        -:    0:Source:/home/workspace/src/mod_aux.c
        -:    1:/*
        -:    2: * mod_aux.c
        -:    3: *
        -:    4: * Copyright (c) 2005, 2006, 2008, 2009, 2012-2014
        -:    5: *	libchewing Core Team. See ChangeLog for details.
        -:    6: *
        -:    7: * See the file "COPYING" for information on usage and redistribution
        -:    8: * of this file.
        -:    9: */
        -:   10:
        -:   11:/**
        -:   12: * @file mod_aux.c
        -:   13: * @brief Auxiliary module
        -:   14: */
        -:   15:
        -:   16:#include <string.h>
        -:   17:#include <stdlib.h>
        -:   18:
        -:   19:#include "global.h"
        -:   20:#include "chewing-private.h"
        -:   21:#include "bopomofo-private.h"
        -:   22:#include "chewingio.h"
        -:   23:#include "chewing-utf8-util.h"
        -:   24:#include "private.h"
        -:   25:
        -:   26:/**
        -:   27: * @param ctx handle to Chewing IM context
        -:   28: * @retval TRUE if it currnet input state is at the "end-of-a-char"
        -:   29: */
       41:   30:CHEWING_API int chewing_commit_Check(ChewingContext *ctx)
        -:   31:{
        -:   32:    ChewingData *pgdata;
        -:   33:
       41:   34:    if (!ctx) {
    #####:   35:        return -1;
        -:   36:    }
       41:   37:    pgdata = ctx->data;
        -:   38:
       41:   39:    LOG_API("");
        -:   40:
       41:   41:    return ! !(ctx->output->keystrokeRtn & KEYSTROKE_COMMIT);
        -:   42:}
        -:   43:
        -:   44:/**
        -:   45: * @param ctx handle to Chewing IM context
        -:   46: *
        -:   47: * retrun current commit string, regardless current input state.
        -:   48: * Alwasy returns a char pointer, caller must free it.
        -:   49: */
       35:   50:CHEWING_API char *chewing_commit_String(ChewingContext *ctx)
        -:   51:{
        -:   52:    ChewingData *pgdata;
        -:   53:
       35:   54:    if (!ctx) {
    #####:   55:        return strdup("");
        -:   56:    }
       35:   57:    pgdata = ctx->data;
        -:   58:
       35:   59:    LOG_API("");
        -:   60:
       35:   61:    return strdup(ctx->output->commitBuf);
        -:   62:}
        -:   63:
        -:   64:/**
        -:   65: * @param ctx handle to Chewing IM context
        -:   66: * retrun current commit string, regardless current input state.
        -:   67: * Alwasy returns a const char pointer, you have to clone them immediately,
        -:   68: * if you need.
        -:   69: */
       35:   70:CHEWING_API const char *chewing_commit_String_static(ChewingContext *ctx)
        -:   71:{
        -:   72:    ChewingData *pgdata;
        -:   73:
       35:   74:    if (!ctx) {
    #####:   75:        return "";
        -:   76:    }
       35:   77:    pgdata = ctx->data;
        -:   78:
       35:   79:    LOG_API("");
        -:   80:
       35:   81:    return ctx->output->commitBuf;
        -:   82:}
        -:   83:
       18:   84:CHEWING_API int chewing_buffer_Check(ChewingContext *ctx)
        -:   85:{
        -:   86:    ChewingData *pgdata;
        -:   87:
       18:   88:    if (!ctx) {
    #####:   89:        return -1;
        -:   90:    }
       18:   91:    pgdata = ctx->data;
        -:   92:
       18:   93:    LOG_API("");
        -:   94:
       18:   95:    return (ctx->output->chiSymbolBufLen != 0);
        -:   96:}
        -:   97:
       18:   98:CHEWING_API int chewing_buffer_Len(ChewingContext *ctx)
        -:   99:{
        -:  100:    ChewingData *pgdata;
        -:  101:
       18:  102:    if (!ctx) {
    #####:  103:        return -1;
        -:  104:    }
       18:  105:    pgdata = ctx->data;
        -:  106:
       18:  107:    LOG_API("");
        -:  108:
       18:  109:    return ctx->output->chiSymbolBufLen;
        -:  110:}
        -:  111:
       18:  112:CHEWING_API char *chewing_buffer_String(ChewingContext *ctx)
        -:  113:{
        -:  114:    ChewingData *pgdata;
        -:  115:
       18:  116:    if (!ctx) {
    #####:  117:        return strdup("");
        -:  118:    }
       18:  119:    pgdata = ctx->data;
        -:  120:
       18:  121:    LOG_API("");
        -:  122:
       18:  123:    return strdup(ctx->output->preeditBuf);
        -:  124:}
        -:  125:
       18:  126:CHEWING_API const char *chewing_buffer_String_static(ChewingContext *ctx)
        -:  127:{
        -:  128:    ChewingData *pgdata;
        -:  129:
       18:  130:    if (!ctx) {
    #####:  131:        return "";
        -:  132:    }
       18:  133:    pgdata = ctx->data;
        -:  134:
       18:  135:    LOG_API("");
        -:  136:
       18:  137:    return ctx->output->preeditBuf;
        -:  138:}
        -:  139:
        -:  140:/**
        -:  141: * @param ctx handle to Chewing IM context
        -:  142: *
        -:  143: * Alwasy returns a const char pointer, you have to clone them immediately,
        -:  144: * if you need.
        -:  145: */
       30:  146:CHEWING_API const char *chewing_bopomofo_String_static(ChewingContext *ctx)
        -:  147:{
        -:  148:    ChewingData *pgdata;
        -:  149:
       30:  150:    if (!ctx) {
    #####:  151:        return "";
        -:  152:    }
       30:  153:    pgdata = ctx->data;
        -:  154:
       30:  155:    LOG_API("");
        -:  156:
       30:  157:    return ctx->output->bopomofoBuf;
        -:  158:}
        -:  159:
       30:  160:CHEWING_API int chewing_bopomofo_Check(ChewingContext *ctx)
        -:  161:{
        -:  162:    ChewingData *pgdata;
        -:  163:
       30:  164:    if (!ctx) {
    #####:  165:        return -1;
        -:  166:    }
       30:  167:    pgdata = ctx->data;
        -:  168:
       30:  169:    LOG_API("");
        -:  170:
       30:  171:    return ctx->output->bopomofoBuf[0] != 0;
        -:  172:}
        -:  173:
        8:  174:CHEWING_API int chewing_cursor_Current(ChewingContext *ctx)
        -:  175:{
        -:  176:    ChewingData *pgdata;
        -:  177:
        8:  178:    if (!ctx) {
    #####:  179:        return -1;
        -:  180:    }
        8:  181:    pgdata = ctx->data;
        -:  182:
        8:  183:    LOG_API("");
        -:  184:
        8:  185:    return (ctx->output->chiSymbolCursor);
        -:  186:}
        -:  187:
    #####:  188:CHEWING_API int chewing_cand_CheckDone(ChewingContext *ctx)
        -:  189:{
        -:  190:    ChewingData *pgdata;
        -:  191:
    #####:  192:    if (!ctx) {
    #####:  193:        return -1;
        -:  194:    }
    #####:  195:    pgdata = ctx->data;
        -:  196:
    #####:  197:    LOG_API("");
        -:  198:
    #####:  199:    return (!ctx->output->pci);
        -:  200:}
        -:  201:
        2:  202:CHEWING_API int chewing_cand_TotalPage(ChewingContext *ctx)
        -:  203:{
        -:  204:    ChewingData *pgdata;
        -:  205:
        2:  206:    if (!ctx) {
    #####:  207:        return -1;
        -:  208:    }
        2:  209:    pgdata = ctx->data;
        -:  210:
        2:  211:    LOG_API("");
        -:  212:
       2*:  213:    return (ctx->output->pci ? ctx->output->pci->nPage : 0);
        -:  214:}
        -:  215:
    #####:  216:CHEWING_API int chewing_cand_ChoicePerPage(ChewingContext *ctx)
        -:  217:{
        -:  218:    ChewingData *pgdata;
        -:  219:
    #####:  220:    if (!ctx) {
    #####:  221:        return -1;
        -:  222:    }
    #####:  223:    pgdata = ctx->data;
        -:  224:
    #####:  225:    LOG_API("");
        -:  226:
    #####:  227:    return (ctx->output->pci ? ctx->output->pci->nChoicePerPage : 0);
        -:  228:}
        -:  229:
       28:  230:CHEWING_API int chewing_cand_TotalChoice(ChewingContext *ctx)
        -:  231:{
        -:  232:    ChewingData *pgdata;
        -:  233:
       28:  234:    if (!ctx) {
    #####:  235:        return -1;
        -:  236:    }
       28:  237:    pgdata = ctx->data;
        -:  238:
       28:  239:    LOG_API("");
        -:  240:
      28*:  241:    return (ctx->output->pci ? ctx->output->pci->nTotalChoice : 0);
        -:  242:}
        -:  243:
        7:  244:CHEWING_API int chewing_cand_CurrentPage(ChewingContext *ctx)
        -:  245:{
        -:  246:    ChewingData *pgdata;
        -:  247:
        7:  248:    if (!ctx) {
    #####:  249:        return -1;
        -:  250:    }
        7:  251:    pgdata = ctx->data;
        -:  252:
        7:  253:    LOG_API("");
        -:  254:
       7*:  255:    return (ctx->output->pci ? ctx->output->pci->pageNo : -1);
        -:  256:}
        -:  257:
       27:  258:CHEWING_API void chewing_cand_Enumerate(ChewingContext *ctx)
        -:  259:{
        -:  260:    ChewingData *pgdata;
        -:  261:
       27:  262:    if (!ctx) {
    #####:  263:        return;
        -:  264:    }
       27:  265:    pgdata = ctx->data;
        -:  266:
       27:  267:    LOG_API("");
        -:  268:
       27:  269:    ctx->cand_no = ctx->output->pci->pageNo * ctx->output->pci->nChoicePerPage;
        -:  270:}
        -:  271:
       45:  272:CHEWING_API int chewing_cand_hasNext(ChewingContext *ctx)
        -:  273:{
        -:  274:    ChewingData *pgdata;
        -:  275:
       45:  276:    if (!ctx) {
    #####:  277:        return -1;
        -:  278:    }
       45:  279:    pgdata = ctx->data;
        -:  280:
       45:  281:    LOG_API("");
        -:  282:
       45:  283:    return (ctx->cand_no < ctx->output->pci->nTotalChoice);
        -:  284:}
        -:  285:
       33:  286:CHEWING_API const char *chewing_cand_String_static(ChewingContext *ctx)
        -:  287:{
        -:  288:    ChewingData *pgdata;
        -:  289:    char *s;
        -:  290:
       33:  291:    if (!ctx) {
    #####:  292:        return "";
        -:  293:    }
       33:  294:    pgdata = ctx->data;
        -:  295:
       33:  296:    LOG_API("");
        -:  297:
       33:  298:    if (chewing_cand_hasNext(ctx)) {
       27:  299:        s = ctx->output->pci->totalChoiceStr[ctx->cand_no];
       27:  300:        ctx->cand_no++;
        -:  301:    } else {
        6:  302:        s = "";
        -:  303:    }
       33:  304:    return s;
        -:  305:}
        -:  306:
       30:  307:CHEWING_API char *chewing_cand_String(ChewingContext *ctx)
        -:  308:{
       30:  309:    return strdup(chewing_cand_String_static(ctx));
        -:  310:}
        -:  311:
        6:  312:CHEWING_API void chewing_interval_Enumerate(ChewingContext *ctx)
        -:  313:{
        -:  314:    ChewingData *pgdata;
        -:  315:
        6:  316:    if (!ctx) {
    #####:  317:        return;
        -:  318:    }
        6:  319:    pgdata = ctx->data;
        -:  320:
        6:  321:    LOG_API("");
        -:  322:
        6:  323:    ctx->it_no = 0;
        -:  324:}
        -:  325:
       23:  326:CHEWING_API int chewing_interval_hasNext(ChewingContext *ctx)
        -:  327:{
        -:  328:    ChewingData *pgdata;
        -:  329:
       23:  330:    if (!ctx) {
    #####:  331:        return -1;
        -:  332:    }
       23:  333:    pgdata = ctx->data;
        -:  334:
       23:  335:    LOG_API("");
        -:  336:
       23:  337:    return (ctx->it_no < ctx->output->nDispInterval);
        -:  338:}
        -:  339:
        9:  340:CHEWING_API void chewing_interval_Get(ChewingContext *ctx, IntervalType * it)
        -:  341:{
        -:  342:    ChewingData *pgdata;
        -:  343:
        9:  344:    if (!ctx) {
    #####:  345:        return;
        -:  346:    }
        9:  347:    pgdata = ctx->data;
        -:  348:
        9:  349:    LOG_API("");
        -:  350:
        9:  351:    if (chewing_interval_hasNext(ctx)) {
        9:  352:        if (it) {
        9:  353:            it->from = ctx->output->dispInterval[ctx->it_no].from;
        9:  354:            it->to = ctx->output->dispInterval[ctx->it_no].to;
        -:  355:        }
        9:  356:        ctx->it_no++;
        -:  357:    }
        -:  358:}
        -:  359:
    #####:  360:CHEWING_API int chewing_aux_Check(ChewingContext *ctx)
        -:  361:{
        -:  362:    ChewingData *pgdata;
        -:  363:
    #####:  364:    if (!ctx) {
    #####:  365:        return -1;
        -:  366:    }
    #####:  367:    pgdata = ctx->data;
        -:  368:
    #####:  369:    LOG_API("");
        -:  370:
    #####:  371:    return (ctx->data->bShowMsg);
        -:  372:}
        -:  373:
    #####:  374:CHEWING_API int chewing_aux_Length(ChewingContext *ctx)
        -:  375:{
        -:  376:    ChewingData *pgdata;
        -:  377:
    #####:  378:    if (!ctx) {
    #####:  379:        return -1;
        -:  380:    }
    #####:  381:    pgdata = ctx->data;
        -:  382:
    #####:  383:    LOG_API("");
        -:  384:
    #####:  385:    return (ctx->data->bShowMsg ? ctx->data->showMsgLen : 0);
        -:  386:}
        -:  387:
    #####:  388:CHEWING_API const char *chewing_aux_String_static(ChewingContext *ctx)
        -:  389:{
        -:  390:    ChewingData *pgdata;
        -:  391:
    #####:  392:    if (!ctx) {
    #####:  393:        return "";
        -:  394:    }
    #####:  395:    pgdata = ctx->data;
        -:  396:
    #####:  397:    LOG_API("");
        -:  398:
    #####:  399:    return ctx->data->showMsg;
        -:  400:}
        -:  401:
    #####:  402:CHEWING_API char *chewing_aux_String(ChewingContext *ctx)
        -:  403:{
        -:  404:    ChewingData *pgdata;
        -:  405:
    #####:  406:    if (!ctx) {
    #####:  407:        return strdup("");
        -:  408:    }
    #####:  409:    pgdata = ctx->data;
        -:  410:
    #####:  411:    LOG_API("");
        -:  412:
    #####:  413:    return strdup(chewing_aux_String_static(ctx));
        -:  414:}
        -:  415:
        6:  416:CHEWING_API int chewing_keystroke_CheckIgnore(ChewingContext *ctx)
        -:  417:{
        -:  418:    ChewingData *pgdata;
        -:  419:
        6:  420:    if (!ctx) {
    #####:  421:        return -1;
        -:  422:    }
        6:  423:    pgdata = ctx->data;
        -:  424:
        6:  425:    LOG_API("");
        -:  426:
        6:  427:    return ! !(ctx->output->keystrokeRtn & KEYSTROKE_IGNORE);
        -:  428:}
        -:  429:
        6:  430:CHEWING_API int chewing_keystroke_CheckAbsorb(ChewingContext *ctx)
        -:  431:{
        -:  432:    ChewingData *pgdata;
        -:  433:
        6:  434:    if (!ctx) {
    #####:  435:        return -1;
        -:  436:    }
        6:  437:    pgdata = ctx->data;
        -:  438:
        6:  439:    LOG_API("");
        -:  440:
        6:  441:    return ! !(ctx->output->keystrokeRtn & KEYSTROKE_ABSORB);
        -:  442:}
        -:  443:
    #####:  444:CHEWING_API int chewing_kbtype_Total(ChewingContext *ctx UNUSED)
        -:  445:{
    #####:  446:    return KB_TYPE_NUM;
        -:  447:}
        -:  448:
    #####:  449:CHEWING_API void chewing_kbtype_Enumerate(ChewingContext *ctx)
        -:  450:{
        -:  451:    ChewingData *pgdata;
        -:  452:
    #####:  453:    if (!ctx) {
    #####:  454:        return;
        -:  455:    }
    #####:  456:    pgdata = ctx->data;
        -:  457:
    #####:  458:    LOG_API("");
        -:  459:
    #####:  460:    ctx->kb_no = 0;
        -:  461:}
        -:  462:
    #####:  463:CHEWING_API int chewing_kbtype_hasNext(ChewingContext *ctx)
        -:  464:{
        -:  465:    ChewingData *pgdata;
        -:  466:
    #####:  467:    if (!ctx) {
    #####:  468:        return -1;
        -:  469:    }
    #####:  470:    pgdata = ctx->data;
        -:  471:
    #####:  472:    LOG_API("");
        -:  473:
    #####:  474:    return ctx->kb_no < KB_TYPE_NUM;
        -:  475:}
        -:  476:
        -:  477:extern const char *const kb_type_str[];
        -:  478:
    #####:  479:CHEWING_API const char *chewing_kbtype_String_static(ChewingContext *ctx)
        -:  480:{
        -:  481:    ChewingData *pgdata;
        -:  482:    char *s;
        -:  483:
    #####:  484:    if (!ctx) {
    #####:  485:        return "";
        -:  486:    }
    #####:  487:    pgdata = ctx->data;
        -:  488:
    #####:  489:    LOG_API("");
        -:  490:
    #####:  491:    if (chewing_kbtype_hasNext(ctx)) {
    #####:  492:        s = (char *) kb_type_str[ctx->kb_no];
    #####:  493:        ctx->kb_no++;
        -:  494:    } else {
    #####:  495:        s = "";
        -:  496:    }
    #####:  497:    return s;
        -:  498:}
        -:  499:
    #####:  500:CHEWING_API char *chewing_kbtype_String(ChewingContext *ctx)
        -:  501:{
        -:  502:    ChewingData *pgdata;
        -:  503:
    #####:  504:    if (!ctx) {
    #####:  505:        return strdup("");
        -:  506:    }
    #####:  507:    pgdata = ctx->data;
        -:  508:
    #####:  509:    LOG_API("");
        -:  510:
    #####:  511:    return strdup(chewing_kbtype_String_static(ctx));
        -:  512:}
