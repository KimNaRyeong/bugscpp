        -:    0:Source:/home/workspace/src/mod_aux.c
        -:    1:/*
        -:    2: * mod_aux.c
        -:    3: *
        -:    4: * Copyright (c) 2005, 2006, 2008, 2009, 2012-2014
        -:    5: *	libchewing Core Team. See ChangeLog for details.
        -:    6: *
        -:    7: * See the file "COPYING" for information on usage and redistribution
        -:    8: * of this file.
        -:    9: */
        -:   10:
        -:   11:/**
        -:   12: * @file mod_aux.c
        -:   13: * @brief Auxiliary module
        -:   14: */
        -:   15:
        -:   16:#include <string.h>
        -:   17:#include <stdlib.h>
        -:   18:
        -:   19:#include "global.h"
        -:   20:#include "chewing-private.h"
        -:   21:#include "bopomofo-private.h"
        -:   22:#include "chewingio.h"
        -:   23:#include "chewing-utf8-util.h"
        -:   24:#include "private.h"
        -:   25:
        -:   26:/**
        -:   27: * @param ctx handle to Chewing IM context
        -:   28: * @retval TRUE if it currnet input state is at the "end-of-a-char"
        -:   29: */
        1:   30:CHEWING_API int chewing_commit_Check(ChewingContext *ctx)
        -:   31:{
        -:   32:    ChewingData *pgdata;
        -:   33:
        1:   34:    if (!ctx) {
        1:   35:        return -1;
        -:   36:    }
    #####:   37:    pgdata = ctx->data;
        -:   38:
    #####:   39:    LOG_API("");
        -:   40:
    #####:   41:    return ! !(ctx->output->keystrokeRtn & KEYSTROKE_COMMIT);
        -:   42:}
        -:   43:
        -:   44:/**
        -:   45: * @param ctx handle to Chewing IM context
        -:   46: *
        -:   47: * retrun current commit string, regardless current input state.
        -:   48: * Alwasy returns a char pointer, caller must free it.
        -:   49: */
        1:   50:CHEWING_API char *chewing_commit_String(ChewingContext *ctx)
        -:   51:{
        -:   52:    ChewingData *pgdata;
        -:   53:
        1:   54:    if (!ctx) {
        1:   55:        return strdup("");
        -:   56:    }
    #####:   57:    pgdata = ctx->data;
        -:   58:
    #####:   59:    LOG_API("");
        -:   60:
    #####:   61:    return strdup(ctx->output->commitBuf);
        -:   62:}
        -:   63:
        -:   64:/**
        -:   65: * @param ctx handle to Chewing IM context
        -:   66: * retrun current commit string, regardless current input state.
        -:   67: * Alwasy returns a const char pointer, you have to clone them immediately,
        -:   68: * if you need.
        -:   69: */
        1:   70:CHEWING_API const char *chewing_commit_String_static(ChewingContext *ctx)
        -:   71:{
        -:   72:    ChewingData *pgdata;
        -:   73:
        1:   74:    if (!ctx) {
        1:   75:        return "";
        -:   76:    }
    #####:   77:    pgdata = ctx->data;
        -:   78:
    #####:   79:    LOG_API("");
        -:   80:
    #####:   81:    return ctx->output->commitBuf;
        -:   82:}
        -:   83:
        1:   84:CHEWING_API int chewing_buffer_Check(ChewingContext *ctx)
        -:   85:{
        -:   86:    ChewingData *pgdata;
        -:   87:
        1:   88:    if (!ctx) {
        1:   89:        return -1;
        -:   90:    }
    #####:   91:    pgdata = ctx->data;
        -:   92:
    #####:   93:    LOG_API("");
        -:   94:
    #####:   95:    return (ctx->output->chiSymbolBufLen != 0);
        -:   96:}
        -:   97:
        1:   98:CHEWING_API int chewing_buffer_Len(ChewingContext *ctx)
        -:   99:{
        -:  100:    ChewingData *pgdata;
        -:  101:
        1:  102:    if (!ctx) {
        1:  103:        return -1;
        -:  104:    }
    #####:  105:    pgdata = ctx->data;
        -:  106:
    #####:  107:    LOG_API("");
        -:  108:
    #####:  109:    return ctx->output->chiSymbolBufLen;
        -:  110:}
        -:  111:
        1:  112:CHEWING_API char *chewing_buffer_String(ChewingContext *ctx)
        -:  113:{
        -:  114:    ChewingData *pgdata;
        -:  115:
        1:  116:    if (!ctx) {
        1:  117:        return strdup("");
        -:  118:    }
    #####:  119:    pgdata = ctx->data;
        -:  120:
    #####:  121:    LOG_API("");
        -:  122:
    #####:  123:    return strdup(ctx->output->preeditBuf);
        -:  124:}
        -:  125:
        1:  126:CHEWING_API const char *chewing_buffer_String_static(ChewingContext *ctx)
        -:  127:{
        -:  128:    ChewingData *pgdata;
        -:  129:
        1:  130:    if (!ctx) {
        1:  131:        return "";
        -:  132:    }
    #####:  133:    pgdata = ctx->data;
        -:  134:
    #####:  135:    LOG_API("");
        -:  136:
    #####:  137:    return ctx->output->preeditBuf;
        -:  138:}
        -:  139:
        -:  140:/**
        -:  141: * @param ctx handle to Chewing IM context
        -:  142: *
        -:  143: * Alwasy returns a const char pointer, you have to clone them immediately,
        -:  144: * if you need.
        -:  145: */
        2:  146:CHEWING_API const char *chewing_bopomofo_String_static(ChewingContext *ctx)
        -:  147:{
        -:  148:    ChewingData *pgdata;
        -:  149:
        2:  150:    if (!ctx) {
        2:  151:        return "";
        -:  152:    }
    #####:  153:    pgdata = ctx->data;
        -:  154:
    #####:  155:    LOG_API("");
        -:  156:
    #####:  157:    return ctx->output->bopomofoBuf;
        -:  158:}
        -:  159:
        2:  160:CHEWING_API int chewing_bopomofo_Check(ChewingContext *ctx)
        -:  161:{
        -:  162:    ChewingData *pgdata;
        -:  163:
        2:  164:    if (!ctx) {
        2:  165:        return -1;
        -:  166:    }
    #####:  167:    pgdata = ctx->data;
        -:  168:
    #####:  169:    LOG_API("");
        -:  170:
    #####:  171:    return ctx->output->bopomofoBuf[0] != 0;
        -:  172:}
        -:  173:
        1:  174:CHEWING_API int chewing_cursor_Current(ChewingContext *ctx)
        -:  175:{
        -:  176:    ChewingData *pgdata;
        -:  177:
        1:  178:    if (!ctx) {
        1:  179:        return -1;
        -:  180:    }
    #####:  181:    pgdata = ctx->data;
        -:  182:
    #####:  183:    LOG_API("");
        -:  184:
    #####:  185:    return (ctx->output->chiSymbolCursor);
        -:  186:}
        -:  187:
        1:  188:CHEWING_API int chewing_cand_CheckDone(ChewingContext *ctx)
        -:  189:{
        -:  190:    ChewingData *pgdata;
        -:  191:
        1:  192:    if (!ctx) {
        1:  193:        return -1;
        -:  194:    }
    #####:  195:    pgdata = ctx->data;
        -:  196:
    #####:  197:    LOG_API("");
        -:  198:
    #####:  199:    return (!ctx->output->pci);
        -:  200:}
        -:  201:
        1:  202:CHEWING_API int chewing_cand_TotalPage(ChewingContext *ctx)
        -:  203:{
        -:  204:    ChewingData *pgdata;
        -:  205:
        1:  206:    if (!ctx) {
        1:  207:        return -1;
        -:  208:    }
    #####:  209:    pgdata = ctx->data;
        -:  210:
    #####:  211:    LOG_API("");
        -:  212:
    #####:  213:    return (ctx->output->pci ? ctx->output->pci->nPage : 0);
        -:  214:}
        -:  215:
        1:  216:CHEWING_API int chewing_cand_ChoicePerPage(ChewingContext *ctx)
        -:  217:{
        -:  218:    ChewingData *pgdata;
        -:  219:
        1:  220:    if (!ctx) {
        1:  221:        return -1;
        -:  222:    }
    #####:  223:    pgdata = ctx->data;
        -:  224:
    #####:  225:    LOG_API("");
        -:  226:
    #####:  227:    return (ctx->output->pci ? ctx->output->pci->nChoicePerPage : 0);
        -:  228:}
        -:  229:
        1:  230:CHEWING_API int chewing_cand_TotalChoice(ChewingContext *ctx)
        -:  231:{
        -:  232:    ChewingData *pgdata;
        -:  233:
        1:  234:    if (!ctx) {
        1:  235:        return -1;
        -:  236:    }
    #####:  237:    pgdata = ctx->data;
        -:  238:
    #####:  239:    LOG_API("");
        -:  240:
    #####:  241:    return (ctx->output->pci ? ctx->output->pci->nTotalChoice : 0);
        -:  242:}
        -:  243:
        1:  244:CHEWING_API int chewing_cand_CurrentPage(ChewingContext *ctx)
        -:  245:{
        -:  246:    ChewingData *pgdata;
        -:  247:
        1:  248:    if (!ctx) {
        1:  249:        return -1;
        -:  250:    }
    #####:  251:    pgdata = ctx->data;
        -:  252:
    #####:  253:    LOG_API("");
        -:  254:
    #####:  255:    return (ctx->output->pci ? ctx->output->pci->pageNo : -1);
        -:  256:}
        -:  257:
        1:  258:CHEWING_API void chewing_cand_Enumerate(ChewingContext *ctx)
        -:  259:{
        -:  260:    ChewingData *pgdata;
        -:  261:
        1:  262:    if (!ctx) {
        1:  263:        return;
        -:  264:    }
    #####:  265:    pgdata = ctx->data;
        -:  266:
    #####:  267:    LOG_API("");
        -:  268:
    #####:  269:    ctx->cand_no = ctx->output->pci->pageNo * ctx->output->pci->nChoicePerPage;
        -:  270:}
        -:  271:
        1:  272:CHEWING_API int chewing_cand_hasNext(ChewingContext *ctx)
        -:  273:{
        -:  274:    ChewingData *pgdata;
        -:  275:
        1:  276:    if (!ctx) {
        1:  277:        return -1;
        -:  278:    }
    #####:  279:    pgdata = ctx->data;
        -:  280:
    #####:  281:    LOG_API("");
        -:  282:
    #####:  283:    return (ctx->cand_no < ctx->output->pci->nTotalChoice);
        -:  284:}
        -:  285:
        2:  286:CHEWING_API const char *chewing_cand_String_static(ChewingContext *ctx)
        -:  287:{
        -:  288:    ChewingData *pgdata;
        -:  289:    char *s;
        -:  290:
        2:  291:    if (!ctx) {
        2:  292:        return "";
        -:  293:    }
    #####:  294:    pgdata = ctx->data;
        -:  295:
    #####:  296:    LOG_API("");
        -:  297:
    #####:  298:    if (chewing_cand_hasNext(ctx)) {
    #####:  299:        s = ctx->output->pci->totalChoiceStr[ctx->cand_no];
    #####:  300:        ctx->cand_no++;
        -:  301:    } else {
    #####:  302:        s = "";
        -:  303:    }
    #####:  304:    return s;
        -:  305:}
        -:  306:
        1:  307:CHEWING_API char *chewing_cand_String(ChewingContext *ctx)
        -:  308:{
        1:  309:    return strdup(chewing_cand_String_static(ctx));
        -:  310:}
        -:  311:
        1:  312:CHEWING_API void chewing_interval_Enumerate(ChewingContext *ctx)
        -:  313:{
        -:  314:    ChewingData *pgdata;
        -:  315:
        1:  316:    if (!ctx) {
        1:  317:        return;
        -:  318:    }
    #####:  319:    pgdata = ctx->data;
        -:  320:
    #####:  321:    LOG_API("");
        -:  322:
    #####:  323:    ctx->it_no = 0;
        -:  324:}
        -:  325:
        1:  326:CHEWING_API int chewing_interval_hasNext(ChewingContext *ctx)
        -:  327:{
        -:  328:    ChewingData *pgdata;
        -:  329:
        1:  330:    if (!ctx) {
        1:  331:        return -1;
        -:  332:    }
    #####:  333:    pgdata = ctx->data;
        -:  334:
    #####:  335:    LOG_API("");
        -:  336:
    #####:  337:    return (ctx->it_no < ctx->output->nDispInterval);
        -:  338:}
        -:  339:
        1:  340:CHEWING_API void chewing_interval_Get(ChewingContext *ctx, IntervalType * it)
        -:  341:{
        -:  342:    ChewingData *pgdata;
        -:  343:
        1:  344:    if (!ctx) {
        1:  345:        return;
        -:  346:    }
    #####:  347:    pgdata = ctx->data;
        -:  348:
    #####:  349:    LOG_API("");
        -:  350:
    #####:  351:    if (chewing_interval_hasNext(ctx)) {
    #####:  352:        if (it) {
    #####:  353:            it->from = ctx->output->dispInterval[ctx->it_no].from;
    #####:  354:            it->to = ctx->output->dispInterval[ctx->it_no].to;
        -:  355:        }
    #####:  356:        ctx->it_no++;
        -:  357:    }
        -:  358:}
        -:  359:
        1:  360:CHEWING_API int chewing_aux_Check(ChewingContext *ctx)
        -:  361:{
        -:  362:    ChewingData *pgdata;
        -:  363:
        1:  364:    if (!ctx) {
        1:  365:        return -1;
        -:  366:    }
    #####:  367:    pgdata = ctx->data;
        -:  368:
    #####:  369:    LOG_API("");
        -:  370:
    #####:  371:    return (ctx->data->bShowMsg);
        -:  372:}
        -:  373:
        1:  374:CHEWING_API int chewing_aux_Length(ChewingContext *ctx)
        -:  375:{
        -:  376:    ChewingData *pgdata;
        -:  377:
        1:  378:    if (!ctx) {
        1:  379:        return -1;
        -:  380:    }
    #####:  381:    pgdata = ctx->data;
        -:  382:
    #####:  383:    LOG_API("");
        -:  384:
    #####:  385:    return (ctx->data->bShowMsg ? ctx->data->showMsgLen : 0);
        -:  386:}
        -:  387:
        1:  388:CHEWING_API const char *chewing_aux_String_static(ChewingContext *ctx)
        -:  389:{
        -:  390:    ChewingData *pgdata;
        -:  391:
        1:  392:    if (!ctx) {
        1:  393:        return "";
        -:  394:    }
    #####:  395:    pgdata = ctx->data;
        -:  396:
    #####:  397:    LOG_API("");
        -:  398:
    #####:  399:    return ctx->data->showMsg;
        -:  400:}
        -:  401:
        1:  402:CHEWING_API char *chewing_aux_String(ChewingContext *ctx)
        -:  403:{
        -:  404:    ChewingData *pgdata;
        -:  405:
        1:  406:    if (!ctx) {
        1:  407:        return strdup("");
        -:  408:    }
    #####:  409:    pgdata = ctx->data;
        -:  410:
    #####:  411:    LOG_API("");
        -:  412:
    #####:  413:    return strdup(chewing_aux_String_static(ctx));
        -:  414:}
        -:  415:
        1:  416:CHEWING_API int chewing_keystroke_CheckIgnore(ChewingContext *ctx)
        -:  417:{
        -:  418:    ChewingData *pgdata;
        -:  419:
        1:  420:    if (!ctx) {
        1:  421:        return -1;
        -:  422:    }
    #####:  423:    pgdata = ctx->data;
        -:  424:
    #####:  425:    LOG_API("");
        -:  426:
    #####:  427:    return ! !(ctx->output->keystrokeRtn & KEYSTROKE_IGNORE);
        -:  428:}
        -:  429:
        1:  430:CHEWING_API int chewing_keystroke_CheckAbsorb(ChewingContext *ctx)
        -:  431:{
        -:  432:    ChewingData *pgdata;
        -:  433:
        1:  434:    if (!ctx) {
        1:  435:        return -1;
        -:  436:    }
    #####:  437:    pgdata = ctx->data;
        -:  438:
    #####:  439:    LOG_API("");
        -:  440:
    #####:  441:    return ! !(ctx->output->keystrokeRtn & KEYSTROKE_ABSORB);
        -:  442:}
        -:  443:
    #####:  444:CHEWING_API int chewing_kbtype_Total(ChewingContext *ctx UNUSED)
        -:  445:{
    #####:  446:    return KB_TYPE_NUM;
        -:  447:}
        -:  448:
        1:  449:CHEWING_API void chewing_kbtype_Enumerate(ChewingContext *ctx)
        -:  450:{
        -:  451:    ChewingData *pgdata;
        -:  452:
        1:  453:    if (!ctx) {
        1:  454:        return;
        -:  455:    }
    #####:  456:    pgdata = ctx->data;
        -:  457:
    #####:  458:    LOG_API("");
        -:  459:
    #####:  460:    ctx->kb_no = 0;
        -:  461:}
        -:  462:
        1:  463:CHEWING_API int chewing_kbtype_hasNext(ChewingContext *ctx)
        -:  464:{
        -:  465:    ChewingData *pgdata;
        -:  466:
        1:  467:    if (!ctx) {
        1:  468:        return -1;
        -:  469:    }
    #####:  470:    pgdata = ctx->data;
        -:  471:
    #####:  472:    LOG_API("");
        -:  473:
    #####:  474:    return ctx->kb_no < KB_TYPE_NUM;
        -:  475:}
        -:  476:
        -:  477:extern const char *const kb_type_str[];
        -:  478:
        1:  479:CHEWING_API const char *chewing_kbtype_String_static(ChewingContext *ctx)
        -:  480:{
        -:  481:    ChewingData *pgdata;
        -:  482:    char *s;
        -:  483:
        1:  484:    if (!ctx) {
        1:  485:        return "";
        -:  486:    }
    #####:  487:    pgdata = ctx->data;
        -:  488:
    #####:  489:    LOG_API("");
        -:  490:
    #####:  491:    if (chewing_kbtype_hasNext(ctx)) {
    #####:  492:        s = (char *) kb_type_str[ctx->kb_no];
    #####:  493:        ctx->kb_no++;
        -:  494:    } else {
    #####:  495:        s = "";
        -:  496:    }
    #####:  497:    return s;
        -:  498:}
        -:  499:
        1:  500:CHEWING_API char *chewing_kbtype_String(ChewingContext *ctx)
        -:  501:{
        -:  502:    ChewingData *pgdata;
        -:  503:
        1:  504:    if (!ctx) {
        1:  505:        return strdup("");
        -:  506:    }
    #####:  507:    pgdata = ctx->data;
        -:  508:
    #####:  509:    LOG_API("");
        -:  510:
    #####:  511:    return strdup(chewing_kbtype_String_static(ctx));
        -:  512:}
