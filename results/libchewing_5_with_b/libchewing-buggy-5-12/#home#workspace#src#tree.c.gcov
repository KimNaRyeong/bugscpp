        -:    0:Source:/home/workspace/src/tree.c
        -:    1:/**
        -:    2: * tree.c
        -:    3: *
        -:    4: * Copyright (c) 1999, 2000, 2001
        -:    5: *	Lu-chuan Kung and Kang-pen Chen.
        -:    6: *	All rights reserved.
        -:    7: *
        -:    8: * Copyright (c) 2004-2006, 2008, 2010-2014
        -:    9: *	libchewing Core Team. See ChangeLog for details.
        -:   10: *
        -:   11: * See the file "COPYING" for information on usage and redistribution
        -:   12: * of this file.
        -:   13: */
        -:   14:
        -:   15:/**
        -:   16: *	@file tree.c
        -:   17: *	@brief API for accessing the phrase tree.
        -:   18: */
        -:   19:#include <assert.h>
        -:   20:#include <stdio.h>
        -:   21:#include <stdlib.h>
        -:   22:#include <string.h>
        -:   23:
        -:   24:#include "chewing-private.h"
        -:   25:#include "chewing-utf8-util.h"
        -:   26:#include "userphrase-private.h"
        -:   27:#include "global.h"
        -:   28:#include "global-private.h"
        -:   29:#include "dict-private.h"
        -:   30:#include "memory-private.h"
        -:   31:#include "tree-private.h"
        -:   32:#include "private.h"
        -:   33:#include "plat_mmap.h"
        -:   34:#include "chewingutil.h"
        -:   35:
        -:   36:#define INTERVAL_SIZE ( ( MAX_PHONE_SEQ_LEN + 1 ) * MAX_PHONE_SEQ_LEN / 2 )
        -:   37:
        -:   38:typedef struct PhraseIntervalType {
        -:   39:    int from, to, source;
        -:   40:    Phrase *p_phr;
        -:   41:} PhraseIntervalType;
        -:   42:
        -:   43:typedef struct RecordNode {
        -:   44:    int *arrIndex;              /* the index array of the things in "interval" */
        -:   45:    int nInter, score;
        -:   46:    struct RecordNode *next;
        -:   47:    int nMatchCnnct;            /* match how many Cnnct. */
        -:   48:} RecordNode;
        -:   49:
        -:   50:typedef struct TreeDataType {
        -:   51:    int leftmost[MAX_PHONE_SEQ_LEN + 1];
        -:   52:    char graph[MAX_PHONE_SEQ_LEN + 1][MAX_PHONE_SEQ_LEN + 1];
        -:   53:    PhraseIntervalType interval[MAX_INTERVAL];
        -:   54:    int nInterval;
        -:   55:    RecordNode *phList;
        -:   56:    int nPhListLen;
        -:   57:} TreeDataType;
        -:   58:
      114:   59:static int IsContain(IntervalType in1, IntervalType in2)
        -:   60:{
      114:   61:    return (in1.from <= in2.from && in1.to >= in2.to);
        -:   62:}
        -:   63:
       21:   64:int IsIntersect(IntervalType in1, IntervalType in2)
        -:   65:{
       21:   66:    return (max(in1.from, in2.from) < min(in1.to, in2.to));
        -:   67:}
        -:   68:
       84:   69:static int PhraseIntervalContain(PhraseIntervalType in1, PhraseIntervalType in2)
        -:   70:{
       84:   71:    return (in1.from <= in2.from && in1.to >= in2.to);
        -:   72:}
        -:   73:
    #####:   74:static int PhraseIntervalIntersect(PhraseIntervalType in1, PhraseIntervalType in2)
        -:   75:{
    #####:   76:    return (max(in1.from, in2.from) < min(in1.to, in2.to));
        -:   77:}
        -:   78:
        5:   79:void TerminateTree(ChewingData *pgdata)
        -:   80:{
        5:   81:    pgdata->static_data.tree = NULL;
        5:   82:    plat_mmap_close(&pgdata->static_data.tree_mmap);
        5:   83:}
        -:   84:
        -:   85:
        5:   86:int InitTree(ChewingData *pgdata, const char *prefix)
        -:   87:{
        -:   88:    char filename[PATH_MAX];
        -:   89:    size_t len;
        -:   90:    size_t offset;
        -:   91:
        5:   92:    len = snprintf(filename, sizeof(filename), "%s" PLAT_SEPARATOR "%s", prefix, PHONE_TREE_FILE);
        5:   93:    if (len + 1 > sizeof(filename))
    #####:   94:        return -1;
        -:   95:
        5:   96:    plat_mmap_set_invalid(&pgdata->static_data.tree_mmap);
        5:   97:    pgdata->static_data.tree_size = plat_mmap_create(&pgdata->static_data.tree_mmap, filename, FLAG_ATTRIBUTE_READ);
        5:   98:    if (pgdata->static_data.tree_size <= 0)
    #####:   99:        return -1;
        -:  100:
        5:  101:    offset = 0;
        5:  102:    pgdata->static_data.tree =
        5:  103:        (const TreeType *) plat_mmap_set_view(&pgdata->static_data.tree_mmap, &offset, &pgdata->static_data.tree_size);
        5:  104:    if (!pgdata->static_data.tree)
    #####:  105:        return -1;
        -:  106:
        5:  107:    return 0;
        -:  108:}
        -:  109:
       94:  110:static int CheckBreakpoint(int from, int to, int bArrBrkpt[])
        -:  111:{
        -:  112:    int i;
        -:  113:
      116:  114:    for (i = from + 1; i < to; i++)
       22:  115:        if (bArrBrkpt[i])
    #####:  116:            return 0;
       94:  117:    return 1;
        -:  118:}
        -:  119:
       14:  120:static int CheckUserChoose(ChewingData *pgdata,
        -:  121:                           uint16_t *new_phoneSeq, int from, int to,
        -:  122:                           Phrase **pp_phr,
        -:  123:                           char selectStr[][MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1],
        -:  124:                           IntervalType selectInterval[], int nSelect)
        -:  125:{
        -:  126:    IntervalType inte, c;
        -:  127:    int chno, len;
        -:  128:    int user_alloc;
        -:  129:    UserPhraseData *pUserPhraseData;
       14:  130:    Phrase *p_phr = ALC(Phrase, 1);
        -:  131:
      14*:  132:    assert(p_phr);
       14:  133:    inte.from = from;
       14:  134:    inte.to = to;
       14:  135:    *pp_phr = NULL;
        -:  136:
        -:  137:    /* pass 1
        -:  138:     * if these exist one selected interval which is not contained by inte
        -:  139:     * but has intersection with inte, then inte is an unacceptable interval
        -:  140:     */
       22:  141:    for (chno = 0; chno < nSelect; chno++) {
       10:  142:        c = selectInterval[chno];
       10:  143:        if (IsIntersect(inte, c) && !IsContain(inte, c)) {
        2:  144:            free(p_phr);
        2:  145:            return 0;
        -:  146:        }
        -:  147:    }
        -:  148:
        -:  149:    /* pass 2
        -:  150:     * if there exist one phrase satisfied all selectStr then return 1, else return 0.
        -:  151:     * also store the phrase with highest freq
        -:  152:     */
       12:  153:    pUserPhraseData = UserGetPhraseFirst(pgdata, new_phoneSeq);
       12:  154:    p_phr->freq = -1;
        -:  155:    do {
       20:  156:        for (chno = 0; chno < nSelect; chno++) {
        8:  157:            c = selectInterval[chno];
        -:  158:
        8:  159:            if (IsContain(inte, c)) {
        -:  160:                /*
        -:  161:                 * find a phrase of ph_id where the text contains
        -:  162:                 * 'selectStr[chno]' test if not ok then return 0,
        -:  163:                 * if ok then continue to test. */
        8:  164:                len = c.to - c.from;
        8:  165:                if (memcmp(ueStrSeek(pUserPhraseData->wordSeq, c.from - from),
        8:  166:                           selectStr[chno], ueStrNBytes(selectStr[chno], len)))
    #####:  167:                    break;
        -:  168:            }
        -:  169:
        -:  170:        }
       12:  171:        if (chno == nSelect) {
        -:  172:            /* save phrase data to "pp_phr" */
       12:  173:            if (pUserPhraseData->userfreq > p_phr->freq) {
       12:  174:                if ((user_alloc = (to - from)) > 0) {
       12:  175:                    ueStrNCpy(p_phr->phrase, pUserPhraseData->wordSeq, user_alloc, 1);
        -:  176:                }
       12:  177:                p_phr->freq = pUserPhraseData->userfreq;
       12:  178:                *pp_phr = p_phr;
        -:  179:            }
        -:  180:        }
       12:  181:    } while ((pUserPhraseData = UserGetPhraseNext(pgdata, new_phoneSeq)) != NULL);
       12:  182:    UserGetPhraseEnd(pgdata, new_phoneSeq);
        -:  183:
       12:  184:    if (p_phr->freq != -1)
       12:  185:        return 1;
        -:  186:
    #####:  187:    free(p_phr);
    #####:  188:    return 0;
        -:  189:}
        -:  190:
        -:  191:/*
        -:  192: * phrase is said to satisfy a choose interval if
        -:  193: * their intersections are the same */
       92:  194:static int CheckChoose(ChewingData *pgdata,
        -:  195:                       const TreeType *phrase_parent, int from, int to, Phrase **pp_phr,
        -:  196:                       char selectStr[][MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1],
        -:  197:                       IntervalType selectInterval[], int nSelect)
        -:  198:{
        -:  199:    IntervalType inte, c;
        -:  200:    int chno, len;
       92:  201:    Phrase *phrase = ALC(Phrase, 1);
        -:  202:
      92*:  203:    assert(phrase);
       92:  204:    inte.from = from;
       92:  205:    inte.to = to;
       92:  206:    *pp_phr = NULL;
        -:  207:
        -:  208:    /* if there exist one phrase satisfied all selectStr then return 1, else return 0. */
       92:  209:    GetPhraseFirst(pgdata, phrase, phrase_parent);
        -:  210:    do {
      184:  211:        for (chno = 0; chno < nSelect; chno++) {
       96:  212:            c = selectInterval[chno];
        -:  213:
       96:  214:            if (IsContain(inte, c)) {
        -:  215:                /* find a phrase under phrase_parent where the text contains
        -:  216:                 * 'selectStr[chno]' test if not ok then return 0, if ok
        -:  217:                 * then continue to test
        -:  218:                 */
       90:  219:                len = c.to - c.from;
       90:  220:                if (memcmp(ueStrSeek(phrase->phrase, c.from - from),
       90:  221:                           selectStr[chno], ueStrNBytes(selectStr[chno], len)))
       80:  222:                    break;
        6:  223:            } else if (IsIntersect(inte, selectInterval[chno])) {
        4:  224:                free(phrase);
        4:  225:                return 0;
        -:  226:            }
        -:  227:        }
      168:  228:        if (chno == nSelect) {
       88:  229:            *pp_phr = phrase;
       88:  230:            return 1;
        -:  231:        }
       80:  232:    } while (GetVocabNext(pgdata, phrase));
    #####:  233:    free(phrase);
    #####:  234:    return 0;
        -:  235:}
        -:  236:
     1529:  237:static int CompTreeType(const void *a, const void *b)
        -:  238:{
     1529:  239:    return GetUint16(((TreeType *) a)->key) - GetUint16(((TreeType *) b)->key);
        -:  240:}
        -:  241:
        -:  242:/** @brief search for the phrases have the same pronunciation.*/
        -:  243:/* if phoneSeq[begin] ~ phoneSeq[end] is a phrase, then add an interval
        -:  244: * from (begin) to (end+1)
        -:  245: */
      129:  246:const TreeType *TreeFindPhrase(ChewingData *pgdata, int begin, int end, const uint16_t *phoneSeq)
        -:  247:{
        -:  248:    TreeType target;
      129:  249:    const TreeType *tree_p = pgdata->static_data.tree;
        -:  250:    uint32_t range[2];
        -:  251:    int i;
        -:  252:
      282:  253:    for (i = begin; i <= end; i++) {
      156:  254:        PutUint16(phoneSeq[i], target.key);
      156:  255:        range[0] = GetUint24(tree_p->child.begin);
      156:  256:        range[1] = GetUint24(tree_p->child.end);
     156*:  257:        assert(range[1] >= range[0]);
      156:  258:        tree_p = (const TreeType *) bsearch(&target, pgdata->static_data.tree + range[0],
      156:  259:                                            range[1] - range[0], sizeof(TreeType), CompTreeType);
        -:  260:
        -:  261:        /* if not found any word then fail. */
      156:  262:        if (!tree_p)
        3:  263:            return NULL;
        -:  264:    }
        -:  265:
        -:  266:    /* If its child has no key value of 0, then it is only a "half" phrase. */
      126:  267:    if (GetUint16(pgdata->static_data.tree[GetUint24(tree_p->child.begin)].key) != 0)
    #####:  268:        return NULL;
      126:  269:    return tree_p;
        -:  270:}
        -:  271:
        -:  272:/**
        -:  273: * @brief get child range of a given parent node.
        -:  274: */
      121:  275:void TreeChildRange(ChewingData *pgdata, const TreeType *parent)
        -:  276:{
      121:  277:    pgdata->static_data.tree_cur_pos = pgdata->static_data.tree + GetUint24(parent->child.begin);
      121:  278:    pgdata->static_data.tree_end_pos = pgdata->static_data.tree + GetUint24(parent->child.end);
      121:  279:}
        -:  280:
       88:  281:static void AddInterval(TreeDataType *ptd, int begin, int end, Phrase *p_phrase, int dict_or_user)
        -:  282:{
       88:  283:    ptd->interval[ptd->nInterval].from = begin;
       88:  284:    ptd->interval[ptd->nInterval].to = end + 1;
       88:  285:    ptd->interval[ptd->nInterval].p_phr = p_phrase;
       88:  286:    ptd->interval[ptd->nInterval].source = dict_or_user;
       88:  287:    ptd->nInterval++;
       88:  288:}
        -:  289:
        -:  290:/* Item which inserts to interval array */
        -:  291:typedef enum {
        -:  292:    USED_PHRASE_NONE,           /**< none of items used */
        -:  293:    USED_PHRASE_USER,           /**< User phrase */
        -:  294:    USED_PHRASE_DICT            /**< Dict phrase */
        -:  295:} UsedPhraseMode;
        -:  296:
       94:  297:static void internal_release_Phrase(UsedPhraseMode mode, Phrase *pUser, Phrase *pDict)
        -:  298:{
        -:  299:    /* we must free unused phrase entry to avoid memory leak. */
       94:  300:    switch (mode) {
        8:  301:    case USED_PHRASE_USER:
        8:  302:        if (pDict != NULL)
        8:  303:            free(pDict);
        8:  304:        break;
       80:  305:    case USED_PHRASE_DICT:
       80:  306:        if (pUser != NULL)
        4:  307:            free(pUser);
       80:  308:        break;
        6:  309:    default:                   /* In fact, it is alwyas 0 */
        6:  310:        if (pDict != NULL)
    #####:  311:            free(pDict);
        6:  312:        if (pUser != NULL)
    #####:  313:            free(pUser);
        6:  314:        break;
        -:  315:    }
       94:  316:}
        -:  317:
      459:  318:static void FindInterval(ChewingData *pgdata, TreeDataType *ptd)
        -:  319:{
        -:  320:    int end, begin;
        -:  321:    const TreeType *phrase_parent;
        -:  322:    Phrase *p_phrase, *puserphrase, *pdictphrase;
        -:  323:    UsedPhraseMode i_used_phrase;
        -:  324:    uint16_t new_phoneSeq[MAX_PHONE_SEQ_LEN];
        -:  325:    UserPhraseData *userphrase;
        -:  326:
      533:  327:    for (begin = 0; begin < pgdata->nPhoneSeq; begin++) {
      168:  328:        for (end = begin; end < min(pgdata->nPhoneSeq, begin + MAX_PHRASE_LEN); end++) {
       94:  329:            if (!CheckBreakpoint(begin, end + 1, pgdata->bArrBrkpt))
    #####:  330:                break;
        -:  331:
        -:  332:            /* set new_phoneSeq */
       94:  333:            memcpy(new_phoneSeq, &pgdata->phoneSeq[begin], sizeof(uint16_t) * (end - begin + 1));
       94:  334:            new_phoneSeq[end - begin + 1] = 0;
       94:  335:            puserphrase = pdictphrase = NULL;
       94:  336:            i_used_phrase = USED_PHRASE_NONE;
        -:  337:
       94:  338:            userphrase = UserGetPhraseFirst(pgdata, new_phoneSeq);
       94:  339:            UserGetPhraseEnd(pgdata, new_phoneSeq);
        -:  340:
      108:  341:            if (userphrase && CheckUserChoose(pgdata, new_phoneSeq, begin, end + 1,
       14:  342:                                              &p_phrase, pgdata->selectStr, pgdata->selectInterval, pgdata->nSelect)) {
       12:  343:                puserphrase = p_phrase;
        -:  344:            }
        -:  345:
        -:  346:            /* check dict phrase */
       94:  347:            phrase_parent = TreeFindPhrase(pgdata, begin, end, pgdata->phoneSeq);
      186:  348:            if (phrase_parent &&
       92:  349:                CheckChoose(pgdata,
        -:  350:                            phrase_parent, begin, end + 1,
       92:  351:                            &p_phrase, pgdata->selectStr, pgdata->selectInterval, pgdata->nSelect)) {
       88:  352:                pdictphrase = p_phrase;
        -:  353:            }
        -:  354:
        -:  355:            /* add only one interval, which has the largest freqency
        -:  356:             * but when the phrase is the same, the user phrase overrides
        -:  357:             * static dict
        -:  358:             */
       94:  359:            if (puserphrase != NULL && pdictphrase == NULL) {
    #####:  360:                i_used_phrase = USED_PHRASE_USER;
       94:  361:            } else if (puserphrase == NULL && pdictphrase != NULL) {
       76:  362:                i_used_phrase = USED_PHRASE_DICT;
       18:  363:            } else if (puserphrase != NULL && pdictphrase != NULL) {
        -:  364:                /* the same phrase, userphrase overrides */
       12:  365:                if (!strcmp(puserphrase->phrase, pdictphrase->phrase)) {
        8:  366:                    i_used_phrase = USED_PHRASE_USER;
        -:  367:                } else {
        4:  368:                    if (puserphrase->freq > pdictphrase->freq) {
    #####:  369:                        i_used_phrase = USED_PHRASE_USER;
        -:  370:                    } else {
        4:  371:                        i_used_phrase = USED_PHRASE_DICT;
        -:  372:                    }
        -:  373:                }
        -:  374:            }
       94:  375:            switch (i_used_phrase) {
        8:  376:            case USED_PHRASE_USER:
        8:  377:                AddInterval(ptd, begin, end, puserphrase, IS_USER_PHRASE);
        8:  378:                break;
       80:  379:            case USED_PHRASE_DICT:
       80:  380:                AddInterval(ptd, begin, end, pdictphrase, IS_DICT_PHRASE);
       80:  381:                break;
        6:  382:            case USED_PHRASE_NONE:
        -:  383:            default:
        6:  384:                break;
        -:  385:            }
       94:  386:            internal_release_Phrase(i_used_phrase, puserphrase, pdictphrase);
        -:  387:        }
        -:  388:    }
      459:  389:}
        -:  390:
      459:  391:static void SetInfo(int len, TreeDataType *ptd)
        -:  392:{
        -:  393:    int i, a;
        -:  394:
      992:  395:    for (i = 0; i <= len; i++)
      533:  396:        ptd->leftmost[i] = i;
      547:  397:    for (i = 0; i < ptd->nInterval; i++) {
       88:  398:        ptd->graph[ptd->interval[i].from][ptd->interval[i].to] = 1;
       88:  399:        ptd->graph[ptd->interval[i].to][ptd->interval[i].from] = 1;
        -:  400:    }
        -:  401:
        -:  402:    /* set leftmost */
      992:  403:    for (a = 0; a <= len; a++) {
     1254:  404:        for (i = 0; i <= len; i++) {
      721:  405:            if (!(ptd->graph[a][i]))
      545:  406:                continue;
      176:  407:            if (ptd->leftmost[i] < ptd->leftmost[a])
       72:  408:                ptd->leftmost[a] = ptd->leftmost[i];
        -:  409:        }
        -:  410:    }
      459:  411:}
        -:  412:
        -:  413:/*
        -:  414: * First we compare the 'nMatchCnnct'.
        -:  415: * If the values are the same, we will compare the 'score'
        -:  416: */
    #####:  417:static int CompRecord(const RecordNode **pa, const RecordNode **pb)
        -:  418:{
    #####:  419:    int diff = (*pb)->nMatchCnnct - (*pa)->nMatchCnnct;
        -:  420:
    #####:  421:    if (diff)
    #####:  422:        return diff;
    #####:  423:    return ((*pb)->score - (*pa)->score);
        -:  424:}
        -:  425:
        -:  426:/*
        -:  427: * Remove the interval containing in another interval.
        -:  428: *
        -:  429: * Example:
        -:  430: * 國民大會 has three interval: 國民, 大會, 國民大會. This function removes
        -:  431: * 國名, 大會 becasue 國民大會 contains 國民 and 大會.
        -:  432: */
      459:  433:static void Discard1(TreeDataType *ptd)
        -:  434:{
        -:  435:    int a, b;
        -:  436:    char failflag[INTERVAL_SIZE];
        -:  437:    int nInterval2;
        -:  438:
      459:  439:    memset(failflag, 0, sizeof(failflag));
      547:  440:    for (a = 0; a < ptd->nInterval; a++) {
       88:  441:        if (failflag[a])
       12:  442:            continue;
      184:  443:        for (b = 0; b < ptd->nInterval; b++) {
      130:  444:            if (a == b || failflag[b])
       70:  445:                continue;
        -:  446:
        -:  447:            /* interval b is in interval a */
       60:  448:            if (PhraseIntervalContain(ptd->interval[a], ptd->interval[b]))
       28:  449:                continue;
        -:  450:
        -:  451:            /* interval b is in front of interval a */
       32:  452:            if (ptd->interval[b].to <= ptd->interval[a].from)
       10:  453:                continue;
        -:  454:
        -:  455:            /* interval b is in back of interval a */
       22:  456:            if (ptd->interval[a].to <= ptd->interval[b].from)
    #####:  457:                continue;
        -:  458:
       22:  459:            break;
        -:  460:        }
        -:  461:        /* if any other interval b is inside or leftside or rightside the
        -:  462:         * interval a */
       76:  463:        if (b >= ptd->nInterval) {
        -:  464:            /* then kill all the intervals inside the interval a */
        -:  465:            int i;
        -:  466:
      132:  467:            for (i = 0; i < ptd->nInterval; i++) {
       78:  468:                if (!failflag[i] && i != a && PhraseIntervalContain(ptd->interval[a], ptd->interval[i])) {
       24:  469:                    failflag[i] = 1;
        -:  470:                }
        -:  471:            }
        -:  472:        }
        -:  473:    }
        -:  474:    /* discard all the intervals whose failflag[a] = 1 */
      459:  475:    nInterval2 = 0;
      547:  476:    for (a = 0; a < ptd->nInterval; a++) {
       88:  477:        if (!failflag[a]) {
       64:  478:            ptd->interval[nInterval2++] = ptd->interval[a];
        -:  479:        } else {
       24:  480:            if (ptd->interval[a].p_phr != NULL) {
       24:  481:                free(ptd->interval[a].p_phr);
        -:  482:            }
        -:  483:        }
        -:  484:    }
      459:  485:    ptd->nInterval = nInterval2;
      459:  486:}
        -:  487:
        -:  488:/*
        -:  489: * Remove the interval that cannot connect to head or tail by other intervals.
        -:  490: *
        -:  491: * Example:
        -:  492: * The input string length is 5
        -:  493: * The available intervals are [1,1], [1,2], [2,3], [2,4], [5,5], [3,5].
        -:  494: *
        -:  495: * The possible connection from head to tail are [1,2][3,5], and
        -:  496: * [1,1][2,4][5,5]. Since [2,3] cannot connect to head or tail, it is removed
        -:  497: * by this function.
        -:  498: */
      459:  499:static void Discard2(TreeDataType *ptd)
        -:  500:{
        -:  501:    int i, j;
        -:  502:    char overwrite[MAX_PHONE_SEQ_LEN];
        -:  503:    char failflag[INTERVAL_SIZE];
        -:  504:    int nInterval2;
        -:  505:
      459:  506:    memset(failflag, 0, sizeof(failflag));
      523:  507:    for (i = 0; i < ptd->nInterval; i++) {
       64:  508:        if (ptd->leftmost[ptd->interval[i].from] == 0)
       64:  509:            continue;
        -:  510:        /* test if interval i is overwrited by other intervals */
    #####:  511:        memset(overwrite, 0, sizeof(overwrite));
    #####:  512:        for (j = 0; j < ptd->nInterval; j++) {
    #####:  513:            if (j == i)
    #####:  514:                continue;
    #####:  515:            memset(&overwrite[ptd->interval[j].from], 1, ptd->interval[j].to - ptd->interval[j].from);
        -:  516:        }
    #####:  517:        if (memchr(&overwrite[ptd->interval[i].from], 1, ptd->interval[i].to - ptd->interval[i].from))
    #####:  518:            failflag[i] = 1;
        -:  519:    }
        -:  520:    /* discard all the intervals whose failflag[a] = 1 */
      459:  521:    nInterval2 = 0;
      523:  522:    for (i = 0; i < ptd->nInterval; i++)
       64:  523:        if (!failflag[i])
       64:  524:            ptd->interval[nInterval2++] = ptd->interval[i];
      459:  525:    ptd->nInterval = nInterval2;
      459:  526:}
        -:  527:
       66:  528:static void FillPreeditBuf(ChewingData *pgdata, char *phrase, int from, int to)
        -:  529:{
        -:  530:    int i;
       66:  531:    int start = 0;
        -:  532:
      66*:  533:    assert(pgdata);
      66*:  534:    assert(phrase);
      66*:  535:    assert(from < to);
        -:  536:
       66:  537:    start = toPreeditBufIndex(pgdata, from);
        -:  538:
       66:  539:    LOG_VERBOSE("Fill preeditBuf start %d, from = %d, to = %d", start, from, to);
        -:  540:
      150:  541:    for (i = start; i < start - from + to; ++i) {
       84:  542:        ueStrNCpy(pgdata->preeditBuf[i].char_, ueStrSeek(phrase, i - start), 1, STRNCPY_CLOSE);
        -:  543:    }
       66:  544:}
        -:  545:
        -:  546:/* kpchen said, record is the index array of interval */
      459:  547:static void OutputRecordStr(ChewingData *pgdata, const TreeDataType *ptd)
        -:  548:{
        -:  549:    PhraseIntervalType inter;
        -:  550:    int i;
        -:  551:
      517:  552:    for (i = 0; i < ptd->phList->nInter; i++) {
       58:  553:        inter = ptd->interval[ptd->phList->arrIndex[i]];
       58:  554:        FillPreeditBuf(pgdata, inter.p_phr->phrase, inter.from, inter.to);
        -:  555:    }
        -:  556:
      467:  557:    for (i = 0; i < pgdata->nSelect; i++) {
        8:  558:        FillPreeditBuf(pgdata, pgdata->selectStr[i], pgdata->selectInterval[i].from, pgdata->selectInterval[i].to);
        -:  559:    }
      459:  560:}
        -:  561:
      128:  562:static int rule_largest_sum(const int *record, int nRecord, const TreeDataType *ptd)
        -:  563:{
      128:  564:    int i, score = 0;
        -:  565:    PhraseIntervalType inter;
        -:  566:
      268:  567:    for (i = 0; i < nRecord; i++) {
      140:  568:        inter = ptd->interval[record[i]];
     140*:  569:        assert(inter.p_phr);
      140:  570:        score += inter.to - inter.from;
        -:  571:    }
      128:  572:    return score;
        -:  573:}
        -:  574:
       64:  575:static int rule_largest_avgwordlen(const int *record, int nRecord, const TreeDataType *ptd)
        -:  576:{
        -:  577:    /* constant factor 6=1*2*3, to keep value as integer */
       64:  578:    return 6 * rule_largest_sum(record, nRecord, ptd) / nRecord;
        -:  579:}
        -:  580:
       64:  581:static int rule_smallest_lenvariance(const int *record, int nRecord, const TreeDataType *ptd)
        -:  582:{
       64:  583:    int i, j, score = 0;
        -:  584:    PhraseIntervalType inter1, inter2;
        -:  585:
        -:  586:    /* kcwu: heuristic? why variance no square function? */
      134:  587:    for (i = 0; i < nRecord; i++) {
       76:  588:        for (j = i + 1; j < nRecord; j++) {
        6:  589:            inter1 = ptd->interval[record[i]];
        6:  590:            inter2 = ptd->interval[record[j]];
       6*:  591:            assert(inter1.p_phr && inter2.p_phr);
        6:  592:            score += abs((inter1.to - inter1.from) - (inter2.to - inter2.from));
        -:  593:        }
        -:  594:    }
       64:  595:    return -score;
        -:  596:}
        -:  597:
       64:  598:static int rule_largest_freqsum(const int *record, int nRecord, const TreeDataType *ptd)
        -:  599:{
       64:  600:    int i, score = 0;
        -:  601:    PhraseIntervalType inter;
        -:  602:
      134:  603:    for (i = 0; i < nRecord; i++) {
       70:  604:        inter = ptd->interval[record[i]];
      70*:  605:        assert(inter.p_phr);
        -:  606:
        -:  607:        /* We adjust the 'freq' of One-word Phrase */
       70:  608:        score += (inter.to - inter.from == 1) ? (inter.p_phr->freq / 512) : inter.p_phr->freq;
        -:  609:    }
       64:  610:    return score;
        -:  611:}
        -:  612:
       66:  613:static int LoadPhraseAndCountScore(const int *record, int nRecord, const TreeDataType *ptd)
        -:  614:{
       66:  615:    int total_score = 0;
        -:  616:
        -:  617:    /* NOTE: the balance factor is tuneable */
       66:  618:    if (nRecord) {
       64:  619:        total_score += 1000 * rule_largest_sum(record, nRecord, ptd);
       64:  620:        total_score += 1000 * rule_largest_avgwordlen(record, nRecord, ptd);
       64:  621:        total_score += 100 * rule_smallest_lenvariance(record, nRecord, ptd);
       64:  622:        total_score += rule_largest_freqsum(record, nRecord, ptd);
        -:  623:    }
       66:  624:    return total_score;
        -:  625:}
        -:  626:
    #####:  627:static int IsRecContain(const int *intA, int nA, const int *intB, int nB, const TreeDataType *ptd)
        -:  628:{
        -:  629:    int big, sml;
        -:  630:
    #####:  631:    for (big = 0, sml = 0; sml < nB; sml++) {
    #####:  632:        while ((big < nA) && ptd->interval[intA[big]].from < ptd->interval[intB[sml]].to) {
    #####:  633:            if (PhraseIntervalContain(ptd->interval[intA[big]], ptd->interval[intB[sml]]))
    #####:  634:                break;
    #####:  635:            big++;
        -:  636:        }
    #####:  637:        if ((big >= nA) || ptd->interval[intA[big]].from >= ptd->interval[intB[sml]].to)
    #####:  638:            return 0;
        -:  639:    }
    #####:  640:    return 1;
        -:  641:}
        -:  642:
        2:  643:static void SortListByScore(TreeDataType *ptd)
        -:  644:{
        -:  645:    int i, listLen;
        -:  646:    RecordNode *p, **arr;
        -:  647:
        4:  648:    for (listLen = 0, p = ptd->phList; p; listLen++, p = p->next);
        2:  649:    ptd->nPhListLen = listLen;
        -:  650:
        2:  651:    arr = ALC(RecordNode *, listLen);
        -:  652:
       2*:  653:    assert(arr);
        -:  654:
        4:  655:    for (i = 0, p = ptd->phList; i < listLen; p = p->next, i++) {
        2:  656:        arr[i] = p;
        2:  657:        p->score = LoadPhraseAndCountScore(p->arrIndex, p->nInter, ptd);
        -:  658:    }
        -:  659:
        2:  660:    qsort(arr, listLen, sizeof(RecordNode *), (CompFuncType) CompRecord);
        -:  661:
        2:  662:    ptd->phList = arr[0];
       2*:  663:    for (i = 1; i < listLen; i++) {
    #####:  664:        arr[i - 1]->next = arr[i];
        -:  665:    }
        2:  666:    arr[listLen - 1]->next = NULL;
        -:  667:
        2:  668:    free(arr);
        2:  669:}
        -:  670:
        -:  671:/* when record==NULL then output the "link list" */
        2:  672:static void SaveRecord(const int *record, int nInter, TreeDataType *ptd)
        -:  673:{
        -:  674:    RecordNode *now, *p, *pre;
        -:  675:
        2:  676:    pre = NULL;
        2:  677:    for (p = ptd->phList; p;) {
        -:  678:        /* if  'p' contains 'record', then discard 'record'. */
    #####:  679:        if (IsRecContain(p->arrIndex, p->nInter, record, nInter, ptd))
    #####:  680:            return;
        -:  681:
        -:  682:        /* if 'record' contains 'p', then discard 'p'
        -:  683:         * -- We must deal with the linked list. */
    #####:  684:        if (IsRecContain(record, nInter, p->arrIndex, p->nInter, ptd)) {
    #####:  685:            RecordNode *tp = p;
        -:  686:
    #####:  687:            if (pre)
    #####:  688:                pre->next = p->next;
        -:  689:            else
    #####:  690:                ptd->phList = ptd->phList->next;
    #####:  691:            p = p->next;
    #####:  692:            free(tp->arrIndex);
    #####:  693:            free(tp);
        -:  694:        } else
    #####:  695:            pre = p, p = p->next;
        -:  696:    }
        2:  697:    now = ALC(RecordNode, 1);
        -:  698:
       2*:  699:    assert(now);
        2:  700:    now->next = ptd->phList;
        2:  701:    now->arrIndex = ALC(int, nInter);
        -:  702:
       2*:  703:    assert(now->arrIndex);
        2:  704:    now->nInter = nInter;
        2:  705:    memcpy(now->arrIndex, record, nInter * sizeof(int));
        2:  706:    ptd->phList = now;
        -:  707:}
        -:  708:
        2:  709:static void RecursiveSave(int depth, int to, int *record, TreeDataType *ptd)
        -:  710:{
        -:  711:    int first, i;
        -:  712:
        -:  713:    /* to find first interval */
       2*:  714:    for (first = record[depth - 1] + 1; ptd->interval[first].from < to && first < ptd->nInterval; first++);
        -:  715:
        2:  716:    if (first == ptd->nInterval) {
        2:  717:        SaveRecord(record + 1, depth - 1, ptd);
        2:  718:        return;
        -:  719:    }
    #####:  720:    record[depth] = first;
    #####:  721:    RecursiveSave(depth + 1, ptd->interval[first].to, record, ptd);
        -:  722:    /* for each interval which intersects first */
    #####:  723:    for (i = first + 1; PhraseIntervalIntersect(ptd->interval[first], ptd->interval[i]) && i < ptd->nInterval; i++) {
    #####:  724:        record[depth] = i;
    #####:  725:        RecursiveSave(depth + 1, ptd->interval[i].to, record, ptd);
        -:  726:    }
        -:  727:}
        -:  728:
        2:  729:static void SaveList(TreeDataType *ptd)
        -:  730:{
        2:  731:    int record[MAX_PHONE_SEQ_LEN + 1] = { -1 };
        -:  732:
        2:  733:    RecursiveSave(1, 0, record, ptd);
        2:  734:}
        -:  735:
      459:  736:static void InitPhrasing(TreeDataType *ptd)
        -:  737:{
      459:  738:    memset(ptd, 0, sizeof(TreeDataType));
      459:  739:}
        -:  740:
      459:  741:static void SaveDispInterval(PhrasingOutput *ppo, TreeDataType *ptd)
        -:  742:{
        -:  743:    int i;
        -:  744:
      517:  745:    for (i = 0; i < ptd->phList->nInter; i++) {
       58:  746:        ppo->dispInterval[i].from = ptd->interval[ptd->phList->arrIndex[i]].from;
       58:  747:        ppo->dispInterval[i].to = ptd->interval[ptd->phList->arrIndex[i]].to;
        -:  748:    }
      459:  749:    ppo->nDispInterval = ptd->phList->nInter;
      459:  750:}
        -:  751:
      459:  752:static void CleanUpMem(TreeDataType *ptd)
        -:  753:{
        -:  754:    int i;
        -:  755:    RecordNode *pNode;
        -:  756:
      523:  757:    for (i = 0; i < ptd->nInterval; i++) {
       64:  758:        if (ptd->interval[i].p_phr) {
       64:  759:            free(ptd->interval[i].p_phr);
       64:  760:            ptd->interval[i].p_phr = NULL;
        -:  761:        }
        -:  762:    }
      918:  763:    while (ptd->phList != NULL) {
      459:  764:        pNode = ptd->phList;
      459:  765:        ptd->phList = pNode->next;
      459:  766:        free(pNode->arrIndex);
      459:  767:        free(pNode);
        -:  768:    }
      459:  769:}
        -:  770:
        2:  771:static void CountMatchCnnct(TreeDataType *ptd, const int *bUserArrCnnct, int nPhoneSeq)
        -:  772:{
        -:  773:    RecordNode *p;
        -:  774:    int i, k, sum;
        -:  775:
        4:  776:    for (p = ptd->phList; p; p = p->next) {
        -:  777:        /* for each record, count its 'nMatchCnnct' */
       2*:  778:        for (sum = 0, i = 1; i < nPhoneSeq; i++) {
    #####:  779:            if (!bUserArrCnnct[i])
    #####:  780:                continue;
        -:  781:            /* check if matching 'cnnct' */
    #####:  782:            for (k = 0; k < p->nInter; k++) {
    #####:  783:                if (ptd->interval[p->arrIndex[k]].from < i && ptd->interval[p->arrIndex[k]].to > i) {
    #####:  784:                    sum++;
    #####:  785:                    break;
        -:  786:                }
        -:  787:            }
        -:  788:        }
        2:  789:        p->nMatchCnnct = sum;
        -:  790:    }
        2:  791:}
        -:  792:
      459:  793:static void ShowList(ChewingData *pgdata, const TreeDataType *ptd)
        -:  794:{
        -:  795:    const RecordNode *p;
        -:  796:    int i;
        -:  797:
      459:  798:    DEBUG_OUT("After SaveList :\n");
      918:  799:    for (p = ptd->phList; p; p = p->next) {
      459:  800:        DEBUG_OUT("  interval : ");
      517:  801:        for (i = 0; i < p->nInter; i++) {
       58:  802:            DEBUG_OUT("[%d %d] ", ptd->interval[p->arrIndex[i]].from, ptd->interval[p->arrIndex[i]].to);
        -:  803:        }
      459:  804:        DEBUG_OUT("\n" "      score : %d , nMatchCnnct : %d\n", p->score, p->nMatchCnnct);
        -:  805:    }
      459:  806:    DEBUG_OUT("\n");
      459:  807:}
        -:  808:
        2:  809:static RecordNode *NextCut(TreeDataType *tdt, PhrasingOutput *ppo)
        -:  810:{
        -:  811:    /* pop nNumCut-th candidate to first */
        -:  812:    int i;
        -:  813:    RecordNode *former;
        -:  814:    RecordNode *want;
        -:  815:
        2:  816:    if (ppo->nNumCut >= tdt->nPhListLen)
        2:  817:        ppo->nNumCut = 0;
        2:  818:    if (ppo->nNumCut == 0)
        2:  819:        return tdt->phList;
        -:  820:
        -:  821:    /* find the former of our candidate */
    #####:  822:    former = tdt->phList;
    #####:  823:    for (i = 0; i < ppo->nNumCut - 1; i++) {
    #####:  824:        former = former->next;
    #####:  825:        assert(former);
        -:  826:    }
        -:  827:
        -:  828:    /* take the candidate out of the listed list */
    #####:  829:    want = former->next;
    #####:  830:    assert(want);
    #####:  831:    former->next = former->next->next;
        -:  832:
        -:  833:    /* prepend to front of list */
    #####:  834:    want->next = tdt->phList;
    #####:  835:    tdt->phList = want;
        -:  836:
    #####:  837:    return tdt->phList;
        -:  838:}
        -:  839:
       10:  840:static int SortByIncreaseEnd(const void *x, const void *y)
        -:  841:{
       10:  842:    const PhraseIntervalType *interval_x = (const PhraseIntervalType *) x;
       10:  843:    const PhraseIntervalType *interval_y = (const PhraseIntervalType *) y;
        -:  844:
       10:  845:    if (interval_x->to < interval_y->to)
        6:  846:        return -1;
        -:  847:
        4:  848:    if (interval_x->to > interval_y->to)
    #####:  849:        return 1;
        -:  850:
        4:  851:    return 0;
        -:  852:}
        -:  853:
        6:  854:static RecordNode *DuplicateRecordAndInsertInterval(const RecordNode *record, TreeDataType *pdt, const int interval_id)
        -:  855:{
        6:  856:    RecordNode *ret = NULL;
        -:  857:
       6*:  858:    assert(record);
       6*:  859:    assert(pdt);
        -:  860:
        6:  861:    ret = ALC(RecordNode, 1);
        -:  862:
        6:  863:    if (!ret)
    #####:  864:        return NULL;
        -:  865:
        6:  866:    ret->arrIndex = ALC(int, record->nInter + 1);
        6:  867:    if (!ret->arrIndex) {
    #####:  868:        free(ret);
    #####:  869:        return NULL;
        -:  870:    }
        6:  871:    ret->nInter = record->nInter + 1;
        6:  872:    memcpy(ret->arrIndex, record->arrIndex, sizeof(record->arrIndex[0]) * record->nInter);
        -:  873:
        6:  874:    ret->arrIndex[ret->nInter - 1] = interval_id;
        -:  875:
        6:  876:    ret->score = LoadPhraseAndCountScore(ret->arrIndex, ret->nInter, pdt);
        -:  877:
        6:  878:    return ret;
        -:  879:}
        -:  880:
       58:  881:static RecordNode *CreateSingleIntervalRecord(TreeDataType *pdt, const int interval_id)
        -:  882:{
       58:  883:    RecordNode *ret = NULL;
        -:  884:
      58*:  885:    assert(pdt);
        -:  886:
       58:  887:    ret = ALC(RecordNode, 1);
        -:  888:
       58:  889:    if (!ret)
    #####:  890:        return NULL;
        -:  891:
       58:  892:    ret->arrIndex = ALC(int, 1);
       58:  893:    if (!ret->arrIndex) {
    #####:  894:        free(ret);
    #####:  895:        return NULL;
        -:  896:    }
        -:  897:
       58:  898:    ret->nInter = 1;
       58:  899:    ret->arrIndex[0] = interval_id;
        -:  900:
       58:  901:    ret->score = LoadPhraseAndCountScore(ret->arrIndex, ret->nInter, pdt);
        -:  902:
       58:  903:    return ret;
        -:  904:}
        -:  905:
      401:  906:static RecordNode *CreateNullIntervalRecord()
        -:  907:{
      401:  908:    RecordNode *ret = NULL;
      401:  909:    ret = ALC(RecordNode, 1);
        -:  910:
      401:  911:    if (!ret)
    #####:  912:        return NULL;
        -:  913:
      401:  914:    ret->arrIndex = ALC(int, 1);
      401:  915:    if (!ret->arrIndex) {
    #####:  916:        free(ret);
    #####:  917:        return NULL;
        -:  918:    }
        -:  919:
      401:  920:    ret->nInter = 0;
      401:  921:    ret->score = 0;
        -:  922:
      401:  923:    return ret;
        -:  924:}
        -:  925:
       82:  926:static void FreeRecord(RecordNode *node)
        -:  927:{
       82:  928:    if (node) {
        8:  929:        free(node->arrIndex);
        8:  930:        free(node);
        -:  931:    }
       82:  932:}
        -:  933:
      457:  934:static void DoDpPhrasing(ChewingData *pgdata, TreeDataType *pdt)
        -:  935:{
      457:  936:    RecordNode *highest_score[MAX_PHONE_SEQ_LEN] = { 0 };
        -:  937:    RecordNode *tmp;
        -:  938:    int prev_end;
        -:  939:    int end;
        -:  940:    int interval_id;
        -:  941:
     457*:  942:    assert(pgdata);
     457*:  943:    assert(pdt);
        -:  944:
        -:  945:    /*
        -:  946:     * Assume P(x,y) is the highest score phrasing result from x to y. The
        -:  947:     * following is formula for P(x,y):
        -:  948:     *
        -:  949:     * P(x,y) = MAX( P(x,y-1)+P(y-1,y), P(x,y-2)+P(y-2,y), ... )
        -:  950:     *
        -:  951:     * While P(x,y-1) is stored in highest_score array, and P(y-1,y) is
        -:  952:     * interval end at y. In this formula, x is always 0.
        -:  953:     *
        -:  954:     * The format of highest_score array is described as following:
        -:  955:     *
        -:  956:     * highest_score[0] = P(0,0)
        -:  957:     * highest_score[1] = P(0,1)
        -:  958:     * ...
        -:  959:     * highest_score[y-1] = P(0,y-1)
        -:  960:     */
        -:  961:
        -:  962:    /* The interval shall be sorted by the increase order of end. */
      457:  963:    qsort(pdt->interval, pdt->nInterval, sizeof(pdt->interval[0]), SortByIncreaseEnd);
        -:  964:
      521:  965:    for (interval_id = 0; interval_id < pdt->nInterval; ++interval_id) {
        -:  966:        /*
        -:  967:         * XXX: pdt->interval.to is excluding, while end is
        -:  968:         * including, so we need to minus one here.
        -:  969:         */
       64:  970:        end = pdt->interval[interval_id].to - 1;
        -:  971:
       64:  972:        prev_end = pdt->interval[interval_id].from - 1;
        -:  973:
       64:  974:        if (prev_end >= 0)
        6:  975:            tmp = DuplicateRecordAndInsertInterval(highest_score[prev_end], pdt, interval_id);
        -:  976:        else
       58:  977:            tmp = CreateSingleIntervalRecord(pdt, interval_id);
        -:  978:
        -:  979:        /* FIXME: shall exit immediately? */
       64:  980:        if (!tmp)
    #####:  981:            continue;
        -:  982:
       64:  983:        if (highest_score[end] == NULL || highest_score[end]->score < tmp->score) {
       62:  984:            FreeRecord(highest_score[end]);
       62:  985:            highest_score[end] = tmp;
        -:  986:        } else
        2:  987:            FreeRecord(tmp);
        -:  988:    }
        -:  989:
      457:  990:    if (pgdata->nPhoneSeq - 1 < 0 || highest_score[pgdata->nPhoneSeq - 1] == NULL) {
      401:  991:        pdt->phList = CreateNullIntervalRecord();
        -:  992:    } else {
       56:  993:        pdt->phList = highest_score[pgdata->nPhoneSeq - 1];
        -:  994:    }
      457:  995:    pdt->nPhListLen = 1;
        -:  996:
      475:  997:    for (end = 0; end < pgdata->nPhoneSeq - 1; ++end)
       18:  998:        FreeRecord(highest_score[end]);
      457:  999:}
        -: 1000:
      459: 1001:int Phrasing(ChewingData *pgdata, int all_phrasing)
        -: 1002:{
        -: 1003:    TreeDataType treeData;
        -: 1004:
      459: 1005:    InitPhrasing(&treeData);
        -: 1006:
      459: 1007:    FindInterval(pgdata, &treeData);
      459: 1008:    SetInfo(pgdata->nPhoneSeq, &treeData);
      459: 1009:    Discard1(&treeData);
      459: 1010:    Discard2(&treeData);
      459: 1011:    if (all_phrasing) {
        2: 1012:        SaveList(&treeData);
        2: 1013:        CountMatchCnnct(&treeData, pgdata->bUserArrCnnct, pgdata->nPhoneSeq);
        2: 1014:        SortListByScore(&treeData);
        2: 1015:        NextCut(&treeData, &pgdata->phrOut);
        -: 1016:    } else {
      457: 1017:        DoDpPhrasing(pgdata, &treeData);
        -: 1018:    }
        -: 1019:
      459: 1020:    ShowList(pgdata, &treeData);
        -: 1021:
        -: 1022:    /* set phrasing output */
      459: 1023:    OutputRecordStr(pgdata, &treeData);
      459: 1024:    SaveDispInterval(&pgdata->phrOut, &treeData);
        -: 1025:
        -: 1026:    /* free "phrase" */
      459: 1027:    CleanUpMem(&treeData);
      459: 1028:    return 0;
        -: 1029:}
