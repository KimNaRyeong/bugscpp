        -:    0:Source:/home/workspace/src/porting_layer/src/plat_path.c
        -:    1:/**
        -:    2: * plat_path.c
        -:    3: *
        -:    4: * Copyright (c) 2012-2014
        -:    5: *	libchewing Core Team. See ChangeLog for details.
        -:    6: *
        -:    7: * See the file "COPYING" for information on usage and redistribution
        -:    8: * of this file.
        -:    9: */
        -:   10:
        -:   11:#ifdef HAVE_CONFIG_H
        -:   12:#    include <config.h>
        -:   13:#endif
        -:   14:#include "plat_path.h"
        -:   15:
        -:   16:#ifndef HAVE_ASPRINTF
        -:   17:#    include <stdarg.h>
        -:   18:#endif
        -:   19:#include <assert.h>
        -:   20:#include <stdio.h>
        -:   21:#include <stdlib.h>
        -:   22:#include <string.h>
        -:   23:
        -:   24:#include "plat_types.h"
        -:   25:
        -:   26:#ifdef UNDER_POSIX
        -:   27:#    define SEARCH_PATH_SEP ":"
       17:   28:int get_search_path(char *path, size_t path_len)
        -:   29:{
        -:   30:    char *chewing_path;
        -:   31:    char *home;
        -:   32:
       17:   33:    chewing_path = getenv("CHEWING_PATH");
       17:   34:    if (chewing_path) {
       17:   35:        strncpy(path, chewing_path, path_len);
        -:   36:    } else {
    #####:   37:        home = getenv("HOME");
    #####:   38:        if (home) {
    #####:   39:            snprintf(path, path_len, "%s/.chewing" SEARCH_PATH_SEP CHEWING_DATADIR "/libchewing", home);
        -:   40:        } else {
        -:   41:            // No HOME ?
    #####:   42:            strncpy(path, SEARCH_PATH_SEP CHEWING_DATADIR "/libchewing", path_len);
        -:   43:        }
        -:   44:    }
        -:   45:
       17:   46:    return 0;
        -:   47:}
        -:   48:
        -:   49:#elif defined(_WIN32) || defined(_WIN64) || defined(_WIN32_WCE)
        -:   50:#include <Shlobj.h>
        -:   51:
        -:   52:#    define SEARCH_PATH_SEP ";"
        -:   53:
        -:   54:int get_search_path(char *path, size_t path_len)
        -:   55:{
        -:   56:    char *chewing_path;
        -:   57:    size_t len;
        -:   58:    HRESULT result;
        -:   59:
        -:   60:    chewing_path = getenv("CHEWING_PATH");
        -:   61:    if (chewing_path) {
        -:   62:        // FIXME: Check for truncated.
        -:   63:        strncpy(path, chewing_path, path_len);
        -:   64:    } else {
        -:   65:
        -:   66:        /*
        -:   67:         * Try to search dictionary location at the following path
        -:   68:         *
        -:   69:         * - %CSIDL_PROGRAM_FILESX86%/ChewingTextService/Dictionary
        -:   70:         * - %CSIDL_PROGRAM_FILES%/ChewingTextService/Dictionary
        -:   71:         */
        -:   72:
        -:   73:        if (path_len < MAX_PATH) {
        -:   74:            return -1;
        -:   75:        }
        -:   76:
        -:   77:        result = SHGetFolderPathA(NULL, CSIDL_PROGRAM_FILESX86, NULL, 0, path);
        -:   78:        if(result != S_OK) {
        -:   79:            result = SHGetFolderPathA(NULL, CSIDL_PROGRAM_FILES, NULL, 0, path);
        -:   80:        }
        -:   81:
        -:   82:        if (result != S_OK) {
        -:   83:            return -1;
        -:   84:        }
        -:   85:
        -:   86:        len = strlen(path);
        -:   87:        path += len;
        -:   88:        path_len -= len;
        -:   89:
        -:   90:        // FIXME: Check for truncated.
        -:   91:        snprintf(path, path_len, "\\%s\\%s", "ChewingTextService", "Dictionary");
        -:   92:    }
        -:   93:
        -:   94:    return 0;
        -:   95:}
        -:   96:#else
        -:   97:#    error please implement get_search_path
        -:   98:#endif
        -:   99:
        -:  100:#ifndef HAVE_STRTOK_R
        -:  101:char *strtok_r(char *s, const char *delim, char **save_ptr)
        -:  102:{
        -:  103:    char *token;
        -:  104:
        -:  105:    if (s == NULL)
        -:  106:        s = *save_ptr;
        -:  107:
        -:  108:    /* Scan leading delimiters.  */
        -:  109:    s += strspn(s, delim);
        -:  110:    if (*s == '\0') {
        -:  111:        *save_ptr = s;
        -:  112:        return NULL;
        -:  113:    }
        -:  114:
        -:  115:    /* Find the end of the token.  */
        -:  116:    token = s;
        -:  117:    s = strpbrk(token, delim);
        -:  118:    if (s == NULL)
        -:  119:        /* This token finishes the string.  */
        -:  120:        *save_ptr = token + strlen(token);
        -:  121:    else {
        -:  122:        /* Terminate the token and make *SAVE_PTR point past it.  */
        -:  123:        *s = '\0';
        -:  124:        *save_ptr = s + 1;
        -:  125:    }
        -:  126:    return token;
        -:  127:}
        -:  128:#endif
        -:  129:
        -:  130:#ifndef HAVE_ASPRINTF
        -:  131:int asprintf(char **strp, const char *fmt, ...)
        -:  132:{
        -:  133:    char *buf;
        -:  134:    size_t len;
        -:  135:    va_list ap;
        -:  136:
        -:  137:    va_start(ap, fmt);
        -:  138:    len = vsnprintf(NULL, 0, fmt, ap);
        -:  139:    va_end(ap);
        -:  140:
        -:  141:    buf = (char *) malloc(len + 1);
        -:  142:    if (!buf)
        -:  143:        return -1;
        -:  144:
        -:  145:    va_start(ap, fmt);
        -:  146:    len = vsnprintf(buf, len + 1, fmt, ap);
        -:  147:    va_end(ap);
        -:  148:
        -:  149:    *strp = buf;
        -:  150:
        -:  151:    return len;
        -:  152:}
        -:  153:#endif
        -:  154:
       70:  155:static int are_all_files_readable(const char *path, const char *const *files, char *output, size_t output_len)
        -:  156:{
        -:  157:    int i;
        -:  158:
      70*:  159:    assert(path);
      70*:  160:    assert(files);
        -:  161:
      157:  162:    for (i = 0; files[i] != NULL; ++i) {
       88:  163:        snprintf(output, output_len, "%s" PLAT_SEPARATOR "%s", path, files[i]);
       88:  164:        if (access(output, R_OK) != 0) {
        1:  165:            return 0;
        -:  166:        }
        -:  167:    }
        -:  168:
       69:  169:    return 1;
        -:  170:}
        -:  171:
       70:  172:int find_path_by_files(const char *search_path, const char *const *files, char *output, size_t output_len)
        -:  173:{
        -:  174:    char buffer[PATH_MAX];
        -:  175:    char *path;
        -:  176:    char *saveptr;
        -:  177:    int ret;
        -:  178:
      70*:  179:    assert(search_path);
      70*:  180:    assert(files);
      70*:  181:    assert(output);
      70*:  182:    assert(output_len);
        -:  183:
        -:  184:    // strtok_r will modify its first parameter.
       70:  185:    strncpy(buffer, search_path, sizeof(buffer));
        -:  186:
       71:  187:    for (path = strtok_r(buffer, SEARCH_PATH_SEP, &saveptr); path; path = strtok_r(NULL, SEARCH_PATH_SEP, &saveptr)) {
        -:  188:
       70:  189:        ret = are_all_files_readable(path, files, output, output_len);
       70:  190:        if (ret) {
       69:  191:            snprintf(output, output_len, "%s", path);
       69:  192:            return 0;
        -:  193:        }
        -:  194:    }
        1:  195:    return -1;
        -:  196:}
