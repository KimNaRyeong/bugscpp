        -:    0:Source:/home/workspace/src/porting_layer/src/plat_path.c
        -:    1:/**
        -:    2: * plat_path.c
        -:    3: *
        -:    4: * Copyright (c) 2012
        -:    5: *	libchewing Core Team. See ChangeLog for details.
        -:    6: *
        -:    7: * See the file "COPYING" for information on usage and redistribution
        -:    8: * of this file.
        -:    9: */
        -:   10:
        -:   11:#ifdef HAVE_CONFIG_H
        -:   12:  #include <config.h>
        -:   13:#endif
        -:   14:#include "plat_path.h"
        -:   15:
        -:   16:#ifndef HAVE_ASPRINTF
        -:   17:#include <stdarg.h>
        -:   18:#endif
        -:   19:#include <assert.h>
        -:   20:#include <stdio.h>
        -:   21:#include <stdlib.h>
        -:   22:#include <string.h>
        -:   23:
        -:   24:#include "plat_types.h"
        -:   25:
        -:   26:#ifdef UNDER_POSIX
        -:   27:#define SEARCH_PATH_SEP ":"
        1:   28:int get_search_path( char * path, size_t path_len )
        -:   29:{
        -:   30:	char *chewing_path;
        -:   31:	char *home;
        -:   32:
        1:   33:	chewing_path = getenv( "CHEWING_PATH" );
        1:   34:	if ( chewing_path ) {
        1:   35:		strncpy( path, chewing_path, path_len );
        -:   36:	} else {
    #####:   37:		home = getenv( "HOME" );
    #####:   38:		if ( home ) {
    #####:   39:			snprintf( path, path_len, "%s/.chewing" SEARCH_PATH_SEP
        -:   40:				DATADIR "/libchewing", home );
        -:   41:		} else {
        -:   42:			// No HOME ?
    #####:   43:			strncpy( path, SEARCH_PATH_SEP DATADIR "/libchewing", path_len );
        -:   44:		}
        -:   45:	}
        -:   46:
        1:   47:	return 0;
        -:   48:}
        -:   49:
        -:   50:#elif defined(_WIN32) || defined(_WIN64) || defined(_WIN32_WCE)
        -:   51:#define SEARCH_PATH_SEP ";"
        -:   52:int get_search_path( char * path, size_t path_len )
        -:   53:{
        -:   54:	char *chewing_path;
        -:   55:	char *windir;
        -:   56:
        -:   57:	chewing_path = getenv( "CHEWING_PATH" );
        -:   58:	if ( chewing_path ) {
        -:   59:		strncpy( path, chewing_path, path_len );
        -:   60:	} else {
        -:   61:		windir = getenv( "WINDIR" );
        -:   62:		if ( windir ) {
        -:   63:			snprintf( path, path_len, "%s\\%s", windir, "chewing" );
        -:   64:		} else {
        -:   65:			return -1;
        -:   66:		}
        -:   67:	}
        -:   68:
        -:   69:	return 0;
        -:   70:}
        -:   71:#else
        -:   72:#error please implement get_search_path
        -:   73:#endif
        -:   74:
        -:   75:#ifndef HAVE_STRTOK_R
        -:   76:char * strtok_r (char *s, const char *delim, char **save_ptr)
        -:   77:{
        -:   78:	char *token;
        -:   79:
        -:   80:	if ( s == NULL )
        -:   81:		s = *save_ptr;
        -:   82:
        -:   83:	/* Scan leading delimiters.  */
        -:   84:	s += strspn( s, delim );
        -:   85:	if ( *s == '\0' ) {
        -:   86:		*save_ptr = s;
        -:   87:		return NULL;
        -:   88:	}
        -:   89:
        -:   90:	/* Find the end of the token.  */
        -:   91:	token = s;
        -:   92:	s = strpbrk( token, delim );
        -:   93:	if ( s == NULL )
        -:   94:		/* This token finishes the string.  */
        -:   95:		*save_ptr = token + strlen( token );
        -:   96:	else {
        -:   97:		/* Terminate the token and make *SAVE_PTR point past it.  */
        -:   98:		*s = '\0';
        -:   99:		*save_ptr = s + 1;
        -:  100:	}
        -:  101:	return token;
        -:  102:}
        -:  103:#endif
        -:  104:
        -:  105:#ifndef HAVE_ASPRINTF
        -:  106:int asprintf( char **strp, const char *fmt, ... )
        -:  107:{
        -:  108:	char *buf;
        -:  109:	size_t len;
        -:  110:	va_list ap;
        -:  111:
        -:  112:	va_start( ap, fmt );
        -:  113:	len = vsnprintf( NULL, 0, fmt, ap );
        -:  114:	va_end( ap );
        -:  115:
        -:  116:	buf = (char *) malloc( len + 1 );
        -:  117:	if ( !buf )
        -:  118:		return -1;
        -:  119:
        -:  120:	va_start( ap, fmt );
        -:  121:	len = vsnprintf( buf, len + 1, fmt, ap );
        -:  122:	va_end( ap );
        -:  123:
        -:  124:	*strp = buf;
        -:  125:
        -:  126:	return len;
        -:  127:}
        -:  128:#endif
        -:  129:
        4:  130:static int are_all_files_readable(
        -:  131:	const char *path,
        -:  132:	const char * const *files,
        -:  133:	char *output,
        -:  134:	size_t output_len )
        -:  135:{
        -:  136:	int i;
        -:  137:
       4*:  138:	assert( path );
       4*:  139:	assert( files );
        -:  140:
        9:  141:	for ( i = 0; files[i] != NULL; ++i ) {
        5:  142:		snprintf( output, output_len, "%s" PLAT_SEPARATOR "%s", path,
        5:  143:				files[i] );
        5:  144:		if ( access( output, R_OK ) != 0 ) {
    #####:  145:			return 0;
        -:  146:		}
        -:  147:	}
        -:  148:
        4:  149:	return 1;
        -:  150:}
        -:  151:
        4:  152:int find_path_by_files(
        -:  153:	const char *search_path,
        -:  154:	const char * const *files,
        -:  155:	char *output,
        -:  156:	size_t output_len )
        -:  157:{
        -:  158:	char buffer[PATH_MAX];
        -:  159:	char *path;
        -:  160:	char *saveptr;
        -:  161:	int ret;
        -:  162:
       4*:  163:	assert( search_path );
       4*:  164:	assert( files );
       4*:  165:	assert( output );
       4*:  166:	assert( output_len );
        -:  167:
        -:  168:	// strtok_r will modify its first parameter.
        4:  169:	strncpy( buffer, search_path, sizeof( buffer ) );
        -:  170:
        4:  171:	for ( path = strtok_r( buffer, SEARCH_PATH_SEP, &saveptr );
    #####:  172:		path; path = strtok_r( NULL, SEARCH_PATH_SEP, &saveptr ) ) {
        -:  173:
        4:  174:		ret = are_all_files_readable( path, files, output, output_len );
        4:  175:		if ( ret ) {
        4:  176:			snprintf( output, output_len, "%s", path );
        4:  177:			return 0;
        -:  178:		}
        -:  179:	}
    #####:  180:	return -1;
        -:  181:}
