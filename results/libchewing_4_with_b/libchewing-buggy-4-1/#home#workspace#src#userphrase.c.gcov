        -:    0:Source:/home/workspace/src/userphrase.c
        -:    1:/**
        -:    2: * userphrase.c
        -:    3: *
        -:    4: * Copyright (c) 2014
        -:    5: *	libchewing Core Team. See ChangeLog for details.
        -:    6: *
        -:    7: * See the file "COPYING" for information on usage and redistribution
        -:    8: * of this file.
        -:    9: */
        -:   10:
        -:   11:#include "userphrase-private.h"
        -:   12:
        -:   13:#include <assert.h>
        -:   14:
        -:   15:#include "chewing-private.h"
        -:   16:#include "chewing-sql.h"
        -:   17:#include "private.h"
        -:   18:
        -:   19:#if defined(_WIN32) || defined(_WIN64) || defined(_WIN32_WCE)
        -:   20:
        -:   21:#include <Shlobj.h>
        -:   22:#define USERPHRASE_DIR	"ChewingTextService"
        -:   23:
        -:   24:char *GetDefaultUserPhrasePath(ChewingData *pgdata)
        -:   25:{
        -:   26:	wchar_t *tmp;
        -:   27:	char *path;
        -:   28:	int i;
        -:   29:	int len;
        -:   30:
        -:   31:	assert(pgdata);
        -:   32:
        -:   33:	len = GetEnvironmentVariableW(L"CHEWING_USER_PATH", NULL, 0);
        -:   34:	if (len) {
        -:   35:		tmp = calloc(sizeof(*tmp), len);
        -:   36:		if (!tmp) {
        -:   37:			LOG_ERROR("calloc returns %#p", tmp);
        -:   38:			exit(-1);
        -:   39:		}
        -:   40:
        -:   41:		GetEnvironmentVariableW(L"CHEWING_USER_PATH", tmp, len);
        -:   42:
        -:   43:		len = WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, tmp, -1, NULL, 0, NULL, NULL);
        -:   44:		path = calloc(sizeof(*path), len + 1 + strlen(DB_NAME) + 1);
        -:   45:		if (!path) {
        -:   46:			free(tmp);
        -:   47:			LOG_ERROR("calloc returns %#p", path);
        -:   48:			exit(-1);
        -:   49:		}
        -:   50:		WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, tmp, -1, path, len, NULL, NULL);
        -:   51:		strcat(path + len, "\\" DB_NAME);
        -:   52:
        -:   53:		free(tmp);
        -:   54:		return path;
        -:   55:	}
        -:   56:
        -:   57:	len = GetEnvironmentVariableW(L"USERPROFILE", NULL, 0);
        -:   58:	if (len) {
        -:   59:		tmp = calloc(sizeof(*tmp), len);
        -:   60:		if (!tmp) {
        -:   61:			LOG_ERROR("calloc returns %#p", tmp);
        -:   62:			exit(-1);
        -:   63:		}
        -:   64:
        -:   65:		GetEnvironmentVariableW(L"USERPROFILE", tmp, len);
        -:   66:
        -:   67:		len = WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, tmp, -1, NULL, 0, NULL, NULL);
        -:   68:		path = calloc(sizeof(*path), len + 1 + strlen(USERPHRASE_DIR) + 1 + strlen(DB_NAME) + 1);
        -:   69:		if (!path) {
        -:   70:			free(tmp);
        -:   71:			LOG_ERROR("calloc returns %#p", path);
        -:   72:			exit(-1);
        -:   73:		}
        -:   74:		WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, tmp, -1, path, len, NULL, NULL);
        -:   75:		strcat(path + len, "\\" USERPHRASE_DIR "\\" DB_NAME);
        -:   76:
        -:   77:		free(tmp);
        -:   78:		return path;
        -:   79:	}
        -:   80:
        -:   81:	return NULL;
        -:   82:}
        -:   83:
        -:   84:#else
        -:   85:
        -:   86:#ifdef __MaxOSX__
        -:   87:/* FIXME: Shall this path pre user? */
        -:   88:#define USERPHRASE_DIR	"/Library/ChewingOSX"
        -:   89:#else
        -:   90:#define USERPHRASE_DIR	".chewing"
        -:   91:#endif
        -:   92:
        -:   93:#include <stdio.h>
        -:   94:#include <stdlib.h>
        -:   95:#include <string.h>
        -:   96:#include <unistd.h>
        -:   97:
       43:   98:char *GetDefaultUserPhrasePath(ChewingData *pgdata)
        -:   99:{
        -:  100:	char *tmp;
        -:  101:	char *path;
        -:  102:	int len;
        -:  103:	int ret;
        -:  104:
      43*:  105:	assert(pgdata);
        -:  106:
       43:  107:	tmp = getenv("CHEWING_USER_PATH");
       43:  108:	if (tmp && access(tmp, W_OK) == 0) {
       43:  109:		ret = asprintf(&path, "%s/%s", tmp, DB_NAME);
       43:  110:		if (ret == -1) {
    #####:  111:			LOG_ERROR("asprintf returns %d", ret);
    #####:  112:			exit(-1);
        -:  113:		}
       43:  114:		return path;
        -:  115:	}
        -:  116:
    #####:  117:	tmp = getenv("HOME");
    #####:  118:	if (!tmp) {
    #####:  119:		tmp = PLAT_TMPDIR;
        -:  120:	}
        -:  121:
    #####:  122:	len = snprintf(NULL, 0, "%s/%s/%s", tmp, USERPHRASE_DIR, DB_NAME);
    #####:  123:	++len;
    #####:  124:	path = malloc(len);
    #####:  125:	if (!path) {
    #####:  126:		LOG_ERROR("malloc returns %#p", path);
    #####:  127:		exit(-1);
        -:  128:	}
        -:  129:
    #####:  130:	snprintf(path, len, "%s/%s", tmp, USERPHRASE_DIR);
    #####:  131:	PLAT_MKDIR(path);
    #####:  132:	snprintf(path, len, "%s/%s/%s", tmp, USERPHRASE_DIR, DB_NAME);
        -:  133:
    #####:  134:	return path;
        -:  135:}
        -:  136:
        -:  137:#endif
