        -:    0:Source:/home/workspace/src/common/key2pho.c
        -:    1:/**
        -:    2: * key2pho.c
        -:    3: *
        -:    4: * Copyright (c) 1999, 2000, 2001
        -:    5: *	Lu-chuan Kung and Kang-pen Chen.
        -:    6: *	All rights reserved.
        -:    7: *
        -:    8: * Copyright (c) 2004-2006, 2008, 2010, 2012
        -:    9: *	libchewing Core Team. See ChangeLog for details.
        -:   10: *
        -:   11: * See the file "COPYING" for information on usage and redistribution
        -:   12: * of this file.
        -:   13: */
        -:   14:
        -:   15:/**
        -:   16: * @file key2pho.c
        -:   17: * @brief map zuins to uint16_t type according to different kb_type
        -:   18: */
        -:   19:
        -:   20:/* This file is encoded in UTF-8 */
        -:   21:#include "key2pho-private.h"
        -:   22:
        -:   23:#include <assert.h>
        -:   24:#include <stdio.h>
        -:   25:#include <string.h>
        -:   26:#include "chewing-utf8-util.h"
        -:   27:#include "chewing-private.h"
        -:   28:
        -:   29:/* NOTE:
        -:   30: * The reason why we convert string literal to hex representation is for the
        -:   31: * sake of portability, that avoid some buggy or faulty environment like
        -:   32: * Microsoft VC9 to misinterpret the string.
        -:   33: */
        -:   34:const char *const zhuin_tab[] = {				/* number of bits */
        -:   35:	  "  \xE3\x84\x85\xE3\x84\x86\xE3\x84\x87\xE3\x84\x88\xE3\x84\x89"
        -:   36:	  "\xE3\x84\x8A\xE3\x84\x8B\xE3\x84\x8C\xE3\x84\x8D\xE3\x84\x8E"
        -:   37:	  "\xE3\x84\x8F\xE3\x84\x90\xE3\x84\x91\xE3\x84\x92\xE3\x84\x93"
        -:   38:	  "\xE3\x84\x94\xE3\x84\x95\xE3\x84\x96\xE3\x84\x97\xE3\x84\x98"
        -:   39:	  "\xE3\x84\x99",						/* 5 */
        -:   40:	  	/* ㄅㄆㄇㄈㄉㄊㄋㄌㄍㄎㄏㄐㄑㄒㄓㄔㄕㄖㄗㄘㄙ */
        -:   41:	  "  \xE3\x84\xA7\xE3\x84\xA8\xE3\x84\xA9",			/* 2 */
        -:   42:	  	/* ㄧㄨㄩ */
        -:   43:	  "  \xE3\x84\x9A\xE3\x84\x9B\xE3\x84\x9C\xE3\x84\x9D\xE3\x84\x9E"
        -:   44:	  "\xE3\x84\x9F\xE3\x84\xA0\xE3\x84\xA1\xE3\x84\xA2\xE3\x84\xA3"
        -:   45:	  "\xE3\x84\xA4\xE3\x84\xA5\xE3\x84\xA6",			/* 4 */
        -:   46:	  	/* ㄚㄛㄜㄝㄞㄟㄠㄡㄢㄣㄤㄥㄦ */
        -:   47:	  "  \xCB\x99\xCB\x8A\xCB\x87\xCB\x8B"				/* 3 */
        -:   48:		/* ˙ˊˇˋ */
        -:   49:};
        -:   50:
        -:   51:static const int zhuin_tab_num[] = { 22, 4, 14, 5 };
        -:   52:static const int shift[] = { 9, 7, 3, 0 };
        -:   53:static const int sb[] = { 31, 3, 15, 7 };
        -:   54:
        -:   55:static const char * const ph_str =
        -:   56:	"\xE3\x84\x85\xE3\x84\x86\xE3\x84\x87\xE3\x84\x88"
        -:   57:		/* ㄅㄆㄇㄈ */
        -:   58:	"\xE3\x84\x89\xE3\x84\x8A\xE3\x84\x8B\xE3\x84\x8C"
        -:   59:		/* ㄉㄊㄋㄌ */
        -:   60:	"\xE3\x84\x8D\xE3\x84\x8E\xE3\x84\x8F\xE3\x84\x90"
        -:   61:		/* ㄍㄎㄏㄐ */
        -:   62:	"\xE3\x84\x91\xE3\x84\x92\xE3\x84\x93\xE3\x84\x94"
        -:   63:		/* ㄑㄒㄓㄔ */
        -:   64:	"\xE3\x84\x95\xE3\x84\x96\xE3\x84\x97\xE3\x84\x98"
        -:   65:		/* ㄕㄖㄗㄘ */
        -:   66:	"\xE3\x84\x99\xE3\x84\xA7\xE3\x84\xA8\xE3\x84\xA9"
        -:   67:		/* ㄙㄧㄨㄩ */
        -:   68:	"\xE3\x84\x9A\xE3\x84\x9B\xE3\x84\x9C\xE3\x84\x9D"
        -:   69:		/* ㄚㄛㄜㄝ */
        -:   70:	"\xE3\x84\x9E\xE3\x84\x9F\xE3\x84\xA0\xE3\x84\xA1"
        -:   71:		/* ㄞㄟㄠㄡ */
        -:   72:	"\xE3\x84\xA2\xE3\x84\xA3\xE3\x84\xA4\xE3\x84\xA5\xE3\x84\xA6"
        -:   73:		/* ㄢㄣㄤㄥㄦ */
        -:   74:	"\xCB\x99\xCB\x8A\xCB\x87\xCB\x8B" ;
        -:   75:		/* ˙ˊˇˋ */
        -:   76:static const char * const key_str[ MAX_KBTYPE ] = {
        -:   77:	 "1qaz2wsxedcrfv5tgbyhnujm8ik,9ol.0p;/-7634",		/* standard kb */
        -:   78:	 "bpmfdtnlgkhjvcjvcrzasexuyhgeiawomnkllsdfj",		/* hsu */
        -:   79:	 "1234567890-qwertyuiopasdfghjkl;zxcvbn/m,.",		/* IBM */
        -:   80:	 "2wsx3edcrfvtgb6yhnujm8ik,9ol.0p;/-['=1qaz",		/* Gin-yieh */
        -:   81:	 "bpmfdtnlvkhg7c,./j;'sexuaorwiqzy890-=1234",		/* ET  */
        -:   82:	 "bpmfdtnlvkhgvcgycjqwsexuaorwiqzpmntlhdfjk",		/* ET26 */
        -:   83:	 "1'a;2,oq.ejpuk5yixfdbghm8ctw9rnv0lsz[7634",		/* Dvorak */
        -:   84:	 "bpmfdtnlgkhjvcjvcrzasexuyhgeiawomnkllsdfj",		/* Dvorak Hsu */
        -:   85:	 "qqazwwsxedcrfvttgbyhnujmuikbiolmoplnpyerd",		/* DACHEN-CP26 */
        -:   86:	 "1qaz2wsxedcrfv5tgbyhnujm8ik,9ol.0p;/-7634",           /* Hanyu Pinyin */
        -:   87:	 "1qaz2wsxedcrfv5tgbyhnujm8ik,9ol.0p;/-7634",           /* Luoma Pinyin */
        -:   88:	 "1qaz2wsxedcrfv5tgbyhnujm8ik,9ol.0p;/-7634",           /* secondary Bopomofo Pinyin */
        -:   89:
        -:   90:} ;
        -:   91:
        -:   92:/*
        -:   93: * Read one zhuin string,
        -:   94: *
        -:   95: * return the number it means. 0 means error.
        -:   96: */
    #####:   97:uint16_t UintFromPhone( const char *zhuin )
        -:   98:{
        -:   99:	const char *iter;
        -:  100:	char *pos;
        -:  101:	char buf[ MAX_UTF8_SIZE + 1 ];
    #####:  102:	int len, result = 0;
    #####:  103:	int zhuin_index = 0;
        -:  104:
    #####:  105:	iter = zhuin;
        -:  106:
    #####:  107:	while ( *iter && *iter != 0x20 ) {
    #####:  108:		len = ueStrNCpy( buf, iter, 1, STRNCPY_CLOSE );
        -:  109:
    #####:  110:		for (; zhuin_index < ZUIN_SIZE; ++zhuin_index ) {
    #####:  111:			pos = strstr( zhuin_tab[ zhuin_index ], buf );
    #####:  112:			if ( pos ) {
    #####:  113:				break;
        -:  114:			}
        -:  115:		}
        -:  116:
    #####:  117:		if ( zhuin_index >= ZUIN_SIZE ) {
    #####:  118:			return 0;
        -:  119:		}
        -:  120:
    #####:  121:		result |= (zhuin_tab_num[ zhuin_index ] - ueStrLen( pos )) << shift[ zhuin_index ];
    #####:  122:		++zhuin_index;
    #####:  123:		iter += len;
        -:  124:	}
    #####:  125:	return result;
        -:  126:}
        -:  127:
      375:  128:int PhoneFromKey( char *pho, const char *inputkey, int kbtype, int searchTimes )
        -:  129:{
      375:  130:	int len = strlen( inputkey ), i, s;
        -:  131:	const char *pTarget;
        -:  132:
      375:  133:	pho[ 0 ] = '\0';
      518:  134:	for ( i = 0; i < len; i++ ) {
      375:  135:		char *findptr = NULL;
        -:  136:		int _index;
        -:  137:
      518:  138:		for (
      375:  139:				s = 0, pTarget = key_str[ kbtype ];
        -:  140:				s < searchTimes;
      143:  141:				s++, pTarget = findptr + 1 ) {
      375:  142:			findptr = strchr( pTarget, inputkey[ i ] );
      375:  143:			if ( ! findptr ) {
      232:  144:				return 0;
        -:  145:			}
        -:  146:		}
      143:  147:		_index = findptr - key_str[ kbtype ];
      143:  148:		ueStrNCpy( ueStrSeek( pho, i ),
        -:  149:		           ueConstStrSeek( ph_str, _index ),
        -:  150:			   1, 0);
        -:  151:	}
      143:  152:	pho = ueStrSeek( pho, len );
      143:  153:	pho[0] = '\0';
      143:  154:	return 1;
        -:  155:}
        -:  156:
    #####:  157:int PhoneFromUint( char *phone, size_t phone_len, uint16_t phone_num )
        -:  158:{
        -:  159:	int i;
        -:  160:	int index;
        -:  161:	const char *pos;
        -:  162:	char tmp[ MAX_UTF8_SIZE + 1 ];
    #####:  163:	char buffer[ MAX_UTF8_SIZE * ZUIN_SIZE + 1 ] = { 0 };
        -:  164:
    #####:  165:	for ( i = 0; i < ZUIN_SIZE; ++i ) {
        -:  166:		// The first two characters in zhuin_tab are space, so we need
        -:  167:		// to add 1 here.
    #####:  168:		index = ((phone_num >> shift[ i ]) & sb[ i ]) + 1;
    #####:  169:		if ( index >= 2 ) {
    #####:  170:			pos = ueConstStrSeek( zhuin_tab[ i ], index );
    #####:  171:			ueStrNCpy( tmp, pos, 1, 1 );
    #####:  172:			strcat( buffer, tmp );
        -:  173:		}
        -:  174:	}
    #####:  175:	strncpy( phone, buffer, phone_len );
    #####:  176:	phone[ phone_len - 1 ] = 0;
    #####:  177:	return 0;
        -:  178:}
        -:  179:
      375:  180:int PhoneInxFromKey( int key, int type, int kbtype, int searchTimes )
        -:  181:{
        -:  182:	char keyStr[ 2 ], rtStr[ 10 ], *p;
        -:  183:
      375:  184:	keyStr[ 0 ] = key;
      375:  185:	keyStr[ 1 ] = '\0';
      375:  186:	if ( ! PhoneFromKey( rtStr, keyStr, kbtype, searchTimes ) )
      232:  187:		return 0;
      143:  188:	p = strstr( zhuin_tab[ type ], rtStr );
      143:  189:	if ( ! p )
       79:  190:		return 0;
       64:  191:	return zhuin_tab_num[type] - ueStrLen(p);
        -:  192:}
        -:  193:
       12:  194:uint16_t UintFromPhoneInx( const int ph_inx[] )
        -:  195:{
        -:  196:	int i;
       12:  197:	uint16_t result = 0;
        -:  198:
       60:  199:	for ( i = 0; i < ZUIN_SIZE; i++ )
       48:  200:		result |= ph_inx[ i ] << shift[ i ];
       12:  201:	return result;
        -:  202:}
        -:  203:
      114:  204:size_t GetPhoneLen( const uint16_t *phoneSeq )
        -:  205:{
      114:  206:	size_t len = 0;
     114*:  207:	assert( phoneSeq );
        -:  208:
      255:  209:	while ( phoneSeq[len] )
      141:  210:		++len;
      114:  211:	return len;
        -:  212:}
        -:  213:
    #####:  214:static size_t GetBopomofoCount( const char * bopomofo_buf )
        -:  215:{
    #####:  216:	size_t count = 0;
    #####:  217:	assert( bopomofo_buf );
        -:  218:
    #####:  219:	while( (bopomofo_buf = strpbrk( bopomofo_buf, " ")) != NULL ) {
    #####:  220:		++count;
    #####:  221:		bopomofo_buf += 1;
        -:  222:	}
        -:  223:
    #####:  224:	return count;
        -:  225:}
        -:  226:
    #####:  227:size_t BopomofoFromUintArray( char * const bopomofo_buf, const size_t bopomofo_len, const uint16_t *phoneSeq )
        -:  228:{
        -:  229:	size_t i;
        -:  230:	size_t len;
        -:  231:	size_t buf_len;
    #####:  232:	size_t shift = 0;
        -:  233:
    #####:  234:	assert( phoneSeq );
        -:  235:
    #####:  236:	len = GetPhoneLen( phoneSeq );
    #####:  237:	buf_len = GetBopomofoBufLen( len );
        -:  238:
    #####:  239:	if ( bopomofo_buf && bopomofo_len >= buf_len ) {
    #####:  240:		for ( i = 0; i < len; ++i ) {
    #####:  241:			PhoneFromUint( bopomofo_buf + shift, bopomofo_len - shift, phoneSeq[i] );
    #####:  242:			strcat( bopomofo_buf + shift, " " );
    #####:  243:			shift += strlen( bopomofo_buf + shift );
        -:  244:		}
    #####:  245:		if ( shift )
    #####:  246:			bopomofo_buf[ shift - 1 ] = 0;
        -:  247:	}
    #####:  248:	return buf_len;
        -:  249:}
        -:  250:
    #####:  251:ssize_t UintArrayFromBopomofo( uint16_t *phone_seq, const size_t phone_len, const char * bopomofo_buf )
        -:  252:{
        -:  253:	ssize_t i;
        -:  254:	ssize_t len;
        -:  255:
    #####:  256:	assert( bopomofo_buf );
        -:  257:
    #####:  258:	len = GetBopomofoCount( bopomofo_buf ) + 1;
    #####:  259:	if ( !phone_seq )
    #####:  260:		return len;
        -:  261:
    #####:  262:	if ( phone_len <= len )
    #####:  263:		return -1;
        -:  264:
    #####:  265:	for ( i = 0; i < len ; ++i ) {
    #####:  266:		phone_seq[ i ] = UintFromPhone( bopomofo_buf );
    #####:  267:		if ( phone_seq[ i ] == 0 )
    #####:  268:			return -1;
    #####:  269:		bopomofo_buf = strpbrk( bopomofo_buf, " " ) + 1;
        -:  270:	}
    #####:  271:	phone_seq[ len ] = 0;
        -:  272:
    #####:  273:	return len;
        -:  274:}
        -:  275:
    #####:  276:size_t GetBopomofoBufLen( size_t len )
        -:  277:{
    #####:  278:	return ( MAX_UTF8_SIZE * ZUIN_SIZE + 1 ) * len;
        -:  279:}
