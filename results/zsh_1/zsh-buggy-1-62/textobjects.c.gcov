        -:    0:Source:textobjects.c
        -:    0:Graph:/home/workspace/Src/Zle/textobjects.gcno
        -:    0:Data:/home/workspace/Src/Zle/textobjects.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:/*
        -:    2: * textobjects.c - ZLE widgets implementing Vim style text objects
        -:    3: *
        -:    4: * This file is part of zsh, the Z shell.
        -:    5: *
        -:    6: * Copyright (c) 2014 Oliver Kiddle
        -:    7: * All rights reserved.
        -:    8: *
        -:    9: * Permission is hereby granted, without written agreement and without
        -:   10: * license or royalty fees, to use, copy, modify, and distribute this
        -:   11: * software and to distribute modified versions of this software for any
        -:   12: * purpose, provided that the above copyright notice and the following
        -:   13: * two paragraphs appear in all copies of this software.
        -:   14: *
        -:   15: * In no event shall Oliver Kiddle or the Zsh Development Group be liable
        -:   16: * to any party for direct, indirect, special, incidental, or consequential
        -:   17: * damages arising out of the use of this software and its documentation,
        -:   18: * even if Oliver Kiddle and the Zsh Development Group have been advised of
        -:   19: * the possibility of such damage.
        -:   20: *
        -:   21: * Oliver Kiddle and the Zsh Development Group specifically disclaim any
        -:   22: * warranties, including, but not limited to, the implied warranties of
        -:   23: * merchantability and fitness for a particular purpose.  The software
        -:   24: * provided hereunder is on an "as is" basis, and Oliver Kiddle and the
        -:   25: * Zsh Development Group have no obligation to provide maintenance,
        -:   26: * support, updates, enhancements, or modifications.
        -:   27: *
        -:   28: */
        -:   29:
        -:   30:#include "zle.mdh"
        -:   31:#include "textobjects.pro"
        -:   32:
        -:   33:static int
    #####:   34:blankwordclass(ZLE_CHAR_T x)
        -:   35:{
    #####:   36:    return (ZC_iblank(x) ? 0 : 1);
        -:   37:}
        -:   38:
        -:   39:/**/
        -:   40:int
    #####:   41:selectword(UNUSED(char **args))
        -:   42:{
    #####:   43:    int n = zmult;
    #####:   44:    int all = IS_THINGY(bindk, selectaword) ||
    #####:   45:	IS_THINGY(bindk, selectablankword);
    #####:   46:    int (*viclass)(ZLE_CHAR_T) = (IS_THINGY(bindk, selectaword) ||
    #####:   47:	    IS_THINGY(bindk, selectinword)) ? wordclass : blankwordclass;
    #####:   48:    int sclass = viclass(zleline[zlecs]);
    #####:   49:    int doblanks = all && sclass;
        -:   50:
    #####:   51:    if (!region_active || zlecs == mark || mark == -1) {
        -:   52:	/* search back to first character of same class as the start position
        -:   53:	 * also stop at the beginning of the line */
    #####:   54:	mark = zlecs;
    #####:   55:	while (mark) {
    #####:   56:	    int pos = mark;
    #####:   57:	    DECPOS(pos);
    #####:   58:	    if (zleline[pos] == ZWC('\n') || viclass(zleline[pos]) != sclass)
        -:   59:		break;
    #####:   60:	    mark = pos;
        -:   61:	}
        -:   62:	/* similarly scan forward over characters of the same class */
    #####:   63:	while (zlecs < zlell) {
    #####:   64:	    INCCS();
    #####:   65:	    int pos = zlecs;
        -:   66:	    /* single newlines within blanks are included */
    #####:   67:	    if (all && !sclass && pos < zlell && zleline[pos] == ZWC('\n'))
    #####:   68:		INCPOS(pos);
        -:   69:
    #####:   70:	    if (zleline[pos] == ZWC('\n') || viclass(zleline[pos]) != sclass)
        -:   71:		break;
        -:   72:	}
        -:   73:
    #####:   74:	if (all) {
    #####:   75:	    int nclass = viclass(zleline[zlecs]);
        -:   76:	    /* if either start or new position is blank advance over
        -:   77:	     * a new block of characters of a common type */
    #####:   78:	    if (!nclass || !sclass) {
    #####:   79:		while (zlecs < zlell) {
    #####:   80:		    INCCS();
    #####:   81:		    if (zleline[zlecs] == ZWC('\n') ||
    #####:   82:			    viclass(zleline[zlecs]) != nclass)
        -:   83:			break;
        -:   84:		}
    #####:   85:		if (n < 2)
    #####:   86:		    doblanks = 0;
        -:   87:	    }
        -:   88:	}
        -:   89:    } else {
        -:   90:	/* For visual mode, advance one char so repeated
        -:   91:	 * invocations select subsequent words */
    #####:   92:	if (zlecs > mark) {
    #####:   93:	    if (zlecs < zlell)
    #####:   94:		INCCS();
    #####:   95:	} else if (zlecs)
    #####:   96:	    DECCS();
    #####:   97:	if (zlecs < mark) {
        -:   98:	    /* visual mode with the cursor before the mark: move cursor back */
    #####:   99:	    while (n-- > 0) {
    #####:  100:		int pos = zlecs;
        -:  101:		/* first over blanks */
    #####:  102:		if (all && (!viclass(zleline[pos]) ||
    #####:  103:			zleline[pos] == ZWC('\n'))) {
    #####:  104:		    all = 0;
    #####:  105:		    while (pos) {
    #####:  106:			DECPOS(pos);
    #####:  107:			if (zleline[pos] == ZWC('\n'))
    #####:  108:			    break;
    #####:  109:			zlecs = pos;
    #####:  110:			if (viclass(zleline[pos]))
    #####:  111:			    break;
        -:  112:		    }
    #####:  113:		} else if (zlecs && zleline[zlecs] == ZWC('\n')) {
        -:  114:		    /* for in widgets pass over one newline */
    #####:  115:		    DECPOS(pos);
    #####:  116:		    if (zleline[pos] != ZWC('\n'))
    #####:  117:			zlecs = pos;
        -:  118:		}
    #####:  119:		pos = zlecs;
    #####:  120:		sclass = viclass(zleline[zlecs]);
        -:  121:		/* now retreat over non-blanks */
    #####:  122:		while (zleline[pos] != ZWC('\n') &&
    #####:  123:			viclass(zleline[pos]) == sclass) {
    #####:  124:		    zlecs = pos;
    #####:  125:		    if (!pos) {
    #####:  126:			zlecs = 0;
    #####:  127:			break;
        -:  128:		    }
    #####:  129:		    DECPOS(pos);
        -:  130:		}
        -:  131:		/* blanks again but only if there were none first time */
    #####:  132:		if (all && zlecs) {
    #####:  133:		    pos = zlecs;
    #####:  134:		    DECPOS(pos);
    #####:  135:		    if (!viclass(zleline[pos])) {
    #####:  136:			while (pos) {
    #####:  137:			    DECPOS(pos);
    #####:  138:			    if (zleline[pos] == ZWC('\n') ||
    #####:  139:				    viclass(zleline[pos]))
        -:  140:				break;
    #####:  141:			    zlecs = pos;
        -:  142:			}
        -:  143:		    }
        -:  144:		}
        -:  145:	    }
    #####:  146:	    return 0;
        -:  147:	}
    #####:  148:	n++;
    #####:  149:	doblanks = 0;
        -:  150:    }
    #####:  151:    region_active = !!region_active; /* force to character wise */
        -:  152:
        -:  153:    /* for each digit argument, advance over further block of one class */
    #####:  154:    while (--n > 0) {
    #####:  155:	if (zlecs < zlell && zleline[zlecs] == ZWC('\n'))
    #####:  156:	    INCCS();
    #####:  157:	sclass = viclass(zleline[zlecs]);
    #####:  158:	while (zlecs < zlell) {
    #####:  159:	    INCCS();
    #####:  160:	    if (zleline[zlecs] == ZWC('\n') ||
    #####:  161:		    viclass(zleline[zlecs]) != sclass)
        -:  162:		break;
        -:  163:	}
        -:  164:	/* for 'a' widgets, advance extra block if either consists of blanks */
    #####:  165:	if (all) {
    #####:  166:	    if (zlecs < zlell && zleline[zlecs] == ZWC('\n'))
    #####:  167:		INCCS();
    #####:  168:	    if (!sclass || !viclass(zleline[zlecs]) ) {
    #####:  169:		sclass = viclass(zleline[zlecs]);
    #####:  170:		if (n == 1 && !sclass)
    #####:  171:		    doblanks = 0;
    #####:  172:		while (zlecs < zlell) {
    #####:  173:		    INCCS();
    #####:  174:		    if (zleline[zlecs] == ZWC('\n') ||
    #####:  175:			    viclass(zleline[zlecs]) != sclass)
        -:  176:			break;
        -:  177:		}
        -:  178:	    }
        -:  179:	}
        -:  180:    }
        -:  181:
        -:  182:    /* if we didn't remove blanks at either end we remove some at the start */
    #####:  183:    if (doblanks) {
    #####:  184:	int pos = mark;
    #####:  185:	while (pos) {
    #####:  186:	    DECPOS(pos);
        -:  187:	    /* don't remove blanks at the start of the line, i.e indentation */
    #####:  188:	    if (zleline[pos] == ZWC('\n'))
    #####:  189:		break;
    #####:  190:	    if (!ZC_iblank(zleline[pos])) {
    #####:  191:		INCPOS(pos);
    #####:  192:		mark = pos;
    #####:  193:		break;
        -:  194:	    }
        -:  195:	}
        -:  196:    }
        -:  197:    /* Adjustment: vi operators don't include the cursor position, in insert
        -:  198:     * or emacs mode the region also doesn't but for vi visual mode it is
        -:  199:     * included. */
    #####:  200:    if (!virangeflag) {
    #####:  201:	if (!invicmdmode())
    #####:  202:	    region_active = 1;
    #####:  203:	else if (zlecs && zlecs > mark)
    #####:  204:	    DECCS();
        -:  205:    }
        -:  206:
    #####:  207:    return 0;
        -:  208:}
        -:  209:
        -:  210:/**/
        -:  211:int
    #####:  212:selectargument(UNUSED(char **args))
        -:  213:{
    #####:  214:    int ne = noerrs, ocs = zlemetacs;
    #####:  215:    int owb = wb, owe= we, oadx = addedx, ona = noaliases;
        -:  216:    char *p;
        -:  217:    int ll, cs;
        -:  218:    char *linein;
    #####:  219:    int wend = 0, wcur = 0;
    #####:  220:    int n = zmult;
        -:  221:    int *wstarts;
        -:  222:    int tmpsz;
        -:  223:
    #####:  224:    if (n < 1 || 2*n > zlell + 1)
    #####:  225:	return 1;
        -:  226:
        -:  227:    /* if used from emacs mode enable the region */
    #####:  228:    if (!invicmdmode()) {
    #####:  229:	region_active = 1;
    #####:  230:	mark = zlecs;
        -:  231:    }
        -:  232:
    #####:  233:    wstarts = (int *) zhalloc(n * sizeof(int));
    #####:  234:    memset(wstarts, 0, n * sizeof(int));
        -:  235:
    #####:  236:    addedx = 0;
    #####:  237:    noerrs = 1;
    #####:  238:    zcontext_save();
    #####:  239:    lexflags = LEXFLAGS_ACTIVE;
    #####:  240:    linein = zlegetline(&ll, &cs);
    #####:  241:    zlemetall = ll;
    #####:  242:    zlemetacs = cs;
        -:  243:
    #####:  244:    if (!isfirstln && chline) {
    #####:  245:       p = (char *) zhalloc(hptr - chline + zlemetall + 2);
    #####:  246:       memcpy(p, chline, hptr - chline);
    #####:  247:       memcpy(p + (hptr - chline), linein, ll);
    #####:  248:       p[(hptr - chline) + ll] = '\0';
    #####:  249:       inpush(p, 0, NULL);
    #####:  250:       zlemetacs += hptr - chline;
        -:  251:    } else {
    #####:  252:       p = (char *) zhalloc(ll + 1);
    #####:  253:       memcpy(p, linein, ll);
    #####:  254:       p[ll] = '\0';
    #####:  255:       inpush(p, 0, NULL);
        -:  256:    }
    #####:  257:    if (zlemetacs)
    #####:  258:       zlemetacs--;
    #####:  259:    strinbeg(0);
    #####:  260:    noaliases = 1;
        -:  261:    do {
    #####:  262:       wstarts[wcur++] = wend;
    #####:  263:       wcur %= n;
    #####:  264:       ctxtlex();
    #####:  265:       if (tok == ENDINPUT || tok == LEXERR)
        -:  266:           break;
    #####:  267:       wend = zlemetall - inbufct;
    #####:  268:    } while (tok != ENDINPUT && tok != LEXERR && wend <= zlemetacs);
    #####:  269:    noaliases = ona;
    #####:  270:    strinend();
    #####:  271:    inpop();
    #####:  272:    errflag &= ~ERRFLAG_ERROR;
    #####:  273:    noerrs = ne;
    #####:  274:    zcontext_restore();
    #####:  275:    zlemetacs = ocs;
    #####:  276:    wb = owb;
    #####:  277:    we = owe;
    #####:  278:    addedx = oadx;
        -:  279:
        -:  280:    /* convert offsets for mark and zlecs back to ZLE internal format */
    #####:  281:    linein[wend] = '\0'; /* a bit of a hack to get two offsets */
    #####:  282:    free(stringaszleline(linein, wstarts[wcur], &zlecs, &tmpsz, &mark));
    #####:  283:    free(linein);
        -:  284:
    #####:  285:    if (IS_THINGY(bindk, selectinshellword)) {
    #####:  286:	ZLE_CHAR_T *match = ZWS("`\'\"");
    #####:  287:	ZLE_CHAR_T *lmatch = ZWS("\'({"), *rmatch = ZWS("\')}");
    #####:  288:	ZLE_CHAR_T *ematch = match, *found;
    #####:  289:	int start, end = zlecs;
        -:  290:	/* for 'in' widget, don't include initial blanks ... */
    #####:  291:	while (mark < zlecs && ZC_iblank(zleline[mark]))
    #####:  292:	    INCPOS(mark);
        -:  293:	/* ... or a matching pair of quotes */
    #####:  294:	start = mark;
    #####:  295:	if (zleline[start] == ZWC('$')) {
    #####:  296:	    match = lmatch;
    #####:  297:	    ematch = rmatch;
    #####:  298:	    INCPOS(start);
        -:  299:	}
    #####:  300:	found = ZS_strchr(match, zleline[start]);
    #####:  301:	if (found) {
    #####:  302:	    DECPOS(end);
    #####:  303:	    if (zleline[end] == ematch[found-match]) {
    #####:  304:		zlecs = end;
    #####:  305:		INCPOS(start);
    #####:  306:		mark = start;
        -:  307:	    }
        -:  308:	}
        -:  309:    }
        -:  310:
        -:  311:    /* Adjustment: vi operators don't include the cursor position */
    #####:  312:    if (!virangeflag && invicmdmode())
    #####:  313:       DECCS();
        -:  314:
    #####:  315:    return 0;
        -:  316:}
