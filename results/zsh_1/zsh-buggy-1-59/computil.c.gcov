        -:    0:Source:computil.c
        -:    0:Graph:/home/workspace/Src/Zle/computil.gcno
        -:    0:Data:/home/workspace/Src/Zle/computil.gcda
        -:    0:Runs:3
        -:    0:Programs:1
        -:    1:/*
        -:    2: * computil.c - completion utilities
        -:    3: *
        -:    4: * This file is part of zsh, the Z shell.
        -:    5: *
        -:    6: * Copyright (c) 1999 Sven Wischnowsky
        -:    7: * All rights reserved.
        -:    8: *
        -:    9: * Permission is hereby granted, without written agreement and without
        -:   10: * license or royalty fees, to use, copy, modify, and distribute this
        -:   11: * software and to distribute modified versions of this software for any
        -:   12: * purpose, provided that the above copyright notice and the following
        -:   13: * two paragraphs appear in all copies of this software.
        -:   14: *
        -:   15: * In no event shall Sven Wischnowsky or the Zsh Development Group be liable
        -:   16: * to any party for direct, indirect, special, incidental, or consequential
        -:   17: * damages arising out of the use of this software and its documentation,
        -:   18: * even if Sven Wischnowsky and the Zsh Development Group have been advised of
        -:   19: * the possibility of such damage.
        -:   20: *
        -:   21: * Sven Wischnowsky and the Zsh Development Group specifically disclaim any
        -:   22: * warranties, including, but not limited to, the implied warranties of
        -:   23: * merchantability and fitness for a particular purpose.  The software
        -:   24: * provided hereunder is on an "as is" basis, and Sven Wischnowsky and the
        -:   25: * Zsh Development Group have no obligation to provide maintenance,
        -:   26: * support, updates, enhancements, or modifications.
        -:   27: *
        -:   28: */
        -:   29:
        -:   30:#include "computil.mdh"
        -:   31:#include "computil.pro"
        -:   32:
        -:   33:
        -:   34:/* Help for `_describe'. */
        -:   35:
        -:   36:typedef struct cdset *Cdset;
        -:   37:typedef struct cdstr *Cdstr;
        -:   38:typedef struct cdrun *Cdrun;
        -:   39:
        -:   40:struct cdstate {
        -:   41:    int showd;			/* != 0 if descriptions should be shown */
        -:   42:    char *sep;			/* the separator string */
        -:   43:    int slen;			/* its metafied length */
        -:   44:    int swidth;			/* its screen width */
        -:   45:    int maxmlen;                /* maximum length to allow for the matches */
        -:   46:    Cdset sets;			/* the sets of matches */
        -:   47:    int pre;                    /* longest prefix length (before description) */
        -:   48:    int premaxw;		/* ... and its screen width */
        -:   49:    int suf;                    /* longest suffix (description) */
        -:   50:    int maxg;                   /* size of largest group */
        -:   51:    int maxglen;                /* columns for matches of largest group */
        -:   52:    int groups;                 /* number of groups */
        -:   53:    int descs;                  /* number of non-group matches with desc */
        -:   54:    int gprew;                   /* prefix screen width for group display */
        -:   55:    Cdrun runs;                 /* runs to report to shell code */
        -:   56:};
        -:   57:
        -:   58:struct cdstr {
        -:   59:    Cdstr next;                 /* the next one in this set */
        -:   60:    char *str;                  /* the string to display */
        -:   61:    char *desc;                 /* the description or NULL */
        -:   62:    char *match;                /* the match to add */
        -:   63:    char *sortstr;		/* unmetafied string used to sort matches */
        -:   64:    int len;                    /* length of str or match */
        -:   65:    int width;			/* ... and its screen width */
        -:   66:    Cdstr other;                /* next string with the same description */
        -:   67:    int kind;                   /* 0: not in a group, 1: the first, 2: other */
        -:   68:    Cdset set;                  /* the set this string is in */
        -:   69:    Cdstr run;                  /* next in this run */
        -:   70:};
        -:   71:
        -:   72:struct cdrun {
        -:   73:    Cdrun next;                 /* ... */
        -:   74:    int type;                   /* see CRT_* below */
        -:   75:    Cdstr strs;                 /* strings in this run */
        -:   76:    int count;                  /* number of strings in this run */
        -:   77:};
        -:   78:
        -:   79:#define CRT_SIMPLE 0
        -:   80:#define CRT_DESC   1
        -:   81:#define CRT_SPEC   2
        -:   82:#define CRT_DUMMY  3
        -:   83:#define CRT_EXPL   4
        -:   84:
        -:   85:struct cdset {
        -:   86:    Cdset next;			/* guess what */
        -:   87:    char **opts;		/* the compadd-options */
        -:   88:    Cdstr strs;                 /* the strings/matches */
        -:   89:    int count;                  /* number of matches in this set */
        -:   90:    int desc;                   /* number of matches with description */
        -:   91:};
        -:   92:
        -:   93:static struct cdstate cd_state;
        -:   94:static int cd_parsed = 0;
        -:   95:
        -:   96:static void
       77:   97:freecdsets(Cdset p)
        -:   98:{
        -:   99:    Cdset n;
        -:  100:    Cdstr s, sn;
        -:  101:    Cdrun r, rn;
        -:  102:
      300:  103:    for (; p; p = n) {
      223:  104:	n = p->next;
      223:  105:	if (p->opts)
      223:  106:	    freearray(p->opts);
      346:  107:        for (s = p->strs; s; s = sn) {
      123:  108:            sn = s->next;
      123:  109:	    zfree(s->sortstr, strlen(s->str) + 1);
      123:  110:            zsfree(s->str);
      123:  111:            zsfree(s->desc);
      123:  112:            if (s->match != s->str)
       10:  113:                zsfree(s->match);
      123:  114:            zfree(s, sizeof(*s));
        -:  115:        }
      223:  116:        for (r = cd_state.runs; r; r = rn) {
    #####:  117:            rn = r->next;
    #####:  118:            zfree(r, sizeof(*r));
        -:  119:        }
      223:  120:	zfree(p, sizeof(*p));
        -:  121:    }
       77:  122:}
        -:  123:
        -:  124:/* Find matches with same descriptions and group them. */
        -:  125:
        -:  126:static void
       78:  127:cd_group(int maxg)
        -:  128:{
        -:  129:    Cdset set1, set2;
        -:  130:    Cdstr str1, str2, *strp;
        -:  131:    int num, width;
        -:  132:
       78:  133:    cd_state.groups = cd_state.descs = cd_state.maxglen = 0;
       78:  134:    cd_state.maxg = 0;
        -:  135:
      303:  136:    for (set1 = cd_state.sets; set1; set1 = set1->next)
      349:  137:        for (str1 = set1->strs; str1; str1 = str1->next) {
      124:  138:            str1->kind = 0;
      124:  139:            str1->other = NULL;
        -:  140:        }
        -:  141:
      303:  142:    for (set1 = cd_state.sets; set1; set1 = set1->next) {
      349:  143:        for (str1 = set1->strs; str1; str1 = str1->next) {
      124:  144:            if (!str1->desc || str1->kind != 0)
      120:  145:                continue;
        -:  146:
        4:  147:            num = 1;
        4:  148:            width = str1->width + cd_state.swidth;
        4:  149:            if (width > cd_state.maxglen)
        3:  150:                cd_state.maxglen = width;
        4:  151:            strp = &(str1->other);
        -:  152:
       12:  153:            for (set2 = set1; set2; set2 = set2->next) {
       17:  154:                for (str2 = (set2 == set1 ? str1->next : set2->strs);
        1:  155:                     str2; str2 = str2->next)
        1:  156:                    if (str2->desc && !strcmp(str1->desc, str2->desc)) {
    #####:  157:                        width += CM_SPACE + str2->width;
    #####:  158:                        if (width > cd_state.maxmlen || num == maxg)
        -:  159:                            break;
    #####:  160:                        if (width > cd_state.maxglen)
    #####:  161:                            cd_state.maxglen = width;
    #####:  162:                        str1->kind = 1;
    #####:  163:                        str2->kind = 2;
    #####:  164:                        num++;
    #####:  165:                        *strp = str2;
    #####:  166:                        strp = &(str2->other);
        -:  167:                    }
        8:  168:                if (str2)
    #####:  169:                    break;
        -:  170:            }
        4:  171:            *strp = NULL;
        -:  172:
        4:  173:            if (num > 1)
    #####:  174:                cd_state.groups++;
        -:  175:            else
        4:  176:                cd_state.descs++;
        -:  177:
        4:  178:            if (num > cd_state.maxg)
        3:  179:                cd_state.maxg = num;
        -:  180:        }
        -:  181:    }
       78:  182:}
        -:  183:
        -:  184:/* Calculate longest prefix and suffix and count the strings with
        -:  185: * descriptions. */
        -:  186:
        -:  187:static void
       78:  188:cd_calc(void)
        -:  189:{
        -:  190:    Cdset set;
        -:  191:    Cdstr str;
        -:  192:    int l;
        -:  193:
       78:  194:    cd_state.pre = cd_state.suf = 0;
        -:  195:
      303:  196:    for (set = cd_state.sets; set; set = set->next) {
      225:  197:        set->count = set->desc = 0;
      349:  198:        for (str = set->strs; str; str = str->next) {
      124:  199:            set->count++;
      124:  200:            if ((l = strlen(str->str)) > cd_state.pre)
       74:  201:                cd_state.pre = l;
      124:  202:            if ((l = ZMB_nicewidth(str->str)) > cd_state.premaxw)
       74:  203:                cd_state.premaxw = l;
      124:  204:            if (str->desc) {
        4:  205:                set->desc++;
        4:  206:                if ((l = strlen(str->desc)) > cd_state.suf) /* ### strlen() assumes no \n */
        4:  207:                    cd_state.suf = l;
        -:  208:            }
        -:  209:        }
        -:  210:    }
       78:  211:}
        -:  212:
        -:  213:/* Return 1 if cd_state specifies unsorted groups, 0 otherwise. */
        -:  214:static int
    #####:  215:cd_groups_want_sorting(void)
        -:  216:{
        -:  217:    Cdset set;
        -:  218:    char *const *i;
        -:  219:
    #####:  220:    for (set = cd_state.sets; set; set = set->next)
    #####:  221:        for (i = set->opts; *i; i++) {
    #####:  222:            if (!strncmp(*i, "-V", 2))
    #####:  223:                return 0;
    #####:  224:            else if (!strncmp(*i, "-J", 2))
    #####:  225:                return 1;
        -:  226:        }
        -:  227:
        -:  228:    /* Sorted by default */
    #####:  229:    return 1;
        -:  230:}
        -:  231:
        -:  232:static int
    #####:  233:cd_sort(const void *a, const void *b)
        -:  234:{
    #####:  235:    return zstrcmp((*((Cdstr *) a))->sortstr, (*((Cdstr *) b))->sortstr, 0);
        -:  236:}
        -:  237:
        -:  238:static int
       78:  239:cd_prep(void)
        -:  240:{
        -:  241:    Cdrun run, *runp;
        -:  242:    Cdset set;
        -:  243:    Cdstr str, *strp;
        -:  244:
       78:  245:    runp = &(cd_state.runs);
        -:  246:
       78:  247:    if (cd_state.groups) {
    #####:  248:        int preplines = cd_state.groups + cd_state.descs;
    #####:  249:        VARARR(Cdstr, grps, preplines);
    #####:  250:        VARARR(int, wids, cd_state.maxg);
        -:  251:        Cdstr gs, gp, gn, *gpp;
        -:  252:        int i, j, d;
        -:  253:        Cdrun expl;
        -:  254:        Cdstr *strp2;
        -:  255:
    #####:  256:        memset(wids, 0, cd_state.maxg * sizeof(int));
    #####:  257:        strp = grps;
        -:  258:
    #####:  259:        for (set = cd_state.sets; set; set = set->next)
    #####:  260:            for (str = set->strs; str; str = str->next) {
    #####:  261:                if (str->kind != 1) {
    #####:  262:                    if (!str->kind && str->desc) {
    #####:  263:                        if (str->width > wids[0])
    #####:  264:                            wids[0] = str->width;
    #####:  265:                        str->other = NULL;
    #####:  266:                        *strp++ = str;
        -:  267:                    }
    #####:  268:                    continue;
        -:  269:                }
    #####:  270:                gs = str;
    #####:  271:                gs->kind = 2;
    #####:  272:                gp = str->other;
    #####:  273:                gs->other = NULL;
    #####:  274:                for (; gp; gp = gn) {
    #####:  275:                    gn = gp->other;
    #####:  276:                    gp->other = NULL;
    #####:  277:                    for (gpp = &gs; *gpp && (*gpp)->width > gp->width;
    #####:  278:                         gpp = &((*gpp)->other));
    #####:  279:                    gp->other = *gpp;
    #####:  280:                    *gpp = gp;
        -:  281:                }
    #####:  282:                for (gp = gs, i = 0; gp; gp = gp->other, i++)
    #####:  283:                    if (gp->width > wids[i])
    #####:  284:                        wids[i] = gp->width;
        -:  285:
    #####:  286:                *strp++ = gs;
        -:  287:            }
        -:  288:
    #####:  289:        cd_state.gprew = 0;
    #####:  290:        for (i = 0; i < cd_state.maxg; i++) {
    #####:  291:            cd_state.gprew += wids[i] + CM_SPACE;
        -:  292:	}
        -:  293:
    #####:  294:        if (cd_state.gprew > cd_state.maxmlen && cd_state.maxglen > 1)
    #####:  295:            return 1;
        -:  296:
    #####:  297:	for (i = 0; i < preplines; i++) {
    #####:  298:	    Cdstr s = grps[i];
        -:  299:	    int dummy;
        -:  300:
    #####:  301:	    s->sortstr = ztrdup(s->str);
    #####:  302:	    unmetafy(s->sortstr, &dummy);
        -:  303:	}
        -:  304:
    #####:  305:        if (cd_groups_want_sorting())
    #####:  306:            qsort(grps, preplines, sizeof(Cdstr), cd_sort);
        -:  307:
    #####:  308:        for (i = preplines, strp = grps; i > 1; i--, strp++) {
    #####:  309:            strp2 = strp + 1;
    #####:  310:            if (!strcmp((*strp)->desc, (*strp2)->desc))
    #####:  311:                continue;
    #####:  312:            for (j = i - 2, strp2++; j > 0; j--, strp2++)
    #####:  313:                if (!strcmp((*strp)->desc, (*strp2)->desc)) {
    #####:  314:                    Cdstr tmp = *strp2;
        -:  315:
    #####:  316:                    memmove(strp + 2, strp + 1,
    #####:  317:                            (strp2 - strp - 1) * sizeof(Cdstr));
        -:  318:
    #####:  319:                    *++strp = tmp;
    #####:  320:                    i--;
        -:  321:                }
        -:  322:        }
    #####:  323:        expl =  (Cdrun) zalloc(sizeof(*run));
    #####:  324:        expl->type = CRT_EXPL;
    #####:  325:        expl->strs = grps[0];
    #####:  326:        expl->count = preplines;
        -:  327:
    #####:  328:        for (i = preplines, strp = grps, strp2 = NULL; i; i--, strp++) {
    #####:  329:            str = *strp;
    #####:  330:            *strp = str->other;
    #####:  331:            if (strp2)
    #####:  332:                *strp2 = str;
    #####:  333:            strp2 = &(str->run);
        -:  334:
    #####:  335:            *runp = run = (Cdrun) zalloc(sizeof(*run));
    #####:  336:            runp = &(run->next);
    #####:  337:            run->type = CRT_SPEC;
    #####:  338:            run->strs = str;
    #####:  339:            run->count = 1;
        -:  340:        }
    #####:  341:        *strp2 = NULL;
        -:  342:
    #####:  343:        for (i = cd_state.maxg - 1; i; i--) {
    #####:  344:            for (d = 0, j = preplines, strp = grps; j; j--, strp++) {
    #####:  345:                if ((str = *strp)) {
    #####:  346:                    if (d) {
    #####:  347:                        *runp = run = (Cdrun) zalloc(sizeof(*run));
    #####:  348:                        runp = &(run->next);
    #####:  349:                        run->type = CRT_DUMMY;
    #####:  350:                        run->strs = expl->strs;
    #####:  351:                        run->count = d;
    #####:  352:                        d = 0;
        -:  353:                    }
    #####:  354:                    *runp = run = (Cdrun) zalloc(sizeof(*run));
    #####:  355:                    runp = &(run->next);
    #####:  356:                    run->type = CRT_SPEC;
    #####:  357:                    run->strs = str;
    #####:  358:                    run->strs->run = NULL;
    #####:  359:                    run->count = 1;
        -:  360:
    #####:  361:                    *strp = str->other;
        -:  362:                } else
    #####:  363:                    d++;
        -:  364:            }
    #####:  365:            if (d) {
    #####:  366:                *runp = run = (Cdrun) zalloc(sizeof(*run));
    #####:  367:                runp = &(run->next);
    #####:  368:                run->type = CRT_DUMMY;
    #####:  369:                run->strs = expl->strs;
    #####:  370:                run->count = d;
        -:  371:            }
        -:  372:        }
    #####:  373:        *runp = expl;
    #####:  374:        runp = &(expl->next);
        -:  375:
    #####:  376:        for (set = cd_state.sets; set; set = set->next) {
    #####:  377:            for (i = 0, gs = NULL, gpp = &gs, str = set->strs;
    #####:  378:                 str; str = str->next) {
    #####:  379:                if (str->kind || str->desc)
    #####:  380:                    continue;
        -:  381:
    #####:  382:                i++;
    #####:  383:                *gpp = str;
    #####:  384:                gpp = &(str->run);
        -:  385:            }
    #####:  386:            *gpp = NULL;
    #####:  387:            if (i) {
    #####:  388:                *runp = run = (Cdrun) zalloc(sizeof(*run));
    #####:  389:                runp = &(run->next);
    #####:  390:                run->type = CRT_SIMPLE;
    #####:  391:                run->strs = gs;
    #####:  392:                run->count = i;
        -:  393:            }
        -:  394:        }
       78:  395:    } else if (cd_state.showd) {
      303:  396:        for (set = cd_state.sets; set; set = set->next) {
      225:  397:            if (set->desc) {
        3:  398:                *runp = run = (Cdrun) zalloc(sizeof(*run));
        3:  399:                runp = &(run->next);
        3:  400:                run->type = CRT_DESC;
        3:  401:                strp = &(run->strs);
        7:  402:                for (str = set->strs; str; str = str->next)
        4:  403:                    if (str->desc) {
        4:  404:                        *strp = str;
        4:  405:                        strp = &(str->run);
        -:  406:                    }
        3:  407:                *strp = NULL;
        3:  408:                run->count = set->desc;
        -:  409:            }
      225:  410:            if (set->desc != set->count) {
       70:  411:                *runp = run = (Cdrun) zalloc(sizeof(*run));
       70:  412:                runp = &(run->next);
       70:  413:                run->type = CRT_SIMPLE;
       70:  414:                strp = &(run->strs);
      190:  415:                for (str = set->strs; str; str = str->next)
      120:  416:                    if (!str->desc) {
      120:  417:                        *strp = str;
      120:  418:                        strp = &(str->run);
        -:  419:                    }
       70:  420:                *strp = NULL;
       70:  421:                run->count = set->count - set->desc;
        -:  422:            }
        -:  423:        }
        -:  424:    } else {
    #####:  425:        for (set = cd_state.sets; set; set = set->next)
    #####:  426:            if (set->count) {
    #####:  427:                *runp = run = (Cdrun) zalloc(sizeof(*run));
    #####:  428:                runp = &(run->next);
    #####:  429:                run->type = CRT_SIMPLE;
    #####:  430:                run->strs = set->strs;
    #####:  431:                for (str = set->strs; str; str = str->next)
    #####:  432:                    str->run = str->next;
    #####:  433:                run->count = set->count;
        -:  434:            }
        -:  435:    }
       78:  436:    *runp = NULL;
        -:  437:
       78:  438:    return 0;
        -:  439:}
        -:  440:
        -:  441:/* Duplicate and concatenate two arrays.  Return the result. */
        -:  442:
        -:  443:static char **
      225:  444:cd_arrcat(char **a, char **b)
        -:  445:{
      225:  446:    if (!b)
    #####:  447:        return zarrdup(a);
        -:  448:    else {
      225:  449:        char **r = (char **) zalloc((arrlen(a) + arrlen(b) + 1) *
        -:  450:                                    sizeof(char *));
      225:  451:        char **p = r;
        -:  452:
      955:  453:        for (; *a; a++)
      730:  454:            *p++ = ztrdup(*a);
     1125:  455:        for (; *b; b++)
      900:  456:            *p++ = ztrdup(*b);
        -:  457:
      225:  458:        *p = NULL;
        -:  459:
      225:  460:        return r;
        -:  461:    }
        -:  462:}
        -:  463:
        -:  464:/* Initialisation. Store and calculate the string and matches and so on.
        -:  465: *
        -:  466: * nam: argv[0] of the builtin
        -:  467: * hide: ???
        -:  468: * mlen: see max-matches-width style
        -:  469: * sep: see list-seperator style
        -:  470: * opts: options to (eventually) pass to compadd.
        -:  471: *       Returned via 2nd return parameter of 'compdescribe -g'.
        -:  472: * args: ??? (the positional arguments to 'compdescribe')
        -:  473: * disp: 1 if descriptions should be shown, 0 otherwise
        -:  474: */
        -:  475:
        -:  476:static int
       78:  477:cd_init(char *nam, char *hide, char *mlen, char *sep,
        -:  478:        char **opts, char **args, int disp)
        -:  479:{
        -:  480:    Cdset *setp, set;
        -:  481:    Cdstr *strp, str;
        -:  482:    char **ap, *tmp;
       78:  483:    int grp = 0, itmp;
        -:  484:
       78:  485:    if (cd_parsed) {
       77:  486:	zsfree(cd_state.sep);
       77:  487:	freecdsets(cd_state.sets);
       77:  488:	cd_parsed = 0;
        -:  489:    }
       78:  490:    setp = &(cd_state.sets);
       78:  491:    cd_state.sep = ztrdup(sep);
       78:  492:    cd_state.slen = strlen(sep);
       78:  493:    cd_state.swidth = ZMB_nicewidth(sep);
       78:  494:    cd_state.sets = NULL;
       78:  495:    cd_state.showd = disp;
       78:  496:    cd_state.maxg = cd_state.groups = cd_state.descs = 0;
       78:  497:    cd_state.maxmlen = atoi(mlen);
       78:  498:    cd_state.premaxw = 0;
       78:  499:    itmp = zterm_columns - cd_state.swidth - 4;
       78:  500:    if (cd_state.maxmlen > itmp)
    #####:  501:        cd_state.maxmlen = itmp;
       78:  502:    if (cd_state.maxmlen < 4)
    #####:  503:        cd_state.maxmlen = 4;
       78:  504:    if (*args && !strcmp(*args, "-g")) {
       78:  505:        args++;
       78:  506:        grp = 1;
        -:  507:    }
      381:  508:    while (*args) {
      225:  509:	*setp = set = (Cdset) zshcalloc(sizeof(*set));
      225:  510:	setp = &(set->next);
      225:  511:        *setp = NULL;
      225:  512:        set->opts = NULL;
      225:  513:        set->strs = NULL;
        -:  514:
      225:  515:	if (!(ap = get_user_var(*args))) {
    #####:  516:	    zwarnnam(nam, "invalid argument: %s", *args);
    #####:  517:            zsfree(cd_state.sep);
    #####:  518:            freecdsets(cd_state.sets);
    #####:  519:	    return 1;
        -:  520:	}
      349:  521:        for (str = NULL, strp = &(set->strs); *ap; ap++) {
      124:  522:            *strp = str = (Cdstr) zalloc(sizeof(*str));
      124:  523:            strp = &(str->next);
        -:  524:
      124:  525:            str->kind = 0;
      124:  526:            str->other = NULL;
      124:  527:            str->set = set;
        -:  528:
        -:  529:	    /* Advance tmp to the first unescaped colon. */
      463:  530:	    for (tmp = *ap; *tmp && *tmp != ':'; tmp++)
      339:  531:                if (*tmp == '\\' && tmp[1])
        1:  532:                    tmp++;
        -:  533:
      124:  534:            if (*tmp)
        4:  535:                str->desc = ztrdup(rembslash(tmp + 1));
        -:  536:            else
      120:  537:                str->desc = NULL;
      124:  538:            *tmp = '\0';
      124:  539:            str->str = str->match = ztrdup(rembslash(*ap));
      124:  540:            str->len = strlen(str->str);
      124:  541:            str->width = ZMB_nicewidth(str->str);
      124:  542:	    str->sortstr = NULL;
        -:  543:        }
      225:  544:        if (str)
       73:  545:            str->next = NULL;
        -:  546:
      225:  547:	if (*++args && **args != '-') {
        7:  548:	    if (!(ap = get_user_var(*args))) {
    #####:  549:		zwarnnam(nam, "invalid argument: %s", *args);
    #####:  550:                zsfree(cd_state.sep);
    #####:  551:                freecdsets(cd_state.sets);
    #####:  552:		return 1;
        -:  553:	    }
       18:  554:            for (str = set->strs; str && *ap; str = str->next, ap++)
       11:  555:                str->match = ztrdup(*ap);
        -:  556:
        7:  557:	    args++;
        -:  558:	}
      225:  559:        if (hide && *hide) {
    #####:  560:            for (str = set->strs; str; str = str->next) {
    #####:  561:                if (str->str == str->match)
    #####:  562:                    str->str = ztrdup(str->str);
    #####:  563:                if (hide[1] && str->str[0] == '-' && str->str[1] == '-')
    #####:  564:                    memmove(str->str, str->str + 2, strlen(str->str) - 1);
    #####:  565:                else if (str->str[0] == '-' || str->str[0] == '+')
    #####:  566:                    memmove(str->str, str->str + 1, strlen(str->str));
        -:  567:            }
        -:  568:        }
     2057:  569:	for (ap = args; *args &&
     1466:  570:		 (args[0][0] != '-' || args[0][1] != '-' || args[0][2]);
      730:  571:	     args++);
        -:  572:
      225:  573:	tmp = *args;
      225:  574:	*args = NULL;
      225:  575:	set->opts = cd_arrcat(ap, opts);
      225:  576:	if ((*args = tmp))
      147:  577:	    args++;
        -:  578:    }
      156:  579:    if (disp && grp) {
       78:  580:        int mg = zterm_columns;
        -:  581:
        -:  582:        do {
       78:  583:            cd_group(mg);
       78:  584:            mg = cd_state.maxg - 1;
       78:  585:            cd_calc();
       78:  586:        } while (cd_prep());
        -:  587:
        -:  588:    } else {
    #####:  589:        cd_calc();
    #####:  590:        cd_prep();
        -:  591:    }
       78:  592:    cd_parsed = 1;
       78:  593:    return 0;
        -:  594:}
        -:  595:
        -:  596:/* Copy an array with one element in reserve (at the beginning). */
        -:  597:
        -:  598:static char **
        3:  599:cd_arrdup(char **a)
        -:  600:{
        3:  601:    char **r = (char **) zalloc((arrlen(a) + 2) * sizeof(char *));
        3:  602:    char **p = r + 1;
        -:  603:
       26:  604:    while (*a)
       20:  605:        *p++ = ztrdup(*a++);
        3:  606:    *p = NULL;
        -:  607:
        3:  608:    return r;
        -:  609:}
        -:  610:
        -:  611:/* Get the next set. */
        -:  612:
        -:  613:static int
      151:  614:cd_get(char **params)
        -:  615:{
        -:  616:    Cdrun run;
        -:  617:
      151:  618:    if ((run = cd_state.runs)) {
        -:  619:        Cdstr str;
       73:  620:        char **mats, **mp, **dpys, **dp, **opts, *csl = "";
        -:  621:
       73:  622:        cd_state.runs = run->next;
        -:  623:
       73:  624:        switch (run->type) {
       70:  625:        case CRT_SIMPLE:
       70:  626:            mats = mp = (char **) zalloc((run->count + 1) * sizeof(char *));
       70:  627:            dpys = dp = (char **) zalloc((run->count + 1) * sizeof(char *));
        -:  628:
      190:  629:            for (str = run->strs; str; str = str->run) {
      120:  630:                *mp++ = ztrdup(str->match);
      120:  631:                *dp++ = ztrdup(str->str ? str->str : str->match);
        -:  632:            }
       70:  633:            *mp = *dp = NULL;
       70:  634:            opts = zarrdup(run->strs->set->opts);
       70:  635:            if (cd_state.groups) {
        -:  636:                /* We are building a columnised list with dummy matches
        -:  637:                 * but there are also matches without descriptions.
        -:  638:                 * Those end up in a different group, so make sure that
        -:  639:                 * group doesn't have an explanation. */
        -:  640:
    #####:  641:                for (mp = dp = opts; *mp; mp++) {
    #####:  642:                    if (dp[0][0] == '-' && dp[0][1] == 'X') {
    #####:  643:                        if (!dp[0][2] && dp[1])
    #####:  644:                            mp++;
        -:  645:                    } else
    #####:  646:                        *dp++ = *mp;
        -:  647:                }
    #####:  648:                *dp = NULL;
        -:  649:            }
       70:  650:            break;
        -:  651:
        3:  652:        case CRT_DESC:
        -:  653:            {
        -:  654:		/*
        -:  655:		 * The buffer size:
        -:  656:		 *     max prefix length (cd_state.pre) +
        -:  657:		 *     max padding (cd_state.premaxw generously :) +
        -:  658:		 *     separator length (cd_state.slen) +
        -:  659:		 *     inter matches gap (CM_SPACE) +
        -:  660:		 *     max description length (cd_state.suf) +
        -:  661:		 *     trailing \0
        -:  662:		 */
        3:  663:                VARARR(char, buf,
        -:  664:                       cd_state.pre + cd_state.suf +
        -:  665:		       cd_state.premaxw + cd_state.slen + 3);
        3:  666:                mats = mp = (char **) zalloc((run->count + 1) * sizeof(char *));
        3:  667:                dpys = dp = (char **) zalloc((run->count + 1) * sizeof(char *));
        -:  668:
        7:  669:                for (str = run->strs; str; str = str->run) {
        4:  670:		    char *p = buf, *pp, *d;
        -:  671:		    int l, remw, w;
        -:  672:
        4:  673:                    *mp++ = ztrdup(str->match);
        4:  674:		    strcpy(p, str->str);
        4:  675:		    p += str->len;
        4:  676:                    memset(p, ' ', (l = (cd_state.premaxw - str->width + CM_SPACE)));
        4:  677:		    p += l;
        -:  678:
       12:  679:		    remw = zterm_columns - cd_state.premaxw -
        8:  680:			cd_state.swidth - 3;
        8:  681:		    while (remw < 0 && zterm_columns) {
        -:  682:			/* line wrapped, use remainder of the extra line */
    #####:  683:			remw += zterm_columns;
        -:  684:		    }
        4:  685:		    if (cd_state.slen < remw) {
        4:  686:			strcpy(p, cd_state.sep);
        4:  687:			p += cd_state.slen;
        4:  688:			remw -= cd_state.slen;
        -:  689:
        -:  690:			/*
        -:  691:			 * copy a character at once until no more screen
        -:  692:			 * width is available. Leave 1 character at the
        -:  693:			 * end of screen as safety margin
        -:  694:			 */
        4:  695:			d = str->desc;
        4:  696:			w = ZMB_nicewidth(d);
        4:  697:			if (w <= remw)
        4:  698:			    strcpy(p, d);
        -:  699:			else {
    #####:  700:			    pp = p;
    #####:  701:			    while (remw > 0 && *d) {
    #####:  702:				l = MB_METACHARLEN(d);
    #####:  703:				memcpy(pp, d, l);
    #####:  704:				pp[l] = '\0';
    #####:  705:				w = ZMB_nicewidth(pp);
    #####:  706:				if (w > remw) {
    #####:  707:				    *pp = '\0';
    #####:  708:				    break;
        -:  709:				}
        -:  710:
    #####:  711:				pp += l;
    #####:  712:				d += l;
    #####:  713:				remw -= w;
        -:  714:			    }
        -:  715:			}
        -:  716:		    }
        -:  717:
        4:  718:                    *dp++ = ztrdup(buf);
        -:  719:                }
        3:  720:                *mp = *dp = NULL;
        3:  721:                opts = cd_arrdup(run->strs->set->opts);
        3:  722:                opts[0] = ztrdup("-l");
        3:  723:                break;
        -:  724:            }
        -:  725:
    #####:  726:        case CRT_SPEC:
    #####:  727:            mats = (char **) zalloc(2 * sizeof(char *));
    #####:  728:            dpys = (char **) zalloc(2 * sizeof(char *));
    #####:  729:            mats[0] = ztrdup(run->strs->match);
    #####:  730:            dpys[0] = ztrdup(run->strs->str);
    #####:  731:            mats[1] = dpys[1] = NULL;
    #####:  732:            opts = cd_arrdup(run->strs->set->opts);
        -:  733:
        -:  734:            /* Set -2V, possibly reusing the group name from an existing -J/-V
        -:  735:             * flag. */
    #####:  736:            for (dp = opts + 1; *dp; dp++)
    #####:  737:                if ((dp[0][0] == '-' && dp[0][1] == 'J') ||
    #####:  738:		    (dp[0][0] == '-' && dp[0][1] == 'V'))
        -:  739:                    break;
    #####:  740:            if (*dp) {
    #####:  741:                char *s = tricat("-2V", "", dp[0] + 2);
        -:  742:
    #####:  743:                zsfree(*dp);
    #####:  744:                *dp = s;
        -:  745:
    #####:  746:                memmove(opts, opts + 1,
    #####:  747:                        (arrlen(opts + 1) + 1) * sizeof(char *));
        -:  748:                
        -:  749:            } else
    #####:  750:                opts[0] = ztrdup("-2V-default-");
    #####:  751:            csl = "packed";
    #####:  752:            break;
        -:  753:  
    #####:  754:        case CRT_DUMMY:
        -:  755:            {
        -:  756:                char buf[20];
        -:  757:
    #####:  758:                sprintf(buf, "-E%d", run->count);
        -:  759:
    #####:  760:                mats = (char **) zalloc(sizeof(char *));
    #####:  761:                dpys = (char **) zalloc(sizeof(char *));
    #####:  762:                mats[0] = dpys[0] = NULL;
        -:  763:
    #####:  764:                opts = cd_arrdup(run->strs->set->opts);
    #####:  765:                opts[0] = ztrdup(buf);
        -:  766:
    #####:  767:                csl = "packed";
        -:  768:            }
    #####:  769:            break;
        -:  770:
    #####:  771:	default: /* This silences the "might be used uninitialized" warnings */
        -:  772:        case CRT_EXPL:
        -:  773:            {
        -:  774:		/* add columns as safety margin */
    #####:  775:                VARARR(char, dbuf, cd_state.suf + cd_state.slen +
        -:  776:		       zterm_columns);
        -:  777:                char buf[20], *p, *pp, *d;
    #####:  778:                int i = run->count, remw, w, l;
        -:  779:
    #####:  780:                sprintf(buf, "-E%d", i);
        -:  781:
    #####:  782:                mats = (char **) zalloc(sizeof(char *));
    #####:  783:                dpys = (char **) zalloc((i + 1) * sizeof(char *));
        -:  784:
    #####:  785:                for (dp = dpys, str = run->strs; str; str = str->run) {
    #####:  786:                    if (str->run && !strcmp(str->desc, str->run->desc)) {
    #####:  787:                        *dp++ = ztrdup("");
    #####:  788:                        continue;
        -:  789:                    }
        -:  790:
    #####:  791:                    strcpy(dbuf, cd_state.sep);
    #####:  792:		    remw = zterm_columns - cd_state.gprew -
    #####:  793:			cd_state.swidth - CM_SPACE;
    #####:  794:		    p = pp = dbuf + cd_state.slen;
    #####:  795:		    d = str->desc;
    #####:  796:		    w = ZMB_nicewidth(d);
    #####:  797:		    if (w <= remw) {
    #####:  798:			strcpy(p, d);
    #####:  799:			remw -= w;
    #####:  800:			pp += strlen(d);
        -:  801:		    } else
    #####:  802:			while (remw > 0 && *d) {
    #####:  803:			    l = MB_METACHARLEN(d);
    #####:  804:			    memcpy(pp, d, l);
    #####:  805:			    pp[l] = '\0';
    #####:  806:			    w = ZMB_nicewidth(pp);
    #####:  807:			    if (w > remw) {
    #####:  808:				*pp = '\0';
    #####:  809:				break;
        -:  810:			    }
        -:  811:
    #####:  812:			    pp += l;
    #####:  813:			    d += l;
    #####:  814:			    remw -= w;
        -:  815:			}
        -:  816:
    #####:  817:		    while (remw-- > 0)
    #####:  818:			*pp++ = ' ';
    #####:  819:		    *pp = '\0';
        -:  820:
    #####:  821:                    *dp++ = ztrdup(dbuf);
        -:  822:                }
    #####:  823:                mats[0] = *dp = NULL;
        -:  824:
    #####:  825:                opts = cd_arrdup(run->strs->set->opts);
    #####:  826:                opts[0] = ztrdup(buf);
        -:  827:
    #####:  828:                csl = "packed";
        -:  829:            }
    #####:  830:            break;
        -:  831:        }
       73:  832:        setsparam(params[0], ztrdup(csl));
       73:  833:        setaparam(params[1], opts);
       73:  834:        setaparam(params[2], mats);
       73:  835:        setaparam(params[3], dpys);
        -:  836:
       73:  837:        zfree(run, sizeof(*run));
        -:  838:
       73:  839:        return 0;
        -:  840:    }
       78:  841:    return 1;
        -:  842:}
        -:  843:
        -:  844:/**/
        -:  845:static int
      229:  846:bin_compdescribe(char *nam, char **args, UNUSED(Options ops), UNUSED(int func))
        -:  847:{
      229:  848:    int n = arrlen(args);
        -:  849:
      229:  850:    if (incompfunc != 1) {
    #####:  851:	zwarnnam(nam, "can only be called from completion function");
    #####:  852:	return 1;
        -:  853:    }
      229:  854:    if (!args[0][0] || !args[0][1] || args[0][2]) {
    #####:  855:	zwarnnam(nam, "invalid argument: %s", args[0]);
    #####:  856:	return 1;
        -:  857:    }
      229:  858:    switch (args[0][1]) {
    #####:  859:    case 'i':
    #####:  860:        if (n < 3) {
    #####:  861:            zwarnnam(nam, "not enough arguments");
        -:  862:
    #####:  863:            return 1;
        -:  864:        }
    #####:  865:	return cd_init(nam, args[1], args[2], "", NULL, args + 3, 0);
       78:  866:    case 'I':
       78:  867:        if (n < 6) {
    #####:  868:            zwarnnam(nam, "not enough arguments");
        -:  869:
    #####:  870:            return 1;
        -:  871:        } else {
        -:  872:            char **opts;
        -:  873:
       78:  874:            if (!(opts = getaparam(args[4]))) {
    #####:  875:		zwarnnam(nam, "unknown parameter: %s", args[4]);
    #####:  876:		return 1;
        -:  877:            }
       78:  878:            return cd_init(nam, args[1], args[2], args[3], opts, args + 5, 1);
        -:  879:        }
      151:  880:    case 'g':
      151:  881:	if (cd_parsed) {
      151:  882:	    if (n != 5) {
    #####:  883:		zwarnnam(nam, (n < 5 ? "not enough arguments" :
        -:  884:			      "too many arguments"));
    #####:  885:		return 1;
        -:  886:	    }
      151:  887:	    return cd_get(args + 1);
        -:  888:	} else {
    #####:  889:	    zwarnnam(nam, "no parsed state");
    #####:  890:	    return 1;
        -:  891:	}
        -:  892:    }
    #####:  893:    zwarnnam(nam, "invalid option: %s", args[0]);
    #####:  894:    return 1;
        -:  895:}
        -:  896:
        -:  897:/* Help for `_arguments'. */
        -:  898:
        -:  899:typedef struct cadef *Cadef;
        -:  900:typedef struct caopt *Caopt;
        -:  901:typedef struct caarg *Caarg;
        -:  902:
        -:  903:/* Cache for a set of _arguments-definitions. */
        -:  904:
        -:  905:struct cadef {
        -:  906:    Cadef next;			/* next in cache */
        -:  907:    Cadef snext;		/* next set */
        -:  908:    Caopt opts;			/* the options */
        -:  909:    int nopts, ndopts, nodopts;	/* number of options/direct/optional direct */
        -:  910:    Caarg args;			/* the normal arguments */
        -:  911:    Caarg rest;			/* the rest-argument */
        -:  912:    char **defs;		/* the original strings */
        -:  913:    int ndefs;			/* number of ... */
        -:  914:    int lastt;			/* last time this was used */
        -:  915:    Caopt *single;		/* array of single-letter options */
        -:  916:    char *match;		/* -M spec to use */
        -:  917:    int argsactive;		/* if normal arguments are still allowed */
        -:  918:				/* used while parsing a command line */
        -:  919:    char *set;			/* set name prefix (<name>-), shared */
        -:  920:    int flags;			/* see CDF_* below */
        -:  921:    char *nonarg;		/* pattern for non-args (-A argument) */
        -:  922:};
        -:  923:
        -:  924:#define CDF_SEP 1		/* -S was specified: -- terminates options */
        -:  925:
        -:  926:/* Description for an option. */
        -:  927:
        -:  928:struct caopt {
        -:  929:    Caopt next;
        -:  930:    char *name;			/* option name */
        -:  931:    char *descr;		/* the description */
        -:  932:    char **xor;			/* if this, then not ... */
        -:  933:    int type;			/* type, CAO_* */
        -:  934:    Caarg args;			/* option arguments */
        -:  935:    int active;			/* still allowed on command line */
        -:  936:    int num;			/* it's the num'th option */
        -:  937:    char *gsname;		/* group or set name, shared */
        -:  938:    int not;			/* don't complete this option (`!...') */
        -:  939:};
        -:  940:
        -:  941:#define CAO_NEXT    1		/* argument follows in next argument (`-opt:...') */
        -:  942:#define CAO_DIRECT  2		/* argument follows option directly (`-opt-:...') */
        -:  943:#define CAO_ODIRECT 3		/* argument may follow option directly (`-opt+:...') */
        -:  944:#define CAO_EQUAL   4		/* argument follows mandatory equals (`-opt=-:...') */
        -:  945:#define CAO_OEQUAL  5		/* argument follows optional equals (`-opt=:...') */
        -:  946:
        -:  947:/* Description for an argument */
        -:  948:
        -:  949:struct caarg {
        -:  950:    Caarg next;
        -:  951:    char *descr;		/* description */
        -:  952:    char **xor;			/* if this, then not ... */
        -:  953:    char *action;		/* what to do for it */
        -:  954:    int type;			/* CAA_* below */
        -:  955:    char *end;			/* end-pattern for ::<pat>:... */
        -:  956:    char *opt;			/* option name if for an option */
        -:  957:    int num;			/* it's the num'th argument */
        -:  958:    int min;			/* earliest possible arg pos, given optional args */
        -:  959:    int direct;			/* true if argument number was given explicitly */
        -:  960:    int active;			/* still allowed on command line */
        -:  961:    char *gsname;		/* group or set name, shared */
        -:  962:};
        -:  963:
        -:  964:#define CAA_NORMAL 1
        -:  965:#define CAA_OPT    2
        -:  966:#define CAA_REST   3
        -:  967:#define CAA_RARGS  4
        -:  968:#define CAA_RREST  5
        -:  969:
        -:  970:/* The cache of parsed descriptions. */
        -:  971:
        -:  972:#define MAX_CACACHE 8
        -:  973:static Cadef cadef_cache[MAX_CACACHE];
        -:  974:
        -:  975:/* Compare two arrays of strings for equality. */
        -:  976:
        -:  977:static int
      237:  978:arrcmp(char **a, char **b)
        -:  979:{
      237:  980:    if (!a && !b)
    #####:  981:	return 1;
      237:  982:    else if (!a || !b)
    #####:  983:	return 0;
        -:  984:    else {
     1203:  985:	while (*a && *b)
      884:  986:	    if (strcmp(*a++, *b++))
      155:  987:		return 0;
        -:  988:
       82:  989:	return (!*a && !*b);
        -:  990:    }
        -:  991:}
        -:  992:
        -:  993:/* Memory stuff. Obviously. */
        -:  994:
        -:  995:static void
      367:  996:freecaargs(Caarg a)
        -:  997:{
        -:  998:    Caarg n;
        -:  999:
      445: 1000:    for (; a; a = n) {
       78: 1001:	n = a->next;
       78: 1002:	zsfree(a->descr);
       78: 1003:	if (a->xor)
        2: 1004:	    freearray(a->xor);
       78: 1005:	zsfree(a->action);
       78: 1006:	zsfree(a->end);
       78: 1007:	zsfree(a->opt);
       78: 1008:	zfree(a, sizeof(*a));
        -: 1009:    }
      367: 1010:}
        -: 1011:
        -: 1012:static void
       85: 1013:freecadef(Cadef d)
        -: 1014:{
        -: 1015:    Cadef s;
        -: 1016:    Caopt p, n;
        -: 1017:
      258: 1018:    while (d) {
       88: 1019:	s = d->snext;
       88: 1020:	zsfree(d->match);
       88: 1021:	zsfree(d->set);
       88: 1022:	if (d->defs)
       77: 1023:	    freearray(d->defs);
        -: 1024:
      279: 1025:	for (p = d->opts; p; p = n) {
      191: 1026:	    n = p->next;
      191: 1027:	    zsfree(p->name);
      191: 1028:	    zsfree(p->descr);
      191: 1029:	    if (p->xor)
      182: 1030:		freearray(p->xor);
      191: 1031:	    freecaargs(p->args);
      191: 1032:	    zfree(p, sizeof(*p));
        -: 1033:	}
       88: 1034:	freecaargs(d->args);
       88: 1035:	freecaargs(d->rest);
       88: 1036:	zsfree(d->nonarg);
       88: 1037:	if (d->single)
       13: 1038:	    zfree(d->single, 256 * sizeof(Caopt));
       88: 1039:	zfree(d, sizeof(*d));
       88: 1040:	d = s;
        -: 1041:    }
       85: 1042:}
        -: 1043:
        -: 1044:/* Remove backslashes before colons. */
        -: 1045:
        -: 1046:static char *
      589: 1047:rembslashcolon(char *s)
        -: 1048:{
        -: 1049:    char *p, *r;
        -: 1050:
      589: 1051:    r = p = s = dupstring(s);
        -: 1052:
     3121: 1053:    while (*s) {
     1943: 1054:	if (s[0] != '\\' || s[1] != ':')
     1941: 1055:	    *p++ = *s;
     1943: 1056:	s++;
        -: 1057:    }
      589: 1058:    *p = '\0';
        -: 1059:
      589: 1060:    return r;
        -: 1061:}
        -: 1062:
        -: 1063:/* Add backslashes before colons. */
        -: 1064:
        -: 1065:static char *
      178: 1066:bslashcolon(char *s)
        -: 1067:{
        -: 1068:    char *p, *r;
        -: 1069:
      178: 1070:    r = p = zhalloc((2 * strlen(s)) + 1);
        -: 1071:
      861: 1072:    while (*s) {
      505: 1073:	if (*s == ':')
    #####: 1074:	    *p++ = '\\';
      505: 1075:	*p++ = *s++;
        -: 1076:    }
      178: 1077:    *p = '\0';
        -: 1078:
      178: 1079:    return r;
        -: 1080:}
        -: 1081:
        -: 1082:/* Parse an argument definition. */
        -: 1083:
        -: 1084:static Caarg
       92: 1085:parse_caarg(int mult, int type, int num, int opt, char *oname, char **def,
        -: 1086:	    char *set)
        -: 1087:{
       92: 1088:    Caarg ret = (Caarg) zalloc(sizeof(*ret));
       92: 1089:    char *p = *def, *d, sav;
        -: 1090:
       92: 1091:    ret->next = NULL;
       92: 1092:    ret->descr = ret->action = ret->end = NULL;
       92: 1093:    ret->xor = NULL;
       92: 1094:    ret->num = num;
       92: 1095:    ret->min = num - opt;
       92: 1096:    ret->type = type;
       92: 1097:    ret->opt = ztrdup(oname);
       92: 1098:    ret->direct = 0;
       92: 1099:    ret->gsname = set;
        -: 1100:
        -: 1101:    /* Get the description. */
        -: 1102:
      438: 1103:    for (d = p; *p && *p != ':'; p++)
      346: 1104:	if (*p == '\\' && p[1])
    #####: 1105:	    p++;
       92: 1106:    sav = *p;
       92: 1107:    *p = '\0';
       92: 1108:    ret->descr = ztrdup(rembslashcolon(d));
        -: 1109:
        -: 1110:    /* Get the action if there is one. */
        -: 1111:
       92: 1112:    if (sav) {
       73: 1113:	if (mult) {
      105: 1114:	    for (d = ++p; *p && *p != ':'; p++)
       83: 1115:		if (*p == '\\' && p[1])
    #####: 1116:		    p++;
       22: 1117:	    sav = *p;
       22: 1118:	    *p = '\0';
       22: 1119:	    ret->action = ztrdup(rembslashcolon(d));
       22: 1120:	    if (sav)
        3: 1121:		*p = ':';
        -: 1122:	} else
       51: 1123:	    ret->action = ztrdup(rembslashcolon(p + 1));
        -: 1124:    } else
       19: 1125:	ret->action = ztrdup("");
       92: 1126:    *def = p;
        -: 1127:
       92: 1128:    return ret;
        -: 1129:}
        -: 1130:
        -: 1131:static Cadef
      103: 1132:alloc_cadef(char **args, int single, char *match, char *nonarg, int flags)
        -: 1133:{
        -: 1134:    Cadef ret;
        -: 1135:
      103: 1136:    ret = (Cadef) zalloc(sizeof(*ret));
      103: 1137:    ret->next = ret->snext = NULL;
      103: 1138:    ret->opts = NULL;
      103: 1139:    ret->args = ret->rest = NULL;
      103: 1140:    ret->nonarg = ztrdup(nonarg);
      103: 1141:    if (args) {
       85: 1142:	ret->defs = zarrdup(args);
       85: 1143:	ret->ndefs = arrlen(args);
        -: 1144:    } else {
       18: 1145:	ret->defs = NULL;
       18: 1146:	ret->ndefs = 0;
        -: 1147:    }
      103: 1148:    ret->nopts = 0;
      103: 1149:    ret->ndopts = 0;
      103: 1150:    ret->nodopts = 0;
      103: 1151:    ret->lastt = time(0);
      103: 1152:    ret->set = NULL;
      103: 1153:    if (single) {
       14: 1154:	ret->single = (Caopt *) zalloc(256 * sizeof(Caopt));
       14: 1155:	memset(ret->single, 0, 256 * sizeof(Caopt));
        -: 1156:    } else
       89: 1157:	ret->single = NULL;
      103: 1158:    ret->match = ztrdup(match);
      103: 1159:    ret->flags = flags;
        -: 1160:
      103: 1161:    return ret;
        -: 1162:}
        -: 1163:
        -: 1164:static void
      103: 1165:set_cadef_opts(Cadef def)
        -: 1166:{
        -: 1167:    Caarg argp;
        -: 1168:    int xnum;
        -: 1169:
      147: 1170:    for (argp = def->args, xnum = 0; argp; argp = argp->next) {
       44: 1171:	if (!argp->direct)
       37: 1172:	    argp->min = argp->num - xnum;
       44: 1173:	if (argp->type == CAA_OPT)
        2: 1174:	    xnum++;
        -: 1175:    }
      103: 1176:}
        -: 1177:
        -: 1178:/* Parse an array of definitions. */
        -: 1179:
        -: 1180:static Cadef
       85: 1181:parse_cadef(char *nam, char **args)
        -: 1182:{
        -: 1183:    Cadef all, ret;
        -: 1184:    Caopt *optp;
       85: 1185:    char **orig_args = args, *p, *q, *match = "r:|[_-]=* r:|=*", **xor, **sargs;
       85: 1186:    char *adpre, *adsuf, *axor = NULL, *doset = NULL, **pendset = NULL, **curset = NULL;
       85: 1187:    char *nonarg = NULL;
       85: 1188:    int single = 0, anum = 1, xnum, flags = 0;
       85: 1189:    int foreignset = 0, not = 0;
        -: 1190:
        -: 1191:    /* First string is the auto-description definition. */
        -: 1192:
       85: 1193:    for (p = args[0]; *p && (p[0] != '%' || p[1] != 'd'); p++);
        -: 1194:
       85: 1195:    if (*p) {
    #####: 1196:	*p = '\0';
    #####: 1197:	adpre = dupstring(args[0]);
    #####: 1198:	*p = '%';
    #####: 1199:	adsuf = dupstring(p + 2);
        -: 1200:    } else
       85: 1201:	adpre = adsuf = NULL;
        -: 1202:
        -: 1203:    /* Now get the -s, -A, -S and -M options. */
        -: 1204:
       85: 1205:    args++;
      191: 1206:    while ((p = *args) && *p == '-' && p[1]) {
       34: 1207:	for (q = ++p; *q; q++)
       21: 1208:	    if (*q == 'M' || *q == 'A') {
        8: 1209:		q = "";
        8: 1210:		break;
       13: 1211:	    } else if (*q != 's' && *q != 'S')
    #####: 1212:		break;
        -: 1213:
       21: 1214:	if (*q)
    #####: 1215:	    break;
        -: 1216:
       42: 1217:	for (; *p; p++) {
       21: 1218:	    if (*p == 's')
       12: 1219:		single = 1;
        9: 1220:	    else if (*p == 'S')
        1: 1221:		flags |= CDF_SEP;
        8: 1222:	    else if (*p == 'A') {
        6: 1223:		if (p[1]) {
        1: 1224:		    nonarg = p + 1;
        1: 1225:		    p += strlen(p+1);
        5: 1226:		} else if (args[1])
        5: 1227:		    nonarg = *++args;
        -: 1228:		else
    #####: 1229:		    break;
        2: 1230:	    } else if (*p == 'M') {
        2: 1231:		if (p[1]) {
    #####: 1232:		    match = p + 1;
    #####: 1233:		    p += strlen(p+1);
        2: 1234:		} else if (args[1])
        2: 1235:		    match = *++args;
        -: 1236:		else
    #####: 1237:		    break;
        -: 1238:	    }
        -: 1239:	}
       21: 1240:	if (*p)
    #####: 1241:	    break;
        -: 1242:
       21: 1243:	args++;
        -: 1244:    }
       85: 1245:    if (*args && !strcmp(*args, ":"))
       85: 1246:        args++;
       85: 1247:    if (!*args)
    #####: 1248:	return NULL;
        -: 1249:
       85: 1250:    if (nonarg)
        6: 1251:	tokenize(nonarg = dupstring(nonarg));
        -: 1252:    /* Looks good. Optimistically allocate the cadef structure. */
        -: 1253:
       85: 1254:    all = ret = alloc_cadef(orig_args, single, match, nonarg, flags);
       85: 1255:    optp = &(ret->opts);
       85: 1256:    sargs = args;
        -: 1257:
        -: 1258:    /* Get the definitions. */
        -: 1259:
      541: 1260:    for (; *args || pendset; args++) {
      456: 1261:	if (!*args) {
        -: 1262:	    /* start new set */
       18: 1263:	    args = sargs; /* go back and repeat parse of common options */
       18: 1264:	    doset = NULL;
       18: 1265:	    set_cadef_opts(ret);
       18: 1266:	    ret = ret->snext = alloc_cadef(NULL, single, match, nonarg, flags);
       18: 1267:	    optp = &(ret->opts);
       18: 1268:	    anum = 1;
       18: 1269:	    foreignset = 0;
       18: 1270:	    curset = pendset;
       18: 1271:	    pendset = 0;
        -: 1272:        }
      456: 1273:        if (args[0][0] == '-' && !args[0][1] && args[1]) {
       80: 1274:	    if ((foreignset = curset && args != curset)) {
       44: 1275:		if (!pendset && args > curset)
       18: 1276:		    pendset = args; /* mark pointer to next pending set */
       44: 1277:		++args;
        -: 1278:	    } else {
        -: 1279:		/* Carrying on: this is the current set */
       36: 1280:		char *p = *++args;
       36: 1281:		int l = strlen(p) - 1;
        -: 1282:
       36: 1283:		if (*p == '(' && p[l] == ')') {
        5: 1284:		    axor = p = dupstring(p + 1);
        5: 1285:		    p[l - 1] = '\0';
        -: 1286:		} else
       31: 1287:		    axor = NULL;
       36: 1288:		if (!*p) {
    #####: 1289:		    freecadef(all);
    #####: 1290:		    zwarnnam(nam, "empty set name");
    #####: 1291:		    return NULL;
        -: 1292:		}
       36: 1293:		ret->set = doset = tricat(p, "-", "");
       36: 1294:		curset = args; /* needed for the first set */
        -: 1295:	    }
       80: 1296:	    continue;
      376: 1297:	} else if (args[0][0] == '+' && !args[0][1] && args[1]) {
        -: 1298:	    char *p;
        -: 1299:	    int l;
        -: 1300:
       20: 1301:	    foreignset = 0; /* group not in any set, don't want to skip it */
       20: 1302:	    p = *++args;
       20: 1303:	    l = strlen(p) - 1;
       20: 1304:	    if (*p == '(' && p[l] == ')') {
        3: 1305:		axor = p = dupstring(p + 1);
        3: 1306:		p[l - 1] = '\0';
        -: 1307:	    } else
       17: 1308:		axor = NULL;
       20: 1309:	    if (!*p) {
    #####: 1310:		freecadef(all);
    #####: 1311:		zwarnnam(nam, "empty group name");
    #####: 1312:		return NULL;
        -: 1313:	    }
       20: 1314:	    doset = tricat(p, "-", "");
       20: 1315:	    continue;
      356: 1316:	} else if (foreignset) /* skipping over a different set */
       79: 1317:	    continue;
      277: 1318:	p = dupstring(*args);
      277: 1319:	xnum = 0;
      277: 1320:	if ((not = (*p == '!')))
        3: 1321:	    p++;
      277: 1322:	if (*p == '(') {
        -: 1323:	    /* There is a xor list, get it. */
        -: 1324:
       38: 1325:	    LinkList list = newlinklist();
        -: 1326:	    LinkNode node;
        -: 1327:	    char **xp, sav;
        -: 1328:
      136: 1329:	    while (*p && *p != ')') {
       62: 1330:		for (p++; inblank(*p); p++);
        -: 1331:
       62: 1332:		if (*p == ')')
        2: 1333:		    break;
       60: 1334:		for (q = p++; *p && *p != ')' && !inblank(*p); p++);
        -: 1335:
       60: 1336:		if (!*p)
    #####: 1337:		    break;
        -: 1338:
       60: 1339:		sav = *p;
       60: 1340:		*p = '\0';
       60: 1341:		addlinknode(list, dupstring(q));
       60: 1342:		xnum++;
       60: 1343:		*p = sav;
        -: 1344:	    }
        -: 1345:	    /* Oops, end-of-string. */
       38: 1346:	    if (*p != ')') {
    #####: 1347:		freecadef(all);
    #####: 1348:		zwarnnam(nam, "invalid argument: %s", *args);
    #####: 1349:		return NULL;
        -: 1350:	    }
       38: 1351:	    if (doset && axor)
        2: 1352:		xnum++;
       38: 1353:	    xor = (char **) zalloc((xnum + 2) * sizeof(char *));
       98: 1354:	    for (node = firstnode(list), xp = xor; node; incnode(node), xp++)
       60: 1355:		*xp = ztrdup((char *) getdata(node));
       38: 1356:	    if (doset && axor)
        2: 1357:		*xp++ = ztrdup(axor);
       38: 1358:	    xp[0] = xp[1] = NULL;
        -: 1359:
       38: 1360:	    p++;
      239: 1361:	} else if (doset && axor) {
       16: 1362:	    xnum = 1;
       16: 1363:	    xor = (char **) zalloc(3 * sizeof(char *));
       16: 1364:	    xor[0] = ztrdup(axor);
       16: 1365:	    xor[1] = xor[2] = NULL;
        -: 1366:	} else
      223: 1367:	    xor = NULL;
        -: 1368:
      349: 1369:	if (*p == '-' || *p == '+' ||
      315: 1370:	    (*p == '*' && (p[1] == '-' || p[1] == '+'))) {
        -: 1371:	    /* It's an option. */
        -: 1372:	    Caopt opt;
      215: 1373:	    Caarg oargs = NULL;
      215: 1374:	    int multi, otype = CAO_NEXT, again = 0;
      215: 1375:	    char *name, *descr, c, *againp = NULL;
        -: 1376:
      217: 1377:	    rec:
        -: 1378:
        -: 1379:	    /* Allowed more than once? */
      217: 1380:	    if ((multi = (*p == '*')))
       10: 1381:		p++;
        -: 1382:
      432: 1383:	    if (((p[0] == '-' && p[1] == '+') ||
      228: 1384:		 (p[0] == '+' && p[1] == '-')) &&
       12: 1385:		p[2] && p[2] != ':' && p[2] != '[' &&
        8: 1386:		p[2] != '=' && p[2] != '-' && p[2] != '+') {
        -: 1387:		/* It's a -+ or +- definition. We just execute the whole
        -: 1388:		 * stuff twice for such things. */
        4: 1389:		againp = dupstring(p);
        4: 1390:		name = ++p;
        4: 1391:		*p = (again ? '-' : '+');
        4: 1392:		again++;
        -: 1393:	    } else {
      213: 1394:		name = p;
        -: 1395:		/* If it's a long option skip over the first `-'. */
      213: 1396:		if (p[0] == '-' && p[1] == '-')
       14: 1397:		    p++;
        -: 1398:	    }
      217: 1399:	    if (!p[1]) {
    #####: 1400:		freecadef(all);
    #####: 1401:		zwarnnam(nam, "invalid argument: %s", *args);
    #####: 1402:		return NULL;
        -: 1403:	    }
        -: 1404:
        -: 1405:	    /* Skip over the name. */
      989: 1406:	    for (p++; *p && *p != ':' && *p != '[' &&
      573: 1407:		     ((*p != '-' && *p != '+') ||
      284: 1408:		      (p[1] != ':' && p[1] != '[')) &&
      285: 1409:		     (*p != '=' ||
      279: 1410:		      (p[1] != ':' && p[1] != '[' && p[1] != '-')); p++)
      271: 1411:		if (*p == '\\' && p[1])
        1: 1412:		    p++;
        -: 1413:
        -: 1414:	    /* The character after the option name specifies the type. */
      217: 1415:	    c = *p;
      217: 1416:	    *p = '\0';
      217: 1417:	    if (c == '-') {
        1: 1418:		otype = CAO_DIRECT;
        1: 1419:		c = *++p;
      216: 1420:	    } else if (c == '+') {
        5: 1421:		otype = CAO_ODIRECT;
        5: 1422:		c = *++p;
      211: 1423:	    } else if (c == '=') {
        7: 1424:		otype = CAO_OEQUAL;
        7: 1425:		if ((c = *++p) == '-') {
        1: 1426:		    otype = CAO_EQUAL;
        1: 1427:		    c = *++p;
        -: 1428:		}
        -: 1429:	    }
        -: 1430:	    /* Get the optional description, if any. */
      217: 1431:	    if (c == '[') {
        9: 1432:		for (descr = ++p; *p && *p != ']'; p++)
        7: 1433:		    if (*p == '\\' && p[1])
    #####: 1434:			p++;
        -: 1435:
        2: 1436:		if (!*p) {
    #####: 1437:		    freecadef(all);
    #####: 1438:		    zwarnnam(nam, "invalid option definition: %s", *args);
    #####: 1439:		    return NULL;
        -: 1440:		}
        2: 1441:		*p++ = '\0';
        2: 1442:		c = *p;
        -: 1443:	    } else
      215: 1444:		descr = NULL;
        -: 1445:
      217: 1446:	    if (c && c != ':') {
    #####: 1447:		freecadef(all);
    #####: 1448:		zwarnnam(nam, "invalid option definition: %s", *args);
    #####: 1449:		return NULL;
        -: 1450:	    }
        -: 1451:	    /* Add the option name to the xor list if not `*-...'. */
      217: 1452:	    if (!multi) {
      207: 1453:		if (!xor) {
      155: 1454:		    xor = (char **) zalloc(2 * sizeof(char *));
      155: 1455:		    xor[0] = xor[1] = NULL;
        -: 1456:		}
      207: 1457:                zsfree(xor[xnum]);
      207: 1458:		xor[xnum] = ztrdup(rembslashcolon(name));
        -: 1459:	    }
      217: 1460:	    if (c == ':') {
        -: 1461:		/* There's at least one argument. */
        -: 1462:
       27: 1463:		Caarg *oargp = &oargs;
       27: 1464:		int atype, rest, oanum = 1, onum = 0;
        -: 1465:		char *end;
        -: 1466:
        -: 1467:		/* Loop over the arguments. */
        -: 1468:
       82: 1469:		while (c == ':') {
       30: 1470:		    rest = 0;
       30: 1471:		    end = NULL;
        -: 1472:
        -: 1473:		    /* Get the argument type. */
       30: 1474:		    if (*++p == ':') {
        2: 1475:			atype = CAA_OPT;
        2: 1476:			p++;
       28: 1477:		    } else if (*p == '*') {
        2: 1478:			if (*++p != ':') {
        -: 1479:			    char sav;
        -: 1480:
        5: 1481:			    for (end = p++; *p && *p != ':'; p++)
        3: 1482:				if (*p == '\\' && p[1])
    #####: 1483:				    p++;
        2: 1484:			    sav = *p;
        2: 1485:			    *p = '\0';
        2: 1486:			    end = dupstring(end);
        2: 1487:			    tokenize(end);
        2: 1488:			    *p = sav;
        -: 1489:			}
        2: 1490:			if (*p != ':') {
    #####: 1491:			    freecadef(all);
    #####: 1492:			    freecaargs(oargs);
    #####: 1493:			    zwarnnam(nam, "invalid option definition: %s",
        -: 1494:				    *args);
    #####: 1495:			    return NULL;
        -: 1496:			}
        2: 1497:			if (*++p == ':') {
        1: 1498:			    if (*++p == ':') {
        1: 1499:				atype = CAA_RREST;
        1: 1500:				p++;
        -: 1501:			    } else
    #####: 1502:				atype = CAA_RARGS;
        -: 1503:			} else
        1: 1504:			    atype = CAA_REST;
        2: 1505:			rest = 1;
        -: 1506:		    } else
       26: 1507:			atype = CAA_NORMAL;
        -: 1508:
        -: 1509:		    /* And the definition. */
        -: 1510:
       30: 1511:		    *oargp = parse_caarg(!rest, atype, oanum++, onum,
        -: 1512:					 name, &p, doset);
       30: 1513:		    if (atype == CAA_OPT)
        2: 1514:			onum++;
       30: 1515:		    if (end)
        2: 1516:			(*oargp)->end = ztrdup(end);
       30: 1517:		    oargp = &((*oargp)->next);
       30: 1518:		    if (rest)
        2: 1519:			break;
       28: 1520:		    c = *p;
        -: 1521:		}
        -: 1522:	    }
        -: 1523:	    /* Store the option definition. */
        -: 1524:
      217: 1525:	    *optp = opt = (Caopt) zalloc(sizeof(*opt));
      217: 1526:	    optp = &((*optp)->next);
        -: 1527:
      217: 1528:	    opt->next = NULL;
      217: 1529:	    opt->gsname = doset;
      217: 1530:	    opt->name = ztrdup(rembslashcolon(name));
      217: 1531:	    if (descr)
        2: 1532:		opt->descr = ztrdup(descr);
      215: 1533:	    else if (adpre && oargs && !oargs->next) {
        -: 1534:		char *d;
        -: 1535:
    #####: 1536:		for (d = oargs->descr; *d; d++)
    #####: 1537:		    if (!iblank(*d))
    #####: 1538:			break;
        -: 1539:
    #####: 1540:		if (*d)
    #####: 1541:		    opt->descr = tricat(adpre, oargs->descr, adsuf);
        -: 1542:		else
    #####: 1543:		    opt->descr = NULL;
        -: 1544:	    } else
      215: 1545:		opt->descr = NULL;
      217: 1546:	    opt->xor = (again == 1 && xor ? zarrdup(xor) : xor);
      217: 1547:	    opt->type = otype;
      217: 1548:	    opt->args = oargs;
      217: 1549:	    opt->num = ret->nopts++;
      217: 1550:	    opt->not = not;
        -: 1551:
      217: 1552:	    if (otype == CAO_DIRECT || otype == CAO_EQUAL)
        2: 1553:		ret->ndopts++;
      215: 1554:	    else if (otype == CAO_ODIRECT || otype == CAO_OEQUAL)
       11: 1555:		ret->nodopts++;
        -: 1556:
        -: 1557:	    /* If this is for single-letter option we also store a
        -: 1558:	     * pointer for the definition in the array for fast lookup.
        -: 1559:	     * But don't treat '--' as a single option called '-' */
        -: 1560:
        -: 1561:
      217: 1562:	    if (single && name[1] && !name[2] && name[1] != '-')
       42: 1563:		ret->single[STOUC(name[1])] = opt;
        -: 1564:
      217: 1565:	    if (again == 1) {
        -: 1566:		/* Do it all again for `*-...'. */
        2: 1567:		p = againp;
        2: 1568:		goto rec;
        -: 1569:	    }
       62: 1570:	} else if (*p == '*') {
        -: 1571:	    /* It's a rest-argument definition. */
        -: 1572:
       18: 1573:	    int type = CAA_REST;
        -: 1574:
       18: 1575:	    if (not)
    #####: 1576:		continue;
        -: 1577:
       18: 1578:	    if (*++p != ':') {
    #####: 1579:		freecadef(all);
    #####: 1580:		zwarnnam(nam, "invalid rest argument definition: %s", *args);
    #####: 1581:		return NULL;
        -: 1582:	    }
       18: 1583:	    if (ret->rest) {
    #####: 1584:		freecadef(all);
    #####: 1585:		zwarnnam(nam, "doubled rest argument definition: %s", *args);
    #####: 1586:		return NULL;
        -: 1587:	    }
       18: 1588:	    if (*++p == ':') {
        6: 1589:		if (*++p == ':') {
        3: 1590:		    type = CAA_RREST;
        3: 1591:		    p++;
        -: 1592:		} else
        3: 1593:		    type = CAA_RARGS;
        -: 1594:	    }
       18: 1595:	    ret->rest = parse_caarg(0, type, -1, 0, NULL, &p, doset);
       18: 1596:	    ret->rest->xor = xor;
        -: 1597:	} else {
        -: 1598:	    /* It's a normal argument definition. */
        -: 1599:
       44: 1600:	    int type = CAA_NORMAL, direct;
        -: 1601:	    Caarg arg, tmp, pre;
        -: 1602:
       44: 1603:	    if (not)
    #####: 1604:		continue;
        -: 1605:
       44: 1606:	    if ((direct = idigit(*p))) {
        -: 1607:		/* Argument number is given. */
        7: 1608:		int num = 0;
        -: 1609:
       21: 1610:		while (*p && idigit(*p))
        7: 1611:		    num = (num * 10) + (((int) *p++) - '0');
        -: 1612:
        7: 1613:		anum = num + 1;
        -: 1614:	    } else
        -: 1615:		/* Default number. */
       37: 1616:		anum++;
        -: 1617:
       44: 1618:	    if (*p != ':') {
    #####: 1619:		freecadef(all);
    #####: 1620:		zwarnnam(nam, "invalid argument: %s", *args);
    #####: 1621:		if (xor)
    #####: 1622:		    free(xor);
    #####: 1623:		return NULL;
        -: 1624:	    }
       44: 1625:	    if (*++p == ':') {
        -: 1626:		/* Optional argument. */
        2: 1627:		type = CAA_OPT;
        2: 1628:		p++;
        -: 1629:	    }
       44: 1630:	    arg = parse_caarg(0, type, anum - 1, 0, NULL, &p, doset);
       44: 1631:	    arg->xor = xor;
       44: 1632:	    arg->direct = direct;
        -: 1633:
        -: 1634:	    /* Sort the new definition into the existing list. */
        -: 1635:
       94: 1636:	    for (tmp = ret->args, pre = NULL;
        6: 1637:		 tmp && tmp->num < anum - 1;
        6: 1638:		 pre = tmp, tmp = tmp->next);
        -: 1639:
       44: 1640:	    if (tmp && tmp->num == anum - 1) {
    #####: 1641:		freecadef(all);
    #####: 1642:		freecaargs(arg);
    #####: 1643:		zwarnnam(nam, "doubled argument definition: %s", *args);
    #####: 1644:		return NULL;
        -: 1645:	    }
       44: 1646:	    arg->next = tmp;
       44: 1647:	    if (pre)
        5: 1648:		pre->next = arg;
        -: 1649:	    else
       39: 1650:		ret->args = arg;
        -: 1651:	}
        -: 1652:    }
       85: 1653:    set_cadef_opts(ret);
        -: 1654:
       85: 1655:    return all;
        -: 1656:}
        -: 1657:
        -: 1658:/* Given an array of definitions, return the cadef for it. From the cache
        -: 1659: * are newly built. */
        -: 1660:
        -: 1661:static Cadef
      167: 1662:get_cadef(char *nam, char **args)
        -: 1663:{
        -: 1664:    Cadef *p, *min, new;
      167: 1665:    int i, na = arrlen(args);
        -: 1666:
      869: 1667:    for (i = MAX_CACACHE, p = cadef_cache, min = NULL; i && *p; p++, i--)
      784: 1668:	if (*p && na == (*p)->ndefs && arrcmp(args, (*p)->defs)) {
       82: 1669:	    (*p)->lastt = time(0);
        -: 1670:
       82: 1671:	    return *p;
      702: 1672:	} else if (!min || !*p || (*p)->lastt < (*min)->lastt)
      115: 1673:	    min = p;
       85: 1674:    if (i > 0)
        8: 1675:	min = p;
       85: 1676:    if ((new = parse_cadef(nam, args))) {
       85: 1677:	freecadef(*min);
       85: 1678:	*min = new;
        -: 1679:    }
       85: 1680:    return new;
        -: 1681:}
        -: 1682:
        -: 1683:/*
        -: 1684: * Get the option used in a word from the line, if any.
        -: 1685: *
        -: 1686: * "d" is a complete set of argument/option definitions to scan.
        -: 1687: * "line" is the word we are scanning.
        -: 1688: * "full" indicates that the option must match a full word; otherwise
        -: 1689: *   we look for "=" arguments or prefixes.
        -: 1690: * *"end" is set to point to the end of the option, in some cases
        -: 1691: *   leaving an option argument after it.
        -: 1692: */
        -: 1693:
        -: 1694:static Caopt
      339: 1695:ca_get_opt(Cadef d, char *line, int full, char **end)
        -: 1696:{
        -: 1697:    Caopt p;
        -: 1698:
        -: 1699:    /* The full string may be an option. */
        -: 1700:
      710: 1701:    for (p = d->opts; p; p = p->next)
      580: 1702:	if (p->active && !strcmp(p->name, line)) {
      209: 1703:	    if (end)
      106: 1704:		*end = line + strlen(line);
        -: 1705:
      209: 1706:	    return p;
        -: 1707:	}
        -: 1708:
      130: 1709:    if (!full) {
        -: 1710:	/* The string from the line probably only begins with an option. */
      229: 1711:	for (p = d->opts; p; p = p->next)
      279: 1712:	    if (p->active && ((!p->args || p->type == CAO_NEXT) ?
      129: 1713:			      !strcmp(p->name, line) : strpfx(p->name, line))) {
       20: 1714:		int l = strlen(p->name);
       32: 1715:		if ((p->type == CAO_OEQUAL || p->type == CAO_EQUAL) &&
       24: 1716:		    line[l] && line[l] != '=')
        2: 1717:		    continue;
        -: 1718:
       18: 1719:		if (end) {
        -: 1720:		    /* Return a pointer to the end of the option. */
       28: 1721:		    if ((p->type == CAO_OEQUAL || p->type == CAO_EQUAL) &&
       10: 1722:			line[l] == '=')
       10: 1723:			l++;
        -: 1724:
       18: 1725:		    *end = line + l;
        -: 1726:		}
       18: 1727:		return p;
        -: 1728:	    }
        -: 1729:    }
      112: 1730:    return NULL;
        -: 1731:}
        -: 1732:
        -: 1733:/* Same as above, only for single-letter-style. */
        -: 1734:
        -: 1735:static Caopt
       13: 1736:ca_get_sopt(Cadef d, char *line, char **end, LinkList *lp)
        -: 1737:{
       13: 1738:    Caopt p, pp = NULL;
       13: 1739:    char pre = *line++;
       13: 1740:    LinkList l = NULL;
        -: 1741:
       13: 1742:    *lp = NULL;
       28: 1743:    for (p = NULL; *line; line++) {
       38: 1744:	if ((p = d->single[STOUC(*line)]) && p->active &&
       27: 1745:	    p->args && p->name[0] == pre) {
        3: 1746:	    if (p->type == CAO_NEXT) {
    #####: 1747:		if (!l)
    #####: 1748:		    *lp = l = newlinklist();
    #####: 1749:		addlinknode(l, p);
        -: 1750:	    } else {
        3: 1751:		if (end) {
        3: 1752:		    line++;
        6: 1753:		    if ((p->type == CAO_OEQUAL || p->type == CAO_EQUAL) &&
        3: 1754:			*line == '=')
    #####: 1755:			line++;
        3: 1756:		    *end = line;
        -: 1757:		}
        3: 1758:		pp = p;
        3: 1759:		break;
        -: 1760:	    }
       17: 1761:	} else if (!p || (p && !p->active))
        2: 1762:	    return NULL;
       15: 1763:	pp = (p->name[0] == pre ? p : NULL);
       15: 1764:	p = NULL;
        -: 1765:    }
       11: 1766:    if (pp && end)
        7: 1767:	*end = line;
       11: 1768:    return pp;
        -: 1769:}
        -: 1770:
        -: 1771:/* Search for an option in all sets except the current one.
        -: 1772: * Return true if found */
        -: 1773:
        -: 1774:static int
       15: 1775:ca_foreign_opt(Cadef curset, Cadef all, char *option)
        -: 1776:{
        -: 1777:    Cadef d;
        -: 1778:    Caopt p;
        -: 1779:
       25: 1780:    for (d = all; d; d = d->snext) {
       24: 1781:	if (d == curset)
        8: 1782:	    continue;
        -: 1783:
       31: 1784:	for (p = d->opts; p; p = p->next) {
       29: 1785:	    if (!strcmp(p->name, option))
       14: 1786:		return 1;
        -: 1787:	}
        -: 1788:    }
        1: 1789:    return 0;
        -: 1790:}
        -: 1791:
        -: 1792:/* Return the n'th argument definition. */
        -: 1793:
        -: 1794:static Caarg
      170: 1795:ca_get_arg(Cadef d, int n)
        -: 1796:{
      170: 1797:    if (d->argsactive) {
      170: 1798:	Caarg a = d->args;
        -: 1799:
      379: 1800:	while (a && (!a->active || n < a->min || n > a->num)) {
       39: 1801:            if (!a->active)
        7: 1802:                n++;
       39: 1803:	    a = a->next;
        -: 1804:        }
      170: 1805:	if (a && a->min <= n && a->num >= n && a->active)
       72: 1806:	    return a;
        -: 1807:
       98: 1808:	return (d->rest && d->rest->active ? d->rest : NULL);
        -: 1809:    }
    #####: 1810:    return NULL;
        -: 1811:}
        -: 1812:
        -: 1813:/* Mark options as inactive.
        -: 1814: *   d: option definitions for a set
        -: 1815: *   pass either:
        -: 1816: *     xor: a list if exclusions
        -: 1817: *     opts: if set, all options excluded leaving only nornal/rest arguments */
        -: 1818:
        -: 1819:static void
      498: 1820:ca_inactive(Cadef d, char **xor, int cur, int opts)
        -: 1821:{
      498: 1822:    if ((xor || opts) && cur <= compcurrent) {
        -: 1823:	Caopt opt;
        -: 1824:	char *x;
        -: 1825:        /* current word could be a prefix of a longer one so only do
        -: 1826:	 * exclusions for single-letter options (for option clumping) */
      100: 1827:	int single = !opts && (cur == compcurrent);
        -: 1828:
      257: 1829:	for (; (x = (opts ? "-" : *xor)); xor++) {
      162: 1830:	    int excludeall = 0;
      162: 1831:	    char *grp = NULL;
        -: 1832:	    size_t grplen;
      162: 1833:	    char *next, *sep = x;
        -: 1834:
      353: 1835:	    while (*sep != '+' && *sep != '-' && *sep != ':' && *sep != '*' && !idigit(*sep)) {
       52: 1836:		if (!(next = strchr(sep, '-')) || !*++next) {
        -: 1837:		    /* exclusion is just the name of a set or group */
       23: 1838:		    excludeall = 1; /* excluding options and args */
       23: 1839:		    sep += strlen(sep);
        -: 1840:		    /* A trailing '-' is included in the various gsname fields but is not
        -: 1841:		     * there for this branch. This is why we add excludeall to grplen
        -: 1842:		     * when checking for the null in a few places below */
       23: 1843:		    break;
        -: 1844:		}
       29: 1845:		sep = next;
        -: 1846:	    }
      162: 1847:	    if (sep > x) { /* exclusion included a set or group name */
       46: 1848:		grp = x;
       46: 1849:		grplen = sep - grp;
       46: 1850:		x = sep;
        -: 1851:	    }
        -: 1852:
      162: 1853:	    if (excludeall || (x[0] == ':' && !x[1])) {
       27: 1854:		if (grp) {
        -: 1855:		    Caarg a;
        -: 1856:
       36: 1857:		    for (a = d->args; a; a = a->next)
       14: 1858:			if (a->gsname && !strncmp(a->gsname, grp, grplen) &&
        5: 1859:				!a->gsname[grplen + excludeall])
        5: 1860:			    a->active = 0;
       30: 1861:		    if (d->rest && d->rest->gsname &&
        4: 1862:			    !strncmp(d->rest->gsname, grp, grplen) &&
        1: 1863:			    !d->rest->gsname[grplen + excludeall])
        1: 1864:			d->rest->active = 0;
        -: 1865:		} else
    #####: 1866:		    d->argsactive = 0;
        -: 1867:	    }
        -: 1868:
      162: 1869:	    if (excludeall || (x[0] == '-' && !x[1])) {
        -: 1870:		Caopt p;
        -: 1871:
      157: 1872:		for (p = d->opts; p; p = p->next)
      160: 1873:		    if ((!grp || (p->gsname && !strncmp(p->gsname, grp, grplen) &&
       89: 1874:			    !p->gsname[grplen + excludeall])) &&
       12: 1875:			    !(single && *p->name && p->name[1] && p->name[2]))
       50: 1876:			p->active = 0;
        -: 1877:	    }
        -: 1878:
      162: 1879:	    if (excludeall || (x[0] == '*' && !x[1])) {
       32: 1880:		if (d->rest && (!grp || (d->rest->gsname &&
        7: 1881:			!strncmp(d->rest->gsname, grp, grplen) &&
        3: 1882:			!d->rest->gsname[grplen + excludeall])))
        3: 1883:		    d->rest->active = 0;
        -: 1884:            }
        -: 1885:
      162: 1886:	    if (!excludeall) {
      139: 1887:		if (idigit(x[0])) {
        5: 1888:		    int n = atoi(x);
        5: 1889:		    Caarg a = d->args;
        -: 1890:
       11: 1891:		    while (a && a->num < n)
        1: 1892:			a = a->next;
        -: 1893:
        9: 1894:		    if (a && a->num == n && (!grp || (a->gsname &&
        4: 1895:			    !strncmp(a->gsname, grp, grplen))))
        2: 1896:			a->active = 0;
      134: 1897:		} else if ((opt = ca_get_opt(d, x, 1, NULL)) &&
        3: 1898:			(!grp || (opt->gsname && !strncmp(opt->gsname, grp, grplen))) &&
       19: 1899:			!(single && *opt->name && opt->name[1] && opt->name[2]))
       97: 1900:		    opt->active = 0;
      139: 1901:		if (opts)
        5: 1902:		    break;
        -: 1903:	    }
        -: 1904:	}
        -: 1905:    }
      498: 1906:}
        -: 1907:
        -: 1908:/* State when parsing a command line. */
        -: 1909:
        -: 1910:typedef struct castate *Castate;
        -: 1911:
        -: 1912:/* Encapsulates details from parsing the current line against a particular set,
        -: 1913: * Covers positions of options and normal arguments. Used as a linked list
        -: 1914: * with one state for each set. */
        -: 1915:
        -: 1916:struct castate {
        -: 1917:    Castate snext;	/* state for next set */
        -: 1918:    Cadef d;		/* parsed _arguments specs for the set */
        -: 1919:    int nopts;		/* number of specified options (size of oargs) */
        -: 1920:    Caarg def;		/* definition for the current set */
        -: 1921:    Caarg ddef;
        -: 1922:    Caopt curopt;	/* option description corresponding to option found on the command-line */
        -: 1923:    Caopt dopt;
        -: 1924:    int opt;		/* the length of the option up to a maximum of 2 */
        -: 1925:    int arg;		/* completing arguments to an option or rest args */
        -: 1926:    int argbeg;         /* position of first rest argument (+1) */
        -: 1927:    int optbeg;		/* first word after the last option to the left of the cursor:
        -: 1928:			 * in effect the start of any arguments to the current option */
        -: 1929:    int nargbeg;	/* same as optbeg but used during parse */
        -: 1930:    int restbeg;	/* same as argbeg but used during parse */
        -: 1931:    int curpos;		/* current word position */
        -: 1932:    int argend;         /* total number of words */
        -: 1933:    int inopt;		/* set to current word pos if word is a recognised option */
        -: 1934:    int inarg;          /* in a normal argument */
        -: 1935:    int nth;		/* number of current normal arg */
        -: 1936:    int singles;	/* argument consists of clumped options */
        -: 1937:    int oopt;
        -: 1938:    int actopts;	/* count of active options */
        -: 1939:    LinkList args;	/* list of non-option args used for populating $line */
        -: 1940:    LinkList *oargs;	/* list of lists used for populating $opt_args */
        -: 1941:};
        -: 1942:
        -: 1943:static struct castate ca_laststate;
        -: 1944:static int ca_parsed = 0, ca_alloced = 0;
        -: 1945:static int ca_doff; /* no. of chars of ignored prefix (for clumped options or arg to an option) */
        -: 1946:
        -: 1947:static void
      185: 1948:freecastate(Castate s)
        -: 1949:{
        -: 1950:    int i;
        -: 1951:    LinkList *p;
        -: 1952:
      185: 1953:    freelinklist(s->args, freestr);
      536: 1954:    for (i = s->nopts, p = s->oargs; i--; p++)
      351: 1955:	if (*p)
      119: 1956:	    freelinklist(*p, freestr);
      185: 1957:    zfree(s->oargs, s->d->nopts * sizeof(LinkList));
      185: 1958:}
        -: 1959:
        -: 1960:/* Return a copy of an option's argument, ignoring possible quoting
        -: 1961: * in the option name. */
        -: 1962:
        -: 1963:static char *
       23: 1964:ca_opt_arg(Caopt opt, char *line)
        -: 1965:{
       23: 1966:    char *o = opt->name;
        -: 1967:
        -: 1968:    while (1) {
      149: 1969:        if (*o == '\\')
    #####: 1970:            o++;
       86: 1971:        if (*line == '\\' || *line == '\'' || *line == '"')
    #####: 1972:            line++;
       86: 1973:        if (!*o || *o != *line)
        -: 1974:            break;
       63: 1975:        o++;
       63: 1976:        line++;
        -: 1977:    }
       23: 1978:    if (*line && (opt->type == CAO_EQUAL || opt->type == CAO_OEQUAL)) {
       12: 1979:        if (*line == '\\')
    #####: 1980:            line++;
       12: 1981:        if (*line == '=')
       10: 1982:            line++;
        -: 1983:    }
       23: 1984:    return ztrdup(line);
        -: 1985:}
        -: 1986:
        -: 1987:/* Parse the command line for a particular argument set (d).
        -: 1988: * Returns 1 if the set should be skipped because it doesn't match
        -: 1989: * existing options on the line. */
        -: 1990:
        -: 1991:static int
      193: 1992:ca_parse_line(Cadef d, Cadef all, int multi, int first)
        -: 1993:{
        -: 1994:    Caarg adef, ddef;
      193: 1995:    Caopt ptr, wasopt = NULL, dopt;
        -: 1996:    struct castate state;
      193: 1997:    char *line, *oline, *pe, **argxor = NULL;
        -: 1998:    int cur, doff, argend, arglast;
      193: 1999:    Patprog endpat = NULL, napat = NULL;
      193: 2000:    LinkList sopts = NULL;
        -: 2001:#if 0
        -: 2002:    int ne;
        -: 2003:#endif
        -: 2004:
        -: 2005:    /* Free old state. */
        -: 2006:
      193: 2007:    if (first && ca_alloced) {
      166: 2008:	Castate s = &ca_laststate, ss;
        -: 2009:
      512: 2010:	while (s) {
      180: 2011:	    ss = s->snext;
      180: 2012:	    freecastate(s);
      180: 2013:	    s = ss;
        -: 2014:	}
        -: 2015:    }
        -: 2016:    /* Mark everything as active. */
        -: 2017:
      564: 2018:    for (ptr = d->opts; ptr; ptr = ptr->next)
      371: 2019:	ptr->active = 1;
      193: 2020:    d->argsactive = 1;
      193: 2021:    if (d->rest)
       36: 2022:	d->rest->active = 1;
      282: 2023:    for (adef = d->args; adef; adef = adef->next)
       89: 2024:	adef->active = 1;
        -: 2025:
        -: 2026:    /* Default values for the state. */
        -: 2027:
      193: 2028:    state.snext = NULL;
      193: 2029:    state.d = d;
      193: 2030:    state.nopts = d->nopts;
      193: 2031:    state.def = state.ddef = NULL;
      193: 2032:    state.curopt = state.dopt = NULL;
      193: 2033:    state.argbeg = state.optbeg = state.nargbeg = state.restbeg = state.actopts =
      193: 2034:	state.nth = state.inopt = state.inarg = state.opt = state.arg = 1;
      193: 2035:    state.argend = argend = arrlen(compwords) - 1;
      193: 2036:    state.singles = state.oopt = 0;
      193: 2037:    state.curpos = compcurrent;
      193: 2038:    state.args = znewlinklist();
      193: 2039:    state.oargs = (LinkList *) zalloc(d->nopts * sizeof(LinkList));
      193: 2040:    memset(state.oargs, 0, d->nopts * sizeof(LinkList));
        -: 2041:
      193: 2042:    ca_alloced = 1;
        -: 2043:
      193: 2044:    memcpy(&ca_laststate, &state, sizeof(state));
        -: 2045:
      193: 2046:    if (!compwords[1]) {
    #####: 2047:	ca_laststate.opt = ca_laststate.arg = 0;
        -: 2048:
    #####: 2049:	goto end;
        -: 2050:    }
      193: 2051:    if (d->nonarg) /* argument to -A */
       10: 2052:	napat = patcompile(d->nonarg, 0, NULL);
        -: 2053:
        -: 2054:    /* Loop over the words from the line. */
        -: 2055:
      714: 2056:    for (line = compwords[1], cur = 2, state.curopt = NULL, state.def = NULL;
      328: 2057:	 line; line = compwords[cur++]) {
      353: 2058:	ddef = adef = NULL;
      353: 2059:	dopt = NULL;
      353: 2060:	state.singles = arglast = 0;
        -: 2061:
      353: 2062:        oline = line;
        -: 2063:#if 0
        -: 2064:        /*
        -: 2065:	 * remove quotes.
        -: 2066:	 * This is commented out:  it doesn't allow you to discriminate
        -: 2067:	 * between command line values that can be expanded and those
        -: 2068:	 * that can't, and in some cases this generates inconsistency;
        -: 2069:	 * for example, ~/foo\[bar unqotes to ~/foo[bar which doesn't
        -: 2070:	 * work either way---it's wrong if the ~ is quoted, and
        -: 2071:	 * wrong if the [ isn't quoted..  So it's now up to the caller to
        -: 2072:	 * unquote.
        -: 2073:	 */
        -: 2074:        line = dupstring(line);
        -: 2075:        ne = noerrs;
        -: 2076:        noerrs = 2;
        -: 2077:        parse_subst_string(line);
        -: 2078:        noerrs = ne;
        -: 2079:#endif
      353: 2080:        remnulargs(line);
      353: 2081:        untokenize(line);
        -: 2082:
      353: 2083:	ca_inactive(d, argxor, cur - 1, 0);
      353: 2084:	if ((d->flags & CDF_SEP) && cur != compcurrent && !strcmp(line, "--")) {
        2: 2085:	    ca_inactive(d, NULL, cur, 1);
        2: 2086:	    continue;
        -: 2087:	}
        -: 2088:
        -: 2089:	/* We've got a definition for an option/rest argument. For an option,
        -: 2090:	 * this means that we're completing arguments to that option. */
      351: 2091:	if (state.def) {
       38: 2092:	    state.arg = 0;
       38: 2093:	    if (state.curopt)
       38: 2094:		zaddlinknode(state.oargs[state.curopt->num], ztrdup(oline));
        -: 2095:
       38: 2096:	    if ((state.opt = (state.def->type == CAA_OPT)) && state.def->opt)
        2: 2097:		state.oopt++;
        -: 2098:
       71: 2099:	    if (state.def->type == CAA_REST || state.def->type == CAA_RARGS ||
       33: 2100:		state.def->type == CAA_RREST) {
       22: 2101:		if (state.def->end && pattry(endpat, line)) {
        6: 2102:		    state.def = NULL;
        6: 2103:		    state.curopt = NULL;
        6: 2104:		    state.opt = state.arg = 1;
        6: 2105:		    state.argend = ca_laststate.argend = cur - 1;
        6: 2106:		    goto cont;
        -: 2107:		}
       24: 2108:	    } else if ((state.def = state.def->next)) {
        4: 2109:		state.argbeg = cur;
        4: 2110:		state.argend = argend;
       20: 2111:	    } else if (sopts && nonempty(sopts)) {
    #####: 2112:		state.curopt = (Caopt) uremnode(sopts, firstnode(sopts));
    #####: 2113:		state.def = state.curopt->args;
    #####: 2114:		state.opt = 0;
    #####: 2115:		state.argbeg = state.optbeg = state.inopt = cur;
    #####: 2116:		state.argend = argend;
    #####: 2117:		doff = 0;
    #####: 2118:		state.singles = 1;
    #####: 2119:		if (!state.oargs[state.curopt->num])
    #####: 2120:		    state.oargs[state.curopt->num] = znewlinklist();
    #####: 2121:		goto cont;
        -: 2122:	    } else {
       20: 2123:		state.curopt = NULL;
       20: 2124:		state.opt = 1;
        -: 2125:	    }
        -: 2126:	} else {
      313: 2127:	    state.opt = state.arg = 1;
      313: 2128:	    state.curopt = NULL;
        -: 2129:	}
      345: 2130:	if (state.opt)
      333: 2131:	    state.opt = (line[0] ? (line[1] ? 2 : 1) : 0);
        -: 2132:
      345: 2133:	pe = NULL;
        -: 2134:
      345: 2135:	wasopt = NULL;
        -: 2136:
        -: 2137:	/* See if it's an option. */
        -: 2138:
      707: 2139:	if (state.opt == 2 && (state.curopt = ca_get_opt(d, line, 0, &pe)) &&
      124: 2140:	    (state.curopt->type == CAO_OEQUAL ?
       14: 2141:	     (compwords[cur] || pe[-1] == '=') :
      110: 2142:	     (state.curopt->type == CAO_EQUAL ?
        6: 2143:	      (pe[-1] == '=' || !pe[0]) : 1))) {
        -: 2144:
      248: 2145:	    if ((ddef = state.def = ((state.curopt->type != CAO_EQUAL ||
        4: 2146:				      pe[-1] == '=') ?
      242: 2147:				     state.curopt->args : NULL)))
       57: 2148:		dopt = state.curopt;
        -: 2149:
      122: 2150:	    doff = pe - line;
      122: 2151:	    state.optbeg = state.argbeg = state.inopt = cur;
      122: 2152:	    state.argend = argend;
      275: 2153:	    state.singles = (d->single && (!pe || !*pe) &&
      161: 2154:			     state.curopt->name[1] && !state.curopt->name[2] &&
        -: 2155:			     /* Don't treat '--' as a single option called '-' */
       11: 2156:			     state.curopt->name[1] != '-');
        -: 2157:
      122: 2158:	    if (!state.oargs[state.curopt->num])
      111: 2159:		state.oargs[state.curopt->num] = znewlinklist();
        -: 2160:
      122: 2161:	    ca_inactive(d, state.curopt->xor, cur, 0);
        -: 2162:
        -: 2163:	    /* Collect the argument strings. Maybe. */
        -: 2164:
      179: 2165:	    if (state.def &&
      108: 2166:		(state.curopt->type == CAO_DIRECT ||
      100: 2167:		 state.curopt->type == CAO_EQUAL ||
      106: 2168:		 (state.curopt->type == CAO_ODIRECT && pe[0]) ||
       56: 2169:		 (state.curopt->type == CAO_OEQUAL &&
       21: 2170:		  (pe[0] || pe[-1] == '=')))) {
       42: 2171:		if (state.def->type != CAA_REST &&
       42: 2172:		    state.def->type != CAA_RARGS &&
       21: 2173:		    state.def->type != CAA_RREST)
       21: 2174:		    state.def = state.def->next;
        -: 2175:
       21: 2176:		zaddlinknode(state.oargs[state.curopt->num],
        -: 2177:                             ca_opt_arg(state.curopt, oline));
        -: 2178:	    }
      244: 2179:	    if (state.def)
       36: 2180:		state.opt = 0;
        -: 2181:	    else {
       86: 2182:		if (!d->single || (state.curopt->name[1] && state.curopt->name[2]))
       74: 2183:		    wasopt = state.curopt;
       86: 2184:		state.curopt = NULL;
        -: 2185:	    }
      236: 2186:	} else if (state.opt == 2 && d->single &&
       19: 2187:		   ((state.curopt = ca_get_sopt(d, line, &pe, &sopts)) ||
       17: 2188:		    (cur != compcurrent && sopts && nonempty(sopts)))) {
        -: 2189:	    /* Or maybe it's a single-letter option? */
        -: 2190:
        -: 2191:	    char *p;
        -: 2192:	    Caopt tmpopt;
        -: 2193:
        7: 2194:	    if (cur != compcurrent && sopts && nonempty(sopts))
    #####: 2195:		state.curopt = (Caopt) uremnode(sopts, firstnode(sopts));
        -: 2196:
        7: 2197:	    if (!state.oargs[state.curopt->num])
        7: 2198:		state.oargs[state.curopt->num] = znewlinklist();
        -: 2199:
        7: 2200:	    state.def = state.curopt->args;
       18: 2201:	    ddef = (state.curopt->type == CAO_NEXT && cur == compcurrent ?
       13: 2202:		    NULL : state.def);
        7: 2203:	    dopt = state.curopt;
        7: 2204:	    doff = pe - line;
        7: 2205:	    state.optbeg = state.argbeg = state.inopt = cur;
        7: 2206:	    state.argend = argend;
        7: 2207:	    state.singles = (!pe || !*pe);
        -: 2208:
       18: 2209:	    for (p = line + 1; p < pe; p++) {
       11: 2210:		if ((tmpopt = d->single[STOUC(*p)])) {
       11: 2211:		    if (!state.oargs[tmpopt->num])
        4: 2212:			state.oargs[tmpopt->num] = znewlinklist();
        -: 2213:
       11: 2214:		    ca_inactive(d, tmpopt->xor, cur, 0);
        -: 2215:		}
        -: 2216:	    }
       10: 2217:	    if (state.def &&
        6: 2218:		(state.curopt->type == CAO_DIRECT ||
        6: 2219:		 state.curopt->type == CAO_EQUAL ||
        6: 2220:		 (state.curopt->type == CAO_ODIRECT && pe[0]) ||
        6: 2221:		 (state.curopt->type == CAO_OEQUAL &&
        4: 2222:		  (pe[0] || pe[-1] == '=')))) {
        4: 2223:		if (state.def->type != CAA_REST &&
        4: 2224:		    state.def->type != CAA_RARGS &&
        2: 2225:		    state.def->type != CAA_RREST)
        2: 2226:		    state.def = state.def->next;
        -: 2227:
        2: 2228:		zaddlinknode(state.oargs[state.curopt->num],
        -: 2229:                             ca_opt_arg(state.curopt, line));
        -: 2230:	    }
        7: 2231:	    if (state.def)
        1: 2232:		state.opt = 0;
        -: 2233:	    else
        6: 2234:		state.curopt = NULL;
      216: 2235:	} else if (multi && (*line == '-' || *line == '+') && cur != compcurrent
       15: 2236:		&& (ca_foreign_opt(d, all, line)))
       14: 2237:	    return 1;
      202: 2238:	else if (state.arg &&
       11: 2239:		 (!napat || cur <= compcurrent || !pattry(napat, line))) {
        -: 2240:	    /* Otherwise it's a normal argument. */
      171: 2241:	    if (napat && cur <= compcurrent)
       10: 2242:		ca_inactive(d, NULL, cur + 1, 1);
        -: 2243:
      171: 2244:	    arglast = 1;
        -: 2245:	    /* if this is the first normal arg after an option, may have been
        -: 2246:	     * earlier normal arguments if they're intermixed with options */
      171: 2247:	    if (state.inopt) {
      141: 2248:		state.inopt = 0;
      141: 2249:		state.nargbeg = cur - 1;
      141: 2250:		state.argend = argend;
        -: 2251:	    }
      171: 2252:	    if (!d->args && !d->rest && *line && *line != '-' && *line != '+') {
        2: 2253:		if (!multi && cur > compcurrent)
        1: 2254:		    break;
        1: 2255:		return 1;
        -: 2256:	    }
      271: 2257:	    if ((adef = state.def = ca_get_arg(d, state.nth)) &&
      201: 2258:		(state.def->type == CAA_RREST ||
       99: 2259:		 state.def->type == CAA_RARGS)) {
        -: 2260:
        -: 2261:		/* Bart 2009/11/17:
        -: 2262:		 * We've reached the "rest" definition.  If at this point
        -: 2263:		 * we already found another definition that describes the
        -: 2264:		 * current word, use that instead.  If not, prep for the
        -: 2265:		 * "narrowing" of scope to only the remaining words.
        -: 2266:		 *
        -: 2267:		 * We can't test ca_laststate.def in the loop conditions
        -: 2268:		 * at the top because this same loop also handles the
        -: 2269:		 * ':*PATTERN:MESSAGE:ACTION' form for multiple arguments
        -: 2270:		 * after an option, which may need to continue scanning.
        -: 2271:		 * There might be an earlier point at which this test can
        -: 2272:		 * be made but tracking it down is not worth the effort.
        -: 2273:		 */
        9: 2274:		if (ca_laststate.def)
    #####: 2275:		    break;
        -: 2276:
       16: 2277:		state.opt = (cur == state.nargbeg + 1 &&
    #####: 2278:			     (!multi || !*line || 
    #####: 2279:			      *line == '-' || *line == '+'));
        9: 2280:		state.optbeg = state.nargbeg;
        9: 2281:		state.argbeg = cur - 1;
        9: 2282:		state.argend = argend;
        -: 2283:
       32: 2284:		for (; line; line = compwords[cur++])
       23: 2285:		    zaddlinknode(state.args, ztrdup(line));
        -: 2286:
        9: 2287:		memcpy(&ca_laststate, &state, sizeof(state));
        9: 2288:		ca_laststate.ddef = NULL;
        9: 2289:		ca_laststate.dopt = NULL;
        9: 2290:		break;
        -: 2291:	    }
      160: 2292:	    zaddlinknode(state.args, ztrdup(line));
      160: 2293:            if (adef)
       93: 2294:                state.oopt = adef->num - state.nth;
        -: 2295:
      160: 2296:	    if (state.def)
       93: 2297:		argxor = state.def->xor;
        -: 2298:
      184: 2299:	    if (state.def && state.def->type != CAA_NORMAL &&
       46: 2300:		state.def->type != CAA_OPT && state.inarg) {
       17: 2301:		state.restbeg = cur;
       17: 2302:		state.inarg = 0;
      150: 2303:	    } else if (!state.def || state.def->type == CAA_NORMAL ||
        7: 2304:		       state.def->type == CAA_OPT)
      138: 2305:		state.inarg = 1;
      160: 2306:	    state.nth++;
      160: 2307:	    state.def = NULL;
        -: 2308:	}
        -: 2309:	/* Do the end-pattern test if needed. */
        -: 2310:
      369: 2311:	if (state.def && state.curopt &&
       87: 2312:	    (state.def->type == CAA_RREST || state.def->type == CAA_RARGS)) {
       22: 2313:	    if (state.def->end)
       11: 2314:		endpat = patcompile(state.def->end, 0, NULL);
        -: 2315:	    else {
    #####: 2316:		LinkList l = state.oargs[state.curopt->num];
        -: 2317:
    #####: 2318:		if (cur < compcurrent)
    #####: 2319:		    memcpy(&ca_laststate, &state, sizeof(state));
        -: 2320:
    #####: 2321:		for (; line; line = compwords[cur++])
    #####: 2322:		    zaddlinknode(l, ztrdup(line));
        -: 2323:
    #####: 2324:		ca_laststate.ddef = NULL;
    #####: 2325:		ca_laststate.dopt = NULL;
    #####: 2326:		break;
        -: 2327:	    }
      347: 2328:	} else if (state.def && state.def->end)
        5: 2329:	    endpat = patcompile(state.def->end, 0, NULL);
        -: 2330:
        -: 2331:	/* Copy the state into the global one. */
        -: 2332:
      630: 2333:    cont:
        -: 2334:
      326: 2335:	if (cur + 1 == compcurrent) {
       96: 2336:	    memcpy(&ca_laststate, &state, sizeof(state));
       96: 2337:	    ca_laststate.ddef = NULL;
       96: 2338:	    ca_laststate.dopt = NULL;
      230: 2339:	} else if (cur == compcurrent && !ca_laststate.def) {
      149: 2340:	    if ((ca_laststate.def = ddef)) {
       18: 2341:		ca_laststate.singles = state.singles;
       18: 2342:		if (state.curopt && state.curopt->type == CAO_NEXT) {
        3: 2343:		    ca_laststate.ddef = ddef;
        3: 2344:		    ca_laststate.dopt = dopt;
        3: 2345:		    ca_laststate.def = NULL;
        3: 2346:		    ca_laststate.opt = 1;
        3: 2347:		    state.curopt->active = 1;
        -: 2348:		} else {
       15: 2349:		    ca_doff = doff;
       15: 2350:		    ca_laststate.opt = 0;
        -: 2351:		}
        -: 2352:	    } else {
      131: 2353:		ca_laststate.def = adef;
      273: 2354:		ca_laststate.opt = (!arglast || !multi || !*line || 
      154: 2355:				    *line == '-' || *line == '+');
      131: 2356:		ca_laststate.ddef = NULL;
      131: 2357:		ca_laststate.dopt = NULL;
      131: 2358:		ca_laststate.optbeg = state.nargbeg;
      131: 2359:		ca_laststate.argbeg = state.restbeg;
      131: 2360:		ca_laststate.argend = state.argend;
      131: 2361:		ca_laststate.singles = state.singles;
      131: 2362:		ca_laststate.oopt = state.oopt;
      131: 2363:		if (wasopt)
        4: 2364:		    wasopt->active = 1;
        -: 2365:	    }
        -: 2366:	}
        -: 2367:    }
      168: 2368: end:
        -: 2369:
      178: 2370:    ca_laststate.actopts = 0;
      515: 2371:    for (ptr = d->opts; ptr; ptr = ptr->next)
      337: 2372:	if (ptr->active)
      199: 2373:	    ca_laststate.actopts++;
        -: 2374:
      178: 2375:    return 0;
        -: 2376:}
        -: 2377:
        -: 2378:/* Build a NUL-separated from a list.
        -: 2379: *
        -: 2380: * This is only used to populate values of $opt_args.
        -: 2381: */
        -: 2382:
        -: 2383:static char *
        1: 2384:ca_nullist(LinkList l)
        -: 2385:{
        1: 2386:    if (l) {
        1: 2387:	char **array = zlinklist2array(l, 0 /* don't dup elements */);
        1: 2388:	char *ret = zjoin(array, '\0', 0 /* permanent allocation */);
        1: 2389:	free(array); /* the elements are owned by the list */
        1: 2390:	return ret;
        -: 2391:    } else
    #####: 2392:	return ztrdup("");
        -: 2393:}
        -: 2394:
        -: 2395:/* Build a colon-list from a list.
        -: 2396: *
        -: 2397: * This is only used to populate values of $opt_args.
        -: 2398: */
        -: 2399:
        -: 2400:static char *
       63: 2401:ca_colonlist(LinkList l)
        -: 2402:{
       63: 2403:    if (l) {
        -: 2404:	LinkNode n;
       63: 2405:	int len = 0;
        -: 2406:	char *p, *ret, *q;
        -: 2407:
        -: 2408:	/* Compute the length to be allocated. */
      117: 2409:	for (n = firstnode(l); n; incnode(n)) {
       54: 2410:	    len++;
      109: 2411:	    for (p = (char *) getdata(n); *p; p++)
       55: 2412:		len += (*p == ':' || *p == '\\') ? 2 : 1;
        -: 2413:	}
       63: 2414:	ret = q = (char *) zalloc(len);
        -: 2415:
        -: 2416:	/* Join L into RET, joining with colons and escaping colons and
        -: 2417:	 * backslashes. */
      180: 2418:	for (n = firstnode(l); n;) {
      109: 2419:	    for (p = (char *) getdata(n); *p; p++) {
       55: 2420:		if (*p == ':' || *p == '\\')
        2: 2421:		    *q++ = '\\';
       55: 2422:		*q++ = *p;
        -: 2423:	    }
       54: 2424:	    incnode(n);
       54: 2425:	    if (n)
       17: 2426:		*q++ = ':';
        -: 2427:	}
       63: 2428:	*q = '\0';
        -: 2429:
       63: 2430:	return ret;
        -: 2431:    } else
    #####: 2432:	return ztrdup("");
        -: 2433:}
        -: 2434:
        -: 2435:/*
        -: 2436: * This function adds the current set of descriptions, actions,
        -: 2437: * and subcontext descriptions to the given linked list for passing
        -: 2438: * up in comparguments -D and comparguments -L.  opt is the
        -: 2439: * option string (may be NULL if this isn't an option argument) and arg the
        -: 2440: * argument structure (either an option argument or a normal argument
        -: 2441: * as determined by arg->type).
        -: 2442: */
        -: 2443:
        -: 2444:static void
      103: 2445:ca_set_data(LinkList descr, LinkList act, LinkList subc,
        -: 2446:	    char *opt, Caarg arg, Caopt optdef, int single)
        -: 2447:{
        -: 2448:    LinkNode dnode, anode;
        -: 2449:    char nbuf[40], *buf;
      103: 2450:    int restr = 0, onum, miss = 0, rest, oopt = 1, lopt = 0, addopt;
        -: 2451:
      104: 2452: rec:
        -: 2453:
      104: 2454:    addopt = (opt ? 0 : ca_laststate.oopt);
        -: 2455:
      325: 2456:    for (; arg && (opt || (arg->num < 0 ||
       97: 2457:			   (arg->min <= ca_laststate.nth + addopt &&
       47: 2458:			    arg->num >= ca_laststate.nth)));) {
      104: 2459:	lopt = (arg->type == CAA_OPT);
      104: 2460:	if (!opt && !lopt && oopt > 0)
       67: 2461:	    oopt = 0;
        -: 2462:
      212: 2463:	for (dnode = firstnode(descr), anode = firstnode(act);
        4: 2464:	     dnode; incnode(dnode), incnode(anode))
        5: 2465:	    if (!strcmp((char *) getdata(dnode), arg->descr) &&
        1: 2466:		!strcmp((char *) getdata(anode), arg->action))
    #####: 2467:		break;
        -: 2468:
        -: 2469:	/* with an ignored prefix, we're not completing any normal arguments */
      104: 2470:	if (single && !arg->opt)
       18: 2471:	    return;
        -: 2472:
      103: 2473:	if (!dnode) {
      103: 2474:	    addlinknode(descr, arg->descr);
      103: 2475:	    addlinknode(act, arg->action);
        -: 2476:
      103: 2477:	    if (!restr) {
        -: 2478:
      103: 2479:		if ((restr = (arg->type == CAA_RARGS)))
        6: 2480:		    restrict_range(ca_laststate.optbeg, ca_laststate.argend);
       97: 2481:		else if ((restr = (arg->type == CAA_RREST)))
        8: 2482:		    restrict_range(ca_laststate.argbeg, ca_laststate.argend);
        -: 2483:	    }
      103: 2484:	    if (arg->opt) {
       74: 2485:		buf = (char *) zhalloc((arg->gsname ? strlen(arg->gsname) : 0) +
       37: 2486:				       strlen(arg->opt) + 40);
       37: 2487:		if (arg->num > 0 && arg->type < CAA_REST)
       64: 2488:		    sprintf(buf, "%soption%s-%d",
       32: 2489:			    (arg->gsname ? arg->gsname : ""), arg->opt, arg->num);
        -: 2490:		else
       10: 2491:		    sprintf(buf, "%soption%s-rest",
        5: 2492:			    (arg->gsname ? arg->gsname : ""), arg->opt);
       66: 2493:	    } else if (arg->num > 0) {
       46: 2494:		sprintf(nbuf, "argument-%d", arg->num);
       46: 2495:		buf = (arg->gsname ? dyncat(arg->gsname, nbuf) : dupstring(nbuf));
        -: 2496:	    } else
       20: 2497:		buf = (arg->gsname ? dyncat(arg->gsname, "argument-rest") :
        -: 2498:		       dupstring("argument-rest"));
        -: 2499:
      103: 2500:	    addlinknode(subc, buf);
        -: 2501:	}
        -: 2502:	/*
        -: 2503:	 * If this is an argument to an option, and the option definition says
        -: 2504:	 * the argument to the option is required and in the following
        -: 2505:	 * (i.e. this) word, then it must match what we've just told it to
        -: 2506:	 * match---don't try to match normal arguments.
        -: 2507:	 *
        -: 2508:	 * This test may be too stringent for what we need, or it
        -: 2509:	 * may be too loose; I've simply tweaked it until it gets
        -: 2510:	 * the case above right.
        -: 2511:	 */
      103: 2512:	if (arg->type == CAA_NORMAL &&
       47: 2513:	    opt && optdef &&
       31: 2514:	    (optdef->type == CAO_NEXT || optdef->type == CAO_ODIRECT ||
        6: 2515:	     optdef->type == CAO_OEQUAL))
       16: 2516:	    return;
        -: 2517:
       87: 2518:	if (single)
       15: 2519:	    break;
        -: 2520:
       72: 2521:	if (!opt) {
       66: 2522:	    if (arg->num >= 0 && !arg->next && miss)
    #####: 2523:		arg = (ca_laststate.d->rest && ca_laststate.d->rest->active ?
    #####: 2524:		       ca_laststate.d->rest : NULL);
        -: 2525:	    else {
       66: 2526:		onum = arg->num;
       66: 2527:		rest = (onum != arg->min && onum == ca_laststate.nth);
       66: 2528:		if ((arg = arg->next)) {
        3: 2529:		    if (arg->num != onum + 1)
    #####: 2530:			miss = 1;
       63: 2531:		} else if (rest || (oopt > 0 && !opt)) {
    #####: 2532:		    arg = (ca_laststate.d->rest && ca_laststate.d->rest->active ?
    #####: 2533:			   ca_laststate.d->rest : NULL);
    #####: 2534:		    oopt = -1;
        -: 2535:		}
        -: 2536:	    }
        -: 2537:	} else {
        6: 2538:	    if (!lopt)
        5: 2539:		break;
        1: 2540:	    arg = arg->next;
        -: 2541:	}
        -: 2542:    }
       87: 2543:    if (!single && opt && (lopt || ca_laststate.oopt)) {
        1: 2544:	opt = NULL;
        1: 2545:	arg = ca_get_arg(ca_laststate.d, ca_laststate.nth);
        1: 2546:	goto rec;
        -: 2547:    }
       86: 2548:    if (!opt && oopt > 0) {
    #####: 2549:	oopt = -1;
    #####: 2550:	arg = (ca_laststate.d->rest && ca_laststate.d->rest->active ?
    #####: 2551:	       ca_laststate.d->rest : NULL);
        -: 2552:
    #####: 2553:	goto rec;
        -: 2554:    }
        -: 2555:}
        -: 2556:
        -: 2557:static int
      882: 2558:bin_comparguments(char *nam, char **args, UNUSED(Options ops), UNUSED(int func))
        -: 2559:{
        -: 2560:    int min, max, n;
      882: 2561:    Castate lstate = &ca_laststate;
        -: 2562:
      882: 2563:    if (incompfunc != 1) {
    #####: 2564:	zwarnnam(nam, "can only be called from completion function");
    #####: 2565:	return 1;
        -: 2566:    }
      882: 2567:    if (args[0][0] != '-' || !args[0][1] || args[0][2]) {
    #####: 2568:	zwarnnam(nam, "invalid argument: %s", args[0]);
    #####: 2569:	return 1;
        -: 2570:    }
      882: 2571:    if (args[0][1] != 'i' && args[0][1] != 'I' && !ca_parsed) {
    #####: 2572:	zwarnnam(nam, "no parsed state");
    #####: 2573:	return 1;
        -: 2574:    }
      882: 2575:    switch (args[0][1]) {
      167: 2576:    case 'i': min = 2; max = -1; break;
      164: 2577:    case 'D': min = 3; max =  3; break;
      164: 2578:    case 'O': min = 4; max =  4; break;
        2: 2579:    case 'L': min = 3; max =  4; break;
       63: 2580:    case 's': min = 1; max =  1; break;
      152: 2581:    case 'M': min = 1; max =  1; break;
       67: 2582:    case 'a': min = 0; max =  0; break;
      103: 2583:    case 'W': min = 3; max =  3; break;
    #####: 2584:    case 'n': min = 1; max =  1; break;
    #####: 2585:    default:
    #####: 2586:	zwarnnam(nam, "invalid option: %s", args[0]);
    #####: 2587:	return 1;
        -: 2588:    }
      882: 2589:    n = arrlen(args) - 1;
      882: 2590:    if (n < min) {
    #####: 2591:	zwarnnam(nam, "not enough arguments");
    #####: 2592:	return 1;
      882: 2593:    } else if (max >= 0 && n > max) {
    #####: 2594:	zwarnnam(nam, "too many arguments");
    #####: 2595:	return 1;
        -: 2596:    }
      882: 2597:    switch (args[0][1]) {
      167: 2598:    case 'i':
        -: 2599:        /* This initialises the internal data structures. Arguments are the
        -: 2600:         * auto-description string, the optional -s, -S, -A and -M options
        -: 2601:         * given to _arguments and the specs. */
      167: 2602:	if (compcurrent > 1 && compwords[0]) {
        -: 2603:	    Cadef def, all;
      167: 2604:	    int cap = ca_parsed, multi, first = 1, use, ret = 0;
      167: 2605:	    Castate states = NULL, sp;
        -: 2606:
      167: 2607:	    ca_parsed = 0;
        -: 2608:
      167: 2609:	    if (!(def = all = get_cadef(nam, args + 1)))
    #####: 2610:		return 1;
        -: 2611:
      167: 2612:	    multi = !!def->snext; /* if we have sets */
      167: 2613:	    ca_parsed = cap;
      167: 2614:	    ca_doff = 0;
        -: 2615:
      527: 2616:	    while (def) { /* for each set */
      193: 2617:		use = !ca_parse_line(def, all, multi, first);
      193: 2618:		def = def->snext;
      193: 2619:		if (use && def) {
        -: 2620:		    /* entry needed so save it into list */
       19: 2621:		    sp = (Castate) zalloc(sizeof(*sp));
       19: 2622:		    memcpy(sp, &ca_laststate, sizeof(*sp));
       19: 2623:		    sp->snext = states;
       19: 2624:		    states = sp;
      174: 2625:		} else if (!use && !def) {
        -: 2626:		    /* final entry not needed */
        8: 2627:		    if (states) {
        5: 2628:			freecastate(&ca_laststate);
        5: 2629:			memcpy(&ca_laststate, states, sizeof(*sp));
        5: 2630:			sp = states->snext;
        5: 2631:			zfree(states, sizeof(*states));
        5: 2632:			states = sp;
        -: 2633:		    } else
        3: 2634:			ret = 1;
        -: 2635:		}
      193: 2636:		first = 0;
        -: 2637:	    }
      167: 2638:	    ca_parsed = 1;
      167: 2639:	    ca_laststate.snext = states;
        -: 2640:
      167: 2641:	    return ret;
        -: 2642:	}
    #####: 2643:	return 1;
        -: 2644:
      164: 2645:    case 'D':
        -: 2646:        /* This returns the descriptions, actions and sub-contexts for the
        -: 2647:         * things _arguments has to execute at this place on the line (the
        -: 2648:         * sub-contexts are used as tags).
        -: 2649:         * The return value is particularly important here, it says if 
        -: 2650:         * there are arguments to complete at all. */
        -: 2651:	{
        -: 2652:	    LinkList descr, act, subc;
        -: 2653:	    Caarg arg;
      164: 2654:	    int ret = 1;
        -: 2655:
      164: 2656:	    descr = newlinklist();
      164: 2657:	    act = newlinklist();
      164: 2658:	    subc = newlinklist();
        -: 2659:
      164: 2660:	    ignore_prefix(ca_doff);
      506: 2661:	    while (lstate) {
      178: 2662:		arg = lstate->def;
        -: 2663:
      178: 2664:		if (arg) {
      101: 2665:		    ret = 0;
      101: 2666:		    ca_set_data(descr, act, subc, arg->opt, arg,
        -: 2667:				lstate->curopt, (ca_doff > 0));
        -: 2668:		}
      178: 2669:		lstate = lstate->snext;
        -: 2670:	    }
      164: 2671:	    if (!ret) {
       97: 2672:		set_list_array(args[1], descr);
       97: 2673:		set_list_array(args[2], act);
       97: 2674:		set_list_array(args[3], subc);
        -: 2675:	    }
      164: 2676:	    return ret;
        -: 2677:	}
      164: 2678:    case 'O':
        -: 2679:        /* This returns the descriptions for the options in the arrays whose
        -: 2680:         * names are given as arguments.  The descriptions are strings in a
        -: 2681:         * form usable by _describe.  The return value says if there are any
        -: 2682:         * options to be completed. */
        -: 2683:	{
      164: 2684:	    LinkList next = newlinklist();
      164: 2685:	    LinkList direct = newlinklist();
      164: 2686:	    LinkList odirect = newlinklist();
      164: 2687:	    LinkList equal = newlinklist(), l;
        -: 2688:            LinkNode node;
        -: 2689:	    Caopt p;
        -: 2690:	    char *str;
      164: 2691:	    int ret = 1;
        -: 2692:
      342: 2693:	    for (; lstate; lstate = lstate->snext) {
      300: 2694:		if (lstate->actopts &&
      153: 2695:		    (lstate->opt || (ca_doff && lstate->def) ||
       30: 2696:		     (lstate->def && lstate->def->opt &&
       20: 2697:		      (lstate->def->type == CAA_OPT ||
       10: 2698:		       (lstate->def->type >= CAA_RARGS &&
      108: 2699:			lstate->def->num < 0)))) &&
      157: 2700:		    (!lstate->def || lstate->def->type < CAA_RARGS ||
        4: 2701:		     (lstate->def->type == CAA_RARGS ?
        4: 2702:		      (lstate->curpos == lstate->argbeg + 1) :
        -: 2703:		      (compcurrent == 1)))) {
      104: 2704:		    ret = 0;
      359: 2705:		    for (p = lstate->d->opts; p; p = p->next) {
      255: 2706:			if (p->active && !p->not) {
      178: 2707:			    switch (p->type) {
      152: 2708:			    case CAO_NEXT:    l = next;    break;
        3: 2709:			    case CAO_DIRECT:  l = direct;  break;
        7: 2710:			    case CAO_ODIRECT: l = odirect; break;
       16: 2711:			    default:          l = equal;   break;
        -: 2712:			    }
      178: 2713:			    if (p->descr) {
        2: 2714:				char *n = bslashcolon(p->name);
        2: 2715:				int len = strlen(n) + strlen(p->descr) + 2;
        -: 2716:
        2: 2717:				str = (char *) zhalloc(len);
        2: 2718:				strcpy(str, n);
        2: 2719:				strcat(str, ":");
        2: 2720:				strcat(str, p->descr);
        -: 2721:			    } else
      176: 2722:				str = bslashcolon(p->name);
        -: 2723:
      286: 2724:                            for (node = firstnode(l); node; incnode(node))
      114: 2725:                                if (!strcmp(str, (char *) getdata(node)))
        6: 2726:                                    break;
        -: 2727:
      178: 2728:                            if (!node)
      172: 2729:                                addlinknode(l, str);
        -: 2730:			}
        -: 2731:		    }
        -: 2732:		}
        -: 2733:	    }
      164: 2734:	    if (!ret) {
       95: 2735:		set_list_array(args[1], next);
       95: 2736:		set_list_array(args[2], direct);
       95: 2737:		set_list_array(args[3], odirect);
       95: 2738:		set_list_array(args[4], equal);
        -: 2739:
       95: 2740:		return 0;
        -: 2741:	    }
       69: 2742:	    return (ca_laststate.singles ? 2 : 1);
        -: 2743:	}
        2: 2744:    case 'L':
        -: 2745:        /* This tests if the beginning of the current word matches an option.
        -: 2746:         * It is for cases like `./configure --pre=/<TAB>' which should
        -: 2747:         * complete to `--prefix=/...'.  The options name isn't fully typed
        -: 2748:         * and _arguments finds out that there is no option `--pre' and that
        -: 2749:         * it should complete some argument to an option.  It then uses -L
        -: 2750:         * to find the option the argument is for. */
        -: 2751:	{
        -: 2752:	    LinkList descr, act, subc;
        -: 2753:	    Caopt opt;
        2: 2754:	    int ret = 1;
        -: 2755:
        2: 2756:	    descr = newlinklist();
        2: 2757:	    act = newlinklist();
        2: 2758:	    subc = newlinklist();
        -: 2759:
        6: 2760:	    while (lstate) {
        2: 2761:		opt = ca_get_opt(lstate->d, args[1], 1, NULL);
        -: 2762:
        2: 2763:		if (opt && opt->args) {
        2: 2764:		    ret = 0;
        2: 2765:		    ca_set_data(descr, act, subc, opt->name, opt->args, opt, 1);
        -: 2766:		}
        2: 2767:		lstate = lstate->snext;
        -: 2768:	    }
        2: 2769:	    if (!ret) {
        2: 2770:		set_list_array(args[2], descr);
        2: 2771:		set_list_array(args[3], act);
        2: 2772:		set_list_array(args[4], subc);
        -: 2773:	    }
        2: 2774:	    return ret;
        -: 2775:	}
       63: 2776:    case 's':
        -: 2777:        /* This returns zero if we are completing single letter options.
        -: 2778:         * It also uses its argument as the name of a parameter and sets
        -: 2779:         * that to a string describing the argument behaviour of the last
        -: 2780:         * option in the current word so that we can get the auto-suffix
        -: 2781:         * right. */
      127: 2782:	for (; lstate; lstate = lstate->snext)
       78: 2783:	    if (lstate->d->single && lstate->singles &&
        7: 2784:		lstate->actopts
        -: 2785:#if 0
        -: 2786:                /* let's try without, for the -W option of _arguments */
        -: 2787:                && lstate->opt
        -: 2788:#endif
        -: 2789:                ) {
        7: 2790:		setsparam(args[1],
        7: 2791:			  ztrdup((lstate->ddef && lstate->dopt) ?
    #####: 2792:				 (lstate->dopt->type == CAO_DIRECT ?
        -: 2793:				  "direct" :
    #####: 2794:				  ((lstate->dopt->type == CAO_OEQUAL ||
    #####: 2795:				    lstate->dopt->type == CAO_EQUAL) ?
    #####: 2796:				   "equal" : "next")) : ""));
        7: 2797:		return 0;
        -: 2798:	    }
       56: 2799:	return 1;
      152: 2800:    case 'M':
        -: 2801:        /* This returns the match specs defined for the set of specs we are
        -: 2802:         * using.  Returned, as usual in a parameter whose name is given as
        -: 2803:         * the argument. */
      152: 2804:	setsparam(args[1], ztrdup(ca_laststate.d->match));
      152: 2805:	return 0;
       67: 2806:    case 'a':
        -: 2807:        /* This just sets the return value.  To zero if there would be or
        -: 2808:         * were any normal arguments to be completed.  Used to decide if
        -: 2809:         * _arguments should say `no arguments' or `no more arguments'. */
      127: 2810:	for (; lstate; lstate = lstate->snext)
       75: 2811:	    if (lstate->d->args || lstate->d->rest)
       15: 2812:		return 0;
       52: 2813:	return 1;
      103: 2814:    case 'W':
        -: 2815:        /* This gets two parameter names and one integer as arguments.
        -: 2816:         *
        -: 2817:         * The first parameter is set to the current word sans any option
        -: 2818:         * prefixes handled by comparguments.
        -: 2819:         *
        -: 2820:         * The second parameter is set to an array containing the options on
        -: 2821:         * the line and their arguments.  I.e. the stuff _arguments returns
        -: 2822:         * to its caller in the `line' and `opt_args' parameters.
        -: 2823:         *
        -: 2824:         * The integer is one if the second parameter (which is just $opt_args,
        -: 2825:         * you know) should encode multiple values by joining them with NULs
        -: 2826:         * and zero if it should encode multiple values by joining them with
        -: 2827:         * colons after backslash-escaping colons and backslashes.
        -: 2828:         */
        -: 2829:	{
        -: 2830:	    Castate s;
        -: 2831:	    char **ret, **p;
        -: 2832:	    LinkNode n;
        -: 2833:	    LinkList *a;
        -: 2834:	    Caopt o;
        -: 2835:	    int num;
      103: 2836:	    int opt_args_use_NUL_separators = (args[3][0] != '0');
        -: 2837:
      217: 2838:	    for (num = 0, s = lstate; s; s = s->snext)
      114: 2839:		num += countlinknodes(s->args);
        -: 2840:
      103: 2841:	    ret = p = zalloc((num + 1) * sizeof(char *));
        -: 2842:
      217: 2843:	    for (s = lstate; s; s = s->snext)
      234: 2844:		for (n = firstnode(s->args); n; incnode(n))
      120: 2845:		    *p++ = ztrdup((char *) getdata(n));
      103: 2846:	    *p = NULL;
        -: 2847:
      103: 2848:	    setaparam(args[1], ret);
        -: 2849:
      217: 2850:	    for (num = 0, s = lstate; s; s = s->snext)
      266: 2851:		for (o = s->d->opts, a = s->oargs; o; o = o->next, a++)
      152: 2852:		    if (*a)
       64: 2853:			num += 2;
        -: 2854:
      103: 2855:	    ret = p = zalloc((num + 1) * sizeof(char *));
        -: 2856:
      217: 2857:	    for (s = lstate; s; s = s->snext)
      266: 2858:		for (o = s->d->opts, a = s->oargs; o; o = o->next, a++)
      152: 2859:		    if (*a) {
      123: 2860:			*p++ = (o->gsname ? tricat(o->gsname, o->name, "") :
       59: 2861:				ztrdup(o->name));
       64: 2862:			if (opt_args_use_NUL_separators)
        1: 2863:			    *p++ = ca_nullist(*a);
        -: 2864:			else
       63: 2865:			    *p++ = ca_colonlist(*a);
        -: 2866:		    }
      103: 2867:	    *p = NULL;
        -: 2868:
      103: 2869:	    sethparam(args[2], ret);
        -: 2870:	}
      103: 2871:	return 0;
    #####: 2872:    case 'n':
        -: 2873:	/*
        -: 2874:	 * This returns the array index of the word where normal
        -: 2875:	 * arguments began.  It uses optbeg rather than nargbeg
        -: 2876:	 * (the value used when parsing) because nargbeg is assigned
        -: 2877:	 * to optbeg in the returned value and nargbeg isn't
        -: 2878:	 * used.
        -: 2879:	 *
        -: 2880:	 * -->PLEASE DON'T ASK<--
        -: 2881:	 *
        -: 2882:	 * Thank you.
        -: 2883:	 */
    #####: 2884:	setiparam(args[1], (zlong)ca_laststate.optbeg + !isset(KSHARRAYS));
    #####: 2885:	return 0;
        -: 2886:    }
    #####: 2887:    return 1;
        -: 2888:}
        -: 2889:
        -: 2890:/* Help for `_values'. */
        -: 2891:
        -: 2892:typedef struct cvdef *Cvdef;
        -: 2893:typedef struct cvval *Cvval;
        -: 2894:
        -: 2895:/* Definitions for _values. */
        -: 2896:
        -: 2897:struct cvdef {
        -: 2898:    char *descr;		/* global description */
        -: 2899:    int hassep;			/* multiple values allowed */
        -: 2900:    char sep;			/* separator character */
        -: 2901:    char argsep;                /* argument separator */
        -: 2902:    Cvdef next;			/* next in cache */
        -: 2903:    Cvval vals;			/* value definitions */
        -: 2904:    char **defs;		/* original strings */
        -: 2905:    int ndefs;			/* number of ... */
        -: 2906:    int lastt;			/* last time used */
        -: 2907:    int words;                  /* if to look at other words */
        -: 2908:};
        -: 2909:
        -: 2910:/* One value definition. */
        -: 2911:
        -: 2912:struct cvval {
        -: 2913:    Cvval next;
        -: 2914:    char *name;			/* value name */
        -: 2915:    char *descr;		/* description */
        -: 2916:    char **xor;			/* xor-list */
        -: 2917:    int type;			/* CVV_* below */
        -: 2918:    Caarg arg;			/* argument definition */
        -: 2919:    int active;			/* still allowed */
        -: 2920:};
        -: 2921:
        -: 2922:#define CVV_NOARG 0
        -: 2923:#define CVV_ARG   1
        -: 2924:#define CVV_OPT   2
        -: 2925:
        -: 2926:/* Cache. */
        -: 2927:
        -: 2928:#define MAX_CVCACHE 8
        -: 2929:static Cvdef cvdef_cache[MAX_CVCACHE];
        -: 2930:
        -: 2931:/* Memory stuff. */
        -: 2932:
        -: 2933:static void
    #####: 2934:freecvdef(Cvdef d)
        -: 2935:{
    #####: 2936:    if (d) {
        -: 2937:	Cvval p, n;
        -: 2938:
    #####: 2939:	zsfree(d->descr);
    #####: 2940:	if (d->defs)
    #####: 2941:	    freearray(d->defs);
        -: 2942:
    #####: 2943:	for (p = d->vals; p; p = n) {
    #####: 2944:	    n = p->next;
    #####: 2945:	    zsfree(p->name);
    #####: 2946:	    zsfree(p->descr);
    #####: 2947:	    if (p->xor)
    #####: 2948:		freearray(p->xor);
    #####: 2949:	    freecaargs(p->arg);
    #####: 2950:	    zfree(p, sizeof(*p));
        -: 2951:	}
    #####: 2952:	zfree(d, sizeof(*d));
        -: 2953:    }
    #####: 2954:}
        -: 2955:
        -: 2956:/* Parse option definitions. */
        -: 2957:
        -: 2958:static Cvdef
    #####: 2959:parse_cvdef(char *nam, char **args)
        -: 2960:{
        -: 2961:    Cvdef ret;
        -: 2962:    Cvval val, *valp;
        -: 2963:    Caarg arg;
    #####: 2964:    char **oargs = args, sep = '\0', asep = '=', *name, *descr, *p, *q, **xor, c;
    #####: 2965:    int xnum, multi, vtype, hassep = 0, words = 0;
        -: 2966:
    #####: 2967:    while (args && args[0] && args[1] &&
    #####: 2968:           args[0][0] == '-' &&
    #####: 2969:           (args[0][1] == 's' || args[0][1] == 'S' || args[0][1] == 'w') &&
    #####: 2970:           !args[0][2]) {
        -: 2971:
    #####: 2972:        if (args[0][1] == 's') {
    #####: 2973:            hassep = 1;
    #####: 2974:            sep = args[1][0];
    #####: 2975:            args += 2;
    #####: 2976:        } else if (args[0][1] == 'S') {
    #####: 2977:            asep = args[1][0];
    #####: 2978:            args += 2;
        -: 2979:        } else {
    #####: 2980:            words = 1;
    #####: 2981:            args++;
        -: 2982:        }
        -: 2983:    }
    #####: 2984:    if (!args[0] || !args[1]) {
    #####: 2985:	zwarnnam(nam, "not enough arguments");
    #####: 2986:	return NULL;
        -: 2987:    }
    #####: 2988:    descr = *args++;
        -: 2989:
    #####: 2990:    ret = (Cvdef) zalloc(sizeof(*ret));
    #####: 2991:    ret->descr = ztrdup(descr);
    #####: 2992:    ret->hassep = hassep;
    #####: 2993:    ret->sep = sep;
    #####: 2994:    ret->argsep = asep;
    #####: 2995:    ret->next = NULL;
    #####: 2996:    ret->vals = NULL;
    #####: 2997:    ret->defs = zarrdup(oargs);
    #####: 2998:    ret->ndefs = arrlen(oargs);
    #####: 2999:    ret->lastt = time(0);
    #####: 3000:    ret->words = words;
        -: 3001:
    #####: 3002:    for (valp = &(ret->vals); *args; args++) {
    #####: 3003:	int bs = 0;
    #####: 3004:	p = dupstring(*args);
    #####: 3005:	xnum = 0;
        -: 3006:
        -: 3007:	/* xor list? */
    #####: 3008:	if (*p == '(') {
    #####: 3009:	    LinkList list = newlinklist();
        -: 3010:	    LinkNode node;
        -: 3011:	    char **xp, sav;
        -: 3012:
    #####: 3013:	    while (*p && *p != ')') {
    #####: 3014:		for (p++; inblank(*p); p++);
        -: 3015:
    #####: 3016:		if (*p == ')')
    #####: 3017:		    break;
    #####: 3018:		for (q = p++; *p && *p != ')' && !inblank(*p); p++);
        -: 3019:
    #####: 3020:		if (!*p)
    #####: 3021:		    break;
        -: 3022:
    #####: 3023:		sav = *p;
    #####: 3024:		*p = '\0';
    #####: 3025:		addlinknode(list, dupstring(q));
    #####: 3026:		xnum++;
    #####: 3027:		*p = sav;
        -: 3028:	    }
    #####: 3029:	    if (*p != ')') {
    #####: 3030:		freecvdef(ret);
    #####: 3031:		zwarnnam(nam, "invalid argument: %s", *args);
    #####: 3032:		return NULL;
        -: 3033:	    }
    #####: 3034:	    xor = (char **) zalloc((xnum + 2) * sizeof(char *));
    #####: 3035:	    for (node = firstnode(list), xp = xor; node; incnode(node), xp++)
    #####: 3036:		*xp = ztrdup((char *) getdata(node));
    #####: 3037:	    xp[0] = xp[1] = NULL;
        -: 3038:
    #####: 3039:	    p++;
        -: 3040:	} else
    #####: 3041:	    xor = NULL;
        -: 3042:
        -: 3043:	/* More than once allowed? */
    #####: 3044:	if ((multi = (*p == '*')))
    #####: 3045:	    p++;
        -: 3046:
        -: 3047:	/* Skip option name. */
        -: 3048:
    #####: 3049:	for (name = p; *p && *p != ':' && *p != '['; p++)
    #####: 3050:	    if (*p == '\\' && p[1])
    #####: 3051:		p++, bs = 1;
        -: 3052:
    #####: 3053:	if (hassep && !sep && name + bs + 1 < p) {
    #####: 3054:	    freecvdef(ret);
    #####: 3055:	    if (xor) freearray(xor);
    #####: 3056:	    zwarnnam(nam, "no multi-letter values with empty separator allowed");
    #####: 3057:	    return NULL;
        -: 3058:	}
        -: 3059:	/* Optional description? */
        -: 3060:
    #####: 3061:	if ((c = *p) == '[') {
    #####: 3062:	    *p = '\0';
    #####: 3063:	    for (descr = ++p; *p && *p != ']'; p++)
    #####: 3064:		if (*p == '\\' && p[1])
    #####: 3065:		    p++;
        -: 3066:
    #####: 3067:	    if (!*p) {
    #####: 3068:		freecvdef(ret);
    #####: 3069:		if (xor) freearray(xor);
    #####: 3070:		zwarnnam(nam, "invalid value definition: %s", *args);
    #####: 3071:		return NULL;
        -: 3072:	    }
    #####: 3073:	    *p++ = '\0';
    #####: 3074:	    c = *p;
        -: 3075:	} else {
    #####: 3076:	    *p = '\0';
    #####: 3077:	    descr = NULL;
        -: 3078:	}
    #####: 3079:	if (c && c != ':') {
    #####: 3080:	    freecvdef(ret);
    #####: 3081:	    if (xor) freearray(xor);
    #####: 3082:	    zwarnnam(nam, "invalid value definition: %s", *args);
    #####: 3083:	    return NULL;
        -: 3084:	}
        -: 3085:	/* Get argument? */
        -: 3086:
    #####: 3087:	if (c == ':') {
    #####: 3088:	    if (hassep && !sep) {
    #####: 3089:		freecvdef(ret);
    #####: 3090:		if (xor) freearray(xor);
    #####: 3091:		zwarnnam(nam, "no value with argument with empty separator allowed");
    #####: 3092:		return NULL;
        -: 3093:	    }
    #####: 3094:	    if (*++p == ':') {
    #####: 3095:		p++;
    #####: 3096:		vtype = CVV_OPT;
        -: 3097:	    } else
    #####: 3098:		vtype = CVV_ARG;
    #####: 3099:	    arg = parse_caarg(0, 0, 0, 0, name, &p, NULL);
        -: 3100:	} else {
    #####: 3101:	    vtype = CVV_NOARG;
    #####: 3102:	    arg = NULL;
        -: 3103:	}
    #####: 3104:	if (!multi) {
    #####: 3105:	    if (!xor) {
    #####: 3106:		xor = (char **) zalloc(2 * sizeof(char *));
    #####: 3107:		xor[1] = NULL;
        -: 3108:	    }
    #####: 3109:	    xor[xnum] = ztrdup(name);
        -: 3110:	}
    #####: 3111:	*valp = val = (Cvval) zalloc(sizeof(*val));
    #####: 3112:	valp = &((*valp)->next);
        -: 3113:
    #####: 3114:	val->next = NULL;
    #####: 3115:	val->name = ztrdup(name);
    #####: 3116:	val->descr = ztrdup(descr);
    #####: 3117:	val->xor = xor;
    #####: 3118:	val->type = vtype;
    #####: 3119:	val->arg = arg;
        -: 3120:    }
    #####: 3121:    return ret;
        -: 3122:}
        -: 3123:
        -: 3124:/* Get the definition from the cache or newly built. */
        -: 3125:
        -: 3126:static Cvdef
    #####: 3127:get_cvdef(char *nam, char **args)
        -: 3128:{
        -: 3129:    Cvdef *p, *min, new;
    #####: 3130:    int i, na = arrlen(args);
        -: 3131:
    #####: 3132:    for (i = MAX_CVCACHE, p = cvdef_cache, min = NULL; *p && i--; p++)
    #####: 3133:	if (*p && na == (*p)->ndefs && arrcmp(args, (*p)->defs)) {
    #####: 3134:	    (*p)->lastt = time(0);
        -: 3135:
    #####: 3136:	    return *p;
    #####: 3137:	} else if (!min || !*p || (*p)->lastt < (*min)->lastt)
    #####: 3138:	    min = p;
    #####: 3139:    if (i > 0)
    #####: 3140:	min = p;
    #####: 3141:    if ((new = parse_cvdef(nam, args))) {
    #####: 3142:	freecvdef(*min);
    #####: 3143:	*min = new;
        -: 3144:    }
    #####: 3145:    return new;
        -: 3146:}
        -: 3147:
        -: 3148:/* Get the definition for a value. */
        -: 3149:
        -: 3150:static Cvval
    #####: 3151:cv_get_val(Cvdef d, char *name)
        -: 3152:{
        -: 3153:    Cvval p;
        -: 3154:
    #####: 3155:    for (p = d->vals; p; p = p->next)
    #####: 3156:	if (!strcmp(name, p->name))
    #####: 3157:	    return p;
        -: 3158:
    #####: 3159:    return NULL;
        -: 3160:}
        -: 3161:
        -: 3162:static Cvval
    #####: 3163:cv_quote_get_val(Cvdef d, char *name)
        -: 3164:{
        -: 3165:    int ne;
        -: 3166:
        -: 3167:    /* remove quotes */
    #####: 3168:    name = dupstring(name);
    #####: 3169:    ne = noerrs;
    #####: 3170:    noerrs = 2;
    #####: 3171:    parse_subst_string(name);
    #####: 3172:    noerrs = ne;
    #####: 3173:    remnulargs(name);
    #####: 3174:    untokenize(name);
        -: 3175:
    #####: 3176:    return cv_get_val(d, name);
        -: 3177:}
        -: 3178:
        -: 3179:/* Handle a xor list. */
        -: 3180:
        -: 3181:static void
    #####: 3182:cv_inactive(Cvdef d, char **xor)
        -: 3183:{
    #####: 3184:    if (xor) {
        -: 3185:	Cvval val;
        -: 3186:
    #####: 3187:	for (; *xor; xor++)
    #####: 3188:	    if ((val = cv_get_val(d, *xor)))
    #####: 3189:		val->active = 0;
        -: 3190:    }
    #####: 3191:}
        -: 3192:
        -: 3193:/* Parse state. */
        -: 3194:
        -: 3195:struct cvstate {
        -: 3196:    Cvdef d;
        -: 3197:    Caarg def;
        -: 3198:    Cvval val;
        -: 3199:    LinkList vals;
        -: 3200:};
        -: 3201:
        -: 3202:static struct cvstate cv_laststate;
        -: 3203:static int cv_parsed = 0, cv_alloced = 0;
        -: 3204:
        -: 3205:/* Get the next value in the string.  Return it's definition and update the
        -: 3206: * sp pointer to point to the end of the value (plus argument, if any).
        -: 3207: * If there is no next value, the string pointer is set to null.  In any
        -: 3208: * case ap will point to the beginning of the argument or will be a null
        -: 3209: * pointer if there is no argument.
        -: 3210: */
        -: 3211:
        -: 3212:static Cvval
    #####: 3213:cv_next(Cvdef d, char **sp, char **ap)
        -: 3214:{
    #####: 3215:    Cvval r = NULL;
    #####: 3216:    char *s = *sp;
        -: 3217:
    #####: 3218:    if (!*s) {
    #####: 3219:        *sp = *ap = NULL;
        -: 3220:
    #####: 3221:        return NULL;
        -: 3222:    }
    #####: 3223:    if ((d->hassep && !d->sep) || !d->argsep) {
    #####: 3224:        char sav, ec, *v = s, *os;
        -: 3225:
    #####: 3226:        ec = ((d->hassep && d->sep) ? d->sep : d->argsep);
        -: 3227:
        -: 3228:        do {
    #####: 3229:            sav = *++s;
    #####: 3230:            *s = '\0';
    #####: 3231:            if ((r = cv_quote_get_val(d, v))) {
    #####: 3232:                *s = sav;
        -: 3233:
    #####: 3234:                break;
        -: 3235:            }
    #####: 3236:            *s = sav;
    #####: 3237:        } while (*s && *s != ec);
        -: 3238:
    #####: 3239:        os = s;
        -: 3240:
    #####: 3241:        if (d->hassep && d->sep) {
    #####: 3242:            if ((s = strchr(s, d->sep)))
    #####: 3243:                *sp = s + 1;
        -: 3244:            else
    #####: 3245:                *sp = NULL;
        -: 3246:        } else
    #####: 3247:            *sp = s;
    #####: 3248:        if (d->argsep && *os == d->argsep) {
    #####: 3249:            *ap = os + 1;
    #####: 3250:            *sp = NULL;
    #####: 3251:        } else if (r && r->type != CVV_NOARG)
    #####: 3252:            *ap = os;
        -: 3253:        else
    #####: 3254:            *ap = NULL;
        -: 3255:
    #####: 3256:        return r;
        -: 3257:
    #####: 3258:    } else if (d->hassep) {
    #####: 3259:        char *ns = strchr(s, d->sep), *as = 0, *sap, sav = 0;
    #####: 3260:        int skip = 0;
        -: 3261:
    #####: 3262:        if (d->argsep && (as = strchr(s, d->argsep)) && (!ns || as <= ns)) {
    #####: 3263:            *ap = as + 1;
    #####: 3264:            ns = strchr(as + 1, d->sep);
    #####: 3265:            skip = 1;
    #####: 3266:            sap = as;
        -: 3267:        } else {
    #####: 3268:            *ap = NULL;
    #####: 3269:            sap = ns;
        -: 3270:        }
    #####: 3271:        if (sap) {
    #####: 3272:            sav = *sap;
    #####: 3273:            *sap = '\0';
        -: 3274:        }
    #####: 3275:        if ((!(r = cv_quote_get_val(d, s)) || r->type == CVV_NOARG) && skip)
    #####: 3276:            ns = as;
        -: 3277:
    #####: 3278:        if (sap)
    #####: 3279:            *sap = sav;
        -: 3280:
    #####: 3281:        *sp = ((!ns || (ns == as && r && r->type != CVV_NOARG)) ? NULL : ns + 1);
        -: 3282:
    #####: 3283:        return r;
        -: 3284:    } else {
    #####: 3285:        char *as = strchr(s, d->argsep), *sap, sav = 0;
        -: 3286:
    #####: 3287:        *sp = NULL;
        -: 3288:
    #####: 3289:        if (as) {
    #####: 3290:            *ap = as + 1;
    #####: 3291:            sap = as;
    #####: 3292:            sav = *as;
    #####: 3293:            *sap = '\0';
        -: 3294:        } else
    #####: 3295:            *ap = sap = NULL;
        -: 3296:
    #####: 3297:        r = cv_quote_get_val(d, s);
        -: 3298:
    #####: 3299:        if (sap)
    #####: 3300:            *sap = sav;
        -: 3301:
    #####: 3302:        return r;
        -: 3303:    }
        -: 3304:}
        -: 3305:
        -: 3306:/* Parse the current word. */
        -: 3307:
        -: 3308:static void
    #####: 3309:cv_parse_word(Cvdef d)
        -: 3310:{
        -: 3311:    Cvval val;
        -: 3312:    struct cvstate state;
    #####: 3313:    char *str, *arg = NULL, *pign = compprefix;
    #####: 3314:    int nosfx = 0;
        -: 3315:
    #####: 3316:    if (cv_alloced)
    #####: 3317:	freelinklist(cv_laststate.vals, freestr);
        -: 3318:
    #####: 3319:    for (val = d->vals; val; val = val->next)
    #####: 3320:	val->active = 1;
        -: 3321:
    #####: 3322:    state.d = d;
    #####: 3323:    state.def = NULL;
    #####: 3324:    state.val = NULL;
    #####: 3325:    state.vals = (LinkList) znewlinklist();
        -: 3326:
    #####: 3327:    cv_alloced = 1;
        -: 3328:
    #####: 3329:    if (d->words && compwords[0]) {
        -: 3330:        int i;
        -: 3331:
    #####: 3332:        for (i = 1; compwords[i]; i++)
    #####: 3333:            if (i != compcurrent - 1)
    #####: 3334:                for (str = compwords[i]; str && *str; ) {
    #####: 3335:                    if ((val = cv_next(d, &str, &arg))) {
    #####: 3336:                        zaddlinknode(state.vals, ztrdup(val->name));
    #####: 3337:                        if (arg) {
    #####: 3338:                            char sav = '\0';
        -: 3339:
    #####: 3340:                            if (str) {
    #####: 3341:                                sav = str[-1];
    #####: 3342:                                str[-1] = '\0';
        -: 3343:                            }
    #####: 3344:                            zaddlinknode(state.vals, ztrdup(arg));
    #####: 3345:                            if (str)
    #####: 3346:                                str[-1] = sav;
        -: 3347:                        } else
    #####: 3348:                            zaddlinknode(state.vals, ztrdup(""));
        -: 3349:
    #####: 3350:                        if (i + 1 < compcurrent)
    #####: 3351:                            cv_inactive(d, val->xor);
        -: 3352:                    }
        -: 3353:                }
        -: 3354:
    #####: 3355:        val = NULL;
    #####: 3356:        arg = NULL;
        -: 3357:    }
    #####: 3358:    for (str = compprefix; str && *str; ) {
    #####: 3359:        if ((val = cv_next(d, &str, &arg))) {
    #####: 3360:            zaddlinknode(state.vals, ztrdup(val->name));
    #####: 3361:            if (arg) {
    #####: 3362:                if (str) {
    #####: 3363:                    char sav = str[-1];
        -: 3364:
    #####: 3365:                    str[-1] = '\0';
    #####: 3366:                    zaddlinknode(state.vals, ztrdup(arg));
    #####: 3367:                    str[-1] = sav;
        -: 3368:                } else {
    #####: 3369:                    zaddlinknode(state.vals, tricat(arg, compsuffix, ""));
    #####: 3370:                    nosfx = 1;
        -: 3371:                }
        -: 3372:            } else
    #####: 3373:                zaddlinknode(state.vals, ztrdup(""));
        -: 3374:
    #####: 3375:            cv_inactive(d, val->xor);
        -: 3376:
    #####: 3377:            if (str)
    #####: 3378:                pign = str;
        -: 3379:            else
    #####: 3380:                val->active = 1;
        -: 3381:        }
        -: 3382:    }
    #####: 3383:    state.val = val;
    #####: 3384:    if (val && arg && !str)
    #####: 3385:        state.def = val->arg;
        -: 3386:
    #####: 3387:    if (!nosfx && d->hassep) {
    #####: 3388:        int ign = 0;
    #####: 3389:        char *more = NULL;
        -: 3390:
    #####: 3391:        ignore_prefix(pign - compprefix);
        -: 3392:
    #####: 3393:        if (!d->sep && (!val || val->type == CVV_NOARG)) {
    #####: 3394:            ign = strlen(compsuffix);
    #####: 3395:            more = compsuffix;
        -: 3396:        } else {
    #####: 3397:            if (d->sep) {
    #####: 3398:                char *ns = strchr(compsuffix, d->sep), *as;
        -: 3399:
    #####: 3400:                if (d->argsep && (as = strchr(compsuffix, d->argsep)) &&
    #####: 3401:                    (!ns || as <= ns)) {
    #####: 3402:                    ign = strlen(as);
        -: 3403:                } else
    #####: 3404:                    ign = (ns ? strlen(ns) : 0);
        -: 3405:
    #####: 3406:                more = (ns ? ns + 1 : NULL);
    #####: 3407:            } else if (d->argsep) {
        -: 3408:                char *as;
        -: 3409:
    #####: 3410:                if ((as = strchr(compsuffix, d->argsep)))
    #####: 3411:                    ign = strlen(as);
        -: 3412:            }
        -: 3413:        }
    #####: 3414:        more = dupstring(more);
        -: 3415:
    #####: 3416:        if (ign)
    #####: 3417:            ignore_suffix(ign);
        -: 3418:
    #####: 3419:        while (more && *more) {
    #####: 3420:            if ((val = cv_next(d, &more, &arg))) {
    #####: 3421:                zaddlinknode(state.vals, ztrdup(val->name));
    #####: 3422:                if (arg) {
    #####: 3423:                    if (more) {
    #####: 3424:                        char sav = more[-1];
        -: 3425:
    #####: 3426:                        more[-1] = '\0';
    #####: 3427:                        zaddlinknode(state.vals, ztrdup(arg));
    #####: 3428:                        more[-1] = sav;
        -: 3429:                    } else {
    #####: 3430:                        zaddlinknode(state.vals, tricat(arg, compsuffix, ""));
    #####: 3431:                        nosfx = 1;
        -: 3432:                    }
        -: 3433:                } else
    #####: 3434:                    zaddlinknode(state.vals, ztrdup(""));
        -: 3435:
    #####: 3436:                cv_inactive(d, val->xor);
        -: 3437:            }
        -: 3438:        }
    #####: 3439:    } else if (arg)
    #####: 3440:        ignore_prefix(arg - compprefix);
        -: 3441:    else
    #####: 3442:        ignore_prefix(pign - compprefix);
        -: 3443:
    #####: 3444:    memcpy(&cv_laststate, &state, sizeof(state));
    #####: 3445:}
        -: 3446:
        -: 3447:static int
    #####: 3448:bin_compvalues(char *nam, char **args, UNUSED(Options ops), UNUSED(int func))
        -: 3449:{
        -: 3450:    int min, max, n;
        -: 3451:
    #####: 3452:    if (incompfunc != 1) {
    #####: 3453:	zwarnnam(nam, "can only be called from completion function");
    #####: 3454:	return 1;
        -: 3455:    }
    #####: 3456:    if (args[0][0] != '-' || !args[0][1] || args[0][2]) {
    #####: 3457:	zwarnnam(nam, "invalid argument: %s", args[0]);
    #####: 3458:	return 1;
        -: 3459:    }
    #####: 3460:    if (args[0][1] != 'i' && !cv_parsed) {
    #####: 3461:	zwarnnam(nam, "no parsed state");
    #####: 3462:	return 1;
        -: 3463:    }
    #####: 3464:    switch (args[0][1]) {
    #####: 3465:    case 'i': min = 2; max = -1; break;
    #####: 3466:    case 'D': min = 2; max =  2; break;
    #####: 3467:    case 'C': min = 1; max =  1; break;
    #####: 3468:    case 'V': min = 3; max =  3; break;
    #####: 3469:    case 's': min = 1; max =  1; break;
    #####: 3470:    case 'S': min = 1; max =  1; break;
    #####: 3471:    case 'd': min = 1; max =  1; break;
    #####: 3472:    case 'L': min = 3; max =  4; break;
    #####: 3473:    case 'v': min = 1; max =  1; break;
    #####: 3474:    default:
    #####: 3475:	zwarnnam(nam, "invalid option: %s", args[0]);
    #####: 3476:	return 1;
        -: 3477:    }
    #####: 3478:    n = arrlen(args) - 1;
    #####: 3479:    if (n < min) {
    #####: 3480:	zwarnnam(nam, "not enough arguments");
    #####: 3481:	return 1;
    #####: 3482:    } else if (max >= 0 && n > max) {
    #####: 3483:	zwarnnam(nam, "too many arguments");
    #####: 3484:	return 1;
        -: 3485:    }
    #####: 3486:    switch (args[0][1]) {
    #####: 3487:    case 'i':
        -: 3488:        /* This initialises the internal data structures.  The arguments are
        -: 3489:         * just the arguments that were given to _values itself. */
        -: 3490:	{
    #####: 3491:	    Cvdef def = get_cvdef(nam, args + 1);
    #####: 3492:	    int cvp = cv_parsed;
        -: 3493:
    #####: 3494:	    cv_parsed = 0;
        -: 3495:
    #####: 3496:	    if (!def)
    #####: 3497:		return 1;
        -: 3498:
    #####: 3499:	    cv_parsed = cvp;
    #####: 3500:	    cv_parse_word(def);
    #####: 3501:	    cv_parsed = 1;
        -: 3502:
    #####: 3503:	    return 0;
        -: 3504:	}
        -: 3505:
    #####: 3506:    case 'D':
        -: 3507:        /* This returns the description and action to use if we are at
        -: 3508:         * a place where some action has to be used at all.  In that case
        -: 3509:         * zero is returned and non-zero otherwise. */
        -: 3510:	{
    #####: 3511:	    Caarg arg = cv_laststate.def;
        -: 3512:
    #####: 3513:	    if (arg) {
    #####: 3514:		setsparam(args[1], ztrdup(arg->descr));
    #####: 3515:		setsparam(args[2], ztrdup(arg->action));
        -: 3516:
    #####: 3517:		return 0;
        -: 3518:	    }
    #####: 3519:	    return 1;
        -: 3520:	}
    #####: 3521:    case 'C':
        -: 3522:        /* This returns the sub-context (i.e.: the tag) to use when executing
        -: 3523:         * an action. */
        -: 3524:	{
    #####: 3525:	    Caarg arg = cv_laststate.def;
        -: 3526:
    #####: 3527:	    if (arg) {
    #####: 3528:		setsparam(args[1], ztrdup(arg->opt));
        -: 3529:
    #####: 3530:		return 0;
        -: 3531:	    }
    #####: 3532:	    return 1;
        -: 3533:	}
    #####: 3534:    case 'V':
        -: 3535:        /* This is what -O is for comparguments: it returns (in three arrays)
        -: 3536:         * the values for values without arguments, with arguments and with
        -: 3537:         * optional arguments (so that we can get the auto-suffixes right).
        -: 3538:         * As for comparguments, the strings returned are usable for _describe. */
        -: 3539:	{
    #####: 3540:	    LinkList noarg = newlinklist();
    #####: 3541:	    LinkList arg = newlinklist();
    #####: 3542:	    LinkList opt = newlinklist(), l;
        -: 3543:	    Cvval p;
        -: 3544:	    char *str;
        -: 3545:
    #####: 3546:	    for (p = cv_laststate.d->vals; p; p = p->next) {
    #####: 3547:		if (p->active) {
    #####: 3548:		    switch (p->type) {
    #####: 3549:		    case CVV_NOARG: l = noarg; break;
    #####: 3550:		    case CVV_ARG:   l = arg;   break;
    #####: 3551:		    default:        l = opt;   break;
        -: 3552:		    }
    #####: 3553:		    if (p->descr) {
    #####: 3554:			int len = strlen(p->name) + strlen(p->descr) + 2;
        -: 3555:
    #####: 3556:			str = (char *) zhalloc(len);
    #####: 3557:			strcpy(str, p->name);
    #####: 3558:			strcat(str, ":");
    #####: 3559:			strcat(str, p->descr);
        -: 3560:		    } else
    #####: 3561:			str = p->name;
    #####: 3562:		    addlinknode(l, str);
        -: 3563:		}
        -: 3564:	    }
    #####: 3565:	    set_list_array(args[1], noarg);
    #####: 3566:	    set_list_array(args[2], arg);
    #####: 3567:	    set_list_array(args[3], opt);
        -: 3568:
    #####: 3569:	    return 0;
        -: 3570:	}
    #####: 3571:    case 's':
        -: 3572:        /* This returns the value separator, if any, and sets the return
        -: 3573:         * value to say if there is such a separator. */
    #####: 3574:	if (cv_laststate.d->hassep) {
        -: 3575:	    char tmp[2];
        -: 3576:
    #####: 3577:	    tmp[0] = cv_laststate.d->sep;
    #####: 3578:	    tmp[1] = '\0';
    #####: 3579:	    setsparam(args[1], ztrdup(tmp));
        -: 3580:
    #####: 3581:	    return 0;
        -: 3582:	}
    #####: 3583:	return 1;
    #####: 3584:    case 'S':
        -: 3585:        /* Like -s, but for the separator between values and their arguments. */
        -: 3586:	{
        -: 3587:	    char tmp[2];
        -: 3588:
    #####: 3589:	    tmp[0] = cv_laststate.d->argsep;
    #####: 3590:	    tmp[1] = '\0';
    #####: 3591:	    setsparam(args[1], ztrdup(tmp));
        -: 3592:	}
    #####: 3593:	return 0;
    #####: 3594:    case 'd':
        -: 3595:        /* This returns the description string (first argument to _values)
        -: 3596:         * which is passed down to _describe. */
    #####: 3597:	setsparam(args[1], ztrdup(cv_laststate.d->descr));
    #####: 3598:	return 0;
    #####: 3599:    case 'L':
        -: 3600:        /* Almost the same as for comparguments.  This gets a value name
        -: 3601:         * and returns the description and action of its first argument, if
        -: 3602:         * any.  The rest (prefix matching) is in _values.  Return non-zero
        -: 3603:         * if there is no such option. */
        -: 3604:	{
    #####: 3605:	    Cvval val = cv_get_val(cv_laststate.d, args[1]);
        -: 3606:
    #####: 3607:	    if (val && val->arg) {
    #####: 3608:		setsparam(args[2], ztrdup(val->arg->descr));
    #####: 3609:		setsparam(args[3], ztrdup(val->arg->action));
        -: 3610:
    #####: 3611:		if (args[4])
    #####: 3612:		    setsparam(args[4], ztrdup(val->name));
        -: 3613:
    #####: 3614:		return 0;
        -: 3615:	    }
    #####: 3616:	    return 1;
        -: 3617:	}
    #####: 3618:    case 'v':
        -: 3619:        /* Again, as for comparguments.  This returns the values and their
        -: 3620:         * arguments as an array which will be stored in val_args in _values. */
    #####: 3621:	if (cv_laststate.vals) {
        -: 3622:	    char **ret;
        -: 3623:
    #####: 3624:	    ret = zlinklist2array(cv_laststate.vals, 1);
    #####: 3625:	    sethparam(args[1], ret);
        -: 3626:
    #####: 3627:	    return 0;
        -: 3628:	}
    #####: 3629:	return 1;
        -: 3630:    }
    #####: 3631:    return 1;
        -: 3632:}
        -: 3633:
        -: 3634:static char *
    #####: 3635:comp_quote(char *str, int prefix)
        -: 3636:{
        -: 3637:    int x;
        -: 3638:    char *ret;
        -: 3639:
    #####: 3640:    if ((x = (prefix && *str == '=')))
    #####: 3641:	*str = 'x';
        -: 3642:
    #####: 3643:    ret = quotestring(str, *compqstack);
        -: 3644:
    #####: 3645:    if (x)
    #####: 3646:	*str = *ret = '=';
        -: 3647:
    #####: 3648:    return ret;
        -: 3649:}
        -: 3650:
        -: 3651:static int
    #####: 3652:bin_compquote(char *nam, char **args, Options ops, UNUSED(int func))
        -: 3653:{
        -: 3654:    char *name;
        -: 3655:    struct value vbuf;
        -: 3656:    Value v;
        -: 3657:
    #####: 3658:    if (incompfunc != 1) {
    #####: 3659:	zwarnnam(nam, "can only be called from completion function");
    #####: 3660:	return 1;
        -: 3661:    }
        -: 3662:    /* Anything to do? */
        -: 3663:
    #####: 3664:    if (!compqstack || !*compqstack)
    #####: 3665:	return 0;
        -: 3666:
        -: 3667:    /* For all parameters given... */
        -: 3668:
    #####: 3669:    while ((name = *args++)) {
    #####: 3670:	name = dupstring(name);
    #####: 3671:	queue_signals();
    #####: 3672:	if ((v = getvalue(&vbuf, &name, 0))) {
    #####: 3673:	    switch (PM_TYPE(v->pm->node.flags)) {
    #####: 3674:	    case PM_SCALAR:
    #####: 3675:		setstrvalue(v, ztrdup(comp_quote(getstrvalue(v), 
    #####: 3676:						 OPT_ISSET(ops,'p'))));
    #####: 3677:		break;
    #####: 3678:	    case PM_ARRAY:
        -: 3679:		{
    #####: 3680:		    char **val = v->pm->gsu.a->getfn(v->pm);
    #####: 3681:		    char **new = (char **) zalloc((arrlen(val) + 1) *
        -: 3682:						  sizeof(char *));
    #####: 3683:		    char **p = new;
        -: 3684:
    #####: 3685:		    for (; *val; val++, p++)
    #####: 3686:			*p = ztrdup(comp_quote(*val, OPT_ISSET(ops,'p')));
    #####: 3687:		    *p = NULL;
        -: 3688:
    #####: 3689:		    setarrvalue(v, new);
        -: 3690:		}
    #####: 3691:		break;
    #####: 3692:	    default:
    #####: 3693:		zwarnnam(nam, "invalid parameter type: %s", args[-1]);
        -: 3694:	    }
        -: 3695:	} else
    #####: 3696:	    zwarnnam(nam, "unknown parameter: %s", args[-1]);
    #####: 3697:	unqueue_signals();
        -: 3698:    }
    #####: 3699:    return 0;
        -: 3700:}
        -: 3701:
        -: 3702:/* Tags stuff. */
        -: 3703:
        -: 3704:typedef struct ctags *Ctags;
        -: 3705:typedef struct ctset *Ctset;
        -: 3706:
        -: 3707:/* A bunch of tag sets. */
        -: 3708:
        -: 3709:struct ctags {
        -: 3710:    char **all;			/* all tags offered */
        -: 3711:    char *context;		/* the current context */
        -: 3712:    int init;			/* not yet used */
        -: 3713:    Ctset sets;			/* the tag sets */
        -: 3714:};
        -: 3715:
        -: 3716:/* A tag set. */
        -: 3717:
        -: 3718:struct ctset {
        -: 3719:    Ctset next;
        -: 3720:    char **tags;		/* the tags */
        -: 3721:    char *tag;			/* last tag checked for -A */
        -: 3722:    char **ptr;			/* ptr into tags for -A */
        -: 3723:};
        -: 3724:
        -: 3725:/* Array of tag-set infos. Index is the locallevel. */
        -: 3726:
        -: 3727:#define MAX_TAGS 256
        -: 3728:static Ctags comptags[MAX_TAGS];
        -: 3729:
        -: 3730:/* locallevel at last comptags -i */
        -: 3731:
        -: 3732:static int lasttaglevel;
        -: 3733:
        -: 3734:static void
      367: 3735:freectset(Ctset s)
        -: 3736:{
        -: 3737:    Ctset n;
        -: 3738:
     1034: 3739:    while (s) {
      300: 3740:	n = s->next;
        -: 3741:
      300: 3742:	if (s->tags)
      300: 3743:	    freearray(s->tags);
      300: 3744:	zsfree(s->tag);
      300: 3745:	zfree(s, sizeof(*s));
        -: 3746:
      300: 3747:	s = n;
        -: 3748:    }
      367: 3749:}
        -: 3750:
        -: 3751:static void
      259: 3752:freectags(Ctags t)
        -: 3753:{
      259: 3754:    if (t) {
      259: 3755:	if (t->all)
      259: 3756:	    freearray(t->all);
      259: 3757:	zsfree(t->context);
      259: 3758:	freectset(t->sets);
      259: 3759:	zfree(t, sizeof(*t));
        -: 3760:    }
      259: 3761:}
        -: 3762:
        -: 3763:/* Set the tags for the current local level. */
        -: 3764:
        -: 3765:static void
      261: 3766:settags(int level, char **tags)
        -: 3767:{
        -: 3768:    Ctags t;
        -: 3769:
      261: 3770:    if (comptags[level])
      259: 3771:	freectags(comptags[level]);
        -: 3772:
      261: 3773:    comptags[level] = t = (Ctags) zalloc(sizeof(*t));
        -: 3774:
      261: 3775:    t->all = zarrdup(tags + 1);
      261: 3776:    t->context = ztrdup(*tags);
      261: 3777:    t->sets = NULL;
      261: 3778:    t->init = 1;
      261: 3779:}
        -: 3780:
        -: 3781:/* Check if an array contains a string. */
        -: 3782:
        -: 3783:/**/
        -: 3784:static int
     1220: 3785:arrcontains(char **a, char *s, int colon)
        -: 3786:{
        -: 3787:    char *p, *q;
        -: 3788:
     2935: 3789:    while (*a) {
     1364: 3790:	if (colon) {
     5291: 3791:	    for (p = s, q = *a++; *p && *q && *p != ':' && *q != ':'; p++, q++)
     4808: 3792:		if (*p != *q)
      153: 3793:		    break;
      636: 3794:	    if ((!*p || *p == ':') && (!*q || *q == ':'))
      483: 3795:		return 1;
      728: 3796:	} else if (!strcmp(*a++, s))
      386: 3797:	    return 1;
        -: 3798:    }
      351: 3799:    return 0;
        -: 3800:}
        -: 3801:
        -: 3802:static int
     1499: 3803:bin_comptags(char *nam, char **args, UNUSED(Options ops), UNUSED(int func))
        -: 3804:{
        -: 3805:    int min, max, n, level;
        -: 3806:
     1499: 3807:    if (incompfunc != 1) {
    #####: 3808:	zwarnnam(nam, "can only be called from completion function");
    #####: 3809:	return 1;
        -: 3810:    }
     2998: 3811:    if (args[0][0] != '-' || !args[0][1] ||
     1499: 3812:	(args[0][2] && (args[0][2] != '-' || args[0][3]))) {
    #####: 3813:	zwarnnam(nam, "invalid argument: %s", args[0]);
    #####: 3814:	return 1;
        -: 3815:    }
     1499: 3816:    level = locallevel - (args[0][2] ? 1 : 0);
     1499: 3817:    if (level >= MAX_TAGS) {
    #####: 3818:	zwarnnam(nam, "nesting level too deep");
    #####: 3819:	return 1;
        -: 3820:    }
     1499: 3821:    if (args[0][1] != 'i' && args[0][1] != 'I' && !comptags[level]) {
    #####: 3822:	zwarnnam(nam, "no tags registered");
    #####: 3823:	return 1;
        -: 3824:    }
     1499: 3825:    switch (args[0][1]) {
      261: 3826:    case 'i': min = 2; max = -1; break;
    #####: 3827:    case 'C': min = 1; max =  1; break;
      261: 3828:    case 'T': min = 0; max =  0; break;
      340: 3829:    case 'N': min = 0; max =  0; break;
      277: 3830:    case 'R': min = 1; max =  1; break;
    #####: 3831:    case 'S': min = 1; max =  1; break;
      360: 3832:    case 'A': min = 2; max =  3; break;
    #####: 3833:    default:
    #####: 3834:	zwarnnam(nam, "invalid option: %s", args[0]);
    #####: 3835:	return 1;
        -: 3836:    }
     1499: 3837:    n = arrlen(args) - 1;
     1499: 3838:    if (n < min) {
    #####: 3839:	zwarnnam(nam, "not enough arguments");
    #####: 3840:	return 1;
     1499: 3841:    } else if (max >= 0 && n > max) {
    #####: 3842:	zwarnnam(nam, "too many arguments");
    #####: 3843:	return 1;
        -: 3844:    }
     1499: 3845:    switch (args[0][1]) {
      261: 3846:    case 'i':
      261: 3847:	settags(level, args + 1);
      261: 3848:	lasttaglevel = level;
      261: 3849:	break;
    #####: 3850:    case 'C':
    #####: 3851:	setsparam(args[1], ztrdup(comptags[level]->context));
    #####: 3852:	break;
      261: 3853:    case 'T':
      261: 3854:	return !comptags[level]->sets;
      340: 3855:    case 'N':
        -: 3856:	{
        -: 3857:	    Ctset s;
        -: 3858:
      340: 3859:	    if (comptags[level]->init)
      232: 3860:		comptags[level]->init = 0;
      108: 3861:	    else if ((s = comptags[level]->sets)) {
      108: 3862:		comptags[level]->sets = s->next;
      108: 3863:		s->next = NULL;
      108: 3864:		freectset(s);
        -: 3865:	    }
      340: 3866:	    return !comptags[level]->sets;
        -: 3867:	}
      277: 3868:    case 'R':
        -: 3869:	{
        -: 3870:	    Ctset s;
        -: 3871:
      554: 3872:	    return !((s = comptags[level]->sets) &&
      277: 3873:		     arrcontains(s->tags, args[1], 1));
        -: 3874:	}
      360: 3875:    case 'A':
        -: 3876:	{
        -: 3877:	    Ctset s;
        -: 3878:
      360: 3879:	    if (comptags[level] && (s = comptags[level]->sets)) {
      360: 3880:		char **q, *v = NULL;
      360: 3881:		int l = strlen(args[1]);
        -: 3882:
      360: 3883:		if (!s->tag || strcmp(s->tag, args[1])) {
      180: 3884:		    zsfree(s->tag);
      180: 3885:		    s->tag = ztrdup(args[1]);
      180: 3886:		    s->ptr = s->tags;
        -: 3887:		}
      368: 3888:		for (q = s->ptr; *q; q++) {
      188: 3889:		    if (strpfx(args[1], *q)) {
      180: 3890:			if (!(*q)[l]) {
      180: 3891:			    v = *q;
      180: 3892:			    break;
    #####: 3893:			} else if ((*q)[l] == ':') {
    #####: 3894:			    v = (*q) + l + 1;
    #####: 3895:			    break;
        -: 3896:			}
        -: 3897:		    }
        -: 3898:		}
      360: 3899:		if (!v) {
      180: 3900:		    zsfree(s->tag);
      180: 3901:		    s->tag = NULL;
      180: 3902:		    return 1;
        -: 3903:		}
      180: 3904:		s->ptr = q + 1;
      180: 3905:		setsparam(args[2], ztrdup(*v == '-' ? dyncat(args[1], v) : v));
      180: 3906:		if (args[3]) {
      180: 3907:		    char *r = dupstring(*q), *p;
        -: 3908:
      180: 3909:		    for (p = r + (v - *q); *p && *p != ':'; p++);
      180: 3910:		    *p = '\0';
        -: 3911:
      180: 3912:		    setsparam(args[3], ztrdup(r));
        -: 3913:		}
      180: 3914:		return 0;
        -: 3915:	    }
    #####: 3916:	    return 1;
        -: 3917:	}
    #####: 3918:    case 'S':
    #####: 3919:	if (comptags[level]->sets) {
        -: 3920:	    char **ret;
        -: 3921:
    #####: 3922:	    ret = zarrdup(comptags[level]->sets->tags);
    #####: 3923:	    setaparam(args[1], ret);
        -: 3924:	} else
    #####: 3925:	    return 1;
        -: 3926:
    #####: 3927:	break;
        -: 3928:    }
      261: 3929:    return 0;
        -: 3930:}
        -: 3931:
        -: 3932:static int
      605: 3933:bin_comptry(char *nam, char **args, UNUSED(Options ops), UNUSED(int func))
        -: 3934:{
      605: 3935:    if (incompfunc != 1) {
    #####: 3936:	zwarnnam(nam, "can only be called from completion function");
    #####: 3937:	return 1;
        -: 3938:    }
      605: 3939:    if (!lasttaglevel || !comptags[lasttaglevel]) {
    #####: 3940:	zwarnnam(nam, "no tags registered");
    #####: 3941:	return 1;
        -: 3942:    }
      605: 3943:    if (*args) {
      605: 3944:	if (!strcmp(*args, "-m")) {
      344: 3945:	    char *s, *p, *q, *c, **all = comptags[lasttaglevel]->all;
      344: 3946:	    LinkList list = newlinklist();
      344: 3947:	    int num = 0;
        -: 3948:	    Ctset set;
        -: 3949:
     1032: 3950:	    while ((s = *++args)) {
     1376: 3951:		while (*s) {
     1376: 3952:		    while (*s && iblank(*s))
    #####: 3953:			s++;
     8256: 3954:		    for (p = q = s, c = NULL; *s && !inblank(*s); s++) {
     7568: 3955:			if (!c && *s == ':')
    #####: 3956:			    c = p;
     7568: 3957:			if (*s == '\\' && s[1])
    #####: 3958:			    s++;
     7568: 3959:			*p++ = *s;
        -: 3960:		    }
      688: 3961:		    if (*s)
      344: 3962:			s++;
      688: 3963:		    *p = '\0';
      688: 3964:		    if (*q) {
        -: 3965:			char *qq, *qqq;
        -: 3966:
      688: 3967:			queue_signals();
        -: 3968:
      688: 3969:			if (c)
    #####: 3970:			    *c = '\0';
        -: 3971:
      688: 3972:			qqq = qq = dupstring(q);
     8944: 3973:			while (*qqq) {
     7568: 3974:			    if (*qqq == '\\' && qqq[1])
    #####: 3975:				qqq++;
     7568: 3976:			    else if (*qqq == '{')
    #####: 3977:				*qqq = Inbrace;
     7568: 3978:			    else if (*qqq == '}')
    #####: 3979:				*qqq = Outbrace;
     7568: 3980:			    else if (*qqq == ',')
    #####: 3981:				*qqq = Comma;
     7568: 3982:			    qqq++;
        -: 3983:			}
      688: 3984:			tokenize(qq);
     1032: 3985:			if (haswilds(qq) || hasbraces(qq)) {
        -: 3986:			    Patprog prog;
        -: 3987:			    LinkNode bnode, node;
      344: 3988:			    LinkList blist = newlinklist();
        -: 3989:
      344: 3990:			    addlinknode(blist, qq);
      688: 3991:			    for (bnode = firstnode(blist); bnode; incnode(bnode))
      688: 3992:				while (hasbraces(getdata(bnode)))
    #####: 3993:				    xpandbraces(blist, &bnode);
        -: 3994:
      688: 3995:			    for (bnode = firstnode(blist); bnode; incnode(bnode)) {
      344: 3996:				qq = (char *) getdata(bnode);
      344: 3997:				if ((prog = patcompile(qq, PAT_STATIC, NULL))) {
        -: 3998:				    char **a, *n;
      344: 3999:				    int l = (c ? strlen(c + 1) + 2 : 1), al;
        -: 4000:
      772: 4001:				    for (a = all; *a; a++) {
      929: 4002:					for (node = firstnode(list); node;
       73: 4003:					     incnode(node)) {
        -: 4004:					    char *as, *ls;
        -: 4005:
      594: 4006:					    for (as = *a, ls = (char *) getdata(node);
      861: 4007:						 *as && *ls && *ls != ':'; as++, ls++)
      467: 4008:						if (*as != *ls)
       73: 4009:						    break;
      100: 4010:					    if (!*as && (!*ls || *ls == ':'))
        -: 4011:						break;
        -: 4012:					}
      428: 4013:					if (node)
       27: 4014:					    continue;
      401: 4015:					if (pattry(prog, *a)) {
       42: 4016:					    n = (char *) zhalloc((al = strlen(*a)) + l);
       42: 4017:					    strcpy(n, *a);
       42: 4018:					    if (c) {
    #####: 4019:						n[al] = ':';
    #####: 4020:						strcpy(n + al + 1, c + 1);
        -: 4021:					    }
       42: 4022:					    addlinknode(list, n);
       42: 4023:					    num++;
        -: 4024:					}
        -: 4025:				    }
        -: 4026:				}
        -: 4027:			    }
      344: 4028:			} else if (arrcontains(all, q, 0)) {
      384: 4029:			    for (set = comptags[lasttaglevel]->sets; set;
       40: 4030:				 set = set->next)
       40: 4031:				if (arrcontains(set->tags, q, 0))
    #####: 4032:				    break;
      172: 4033:			    if (!set) {
      172: 4034:				addlinknode(list, q);
      172: 4035:				num++;
        -: 4036:			    }
        -: 4037:			}
      688: 4038:			if (c)
    #####: 4039:			    *c = ':';
        -: 4040:
      688: 4041:			unqueue_signals();
        -: 4042:		    }
        -: 4043:		}
      344: 4044:		if (num) {
        -: 4045:		    Ctset l;
        -: 4046:
      212: 4047:		    set = (Ctset) zalloc(sizeof(*set));
        -: 4048:
      212: 4049:		    set->tags = zlinklist2array(list, 1);
      212: 4050:		    set->next = NULL;
      212: 4051:		    set->ptr = NULL;
      212: 4052:		    set->tag = NULL;
        -: 4053:
      212: 4054:		    if ((l = comptags[lasttaglevel]->sets)) {
       80: 4055:			while (l->next)
    #####: 4056:			    l = l->next;
        -: 4057:
       40: 4058:			l->next = set;
        -: 4059:		    } else
      172: 4060:			comptags[lasttaglevel]->sets = set;
        -: 4061:		}
        -: 4062:	    }
        -: 4063:	} else {
        -: 4064:	    char **p, **q, **all;
      261: 4065:	    int sep = 0;
        -: 4066:
      261: 4067:	    if ((sep = !strcmp(*args, "-s")))
    #####: 4068:		args++;
        -: 4069:
      566: 4070:	    for (p = q = args, all = comptags[lasttaglevel]->all; *p; p++)
      305: 4071:		if (arrcontains(all, *p, 1)) {
        -: 4072:		    Ctset s;
        -: 4073:
      345: 4074:		    for (s = comptags[lasttaglevel]->sets; s; s = s->next)
      254: 4075:			if (arrcontains(s->tags, *p, 0))
      214: 4076:			    break;
        -: 4077:
      305: 4078:		    if (!s)
       91: 4079:			*q++ = *p;
        -: 4080:		}
      261: 4081:	    *q = NULL;
        -: 4082:
      261: 4083:	    if (*args) {
        -: 4084:		char *dummy[2];
        -: 4085:
        -: 4086:		do {
       89: 4087:		    Ctset s = (Ctset) zalloc(sizeof(*s)), l;
        -: 4088:
       89: 4089:		    if (sep) {
    #####: 4090:			dummy[0] = *args++;
    #####: 4091:			dummy[1] = NULL;
    #####: 4092:			s->tags = zarrdup(dummy);
        -: 4093:		    } else
       89: 4094:			s->tags = zarrdup(args);
       89: 4095:		    s->next = NULL;
       89: 4096:		    s->ptr = NULL;
       89: 4097:		    s->tag = NULL;
        -: 4098:
       89: 4099:		    if ((l = comptags[lasttaglevel]->sets)) {
    #####: 4100:			while (l->next)
    #####: 4101:			    l = l->next;
        -: 4102:
    #####: 4103:			l->next = s;
        -: 4104:		    } else
       89: 4105:			comptags[lasttaglevel]->sets = s;
       89: 4106:		} while (sep && *args);
        -: 4107:	    }
        -: 4108:	}
        -: 4109:    }
      605: 4110:    return 0;
        -: 4111:}
        -: 4112:
        -: 4113:#define PATH_MAX2 (PATH_MAX * 2)
        -: 4114:
        -: 4115:/*
        -: 4116: * Return a list of files we should accept exactly, without
        -: 4117: * trying pattern matching.
        -: 4118: *
        -: 4119: * This is based on the accept-exact style, which may be
        -: 4120: * an array so is passed in via "accept".  The trial files
        -: 4121: * are input in "names".  "skipped" is passed down straight
        -: 4122: * from the file completion function:  it's got something to
        -: 4123: * do with other components in the path but it's hard to work out
        -: 4124: * quite what.
        -: 4125: *
        -: 4126: * There is one extra trick here for Cygwin.  Regardless of the style,
        -: 4127: * if the file ends in a colon it has to be a drive or a special device
        -: 4128: * file and we always accept it exactly because treating it as a pattern
        -: 4129: * won't work.
        -: 4130: */
        -: 4131:static LinkList
    #####: 4132:cfp_test_exact(LinkList names, char **accept, char *skipped)
        -: 4133:{
        -: 4134:    char buf[PATH_MAX2 + 1], *suf, *p;
    #####: 4135:    int l, sl, found = 0;
        -: 4136:    struct stat st;
        -: 4137:    LinkNode node;
    #####: 4138:    LinkList ret = newlinklist(), alist = NULL;
        -: 4139:#ifdef __CYGWIN__
        -: 4140:    int accept_off = 0;
        -: 4141:#endif
        -: 4142:
        -: 4143:    /*
        -: 4144:     * Don't do this unless completion has provided either a
        -: 4145:     * prefix or suffix from the command line.
        -: 4146:     */
    #####: 4147:    if (!(compprefix && *compprefix) && !(compsuffix && *compsuffix))
    #####: 4148:	return NULL;
        -: 4149:
        -: 4150:    /*
        -: 4151:     * See if accept-exact is off, implicitly or explicitly.
        -: 4152:     */
    #####: 4153:    if (!accept || !*accept ||
    #####: 4154:	((!strcmp(*accept, "false") || !strcmp(*accept, "no") ||
    #####: 4155:	  !strcmp(*accept, "off") || !strcmp(*accept, "0")) && !accept[1])) {
        -: 4156:#ifdef __CYGWIN__
        -: 4157:	accept_off = 1;
        -: 4158:#else
        -: 4159:	/* If not Cygwin, nothing to do here. */
    #####: 4160:	return NULL;
        -: 4161:#endif
        -: 4162:    }
        -: 4163:
        -: 4164:    /*
        -: 4165:     * See if the style is something other than just a boolean.
        -: 4166:     */
    #####: 4167:    if (
        -: 4168:#ifdef __CYGWIN__
        -: 4169:	!accept_off &&
        -: 4170:#endif
    #####: 4171:	(accept[1] ||
    #####: 4172:	 (strcmp(*accept, "true") && strcmp(*accept, "yes") &&
    #####: 4173:	  strcmp(*accept, "on") && strcmp(*accept, "1")))) {
        -: 4174:	Patprog prog;
        -: 4175:
    #####: 4176:	alist = newlinklist();
        -: 4177:
    #####: 4178:	for (; (p = *accept); accept++) {
    #####: 4179:	    if (*p == '*' && !p[1]) {
    #####: 4180:		alist = NULL;
    #####: 4181:		break;
        -: 4182:	    }
    #####: 4183:	    tokenize(p = dupstring(p));
    #####: 4184:	    if ((prog = patcompile(p, 0, NULL)))
    #####: 4185:		addlinknode(alist, prog);
        -: 4186:	}
        -: 4187:    }
        -: 4188:    /*
        -: 4189:     * Assemble the bits other than the set of file names:
        -: 4190:     * the other components, and the prefix and suffix.
        -: 4191:     */
    #####: 4192:    sl = strlen(skipped) + (compprefix ? strlen(compprefix) : 0) +
    #####: 4193:	(compsuffix ? strlen(compsuffix) : 0);
        -: 4194:
    #####: 4195:    if (sl > PATH_MAX2)
    #####: 4196:	return NULL;
        -: 4197:
    #####: 4198:    suf = dyncat(skipped, rembslash(dyncat(compprefix ? compprefix : "",
    #####: 4199:		                           compsuffix ? compsuffix : "")));
        -: 4200:
    #####: 4201:    for (node = firstnode(names); node; incnode(node)) {
    #####: 4202:	l = strlen(p = (char *) getdata(node));
    #####: 4203:	if (l + sl < PATH_MAX2) {
        -: 4204:#ifdef __CYGWIN__
        -: 4205:	    char *testbuf;
        -: 4206:#define TESTBUF testbuf
        -: 4207:#else
        -: 4208:#define TESTBUF buf
        -: 4209:#endif
    #####: 4210:	    strcpy(buf, p);
    #####: 4211:	    strcpy(buf + l, suf);
        -: 4212:#ifdef __CYGWIN__
        -: 4213:	    if (accept_off) {
        -: 4214:		int sl = strlen(buf);
        -: 4215:		/*
        -: 4216:		 * If accept-exact is not set, accept this only if
        -: 4217:		 * it looks like a special file such as a drive.
        -: 4218:		 * We still test if it exists.
        -: 4219:		 */
        -: 4220:		if (!sl || strchr(buf, '/') || buf[sl-1] != ':')
        -: 4221:		    continue;
        -: 4222:		if (sl == 2) {
        -: 4223:		    /*
        -: 4224:		     * Recent versions of Cygwin only recognise "c:/",
        -: 4225:		     * but not "c:", as special directories.  So
        -: 4226:		     * we have to append the slash for the purpose of
        -: 4227:		     * the test.
        -: 4228:		     */
        -: 4229:		    testbuf = zhalloc(sl + 2);
        -: 4230:		    strcpy(testbuf, buf);
        -: 4231:		    testbuf[sl] = '/';
        -: 4232:		    testbuf[sl+1] = '\0';
        -: 4233:		} else {
        -: 4234:		    /* Don't do this with stuff like PRN: */
        -: 4235:		    testbuf = buf;
        -: 4236:		}
        -: 4237:	    } else {
        -: 4238:		testbuf = buf;
        -: 4239:	    }
        -: 4240:#endif
    #####: 4241:	    if (!ztat(TESTBUF, &st, 0)) {
        -: 4242:		/*
        -: 4243:		 * File exists; if accept-exact contained non-boolean
        -: 4244:		 * values it must match those, too.
        -: 4245:		 */
    #####: 4246:		if (alist) {
        -: 4247:		    LinkNode anode;
        -: 4248:
    #####: 4249:		    for (anode = firstnode(alist); anode; incnode(anode))
    #####: 4250:			if (pattry((Patprog) getdata(anode), buf))
    #####: 4251:			    break;
        -: 4252:
    #####: 4253:		    if (!anode)
    #####: 4254:			continue;
        -: 4255:		}
    #####: 4256:		found = 1;
    #####: 4257:		addlinknode(ret, dupstring(buf));
        -: 4258:	    }
        -: 4259:	}
        -: 4260:    }
    #####: 4261:    return (found ? ret : NULL);
        -: 4262:}
        -: 4263:
        -: 4264:
        -: 4265:/*
        -: 4266: * This code constructs (from heap) and returns a string that
        -: 4267: * corresponds to a series of matches; when compiled as a pattern, at
        -: 4268: * each position it matches either the character from the string "add"
        -: 4269: * or the corresponding single-character match from the set of matchers.
        -: 4270: * To take a simple case, if add is "a" and the single matcher for the
        -: 4271: * character position matches "[0-9]", the pattern returned is "[0-9a]".
        -: 4272: * We take account of equivalences between the word and line, too.
        -: 4273: *
        -: 4274: * As there are virtually no comments in this file, I don't really
        -: 4275: * know why we're doing this, but it's to do with a matcher which
        -: 4276: * is passed as an argument to the utility compfiles -p/-P.
        -: 4277: */
        -: 4278:static char *
    #####: 4279:cfp_matcher_range(Cmatcher *ms, char *add)
        -: 4280:{
        -: 4281:    Cmatcher *mp, m;
    #####: 4282:    int len = 0, mt;
    #####: 4283:    char *ret = NULL, *p = NULL, *adds = add;
        -: 4284:
        -: 4285:    /*
        -: 4286:     * Do this twice:  once to work out the length of the
        -: 4287:     * string in len, the second time to build it in ret.
        -: 4288:     * This is probably worthwhile because otherwise memory
        -: 4289:     * management is difficult.
        -: 4290:     */
        -: 4291:    for (;;) {
    #####: 4292:	MB_METACHARINIT();
    #####: 4293:	for (mp = ms; *add; ) {
        -: 4294:	    convchar_t addc;
        -: 4295:	    int addlen;
        -: 4296:
    #####: 4297:	    addlen = MB_METACHARLENCONV(add, &addc);
        -: 4298:#ifdef MULTIBYTE_SUPPORT
    #####: 4299:	    if (addc == WEOF)
    #####: 4300:		addc = (wchar_t)(*add == Meta ? add[1] ^ 32 : *add);
        -: 4301:#endif
        -: 4302:
    #####: 4303:	    if (!(m = *mp)) {
        -: 4304:		/*
        -: 4305:		 * No matcher, so just match the character
        -: 4306:		 * itself.
        -: 4307:		 *
        -: 4308:		 * TODO: surely this needs quoting if it's a
        -: 4309:		 * metacharacter?
        -: 4310:		 */
    #####: 4311:		if (ret) {
    #####: 4312:		    memcpy(p, add, addlen);
    #####: 4313:		    p += addlen;
        -: 4314:		} else
    #####: 4315:		    len += addlen;
    #####: 4316:	    } else if (m->flags & CMF_RIGHT) {
        -: 4317:		/*
        -: 4318:		 * Right-anchored:  match anything followed
        -: 4319:		 * by the character itself.
        -: 4320:		 */
    #####: 4321:		if (ret) {
    #####: 4322:		    *p++ = '*';
        -: 4323:		    /* TODO: quote again? */
    #####: 4324:		    memcpy(p, add, addlen);
    #####: 4325:		    p += addlen;
        -: 4326:		} else
    #####: 4327:		    len += addlen + 1;
        -: 4328:	    } else {
        -: 4329:		/* The usual set of matcher possibilities. */
        -: 4330:		convchar_t ind;
    #####: 4331:		if (m->line->tp == CPAT_EQUIV &&
    #####: 4332:		    m->word->tp == CPAT_EQUIV) {
        -: 4333:		    /*
        -: 4334:		     * Genuine equivalence.  Add the character to match
        -: 4335:		     * and the equivalent character from the word
        -: 4336:		     * pattern.
        -: 4337:		     *
        -: 4338:		     * TODO: we could be more careful here with special
        -: 4339:		     * cases as we are in the basic character class
        -: 4340:		     * code below.
        -: 4341:		     */
    #####: 4342:		    if (ret) {
    #####: 4343:			*p++ = '[';
    #####: 4344:			memcpy(p, add, addlen);
    #####: 4345:			p += addlen;
        -: 4346:		    } else
    #####: 4347:			len += addlen + 1;
    #####: 4348:		    if (PATMATCHRANGE(m->line->u.str, addc, &ind, &mt)) {
        -: 4349:			/*
        -: 4350:			 * Find the equivalent match for ind in the
        -: 4351:			 * word pattern.
        -: 4352:			 */
    #####: 4353:			if ((ind = pattern_match_equivalence
        -: 4354:			     (m->word, ind, mt, addc)) != CHR_INVALID) {
    #####: 4355:			    if (ret) {
    #####: 4356:				if (imeta(ind)) {
    #####: 4357:				    *p++ = Meta;
    #####: 4358:				    *p++ = ind ^ 32;
        -: 4359:				} else
    #####: 4360:				    *p++ = ind;
        -: 4361:			    } else
    #####: 4362:				len += imeta(ind) ? 2 : 1;
        -: 4363:			}
        -: 4364:		    }
    #####: 4365:		    if (ret)
    #####: 4366:			*p++ = ']';
        -: 4367:		    else
    #####: 4368:			len++;
        -: 4369:		} else {
        -: 4370:		    int newlen, addadd;
        -: 4371:
    #####: 4372:		    switch (m->word->tp) {
    #####: 4373:		    case CPAT_NCLASS:
        -: 4374:			/*
        -: 4375:			 * TODO: the old logic implies that we need to
        -: 4376:			 * match *add, i.e. it should be deleted from
        -: 4377:			 * the set of character's we're not allowed to
        -: 4378:			 * match.  That's too much like hard work for
        -: 4379:			 * now.  Indeed, in general it's impossible
        -: 4380:			 * without trickery.  Consider *add == 'A',
        -: 4381:			 * range == "[^[:upper:]]": we would have to
        -: 4382:			 * resort to something like "(A|[^[:upper:]])";
        -: 4383:			 * and in an expression like that *add may or
        -: 4384:			 * may not need backslashing.  So we're deep
        -: 4385:			 * into see-if-we-can-get-away-without
        -: 4386:			 * territory.
        -: 4387:			 */
    #####: 4388:			if (ret) {
    #####: 4389:			    *p++ = '[';
    #####: 4390:			    *p++ = '^';
        -: 4391:			} else
    #####: 4392:			    len += 2;
        -: 4393:			/*
        -: 4394:			 * Convert the compiled range string back
        -: 4395:			 * to an ordinary string.
        -: 4396:			 */
    #####: 4397:			newlen =
    #####: 4398:			    pattern_range_to_string(m->word->u.str, p);
        -: 4399:			DPUTS(!newlen, "empty character range");
    #####: 4400:			if (ret) {
    #####: 4401:			    p += newlen;
    #####: 4402:			    *p++ = ']';
        -: 4403:			} else
    #####: 4404:			    len += newlen + 1;
    #####: 4405:			break;
        -: 4406:			    
    #####: 4407:		    case CPAT_CCLASS:
        -: 4408:			/*
        -: 4409:			 * If there is an equivalence only on one
        -: 4410:			 * side it's not equivalent to anything.
        -: 4411:			 * Treat it as an ordinary character class.
        -: 4412:			 */ 
        -: 4413:		    case CPAT_EQUIV:
        -: 4414:		    case CPAT_CHAR:
    #####: 4415:			if (ret)
    #####: 4416:			    *p++ = '[';
        -: 4417:			else
    #####: 4418:			    len++;
        -: 4419:			/*
        -: 4420:			 * We needed to add *add specially only if
        -: 4421:			 * it is not covered by the range.  This
        -: 4422:			 * is necessary for correct syntax---consider
        -: 4423:			 * if *add is ] and ] is also the first
        -: 4424:			 * character in the range.
        -: 4425:			 */
    #####: 4426:			addadd = !pattern_match1(m->word, addc, &mt);
    #####: 4427:			if (addadd && *add == ']') {
    #####: 4428:			    if (ret)
    #####: 4429:				*p++ = *add;
        -: 4430:			    else
    #####: 4431:				len++;
        -: 4432:			}
    #####: 4433:			if (m->word->tp == CPAT_CHAR) {
        -: 4434:			    /*
        -: 4435:			     * The matcher just matches a single
        -: 4436:			     * character, but we need to be able
        -: 4437:			     * to match *add, too, hence we do
        -: 4438:			     * this as a [...].
        -: 4439:			     */
    #####: 4440:			    if (ret) {
    #####: 4441:				if (imeta(m->word->u.chr)) {
    #####: 4442:				    *p++ = Meta;
    #####: 4443:				    *p++ = m->word->u.chr ^ 32;
        -: 4444:				} else
    #####: 4445:				    *p++ = m->word->u.chr;
        -: 4446:			    } else
    #####: 4447:				len += imeta(m->word->u.chr) ? 2 : 1;
        -: 4448:			} else {
        -: 4449:			    /*
        -: 4450:			     * Convert the compiled range string back
        -: 4451:			     * to an ordinary string.
        -: 4452:			     */
    #####: 4453:			    newlen =
    #####: 4454:				pattern_range_to_string(m->word->u.str, p);
        -: 4455:			    DPUTS(!newlen, "empty character range");
    #####: 4456:			    if (ret)
    #####: 4457:				p += newlen;
        -: 4458:			    else
    #####: 4459:				len += newlen;
        -: 4460:			}
    #####: 4461:			if (addadd && *add != ']') {
    #####: 4462:			    if (ret) {
    #####: 4463:				memcpy(p, add, addlen);
    #####: 4464:				p += addlen;
        -: 4465:			    } else
    #####: 4466:				len += addlen;
        -: 4467:			}
    #####: 4468:			if (ret)
    #####: 4469:			    *p++ = ']';
        -: 4470:			else
    #####: 4471:			    len++;
    #####: 4472:			break;
        -: 4473:
    #####: 4474:		    case CPAT_ANY:
    #####: 4475:			if (ret)
    #####: 4476:			    *p++ = '?';
        -: 4477:			else
    #####: 4478:			    len++;
    #####: 4479:			break;
        -: 4480:		    }
        -: 4481:		}
        -: 4482:	    }
    #####: 4483:	    add += addlen;
    #####: 4484:	    mp++;
        -: 4485:	}
    #####: 4486:	if (ret) {
    #####: 4487:	    *p = '\0';
    #####: 4488:	    return ret;
        -: 4489:	}
    #####: 4490:	p = ret = zhalloc(len + 1);
    #####: 4491:	add = adds;
        -: 4492:    }
        -: 4493:}
        -: 4494:
        -: 4495:
        -: 4496:static char *
    #####: 4497:cfp_matcher_pats(char *matcher, char *add)
        -: 4498:{
    #####: 4499:    Cmatcher m = parse_cmatcher(NULL, matcher);
        -: 4500:
    #####: 4501:    if (m && m != pcm_err) {
        -: 4502:	char *tmp;
    #####: 4503:	int al = strlen(add), zl = ztrlen(add), tl, cl;
    #####: 4504:	VARARR(Cmatcher, ms, zl);	/* One Cmatcher per character */
        -: 4505:	Cmatcher *mp;
        -: 4506:	Cpattern stopp;
    #####: 4507:	int stopl = 0;
        -: 4508:
        -: 4509:	/* zl >= (number of wide characters) is guaranteed */
    #####: 4510:	memset(ms, 0, zl * sizeof(Cmatcher));
        -: 4511:
    #####: 4512:	for (; m && *add; m = m->next) {
    #####: 4513:	    stopp = NULL;
    #####: 4514:	    if (!(m->flags & (CMF_LEFT|CMF_RIGHT))) {
    #####: 4515:		if (m->llen == 1 && m->wlen == 1) {
        -: 4516:		    /*
        -: 4517:		     * In this loop and similar loops below we step
        -: 4518:		     * through tmp one (possibly wide) character at a
        -: 4519:		     * time.  pattern_match() compares only the first
        -: 4520:		     * character using unmeta_one() so keep in step.
        -: 4521:		     */
    #####: 4522:		    for (tmp = add, tl = al, mp = ms; tl; ) {
    #####: 4523:			if (pattern_match(m->line, tmp, NULL, NULL)) {
    #####: 4524:			    if (*mp) {
    #####: 4525:				*tmp = '\0';
    #####: 4526:				al = tmp - add;
    #####: 4527:				break;
        -: 4528:			    } else
    #####: 4529:				*mp = m;
        -: 4530:			}
    #####: 4531:			(void) unmeta_one(tmp, &cl);
    #####: 4532:			tl -= cl;
    #####: 4533:			tmp += cl;
    #####: 4534:			mp++;
        -: 4535:		    }
        -: 4536:		} else {
    #####: 4537:		    stopp = m->line;
    #####: 4538:		    stopl = m->llen;
        -: 4539:		}
    #####: 4540:	    } else if (m->flags & CMF_RIGHT) {
    #####: 4541:		if (m->wlen < 0 && !m->llen && m->ralen == 1) {
    #####: 4542:		    for (tmp = add, tl = al, mp = ms; tl; ) {
    #####: 4543:			if (pattern_match(m->right, tmp, NULL, NULL)) {
    #####: 4544:			    if (*mp || (tmp == add && *tmp == '.')) {
    #####: 4545:				*tmp = '\0';
    #####: 4546:				al = tmp - add;
    #####: 4547:				break;
        -: 4548:			    } else
    #####: 4549:				*mp = m;
        -: 4550:			}
    #####: 4551:			(void) unmeta_one(tmp, &cl);
    #####: 4552:			tl -= cl;
    #####: 4553:			tmp += cl;
    #####: 4554:			mp++;
        -: 4555:		    }
    #####: 4556:		} else if (m->llen) {
    #####: 4557:		    stopp = m->line;
    #####: 4558:		    stopl = m->llen;
        -: 4559:		} else {
    #####: 4560:		    stopp = m->right;
    #####: 4561:		    stopl = m->ralen;
        -: 4562:		}
        -: 4563:	    } else {
    #####: 4564:		if (!m->lalen)
    #####: 4565:		    return "";
        -: 4566:
    #####: 4567:		stopp = m->left;
    #####: 4568:		stopl = m->lalen;
        -: 4569:	    }
    #####: 4570:	    if (stopp)
    #####: 4571:		for (tmp = add, tl = al; tl >= stopl; ) {
    #####: 4572:		    if (pattern_match(stopp, tmp, NULL, NULL)) {
    #####: 4573:			*tmp = '\0';
    #####: 4574:			al = tmp - add;
    #####: 4575:			break;
        -: 4576:		    }
    #####: 4577:		    (void) unmeta_one(tmp, &cl);
    #####: 4578:		    tl -= cl;
    #####: 4579:		    tmp += cl;
        -: 4580:		}
        -: 4581:	}
    #####: 4582:	if (*add)
    #####: 4583:	    return cfp_matcher_range(ms, add);
        -: 4584:    }
    #####: 4585:    return add;
        -: 4586:}
        -: 4587:
        -: 4588:/*
        -: 4589: * ### This function call is skipped by _approximate, so "opt" probably means "optimize".
        -: 4590: */
        -: 4591:
        -: 4592:static void
    #####: 4593:cfp_opt_pats(char **pats, char *matcher)
        -: 4594:{
        -: 4595:    char *add, **p, *q, *t, *s;
        -: 4596:
    #####: 4597:    if (!compprefix || !*compprefix)
    #####: 4598:	return;
        -: 4599:
    #####: 4600:    if (comppatmatch && *comppatmatch) {
    #####: 4601:	tokenize(t = rembslash(dyncat(compprefix, compsuffix)));
    #####: 4602:	remnulargs(t);
    #####: 4603:	if (haswilds(t))
    #####: 4604:	    return;
        -: 4605:    }
    #####: 4606:    add = (char *) zhalloc(strlen(compprefix) * 2 + 1);
    #####: 4607:    for (s = compprefix, t = add; *s; s++) {
    #####: 4608:	if (*s != '\\' || !s[1] || s[1] == '*' || s[1] == '?' ||
    #####: 4609:	    s[1] == '<' || s[1] == '>' || s[1] == '(' || s[1] == ')' ||
    #####: 4610:	    s[1] == '[' || s[1] == ']' || s[1] == '|' || s[1] == '#' ||
    #####: 4611:	    s[1] == '^' || s[1] == '~' || s[1] == '=') {
    #####: 4612:	    if ((s == compprefix || s[-1] != '\\') &&
    #####: 4613:		(*s == '*' || *s == '?' || *s == '<' || *s == '>' ||
    #####: 4614:		 *s == '(' || *s == ')' || *s == '[' || *s == ']' ||
    #####: 4615:		 *s == '|' || *s == '#' || *s == '^' || *s == '~' ||
    #####: 4616:		 *s == '='))
    #####: 4617:		*t++ = '\\';
    #####: 4618:	    *t++ = *s;
        -: 4619:	}
        -: 4620:    }
    #####: 4621:    *t = '\0';
    #####: 4622:    for (p = pats; *add && (q = *p); p++) {
    #####: 4623:	if (*q) {
    #####: 4624:	    q = dupstring(q);
    #####: 4625:	    t = q + strlen(q) - 1;
    #####: 4626:	    if (*t == ')') {
    #####: 4627:		for (s = t--; t > q; t--)
    #####: 4628:		    if (*t == ')' || *t == '|' || *t == '~' || *t == '(')
        -: 4629:			break;
    #####: 4630:		if (t != q && *t == '(')
    #####: 4631:		    *t = '\0';
        -: 4632:	    }
    #####: 4633:	    for (; *q && *add; q++) {
    #####: 4634:		if (*q == '\\' && q[1]) {
    #####: 4635:		    for (s = add, q++; *s && *s != *q; s++);
    #####: 4636:		    *s = '\0';
    #####: 4637:		} else if (*q == '<') {
    #####: 4638:		    for (s = add; *s && !idigit(*s); s++);
    #####: 4639:		    *s = '\0';
    #####: 4640:		} else if (*q == '[') {
        -: 4641:		    int not;
    #####: 4642:		    char *x = ++q;
        -: 4643:
    #####: 4644:		    if ((not = (*x == '!' || *x == '^')))
    #####: 4645:			x++;
    #####: 4646:		    for (; *x; x++) {
    #####: 4647:			if (x[1] == '-' && x[2]) {
    #####: 4648:			    char c1 = *x, c2 = x[2];
        -: 4649:
    #####: 4650:			    for (s = add; *s && (*x < c1 || *x > c2); s++);
    #####: 4651:			    *s = '\0';
        -: 4652:			} else {
    #####: 4653:			    for (s = add; *s && *s != *x; s++);
    #####: 4654:			    *s = '\0';
        -: 4655:			}
        -: 4656:		    }
    #####: 4657:		} else if (*q != '?' && *q != '*' && *q != '(' && *q != ')' &&
    #####: 4658:			   *q != '|' && *q != '~' && *q != '#') {
    #####: 4659:		    for (s = add; *s && *s != *q; s++);
    #####: 4660:		    *s = '\0';
        -: 4661:		}
        -: 4662:	    }
        -: 4663:	}
        -: 4664:    }
    #####: 4665:    if (*add) {
    #####: 4666:	if (*matcher && !(add = cfp_matcher_pats(matcher, add)))
    #####: 4667:	    return;
        -: 4668:
    #####: 4669:	for (p = pats; *p; p++)
    #####: 4670:	    if (**p == '*')
    #####: 4671:		*p = dyncat(add, *p);
        -: 4672:    }
        -: 4673:}
        -: 4674:
        -: 4675:static LinkList
    #####: 4676:cfp_bld_pats(UNUSED(int dirs), LinkList names, char *skipped, char **pats)
        -: 4677:{
    #####: 4678:    LinkList ret = newlinklist();
        -: 4679:    LinkNode node;
    #####: 4680:    int ol, sl = strlen(skipped), pl, dot;
        -: 4681:    char **p, *o, *str;
        -: 4682:
    #####: 4683:    dot = (unset(GLOBDOTS) && compprefix && *compprefix == '.');
    #####: 4684:    for (node = firstnode(names); node; incnode(node)) {
    #####: 4685:	ol = strlen(o = (char *) getdata(node));
    #####: 4686:	for (p = pats; *p; p++) {
    #####: 4687:	    pl = strlen(*p);
    #####: 4688:	    str = (char *) zhalloc(ol + sl + pl + 1);
    #####: 4689:	    strcpy(str, o);
    #####: 4690:	    strcpy(str + ol, skipped);
    #####: 4691:	    strcpy(str + ol + sl, *p);
    #####: 4692:	    addlinknode(ret, str);
    #####: 4693:	    if (dot && **p != '.') {
    #####: 4694:		str = (char *) zhalloc(ol + sl + pl + 2);
    #####: 4695:		strcpy(str, o);
    #####: 4696:		strcpy(str + ol, skipped);
    #####: 4697:		str[ol + sl] = '.';
    #####: 4698:		strcpy(str + ol + sl + 1, *p);
    #####: 4699:		addlinknode(ret, str);
        -: 4700:	    }
        -: 4701:	}
        -: 4702:    }
    #####: 4703:    return ret;
        -: 4704:}
        -: 4705:
        -: 4706:static LinkList
    #####: 4707:cfp_add_sdirs(LinkList final, LinkList orig, char *skipped,
        -: 4708:	      char *sdirs, char **fake)
        -: 4709:{
    #####: 4710:    int add = 0;
        -: 4711:
    #####: 4712:    if (*sdirs && (isset(GLOBDOTS) || (compprefix && *compprefix == '.'))) {
    #####: 4713:	if (!strcmp(sdirs, "yes") || !strcmp(sdirs, "true") ||
    #####: 4714:	    !strcmp(sdirs, "on") || !strcmp(sdirs, "1"))
    #####: 4715:	    add = 2;
    #####: 4716:	else if (!strcmp(sdirs, ".."))
    #####: 4717:	    add = 1;
        -: 4718:    }
    #####: 4719:    if (add) {
        -: 4720:	LinkNode node;
    #####: 4721:	char *s1 = dyncat(skipped, "..");
    #####: 4722:	char *s2 = (add == 2 ? dyncat(skipped, ".") : NULL), *m;
        -: 4723:
    #####: 4724:	for (node = firstnode(orig); node; incnode(node)) {
    #####: 4725:	    if ((m = (char *) getdata(node))) {
    #####: 4726:		addlinknode(final, dyncat(m, s1));
    #####: 4727:		if (s2)
    #####: 4728:		    addlinknode(final, dyncat(m, s2));
        -: 4729:	    }
        -: 4730:	}
        -: 4731:    }
    #####: 4732:    if (fake && *fake) {
        -: 4733:	LinkNode node;
        -: 4734:	char *m, *f, *p, *t, *a, c;
    #####: 4735:	int sl = strlen(skipped) + 1;
        -: 4736:	struct stat st1, st2;
        -: 4737:	Patprog pprog;
        -: 4738:
    #####: 4739:	for (; (f = *fake); fake++) {
    #####: 4740:	    f = dupstring(f);
    #####: 4741:	    for (p = t = f; *p; p++) {
    #####: 4742:		if (*p == ':')
    #####: 4743:		    break;
    #####: 4744:		else if (*p == '\\' && p[1] == ':') {
        -: 4745:		    /*
        -: 4746:		     * strip quoted colons here; rely
        -: 4747:		     * on tokenization to strip other backslashes
        -: 4748:		     */
    #####: 4749:		    p++;
        -: 4750:		}
    #####: 4751:		*t++ = *p;
        -: 4752:	    }
    #####: 4753:	    if (*p) {
    #####: 4754:		*t = *p++ = '\0';
    #####: 4755:		if (!*p)
    #####: 4756:		    continue;
        -: 4757:
    #####: 4758:		queue_signals();	/* Protect PAT_STATIC */
        -: 4759:
    #####: 4760:		tokenize(f);
    #####: 4761:		pprog = patcompile(f, PAT_STATIC, NULL);
    #####: 4762:		untokenize(f);
    #####: 4763:		for (node = firstnode(orig); node; incnode(node)) {
    #####: 4764:		    if ((m = (char *) getdata(node)) &&
    #####: 4765:			((pprog ? pattry(pprog, m) : !strcmp(f, m)) ||
    #####: 4766:			 (!stat(f, &st1) && !stat((*m ? m : "."), &st2) &&
    #####: 4767:			  st1.st_dev == st2.st_dev &&
    #####: 4768:			  st1.st_ino == st2.st_ino))) {
    #####: 4769:			while (*p) {
    #####: 4770:			    while (*p && inblank(*p))
    #####: 4771:				p++;
    #####: 4772:			    if (!*p)
    #####: 4773:				break;
    #####: 4774:			    for (f = t = p; *p; p++) {
    #####: 4775:				if (inblank(*p))
    #####: 4776:				    break;
    #####: 4777:				else if (*p == '\\' && p[1])
    #####: 4778:				    p++;
    #####: 4779:				*t++ = *p;
        -: 4780:			    }
    #####: 4781:			    c = *t;
    #####: 4782:			    *t = '\0';
    #####: 4783:			    a = (char *) zhalloc(strlen(m) + sl + strlen(f));
    #####: 4784:			    strcpy(a, m);
    #####: 4785:			    strcat(a, skipped);
    #####: 4786:			    strcat(a, f);
    #####: 4787:			    addlinknode(final, a);
    #####: 4788:			    *t = c;
        -: 4789:			}
        -: 4790:		    }
        -: 4791:		}
        -: 4792:
    #####: 4793:		unqueue_signals();
        -: 4794:	    }
        -: 4795:	}
        -: 4796:    }
    #####: 4797:    return final;
        -: 4798:}
        -: 4799:
        -: 4800:static LinkList
    #####: 4801:cf_pats(int dirs, int noopt, LinkList names, char **accept, char *skipped,
        -: 4802:	char *matcher, char *sdirs, char **fake, char **pats)
        -: 4803:{
        -: 4804:    LinkList ret;
        -: 4805:    char *dpats[2];
        -: 4806:
    #####: 4807:    if ((ret = cfp_test_exact(names, accept, skipped)))
    #####: 4808:	return cfp_add_sdirs(ret, names, skipped, sdirs, fake);
        -: 4809:
    #####: 4810:    if (dirs) {
    #####: 4811:	dpats[0] = "*(-/)";
    #####: 4812:	dpats[1] = NULL;
    #####: 4813:	pats = dpats;
        -: 4814:    }
    #####: 4815:    if (!noopt)
    #####: 4816:	cfp_opt_pats(pats, matcher);
        -: 4817:
    #####: 4818:    return cfp_add_sdirs(cfp_bld_pats(dirs, names, skipped, pats),
        -: 4819:			 names, skipped, sdirs, fake);
        -: 4820:}
        -: 4821:
        -: 4822:/*
        -: 4823: * This function looks at device/inode pairs to determine if
        -: 4824: * a file is one we should ignore because of its relationship
        -: 4825: * to the current or parent directory.
        -: 4826: *
        -: 4827: * We don't follow symbolic links here, because typically
        -: 4828: * a user will not want an explicit link to the current or parent
        -: 4829: * directory ignored.
        -: 4830: */
        -: 4831:static void
    #####: 4832:cf_ignore(char **names, LinkList ign, char *style, char *path)
        -: 4833:{
    #####: 4834:    int pl = strlen(path), tpar, tpwd, found;
        -: 4835:    struct stat nst, est, st;
        -: 4836:    char *n, *c, *e;
        -: 4837:
    #####: 4838:    tpar = !!strstr(style, "parent");
    #####: 4839:    if ((tpwd = !!strstr(style, "pwd")) && lstat(pwd, &est))
    #####: 4840:	tpwd = 0;
        -: 4841:
    #####: 4842:    if (!tpar && !tpwd)
    #####: 4843:	return;
        -: 4844:
    #####: 4845:    for (; (n = *names); names++) {
    #####: 4846:	if (!ztat(n, &nst, 1) && S_ISDIR(nst.st_mode)) {
    #####: 4847:	    if (tpwd && nst.st_dev == est.st_dev && nst.st_ino == est.st_ino) {
    #####: 4848:		addlinknode(ign, quotestring(n, QT_BACKSLASH));
    #####: 4849:		continue;
        -: 4850:	    }
    #####: 4851:	    if (tpar && !strncmp((c = dupstring(n)), path, pl)) {
    #####: 4852:		found = 0;
    #####: 4853:		while ((e = strrchr(c, '/')) && e > c + pl) {
    #####: 4854:		    *e = '\0';
    #####: 4855:		    if (!ztat(c, &st, 0) &&
    #####: 4856:			st.st_dev == nst.st_dev && st.st_ino == nst.st_ino) {
    #####: 4857:			found = 1;
    #####: 4858:			break;
        -: 4859:		    }
        -: 4860:		}
    #####: 4861:		if (found || ((e = strrchr(c, '/')) && e > c + pl &&
    #####: 4862:			      !ztat(c, &st, 1) && st.st_dev == nst.st_dev &&
    #####: 4863:			      st.st_ino == nst.st_ino))
    #####: 4864:		    addlinknode(ign, quotestring(n, QT_BACKSLASH));
        -: 4865:	    }
        -: 4866:	}
        -: 4867:    }
        -: 4868:}
        -: 4869:
        -: 4870:static LinkList
    #####: 4871:cf_remove_other(char **names, char *pre, int *amb)
        -: 4872:{
        -: 4873:    char *p;
        -: 4874:
    #####: 4875:    if ((p = strchr(pre, '/'))) {
        -: 4876:	char **n;
        -: 4877:
    #####: 4878:	*p = '\0';
    #####: 4879:	pre = dyncat(pre, "/");
    #####: 4880:	*p = '/';
        -: 4881:
    #####: 4882:	for (n = names; *n; n++)
    #####: 4883:	    if (strpfx(pre, *n))
    #####: 4884:		break;
        -: 4885:
    #####: 4886:	if (*n) {
    #####: 4887:	    LinkList ret = newlinklist();
        -: 4888:
    #####: 4889:	    for (; *names; names++)
    #####: 4890:		if (strpfx(pre, *names))
    #####: 4891:		    addlinknode(ret, dupstring(*names));
        -: 4892:
    #####: 4893:	    *amb = 0;
        -: 4894:
    #####: 4895:	    return ret;
        -: 4896:	} else {
    #####: 4897:	    if (!(p = *names++))
    #####: 4898:		*amb = 0;
        -: 4899:	    else {
        -: 4900:		char *q;
        -: 4901:
    #####: 4902:		if ((q = strchr((p = dupstring(p)), '/')))
    #####: 4903:		    *q = '\0';
        -: 4904:
    #####: 4905:                p = dyncat(p, "/");
        -: 4906:
    #####: 4907:		for (; *names; names++)
    #####: 4908:		    if (!strpfx(p, *names)) {
    #####: 4909:			*amb = 1;
    #####: 4910:			return NULL;
        -: 4911:		    }
        -: 4912:	    }
        -: 4913:	}
        -: 4914:    } else {
    #####: 4915:	if (!(p = *names++))
    #####: 4916:	    *amb = 0;
        -: 4917:	else
    #####: 4918:	    for (; *names; names++)
    #####: 4919:		if (strcmp(p, *names)) {
    #####: 4920:		    *amb = 1;
    #####: 4921:		    return NULL;
        -: 4922:		}
        -: 4923:    }
    #####: 4924:    return NULL;
        -: 4925:}
        -: 4926:
        -: 4927:/*
        -: 4928: * SYNOPSIS:
        -: 4929: *     1. compfiles -p  parnam1 parnam2 skipped matcher sdirs parnam3 varargs [..varargs]
        -: 4930: *     2. compfiles -p- parnam1 parnam2 skipped matcher sdirs parnam3 varargs [..varargs]
        -: 4931: *     3. compfiles -P  parnam1 parnam2 skipped matcher sdirs parnam3 
        -: 4932: *
        -: 4933: *     1. Set parnam1 to an array of patterns....
        -: 4934: *        ${(P)parnam1} is an in/out parameter.
        -: 4935: *     2. Like #1 but without calling cfp_opt_pats().  (This is only used by _approximate.)
        -: 4936: *     3. Like #1 but varargs is implicitly set to  char *varargs[2] = { "*(-/)", NULL };.
        -: 4937: *
        -: 4938: *     parnam2 has to do with the accept-exact style (see cfp_test_exact()).
        -: 4939: */
        -: 4940:
        -: 4941:static int
    #####: 4942:bin_compfiles(char *nam, char **args, UNUSED(Options ops), UNUSED(int func))
        -: 4943:{
    #####: 4944:    if (incompfunc != 1) {
    #####: 4945:	zwarnnam(nam, "can only be called from completion function");
    #####: 4946:	return 1;
        -: 4947:    }
    #####: 4948:    if (**args != '-') {
    #####: 4949:	zwarnnam(nam, "missing option: %s", *args);
    #####: 4950:	return 1;
        -: 4951:    }
    #####: 4952:    switch (args[0][1]) {
    #####: 4953:    case 'p':
        -: 4954:    case 'P':
    #####: 4955:	if (args[0][2] && (args[0][2] != '-' || args[0][3])) {
    #####: 4956:	    zwarnnam(nam, "invalid option: %s", *args);
    #####: 4957:	    return 1;
        -: 4958:	} else {
        -: 4959:	    char **tmp;
        -: 4960:	    LinkList l;
        -: 4961:
    #####: 4962:	    if (!args[1] || !args[2] || !args[3] || !args[4] || !args[5] ||
    #####: 4963:		!args[6] || (args[0][1] == 'p' && !args[7])) {
    #####: 4964:		zwarnnam(nam, "too few arguments");
    #####: 4965:		return 1;
        -: 4966:	    }
    #####: 4967:	    queue_signals();
    #####: 4968:	    if (!(tmp = getaparam(args[1]))) {
    #####: 4969:		unqueue_signals();
    #####: 4970:		zwarnnam(nam, "unknown parameter: %s", args[1]);
    #####: 4971:		return 0;
        -: 4972:	    }
    #####: 4973:	    for (l = newlinklist(); *tmp; tmp++)
    #####: 4974:		addlinknode(l, quotestring(*tmp, QT_BACKSLASH_PATTERN));
    #####: 4975:	    set_list_array(args[1], cf_pats((args[0][1] == 'P'), !!args[0][2],
    #####: 4976:					    l, getaparam(args[2]), args[3],
    #####: 4977:					    args[4], args[5],
    #####: 4978:					    getaparam(args[6]), args + 7));
    #####: 4979:	    unqueue_signals();
    #####: 4980:	    return 0;
        -: 4981:	}
    #####: 4982:    case 'i':
    #####: 4983:	if (args[0][2]) {
    #####: 4984:	    zwarnnam(nam, "invalid option: %s", *args);
    #####: 4985:	    return 1;
        -: 4986:	} else {
        -: 4987:	    char **tmp;
        -: 4988:	    LinkList l;
        -: 4989:
    #####: 4990:	    if (!args[1] || !args[2] || !args[3] || !args[4]) {
    #####: 4991:		zwarnnam(nam, "too few arguments");
    #####: 4992:		return 1;
        -: 4993:	    }
    #####: 4994:	    if (args[5]) {
    #####: 4995:		zwarnnam(nam, "too many arguments");
    #####: 4996:		return 1;
        -: 4997:	    }
    #####: 4998:	    queue_signals();
    #####: 4999:	    tmp = getaparam(args[2]);
    #####: 5000:	    l = newlinklist();
    #####: 5001:	    if (tmp)
    #####: 5002:		for (; *tmp; tmp++)
    #####: 5003:		    addlinknode(l, *tmp);
    #####: 5004:	    if (!(tmp = getaparam(args[1]))) {
    #####: 5005:		unqueue_signals();
    #####: 5006:		zwarnnam(nam, "unknown parameter: %s", args[1]);
    #####: 5007:		return 0;
        -: 5008:	    }
    #####: 5009:	    cf_ignore(tmp, l, args[3], args[4]);
    #####: 5010:	    unqueue_signals();
    #####: 5011:	    set_list_array(args[2], l);
    #####: 5012:	    return 0;
        -: 5013:	}
    #####: 5014:    case 'r':
        -: 5015:	{
        -: 5016:	    char **tmp;
        -: 5017:	    LinkList l;
    #####: 5018:	    int ret = 0;
        -: 5019:
    #####: 5020:	    if (!args[1] || !args[2]) {
    #####: 5021:		zwarnnam(nam, "too few arguments");
    #####: 5022:		return 1;
        -: 5023:	    }
    #####: 5024:	    if (args[3]) {
    #####: 5025:		zwarnnam(nam, "too many arguments");
    #####: 5026:		return 1;
        -: 5027:	    }
    #####: 5028:	    queue_signals();
    #####: 5029:	    if (!(tmp = getaparam(args[1]))) {
    #####: 5030:		unqueue_signals();
    #####: 5031:		zwarnnam(nam, "unknown parameter: %s", args[1]);
    #####: 5032:		return 0;
        -: 5033:	    }
    #####: 5034:	    if ((l = cf_remove_other(tmp, args[2], &ret)))
    #####: 5035:		set_list_array(args[1], l);
    #####: 5036:	    unqueue_signals();
    #####: 5037:	    return ret;
        -: 5038:	}
        -: 5039:    }
    #####: 5040:    zwarnnam(nam, "invalid option: %s", *args);
    #####: 5041:    return 1;
        -: 5042:}
        -: 5043:
        -: 5044:static int
    #####: 5045:bin_compgroups(char *nam, char **args, UNUSED(Options ops), UNUSED(int func))
        -: 5046:{
        -: 5047:    Heap oldheap;
        -: 5048:    char *n;
        -: 5049:
    #####: 5050:    if (incompfunc != 1) {
    #####: 5051:	zwarnnam(nam, "can only be called from completion function");
    #####: 5052:	return 1;
        -: 5053:    }
    #####: 5054:    SWITCHHEAPS(oldheap, compheap) {
    #####: 5055:	while ((n = *args++)) {
    #####: 5056:	    endcmgroup(NULL);
    #####: 5057:	    begcmgroup(n, CGF_NOSORT|CGF_UNIQCON);
    #####: 5058:	    endcmgroup(NULL);
    #####: 5059:	    begcmgroup(n, CGF_UNIQALL);
    #####: 5060:	    endcmgroup(NULL);
    #####: 5061:	    begcmgroup(n, CGF_NOSORT|CGF_UNIQCON);
    #####: 5062:	    endcmgroup(NULL);
    #####: 5063:	    begcmgroup(n, CGF_UNIQALL);
    #####: 5064:	    endcmgroup(NULL);
    #####: 5065:	    begcmgroup(n, CGF_NOSORT);
    #####: 5066:	    endcmgroup(NULL);
    #####: 5067:	    begcmgroup(n, 0);
        -: 5068:	}
    #####: 5069:    } SWITCHBACKHEAPS(oldheap);
        -: 5070:
    #####: 5071:    return 0;
        -: 5072:}
        -: 5073:
        -: 5074:static struct builtin bintab[] = {
        -: 5075:    BUILTIN("comparguments", 0, bin_comparguments, 1, -1, 0, NULL, NULL),
        -: 5076:    BUILTIN("compdescribe", 0, bin_compdescribe, 3, -1, 0, NULL, NULL),
        -: 5077:    BUILTIN("compfiles", 0, bin_compfiles, 1, -1, 0, NULL, NULL),
        -: 5078:    BUILTIN("compgroups", 0, bin_compgroups, 1, -1, 0, NULL, NULL),
        -: 5079:    BUILTIN("compquote", 0, bin_compquote, 1, -1, 0, "p", NULL),
        -: 5080:    BUILTIN("comptags", 0, bin_comptags, 1, -1, 0, NULL, NULL),
        -: 5081:    BUILTIN("comptry", 0, bin_comptry, 0, -1, 0, NULL, NULL),
        -: 5082:    BUILTIN("compvalues", 0, bin_compvalues, 1, -1, 0, NULL, NULL)
        -: 5083:};
        -: 5084:
        -: 5085:static struct features module_features = {
        -: 5086:    bintab, sizeof(bintab)/sizeof(*bintab),
        -: 5087:    NULL, 0,
        -: 5088:    NULL, 0,
        -: 5089:    NULL, 0,
        -: 5090:    0
        -: 5091:};
        -: 5092:
        -: 5093:
        -: 5094:/**/
        -: 5095:int
        1: 5096:setup_(UNUSED(Module m))
        -: 5097:{
        1: 5098:    memset(cadef_cache, 0, sizeof(cadef_cache));
        1: 5099:    memset(cvdef_cache, 0, sizeof(cvdef_cache));
        -: 5100:
        1: 5101:    memset(comptags, 0, sizeof(comptags));
        -: 5102:
        1: 5103:    lasttaglevel = 0;
        -: 5104:
        1: 5105:    return 0;
        -: 5106:}
        -: 5107:
        -: 5108:/**/
        -: 5109:int
        4: 5110:features_(Module m, char ***features)
        -: 5111:{
        4: 5112:    *features = featuresarray(m, &module_features);
        4: 5113:    return 0;
        -: 5114:}
        -: 5115:
        -: 5116:/**/
        -: 5117:int
        8: 5118:enables_(Module m, int **enables)
        -: 5119:{
        8: 5120:    return handlefeatures(m, &module_features, enables);
        -: 5121:}
        -: 5122:
        -: 5123:/**/
        -: 5124:int
        1: 5125:boot_(UNUSED(Module m))
        -: 5126:{
        1: 5127:    return 0;
        -: 5128:}
        -: 5129:
        -: 5130:/**/
        -: 5131:int
    #####: 5132:cleanup_(Module m)
        -: 5133:{
    #####: 5134:    return setfeatureenables(m, &module_features, NULL);
        -: 5135:}
        -: 5136:
        -: 5137:/**/
        -: 5138:int
    #####: 5139:finish_(UNUSED(Module m))
        -: 5140:{
        -: 5141:    int i;
        -: 5142:
    #####: 5143:    for (i = 0; i < MAX_CACACHE; i++)
    #####: 5144:	freecadef(cadef_cache[i]);
    #####: 5145:    for (i = 0; i < MAX_CVCACHE; i++)
    #####: 5146:	freecvdef(cvdef_cache[i]);
        -: 5147:
    #####: 5148:    for (i = 0; i < MAX_TAGS; i++)
    #####: 5149:	freectags(comptags[i]);
        -: 5150:
    #####: 5151:    return 0;
        -: 5152:}
