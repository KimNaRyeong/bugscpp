        -:    0:Source:hist.c
        -:    0:Programs:1
        -:    1:/*
        -:    2: * hist.c - history expansion
        -:    3: *
        -:    4: * This file is part of zsh, the Z shell.
        -:    5: *
        -:    6: * Copyright (c) 1992-1997 Paul Falstad
        -:    7: * All rights reserved.
        -:    8: *
        -:    9: * Permission is hereby granted, without written agreement and without
        -:   10: * license or royalty fees, to use, copy, modify, and distribute this
        -:   11: * software and to distribute modified versions of this software for any
        -:   12: * purpose, provided that the above copyright notice and the following
        -:   13: * two paragraphs appear in all copies of this software.
        -:   14: *
        -:   15: * In no event shall Paul Falstad or the Zsh Development Group be liable
        -:   16: * to any party for direct, indirect, special, incidental, or consequential
        -:   17: * damages arising out of the use of this software and its documentation,
        -:   18: * even if Paul Falstad and the Zsh Development Group have been advised of
        -:   19: * the possibility of such damage.
        -:   20: *
        -:   21: * Paul Falstad and the Zsh Development Group specifically disclaim any
        -:   22: * warranties, including, but not limited to, the implied warranties of
        -:   23: * merchantability and fitness for a particular purpose.  The software
        -:   24: * provided hereunder is on an "as is" basis, and Paul Falstad and the
        -:   25: * Zsh Development Group have no obligation to provide maintenance,
        -:   26: * support, updates, enhancements, or modifications.
        -:   27: *
        -:   28: */
        -:   29:
        -:   30:#include "zsh.mdh"
        -:   31:#include "hist.pro"
        -:   32:
        -:   33:/* Functions to call for getting/ungetting a character and for history
        -:   34: * word control. */
        -:   35:
        -:   36:/**/
        -:   37:mod_export int (*hgetc) _((void));
        -:   38:
        -:   39:/**/
        -:   40:void (*hungetc) _((int));
        -:   41:
        -:   42:/**/
        -:   43:void (*hwaddc) _((int));
        -:   44:
        -:   45:/**/
        -:   46:void (*hwbegin) _((int));
        -:   47:
        -:   48:/**/
        -:   49:void (*hwabort) _((void));
        -:   50:
        -:   51:/**/
        -:   52:void (*hwend) _((void));
        -:   53:
        -:   54:/**/
        -:   55:void (*addtoline) _((int));
        -:   56:
        -:   57:/* != 0 means history substitution is turned off */
        -:   58: 
        -:   59:/**/
        -:   60:mod_export int stophist;
        -:   61:
        -:   62:/* if != 0, we are expanding the current line */
        -:   63:
        -:   64:/**/
        -:   65:mod_export int expanding;
        -:   66:
        -:   67:/* these are used to modify the cursor position during expansion */
        -:   68:
        -:   69:/**/
        -:   70:mod_export int excs, exlast;
        -:   71:
        -:   72:/*
        -:   73: * Current history event number
        -:   74: *
        -:   75: * Note on curhist: with history inactive, this points to the
        -:   76: * last line actually added to the history list.  With history active,
        -:   77: * the line does not get added to the list until hend(), if at all.
        -:   78: * However, curhist is incremented to reflect the current line anyway
        -:   79: * and a temporary history entry is inserted while the user is editing.
        -:   80: * If the resulting line was not added to the list, a flag is set so
        -:   81: * that curhist will be decremented in hbegin().
        -:   82: *
        -:   83: * Note curhist is passed to zle on variable length argument list:
        -:   84: * type must match that retrieved in zle_main_entry.
        -:   85: */
        -:   86: 
        -:   87:/**/
        -:   88:mod_export zlong curhist;
        -:   89:
        -:   90:/**/
        -:   91:struct histent curline;
        -:   92:
        -:   93:/* current line count of allocated history entries */
        -:   94:
        -:   95:/**/
        -:   96:zlong histlinect;
        -:   97:
        -:   98:/* The history lines are kept in a hash, and also doubly-linked in a ring */
        -:   99:
        -:  100:/**/
        -:  101:HashTable histtab;
        -:  102:/**/
        -:  103:mod_export Histent hist_ring;
        -:  104: 
        -:  105:/* capacity of history lists */
        -:  106: 
        -:  107:/**/
        -:  108:zlong histsiz;
        -:  109: 
        -:  110:/* desired history-file size (in lines) */
        -:  111: 
        -:  112:/**/
        -:  113:zlong savehistsiz;
        -:  114: 
        -:  115:/* if = 1, we have performed history substitution on the current line *
        -:  116: * if = 2, we have used the 'p' modifier                              */
        -:  117: 
        -:  118:/**/
        -:  119:int histdone;
        -:  120: 
        -:  121:/* state of the history mechanism */
        -:  122: 
        -:  123:/**/
        -:  124:int histactive;
        -:  125:
        -:  126:/* Current setting of the associated option, but sometimes also includes
        -:  127: * the setting of the HIST_SAVE_NO_DUPS option. */
        -:  128:
        -:  129:/**/
        -:  130:int hist_ignore_all_dups;
        -:  131:
        -:  132:/* What flags (if any) we should skip when moving through the history */
        -:  133:
        -:  134:/**/
        -:  135:mod_export int hist_skip_flags;
        -:  136:
        -:  137:/* Bits of histactive variable */
        -:  138:#define HA_ACTIVE	(1<<0)	/* History mechanism is active */
        -:  139:#define HA_NOINC	(1<<1)	/* Don't store, curhist not incremented */
        -:  140:#define HA_INWORD       (1<<2)  /* We're inside a word, don't add
        -:  141:				   start and end markers */
        -:  142:#define HA_UNGET        (1<<3)  /* Recursively ungetting */
        -:  143:
        -:  144:/* Array of word beginnings and endings in current history line. */
        -:  145:
        -:  146:/**/
        -:  147:short *chwords;
        -:  148:
        -:  149:/* Max, actual position in chwords.
        -:  150: * nwords = chwordpos/2 because we record beginning and end of words.
        -:  151: */
        -:  152:
        -:  153:/**/
        -:  154:int chwordlen, chwordpos;
        -:  155:
        -:  156:/* the last l for s/l/r/ history substitution */
        -:  157: 
        -:  158:/**/
        -:  159:char *hsubl;
        -:  160:
        -:  161:/* the last r for s/l/r/ history substitution */
        -:  162: 
        -:  163:/**/
        -:  164:char *hsubr;
        -:  165: 
        -:  166:/* pointer into the history line */
        -:  167: 
        -:  168:/**/
        -:  169:mod_export char *hptr;
        -:  170: 
        -:  171:/* the current history line */
        -:  172: 
        -:  173:/**/
        -:  174:mod_export char *chline;
        -:  175:
        -:  176:/*
        -:  177: * The current history line as seen by ZLE.
        -:  178: * We modify chline for use in other contexts while ZLE may
        -:  179: * still be running; ZLE should see only the top-level value.
        -:  180: *
        -:  181: * To avoid having to modify this every time we modify chline,
        -:  182: * we set it when we push the stack, and unset it when we pop
        -:  183: * the appropriate value off the stack.  As it's never modified
        -:  184: * on the stack this is the only maintenance we ever do on it.
        -:  185: * In return, ZLE has to check both zle_chline and (if that's
        -:  186: * NULL) chline to get the current value.
        -:  187: */
        -:  188:
        -:  189:/**/
        -:  190:mod_export char *zle_chline;
        -:  191:
        -:  192:/* true if the last character returned by hgetc was an escaped bangchar *
        -:  193: * if it is set and NOBANGHIST is unset hwaddc escapes bangchars        */
        -:  194:
        -:  195:/**/
        -:  196:int qbang;
        -:  197: 
        -:  198:/* max size of histline */
        -:  199: 
        -:  200:/**/
        -:  201:int hlinesz;
        -:  202: 
        -:  203:/* default event (usually curhist-1, that is, "!!") */
        -:  204: 
        -:  205:static zlong defev;
        -:  206:
        -:  207:/*
        -:  208: * Flag that we stopped reading line when we got to a comment,
        -:  209: * but we want to keep it in the histofy even if there were no words
        -:  210: * (i.e. the comment was the entire line).
        -:  211: */
        -:  212:static int hist_keep_comment;
        -:  213:
        -:  214:/* Remember the last line in the history file so we can find it again. */
        -:  215:static struct histfile_stats {
        -:  216:    char *text;
        -:  217:    time_t stim, mtim;
        -:  218:    off_t fpos, fsiz;
        -:  219:    int interrupted;
        -:  220:    zlong next_write_ev;
        -:  221:} lasthist;
        -:  222:
        -:  223:static struct histsave {
        -:  224:    struct histfile_stats lasthist;
        -:  225:    char *histfile;
        -:  226:    HashTable histtab;
        -:  227:    Histent hist_ring;
        -:  228:    zlong curhist;
        -:  229:    zlong histlinect;
        -:  230:    zlong histsiz;
        -:  231:    zlong savehistsiz;
        -:  232:    int locallevel;
        -:  233:} *histsave_stack;
        -:  234:static int histsave_stack_size = 0;
        -:  235:static int histsave_stack_pos = 0;
        -:  236:
        -:  237:static zlong histfile_linect;
        -:  238:
        -:  239:/* save history context */
        -:  240:
        -:  241:/**/
        -:  242:void
     1829:  243:hist_context_save(struct hist_stack *hs, int toplevel)
        -:  244:{
     1829:  245:    if (toplevel) {
        -:  246:	/* top level, make this version visible to ZLE */
     1829:  247:	zle_chline = chline;
        -:  248:	/* ensure line stored is NULL-terminated */
     1829:  249:	if (hptr)
    #####:  250:	    *hptr = '\0';
        -:  251:    }
     1829:  252:    hs->histactive = histactive;
     1829:  253:    hs->histdone = histdone;
     1829:  254:    hs->stophist = stophist;
     1829:  255:    hs->hline = chline;
     1829:  256:    hs->hptr = hptr;
     1829:  257:    hs->chwords = chwords;
     1829:  258:    hs->chwordlen = chwordlen;
     1829:  259:    hs->chwordpos = chwordpos;
     1829:  260:    hs->hgetc = hgetc;
     1829:  261:    hs->hungetc = hungetc;
     1829:  262:    hs->hwaddc = hwaddc;
     1829:  263:    hs->hwbegin = hwbegin;
     1829:  264:    hs->hwabort = hwabort;
     1829:  265:    hs->hwend = hwend;
     1829:  266:    hs->addtoline = addtoline;
     1829:  267:    hs->hlinesz = hlinesz;
     1829:  268:    hs->defev = defev;
     1829:  269:    hs->hist_keep_comment = hist_keep_comment;
        -:  270:    /*
        -:  271:     * We save and restore the command stack with history
        -:  272:     * as it's visible to the user interactively, so if
        -:  273:     * we're preserving history state we'll continue to
        -:  274:     * show the current set of commands from input.
        -:  275:     */
     1829:  276:    hs->cstack = cmdstack;
     1829:  277:    hs->csp = cmdsp;
        -:  278:
     1829:  279:    stophist = 0;
     1829:  280:    chline = NULL;
     1829:  281:    hptr = NULL;
     1829:  282:    histactive = 0;
     1829:  283:    cmdstack = (unsigned char *)zalloc(CMDSTACKSZ);
     1829:  284:    cmdsp = 0;
     1829:  285:}
        -:  286:
        -:  287:/* restore history context */
        -:  288:
        -:  289:/**/
        -:  290:void
     1829:  291:hist_context_restore(const struct hist_stack *hs, int toplevel)
        -:  292:{
     1829:  293:    if (toplevel) {
        -:  294:	/* Back to top level: don't need special ZLE value */
        -:  295:	DPUTS(hs->hline != zle_chline, "BUG: Ouch, wrong chline for ZLE");
     1829:  296:	zle_chline = NULL;
        -:  297:    }
     1829:  298:    histactive = hs->histactive;
     1829:  299:    histdone = hs->histdone;
     1829:  300:    stophist = hs->stophist;
     1829:  301:    chline = hs->hline;
     1829:  302:    hptr = hs->hptr;
     1829:  303:    chwords = hs->chwords;
     1829:  304:    chwordlen = hs->chwordlen;
     1829:  305:    chwordpos = hs->chwordpos;
     1829:  306:    hgetc = hs->hgetc;
     1829:  307:    hungetc = hs->hungetc;
     1829:  308:    hwaddc = hs->hwaddc;
     1829:  309:    hwbegin = hs->hwbegin;
     1829:  310:    hwabort = hs->hwabort;
     1829:  311:    hwend = hs->hwend;
     1829:  312:    addtoline = hs->addtoline;
     1829:  313:    hlinesz = hs->hlinesz;
     1829:  314:    defev = hs->defev;
     1829:  315:    hist_keep_comment = hs->hist_keep_comment;
     1829:  316:    if (cmdstack)
     1829:  317:	zfree(cmdstack, CMDSTACKSZ);
     1829:  318:    cmdstack = hs->cstack;
     1829:  319:    cmdsp = hs->csp;
     1829:  320:}
        -:  321:
        -:  322:/*
        -:  323: * Mark that the current level of history is within a word whatever
        -:  324: * characters turn up, or turn that mode off.  This is used for nested
        -:  325: * parsing of substitutions.
        -:  326: *
        -:  327: * The caller takes care only to turn this on or off at the start
        -:  328: * or end of recursive use of the same mode, so a single flag is
        -:  329: * good enough here.
        -:  330: */
        -:  331:
        -:  332:/**/
        -:  333:void
       24:  334:hist_in_word(int yesno)
        -:  335:{
       24:  336:    if (yesno)
       12:  337:	histactive |= HA_INWORD;
        -:  338:    else
       12:  339:	histactive &= ~HA_INWORD;
       24:  340:}
        -:  341:
        -:  342:/**/
        -:  343:int
    #####:  344:hist_is_in_word(void)
        -:  345:{
    #####:  346:    return (histactive & HA_INWORD) ? 1 : 0;
        -:  347:}
        -:  348:
        -:  349:/* add a character to the current history word */
        -:  350:
        -:  351:static void
    #####:  352:ihwaddc(int c)
        -:  353:{
        -:  354:    /* Only if history line exists and lexing has not finished. */
    #####:  355:    if (chline && !(errflag || lexstop) &&
        -:  356:	/*
        -:  357:	 * If we're reading inside a word for command substitution
        -:  358:	 * we allow the lexer to expand aliases but don't deal
        -:  359:	 * with them here.  Note matching code in ihungetc().
        -:  360:	 * TBD: it might be neater to deal with all aliases in this
        -:  361:	 * fashion as we never need the expansion in the history
        -:  362:	 * line, only in the lexer and above.
        -:  363:	 */
    #####:  364:	(inbufflags & (INP_ALIAS|INP_HIST)) != INP_ALIAS) {
        -:  365:	/* Quote un-expanded bangs in the history line. */
    #####:  366:	if (c == bangchar && stophist < 2 && qbang)
        -:  367:	    /* If qbang is not set, we do not escape this bangchar as it's *
        -:  368:	     * not necessary (e.g. it's a bang in !=, or it is followed    *
        -:  369:	     * by a space). Roughly speaking, qbang is zero only if the    *
        -:  370:	     * history interpreter has already digested this bang and      *
        -:  371:	     * found that it is not necessary to escape it.                */
    #####:  372:	    hwaddc('\\');
    #####:  373:	*hptr++ = c;
        -:  374:
        -:  375:	/* Resize history line if necessary */
    #####:  376:	if (hptr - chline >= hlinesz) {
    #####:  377:	    int oldsiz = hlinesz;
        -:  378:
    #####:  379:	    chline = realloc(chline, hlinesz = oldsiz + 64);
    #####:  380:	    hptr = chline + oldsiz;
        -:  381:	}
        -:  382:    }
    #####:  383:}
        -:  384:
        -:  385:/* This function adds a character to the zle input line. It is used when *
        -:  386: * zsh expands history (see doexpandhist() in zle_tricky.c). It also     *
        -:  387: * calculates the new cursor position after the expansion. It is called  *
        -:  388: * from hgetc() and from gettok() in lex.c for characters in comments.   */
        -:  389:
        -:  390:/**/
        -:  391:void
    #####:  392:iaddtoline(int c)
        -:  393:{
    #####:  394:    if (!expanding || lexstop)
    #####:  395:	return;
    #####:  396:    if (qbang && c == bangchar && stophist < 2) {
    #####:  397:	exlast--;
    #####:  398:	zleentry(ZLE_CMD_ADD_TO_LINE, '\\');
        -:  399:    }
    #####:  400:    if (excs > zlemetacs) {
    #####:  401:	excs += 1 + inbufct - exlast;
    #####:  402:	if (excs < zlemetacs)
        -:  403:	    /* this case could be handled better but it is    *
        -:  404:	     * so rare that it does not worth it              */
    #####:  405:	    excs = zlemetacs;
        -:  406:    }
    #####:  407:    exlast = inbufct;
    #####:  408:    zleentry(ZLE_CMD_ADD_TO_LINE, itok(c) ? ztokens[c - Pound] : c);
        -:  409:}
        -:  410:
        -:  411:
        -:  412:static int
    #####:  413:ihgetc(void)
        -:  414:{
    #####:  415:    int c = ingetc();
        -:  416:
    #####:  417:    if (exit_pending)
        -:  418:    {
    #####:  419:	lexstop = 1;
    #####:  420:	errflag |= ERRFLAG_ERROR;
    #####:  421:	return ' ';
        -:  422:    }
    #####:  423:    qbang = 0;
    #####:  424:    if (!stophist && !(inbufflags & INP_ALIAS)) {
        -:  425:	/* If necessary, expand history characters. */
    #####:  426:	c = histsubchar(c);
    #####:  427:	if (c < 0) {
        -:  428:	    /* bad expansion */
    #####:  429:	    lexstop = 1;
    #####:  430:	    errflag |= ERRFLAG_ERROR;
    #####:  431:	    return ' ';
        -:  432:	}
        -:  433:    }
    #####:  434:    if ((inbufflags & INP_HIST) && !stophist) {
        -:  435:	/* the current character c came from a history expansion          *
        -:  436:	 * (inbufflags & INP_HIST) and history is not disabled            *
        -:  437:	 * (e.g. we are not inside single quotes). In that case, \!       *
        -:  438:	 * should be treated as ! (since this \! came from a previous     *
        -:  439:	 * history line where \ was used to escape the bang). So if       *
        -:  440:	 * c == '\\' we fetch one more character to see if it's a bang,   *
        -:  441:	 * and if it is not, we unget it and reset c back to '\\'         */
    #####:  442:	qbang = 0;
    #####:  443:	if (c == '\\' && !(qbang = (c = ingetc()) == bangchar))
    #####:  444:	    safeinungetc(c), c = '\\';
    #####:  445:    } else if (stophist || (inbufflags & INP_ALIAS))
        -:  446:	/* If the result is a bangchar which came from history or alias  *
        -:  447:	 * expansion, we treat it as an escaped bangchar, unless history *
        -:  448:	 * is disabled. If stophist == 1 it only means that history is   *
        -:  449:	 * temporarily disabled by a !" which won't appear in the        *
        -:  450:	 * history, so we still have an escaped bang. stophist > 1 if    *
        -:  451:	 * history is disabled with NOBANGHIST or by someone else (e.g.  *
        -:  452:	 * when the lexer scans single quoted text).                     */
    #####:  453:	qbang = c == bangchar && (stophist < 2);
    #####:  454:    hwaddc(c);
    #####:  455:    addtoline(c);
        -:  456:
    #####:  457:    return c;
        -:  458:}
        -:  459:
        -:  460:/**/
        -:  461:static void
    #####:  462:safeinungetc(int c)
        -:  463:{
    #####:  464:    if (lexstop)
    #####:  465:	lexstop = 0;
        -:  466:    else
    #####:  467:	inungetc(c);
    #####:  468:}
        -:  469:
        -:  470:/**/
        -:  471:void
    #####:  472:herrflush(void)
        -:  473:{
    #####:  474:    inpopalias();
        -:  475:
    #####:  476:    if (lexstop)
    #####:  477:	return;
        -:  478:    /*
        -:  479:     * The lex_add_raw test is needed if we are parsing a command
        -:  480:     * substitution when expanding history for ZLE: strin is set but we
        -:  481:     * need to finish off the input because the string we are reading is
        -:  482:     * going to be used directly in the line that goes to ZLE.
        -:  483:     *
        -:  484:     * Note that this is a side effect --- this is not the usual reason
        -:  485:     * for testing lex_add_raw which is to add the text to a different
        -:  486:     * buffer used when we are actually parsing the command substitution
        -:  487:     * (nothing to do with ZLE).  Sorry.
        -:  488:     */
    #####:  489:    while (inbufct && (!strin || lex_add_raw)) {
    #####:  490:	int c = ingetc();
    #####:  491:	if (!lexstop) {
    #####:  492:	    hwaddc(c);
    #####:  493:	    addtoline(c);
        -:  494:	}
        -:  495:    }
        -:  496:}
        -:  497:
        -:  498:/*
        -:  499: * Extract :s/foo/bar/ delimiters and arguments
        -:  500: *
        -:  501: * The first character expected is the first delimiter.
        -:  502: * The arguments are stored in the hsubl and hsubr variables.
        -:  503: *
        -:  504: * subline is the part of the command line to be matched.
        -:  505: *
        -:  506: * If a ':' was found but was not followed by a 'G',
        -:  507: * *cflagp is set to 1 and the input is backed up to the
        -:  508: * character following the colon.
        -:  509: */
        -:  510:
        -:  511:/**/
        -:  512:static int
    #####:  513:getsubsargs(UNUSED(char *subline), int *gbalp, int *cflagp)
        -:  514:{
        -:  515:    int del, follow;
        -:  516:    char *ptr1, *ptr2;
        -:  517:
    #####:  518:    del = ingetc();
    #####:  519:    ptr1 = hdynread2(del);
    #####:  520:    if (!ptr1)
    #####:  521:	return 1;
    #####:  522:    ptr2 = hdynread2(del);
    #####:  523:    if (strlen(ptr1)) {
    #####:  524:	zsfree(hsubl);
    #####:  525:	hsubl = ptr1;
    #####:  526:    } else if (!hsubl) {		/* fail silently on this */
    #####:  527:	zsfree(ptr1);
    #####:  528:	zsfree(ptr2);
    #####:  529:	return 0;
        -:  530:    }
    #####:  531:    zsfree(hsubr);
    #####:  532:    hsubr = ptr2;
    #####:  533:    follow = ingetc();
    #####:  534:    if (follow == ':') {
    #####:  535:	follow = ingetc();
    #####:  536:	if (follow == 'G')
    #####:  537:	    *gbalp = 1;
        -:  538:	else {
    #####:  539:	    inungetc(follow);
    #####:  540:	    *cflagp = 1;
        -:  541:	}
        -:  542:    } else
    #####:  543:	inungetc(follow);
    #####:  544:    return 0;
        -:  545:}
        -:  546:
        -:  547:/* Get the maximum no. of words for a history entry. */
        -:  548:
        -:  549:/**/
        -:  550:static int
    #####:  551:getargc(Histent ehist)
        -:  552:{
    #####:  553:    return ehist->nwords ? ehist->nwords-1 : 0;
        -:  554:}
        -:  555:
        -:  556:/**/
        -:  557:static int
    #####:  558:substfailed(void)
        -:  559:{
    #####:  560:    herrflush();
    #####:  561:    zerr("substitution failed");
    #####:  562:    return -1;
        -:  563:}
        -:  564:
        -:  565:/*
        -:  566: * Return a count given by decimal digits after a modifier.
        -:  567: */
        -:  568:static int
    #####:  569:digitcount(void)
        -:  570:{
    #####:  571:    int c = ingetc(), count;
        -:  572:
    #####:  573:    if (idigit(c)) {
    #####:  574:	count = 0;
        -:  575:	do {
    #####:  576:	    count = 10 * count + (c - '0');
    #####:  577:	    c = ingetc();
    #####:  578:	} while (idigit(c));
        -:  579:    }
        -:  580:    else
    #####:  581:	count = 0;
    #####:  582:    inungetc(c);
    #####:  583:    return count;
        -:  584:}
        -:  585:
        -:  586:/* Perform history substitution, returning the next character afterwards. */
        -:  587:
        -:  588:/**/
        -:  589:static int
    #####:  590:histsubchar(int c)
        -:  591:{
    #####:  592:    int farg, evset = -1, larg, argc, cflag = 0, bflag = 0;
        -:  593:    zlong ev;
        -:  594:    static int marg = -1;
        -:  595:    static zlong mev = -1;
        -:  596:    char *buf, *ptr;
        -:  597:    char *sline;
        -:  598:    int lexraw_mark;
        -:  599:    Histent ehist;
        -:  600:    size_t buflen;
        -:  601:
        -:  602:    /*
        -:  603:     * If accumulating raw input for use in command substitution,
        -:  604:     * we don't want the history text, so mark it for later removal.
        -:  605:     * It would be better to do this at a level above the history
        -:  606:     * and below the lexer --- but there isn't one.
        -:  607:     *
        -:  608:     * Include the character we are attempting to substitute.
        -:  609:     */
    #####:  610:    lexraw_mark = zshlex_raw_mark(-1); 
        -:  611:
        -:  612:    /* look, no goto's */
    #####:  613:    if (isfirstch && c == hatchar) {
    #####:  614:	int gbal = 0;
        -:  615:
        -:  616:	/* Line begins ^foo^bar */
    #####:  617:	isfirstch = 0;
    #####:  618:	inungetc(hatchar);
    #####:  619:	if (!(ehist = gethist(defev))
    #####:  620:	    || !(sline = getargs(ehist, 0, getargc(ehist))))
    #####:  621:	    return -1;
        -:  622:
    #####:  623:	if (getsubsargs(sline, &gbal, &cflag))
    #####:  624:	    return substfailed();
    #####:  625:	if (!hsubl)
    #####:  626:	    return -1;
    #####:  627:	if (subst(&sline, hsubl, hsubr, gbal))
    #####:  628:	    return substfailed();
        -:  629:    } else {
        -:  630:	/* Line doesn't begin ^foo^bar */
    #####:  631:	if (c != ' ')
    #####:  632:	    isfirstch = 0;
    #####:  633:	if (c == '\\') {
    #####:  634:	    int g = ingetc();
        -:  635:
    #####:  636:	    if (g != bangchar)
    #####:  637:		safeinungetc(g);
        -:  638:	    else {
    #####:  639:		qbang = 1;
    #####:  640:		return bangchar;
        -:  641:	    }
        -:  642:	}
    #####:  643:	if (c != bangchar)
    #####:  644:	    return c;
    #####:  645:	*hptr = '\0';
    #####:  646:	if ((c = ingetc()) == '{') {
    #####:  647:	    bflag = cflag = 1;
    #####:  648:	    c = ingetc();
        -:  649:	}
    #####:  650:	if (c == '\"') {
    #####:  651:	    stophist = 1;
    #####:  652:	    return ingetc();
        -:  653:	}
    #####:  654:	if ((!cflag && inblank(c)) || c == '=' || c == '(' || lexstop) {
    #####:  655:	    safeinungetc(c);
    #####:  656:	    return bangchar;
        -:  657:	}
    #####:  658:	cflag = 0;
    #####:  659:	ptr = buf = zhalloc(buflen = 265);
        -:  660:
        -:  661:	/* get event number */
        -:  662:
    #####:  663:	queue_signals();
    #####:  664:	if (c == '?') {
        -:  665:	    for (;;) {
    #####:  666:		c = ingetc();
    #####:  667:		if (c == '?' || c == '\n' || lexstop)
        -:  668:		    break;
        -:  669:		else {
    #####:  670:		    *ptr++ = c;
    #####:  671:		    if (ptr == buf + buflen) {
    #####:  672:			buf = hrealloc(buf, buflen, 2 * buflen);
    #####:  673:			ptr = buf + buflen;
    #####:  674:			buflen *= 2;
        -:  675:		    }
        -:  676:		}
        -:  677:	    }
    #####:  678:	    if (c != '\n' && !lexstop)
    #####:  679:		c = ingetc();
    #####:  680:	    *ptr = '\0';
    #####:  681:	    mev = ev = hconsearch(hsubl = ztrdup(buf), &marg);
    #####:  682:	    evset = 0;
    #####:  683:	    if (ev == -1) {
    #####:  684:		herrflush();
    #####:  685:		unqueue_signals();
    #####:  686:		zerr("no such event: %s", buf);
    #####:  687:		return -1;
        -:  688:	    }
        -:  689:	} else {
        -:  690:	    zlong t0;
        -:  691:
        -:  692:	    for (;;) {
    #####:  693:		if (inblank(c) || c == ';' || c == ':' || c == '^' ||
    #####:  694:		    c == '$' || c == '*' || c == '%' || c == '}' ||
    #####:  695:		    c == '\'' || c == '"' || c == '`' || lexstop)
        -:  696:		    break;
    #####:  697:		if (ptr != buf) {
    #####:  698:		    if (c == '-')
    #####:  699:			break;
    #####:  700:		    if ((idigit(buf[0]) || buf[0] == '-') && !idigit(c))
    #####:  701:			break;
        -:  702:		}
    #####:  703:		*ptr++ = c;
    #####:  704:		if (ptr == buf + buflen) {
    #####:  705:		    buf = hrealloc(buf, buflen, 2 * buflen);
    #####:  706:		    ptr = buf + buflen;
    #####:  707:		    buflen *= 2;
        -:  708:		}
    #####:  709:		if (c == '#' || c == bangchar) {
    #####:  710:		    c = ingetc();
    #####:  711:		    break;
        -:  712:		}
    #####:  713:		c = ingetc();
        -:  714:	    }
    #####:  715:	    if (ptr == buf &&
    #####:  716:		(c == '}' ||  c == ';' || c == '\'' || c == '"' || c == '`')) {
        -:  717:	      /* Neither event nor word designator, no expansion */
    #####:  718:	      safeinungetc(c);
    #####:  719:	      unqueue_signals();
    #####:  720:	      return bangchar;
        -:  721:	    }
    #####:  722:	    *ptr = 0;
    #####:  723:	    if (!*buf) {
    #####:  724:		if (c != '%') {
    #####:  725:		    if (isset(CSHJUNKIEHISTORY))
    #####:  726:			ev = addhistnum(curhist,-1,HIST_FOREIGN);
        -:  727:		    else
    #####:  728:			ev = defev;
    #####:  729:		    if (c == ':' && evset == -1)
    #####:  730:			evset = 0;
        -:  731:		    else
    #####:  732:			evset = 1;
        -:  733:		} else {
    #####:  734:		    if (marg != -1)
    #####:  735:			ev = mev;
        -:  736:		    else
    #####:  737:			ev = defev;
    #####:  738:		    evset = 0;
        -:  739:		}
    #####:  740:	    } else if ((t0 = zstrtol(buf, NULL, 10))) {
    #####:  741:		ev = (t0 < 0) ? addhistnum(curhist,t0,HIST_FOREIGN) : t0;
    #####:  742:		evset = 1;
    #####:  743:	    } else if ((unsigned)*buf == bangchar) {
    #####:  744:		ev = addhistnum(curhist,-1,HIST_FOREIGN);
    #####:  745:		evset = 1;
    #####:  746:	    } else if (*buf == '#') {
    #####:  747:		ev = curhist;
    #####:  748:		evset = 1;
    #####:  749:	    } else if ((ev = hcomsearch(buf)) == -1) {
    #####:  750:		herrflush();
    #####:  751:		unqueue_signals();
    #####:  752:		zerr("event not found: %s", buf);
    #####:  753:		return -1;
        -:  754:	    } else
    #####:  755:		evset = 1;
        -:  756:	}
        -:  757:
        -:  758:	/* get the event */
        -:  759:
    #####:  760:	if (!(ehist = gethist(defev = ev))) {
    #####:  761:	    unqueue_signals();
    #####:  762:	    return -1;
        -:  763:	}
        -:  764:	/* extract the relevant arguments */
        -:  765:
    #####:  766:	argc = getargc(ehist);
    #####:  767:	if (c == ':') {
    #####:  768:	    cflag = 1;
    #####:  769:	    c = ingetc();
    #####:  770:	    if (c == '%' && marg != -1) {
    #####:  771:		if (!evset) {
    #####:  772:		    ehist = gethist(defev = mev);
    #####:  773:		    argc = getargc(ehist);
        -:  774:		} else {
    #####:  775:		    herrflush();
    #####:  776:		    unqueue_signals();
    #####:  777:		    zerr("ambiguous history reference");
    #####:  778:		    return -1;
        -:  779:		}
        -:  780:
        -:  781:	    }
        -:  782:	}
    #####:  783:	if (c == '*') {
    #####:  784:	    farg = 1;
    #####:  785:	    larg = argc;
    #####:  786:	    cflag = 0;
        -:  787:	} else {
    #####:  788:	    inungetc(c);
    #####:  789:	    larg = farg = getargspec(argc, marg, evset);
    #####:  790:	    if (larg == -2) {
    #####:  791:		unqueue_signals();
    #####:  792:		return -1;
        -:  793:	    }
    #####:  794:	    if (farg != -1)
    #####:  795:		cflag = 0;
    #####:  796:	    c = ingetc();
    #####:  797:	    if (c == '*') {
    #####:  798:		cflag = 0;
    #####:  799:		larg = argc;
    #####:  800:	    } else if (c == '-') {
    #####:  801:		cflag = 0;
    #####:  802:		larg = getargspec(argc, marg, evset);
    #####:  803:		if (larg == -2) {
    #####:  804:		    unqueue_signals();
    #####:  805:		    return -1;
        -:  806:		}
    #####:  807:		if (larg == -1)
    #####:  808:		    larg = argc - 1;
        -:  809:	    } else
    #####:  810:		inungetc(c);
        -:  811:	}
    #####:  812:	if (farg == -1)
    #####:  813:	    farg = 0;
    #####:  814:	if (larg == -1)
    #####:  815:	    larg = argc;
    #####:  816:	if (!(sline = getargs(ehist, farg, larg))) {
    #####:  817:	    unqueue_signals();
    #####:  818:	    return -1;
        -:  819:	}
    #####:  820:	unqueue_signals();
        -:  821:    }
        -:  822:
        -:  823:    /* do the modifiers */
        -:  824:
        -:  825:    for (;;) {
    #####:  826:	c = (cflag) ? ':' : ingetc();
    #####:  827:	cflag = 0;
    #####:  828:	if (c == ':') {
    #####:  829:	    int gbal = 0;
        -:  830:
    #####:  831:	    if ((c = ingetc()) == 'g') {
    #####:  832:		gbal = 1;
    #####:  833:		c = ingetc();
    #####:  834:		if (c != 's' && c != '&') {
    #####:  835:		    zerr("'s' or '&' modifier expected after 'g'");
    #####:  836:		    return -1;
        -:  837:		}
        -:  838:	    }
    #####:  839:	    switch (c) {
    #####:  840:	    case 'p':
    #####:  841:		histdone = HISTFLAG_DONE | HISTFLAG_NOEXEC;
    #####:  842:		break;
    #####:  843:	    case 'a':
    #####:  844:		if (!chabspath(&sline)) {
    #####:  845:		    herrflush();
    #####:  846:		    zerr("modifier failed: a");
    #####:  847:		    return -1;
        -:  848:		}
    #####:  849:		break;
        -:  850:
    #####:  851:	    case 'A':
    #####:  852:		if (!chrealpath(&sline, 'A', 1)) {
    #####:  853:		    herrflush();
    #####:  854:		    zerr("modifier failed: A");
    #####:  855:		    return -1;
        -:  856:		}
    #####:  857:		break;
    #####:  858:	    case 'c':
    #####:  859:		if (!(sline = equalsubstr(sline, 0, 0))) {
    #####:  860:		    herrflush();
    #####:  861:		    zerr("modifier failed: c");
    #####:  862:		    return -1;
        -:  863:		}
    #####:  864:		break;
    #####:  865:	    case 'h':
    #####:  866:		if (!remtpath(&sline, digitcount())) {
    #####:  867:		    herrflush();
    #####:  868:		    zerr("modifier failed: h");
    #####:  869:		    return -1;
        -:  870:		}
    #####:  871:		break;
    #####:  872:	    case 'e':
    #####:  873:		if (!rembutext(&sline)) {
    #####:  874:		    herrflush();
    #####:  875:		    zerr("modifier failed: e");
    #####:  876:		    return -1;
        -:  877:		}
    #####:  878:		break;
    #####:  879:	    case 'r':
    #####:  880:		if (!remtext(&sline)) {
    #####:  881:		    herrflush();
    #####:  882:		    zerr("modifier failed: r");
    #####:  883:		    return -1;
        -:  884:		}
    #####:  885:		break;
    #####:  886:	    case 't':
    #####:  887:		if (!remlpaths(&sline, digitcount())) {
    #####:  888:		    herrflush();
    #####:  889:		    zerr("modifier failed: t");
    #####:  890:		    return -1;
        -:  891:		}
    #####:  892:		break;
    #####:  893:	    case 's':
    #####:  894:		if (getsubsargs(sline, &gbal, &cflag))
    #####:  895:		    return -1; /* fall through */
        -:  896:	    case '&':
    #####:  897:		if (hsubl && hsubr) {
    #####:  898:		    if (subst(&sline, hsubl, hsubr, gbal))
    #####:  899:			return substfailed();
        -:  900:		} else {
    #####:  901:		    herrflush();
    #####:  902:		    zerr("no previous substitution");
    #####:  903:		    return -1;
        -:  904:		}
    #####:  905:		break;
    #####:  906:	    case 'q':
    #####:  907:		quote(&sline);
    #####:  908:		break;
    #####:  909:	    case 'Q':
        -:  910:		{
    #####:  911:		    int one = noerrs, oef = errflag;
        -:  912:
    #####:  913:		    noerrs = 1;
    #####:  914:		    parse_subst_string(sline);
    #####:  915:		    noerrs = one;
    #####:  916:		    errflag = oef | (errflag & ERRFLAG_INT);
    #####:  917:		    remnulargs(sline);
    #####:  918:		    untokenize(sline);
        -:  919:		}
    #####:  920:		break;
    #####:  921:	    case 'x':
    #####:  922:		quotebreak(&sline);
    #####:  923:		break;
    #####:  924:	    case 'l':
    #####:  925:		sline = casemodify(sline, CASMOD_LOWER);
    #####:  926:		break;
    #####:  927:	    case 'u':
    #####:  928:		sline = casemodify(sline, CASMOD_UPPER);
    #####:  929:		break;
    #####:  930:	    case 'P':
    #####:  931:		if (*sline != '/') {
    #####:  932:		    char *here = zgetcwd();
    #####:  933:		    if (here[strlen(here)-1] != '/')
    #####:  934:			sline = zhtricat(metafy(here, -1, META_HEAPDUP), "/", sline);
        -:  935:		    else
    #####:  936:			sline = dyncat(here, sline);
        -:  937:		}
    #####:  938:		sline = xsymlink(sline, 1);
    #####:  939:		break;
    #####:  940:	    default:
    #####:  941:		herrflush();
    #####:  942:		zerr("illegal modifier: %c", c);
    #####:  943:		return -1;
        -:  944:	    }
        -:  945:	} else {
    #####:  946:	    if (c != '}' || !bflag)
    #####:  947:		inungetc(c);
    #####:  948:	    if (c != '}' && bflag) {
    #####:  949:		zerr("'}' expected");
    #####:  950:		return -1;
        -:  951:	    }
    #####:  952:	    break;
        -:  953:	}
        -:  954:    }
        -:  955:
    #####:  956:    zshlex_raw_back_to_mark(lexraw_mark);
        -:  957:
        -:  958:    /*
        -:  959:     * Push the expanded value onto the input stack,
        -:  960:     * marking this as a history word for purposes of the alias stack.
        -:  961:     */
        -:  962:
    #####:  963:    lexstop = 0;
        -:  964:    /* this function is called only called from hgetc and only if      *
        -:  965:     * !(inbufflags & INP_ALIAS). History expansion should never be    *
        -:  966:     * done with INP_ALIAS (to prevent recursive history expansion and *
        -:  967:     * histoty expansion of aliases). Escapes are not removed here.    *
        -:  968:     * This is now handled in hgetc.                                   */
    #####:  969:    inpush(sline, INP_HIST, NULL); /* sline from heap, don't free */
    #####:  970:    histdone |= HISTFLAG_DONE;
    #####:  971:    if (isset(HISTVERIFY))
    #####:  972:	histdone |= HISTFLAG_NOEXEC | HISTFLAG_RECALL;
        -:  973:
        -:  974:    /* Don't try and re-expand line. */
    #####:  975:    return ingetc();
        -:  976:}
        -:  977:
        -:  978:/* unget a char and remove it from chline. It can only be used *
        -:  979: * to unget a character returned by hgetc.                     */
        -:  980:
        -:  981:static void
    #####:  982:ihungetc(int c)
        -:  983:{
    #####:  984:    int doit = 1;
        -:  985:
    #####:  986:    while (!lexstop && !errflag) {
    #####:  987:	if (hptr[-1] != (char) c && stophist < 4 &&
    #####:  988:	    hptr > chline + 1 && hptr[-1] == '\n' && hptr[-2] == '\\' &&
    #####:  989:	    !(histactive & HA_UNGET) &&
    #####:  990:	    (inbufflags & (INP_ALIAS|INP_HIST)) != INP_ALIAS) {
    #####:  991:	    histactive |= HA_UNGET;
    #####:  992:	    hungetc('\n');
    #####:  993:	    hungetc('\\');
    #####:  994:	    histactive &= ~HA_UNGET;
        -:  995:	}
        -:  996:
    #####:  997:	if (expanding) {
    #####:  998:	    zlemetacs--;
    #####:  999:	    zlemetall--;
    #####: 1000:	    exlast++;
        -: 1001:	}
    #####: 1002:	if ((inbufflags & (INP_ALIAS|INP_HIST)) != INP_ALIAS) {
        -: 1003:	    DPUTS(hptr <= chline, "BUG: hungetc attempted at buffer start");
    #####: 1004:	    hptr--;
        -: 1005:	    DPUTS(*hptr != (char) c, "BUG: wrong character in hungetc() ");
    #####: 1006:	    qbang = (c == bangchar && stophist < 2 &&
    #####: 1007:		     hptr > chline && hptr[-1] == '\\');
        -: 1008:	} else {
        -: 1009:	    /* No active bangs in aliases */
    #####: 1010:	    qbang = 0;
        -: 1011:	}
    #####: 1012:	if (doit)
    #####: 1013:	    inungetc(c);
    #####: 1014:	if (!qbang)
    #####: 1015:	    return;
    #####: 1016:	doit = !stophist && ((inbufflags & INP_HIST) ||
    #####: 1017:				 !(inbufflags & INP_ALIAS));
    #####: 1018:	c = '\\';
        -: 1019:    }
        -: 1020:}
        -: 1021:
        -: 1022:/* begin reading a string */
        -: 1023:
        -: 1024:/**/
        -: 1025:mod_export void
     1829: 1026:strinbeg(int dohist)
        -: 1027:{
     1829: 1028:    strin++;
     1829: 1029:    hbegin(dohist);
     1829: 1030:    lexinit();
        -: 1031:    /*
        -: 1032:     * Also initialise some variables owned by the parser but
        -: 1033:     * used for communication between the parser and lexer.
        -: 1034:     */
     1829: 1035:    init_parse_status();
     1829: 1036:}
        -: 1037:
        -: 1038:/* done reading a string */
        -: 1039:
        -: 1040:/**/
        -: 1041:mod_export void
     1829: 1042:strinend(void)
        -: 1043:{
     1829: 1044:    hend(NULL);
        -: 1045:    DPUTS(!strin, "BUG: strinend() called without strinbeg()");
     1829: 1046:    strin--;
     1829: 1047:    isfirstch = 1;
     1829: 1048:    histdone = 0;
     1829: 1049:}
        -: 1050:
        -: 1051:/* dummy functions to use instead of hwaddc(), hwbegin(), and hwend() when
        -: 1052: * they aren't needed */
        -: 1053:
        -: 1054:static void
    13505: 1055:nohw(UNUSED(int c))
        -: 1056:{
    13505: 1057:}
        -: 1058:
        -: 1059:static void
       92: 1060:nohwabort(void)
        -: 1061:{
       92: 1062:}
        -: 1063:
        -: 1064:static void
     4171: 1065:nohwe(void)
        -: 1066:{
     4171: 1067:}
        -: 1068:
        -: 1069:/* these functions handle adding/removing curline to/from the hist_ring */
        -: 1070:
        -: 1071:static void
    #####: 1072:linkcurline(void)
        -: 1073:{
    #####: 1074:    if (!hist_ring)
    #####: 1075:	hist_ring = curline.up = curline.down = &curline;
        -: 1076:    else {
    #####: 1077:	curline.up = hist_ring;
    #####: 1078:	curline.down = hist_ring->down;
    #####: 1079:	hist_ring->down = hist_ring->down->up = &curline;
    #####: 1080:	hist_ring = &curline;
        -: 1081:    }
    #####: 1082:    curline.histnum = ++curhist;
    #####: 1083:}
        -: 1084:
        -: 1085:static void
    #####: 1086:unlinkcurline(void)
        -: 1087:{
    #####: 1088:    curline.up->down = curline.down;
    #####: 1089:    curline.down->up = curline.up;
    #####: 1090:    if (hist_ring == &curline) {
    #####: 1091:	if (!histlinect)
    #####: 1092:	    hist_ring = NULL;
        -: 1093:	else
    #####: 1094:	    hist_ring = curline.up;
        -: 1095:    }
    #####: 1096:    curhist--;
    #####: 1097:}
        -: 1098:
        -: 1099:/* initialize the history mechanism */
        -: 1100:
        -: 1101:/**/
        -: 1102:mod_export void
     2005: 1103:hbegin(int dohist)
        -: 1104:{
        -: 1105:    char *hf;
        -: 1106:
     2005: 1107:    isfirstln = isfirstch = 1;
     2005: 1108:    errflag &= ~ERRFLAG_ERROR;
     2005: 1109:    histdone = 0;
     2005: 1110:    if (!dohist)
     1829: 1111:	stophist = 2;
      176: 1112:    else if (dohist != 2)
      176: 1113:	stophist = (!interact || unset(SHINSTDIN)) ? 2 : 0;
        -: 1114:    else
    #####: 1115:	stophist = 0;
        -: 1116:    /*
        -: 1117:     * pws: We used to test for "|| (inbufflags & INP_ALIAS)"
        -: 1118:     * in this test, but at this point we don't have input
        -: 1119:     * set up so this can trigger unnecessarily.
        -: 1120:     * I don't see how the test at this point could ever be
        -: 1121:     * useful, since we only get here when we're initialising
        -: 1122:     * the history mechanism, before we've done any input.
        -: 1123:     *
        -: 1124:     * (I also don't see any point where this function is called with
        -: 1125:     * dohist=0.)
        -: 1126:     */
     2005: 1127:    if (stophist == 2) {
     2005: 1128:	chline = hptr = NULL;
     2005: 1129:	hlinesz = 0;
     2005: 1130:	chwords = NULL;
     2005: 1131:	chwordlen = 0;
     2005: 1132:	hgetc = ingetc;
     2005: 1133:	hungetc = inungetc;
     2005: 1134:	hwaddc = nohw;
     2005: 1135:	hwbegin = nohw;
     2005: 1136:	hwabort = nohwabort;
     2005: 1137:	hwend = nohwe;
     2005: 1138:	addtoline = nohw;
        -: 1139:    } else {
    #####: 1140:	chline = hptr = zshcalloc(hlinesz = 64);
    #####: 1141:	chwords = zalloc((chwordlen = 64) * sizeof(short));
    #####: 1142:	hgetc = ihgetc;
    #####: 1143:	hungetc = ihungetc;
    #####: 1144:	hwaddc = ihwaddc;
    #####: 1145:	hwbegin = ihwbegin;
    #####: 1146:	hwabort = ihwabort;
    #####: 1147:	hwend = ihwend;
    #####: 1148:	addtoline = iaddtoline;
    #####: 1149:	if (!isset(BANGHIST))
    #####: 1150:	    stophist = 4;
        -: 1151:    }
     2005: 1152:    chwordpos = 0;
        -: 1153:
     2005: 1154:    if (hist_ring && !hist_ring->ftim && !strin)
    #####: 1155:	hist_ring->ftim = time(NULL);
     2005: 1156:    if ((dohist == 2 || (interact && isset(SHINSTDIN))) && !strin) {
    #####: 1157:	histactive = HA_ACTIVE;
    #####: 1158:	attachtty(mypgrp);
    #####: 1159:	linkcurline();
    #####: 1160:	defev = addhistnum(curhist, -1, HIST_FOREIGN);
        -: 1161:    } else
     2005: 1162:	histactive = HA_ACTIVE | HA_NOINC;
        -: 1163:
        -: 1164:    /*
        -: 1165:     * For INCAPPENDHISTORYTIME, when interactive, save the history here
        -: 1166:     * as it gives a better estimate of the times of commands.
        -: 1167:     *
        -: 1168:     * If INCAPPENDHISTORY is also set we've already done it.
        -: 1169:     *
        -: 1170:     * If SHAREHISTORY is also set continue to do so in the
        -: 1171:     * standard place, because that's safer about reading and
        -: 1172:     * rewriting history atomically.
        -: 1173:     *
        -: 1174:     * The histsave_stack_pos test won't usually fail here.
        -: 1175:     * We need to test the opposite for the hend() case because we
        -: 1176:     * need to save in the history file we've switched to, but then
        -: 1177:     * we pop immediately after that so the variable becomes zero.
        -: 1178:     * We will already have saved the line and restored the history
        -: 1179:     * so that (correctly) nothing happens here.  But it shows
        -: 1180:     * I thought about it.
        -: 1181:     */
     2005: 1182:    if (isset(INCAPPENDHISTORYTIME) && !isset(SHAREHISTORY) &&
    #####: 1183:	!isset(INCAPPENDHISTORY) &&
    #####: 1184:	!(histactive & HA_NOINC) && !strin && histsave_stack_pos == 0) {
    #####: 1185:	hf = getsparam("HISTFILE");
    #####: 1186:	savehistfile(hf, 0, HFILE_USE_OPTIONS | HFILE_FAST);
        -: 1187:    }
     2005: 1188:}
        -: 1189:
        -: 1190:/**/
        -: 1191:void
    #####: 1192:histreduceblanks(void)
        -: 1193:{
    #####: 1194:    int i, len, pos, needblank, spacecount = 0, trunc_ok;
        -: 1195:    char *lastptr, *ptr;
        -: 1196:
    #####: 1197:    if (isset(HISTIGNORESPACE))
    #####: 1198:	while (chline[spacecount] == ' ') spacecount++;
        -: 1199:
    #####: 1200:    for (i = 0, len = spacecount; i < chwordpos; i += 2) {
    #####: 1201:	len += chwords[i+1] - chwords[i]
    #####: 1202:	     + (i > 0 && chwords[i] > chwords[i-1]);
        -: 1203:    }
    #####: 1204:    if (chline[len] == '\0')
    #####: 1205:	return;
        -: 1206:
        -: 1207:    /* Remember where the delimited words end */
    #####: 1208:    if (chwordpos)
    #####: 1209:	lastptr = chline + chwords[chwordpos-1];
        -: 1210:    else
    #####: 1211:	lastptr = chline;
        -: 1212:
    #####: 1213:    for (i = 0, pos = spacecount; i < chwordpos; i += 2) {
    #####: 1214:	len = chwords[i+1] - chwords[i];
    #####: 1215:	needblank = (i < chwordpos-2 && chwords[i+2] > chwords[i+1]);
    #####: 1216:	if (pos != chwords[i]) {
    #####: 1217:	    memmove(chline + pos, chline + chwords[i], len + needblank);
    #####: 1218:	    chwords[i] = pos;
    #####: 1219:	    chwords[i+1] = chwords[i] + len;
        -: 1220:	}
    #####: 1221:	pos += len + needblank;
        -: 1222:    }
        -: 1223:
        -: 1224:    /*
        -: 1225:     * A terminating comment isn't recorded as a word.
        -: 1226:     * Only truncate the line if just whitespace remains.
        -: 1227:     */
    #####: 1228:    trunc_ok = 1;
    #####: 1229:    for (ptr = lastptr; *ptr; ptr++) {
    #####: 1230:	if (!inblank(*ptr)) {
    #####: 1231:	    trunc_ok = 0;
    #####: 1232:	    break;
        -: 1233:	}
        -: 1234:    }
    #####: 1235:    if (trunc_ok) {
    #####: 1236:	chline[pos] = '\0';
        -: 1237:    } else {
    #####: 1238:	ptr = chline + pos;
    #####: 1239:	if (ptr < lastptr)
    #####: 1240:	    while ((*ptr++ = *lastptr++))
        -: 1241:		;
        -: 1242:    }
        -: 1243:}
        -: 1244:
        -: 1245:/**/
        -: 1246:void
    #####: 1247:histremovedups(void)
        -: 1248:{
        -: 1249:    Histent he, next;
    #####: 1250:    for (he = hist_ring; he; he = next) {
    #####: 1251:	next = up_histent(he);
    #####: 1252:	if (he->node.flags & HIST_DUP)
    #####: 1253:	    freehistnode(&he->node);
        -: 1254:    }
    #####: 1255:}
        -: 1256:
        -: 1257:/**/
        -: 1258:mod_export zlong
    #####: 1259:addhistnum(zlong hl, int n, int xflags)
        -: 1260:{
    #####: 1261:    int dir = n < 0? -1 : n > 0? 1 : 0;
    #####: 1262:    Histent he = gethistent(hl, dir);
        -: 1263:			     
    #####: 1264:    if (!he)
    #####: 1265:	return 0;
    #####: 1266:    if (he->histnum != hl)
    #####: 1267:	n -= dir;
    #####: 1268:    if (n)
    #####: 1269:	he = movehistent(he, n, xflags);
    #####: 1270:    if (!he)
    #####: 1271:	return dir < 0? firsthist() - 1 : curhist + 1;
    #####: 1272:    return he->histnum;
        -: 1273:}
        -: 1274:
        -: 1275:/**/
        -: 1276:mod_export Histent
    #####: 1277:movehistent(Histent he, int n, int xflags)
        -: 1278:{
    #####: 1279:    while (n < 0) {
    #####: 1280:	if (!(he = up_histent(he)))
    #####: 1281:	    return NULL;
    #####: 1282:	if (!(he->node.flags & xflags))
    #####: 1283:	    n++;
        -: 1284:    }
    #####: 1285:    while (n > 0) {
    #####: 1286:	if (!(he = down_histent(he)))
    #####: 1287:	    return NULL;
    #####: 1288:	if (!(he->node.flags & xflags))
    #####: 1289:	    n--;
        -: 1290:    }
    #####: 1291:    checkcurline(he);
    #####: 1292:    return he;
        -: 1293:}
        -: 1294:
        -: 1295:/**/
        -: 1296:mod_export Histent
    #####: 1297:up_histent(Histent he)
        -: 1298:{
    #####: 1299:    return !he || he->up == hist_ring? NULL : he->up;
        -: 1300:}
        -: 1301:
        -: 1302:/**/
        -: 1303:mod_export Histent
    #####: 1304:down_histent(Histent he)
        -: 1305:{
    #####: 1306:    return he == hist_ring? NULL : he->down;
        -: 1307:}
        -: 1308:
        -: 1309:/**/
        -: 1310:mod_export Histent
    #####: 1311:gethistent(zlong ev, int nearmatch)
        -: 1312:{
        -: 1313:    Histent he;
        -: 1314:
    #####: 1315:    if (!hist_ring)
    #####: 1316:	return NULL;
        -: 1317:
    #####: 1318:    if (ev - hist_ring->down->histnum < hist_ring->histnum - ev) {
    #####: 1319:	for (he = hist_ring->down; he->histnum < ev; he = he->down) ;
    #####: 1320:	if (he->histnum != ev) {
    #####: 1321:	    if (nearmatch == 0
    #####: 1322:	     || (nearmatch < 0 && (he = up_histent(he)) == NULL))
    #####: 1323:		return NULL;
        -: 1324:	}
        -: 1325:    }
        -: 1326:    else {
    #####: 1327:	for (he = hist_ring; he->histnum > ev; he = he->up) ;
    #####: 1328:	if (he->histnum != ev) {
    #####: 1329:	    if (nearmatch == 0
    #####: 1330:	     || (nearmatch > 0 && (he = down_histent(he)) == NULL))
    #####: 1331:		return NULL;
        -: 1332:	}
        -: 1333:    }
        -: 1334:
    #####: 1335:    checkcurline(he);
    #####: 1336:    return he;
        -: 1337:}
        -: 1338:
        -: 1339:static void
    #####: 1340:putoldhistentryontop(short keep_going)
        -: 1341:{
        -: 1342:    static Histent next = NULL;
    #####: 1343:    Histent he = (keep_going || !hist_ring) ? next : hist_ring->down;
    #####: 1344:    if (he)
    #####: 1345:	next = he->down;
        -: 1346:    else
    #####: 1347:	return;
    #####: 1348:    if (isset(HISTEXPIREDUPSFIRST) && !(he->node.flags & HIST_DUP)) {
        -: 1349:	static zlong max_unique_ct = 0;
    #####: 1350:	if (!keep_going)
    #####: 1351:	    max_unique_ct = savehistsiz;
        -: 1352:	do {
    #####: 1353:	    if (max_unique_ct-- <= 0 || he == hist_ring) {
    #####: 1354:		max_unique_ct = 0;
    #####: 1355:		he = hist_ring->down;
    #####: 1356:		next = hist_ring;
    #####: 1357:		break;
        -: 1358:	    }
    #####: 1359:	    he = next;
    #####: 1360:	    next = he->down;
    #####: 1361:	} while (!(he->node.flags & HIST_DUP));
        -: 1362:    }
    #####: 1363:    if (he != hist_ring->down) {
    #####: 1364:	he->up->down = he->down;
    #####: 1365:	he->down->up = he->up;
    #####: 1366:	he->up = hist_ring;
    #####: 1367:	he->down = hist_ring->down;
    #####: 1368:	hist_ring->down = he->down->up = he;
        -: 1369:    }
    #####: 1370:    hist_ring = he;
        -: 1371:}
        -: 1372:
        -: 1373:/**/
        -: 1374:Histent
    #####: 1375:prepnexthistent(void)
        -: 1376:{
        -: 1377:    Histent he; 
    #####: 1378:    int curline_in_ring = hist_ring == &curline;
        -: 1379:
    #####: 1380:    if (curline_in_ring)
    #####: 1381:	unlinkcurline();
    #####: 1382:    if (hist_ring && hist_ring->node.flags & HIST_TMPSTORE) {
    #####: 1383:	curhist--;
    #####: 1384:	freehistnode(&hist_ring->node);
        -: 1385:    }
        -: 1386:
    #####: 1387:    if (histlinect < histsiz || !hist_ring) {
    #####: 1388:	he = (Histent)zshcalloc(sizeof *he);
    #####: 1389:	if (!hist_ring)
    #####: 1390:	    hist_ring = he->up = he->down = he;
        -: 1391:	else {
    #####: 1392:	    he->up = hist_ring;
    #####: 1393:	    he->down = hist_ring->down;
    #####: 1394:	    hist_ring->down = he->down->up = he;
    #####: 1395:	    hist_ring = he;
        -: 1396:	}
    #####: 1397:	histlinect++;
        -: 1398:    }
        -: 1399:    else {
    #####: 1400:	putoldhistentryontop(0);
    #####: 1401:	freehistdata(hist_ring, 0);
    #####: 1402:	he = hist_ring;
        -: 1403:    }
    #####: 1404:    he->histnum = ++curhist;
    #####: 1405:    if (curline_in_ring)
    #####: 1406:	linkcurline();
    #####: 1407:    return he;
        -: 1408:}
        -: 1409:
        -: 1410:/* A helper function for hend() */
        -: 1411:
        -: 1412:static int
    #####: 1413:should_ignore_line(Eprog prog)
        -: 1414:{
    #####: 1415:    if (isset(HISTIGNORESPACE)) {
    #####: 1416:	if (*chline == ' ' || aliasspaceflag)
    #####: 1417:	    return 1;
        -: 1418:    }
        -: 1419:
    #####: 1420:    if (!prog)
    #####: 1421:	return 0;
        -: 1422:
    #####: 1423:    if (isset(HISTNOFUNCTIONS)) {
    #####: 1424:	Wordcode pc = prog->prog;
    #####: 1425:	wordcode code = *pc;
    #####: 1426:	if (wc_code(code) == WC_LIST && WC_LIST_TYPE(code) & Z_SIMPLE
    #####: 1427:	 && wc_code(pc[2]) == WC_FUNCDEF)
    #####: 1428:	    return 1;
        -: 1429:    }
        -: 1430:
    #####: 1431:    if (isset(HISTNOSTORE)) {
    #####: 1432:	char *b = getjobtext(prog, NULL);
        -: 1433:	int saw_builtin;
    #####: 1434:	if (*b == 'b' && strncmp(b,"builtin ",8) == 0) {
    #####: 1435:	    b += 8;
    #####: 1436:	    saw_builtin = 1;
        -: 1437:	} else
    #####: 1438:	    saw_builtin = 0;
    #####: 1439:	if (*b == 'h' && strncmp(b,"history",7) == 0 && (!b[7] || b[7] == ' ')
    #####: 1440:	 && (saw_builtin || !shfunctab->getnode(shfunctab,"history")))
    #####: 1441:	    return 1;
    #####: 1442:	if (*b == 'r' && (!b[1] || b[1] == ' ')
    #####: 1443:	 && (saw_builtin || !shfunctab->getnode(shfunctab,"r")))
    #####: 1444:	    return 1;
    #####: 1445:	if (*b == 'f' && b[1] == 'c' && b[2] == ' ' && b[3] == '-'
    #####: 1446:	 && (saw_builtin || !shfunctab->getnode(shfunctab,"fc"))) {
    #####: 1447:	    b += 3;
        -: 1448:	    do {
    #####: 1449:		if (*++b == 'l')
    #####: 1450:		    return 1;
    #####: 1451:	    } while (ialpha(*b));
        -: 1452:	}
        -: 1453:    }
        -: 1454:
    #####: 1455:    return 0;
        -: 1456:}
        -: 1457:
        -: 1458:/* say we're done using the history mechanism */
        -: 1459:
        -: 1460:/**/
        -: 1461:mod_export int
     2005: 1462:hend(Eprog prog)
        -: 1463:{
     2005: 1464:    int flag, hookret, stack_pos = histsave_stack_pos;
        -: 1465:    /*
        -: 1466:     * save:
        -: 1467:     * 0: don't save
        -: 1468:     * 1: save normally
        -: 1469:     * -1: save temporarily, delete after next line
        -: 1470:     * -2: save internally but mark for not writing
        -: 1471:     */
     2005: 1472:    int save = 1;
        -: 1473:    char *hf;
        -: 1474:
        -: 1475:    DPUTS(stophist != 2 && !(inbufflags & INP_ALIAS) && !chline,
        -: 1476:	  "BUG: chline is NULL in hend()");
     2005: 1477:    queue_signals();
     2005: 1478:    if (histdone & HISTFLAG_SETTY)
    #####: 1479:	settyinfo(&shttyinfo);
     2005: 1480:    if (!(histactive & HA_NOINC))
    #####: 1481:	unlinkcurline();
     2005: 1482:    if (histactive & HA_NOINC) {
     2005: 1483:	zfree(chline, hlinesz);
     2005: 1484:	zfree(chwords, chwordlen*sizeof(short));
     2005: 1485:	chline = hptr = NULL;
     2005: 1486:	chwords = NULL;
     2005: 1487:	histactive = 0;
     2005: 1488:	unqueue_signals();
     2005: 1489:	return 1;
        -: 1490:    }
    #####: 1491:    if (hist_ignore_all_dups != isset(HISTIGNOREALLDUPS)
    #####: 1492:     && (hist_ignore_all_dups = isset(HISTIGNOREALLDUPS)) != 0)
    #####: 1493:	histremovedups();
        -: 1494:
    #####: 1495:    if (hptr) {
        -: 1496:	/*
        -: 1497:	 * Added the following in case the test "hptr < chline + 1"
        -: 1498:	 * is more than just paranoia.
        -: 1499:	 */
        -: 1500:	DPUTS(hptr < chline, "History end pointer off start of line");
    #####: 1501:	*hptr = '\0';
        -: 1502:    }
    #####: 1503:    if (*chline) {
    #####: 1504:	LinkList hookargs = newlinklist();
    #####: 1505:	int save_errflag = errflag;
    #####: 1506:	errflag = 0;
        -: 1507:
    #####: 1508:	addlinknode(hookargs, "zshaddhistory");
    #####: 1509:	addlinknode(hookargs, chline);
    #####: 1510:	callhookfunc("zshaddhistory", hookargs, 1, &hookret);
        -: 1511:
    #####: 1512:	errflag &= ~ERRFLAG_ERROR;
    #####: 1513:	errflag |= save_errflag;
        -: 1514:    }
        -: 1515:    /* For history sharing, lock history file once for both read and write */
    #####: 1516:    hf = getsparam("HISTFILE");
    #####: 1517:    if (isset(SHAREHISTORY) && !lockhistfile(hf, 0)) {
    #####: 1518:	readhistfile(hf, 0, HFILE_USE_OPTIONS | HFILE_FAST);
    #####: 1519:	curline.histnum = curhist+1;
        -: 1520:    }
    #####: 1521:    flag = histdone;
    #####: 1522:    histdone = 0;
    #####: 1523:    if (hptr < chline + 1)
    #####: 1524:	save = 0;
        -: 1525:    else {
    #####: 1526:	if (hptr[-1] == '\n') {
    #####: 1527:	    if (chline[1]) {
    #####: 1528:		*--hptr = '\0';
        -: 1529:	    } else
    #####: 1530:		save = 0;
        -: 1531:	}
    #####: 1532:	if (chwordpos <= 2 && !hist_keep_comment)
    #####: 1533:	    save = 0;
    #####: 1534:	else if (should_ignore_line(prog))
    #####: 1535:	    save = -1;
    #####: 1536:	else if (hookret == 2)
    #####: 1537:	    save = -2;
    #####: 1538:	else if (hookret)
    #####: 1539:	    save = -1;
        -: 1540:    }
    #####: 1541:    if (flag & (HISTFLAG_DONE | HISTFLAG_RECALL)) {
        -: 1542:	char *ptr;
        -: 1543:
    #####: 1544:	ptr = ztrdup(chline);
    #####: 1545:	if ((flag & (HISTFLAG_DONE | HISTFLAG_RECALL)) == HISTFLAG_DONE) {
    #####: 1546:	    zputs(ptr, shout);
    #####: 1547:	    fputc('\n', shout);
    #####: 1548:	    fflush(shout);
        -: 1549:	}
    #####: 1550:	if (flag & HISTFLAG_RECALL) {
    #####: 1551:	    zpushnode(bufstack, ptr);
    #####: 1552:	    save = 0;
        -: 1553:	} else
    #####: 1554:	    zsfree(ptr);
        -: 1555:    }
    #####: 1556:    if (save || *chline == ' ') {
        -: 1557:	Histent he;
    #####: 1558:	for (he = hist_ring; he && he->node.flags & HIST_FOREIGN;
    #####: 1559:	     he = up_histent(he)) ;
    #####: 1560:	if (he && he->node.flags & HIST_TMPSTORE) {
    #####: 1561:	    if (he == hist_ring)
    #####: 1562:		curline.histnum = curhist--;
    #####: 1563:	    freehistnode(&he->node);
        -: 1564:	}
        -: 1565:    }
    #####: 1566:    if (save) {
        -: 1567:	Histent he;
        -: 1568:	int newflags;
        -: 1569:
        -: 1570:#ifdef DEBUG
        -: 1571:	/* debugging only */
        -: 1572:	if (chwordpos%2) {
        -: 1573:	    hwend();
        -: 1574:	    DPUTS(1, "BUG: uncompleted line in history");
        -: 1575:	}
        -: 1576:#endif
        -: 1577:	/* get rid of pesky \n which we've already nulled out */
    #####: 1578:	if (chwordpos > 1 && !chline[chwords[chwordpos-2]]) {
    #####: 1579:	    chwordpos -= 2;
        -: 1580:	    /* strip superfluous blanks, if desired */
    #####: 1581:	    if (isset(HISTREDUCEBLANKS))
    #####: 1582:		histreduceblanks();
        -: 1583:	}
    #####: 1584:	if (save == -1)
    #####: 1585:	    newflags = HIST_TMPSTORE;
    #####: 1586:	else if (save == -2)
    #####: 1587:	    newflags = HIST_NOWRITE;
        -: 1588:	else
    #####: 1589:	    newflags = 0;
    #####: 1590:	if ((isset(HISTIGNOREDUPS) || isset(HISTIGNOREALLDUPS)) && save > 0
    #####: 1591:	 && hist_ring && histstrcmp(chline, hist_ring->node.nam) == 0) {
        -: 1592:	    /* This history entry compares the same as the previous.
        -: 1593:	     * In case minor changes were made, we overwrite the
        -: 1594:	     * previous one with the current one.  This also gets the
        -: 1595:	     * timestamp right.  Perhaps, preserve the HIST_OLD flag.
        -: 1596:	     */
    #####: 1597:	    he = hist_ring;
    #####: 1598:	    newflags |= he->node.flags & HIST_OLD; /* Avoid re-saving */
    #####: 1599:	    freehistdata(he, 0);
    #####: 1600:	    curline.histnum = curhist;
        -: 1601:	} else
    #####: 1602:	    he = prepnexthistent();
        -: 1603:
    #####: 1604:	he->node.nam = ztrdup(chline);
    #####: 1605:	he->stim = time(NULL);
    #####: 1606:	he->ftim = 0L;
    #####: 1607:	he->node.flags = newflags;
        -: 1608:
    #####: 1609:	if ((he->nwords = chwordpos/2)) {
    #####: 1610:	    he->words = (short *)zalloc(chwordpos * sizeof(short));
    #####: 1611:	    memcpy(he->words, chwords, chwordpos * sizeof(short));
        -: 1612:	}
    #####: 1613:	if (!(newflags & HIST_TMPSTORE))
    #####: 1614:	    addhistnode(histtab, he->node.nam, he);
        -: 1615:    }
    #####: 1616:    zfree(chline, hlinesz);
    #####: 1617:    zfree(chwords, chwordlen*sizeof(short));
    #####: 1618:    chline = hptr = NULL;
    #####: 1619:    chwords = NULL;
    #####: 1620:    histactive = 0;
        -: 1621:    /*
        -: 1622:     * For normal INCAPPENDHISTORY case and reasoning, see hbegin().
        -: 1623:     */
    #####: 1624:    if (isset(SHAREHISTORY) ? histfileIsLocked() :
    #####: 1625:	(isset(INCAPPENDHISTORY) || (isset(INCAPPENDHISTORYTIME) &&
    #####: 1626:				     histsave_stack_pos != 0)))
    #####: 1627:	savehistfile(hf, 0, HFILE_USE_OPTIONS | HFILE_FAST);
    #####: 1628:    unlockhistfile(hf); /* It's OK to call this even if we aren't locked */
        -: 1629:    /*
        -: 1630:     * No good reason for the user to push the history more than once, but
        -: 1631:     * it's easy to be tidy...
        -: 1632:     */
    #####: 1633:    while (histsave_stack_pos > stack_pos)
    #####: 1634:	pophiststack();
    #####: 1635:    hist_keep_comment = 0;
    #####: 1636:    unqueue_signals();
    #####: 1637:    return !(flag & HISTFLAG_NOEXEC || errflag);
        -: 1638:}
        -: 1639:
        -: 1640:/* begin a word */
        -: 1641:
        -: 1642:/**/
        -: 1643:void
    #####: 1644:ihwbegin(int offset)
        -: 1645:{
    #####: 1646:    if (stophist == 2 || (histactive & HA_INWORD) ||
    #####: 1647:	(inbufflags & (INP_ALIAS|INP_HIST)) == INP_ALIAS)
    #####: 1648:	return;
    #####: 1649:    if (chwordpos%2)
    #####: 1650:	chwordpos--;	/* make sure we're on a word start, not end */
    #####: 1651:    chwords[chwordpos++] = hptr - chline + offset;
        -: 1652:}
        -: 1653:
        -: 1654:/* Abort current history word, not needed */
        -: 1655:
        -: 1656:/**/
        -: 1657:void
    #####: 1658:ihwabort(void)
        -: 1659:{
    #####: 1660:    if (chwordpos%2)
    #####: 1661:	chwordpos--;
    #####: 1662:    hist_keep_comment = 1;
    #####: 1663:}
        -: 1664:
        -: 1665:/* add a word to the history List */
        -: 1666:
        -: 1667:/**/
        -: 1668:void
    #####: 1669:ihwend(void)
        -: 1670:{
    #####: 1671:    if (stophist == 2 || (histactive & HA_INWORD) ||
    #####: 1672:	(inbufflags & (INP_ALIAS|INP_HIST)) == INP_ALIAS)
    #####: 1673:	return;
    #####: 1674:    if (chwordpos%2 && chline) {
        -: 1675:	/* end of word reached and we've already begun a word */
    #####: 1676:	if (hptr > chline + chwords[chwordpos-1]) {
    #####: 1677:	    chwords[chwordpos++] = hptr - chline;
    #####: 1678:	    if (chwordpos >= chwordlen) {
    #####: 1679:		chwords = (short *) realloc(chwords,
    #####: 1680:					    (chwordlen += 32) * 
        -: 1681:					    sizeof(short));
        -: 1682:	    }
        -: 1683:	} else {
        -: 1684:	    /* scrub that last word, it doesn't exist */
    #####: 1685:	    chwordpos--;
        -: 1686:	}
        -: 1687:    }
        -: 1688:}
        -: 1689:
        -: 1690:/* Go back to immediately after the last word, skipping space. */
        -: 1691:
        -: 1692:/**/
        -: 1693:void
    #####: 1694:histbackword(void)
        -: 1695:{
    #####: 1696:    if (!(chwordpos%2) && chwordpos)
    #####: 1697:	hptr = chline + chwords[chwordpos-1];
    #####: 1698:}
        -: 1699:
        -: 1700:/* Get the start and end point of the current history word */
        -: 1701:
        -: 1702:/**/
        -: 1703:static void
    #####: 1704:hwget(char **startptr)
        -: 1705:{
    #####: 1706:    int pos = chwordpos - 2;
        -: 1707:
        -: 1708:#ifdef DEBUG
        -: 1709:    /* debugging only */
        -: 1710:    if (!chwordpos) {
        -: 1711:	/* no words available */
        -: 1712:	DPUTS(1, "BUG: hwget() called with no words");
        -: 1713:	*startptr = "";
        -: 1714:	return;
        -: 1715:    }
        -: 1716:    else if (chwordpos%2) {
        -: 1717:	DPUTS(1, "BUG: hwget() called in middle of word");
        -: 1718:	*startptr = "";
        -: 1719:	return;
        -: 1720:    }
        -: 1721:#endif
        -: 1722:
    #####: 1723:    *startptr = chline + chwords[pos];
    #####: 1724:    chline[chwords[++pos]] = '\0';
    #####: 1725:}
        -: 1726:
        -: 1727:/* Replace the current history word with rep, if different */
        -: 1728:
        -: 1729:/**/
        -: 1730:void
    #####: 1731:hwrep(char *rep)
        -: 1732:{
        -: 1733:    char *start;
    #####: 1734:    hwget(&start);
        -: 1735:
    #####: 1736:    if (!strcmp(rep, start))
    #####: 1737:	return;
        -: 1738:
    #####: 1739:    hptr = start;
    #####: 1740:    chwordpos = chwordpos - 2;
    #####: 1741:    hwbegin(0);
    #####: 1742:    qbang = 1;
    #####: 1743:    while (*rep)
    #####: 1744:	hwaddc(*rep++);
    #####: 1745:    hwend();
        -: 1746:}
        -: 1747:
        -: 1748:/* Get the entire current line, deleting it in the history. */
        -: 1749:
        -: 1750:/**/
        -: 1751:mod_export char *
    #####: 1752:hgetline(void)
        -: 1753:{
        -: 1754:    /* Currently only used by pushlineoredit().
        -: 1755:     * It's necessary to prevent that from getting too pally with
        -: 1756:     * the history code.
        -: 1757:     */
        -: 1758:    char *ret;
        -: 1759:
    #####: 1760:    if (!chline || hptr == chline)
    #####: 1761:	return NULL;
    #####: 1762:    *hptr = '\0';
    #####: 1763:    ret = dupstring(chline);
        -: 1764:
        -: 1765:    /* reset line */
    #####: 1766:    hptr = chline;
    #####: 1767:    chwordpos = 0;
        -: 1768:
    #####: 1769:    return ret;
        -: 1770:}
        -: 1771:
        -: 1772:/* get an argument specification */
        -: 1773:
        -: 1774:/**/
        -: 1775:static int
    #####: 1776:getargspec(int argc, int marg, int evset)
        -: 1777:{
    #####: 1778:    int c, ret = -1;
        -: 1779:
    #####: 1780:    if ((c = ingetc()) == '0')
    #####: 1781:	return 0;
    #####: 1782:    if (idigit(c)) {
    #####: 1783:	ret = 0;
    #####: 1784:	while (idigit(c)) {
    #####: 1785:	    ret = ret * 10 + c - '0';
    #####: 1786:	    c = ingetc();
        -: 1787:	}
    #####: 1788:	inungetc(c);
    #####: 1789:    } else if (c == '^')
    #####: 1790:	ret = 1;
    #####: 1791:    else if (c == '$')
    #####: 1792:	ret = argc;
    #####: 1793:    else if (c == '%') {
    #####: 1794:	if (evset) {
    #####: 1795:	    herrflush();
    #####: 1796:	    zerr("Ambiguous history reference");
    #####: 1797:	    return -2;
        -: 1798:	}
    #####: 1799:	if (marg == -1) {
    #####: 1800:	    herrflush();
    #####: 1801:	    zerr("%% with no previous word matched");
    #####: 1802:	    return -2;
        -: 1803:	}
    #####: 1804:	ret = marg;
        -: 1805:    } else
    #####: 1806:	inungetc(c);
    #####: 1807:    return ret;
        -: 1808:}
        -: 1809:
        -: 1810:/* do ?foo? search */
        -: 1811:
        -: 1812:/**/
        -: 1813:static zlong
    #####: 1814:hconsearch(char *str, int *marg)
        -: 1815:{
    #####: 1816:    int t1 = 0;
        -: 1817:    char *s;
        -: 1818:    Histent he;
        -: 1819:
    #####: 1820:    for (he = up_histent(hist_ring); he; he = up_histent(he)) {
    #####: 1821:	if (he->node.flags & HIST_FOREIGN)
    #####: 1822:	    continue;
    #####: 1823:	if ((s = strstr(he->node.nam, str))) {
    #####: 1824:	    int pos = s - he->node.nam;
    #####: 1825:	    while (t1 < he->nwords && he->words[2*t1] <= pos)
    #####: 1826:		t1++;
    #####: 1827:	    *marg = t1 - 1;
    #####: 1828:	    return he->histnum;
        -: 1829:	}
        -: 1830:    }
    #####: 1831:    return -1;
        -: 1832:}
        -: 1833:
        -: 1834:/* do !foo search */
        -: 1835:
        -: 1836:/**/
        -: 1837:zlong
    #####: 1838:hcomsearch(char *str)
        -: 1839:{
        -: 1840:    Histent he;
    #####: 1841:    int len = strlen(str);
        -: 1842:
    #####: 1843:    for (he = up_histent(hist_ring); he; he = up_histent(he)) {
    #####: 1844:	if (he->node.flags & HIST_FOREIGN)
    #####: 1845:	    continue;
    #####: 1846:	if (strncmp(he->node.nam, str, len) == 0)
    #####: 1847:	    return he->histnum;
        -: 1848:    }
    #####: 1849:    return -1;
        -: 1850:}
        -: 1851:
        -: 1852:/* various utilities for : modifiers */
        -: 1853:
        -: 1854:/**/
        -: 1855:int
    #####: 1856:chabspath(char **junkptr)
        -: 1857:{
        -: 1858:    char *current, *dest;
        -: 1859:
    #####: 1860:    if (!**junkptr)
    #####: 1861:	return 1;
        -: 1862:
    #####: 1863:    if (**junkptr != '/') {
    #####: 1864:	*junkptr = zhtricat(metafy(zgetcwd(), -1, META_HEAPDUP), "/", *junkptr);
        -: 1865:    }
        -: 1866:
    #####: 1867:    current = *junkptr;
    #####: 1868:    dest = *junkptr;
        -: 1869:
        -: 1870:#ifdef HAVE_SUPERROOT
        -: 1871:    while (*current == '/' && current[1] == '.' && current[2] == '.' &&
        -: 1872:	   (!current[3] || current[3] == '/')) {
        -: 1873:	*dest++ = '/';
        -: 1874:	*dest++ = '.';
        -: 1875:	*dest++ = '.';
        -: 1876:	current += 3;
        -: 1877:    }
        -: 1878:#endif
        -: 1879:
        -: 1880:    for (;;) {
    #####: 1881:	if (*current == '/') {
        -: 1882:#ifdef __CYGWIN__
        -: 1883:	    if (current == *junkptr && current[1] == '/')
        -: 1884:		*dest++ = *current++;
        -: 1885:#endif
    #####: 1886:	    *dest++ = *current++;
    #####: 1887:	    while (*current == '/')
    #####: 1888:		current++;
    #####: 1889:	} else if (!*current) {
    #####: 1890:	    while (dest > *junkptr + 1 && dest[-1] == '/')
    #####: 1891:		dest--;
    #####: 1892:	    *dest = '\0';
    #####: 1893:	    break;
    #####: 1894:	} else if (current[0] == '.' && current[1] == '.' &&
    #####: 1895:		   (!current[2] || current[2] == '/')) {
    #####: 1896:		if (current == *junkptr || dest == *junkptr) {
    #####: 1897:		    *dest++ = '.';
    #####: 1898:		    *dest++ = '.';
    #####: 1899:		    current += 2;
    #####: 1900:		} else if (dest > *junkptr + 2 &&
    #####: 1901:			   !strncmp(dest - 3, "../", 3)) {
    #####: 1902:		    *dest++ = '.';
    #####: 1903:		    *dest++ = '.';
    #####: 1904:		    current += 2;
    #####: 1905:		} else if (dest > *junkptr + 1) {
    #####: 1906:		    *dest = '\0';
    #####: 1907:		    for (dest--;
    #####: 1908:			 dest > *junkptr + 1 && dest[-1] != '/';
    #####: 1909:			 dest--);
    #####: 1910:		    if (dest[-1] != '/')
    #####: 1911:			dest--;
    #####: 1912:		    current += 2;
    #####: 1913:		    if (*current == '/')
    #####: 1914:			current++;
    #####: 1915:		} else if (dest == *junkptr + 1) {
        -: 1916:		    /* This might break with Cygwin's leading double slashes? */
    #####: 1917:		    current += 2;
        -: 1918:		} else {
    #####: 1919:		    return 0;
        -: 1920:		}
    #####: 1921:	} else if (current[0] == '.' && (current[1] == '/' || !current[1])) {
    #####: 1922:	     while (*++current == '/');
        -: 1923:	} else {
    #####: 1924:	    while (*current != '/' && *current != '\0')
    #####: 1925:		if ((*dest++ = *current++) == Meta)
    #####: 1926:		    *dest++ = *current++;
        -: 1927:	}
        -: 1928:    }
    #####: 1929:    return 1;
        -: 1930:}
        -: 1931:
        -: 1932:/*
        -: 1933: * Resolve symlinks in junkptr.
        -: 1934: *
        -: 1935: * If mode is 'A', resolve dot-dot before symlinks.  Else, mode should be 'P'.
        -: 1936: * Refer to the documentation of the :A and :P modifiers for details.
        -: 1937: *
        -: 1938: * use_heap is 1 if the result is to be allocated on the heap, 0 otherwise.
        -: 1939: *
        -: 1940: * Return 0 for error, non-zero for success.
        -: 1941: */
        -: 1942:
        -: 1943:/**/
        -: 1944:int
    #####: 1945:chrealpath(char **junkptr, char mode, int use_heap)
        -: 1946:{
        -: 1947:    char *str;
        -: 1948:#ifdef HAVE_REALPATH
        -: 1949:# ifdef REALPATH_ACCEPTS_NULL
        -: 1950:    char *lastpos, *nonreal, *real;
        -: 1951:# else
        -: 1952:    char *lastpos, *nonreal, pathbuf[PATH_MAX+1];
        -: 1953:    char *real = pathbuf;
        -: 1954:# endif
        -: 1955:#endif
        -: 1956:
        -: 1957:    DPUTS1(mode != 'A' && mode != 'P', "chrealpath: mode='%c' is invalid", mode);
        -: 1958:
    #####: 1959:    if (!**junkptr)
    #####: 1960:	return 1;
        -: 1961:
    #####: 1962:    if (mode == 'A')
    #####: 1963:	if (!chabspath(junkptr))
    #####: 1964:	    return 0;
        -: 1965:
        -: 1966:#ifndef HAVE_REALPATH
        -: 1967:    return 1;
        -: 1968:#else
        -: 1969:    /*
        -: 1970:     * Notice that this means you cannot pass relative paths into this
        -: 1971:     * function!
        -: 1972:     */
    #####: 1973:    if (**junkptr != '/')
    #####: 1974:	return 0;
        -: 1975:
    #####: 1976:    unmetafy(*junkptr, NULL);
        -: 1977:
    #####: 1978:    lastpos = strend(*junkptr);
    #####: 1979:    nonreal = lastpos + 1;
        -: 1980:
    #####: 1981:    while (!
        -: 1982:#ifdef REALPATH_ACCEPTS_NULL
        -: 1983:	   /* realpath() with a NULL second argument uses malloc() to get
        -: 1984:	    * memory so we don't need to worry about overflowing PATH_MAX */
    #####: 1985:	   (real = realpath(*junkptr, NULL))
        -: 1986:#else
        -: 1987:	   realpath(*junkptr, real)
        -: 1988:#endif
        -: 1989:	) {
    #####: 1990:	if (errno == EINVAL || errno == ENOMEM)
    #####: 1991:	    return 0;
        -: 1992:
    #####: 1993:	if (nonreal == *junkptr) {
        -: 1994:#ifndef REALPATH_ACCEPTS_NULL
        -: 1995:	    real = NULL;
        -: 1996:#endif
    #####: 1997:	    break;
        -: 1998:	}
        -: 1999:
    #####: 2000:	while (*nonreal != '/' && nonreal >= *junkptr)
    #####: 2001:	    nonreal--;
    #####: 2002:	*nonreal = '\0';
        -: 2003:    }
        -: 2004:
    #####: 2005:    str = nonreal;
    #####: 2006:    while (str <= lastpos) {
    #####: 2007:	if (*str == '\0')
    #####: 2008:	    *str = '/';
    #####: 2009:	str++;
        -: 2010:    }
        -: 2011:
    #####: 2012:    use_heap = (use_heap ? META_HEAPDUP : META_DUP);
    #####: 2013:    if (real) {
    #####: 2014:	*junkptr = metafy(str = bicat(real, nonreal), -1, use_heap);
    #####: 2015:	zsfree(str);
        -: 2016:#ifdef REALPATH_ACCEPTS_NULL
    #####: 2017:	free(real);
        -: 2018:#endif
        -: 2019:    } else {
    #####: 2020:	*junkptr = metafy(nonreal, lastpos - nonreal + 1, use_heap);
        -: 2021:    }
        -: 2022:#endif
        -: 2023:
    #####: 2024:    return 1;
        -: 2025:}
        -: 2026:
        -: 2027:/**/
        -: 2028:int
    #####: 2029:remtpath(char **junkptr, int count)
        -: 2030:{
    #####: 2031:    char *str = strend(*junkptr);
        -: 2032:
        -: 2033:    /* ignore trailing slashes */
    #####: 2034:    while (str >= *junkptr && IS_DIRSEP(*str))
    #####: 2035:	--str;
    #####: 2036:    if (!count) {
        -: 2037:	/* skip filename */
    #####: 2038:	while (str >= *junkptr && !IS_DIRSEP(*str))
    #####: 2039:	    --str;
        -: 2040:    }
    #####: 2041:    if (str < *junkptr) {
    #####: 2042:	if (IS_DIRSEP(**junkptr))
    #####: 2043:	    *junkptr = dupstring ("/");
        -: 2044:	else
    #####: 2045:	    *junkptr = dupstring (".");
        -: 2046:
    #####: 2047:	return 0;
        -: 2048:    }
        -: 2049:
    #####: 2050:    if (count)
        -: 2051:    {
        -: 2052:	/*
        -: 2053:	 * Return this many components, so start from the front.
        -: 2054:	 * Leading slash counts as one component, consistent with
        -: 2055:	 * behaviour of repeated applications of :h.
        -: 2056:	 */
    #####: 2057:	char *strp = *junkptr;
    #####: 2058:	while (strp < str) {
    #####: 2059:	    if (IS_DIRSEP(*strp)) {
    #####: 2060:		if (--count <= 0) {
    #####: 2061:		    if (strp == *junkptr)
    #####: 2062:			++strp;
    #####: 2063:		    *strp = '\0';
    #####: 2064:		    return 1;
        -: 2065:		}
        -: 2066:		/* Count consecutive separators as one */
    #####: 2067:		while (IS_DIRSEP(strp[1]))
    #####: 2068:		    ++strp;
        -: 2069:	    }
    #####: 2070:	    ++strp;
        -: 2071:	}
        -: 2072:
        -: 2073:	/* Full string needed */
    #####: 2074:	return 1;
        -: 2075:    }
        -: 2076:
        -: 2077:    /* repeated slashes are considered like a single slash */
    #####: 2078:    while (str > *junkptr && IS_DIRSEP(str[-1]))
    #####: 2079:	--str;
        -: 2080:    /* never erase the root slash */
    #####: 2081:    if (str == *junkptr) {
    #####: 2082:	++str;
        -: 2083:	/* Leading doubled slashes (`//') have a special meaning on cygwin
        -: 2084:	   and some old flavor of UNIX, so we do not assimilate them to
        -: 2085:	   a single slash.  However a greater number is ok to squeeze. */
    #####: 2086:	if (IS_DIRSEP(*str) && !IS_DIRSEP(str[1]))
    #####: 2087:	    ++str;
        -: 2088:    }
    #####: 2089:    *str = '\0';
    #####: 2090:    return 1;
        -: 2091:}
        -: 2092:
        -: 2093:/**/
        -: 2094:int
    #####: 2095:remtext(char **junkptr)
        -: 2096:{
        -: 2097:    char *str;
        -: 2098:
    #####: 2099:    for (str = strend(*junkptr); str >= *junkptr && !IS_DIRSEP(*str); --str)
    #####: 2100:	if (*str == '.') {
    #####: 2101:	    *str = '\0';
    #####: 2102:	    return 1;
        -: 2103:	}
    #####: 2104:    return 0;
        -: 2105:}
        -: 2106:
        -: 2107:/**/
        -: 2108:int
    #####: 2109:rembutext(char **junkptr)
        -: 2110:{
        -: 2111:    char *str;
        -: 2112:
    #####: 2113:    for (str = strend(*junkptr); str >= *junkptr && !IS_DIRSEP(*str); --str)
    #####: 2114:	if (*str == '.') {
    #####: 2115:	    *junkptr = dupstring(str + 1); /* .xx or xx? */
    #####: 2116:	    return 1;
        -: 2117:	}
        -: 2118:    /* no extension */
    #####: 2119:    *junkptr = dupstring ("");
    #####: 2120:    return 0;
        -: 2121:}
        -: 2122:
        -: 2123:/**/
        -: 2124:mod_export int
    #####: 2125:remlpaths(char **junkptr, int count)
        -: 2126:{
    #####: 2127:    char *str = strend(*junkptr);
        -: 2128:
    #####: 2129:    if (IS_DIRSEP(*str)) {
        -: 2130:	/* remove trailing slashes */
    #####: 2131:	while (str >= *junkptr && IS_DIRSEP(*str))
    #####: 2132:	    --str;
    #####: 2133:	str[1] = '\0';
        -: 2134:    }
        -: 2135:    for (;;) {
    #####: 2136:	for (; str >= *junkptr; --str) {
    #####: 2137:	    if (IS_DIRSEP(*str)) {
    #####: 2138:		if (--count > 0) {
    #####: 2139:		    if (str > *junkptr) {
    #####: 2140:			--str;
    #####: 2141:			break;
        -: 2142:		    } else {
        -: 2143:			/* Whole string needed */
    #####: 2144:			return 1;
        -: 2145:		    }
        -: 2146:		}
    #####: 2147:		*str = '\0';
    #####: 2148:		*junkptr = dupstring(str + 1);
    #####: 2149:		return 1;
        -: 2150:	    }
        -: 2151:	}
        -: 2152:	/* Count consecutive separators as 1 */
    #####: 2153:	while (str >= *junkptr && IS_DIRSEP(*str))
    #####: 2154:	    --str;
    #####: 2155:	if (str <= *junkptr)
    #####: 2156:	    break;
        -: 2157:    }
    #####: 2158:    return 0;
        -: 2159:}
        -: 2160:
        -: 2161:/*
        -: 2162: * Return modified version of str from the heap with modification
        -: 2163: * according to one of the CASMOD_* types defined in zsh.h; CASMOD_NONE
        -: 2164: * is not handled, for obvious reasons.
        -: 2165: */
        -: 2166:
        -: 2167:/**/
        -: 2168:char *
    #####: 2169:casemodify(char *str, int how)
        -: 2170:{
    #####: 2171:    char *str2 = zhalloc(2 * strlen(str) + 1);
    #####: 2172:    char *ptr2 = str2;
    #####: 2173:    int nextupper = 1;
        -: 2174:
        -: 2175:#ifdef MULTIBYTE_SUPPORT
    #####: 2176:    if (isset(MULTIBYTE)) {
    #####: 2177:	VARARR(char, mbstr, MB_CUR_MAX);
        -: 2178:	mbstate_t ps;
        -: 2179:
    #####: 2180:	mb_charinit();
    #####: 2181:	memset(&ps, 0, sizeof(ps));
    #####: 2182:	while (*str) {
        -: 2183:	    wint_t wc;
    #####: 2184:	    int len = mb_metacharlenconv(str, &wc), mod = 0, len2;
        -: 2185:	    /*
        -: 2186:	     * wc is set to WEOF if the start of str couldn't be
        -: 2187:	     * converted.  Presumably WEOF doesn't match iswlower(), but
        -: 2188:	     * better be safe.
        -: 2189:	     */
    #####: 2190:	    if (wc == WEOF) {
    #####: 2191:		while (len--)
    #####: 2192:		    *ptr2++ = *str++;
        -: 2193:		/* not alphanumeric */
    #####: 2194:		nextupper = 1;
    #####: 2195:		continue;
        -: 2196:	    }
    #####: 2197:	    switch (how) {
    #####: 2198:	    case CASMOD_LOWER:
    #####: 2199:		if (iswupper(wc)) {
    #####: 2200:		    wc = towlower(wc);
    #####: 2201:		    mod = 1;
        -: 2202:		}
    #####: 2203:		break;
        -: 2204:
    #####: 2205:	    case CASMOD_UPPER:
    #####: 2206:		if (iswlower(wc)) {
    #####: 2207:		    wc = towupper(wc);
    #####: 2208:		    mod = 1;
        -: 2209:		}
    #####: 2210:		break;
        -: 2211:
    #####: 2212:	    case CASMOD_CAPS:
        -: 2213:	    default:		/* shuts up compiler */
    #####: 2214:		if (IS_COMBINING(wc))
    #####: 2215:			break;
    #####: 2216:		if (!iswalnum(wc))
    #####: 2217:		    nextupper = 1;
    #####: 2218:		else if (nextupper) {
    #####: 2219:		    if (iswlower(wc)) {
    #####: 2220:			wc = towupper(wc);
    #####: 2221:			mod = 1;
        -: 2222:		    }
    #####: 2223:		    nextupper = 0;
    #####: 2224:		} else if (iswupper(wc)) {
    #####: 2225:		    wc = towlower(wc);
    #####: 2226:		    mod = 1;
        -: 2227:		}
    #####: 2228:		break;
        -: 2229:	    }
    #####: 2230:	    if (mod && (len2 = wcrtomb(mbstr, wc, &ps)) > 0) {
        -: 2231:		char *mbptr;
        -: 2232:
    #####: 2233:		for (mbptr = mbstr; mbptr < mbstr + len2; mbptr++) {
    #####: 2234:		    if (imeta(STOUC(*mbptr))) {
    #####: 2235:			*ptr2++ = Meta;
    #####: 2236:			*ptr2++ = *mbptr ^ 32;
        -: 2237:		    } else
    #####: 2238:			*ptr2++ = *mbptr;
        -: 2239:		}
    #####: 2240:		str += len;
        -: 2241:	    } else {
    #####: 2242:		while (len--)
    #####: 2243:		    *ptr2++ = *str++;
        -: 2244:	    }
        -: 2245:	}
        -: 2246:    }
        -: 2247:    else
        -: 2248:#endif
    #####: 2249:	while (*str) {
        -: 2250:	    int c;
    #####: 2251:	    if (*str == Meta) {
    #####: 2252:		c = str[1] ^ 32;
    #####: 2253:		str += 2;
        -: 2254:	    } else
    #####: 2255:		c = *str++;
    #####: 2256:	    switch (how) {
    #####: 2257:	    case CASMOD_LOWER:
    #####: 2258:		if (isupper(c))
    #####: 2259:		    c = tolower(c);
    #####: 2260:		break;
        -: 2261:
    #####: 2262:	    case CASMOD_UPPER:
    #####: 2263:		if (islower(c))
    #####: 2264:		    c = toupper(c);
    #####: 2265:		break;
        -: 2266:
    #####: 2267:	    case CASMOD_CAPS:
        -: 2268:	    default:		/* shuts up compiler */
    #####: 2269:		if (!ialnum(c))
    #####: 2270:		    nextupper = 1;
    #####: 2271:		else if (nextupper) {
    #####: 2272:		    if (islower(c))
    #####: 2273:			c = toupper(c);
    #####: 2274:		    nextupper = 0;
    #####: 2275:		} else if (isupper(c))
    #####: 2276:		    c = tolower(c);
    #####: 2277:		break;
        -: 2278:	    }
    #####: 2279:	    if (imeta(c)) {
    #####: 2280:		*ptr2++ = Meta;
    #####: 2281:		*ptr2++ = c ^ 32;
        -: 2282:	    } else
    #####: 2283:		*ptr2++ = c;
        -: 2284:	}
    #####: 2285:    *ptr2 = '\0';
    #####: 2286:    return str2;
        -: 2287:}
        -: 2288:
        -: 2289:
        -: 2290:/*
        -: 2291: * Substitute "in" for "out" in "*strptr" and update "*strptr".
        -: 2292: * If "gbal", do global substitution.
        -: 2293: *
        -: 2294: * This returns a result from the heap.  There seems to have
        -: 2295: * been some confusion on this point.
        -: 2296: */
        -: 2297:
        -: 2298:/**/
        -: 2299:int
    #####: 2300:subst(char **strptr, char *in, char *out, int gbal)
        -: 2301:{
    #####: 2302:    char *str = *strptr, *substcut, *sptr;
        -: 2303:    int off, inlen, outlen;
        -: 2304:
    #####: 2305:    if (!*in)
    #####: 2306:	in = str, gbal = 0;
        -: 2307:
    #####: 2308:    if (isset(HISTSUBSTPATTERN)) {
    #####: 2309:	int fl = SUB_LONG|SUB_REST|SUB_RETFAIL;
    #####: 2310:	char *oldin = in;
    #####: 2311:	if (gbal)
    #####: 2312:	    fl |= SUB_GLOBAL;
    #####: 2313:	if (*in == '#' || *in == Pound) {
        -: 2314:	    /* anchor at head, flag needed if SUB_END is also set */
    #####: 2315:	    fl |= SUB_START;
    #####: 2316:	    in++;
        -: 2317:	}
    #####: 2318:	if (*in == '%') {
        -: 2319:	    /* anchor at tail */
    #####: 2320:	    in++;
    #####: 2321:	    fl |= SUB_END;
        -: 2322:	}
    #####: 2323:	if (in == oldin) {
        -: 2324:	    /* no anchor, substring match */
    #####: 2325:	    fl |= SUB_SUBSTR;
        -: 2326:	}
    #####: 2327:	if (in == str)
    #####: 2328:	    in = dupstring(in);
    #####: 2329:	if (parse_subst_string(in) || errflag)
    #####: 2330:	    return 1;
    #####: 2331:	if (parse_subst_string(out) || errflag)
    #####: 2332:	    return 1;
    #####: 2333:	singsub(&in);
    #####: 2334:	if (getmatch(strptr, in, fl, 1, out))
    #####: 2335:	    return 0;
        -: 2336:    } else {
    #####: 2337:	if ((substcut = (char *)strstr(str, in))) {
    #####: 2338:	    inlen = strlen(in);
    #####: 2339:	    sptr = convamps(out, in, inlen);
    #####: 2340:	    outlen = strlen(sptr);
        -: 2341:
        -: 2342:	    do {
    #####: 2343:		*substcut = '\0';
    #####: 2344:		off = substcut - *strptr + outlen;
    #####: 2345:		substcut += inlen;
    #####: 2346:		*strptr = zhtricat(*strptr, sptr, substcut);
    #####: 2347:		str = (char *)*strptr + off;
    #####: 2348:	    } while (gbal && (substcut = (char *)strstr(str, in)));
        -: 2349:
    #####: 2350:	    return 0;
        -: 2351:	}
        -: 2352:    }
        -: 2353:
    #####: 2354:    return 1;
        -: 2355:}
        -: 2356:
        -: 2357:/**/
        -: 2358:static char *
    #####: 2359:convamps(char *out, char *in, int inlen)
        -: 2360:{
        -: 2361:    char *ptr, *ret, *pp;
    #####: 2362:    int slen, sdup = 0;
        -: 2363:
    #####: 2364:    for (ptr = out, slen = 0; *ptr; ptr++, slen++)
    #####: 2365:	if (*ptr == '\\')
    #####: 2366:	    ptr++, sdup = 1;
    #####: 2367:	else if (*ptr == '&')
    #####: 2368:	    slen += inlen - 1, sdup = 1;
    #####: 2369:    if (!sdup)
    #####: 2370:	return out;
    #####: 2371:    ret = pp = (char *) zhalloc(slen + 1);
    #####: 2372:    for (ptr = out; *ptr; ptr++)
    #####: 2373:	if (*ptr == '\\')
    #####: 2374:	    *pp++ = *++ptr;
    #####: 2375:	else if (*ptr == '&') {
    #####: 2376:	    strcpy(pp, in);
    #####: 2377:	    pp += inlen;
        -: 2378:	} else
    #####: 2379:	    *pp++ = *ptr;
    #####: 2380:    *pp = '\0';
    #####: 2381:    return ret;
        -: 2382:}
        -: 2383:
        -: 2384:/**/
        -: 2385:mod_export void
    #####: 2386:checkcurline(Histent he)
        -: 2387:{
    #####: 2388:    if (he->histnum == curhist && (histactive & HA_ACTIVE)) {
    #####: 2389:	curline.node.nam = chline;
    #####: 2390:	curline.nwords = chwordpos/2;
    #####: 2391:	curline.words = chwords;
        -: 2392:    }
    #####: 2393:}
        -: 2394:
        -: 2395:/**/
        -: 2396:mod_export Histent
    #####: 2397:quietgethist(int ev)
        -: 2398:{
    #####: 2399:    return gethistent(ev, GETHIST_EXACT);
        -: 2400:}
        -: 2401:
        -: 2402:/**/
        -: 2403:static Histent
    #####: 2404:gethist(int ev)
        -: 2405:{
        -: 2406:    Histent ret;
        -: 2407:
    #####: 2408:    ret = quietgethist(ev);
    #####: 2409:    if (!ret) {
    #####: 2410:	herrflush();
    #####: 2411:	zerr("no such event: %d", ev);
        -: 2412:    }
    #####: 2413:    return ret;
        -: 2414:}
        -: 2415:
        -: 2416:/**/
        -: 2417:static char *
    #####: 2418:getargs(Histent elist, int arg1, int arg2)
        -: 2419:{
    #####: 2420:    short *words = elist->words;
    #####: 2421:    int pos1, pos2, nwords = elist->nwords;
        -: 2422:
    #####: 2423:    if (arg2 < arg1 || arg1 >= nwords || arg2 >= nwords) {
        -: 2424:	/* remember, argN is indexed from 0, nwords is total no. of words */
    #####: 2425:	herrflush();
    #####: 2426:	zerr("no such word in event");
    #####: 2427:	return NULL;
        -: 2428:    }
        -: 2429:
        -: 2430:    /* optimization for accessing entire history event */
    #####: 2431:    if (arg1 == 0 && arg2 == nwords - 1)
    #####: 2432:	return dupstring(elist->node.nam);
        -: 2433:
    #####: 2434:    pos1 = words[2*arg1];
    #####: 2435:    pos2 = words[2*arg2+1];
        -: 2436:
        -: 2437:    /* a word has to be at least one character long, so if the position
        -: 2438:     * of a word is less than its index, we've overflowed our signed
        -: 2439:     * short integer word range and the recorded position is garbage. */
    #####: 2440:    if (pos1 < 0 || pos1 < arg1 || pos2 < 0 || pos2 < arg2) {
    #####: 2441:	herrflush();
    #####: 2442:	zerr("history event too long, can't index requested words");
    #####: 2443:	return NULL;
        -: 2444:    }
    #####: 2445:    return dupstrpfx(elist->node.nam + pos1, pos2 - pos1);
        -: 2446:}
        -: 2447:
        -: 2448:/**/
        -: 2449:static int
    #####: 2450:quote(char **tr)
        -: 2451:{
    #####: 2452:    char *ptr, *rptr, **str = tr;
    #####: 2453:    int len = 3;
    #####: 2454:    int inquotes = 0;
        -: 2455:
    #####: 2456:    for (ptr = *str; *ptr; ptr++, len++)
    #####: 2457:	if (*ptr == '\'') {
    #####: 2458:	    len += 3;
    #####: 2459:	    if (!inquotes)
    #####: 2460:		inquotes = 1;
        -: 2461:	    else
    #####: 2462:		inquotes = 0;
    #####: 2463:	} else if (inblank(*ptr) && !inquotes && ptr[-1] != '\\')
    #####: 2464:	    len += 2;
    #####: 2465:    ptr = *str;
    #####: 2466:    *str = rptr = (char *) zhalloc(len);
    #####: 2467:    *rptr++ = '\'';
    #####: 2468:    for (; *ptr; ptr++)
    #####: 2469:	if (*ptr == '\'') {
    #####: 2470:	    if (!inquotes)
    #####: 2471:		inquotes = 1;
        -: 2472:	    else
    #####: 2473:		inquotes = 0;
    #####: 2474:	    *rptr++ = '\'';
    #####: 2475:	    *rptr++ = '\\';
    #####: 2476:	    *rptr++ = '\'';
    #####: 2477:	    *rptr++ = '\'';
    #####: 2478:	} else if (inblank(*ptr) && !inquotes && ptr[-1] != '\\') {
    #####: 2479:	    *rptr++ = '\'';
    #####: 2480:	    *rptr++ = *ptr;
    #####: 2481:	    *rptr++ = '\'';
        -: 2482:	} else
    #####: 2483:	    *rptr++ = *ptr;
    #####: 2484:    *rptr++ = '\'';
    #####: 2485:    *rptr++ = 0;
    #####: 2486:    return 0;
        -: 2487:}
        -: 2488:
        -: 2489:/**/
        -: 2490:static int
    #####: 2491:quotebreak(char **tr)
        -: 2492:{
    #####: 2493:    char *ptr, *rptr, **str = tr;
    #####: 2494:    int len = 3;
        -: 2495:
    #####: 2496:    for (ptr = *str; *ptr; ptr++, len++)
    #####: 2497:	if (*ptr == '\'')
    #####: 2498:	    len += 3;
    #####: 2499:	else if (inblank(*ptr))
    #####: 2500:	    len += 2;
    #####: 2501:    ptr = *str;
    #####: 2502:    *str = rptr = (char *) zhalloc(len);
    #####: 2503:    *rptr++ = '\'';
    #####: 2504:    for (; *ptr;)
    #####: 2505:	if (*ptr == '\'') {
    #####: 2506:	    *rptr++ = '\'';
    #####: 2507:	    *rptr++ = '\\';
    #####: 2508:	    *rptr++ = '\'';
    #####: 2509:	    *rptr++ = '\'';
    #####: 2510:	    ptr++;
    #####: 2511:	} else if (inblank(*ptr)) {
    #####: 2512:	    *rptr++ = '\'';
    #####: 2513:	    *rptr++ = *ptr++;
    #####: 2514:	    *rptr++ = '\'';
        -: 2515:	} else
    #####: 2516:	    *rptr++ = *ptr++;
    #####: 2517:    *rptr++ = '\'';
    #####: 2518:    *rptr++ = '\0';
    #####: 2519:    return 0;
        -: 2520:}
        -: 2521:
        -: 2522:/* read an arbitrary amount of data into a buffer until stop is found */
        -: 2523:
        -: 2524:#if 0 /**/
        -: 2525:char *
        -: 2526:hdynread(int stop)
        -: 2527:{
        -: 2528:    int bsiz = 256, ct = 0, c;
        -: 2529:    char *buf = (char *)zalloc(bsiz), *ptr;
        -: 2530:
        -: 2531:    ptr = buf;
        -: 2532:    while ((c = ingetc()) != stop && c != '\n' && !lexstop) {
        -: 2533:	if (c == '\\')
        -: 2534:	    c = ingetc();
        -: 2535:	*ptr++ = c;
        -: 2536:	if (++ct == bsiz) {
        -: 2537:	    buf = realloc(buf, bsiz *= 2);
        -: 2538:	    ptr = buf + ct;
        -: 2539:	}
        -: 2540:    }
        -: 2541:    *ptr = 0;
        -: 2542:    if (c == '\n') {
        -: 2543:	inungetc('\n');
        -: 2544:	zerr("delimiter expected");
        -: 2545:	zfree(buf, bsiz);
        -: 2546:	return NULL;
        -: 2547:    }
        -: 2548:    return buf;
        -: 2549:}
        -: 2550:#endif
        -: 2551:
        -: 2552:/**/
        -: 2553:static char *
    #####: 2554:hdynread2(int stop)
        -: 2555:{
    #####: 2556:    int bsiz = 256, ct = 0, c;
    #####: 2557:    char *buf = (char *)zalloc(bsiz), *ptr;
        -: 2558:
    #####: 2559:    ptr = buf;
    #####: 2560:    while ((c = ingetc()) != stop && c != '\n' && !lexstop) {
    #####: 2561:	if (c == '\\')
    #####: 2562:	    c = ingetc();
    #####: 2563:	*ptr++ = c;
    #####: 2564:	if (++ct == bsiz) {
    #####: 2565:	    buf = realloc(buf, bsiz *= 2);
    #####: 2566:	    ptr = buf + ct;
        -: 2567:	}
        -: 2568:    }
    #####: 2569:    *ptr = 0;
    #####: 2570:    if (c == '\n')
    #####: 2571:	inungetc('\n');
    #####: 2572:    return buf;
        -: 2573:}
        -: 2574:
        -: 2575:/**/
        -: 2576:void
        2: 2577:inithist(void)
        -: 2578:{
        2: 2579:    createhisttable();
        2: 2580:}
        -: 2581:
        -: 2582:/**/
        -: 2583:void
    #####: 2584:resizehistents(void)
        -: 2585:{
    #####: 2586:    if (histlinect > histsiz) {
        -: 2587:	/* The reason we don't just call freehistnode(hist_ring->down) is
        -: 2588:	 * so that we can honor the HISTEXPIREDUPSFIRST setting. */
    #####: 2589:	putoldhistentryontop(0);
    #####: 2590:	freehistnode(&hist_ring->node);
    #####: 2591:	while (histlinect > histsiz) {
    #####: 2592:	    putoldhistentryontop(1);
    #####: 2593:	    freehistnode(&hist_ring->node);
        -: 2594:	}
        -: 2595:    }
    #####: 2596:}
        -: 2597:
        -: 2598:static int
    #####: 2599:readhistline(int start, char **bufp, int *bufsiz, FILE *in, int *readbytes)
        -: 2600:{
    #####: 2601:    char *buf = *bufp;
    #####: 2602:    if (fgets(buf + start, *bufsiz - start, in)) {
    #####: 2603:	int len = strlen(buf + start);
    #####: 2604:	*readbytes += len;
    #####: 2605:	len += start;
    #####: 2606:	if (len == start)
    #####: 2607:	    return -1;
    #####: 2608:	if (buf[len - 1] != '\n') {
    #####: 2609:	    if (!feof(in)) {
    #####: 2610:		if (len < (*bufsiz) - 1)
    #####: 2611:		    return -1;
    #####: 2612:		*bufp = zrealloc(buf, 2 * (*bufsiz));
    #####: 2613:		*bufsiz = 2 * (*bufsiz);
    #####: 2614:		return readhistline(len, bufp, bufsiz, in, readbytes);
        -: 2615:	    }
        -: 2616:	}
        -: 2617:	else {
    #####: 2618:	    buf[len - 1] = '\0';
    #####: 2619:	    if (len > 1 && buf[len - 2] == '\\') {
    #####: 2620:		buf[--len - 1] = '\n';
    #####: 2621:		if (!feof(in))
    #####: 2622:		    return readhistline(len, bufp, bufsiz, in, readbytes);
        -: 2623:	    }
        -: 2624:	}
    #####: 2625:	return len;
        -: 2626:    }
    #####: 2627:    return 0;
        -: 2628:}
        -: 2629:
        -: 2630:/**/
        -: 2631:void
    #####: 2632:readhistfile(char *fn, int err, int readflags)
        -: 2633:{
    #####: 2634:    char *buf, *start = NULL;
        -: 2635:    FILE *in;
        -: 2636:    Histent he;
    #####: 2637:    time_t stim, ftim, tim = time(NULL);
        -: 2638:    off_t fpos;
        -: 2639:    short *words;
        -: 2640:    struct stat sb;
        -: 2641:    int nwordpos, nwords, bufsiz;
        -: 2642:    int searching, newflags, l, ret, uselex, readbytes;
        -: 2643:
    #####: 2644:    if (!fn && !(fn = getsparam("HISTFILE")))
    #####: 2645:	return;
    #####: 2646:    if (stat(unmeta(fn), &sb) < 0 ||
    #####: 2647:	sb.st_size == 0)
    #####: 2648:	return;
    #####: 2649:    if (readflags & HFILE_FAST) {
    #####: 2650:	if (!lasthist.interrupted &&
    #####: 2651:	    ((lasthist.fsiz == sb.st_size && lasthist.mtim == sb.st_mtime)
    #####: 2652:	     || lockhistfile(fn, 0)))
    #####: 2653:	    return;
    #####: 2654:	lasthist.fsiz = sb.st_size;
    #####: 2655:	lasthist.mtim = sb.st_mtime;
    #####: 2656:	lasthist.interrupted = 0;
    #####: 2657:    } else if ((ret = lockhistfile(fn, 1))) {
    #####: 2658:	if (ret == 2) {
    #####: 2659:	    zwarn("locking failed for %s: %e: reading anyway", fn, errno);
        -: 2660:	} else {
    #####: 2661:	    zerr("locking failed for %s: %e", fn, errno);
    #####: 2662:	    return;
        -: 2663:	}
        -: 2664:    }
    #####: 2665:    if ((in = fopen(unmeta(fn), "r"))) {
    #####: 2666:	nwords = 64;
    #####: 2667:	words = (short *)zalloc(nwords*sizeof(short));
    #####: 2668:	bufsiz = 1024;
    #####: 2669:	buf = zalloc(bufsiz);
        -: 2670:
    #####: 2671:	pushheap();
    #####: 2672:	if (readflags & HFILE_FAST && lasthist.text) {
    #####: 2673:	    if (lasthist.fpos < lasthist.fsiz) {
    #####: 2674:		fseek(in, lasthist.fpos, SEEK_SET);
    #####: 2675:		searching = 1;
        -: 2676:	    }
        -: 2677:	    else {
    #####: 2678:		histfile_linect = 0;
    #####: 2679:		searching = -1;
        -: 2680:	    }
        -: 2681:	} else
    #####: 2682:	    searching = 0;
        -: 2683:
    #####: 2684:	fpos = ftell(in);
    #####: 2685:	readbytes = 0;
    #####: 2686:	newflags = HIST_OLD | HIST_READ;
    #####: 2687:	if (readflags & HFILE_FAST)
    #####: 2688:	    newflags |= HIST_FOREIGN;
    #####: 2689:	if (readflags & HFILE_SKIPOLD
    #####: 2690:	 || (hist_ignore_all_dups && newflags & hist_skip_flags))
    #####: 2691:	    newflags |= HIST_MAKEUNIQUE;
    #####: 2692:	while (fpos += readbytes, readbytes = 0, (l = readhistline(0, &buf, &bufsiz, in, &readbytes))) {
        -: 2693:	    char *pt;
    #####: 2694:	    int remeta = 0;
        -: 2695:
    #####: 2696:	    if (l < 0) {
    #####: 2697:		zerr("corrupt history file %s", fn);
    #####: 2698:		break;
        -: 2699:	    }
        -: 2700:
        -: 2701:	    /*
        -: 2702:	     * Handle the special case that we're reading from an
        -: 2703:	     * old shell with fewer meta characters, so we need to
        -: 2704:	     * metafy some more.  (It's not clear why the history
        -: 2705:	     * file is metafied at all; some would say this is plain
        -: 2706:	     * stupid.  But we're stuck with it now without some
        -: 2707:	     * hairy workarounds for compatibility).
        -: 2708:	     *
        -: 2709:	     * This is rare so doesn't need to be that efficient; just
        -: 2710:	     * allocate space off the heap.
        -: 2711:	     */
    #####: 2712:	    for (pt = buf; *pt; pt++) {
    #####: 2713:		if (*pt == Meta && pt[1])
    #####: 2714:		    pt++;
    #####: 2715:		else if (imeta(*pt)) {
    #####: 2716:		    remeta = 1;
    #####: 2717:		    break;
        -: 2718:		}
        -: 2719:	    }
    #####: 2720:	    if (remeta) {
    #####: 2721:		unmetafy(buf, &remeta);
    #####: 2722:		pt = metafy(buf, remeta, META_USEHEAP);
        -: 2723:	    } else {
    #####: 2724:		pt = buf;
        -: 2725:	    }
        -: 2726:
    #####: 2727:	    if (*pt == ':') {
    #####: 2728:		pt++;
    #####: 2729:		stim = zstrtol(pt, NULL, 0);
    #####: 2730:		for (; *pt != ':' && *pt; pt++);
    #####: 2731:		if (*pt) {
    #####: 2732:		    pt++;
    #####: 2733:		    ftim = zstrtol(pt, NULL, 0);
    #####: 2734:		    for (; *pt != ';' && *pt; pt++);
    #####: 2735:		    if (*pt)
    #####: 2736:			pt++;
        -: 2737:		} else
    #####: 2738:		    ftim = stim;
        -: 2739:	    } else {
    #####: 2740:		if (*pt == '\\' && pt[1] == ':')
    #####: 2741:		    pt++;
    #####: 2742:		stim = ftim = 0;
        -: 2743:	    }
        -: 2744:
    #####: 2745:	    if (searching) {
    #####: 2746:		if (searching > 0) {
    #####: 2747:		    if (stim == lasthist.stim
    #####: 2748:		     && histstrcmp(pt, lasthist.text) == 0)
    #####: 2749:			searching = 0;
        -: 2750:		    else {
    #####: 2751:			fseek(in, 0, SEEK_SET);
    #####: 2752:			histfile_linect = 0;
    #####: 2753:			searching = -1;
        -: 2754:		    }
    #####: 2755:		    continue;
        -: 2756:		}
    #####: 2757:		else if (stim < lasthist.stim) {
    #####: 2758:		    histfile_linect++;
    #####: 2759:		    continue;
        -: 2760:		}
    #####: 2761:		searching = 0;
        -: 2762:	    }
        -: 2763:
    #####: 2764:	    if (readflags & HFILE_USE_OPTIONS) {
    #####: 2765:		histfile_linect++;
    #####: 2766:		lasthist.fpos = fpos;
    #####: 2767:		lasthist.stim = stim;
        -: 2768:	    }
        -: 2769:
    #####: 2770:	    he = prepnexthistent();
    #####: 2771:	    he->node.nam = ztrdup(pt);
    #####: 2772:	    he->node.flags = newflags;
    #####: 2773:	    if ((he->stim = stim) == 0)
    #####: 2774:		he->stim = he->ftim = tim;
    #####: 2775:	    else if (ftim < stim)
    #####: 2776:		he->ftim = stim + ftim;
        -: 2777:	    else
    #####: 2778:		he->ftim = ftim;
        -: 2779:
        -: 2780:	    /*
        -: 2781:	     * Divide up the words.
        -: 2782:	     */
    #####: 2783:	    start = pt;
    #####: 2784:	    uselex = isset(HISTLEXWORDS) && !(readflags & HFILE_FAST);
    #####: 2785:	    histsplitwords(pt, &words, &nwords, &nwordpos, uselex);
        -: 2786:
    #####: 2787:	    he->nwords = nwordpos/2;
    #####: 2788:	    if (he->nwords) {
    #####: 2789:		he->words = (short *)zalloc(nwordpos*sizeof(short));
    #####: 2790:		memcpy(he->words, words, nwordpos*sizeof(short));
        -: 2791:	    } else
    #####: 2792:		he->words = (short *)NULL;
    #####: 2793:	    addhistnode(histtab, he->node.nam, he);
    #####: 2794:	    if (he->node.flags & HIST_DUP) {
    #####: 2795:		freehistnode(&he->node);
    #####: 2796:		curhist--;
        -: 2797:	    }
        -: 2798:	    /*
        -: 2799:	     * Do this last out of paranoia in case use of
        -: 2800:	     * heap is disguised...
        -: 2801:	     */
    #####: 2802:	    if (uselex || remeta)
    #####: 2803:		freeheap();
    #####: 2804:	    if (errflag & ERRFLAG_INT) {
        -: 2805:		/* Can't assume fast read next time if interrupted. */
    #####: 2806:		lasthist.interrupted = 1;
    #####: 2807:		break;
        -: 2808:	    }
        -: 2809:	}
    #####: 2810:	if (start && readflags & HFILE_USE_OPTIONS) {
    #####: 2811:	    zsfree(lasthist.text);
    #####: 2812:	    lasthist.text = ztrdup(start);
        -: 2813:	}
    #####: 2814:	zfree(words, nwords*sizeof(short));
    #####: 2815:	zfree(buf, bufsiz);
        -: 2816:
    #####: 2817:	popheap();
    #####: 2818:	fclose(in);
    #####: 2819:    } else if (err)
    #####: 2820:	zerr("can't read history file %s", fn);
        -: 2821:
    #####: 2822:    unlockhistfile(fn);
        -: 2823:
    #####: 2824:    if (zleactive)
    #####: 2825:	zleentry(ZLE_CMD_SET_HIST_LINE, curhist);
        -: 2826:}
        -: 2827:
        -: 2828:#ifdef HAVE_FCNTL_H
        -: 2829:static int flock_fd = -1;
        -: 2830:
        -: 2831:/*
        -: 2832: * Lock file using fcntl().  Return 0 on success, 1 on failure of
        -: 2833: * locking mechanism, 2 on permanent failure (e.g. permission).
        -: 2834: */
        -: 2835:
        -: 2836:static int
    #####: 2837:flockhistfile(char *fn, int keep_trying)
        -: 2838:{
        -: 2839:    struct flock lck;
    #####: 2840:    long sleep_us = 0x10000; /* about 67 ms */
        -: 2841:    time_t end_time;
        -: 2842:
    #####: 2843:    if (flock_fd >= 0)
    #####: 2844:	return 0; /* already locked */
        -: 2845:
    #####: 2846:    if ((flock_fd = open(unmeta(fn), O_RDWR | O_NOCTTY)) < 0)
    #####: 2847:	return errno == ENOENT ? 0 : 2; /* "successfully" locked missing file */
        -: 2848:
    #####: 2849:    lck.l_type = F_WRLCK;
    #####: 2850:    lck.l_whence = SEEK_SET;
    #####: 2851:    lck.l_start = 0;
    #####: 2852:    lck.l_len = 0;  /* lock the whole file */
        -: 2853:
        -: 2854:    /*
        -: 2855:     * Timeout is ten seconds.
        -: 2856:     */
    #####: 2857:    end_time = time(NULL) + (time_t)10;
    #####: 2858:    while (fcntl(flock_fd, F_SETLKW, &lck) == -1) {
    #####: 2859:	if (!keep_trying || time(NULL) >= end_time ||
        -: 2860:	    /*
        -: 2861:	     * Randomise wait to minimise clashes with shells exiting at
        -: 2862:	     * the same time.
        -: 2863:	     */
    #####: 2864:	    !zsleep_random(sleep_us, end_time)) {
    #####: 2865:	    close(flock_fd);
    #####: 2866:	    flock_fd = -1;
    #####: 2867:	    return 1;
        -: 2868:	}
    #####: 2869:	sleep_us <<= 1;
        -: 2870:    }
        -: 2871:
    #####: 2872:    return 0;
        -: 2873:}
        -: 2874:#endif
        -: 2875:
        -: 2876:/**/
        -: 2877:void
    #####: 2878:savehistfile(char *fn, int err, int writeflags)
        -: 2879:{
    #####: 2880:    char *t, *tmpfile, *start = NULL;
        -: 2881:    FILE *out;
        -: 2882:    Histent he;
    #####: 2883:    zlong xcurhist = curhist - !!(histactive & HA_ACTIVE);
    #####: 2884:    int extended_history = isset(EXTENDEDHISTORY);
        -: 2885:    int ret;
        -: 2886:
    #####: 2887:    if (!interact || savehistsiz <= 0 || !hist_ring
    #####: 2888:     || (!fn && !(fn = getsparam("HISTFILE"))))
    #####: 2889:	return;
    #####: 2890:    if (writeflags & HFILE_FAST) {
    #####: 2891:	he = gethistent(lasthist.next_write_ev, GETHIST_DOWNWARD);
    #####: 2892:	while (he && he->node.flags & HIST_OLD) {
    #####: 2893:	    lasthist.next_write_ev = he->histnum + 1;
    #####: 2894:	    he = down_histent(he);
        -: 2895:	}
    #####: 2896:	if (!he || lockhistfile(fn, 0))
    #####: 2897:	    return;
    #####: 2898:	if (histfile_linect > savehistsiz + savehistsiz / 5)
    #####: 2899:	    writeflags &= ~HFILE_FAST;
        -: 2900:    }
        -: 2901:    else {
    #####: 2902:	if (lockhistfile(fn, 1)) {
    #####: 2903:	    zerr("locking failed for %s: %e", fn, errno);
    #####: 2904:	    return;
        -: 2905:	}
    #####: 2906:	he = hist_ring->down;
        -: 2907:    }
    #####: 2908:    if (writeflags & HFILE_USE_OPTIONS) {
    #####: 2909:	if (isset(APPENDHISTORY) || isset(INCAPPENDHISTORY)
    #####: 2910:	 || isset(INCAPPENDHISTORYTIME) || isset(SHAREHISTORY))
    #####: 2911:	    writeflags |= HFILE_APPEND | HFILE_SKIPOLD;
        -: 2912:	else
    #####: 2913:	    histfile_linect = 0;
    #####: 2914:	if (isset(HISTSAVENODUPS))
    #####: 2915:	    writeflags |= HFILE_SKIPDUPS;
    #####: 2916:	if (isset(SHAREHISTORY))
    #####: 2917:	    extended_history = 1;
        -: 2918:    }
    #####: 2919:    errno = 0;
    #####: 2920:    if (writeflags & HFILE_APPEND) {
    #####: 2921:	int fd = open(unmeta(fn), O_CREAT | O_WRONLY | O_APPEND | O_NOCTTY, 0600);
    #####: 2922:	tmpfile = NULL;
    #####: 2923:	out = fd >= 0 ? fdopen(fd, "a") : NULL;
    #####: 2924:    } else if (!isset(HISTSAVEBYCOPY)) {
    #####: 2925:	int fd = open(unmeta(fn), O_CREAT | O_WRONLY | O_TRUNC | O_NOCTTY, 0600);
    #####: 2926:	tmpfile = NULL;
    #####: 2927:	out = fd >= 0 ? fdopen(fd, "w") : NULL;
        -: 2928:    } else {
    #####: 2929:	tmpfile = bicat(unmeta(fn), ".new");
    #####: 2930:	if (unlink(tmpfile) < 0 && errno != ENOENT)
    #####: 2931:	    out = NULL;
        -: 2932:	else {
        -: 2933:	    struct stat sb;
    #####: 2934:	    int old_exists = stat(unmeta(fn), &sb) == 0;
    #####: 2935:	    uid_t euid = geteuid();
        -: 2936:
    #####: 2937:	    if (old_exists
        -: 2938:#if defined HAVE_FCHMOD && defined HAVE_FCHOWN
    #####: 2939:	     && euid
        -: 2940:#endif
    #####: 2941:	     && sb.st_uid != euid) {
    #####: 2942:		free(tmpfile);
    #####: 2943:		tmpfile = NULL;
    #####: 2944:		if (err) {
    #####: 2945:		    if (isset(APPENDHISTORY) || isset(INCAPPENDHISTORY)
    #####: 2946:		     || isset(INCAPPENDHISTORYTIME) || isset(SHAREHISTORY))
    #####: 2947:			zerr("rewriting %s would change its ownership -- skipped", fn);
        -: 2948:		    else
    #####: 2949:			zerr("rewriting %s would change its ownership -- history not saved", fn);
    #####: 2950:		    err = 0; /* Don't report a generic error below. */
        -: 2951:		}
    #####: 2952:		out = NULL;
        -: 2953:	    } else {
    #####: 2954:		int fd = open(tmpfile, O_CREAT | O_WRONLY | O_EXCL, 0600);
    #####: 2955:		if (fd >=0) {
    #####: 2956:		    out = fdopen(fd, "w");
    #####: 2957:		    if (!out)
    #####: 2958:			close(fd);
        -: 2959:		} else
    #####: 2960:		    out = NULL;
        -: 2961:	    }
        -: 2962:
        -: 2963:#ifdef HAVE_FCHMOD
    #####: 2964:	    if (old_exists && out) {
        -: 2965:#ifdef HAVE_FCHOWN
    #####: 2966:		if (fchown(fileno(out), sb.st_uid, sb.st_gid) < 0) {} /* IGNORE FAILURE */
        -: 2967:#endif
    #####: 2968:		if (fchmod(fileno(out), sb.st_mode) < 0) {} /* IGNORE FAILURE */
        -: 2969:	    }
        -: 2970:#endif
        -: 2971:	}
        -: 2972:    }
    #####: 2973:    if (out) {
        -: 2974:	char *history_ignore;
    #####: 2975:	Patprog histpat = NULL;
        -: 2976:
    #####: 2977:	pushheap();
        -: 2978:
    #####: 2979:	if ((history_ignore = getsparam("HISTORY_IGNORE")) != NULL) {
    #####: 2980:	    tokenize(history_ignore = dupstring(history_ignore));
    #####: 2981:	    remnulargs(history_ignore);
    #####: 2982:	    histpat = patcompile(history_ignore, 0, NULL);
        -: 2983:	}
        -: 2984:
    #####: 2985:	ret = 0;
    #####: 2986:	for (; he && he->histnum <= xcurhist; he = down_histent(he)) {
    #####: 2987:	    int count_backslashes = 0;
        -: 2988:
    #####: 2989:	    if ((writeflags & HFILE_SKIPDUPS && he->node.flags & HIST_DUP)
    #####: 2990:	     || (writeflags & HFILE_SKIPFOREIGN && he->node.flags & HIST_FOREIGN)
    #####: 2991:	     || he->node.flags & HIST_TMPSTORE)
    #####: 2992:		continue;
    #####: 2993:	    if (histpat &&
    #####: 2994:		pattry(histpat, metafy(he->node.nam, -1, META_HEAPDUP))) {
    #####: 2995:		continue;
        -: 2996:	    }
    #####: 2997:	    if (writeflags & HFILE_SKIPOLD) {
    #####: 2998:		if (he->node.flags & (HIST_OLD|HIST_NOWRITE))
    #####: 2999:		    continue;
    #####: 3000:		he->node.flags |= HIST_OLD;
    #####: 3001:		if (writeflags & HFILE_USE_OPTIONS)
    #####: 3002:		    lasthist.next_write_ev = he->histnum + 1;
        -: 3003:	    }
    #####: 3004:	    if (writeflags & HFILE_USE_OPTIONS) {
    #####: 3005:		lasthist.fpos = ftell(out);
    #####: 3006:		lasthist.stim = he->stim;
    #####: 3007:		histfile_linect++;
        -: 3008:	    }
    #####: 3009:	    t = start = he->node.nam;
    #####: 3010:	    if (extended_history) {
    #####: 3011:		ret = fprintf(out, ": %ld:%ld;", (long)he->stim,
    #####: 3012:			      he->ftim? (long)(he->ftim - he->stim) : 0L);
    #####: 3013:	    } else if (*t == ':')
    #####: 3014:		ret = fputc('\\', out);
        -: 3015:
    #####: 3016:	    for (; ret >= 0 && *t; t++) {
    #####: 3017:		if (*t == '\n')
    #####: 3018:		    if ((ret = fputc('\\', out)) < 0)
    #####: 3019:			break;
    #####: 3020:		if (*t == '\\')
    #####: 3021:		    count_backslashes++;
        -: 3022:		else
    #####: 3023:		    count_backslashes = 0;
    #####: 3024:		if ((ret = fputc(*t, out)) < 0)
    #####: 3025:		    break;
        -: 3026:	    }
    #####: 3027:	    if (ret < 0)
    #####: 3028:	    	break;
    #####: 3029:	    if (count_backslashes && (count_backslashes % 2 == 0))
    #####: 3030:		if ((ret = fputc(' ', out)) < 0)
    #####: 3031:		    break;
    #####: 3032:	    if (ret < 0 || (ret = fputc('\n', out)) < 0)
        -: 3033:		break;
        -: 3034:	}
    #####: 3035:	if (ret >= 0 && start && writeflags & HFILE_USE_OPTIONS) {
        -: 3036:	    struct stat sb;
    #####: 3037:	    if ((ret = fflush(out)) >= 0) {
    #####: 3038:		if (fstat(fileno(out), &sb) == 0) {
    #####: 3039:		    lasthist.fsiz = sb.st_size;
    #####: 3040:		    lasthist.mtim = sb.st_mtime;
        -: 3041:		}
    #####: 3042:		zsfree(lasthist.text);
    #####: 3043:		lasthist.text = ztrdup(start);
        -: 3044:	    }
        -: 3045:	}
    #####: 3046:	if (fclose(out) < 0 && ret >= 0)
    #####: 3047:	    ret = -1;
    #####: 3048:	if (ret >= 0) {
    #####: 3049:	    if (tmpfile) {
    #####: 3050:		if (rename(tmpfile, unmeta(fn)) < 0) {
    #####: 3051:		    zerr("can't rename %s.new to $HISTFILE", fn);
    #####: 3052:		    ret = -1;
    #####: 3053:		    err = 0;
        -: 3054:#ifdef HAVE_FCNTL_H
        -: 3055:		} else {
        -: 3056:		    /* We renamed over the locked HISTFILE, so close fd.
        -: 3057:		     * If we do more writing, we'll get a lock then. */
    #####: 3058:		    if (flock_fd >= 0) {
    #####: 3059:			close(flock_fd);
    #####: 3060:			flock_fd = -1;
        -: 3061:		    }
        -: 3062:#endif
        -: 3063:		}
        -: 3064:	    }
        -: 3065:
    #####: 3066:	    if (ret >= 0 && writeflags & HFILE_SKIPOLD
    #####: 3067:		&& !(writeflags & (HFILE_FAST | HFILE_NO_REWRITE))) {
    #####: 3068:		int remember_histactive = histactive;
        -: 3069:
        -: 3070:		/* Zeroing histactive avoids unnecessary munging of curline. */
    #####: 3071:		histactive = 0;
        -: 3072:		/* The NULL leaves HISTFILE alone, preserving fn's value. */
    #####: 3073:		pushhiststack(NULL, savehistsiz, savehistsiz, -1);
        -: 3074:
    #####: 3075:		hist_ignore_all_dups |= isset(HISTSAVENODUPS);
    #####: 3076:		readhistfile(fn, err, 0);
    #####: 3077:		hist_ignore_all_dups = isset(HISTIGNOREALLDUPS);
    #####: 3078:		if (histlinect)
    #####: 3079:		    savehistfile(fn, err, 0);
        -: 3080:
    #####: 3081:		pophiststack();
    #####: 3082:		histactive = remember_histactive;
        -: 3083:	    }
        -: 3084:	}
        -: 3085:
    #####: 3086:	popheap();
        -: 3087:    } else
    #####: 3088:	ret = -1;
        -: 3089:
    #####: 3090:    if (ret < 0 && err) {
    #####: 3091:	if (tmpfile)
    #####: 3092:	    zerr("failed to write history file %s.new: %e", fn, errno);
        -: 3093:	else
    #####: 3094:	    zerr("failed to write history file %s: %e", fn, errno);
        -: 3095:    }
    #####: 3096:    if (tmpfile)
    #####: 3097:	free(tmpfile);
        -: 3098:
    #####: 3099:    unlockhistfile(fn);
        -: 3100:}
        -: 3101:
        -: 3102:static int lockhistct;
        -: 3103:
        -: 3104:static int
    #####: 3105:checklocktime(char *lockfile, long *sleep_usp, time_t then)
        -: 3106:{
    #####: 3107:    time_t now = time(NULL);
        -: 3108:
    #####: 3109:    if (now + 10 < then) {
        -: 3110:	/* File is more than 10 seconds in the future? */
    #####: 3111:	errno = EEXIST;
    #####: 3112:	return -1;
        -: 3113:    }
        -: 3114:
    #####: 3115:    if (now - then < 10) {
        -: 3116:	/*
        -: 3117:	 * To give the effect of a gradually increasing backoff,
        -: 3118:	 * we'll sleep a period based on the time we've spent so far.
        -: 3119:	 */
        -: 3120:	DPUTS(now < then, "time flowing backwards through history");
        -: 3121:	/*
        -: 3122:	 * Randomise to minimise clashes with shells exiting at the same
        -: 3123:	 * time.
        -: 3124:	 */
    #####: 3125:	(void)zsleep_random(*sleep_usp, then + 10);
    #####: 3126:	*sleep_usp <<= 1;
        -: 3127:    } else
    #####: 3128:	unlink(lockfile);
        -: 3129:
    #####: 3130:    return 0;
        -: 3131:}
        -: 3132:
        -: 3133:/*
        -: 3134: * Lock history file.  Return 0 on success, 1 on failure to lock this
        -: 3135: * time, 2 on permanent failure (e.g. permission).
        -: 3136: */
        -: 3137:
        -: 3138:/**/
        -: 3139:int
    #####: 3140:lockhistfile(char *fn, int keep_trying)
        -: 3141:{
    #####: 3142:    int ct = lockhistct;
    #####: 3143:    int ret = 0;
    #####: 3144:    long sleep_us = 0x10000; /* about 67 ms */
        -: 3145:
    #####: 3146:    if (!fn && !(fn = getsparam("HISTFILE")))
    #####: 3147:	return 1;
        -: 3148:
    #####: 3149:    if (!lockhistct++) {
        -: 3150:	struct stat sb;
        -: 3151:	int fd;
        -: 3152:	char *lockfile;
        -: 3153:#ifdef HAVE_LINK
        -: 3154:# ifdef HAVE_SYMLINK
        -: 3155:	char pidbuf[32], *lnk;
        -: 3156:# else
        -: 3157:	char *tmpfile;
        -: 3158:# endif
        -: 3159:#endif
        -: 3160:
        -: 3161:#ifdef HAVE_FCNTL_H
    #####: 3162:	if (isset(HISTFCNTLLOCK))
    #####: 3163:	    return flockhistfile(fn, keep_trying);
        -: 3164:#endif
        -: 3165:
    #####: 3166:	lockfile = bicat(unmeta(fn), ".LOCK");
        -: 3167:	/* NOTE: only use symlink locking on a link()-having host in order to
        -: 3168:	 * avoid a change from open()-based locking to symlink()-based. */
        -: 3169:#ifdef HAVE_LINK
        -: 3170:# ifdef HAVE_SYMLINK
    #####: 3171:	sprintf(pidbuf, "/pid-%ld/host-", (long)mypid);
    #####: 3172:	lnk = getsparam("HOST");
    #####: 3173:	lnk = bicat(pidbuf, lnk ? lnk : "");
        -: 3174:	/* We'll abuse fd as our success flag. */
    #####: 3175:	while ((fd = symlink(lnk, lockfile)) < 0) {
    #####: 3176:	    if (errno != EEXIST) {
    #####: 3177:		ret = 2;
    #####: 3178:		break;
    #####: 3179:	    } else if (!keep_trying) {
    #####: 3180:		ret = 1;
    #####: 3181:		break;
        -: 3182:	    }
    #####: 3183:	    if (lstat(lockfile, &sb) < 0) {
    #####: 3184:		if (errno == ENOENT)
    #####: 3185:		    continue;
    #####: 3186:		break;
        -: 3187:	    }
    #####: 3188:	    if (checklocktime(lockfile, &sleep_us, sb.st_mtime) < 0) {
    #####: 3189:		ret = 1;
    #####: 3190:		break;
        -: 3191:	    }
        -: 3192:	}
    #####: 3193:	if (fd < 0)
    #####: 3194:	    lockhistct--;
    #####: 3195:	free(lnk);
        -: 3196:# else /* not HAVE_SYMLINK */
        -: 3197:	if ((fd = gettempfile(fn, 0, &tmpfile)) >= 0) {
        -: 3198:	    FILE *out = fdopen(fd, "w");
        -: 3199:	    if (out) {
        -: 3200:		fprintf(out, "%ld %s\n", (long)getpid(), getsparam("HOST"));
        -: 3201:		fclose(out);
        -: 3202:	    } else
        -: 3203:		close(fd);
        -: 3204:	    while (link(tmpfile, lockfile) < 0) {
        -: 3205:		if (errno != EEXIST) {
        -: 3206:		    ret = 2;
        -: 3207:		    break;
        -: 3208:		} else if (!keep_trying) {
        -: 3209:		    ret = 1;
        -: 3210:		    break;
        -: 3211:		} else if (lstat(lockfile, &sb) < 0) {
        -: 3212:		    if (errno == ENOENT)
        -: 3213:			continue;
        -: 3214:		    ret = 2;
        -: 3215:		} else {
        -: 3216:		    if (checklocktime(lockfile, &sleep_us, sb.st_mtime) < 0) {
        -: 3217:			ret = 1;
        -: 3218:			break;
        -: 3219:		    }
        -: 3220:		    continue;
        -: 3221:		}
        -: 3222:		lockhistct--;
        -: 3223:		break;
        -: 3224:	    }
        -: 3225:	    unlink(tmpfile);
        -: 3226:	    free(tmpfile);
        -: 3227:	}
        -: 3228:# endif /* not HAVE_SYMLINK */
        -: 3229:#else /* not HAVE_LINK */
        -: 3230:	while ((fd = open(lockfile, O_WRONLY|O_CREAT|O_EXCL, 0644)) < 0) {
        -: 3231:	    if (errno != EEXIST) {
        -: 3232:		ret = 2;
        -: 3233:		break;
        -: 3234:	    } else if (!keep_trying) {
        -: 3235:		ret = 1;
        -: 3236:		break;
        -: 3237:	    }
        -: 3238:	    if (lstat(lockfile, &sb) < 0) {
        -: 3239:		if (errno == ENOENT)
        -: 3240:		    continue;
        -: 3241:		ret = 2;
        -: 3242:		break;
        -: 3243:	    }
        -: 3244:	    if (checklocktime(lockfile, &sleep_us, sb.st_mtime) < 0) {
        -: 3245:		ret = 1;
        -: 3246:		break;
        -: 3247:	    }
        -: 3248:	}
        -: 3249:	if (fd < 0)
        -: 3250:	    lockhistct--;
        -: 3251:	else {
        -: 3252:	    FILE *out = fdopen(fd, "w");
        -: 3253:	    if (out) {
        -: 3254:		fprintf(out, "%ld %s\n", (long)mypid, getsparam("HOST"));
        -: 3255:		fclose(out);
        -: 3256:	    } else
        -: 3257:		close(fd);
        -: 3258:	}
        -: 3259:#endif /* not HAVE_LINK */
    #####: 3260:	free(lockfile);
        -: 3261:    }
        -: 3262:
    #####: 3263:    if (ct == lockhistct) {
        -: 3264:#ifdef HAVE_FCNTL_H
    #####: 3265:	if (flock_fd >= 0) {
    #####: 3266:	    close(flock_fd);
    #####: 3267:	    flock_fd = -1;
        -: 3268:	}
        -: 3269:#endif
        -: 3270:	DPUTS(ret == 0, "BUG: return value non-zero on locking error");
    #####: 3271:	return ret;
        -: 3272:    }
    #####: 3273:    return 0;
        -: 3274:}
        -: 3275:
        -: 3276:/* Unlock the history file if this corresponds to the last nested lock
        -: 3277: * request.  If we don't have the file locked, just return.
        -: 3278: */
        -: 3279:
        -: 3280:/**/
        -: 3281:void
    #####: 3282:unlockhistfile(char *fn)
        -: 3283:{
    #####: 3284:    if (!fn && !(fn = getsparam("HISTFILE")))
    #####: 3285:	return;
    #####: 3286:    if (--lockhistct) {
    #####: 3287:	if (lockhistct < 0)
    #####: 3288:	    lockhistct = 0;
        -: 3289:    }
        -: 3290:    else {
        -: 3291:	char *lockfile;
    #####: 3292:	fn = unmeta(fn);
    #####: 3293:	lockfile = zalloc(strlen(fn) + 5 + 1);
    #####: 3294:	sprintf(lockfile, "%s.LOCK", fn);
    #####: 3295:	unlink(lockfile);
    #####: 3296:	free(lockfile);
        -: 3297:#ifdef HAVE_FCNTL_H
    #####: 3298:	if (flock_fd >= 0) {
    #####: 3299:	    close(flock_fd);
    #####: 3300:	    flock_fd = -1;
        -: 3301:	}
        -: 3302:#endif
        -: 3303:    }
        -: 3304:}
        -: 3305:
        -: 3306:/**/
        -: 3307:int
    #####: 3308:histfileIsLocked(void)
        -: 3309:{
    #####: 3310:    return lockhistct > 0;
        -: 3311:}
        -: 3312:
        -: 3313:/*
        -: 3314: * Get the words in the current buffer. Using the lexer. 
        -: 3315: *
        -: 3316: * As far as I can make out, this is a gross hack based on a gross hack.
        -: 3317: * When analysing lines from within zle, we tweak the metafied line
        -: 3318: * positions (zlemetall and zlemetacs) directly in the lexer.  That's
        -: 3319: * bad enough, but this function appears to be designed to be called
        -: 3320: * from outside zle, pretending to be in zle and calling out, so
        -: 3321: * we set zlemetall and zlemetacs locally and copy the current zle line,
        -: 3322: * which may not even be valid at this point.
        -: 3323: *
        -: 3324: * However, I'm so confused it could simply be baking Bakewell tarts.
        -: 3325: *
        -: 3326: * list may be an existing linked list (off the heap), in which case
        -: 3327: * it will be appended to; otherwise it will be created.
        -: 3328: *
        -: 3329: * If buf is set we will take input from that string, else we will
        -: 3330: * attempt to use ZLE directly in a way they tell you not to do on all
        -: 3331: * programming courses.
        -: 3332: *
        -: 3333: * If index is non-NULL, and input is from a string in ZLE, *index
        -: 3334: * is set to the position of the end of the current editor word.
        -: 3335: *
        -: 3336: * flags is passed directly to lexflags, see lex.c, except that
        -: 3337: * we 'or' in the bit LEXFLAGS_ACTIVE to make sure the variable
        -: 3338: * is set.
        -: 3339: */
        -: 3340:
        -: 3341:/**/
        -: 3342:mod_export LinkList
    #####: 3343:bufferwords(LinkList list, char *buf, int *index, int flags)
        -: 3344:{
    #####: 3345:    int num = 0, cur = -1, got = 0, ne = noerrs;
    #####: 3346:    int owb = wb, owe = we, oadx = addedx, onc = nocomments;
    #####: 3347:    int ona = noaliases, ocs = zlemetacs, oll = zlemetall;
    #####: 3348:    int forloop = 0, rcquotes = opts[RCQUOTES];
    #####: 3349:    int envarray = 0;
        -: 3350:    char *p, *addedspaceptr;
        -: 3351:
    #####: 3352:    if (!list)
    #####: 3353:	list = newlinklist();
        -: 3354:
        -: 3355:    /*
        -: 3356:     * With RC_QUOTES, 'foo '' bar' comes back as 'foo ' bar'.  That's
        -: 3357:     * not very useful.  As nothing in here requires the fully processed
        -: 3358:     * string expression, we just turn the option off for this function.
        -: 3359:     */
    #####: 3360:    opts[RCQUOTES] = 0;
    #####: 3361:    addedx = 0;
    #####: 3362:    noerrs = 1;
    #####: 3363:    zcontext_save();
    #####: 3364:    lexflags = flags | LEXFLAGS_ACTIVE;
        -: 3365:    /*
        -: 3366:     * Are we handling comments?
        -: 3367:     */
    #####: 3368:    nocomments = !(flags & (LEXFLAGS_COMMENTS_KEEP|
        -: 3369:			    LEXFLAGS_COMMENTS_STRIP));
    #####: 3370:    if (buf) {
    #####: 3371:	int l = strlen(buf);
        -: 3372:
    #####: 3373:	p = (char *) zhalloc(l + 2);
    #####: 3374:	memcpy(p, buf, l);
        -: 3375:	/*
        -: 3376:	 * I'm sure this space is here for a reason, but it's
        -: 3377:	 * a pain in the neck:  when we get back a string that's
        -: 3378:	 * not finished it's very hard to tell if a space at the
        -: 3379:	 * end is this one or not.  We use two tricks below to
        -: 3380:	 * work around this.
        -: 3381:	 */
    #####: 3382:	addedspaceptr = p + l;
    #####: 3383:	*addedspaceptr = ' ';
    #####: 3384:	addedspaceptr[1] = '\0';
    #####: 3385:	inpush(p, 0, NULL);
    #####: 3386:	zlemetall = strlen(p) ;
    #####: 3387:	zlemetacs = zlemetall + 1;
        -: 3388:    } else {
        -: 3389:	int ll, cs;
        -: 3390:	char *linein;
        -: 3391:
    #####: 3392:	linein = zleentry(ZLE_CMD_GET_LINE, &ll, &cs);
    #####: 3393:	zlemetall = ll + 1; /* length of line plus space added below */
    #####: 3394:	zlemetacs = cs;
        -: 3395:
    #####: 3396:	if (!isfirstln && chline) {
    #####: 3397:	    p = (char *) zhalloc(hptr - chline + ll + 2);
    #####: 3398:	    memcpy(p, chline, hptr - chline);
    #####: 3399:	    memcpy(p + (hptr - chline), linein, ll);
    #####: 3400:	    addedspaceptr = p + (hptr - chline) + ll;
    #####: 3401:	    *addedspaceptr = ' ';
    #####: 3402:	    addedspaceptr[1] = '\0';
    #####: 3403:	    inpush(p, 0, NULL);
        -: 3404:
        -: 3405:	    /*
        -: 3406:	     * advance line length and character position over
        -: 3407:	     * prepended string.
        -: 3408:	     */
    #####: 3409:	    zlemetall += hptr - chline;
    #####: 3410:	    zlemetacs += hptr - chline;
        -: 3411:	} else {
    #####: 3412:	    p = (char *) zhalloc(ll + 2);
    #####: 3413:	    memcpy(p, linein, ll);
    #####: 3414:	    addedspaceptr = p + ll;
    #####: 3415:	    *addedspaceptr = ' ';
    #####: 3416:	    p[zlemetall] = '\0';
    #####: 3417:	    inpush(p, 0, NULL);
        -: 3418:	}
    #####: 3419:	zsfree(linein);
        -: 3420:    }
    #####: 3421:    if (zlemetacs)
    #####: 3422:	zlemetacs--;
    #####: 3423:    strinbeg(0);
    #####: 3424:    noaliases = 1;
        -: 3425:    do {
    #####: 3426:	if (incond)
    #####: 3427:	    incond = 1 + (tok != DINBRACK && tok != INPAR &&
    #####: 3428:			  tok != DBAR && tok != DAMPER &&
    #####: 3429:			  tok != BANG);
    #####: 3430:	ctxtlex();
    #####: 3431:	if (tok == ENDINPUT || tok == LEXERR)
        -: 3432:	    break;
        -: 3433:	/*
        -: 3434:	 * After an array assignment, return to the initial
        -: 3435:	 * start-of-command state.  There could be a second ENVARRAY.
        -: 3436:	 */
    #####: 3437:	if (tok == OUTPAR && envarray) {
    #####: 3438:	    incmdpos = 1;
    #####: 3439:	    envarray = 0;
        -: 3440:	}
    #####: 3441:	if (tok == FOR) {
        -: 3442:	    /*
        -: 3443:	     * The way for (( expr1 ; expr2; expr3 )) is parsed is:
        -: 3444:	     * - a FOR tok
        -: 3445:	     * - a DINPAR with no tokstr
        -: 3446:	     * - two DINPARS with tokstr's expr1, expr2.
        -: 3447:	     * - a DOUTPAR with tokstr expr3.
        -: 3448:	     *
        -: 3449:	     * We'll decrement the variable forloop as we verify
        -: 3450:	     * the various stages.
        -: 3451:	     *
        -: 3452:	     * Don't ask me, ma'am, I'm just the programmer.
        -: 3453:	     */
    #####: 3454:	    forloop = 5;
        -: 3455:	} else {
    #####: 3456:	    switch (forloop) {
    #####: 3457:	    case 1:
    #####: 3458:		if (tok != DOUTPAR)
    #####: 3459:		    forloop = 0;
    #####: 3460:		break;
        -: 3461:
    #####: 3462:	    case 2:
        -: 3463:	    case 3:
        -: 3464:	    case 4:
    #####: 3465:		if (tok != DINPAR)
    #####: 3466:		    forloop = 0;
    #####: 3467:		break;
        -: 3468:
    #####: 3469:	    default:
        -: 3470:		/* nothing to do */
    #####: 3471:		break;
        -: 3472:	    }
        -: 3473:	}
    #####: 3474:	if (tokstr) {
    #####: 3475:	    switch (tok) {
    #####: 3476:	    case ENVARRAY:
    #####: 3477:		p = dyncat(tokstr, "=(");
    #####: 3478:		envarray = 1;
    #####: 3479:		break;
        -: 3480:
    #####: 3481:	    case DINPAR:
    #####: 3482:		if (forloop) {
        -: 3483:		    /* See above. */
    #####: 3484:		    p = dyncat(tokstr, ";");
        -: 3485:		} else {
        -: 3486:		    /*
        -: 3487:		     * Mathematical expressions analysed as a single
        -: 3488:		     * word.  That's correct because it behaves like
        -: 3489:		     * double quotes.  Whitespace in the middle is
        -: 3490:		     * similarly retained, so just add the parentheses back.
        -: 3491:		     */
    #####: 3492:		    p = zhtricat("((", tokstr, "))");
        -: 3493:		}
    #####: 3494:		break;
        -: 3495:
    #####: 3496:	    default:
    #####: 3497:		p = dupstring(tokstr);
    #####: 3498:		break;
        -: 3499:	    }
    #####: 3500:	    if (*p) {
    #####: 3501:		untokenize(p);
    #####: 3502:		if (ingetptr() == addedspaceptr + 1) {
        -: 3503:		    /*
        -: 3504:		     * Whoops, we've read past the space we added, probably
        -: 3505:		     * because we were expecting a terminator but when
        -: 3506:		     * it didn't turn up we shrugged our shoulders thinking
        -: 3507:		     * it might as well be a complete string anyway.
        -: 3508:		     * So remove the space.  C.f. below for the case
        -: 3509:		     * where the missing terminator caused a lex error.
        -: 3510:		     * We use the same paranoid test.
        -: 3511:		     */
    #####: 3512:		    int plen = strlen(p);
    #####: 3513:		    if (plen && p[plen-1] == ' ' &&
    #####: 3514:			(plen == 1 || p[plen-2] != Meta))
    #####: 3515:			p[plen-1] = '\0';
        -: 3516:		}
    #####: 3517:		addlinknode(list, p);
    #####: 3518:		num++;
        -: 3519:	    }
    #####: 3520:	} else if (buf) {
    #####: 3521:	    if (IS_REDIROP(tok) && tokfd >= 0) {
        -: 3522:		char b[20];
        -: 3523:
    #####: 3524:		sprintf(b, "%d%s", tokfd, tokstrings[tok]);
    #####: 3525:		addlinknode(list, dupstring(b));
    #####: 3526:		num++;
    #####: 3527:	    } else if (tok != NEWLIN) {
    #####: 3528:		addlinknode(list, dupstring(tokstrings[tok]));
    #####: 3529:		num++;
        -: 3530:	    }
        -: 3531:	}
    #####: 3532:	if (forloop) {
    #####: 3533:	    if (forloop == 1) {
        -: 3534:		/*
        -: 3535:		 * Final "))" of for loop to match opening,
        -: 3536:		 * since we've just added the preceding element.
        -: 3537: 		 */
    #####: 3538:		addlinknode(list, dupstring("))"));
        -: 3539:	    }
    #####: 3540:	    forloop--;
        -: 3541:	}
    #####: 3542:	if (!got && !lexflags) {
    #####: 3543:	    got = 1;
    #####: 3544:	    cur = num - 1;
        -: 3545:	}
    #####: 3546:    } while (tok != ENDINPUT && tok != LEXERR && !(errflag & ERRFLAG_INT));
    #####: 3547:    if (buf && tok == LEXERR && tokstr && *tokstr) {
        -: 3548:	int plen;
    #####: 3549:	untokenize((p = dupstring(tokstr)));
    #####: 3550:	plen = strlen(p);
        -: 3551:	/*
        -: 3552:	 * Strip the space we added for lexing but which won't have
        -: 3553:	 * been swallowed by the lexer because we aborted early.
        -: 3554:	 * The test is paranoia.
        -: 3555:	 */
    #####: 3556:	if (plen && p[plen-1] == ' ' && (plen == 1 || p[plen-2] != Meta))
    #####: 3557:	    p[plen - 1] = '\0';
    #####: 3558:	addlinknode(list, p);
    #####: 3559:	num++;
        -: 3560:    }
    #####: 3561:    if (cur < 0 && num)
    #####: 3562:	cur = num - 1;
    #####: 3563:    noaliases = ona;
    #####: 3564:    strinend();
    #####: 3565:    inpop();
    #####: 3566:    errflag &= ~ERRFLAG_ERROR;
    #####: 3567:    nocomments = onc;
    #####: 3568:    noerrs = ne;
    #####: 3569:    zcontext_restore();
    #####: 3570:    zlemetacs = ocs;
    #####: 3571:    zlemetall = oll;
    #####: 3572:    wb = owb;
    #####: 3573:    we = owe;
    #####: 3574:    addedx = oadx;
    #####: 3575:    opts[RCQUOTES] = rcquotes;
        -: 3576:
    #####: 3577:    if (index)
    #####: 3578:	*index = cur;
        -: 3579:
    #####: 3580:    return list;
        -: 3581:}
        -: 3582:
        -: 3583:/*
        -: 3584: * Split up a line into words for use in a history file.
        -: 3585: *
        -: 3586: * lineptr is the line to be split.
        -: 3587: *
        -: 3588: * *wordsp and *nwordsp are an array already allocated to hold words
        -: 3589: * and its length.  The array holds both start and end positions,
        -: 3590: * so *nwordsp actually counts twice the number of words in the
        -: 3591: * original string.  *nwordsp may be zero in which case the array
        -: 3592: * will be allocated.
        -: 3593: *
        -: 3594: * *nwordposp returns the used length of *wordsp in the same units as
        -: 3595: * *nwordsp, i.e. twice the number of words in the input line.
        -: 3596: *
        -: 3597: * If uselex is 1, attempt to do this using the lexical analyser.
        -: 3598: * This is more accurate, but slower; for reading history files it's
        -: 3599: * controlled by the option HISTLEXWORDS.  If this failed (which
        -: 3600: * indicates a bug in the shell) it falls back to whitespace-separated
        -: 3601: * strings, printing a message if in debug mode.
        -: 3602: *
        -: 3603: * If uselex is 0, just look for whitespace-separated words; the only
        -: 3604: * special handling is for a backslash-newline combination as used
        -: 3605: * by the history file format to save multiline buffers.
        -: 3606: */
        -: 3607:/**/
        -: 3608:mod_export void
    #####: 3609:histsplitwords(char *lineptr, short **wordsp, int *nwordsp, int *nwordposp,
        -: 3610:	       int uselex)
        -: 3611:{
    #####: 3612:    int nwords = *nwordsp, nwordpos = 0;
    #####: 3613:    short *words = *wordsp;
    #####: 3614:    char *start = lineptr;
        -: 3615:
    #####: 3616:    if (uselex) {
        -: 3617:	LinkList wordlist;
        -: 3618:	LinkNode wordnode;
        -: 3619:	int nwords_max;
        -: 3620:
    #####: 3621:	wordlist = bufferwords(NULL, lineptr, NULL,
        -: 3622:			       LEXFLAGS_COMMENTS_KEEP);
    #####: 3623:	if (errflag)
    #####: 3624:	    return;
    #####: 3625:	nwords_max = 2 * countlinknodes(wordlist);
    #####: 3626:	if (nwords_max > nwords) {
    #####: 3627:	    *nwordsp = nwords = nwords_max;
    #####: 3628:	    *wordsp = words = (short *)zrealloc(words, nwords*sizeof(short));
        -: 3629:	}
    #####: 3630:	for (wordnode = firstnode(wordlist);
        -: 3631:	     wordnode;
    #####: 3632:	     incnode(wordnode)) {
    #####: 3633:	    char *word = getdata(wordnode);
    #####: 3634:	    char *lptr, *wptr = word;
    #####: 3635:	    int loop_next = 0, skipping;
        -: 3636:
        -: 3637:	    /* Skip stuff at the start of the word */
        -: 3638:	    for (;;) {
        -: 3639:		/*
        -: 3640:		 * Not really an oddity: "\\\n" is
        -: 3641:		 * removed from input as if whitespace.
        -: 3642:		 */
    #####: 3643:		if (inblank(*lineptr))
    #####: 3644:		    lineptr++;
    #####: 3645:		else if (lineptr[0] == '\\' && lineptr[1] == '\n') {
        -: 3646:		    /*
        -: 3647:		     * Optimisation: we handle this in the loop below,
        -: 3648:		     * too.
        -: 3649:		     */
    #####: 3650:		    lineptr += 2;
        -: 3651:		} else
        -: 3652:		    break;
        -: 3653:	    }
    #####: 3654:	    lptr = lineptr;
        -: 3655:	    /*
        -: 3656:	     * Skip chunks of word with possible intervening
        -: 3657:	     * backslash-newline.
        -: 3658:	     *
        -: 3659:	     * To get round C's annoying lack of ability to
        -: 3660:	     * reference the outer loop, we'll break from this
        -: 3661:	     * one with
        -: 3662:	     * loop_next = 0: carry on as normal
        -: 3663:	     * loop_next = 1: break from outer loop
        -: 3664:	     * loop_next = 2: continue round outer loop.
        -: 3665:	     */
        -: 3666:	    do {
    #####: 3667:		skipping = 0;
    #####: 3668:		if (strpfx(wptr, lptr)) {
        -: 3669:		    /*
        -: 3670:		     * Normal case: word from lexer matches start of
        -: 3671:		     * string from line.  Just advance over it.
        -: 3672:		     */
        -: 3673:		    int len;
    #####: 3674:		    if (!strcmp(wptr, ";") && strpfx(";;", lptr)) {
        -: 3675:			/*
        -: 3676:			 * Don't get confused between a semicolon that's
        -: 3677:			 * probably really a newline and a double
        -: 3678:			 * semicolon that's terminating a case.
        -: 3679:			 */
    #####: 3680:			loop_next = 2;
    #####: 3681:			break;
        -: 3682:		    }
    #####: 3683:		    len = strlen(wptr);
    #####: 3684:		    lptr += len;
    #####: 3685:		    wptr += len;
        -: 3686:		} else {
        -: 3687:		    /*
        -: 3688:		     * Didn't get to the end of the word.
        -: 3689:		     * See what's amiss.
        -: 3690:		     */
    #####: 3691:		    int bad = 0;
        -: 3692:		    /*
        -: 3693:		     * Oddity 1: newlines turn into semicolons.
        -: 3694:		     */
    #####: 3695:		    if (!strcmp(wptr, ";"))
        -: 3696:		    {
    #####: 3697:			loop_next = 2;
    #####: 3698:			break;
        -: 3699:		    }
    #####: 3700:		    while (*lptr) {
    #####: 3701:			if (!*wptr) {
        -: 3702:			    /*
        -: 3703:			     * End of the word before the end of the
        -: 3704:			     * line: not good.
        -: 3705:			     */
    #####: 3706:			    bad = 1;
    #####: 3707:			    loop_next = 1;
    #####: 3708:			    break;
        -: 3709:			}
        -: 3710:			/*
        -: 3711:			 * Oddity 2: !'s turn into |'s.
        -: 3712:			 */
    #####: 3713:			if (*lptr == *wptr ||
    #####: 3714:			    (*lptr == '!' && *wptr == '|')) {
    #####: 3715:			    lptr++;
    #####: 3716:			    if (!*++wptr)
    #####: 3717:				break;
    #####: 3718:			} else if (lptr[0] == '\\' &&
    #####: 3719:				   lptr[1] == '\n') {
        -: 3720:			    /*
        -: 3721:			     * \\\n can occur in the middle of a word;
        -: 3722:			     * wptr is already pointing at this, we
        -: 3723:			     * just need to skip over the break
        -: 3724:			     * in lptr and look at the next chunk.
        -: 3725:			     */
    #####: 3726:			    lptr += 2;
    #####: 3727:			    skipping = 1;
    #####: 3728:			    break;
        -: 3729:			} else {
    #####: 3730:			    bad = 1;
    #####: 3731:			    loop_next = 1;
    #####: 3732:			    break;
        -: 3733:			}
        -: 3734:		    }
    #####: 3735:		    if (bad) {
        -: 3736:#ifdef DEBUG
        -: 3737:			dputs(ERRMSG("bad wordsplit reading history: "
        -: 3738:				     "%s\nat: %s\nword: %s"),
        -: 3739:			      start, lineptr, word);
        -: 3740:#endif
    #####: 3741:			lineptr = start;
    #####: 3742:			nwordpos = 0;
    #####: 3743:			uselex = 0;
    #####: 3744:			loop_next = 1;
        -: 3745:		    }
        -: 3746:		}
    #####: 3747:	    } while (skipping);
    #####: 3748:	    if (loop_next) {
    #####: 3749:		if (loop_next == 1)
    #####: 3750:		    break;
    #####: 3751:		continue;
        -: 3752:	    }
        -: 3753:	    /* Record position of current word... */
    #####: 3754:	    words[nwordpos++] = lineptr - start;
    #####: 3755:	    words[nwordpos++] = lptr - start;
        -: 3756:
        -: 3757:	    /* ready for start of next word. */
    #####: 3758:	    lineptr = lptr;
        -: 3759:	}
        -: 3760:    }
    #####: 3761:    if (!uselex) {
        -: 3762:	do {
        -: 3763:	    for (;;) {
    #####: 3764:		if (inblank(*lineptr))
    #####: 3765:		    lineptr++;
    #####: 3766:		else if (lineptr[0] == '\\' && lineptr[1] == '\n')
    #####: 3767:		    lineptr += 2;
        -: 3768:		else
        -: 3769:		    break;
        -: 3770:	    }
    #####: 3771:	    if (*lineptr) {
    #####: 3772:		if (nwordpos >= nwords) {
    #####: 3773:		    *nwordsp = nwords = nwords + 64;
    #####: 3774:		    *wordsp = words = (short *)
    #####: 3775:			zrealloc(words, nwords*sizeof(*words));
        -: 3776:		}
    #####: 3777:		words[nwordpos++] = lineptr - start;
    #####: 3778:		while (*lineptr && !inblank(*lineptr))
    #####: 3779:		    lineptr++;
    #####: 3780:		words[nwordpos++] = lineptr - start;
        -: 3781:	    }
    #####: 3782:	} while (*lineptr);
        -: 3783:    }
        -: 3784:
    #####: 3785:    *nwordposp = nwordpos;
        -: 3786:}
        -: 3787:
        -: 3788:/* Move the current history list out of the way and prepare a fresh history
        -: 3789: * list using hf for HISTFILE, hs for HISTSIZE, and shs for SAVEHIST.  If
        -: 3790: * the hf value is an empty string, HISTFILE will be unset from the new
        -: 3791: * environment; if it is NULL, HISTFILE will not be changed, not even by the
        -: 3792: * pop function (this functionality is used internally to rewrite the current
        -: 3793: * history file without affecting pointers into the environment).
        -: 3794: */
        -: 3795:
        -: 3796:/**/
        -: 3797:int
    #####: 3798:pushhiststack(char *hf, zlong hs, zlong shs, int level)
        -: 3799:{
        -: 3800:    struct histsave *h;
    #####: 3801:    int curline_in_ring = (histactive & HA_ACTIVE) && hist_ring == &curline;
        -: 3802:
    #####: 3803:    if (histsave_stack_pos == histsave_stack_size) {
    #####: 3804:	histsave_stack_size += 5;
    #####: 3805:	histsave_stack = zrealloc(histsave_stack,
        -: 3806:			    histsave_stack_size * sizeof (struct histsave));
        -: 3807:    }
        -: 3808:
    #####: 3809:    if (curline_in_ring)
    #####: 3810:	unlinkcurline();
        -: 3811:
    #####: 3812:    h = &histsave_stack[histsave_stack_pos++];
        -: 3813:
    #####: 3814:    h->lasthist = lasthist;
    #####: 3815:    if (hf) {
    #####: 3816:	if ((h->histfile = getsparam("HISTFILE")) != NULL && *h->histfile)
    #####: 3817:	    h->histfile = ztrdup(h->histfile);
        -: 3818:	else
    #####: 3819:	    h->histfile = "";
        -: 3820:    } else
    #####: 3821:	h->histfile = NULL;
    #####: 3822:    h->histtab = histtab;
    #####: 3823:    h->hist_ring = hist_ring;
    #####: 3824:    h->curhist = curhist;
    #####: 3825:    h->histlinect = histlinect;
    #####: 3826:    h->histsiz = histsiz;
    #####: 3827:    h->savehistsiz = savehistsiz;
    #####: 3828:    h->locallevel = level;
        -: 3829:
    #####: 3830:    memset(&lasthist, 0, sizeof lasthist);
    #####: 3831:    if (hf) {
    #####: 3832:	if (*hf)
    #####: 3833:	    setsparam("HISTFILE", ztrdup(hf));
        -: 3834:	else
    #####: 3835:	    unsetparam("HISTFILE");
        -: 3836:    }
    #####: 3837:    hist_ring = NULL;
    #####: 3838:    curhist = histlinect = 0;
    #####: 3839:    if (zleactive)
    #####: 3840:	zleentry(ZLE_CMD_SET_HIST_LINE, curhist);
    #####: 3841:    histsiz = hs;
    #####: 3842:    savehistsiz = shs;
    #####: 3843:    inithist(); /* sets histtab */
        -: 3844:
    #####: 3845:    if (curline_in_ring)
    #####: 3846:	linkcurline();
        -: 3847:
    #####: 3848:    return histsave_stack_pos;
        -: 3849:}
        -: 3850:
        -: 3851:
        -: 3852:/**/
        -: 3853:int
    #####: 3854:pophiststack(void)
        -: 3855:{
        -: 3856:    struct histsave *h;
    #####: 3857:    int curline_in_ring = (histactive & HA_ACTIVE) && hist_ring == &curline;
        -: 3858:
    #####: 3859:    if (histsave_stack_pos == 0)
    #####: 3860:	return 0;
        -: 3861:
    #####: 3862:    if (curline_in_ring)
    #####: 3863:	unlinkcurline();
        -: 3864:
    #####: 3865:    deletehashtable(histtab);
    #####: 3866:    zsfree(lasthist.text);
        -: 3867:
    #####: 3868:    h = &histsave_stack[--histsave_stack_pos];
        -: 3869:
    #####: 3870:    lasthist = h->lasthist;
    #####: 3871:    if (h->histfile) {
    #####: 3872:	if (*h->histfile)
    #####: 3873:	    setsparam("HISTFILE", h->histfile);
        -: 3874:	else
    #####: 3875:	    unsetparam("HISTFILE");
        -: 3876:    }
    #####: 3877:    histtab = h->histtab;
    #####: 3878:    hist_ring = h->hist_ring;
    #####: 3879:    curhist = h->curhist;
    #####: 3880:    if (zleactive)
    #####: 3881:	zleentry(ZLE_CMD_SET_HIST_LINE, curhist);
    #####: 3882:    histlinect = h->histlinect;
    #####: 3883:    histsiz = h->histsiz;
    #####: 3884:    savehistsiz = h->savehistsiz;
        -: 3885:
    #####: 3886:    if (curline_in_ring)
    #####: 3887:	linkcurline();
        -: 3888:
    #####: 3889:    return histsave_stack_pos + 1;
        -: 3890:}
        -: 3891:
        -: 3892:/* If pop_through > 0, pop all array items >= the 1-relative index value.
        -: 3893: * If pop_through <= 0, pop (-1)*pop_through levels off the stack.
        -: 3894: * If the (new) top of stack is from a higher locallevel, auto-pop until
        -: 3895: * it is not.
        -: 3896: */
        -: 3897:
        -: 3898:/**/
        -: 3899:int
     2816: 3900:saveandpophiststack(int pop_through, int writeflags)
        -: 3901:{
     2816: 3902:    if (pop_through <= 0) {
     2816: 3903:	pop_through += histsave_stack_pos + 1;
     2816: 3904:	if (pop_through <= 0)
    #####: 3905:	    pop_through = 1;
        -: 3906:    }
     5632: 3907:    while (pop_through > 1
    #####: 3908:     && histsave_stack[pop_through-2].locallevel > locallevel)
    #####: 3909:	pop_through--;
     2816: 3910:    if (histsave_stack_pos < pop_through)
     2816: 3911:	return 0;
        -: 3912:    do {
    #####: 3913:	if (!nohistsave)
    #####: 3914:	    savehistfile(NULL, 1, writeflags);
    #####: 3915:	pophiststack();
    #####: 3916:    } while (histsave_stack_pos >= pop_through);
    #####: 3917:    return 1;
        -: 3918:}
