        -:    0:Source:params.c
        -:    0:Graph:/home/workspace/Src/params.gcno
        -:    0:Data:/home/workspace/Src/params.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:/*
        -:    2: * params.c - parameters
        -:    3: *
        -:    4: * This file is part of zsh, the Z shell.
        -:    5: *
        -:    6: * Copyright (c) 1992-1997 Paul Falstad
        -:    7: * All rights reserved.
        -:    8: *
        -:    9: * Permission is hereby granted, without written agreement and without
        -:   10: * license or royalty fees, to use, copy, modify, and distribute this
        -:   11: * software and to distribute modified versions of this software for any
        -:   12: * purpose, provided that the above copyright notice and the following
        -:   13: * two paragraphs appear in all copies of this software.
        -:   14: *
        -:   15: * In no event shall Paul Falstad or the Zsh Development Group be liable
        -:   16: * to any party for direct, indirect, special, incidental, or consequential
        -:   17: * damages arising out of the use of this software and its documentation,
        -:   18: * even if Paul Falstad and the Zsh Development Group have been advised of
        -:   19: * the possibility of such damage.
        -:   20: *
        -:   21: * Paul Falstad and the Zsh Development Group specifically disclaim any
        -:   22: * warranties, including, but not limited to, the implied warranties of
        -:   23: * merchantability and fitness for a particular purpose.  The software
        -:   24: * provided hereunder is on an "as is" basis, and Paul Falstad and the
        -:   25: * Zsh Development Group have no obligation to provide maintenance,
        -:   26: * support, updates, enhancements, or modifications.
        -:   27: *
        -:   28: */
        -:   29:
        -:   30:#include "zsh.mdh"
        -:   31:#include "params.pro"
        -:   32:
        -:   33:#include "version.h"
        -:   34:#ifdef CUSTOM_PATCHLEVEL
        -:   35:#define ZSH_PATCHLEVEL	CUSTOM_PATCHLEVEL
        -:   36:#else
        -:   37:#include "patchlevel.h"
        -:   38:
        -:   39:#include <math.h>
        -:   40:
        -:   41:/* If removed from the ChangeLog for some reason */
        -:   42:#ifndef ZSH_PATCHLEVEL
        -:   43:#define ZSH_PATCHLEVEL "unknown"
        -:   44:#endif
        -:   45:#endif
        -:   46:
        -:   47:/* What level of localness we are at.
        -:   48: *
        -:   49: * Hand-wavingly, this is incremented at every function call and decremented
        -:   50: * at every function return.  See startparamscope().
        -:   51: */
        -:   52: 
        -:   53:/**/
        -:   54:mod_export int locallevel;
        -:   55:
        -:   56:/* Variables holding values of special parameters */
        -:   57: 
        -:   58:/**/
        -:   59:mod_export
        -:   60:char **pparams,		/* $argv        */
        -:   61:     **cdpath,		/* $cdpath      */
        -:   62:     **fpath,		/* $fpath       */
        -:   63:     **mailpath,	/* $mailpath    */
        -:   64:     **manpath,		/* $manpath     */
        -:   65:     **psvar,		/* $psvar       */
        -:   66:     **watch,		/* $watch       */
        -:   67:     **zsh_eval_context; /* $zsh_eval_context */
        -:   68:/**/
        -:   69:mod_export
        -:   70:char **path,		/* $path        */
        -:   71:     **fignore;		/* $fignore     */
        -:   72: 
        -:   73:/**/
        -:   74:mod_export
        -:   75:char *argzero,		/* $0           */
        -:   76:     *posixzero,	/* $0           */
        -:   77:     *home,		/* $HOME        */
        -:   78:     *nullcmd,		/* $NULLCMD     */
        -:   79:     *oldpwd,		/* $OLDPWD      */
        -:   80:     *zoptarg,		/* $OPTARG      */
        -:   81:     *prompt,		/* $PROMPT      */
        -:   82:     *prompt2,		/* $PROMPT2     */
        -:   83:     *prompt3,		/* $PROMPT3     */
        -:   84:     *prompt4,		/* $PROMPT4     */
        -:   85:     *readnullcmd,	/* $READNULLCMD */
        -:   86:     *rprompt,		/* $RPROMPT     */
        -:   87:     *rprompt2,		/* $RPROMPT2    */
        -:   88:     *sprompt,		/* $SPROMPT     */
        -:   89:     *wordchars;	/* $WORDCHARS   */
        -:   90:/**/
        -:   91:mod_export
        -:   92:char *ifs,		/* $IFS         */
        -:   93:     *postedit,		/* $POSTEDIT    */
        -:   94:     *term,		/* $TERM        */
        -:   95:     *zsh_terminfo,     /* $TERMINFO    */
        -:   96:     *zsh_terminfodirs, /* $TERMINFO_DIRS */
        -:   97:     *ttystrname,	/* $TTY         */
        -:   98:     *pwd;		/* $PWD         */
        -:   99:
        -:  100:/**/
        -:  101:mod_export volatile zlong
        -:  102:     lastval;		/* $?           */
        -:  103:/**/
        -:  104:mod_export zlong
        -:  105:     mypid,		/* $$           */
        -:  106:     lastpid,		/* $!           */
        -:  107:     zterm_columns,	/* $COLUMNS     */
        -:  108:     zterm_lines,	/* $LINES       */
        -:  109:     rprompt_indent,	/* $ZLE_RPROMPT_INDENT */
        -:  110:     ppid,		/* $PPID        */
        -:  111:     zsh_subshell;	/* $ZSH_SUBSHELL */
        -:  112:
        -:  113:/* $FUNCNEST    */
        -:  114:/**/
        -:  115:mod_export
        -:  116:zlong zsh_funcnest =
        -:  117:#ifdef MAX_FUNCTION_DEPTH
        -:  118:    MAX_FUNCTION_DEPTH
        -:  119:#else
        -:  120:    /* Disabled by default but can be enabled at run time */
        -:  121:    -1
        -:  122:#endif
        -:  123:    ;
        -:  124:
        -:  125:/**/
        -:  126:zlong lineno,		/* $LINENO      */
        -:  127:     zoptind,		/* $OPTIND      */
        -:  128:     shlvl;		/* $SHLVL       */
        -:  129:
        -:  130:/* $histchars */
        -:  131: 
        -:  132:/**/
        -:  133:mod_export unsigned char bangchar;
        -:  134:/**/
        -:  135:unsigned char hatchar, hashchar;
        -:  136:
        -:  137:/**/
        -:  138:unsigned char keyboardhackchar = '\0';
        -:  139: 
        -:  140:/* $SECONDS = now.tv_sec - shtimer.tv_sec
        -:  141: *          + (now.tv_usec - shtimer.tv_usec) / 1000000.0
        -:  142: * (rounded to an integer if the parameter is not set to float) */
        -:  143: 
        -:  144:/**/
        -:  145:struct timeval shtimer;
        -:  146: 
        -:  147:/* 0 if this $TERM setup is usable, otherwise it contains TERM_* flags */
        -:  148:
        -:  149:/**/
        -:  150:mod_export int termflags;
        -:  151:
        -:  152:/* Forward declaration */
        -:  153:
        -:  154:static void
        -:  155:rprompt_indent_unsetfn(Param pm, int exp);
        -:  156:
        -:  157:/* Standard methods for get/set/unset pointers in parameters */
        -:  158:
        -:  159:/**/
        -:  160:mod_export const struct gsu_scalar stdscalar_gsu =
        -:  161:{ strgetfn, strsetfn, stdunsetfn };
        -:  162:/**/
        -:  163:mod_export const struct gsu_scalar varscalar_gsu =
        -:  164:{ strvargetfn, strvarsetfn, stdunsetfn };
        -:  165:/**/
        -:  166:mod_export const struct gsu_scalar nullsetscalar_gsu =
        -:  167:{ strgetfn, nullstrsetfn, NULL };
        -:  168:
        -:  169:/**/
        -:  170:mod_export const struct gsu_integer stdinteger_gsu =
        -:  171:{ intgetfn, intsetfn, stdunsetfn };
        -:  172:/**/
        -:  173:mod_export const struct gsu_integer varinteger_gsu =
        -:  174:{ intvargetfn, intvarsetfn, stdunsetfn };
        -:  175:/**/
        -:  176:mod_export const struct gsu_integer nullsetinteger_gsu =
        -:  177:{ intgetfn, NULL, NULL };
        -:  178:
        -:  179:/**/
        -:  180:mod_export const struct gsu_float stdfloat_gsu =
        -:  181:{ floatgetfn, floatsetfn, stdunsetfn };
        -:  182:
        -:  183:/**/
        -:  184:mod_export const struct gsu_array stdarray_gsu =
        -:  185:{ arrgetfn, arrsetfn, stdunsetfn };
        -:  186:/**/
        -:  187:mod_export const struct gsu_array vararray_gsu =
        -:  188:{ arrvargetfn, arrvarsetfn, stdunsetfn };
        -:  189:
        -:  190:/**/
        -:  191:mod_export const struct gsu_hash stdhash_gsu =
        -:  192:{ hashgetfn, hashsetfn, stdunsetfn };
        -:  193:/**/
        -:  194:mod_export const struct gsu_hash nullsethash_gsu =
        -:  195:{ hashgetfn, nullsethashfn, nullunsetfn };
        -:  196:
        -:  197:
        -:  198:/* Non standard methods (not exported) */
        -:  199:static const struct gsu_integer pound_gsu =
        -:  200:{ poundgetfn, nullintsetfn, stdunsetfn };
        -:  201:static const struct gsu_integer errno_gsu =
        -:  202:{ errnogetfn, errnosetfn, stdunsetfn };
        -:  203:static const struct gsu_integer gid_gsu =
        -:  204:{ gidgetfn, gidsetfn, stdunsetfn };
        -:  205:static const struct gsu_integer egid_gsu =
        -:  206:{ egidgetfn, egidsetfn, stdunsetfn };
        -:  207:static const struct gsu_integer histsize_gsu =
        -:  208:{ histsizegetfn, histsizesetfn, stdunsetfn };
        -:  209:static const struct gsu_integer random_gsu =
        -:  210:{ randomgetfn, randomsetfn, stdunsetfn };
        -:  211:static const struct gsu_integer savehist_gsu =
        -:  212:{ savehistsizegetfn, savehistsizesetfn, stdunsetfn };
        -:  213:static const struct gsu_integer intseconds_gsu =
        -:  214:{ intsecondsgetfn, intsecondssetfn, stdunsetfn };
        -:  215:static const struct gsu_float floatseconds_gsu =
        -:  216:{ floatsecondsgetfn, floatsecondssetfn, stdunsetfn };
        -:  217:static const struct gsu_integer uid_gsu =
        -:  218:{ uidgetfn, uidsetfn, stdunsetfn };
        -:  219:static const struct gsu_integer euid_gsu =
        -:  220:{ euidgetfn, euidsetfn, stdunsetfn };
        -:  221:static const struct gsu_integer ttyidle_gsu =
        -:  222:{ ttyidlegetfn, nullintsetfn, stdunsetfn };
        -:  223:
        -:  224:static const struct gsu_scalar argzero_gsu =
        -:  225:{ argzerogetfn, argzerosetfn, nullunsetfn };
        -:  226:static const struct gsu_scalar username_gsu =
        -:  227:{ usernamegetfn, usernamesetfn, stdunsetfn };
        -:  228:static const struct gsu_scalar dash_gsu =
        -:  229:{ dashgetfn, nullstrsetfn, stdunsetfn };
        -:  230:static const struct gsu_scalar histchars_gsu =
        -:  231:{ histcharsgetfn, histcharssetfn, stdunsetfn };
        -:  232:static const struct gsu_scalar home_gsu =
        -:  233:{ homegetfn, homesetfn, stdunsetfn };
        -:  234:static const struct gsu_scalar term_gsu =
        -:  235:{ termgetfn, termsetfn, stdunsetfn };
        -:  236:static const struct gsu_scalar terminfo_gsu =
        -:  237:{ terminfogetfn, terminfosetfn, stdunsetfn };
        -:  238:static const struct gsu_scalar terminfodirs_gsu =
        -:  239:{ terminfodirsgetfn, terminfodirssetfn, stdunsetfn };
        -:  240:static const struct gsu_scalar wordchars_gsu =
        -:  241:{ wordcharsgetfn, wordcharssetfn, stdunsetfn };
        -:  242:static const struct gsu_scalar ifs_gsu =
        -:  243:{ ifsgetfn, ifssetfn, stdunsetfn };
        -:  244:static const struct gsu_scalar underscore_gsu =
        -:  245:{ underscoregetfn, nullstrsetfn, stdunsetfn };
        -:  246:static const struct gsu_scalar keyboard_hack_gsu =
        -:  247:{ keyboardhackgetfn, keyboardhacksetfn, stdunsetfn };
        -:  248:#ifdef USE_LOCALE
        -:  249:static const struct gsu_scalar lc_blah_gsu =
        -:  250:{ strgetfn, lcsetfn, stdunsetfn };
        -:  251:static const struct gsu_scalar lang_gsu =
        -:  252:{ strgetfn, langsetfn, stdunsetfn };
        -:  253:static const struct gsu_scalar lc_all_gsu =
        -:  254:{ strgetfn, lc_allsetfn, stdunsetfn };
        -:  255:#endif
        -:  256:
        -:  257:static const struct gsu_integer varint_readonly_gsu =
        -:  258:{ intvargetfn, nullintsetfn, stdunsetfn };
        -:  259:static const struct gsu_integer zlevar_gsu =
        -:  260:{ intvargetfn, zlevarsetfn, stdunsetfn };
        -:  261:
        -:  262:static const struct gsu_scalar colonarr_gsu =
        -:  263:{ colonarrgetfn, colonarrsetfn, stdunsetfn };
        -:  264:
        -:  265:static const struct gsu_integer argc_gsu =
        -:  266:{ poundgetfn, nullintsetfn, stdunsetfn };
        -:  267:static const struct gsu_array pipestatus_gsu =
        -:  268:{ pipestatgetfn, pipestatsetfn, stdunsetfn };
        -:  269:
        -:  270:static const struct gsu_integer rprompt_indent_gsu =
        -:  271:{ intvargetfn, zlevarsetfn, rprompt_indent_unsetfn };
        -:  272:
        -:  273:/* Nodes for special parameters for parameter hash table */
        -:  274:
        -:  275:#ifdef HAVE_UNION_INIT
        -:  276:# define BR(X) {X}
        -:  277:typedef struct param initparam;
        -:  278:#else
        -:  279:# define BR(X) X
        -:  280:typedef struct iparam {
        -:  281:    struct hashnode *next;
        -:  282:    char *nam;			/* hash data                             */
        -:  283:    int flags;			/* PM_* flags (defined in zsh.h)         */
        -:  284:    void *value;
        -:  285:    void *gsu;			/* get/set/unset methods */
        -:  286:    int base;			/* output base                           */
        -:  287:    int width;			/* output field width                    */
        -:  288:    char *env;			/* location in environment, if exported  */
        -:  289:    char *ename;		/* name of corresponding environment var */
        -:  290:    Param old;			/* old struct for use with local         */
        -:  291:    int level;			/* if (old != NULL), level of localness  */
        -:  292:} initparam;
        -:  293:#endif
        -:  294:
        -:  295:static initparam special_params[] ={
        -:  296:#define GSU(X) BR((GsuScalar)(void *)(&(X)))
        -:  297:#define NULL_GSU BR((GsuScalar)(void *)NULL)
        -:  298:#define IPDEF1(A,B,C) {{NULL,A,PM_INTEGER|PM_SPECIAL|C},BR(NULL),GSU(B),10,0,NULL,NULL,NULL,0}
        -:  299:IPDEF1("#", pound_gsu, PM_READONLY_SPECIAL),
        -:  300:IPDEF1("ERRNO", errno_gsu, PM_UNSET),
        -:  301:IPDEF1("GID", gid_gsu, PM_DONTIMPORT | PM_RESTRICTED),
        -:  302:IPDEF1("EGID", egid_gsu, PM_DONTIMPORT | PM_RESTRICTED),
        -:  303:IPDEF1("HISTSIZE", histsize_gsu, PM_RESTRICTED),
        -:  304:IPDEF1("RANDOM", random_gsu, 0),
        -:  305:IPDEF1("SAVEHIST", savehist_gsu, PM_RESTRICTED),
        -:  306:IPDEF1("SECONDS", intseconds_gsu, 0),
        -:  307:IPDEF1("UID", uid_gsu, PM_DONTIMPORT | PM_RESTRICTED),
        -:  308:IPDEF1("EUID", euid_gsu, PM_DONTIMPORT | PM_RESTRICTED),
        -:  309:IPDEF1("TTYIDLE", ttyidle_gsu, PM_READONLY_SPECIAL),
        -:  310:
        -:  311:#define IPDEF2(A,B,C) {{NULL,A,PM_SCALAR|PM_SPECIAL|C},BR(NULL),GSU(B),0,0,NULL,NULL,NULL,0}
        -:  312:IPDEF2("USERNAME", username_gsu, PM_DONTIMPORT|PM_RESTRICTED),
        -:  313:IPDEF2("-", dash_gsu, PM_READONLY_SPECIAL),
        -:  314:IPDEF2("histchars", histchars_gsu, PM_DONTIMPORT),
        -:  315:IPDEF2("HOME", home_gsu, PM_UNSET),
        -:  316:IPDEF2("TERM", term_gsu, PM_UNSET),
        -:  317:IPDEF2("TERMINFO", terminfo_gsu, PM_UNSET),
        -:  318:IPDEF2("TERMINFO_DIRS", terminfodirs_gsu, PM_UNSET),
        -:  319:IPDEF2("WORDCHARS", wordchars_gsu, 0),
        -:  320:IPDEF2("IFS", ifs_gsu, PM_DONTIMPORT | PM_RESTRICTED),
        -:  321:IPDEF2("_", underscore_gsu, PM_DONTIMPORT),
        -:  322:IPDEF2("KEYBOARD_HACK", keyboard_hack_gsu, PM_DONTIMPORT),
        -:  323:IPDEF2("0", argzero_gsu, 0),
        -:  324:
        -:  325:#ifdef USE_LOCALE
        -:  326:# define LCIPDEF(name) IPDEF2(name, lc_blah_gsu, PM_UNSET)
        -:  327:IPDEF2("LANG", lang_gsu, PM_UNSET),
        -:  328:IPDEF2("LC_ALL", lc_all_gsu, PM_UNSET),
        -:  329:# ifdef LC_COLLATE
        -:  330:LCIPDEF("LC_COLLATE"),
        -:  331:# endif
        -:  332:# ifdef LC_CTYPE
        -:  333:LCIPDEF("LC_CTYPE"),
        -:  334:# endif
        -:  335:# ifdef LC_MESSAGES
        -:  336:LCIPDEF("LC_MESSAGES"),
        -:  337:# endif
        -:  338:# ifdef LC_NUMERIC
        -:  339:LCIPDEF("LC_NUMERIC"),
        -:  340:# endif
        -:  341:# ifdef LC_TIME
        -:  342:LCIPDEF("LC_TIME"),
        -:  343:# endif
        -:  344:#endif /* USE_LOCALE */
        -:  345:
        -:  346:#define IPDEF4(A,B) {{NULL,A,PM_INTEGER|PM_READONLY_SPECIAL},BR((void *)B),GSU(varint_readonly_gsu),10,0,NULL,NULL,NULL,0}
        -:  347:IPDEF4("!", &lastpid),
        -:  348:IPDEF4("$", &mypid),
        -:  349:IPDEF4("?", &lastval),
        -:  350:IPDEF4("HISTCMD", &curhist),
        -:  351:IPDEF4("LINENO", &lineno),
        -:  352:IPDEF4("PPID", &ppid),
        -:  353:IPDEF4("ZSH_SUBSHELL", &zsh_subshell),
        -:  354:
        -:  355:#define IPDEF5(A,B,F) {{NULL,A,PM_INTEGER|PM_SPECIAL},BR((void *)B),GSU(F),10,0,NULL,NULL,NULL,0}
        -:  356:#define IPDEF5U(A,B,F) {{NULL,A,PM_INTEGER|PM_SPECIAL|PM_UNSET},BR((void *)B),GSU(F),10,0,NULL,NULL,NULL,0}
        -:  357:IPDEF5("COLUMNS", &zterm_columns, zlevar_gsu),
        -:  358:IPDEF5("LINES", &zterm_lines, zlevar_gsu),
        -:  359:IPDEF5U("ZLE_RPROMPT_INDENT", &rprompt_indent, rprompt_indent_gsu),
        -:  360:IPDEF5("SHLVL", &shlvl, varinteger_gsu),
        -:  361:IPDEF5("FUNCNEST", &zsh_funcnest, varinteger_gsu),
        -:  362:
        -:  363:/* Don't import internal integer status variables. */
        -:  364:#define IPDEF6(A,B,F) {{NULL,A,PM_INTEGER|PM_SPECIAL|PM_DONTIMPORT},BR((void *)B),GSU(F),10,0,NULL,NULL,NULL,0}
        -:  365:IPDEF6("OPTIND", &zoptind, varinteger_gsu),
        -:  366:IPDEF6("TRY_BLOCK_ERROR", &try_errflag, varinteger_gsu),
        -:  367:IPDEF6("TRY_BLOCK_INTERRUPT", &try_interrupt, varinteger_gsu),
        -:  368:
        -:  369:#define IPDEF7(A,B) {{NULL,A,PM_SCALAR|PM_SPECIAL},BR((void *)B),GSU(varscalar_gsu),0,0,NULL,NULL,NULL,0}
        -:  370:#define IPDEF7R(A,B) {{NULL,A,PM_SCALAR|PM_SPECIAL|PM_DONTIMPORT_SUID},BR((void *)B),GSU(varscalar_gsu),0,0,NULL,NULL,NULL,0}
        -:  371:#define IPDEF7U(A,B) {{NULL,A,PM_SCALAR|PM_SPECIAL|PM_UNSET},BR((void *)B),GSU(varscalar_gsu),0,0,NULL,NULL,NULL,0}
        -:  372:IPDEF7("OPTARG", &zoptarg),
        -:  373:IPDEF7("NULLCMD", &nullcmd),
        -:  374:IPDEF7U("POSTEDIT", &postedit),
        -:  375:IPDEF7("READNULLCMD", &readnullcmd),
        -:  376:IPDEF7("PS1", &prompt),
        -:  377:IPDEF7U("RPS1", &rprompt),
        -:  378:IPDEF7U("RPROMPT", &rprompt),
        -:  379:IPDEF7("PS2", &prompt2),
        -:  380:IPDEF7U("RPS2", &rprompt2),
        -:  381:IPDEF7U("RPROMPT2", &rprompt2),
        -:  382:IPDEF7("PS3", &prompt3),
        -:  383:IPDEF7R("PS4", &prompt4),
        -:  384:IPDEF7("SPROMPT", &sprompt),
        -:  385:
        -:  386:#define IPDEF9(A,B,C,D) {{NULL,A,D|PM_ARRAY|PM_SPECIAL|PM_DONTIMPORT},BR((void *)B),GSU(vararray_gsu),0,0,NULL,C,NULL,0}
        -:  387:IPDEF9("*", &pparams, NULL, PM_ARRAY|PM_READONLY_SPECIAL|PM_DONTIMPORT),
        -:  388:IPDEF9("@", &pparams, NULL, PM_ARRAY|PM_READONLY_SPECIAL|PM_DONTIMPORT),
        -:  389:
        -:  390:/*
        -:  391: * This empty row indicates the end of parameters available in
        -:  392: * all emulations.
        -:  393: */
        -:  394:{{NULL,NULL,0},BR(NULL),NULL_GSU,0,0,NULL,NULL,NULL,0},
        -:  395:
        -:  396:#define IPDEF8(A,B,C,D) {{NULL,A,D|PM_SCALAR|PM_SPECIAL},BR((void *)B),GSU(colonarr_gsu),0,0,NULL,C,NULL,0}
        -:  397:IPDEF8("CDPATH", &cdpath, "cdpath", PM_TIED),
        -:  398:IPDEF8("FIGNORE", &fignore, "fignore", PM_TIED),
        -:  399:IPDEF8("FPATH", &fpath, "fpath", PM_TIED),
        -:  400:IPDEF8("MAILPATH", &mailpath, "mailpath", PM_TIED),
        -:  401:IPDEF8("WATCH", &watch, "watch", PM_TIED),
        -:  402:IPDEF8("PATH", &path, "path", PM_RESTRICTED|PM_TIED),
        -:  403:IPDEF8("PSVAR", &psvar, "psvar", PM_TIED),
        -:  404:IPDEF8("ZSH_EVAL_CONTEXT", &zsh_eval_context, "zsh_eval_context", PM_READONLY_SPECIAL|PM_TIED),
        -:  405:
        -:  406:/* MODULE_PATH is not imported for security reasons */
        -:  407:IPDEF8("MODULE_PATH", &module_path, "module_path", PM_DONTIMPORT|PM_RESTRICTED|PM_TIED),
        -:  408:
        -:  409:#define IPDEF10(A,B) {{NULL,A,PM_ARRAY|PM_SPECIAL},BR(NULL),GSU(B),10,0,NULL,NULL,NULL,0}
        -:  410:
        -:  411:/*
        -:  412: * The following parameters are not available in sh/ksh compatibility *
        -:  413: * mode.
        -:  414: */
        -:  415:
        -:  416:/* All of these have sh compatible equivalents.                */
        -:  417:IPDEF1("ARGC", argc_gsu, PM_READONLY_SPECIAL),
        -:  418:IPDEF2("HISTCHARS", histchars_gsu, PM_DONTIMPORT),
        -:  419:IPDEF4("status", &lastval),
        -:  420:IPDEF7("prompt", &prompt),
        -:  421:IPDEF7("PROMPT", &prompt),
        -:  422:IPDEF7("PROMPT2", &prompt2),
        -:  423:IPDEF7("PROMPT3", &prompt3),
        -:  424:IPDEF7("PROMPT4", &prompt4),
        -:  425:IPDEF8("MANPATH", &manpath, "manpath", PM_TIED),
        -:  426:IPDEF9("argv", &pparams, NULL, 0),
        -:  427:IPDEF9("fignore", &fignore, "FIGNORE", PM_TIED),
        -:  428:IPDEF9("cdpath", &cdpath, "CDPATH", PM_TIED),
        -:  429:IPDEF9("fpath", &fpath, "FPATH", PM_TIED),
        -:  430:IPDEF9("mailpath", &mailpath, "MAILPATH", PM_TIED),
        -:  431:IPDEF9("manpath", &manpath, "MANPATH", PM_TIED),
        -:  432:IPDEF9("psvar", &psvar, "PSVAR", PM_TIED),
        -:  433:IPDEF9("watch", &watch, "WATCH", PM_TIED),
        -:  434:
        -:  435:IPDEF9("zsh_eval_context", &zsh_eval_context, "ZSH_EVAL_CONTEXT", PM_TIED|PM_READONLY_SPECIAL),
        -:  436:
        -:  437:IPDEF9("module_path", &module_path, "MODULE_PATH", PM_TIED|PM_RESTRICTED),
        -:  438:IPDEF9("path", &path, "PATH", PM_TIED|PM_RESTRICTED),
        -:  439:
        -:  440:/* These are known to zsh alone. */
        -:  441:
        -:  442:IPDEF10("pipestatus", pipestatus_gsu),
        -:  443:
        -:  444:{{NULL,NULL,0},BR(NULL),NULL_GSU,0,0,NULL,NULL,NULL,0},
        -:  445:};
        -:  446:
        -:  447:/*
        -:  448: * Alternative versions of colon-separated path parameters for
        -:  449: * sh emulation.  These don't link to the array versions.
        -:  450: */
        -:  451:static initparam special_params_sh[] = {
        -:  452:IPDEF8("CDPATH", &cdpath, NULL, 0),
        -:  453:IPDEF8("FIGNORE", &fignore, NULL, 0),
        -:  454:IPDEF8("FPATH", &fpath, NULL, 0),
        -:  455:IPDEF8("MAILPATH", &mailpath, NULL, 0),
        -:  456:IPDEF8("WATCH", &watch, NULL, 0),
        -:  457:IPDEF8("PATH", &path, NULL, PM_RESTRICTED),
        -:  458:IPDEF8("PSVAR", &psvar, NULL, 0),
        -:  459:IPDEF8("ZSH_EVAL_CONTEXT", &zsh_eval_context, NULL, PM_READONLY_SPECIAL),
        -:  460:
        -:  461:/* MODULE_PATH is not imported for security reasons */
        -:  462:IPDEF8("MODULE_PATH", &module_path, NULL, PM_DONTIMPORT|PM_RESTRICTED),
        -:  463:
        -:  464:{{NULL,NULL,0},BR(NULL),NULL_GSU,0,0,NULL,NULL,NULL,0},
        -:  465:};
        -:  466:
        -:  467:/*
        -:  468: * Special way of referring to the positional parameters.  Unlike $*
        -:  469: * and $@, this is not readonly.  This parameter is not directly
        -:  470: * visible in user space.
        -:  471: */
        -:  472:static initparam argvparam_pm = IPDEF9("", &pparams, NULL, \
        -:  473:				 PM_ARRAY|PM_SPECIAL|PM_DONTIMPORT);
        -:  474:
        -:  475:#undef BR
        -:  476:
        -:  477:#define IS_UNSET_VALUE(V) \
        -:  478:	((V) && (!(V)->pm || ((V)->pm->node.flags & PM_UNSET) || \
        -:  479:		 !(V)->pm->node.nam || !*(V)->pm->node.nam))
        -:  480:
        -:  481:static Param argvparam;
        -:  482:
        -:  483:/* "parameter table" - hash table containing the parameters
        -:  484: *
        -:  485: * realparamtab always points to the shell's global table.  paramtab is sometimes
        -:  486: * temporarily changed to point at another table, while dealing with the keys
        -:  487: * of an associative array (for example, see makecompparams() which initializes
        -:  488: * the associative array ${compstate}).
        -:  489: */
        -:  490: 
        -:  491:/**/
        -:  492:mod_export HashTable paramtab, realparamtab;
        -:  493:
        -:  494:/**/
        -:  495:mod_export HashTable
        5:  496:newparamtable(int size, char const *name)
        -:  497:{
        -:  498:    HashTable ht;
        5:  499:    if (!size)
    #####:  500:	size = 17;
        5:  501:    ht = newhashtable(size, name, NULL);
        -:  502:
        5:  503:    ht->hash        = hasher;
        5:  504:    ht->emptytable  = emptyhashtable;
        5:  505:    ht->filltable   = NULL;
        5:  506:    ht->cmpnodes    = strcmp;
        5:  507:    ht->addnode     = addhashnode;
        5:  508:    ht->getnode     = getparamnode;
        5:  509:    ht->getnode2    = gethashnode2;
        5:  510:    ht->removenode  = removehashnode;
        5:  511:    ht->disablenode = NULL;
        5:  512:    ht->enablenode  = NULL;
        5:  513:    ht->freenode    = freeparamnode;
        5:  514:    ht->printnode   = printparamnode;
        -:  515:
        5:  516:    return ht;
        -:  517:}
        -:  518:
        -:  519:/**/
        -:  520:static HashNode
     1089:  521:getparamnode(HashTable ht, const char *nam)
        -:  522:{
     1089:  523:    HashNode hn = gethashnode2(ht, nam);
     1089:  524:    Param pm = (Param) hn;
        -:  525:
     1089:  526:    if (pm && pm->u.str && (pm->node.flags & PM_AUTOLOAD)) {
    #####:  527:	char *mn = dupstring(pm->u.str);
        -:  528:
    #####:  529:	(void)ensurefeature(mn, "p:", (pm->node.flags & PM_AUTOALL) ? NULL :
        -:  530:			    nam);
    #####:  531:	hn = gethashnode2(ht, nam);
    #####:  532:	if (!hn) {
        -:  533:	    /*
        -:  534:	     * This used to be a warning, but surely if we allow
        -:  535:	     * stuff to go ahead with the autoload stub with
        -:  536:	     * no error status we're in for all sorts of mayhem?
        -:  537:	     */
    #####:  538:	    zerr("autoloading module %s failed to define parameter: %s", mn,
        -:  539:		 nam);
        -:  540:	}
        -:  541:    }
     1089:  542:    return hn;
        -:  543:}
        -:  544:
        -:  545:/* Copy a parameter hash table */
        -:  546:
        -:  547:static HashTable outtable;
        -:  548:
        -:  549:/**/
        -:  550:static void
    #####:  551:scancopyparams(HashNode hn, UNUSED(int flags))
        -:  552:{
        -:  553:    /* Going into a real parameter, so always use permanent storage */
    #####:  554:    Param pm = (Param)hn;
    #####:  555:    Param tpm = (Param) zshcalloc(sizeof *tpm);
    #####:  556:    tpm->node.nam = ztrdup(pm->node.nam);
    #####:  557:    copyparam(tpm, pm, 0);
    #####:  558:    addhashnode(outtable, tpm->node.nam, tpm);
    #####:  559:}
        -:  560:
        -:  561:/**/
        -:  562:HashTable
    #####:  563:copyparamtable(HashTable ht, char *name)
        -:  564:{
    #####:  565:    HashTable nht = 0;
    #####:  566:    if (ht) {
    #####:  567:	nht = newparamtable(ht->hsize, name);
    #####:  568:	outtable = nht;
    #####:  569:	scanhashtable(ht, 0, 0, 0, scancopyparams, 0);
    #####:  570:	outtable = NULL;
        -:  571:    }
    #####:  572:    return nht;
        -:  573:}
        -:  574:
        -:  575:/* Flag to freeparamnode to unset the struct */
        -:  576:
        -:  577:static int delunset;
        -:  578:
        -:  579:/* Function to delete a parameter table. */
        -:  580:
        -:  581:/**/
        -:  582:mod_export void
        2:  583:deleteparamtable(HashTable t)
        -:  584:{
        -:  585:    /* The parameters in the hash table need to be unset *
        -:  586:     * before being deleted.                             */
        2:  587:    int odelunset = delunset;
        2:  588:    delunset = 1;
        2:  589:    deletehashtable(t);
        2:  590:    delunset = odelunset;
        2:  591:}
        -:  592:
        -:  593:static unsigned numparamvals;
        -:  594:
        -:  595:/**/
        -:  596:mod_export void
      591:  597:scancountparams(UNUSED(HashNode hn), int flags)
        -:  598:{
      591:  599:    ++numparamvals;
      591:  600:    if ((flags & SCANPM_WANTKEYS) && (flags & SCANPM_WANTVALS))
      591:  601:	++numparamvals;
      591:  602:}
        -:  603:
        -:  604:static Patprog scanprog;
        -:  605:static char *scanstr;
        -:  606:static char **paramvals;
        -:  607:static Param foundparam;
        -:  608:
        -:  609:/**/
        -:  610:static void
      591:  611:scanparamvals(HashNode hn, int flags)
        -:  612:{
        -:  613:    struct value v;
        -:  614:    Patprog prog;
        -:  615:
     1179:  616:    if (numparamvals && !(flags & SCANPM_MATCHMANY) &&
      588:  617:	(flags & (SCANPM_MATCHVAL|SCANPM_MATCHKEY|SCANPM_KEYMATCH)))
    #####:  618:	return;
      591:  619:    v.pm = (Param)hn;
      591:  620:    if ((flags & SCANPM_KEYMATCH)) {
    #####:  621:	char *tmp = dupstring(v.pm->node.nam);
        -:  622:
    #####:  623:	tokenize(tmp);
    #####:  624:	remnulargs(tmp);
        -:  625:
    #####:  626:	if (!(prog = patcompile(tmp, 0, NULL)) || !pattry(prog, scanstr))
    #####:  627:	    return;
      591:  628:    } else if ((flags & SCANPM_MATCHKEY) && !pattry(scanprog, v.pm->node.nam)) {
    #####:  629:	return;
        -:  630:    }
      591:  631:    foundparam = v.pm;
      591:  632:    if (flags & SCANPM_WANTKEYS) {
      591:  633:	paramvals[numparamvals++] = v.pm->node.nam;
      591:  634:	if (!(flags & (SCANPM_WANTVALS|SCANPM_MATCHVAL)))
    #####:  635:	    return;
        -:  636:    }
      591:  637:    v.isarr = (PM_TYPE(v.pm->node.flags) & (PM_ARRAY|PM_HASHED));
      591:  638:    v.flags = 0;
      591:  639:    v.start = 0;
      591:  640:    v.end = -1;
      591:  641:    paramvals[numparamvals] = getstrvalue(&v);
      591:  642:    if (flags & SCANPM_MATCHVAL) {
    #####:  643:	if (pattry(scanprog, paramvals[numparamvals])) {
    #####:  644:	    numparamvals += ((flags & SCANPM_WANTVALS) ? 1 :
    #####:  645:			     !(flags & SCANPM_WANTKEYS));
    #####:  646:	} else if (flags & SCANPM_WANTKEYS)
    #####:  647:	    --numparamvals;	/* Value didn't match, discard key */
        -:  648:    } else
      591:  649:	++numparamvals;
      591:  650:    foundparam = NULL;
        -:  651:}
        -:  652:
        -:  653:/**/
        -:  654:char **
        3:  655:paramvalarr(HashTable ht, int flags)
        -:  656:{
        -:  657:    DPUTS((flags & (SCANPM_MATCHKEY|SCANPM_MATCHVAL)) && !scanprog,
        -:  658:	  "BUG: scanning hash without scanprog set");
        3:  659:    numparamvals = 0;
        3:  660:    if (ht)
        3:  661:	scanhashtable(ht, 0, 0, PM_UNSET, scancountparams, flags);
        3:  662:    paramvals = (char **) zhalloc((numparamvals + 1) * sizeof(char *));
        3:  663:    if (ht) {
        3:  664:	numparamvals = 0;
        3:  665:	scanhashtable(ht, 0, 0, PM_UNSET, scanparamvals, flags);
        -:  666:    }
        3:  667:    paramvals[numparamvals] = 0;
        3:  668:    return paramvals;
        -:  669:}
        -:  670:
        -:  671:/* Return the full array (no indexing) referred to by a Value. *
        -:  672: * The array value is cached for the lifetime of the Value.    */
        -:  673:
        -:  674:/**/
        -:  675:static char **
       12:  676:getvaluearr(Value v)
        -:  677:{
       12:  678:    if (v->arr)
    #####:  679:	return v->arr;
       12:  680:    else if (PM_TYPE(v->pm->node.flags) == PM_ARRAY)
        9:  681:	return v->arr = v->pm->gsu.a->getfn(v->pm);
        3:  682:    else if (PM_TYPE(v->pm->node.flags) == PM_HASHED) {
        3:  683:	v->arr = paramvalarr(v->pm->gsu.h->getfn(v->pm), v->isarr);
        -:  684:	/* Can't take numeric slices of associative arrays */
        3:  685:	v->start = 0;
        3:  686:	v->end = numparamvals + 1;
        3:  687:	return v->arr;
        -:  688:    } else
    #####:  689:	return NULL;
        -:  690:}
        -:  691:
        -:  692:/* Return whether the variable is set         *
        -:  693: * checks that array slices are within range  *
        -:  694: * used for [[ -v ... ]] condition test       */
        -:  695:
        -:  696:/**/
        -:  697:int
    #####:  698:issetvar(char *name)
        -:  699:{
        -:  700:    struct value vbuf;
        -:  701:    Value v;
        -:  702:    int slice;
        -:  703:    char **arr;
        -:  704:
    #####:  705:    if (!(v = getvalue(&vbuf, &name, 1)) || *name)
    #####:  706:	return 0; /* no value or more chars after the variable name */
    #####:  707:    if (v->isarr & ~SCANPM_ARRONLY)
    #####:  708:	return v->end > 1; /* for extracted elements, end gives us a count */
        -:  709:
    #####:  710:    slice = v->start != 0 || v->end != -1;
    #####:  711:    if (PM_TYPE(v->pm->node.flags) != PM_ARRAY || !slice)
    #####:  712:	return !slice && !(v->pm->node.flags & PM_UNSET);
        -:  713:
    #####:  714:    if (!v->end) /* empty array slice */
    #####:  715:	return 0;
        -:  716:    /* get the array and check end is within range */
    #####:  717:    if (!(arr = getvaluearr(v)))
    #####:  718:	return 0;
    #####:  719:    return arrlen_ge(arr, v->end < 0 ? - v->end : v->end);
        -:  720:}
        -:  721:
        -:  722:/*
        -:  723: * Split environment string into (name, value) pair.
        -:  724: * this is used to avoid in-place editing of environment table
        -:  725: * that results in core dump on some systems
        -:  726: */
        -:  727:
        -:  728:static int
       33:  729:split_env_string(char *env, char **name, char **value)
        -:  730:{
        -:  731:    char *str, *tenv;
        -:  732:
       33:  733:    if (!env || !name || !value)
    #####:  734:	return 0;
        -:  735:
       33:  736:    tenv = strcpy(zhalloc(strlen(env) + 1), env);
      284:  737:    for (str = tenv; *str && *str != '='; str++) {
      251:  738:	if (STOUC(*str) >= 128) {
        -:  739:	    /*
        -:  740:	     * We'll ignore environment variables with names not
        -:  741:	     * from the portable character set since we don't
        -:  742:	     * know of a good reason to accept them.
        -:  743:	     */
    #####:  744:	    return 0;
        -:  745:	}
        -:  746:    }
       33:  747:    if (str != tenv && *str == '=') {
       33:  748:	*str = '\0';
       33:  749:	*name = tenv;
       33:  750:	*value = str + 1;
       33:  751:	return 1;
        -:  752:    } else
    #####:  753:	return 0;
        -:  754:}
        -:  755:
        -:  756:/**
        -:  757: * Check parameter flags to see if parameter shouldn't be imported
        -:  758: * from environment at start.
        -:  759: *
        -:  760: * return 1: don't import: 0: ok to import.
        -:  761: */
        9:  762:static int dontimport(int flags)
        -:  763:{
        -:  764:    /* If explicitly marked as don't export */
        9:  765:    if (flags & PM_DONTIMPORT)
        2:  766:	return 1;
        -:  767:    /* If value already exported */
        7:  768:    if (flags & PM_EXPORTED)
    #####:  769:	return 1;
        -:  770:    /* If security issue when importing and running with some privilege */
        7:  771:    if ((flags & PM_DONTIMPORT_SUID) && isset(PRIVILEGED))
    #####:  772:	return 1;
        -:  773:    /* OK to import */
        7:  774:    return 0;
        -:  775:}
        -:  776:
        -:  777:/* Set up parameter hash table.  This will add predefined  *
        -:  778: * parameter entries as well as setting up parameter table *
        -:  779: * entries for environment variables we inherit.           */
        -:  780:
        -:  781:/**/
        -:  782:void
        2:  783:createparamtable(void)
        -:  784:{
        -:  785:    Param ip, pm;
        -:  786:#if !defined(HAVE_PUTENV) && !defined(USE_SET_UNSET_ENV)
        -:  787:    char **new_environ;
        -:  788:    int  envsize;
        -:  789:#endif
        -:  790:#ifndef USE_SET_UNSET_ENV
        -:  791:    char **envp;
        -:  792:#endif
        -:  793:    char **envp2, **sigptr, **t;
        -:  794:    char buf[50], *str, *iname, *ivalue, *hostnam;
        2:  795:    int  oae = opts[ALLEXPORT];
        -:  796:#ifdef HAVE_UNAME
        -:  797:    struct utsname unamebuf;
        -:  798:    char *machinebuf;
        -:  799:#endif
        -:  800:
        2:  801:    paramtab = realparamtab = newparamtable(151, "paramtab");
        -:  802:
        -:  803:    /* Add the special parameters to the hash table */
      122:  804:    for (ip = special_params; ip->node.nam; ip++)
      120:  805:	paramtab->addnode(paramtab, ztrdup(ip->node.nam), ip);
        2:  806:    if (EMULATION(EMULATE_SH|EMULATE_KSH)) {
    #####:  807:	for (ip = special_params_sh; ip->node.nam; ip++)
    #####:  808:	    paramtab->addnode(paramtab, ztrdup(ip->node.nam), ip);
        -:  809:    } else {
       64:  810:	while ((++ip)->node.nam)
       60:  811:	    paramtab->addnode(paramtab, ztrdup(ip->node.nam), ip);
        -:  812:    }
        -:  813:
        2:  814:    argvparam = (Param) &argvparam_pm;
        -:  815:
        2:  816:    noerrs = 2;
        -:  817:
        -:  818:    /* Add the standard non-special parameters which have to    *
        -:  819:     * be initialized before we copy the environment variables. *
        -:  820:     * We don't want to override whatever values the user has   *
        -:  821:     * given them in the environment.                           */
        2:  822:    opts[ALLEXPORT] = 0;
        2:  823:    setiparam("MAILCHECK", 60);
        2:  824:    setiparam("LOGCHECK", 60);
        2:  825:    setiparam("KEYTIMEOUT", 40);
        2:  826:    setiparam("LISTMAX", 100);
        -:  827:    /*
        -:  828:     * We used to get the output baud rate here.  However, that's
        -:  829:     * pretty irrelevant to a terminal on an X display and can lead
        -:  830:     * to unnecessary delays if it's wrong (which it probably is).
        -:  831:     * Furthermore, even if the output is slow it's very likely
        -:  832:     * to be because of WAN delays, not covered by the output
        -:  833:     * baud rate.
        -:  834:     * So allow the user to set it in the special cases where it's
        -:  835:     * useful.
        -:  836:     */
        2:  837:    setsparam("TMPPREFIX", ztrdup_metafy(DEFAULT_TMPPREFIX));
        2:  838:    setsparam("TIMEFMT", ztrdup_metafy(DEFAULT_TIMEFMT));
        2:  839:    setsparam("WATCHFMT", ztrdup_metafy(default_watchfmt));
        -:  840:
        2:  841:    hostnam = (char *)zalloc(256);
        2:  842:    gethostname(hostnam, 256);
        2:  843:    setsparam("HOST", ztrdup_metafy(hostnam));
        2:  844:    zfree(hostnam, 256);
        -:  845:
        2:  846:    setsparam("LOGNAME",
    #####:  847:	      ztrdup_metafy((str = getlogin()) && *str ?
        -:  848:			    str : cached_username));
        -:  849:
        -:  850:#if !defined(HAVE_PUTENV) && !defined(USE_SET_UNSET_ENV)
        -:  851:    /* Copy the environment variables we are inheriting to dynamic *
        -:  852:     * memory, so we can do mallocs and frees on it.               */
        -:  853:    envsize = sizeof(char *)*(1 + arrlen(environ));
        -:  854:    new_environ = (char **) zalloc(envsize);
        -:  855:    memcpy(new_environ, environ, envsize);
        -:  856:    environ = new_environ;
        -:  857:#endif
        -:  858:
        -:  859:    /* Use heap allocation to avoid many small alloc/free calls */
        2:  860:    pushheap();
        -:  861:
        -:  862:    /* Now incorporate environment variables we are inheriting *
        -:  863:     * into the parameter hash table. Copy them into dynamic   *
        -:  864:     * memory so that we can free them if needed               */
       37:  865:    for (
        -:  866:#ifndef USE_SET_UNSET_ENV
        -:  867:	envp = 
        -:  868:#endif
       35:  869:	    envp2 = environ; *envp2; envp2++) {
       33:  870:	if (split_env_string(*envp2, &iname, &ivalue)) {
       33:  871:	    if (!idigit(*iname) && isident(iname) && !strchr(iname, '[')) {
        -:  872:		/*
        -:  873:		 * Parameters that aren't already in the parameter table
        -:  874:		 * aren't special to the shell, so it's always OK to
        -:  875:		 * import.  Otherwise, check parameter flags.
        -:  876:		 */
       42:  877:		if ((!(pm = (Param) paramtab->getnode(paramtab, iname)) ||
       40:  878:		     !dontimport(pm->node.flags)) &&
       31:  879:		    (pm = assignsparam(iname, metafy(ivalue, -1, META_DUP),
        -:  880:				       ASSPM_ENV_IMPORT))) {
       31:  881:		    pm->node.flags |= PM_EXPORTED;
       31:  882:		    if (pm->node.flags & PM_SPECIAL)
        6:  883:			pm->env = mkenvstr (pm->node.nam,
        -:  884:					    getsparam(pm->node.nam), pm->node.flags);
        -:  885:		    else
       25:  886:			pm->env = ztrdup(*envp2);
        -:  887:#ifndef USE_SET_UNSET_ENV
        -:  888:		    *envp++ = pm->env;
        -:  889:#endif
        -:  890:		}
        -:  891:	    }
        -:  892:	}
        -:  893:    }
        2:  894:    popheap();
        -:  895:#ifndef USE_SET_UNSET_ENV
        -:  896:    *envp = NULL;
        -:  897:#endif
        2:  898:    opts[ALLEXPORT] = oae;
        -:  899:
        -:  900:    /*
        -:  901:     * For native emulation we always set the variable home
        -:  902:     * (see setupvals()).
        -:  903:     */
        2:  904:    pm = (Param) paramtab->getnode(paramtab, "HOME");
        2:  905:    if (EMULATION(EMULATE_ZSH))
        -:  906:    {
        2:  907:	pm->node.flags &= ~PM_UNSET;
        2:  908:	if (!(pm->node.flags & PM_EXPORTED))
    #####:  909:	    addenv(pm, home);
    #####:  910:    } else if (!home)
    #####:  911:	pm->node.flags |= PM_UNSET;
        2:  912:    pm = (Param) paramtab->getnode(paramtab, "LOGNAME");
        2:  913:    if (!(pm->node.flags & PM_EXPORTED))
        1:  914:	addenv(pm, pm->u.str);
        2:  915:    pm = (Param) paramtab->getnode(paramtab, "SHLVL");
        2:  916:    sprintf(buf, "%d", (int)++shlvl);
        -:  917:    /* shlvl value in environment needs updating unconditionally */
        2:  918:    addenv(pm, buf);
        -:  919:
        -:  920:    /* Add the standard non-special parameters */
        2:  921:    set_pwd_env();
        -:  922:#ifdef HAVE_UNAME
        2:  923:    if(uname(&unamebuf)) setsparam("CPUTYPE", ztrdup("unknown"));
        -:  924:    else
        -:  925:    {
        2:  926:       machinebuf = ztrdup_metafy(unamebuf.machine);
        2:  927:       setsparam("CPUTYPE", machinebuf);
        -:  928:    }
        -:  929:
        -:  930:#else
        -:  931:    setsparam("CPUTYPE", ztrdup_metafy("unknown"));
        -:  932:#endif
        2:  933:    setsparam("MACHTYPE", ztrdup_metafy(MACHTYPE));
        2:  934:    setsparam("OSTYPE", ztrdup_metafy(OSTYPE));
        2:  935:    setsparam("TTY", ztrdup_metafy(ttystrname));
        2:  936:    setsparam("VENDOR", ztrdup_metafy(VENDOR));
        2:  937:    setsparam("ZSH_ARGZERO", ztrdup(posixzero));
        2:  938:    setsparam("ZSH_VERSION", ztrdup_metafy(ZSH_VERSION));
        2:  939:    setsparam("ZSH_PATCHLEVEL", ztrdup_metafy(ZSH_PATCHLEVEL));
        2:  940:    setaparam("signals", sigptr = zalloc((SIGCOUNT+4) * sizeof(char *)));
        2:  941:    for (t = sigs; (*sigptr++ = ztrdup_metafy(*t++)); );
        -:  942:
        2:  943:    noerrs = 0;
        2:  944:}
        -:  945:
        -:  946:/* assign various functions used for non-special parameters */
        -:  947:
        -:  948:/**/
        -:  949:mod_export void
      573:  950:assigngetset(Param pm)
        -:  951:{
      573:  952:    switch (PM_TYPE(pm->node.flags)) {
      550:  953:    case PM_SCALAR:
      550:  954:	pm->gsu.s = &stdscalar_gsu;
      550:  955:	break;
       15:  956:    case PM_INTEGER:
       15:  957:	pm->gsu.i = &stdinteger_gsu;
       15:  958:	break;
    #####:  959:    case PM_EFLOAT:
        -:  960:    case PM_FFLOAT:
    #####:  961:	pm->gsu.f = &stdfloat_gsu;
    #####:  962:	break;
        7:  963:    case PM_ARRAY:
        7:  964:	pm->gsu.a = &stdarray_gsu;
        7:  965:	break;
        1:  966:    case PM_HASHED:
        1:  967:	pm->gsu.h = &stdhash_gsu;
        1:  968:	break;
    #####:  969:    default:
        -:  970:	DPUTS(1, "BUG: tried to create param node without valid flag");
    #####:  971:	break;
        -:  972:    }
      573:  973:}
        -:  974:
        -:  975:/* Create a parameter, so that it can be assigned to.  Returns NULL if the *
        -:  976: * parameter already exists or can't be created, otherwise returns the     *
        -:  977: * parameter node.  If a parameter of the same name exists in an outer     *
        -:  978: * scope, it is hidden by a newly created parameter.  An already existing  *
        -:  979: * parameter node at the current level may be `created' and returned       *
        -:  980: * provided it is unset and not special.  If the parameter can't be        *
        -:  981: * created because it already exists, the PM_UNSET flag is cleared.        */
        -:  982:
        -:  983:/**/
        -:  984:mod_export Param
      608:  985:createparam(char *name, int flags)
        -:  986:{
        -:  987:    Param pm, oldpm;
        -:  988:
      608:  989:    if (paramtab != realparamtab)
      397:  990:	flags = (flags & ~PM_EXPORTED) | PM_HASHELEM;
        -:  991:
      608:  992:    if (name != nulstring) {
     1216:  993:	oldpm = (Param) (paramtab == realparamtab ?
        -:  994:			 /* gethashnode2() for direct table read */
      211:  995:			 gethashnode2(paramtab, name) :
      397:  996:			 paramtab->getnode(paramtab, name));
        -:  997:
        -:  998:	DPUTS(oldpm && oldpm->level > locallevel,
        -:  999:	      "BUG: old local parameter not deleted");
      608: 1000:	if (oldpm && (oldpm->level == locallevel || !(flags & PM_LOCAL))) {
        5: 1001:	    if (isset(POSIXBUILTINS) && (oldpm->node.flags & PM_READONLY)) {
    #####: 1002:		zerr("read-only variable: %s", name);
    #####: 1003:		return NULL;
        -: 1004:	    }
        5: 1005:	    if ((oldpm->node.flags & PM_RESTRICTED) && isset(RESTRICTED)) {
    #####: 1006:		zerr("%s: restricted", name);
    #####: 1007:		return NULL;
        -: 1008:	    }
       10: 1009:	    if (!(oldpm->node.flags & PM_UNSET) ||
        8: 1010:		(oldpm->node.flags & PM_SPECIAL) ||
        -: 1011:		/* POSIXBUILTINS horror: we need to retain 'export' flags */
        3: 1012:		(isset(POSIXBUILTINS) && (oldpm->node.flags & PM_EXPORTED))) {
        2: 1013:		oldpm->node.flags &= ~PM_UNSET;
        2: 1014:		if ((oldpm->node.flags & PM_SPECIAL) && oldpm->ename) {
    #####: 1015:		    Param altpm =
    #####: 1016:			(Param) paramtab->getnode(paramtab, oldpm->ename);
    #####: 1017:		    if (altpm)
    #####: 1018:			altpm->node.flags &= ~PM_UNSET;
        -: 1019:		}
        2: 1020:		return NULL;
        -: 1021:	    }
        -: 1022:
        3: 1023:	    pm = oldpm;
        3: 1024:	    pm->base = pm->width = 0;
        3: 1025:	    oldpm = pm->old;
        -: 1026:	} else {
      603: 1027:	    pm = (Param) zshcalloc(sizeof *pm);
      603: 1028:	    if ((pm->old = oldpm)) {
        -: 1029:		/*
        -: 1030:		 * needed to avoid freeing oldpm, but we do take it
        -: 1031:		 * out of the environment when it's hidden.
        -: 1032:		 */
    #####: 1033:		if (oldpm->env)
    #####: 1034:		    delenv(oldpm);
    #####: 1035:		paramtab->removenode(paramtab, name);
        -: 1036:	    }
      603: 1037:	    paramtab->addnode(paramtab, ztrdup(name), pm);
        -: 1038:	}
        -: 1039:
      606: 1040:	if (isset(ALLEXPORT) && !(flags & PM_HASHELEM))
    #####: 1041:	    flags |= PM_EXPORTED;
        -: 1042:    } else {
    #####: 1043:	pm = (Param) hcalloc(sizeof *pm);
    #####: 1044:	pm->node.nam = nulstring;
        -: 1045:    }
      606: 1046:    pm->node.flags = flags & ~PM_LOCAL;
        -: 1047:
      606: 1048:    if(!(pm->node.flags & PM_SPECIAL))
      573: 1049:	assigngetset(pm);
      606: 1050:    return pm;
        -: 1051:}
        -: 1052:
        -: 1053:/* Empty dummy function for special hash parameters. */
        -: 1054:
        -: 1055:/**/
        -: 1056:static void
    #####: 1057:shempty(void)
        -: 1058:{
    #####: 1059:}
        -: 1060:
        -: 1061:/*
        -: 1062: * Create a simple special hash parameter.
        -: 1063: *
        -: 1064: * This is for hashes added internally --- it's not possible to add
        -: 1065: * special hashes from shell commands.  It's currently used
        -: 1066: * - by addparamdef() for special parameters in the zsh/parameter
        -: 1067: *   module
        -: 1068: * - by ztie for special parameters tied to databases.
        -: 1069: */
        -: 1070:
        -: 1071:/**/
        -: 1072:mod_export Param
       23: 1073:createspecialhash(char *name, GetNodeFunc get, ScanTabFunc scan, int flags)
        -: 1074:{
        -: 1075:    Param pm;
        -: 1076:    HashTable ht;
        -: 1077:
       23: 1078:    if (!(pm = createparam(name, PM_SPECIAL|PM_HASHED|flags)))
    #####: 1079:	return NULL;
        -: 1080:
        -: 1081:    /*
        -: 1082:     * If there's an old parameter, we'll put the new one at
        -: 1083:     * the current locallevel, so that the old parameter is
        -: 1084:     * exposed again after leaving the function.  Otherwise,
        -: 1085:     * we'll leave it alone.  Usually this means the parameter
        -: 1086:     * will stay in place until explicitly unloaded, however
        -: 1087:     * if the parameter was previously unset within a function
        -: 1088:     * we'll inherit the level of that function and follow the
        -: 1089:     * standard convention that the parameter remains local
        -: 1090:     * even if unset.
        -: 1091:     *
        -: 1092:     * These semantics are similar to those of a normal parameter set
        -: 1093:     * within a function without a local definition.
        -: 1094:     */
       23: 1095:    if (pm->old)
    #####: 1096:	pm->level = locallevel;
       23: 1097:    pm->gsu.h = (flags & PM_READONLY) ? &stdhash_gsu :
        -: 1098:	&nullsethash_gsu;
       23: 1099:    pm->u.hash = ht = newhashtable(0, name, NULL);
        -: 1100:
       23: 1101:    ht->hash        = hasher;
       23: 1102:    ht->emptytable  = (TableFunc) shempty;
       23: 1103:    ht->filltable   = NULL;
       23: 1104:    ht->addnode     = (AddNodeFunc) shempty;
       23: 1105:    ht->getnode     = ht->getnode2 = get;
       23: 1106:    ht->removenode  = (RemoveNodeFunc) shempty;
       23: 1107:    ht->disablenode = NULL;
       23: 1108:    ht->enablenode  = NULL;
       23: 1109:    ht->freenode    = (FreeNodeFunc) shempty;
       23: 1110:    ht->printnode   = printparamnode;
       23: 1111:    ht->scantab     = scan;
        -: 1112:
       23: 1113:    return pm;
        -: 1114:}
        -: 1115:
        -: 1116:
        -: 1117:/*
        -: 1118: * Copy a parameter
        -: 1119: *
        -: 1120: * If fakecopy is set, we are just saving the details of a special
        -: 1121: * parameter.  Otherwise, the result will be used as a real parameter
        -: 1122: * and we need to do more work.
        -: 1123: */
        -: 1124:
        -: 1125:/**/
        -: 1126:void
       12: 1127:copyparam(Param tpm, Param pm, int fakecopy)
        -: 1128:{
        -: 1129:    /*
        -: 1130:     * Note that tpm, into which we're copying, may not be in permanent
        -: 1131:     * storage.  However, the values themselves are later used directly
        -: 1132:     * to set the parameter, so must be permanently allocated (in accordance
        -: 1133:     * with sets.?fn() usage).
        -: 1134:     */
       12: 1135:    tpm->node.flags = pm->node.flags;
       12: 1136:    tpm->base = pm->base;
       12: 1137:    tpm->width = pm->width;
       12: 1138:    tpm->level = pm->level;
       12: 1139:    if (!fakecopy) {
    #####: 1140:	tpm->old = pm->old;
    #####: 1141:	tpm->node.flags &= ~PM_SPECIAL;
        -: 1142:    }
       12: 1143:    switch (PM_TYPE(pm->node.flags)) {
       12: 1144:    case PM_SCALAR:
       12: 1145:	tpm->u.str = ztrdup(pm->gsu.s->getfn(pm));
       12: 1146:	break;
    #####: 1147:    case PM_INTEGER:
    #####: 1148:	tpm->u.val = pm->gsu.i->getfn(pm);
    #####: 1149:	break;
    #####: 1150:    case PM_EFLOAT:
        -: 1151:    case PM_FFLOAT:
    #####: 1152:	tpm->u.dval = pm->gsu.f->getfn(pm);
    #####: 1153:	break;
    #####: 1154:    case PM_ARRAY:
    #####: 1155:	tpm->u.arr = zarrdup(pm->gsu.a->getfn(pm));
    #####: 1156:	break;
    #####: 1157:    case PM_HASHED:
    #####: 1158:	tpm->u.hash = copyparamtable(pm->gsu.h->getfn(pm), pm->node.nam);
    #####: 1159:	break;
        -: 1160:    }
        -: 1161:    /*
        -: 1162:     * If the value is going to be passed as a real parameter (e.g. this is
        -: 1163:     * called from inside an associative array), we need the gets and sets
        -: 1164:     * functions to be useful.
        -: 1165:     *
        -: 1166:     * In this case we assume the saved parameter is not itself special,
        -: 1167:     * so we just use the standard functions.  This is also why we switch off
        -: 1168:     * PM_SPECIAL.
        -: 1169:     */
       12: 1170:    if (!fakecopy)
    #####: 1171:	assigngetset(tpm);
       12: 1172:}
        -: 1173:
        -: 1174:/* Return 1 if the string s is a valid identifier, else return 0. */
        -: 1175:
        -: 1176:/**/
        -: 1177:mod_export int
      276: 1178:isident(char *s)
        -: 1179:{
        -: 1180:    char *ss;
        -: 1181:
      276: 1182:    if (!*s)			/* empty string is definitely not valid */
    #####: 1183:	return 0;
        -: 1184:
      276: 1185:    if (idigit(*s)) {
        -: 1186:	/* If the first character is `s' is a digit, then all must be */
    #####: 1187:	for (ss = ++s; *ss; ss++)
    #####: 1188:	    if (!idigit(*ss))
    #####: 1189:		break;
        -: 1190:    } else {
        -: 1191:	/* Find the first character in `s' not in the iident type table */
      276: 1192:	ss = itype_end(s, IIDENT, 0);
        -: 1193:    }
        -: 1194:
        -: 1195:    /* If the next character is not [, then it is *
        -: 1196:     * definitely not a valid identifier.         */
      276: 1197:    if (!*ss)
      275: 1198:	return 1;
        1: 1199:    if (s == ss)
    #####: 1200:	return 0;
        1: 1201:    if (*ss != '[')
    #####: 1202:	return 0;
        -: 1203:
        -: 1204:    /* Require balanced [ ] pairs with something between */
        1: 1205:    if (!(ss = parse_subscript(++ss, 1, ']')))
    #####: 1206:	return 0;
        1: 1207:    untokenize(s);
        1: 1208:    return !ss[1];
        -: 1209:}
        -: 1210:
        -: 1211:/*
        -: 1212: * Parse a single argument to a parameter subscript.
        -: 1213: * The subscripts starts at *str; *str is updated (input/output)
        -: 1214: *
        -: 1215: * *inv is set to indicate if the subscript is reversed (output)
        -: 1216: * v is the Value for the parameter being accessed (input; note
        -: 1217: *  v->isarr may be modified, and if v is a hash the parameter will
        -: 1218: *  be updated to the element of the hash)
        -: 1219: * a2 is 1 if this is the second subscript of a range (input)
        -: 1220: * *w is only set if we need to find the end of a word (input; should
        -: 1221: *  be set to 0 by the caller).
        -: 1222: *
        -: 1223: * The final two arguments are to support multibyte characters.
        -: 1224: * If supplied they are set to the length of the character before
        -: 1225: * the index position and the one at the index position.  If
        -: 1226: * multibyte characters are not in use they are set to 1 for
        -: 1227: * consistency.  Note they aren't fully handled if a2 is non-zero,
        -: 1228: * since they aren't needed.
        -: 1229: *
        -: 1230: * Returns a raw offset into the value from the start or end (i.e.
        -: 1231: * after the arithmetic for Meta and possible multibyte characters has
        -: 1232: * been taken into account).  This actually gives the offset *after*
        -: 1233: * the character in question; subtract *prevcharlen if necessary.
        -: 1234: */
        -: 1235:
        -: 1236:/**/
        -: 1237:static zlong
        5: 1238:getarg(char **str, int *inv, Value v, int a2, zlong *w,
        -: 1239:       int *prevcharlen, int *nextcharlen, int flags)
        -: 1240:{
        5: 1241:    int hasbeg = 0, word = 0, rev = 0, ind = 0, down = 0, l, i, ishash;
        5: 1242:    int keymatch = 0, needtok = 0, arglen, len, inpar = 0;
        5: 1243:    char *s = *str, *sep = NULL, *t, sav, *d, **ta, **p, *tt, c;
        5: 1244:    zlong num = 1, beg = 0, r = 0, quote_arg = 0;
        5: 1245:    Patprog pprog = NULL;
        -: 1246:
        -: 1247:    /*
        -: 1248:     * If in NO_EXEC mode, the parameters won't be set up properly,
        -: 1249:     * so just pretend everything is a hash for subscript parsing
        -: 1250:     */
        -: 1251:
       14: 1252:    ishash = (unset(EXECOPT) ||
       10: 1253:	      (v->pm && PM_TYPE(v->pm->node.flags) == PM_HASHED));
        5: 1254:    if (prevcharlen)
        5: 1255:	*prevcharlen = 1;
        5: 1256:    if (nextcharlen)
        5: 1257:	*nextcharlen = 1;
        -: 1258:
        -: 1259:    /* first parse any subscription flags */
        5: 1260:    if (v->pm && (*s == '(' || *s == Inpar)) {
    #####: 1261:	int escapes = 0;
        -: 1262:	int waste;
    #####: 1263:	for (s++; *s != ')' && *s != Outpar && s != *str; s++) {
    #####: 1264:	    switch (*s) {
    #####: 1265:	    case 'r':
    #####: 1266:		rev = 1;
    #####: 1267:		keymatch = down = ind = 0;
    #####: 1268:		break;
    #####: 1269:	    case 'R':
    #####: 1270:		rev = down = 1;
    #####: 1271:		keymatch = ind = 0;
    #####: 1272:		break;
    #####: 1273:	    case 'k':
    #####: 1274:		keymatch = ishash;
    #####: 1275:		rev = 1;
    #####: 1276:		down = ind = 0;
    #####: 1277:		break;
    #####: 1278:	    case 'K':
    #####: 1279:		keymatch = ishash;
    #####: 1280:		rev = down = 1;
    #####: 1281:		ind = 0;
    #####: 1282:		break;
    #####: 1283:	    case 'i':
    #####: 1284:		rev = ind = 1;
    #####: 1285:		down = keymatch = 0;
    #####: 1286:		break;
    #####: 1287:	    case 'I':
    #####: 1288:		rev = ind = down = 1;
    #####: 1289:		keymatch = 0;
    #####: 1290:		break;
    #####: 1291:	    case 'w':
        -: 1292:		/* If the parameter is a scalar, then make subscription *
        -: 1293:		 * work on a per-word basis instead of characters.      */
    #####: 1294:		word = 1;
    #####: 1295:		break;
    #####: 1296:	    case 'f':
    #####: 1297:		word = 1;
    #####: 1298:		sep = "\n";
    #####: 1299:		break;
    #####: 1300:	    case 'e':
    #####: 1301:		quote_arg = 1;
    #####: 1302:		break;
    #####: 1303:	    case 'n':
    #####: 1304:		t = get_strarg(++s, &arglen);
    #####: 1305:		if (!*t)
    #####: 1306:		    goto flagerr;
    #####: 1307:		sav = *t;
    #####: 1308:		*t = '\0';
    #####: 1309:		num = mathevalarg(s + arglen, &d);
    #####: 1310:		if (!num)
    #####: 1311:		    num = 1;
    #####: 1312:		*t = sav;
    #####: 1313:		s = t + arglen - 1;
    #####: 1314:		break;
    #####: 1315:	    case 'b':
    #####: 1316:		hasbeg = 1;
    #####: 1317:		t = get_strarg(++s, &arglen);
    #####: 1318:		if (!*t)
    #####: 1319:		    goto flagerr;
    #####: 1320:		sav = *t;
    #####: 1321:		*t = '\0';
    #####: 1322:		if ((beg = mathevalarg(s + arglen, &d)) > 0)
    #####: 1323:		    beg--;
    #####: 1324:		*t = sav;
    #####: 1325:		s = t + arglen - 1;
    #####: 1326:		break;
    #####: 1327:	    case 'p':
    #####: 1328:		escapes = 1;
    #####: 1329:		break;
    #####: 1330:	    case 's':
        -: 1331:		/* This gives the string that separates words *
        -: 1332:		 * (for use with the `w' flag).               */
    #####: 1333:		t = get_strarg(++s, &arglen);
    #####: 1334:		if (!*t)
    #####: 1335:		    goto flagerr;
    #####: 1336:		sav = *t;
    #####: 1337:		*t = '\0';
    #####: 1338:		s += arglen;
    #####: 1339:		sep = escapes ? getkeystring(s, &waste, GETKEYS_SEP, NULL)
    #####: 1340:		    : dupstring(s);
    #####: 1341:		*t = sav;
    #####: 1342:		s = t + arglen - 1;
    #####: 1343:		break;
        -: 1344:	    default:
    #####: 1345:	      flagerr:
    #####: 1346:		num = 1;
    #####: 1347:		word = rev = ind = down = keymatch = 0;
    #####: 1348:		sep = NULL;
    #####: 1349:		s = *str - 1;
        -: 1350:	    }
        -: 1351:	}
    #####: 1352:	if (s != *str)
    #####: 1353:	    s++;
        -: 1354:    }
        5: 1355:    if (num < 0) {
    #####: 1356:	down = !down;
    #####: 1357:	num = -num;
        -: 1358:    }
        5: 1359:    if (v->isarr & SCANPM_WANTKEYS)
    #####: 1360:	*inv = (ind || !(v->isarr & SCANPM_WANTVALS));
        5: 1361:    else if (v->isarr & SCANPM_WANTVALS)
    #####: 1362:	*inv = 0;
        -: 1363:    else {
        5: 1364:	if (v->isarr) {
        5: 1365:	    if (ind) {
    #####: 1366:		v->isarr |= SCANPM_WANTKEYS;
    #####: 1367:		v->isarr &= ~SCANPM_WANTVALS;
        5: 1368:	    } else if (rev)
    #####: 1369:		v->isarr |= SCANPM_WANTVALS;
        -: 1370:	    /*
        -: 1371:	     * This catches the case where we are using "k" (rather
        -: 1372:	     * than "K") on a hash.
        -: 1373:	     */
        5: 1374:	    if (!down && keymatch && ishash)
    #####: 1375:		v->isarr &= ~SCANPM_MATCHMANY;
        -: 1376:	}
        5: 1377:	*inv = ind;
        -: 1378:    }
        -: 1379:
       28: 1380:    for (t = s, i = 0;
       46: 1381:	 (c = *t) &&
       18: 1382:	     ((c != Outbrack && (ishash || c != ',')) || i || inpar);
       18: 1383:	 t++) {
        -: 1384:	/* Untokenize inull() except before brackets and double-quotes */
       18: 1385:	if (inull(c)) {
    #####: 1386:	    c = t[1];
    #####: 1387:	    if (c == '[' || c == ']' ||
    #####: 1388:		c == '(' || c == ')' ||
    #####: 1389:		c == '{' || c == '}') {
        -: 1390:		/* This test handles nested subscripts in hash keys */
    #####: 1391:		if (ishash && i)
    #####: 1392:		    *t = ztokens[*t - Pound];
    #####: 1393:		needtok = 1;
    #####: 1394:		++t;
    #####: 1395:	    } else if (c != '"')
    #####: 1396:		*t = ztokens[*t - Pound];
    #####: 1397:	    continue;
        -: 1398:	}
        -: 1399:	/* Inbrack and Outbrack are probably never found here ... */
       18: 1400:	if (c == '[' || c == Inbrack)
    #####: 1401:	    i++;
       18: 1402:	else if (c == ']' || c == Outbrack)
    #####: 1403:	    i--;
       18: 1404:	if (c == '(' || c == Inpar)
    #####: 1405:	    inpar++;
       18: 1406:	else if (c == ')' || c == Outpar)
    #####: 1407:	    inpar--;
       18: 1408:	if (ispecial(c))
    #####: 1409:	    needtok = 1;
        -: 1410:    }
        5: 1411:    if (!c)
    #####: 1412:	return 0;
        5: 1413:    *str = tt = t;
        -: 1414:
        -: 1415:    /*
        -: 1416:     * If in NO_EXEC mode, the parameters won't be set up properly,
        -: 1417:     * so there's no additional sanity checking we can do.
        -: 1418:     * Just return 0 now.
        -: 1419:     */
        5: 1420:    if (unset(EXECOPT))
    #####: 1421:	return 0;
        -: 1422:
        5: 1423:    s = dupstrpfx(s, t - s);
        -: 1424:
        -: 1425:    /* If we're NOT reverse subscripting, strip the inull()s so brackets *
        -: 1426:     * are not backslashed after parsestr().  Otherwise leave them alone *
        -: 1427:     * so that the brackets will be escaped when we patcompile() or when *
        -: 1428:     * subscript arithmetic is performed (for nested subscripts).        */
        5: 1429:    if (ishash && (keymatch || !rev))
        4: 1430:	remnulargs(s);
        5: 1431:    if (needtok) {
    #####: 1432:	s = dupstring(s);
    #####: 1433:	if (parsestr(&s))
    #####: 1434:	    return 0;
    #####: 1435:	singsub(&s);
        5: 1436:    } else if (rev)
    #####: 1437:	remnulargs(s);	/* This is probably always a no-op, but ... */
        5: 1438:    if (!rev) {
        5: 1439:	if (ishash) {
        4: 1440:	    HashTable ht = v->pm->gsu.h->getfn(v->pm);
        4: 1441:	    if (!ht) {
    #####: 1442:		if (flags & SCANPM_CHECKING)
    #####: 1443:		    return 0;
    #####: 1444:		ht = newparamtable(17, v->pm->node.nam);
    #####: 1445:		v->pm->gsu.h->setfn(v->pm, ht);
        -: 1446:	    }
        4: 1447:	    untokenize(s);
        4: 1448:	    if (!(v->pm = (Param) ht->getnode(ht, s))) {
    #####: 1449:		HashTable tht = paramtab;
    #####: 1450:		paramtab = ht;
    #####: 1451:		v->pm = createparam(s, PM_SCALAR|PM_UNSET);
    #####: 1452:		paramtab = tht;
        -: 1453:	    }
        4: 1454:	    v->isarr = (*inv ? SCANPM_WANTINDEX : 0);
        4: 1455:	    v->start = 0;
        4: 1456:	    *inv = 0;	/* We've already obtained the "index" (key) */
        4: 1457:	    *w = v->end = -1;
        4: 1458:	    r = isset(KSHARRAYS) ? 1 : 0;
        -: 1459:	} else {
        1: 1460:	    r = mathevalarg(s, &s);
        1: 1461:	    if (isset(KSHARRAYS) && r >= 0)
    #####: 1462:		r++;
        -: 1463:	}
        5: 1464:	if (word && !v->isarr) {
    #####: 1465:	    s = t = getstrvalue(v);
    #####: 1466:	    i = wordcount(s, sep, 0);
    #####: 1467:	    if (r < 0)
    #####: 1468:		r += i + 1;
    #####: 1469:	    if (r < 1)
    #####: 1470:		r = 1;
    #####: 1471:	    if (r > i)
    #####: 1472:		r = i;
    #####: 1473:	    if (!s || !*s)
    #####: 1474:		return 0;
    #####: 1475:	    while ((d = findword(&s, sep)) && --r);
    #####: 1476:	    if (!d)
    #####: 1477:		return 0;
        -: 1478:
    #####: 1479:	    if (!a2 && *tt != ',')
    #####: 1480:		*w = (zlong)(s - t);
        -: 1481:
    #####: 1482:	    return (a2 ? s : d + 1) - t;
        5: 1483:	} else if (!v->isarr && !word) {
        4: 1484:	    int lastcharlen = 1;
        4: 1485:	    s = getstrvalue(v);
        -: 1486:	    /*
        -: 1487:	     * Note for the confused (= pws):  the index r we
        -: 1488:	     * have so far is that specified by the user.  The value
        -: 1489:	     * passed back is an offset from the start or end of
        -: 1490:	     * the string.  Hence it needs correcting at least
        -: 1491:	     * for Meta characters and maybe for multibyte characters.
        -: 1492:	     */
        4: 1493:	    if (r > 0) {
    #####: 1494:		zlong nchars = r;
        -: 1495:
    #####: 1496:		MB_METACHARINIT();
    #####: 1497:		for (t = s; nchars && *t; nchars--)
    #####: 1498:		    t += (lastcharlen = MB_METACHARLEN(t));
        -: 1499:		/* for consistency, keep any remainder off the end */
    #####: 1500:		r = (zlong)(t - s) + nchars;
    #####: 1501:		if (prevcharlen && !nchars /* ignore if off the end */)
    #####: 1502:		    *prevcharlen = lastcharlen;
    #####: 1503:		if (nextcharlen && *t)
    #####: 1504:		    *nextcharlen = MB_METACHARLEN(t);
        4: 1505:	    } else if (r == 0) {
        4: 1506:		if (prevcharlen)
        4: 1507:		    *prevcharlen = 0;
        4: 1508:		if (nextcharlen && *s) {
        4: 1509:		    MB_METACHARINIT();
        4: 1510:		    *nextcharlen = MB_METACHARLEN(s);
        -: 1511:		}
        -: 1512:	    } else {
    #####: 1513:		zlong nchars = (zlong)MB_METASTRLEN(s) + r;
        -: 1514:
    #####: 1515:		if (nchars < 0) {
        -: 1516:		    /* make sure this isn't valid as a raw pointer */
    #####: 1517:		    r -= (zlong)strlen(s);
        -: 1518:		} else {
    #####: 1519:		    MB_METACHARINIT();
    #####: 1520:		    for (t = s; nchars && *t; nchars--)
    #####: 1521:			t += (lastcharlen = MB_METACHARLEN(t));
    #####: 1522:		    r = - (zlong)strlen(t); /* keep negative */
    #####: 1523:		    if (prevcharlen)
    #####: 1524:			*prevcharlen = lastcharlen;
    #####: 1525:		    if (nextcharlen && *t)
    #####: 1526:			*nextcharlen = MB_METACHARLEN(t);
        -: 1527:		}
        -: 1528:	    }
        -: 1529:	}
        -: 1530:    } else {
    #####: 1531:	if (!v->isarr && !word && !quote_arg) {
    #####: 1532:	    l = strlen(s);
    #####: 1533:	    if (a2) {
    #####: 1534:		if (!l || *s != '*') {
    #####: 1535:		    d = (char *) hcalloc(l + 2);
    #####: 1536:		    *d = '*';
    #####: 1537:		    strcpy(d + 1, s);
    #####: 1538:		    s = d;
        -: 1539:		}
        -: 1540:	    } else {
    #####: 1541:		if (!l || s[l - 1] != '*' || (l > 1 && s[l - 2] == '\\')) {
    #####: 1542:		    d = (char *) hcalloc(l + 2);
    #####: 1543:		    strcpy(d, s);
    #####: 1544:		    strcat(d, "*");
    #####: 1545:		    s = d;
        -: 1546:		}
        -: 1547:	    }
        -: 1548:	}
    #####: 1549:	if (!keymatch) {
    #####: 1550:	    if (quote_arg) {
    #####: 1551:		untokenize(s);
        -: 1552:		/* Scalar (e) needs implicit asterisk tokens */
    #####: 1553:		if (!v->isarr && !word) {
    #####: 1554:		    l = strlen(s);
    #####: 1555:		    d = (char *) hcalloc(l + 2);
    #####: 1556:		    if (a2) {
    #####: 1557:			*d = Star;
    #####: 1558:			strcpy(d + 1, s);
        -: 1559:		    } else {
    #####: 1560:			strcpy(d, s);
    #####: 1561:			d[l] = Star;
    #####: 1562:			d[l + 1] = '\0';
        -: 1563:		    }
    #####: 1564:		    s = d;
        -: 1565:		}
        -: 1566:	    } else
    #####: 1567:		tokenize(s);
    #####: 1568:	    remnulargs(s);
    #####: 1569:	    pprog = patcompile(s, 0, NULL);
        -: 1570:	} else
    #####: 1571:	    pprog = NULL;
        -: 1572:
    #####: 1573:	if (v->isarr) {
    #####: 1574:	    if (ishash) {
    #####: 1575:		scanprog = pprog;
    #####: 1576:		scanstr = s;
    #####: 1577:		if (keymatch)
    #####: 1578:		    v->isarr |= SCANPM_KEYMATCH;
        -: 1579:		else {
    #####: 1580:		    if (!pprog)
    #####: 1581:			return 1;
    #####: 1582:		    if (ind)
    #####: 1583:			v->isarr |= SCANPM_MATCHKEY;
        -: 1584:		    else
    #####: 1585:			v->isarr |= SCANPM_MATCHVAL;
        -: 1586:		}
    #####: 1587:		if (down)
    #####: 1588:		    v->isarr |= SCANPM_MATCHMANY;
    #####: 1589:		if ((ta = getvaluearr(v)) &&
    #####: 1590:		    (*ta || ((v->isarr & SCANPM_MATCHMANY) &&
    #####: 1591:			     (v->isarr & (SCANPM_MATCHKEY | SCANPM_MATCHVAL |
        -: 1592:					  SCANPM_KEYMATCH))))) {
    #####: 1593:		    *inv = (v->flags & VALFLAG_INV) ? 1 : 0;
    #####: 1594:		    *w = v->end;
    #####: 1595:		    scanprog = NULL;
    #####: 1596:		    return 1;
        -: 1597:		}
    #####: 1598:		scanprog = NULL;
        -: 1599:	    } else
    #####: 1600:		ta = getarrvalue(v);
    #####: 1601:	    if (!ta || !*ta)
    #####: 1602:		return !down;
    #####: 1603:	    len = arrlen(ta);
    #####: 1604:	    if (beg < 0)
    #####: 1605:		beg += len;
    #####: 1606:	    if (down) {
    #####: 1607:		if (beg < 0)
    #####: 1608:		    return 0;
    #####: 1609:	    } else if (beg >= len)
    #####: 1610:		return len + 1;
    #####: 1611:	    if (beg >= 0 && beg < len) {
    #####: 1612:		if (down) {
    #####: 1613:		    if (!hasbeg)
    #####: 1614:			beg = len - 1;
    #####: 1615:		    for (r = 1 + beg, p = ta + beg; p >= ta; r--, p--) {
    #####: 1616:			if (pprog && pattry(pprog, *p) && !--num)
    #####: 1617:			    return r;
        -: 1618:		    }
        -: 1619:		} else
    #####: 1620:		    for (r = 1 + beg, p = ta + beg; *p; r++, p++)
    #####: 1621:			if (pprog && pattry(pprog, *p) && !--num)
    #####: 1622:			    return r;
        -: 1623:	    }
    #####: 1624:	} else if (word) {
    #####: 1625:	    ta = sepsplit(d = s = getstrvalue(v), sep, 1, 1);
    #####: 1626:	    len = arrlen(ta);
    #####: 1627:	    if (beg < 0)
    #####: 1628:		beg += len;
    #####: 1629:	    if (down) {
    #####: 1630:		if (beg < 0)
    #####: 1631:		    return 0;
    #####: 1632:	    } else if (beg >= len)
    #####: 1633:		return len + 1;
    #####: 1634:	    if (beg >= 0 && beg < len) {
    #####: 1635:		if (down) {
    #####: 1636:		    if (!hasbeg)
    #####: 1637:			beg = len - 1;
    #####: 1638:		    for (r = 1 + beg, p = ta + beg; p >= ta; p--, r--)
    #####: 1639:			if (pprog && pattry(pprog, *p) && !--num)
    #####: 1640:			    break;
    #####: 1641:		    if (p < ta)
    #####: 1642:			return 0;
        -: 1643:		} else {
    #####: 1644:		    for (r = 1 + beg, p = ta + beg; *p; r++, p++)
    #####: 1645:			if (pprog && pattry(pprog, *p) && !--num)
    #####: 1646:			    break;
    #####: 1647:		    if (!*p)
    #####: 1648:			return 0;
        -: 1649:		}
        -: 1650:	    }
    #####: 1651:	    if (a2)
    #####: 1652:		r++;
    #####: 1653:	    for (i = 0; (t = findword(&d, sep)) && *t; i++)
    #####: 1654:		if (!--r) {
    #####: 1655:		    r = (zlong)(t - s + (a2 ? -1 : 1));
    #####: 1656:		    if (!a2 && *tt != ',')
    #####: 1657:			*w = r + strlen(ta[i]) - 1;
    #####: 1658:		    return r;
        -: 1659:		}
    #####: 1660:	    return a2 ? -1 : 0;
        -: 1661:	} else {
        -: 1662:	    /* Searching characters */
        -: 1663:	    int slen;
    #####: 1664:	    d = getstrvalue(v);
    #####: 1665:	    if (!d || !*d)
    #####: 1666:		return 0;
        -: 1667:	    /*
        -: 1668:	     * beg and len are character counts, not raw offsets.
        -: 1669:	     * Remember we need to return a raw offset.
        -: 1670:	     */
    #####: 1671:	    len = MB_METASTRLEN(d);
    #####: 1672:	    slen = strlen(d);
    #####: 1673:	    if (beg < 0)
    #####: 1674:		beg += len;
    #####: 1675:	    MB_METACHARINIT();
    #####: 1676:	    if (beg >= 0 && beg < len) {
    #####: 1677:		char *de = d + slen;
        -: 1678:
    #####: 1679:		if (a2) {
        -: 1680:		    /*
        -: 1681:		     * Second argument: we don't need to
        -: 1682:		     * handle prevcharlen or nextcharlen, but
        -: 1683:		     * we do need to handle characters appropriately.
        -: 1684:		     */
    #####: 1685:		    if (down) {
    #####: 1686:			int nmatches = 0;
    #####: 1687:			char *lastpos = NULL;
        -: 1688:
    #####: 1689:			if (!hasbeg)
    #####: 1690:			    beg = len;
        -: 1691:
        -: 1692:			/*
        -: 1693:			 * See below: we have to move forward,
        -: 1694:			 * but need to count from the end.
        -: 1695:			 */
    #####: 1696:			for (t = d, r = 0; r <= beg; r++) {
    #####: 1697:			    sav = *t;
    #####: 1698:			    *t = '\0';
    #####: 1699:			    if (pprog && pattry(pprog, d)) {
    #####: 1700:				nmatches++;
    #####: 1701:				lastpos = t;
        -: 1702:			    }
    #####: 1703:			    *t = sav;
    #####: 1704:			    if (t == de)
    #####: 1705:				break;
    #####: 1706:			    t += MB_METACHARLEN(t);
        -: 1707:			}
        -: 1708:
    #####: 1709:			if (nmatches >= num) {
    #####: 1710:			    if (num > 1) {
    #####: 1711:				nmatches -= num;
    #####: 1712:				MB_METACHARINIT();
    #####: 1713:				for (t = d, r = 0; ; r++) {
    #####: 1714:				    sav = *t;
    #####: 1715:				    *t = '\0';
    #####: 1716:				    if (pprog && pattry(pprog, d) &&
    #####: 1717:					nmatches-- == 0) {
    #####: 1718:					lastpos = t;
    #####: 1719:					*t = sav;
    #####: 1720:					break;
        -: 1721:				    }
    #####: 1722:				    *t = sav;
    #####: 1723:				    t += MB_METACHARLEN(t);
        -: 1724:				}
        -: 1725:			    }
        -: 1726:			    /* else lastpos is already OK */
        -: 1727:
    #####: 1728:			    return lastpos - d;
        -: 1729:			}
        -: 1730:		    } else {
        -: 1731:			/*
        -: 1732:			 * This handling of the b flag
        -: 1733:			 * gives odd results, but this is the
        -: 1734:			 * way it's always worked.
        -: 1735:			 */
    #####: 1736:			for (t = d; beg && t <= de; beg--)
    #####: 1737:			    t += MB_METACHARLEN(t);
        -: 1738:			for (;;) {
    #####: 1739:			    sav = *t;
    #####: 1740:			    *t = '\0';
    #####: 1741:			    if (pprog && pattry(pprog, d) && !--num) {
    #####: 1742:				*t = sav;
        -: 1743:				/*
        -: 1744:				 * This time, don't increment
        -: 1745:				 * pointer, since it's already
        -: 1746:				 * after everything we matched.
        -: 1747:				 */
    #####: 1748:				return t - d;
        -: 1749:			    }
    #####: 1750:			    *t = sav;
    #####: 1751:			    if (t == de)
    #####: 1752:				break;
    #####: 1753:			    t += MB_METACHARLEN(t);
        -: 1754:			}
        -: 1755:		    }
        -: 1756:		} else {
        -: 1757:		    /*
        -: 1758:		     * First argument: this is the only case
        -: 1759:		     * where we need prevcharlen and nextcharlen.
        -: 1760:		     */
        -: 1761:		    int lastcharlen;
        -: 1762:
    #####: 1763:		    if (down) {
    #####: 1764:			int nmatches = 0;
    #####: 1765:			char *lastpos = NULL;
        -: 1766:
    #####: 1767:			if (!hasbeg)
    #####: 1768:			    beg = len;
        -: 1769:
        -: 1770:			/*
        -: 1771:			 * We can only move forward through
        -: 1772:			 * multibyte strings, so record the
        -: 1773:			 * matches.
        -: 1774:			 * Unfortunately the count num works
        -: 1775:			 * from the end, so it's easy to get the
        -: 1776:			 * last one but we need to repeat if
        -: 1777:			 * we want another one.
        -: 1778:			 */
    #####: 1779:			for (t = d, r = 0; r <= beg; r++) {
    #####: 1780:			    if (pprog && pattry(pprog, t)) {
    #####: 1781:				nmatches++;
    #####: 1782:				lastpos = t;
        -: 1783:			    }
    #####: 1784:			    if (t == de)
    #####: 1785:				break;
    #####: 1786:			    t += MB_METACHARLEN(t);
        -: 1787:			}
        -: 1788:
    #####: 1789:			if (nmatches >= num) {
    #####: 1790:			    if (num > 1) {
        -: 1791:				/*
        -: 1792:				 * Need to start again and repeat
        -: 1793:				 * to get the right match.
        -: 1794:				 */
    #####: 1795:				nmatches -= num;
    #####: 1796:				MB_METACHARINIT();
    #####: 1797:				for (t = d, r = 0; ; r++) {
    #####: 1798:				    if (pprog && pattry(pprog, t) &&
    #####: 1799:					nmatches-- == 0) {
    #####: 1800:					lastpos = t;
    #####: 1801:					break;
        -: 1802:				    }
    #####: 1803:				    t += MB_METACHARLEN(t);
        -: 1804:				}
        -: 1805:			    }
        -: 1806:			    /* else lastpos is already OK */
        -: 1807:
        -: 1808:			    /* return pointer after matched char */
    #####: 1809:			    lastpos +=
    #####: 1810:				(lastcharlen = MB_METACHARLEN(lastpos));
    #####: 1811:			    if (prevcharlen)
    #####: 1812:				*prevcharlen = lastcharlen;
    #####: 1813:			    if (nextcharlen)
    #####: 1814:				*nextcharlen = MB_METACHARLEN(lastpos);
    #####: 1815:			    return lastpos - d;
        -: 1816:			}
        -: 1817:
    #####: 1818:			for (r = beg + 1, t = d + beg; t >= d; r--, t--) {
    #####: 1819:			    if (pprog && pattry(pprog, t) &&
        -: 1820:				!--num)
    #####: 1821:				return r;
        -: 1822:			}
        -: 1823:		    } else {
    #####: 1824:			for (t = d; beg && t <= de; beg--)
    #####: 1825:			    t += MB_METACHARLEN(t);
        -: 1826:			for (;;) {
    #####: 1827:			    if (pprog && pattry(pprog, t) && !--num) {
        -: 1828:				/* return pointer after matched char */
    #####: 1829:				t += (lastcharlen = MB_METACHARLEN(t));
    #####: 1830:				if (prevcharlen)
    #####: 1831:				    *prevcharlen = lastcharlen;
    #####: 1832:				if (nextcharlen)
    #####: 1833:				    *nextcharlen = MB_METACHARLEN(t);
    #####: 1834:				return t - d;
        -: 1835:			    }
    #####: 1836:			    if (t == de)
    #####: 1837:				break;
    #####: 1838:			    t += MB_METACHARLEN(t);
        -: 1839:			}
        -: 1840:		    }
        -: 1841:		}
        -: 1842:	    }
    #####: 1843:	    return down ? 0 : slen + 1;
        -: 1844:	}
        -: 1845:    }
        5: 1846:    return r;
        -: 1847:}
        -: 1848:
        -: 1849:/*
        -: 1850: * Parse a subscript.
        -: 1851: *
        -: 1852: * pptr: In/Out parameter.  On entry, *ptr points to a "[foo]" string.  On exit
        -: 1853: * it will point one past the closing bracket.
        -: 1854: *
        -: 1855: * v: In/Out parameter.  Its .start and .end members (at least) will be updated
        -: 1856: * with the parsed indices.
        -: 1857: *
        -: 1858: * flags: can be either SCANPM_DQUOTED or zero.  Other bits are not used.
        -: 1859: */
        -: 1860:
        -: 1861:/**/
        -: 1862:int
        7: 1863:getindex(char **pptr, Value v, int flags)
        -: 1864:{
        7: 1865:    int start, end, inv = 0;
        7: 1866:    char *s = *pptr, *tbrack;
        -: 1867:
        7: 1868:    *s++ = '[';
        -: 1869:    /* Error handled after untokenizing */
        7: 1870:    s = parse_subscript(s, flags & SCANPM_DQUOTED, ']');
        -: 1871:    /* Now we untokenize everything except inull() markers so we can check *
        -: 1872:     * for the '*' and '@' special subscripts.  The inull()s are removed  *
        -: 1873:     * in getarg() after we know whether we're doing reverse indexing.    */
       27: 1874:    for (tbrack = *pptr + 1; *tbrack && tbrack != s; tbrack++) {
       20: 1875:	if (inull(*tbrack) && !*++tbrack)
    #####: 1876:	    break;
       20: 1877:	if (itok(*tbrack))	/* Need to check for Nularg here? */
    #####: 1878:	    *tbrack = ztokens[*tbrack - Pound];
        -: 1879:    }
        -: 1880:    /* If we reached the end of the string (s == NULL) we have an error */
        7: 1881:    if (*tbrack)
        7: 1882:	*tbrack = Outbrack;
        -: 1883:    else {
    #####: 1884:	zerr("invalid subscript");
    #####: 1885:	*pptr = tbrack;
    #####: 1886:	return 1;
        -: 1887:    }
        7: 1888:    s = *pptr + 1;
        7: 1889:    if ((s[0] == '*' || s[0] == '@') && s + 1 == tbrack) {
        2: 1890:	if ((v->isarr || IS_UNSET_VALUE(v)) && s[0] == '@')
    #####: 1891:	    v->isarr |= SCANPM_ISVAR_AT;
        2: 1892:	v->start = 0;
        2: 1893:	v->end = -1;
        2: 1894:	s += 2;
        -: 1895:    } else {
        5: 1896:	zlong we = 0, dummy;
        -: 1897:	int startprevlen, startnextlen;
        -: 1898:
        5: 1899:	start = getarg(&s, &inv, v, 0, &we, &startprevlen, &startnextlen,
        -: 1900:		       flags);
        -: 1901:
        5: 1902:	if (inv) {
    #####: 1903:	    if (!v->isarr && start != 0) {
        -: 1904:		char *t, *p;
    #####: 1905:		t = getstrvalue(v);
        -: 1906:		/*
        -: 1907:		 * Note for the confused (= pws): this is an inverse
        -: 1908:		 * offset so at this stage we need to convert from
        -: 1909:		 * the immediate offset into the value that we have
        -: 1910:		 * into a logical character position.
        -: 1911:		 */
    #####: 1912:		if (start > 0) {
    #####: 1913:		    int nstart = 0;
    #####: 1914:		    char *target = t + start - startprevlen;
        -: 1915:
    #####: 1916:		    p = t;
    #####: 1917:		    MB_METACHARINIT();
    #####: 1918:		    while (*p) {
        -: 1919:			/*
        -: 1920:			 * move up characters, counting how many we
        -: 1921:			 * found
        -: 1922:			 */
    #####: 1923:			p += MB_METACHARLEN(p);
    #####: 1924:			if (p < target)
    #####: 1925:			    nstart++;
        -: 1926:			else {
    #####: 1927:			    if (p == target)
    #####: 1928:				nstart++;
        -: 1929:			    else
    #####: 1930:				p = target; /* pretend we hit exactly */
    #####: 1931:			    break;
        -: 1932:			}
        -: 1933:		    }
        -: 1934:		    /* if start was too big, keep the difference */
    #####: 1935:		    start = nstart + (target - p) + 1;
        -: 1936:		} else {
    #####: 1937:		    zlong startoff = start + strlen(t);
        -: 1938:#ifdef DEBUG
        -: 1939:		    dputs("BUG: can't have negative inverse offsets???");
        -: 1940:#endif
    #####: 1941:		    if (startoff < 0) {
        -: 1942:			/* invalid: keep index but don't dereference */
    #####: 1943:			start = startoff;
        -: 1944:		    } else {
        -: 1945:			/* find start in full characters */
    #####: 1946:			MB_METACHARINIT();
    #####: 1947:			for (p = t; p < t + startoff;)
    #####: 1948:			    p += MB_METACHARLEN(p);
    #####: 1949:			start = - MB_METASTRLEN(p);
        -: 1950:		    }
        -: 1951:		}
        -: 1952:	    }
    #####: 1953:	    if (start > 0 && (isset(KSHARRAYS) || (v->pm->node.flags & PM_HASHED)))
    #####: 1954:		start--;
    #####: 1955:	    if (v->isarr != SCANPM_WANTINDEX) {
    #####: 1956:		v->flags |= VALFLAG_INV;
    #####: 1957:		v->isarr = 0;
    #####: 1958:		v->start = start;
    #####: 1959:		v->end = start + 1;
        -: 1960:	    }
    #####: 1961:	    if (*s == ',') {
    #####: 1962:		zerr("invalid subscript");
    #####: 1963:		*tbrack = ']';
    #####: 1964:		*pptr = tbrack+1;
    #####: 1965:		return 1;
        -: 1966:	    }
    #####: 1967:	    if (s == tbrack)
    #####: 1968:		s++;
        -: 1969:	} else {
        -: 1970:	    int com;
        -: 1971:
        5: 1972:	    if ((com = (*s == ','))) {
    #####: 1973:		s++;
    #####: 1974:		end = getarg(&s, &inv, v, 1, &dummy, NULL, NULL, flags);
        -: 1975:	    } else {
        5: 1976:		end = we ? we : start;
        -: 1977:	    }
        5: 1978:	    if (start != end)
        4: 1979:		com = 1;
        -: 1980:	    /*
        -: 1981:	     * Somehow the logic sometimes forces us to use the previous
        -: 1982:	     * or next character to what we would expect, which is
        -: 1983:	     * why we had to calculate them in getarg().
        -: 1984:	     */
        5: 1985:	    if (start > 0)
        1: 1986:		start -= startprevlen;
        4: 1987:	    else if (start == 0 && end == 0)
        -: 1988:	    {
        -: 1989:		/*
        -: 1990:		 * Strictly, this range is entirely off the
        -: 1991:		 * start of the available index range.
        -: 1992:		 * This can't happen with KSH_ARRAYS; we already
        -: 1993:		 * altered the start index in getarg().
        -: 1994:		 * Are we being strict?
        -: 1995:		 */
    #####: 1996:		if (isset(KSHZEROSUBSCRIPT)) {
        -: 1997:		    /*
        -: 1998:		     * We're not.
        -: 1999:		     * Treat this as accessing the first element of the
        -: 2000:		     * array.
        -: 2001:		     */
    #####: 2002:		    end = startnextlen;
        -: 2003:		} else {
        -: 2004:		    /*
        -: 2005:		     * We are.  Flag that this range is invalid
        -: 2006:		     * for setting elements.  Set the indexes
        -: 2007:		     * to a range that returns empty for other accesses.
        -: 2008:		     */
    #####: 2009:		    v->flags |= VALFLAG_EMPTY;
    #####: 2010:		    start = -1;
    #####: 2011:		    com = 1;
        -: 2012:		}
        -: 2013:	    }
        5: 2014:	    if (s == tbrack) {
        5: 2015:		s++;
        6: 2016:		if (v->isarr && !com &&
        1: 2017:		    (!(v->isarr & SCANPM_MATCHMANY) ||
    #####: 2018:		     !(v->isarr & (SCANPM_MATCHKEY | SCANPM_MATCHVAL |
        -: 2019:				   SCANPM_KEYMATCH))))
        1: 2020:		    v->isarr = 0;
        5: 2021:		v->start = start;
        5: 2022:		v->end = end;
        -: 2023:	    } else
    #####: 2024:		s = *pptr;
        -: 2025:	}
        -: 2026:    }
        7: 2027:    *tbrack = ']';
        7: 2028:    *pptr = s;
        7: 2029:    return 0;
        -: 2030:}
        -: 2031:
        -: 2032:
        -: 2033:/**/
        -: 2034:mod_export Value
      404: 2035:getvalue(Value v, char **pptr, int bracks)
        -: 2036:{
      404: 2037:  return fetchvalue(v, pptr, bracks, 0);
        -: 2038:}
        -: 2039:
        -: 2040:/**/
        -: 2041:mod_export Value
      576: 2042:fetchvalue(Value v, char **pptr, int bracks, int flags)
        -: 2043:{
        -: 2044:    char *s, *t, *ie;
        -: 2045:    char sav, c;
      576: 2046:    int ppar = 0;
        -: 2047:
      576: 2048:    s = t = *pptr;
        -: 2049:
      576: 2050:    if (idigit(c = *s)) {
        8: 2051:	if (bracks >= 0)
        8: 2052:	    ppar = zstrtol(s, &s, 10);
        -: 2053:	else
    #####: 2054:	    ppar = *s++ - '0';
        -: 2055:    }
      568: 2056:    else if ((ie = itype_end(s, IIDENT, 0)) != s)
      564: 2057:	s = ie;
        4: 2058:    else if (c == Quest)
        2: 2059:	*s++ = '?';
        2: 2060:    else if (c == Pound)
        1: 2061:	*s++ = '#';
        1: 2062:    else if (c == String)
        1: 2063:	*s++ = '$';
    #####: 2064:    else if (c == Qstring)
    #####: 2065:	*s++ = '$';
    #####: 2066:    else if (c == Star)
    #####: 2067:	*s++ = '*';
    #####: 2068:    else if (IS_DASH(c))
    #####: 2069:	*s++ = '-';
    #####: 2070:    else if (c == '#' || c == '?' || c == '$' ||
    #####: 2071:	     c == '!' || c == '@' || c == '*')
    #####: 2072:	s++;
        -: 2073:    else
    #####: 2074:	return NULL;
        -: 2075:
      576: 2076:    if ((sav = *s))
       65: 2077:	*s = '\0';
      576: 2078:    if (ppar) {
        6: 2079:	if (v)
        6: 2080:	    memset(v, 0, sizeof(*v));
        -: 2081:	else
    #####: 2082:	    v = (Value) hcalloc(sizeof *v);
        6: 2083:	v->pm = argvparam;
        6: 2084:	v->flags = 0;
        6: 2085:	v->start = ppar - 1;
        6: 2086:	v->end = ppar;
        6: 2087:	if (sav)
    #####: 2088:	    *s = sav;
        -: 2089:    } else {
        -: 2090:	Param pm;
        -: 2091:	int isvarat;
        -: 2092:
      570: 2093:        isvarat = (t[0] == '@' && !t[1]);
      570: 2094:	pm = (Param) paramtab->getnode(paramtab, *t == '0' ? "0" : t);
      570: 2095:	if (sav)
       65: 2096:	    *s = sav;
      570: 2097:	*pptr = s;
      577: 2098:	if (!pm || ((pm->node.flags & PM_UNSET) &&
        7: 2099:		    !(pm->node.flags & PM_DECLARED)))
      186: 2100:	    return NULL;
      384: 2101:	if (v)
      384: 2102:	    memset(v, 0, sizeof(*v));
        -: 2103:	else
    #####: 2104:	    v = (Value) hcalloc(sizeof *v);
      384: 2105:	if (PM_TYPE(pm->node.flags) & (PM_ARRAY|PM_HASHED)) {
        -: 2106:	    /* Overload v->isarr as the flag bits for hashed arrays. */
       23: 2107:	    v->isarr = flags | (isvarat ? SCANPM_ISVAR_AT : 0);
        -: 2108:	    /* If no flags were passed, we need something to represent *
        -: 2109:	     * `true' yet differ from an explicit WANTVALS.  Use a     *
        -: 2110:	     * special flag for this case.                             */
       23: 2111:	    if (!v->isarr)
        5: 2112:		v->isarr = SCANPM_ARRONLY;
        -: 2113:	}
      384: 2114:	v->pm = pm;
      384: 2115:	v->flags = 0;
      384: 2116:	v->start = 0;
      384: 2117:	v->end = -1;
      384: 2118:	if (bracks > 0 && (*s == '[' || *s == Inbrack)) {
       14: 2119:	    if (getindex(&s, v, flags)) {
    #####: 2120:		*pptr = s;
    #####: 2121:		return v;
        -: 2122:	    }
      381: 2123:	} else if (!(flags & SCANPM_ASSIGNING) && v->isarr &&
        8: 2124:		   itype_end(t, IIDENT, 1) != t && isset(KSHARRAYS))
    #####: 2125:	    v->end = 1, v->isarr = 0;
        -: 2126:    }
      390: 2127:    if (!bracks && *s)
    #####: 2128:	return NULL;
      390: 2129:    *pptr = s;
        -: 2130:#if 0
        -: 2131:    /*
        -: 2132:     * Check for large subscripts that might be erroneous.
        -: 2133:     * This code is too gross in several ways:
        -: 2134:     * - the limit is completely arbitrary
        -: 2135:     * - the test vetoes operations on existing arrays
        -: 2136:     * - it's not at all clear a general test on large arrays of
        -: 2137:     *   this kind is any use.
        -: 2138:     *
        -: 2139:     * Until someone comes up with workable replacement code it's
        -: 2140:     * therefore commented out.
        -: 2141:     */
        -: 2142:    if (v->start > MAX_ARRLEN) {
        -: 2143:	zerr("subscript too %s: %d", "big", v->start + !isset(KSHARRAYS));
        -: 2144:	return NULL;
        -: 2145:    }
        -: 2146:    if (v->start < -MAX_ARRLEN) {
        -: 2147:	zerr("subscript too %s: %d", "small", v->start);
        -: 2148:	return NULL;
        -: 2149:    }
        -: 2150:    if (v->end > MAX_ARRLEN+1) {
        -: 2151:	zerr("subscript too %s: %d", "big", v->end - !!isset(KSHARRAYS));
        -: 2152:	return NULL;
        -: 2153:    }
        -: 2154:    if (v->end < -MAX_ARRLEN) {
        -: 2155:	zerr("subscript too %s: %d", "small", v->end);
        -: 2156:	return NULL;
        -: 2157:    }
        -: 2158:#endif
      390: 2159:    return v;
        -: 2160:}
        -: 2161:
        -: 2162:/**/
        -: 2163:mod_export char *
     1138: 2164:getstrvalue(Value v)
        -: 2165:{
        -: 2166:    char *s, **ss;
        -: 2167:    char buf[BDIGBUFSIZE];
        -: 2168:    int len;
        -: 2169:
     1138: 2170:    if (!v)
    #####: 2171:	return hcalloc(1);
        -: 2172:
     1138: 2173:    if ((v->flags & VALFLAG_INV) && !(v->pm->node.flags & PM_HASHED)) {
    #####: 2174:	sprintf(buf, "%d", v->start);
    #####: 2175:	s = dupstring(buf);
    #####: 2176:	return s;
        -: 2177:    }
        -: 2178:
     1138: 2179:    switch(PM_TYPE(v->pm->node.flags)) {
    #####: 2180:    case PM_HASHED:
        -: 2181:	/* (!v->isarr) should be impossible unless emulating ksh */
    #####: 2182:	if (!v->isarr && EMULATION(EMULATE_KSH)) {
    #####: 2183:	    s = dupstring("[0]");
    #####: 2184:	    if (getindex(&s, v, 0) == 0)
    #####: 2185:		s = getstrvalue(v);
    #####: 2186:	    return s;
        -: 2187:	} /* else fall through */
        -: 2188:    case PM_ARRAY:
        7: 2189:	ss = getvaluearr(v);
        7: 2190:	if (v->isarr)
    #####: 2191:	    s = sepjoin(ss, NULL, 1);
        -: 2192:	else {
        7: 2193:	    if (v->start < 0)
    #####: 2194:		v->start += arrlen(ss);
       21: 2195:	    s = (arrlen_le(ss, v->start) || v->start < 0) ?
        7: 2196:		(char *) hcalloc(1) : ss[v->start];
        -: 2197:	}
        7: 2198:	return s;
       25: 2199:    case PM_INTEGER:
       25: 2200:	convbase(buf, v->pm->gsu.i->getfn(v->pm), v->pm->base);
       25: 2201:	s = dupstring(buf);
       25: 2202:	break;
    #####: 2203:    case PM_EFLOAT:
        -: 2204:    case PM_FFLOAT:
    #####: 2205:	s = convfloat(v->pm->gsu.f->getfn(v->pm),
    #####: 2206:		      v->pm->base, v->pm->node.flags, NULL);
    #####: 2207:	break;
     1106: 2208:    case PM_SCALAR:
     1106: 2209:	s = v->pm->gsu.s->getfn(v->pm);
     1106: 2210:	break;
    #####: 2211:    default:
    #####: 2212:	s = "";
        -: 2213:	DPUTS(1, "BUG: param node without valid type");
    #####: 2214:	break;
        -: 2215:    }
        -: 2216:
     1131: 2217:    if (v->flags & VALFLAG_SUBST) {
      135: 2218:	if (v->pm->node.flags & (PM_LEFT|PM_RIGHT_B|PM_RIGHT_Z)) {
    #####: 2219:	    size_t fwidth = v->pm->width ? (unsigned int)v->pm->width : MB_METASTRLEN(s);
    #####: 2220:	    switch (v->pm->node.flags & (PM_LEFT | PM_RIGHT_B | PM_RIGHT_Z)) {
        -: 2221:		char *t, *tend;
        -: 2222:		size_t t0;
        -: 2223:
    #####: 2224:	    case PM_LEFT:
        -: 2225:	    case PM_LEFT | PM_RIGHT_Z:
    #####: 2226:		t = s;
    #####: 2227:		if (v->pm->node.flags & PM_RIGHT_Z)
    #####: 2228:		    while (*t == '0')
    #####: 2229:			t++;
        -: 2230:		else
    #####: 2231:		    while (iblank(*t))
    #####: 2232:			t++;
    #####: 2233:		MB_METACHARINIT();
    #####: 2234:		for (tend = t, t0 = 0; t0 < fwidth && *tend; t0++)
    #####: 2235:		    tend += MB_METACHARLEN(tend);
        -: 2236:		/*
        -: 2237:		 * t0 is the number of characters from t used,
        -: 2238:		 * hence (fwidth - t0) is the number of padding
        -: 2239:		 * characters.  fwidth is a misnomer: we use
        -: 2240:		 * character counts, not character widths.
        -: 2241:		 *
        -: 2242:		 * (tend - t) is the number of bytes we need
        -: 2243:		 * to get fwidth characters or the entire string;
        -: 2244:		 * the characters may be multiple bytes.
        -: 2245:		 */
    #####: 2246:		fwidth -= t0; /* padding chars remaining */
    #####: 2247:		t0 = tend - t; /* bytes to copy from string */
    #####: 2248:		s = (char *) hcalloc(t0 + fwidth + 1);
    #####: 2249:		memcpy(s, t, t0);
    #####: 2250:		if (fwidth)
    #####: 2251:		    memset(s + t0, ' ', fwidth);
    #####: 2252:		s[t0 + fwidth] = '\0';
    #####: 2253:		break;
    #####: 2254:	    case PM_RIGHT_B:
        -: 2255:	    case PM_RIGHT_Z:
        -: 2256:	    case PM_RIGHT_Z | PM_RIGHT_B:
        -: 2257:		{
    #####: 2258:		    int zero = 1;
        -: 2259:		    /* Calculate length in possibly multibyte chars */
    #####: 2260:		    unsigned int charlen = MB_METASTRLEN(s);
        -: 2261:
    #####: 2262:		    if (charlen < fwidth) {
    #####: 2263:			char *valprefend = s;
        -: 2264:			int preflen;
    #####: 2265:			if (v->pm->node.flags & PM_RIGHT_Z) {
        -: 2266:			    /*
        -: 2267:			     * This is a documented feature: when deciding
        -: 2268:			     * whether to pad with zeroes, ignore
        -: 2269:			     * leading blanks already in the value;
        -: 2270:			     * only look for numbers after that.
        -: 2271:			     * Not sure how useful this really is.
        -: 2272:			     * It's certainly confusing to code around.
        -: 2273:			     */
    #####: 2274:			    for (t = s; iblank(*t); t++)
        -: 2275:				;
        -: 2276:			    /*
        -: 2277:			     * Allow padding after initial minus
        -: 2278:			     * for numeric variables.
        -: 2279:			     */
    #####: 2280:			    if ((v->pm->node.flags &
    #####: 2281:				 (PM_INTEGER|PM_EFLOAT|PM_FFLOAT)) &&
    #####: 2282:				*t == '-')
    #####: 2283:				t++;
        -: 2284:			    /*
        -: 2285:			     * Allow padding after initial 0x or
        -: 2286:			     * base# for integer variables.
        -: 2287:			     */
    #####: 2288:			    if (v->pm->node.flags & PM_INTEGER) {
    #####: 2289:				if (isset(CBASES) &&
    #####: 2290:				    t[0] == '0' && t[1] == 'x')
    #####: 2291:				    t += 2;
    #####: 2292:				else if ((valprefend = strchr(t, '#')))
    #####: 2293:				    t = valprefend + 1;
        -: 2294:			    }
    #####: 2295:			    valprefend = t;
    #####: 2296:			    if (!*t)
    #####: 2297:				zero = 0;
    #####: 2298:			    else if (v->pm->node.flags &
        -: 2299:				     (PM_INTEGER|PM_EFLOAT|PM_FFLOAT)) {
        -: 2300:				/* zero always OK */
    #####: 2301:			    } else if (!idigit(*t))
    #####: 2302:				zero = 0;
        -: 2303:			}
        -: 2304:			/* number of characters needed for padding */
    #####: 2305:			fwidth -= charlen;
        -: 2306:			/* bytes from original string */
    #####: 2307:			t0 = strlen(s);
    #####: 2308:			t = (char *) hcalloc(fwidth + t0 + 1);
        -: 2309:			/* prefix guaranteed to be single byte chars */
    #####: 2310:			preflen = valprefend - s;
    #####: 2311:			memset(t + preflen, 
    #####: 2312:			       (((v->pm->node.flags & PM_RIGHT_B)
    #####: 2313:				 || !zero) ?       ' ' : '0'), fwidth);
        -: 2314:			/*
        -: 2315:			 * Copy - or 0x or base# before any padding
        -: 2316:			 * zeroes.
        -: 2317:			 */
    #####: 2318:			if (preflen)
    #####: 2319:			    memcpy(t, s, preflen);
    #####: 2320:			memcpy(t + preflen + fwidth,
        -: 2321:			       valprefend, t0 - preflen);
    #####: 2322:			t[fwidth + t0] = '\0';
    #####: 2323:			s = t;
        -: 2324:		    } else {
        -: 2325:			/* Need to skip (charlen - fwidth) chars */
    #####: 2326:			for (t0 = charlen - fwidth; t0; t0--)
    #####: 2327:			    s += MB_METACHARLEN(s);
        -: 2328:		    }
        -: 2329:		}
    #####: 2330:		break;
        -: 2331:	    }
        -: 2332:	}
      135: 2333:	switch (v->pm->node.flags & (PM_LOWER | PM_UPPER)) {
    #####: 2334:	case PM_LOWER:
    #####: 2335:	    s = casemodify(s, CASMOD_LOWER);
    #####: 2336:	    break;
    #####: 2337:	case PM_UPPER:
    #####: 2338:	    s = casemodify(s, CASMOD_UPPER);
    #####: 2339:	    break;
        -: 2340:	}
        -: 2341:    }
     1131: 2342:    if (v->start == 0 && v->end == -1)
     1131: 2343:	return s;
        -: 2344:
    #####: 2345:    len = strlen(s);
    #####: 2346:    if (v->start < 0) {
    #####: 2347:	v->start += len;
    #####: 2348:	if (v->start < 0)
    #####: 2349:	    v->start = 0;
        -: 2350:    }
    #####: 2351:    if (v->end < 0) {
    #####: 2352:	v->end += len;
    #####: 2353:	if (v->end >= 0) {
    #####: 2354:	    char *eptr = s + v->end;
    #####: 2355:	    if (*eptr)
    #####: 2356:		v->end += MB_METACHARLEN(eptr);
        -: 2357:	}
        -: 2358:    }
        -: 2359:
    #####: 2360:    s = (v->start > len) ? dupstring("") :
    #####: 2361:	dupstring_wlen(s + v->start, len - v->start);
        -: 2362:
    #####: 2363:    if (v->end <= v->start)
    #####: 2364:	s[0] = '\0';
    #####: 2365:    else if (v->end - v->start <= len - v->start)
    #####: 2366:	s[v->end - v->start] = '\0';
        -: 2367:
    #####: 2368:    return s;
        -: 2369:}
        -: 2370:
        -: 2371:static char *nular[] = {"", NULL};
        -: 2372:
        -: 2373:/**/
        -: 2374:mod_export char **
        5: 2375:getarrvalue(Value v)
        -: 2376:{
        -: 2377:    char **s;
        -: 2378:
        5: 2379:    if (!v)
    #####: 2380:	return arrdup(nular);
        5: 2381:    else if (IS_UNSET_VALUE(v))
    #####: 2382:	return arrdup(&nular[1]);
        5: 2383:    if (v->flags & VALFLAG_INV) {
        -: 2384:	char buf[DIGBUFSIZE];
        -: 2385:
    #####: 2386:	s = arrdup(nular);
    #####: 2387:	sprintf(buf, "%d", v->start);
    #####: 2388:	s[0] = dupstring(buf);
    #####: 2389:	return s;
        -: 2390:    }
        5: 2391:    s = getvaluearr(v);
        5: 2392:    if (v->start == 0 && v->end == -1)
        2: 2393:	return s;
        3: 2394:    if (v->start < 0)
    #####: 2395:	v->start += arrlen(s);
        3: 2396:    if (v->end < 0)
    #####: 2397:	v->end += arrlen(s) + 1;
        -: 2398:
        -: 2399:    /* Null if 1) array too short, 2) index still negative */
        3: 2400:    if (v->end <= v->start) {
    #####: 2401:	s = arrdup_max(nular, 0);
        -: 2402:    }
        3: 2403:    else if (v->start < 0) {
    #####: 2404:	s = arrdup_max(nular, 1);
        -: 2405:    }
        3: 2406:    else if (arrlen_le(s, v->start)) {
        -: 2407:	/* Handle $ary[i,i] consistently for any $i > $#ary
        -: 2408:	 * and $ary[i,j] consistently for any $j > $i > $#ary
        -: 2409:	 */
    #####: 2410:	s = arrdup_max(nular, v->end - (v->start + 1));
        -: 2411:    }
        -: 2412:    else {
        -: 2413:        /* Copy to a point before the end of the source array:
        -: 2414:         * arrdup_max will copy at most v->end - v->start elements,
        -: 2415:         * starting from v->start element. Original code said:
        -: 2416:	 *  s[v->end - v->start] = NULL
        -: 2417:         * which means that there are exactly the same number of
        -: 2418:         * elements as the value of the above *0-based* index.
        -: 2419:         */
        3: 2420:	s = arrdup_max(s + v->start, v->end - v->start);
        -: 2421:    }
        -: 2422:
        3: 2423:    return s;
        -: 2424:}
        -: 2425:
        -: 2426:/**/
        -: 2427:mod_export zlong
    #####: 2428:getintvalue(Value v)
        -: 2429:{
    #####: 2430:    if (!v)
    #####: 2431:	return 0;
    #####: 2432:    if (v->flags & VALFLAG_INV)
    #####: 2433:	return v->start;
    #####: 2434:    if (v->isarr) {
    #####: 2435:	char **arr = getarrvalue(v);
    #####: 2436:	if (arr) {
    #####: 2437:	    char *scal = sepjoin(arr, NULL, 1);
    #####: 2438:	    return mathevali(scal);
        -: 2439:	} else
    #####: 2440:	    return 0;
        -: 2441:    }
    #####: 2442:    if (PM_TYPE(v->pm->node.flags) == PM_INTEGER)
    #####: 2443:	return v->pm->gsu.i->getfn(v->pm);
    #####: 2444:    if (v->pm->node.flags & (PM_EFLOAT|PM_FFLOAT))
    #####: 2445:	return (zlong)v->pm->gsu.f->getfn(v->pm);
    #####: 2446:    return mathevali(getstrvalue(v));
        -: 2447:}
        -: 2448:
        -: 2449:/**/
        -: 2450:mnumber
        3: 2451:getnumvalue(Value v)
        -: 2452:{
        -: 2453:    mnumber mn;
        3: 2454:    mn.type = MN_INTEGER;
        -: 2455:
        -: 2456:
        3: 2457:    if (!v) {
    #####: 2458:	mn.u.l = 0;
        3: 2459:    } else if (v->flags & VALFLAG_INV) {
    #####: 2460:	mn.u.l = v->start;
        3: 2461:    } else if (v->isarr) {
    #####: 2462:	char **arr = getarrvalue(v);
    #####: 2463:	if (arr) {
    #####: 2464:	    char *scal = sepjoin(arr, NULL, 1);
    #####: 2465:	    return matheval(scal);
        -: 2466:	} else
    #####: 2467:	    mn.u.l = 0;
        3: 2468:    } else if (PM_TYPE(v->pm->node.flags) == PM_INTEGER) {
        3: 2469:	mn.u.l = v->pm->gsu.i->getfn(v->pm);
    #####: 2470:    } else if (v->pm->node.flags & (PM_EFLOAT|PM_FFLOAT)) {
    #####: 2471:	mn.type = MN_FLOAT;
    #####: 2472:	mn.u.d = v->pm->gsu.f->getfn(v->pm);
        -: 2473:    } else
    #####: 2474:	return matheval(getstrvalue(v));
        3: 2475:    return mn;
        -: 2476:}
        -: 2477:
        -: 2478:/**/
        -: 2479:void
        8: 2480:export_param(Param pm)
        -: 2481:{
        -: 2482:    char buf[BDIGBUFSIZE], *val;
        -: 2483:
        8: 2484:    if (PM_TYPE(pm->node.flags) & (PM_ARRAY|PM_HASHED)) {
        -: 2485:#if 0	/* Requires changes elsewhere in params.c and builtin.c */
        -: 2486:	if (EMULATION(EMULATE_KSH) /* isset(KSHARRAYS) */) {
        -: 2487:	    struct value v;
        -: 2488:	    v.isarr = 1;
        -: 2489:	    v.flags = 0;
        -: 2490:	    v.start = 0;
        -: 2491:	    v.end = -1;
        -: 2492:	    val = getstrvalue(&v);
        -: 2493:	} else
        -: 2494:#endif
    #####: 2495:	    return;
        8: 2496:    } else if (PM_TYPE(pm->node.flags) == PM_INTEGER)
    #####: 2497:	convbase(val = buf, pm->gsu.i->getfn(pm), pm->base);
        8: 2498:    else if (pm->node.flags & (PM_EFLOAT|PM_FFLOAT))
    #####: 2499:	val = convfloat(pm->gsu.f->getfn(pm), pm->base,
        -: 2500:			pm->node.flags, NULL);
        -: 2501:    else
        8: 2502:	val = pm->gsu.s->getfn(pm);
        -: 2503:
        8: 2504:    addenv(pm, val);
        -: 2505:}
        -: 2506:
        -: 2507:/**/
        -: 2508:mod_export void
       11: 2509:setstrvalue(Value v, char *val)
        -: 2510:{
       11: 2511:    assignstrvalue(v, val, 0);
       11: 2512:}
        -: 2513:
        -: 2514:/**/
        -: 2515:mod_export void
      615: 2516:assignstrvalue(Value v, char *val, int flags)
        -: 2517:{
      615: 2518:    if (unset(EXECOPT))
    #####: 2519:	return;
      615: 2520:    if (v->pm->node.flags & PM_READONLY) {
    #####: 2521:	zerr("read-only variable: %s", v->pm->node.nam);
    #####: 2522:	zsfree(val);
    #####: 2523:	return;
        -: 2524:    }
      615: 2525:    if ((v->pm->node.flags & PM_RESTRICTED) && isset(RESTRICTED)) {
    #####: 2526:	zerr("%s: restricted", v->pm->node.nam);
    #####: 2527:	zsfree(val);
    #####: 2528:	return;
        -: 2529:    }
      615: 2530:    if ((v->pm->node.flags & PM_HASHED) &&
    #####: 2531:	(v->isarr & (SCANPM_MATCHMANY|SCANPM_ARRONLY))) {
    #####: 2532:	zerr("%s: attempt to set slice of associative array", v->pm->node.nam);
    #####: 2533:	zsfree(val);
    #####: 2534:	return;
        -: 2535:    }
      615: 2536:    if (v->flags & VALFLAG_EMPTY) {
    #####: 2537:	zerr("%s: assignment to invalid subscript range", v->pm->node.nam);
    #####: 2538:	zsfree(val);
    #####: 2539:	return;
        -: 2540:    }
      615: 2541:    v->pm->node.flags &= ~PM_UNSET;
      615: 2542:    switch (PM_TYPE(v->pm->node.flags)) {
      596: 2543:    case PM_SCALAR:
      596: 2544:	if (v->start == 0 && v->end == -1) {
      596: 2545:	    v->pm->gsu.s->setfn(v->pm, val);
     1192: 2546:	    if ((v->pm->node.flags & (PM_LEFT | PM_RIGHT_B | PM_RIGHT_Z)) &&
    #####: 2547:		!v->pm->width)
    #####: 2548:		v->pm->width = strlen(val);
        -: 2549:	} else {
        -: 2550:	    char *z, *x;
        -: 2551:            int zlen, vlen, newsize;
        -: 2552:
    #####: 2553:            z = v->pm->gsu.s->getfn(v->pm);
    #####: 2554:            zlen = strlen(z);
        -: 2555:
    #####: 2556:	    if ((v->flags & VALFLAG_INV) && unset(KSHARRAYS))
    #####: 2557:		v->start--, v->end--;
    #####: 2558:	    if (v->start < 0) {
    #####: 2559:		v->start += zlen;
    #####: 2560:		if (v->start < 0)
    #####: 2561:		    v->start = 0;
        -: 2562:	    }
    #####: 2563:	    if (v->start > zlen)
    #####: 2564:		v->start = zlen;
    #####: 2565:	    if (v->end < 0) {
    #####: 2566:		v->end += zlen;
    #####: 2567:		if (v->end < 0) {
    #####: 2568:		    v->end = 0;
    #####: 2569:		} else if (v->end >= zlen) {
    #####: 2570:		    v->end = zlen;
        -: 2571:		} else {
        -: 2572:#ifdef MULTIBYTE_SUPPORT
    #####: 2573:		    if (isset(MULTIBYTE)) {
    #####: 2574:			v->end += MB_METACHARLEN(z + v->end);
        -: 2575:		    } else {
    #####: 2576:			v->end++;
        -: 2577:		    }
        -: 2578:#else
        -: 2579:		    v->end++;
        -: 2580:#endif
        -: 2581:		}
        -: 2582:	    }
    #####: 2583:	    else if (v->end > zlen)
    #####: 2584:		v->end = zlen;
        -: 2585:
    #####: 2586:            vlen = strlen(val);
        -: 2587:            /* Characters preceding start index +
        -: 2588:               characters of what is assigned +
        -: 2589:               characters following end index */
    #####: 2590:            newsize = v->start + vlen + (zlen - v->end);
        -: 2591:
        -: 2592:            /* Does new size differ? */
    #####: 2593:            if (newsize != zlen || v->pm->gsu.s->setfn != strsetfn) {
    #####: 2594:                x = (char *) zalloc(newsize + 1);
    #####: 2595:                strncpy(x, z, v->start);
    #####: 2596:                strcpy(x + v->start, val);
    #####: 2597:                strcat(x + v->start, z + v->end);
    #####: 2598:                v->pm->gsu.s->setfn(v->pm, x);
        -: 2599:            } else {
    #####: 2600:		Param pm = v->pm;
        -: 2601:                /* Size doesn't change, can limit actions to only
        -: 2602:                 * overwriting bytes in already allocated string */
    #####: 2603:		memcpy(z + v->start, val, vlen);
        -: 2604:		/* Implement remainder of strsetfn */
    #####: 2605:		if (!(pm->node.flags & PM_HASHELEM) &&
    #####: 2606:		    ((pm->node.flags & PM_NAMEDDIR) ||
    #####: 2607:		     isset(AUTONAMEDIRS))) {
    #####: 2608:		    pm->node.flags |= PM_NAMEDDIR;
    #####: 2609:		    adduserdir(pm->node.nam, z, 0, 0);
        -: 2610:		}
        -: 2611:            }
    #####: 2612:            zsfree(val);
        -: 2613:	}
      596: 2614:	break;
       19: 2615:    case PM_INTEGER:
       19: 2616:	if (val) {
        -: 2617:	    zlong ival;
        8: 2618:	    if (flags & ASSPM_ENV_IMPORT) {
        -: 2619:		char *ptr;
        2: 2620:		ival = zstrtol_underscore(val, &ptr, 0, 1);
        -: 2621:	    } else
        6: 2622:		ival = mathevali(val);
        8: 2623:	    v->pm->gsu.i->setfn(v->pm, ival);
        8: 2624:	    if ((v->pm->node.flags & (PM_LEFT | PM_RIGHT_B | PM_RIGHT_Z)) &&
    #####: 2625:		!v->pm->width)
    #####: 2626:		v->pm->width = strlen(val);
        8: 2627:	    zsfree(val);
        -: 2628:	}
       19: 2629:	if (!v->pm->base && lastbase != -1)
        8: 2630:	    v->pm->base = lastbase;
       19: 2631:	break;
    #####: 2632:    case PM_EFLOAT:
        -: 2633:    case PM_FFLOAT:
    #####: 2634:	if (val) {
        -: 2635:	    mnumber mn;
    #####: 2636:	    if (flags & ASSPM_ENV_IMPORT) {
        -: 2637:		char *ptr;
    #####: 2638:		mn.type = MN_FLOAT;
    #####: 2639:		mn.u.d = strtod(val, &ptr);
        -: 2640:	    } else
    #####: 2641:		mn = matheval(val);
    #####: 2642:	    v->pm->gsu.f->setfn(v->pm, (mn.type & MN_FLOAT) ? mn.u.d :
    #####: 2643:			       (double)mn.u.l);
    #####: 2644:	    if ((v->pm->node.flags & (PM_LEFT | PM_RIGHT_B | PM_RIGHT_Z)) &&
    #####: 2645:		!v->pm->width)
    #####: 2646:		v->pm->width = strlen(val);
    #####: 2647:	    zsfree(val);
        -: 2648:	}
    #####: 2649:	break;
    #####: 2650:    case PM_ARRAY:
        -: 2651:	{
    #####: 2652:	    char **ss = (char **) zalloc(2 * sizeof(char *));
        -: 2653:
    #####: 2654:	    ss[0] = val;
    #####: 2655:	    ss[1] = NULL;
    #####: 2656:	    setarrvalue(v, ss);
        -: 2657:	}
    #####: 2658:	break;
    #####: 2659:    case PM_HASHED:
        -: 2660:        {
    #####: 2661:	    if (foundparam == NULL)
        -: 2662:	    {
    #####: 2663:		zerr("%s: attempt to set associative array to scalar",
    #####: 2664:		     v->pm->node.nam);
    #####: 2665:		zsfree(val);
    #####: 2666:		return;
        -: 2667:	    }
        -: 2668:	    else
    #####: 2669:		foundparam->gsu.s->setfn(foundparam, val);
        -: 2670:        }
    #####: 2671:	break;
        -: 2672:    }
     1222: 2673:    if ((!v->pm->env && !(v->pm->node.flags & PM_EXPORTED) &&
      615: 2674:	 !(isset(ALLEXPORT) && !(v->pm->node.flags & PM_HASHELEM))) ||
       16: 2675:	(v->pm->node.flags & PM_ARRAY) || v->pm->ename)
      607: 2676:	return;
        8: 2677:    export_param(v->pm);
        -: 2678:}
        -: 2679:
        -: 2680:/**/
        -: 2681:void
       11: 2682:setnumvalue(Value v, mnumber val)
        -: 2683:{
        -: 2684:    char buf[BDIGBUFSIZE], *p;
        -: 2685:
       11: 2686:    if (unset(EXECOPT))
    #####: 2687:	return;
       11: 2688:    if (v->pm->node.flags & PM_READONLY) {
    #####: 2689:	zerr("read-only variable: %s", v->pm->node.nam);
    #####: 2690:	return;
        -: 2691:    }
       11: 2692:    if ((v->pm->node.flags & PM_RESTRICTED) && isset(RESTRICTED)) {
    #####: 2693:	zerr("%s: restricted", v->pm->node.nam);
    #####: 2694:	return;
        -: 2695:    }
       11: 2696:    switch (PM_TYPE(v->pm->node.flags)) {
    #####: 2697:    case PM_SCALAR:
        -: 2698:    case PM_ARRAY:
    #####: 2699:	if ((val.type & MN_INTEGER) || outputradix) {
    #####: 2700:	    if (!(val.type & MN_INTEGER))
    #####: 2701:		val.u.l = (zlong) val.u.d;
    #####: 2702:	    p = convbase_underscore(buf, val.u.l, outputradix,
        -: 2703:				    outputunderscore);
        -: 2704:	} else
    #####: 2705:	    p = convfloat_underscore(val.u.d, outputunderscore);
    #####: 2706:	setstrvalue(v, ztrdup(p));
    #####: 2707:	break;
       11: 2708:    case PM_INTEGER:
       11: 2709:	v->pm->gsu.i->setfn(v->pm, (val.type & MN_INTEGER) ? val.u.l :
    #####: 2710:			    (zlong) val.u.d);
       11: 2711:	setstrvalue(v, NULL);
       11: 2712:	break;
    #####: 2713:    case PM_EFLOAT:
        -: 2714:    case PM_FFLOAT:
    #####: 2715:	v->pm->gsu.f->setfn(v->pm, (val.type & MN_INTEGER) ?
    #####: 2716:			    (double)val.u.l : val.u.d);
    #####: 2717:	setstrvalue(v, NULL);
    #####: 2718:	break;
        -: 2719:    }
        -: 2720:}
        -: 2721:
        -: 2722:/**/
        -: 2723:mod_export void
       12: 2724:setarrvalue(Value v, char **val)
        -: 2725:{
       12: 2726:    if (unset(EXECOPT))
    #####: 2727:	return;
       12: 2728:    if (v->pm->node.flags & PM_READONLY) {
    #####: 2729:	zerr("read-only variable: %s", v->pm->node.nam);
    #####: 2730:	freearray(val);
    #####: 2731:	return;
        -: 2732:    }
       12: 2733:    if ((v->pm->node.flags & PM_RESTRICTED) && isset(RESTRICTED)) {
    #####: 2734:	zerr("%s: restricted", v->pm->node.nam);
    #####: 2735:	freearray(val);
    #####: 2736:	return;
        -: 2737:    }
       12: 2738:    if (!(PM_TYPE(v->pm->node.flags) & (PM_ARRAY|PM_HASHED))) {
    #####: 2739:	freearray(val);
    #####: 2740:	zerr("%s: attempt to assign array value to non-array",
    #####: 2741:	     v->pm->node.nam);
    #####: 2742:	return;
        -: 2743:    }
       12: 2744:    if (v->flags & VALFLAG_EMPTY) {
    #####: 2745:	zerr("%s: assignment to invalid subscript range", v->pm->node.nam);
    #####: 2746:	freearray(val);
    #####: 2747:	return;
        -: 2748:    }
        -: 2749:
       12: 2750:    if (v->start == 0 && v->end == -1) {
       24: 2751:	if (PM_TYPE(v->pm->node.flags) == PM_HASHED)
        3: 2752:	    arrhashsetfn(v->pm, val, 0);
        -: 2753:	else
        9: 2754:	    v->pm->gsu.a->setfn(v->pm, val);
    #####: 2755:    } else if (v->start == -1 && v->end == 0 &&
    #####: 2756:    	    PM_TYPE(v->pm->node.flags) == PM_HASHED) {
    #####: 2757:    	arrhashsetfn(v->pm, val, ASSPM_AUGMENT);
    #####: 2758:    } else if ((PM_TYPE(v->pm->node.flags) == PM_HASHED)) {
    #####: 2759:	freearray(val);
    #####: 2760:	zerr("%s: attempt to set slice of associative array",
    #####: 2761:	     v->pm->node.nam);
    #####: 2762:	return;
        -: 2763:    } else {
    #####: 2764:	char **const old = v->pm->gsu.a->getfn(v->pm);
        -: 2765:	char **new;
        -: 2766:	char **p, **q, **r; /* index variables */
    #####: 2767:	const int pre_assignment_length = arrlen(old);
        -: 2768:	int post_assignment_length;
        -: 2769:	int i;
        -: 2770:
    #####: 2771:	q = old;
        -: 2772:
    #####: 2773:	if ((v->flags & VALFLAG_INV) && unset(KSHARRAYS)) {
    #####: 2774:	    if (v->start > 0)
    #####: 2775:		v->start--;
    #####: 2776:	    v->end--;
        -: 2777:	}
    #####: 2778:	if (v->start < 0) {
    #####: 2779:	    v->start += pre_assignment_length;
    #####: 2780:	    if (v->start < 0)
    #####: 2781:		v->start = 0;
        -: 2782:	}
    #####: 2783:	if (v->end < 0) {
    #####: 2784:	    v->end += pre_assignment_length + 1;
    #####: 2785:	    if (v->end < 0)
    #####: 2786:		v->end = 0;
        -: 2787:	}
    #####: 2788:	if (v->end < v->start)
    #####: 2789:	    v->end = v->start;
        -: 2790:
    #####: 2791:	post_assignment_length = v->start + arrlen(val);
    #####: 2792:	if (v->end < pre_assignment_length) {
        -: 2793:	    /* 
        -: 2794:	     * Allocate room for array elements between the end of the slice `v'
        -: 2795:	     * and the original array's end.
        -: 2796:	     */
    #####: 2797:	    post_assignment_length += pre_assignment_length - v->end;
        -: 2798:	}
        -: 2799:
    #####: 2800:	if (pre_assignment_length == post_assignment_length
    #####: 2801:	    && v->pm->gsu.a->setfn == arrsetfn
        -: 2802:	    /* ... and isn't something that arrsetfn() treats specially */
    #####: 2803:	    && 0 == (v->pm->node.flags & (PM_SPECIAL|PM_UNIQUE))
    #####: 2804:	    && NULL == v->pm->ename)
        -: 2805:	{
        -: 2806:	    /* v->start is 0-based */
    #####: 2807:	    p = old + v->start;
    #####: 2808:	    for (r = val; *r;) {
        -: 2809:		/* Free previous string */
    #####: 2810:		zsfree(*p);
        -: 2811:		/* Give away ownership of the string */
    #####: 2812:		*p++ = *r++;
        -: 2813:	    }
        -: 2814:	} else {
        -: 2815:            /* arr+=( ... )
        -: 2816:             * arr[${#arr}+x,...]=( ... ) */
    #####: 2817:            if (post_assignment_length > pre_assignment_length &&
    #####: 2818:                    pre_assignment_length <= v->start &&
    #####: 2819:                    pre_assignment_length > 0 &&
    #####: 2820:                    v->pm->gsu.a->setfn == arrsetfn)
        -: 2821:            {
    #####: 2822:                p = new = (char **) zrealloc(old, sizeof(char *)
    #####: 2823:                                           * (post_assignment_length + 1));
        -: 2824:
    #####: 2825:                p += pre_assignment_length; /* after old elements */
        -: 2826:
        -: 2827:                /* Consider 1 < 0, case for a=( 1 ); a[1,..] =
        -: 2828:                 *          1 < 1, case for a=( 1 ); a[2,..] = */
    #####: 2829:                if (pre_assignment_length < v->start) {
    #####: 2830:                    for (i = pre_assignment_length; i < v->start; i++) {
    #####: 2831:                        *p++ = ztrdup("");
        -: 2832:                    }
        -: 2833:                }
        -: 2834:
    #####: 2835:                for (r = val; *r;) {
        -: 2836:                    /* Give away ownership of the string */
    #####: 2837:                    *p++ = *r++;
        -: 2838:                }
        -: 2839:
        -: 2840:                /* v->end doesn't matter:
        -: 2841:                 * a=( 1 2 ); a[4,100]=( a b ); echo "${(q@)a}"
        -: 2842:                 * 1 2 '' a b */
    #####: 2843:                *p = NULL;
        -: 2844:
    #####: 2845:                v->pm->u.arr = NULL;
    #####: 2846:                v->pm->gsu.a->setfn(v->pm, new);
        -: 2847:            } else {
    #####: 2848:                p = new = (char **) zalloc(sizeof(char *)
    #####: 2849:                                           * (post_assignment_length + 1));
    #####: 2850:                for (i = 0; i < v->start; i++)
    #####: 2851:                    *p++ = i < pre_assignment_length ? ztrdup(*q++) : ztrdup("");
    #####: 2852:                for (r = val; *r;) {
        -: 2853:                    /* Give away ownership of the string */
    #####: 2854:                    *p++ = *r++;
        -: 2855:                }
    #####: 2856:                if (v->end < pre_assignment_length)
    #####: 2857:                    for (q = old + v->end; *q;)
    #####: 2858:                        *p++ = ztrdup(*q++);
    #####: 2859:                *p = NULL;
        -: 2860:
    #####: 2861:                v->pm->gsu.a->setfn(v->pm, new);
        -: 2862:            }
        -: 2863:
        -: 2864:	    DPUTS2(p - new != post_assignment_length, "setarrvalue: wrong allocation: %d 1= %lu",
        -: 2865:		   post_assignment_length, (unsigned long)(p - new));
        -: 2866:	}
        -: 2867:
        -: 2868:        /* Ownership of all strings has been
        -: 2869:         * given away, can plainly free */
    #####: 2870:	free(val);
        -: 2871:    }
        -: 2872:}
        -: 2873:
        -: 2874:/* Retrieve an integer parameter */
        -: 2875:
        -: 2876:/**/
        -: 2877:mod_export zlong
        1: 2878:getiparam(char *s)
        -: 2879:{
        -: 2880:    struct value vbuf;
        -: 2881:    Value v;
        -: 2882:
        1: 2883:    if (!(v = getvalue(&vbuf, &s, 1)))
        1: 2884:	return 0;
    #####: 2885:    return getintvalue(v);
        -: 2886:}
        -: 2887:
        -: 2888:/* Retrieve a numerical parameter, either integer or floating */
        -: 2889:
        -: 2890:/**/
        -: 2891:mnumber
    #####: 2892:getnparam(char *s)
        -: 2893:{
        -: 2894:    struct value vbuf;
        -: 2895:    Value v;
        -: 2896:
    #####: 2897:    if (!(v = getvalue(&vbuf, &s, 1))) {
        -: 2898:	mnumber mn;
    #####: 2899:	mn.type = MN_INTEGER;
    #####: 2900:	mn.u.l = 0;
    #####: 2901:	return mn;
        -: 2902:    }
    #####: 2903:    return getnumvalue(v);
        -: 2904:}
        -: 2905:
        -: 2906:/* Retrieve a scalar (string) parameter */
        -: 2907:
        -: 2908:/**/
        -: 2909:mod_export char *
        7: 2910:getsparam(char *s)
        -: 2911:{
        -: 2912:    struct value vbuf;
        -: 2913:    Value v;
        -: 2914:
        7: 2915:    if (!(v = getvalue(&vbuf, &s, 0)))
    #####: 2916:	return NULL;
        7: 2917:    return getstrvalue(v);
        -: 2918:}
        -: 2919:
        -: 2920:/**/
        -: 2921:mod_export char *
    #####: 2922:getsparam_u(char *s)
        -: 2923:{
    #####: 2924:    if ((s = getsparam(s)))
    #####: 2925:	return unmetafy(s, NULL);
    #####: 2926:    return s;
        -: 2927:}
        -: 2928:
        -: 2929:/* Retrieve an array parameter */
        -: 2930:
        -: 2931:/**/
        -: 2932:mod_export char **
        3: 2933:getaparam(char *s)
        -: 2934:{
        -: 2935:    struct value vbuf;
        -: 2936:    Value v;
        -: 2937:
        3: 2938:    if (!idigit(*s) && (v = getvalue(&vbuf, &s, 0)) &&
    #####: 2939:	PM_TYPE(v->pm->node.flags) == PM_ARRAY)
    #####: 2940:	return v->pm->gsu.a->getfn(v->pm);
        3: 2941:    return NULL;
        -: 2942:}
        -: 2943:
        -: 2944:/* Retrieve an assoc array parameter as an array */
        -: 2945:
        -: 2946:/**/
        -: 2947:mod_export char **
    #####: 2948:gethparam(char *s)
        -: 2949:{
        -: 2950:    struct value vbuf;
        -: 2951:    Value v;
        -: 2952:
    #####: 2953:    if (!idigit(*s) && (v = getvalue(&vbuf, &s, 0)) &&
    #####: 2954:	PM_TYPE(v->pm->node.flags) == PM_HASHED)
    #####: 2955:	return paramvalarr(v->pm->gsu.h->getfn(v->pm), SCANPM_WANTVALS);
    #####: 2956:    return NULL;
        -: 2957:}
        -: 2958:
        -: 2959:/* Retrieve the keys of an assoc array parameter as an array */
        -: 2960:
        -: 2961:/**/
        -: 2962:mod_export char **
    #####: 2963:gethkparam(char *s)
        -: 2964:{
        -: 2965:    struct value vbuf;
        -: 2966:    Value v;
        -: 2967:
    #####: 2968:    if (!idigit(*s) && (v = getvalue(&vbuf, &s, 0)) &&
    #####: 2969:	PM_TYPE(v->pm->node.flags) == PM_HASHED)
    #####: 2970:	return paramvalarr(v->pm->gsu.h->getfn(v->pm), SCANPM_WANTKEYS);
    #####: 2971:    return NULL;
        -: 2972:}
        -: 2973:
        -: 2974:/*
        -: 2975: * Function behind WARNCREATEGLOBAL and WARNNESTEDVAR option.
        -: 2976: *
        -: 2977: * For WARNNESTEDVAR:
        -: 2978: * Called when the variable is created.
        -: 2979: * Apply heuristics to see if this variable was just created
        -: 2980: * globally but in a local context.
        -: 2981: *
        -: 2982: * For WARNNESTEDVAR:
        -: 2983: * Called when the variable already exists and is set.
        -: 2984: * Apply heuristics to see if this variable is setting
        -: 2985: * a variable that was created in a less nested function
        -: 2986: * or globally.
        -: 2987: */
        -: 2988:
        -: 2989:/**/
        -: 2990:static void
      171: 2991:check_warn_pm(Param pm, const char *pmtype, int created,
        -: 2992:	      int may_warn_about_nested_vars)
        -: 2993:{
        -: 2994:    Funcstack i;
        -: 2995:
      171: 2996:    if (!may_warn_about_nested_vars && !created)
    #####: 2997:	return;
        -: 2998:
      171: 2999:    if (created && isset(WARNCREATEGLOBAL)) {
    #####: 3000:	if (locallevel <= forklevel || pm->level != 0)
    #####: 3001:	    return;
      171: 3002:    } else if (!created && isset(WARNNESTEDVAR)) {
    #####: 3003:	if (pm->level >= locallevel)
    #####: 3004:	    return;
        -: 3005:    } else
      171: 3006:	return;
        -: 3007:
    #####: 3008:    if (pm->node.flags & PM_SPECIAL)
    #####: 3009:	return;
        -: 3010:
    #####: 3011:    for (i = funcstack; i; i = i->prev) {
    #####: 3012:	if (i->tp == FS_FUNC) {
        -: 3013:	    char *msg;
        -: 3014:	    DPUTS(!i->name, "funcstack entry with no name");
    #####: 3015:	    msg = created ?
    #####: 3016:		"%s parameter %s created globally in function %s" :
        -: 3017:		"%s parameter %s set in enclosing scope in function %s";
    #####: 3018:	    zwarn(msg, pmtype, pm->node.nam, i->name);
    #####: 3019:	    break;
        -: 3020:	}
        -: 3021:    }
        -: 3022:}
        -: 3023:
        -: 3024:/**/
        -: 3025:mod_export Param
      207: 3026:assignsparam(char *s, char *val, int flags)
        -: 3027:{
        -: 3028:    struct value vbuf;
        -: 3029:    Value v;
      207: 3030:    char *t = s;
        -: 3031:    char *ss, *copy, *var;
        -: 3032:    size_t lvar;
        -: 3033:    mnumber lhs, rhs;
      207: 3034:    int sstart, created = 0;
        -: 3035:
      207: 3036:    if (!isident(s)) {
    #####: 3037:	zerr("not an identifier: %s", s);
    #####: 3038:	zsfree(val);
    #####: 3039:	errflag |= ERRFLAG_ERROR;
    #####: 3040:	return NULL;
        -: 3041:    }
      207: 3042:    queue_signals();
      207: 3043:    if ((ss = strchr(s, '['))) {
        1: 3044:	*ss = '\0';
        1: 3045:	if (!(v = getvalue(&vbuf, &s, 1))) {
    #####: 3046:	    createparam(t, PM_ARRAY);
    #####: 3047:	    created = 1;
        -: 3048:	} else {
        1: 3049:	    if (v->pm->node.flags & PM_READONLY) {
    #####: 3050:		zerr("read-only variable: %s", v->pm->node.nam);
    #####: 3051:		*ss = '[';
    #####: 3052:		zsfree(val);
    #####: 3053:		unqueue_signals();
    #####: 3054:		return NULL;
        -: 3055:	    }
        -: 3056:	    /*
        -: 3057:	     * Parameter defined here is a temporary bogus one.
        -: 3058:	     * Don't warn about anything.
        -: 3059:	     */
        1: 3060:	    flags &= ~ASSPM_WARN;
        1: 3061:	    v->pm->node.flags &= ~PM_DEFAULTED;
        -: 3062:	}
        1: 3063:	*ss = '[';
        1: 3064:	v = NULL;
        -: 3065:    } else {
      206: 3066:	if (!(v = getvalue(&vbuf, &s, 1))) {
      148: 3067:	    createparam(t, PM_SCALAR);
      148: 3068:	    created = 1;
      116: 3069:	} else if ((((v->pm->node.flags & PM_ARRAY) && !(flags & ASSPM_AUGMENT)) ||
       58: 3070:	    	 (v->pm->node.flags & PM_HASHED)) &&
    #####: 3071:		 !(v->pm->node.flags & (PM_SPECIAL|PM_TIED)) && 
    #####: 3072:		 unset(KSHARRAYS)) {
    #####: 3073:	    unsetparam(t);
    #####: 3074:	    createparam(t, PM_SCALAR);
        -: 3075:	    /* not regarded as a new creation */
    #####: 3076:	    v = NULL;
        -: 3077:	}
        -: 3078:    }
      207: 3079:    if (!v && !(v = getvalue(&vbuf, &t, 1))) {
    #####: 3080:	unqueue_signals();
    #####: 3081:	zsfree(val);
        -: 3082:	/* errflag |= ERRFLAG_ERROR; */
    #####: 3083:	return NULL;
        -: 3084:    }
      207: 3085:    if (flags & ASSPM_WARN)
      149: 3086:	check_warn_pm(v->pm, "scalar", created, 1);
      207: 3087:    v->pm->node.flags &= ~PM_DEFAULTED;
      207: 3088:    if (flags & ASSPM_AUGMENT) {
    #####: 3089:	if (v->start == 0 && v->end == -1) {
    #####: 3090:	    switch (PM_TYPE(v->pm->node.flags)) {
    #####: 3091:	    case PM_SCALAR:
    #####: 3092:		v->start = INT_MAX;  /* just append to scalar value */
    #####: 3093:		break;
    #####: 3094:	    case PM_INTEGER:
        -: 3095:	    case PM_EFLOAT:
        -: 3096:	    case PM_FFLOAT:
    #####: 3097:		rhs = matheval(val);
    #####: 3098:		lhs = getnumvalue(v);
    #####: 3099:		if (lhs.type == MN_FLOAT) {
    #####: 3100:		    if ((rhs.type) == MN_FLOAT)
    #####: 3101:        		lhs.u.d = lhs.u.d + rhs.u.d;
        -: 3102:		    else
    #####: 3103:			lhs.u.d = lhs.u.d + (double)rhs.u.l;
        -: 3104:		} else {
    #####: 3105:        	    if ((rhs.type) == MN_INTEGER)
    #####: 3106:			lhs.u.l = lhs.u.l + rhs.u.l;
        -: 3107:		    else
    #####: 3108:			lhs.u.l = lhs.u.l + (zlong)rhs.u.d;
        -: 3109:		}
    #####: 3110:		setnumvalue(v, lhs);
    #####: 3111:    	    	unqueue_signals();
    #####: 3112:		zsfree(val);
    #####: 3113:		return v->pm; /* avoid later setstrvalue() call */
    #####: 3114:	    case PM_ARRAY:
    #####: 3115:	    	if (unset(KSHARRAYS)) {
    #####: 3116:		    v->start = arrlen(v->pm->gsu.a->getfn(v->pm));
    #####: 3117:		    v->end = v->start + 1;
        -: 3118:		} else {
        -: 3119:		    /* ksh appends scalar to first element */
    #####: 3120:		    v->end = 1;
    #####: 3121:		    goto kshappend;
        -: 3122:		}
    #####: 3123:		break;
        -: 3124:	    }
    #####: 3125:	} else {
    #####: 3126:	    switch (PM_TYPE(v->pm->node.flags)) {
    #####: 3127:	    case PM_SCALAR:
    #####: 3128:    		if (v->end > 0)
    #####: 3129:		    v->start = v->end;
        -: 3130:		else
    #####: 3131:		    v->start = v->end = strlen(v->pm->gsu.s->getfn(v->pm)) +
    #####: 3132:			v->end + 1;
    #####: 3133:	    	break;
    #####: 3134:	    case PM_INTEGER:
        -: 3135:	    case PM_EFLOAT:
        -: 3136:	    case PM_FFLOAT:
    #####: 3137:		unqueue_signals();
    #####: 3138:		zerr("attempt to add to slice of a numeric variable");
    #####: 3139:		zsfree(val);
    #####: 3140:		return NULL;
        -: 3141:	    case PM_ARRAY:
    #####: 3142:	      kshappend:
        -: 3143:		/* treat slice as the end element */
    #####: 3144:		v->start = sstart = v->end > 0 ? v->end - 1 : v->end;
    #####: 3145:		v->isarr = 0;
    #####: 3146:		var = getstrvalue(v);
    #####: 3147:		v->start = sstart;
    #####: 3148:		copy = val;
    #####: 3149:		lvar = strlen(var);
    #####: 3150:		val = (char *)zalloc(lvar + strlen(val) + 1);
    #####: 3151:		strcpy(val, var);
    #####: 3152:		strcpy(val + lvar, copy);
    #####: 3153:		zsfree(copy);
    #####: 3154:		break;
        -: 3155:	    }
        -: 3156:	}
        -: 3157:    }
        -: 3158:
      207: 3159:    assignstrvalue(v, val, flags);
      207: 3160:    unqueue_signals();
      207: 3161:    return v->pm;
        -: 3162:}
        -: 3163:
        -: 3164:/**/
        -: 3165:mod_export Param
      121: 3166:setsparam(char *s, char *val)
        -: 3167:{
      121: 3168:    return assignsparam(s, val, ASSPM_WARN);
        -: 3169:}
        -: 3170:
        -: 3171:/**/
        -: 3172:mod_export Param
       12: 3173:assignaparam(char *s, char **val, int flags)
        -: 3174:{
        -: 3175:    struct value vbuf;
        -: 3176:    Value v;
       12: 3177:    char *t = s;
        -: 3178:    char *ss;
       12: 3179:    int created = 0;
       12: 3180:    int may_warn_about_nested_vars = 1;
        -: 3181:
       12: 3182:    if (!isident(s)) {
    #####: 3183:	zerr("not an identifier: %s", s);
    #####: 3184:	freearray(val);
    #####: 3185:	errflag |= ERRFLAG_ERROR;
    #####: 3186:	return NULL;
        -: 3187:    }
       12: 3188:    queue_signals();
       12: 3189:    if ((ss = strchr(s, '['))) {
    #####: 3190:	*ss = '\0';
    #####: 3191:	if (!(v = getvalue(&vbuf, &s, 1))) {
    #####: 3192:	    createparam(t, PM_ARRAY);
    #####: 3193:	    created = 1;
        -: 3194:	} else {
    #####: 3195:	    may_warn_about_nested_vars = 0;
        -: 3196:	}
    #####: 3197:	*ss = '[';
    #####: 3198:	if (v && PM_TYPE(v->pm->node.flags) == PM_HASHED) {
    #####: 3199:	    unqueue_signals();
    #####: 3200:	    zerr("%s: attempt to set slice of associative array",
    #####: 3201:		 v->pm->node.nam);
    #####: 3202:	    freearray(val);
    #####: 3203:	    errflag |= ERRFLAG_ERROR;
    #####: 3204:	    return NULL;
        -: 3205:	}
    #####: 3206:	v = NULL;
        -: 3207:    } else {
       12: 3208:	if (!(v = fetchvalue(&vbuf, &s, 1, SCANPM_ASSIGNING))) {
        4: 3209:	    createparam(t, PM_ARRAY);
        4: 3210:	    created = 1;
       11: 3211:	} else if (!(PM_TYPE(v->pm->node.flags) & (PM_ARRAY|PM_HASHED)) &&
        3: 3212:		 !(v->pm->node.flags & (PM_SPECIAL|PM_TIED))) {
        3: 3213:	    int uniq = v->pm->node.flags & PM_UNIQUE;
        3: 3214:	    if (flags & ASSPM_AUGMENT) {
        -: 3215:	    	/* insert old value at the beginning of the val array */
        -: 3216:		char **new;
    #####: 3217:		int lv = arrlen(val);
        -: 3218:
    #####: 3219:		new = (char **) zalloc(sizeof(char *) * (lv + 2));
    #####: 3220:		*new = ztrdup(getstrvalue(v));
    #####: 3221:		memcpy(new+1, val, sizeof(char *) * (lv + 1));
    #####: 3222:		free(val);
    #####: 3223:		val = new;
        -: 3224:	    }
        3: 3225:	    unsetparam(t);
        3: 3226:	    createparam(t, PM_ARRAY | uniq);
        3: 3227:	    v = NULL;
        -: 3228:	}
        -: 3229:    }
       12: 3230:    if (!v)
        7: 3231:	if (!(v = fetchvalue(&vbuf, &t, 1, SCANPM_ASSIGNING))) {
    #####: 3232:	    unqueue_signals();
    #####: 3233:	    freearray(val);
        -: 3234:	    /* errflag |= ERRFLAG_ERROR; */
    #####: 3235:	    return NULL;
        -: 3236:	}
        -: 3237:
       12: 3238:    if (flags & ASSPM_WARN)
       12: 3239:	check_warn_pm(v->pm, "array", created, may_warn_about_nested_vars);
       12: 3240:    v->pm->node.flags &= ~PM_DEFAULTED;
        -: 3241:
        -: 3242:    /*
        -: 3243:     * At this point, we may have array entries consisting of
        -: 3244:     * - a Marker element --- normally allocated array entry but
        -: 3245:     *   with just Marker char and null
        -: 3246:     * - an array index element --- as normal for associative array,
        -: 3247:     *   but non-standard for normal array which we handle now.
        -: 3248:     * - a value for the indexed element.
        -: 3249:     * This only applies if the flag ASSPM_KEY_VALUE is passed in,
        -: 3250:     * indicating prefork() detected this syntax.
        -: 3251:     *
        -: 3252:     * For associative arrays we just junk the Marker elements.
        -: 3253:     */
       12: 3254:    if (flags & ASSPM_KEY_VALUE) {
        -: 3255:	char **aptr;
    #####: 3256:	if (PM_TYPE(v->pm->node.flags) & PM_ARRAY) {
        -: 3257:	    /*
        -: 3258:	     * This is an ordinary array with key / value pairs.
        -: 3259:	     */
        -: 3260:	    int maxlen, origlen, nextind;
        -: 3261:	    char **fullval, **origptr;
    #####: 3262:	    zlong *subscripts = (zlong *)zhalloc(arrlen(val) * sizeof(zlong));
    #####: 3263:	    zlong *iptr = subscripts;
    #####: 3264:	    if (flags & ASSPM_AUGMENT) {
    #####: 3265:		origptr = v->pm->gsu.a->getfn(v->pm);
    #####: 3266:		maxlen = origlen = arrlen(origptr);
        -: 3267:	    } else {
    #####: 3268:		maxlen = origlen = 0;
    #####: 3269:		origptr = NULL;
        -: 3270:	    }
    #####: 3271:	    nextind = 0;
    #####: 3272:	    for (aptr = val; *aptr; ) {
    #####: 3273:		if (**aptr == Marker) {
    #####: 3274:		    *iptr = mathevali(*++aptr);
    #####: 3275:		    if (*iptr < 0 ||
    #####: 3276:			(!isset(KSHARRAYS) && *iptr == 0)) {
    #####: 3277:			unqueue_signals();
    #####: 3278:			zerr("bad subscript for direct array assignment: %s", *aptr);
    #####: 3279:			freearray(val);
    #####: 3280:			return NULL;
        -: 3281:		    }
    #####: 3282:		    if (!isset(KSHARRAYS))
    #####: 3283:			--*iptr;
    #####: 3284:		    nextind = *iptr + 1;
    #####: 3285:		    ++iptr;
    #####: 3286:		    aptr += 2;
        -: 3287:		} else {
    #####: 3288:		    ++nextind;
    #####: 3289:		    ++aptr;
        -: 3290:		}
    #####: 3291:		if (nextind > maxlen)
    #####: 3292:		    maxlen = nextind;
        -: 3293:	    }
    #####: 3294:	    fullval = zshcalloc((maxlen+1) * sizeof(char *));
    #####: 3295:	    if (!fullval) {
    #####: 3296:		zerr("array too large");
    #####: 3297:		freearray(val);
    #####: 3298:		return NULL;
        -: 3299:	    }
    #####: 3300:	    fullval[maxlen] = NULL;
    #####: 3301:	    if (flags & ASSPM_AUGMENT) {
    #####: 3302:		char **srcptr = origptr;
    #####: 3303:		for (aptr = fullval; aptr <= fullval + origlen; aptr++) {
    #####: 3304:		    *aptr = ztrdup(*srcptr);
    #####: 3305:		    srcptr++;
        -: 3306:		}
        -: 3307:	    }
    #####: 3308:	    iptr = subscripts;
    #####: 3309:	    nextind = 0;
    #####: 3310:	    for (aptr = val; *aptr; ++aptr) {
        -: 3311:		char *old;
    #####: 3312:		if (**aptr == Marker) {
    #####: 3313:		    int augment = ((*aptr)[1] == '+');
    #####: 3314:		    zsfree(*aptr);
    #####: 3315:		    zsfree(*++aptr); /* Index, no longer needed */
    #####: 3316:		    old = fullval[*iptr];
    #####: 3317:		    if (augment && old) {
    #####: 3318:			fullval[*iptr] = bicat(old, *++aptr);
    #####: 3319:			zsfree(*aptr);
        -: 3320:		    } else {
    #####: 3321:			fullval[*iptr] = *++aptr;
        -: 3322:		    }
    #####: 3323:		    nextind = *iptr + 1;
    #####: 3324:		    ++iptr;
        -: 3325:		} else {
    #####: 3326:		    old = fullval[nextind];
    #####: 3327:		    fullval[nextind] = *aptr;
    #####: 3328:		    ++nextind;
        -: 3329:		}
    #####: 3330:		if (old)
    #####: 3331:		    zsfree(old);
        -: 3332:		/* aptr now on value in both cases */
        -: 3333:	    }
    #####: 3334:	    if (*aptr) {		/* Shouldn't be possible */
        -: 3335:		DPUTS(1, "Extra element in key / value array");
    #####: 3336:		zsfree(*aptr);
        -: 3337:	    }
    #####: 3338:	    free(val);
    #####: 3339:	    for (aptr = fullval; aptr < fullval + maxlen; aptr++) {
        -: 3340:		/*
        -: 3341:		 * Remember we don't have sparse arrays but and they're null
        -: 3342:		 * terminated --- so any value we don't set has to be an
        -: 3343:		 * empty string.
        -: 3344:		 */
    #####: 3345:		if (!*aptr)
    #####: 3346:		    *aptr = ztrdup("");
        -: 3347:	    }
    #####: 3348:	    setarrvalue(v, fullval);
    #####: 3349:	    unqueue_signals();
    #####: 3350:	    return v->pm;
    #####: 3351:	} else if (PM_TYPE(v->pm->node.flags & PM_HASHED)) {
        -: 3352:	    /*
        -: 3353:	     * We strictly enforce [key]=value syntax for associative
        -: 3354:	     * arrays.  Marker can only indicate a Marker / key / value
        -: 3355:	     * triad; it cannot be there by accident.
        -: 3356:	     *
        -: 3357:	     * It's too inefficient to strip Markers here, and they
        -: 3358:	     * can't be there in the other form --- so just ignore
        -: 3359:	     * them willy nilly lower down.
        -: 3360:	     */
    #####: 3361:	    for (aptr = val; *aptr; aptr += 3) {
    #####: 3362:		if (**aptr != Marker) {
    #####: 3363:		    unqueue_signals();
    #####: 3364:		    freearray(val);
    #####: 3365:		    zerr("bad [key]=value syntax for associative array");
    #####: 3366:		    return NULL;
        -: 3367:		}
        -: 3368:	    }
        -: 3369:	} else {
    #####: 3370:	    unqueue_signals();
    #####: 3371:	    freearray(val);
    #####: 3372:	    zerr("invalid use of [key]=value assignment syntax");
    #####: 3373:	    return NULL;
        -: 3374:	}
        -: 3375:    }
        -: 3376:
       12: 3377:    if (flags & ASSPM_AUGMENT) {
    #####: 3378:    	if (v->start == 0 && v->end == -1) {
    #####: 3379:	    if (PM_TYPE(v->pm->node.flags) & PM_ARRAY) {
    #####: 3380:	    	v->start = arrlen(v->pm->gsu.a->getfn(v->pm));
    #####: 3381:	    	v->end = v->start + 1;
    #####: 3382:	    } else if (PM_TYPE(v->pm->node.flags) & PM_HASHED)
    #####: 3383:	    	v->start = -1, v->end = 0;
        -: 3384:	} else {
    #####: 3385:	    if (v->end > 0)
    #####: 3386:		v->start = v->end--;
    #####: 3387:	    else if (PM_TYPE(v->pm->node.flags) & PM_ARRAY) {
    #####: 3388:		v->end = arrlen(v->pm->gsu.a->getfn(v->pm)) + v->end;
    #####: 3389:		v->start = v->end + 1;
        -: 3390:	    }
        -: 3391:	}
        -: 3392:    }
        -: 3393:
       12: 3394:    setarrvalue(v, val);
       12: 3395:    unqueue_signals();
       12: 3396:    return v->pm;
        -: 3397:}
        -: 3398:
        -: 3399:
        -: 3400:/**/
        -: 3401:mod_export Param
        5: 3402:setaparam(char *s, char **aval)
        -: 3403:{
        5: 3404:    return assignaparam(s, aval, ASSPM_WARN);
        -: 3405:}
        -: 3406:
        -: 3407:/**/
        -: 3408:mod_export Param
    #####: 3409:sethparam(char *s, char **val)
        -: 3410:{
        -: 3411:    struct value vbuf;
        -: 3412:    Value v;
    #####: 3413:    char *t = s;
    #####: 3414:    int checkcreate = 0;
        -: 3415:
    #####: 3416:    if (!isident(s)) {
    #####: 3417:	zerr("not an identifier: %s", s);
    #####: 3418:	freearray(val);
    #####: 3419:	errflag |= ERRFLAG_ERROR;
    #####: 3420:	return NULL;
        -: 3421:    }
    #####: 3422:    if (strchr(s, '[')) {
    #####: 3423:	freearray(val);
    #####: 3424:	zerr("nested associative arrays not yet supported");
    #####: 3425:	errflag |= ERRFLAG_ERROR;
    #####: 3426:	return NULL;
        -: 3427:    }
    #####: 3428:    if (unset(EXECOPT))
    #####: 3429:	return NULL;
    #####: 3430:    queue_signals();
    #####: 3431:    if (!(v = fetchvalue(&vbuf, &s, 1, SCANPM_ASSIGNING))) {
    #####: 3432:	createparam(t, PM_HASHED);
    #####: 3433:	checkcreate = 1;
    #####: 3434:    } else if (!(PM_TYPE(v->pm->node.flags) & PM_HASHED)) {
    #####: 3435:	if (!(v->pm->node.flags & PM_SPECIAL)) {
    #####: 3436:	    unsetparam(t);
        -: 3437:	    /* no WARNCREATEGLOBAL check here as parameter already existed */
    #####: 3438:	    createparam(t, PM_HASHED);
    #####: 3439:	    v = NULL;
        -: 3440:	} else {
    #####: 3441:	    zerr("%s: can't change type of a special parameter", t);
    #####: 3442:	    unqueue_signals();
    #####: 3443:	    return NULL;
        -: 3444:	}
        -: 3445:    }
    #####: 3446:    if (!v)
    #####: 3447:	if (!(v = fetchvalue(&vbuf, &t, 1, SCANPM_ASSIGNING))) {
    #####: 3448:	    unqueue_signals();
        -: 3449:	    /* errflag |= ERRFLAG_ERROR; */
    #####: 3450:	    return NULL;
        -: 3451:	}
    #####: 3452:    check_warn_pm(v->pm, "associative array", checkcreate, 1);
    #####: 3453:    v->pm->node.flags &= ~PM_DEFAULTED;
    #####: 3454:    setarrvalue(v, val);
    #####: 3455:    unqueue_signals();
    #####: 3456:    return v->pm;
        -: 3457:}
        -: 3458:
        -: 3459:
        -: 3460:/*
        -: 3461: * Set a generic shell number, floating point or integer.
        -: 3462: * Option to warn on setting.
        -: 3463: */
        -: 3464:
        -: 3465:/**/
        -: 3466:mod_export Param
       10: 3467:assignnparam(char *s, mnumber val, int flags)
        -: 3468:{
        -: 3469:    struct value vbuf;
        -: 3470:    Value v;
       10: 3471:    char *t = s, *ss;
        -: 3472:    Param pm;
       10: 3473:    int was_unset = 0;
        -: 3474:
       10: 3475:    if (!isident(s)) {
    #####: 3476:	zerr("not an identifier: %s", s);
    #####: 3477:	errflag |= ERRFLAG_ERROR;
    #####: 3478:	return NULL;
        -: 3479:    }
       10: 3480:    if (unset(EXECOPT))
    #####: 3481:	return NULL;
       10: 3482:    queue_signals();
       10: 3483:    ss = strchr(s, '[');
       10: 3484:    v = getvalue(&vbuf, &s, 1);
       10: 3485:    if (v && (v->pm->node.flags & (PM_ARRAY|PM_HASHED)) &&
    #####: 3486:	!(v->pm->node.flags & (PM_SPECIAL|PM_TIED)) &&
        -: 3487:	/*
        -: 3488:	 * not sure what KSHARRAYS has got to do with this...
        -: 3489:	 * copied this from assignsparam().
        -: 3490:	 */
    #####: 3491:	unset(KSHARRAYS) && !ss) {
    #####: 3492:	unsetparam_pm(v->pm, 0, 1);
    #####: 3493:	was_unset = 1;
    #####: 3494:	s = t;
    #####: 3495:	v = NULL;
        -: 3496:    }
       10: 3497:    if (!v) {
        -: 3498:	/* s has been updated by getvalue, so check again */
       10: 3499:	ss = strchr(s, '[');
       10: 3500:	if (ss)
    #####: 3501:	    *ss = '\0';
       20: 3502:	pm = createparam(t, ss ? PM_ARRAY :
       20: 3503:			 isset(POSIXIDENTIFIERS) ? PM_SCALAR :
       10: 3504:			 (val.type & MN_INTEGER) ? PM_INTEGER : PM_FFLOAT);
       10: 3505:	if (!pm)
    #####: 3506:	    pm = (Param) paramtab->getnode(paramtab, t);
        -: 3507:	DPUTS(!pm, "BUG: parameter not created");
       10: 3508:	if (ss) {
    #####: 3509:	    *ss = '[';
       10: 3510:	} else if (val.type & MN_INTEGER) {
       10: 3511:	    pm->base = outputradix;
        -: 3512:	}
       10: 3513:	if (!(v = getvalue(&vbuf, &t, 1))) {
        -: 3514:	    DPUTS(!v, "BUG: value not found for new parameter");
        -: 3515:	    /* errflag |= ERRFLAG_ERROR; */
    #####: 3516:	    unqueue_signals();
    #####: 3517:	    return NULL;
        -: 3518:	}
       10: 3519:	if (flags & ASSPM_WARN)
       10: 3520:	    check_warn_pm(v->pm, "numeric", !was_unset, 1);
        -: 3521:    } else {
    #####: 3522:	if (flags & ASSPM_WARN)
    #####: 3523:	    check_warn_pm(v->pm, "numeric", 0, 1);
        -: 3524:    }
       10: 3525:    v->pm->node.flags &= ~PM_DEFAULTED;
       10: 3526:    setnumvalue(v, val);
       10: 3527:    unqueue_signals();
       10: 3528:    return v->pm;
        -: 3529:}
        -: 3530:
        -: 3531:/*
        -: 3532: * Set a generic shell number, floating point or integer.
        -: 3533: * Warn on setting based on option.
        -: 3534: */
        -: 3535:
        -: 3536:/**/
        -: 3537:mod_export Param
    #####: 3538:setnparam(char *s, mnumber val)
        -: 3539:{
    #####: 3540:    return assignnparam(s, val, ASSPM_WARN);
        -: 3541:}
        -: 3542:
        -: 3543:/* Simplified interface to assignnparam */
        -: 3544:
        -: 3545:/**/
        -: 3546:mod_export Param
    #####: 3547:assigniparam(char *s, zlong val, int flags)
        -: 3548:{
        -: 3549:    mnumber mnval;
    #####: 3550:    mnval.type = MN_INTEGER;
    #####: 3551:    mnval.u.l = val;
    #####: 3552:    return assignnparam(s, mnval, flags);
        -: 3553:}
        -: 3554:
        -: 3555:/* Simplified interface to setnparam */
        -: 3556:
        -: 3557:/**/
        -: 3558:mod_export Param
       10: 3559:setiparam(char *s, zlong val)
        -: 3560:{
        -: 3561:    mnumber mnval;
       10: 3562:    mnval.type = MN_INTEGER;
       10: 3563:    mnval.u.l = val;
       10: 3564:    return assignnparam(s, mnval, ASSPM_WARN);
        -: 3565:}
        -: 3566:
        -: 3567:/*
        -: 3568: * Set an integer parameter without forcing creation of an integer type.
        -: 3569: * This is useful if the integer is going to be set to a parameter which
        -: 3570: * would usually be scalar but may not exist.
        -: 3571: */
        -: 3572:
        -: 3573:/**/
        -: 3574:mod_export Param
    #####: 3575:setiparam_no_convert(char *s, zlong val)
        -: 3576:{
        -: 3577:    /*
        -: 3578:     * If the target is already an integer, thisgets converted
        -: 3579:     * back.  Low technology rules.
        -: 3580:     */
        -: 3581:    char buf[BDIGBUFSIZE];
    #####: 3582:    convbase(buf, val, 10);
    #####: 3583:    return assignsparam(s, ztrdup(buf), ASSPM_WARN);
        -: 3584:}
        -: 3585:
        -: 3586:/* Unset a parameter */
        -: 3587:
        -: 3588:/**/
        -: 3589:mod_export void
        3: 3590:unsetparam(char *s)
        -: 3591:{
        -: 3592:    Param pm;
        -: 3593:
        3: 3594:    queue_signals();
        6: 3595:    if ((pm = (Param) (paramtab == realparamtab ?
        -: 3596:		       /* getnode2() to avoid autoloading */
        3: 3597:		       paramtab->getnode2(paramtab, s) :
    #####: 3598:		       paramtab->getnode(paramtab, s))))
        3: 3599:	unsetparam_pm(pm, 0, 1);
        3: 3600:    unqueue_signals();
        3: 3601:}
        -: 3602:
        -: 3603:/* Unset a parameter
        -: 3604: *
        -: 3605: * altflag: if true, don't remove pm->ename from the environment
        -: 3606: * exp: See stdunsetfn()
        -: 3607: */
        -: 3608:
        -: 3609:/**/
        -: 3610:mod_export int
       43: 3611:unsetparam_pm(Param pm, int altflag, int exp)
        -: 3612:{
        -: 3613:    Param oldpm, altpm;
        -: 3614:    char *altremove;
        -: 3615:
       43: 3616:    if ((pm->node.flags & PM_READONLY) && pm->level <= locallevel) {
    #####: 3617:	zerr("read-only variable: %s", pm->node.nam);
    #####: 3618:	return 1;
        -: 3619:    }
       43: 3620:    if ((pm->node.flags & PM_RESTRICTED) && isset(RESTRICTED)) {
    #####: 3621:	zerr("%s: restricted", pm->node.nam);
    #####: 3622:	return 1;
        -: 3623:    }
        -: 3624:
       43: 3625:    if (pm->ename && !altflag)
    #####: 3626:	altremove = ztrdup(pm->ename);
        -: 3627:    else
       43: 3628:	altremove = NULL;
        -: 3629:
       43: 3630:    pm->node.flags &= ~PM_DECLARED;	/* like ksh, not like bash */
       43: 3631:    if (!(pm->node.flags & PM_UNSET))
       43: 3632:	pm->gsu.s->unsetfn(pm, exp);
       43: 3633:    if (pm->env)
    #####: 3634:	delenv(pm);
        -: 3635:
        -: 3636:    /* remove it under its alternate name if necessary */
       43: 3637:    if (altremove) {
    #####: 3638:	altpm = (Param) paramtab->getnode(paramtab, altremove);
        -: 3639:	/* tied parameters are at the same local level as each other */
    #####: 3640:	oldpm = NULL;
        -: 3641:	/*
        -: 3642:	 * Look for param under alternate name hidden by a local.
        -: 3643:	 * If this parameter is special, however, the visible
        -: 3644:	 * parameter is the special and the hidden one is keeping
        -: 3645:	 * an old value --- we just mark the visible one as unset.
        -: 3646:	 */
    #####: 3647:	if (altpm && !(altpm->node.flags & PM_SPECIAL))
        -: 3648:	{
    #####: 3649:	    while (altpm && altpm->level > pm->level) {
    #####: 3650:		oldpm = altpm;
    #####: 3651:		altpm = altpm->old;
        -: 3652:	    }
        -: 3653:	}
    #####: 3654:	if (altpm) {
    #####: 3655:	    if (oldpm && !altpm->level) {
    #####: 3656:		oldpm->old = NULL;
        -: 3657:		/* fudge things so removenode isn't called */
    #####: 3658:		altpm->level = 1;
        -: 3659:	    }
    #####: 3660:	    unsetparam_pm(altpm, 1, exp);
        -: 3661:	}
        -: 3662:
    #####: 3663:	zsfree(altremove);
    #####: 3664:	if (!(pm->node.flags & PM_SPECIAL))
    #####: 3665:	    pm->gsu.s = &stdscalar_gsu;
        -: 3666:    }
        -: 3667:
        -: 3668:    /*
        -: 3669:     * If this was a local variable, we need to keep the old
        -: 3670:     * struct so that it is resurrected at the right level.
        -: 3671:     * This is partly because when an array/scalar value is set
        -: 3672:     * and the parameter used to be the other sort, unsetparam()
        -: 3673:     * is called.  Beyond that, there is an ambiguity:  should
        -: 3674:     * foo() { local bar; unset bar; } make the global bar
        -: 3675:     * available or not?  The following makes the answer "no".
        -: 3676:     *
        -: 3677:     * Some specials, such as those used in zle, still need removing
        -: 3678:     * from the parameter table; they have the PM_REMOVABLE flag.
        -: 3679:     */
       83: 3680:    if ((pm->level && locallevel >= pm->level) ||
       40: 3681:	(pm->node.flags & (PM_SPECIAL|PM_REMOVABLE)) == PM_SPECIAL)
        3: 3682:	return 0;
        -: 3683:
        -: 3684:    /* remove parameter node from table */
       40: 3685:    paramtab->removenode(paramtab, pm->node.nam);
        -: 3686:
       40: 3687:    if (pm->old) {
    #####: 3688:	oldpm = pm->old;
    #####: 3689:	paramtab->addnode(paramtab, oldpm->node.nam, oldpm);
    #####: 3690:	if ((PM_TYPE(oldpm->node.flags) == PM_SCALAR) &&
    #####: 3691:	    !(pm->node.flags & PM_HASHELEM) &&
    #####: 3692:	    (oldpm->node.flags & PM_NAMEDDIR) &&
    #####: 3693:	    oldpm->gsu.s == &stdscalar_gsu)
    #####: 3694:	    adduserdir(oldpm->node.nam, oldpm->u.str, 0, 0);
    #####: 3695:	if (oldpm->node.flags & PM_EXPORTED) {
        -: 3696:	    /*
        -: 3697:	     * Re-export the old value which we removed in typeset_single().
        -: 3698:	     * I don't think we need to test for ALL_EXPORT here, since if
        -: 3699:	     * it was used to export the parameter originally the parameter
        -: 3700:	     * should still have the PM_EXPORTED flag.
        -: 3701:	     */
    #####: 3702:	    export_param(oldpm);
        -: 3703:	}
        -: 3704:    }
        -: 3705:
       40: 3706:    paramtab->freenode(&pm->node); /* free parameter node */
        -: 3707:
       40: 3708:    return 0;
        -: 3709:}
        -: 3710:
        -: 3711:/* Standard function to unset a parameter.  This is mostly delegated to *
        -: 3712: * the specific set function.
        -: 3713: *
        -: 3714: * This could usefully be made type-specific, but then we need
        -: 3715: * to be more careful when calling the unset method directly.
        -: 3716: *
        -: 3717: * The "exp"licit parameter should be nonzero for assignments and the
        -: 3718: * unset command, and zero for implicit unset (e.g., end of scope).
        -: 3719: * Currently this is used only by some modules.
        -: 3720: */
        -: 3721:
        -: 3722:/**/
        -: 3723:mod_export void
      437: 3724:stdunsetfn(Param pm, UNUSED(int exp))
        -: 3725:{
      437: 3726:    switch (PM_TYPE(pm->node.flags)) {
      434: 3727:	case PM_SCALAR:
      434: 3728:	    if (pm->gsu.s->setfn)
      434: 3729:		pm->gsu.s->setfn(pm, NULL);
      434: 3730:	    break;
        -: 3731:
        3: 3732:	case PM_ARRAY:
        3: 3733:	    if (pm->gsu.a->setfn)
        3: 3734:		pm->gsu.a->setfn(pm, NULL);
        3: 3735:	    break;
        -: 3736:
    #####: 3737:	case PM_HASHED:
    #####: 3738:	    if (pm->gsu.h->setfn)
    #####: 3739:		pm->gsu.h->setfn(pm, NULL);
    #####: 3740:	    break;
        -: 3741:
    #####: 3742:	default:
    #####: 3743:	    if (!(pm->node.flags & PM_SPECIAL))
    #####: 3744:	    	pm->u.str = NULL;
    #####: 3745:	    break;
        -: 3746:    }
      437: 3747:    if ((pm->node.flags & (PM_SPECIAL|PM_TIED)) == PM_TIED) {
    #####: 3748:	if (pm->ename) {
    #####: 3749:	    zsfree(pm->ename);
    #####: 3750:	    pm->ename = NULL;
        -: 3751:	}
    #####: 3752:	pm->node.flags &= ~PM_TIED;
        -: 3753:    }
      437: 3754:    pm->node.flags |= PM_UNSET;
      437: 3755:}
        -: 3756:
        -: 3757:/* Function to get value of an integer parameter */
        -: 3758:
        -: 3759:/**/
        -: 3760:mod_export zlong
       22: 3761:intgetfn(Param pm)
        -: 3762:{
       22: 3763:    return pm->u.val;
        -: 3764:}
        -: 3765:
        -: 3766:/* Function to set value of an integer parameter */
        -: 3767:
        -: 3768:/**/
        -: 3769:static void
       17: 3770:intsetfn(Param pm, zlong x)
        -: 3771:{
       17: 3772:    pm->u.val = x;
       17: 3773:}
        -: 3774:
        -: 3775:/* Function to get value of a floating point parameter */
        -: 3776:
        -: 3777:/**/
        -: 3778:static double
    #####: 3779:floatgetfn(Param pm)
        -: 3780:{
    #####: 3781:    return pm->u.dval;
        -: 3782:}
        -: 3783:
        -: 3784:/* Function to set value of an integer parameter */
        -: 3785:
        -: 3786:/**/
        -: 3787:static void
    #####: 3788:floatsetfn(Param pm, double x)
        -: 3789:{
    #####: 3790:    pm->u.dval = x;
    #####: 3791:}
        -: 3792:
        -: 3793:/* Function to get value of a scalar (string) parameter */
        -: 3794:
        -: 3795:/**/
        -: 3796:mod_export char *
     1107: 3797:strgetfn(Param pm)
        -: 3798:{
     1107: 3799:    return pm->u.str ? pm->u.str : (char *) hcalloc(1);
        -: 3800:}
        -: 3801:
        -: 3802:/* Function to set value of a scalar (string) parameter */
        -: 3803:
        -: 3804:/**/
        -: 3805:mod_export void
     1014: 3806:strsetfn(Param pm, char *x)
        -: 3807:{
     1014: 3808:    zsfree(pm->u.str);
     1014: 3809:    pm->u.str = x;
     1236: 3810:    if (!(pm->node.flags & PM_HASHELEM) &&
      444: 3811:	((pm->node.flags & PM_NAMEDDIR) || isset(AUTONAMEDIRS))) {
    #####: 3812:	pm->node.flags |= PM_NAMEDDIR;
    #####: 3813:	adduserdir(pm->node.nam, x, 0, 0);
        -: 3814:    }
        -: 3815:    /* If you update this function, you may need to update the
        -: 3816:     * `Implement remainder of strsetfn' block in assignstrvalue(). */
     1014: 3817:}
        -: 3818:
        -: 3819:/* Function to get value of an array parameter */
        -: 3820:
        -: 3821:static char *nullarray = NULL;
        -: 3822:
        -: 3823:/**/
        -: 3824:char **
        4: 3825:arrgetfn(Param pm)
        -: 3826:{
        4: 3827:    return pm->u.arr ? pm->u.arr : &nullarray;
        -: 3828:}
        -: 3829:
        -: 3830:/* Function to set value of an array parameter */
        -: 3831:
        -: 3832:/**/
        -: 3833:mod_export void
       11: 3834:arrsetfn(Param pm, char **x)
        -: 3835:{
       11: 3836:    if (pm->u.arr && pm->u.arr != x)
        4: 3837:	freearray(pm->u.arr);
       11: 3838:    if (pm->node.flags & PM_UNIQUE)
    #####: 3839:	uniqarray(x);
       11: 3840:    pm->u.arr = x;
        -: 3841:    /* Arrays tied to colon-arrays may need to fix the environment */
       11: 3842:    if (pm->ename && x)
    #####: 3843:	arrfixenv(pm->ename, x);
        -: 3844:    /* If you extend this function, update the list of conditions in
        -: 3845:     * setarrvalue(). */
       11: 3846:}
        -: 3847:
        -: 3848:/* Function to get value of an association parameter */
        -: 3849:
        -: 3850:/**/
        -: 3851:mod_export HashTable
        7: 3852:hashgetfn(Param pm)
        -: 3853:{
        7: 3854:    return pm->u.hash;
        -: 3855:}
        -: 3856:
        -: 3857:/* Function to set value of an association parameter */
        -: 3858:
        -: 3859:/**/
        -: 3860:mod_export void
        1: 3861:hashsetfn(Param pm, HashTable x)
        -: 3862:{
        1: 3863:    if (pm->u.hash && pm->u.hash != x)
    #####: 3864:	deleteparamtable(pm->u.hash);
        1: 3865:    pm->u.hash = x;
        1: 3866:}
        -: 3867:
        -: 3868:/* Function to dispose of setting of an unsettable hash */
        -: 3869:
        -: 3870:/**/
        -: 3871:mod_export void
    #####: 3872:nullsethashfn(UNUSED(Param pm), HashTable x)
        -: 3873:{
    #####: 3874:    deleteparamtable(x);
    #####: 3875:}
        -: 3876:
        -: 3877:/* Function to set value of an association parameter using key/value pairs */
        -: 3878:
        -: 3879:/**/
        -: 3880:static void
        3: 3881:arrhashsetfn(Param pm, char **val, int flags)
        -: 3882:{
        -: 3883:    /* Best not to shortcut this by using the existing hash table,   *
        -: 3884:     * since that could cause trouble for special hashes.  This way, *
        -: 3885:     * it's up to pm->gsu.h->setfn() what to do.                     */
        3: 3886:    int alen = 0;
        3: 3887:    HashTable opmtab = paramtab, ht = 0;
        -: 3888:    char **aptr;
        3: 3889:    Value v = (Value) hcalloc(sizeof *v);
        3: 3890:    v->end = -1;
        -: 3891:
      797: 3892:    for (aptr = val; *aptr; ++aptr) {
      794: 3893:	if (**aptr != Marker)
      794: 3894:	    ++alen;
        -: 3895:    }
        -: 3896:
        3: 3897:    if (alen % 2) {
    #####: 3898:	freearray(val);
    #####: 3899:	zerr("bad set of key/value pairs for associative array");
    #####: 3900:	return;
        -: 3901:    }
        3: 3902:    if (flags & ASSPM_AUGMENT) {
    #####: 3903:	ht = paramtab = pm->gsu.h->getfn(pm);
        -: 3904:    }
        3: 3905:    if (alen && (!(flags & ASSPM_AUGMENT) || !paramtab)) {
        3: 3906:	ht = paramtab = newparamtable(17, pm->node.nam);
        -: 3907:    }
      403: 3908:    for (aptr = val; *aptr; ) {
      397: 3909:	int eltflags = 0;
      397: 3910:	if (**aptr == Marker) {
        -: 3911:	    /* Either all elements have Marker or none. Checked in caller. */
    #####: 3912:	    if ((*aptr)[1] == '+') {
        -: 3913:		/* Actually, assignstrvalue currently doesn't handle this... */
    #####: 3914:		eltflags = ASSPM_AUGMENT;
        -: 3915:		/* ...so we'll use the trick from setsparam(). */
    #####: 3916:		v->start = INT_MAX;
        -: 3917:	    } else {
    #####: 3918:		v->start = 0;
        -: 3919:	    }
    #####: 3920:	    v->end = -1;
    #####: 3921:	    zsfree(*aptr++);
        -: 3922:	}
        -: 3923:	/* The parameter name is ztrdup'd... */
      397: 3924:	v->pm = createparam(*aptr, PM_SCALAR|PM_UNSET);
        -: 3925:	/*
        -: 3926:	 * createparam() doesn't return anything if the parameter
        -: 3927:	 * already existed.
        -: 3928:	 */
      397: 3929:	if (!v->pm)
    #####: 3930:	    v->pm = (Param) paramtab->getnode(paramtab, *aptr);
      397: 3931:	zsfree(*aptr++);
        -: 3932:	/* ...but we can use the value without copying. */
      397: 3933:	assignstrvalue(v, *aptr++, eltflags);
        -: 3934:    }
        3: 3935:    paramtab = opmtab;
        3: 3936:    pm->gsu.h->setfn(pm, ht);
        3: 3937:    free(val);		/* not freearray() */
        -: 3938:}
        -: 3939:
        -: 3940:/*
        -: 3941: * These functions are used as the set function for special parameters that
        -: 3942: * cannot be set by the user.  The set is incomplete as the only such
        -: 3943: * parameters are scalar and integer.
        -: 3944: */
        -: 3945:
        -: 3946:/**/
        -: 3947:mod_export void
    #####: 3948:nullstrsetfn(UNUSED(Param pm), char *x)
        -: 3949:{
    #####: 3950:    zsfree(x);
    #####: 3951:}
        -: 3952:
        -: 3953:/**/
        -: 3954:mod_export void
    #####: 3955:nullintsetfn(UNUSED(Param pm), UNUSED(zlong x))
    #####: 3956:{}
        -: 3957:
        -: 3958:/**/
        -: 3959:mod_export void
    #####: 3960:nullunsetfn(UNUSED(Param pm), UNUSED(int exp))
    #####: 3961:{}
        -: 3962:
        -: 3963:
        -: 3964:/* Function to get value of generic special integer *
        -: 3965: * parameter.  data is pointer to global variable   *
        -: 3966: * containing the integer value.                    */
        -: 3967:
        -: 3968:/**/
        -: 3969:mod_export zlong
        5: 3970:intvargetfn(Param pm)
        -: 3971:{
        5: 3972:    return *pm->u.valptr;
        -: 3973:}
        -: 3974:
        -: 3975:/* Function to set value of generic special integer *
        -: 3976: * parameter.  data is pointer to global variable   *
        -: 3977: * where the value is to be stored.                 */
        -: 3978:
        -: 3979:/**/
        -: 3980:mod_export void
        2: 3981:intvarsetfn(Param pm, zlong x)
        -: 3982:{
        2: 3983:    *pm->u.valptr = x;
        2: 3984:}
        -: 3985:
        -: 3986:/* Function to set value of any ZLE-related integer *
        -: 3987: * parameter.  data is pointer to global variable   *
        -: 3988: * where the value is to be stored.                 */
        -: 3989:
        -: 3990:/**/
        -: 3991:void
    #####: 3992:zlevarsetfn(Param pm, zlong x)
        -: 3993:{
    #####: 3994:    zlong *p = pm->u.valptr;
        -: 3995:
    #####: 3996:    *p = x;
    #####: 3997:    if (p == &zterm_lines || p == &zterm_columns)
    #####: 3998:	adjustwinsize(2 + (p == &zterm_columns));
    #####: 3999:}
        -: 4000:
        -: 4001:
        -: 4002:/* Implements gsu_integer.unsetfn for ZLE_RPROMPT_INDENT; see stdunsetfn() */
        -: 4003:
        -: 4004:static void
    #####: 4005:rprompt_indent_unsetfn(Param pm, int exp)
        -: 4006:{
    #####: 4007:    stdunsetfn(pm, exp);
    #####: 4008:    rprompt_indent = 1; /* Keep this in sync with init_term() */
    #####: 4009:}
        -: 4010:
        -: 4011:/* Function to set value of generic special scalar    *
        -: 4012: * parameter.  data is pointer to a character pointer *
        -: 4013: * representing the scalar (string).                  */
        -: 4014:
        -: 4015:/**/
        -: 4016:mod_export void
    #####: 4017:strvarsetfn(Param pm, char *x)
        -: 4018:{
    #####: 4019:    char **q = ((char **)pm->u.data);
        -: 4020:
    #####: 4021:    zsfree(*q);
    #####: 4022:    *q = x;
    #####: 4023:}
        -: 4024:
        -: 4025:/* Function to get value of generic special scalar    *
        -: 4026: * parameter.  data is pointer to a character pointer *
        -: 4027: * representing the scalar (string).                  */
        -: 4028:
        -: 4029:/**/
        -: 4030:mod_export char *
    #####: 4031:strvargetfn(Param pm)
        -: 4032:{
    #####: 4033:    char *s = *((char **)pm->u.data);
        -: 4034:
    #####: 4035:    if (!s)
    #####: 4036:	return hcalloc(1);
    #####: 4037:    return s;
        -: 4038:}
        -: 4039:
        -: 4040:/* Function to get value of generic special array  *
        -: 4041: * parameter.  data is a pointer to the pointer to *
        -: 4042: * a pointer (a pointer to a variable length array *
        -: 4043: * of pointers).                                   */
        -: 4044:
        -: 4045:/**/
        -: 4046:mod_export char **
       12: 4047:arrvargetfn(Param pm)
        -: 4048:{
       12: 4049:    char **arrptr = *((char ***)pm->u.data);
        -: 4050:
       12: 4051:    return arrptr ? arrptr : &nullarray;
        -: 4052:}
        -: 4053:
        -: 4054:/* Function to set value of generic special array parameter.    *
        -: 4055: * data is pointer to a variable length array of pointers which *
        -: 4056: * represents this array of scalars (strings).  If pm->ename is *
        -: 4057: * non NULL, then it is a colon separated environment variable  *
        -: 4058: * version of this array which will need to be updated.         */
        -: 4059:
        -: 4060:/**/
        -: 4061:mod_export void
        1: 4062:arrvarsetfn(Param pm, char **x)
        -: 4063:{
        1: 4064:    char ***dptr = (char ***)pm->u.data;
        -: 4065:
        1: 4066:    if (*dptr != x)
        1: 4067:	freearray(*dptr);
        1: 4068:    if (pm->node.flags & PM_UNIQUE)
    #####: 4069:	uniqarray(x);
        -: 4070:    /*
        -: 4071:     * Special tied arrays point to variables accessible in other
        -: 4072:     * ways which need to be set to NULL.  We can't do this
        -: 4073:     * with user tied variables since we can leak memory.
        -: 4074:     */
        1: 4075:    if ((pm->node.flags & PM_SPECIAL) && !x)
    #####: 4076:	*dptr = mkarray(NULL);
        -: 4077:    else
        1: 4078:	*dptr = x;
        1: 4079:    if (pm->ename) {
        1: 4080:	if (x)
        1: 4081:	    arrfixenv(pm->ename, x);
    #####: 4082:	else if (*dptr == path)
    #####: 4083:	    pathchecked = path;
        -: 4084:    }
        1: 4085:}
        -: 4086:
        -: 4087:/**/
        -: 4088:char *
        3: 4089:colonarrgetfn(Param pm)
        -: 4090:{
        3: 4091:    char ***dptr = (char ***)pm->u.data;
        3: 4092:    return *dptr ? zjoin(*dptr, ':', 1) : "";
        -: 4093:}
        -: 4094:
        -: 4095:/**/
        -: 4096:void
        2: 4097:colonarrsetfn(Param pm, char *x)
        -: 4098:{
        2: 4099:    char ***dptr = (char ***)pm->u.data;
        -: 4100:    /*
        -: 4101:     * We have to make sure this is never NULL, since that
        -: 4102:     * can cause problems.
        -: 4103:     */
        2: 4104:    if (*dptr)
        2: 4105:	freearray(*dptr);
        2: 4106:    if (x)
        2: 4107:	*dptr = colonsplit(x, pm->node.flags & PM_UNIQUE);
        -: 4108:    else
    #####: 4109:	*dptr = mkarray(NULL);
        2: 4110:    arrfixenv(pm->node.nam, *dptr);
        2: 4111:    zsfree(x);
        2: 4112:}
        -: 4113:
        -: 4114:/**/
        -: 4115:char *
    #####: 4116:tiedarrgetfn(Param pm)
        -: 4117:{
    #####: 4118:    struct tieddata *dptr = (struct tieddata *)pm->u.data;
    #####: 4119:    return *dptr->arrptr ? zjoin(*dptr->arrptr, STOUC(dptr->joinchar), 1) : "";
        -: 4120:}
        -: 4121:
        -: 4122:/**/
        -: 4123:void
    #####: 4124:tiedarrsetfn(Param pm, char *x)
        -: 4125:{
    #####: 4126:    struct tieddata *dptr = (struct tieddata *)pm->u.data;
        -: 4127:
    #####: 4128:    if (*dptr->arrptr)
    #####: 4129:	freearray(*dptr->arrptr);
    #####: 4130:    else if (pm->ename) {
    #####: 4131:	Param altpm = (Param) paramtab->getnode(paramtab, pm->ename);
    #####: 4132:	if (altpm)
    #####: 4133:	    altpm->node.flags &= ~PM_DEFAULTED;
        -: 4134:    }
    #####: 4135:    if (x) {
        -: 4136:	char sepbuf[3];
    #####: 4137:	if (imeta(dptr->joinchar))
        -: 4138:	{
    #####: 4139:	    sepbuf[0] = Meta;
    #####: 4140:	    sepbuf[1] = dptr->joinchar ^ 32;
    #####: 4141:	    sepbuf[2] = '\0';
        -: 4142:	}
        -: 4143:	else
        -: 4144:	{
    #####: 4145:	    sepbuf[0] = dptr->joinchar;
    #####: 4146:	    sepbuf[1] = '\0';
        -: 4147:	}
    #####: 4148:	*dptr->arrptr = sepsplit(x, sepbuf, 0, 0);
    #####: 4149:	if (pm->node.flags & PM_UNIQUE)
    #####: 4150:	    uniqarray(*dptr->arrptr);
    #####: 4151:	zsfree(x);
        -: 4152:    } else
    #####: 4153:	*dptr->arrptr = NULL;
    #####: 4154:    if (pm->ename)
    #####: 4155:	arrfixenv(pm->node.nam, *dptr->arrptr);
    #####: 4156:}
        -: 4157:
        -: 4158:/**/
        -: 4159:void
    #####: 4160:tiedarrunsetfn(Param pm, UNUSED(int exp))
        -: 4161:{
        -: 4162:    /*
        -: 4163:     * Special unset function because we allocated a struct tieddata
        -: 4164:     * in typeset_single to hold the special data which we now
        -: 4165:     * need to delete.
        -: 4166:     */
    #####: 4167:    pm->gsu.s->setfn(pm, NULL);
    #####: 4168:    zfree(pm->u.data, sizeof(struct tieddata));
        -: 4169:    /* paranoia -- shouldn't need these, but in case we reuse the struct... */
    #####: 4170:    pm->u.data = NULL;
    #####: 4171:    zsfree(pm->ename);
    #####: 4172:    pm->ename = NULL;
    #####: 4173:    pm->node.flags &= ~PM_TIED;
    #####: 4174:    pm->node.flags |= PM_UNSET;
    #####: 4175:}
        -: 4176:
        -: 4177:/**/
        -: 4178:static void
    #####: 4179:simple_arrayuniq(char **x, int freeok)
        -: 4180:{
    #####: 4181:    char **t, **p = x;
    #####: 4182:    char *hole = "";
        -: 4183:
        -: 4184:    /* Find duplicates and replace them with holes */
    #####: 4185:    while (*++p)
    #####: 4186:	for (t = x; t < p; t++)
    #####: 4187:	    if (*t != hole && !strcmp(*p, *t)) {
    #####: 4188:		if (freeok)
    #####: 4189:		    zsfree(*p);
    #####: 4190:		*p = hole;
    #####: 4191:		break;
        -: 4192:	    }
        -: 4193:    /* Swap non-holes into holes in optimal jumps */
    #####: 4194:    for (p = t = x; *t != NULL; t++) {
    #####: 4195:	if (*t == hole) {
    #####: 4196:	    while (*p == hole)
    #####: 4197:		++p;
    #####: 4198:	    if ((*t = *p) != NULL)
    #####: 4199:		*p++ = hole;
    #####: 4200:	} else if (p == t)
    #####: 4201:	    p++;
        -: 4202:    }
        -: 4203:    /* Erase all the remaining holes, just in case */
    #####: 4204:    while (++t < p)
    #####: 4205:	*t = NULL;
    #####: 4206:}
        -: 4207:
        -: 4208:/**/
        -: 4209:static void
    #####: 4210:arrayuniq_freenode(HashNode hn)
        -: 4211:{
        -: 4212:    (void)hn;
    #####: 4213:}
        -: 4214:
        -: 4215:/**/
        -: 4216:HashTable
    #####: 4217:newuniqtable(zlong size)
        -: 4218:{
    #####: 4219:    HashTable ht = newhashtable((int)size, "arrayuniq", NULL);
        -: 4220:    /* ??? error checking */
        -: 4221:
    #####: 4222:    ht->hash        = hasher;
    #####: 4223:    ht->emptytable  = emptyhashtable;
    #####: 4224:    ht->filltable   = NULL;
    #####: 4225:    ht->cmpnodes    = strcmp;
    #####: 4226:    ht->addnode     = addhashnode;
    #####: 4227:    ht->getnode     = gethashnode2;
    #####: 4228:    ht->getnode2    = gethashnode2;
    #####: 4229:    ht->removenode  = removehashnode;
    #####: 4230:    ht->disablenode = disablehashnode;
    #####: 4231:    ht->enablenode  = enablehashnode;
    #####: 4232:    ht->freenode    = arrayuniq_freenode;
    #####: 4233:    ht->printnode   = NULL;
        -: 4234:
    #####: 4235:    return ht;
        -: 4236:}
        -: 4237:
        -: 4238:/**/
        -: 4239:static void
    #####: 4240:arrayuniq(char **x, int freeok)
        -: 4241:{
        -: 4242:    char **it, **write_it;
    #####: 4243:    zlong array_size = arrlen(x);
        -: 4244:    HashTable ht;
        -: 4245:
    #####: 4246:    if (array_size == 0)
    #####: 4247:	return;
    #####: 4248:    if (array_size < 10 || !(ht = newuniqtable(array_size + 1))) {
        -: 4249:	/* fallback to simpler routine */
    #####: 4250:	simple_arrayuniq(x, freeok);
    #####: 4251:	return;
        -: 4252:    }
        -: 4253:
    #####: 4254:    for (it = x, write_it = x; *it;) {
    #####: 4255:	if (! gethashnode2(ht, *it)) {
    #####: 4256:	    HashNode new_node = zhalloc(sizeof(struct hashnode));
    #####: 4257:	    if (!new_node) {
        -: 4258:		/* Oops, out of heap memory, no way to recover */
    #####: 4259:		zerr("out of memory in arrayuniq");
    #####: 4260:		break;
        -: 4261:	    }
    #####: 4262:	    (void) addhashnode2(ht, *it, new_node);
    #####: 4263:	    *write_it = *it;
    #####: 4264:	    if (it != write_it)
    #####: 4265:		*it = NULL;
    #####: 4266:	    ++write_it;
        -: 4267:	}
        -: 4268:	else {
    #####: 4269:	    if (freeok)
    #####: 4270:		zsfree(*it);
    #####: 4271:	    *it = NULL;
        -: 4272:	}
    #####: 4273:	++it;
        -: 4274:    }
        -: 4275:    
    #####: 4276:    deletehashtable(ht);
        -: 4277:}
        -: 4278:
        -: 4279:/**/
        -: 4280:void
    #####: 4281:uniqarray(char **x)
        -: 4282:{
    #####: 4283:    if (!x || !*x)
    #####: 4284:	return;
    #####: 4285:    arrayuniq(x, !zheapptr(*x));
        -: 4286:}
        -: 4287:
        -: 4288:/**/
        -: 4289:void
    #####: 4290:zhuniqarray(char **x)
        -: 4291:{
    #####: 4292:    if (!x || !*x)
    #####: 4293:	return;
    #####: 4294:    arrayuniq(x, 0);
        -: 4295:}
        -: 4296:
        -: 4297:/* Function to get value of special parameter `#' and `ARGC' */
        -: 4298:
        -: 4299:/**/
        -: 4300:zlong
        1: 4301:poundgetfn(UNUSED(Param pm))
        -: 4302:{
        1: 4303:    return arrlen(pparams);
        -: 4304:}
        -: 4305:
        -: 4306:/* Function to get value for special parameter `RANDOM' */
        -: 4307:
        -: 4308:/**/
        -: 4309:zlong
    #####: 4310:randomgetfn(UNUSED(Param pm))
        -: 4311:{
    #####: 4312:    return rand() & 0x7fff;
        -: 4313:}
        -: 4314:
        -: 4315:/* Function to set value of special parameter `RANDOM' */
        -: 4316:
        -: 4317:/**/
        -: 4318:void
    #####: 4319:randomsetfn(UNUSED(Param pm), zlong v)
        -: 4320:{
    #####: 4321:    srand((unsigned int)v);
    #####: 4322:}
        -: 4323:
        -: 4324:/* Function to get value for special parameter `SECONDS' */
        -: 4325:
        -: 4326:/**/
        -: 4327:zlong
    #####: 4328:intsecondsgetfn(UNUSED(Param pm))
        -: 4329:{
        -: 4330:    struct timeval now;
        -: 4331:    struct timezone dummy_tz;
        -: 4332:
    #####: 4333:    gettimeofday(&now, &dummy_tz);
        -: 4334:
    #####: 4335:    return (zlong)(now.tv_sec - shtimer.tv_sec -
    #####: 4336:		  (now.tv_usec < shtimer.tv_usec ? 1 : 0));
        -: 4337:}
        -: 4338:
        -: 4339:/* Function to set value of special parameter `SECONDS' */
        -: 4340:
        -: 4341:/**/
        -: 4342:void
    #####: 4343:intsecondssetfn(UNUSED(Param pm), zlong x)
        -: 4344:{
        -: 4345:    struct timeval now;
        -: 4346:    struct timezone dummy_tz;
        -: 4347:    zlong diff;
        -: 4348:
    #####: 4349:    gettimeofday(&now, &dummy_tz);
    #####: 4350:    diff = (zlong)now.tv_sec - x;
    #####: 4351:    shtimer.tv_sec = diff;
    #####: 4352:    if ((zlong)shtimer.tv_sec != diff)
    #####: 4353:	zwarn("SECONDS truncated on assignment");
    #####: 4354:    shtimer.tv_usec = now.tv_usec;
    #####: 4355:}
        -: 4356:
        -: 4357:/**/
        -: 4358:double
    #####: 4359:floatsecondsgetfn(UNUSED(Param pm))
        -: 4360:{
        -: 4361:    struct timeval now;
        -: 4362:    struct timezone dummy_tz;
        -: 4363:
    #####: 4364:    gettimeofday(&now, &dummy_tz);
        -: 4365:
    #####: 4366:    return (double)(now.tv_sec - shtimer.tv_sec) +
    #####: 4367:	(double)(now.tv_usec - shtimer.tv_usec) / 1000000.0;
        -: 4368:}
        -: 4369:
        -: 4370:/**/
        -: 4371:void
    #####: 4372:floatsecondssetfn(UNUSED(Param pm), double x)
        -: 4373:{
        -: 4374:    struct timeval now;
        -: 4375:    struct timezone dummy_tz;
        -: 4376:
    #####: 4377:    gettimeofday(&now, &dummy_tz);
    #####: 4378:    shtimer.tv_sec = now.tv_sec - (zlong)x;
    #####: 4379:    shtimer.tv_usec = now.tv_usec - (zlong)((x - (zlong)x) * 1000000.0);
    #####: 4380:}
        -: 4381:
        -: 4382:/**/
        -: 4383:double
    #####: 4384:getrawseconds(void)
        -: 4385:{
    #####: 4386:    return (double)shtimer.tv_sec + (double)shtimer.tv_usec / 1000000.0;
        -: 4387:}
        -: 4388:
        -: 4389:/**/
        -: 4390:void
    #####: 4391:setrawseconds(double x)
        -: 4392:{
    #####: 4393:    shtimer.tv_sec = (zlong)x;
    #####: 4394:    shtimer.tv_usec = (zlong)((x - (zlong)x) * 1000000.0);
    #####: 4395:}
        -: 4396:
        -: 4397:/**/
        -: 4398:int
    #####: 4399:setsecondstype(Param pm, int on, int off)
        -: 4400:{
    #####: 4401:    int newflags = (pm->node.flags | on) & ~off;
    #####: 4402:    int tp = PM_TYPE(newflags);
        -: 4403:    /* Only one of the numeric types is allowed. */
    #####: 4404:    if (tp == PM_EFLOAT || tp == PM_FFLOAT)
        -: 4405:    {
    #####: 4406:	pm->gsu.f = &floatseconds_gsu;
        -: 4407:    }
    #####: 4408:    else if (tp == PM_INTEGER)
        -: 4409:    {
    #####: 4410:	pm->gsu.i = &intseconds_gsu;
        -: 4411:    }
        -: 4412:    else
    #####: 4413:	return 1;
    #####: 4414:    pm->node.flags = newflags;
    #####: 4415:    return 0;
        -: 4416:}
        -: 4417:
        -: 4418:/* Function to get value for special parameter `USERNAME' */
        -: 4419:
        -: 4420:/**/
        -: 4421:char *
    #####: 4422:usernamegetfn(UNUSED(Param pm))
        -: 4423:{
    #####: 4424:    return get_username();
        -: 4425:}
        -: 4426:
        -: 4427:/* Function to set value of special parameter `USERNAME' */
        -: 4428:
        -: 4429:/**/
        -: 4430:void
    #####: 4431:usernamesetfn(UNUSED(Param pm), char *x)
        -: 4432:{
        -: 4433:#if defined(HAVE_SETUID) && defined(HAVE_GETPWNAM)
        -: 4434:    struct passwd *pswd;
        -: 4435:
    #####: 4436:    if (x && (pswd = getpwnam(x)) && (pswd->pw_uid != cached_uid)) {
        -: 4437:# ifdef USE_INITGROUPS
    #####: 4438:	initgroups(x, pswd->pw_gid);
        -: 4439:# endif
    #####: 4440:	if (setgid(pswd->pw_gid))
    #####: 4441:	    zwarn("failed to change group ID: %e", errno);
    #####: 4442:	else if (setuid(pswd->pw_uid))
    #####: 4443:	    zwarn("failed to change user ID: %e", errno);
        -: 4444:	else {
    #####: 4445:	    zsfree(cached_username);
    #####: 4446:	    cached_username = ztrdup(pswd->pw_name);
    #####: 4447:	    cached_uid = pswd->pw_uid;
        -: 4448:	}
        -: 4449:    }
        -: 4450:#endif /* HAVE_SETUID && HAVE_GETPWNAM */
    #####: 4451:    zsfree(x);
    #####: 4452:}
        -: 4453:
        -: 4454:/* Function to get value for special parameter `UID' */
        -: 4455:
        -: 4456:/**/
        -: 4457:zlong
    #####: 4458:uidgetfn(UNUSED(Param pm))
        -: 4459:{
    #####: 4460:    return getuid();
        -: 4461:}
        -: 4462:
        -: 4463:/* Function to set value of special parameter `UID' */
        -: 4464:
        -: 4465:/**/
        -: 4466:void
    #####: 4467:uidsetfn(UNUSED(Param pm), zlong x)
        -: 4468:{
        -: 4469:#ifdef HAVE_SETUID
    #####: 4470:    if (setuid((uid_t)x))
    #####: 4471:	zerr("failed to change user ID: %e", errno);
        -: 4472:#endif
    #####: 4473:}
        -: 4474:
        -: 4475:/* Function to get value for special parameter `EUID' */
        -: 4476:
        -: 4477:/**/
        -: 4478:zlong
    #####: 4479:euidgetfn(UNUSED(Param pm))
        -: 4480:{
    #####: 4481:    return geteuid();
        -: 4482:}
        -: 4483:
        -: 4484:/* Function to set value of special parameter `EUID' */
        -: 4485:
        -: 4486:/**/
        -: 4487:void
    #####: 4488:euidsetfn(UNUSED(Param pm), zlong x)
        -: 4489:{
        -: 4490:#ifdef HAVE_SETEUID
    #####: 4491:    if (seteuid((uid_t)x))
    #####: 4492:	zerr("failed to change effective user ID: %e", errno);
        -: 4493:#endif
    #####: 4494:}
        -: 4495:
        -: 4496:/* Function to get value for special parameter `GID' */
        -: 4497:
        -: 4498:/**/
        -: 4499:zlong
    #####: 4500:gidgetfn(UNUSED(Param pm))
        -: 4501:{
    #####: 4502:    return getgid();
        -: 4503:}
        -: 4504:
        -: 4505:/* Function to set value of special parameter `GID' */
        -: 4506:
        -: 4507:/**/
        -: 4508:void
    #####: 4509:gidsetfn(UNUSED(Param pm), zlong x)
        -: 4510:{
        -: 4511:#ifdef HAVE_SETUID
    #####: 4512:    if (setgid((gid_t)x))
    #####: 4513:	zerr("failed to change group ID: %e", errno);
        -: 4514:#endif
    #####: 4515:}
        -: 4516:
        -: 4517:/* Function to get value for special parameter `EGID' */
        -: 4518:
        -: 4519:/**/
        -: 4520:zlong
    #####: 4521:egidgetfn(UNUSED(Param pm))
        -: 4522:{
    #####: 4523:    return getegid();
        -: 4524:}
        -: 4525:
        -: 4526:/* Function to set value of special parameter `EGID' */
        -: 4527:
        -: 4528:/**/
        -: 4529:void
    #####: 4530:egidsetfn(UNUSED(Param pm), zlong x)
        -: 4531:{
        -: 4532:#ifdef HAVE_SETEUID
    #####: 4533:    if (setegid((gid_t)x))
    #####: 4534:	zerr("failed to change effective group ID: %e", errno);
        -: 4535:#endif
    #####: 4536:}
        -: 4537:
        -: 4538:/**/
        -: 4539:zlong
    #####: 4540:ttyidlegetfn(UNUSED(Param pm))
        -: 4541:{
        -: 4542:    struct stat ttystat;
        -: 4543:
    #####: 4544:    if (SHTTY == -1 || fstat(SHTTY, &ttystat))
    #####: 4545:	return -1;
    #####: 4546:    return time(NULL) - ttystat.st_atime;
        -: 4547:}
        -: 4548:
        -: 4549:/* Function to get value for special parameter `IFS' */
        -: 4550:
        -: 4551:/**/
        -: 4552:char *
       12: 4553:ifsgetfn(UNUSED(Param pm))
        -: 4554:{
       12: 4555:    return ifs;
        -: 4556:}
        -: 4557:
        -: 4558:/* Function to set value of special parameter `IFS' */
        -: 4559:
        -: 4560:/**/
        -: 4561:void
       24: 4562:ifssetfn(UNUSED(Param pm), char *x)
        -: 4563:{
       24: 4564:    zsfree(ifs);
       24: 4565:    ifs = x;
       24: 4566:    inittyptab();
       24: 4567:}
        -: 4568:
        -: 4569:/* Functions to set value of special parameters `LANG' and `LC_*' */
        -: 4570:
        -: 4571:#ifdef USE_LOCALE
        -: 4572:static struct localename {
        -: 4573:    char *name;
        -: 4574:    int category;
        -: 4575:} lc_names[] = {
        -: 4576:#ifdef LC_COLLATE
        -: 4577:    {"LC_COLLATE", LC_COLLATE},
        -: 4578:#endif
        -: 4579:#ifdef LC_CTYPE
        -: 4580:    {"LC_CTYPE", LC_CTYPE},
        -: 4581:#endif
        -: 4582:#ifdef LC_MESSAGES
        -: 4583:    {"LC_MESSAGES", LC_MESSAGES},
        -: 4584:#endif
        -: 4585:#ifdef LC_NUMERIC
        -: 4586:    {"LC_NUMERIC", LC_NUMERIC},
        -: 4587:#endif
        -: 4588:#ifdef LC_TIME
        -: 4589:    {"LC_TIME", LC_TIME},
        -: 4590:#endif
        -: 4591:    {NULL, 0}
        -: 4592:};
        -: 4593:
        -: 4594:/**/
        -: 4595:static void
    #####: 4596:setlang(char *x)
        -: 4597:{
        -: 4598:    struct localename *ln;
        -: 4599:    char *x2;
        -: 4600:
    #####: 4601:    if ((x2 = getsparam_u("LC_ALL")) && *x2)
    #####: 4602:	return;
        -: 4603:
        -: 4604:    /*
        -: 4605:     * Set the global locale to the value passed, but override
        -: 4606:     * this with any non-empty definitions for specific
        -: 4607:     * categories.
        -: 4608:     *
        -: 4609:     * We only use non-empty definitions because empty values aren't
        -: 4610:     * valid as locales; when passed to setlocale() they mean "use the
        -: 4611:     * environment variable", but if that's what we're setting the value
        -: 4612:     * from this is meaningless.  So just all $LANG to show through in
        -: 4613:     * that case.
        -: 4614:     */
    #####: 4615:    setlocale(LC_ALL, x ? unmeta(x) : "");
    #####: 4616:    queue_signals();
    #####: 4617:    for (ln = lc_names; ln->name; ln++)
    #####: 4618:	if ((x = getsparam_u(ln->name)) && *x)
    #####: 4619:	    setlocale(ln->category, x);
    #####: 4620:    unqueue_signals();
        -: 4621:}
        -: 4622:
        -: 4623:/**/
        -: 4624:void
    #####: 4625:lc_allsetfn(Param pm, char *x)
        -: 4626:{
    #####: 4627:    strsetfn(pm, x);
        -: 4628:    /*
        -: 4629:     * Treat an empty LC_ALL the same as an unset one,
        -: 4630:     * namely by using LANG as the default locale but overriding
        -: 4631:     * that with any LC_* that are set.
        -: 4632:     */
    #####: 4633:    if (!x || !*x) {
    #####: 4634:	x = getsparam_u("LANG");
    #####: 4635:	if (x && *x) {
    #####: 4636:	    queue_signals();
    #####: 4637:	    setlang(x);
    #####: 4638:	    unqueue_signals();
        -: 4639:	}
        -: 4640:    }
        -: 4641:    else
    #####: 4642:	setlocale(LC_ALL, unmeta(x));
    #####: 4643:}
        -: 4644:
        -: 4645:/**/
        -: 4646:void
    #####: 4647:langsetfn(Param pm, char *x)
        -: 4648:{
    #####: 4649:    strsetfn(pm, x);
    #####: 4650:    setlang(unmeta(x));
    #####: 4651:}
        -: 4652:
        -: 4653:/**/
        -: 4654:void
    #####: 4655:lcsetfn(Param pm, char *x)
        -: 4656:{
        -: 4657:    char *x2;
        -: 4658:    struct localename *ln;
        -: 4659:
    #####: 4660:    strsetfn(pm, x);
    #####: 4661:    if ((x2 = getsparam("LC_ALL")) && *x2)
    #####: 4662:	return;
    #####: 4663:    queue_signals();
        -: 4664:    /* Treat empty LC_* the same as unset. */
    #####: 4665:    if (!x || !*x)
    #####: 4666:	x = getsparam("LANG");
        -: 4667:
        -: 4668:    /*
        -: 4669:     * If we've got no non-empty string at this
        -: 4670:     * point (after checking $LANG, too),
        -: 4671:     * we shouldn't bother setting anything.
        -: 4672:     */
    #####: 4673:    if (x && *x) {
    #####: 4674:	for (ln = lc_names; ln->name; ln++)
    #####: 4675:	    if (!strcmp(ln->name, pm->node.nam))
    #####: 4676:		setlocale(ln->category, unmeta(x));
        -: 4677:    }
    #####: 4678:    unqueue_signals();
        -: 4679:}
        -: 4680:#endif /* USE_LOCALE */
        -: 4681:
        -: 4682:/* Function to set value for special parameter `0' */
        -: 4683:
        -: 4684:/**/
        -: 4685:static void
    #####: 4686:argzerosetfn(UNUSED(Param pm), char *x)
        -: 4687:{
    #####: 4688:    if (x) {
    #####: 4689:	if (isset(POSIXARGZERO))
    #####: 4690:	    zerr("read-only variable: 0");
        -: 4691:	else {
    #####: 4692:	    zsfree(argzero);
    #####: 4693:	    argzero = ztrdup(x);
        -: 4694:	}
    #####: 4695:	zsfree(x);
        -: 4696:    }
    #####: 4697:}
        -: 4698:
        -: 4699:/* Function to get value for special parameter `0' */
        -: 4700:
        -: 4701:/**/
        -: 4702:static char *
        2: 4703:argzerogetfn(UNUSED(Param pm))
        -: 4704:{
        2: 4705:    if (isset(POSIXARGZERO))
    #####: 4706:	return posixzero;
        2: 4707:    return argzero;
        -: 4708:}
        -: 4709:
        -: 4710:/* Function to get value for special parameter `HISTSIZE' */
        -: 4711:
        -: 4712:/**/
        -: 4713:zlong
    #####: 4714:histsizegetfn(UNUSED(Param pm))
        -: 4715:{
    #####: 4716:    return histsiz;
        -: 4717:}
        -: 4718:
        -: 4719:/* Function to set value of special parameter `HISTSIZE' */
        -: 4720:
        -: 4721:/**/
        -: 4722:void
    #####: 4723:histsizesetfn(UNUSED(Param pm), zlong v)
        -: 4724:{
    #####: 4725:    if ((histsiz = v) < 1)
    #####: 4726:	histsiz = 1;
    #####: 4727:    resizehistents();
    #####: 4728:}
        -: 4729:
        -: 4730:/* Function to get value for special parameter `SAVEHIST' */
        -: 4731:
        -: 4732:/**/
        -: 4733:zlong
    #####: 4734:savehistsizegetfn(UNUSED(Param pm))
        -: 4735:{
    #####: 4736:    return savehistsiz;
        -: 4737:}
        -: 4738:
        -: 4739:/* Function to set value of special parameter `SAVEHIST' */
        -: 4740:
        -: 4741:/**/
        -: 4742:void
    #####: 4743:savehistsizesetfn(UNUSED(Param pm), zlong v)
        -: 4744:{
    #####: 4745:    if ((savehistsiz = v) < 0)
    #####: 4746:	savehistsiz = 0;
    #####: 4747:}
        -: 4748:
        -: 4749:/* Function to set value for special parameter `ERRNO' */
        -: 4750:
        -: 4751:/**/
        -: 4752:void
    #####: 4753:errnosetfn(UNUSED(Param pm), zlong x)
        -: 4754:{
    #####: 4755:    errno = (int)x;
    #####: 4756:    if ((zlong)errno != x)
    #####: 4757:	zwarn("errno truncated on assignment");
    #####: 4758:}
        -: 4759:
        -: 4760:/* Function to get value for special parameter `ERRNO' */
        -: 4761:
        -: 4762:/**/
        -: 4763:zlong
    #####: 4764:errnogetfn(UNUSED(Param pm))
        -: 4765:{
    #####: 4766:    return errno;
        -: 4767:}
        -: 4768:
        -: 4769:/* Function to get value for special parameter `KEYBOARD_HACK' */
        -: 4770:
        -: 4771:/**/
        -: 4772:char *
    #####: 4773:keyboardhackgetfn(UNUSED(Param pm))
        -: 4774:{
        -: 4775:    static char buf[2];
        -: 4776:
    #####: 4777:    buf[0] = keyboardhackchar;
    #####: 4778:    buf[1] = '\0';
    #####: 4779:    return buf;
        -: 4780:}
        -: 4781:
        -: 4782:
        -: 4783:/* Function to set value of special parameter `KEYBOARD_HACK' */
        -: 4784:
        -: 4785:/**/
        -: 4786:void
    #####: 4787:keyboardhacksetfn(UNUSED(Param pm), char *x)
        -: 4788:{
    #####: 4789:    if (x) {
        -: 4790:	int len, i;
        -: 4791:
    #####: 4792:	unmetafy(x, &len);
    #####: 4793:	if (len > 1) {
    #####: 4794:	    len = 1;
    #####: 4795:	    zwarn("Only one KEYBOARD_HACK character can be defined");  /* could be changed if needed */
        -: 4796:	}
    #####: 4797:	for (i = 0; i < len; i++) {
    #####: 4798:	    if (!isascii(STOUC(x[i]))) {
    #####: 4799:		zwarn("KEYBOARD_HACK can only contain ASCII characters");
    #####: 4800:		return;
        -: 4801:	    }
        -: 4802:	}
    #####: 4803:	keyboardhackchar = len ? STOUC(x[0]) : '\0';
    #####: 4804:	free(x);
        -: 4805:    } else
    #####: 4806:	keyboardhackchar = '\0';
        -: 4807:}
        -: 4808:
        -: 4809:/* Function to get value for special parameter `histchar' */
        -: 4810:
        -: 4811:/**/
        -: 4812:char *
    #####: 4813:histcharsgetfn(UNUSED(Param pm))
        -: 4814:{
        -: 4815:    static char buf[4];
        -: 4816:
    #####: 4817:    buf[0] = bangchar;
    #####: 4818:    buf[1] = hatchar;
    #####: 4819:    buf[2] = hashchar;
    #####: 4820:    buf[3] = '\0';
    #####: 4821:    return buf;
        -: 4822:}
        -: 4823:
        -: 4824:/* Function to set value of special parameter `histchar' */
        -: 4825:
        -: 4826:/**/
        -: 4827:void
    #####: 4828:histcharssetfn(UNUSED(Param pm), char *x)
        -: 4829:{
    #####: 4830:    if (x) {
        -: 4831:	int len, i;
        -: 4832:
    #####: 4833:	unmetafy(x, &len);
    #####: 4834:	if (len > 3)
    #####: 4835:	    len = 3;
    #####: 4836:	for (i = 0; i < len; i++) {
    #####: 4837:	    if (!isascii(STOUC(x[i]))) {
    #####: 4838:		zwarn("HISTCHARS can only contain ASCII characters");
    #####: 4839:		return;
        -: 4840:	    }
        -: 4841:	}
    #####: 4842:	bangchar = len ? STOUC(x[0]) : '\0';
    #####: 4843:	hatchar =  len > 1 ? STOUC(x[1]) : '\0';
    #####: 4844:	hashchar = len > 2 ? STOUC(x[2]) : '\0';
    #####: 4845:	free(x);
        -: 4846:    } else {
    #####: 4847:	bangchar = '!';
    #####: 4848:	hashchar = '#';
    #####: 4849:	hatchar = '^';
        -: 4850:    }
    #####: 4851:    inittyptab();
        -: 4852:}
        -: 4853:
        -: 4854:/* Function to get value for special parameter `HOME' */
        -: 4855:
        -: 4856:/**/
        -: 4857:char *
        2: 4858:homegetfn(UNUSED(Param pm))
        -: 4859:{
        2: 4860:    return home;
        -: 4861:}
        -: 4862:
        -: 4863:/* Function to set value of special parameter `HOME' */
        -: 4864:
        -: 4865:/**/
        -: 4866:void
        2: 4867:homesetfn(UNUSED(Param pm), char *x)
        -: 4868:{
        2: 4869:    zsfree(home);
        2: 4870:    if (x && isset(CHASELINKS) && (home = xsymlink(x, 0)))
    #####: 4871:	zsfree(x);
        -: 4872:    else
        2: 4873:	home = x ? x : ztrdup("");
        2: 4874:    finddir(NULL);
        2: 4875:}
        -: 4876:
        -: 4877:/* Function to get value for special parameter `WORDCHARS' */
        -: 4878:
        -: 4879:/**/
        -: 4880:char *
    #####: 4881:wordcharsgetfn(UNUSED(Param pm))
        -: 4882:{
    #####: 4883:    return wordchars;
        -: 4884:}
        -: 4885:
        -: 4886:/* Function to set value of special parameter `WORDCHARS' */
        -: 4887:
        -: 4888:/**/
        -: 4889:void
    #####: 4890:wordcharssetfn(UNUSED(Param pm), char *x)
        -: 4891:{
    #####: 4892:    zsfree(wordchars);
    #####: 4893:    wordchars = x;
    #####: 4894:    inittyptab();
    #####: 4895:}
        -: 4896:
        -: 4897:/* Function to get value for special parameter `_' */
        -: 4898:
        -: 4899:/**/
        -: 4900:char *
    #####: 4901:underscoregetfn(UNUSED(Param pm))
        -: 4902:{
    #####: 4903:    char *u = dupstring(zunderscore);
        -: 4904:
    #####: 4905:    untokenize(u);
    #####: 4906:    return u;
        -: 4907:}
        -: 4908:
        -: 4909:/* Function used when we need to reinitialise the terminal */
        -: 4910:
        -: 4911:static void
    #####: 4912:term_reinit_from_pm(void)
        -: 4913:{
        -: 4914:    /* If non-interactive, delay setting up term till we need it. */
    #####: 4915:    if (unset(INTERACTIVE) || !*term)
    #####: 4916:	termflags |= TERM_UNKNOWN;
        -: 4917:    else
    #####: 4918:	init_term();
    #####: 4919:}
        -: 4920:
        -: 4921:/* Function to get value for special parameter `TERM' */
        -: 4922:
        -: 4923:/**/
        -: 4924:char *
    #####: 4925:termgetfn(UNUSED(Param pm))
        -: 4926:{
    #####: 4927:    return term;
        -: 4928:}
        -: 4929:
        -: 4930:/* Function to set value of special parameter `TERM' */
        -: 4931:
        -: 4932:/**/
        -: 4933:void
    #####: 4934:termsetfn(UNUSED(Param pm), char *x)
        -: 4935:{
    #####: 4936:    zsfree(term);
    #####: 4937:    term = x ? x : ztrdup("");
    #####: 4938:    term_reinit_from_pm();
    #####: 4939:}
        -: 4940:
        -: 4941:/* Function to get value of special parameter `TERMINFO' */
        -: 4942:
        -: 4943:/**/
        -: 4944:char *
    #####: 4945:terminfogetfn(UNUSED(Param pm))
        -: 4946:{
    #####: 4947:    return zsh_terminfo ? zsh_terminfo : dupstring("");
        -: 4948:}
        -: 4949:
        -: 4950:/* Function to set value of special parameter `TERMINFO' */
        -: 4951:
        -: 4952:/**/
        -: 4953:void
    #####: 4954:terminfosetfn(Param pm, char *x)
        -: 4955:{
    #####: 4956:    zsfree(zsh_terminfo);
    #####: 4957:    zsh_terminfo = x;
        -: 4958:
        -: 4959:    /*
        -: 4960:     * terminfo relies on the value being exported before
        -: 4961:     * we reinitialise the terminal.  This is a bit inefficient.
        -: 4962:     */
    #####: 4963:    if ((pm->node.flags & PM_EXPORTED) && x)
    #####: 4964:	addenv(pm, x);
        -: 4965:
    #####: 4966:    term_reinit_from_pm();
    #####: 4967:}
        -: 4968:
        -: 4969:/* Function to get value of special parameter `TERMINFO_DIRS' */
        -: 4970:
        -: 4971:/**/
        -: 4972:char *
    #####: 4973:terminfodirsgetfn(UNUSED(Param pm))
        -: 4974:{
    #####: 4975:    return zsh_terminfodirs ? zsh_terminfodirs : dupstring("");
        -: 4976:}
        -: 4977:
        -: 4978:/* Function to set value of special parameter `TERMINFO_DIRS' */
        -: 4979:
        -: 4980:/**/
        -: 4981:void
    #####: 4982:terminfodirssetfn(Param pm, char *x)
        -: 4983:{
    #####: 4984:    zsfree(zsh_terminfodirs);
    #####: 4985:    zsh_terminfodirs = x;
        -: 4986:
        -: 4987:    /*
        -: 4988:     * terminfo relies on the value being exported before
        -: 4989:     * we reinitialise the terminal.  This is a bit inefficient.
        -: 4990:     */
    #####: 4991:    if ((pm->node.flags & PM_EXPORTED) && x)
    #####: 4992:	addenv(pm, x);
        -: 4993:
    #####: 4994:    term_reinit_from_pm();
    #####: 4995:}
        -: 4996:/* Function to get value for special parameter `pipestatus' */
        -: 4997:
        -: 4998:/**/
        -: 4999:static char **
    #####: 5000:pipestatgetfn(UNUSED(Param pm))
        -: 5001:{
    #####: 5002:    char **x = (char **) zhalloc((numpipestats + 1) * sizeof(char *));
        -: 5003:    char buf[DIGBUFSIZE], **p;
        -: 5004:    int *q, i;
        -: 5005:
    #####: 5006:    for (p = x, q = pipestats, i = numpipestats; i--; p++, q++) {
    #####: 5007:	sprintf(buf, "%d", *q);
    #####: 5008:	*p = dupstring(buf);
        -: 5009:    }
    #####: 5010:    *p = NULL;
        -: 5011:
    #####: 5012:    return x;
        -: 5013:}
        -: 5014:
        -: 5015:/* Function to get value for special parameter `pipestatus' */
        -: 5016:
        -: 5017:/**/
        -: 5018:static void
    #####: 5019:pipestatsetfn(UNUSED(Param pm), char **x)
        -: 5020:{
    #####: 5021:    if (x) {
        -: 5022:        int i;
        -: 5023:
    #####: 5024:        for (i = 0; *x && i < MAX_PIPESTATS; i++, x++)
    #####: 5025:            pipestats[i] = atoi(*x);
    #####: 5026:        numpipestats = i;
        -: 5027:    }
        -: 5028:    else
    #####: 5029:        numpipestats = 0;
    #####: 5030:}
        -: 5031:
        -: 5032:/**/
        -: 5033:void
        3: 5034:arrfixenv(char *s, char **t)
        -: 5035:{
        -: 5036:    Param pm;
        -: 5037:    int joinchar;
        -: 5038:
        3: 5039:    if (t == path)
        2: 5040:	cmdnamtab->emptytable(cmdnamtab);
        -: 5041:
        3: 5042:    pm = (Param) paramtab->getnode(paramtab, s);
        -: 5043:    
        -: 5044:    /*
        -: 5045:     * Only one level of a parameter can be exported.  Unless
        -: 5046:     * ALLEXPORT is set, this must be global.
        -: 5047:     */
        -: 5048:
        3: 5049:    if (pm->node.flags & PM_HASHELEM)
    #####: 5050:	return;
        -: 5051:
        3: 5052:    if (isset(ALLEXPORT))
    #####: 5053:	pm->node.flags |= PM_EXPORTED;
        3: 5054:    pm->node.flags &= ~PM_DEFAULTED;
        -: 5055:
        -: 5056:    /*
        -: 5057:     * Do not "fix" parameters that were not exported
        -: 5058:     */
        -: 5059:
        3: 5060:    if (!(pm->node.flags & PM_EXPORTED))
        3: 5061:	return;
        -: 5062:
    #####: 5063:    if (pm->node.flags & PM_SPECIAL)
    #####: 5064:	joinchar = ':';
        -: 5065:    else
    #####: 5066:	joinchar = STOUC(((struct tieddata *)pm->u.data)->joinchar);
        -: 5067:
    #####: 5068:    addenv(pm, t ? zjoin(t, joinchar, 1) : "");
        -: 5069:}
        -: 5070:
        -: 5071:
        -: 5072:/**/
        -: 5073:int
       18: 5074:zputenv(char *str)
        -: 5075:{
        -: 5076:    DPUTS(!str, "Attempt to put null string into environment.");
        -: 5077:#ifdef USE_SET_UNSET_ENV
        -: 5078:    /*
        -: 5079:     * If we are using unsetenv() to remove values from the
        -: 5080:     * environment, which is the safe thing to do, we
        -: 5081:     * need to use setenv() to put them there in the first place.
        -: 5082:     * Unfortunately this is a slightly different interface
        -: 5083:     * from what zputenv() assumes.
        -: 5084:     */
        -: 5085:    char *ptr;
        -: 5086:    int ret;
        -: 5087:
       18: 5088:    for (ptr = str; *ptr && STOUC(*ptr) < 128 && *ptr != '='; ptr++)
        -: 5089:	;
       18: 5090:    if (STOUC(*ptr) >= 128) {
        -: 5091:	/*
        -: 5092:	 * Environment variables not in the portable character
        -: 5093:	 * set are non-standard and we don't really know of
        -: 5094:	 * a use for them.
        -: 5095:	 *
        -: 5096:	 * We'll disable until someone complains.
        -: 5097:	 */
    #####: 5098:	return 1;
       18: 5099:    } else if (*ptr) {
       18: 5100:	*ptr = '\0';
       18: 5101:	ret = setenv(str, ptr+1, 1);
       18: 5102:	*ptr = '=';
        -: 5103:    } else {
        -: 5104:	/* safety first */
        -: 5105:	DPUTS(1, "bad environment string");
    #####: 5106:	ret = setenv(str, ptr, 1);
        -: 5107:    }
       18: 5108:    return ret;
        -: 5109:#else
        -: 5110:#ifdef HAVE_PUTENV
        -: 5111:    return putenv(str);
        -: 5112:#else
        -: 5113:    char **ep;
        -: 5114:    int num_env;
        -: 5115:
        -: 5116:
        -: 5117:    /* First check if there is already an environment *
        -: 5118:     * variable matching string `name'.               */
        -: 5119:    if (findenv(str, &num_env)) {
        -: 5120:	environ[num_env] = str;
        -: 5121:    } else {
        -: 5122:    /* Else we have to make room and add it */
        -: 5123:	num_env = arrlen(environ);
        -: 5124:	environ = (char **) zrealloc(environ, (sizeof(char *)) * (num_env + 2));
        -: 5125:
        -: 5126:	/* Now add it at the end */
        -: 5127:	ep = environ + num_env;
        -: 5128:	*ep = str;
        -: 5129:	*(ep + 1) = NULL;
        -: 5130:    }
        -: 5131:    return 0;
        -: 5132:#endif
        -: 5133:#endif
        -: 5134:}
        -: 5135:
        -: 5136:/**/
        -: 5137:#ifndef USE_SET_UNSET_ENV
        -: 5138:/**/
        -: 5139:static int
        -: 5140:findenv(char *name, int *pos)
        -: 5141:{
        -: 5142:    char **ep, *eq;
        -: 5143:    int  nlen;
        -: 5144:
        -: 5145:
        -: 5146:    eq = strchr(name, '=');
        -: 5147:    nlen = eq ? eq - name : (int)strlen(name);
        -: 5148:    for (ep = environ; *ep; ep++) 
        -: 5149:	if (!strncmp (*ep, name, nlen) && *((*ep)+nlen) == '=') {
        -: 5150:	    if (pos)
        -: 5151:		*pos = ep - environ;
        -: 5152:	    return 1;
        -: 5153:	}
        -: 5154:    
        -: 5155:    return 0;
        -: 5156:}
        -: 5157:/**/
        -: 5158:#endif
        -: 5159:
        -: 5160:/* Given *name = "foo", it searches the environment for string *
        -: 5161: * "foo=bar", and returns a pointer to the beginning of "bar"  */
        -: 5162:
        -: 5163:/**/
        -: 5164:mod_export char *
        8: 5165:zgetenv(char *name)
        -: 5166:{
        -: 5167:#ifdef HAVE_GETENV
        8: 5168:    return getenv(name);
        -: 5169:#else
        -: 5170:    char **ep, *s, *t;
        -: 5171: 
        -: 5172:    for (ep = environ; *ep; ep++) {
        -: 5173:       for (s = *ep, t = name; *s && *s == *t; s++, t++);
        -: 5174:       if (*s == '=' && !*t)
        -: 5175:           return s + 1;
        -: 5176:    }
        -: 5177:    return NULL;
        -: 5178:#endif
        -: 5179:}
        -: 5180:
        -: 5181:/**/
        -: 5182:static void
       18: 5183:copyenvstr(char *s, char *value, int flags)
        -: 5184:{
      392: 5185:    while (*s++) {
      356: 5186:	if ((*s = *value++) == Meta)
    #####: 5187:	    *s = *value++ ^ 32;
      356: 5188:	if (flags & PM_LOWER)
    #####: 5189:	    *s = tulower(*s);
      356: 5190:	else if (flags & PM_UPPER)
    #####: 5191:	    *s = tuupper(*s);
        -: 5192:    }
       18: 5193:}
        -: 5194:
        -: 5195:/**/
        -: 5196:void
       12: 5197:addenv(Param pm, char *value)
        -: 5198:{
       12: 5199:    char *newenv = 0;
        -: 5200:#ifndef USE_SET_UNSET_ENV
        -: 5201:    char *oldenv = 0, *env = 0;
        -: 5202:    int pos;
        -: 5203:
        -: 5204:    /*
        -: 5205:     * First check if there is already an environment
        -: 5206:     * variable matching string `name'.
        -: 5207:     */
        -: 5208:    if (findenv(pm->node.nam, &pos))
        -: 5209:	oldenv = environ[pos];
        -: 5210:#endif
        -: 5211:
       12: 5212:     newenv = mkenvstr(pm->node.nam, value, pm->node.flags);
       12: 5213:     if (zputenv(newenv)) {
    #####: 5214:        zsfree(newenv);
    #####: 5215:	pm->env = NULL;
    #####: 5216:	return;
        -: 5217:    }
        -: 5218:#ifdef USE_SET_UNSET_ENV
        -: 5219:     /*
        -: 5220:      * If we are using setenv/unsetenv to manage the environment,
        -: 5221:      * we simply store the string we created in pm->env since
        -: 5222:      * memory management of the environment is handled entirely
        -: 5223:      * by the system.
        -: 5224:      *
        -: 5225:      * TODO: is this good enough to fix problem cases from
        -: 5226:      * the other branch?  If so, we don't actually need to
        -: 5227:      * store pm->env at all, just a flag that the value was set.
        -: 5228:      */
       12: 5229:     if (pm->env)
       10: 5230:         zsfree(pm->env);
       12: 5231:     pm->env = newenv;
       12: 5232:     pm->node.flags |= PM_EXPORTED;
        -: 5233:#else
        -: 5234:    /*
        -: 5235:     * Under Cygwin we must use putenv() to maintain consistency.
        -: 5236:     * Unfortunately, current version (1.1.2) copies argument and may
        -: 5237:     * silently reuse existing environment string. This tries to
        -: 5238:     * check for both cases
        -: 5239:     */
        -: 5240:    if (findenv(pm->node.nam, &pos)) {
        -: 5241:	env = environ[pos];
        -: 5242:	if (env != oldenv)
        -: 5243:	    zsfree(oldenv);
        -: 5244:	if (env != newenv)
        -: 5245:	    zsfree(newenv);
        -: 5246:	pm->node.flags |= PM_EXPORTED;
        -: 5247:	pm->env = env;
        -: 5248:	return;
        -: 5249:    }
        -: 5250:
        -: 5251:    DPUTS(1, "addenv should never reach the end");
        -: 5252:    pm->env = NULL;
        -: 5253:#endif
        -: 5254:}
        -: 5255:
        -: 5256:
        -: 5257:/* Given strings *name = "foo", *value = "bar", *
        -: 5258: * return a new string *str = "foo=bar".        */
        -: 5259:
        -: 5260:/**/
        -: 5261:static char *
       18: 5262:mkenvstr(char *name, char *value, int flags)
        -: 5263:{
       18: 5264:    char *str, *s = value;
       18: 5265:    int len_name, len_value = 0;
        -: 5266:
       18: 5267:    len_name = strlen(name);
       18: 5268:    if (s)
      374: 5269:	while (*s && (*s++ != Meta || *s++ != 32))
      338: 5270:	    len_value++;
       18: 5271:    s = str = (char *) zalloc(len_name + len_value + 2);
       18: 5272:    strcpy(s, name);
       18: 5273:    s += len_name;
       18: 5274:    *s = '=';
       18: 5275:    if (value)
       18: 5276:	copyenvstr(s, value, flags);
        -: 5277:    else
    #####: 5278:	*++s = '\0';
       18: 5279:    return str;
        -: 5280:}
        -: 5281:
        -: 5282:/* Given *name = "foo", *value = "bar", add the    *
        -: 5283: * string "foo=bar" to the environment.  Return a  *
        -: 5284: * pointer to the location of this new environment *
        -: 5285: * string.                                         */
        -: 5286:
        -: 5287:
        -: 5288:#ifndef USE_SET_UNSET_ENV
        -: 5289:/**/
        -: 5290:void
        -: 5291:delenvvalue(char *x)
        -: 5292:{
        -: 5293:    char **ep;
        -: 5294:
        -: 5295:    for (ep = environ; *ep; ep++) {
        -: 5296:	if (*ep == x)
        -: 5297:	    break;
        -: 5298:    }
        -: 5299:    if (*ep) {
        -: 5300:	for (; (ep[0] = ep[1]); ep++);
        -: 5301:    }
        -: 5302:    zsfree(x);
        -: 5303:}
        -: 5304:#endif
        -: 5305:
        -: 5306:
        -: 5307:/* Delete a pointer from the list of pointers to environment *
        -: 5308: * variables by shifting all the other pointers up one slot. */
        -: 5309:
        -: 5310:/**/
        -: 5311:void
    #####: 5312:delenv(Param pm)
        -: 5313:{
        -: 5314:#ifdef USE_SET_UNSET_ENV
    #####: 5315:    unsetenv(pm->node.nam);
    #####: 5316:    zsfree(pm->env);
        -: 5317:#else
        -: 5318:    delenvvalue(pm->env);
        -: 5319:#endif
    #####: 5320:    pm->env = NULL;
        -: 5321:    /*
        -: 5322:     * Note we don't remove PM_EXPORT from the flags.  This
        -: 5323:     * may be asking for trouble but we need to know later
        -: 5324:     * if we restore this parameter to its old value.
        -: 5325:     */
    #####: 5326:}
        -: 5327:
        -: 5328:/*
        -: 5329: * Guts of convbase: this version can return the number of digits
        -: 5330: * sans any base discriminator.
        -: 5331: */
        -: 5332:
        -: 5333:/**/
        -: 5334:void
       27: 5335:convbase_ptr(char *s, zlong v, int base, int *ndigits)
        -: 5336:{
       27: 5337:    int digs = 0;
        -: 5338:    zulong x;
        -: 5339:
       27: 5340:    if (v < 0)
    #####: 5341:	*s++ = '-', v = -v;
       27: 5342:    if (base >= -1 && base <= 1)
       21: 5343:	base = -10;
        -: 5344:
       27: 5345:    if (base > 0) {
        6: 5346:	if (isset(CBASES) && base == 16)
    #####: 5347:	    sprintf(s, "0x");
        6: 5348:	else if (isset(CBASES) && base == 8 && isset(OCTALZEROES))
    #####: 5349:	    sprintf(s, "0");
        6: 5350:	else if (base != 10)
    #####: 5351:	    sprintf(s, "%d#", base);
        -: 5352:	else
        6: 5353:	    *s = 0;
        6: 5354:	s += strlen(s);
        -: 5355:    } else
       21: 5356:	base = -base;
       64: 5357:    for (x = v; x; digs++)
       37: 5358:	x /= base;
       27: 5359:    if (!digs)
        7: 5360:	digs = 1;
       27: 5361:    if (ndigits)
        2: 5362:	*ndigits = digs;
       27: 5363:    s[digs--] = '\0';
       27: 5364:    x = v;
       98: 5365:    while (digs >= 0) {
       44: 5366:	int dig = x % base;
        -: 5367:
       44: 5368:	s[digs--] = (dig < 10) ? '0' + dig : dig - 10 + 'A';
       44: 5369:	x /= base;
        -: 5370:    }
       27: 5371:}
        -: 5372:
        -: 5373:/*
        -: 5374: * Basic conversion of integer to a string given a base.
        -: 5375: * If 0 base is 10.
        -: 5376: * If negative no base discriminator is output.
        -: 5377: */
        -: 5378:
        -: 5379:/**/
        -: 5380:mod_export void
       25: 5381:convbase(char *s, zlong v, int base)
        -: 5382:{
       25: 5383:    convbase_ptr(s, v, base, NULL);
       25: 5384:}
        -: 5385:
        -: 5386:/*
        -: 5387: * Add underscores to converted integer for readability with given spacing.
        -: 5388: * s is as for convbase: at least BDIGBUFSIZE.
        -: 5389: * If underscores were added, returned value with underscores comes from
        -: 5390: * heap, else the returned value is s.
        -: 5391: */
        -: 5392:
        -: 5393:/**/
        -: 5394:char *
        2: 5395:convbase_underscore(char *s, zlong v, int base, int underscore)
        -: 5396:{
        -: 5397:    char *retptr, *sptr, *dptr;
        -: 5398:    int ndigits, nunderscore, mod, len;
        -: 5399:
        2: 5400:    convbase_ptr(s, v, base, &ndigits);
        -: 5401:
        2: 5402:    if (underscore <= 0)
        2: 5403:	return s;
        -: 5404:
    #####: 5405:    nunderscore = (ndigits - 1) / underscore;
    #####: 5406:    if (!nunderscore)
    #####: 5407:	return s;
    #####: 5408:    len = strlen(s);
    #####: 5409:    retptr = zhalloc(len + nunderscore + 1);
    #####: 5410:    mod = 0;
    #####: 5411:    memcpy(retptr, s, len - ndigits);
    #####: 5412:    sptr = s + len;
    #####: 5413:    dptr = retptr + len + nunderscore;
        -: 5414:    /* copy the null */
    #####: 5415:    *dptr-- = *sptr--;
        -: 5416:    for (;;) {
    #####: 5417:	*dptr = *sptr;
    #####: 5418:	if (!--ndigits)
    #####: 5419:	    break;
    #####: 5420:	dptr--;
    #####: 5421:	sptr--;
    #####: 5422:	if (++mod == underscore) {
    #####: 5423:	    mod = 0;
    #####: 5424:	    *dptr-- = '_';
        -: 5425:	}
        -: 5426:    }
        -: 5427:
    #####: 5428:    return retptr;
        -: 5429:}
        -: 5430:
        -: 5431:/*
        -: 5432: * Convert a floating point value for output.
        -: 5433: * Unlike convbase(), this has its own internal storage and returns
        -: 5434: * a value from the heap.
        -: 5435: */
        -: 5436:
        -: 5437:/**/
        -: 5438:char *
    #####: 5439:convfloat(double dval, int digits, int flags, FILE *fout)
        -: 5440:{
    #####: 5441:    char fmt[] = "%.*e";
        -: 5442:    char *prev_locale, *ret;
        -: 5443:
        -: 5444:    /*
        -: 5445:     * The difficulty with the buffer size is that a %f conversion
        -: 5446:     * prints all digits before the decimal point: with 64 bit doubles,
        -: 5447:     * that's around 310.  We can't check without doing some quite
        -: 5448:     * serious floating point operations we'd like to avoid.
        -: 5449:     * Then we are liable to get all the digits
        -: 5450:     * we asked for after the decimal point, or we should at least
        -: 5451:     * bargain for it.  So we just allocate 512 + digits.  This
        -: 5452:     * should work until somebody decides on 128-bit doubles.
        -: 5453:     */
    #####: 5454:    if (!(flags & (PM_EFLOAT|PM_FFLOAT))) {
        -: 5455:	/*
        -: 5456:	 * Conversion from a floating point expression without using
        -: 5457:	 * a variable.  The best bet in this case just seems to be
        -: 5458:	 * to use the general %g format with something like the maximum
        -: 5459:	 * double precision.
        -: 5460:	 */
    #####: 5461:	fmt[3] = 'g';
    #####: 5462:	if (!digits)
    #####: 5463:	    digits = 17;
        -: 5464:    } else {
    #####: 5465:	if (flags & PM_FFLOAT)
    #####: 5466:	    fmt[3] = 'f';
    #####: 5467:	if (digits <= 0)
    #####: 5468:	    digits = 10;
    #####: 5469:	if (flags & PM_EFLOAT) {
        -: 5470:	    /*
        -: 5471:	     * Here, we are given the number of significant figures, but
        -: 5472:	     * %e wants the number of decimal places (unlike %g)
        -: 5473:	     */
    #####: 5474:	    digits--;
        -: 5475:	}
        -: 5476:    }
        -: 5477:#ifdef USE_LOCALE
    #####: 5478:    prev_locale = dupstring(setlocale(LC_NUMERIC, NULL));
    #####: 5479:    setlocale(LC_NUMERIC, "POSIX");
        -: 5480:#endif
    #####: 5481:    if (fout) {
    #####: 5482:	fprintf(fout, fmt, digits, dval);
    #####: 5483:	ret = NULL;
        -: 5484:    } else {
    #####: 5485:	VARARR(char, buf, 512 + digits);
    #####: 5486:	if (isinf(dval))
    #####: 5487:	    ret = dupstring((dval < 0.0) ? "-Inf" : "Inf");
    #####: 5488:	else if (isnan(dval))
    #####: 5489:	    ret = dupstring("NaN");
        -: 5490:	else {
    #####: 5491:	    sprintf(buf, fmt, digits, dval);
    #####: 5492:	    if (!strchr(buf, 'e') && !strchr(buf, '.'))
    #####: 5493:		strcat(buf, ".");
    #####: 5494:	    ret = dupstring(buf);
        -: 5495:	}
        -: 5496:    }
        -: 5497:#ifdef USE_LOCALE
    #####: 5498:    if (prev_locale) setlocale(LC_NUMERIC, prev_locale);
        -: 5499:#endif
    #####: 5500:    return ret;
        -: 5501:}
        -: 5502:
        -: 5503:/*
        -: 5504: * convert float to string with basic options but inserting underscores
        -: 5505: * for readability.
        -: 5506: */
        -: 5507:
        -: 5508:/**/
    #####: 5509:char *convfloat_underscore(double dval, int underscore)
        -: 5510:{
    #####: 5511:    int ndigits_int = 0, ndigits_frac = 0, nunderscore, len;
        -: 5512:    char *s, *retptr, *sptr, *dptr;
        -: 5513:
    #####: 5514:    s = convfloat(dval, 0, 0, NULL);
    #####: 5515:    if (underscore <= 0)
    #####: 5516:	return s;
        -: 5517:
        -: 5518:    /*
        -: 5519:     * Count the number of digits before and after the decimal point, if any.
        -: 5520:     */
    #####: 5521:    sptr = s;
    #####: 5522:    if (*sptr == '-')
    #####: 5523:	sptr++;
    #####: 5524:    while (idigit(*sptr)) {
    #####: 5525:	ndigits_int++;
    #####: 5526:	sptr++;
        -: 5527:    }
    #####: 5528:    if (*sptr == '.') {
    #####: 5529:	sptr++;
    #####: 5530:	while (idigit(*sptr)) {
    #####: 5531:	    ndigits_frac++;
    #####: 5532:	    sptr++;
        -: 5533:	}
        -: 5534:    }
        -: 5535:
        -: 5536:    /*
        -: 5537:     * Work out how many underscores to insert --- remember we
        -: 5538:     * put them in integer and fractional parts separately.
        -: 5539:     */
    #####: 5540:    nunderscore = (ndigits_int-1) / underscore + (ndigits_frac-1) / underscore;
    #####: 5541:    if (!nunderscore)
    #####: 5542:	return s;
    #####: 5543:    len = strlen(s);
    #####: 5544:    dptr = retptr = zhalloc(len + nunderscore + 1);
        -: 5545:
        -: 5546:    /*
        -: 5547:     * Insert underscores in integer part.
        -: 5548:     * Grouping starts from the point in both directions.
        -: 5549:     */
    #####: 5550:    sptr = s;
    #####: 5551:    if (*sptr == '-')
    #####: 5552:	*dptr++ = *sptr++;
    #####: 5553:    while (ndigits_int) {
    #####: 5554:	*dptr++ = *sptr++;
    #####: 5555:	if (--ndigits_int && !(ndigits_int % underscore))
    #####: 5556:	    *dptr++ = '_';
        -: 5557:    }
    #####: 5558:    if (ndigits_frac) {
        -: 5559:	/*
        -: 5560:	 * Insert underscores in the fractional part.
        -: 5561:	 */
    #####: 5562:	int mod = 0;
        -: 5563:	/* decimal point, we already checked */
    #####: 5564:	*dptr++ = *sptr++;
    #####: 5565:	while (ndigits_frac) {
    #####: 5566:	    *dptr++ = *sptr++;
    #####: 5567:	    mod++;
    #####: 5568:	    if (--ndigits_frac && mod == underscore) {
    #####: 5569:		*dptr++ = '_';
    #####: 5570:		mod = 0;
        -: 5571:	    }
        -: 5572:	}
        -: 5573:    }
        -: 5574:    /* Copy exponent and anything else up to null */
    #####: 5575:    while ((*dptr++ = *sptr++))
        -: 5576:	;
    #####: 5577:    return retptr;
        -: 5578:}
        -: 5579:
        -: 5580:/* Start a parameter scope */
        -: 5581:
        -: 5582:/**/
        -: 5583:mod_export void
       23: 5584:startparamscope(void)
        -: 5585:{
       23: 5586:    locallevel++;
       23: 5587:}
        -: 5588:
        -: 5589:#ifdef USE_LOCALE
        -: 5590:/*
        -: 5591: * Flag that one of the special LC_ functions or LANG changed on scope
        -: 5592: * end
        -: 5593: */
        -: 5594:static int lc_update_needed;
        -: 5595:#endif /* USE_LOCALE */
        -: 5596:
        -: 5597:/* End a parameter scope: delete the parameters local to the scope. */
        -: 5598:
        -: 5599:/**/
        -: 5600:mod_export void
       23: 5601:endparamscope(void)
        -: 5602:{
       23: 5603:    queue_signals();
       23: 5604:    locallevel--;
        -: 5605:    /* This pops anything from a higher locallevel */
       23: 5606:    saveandpophiststack(0, HFILE_USE_OPTIONS);
        -: 5607:#ifdef USE_LOCALE
       23: 5608:    lc_update_needed = 0;
        -: 5609:#endif
       23: 5610:    scanhashtable(paramtab, 0, 0, 0, scanendscope, 0);
        -: 5611:#ifdef USE_LOCALE
       23: 5612:    if (lc_update_needed)
        -: 5613:    {
        -: 5614:	/* Locale changed --- ensure it is restored. */
        -: 5615:	char *val;
    #####: 5616:	if ((val = getsparam_u("LC_ALL")) && *val) {
    #####: 5617:	    setlocale(LC_ALL, val);
        -: 5618:	} else {
        -: 5619:	    struct localename *ln;
    #####: 5620:	    if ((val = getsparam_u("LANG")) && *val)
    #####: 5621:		setlang(val);
    #####: 5622:	    for (ln = lc_names; ln->name; ln++) {
    #####: 5623:		if ((val = getsparam_u(ln->name)) && *val)
    #####: 5624:		    setlocale(ln->category, val);
        -: 5625:	    }
        -: 5626:	}
        -: 5627:    }
        -: 5628:#endif /* USE_LOCALE */
       23: 5629:    unqueue_signals();
       23: 5630:}
        -: 5631:
        -: 5632:/**/
        -: 5633:static void
     4161: 5634:scanendscope(HashNode hn, UNUSED(int flags))
        -: 5635:{
     4161: 5636:    Param pm = (Param)hn;
     4161: 5637:    if (pm->level > locallevel) {
       19: 5638:	if ((pm->node.flags & (PM_SPECIAL|PM_REMOVABLE)) == PM_SPECIAL) {
        -: 5639:	    /*
        -: 5640:	     * Removable specials are normal in that they can be removed
        -: 5641:	     * to reveal an ordinary parameter beneath.  Here we handle
        -: 5642:	     * non-removable specials, which were made local by stealth
        -: 5643:	     * (see newspecial code in typeset_single()).  In fact the
        -: 5644:	     * visible pm is always the same struct; the pm->old is
        -: 5645:	     * just a place holder for old data and flags.
        -: 5646:	     */
       12: 5647:	    Param tpm = pm->old;
        -: 5648:
        -: 5649:#ifdef USE_LOCALE
       24: 5650:	    if (!strncmp(pm->node.nam, "LC_", 3) ||
       12: 5651:		!strcmp(pm->node.nam, "LANG"))
    #####: 5652:		lc_update_needed = 1;
        -: 5653:#endif
       12: 5654:	    if (!strcmp(pm->node.nam, "SECONDS"))
        -: 5655:	    {
    #####: 5656:		setsecondstype(pm, PM_TYPE(tpm->node.flags), PM_TYPE(pm->node.flags));
        -: 5657:		/*
        -: 5658:		 * We restore SECONDS by restoring its raw internal value
        -: 5659:		 * that we cached off into tpm->u.dval.
        -: 5660:		 */
    #####: 5661:		setrawseconds(tpm->u.dval);
    #####: 5662:		tpm->node.flags |= PM_NORESTORE;
        -: 5663:	    }
        -: 5664:	    DPUTS(!tpm || PM_TYPE(pm->node.flags) != PM_TYPE(tpm->node.flags) ||
        -: 5665:		  !(tpm->node.flags & PM_SPECIAL),
        -: 5666:		  "BUG: in restoring scope of special parameter");
       12: 5667:	    pm->old = tpm->old;
       12: 5668:	    pm->node.flags = (tpm->node.flags & ~PM_NORESTORE);
       12: 5669:	    pm->level = tpm->level;
       12: 5670:	    pm->base = tpm->base;
       12: 5671:	    pm->width = tpm->width;
       12: 5672:	    if (pm->env)
    #####: 5673:		delenv(pm);
        -: 5674:
       12: 5675:	    if (!(tpm->node.flags & (PM_NORESTORE|PM_READONLY)))
       12: 5676:		switch (PM_TYPE(pm->node.flags)) {
       12: 5677:		case PM_SCALAR:
       12: 5678:		    pm->gsu.s->setfn(pm, tpm->u.str);
       12: 5679:		    break;
    #####: 5680:		case PM_INTEGER:
    #####: 5681:		    pm->gsu.i->setfn(pm, tpm->u.val);
    #####: 5682:		    break;
    #####: 5683:		case PM_EFLOAT:
        -: 5684:		case PM_FFLOAT:
    #####: 5685:		    pm->gsu.f->setfn(pm, tpm->u.dval);
    #####: 5686:		    break;
    #####: 5687:		case PM_ARRAY:
    #####: 5688:		    pm->gsu.a->setfn(pm, tpm->u.arr);
    #####: 5689:		    break;
    #####: 5690:		case PM_HASHED:
    #####: 5691:		    pm->gsu.h->setfn(pm, tpm->u.hash);
    #####: 5692:		    break;
        -: 5693:		}
       12: 5694:	    zfree(tpm, sizeof(*tpm));
        -: 5695:
       12: 5696:	    if (pm->node.flags & PM_EXPORTED)
    #####: 5697:		export_param(pm);
        -: 5698:	} else
        7: 5699:	    unsetparam_pm(pm, 0, 0);
        -: 5700:    }
     4161: 5701:}
        -: 5702:
        -: 5703:
        -: 5704:/**********************************/
        -: 5705:/* Parameter Hash Table Functions */
        -: 5706:/**********************************/
        -: 5707:
        -: 5708:/**/
        -: 5709:void
      434: 5710:freeparamnode(HashNode hn)
        -: 5711:{
      434: 5712:    Param pm = (Param) hn;
        -: 5713: 
        -: 5714:    /* The second argument of unsetfn() is used by modules to
        -: 5715:     * differentiate "exp"licit unset from implicit unset, as when
        -: 5716:     * a parameter is going out of scope.  It's not clear which
        -: 5717:     * of these applies here, but passing 1 has always worked.
        -: 5718:     */
      434: 5719:    if (delunset)
      394: 5720:	pm->gsu.s->unsetfn(pm, 1);
      434: 5721:    zsfree(pm->node.nam);
        -: 5722:    /* If this variable was tied by the user, ename was ztrdup'd */
      434: 5723:    if (!(pm->node.flags & PM_SPECIAL))
      434: 5724:	zsfree(pm->ename);
      434: 5725:    zfree(pm, sizeof(struct param));
      434: 5726:}
        -: 5727:
        -: 5728:/* Print a parameter */
        -: 5729:
        -: 5730:enum paramtypes_flags {
        -: 5731:    PMTF_USE_BASE	= (1<<0),
        -: 5732:    PMTF_USE_WIDTH	= (1<<1),
        -: 5733:    PMTF_TEST_LEVEL	= (1<<2)
        -: 5734:};
        -: 5735:
        -: 5736:struct paramtypes {
        -: 5737:    int binflag;	/* The relevant PM_FLAG(S) */
        -: 5738:    const char *string;	/* String for verbose output */
        -: 5739:    int typeflag;	/* Flag for typeset -? */
        -: 5740:    int flags;		/* The enum above */
        -: 5741:};
        -: 5742:
        -: 5743:static const struct paramtypes pmtypes[] = {
        -: 5744:    { PM_AUTOLOAD, "undefined", 0, 0},
        -: 5745:    { PM_INTEGER, "integer", 'i', PMTF_USE_BASE},
        -: 5746:    { PM_EFLOAT, "float", 'E', 0},
        -: 5747:    { PM_FFLOAT, "float", 'F', 0},
        -: 5748:    { PM_ARRAY, "array", 'a', 0},
        -: 5749:    { PM_HASHED, "association", 'A', 0},
        -: 5750:    { 0, "local", 0, PMTF_TEST_LEVEL},
        -: 5751:    { PM_LEFT, "left justified", 'L', PMTF_USE_WIDTH},
        -: 5752:    { PM_RIGHT_B, "right justified", 'R', PMTF_USE_WIDTH},
        -: 5753:    { PM_RIGHT_Z, "zero filled", 'Z', PMTF_USE_WIDTH},
        -: 5754:    { PM_LOWER, "lowercase", 'l', 0},
        -: 5755:    { PM_UPPER, "uppercase", 'u', 0},
        -: 5756:    { PM_READONLY, "readonly", 'r', 0},
        -: 5757:    { PM_TAGGED, "tagged", 't', 0},
        -: 5758:    { PM_EXPORTED, "exported", 'x', 0},
        -: 5759:    { PM_UNIQUE, "unique", 'U', 0},
        -: 5760:    { PM_TIED, "tied", 'T', 0}
        -: 5761:};
        -: 5762:
        -: 5763:#define PMTYPES_SIZE ((int)(sizeof(pmtypes)/sizeof(struct paramtypes)))
        -: 5764:
        -: 5765:static void
    #####: 5766:printparamvalue(Param p, int printflags)
        -: 5767:{
        -: 5768:    char *t, **u;
        -: 5769:
    #####: 5770:    if (!(printflags & PRINT_KV_PAIR))
    #####: 5771:	putchar('=');
        -: 5772:
        -: 5773:    /* How the value is displayed depends *
        -: 5774:     * on the type of the parameter       */
    #####: 5775:    switch (PM_TYPE(p->node.flags)) {
    #####: 5776:    case PM_SCALAR:
        -: 5777:	/* string: simple output */
    #####: 5778:	if (p->gsu.s->getfn && (t = p->gsu.s->getfn(p)))
    #####: 5779:	    quotedzputs(t, stdout);
    #####: 5780:	break;
    #####: 5781:    case PM_INTEGER:
        -: 5782:	/* integer */
        -: 5783:#ifdef ZSH_64_BIT_TYPE
        -: 5784:	fputs(output64(p->gsu.i->getfn(p)), stdout);
        -: 5785:#else
    #####: 5786:	printf("%ld", p->gsu.i->getfn(p));
        -: 5787:#endif
    #####: 5788:	break;
    #####: 5789:    case PM_EFLOAT:
        -: 5790:    case PM_FFLOAT:
        -: 5791:	/* float */
    #####: 5792:	convfloat(p->gsu.f->getfn(p), p->base, p->node.flags, stdout);
    #####: 5793:	break;
    #####: 5794:    case PM_ARRAY:
        -: 5795:	/* array */
    #####: 5796:	if (!(printflags & PRINT_KV_PAIR)) {
    #####: 5797:	    putchar('(');
    #####: 5798:	    if (!(printflags & PRINT_LINE))
    #####: 5799:		putchar(' ');
        -: 5800:	}
    #####: 5801:	u = p->gsu.a->getfn(p);
    #####: 5802:	if(*u) {
    #####: 5803:	    if (printflags & PRINT_LINE) {
    #####: 5804:		if (printflags & PRINT_KV_PAIR)
    #####: 5805:		    printf("  ");
        -: 5806:		else
    #####: 5807:		    printf("\n  ");
        -: 5808:	    }
    #####: 5809:	    quotedzputs(*u++, stdout);
    #####: 5810:	    while (*u) {
    #####: 5811:		if (printflags & PRINT_LINE)
    #####: 5812:		    printf("\n  ");
        -: 5813:		else
    #####: 5814:		    putchar(' ');
    #####: 5815:		quotedzputs(*u++, stdout);
        -: 5816:	    }
    #####: 5817:	    if ((printflags & (PRINT_LINE|PRINT_KV_PAIR)) == PRINT_LINE)
    #####: 5818:		putchar('\n');
        -: 5819:	}
    #####: 5820:	if (!(printflags & PRINT_KV_PAIR)) {
    #####: 5821:	    if (!(printflags & PRINT_LINE))
    #####: 5822:		putchar(' ');
    #####: 5823:	    putchar(')');
        -: 5824:	}
    #####: 5825:	break;
    #####: 5826:    case PM_HASHED:
        -: 5827:	/* association */
        -: 5828:	{
        -: 5829:	    HashTable ht;
    #####: 5830:	    int found = 0;
    #####: 5831:	    if (!(printflags & PRINT_KV_PAIR)) {
    #####: 5832:		putchar('(');
    #####: 5833:		if (!(printflags & PRINT_LINE))
    #####: 5834:		    putchar(' ');
        -: 5835:	    }
    #####: 5836:            ht = p->gsu.h->getfn(p);
    #####: 5837:            if (ht)
    #####: 5838:		found = scanhashtable(ht, 1, 0, PM_UNSET,
        -: 5839:				      ht->printnode, PRINT_KV_PAIR |
    #####: 5840:				      (printflags & PRINT_LINE));
    #####: 5841:	    if (!(printflags & PRINT_KV_PAIR)) {
    #####: 5842:		if (found && (printflags & PRINT_LINE))
    #####: 5843:		    putchar('\n');
    #####: 5844:		putchar(')');
        -: 5845:	    }
        -: 5846:	}
    #####: 5847:	break;
        -: 5848:    }
    #####: 5849:}
        -: 5850:
        -: 5851:/**/
        -: 5852:mod_export void
    #####: 5853:printparamnode(HashNode hn, int printflags)
        -: 5854:{
    #####: 5855:    Param p = (Param) hn;
    #####: 5856:    Param peer = NULL;
        -: 5857:
    #####: 5858:    if (p->node.flags & PM_UNSET) {
    #####: 5859:	if ((printflags & (PRINT_POSIX_READONLY|PRINT_POSIX_EXPORT) &&
    #####: 5860:	     p->node.flags & (PM_READONLY|PM_EXPORTED)) ||
    #####: 5861:	    (p->node.flags & PM_DEFAULTED) == PM_DEFAULTED) {
        -: 5862:	    /*
        -: 5863:	     * Special POSIX rules: show the parameter as readonly/exported
        -: 5864:	     * even though it's unset, but with no value.
        -: 5865:	     */
    #####: 5866:	    printflags |= PRINT_NAMEONLY;
        -: 5867:	}
        -: 5868:	else
    #####: 5869:	    return;
        -: 5870:    }
    #####: 5871:    if (p->node.flags & PM_AUTOLOAD)
    #####: 5872:	printflags |= PRINT_NAMEONLY;
        -: 5873:
    #####: 5874:    if (printflags & (PRINT_TYPESET|PRINT_POSIX_READONLY|PRINT_POSIX_EXPORT)) {
    #####: 5875:	if (p->node.flags & (PM_RO_BY_DESIGN|PM_AUTOLOAD)) {
        -: 5876:	    /*
        -: 5877:	     * It's not possible to restore the state of
        -: 5878:	     * these, so don't output.
        -: 5879:	     */
    #####: 5880:	    return;
        -: 5881:	}
        -: 5882:	/*
        -: 5883:	 * The zsh variants of export -p/readonly -p also report other
        -: 5884:	 * flags to indicate other attributes or scope. The POSIX variants
        -: 5885:	 * don't.
        -: 5886:	 */
    #####: 5887:	if (printflags & PRINT_POSIX_EXPORT) {
    #####: 5888:	    if (!(p->node.flags & PM_EXPORTED))
    #####: 5889:		return;
    #####: 5890:	    printf("export ");
    #####: 5891:	} else if (printflags & PRINT_POSIX_READONLY) {
    #####: 5892:	    if (!(p->node.flags & PM_READONLY))
    #####: 5893:		return;
    #####: 5894:	    printf("readonly ");
    #####: 5895:	} else if (locallevel && p->level >= locallevel) {
    #####: 5896:	    printf("typeset ");	    /* printf("local "); */
    #####: 5897:	} else if ((p->node.flags & PM_EXPORTED) &&
    #####: 5898:		   !(p->node.flags & (PM_ARRAY|PM_HASHED))) {
    #####: 5899:	    printf("export ");
    #####: 5900:	} else if (locallevel) {
    #####: 5901:	    printf("typeset -g ");
        -: 5902:	} else
    #####: 5903:	    printf("typeset ");
        -: 5904:    }
        -: 5905:
        -: 5906:    /* Print the attributes of the parameter */
    #####: 5907:    if (printflags & (PRINT_TYPE|PRINT_TYPESET)) {
    #####: 5908:	int doneminus = 0, i;
        -: 5909:	const struct paramtypes *pmptr;
        -: 5910:
    #####: 5911:	for (pmptr = pmtypes, i = 0; i < PMTYPES_SIZE; i++, pmptr++) {
    #####: 5912:	    int doprint = 0;
    #####: 5913:	    if (pmptr->flags & PMTF_TEST_LEVEL) {
    #####: 5914:		if (p->level)
    #####: 5915:		    doprint = 1;
    #####: 5916:	    } else if ((pmptr->binflag != PM_EXPORTED || p->level ||
    #####: 5917:			(p->node.flags & (PM_LOCAL|PM_ARRAY|PM_HASHED))) &&
    #####: 5918:		       (p->node.flags & pmptr->binflag))
    #####: 5919:		doprint = 1;
        -: 5920:
    #####: 5921:	    if (doprint) {
    #####: 5922:		if (printflags & PRINT_TYPESET) {
    #####: 5923:		    if (pmptr->typeflag) {
    #####: 5924:			if (!doneminus) {
    #####: 5925:			    putchar('-');
    #####: 5926:			    doneminus = 1;
        -: 5927:			}
    #####: 5928:			putchar(pmptr->typeflag);
        -: 5929:		    }
        -: 5930:		} else
    #####: 5931:		    printf("%s ", pmptr->string);
    #####: 5932:		if ((pmptr->flags & PMTF_USE_BASE) && p->base) {
    #####: 5933:		    printf("%d ", p->base);
    #####: 5934:		    doneminus = 0;
        -: 5935:		}
    #####: 5936:		if ((pmptr->flags & PMTF_USE_WIDTH) && p->width) {
    #####: 5937:		    printf("%u ", p->width);
    #####: 5938:		    doneminus = 0;
        -: 5939:		}
        -: 5940:	    }
        -: 5941:	}
    #####: 5942:	if (doneminus)
    #####: 5943:	    putchar(' ');
        -: 5944:
    #####: 5945:	if (p->node.flags & PM_TIED) {
        -: 5946:	    /*
        -: 5947:	     * For scalars tied to arrays,s
        -: 5948:	     *   * typeset +m outputs
        -: 5949:	     *      array tied SCALAR array
        -: 5950:	     *      tied array SCALAR
        -: 5951:	     *   * typeset -p outputs:
        -: 5952:	     *      typeset -T SCALAR array  (for hidden values)
        -: 5953:	     *      typeset -T SCALAR array=(values)
        -: 5954:	     *      for both scalar and array (flags may be different)
        -: 5955:	     *
        -: 5956:	     * We choose to print the value for the array instead of the scalar
        -: 5957:	     * as scalars can't disambiguate between
        -: 5958:	     * typeset -T SCALAR array=()
        -: 5959:	     * and
        -: 5960:	     * typeset -T SCALAR array=('')
        -: 5961:	     * (same for (a b:c)...)
        -: 5962:	     */
    #####: 5963:	    Param tmp = (Param) paramtab->getnode(paramtab, p->ename);
        -: 5964:
        -: 5965:	    /*
        -: 5966:	     * Swap param and tied peer for typeset -p output
        -: 5967:	     */
    #####: 5968:	    if (!(printflags & PRINT_TYPESET) || (p->node.flags & PM_ARRAY))
    #####: 5969:		peer = tmp;
        -: 5970:	    else {
    #####: 5971:		peer = p;
    #####: 5972:		p = tmp;
        -: 5973:	    }
        -: 5974:
    #####: 5975:	    quotedzputs(peer->node.nam, stdout);
    #####: 5976:	    putchar(' ');
        -: 5977:	}
        -: 5978:    }
        -: 5979:
    #####: 5980:    if ((printflags & PRINT_NAMEONLY) ||
    #####: 5981:	((p->node.flags & PM_HIDEVAL) && !(printflags & PRINT_INCLUDEVALUE)))
    #####: 5982:	quotedzputs(p->node.nam, stdout);
        -: 5983:    else {
    #####: 5984:	if (printflags & PRINT_KV_PAIR) {
    #####: 5985:	    if (printflags & PRINT_LINE)
    #####: 5986:		printf("\n  ");
    #####: 5987:	    putchar('[');
        -: 5988:	}
    #####: 5989:	quotedzputs(p->node.nam, stdout);
    #####: 5990:	if (printflags & PRINT_KV_PAIR)
    #####: 5991:	    printf("]=");
        -: 5992:
    #####: 5993:	printparamvalue(p, printflags);
        -: 5994:    }
    #####: 5995:    if (peer && (printflags & PRINT_TYPESET) && !(p->node.flags & PM_SPECIAL)) {
        -: 5996:	/*
        -: 5997:	 * append the join char for tied parameters if different from colon
        -: 5998:	 * for typeset -p output.
        -: 5999:	 */
    #####: 6000:	unsigned char joinchar = STOUC(((struct tieddata *)peer->u.data)->joinchar);
    #####: 6001:	if (joinchar != ':') {
        -: 6002:	    char buf[2];
    #####: 6003:	    buf[0] = joinchar;
    #####: 6004:	    buf[1] = '\0';
    #####: 6005:	    putchar(' ');
    #####: 6006:	    quotedzputs(buf, stdout);
        -: 6007:	}
        -: 6008:    }
    #####: 6009:    if ((printflags & (PRINT_KV_PAIR|PRINT_LINE)) == PRINT_KV_PAIR)
    #####: 6010:	putchar(' ');
    #####: 6011:    else if (!(printflags & PRINT_KV_PAIR))
    #####: 6012:	putchar('\n');
        -: 6013:}
