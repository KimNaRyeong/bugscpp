        -:    0:Source:utils.c
        -:    0:Graph:/home/workspace/Src/utils.gcno
        -:    0:Data:/home/workspace/Src/utils.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:/*
        -:    2: * utils.c - miscellaneous utilities
        -:    3: *
        -:    4: * This file is part of zsh, the Z shell.
        -:    5: *
        -:    6: * Copyright (c) 1992-1997 Paul Falstad
        -:    7: * All rights reserved.
        -:    8: *
        -:    9: * Permission is hereby granted, without written agreement and without
        -:   10: * license or royalty fees, to use, copy, modify, and distribute this
        -:   11: * software and to distribute modified versions of this software for any
        -:   12: * purpose, provided that the above copyright notice and the following
        -:   13: * two paragraphs appear in all copies of this software.
        -:   14: *
        -:   15: * In no event shall Paul Falstad or the Zsh Development Group be liable
        -:   16: * to any party for direct, indirect, special, incidental, or consequential
        -:   17: * damages arising out of the use of this software and its documentation,
        -:   18: * even if Paul Falstad and the Zsh Development Group have been advised of
        -:   19: * the possibility of such damage.
        -:   20: *
        -:   21: * Paul Falstad and the Zsh Development Group specifically disclaim any
        -:   22: * warranties, including, but not limited to, the implied warranties of
        -:   23: * merchantability and fitness for a particular purpose.  The software
        -:   24: * provided hereunder is on an "as is" basis, and Paul Falstad and the
        -:   25: * Zsh Development Group have no obligation to provide maintenance,
        -:   26: * support, updates, enhancements, or modifications.
        -:   27: *
        -:   28: */
        -:   29:
        -:   30:#include "zsh.mdh"
        -:   31:#include "utils.pro"
        -:   32:
        -:   33:/* name of script being sourced */
        -:   34:
        -:   35:/**/
        -:   36:mod_export char *scriptname;     /* is sometimes a function name */
        -:   37:
        -:   38:/* filename of script or other file containing code source e.g. autoload */
        -:   39:
        -:   40:/**/
        -:   41:mod_export char *scriptfilename;
        -:   42:
        -:   43:/* != 0 if we are in a new style completion function */
        -:   44:
        -:   45:/**/
        -:   46:mod_export int incompfunc;
        -:   47:
        -:   48:#ifdef MULTIBYTE_SUPPORT
        -:   49:struct widechar_array {
        -:   50:    wchar_t *chars;
        -:   51:    size_t len;
        -:   52:};
        -:   53:typedef struct widechar_array *Widechar_array;
        -:   54:
        -:   55:/*
        -:   56: * The wordchars variable turned into a wide character array.
        -:   57: * This is much more convenient for testing.
        -:   58: */
        -:   59:static struct widechar_array wordchars_wide;
        -:   60:
        -:   61:/*
        -:   62: * The same for the separators (IFS) array.
        -:   63: */
        -:   64:static struct widechar_array ifs_wide;
        -:   65:
        -:   66:/* Function to set one of the above from the multibyte array */
        -:   67:
        -:   68:static void
      180:   69:set_widearray(char *mb_array, Widechar_array wca)
        -:   70:{
      180:   71:    if (wca->chars) {
      176:   72:	free(wca->chars);
      176:   73:	wca->chars = NULL;
        -:   74:    }
      180:   75:    wca->len = 0;
        -:   76:
      180:   77:    if (!isset(MULTIBYTE))
    #####:   78:	return;
        -:   79:
      180:   80:    if (mb_array) {
      180:   81:	VARARR(wchar_t, tmpwcs, strlen(mb_array));
      180:   82:	wchar_t *wcptr = tmpwcs;
        -:   83:	wint_t wci;
        -:   84:
      180:   85:	mb_charinit();
     2650:   86:	while (*mb_array) {
        -:   87:	    int mblen;
        -:   88:
     2290:   89:	    if (STOUC(*mb_array) <= 0x7f) {
     2235:   90:		mb_array++;
     2235:   91:		*wcptr++ = (wchar_t)*mb_array;
     2235:   92:		continue;
        -:   93:	    }
        -:   94:
       55:   95:	    mblen = mb_metacharlenconv(mb_array, &wci);
        -:   96:
       55:   97:	    if (!mblen)
    #####:   98:		break;
        -:   99:	    /* No good unless all characters are convertible */
       55:  100:	    if (wci == WEOF)
    #####:  101:		return;
       55:  102:	    *wcptr++ = (wchar_t)wci;
        -:  103:#ifdef DEBUG
        -:  104:	    /*
        -:  105:	     * This generates a warning from the compiler (and is
        -:  106:	     * indeed useless) if chars are unsigned.  It's
        -:  107:	     * extreme paranoia anyway.
        -:  108:	     */
        -:  109:	    if (wcptr[-1] < 0)
        -:  110:		fprintf(stderr, "BUG: Bad cast to wchar_t\n");
        -:  111:#endif
       55:  112:	    mb_array += mblen;
        -:  113:	}
        -:  114:
      180:  115:	wca->len = wcptr - tmpwcs;
      180:  116:	wca->chars = (wchar_t *)zalloc(wca->len * sizeof(wchar_t));
      180:  117:	wmemcpy(wca->chars, tmpwcs, wca->len);
        -:  118:    }
        -:  119:}
        -:  120:#endif
        -:  121:
        -:  122:
        -:  123:/* Print an error
        -:  124:
        -:  125:   The following functions use the following printf-like format codes
        -:  126:   (implemented by zerrmsg()):
        -:  127:
        -:  128:   Code	Argument types		Prints
        -:  129:   %s	const char *		C string (null terminated)
        -:  130:   %l	const char *, int	C string of given length (null not required)
        -:  131:   %L	long			decimal value
        -:  132:   %d	int			decimal value
        -:  133:   %z	zlong			decimal value
        -:  134:   %%	(none)			literal '%'
        -:  135:   %c	int			character at that codepoint
        -:  136:   %e	int			strerror() message (argument is typically 'errno')
        -:  137: */
        -:  138:
        -:  139:static void
    #####:  140:zwarning(const char *cmd, const char *fmt, va_list ap)
        -:  141:{
    #####:  142:    if (isatty(2))
    #####:  143:	zleentry(ZLE_CMD_TRASH);
        -:  144:
    #####:  145:    char *prefix = scriptname ? scriptname : (argzero ? argzero : "");
        -:  146:
    #####:  147:    if (cmd) {
    #####:  148:	if (unset(SHINSTDIN) || locallevel) {
    #####:  149:	    nicezputs(prefix, stderr);
    #####:  150:	    fputc((unsigned char)':', stderr);
        -:  151:	}
    #####:  152:	nicezputs(cmd, stderr);
    #####:  153:	fputc((unsigned char)':', stderr);
        -:  154:    } else {
        -:  155:	/*
        -:  156:	 * scriptname is set when sourcing scripts, so that we get the
        -:  157:	 * correct name instead of the generic name of whatever
        -:  158:	 * program/script is running.  It's also set in shell functions,
        -:  159:	 * so test locallevel, too.
        -:  160:	 */
    #####:  161:	nicezputs((isset(SHINSTDIN) && !locallevel) ? "zsh" : prefix, stderr);
    #####:  162:	fputc((unsigned char)':', stderr);
        -:  163:    }
        -:  164:
    #####:  165:    zerrmsg(stderr, fmt, ap);
    #####:  166:}
        -:  167:
        -:  168:
        -:  169:/**/
        -:  170:mod_export void
    #####:  171:zerr(VA_ALIST1(const char *fmt))
        -:  172:VA_DCL
        -:  173:{
        -:  174:    va_list ap;
        -:  175:    VA_DEF_ARG(const char *fmt);
        -:  176:
    #####:  177:    if (errflag || noerrs) {
    #####:  178:	if (noerrs < 2)
    #####:  179:	    errflag |= ERRFLAG_ERROR;
    #####:  180:	return;
        -:  181:    }
    #####:  182:    errflag |= ERRFLAG_ERROR;
        -:  183:
    #####:  184:    VA_START(ap, fmt);
        -:  185:    VA_GET_ARG(ap, fmt, const char *);
    #####:  186:    zwarning(NULL, fmt, ap);
    #####:  187:    va_end(ap);
        -:  188:}
        -:  189:
        -:  190:/**/
        -:  191:mod_export void
    #####:  192:zerrnam(VA_ALIST2(const char *cmd, const char *fmt))
        -:  193:VA_DCL
        -:  194:{
        -:  195:    va_list ap;
        -:  196:    VA_DEF_ARG(const char *cmd);
        -:  197:    VA_DEF_ARG(const char *fmt);
        -:  198:
    #####:  199:    if (errflag || noerrs)
    #####:  200:	return;
    #####:  201:    errflag |= ERRFLAG_ERROR;
        -:  202:
    #####:  203:    VA_START(ap, fmt);
        -:  204:    VA_GET_ARG(ap, cmd, const char *);
        -:  205:    VA_GET_ARG(ap, fmt, const char *);
    #####:  206:    zwarning(cmd, fmt, ap);
    #####:  207:    va_end(ap);
        -:  208:}
        -:  209:
        -:  210:/**/
        -:  211:mod_export void
    #####:  212:zwarn(VA_ALIST1(const char *fmt))
        -:  213:VA_DCL
        -:  214:{
        -:  215:    va_list ap;
        -:  216:    VA_DEF_ARG(const char *fmt);
        -:  217:
    #####:  218:    if (errflag || noerrs)
    #####:  219:	return;
        -:  220:
    #####:  221:    VA_START(ap, fmt);
        -:  222:    VA_GET_ARG(ap, fmt, const char *);
    #####:  223:    zwarning(NULL, fmt, ap);
    #####:  224:    va_end(ap);
        -:  225:}
        -:  226:
        -:  227:/**/
        -:  228:mod_export void
    #####:  229:zwarnnam(VA_ALIST2(const char *cmd, const char *fmt))
        -:  230:VA_DCL
        -:  231:{
        -:  232:    va_list ap;
        -:  233:    VA_DEF_ARG(const char *cmd);
        -:  234:    VA_DEF_ARG(const char *fmt);
        -:  235:
    #####:  236:    if (errflag || noerrs)
    #####:  237:	return;
        -:  238:
    #####:  239:    VA_START(ap, fmt);
        -:  240:    VA_GET_ARG(ap, cmd, const char *);
        -:  241:    VA_GET_ARG(ap, fmt, const char *);
    #####:  242:    zwarning(cmd, fmt, ap);
    #####:  243:    va_end(ap);
        -:  244:}
        -:  245:
        -:  246:
        -:  247:#ifdef DEBUG
        -:  248:
        -:  249:/**/
        -:  250:mod_export void
        -:  251:dputs(VA_ALIST1(const char *message))
        -:  252:VA_DCL
        -:  253:{
        -:  254:    char *filename;
        -:  255:    FILE *file;
        -:  256:    va_list ap;
        -:  257:    VA_DEF_ARG(const char *message);
        -:  258:
        -:  259:    VA_START(ap, message);
        -:  260:    VA_GET_ARG(ap, message, const char *);
        -:  261:    if ((filename = getsparam_u("ZSH_DEBUG_LOG")) != NULL &&
        -:  262:	(file = fopen(filename, "a")) != NULL) {
        -:  263:	zerrmsg(file, message, ap);
        -:  264:	fclose(file);
        -:  265:    } else
        -:  266:	zerrmsg(stderr, message, ap);
        -:  267:    va_end(ap);
        -:  268:}
        -:  269:
        -:  270:#endif /* DEBUG */
        -:  271:
        -:  272:#ifdef __CYGWIN__
        -:  273:/*
        -:  274: * This works around an occasional problem with dllwrap on Cygwin, seen
        -:  275: * on at least two installations.  It fails to find the last symbol
        -:  276: * exported in alphabetical order (in our case zwarnnam).  Until this is
        -:  277: * properly categorised and fixed we add a dummy symbol at the end.
        -:  278: */
        -:  279:mod_export void
        -:  280:zz_plural_z_alpha(void)
        -:  281:{
        -:  282:}
        -:  283:#endif
        -:  284:
        -:  285:/**/
        -:  286:void
    #####:  287:zerrmsg(FILE *file, const char *fmt, va_list ap)
        -:  288:{
        -:  289:    const char *str;
        -:  290:    int num;
        -:  291:    long lnum;
        -:  292:#ifdef HAVE_STRERROR_R
        -:  293:#define ERRBUFSIZE (80)
        -:  294:    int olderrno;
        -:  295:    char errbuf[ERRBUFSIZE];
        -:  296:#endif
        -:  297:    char *errmsg;
        -:  298:
    #####:  299:    if ((unset(SHINSTDIN) || locallevel) && lineno) {
        -:  300:#if defined(ZLONG_IS_LONG_LONG) && defined(PRINTF_HAS_LLD)
        -:  301:	fprintf(file, "%lld: ", lineno);
        -:  302:#else
    #####:  303:	fprintf(file, "%ld: ", (long)lineno);
        -:  304:#endif
        -:  305:    } else
    #####:  306:	fputc((unsigned char)' ', file);
        -:  307:
    #####:  308:    while (*fmt)
    #####:  309:	if (*fmt == '%') {
    #####:  310:	    fmt++;
    #####:  311:	    switch (*fmt++) {
    #####:  312:	    case 's':
    #####:  313:		str = va_arg(ap, const char *);
    #####:  314:		nicezputs(str, file);
    #####:  315:		break;
    #####:  316:	    case 'l': {
        -:  317:		char *s;
    #####:  318:		str = va_arg(ap, const char *);
    #####:  319:		num = va_arg(ap, int);
    #####:  320:		num = metalen(str, num);
    #####:  321:		s = zhalloc(num + 1);
    #####:  322:		memcpy(s, str, num);
    #####:  323:		s[num] = '\0';
    #####:  324:		nicezputs(s, file);
    #####:  325:		break;
        -:  326:	    }
    #####:  327:	    case 'L':
    #####:  328:		lnum = va_arg(ap, long);
    #####:  329:		fprintf(file, "%ld", lnum);
    #####:  330:		break;
    #####:  331:	    case 'd':
    #####:  332:		num = va_arg(ap, int);
    #####:  333:		fprintf(file, "%d", num);
    #####:  334:		break;
    #####:  335:	    case 'z':
        -:  336:	    {
    #####:  337:		zlong znum = va_arg(ap, zlong);
        -:  338:		char buf[DIGBUFSIZE];
    #####:  339:		convbase(buf, znum, 10);
    #####:  340:		fputs(buf, file);
    #####:  341:		break;
        -:  342:	    }
    #####:  343:	    case '%':
    #####:  344:		putc('%', file);
    #####:  345:		break;
    #####:  346:	    case 'c':
    #####:  347:		num = va_arg(ap, int);
        -:  348:#ifdef MULTIBYTE_SUPPORT
    #####:  349:		mb_charinit();
    #####:  350:		zputs(wcs_nicechar(num, NULL, NULL), file);
        -:  351:#else
        -:  352:		zputs(nicechar(num), file);
        -:  353:#endif
    #####:  354:		break;
    #####:  355:	    case 'e':
        -:  356:		/* print the corresponding message for this errno */
    #####:  357:		num = va_arg(ap, int);
    #####:  358:		if (num == EINTR) {
    #####:  359:		    fputs("interrupt\n", file);
    #####:  360:		    errflag |= ERRFLAG_ERROR;
    #####:  361:		    return;
        -:  362:		}
    #####:  363:		errmsg = strerror(num);
        -:  364:		/* If the message is not about I/O problems, it looks better *
        -:  365:		 * if we uncapitalize the first letter of the message        */
    #####:  366:		if (num == EIO)
    #####:  367:		    fputs(errmsg, file);
        -:  368:		else {
    #####:  369:		    fputc(tulower(errmsg[0]), file);
    #####:  370:		    fputs(errmsg + 1, file);
        -:  371:		}
    #####:  372:		break;
        -:  373:	    /* When adding format codes, update the comment above zwarning(). */
        -:  374:	    }
        -:  375:	} else {
    #####:  376:	    putc(*fmt == Meta ? *++fmt ^ 32 : *fmt, file);
    #####:  377:	    fmt++;
        -:  378:	}
    #####:  379:    putc('\n', file);
    #####:  380:    fflush(file);
        -:  381:}
        -:  382:
        -:  383:/*
        -:  384: * Wrapper for setupterm() and del_curterm().
        -:  385: * These are called from terminfo.c and termcap.c.
        -:  386: */
        -:  387:static int term_count;	/* reference count of cur_term */
        -:  388:
        -:  389:/**/
        -:  390:mod_export void
    #####:  391:zsetupterm(void)
        -:  392:{
        -:  393:#ifdef HAVE_SETUPTERM
        -:  394:    int errret;
        -:  395:
        -:  396:    DPUTS(term_count < 0 || (term_count > 0 && !cur_term),
        -:  397:	    "inconsistent term_count and/or cur_term");
        -:  398:    /*
        -:  399:     * Just because we can't set up the terminal doesn't
        -:  400:     * mean the modules hasn't booted---TERM may change,
        -:  401:     * and it should be handled dynamically---so ignore errors here.
        -:  402:     */
    #####:  403:    if (term_count++ == 0)
    #####:  404:	(void)setupterm((char *)0, 1, &errret);
        -:  405:#endif
    #####:  406:}
        -:  407:
        -:  408:/**/
        -:  409:mod_export void
    #####:  410:zdeleteterm(void)
        -:  411:{
        -:  412:#ifdef HAVE_SETUPTERM
        -:  413:    DPUTS(term_count < 1 || !cur_term,
        -:  414:	    "inconsistent term_count and/or cur_term");
    #####:  415:    if (--term_count == 0)
    #####:  416:	del_curterm(cur_term);
        -:  417:#endif
    #####:  418:}
        -:  419:
        -:  420:/* Output a single character, for the termcap routines.     *
        -:  421: * This is used instead of putchar since it can be a macro. */
        -:  422:
        -:  423:/**/
        -:  424:mod_export int
    #####:  425:putraw(int c)
        -:  426:{
    #####:  427:    putc(c, stdout);
    #####:  428:    return 0;
        -:  429:}
        -:  430:
        -:  431:/* Output a single character, for the termcap routines. */
        -:  432:
        -:  433:/**/
        -:  434:mod_export int
    #####:  435:putshout(int c)
        -:  436:{
    #####:  437:    putc(c, shout);
    #####:  438:    return 0;
        -:  439:}
        -:  440:
        -:  441:#ifdef MULTIBYTE_SUPPORT
        -:  442:/*
        -:  443: * Turn a character into a visible representation thereof.  The visible
        -:  444: * string is put together in a static buffer, and this function returns
        -:  445: * a pointer to it.  Printable characters stand for themselves, DEL is
        -:  446: * represented as "^?", newline and tab are represented as "\n" and
        -:  447: * "\t", and normal control characters are represented in "^C" form.
        -:  448: * Characters with bit 7 set, if unprintable, are represented as "\M-"
        -:  449: * followed by the visible representation of the character with bit 7
        -:  450: * stripped off.  Tokens are interpreted, rather than being treated as
        -:  451: * literal characters.
        -:  452: *
        -:  453: * Note that the returned string is metafied, so that it must be
        -:  454: * treated like any other zsh internal string (and not, for example,
        -:  455: * output directly).
        -:  456: *
        -:  457: * This function is used even if MULTIBYTE_SUPPORT is defined: we
        -:  458: * use it as a fallback in case we couldn't identify a wide character
        -:  459: * in a multibyte string.
        -:  460: */
        -:  461:
        -:  462:/**/
        -:  463:mod_export char *
    #####:  464:nicechar_sel(int c, int quotable)
        -:  465:{
        -:  466:    static char buf[10];
    #####:  467:    char *s = buf;
    #####:  468:    c &= 0xff;
    #####:  469:    if (ZISPRINT(c))
    #####:  470:	goto done;
    #####:  471:    if (c & 0x80) {
    #####:  472:	if (isset(PRINTEIGHTBIT))
    #####:  473:	    goto done;
    #####:  474:	*s++ = '\\';
    #####:  475:	*s++ = 'M';
    #####:  476:	*s++ = '-';
    #####:  477:	c &= 0x7f;
    #####:  478:	if(ZISPRINT(c))
    #####:  479:	    goto done;
        -:  480:    }
    #####:  481:    if (c == 0x7f) {
    #####:  482:	if (quotable) {
    #####:  483:	    *s++ = '\\';
    #####:  484:	    *s++ = 'C';
    #####:  485:	    *s++ = '-';
        -:  486:	} else
    #####:  487:	    *s++ = '^';
    #####:  488:	c = '?';
    #####:  489:    } else if (c == '\n') {
    #####:  490:	*s++ = '\\';
    #####:  491:	c = 'n';
    #####:  492:    } else if (c == '\t') {
    #####:  493:	*s++ = '\\';
    #####:  494:	c = 't';
    #####:  495:    } else if (c < 0x20) {
    #####:  496:	if (quotable) {
    #####:  497:	    *s++ = '\\';
    #####:  498:	    *s++ = 'C';
    #####:  499:	    *s++ = '-';
        -:  500:	} else
    #####:  501:	    *s++ = '^';
    #####:  502:	c += 0x40;
        -:  503:    }
    #####:  504:    done:
        -:  505:    /*
        -:  506:     * The resulting string is still metafied, so check if
        -:  507:     * we are returning a character in the range that needs metafication.
        -:  508:     * This can't happen if the character is printed "nicely", so
        -:  509:     * this results in a maximum of two bytes total (plus the null).
        -:  510:     */
    #####:  511:    if (imeta(c)) {
    #####:  512:	*s++ = Meta;
    #####:  513:	*s++ = c ^ 32;
        -:  514:    } else
    #####:  515:	*s++ = c;
    #####:  516:    *s = 0;
    #####:  517:    return buf;
        -:  518:}
        -:  519:
        -:  520:/**/
        -:  521:mod_export char *
    #####:  522:nicechar(int c)
        -:  523:{
    #####:  524:    return nicechar_sel(c, 0);
        -:  525:}
        -:  526:
        -:  527:#else /* MULTIBYTE_SUPPORT */
        -:  528:
        -:  529:/**/
        -:  530:mod_export char *
        -:  531:nicechar(int c)
        -:  532:{
        -:  533:    static char buf[10];
        -:  534:    char *s = buf;
        -:  535:    c &= 0xff;
        -:  536:    if (ZISPRINT(c))
        -:  537:	goto done;
        -:  538:    if (c & 0x80) {
        -:  539:	if (isset(PRINTEIGHTBIT))
        -:  540:	    goto done;
        -:  541:	*s++ = '\\';
        -:  542:	*s++ = 'M';
        -:  543:	*s++ = '-';
        -:  544:	c &= 0x7f;
        -:  545:	if(ZISPRINT(c))
        -:  546:	    goto done;
        -:  547:    }
        -:  548:    if (c == 0x7f) {
        -:  549:	*s++ = '\\';
        -:  550:	*s++ = 'C';
        -:  551:	*s++ = '-';
        -:  552:	c = '?';
        -:  553:    } else if (c == '\n') {
        -:  554:	*s++ = '\\';
        -:  555:	c = 'n';
        -:  556:    } else if (c == '\t') {
        -:  557:	*s++ = '\\';
        -:  558:	c = 't';
        -:  559:    } else if (c < 0x20) {
        -:  560:	*s++ = '\\';
        -:  561:	*s++ = 'C';
        -:  562:	*s++ = '-';
        -:  563:	c += 0x40;
        -:  564:    }
        -:  565:    done:
        -:  566:    /*
        -:  567:     * The resulting string is still metafied, so check if
        -:  568:     * we are returning a character in the range that needs metafication.
        -:  569:     * This can't happen if the character is printed "nicely", so
        -:  570:     * this results in a maximum of two bytes total (plus the null).
        -:  571:     */
        -:  572:    if (imeta(c)) {
        -:  573:	*s++ = Meta;
        -:  574:	*s++ = c ^ 32;
        -:  575:    } else
        -:  576:	*s++ = c;
        -:  577:    *s = 0;
        -:  578:    return buf;
        -:  579:}
        -:  580:
        -:  581:#endif /* MULTIBYTE_SUPPORT */
        -:  582:
        -:  583:/*
        -:  584: * Return 1 if nicechar() would reformat this character.
        -:  585: */
        -:  586:
        -:  587:/**/
        -:  588:mod_export int
    #####:  589:is_nicechar(int c)
        -:  590:{
    #####:  591:    c &= 0xff;
    #####:  592:    if (ZISPRINT(c))
    #####:  593:	return 0;
    #####:  594:    if (c & 0x80)
    #####:  595:	return !isset(PRINTEIGHTBIT);
    #####:  596:    return (c == 0x7f || c == '\n' || c == '\t' || c < 0x20);
        -:  597:}
        -:  598:
        -:  599:/**/
        -:  600:#ifdef MULTIBYTE_SUPPORT
        -:  601:static mbstate_t mb_shiftstate;
        -:  602:
        -:  603:/*
        -:  604: * Initialise multibyte state: called before a sequence of
        -:  605: * wcs_nicechar(), mb_metacharlenconv(), or
        -:  606: * mb_charlenconv().
        -:  607: */
        -:  608:
        -:  609:/**/
        -:  610:mod_export void
     2482:  611:mb_charinit(void)
        -:  612:{
     2482:  613:    memset(&mb_shiftstate, 0, sizeof(mb_shiftstate));
     2482:  614:}
        -:  615:
        -:  616:/*
        -:  617: * The number of bytes we need to allocate for a "nice" representation
        -:  618: * of a multibyte character.
        -:  619: *
        -:  620: * We double MB_CUR_MAX to take account of the fact that
        -:  621: * we may need to metafy.  In fact the representation probably
        -:  622: * doesn't allow every character to be in the meta range, but
        -:  623: * we don't need to be too pedantic.
        -:  624: *
        -:  625: * The 12 is for the output of a UCS-4 code; we don't actually
        -:  626: * need this at the same time as MB_CUR_MAX, but again it's
        -:  627: * not worth calculating more exactly.
        -:  628: */
        -:  629:#define NICECHAR_MAX (12 + 2*MB_CUR_MAX)
        -:  630:/*
        -:  631: * Input a wide character.  Output a printable representation,
        -:  632: * which is a metafied multibyte string.   With widthp return
        -:  633: * the printing width.
        -:  634: *
        -:  635: * swide, if non-NULL, is used to help the completion code, which needs
        -:  636: * to know the printing width of the each part of the representation.
        -:  637: * *swide is set to the part of the returned string where the wide
        -:  638: * character starts.  Any string up to that point is ASCII characters,
        -:  639: * so the width of it is (*swide - <return_value>).  Anything left is
        -:  640: * a single wide character corresponding to the remaining width.
        -:  641: * Either the initial ASCII part or the wide character part may be empty
        -:  642: * (but not both).  (Note the complication that the wide character
        -:  643: * part may contain metafied characters.)
        -:  644: *
        -:  645: * The caller needs to call mb_charinit() before the first call, to
        -:  646: * set up the multibyte shift state for a range of characters.
        -:  647: */
        -:  648:
        -:  649:/**/
        -:  650:mod_export char *
    #####:  651:wcs_nicechar_sel(wchar_t c, size_t *widthp, char **swidep, int quotable)
        -:  652:{
        -:  653:    static char *buf;
        -:  654:    static int bufalloc = 0, newalloc;
        -:  655:    char *s, *mbptr;
    #####:  656:    int ret = 0;
    #####:  657:    VARARR(char, mbstr, MB_CUR_MAX);
        -:  658:
        -:  659:    /*
        -:  660:     * We want buf to persist beyond the return.  MB_CUR_MAX and hence
        -:  661:     * NICECHAR_MAX may not be constant, so we have to allocate this at
        -:  662:     * run time.  (We could probably get away with just allocating a
        -:  663:     * large buffer, in practice.)  For efficiency, only reallocate if
        -:  664:     * we really need to, since this function will be called frequently.
        -:  665:     */
    #####:  666:    newalloc = NICECHAR_MAX;
    #####:  667:    if (bufalloc != newalloc)
        -:  668:    {
    #####:  669:	bufalloc = newalloc;
    #####:  670:	buf = (char *)zrealloc(buf, bufalloc);
        -:  671:    }
        -:  672:
    #####:  673:    s = buf;
    #####:  674:    if (!WC_ISPRINT(c) && (c < 0x80 || !isset(PRINTEIGHTBIT))) {
    #####:  675:	if (c == 0x7f) {
    #####:  676:	    if (quotable) {
    #####:  677:		*s++ = '\\';
    #####:  678:		*s++ = 'C';
    #####:  679:		*s++ = '-';
        -:  680:	    } else
    #####:  681:		*s++ = '^';
    #####:  682:	    c = '?';
    #####:  683:	} else if (c == L'\n') {
    #####:  684:	    *s++ = '\\';
    #####:  685:	    c = 'n';
    #####:  686:	} else if (c == L'\t') {
    #####:  687:	    *s++ = '\\';
    #####:  688:	    c = 't';
    #####:  689:	} else if (c < 0x20) {
    #####:  690:	    if (quotable) {
    #####:  691:		*s++ = '\\';
    #####:  692:		*s++ = 'C';
    #####:  693:		*s++ = '-';
        -:  694:	    } else
    #####:  695:		*s++ = '^';
    #####:  696:	    c += 0x40;
    #####:  697:	} else if (c >= 0x80) {
    #####:  698:	    ret = -1;
        -:  699:	}
        -:  700:    }
        -:  701:
    #####:  702:    if (ret != -1)
    #####:  703:	ret = wcrtomb(mbstr, c, &mb_shiftstate);
        -:  704:
    #####:  705:    if (ret == -1) {
    #####:  706:	memset(&mb_shiftstate, 0, sizeof(mb_shiftstate));
        -:  707:	/*
        -:  708:	 * Can't or don't want to convert character: use UCS-2 or
        -:  709:	 * UCS-4 code in print escape format.
        -:  710:	 *
        -:  711:	 * This comparison fails and generates a compiler warning
        -:  712:	 * if wchar_t is 16 bits, but the code is still correct.
        -:  713:	 */
    #####:  714:	if (c >=  0x10000) {
    #####:  715:	    sprintf(buf, "\\U%.8x", (unsigned int)c);
    #####:  716:	    if (widthp)
    #####:  717:		*widthp = 10;
    #####:  718:	} else if (c >= 0x100) {
    #####:  719:	    sprintf(buf, "\\u%.4x", (unsigned int)c);
    #####:  720:	    if (widthp)
    #####:  721:		*widthp = 6;
        -:  722:	} else {
    #####:  723:	    strcpy(buf, nicechar_sel((int)c, quotable));
        -:  724:	    /*
        -:  725:	     * There may be metafied characters from nicechar(),
        -:  726:	     * so compute width and end position independently.
        -:  727:	     */
    #####:  728:	    if (widthp)
    #####:  729:		*widthp = ztrlen(buf);
    #####:  730:	    if (swidep)
    #####:  731:	      *swidep = buf + strlen(buf);
    #####:  732:	    return buf;
        -:  733:	}
    #####:  734:	if (swidep)
    #####:  735:	    *swidep = widthp ? buf + *widthp : buf;
    #####:  736:	return buf;
        -:  737:    }
        -:  738:
    #####:  739:    if (widthp) {
    #####:  740:	int wcw = WCWIDTH(c);
    #####:  741:	*widthp = (s - buf);
    #####:  742:	if (wcw >= 0)
    #####:  743:	    *widthp += wcw;
        -:  744:	else
    #####:  745:	    (*widthp)++;
        -:  746:    }
    #####:  747:    if (swidep)
    #####:  748:	*swidep = s;
    #####:  749:    for (mbptr = mbstr; ret; s++, mbptr++, ret--) {
        -:  750:	DPUTS(s >= buf + NICECHAR_MAX,
        -:  751:	      "BUG: buffer too small in wcs_nicechar");
    #####:  752:	if (imeta(*mbptr)) {
    #####:  753:	    *s++ = Meta;
        -:  754:	    DPUTS(s >= buf + NICECHAR_MAX,
        -:  755:		  "BUG: buffer too small for metafied char in wcs_nicechar");
    #####:  756:	    *s = *mbptr ^ 32;
        -:  757:	} else {
    #####:  758:	    *s = *mbptr;
        -:  759:	}
        -:  760:    }
    #####:  761:    *s = 0;
    #####:  762:    return buf;
        -:  763:}
        -:  764:
        -:  765:/**/
        -:  766:mod_export char *
    #####:  767:wcs_nicechar(wchar_t c, size_t *widthp, char **swidep)
        -:  768:{
    #####:  769:    return wcs_nicechar_sel(c, widthp, swidep, 0);
        -:  770:}
        -:  771:
        -:  772:/*
        -:  773: * Return 1 if wcs_nicechar() would reformat this character for display.
        -:  774: */
        -:  775:
        -:  776:/**/
    #####:  777:mod_export int is_wcs_nicechar(wchar_t c)
        -:  778:{
    #####:  779:    if (!WC_ISPRINT(c) && (c < 0x80 || !isset(PRINTEIGHTBIT))) {
    #####:  780:	if (c == 0x7f || c == L'\n' || c == L'\t' || c < 0x20)
    #####:  781:	    return 1;
    #####:  782:	if (c >= 0x80) {
    #####:  783:	    return (c >= 0x100 || is_nicechar((int)c));
        -:  784:	}
        -:  785:    }
    #####:  786:    return 0;
        -:  787:}
        -:  788:
        -:  789:/**/
        -:  790:mod_export int
    #####:  791:zwcwidth(wint_t wc)
        -:  792:{
        -:  793:    int wcw;
        -:  794:    /* assume a single-byte character if not valid */
    #####:  795:    if (wc == WEOF || unset(MULTIBYTE))
    #####:  796:	return 1;
    #####:  797:    wcw = WCWIDTH(wc);
        -:  798:    /* if not printable, assume width 1 */
    #####:  799:    if (wcw < 0)
    #####:  800:	return 1;
    #####:  801:    return wcw;
        -:  802:}
        -:  803:
        -:  804:/**/
        -:  805:#endif /* MULTIBYTE_SUPPORT */
        -:  806:
        -:  807:/*
        -:  808: * Search the path for prog and return the file name.
        -:  809: * The returned value is unmetafied and in the unmeta storage
        -:  810: * area (N.B. should be duplicated if not used immediately and not
        -:  811: * equal to *namep).
        -:  812: *
        -:  813: * If namep is not NULL, *namep is set to the metafied programme
        -:  814: * name, which is in heap storage.
        -:  815: */
        -:  816:/**/
        -:  817:char *
    #####:  818:pathprog(char *prog, char **namep)
        -:  819:{
    #####:  820:    char **pp, ppmaxlen = 0, *buf, *funmeta;
        -:  821:    struct stat st;
        -:  822:
    #####:  823:    for (pp = path; *pp; pp++)
        -:  824:    {
    #####:  825:	int len = strlen(*pp);
    #####:  826:	if (len > ppmaxlen)
    #####:  827:	    ppmaxlen = len;
        -:  828:    }
    #####:  829:    buf = zhalloc(ppmaxlen + strlen(prog) + 2);
    #####:  830:    for (pp = path; *pp; pp++) {
    #####:  831:	sprintf(buf, "%s/%s", *pp, prog);
    #####:  832:	funmeta = unmeta(buf);
    #####:  833:	if (access(funmeta, F_OK) == 0 &&
    #####:  834:	    stat(funmeta, &st) >= 0 &&
    #####:  835:	    !S_ISDIR(st.st_mode)) {
    #####:  836:	    if (namep)
    #####:  837:		*namep = buf;
    #####:  838:	    return funmeta;
        -:  839:	}
        -:  840:    }
        -:  841:
    #####:  842:    return NULL;
        -:  843:}
        -:  844:
        -:  845:/* get a symlink-free pathname for s relative to PWD */
        -:  846:
        -:  847:/**/
        -:  848:char *
    #####:  849:findpwd(char *s)
        -:  850:{
        -:  851:    char *t;
        -:  852:
    #####:  853:    if (*s == '/')
    #####:  854:	return xsymlink(s, 0);
    #####:  855:    s = tricat((pwd[1]) ? pwd : "", "/", s);
    #####:  856:    t = xsymlink(s, 0);
    #####:  857:    zsfree(s);
    #####:  858:    return t;
        -:  859:}
        -:  860:
        -:  861:/* Check whether a string contains the *
        -:  862: * name of the present directory.      */
        -:  863:
        -:  864:/**/
        -:  865:int
        4:  866:ispwd(char *s)
        -:  867:{
        -:  868:    struct stat sbuf, tbuf;
        -:  869:
        -:  870:    /* POSIX: environment PWD must be absolute */
        4:  871:    if (*s != '/')
    #####:  872:	return 0;
        -:  873:
        4:  874:    if (stat((s = unmeta(s)), &sbuf) == 0 && stat(".", &tbuf) == 0)
        4:  875:	if (sbuf.st_dev == tbuf.st_dev && sbuf.st_ino == tbuf.st_ino) {
        -:  876:	    /* POSIX: No element of $PWD may be "." or ".." */
       12:  877:	    while (*s) {
        8:  878:		if (s[0] == '.' &&
    #####:  879:		    (!s[1] || s[1] == '/' ||
    #####:  880:		     (s[1] == '.' && (!s[2] || s[2] == '/'))))
        -:  881:		    break;
       48:  882:		while (*s++ != '/' && *s)
       32:  883:		    continue;
        -:  884:	    }
        2:  885:	    return !*s;
        -:  886:	}
        2:  887:    return 0;
        -:  888:}
        -:  889:
        -:  890:static char xbuf[PATH_MAX*2+1];
        -:  891:
        -:  892:/**/
        -:  893:static char **
    #####:  894:slashsplit(char *s)
        -:  895:{
        -:  896:    char *t, **r, **q;
        -:  897:    int t0;
        -:  898:
    #####:  899:    if (!*s)
    #####:  900:	return (char **) zshcalloc(sizeof(char *));
        -:  901:
    #####:  902:    for (t = s, t0 = 0; *t; t++)
    #####:  903:	if (*t == '/')
    #####:  904:	    t0++;
    #####:  905:    q = r = (char **) zalloc(sizeof(char *) * (t0 + 2));
        -:  906:
    #####:  907:    while ((t = strchr(s, '/'))) {
    #####:  908:	*q++ = ztrduppfx(s, t - s);
    #####:  909:	while (*t == '/')
    #####:  910:	    t++;
    #####:  911:	if (!*t) {
    #####:  912:	    *q = NULL;
    #####:  913:	    return r;
        -:  914:	}
    #####:  915:	s = t;
        -:  916:    }
    #####:  917:    *q++ = ztrdup(s);
    #####:  918:    *q = NULL;
    #####:  919:    return r;
        -:  920:}
        -:  921:
        -:  922:/* expands .. or . expressions and one level of symlinks
        -:  923: *
        -:  924: * Puts the result in the global "xbuf"
        -:  925: */
        -:  926:
        -:  927:/**/
        -:  928:static int
    #####:  929:xsymlinks(char *s)
        -:  930:{
        -:  931:    char **pp, **opp;
        -:  932:    char xbuf2[PATH_MAX*3+1], xbuf3[PATH_MAX*2+1];
    #####:  933:    int t0, ret = 0;
    #####:  934:    zulong xbuflen = strlen(xbuf), pplen;
        -:  935:
    #####:  936:    opp = pp = slashsplit(s);
    #####:  937:    for (; xbuflen < sizeof(xbuf) && *pp && ret >= 0; pp++) {
    #####:  938:	if (!strcmp(*pp, "."))
    #####:  939:	    continue;
    #####:  940:	if (!strcmp(*pp, "..")) {
        -:  941:	    char *p;
        -:  942:
    #####:  943:	    if (!strcmp(xbuf, "/"))
    #####:  944:		continue;
    #####:  945:	    if (!*xbuf)
    #####:  946:		continue;
    #####:  947:	    p = xbuf + xbuflen;
    #####:  948:	    while (*--p != '/')
    #####:  949:		xbuflen--;
    #####:  950:	    *p = '\0';
        -:  951:	    /* The \0 isn't included in the length */
    #####:  952:	    xbuflen--;
    #####:  953:	    continue;
        -:  954:	}
        -:  955:	/* Includes null byte. */
    #####:  956:	pplen = strlen(*pp) + 1;
    #####:  957:	if (xbuflen + pplen + 1 > sizeof(xbuf2)) {
    #####:  958:	    *xbuf = 0;
    #####:  959:	    ret = -1;
    #####:  960:	    break;
        -:  961:	}
    #####:  962:	memcpy(xbuf2, xbuf, xbuflen);
    #####:  963:	xbuf2[xbuflen] = '/';
    #####:  964:	memcpy(xbuf2 + xbuflen + 1, *pp, pplen);
    #####:  965:	t0 = readlink(unmeta(xbuf2), xbuf3, PATH_MAX);
    #####:  966:	if (t0 == -1) {
    #####:  967:	    if ((xbuflen += pplen) < sizeof(xbuf)) {
    #####:  968:		strcat(xbuf, "/");
    #####:  969:		strcat(xbuf, *pp);
        -:  970:	    } else {
    #####:  971:		*xbuf = 0;
    #####:  972:		ret = -1;
    #####:  973:		break;
        -:  974:	    }
        -:  975:	} else {
    #####:  976:	    ret = 1;
    #####:  977:	    metafy(xbuf3, t0, META_NOALLOC);
        -:  978:	    {
        -:  979:		/*
        -:  980:		 * If only one expansion requested, ensure the
        -:  981:		 * full path is in xbuf.
        -:  982:		 */
    #####:  983:		zulong len = xbuflen;
    #####:  984:		if (*xbuf3 == '/')
    #####:  985:		    strcpy(xbuf, xbuf3);
    #####:  986:		else if ((len += strlen(xbuf3) + 1) < sizeof(xbuf)) {
    #####:  987:		    strcpy(xbuf + xbuflen, "/");
    #####:  988:		    strcpy(xbuf + xbuflen + 1, xbuf3);
        -:  989:		} else {
    #####:  990:		    *xbuf = 0;
    #####:  991:		    ret = -1;
    #####:  992:		    break;
        -:  993:		}
        -:  994:
    #####:  995:		while (*++pp) {
    #####:  996:		    zulong newlen = len + strlen(*pp) + 1;
    #####:  997:		    if (newlen < sizeof(xbuf)) {
    #####:  998:			strcpy(xbuf + len, "/");
    #####:  999:			strcpy(xbuf + len + 1, *pp);
    #####: 1000:			len = newlen;
        -: 1001:		    } else {
    #####: 1002:			*xbuf = 01;
    #####: 1003:			ret = -1;
    #####: 1004:			break;
        -: 1005:		    }
        -: 1006:		}
        -: 1007:		/*
        -: 1008:		 * No need to update xbuflen, we're finished
        -: 1009:		 * the expansion (for now).
        -: 1010:		 */
    #####: 1011:		break;
        -: 1012:	    }
        -: 1013:	}
        -: 1014:    }
    #####: 1015:    freearray(opp);
    #####: 1016:    return ret;
        -: 1017:}
        -: 1018:
        -: 1019:/*
        -: 1020: * expand symlinks in s, and remove other weird things:
        -: 1021: * note that this always expands symlinks.
        -: 1022: *
        -: 1023: * 'heap' indicates whether to malloc() or allocate on the heap.
        -: 1024: */
        -: 1025:
        -: 1026:/**/
        -: 1027:mod_export char *
    #####: 1028:xsymlink(char *s, int heap)
        -: 1029:{
    #####: 1030:    if (*s != '/')
    #####: 1031:	return NULL;
    #####: 1032:    *xbuf = '\0';
    #####: 1033:    if (!chrealpath(&s, 'P', heap)) {
    #####: 1034:	zwarn("path expansion failed, using root directory");
    #####: 1035:	return heap ? dupstring("/") : ztrdup("/");
        -: 1036:    }
    #####: 1037:    return s;
        -: 1038:}
        -: 1039:
        -: 1040:/**/
        -: 1041:void
    #####: 1042:print_if_link(char *s, int all)
        -: 1043:{
    #####: 1044:    if (*s == '/') {
    #####: 1045:	if (all) {
    #####: 1046:	    char *start = s + 1;
        -: 1047:	    char xbuflink[PATH_MAX+1];
    #####: 1048:	    *xbuf = '\0';
        -: 1049:	    for (;;) {
    #####: 1050:		if (xsymlinks(start) > 0) {
    #####: 1051:		    printf(" -> ");
    #####: 1052:		    zputs(*xbuf ? xbuf : "/", stdout);
    #####: 1053:		    if (!*xbuf)
    #####: 1054:			break;
    #####: 1055:		    strcpy(xbuflink, xbuf);
    #####: 1056:		    start = xbuflink + 1;
    #####: 1057:		    *xbuf = '\0';
        -: 1058:		} else {
    #####: 1059:		    break;
        -: 1060:		}
        -: 1061:	    }
        -: 1062:	} else {
    #####: 1063:	    if (chrealpath(&s, 'P', 0)) {
    #####: 1064:		printf(" -> ");
    #####: 1065:		zputs(*s ? s : "/", stdout);
    #####: 1066:		zsfree(s);
        -: 1067:	    }
        -: 1068:	}
        -: 1069:    }
    #####: 1070:}
        -: 1071:
        -: 1072:/* print a directory */
        -: 1073:
        -: 1074:/**/
        -: 1075:void
    #####: 1076:fprintdir(char *s, FILE *f)
        -: 1077:{
    #####: 1078:    Nameddir d = finddir(s);
        -: 1079:
    #####: 1080:    if (!d)
    #####: 1081:	fputs(unmeta(s), f);
        -: 1082:    else {
    #####: 1083:	putc('~', f);
    #####: 1084:	fputs(unmeta(d->node.nam), f);
    #####: 1085:	fputs(unmeta(s + strlen(d->dir)), f);
        -: 1086:    }
    #####: 1087:}
        -: 1088:
        -: 1089:/*
        -: 1090: * Substitute a directory using a name.
        -: 1091: * If there is none, return the original argument.
        -: 1092: *
        -: 1093: * At this level all strings involved are metafied.
        -: 1094: */
        -: 1095:
        -: 1096:/**/
        -: 1097:char *
    #####: 1098:substnamedir(char *s)
        -: 1099:{
    #####: 1100:    Nameddir d = finddir(s);
        -: 1101:
    #####: 1102:    if (!d)
    #####: 1103:	return quotestring(s, QT_BACKSLASH);
    #####: 1104:    return zhtricat("~", d->node.nam, quotestring(s + strlen(d->dir),
        -: 1105:						  QT_BACKSLASH));
        -: 1106:}
        -: 1107:
        -: 1108:
        -: 1109:/* Returns the current username.  It caches the username *
        -: 1110: * and uid to try to avoid requerying the password files *
        -: 1111: * or NIS/NIS+ database.                                 */
        -: 1112:
        -: 1113:/**/
        -: 1114:uid_t cached_uid;
        -: 1115:/**/
        -: 1116:char *cached_username;
        -: 1117:
        -: 1118:/**/
        -: 1119:char *
    #####: 1120:get_username(void)
        -: 1121:{
        -: 1122:#ifdef HAVE_GETPWUID
        -: 1123:    struct passwd *pswd;
        -: 1124:    uid_t current_uid;
        -: 1125:
    #####: 1126:    current_uid = getuid();
    #####: 1127:    if (current_uid != cached_uid) {
    #####: 1128:	cached_uid = current_uid;
    #####: 1129:	zsfree(cached_username);
    #####: 1130:	if ((pswd = getpwuid(current_uid)))
    #####: 1131:	    cached_username = ztrdup(pswd->pw_name);
        -: 1132:	else
    #####: 1133:	    cached_username = ztrdup("");
        -: 1134:    }
        -: 1135:#else /* !HAVE_GETPWUID */
        -: 1136:    cached_uid = getuid();
        -: 1137:#endif /* !HAVE_GETPWUID */
    #####: 1138:    return cached_username;
        -: 1139:}
        -: 1140:
        -: 1141:/* static variables needed by finddir(). */
        -: 1142:
        -: 1143:static char *finddir_full;
        -: 1144:static Nameddir finddir_last;
        -: 1145:static int finddir_best;
        -: 1146:
        -: 1147:/* ScanFunc used by finddir(). */
        -: 1148:
        -: 1149:/**/
        -: 1150:static void
    #####: 1151:finddir_scan(HashNode hn, UNUSED(int flags))
        -: 1152:{
    #####: 1153:    Nameddir nd = (Nameddir) hn;
        -: 1154:
    #####: 1155:    if(nd->diff > finddir_best && !dircmp(nd->dir, finddir_full)
    #####: 1156:       && !(nd->node.flags & ND_NOABBREV)) {
    #####: 1157:	finddir_last=nd;
    #####: 1158:	finddir_best=nd->diff;
        -: 1159:    }
    #####: 1160:}
        -: 1161:
        -: 1162:/*
        -: 1163: * See if a path has a named directory as its prefix.
        -: 1164: * If passed a NULL argument, it will invalidate any 
        -: 1165: * cached information.
        -: 1166: *
        -: 1167: * s here is metafied.
        -: 1168: */
        -: 1169:
        -: 1170:/**/
        -: 1171:Nameddir
        4: 1172:finddir(char *s)
        -: 1173:{
        -: 1174:    static struct nameddir homenode = { {NULL, "", 0}, NULL, 0 };
        -: 1175:    static int ffsz;
        -: 1176:    char **ares;
        -: 1177:    int len;
        -: 1178:
        -: 1179:    /* Invalidate directory cache if argument is NULL.  This is called *
        -: 1180:     * whenever a node is added to or removed from the hash table, and *
        -: 1181:     * whenever the value of $HOME changes.  (On startup, too.)        */
        4: 1182:    if (!s) {
        4: 1183:	homenode.dir = home ? home : "";
        4: 1184:	homenode.diff = home ? strlen(home) : 0;
        4: 1185:	if(homenode.diff==1)
    #####: 1186:	    homenode.diff = 0;
        4: 1187:	if(!finddir_full)
        2: 1188:	    finddir_full = zalloc(ffsz = PATH_MAX+1);
        4: 1189:	finddir_full[0] = 0;
        4: 1190:	return finddir_last = NULL;
        -: 1191:    }
        -: 1192:
        -: 1193:#if 0
        -: 1194:    /*
        -: 1195:     * It's not safe to use the cache while we have function
        -: 1196:     * transformations, and it's not clear it's worth the
        -: 1197:     * complexity of guessing here whether subst_string_by_hook
        -: 1198:     * is going to turn up the goods.
        -: 1199:     */
        -: 1200:    if (!strcmp(s, finddir_full) && *finddir_full)
        -: 1201:	return finddir_last;
        -: 1202:#endif
        -: 1203:
    #####: 1204:    if ((int)strlen(s) >= ffsz) {
    #####: 1205:	free(finddir_full);
    #####: 1206:	finddir_full = zalloc(ffsz = strlen(s) * 2);
        -: 1207:    }
    #####: 1208:    strcpy(finddir_full, s);
    #####: 1209:    finddir_best=0;
    #####: 1210:    finddir_last=NULL;
    #####: 1211:    finddir_scan(&homenode.node, 0);
    #####: 1212:    scanhashtable(nameddirtab, 0, 0, 0, finddir_scan, 0);
        -: 1213:
    #####: 1214:    ares = subst_string_by_hook("zsh_directory_name", "d", finddir_full);
    #####: 1215:    if (ares && arrlen_ge(ares, 2) &&
    #####: 1216:	(len = (int)zstrtol(ares[1], NULL, 10)) > finddir_best) {
        -: 1217:	/* better duplicate this string since it's come from REPLY */
    #####: 1218:	finddir_last = (Nameddir)hcalloc(sizeof(struct nameddir));
    #####: 1219:	finddir_last->node.nam = zhtricat("[", dupstring(ares[0]), "]");
    #####: 1220:	finddir_last->dir = dupstrpfx(finddir_full, len);
    #####: 1221:	finddir_last->diff = len - strlen(finddir_last->node.nam);
    #####: 1222:	finddir_best = len;
        -: 1223:    }
        -: 1224:
    #####: 1225:    return finddir_last;
        -: 1226:}
        -: 1227:
        -: 1228:/* add a named directory */
        -: 1229:
        -: 1230:/**/
        -: 1231:mod_export void
    #####: 1232:adduserdir(char *s, char *t, int flags, int always)
        -: 1233:{
        -: 1234:    Nameddir nd;
        -: 1235:    char *eptr;
        -: 1236:
        -: 1237:    /* We don't maintain a hash table in non-interactive shells. */
    #####: 1238:    if (!interact)
    #####: 1239:	return;
        -: 1240:
        -: 1241:    /* The ND_USERNAME flag means that this possible hash table *
        -: 1242:     * entry is derived from a passwd entry.  Such entries are  *
        -: 1243:     * subordinate to explicitly generated entries.             */
    #####: 1244:    if ((flags & ND_USERNAME) && nameddirtab->getnode2(nameddirtab, s))
    #####: 1245:	return;
        -: 1246:
        -: 1247:    /* Normal parameter assignments generate calls to this function, *
        -: 1248:     * with always==0.  Unless the AUTO_NAME_DIRS option is set, we  *
        -: 1249:     * don't let such assignments actually create directory names.   *
        -: 1250:     * Instead, a reference to the parameter as a directory name can *
        -: 1251:     * cause the actual creation of the hash table entry.            */
    #####: 1252:    if (!always && unset(AUTONAMEDIRS) &&
    #####: 1253:	    !nameddirtab->getnode2(nameddirtab, s))
    #####: 1254:	return;
        -: 1255:
    #####: 1256:    if (!t || *t != '/' || strlen(t) >= PATH_MAX) {
        -: 1257:	/* We can't use this value as a directory, so simply remove *
        -: 1258:	 * the corresponding entry in the hash table, if any.       */
    #####: 1259:	HashNode hn = nameddirtab->removenode(nameddirtab, s);
        -: 1260:
    #####: 1261:	if(hn)
    #####: 1262:	    nameddirtab->freenode(hn);
    #####: 1263:	return;
        -: 1264:    }
        -: 1265:
        -: 1266:    /* add the name */
    #####: 1267:    nd = (Nameddir) zshcalloc(sizeof *nd);
    #####: 1268:    nd->node.flags = flags;
    #####: 1269:    eptr = t + strlen(t);
    #####: 1270:    while (eptr > t && eptr[-1] == '/')
    #####: 1271:	eptr--;
    #####: 1272:    if (eptr == t) {
        -: 1273:	/*
        -: 1274:	 * Don't abbreviate multiple slashes at the start of a
        -: 1275:	 * named directory, since these are sometimes used for
        -: 1276:	 * special purposes.
        -: 1277:	 */
    #####: 1278:	nd->dir = metafy(t, -1, META_DUP);
        -: 1279:    } else
    #####: 1280:	nd->dir = metafy(t, eptr - t, META_DUP);
        -: 1281:    /* The variables PWD and OLDPWD are not to be displayed as ~PWD etc. */
    #####: 1282:    if (!strcmp(s, "PWD") || !strcmp(s, "OLDPWD"))
    #####: 1283:	nd->node.flags |= ND_NOABBREV;
    #####: 1284:    nameddirtab->addnode(nameddirtab, metafy(s, -1, META_DUP), nd);
        -: 1285:}
        -: 1286:
        -: 1287:/* Get a named directory: this function can cause a directory name *
        -: 1288: * to be added to the hash table, if it isn't there already.       */
        -: 1289:
        -: 1290:/**/
        -: 1291:char *
    #####: 1292:getnameddir(char *name)
        -: 1293:{
        -: 1294:    Param pm;
        -: 1295:    char *str;
        -: 1296:    Nameddir nd;
        -: 1297:
        -: 1298:    /* Check if it is already in the named directory table */
    #####: 1299:    if ((nd = (Nameddir) nameddirtab->getnode(nameddirtab, name)))
    #####: 1300:	return dupstring(nd->dir);
        -: 1301:
        -: 1302:    /* Check if there is a scalar parameter with this name whose value *
        -: 1303:     * begins with a `/'.  If there is, add it to the hash table and   *
        -: 1304:     * return the new value.                                           */
    #####: 1305:    if ((pm = (Param) paramtab->getnode(paramtab, name)) &&
    #####: 1306:	    (PM_TYPE(pm->node.flags) == PM_SCALAR) &&
    #####: 1307:	    (str = getsparam(name)) && *str == '/') {
    #####: 1308:	pm->node.flags |= PM_NAMEDDIR;
    #####: 1309:	adduserdir(name, str, 0, 1);
    #####: 1310:	return str;
        -: 1311:    }
        -: 1312:
        -: 1313:#ifdef HAVE_GETPWNAM
        -: 1314:    {
        -: 1315:	/* Retrieve an entry from the password table/database for this user. */
        -: 1316:	struct passwd *pw;
    #####: 1317:	if ((pw = getpwnam(name))) {
    #####: 1318:	    char *dir = isset(CHASELINKS) ? xsymlink(pw->pw_dir, 0)
    #####: 1319:		: ztrdup(pw->pw_dir);
    #####: 1320:	    if (dir) {
    #####: 1321:		adduserdir(name, dir, ND_USERNAME, 1);
    #####: 1322:		str = dupstring(dir);
    #####: 1323:		zsfree(dir);
    #####: 1324:		return str;
        -: 1325:	    } else
    #####: 1326:		return dupstring(pw->pw_dir);
        -: 1327:	}
        -: 1328:    }
        -: 1329:#endif /* HAVE_GETPWNAM */
        -: 1330:
        -: 1331:    /* There are no more possible sources of directory names, so give up. */
    #####: 1332:    return NULL;
        -: 1333:}
        -: 1334:
        -: 1335:/*
        -: 1336: * Compare directories.  Both are metafied.
        -: 1337: */
        -: 1338:
        -: 1339:/**/
        -: 1340:static int
    #####: 1341:dircmp(char *s, char *t)
        -: 1342:{
    #####: 1343:    if (s) {
    #####: 1344:	for (; *s == *t; s++, t++)
    #####: 1345:	    if (!*s)
    #####: 1346:		return 0;
    #####: 1347:	if (!*s && *t == '/')
    #####: 1348:	    return 0;
        -: 1349:    }
    #####: 1350:    return 1;
        -: 1351:}
        -: 1352:
        -: 1353:/*
        -: 1354: * Extra functions to call before displaying the prompt.
        -: 1355: * The data is a Prepromptfn.
        -: 1356: */
        -: 1357:
        -: 1358:static LinkList prepromptfns;
        -: 1359:
        -: 1360:/* Add a function to the list of pre-prompt functions. */
        -: 1361:
        -: 1362:/**/
        -: 1363:mod_export void
    #####: 1364:addprepromptfn(voidvoidfnptr_t func)
        -: 1365:{
    #####: 1366:    Prepromptfn ppdat = (Prepromptfn)zalloc(sizeof(struct prepromptfn));
    #####: 1367:    ppdat->func = func;
    #####: 1368:    if (!prepromptfns)
    #####: 1369:	prepromptfns = znewlinklist();
    #####: 1370:    zaddlinknode(prepromptfns, ppdat);
    #####: 1371:}
        -: 1372:
        -: 1373:/* Remove a function from the list of pre-prompt functions. */
        -: 1374:
        -: 1375:/**/
        -: 1376:mod_export void
    #####: 1377:delprepromptfn(voidvoidfnptr_t func)
        -: 1378:{
        -: 1379:    LinkNode ln;
        -: 1380:
    #####: 1381:    for (ln = firstnode(prepromptfns); ln; ln = nextnode(ln)) {
    #####: 1382:	Prepromptfn ppdat = (Prepromptfn)getdata(ln);
    #####: 1383:	if (ppdat->func == func) {
    #####: 1384:	    (void)remnode(prepromptfns, ln);
    #####: 1385:	    zfree(ppdat, sizeof(struct prepromptfn));
    #####: 1386:	    return;
        -: 1387:	}
        -: 1388:    }
        -: 1389:#ifdef DEBUG
        -: 1390:    dputs("BUG: failed to delete node from prepromptfns");
        -: 1391:#endif
        -: 1392:}
        -: 1393:
        -: 1394:/*
        -: 1395: * Functions to call at a particular time even if not at
        -: 1396: * the prompt.  This is handled by zle.  The data is a
        -: 1397: * Timedfn.  The functions must be in time order, but this
        -: 1398: * is enforced by addtimedfn().
        -: 1399: *
        -: 1400: * Note on debugging:  the code in sched.c currently assumes it's
        -: 1401: * the only user of timedfns for the purposes of checking whether
        -: 1402: * there's a function on the list.  If this becomes no longer the case,
        -: 1403: * the DPUTS() tests in sched.c need rewriting.
        -: 1404: */
        -: 1405:
        -: 1406:/**/
        -: 1407:mod_export LinkList timedfns;
        -: 1408:
        -: 1409:/* Add a function to the list of timed functions. */
        -: 1410:
        -: 1411:/**/
        -: 1412:mod_export void
    #####: 1413:addtimedfn(voidvoidfnptr_t func, time_t when)
        -: 1414:{
    #####: 1415:    Timedfn tfdat = (Timedfn)zalloc(sizeof(struct timedfn));
    #####: 1416:    tfdat->func = func;
    #####: 1417:    tfdat->when = when;
        -: 1418:
    #####: 1419:    if (!timedfns) {
    #####: 1420:	timedfns = znewlinklist();
    #####: 1421:	zaddlinknode(timedfns, tfdat);
        -: 1422:    } else {
    #####: 1423:	LinkNode ln = firstnode(timedfns);
        -: 1424:
        -: 1425:	/*
        -: 1426:	 * Insert the new element in the linked list.  We do
        -: 1427:	 * rather too much work here since the standard
        -: 1428:	 * functions insert after a given node, whereas we
        -: 1429:	 * want to insert the new data before the first element
        -: 1430:	 * with a greater time.
        -: 1431:	 *
        -: 1432:	 * In practice, the only use of timed functions is
        -: 1433:	 * sched, which only adds the one function; so this
        -: 1434:	 * whole branch isn't used beyond the following block.
        -: 1435:	 */
    #####: 1436:	if (!ln) {
    #####: 1437:	    zaddlinknode(timedfns, tfdat);
    #####: 1438:	    return;
        -: 1439:	}
    #####: 1440:	for (;;) {
        -: 1441:	    Timedfn tfdat2;
    #####: 1442:	    LinkNode next = nextnode(ln);
    #####: 1443:	    if (!next) {
    #####: 1444:		zaddlinknode(timedfns, tfdat);
    #####: 1445:		return;
        -: 1446:	    }
    #####: 1447:	    tfdat2 = (Timedfn)getdata(next);
    #####: 1448:	    if (when < tfdat2->when) {
    #####: 1449:		zinsertlinknode(timedfns, ln, tfdat);
    #####: 1450:		return;
        -: 1451:	    }
    #####: 1452:	    ln = next;
        -: 1453:	}
        -: 1454:    }
        -: 1455:}
        -: 1456:
        -: 1457:/*
        -: 1458: * Delete a function from the list of timed functions.
        -: 1459: * Note that if the function apperas multiple times only
        -: 1460: * the first occurrence will be removed.
        -: 1461: *
        -: 1462: * Note also that when zle calls the function it does *not*
        -: 1463: * automatically delete the entry from the list.  That must
        -: 1464: * be done by the function called.  This is recommended as otherwise
        -: 1465: * the function will keep being called immediately.  (It just so
        -: 1466: * happens this "feature" fits in well with the only current use
        -: 1467: * of timed functions.)
        -: 1468: */
        -: 1469:
        -: 1470:/**/
        -: 1471:mod_export void
    #####: 1472:deltimedfn(voidvoidfnptr_t func)
        -: 1473:{
        -: 1474:    LinkNode ln;
        -: 1475:
    #####: 1476:    for (ln = firstnode(timedfns); ln; ln = nextnode(ln)) {
    #####: 1477:	Timedfn ppdat = (Timedfn)getdata(ln);
    #####: 1478:	if (ppdat->func == func) {
    #####: 1479:	    (void)remnode(timedfns, ln);
    #####: 1480:	    zfree(ppdat, sizeof(struct timedfn));
    #####: 1481:	    return;
        -: 1482:	}
        -: 1483:    }
        -: 1484:#ifdef DEBUG
        -: 1485:    dputs("BUG: failed to delete node from timedfns");
        -: 1486:#endif
        -: 1487:}
        -: 1488:
        -: 1489:/* the last time we checked mail */
        -: 1490:
        -: 1491:/**/
        -: 1492:time_t lastmailcheck;
        -: 1493:
        -: 1494:/* the last time we checked the people in the WATCH variable */
        -: 1495:
        -: 1496:/**/
        -: 1497:time_t lastwatch;
        -: 1498:
        -: 1499:/*
        -: 1500: * Call a function given by "name" with optional arguments
        -: 1501: * "lnklst".  If these are present the first argument is the function name.
        -: 1502: *
        -: 1503: * If "arrayp" is not zero, we also look through
        -: 1504: * the array "name"_functions and execute functions found there.
        -: 1505: *
        -: 1506: * If "retval" is not NULL, the return value of the first hook function to
        -: 1507: * return non-zero is stored in *"retval".  The return value is not otherwise
        -: 1508: * available as the calling context is restored.
        -: 1509: *
        -: 1510: * Returns 0 if at least one function was called (regardless of that function's
        -: 1511: * exit status), and 1 otherwise.
        -: 1512: */
        -: 1513:
        -: 1514:/**/
        -: 1515:mod_export int
        3: 1516:callhookfunc(char *name, LinkList lnklst, int arrayp, int *retval)
        -: 1517:{
        -: 1518:    Shfunc shfunc;
        -: 1519:	/*
        -: 1520:	 * Save stopmsg, since user doesn't get a chance to respond
        -: 1521:	 * to a list of jobs generated in a hook.
        -: 1522:	 */
        3: 1523:    int osc = sfcontext, osm = stopmsg, stat = 1, ret = 0;
        3: 1524:    int old_incompfunc = incompfunc;
        -: 1525:
        3: 1526:    sfcontext = SFC_HOOK;
        3: 1527:    incompfunc = 0;
        -: 1528:
        3: 1529:    if ((shfunc = getshfunc(name))) {
    #####: 1530:	if (!lnklst) {
    #####: 1531:	    lnklst = newlinklist();
    #####: 1532:	    addlinknode(lnklst, name);
        -: 1533:	}
    #####: 1534:	ret = doshfunc(shfunc, lnklst, 1);
    #####: 1535:	stat = 0;
        -: 1536:    }
        -: 1537:
        3: 1538:    if (arrayp) {
        -: 1539:	char **arrptr;
        3: 1540:	int namlen = strlen(name);
        3: 1541:	VARARR(char, arrnam, namlen + HOOK_SUFFIX_LEN);
        3: 1542:	memcpy(arrnam, name, namlen);
        3: 1543:	memcpy(arrnam + namlen, HOOK_SUFFIX, HOOK_SUFFIX_LEN);
        -: 1544:
        3: 1545:	if ((arrptr = getaparam(arrnam))) {
    #####: 1546:	    char **argarr = lnklst ? hlinklist2array(lnklst, 0) : NULL;
    #####: 1547:	    arrptr = arrdup(arrptr);
    #####: 1548:	    for (; *arrptr; arrptr++) {
    #####: 1549:		if ((shfunc = getshfunc(*arrptr))) {
    #####: 1550:		    int newret, i = 1;
    #####: 1551:		    LinkList arg0 = newlinklist();
    #####: 1552:		    addlinknode(arg0, *arrptr);
    #####: 1553:		    while (argarr && argarr[i])
    #####: 1554:			addlinknode(arg0, argarr[i++]);
    #####: 1555:		    newret = doshfunc(shfunc, arg0, 1);
    #####: 1556:		    if (!ret)
    #####: 1557:			ret = newret;
    #####: 1558:		    stat = 0;
        -: 1559:		}
        -: 1560:	    }
        -: 1561:	}
        -: 1562:    }
        -: 1563:
        3: 1564:    sfcontext = osc;
        3: 1565:    stopmsg = osm;
        3: 1566:    incompfunc = old_incompfunc;
        -: 1567:
        3: 1568:    if (retval)
    #####: 1569:	*retval = ret;
        3: 1570:    return stat;
        -: 1571:}
        -: 1572:
        -: 1573:/* do pre-prompt stuff */
        -: 1574:
        -: 1575:/**/
        -: 1576:void
    #####: 1577:preprompt(void)
        -: 1578:{
        -: 1579:    static time_t lastperiodic;
        -: 1580:    time_t currentmailcheck;
        -: 1581:    LinkNode ln;
    #####: 1582:    zlong period = getiparam("PERIOD");
    #####: 1583:    zlong mailcheck = getiparam("MAILCHECK");
        -: 1584:
        -: 1585:    /*
        -: 1586:     * Handle any pending window size changes before we compute prompts,
        -: 1587:     * then block them again to avoid interrupts during prompt display.
        -: 1588:     */
    #####: 1589:    winch_unblock();
    #####: 1590:    winch_block();
        -: 1591:
    #####: 1592:    if (isset(PROMPTSP) && isset(PROMPTCR) && !use_exit_printed && shout) {
        -: 1593:	/* The PROMPT_SP heuristic will move the prompt down to a new line
        -: 1594:	 * if there was any dangling output on the line (assuming the terminal
        -: 1595:	 * has automatic margins, but we try even if hasam isn't set).
        -: 1596:	 * Unfortunately it interacts badly with ZLE displaying message
        -: 1597:	 * when ^D has been pressed. So just disable PROMPT_SP logic in
        -: 1598:	 * this case */
    #####: 1599:	char *eolmark = getsparam("PROMPT_EOL_MARK");
        -: 1600:	char *str;
    #####: 1601:	int percents = opts[PROMPTPERCENT], w = 0;
    #####: 1602:	if (!eolmark)
    #####: 1603:	    eolmark = "%B%S%#%s%b";
    #####: 1604:	opts[PROMPTPERCENT] = 1;
    #####: 1605:	str = promptexpand(eolmark, 1, NULL, NULL, NULL);
    #####: 1606:	countprompt(str, &w, 0, -1);
    #####: 1607:	opts[PROMPTPERCENT] = percents;
    #####: 1608:	zputs(str, shout);
    #####: 1609:	fprintf(shout, "%*s\r%*s\r", (int)zterm_columns - w - !hasxn,
        -: 1610:		"", w, "");
    #####: 1611:	fflush(shout);
    #####: 1612:	free(str);
        -: 1613:    }
        -: 1614:
        -: 1615:    /* If NOTIFY is not set, then check for completed *
        -: 1616:     * jobs before we print the prompt.               */
    #####: 1617:    if (unset(NOTIFY))
    #####: 1618:	scanjobs();
    #####: 1619:    if (errflag)
    #####: 1620:	return;
        -: 1621:
        -: 1622:    /* If a shell function named "precmd" exists, *
        -: 1623:     * then execute it.                           */
    #####: 1624:    callhookfunc("precmd", NULL, 1, NULL);
    #####: 1625:    if (errflag)
    #####: 1626:	return;
        -: 1627:
        -: 1628:    /* If 1) the parameter PERIOD exists, 2) a hook function for    *
        -: 1629:     * "periodic" exists, 3) it's been greater than PERIOD since we *
        -: 1630:     * executed any such hook, then execute it now.                 */
    #####: 1631:    if (period && ((zlong)time(NULL) > (zlong)lastperiodic + period) &&
    #####: 1632:	!callhookfunc("periodic", NULL, 1, NULL))
    #####: 1633:	lastperiodic = time(NULL);
    #####: 1634:    if (errflag)
    #####: 1635:	return;
        -: 1636:
        -: 1637:    /* If WATCH is set, then check for the *
        -: 1638:     * specified login/logout events.      */
    #####: 1639:    if (watch) {
    #####: 1640:	if ((int) difftime(time(NULL), lastwatch) > getiparam("LOGCHECK")) {
    #####: 1641:	    dowatch();
    #####: 1642:	    lastwatch = time(NULL);
        -: 1643:	}
        -: 1644:    }
    #####: 1645:    if (errflag)
    #####: 1646:	return;
        -: 1647:
        -: 1648:    /* Check mail */
    #####: 1649:    currentmailcheck = time(NULL);
    #####: 1650:    if (mailcheck &&
    #####: 1651:	(zlong) difftime(currentmailcheck, lastmailcheck) > mailcheck) {
        -: 1652:	char *mailfile;
        -: 1653:
    #####: 1654:	if (mailpath && *mailpath && **mailpath)
    #####: 1655:	    checkmailpath(mailpath);
        -: 1656:	else {
    #####: 1657:	    queue_signals();
    #####: 1658:	    if ((mailfile = getsparam("MAIL")) && *mailfile) {
        -: 1659:		char *x[2];
        -: 1660:
    #####: 1661:		x[0] = mailfile;
    #####: 1662:		x[1] = NULL;
    #####: 1663:		checkmailpath(x);
        -: 1664:	    }
    #####: 1665:	    unqueue_signals();
        -: 1666:	}
    #####: 1667:	lastmailcheck = currentmailcheck;
        -: 1668:    }
        -: 1669:
    #####: 1670:    if (prepromptfns) {
    #####: 1671:	for(ln = firstnode(prepromptfns); ln; ln = nextnode(ln)) {
    #####: 1672:	    Prepromptfn ppnode = (Prepromptfn)getdata(ln);
    #####: 1673:	    ppnode->func();
        -: 1674:	}
        -: 1675:    }
        -: 1676:}
        -: 1677:
        -: 1678:/**/
        -: 1679:static void
    #####: 1680:checkmailpath(char **s)
        -: 1681:{
        -: 1682:    struct stat st;
        -: 1683:    char *v, *u, c;
        -: 1684:
    #####: 1685:    while (*s) {
    #####: 1686:	for (v = *s; *v && *v != '?'; v++);
    #####: 1687:	c = *v;
    #####: 1688:	*v = '\0';
    #####: 1689:	if (c != '?')
    #####: 1690:	    u = NULL;
        -: 1691:	else
    #####: 1692:	    u = v + 1;
    #####: 1693:	if (**s == 0) {
    #####: 1694:	    *v = c;
    #####: 1695:	    zerr("empty MAILPATH component: %s", *s);
    #####: 1696:	} else if (mailstat(unmeta(*s), &st) == -1) {
    #####: 1697:	    if (errno != ENOENT)
    #####: 1698:		zerr("%e: %s", errno, *s);
    #####: 1699:	} else if (S_ISDIR(st.st_mode)) {
        -: 1700:	    LinkList l;
    #####: 1701:	    DIR *lock = opendir(unmeta(*s));
        -: 1702:	    char buf[PATH_MAX * 2 + 1], **arr, **ap;
    #####: 1703:	    int buflen, ct = 1;
        -: 1704:
    #####: 1705:	    if (lock) {
        -: 1706:		char *fn;
        -: 1707:
    #####: 1708:		pushheap();
    #####: 1709:		l = newlinklist();
    #####: 1710:		while ((fn = zreaddir(lock, 1)) && !errflag) {
    #####: 1711:		    if (u)
    #####: 1712:			buflen = snprintf(buf, sizeof(buf), "%s/%s?%s", *s, fn, u);
        -: 1713:		    else
    #####: 1714:			buflen = snprintf(buf, sizeof(buf), "%s/%s", *s, fn);
    #####: 1715:		    if (buflen < 0 || buflen >= (int)sizeof(buf))
    #####: 1716:			continue;
    #####: 1717:		    addlinknode(l, dupstring(buf));
    #####: 1718:		    ct++;
        -: 1719:		}
    #####: 1720:		closedir(lock);
    #####: 1721:		ap = arr = (char **) zhalloc(ct * sizeof(char *));
        -: 1722:
    #####: 1723:		while ((*ap++ = (char *)ugetnode(l)));
    #####: 1724:		checkmailpath(arr);
    #####: 1725:		popheap();
        -: 1726:	    }
    #####: 1727:	} else if (shout) {
    #####: 1728:	    if (st.st_size && st.st_atime <= st.st_mtime &&
    #####: 1729:		st.st_mtime >= lastmailcheck) {
    #####: 1730:		if (!u) {
    #####: 1731:		    fprintf(shout, "You have new mail.\n");
    #####: 1732:		    fflush(shout);
        -: 1733:		} else {
        -: 1734:		    char *usav;
    #####: 1735:		    int uusav = underscoreused;
        -: 1736:
    #####: 1737:		    usav = zalloc(underscoreused);
        -: 1738:
    #####: 1739:		    if (usav)
    #####: 1740:			memcpy(usav, zunderscore, underscoreused);
        -: 1741:
    #####: 1742:		    setunderscore(*s);
        -: 1743:
    #####: 1744:		    u = dupstring(u);
    #####: 1745:		    if (!parsestr(&u)) {
    #####: 1746:			singsub(&u);
    #####: 1747:			zputs(u, shout);
    #####: 1748:			fputc('\n', shout);
    #####: 1749:			fflush(shout);
        -: 1750:		    }
    #####: 1751:		    if (usav) {
    #####: 1752:			setunderscore(usav);
    #####: 1753:			zfree(usav, uusav);
        -: 1754:		    }
        -: 1755:		}
        -: 1756:	    }
    #####: 1757:	    if (isset(MAILWARNING) && st.st_atime > st.st_mtime &&
    #####: 1758:		st.st_atime > lastmailcheck && st.st_size) {
    #####: 1759:		fprintf(shout, "The mail in %s has been read.\n", unmeta(*s));
    #####: 1760:		fflush(shout);
        -: 1761:	    }
        -: 1762:	}
    #####: 1763:	*v = c;
    #####: 1764:	s++;
        -: 1765:    }
    #####: 1766:}
        -: 1767:
        -: 1768:/* This prints the XTRACE prompt. */
        -: 1769:
        -: 1770:/**/
        -: 1771:FILE *xtrerr = 0;
        -: 1772:
        -: 1773:/**/
        -: 1774:void
    #####: 1775:printprompt4(void)
        -: 1776:{
    #####: 1777:    if (!xtrerr)
    #####: 1778:	xtrerr = stderr;
    #####: 1779:    if (prompt4) {
    #####: 1780:	int l, t = opts[XTRACE];
    #####: 1781:	char *s = dupstring(prompt4);
        -: 1782:
    #####: 1783:	opts[XTRACE] = 0;
    #####: 1784:	unmetafy(s, &l);
    #####: 1785:	s = unmetafy(promptexpand(metafy(s, l, META_NOALLOC),
        -: 1786:				  0, NULL, NULL, NULL), &l);
    #####: 1787:	opts[XTRACE] = t;
        -: 1788:
    #####: 1789:	fprintf(xtrerr, "%s", s);
    #####: 1790:	free(s);
        -: 1791:    }
    #####: 1792:}
        -: 1793:
        -: 1794:/**/
        -: 1795:mod_export void
    #####: 1796:freestr(void *a)
        -: 1797:{
    #####: 1798:    zsfree(a);
    #####: 1799:}
        -: 1800:
        -: 1801:/**/
        -: 1802:mod_export void
    #####: 1803:gettyinfo(struct ttyinfo *ti)
        -: 1804:{
    #####: 1805:    if (SHTTY != -1) {
        -: 1806:#ifdef HAVE_TERMIOS_H
        -: 1807:# ifdef HAVE_TCGETATTR
    #####: 1808:	if (tcgetattr(SHTTY, &ti->tio) == -1)
        -: 1809:# else
        -: 1810:	if (ioctl(SHTTY, TCGETS, &ti->tio) == -1)
        -: 1811:# endif
    #####: 1812:	    zerr("bad tcgets: %e", errno);
        -: 1813:#else
        -: 1814:# ifdef HAVE_TERMIO_H
        -: 1815:	ioctl(SHTTY, TCGETA, &ti->tio);
        -: 1816:# else
        -: 1817:	ioctl(SHTTY, TIOCGETP, &ti->sgttyb);
        -: 1818:	ioctl(SHTTY, TIOCLGET, &ti->lmodes);
        -: 1819:	ioctl(SHTTY, TIOCGETC, &ti->tchars);
        -: 1820:	ioctl(SHTTY, TIOCGLTC, &ti->ltchars);
        -: 1821:# endif
        -: 1822:#endif
        -: 1823:    }
    #####: 1824:}
        -: 1825:
        -: 1826:/**/
        -: 1827:mod_export void
    #####: 1828:settyinfo(struct ttyinfo *ti)
        -: 1829:{
    #####: 1830:    if (SHTTY != -1) {
        -: 1831:#ifdef HAVE_TERMIOS_H
        -: 1832:# ifdef HAVE_TCGETATTR
        -: 1833:#  ifndef TCSADRAIN
        -: 1834:#   define TCSADRAIN 1	/* XXX Princeton's include files are screwed up */
        -: 1835:#  endif
    #####: 1836:	while (tcsetattr(SHTTY, TCSADRAIN, &ti->tio) == -1 && errno == EINTR)
        -: 1837:	    ;
        -: 1838:# else
        -: 1839:	while (ioctl(SHTTY, TCSETS, &ti->tio) == -1 && errno == EINTR)
        -: 1840:	    ;
        -: 1841:# endif
        -: 1842:	/*	zerr("settyinfo: %e",errno);*/
        -: 1843:#else
        -: 1844:# ifdef HAVE_TERMIO_H
        -: 1845:	ioctl(SHTTY, TCSETA, &ti->tio);
        -: 1846:# else
        -: 1847:	ioctl(SHTTY, TIOCSETN, &ti->sgttyb);
        -: 1848:	ioctl(SHTTY, TIOCLSET, &ti->lmodes);
        -: 1849:	ioctl(SHTTY, TIOCSETC, &ti->tchars);
        -: 1850:	ioctl(SHTTY, TIOCSLTC, &ti->ltchars);
        -: 1851:# endif
        -: 1852:#endif
        -: 1853:    }
    #####: 1854:}
        -: 1855:
        -: 1856:/* the default tty state */
        -: 1857:
        -: 1858:/**/
        -: 1859:mod_export struct ttyinfo shttyinfo;
        -: 1860:
        -: 1861:/* != 0 if we need to call resetvideo() */
        -: 1862:
        -: 1863:/**/
        -: 1864:mod_export int resetneeded;
        -: 1865:
        -: 1866:#ifdef TIOCGWINSZ
        -: 1867:/* window size changed */
        -: 1868:
        -: 1869:/**/
        -: 1870:mod_export int winchanged;
        -: 1871:#endif
        -: 1872:
        -: 1873:static int
    #####: 1874:adjustlines(int signalled)
        -: 1875:{
    #####: 1876:    int oldlines = zterm_lines;
        -: 1877:
        -: 1878:#ifdef TIOCGWINSZ
    #####: 1879:    if (signalled || zterm_lines <= 0)
    #####: 1880:	zterm_lines = shttyinfo.winsize.ws_row;
        -: 1881:    else
    #####: 1882:	shttyinfo.winsize.ws_row = zterm_lines;
        -: 1883:#endif /* TIOCGWINSZ */
    #####: 1884:    if (zterm_lines <= 0) {
        -: 1885:	DPUTS(signalled && zterm_lines < 0,
        -: 1886:	      "BUG: Impossible TIOCGWINSZ rows");
    #####: 1887:	zterm_lines = tclines > 0 ? tclines : 24;
        -: 1888:    }
        -: 1889:
    #####: 1890:    if (zterm_lines > 2)
    #####: 1891:	termflags &= ~TERM_SHORT;
        -: 1892:    else
    #####: 1893:	termflags |= TERM_SHORT;
        -: 1894:
    #####: 1895:    return (zterm_lines != oldlines);
        -: 1896:}
        -: 1897:
        -: 1898:static int
    #####: 1899:adjustcolumns(int signalled)
        -: 1900:{
    #####: 1901:    int oldcolumns = zterm_columns;
        -: 1902:
        -: 1903:#ifdef TIOCGWINSZ
    #####: 1904:    if (signalled || zterm_columns <= 0)
    #####: 1905:	zterm_columns = shttyinfo.winsize.ws_col;
        -: 1906:    else
    #####: 1907:	shttyinfo.winsize.ws_col = zterm_columns;
        -: 1908:#endif /* TIOCGWINSZ */
    #####: 1909:    if (zterm_columns <= 0) {
        -: 1910:	DPUTS(signalled && zterm_columns < 0,
        -: 1911:	      "BUG: Impossible TIOCGWINSZ cols");
    #####: 1912:	zterm_columns = tccolumns > 0 ? tccolumns : 80;
        -: 1913:    }
        -: 1914:
    #####: 1915:    if (zterm_columns > 2)
    #####: 1916:	termflags &= ~TERM_NARROW;
        -: 1917:    else
    #####: 1918:	termflags |= TERM_NARROW;
        -: 1919:
    #####: 1920:    return (zterm_columns != oldcolumns);
        -: 1921:}
        -: 1922:
        -: 1923:/* check the size of the window and adjust if necessary. *
        -: 1924: * The value of from:					 *
        -: 1925: *   0: called from update_job or setupvals		 *
        -: 1926: *   1: called from the SIGWINCH handler		 *
        -: 1927: *   2: called from the LINES parameter callback	 *
        -: 1928: *   3: called from the COLUMNS parameter callback	 */
        -: 1929:
        -: 1930:/**/
        -: 1931:void
        2: 1932:adjustwinsize(int from)
        -: 1933:{
        -: 1934:    static int getwinsz = 1;
        -: 1935:#ifdef TIOCGWINSZ
        2: 1936:    int ttyrows = shttyinfo.winsize.ws_row;
        2: 1937:    int ttycols = shttyinfo.winsize.ws_col;
        -: 1938:#endif
        2: 1939:    int resetzle = 0;
        -: 1940:
        2: 1941:    if (getwinsz || from == 1) {
        -: 1942:#ifdef TIOCGWINSZ
        2: 1943:	if (SHTTY == -1)
        2: 1944:	    return;
    #####: 1945:	if (ioctl(SHTTY, TIOCGWINSZ, (char *)&shttyinfo.winsize) == 0) {
    #####: 1946:	    resetzle = (ttyrows != shttyinfo.winsize.ws_row ||
    #####: 1947:			ttycols != shttyinfo.winsize.ws_col);
    #####: 1948:	    if (from == 0 && resetzle && ttyrows && ttycols)
    #####: 1949:		from = 1; /* Signal missed while a job owned the tty? */
    #####: 1950:	    ttyrows = shttyinfo.winsize.ws_row;
    #####: 1951:	    ttycols = shttyinfo.winsize.ws_col;
        -: 1952:	} else {
        -: 1953:	    /* Set to value from environment on failure */
    #####: 1954:	    shttyinfo.winsize.ws_row = zterm_lines;
    #####: 1955:	    shttyinfo.winsize.ws_col = zterm_columns;
    #####: 1956:	    resetzle = (from == 1);
        -: 1957:	}
        -: 1958:#else
        -: 1959:	resetzle = from == 1;
        -: 1960:#endif /* TIOCGWINSZ */
        -: 1961:    } /* else
        -: 1962:	 return; */
        -: 1963:
    #####: 1964:    switch (from) {
    #####: 1965:    case 0:
        -: 1966:    case 1:
    #####: 1967:	getwinsz = 0;
        -: 1968:	/* Calling setiparam() here calls this function recursively, but  *
        -: 1969:	 * because we've already called adjustlines() and adjustcolumns() *
        -: 1970:	 * here, recursive calls are no-ops unless a signal intervenes.   *
        -: 1971:	 * The commented "else return;" above might be a safe shortcut,   *
        -: 1972:	 * but I'm concerned about what happens on race conditions; e.g., *
        -: 1973:	 * suppose the user resizes his xterm during `eval $(resize)'?    */
    #####: 1974:	if (adjustlines(from) && zgetenv("LINES"))
    #####: 1975:	    setiparam("LINES", zterm_lines);
    #####: 1976:	if (adjustcolumns(from) && zgetenv("COLUMNS"))
    #####: 1977:	    setiparam("COLUMNS", zterm_columns);
    #####: 1978:	getwinsz = 1;
    #####: 1979:	break;
    #####: 1980:    case 2:
    #####: 1981:	resetzle = adjustlines(0);
    #####: 1982:	break;
    #####: 1983:    case 3:
    #####: 1984:	resetzle = adjustcolumns(0);
    #####: 1985:	break;
        -: 1986:    }
        -: 1987:
        -: 1988:#ifdef TIOCGWINSZ
    #####: 1989:    if (interact && from >= 2 &&
    #####: 1990:	(shttyinfo.winsize.ws_row != ttyrows ||
    #####: 1991:	 shttyinfo.winsize.ws_col != ttycols)) {
        -: 1992:	/* shttyinfo.winsize is already set up correctly */
        -: 1993:	/* ioctl(SHTTY, TIOCSWINSZ, (char *)&shttyinfo.winsize); */
        -: 1994:    }
        -: 1995:#endif /* TIOCGWINSZ */
        -: 1996:
    #####: 1997:    if (zleactive && resetzle) {
        -: 1998:#ifdef TIOCGWINSZ
    #####: 1999:	winchanged =
        -: 2000:#endif /* TIOCGWINSZ */
    #####: 2001:	    resetneeded = 1;
    #####: 2002:	zleentry(ZLE_CMD_RESET_PROMPT);
    #####: 2003:	zleentry(ZLE_CMD_REFRESH);
        -: 2004:    }
        -: 2005:}
        -: 2006:
        -: 2007:/*
        -: 2008: * Ensure the fdtable is large enough for fd, and that the
        -: 2009: * maximum fd is set appropriately.
        -: 2010: */
        -: 2011:static void
       41: 2012:check_fd_table(int fd)
        -: 2013:{
       41: 2014:    if (fd <= max_zsh_fd)
       21: 2015:	return;
        -: 2016:
       20: 2017:    if (fd >= fdtable_size) {
    #####: 2018:	int old_size = fdtable_size;
    #####: 2019:	while (fd >= fdtable_size)
    #####: 2020:	    fdtable = zrealloc(fdtable,
    #####: 2021:			       (fdtable_size *= 2)*sizeof(*fdtable));
    #####: 2022:	memset(fdtable + old_size, 0,
    #####: 2023:	       (fdtable_size - old_size) * sizeof(*fdtable));
        -: 2024:    }
       20: 2025:    max_zsh_fd = fd;
        -: 2026:}
        -: 2027:
        -: 2028:/* Move a fd to a place >= 10 and mark the new fd in fdtable.  If the fd *
        -: 2029: * is already >= 10, it is not moved.  If it is invalid, -1 is returned. */
        -: 2030:
        -: 2031:/**/
        -: 2032:mod_export int
       25: 2033:movefd(int fd)
        -: 2034:{
       25: 2035:    if(fd != -1 && fd < 10) {
        -: 2036:#ifdef F_DUPFD
       20: 2037:	int fe = fcntl(fd, F_DUPFD, 10);
        -: 2038:#else
        -: 2039:	int fe = movefd(dup(fd));
        -: 2040:#endif
        -: 2041:	/*
        -: 2042:	 * To close or not to close if fe is -1?
        -: 2043:	 * If it is -1, we haven't moved the fd, so if we close
        -: 2044:	 * it we lose it; but we're probably not going to be able
        -: 2045:	 * to use it in situ anyway.  So probably better to avoid a leak.
        -: 2046:	 */
       20: 2047:	zclose(fd);
       20: 2048:	fd = fe;
        -: 2049:    }
       25: 2050:    if(fd != -1) {
       21: 2051:	check_fd_table(fd);
       21: 2052:	fdtable[fd] = FDT_INTERNAL;
        -: 2053:    }
       25: 2054:    return fd;
        -: 2055:}
        -: 2056:
        -: 2057:/*
        -: 2058: * Move fd x to y.  If x == -1, fd y is closed.
        -: 2059: * Returns y for success, -1 for failure.
        -: 2060: */
        -: 2061:
        -: 2062:/**/
        -: 2063:mod_export int
       20: 2064:redup(int x, int y)
        -: 2065:{
       20: 2066:    int ret = y;
        -: 2067:
       20: 2068:    if(x < 0)
    #####: 2069:	zclose(y);
       20: 2070:    else if (x != y) {
       20: 2071:	if (dup2(x, y) == -1) {
    #####: 2072:	    ret = -1;
        -: 2073:	} else {
       20: 2074:	    check_fd_table(y);
       20: 2075:	    fdtable[y] = fdtable[x];
       20: 2076:	    if (fdtable[y] == FDT_FLOCK || fdtable[y] == FDT_FLOCK_EXEC)
    #####: 2077:		fdtable[y] = FDT_INTERNAL;
        -: 2078:	}
        -: 2079:	/*
        -: 2080:	 * Closing any fd to the locked file releases the lock.
        -: 2081:	 * This isn't expected to happen, it's here for completeness.
        -: 2082:	 */
       20: 2083:	if (fdtable[x] == FDT_FLOCK)
    #####: 2084:	    fdtable_flocks--;
       20: 2085:	zclose(x);
        -: 2086:    }
        -: 2087:
       20: 2088:    return ret;
        -: 2089:}
        -: 2090:
        -: 2091:/*
        -: 2092: * Add an fd opened ithin a module.
        -: 2093: *
        -: 2094: * fdt is the type of the fd; see the FDT_ definitions in zsh.h.
        -: 2095: * The most likely falures are:
        -: 2096: *
        -: 2097: * FDT_EXTERNAL: the fd can be used within the shell for normal I/O but
        -: 2098: * it will not be closed automatically or by normal shell syntax.
        -: 2099: *
        -: 2100: * FDT_MODULE: as FDT_EXTERNAL, but it can only be closed by the module
        -: 2101: * (which should included zclose() as part of the sequence), not by
        -: 2102: * the standard shell syntax for closing file descriptors.
        -: 2103: *
        -: 2104: * FDT_INTERNAL: fd is treated like others created by the shell for
        -: 2105: * internal use; it can be closed and will be closed by the shell if it
        -: 2106: * exec's or performs an exec with a fork optimised out.
        -: 2107: *
        -: 2108: * Safe if fd is -1 to indicate failure.
        -: 2109: */
        -: 2110:/**/
        -: 2111:mod_export void
    #####: 2112:addmodulefd(int fd, int fdt)
        -: 2113:{
    #####: 2114:    if (fd >= 0) {
    #####: 2115:	check_fd_table(fd);
    #####: 2116:	fdtable[fd] = fdt;
        -: 2117:    }
    #####: 2118:}
        -: 2119:
        -: 2120:/**/
        -: 2121:
        -: 2122:/*
        -: 2123: * Indicate that an fd has a file lock; if cloexec is 1 it will be closed
        -: 2124: * on exec.
        -: 2125: * The fd should already be known to fdtable (e.g. by movefd).
        -: 2126: * Note the fdtable code doesn't care what sort of lock
        -: 2127: * is used; this simply prevents the main shell exiting prematurely
        -: 2128: * when it holds a lock.
        -: 2129: */
        -: 2130:
        -: 2131:/**/
        -: 2132:mod_export void
    #####: 2133:addlockfd(int fd, int cloexec)
        -: 2134:{
    #####: 2135:    if (cloexec) {
    #####: 2136:	if (fdtable[fd] != FDT_FLOCK)
    #####: 2137:	    fdtable_flocks++;
    #####: 2138:	fdtable[fd] = FDT_FLOCK;
        -: 2139:    } else {
    #####: 2140:	fdtable[fd] = FDT_FLOCK_EXEC;
        -: 2141:    }
    #####: 2142:}
        -: 2143:
        -: 2144:/* Close the given fd, and clear it from fdtable. */
        -: 2145:
        -: 2146:/**/
        -: 2147:mod_export int
       76: 2148:zclose(int fd)
        -: 2149:{
       76: 2150:    if (fd >= 0) {
        -: 2151:	/*
        -: 2152:	 * Careful: we allow closing of arbitrary fd's, beyond
        -: 2153:	 * max_zsh_fd.  In that case we don't try anything clever.
        -: 2154:	 */
       64: 2155:	if (fd <= max_zsh_fd) {
       62: 2156:	    if (fdtable[fd] == FDT_FLOCK)
    #####: 2157:		fdtable_flocks--;
       62: 2158:	    fdtable[fd] = FDT_UNUSED;
      192: 2159:	    while (max_zsh_fd > 0 && fdtable[max_zsh_fd] == FDT_UNUSED)
       68: 2160:		max_zsh_fd--;
       62: 2161:	    if (fd == coprocin)
    #####: 2162:		coprocin = -1;
       62: 2163:	    if (fd == coprocout)
    #####: 2164:		coprocout = -1;
        -: 2165:	}
       64: 2166:	return close(fd);
        -: 2167:    }
       12: 2168:    return -1;
        -: 2169:}
        -: 2170:
        -: 2171:/*
        -: 2172: * Close an fd returning 0 if used for locking; return -1 if it isn't.
        -: 2173: */
        -: 2174:
        -: 2175:/**/
        -: 2176:mod_export int
    #####: 2177:zcloselockfd(int fd)
        -: 2178:{
    #####: 2179:    if (fd > max_zsh_fd)
    #####: 2180:	return -1;
    #####: 2181:    if (fdtable[fd] != FDT_FLOCK && fdtable[fd] != FDT_FLOCK_EXEC)
    #####: 2182:	return -1;
    #####: 2183:    zclose(fd);
    #####: 2184:    return 0;
        -: 2185:}
        -: 2186:
        -: 2187:#ifdef HAVE__MKTEMP
        -: 2188:extern char *_mktemp(char *);
        -: 2189:#endif
        -: 2190:
        -: 2191:/* Get a unique filename for use as a temporary file.  If "prefix" is
        -: 2192: * NULL, the name is relative to $TMPPREFIX; If it is non-NULL, the
        -: 2193: * unique suffix includes a prefixed '.' for improved readability.  If
        -: 2194: * "use_heap" is true, we allocate the returned name on the heap.
        -: 2195: * The string passed as "prefix" is expected to be metafied. */
        -: 2196:
        -: 2197:/**/
        -: 2198:mod_export char *
    #####: 2199:gettempname(const char *prefix, int use_heap)
        -: 2200:{
    #####: 2201:    char *ret, *suffix = prefix ? ".XXXXXX" : "XXXXXX";
        -: 2202:
    #####: 2203:    queue_signals();
    #####: 2204:    if (!prefix && !(prefix = getsparam("TMPPREFIX")))
    #####: 2205:	prefix = DEFAULT_TMPPREFIX;
    #####: 2206:    if (use_heap)
    #####: 2207:	ret = dyncat(unmeta(prefix), suffix);
        -: 2208:    else
    #####: 2209:	ret = bicat(unmeta(prefix), suffix);
        -: 2210:
        -: 2211:#ifdef HAVE__MKTEMP
        -: 2212:    /* Zsh uses mktemp() safely, so silence the warnings */
        -: 2213:    ret = (char *) _mktemp(ret);
        -: 2214:#elif HAVE_MKSTEMP && defined(DEBUG)
        -: 2215:    {
        -: 2216:	/* zsh uses mktemp() safely (all callers use O_EXCL, and one of them
        -: 2217:	 * uses mkfifo()/mknod(), as opposed to open()), but some compilers
        -: 2218:	 * warn about this anyway and give no way to disable the warning. To
        -: 2219:	 * appease them, use mkstemp() and then close the fd and unlink the
        -: 2220:	 * filename, to match callers' expectations.
        -: 2221:	 *
        -: 2222:	 * But do this in debug builds only, because we don't want to suffer
        -: 2223:	 * x3 the disk access (touch, unlink, touch again) in production.
        -: 2224:	 */
        -: 2225:	int fd;
        -: 2226:	errno = 0;
        -: 2227:	fd = mkstemp(ret);
        -: 2228:	if (fd < 0)
        -: 2229:	    zwarn("can't get a temporary filename: %e", errno);
        -: 2230:	else {
        -: 2231:	    close(fd);
        -: 2232:	    ret = ztrdup(ret);
        -: 2233:
        -: 2234:	    errno = 0;
        -: 2235:	    if (unlink(ret) < 0)
        -: 2236:		zwarn("unlinking a temporary filename failed: %e", errno);
        -: 2237:	}
        -: 2238:    }
        -: 2239:#else
    #####: 2240:    ret = (char *) mktemp(ret);
        -: 2241:#endif
    #####: 2242:    unqueue_signals();
        -: 2243:
    #####: 2244:    return ret;
        -: 2245:}
        -: 2246:
        -: 2247:/* The gettempfile() "prefix" is expected to be metafied, see hist.c
        -: 2248: * and gettempname(). */
        -: 2249:
        -: 2250:/**/
        -: 2251:mod_export int
    #####: 2252:gettempfile(const char *prefix, int use_heap, char **tempname)
        -: 2253:{
        -: 2254:    char *fn;
        -: 2255:    int fd;
        -: 2256:    mode_t old_umask;
        -: 2257:#if HAVE_MKSTEMP
    #####: 2258:    char *suffix = prefix ? ".XXXXXX" : "XXXXXX";
        -: 2259:
    #####: 2260:    queue_signals();
    #####: 2261:    old_umask = umask(0177);
    #####: 2262:    if (!prefix && !(prefix = getsparam("TMPPREFIX")))
    #####: 2263:	prefix = DEFAULT_TMPPREFIX;
    #####: 2264:    if (use_heap)
    #####: 2265:	fn = dyncat(unmeta(prefix), suffix);
        -: 2266:    else
    #####: 2267:	fn = bicat(unmeta(prefix), suffix);
        -: 2268:
    #####: 2269:    fd = mkstemp(fn);
    #####: 2270:    if (fd < 0) {
    #####: 2271:	if (!use_heap)
    #####: 2272:	    free(fn);
    #####: 2273:	fn = NULL;
        -: 2274:    }
        -: 2275:#else
        -: 2276:    int failures = 0;
        -: 2277:
        -: 2278:    queue_signals();
        -: 2279:    old_umask = umask(0177);
        -: 2280:    do {
        -: 2281:	if (!(fn = gettempname(prefix, use_heap))) {
        -: 2282:	    fd = -1;
        -: 2283:	    break;
        -: 2284:	}
        -: 2285:	if ((fd = open(fn, O_RDWR | O_CREAT | O_EXCL, 0600)) >= 0)
        -: 2286:	    break;
        -: 2287:	if (!use_heap)
        -: 2288:	    free(fn);
        -: 2289:	fn = NULL;
        -: 2290:    } while (errno == EEXIST && ++failures < 16);
        -: 2291:#endif
    #####: 2292:    *tempname = fn;
        -: 2293:
    #####: 2294:    umask(old_umask);
    #####: 2295:    unqueue_signals();
    #####: 2296:    return fd;
        -: 2297:}
        -: 2298:
        -: 2299:/* Check if a string contains a token */
        -: 2300:
        -: 2301:/**/
        -: 2302:mod_export int
     2349: 2303:has_token(const char *s)
        -: 2304:{
    14140: 2305:    while(*s)
    10304: 2306:	if(itok(*s++))
      862: 2307:	    return 1;
     1487: 2308:    return 0;
        -: 2309:}
        -: 2310:
        -: 2311:/* Delete a character in a string */
        -: 2312:
        -: 2313:/**/
        -: 2314:mod_export void
       20: 2315:chuck(char *str)
        -: 2316:{
      134: 2317:    while ((str[0] = str[1]))
       94: 2318:	str++;
       20: 2319:}
        -: 2320:
        -: 2321:/**/
        -: 2322:mod_export int
    #####: 2323:tulower(int c)
        -: 2324:{
    #####: 2325:    c &= 0xff;
    #####: 2326:    return (isupper(c) ? tolower(c) : c);
        -: 2327:}
        -: 2328:
        -: 2329:/**/
        -: 2330:mod_export int
    #####: 2331:tuupper(int c)
        -: 2332:{
    #####: 2333:    c &= 0xff;
    #####: 2334:    return (islower(c) ? toupper(c) : c);
        -: 2335:}
        -: 2336:
        -: 2337:/* copy len chars from t into s, and null terminate */
        -: 2338:
        -: 2339:/**/
        -: 2340:void
       12: 2341:ztrncpy(char *s, char *t, int len)
        -: 2342:{
      134: 2343:    while (len--)
      110: 2344:	*s++ = *t++;
       12: 2345:    *s = '\0';
       12: 2346:}
        -: 2347:
        -: 2348:/* copy t into *s and update s */
        -: 2349:
        -: 2350:/**/
        -: 2351:mod_export void
       15: 2352:strucpy(char **s, char *t)
        -: 2353:{
       15: 2354:    char *u = *s;
        -: 2355:
       15: 2356:    while ((*u++ = *t++));
       15: 2357:    *s = u - 1;
       15: 2358:}
        -: 2359:
        -: 2360:/**/
        -: 2361:mod_export void
        6: 2362:struncpy(char **s, char *t, int n)
        -: 2363:{
        6: 2364:    char *u = *s;
        -: 2365:
       67: 2366:    while (n-- && (*u = *t++))
       55: 2367:	u++;
        6: 2368:    *s = u;
        6: 2369:    if (n > 0) /* just one null-byte will do, unlike strncpy(3) */
        6: 2370:	*u = '\0';
        6: 2371:}
        -: 2372:
        -: 2373:/* Return the number of elements in an array of pointers. *
        -: 2374: * It doesn't count the NULL pointer at the end.          */
        -: 2375:
        -: 2376:/**/
        -: 2377:mod_export int
      212: 2378:arrlen(char **s)
        -: 2379:{
        -: 2380:    int count;
        -: 2381:
      212: 2382:    for (count = 0; *s; s++, count++);
      212: 2383:    return count;
        -: 2384:}
        -: 2385:
        -: 2386:/* Return TRUE iff arrlen(s) >= lower_bound, but more efficiently. */
        -: 2387:
        -: 2388:/**/
        -: 2389:mod_export char
       98: 2390:arrlen_ge(char **s, unsigned lower_bound)
        -: 2391:{
      317: 2392:    while (lower_bound--)
      121: 2393:	if (!*s++)
    #####: 2394:	    return 0 /* FALSE */;
        -: 2395:
       98: 2396:    return 1 /* TRUE */;
        -: 2397:}
        -: 2398:
        -: 2399:/* Return TRUE iff arrlen(s) > lower_bound, but more efficiently. */
        -: 2400:
        -: 2401:/**/
        -: 2402:mod_export char
    #####: 2403:arrlen_gt(char **s, unsigned lower_bound)
        -: 2404:{
    #####: 2405:    return arrlen_ge(s, 1+lower_bound);
        -: 2406:}
        -: 2407:
        -: 2408:/* Return TRUE iff arrlen(s) <= upper_bound, but more efficiently. */
        -: 2409:
        -: 2410:/**/
        -: 2411:mod_export char
       94: 2412:arrlen_le(char **s, unsigned upper_bound)
        -: 2413:{
       94: 2414:    return arrlen_lt(s, 1+upper_bound);
        -: 2415:}
        -: 2416:
        -: 2417:/* Return TRUE iff arrlen(s) < upper_bound, but more efficiently. */
        -: 2418:
        -: 2419:/**/
        -: 2420:mod_export char
       98: 2421:arrlen_lt(char **s, unsigned upper_bound)
        -: 2422:{
       98: 2423:    return !arrlen_ge(s, upper_bound);
        -: 2424:}
        -: 2425:
        -: 2426:/* Skip over a balanced pair of parenthesis. */
        -: 2427:
        -: 2428:/**/
        -: 2429:mod_export int
       17: 2430:skipparens(char inpar, char outpar, char **s)
        -: 2431:{
        -: 2432:    int level;
        -: 2433:
       17: 2434:    if (**s != inpar)
    #####: 2435:	return -1;
        -: 2436:
      194: 2437:    for (level = 1; *++*s && level;)
      160: 2438:	if (**s == inpar)
    #####: 2439:	   ++level;
      160: 2440:	else if (**s == outpar)
       17: 2441:	   --level;
        -: 2442:
       17: 2443:   return level;
        -: 2444:}
        -: 2445:
        -: 2446:/**/
        -: 2447:mod_export zlong
       75: 2448:zstrtol(const char *s, char **t, int base)
        -: 2449:{
       75: 2450:    return zstrtol_underscore(s, t, base, 0);
        -: 2451:}
        -: 2452:
        -: 2453:/* Convert string to zlong (see zsh.h).  This function (without the z) *
        -: 2454: * is contained in the ANSI standard C library, but a lot of them seem *
        -: 2455: * to be broken.                                                       */
        -: 2456:
        -: 2457:/**/
        -: 2458:mod_export zlong
      257: 2459:zstrtol_underscore(const char *s, char **t, int base, int underscore)
        -: 2460:{
      257: 2461:    const char *inp, *trunc = NULL;
      257: 2462:    zulong calc = 0, newcalc = 0;
        -: 2463:    int neg;
        -: 2464:
      514: 2465:    while (inblank(*s))
    #####: 2466:	s++;
        -: 2467:
      257: 2468:    if ((neg = IS_DASH(*s)))
    #####: 2469:	s++;
      257: 2470:    else if (*s == '+')
    #####: 2471:	s++;
        -: 2472:
      257: 2473:    if (!base) {
        2: 2474:	if (*s != '0')
        2: 2475:	    base = 10;
    #####: 2476:	else if (*++s == 'x' || *s == 'X')
    #####: 2477:	    base = 16, s++;
    #####: 2478:	else if (*s == 'b' || *s == 'B')
    #####: 2479:	    base = 2, s++;
        -: 2480:	else
    #####: 2481:	    base = 8;
        -: 2482:    }
      257: 2483:    inp = s;
      257: 2484:    if (base < 2 || base > 36) {
    #####: 2485:	zerr("invalid base (must be 2 to 36 inclusive): %d", base);
    #####: 2486:	return (zlong)0;
      257: 2487:    } else if (base <= 10) {
      809: 2488:	for (; (*s >= '0' && *s < ('0' + base)) ||
      477: 2489:		 (underscore && *s == '_'); s++) {
      295: 2490:	    if (trunc || *s == '_')
    #####: 2491:		continue;
      295: 2492:	    newcalc = calc * base + *s - '0';
      295: 2493:	    if (newcalc < calc)
        -: 2494:	    {
    #####: 2495:		trunc = s;
    #####: 2496:		continue;
        -: 2497:	    }
      295: 2498:	    calc = newcalc;
        -: 2499:	}
        -: 2500:    } else {
    #####: 2501:	for (; idigit(*s) || (*s >= 'a' && *s < ('a' + base - 10))
    #####: 2502:	     || (*s >= 'A' && *s < ('A' + base - 10))
    #####: 2503:	     || (underscore && *s == '_'); s++) {
    #####: 2504:	    if (trunc || *s == '_')
    #####: 2505:		continue;
    #####: 2506:	    newcalc = calc*base + (idigit(*s) ? (*s - '0') : (*s & 0x1f) + 9);
    #####: 2507:	    if (newcalc < calc)
        -: 2508:	    {
    #####: 2509:		trunc = s;
    #####: 2510:		continue;
        -: 2511:	    }
    #####: 2512:	    calc = newcalc;
        -: 2513:	}
        -: 2514:    }
        -: 2515:
        -: 2516:    /*
        -: 2517:     * Special case: check for a number that was just too long for
        -: 2518:     * signed notation.
        -: 2519:     * Extra special case: the lowest negative number would trigger
        -: 2520:     * the first test, but is actually representable correctly.
        -: 2521:     * This is a 1 in the top bit, all others zero, so test for
        -: 2522:     * that explicitly.
        -: 2523:     */
      257: 2524:    if (!trunc && (zlong)calc < 0 &&
    #####: 2525:	(!neg || calc & ~((zulong)1 << (8*sizeof(zulong)-1))))
        -: 2526:    {
    #####: 2527:	trunc = s - 1;
    #####: 2528:	calc /= base;
        -: 2529:    }
        -: 2530:
      257: 2531:    if (trunc)
    #####: 2532:	zwarn("number truncated after %d digits: %s", (int)(trunc - inp), inp);
        -: 2533:
      257: 2534:    if (t)
      256: 2535:	*t = (char *)s;
      257: 2536:    return neg ? -(zlong)calc : (zlong)calc;
        -: 2537:}
        -: 2538:
        -: 2539:/*
        -: 2540: * If s represents a complete unsigned integer (and nothing else)
        -: 2541: * return 1 and set retval to the value.  Otherwise return 0.
        -: 2542: *
        -: 2543: * Underscores are always allowed.
        -: 2544: *
        -: 2545: * Sensitive to OCTAL_ZEROES.
        -: 2546: */
        -: 2547:
        -: 2548:/**/
        -: 2549:mod_export int
    #####: 2550:zstrtoul_underscore(const char *s, zulong *retval)
        -: 2551:{
    #####: 2552:    zulong calc = 0, newcalc = 0, base;
        -: 2553:
    #####: 2554:    if (*s == '+')
    #####: 2555:	s++;
        -: 2556:
    #####: 2557:    if (*s != '0')
    #####: 2558:	base = 10;
    #####: 2559:    else if (*++s == 'x' || *s == 'X')
    #####: 2560:	base = 16, s++;
    #####: 2561:    else if (*s == 'b' || *s == 'B')
    #####: 2562:	base = 2, s++;
        -: 2563:    else
    #####: 2564:	base = isset(OCTALZEROES) ? 8 : 10;
    #####: 2565:    if (base <= 10) {
    #####: 2566:	for (; (*s >= '0' && *s < ('0' + base)) ||
    #####: 2567:		 *s == '_'; s++) {
    #####: 2568:	    if (*s == '_')
    #####: 2569:		continue;
    #####: 2570:	    newcalc = calc * base + *s - '0';
    #####: 2571:	    if (newcalc < calc)
        -: 2572:	    {
    #####: 2573:		return 0;
        -: 2574:	    }
    #####: 2575:	    calc = newcalc;
        -: 2576:	}
        -: 2577:    } else {
    #####: 2578:	for (; idigit(*s) || (*s >= 'a' && *s < ('a' + base - 10))
    #####: 2579:	     || (*s >= 'A' && *s < ('A' + base - 10))
    #####: 2580:	     || *s == '_'; s++) {
    #####: 2581:	    if (*s == '_')
    #####: 2582:		continue;
    #####: 2583:	    newcalc = calc*base + (idigit(*s) ? (*s - '0') : (*s & 0x1f) + 9);
    #####: 2584:	    if (newcalc < calc)
        -: 2585:	    {
    #####: 2586:		return 0;
        -: 2587:	    }
    #####: 2588:	    calc = newcalc;
        -: 2589:	}
        -: 2590:    }
        -: 2591:
    #####: 2592:    if (*s)
    #####: 2593:	return 0;
    #####: 2594:    *retval = calc;
    #####: 2595:    return 1;
        -: 2596:}
        -: 2597:
        -: 2598:/**/
        -: 2599:mod_export int
    #####: 2600:setblock_fd(int turnonblocking, int fd, long *modep)
        -: 2601:{
        -: 2602:#ifdef O_NDELAY
        -: 2603:# ifdef O_NONBLOCK
        -: 2604:#  define NONBLOCK (O_NDELAY|O_NONBLOCK)
        -: 2605:# else /* !O_NONBLOCK */
        -: 2606:#  define NONBLOCK O_NDELAY
        -: 2607:# endif /* !O_NONBLOCK */
        -: 2608:#else /* !O_NDELAY */
        -: 2609:# ifdef O_NONBLOCK
        -: 2610:#  define NONBLOCK O_NONBLOCK
        -: 2611:# else /* !O_NONBLOCK */
        -: 2612:#  define NONBLOCK 0
        -: 2613:# endif /* !O_NONBLOCK */
        -: 2614:#endif /* !O_NDELAY */
        -: 2615:
        -: 2616:#if NONBLOCK
        -: 2617:    struct stat st;
        -: 2618:
    #####: 2619:    if (!fstat(fd, &st) && !S_ISREG(st.st_mode)) {
    #####: 2620:	*modep = fcntl(fd, F_GETFL, 0);
    #####: 2621:	if (*modep != -1) {
    #####: 2622:	    if (!turnonblocking) {
        -: 2623:		/* We want to know if blocking was off */
    #####: 2624:		if ((*modep & NONBLOCK) ||
    #####: 2625:		    !fcntl(fd, F_SETFL, *modep | NONBLOCK))
    #####: 2626:		    return 1;
    #####: 2627:	    } else if ((*modep & NONBLOCK) &&
    #####: 2628:		       !fcntl(fd, F_SETFL, *modep & ~NONBLOCK)) {
        -: 2629:		/* Here we want to know if the state changed */
    #####: 2630:		return 1;
        -: 2631:	    }
        -: 2632:	}
        -: 2633:    } else
        -: 2634:#endif /* NONBLOCK */
    #####: 2635:	*modep = -1;
    #####: 2636:    return 0;
        -: 2637:
        -: 2638:#undef NONBLOCK
        -: 2639:}
        -: 2640:
        -: 2641:/**/
        -: 2642:int
    #####: 2643:setblock_stdin(void)
        -: 2644:{
        -: 2645:    long mode;
    #####: 2646:    return setblock_fd(1, 0, &mode);
        -: 2647:}
        -: 2648:
        -: 2649:/*
        -: 2650: * Check for pending input on fd.  If polltty is set, we may need to
        -: 2651: * use termio to look for input.  As a final resort, go to non-blocking
        -: 2652: * input and try to read a character, which in this case will be
        -: 2653: * returned in *readchar.
        -: 2654: *
        -: 2655: * Note that apart from setting (and restoring) non-blocking input,
        -: 2656: * this function does not change the input mode.  The calling function
        -: 2657: * should have set cbreak mode if necessary.
        -: 2658: *
        -: 2659: * fd may be -1 to sleep until the timeout in microseconds.  This is a
        -: 2660: * fallback for old systems that don't have nanosleep().  Some very old
        -: 2661: * systems might not have select: get with it, daddy-o.
        -: 2662: */
        -: 2663:
        -: 2664:/**/
        -: 2665:mod_export int
    #####: 2666:read_poll(int fd, int *readchar, int polltty, zlong microseconds)
        -: 2667:{
    #####: 2668:    int ret = -1;
    #####: 2669:    long mode = -1;
        -: 2670:    char c;
        -: 2671:#ifdef HAVE_SELECT
        -: 2672:    fd_set foofd;
        -: 2673:    struct timeval expire_tv;
        -: 2674:#else
        -: 2675:#ifdef FIONREAD
        -: 2676:    int val;
        -: 2677:#endif
        -: 2678:#endif
        -: 2679:#ifdef HAS_TIO
        -: 2680:    struct ttyinfo ti;
        -: 2681:#endif
        -: 2682:
    #####: 2683:    if (fd < 0 || (polltty && !isatty(fd)))
    #####: 2684:	polltty = 0;		/* no tty to poll */
        -: 2685:
        -: 2686:#if defined(HAS_TIO) && !defined(__CYGWIN__)
        -: 2687:    /*
        -: 2688:     * Under Solaris, at least, reading from the terminal in non-canonical
        -: 2689:     * mode requires that we use the VMIN mechanism to poll.  Any attempt
        -: 2690:     * to check any other way, or to set the terminal to non-blocking mode
        -: 2691:     * and poll that way, fails; it will just for canonical mode input.
        -: 2692:     * We should probably use this mechanism if the user has set non-canonical
        -: 2693:     * mode, in which case testing here for isatty() and ~ICANON would be
        -: 2694:     * better than testing whether bin_read() set it, but for now we've got
        -: 2695:     * enough problems.
        -: 2696:     *
        -: 2697:     * Under Cygwin, you won't be surprised to here, this mechanism,
        -: 2698:     * although present, doesn't work, and we *have* to use ordinary
        -: 2699:     * non-blocking reads to find out if there is a character present
        -: 2700:     * in non-canonical mode.
        -: 2701:     *
        -: 2702:     * I am assuming Solaris is nearer the UNIX norm.  This is not necessarily
        -: 2703:     * as plausible as it sounds, but it seems the right way to guess.
        -: 2704:     *		pws 2000/06/26
        -: 2705:     */
    #####: 2706:    if (polltty && fd >= 0) {
    #####: 2707:	gettyinfo(&ti);
    #####: 2708:	if ((polltty = ti.tio.c_cc[VMIN])) {
    #####: 2709:	    ti.tio.c_cc[VMIN] = 0;
        -: 2710:	    /* termios timeout is 10ths of a second */
    #####: 2711:	    ti.tio.c_cc[VTIME] = (int) (microseconds / (zlong)100000);
    #####: 2712:	    settyinfo(&ti);
        -: 2713:	}
        -: 2714:    }
        -: 2715:#else
        -: 2716:    polltty = 0;
        -: 2717:#endif
        -: 2718:#ifdef HAVE_SELECT
    #####: 2719:    expire_tv.tv_sec = (int) (microseconds / (zlong)1000000);
    #####: 2720:    expire_tv.tv_usec = microseconds % (zlong)1000000;
    #####: 2721:    FD_ZERO(&foofd);
    #####: 2722:    if (fd > -1) {
    #####: 2723:	FD_SET(fd, &foofd);
    #####: 2724:	ret = select(fd+1, (SELECT_ARG_2_T) &foofd, NULL, NULL, &expire_tv);
        -: 2725:    } else
    #####: 2726:	ret = select(0, NULL, NULL, NULL, &expire_tv);
        -: 2727:#else
        -: 2728:    if (fd < 0) {
        -: 2729:	/* OK, can't do that.  Just quietly sleep for a second. */
        -: 2730:	sleep(1);
        -: 2731:	return 1;
        -: 2732:    }
        -: 2733:#ifdef FIONREAD
        -: 2734:    if (ioctl(fd, FIONREAD, (char *) &val) == 0)
        -: 2735:	ret = (val > 0);
        -: 2736:#endif
        -: 2737:#endif
        -: 2738:
    #####: 2739:    if (fd >= 0 && ret < 0 && !errflag) {
        -: 2740:	/*
        -: 2741:	 * Final attempt: set non-blocking read and try to read a character.
        -: 2742:	 * Praise Bill, this works under Cygwin (nothing else seems to).
        -: 2743:	 */
    #####: 2744:	if ((polltty || setblock_fd(0, fd, &mode)) && read(fd, &c, 1) > 0) {
    #####: 2745:	    *readchar = c;
    #####: 2746:	    ret = 1;
        -: 2747:	}
    #####: 2748:	if (mode != -1)
    #####: 2749:	    fcntl(fd, F_SETFL, mode);
        -: 2750:    }
        -: 2751:#ifdef HAS_TIO
    #####: 2752:    if (polltty) {
    #####: 2753:	ti.tio.c_cc[VMIN] = 1;
    #####: 2754:	ti.tio.c_cc[VTIME] = 0;
    #####: 2755:	settyinfo(&ti);
        -: 2756:    }
        -: 2757:#endif
    #####: 2758:    return (ret > 0);
        -: 2759:}
        -: 2760:
        -: 2761:/*
        -: 2762: * Return the difference between 2 times, given as struct timespec*,
        -: 2763: * expressed in microseconds, as a long.  If the difference doesn't fit
        -: 2764: * into a long, return LONG_MIN or LONG_MAX so that the times can still
        -: 2765: * be compared.
        -: 2766: *
        -: 2767: * Note: returns a long rather than a zlong because zsleep() below
        -: 2768: * takes a long.
        -: 2769: */
        -: 2770:
        -: 2771:/**/
        -: 2772:long
    #####: 2773:timespec_diff_us(const struct timespec *t1, const struct timespec *t2)
        -: 2774:{
    #####: 2775:    int reverse = (t1->tv_sec > t2->tv_sec);
        -: 2776:    time_t diff_sec;
        -: 2777:    long diff_usec, max_margin, res;
        -: 2778:
        -: 2779:    /* Don't just subtract t2-t1 because time_t might be unsigned. */
    #####: 2780:    diff_sec = (reverse ? t1->tv_sec - t2->tv_sec : t2->tv_sec - t1->tv_sec);
    #####: 2781:    if (diff_sec > LONG_MAX / 1000000L) {
    #####: 2782:	goto overflow;
        -: 2783:    }
    #####: 2784:    res = diff_sec * 1000000L;
    #####: 2785:    max_margin = LONG_MAX - res;
    #####: 2786:    diff_usec = (reverse ?
    #####: 2787:		 t1->tv_nsec - t2->tv_nsec : t2->tv_nsec - t1->tv_nsec
    #####: 2788:		 ) / 1000;
    #####: 2789:    if (diff_usec <= max_margin) {
    #####: 2790:	res += diff_usec;
    #####: 2791:	return (reverse ? -res : res);
        -: 2792:    }
    #####: 2793: overflow:
    #####: 2794:    return (reverse ? LONG_MIN : LONG_MAX);
        -: 2795:}
        -: 2796:
        -: 2797:/*
        -: 2798: * Sleep for the given number of microseconds --- must be within
        -: 2799: * range of a long at the moment, but this is only used for
        -: 2800: * limited internal purposes.
        -: 2801: */
        -: 2802:
        -: 2803:/**/
        -: 2804:int
    #####: 2805:zsleep(long us)
        -: 2806:{
        -: 2807:#ifdef HAVE_NANOSLEEP
        -: 2808:    struct timespec sleeptime;
        -: 2809:
    #####: 2810:    sleeptime.tv_sec = (time_t)us / (time_t)1000000;
    #####: 2811:    sleeptime.tv_nsec = (us % 1000000L) * 1000L;
    #####: 2812:    for (;;) {
        -: 2813:	struct timespec rem;
    #####: 2814:	int ret = nanosleep(&sleeptime, &rem);
        -: 2815:
    #####: 2816:	if (ret == 0)
    #####: 2817:	    return 1;
    #####: 2818:	else if (errno != EINTR)
    #####: 2819:	    return 0;
    #####: 2820:	sleeptime = rem;
        -: 2821:    }
        -: 2822:#else
        -: 2823:    int dummy;
        -: 2824:    return read_poll(-1, &dummy, 0, us);
        -: 2825:#endif
        -: 2826:}
        -: 2827:
        -: 2828:/**
        -: 2829: * Sleep for time (fairly) randomly up to max_us microseconds.
        -: 2830: * Don't let the wallclock time extend beyond end_time.
        -: 2831: * Return 1 if that seemed to work, else 0.
        -: 2832: *
        -: 2833: * For best results max_us should be a multiple of 2**16 or large
        -: 2834: * enough that it doesn't matter.
        -: 2835: */
        -: 2836:
        -: 2837:/**/
        -: 2838:int
    #####: 2839:zsleep_random(long max_us, time_t end_time)
        -: 2840:{
        -: 2841:    long r;
    #####: 2842:    time_t now = time(NULL);
        -: 2843:
        -: 2844:    /*
        -: 2845:     * Randomish backoff.  Doesn't need to be fundamentally
        -: 2846:     * unpredictable, just probably unlike the value another
        -: 2847:     * exiting shell is using.  On some systems the bottom 16
        -: 2848:     * bits aren't that random but the use here doesn't
        -: 2849:     * really care.
        -: 2850:     */
    #####: 2851:    r = (long)(rand() & 0xFFFF);
        -: 2852:    /*
        -: 2853:     * Turn this into a fraction of sleep_us.  Again, this
        -: 2854:     * doesn't need to be particularly accurate and the base time
        -: 2855:     * is sufficient that we can do the division first and not
        -: 2856:     * worry about the range.
        -: 2857:     */
    #####: 2858:    r = (max_us >> 16) * r;
        -: 2859:    /*
        -: 2860:     * Don't sleep beyond timeout.
        -: 2861:     * Not that important as timeout is ridiculously long, but
        -: 2862:     * if there's an interface, interface to it...
        -: 2863:     */
    #####: 2864:    while (r && now + (time_t)(r / 1000000) > end_time)
    #####: 2865:	r >>= 1;
    #####: 2866:    if (r) /* pedantry */
    #####: 2867:	return zsleep(r);
    #####: 2868:    return 0;
        -: 2869:}
        -: 2870:
        -: 2871:/**/
        -: 2872:int
    #####: 2873:checkrmall(char *s)
        -: 2874:{
        -: 2875:    DIR *rmd;
    #####: 2876:    int count = 0;
    #####: 2877:    if (!shout)
    #####: 2878:	return 1;
    #####: 2879:    if (*s != '/') {
    #####: 2880:	if (pwd[1])
    #####: 2881:	    s = zhtricat(pwd, "/", s);
        -: 2882:	else
    #####: 2883:	    s = dyncat("/", s);
        -: 2884:    }
    #####: 2885:    const int max_count = 100;
    #####: 2886:    if ((rmd = opendir(unmeta(s)))) {
    #####: 2887:	int ignoredots = !isset(GLOBDOTS);
        -: 2888:	char *fname;
        -: 2889:
    #####: 2890:	while ((fname = zreaddir(rmd, 1))) {
    #####: 2891:	    if (ignoredots && *fname == '.')
    #####: 2892:		continue;
    #####: 2893:	    count++;
    #####: 2894:	    if (count > max_count)
    #####: 2895:		break;
        -: 2896:	}
    #####: 2897:	closedir(rmd);
        -: 2898:    }
    #####: 2899:    if (count > max_count)
    #####: 2900:	fprintf(shout, "zsh: sure you want to delete more than %d files in ",
        -: 2901:		max_count);
    #####: 2902:    else if (count == 1)
    #####: 2903:	fprintf(shout, "zsh: sure you want to delete the only file in ");
    #####: 2904:    else if (count > 0)
    #####: 2905:	fprintf(shout, "zsh: sure you want to delete all %d files in ",
        -: 2906:		count);
        -: 2907:    else {
        -: 2908:	/* We don't know how many files the glob will expand to; see 41707. */
    #####: 2909:	fprintf(shout, "zsh: sure you want to delete all the files in ");
        -: 2910:    }
    #####: 2911:    nicezputs(s, shout);
    #####: 2912:    if(isset(RMSTARWAIT)) {
    #####: 2913:	fputs("? (waiting ten seconds)", shout);
    #####: 2914:	fflush(shout);
    #####: 2915:	zbeep();
    #####: 2916:	sleep(10);
    #####: 2917:	fputc('\n', shout);
        -: 2918:    }
    #####: 2919:    if (errflag)
    #####: 2920:      return 0;
    #####: 2921:    fputs(" [yn]? ", shout);
    #####: 2922:    fflush(shout);
    #####: 2923:    zbeep();
    #####: 2924:    return (getquery("ny", 1) == 'y');
        -: 2925:}
        -: 2926:
        -: 2927:/**/
        -: 2928:mod_export ssize_t
       12: 2929:read_loop(int fd, char *buf, size_t len)
        -: 2930:{
       12: 2931:    ssize_t got = len;
        -: 2932:
    #####: 2933:    while (1) {
       12: 2934:	ssize_t ret = read(fd, buf, len);
       12: 2935:	if (ret == len)
       12: 2936:	    break;
    #####: 2937:	if (ret <= 0) {
    #####: 2938:	    if (ret < 0) {
    #####: 2939:		if (errno == EINTR)
    #####: 2940:		    continue;
    #####: 2941:		if (fd != SHTTY)
    #####: 2942:		    zwarn("read failed: %e", errno);
        -: 2943:	    }
    #####: 2944:	    return ret;
        -: 2945:	}
    #####: 2946:	buf += ret;
    #####: 2947:	len -= ret;
        -: 2948:    }
        -: 2949:
       12: 2950:    return got;
        -: 2951:}
        -: 2952:
        -: 2953:/**/
        -: 2954:mod_export ssize_t
       12: 2955:write_loop(int fd, const char *buf, size_t len)
        -: 2956:{
       12: 2957:    ssize_t wrote = len;
        -: 2958:
    #####: 2959:    while (1) {
       12: 2960:	ssize_t ret = write(fd, buf, len);
       12: 2961:	if (ret == len)
       12: 2962:	    break;
    #####: 2963:	if (ret < 0) {
    #####: 2964:	    if (errno == EINTR)
    #####: 2965:		continue;
    #####: 2966:	    if (fd != SHTTY)
    #####: 2967:		zwarn("write failed: %e", errno);
    #####: 2968:	    return -1;
        -: 2969:	}
    #####: 2970:	buf += ret;
    #####: 2971:	len -= ret;
        -: 2972:    }
        -: 2973:
       12: 2974:    return wrote;
        -: 2975:}
        -: 2976:
        -: 2977:static int
    #####: 2978:read1char(int echo)
        -: 2979:{
        -: 2980:    char c;
    #####: 2981:    int q = queue_signal_level();
        -: 2982:
    #####: 2983:    dont_queue_signals();
    #####: 2984:    while (read(SHTTY, &c, 1) != 1) {
    #####: 2985:	if (errno != EINTR || errflag || retflag || breaks || contflag) {
    #####: 2986:	    restore_queue_signals(q);
    #####: 2987:	    return -1;
        -: 2988:	}
        -: 2989:    }
    #####: 2990:    restore_queue_signals(q);
    #####: 2991:    if (echo)
    #####: 2992:	write_loop(SHTTY, &c, 1);
    #####: 2993:    return STOUC(c);
        -: 2994:}
        -: 2995:
        -: 2996:/**/
        -: 2997:mod_export int
    #####: 2998:noquery(int purge)
        -: 2999:{
    #####: 3000:    int val = 0;
        -: 3001:
        -: 3002:#ifdef FIONREAD
        -: 3003:    char c;
        -: 3004:
    #####: 3005:    ioctl(SHTTY, FIONREAD, (char *)&val);
    #####: 3006:    if (purge) {
    #####: 3007:	for (; val; val--) {
    #####: 3008:	    if (read(SHTTY, &c, 1) != 1) {
        -: 3009:		/* Do nothing... */
        -: 3010:	    }
        -: 3011:	}
        -: 3012:    }
        -: 3013:#endif
        -: 3014:
    #####: 3015:    return val;
        -: 3016:}
        -: 3017:
        -: 3018:/**/
        -: 3019:int
    #####: 3020:getquery(char *valid_chars, int purge)
        -: 3021:{
    #####: 3022:    int c, d, nl = 0;
    #####: 3023:    int isem = !strcmp(term, "emacs");
        -: 3024:    struct ttyinfo ti;
        -: 3025:
    #####: 3026:    attachtty(mypgrp);
        -: 3027:
    #####: 3028:    gettyinfo(&ti);
        -: 3029:#ifdef HAS_TIO
    #####: 3030:    ti.tio.c_lflag &= ~ECHO;
    #####: 3031:    if (!isem) {
    #####: 3032:	ti.tio.c_lflag &= ~ICANON;
    #####: 3033:	ti.tio.c_cc[VMIN] = 1;
    #####: 3034:	ti.tio.c_cc[VTIME] = 0;
        -: 3035:    }
        -: 3036:#else
        -: 3037:    ti.sgttyb.sg_flags &= ~ECHO;
        -: 3038:    if (!isem)
        -: 3039:	ti.sgttyb.sg_flags |= CBREAK;
        -: 3040:#endif
    #####: 3041:    settyinfo(&ti);
        -: 3042:
    #####: 3043:    if (noquery(purge)) {
    #####: 3044:	if (!isem)
    #####: 3045:	    settyinfo(&shttyinfo);
    #####: 3046:	write_loop(SHTTY, "n\n", 2);
    #####: 3047:	return 'n';
        -: 3048:    }
        -: 3049:
    #####: 3050:    while ((c = read1char(0)) >= 0) {
    #####: 3051:	if (c == 'Y')
    #####: 3052:	    c = 'y';
    #####: 3053:	else if (c == 'N')
    #####: 3054:	    c = 'n';
    #####: 3055:	if (!valid_chars)
    #####: 3056:	    break;
    #####: 3057:	if (c == '\n') {
    #####: 3058:	    c = *valid_chars;
    #####: 3059:	    nl = 1;
    #####: 3060:	    break;
        -: 3061:	}
    #####: 3062:	if (strchr(valid_chars, c)) {
    #####: 3063:	    nl = 1;
    #####: 3064:	    break;
        -: 3065:	}
    #####: 3066:	zbeep();
        -: 3067:    }
    #####: 3068:    if (c >= 0) {
    #####: 3069:	char buf = (char)c;
    #####: 3070:	write_loop(SHTTY, &buf, 1);
        -: 3071:    }
    #####: 3072:    if (nl)
    #####: 3073:	write_loop(SHTTY, "\n", 1);
        -: 3074:
    #####: 3075:    if (isem) {
    #####: 3076:	if (c != '\n')
    #####: 3077:	    while ((d = read1char(1)) >= 0 && d != '\n');
        -: 3078:    } else {
    #####: 3079:	if (c != '\n' && !valid_chars) {
        -: 3080:#ifdef MULTIBYTE_SUPPORT
    #####: 3081:	    if (isset(MULTIBYTE) && c >= 0) {
        -: 3082:		/*
        -: 3083:		 * No waiting for a valid character, and no draining;
        -: 3084:		 * we should ensure we haven't stopped in the middle
        -: 3085:		 * of a multibyte character.
        -: 3086:		 */
        -: 3087:		mbstate_t mbs;
    #####: 3088:		char cc = (char)c;
    #####: 3089:		memset(&mbs, 0, sizeof(mbs));
    #####: 3090:		for (;;) {
    #####: 3091:		    size_t ret = mbrlen(&cc, 1, &mbs);
        -: 3092:
    #####: 3093:		    if (ret != MB_INCOMPLETE)
    #####: 3094:			break;
    #####: 3095:		    c = read1char(1);
    #####: 3096:		    if (c < 0)
    #####: 3097:			break;
    #####: 3098:		    cc = (char)c;
        -: 3099:		}
        -: 3100:	    }
        -: 3101:#endif
    #####: 3102:	    write_loop(SHTTY, "\n", 1);
        -: 3103:	}
        -: 3104:    }
    #####: 3105:    settyinfo(&shttyinfo);
    #####: 3106:    return c;
        -: 3107:}
        -: 3108:
        -: 3109:static int d;
        -: 3110:static char *guess, *best;
        -: 3111:static Patprog spckpat, spnamepat;
        -: 3112:
        -: 3113:/**/
        -: 3114:static void
    #####: 3115:spscan(HashNode hn, UNUSED(int scanflags))
        -: 3116:{
        -: 3117:    int nd;
        -: 3118:
    #####: 3119:    if (spckpat && pattry(spckpat, hn->nam))
    #####: 3120:	return;
        -: 3121:
    #####: 3122:    nd = spdist(hn->nam, guess, (int) strlen(guess) / 4 + 1);
    #####: 3123:    if (nd <= d) {
    #####: 3124:	best = hn->nam;
    #####: 3125:	d = nd;
        -: 3126:    }
        -: 3127:}
        -: 3128:
        -: 3129:/* spellcheck a word */
        -: 3130:/* fix s ; if hist is nonzero, fix the history list too */
        -: 3131:
        -: 3132:/**/
        -: 3133:mod_export void
    #####: 3134:spckword(char **s, int hist, int cmd, int ask)
        -: 3135:{
        -: 3136:    char *t, *correct_ignore;
    #####: 3137:    char ic = '\0';
    #####: 3138:    int preflen = 0;
    #####: 3139:    int autocd = cmd && isset(AUTOCD) && strcmp(*s, ".") && strcmp(*s, "..");
        -: 3140:
    #####: 3141:    if (!(*s)[0] || !(*s)[1])
    #####: 3142:	return;
    #####: 3143:    if ((histdone & HISTFLAG_NOEXEC) ||
        -: 3144:	/* Leading % is a job, else leading hyphen is an option */
    #####: 3145:	(cmd ? **s == '%' : (**s == '-' || **s == Dash)))
    #####: 3146:	return;
    #####: 3147:    if (!strcmp(*s, "in"))
    #####: 3148:	return;
    #####: 3149:    if (cmd) {
    #####: 3150:	if (shfunctab->getnode(shfunctab, *s) ||
    #####: 3151:	    builtintab->getnode(builtintab, *s) ||
    #####: 3152:	    cmdnamtab->getnode(cmdnamtab, *s) ||
    #####: 3153:	    aliastab->getnode(aliastab, *s)  ||
    #####: 3154:	    reswdtab->getnode(reswdtab, *s))
    #####: 3155:	    return;
    #####: 3156:	else if (isset(HASHLISTALL)) {
    #####: 3157:	    cmdnamtab->filltable(cmdnamtab);
    #####: 3158:	    if (cmdnamtab->getnode(cmdnamtab, *s))
    #####: 3159:		return;
        -: 3160:	}
        -: 3161:    }
    #####: 3162:    t = *s;
    #####: 3163:    if (*t == Tilde || *t == Equals || *t == String)
    #####: 3164:	t++;
    #####: 3165:    for (; *t; t++)
    #####: 3166:	if (itok(*t)) {
    #####: 3167:	    if (*t == Dash)
    #####: 3168:		*t = '-';
        -: 3169:	    else
    #####: 3170:		return;
        -: 3171:	}
    #####: 3172:    best = NULL;
    #####: 3173:    for (t = *s; *t; t++)
    #####: 3174:	if (*t == '/')
    #####: 3175:	    break;
    #####: 3176:    if (**s == Tilde && !*t)
    #####: 3177:	return;
        -: 3178:
    #####: 3179:    if ((correct_ignore = getsparam("CORRECT_IGNORE")) != NULL) {
    #####: 3180:	tokenize(correct_ignore = dupstring(correct_ignore));
    #####: 3181:	remnulargs(correct_ignore);
    #####: 3182:	spckpat = patcompile(correct_ignore, 0, NULL);
        -: 3183:    } else
    #####: 3184:	spckpat = NULL;
        -: 3185:
    #####: 3186:    if ((correct_ignore = getsparam("CORRECT_IGNORE_FILE")) != NULL) {
    #####: 3187:	tokenize(correct_ignore = dupstring(correct_ignore));
    #####: 3188:	remnulargs(correct_ignore);
    #####: 3189:	spnamepat = patcompile(correct_ignore, 0, NULL);
        -: 3190:    } else
    #####: 3191:	spnamepat = NULL;
        -: 3192:
    #####: 3193:    if (**s == String && !*t) {
    #####: 3194:	guess = *s + 1;
    #####: 3195:	if (itype_end(guess, IIDENT, 1) == guess)
    #####: 3196:	    return;
    #####: 3197:	ic = String;
    #####: 3198:	d = 100;
    #####: 3199:	scanhashtable(paramtab, 1, 0, 0, spscan, 0);
    #####: 3200:    } else if (**s == Equals) {
    #####: 3201:	if (*t)
    #####: 3202:	    return;
    #####: 3203:	if (hashcmd(guess = *s + 1, pathchecked))
    #####: 3204:	    return;
    #####: 3205:	d = 100;
    #####: 3206:	ic = Equals;
    #####: 3207:	scanhashtable(aliastab, 1, 0, 0, spscan, 0);
    #####: 3208:	scanhashtable(cmdnamtab, 1, 0, 0, spscan, 0);
        -: 3209:    } else {
    #####: 3210:	guess = *s;
    #####: 3211:	if (*guess == Tilde || *guess == String) {
        -: 3212:	    int ne;
    #####: 3213:	    ic = *guess;
    #####: 3214:	    if (!*++t)
    #####: 3215:		return;
    #####: 3216:	    guess = dupstring(guess);
    #####: 3217:	    ne = noerrs;
    #####: 3218:	    noerrs = 2;
    #####: 3219:	    singsub(&guess);
    #####: 3220:	    noerrs = ne;
    #####: 3221:	    if (!guess)
    #####: 3222:		return;
    #####: 3223:	    preflen = strlen(guess) - strlen(t);
        -: 3224:	}
    #####: 3225:	if (access(unmeta(guess), F_OK) == 0)
    #####: 3226:	    return;
    #####: 3227:	best = spname(guess);
    #####: 3228:	if (!*t && cmd) {
    #####: 3229:	    if (hashcmd(guess, pathchecked))
    #####: 3230:		return;
    #####: 3231:	    d = 100;
    #####: 3232:	    scanhashtable(reswdtab, 1, 0, 0, spscan, 0);
    #####: 3233:	    scanhashtable(aliastab, 1, 0, 0, spscan, 0);
    #####: 3234:	    scanhashtable(shfunctab, 1, 0, 0, spscan, 0);
    #####: 3235:	    scanhashtable(builtintab, 1, 0, 0, spscan, 0);
    #####: 3236:	    scanhashtable(cmdnamtab, 1, 0, 0, spscan, 0);
    #####: 3237:	    if (autocd) {
        -: 3238:		char **pp;
    #####: 3239:		if (cd_able_vars(unmeta(guess)))
    #####: 3240:		    return;
    #####: 3241:		for (pp = cdpath; *pp; pp++) {
        -: 3242:		    char bestcd[PATH_MAX + 1];
        -: 3243:		    int thisdist;
        -: 3244:		    /* Less than d here, instead of less than or equal  *
        -: 3245:		     * as used in spscan(), so that an autocd is chosen *
        -: 3246:		     * only when it is better than anything so far, and *
        -: 3247:		     * so we prefer directories earlier in the cdpath.  */
    #####: 3248:		    if ((thisdist = mindist(*pp, *s, bestcd, 1)) < d) {
    #####: 3249:			best = dupstring(bestcd);
    #####: 3250:			d = thisdist;
        -: 3251:		    }
        -: 3252:		}
        -: 3253:	    }
        -: 3254:	}
        -: 3255:    }
    #####: 3256:    if (errflag)
    #####: 3257:	return;
    #####: 3258:    if (best && (int)strlen(best) > 1 && strcmp(best, guess)) {
        -: 3259:	int x;
    #####: 3260:	if (ic) {
        -: 3261:	    char *u;
    #####: 3262:	    if (preflen) {
        -: 3263:		/* do not correct the result of an expansion */
    #####: 3264:		if (strncmp(guess, best, preflen))
    #####: 3265:		    return;
        -: 3266:		/* replace the temporarily expanded prefix with the original */
    #####: 3267:		u = (char *) zhalloc(t - *s + strlen(best + preflen) + 1);
    #####: 3268:		strncpy(u, *s, t - *s);
    #####: 3269:		strcpy(u + (t - *s), best + preflen);
        -: 3270:	    } else {
    #####: 3271:		u = (char *) zhalloc(strlen(best) + 2);
    #####: 3272:		*u = '\0';
    #####: 3273:		strcpy(u + 1, best);
        -: 3274:	    }
    #####: 3275:	    best = u;
    #####: 3276:	    guess = *s;
    #####: 3277:	    *guess = *best = ztokens[ic - Pound];
        -: 3278:	}
    #####: 3279:	if (ask) {
    #####: 3280:	    if (noquery(0)) {
    #####: 3281:		x = 'n';
    #####: 3282:	    } else if (shout) {
        -: 3283:		char *pptbuf;
    #####: 3284:		pptbuf = promptexpand(sprompt, 0, best, guess, NULL);
    #####: 3285:		zputs(pptbuf, shout);
    #####: 3286:		free(pptbuf);
    #####: 3287:		fflush(shout);
    #####: 3288:		zbeep();
    #####: 3289:		x = getquery("nyae", 0);
    #####: 3290:		if (cmd && x == 'n')
    #####: 3291:		    pathchecked = path;
        -: 3292:	    } else
    #####: 3293:		x = 'n';
        -: 3294:	} else
    #####: 3295:	    x = 'y';
    #####: 3296:	if (x == 'y') {
    #####: 3297:	    *s = dupstring(best);
    #####: 3298:	    if (hist)
    #####: 3299:		hwrep(best);
    #####: 3300:	} else if (x == 'a') {
    #####: 3301:	    histdone |= HISTFLAG_NOEXEC;
    #####: 3302:	} else if (x == 'e') {
    #####: 3303:	    histdone |= HISTFLAG_NOEXEC | HISTFLAG_RECALL;
        -: 3304:	}
    #####: 3305:	if (ic)
    #####: 3306:	    **s = ic;
        -: 3307:    }
        -: 3308:}
        -: 3309:
        -: 3310:/*
        -: 3311: * Helper for ztrftime.  Called with a pointer to the length left
        -: 3312: * in the buffer, and a new string length to decrement from that.
        -: 3313: * Returns 0 if the new length fits, 1 otherwise.  We assume a terminating
        -: 3314: * NUL and return 1 if that doesn't fit.
        -: 3315: */
        -: 3316:
        -: 3317:static int
    #####: 3318:ztrftimebuf(int *bufsizeptr, int decr)
        -: 3319:{
    #####: 3320:    if (*bufsizeptr <= decr)
    #####: 3321:	return 1;
    #####: 3322:    *bufsizeptr -= decr;
    #####: 3323:    return 0;
        -: 3324:}
        -: 3325:
        -: 3326:/*
        -: 3327: * Like the system function, this returns the number of characters
        -: 3328: * copied, not including the terminating NUL.  This may be zero
        -: 3329: * if the string didn't fit.
        -: 3330: *
        -: 3331: * As an extension, try to detect an error in strftime --- typically
        -: 3332: * not enough memory --- and return -1.  Not guaranteed to be portable,
        -: 3333: * since the strftime() interface doesn't make any guarantees about
        -: 3334: * the state of the buffer if it returns zero.
        -: 3335: *
        -: 3336: * fmt is metafied, but we need to unmetafy it on the fly to
        -: 3337: * pass into strftime / combine with the output from strftime.
        -: 3338: * The return value in buf is not metafied.
        -: 3339: */
        -: 3340:
        -: 3341:/**/
        -: 3342:mod_export int
    #####: 3343:ztrftime(char *buf, int bufsize, char *fmt, struct tm *tm, long nsec)
        -: 3344:{
        -: 3345:    int hr12;
        -: 3346:#ifdef HAVE_STRFTIME
        -: 3347:    int decr;
        -: 3348:    char *fmtstart;
        -: 3349:#else
        -: 3350:    static char *astr[] =
        -: 3351:    {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
        -: 3352:    static char *estr[] =
        -: 3353:    {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul",
        -: 3354:     "Aug", "Sep", "Oct", "Nov", "Dec"};
        -: 3355:#endif
    #####: 3356:    char *origbuf = buf;
        -: 3357:
        -: 3358:
    #####: 3359:    while (*fmt) {
    #####: 3360:	if (*fmt == Meta) {
    #####: 3361:	    int chr = fmt[1] ^ 32;
    #####: 3362:	    if (ztrftimebuf(&bufsize, 1))
    #####: 3363:		return -1;
    #####: 3364:	    *buf++ = chr;
    #####: 3365:	    fmt += 2;
    #####: 3366:	} else if (*fmt == '%') {
        -: 3367:	    int strip;
    #####: 3368:	    int digs = 3;
        -: 3369:
        -: 3370:#ifdef HAVE_STRFTIME
    #####: 3371:	    fmtstart =
        -: 3372:#endif
    #####: 3373:	    fmt++;
        -: 3374:
    #####: 3375:	    if (*fmt == '-') {
    #####: 3376:		strip = 1;
    #####: 3377:		fmt++;
        -: 3378:	    } else
    #####: 3379:		strip = 0;
    #####: 3380:	    if (idigit(*fmt)) {
        -: 3381:		/* Digit --- only useful with . */
    #####: 3382:		char *dstart = fmt;
    #####: 3383:		char *dend = fmt+1;
    #####: 3384:		while (idigit(*dend))
    #####: 3385:		    dend++;
    #####: 3386:		if (*dend == '.') {
    #####: 3387:		    fmt = dend;
    #####: 3388:		    digs = atoi(dstart);
        -: 3389:		}
        -: 3390:	    }
        -: 3391:	    /*
        -: 3392:	     * Assume this format will take up at least two
        -: 3393:	     * characters.  Not always true, but if that matters
        -: 3394:	     * we are so close to the edge it's not a big deal.
        -: 3395:	     * Fix up some longer cases specially when we get to them.
        -: 3396:	     */
    #####: 3397:	    if (ztrftimebuf(&bufsize, 2))
    #####: 3398:		return -1;
        -: 3399:#ifdef HAVE_STRFTIME
        -: 3400:	    /* Our internal handling doesn't handle padding and other gnu extensions,
        -: 3401:	     * so here we detect them and pass over to strftime(). We don't want
        -: 3402:	     * to do this unconditionally though, as we have some extensions that
        -: 3403:	     * strftime() doesn't have (%., %f, %L and %K) */
    #####: 3404:morefmt:
    #####: 3405:	    if (!((fmt - fmtstart == 1) || (fmt - fmtstart == 2 && strip) || *fmt == '.')) {
    #####: 3406:		while (*fmt && strchr("OE^#_-0123456789", *fmt))
    #####: 3407:		    fmt++;
    #####: 3408:		if (*fmt) {
    #####: 3409:		    fmt++;
    #####: 3410:		    goto strftimehandling;
        -: 3411:		}
        -: 3412:	    }
        -: 3413:#endif
    #####: 3414:	    switch (*fmt++) {
    #####: 3415:	    case '.':
        -: 3416:	    {
    #####: 3417:		long fnsec = nsec;
    #####: 3418:		if (digs < 0 || digs > 9)
    #####: 3419:		    digs = 9;
    #####: 3420:		if (ztrftimebuf(&bufsize, digs))
    #####: 3421:		    return -1;
    #####: 3422:		if (digs < 9) {
        -: 3423:		    int trunc;
    #####: 3424:		    long max = 100000000;
    #####: 3425:		    for (trunc = 8 - digs; trunc; trunc--) {
    #####: 3426:			max /= 10;
    #####: 3427:			fnsec /= 10;
        -: 3428:		    }
    #####: 3429:		    max -= 1;
    #####: 3430:		    fnsec = (fnsec + 5) / 10;
    #####: 3431:		    if (fnsec > max)
    #####: 3432:			fnsec = max;
        -: 3433:		}
    #####: 3434:		sprintf(buf, "%0*ld", digs, fnsec);
    #####: 3435:		buf += digs;
    #####: 3436:		break;
        -: 3437:	    }
    #####: 3438:	    case '\0':
        -: 3439:		/* Guard against premature end of string */
    #####: 3440:		*buf++ = '%';
    #####: 3441:		fmt--;
    #####: 3442:		break;
    #####: 3443:	    case 'f':
    #####: 3444:		strip = 1;
        -: 3445:		/* FALLTHROUGH */
    #####: 3446:	    case 'e':
    #####: 3447:		if (tm->tm_mday > 9)
    #####: 3448:		    *buf++ = '0' + tm->tm_mday / 10;
    #####: 3449:		else if (!strip)
    #####: 3450:		    *buf++ = ' ';
    #####: 3451:		*buf++ = '0' + tm->tm_mday % 10;
    #####: 3452:		break;
    #####: 3453:	    case 'K':
    #####: 3454:		strip = 1;
        -: 3455:		/* FALLTHROUGH */
    #####: 3456:	    case 'H':
        -: 3457:	    case 'k':
    #####: 3458:		if (tm->tm_hour > 9)
    #####: 3459:		    *buf++ = '0' + tm->tm_hour / 10;
    #####: 3460:		else if (!strip) {
    #####: 3461:		    if (fmt[-1] == 'H')
    #####: 3462:			*buf++ = '0';
        -: 3463:		    else
    #####: 3464:			*buf++ = ' ';
        -: 3465:		}
    #####: 3466:		*buf++ = '0' + tm->tm_hour % 10;
    #####: 3467:		break;
    #####: 3468:	    case 'L':
    #####: 3469:		strip = 1;
        -: 3470:		/* FALLTHROUGH */
    #####: 3471:	    case 'l':
    #####: 3472:		hr12 = tm->tm_hour % 12;
    #####: 3473:		if (hr12 == 0)
    #####: 3474:		    hr12 = 12;
    #####: 3475:	        if (hr12 > 9)
    #####: 3476:		    *buf++ = '1';
    #####: 3477:		else if (!strip)
    #####: 3478:		    *buf++ = ' ';
        -: 3479:
    #####: 3480:		*buf++ = '0' + (hr12 % 10);
    #####: 3481:		break;
    #####: 3482:	    case 'd':
    #####: 3483:		if (tm->tm_mday > 9 || !strip)
    #####: 3484:		    *buf++ = '0' + tm->tm_mday / 10;
    #####: 3485:		*buf++ = '0' + tm->tm_mday % 10;
    #####: 3486:		break;
    #####: 3487:	    case 'm':
    #####: 3488:		if (tm->tm_mon > 8 || !strip)
    #####: 3489:		    *buf++ = '0' + (tm->tm_mon + 1) / 10;
    #####: 3490:		*buf++ = '0' + (tm->tm_mon + 1) % 10;
    #####: 3491:		break;
    #####: 3492:	    case 'M':
    #####: 3493:		if (tm->tm_min > 9 || !strip)
    #####: 3494:		    *buf++ = '0' + tm->tm_min / 10;
    #####: 3495:		*buf++ = '0' + tm->tm_min % 10;
    #####: 3496:		break;
    #####: 3497:	    case 'N':
    #####: 3498:		if (ztrftimebuf(&bufsize, 9))
    #####: 3499:		    return -1;
    #####: 3500:		sprintf(buf, "%09ld", nsec);
    #####: 3501:		buf += 9;
    #####: 3502:		break;
    #####: 3503:	    case 'S':
    #####: 3504:		if (tm->tm_sec > 9 || !strip)
    #####: 3505:		    *buf++ = '0' + tm->tm_sec / 10;
    #####: 3506:		*buf++ = '0' + tm->tm_sec % 10;
    #####: 3507:		break;
    #####: 3508:	    case 'y':
    #####: 3509:		if (tm->tm_year > 9 || !strip)
    #####: 3510:		    *buf++ = '0' + (tm->tm_year / 10) % 10;
    #####: 3511:		*buf++ = '0' + tm->tm_year % 10;
    #####: 3512:		break;
        -: 3513:#ifndef HAVE_STRFTIME
        -: 3514:	    case 'Y':
        -: 3515:	    {
        -: 3516:		int year, digits, testyear;
        -: 3517:		year = tm->tm_year + 1900;
        -: 3518:		digits = 1;
        -: 3519:		testyear = year;
        -: 3520:		while (testyear > 9) {
        -: 3521:		    digits++;
        -: 3522:		    testyear /= 10;
        -: 3523:		}
        -: 3524:		if (ztrftimebuf(&bufsize, digits))
        -: 3525:		    return -1;
        -: 3526:		sprintf(buf, "%d", year);
        -: 3527:		buf += digits;
        -: 3528:		break;
        -: 3529:	    }
        -: 3530:	    case 'a':
        -: 3531:		if (ztrftimebuf(&bufsize, strlen(astr[tm->tm_wday]) - 2))
        -: 3532:		    return -1;
        -: 3533:		strucpy(&buf, astr[tm->tm_wday]);
        -: 3534:		break;
        -: 3535:	    case 'b':
        -: 3536:		if (ztrftimebuf(&bufsize, strlen(estr[tm->tm_mon]) - 2))
        -: 3537:		    return -1;
        -: 3538:		strucpy(&buf, estr[tm->tm_mon]);
        -: 3539:		break;
        -: 3540:	    case 'p':
        -: 3541:		*buf++ = (tm->tm_hour > 11) ? 'p' : 'a';
        -: 3542:		*buf++ = 'm';
        -: 3543:		break;
        -: 3544:	    default:
        -: 3545:		*buf++ = '%';
        -: 3546:		if (fmt[-1] != '%')
        -: 3547:		    *buf++ = fmt[-1];
        -: 3548:#else
    #####: 3549:	    case 'E':
        -: 3550:	    case 'O':
        -: 3551:	    case '^':
        -: 3552:	    case '#':
        -: 3553:	    case '_':
        -: 3554:	    case '-':
        -: 3555:	    case '0': case '1': case '2': case '3': case '4':
        -: 3556:	    case '5': case '6': case '7': case '8': case '9':
    #####: 3557:		goto morefmt;
    #####: 3558:strftimehandling:
        -: 3559:	    default:
        -: 3560:		/*
        -: 3561:		 * Remember we've already allowed for two characters
        -: 3562:		 * in the accounting in bufsize (but nowhere else).
        -: 3563:		 */
        -: 3564:		{
    #####: 3565:		    char origchar = fmt[-1];
    #####: 3566:		    int size = fmt - fmtstart;
        -: 3567:		    char *tmp, *last;
    #####: 3568:		    tmp = zhalloc(size + 1);
    #####: 3569:		    strncpy(tmp, fmtstart, size);
    #####: 3570:		    last = fmt-1;
    #####: 3571:		    if (*last == Meta) {
        -: 3572:			/*
        -: 3573:			 * This is for consistency in counting:
        -: 3574:			 * a metafiable character isn't actually
        -: 3575:			 * a valid strftime descriptor.
        -: 3576:			 *
        -: 3577:			 * Previous characters were explicitly checked,
        -: 3578:			 * so can't be metafied.
        -: 3579:			 */
    #####: 3580:			*last = *++fmt ^ 32;
        -: 3581:		    }
    #####: 3582:		    tmp[size] = '\0';
    #####: 3583:		    *buf = '\1';
    #####: 3584:		    if (!strftime(buf, bufsize + 2, tmp, tm))
        -: 3585:		    {
        -: 3586:			/*
        -: 3587:			 * Some locales don't have strings for
        -: 3588:			 * AM/PM, so empty output is valid.
        -: 3589:			 */
    #####: 3590:			if (*buf || (origchar != 'p' && origchar != 'P')) {
    #####: 3591:			    if (*buf) {
    #####: 3592:				buf[0] = '\0';
    #####: 3593:				return -1;
        -: 3594:			    }
    #####: 3595:			    return 0;
        -: 3596:			}
        -: 3597:		    }
    #####: 3598:		    decr = strlen(buf);
    #####: 3599:		    buf += decr;
    #####: 3600:		    bufsize -= decr - 2;
        -: 3601:		}
        -: 3602:#endif
    #####: 3603:		break;
        -: 3604:	    }
        -: 3605:	} else {
    #####: 3606:	    if (ztrftimebuf(&bufsize, 1))
    #####: 3607:		return -1;
    #####: 3608:	    *buf++ = *fmt++;
        -: 3609:	}
        -: 3610:    }
    #####: 3611:    *buf = '\0';
    #####: 3612:    return buf - origbuf;
        -: 3613:}
        -: 3614:
        -: 3615:/*
        -: 3616: * Return a string consisting of the elements of 'arr' joined by the character
        -: 3617: * 'delim', which will be metafied if necessary.  The string will be allocated
        -: 3618: * on the heap iff 'heap'.
        -: 3619: *
        -: 3620: * Comparable to:
        -: 3621: *
        -: 3622: *     char metafied_delim[] = { Meta, delim ^ 32, '\0' };
        -: 3623: *     sepjoin(arr, metafied_delim, heap)
        -: 3624: */
        -: 3625:
        -: 3626:/**/
        -: 3627:mod_export char *
        5: 3628:zjoin(char **arr, int delim, int heap)
        -: 3629:{
        5: 3630:    int len = 0;
        -: 3631:    char **s, *ret, *ptr;
        -: 3632:
       20: 3633:    for (s = arr; *s; s++)
       15: 3634:	len += strlen(*s) + 1 + (imeta(delim) ? 1 : 0);
        5: 3635:    if (!len)
    #####: 3636:	return heap? "" : ztrdup("");
        5: 3637:    ptr = ret = (char *) (heap ? zhalloc(len) : zalloc(len));
       20: 3638:    for (s = arr; *s; s++) {
       15: 3639:	strucpy(&ptr, *s);
       15: 3640:	    if (imeta(delim)) {
    #####: 3641:		*ptr++ = Meta;
    #####: 3642:		*ptr++ = delim ^ 32;
        -: 3643:	    }
        -: 3644:	    else
       15: 3645:		*ptr++ = delim;
        -: 3646:    }
        5: 3647:    ptr[-1 - (imeta(delim) ? 1 : 0)] = '\0';
        5: 3648:    return ret;
        -: 3649:}
        -: 3650:
        -: 3651:/* Split a string containing a colon separated list *
        -: 3652: * of items into an array of strings.               */
        -: 3653:
        -: 3654:/**/
        -: 3655:mod_export char **
        2: 3656:colonsplit(char *s, int uniq)
        -: 3657:{
        -: 3658:    int ct;
        -: 3659:    char *t, **ret, **ptr, **p;
        -: 3660:
      122: 3661:    for (t = s, ct = 0; *t; t++) /* count number of colons */
      120: 3662:	if (*t == ':')
       10: 3663:	    ct++;
        2: 3664:    ptr = ret = (char **) zalloc(sizeof(char *) * (ct + 2));
        -: 3665:
        2: 3666:    t = s;
        -: 3667:    do {
       12: 3668:	s = t;
        -: 3669:        /* move t to point at next colon */
       12: 3670:	for (; *t && *t != ':'; t++);
       12: 3671:	if (uniq)
    #####: 3672:	    for (p = ret; p < ptr; p++)
    #####: 3673:		if ((int)strlen(*p) == t - s && ! strncmp(*p, s, t - s))
    #####: 3674:		    goto cont;
       12: 3675:	*ptr = (char *) zalloc((t - s) + 1);
       12: 3676:	ztrncpy(*ptr++, s, t - s);
       12: 3677:      cont: ;
        -: 3678:    }
       12: 3679:    while (*t++);
        2: 3680:    *ptr = NULL;
        2: 3681:    return ret;
        -: 3682:}
        -: 3683:
        -: 3684:/**/
        -: 3685:static int
    #####: 3686:skipwsep(char **s)
        -: 3687:{
    #####: 3688:    char *t = *s;
    #####: 3689:    int i = 0;
        -: 3690:
        -: 3691:    /*
        -: 3692:     * Don't need to handle mutlibyte characters, they can't
        -: 3693:     * be IWSEP.  Do need to check for metafication.
        -: 3694:     */
    #####: 3695:    while (*t && iwsep(*t == Meta ? t[1] ^ 32 : *t)) {
    #####: 3696:	if (*t == Meta)
    #####: 3697:	    t++;
    #####: 3698:	t++;
    #####: 3699:	i++;
        -: 3700:    }
    #####: 3701:    *s = t;
    #####: 3702:    return i;
        -: 3703:}
        -: 3704:
        -: 3705:/*
        -: 3706: * haven't worked out what allownull does; it's passed down from
        -: 3707: *   sepsplit but all the cases it's used are either 0 or 1 without
        -: 3708: *   a comment.  it seems to be something to do with the `nulstring'
        -: 3709: *   which i think is some kind of a metafication thing, so probably
        -: 3710: *   allownull's value is associated with whether we are using
        -: 3711: *   metafied strings.
        -: 3712: * see findsep() below for handling of `quote' argument
        -: 3713: */
        -: 3714:
        -: 3715:/**/
        -: 3716:mod_export char **
    #####: 3717:spacesplit(char *s, int allownull, int heap, int quote)
        -: 3718:{
        -: 3719:    char *t, **ret, **ptr;
    #####: 3720:    int l = sizeof(*ret) * (wordcount(s, NULL, -!allownull) + 1);
    #####: 3721:    char *(*dup)(const char *) = (heap ? dupstring : ztrdup);
        -: 3722:
        -: 3723:    /* ### TODO: s/calloc/alloc/ */
    #####: 3724:    ptr = ret = (char **) (heap ? hcalloc(l) : zshcalloc(l));
        -: 3725:
    #####: 3726:    if (quote) {
        -: 3727:	/*
        -: 3728:	 * we will be stripping quoted separators by hacking string,
        -: 3729:	 * so make sure it's hackable.
        -: 3730:	 */
    #####: 3731:	s = dupstring(s);
        -: 3732:    }
        -: 3733:
    #####: 3734:    t = s;
    #####: 3735:    skipwsep(&s);
    #####: 3736:    MB_METACHARINIT();
    #####: 3737:    if (*s && itype_end(s, ISEP, 1) != s)
    #####: 3738:	*ptr++ = dup(allownull ? "" : nulstring);
    #####: 3739:    else if (!allownull && t != s)
    #####: 3740:	*ptr++ = dup("");
    #####: 3741:    while (*s) {
    #####: 3742:	char *iend = itype_end(s, ISEP, 1);
    #####: 3743:	if (iend != s) {
    #####: 3744:	    s = iend;
    #####: 3745:	    skipwsep(&s);
        -: 3746:	}
    #####: 3747:	else if (quote && *s == '\\') {
    #####: 3748:	    s++;
    #####: 3749:	    skipwsep(&s);
        -: 3750:	}
    #####: 3751:	t = s;
    #####: 3752:	(void)findsep(&s, NULL, quote);
    #####: 3753:	if (s > t || allownull) {
    #####: 3754:	    *ptr = (char *) (heap ? zhalloc((s - t) + 1) :
    #####: 3755:		                     zalloc((s - t) + 1));
    #####: 3756:	    ztrncpy(*ptr++, t, s - t);
        -: 3757:	} else
    #####: 3758:	    *ptr++ = dup(nulstring);
    #####: 3759:	t = s;
    #####: 3760:	skipwsep(&s);
        -: 3761:    }
    #####: 3762:    if (!allownull && t != s)
    #####: 3763:	*ptr++ = dup("");
    #####: 3764:    *ptr = NULL;
    #####: 3765:    return ret;
        -: 3766:}
        -: 3767:
        -: 3768:/*
        -: 3769: * Find a separator.  Return 0 if already at separator, 1 if separator
        -: 3770: * found later, else -1.  (Historical note: used to return length into
        -: 3771: * string but this is all that is necessary and is less ambiguous with
        -: 3772: * multibyte characters around.)
        -: 3773: *
        -: 3774: * *s is the string we are looking along, which will be updated
        -: 3775: * to the point we have got to.
        -: 3776: *
        -: 3777: * sep is a possibly multicharacter separator to look for.  If NULL,
        -: 3778: * use normal separator characters.  If *sep is NULL, split on individual
        -: 3779: * characters.
        -: 3780: *
        -: 3781: * quote is a flag that '\<sep>' should not be treated as a separator.
        -: 3782: * in this case we need to be able to strip the backslash directly
        -: 3783: * in the string, so the calling function must have sent us something
        -: 3784: * modifiable.  currently this only works for sep == NULL.  also in
        -: 3785: * in this case only, we need to turn \\ into \.
        -: 3786: */
        -: 3787:
        -: 3788:/**/
        -: 3789:static int
        2: 3790:findsep(char **s, char *sep, int quote)
        -: 3791:{
        -: 3792:    /*
        -: 3793:     */
        -: 3794:    int i, ilen;
        -: 3795:    char *t, *tt;
        -: 3796:    convchar_t c;
        -: 3797:
        2: 3798:    MB_METACHARINIT();
        2: 3799:    if (!sep) {
    #####: 3800:	for (t = *s; *t; t += ilen) {
    #####: 3801:	    if (quote && *t == '\\') {
    #####: 3802:		if (t[1] == '\\') {
    #####: 3803:		    chuck(t);
    #####: 3804:		    ilen = 1;
    #####: 3805:		    continue;
        -: 3806:		} else {
    #####: 3807:		    ilen = MB_METACHARLENCONV(t+1, &c);
    #####: 3808:		    if (WC_ZISTYPE(c, ISEP)) {
    #####: 3809:			chuck(t);
        -: 3810:			/* then advance over new character, length ilen */
        -: 3811:		    } else {
        -: 3812:			/* treat *t (backslash) as normal byte */
    #####: 3813:			if (isep(*t))
    #####: 3814:			    break;
    #####: 3815:			ilen = 1;
        -: 3816:		    }
        -: 3817:		}
        -: 3818:	    } else {
    #####: 3819:		ilen = MB_METACHARLENCONV(t, &c);
    #####: 3820:		if (WC_ZISTYPE(c, ISEP))
    #####: 3821:		    break;
        -: 3822:	    }
        -: 3823:	}
    #####: 3824:	i = (t > *s);
    #####: 3825:	*s = t;
    #####: 3826:	return i;
        -: 3827:    }
        2: 3828:    if (!sep[0]) {
        -: 3829:	/*
        -: 3830:	 * NULL separator just means advance past first character,
        -: 3831:	 * if any.
        -: 3832:	 */
    #####: 3833:	if (**s) {
    #####: 3834:	    *s += MB_METACHARLEN(*s);
    #####: 3835:	    return 1;
        -: 3836:	}
    #####: 3837:	return -1;
        -: 3838:    }
       32: 3839:    for (i = 0; **s; i++) {
        -: 3840:	/*
        -: 3841:	 * The following works for multibyte characters by virtue of
        -: 3842:	 * the fact that sep may be a string (and we don't care how
        -: 3843:	 * it divides up, we need to match all of it).
        -: 3844:	 */
       30: 3845:	for (t = sep, tt = *s; *t && *tt && *t == *tt; t++, tt++);
       30: 3846:	if (!*t)
    #####: 3847:	    return (i > 0);
       30: 3848:	*s += MB_METACHARLEN(*s);
        -: 3849:    }
        2: 3850:    return -1;
        -: 3851:}
        -: 3852:
        -: 3853:/**/
        -: 3854:char *
    #####: 3855:findword(char **s, char *sep)
        -: 3856:{
        -: 3857:    char *r, *t;
        -: 3858:    int sl;
        -: 3859:
    #####: 3860:    if (!**s)
    #####: 3861:	return NULL;
        -: 3862:
    #####: 3863:    if (sep) {
    #####: 3864:	sl = strlen(sep);
    #####: 3865:	r = *s;
    #####: 3866:	while (! findsep(s, sep, 0)) {
    #####: 3867:	    r = *s += sl;
        -: 3868:	}
    #####: 3869:	return r;
        -: 3870:    }
    #####: 3871:    MB_METACHARINIT();
    #####: 3872:    for (t = *s; *t; t += sl) {
        -: 3873:	convchar_t c;
    #####: 3874:	sl = MB_METACHARLENCONV(t, &c);
    #####: 3875:	if (!WC_ZISTYPE(c, ISEP))
    #####: 3876:	    break;
        -: 3877:    }
    #####: 3878:    *s = t;
    #####: 3879:    (void)findsep(s, sep, 0);
    #####: 3880:    return t;
        -: 3881:}
        -: 3882:
        -: 3883:/**/
        -: 3884:int
        1: 3885:wordcount(char *s, char *sep, int mul)
        -: 3886:{
        -: 3887:    int r, sl, c;
        -: 3888:
        1: 3889:    if (sep) {
        1: 3890:	r = 1;
        1: 3891:	sl = strlen(sep);
        1: 3892:	for (; (c = findsep(&s, sep, 0)) >= 0; s += sl)
    #####: 3893:	    if ((c || mul) && (sl || *(s + sl)))
    #####: 3894:		r++;
        -: 3895:    } else {
    #####: 3896:	char *t = s;
        -: 3897:
    #####: 3898:	r = 0;
    #####: 3899:	if (mul <= 0)
    #####: 3900:	    skipwsep(&s);
    #####: 3901:	if ((*s && itype_end(s, ISEP, 1) != s) ||
    #####: 3902:	    (mul < 0 && t != s))
    #####: 3903:	    r++;
    #####: 3904:	for (; *s; r++) {
    #####: 3905:	    char *ie = itype_end(s, ISEP, 1);
    #####: 3906:	    if (ie != s) {
    #####: 3907:		s = ie;
    #####: 3908:		if (mul <= 0)
    #####: 3909:		    skipwsep(&s);
        -: 3910:	    }
    #####: 3911:	    (void)findsep(&s, NULL, 0);
    #####: 3912:	    t = s;
    #####: 3913:	    if (mul <= 0)
    #####: 3914:		skipwsep(&s);
        -: 3915:	}
    #####: 3916:	if (mul < 0 && t != s)
    #####: 3917:	    r++;
        -: 3918:    }
        1: 3919:    return r;
        -: 3920:}
        -: 3921:
        -: 3922:/*
        -: 3923: * 's' is a NULL-terminated array of strings.
        -: 3924: * 'sep' is a string, or NULL to split on ${IFS[1]}.
        -: 3925: *
        -: 3926: * Return a string consisting of the elements of 's' joined by 'sep',
        -: 3927: * allocated on the heap iff 'heap'.
        -: 3928: *
        -: 3929: * See also zjoin().
        -: 3930: */
        -: 3931:
        -: 3932:/**/
        -: 3933:mod_export char *
    #####: 3934:sepjoin(char **s, char *sep, int heap)
        -: 3935:{
        -: 3936:    char *r, *p, **t;
        -: 3937:    int l, sl;
        -: 3938:    char sepbuf[2];
        -: 3939:
    #####: 3940:    if (!*s)
    #####: 3941:	return heap ? dupstring("") : ztrdup("");
    #####: 3942:    if (!sep) {
        -: 3943:	/* optimise common case that ifs[0] is space */
    #####: 3944:	if (ifs && *ifs != ' ') {
    #####: 3945:	    MB_METACHARINIT();
    #####: 3946:	    sep = dupstrpfx(ifs, MB_METACHARLEN(ifs));
        -: 3947:	} else {
    #####: 3948:	    p = sep = sepbuf;
    #####: 3949:	    *p++ = ' ';
    #####: 3950:	    *p = '\0';
        -: 3951:	}
        -: 3952:    }
    #####: 3953:    sl = strlen(sep);
    #####: 3954:    for (t = s, l = 1 - sl; *t; l += strlen(*t) + sl, t++);
    #####: 3955:    r = p = (char *) (heap ? zhalloc(l) : zalloc(l));
    #####: 3956:    t = s;
    #####: 3957:    while (*t) {
    #####: 3958:	strucpy(&p, *t);
    #####: 3959:	if (*++t)
    #####: 3960:	    strucpy(&p, sep);
        -: 3961:    }
    #####: 3962:    *p = '\0';
    #####: 3963:    return r;
        -: 3964:}
        -: 3965:
        -: 3966:/**/
        -: 3967:char **
        1: 3968:sepsplit(char *s, char *sep, int allownull, int heap)
        -: 3969:{
        -: 3970:    int n, sl;
        -: 3971:    char *t, *tt, **r, **p;
        -: 3972:
        -: 3973:    /* Null string?  Treat as empty string. */
        1: 3974:    if (s[0] == Nularg && !s[1])
    #####: 3975:	s++;
        -: 3976:
        1: 3977:    if (!sep)
    #####: 3978:	return spacesplit(s, allownull, heap, 0);
        -: 3979:
        1: 3980:    sl = strlen(sep);
        1: 3981:    n = wordcount(s, sep, 1);
        1: 3982:    r = p = (char **) (heap ? zhalloc((n + 1) * sizeof(char *)) :
    #####: 3983:	                       zalloc((n + 1) * sizeof(char *)));
        -: 3984:
        3: 3985:    for (t = s; n--;) {
        1: 3986:	tt = t;
        1: 3987:	(void)findsep(&t, sep, 0);
        1: 3988:	*p = (char *) (heap ? zhalloc(t - tt + 1) :
    #####: 3989:	                       zalloc(t - tt + 1));
        1: 3990:	strncpy(*p, tt, t - tt);
        1: 3991:	(*p)[t - tt] = '\0';
        1: 3992:	p++;
        1: 3993:	t += sl;
        -: 3994:    }
        1: 3995:    *p = NULL;
        -: 3996:
        1: 3997:    return r;
        -: 3998:}
        -: 3999:
        -: 4000:/* Get the definition of a shell function */
        -: 4001:
        -: 4002:/**/
        -: 4003:mod_export Shfunc
       66: 4004:getshfunc(char *nam)
        -: 4005:{
       66: 4006:    return (Shfunc) shfunctab->getnode(shfunctab, nam);
        -: 4007:}
        -: 4008:
        -: 4009:/*
        -: 4010: * Call the function func to substitute string orig by setting
        -: 4011: * the parameter reply.
        -: 4012: * Return the array from reply, or NULL if the function returned
        -: 4013: * non-zero status.
        -: 4014: * The returned value comes directly from the parameter and
        -: 4015: * so should be used before there is any chance of that
        -: 4016: * being changed or unset.
        -: 4017: * If arg1 is not NULL, it is used as an initial argument to
        -: 4018: * the function, with the original string as the second argument.
        -: 4019: */
        -: 4020:
        -: 4021:/**/
        -: 4022:char **
    #####: 4023:subst_string_by_func(Shfunc func, char *arg1, char *orig)
        -: 4024:{
    #####: 4025:    int osc = sfcontext, osm = stopmsg, old_incompfunc = incompfunc;
    #####: 4026:    LinkList l = newlinklist();
        -: 4027:    char **ret;
        -: 4028:
    #####: 4029:    addlinknode(l, func->node.nam);
    #####: 4030:    if (arg1)
    #####: 4031:	addlinknode(l, arg1);
    #####: 4032:    addlinknode(l, orig);
    #####: 4033:    sfcontext = SFC_SUBST;
    #####: 4034:    incompfunc = 0;
        -: 4035:
    #####: 4036:    if (doshfunc(func, l, 1))
    #####: 4037:	ret = NULL;
        -: 4038:    else
    #####: 4039:	ret = getaparam("reply");
        -: 4040:
    #####: 4041:    sfcontext = osc;
    #####: 4042:    stopmsg = osm;
    #####: 4043:    incompfunc = old_incompfunc;
    #####: 4044:    return ret;
        -: 4045:}
        -: 4046:
        -: 4047:/**
        -: 4048: * Front end to subst_string_by_func to use hook-like logic.
        -: 4049: * name can refer to a function, and name + "_hook" can refer
        -: 4050: * to an array containing a list of functions.  The functions
        -: 4051: * are tried in order until one returns success.
        -: 4052: */
        -: 4053:/**/
        -: 4054:char **
    #####: 4055:subst_string_by_hook(char *name, char *arg1, char *orig)
        -: 4056:{
        -: 4057:    Shfunc func;
    #####: 4058:    char **ret = NULL;
        -: 4059:
    #####: 4060:    if ((func = getshfunc(name))) {
    #####: 4061:	ret = subst_string_by_func(func, arg1, orig);
        -: 4062:    }
        -: 4063:
    #####: 4064:    if (!ret) {
        -: 4065:	char **arrptr;
    #####: 4066:	int namlen = strlen(name);
    #####: 4067:	VARARR(char, arrnam, namlen + HOOK_SUFFIX_LEN);
    #####: 4068:	memcpy(arrnam, name, namlen);
    #####: 4069:	memcpy(arrnam + namlen, HOOK_SUFFIX, HOOK_SUFFIX_LEN);
        -: 4070:
    #####: 4071:	if ((arrptr = getaparam(arrnam))) {
        -: 4072:	    /* Guard against internal modification of the array */
    #####: 4073:	    arrptr = arrdup(arrptr);
    #####: 4074:	    for (; *arrptr; arrptr++) {
    #####: 4075:		if ((func = getshfunc(*arrptr))) {
    #####: 4076:		    ret = subst_string_by_func(func, arg1, orig);
    #####: 4077:		    if (ret)
    #####: 4078:			break;
        -: 4079:		}
        -: 4080:	    }
        -: 4081:	}
        -: 4082:    }
        -: 4083:
    #####: 4084:    return ret;
        -: 4085:}
        -: 4086:
        -: 4087:/**/
        -: 4088:mod_export char **
       14: 4089:mkarray(char *s)
        -: 4090:{
       14: 4091:    char **t = (char **) zalloc((s) ? (2 * sizeof s) : (sizeof s));
        -: 4092:
       14: 4093:    if ((*t = s))
        2: 4094:	t[1] = NULL;
       14: 4095:    return t;
        -: 4096:}
        -: 4097:
        -: 4098:/**/
        -: 4099:mod_export char **
    #####: 4100:hmkarray(char *s)
        -: 4101:{
    #####: 4102:    char **t = (char **) zhalloc((s) ? (2 * sizeof s) : (sizeof s));
        -: 4103:
    #####: 4104:    if ((*t = s))
    #####: 4105:	t[1] = NULL;
    #####: 4106:    return t;
        -: 4107:}
        -: 4108:
        -: 4109:/**/
        -: 4110:mod_export void
    #####: 4111:zbeep(void)
        -: 4112:{
        -: 4113:    char *vb;
    #####: 4114:    queue_signals();
    #####: 4115:    if ((vb = getsparam_u("ZBEEP"))) {
        -: 4116:	int len;
    #####: 4117:	vb = getkeystring(vb, &len, GETKEYS_BINDKEY, NULL);
    #####: 4118:	write_loop(SHTTY, vb, len);
    #####: 4119:    } else if (isset(BEEP))
    #####: 4120:	write_loop(SHTTY, "\07", 1);
    #####: 4121:    unqueue_signals();
    #####: 4122:}
        -: 4123:
        -: 4124:/**/
        -: 4125:mod_export void
      102: 4126:freearray(char **s)
        -: 4127:{
      102: 4128:    char **t = s;
        -: 4129:
        -: 4130:    DPUTS(!s, "freearray() with zero argument");
        -: 4131:
     1097: 4132:    while (*s)
      893: 4133:	zsfree(*s++);
      102: 4134:    free(t);
      102: 4135:}
        -: 4136:
        -: 4137:/**/
        -: 4138:int
    #####: 4139:equalsplit(char *s, char **t)
        -: 4140:{
    #####: 4141:    for (; *s && *s != '='; s++);
    #####: 4142:    if (*s == '=') {
    #####: 4143:	*s++ = '\0';
    #####: 4144:	*t = s;
    #####: 4145:	return 1;
        -: 4146:    }
    #####: 4147:    return 0;
        -: 4148:}
        -: 4149:
        -: 4150:
        -: 4151:/* the ztypes table */
        -: 4152:
        -: 4153:/**/
        -: 4154:mod_export short int typtab[256];
        -: 4155:static int typtab_flags = 0;
        -: 4156:
        -: 4157:/* initialize the ztypes table */
        -: 4158:
        -: 4159:/**/
        -: 4160:void
       90: 4161:inittyptab(void)
        -: 4162:{
        -: 4163:    int t0;
        -: 4164:    char *s;
        -: 4165:
       90: 4166:    if (!(typtab_flags & ZTF_INIT)) {
        2: 4167:	typtab_flags = ZTF_INIT;
        2: 4168:	if (interact && isset(SHINSTDIN))
    #####: 4169:	    typtab_flags |= ZTF_INTERACT;
        -: 4170:    }
        -: 4171:
       90: 4172:    queue_signals();
        -: 4173:
       90: 4174:    memset(typtab, 0, sizeof(typtab));
     2970: 4175:    for (t0 = 0; t0 != 32; t0++)
     2880: 4176:	typtab[t0] = typtab[t0 + 128] = ICNTRL;
       90: 4177:    typtab[127] = ICNTRL;
      990: 4178:    for (t0 = '0'; t0 <= '9'; t0++)
      900: 4179:	typtab[t0] = IDIGIT | IALNUM | IWORD | IIDENT | IUSER;
     2430: 4180:    for (t0 = 'a'; t0 <= 'z'; t0++)
     2340: 4181:	typtab[t0] = typtab[t0 - 'a' + 'A'] = IALPHA | IALNUM | IIDENT | IUSER | IWORD;
        -: 4182:#ifndef MULTIBYTE_SUPPORT
        -: 4183:    /*
        -: 4184:     * This really doesn't seem to me the right thing to do when
        -: 4185:     * we have multibyte character support...  it was a hack to assume
        -: 4186:     * eight bit characters `worked' for some values of work before
        -: 4187:     * we could test for them properly.  I'm not 100% convinced
        -: 4188:     * having IIDENT here is a good idea at all, but this code
        -: 4189:     * should disappear into history...
        -: 4190:     */
        -: 4191:    for (t0 = 0240; t0 != 0400; t0++)
        -: 4192:	typtab[t0] = IALPHA | IALNUM | IIDENT | IUSER | IWORD;
        -: 4193:#endif
        -: 4194:    /* typtab['.'] |= IIDENT; */ /* Allow '.' in variable names - broken */
       90: 4195:    typtab['_'] = IIDENT | IUSER;
       90: 4196:    typtab['-'] = typtab['.'] = typtab[STOUC(Dash)] = IUSER;
       90: 4197:    typtab[' '] |= IBLANK | INBLANK;
       90: 4198:    typtab['\t'] |= IBLANK | INBLANK;
       90: 4199:    typtab['\n'] |= INBLANK;
       90: 4200:    typtab['\0'] |= IMETA;
       90: 4201:    typtab[STOUC(Meta)  ] |= IMETA;
       90: 4202:    typtab[STOUC(Marker)] |= IMETA;
     2340: 4203:    for (t0 = (int)STOUC(Pound); t0 <= (int)STOUC(LAST_NORMAL_TOK); t0++)
     2250: 4204:	typtab[t0] |= ITOK | IMETA;
      540: 4205:    for (t0 = (int)STOUC(Snull); t0 <= (int)STOUC(Nularg); t0++)
      450: 4206:	typtab[t0] |= ITOK | IMETA | INULL;
      400: 4207:    for (s = ifs ? ifs : EMULATION(EMULATE_KSH|EMULATE_SH) ?
      220: 4208:	DEFAULT_IFS_SH : DEFAULT_IFS; *s; s++) {
      220: 4209:	int c = STOUC(*s == Meta ? *++s ^ 32 : *s);
        -: 4210:#ifdef MULTIBYTE_SUPPORT
      220: 4211:	if (!isascii(c)) {
        -: 4212:	    /* see comment for wordchars below */
    #####: 4213:	    continue;
        -: 4214:	}
        -: 4215:#endif
      220: 4216:	if (inblank(c)) {
      165: 4217:	    if (s[1] == c)
    #####: 4218:		s++;
        -: 4219:	    else
      165: 4220:		typtab[c] |= IWSEP;
        -: 4221:	}
      220: 4222:	typtab[c] |= ISEP;
        -: 4223:    }
     2160: 4224:    for (s = wordchars ? wordchars : DEFAULT_WORDCHARS; *s; s++) {
     2070: 4225:	int c = STOUC(*s == Meta ? *++s ^ 32 : *s);
        -: 4226:#ifdef MULTIBYTE_SUPPORT
     2070: 4227:	if (!isascii(c)) {
        -: 4228:	    /*
        -: 4229:	     * If we have support for multibyte characters, we don't
        -: 4230:	     * handle non-ASCII characters here; instead, we turn
        -: 4231:	     * wordchars into a wide character array.
        -: 4232:	     * (We may actually have a single-byte 8-bit character set,
        -: 4233:	     * but it works the same way.)
        -: 4234:	     */
    #####: 4235:	    continue;
        -: 4236:	}
        -: 4237:#endif
     2070: 4238:	typtab[c] |= IWORD;
        -: 4239:    }
        -: 4240:#ifdef MULTIBYTE_SUPPORT
       90: 4241:    set_widearray(wordchars, &wordchars_wide);
       90: 4242:    set_widearray(ifs ? ifs : EMULATION(EMULATE_KSH|EMULATE_SH) ?
    #####: 4243:	DEFAULT_IFS_SH : DEFAULT_IFS, &ifs_wide);
        -: 4244:#endif
     2340: 4245:    for (s = SPECCHARS; *s; s++)
     2250: 4246:	typtab[STOUC(*s)] |= ISPECIAL;
       90: 4247:    if (typtab_flags & ZTF_SP_COMMA)
    #####: 4248:	typtab[STOUC(',')] |= ISPECIAL;
       90: 4249:    if (isset(BANGHIST) && bangchar && (typtab_flags & ZTF_INTERACT)) {
    #####: 4250:	typtab_flags |= ZTF_BANGCHAR;
    #####: 4251:	typtab[bangchar] |= ISPECIAL;
        -: 4252:    } else
       90: 4253:	typtab_flags &= ~ZTF_BANGCHAR;
     1260: 4254:    for (s = PATCHARS; *s; s++)
     1170: 4255:	typtab[STOUC(*s)] |= IPATTERN;
        -: 4256:
       90: 4257:    unqueue_signals();
       90: 4258:}
        -: 4259:
        -: 4260:/**/
        -: 4261:mod_export void
    #####: 4262:makecommaspecial(int yesno)
        -: 4263:{
    #####: 4264:    if (yesno != 0) {
    #####: 4265:	typtab_flags |= ZTF_SP_COMMA;
    #####: 4266:	typtab[STOUC(',')] |= ISPECIAL;
        -: 4267:    } else {
    #####: 4268:	typtab_flags &= ~ZTF_SP_COMMA;
    #####: 4269:	typtab[STOUC(',')] &= ~ISPECIAL;
        -: 4270:    }
    #####: 4271:}
        -: 4272:
        -: 4273:/**/
        -: 4274:mod_export void
    #####: 4275:makebangspecial(int yesno)
        -: 4276:{
        -: 4277:    /* Name and call signature for congruence with makecommaspecial(),
        -: 4278:     * but in this case when yesno is nonzero we defer to the state
        -: 4279:     * saved by inittyptab().
        -: 4280:     */ 
    #####: 4281:    if (yesno == 0) {
    #####: 4282:	typtab[bangchar] &= ~ISPECIAL;
    #####: 4283:    } else if (typtab_flags & ZTF_BANGCHAR) {
    #####: 4284:	typtab[bangchar] |= ISPECIAL;
        -: 4285:    }
    #####: 4286:}
        -: 4287:
        -: 4288:
        -: 4289:/**/
        -: 4290:#ifdef MULTIBYTE_SUPPORT
        -: 4291:/* A wide-character version of the iblank() macro. */
        -: 4292:/**/
        -: 4293:mod_export int
    #####: 4294:wcsiblank(wint_t wc)
        -: 4295:{
    #####: 4296:    if (iswspace(wc) && wc != L'\n')
    #####: 4297:	return 1;
    #####: 4298:    return 0;
        -: 4299:}
        -: 4300:
        -: 4301:/*
        -: 4302: * zistype macro extended to support wide characters.
        -: 4303: * Works for IIDENT, IWORD, IALNUM, ISEP.
        -: 4304: * We don't need this for IWSEP because that only applies to
        -: 4305: * a fixed set of ASCII characters.
        -: 4306: * Note here that use of multibyte mode is not tested:
        -: 4307: * that's because for ZLE this is unconditional,
        -: 4308: * not dependent on the option.  The caller must decide.
        -: 4309: */
        -: 4310:
        -: 4311:/**/
        -: 4312:mod_export int
       30: 4313:wcsitype(wchar_t c, int itype)
        -: 4314:{
        -: 4315:    int len;
        -: 4316:    mbstate_t mbs;
       30: 4317:    VARARR(char, outstr, MB_CUR_MAX);
        -: 4318:
       30: 4319:    if (!isset(MULTIBYTE))
    #####: 4320:	return zistype(c, itype);
        -: 4321:
        -: 4322:    /*
        -: 4323:     * Strategy:  the shell requires that the multibyte representation
        -: 4324:     * be an extension of ASCII.  So see if converting the character
        -: 4325:     * produces an ASCII character.  If it does, use zistype on that.
        -: 4326:     * If it doesn't, use iswalnum on the original character.
        -: 4327:     * If that fails, resort to the appropriate wide character array.
        -: 4328:     */
       30: 4329:    memset(&mbs, 0, sizeof(mbs));
       30: 4330:    len = wcrtomb(outstr, c, &mbs);
        -: 4331:
       30: 4332:    if (len == 0) {
        -: 4333:	/* NULL is special */
    #####: 4334:	return zistype(0, itype);
       30: 4335:    } else if (len == 1 && isascii(outstr[0])) {
       30: 4336:	return zistype(outstr[0], itype);
        -: 4337:    } else {
    #####: 4338:	switch (itype) {
    #####: 4339:	case IIDENT:
    #####: 4340:	    if (isset(POSIXIDENTIFIERS))
    #####: 4341:		return 0;
    #####: 4342:	    return iswalnum(c);
        -: 4343:
    #####: 4344:	case IWORD:
    #####: 4345:	    if (iswalnum(c))
    #####: 4346:		return 1;
        -: 4347:	    /*
        -: 4348:	     * If we are handling combining characters, any punctuation
        -: 4349:	     * characters with zero width needs to be considered part of
        -: 4350:	     * a word.  If we are not handling combining characters then
        -: 4351:	     * logically they are still part of the word, even if they
        -: 4352:	     * don't get displayed properly, so always do this.
        -: 4353:	     */
    #####: 4354:	    if (IS_COMBINING(c))
    #####: 4355:		return 1;
    #####: 4356:	    return !!wmemchr(wordchars_wide.chars, c, wordchars_wide.len);
        -: 4357:
    #####: 4358:	case ISEP:
    #####: 4359:	    return !!wmemchr(ifs_wide.chars, c, ifs_wide.len);
        -: 4360:
    #####: 4361:	default:
    #####: 4362:	    return iswalnum(c);
        -: 4363:	}
        -: 4364:    }
        -: 4365:}
        -: 4366:
        -: 4367:/**/
        -: 4368:#endif
        -: 4369:
        -: 4370:
        -: 4371:/*
        -: 4372: * Find the end of a set of characters in the set specified by itype;
        -: 4373: * one of IALNUM, IIDENT, IWORD or IUSER.  For non-ASCII characters, we assume
        -: 4374: * alphanumerics are part of the set, with the exception that
        -: 4375: * identifiers are not treated that way if POSIXIDENTIFIERS is set.
        -: 4376: *
        -: 4377: * See notes above for identifiers.
        -: 4378: * Returns the same pointer as passed if not on an identifier character.
        -: 4379: * If "once" is set, just test the first character, i.e. (outptr !=
        -: 4380: * inptr) tests whether the first character is valid in an identifier.
        -: 4381: *
        -: 4382: * Currently this is only called with itype IIDENT, IUSER or ISEP.
        -: 4383: */
        -: 4384:
        -: 4385:/**/
        -: 4386:mod_export char *
     2267: 4387:itype_end(const char *ptr, int itype, int once)
        -: 4388:{
        -: 4389:#ifdef MULTIBYTE_SUPPORT
     4534: 4390:    if (isset(MULTIBYTE) &&
     2267: 4391:	(itype != IIDENT || !isset(POSIXIDENTIFIERS))) {
     2267: 4392:	mb_charinit();
     2267: 4393:	while (*ptr) {
        -: 4394:	    int len;
    15323: 4395:	    if (itok(*ptr)) {
        -: 4396:		/* Not untokenised yet --- can happen in raw command line */
      232: 4397:		len = 1;
      232: 4398:		if (!zistype(*ptr,itype))
      232: 4399:		    break;
        -: 4400:	    } else {
        -: 4401:		wint_t wc;
    15091: 4402:		len = mb_metacharlenconv(ptr, &wc);
        -: 4403:
    15091: 4404:		if (!len)
       99: 4405:		    break;
        -: 4406:
    15091: 4407:		if (wc == WEOF) {
        -: 4408:		    /* invalid, treat as single character */
    #####: 4409:		    int chr = STOUC(*ptr == Meta ? ptr[1] ^ 32 : *ptr);
        -: 4410:		    /* in this case non-ASCII characters can't match */
    #####: 4411:		    if (chr > 127 || !zistype(chr,itype))
        -: 4412:			break;
    15091: 4413:		} else if (len == 1 && isascii(*ptr)) {
        -: 4414:		    /* ASCII: can't be metafied, use standard test */
    30083: 4415:		    if (!zistype(*ptr,itype))
       99: 4416:			break;
        -: 4417:		} else {
        -: 4418:		    /*
        -: 4419:		     * Valid non-ASCII character.
        -: 4420:		     */
    #####: 4421:		    switch (itype) {
    #####: 4422:		    case IWORD:
    #####: 4423:			if (!iswalnum(wc) &&
    #####: 4424:			    !wmemchr(wordchars_wide.chars, wc,
        -: 4425:				     wordchars_wide.len))
    #####: 4426:			    return (char *)ptr;
    #####: 4427:			break;
        -: 4428:
    #####: 4429:		    case ISEP:
    #####: 4430:			if (!wmemchr(ifs_wide.chars, wc, ifs_wide.len))
    #####: 4431:			    return (char *)ptr;
    #####: 4432:			break;
        -: 4433:
    #####: 4434:		    default:
    #####: 4435:			if (!iswalnum(wc))
    #####: 4436:			    return (char *)ptr;
        -: 4437:		    }
        -: 4438:		}
        -: 4439:	    }
    14992: 4440:	    ptr += len;
        -: 4441:
    14992: 4442:	    if (once)
      437: 4443:		break;
        -: 4444:	}
        -: 4445:    } else
        -: 4446:#endif
    #####: 4447:	for (;;) {
    #####: 4448:	    int chr = STOUC(*ptr == Meta ? ptr[1] ^ 32 : *ptr);
    #####: 4449:	    if (!zistype(chr,itype))
    #####: 4450:		break;
    #####: 4451:	    ptr += (*ptr == Meta) ? 2 : 1;
        -: 4452:
    #####: 4453:	    if (once)
    #####: 4454:		break;
        -: 4455:	}
        -: 4456:
        -: 4457:    /*
        -: 4458:     * Nasty.  The first argument is const char * because we
        -: 4459:     * don't modify it here.  However, we really want to pass
        -: 4460:     * back the same type as was passed down, to allow idioms like
        -: 4461:     *   p = itype_end(p, IIDENT, 0);
        -: 4462:     * So returning a const char * isn't really the right thing to do.
        -: 4463:     * Without having two different functions the following seems
        -: 4464:     * to be the best we can do.
        -: 4465:     */
     2267: 4466:    return (char *)ptr;
        -: 4467:}
        -: 4468:
        -: 4469:/**/
        -: 4470:mod_export char **
    #####: 4471:arrdup(char **s)
        -: 4472:{
        -: 4473:    char **x, **y;
        -: 4474:
    #####: 4475:    y = x = (char **) zhalloc(sizeof(char *) * (arrlen(s) + 1));
        -: 4476:
    #####: 4477:    while ((*x++ = dupstring(*s++)));
        -: 4478:
    #####: 4479:    return y;
        -: 4480:}
        -: 4481:
        -: 4482:/* Duplicate at most max elements of the array s with heap memory */
        -: 4483:
        -: 4484:/**/
        -: 4485:mod_export char **
        4: 4486:arrdup_max(char **s, unsigned max)
        -: 4487:{
        -: 4488:    char **x, **y, **send;
        4: 4489:    int len = 0;
        -: 4490:
        4: 4491:    if (max)
        4: 4492:	len = arrlen(s);
        -: 4493:
        -: 4494:    /* Limit has sense only if not equal to len */
        4: 4495:    if (max > len)
        4: 4496:        max = len;
        -: 4497:
        4: 4498:    y = x = (char **) zhalloc(sizeof(char *) * (max + 1));
        -: 4499:
        4: 4500:    send = s + max;
     1584: 4501:    while (s < send)
     1576: 4502:	*x++ = dupstring(*s++);
        4: 4503:    *x = NULL;
        -: 4504:
        4: 4505:    return y;
        -: 4506:}
        -: 4507:
        -: 4508:/**/
        -: 4509:mod_export char **
        3: 4510:zarrdup(char **s)
        -: 4511:{
        -: 4512:    char **x, **y;
        -: 4513:
        3: 4514:    y = x = (char **) zalloc(sizeof(char *) * (arrlen(s) + 1));
        -: 4515:
        3: 4516:    while ((*x++ = ztrdup(*s++)));
        -: 4517:
        3: 4518:    return y;
        -: 4519:}
        -: 4520:
        -: 4521:/**/
        -: 4522:#ifdef MULTIBYTE_SUPPORT
        -: 4523:/**/
        -: 4524:mod_export wchar_t **
    #####: 4525:wcs_zarrdup(wchar_t **s)
        -: 4526:{
        -: 4527:    wchar_t **x, **y;
        -: 4528:
    #####: 4529:    y = x = (wchar_t **) zalloc(sizeof(wchar_t *) * (arrlen((char **)s) + 1));
        -: 4530:
    #####: 4531:    while ((*x++ = wcs_ztrdup(*s++)));
        -: 4532:
    #####: 4533:    return y;
        -: 4534:}
        -: 4535:/**/
        -: 4536:#endif /* MULTIBYTE_SUPPORT */
        -: 4537:
        -: 4538:/**/
        -: 4539:static char *
    #####: 4540:spname(char *oldname)
        -: 4541:{
        -: 4542:    char *p, spnameguess[PATH_MAX + 1], spnamebest[PATH_MAX + 1];
        -: 4543:    static char newname[PATH_MAX + 1];
    #####: 4544:    char *new = newname, *old = oldname;
    #####: 4545:    int bestdist = 0, thisdist, thresh, maxthresh = 0;
        -: 4546:
        -: 4547:    /* This loop corrects each directory component of the path, stopping *
        -: 4548:     * when any correction distance would exceed the distance threshold. *
        -: 4549:     * NULL is returned only if the first component cannot be corrected; *
        -: 4550:     * otherwise a copy of oldname with a corrected prefix is returned.  *
        -: 4551:     * Rationale for this, if there ever was any, has been forgotten.    */
        -: 4552:    for (;;) {
    #####: 4553:	while (*old == '/') {
    #####: 4554:            if (new >= newname + sizeof(newname) - 1)
    #####: 4555:		return NULL;
    #####: 4556:	    *new++ = *old++;
        -: 4557:	}
    #####: 4558:	*new = '\0';
    #####: 4559:	if (*old == '\0')
    #####: 4560:	    return newname;
    #####: 4561:	p = spnameguess;
    #####: 4562:	for (; *old != '/' && *old != '\0'; old++)
    #####: 4563:	    if (p < spnameguess + PATH_MAX)
    #####: 4564:		*p++ = *old;
    #####: 4565:	*p = '\0';
        -: 4566:	/* Every component is allowed a single distance 2 correction or two *
        -: 4567:	 * distance 1 corrections.  Longer ones get additional corrections. */
    #####: 4568:	thresh = (int)(p - spnameguess) / 4 + 1;
    #####: 4569:	if (thresh < 3)
    #####: 4570:	    thresh = 3;
    #####: 4571:	else if (thresh > 100)
    #####: 4572:	    thresh = 100;
    #####: 4573:	thisdist = mindist(newname, spnameguess, spnamebest, *old == '/');
    #####: 4574:	if (thisdist >= thresh) {
        -: 4575:	    /* The next test is always true, except for the first path    *
        -: 4576:	     * component.  We could initialize bestdist to some large     *
        -: 4577:	     * constant instead, and then compare to that constant here,  *
        -: 4578:	     * because an invariant is that we've never exceeded the      *
        -: 4579:	     * threshold for any component so far; but I think that looks *
        -: 4580:	     * odd to the human reader, and we may make use of the total  *
        -: 4581:	     * distance for all corrections at some point in the future.  */
    #####: 4582:	    if (bestdist < maxthresh) {
    #####: 4583:		struncpy(&new, spnameguess, sizeof(newname) - (new - newname));
    #####: 4584:		struncpy(&new, old, sizeof(newname) - (new - newname));
    #####: 4585:		return (new >= newname + sizeof(newname) -1) ? NULL : newname;
        -: 4586:	    } else
    #####: 4587:	    	return NULL;
        -: 4588:	} else {
    #####: 4589:	    maxthresh = bestdist + thresh;
    #####: 4590:	    bestdist += thisdist;
        -: 4591:	}
    #####: 4592:	for (p = spnamebest; (*new = *p++);) {
    #####: 4593:	    if (new >= newname + sizeof(newname) - 1)
    #####: 4594:		return NULL;
    #####: 4595:	    new++;
        -: 4596:	}
        -: 4597:    }
        -: 4598:}
        -: 4599:
        -: 4600:/**/
        -: 4601:static int
    #####: 4602:mindist(char *dir, char *mindistguess, char *mindistbest, int wantdir)
        -: 4603:{
        -: 4604:    int mindistd, nd;
        -: 4605:    DIR *dd;
        -: 4606:    char *fn;
        -: 4607:    char *buf;
        -: 4608:    struct stat st;
        -: 4609:    size_t dirlen;
        -: 4610:
    #####: 4611:    if (dir[0] == '\0')
    #####: 4612:	dir = ".";
    #####: 4613:    mindistd = 100;
        -: 4614:
    #####: 4615:    if (!(buf = zalloc((dirlen = strlen(dir)) + strlen(mindistguess) + 2)))
    #####: 4616:	return 0;
    #####: 4617:    sprintf(buf, "%s/%s", dir, mindistguess);
        -: 4618:
    #####: 4619:    if (stat(unmeta(buf), &st) == 0 && (!wantdir || S_ISDIR(st.st_mode))) {
    #####: 4620:	strcpy(mindistbest, mindistguess);
    #####: 4621:	free(buf);
    #####: 4622:	return 0;
        -: 4623:    }
        -: 4624:
    #####: 4625:    if ((dd = opendir(unmeta(dir)))) {
    #####: 4626:	while ((fn = zreaddir(dd, 0))) {
    #####: 4627:	    if (spnamepat && pattry(spnamepat, fn))
    #####: 4628:		continue;
    #####: 4629:	    nd = spdist(fn, mindistguess,
    #####: 4630:			(int)strlen(mindistguess) / 4 + 1);
    #####: 4631:	    if (nd <= mindistd) {
    #####: 4632:		if (wantdir) {
    #####: 4633:		    if (!(buf = zrealloc(buf, dirlen + strlen(fn) + 2)))
    #####: 4634:			continue;
    #####: 4635:		    sprintf(buf, "%s/%s", dir, fn);
    #####: 4636:		    if (stat(unmeta(buf), &st) != 0 || !S_ISDIR(st.st_mode))
    #####: 4637:			continue;
        -: 4638:		}
    #####: 4639:		strcpy(mindistbest, fn);
    #####: 4640:		mindistd = nd;
    #####: 4641:		if (mindistd == 0)
    #####: 4642:		    break;
        -: 4643:	    }
        -: 4644:	}
    #####: 4645:	closedir(dd);
        -: 4646:    }
    #####: 4647:    free(buf);
    #####: 4648:    return mindistd;
        -: 4649:}
        -: 4650:
        -: 4651:/**/
        -: 4652:static int
    #####: 4653:spdist(char *s, char *t, int thresh)
        -: 4654:{
        -: 4655:    /* TODO: Correction for non-ASCII and multibyte-input keyboards. */
        -: 4656:    char *p, *q;
    #####: 4657:    const char qwertykeymap[] =
        -: 4658:    "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\
        -: 4659:\t1234567890-=\t\
        -: 4660:\tqwertyuiop[]\t\
        -: 4661:\tasdfghjkl;'\n\t\
        -: 4662:\tzxcvbnm,./\t\t\t\
        -: 4663:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\
        -: 4664:\t!@#$%^&*()_+\t\
        -: 4665:\tQWERTYUIOP{}\t\
        -: 4666:\tASDFGHJKL:\"\n\t\
        -: 4667:\tZXCVBNM<>?\n\n\t\
        -: 4668:\n\n\n\n\n\n\n\n\n\n\n\n\n\n";
    #####: 4669:    const char dvorakkeymap[] =
        -: 4670:    "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\
        -: 4671:\t1234567890[]\t\
        -: 4672:\t',.pyfgcrl/=\t\
        -: 4673:\taoeuidhtns-\n\t\
        -: 4674:\t;qjkxbmwvz\t\t\t\
        -: 4675:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\
        -: 4676:\t!@#$%^&*(){}\t\
        -: 4677:\t\"<>PYFGCRL?+\t\
        -: 4678:\tAOEUIDHTNS_\n\t\
        -: 4679:\t:QJKXBMWVZ\n\n\t\
        -: 4680:\n\n\n\n\n\n\n\n\n\n\n\n\n\n";
        -: 4681:    const char *keymap;
    #####: 4682:    if ( isset( DVORAK ) )
    #####: 4683:      keymap = dvorakkeymap;
        -: 4684:    else
    #####: 4685:      keymap = qwertykeymap;
        -: 4686:
    #####: 4687:    if (!strcmp(s, t))
    #####: 4688:	return 0;
        -: 4689:    /* any number of upper/lower mistakes allowed (dist = 1) */
    #####: 4690:    for (p = s, q = t; *p && tulower(*p) == tulower(*q); p++, q++);
    #####: 4691:    if (!*p && !*q)
    #####: 4692:	return 1;
    #####: 4693:    if (!thresh)
    #####: 4694:	return 200;
    #####: 4695:    for (p = s, q = t; *p && *q; p++, q++)
    #####: 4696:	if (*p == *q)
    #####: 4697:	    continue;		/* don't consider "aa" transposed, ash */
    #####: 4698:	else if (p[1] == q[0] && q[1] == p[0])	/* transpositions */
    #####: 4699:	    return spdist(p + 2, q + 2, thresh - 1) + 1;
    #####: 4700:	else if (p[1] == q[0])	/* missing letter */
    #####: 4701:	    return spdist(p + 1, q + 0, thresh - 1) + 2;
    #####: 4702:	else if (p[0] == q[1])	/* missing letter */
    #####: 4703:	    return spdist(p + 0, q + 1, thresh - 1) + 2;
    #####: 4704:	else if (*p != *q)
    #####: 4705:	    break;
    #####: 4706:    if ((!*p && strlen(q) == 1) || (!*q && strlen(p) == 1))
    #####: 4707:	return 2;
    #####: 4708:    for (p = s, q = t; *p && *q; p++, q++)
    #####: 4709:	if (p[0] != q[0] && p[1] == q[1]) {
        -: 4710:	    int t0;
        -: 4711:	    char *z;
        -: 4712:
        -: 4713:	    /* mistyped letter */
        -: 4714:
    #####: 4715:	    if (!(z = strchr(keymap, p[0])) || *z == '\n' || *z == '\t')
    #####: 4716:		return spdist(p + 1, q + 1, thresh - 1) + 1;
    #####: 4717:	    t0 = z - keymap;
    #####: 4718:	    if (*q == keymap[t0 - 15] || *q == keymap[t0 - 14] ||
    #####: 4719:		*q == keymap[t0 - 13] ||
    #####: 4720:		*q == keymap[t0 - 1] || *q == keymap[t0 + 1] ||
    #####: 4721:		*q == keymap[t0 + 13] || *q == keymap[t0 + 14] ||
    #####: 4722:		*q == keymap[t0 + 15])
    #####: 4723:		return spdist(p + 1, q + 1, thresh - 1) + 2;
    #####: 4724:	    return 200;
    #####: 4725:	} else if (*p != *q)
    #####: 4726:	    break;
    #####: 4727:    return 200;
        -: 4728:}
        -: 4729:
        -: 4730:/* set cbreak mode, or the equivalent */
        -: 4731:
        -: 4732:/**/
        -: 4733:void
    #####: 4734:setcbreak(void)
        -: 4735:{
        -: 4736:    struct ttyinfo ti;
        -: 4737:
    #####: 4738:    ti = shttyinfo;
        -: 4739:#ifdef HAS_TIO
    #####: 4740:    ti.tio.c_lflag &= ~ICANON;
    #####: 4741:    ti.tio.c_cc[VMIN] = 1;
    #####: 4742:    ti.tio.c_cc[VTIME] = 0;
        -: 4743:#else
        -: 4744:    ti.sgttyb.sg_flags |= CBREAK;
        -: 4745:#endif
    #####: 4746:    settyinfo(&ti);
    #####: 4747:}
        -: 4748:
        -: 4749:/* give the tty to some process */
        -: 4750:
        -: 4751:/**/
        -: 4752:mod_export void
    #####: 4753:attachtty(pid_t pgrp)
        -: 4754:{
        -: 4755:    static int ep = 0;
        -: 4756:
    #####: 4757:    if (jobbing && interact) {
        -: 4758:#ifdef HAVE_TCSETPGRP
    #####: 4759:	if (SHTTY != -1 && tcsetpgrp(SHTTY, pgrp) == -1 && !ep)
        -: 4760:#else
        -: 4761:# if ardent
        -: 4762:	if (SHTTY != -1 && setpgrp() == -1 && !ep)
        -: 4763:# else
        -: 4764:	int arg = pgrp;
        -: 4765:
        -: 4766:	if (SHTTY != -1 && ioctl(SHTTY, TIOCSPGRP, &arg) == -1 && !ep)
        -: 4767:# endif
        -: 4768:#endif
        -: 4769:	{
    #####: 4770:	    if (pgrp != mypgrp && kill(-pgrp, 0) == -1)
    #####: 4771:		attachtty(mypgrp);
        -: 4772:	    else {
    #####: 4773:		if (errno != ENOTTY)
        -: 4774:		{
    #####: 4775:		    zwarn("can't set tty pgrp: %e", errno);
    #####: 4776:		    fflush(stderr);
        -: 4777:		}
    #####: 4778:		opts[MONITOR] = 0;
    #####: 4779:		ep = 1;
        -: 4780:	    }
        -: 4781:	}
        -: 4782:	else
        -: 4783:	{
    #####: 4784:	    last_attached_pgrp = pgrp;
        -: 4785:	}
        -: 4786:    }
    #####: 4787:}
        -: 4788:
        -: 4789:/* get the process group associated with the tty */
        -: 4790:
        -: 4791:/**/
        -: 4792:pid_t
    #####: 4793:gettygrp(void)
        -: 4794:{
        -: 4795:    pid_t arg;
        -: 4796:
    #####: 4797:    if (SHTTY == -1)
    #####: 4798:	return -1;
        -: 4799:
        -: 4800:#ifdef HAVE_TCSETPGRP
    #####: 4801:    arg = tcgetpgrp(SHTTY);
        -: 4802:#else
        -: 4803:    ioctl(SHTTY, TIOCGPGRP, &arg);
        -: 4804:#endif
        -: 4805:
    #####: 4806:    return arg;
        -: 4807:}
        -: 4808:
        -: 4809:
        -: 4810:/* Escape tokens and null characters.  Buf is the string which should be     *
        -: 4811: * escaped.  len is the length of the string.  If len is -1, buf should be   *
        -: 4812: * null terminated.  If len is non-negative and the third parameter is not   *
        -: 4813: * META_DUP, buf should point to an at least len+1 long memory area.  The    *
        -: 4814: * return value points to the quoted string.  If the given string does not   *
        -: 4815: * contain any special character which should be quoted and the third        *
        -: 4816: * parameter is not META_(HEAP|)DUP, buf is returned unchanged (a            *
        -: 4817: * terminating null character is appended to buf if necessary).  Otherwise   *
        -: 4818: * the third `heap' argument determines the method used to allocate space    *
        -: 4819: * for the result.  It can have the following values:                        *
        -: 4820: *   META_REALLOC:  use zrealloc on buf                                      *
        -: 4821: *   META_HREALLOC: use hrealloc on buf                                      *
        -: 4822: *   META_USEHEAP:  get memory from the heap.  This leaves buf unchanged.    *
        -: 4823: *   META_NOALLOC:  buf points to a memory area which is long enough to hold *
        -: 4824: *                  the quoted form, just quote it and return buf.           *
        -: 4825: *   META_STATIC:   store the quoted string in a static area.  The original  *
        -: 4826: *                  string should be at most PATH_MAX long.                  *
        -: 4827: *   META_ALLOC:    allocate memory for the new string with zalloc().        *
        -: 4828: *   META_DUP:      leave buf unchanged and allocate space for the return    *
        -: 4829: *                  value even if buf does not contains special characters   *
        -: 4830: *   META_HEAPDUP:  same as META_DUP, but uses the heap                      */
        -: 4831:
        -: 4832:/**/
        -: 4833:mod_export char *
     1071: 4834:metafy(char *buf, int len, int heap)
        -: 4835:{
     1071: 4836:    int meta = 0;
        -: 4837:    char *t, *p, *e;
        -: 4838:    static char mbuf[PATH_MAX*2+1];
        -: 4839:
     1071: 4840:    if (len == -1) {
    10419: 4841:	for (e = buf, len = 0; *e; len++)
     9355: 4842:	    if (imeta(*e++))
    #####: 4843:		meta++;
        -: 4844:    } else
       66: 4845:	for (e = buf; e < buf + len;)
       52: 4846:	    if (imeta(*e++))
    #####: 4847:		meta++;
        -: 4848:
     1071: 4849:    if (meta || heap == META_DUP || heap == META_HEAPDUP) {
      132: 4850:	switch (heap) {
    #####: 4851:	case META_REALLOC:
    #####: 4852:	    buf = zrealloc(buf, len + meta + 1);
    #####: 4853:	    break;
    #####: 4854:	case META_HREALLOC:
    #####: 4855:	    buf = hrealloc(buf, len, len + meta + 1);
    #####: 4856:	    break;
      132: 4857:	case META_ALLOC:
        -: 4858:	case META_DUP:
      132: 4859:	    buf = memcpy(zalloc(len + meta + 1), buf, len);
      132: 4860:	    break;
    #####: 4861:	case META_USEHEAP:
        -: 4862:	case META_HEAPDUP:
    #####: 4863:	    buf = memcpy(zhalloc(len + meta + 1), buf, len);
    #####: 4864:	    break;
    #####: 4865:	case META_STATIC:
        -: 4866:#ifdef DEBUG
        -: 4867:	    if (len > PATH_MAX) {
        -: 4868:		fprintf(stderr, "BUG: len = %d > PATH_MAX in metafy\n", len);
        -: 4869:		fflush(stderr);
        -: 4870:	    }
        -: 4871:#endif
    #####: 4872:	    buf = memcpy(mbuf, buf, len);
    #####: 4873:	    break;
        -: 4874:#ifdef DEBUG
        -: 4875:	case META_NOALLOC:
        -: 4876:	    break;
        -: 4877:	default:
        -: 4878:	    fprintf(stderr, "BUG: metafy called with invalid heap value\n");
        -: 4879:	    fflush(stderr);
        -: 4880:	    break;
        -: 4881:#endif
        -: 4882:	}
      132: 4883:	p = buf + len;
      132: 4884:	e = t = buf + len + meta;
      264: 4885:	while (meta) {
    #####: 4886:	    if (imeta(*--t = *--p)) {
    #####: 4887:		*t-- ^= 32;
    #####: 4888:		*t = Meta;
    #####: 4889:		meta--;
        -: 4890:	    }
        -: 4891:	}
        -: 4892:    }
     1071: 4893:    *e = '\0';
     1071: 4894:    return buf;
        -: 4895:}
        -: 4896:
        -: 4897:
        -: 4898:/*
        -: 4899: * Duplicate a string, metafying it as we go.
        -: 4900: *
        -: 4901: * Typically, this is used only for strings imported from outside
        -: 4902: * zsh, as strings internally are either already metafied or passed
        -: 4903: * around with an associated length.
        -: 4904: */
        -: 4905:/**/
        -: 4906:mod_export char *
       94: 4907:ztrdup_metafy(const char *s)
        -: 4908:{
        -: 4909:    /* To mimic ztrdup() behaviour */
       94: 4910:    if (!s)
        2: 4911:	return NULL;
        -: 4912:    /*
        -: 4913:     * metafy() does lots of different things, so the pointer
        -: 4914:     * isn't const.  Using it with META_DUP should be safe.
        -: 4915:     */
       92: 4916:    return metafy((char *)s, -1, META_DUP);
        -: 4917:}
        -: 4918:
        -: 4919:
        -: 4920:/*
        -: 4921: * Take a null-terminated, metafied string in s into a literal
        -: 4922: * representation by converting in place.  The length is in *len
        -: 4923: * len is non-NULL; if len is NULL, you don't know the length of
        -: 4924: * the final string, but if it's to be supplied to some system
        -: 4925: * routine that always uses NULL termination, such as a filename
        -: 4926: * interpreter, that doesn't matter.  Note the NULL termination
        -: 4927: * is always copied for purposes of that kind.
        -: 4928: */
        -: 4929:
        -: 4930:/**/
        -: 4931:mod_export char *
      834: 4932:unmetafy(char *s, int *len)
        -: 4933:{
        -: 4934:    char *p, *t;
        -: 4935:
      834: 4936:    for (p = s; *p && *p != Meta; p++);
     1668: 4937:    for (t = p; (*t = *p++);)
    #####: 4938:	if (*t++ == Meta && *p)
    #####: 4939:	    t[-1] = *p++ ^ 32;
      834: 4940:    if (len)
      706: 4941:	*len = t - s;
      834: 4942:    return s;
        -: 4943:}
        -: 4944:
        -: 4945:/* Return the character length of a metafied substring, given the      *
        -: 4946: * unmetafied substring length.                                        */
        -: 4947:
        -: 4948:/**/
        -: 4949:mod_export int
    #####: 4950:metalen(const char *s, int len)
        -: 4951:{
    #####: 4952:    int mlen = len;
        -: 4953:
    #####: 4954:    while (len--) {
    #####: 4955:	if (*s++ == Meta) {
    #####: 4956:	    mlen++;
    #####: 4957:	    s++;
        -: 4958:	}
        -: 4959:    }
    #####: 4960:    return mlen;
        -: 4961:}
        -: 4962:
        -: 4963:/*
        -: 4964: * This function converts a zsh internal string to a form which can be
        -: 4965: * passed to a system call as a filename.  The result is stored in a
        -: 4966: * single static area, sized to fit.  If there is no Meta character
        -: 4967: * the original string is returned.
        -: 4968: */
        -: 4969:
        -: 4970:/**/
        -: 4971:mod_export char *
       59: 4972:unmeta(const char *file_name)
        -: 4973:{
        -: 4974:    static char *fn;
        -: 4975:    static int sz;
        -: 4976:    char *p;
        -: 4977:    const char *t;
        -: 4978:    int newsz, meta;
        -: 4979:
       59: 4980:    if (!file_name)
    #####: 4981:	return NULL;
        -: 4982:
       59: 4983:    meta = 0;
     1684: 4984:    for (t = file_name; *t; t++) {
     1625: 4985:	if (*t == Meta)
    #####: 4986:	    meta = 1;
        -: 4987:    }
       59: 4988:    if (!meta) {
        -: 4989:	/*
        -: 4990:	 * don't need allocation... free if it's long, see below
        -: 4991:	 */
       59: 4992:	if (sz > 4 * PATH_MAX) {
    #####: 4993:	    zfree(fn, sz);
    #####: 4994:	    fn = NULL;
    #####: 4995:	    sz = 0;
        -: 4996:	}
       59: 4997:	return (char *) file_name;
        -: 4998:    }
        -: 4999:
    #####: 5000:    newsz = (t - file_name) + 1;
        -: 5001:    /*
        -: 5002:     * Optimisation: don't resize if we don't have to.
        -: 5003:     * We need a new allocation if
        -: 5004:     * - nothing was allocated before
        -: 5005:     * - the new string is larger than the old one
        -: 5006:     * - the old string was larger than an arbitrary limit but the
        -: 5007:     *   new string isn't so that we free up significant space by resizing.
        -: 5008:     */
    #####: 5009:    if (!fn || newsz > sz || (sz > 4 * PATH_MAX && newsz <= 4 * PATH_MAX))
        -: 5010:    {
    #####: 5011:	if (fn)
    #####: 5012:	    zfree(fn, sz);
    #####: 5013:	sz = newsz;
    #####: 5014:	fn = (char *)zalloc(sz);
    #####: 5015:	if (!fn) {
    #####: 5016:	    sz = 0;
        -: 5017:	    /*
        -: 5018:	     * will quite likely crash in the caller anyway...
        -: 5019:	     */
    #####: 5020:	    return NULL;
        -: 5021:	}
        -: 5022:    }
        -: 5023:
    #####: 5024:    for (t = file_name, p = fn; *t; p++)
    #####: 5025:	if ((*p = *t++) == Meta && *t)
    #####: 5026:	    *p = *t++ ^ 32;
    #####: 5027:    *p = '\0';
    #####: 5028:    return fn;
        -: 5029:}
        -: 5030:
        -: 5031:/*
        -: 5032: * Unmetafy just one character and store the number of bytes it occupied.
        -: 5033: */
        -: 5034:/**/
        -: 5035:mod_export convchar_t
    #####: 5036:unmeta_one(const char *in, int *sz)
        -: 5037:{
        -: 5038:    convchar_t wc;
        -: 5039:    int newsz;
        -: 5040:#ifdef MULTIBYTE_SUPPORT
        -: 5041:    mbstate_t wstate;
        -: 5042:#endif
        -: 5043:
    #####: 5044:    if (!sz)
    #####: 5045:	sz = &newsz;
    #####: 5046:    *sz = 0;
        -: 5047:
    #####: 5048:    if (!in || !*in)
    #####: 5049:	return 0;
        -: 5050:
        -: 5051:#ifdef MULTIBYTE_SUPPORT
    #####: 5052:    memset(&wstate, 0, sizeof(wstate));
    #####: 5053:    *sz = mb_metacharlenconv_r(in, &wc, &wstate);
        -: 5054:#else
        -: 5055:    if (in[0] == Meta) {
        -: 5056:      *sz = 2;
        -: 5057:      wc = STOUC(in[1] ^ 32);
        -: 5058:    } else {
        -: 5059:      *sz = 1;
        -: 5060:      wc = STOUC(in[0]);
        -: 5061:    }
        -: 5062:#endif
    #####: 5063:    return wc;
        -: 5064:}
        -: 5065:
        -: 5066:/*
        -: 5067: * Unmetafy and compare two strings, comparing unsigned character values.
        -: 5068: * "a\0" sorts after "a".
        -: 5069: *
        -: 5070: * Currently this is only used in hash table sorting, where the
        -: 5071: * keys are names of hash nodes and where we don't use strcoll();
        -: 5072: * it's not clear if that's right but it does guarantee the ordering
        -: 5073: * of shell structures on output.
        -: 5074: *
        -: 5075: * As we don't use strcoll(), it seems overkill to convert multibyte
        -: 5076: * characters to wide characters for comparison every time.  In the case
        -: 5077: * of UTF-8, Unicode ordering is preserved when sorted raw, and for
        -: 5078: * other character sets we rely on an extension of ASCII so the result,
        -: 5079: * while it may not be correct, is at least rational.
        -: 5080: */
        -: 5081:
        -: 5082:/**/
        -: 5083:int
    #####: 5084:ztrcmp(char const *s1, char const *s2)
        -: 5085:{
        -: 5086:    int c1, c2;
        -: 5087:
    #####: 5088:    while(*s1 && *s1 == *s2) {
    #####: 5089:	s1++;
    #####: 5090:	s2++;
        -: 5091:    }
        -: 5092:
    #####: 5093:    if(!(c1 = *s1))
    #####: 5094:	c1 = -1;
    #####: 5095:    else if(c1 == STOUC(Meta))
    #####: 5096:	c1 = *++s1 ^ 32;
    #####: 5097:    if(!(c2 = *s2))
    #####: 5098:	c2 = -1;
    #####: 5099:    else if(c2 == STOUC(Meta))
    #####: 5100:	c2 = *++s2 ^ 32;
        -: 5101:
    #####: 5102:    if(c1 == c2)
    #####: 5103:	return 0;
    #####: 5104:    else if(c1 < c2)
    #####: 5105:	return -1;
        -: 5106:    else
    #####: 5107:	return 1;
        -: 5108:}
        -: 5109:
        -: 5110:/* Return the unmetafied length of a metafied string. */
        -: 5111:
        -: 5112:/**/
        -: 5113:mod_export int
       13: 5114:ztrlen(char const *s)
        -: 5115:{
        -: 5116:    int l;
        -: 5117:
      310: 5118:    for (l = 0; *s; l++) {
      297: 5119:	if (*s++ == Meta) {
        -: 5120:#ifdef DEBUG
        -: 5121:	    if (! *s) {
        -: 5122:		fprintf(stderr, "BUG: unexpected end of string in ztrlen()\n");
        -: 5123:		break;
        -: 5124:	    } else
        -: 5125:#endif
    #####: 5126:	    s++;
        -: 5127:	}
        -: 5128:    }
       13: 5129:    return l;
        -: 5130:}
        -: 5131:
        -: 5132:#ifndef MULTIBYTE_SUPPORT
        -: 5133:/*
        -: 5134: * ztrlen() but with explicit end point for non-null-terminated
        -: 5135: * segments.  eptr may not be NULL.
        -: 5136: */
        -: 5137:
        -: 5138:/**/
        -: 5139:mod_export int
        -: 5140:ztrlenend(char const *s, char const *eptr)
        -: 5141:{
        -: 5142:    int l;
        -: 5143:
        -: 5144:    for (l = 0; s < eptr; l++) {
        -: 5145:	if (*s++ == Meta) {
        -: 5146:#ifdef DEBUG
        -: 5147:	    if (! *s) {
        -: 5148:		fprintf(stderr,
        -: 5149:			"BUG: unexpected end of string in ztrlenend()\n");
        -: 5150:		break;
        -: 5151:	    } else
        -: 5152:#endif
        -: 5153:	    s++;
        -: 5154:	}
        -: 5155:    }
        -: 5156:    return l;
        -: 5157:}
        -: 5158:
        -: 5159:#endif /* MULTIBYTE_SUPPORT */
        -: 5160:
        -: 5161:/* Subtract two pointers in a metafied string. */
        -: 5162:
        -: 5163:/**/
        -: 5164:mod_export int
      417: 5165:ztrsub(char const *t, char const *s)
        -: 5166:{
      417: 5167:    int l = t - s;
        -: 5168:
     7767: 5169:    while (s != t) {
     6933: 5170:	if (*s++ == Meta) {
        -: 5171:#ifdef DEBUG
        -: 5172:	    if (! *s || s == t)
        -: 5173:		fprintf(stderr, "BUG: substring ends in the middle of a metachar in ztrsub()\n");
        -: 5174:	    else
        -: 5175:#endif
    #####: 5176:	    s++;
    #####: 5177:	    l--;
        -: 5178:	}
        -: 5179:    }
      417: 5180:    return l;
        -: 5181:}
        -: 5182:
        -: 5183:/*
        -: 5184: * Wrapper for readdir().
        -: 5185: *
        -: 5186: * If ignoredots is true, skip the "." and ".." entries.
        -: 5187: *
        -: 5188: * When __APPLE__ is defined, recode dirent names from UTF-8-MAC to UTF-8.
        -: 5189: *
        -: 5190: * Return the dirent's name, metafied.
        -: 5191: */
        -: 5192:
        -: 5193:/**/
        -: 5194:mod_export char *
      999: 5195:zreaddir(DIR *dir, int ignoredots)
        -: 5196:{
        -: 5197:    struct dirent *de;
        -: 5198:#if defined(HAVE_ICONV) && defined(__APPLE__)
        -: 5199:    static iconv_t conv_ds = (iconv_t)0;
        -: 5200:    static char *conv_name = 0;
        -: 5201:    char *conv_name_ptr, *orig_name_ptr;
        -: 5202:    size_t conv_name_len, orig_name_len;
        -: 5203:#endif
        -: 5204:
        -: 5205:    do {
      999: 5206:	de = readdir(dir);
      999: 5207:	if(!de)
       24: 5208:	    return NULL;
     1040: 5209:    } while(ignoredots && de->d_name[0] == '.' &&
     1081: 5210:	(!de->d_name[1] || (de->d_name[1] == '.' && !de->d_name[2])));
        -: 5211:
        -: 5212:#if defined(HAVE_ICONV) && defined(__APPLE__)
        -: 5213:    if (!conv_ds)
        -: 5214:	conv_ds = iconv_open("UTF-8", "UTF-8-MAC");
        -: 5215:    if (conv_ds != (iconv_t)(-1)) {
        -: 5216:	/* Force initial state in case re-using conv_ds */
        -: 5217:	(void) iconv(conv_ds, 0, &orig_name_len, 0, &conv_name_len);
        -: 5218:
        -: 5219:	orig_name_ptr = de->d_name;
        -: 5220:	orig_name_len = strlen(de->d_name);
        -: 5221:	conv_name = zrealloc(conv_name, orig_name_len+1);
        -: 5222:	conv_name_ptr = conv_name;
        -: 5223:	conv_name_len = orig_name_len;
        -: 5224:	if (iconv(conv_ds,
        -: 5225:		  &orig_name_ptr, &orig_name_len,
        -: 5226:		  &conv_name_ptr, &conv_name_len) != (size_t)(-1) &&
        -: 5227:	    orig_name_len == 0) {
        -: 5228:	    /* Completely converted, metafy and return */
        -: 5229:	    *conv_name_ptr = '\0';
        -: 5230:	    return metafy(conv_name, -1, META_STATIC);
        -: 5231:	}
        -: 5232:	/* Error, or conversion incomplete, keep the original name */
        -: 5233:    }
        -: 5234:#endif
        -: 5235:
      927: 5236:    return metafy(de->d_name, -1, META_STATIC);
        -: 5237:}
        -: 5238:
        -: 5239:/* Unmetafy and output a string.  Tokens are skipped. */
        -: 5240:
        -: 5241:/**/
        -: 5242:mod_export int
    #####: 5243:zputs(char const *s, FILE *stream)
        -: 5244:{
        -: 5245:    int c;
        -: 5246:
    #####: 5247:    while (*s) {
    #####: 5248:	if (*s == Meta)
    #####: 5249:	    c = *++s ^ 32;
    #####: 5250:	else if(itok(*s)) {
    #####: 5251:	    s++;
    #####: 5252:	    continue;
        -: 5253:	} else
    #####: 5254:	    c = *s;
    #####: 5255:	s++;
    #####: 5256:	if (fputc(c, stream) < 0)
    #####: 5257:	    return EOF;
        -: 5258:    }
    #####: 5259:    return 0;
        -: 5260:}
        -: 5261:
        -: 5262:#ifndef MULTIBYTE_SUPPORT
        -: 5263:/* Create a visibly-represented duplicate of a string. */
        -: 5264:
        -: 5265:/**/
        -: 5266:mod_export char *
        -: 5267:nicedup(char const *s, int heap)
        -: 5268:{
        -: 5269:    int c, len = strlen(s) * 5 + 1;
        -: 5270:    VARARR(char, buf, len);
        -: 5271:    char *p = buf, *n;
        -: 5272:
        -: 5273:    while ((c = *s++)) {
        -: 5274:	if (itok(c)) {
        -: 5275:	    if (c <= Comma)
        -: 5276:		c = ztokens[c - Pound];
        -: 5277:	    else
        -: 5278:		continue;
        -: 5279:	}
        -: 5280:	if (c == Meta)
        -: 5281:	    c = *s++ ^ 32;
        -: 5282:	/* The result here is metafied */
        -: 5283:	n = nicechar(c);
        -: 5284:	while(*n)
        -: 5285:	    *p++ = *n++;
        -: 5286:    }
        -: 5287:    *p = '\0';
        -: 5288:    return heap ? dupstring(buf) : ztrdup(buf);
        -: 5289:}
        -: 5290:#endif
        -: 5291:
        -: 5292:/**/
        -: 5293:mod_export char *
    #####: 5294:nicedupstring(char const *s)
        -: 5295:{
    #####: 5296:    return nicedup(s, 1);
        -: 5297:}
        -: 5298:
        -: 5299:
        -: 5300:#ifndef MULTIBYTE_SUPPORT
        -: 5301:/* Unmetafy and output a string, displaying special characters readably. */
        -: 5302:
        -: 5303:/**/
        -: 5304:mod_export int
        -: 5305:nicezputs(char const *s, FILE *stream)
        -: 5306:{
        -: 5307:    int c;
        -: 5308:
        -: 5309:    while ((c = *s++)) {
        -: 5310:	if (itok(c)) {
        -: 5311:	    if (c <= Comma)
        -: 5312:		c = ztokens[c - Pound];
        -: 5313:	    else
        -: 5314:		continue;
        -: 5315:	}
        -: 5316:	if (c == Meta)
        -: 5317:	    c = *s++ ^ 32;
        -: 5318:	if(zputs(nicechar(c), stream) < 0)
        -: 5319:	    return EOF;
        -: 5320:    }
        -: 5321:    return 0;
        -: 5322:}
        -: 5323:
        -: 5324:
        -: 5325:/* Return the length of the visible representation of a metafied string. */
        -: 5326:
        -: 5327:/**/
        -: 5328:mod_export size_t
        -: 5329:niceztrlen(char const *s)
        -: 5330:{
        -: 5331:    size_t l = 0;
        -: 5332:    int c;
        -: 5333:
        -: 5334:    while ((c = *s++)) {
        -: 5335:	if (itok(c)) {
        -: 5336:	    if (c <= Comma)
        -: 5337:		c = ztokens[c - Pound];
        -: 5338:	    else
        -: 5339:		continue;
        -: 5340:	}
        -: 5341:	if (c == Meta)
        -: 5342:	    c = *s++ ^ 32;
        -: 5343:	l += strlen(nicechar(c));
        -: 5344:    }
        -: 5345:    return l;
        -: 5346:}
        -: 5347:#endif
        -: 5348:
        -: 5349:
        -: 5350:/**/
        -: 5351:#ifdef MULTIBYTE_SUPPORT
        -: 5352:/*
        -: 5353: * Version of both nicezputs() and niceztrlen() for use with multibyte
        -: 5354: * characters.  Input is a metafied string; output is the screen width of
        -: 5355: * the string.
        -: 5356: *
        -: 5357: * If the FILE * is not NULL, output to that, too.
        -: 5358: *
        -: 5359: * If outstrp is not NULL, set *outstrp to a zalloc'd version of
        -: 5360: * the output (still metafied).
        -: 5361: *
        -: 5362: * If flags contains NICEFLAG_HEAP, use the heap for *outstrp, else
        -: 5363: * zalloc.
        -: 5364: * If flags contsins NICEFLAG_QUOTE, the output is going to be within
        -: 5365: * $'...', so quote "'" and "\" with a backslash.
        -: 5366: */
        -: 5367:
        -: 5368:/**/
        -: 5369:mod_export size_t
    #####: 5370:mb_niceformat(const char *s, FILE *stream, char **outstrp, int flags)
        -: 5371:{
    #####: 5372:    size_t l = 0, newl;
    #####: 5373:    int umlen, outalloc, outleft, eol = 0;
        -: 5374:    wchar_t c;
        -: 5375:    char *ums, *ptr, *fmt, *outstr, *outptr;
        -: 5376:    mbstate_t mbs;
        -: 5377:
    #####: 5378:    if (outstrp) {
    #####: 5379:	outleft = outalloc = 5 * strlen(s);
    #####: 5380:	outptr = outstr = zalloc(outalloc);
        -: 5381:    } else {
    #####: 5382:	outleft = outalloc = 0;
    #####: 5383:	outptr = outstr = NULL;
        -: 5384:    }
        -: 5385:
    #####: 5386:    ums = ztrdup(s);
        -: 5387:    /*
        -: 5388:     * is this necessary at this point? niceztrlen does this
        -: 5389:     * but it's used in lots of places.  however, one day this may
        -: 5390:     * be, too.
        -: 5391:     */
    #####: 5392:    untokenize(ums);
    #####: 5393:    ptr = unmetafy(ums, &umlen);
        -: 5394:
    #####: 5395:    memset(&mbs, 0, sizeof mbs);
    #####: 5396:    while (umlen > 0) {
    #####: 5397:	size_t cnt = eol ? MB_INVALID : mbrtowc(&c, ptr, umlen, &mbs);
        -: 5398:
    #####: 5399:	switch (cnt) {
    #####: 5400:	case MB_INCOMPLETE:
    #####: 5401:	    eol = 1;
        -: 5402:	    /* FALL THROUGH */
    #####: 5403:	case MB_INVALID:
        -: 5404:	    /* The byte didn't convert, so output it as a \M-... sequence. */
    #####: 5405:	    fmt = nicechar_sel(*ptr, flags & NICEFLAG_QUOTE);
    #####: 5406:	    newl = strlen(fmt);
    #####: 5407:	    cnt = 1;
        -: 5408:	    /* Get mbs out of its undefined state. */
    #####: 5409:	    memset(&mbs, 0, sizeof mbs);
    #####: 5410:	    break;
    #####: 5411:	case 0:
        -: 5412:	    /* Careful:  converting '\0' returns 0, but a '\0' is a
        -: 5413:	     * real character for us, so we should consume 1 byte. */
    #####: 5414:	    cnt = 1;
        -: 5415:	    /* FALL THROUGH */
    #####: 5416:	default:
    #####: 5417:	    if (c == L'\'' && (flags & NICEFLAG_QUOTE)) {
    #####: 5418:		fmt = "\\'";
    #####: 5419:		newl = 2;
        -: 5420:	    }
    #####: 5421:	    else if (c == L'\\' && (flags & NICEFLAG_QUOTE)) {
    #####: 5422:		fmt = "\\\\";
    #####: 5423:		newl = 2;
        -: 5424:	    }
        -: 5425:	    else
    #####: 5426:		fmt = wcs_nicechar_sel(c, &newl, NULL, flags & NICEFLAG_QUOTE);
    #####: 5427:	    break;
        -: 5428:	}
        -: 5429:
    #####: 5430:	umlen -= cnt;
    #####: 5431:	ptr += cnt;
    #####: 5432:	l += newl;
        -: 5433:
    #####: 5434:	if (stream)
    #####: 5435:	    zputs(fmt, stream);
    #####: 5436:	if (outstr) {
        -: 5437:	    /* Append to output string */
    #####: 5438:	    int outlen = strlen(fmt);
    #####: 5439:	    if (outlen >= outleft) {
        -: 5440:		/* Reallocate to twice the length */
    #####: 5441:		int outoffset = outptr - outstr;
        -: 5442:
    #####: 5443:		outleft += outalloc;
    #####: 5444:		outalloc *= 2;
    #####: 5445:		outstr = zrealloc(outstr, outalloc);
    #####: 5446:		outptr = outstr + outoffset;
        -: 5447:	    }
    #####: 5448:	    memcpy(outptr, fmt, outlen);
        -: 5449:	    /* Update start position */
    #####: 5450:	    outptr += outlen;
        -: 5451:	    /* Update available bytes */
    #####: 5452:	    outleft -= outlen;
        -: 5453:	}
        -: 5454:    }
        -: 5455:
    #####: 5456:    free(ums);
    #####: 5457:    if (outstrp) {
    #####: 5458:	*outptr = '\0';
        -: 5459:	/* Use more efficient storage for returned string */
    #####: 5460:	if (flags & NICEFLAG_NODUP)
    #####: 5461:	    *outstrp = outstr;
        -: 5462:	else {
    #####: 5463:	    *outstrp = (flags & NICEFLAG_HEAP) ? dupstring(outstr) :
        -: 5464:		ztrdup(outstr);
    #####: 5465:	    free(outstr);
        -: 5466:	}
        -: 5467:    }
        -: 5468:
    #####: 5469:    return l;
        -: 5470:}
        -: 5471:
        -: 5472:/*
        -: 5473: * Return 1 if mb_niceformat() would reformat this string, else 0.
        -: 5474: */
        -: 5475:
        -: 5476:/**/
        -: 5477:mod_export int
    #####: 5478:is_mb_niceformat(const char *s)
        -: 5479:{
    #####: 5480:    int umlen, eol = 0, ret = 0;
        -: 5481:    wchar_t c;
        -: 5482:    char *ums, *ptr;
        -: 5483:    mbstate_t mbs;
        -: 5484:
    #####: 5485:    ums = ztrdup(s);
    #####: 5486:    untokenize(ums);
    #####: 5487:    ptr = unmetafy(ums, &umlen);
        -: 5488:
    #####: 5489:    memset(&mbs, 0, sizeof mbs);
    #####: 5490:    while (umlen > 0) {
    #####: 5491:	size_t cnt = eol ? MB_INVALID : mbrtowc(&c, ptr, umlen, &mbs);
        -: 5492:
    #####: 5493:	switch (cnt) {
    #####: 5494:	case MB_INCOMPLETE:
    #####: 5495:	    eol = 1;
        -: 5496:	    /* FALL THROUGH */
    #####: 5497:	case MB_INVALID:
        -: 5498:	    /* The byte didn't convert, so output it as a \M-... sequence. */
    #####: 5499:	    if (is_nicechar(*ptr))  {
    #####: 5500:		ret = 1;
    #####: 5501:		break;
        -: 5502:	    }
    #####: 5503:	    cnt = 1;
        -: 5504:	    /* Get mbs out of its undefined state. */
    #####: 5505:	    memset(&mbs, 0, sizeof mbs);
    #####: 5506:	    break;
    #####: 5507:	case 0:
        -: 5508:	    /* Careful:  converting '\0' returns 0, but a '\0' is a
        -: 5509:	     * real character for us, so we should consume 1 byte. */
    #####: 5510:	    cnt = 1;
        -: 5511:	    /* FALL THROUGH */
    #####: 5512:	default:
    #####: 5513:	    if (is_wcs_nicechar(c))
    #####: 5514:		ret = 1;
    #####: 5515:	    break;
        -: 5516:	}
        -: 5517:
    #####: 5518:	if (ret)
    #####: 5519:	    break;
        -: 5520:
    #####: 5521:	umlen -= cnt;
    #####: 5522:	ptr += cnt;
        -: 5523:    }
        -: 5524:
    #####: 5525:    free(ums);
        -: 5526:
    #####: 5527:    return ret;
        -: 5528:}
        -: 5529:
        -: 5530:/* ztrdup multibyte string with nice formatting */
        -: 5531:
        -: 5532:/**/
        -: 5533:mod_export char *
    #####: 5534:nicedup(const char *s, int heap)
        -: 5535:{
        -: 5536:    char *retstr;
        -: 5537:
    #####: 5538:    (void)mb_niceformat(s, NULL, &retstr, heap ? NICEFLAG_HEAP : 0);
        -: 5539:
    #####: 5540:    return retstr;
        -: 5541:}
        -: 5542:
        -: 5543:
        -: 5544:/*
        -: 5545: * The guts of mb_metacharlenconv().  This version assumes we are
        -: 5546: * processing a true multibyte character string without tokens, and
        -: 5547: * takes the shift state as an argument.
        -: 5548: */
        -: 5549:
        -: 5550:/**/
        -: 5551:mod_export int
       55: 5552:mb_metacharlenconv_r(const char *s, wint_t *wcp, mbstate_t *mbsp)
        -: 5553:{
       55: 5554:    size_t ret = MB_INVALID;
        -: 5555:    char inchar;
        -: 5556:    const char *ptr;
        -: 5557:    wchar_t wc;
        -: 5558:
       55: 5559:    if (STOUC(*s) <= 0x7f) {
    #####: 5560:	if (wcp)
    #####: 5561:	    *wcp = (wint_t)*s;
    #####: 5562:	return 1;
        -: 5563:    }
        -: 5564:
      110: 5565:    for (ptr = s; *ptr; ) {
       55: 5566:	if (*ptr == Meta) {
       55: 5567:	    inchar = *++ptr ^ 32;
        -: 5568:	    DPUTS(!*ptr,
        -: 5569:		  "BUG: unexpected end of string in mb_metacharlen()\n");
    #####: 5570:	} else if (imeta(*ptr)) {
        -: 5571:	    /*
        -: 5572:	     * As this is metafied input, this is a token --- this
        -: 5573:	     * can't be a part of the string.  It might be
        -: 5574:	     * something on the end of an unbracketed parameter
        -: 5575:	     * reference, for example.
        -: 5576:	     */
    #####: 5577:	    break;
        -: 5578:	} else
    #####: 5579:	    inchar = *ptr;
       55: 5580:	ptr++;
       55: 5581:	ret = mbrtowc(&wc, &inchar, 1, mbsp);
        -: 5582:
       55: 5583:	if (ret == MB_INVALID)
    #####: 5584:	    break;
       55: 5585:	if (ret == MB_INCOMPLETE)
    #####: 5586:	    continue;
       55: 5587:	if (wcp)
       55: 5588:	    *wcp = wc;
       55: 5589:	return ptr - s;
        -: 5590:    }
        -: 5591:
    #####: 5592:    if (wcp)
    #####: 5593:	*wcp = WEOF;
        -: 5594:    /* No valid multibyte sequence */
    #####: 5595:    memset(mbsp, 0, sizeof(*mbsp));
    #####: 5596:    if (ptr > s) {
    #####: 5597:	return 1 + (*s == Meta);	/* Treat as single byte character */
        -: 5598:    } else
    #####: 5599:	return 0;		/* Probably shouldn't happen */
        -: 5600:}
        -: 5601:
        -: 5602:/*
        -: 5603: * Length of metafied string s which contains the next multibyte
        -: 5604: * character; single (possibly metafied) character if string is not null
        -: 5605: * but character is not valid (e.g. possibly incomplete at end of string).
        -: 5606: * Returned value is guaranteed not to reach beyond the end of the
        -: 5607: * string (assuming correct metafication).
        -: 5608: *
        -: 5609: * If wcp is not NULL, the converted wide character is stored there.
        -: 5610: * If no conversion could be done WEOF is used.
        -: 5611: */
        -: 5612:
        -: 5613:/**/
        -: 5614:mod_export int
    15510: 5615:mb_metacharlenconv(const char *s, wint_t *wcp)
        -: 5616:{
    15510: 5617:    if (!isset(MULTIBYTE) || STOUC(*s) <= 0x7f) {
        -: 5618:	/* treat as single byte, possibly metafied */
    15455: 5619:	if (wcp)
    15091: 5620:	    *wcp = (wint_t)(*s == Meta ? s[1] ^ 32 : *s);
    15455: 5621:	return 1 + (*s == Meta);
        -: 5622:    }
        -: 5623:    /*
        -: 5624:     * We have to handle tokens here, since we may be looking
        -: 5625:     * through a tokenized input.  Obviously this isn't
        -: 5626:     * a valid multibyte character, so just return WEOF
        -: 5627:     * and let the caller handle it as a single character.
        -: 5628:     *
        -: 5629:     * TODO: I've a sneaking suspicion we could do more here
        -: 5630:     * to prevent the caller always needing to handle invalid
        -: 5631:     * characters specially, but sometimes it may need to know.
        -: 5632:     */
       55: 5633:    if (itok(*s)) {
    #####: 5634:	if (wcp)
    #####: 5635:	    *wcp = WEOF;
    #####: 5636:	return 1;
        -: 5637:    }
        -: 5638:
       55: 5639:    return mb_metacharlenconv_r(s, wcp, &mb_shiftstate);
        -: 5640:}
        -: 5641:
        -: 5642:/*
        -: 5643: * Total number of multibyte characters in metafied string s.
        -: 5644: * Same answer as iterating mb_metacharlen() and counting calls
        -: 5645: * until end of string.
        -: 5646: *
        -: 5647: * If width is 1, return total character width rather than number.
        -: 5648: * If width is greater than 1, return 1 if character has non-zero width,
        -: 5649: * else 0.
        -: 5650: *
        -: 5651: * Ends if either *ptr is '\0', the normal case (eptr may be NULL for
        -: 5652: * this), or ptr is eptr (i.e.  *eptr is where the null would be if null
        -: 5653: * terminated) for strings not delimited by nulls --- note these are
        -: 5654: * still metafied.
        -: 5655: */
        -: 5656:
        -: 5657:/**/
        -: 5658:mod_export int
       10: 5659:mb_metastrlenend(char *ptr, int width, char *eptr)
        -: 5660:{
        -: 5661:    char inchar, *laststart;
        -: 5662:    size_t ret;
        -: 5663:    wchar_t wc;
        -: 5664:    int num, num_in_char, complete;
        -: 5665:
       10: 5666:    if (!isset(MULTIBYTE) || MB_CUR_MAX == 1)
       10: 5667:	return eptr ? (int)(eptr - ptr) : ztrlen(ptr);
        -: 5668:
    #####: 5669:    laststart = ptr;
    #####: 5670:    ret = MB_INVALID;
    #####: 5671:    num = num_in_char = 0;
    #####: 5672:    complete = 1;
        -: 5673:
    #####: 5674:    memset(&mb_shiftstate, 0, sizeof(mb_shiftstate));
    #####: 5675:    while (*ptr && !(eptr && ptr >= eptr)) {
    #####: 5676:	if (*ptr == Meta)
    #####: 5677:	    inchar = *++ptr ^ 32;
        -: 5678:	else
    #####: 5679:	    inchar = *ptr;
    #####: 5680:	ptr++;
        -: 5681:
    #####: 5682:	if (complete && STOUC(inchar) <= STOUC(0x7f)) {
        -: 5683:	    /*
        -: 5684:	     * We rely on 7-bit US-ASCII as a subset, so skip
        -: 5685:	     * multibyte handling if we have such a character.
        -: 5686:	     */
    #####: 5687:	    num++;
    #####: 5688:	    laststart = ptr;
    #####: 5689:	    num_in_char = 0;
    #####: 5690:	    continue;
        -: 5691:	}
        -: 5692:
    #####: 5693:	ret = mbrtowc(&wc, &inchar, 1, &mb_shiftstate);
        -: 5694:
    #####: 5695:	if (ret == MB_INCOMPLETE) {
        -: 5696:	    /*
        -: 5697:	     * "num_in_char" is only used for incomplete characters.
        -: 5698:	     * The assumption is that we will output all trailing octets
        -: 5699:	     * that form part of an incomplete character as a single
        -: 5700:	     * character (of single width) if we don't get a complete
        -: 5701:	     * character.  This is purely pragmatic --- I'm not aware
        -: 5702:	     * of a standard way of dealing with incomplete characters.
        -: 5703:	     *
        -: 5704:	     * If we do get a complete character, num_in_char
        -: 5705:	     * becomes irrelevant and is set to zero
        -: 5706:	     *
        -: 5707:	     * This is in contrast to "num" which counts the characters
        -: 5708:	     * or widths in complete characters.  The two are summed,
        -: 5709:	     * so we don't count characters twice.
        -: 5710:	     */
    #####: 5711:	    num_in_char++;
    #####: 5712:	    complete = 0;
        -: 5713:	} else {
    #####: 5714:	    if (ret == MB_INVALID) {
        -: 5715:		/* Reset, treat as single character */
    #####: 5716:		memset(&mb_shiftstate, 0, sizeof(mb_shiftstate));
    #####: 5717:		ptr = laststart + (*laststart == Meta) + 1;
    #####: 5718:		num++;
    #####: 5719:	    } else if (width) {
        -: 5720:		/*
        -: 5721:		 * Returns -1 if not a printable character.  We
        -: 5722:		 * turn this into 0.
        -: 5723:		 */
    #####: 5724:		int wcw = WCWIDTH(wc);
    #####: 5725:		if (wcw > 0) {
    #####: 5726:		    if (width == 1)
    #####: 5727:			num += wcw;
        -: 5728:		    else
    #####: 5729:			num++;
        -: 5730:		}
        -: 5731:	    } else
    #####: 5732:		num++;
    #####: 5733:	    laststart = ptr;
    #####: 5734:	    num_in_char = 0;
    #####: 5735:	    complete = 1;
        -: 5736:	}
        -: 5737:    }
        -: 5738:
        -: 5739:    /* If incomplete, treat remainder as trailing single character */
    #####: 5740:    return num + (num_in_char ? 1 : 0);
        -: 5741:}
        -: 5742:
        -: 5743:/*
        -: 5744: * The equivalent of mb_metacharlenconv_r() for
        -: 5745: * strings that aren't metafied and hence have
        -: 5746: * explicit lengths.
        -: 5747: */
        -: 5748:
        -: 5749:/**/
        -: 5750:mod_export int
    #####: 5751:mb_charlenconv_r(const char *s, int slen, wint_t *wcp, mbstate_t *mbsp)
        -: 5752:{
    #####: 5753:    size_t ret = MB_INVALID;
        -: 5754:    char inchar;
        -: 5755:    const char *ptr;
        -: 5756:    wchar_t wc;
        -: 5757:
    #####: 5758:    if (slen && STOUC(*s) <= 0x7f) {
    #####: 5759:	if (wcp)
    #####: 5760:	    *wcp = (wint_t)*s;
    #####: 5761:	return 1;
        -: 5762:    }
        -: 5763:
    #####: 5764:    for (ptr = s; slen;  ) {
    #####: 5765:	inchar = *ptr;
    #####: 5766:	ptr++;
    #####: 5767:	slen--;
    #####: 5768:	ret = mbrtowc(&wc, &inchar, 1, mbsp);
        -: 5769:
    #####: 5770:	if (ret == MB_INVALID)
    #####: 5771:	    break;
    #####: 5772:	if (ret == MB_INCOMPLETE)
    #####: 5773:	    continue;
    #####: 5774:	if (wcp)
    #####: 5775:	    *wcp = wc;
    #####: 5776:	return ptr - s;
        -: 5777:    }
        -: 5778:
    #####: 5779:    if (wcp)
    #####: 5780:	*wcp = WEOF;
        -: 5781:    /* No valid multibyte sequence */
    #####: 5782:    memset(mbsp, 0, sizeof(*mbsp));
    #####: 5783:    if (ptr > s) {
    #####: 5784:	return 1;	/* Treat as single byte character */
        -: 5785:    } else
    #####: 5786:	return 0;		/* Probably shouldn't happen */
        -: 5787:}
        -: 5788:
        -: 5789:/*
        -: 5790: * The equivalent of mb_metacharlenconv() for
        -: 5791: * strings that aren't metafied and hence have
        -: 5792: * explicit lengths;
        -: 5793: */
        -: 5794:
        -: 5795:/**/
        -: 5796:mod_export int
       10: 5797:mb_charlenconv(const char *s, int slen, wint_t *wcp)
        -: 5798:{
       10: 5799:    if (!isset(MULTIBYTE) || STOUC(*s) <= 0x7f) {
       10: 5800:	if (wcp)
    #####: 5801:	    *wcp = (wint_t)*s;
       10: 5802:	return 1;
        -: 5803:    }
        -: 5804:
    #####: 5805:    return mb_charlenconv_r(s, slen, wcp, &mb_shiftstate);
        -: 5806:}
        -: 5807:
        -: 5808:/**/
        -: 5809:#else
        -: 5810:
        -: 5811:/* Simple replacement for mb_metacharlenconv */
        -: 5812:
        -: 5813:/**/
        -: 5814:mod_export int
        -: 5815:metacharlenconv(const char *x, int *c)
        -: 5816:{
        -: 5817:    /*
        -: 5818:     * Here we don't use STOUC() on the chars since they
        -: 5819:     * may be compared against other chars and this will fail
        -: 5820:     * if chars are signed and the high bit is set.
        -: 5821:     */
        -: 5822:    if (*x == Meta) {
        -: 5823:	if (c)
        -: 5824:	    *c = x[1] ^ 32;
        -: 5825:	return 2;
        -: 5826:    }
        -: 5827:    if (c)
        -: 5828:	*c = (char)*x;
        -: 5829:    return 1;
        -: 5830:}
        -: 5831:
        -: 5832:/* Simple replacement for mb_charlenconv */
        -: 5833:
        -: 5834:/**/
        -: 5835:mod_export int
        -: 5836:charlenconv(const char *x, int len, int *c)
        -: 5837:{
        -: 5838:    if (!len) {
        -: 5839:	if (c)
        -: 5840:	    *c = '\0';
        -: 5841:	return 0;
        -: 5842:    }
        -: 5843:
        -: 5844:    if (c)
        -: 5845:	*c = (char)*x;
        -: 5846:    return 1;
        -: 5847:}
        -: 5848:
        -: 5849:/**/
        -: 5850:#endif /* MULTIBYTE_SUPPORT */
        -: 5851:
        -: 5852:/*
        -: 5853: * Expand tabs to given width, with given starting position on line.
        -: 5854: * len is length of unmetafied string in bytes.
        -: 5855: * Output to fout.
        -: 5856: * Return the end position on the line, i.e. if this is 0 modulo width
        -: 5857: * the next character is aligned with a tab stop.
        -: 5858: *
        -: 5859: * If all is set, all tabs are expanded, else only leading tabs.
        -: 5860: */
        -: 5861:
        -: 5862:/**/
        -: 5863:mod_export int
    #####: 5864:zexpandtabs(const char *s, int len, int width, int startpos, FILE *fout,
        -: 5865:	    int all)
        -: 5866:{
    #####: 5867:    int at_start = 1;
        -: 5868:
        -: 5869:#ifdef MULTIBYTE_SUPPORT
        -: 5870:    mbstate_t mbs;
        -: 5871:    size_t ret;
        -: 5872:    wchar_t wc;
        -: 5873:
    #####: 5874:    memset(&mbs, 0, sizeof(mbs));
        -: 5875:#endif
        -: 5876:
    #####: 5877:    while (len) {
    #####: 5878:	if (*s == '\t') {
    #####: 5879:	    if (all || at_start) {
    #####: 5880:		s++;
    #####: 5881:		len--;
    #####: 5882:		if (width <= 0 || !(startpos % width)) {
        -: 5883:		    /* always output at least one space */
    #####: 5884:		    fputc(' ', fout);
    #####: 5885:		    startpos++;
        -: 5886:		}
    #####: 5887:		if (width <= 0)
    #####: 5888:		    continue;	/* paranoia */
    #####: 5889:		while (startpos % width) {
    #####: 5890:		    fputc(' ', fout);
    #####: 5891:		    startpos++;
        -: 5892:		}
        -: 5893:	    } else {
        -: 5894:		/*
        -: 5895:		 * Leave tab alone.
        -: 5896:		 * Guess width to apply... we might get this wrong.
        -: 5897:		 * This is only needed if there's a following string
        -: 5898:		 * that needs tabs expanding, which is unusual.
        -: 5899:		 */
    #####: 5900:		startpos += width - startpos % width;
    #####: 5901:		s++;
    #####: 5902:		len--;
    #####: 5903:		fputc('\t', fout);
        -: 5904:	    }
    #####: 5905:	    continue;
    #####: 5906:	} else if (*s == '\n' || *s == '\r') {
    #####: 5907:	    fputc(*s, fout);
    #####: 5908:	    s++;
    #####: 5909:	    len--;
    #####: 5910:	    startpos = 0;
    #####: 5911:	    at_start = 1;
    #####: 5912:	    continue;
        -: 5913:	}
        -: 5914:
    #####: 5915:	at_start = 0;
        -: 5916:#ifdef MULTIBYTE_SUPPORT
    #####: 5917:	if (isset(MULTIBYTE)) {
    #####: 5918:	    const char *sstart = s;
    #####: 5919:	    ret = mbrtowc(&wc, s, len, &mbs);
    #####: 5920:	    if (ret == MB_INVALID) {
        -: 5921:		/* Assume single character per character */
    #####: 5922:		memset(&mbs, 0, sizeof(mbs));
    #####: 5923:		s++;
    #####: 5924:		len--;
    #####: 5925:	    } else if (ret == MB_INCOMPLETE ||
        -: 5926:		/* incomplete at end --- assume likewise, best we've got */
        -: 5927:	               ret == 0) {
        -: 5928:		/* NUL character returns 0, which would loop infinitely, so advance
        -: 5929:		 * one byte in this case too */
    #####: 5930:		s++;
    #####: 5931:		len--;
        -: 5932:	    } else {
    #####: 5933:		s += ret;
    #####: 5934:		len -= (int)ret;
        -: 5935:	    }
    #####: 5936:	    if (ret == MB_INVALID || ret == MB_INCOMPLETE) {
    #####: 5937:		startpos++;
        -: 5938:	    } else {
    #####: 5939:		int wcw = WCWIDTH(wc);
    #####: 5940:		if (wcw > 0)	/* paranoia */
    #####: 5941:		    startpos += wcw;
        -: 5942:	    }
    #####: 5943:	    fwrite(sstart, s - sstart, 1, fout);
        -: 5944:
    #####: 5945:	    continue;
        -: 5946:	}
        -: 5947:#endif /* MULTIBYTE_SUPPORT */
    #####: 5948:	fputc(*s, fout);
    #####: 5949:	s++;
    #####: 5950:	len--;
    #####: 5951:	startpos++;
        -: 5952:    }
        -: 5953:
    #####: 5954:    return startpos;
        -: 5955:}
        -: 5956:
        -: 5957:/* check for special characters in the string */
        -: 5958:
        -: 5959:/**/
        -: 5960:mod_export int
    #####: 5961:hasspecial(char const *s)
        -: 5962:{
    #####: 5963:    for (; *s; s++) {
    #####: 5964:	if (ispecial(*s == Meta ? *++s ^ 32 : *s))
    #####: 5965:	    return 1;
        -: 5966:    }
    #####: 5967:    return 0;
        -: 5968:}
        -: 5969:
        -: 5970:
        -: 5971:static char *
    #####: 5972:addunprintable(char *v, const char *u, const char *uend)
        -: 5973:{
    #####: 5974:    for (; u < uend; u++) {
        -: 5975:	/*
        -: 5976:	 * Just do this byte by byte; there's no great
        -: 5977:	 * advantage in being clever with multibyte
        -: 5978:	 * characters if we don't think they're printable.
        -: 5979:	 */
        -: 5980:	int c;
    #####: 5981:	if (*u == Meta)
    #####: 5982:	    c = STOUC(*++u ^ 32);
        -: 5983:	else
    #####: 5984:	    c = STOUC(*u);
    #####: 5985:	switch (c) {
    #####: 5986:	case '\0':
    #####: 5987:	    *v++ = '\\';
    #####: 5988:	    *v++ = '0';
    #####: 5989:	    if ('0' <= u[1] && u[1] <= '7') {
    #####: 5990:		*v++ = '0';
    #####: 5991:		*v++ = '0';
        -: 5992:	    }
    #####: 5993:	    break;
        -: 5994:
    #####: 5995:	case '\007': *v++ = '\\'; *v++ = 'a'; break;
    #####: 5996:	case '\b': *v++ = '\\'; *v++ = 'b'; break;
    #####: 5997:	case '\f': *v++ = '\\'; *v++ = 'f'; break;
    #####: 5998:	case '\n': *v++ = '\\'; *v++ = 'n'; break;
    #####: 5999:	case '\r': *v++ = '\\'; *v++ = 'r'; break;
    #####: 6000:	case '\t': *v++ = '\\'; *v++ = 't'; break;
    #####: 6001:	case '\v': *v++ = '\\'; *v++ = 'v'; break;
        -: 6002:
    #####: 6003:	default:
    #####: 6004:	    *v++ = '\\';
    #####: 6005:	    *v++ = '0' + ((c >> 6) & 7);
    #####: 6006:	    *v++ = '0' + ((c >> 3) & 7);
    #####: 6007:	    *v++ = '0' + (c & 7);
    #####: 6008:	    break;
        -: 6009:	}
        -: 6010:    }
        -: 6011:
    #####: 6012:    return v;
        -: 6013:}
        -: 6014:
        -: 6015:/*
        -: 6016: * Quote the string s and return the result as a string from the heap.
        -: 6017: *
        -: 6018: * The last argument is a QT_ value defined in zsh.h other than QT_NONE.
        -: 6019: *
        -: 6020: * Most quote styles other than backslash assume the quotes are to
        -: 6021: * be added outside quotestring().  QT_SINGLE_OPTIONAL is different:
        -: 6022: * the single quotes are only added where necessary, so the
        -: 6023: * whole expression is handled here.
        -: 6024: *
        -: 6025: * The string may be metafied and contain tokens.
        -: 6026: */
        -: 6027:
        -: 6028:/**/
        -: 6029:mod_export char *
    #####: 6030:quotestring(const char *s, int instring)
        -: 6031:{
        -: 6032:    const char *u;
        -: 6033:    char *v;
        -: 6034:    int alloclen;
        -: 6035:    char *buf;
    #####: 6036:    int shownull = 0;
        -: 6037:    /*
        -: 6038:     * quotesub is used with QT_SINGLE_OPTIONAL.
        -: 6039:     * quotesub = 0:  mechanism not active
        -: 6040:     * quotesub = 1:  mechanism pending, no "'" yet;
        -: 6041:     *                needs adding at quotestart.
        -: 6042:     * quotesub = 2:  mechanism active, added opening "'"; need
        -: 6043:     *                closing "'".
        -: 6044:     */
    #####: 6045:    int quotesub = 0, slen;
        -: 6046:    char *quotestart;
        -: 6047:    convchar_t cc;
        -: 6048:    const char *uend;
        -: 6049:
    #####: 6050:    slen = strlen(s);
    #####: 6051:    switch (instring)
        -: 6052:    {
    #####: 6053:    case QT_BACKSLASH_SHOWNULL:
    #####: 6054:	shownull = 1;
    #####: 6055:	instring = QT_BACKSLASH;
        -: 6056:	/*FALLTHROUGH*/
    #####: 6057:    case QT_BACKSLASH:
        -: 6058:	/*
        -: 6059:	 * With QT_BACKSLASH we may need to use $'\300' stuff.
        -: 6060:	 * Keep memory usage within limits by allocating temporary
        -: 6061:	 * storage and using heap for correct size at end.
        -: 6062:	 */
    #####: 6063:	alloclen = slen * 7 + 1;
    #####: 6064:	break;
        -: 6065:
    #####: 6066:    case QT_BACKSLASH_PATTERN:
    #####: 6067:	alloclen = slen * 2  + 1;
    #####: 6068:	break;
        -: 6069:
    #####: 6070:    case QT_SINGLE_OPTIONAL:
        -: 6071:	/*
        -: 6072:	 * Here, we may need to add single quotes.
        -: 6073:	 * Always show empty strings.
        -: 6074:	 */
    #####: 6075:	alloclen = slen * 4 + 3;
    #####: 6076:	quotesub = shownull = 1;
    #####: 6077:	break;
        -: 6078:
    #####: 6079:    default:
    #####: 6080:	alloclen = slen * 4 + 1;
    #####: 6081:	break;
        -: 6082:    }
    #####: 6083:    if (!*s && shownull)
    #####: 6084:	alloclen += 2;	/* for '' */
        -: 6085:
    #####: 6086:    quotestart = v = buf = zshcalloc(alloclen);
        -: 6087:
        -: 6088:    DPUTS(instring < QT_BACKSLASH || instring == QT_BACKTICK ||
        -: 6089:	  instring > QT_BACKSLASH_PATTERN,
        -: 6090:	  "BUG: bad quote type in quotestring");
    #####: 6091:    u = s;
    #####: 6092:    if (instring == QT_DOLLARS) {
        -: 6093:	/*
        -: 6094:	 * The only way to get Nularg here is when
        -: 6095:	 * it is placeholding for the empty string?
        -: 6096:	 */
    #####: 6097:	if (inull(*u))
    #####: 6098:	    u++;
        -: 6099:	/*
        -: 6100:	 * As we test for printability here we need to be able
        -: 6101:	 * to look for multibyte characters.
        -: 6102:	 */
    #####: 6103:	MB_METACHARINIT();
    #####: 6104:	while (*u) {
    #####: 6105:	    uend = u + MB_METACHARLENCONV(u, &cc);
        -: 6106:
    #####: 6107:	    if (
        -: 6108:#ifdef MULTIBYTE_SUPPORT
    #####: 6109:		cc != WEOF &&
        -: 6110:#endif
    #####: 6111:		WC_ISPRINT(cc)) {
    #####: 6112:		switch (cc) {
    #####: 6113:		case ZWC('\\'):
        -: 6114:		case ZWC('\''):
    #####: 6115:		    *v++ = '\\';
    #####: 6116:		    break;
        -: 6117:
    #####: 6118:		default:
    #####: 6119:		    if (isset(BANGHIST) && cc == (wchar_t)bangchar)
    #####: 6120:			*v++ = '\\';
    #####: 6121:		    break;
        -: 6122:		}
    #####: 6123:		while (u < uend)
    #####: 6124:		    *v++ = *u++;
        -: 6125:	    } else {
        -: 6126:		/* Not printable */
    #####: 6127:		v = addunprintable(v, u, uend);
    #####: 6128:		u = uend;
        -: 6129:	    }
        -: 6130:	}
    #####: 6131:    } else if (instring == QT_BACKSLASH_PATTERN) {
    #####: 6132:	while (*u) {
    #####: 6133:	    if (ipattern(*u))
    #####: 6134:		*v++ = '\\';
    #####: 6135:	    *v++ = *u++;
        -: 6136:	}
        -: 6137:    } else {
    #####: 6138:	if (shownull) {
        -: 6139:	    /* We can't show an empty string with just backslash quoting. */
    #####: 6140:	    if (!*u) {
    #####: 6141:		*v++ = '\'';
    #####: 6142:		*v++ = '\'';
        -: 6143:	    }
        -: 6144:	}
        -: 6145:	/*
        -: 6146:	 * Here there are syntactic special characters, so
        -: 6147:	 * we start by going through bytewise.
        -: 6148:	 */
    #####: 6149:	while (*u) {
    #####: 6150:	    int dobackslash = 0;
    #####: 6151:	    if (*u == Tick || *u == Qtick) {
    #####: 6152:		char c = *u++;
        -: 6153:
    #####: 6154:		*v++ = c;
    #####: 6155:		while (*u && *u != c)
    #####: 6156:		    *v++ = *u++;
    #####: 6157:		*v++ = c;
    #####: 6158:		if (*u)
    #####: 6159:		    u++;
    #####: 6160:		continue;
    #####: 6161:	    } else if ((*u == Qstring || *u == '$') && u[1] == '\'' &&
        -: 6162:		       instring == QT_DOUBLE) {
        -: 6163:		/*
        -: 6164:		 * We don't need to quote $'...' inside a double-quoted
        -: 6165:		 * string.  This is largely cosmetic; it looks neater
        -: 6166:		 * if we don't but it doesn't do any harm since the
        -: 6167:		 * \ is stripped.
        -: 6168:		 */
    #####: 6169:		*v++ = *u++;
    #####: 6170:	    } else if ((*u == String || *u == Qstring) &&
    #####: 6171:		       (u[1] == Inpar || u[1] == Inbrack || u[1] == Inbrace)) {
    #####: 6172:		char c = (u[1] == Inpar ? Outpar : (u[1] == Inbrace ?
        -: 6173:						    Outbrace : Outbrack));
    #####: 6174:		char beg = *u;
    #####: 6175:		int level = 0;
        -: 6176:
    #####: 6177:		*v++ = *u++;
    #####: 6178:		*v++ = *u++;
    #####: 6179:		while (*u && (*u != c || level)) {
    #####: 6180:		    if (*u == beg)
    #####: 6181:			level++;
    #####: 6182:		    else if (*u == c)
    #####: 6183:			level--;
    #####: 6184:		    *v++ = *u++;
        -: 6185:		}
    #####: 6186:		if (*u)
    #####: 6187:		    *v++ = *u++;
    #####: 6188:		continue;
        -: 6189:	    }
    #####: 6190:	    else if (ispecial(*u) &&
    #####: 6191:		     ((*u != '=' && *u != '~') ||
    #####: 6192:		      u == s ||
    #####: 6193:		      (isset(MAGICEQUALSUBST) &&
    #####: 6194:		       (u[-1] == '=' || u[-1] == ':')) ||
    #####: 6195:		      (*u == '~' && isset(EXTENDEDGLOB))) &&
    #####: 6196:		     (instring == QT_BACKSLASH ||
    #####: 6197:		      instring == QT_SINGLE_OPTIONAL ||
    #####: 6198:		      (isset(BANGHIST) && *u == (char)bangchar &&
    #####: 6199:		       instring != QT_SINGLE) ||
    #####: 6200:		      (instring == QT_DOUBLE &&
    #####: 6201:		       (*u == '$' || *u == '`' || *u == '\"' || *u == '\\')) ||
    #####: 6202:		      (instring == QT_SINGLE && *u == '\''))) {
    #####: 6203:		if (instring == QT_SINGLE_OPTIONAL) {
    #####: 6204:		    if (quotesub == 1) {
        -: 6205:			/*
        -: 6206:			 * We haven't yet had to quote at the start.
        -: 6207:			 */
    #####: 6208:			if (*u == '\'') {
        -: 6209:			    /*
        -: 6210:			     * We don't need to.
        -: 6211:			     */
    #####: 6212:			    *v++ = '\\';
        -: 6213:			} else {
        -: 6214:			    /*
        -: 6215:			     * It's now time to add quotes.
        -: 6216:			     */
    #####: 6217:			    if (v > quotestart)
        -: 6218:			    {
        -: 6219:				char *addq;
        -: 6220:
    #####: 6221:				for (addq = v; addq > quotestart; addq--)
    #####: 6222:				    *addq = addq[-1];
        -: 6223:			    }
    #####: 6224:			    *quotestart = '\'';
    #####: 6225:			    v++;
    #####: 6226:			    quotesub = 2;
        -: 6227:			}
    #####: 6228:			*v++ = *u++;
        -: 6229:			/*
        -: 6230:			 * Next place to start quotes is here.
        -: 6231:			 */
    #####: 6232:			quotestart = v;
    #####: 6233:		    } else if (*u == '\'') {
    #####: 6234:			if (unset(RCQUOTES)) {
    #####: 6235:			    *v++ = '\'';
    #####: 6236:			    *v++ = '\\';
    #####: 6237:			    *v++ = '\'';
        -: 6238:			    /* Don't restart quotes unless we need them */
    #####: 6239:			    quotesub = 1;
    #####: 6240:			    quotestart = v;
        -: 6241:			} else {
        -: 6242:			    /* simplest just to use '' always */
    #####: 6243:			    *v++ = '\'';
    #####: 6244:			    *v++ = '\'';
        -: 6245:			}
        -: 6246:			/* dealt with */
    #####: 6247:			u++;
        -: 6248:		    } else {
        -: 6249:			/* else already quoting, just add */
    #####: 6250:			*v++ = *u++;
        -: 6251:		    }
    #####: 6252:		    continue;
    #####: 6253:		} else if (*u == '\n' ||
    #####: 6254:			   (instring == QT_SINGLE && *u == '\'')) {
    #####: 6255:		    if (*u == '\n') {
    #####: 6256:			*v++ = '$';
    #####: 6257:			*v++ = '\'';
    #####: 6258:			*v++ = '\\';
    #####: 6259:			*v++ = 'n';
    #####: 6260:			*v++ = '\'';
    #####: 6261:		    } else if (unset(RCQUOTES)) {
    #####: 6262:			*v++ = '\'';
    #####: 6263:			if (*u == '\'')
    #####: 6264:			    *v++ = '\\';
    #####: 6265:			*v++ = *u;
    #####: 6266:			*v++ = '\'';
        -: 6267:		    } else
    #####: 6268:			*v++ = '\'', *v++ = '\'';
    #####: 6269:		    u++;
    #####: 6270:		    continue;
        -: 6271:		} else {
        -: 6272:		    /*
        -: 6273:		     * We'll need a backslash, but don't add it
        -: 6274:		     * yet since if the character isn't printable
        -: 6275:		     * we'll have to upgrade it to $'...'.
        -: 6276:		     */
    #####: 6277:		    dobackslash = 1;
        -: 6278:		}
        -: 6279:	    }
        -: 6280:
    #####: 6281:	    if (itok(*u) || instring != QT_BACKSLASH) {
        -: 6282:		/* Needs to be passed straight through. */
    #####: 6283:		if (dobackslash)
    #####: 6284:		    *v++ = '\\';
    #####: 6285:		if (*u == Inparmath) {
        -: 6286:		    /*
        -: 6287:		     * Already syntactically quoted: don't
        -: 6288:		     * add more.
        -: 6289:		     */
    #####: 6290:		    int inmath = 1;
    #####: 6291:		    *v++ = *u++;
    #####: 6292:		    for (;;) {
    #####: 6293:			char uc = *u;
    #####: 6294:			*v++ = *u++;
    #####: 6295:			if (uc == '\0')
    #####: 6296:			    break;
    #####: 6297:			else if (uc == Outparmath && !--inmath)
        -: 6298:			    break;
    #####: 6299:			else if (uc == Inparmath)
    #####: 6300:			    ++inmath;
        -: 6301:		    }
        -: 6302:		} else
    #####: 6303:		    *v++ = *u++;
    #####: 6304:		continue;
        -: 6305:	    }
        -: 6306:
        -: 6307:	    /*
        -: 6308:	     * Now check if the output is unprintable in the
        -: 6309:	     * current character set.
        -: 6310:	     */
    #####: 6311:	    uend = u + MB_METACHARLENCONV(u, &cc);
    #####: 6312:	    if (
        -: 6313:#ifdef MULTIBYTE_SUPPORT
    #####: 6314:		cc != WEOF &&
        -: 6315:#endif
    #####: 6316:		WC_ISPRINT(cc)) {
    #####: 6317:		if (dobackslash)
    #####: 6318:		    *v++ = '\\';
    #####: 6319:		while (u < uend) {
    #####: 6320:		    if (*u == Meta)
    #####: 6321:			*v++ = *u++;
    #####: 6322:		    *v++ = *u++;
        -: 6323:		}
        -: 6324:	    } else {
        -: 6325:		/* Not printable */
    #####: 6326:		*v++ = '$';
    #####: 6327:		*v++ = '\'';
    #####: 6328:		v = addunprintable(v, u, uend);
    #####: 6329:		*v++ = '\'';
    #####: 6330:		u = uend;
        -: 6331:	    }
        -: 6332:	}
        -: 6333:    }
    #####: 6334:    if (quotesub == 2)
    #####: 6335:	*v++ = '\'';
    #####: 6336:    *v = '\0';
        -: 6337:
    #####: 6338:    v = dupstring(buf);
    #####: 6339:    zfree(buf, alloclen);
    #####: 6340:    return v;
        -: 6341:}
        -: 6342:
        -: 6343:/*
        -: 6344: * Unmetafy and output a string, quoted if it contains special
        -: 6345: * characters.
        -: 6346: *
        -: 6347: * If stream is NULL, return the same output with any allocation on the
        -: 6348: * heap.
        -: 6349: */
        -: 6350:
        -: 6351:/**/
        -: 6352:mod_export char *
    #####: 6353:quotedzputs(char const *s, FILE *stream)
        -: 6354:{
    #####: 6355:    int inquote = 0, c;
        -: 6356:    char *outstr, *ptr;
        -: 6357:
        -: 6358:    /* check for empty string */
    #####: 6359:    if(!*s) {
    #####: 6360:	if (!stream)
    #####: 6361:	    return dupstring("''");
    #####: 6362:	fputs("''", stream);
    #####: 6363:	return NULL;
        -: 6364:    }
        -: 6365:
        -: 6366:#ifdef MULTIBYTE_SUPPORT
    #####: 6367:    if (is_mb_niceformat(s)) {
    #####: 6368:	if (stream) {
    #####: 6369:	    fputs("$'", stream);
    #####: 6370:	    mb_niceformat(s, stream, NULL, NICEFLAG_QUOTE);
    #####: 6371:	    fputc('\'', stream);
    #####: 6372:	    return NULL;
        -: 6373:	} else {
        -: 6374:	    char *substr;
    #####: 6375:	    mb_niceformat(s, NULL, &substr, NICEFLAG_QUOTE|NICEFLAG_NODUP);
    #####: 6376:	    outstr = (char *)zhalloc(4 + strlen(substr));
    #####: 6377:	    sprintf(outstr, "$'%s'", substr);
    #####: 6378:	    free(substr);
    #####: 6379:	    return outstr;
        -: 6380:	}
        -: 6381:    }
        -: 6382:#endif /* MULTIBYTE_SUPPORT */
        -: 6383:
    #####: 6384:    if (!hasspecial(s)) {
    #####: 6385:	if (stream) {
    #####: 6386:	    zputs(s, stream);
    #####: 6387:	    return NULL;
        -: 6388:	} else {
    #####: 6389:	    return dupstring(s);
        -: 6390:	}
        -: 6391:    }
        -: 6392:
    #####: 6393:    if (!stream) {
        -: 6394:	const char *cptr;
    #####: 6395:	int l = strlen(s) + 2;
    #####: 6396:	for (cptr = s; *cptr; cptr++) {
    #####: 6397:	    if (*cptr == Meta)
    #####: 6398:		cptr++;
    #####: 6399:	    else if (*cptr == '\'')
    #####: 6400:		l += isset(RCQUOTES) ? 1 : 3;
        -: 6401:	}
    #####: 6402:	ptr = outstr = zhalloc(l + 1);
        -: 6403:    } else {
    #####: 6404:	ptr = outstr = NULL;
        -: 6405:    }
    #####: 6406:    if (isset(RCQUOTES)) {
        -: 6407:	/* use rc-style quotes-within-quotes for the whole string */
    #####: 6408:	if (stream) {
    #####: 6409:	    if (fputc('\'', stream) < 0)
    #####: 6410:		return NULL;
        -: 6411:	} else
    #####: 6412:	    *ptr++ = '\'';
    #####: 6413:	while(*s) {
    #####: 6414:	    if (*s == Dash)
    #####: 6415:		c = '-';
    #####: 6416:	    else if (*s == Meta)
    #####: 6417:		c = *++s ^ 32;
        -: 6418:	    else
    #####: 6419:		c = *s;
    #####: 6420:	    s++;
    #####: 6421:	    if (c == '\'') {
    #####: 6422:		if (stream) {
    #####: 6423:		    if (fputc('\'', stream) < 0)
    #####: 6424:			return NULL;
        -: 6425:		} else
    #####: 6426:		    *ptr++ = '\'';
    #####: 6427:	    } else if (c == '\n' && isset(CSHJUNKIEQUOTES)) {
    #####: 6428:		if (stream) {
    #####: 6429:		    if (fputc('\\', stream) < 0)
    #####: 6430:			return NULL;
        -: 6431:		} else
    #####: 6432:		    *ptr++ = '\\';
        -: 6433:	    }
    #####: 6434:	    if (stream) {
    #####: 6435:		if (fputc(c, stream) < 0)
    #####: 6436:		    return NULL;
        -: 6437:	    } else {
    #####: 6438:		if (imeta(c)) {
    #####: 6439:		    *ptr++ = Meta;
    #####: 6440:		    *ptr++ = c ^ 32;
        -: 6441:		} else
    #####: 6442:		    *ptr++ = c;
        -: 6443:	    }
        -: 6444:	}
    #####: 6445:	if (stream) {
    #####: 6446:	    if (fputc('\'', stream) < 0)
    #####: 6447:		return NULL;
        -: 6448:	} else
    #####: 6449:	    *ptr++ = '\'';
        -: 6450:    } else {
        -: 6451:	/* use Bourne-style quoting, avoiding empty quoted strings */
    #####: 6452:	while (*s) {
    #####: 6453:	    if (*s == Dash)
    #####: 6454:		c = '-';
    #####: 6455:	    else if (*s == Meta)
    #####: 6456:		c = *++s ^ 32;
        -: 6457:	    else
    #####: 6458:		c = *s;
    #####: 6459:	    s++;
    #####: 6460:	    if (c == '\'') {
    #####: 6461:		if (inquote) {
    #####: 6462:		    if (stream) {
    #####: 6463:			if (putc('\'', stream) < 0)
    #####: 6464:			    return NULL;
        -: 6465:		    } else
    #####: 6466:			*ptr++ = '\'';
    #####: 6467:		    inquote=0;
        -: 6468:		}
    #####: 6469:		if (stream) {
    #####: 6470:		    if (fputs("\\'", stream) < 0)
    #####: 6471:			return NULL;
        -: 6472:		} else {
    #####: 6473:		    *ptr++ = '\\';
    #####: 6474:		    *ptr++ = '\'';
        -: 6475:		}
        -: 6476:	    } else {
    #####: 6477:		if (!inquote) {
    #####: 6478:		    if (stream) {
    #####: 6479:			if (fputc('\'', stream) < 0)
    #####: 6480:			    return NULL;
        -: 6481:		    } else
    #####: 6482:			*ptr++ = '\'';
    #####: 6483:		    inquote=1;
        -: 6484:		}
    #####: 6485:		if (c == '\n' && isset(CSHJUNKIEQUOTES)) {
    #####: 6486:		    if (stream) {
    #####: 6487:			if (fputc('\\', stream) < 0)
    #####: 6488:			    return NULL;
        -: 6489:		    } else
    #####: 6490:			*ptr++ = '\\';
        -: 6491:		}
    #####: 6492:		if (stream) {
    #####: 6493:		    if (fputc(c, stream) < 0)
    #####: 6494:			return NULL;
        -: 6495:		} else {
    #####: 6496:		    if (imeta(c)) {
    #####: 6497:			*ptr++ = Meta;
    #####: 6498:			*ptr++ = c ^ 32;
        -: 6499:		    } else
    #####: 6500:			*ptr++ = c;
        -: 6501:		}
        -: 6502:	    }
        -: 6503:	}
    #####: 6504:	if (inquote) {
    #####: 6505:	    if (stream) {
    #####: 6506:		if (fputc('\'', stream) < 0)
    #####: 6507:		    return NULL;
        -: 6508:	    } else
    #####: 6509:		*ptr++ = '\'';
        -: 6510:	}
        -: 6511:    }
    #####: 6512:    if (!stream)
    #####: 6513:	*ptr++ = '\0';
        -: 6514:
    #####: 6515:    return outstr;
        -: 6516:}
        -: 6517:
        -: 6518:/* Double-quote a metafied string. */
        -: 6519:
        -: 6520:/**/
        -: 6521:mod_export char *
    #####: 6522:dquotedztrdup(char const *s)
        -: 6523:{
    #####: 6524:    int len = strlen(s) * 4 + 2;
    #####: 6525:    char *buf = zalloc(len);
    #####: 6526:    char *p = buf, *ret;
        -: 6527:
    #####: 6528:    if(isset(CSHJUNKIEQUOTES)) {
    #####: 6529:	int inquote = 0;
        -: 6530:
    #####: 6531:	while(*s) {
    #####: 6532:	    int c = *s++;
        -: 6533:
    #####: 6534:	    if (c == Meta)
    #####: 6535:		c = *s++ ^ 32;
    #####: 6536:	    switch(c) {
    #####: 6537:		case '"':
        -: 6538:		case '$':
        -: 6539:		case '`':
    #####: 6540:		    if(inquote) {
    #####: 6541:			*p++ = '"';
    #####: 6542:			inquote = 0;
        -: 6543:		    }
    #####: 6544:		    *p++ = '\\';
    #####: 6545:		    *p++ = c;
    #####: 6546:		    break;
    #####: 6547:		default:
    #####: 6548:		    if(!inquote) {
    #####: 6549:			*p++ = '"';
    #####: 6550:			inquote = 1;
        -: 6551:		    }
    #####: 6552:		    if(c == '\n')
    #####: 6553:			*p++ = '\\';
    #####: 6554:		    *p++ = c;
    #####: 6555:		    break;
        -: 6556:	    }
        -: 6557:	}
    #####: 6558:	if (inquote)
    #####: 6559:	    *p++ = '"';
        -: 6560:    } else {
    #####: 6561:	int pending = 0;
        -: 6562:
    #####: 6563:	*p++ = '"';
    #####: 6564:	while(*s) {
    #####: 6565:	    int c = *s++;
        -: 6566:
    #####: 6567:	    if (c == Meta)
    #####: 6568:		c = *s++ ^ 32;
    #####: 6569:	    switch(c) {
    #####: 6570:		case '\\':
    #####: 6571:		    if(pending)
    #####: 6572:			*p++ = '\\';
    #####: 6573:		    *p++ = '\\';
    #####: 6574:		    pending = 1;
    #####: 6575:		    break;
    #####: 6576:		case '"':
        -: 6577:		case '$':
        -: 6578:		case '`':
    #####: 6579:		    if(pending)
    #####: 6580:			*p++ = '\\';
    #####: 6581:		    *p++ = '\\';
        -: 6582:		    /* FALL THROUGH */
    #####: 6583:		default:
    #####: 6584:		    *p++ = c;
    #####: 6585:		    pending = 0;
    #####: 6586:		    break;
        -: 6587:	    }
        -: 6588:	}
    #####: 6589:	if(pending)
    #####: 6590:	    *p++ = '\\';
    #####: 6591:	*p++ = '"';
        -: 6592:    }
    #####: 6593:    ret = metafy(buf, p - buf, META_DUP);
    #####: 6594:    zfree(buf, len);
    #####: 6595:    return ret;
        -: 6596:}
        -: 6597:
        -: 6598:/* Unmetafy and output a string, double quoting it in its entirety. */
        -: 6599:
        -: 6600:#if 0 /**/
        -: 6601:int
        -: 6602:dquotedzputs(char const *s, FILE *stream)
        -: 6603:{
        -: 6604:    char *d = dquotedztrdup(s);
        -: 6605:    int ret = zputs(d, stream);
        -: 6606:
        -: 6607:    zsfree(d);
        -: 6608:    return ret;
        -: 6609:}
        -: 6610:#endif
        -: 6611:
        -: 6612:# if defined(HAVE_NL_LANGINFO) && defined(CODESET) && !defined(__STDC_ISO_10646__)
        -: 6613:/* Convert a character from UCS4 encoding to UTF-8 */
        -: 6614:
        -: 6615:static size_t
        -: 6616:ucs4toutf8(char *dest, unsigned int wval)
        -: 6617:{
        -: 6618:    size_t len;
        -: 6619:
        -: 6620:    if (wval < 0x80)
        -: 6621:      len = 1;
        -: 6622:    else if (wval < 0x800)
        -: 6623:      len = 2;
        -: 6624:    else if (wval < 0x10000)
        -: 6625:      len = 3;
        -: 6626:    else if (wval < 0x200000)
        -: 6627:      len = 4;
        -: 6628:    else if (wval < 0x4000000)
        -: 6629:      len = 5;
        -: 6630:    else
        -: 6631:      len = 6;
        -: 6632:
        -: 6633:    switch (len) { /* falls through except to the last case */
        -: 6634:    case 6: dest[5] = (wval & 0x3f) | 0x80; wval >>= 6;
        -: 6635:    case 5: dest[4] = (wval & 0x3f) | 0x80; wval >>= 6;
        -: 6636:    case 4: dest[3] = (wval & 0x3f) | 0x80; wval >>= 6;
        -: 6637:    case 3: dest[2] = (wval & 0x3f) | 0x80; wval >>= 6;
        -: 6638:    case 2: dest[1] = (wval & 0x3f) | 0x80; wval >>= 6;
        -: 6639:	*dest = wval | ((0xfc << (6 - len)) & 0xfc);
        -: 6640:	break;
        -: 6641:    case 1: *dest = wval;
        -: 6642:    }
        -: 6643:
        -: 6644:    return len;
        -: 6645:}
        -: 6646:#endif
        -: 6647:
        -: 6648:
        -: 6649:/*
        -: 6650: * The following only occurs once or twice in the code, but in different
        -: 6651: * places depending how character set conversion is implemented.
        -: 6652: */
        -: 6653:#define CHARSET_FAILED()		      \
        -: 6654:    if (how & GETKEY_DOLLAR_QUOTE) {	      \
        -: 6655:	while ((*tdest++ = *++s)) {	      \
        -: 6656:	    if (how & GETKEY_UPDATE_OFFSET) { \
        -: 6657:		if (s - sstart > *misc)	      \
        -: 6658:		    (*misc)++;		      \
        -: 6659:	    }				      \
        -: 6660:	    if (*s == Snull) {		      \
        -: 6661:		*len = (s - sstart) + 1;      \
        -: 6662:		*tdest = '\0';		      \
        -: 6663:		return buf;		      \
        -: 6664:	    }				      \
        -: 6665:	}				      \
        -: 6666:	*len = tdest - buf;		      \
        -: 6667:	return buf;			      \
        -: 6668:    }					      \
        -: 6669:    *t = '\0';				      \
        -: 6670:    *len = t - buf;			      \
        -: 6671:    return buf
        -: 6672:
        -: 6673:/*
        -: 6674: * Decode a key string, turning it into the literal characters.
        -: 6675: * The value returned is a newly allocated string from the heap.
        -: 6676: *
        -: 6677: * The length is returned in *len.  This is usually the length of
        -: 6678: * the final unmetafied string.  The exception is the case of
        -: 6679: * a complete GETKEY_DOLLAR_QUOTE conversion where *len is the
        -: 6680: * length of the input string which has been used (up to and including
        -: 6681: * the terminating single quote); as the final string is metafied and
        -: 6682: * NULL-terminated its length is not required.  If both GETKEY_DOLLAR_QUOTE
        -: 6683: * and GETKEY_UPDATE_OFFSET are present in "how", the string is not
        -: 6684: * expected to be terminated (this is used in completion to parse
        -: 6685: * a partial $'...'-quoted string) and the length passed back is
        -: 6686: * that of the converted string.  Note in both cases that this is a length
        -: 6687: * in bytes (i.e. the same as given by a raw pointer difference), not
        -: 6688: * characters, which may occupy multiple bytes.
        -: 6689: *
        -: 6690: * how is a set of bits from the GETKEY_ values defined in zsh.h;
        -: 6691: * not all combinations of bits are useful.  Callers will typically
        -: 6692: * use one of the GETKEYS_ values which define sets of bits.
        -: 6693: * Note, for example that:
        -: 6694: * - GETKEY_SINGLE_CHAR must not be combined with GETKEY_DOLLAR_QUOTE.
        -: 6695: * - GETKEY_UPDATE_OFFSET is only allowed if GETKEY_DOLLAR_QUOTE is
        -: 6696: *   also present.
        -: 6697: *
        -: 6698: * *misc is used for various purposes:
        -: 6699: * - If GETKEY_BACKSLASH_MINUS is set, it indicates the presence
        -: 6700: *   of \- in the input.
        -: 6701: * - If GETKEY_BACKSLASH_C is set, it indicates the presence
        -: 6702: *   of \c in the input.
        -: 6703: * - If GETKEY_UPDATE_OFFSET is set, it is set on input to some
        -: 6704: *   mystical completion offset and is updated to a new offset based
        -: 6705: *   on the converted characters.  All Hail the Completion System
        -: 6706: *   [makes the mystic completion system runic sign in the air].
        -: 6707: *
        -: 6708: * The return value is unmetafied unless GETKEY_DOLLAR_QUOTE is
        -: 6709: * in use.
        -: 6710: *
        -: 6711: * If GETKEY_SINGLE_CHAR is set in how, a next character in the given
        -: 6712: * string is parsed, and the character code for it is returned in misc.
        -: 6713: * The return value of the function is a pointer to the byte in the
        -: 6714: * given string from where the next parsing should start. If the next
        -: 6715: * character can't be found then NULL is returned.
        -: 6716: * CAUTION: Currently, GETKEY_SINGLE_CHAR can be used only via
        -: 6717: *          GETKEYS_MATH. Other use of it may cause trouble.
        -: 6718: */
        -: 6719:
        -: 6720:/**/
        -: 6721:mod_export char *
       48: 6722:getkeystring(char *s, int *len, int how, int *misc)
        -: 6723:{
       48: 6724:    char *buf = NULL, tmp[1];
       48: 6725:    char *t, *tdest = NULL, *u = NULL, *sstart = s, *tbuf = NULL;
       48: 6726:    char svchar = '\0';
       48: 6727:    int meta = 0, control = 0, ignoring = 0;
        -: 6728:    int i;
        -: 6729:#if defined(HAVE_WCHAR_H) && defined(HAVE_WCTOMB) && defined(__STDC_ISO_10646__)
        -: 6730:    wint_t wval;
        -: 6731:    int count;
        -: 6732:#else
        -: 6733:    unsigned int wval;
        -: 6734:# if defined(HAVE_NL_LANGINFO) && defined(CODESET)
        -: 6735:#  if defined(HAVE_ICONV)
        -: 6736:    iconv_t cd;
        -: 6737:    char inbuf[4];
        -: 6738:    size_t inbytes, outbytes;
        -: 6739:#  endif
        -: 6740:    size_t count;
        -: 6741:# endif
        -: 6742:#endif
        -: 6743:
        -: 6744:    DPUTS((how & GETKEY_UPDATE_OFFSET) &&
        -: 6745:	  (how & ~(GETKEYS_DOLLARS_QUOTE|GETKEY_UPDATE_OFFSET)),
        -: 6746:	  "BUG: offset updating in getkeystring only supported with $'.");
        -: 6747:    DPUTS((how & (GETKEY_DOLLAR_QUOTE|GETKEY_SINGLE_CHAR)) ==
        -: 6748:	  (GETKEY_DOLLAR_QUOTE|GETKEY_SINGLE_CHAR),
        -: 6749:	  "BUG: incompatible options in getkeystring");
        -: 6750:    DPUTS((how & GETKEY_SINGLE_CHAR) && (how != GETKEYS_MATH),
        -: 6751:	  "BUG: unsupported options in getkeystring");
        -: 6752:
       48: 6753:    if (how & GETKEY_SINGLE_CHAR)
    #####: 6754:	t = tmp;
        -: 6755:    else {
        -: 6756:	/* Length including terminating NULL */
       48: 6757:	int maxlen = 1;
        -: 6758:	/*
        -: 6759:	 * We're not necessarily guaranteed the output string will
        -: 6760:	 * be no longer than the input with \u and \U when output
        -: 6761:	 * characters need to be metafied.  As this is the only
        -: 6762:	 * case where the string can get longer (?I think),
        -: 6763:	 * include it in the allocation length here but don't
        -: 6764:	 * bother taking account of other factors.
        -: 6765:	 */
      431: 6766:	for (t = s; *t; t++) {
      383: 6767:	    if (*t == '\\') {
    #####: 6768:		if (!t[1]) {
    #####: 6769:		    maxlen++;
    #####: 6770:		    break;
        -: 6771:		}
    #####: 6772:		if (t[1] == 'u' || t[1] == 'U')
    #####: 6773:		    maxlen += MB_CUR_MAX * 2;
        -: 6774:		else
    #####: 6775:		    maxlen += 2;
        -: 6776:		/* skip the backslash and the following character */
    #####: 6777:		t++;
        -: 6778:	    } else
      383: 6779:		maxlen++;
        -: 6780:	}
       48: 6781:	if (how & GETKEY_DOLLAR_QUOTE) {
        -: 6782:	    /*
        -: 6783:	     * We're going to unmetafy into a new string, but
        -: 6784:	     * to get a proper metafied input we're going to metafy
        -: 6785:	     * into an intermediate buffer.  This is necessary if we have
        -: 6786:	     * \u and \U's with multiple metafied bytes.  We can't
        -: 6787:	     * simply remetafy the entire string because there may
        -: 6788:	     * be tokens (indeed, we know there are lexical nulls floating
        -: 6789:	     * around), so we have to be aware character by character
        -: 6790:	     * what we are converting.
        -: 6791:	     *
        -: 6792:	     * In this case, buf is the final buffer (as usual),
        -: 6793:	     * but t points into a temporary buffer that just has
        -: 6794:	     * to be long enough to hold the result of one escape
        -: 6795:	     * code transformation.  We count this is a full multibyte
        -: 6796:	     * character (MB_CUR_MAX) with every character metafied
        -: 6797:	     * (*2) plus a little bit of fuzz (for e.g. the odd backslash).
        -: 6798:	     */
    #####: 6799:	    buf = tdest = zhalloc(maxlen);
    #####: 6800:	    t = tbuf = zhalloc(MB_CUR_MAX * 3 + 1);
        -: 6801:	} else {
       48: 6802:	    t = buf = zhalloc(maxlen);
        -: 6803:	}
        -: 6804:    }
      431: 6805:    for (; *s; s++) {
      383: 6806:	if (*s == '\\' && s[1]) {
        -: 6807:	    int miscadded;
    #####: 6808:	    if ((how & GETKEY_UPDATE_OFFSET) && s - sstart < *misc) {
    #####: 6809:		(*misc)--;
    #####: 6810:		miscadded = 1;
        -: 6811:	    } else
    #####: 6812:		miscadded = 0;
    #####: 6813:	    switch (*++s) {
    #####: 6814:	    case 'a':
        -: 6815:#ifdef __STDC__
    #####: 6816:		*t++ = '\a';
        -: 6817:#else
        -: 6818:		*t++ = '\07';
        -: 6819:#endif
    #####: 6820:		break;
    #####: 6821:	    case 'n':
    #####: 6822:		*t++ = '\n';
    #####: 6823:		break;
    #####: 6824:	    case 'b':
    #####: 6825:		*t++ = '\b';
    #####: 6826:		break;
    #####: 6827:	    case 't':
    #####: 6828:		*t++ = '\t';
    #####: 6829:		break;
    #####: 6830:	    case 'v':
    #####: 6831:		*t++ = '\v';
    #####: 6832:		break;
    #####: 6833:	    case 'f':
    #####: 6834:		*t++ = '\f';
    #####: 6835:		break;
    #####: 6836:	    case 'r':
    #####: 6837:		*t++ = '\r';
    #####: 6838:		break;
    #####: 6839:	    case 'E':
    #####: 6840:		if (!(how & GETKEY_EMACS)) {
    #####: 6841:		    *t++ = '\\', s--;
    #####: 6842:		    if (miscadded)
    #####: 6843:			(*misc)++;
    #####: 6844:		    continue;
        -: 6845:		}
        -: 6846:		/* FALL THROUGH */
        -: 6847:	    case 'e':
    #####: 6848:		*t++ = '\033';
    #####: 6849:		break;
    #####: 6850:	    case 'M':
        -: 6851:		/* HERE: GETKEY_UPDATE_OFFSET */
    #####: 6852:		if (how & GETKEY_EMACS) {
    #####: 6853:		    if (s[1] == '-')
    #####: 6854:			s++;
    #####: 6855:		    meta = 1 + control;	/* preserve the order of ^ and meta */
        -: 6856:		} else {
    #####: 6857:		    if (miscadded)
    #####: 6858:			(*misc)++;
    #####: 6859:		    *t++ = '\\', s--;
        -: 6860:		}
    #####: 6861:		continue;
    #####: 6862:	    case 'C':
        -: 6863:		/* HERE: GETKEY_UPDATE_OFFSET */
    #####: 6864:		if (how & GETKEY_EMACS) {
    #####: 6865:		    if (s[1] == '-')
    #####: 6866:			s++;
    #####: 6867:		    control = 1;
        -: 6868:		} else {
    #####: 6869:		    if (miscadded)
    #####: 6870:			(*misc)++;
    #####: 6871:		    *t++ = '\\', s--;
        -: 6872:		}
    #####: 6873:		continue;
    #####: 6874:	    case Meta:
    #####: 6875:		if (miscadded)
    #####: 6876:		    (*misc)++;
    #####: 6877:		*t++ = '\\', s--;
    #####: 6878:		break;
    #####: 6879:	    case '-':
    #####: 6880:		if (how & GETKEY_BACKSLASH_MINUS) {
    #####: 6881:		    *misc  = 1;
    #####: 6882:		    break;
        -: 6883:		}
    #####: 6884:		goto def;
    #####: 6885:	    case 'c':
    #####: 6886:		if (how & GETKEY_BACKSLASH_C) {
    #####: 6887:		    *misc = 1;
    #####: 6888:		    *t = '\0';
    #####: 6889:		    *len = t - buf;
    #####: 6890:		    return buf;
        -: 6891:		}
    #####: 6892:		goto def;
    #####: 6893:	    case 'U':
    #####: 6894:		if ((how & GETKEY_UPDATE_OFFSET) && s - sstart < *misc)
    #####: 6895:		    (*misc) -= 4;
        -: 6896:		/* FALLTHROUGH */
        -: 6897:	    case 'u':
    #####: 6898:		if ((how & GETKEY_UPDATE_OFFSET) && s - sstart < *misc) {
    #####: 6899:		    (*misc) -= 6; /* HERE don't really believe this */
        -: 6900:		    /*
        -: 6901:		     * We've now adjusted the offset for all the input
        -: 6902:		     * characters, so we need to add for each
        -: 6903:		     * byte of output below.
        -: 6904:		     */
        -: 6905:		}
    #####: 6906:	    	wval = 0;
    #####: 6907:		for (i=(*s == 'u' ? 4 : 8); i>0; i--) {
    #####: 6908:		    if (*++s && idigit(*s))
    #####: 6909:		        wval = wval * 16 + (*s - '0');
    #####: 6910:		    else if (*s && ((*s >= 'a' && *s <= 'f') ||
    #####: 6911:				    (*s >= 'A' && *s <= 'F')))
    #####: 6912:		        wval = wval * 16 + (*s & 0x1f) + 9;
        -: 6913:		    else {
    #####: 6914:		    	s--;
    #####: 6915:		        break;
        -: 6916:		    }
        -: 6917:		}
    #####: 6918:    	    	if (how & GETKEY_SINGLE_CHAR) {
    #####: 6919:		    *misc = wval;
    #####: 6920:		    return s+1;
        -: 6921:		}
        -: 6922:#if defined(HAVE_WCHAR_H) && defined(HAVE_WCTOMB) && defined(__STDC_ISO_10646__)
    #####: 6923:		count = wctomb(t, (wchar_t)wval);
    #####: 6924:		if (count == -1) {
    #####: 6925:		    zerr("character not in range");
    #####: 6926:		    CHARSET_FAILED();
        -: 6927:		}
    #####: 6928:		if ((how & GETKEY_UPDATE_OFFSET) && s - sstart < *misc)
    #####: 6929:		    (*misc) += count;
    #####: 6930:		t += count;
        -: 6931:# else
        -: 6932:#  if defined(HAVE_NL_LANGINFO) && defined(CODESET)
        -: 6933:		if (!strcmp(nl_langinfo(CODESET), "UTF-8")) {
        -: 6934:		    count = ucs4toutf8(t, wval);
        -: 6935:		    t += count;
        -: 6936:		    if ((how & GETKEY_UPDATE_OFFSET) && s - sstart < *misc)
        -: 6937:			(*misc) += count;
        -: 6938:		} else {
        -: 6939:#   ifdef HAVE_ICONV
        -: 6940:		    ICONV_CONST char *inptr = inbuf;
        -: 6941:		    const char *codesetstr = nl_langinfo(CODESET);
        -: 6942:    	    	    inbytes = 4;
        -: 6943:		    outbytes = 6;
        -: 6944:		    /* store value in big endian form */
        -: 6945:		    for (i=3;i>=0;i--) {
        -: 6946:			inbuf[i] = wval & 0xff;
        -: 6947:			wval >>= 8;
        -: 6948:		    }
        -: 6949:
        -: 6950:		    /*
        -: 6951:		     * If the code set isn't handled, we'd better
        -: 6952:		     * assume it's US-ASCII rather than just failing
        -: 6953:		     * hopelessly.  Solaris has a weird habit of
        -: 6954:		     * returning 646.  This is handled by the
        -: 6955:		     * native iconv(), but not by GNU iconv; what's
        -: 6956:		     * more, some versions of the native iconv don't
        -: 6957:		     * handle standard names like ASCII.
        -: 6958:		     *
        -: 6959:		     * This should only be a problem if there's a
        -: 6960:		     * mismatch between the NLS and the iconv in use,
        -: 6961:		     * which probably only means if libiconv is in use.
        -: 6962:		     * We checked at configure time if our libraries
        -: 6963:		     * pulled in _libiconv_version, which should be
        -: 6964:		     * a good test.
        -: 6965:		     *
        -: 6966:		     * It shouldn't ever be NULL, but while we're
        -: 6967:		     * being paranoid...
        -: 6968:		     */
        -: 6969:#ifdef ICONV_FROM_LIBICONV
        -: 6970:		    if (!codesetstr || !*codesetstr)
        -: 6971:			codesetstr = "US-ASCII";
        -: 6972:#endif
        -: 6973:    	    	    cd = iconv_open(codesetstr, "UCS-4BE");
        -: 6974:#ifdef ICONV_FROM_LIBICONV
        -: 6975:		    if (cd == (iconv_t)-1 &&  !strcmp(codesetstr, "646")) {
        -: 6976:			codesetstr = "US-ASCII";
        -: 6977:			cd = iconv_open(codesetstr, "UCS-4BE");
        -: 6978:		    }
        -: 6979:#endif
        -: 6980:		    if (cd == (iconv_t)-1) {
        -: 6981:			zerr("cannot do charset conversion (iconv failed)");
        -: 6982:			CHARSET_FAILED();
        -: 6983:		    }
        -: 6984:                    count = iconv(cd, &inptr, &inbytes, &t, &outbytes);
        -: 6985:		    iconv_close(cd);
        -: 6986:		    if (count == (size_t)-1) {
        -: 6987:                        zerr("character not in range");
        -: 6988:			CHARSET_FAILED();
        -: 6989:		    }
        -: 6990:		    if ((how & GETKEY_UPDATE_OFFSET) && s - sstart < *misc)
        -: 6991:			(*misc) += count;
        -: 6992:#   else
        -: 6993:                    zerr("cannot do charset conversion (iconv not available)");
        -: 6994:		    CHARSET_FAILED();
        -: 6995:#   endif
        -: 6996:		}
        -: 6997:#  else
        -: 6998:                zerr("cannot do charset conversion (NLS not supported)");
        -: 6999:		CHARSET_FAILED();
        -: 7000:#  endif
        -: 7001:# endif
    #####: 7002:		if (how & GETKEY_DOLLAR_QUOTE) {
        -: 7003:		    char *t2;
    #####: 7004:		    for (t2 = tbuf; t2 < t; t2++) {
    #####: 7005:			if (imeta(*t2)) {
    #####: 7006:			    *tdest++ = Meta;
    #####: 7007:			    *tdest++ = *t2 ^ 32;
        -: 7008:			} else
    #####: 7009:			    *tdest++ = *t2;
        -: 7010:		    }
        -: 7011:		    /* reset temporary buffer after handling */
    #####: 7012:		    t = tbuf;
        -: 7013:		}
    #####: 7014:		continue;
    #####: 7015:	    case '\'':
        -: 7016:	    case '\\':
    #####: 7017:		if (how & GETKEY_DOLLAR_QUOTE) {
        -: 7018:		    /*
        -: 7019:		     * Usually \' and \\ will have the initial
        -: 7020:		     * \ turned into a Bnull, however that's not
        -: 7021:		     * necessarily the case when called from
        -: 7022:		     * completion.
        -: 7023:		     */
    #####: 7024:		    *t++ = *s;
    #####: 7025:		    break;
        -: 7026:		}
        -: 7027:		/* FALLTHROUGH */
        -: 7028:	    default:
    #####: 7029:	    def:
        -: 7030:		/* HERE: GETKEY_UPDATE_OFFSET? */
    #####: 7031:		if ((idigit(*s) && *s < '8') || *s == 'x') {
    #####: 7032:		    if (!(how & GETKEY_OCTAL_ESC)) {
    #####: 7033:			if (*s == '0')
    #####: 7034:			    s++;
    #####: 7035:			else if (*s != 'x') {
    #####: 7036:			    *t++ = '\\', s--;
    #####: 7037:			    continue;
        -: 7038:			}
        -: 7039:		    }
    #####: 7040:		    if (s[1] && s[2] && s[3]) {
    #####: 7041:			svchar = s[3];
    #####: 7042:			s[3] = '\0';
    #####: 7043:			u = s;
        -: 7044:		    }
    #####: 7045:		    *t++ = zstrtol(s + (*s == 'x'), &s,
    #####: 7046:				   (*s == 'x') ? 16 : 8);
    #####: 7047:		    if ((how & GETKEY_PRINTF_PERCENT) && t[-1] == '%')
    #####: 7048:		        *t++ = '%';
    #####: 7049:		    if (svchar) {
    #####: 7050:			u[3] = svchar;
    #####: 7051:			svchar = '\0';
        -: 7052:		    }
    #####: 7053:		    s--;
        -: 7054:		} else {
    #####: 7055:		    if (!(how & GETKEY_EMACS) && *s != '\\') {
    #####: 7056:			if (miscadded)
    #####: 7057:			    (*misc)++;
    #####: 7058:			*t++ = '\\';
        -: 7059:		    }
    #####: 7060:		    *t++ = *s;
        -: 7061:		}
    #####: 7062:		break;
        -: 7063:	    }
      383: 7064:	} else if ((how & GETKEY_DOLLAR_QUOTE) && *s == Snull) {
        -: 7065:	    /* return length to following character */
    #####: 7066:	    *len = (s - sstart) + 1;
    #####: 7067:	    *tdest = '\0';
    #####: 7068:	    return buf;
      383: 7069:	} else if (*s == '^' && !control && (how & GETKEY_CTRL) && s[1]) {
    #####: 7070:	    control = 1;
    #####: 7071:	    continue;
        -: 7072:#ifdef MULTIBYTE_SUPPORT
      383: 7073:	} else if ((how & GETKEY_SINGLE_CHAR) &&
    #####: 7074:		   isset(MULTIBYTE) && STOUC(*s) > 127) {
        -: 7075:	    wint_t wc;
        -: 7076:	    int len;
    #####: 7077:	    len = mb_metacharlenconv(s, &wc);
    #####: 7078:	    if (wc != WEOF) {
    #####: 7079:		*misc = (int)wc;
    #####: 7080:		return s + len;
        -: 7081:	    }
        -: 7082:#endif
        -: 7083:
      383: 7084:	} else if (*s == Meta)
    #####: 7085:	    *t++ = *++s ^ 32;
        -: 7086:	else {
      383: 7087:	    if (itok(*s)) {
        -: 7088:		/*
        -: 7089:		 * We need to be quite careful here.  We haven't
        -: 7090:		 * necessarily got an input stream with all tokens
        -: 7091:		 * removed, so the majority of tokens need passing
        -: 7092:		 * through untouched and without Meta handling.
        -: 7093:		 * However, me may need to handle tokenized
        -: 7094:		 * backslashes.
        -: 7095:		 */
    #####: 7096:		if (meta || control) {
        -: 7097:		    /*
        -: 7098:		     * Presumably we should be using meta or control
        -: 7099:		     * on the character representing the token.
        -: 7100:		     *
        -: 7101:		     * Special case: $'\M-\\' where the token is a Bnull.
        -: 7102:		     * This time we dump the Bnull since we're
        -: 7103:		     * replacing the whole thing.  The lexer
        -: 7104:		     * doesn't know about the meta or control modifiers.
        -: 7105:		     */
    #####: 7106:		    if ((how & GETKEY_DOLLAR_QUOTE) && *s == Bnull)
    #####: 7107:			*t++ = *++s;
        -: 7108:		    else
    #####: 7109:			*t++ = ztokens[*s - Pound];
    #####: 7110:		} else if (how & GETKEY_DOLLAR_QUOTE) {
        -: 7111:		    /*
        -: 7112:		     * We don't want to metafy this, it's a real
        -: 7113:		     * token.
        -: 7114:		     */
    #####: 7115:		    *tdest++ = *s;
    #####: 7116:		    if (*s == Bnull) {
        -: 7117:			/*
        -: 7118:			 * Bnull is a backslash which quotes a couple
        -: 7119:			 * of special characters that always appear
        -: 7120:			 * literally next.  See strquote handling
        -: 7121:			 * in gettokstr() in lex.c.  We need
        -: 7122:			 * to retain the Bnull (as above) so that quote
        -: 7123:			 * handling in completion can tell where the
        -: 7124:			 * backslash was.
        -: 7125:			 */
    #####: 7126:			*tdest++ = *++s;
        -: 7127:		    }
        -: 7128:		    /* reset temporary buffer, now handled */
    #####: 7129:		    t = tbuf;
    #####: 7130:		    continue;
        -: 7131:		} else
    #####: 7132:		    *t++ = *s;
        -: 7133:	    } else
      383: 7134:		*t++ = *s;
        -: 7135:	}
      383: 7136:	if (meta == 2) {
    #####: 7137:	    t[-1] |= 0x80;
    #####: 7138:	    meta = 0;
        -: 7139:	}
      383: 7140:	if (control) {
    #####: 7141:	    if (t[-1] == '?')
    #####: 7142:		t[-1] = 0x7f;
        -: 7143:	    else
    #####: 7144:		t[-1] &= 0x9f;
    #####: 7145:	    control = 0;
        -: 7146:	}
      383: 7147:	if (meta) {
    #####: 7148:	    t[-1] |= 0x80;
    #####: 7149:	    meta = 0;
        -: 7150:	}
      383: 7151:	if (how & GETKEY_DOLLAR_QUOTE) {
        -: 7152:	    char *t2;
    #####: 7153:	    for (t2 = tbuf; t2 < t; t2++) {
        -: 7154:		/*
        -: 7155:		 * In POSIX mode, an embedded NULL is discarded and
        -: 7156:		 * terminates processing.  It just does, that's why.
        -: 7157:		 */
    #####: 7158:		if (isset(POSIXSTRINGS)) {
    #####: 7159:		    if (*t2 == '\0')
    #####: 7160:			ignoring = 1;
    #####: 7161:		    if (ignoring)
    #####: 7162:			break;
        -: 7163:		}
    #####: 7164:		if (imeta(*t2)) {
    #####: 7165:		    *tdest++ = Meta;
    #####: 7166:		    *tdest++ = *t2 ^ 32;
        -: 7167:		} else {
    #####: 7168:		    *tdest++ = *t2;
        -: 7169:		}
        -: 7170:	    }
        -: 7171:	    /*
        -: 7172:	     * Reset use of temporary buffer.
        -: 7173:	     */
    #####: 7174:	    t = tbuf;
        -: 7175:	}
      383: 7176:	if ((how & GETKEY_SINGLE_CHAR) && t != tmp) {
    #####: 7177:	    *misc = STOUC(tmp[0]);
    #####: 7178:	    return s + 1;
        -: 7179:	}
        -: 7180:    }
        -: 7181:    /*
        -: 7182:     * When called from completion, where we use GETKEY_UPDATE_OFFSET to
        -: 7183:     * update the index into the metafied editor line, we don't necessarily
        -: 7184:     * have the end of a $'...' quotation, else we should do.
        -: 7185:     */
        -: 7186:    DPUTS((how & (GETKEY_DOLLAR_QUOTE|GETKEY_UPDATE_OFFSET)) ==
        -: 7187:	  GETKEY_DOLLAR_QUOTE, "BUG: unterminated $' substitution");
        -: 7188:
       48: 7189:    if (how & GETKEY_SINGLE_CHAR) {
        -: 7190:	/* couldn't find a character */
    #####: 7191:	*misc = 0;
    #####: 7192:	return NULL;
        -: 7193:    }
       48: 7194:    if (how & GETKEY_DOLLAR_QUOTE) {
    #####: 7195:	*tdest = '\0';
    #####: 7196:	*len = tdest - buf;
        -: 7197:    }
        -: 7198:    else {
       48: 7199:	*t = '\0';
       48: 7200:	*len = t - buf;
        -: 7201:    }
       48: 7202:    return buf;
        -: 7203:}
        -: 7204:
        -: 7205:/* Return non-zero if s is a prefix of t. */
        -: 7206:
        -: 7207:/**/
        -: 7208:mod_export int
    #####: 7209:strpfx(const char *s, const char *t)
        -: 7210:{
    #####: 7211:    while (*s && *s == *t)
    #####: 7212:	s++, t++;
    #####: 7213:    return !*s;
        -: 7214:}
        -: 7215:
        -: 7216:/* Return non-zero if s is a suffix of t. */
        -: 7217:
        -: 7218:/**/
        -: 7219:mod_export int
        2: 7220:strsfx(char *s, char *t)
        -: 7221:{
        2: 7222:    int ls = strlen(s), lt = strlen(t);
        -: 7223:
        2: 7224:    if (ls <= lt)
        2: 7225:	return !strcmp(t + lt - ls, s);
    #####: 7226:    return 0;
        -: 7227:}
        -: 7228:
        -: 7229:/**/
        -: 7230:static int
    #####: 7231:upchdir(int n)
        -: 7232:{
        -: 7233:    char buf[PATH_MAX+1];
        -: 7234:    char *s;
    #####: 7235:    int err = -1;
        -: 7236:
    #####: 7237:    while (n > 0) {
    #####: 7238:	for (s = buf; s < buf + PATH_MAX - 4 && n--; )
    #####: 7239:	    *s++ = '.', *s++ = '.', *s++ = '/';
    #####: 7240:	s[-1] = '\0';
    #####: 7241:	if (chdir(buf))
    #####: 7242:	    return err;
    #####: 7243:	err = -2;
        -: 7244:    }
    #####: 7245:    return 0;
        -: 7246:}
        -: 7247:
        -: 7248:/*
        -: 7249: * Initialize a "struct dirsav".
        -: 7250: * The structure will be set to the directory we want to save
        -: 7251: * the first time we change to a different directory.
        -: 7252: */
        -: 7253:
        -: 7254:/**/
        -: 7255:mod_export void
       40: 7256:init_dirsav(Dirsav d)
        -: 7257:{
       40: 7258:    d->ino = d->dev = 0;
       40: 7259:    d->dirname = NULL;
       40: 7260:    d->dirfd = d->level = -1;
       40: 7261:}
        -: 7262:
        -: 7263:/*
        -: 7264: * Change directory, without following symlinks.  Returns 0 on success, -1
        -: 7265: * on failure.  Sets errno to ENOTDIR if any symlinks are encountered.  If
        -: 7266: * fchdir() fails, or the current directory is unreadable, we might end up
        -: 7267: * in an unwanted directory in case of failure.
        -: 7268: *
        -: 7269: * path is an unmetafied but null-terminated string, as needed by system
        -: 7270: * calls.
        -: 7271: */
        -: 7272:
        -: 7273:/**/
        -: 7274:mod_export int
        1: 7275:lchdir(char const *path, struct dirsav *d, int hard)
        -: 7276:{
        -: 7277:    char const *pptr;
        -: 7278:    int level;
        -: 7279:    struct stat st1;
        -: 7280:    struct dirsav ds;
        -: 7281:#ifdef HAVE_LSTAT
        -: 7282:    char buf[PATH_MAX + 1], *ptr;
        -: 7283:    int err;
        -: 7284:    struct stat st2;
        -: 7285:#endif
        -: 7286:#ifdef HAVE_FCHDIR
        1: 7287:    int close_dir = 0;
        -: 7288:#endif
        -: 7289:
        1: 7290:    if (!d) {
        1: 7291:	init_dirsav(&ds);
        1: 7292:	d = &ds;
        -: 7293:    }
        -: 7294:#ifdef HAVE_LSTAT
        1: 7295:    if ((*path == '/' || !hard) &&
        1: 7296:	(d != &ds || hard)){
        -: 7297:#else
        -: 7298:    if (*path == '/') {
        -: 7299:#endif
    #####: 7300:	level = -1;
        -: 7301:#ifndef HAVE_FCHDIR
        -: 7302:	if (!d->dirname)
        -: 7303:	    zgetdir(d);
        -: 7304:#endif
        -: 7305:    } else {
        1: 7306:	level = 0;
        1: 7307:	if (!d->dev && !d->ino) {
        1: 7308:	    stat(".", &st1);
        1: 7309:	    d->dev = st1.st_dev;
        1: 7310:	    d->ino = st1.st_ino;
        -: 7311:	}
        -: 7312:    }
        -: 7313:
        -: 7314:#ifdef HAVE_LSTAT
        1: 7315:    if (!hard)
        -: 7316:#endif
        -: 7317:    {
        1: 7318:	if (d != &ds) {
    #####: 7319:	    for (pptr = path; *pptr; level++) {
    #####: 7320:		while (*pptr && *pptr++ != '/');
    #####: 7321:		while (*pptr == '/')
    #####: 7322:		    pptr++;
        -: 7323:	    }
    #####: 7324:	    d->level = level;
        -: 7325:	}
        1: 7326:	return zchdir((char *) path);
        -: 7327:    }
        -: 7328:
        -: 7329:#ifdef HAVE_LSTAT
        -: 7330:#ifdef HAVE_FCHDIR
    #####: 7331:    if (d->dirfd < 0) {
    #####: 7332:	close_dir = 1;
    #####: 7333:        if ((d->dirfd = open(".", O_RDONLY | O_NOCTTY)) < 0 &&
    #####: 7334:	    zgetdir(d) && *d->dirname != '/')
    #####: 7335:	    d->dirfd = open("..", O_RDONLY | O_NOCTTY);
        -: 7336:    }
        -: 7337:#endif
    #####: 7338:    if (*path == '/')
    #####: 7339:	if (chdir("/") < 0)
    #####: 7340:	    zwarn("failed to chdir(/): %e", errno);
        -: 7341:    for(;;) {
    #####: 7342:	while(*path == '/')
    #####: 7343:	    path++;
    #####: 7344:	if(!*path) {
    #####: 7345:	    if (d == &ds)
    #####: 7346:		zsfree(ds.dirname);
        -: 7347:	    else
    #####: 7348:		d->level = level;
        -: 7349:#ifdef HAVE_FCHDIR
    #####: 7350:	    if (d->dirfd >=0 && close_dir) {
    #####: 7351:		close(d->dirfd);
    #####: 7352:		d->dirfd = -1;
        -: 7353:	    }
        -: 7354:#endif
    #####: 7355:	    return 0;
        -: 7356:	}
    #####: 7357:	for(pptr = path; *++pptr && *pptr != '/'; ) ;
    #####: 7358:	if(pptr - path > PATH_MAX) {
    #####: 7359:	    err = ENAMETOOLONG;
    #####: 7360:	    break;
        -: 7361:	}
    #####: 7362:	for(ptr = buf; path != pptr; )
    #####: 7363:	    *ptr++ = *path++;
    #####: 7364:	*ptr = 0;
    #####: 7365:	if(lstat(buf, &st1)) {
    #####: 7366:	    err = errno;
    #####: 7367:	    break;
        -: 7368:	}
    #####: 7369:	if(!S_ISDIR(st1.st_mode)) {
    #####: 7370:	    err = ENOTDIR;
    #####: 7371:	    break;
        -: 7372:	}
    #####: 7373:	if(chdir(buf)) {
    #####: 7374:	    err = errno;
    #####: 7375:	    break;
        -: 7376:	}
    #####: 7377:	if (level >= 0)
    #####: 7378:	    level++;
    #####: 7379:	if(lstat(".", &st2)) {
    #####: 7380:	    err = errno;
    #####: 7381:	    break;
        -: 7382:	}
    #####: 7383:	if(st1.st_dev != st2.st_dev || st1.st_ino != st2.st_ino) {
    #####: 7384:	    err = ENOTDIR;
    #####: 7385:	    break;
        -: 7386:	}
        -: 7387:    }
    #####: 7388:    if (restoredir(d)) {
    #####: 7389:	int restoreerr = errno;
        -: 7390:	int i;
        -: 7391:	/*
        -: 7392:	 * Failed to restore the directory.
        -: 7393:	 * Just be definite, cd to root and report the result.
        -: 7394:	 */
    #####: 7395:	for (i = 0; i < 2; i++) {
        -: 7396:	    const char *cdest;
    #####: 7397:	    if (i)
    #####: 7398:		cdest = "/";
        -: 7399:	    else {
    #####: 7400:		if (!home)
    #####: 7401:		    continue;
    #####: 7402:		cdest = home;
        -: 7403:	    }
    #####: 7404:	    zsfree(pwd);
    #####: 7405:	    pwd = ztrdup(cdest);
    #####: 7406:	    if (chdir(pwd) == 0)
    #####: 7407:		break;
        -: 7408:	}
    #####: 7409:	if (i == 2)
    #####: 7410:	    zerr("lost current directory, failed to cd to /: %e", errno);
        -: 7411:	else
    #####: 7412:	    zerr("lost current directory: %e: changed to `%s'", restoreerr,
        -: 7413:		pwd);
    #####: 7414:	if (d == &ds)
    #####: 7415:	    zsfree(ds.dirname);
        -: 7416:#ifdef HAVE_FCHDIR
    #####: 7417:	if (d->dirfd >=0 && close_dir) {
    #####: 7418:	    close(d->dirfd);
    #####: 7419:	    d->dirfd = -1;
        -: 7420:	}
        -: 7421:#endif
    #####: 7422:	errno = err;
    #####: 7423:	return -2;
        -: 7424:    }
    #####: 7425:    if (d == &ds)
    #####: 7426:	zsfree(ds.dirname);
        -: 7427:#ifdef HAVE_FCHDIR
    #####: 7428:    if (d->dirfd >=0 && close_dir) {
    #####: 7429:	close(d->dirfd);
    #####: 7430:	d->dirfd = -1;
        -: 7431:    }
        -: 7432:#endif
    #####: 7433:    errno = err;
    #####: 7434:    return -1;
        -: 7435:#endif /* HAVE_LSTAT */
        -: 7436:}
        -: 7437:
        -: 7438:/**/
        -: 7439:mod_export int
    #####: 7440:restoredir(struct dirsav *d)
        -: 7441:{
    #####: 7442:    int err = 0;
        -: 7443:    struct stat sbuf;
        -: 7444:
    #####: 7445:    if (d->dirname && *d->dirname == '/')
    #####: 7446:	return chdir(d->dirname);
        -: 7447:#ifdef HAVE_FCHDIR
    #####: 7448:    if (d->dirfd >= 0) {
    #####: 7449:	if (!fchdir(d->dirfd)) {
    #####: 7450:	    if (!d->dirname) {
    #####: 7451:		return 0;
    #####: 7452:	    } else if (chdir(d->dirname)) {
    #####: 7453:		close(d->dirfd);
    #####: 7454:		d->dirfd = -1;
    #####: 7455:		err = -2;
        -: 7456:	    }
        -: 7457:	} else {
    #####: 7458:	    close(d->dirfd);
    #####: 7459:	    d->dirfd = err = -1;
        -: 7460:	}
        -: 7461:    } else
        -: 7462:#endif
    #####: 7463:    if (d->level > 0)
    #####: 7464:	err = upchdir(d->level);
    #####: 7465:    else if (d->level < 0)
    #####: 7466:	err = -1;
    #####: 7467:    if (d->dev || d->ino) {
    #####: 7468:	stat(".", &sbuf);
    #####: 7469:	if (sbuf.st_ino != d->ino || sbuf.st_dev != d->dev)
    #####: 7470:	    err = -2;
        -: 7471:    }
    #####: 7472:    return err;
        -: 7473:}
        -: 7474:
        -: 7475:
        -: 7476:/* Check whether the shell is running with privileges in effect.  *
        -: 7477: * This is the case if EITHER the euid is zero, OR (if the system *
        -: 7478: * supports POSIX.1e (POSIX.6) capability sets) the process'      *
        -: 7479: * Effective or Inheritable capability sets are non-empty.        */
        -: 7480:
        -: 7481:/**/
        -: 7482:int
    #####: 7483:privasserted(void)
        -: 7484:{
    #####: 7485:    if(!geteuid())
    #####: 7486:	return 1;
        -: 7487:#ifdef HAVE_CAP_GET_PROC
        -: 7488:    {
        -: 7489:	cap_t caps = cap_get_proc();
        -: 7490:	if(caps) {
        -: 7491:	    /* POSIX doesn't define a way to test whether a capability set *
        -: 7492:	     * is empty or not.  Typical.  I hope this is conforming...    */
        -: 7493:	    cap_flag_value_t val;
        -: 7494:	    cap_value_t n;
        -: 7495:	    for(n = 0; !cap_get_flag(caps, n, CAP_EFFECTIVE, &val); n++)
        -: 7496:		if(val) {
        -: 7497:		    cap_free(caps);
        -: 7498:		    return 1;
        -: 7499:		}
        -: 7500:	}
        -: 7501:	cap_free(caps);
        -: 7502:    }
        -: 7503:#endif /* HAVE_CAP_GET_PROC */
    #####: 7504:    return 0;
        -: 7505:}
        -: 7506:
        -: 7507:/**/
        -: 7508:mod_export int
    #####: 7509:mode_to_octal(mode_t mode)
        -: 7510:{
    #####: 7511:    int m = 0;
        -: 7512:
    #####: 7513:    if(mode & S_ISUID)
    #####: 7514:	m |= 04000;
    #####: 7515:    if(mode & S_ISGID)
    #####: 7516:	m |= 02000;
    #####: 7517:    if(mode & S_ISVTX)
    #####: 7518:	m |= 01000;
    #####: 7519:    if(mode & S_IRUSR)
    #####: 7520:	m |= 00400;
    #####: 7521:    if(mode & S_IWUSR)
    #####: 7522:	m |= 00200;
    #####: 7523:    if(mode & S_IXUSR)
    #####: 7524:	m |= 00100;
    #####: 7525:    if(mode & S_IRGRP)
    #####: 7526:	m |= 00040;
    #####: 7527:    if(mode & S_IWGRP)
    #####: 7528:	m |= 00020;
    #####: 7529:    if(mode & S_IXGRP)
    #####: 7530:	m |= 00010;
    #####: 7531:    if(mode & S_IROTH)
    #####: 7532:	m |= 00004;
    #####: 7533:    if(mode & S_IWOTH)
    #####: 7534:	m |= 00002;
    #####: 7535:    if(mode & S_IXOTH)
    #####: 7536:	m |= 00001;
    #####: 7537:    return m;
        -: 7538:}
        -: 7539:
        -: 7540:#ifdef MAILDIR_SUPPORT
        -: 7541:/*
        -: 7542: *     Stat a file. If it's a maildir, check all messages
        -: 7543: *     in the maildir and present the grand total as a file.
        -: 7544: *     The fields in the 'struct stat' are from the mail directory.
        -: 7545: *     The following fields are emulated:
        -: 7546: *
        -: 7547: *     st_nlink        always 1
        -: 7548: *     st_size         total number of bytes in all files
        -: 7549: *     st_blocks       total number of messages
        -: 7550: *     st_atime        access time of newest file in maildir
        -: 7551: *     st_mtime        modify time of newest file in maildir
        -: 7552: *     st_mode         S_IFDIR changed to S_IFREG
        -: 7553: *
        -: 7554: *     This is good enough for most mail-checking applications.
        -: 7555: */
        -: 7556:
        -: 7557:/**/
        -: 7558:int
        -: 7559:mailstat(char *path, struct stat *st)
        -: 7560:{
        -: 7561:       DIR                     *dd;
        -: 7562:       struct                  dirent *fn;
        -: 7563:       struct stat             st_ret, st_tmp;
        -: 7564:       static struct stat      st_ret_last;
        -: 7565:       char                    *dir, *file = 0;
        -: 7566:       int                     i;
        -: 7567:       time_t                  atime = 0, mtime = 0;
        -: 7568:       size_t                  plen = strlen(path), dlen;
        -: 7569:
        -: 7570:       /* First see if it's a directory. */
        -: 7571:       if ((i = stat(path, st)) != 0 || !S_ISDIR(st->st_mode))
        -: 7572:               return i;
        -: 7573:
        -: 7574:       st_ret = *st;
        -: 7575:       st_ret.st_nlink = 1;
        -: 7576:       st_ret.st_size  = 0;
        -: 7577:       st_ret.st_blocks  = 0;
        -: 7578:       st_ret.st_mode  &= ~S_IFDIR;
        -: 7579:       st_ret.st_mode  |= S_IFREG;
        -: 7580:
        -: 7581:       /* See if cur/ is present */
        -: 7582:       dir = appstr(ztrdup(path), "/cur");
        -: 7583:       if (stat(dir, &st_tmp) || !S_ISDIR(st_tmp.st_mode)) {
        -: 7584:	   zsfree(dir);
        -: 7585:	   return 0;
        -: 7586:       }
        -: 7587:       st_ret.st_atime = st_tmp.st_atime;
        -: 7588:
        -: 7589:       /* See if tmp/ is present */
        -: 7590:       dir[plen] = 0;
        -: 7591:       dir = appstr(dir, "/tmp");
        -: 7592:       if (stat(dir, &st_tmp) || !S_ISDIR(st_tmp.st_mode)) {
        -: 7593:	   zsfree(dir);
        -: 7594:	   return 0;
        -: 7595:       }
        -: 7596:       st_ret.st_mtime = st_tmp.st_mtime;
        -: 7597:
        -: 7598:       /* And new/ */
        -: 7599:       dir[plen] = 0;
        -: 7600:       dir = appstr(dir, "/new");
        -: 7601:       if (stat(dir, &st_tmp) || !S_ISDIR(st_tmp.st_mode)) {
        -: 7602:	   zsfree(dir);
        -: 7603:	   return 0;
        -: 7604:       }
        -: 7605:       st_ret.st_mtime = st_tmp.st_mtime;
        -: 7606:
        -: 7607:#if THERE_IS_EXACTLY_ONE_MAILDIR_IN_MAILPATH
        -: 7608:       {
        -: 7609:       static struct stat      st_new_last;
        -: 7610:       /* Optimization - if new/ didn't change, nothing else did. */
        -: 7611:       if (st_tmp.st_dev == st_new_last.st_dev &&
        -: 7612:           st_tmp.st_ino == st_new_last.st_ino &&
        -: 7613:           st_tmp.st_atime == st_new_last.st_atime &&
        -: 7614:           st_tmp.st_mtime == st_new_last.st_mtime) {
        -: 7615:	   *st = st_ret_last;
        -: 7616:	   zsfree(dir);
        -: 7617:	   return 0;
        -: 7618:       }
        -: 7619:       st_new_last = st_tmp;
        -: 7620:       }
        -: 7621:#endif
        -: 7622:
        -: 7623:       /* Loop over new/ and cur/ */
        -: 7624:       for (i = 0; i < 2; i++) {
        -: 7625:	   dir[plen] = 0;
        -: 7626:	   dir = appstr(dir, i ? "/cur" : "/new");
        -: 7627:	   if ((dd = opendir(dir)) == NULL) {
        -: 7628:	       zsfree(file);
        -: 7629:	       zsfree(dir);
        -: 7630:	       return 0;
        -: 7631:	   }
        -: 7632:	   dlen = strlen(dir) + 1; /* include the "/" */
        -: 7633:	   while ((fn = readdir(dd)) != NULL) {
        -: 7634:	       if (fn->d_name[0] == '.')
        -: 7635:		   continue;
        -: 7636:	       if (file) {
        -: 7637:		   file[dlen] = 0;
        -: 7638:		   file = appstr(file, fn->d_name);
        -: 7639:	       } else {
        -: 7640:		   file = tricat(dir, "/", fn->d_name);
        -: 7641:	       }
        -: 7642:	       if (stat(file, &st_tmp) != 0)
        -: 7643:		   continue;
        -: 7644:	       st_ret.st_size += st_tmp.st_size;
        -: 7645:	       st_ret.st_blocks++;
        -: 7646:	       if (st_tmp.st_atime != st_tmp.st_mtime &&
        -: 7647:		   st_tmp.st_atime > atime)
        -: 7648:		   atime = st_tmp.st_atime;
        -: 7649:	       if (st_tmp.st_mtime > mtime)
        -: 7650:		   mtime = st_tmp.st_mtime;
        -: 7651:	   }
        -: 7652:	   closedir(dd);
        -: 7653:       }
        -: 7654:       zsfree(file);
        -: 7655:       zsfree(dir);
        -: 7656:
        -: 7657:       if (atime) st_ret.st_atime = atime;
        -: 7658:       if (mtime) st_ret.st_mtime = mtime;
        -: 7659:
        -: 7660:       *st = st_ret_last = st_ret;
        -: 7661:       return 0;
        -: 7662:}
        -: 7663:#endif
