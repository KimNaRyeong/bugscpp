        -:    0:Source:exec.c
        -:    0:Graph:/home/workspace/Src/exec.gcno
        -:    0:Data:/home/workspace/Src/exec.gcda
        -:    0:Runs:6
        -:    0:Programs:1
        -:    1:/*
        -:    2: * exec.c - command execution
        -:    3: *
        -:    4: * This file is part of zsh, the Z shell.
        -:    5: *
        -:    6: * Copyright (c) 1992-1997 Paul Falstad
        -:    7: * All rights reserved.
        -:    8: *
        -:    9: * Permission is hereby granted, without written agreement and without
        -:   10: * license or royalty fees, to use, copy, modify, and distribute this
        -:   11: * software and to distribute modified versions of this software for any
        -:   12: * purpose, provided that the above copyright notice and the following
        -:   13: * two paragraphs appear in all copies of this software.
        -:   14: *
        -:   15: * In no event shall Paul Falstad or the Zsh Development Group be liable
        -:   16: * to any party for direct, indirect, special, incidental, or consequential
        -:   17: * damages arising out of the use of this software and its documentation,
        -:   18: * even if Paul Falstad and the Zsh Development Group have been advised of
        -:   19: * the possibility of such damage.
        -:   20: *
        -:   21: * Paul Falstad and the Zsh Development Group specifically disclaim any
        -:   22: * warranties, including, but not limited to, the implied warranties of
        -:   23: * merchantability and fitness for a particular purpose.  The software
        -:   24: * provided hereunder is on an "as is" basis, and Paul Falstad and the
        -:   25: * Zsh Development Group have no obligation to provide maintenance,
        -:   26: * support, updates, enhancements, or modifications.
        -:   27: *
        -:   28: */
        -:   29:
        -:   30:#include "zsh.mdh"
        -:   31:#include "exec.pro"
        -:   32:
        -:   33:/* Flags for last argument of addvars */
        -:   34:
        -:   35:enum {
        -:   36:    /* Export the variable for "VAR=val cmd ..." */
        -:   37:    ADDVAR_EXPORT =   1 << 0,
        -:   38:    /* Apply restrictions for variable */
        -:   39:    ADDVAR_RESTRICT = 1 << 1,
        -:   40:    /* Variable list is being restored later */
        -:   41:    ADDVAR_RESTORE =  1 << 2
        -:   42:};
        -:   43:
        -:   44:/* Structure in which to save values around shell function call */
        -:   45:
        -:   46:struct funcsave {
        -:   47:    char opts[OPT_SIZE];
        -:   48:    char *argv0;
        -:   49:    int zoptind, lastval, optcind, numpipestats;
        -:   50:    int *pipestats;
        -:   51:    char *scriptname;
        -:   52:    int breaks, contflag, loops, emulation, noerrexit, oflags, restore_sticky;
        -:   53:    Emulation_options sticky;
        -:   54:    struct funcstack fstack;
        -:   55:};
        -:   56:typedef struct funcsave *Funcsave;
        -:   57:
        -:   58:/*
        -:   59: * used to suppress ERREXIT and trapping of SIGZERR, SIGEXIT.
        -:   60: * Bits from noerrexit_bits.
        -:   61: */
        -:   62:
        -:   63:/**/
        -:   64:int noerrexit;
        -:   65:
        -:   66:/* used to suppress ERREXIT or ERRRETURN for one occurrence: 0 or 1 */
        -:   67:
        -:   68:/**/
        -:   69:int this_noerrexit;
        -:   70:
        -:   71:/*
        -:   72: * noerrs = 1: suppress error messages
        -:   73: * noerrs = 2: don't set errflag on parse error, either
        -:   74: */
        -:   75:
        -:   76:/**/
        -:   77:mod_export int noerrs;
        -:   78:
        -:   79:/* do not save history on exec and exit */
        -:   80:
        -:   81:/**/
        -:   82:int nohistsave;
        -:   83:
        -:   84:/* error flag: bits from enum errflag_bits */
        -:   85:
        -:   86:/**/
        -:   87:mod_export volatile int errflag;
        -:   88:
        -:   89:/*
        -:   90: * State of trap return value.  Value is from enum trap_state.
        -:   91: */
        -:   92:
        -:   93:/**/
        -:   94:int trap_state;
        -:   95:
        -:   96:/*
        -:   97: * Value associated with return from a trap.
        -:   98: * This is only active if we are inside a trap, else its value
        -:   99: * is irrelevant.  It is initialised to -1 for a function trap and
        -:  100: * -2 for a non-function trap and if negative is decremented as
        -:  101: * we go deeper into functions and incremented as we come back up.
        -:  102: * The value is used to decide if an explicit "return" should cause
        -:  103: * a return from the caller of the trap; it does this by setting
        -:  104: * trap_return to a status (i.e. a non-negative value).
        -:  105: *
        -:  106: * In summary, trap_return is
        -:  107: * - zero unless we are in a trap
        -:  108: * - negative in a trap unless it has triggered.  Code uses this
        -:  109: *   to detect an active trap.
        -:  110: * - non-negative in a trap once it was triggered.  It should remain
        -:  111: *   non-negative until restored after execution of the trap.
        -:  112: */
        -:  113:
        -:  114:/**/
        -:  115:int trap_return;
        -:  116:
        -:  117:/* != 0 if this is a subshell */
        -:  118:
        -:  119:/**/
        -:  120:int subsh;
        -:  121:
        -:  122:/* != 0 if we have a return pending */
        -:  123:
        -:  124:/**/
        -:  125:mod_export volatile int retflag;
        -:  126:
        -:  127:/**/
        -:  128:long lastval2;
        -:  129:
        -:  130:/* The table of file descriptors.  A table element is zero if the  *
        -:  131: * corresponding fd is not used by the shell.  It is greater than  *
        -:  132: * 1 if the fd is used by a <(...) or >(...) substitution and 1 if *
        -:  133: * it is an internal file descriptor which must be closed before   *
        -:  134: * executing an external command.  The first ten elements of the   *
        -:  135: * table is not used.  A table element is set by movefd and cleard *
        -:  136: * by zclose.                                                      */
        -:  137:
        -:  138:/**/
        -:  139:mod_export unsigned char *fdtable;
        -:  140:
        -:  141:/* The allocated size of fdtable */
        -:  142:
        -:  143:/**/
        -:  144:int fdtable_size;
        -:  145:
        -:  146:/* The highest fd that marked with nonzero in fdtable */
        -:  147:
        -:  148:/**/
        -:  149:mod_export int max_zsh_fd;
        -:  150:
        -:  151:/* input fd from the coprocess */
        -:  152:
        -:  153:/**/
        -:  154:mod_export int coprocin;
        -:  155:
        -:  156:/* output fd from the coprocess */
        -:  157:
        -:  158:/**/
        -:  159:mod_export int coprocout;
        -:  160:
        -:  161:/* count of file locks recorded in fdtable */
        -:  162:
        -:  163:/**/
        -:  164:int fdtable_flocks;
        -:  165:
        -:  166:
        -:  167:/* != 0 if the line editor is active */
        -:  168:
        -:  169:/**/
        -:  170:mod_export int zleactive;
        -:  171:
        -:  172:/* pid of process undergoing 'process substitution' */
        -:  173:
        -:  174:/**/
        -:  175:pid_t cmdoutpid;
        -:  176:
        -:  177:/* pid of last process started by <(...),  >(...) */
        -:  178:
        -:  179:/**/
        -:  180:mod_export pid_t procsubstpid;
        -:  181:
        -:  182:/* exit status of process undergoing 'process substitution' */
        -:  183:
        -:  184:/**/
        -:  185:int cmdoutval;
        -:  186:
        -:  187:/*
        -:  188: * This is set by an exiting $(...) substitution to indicate we need
        -:  189: * to retain the status.  We initialize it to zero if we think we need
        -:  190: * to reset the status for a command.
        -:  191: */
        -:  192:
        -:  193:/**/
        -:  194:int use_cmdoutval;
        -:  195:
        -:  196:/* The context in which a shell function is called, see SFC_* in zsh.h. */
        -:  197:
        -:  198:/**/
        -:  199:mod_export int sfcontext;
        -:  200:
        -:  201:/* Stack to save some variables before executing a signal handler function */
        -:  202:
        -:  203:/**/
        -:  204:struct execstack *exstack;
        -:  205:
        -:  206:/* Stack with names of function calls, 'source' calls, and 'eval' calls
        -:  207: * currently active. */
        -:  208:
        -:  209:/**/
        -:  210:mod_export Funcstack funcstack;
        -:  211:
        -:  212:#define execerr()				\
        -:  213:    do {					\
        -:  214:	if (!forked) {				\
        -:  215:	    redir_err = lastval = 1;		\
        -:  216:	    goto done;				\
        -:  217:	} else {				\
        -:  218:	    _exit(1);				\
        -:  219:	}					\
        -:  220:    } while (0)
        -:  221:
        -:  222:static int doneps4;
        -:  223:static char *STTYval;
        -:  224:static char *blank_env[] = { NULL };
        -:  225:
        -:  226:/* Execution functions. */
        -:  227:
        -:  228:static int (*execfuncs[WC_COUNT-WC_CURSH]) _((Estate, int)) = {
        -:  229:    execcursh, exectime, NULL /* execfuncdef handled specially */,
        -:  230:    execfor, execselect,
        -:  231:    execwhile, execrepeat, execcase, execif, execcond,
        -:  232:    execarith, execautofn, exectry
        -:  233:};
        -:  234:
        -:  235:/* structure for command builtin for when it is used with -v or -V */
        -:  236:static struct builtin commandbn =
        -:  237:    BUILTIN("command", 0, bin_whence, 0, -1, BIN_COMMAND, "pvV", NULL);
        -:  238:
        -:  239:/* parse string into a list */
        -:  240:
        -:  241:/**/
        -:  242:mod_export Eprog
       24:  243:parse_string(char *s, int reset_lineno)
        -:  244:{
        -:  245:    Eprog p;
        -:  246:    zlong oldlineno;
        -:  247:
       24:  248:    zcontext_save();
       24:  249:    inpush(s, INP_LINENO, NULL);
       24:  250:    strinbeg(0);
       24:  251:    oldlineno = lineno;
       24:  252:    if (reset_lineno)
        5:  253:	lineno = 1;
       24:  254:    p = parse_list();
       24:  255:    lineno = oldlineno;
       24:  256:    if (tok == LEXERR && !lastval)
    #####:  257:	lastval = 1;
       24:  258:    strinend();
       24:  259:    inpop();
       24:  260:    zcontext_restore();
       24:  261:    return p;
        -:  262:}
        -:  263:
        -:  264:/**/
        -:  265:#ifdef HAVE_GETRLIMIT
        -:  266:
        -:  267:/* the resource limits for the shell and its children */
        -:  268:
        -:  269:/**/
        -:  270:mod_export struct rlimit current_limits[RLIM_NLIMITS], limits[RLIM_NLIMITS];
        -:  271:
        -:  272:/**/
        -:  273:mod_export int
      496:  274:zsetlimit(int limnum, char *nam)
        -:  275:{
      992:  276:    if (limits[limnum].rlim_max != current_limits[limnum].rlim_max ||
      496:  277:	limits[limnum].rlim_cur != current_limits[limnum].rlim_cur) {
    #####:  278:	if (setrlimit(limnum, limits + limnum)) {
    #####:  279:	    if (nam)
    #####:  280:		zwarnnam(nam, "setrlimit failed: %e", errno);
    #####:  281:	    limits[limnum] = current_limits[limnum];
    #####:  282:	    return -1;
        -:  283:	}
    #####:  284:	current_limits[limnum] = limits[limnum];
        -:  285:    }
      496:  286:    return 0;
        -:  287:}
        -:  288:
        -:  289:/**/
        -:  290:mod_export int
       31:  291:setlimits(char *nam)
        -:  292:{
        -:  293:    int limnum;
       31:  294:    int ret = 0;
        -:  295:
      527:  296:    for (limnum = 0; limnum < RLIM_NLIMITS; limnum++)
      496:  297:	if (zsetlimit(limnum, nam))
    #####:  298:	    ret++;
       31:  299:    return ret;
        -:  300:}
        -:  301:
        -:  302:/**/
        -:  303:#endif /* HAVE_GETRLIMIT */
        -:  304:
        -:  305:/* fork and set limits */
        -:  306:
        -:  307:/**/
        -:  308:static pid_t
       26:  309:zfork(struct timeval *tv)
        -:  310:{
        -:  311:    pid_t pid;
        -:  312:    struct timezone dummy_tz;
        -:  313:
        -:  314:    /*
        -:  315:     * Is anybody willing to explain this test?
        -:  316:     */
       26:  317:    if (thisjob != -1 && thisjob >= jobtabsize - 1 && !expandjobtab()) {
    #####:  318:	zerr("job table full");
    #####:  319:	return -1;
        -:  320:    }
       26:  321:    if (tv)
       21:  322:	gettimeofday(tv, &dummy_tz);
        -:  323:    /*
        -:  324:     * Queueing signals is necessary on Linux because fork()
        -:  325:     * manipulates mutexes, leading to deadlock in memory
        -:  326:     * allocation.  We don't expect fork() to be particularly
        -:  327:     * zippy anyway.
        -:  328:     */
       26:  329:    queue_signals();
       26:  330:    pid = fork();
       52:  331:    unqueue_signals();
       52:  332:    if (pid == -1) {
    #####:  333:	zerr("fork failed: %e", errno);
    #####:  334:	return -1;
        -:  335:    }
        -:  336:#ifdef HAVE_GETRLIMIT
       52:  337:    if (!pid)
        -:  338:	/* set resource limits for the child process */
       26:  339:	setlimits(NULL);
        -:  340:#endif
       52:  341:    return pid;
        -:  342:}
        -:  343:
        -:  344:/*
        -:  345: *   Allen Edeln gebiet ich Andacht,
        -:  346: *   Hohen und Niedern von Heimdalls Geschlecht;
        -:  347: *   Ich will list_pipe's Wirken kuenden
        -:  348: *   Die aeltesten Sagen, der ich mich entsinne...
        -:  349: *
        -:  350: * In most shells, if you do something like:
        -:  351: *
        -:  352: *   cat foo | while read a; do grep $a bar; done
        -:  353: *
        -:  354: * the shell forks and executes the loop in the sub-shell thus created.
        -:  355: * In zsh this traditionally executes the loop in the current shell, which
        -:  356: * is nice to have if the loop does something to change the shell, like
        -:  357: * setting parameters or calling builtins.
        -:  358: * Putting the loop in a sub-shell makes life easy, because the shell only
        -:  359: * has to put it into the job-structure and then treats it as a normal
        -:  360: * process. Suspending and interrupting is no problem then.
        -:  361: * Some years ago, zsh either couldn't suspend such things at all, or
        -:  362: * it got really messed up when users tried to do it. As a solution, we
        -:  363: * implemented the list_pipe-stuff, which has since then become a reason
        -:  364: * for many nightmares.
        -:  365: * Pipelines like the one above are executed by the functions in this file
        -:  366: * which call each other (and sometimes recursively). The one above, for
        -:  367: * example would lead to a function call stack roughly like:
        -:  368: *
        -:  369: *  execlist->execpline->execcmd->execwhile->execlist->execpline
        -:  370: *
        -:  371: * (when waiting for the grep, ignoring execpline2 for now). At this time,
        -:  372: * zsh has built two job-table entries for it: one for the cat and one for
        -:  373: * the grep. If the user hits ^Z at this point (and jobbing is used), the
        -:  374: * shell is notified that the grep was suspended. The list_pipe flag is
        -:  375: * used to tell the execpline where it was waiting that it was in a pipeline
        -:  376: * with a shell construct at the end (which may also be a shell function or
        -:  377: * several other things). When zsh sees the suspended grep, it forks to let
        -:  378: * the sub-shell execute the rest of the while loop. The parent shell walks
        -:  379: * up in the function call stack to the first execpline. There it has to find
        -:  380: * out that it has just forked and then has to add information about the sub-
        -:  381: * shell (its pid and the text for it) in the job entry of the cat. The pid
        -:  382: * is passed down in the list_pipe_pid variable.
        -:  383: * But there is a problem: the suspended grep is a child of the parent shell
        -:  384: * and can't be adopted by the sub-shell. So the parent shell also has to
        -:  385: * keep the information about this process (more precisely: this pipeline)
        -:  386: * by keeping the job table entry it created for it. The fact that there
        -:  387: * are two jobs which have to be treated together is remembered by setting
        -:  388: * the STAT_SUPERJOB flag in the entry for the cat-job (which now also
        -:  389: * contains a process-entry for the whole loop -- the sub-shell) and by
        -:  390: * setting STAT_SUBJOB in the job of the grep-job. With that we can keep
        -:  391: * sub-jobs from being displayed and we can handle an fg/bg on the super-
        -:  392: * job correctly. When the super-job is continued, the shell also wakes up
        -:  393: * the sub-job. But then, the grep will exit sometime. Now the parent shell
        -:  394: * has to remember not to try to wake it up again (in case of another ^Z).
        -:  395: * It also has to wake up the sub-shell (which suspended itself immediately
        -:  396: * after creation), so that the rest of the loop is executed by it.
        -:  397: * But there is more: when the sub-shell is created, the cat may already
        -:  398: * have exited, so we can't put the sub-shell in the process group of it.
        -:  399: * In this case, we put the sub-shell in the process group of the parent
        -:  400: * shell and in any case, the sub-shell has to put all commands executed
        -:  401: * by it into its own process group, because only this way the parent
        -:  402: * shell can control them since it only knows the process group of the sub-
        -:  403: * shell. Of course, this information is also important when putting a job
        -:  404: * in the foreground, where we have to attach its process group to the
        -:  405: * controlling tty.
        -:  406: * All this is made more difficult because we have to handle return values
        -:  407: * correctly. If the grep is signaled, its exit status has to be propagated
        -:  408: * back to the parent shell which needs it to set the exit status of the
        -:  409: * super-job. And of course, when the grep is signaled (including ^C), the
        -:  410: * loop has to be stopped, etc.
        -:  411: * The code for all this is distributed over three files (exec.c, jobs.c,
        -:  412: * and signals.c) and none of them is a simple one. So, all in all, there
        -:  413: * may still be bugs, but considering the complexity (with race conditions,
        -:  414: * signal handling, and all that), this should probably be expected.
        -:  415: */
        -:  416:
        -:  417:/**/
        -:  418:int list_pipe = 0, simple_pline = 0;
        -:  419:
        -:  420:static pid_t list_pipe_pid;
        -:  421:static struct timeval list_pipe_start;
        -:  422:static int nowait, pline_level = 0;
        -:  423:static int list_pipe_child = 0, list_pipe_job;
        -:  424:static char list_pipe_text[JOBTEXTSIZE];
        -:  425:
        -:  426:/* execute a current shell command */
        -:  427:
        -:  428:/**/
        -:  429:static int
    #####:  430:execcursh(Estate state, int do_exec)
        -:  431:{
    #####:  432:    Wordcode end = state->pc + WC_CURSH_SKIP(state->pc[-1]);
        -:  433:
        -:  434:    /* Skip word only used for try/always */
    #####:  435:    state->pc++;
        -:  436:
        -:  437:    /*
        -:  438:     * The test thisjob != -1 was added because sometimes thisjob
        -:  439:     * can be invalid at this point.  The case in question was
        -:  440:     * in a precmd function after operations involving background
        -:  441:     * jobs.
        -:  442:     *
        -:  443:     * This is because sometimes we bypass job control to execute
        -:  444:     * very simple functions via execssimple().
        -:  445:     */
    #####:  446:    if (!list_pipe && thisjob != -1 && thisjob != list_pipe_job &&
    #####:  447:	!hasprocs(thisjob))
    #####:  448:	deletejob(jobtab + thisjob, 0);
    #####:  449:    cmdpush(CS_CURSH);
    #####:  450:    execlist(state, 1, do_exec);
    #####:  451:    cmdpop();
        -:  452:
    #####:  453:    state->pc = end;
    #####:  454:    this_noerrexit = 1;
        -:  455:
    #####:  456:    return lastval;
        -:  457:}
        -:  458:
        -:  459:/* execve after handling $_ and #! */
        -:  460:
        -:  461:#define POUNDBANGLIMIT 128
        -:  462:
        -:  463:/**/
        -:  464:static int
       26:  465:zexecve(char *pth, char **argv, char **newenvp)
        -:  466:{
        -:  467:    int eno;
        -:  468:    static char buf[PATH_MAX * 2+1];
        -:  469:    char **eep;
        -:  470:
       26:  471:    unmetafy(pth, NULL);
      133:  472:    for (eep = argv; *eep; eep++)
      107:  473:	if (*eep != pth)
      102:  474:	    unmetafy(*eep, NULL);
       26:  475:    buf[0] = '_';
       26:  476:    buf[1] = '=';
       26:  477:    if (*pth == '/')
       25:  478:	strcpy(buf + 2, pth);
        -:  479:    else
        1:  480:	sprintf(buf + 2, "%s/%s", pwd, pth);
       26:  481:    zputenv(buf);
        -:  482:#ifndef FD_CLOEXEC
        -:  483:    closedumps();
        -:  484:#endif
        -:  485:
       26:  486:    if (newenvp == NULL)
       26:  487:	    newenvp = environ;
       26:  488:    winch_unblock();
       26:  489:    execve(pth, argv, newenvp);
        -:  490:
        -:  491:    /* If the execve returns (which in general shouldn't happen),   *
        -:  492:     * then check for an errno equal to ENOEXEC.  This errno is set *
        -:  493:     * if the process file has the appropriate access permission,   *
        -:  494:     * but has an invalid magic number in its header.               */
       26:  495:    if ((eno = errno) == ENOEXEC || eno == ENOENT) {
        -:  496:	char execvebuf[POUNDBANGLIMIT + 1], *ptr, *ptr2, *argv0;
        -:  497:	int fd, ct, t0;
        -:  498:
       26:  499:	if ((fd = open(pth, O_RDONLY|O_NOCTTY)) >= 0) {
    #####:  500:	    argv0 = *argv;
    #####:  501:	    *argv = pth;
    #####:  502:	    memset(execvebuf, '\0', POUNDBANGLIMIT + 1);
    #####:  503:	    ct = read(fd, execvebuf, POUNDBANGLIMIT);
    #####:  504:	    close(fd);
    #####:  505:	    if (ct >= 0) {
    #####:  506:		if (ct >= 2 && execvebuf[0] == '#' && execvebuf[1] == '!') {
    #####:  507:		    for (t0 = 0; t0 != ct; t0++)
    #####:  508:			if (execvebuf[t0] == '\n')
    #####:  509:			    break;
    #####:  510:		    if (t0 == ct)
    #####:  511:			zerr("%s: bad interpreter: %s: %e", pth,
        -:  512:			     execvebuf + 2, eno);
        -:  513:		    else {
    #####:  514:			while (inblank(execvebuf[t0]))
    #####:  515:			    execvebuf[t0--] = '\0';
    #####:  516:			for (ptr = execvebuf + 2; *ptr && *ptr == ' '; ptr++);
    #####:  517:			for (ptr2 = ptr; *ptr && *ptr != ' '; ptr++);
    #####:  518:			if (eno == ENOENT) {
        -:  519:			    char *pprog;
    #####:  520:			    if (*ptr)
    #####:  521:				*ptr = '\0';
    #####:  522:			    if (*ptr2 != '/' &&
        -:  523:				(pprog = pathprog(ptr2, NULL))) {
    #####:  524:				if (ptr == execvebuf + t0 + 1) {
    #####:  525:				    argv[-1] = ptr2;
    #####:  526:				    winch_unblock();
    #####:  527:				    execve(pprog, argv - 1, newenvp);
        -:  528:				} else {
    #####:  529:				    argv[-2] = ptr2;
    #####:  530:				    argv[-1] = ptr + 1;
    #####:  531:				    winch_unblock();
    #####:  532:				    execve(pprog, argv - 2, newenvp);
        -:  533:				}
        -:  534:			    }
    #####:  535:			    zerr("%s: bad interpreter: %s: %e", pth, ptr2,
        -:  536:				 eno);
    #####:  537:			} else if (*ptr) {
    #####:  538:			    *ptr = '\0';
    #####:  539:			    argv[-2] = ptr2;
    #####:  540:			    argv[-1] = ptr + 1;
    #####:  541:			    winch_unblock();
    #####:  542:			    execve(ptr2, argv - 2, newenvp);
        -:  543:			} else {
    #####:  544:			    argv[-1] = ptr2;
    #####:  545:			    winch_unblock();
    #####:  546:			    execve(ptr2, argv - 1, newenvp);
        -:  547:			}
        -:  548:		    }
    #####:  549:		} else if (eno == ENOEXEC) {
        -:  550:                    /* Perform binary safety check on classic shell    *
        -:  551:                     * scripts (shebang wasn't introduced until UNIX   *
        -:  552:                     * Seventh Edition). POSIX says we shall allow     *
        -:  553:                     * execution of scripts with concatenated binary   *
        -:  554:                     * and suggests checking a line exists before the  *
        -:  555:                     * first NUL character with a lowercase letter or  *
        -:  556:                     * expansion. This is consistent with FreeBSD sh.  */
        -:  557:                    int isbinary, hasletter;
    #####:  558:                    if (!(ptr2 = memchr(execvebuf, '\0', ct))) {
    #####:  559:                        isbinary = 0;
        -:  560:                    } else {
    #####:  561:                        isbinary = 1;
    #####:  562:                        hasletter = 0;
    #####:  563:                        for (ptr = execvebuf; ptr < ptr2; ptr++) {
    #####:  564:                            if (islower(*ptr) || *ptr == '$' || *ptr == '`')
    #####:  565:                                hasletter = 1;
    #####:  566:                            if (hasletter && *ptr == '\n') {
    #####:  567:                                isbinary = 0;
    #####:  568:                                break;
        -:  569:                            }
        -:  570:                        }
        -:  571:                    }
    #####:  572:		    if (!isbinary) {
    #####:  573:			argv[-1] = "sh";
    #####:  574:			winch_unblock();
    #####:  575:			execve("/bin/sh", argv - 1, newenvp);
        -:  576:		    }
        -:  577:		}
        -:  578:	    } else
    #####:  579:		eno = errno;
    #####:  580:	    *argv = argv0;
        -:  581:	} else
    #####:  582:	    eno = errno;
        -:  583:    }
        -:  584:    /* restore the original arguments and path but do not bother with *
        -:  585:     * null characters as these cannot be passed to external commands *
        -:  586:     * anyway.  So the result is truncated at the first null char.    */
    #####:  587:    pth = metafy(pth, -1, META_NOALLOC);
    #####:  588:    for (eep = argv; *eep; eep++)
    #####:  589:	if (*eep != pth)
    #####:  590:	    (void) metafy(*eep, -1, META_NOALLOC);
    #####:  591:    return eno;
        -:  592:}
        -:  593:
        -:  594:#define MAXCMDLEN (PATH_MAX*4)
        -:  595:
        -:  596:/* test whether we really want to believe the error number */
        -:  597:
        -:  598:/**/
        -:  599:static int
    #####:  600:isgooderr(int e, char *dir)
        -:  601:{
        -:  602:    /*
        -:  603:     * Maybe the directory was unreadable, or maybe it wasn't
        -:  604:     * even a directory.
        -:  605:     */
    #####:  606:    return ((e != EACCES || !access(dir, X_OK)) &&
    #####:  607:	    e != ENOENT && e != ENOTDIR);
        -:  608:}
        -:  609:
        -:  610:/*
        -:  611: * Attempt to handle command not found.
        -:  612: * Return 0 if the condition was handled, non-zero otherwise.
        -:  613: */
        -:  614:
        -:  615:/**/
        -:  616:static int
    #####:  617:commandnotfound(char *arg0, LinkList args)
        -:  618:{
    #####:  619:    Shfunc shf = (Shfunc)
    #####:  620:	shfunctab->getnode(shfunctab, "command_not_found_handler");
        -:  621:
    #####:  622:    if (!shf) {
    #####:  623:	lastval = 127;
    #####:  624:	return 1;
        -:  625:    }
        -:  626:
    #####:  627:    pushnode(args, arg0);
    #####:  628:    lastval = doshfunc(shf, args, 1);
    #####:  629:    return 0;
        -:  630:}
        -:  631:
        -:  632:/*
        -:  633: * Search the default path for cmd.
        -:  634: * pbuf of length plen is the buffer to use.
        -:  635: * Return NULL if not found.
        -:  636: */
        -:  637:
        -:  638:static char *
    #####:  639:search_defpath(char *cmd, char *pbuf, int plen)
        -:  640:{
    #####:  641:    char *ps = DEFAULT_PATH, *pe = NULL, *s;
        -:  642:
    #####:  643:    for (ps = DEFAULT_PATH; ps; ps = pe ? pe+1 : NULL) {
    #####:  644:	pe = strchr(ps, ':');
    #####:  645:	if (*ps == '/') {
    #####:  646:	    s = pbuf;
    #####:  647:	    if (pe) {
    #####:  648:		if (pe - ps >= plen)
    #####:  649:		    continue;
    #####:  650:		struncpy(&s, ps, pe-ps);
        -:  651:	    } else {
    #####:  652:		if (strlen(ps) >= plen)
    #####:  653:		    continue;
    #####:  654:		strucpy(&s, ps);
        -:  655:	    }
    #####:  656:	    *s++ = '/';
    #####:  657:	    if ((s - pbuf) + strlen(cmd) >= plen)
    #####:  658:		continue;
    #####:  659:	    strucpy(&s, cmd);
    #####:  660:	    if (iscom(pbuf))
    #####:  661:		return pbuf;
        -:  662:	}
        -:  663:    }
    #####:  664:    return NULL;
        -:  665:}
        -:  666:
        -:  667:/* execute an external command */
        -:  668:
        -:  669:/**/
        -:  670:static void
       26:  671:execute(LinkList args, int flags, int defpath)
        -:  672:{
        -:  673:    Cmdnam cn;
        -:  674:    char buf[MAXCMDLEN+1], buf2[MAXCMDLEN+1];
        -:  675:    char *s, *z, *arg0;
       26:  676:    char **argv, **pp, **newenvp = NULL;
       26:  677:    int eno = 0, ee;
        -:  678:
       26:  679:    arg0 = (char *) peekfirst(args);
       26:  680:    if (isset(RESTRICTED) && (strchr(arg0, '/') || defpath)) {
    #####:  681:	zerr("%s: restricted", arg0);
    #####:  682:	_exit(1);
        -:  683:    }
        -:  684:
        -:  685:    /* If the parameter STTY is set in the command's environment, *
        -:  686:     * we first run the stty command with the value of this       *
        -:  687:     * parameter as it arguments.                                 */
       26:  688:    if ((s = STTYval) && isatty(0) && (GETPGRP() == getpid())) {
    #####:  689:	char *t = tricat("stty", " ", s);
        -:  690:
    #####:  691:	STTYval = 0;	/* this prevents infinite recursion */
    #####:  692:	zsfree(s);
    #####:  693:	execstring(t, 1, 0, "stty");
    #####:  694:	zsfree(t);
       26:  695:    } else if (s) {
    #####:  696:	STTYval = 0;
    #####:  697:	zsfree(s);
        -:  698:    }
        -:  699:
        -:  700:    /* If ARGV0 is in the commands environment, we use *
        -:  701:     * that as argv[0] for this external command       */
       26:  702:    if (unset(RESTRICTED) && (z = zgetenv("ARGV0"))) {
    #####:  703:	setdata(firstnode(args), (void *) ztrdup(z));
        -:  704:	/*
        -:  705:	 * Note we don't do anything with the parameter structure
        -:  706:	 * for ARGV0: that's OK since we're about to exec or exit
        -:  707:	 * on failure.
        -:  708:	 */
        -:  709:#ifdef USE_SET_UNSET_ENV
    #####:  710:	unsetenv("ARGV0");
        -:  711:#else
        -:  712:	delenvvalue(z - 6);
        -:  713:#endif
       26:  714:    } else if (flags & BINF_DASH) {
        -:  715:    /* Else if the pre-command `-' was given, we add `-' *
        -:  716:     * to the front of argv[0] for this command.         */
    #####:  717:	sprintf(buf2, "-%s", arg0);
    #####:  718:	setdata(firstnode(args), (void *) ztrdup(buf2));
        -:  719:    }
        -:  720:
       26:  721:    argv = makecline(args);
       26:  722:    if (flags & BINF_CLEARENV)
    #####:  723:	newenvp = blank_env;
        -:  724:
        -:  725:    /*
        -:  726:     * Note that we don't close fd's attached to process substitution
        -:  727:     * here, which should be visible to external processes.
        -:  728:     */
       26:  729:    closem(FDT_XTRACE, 0);
        -:  730:#ifndef FD_CLOEXEC
        -:  731:    if (SHTTY != -1) {
        -:  732:	close(SHTTY);
        -:  733:	SHTTY = -1;
        -:  734:    }
        -:  735:#endif
       26:  736:    child_unblock();
       26:  737:    if ((int) strlen(arg0) >= PATH_MAX) {
    #####:  738:	zerr("command too long: %s", arg0);
    #####:  739:	_exit(1);
        -:  740:    }
      104:  741:    for (s = arg0; *s; s++)
       83:  742:	if (*s == '/') {
        5:  743:	    int lerrno = zexecve(arg0, argv, newenvp);
    #####:  744:	    if (arg0 == s || unset(PATHDIRS) ||
    #####:  745:		(arg0[0] == '.' && (arg0 + 1 == s ||
    #####:  746:				    (arg0[1] == '.' && arg0 + 2 == s)))) {
    #####:  747:		zerr("%e: %s", lerrno, arg0);
    #####:  748:		_exit((lerrno == EACCES || lerrno == ENOEXEC) ? 126 : 127);
        -:  749:	    }
    #####:  750:	    break;
        -:  751:	}
        -:  752:
        -:  753:    /* for command -p, search the default path */
       21:  754:    if (defpath) {
        -:  755:	char pbuf[PATH_MAX+1];
        -:  756:	char *dptr;
        -:  757:
    #####:  758:	if (!search_defpath(arg0, pbuf, PATH_MAX)) {
    #####:  759:	    if (commandnotfound(arg0, args) == 0)
    #####:  760:		_realexit();
    #####:  761:	    zerr("command not found: %s", arg0);
    #####:  762:	    _exit(127);
        -:  763:	}
        -:  764:
    #####:  765:	ee = zexecve(pbuf, argv, newenvp);
        -:  766:
    #####:  767:	if ((dptr = strrchr(pbuf, '/')))
    #####:  768:	    *dptr = '\0';
    #####:  769:	if (isgooderr(ee, *pbuf ? pbuf : "/"))
    #####:  770:	    eno = ee;
        -:  771:
        -:  772:    } else {
        -:  773:
       21:  774:	if ((cn = (Cmdnam) cmdnamtab->getnode(cmdnamtab, arg0))) {
        -:  775:	    char nn[PATH_MAX+1], *dptr;
        -:  776:
       21:  777:	    if (cn->node.flags & HASHED)
    #####:  778:		strcpy(nn, cn->u.cmd);
        -:  779:	    else {
      106:  780:		for (pp = path; pp < cn->u.name; pp++)
       85:  781:		    if (!**pp || (**pp == '.' && (*pp)[1] == '\0')) {
    #####:  782:			ee = zexecve(arg0, argv, newenvp);
    #####:  783:			if (isgooderr(ee, *pp))
    #####:  784:			    eno = ee;
       85:  785:		    } else if (**pp != '/') {
    #####:  786:			z = buf;
    #####:  787:			strucpy(&z, *pp);
    #####:  788:			*z++ = '/';
    #####:  789:			strcpy(z, arg0);
    #####:  790:			ee = zexecve(buf, argv, newenvp);
    #####:  791:			if (isgooderr(ee, *pp))
    #####:  792:			    eno = ee;
        -:  793:		    }
       21:  794:		strcpy(nn, cn->u.name ? *(cn->u.name) : "");
       21:  795:		strcat(nn, "/");
       21:  796:		strcat(nn, cn->node.nam);
        -:  797:	    }
       21:  798:	    ee = zexecve(nn, argv, newenvp);
        -:  799:
    #####:  800:	    if ((dptr = strrchr(nn, '/')))
    #####:  801:		*dptr = '\0';
    #####:  802:	    if (isgooderr(ee, *nn ? nn : "/"))
    #####:  803:		eno = ee;
        -:  804:	}
    #####:  805:	for (pp = path; *pp; pp++)
    #####:  806:	    if (!(*pp)[0] || ((*pp)[0] == '.' && !(*pp)[1])) {
    #####:  807:		ee = zexecve(arg0, argv, newenvp);
    #####:  808:		if (isgooderr(ee, *pp))
    #####:  809:		    eno = ee;
        -:  810:	    } else {
    #####:  811:		z = buf;
    #####:  812:		strucpy(&z, *pp);
    #####:  813:		*z++ = '/';
    #####:  814:		strcpy(z, arg0);
    #####:  815:		ee = zexecve(buf, argv, newenvp);
    #####:  816:		if (isgooderr(ee, *pp))
    #####:  817:		    eno = ee;
        -:  818:	    }
        -:  819:    }
        -:  820:
    #####:  821:    if (eno)
    #####:  822:	zerr("%e: %s", eno, arg0);
    #####:  823:    else if (commandnotfound(arg0, args) == 0)
    #####:  824:	_realexit();
        -:  825:    else
    #####:  826:	zerr("command not found: %s", arg0);
    #####:  827:    _exit((eno == EACCES || eno == ENOEXEC) ? 126 : 127);
        -:  828:}
        -:  829:
        -:  830:#define RET_IF_COM(X) { if (iscom(X)) return docopy ? dupstring(X) : arg0; }
        -:  831:
        -:  832:/*
        -:  833: * Get the full pathname of an external command.
        -:  834: * If the second argument is zero, return the first argument if found;
        -:  835: * if non-zero, return the path using heap memory.  (RET_IF_COM(X),
        -:  836: * above).
        -:  837: * If the third argument is non-zero, use the system default path
        -:  838: * instead of the current path.
        -:  839: */
        -:  840:
        -:  841:/**/
        -:  842:mod_export char *
    #####:  843:findcmd(char *arg0, int docopy, int default_path)
        -:  844:{
        -:  845:    char **pp;
        -:  846:    char *z, *s, buf[MAXCMDLEN];
        -:  847:    Cmdnam cn;
        -:  848:
    #####:  849:    if (default_path)
        -:  850:    {
    #####:  851:	if (search_defpath(arg0, buf, MAXCMDLEN))
    #####:  852:	    return docopy ? dupstring(buf) : arg0;
    #####:  853:	return NULL;
        -:  854:    }
    #####:  855:    cn = (Cmdnam) cmdnamtab->getnode(cmdnamtab, arg0);
    #####:  856:    if (!cn && isset(HASHCMDS) && !isrelative(arg0))
    #####:  857:	cn = hashcmd(arg0, path);
    #####:  858:    if ((int) strlen(arg0) > PATH_MAX)
    #####:  859:	return NULL;
    #####:  860:    if ((s = strchr(arg0, '/'))) {
    #####:  861:	RET_IF_COM(arg0);
    #####:  862:	if (arg0 == s || unset(PATHDIRS) || !strncmp(arg0, "./", 2) ||
    #####:  863:	    !strncmp(arg0, "../", 3)) {
    #####:  864:	    return NULL;
        -:  865:	}
        -:  866:    }
    #####:  867:    if (cn) {
        -:  868:	char nn[PATH_MAX+1];
        -:  869:
    #####:  870:	if (cn->node.flags & HASHED)
    #####:  871:	    strcpy(nn, cn->u.cmd);
        -:  872:	else {
    #####:  873:	    for (pp = path; pp < cn->u.name; pp++)
    #####:  874:		if (**pp != '/') {
    #####:  875:		    z = buf;
    #####:  876:		    if (**pp) {
    #####:  877:			strucpy(&z, *pp);
    #####:  878:			*z++ = '/';
        -:  879:		    }
    #####:  880:		    strcpy(z, arg0);
    #####:  881:		    RET_IF_COM(buf);
        -:  882:		}
    #####:  883:	    strcpy(nn, cn->u.name ? *(cn->u.name) : "");
    #####:  884:	    strcat(nn, "/");
    #####:  885:	    strcat(nn, cn->node.nam);
        -:  886:	}
    #####:  887:	RET_IF_COM(nn);
        -:  888:    }
    #####:  889:    for (pp = path; *pp; pp++) {
    #####:  890:	z = buf;
    #####:  891:	if (**pp) {
    #####:  892:	    strucpy(&z, *pp);
    #####:  893:	    *z++ = '/';
        -:  894:	}
    #####:  895:	strcpy(z, arg0);
    #####:  896:	RET_IF_COM(buf);
        -:  897:    }
    #####:  898:    return NULL;
        -:  899:}
        -:  900:
        -:  901:/*
        -:  902: * Return TRUE if the given path denotes an executable regular file, or a
        -:  903: * symlink to one.
        -:  904: */
        -:  905:
        -:  906:/**/
        -:  907:int
        6:  908:iscom(char *s)
        -:  909:{
        -:  910:    struct stat statbuf;
        6:  911:    char *us = unmeta(s);
        -:  912:
        7:  913:    return (access(us, X_OK) == 0 && stat(us, &statbuf) >= 0 &&
        1:  914:	    S_ISREG(statbuf.st_mode));
        -:  915:}
        -:  916:
        -:  917:/**/
        -:  918:int
    #####:  919:isreallycom(Cmdnam cn)
        -:  920:{
        -:  921:    char fullnam[MAXCMDLEN];
        -:  922:
    #####:  923:    if (cn->node.flags & HASHED)
    #####:  924:	strcpy(fullnam, cn->u.cmd);
    #####:  925:    else if (!cn->u.name)
    #####:  926:	return 0;
        -:  927:    else {
    #####:  928:	strcpy(fullnam, *(cn->u.name));
    #####:  929:	strcat(fullnam, "/");
    #####:  930:	strcat(fullnam, cn->node.nam);
        -:  931:    }
    #####:  932:    return iscom(fullnam);
        -:  933:}
        -:  934:
        -:  935:/*
        -:  936: * Return TRUE if the given path contains a dot or dot-dot component
        -:  937: * and does not start with a slash.
        -:  938: */
        -:  939:
        -:  940:/**/
        -:  941:int
        6:  942:isrelative(char *s)
        -:  943:{
        6:  944:    if (*s != '/')
    #####:  945:	return 1;
       61:  946:    for (; *s; s++)
       55:  947:	if (*s == '.' && s[-1] == '/' &&
    #####:  948:	    (s[1] == '/' || s[1] == '\0' ||
    #####:  949:	     (s[1] == '.' && (s[2] == '/' || s[2] == '\0'))))
    #####:  950:	    return 1;
        6:  951:    return 0;
        -:  952:}
        -:  953:
        -:  954:/**/
        -:  955:mod_export Cmdnam
        1:  956:hashcmd(char *arg0, char **pp)
        -:  957:{
        -:  958:    Cmdnam cn;
        -:  959:    char *s, buf[PATH_MAX+1];
        -:  960:    char **pq;
        -:  961:
        1:  962:    if (*arg0 == '/')
    #####:  963:        return NULL;
        6:  964:    for (; *pp; pp++)
        6:  965:	if (**pp == '/') {
        6:  966:	    s = buf;
        6:  967:	    struncpy(&s, *pp, PATH_MAX);
        6:  968:	    *s++ = '/';
        6:  969:	    if ((s - buf) + strlen(arg0) >= PATH_MAX)
    #####:  970:		continue;
        6:  971:	    strcpy(s, arg0);
        6:  972:	    if (iscom(buf))
        1:  973:		break;
        -:  974:	}
        -:  975:
        1:  976:    if (!*pp)
    #####:  977:	return NULL;
        -:  978:
        1:  979:    cn = (Cmdnam) zshcalloc(sizeof *cn);
        1:  980:    cn->node.flags = 0;
        1:  981:    cn->u.name = pp;
        1:  982:    cmdnamtab->addnode(cmdnamtab, ztrdup(arg0), cn);
        -:  983:
        1:  984:    if (isset(HASHDIRS)) {
        7:  985:	for (pq = pathchecked; pq <= pp; pq++)
        6:  986:	    hashdir(pq);
        1:  987:	pathchecked = pp + 1;
        -:  988:    }
        -:  989:
        1:  990:    return cn;
        -:  991:}
        -:  992:
        -:  993:/* The value that 'locallevel' had when we forked. When we get back to this
        -:  994: * level, the current process (which is a subshell) will terminate.
        -:  995: */
        -:  996:
        -:  997:/**/
        -:  998:int
        -:  999:forklevel;
        -: 1000:
        -: 1001:/* Arguments to entersubsh() */
        -: 1002:enum {
        -: 1003:    /* Subshell is to be run asynchronously (else synchronously) */
        -: 1004:    ESUB_ASYNC = 0x01,
        -: 1005:    /*
        -: 1006:     * Perform process group and tty handling and clear the
        -: 1007:     * (real) job table, since it won't be any longer valid
        -: 1008:     */
        -: 1009:    ESUB_PGRP = 0x02,
        -: 1010:    /* Don't unset traps */
        -: 1011:    ESUB_KEEPTRAP = 0x04,
        -: 1012:    /* This is only a fake entry to a subshell */
        -: 1013:    ESUB_FAKE = 0x08,
        -: 1014:    /* Release the process group if pid is the shell's process group */
        -: 1015:    ESUB_REVERTPGRP = 0x10,
        -: 1016:    /* Don't handle the MONITOR option even if previously set */
        -: 1017:    ESUB_NOMONITOR = 0x20,
        -: 1018:    /* This is a subshell where job control is allowed */
        -: 1019:    ESUB_JOB_CONTROL = 0x40
        -: 1020:};
        -: 1021:
        -: 1022:/*
        -: 1023: * gleaderp may be NULL.  Otherwise, *gleaderp is set to point to the
        -: 1024: * group leader of the job of the new process if this is assigned.  Else
        -: 1025: * it is left alone: it is initialised to -1.
        -: 1026: */
        -: 1027:
        -: 1028:/**/
        -: 1029:static void
       31: 1030:entersubsh(int flags, struct entersubsh_ret *retp)
        -: 1031:{
        -: 1032:    int i, sig, monitor, job_control_ok;
        -: 1033:
       31: 1034:    if (!(flags & ESUB_KEEPTRAP))
      160: 1035:	for (sig = 0; sig < SIGCOUNT; sig++)
      310: 1036:	    if (!(sigtrapped[sig] & ZSIG_FUNC) &&
      155: 1037:		!(isset(POSIXTRAPS) && (sigtrapped[sig] & ZSIG_IGNORED)))
      155: 1038:		unsettrap(sig);
       31: 1039:    monitor = isset(MONITOR);
       31: 1040:    job_control_ok = monitor && (flags & ESUB_JOB_CONTROL) && isset(POSIXJOBS);
       31: 1041:    exit_val = 0; 		/* parent exit status is irrelevant */
       31: 1042:    if (flags & ESUB_NOMONITOR)
        5: 1043:	opts[MONITOR] = 0;
       31: 1044:    if (!isset(MONITOR)) {
       31: 1045:	if (flags & ESUB_ASYNC) {
    #####: 1046:	    settrap(SIGINT, NULL, 0);
    #####: 1047:	    settrap(SIGQUIT, NULL, 0);
    #####: 1048:	    if (isatty(0)) {
    #####: 1049:		close(0);
    #####: 1050:		if (open("/dev/null", O_RDWR | O_NOCTTY)) {
    #####: 1051:		    zerr("can't open /dev/null: %e", errno);
    #####: 1052:		    _exit(1);
        -: 1053:		}
        -: 1054:	    }
        -: 1055:	}
    #####: 1056:    } else if (thisjob != -1 && (flags & ESUB_PGRP)) {
    #####: 1057:	if (jobtab[list_pipe_job].gleader && (list_pipe || list_pipe_child)) {
    #####: 1058:	    if (setpgrp(0L, jobtab[list_pipe_job].gleader) == -1 ||
    #####: 1059:		(killpg(jobtab[list_pipe_job].gleader, 0) == -1  &&
    #####: 1060:		 errno == ESRCH)) {
    #####: 1061:		jobtab[list_pipe_job].gleader =
    #####: 1062:		    jobtab[thisjob].gleader = (list_pipe_child ? mypgrp : getpid());
    #####: 1063:		setpgrp(0L, jobtab[list_pipe_job].gleader);
    #####: 1064:		if (!(flags & ESUB_ASYNC))
    #####: 1065:		    attachtty(jobtab[thisjob].gleader);
        -: 1066:	    }
    #####: 1067:	    if (retp && !(flags & ESUB_ASYNC)) {
    #####: 1068:		retp->gleader = jobtab[list_pipe_job].gleader;
    #####: 1069:		retp->list_pipe_job = list_pipe_job;
        -: 1070:	    }
        -: 1071:	}
    #####: 1072:	else if (!jobtab[thisjob].gleader ||
    #####: 1073:		 setpgrp(0L, jobtab[thisjob].gleader) == -1) {
        -: 1074:	    /*
        -: 1075:	     * This is the standard point at which a newly started
        -: 1076:	     * process gets put into the foreground by taking over
        -: 1077:	     * the terminal.  Note that in normal circumstances we do
        -: 1078:	     * this only from the process itself.  This only works if
        -: 1079:	     * we are still ignoring SIGTTOU at this point; in this
        -: 1080:	     * case ignoring the signal has the special effect that
        -: 1081:	     * the operation is allowed to work (in addition to not
        -: 1082:	     * causing the shell to be suspended).
        -: 1083:	     */
    #####: 1084:	    jobtab[thisjob].gleader = getpid();
    #####: 1085:	    if (list_pipe_job != thisjob &&
    #####: 1086:		!jobtab[list_pipe_job].gleader)
    #####: 1087:		jobtab[list_pipe_job].gleader = jobtab[thisjob].gleader;
    #####: 1088:	    setpgrp(0L, jobtab[thisjob].gleader);
    #####: 1089:	    if (!(flags & ESUB_ASYNC)) {
    #####: 1090:		attachtty(jobtab[thisjob].gleader);
    #####: 1091:		if (retp) {
    #####: 1092:		    retp->gleader = jobtab[thisjob].gleader;
    #####: 1093:		    if (list_pipe_job != thisjob)
    #####: 1094:			retp->list_pipe_job = list_pipe_job;
        -: 1095:		}
        -: 1096:	    }
        -: 1097:	}
        -: 1098:    }
       31: 1099:    if (!(flags & ESUB_FAKE))
       26: 1100:	subsh = 1;
        -: 1101:    /*
        -: 1102:     * Increment the visible parameter ZSH_SUBSHELL even if this
        -: 1103:     * is a fake subshell because we are exec'ing at the end.
        -: 1104:     * Logically this should be equivalent to a real subshell so
        -: 1105:     * we don't hang out the dirty washing.
        -: 1106:     */
       31: 1107:    zsh_subshell++;
       31: 1108:    if ((flags & ESUB_REVERTPGRP) && getpid() == mypgrp)
    #####: 1109:	release_pgrp();
       31: 1110:    shout = NULL;
       31: 1111:    if (flags & ESUB_NOMONITOR) {
        -: 1112:	/*
        -: 1113:	 * Allowing any form of interactive signalling here is
        -: 1114:	 * actively harmful as we are in a context where there is no
        -: 1115:	 * control over the process.
        -: 1116:	 */
        5: 1117:	signal_ignore(SIGTTOU);
        5: 1118:	signal_ignore(SIGTTIN);
        5: 1119:	signal_ignore(SIGTSTP);
       26: 1120:    } else if (!job_control_ok) {
        -: 1121:	/*
        -: 1122:	 * If this process is not going to be doing job control,
        -: 1123:	 * we don't want to do special things with the corresponding
        -: 1124:	 * signals.  If it is, we need to keep the special behaviour:
        -: 1125:	 * see note about attachtty() above.
        -: 1126:	 */
       26: 1127:	signal_default(SIGTTOU);
       26: 1128:	signal_default(SIGTTIN);
       26: 1129:	signal_default(SIGTSTP);
        -: 1130:    }
       31: 1131:    if (interact) {
    #####: 1132:	signal_default(SIGTERM);
    #####: 1133:	if (!(sigtrapped[SIGINT] & ZSIG_IGNORED))
    #####: 1134:	    signal_default(SIGINT);
    #####: 1135:	if (!(sigtrapped[SIGPIPE]))
    #####: 1136:	    signal_default(SIGPIPE);
        -: 1137:    }
       31: 1138:    if (!(sigtrapped[SIGQUIT] & ZSIG_IGNORED))
       31: 1139:	signal_default(SIGQUIT);
        -: 1140:    /*
        -: 1141:     * sigtrapped[sig] == ZSIG_IGNORED for signals that remain ignored,
        -: 1142:     * but other trapped signals are temporarily blocked when intrap,
        -: 1143:     * and must be unblocked before continuing into the subshell.  This
        -: 1144:     * is orthogonal to what the default handler for the signal may be.
        -: 1145:     *
        -: 1146:     * Start loop at 1 because 0 is SIGEXIT
        -: 1147:     */
       31: 1148:    if (intrap)
    #####: 1149:	for (sig = 1; sig < SIGCOUNT; sig++)
    #####: 1150:	    if (sigtrapped[sig] && sigtrapped[sig] != ZSIG_IGNORED)
    #####: 1151:		signal_unblock(signal_mask(sig));
       31: 1152:    if (!job_control_ok)
       31: 1153:	opts[MONITOR] = 0;
       31: 1154:    opts[USEZLE] = 0;
       31: 1155:    zleactive = 0;
        -: 1156:    /*
        -: 1157:     * If we've saved fd's for later restoring, we're never going
        -: 1158:     * to restore them now, so just close them.
        -: 1159:     */
      136: 1160:    for (i = 10; i <= max_zsh_fd; i++) {
      105: 1161:	if (fdtable[i] & FDT_SAVED_MASK)
       13: 1162:	    zclose(i);
        -: 1163:    }
       31: 1164:    if (flags & ESUB_PGRP)
       31: 1165:	clearjobtab(monitor);
       31: 1166:    get_usage();
       31: 1167:    forklevel = locallevel;
       31: 1168:}
        -: 1169:
        -: 1170:/* execute a string */
        -: 1171:
        -: 1172:/**/
        -: 1173:mod_export void
    #####: 1174:execstring(char *s, int dont_change_job, int exiting, char *context)
        -: 1175:{
        -: 1176:    Eprog prog;
        -: 1177:
    #####: 1178:    pushheap();
    #####: 1179:    if (isset(VERBOSE)) {
    #####: 1180:	zputs(s, stderr);
    #####: 1181:	fputc('\n', stderr);
    #####: 1182:	fflush(stderr);
        -: 1183:    }
    #####: 1184:    if ((prog = parse_string(s, 0)))
    #####: 1185:	execode(prog, dont_change_job, exiting, context);
    #####: 1186:    popheap();
    #####: 1187:}
        -: 1188:
        -: 1189:/**/
        -: 1190:mod_export void
      208: 1191:execode(Eprog p, int dont_change_job, int exiting, char *context)
        -: 1192:{
        -: 1193:    struct estate s;
        -: 1194:    static int zsh_eval_context_len;
        -: 1195:    int alen;
        -: 1196:
      208: 1197:    if (!zsh_eval_context_len) {
        6: 1198:	zsh_eval_context_len = 16;
        6: 1199:	alen = 0;
        6: 1200:	zsh_eval_context = (char **)zalloc(zsh_eval_context_len *
        -: 1201:					   sizeof(*zsh_eval_context));
        -: 1202:    } else {
      202: 1203:	alen = arrlen(zsh_eval_context);
      202: 1204:	if (zsh_eval_context_len == alen + 1) {
    #####: 1205:	    zsh_eval_context_len *= 2;
    #####: 1206:	    zsh_eval_context = zrealloc(zsh_eval_context,
        -: 1207:					zsh_eval_context_len *
        -: 1208:					sizeof(*zsh_eval_context));
        -: 1209:	}
        -: 1210:    }
      208: 1211:    zsh_eval_context[alen] = context;
      208: 1212:    zsh_eval_context[alen+1] = NULL;
        -: 1213:
      208: 1214:    s.prog = p;
      208: 1215:    s.pc = p->prog;
      208: 1216:    s.strs = p->strs;
      208: 1217:    useeprog(p);		/* Mark as in use */
        -: 1218:
      208: 1219:    execlist(&s, dont_change_job, exiting);
        -: 1220:
      201: 1221:    freeeprog(p);		/* Free if now unused */
        -: 1222:
        -: 1223:    /*
        -: 1224:     * zsh_eval_context may have been altered by a recursive
        -: 1225:     * call, but that's OK since we're using the global value.
        -: 1226:     */
      201: 1227:    zsh_eval_context[alen] = NULL;
      201: 1228:}
        -: 1229:
        -: 1230:/* Execute a simplified command. This is used to execute things that
        -: 1231: * will run completely in the shell, so that we can by-pass all that
        -: 1232: * nasty job-handling and redirection stuff in execpline and execcmd. */
        -: 1233:
        -: 1234:/**/
        -: 1235:static int
      390: 1236:execsimple(Estate state)
        -: 1237:{
      390: 1238:    wordcode code = *state->pc++;
        -: 1239:    int lv, otj;
        -: 1240:
      390: 1241:    if (errflag)
    #####: 1242:	return (lastval = 1);
        -: 1243:
      390: 1244:    if (!isset(EXECOPT))
    #####: 1245:	return lastval = 0;
        -: 1246:
        -: 1247:    /* In evaluated traps, don't modify the line number. */
      390: 1248:    if (!IN_EVAL_TRAP() && !ineval && code)
      390: 1249:	lineno = code - 1;
        -: 1250:
      390: 1251:    code = wc_code(*state->pc++);
        -: 1252:
        -: 1253:    /*
        -: 1254:     * Because we're bypassing job control, ensure the called
        -: 1255:     * code doesn't see the current job.
        -: 1256:     */
      390: 1257:    otj = thisjob;
      390: 1258:    thisjob = -1;
        -: 1259:
      390: 1260:    if (code == WC_ASSIGN) {
      128: 1261:	cmdoutval = 0;
      128: 1262:	addvars(state, state->pc - 1, 0);
      128: 1263:	setunderscore("");
      128: 1264:	if (isset(XTRACE)) {
    #####: 1265:	    fputc('\n', xtrerr);
    #####: 1266:	    fflush(xtrerr);
        -: 1267:	}
      128: 1268:	lv = (errflag ? errflag : cmdoutval);
        -: 1269:    } else {
      262: 1270:	int q = queue_signal_level();
      262: 1271:	dont_queue_signals();
      262: 1272:	if (errflag)
    #####: 1273:	    lv = errflag;
      262: 1274:	else if (code == WC_FUNCDEF)
       19: 1275:	    lv = execfuncdef(state, NULL);
        -: 1276:	else
      243: 1277:	    lv = (execfuncs[code - WC_CURSH])(state, 0);
      262: 1278:	restore_queue_signals(q);
        -: 1279:    }
        -: 1280:
      390: 1281:    thisjob = otj;
        -: 1282:
      390: 1283:    return lastval = lv;
        -: 1284:}
        -: 1285:
        -: 1286:/* Main routine for executing a list.                                *
        -: 1287: * exiting means that the (sub)shell we are in is a definite goner   *
        -: 1288: * after the current list is finished, so we may be able to exec the *
        -: 1289: * last command directly instead of forking.  If dont_change_job is  *
        -: 1290: * nonzero, then restore the current job number after executing the  *
        -: 1291: * list.                                                             */
        -: 1292:
        -: 1293:/**/
        -: 1294:void
      606: 1295:execlist(Estate state, int dont_change_job, int exiting)
        -: 1296:{
        -: 1297:    static int donetrap;
        -: 1298:    Wordcode next;
        -: 1299:    wordcode code;
        -: 1300:    int ret, cj, csp, ltype;
        -: 1301:    int old_pline_level, old_list_pipe, old_list_pipe_job;
        -: 1302:    char *old_list_pipe_text;
        -: 1303:    zlong oldlineno;
        -: 1304:    /*
        -: 1305:     * ERREXIT only forces the shell to exit if the last command in a &&
        -: 1306:     * or || fails.  This is the case even if an earlier command is a
        -: 1307:     * shell function or other current shell structure, so we have to set
        -: 1308:     * noerrexit here if the sublist is not of type END.
        -: 1309:     */
      606: 1310:    int oldnoerrexit = noerrexit;
        -: 1311:
      606: 1312:    queue_signals();
        -: 1313:
      606: 1314:    cj = thisjob;
      606: 1315:    old_pline_level = pline_level;
      606: 1316:    old_list_pipe = list_pipe;
      606: 1317:    old_list_pipe_job = list_pipe_job;
      606: 1318:    if (*list_pipe_text)
      536: 1319:	old_list_pipe_text = ztrdup(list_pipe_text);
        -: 1320:    else
       70: 1321:	old_list_pipe_text = NULL;
      606: 1322:    oldlineno = lineno;
        -: 1323:
      606: 1324:    if (sourcelevel && unset(SHINSTDIN)) {
    #####: 1325:	pline_level = list_pipe = list_pipe_job = 0;
    #####: 1326:	*list_pipe_text = '\0';
        -: 1327:    }
        -: 1328:
        -: 1329:    /* Loop over all sets of comands separated by newline, *
        -: 1330:     * semi-colon or ampersand (`sublists').               */
      606: 1331:    code = *state->pc++;
      606: 1332:    if (wc_code(code) != WC_LIST) {
        -: 1333:	/* Empty list; this returns status zero. */
        5: 1334:	lastval = 0;
        -: 1335:    }
     1786: 1336:    while (wc_code(code) == WC_LIST && !breaks && !retflag && !errflag) {
        -: 1337:	int donedebug;
     1163: 1338:	int this_donetrap = 0;
     1163: 1339:	this_noerrexit = 0;
        -: 1340:
     1163: 1341:	ltype = WC_LIST_TYPE(code);
     1163: 1342:	csp = cmdsp;
        -: 1343:
     1163: 1344:	if (!IN_EVAL_TRAP() && !ineval) {
        -: 1345:	    /*
        -: 1346:	     * Ensure we have a valid line number for debugging,
        -: 1347:	     * unless we are in an evaluated trap in which case
        -: 1348:	     * we retain the line number from the context.
        -: 1349:	     * This was added for DEBUGBEFORECMD but I've made
        -: 1350:	     * it unconditional to keep dependencies to a minimum.
        -: 1351:	     *
        -: 1352:	     * The line number is updated for individual pipelines.
        -: 1353:	     * This isn't necessary for debug traps since they only
        -: 1354:	     * run once per sublist.
        -: 1355:	     */
     1163: 1356:	    wordcode code2 = *state->pc, lnp1 = 0;
     1163: 1357:	    if (ltype & Z_SIMPLE) {
      335: 1358:		lnp1 = code2;
      828: 1359:	    } else if (wc_code(code2) == WC_SUBLIST) {
      828: 1360:		if (WC_SUBLIST_FLAGS(code2) == WC_SUBLIST_SIMPLE)
       54: 1361:		    lnp1 = state->pc[1];
        -: 1362:		else
      774: 1363:		    lnp1 = WC_PIPE_LINENO(state->pc[1]);
        -: 1364:	    }
     1163: 1365:	    if (lnp1)
     1163: 1366:		lineno = lnp1 - 1;
        -: 1367:	}
        -: 1368:
     1163: 1369:	if (sigtrapped[SIGDEBUG] && isset(DEBUGBEFORECMD) && !intrap) {
    #####: 1370:	    Wordcode pc2 = state->pc;
    #####: 1371:	    int oerrexit_opt = opts[ERREXIT];
        -: 1372:	    Param pm;
    #####: 1373:	    opts[ERREXIT] = 0;
    #####: 1374:	    noerrexit = NOERREXIT_EXIT | NOERREXIT_RETURN;
    #####: 1375:	    if (ltype & Z_SIMPLE) /* skip the line number */
    #####: 1376:		pc2++;
    #####: 1377:	    pm = assignsparam("ZSH_DEBUG_CMD",
        -: 1378:			      getpermtext(state->prog, pc2, 0),
        -: 1379:			      0);
        -: 1380:
    #####: 1381:	    exiting = donetrap;
    #####: 1382:	    ret = lastval;
    #####: 1383:	    dotrap(SIGDEBUG);
    #####: 1384:	    if (!retflag)
    #####: 1385:		lastval = ret;
    #####: 1386:	    donetrap = exiting;
    #####: 1387:	    noerrexit = oldnoerrexit;
        -: 1388:	    /*
        -: 1389:	     * Only execute the trap once per sublist, even
        -: 1390:	     * if the DEBUGBEFORECMD option changes.
        -: 1391:	     */
    #####: 1392:	    donedebug = isset(ERREXIT) ? 2 : 1;
    #####: 1393:	    opts[ERREXIT] = oerrexit_opt;
    #####: 1394:	    if (pm)
    #####: 1395:		unsetparam_pm(pm, 0, 1);
        -: 1396:	} else
     1163: 1397:	    donedebug = intrap ? 1 : 0;
        -: 1398:
        -: 1399:	/* Reset donetrap:  this ensures that a trap is only *
        -: 1400:	 * called once for each sublist that fails.          */
     1163: 1401:	donetrap = 0;
     1163: 1402:	if (ltype & Z_SIMPLE) {
      335: 1403:	    next = state->pc + WC_LIST_SKIP(code);
      335: 1404:	    if (donedebug != 2)
      335: 1405:		execsimple(state);
      335: 1406:	    state->pc = next;
      335: 1407:	    goto sublist_done;
        -: 1408:	}
        -: 1409:
        -: 1410:	/* Loop through code followed by &&, ||, or end of sublist. */
      828: 1411:	code = *state->pc++;
      828: 1412:	if (donedebug == 2) {
        -: 1413:	    /* Skip sublist. */
    #####: 1414:	    while (wc_code(code) == WC_SUBLIST) {
    #####: 1415:		state->pc = state->pc + WC_SUBLIST_SKIP(code);
    #####: 1416:		if (WC_SUBLIST_TYPE(code) == WC_SUBLIST_END)
    #####: 1417:		    break;
    #####: 1418:		code = *state->pc++;
        -: 1419:	    }
    #####: 1420:	    donetrap = 1;
        -: 1421:	    /* yucky but consistent... */
    #####: 1422:	    goto sublist_done;
        -: 1423:	}
     1704: 1424:	while (wc_code(code) == WC_SUBLIST) {
      876: 1425:	    int isend = (WC_SUBLIST_TYPE(code) == WC_SUBLIST_END);
      876: 1426:	    next = state->pc + WC_SUBLIST_SKIP(code);
      876: 1427:	    if (!oldnoerrexit)
      451: 1428:		noerrexit = isend ? 0 : NOERREXIT_EXIT | NOERREXIT_RETURN;
      876: 1429:	    if (WC_SUBLIST_FLAGS(code) & WC_SUBLIST_NOT) {
        -: 1430:		/* suppress errexit for "! this_command" */
       11: 1431:		if (isend)
        9: 1432:		    this_noerrexit = 1;
        -: 1433:		/* suppress errexit for ! <list-of-shell-commands> */
       11: 1434:		noerrexit = NOERREXIT_EXIT | NOERREXIT_RETURN;
        -: 1435:	    }
      876: 1436:	    switch (WC_SUBLIST_TYPE(code)) {
      770: 1437:	    case WC_SUBLIST_END:
        -: 1438:		/* End of sublist; just execute, ignoring status. */
      770: 1439:		if (WC_SUBLIST_FLAGS(code) & WC_SUBLIST_SIMPLE)
        1: 1440:		    execsimple(state);
        -: 1441:		else
      769: 1442:		    execpline(state, code, ltype, (ltype & Z_END) && exiting);
      763: 1443:		state->pc = next;
      763: 1444:		goto sublist_done;
        -: 1445:		break;
       23: 1446:	    case WC_SUBLIST_AND:
        -: 1447:		/* If the return code is non-zero, we skip pipelines until *
        -: 1448:		 * we find a sublist followed by ORNEXT.                   */
       46: 1449:		if ((ret = ((WC_SUBLIST_FLAGS(code) & WC_SUBLIST_SIMPLE) ?
       23: 1450:			    execsimple(state) :
        -: 1451:			    execpline(state, code, Z_SYNC, 0)))) {
       12: 1452:		    state->pc = next;
       12: 1453:		    code = *state->pc++;
       12: 1454:		    next = state->pc + WC_SUBLIST_SKIP(code);
       36: 1455:		    while (wc_code(code) == WC_SUBLIST &&
       12: 1456:			   WC_SUBLIST_TYPE(code) == WC_SUBLIST_AND) {
    #####: 1457:			state->pc = next;
    #####: 1458:			code = *state->pc++;
    #####: 1459:			next = state->pc + WC_SUBLIST_SKIP(code);
        -: 1460:		    }
       12: 1461:		    if (wc_code(code) != WC_SUBLIST) {
        -: 1462:			/* We've skipped to the end of the list, not executing *
        -: 1463:			 * the final pipeline, so don't perform error handling *
        -: 1464:			 * for this sublist.                                   */
    #####: 1465:			this_donetrap = 1;
    #####: 1466:			goto sublist_done;
       12: 1467:		    } else if (WC_SUBLIST_TYPE(code) == WC_SUBLIST_END) {
       12: 1468:			this_donetrap = 1;
        -: 1469:			/*
        -: 1470:			 * Treat this in the same way as if we reached
        -: 1471:			 * the end of the sublist normally.
        -: 1472:			 */
       12: 1473:			state->pc = next;
       12: 1474:			goto sublist_done;
        -: 1475:		    }
        -: 1476:		}
       11: 1477:		cmdpush(CS_CMDAND);
       11: 1478:		break;
       83: 1479:	    case WC_SUBLIST_OR:
        -: 1480:		/* If the return code is zero, we skip pipelines until *
        -: 1481:		 * we find a sublist followed by ANDNEXT.              */
      166: 1482:		if (!(ret = ((WC_SUBLIST_FLAGS(code) & WC_SUBLIST_SIMPLE) ?
       83: 1483:			     execsimple(state) :
        -: 1484:			     execpline(state, code, Z_SYNC, 0)))) {
       46: 1485:		    state->pc = next;
       46: 1486:		    code = *state->pc++;
       46: 1487:		    next = state->pc + WC_SUBLIST_SKIP(code);
      140: 1488:		    while (wc_code(code) == WC_SUBLIST &&
       47: 1489:			   WC_SUBLIST_TYPE(code) == WC_SUBLIST_OR) {
        1: 1490:			state->pc = next;
        1: 1491:			code = *state->pc++;
        1: 1492:			next = state->pc + WC_SUBLIST_SKIP(code);
        -: 1493:		    }
       46: 1494:		    if (wc_code(code) != WC_SUBLIST) {
        -: 1495:			/* We've skipped to the end of the list, not executing *
        -: 1496:			 * the final pipeline, so don't perform error handling *
        -: 1497:			 * for this sublist.                                   */
    #####: 1498:			this_donetrap = 1;
    #####: 1499:			goto sublist_done;
       46: 1500:		    } else if (WC_SUBLIST_TYPE(code) == WC_SUBLIST_END) {
       46: 1501:			this_donetrap = 1;
        -: 1502:			/*
        -: 1503:			 * Treat this in the same way as if we reached
        -: 1504:			 * the end of the sublist normally.
        -: 1505:			 */
       46: 1506:			state->pc = next;
       46: 1507:			goto sublist_done;
        -: 1508:		    }
        -: 1509:		}
       37: 1510:		cmdpush(CS_CMDOR);
       37: 1511:		break;
        -: 1512:	    }
       48: 1513:	    state->pc = next;
       48: 1514:	    code = *state->pc++;
        -: 1515:	}
    #####: 1516:	state->pc--;
     1156: 1517:sublist_done:
        -: 1518:
        -: 1519:	/*
        -: 1520:	 * See hairy code near the end of execif() for the
        -: 1521:	 * following.  "noerrexit " only applies until
        -: 1522:	 * we hit execcmd on the way down.  We're now
        -: 1523:	 * on the way back up, so don't restore it.
        -: 1524:	 */
     1156: 1525:	if (!(oldnoerrexit & NOERREXIT_UNTIL_EXEC))
     1156: 1526:	    noerrexit = oldnoerrexit;
        -: 1527:
     1156: 1528:	if (sigtrapped[SIGDEBUG] && !isset(DEBUGBEFORECMD) && !donedebug) {
        -: 1529:	    /*
        -: 1530:	     * Save and restore ERREXIT for consistency with
        -: 1531:	     * DEBUGBEFORECMD, even though it's not used.
        -: 1532:	     */
    #####: 1533:	    int oerrexit_opt = opts[ERREXIT];
    #####: 1534:	    opts[ERREXIT] = 0;
    #####: 1535:	    noerrexit = NOERREXIT_EXIT | NOERREXIT_RETURN;
    #####: 1536:	    exiting = donetrap;
    #####: 1537:	    ret = lastval;
    #####: 1538:	    dotrap(SIGDEBUG);
    #####: 1539:	    if (!retflag)
    #####: 1540:		lastval = ret;
    #####: 1541:	    donetrap = exiting;
    #####: 1542:	    noerrexit = oldnoerrexit;
    #####: 1543:	    opts[ERREXIT] = oerrexit_opt;
        -: 1544:	}
        -: 1545:
     1156: 1546:	cmdsp = csp;
        -: 1547:
        -: 1548:	/* Check whether we are suppressing traps/errexit *
        -: 1549:	 * (typically in init scripts) and if we haven't  *
        -: 1550:	 * already performed them for this sublist.       */
     1156: 1551:	if (!this_noerrexit && !donetrap && !this_donetrap) {
      785: 1552:	    if (sigtrapped[SIGZERR] && lastval &&
    #####: 1553:		!(noerrexit & NOERREXIT_EXIT)) {
    #####: 1554:		dotrap(SIGZERR);
    #####: 1555:		donetrap = 1;
        -: 1556:	    }
      785: 1557:	    if (lastval) {
      374: 1558:		int errreturn = isset(ERRRETURN) &&
      187: 1559:		    (isset(INTERACTIVE) || locallevel || sourcelevel) &&
    #####: 1560:		    !(noerrexit & NOERREXIT_RETURN);
      561: 1561:		int errexit = (isset(ERREXIT) ||
      187: 1562:			       (isset(ERRRETURN) && !errreturn)) &&
    #####: 1563:		    !(noerrexit & NOERREXIT_EXIT);
      187: 1564:		if (errexit) {
    #####: 1565:		    if (sigtrapped[SIGEXIT])
    #####: 1566:			dotrap(SIGEXIT);
    #####: 1567:		    if (mypid != getpid())
    #####: 1568:			_realexit();
        -: 1569:		    else
    #####: 1570:			realexit();
        -: 1571:		}
      187: 1572:		if (errreturn) {
    #####: 1573:		    retflag = 1;
    #####: 1574:		    breaks = loops;
        -: 1575:		}
        -: 1576:	    }
        -: 1577:	}
     1156: 1578:	if (ltype & Z_END)
      582: 1579:	    break;
      574: 1580:	code = *state->pc++;
        -: 1581:    }
      599: 1582:    pline_level = old_pline_level;
      599: 1583:    list_pipe = old_list_pipe;
      599: 1584:    list_pipe_job = old_list_pipe_job;
      599: 1585:    if (old_list_pipe_text) {
      531: 1586:	strcpy(list_pipe_text, old_list_pipe_text);
      531: 1587:	zsfree(old_list_pipe_text);
        -: 1588:    } else {
       68: 1589:	*list_pipe_text = '\0';
        -: 1590:    }
      599: 1591:    lineno = oldlineno;
      599: 1592:    if (dont_change_job)
      533: 1593:	thisjob = cj;
        -: 1594:
      599: 1595:    if (exiting && sigtrapped[SIGEXIT]) {
    #####: 1596:	dotrap(SIGEXIT);
        -: 1597:	/* Make sure this doesn't get executed again. */
    #####: 1598:	sigtrapped[SIGEXIT] = 0;
        -: 1599:    }
        -: 1600:
      599: 1601:    unqueue_signals();
      599: 1602:}
        -: 1603:
        -: 1604:/* Execute a pipeline.                                                *
        -: 1605: * last1 is a flag that this command is the last command in a shell   *
        -: 1606: * that is about to exit, so we can exec instead of forking.  It gets *
        -: 1607: * passed all the way down to execcmd() which actually makes the      *
        -: 1608: * decision.  A 0 is always passed if the command is not the last in  *
        -: 1609: * the pipeline.  This function assumes that the sublist is not NULL. *
        -: 1610: * If last1 is zero but the command is at the end of a pipeline, we   *
        -: 1611: * pass 2 down to execcmd().                                          *
        -: 1612: */
        -: 1613:
        -: 1614:/**/
        -: 1615:static int
      821: 1616:execpline(Estate state, wordcode slcode, int how, int last1)
        -: 1617:{
        -: 1618:    int ipipe[2], opipe[2];
        -: 1619:    int pj, newjob;
      821: 1620:    int old_simple_pline = simple_pline;
      821: 1621:    int slflags = WC_SUBLIST_FLAGS(slcode);
      821: 1622:    wordcode code = *state->pc++;
        -: 1623:    static int lastwj, lpforked;
        -: 1624:
      821: 1625:    if (wc_code(code) != WC_PIPE)
    #####: 1626:	return lastval = (slflags & WC_SUBLIST_NOT) != 0;
      821: 1627:    else if (slflags & WC_SUBLIST_NOT)
       11: 1628:	last1 = 0;
        -: 1629:
        -: 1630:    /* If trap handlers are allowed to run here, they may start another
        -: 1631:     * external job in the middle of us starting this one, which can
        -: 1632:     * result in jobs being reaped before their job table entries have
        -: 1633:     * been initialized, which in turn leads to waiting forever for
        -: 1634:     * jobs that no longer exist.  So don't do that.
        -: 1635:     */
      821: 1636:    queue_signals();
        -: 1637:
      821: 1638:    pj = thisjob;
      821: 1639:    ipipe[0] = ipipe[1] = opipe[0] = opipe[1] = 0;
      821: 1640:    child_block();
        -: 1641:
        -: 1642:    /*
        -: 1643:     * Get free entry in job table and initialize it.  This is currently
        -: 1644:     * the only call to initjob() (apart from a minor exception in
        -: 1645:     * clearjobtab()), so this is also the only place where we can
        -: 1646:     * expand the job table under us.
        -: 1647:     */
      821: 1648:    if ((thisjob = newjob = initjob()) == -1) {
    #####: 1649:	child_unblock();
    #####: 1650:	unqueue_signals();
    #####: 1651:	return 1;
        -: 1652:    }
      821: 1653:    if (how & Z_TIMED)
    #####: 1654:	jobtab[thisjob].stat |= STAT_TIMED;
        -: 1655:
      821: 1656:    if (slflags & WC_SUBLIST_COPROC) {
    #####: 1657:	how = Z_ASYNC;
    #####: 1658:	if (coprocin >= 0) {
    #####: 1659:	    zclose(coprocin);
    #####: 1660:	    zclose(coprocout);
        -: 1661:	}
    #####: 1662:	if (mpipe(ipipe) < 0) {
    #####: 1663:	    coprocin = coprocout = -1;
    #####: 1664:	    slflags &= ~WC_SUBLIST_COPROC;
    #####: 1665:	} else if (mpipe(opipe) < 0) {
    #####: 1666:	    close(ipipe[0]);
    #####: 1667:	    close(ipipe[1]);
    #####: 1668:	    coprocin = coprocout = -1;
    #####: 1669:	    slflags &= ~WC_SUBLIST_COPROC;
        -: 1670:	} else {
    #####: 1671:	    coprocin = ipipe[0];
    #####: 1672:	    coprocout = opipe[1];
    #####: 1673:	    fdtable[coprocin] = fdtable[coprocout] = FDT_UNUSED;
        -: 1674:	}
        -: 1675:    }
        -: 1676:    /* This used to set list_pipe_pid=0 unconditionally, but in things
        -: 1677:     * like `ls|if true; then sleep 20; cat; fi' where the sleep was
        -: 1678:     * stopped, the top-level execpline() didn't get the pid for the
        -: 1679:     * sub-shell because it was overwritten. */
      821: 1680:    if (!pline_level++) {
       34: 1681:        list_pipe_pid = 0;
       34: 1682:	nowait = 0;
       34: 1683:	simple_pline = (WC_PIPE_TYPE(code) == WC_PIPE_END);
       34: 1684:	list_pipe_job = newjob;
        -: 1685:    }
      821: 1686:    lastwj = lpforked = 0;
      821: 1687:    execpline2(state, code, how, opipe[0], ipipe[1], last1);
      814: 1688:    pline_level--;
      814: 1689:    if (how & Z_ASYNC) {
    #####: 1690:	lastwj = newjob;
        -: 1691:
    #####: 1692:        if (thisjob == list_pipe_job)
    #####: 1693:            list_pipe_job = 0;
    #####: 1694:	jobtab[thisjob].stat |= STAT_NOSTTY;
    #####: 1695:	if (slflags & WC_SUBLIST_COPROC) {
    #####: 1696:	    zclose(ipipe[1]);
    #####: 1697:	    zclose(opipe[0]);
        -: 1698:	}
    #####: 1699:	if (how & Z_DISOWN) {
    #####: 1700:	    pipecleanfilelist(jobtab[thisjob].filelist, 0);
    #####: 1701:	    deletejob(jobtab + thisjob, 1);
    #####: 1702:	    thisjob = -1;
        -: 1703:	}
        -: 1704:	else
    #####: 1705:	    spawnjob();
    #####: 1706:	child_unblock();
    #####: 1707:	unqueue_signals();
        -: 1708:	/* Executing background code resets shell status */
    #####: 1709:	return lastval = 0;
        -: 1710:    } else {
      814: 1711:	if (newjob != lastwj) {
      690: 1712:	    Job jn = jobtab + newjob;
        -: 1713:	    int updated;
        -: 1714:
      690: 1715:	    if (newjob == list_pipe_job && list_pipe_child)
    #####: 1716:		_exit(0);
        -: 1717:
      690: 1718:	    lastwj = thisjob = newjob;
        -: 1719:
     1348: 1720:	    if (list_pipe || (pline_level && !(how & Z_TIMED) &&
      658: 1721:			      !(jn->stat & STAT_NOSTTY)))
      658: 1722:		jn->stat |= STAT_NOPRINT;
        -: 1723:
      690: 1724:	    if (nowait) {
    #####: 1725:		if(!pline_level) {
        -: 1726:		    int jobsub;
        -: 1727:		    struct process *pn, *qn;
        -: 1728:
    #####: 1729:		    curjob = newjob;
        -: 1730:		    DPUTS(!list_pipe_pid, "invalid list_pipe_pid");
    #####: 1731:		    addproc(list_pipe_pid, list_pipe_text, 0,
        -: 1732:			    &list_pipe_start, -1, -1);
        -: 1733:
        -: 1734:		    /* If the super-job contains only the sub-shell, the
        -: 1735:		       sub-shell is the group leader. */
    #####: 1736:		    if (!jn->procs->next || lpforked == 2) {
    #####: 1737:			jn->gleader = list_pipe_pid;
    #####: 1738:			jn->stat |= STAT_SUBLEADER;
        -: 1739:			/*
        -: 1740:			 * Pick up any subjob that's still lying around
        -: 1741:			 * as it's now our responsibility.
        -: 1742:			 * If we find it we're a SUPERJOB.
        -: 1743:			 */
    #####: 1744:			for (jobsub = 1; jobsub <= maxjob; jobsub++) {
    #####: 1745:			    Job jnsub = jobtab + jobsub;
    #####: 1746:			    if (jnsub->stat & STAT_SUBJOB_ORPHANED) {
    #####: 1747:				jn->other = jobsub;
    #####: 1748:				jn->stat |= STAT_SUPERJOB;
    #####: 1749:				jnsub->stat &= ~STAT_SUBJOB_ORPHANED;
    #####: 1750:				jnsub->other = list_pipe_pid;
        -: 1751:			    }
        -: 1752:			}
        -: 1753:		    }
    #####: 1754:		    for (pn = jobtab[jn->other].procs; pn; pn = pn->next)
    #####: 1755:			if (WIFSTOPPED(pn->status))
    #####: 1756:			    break;
        -: 1757:
    #####: 1758:		    if (pn) {
    #####: 1759:			for (qn = jn->procs; qn->next; qn = qn->next);
    #####: 1760:			qn->status = pn->status;
        -: 1761:		    }
        -: 1762:
    #####: 1763:		    jn->stat &= ~(STAT_DONE | STAT_NOPRINT);
    #####: 1764:		    jn->stat |= STAT_STOPPED | STAT_CHANGED | STAT_LOCKED |
        -: 1765:			STAT_INUSE;
    #####: 1766:		    printjob(jn, !!isset(LONGLISTJOBS), 1);
        -: 1767:		}
    #####: 1768:		else if (newjob != list_pipe_job)
    #####: 1769:		    deletejob(jn, 0);
        -: 1770:		else
    #####: 1771:		    lastwj = -1;
        -: 1772:	    }
        -: 1773:
      690: 1774:	    errbrk_saved = 0;
     1380: 1775:	    for (; !nowait;) {
      690: 1776:		if (list_pipe_child) {
    #####: 1777:		    jn->stat |= STAT_NOPRINT;
    #####: 1778:		    makerunning(jn);
        -: 1779:		}
      690: 1780:		if (!(jn->stat & STAT_LOCKED)) {
      690: 1781:		    updated = hasprocs(thisjob);
      690: 1782:		    waitjobs();		/* deals with signal queue */
      690: 1783:		    child_block();
        -: 1784:		} else
    #####: 1785:		    updated = 0;
      690: 1786:		if (!updated &&
      669: 1787:		    list_pipe_job && hasprocs(list_pipe_job) &&
    #####: 1788:		    !(jobtab[list_pipe_job].stat & STAT_STOPPED)) {
    #####: 1789:		    int q = queue_signal_level();
    #####: 1790:		    child_unblock();
    #####: 1791:		    child_block();
    #####: 1792:		    dont_queue_signals();
    #####: 1793:		    restore_queue_signals(q);
        -: 1794:		}
      690: 1795:		if (list_pipe_child &&
    #####: 1796:		    jn->stat & STAT_DONE &&
    #####: 1797:		    lastval2 & 0200)
    #####: 1798:		    killpg(mypgrp, lastval2 & ~0200);
      690: 1799:		if (!list_pipe_child && !lpforked && !subsh && jobbing &&
    #####: 1800:		    (list_pipe || last1 || pline_level) &&
    #####: 1801:		    ((jn->stat & STAT_STOPPED) ||
    #####: 1802:		     (list_pipe_job && pline_level &&
    #####: 1803:		      (jobtab[list_pipe_job].stat & STAT_STOPPED)))) {
    #####: 1804:		    pid_t pid = 0;
        -: 1805:		    int synch[2];
        -: 1806:		    struct timeval bgtime;
        -: 1807:
        -: 1808:		    /*
        -: 1809:		     * A pipeline with the shell handling the right
        -: 1810:		     * hand side was stopped.  We'll fork to allow
        -: 1811:		     * it to continue.
        -: 1812:		     */
    #####: 1813:		    if (pipe(synch) < 0 || (pid = zfork(&bgtime)) == -1) {
        -: 1814:			/* Failure */
    #####: 1815:			if (pid < 0) {
    #####: 1816:			    close(synch[0]);
    #####: 1817:			    close(synch[1]);
        -: 1818:			} else
    #####: 1819:			    zerr("pipe failed: %e", errno);
    #####: 1820:			zleentry(ZLE_CMD_TRASH);
    #####: 1821:			fprintf(stderr, "zsh: job can't be suspended\n");
    #####: 1822:			fflush(stderr);
    #####: 1823:			makerunning(jn);
    #####: 1824:			killjb(jn, SIGCONT);
    #####: 1825:			thisjob = newjob;
        -: 1826:		    }
    #####: 1827:		    else if (pid) {
        -: 1828:			/*
        -: 1829:			 * Parent: job control is here.  If the job
        -: 1830:			 * started for the RHS of the pipeline is still
        -: 1831:			 * around, then its a SUBJOB and the job for
        -: 1832:			 * earlier parts of the pipeeline is its SUPERJOB.
        -: 1833:			 * The newly forked shell isn't recorded as a
        -: 1834:			 * separate job here, just as list_pipe_pid.
        -: 1835:			 * If the superjob exits (it may already have
        -: 1836:			 * done so, see child branch below), we'll use
        -: 1837:			 * list_pipe_pid to form the basis of a
        -: 1838:			 * replacement job --- see SUBLEADER code above.
        -: 1839:			 */
        -: 1840:			char dummy;
        -: 1841:
    #####: 1842:			lpforked =
    #####: 1843:			    (killpg(jobtab[list_pipe_job].gleader, 0) == -1 ? 2 : 1);
    #####: 1844:			list_pipe_pid = pid;
    #####: 1845:			list_pipe_start = bgtime;
    #####: 1846:			nowait = 1;
    #####: 1847:			errflag |= ERRFLAG_ERROR;
    #####: 1848:			breaks = loops;
    #####: 1849:			close(synch[1]);
    #####: 1850:			read_loop(synch[0], &dummy, 1);
    #####: 1851:			close(synch[0]);
        -: 1852:			/* If this job has finished, we leave it as a
        -: 1853:			 * normal (non-super-) job. */
    #####: 1854:			if (!(jn->stat & STAT_DONE)) {
    #####: 1855:			    jobtab[list_pipe_job].other = newjob;
    #####: 1856:			    jobtab[list_pipe_job].stat |= STAT_SUPERJOB;
    #####: 1857:			    jn->stat |= STAT_SUBJOB | STAT_NOPRINT;
    #####: 1858:			    jn->other = list_pipe_pid;	/* see zsh.h */
    #####: 1859:			    if (hasprocs(list_pipe_job))
    #####: 1860:				jn->gleader = jobtab[list_pipe_job].gleader;
        -: 1861:			}
    #####: 1862:			if ((list_pipe || last1) && hasprocs(list_pipe_job))
    #####: 1863:			    killpg(jobtab[list_pipe_job].gleader, SIGSTOP);
    #####: 1864:			break;
        -: 1865:		    }
        -: 1866:		    else {
    #####: 1867:			close(synch[0]);
    #####: 1868:			entersubsh(ESUB_ASYNC, NULL);
        -: 1869:			/*
        -: 1870:			 * At this point, we used to attach this process
        -: 1871:			 * to the process group of list_pipe_job (the
        -: 1872:			 * new superjob) any time that was still available.
        -: 1873:			 * That caused problems in at least two
        -: 1874:			 * cases because this forked shell was then
        -: 1875:			 * suspended with the right hand side of the
        -: 1876:			 * pipeline, and the SIGSTOP below suspended
        -: 1877:			 * it a second time when it was continued.
        -: 1878:			 *
        -: 1879:			 * It's therefore not clear entirely why you'd ever
        -: 1880:			 * do anything other than the following, but no
        -: 1881:			 * doubt we'll find out...
        -: 1882:			 */
    #####: 1883:			setpgrp(0L, mypgrp = getpid());
    #####: 1884:			close(synch[1]);
    #####: 1885:			kill(getpid(), SIGSTOP);
    #####: 1886:			list_pipe = 0;
    #####: 1887:			list_pipe_child = 1;
    #####: 1888:			opts[INTERACTIVE] = 0;
    #####: 1889:			if (errbrk_saved) {
        -: 1890:			    /*
        -: 1891:			     * Keep any user interrupt bit in errflag.
        -: 1892:			     */
    #####: 1893:			    errflag = prev_errflag | (errflag & ERRFLAG_INT);
    #####: 1894:			    breaks = prev_breaks;
        -: 1895:			}
    #####: 1896:			break;
        -: 1897:		    }
        -: 1898:		}
      690: 1899:		else if (subsh && jn->stat & STAT_STOPPED)
    #####: 1900:		    thisjob = newjob;
        -: 1901:		else
        -: 1902:		    break;
        -: 1903:	    }
      690: 1904:	    child_unblock();
      690: 1905:	    unqueue_signals();
        -: 1906:
      690: 1907:	    if (list_pipe && (lastval & 0200) && pj >= 0 &&
    #####: 1908:		(!(jn->stat & STAT_INUSE) || (jn->stat & STAT_DONE))) {
    #####: 1909:		deletejob(jn, 0);
    #####: 1910:		jn = jobtab + pj;
    #####: 1911:		if (jn->gleader)
    #####: 1912:		    killjb(jn, lastval & ~0200);
        -: 1913:	    }
     1380: 1914:	    if (list_pipe_child ||
      690: 1915:		((jn->stat & STAT_DONE) &&
    #####: 1916:		 (list_pipe || (pline_level && !(jn->stat & STAT_SUBJOB)))))
    #####: 1917:		deletejob(jn, 0);
      690: 1918:	    thisjob = pj;
        -: 1919:	}
        -: 1920:	else
      124: 1921:	    unqueue_signals();
      814: 1922:	if ((slflags & WC_SUBLIST_NOT) && !errflag)
       11: 1923:	    lastval = !lastval;
        -: 1924:    }
      814: 1925:    if (!pline_level)
       32: 1926:	simple_pline = old_simple_pline;
      814: 1927:    return lastval;
        -: 1928:}
        -: 1929:
        -: 1930:/* execute pipeline.  This function assumes the `pline' is not NULL. */
        -: 1931:
        -: 1932:/**/
        -: 1933:static void
      821: 1934:execpline2(Estate state, wordcode pcode,
        -: 1935:	   int how, int input, int output, int last1)
        -: 1936:{
        -: 1937:    struct execcmd_params eparams;
        -: 1938:
      821: 1939:    if (breaks || retflag)
    #####: 1940:	return;
        -: 1941:
        -: 1942:    /* In evaluated traps, don't modify the line number. */
      821: 1943:    if (!IN_EVAL_TRAP() && !ineval && WC_PIPE_LINENO(pcode))
      821: 1944:	lineno = WC_PIPE_LINENO(pcode) - 1;
        -: 1945:
      821: 1946:    if (pline_level == 1) {
       34: 1947:	if ((how & Z_ASYNC) || !sfcontext)
       34: 1948:	    strcpy(list_pipe_text,
       34: 1949:		   getjobtext(state->prog,
       68: 1950:			      state->pc + (WC_PIPE_TYPE(pcode) == WC_PIPE_END ?
       34: 1951:					   0 : 1)));
        -: 1952:	else
    #####: 1953:	    list_pipe_text[0] = '\0';
        -: 1954:    }
      821: 1955:    if (WC_PIPE_TYPE(pcode) == WC_PIPE_END) {
      821: 1956:	execcmd_analyse(state, &eparams);
      821: 1957:	execcmd_exec(state, &eparams, input, output, how, last1 ? 1 : 2, -1);
        -: 1958:    } else {
        -: 1959:	int pipes[2];
    #####: 1960:	int old_list_pipe = list_pipe;
    #####: 1961:	Wordcode next = state->pc + (*state->pc);
        -: 1962:
    #####: 1963:	++state->pc;
    #####: 1964:	execcmd_analyse(state, &eparams);
        -: 1965:
    #####: 1966:	if (mpipe(pipes) < 0) {
        -: 1967:	    /* FIXME */
        -: 1968:	}
        -: 1969:
    #####: 1970:	addfilelist(NULL, pipes[0]);
    #####: 1971:	execcmd_exec(state, &eparams, input, pipes[1], how, 0, pipes[0]);
    #####: 1972:	zclose(pipes[1]);
    #####: 1973:	state->pc = next;
        -: 1974:
        -: 1975:	/* if another execpline() is invoked because the command is *
        -: 1976:	 * a list it must know that we're already in a pipeline     */
    #####: 1977:	cmdpush(CS_PIPE);
    #####: 1978:	list_pipe = 1;
    #####: 1979:	execpline2(state, *state->pc++, how, pipes[0], output, last1);
    #####: 1980:	list_pipe = old_list_pipe;
    #####: 1981:	cmdpop();
        -: 1982:    }
        -: 1983:}
        -: 1984:
        -: 1985:/* make the argv array */
        -: 1986:
        -: 1987:/**/
        -: 1988:static char **
       26: 1989:makecline(LinkList list)
        -: 1990:{
        -: 1991:    LinkNode node;
        -: 1992:    char **argv, **ptr;
        -: 1993:
        -: 1994:    /* A bigger argv is necessary for executing scripts */
       26: 1995:    ptr = argv = 2 + (char **) hcalloc((countlinknodes(list) + 4) *
        -: 1996:				       sizeof(char *));
        -: 1997:
       26: 1998:    if (isset(XTRACE)) {
    #####: 1999:	if (!doneps4)
    #####: 2000:	    printprompt4();
        -: 2001:
    #####: 2002:	for (node = firstnode(list); node; incnode(node)) {
    #####: 2003:	    *ptr++ = (char *)getdata(node);
    #####: 2004:	    quotedzputs(getdata(node), xtrerr);
    #####: 2005:	    if (nextnode(node))
    #####: 2006:		fputc(' ', xtrerr);
        -: 2007:	}
    #####: 2008:	fputc('\n', xtrerr);
    #####: 2009:	fflush(xtrerr);
        -: 2010:    } else {
      133: 2011:	for (node = firstnode(list); node; incnode(node))
      107: 2012:	    *ptr++ = (char *)getdata(node);
        -: 2013:    }
       26: 2014:    *ptr = NULL;
       26: 2015:    return (argv);
        -: 2016:}
        -: 2017:
        -: 2018:/**/
        -: 2019:mod_export void
     8234: 2020:untokenize(char *s)
        -: 2021:{
     8234: 2022:    if (*s) {
        -: 2023:	int c;
        -: 2024:
    76168: 2025:	while ((c = *s++))
    60124: 2026:	    if (itok(c)) {
      242: 2027:		char *p = s - 1;
        -: 2028:
      242: 2029:		if (c != Nularg)
      214: 2030:		    *p++ = ztokens[c - Pound];
        -: 2031:
     1606: 2032:		while ((c = *s++)) {
     1122: 2033:		    if (itok(c)) {
      209: 2034:			if (c != Nularg)
      209: 2035:			    *p++ = ztokens[c - Pound];
        -: 2036:		    } else
      913: 2037:			*p++ = c;
        -: 2038:		}
      242: 2039:		*p = '\0';
      242: 2040:		break;
        -: 2041:	    }
        -: 2042:    }
     8234: 2043:}
        -: 2044:
        -: 2045:
        -: 2046:/*
        -: 2047: * Given a tokenized string, output it to standard output in
        -: 2048: * such a way that it's clear which tokens are active.
        -: 2049: * Hence Star becomes an unquoted "*", while a "*" becomes "\*".
        -: 2050: *
        -: 2051: * The code here is a kind of amalgamation of the tests in
        -: 2052: * zshtokenize() and untokenize() with some outputting.
        -: 2053: */
        -: 2054:
        -: 2055:/**/
        -: 2056:void
    #####: 2057:quote_tokenized_output(char *str, FILE *file)
        -: 2058:{
    #####: 2059:    char *s = str;
        -: 2060:
    #####: 2061:    for (; *s; s++) {
    #####: 2062:	switch (*s) {
    #####: 2063:	case Meta:
    #####: 2064:	    putc(*++s ^ 32, file);
    #####: 2065:	    continue;
        -: 2066:
    #####: 2067:	case Nularg:
        -: 2068:	    /* Do nothing.  I think. */
    #####: 2069:	    continue;
        -: 2070:
    #####: 2071:	case '\\':
        -: 2072:	case '<':
        -: 2073:	case '>':
        -: 2074:	case '(':
        -: 2075:	case '|':
        -: 2076:	case ')':
        -: 2077:	case '^':
        -: 2078:	case '#':
        -: 2079:	case '~':
        -: 2080:	case '[':
        -: 2081:	case ']':
        -: 2082:	case '*':
        -: 2083:	case '?':
        -: 2084:	case '$':
        -: 2085:	case ' ':
    #####: 2086:	    putc('\\', file);
    #####: 2087:	    break;
        -: 2088:
    #####: 2089:	case '\t':
    #####: 2090:	    fputs("$'\\t'", file);
    #####: 2091:	    continue;
        -: 2092:
    #####: 2093:	case '\n':
    #####: 2094:	    fputs("$'\\n'", file);
    #####: 2095:	    continue;
        -: 2096:
    #####: 2097:	case '\r':
    #####: 2098:	    fputs("$'\\r'", file);
    #####: 2099:	    continue;
        -: 2100:
    #####: 2101:	case '=':
    #####: 2102:	    if (s == str)
    #####: 2103:		putc('\\', file);
    #####: 2104:	    break;
        -: 2105:
    #####: 2106:	default:
    #####: 2107:	    if (itok(*s)) {
    #####: 2108:		putc(ztokens[*s - Pound], file);
    #####: 2109:		continue;
        -: 2110:	    }
    #####: 2111:	    break;
        -: 2112:	}
        -: 2113:
    #####: 2114:	putc(*s, file);
        -: 2115:    }
    #####: 2116:}
        -: 2117:
        -: 2118:/* Check that we can use a parameter for allocating a file descriptor. */
        -: 2119:
        -: 2120:static int
       25: 2121:checkclobberparam(struct redir *f)
        -: 2122:{
        -: 2123:    struct value vbuf;
        -: 2124:    Value v;
       25: 2125:    char *s = f->varid;
        -: 2126:    int fd;
        -: 2127:
       25: 2128:    if (!s)
       23: 2129:	return 1;
        -: 2130:
        2: 2131:    if (!(v = getvalue(&vbuf, &s, 0)))
        2: 2132:	return 1;
        -: 2133:
    #####: 2134:    if (v->pm->node.flags & PM_READONLY) {
    #####: 2135:	zwarn("can't allocate file descriptor to readonly parameter %s",
        -: 2136:	      f->varid);
        -: 2137:	/* don't flag a system error for this */
    #####: 2138:	errno = 0;
    #####: 2139:	return 0;
        -: 2140:    }
        -: 2141:
        -: 2142:    /*
        -: 2143:     * We can't clobber the value in the parameter if it's
        -: 2144:     * already an opened file descriptor --- that means it's a decimal
        -: 2145:     * integer corresponding to an opened file descriptor,
        -: 2146:     * not merely an expression that evaluates to a file descriptor.
        -: 2147:     */
    #####: 2148:    if (!isset(CLOBBER) && (s = getstrvalue(v)) &&
    #####: 2149:	(fd = (int)zstrtol(s, &s, 10)) >= 0 && !*s &&
    #####: 2150:	fd <= max_zsh_fd && fdtable[fd] == FDT_EXTERNAL) {
    #####: 2151:	zwarn("can't clobber parameter %s containing file descriptor %d",
        -: 2152:	     f->varid, fd);
        -: 2153:	/* don't flag a system error for this */
    #####: 2154:	errno = 0;
    #####: 2155:	return 0;
        -: 2156:    }
    #####: 2157:    return 1;
        -: 2158:}
        -: 2159:
        -: 2160:/* Open a file for writing redirection */
        -: 2161:
        -: 2162:/**/
        -: 2163:static int
       10: 2164:clobber_open(struct redir *f)
        -: 2165:{
        -: 2166:    struct stat buf;
        -: 2167:    int fd, oerrno;
       10: 2168:    char *ufname = unmeta(f->name);
        -: 2169:
        -: 2170:    /* If clobbering, just open. */
       10: 2171:    if (isset(CLOBBER) || IS_CLOBBER_REDIR(f->type))
       10: 2172:	return open(ufname,
        -: 2173:		O_WRONLY | O_CREAT | O_TRUNC | O_NOCTTY, 0666);
        -: 2174:
        -: 2175:    /* If not clobbering, attempt to create file exclusively. */
    #####: 2176:    if ((fd = open(ufname,
        -: 2177:		   O_WRONLY | O_CREAT | O_EXCL | O_NOCTTY, 0666)) >= 0)
    #####: 2178:	return fd;
        -: 2179:
        -: 2180:    /* If that fails, we are still allowed to open non-regular files. *
        -: 2181:     * Try opening, and if it's a regular file then close it again    *
        -: 2182:     * because we weren't supposed to open it.                        */
    #####: 2183:    oerrno = errno;
    #####: 2184:    if ((fd = open(ufname, O_WRONLY | O_NOCTTY)) != -1) {
    #####: 2185:	if(!fstat(fd, &buf)) {
    #####: 2186:	    if (!S_ISREG(buf.st_mode))
    #####: 2187:		return fd;
        -: 2188:	    /*
        -: 2189:	     * If CLOBBER_EMPTY is in effect and the file is empty,
        -: 2190:	     * we are allowed to re-use it.
        -: 2191:	     *
        -: 2192:	     * Note: there is an intrinsic race here because another
        -: 2193:	     * process can write to this file at any time.  The only fix
        -: 2194:	     * would be file locking, which we wish to avoid in basic
        -: 2195:	     * file operations at this level.  This would not be
        -: 2196:	     * fixed. just additionally complicated, by re-opening the
        -: 2197:	     * file and truncating.
        -: 2198:	     */
    #####: 2199:	    if (isset(CLOBBEREMPTY) && buf.st_size == 0)
    #####: 2200:		return fd;
        -: 2201:	}
    #####: 2202:	close(fd);
        -: 2203:    }
        -: 2204:
    #####: 2205:    errno = oerrno;
    #####: 2206:    return -1;
        -: 2207:}
        -: 2208:
        -: 2209:/* size of buffer for tee and cat processes */
        -: 2210:#define TCBUFSIZE 4092
        -: 2211:
        -: 2212:/* close an multio (success) */
        -: 2213:
        -: 2214:/**/
        -: 2215:static void
        1: 2216:closemn(struct multio **mfds, int fd, int type)
        -: 2217:{
        1: 2218:    if (fd >= 0 && mfds[fd] && mfds[fd]->ct >= 2) {
    #####: 2219:	struct multio *mn = mfds[fd];
        -: 2220:	char buf[TCBUFSIZE];
        -: 2221:	int len, i;
        -: 2222:	pid_t pid;
        -: 2223:	struct timeval bgtime;
        -: 2224:
        -: 2225:	/*
        -: 2226:	 * We need to block SIGCHLD in case the process
        -: 2227:	 * we are spawning terminates before the job table
        -: 2228:	 * is set up to handle it.
        -: 2229:	 */
    #####: 2230:	child_block();
    #####: 2231:	if ((pid = zfork(&bgtime))) {
    #####: 2232:	    for (i = 0; i < mn->ct; i++)
    #####: 2233:		zclose(mn->fds[i]);
    #####: 2234:	    zclose(mn->pipe);
    #####: 2235:	    if (pid == -1) {
    #####: 2236:		mfds[fd] = NULL;
    #####: 2237:		child_unblock();
    #####: 2238:		return;
        -: 2239:	    }
    #####: 2240:	    mn->ct = 1;
    #####: 2241:	    mn->fds[0] = fd;
    #####: 2242:	    addproc(pid, NULL, 1, &bgtime, -1, -1);
    #####: 2243:	    child_unblock();
    #####: 2244:	    return;
        -: 2245:	}
        -: 2246:	/* pid == 0 */
    #####: 2247:	child_unblock();
    #####: 2248:	closeallelse(mn);
    #####: 2249:	if (mn->rflag) {
        -: 2250:	    /* tee process */
    #####: 2251:	    while ((len = read(mn->pipe, buf, TCBUFSIZE)) != 0) {
    #####: 2252:		if (len < 0) {
    #####: 2253:		    if (errno == EINTR)
    #####: 2254:			continue;
        -: 2255:		    else
    #####: 2256:			break;
        -: 2257:		}
    #####: 2258:		for (i = 0; i < mn->ct; i++)
    #####: 2259:		    write_loop(mn->fds[i], buf, len);
        -: 2260:	    }
        -: 2261:	} else {
        -: 2262:	    /* cat process */
    #####: 2263:	    for (i = 0; i < mn->ct; i++)
    #####: 2264:		while ((len = read(mn->fds[i], buf, TCBUFSIZE)) != 0) {
    #####: 2265:		    if (len < 0) {
    #####: 2266:			if (errno == EINTR)
    #####: 2267:			    continue;
        -: 2268:			else
    #####: 2269:			    break;
        -: 2270:		    }
    #####: 2271:		    write_loop(mn->pipe, buf, len);
        -: 2272:		}
        -: 2273:	}
    #####: 2274:	_exit(0);
        1: 2275:    } else if (fd >= 0 && type == REDIR_CLOSE)
    #####: 2276:	mfds[fd] = NULL;
        -: 2277:}
        -: 2278:
        -: 2279:/* close all the mnodes (failure) */
        -: 2280:
        -: 2281:/**/
        -: 2282:static void
    #####: 2283:closemnodes(struct multio **mfds)
        -: 2284:{
        -: 2285:    int i, j;
        -: 2286:
    #####: 2287:    for (i = 0; i < 10; i++)
    #####: 2288:	if (mfds[i]) {
    #####: 2289:	    for (j = 0; j < mfds[i]->ct; j++)
    #####: 2290:		zclose(mfds[i]->fds[j]);
    #####: 2291:	    mfds[i] = NULL;
        -: 2292:	}
    #####: 2293:}
        -: 2294:
        -: 2295:/**/
        -: 2296:static void
    #####: 2297:closeallelse(struct multio *mn)
        -: 2298:{
        -: 2299:    int i, j;
        -: 2300:    long openmax;
        -: 2301:
    #####: 2302:    openmax = fdtable_size;
        -: 2303:
    #####: 2304:    for (i = 0; i < openmax; i++)
    #####: 2305:	if (mn->pipe != i) {
    #####: 2306:	    for (j = 0; j < mn->ct; j++)
    #####: 2307:		if (mn->fds[j] == i)
    #####: 2308:		    break;
    #####: 2309:	    if (j == mn->ct)
    #####: 2310:		zclose(i);
        -: 2311:	}
    #####: 2312:}
        -: 2313:
        -: 2314:/*
        -: 2315: * A multio is a list of fds associated with a certain fd.
        -: 2316: * Thus if you do "foo >bar >ble", the multio for fd 1 will have
        -: 2317: * two fds, the result of open("bar",...), and the result of
        -: 2318: * open("ble",....).
        -: 2319: */
        -: 2320:
        -: 2321:/*
        -: 2322: * Add a fd to an multio.  fd1 must be < 10, and may be in any state.
        -: 2323: * fd2 must be open, and is `consumed' by this function.  Note that
        -: 2324: * fd1 == fd2 is possible, and indicates that fd1 was really closed.
        -: 2325: * We effectively do `fd2 = movefd(fd2)' at the beginning of this
        -: 2326: * function, but in most cases we can avoid an extra dup by delaying
        -: 2327: * the movefd: we only >need< to move it if we're actually doing a
        -: 2328: * multiple redirection.
        -: 2329: *
        -: 2330: * If varid is not NULL, we open an fd above 10 and set the parameter
        -: 2331: * named varid to that value.  fd1 is not used.
        -: 2332: */
        -: 2333:
        -: 2334:/**/
        -: 2335:static void
       25: 2336:addfd(int forked, int *save, struct multio **mfds, int fd1, int fd2, int rflag,
        -: 2337:      char *varid)
        -: 2338:{
        -: 2339:    int pipes[2];
        -: 2340:
       25: 2341:    if (varid) {
        -: 2342:	/* fd will be over 10, don't touch mfds */
        2: 2343:	fd1 = movefd(fd2);
        2: 2344:	if (fd1 == -1) {
    #####: 2345:	    zerr("cannot moved fd %d: %e", fd2, errno);
    #####: 2346:	    return;
        -: 2347:	} else {
        2: 2348:	    fdtable[fd1] = FDT_EXTERNAL;
        2: 2349:	    setiparam(varid, (zlong)fd1);
        -: 2350:	    /*
        -: 2351:	     * If setting the parameter failed, close the fd else
        -: 2352:	     * it will leak.
        -: 2353:	     */
        2: 2354:	    if (errflag)
    #####: 2355:		zclose(fd1);
        -: 2356:	}
       23: 2357:    } else if (!mfds[fd1] || unset(MULTIOS)) {
       23: 2358:	if(!mfds[fd1]) {		/* starting a new multio */
       23: 2359:	    mfds[fd1] = (struct multio *) zhalloc(sizeof(struct multio));
       23: 2360:	    if (!forked && save[fd1] == -2) {
       20: 2361:		if (fd1 == fd2)
    #####: 2362:		    save[fd1] = -1;
        -: 2363:		else {
       20: 2364:		    int fdN = movefd(fd1);
        -: 2365:		    /*
        -: 2366:		     * fd1 may already be closed here, so
        -: 2367:		     * ignore bad file descriptor error
        -: 2368:		     */
       20: 2369:		    if (fdN < 0) {
    #####: 2370:			if (errno != EBADF) {
    #####: 2371:			    zerr("cannot duplicate fd %d: %e", fd1, errno);
    #####: 2372:			    mfds[fd1] = NULL;
    #####: 2373:			    closemnodes(mfds);
    #####: 2374:			    return;
        -: 2375:			}
        -: 2376:		    } else {
        -: 2377:			DPUTS(fdtable[fdN] != FDT_INTERNAL,
        -: 2378:			      "Saved file descriptor not marked as internal");
       20: 2379:			fdtable[fdN] |= FDT_SAVED_MASK;
        -: 2380:		    }
       20: 2381:		    save[fd1] = fdN;
        -: 2382:		}
        -: 2383:	    }
        -: 2384:	}
       23: 2385:	if (!varid)
       23: 2386:	    redup(fd2, fd1);
       23: 2387:	mfds[fd1]->ct = 1;
       23: 2388:	mfds[fd1]->fds[0] = fd1;
       23: 2389:	mfds[fd1]->rflag = rflag;
        -: 2390:    } else {
    #####: 2391:	if (mfds[fd1]->rflag != rflag) {
    #####: 2392:	    zerr("file mode mismatch on fd %d", fd1);
    #####: 2393:	    closemnodes(mfds);
    #####: 2394:	    return;
        -: 2395:	}
    #####: 2396:	if (mfds[fd1]->ct == 1) {	/* split the stream */
    #####: 2397:	    int fdN = movefd(fd1);
    #####: 2398:	    if (fdN < 0) {
    #####: 2399:		zerr("multio failed for fd %d: %e", fd1, errno);
    #####: 2400:		closemnodes(mfds);
    #####: 2401:		return;
        -: 2402:	    }
    #####: 2403:	    mfds[fd1]->fds[0] = fdN;
    #####: 2404:	    fdN = movefd(fd2);
    #####: 2405:	    if (fdN < 0) {
    #####: 2406:		zerr("multio failed for fd %d: %e", fd2, errno);
    #####: 2407:		closemnodes(mfds);
    #####: 2408:		return;
        -: 2409:	    }
    #####: 2410:	    mfds[fd1]->fds[1] = fdN;
    #####: 2411:	    if (mpipe(pipes) < 0) {
    #####: 2412:		zerr("multio failed for fd %d: %e", fd2, errno);
    #####: 2413:		closemnodes(mfds);
    #####: 2414:		return;
        -: 2415:	    }
    #####: 2416:	    mfds[fd1]->pipe = pipes[1 - rflag];
    #####: 2417:	    redup(pipes[rflag], fd1);
    #####: 2418:	    mfds[fd1]->ct = 2;
        -: 2419:	} else {		/* add another fd to an already split stream */
        -: 2420:	    int fdN;
    #####: 2421:	    if(!(mfds[fd1]->ct % MULTIOUNIT)) {
    #####: 2422:		int new = sizeof(struct multio) + sizeof(int) * mfds[fd1]->ct;
    #####: 2423:		int old = new - sizeof(int) * MULTIOUNIT;
    #####: 2424:		mfds[fd1] = hrealloc((char *)mfds[fd1], old, new);
        -: 2425:	    }
    #####: 2426:	    if ((fdN = movefd(fd2)) < 0) {
    #####: 2427:		zerr("multio failed for fd %d: %e", fd2, errno);
    #####: 2428:		closemnodes(mfds);
    #####: 2429:		return;
        -: 2430:	    }
    #####: 2431:	    mfds[fd1]->fds[mfds[fd1]->ct++] = fdN;
        -: 2432:	}
        -: 2433:    }
        -: 2434:}
        -: 2435:
        -: 2436:/**/
        -: 2437:static void
      156: 2438:addvars(Estate state, Wordcode pc, int addflags)
        -: 2439:{
        -: 2440:    LinkList vl;
      156: 2441:    int xtr, isstr, htok = 0;
        -: 2442:    char **arr, **ptr, *name;
        -: 2443:    int flags;
        -: 2444:
      156: 2445:    Wordcode opc = state->pc;
        -: 2446:    wordcode ac;
        -: 2447:    local_list1(svl);
        -: 2448:
        -: 2449:    /*
        -: 2450:     * Warn when creating a global without using typeset -g in a
        -: 2451:     * function.  Don't do this if there is a list of variables marked
        -: 2452:     * to be restored after the command, since then the assignment
        -: 2453:     * is implicitly scoped.
        -: 2454:     */
      156: 2455:    flags = !(addflags & ADDVAR_RESTORE) ? ASSPM_WARN : 0;
      156: 2456:    xtr = isset(XTRACE);
      156: 2457:    if (xtr) {
    #####: 2458:	printprompt4();
    #####: 2459:	doneps4 = 1;
        -: 2460:    }
      156: 2461:    state->pc = pc;
      468: 2462:    while (wc_code(ac = *state->pc++) == WC_ASSIGN) {
      156: 2463:	int myflags = flags;
      156: 2464:	name = ecgetstr(state, EC_DUPTOK, &htok);
      156: 2465:	if (htok)
        2: 2466:	    untokenize(name);
      156: 2467:	if (WC_ASSIGN_TYPE2(ac) == WC_ASSIGN_INC)
    #####: 2468:	    myflags |= ASSPM_AUGMENT;
      156: 2469:	if (xtr)
    #####: 2470:	    fprintf(xtrerr,
    #####: 2471:		WC_ASSIGN_TYPE2(ac) == WC_ASSIGN_INC ? "%s+=" : "%s=", name);
      156: 2472:	if ((isstr = (WC_ASSIGN_TYPE(ac) == WC_ASSIGN_SCALAR))) {
      131: 2473:	    init_list1(svl, ecgetstr(state, EC_DUPTOK, &htok));
      131: 2474:	    vl = &svl;
        -: 2475:	} else {
       25: 2476:	    vl = ecgetlist(state, WC_ASSIGN_NUM(ac), EC_DUPTOK, &htok);
       25: 2477:	    if (errflag) {
    #####: 2478:		state->pc = opc;
    #####: 2479:		return;
        -: 2480:	    }
        -: 2481:	}
        -: 2482:
      156: 2483:	if (vl && htok) {
      110: 2484:	    int prefork_ret = 0;
      110: 2485:	    prefork(vl, (isstr ? (PREFORK_SINGLE|PREFORK_ASSIGN) :
        -: 2486:			 PREFORK_ASSIGN), &prefork_ret);
      110: 2487:	    if (errflag) {
    #####: 2488:		state->pc = opc;
    #####: 2489:		return;
        -: 2490:	    }
      110: 2491:	    if (prefork_ret & PREFORK_KEY_VALUE)
    #####: 2492:		myflags |= ASSPM_KEY_VALUE;
      110: 2493:	    if (!isstr || (isset(GLOBASSIGN) && isstr &&
    #####: 2494:			   haswilds((char *)getdata(firstnode(vl))))) {
       24: 2495:		globlist(vl, prefork_ret);
        -: 2496:		/* Unset the parameter to force it to be recreated
        -: 2497:		 * as either scalar or array depending on how many
        -: 2498:		 * matches were found for the glob.
        -: 2499:		 */
       24: 2500:		if (isset(GLOBASSIGN) && isstr)
    #####: 2501:			unsetparam(name);
       24: 2502:		if (errflag) {
    #####: 2503:		    state->pc = opc;
    #####: 2504:		    return;
        -: 2505:		}
        -: 2506:	    }
        -: 2507:	}
      156: 2508:	if (isstr && (empty(vl) || !nextnode(firstnode(vl)))) {
        -: 2509:	    Param pm;
        -: 2510:	    char *val;
        -: 2511:	    int allexp;
        -: 2512:
      131: 2513:	    if (empty(vl))
    #####: 2514:		val = ztrdup("");
        -: 2515:	    else {
      131: 2516:		untokenize(peekfirst(vl));
      131: 2517:		val = ztrdup(ugetnode(vl));
        -: 2518:	    }
      131: 2519:	    if (xtr) {
    #####: 2520:		quotedzputs(val, xtrerr);
    #####: 2521:		fputc(' ', xtrerr);
        -: 2522:	    }
      131: 2523:	    if ((addflags & ADDVAR_EXPORT) && !strchr(name, '[')) {
        3: 2524:		if ((addflags & ADDVAR_RESTRICT) && isset(RESTRICTED) &&
    #####: 2525:		    (pm = (Param) paramtab->removenode(paramtab, name)) &&
    #####: 2526:		    (pm->node.flags & PM_RESTRICTED)) {
    #####: 2527:		    zerr("%s: restricted", pm->node.nam);
    #####: 2528:		    zsfree(val);
    #####: 2529:		    state->pc = opc;
    #####: 2530:		    return;
        -: 2531:		}
        3: 2532:		if (strcmp(name, "STTY") == 0) {
    #####: 2533:		    zsfree(STTYval);
    #####: 2534:		    STTYval = ztrdup(val);
        -: 2535:		}
        3: 2536:		allexp = opts[ALLEXPORT];
        3: 2537:		opts[ALLEXPORT] = 1;
        3: 2538:		if (isset(KSHARRAYS))
    #####: 2539:		    unsetparam(name);
        3: 2540:	    	pm = assignsparam(name, val, myflags);
        3: 2541:		opts[ALLEXPORT] = allexp;
        -: 2542:	    } else
      128: 2543:	    	pm = assignsparam(name, val, myflags);
      131: 2544:	    if (errflag) {
    #####: 2545:		state->pc = opc;
    #####: 2546:		return;
        -: 2547:	    }
      131: 2548:	    continue;
        -: 2549:	}
       25: 2550:	if (vl) {
       25: 2551:	    ptr = arr = (char **) zalloc(sizeof(char *) *
       25: 2552:					 (countlinknodes(vl) + 1));
        -: 2553:
     6808: 2554:	    while (nonempty(vl))
     6758: 2555:		*ptr++ = ztrdup((char *) ugetnode(vl));
        -: 2556:	} else
    #####: 2557:	    ptr = arr = (char **) zalloc(sizeof(char *));
        -: 2558:
       25: 2559:	*ptr = NULL;
       25: 2560:	if (xtr) {
    #####: 2561:	    fprintf(xtrerr, "( ");
    #####: 2562:	    for (ptr = arr; *ptr; ptr++) {
    #####: 2563:		quotedzputs(*ptr, xtrerr);
    #####: 2564:		fputc(' ', xtrerr);
        -: 2565:	    }
    #####: 2566:	    fprintf(xtrerr, ") ");
        -: 2567:	}
       25: 2568:	assignaparam(name, arr, myflags);
       25: 2569:	if (errflag) {
    #####: 2570:	    state->pc = opc;
    #####: 2571:	    return;
        -: 2572:	}
        -: 2573:    }
      156: 2574:    state->pc = opc;
        -: 2575:}
        -: 2576:
        -: 2577:/**/
        -: 2578:void
     1073: 2579:setunderscore(char *str)
        -: 2580:{
     1073: 2581:    queue_signals();
     1750: 2582:    if (str && *str) {
      677: 2583:	size_t l = strlen(str) + 1, nl = (l + 31) & ~31;
        -: 2584:
      677: 2585:	if (nl > underscorelen || (underscorelen - nl) > 64) {
       71: 2586:	    zfree(zunderscore, underscorelen);
       71: 2587:	    zunderscore = (char *) zalloc(underscorelen = nl);
        -: 2588:	}
      677: 2589:	strcpy(zunderscore, str);
      677: 2590:	underscoreused = l;
        -: 2591:    } else {
      396: 2592:	if (underscorelen > 128) {
    #####: 2593:	    zfree(zunderscore, underscorelen);
    #####: 2594:	    zunderscore = (char *) zalloc(underscorelen = 32);
        -: 2595:	}
      396: 2596:	*zunderscore = '\0';
      396: 2597:	underscoreused = 1;
        -: 2598:    }
     1073: 2599:    unqueue_signals();
     1073: 2600:}
        -: 2601:
        -: 2602:/* These describe the type of expansions that need to be done on the words
        -: 2603: * used in the thing we are about to execute. They are set in execcmd() and
        -: 2604: * used in execsubst() which might be called from one of the functions
        -: 2605: * called from execcmd() (like execfor() and so on). */
        -: 2606:
        -: 2607:static int esprefork, esglob = 1;
        -: 2608:
        -: 2609:/**/
        -: 2610:void
        1: 2611:execsubst(LinkList strs)
        -: 2612:{
        1: 2613:    if (strs) {
        1: 2614:	prefork(strs, esprefork, NULL);
        1: 2615:	if (esglob && !errflag) {
        1: 2616:	    LinkList ostrs = strs;
        1: 2617:	    globlist(strs, 0);
        1: 2618:	    strs = ostrs;
        -: 2619:	}
        -: 2620:    }
        1: 2621:}
        -: 2622:
        -: 2623:/*
        -: 2624: * Check if a builtin requires an autoload and if so
        -: 2625: * deal with it.  This may return NULL.
        -: 2626: */
        -: 2627:
        -: 2628:/**/
        -: 2629:static HashNode
      401: 2630:resolvebuiltin(const char *cmdarg, HashNode hn)
        -: 2631:{
      401: 2632:    if (!((Builtin) hn)->handlerfunc) {
    #####: 2633:	char *modname = dupstring(((Builtin) hn)->optstr);
        -: 2634:	/*
        -: 2635:	 * Ensure the module is loaded and the
        -: 2636:	 * feature corresponding to the builtin
        -: 2637:	 * is enabled.
        -: 2638:	 */
    #####: 2639:	(void)ensurefeature(modname, "b:",
    #####: 2640:			    (hn->flags & BINF_AUTOALL) ? NULL :
        -: 2641:			    hn->nam);
    #####: 2642:	hn = builtintab->getnode(builtintab, cmdarg);
    #####: 2643:	if (!hn) {
    #####: 2644:	    lastval = 1;
    #####: 2645:	    zerr("autoloading module %s failed to define builtin: %s",
        -: 2646:		 modname, cmdarg);
    #####: 2647:	    return NULL;
        -: 2648:	}
        -: 2649:    }
      401: 2650:    return hn;
        -: 2651:}
        -: 2652:
        -: 2653:/*
        -: 2654: * We are about to execute a command at the lowest level of the
        -: 2655: * hierarchy.  Analyse the parameters from the wordcode.
        -: 2656: */
        -: 2657:
        -: 2658:/**/
        -: 2659:static void
      821: 2660:execcmd_analyse(Estate state, Execcmd_params eparams)
        -: 2661:{
        -: 2662:    wordcode code;
        -: 2663:    int i;
        -: 2664:
      821: 2665:    eparams->beg = state->pc;
      821: 2666:    eparams->redir =
      821: 2667:	(wc_code(*state->pc) == WC_REDIR ? ecgetredirs(state) : NULL);
      821: 2668:    if (wc_code(*state->pc) == WC_ASSIGN) {
       28: 2669:	cmdoutval = 0;
       28: 2670:	eparams->varspc = state->pc;
       84: 2671:	while (wc_code((code = *state->pc)) == WC_ASSIGN)
       53: 2672:	    state->pc += (WC_ASSIGN_TYPE(code) == WC_ASSIGN_SCALAR ?
       25: 2673:			  3 : WC_ASSIGN_NUM(code) + 2);
        -: 2674:    } else
      793: 2675:	eparams->varspc = NULL;
        -: 2676:
      821: 2677:    code = *state->pc++;
        -: 2678:
      821: 2679:    eparams->type = wc_code(code);
      821: 2680:    eparams->postassigns = 0;
        -: 2681:
        -: 2682:    /* It would be nice if we could use EC_DUPTOK instead of EC_DUP here.
        -: 2683:     * But for that we would need to check/change all builtins so that
        -: 2684:     * they don't modify their argument strings. */
      821: 2685:    switch (eparams->type) {
      446: 2686:    case WC_SIMPLE:
      446: 2687:	eparams->args = ecgetlist(state, WC_SIMPLE_ARGC(code), EC_DUP,
        -: 2688:				  &eparams->htok);
      446: 2689:	eparams->assignspc = NULL;
      446: 2690:	break;
        -: 2691:
      133: 2692:    case WC_TYPESET:
      133: 2693:	eparams->args = ecgetlist(state, WC_TYPESET_ARGC(code), EC_DUP,
        -: 2694:				  &eparams->htok);
      133: 2695:	eparams->postassigns = *state->pc++;
      133: 2696:	eparams->assignspc = state->pc;
      240: 2697:	for (i = 0; i < eparams->postassigns; i++) {
      107: 2698:	    code = *state->pc;
        -: 2699:	    DPUTS(wc_code(code) != WC_ASSIGN,
        -: 2700:		  "BUG: miscounted typeset assignments");
      107: 2701:	    state->pc += (WC_ASSIGN_TYPE(code) == WC_ASSIGN_SCALAR ?
    #####: 2702:			  3 : WC_ASSIGN_NUM(code) + 2);
        -: 2703:	}
      133: 2704:	break;
        -: 2705:
      242: 2706:    default:
      242: 2707:	eparams->args = NULL;
      242: 2708:	eparams->assignspc = NULL;
      242: 2709:	eparams->htok = 0;
      242: 2710:	break;
        -: 2711:    }
      821: 2712:}
        -: 2713:
        -: 2714:/*
        -: 2715: * Transfer the first node of args to preargs, performing
        -: 2716: * prefork expansion on the way if necessary.
        -: 2717: */
      556: 2718:static void execcmd_getargs(LinkList preargs, LinkList args, int expand)
        -: 2719:{
      556: 2720:    if (!firstnode(args)) {
        2: 2721:	return;
      554: 2722:    } else if (expand) {
        -: 2723:	local_list0(svl);
      177: 2724:	init_list0(svl);
        -: 2725:	/* not init_list1, as we need real nodes */
      177: 2726:	addlinknode(&svl, uremnode(args, firstnode(args)));
        -: 2727:	/* Analysing commands, so vanilla options to prefork */
      177: 2728:	prefork(&svl, 0, NULL);
      177: 2729:	joinlists(preargs, &svl);
        -: 2730:    } else {
      377: 2731:        addlinknode(preargs, uremnode(args, firstnode(args)));
        -: 2732:    }
        -: 2733:}
        -: 2734:
        -: 2735:/**/
        -: 2736:static int
       21: 2737:execcmd_fork(Estate state, int how, int type, Wordcode varspc,
        -: 2738:	     LinkList *filelistp, char *text, int oautocont,
        -: 2739:	     int close_if_forked)
        -: 2740:{
        -: 2741:    pid_t pid;
        -: 2742:    int synch[2], flags;
        -: 2743:    struct entersubsh_ret esret;
        -: 2744:    struct timeval bgtime;
        -: 2745:
       21: 2746:    child_block();
       21: 2747:    esret.gleader = -1;
       21: 2748:    esret.list_pipe_job = -1;
        -: 2749:
       21: 2750:    if (pipe(synch) < 0) {
    #####: 2751:	zerr("pipe failed: %e", errno);
    #####: 2752:	return -1;
       21: 2753:    } else if ((pid = zfork(&bgtime)) == -1) {
    #####: 2754:	close(synch[0]);
    #####: 2755:	close(synch[1]);
    #####: 2756:	lastval = 1;
    #####: 2757:	errflag |= ERRFLAG_ERROR;
    #####: 2758:	return -1;
        -: 2759:    }
       42: 2760:    if (pid) {
       21: 2761:	close(synch[1]);
       21: 2762:	read_loop(synch[0], (char *)&esret, sizeof(esret));
       21: 2763:	close(synch[0]);
       21: 2764:	if (how & Z_ASYNC) {
    #####: 2765:	    lastpid = (zlong) pid;
       21: 2766:	} else if (!jobtab[thisjob].stty_in_env && varspc) {
        -: 2767:	    /* search for STTY=... */
        3: 2768:	    Wordcode p = varspc;
        -: 2769:	    wordcode ac;
        -: 2770:
        9: 2771:	    while (wc_code(ac = *p) == WC_ASSIGN) {
        3: 2772:		if (!strcmp(ecrawstr(state->prog, p + 1, NULL), "STTY")) {
    #####: 2773:		    jobtab[thisjob].stty_in_env = 1;
    #####: 2774:		    break;
        -: 2775:		}
        3: 2776:		p += (WC_ASSIGN_TYPE(ac) == WC_ASSIGN_SCALAR ?
    #####: 2777:		      3 : WC_ASSIGN_NUM(ac) + 2);
        -: 2778:	    }
        -: 2779:	}
       21: 2780:	addproc(pid, text, 0, &bgtime, esret.gleader, esret.list_pipe_job);
       21: 2781:	if (oautocont >= 0)
    #####: 2782:	    opts[AUTOCONTINUE] = oautocont;
       21: 2783:	pipecleanfilelist(jobtab[thisjob].filelist, 1);
       21: 2784:	return pid;
        -: 2785:    }
        -: 2786:
        -: 2787:    /* pid == 0 */
       21: 2788:    close(synch[0]);
       21: 2789:    flags = ((how & Z_ASYNC) ? ESUB_ASYNC : 0) | ESUB_PGRP;
       21: 2790:    if ((type != WC_SUBSH) && !(how & Z_ASYNC))
       21: 2791:	flags |= ESUB_KEEPTRAP;
       21: 2792:    if (type == WC_SUBSH && !(how & Z_ASYNC))
    #####: 2793:	flags |= ESUB_JOB_CONTROL;
       21: 2794:    *filelistp = jobtab[thisjob].filelist;
       21: 2795:    entersubsh(flags, &esret);
       21: 2796:    if (write_loop(synch[1], (const void *) &esret, sizeof(esret)) != sizeof(esret)) {
    #####: 2797:	zerr("Failed to send entersubsh_ret report: %e", errno);
    #####: 2798:	return -1;
        -: 2799:    }
       21: 2800:    close(synch[1]);
       21: 2801:    zclose(close_if_forked);
        -: 2802:
       21: 2803:    if (sigtrapped[SIGINT] & ZSIG_IGNORED)
    #####: 2804:	holdintr();
        -: 2805:    /*
        -: 2806:     * EXIT traps shouldn't be called even if we forked to run
        -: 2807:     * shell code as this isn't the main shell.
        -: 2808:     */
       21: 2809:    sigtrapped[SIGEXIT] = 0;
        -: 2810:#ifdef HAVE_NICE
        -: 2811:    /* Check if we should run background jobs at a lower priority. */
       21: 2812:    if ((how & Z_ASYNC) && isset(BGNICE)) {
    #####: 2813:	errno = 0;
    #####: 2814:	if (nice(5) == -1 && errno)
    #####: 2815:	    zwarn("nice(5) failed: %e", errno);
        -: 2816:    }
        -: 2817:#endif /* HAVE_NICE */
        -: 2818:
       21: 2819:    return 0;
        -: 2820:}
        -: 2821:
        -: 2822:/*
        -: 2823: * Execute a command at the lowest level of the hierarchy.
        -: 2824: */
        -: 2825:
        -: 2826:/**/
        -: 2827:static void
      821: 2828:execcmd_exec(Estate state, Execcmd_params eparams,
        -: 2829:	     int input, int output, int how, int last1, int close_if_forked)
        -: 2830:{
      821: 2831:    HashNode hn = NULL;
      821: 2832:    LinkList filelist = NULL;
        -: 2833:    LinkNode node;
        -: 2834:    Redir fn;
        -: 2835:    struct multio *mfds[10];
        -: 2836:    char *text;
        -: 2837:    int save[10];
      821: 2838:    int fil, dfil, is_cursh, do_exec = 0, redir_err = 0, i;
      821: 2839:    int nullexec = 0, magic_assign = 0, forked = 0, old_lastval;
      821: 2840:    int is_shfunc = 0, is_builtin = 0, is_exec = 0, use_defpath = 0;
        -: 2841:    /* Various flags to the command. */
      821: 2842:    int cflags = 0, orig_cflags = 0, checked = 0, oautocont = -1;
      821: 2843:    FILE *oxtrerr = xtrerr, *newxtrerr = NULL;
        -: 2844:    /*
        -: 2845:     * Retrieve parameters for quick reference (they are unique
        -: 2846:     * to us so we can modify the structure if we want).
        -: 2847:     */
      821: 2848:    LinkList args = eparams->args;
      821: 2849:    LinkList redir = eparams->redir;
      821: 2850:    Wordcode varspc = eparams->varspc;
      821: 2851:    int type = eparams->type;
        -: 2852:    /*
        -: 2853:     * preargs comes from expanding the head of the args list
        -: 2854:     * in order to check for prefix commands.
        -: 2855:     */
        -: 2856:    LinkList preargs;
        -: 2857:
      821: 2858:    doneps4 = 0;
        -: 2859:
        -: 2860:    /*
        -: 2861:     * If assignment but no command get the status from variable
        -: 2862:     * assignment.
        -: 2863:     */
      821: 2864:    old_lastval = lastval;
      821: 2865:    if (!args && varspc)
       25: 2866:	lastval = errflag ? errflag : cmdoutval;
        -: 2867:    /*
        -: 2868:     * If there are arguments, we should reset the status for the
        -: 2869:     * command before execution---unless we are using the result of a
        -: 2870:     * command substitution, which will be indicated by setting
        -: 2871:     * use_cmdoutval to 1.  We haven't kicked those off yet, so
        -: 2872:     * there's no race.
        -: 2873:     */
      821: 2874:    use_cmdoutval = !args;
        -: 2875:
     9031: 2876:    for (i = 0; i < 10; i++) {
     8210: 2877:	save[i] = -2;
     8210: 2878:	mfds[i] = NULL;
        -: 2879:    }
        -: 2880:
        -: 2881:    /* If the command begins with `%', then assume it is a *
        -: 2882:     * reference to a job in the job table.                */
     1375: 2883:    if ((type == WC_SIMPLE || type == WC_TYPESET) && args && nonempty(args) &&
      554: 2884:	*(char *)peekfirst(args) == '%') {
    #####: 2885:        if (how & Z_DISOWN) {
    #####: 2886:	    oautocont = opts[AUTOCONTINUE];
    #####: 2887:            opts[AUTOCONTINUE] = 1;
        -: 2888:	}
    #####: 2889:	pushnode(args, dupstring((how & Z_DISOWN)
        -: 2890:				 ? "disown" : (how & Z_ASYNC) ? "bg" : "fg"));
    #####: 2891:	how = Z_SYNC;
        -: 2892:    }
        -: 2893:
        -: 2894:    /* If AUTORESUME is set, the command is SIMPLE, and doesn't have *
        -: 2895:     * any redirections, then check if it matches as a prefix of a   *
        -: 2896:     * job currently in the job table.  If it does, then we treat it *
        -: 2897:     * as a command to resume this job.                              */
      821: 2898:    if (isset(AUTORESUME) && type == WC_SIMPLE && (how & Z_SYNC) &&
    #####: 2899:	args && nonempty(args) && (!redir || empty(redir)) && !input &&
    #####: 2900:	!nextnode(firstnode(args))) {
    #####: 2901:	if (unset(NOTIFY))
    #####: 2902:	    scanjobs();
    #####: 2903:	if (findjobnam(peekfirst(args)) != -1)
    #####: 2904:	    pushnode(args, dupstring("fg"));
        -: 2905:    }
        -: 2906:
      821: 2907:    if ((how & Z_ASYNC) || output ||
      816: 2908:	(last1 == 2 && input && EMULATION(EMULATE_SH))) {
        -: 2909:	/*
        -: 2910:	 * If running in the background, not the last command in a
        -: 2911:	 * pipeline, or the last command in a multi-stage pipeline
        -: 2912:	 * in sh mode, we don't need any of the rest of this function
        -: 2913:	 * to affect the state in the main shell, so fork immediately.
        -: 2914:	 *
        -: 2915:	 * In other cases we may need to process the command line
        -: 2916:	 * a bit further before we make the decision.
        -: 2917:	 */
    #####: 2918:	text = getjobtext(state->prog, eparams->beg);
    #####: 2919:	switch (execcmd_fork(state, how, type, varspc, &filelist,
        -: 2920:			     text, oautocont, close_if_forked)) {
    #####: 2921:	case -1:
    #####: 2922:	    goto fatal;
    #####: 2923:	case 0:
    #####: 2924:	    break;
    #####: 2925:	default:
       46: 2926:	    return;
        -: 2927:	}
    #####: 2928:	last1 = forked = 1;
        -: 2929:    } else
      821: 2930:	text = NULL;
        -: 2931:
        -: 2932:    /* Check if it's a builtin needing automatic MAGIC_EQUALS_SUBST      *
        -: 2933:     * handling.  Things like typeset need this.  We can't detect the    *
        -: 2934:     * command if it contains some tokens (e.g. x=ex; ${x}port), so this *
        -: 2935:     * only works in simple cases.  has_token() is called to make sure   *
        -: 2936:     * this really is a simple case.                                     */
     1375: 2937:    if ((type == WC_SIMPLE || type == WC_TYPESET) && args) {
        -: 2938:	/*
        -: 2939:	 * preargs contains args that have been expanded by prefork.
        -: 2940:	 * Running execcmd_getargs() causes any argument available
        -: 2941:	 * in args to be exanded where necessary and transferred to
        -: 2942:	 * preargs.  We call execcmd_getargs() every time we need to
        -: 2943:	 * analyse an argument not available in preargs, though there is
        -: 2944:	 * no guarantee a further argument will be available.
        -: 2945:	 */
      554: 2946:	preargs = newlinklist();
      554: 2947:	execcmd_getargs(preargs, args, eparams->htok);
     1108: 2948:	while (nonempty(preargs)) {
      554: 2949:	    char *cmdarg = (char *) peekfirst(preargs);
      554: 2950:	    checked = !has_token(cmdarg);
      554: 2951:	    if (!checked)
    #####: 2952:		break;
      687: 2953:	    if (type == WC_TYPESET &&
      133: 2954:		(hn = builtintab->getnode2(builtintab, cmdarg))) {
        -: 2955:		/*
        -: 2956:		 * If reserved word for typeset command found (and so
        -: 2957:		 * enabled), use regardless of whether builtin is
        -: 2958:		 * enabled as we share the implementation.
        -: 2959:		 *
        -: 2960:		 * Reserved words take precedence over shell functions.
        -: 2961:		 */
      133: 2962:		checked = 1;
      421: 2963:	    } else if (isset(POSIXBUILTINS) && (cflags & BINF_EXEC)) {
        -: 2964:		/*
        -: 2965:		 * POSIX doesn't allow "exec" to operate on builtins
        -: 2966:		 * or shell functions.
        -: 2967:		 */
        -: 2968:		break;
        -: 2969:	    } else {
      842: 2970:		if (!(cflags & (BINF_BUILTIN | BINF_COMMAND)) &&
      421: 2971:		    (hn = shfunctab->getnode(shfunctab, cmdarg))) {
      125: 2972:		    is_shfunc = 1;
      125: 2973:		    break;
        -: 2974:		}
      296: 2975:		if (!(hn = builtintab->getnode(builtintab, cmdarg))) {
       26: 2976:		    checked = !(cflags & BINF_BUILTIN);
       26: 2977:		    break;
        -: 2978:		}
        -: 2979:	    }
      403: 2980:	    orig_cflags |= cflags;
      403: 2981:	    cflags &= ~BINF_BUILTIN & ~BINF_COMMAND;
      403: 2982:	    cflags |= hn->flags;
      403: 2983:	    if (!(hn->flags & BINF_PREFIX)) {
      401: 2984:		is_builtin = 1;
        -: 2985:
        -: 2986:		/* autoload the builtin if necessary */
      401: 2987:		if (!(hn = resolvebuiltin(cmdarg, hn))) {
    #####: 2988:		    if (forked)
    #####: 2989:			_realexit();
    #####: 2990:		    return;
        -: 2991:		}
      401: 2992:		if (type != WC_TYPESET)
      268: 2993:		    magic_assign = (hn->flags & BINF_MAGICEQUALS);
      401: 2994:		break;
        -: 2995:	    }
        2: 2996:	    checked = 0;
        -: 2997:	    /*
        -: 2998:	     * We usually don't need the argument containing the
        -: 2999:	     * precommand modifier itself.  Exception: when "command"
        -: 3000:	     * will implemented by a call to "whence", in which case
        -: 3001:	     * we'll simply re-insert the argument.
        -: 3002:	     */
        2: 3003:	    uremnode(preargs, firstnode(preargs));
        2: 3004:	    if (!firstnode(preargs)) {
        2: 3005:		execcmd_getargs(preargs, args, eparams->htok);
        2: 3006:		if (!firstnode(preargs))
        2: 3007:		    break;
        -: 3008:	    }
    #####: 3009:	    if ((cflags & BINF_COMMAND)) {
        -: 3010:		/*
        -: 3011:		 * Check for options to "command".
        -: 3012:		 * If just -p, this is handled here: use the default
        -: 3013:		 * path to execute.
        -: 3014:		 * If -v or -V, possibly with -p, dispatch to bin_whence
        -: 3015:		 * but with flag to indicate special handling of -p.
        -: 3016:		 * Otherwise, just leave marked as BINF_COMMAND
        -: 3017:		 * modifier with no additional action.
        -: 3018:		 */
    #####: 3019:		LinkNode argnode, oldnode, pnode = NULL;
        -: 3020:		char *argdata, *cmdopt;
    #####: 3021:		int has_p = 0, has_vV = 0, has_other = 0;
    #####: 3022:		argnode = firstnode(preargs);
    #####: 3023:		argdata = (char *) getdata(argnode);
    #####: 3024:		while (IS_DASH(*argdata)) {
        -: 3025:		    /* Just to be definite, stop on single "-", too, */
    #####: 3026:		    if (!argdata[1] ||
    #####: 3027:			(IS_DASH(argdata[1]) && !argdata[2]))
        -: 3028:			break;
    #####: 3029:		    for (cmdopt = argdata+1; *cmdopt; cmdopt++) {
    #####: 3030:			switch (*cmdopt) {
    #####: 3031:			case 'p':
        -: 3032:			    /*
        -: 3033:			     * If we've got this multiple times (command
        -: 3034:			     * -p -p) we'll treat the second -p as a
        -: 3035:			     * command because we only remove one below.
        -: 3036:			     * Don't think that's a big issue, and it's
        -: 3037:			     * also traditional behaviour.
        -: 3038:			     */
    #####: 3039:			    has_p = 1;
    #####: 3040:			    pnode = argnode;
    #####: 3041:			    break;
    #####: 3042:			case 'v':
        -: 3043:			case 'V':
    #####: 3044:			    has_vV = 1;
    #####: 3045:			    break;
    #####: 3046:			default:
    #####: 3047:			    has_other = 1;
    #####: 3048:			    break;
        -: 3049:			}
        -: 3050:		    }
    #####: 3051:		    if (has_other) {
        -: 3052:			/* Don't know how to handle this, so don't */
    #####: 3053:			has_p = has_vV = 0;
    #####: 3054:			break;
        -: 3055:		    }
        -: 3056:
    #####: 3057:		    oldnode = argnode;
    #####: 3058:		    argnode = nextnode(argnode);
    #####: 3059:		    if (!argnode) {
    #####: 3060:			execcmd_getargs(preargs, args, eparams->htok);
    #####: 3061:			if (!(argnode = nextnode(oldnode)))
    #####: 3062:			    break;
        -: 3063:		    }
    #####: 3064:		    argdata = (char *) getdata(argnode);
        -: 3065:		}
    #####: 3066:		if (has_vV) {
        -: 3067:		    /*
        -: 3068:		     * Leave everything alone, dispatch to whence.
        -: 3069:		     * We need to put the name back in the list.
        -: 3070:		     */
    #####: 3071:		    pushnode(preargs, "command");
    #####: 3072:		    hn = &commandbn.node;
    #####: 3073:		    is_builtin = 1;
    #####: 3074:		    break;
    #####: 3075:		} else if (has_p) {
        -: 3076:		    /* Use default path */
    #####: 3077:		    use_defpath = 1;
        -: 3078:		    /*
        -: 3079:		     * We don't need this node as we're not treating
        -: 3080:		     * "command" as a builtin this time.
        -: 3081:		     */
    #####: 3082:		    if (pnode)
    #####: 3083:			uremnode(preargs, pnode);
        -: 3084:		}
        -: 3085:		/*
        -: 3086:		 * Else just any trailing
        -: 3087:		 * end-of-options marker.  This can only occur
        -: 3088:		 * if we just had -p or something including more
        -: 3089:		 * than just -p, -v and -V, in which case we behave
        -: 3090:		 * as if this is command [non-option-stuff].  This
        -: 3091:		 * isn't a good place for standard option handling.
        -: 3092:		 */
    #####: 3093:		if (IS_DASH(argdata[0]) && IS_DASH(argdata[1]) && !argdata[2])
    #####: 3094:		     uremnode(preargs, argnode);
    #####: 3095:	    } else if (cflags & BINF_EXEC) {
        -: 3096:		/*
        -: 3097:		 * Check for compatibility options to exec builtin.
        -: 3098:		 * It would be nice to do these more generically,
        -: 3099:		 * but currently we don't have a mechanism for
        -: 3100:		 * precommand modifiers.
        -: 3101:		 */
    #####: 3102:		LinkNode argnode = firstnode(preargs), oldnode;
    #####: 3103:		char *argdata = (char *) getdata(argnode);
    #####: 3104:		char *cmdopt, *exec_argv0 = NULL;
        -: 3105:		/*
        -: 3106:		 * Careful here: we want to make sure a final dash
        -: 3107:		 * is passed through in order that it still behaves
        -: 3108:		 * as a precommand modifier (zsh equivalent of -l).
        -: 3109:		 * It has to be last, but I think that's OK since
        -: 3110:		 * people aren't likely to mix the option style
        -: 3111:		 * with the zsh style.
        -: 3112:		 */
    #####: 3113:		while (argdata && IS_DASH(*argdata) && strlen(argdata) >= 2) {
    #####: 3114:		    oldnode = argnode;
    #####: 3115:		    argnode = nextnode(oldnode);
    #####: 3116:		    if (!argnode) {
    #####: 3117:			execcmd_getargs(preargs, args, eparams->htok);
    #####: 3118:			argnode = nextnode(oldnode);
        -: 3119:		    }
    #####: 3120:		    if (!argnode) {
    #####: 3121:			zerr("exec requires a command to execute");
    #####: 3122:			lastval = 1;
    #####: 3123:			errflag |= ERRFLAG_ERROR;
    #####: 3124:			goto done;
        -: 3125:		    }
    #####: 3126:		    uremnode(preargs, oldnode);
    #####: 3127:		    if (IS_DASH(argdata[0]) && IS_DASH(argdata[1]) && !argdata[2])
    #####: 3128:			break;
    #####: 3129:		    for (cmdopt = &argdata[1]; *cmdopt; ++cmdopt) {
    #####: 3130:			switch (*cmdopt) {
    #####: 3131:			case 'a':
        -: 3132:			    /* argument is ARGV0 string */
    #####: 3133:			    if (cmdopt[1]) {
    #####: 3134:				exec_argv0 = cmdopt+1;
        -: 3135:				/* position on last non-NULL character */
    #####: 3136:				cmdopt += strlen(cmdopt+1);
        -: 3137:			    } else {
    #####: 3138:				if (!argnode) {
    #####: 3139:				    zerr("exec requires a command to execute");
    #####: 3140:				    lastval = 1;
    #####: 3141:				    errflag |= ERRFLAG_ERROR;
    #####: 3142:				    goto done;
        -: 3143:				}
    #####: 3144:				if (!nextnode(argnode))
    #####: 3145:				    execcmd_getargs(preargs, args,
        -: 3146:						    eparams->htok);
    #####: 3147:				if (!nextnode(argnode)) {
    #####: 3148:				    zerr("exec flag -a requires a parameter");
    #####: 3149:				    lastval = 1;
    #####: 3150:				    errflag |= ERRFLAG_ERROR;
    #####: 3151:				    goto done;
        -: 3152:				}
    #####: 3153:				exec_argv0 = (char *) getdata(argnode);
    #####: 3154:				oldnode = argnode;
    #####: 3155:				argnode = nextnode(argnode);
    #####: 3156:				uremnode(args, oldnode);
        -: 3157:			    }
    #####: 3158:			    break;
    #####: 3159:			case 'c':
    #####: 3160:			    cflags |= BINF_CLEARENV;
    #####: 3161:			    break;
    #####: 3162:			case 'l':
    #####: 3163:			    cflags |= BINF_DASH;
    #####: 3164:			    break;
    #####: 3165:			default:
    #####: 3166:			    zerr("unknown exec flag -%c", *cmdopt);
    #####: 3167:			    lastval = 1;
    #####: 3168:			    errflag |= ERRFLAG_ERROR;
    #####: 3169:			    if (forked)
    #####: 3170:				_realexit();
    #####: 3171:			    return;
        -: 3172:			}
        -: 3173:		    }
    #####: 3174:		    if (!argnode)
    #####: 3175:			break;
    #####: 3176:		    argdata = (char *) getdata(argnode);
        -: 3177:		}
    #####: 3178:		if (exec_argv0) {
        -: 3179:		    char *str, *s;
    #####: 3180:		    exec_argv0 = dupstring(exec_argv0);
    #####: 3181:		    remnulargs(exec_argv0);
    #####: 3182:		    untokenize(exec_argv0);
    #####: 3183:		    size_t sz = strlen(exec_argv0);
    #####: 3184:		    str = s = zalloc(5 + 1 + sz + 1);
    #####: 3185:		    strcpy(s, "ARGV0=");
    #####: 3186:		    s+=6;
    #####: 3187:		    strcpy(s, exec_argv0);
    #####: 3188:		    zputenv(str);
        -: 3189:		}
        -: 3190:	    }
    #####: 3191:	    hn = NULL;
    #####: 3192:	    if ((cflags & BINF_COMMAND) && unset(POSIXBUILTINS))
    #####: 3193:		break;
    #####: 3194:	    if (!nonempty(preargs))
    #####: 3195:		execcmd_getargs(preargs, args, eparams->htok);
        -: 3196:	}
        -: 3197:    } else
      267: 3198:	preargs = NULL;
        -: 3199:
        -: 3200:    /* if we get this far, it is OK to pay attention to lastval again */
      821: 3201:    if (noerrexit & NOERREXIT_UNTIL_EXEC)
    #####: 3202:	noerrexit = 0;
        -: 3203:
        -: 3204:    /* Do prefork substitutions.
        -: 3205:     *
        -: 3206:     * Decide if we need "magic" handling of ~'s etc. in
        -: 3207:     * assignment-like arguments.
        -: 3208:     * - If magic_assign is set, we are using a builtin of the
        -: 3209:     *   tyepset family, but did not recognise this as a keyword,
        -: 3210:     *   so need guess-o-matic behaviour.
        -: 3211:     * - Otherwise, if we did recognise the keyword, we never need
        -: 3212:     *   guess-o-matic behaviour as the argument was properly parsed
        -: 3213:     *   as such.
        -: 3214:     * - Otherwise, use the behaviour specified by the MAGIC_EQUAL_SUBST
        -: 3215:     *   option.
        -: 3216:     */
      821: 3217:    esprefork = (magic_assign ||
      821: 3218:		 (isset(MAGICEQUALSUBST) && type != WC_TYPESET)) ?
     1642: 3219:		 PREFORK_TYPESET : 0;
        -: 3220:
      821: 3221:    if (args) {
      554: 3222:	if (eparams->htok)
      177: 3223:	    prefork(args, esprefork, NULL);
      554: 3224:	if (preargs)
      554: 3225:	    args = joinlists(preargs, args);
        -: 3226:    }
        -: 3227:
      821: 3228:    if (type == WC_SIMPLE || type == WC_TYPESET) {
      579: 3229:	int unglobbed = 0;
        -: 3230:
    #####: 3231:	for (;;) {
        -: 3232:	    char *cmdarg;
        -: 3233:
      579: 3234:	    if (!(cflags & BINF_NOGLOB))
     1158: 3235:		while (!checked && !errflag && args && nonempty(args) &&
    #####: 3236:		       has_token((char *) peekfirst(args)))
    #####: 3237:		    zglob(args, firstnode(args), 0);
    #####: 3238:	    else if (!unglobbed) {
    #####: 3239:		for (node = firstnode(args); node; incnode(node))
    #####: 3240:		    untokenize((char *) getdata(node));
    #####: 3241:		unglobbed = 1;
        -: 3242:	    }
        -: 3243:
        -: 3244:	    /* Current shell should not fork unless the *
        -: 3245:	     * exec occurs at the end of a pipeline.    */
      579: 3246:	    if ((cflags & BINF_EXEC) && last1)
        2: 3247:		do_exec = 1;
        -: 3248:
        -: 3249:	    /* Empty command */
      579: 3250:	    if (!args || empty(args)) {
       27: 3251:		if (redir && nonempty(redir)) {
        2: 3252:		    if (do_exec) {
        -: 3253:			/* Was this "exec < foobar"? */
        2: 3254:			nullexec = 1;
        2: 3255:			break;
    #####: 3256:		    } else if (varspc) {
    #####: 3257:			nullexec = 2;
    #####: 3258:			break;
    #####: 3259:		    } else if (!nullcmd || !*nullcmd || opts[CSHNULLCMD] ||
    #####: 3260:			       (cflags & BINF_PREFIX)) {
    #####: 3261:			zerr("redirection with no command");
    #####: 3262:			lastval = 1;
    #####: 3263:			errflag |= ERRFLAG_ERROR;
    #####: 3264:			if (forked)
    #####: 3265:			    _realexit();
    #####: 3266:			return;
    #####: 3267:		    } else if (!nullcmd || !*nullcmd || opts[SHNULLCMD]) {
    #####: 3268:			if (!args)
    #####: 3269:			    args = newlinklist();
    #####: 3270:			addlinknode(args, dupstring(":"));
    #####: 3271:		    } else if (readnullcmd && *readnullcmd &&
    #####: 3272:			       ((Redir) peekfirst(redir))->type == REDIR_READ &&
    #####: 3273:			       !nextnode(firstnode(redir))) {
    #####: 3274:			if (!args)
    #####: 3275:			    args = newlinklist();
    #####: 3276:			addlinknode(args, dupstring(readnullcmd));
        -: 3277:		    } else {
    #####: 3278:			if (!args)
    #####: 3279:			    args = newlinklist();
    #####: 3280:			addlinknode(args, dupstring(nullcmd));
        -: 3281:		    }
       25: 3282:		} else if ((cflags & BINF_PREFIX) && (cflags & BINF_COMMAND)) {
    #####: 3283:		    lastval = 0;
    #####: 3284:		    if (forked)
    #####: 3285:			_realexit();
    #####: 3286:		    return;
        -: 3287:		} else {
        -: 3288:		    /*
        -: 3289:		     * No arguments.  Reset the status if there were
        -: 3290:		     * arguments before and no command substitution
        -: 3291:		     * has provided a status.
        -: 3292:		     */
       25: 3293:		    if (badcshglob == 1) {
    #####: 3294:			zerr("no match");
    #####: 3295:			lastval = 1;
    #####: 3296:			if (forked)
    #####: 3297:			    _realexit();
    #####: 3298:			return;
        -: 3299:		    }
       25: 3300:		    cmdoutval = use_cmdoutval ? lastval : 0;
       25: 3301:		    if (varspc) {
        -: 3302:			/* Make sure $? is still correct for assignment */
       25: 3303:			lastval = old_lastval;
       25: 3304:			addvars(state, varspc, 0);
        -: 3305:		    }
       25: 3306:		    if (errflag)
    #####: 3307:			lastval = 1;
        -: 3308:		    else
       25: 3309:			lastval = cmdoutval;
       25: 3310:		    if (isset(XTRACE)) {
    #####: 3311:			fputc('\n', xtrerr);
    #####: 3312:			fflush(xtrerr);
        -: 3313:		    }
       25: 3314:		    if (forked)
    #####: 3315:			_realexit();
       25: 3316:		    return;
        -: 3317:		}
      552: 3318:	    } else if (isset(RESTRICTED) && (cflags & BINF_EXEC) && do_exec) {
    #####: 3319:		zerrnam("exec", "%s: restricted",
    #####: 3320:			(char *) getdata(firstnode(args)));
    #####: 3321:		lastval = 1;
    #####: 3322:		if (forked)
    #####: 3323:		    _realexit();
    #####: 3324:		return;
        -: 3325:	    }
        -: 3326:
        -: 3327:	    /*
        -: 3328:	     * Quit looking for a command if:
        -: 3329:	     * - there was an error; or
        -: 3330:	     * - we checked the simple cases needing MAGIC_EQUAL_SUBST; or
        -: 3331:	     * - we know we already found a builtin (because either:
        -: 3332:	     *   - we loaded a builtin from a module, or
        -: 3333:	     *   - we have determined there are options which would
        -: 3334:	     *     require us to use the "command" builtin); or
        -: 3335:	     * - we aren't using POSIX and so BINF_COMMAND indicates a zsh
        -: 3336:	     *   precommand modifier is being used in place of the
        -: 3337:	     *   builtin
        -: 3338:	     * - we are using POSIX and this is an EXEC, so we can't
        -: 3339:	     *   execute a builtin or function.
        -: 3340:	     */
      552: 3341:	    if (errflag || checked || is_builtin ||
    #####: 3342:		(isset(POSIXBUILTINS) ?
    #####: 3343:		 (cflags & BINF_EXEC) : (cflags & BINF_COMMAND)))
        -: 3344:		break;
        -: 3345:
    #####: 3346:	    cmdarg = (char *) peekfirst(args);
    #####: 3347:	    if (!(cflags & (BINF_BUILTIN | BINF_COMMAND)) &&
    #####: 3348:		(hn = shfunctab->getnode(shfunctab, cmdarg))) {
    #####: 3349:		is_shfunc = 1;
    #####: 3350:		break;
        -: 3351:	    }
    #####: 3352:	    if (!(hn = builtintab->getnode(builtintab, cmdarg))) {
    #####: 3353:		if (cflags & BINF_BUILTIN) {
    #####: 3354:		    zwarn("no such builtin: %s", cmdarg);
    #####: 3355:		    lastval = 1;
    #####: 3356:		    if (oautocont >= 0)
    #####: 3357:			opts[AUTOCONTINUE] = oautocont;
    #####: 3358:		    if (forked)
    #####: 3359:			_realexit();
    #####: 3360:		    return;
        -: 3361:		}
    #####: 3362:		break;
        -: 3363:	    }
    #####: 3364:	    if (!(hn->flags & BINF_PREFIX)) {
    #####: 3365:		is_builtin = 1;
        -: 3366:
        -: 3367:		/* autoload the builtin if necessary */
    #####: 3368:		if (!(hn = resolvebuiltin(cmdarg, hn))) {
    #####: 3369:		    if (forked)
    #####: 3370:			_realexit();
    #####: 3371:		    return;
        -: 3372:		}
    #####: 3373:		break;
        -: 3374:	    }
    #####: 3375:	    cflags &= ~BINF_BUILTIN & ~BINF_COMMAND;
    #####: 3376:	    cflags |= hn->flags;
    #####: 3377:	    uremnode(args, firstnode(args));
    #####: 3378:	    hn = NULL;
        -: 3379:	}
        -: 3380:    }
        -: 3381:
      796: 3382:    if (errflag) {
    #####: 3383:	if (!lastval)
    #####: 3384:	    lastval = 1;
    #####: 3385:	if (oautocont >= 0)
    #####: 3386:	    opts[AUTOCONTINUE] = oautocont;
    #####: 3387:	if (forked)
    #####: 3388:	    _realexit();
    #####: 3389:	return;
        -: 3390:    }
        -: 3391:
        -: 3392:    /* Get the text associated with this command. */
     1592: 3393:    if (!text &&
      840: 3394:	(!sfcontext && (jobbing || (how & Z_TIMED))))
    #####: 3395:	text = getjobtext(state->prog, eparams->beg);
        -: 3396:
        -: 3397:    /*
        -: 3398:     * Set up special parameter $_
        -: 3399:     * For execfuncdef we may need to take account of an
        -: 3400:     * anonymous function with arguments.
        -: 3401:     */
      796: 3402:    if (type != WC_FUNCDEF)
     1348: 3403:	setunderscore((args && nonempty(args)) ?
      552: 3404:		      ((char *) getdata(lastnode(args))) : "");
        -: 3405:
        -: 3406:    /* Warn about "rm *" */
      800: 3407:    if (type == WC_SIMPLE && interact && unset(RMSTARSILENT) &&
       12: 3408:	isset(SHINSTDIN) && args && nonempty(args) &&
        7: 3409:	nextnode(firstnode(args)) && !strcmp(peekfirst(args), "rm")) {
        -: 3410:	LinkNode node, next;
        -: 3411:
    #####: 3412:	for (node = nextnode(firstnode(args)); node && !errflag; node = next) {
    #####: 3413:	    char *s = (char *) getdata(node);
    #####: 3414:	    int l = strlen(s);
        -: 3415:
    #####: 3416:	    next = nextnode(node);
    #####: 3417:	    if (s[0] == Star && !s[1]) {
    #####: 3418:		if (!checkrmall(pwd)) {
    #####: 3419:		    errflag |= ERRFLAG_ERROR;
    #####: 3420:		    break;
        -: 3421:		}
    #####: 3422:	    } else if (l >= 2 && s[l - 2] == '/' && s[l - 1] == Star) {
    #####: 3423:		char t = s[l - 2];
        -: 3424:		int rmall;
        -: 3425:
    #####: 3426:		s[l - 2] = 0;
    #####: 3427:		rmall = checkrmall(l == 2 ? "/" : s);
    #####: 3428:		s[l - 2] = t;
        -: 3429:
    #####: 3430:		if (!rmall) {
    #####: 3431:		    errflag |= ERRFLAG_ERROR;
    #####: 3432:		    break;
        -: 3433:		}
        -: 3434:	    }
        -: 3435:	}
        -: 3436:    }
        -: 3437:
      796: 3438:    if (type == WC_FUNCDEF) {
        -: 3439:	/*
        -: 3440:	 * The first word of a function definition is a list of
        -: 3441:	 * names.  If this is empty, we're doing an anonymous function:
        -: 3442:	 * in that case redirections are handled normally.
        -: 3443:	 * If not, it's a function definition: then we don't do
        -: 3444:	 * redirections here but pass in the list of redirections to
        -: 3445:	 * be stored for recall with the function.
        -: 3446:	 */
    #####: 3447:	if (*state->pc != 0) {
        -: 3448:	    /* Nonymous, don't do redirections here */
    #####: 3449:	    redir = NULL;
        -: 3450:	}
      796: 3451:    } else if (is_shfunc || type == WC_AUTOFN) {
        -: 3452:	Shfunc shf;
      125: 3453:	if (is_shfunc)
      125: 3454:	    shf = (Shfunc)hn;
        -: 3455:	else {
    #####: 3456:	    shf = loadautofn(state->prog->shf, 1, 0, 0);
    #####: 3457:	    if (shf)
    #####: 3458:		state->prog->shf = shf;
        -: 3459:	    else {
        -: 3460:		/*
        -: 3461:		 * This doesn't set errflag, so just return now.
        -: 3462:		 */
    #####: 3463:		lastval = 1;
    #####: 3464:		if (oautocont >= 0)
    #####: 3465:		    opts[AUTOCONTINUE] = oautocont;
    #####: 3466:		if (forked)
    #####: 3467:		    _realexit();
    #####: 3468:		return;
        -: 3469:	    }
        -: 3470:	}
        -: 3471:	/*
        -: 3472:	 * A function definition may have a list of additional
        -: 3473:	 * redirections to apply, so retrieve it.
        -: 3474:	 */
      125: 3475:	if (shf->redir) {
        -: 3476:	    struct estate s;
        -: 3477:	    LinkList redir2;
        -: 3478:
    #####: 3479:	    s.prog = shf->redir;
    #####: 3480:	    s.pc = shf->redir->prog;
    #####: 3481:	    s.strs = shf->redir->strs;
    #####: 3482:	    redir2 = ecgetredirs(&s);
    #####: 3483:	    if (!redir)
    #####: 3484:		redir = redir2;
        -: 3485:	    else {
    #####: 3486:		while (nonempty(redir2))
    #####: 3487:		    addlinknode(redir, ugetnode(redir2));
        -: 3488:	    }
        -: 3489:	}
        -: 3490:    }
        -: 3491:
      796: 3492:    if (errflag) {
    #####: 3493:	lastval = 1;
    #####: 3494:	if (oautocont >= 0)
    #####: 3495:	    opts[AUTOCONTINUE] = oautocont;
    #####: 3496:	if (forked)
    #####: 3497:	    _realexit();
    #####: 3498:	return;
        -: 3499:    }
        -: 3500:
      796: 3501:    if ((type == WC_SIMPLE || type == WC_TYPESET) && !nullexec) {
        -: 3502:	char *s;
     1104: 3503:	char trycd = (isset(AUTOCD) && isset(SHINSTDIN) &&
    #####: 3504:		      (!redir || empty(redir)) && args && !empty(args) &&
      552: 3505:		      !nextnode(firstnode(args)) && *(char *)peekfirst(args));
        -: 3506:
        -: 3507:	DPUTS((!args || empty(args)), "BUG: empty(args) in exec.c");
      552: 3508:	if (!hn) {
        -: 3509:	    /* Resolve external commands */
       26: 3510:	    char *cmdarg = (char *) peekfirst(args);
       26: 3511:	    char **checkpath = pathchecked;
       26: 3512:	    int dohashcmd = isset(HASHCMDS);
        -: 3513:
       26: 3514:	    hn = cmdnamtab->getnode(cmdnamtab, cmdarg);
       26: 3515:	    if (hn && trycd && !isreallycom((Cmdnam)hn)) {
    #####: 3516:		if (!(((Cmdnam)hn)->node.flags & HASHED)) {
    #####: 3517:		    checkpath = path;
    #####: 3518:		    dohashcmd = 1;
        -: 3519:		}
    #####: 3520:		cmdnamtab->removenode(cmdnamtab, cmdarg);
    #####: 3521:		cmdnamtab->freenode(hn);
    #####: 3522:		hn = NULL;
        -: 3523:	    }
       26: 3524:	    if (!hn && dohashcmd && strcmp(cmdarg, "..")) {
        6: 3525:		for (s = cmdarg; *s && *s != '/'; s++);
        6: 3526:		if (!*s)
        1: 3527:		    hn = (HashNode) hashcmd(cmdarg, checkpath);
        -: 3528:	    }
        -: 3529:	}
        -: 3530:
        -: 3531:	/* If no command found yet, see if it  *
        -: 3532:	 * is a directory we should AUTOCD to. */
      552: 3533:	if (!hn && trycd && (s = cancd(peekfirst(args)))) {
    #####: 3534:	    peekfirst(args) = (void *) s;
    #####: 3535:	    pushnode(args, dupstring("--"));
    #####: 3536:	    pushnode(args, dupstring("cd"));
    #####: 3537:	    if ((hn = builtintab->getnode(builtintab, "cd")))
    #####: 3538:		is_builtin = 1;
        -: 3539:	}
        -: 3540:    }
        -: 3541:
        -: 3542:    /* This is nonzero if the command is a current shell procedure? */
      796: 3543:    is_cursh = (is_builtin || is_shfunc || nullexec || type >= WC_CURSH);
        -: 3544:
        -: 3545:    /**************************************************************************
        -: 3546:     * Do we need to fork?  We need to fork if:                               *
        -: 3547:     * 1) The command is supposed to run in the background.  This             *
        -: 3548:     *    case is now handled above (forked = 1 here). (or)                   *
        -: 3549:     * 2) There is no `exec' flag, and either:                                *
        -: 3550:     *    a) This is a builtin or shell function with output piped somewhere. *
        -: 3551:     *    b) This is an external command and we can't do a `fake exec'.       *
        -: 3552:     *                                                                        *
        -: 3553:     * A `fake exec' is possible if we have all the following conditions:     *
        -: 3554:     * 1) last1 flag is 1.  This indicates that the current shell will not    *
        -: 3555:     *    be needed after the current command.  This is typically the case    *
        -: 3556:     *    when the command is the last stage in a subshell, or is the         *
        -: 3557:     *    last command after the option `-c'.                                 *
        -: 3558:     * 2) We don't have any traps set.                                        *
        -: 3559:     * 3) We don't have any files to delete.                                  *
        -: 3560:     *                                                                        *
        -: 3561:     * The condition above for a `fake exec' will also work for a current     *
        -: 3562:     * shell command such as a builtin, but doesn't really buy us anything    *
        -: 3563:     * (doesn't save us a process), since it is already running in the        *
        -: 3564:     * current shell.                                                         *
        -: 3565:     **************************************************************************/
        -: 3566:
      796: 3567:    if (!forked) {
      796: 3568:	if (!do_exec &&
      393: 3569:	    (((is_builtin || is_shfunc) && output) ||
       26: 3570:	     (!is_cursh && (last1 != 1 || nsigtrapped || havefiles() ||
        -: 3571:			    fdtable_flocks)))) {
       21: 3572:	    switch (execcmd_fork(state, how, type, varspc, &filelist,
        -: 3573:				 text, oautocont, close_if_forked)) {
    #####: 3574:	    case -1:
    #####: 3575:		goto fatal;
       21: 3576:	    case 0:
       21: 3577:		break;
       21: 3578:	    default:
       21: 3579:		return;
        -: 3580:	    }
       21: 3581:	    forked = 1;
      775: 3582:	} else if (is_cursh) {
        -: 3583:	    /* This is a current shell procedure that didn't need to fork.    *
        -: 3584:	     * This includes current shell procedures that are being exec'ed, *
        -: 3585:	     * as well as null execs.                                         */
      770: 3586:	    jobtab[thisjob].stat |= STAT_CURSH;
      770: 3587:	    if (!jobtab[thisjob].procs)
      770: 3588:		jobtab[thisjob].stat |= STAT_NOPRINT;
      770: 3589:	    if (is_builtin)
      401: 3590:		jobtab[thisjob].stat |= STAT_BUILTIN;
        -: 3591:	} else {
        -: 3592:	    /* This is an exec (real or fake) for an external command.    *
        -: 3593:	     * Note that any form of exec means that the subshell is fake *
        -: 3594:	     * (but we may be in a subshell already).                     */
        5: 3595:	    is_exec = 1;
        -: 3596:	    /*
        -: 3597:	     * If we are in a subshell environment anyway, say we're forked,
        -: 3598:	     * even if we're actually not forked because we know the
        -: 3599:	     * subshell is exiting.  This ensures SHLVL reflects the current
        -: 3600:	     * shell, and also optimises out any save/restore we'd need to
        -: 3601:	     * do if we were returning to the main shell.
        -: 3602:	     */
        5: 3603:	    if (type == WC_SUBSH)
    #####: 3604:		forked = 1;
        -: 3605:	}
        -: 3606:    }
        -: 3607:
      796: 3608:    if ((esglob = !(cflags & BINF_NOGLOB)) && args && eparams->htok) {
      177: 3609:	LinkList oargs = args;
      177: 3610:	globlist(args, 0);
      177: 3611:	args = oargs;
        -: 3612:    }
      796: 3613:    if (errflag) {
    #####: 3614:	lastval = 1;
    #####: 3615:	goto err;
        -: 3616:    }
        -: 3617:
        -: 3618:    /* Make a copy of stderr for xtrace output before redirecting */
      796: 3619:    fflush(xtrerr);
      796: 3620:    if (isset(XTRACE) && xtrerr == stderr &&
    #####: 3621:	(type < WC_SUBSH || type == WC_TIMED)) {
    #####: 3622:	if ((newxtrerr = fdopen(movefd(dup(fileno(stderr))), "w"))) {
    #####: 3623:	    xtrerr = newxtrerr;
    #####: 3624:	    fdtable[fileno(xtrerr)] = FDT_XTRACE;
        -: 3625:	}
        -: 3626:    }
        -: 3627:
        -: 3628:    /* Add pipeline input/output to mnodes */
      796: 3629:    if (input)
    #####: 3630:	addfd(forked, save, mfds, 0, input, 0, NULL);
      796: 3631:    if (output)
    #####: 3632:	addfd(forked, save, mfds, 1, output, 1, NULL);
        -: 3633:
        -: 3634:    /* Do process substitutions */
      796: 3635:    if (redir)
       17: 3636:	spawnpipes(redir, nullexec);
        -: 3637:
        -: 3638:    /* Do io redirections */
     1617: 3639:    while (redir && nonempty(redir)) {
       25: 3640:	fn = (Redir) ugetnode(redir);
        -: 3641:
        -: 3642:	DPUTS(fn->type == REDIR_HEREDOC || fn->type == REDIR_HEREDOCDASH,
        -: 3643:	      "BUG: unexpanded here document");
       25: 3644:	if (fn->type == REDIR_INPIPE) {
    #####: 3645:	    if (!checkclobberparam(fn) || fn->fd2 == -1) {
    #####: 3646:		if (fn->fd2 != -1)
    #####: 3647:		    zclose(fn->fd2);
    #####: 3648:		closemnodes(mfds);
    #####: 3649:		fixfds(save);
    #####: 3650:		execerr();
        -: 3651:	    }
    #####: 3652:	    addfd(forked, save, mfds, fn->fd1, fn->fd2, 0, fn->varid);
       25: 3653:	} else if (fn->type == REDIR_OUTPIPE) {
    #####: 3654:	    if (!checkclobberparam(fn) || fn->fd2 == -1) {
    #####: 3655:		if (fn->fd2 != -1)
    #####: 3656:		    zclose(fn->fd2);
    #####: 3657:		closemnodes(mfds);
    #####: 3658:		fixfds(save);
    #####: 3659:		execerr();
        -: 3660:	    }
    #####: 3661:	    addfd(forked, save, mfds, fn->fd1, fn->fd2, 1, fn->varid);
        -: 3662:	} else {
        -: 3663:	    int closed;
       25: 3664:	    if (fn->type != REDIR_HERESTR && xpandredir(fn, redir))
    #####: 3665:		continue;
       25: 3666:	    if (errflag) {
    #####: 3667:		closemnodes(mfds);
    #####: 3668:		fixfds(save);
    #####: 3669:		execerr();
        -: 3670:	    }
       25: 3671:	    if (isset(RESTRICTED) && IS_WRITE_FILE(fn->type)) {
    #####: 3672:		zwarn("writing redirection not allowed in restricted mode");
    #####: 3673:		execerr();
        -: 3674:	    }
       25: 3675:	    if (unset(EXECOPT))
    #####: 3676:		continue;
       25: 3677:	    switch(fn->type) {
        3: 3678:	    case REDIR_HERESTR:
        3: 3679:		if (!checkclobberparam(fn))
    #####: 3680:		    fil = -1;
        -: 3681:		else
        3: 3682:		    fil = getherestr(fn);
        3: 3683:		if (fil == -1) {
    #####: 3684:		    if (errno && errno != EINTR)
    #####: 3685:			zwarn("can't create temp file for here document: %e",
    #####: 3686:			      errno);
    #####: 3687:		    closemnodes(mfds);
    #####: 3688:		    fixfds(save);
    #####: 3689:		    execerr();
        -: 3690:		}
        3: 3691:		addfd(forked, save, mfds, fn->fd1, fil, 0, fn->varid);
        3: 3692:		break;
        5: 3693:	    case REDIR_READ:
        -: 3694:	    case REDIR_READWRITE:
        5: 3695:		if (!checkclobberparam(fn))
    #####: 3696:		    fil = -1;
        5: 3697:		else if (fn->type == REDIR_READ)
        5: 3698:		    fil = open(unmeta(fn->name), O_RDONLY | O_NOCTTY);
        -: 3699:		else
    #####: 3700:		    fil = open(unmeta(fn->name),
        -: 3701:			       O_RDWR | O_CREAT | O_NOCTTY, 0666);
        5: 3702:		if (fil == -1) {
    #####: 3703:		    closemnodes(mfds);
    #####: 3704:		    fixfds(save);
    #####: 3705:		    if (errno != EINTR)
    #####: 3706:			zwarn("%e: %s", errno, fn->name);
    #####: 3707:		    execerr();
        -: 3708:		}
        5: 3709:		addfd(forked, save, mfds, fn->fd1, fil, 0, fn->varid);
        -: 3710:		/* If this is 'exec < file', read from stdin, *
        -: 3711:		 * not terminal, unless `file' is a terminal. */
        6: 3712:		if (nullexec == 1 && fn->fd1 == 0 &&
        1: 3713:		    isset(SHINSTDIN) && interact && !zleactive)
    #####: 3714:		    init_io(NULL);
        5: 3715:		break;
    #####: 3716:	    case REDIR_CLOSE:
    #####: 3717:		if (fn->varid) {
    #####: 3718:		    char *s = fn->varid, *t;
        -: 3719:		    struct value vbuf;
        -: 3720:		    Value v;
    #####: 3721:		    int bad = 0;
        -: 3722:
    #####: 3723:		    if (!(v = getvalue(&vbuf, &s, 0))) {
    #####: 3724:			bad = 1;
    #####: 3725:		    } else if (v->pm->node.flags & PM_READONLY) {
    #####: 3726:			bad = 2;
        -: 3727:		    } else {
    #####: 3728:			s = getstrvalue(v);
    #####: 3729:			if (errflag)
    #####: 3730:			    bad = 1;
        -: 3731:			else {
    #####: 3732:			    fn->fd1 = zstrtol(s, &t, 0);
    #####: 3733:			    if (s == t)
    #####: 3734:				bad = 1;
    #####: 3735:			    else if (*t) {
        -: 3736:				/* Check for base#number format */
    #####: 3737:				if (*t == '#' && *s != '0')
    #####: 3738:				    fn->fd1 = zstrtol(s = t+1, &t, fn->fd1);
    #####: 3739:				if (s == t || *t)
    #####: 3740:				    bad = 1;
        -: 3741:			    }
    #####: 3742:			    if (!bad && fn->fd1 <= max_zsh_fd) {
    #####: 3743:				if (fn->fd1 >= 10 &&
    #####: 3744:				    (fdtable[fn->fd1] & FDT_TYPE_MASK) ==
        -: 3745:				    FDT_INTERNAL)
    #####: 3746:				    bad = 3;
        -: 3747:			    }
        -: 3748:			}
        -: 3749:		    }
    #####: 3750:		    if (bad) {
    #####: 3751:			const char *bad_msg[] = {
        -: 3752:			    "parameter %s does not contain a file descriptor",
        -: 3753:			    "can't close file descriptor from readonly parameter %s",
        -: 3754:			    "file descriptor %d used by shell, not closed"
        -: 3755:			};
    #####: 3756:			if (bad > 2)
    #####: 3757:			    zwarn(bad_msg[bad-1], fn->fd1);
        -: 3758:			else
    #####: 3759:			    zwarn(bad_msg[bad-1], fn->varid);
    #####: 3760:			execerr();
        -: 3761:		    }
        -: 3762:		}
        -: 3763:		/*
        -: 3764:		 * Note we may attempt to close an fd beyond max_zsh_fd:
        -: 3765:		 * OK as long as we never look in fdtable for it.
        -: 3766: 		 */
    #####: 3767:		closed = 0;
    #####: 3768:		if (!forked && fn->fd1 < 10 && save[fn->fd1] == -2) {
    #####: 3769:		    save[fn->fd1] = movefd(fn->fd1);
    #####: 3770:		    if (save[fn->fd1] >= 0) {
        -: 3771:			/*
        -: 3772:			 * The original fd is now closed, we don't need
        -: 3773:			 * to do it below.
        -: 3774:			 */
    #####: 3775:			closed = 1;
        -: 3776:		    }
        -: 3777:		}
    #####: 3778:		if (fn->fd1 < 10)
    #####: 3779:		    closemn(mfds, fn->fd1, REDIR_CLOSE);
        -: 3780:		/*
        -: 3781:		 * Only report failures to close file descriptors
        -: 3782:		 * if they're under user control as we don't know
        -: 3783:		 * what the previous status of others was.
        -: 3784:		 */
    #####: 3785:		if (!closed && zclose(fn->fd1) < 0 && fn->varid) {
    #####: 3786:		    zwarn("failed to close file descriptor %d: %e",
    #####: 3787:			  fn->fd1, errno);
        -: 3788:		}
    #####: 3789:		break;
        1: 3790:	    case REDIR_MERGEIN:
        -: 3791:	    case REDIR_MERGEOUT:
        1: 3792:		if (fn->fd2 < 10)
        1: 3793:		    closemn(mfds, fn->fd2, fn->type);
        1: 3794:		if (!checkclobberparam(fn))
    #####: 3795:		    fil = -1;
        1: 3796:		else if (fn->fd2 > 9 &&
        -: 3797:			 /*
        -: 3798:			  * If the requested fd is > max_zsh_fd,
        -: 3799:			  * the shell doesn't know about it.
        -: 3800:			  * Just assume the user knows what they're
        -: 3801:			  * doing.
        -: 3802:			  */
    #####: 3803:			 (fn->fd2 <= max_zsh_fd &&
    #####: 3804:			  ((fdtable[fn->fd2] != FDT_UNUSED &&
    #####: 3805:			    fdtable[fn->fd2] != FDT_EXTERNAL) ||
    #####: 3806:			   fn->fd2 == coprocin ||
    #####: 3807:			   fn->fd2 == coprocout))) {
    #####: 3808:		    fil = -1;
    #####: 3809:		    errno = EBADF;
        -: 3810:		} else {
        1: 3811:		    int fd = fn->fd2;
        1: 3812:		    if(fd == -2)
    #####: 3813:			fd = (fn->type == REDIR_MERGEOUT) ? coprocout : coprocin;
        1: 3814:		    fil = movefd(dup(fd));
        -: 3815:		}
        1: 3816:		if (fil == -1) {
        -: 3817:		    char fdstr[DIGBUFSIZE];
        -: 3818:
    #####: 3819:		    closemnodes(mfds);
    #####: 3820:		    fixfds(save);
    #####: 3821:		    if (fn->fd2 != -2)
    #####: 3822:		    	sprintf(fdstr, "%d", fn->fd2);
    #####: 3823:		    if (errno)
    #####: 3824:			zwarn("%s: %e", fn->fd2 == -2 ? "coprocess" : fdstr,
    #####: 3825:			      errno);
    #####: 3826:		    execerr();
        -: 3827:		}
        2: 3828:		addfd(forked, save, mfds, fn->fd1, fil,
        1: 3829:		      fn->type == REDIR_MERGEOUT, fn->varid);
        1: 3830:		break;
       16: 3831:	    default:
       16: 3832:		if (!checkclobberparam(fn))
    #####: 3833:		    fil = -1;
       16: 3834:		else if (IS_APPEND_REDIR(fn->type))
        6: 3835:		    fil = open(unmeta(fn->name),
        6: 3836:			       ((unset(CLOBBER) && unset(APPENDCREATE)) &&
    #####: 3837:				!IS_CLOBBER_REDIR(fn->type)) ?
        -: 3838:			       O_WRONLY | O_APPEND | O_NOCTTY :
        -: 3839:			       O_WRONLY | O_APPEND | O_CREAT | O_NOCTTY, 0666);
        -: 3840:		else
       10: 3841:		    fil = clobber_open(fn);
       16: 3842:		if(fil != -1 && IS_ERROR_REDIR(fn->type))
    #####: 3843:		    dfil = movefd(dup(fil));
        -: 3844:		else
       16: 3845:		    dfil = 0;
       16: 3846:		if (fil == -1 || dfil == -1) {
    #####: 3847:		    if(fil != -1)
    #####: 3848:			close(fil);
    #####: 3849:		    closemnodes(mfds);
    #####: 3850:		    fixfds(save);
    #####: 3851:		    if (errno && errno != EINTR)
    #####: 3852:			zwarn("%e: %s", errno, fn->name);
    #####: 3853:		    execerr();
        -: 3854:		}
       16: 3855:		addfd(forked, save, mfds, fn->fd1, fil, 1, fn->varid);
       16: 3856:		if(IS_ERROR_REDIR(fn->type))
    #####: 3857:		    addfd(forked, save, mfds, 2, dfil, 1, NULL);
       16: 3858:		break;
        -: 3859:	    }
        -: 3860:	    /* May be error in addfd due to setting parameter. */
       25: 3861:	    if (errflag) {
    #####: 3862:		closemnodes(mfds);
    #####: 3863:		fixfds(save);
    #####: 3864:		execerr();
        -: 3865:	    }
        -: 3866:	}
        -: 3867:    }
        -: 3868:
        -: 3869:    /* We are done with redirection.  close the mnodes, *
        -: 3870:     * spawning tee/cat processes as necessary.         */
     8756: 3871:    for (i = 0; i < 10; i++)
     7960: 3872:	if (mfds[i] && mfds[i]->ct >= 2)
    #####: 3873:	    closemn(mfds, i, REDIR_CLOSE);
        -: 3874:
      796: 3875:    if (nullexec) {
        -: 3876:	/*
        -: 3877:	 * If nullexec is 2, we have variables to add with the redirections
        -: 3878:	 * in place.  If nullexec is 1, we may have variables but they
        -: 3879:	 * need the standard restore logic.
        -: 3880:	 */
        2: 3881:	if (varspc) {
    #####: 3882:	    LinkList restorelist = 0, removelist = 0;
    #####: 3883:	    if (!isset(POSIXBUILTINS) && nullexec != 2)
    #####: 3884:		save_params(state, varspc, &restorelist, &removelist);
    #####: 3885:	    addvars(state, varspc, 0);
    #####: 3886:	    if (restorelist)
    #####: 3887:		restore_params(restorelist, removelist);
        -: 3888:	}
        2: 3889:	lastval = errflag ? errflag : cmdoutval;
        2: 3890:	if (nullexec == 1) {
        -: 3891:	    /*
        -: 3892:	     * If nullexec is 1 we specifically *don't* restore the original
        -: 3893:	     * fd's before returning.
        -: 3894:	     */
       22: 3895:	    for (i = 0; i < 10; i++)
       20: 3896:		if (save[i] != -2)
    #####: 3897:		    zclose(save[i]);
        2: 3898:	    goto done;
        -: 3899:	}
    #####: 3900:	if (isset(XTRACE)) {
    #####: 3901:	    fputc('\n', xtrerr);
    #####: 3902:	    fflush(xtrerr);
        -: 3903:	}
     1588: 3904:    } else if (isset(EXECOPT) && !errflag) {
      794: 3905:	int q = queue_signal_level();
        -: 3906:	/*
        -: 3907:	 * We delay the entersubsh() to here when we are exec'ing
        -: 3908:	 * the current shell (including a fake exec to run a builtin then
        -: 3909:	 * exit) in case there is an error return.
        -: 3910:	 */
      794: 3911:	if (is_exec) {
        5: 3912:	    int flags = ((how & Z_ASYNC) ? ESUB_ASYNC : 0) |
        -: 3913:		ESUB_PGRP | ESUB_FAKE;
        5: 3914:	    if (type != WC_SUBSH)
        5: 3915:		flags |= ESUB_KEEPTRAP;
        5: 3916:	    if ((do_exec || (type >= WC_CURSH && last1 == 1))
    #####: 3917:		&& !forked)
    #####: 3918:		flags |= ESUB_REVERTPGRP;
        5: 3919:	    entersubsh(flags, NULL);
        -: 3920:	}
      794: 3921:	if (type == WC_FUNCDEF) {
        -: 3922:	    Eprog redir_prog;
    #####: 3923:	    if (!redir && wc_code(*eparams->beg) == WC_REDIR)  {
        -: 3924:		/*
        -: 3925:		 * We're not using a redirection from the currently
        -: 3926:		 * parsed environment, which is what we'd do for an
        -: 3927:		 * anonymous function, but there are redirections we
        -: 3928:		 * should store with the new function.
        -: 3929:		 */
        -: 3930:		struct estate s;
        -: 3931:
    #####: 3932:		s.prog = state->prog;
    #####: 3933:		s.pc = eparams->beg;
    #####: 3934:		s.strs = state->prog->strs;
        -: 3935:
        -: 3936:		/*
        -: 3937:		 * The copy uses the wordcode parsing area, so save and
        -: 3938:		 * restore state.
        -: 3939:		 */
    #####: 3940:		zcontext_save();
    #####: 3941:		redir_prog = eccopyredirs(&s);
    #####: 3942:		zcontext_restore();
        -: 3943:	    } else
    #####: 3944:		redir_prog = NULL;
        -: 3945:
    #####: 3946:	    dont_queue_signals();
    #####: 3947:	    lastval = execfuncdef(state, redir_prog);
    #####: 3948:	    restore_queue_signals(q);
        -: 3949:	}
      794: 3950:	else if (type >= WC_CURSH) {
      242: 3951:	    if (last1 == 1)
    #####: 3952:		do_exec = 1;
      242: 3953:	    dont_queue_signals();
      242: 3954:	    if (type == WC_AUTOFN) {
        -: 3955:		/*
        -: 3956:		 * We pre-loaded this to get any redirs.
        -: 3957:		 * So we execuate a simplified function here.
        -: 3958:		 */
    #####: 3959:		lastval =  execautofn_basic(state, do_exec);
        -: 3960:	    } else
      242: 3961:		lastval = (execfuncs[type - WC_CURSH])(state, do_exec);
      242: 3962:	    restore_queue_signals(q);
     1076: 3963:	} else if (is_builtin || is_shfunc) {
      526: 3964:	    LinkList restorelist = 0, removelist = 0;
      526: 3965:	    int do_save = 0;
        -: 3966:	    /* builtin or shell function */
        -: 3967:
      526: 3968:	    if (!forked) {
      526: 3969:		if (isset(POSIXBUILTINS)) {
        -: 3970:		    /*
        -: 3971:		     * If it's a function or special builtin --- save
        -: 3972:		     * if it's got "command" in front.
        -: 3973:		     * If it's a normal command --- save.
        -: 3974:		     */
    #####: 3975:		    if (is_shfunc || (hn->flags & (BINF_PSPECIAL|BINF_ASSIGN)))
    #####: 3976:			do_save = (orig_cflags & BINF_COMMAND);
        -: 3977:		    else
    #####: 3978:			do_save = 1;
        -: 3979:		} else {
        -: 3980:		    /*
        -: 3981:		     * Save if it's got "command" in front or it's
        -: 3982:		     * not a magic-equals assignment.
        -: 3983:		     */
      526: 3984:		    if ((cflags & (BINF_COMMAND|BINF_ASSIGN)) || !magic_assign)
      526: 3985:			do_save = 1;
        -: 3986:		}
      526: 3987:		if (do_save && varspc)
    #####: 3988:		    save_params(state, varspc, &restorelist, &removelist);
        -: 3989:	    }
      526: 3990:	    if (varspc) {
        -: 3991:		/* Export this if the command is a shell function,
        -: 3992:		 * but not if it's a builtin.
        -: 3993:		 */
    #####: 3994:		int flags = 0;
    #####: 3995:		if (is_shfunc)
    #####: 3996:		    flags |= ADDVAR_EXPORT;
    #####: 3997:		if (restorelist)
    #####: 3998:		    flags |= ADDVAR_RESTORE;
        -: 3999:
    #####: 4000:		addvars(state, varspc, flags);
    #####: 4001:		if (errflag) {
    #####: 4002:		    if (restorelist)
    #####: 4003:			restore_params(restorelist, removelist);
    #####: 4004:		    lastval = 1;
    #####: 4005:		    fixfds(save);
    #####: 4006:		    goto done;
        -: 4007:		}
        -: 4008:	    }
        -: 4009:
      526: 4010:	    if (is_shfunc) {
        -: 4011:		/* It's a shell function */
      125: 4012:		execshfunc((Shfunc) hn, args);
      125: 4013:		pipecleanfilelist(filelist, 0);
        -: 4014:	    } else {
        -: 4015:		/* It's a builtin */
      401: 4016:		LinkList assigns = (LinkList)0;
      401: 4017:		int postassigns = eparams->postassigns;
      401: 4018:		if (forked)
    #####: 4019:		    closem(FDT_INTERNAL, 0);
      401: 4020:		if (postassigns) {
       98: 4021:		    Wordcode opc = state->pc;
       98: 4022:		    state->pc = eparams->assignspc;
       98: 4023:		    assigns = newlinklist();
       98: 4024:		    while (postassigns--) {
        -: 4025:			int htok;
      107: 4026:			wordcode ac = *state->pc++;
      107: 4027:			char *name = ecgetstr(state, EC_DUPTOK, &htok);
        -: 4028:			Asgment asg;
        -: 4029:			local_list1(svl);
        -: 4030:
        -: 4031:			DPUTS(wc_code(ac) != WC_ASSIGN,
        -: 4032:			      "BUG: bad assignment list for typeset");
      107: 4033:			if (htok) {
    #####: 4034:			    init_list1(svl, name);
    #####: 4035:			    if (WC_ASSIGN_TYPE(ac) == WC_ASSIGN_SCALAR &&
    #####: 4036:				WC_ASSIGN_TYPE2(ac) == WC_ASSIGN_INC) {
        -: 4037:				char *data;
        -: 4038:				/*
        -: 4039:				 * Special case: this is a name only, so
        -: 4040:				 * it's not required to be a single
        -: 4041:				 * expansion.  Furthermore, for
        -: 4042:				 * consistency with the builtin
        -: 4043:				 * interface, it may expand into
        -: 4044:				 * scalar assignments:
        -: 4045:				 *  ass=(one=two three=four)
        -: 4046:				 *  typeset a=b $ass
        -: 4047:				 */
        -: 4048:				/* Unused dummy value for name */
    #####: 4049:				(void)ecgetstr(state, EC_DUPTOK, &htok);
    #####: 4050:				prefork(&svl, PREFORK_TYPESET, NULL);
    #####: 4051:				if (errflag) {
    #####: 4052:				    state->pc = opc;
    #####: 4053:				    break;
        -: 4054:				}
    #####: 4055:				globlist(&svl, 0);
    #####: 4056:				if (errflag) {
    #####: 4057:				    state->pc = opc;
    #####: 4058:				    break;
        -: 4059:				}
    #####: 4060:				while ((data = ugetnode(&svl))) {
        -: 4061:				    char *ptr;
    #####: 4062:				    asg = (Asgment)zhalloc(sizeof(struct asgment));
    #####: 4063:				    asg->flags = 0;
    #####: 4064:				    if ((ptr = strchr(data, '='))) {
    #####: 4065:					*ptr++ = '\0';
    #####: 4066:					asg->name = data;
    #####: 4067:					asg->value.scalar = ptr;
        -: 4068:				    } else {
    #####: 4069:					asg->name = data;
    #####: 4070:					asg->value.scalar = NULL;
        -: 4071:				    }
    #####: 4072:				    uaddlinknode(assigns, &asg->node);
        -: 4073:				}
    #####: 4074:				continue;
        -: 4075:			    }
    #####: 4076:			    prefork(&svl, PREFORK_SINGLE, NULL);
    #####: 4077:			    name = empty(&svl) ? "" :
    #####: 4078:				(char *)getdata(firstnode(&svl));
        -: 4079:			}
      107: 4080:			untokenize(name);
      107: 4081:			asg = (Asgment)zhalloc(sizeof(struct asgment));
      107: 4082:			asg->name = name;
      107: 4083:			if (WC_ASSIGN_TYPE(ac) == WC_ASSIGN_SCALAR) {
      107: 4084:			    char *val = ecgetstr(state, EC_DUPTOK, &htok);
      107: 4085:			    asg->flags = 0;
      107: 4086:			    if (WC_ASSIGN_TYPE2(ac) == WC_ASSIGN_INC) {
        -: 4087:				/* Fake assignment, no value */
        7: 4088:				asg->value.scalar = NULL;
        -: 4089:			    } else {
      100: 4090:				if (htok) {
       69: 4091:				    init_list1(svl, val);
       69: 4092:				    prefork(&svl,
        -: 4093:					    PREFORK_SINGLE|PREFORK_ASSIGN,
        -: 4094:					    NULL);
       69: 4095:				    if (errflag) {
    #####: 4096:					state->pc = opc;
    #####: 4097:					break;
        -: 4098:				    }
        -: 4099:				    /*
        -: 4100:				     * No globassign for typeset
        -: 4101:				     * arguments, thank you
        -: 4102:				     */
      138: 4103:				    val = empty(&svl) ? "" :
       69: 4104:					(char *)getdata(firstnode(&svl));
        -: 4105:				}
      100: 4106:				untokenize(val);
      100: 4107:				asg->value.scalar = val;
        -: 4108:			    }
        -: 4109:			} else {
    #####: 4110:			    asg->flags = ASG_ARRAY;
    #####: 4111:			    asg->value.array =
    #####: 4112:				ecgetlist(state, WC_ASSIGN_NUM(ac),
        -: 4113:					  EC_DUPTOK, &htok);
    #####: 4114:			    if (asg->value.array)
        -: 4115:			    {
    #####: 4116:				if (!errflag) {
    #####: 4117:				    int prefork_ret = 0;
    #####: 4118:				    prefork(asg->value.array, PREFORK_ASSIGN,
        -: 4119:					    &prefork_ret);
    #####: 4120:				    if (errflag) {
    #####: 4121:					state->pc = opc;
    #####: 4122:					break;
        -: 4123:				    }
    #####: 4124:				    if (prefork_ret & PREFORK_KEY_VALUE)
    #####: 4125:					asg->flags |= ASG_KEY_VALUE;
    #####: 4126:				    globlist(asg->value.array, prefork_ret);
        -: 4127:				}
    #####: 4128:				if (errflag) {
    #####: 4129:				    state->pc = opc;
    #####: 4130:				    break;
        -: 4131:				}
        -: 4132:			    }
        -: 4133:			}
        -: 4134:
      107: 4135:			uaddlinknode(assigns, &asg->node);
        -: 4136:		    }
       98: 4137:		    state->pc = opc;
        -: 4138:		}
      401: 4139:		dont_queue_signals();
      401: 4140:		if (!errflag) {
      401: 4141:		    int ret = execbuiltin(args, assigns, (Builtin) hn);
        -: 4142:		    /*
        -: 4143:		     * In case of interruption assume builtin status
        -: 4144:		     * is less useful than what interrupt set.
        -: 4145:		     */
      399: 4146:		    if (!(errflag & ERRFLAG_INT))
      399: 4147:			lastval = ret;
        -: 4148:		}
      399: 4149:		if (do_save & BINF_COMMAND)
    #####: 4150:		    errflag &= ~ERRFLAG_ERROR;
      399: 4151:		restore_queue_signals(q);
      399: 4152:		fflush(stdout);
      399: 4153:		if (save[1] == -2) {
      392: 4154:		    if (ferror(stdout)) {
    #####: 4155:			zwarn("write error: %e", errno);
    #####: 4156:			clearerr(stdout);
        -: 4157:		    }
        -: 4158:		} else
        7: 4159:		    clearerr(stdout);
        -: 4160:	    }
      524: 4161:	    if (isset(PRINTEXITVALUE) && isset(SHINSTDIN) &&
    #####: 4162:		lastval && !subsh) {
        -: 4163:#if defined(ZLONG_IS_LONG_LONG) && defined(PRINTF_HAS_LLD)
        -: 4164:		fprintf(stderr, "zsh: exit %lld\n", lastval);
        -: 4165:#else
    #####: 4166:		fprintf(stderr, "zsh: exit %ld\n", (long)lastval);
        -: 4167:#endif
    #####: 4168:		fflush(stderr);
        -: 4169:	    }
        -: 4170:
      524: 4171:	    if (do_exec) {
    #####: 4172:		if (subsh)
    #####: 4173:		    _realexit();
        -: 4174:
        -: 4175:		/* If we are exec'ing a command, and we are not in a subshell, *
        -: 4176:		 * then check if we should save the history file.              */
    #####: 4177:		if (isset(RCS) && interact && !nohistsave)
    #####: 4178:		    savehistfile(NULL, 1, HFILE_USE_OPTIONS);
    #####: 4179:		realexit();
        -: 4180:	    }
      524: 4181:	    if (restorelist)
    #####: 4182:		restore_params(restorelist, removelist);
        -: 4183:
        -: 4184:	} else {
       26: 4185:	    if (!subsh) {
        -: 4186:	        /* for either implicit or explicit "exec", decrease $SHLVL
        -: 4187:		 * as we're now done as a shell */
    #####: 4188:		if (!forked)
    #####: 4189:		    setiparam("SHLVL", --shlvl);
        -: 4190:
        -: 4191:		/* If we are exec'ing a command, and we are not *
        -: 4192:		 * in a subshell, then save the history file.   */
    #####: 4193:		if (do_exec && isset(RCS) && interact && !nohistsave)
    #####: 4194:		    savehistfile(NULL, 1, HFILE_USE_OPTIONS);
        -: 4195:	    }
       26: 4196:	    if (type == WC_SIMPLE || type == WC_TYPESET) {
       26: 4197:		if (varspc) {
        3: 4198:		    int addflags = ADDVAR_EXPORT|ADDVAR_RESTRICT;
        3: 4199:		    if (forked)
        3: 4200:			addflags |= ADDVAR_RESTORE;
        3: 4201:		    addvars(state, varspc, addflags);
        3: 4202:		    if (errflag)
    #####: 4203:			_exit(1);
        -: 4204:		}
       26: 4205:		closem(FDT_INTERNAL, 0);
       26: 4206:		if (coprocin != -1) {
    #####: 4207:		    zclose(coprocin);
    #####: 4208:		    coprocin = -1;
        -: 4209:		}
       26: 4210:		if (coprocout != -1) {
    #####: 4211:		    zclose(coprocout);
    #####: 4212:		    coprocout = -1;
        -: 4213:		}
        -: 4214:#ifdef HAVE_GETRLIMIT
       26: 4215:		if (!forked)
        5: 4216:		    setlimits(NULL);
        -: 4217:#endif
       26: 4218:		if (how & Z_ASYNC) {
    #####: 4219:		    zsfree(STTYval);
    #####: 4220:		    STTYval = 0;
        -: 4221:		}
       26: 4222:		execute(args, cflags, use_defpath);
        -: 4223:	    } else {		/* ( ... ) */
        -: 4224:		DPUTS(varspc,
        -: 4225:		      "BUG: assignment before complex command");
    #####: 4226:		list_pipe = 0;
    #####: 4227:		pipecleanfilelist(filelist, 0);
        -: 4228:		/* If we're forked (and we should be), no need to return */
        -: 4229:		DPUTS(last1 != 1 && !forked, "BUG: not exiting?");
        -: 4230:		DPUTS(type != WC_SUBSH, "Not sure what we're doing.");
        -: 4231:		/* Skip word only used for try/always blocks */
    #####: 4232:		state->pc++;
    #####: 4233:		execlist(state, 0, 1);
        -: 4234:	    }
        -: 4235:	}
        -: 4236:    }
        -: 4237:
      766: 4238:  err:
      766: 4239:    if (forked) {
        -: 4240:	/*
        -: 4241:	 * So what's going on here then?  Well, I'm glad you asked.
        -: 4242:	 *
        -: 4243:	 * If we create multios for use in a subshell we do
        -: 4244:	 * this after forking, in this function above.  That
        -: 4245:	 * means that the current (sub)process is responsible
        -: 4246:	 * for clearing them up.  However, the processes won't
        -: 4247:	 * go away until we have closed the fd's talking to them.
        -: 4248:	 * Since we're about to exit the shell there's nothing
        -: 4249:	 * to stop us closing all fd's (including the ones 0 to 9
        -: 4250:	 * that we usually leave alone).
        -: 4251:	 *
        -: 4252:	 * Then we wait for any processes.  When we forked,
        -: 4253:	 * we cleared the jobtable and started a new job just for
        -: 4254:	 * any oddments like this, so if there aren't any we won't
        -: 4255:	 * need to wait.  The result of not waiting is that
        -: 4256:	 * the multios haven't flushed the fd's properly, leading
        -: 4257:	 * to obscure missing data.
        -: 4258:	 *
        -: 4259:	 * It would probably be cleaner to ensure that the
        -: 4260:	 * parent shell handled multios, but that requires
        -: 4261:	 * some architectural changes which are likely to be
        -: 4262:	 * hairy.
        -: 4263:	 */
    #####: 4264:	for (i = 0; i < 10; i++)
    #####: 4265:	    if (fdtable[i] != FDT_UNUSED)
    #####: 4266:		close(i);
    #####: 4267:	closem(FDT_UNUSED, 1);
    #####: 4268:	if (thisjob != -1)
    #####: 4269:	    waitjobs();
    #####: 4270:	_realexit();
        -: 4271:    }
      766: 4272:    fixfds(save);
        -: 4273:
      768: 4274: done:
      768: 4275:    if (isset(POSIXBUILTINS) &&
    #####: 4276:	(cflags & (BINF_PSPECIAL|BINF_EXEC)) &&
    #####: 4277:	!(orig_cflags & BINF_COMMAND)) {
        -: 4278:	/*
        -: 4279:	 * For POSIX-compatible behaviour with special
        -: 4280:	 * builtins (including exec which we don't usually
        -: 4281:	 * classify as a builtin) we treat all errors as fatal.
        -: 4282:	 * The "command" builtin is not special so resets this behaviour.
        -: 4283:	 */
    #####: 4284:	forked |= zsh_subshell;
    #####: 4285:    fatal:
    #####: 4286:	if (redir_err || errflag) {
    #####: 4287:	    if (!isset(INTERACTIVE)) {
    #####: 4288:		if (forked)
    #####: 4289:		    _exit(1);
        -: 4290:		else
    #####: 4291:		    exit(1);
        -: 4292:	    }
    #####: 4293:	    errflag |= ERRFLAG_ERROR;
        -: 4294:	}
        -: 4295:    }
      768: 4296:    if (newxtrerr) {
    #####: 4297:	fil = fileno(newxtrerr);
    #####: 4298:	fclose(newxtrerr);
    #####: 4299:	xtrerr = oxtrerr;
    #####: 4300:	zclose(fil);
        -: 4301:    }
        -: 4302:
      768: 4303:    zsfree(STTYval);
      768: 4304:    STTYval = 0;
      768: 4305:    if (oautocont >= 0)
    #####: 4306:	opts[AUTOCONTINUE] = oautocont;
        -: 4307:}
        -: 4308:
        -: 4309:/* Arrange to have variables restored. */
        -: 4310:
        -: 4311:/**/
        -: 4312:static void
    #####: 4313:save_params(Estate state, Wordcode pc, LinkList *restore_p, LinkList *remove_p)
        -: 4314:{
        -: 4315:    Param pm;
        -: 4316:    char *s;
        -: 4317:    wordcode ac;
        -: 4318:
    #####: 4319:    *restore_p = newlinklist();
    #####: 4320:    *remove_p = newlinklist();
        -: 4321:
    #####: 4322:    while (wc_code(ac = *pc) == WC_ASSIGN) {
    #####: 4323:	s = ecrawstr(state->prog, pc + 1, NULL);
    #####: 4324:	if ((pm = (Param) paramtab->getnode(paramtab, s))) {
        -: 4325:	    Param tpm;
    #####: 4326:	    if (pm->env)
    #####: 4327:		delenv(pm);
    #####: 4328:	    if (!(pm->node.flags & PM_SPECIAL)) {
        -: 4329:		/*
        -: 4330:		 * We used to remove ordinary parameters from the
        -: 4331:		 * table, but that meant "HELLO=$HELLO shellfunc"
        -: 4332:		 * failed because the expansion of $HELLO hasn't
        -: 4333:		 * been done at this point.  Instead, copy the
        -: 4334:		 * parameter:  in this case, we'll insert the
        -: 4335:		 * copied parameter straight back into the parameter
        -: 4336:		 * table so we want to be sure everything is
        -: 4337:		 * properly set up and in permanent memory.
        -: 4338:		 */
    #####: 4339:		tpm = (Param) zshcalloc(sizeof *tpm);
    #####: 4340:		tpm->node.nam = ztrdup(pm->node.nam);
    #####: 4341:		copyparam(tpm, pm, 0);
    #####: 4342:		pm = tpm;
    #####: 4343:	    } else if (!(pm->node.flags & PM_READONLY) &&
    #####: 4344:		       (unset(RESTRICTED) || !(pm->node.flags & PM_RESTRICTED))) {
        -: 4345:		/*
        -: 4346:		 * In this case we're just saving parts of
        -: 4347:		 * the parameter in a temporary, so use heap allocation
        -: 4348:		 * and don't bother copying every detail.
        -: 4349:		 */
    #####: 4350:		tpm = (Param) hcalloc(sizeof *tpm);
    #####: 4351:		tpm->node.nam = pm->node.nam;
    #####: 4352:		copyparam(tpm, pm, 1);
    #####: 4353:		pm = tpm;
        -: 4354:	    }
    #####: 4355:	    addlinknode(*remove_p, dupstring(s));
    #####: 4356:	    addlinknode(*restore_p, pm);
        -: 4357:	} else
    #####: 4358:	    addlinknode(*remove_p, dupstring(s));
        -: 4359:
    #####: 4360:	pc += (WC_ASSIGN_TYPE(ac) == WC_ASSIGN_SCALAR ?
    #####: 4361:	       3 : WC_ASSIGN_NUM(ac) + 2);
        -: 4362:    }
    #####: 4363:}
        -: 4364:
        -: 4365:/* Restore saved parameters after executing a shfunc or builtin */
        -: 4366:
        -: 4367:/**/
        -: 4368:static void
    #####: 4369:restore_params(LinkList restorelist, LinkList removelist)
        -: 4370:{
        -: 4371:    Param pm;
        -: 4372:    char *s;
        -: 4373:
        -: 4374:    /* remove temporary parameters */
    #####: 4375:    while ((s = (char *) ugetnode(removelist))) {
    #####: 4376:	if ((pm = (Param) paramtab->getnode(paramtab, s)) &&
    #####: 4377:	    !(pm->node.flags & PM_SPECIAL)) {
    #####: 4378:	    pm->node.flags &= ~PM_READONLY;
    #####: 4379:	    unsetparam_pm(pm, 0, 0);
        -: 4380:	}
        -: 4381:    }
        -: 4382:
    #####: 4383:    if (restorelist) {
        -: 4384:	/* restore saved parameters */
    #####: 4385:	while ((pm = (Param) ugetnode(restorelist))) {
    #####: 4386:	    if (pm->node.flags & PM_SPECIAL) {
    #####: 4387:		Param tpm = (Param) paramtab->getnode(paramtab, pm->node.nam);
        -: 4388:
        -: 4389:		DPUTS(!tpm || PM_TYPE(pm->node.flags) != PM_TYPE(tpm->node.flags) ||
        -: 4390:		      !(pm->node.flags & PM_SPECIAL),
        -: 4391:		      "BUG: in restoring special parameters");
    #####: 4392:		if (!pm->env && tpm->env)
    #####: 4393:		    delenv(tpm);
    #####: 4394:		tpm->node.flags = pm->node.flags;
    #####: 4395:		switch (PM_TYPE(pm->node.flags)) {
    #####: 4396:		case PM_SCALAR:
    #####: 4397:		    tpm->gsu.s->setfn(tpm, pm->u.str);
    #####: 4398:		    break;
    #####: 4399:		case PM_INTEGER:
    #####: 4400:		    tpm->gsu.i->setfn(tpm, pm->u.val);
    #####: 4401:		    break;
    #####: 4402:		case PM_EFLOAT:
        -: 4403:		case PM_FFLOAT:
    #####: 4404:		    tpm->gsu.f->setfn(tpm, pm->u.dval);
    #####: 4405:		    break;
    #####: 4406:		case PM_ARRAY:
    #####: 4407:		    tpm->gsu.a->setfn(tpm, pm->u.arr);
    #####: 4408:		    break;
    #####: 4409:		case PM_HASHED:
    #####: 4410:		    tpm->gsu.h->setfn(tpm, pm->u.hash);
    #####: 4411:		    break;
        -: 4412:		}
    #####: 4413:		pm = tpm;
        -: 4414:	    } else {
    #####: 4415:		paramtab->addnode(paramtab, pm->node.nam, pm);
        -: 4416:	    }
    #####: 4417:	    if ((pm->node.flags & PM_EXPORTED) && ((s = getsparam(pm->node.nam))))
    #####: 4418:		addenv(pm, s);
        -: 4419:	}
        -: 4420:    }
    #####: 4421:}
        -: 4422:
        -: 4423:/* restore fds after redirecting a builtin */
        -: 4424:
        -: 4425:/**/
        -: 4426:static void
      766: 4427:fixfds(int *save)
        -: 4428:{
      766: 4429:    int old_errno = errno;
        -: 4430:    int i;
        -: 4431:
     8426: 4432:    for (i = 0; i != 10; i++)
     7660: 4433:	if (save[i] != -2)
       20: 4434:	    redup(save[i], i);
      766: 4435:    errno = old_errno;
      766: 4436:}
        -: 4437:
        -: 4438:/*
        -: 4439: * Close internal shell fds.
        -: 4440: *
        -: 4441: * Close any that are marked as used if "how" is FDT_UNUSED, else
        -: 4442: * close any with the value "how".
        -: 4443: *
        -: 4444: * If "all" is zero, we'll skip cases where we need the file
        -: 4445: * descriptor to be visible externally.
        -: 4446: */
        -: 4447:
        -: 4448:/**/
        -: 4449:mod_export void
       52: 4450:closem(int how, int all)
        -: 4451:{
        -: 4452:    int i;
        -: 4453:
      183: 4454:    for (i = 10; i <= max_zsh_fd; i++)
      131: 4455:	if (fdtable[i] != FDT_UNUSED &&
        -: 4456:	    /*
        -: 4457:	     * Process substitution needs to be visible to user;
        -: 4458:	     * fd's are explicitly cleaned up by filelist handling.
        -: 4459:	     * External FDs are managed directly by the user.
        -: 4460:	     */
      220: 4461:	    (all || (fdtable[i] != FDT_PROC_SUBST &&
      136: 4462:		     fdtable[i] != FDT_EXTERNAL)) &&
       26: 4463:	    (how == FDT_UNUSED || (fdtable[i] & FDT_TYPE_MASK) == how)) {
       26: 4464:	    if (i == SHTTY)
    #####: 4465:		SHTTY = -1;
       26: 4466:	    zclose(i);
        -: 4467:	}
       52: 4468:}
        -: 4469:
        -: 4470:/* convert here document into a here string */
        -: 4471:
        -: 4472:/**/
        -: 4473:char *
    #####: 4474:gethere(char **strp, int typ)
        -: 4475:{
        -: 4476:    char *buf;
    #####: 4477:    int bsiz, qt = 0, strip = 0;
        -: 4478:    char *s, *t, *bptr, c;
    #####: 4479:    char *str = *strp;
        -: 4480:
    #####: 4481:    for (s = str; *s; s++)
    #####: 4482:	if (inull(*s)) {
    #####: 4483:	    qt = 1;
    #####: 4484:	    break;
        -: 4485:	}
    #####: 4486:    str = quotesubst(str);
    #####: 4487:    untokenize(str);
    #####: 4488:    if (typ == REDIR_HEREDOCDASH) {
    #####: 4489:	strip = 1;
    #####: 4490:	while (*str == '\t')
    #####: 4491:	    str++;
        -: 4492:    }
    #####: 4493:    *strp = str;
    #####: 4494:    bptr = buf = zalloc(bsiz = 256);
        -: 4495:    for (;;) {
    #####: 4496:	t = bptr;
        -: 4497:
    #####: 4498:	while ((c = hgetc()) == '\t' && strip)
        -: 4499:	    ;
        -: 4500:	for (;;) {
    #####: 4501:	    if (bptr >= buf + bsiz - 2) {
    #####: 4502:		ptrdiff_t toff = t - buf;
    #####: 4503:		ptrdiff_t bptroff = bptr - buf;
    #####: 4504:		char *newbuf = realloc(buf, 2 * bsiz);
    #####: 4505:		if (!newbuf) {
        -: 4506:		    /* out of memory */
    #####: 4507:		    zfree(buf, bsiz);
    #####: 4508:		    return NULL;
        -: 4509:		}
    #####: 4510:		buf = newbuf;
    #####: 4511:		t = buf + toff;
    #####: 4512:		bptr = buf + bptroff;
    #####: 4513:		bsiz *= 2;
        -: 4514:	    }
    #####: 4515:	    if (lexstop || c == '\n')
        -: 4516:		break;
    #####: 4517:	    if (!qt && c == '\\') {
    #####: 4518:		*bptr++ = c;
    #####: 4519:		c = hgetc();
    #####: 4520:		if (c == '\n') {
    #####: 4521:		    bptr--;
    #####: 4522:		    c = hgetc();
    #####: 4523:		    continue;
        -: 4524:		}
        -: 4525:	    }
    #####: 4526:	    *bptr++ = c;
    #####: 4527:	    c = hgetc();
        -: 4528:	}
    #####: 4529:	*bptr = '\0';
    #####: 4530:	if (!strcmp(t, str))
    #####: 4531:	    break;
    #####: 4532:	if (lexstop) {
    #####: 4533:	    t = bptr;
    #####: 4534:	    break;
        -: 4535:	}
    #####: 4536:	*bptr++ = '\n';
        -: 4537:    }
    #####: 4538:    *t = '\0';
    #####: 4539:    s = buf;
    #####: 4540:    buf = dupstring(buf);
    #####: 4541:    zfree(s, bsiz);
    #####: 4542:    if (!qt) {
    #####: 4543:	int ef = errflag;
        -: 4544:
    #####: 4545:	parsestr(&buf);
        -: 4546:
    #####: 4547:	if (!(errflag & ERRFLAG_ERROR)) {
        -: 4548:	    /* Retain any user interrupt error */
    #####: 4549:	    errflag = ef | (errflag & ERRFLAG_INT);
        -: 4550:	}
        -: 4551:    }
    #####: 4552:    return buf;
        -: 4553:}
        -: 4554:
        -: 4555:/* open here string fd */
        -: 4556:
        -: 4557:/**/
        -: 4558:static int
        3: 4559:getherestr(struct redir *fn)
        -: 4560:{
        -: 4561:    char *s, *t;
        -: 4562:    int fd, len;
        -: 4563:
        3: 4564:    t = fn->name;
        3: 4565:    singsub(&t);
        3: 4566:    untokenize(t);
        3: 4567:    unmetafy(t, &len);
        -: 4568:    /*
        -: 4569:     * For real here-strings we append a newline, as if the
        -: 4570:     * string given was a complete command line.
        -: 4571:     *
        -: 4572:     * For here-strings from here documents, we use the original
        -: 4573:     * text exactly.
        -: 4574:     */
        3: 4575:    if (!(fn->flags & REDIRF_FROM_HEREDOC))
        3: 4576:	t[len++] = '\n';
        3: 4577:    if ((fd = gettempfile(NULL, 1, &s)) < 0)
    #####: 4578:	return -1;
        3: 4579:    write_loop(fd, t, len);
        3: 4580:    close(fd);
        3: 4581:    fd = open(s, O_RDONLY | O_NOCTTY);
        3: 4582:    unlink(s);
        3: 4583:    return fd;
        -: 4584:}
        -: 4585:
        -: 4586:/*
        -: 4587: * Test if some wordcode starts with a simple redirection of type
        -: 4588: * redir_type.  If it does, return the name of the file, copied onto
        -: 4589: * the heap.  If it doesn't, return NULL.
        -: 4590: */
        -: 4591:
        -: 4592:static char *
       19: 4593:simple_redir_name(Eprog prog, int redir_type)
        -: 4594:{
        -: 4595:    Wordcode pc;
        -: 4596:
       19: 4597:    pc = prog->prog;
       38: 4598:    if (prog != &dummy_eprog &&
       57: 4599:	wc_code(pc[0]) == WC_LIST && (WC_LIST_TYPE(pc[0]) & Z_END) &&
       57: 4600:	wc_code(pc[1]) == WC_SUBLIST && !WC_SUBLIST_FLAGS(pc[1]) &&
       38: 4601:	WC_SUBLIST_TYPE(pc[1]) == WC_SUBLIST_END &&
       57: 4602:	wc_code(pc[2]) == WC_PIPE && WC_PIPE_TYPE(pc[2]) == WC_PIPE_END &&
       47: 4603:	wc_code(pc[3]) == WC_REDIR && WC_REDIR_TYPE(pc[3]) == redir_type &&
       28: 4604:	!WC_REDIR_VARID(pc[3]) &&
       28: 4605:	!pc[4] &&
       28: 4606:	wc_code(pc[6]) == WC_SIMPLE && !WC_SIMPLE_ARGC(pc[6])) {
       14: 4607:	return dupstring(ecrawstr(prog, pc + 5, NULL));
        -: 4608:    }
        -: 4609:
        5: 4610:    return NULL;
        -: 4611:}
        -: 4612:
        -: 4613:/* $(...) */
        -: 4614:
        -: 4615:/**/
        -: 4616:LinkList
       19: 4617:getoutput(char *cmd, int qt)
        -: 4618:{
        -: 4619:    Eprog prog;
        -: 4620:    int pipes[2];
        -: 4621:    pid_t pid;
        -: 4622:    char *s;
        -: 4623:
       19: 4624:    int onc = nocomments;
       19: 4625:    nocomments = (interact && unset(INTERACTIVECOMMENTS));
       19: 4626:    prog = parse_string(cmd, 0);
       19: 4627:    nocomments = onc;
        -: 4628:
       19: 4629:    if (!prog)
    #####: 4630:	return NULL;
        -: 4631:
       19: 4632:    if ((s = simple_redir_name(prog, REDIR_READ))) {
        -: 4633:	/* $(< word) */
        -: 4634:	int stream;
        -: 4635:	LinkList retval;
        -: 4636:	int readerror;
        -: 4637:
       14: 4638:	singsub(&s);
       14: 4639:	if (errflag)
    #####: 4640:	    return NULL;
       14: 4641:	untokenize(s);
       14: 4642:	if ((stream = open(unmeta(s), O_RDONLY | O_NOCTTY)) == -1) {
    #####: 4643:	    zwarn("%e: %s", errno, s);
    #####: 4644:	    lastval = cmdoutval = 1;
    #####: 4645:	    return newlinklist();
        -: 4646:	}
       14: 4647:	retval = readoutput(stream, qt, &readerror);
       14: 4648:	if (readerror) {
    #####: 4649:	  zwarn("error when reading %s: %e", s, readerror);
    #####: 4650:	  lastval = cmdoutval = 1;
        -: 4651:	}
       14: 4652:	return retval;
        -: 4653:    }
        5: 4654:    if (mpipe(pipes) < 0) {
    #####: 4655:	errflag |= ERRFLAG_ERROR;
    #####: 4656:	cmdoutpid = 0;
    #####: 4657:	return NULL;
        -: 4658:    }
        5: 4659:    child_block();
        5: 4660:    cmdoutval = 0;
        5: 4661:    if ((cmdoutpid = pid = zfork(NULL)) == -1) {
        -: 4662:	/* fork error */
    #####: 4663:	zclose(pipes[0]);
    #####: 4664:	zclose(pipes[1]);
    #####: 4665:	errflag |= ERRFLAG_ERROR;
    #####: 4666:	cmdoutpid = 0;
    #####: 4667:	child_unblock();
    #####: 4668:	return NULL;
       10: 4669:    } else if (pid) {
        -: 4670:	LinkList retval;
        -: 4671:
        5: 4672:	zclose(pipes[1]);
        5: 4673:	retval = readoutput(pipes[0], qt, NULL);
        5: 4674:	fdtable[pipes[0]] = FDT_UNUSED;
        5: 4675:	waitforpid(pid, 0);		/* unblocks */
        5: 4676:	lastval = cmdoutval;
        5: 4677:	return retval;
        -: 4678:    }
        -: 4679:    /* pid == 0 */
        5: 4680:    child_unblock();
        5: 4681:    zclose(pipes[0]);
        5: 4682:    redup(pipes[1], 1);
        5: 4683:    entersubsh(ESUB_PGRP|ESUB_NOMONITOR, NULL);
        5: 4684:    cmdpush(CS_CMDSUBST);
        5: 4685:    execode(prog, 0, 1, "cmdsubst");
    #####: 4686:    cmdpop();
    #####: 4687:    close(1);
    #####: 4688:    _realexit();
    #####: 4689:    zerr("exit returned in child!!");
    #####: 4690:    kill(getpid(), SIGKILL);
    #####: 4691:    return NULL;
        -: 4692:}
        -: 4693:
        -: 4694:/* read output of command substitution
        -: 4695: *
        -: 4696: * The file descriptor "in" is closed by the function.
        -: 4697: *
        -: 4698: * "qt" indicates if the substitution was in double quotes.
        -: 4699: *
        -: 4700: * "readerror", if not NULL, is used to return any error that
        -: 4701: * occurred during the read.
        -: 4702: */
        -: 4703:
        -: 4704:/**/
        -: 4705:mod_export LinkList
       19: 4706:readoutput(int in, int qt, int *readerror)
        -: 4707:{
        -: 4708:    LinkList ret;
        -: 4709:    char *buf, *bufptr, *ptr, inbuf[64];
       19: 4710:    int bsiz, c, cnt = 0, readret;
       19: 4711:    int q = queue_signal_level();
        -: 4712:
       19: 4713:    ret = newlinklist();
       19: 4714:    ptr = buf = (char *) hcalloc(bsiz = 64);
        -: 4715:    /*
        -: 4716:     * We need to be sensitive to SIGCHLD else we can be
        -: 4717:     * stuck forever with important processes unreaped.
        -: 4718:     * The case that triggered this was where the exiting
        -: 4719:     * process is group leader of the foreground process and we need
        -: 4720:     * to reclaim the terminal else ^C doesn't work.
        -: 4721:     */
       19: 4722:    dont_queue_signals();
       19: 4723:    child_unblock();
        -: 4724:    for (;;) {
       39: 4725:	readret = read(in, inbuf, 64);
       29: 4726:	if (readret <= 0) {
       19: 4727:	    if (readret < 0 && errno == EINTR)
    #####: 4728:		continue;
        -: 4729:	    else
        -: 4730:		break;
        -: 4731:	}
      365: 4732:	for (bufptr = inbuf; bufptr < inbuf + readret; bufptr++) {
      355: 4733:	    c = *bufptr;
      355: 4734:	    if (imeta(c)) {
    #####: 4735:		*ptr++ = Meta;
    #####: 4736:		c ^= 32;
    #####: 4737:		cnt++;
        -: 4738:	    }
      355: 4739:	    if (++cnt >= bsiz) {
        -: 4740:		char *pp;
    #####: 4741:		queue_signals();
    #####: 4742:		pp = (char *) hcalloc(bsiz *= 2);
    #####: 4743:		dont_queue_signals();
        -: 4744:
    #####: 4745:		memcpy(pp, buf, cnt - 1);
    #####: 4746:		ptr = (buf = pp) + cnt - 1;
        -: 4747:	    }
      355: 4748:	    *ptr++ = c;
        -: 4749:	}
        -: 4750:    }
       19: 4751:    child_block();
       19: 4752:    restore_queue_signals(q);
       19: 4753:    if (readerror)
       14: 4754:	*readerror = readret < 0 ? errno : 0;
       19: 4755:    close(in);
       42: 4756:    while (cnt && ptr[-1] == '\n')
        4: 4757:	ptr--, cnt--;
       19: 4758:    *ptr = '\0';
       19: 4759:    if (qt) {
       19: 4760:	if (!cnt) {
        9: 4761:	    *ptr++ = Nularg;
        9: 4762:	    *ptr = '\0';
        -: 4763:	}
       19: 4764:	addlinknode(ret, buf);
        -: 4765:    } else {
    #####: 4766:	char **words = spacesplit(buf, 0, 1, 0);
        -: 4767:
    #####: 4768:	while (*words) {
    #####: 4769:	    if (isset(GLOBSUBST))
    #####: 4770:		shtokenize(*words);
    #####: 4771:	    addlinknode(ret, *words++);
        -: 4772:	}
        -: 4773:    }
       19: 4774:    return ret;
        -: 4775:}
        -: 4776:
        -: 4777:/**/
        -: 4778:static Eprog
    #####: 4779:parsecmd(char *cmd, char **eptr)
        -: 4780:{
        -: 4781:    char *str;
        -: 4782:    Eprog prog;
        -: 4783:
    #####: 4784:    for (str = cmd + 2; *str && *str != Outpar; str++);
    #####: 4785:    if (!*str || cmd[1] != Inpar) {
        -: 4786:	/*
        -: 4787:	 * This can happen if the expression is being parsed
        -: 4788:	 * inside another construct, e.g. as a value within ${..:..} etc.
        -: 4789:	 * So print a proper error message instead of the not very
        -: 4790:	 * useful but traditional "oops".
        -: 4791: 	 */
    #####: 4792:	char *errstr = dupstrpfx(cmd, 2);
    #####: 4793:	untokenize(errstr);
    #####: 4794:	zerr("unterminated `%s...)'", errstr);
    #####: 4795:	return NULL;
        -: 4796:    }
    #####: 4797:    *str = '\0';
    #####: 4798:    if (eptr)
    #####: 4799:	*eptr = str+1;
    #####: 4800:    if (!(prog = parse_string(cmd + 2, 0))) {
    #####: 4801:	zerr("parse error in process substitution");
    #####: 4802:	return NULL;
        -: 4803:    }
    #####: 4804:    return prog;
        -: 4805:}
        -: 4806:
        -: 4807:/* =(...) */
        -: 4808:
        -: 4809:/**/
        -: 4810:char *
    #####: 4811:getoutputfile(char *cmd, char **eptr)
        -: 4812:{
        -: 4813:    pid_t pid;
        -: 4814:    char *nam;
        -: 4815:    Eprog prog;
        -: 4816:    int fd;
        -: 4817:    char *s;
        -: 4818:
    #####: 4819:    if (thisjob == -1){
    #####: 4820:	zerr("process substitution %s cannot be used here", cmd);
    #####: 4821:	return NULL;
        -: 4822:    }
    #####: 4823:    if (!(prog = parsecmd(cmd, eptr)))
    #####: 4824:	return NULL;
    #####: 4825:    if (!(nam = gettempname(NULL, 1)))
    #####: 4826:	return NULL;
        -: 4827:
    #####: 4828:    if ((s = simple_redir_name(prog, REDIR_HERESTR))) {
        -: 4829:	/*
        -: 4830:	 * =(<<<stuff).  Optimise a la $(<file).  It's
        -: 4831:	 * effectively the reverse, converting a string into a file name
        -: 4832:	 * rather than vice versa.
        -: 4833:	 */
    #####: 4834:	singsub(&s);
    #####: 4835:	if (errflag)
    #####: 4836:	    s = NULL;
        -: 4837:	else
    #####: 4838:	    untokenize(s);
        -: 4839:    }
        -: 4840:
    #####: 4841:    if (!s)             /* Unclear why we need to do this before open() */
    #####: 4842:	child_block();  /* but it has been so for a long time: leave it */
        -: 4843:
    #####: 4844:    if ((fd = open(nam, O_WRONLY | O_CREAT | O_EXCL | O_NOCTTY, 0600)) < 0) {
    #####: 4845:	zerr("process substitution failed: %e", errno);
    #####: 4846:	free(nam);
    #####: 4847:	if (!s)
    #####: 4848:	    child_unblock();
    #####: 4849:	return NULL;
        -: 4850:    } else {
    #####: 4851:	char *suffix = getsparam("TMPSUFFIX");
    #####: 4852:	if (suffix && *suffix && !strstr(suffix, "/")) {
    #####: 4853:	    suffix = dyncat(nam, unmeta(suffix));
    #####: 4854:	    if (link(nam, suffix) == 0) {
    #####: 4855:		addfilelist(nam, 0);
    #####: 4856:		nam = suffix;
        -: 4857:	    }
        -: 4858:	}
        -: 4859:    }
    #####: 4860:    addfilelist(nam, 0);
        -: 4861:
    #####: 4862:    if (s) {
        -: 4863:	/* optimised here-string */
        -: 4864:	int len;
    #####: 4865:	unmetafy(s, &len);
    #####: 4866:	write_loop(fd, s, len);
    #####: 4867:	close(fd);
    #####: 4868:	return nam;
        -: 4869:    }
        -: 4870:
    #####: 4871:    if ((cmdoutpid = pid = zfork(NULL)) == -1) {
        -: 4872:	/* fork error */
    #####: 4873:	close(fd);
    #####: 4874:	child_unblock();
    #####: 4875:	return nam;
    #####: 4876:    } else if (pid) {
        -: 4877:	int os;
        -: 4878:
    #####: 4879:	close(fd);
    #####: 4880:	os = jobtab[thisjob].stat;
    #####: 4881:	waitforpid(pid, 0);
    #####: 4882:	cmdoutval = 0;
    #####: 4883:	jobtab[thisjob].stat = os;
    #####: 4884:	return nam;
        -: 4885:    }
        -: 4886:
        -: 4887:    /* pid == 0 */
    #####: 4888:    closem(FDT_UNUSED, 0);
    #####: 4889:    redup(fd, 1);
    #####: 4890:    entersubsh(ESUB_PGRP|ESUB_NOMONITOR, NULL);
    #####: 4891:    cmdpush(CS_CMDSUBST);
    #####: 4892:    execode(prog, 0, 1, "equalsubst");
    #####: 4893:    cmdpop();
    #####: 4894:    close(1);
    #####: 4895:    _realexit();
    #####: 4896:    zerr("exit returned in child!!");
    #####: 4897:    kill(getpid(), SIGKILL);
    #####: 4898:    return NULL;
        -: 4899:}
        -: 4900:
        -: 4901:#if !defined(PATH_DEV_FD) && defined(HAVE_FIFOS)
        -: 4902:/* get a temporary named pipe */
        -: 4903:
        -: 4904:static char *
        -: 4905:namedpipe(void)
        -: 4906:{
        -: 4907:    char *tnam = gettempname(NULL, 1);
        -: 4908:
        -: 4909:    if (!tnam) {
        -: 4910:	zerr("failed to create named pipe: %e", errno);
        -: 4911:	return NULL;
        -: 4912:    }
        -: 4913:# ifdef HAVE_MKFIFO
        -: 4914:    if (mkfifo(tnam, 0600) < 0){
        -: 4915:# else
        -: 4916:    if (mknod(tnam, 0010600, 0) < 0){
        -: 4917:# endif
        -: 4918:	zerr("failed to create named pipe: %s, %e", tnam, errno);
        -: 4919:	return NULL;
        -: 4920:    }
        -: 4921:    return tnam;
        -: 4922:}
        -: 4923:#endif /* ! PATH_DEV_FD && HAVE_FIFOS */
        -: 4924:
        -: 4925:/* <(...) or >(...) */
        -: 4926:
        -: 4927:/**/
        -: 4928:char *
    #####: 4929:getproc(char *cmd, char **eptr)
        -: 4930:{
        -: 4931:#if !defined(HAVE_FIFOS) && !defined(PATH_DEV_FD)
        -: 4932:    zerr("doesn't look like your system supports FIFOs.");
        -: 4933:    return NULL;
        -: 4934:#else
        -: 4935:    Eprog prog;
    #####: 4936:    int out = *cmd == Inang;
        -: 4937:    char *pnam;
        -: 4938:    pid_t pid;
        -: 4939:    struct timeval bgtime;
        -: 4940:
        -: 4941:#ifndef PATH_DEV_FD
        -: 4942:    int fd;
        -: 4943:    if (thisjob == -1) {
        -: 4944:	zerr("process substitution %s cannot be used here", cmd);
        -: 4945:	return NULL;
        -: 4946:    }
        -: 4947:    if (!(pnam = namedpipe()))
        -: 4948:	return NULL;
        -: 4949:    if (!(prog = parsecmd(cmd, eptr)))
        -: 4950:	return NULL;
        -: 4951:    addfilelist(pnam, 0);
        -: 4952:
        -: 4953:    if ((pid = zfork(&bgtime))) {
        -: 4954:	if (pid == -1)
        -: 4955:	    return NULL;
        -: 4956:	if (!out)
        -: 4957:	    addproc(pid, NULL, 1, &bgtime, -1, -1);
        -: 4958:	procsubstpid = pid;
        -: 4959:	return pnam;
        -: 4960:    }
        -: 4961:    closem(FDT_UNUSED, 0);
        -: 4962:    fd = open(pnam, out ? O_WRONLY | O_NOCTTY : O_RDONLY | O_NOCTTY);
        -: 4963:    if (fd == -1) {
        -: 4964:	zerr("can't open %s: %e", pnam, errno);
        -: 4965:	_exit(1);
        -: 4966:    }
        -: 4967:    entersubsh(ESUB_ASYNC|ESUB_PGRP, NULL);
        -: 4968:    redup(fd, out);
        -: 4969:#else /* PATH_DEV_FD */
        -: 4970:    int pipes[2], fd;
        -: 4971:
    #####: 4972:    if (thisjob == -1) {
    #####: 4973:	zerr("process substitution %s cannot be used here", cmd);
    #####: 4974:	return NULL;
        -: 4975:    }
    #####: 4976:    pnam = zhalloc(strlen(PATH_DEV_FD) + 1 + DIGBUFSIZE);
    #####: 4977:    if (!(prog = parsecmd(cmd, eptr)))
    #####: 4978:	return NULL;
    #####: 4979:    if (mpipe(pipes) < 0)
    #####: 4980:	return NULL;
    #####: 4981:    if ((pid = zfork(&bgtime))) {
    #####: 4982:	sprintf(pnam, "%s/%d", PATH_DEV_FD, pipes[!out]);
    #####: 4983:	zclose(pipes[out]);
    #####: 4984:	if (pid == -1)
        -: 4985:	{
    #####: 4986:	    zclose(pipes[!out]);
    #####: 4987:	    return NULL;
        -: 4988:	}
    #####: 4989:	fd = pipes[!out];
    #####: 4990:	fdtable[fd] = FDT_PROC_SUBST;
    #####: 4991:	addfilelist(NULL, fd);
    #####: 4992:	if (!out)
        -: 4993:	{
    #####: 4994:	    addproc(pid, NULL, 1, &bgtime, -1, -1);
        -: 4995:	}
    #####: 4996:	procsubstpid = pid;
    #####: 4997:	return pnam;
        -: 4998:    }
    #####: 4999:    entersubsh(ESUB_ASYNC|ESUB_PGRP, NULL);
    #####: 5000:    redup(pipes[out], out);
    #####: 5001:    closem(FDT_UNUSED, 0);   /* this closes pipes[!out] as well */
        -: 5002:#endif /* PATH_DEV_FD */
        -: 5003:
    #####: 5004:    cmdpush(CS_CMDSUBST);
    #####: 5005:    execode(prog, 0, 1, out ? "outsubst" : "insubst");
    #####: 5006:    cmdpop();
    #####: 5007:    zclose(out);
    #####: 5008:    _realexit();
    #####: 5009:    return NULL;
        -: 5010:#endif   /* HAVE_FIFOS and PATH_DEV_FD not defined */
        -: 5011:}
        -: 5012:
        -: 5013:/*
        -: 5014: * > >(...) or < <(...) (does not use named pipes)
        -: 5015: *
        -: 5016: * If the second argument is 1, this is part of
        -: 5017: * an "exec < <(...)" or "exec > >(...)" and we shouldn't
        -: 5018: * wait for the job to finish before continuing.
        -: 5019: */
        -: 5020:
        -: 5021:/**/
        -: 5022:static int
    #####: 5023:getpipe(char *cmd, int nullexec)
        -: 5024:{
        -: 5025:    Eprog prog;
    #####: 5026:    int pipes[2], out = *cmd == Inang;
        -: 5027:    pid_t pid;
        -: 5028:    struct timeval bgtime;
        -: 5029:    char *ends;
        -: 5030:
    #####: 5031:    if (!(prog = parsecmd(cmd, &ends)))
    #####: 5032:	return -1;
    #####: 5033:    if (*ends) {
    #####: 5034:	zerr("invalid syntax for process substitution in redirection");
    #####: 5035:	return -1;
        -: 5036:    }
    #####: 5037:    if (mpipe(pipes) < 0)
    #####: 5038:	return -1;
    #####: 5039:    if ((pid = zfork(&bgtime))) {
    #####: 5040:	zclose(pipes[out]);
    #####: 5041:	if (pid == -1) {
    #####: 5042:	    zclose(pipes[!out]);
    #####: 5043:	    return -1;
        -: 5044:	}
    #####: 5045:	if (!nullexec)
    #####: 5046:	    addproc(pid, NULL, 1, &bgtime, -1, -1);
    #####: 5047:	procsubstpid = pid;
    #####: 5048:	return pipes[!out];
        -: 5049:    }
    #####: 5050:    entersubsh(ESUB_ASYNC|ESUB_PGRP, NULL);
    #####: 5051:    redup(pipes[out], out);
    #####: 5052:    closem(FDT_UNUSED, 0);	/* this closes pipes[!out] as well */
    #####: 5053:    cmdpush(CS_CMDSUBST);
    #####: 5054:    execode(prog, 0, 1, out ? "outsubst" : "insubst");
    #####: 5055:    cmdpop();
    #####: 5056:    _realexit();
    #####: 5057:    return 0;
        -: 5058:}
        -: 5059:
        -: 5060:/* open pipes with fds >= 10 */
        -: 5061:
        -: 5062:/**/
        -: 5063:static int
        5: 5064:mpipe(int *pp)
        -: 5065:{
        5: 5066:    if (pipe(pp) < 0) {
    #####: 5067:	zerr("pipe failed: %e", errno);
    #####: 5068:	return -1;
        -: 5069:    }
        5: 5070:    pp[0] = movefd(pp[0]);
        5: 5071:    pp[1] = movefd(pp[1]);
        5: 5072:    return 0;
        -: 5073:}
        -: 5074:
        -: 5075:/*
        -: 5076: * Do process substitution with redirection
        -: 5077: *
        -: 5078: * If the second argument is 1, this is part of
        -: 5079: * an "exec < <(...)" or "exec > >(...)" and we shouldn't
        -: 5080: * wait for the job to finish before continuing.
        -: 5081: * Likewise, we shouldn't wait if we are opening the file
        -: 5082: * descriptor using the {fd}>>(...) notation since it stays
        -: 5083: * valid for subsequent commands.
        -: 5084: */
        -: 5085:
        -: 5086:/**/
        -: 5087:static void
       17: 5088:spawnpipes(LinkList l, int nullexec)
        -: 5089:{
        -: 5090:    LinkNode n;
        -: 5091:    Redir f;
        -: 5092:    char *str;
        -: 5093:
       17: 5094:    n = firstnode(l);
       42: 5095:    for (; n; incnode(n)) {
       25: 5096:	f = (Redir) getdata(n);
       25: 5097:	if (f->type == REDIR_OUTPIPE || f->type == REDIR_INPIPE) {
    #####: 5098:	    str = f->name;
    #####: 5099:	    f->fd2 = getpipe(str, nullexec || f->varid);
        -: 5100:	}
        -: 5101:    }
       17: 5102:}
        -: 5103:
        -: 5104:/* evaluate a [[ ... ]] */
        -: 5105:
        -: 5106:/**/
        -: 5107:static int
      208: 5108:execcond(Estate state, UNUSED(int do_exec))
        -: 5109:{
        -: 5110:    int stat;
        -: 5111:
      208: 5112:    state->pc--;
      208: 5113:    if (isset(XTRACE)) {
    #####: 5114:	printprompt4();
    #####: 5115:	fprintf(xtrerr, "[[");
    #####: 5116:	tracingcond++;
        -: 5117:    }
      208: 5118:    cmdpush(CS_COND);
      208: 5119:    stat = evalcond(state, NULL);
        -: 5120:    /*
        -: 5121:     * 2 indicates a syntax error.  For compatibility, turn this
        -: 5122:     * into a shell error.
        -: 5123:     */
      208: 5124:    if (stat == 2)
    #####: 5125:	errflag |= ERRFLAG_ERROR;
      208: 5126:    cmdpop();
      208: 5127:    if (isset(XTRACE)) {
    #####: 5128:	fprintf(xtrerr, " ]]\n");
    #####: 5129:	fflush(xtrerr);
    #####: 5130:	tracingcond--;
        -: 5131:    }
      208: 5132:    return stat;
        -: 5133:}
        -: 5134:
        -: 5135:/* evaluate a ((...)) arithmetic command */
        -: 5136:
        -: 5137:/**/
        -: 5138:static int
       29: 5139:execarith(Estate state, UNUSED(int do_exec))
        -: 5140:{
        -: 5141:    char *e;
       29: 5142:    mnumber val = zero_mnumber;
       29: 5143:    int htok = 0;
        -: 5144:
       29: 5145:    if (isset(XTRACE)) {
    #####: 5146:	printprompt4();
    #####: 5147:	fprintf(xtrerr, "((");
        -: 5148:    }
       29: 5149:    cmdpush(CS_MATH);
       29: 5150:    e = ecgetstr(state, EC_DUPTOK, &htok);
       29: 5151:    if (htok)
        9: 5152:	singsub(&e);
       29: 5153:    if (isset(XTRACE))
    #####: 5154:	fprintf(xtrerr, " %s", e);
        -: 5155:
       29: 5156:    val = matheval(e);
        -: 5157:
       29: 5158:    cmdpop();
        -: 5159:
       29: 5160:    if (isset(XTRACE)) {
    #####: 5161:	fprintf(xtrerr, " ))\n");
    #####: 5162:	fflush(xtrerr);
        -: 5163:    }
       29: 5164:    if (errflag) {
    #####: 5165:	errflag &= ~ERRFLAG_ERROR;
    #####: 5166:	return 2;
        -: 5167:    }
        -: 5168:    /* should test for fabs(val.u.d) < epsilon? */
       29: 5169:    return (val.type == MN_INTEGER) ? val.u.l == 0 : val.u.d == 0.0;
        -: 5170:}
        -: 5171:
        -: 5172:/* perform time ... command */
        -: 5173:
        -: 5174:/**/
        -: 5175:static int
    #####: 5176:exectime(Estate state, UNUSED(int do_exec))
        -: 5177:{
        -: 5178:    int jb;
        -: 5179:
    #####: 5180:    jb = thisjob;
    #####: 5181:    if (WC_TIMED_TYPE(state->pc[-1]) == WC_TIMED_EMPTY) {
    #####: 5182:	shelltime();
    #####: 5183:	return 0;
        -: 5184:    }
    #####: 5185:    execpline(state, *state->pc++, Z_TIMED|Z_SYNC, 0);
    #####: 5186:    thisjob = jb;
    #####: 5187:    return lastval;
        -: 5188:}
        -: 5189:
        -: 5190:/* The string displayed in lieu of the name of an anonymous function (in PS4,
        -: 5191: * zprof output, etc)
        -: 5192: */
        -: 5193:static const char *const ANONYMOUS_FUNCTION_NAME = "(anon)";
        -: 5194:
        -: 5195:/* 
        -: 5196: * Take a function name argument and return true iff it is equal to the string
        -: 5197: * used for the names of anonymous functions, "(anon)".
        -: 5198: *
        -: 5199: * Note that it's possible to define a named function literally called "(anon)"
        -: 5200: * (though I doubt anyone would ever do that).
        -: 5201: */
        -: 5202:/**/
    #####: 5203:int is_anonymous_function_name(const char *name)
        -: 5204:{
    #####: 5205:    return !strcmp(name, ANONYMOUS_FUNCTION_NAME);
        -: 5206:}
        -: 5207:
        -: 5208:/* Define a shell function */
        -: 5209:
        -: 5210:/**/
        -: 5211:static int
       19: 5212:execfuncdef(Estate state, Eprog redir_prog)
        -: 5213:{
        -: 5214:    Shfunc shf;
       19: 5215:    char *s = NULL;
       19: 5216:    int signum, nprg, sbeg, nstrs, npats, do_tracing, len, plen, i, htok = 0, ret = 0;
       19: 5217:    int anon_func = 0;
       19: 5218:    Wordcode beg = state->pc, end;
        -: 5219:    Eprog prog;
        -: 5220:    Patprog *pp;
        -: 5221:    LinkList names;
        -: 5222:    int tracing_flags;
        -: 5223:
       19: 5224:    end = beg + WC_FUNCDEF_SKIP(state->pc[-1]);
       19: 5225:    names = ecgetlist(state, *state->pc++, EC_DUPTOK, &htok);
       19: 5226:    sbeg = *state->pc++;
       19: 5227:    nstrs = *state->pc++;
       19: 5228:    npats = *state->pc++;
       19: 5229:    do_tracing = *state->pc++;
        -: 5230:
       19: 5231:    nprg = (end - state->pc);
       19: 5232:    plen = nprg * sizeof(wordcode);
       19: 5233:    len = plen + (npats * sizeof(Patprog)) + nstrs;
       19: 5234:    tracing_flags = do_tracing ? PM_TAGGED_LOCAL : 0;
        -: 5235:
       19: 5236:    if (htok && names) {
    #####: 5237:	execsubst(names);
    #####: 5238:	if (errflag) {
    #####: 5239:	    state->pc = end;
    #####: 5240:	    return 1;
        -: 5241:	}
        -: 5242:    }
        -: 5243:
        -: 5244:    DPUTS(!names && redir_prog,
        -: 5245:	  "Passing redirection to anon function definition.");
       52: 5246:    while (!names || (s = (char *) ugetnode(names))) {
       19: 5247:	if (!names) {
        5: 5248:	    prog = (Eprog) zhalloc(sizeof(*prog));
        5: 5249:	    prog->nref = -1; /* on the heap */
        -: 5250:	} else {
       14: 5251:	    prog = (Eprog) zalloc(sizeof(*prog));
       14: 5252:	    prog->nref = 1; /* allocated from permanent storage */
        -: 5253:	}
       19: 5254:	prog->npats = npats;
       19: 5255:	prog->len = len;
       19: 5256:	if (state->prog->dump || !names) {
        5: 5257:	    if (!names) {
        5: 5258:		prog->flags = EF_HEAP;
        5: 5259:		prog->dump = NULL;
        5: 5260:		prog->pats = pp = (Patprog *) zhalloc(npats * sizeof(Patprog));
        -: 5261:	    } else {
    #####: 5262:		prog->flags = EF_MAP;
    #####: 5263:		incrdumpcount(state->prog->dump);
    #####: 5264:		prog->dump = state->prog->dump;
    #####: 5265:		prog->pats = pp = (Patprog *) zalloc(npats * sizeof(Patprog));
        -: 5266:	    }
        5: 5267:	    prog->prog = state->pc;
        5: 5268:	    prog->strs = state->strs + sbeg;
        -: 5269:	} else {
       14: 5270:	    prog->flags = EF_REAL;
       14: 5271:	    prog->pats = pp = (Patprog *) zalloc(len);
       14: 5272:	    prog->prog = (Wordcode) (prog->pats + npats);
       14: 5273:	    prog->strs = (char *) (prog->prog + nprg);
       14: 5274:	    prog->dump = NULL;
       14: 5275:	    memcpy(prog->prog, state->pc, plen);
       14: 5276:	    memcpy(prog->strs, state->strs + sbeg, nstrs);
        -: 5277:	}
       59: 5278:	for (i = npats; i--; pp++)
       40: 5279:	    *pp = dummy_patprog1;
       19: 5280:	prog->shf = NULL;
        -: 5281:
       19: 5282:	shf = (Shfunc) zalloc(sizeof(*shf));
       19: 5283:	shf->funcdef = prog;
       19: 5284:	shf->node.flags = tracing_flags;
        -: 5285:	/* No dircache here, not a directory */
       19: 5286:	shf->filename = ztrdup(scriptfilename);
       19: 5287:	shf->lineno =
       24: 5288:	    (funcstack && (funcstack->tp == FS_FUNC ||
    #####: 5289:			   funcstack->tp == FS_EVAL)) ?
       24: 5290:	    funcstack->flineno + lineno :
        -: 5291:	    lineno;
        -: 5292:	/*
        -: 5293:	 * redir_prog is permanently allocated --- but if
        -: 5294:	 * this function has multiple names we need an additional
        -: 5295:	 * one. Original redir_prog used with the last name
        -: 5296:	 * because earlier functions are freed in case of duplicate
        -: 5297:	 * names.
        -: 5298:	 */
       19: 5299:	if (names && nonempty(names) && redir_prog)
    #####: 5300:	    shf->redir = dupeprog(redir_prog, 0);
        -: 5301:	else {
       19: 5302:	    shf->redir = redir_prog;
       19: 5303:	    redir_prog = 0;
        -: 5304:	}
       19: 5305:	shfunc_set_sticky(shf);
        -: 5306:
       19: 5307:	if (!names) {
        -: 5308:	    /*
        -: 5309:	     * Anonymous function, execute immediately.
        -: 5310:	     * Function name is "(anon)".
        -: 5311:	     */
        -: 5312:	    LinkList args;
        -: 5313:
        5: 5314:	    anon_func = 1;
        5: 5315:	    shf->node.flags |= PM_ANONYMOUS;
        -: 5316:
        5: 5317:	    state->pc = end;
        5: 5318:	    end += *state->pc++;
        5: 5319:	    args = ecgetlist(state, *state->pc++, EC_DUPTOK, &htok);
        -: 5320:
        5: 5321:	    if (htok && args) {
    #####: 5322:		execsubst(args);
    #####: 5323:		if (errflag) {
    #####: 5324:		    freeeprog(shf->funcdef);
    #####: 5325:		    if (shf->redir) /* shouldn't be */
    #####: 5326:			freeeprog(shf->redir);
    #####: 5327:		    dircache_set(&shf->filename, NULL);
    #####: 5328:		    zfree(shf, sizeof(*shf));
    #####: 5329:		    state->pc = end;
    #####: 5330:		    return 1;
        -: 5331:		}
        -: 5332:	    }
        -: 5333:
        5: 5334:	    setunderscore((args && nonempty(args)) ?
    #####: 5335:			  ((char *) getdata(lastnode(args))) : "");
        -: 5336:
        5: 5337:	    if (!args)
        5: 5338:		args = newlinklist();
        5: 5339:	    shf->node.nam = (char *) ANONYMOUS_FUNCTION_NAME;
        5: 5340:	    pushnode(args, shf->node.nam);
        -: 5341:
        5: 5342:	    execshfunc(shf, args);
        5: 5343:	    ret = lastval;
        -: 5344:
        5: 5345:	    if (isset(PRINTEXITVALUE) && isset(SHINSTDIN) &&
        -: 5346:		lastval) {
        -: 5347:#if defined(ZLONG_IS_LONG_LONG) && defined(PRINTF_HAS_LLD)
        -: 5348:		fprintf(stderr, "zsh: exit %lld\n", lastval);
        -: 5349:#else
    #####: 5350:		fprintf(stderr, "zsh: exit %ld\n", (long)lastval);
        -: 5351:#endif
    #####: 5352:		fflush(stderr);
        -: 5353:	    }
        -: 5354:
        5: 5355:	    freeeprog(shf->funcdef);
        5: 5356:	    if (shf->redir) /* shouldn't be */
    #####: 5357:		freeeprog(shf->redir);
        5: 5358:	    dircache_set(&shf->filename, NULL);
        5: 5359:	    zfree(shf, sizeof(*shf));
        5: 5360:	    break;
        -: 5361:	} else {
        -: 5362:	    /* is this shell function a signal trap? */
       14: 5363:	    if (!strncmp(s, "TRAP", 4) &&
    #####: 5364:		(signum = getsignum(s + 4)) != -1) {
    #####: 5365:		if (settrap(signum, NULL, ZSIG_FUNC)) {
    #####: 5366:		    freeeprog(shf->funcdef);
    #####: 5367:		    dircache_set(&shf->filename, NULL);
    #####: 5368:		    zfree(shf, sizeof(*shf));
    #####: 5369:		    state->pc = end;
    #####: 5370:		    return 1;
        -: 5371:		}
        -: 5372:
        -: 5373:		/*
        -: 5374:		 * Remove the old node explicitly in case it has
        -: 5375:		 * an alternative name
        -: 5376:		 */
    #####: 5377:		removetrapnode(signum);
        -: 5378:	    }
        -: 5379:	    /* Is this function traced and redefining itself? */
       14: 5380:	    if (funcstack && funcstack->tp == FS_FUNC &&
    #####: 5381:		    !strcmp(s, funcstack->name)) {
    #####: 5382:		Shfunc old = ((Shfunc)shfunctab->getnode(shfunctab, s));
    #####: 5383:		shf->node.flags |= old->node.flags & (PM_TAGGED|PM_TAGGED_LOCAL);
        -: 5384:	    }
       14: 5385:	    shfunctab->addnode(shfunctab, ztrdup(s), shf);
        -: 5386:	}
        -: 5387:    }
       19: 5388:    if (!anon_func)
       14: 5389:	setunderscore("");
       19: 5390:    if (redir_prog) {
        -: 5391:	/* For completeness, shouldn't happen */
    #####: 5392:	freeeprog(redir_prog);
        -: 5393:    }
       19: 5394:    state->pc = end;
       19: 5395:    return ret;
        -: 5396:}
        -: 5397:
        -: 5398:/* Duplicate a sticky emulation */
        -: 5399:
        -: 5400:/**/
        -: 5401:
        -: 5402:mod_export Emulation_options
    #####: 5403:sticky_emulation_dup(Emulation_options src, int useheap)
        -: 5404:{
    #####: 5405:    Emulation_options newsticky = useheap ?
        -: 5406:	hcalloc(sizeof(*src)) : zshcalloc(sizeof(*src));
    #####: 5407:    newsticky->emulation = src->emulation;
    #####: 5408:    if (src->n_on_opts) {
    #####: 5409:	size_t sz = src->n_on_opts * sizeof(*src->on_opts);
    #####: 5410:	newsticky->n_on_opts = src->n_on_opts;
    #####: 5411:	newsticky->on_opts = useheap ? zhalloc(sz) : zalloc(sz);
    #####: 5412:	memcpy(newsticky->on_opts, src->on_opts, sz);
        -: 5413:    }
    #####: 5414:    if (src->n_off_opts) {
    #####: 5415:	size_t sz = src->n_off_opts * sizeof(*src->off_opts);
    #####: 5416:	newsticky->n_off_opts = src->n_off_opts;
    #####: 5417:	newsticky->off_opts = useheap ? zhalloc(sz) : zalloc(sz);
    #####: 5418:	memcpy(newsticky->off_opts, src->off_opts, sz);
        -: 5419:    }
        -: 5420:
    #####: 5421:    return newsticky;
        -: 5422:}
        -: 5423:
        -: 5424:/* Set the sticky emulation attributes for a shell function */
        -: 5425:
        -: 5426:/**/
        -: 5427:
        -: 5428:mod_export void
       19: 5429:shfunc_set_sticky(Shfunc shf)
        -: 5430:{
       19: 5431:    if (sticky)
    #####: 5432:	shf->sticky = sticky_emulation_dup(sticky, 0);
        -: 5433:    else
       19: 5434:	shf->sticky = NULL;
       19: 5435:}
        -: 5436:
        -: 5437:
        -: 5438:/* Main entry point to execute a shell function. */
        -: 5439:
        -: 5440:/**/
        -: 5441:static void
      130: 5442:execshfunc(Shfunc shf, LinkList args)
        -: 5443:{
      130: 5444:    LinkList last_file_list = NULL;
        -: 5445:    unsigned char *ocs;
        -: 5446:    int ocsp, osfc;
        -: 5447:
      130: 5448:    if (errflag)
    #####: 5449:	return;
        -: 5450:
        -: 5451:    /* thisjob may be invalid if we're called via execsimple: see execcursh */
      254: 5452:    if (!list_pipe && thisjob != -1 && thisjob != list_pipe_job &&
      124: 5453:	!hasprocs(thisjob)) {
        -: 5454:	/* Without this deletejob the process table *
        -: 5455:	 * would be filled by a recursive function. */
      124: 5456:	last_file_list = jobtab[thisjob].filelist;
      124: 5457:	jobtab[thisjob].filelist = NULL;
      124: 5458:	deletejob(jobtab + thisjob, 0);
        -: 5459:    }
        -: 5460:
      130: 5461:    if (isset(XTRACE)) {
        -: 5462:	LinkNode lptr;
    #####: 5463:	printprompt4();
    #####: 5464:	if (args)
    #####: 5465:	    for (lptr = firstnode(args); lptr; incnode(lptr)) {
    #####: 5466:		if (lptr != firstnode(args))
    #####: 5467:		    fputc(' ', xtrerr);
    #####: 5468:		quotedzputs((char *)getdata(lptr), xtrerr);
        -: 5469:	    }
    #####: 5470:	fputc('\n', xtrerr);
    #####: 5471:	fflush(xtrerr);
        -: 5472:    }
      130: 5473:    queue_signals();
      130: 5474:    ocs = cmdstack;
      130: 5475:    ocsp = cmdsp;
      130: 5476:    cmdstack = (unsigned char *) zalloc(CMDSTACKSZ);
      130: 5477:    cmdsp = 0;
      130: 5478:    if ((osfc = sfcontext) == SFC_NONE)
        6: 5479:	sfcontext = SFC_DIRECT;
      130: 5480:    xtrerr = stderr;
        -: 5481:
      130: 5482:    doshfunc(shf, args, 0);
        -: 5483:
      130: 5484:    sfcontext = osfc;
      130: 5485:    free(cmdstack);
      130: 5486:    cmdstack = ocs;
      130: 5487:    cmdsp = ocsp;
        -: 5488:
      130: 5489:    if (!list_pipe)
      130: 5490:	deletefilelist(last_file_list, 0);
      130: 5491:    unqueue_signals();
        -: 5492:}
        -: 5493:
        -: 5494:/*
        -: 5495: * Function to execute the special type of command that represents an
        -: 5496: * autoloaded shell function.  The command structure tells us which
        -: 5497: * function it is.  This function is actually called as part of the
        -: 5498: * execution of the autoloaded function itself, so when the function
        -: 5499: * has been autoloaded, its list is just run with no frills.
        -: 5500: *
        -: 5501: * There are two cases because if we are doing all-singing, all-dancing
        -: 5502: * non-simple code we load the shell function early in execcmd() (the
        -: 5503: * action also present in the non-basic version) to check if
        -: 5504: * there are redirections that need to be handled at that point.
        -: 5505: * Then we call execautofn_basic() to do the rest.
        -: 5506: */
        -: 5507:
        -: 5508:/**/
        -: 5509:static int
    #####: 5510:execautofn_basic(Estate state, UNUSED(int do_exec))
        -: 5511:{
        -: 5512:    Shfunc shf;
        -: 5513:    char *oldscriptname, *oldscriptfilename;
        -: 5514:
    #####: 5515:    shf = state->prog->shf;
        -: 5516:
        -: 5517:    /*
        -: 5518:     * Probably we didn't know the filename where this function was
        -: 5519:     * defined yet.
        -: 5520:     */
    #####: 5521:    if (funcstack && !funcstack->filename)
    #####: 5522:	funcstack->filename = getshfuncfile(shf);
        -: 5523:
    #####: 5524:    oldscriptname = scriptname;
    #####: 5525:    oldscriptfilename = scriptfilename;
    #####: 5526:    scriptname = dupstring(shf->node.nam);
    #####: 5527:    scriptfilename = getshfuncfile(shf);
    #####: 5528:    execode(shf->funcdef, 1, 0, "loadautofunc");
    #####: 5529:    scriptname = oldscriptname;
    #####: 5530:    scriptfilename = oldscriptfilename;
        -: 5531:
    #####: 5532:    return lastval;
        -: 5533:}
        -: 5534:
        -: 5535:/**/
        -: 5536:static int
    #####: 5537:execautofn(Estate state, UNUSED(int do_exec))
        -: 5538:{
        -: 5539:    Shfunc shf;
        -: 5540:
    #####: 5541:    if (!(shf = loadautofn(state->prog->shf, 1, 0, 0)))
    #####: 5542:	return 1;
        -: 5543:
    #####: 5544:    state->prog->shf = shf;
    #####: 5545:    return execautofn_basic(state, 0);
        -: 5546:}
        -: 5547:
        -: 5548:/*
        -: 5549: * Helper function to install the source file name of a shell function
        -: 5550: * just autoloaded.
        -: 5551: *
        -: 5552: * We attempt to do this efficiently as the typical case is the
        -: 5553: * directory part is a well-known directory, which is cached, and
        -: 5554: * the non-directory part is the same as the node name.
        -: 5555: */
        -: 5556:
        -: 5557:/**/
        -: 5558:static void
    #####: 5559:loadautofnsetfile(Shfunc shf, char *fdir)
        -: 5560:{
        -: 5561:    /*
        -: 5562:     * If shf->filename is already the load directory ---
        -: 5563:     * keep it as we can still use it to get the load file.
        -: 5564:     * This makes autoload with an absolute path particularly efficient.
        -: 5565:     */
    #####: 5566:    if (!(shf->node.flags & PM_LOADDIR) ||
    #####: 5567:	strcmp(shf->filename, fdir) != 0) {
        -: 5568:	/* Old directory name not useful... */
    #####: 5569:	dircache_set(&shf->filename, NULL);
    #####: 5570:	if (fdir) {
        -: 5571:	    /* ...can still cache directory */
    #####: 5572:	    shf->node.flags |= PM_LOADDIR;
    #####: 5573:	    dircache_set(&shf->filename, fdir);
        -: 5574:	} else {
        -: 5575:	    /* ...no separate directory part to cache, for some reason. */
    #####: 5576:	    shf->node.flags &= ~PM_LOADDIR;
    #####: 5577:	    shf->filename = ztrdup(shf->node.nam);
        -: 5578:	}
        -: 5579:    }
    #####: 5580:}
        -: 5581:
        -: 5582:/**/
        -: 5583:Shfunc
    #####: 5584:loadautofn(Shfunc shf, int fksh, int autol, int current_fpath)
        -: 5585:{
    #####: 5586:    int noalias = noaliases, ksh = 1;
        -: 5587:    Eprog prog;
        -: 5588:    char *fdir;			/* Directory path where func found */
        -: 5589:
    #####: 5590:    pushheap();
        -: 5591:
    #####: 5592:    noaliases = (shf->node.flags & PM_UNALIASED);
    #####: 5593:    if (shf->filename && shf->filename[0] == '/' &&
    #####: 5594:	(shf->node.flags & PM_LOADDIR))
    #####: 5595:    {
        -: 5596:	char *spec_path[2];
    #####: 5597:	spec_path[0] = dupstring(shf->filename);
    #####: 5598:	spec_path[1] = NULL;
    #####: 5599:	prog = getfpfunc(shf->node.nam, &ksh, &fdir, spec_path, 0);
    #####: 5600:	if (prog == &dummy_eprog &&
    #####: 5601:	    (current_fpath || (shf->node.flags & PM_CUR_FPATH)))
    #####: 5602:	    prog = getfpfunc(shf->node.nam, &ksh, &fdir, NULL, 0);
        -: 5603:    }
        -: 5604:    else
    #####: 5605:	prog = getfpfunc(shf->node.nam, &ksh, &fdir, NULL, 0);
    #####: 5606:    noaliases = noalias;
        -: 5607:
    #####: 5608:    if (ksh == 1) {
    #####: 5609:	ksh = fksh;
    #####: 5610:	if (ksh == 1)
    #####: 5611:	    ksh = (shf->node.flags & PM_KSHSTORED) ? 2 :
    #####: 5612:		  (shf->node.flags & PM_ZSHSTORED) ? 0 : 1;
        -: 5613:    }
        -: 5614:
    #####: 5615:    if (prog == &dummy_eprog) {
        -: 5616:	/* We're not actually in the function; decrement locallevel */
    #####: 5617:	locallevel--;
    #####: 5618:	zwarn("%s: function definition file not found", shf->node.nam);
    #####: 5619:	locallevel++;
    #####: 5620:	popheap();
    #####: 5621:	return NULL;
        -: 5622:    }
    #####: 5623:    if (!prog) {
    #####: 5624:	popheap();
    #####: 5625:	return NULL;
        -: 5626:    }
    #####: 5627:    if (ksh == 2 || (ksh == 1 && isset(KSHAUTOLOAD))) {
    #####: 5628:	if (autol) {
    #####: 5629:	    prog->flags |= EF_RUN;
        -: 5630:
    #####: 5631:	    freeeprog(shf->funcdef);
    #####: 5632:	    if (prog->flags & EF_MAP)
    #####: 5633:		shf->funcdef = prog;
        -: 5634:	    else
    #####: 5635:		shf->funcdef = dupeprog(prog, 0);
    #####: 5636:	    shf->node.flags &= ~PM_UNDEFINED;
    #####: 5637:	    loadautofnsetfile(shf, fdir);
        -: 5638:	} else {
    #####: 5639:	    VARARR(char, n, strlen(shf->node.nam) + 1);
    #####: 5640:	    strcpy(n, shf->node.nam);
    #####: 5641:	    execode(prog, 1, 0, "evalautofunc");
    #####: 5642:	    shf = (Shfunc) shfunctab->getnode(shfunctab, n);
    #####: 5643:	    if (!shf || (shf->node.flags & PM_UNDEFINED)) {
        -: 5644:		/* We're not actually in the function; decrement locallevel */
    #####: 5645:		locallevel--;
    #####: 5646:		zwarn("%s: function not defined by file", n);
    #####: 5647:		locallevel++;
    #####: 5648:		popheap();
    #####: 5649:		return NULL;
        -: 5650:	    }
        -: 5651:	}
        -: 5652:    } else {
    #####: 5653:	freeeprog(shf->funcdef);
    #####: 5654:	if (prog->flags & EF_MAP)
    #####: 5655:	    shf->funcdef = stripkshdef(prog, shf->node.nam);
        -: 5656:	else
    #####: 5657:	    shf->funcdef = dupeprog(stripkshdef(prog, shf->node.nam), 0);
    #####: 5658:	shf->node.flags &= ~PM_UNDEFINED;
    #####: 5659:	loadautofnsetfile(shf, fdir);
        -: 5660:    }
    #####: 5661:    popheap();
        -: 5662:
    #####: 5663:    return shf;
        -: 5664:}
        -: 5665:
        -: 5666:/*
        -: 5667: * Check if a sticky emulation differs from the current one.
        -: 5668: */
        -: 5669:
        -: 5670:/**/
        -: 5671:
      130: 5672:int sticky_emulation_differs(Emulation_options sticky2)
        -: 5673:{
        -: 5674:    /* If no new sticky emulation, not a different emulation */
      130: 5675:    if (!sticky2)
      130: 5676:	return 0;
        -: 5677:    /* If no current sticky emulation, different */
    #####: 5678:    if (!sticky)
    #####: 5679:	return 1;
        -: 5680:    /* If basic emulation different, different */
    #####: 5681:    if (sticky->emulation != sticky2->emulation)
    #####: 5682:	return 1;
        -: 5683:    /* If differing numbers of options, different */
    #####: 5684:    if (sticky->n_on_opts != sticky2->n_on_opts ||
    #####: 5685:	sticky->n_off_opts != sticky2->n_off_opts)
    #####: 5686:	return 1;
        -: 5687:    /*
        -: 5688:     * We need to compare option arrays, if non-null.
        -: 5689:     * We made parseopts() create the list of options in option
        -: 5690:     * order to make this easy.
        -: 5691:     */
        -: 5692:    /* If different options turned on, different */
    #####: 5693:    if (sticky->n_on_opts &&
    #####: 5694:	memcmp(sticky->on_opts, sticky2->on_opts,
    #####: 5695:	       sticky->n_on_opts * sizeof(*sticky->on_opts)) != 0)
    #####: 5696:	return 1;
        -: 5697:    /* If different options turned on, different */
    #####: 5698:    if (sticky->n_off_opts &&
    #####: 5699:	memcmp(sticky->off_opts, sticky2->off_opts,
    #####: 5700:	       sticky->n_off_opts * sizeof(*sticky->off_opts)) != 0)
    #####: 5701:	return 1;
    #####: 5702:    return 0;
        -: 5703:}
        -: 5704:
        -: 5705:/*
        -: 5706: * execute a shell function
        -: 5707: *
        -: 5708: * name is the name of the function
        -: 5709: *
        -: 5710: * prog is the code to execute
        -: 5711: *
        -: 5712: * doshargs, if set, are parameters to pass to the function,
        -: 5713: * in which the first element is the function name (even if
        -: 5714: * FUNCTIONARGZERO is set as this is handled inside this function).
        -: 5715: *
        -: 5716: * If noreturnval is nonzero, then reset the current return
        -: 5717: * value (lastval) to its value before the shell function
        -: 5718: * was executed.  However, in any case return the status value
        -: 5719: * from the function (i.e. if noreturnval is not set, this
        -: 5720: * will be the same as lastval).
        -: 5721: */
        -: 5722:
        -: 5723:/**/
        -: 5724:mod_export int
      130: 5725:doshfunc(Shfunc shfunc, LinkList doshargs, int noreturnval)
        -: 5726:{
        -: 5727:    char **pptab, **x;
        -: 5728:    int ret;
      130: 5729:    char *name = shfunc->node.nam;
      130: 5730:    int flags = shfunc->node.flags;
      130: 5731:    char *fname = dupstring(name);
        -: 5732:    Eprog prog;
        -: 5733:    static int oflags;
        -: 5734:    static int funcdepth;
        -: 5735:    Heap funcheap;
        -: 5736:
      130: 5737:    queue_signals();	/* Lots of memory and global state changes coming */
        -: 5738:
      130: 5739:    NEWHEAPS(funcheap) {
        -: 5740:	/*
        -: 5741:	 * Save data in heap rather than on stack to keep recursive
        -: 5742:	 * function cost down --- use of heap memory should be efficient
        -: 5743:	 * at this point.  Saving is not actually massive.
        -: 5744:	 */
      130: 5745:	Funcsave funcsave = zhalloc(sizeof(struct funcsave));
      130: 5746:	funcsave->scriptname = scriptname;
      130: 5747:	funcsave->argv0 = NULL;
      130: 5748:	funcsave->breaks = breaks;
      130: 5749:	funcsave->contflag = contflag;
      130: 5750:	funcsave->loops = loops;
      130: 5751:	funcsave->lastval = lastval;
      130: 5752:	funcsave->pipestats = NULL;
      130: 5753:	funcsave->numpipestats = numpipestats;
      130: 5754:	funcsave->noerrexit = noerrexit;
      130: 5755:	if (trap_state == TRAP_STATE_PRIMED)
    #####: 5756:	    trap_return--;
        -: 5757:	/*
        -: 5758:	 * Suppression of ERR_RETURN is turned off in function scope.
        -: 5759:	 */
      130: 5760:	noerrexit &= ~NOERREXIT_RETURN;
      130: 5761:	if (noreturnval) {
        -: 5762:	    /*
        -: 5763:	     * Easiest to use the heap here since we're bracketed
        -: 5764:	     * immediately by a pushheap/popheap pair.
        -: 5765:	     */
    #####: 5766:	    size_t bytes = sizeof(int)*numpipestats;
    #####: 5767:	    funcsave->pipestats = (int *)zhalloc(bytes);
    #####: 5768:	    memcpy(funcsave->pipestats, pipestats, bytes);
        -: 5769:	}
        -: 5770:
      130: 5771:	starttrapscope();
      130: 5772:	startpatternscope();
        -: 5773:
      130: 5774:	pptab = pparams;
      130: 5775:	if (!(flags & PM_UNDEFINED))
      130: 5776:	    scriptname = dupstring(name);
      130: 5777:	funcsave->zoptind = zoptind;
      130: 5778:	funcsave->optcind = optcind;
      130: 5779:	if (!isset(POSIXBUILTINS)) {
      130: 5780:	    zoptind = 1;
      130: 5781:	    optcind = 0;
        -: 5782:	}
        -: 5783:
        -: 5784:	/* We need to save the current options even if LOCALOPTIONS is *
        -: 5785:	 * not currently set.  That's because if it gets set in the    *
        -: 5786:	 * function we need to restore the original options on exit.   */
      130: 5787:	memcpy(funcsave->opts, opts, sizeof(opts));
      130: 5788:	funcsave->emulation = emulation;
      130: 5789:	funcsave->sticky = sticky;
        -: 5790:
      130: 5791:	if (sticky_emulation_differs(shfunc->sticky)) {
        -: 5792:	    /*
        -: 5793:	     * Function is marked for sticky emulation.
        -: 5794:	     * Enable it now.
        -: 5795:	     *
        -: 5796:	     * We deliberately do not do this if the sticky emulation
        -: 5797:	     * in effect is the same as that requested.  This enables
        -: 5798:	     * option setting naturally within emulation environments.
        -: 5799:	     * Note that a difference in EMULATE_FULLY (emulate with
        -: 5800:	     * or without -R) counts as a different environment.
        -: 5801:	     *
        -: 5802:	     * This propagates the sticky emulation to subfunctions.
        -: 5803:	     */
    #####: 5804:	    sticky = sticky_emulation_dup(shfunc->sticky, 1);
    #####: 5805:	    emulation = sticky->emulation;
    #####: 5806:	    funcsave->restore_sticky = 1;
    #####: 5807:	    installemulation(emulation, opts);
    #####: 5808:	    if (sticky->n_on_opts) {
        -: 5809:		OptIndex *onptr;
    #####: 5810:		for (onptr = sticky->on_opts;
    #####: 5811:		     onptr < sticky->on_opts + sticky->n_on_opts;
    #####: 5812:		     onptr++)
    #####: 5813:		    opts[*onptr] = 1;
        -: 5814:	    }
    #####: 5815:	    if (sticky->n_off_opts) {
        -: 5816:		OptIndex *offptr;
    #####: 5817:		for (offptr = sticky->off_opts;
    #####: 5818:		     offptr < sticky->off_opts + sticky->n_off_opts;
    #####: 5819:		     offptr++)
    #####: 5820:		    opts[*offptr] = 0;
        -: 5821:	    }
        -: 5822:	    /* All emulations start with pattern disables clear */
    #####: 5823:	    clearpatterndisables();
        -: 5824:	} else
      130: 5825:	    funcsave->restore_sticky = 0;
        -: 5826:
      130: 5827:	if (flags & (PM_TAGGED|PM_TAGGED_LOCAL))
    #####: 5828:	    opts[XTRACE] = 1;
      130: 5829:	else if (oflags & PM_TAGGED_LOCAL) {
    #####: 5830:	    if (shfunc->node.nam == ANONYMOUS_FUNCTION_NAME /* pointer comparison */)
    #####: 5831:		flags |= PM_TAGGED_LOCAL;
        -: 5832:	    else
    #####: 5833:		opts[XTRACE] = 0;
        -: 5834:	}
      130: 5835:	if (flags & PM_WARNNESTED)
    #####: 5836:	    opts[WARNNESTEDVAR] = 1;
      130: 5837:	else if (oflags & PM_WARNNESTED) {
    #####: 5838:	    if (shfunc->node.nam == ANONYMOUS_FUNCTION_NAME)
    #####: 5839:		flags |= PM_WARNNESTED;
        -: 5840:	    else
    #####: 5841:		opts[WARNNESTEDVAR] = 0;
        -: 5842:	}
      130: 5843:	funcsave->oflags = oflags;
        -: 5844:	/*
        -: 5845:	 * oflags is static, because we compare it on the next recursive
        -: 5846:	 * call.  Hence also we maintain a saved version for restoring
        -: 5847:	 * the previous value of oflags after the call.
        -: 5848:	 */
      130: 5849:	oflags = flags;
      130: 5850:	opts[PRINTEXITVALUE] = 0;
      130: 5851:	if (doshargs) {
        -: 5852:	    LinkNode node;
        -: 5853:
      130: 5854:	    node = firstnode(doshargs);
      130: 5855:	    pparams = x = (char **) zshcalloc(((sizeof *x) *
      130: 5856:					       (1 + countlinknodes(doshargs))));
      130: 5857:	    if (isset(FUNCTIONARGZERO)) {
      130: 5858:		funcsave->argv0 = argzero;
      130: 5859:		argzero = ztrdup(getdata(node));
        -: 5860:	    }
        -: 5861:	    /* first node contains name regardless of option */
      130: 5862:	    node = node->next;
      288: 5863:	    for (; node; node = node->next, x++)
      158: 5864:		*x = ztrdup(getdata(node));
        -: 5865:	} else {
    #####: 5866:	    pparams = (char **) zshcalloc(sizeof *pparams);
    #####: 5867:	    if (isset(FUNCTIONARGZERO)) {
    #####: 5868:		funcsave->argv0 = argzero;
    #####: 5869:		argzero = ztrdup(argzero);
        -: 5870:	    }
        -: 5871:	}
      130: 5872:	++funcdepth;
      130: 5873:	if (zsh_funcnest >= 0 && funcdepth > zsh_funcnest) {
    #####: 5874:	    zerr("maximum nested function level reached; increase FUNCNEST?");
    #####: 5875:	    lastval = 1;
    #####: 5876:	    goto undoshfunc;
        -: 5877:	}
      130: 5878:	funcsave->fstack.name = dupstring(name);
        -: 5879:	/*
        -: 5880:	 * The caller is whatever is immediately before on the stack,
        -: 5881:	 * unless we're at the top, in which case it's the script
        -: 5882:	 * or interactive shell name.
        -: 5883:	 */
      136: 5884:	funcsave->fstack.caller = funcstack ? funcstack->name :
        6: 5885:	    dupstring(funcsave->argv0 ? funcsave->argv0 : argzero);
      130: 5886:	funcsave->fstack.lineno = lineno;
      130: 5887:	funcsave->fstack.prev = funcstack;
      130: 5888:	funcsave->fstack.tp = FS_FUNC;
      130: 5889:	funcstack = &funcsave->fstack;
        -: 5890:
      130: 5891:	funcsave->fstack.flineno = shfunc->lineno;
      130: 5892:	funcsave->fstack.filename = getshfuncfile(shfunc);
        -: 5893:
      130: 5894:	prog = shfunc->funcdef;
      130: 5895:	if (prog->flags & EF_RUN) {
        -: 5896:	    Shfunc shf;
        -: 5897:
    #####: 5898:	    prog->flags &= ~EF_RUN;
        -: 5899:
    #####: 5900:	    runshfunc(prog, NULL, funcsave->fstack.name);
        -: 5901:
    #####: 5902:	    if (!(shf = (Shfunc) shfunctab->getnode(shfunctab,
    #####: 5903:						    (name = fname)))) {
    #####: 5904:		zwarn("%s: function not defined by file", name);
    #####: 5905:		if (noreturnval)
    #####: 5906:		    errflag |= ERRFLAG_ERROR;
        -: 5907:		else
    #####: 5908:		    lastval = 1;
    #####: 5909:		goto doneshfunc;
        -: 5910:	    }
    #####: 5911:	    prog = shf->funcdef;
        -: 5912:	}
      130: 5913:	runshfunc(prog, wrappers, funcsave->fstack.name);
      130: 5914:    doneshfunc:
      130: 5915:	funcstack = funcsave->fstack.prev;
      130: 5916:    undoshfunc:
      130: 5917:	--funcdepth;
      130: 5918:	if (retflag) {
        -: 5919:	    /*
        -: 5920:	     * This function is forced to return.
        -: 5921:	     */
       49: 5922:	    retflag = 0;
        -: 5923:	    /*
        -: 5924:	     * The calling function isn't necessarily forced to return,
        -: 5925:	     * but it should be made sensitive to ERR_EXIT and
        -: 5926:	     * ERR_RETURN as the assumptions we made at the end of
        -: 5927:	     * constructs within this function no longer apply.  If
        -: 5928:	     * there are cases where this is not true, they need adding
        -: 5929:	     * to C03traps.ztst.
        -: 5930:	     */
       49: 5931:	    this_noerrexit = 0;
       49: 5932:	    breaks = funcsave->breaks;
        -: 5933:	}
      130: 5934:	freearray(pparams);
      130: 5935:	if (funcsave->argv0) {
      130: 5936:	    zsfree(argzero);
      130: 5937:	    argzero = funcsave->argv0;
        -: 5938:	}
      130: 5939:	pparams = pptab;
      130: 5940:	if (!isset(POSIXBUILTINS)) {
      130: 5941:	    zoptind = funcsave->zoptind;
      130: 5942:	    optcind = funcsave->optcind;
        -: 5943:	}
      130: 5944:	scriptname = funcsave->scriptname;
      130: 5945:	oflags = funcsave->oflags;
        -: 5946:
      130: 5947:	endpatternscope();	/* before restoring old LOCALPATTERNS */
        -: 5948:
      130: 5949:	if (funcsave->restore_sticky) {
        -: 5950:	    /*
        -: 5951:	     * If we switched to an emulation environment just for
        -: 5952:	     * this function, we interpret the option and emulation
        -: 5953:	     * switch as being a firewall between environments.
        -: 5954:	     */
    #####: 5955:	    memcpy(opts, funcsave->opts, sizeof(opts));
    #####: 5956:	    emulation = funcsave->emulation;
    #####: 5957:	    sticky = funcsave->sticky;
      130: 5958:	} else if (isset(LOCALOPTIONS)) {
        -: 5959:	    /* restore all shell options except PRIVILEGED and RESTRICTED */
        8: 5960:	    funcsave->opts[PRIVILEGED] = opts[PRIVILEGED];
        8: 5961:	    funcsave->opts[RESTRICTED] = opts[RESTRICTED];
        8: 5962:	    memcpy(opts, funcsave->opts, sizeof(opts));
        8: 5963:	    emulation = funcsave->emulation;
        -: 5964:	} else {
        -: 5965:	    /* just restore a couple. */
      122: 5966:	    opts[XTRACE] = funcsave->opts[XTRACE];
      122: 5967:	    opts[PRINTEXITVALUE] = funcsave->opts[PRINTEXITVALUE];
      122: 5968:	    opts[LOCALOPTIONS] = funcsave->opts[LOCALOPTIONS];
      122: 5969:	    opts[LOCALLOOPS] = funcsave->opts[LOCALLOOPS];
      122: 5970:	    opts[WARNNESTEDVAR] = funcsave->opts[WARNNESTEDVAR];
        -: 5971:	}
        -: 5972:
      130: 5973:	if (opts[LOCALLOOPS]) {
    #####: 5974:	    if (contflag)
    #####: 5975:		zwarn("`continue' active at end of function scope");
    #####: 5976:	    if (breaks)
    #####: 5977:		zwarn("`break' active at end of function scope");
    #####: 5978:	    breaks = funcsave->breaks;
    #####: 5979:	    contflag = funcsave->contflag;
    #####: 5980:	    loops = funcsave->loops;
        -: 5981:	}
        -: 5982:
      130: 5983:	endtrapscope();
        -: 5984:
      130: 5985:	if (trap_state == TRAP_STATE_PRIMED)
    #####: 5986:	    trap_return++;
      130: 5987:	ret = lastval;
      130: 5988:	noerrexit = funcsave->noerrexit;
      130: 5989:	if (noreturnval) {
    #####: 5990:	    lastval = funcsave->lastval;
    #####: 5991:	    numpipestats = funcsave->numpipestats;
    #####: 5992:	    memcpy(pipestats, funcsave->pipestats, sizeof(int)*numpipestats);
        -: 5993:	}
      130: 5994:    } OLDHEAPS;
        -: 5995:
      130: 5996:    unqueue_signals();
        -: 5997:
        -: 5998:    /*
        -: 5999:     * Exit with a tidy up.
        -: 6000:     * Only leave if we're at the end of the appropriate function ---
        -: 6001:     * not a nested function.  As we usually skip the function body,
        -: 6002:     * the only likely case where we need that second test is
        -: 6003:     * when we have an "always" block.  The endparamscope() has
        -: 6004:     * already happened, hence the "+1" here.
        -: 6005:     *
        -: 6006:     * If we are in an exit trap, finish it first... we wouldn't set
        -: 6007:     * exit_pending if we were already in one.
        -: 6008:     */
      130: 6009:    if (exit_pending && exit_level >= locallevel+1 && !in_exit_trap) {
    #####: 6010:	if (locallevel > forklevel) {
        -: 6011:	    /* Still functions to return: force them to do so. */
    #####: 6012:	    retflag = 1;
    #####: 6013:	    breaks = loops;
        -: 6014:	} else {
        -: 6015:	    /*
        -: 6016:	     * All functions finished: time to exit the shell.
        -: 6017:	     * We already did the `stopmsg' test when the
        -: 6018:	     * exit command was handled.
        -: 6019:	     */
    #####: 6020:	    stopmsg = 1;
    #####: 6021:	    zexit(exit_val, ZEXIT_NORMAL);
        -: 6022:	}
        -: 6023:    }
        -: 6024:
      130: 6025:    return ret;
        -: 6026:}
        -: 6027:
        -: 6028:/* This finally executes a shell function and any function wrappers     *
        -: 6029: * defined by modules. This works by calling the wrapper function which *
        -: 6030: * in turn has to call back this function with the arguments it gets.   */
        -: 6031:
        -: 6032:/**/
        -: 6033:mod_export void
      130: 6034:runshfunc(Eprog prog, FuncWrap wrap, char *name)
        -: 6035:{
        -: 6036:    int cont, ouu;
        -: 6037:    char *ou;
        -: 6038:
      130: 6039:    queue_signals();
        -: 6040:
      130: 6041:    ou = zalloc(ouu = underscoreused);
      130: 6042:    if (ou)
      130: 6043:	memcpy(ou, zunderscore, underscoreused);
        -: 6044:
      260: 6045:    while (wrap) {
    #####: 6046:	wrap->module->wrapper++;
    #####: 6047:	cont = wrap->handler(prog, wrap->next, name);
    #####: 6048:	wrap->module->wrapper--;
        -: 6049:
    #####: 6050:	if (!wrap->module->wrapper &&
    #####: 6051:	    (wrap->module->node.flags & MOD_UNLOAD))
    #####: 6052:	    unload_module(wrap->module);
        -: 6053:
    #####: 6054:	if (!cont) {
    #####: 6055:	    if (ou)
    #####: 6056:		zfree(ou, ouu);
    #####: 6057:	    unqueue_signals();
    #####: 6058:	    return;
        -: 6059:	}
    #####: 6060:	wrap = wrap->next;
        -: 6061:    }
      130: 6062:    startparamscope();
      130: 6063:    execode(prog, 1, 0, "shfunc");	/* handles signal unqueueing */
      130: 6064:    if (ou) {
      130: 6065:	setunderscore(ou);
      130: 6066:	zfree(ou, ouu);
        -: 6067:    }
      130: 6068:    endparamscope();
        -: 6069:
      130: 6070:    unqueue_signals();
        -: 6071:}
        -: 6072:
        -: 6073:/*
        -: 6074: * Search fpath for an undefined function.  Finds the file, and returns the
        -: 6075: * list of its contents.
        -: 6076: *
        -: 6077: * If test is 0, load the function.
        -: 6078: *
        -: 6079: * If test_only is 1, don't load function, just test for it:
        -: 6080: * Non-null return means function was found
        -: 6081: *
        -: 6082: * *fdir points to path at which found (as passed in, not duplicated)
        -: 6083: */
        -: 6084:
        -: 6085:/**/
        -: 6086:Eprog
    #####: 6087:getfpfunc(char *s, int *ksh, char **fdir, char **alt_path, int test_only)
        -: 6088:{
        -: 6089:    char **pp, buf[PATH_MAX+1];
        -: 6090:    off_t len;
        -: 6091:    off_t rlen;
        -: 6092:    char *d;
        -: 6093:    Eprog r;
        -: 6094:    int fd;
        -: 6095:
    #####: 6096:    pp = alt_path ? alt_path : fpath;
    #####: 6097:    for (; *pp; pp++) {
    #####: 6098:	if (strlen(*pp) + strlen(s) + 1 >= PATH_MAX)
    #####: 6099:	    continue;
    #####: 6100:	if (**pp)
    #####: 6101:	    sprintf(buf, "%s/%s", *pp, s);
        -: 6102:	else
    #####: 6103:	    strcpy(buf, s);
    #####: 6104:	if ((r = try_dump_file(*pp, s, buf, ksh, test_only))) {
    #####: 6105:	    if (fdir)
    #####: 6106:		*fdir = *pp;
    #####: 6107:	    return r;
        -: 6108:	}
    #####: 6109:	unmetafy(buf, NULL);
    #####: 6110:	if (!access(buf, R_OK) && (fd = open(buf, O_RDONLY | O_NOCTTY)) != -1) {
        -: 6111:	    struct stat st;
    #####: 6112:	    if (!fstat(fd, &st) && S_ISREG(st.st_mode) &&
        -: 6113:		(len = lseek(fd, 0, 2)) != -1) {
    #####: 6114:		if (test_only) {
    #####: 6115:		    close(fd);
    #####: 6116:		    if (fdir)
    #####: 6117:			*fdir = *pp;
    #####: 6118:		    return &dummy_eprog;
        -: 6119:		}
    #####: 6120:		d = (char *) zalloc(len + 1);
    #####: 6121:		lseek(fd, 0, 0);
    #####: 6122:		if ((rlen = read(fd, d, len)) >= 0) {
    #####: 6123:		    char *oldscriptname = scriptname;
        -: 6124:
    #####: 6125:		    close(fd);
    #####: 6126:		    d[rlen] = '\0';
    #####: 6127:		    d = metafy(d, rlen, META_REALLOC);
        -: 6128:
    #####: 6129:		    scriptname = dupstring(s);
    #####: 6130:		    r = parse_string(d, 1);
    #####: 6131:		    scriptname = oldscriptname;
        -: 6132:
    #####: 6133:		    if (fdir)
    #####: 6134:			*fdir = *pp;
        -: 6135:
    #####: 6136:		    zfree(d, len + 1);
        -: 6137:
    #####: 6138:		    return r;
        -: 6139:		} else
    #####: 6140:		    close(fd);
        -: 6141:
    #####: 6142:		zfree(d, len + 1);
        -: 6143:	    } else
    #####: 6144:		close(fd);
        -: 6145:	}
        -: 6146:    }
    #####: 6147:    return test_only ? NULL : &dummy_eprog;
        -: 6148:}
        -: 6149:
        -: 6150:/* Handle the most common type of ksh-style autoloading, when doing a      *
        -: 6151: * zsh-style autoload.  Given the list read from an autoload file, and the *
        -: 6152: * name of the function being defined, check to see if the file consists   *
        -: 6153: * entirely of a single definition for that function.  If so, use the      *
        -: 6154: * contents of that definition.  Otherwise, use the entire file.           */
        -: 6155:
        -: 6156:/**/
        -: 6157:Eprog
    #####: 6158:stripkshdef(Eprog prog, char *name)
        -: 6159:{
        -: 6160:    Wordcode pc;
        -: 6161:    wordcode code;
        -: 6162:    char *ptr1, *ptr2;
        -: 6163:
    #####: 6164:    if (!prog)
    #####: 6165:	return NULL;
    #####: 6166:    pc = prog->prog;
    #####: 6167:    code = *pc++;
    #####: 6168:    if (wc_code(code) != WC_LIST ||
    #####: 6169:	(WC_LIST_TYPE(code) & (Z_SYNC|Z_END|Z_SIMPLE)) != (Z_SYNC|Z_END|Z_SIMPLE))
    #####: 6170:	return prog;
    #####: 6171:    pc++;
    #####: 6172:    code = *pc++;
    #####: 6173:    if (wc_code(code) != WC_FUNCDEF ||	*pc != 1)
    #####: 6174:	return prog;
        -: 6175:
        -: 6176:    /*
        -: 6177:     * See if name of function requested (name) is same as
        -: 6178:     * name of function in word code.  name may still have "-"
        -: 6179:     * tokenised.  The word code shouldn't, as function names should be
        -: 6180:     * untokenised, but reports say it sometimes does.
        -: 6181:     */
    #####: 6182:    ptr1 = name;
    #####: 6183:    ptr2 = ecrawstr(prog, pc + 1, NULL);
    #####: 6184:    while (*ptr1 && *ptr2) {
    #####: 6185:	if (*ptr1 != *ptr2 && *ptr1 != Dash && *ptr1 != '-' &&
    #####: 6186:	    *ptr2 != Dash && *ptr2 != '-')
    #####: 6187:	    break;
    #####: 6188:	ptr1++;
    #####: 6189:	ptr2++;
        -: 6190:    }
    #####: 6191:    if (*ptr1 || *ptr2)
    #####: 6192:	return prog;
        -: 6193:
        -: 6194:    {
        -: 6195:	Eprog ret;
    #####: 6196:	Wordcode end = pc + WC_FUNCDEF_SKIP(code);
    #####: 6197:	int sbeg = pc[2], nstrs = pc[3], nprg, npats = pc[4], plen, len, i;
        -: 6198:	Patprog *pp;
        -: 6199:
    #####: 6200:	pc += 6;
        -: 6201:
    #####: 6202:	nprg = end - pc;
    #####: 6203:	plen = nprg * sizeof(wordcode);
    #####: 6204:	len = plen + (npats * sizeof(Patprog)) + nstrs;
        -: 6205:
    #####: 6206:	if (prog->flags & EF_MAP) {
    #####: 6207:	    ret = prog;
    #####: 6208:	    free(prog->pats);
    #####: 6209:	    ret->pats = pp = (Patprog *) zalloc(npats * sizeof(Patprog));
    #####: 6210:	    ret->prog = pc;
    #####: 6211:	    ret->strs = prog->strs + sbeg;
        -: 6212:	} else {
    #####: 6213:	    ret = (Eprog) zhalloc(sizeof(*ret));
    #####: 6214:	    ret->flags = EF_HEAP;
    #####: 6215:	    ret->pats = pp = (Patprog *) zhalloc(len);
    #####: 6216:	    ret->prog = (Wordcode) (ret->pats + npats);
    #####: 6217:	    ret->strs = (char *) (ret->prog + nprg);
    #####: 6218:	    memcpy(ret->prog, pc, plen);
    #####: 6219:	    memcpy(ret->strs, prog->strs + sbeg, nstrs);
    #####: 6220:	    ret->dump = NULL;
        -: 6221:	}
    #####: 6222:	ret->len = len;
    #####: 6223:	ret->npats = npats;
    #####: 6224:	for (i = npats; i--; pp++)
    #####: 6225:	    *pp = dummy_patprog1;
    #####: 6226:	ret->shf = NULL;
        -: 6227:
    #####: 6228:	return ret;
        -: 6229:    }
        -: 6230:}
        -: 6231:
        -: 6232:/* check to see if AUTOCD applies here */
        -: 6233:
        -: 6234:/**/
        -: 6235:static char *
    #####: 6236:cancd(char *s)
        -: 6237:{
    #####: 6238:    int nocdpath = s[0] == '.' &&
    #####: 6239:    (s[1] == '/' || !s[1] || (s[1] == '.' && (s[2] == '/' || !s[1])));
        -: 6240:    char *t;
        -: 6241:
    #####: 6242:    if (*s != '/') {
        -: 6243:	char sbuf[PATH_MAX+1], **cp;
        -: 6244:
    #####: 6245:	if (cancd2(s))
    #####: 6246:	    return s;
    #####: 6247:	if (access(unmeta(s), X_OK) == 0)
    #####: 6248:	    return NULL;
    #####: 6249:	if (!nocdpath)
    #####: 6250:	    for (cp = cdpath; *cp; cp++) {
    #####: 6251:		if (strlen(*cp) + strlen(s) + 1 >= PATH_MAX)
    #####: 6252:		    continue;
    #####: 6253:		if (**cp)
    #####: 6254:		    sprintf(sbuf, "%s/%s", *cp, s);
        -: 6255:		else
    #####: 6256:		    strcpy(sbuf, s);
    #####: 6257:		if (cancd2(sbuf)) {
    #####: 6258:		    doprintdir = -1;
    #####: 6259:		    return dupstring(sbuf);
        -: 6260:		}
        -: 6261:	    }
    #####: 6262:	if ((t = cd_able_vars(s))) {
    #####: 6263:	    if (cancd2(t)) {
    #####: 6264:		doprintdir = -1;
    #####: 6265:		return t;
        -: 6266:	    }
        -: 6267:	}
    #####: 6268:	return NULL;
        -: 6269:    }
    #####: 6270:    return cancd2(s) ? s : NULL;
        -: 6271:}
        -: 6272:
        -: 6273:/**/
        -: 6274:static int
    #####: 6275:cancd2(char *s)
        -: 6276:{
        -: 6277:    struct stat buf;
    #####: 6278:    char *us, *us2 = NULL;
        -: 6279:    int ret;
        -: 6280:
        -: 6281:    /*
        -: 6282:     * If CHASEDOTS and CHASELINKS are not set, we want to rationalize the
        -: 6283:     * path by removing foo/.. combinations in the logical rather than
        -: 6284:     * the physical path.  If either is set, we test the physical path.
        -: 6285:     */
    #####: 6286:    if (!isset(CHASEDOTS) && !isset(CHASELINKS)) {
    #####: 6287:	if (*s != '/')
    #####: 6288:	    us = tricat(pwd[1] ? pwd : "", "/", s);
        -: 6289:	else
    #####: 6290:	    us = ztrdup(s);
    #####: 6291:	fixdir(us2 = us);
        -: 6292:    } else
    #####: 6293:	us = unmeta(s);
    #####: 6294:    ret = !(access(us, X_OK) || stat(us, &buf) || !S_ISDIR(buf.st_mode));
    #####: 6295:    if (us2)
    #####: 6296:	free(us2);
    #####: 6297:    return ret;
        -: 6298:}
        -: 6299:
        -: 6300:/**/
        -: 6301:void
    #####: 6302:execsave(void)
        -: 6303:{
        -: 6304:    struct execstack *es;
        -: 6305:
    #####: 6306:    es = (struct execstack *) zalloc(sizeof(struct execstack));
    #####: 6307:    es->list_pipe_pid = list_pipe_pid;
    #####: 6308:    es->nowait = nowait;
    #####: 6309:    es->pline_level = pline_level;
    #####: 6310:    es->list_pipe_child = list_pipe_child;
    #####: 6311:    es->list_pipe_job = list_pipe_job;
    #####: 6312:    strcpy(es->list_pipe_text, list_pipe_text);
    #####: 6313:    es->lastval = lastval;
    #####: 6314:    es->noeval = noeval;
    #####: 6315:    es->badcshglob = badcshglob;
    #####: 6316:    es->cmdoutpid = cmdoutpid;
    #####: 6317:    es->cmdoutval = cmdoutval;
    #####: 6318:    es->use_cmdoutval = use_cmdoutval;
    #####: 6319:    es->procsubstpid = procsubstpid;
    #####: 6320:    es->trap_return = trap_return;
    #####: 6321:    es->trap_state = trap_state;
    #####: 6322:    es->trapisfunc = trapisfunc;
    #####: 6323:    es->traplocallevel = traplocallevel;
    #####: 6324:    es->noerrs = noerrs;
    #####: 6325:    es->this_noerrexit = this_noerrexit;
    #####: 6326:    es->underscore = ztrdup(zunderscore);
    #####: 6327:    es->next = exstack;
    #####: 6328:    exstack = es;
    #####: 6329:    noerrs = cmdoutpid = 0;
    #####: 6330:}
        -: 6331:
        -: 6332:/**/
        -: 6333:void
    #####: 6334:execrestore(void)
        -: 6335:{
    #####: 6336:    struct execstack *en = exstack;
        -: 6337:
        -: 6338:    DPUTS(!exstack, "BUG: execrestore() without execsave()");
        -: 6339:
    #####: 6340:    queue_signals();
    #####: 6341:    exstack = exstack->next;
        -: 6342:
    #####: 6343:    list_pipe_pid = en->list_pipe_pid;
    #####: 6344:    nowait = en->nowait;
    #####: 6345:    pline_level = en->pline_level;
    #####: 6346:    list_pipe_child = en->list_pipe_child;
    #####: 6347:    list_pipe_job = en->list_pipe_job;
    #####: 6348:    strcpy(list_pipe_text, en->list_pipe_text);
    #####: 6349:    lastval = en->lastval;
    #####: 6350:    noeval = en->noeval;
    #####: 6351:    badcshglob = en->badcshglob;
    #####: 6352:    cmdoutpid = en->cmdoutpid;
    #####: 6353:    cmdoutval = en->cmdoutval;
    #####: 6354:    use_cmdoutval = en->use_cmdoutval;
    #####: 6355:    procsubstpid = en->procsubstpid;
    #####: 6356:    trap_return = en->trap_return;
    #####: 6357:    trap_state = en->trap_state;
    #####: 6358:    trapisfunc = en->trapisfunc;
    #####: 6359:    traplocallevel = en->traplocallevel;
    #####: 6360:    noerrs = en->noerrs;
    #####: 6361:    this_noerrexit = en->this_noerrexit;
    #####: 6362:    setunderscore(en->underscore);
    #####: 6363:    zsfree(en->underscore);
    #####: 6364:    free(en);
        -: 6365:
    #####: 6366:    unqueue_signals();
    #####: 6367:}
