        -:    0:Source:builtin.c
        -:    0:Programs:1
        -:    1:/*
        -:    2: * builtin.c - builtin commands
        -:    3: *
        -:    4: * This file is part of zsh, the Z shell.
        -:    5: *
        -:    6: * Copyright (c) 1992-1997 Paul Falstad
        -:    7: * All rights reserved.
        -:    8: *
        -:    9: * Permission is hereby granted, without written agreement and without
        -:   10: * license or royalty fees, to use, copy, modify, and distribute this
        -:   11: * software and to distribute modified versions of this software for any
        -:   12: * purpose, provided that the above copyright notice and the following
        -:   13: * two paragraphs appear in all copies of this software.
        -:   14: *
        -:   15: * In no event shall Paul Falstad or the Zsh Development Group be liable
        -:   16: * to any party for direct, indirect, special, incidental, or consequential
        -:   17: * damages arising out of the use of this software and its documentation,
        -:   18: * even if Paul Falstad and the Zsh Development Group have been advised of
        -:   19: * the possibility of such damage.
        -:   20: *
        -:   21: * Paul Falstad and the Zsh Development Group specifically disclaim any
        -:   22: * warranties, including, but not limited to, the implied warranties of
        -:   23: * merchantability and fitness for a particular purpose.  The software
        -:   24: * provided hereunder is on an "as is" basis, and Paul Falstad and the
        -:   25: * Zsh Development Group have no obligation to provide maintenance,
        -:   26: * support, updates, enhancements, or modifications.
        -:   27: *
        -:   28: */
        -:   29:
        -:   30:/* this is defined so we get the prototype for open_memstream */
        -:   31:#define _GNU_SOURCE 1
        -:   32:
        -:   33:#include "zsh.mdh"
        -:   34:#include "builtin.pro"
        -:   35:
        -:   36:#include <math.h>
        -:   37:
        -:   38:/* Builtins in the main executable */
        -:   39:
        -:   40:static struct builtin builtins[] =
        -:   41:{
        -:   42:    BIN_PREFIX("-", BINF_DASH),
        -:   43:    BIN_PREFIX("builtin", BINF_BUILTIN),
        -:   44:    BIN_PREFIX("command", BINF_COMMAND),
        -:   45:    BIN_PREFIX("exec", BINF_EXEC),
        -:   46:    BIN_PREFIX("noglob", BINF_NOGLOB),
        -:   47:    BUILTIN("[", BINF_HANDLES_OPTS, bin_test, 0, -1, BIN_BRACKET, NULL, NULL),
        -:   48:    BUILTIN(".", BINF_PSPECIAL, bin_dot, 1, -1, 0, NULL, NULL),
        -:   49:    BUILTIN(":", BINF_PSPECIAL, bin_true, 0, -1, 0, NULL, NULL),
        -:   50:    BUILTIN("alias", BINF_MAGICEQUALS | BINF_PLUSOPTS, bin_alias, 0, -1, 0, "Lgmrs", NULL),
        -:   51:    BUILTIN("autoload", BINF_PLUSOPTS, bin_functions, 0, -1, 0, "dmktrRTUwWXz", "u"),
        -:   52:    BUILTIN("bg", 0, bin_fg, 0, -1, BIN_BG, NULL, NULL),
        -:   53:    BUILTIN("break", BINF_PSPECIAL, bin_break, 0, 1, BIN_BREAK, NULL, NULL),
        -:   54:    BUILTIN("bye", 0, bin_break, 0, 1, BIN_EXIT, NULL, NULL),
        -:   55:    BUILTIN("cd", BINF_SKIPINVALID | BINF_SKIPDASH | BINF_DASHDASHVALID, bin_cd, 0, 2, BIN_CD, "qsPL", NULL),
        -:   56:    BUILTIN("chdir", BINF_SKIPINVALID | BINF_SKIPDASH | BINF_DASHDASHVALID, bin_cd, 0, 2, BIN_CD, "qsPL", NULL),
        -:   57:    BUILTIN("continue", BINF_PSPECIAL, bin_break, 0, 1, BIN_CONTINUE, NULL, NULL),
        -:   58:    BUILTIN("declare", BINF_PLUSOPTS | BINF_MAGICEQUALS | BINF_PSPECIAL | BINF_ASSIGN, (HandlerFunc)bin_typeset, 0, -1, 0, "AE:%F:%HL:%R:%TUZ:%afghi:%klmp:%rtuxz", NULL),
        -:   59:    BUILTIN("dirs", 0, bin_dirs, 0, -1, 0, "clpv", NULL),
        -:   60:    BUILTIN("disable", 0, bin_enable, 0, -1, BIN_DISABLE, "afmprs", NULL),
        -:   61:    BUILTIN("disown", 0, bin_fg, 0, -1, BIN_DISOWN, NULL, NULL),
        -:   62:    BUILTIN("echo", BINF_SKIPINVALID, bin_print, 0, -1, BIN_ECHO, "neE", "-"),
        -:   63:    BUILTIN("emulate", 0, bin_emulate, 0, -1, 0, "lLR", NULL),
        -:   64:    BUILTIN("enable", 0, bin_enable, 0, -1, BIN_ENABLE, "afmprs", NULL),
        -:   65:    BUILTIN("eval", BINF_PSPECIAL, bin_eval, 0, -1, BIN_EVAL, NULL, NULL),
        -:   66:    BUILTIN("exit", BINF_PSPECIAL, bin_break, 0, 1, BIN_EXIT, NULL, NULL),
        -:   67:    BUILTIN("export", BINF_PLUSOPTS | BINF_MAGICEQUALS | BINF_PSPECIAL | BINF_ASSIGN, (HandlerFunc)bin_typeset, 0, -1, BIN_EXPORT, "E:%F:%HL:%R:%TUZ:%afhi:%lp:%rtu", "xg"),
        -:   68:    BUILTIN("false", 0, bin_false, 0, -1, 0, NULL, NULL),
        -:   69:    /*
        -:   70:     * We used to behave as if the argument to -e was optional.
        -:   71:     * But that's actually not useful, so it's more consistent to
        -:   72:     * cause an error.
        -:   73:     */
        -:   74:    BUILTIN("fc", 0, bin_fc, 0, -1, BIN_FC, "aAdDe:EfiIlLmnpPrRst:W", NULL),
        -:   75:    BUILTIN("fg", 0, bin_fg, 0, -1, BIN_FG, NULL, NULL),
        -:   76:    BUILTIN("float", BINF_PLUSOPTS | BINF_MAGICEQUALS | BINF_PSPECIAL | BINF_ASSIGN, (HandlerFunc)bin_typeset, 0, -1, 0, "E:%F:%HL:%R:%Z:%ghlp:%rtux", "E"),
        -:   77:    BUILTIN("functions", BINF_PLUSOPTS, bin_functions, 0, -1, 0, "ckmMstTuUWx:z", NULL),
        -:   78:    BUILTIN("getln", 0, bin_read, 0, -1, 0, "ecnAlE", "zr"),
        -:   79:    BUILTIN("getopts", 0, bin_getopts, 2, -1, 0, NULL, NULL),
        -:   80:    BUILTIN("hash", BINF_MAGICEQUALS, bin_hash, 0, -1, 0, "Ldfmrv", NULL),
        -:   81:
        -:   82:#ifdef ZSH_HASH_DEBUG
        -:   83:    BUILTIN("hashinfo", 0, bin_hashinfo, 0, 0, 0, NULL, NULL),
        -:   84:#endif
        -:   85:
        -:   86:    BUILTIN("history", 0, bin_fc, 0, -1, BIN_FC, "adDEfiLmnpPrt:", "l"),
        -:   87:    BUILTIN("integer", BINF_PLUSOPTS | BINF_MAGICEQUALS | BINF_PSPECIAL | BINF_ASSIGN, (HandlerFunc)bin_typeset, 0, -1, 0, "HL:%R:%Z:%ghi:%lp:%rtux", "i"),
        -:   88:    BUILTIN("jobs", 0, bin_fg, 0, -1, BIN_JOBS, "dlpZrs", NULL),
        -:   89:    BUILTIN("kill", BINF_HANDLES_OPTS, bin_kill, 0, -1, 0, NULL, NULL),
        -:   90:    BUILTIN("let", 0, bin_let, 1, -1, 0, NULL, NULL),
        -:   91:    BUILTIN("local", BINF_PLUSOPTS | BINF_MAGICEQUALS | BINF_PSPECIAL | BINF_ASSIGN, (HandlerFunc)bin_typeset, 0, -1, 0, "AE:%F:%HL:%R:%TUZ:%ahi:%lp:%rtux", NULL),
        -:   92:    BUILTIN("log", 0, bin_log, 0, 0, 0, NULL, NULL),
        -:   93:    BUILTIN("logout", 0, bin_break, 0, 1, BIN_LOGOUT, NULL, NULL),
        -:   94:
        -:   95:#if defined(ZSH_MEM) & defined(ZSH_MEM_DEBUG)
        -:   96:    BUILTIN("mem", 0, bin_mem, 0, 0, 0, "v", NULL),
        -:   97:#endif
        -:   98:
        -:   99:#if defined(ZSH_PAT_DEBUG)
        -:  100:    BUILTIN("patdebug", 0, bin_patdebug, 1, -1, 0, "p", NULL),
        -:  101:#endif
        -:  102:
        -:  103:    BUILTIN("popd", BINF_SKIPINVALID | BINF_SKIPDASH | BINF_DASHDASHVALID, bin_cd, 0, 1, BIN_POPD, "q", NULL),
        -:  104:    BUILTIN("print", BINF_PRINTOPTS, bin_print, 0, -1, BIN_PRINT, "abcC:Df:ilmnNoOpPrRsSu:v:x:X:z-", NULL),
        -:  105:    BUILTIN("printf", BINF_SKIPINVALID | BINF_SKIPDASH, bin_print, 1, -1, BIN_PRINTF, "v:", NULL),
        -:  106:    BUILTIN("pushd", BINF_SKIPINVALID | BINF_SKIPDASH | BINF_DASHDASHVALID, bin_cd, 0, 2, BIN_PUSHD, "qsPL", NULL),
        -:  107:    BUILTIN("pushln", 0, bin_print, 0, -1, BIN_PRINT, NULL, "-nz"),
        -:  108:    BUILTIN("pwd", 0, bin_pwd, 0, 0, 0, "rLP", NULL),
        -:  109:    BUILTIN("r", 0, bin_fc, 0, -1, BIN_R, "IlLnr", NULL),
        -:  110:    BUILTIN("read", 0, bin_read, 0, -1, 0, "cd:ek:%lnpqrst:%zu:AE", NULL),
        -:  111:    BUILTIN("readonly", BINF_PLUSOPTS | BINF_MAGICEQUALS | BINF_PSPECIAL | BINF_ASSIGN, (HandlerFunc)bin_typeset, 0, -1, BIN_READONLY, "AE:%F:%HL:%R:%TUZ:%afghi:%lptux", "r"),
        -:  112:    BUILTIN("rehash", 0, bin_hash, 0, 0, 0, "df", "r"),
        -:  113:    BUILTIN("return", BINF_PSPECIAL, bin_break, 0, 1, BIN_RETURN, NULL, NULL),
        -:  114:    BUILTIN("set", BINF_PSPECIAL | BINF_HANDLES_OPTS, bin_set, 0, -1, 0, NULL, NULL),
        -:  115:    BUILTIN("setopt", 0, bin_setopt, 0, -1, BIN_SETOPT, NULL, NULL),
        -:  116:    BUILTIN("shift", BINF_PSPECIAL, bin_shift, 0, -1, 0, "p", NULL),
        -:  117:    BUILTIN("source", BINF_PSPECIAL, bin_dot, 1, -1, 0, NULL, NULL),
        -:  118:    BUILTIN("suspend", 0, bin_suspend, 0, 0, 0, "f", NULL),
        -:  119:    BUILTIN("test", BINF_HANDLES_OPTS, bin_test, 0, -1, BIN_TEST, NULL, NULL),
        -:  120:    BUILTIN("ttyctl", 0, bin_ttyctl, 0, 0, 0, "fu", NULL),
        -:  121:    BUILTIN("times", BINF_PSPECIAL, bin_times, 0, 0, 0, NULL, NULL),
        -:  122:    BUILTIN("trap", BINF_PSPECIAL | BINF_HANDLES_OPTS, bin_trap, 0, -1, 0, NULL, NULL),
        -:  123:    BUILTIN("true", 0, bin_true, 0, -1, 0, NULL, NULL),
        -:  124:    BUILTIN("type", 0, bin_whence, 0, -1, 0, "ampfsSw", "v"),
        -:  125:    BUILTIN("typeset", BINF_PLUSOPTS | BINF_MAGICEQUALS | BINF_PSPECIAL | BINF_ASSIGN, (HandlerFunc)bin_typeset, 0, -1, 0, "AE:%F:%HL:%R:%TUZ:%afghi:%klp:%rtuxmz", NULL),
        -:  126:    BUILTIN("umask", 0, bin_umask, 0, 1, 0, "S", NULL),
        -:  127:    BUILTIN("unalias", 0, bin_unhash, 0, -1, BIN_UNALIAS, "ams", NULL),
        -:  128:    BUILTIN("unfunction", 0, bin_unhash, 1, -1, BIN_UNFUNCTION, "m", "f"),
        -:  129:    BUILTIN("unhash", 0, bin_unhash, 1, -1, BIN_UNHASH, "adfms", NULL),
        -:  130:    BUILTIN("unset", BINF_PSPECIAL, bin_unset, 1, -1, BIN_UNSET, "fmv", NULL),
        -:  131:    BUILTIN("unsetopt", 0, bin_setopt, 0, -1, BIN_UNSETOPT, NULL, NULL),
        -:  132:    BUILTIN("wait", 0, bin_fg, 0, -1, BIN_WAIT, NULL, NULL),
        -:  133:    BUILTIN("whence", 0, bin_whence, 0, -1, 0, "acmpvfsSwx:", NULL),
        -:  134:    BUILTIN("where", 0, bin_whence, 0, -1, 0, "pmsSwx:", "ca"),
        -:  135:    BUILTIN("which", 0, bin_whence, 0, -1, 0, "ampsSwx:", "c"),
        -:  136:    BUILTIN("zmodload", 0, bin_zmodload, 0, -1, 0, "AFRILP:abcfdilmpsue", NULL),
        -:  137:    BUILTIN("zcompile", 0, bin_zcompile, 0, -1, 0, "tUMRcmzka", NULL),
        -:  138:};
        -:  139:
        -:  140:/****************************************/
        -:  141:/* Builtin Command Hash Table Functions */
        -:  142:/****************************************/
        -:  143:
        -:  144:/* hash table containing builtin commands */
        -:  145:
        -:  146:/**/
        -:  147:mod_export HashTable builtintab;
        -:  148:
        -:  149:/**/
        -:  150:void
        7:  151:createbuiltintable(void)
        -:  152:{
        7:  153:    builtintab = newhashtable(85, "builtintab", NULL);
        -:  154:
        7:  155:    builtintab->hash        = hasher;
        7:  156:    builtintab->emptytable  = NULL;
        7:  157:    builtintab->filltable   = NULL;
        7:  158:    builtintab->cmpnodes    = strcmp;
        7:  159:    builtintab->addnode     = addhashnode;
        7:  160:    builtintab->getnode     = gethashnode;
        7:  161:    builtintab->getnode2    = gethashnode2;
        7:  162:    builtintab->removenode  = removehashnode;
        7:  163:    builtintab->disablenode = disablehashnode;
        7:  164:    builtintab->enablenode  = enablehashnode;
        7:  165:    builtintab->freenode    = freebuiltinnode;
        7:  166:    builtintab->printnode   = printbuiltinnode;
        -:  167:
        7:  168:    (void)addbuiltins("zsh", builtins, sizeof(builtins)/sizeof(*builtins));
        7:  169:}
        -:  170:
        -:  171:/* Print a builtin */
        -:  172:
        -:  173:/**/
        -:  174:static void
    #####:  175:printbuiltinnode(HashNode hn, int printflags)
        -:  176:{
    #####:  177:    Builtin bn = (Builtin) hn;
        -:  178:
    #####:  179:    if (printflags & PRINT_WHENCE_WORD) {
    #####:  180:	printf("%s: builtin\n", bn->node.nam);
    #####:  181:	return;
        -:  182:    }
        -:  183:
    #####:  184:    if (printflags & PRINT_WHENCE_CSH) {
    #####:  185:	printf("%s: shell built-in command\n", bn->node.nam);
    #####:  186:	return;
        -:  187:    }
        -:  188:
    #####:  189:    if (printflags & PRINT_WHENCE_VERBOSE) {
    #####:  190:	printf("%s is a shell builtin\n", bn->node.nam);
    #####:  191:	return;
        -:  192:    }
        -:  193:
        -:  194:    /* default is name only */
    #####:  195:    printf("%s\n", bn->node.nam);
        -:  196:}
        -:  197:
        -:  198:/**/
        -:  199:static void
    #####:  200:freebuiltinnode(HashNode hn)
        -:  201:{
    #####:  202:    Builtin bn = (Builtin) hn;
        -:  203:
    #####:  204:    if(!(bn->node.flags & BINF_ADDED)) {
    #####:  205:	zsfree(bn->node.nam);
    #####:  206:	zsfree(bn->optstr);
    #####:  207:	zfree(bn, sizeof(struct builtin));
        -:  208:    }
    #####:  209:}
        -:  210:
        -:  211:/**/
        -:  212:void
        7:  213:init_builtins(void)
        -:  214:{
        7:  215:    if (!EMULATION(EMULATE_ZSH)) {
        4:  216:	HashNode hn = reswdtab->getnode2(reswdtab, "repeat");
        4:  217:	if (hn)
        4:  218:	    reswdtab->disablenode(hn, 0);
        -:  219:    }
        7:  220:}
        -:  221:
        -:  222:/* Make sure we have space for a new option and increment. */
        -:  223:
        -:  224:#define OPT_ALLOC_CHUNK 16
        -:  225:
        -:  226:/**/
        -:  227:static int
      303:  228:new_optarg(Options ops)
        -:  229:{
        -:  230:    /* Argument index must be a non-zero 6-bit number. */
      303:  231:    if (ops->argscount == 63)
    #####:  232:	return 1;
      303:  233:    if (ops->argsalloc == ops->argscount) {
      303:  234:	char **newptr =
      303:  235:	    (char **)zhalloc((ops->argsalloc + OPT_ALLOC_CHUNK) *
        -:  236:			     sizeof(char *));
      303:  237:	if (ops->argsalloc)
    #####:  238:	    memcpy(newptr, ops->args, ops->argsalloc * sizeof(char *));
      303:  239:	ops->args = newptr;
      303:  240:	ops->argsalloc += OPT_ALLOC_CHUNK;
        -:  241:    }
      303:  242:    ops->argscount++;
      303:  243:    return 0;
        -:  244:}
        -:  245:
        -:  246:
        -:  247:/* execute a builtin handler function after parsing the arguments */
        -:  248:
        -:  249:/**/
        -:  250:int
     2464:  251:execbuiltin(LinkList args, LinkList assigns, Builtin bn)
        -:  252:{
        -:  253:    char *pp, *name, *optstr;
     2464:  254:    int flags, argc, execop, xtr = isset(XTRACE);
        -:  255:    struct options ops;
        -:  256:
        -:  257:    /* initialise options structure */
     2464:  258:    memset(ops.ind, 0, MAX_OPS*sizeof(unsigned char));
     2464:  259:    ops.args = NULL;
     2464:  260:    ops.argscount = ops.argsalloc = 0;
        -:  261:
        -:  262:    /* initialize some local variables */
     2464:  263:    name = (char *) ugetnode(args);
        -:  264:
     2464:  265:    if (!bn->handlerfunc) {
        -:  266:	DPUTS(1, "Missing builtin detected too late");
    #####:  267:	deletebuiltin(bn->node.nam);
    #####:  268:	return 1;
        -:  269:    }
        -:  270:    /* get some information about the command */
     2464:  271:    flags = bn->node.flags;
     2464:  272:    optstr = bn->optstr;
        -:  273:
        -:  274:    /* Set up the argument list. */
        -:  275:    /* count the arguments */
     2464:  276:    argc = countlinknodes(args);
        -:  277:
        -:  278:    {
        -:  279:	/*
        -:  280:	 * Keep all arguments, including options, in an array.
        -:  281:	 * We don't actually need the option part of the argument
        -:  282:	 * after option processing, but it makes XTRACE output
        -:  283:	 * much simpler.
        -:  284:	 */
     2464:  285:	VARARR(char *, argarr, argc + 1);
        -:  286:	char **argv;
        -:  287:
        -:  288:	/*
        -:  289:	 * Get the actual arguments, into argv.  Remember argarr
        -:  290:	 * may be an array declaration, depending on the compiler.
        -:  291:	 */
     2464:  292:	argv = argarr;
     2464:  293:	while ((*argv++ = (char *)ugetnode(args)));
     2464:  294:	argv = argarr;
        -:  295:
        -:  296:	/* Sort out the options. */
     2464:  297:	if (optstr) {
     1500:  298:	    char *arg = *argv;
        -:  299:	    int sense; /* 1 for -x, 0 for +x */
        -:  300:	    /* while arguments look like options ... */
     5029:  301:	    while (arg &&
        -:  302:		   /* Must begin with - or maybe + */
     1895:  303:		   ((sense = (*arg == '-')) ||
      678:  304:		    ((flags & BINF_PLUSOPTS) && *arg == '+'))) {
        -:  305:		/* Digits aren't arguments unless the command says they are. */
      734:  306:		if (!(flags & BINF_KEEPNUM) && idigit(arg[1]))
    #####:  307:		    break;
        -:  308:		/* For cd and friends, a single dash is not an option. */
      734:  309:		if ((flags & BINF_SKIPDASH) && !arg[1])
    #####:  310:		    break;
      734:  311:		if ((flags & BINF_DASHDASHVALID) && !strcmp(arg, "--")) {
        -:  312:		    /*
        -:  313:		     * Need to skip this before checking whether this is
        -:  314:		     * really an option.
        -:  315:		     */
    #####:  316:		    argv++;
    #####:  317:		    break;
        -:  318:		}
        -:  319:		/*
        -:  320:		 * Unrecognised options to echo etc. are not really
        -:  321:		 * options.
        -:  322:		 *
        -:  323:		 * Note this flag is not smart enough to handle option
        -:  324:		 * arguments.  In fact, ideally it shouldn't be added
        -:  325:		 * to any new builtins, to preserve standard option
        -:  326:		 * handling as much as possible.
        -:  327:		*/
      734:  328:		if (flags & BINF_SKIPINVALID) {
    #####:  329:		    char *p = arg;
    #####:  330:		    while (*++p && strchr(optstr, (int) *p));
    #####:  331:		    if (*p)
    #####:  332:			break;
        -:  333:		}
        -:  334:		/* handle -- or - (ops.ind['-']), and +
        -:  335:		 * (ops.ind['-'] and ops.ind['+']) */
      734:  336:		if (arg[1] == '-')
       19:  337:		    arg++;
      734:  338:		if (!arg[1]) {
       19:  339:		    ops.ind['-'] = 1;
       19:  340:		    if (!sense)
    #####:  341:			ops.ind['+'] = 1;
        -:  342:		}
        -:  343:		/* save options in ops, as long as they are in bn->optstr */
     2183:  344:		while (*++arg) {
        -:  345:		    char *optptr;
      715:  346:		    if ((optptr = strchr(optstr, execop = (int)*arg))) {
      715:  347:			ops.ind[(int)*arg] = (sense) ? 1 : 2;
      715:  348:			if (optptr[1] == ':') {
      303:  349:			    char *argptr = NULL;
      303:  350:			    if (optptr[2] == ':') {
    #####:  351:				if (arg[1])
    #####:  352:				    argptr = arg+1;
        -:  353:				/* Optional argument in same word*/
      303:  354:			    } else if (optptr[2] == '%') {
        -:  355:				/* Optional numeric argument in same
        -:  356:				 * or next word. */
    #####:  357:				if (arg[1] && idigit(arg[1]))
    #####:  358:				    argptr = arg+1;
    #####:  359:				else if (argv[1] && idigit(*argv[1]))
    #####:  360:				    argptr = arg = *++argv;
        -:  361:			    } else {
        -:  362:				/* Mandatory argument */
      303:  363:				if (arg[1])
    #####:  364:				    argptr = arg+1;
      303:  365:				else if ((arg = *++argv))
      303:  366:				    argptr = arg;
        -:  367:				else {
    #####:  368:				    zwarnnam(name, "argument expected: -%c",
        -:  369:					     execop);
    #####:  370:				    return 1;
        -:  371:				}
        -:  372:			    }
      303:  373:			    if (argptr) {
      303:  374:				if (new_optarg(&ops)) {
    #####:  375:				    zwarnnam(name,
        -:  376:					     "too many option arguments");
    #####:  377:				    return 1;
        -:  378:				}
      303:  379:				ops.ind[execop] |= ops.argscount << 2;
      303:  380:				ops.args[ops.argscount-1] = argptr;
      909:  381:				while (arg[1])
      303:  382:				    arg++;
        -:  383:			    }
        -:  384:			}
        -:  385:		    } else
    #####:  386:			break;
        -:  387:		}
        -:  388:		/* The above loop may have exited on an invalid option.  (We  *
        -:  389:		 * assume that any option requiring metafication is invalid.) */
      734:  390:		if (*arg) {
    #####:  391:		    if(*arg == Meta)
    #####:  392:			*++arg ^= 32;
    #####:  393:		    zwarnnam(name, "bad option: %c%c", "+-"[sense], *arg);
    #####:  394:		    return 1;
        -:  395:		}
      734:  396:		arg = *++argv;
        -:  397:		/* for the "print" builtin, the options after -R are treated as
        -:  398:		   options to "echo" */
      734:  399:		if ((flags & BINF_PRINTOPTS) && ops.ind['R'] &&
    #####:  400:		    !ops.ind['f']) {
    #####:  401:		    optstr = "ne";
    #####:  402:		    flags |= BINF_SKIPINVALID;
        -:  403:		}
        -:  404:		/* the option -- indicates the end of the options */
      734:  405:		if (ops.ind['-'])
       19:  406:		    break;
        -:  407:	    }
     1464:  408:	} else if (!(flags & BINF_HANDLES_OPTS) && *argv &&
      500:  409:		   !strcmp(*argv, "--")) {
    #####:  410:	    ops.ind['-'] = 1;
    #####:  411:	    argv++;
        -:  412:	}
        -:  413:
        -:  414:	/* handle built-in options, for overloaded handler functions */
     2464:  415:	if ((pp = bn->defopts)) {
      154:  416:	    while (*pp) {
        -:  417:		/* only if not already set */
       52:  418:		if (!ops.ind[(int)*pp])
       52:  419:		    ops.ind[(int)*pp] = 1;
       52:  420:		pp++;
        -:  421:	    }
        -:  422:	}
        -:  423:
        -:  424:	/* Fix the argument count by subtracting option arguments */
     2464:  425:	argc -= argv - argarr;
        -:  426:
     2464:  427:	if (errflag) {
    #####:  428:	    errflag &= ~ERRFLAG_ERROR;
    #####:  429:	    return 1;
        -:  430:	}
        -:  431:
        -:  432:	/* check that the argument count lies within the specified bounds */
     2464:  433:	if (argc < bn->minargs || (argc > bn->maxargs && bn->maxargs != -1)) {
    #####:  434:	    zwarnnam(name, (argc < bn->minargs)
        -:  435:		     ? "not enough arguments" : "too many arguments");
    #####:  436:	    return 1;
        -:  437:	}
        -:  438:
        -:  439:	/* display execution trace information, if required */
     2464:  440:	if (xtr) {
        -:  441:	    /* Use full argument list including options for trace output */
    #####:  442:	    char **fullargv = argarr;
    #####:  443:	    printprompt4();
    #####:  444:	    fprintf(xtrerr, "%s", name);
    #####:  445:	    while (*fullargv) {
    #####:  446:	        fputc(' ', xtrerr);
    #####:  447:	        quotedzputs(*fullargv++, xtrerr);
        -:  448:	    }
    #####:  449:	    if (assigns) {
        -:  450:		LinkNode node;
    #####:  451:		for (node = firstnode(assigns); node; incnode(node)) {
    #####:  452:		    Asgment asg = (Asgment)node;
    #####:  453:		    fputc(' ', xtrerr);
    #####:  454:		    quotedzputs(asg->name, xtrerr);
    #####:  455:		    if (asg->flags & ASG_ARRAY) {
    #####:  456:			fprintf(xtrerr, "=(");
    #####:  457:			if (asg->value.array) {
    #####:  458:			    if (asg->flags & ASG_KEY_VALUE) {
        -:  459:				LinkNode keynode, valnode;
    #####:  460:				keynode = firstnode(asg->value.array);
        -:  461:				for (;;) {
    #####:  462:				    if (!keynode)
    #####:  463:					break;
    #####:  464:				    valnode = nextnode(keynode);
    #####:  465:				    if (!valnode)
    #####:  466:					break;
    #####:  467:				    fputc('[', xtrerr);
    #####:  468:				    quotedzputs((char *)getdata(keynode),
        -:  469:						xtrerr);
    #####:  470:				    fprintf(stderr, "]=");
    #####:  471:				    quotedzputs((char *)getdata(valnode),
        -:  472:						xtrerr);
    #####:  473:				    keynode = nextnode(valnode);
        -:  474:				}
        -:  475:			    } else {
        -:  476:				LinkNode arrnode;
    #####:  477:				for (arrnode = firstnode(asg->value.array);
        -:  478:				     arrnode;
    #####:  479:				     incnode(arrnode)) {
    #####:  480:				    fputc(' ', xtrerr);
    #####:  481:				    quotedzputs((char *)getdata(arrnode),
        -:  482:						xtrerr);
        -:  483:				}
        -:  484:			    }
        -:  485:			}
    #####:  486:			fprintf(xtrerr, " )");
    #####:  487:		    } else if (asg->value.scalar) {
    #####:  488:			fputc('=', xtrerr);
    #####:  489:			quotedzputs(asg->value.scalar, xtrerr);
        -:  490:		    }
        -:  491:		}
        -:  492:	    }
    #####:  493:	    fputc('\n', xtrerr);
    #####:  494:	    fflush(xtrerr);
        -:  495:	}
        -:  496:	/* call the handler function, and return its return value */
     2464:  497:	if (flags & BINF_ASSIGN)
        -:  498:	{
        -:  499:	    /*
        -:  500:	     * Takes two sets of arguments.
        -:  501:	     */
      686:  502:	    HandlerFuncAssign assignfunc = (HandlerFuncAssign)bn->handlerfunc;
      686:  503:	    return (*(assignfunc)) (name, argv, assigns, &ops, bn->funcid);
        -:  504:	}
        -:  505:	else
        -:  506:	{
     1778:  507:	    return (*(bn->handlerfunc)) (name, argv, &ops, bn->funcid);
        -:  508:	}
        -:  509:    }
        -:  510:}
        -:  511:
        -:  512:/* Enable/disable an element in one of the internal hash tables.  *
        -:  513: * With no arguments, it lists all the currently enabled/disabled *
        -:  514: * elements in that particular hash table.                        */
        -:  515:
        -:  516:/**/
        -:  517:int
    #####:  518:bin_enable(char *name, char **argv, Options ops, int func)
        -:  519:{
        -:  520:    HashTable ht;
        -:  521:    HashNode hn;
        -:  522:    ScanFunc scanfunc;
        -:  523:    Patprog pprog;
    #####:  524:    int flags1 = 0, flags2 = 0;
    #####:  525:    int match = 0, returnval = 0;
        -:  526:
        -:  527:    /* Find out which hash table we are working with. */
    #####:  528:    if (OPT_ISSET(ops,'p')) {
    #####:  529:	return pat_enables(name, argv, func == BIN_ENABLE);
    #####:  530:    } else if (OPT_ISSET(ops,'f'))
    #####:  531:	ht = shfunctab;
    #####:  532:    else if (OPT_ISSET(ops,'r'))
    #####:  533:	ht = reswdtab;
    #####:  534:    else if (OPT_ISSET(ops,'s'))
    #####:  535:	ht = sufaliastab;
    #####:  536:    else if (OPT_ISSET(ops,'a'))
    #####:  537:	ht = aliastab;
        -:  538:    else
    #####:  539:	ht = builtintab;
        -:  540:
        -:  541:    /* Do we want to enable or disable? */
    #####:  542:    if (func == BIN_ENABLE) {
    #####:  543:	flags2 = DISABLED;
    #####:  544:	scanfunc = ht->enablenode;
        -:  545:    } else {
    #####:  546:	flags1 = DISABLED;
    #####:  547:	scanfunc = ht->disablenode;
        -:  548:    }
        -:  549:
        -:  550:    /* Given no arguments, print the names of the enabled/disabled elements  *
        -:  551:     * in this hash table.  If func == BIN_ENABLE, then scanhashtable will   *
        -:  552:     * print nodes NOT containing the DISABLED flag, else scanhashtable will *
        -:  553:     * print nodes containing the DISABLED flag.                             */
    #####:  554:    if (!*argv) {
    #####:  555:	queue_signals();
    #####:  556:	scanhashtable(ht, 1, flags1, flags2, ht->printnode, 0);
    #####:  557:	unqueue_signals();
    #####:  558:	return 0;
        -:  559:    }
        -:  560:
        -:  561:    /* With -m option, treat arguments as glob patterns. */
    #####:  562:    if (OPT_ISSET(ops,'m')) {
    #####:  563:	for (; *argv; argv++) {
    #####:  564:	    queue_signals();
        -:  565:
        -:  566:	    /* parse pattern */
    #####:  567:	    tokenize(*argv);
    #####:  568:	    if ((pprog = patcompile(*argv, PAT_STATIC, 0)))
    #####:  569:		match += scanmatchtable(ht, pprog, 0, 0, 0, scanfunc, 0);
        -:  570:	    else {
    #####:  571:		untokenize(*argv);
    #####:  572:		zwarnnam(name, "bad pattern : %s", *argv);
    #####:  573:		returnval = 1;
        -:  574:	    }
    #####:  575:	    unqueue_signals();
        -:  576:	}
        -:  577:	/* If we didn't match anything, we return 1. */
    #####:  578:	if (!match)
    #####:  579:	    returnval = 1;
    #####:  580:	return returnval;
        -:  581:    }
        -:  582:
        -:  583:    /* Take arguments literally -- do not glob */
    #####:  584:    queue_signals();
    #####:  585:    for (; *argv; argv++) {
    #####:  586:	if ((hn = ht->getnode2(ht, *argv))) {
    #####:  587:	    scanfunc(hn, 0);
        -:  588:	} else {
    #####:  589:	    zwarnnam(name, "no such hash table element: %s", *argv);
    #####:  590:	    returnval = 1;
        -:  591:	}
        -:  592:    }
    #####:  593:    unqueue_signals();
    #####:  594:    return returnval;
        -:  595:}
        -:  596:
        -:  597:/* set: either set the shell options, or set the shell arguments, *
        -:  598: * or declare an array, or show various things                    */
        -:  599:
        -:  600:/**/
        -:  601:int
    #####:  602:bin_set(char *nam, char **args, UNUSED(Options ops), UNUSED(int func))
        -:  603:{
    #####:  604:    int action, optno, array = 0, hadopt = 0,
    #####:  605:	hadplus = 0, hadend = 0, sort = 0;
    #####:  606:    char **x, *arrayname = NULL;
        -:  607:
        -:  608:    /* Obsolescent sh compatibility: set - is the same as set +xv *
        -:  609:     * and set - args is the same as set +xv -- args              */
    #####:  610:    if (!EMULATION(EMULATE_ZSH) && *args && **args == '-' && !args[0][1]) {
    #####:  611:	dosetopt(VERBOSE, 0, 0, opts);
    #####:  612:	dosetopt(XTRACE, 0, 0, opts);
    #####:  613:	if (!args[1])
    #####:  614:	    return 0;
        -:  615:    }
        -:  616:
        -:  617:    /* loop through command line options (begins with "-" or "+") */
    #####:  618:    while (*args && (**args == '-' || **args == '+')) {
    #####:  619:	action = (**args == '-');
    #####:  620:	hadplus |= !action;
    #####:  621:	if(!args[0][1])
    #####:  622:	    *args = "--";
    #####:  623:	while (*++*args) {
    #####:  624:	    if(**args == Meta)
    #####:  625:		*++*args ^= 32;
    #####:  626:	    if(**args != '-' || action)
    #####:  627:		hadopt = 1;
        -:  628:	    /* The pseudo-option `--' signifies the end of options. */
    #####:  629:	    if (**args == '-') {
    #####:  630:		hadend = 1;
    #####:  631:		args++;
    #####:  632:		goto doneoptions;
    #####:  633:	    } else if (**args == 'o') {
    #####:  634:		if (!*++*args)
    #####:  635:		    args++;
    #####:  636:		if (!*args) {
    #####:  637:		    printoptionstates(hadplus);
    #####:  638:		    inittyptab();
    #####:  639:		    return 0;
        -:  640:		}
    #####:  641:		if(!(optno = optlookup(*args)))
    #####:  642:		    zerrnam(nam, "no such option: %s", *args);
    #####:  643:		else if(dosetopt(optno, action, 0, opts))
    #####:  644:		    zerrnam(nam, "can't change option: %s", *args);
    #####:  645:		break;
    #####:  646:	    } else if(**args == 'A') {
    #####:  647:		if(!*++*args)
    #####:  648:		    args++;
    #####:  649:		array = action ? 1 : -1;
    #####:  650:		arrayname = *args;
    #####:  651:		if (!arrayname)
    #####:  652:		    goto doneoptions;
    #####:  653:		else if  (!isset(KSHARRAYS))
        -:  654:		{
    #####:  655:		    args++;
    #####:  656:		    goto doneoptions;
        -:  657:		}
    #####:  658:		break;
    #####:  659:	    } else if (**args == 's')
    #####:  660:		sort = action ? 1 : -1;
        -:  661:	    else {
    #####:  662:	    	if (!(optno = optlookupc(**args)))
    #####:  663:		    zerrnam(nam, "bad option: -%c", **args);
    #####:  664:		else if(dosetopt(optno, action, 0, opts))
    #####:  665:		    zerrnam(nam, "can't change option: -%c", **args);
        -:  666:	    }
        -:  667:	}
    #####:  668:	args++;
        -:  669:    }
    #####:  670:    if (errflag)
    #####:  671:	return 1;
    #####:  672: doneoptions:
    #####:  673:    inittyptab();
        -:  674:
        -:  675:    /* Show the parameters, possibly with values */
    #####:  676:    queue_signals();
    #####:  677:    if (!arrayname)
        -:  678:    {
    #####:  679:	if (!hadopt && !*args)
    #####:  680:	    scanhashtable(paramtab, 1, 0, 0, paramtab->printnode,
        -:  681:			  hadplus ? PRINT_NAMEONLY : 0);
        -:  682:
    #####:  683:	if (array) {
        -:  684:	    /* display arrays */
    #####:  685:	    scanhashtable(paramtab, 1, PM_ARRAY, 0, paramtab->printnode,
        -:  686:			  hadplus ? PRINT_NAMEONLY : 0);
        -:  687:	}
    #####:  688:	if (!*args && !hadend) {
    #####:  689:	    unqueue_signals();
    #####:  690:	    return 0;
        -:  691:	}
        -:  692:    }
    #####:  693:    if (sort)
    #####:  694:	strmetasort(args, sort < 0 ? SORTIT_BACKWARDS : 0, NULL);
    #####:  695:    if (array) {
        -:  696:	/* create an array with the specified elements */
    #####:  697:	char **a = NULL, **y;
    #####:  698:	int len = arrlen(args);
        -:  699:
    #####:  700:	if (array < 0 && (a = getaparam(arrayname)) && arrlen_gt(a, len)) {
    #####:  701:	    a += len;
    #####:  702:	    len += arrlen(a);
        -:  703:	}
    #####:  704:	for (x = y = zalloc((len + 1) * sizeof(char *)); len--;) {
    #####:  705:	    if (!*args)
    #####:  706:		args = a;
    #####:  707:	    *y++ = ztrdup(*args++);
        -:  708:	}
    #####:  709:	*y++ = NULL;
    #####:  710:	setaparam(arrayname, x);
        -:  711:    } else {
        -:  712:	/* set shell arguments */
    #####:  713:	freearray(pparams);
    #####:  714:	pparams = zarrdup(args);
        -:  715:    }
    #####:  716:    unqueue_signals();
    #####:  717:    return 0;
        -:  718:}
        -:  719:
        -:  720:/**** directory-handling builtins ****/
        -:  721:
        -:  722:/**/
        -:  723:int doprintdir = 0;		/* set in exec.c (for autocd, cdpath, etc.) */
        -:  724:
        -:  725:/* pwd: display the name of the current directory */
        -:  726:
        -:  727:/**/
        -:  728:int
    #####:  729:bin_pwd(UNUSED(char *name), UNUSED(char **argv), Options ops, UNUSED(int func))
        -:  730:{
    #####:  731:    if (OPT_ISSET(ops,'r') || OPT_ISSET(ops,'P') ||
    #####:  732:	(isset(CHASELINKS) && !OPT_ISSET(ops,'L')))
    #####:  733:	printf("%s\n", zgetcwd());
        -:  734:    else {
    #####:  735:	zputs(pwd, stdout);
    #####:  736:	putchar('\n');
        -:  737:    }
    #####:  738:    return 0;
        -:  739:}
        -:  740:
        -:  741:/* the directory stack */
        -:  742:
        -:  743:/**/
        -:  744:mod_export LinkList dirstack;
        -:  745:
        -:  746:/* dirs: list the directory stack, or replace it with a provided list */
        -:  747:
        -:  748:/**/
        -:  749:int
    #####:  750:bin_dirs(UNUSED(char *name), char **argv, Options ops, UNUSED(int func))
        -:  751:{
        -:  752:    LinkList l;
        -:  753:
    #####:  754:    queue_signals();
        -:  755:    /* with -v, -p or no arguments display the directory stack */
    #####:  756:    if (!(*argv || OPT_ISSET(ops,'c')) || OPT_ISSET(ops,'v') ||
    #####:  757:	OPT_ISSET(ops,'p')) {
        -:  758:	LinkNode node;
        -:  759:	char *fmt;
    #####:  760:	int pos = 1;
        -:  761:
        -:  762:	/* with the -v option, display a numbered list, starting at zero */
    #####:  763:	if (OPT_ISSET(ops,'v')) {
    #####:  764:	    printf("0\t");
    #####:  765:	    fmt = "\n%d\t";
        -:  766:	/* with the -p option, display entries one per line */
    #####:  767:	} else if (OPT_ISSET(ops,'p'))
    #####:  768:	    fmt = "\n";
        -:  769:	else
    #####:  770:	    fmt = " ";
    #####:  771:	if (OPT_ISSET(ops,'l'))
    #####:  772:	    zputs(pwd, stdout);
        -:  773:	else
    #####:  774:	    fprintdir(pwd, stdout);
    #####:  775:	for (node = firstnode(dirstack); node; incnode(node)) {
    #####:  776:	    printf(fmt, pos++);
    #####:  777:	    if (OPT_ISSET(ops,'l'))
    #####:  778:		zputs(getdata(node), stdout);
        -:  779:	    else
    #####:  780:		fprintdir(getdata(node), stdout);
        -:  781:
        -:  782:	}
    #####:  783:	unqueue_signals();
    #####:  784:	putchar('\n');
    #####:  785:	return 0;
        -:  786:    }
        -:  787:    /* replace the stack with the specified directories */
    #####:  788:    l = znewlinklist();
    #####:  789:    while (*argv)
    #####:  790:	zaddlinknode(l, ztrdup(*argv++));
    #####:  791:    freelinklist(dirstack, freestr);
    #####:  792:    dirstack = l;
    #####:  793:    unqueue_signals();
    #####:  794:    return 0;
        -:  795:}
        -:  796:
        -:  797:/* cd, chdir, pushd, popd */
        -:  798:
        -:  799:/**/
        -:  800:void
        8:  801:set_pwd_env(void)
        -:  802:{
        -:  803:    Param pm;
        -:  804:
        -:  805:    /* update the PWD and OLDPWD shell parameters */
        -:  806:
        8:  807:    pm = (Param) paramtab->getnode(paramtab, "PWD");
        8:  808:    if (pm && PM_TYPE(pm->node.flags) != PM_SCALAR) {
    #####:  809:	pm->node.flags &= ~PM_READONLY;
    #####:  810:	unsetparam_pm(pm, 0, 1);
        -:  811:    }
        -:  812:
        8:  813:    pm = (Param) paramtab->getnode(paramtab, "OLDPWD");
        8:  814:    if (pm && PM_TYPE(pm->node.flags) != PM_SCALAR) {
    #####:  815:	pm->node.flags &= ~PM_READONLY;
    #####:  816:	unsetparam_pm(pm, 0, 1);
        -:  817:    }
        -:  818:
        8:  819:    assignsparam("PWD", ztrdup(pwd), 0);
        8:  820:    assignsparam("OLDPWD", ztrdup(oldpwd), 0);
        -:  821:
        8:  822:    pm = (Param) paramtab->getnode(paramtab, "PWD");
        8:  823:    if (!(pm->node.flags & PM_EXPORTED))
    #####:  824:	addenv(pm, pwd);
        8:  825:    pm = (Param) paramtab->getnode(paramtab, "OLDPWD");
        8:  826:    if (!(pm->node.flags & PM_EXPORTED))
    #####:  827:	addenv(pm, oldpwd);
        8:  828:}
        -:  829:
        -:  830:/* set if we are resolving links to their true paths */
        -:  831:static int chasinglinks;
        -:  832:
        -:  833:/* The main pwd changing function.  The real work is done by other     *
        -:  834: * functions.  cd_get_dest() does the initial argument processing;     *
        -:  835: * cd_do_chdir() actually changes directory, if possible; cd_new_pwd() *
        -:  836: * does the ancillary processing associated with actually changing    *
        -:  837: * directory.                                                          */
        -:  838:
        -:  839:/**/
        -:  840:int
        1:  841:bin_cd(char *nam, char **argv, Options ops, int func)
        -:  842:{
        -:  843:    LinkNode dir;
        -:  844:
        1:  845:    if (isset(RESTRICTED)) {
    #####:  846:	zwarnnam(nam, "restricted");
    #####:  847:	return 1;
        -:  848:    }
        1:  849:    doprintdir = (doprintdir == -1);
        -:  850:
        2:  851:    chasinglinks = OPT_ISSET(ops,'P') ||
        1:  852:	(isset(CHASELINKS) && !OPT_ISSET(ops,'L'));
        1:  853:    queue_signals();
        1:  854:    zpushnode(dirstack, ztrdup(pwd));
        1:  855:    if (!(dir = cd_get_dest(nam, argv, OPT_ISSET(ops,'s'), func))) {
    #####:  856:	zsfree(getlinknode(dirstack));
    #####:  857:	unqueue_signals();
    #####:  858:	return 1;
        -:  859:    }
        1:  860:    cd_new_pwd(func, dir, OPT_ISSET(ops, 'q'));
        -:  861:
        1:  862:    unqueue_signals();
        1:  863:    return 0;
        -:  864:}
        -:  865:
        -:  866:/* Get directory to chdir to */
        -:  867:
        -:  868:/**/
        -:  869:static LinkNode
        1:  870:cd_get_dest(char *nam, char **argv, int hard, int func)
        -:  871:{
        1:  872:    LinkNode dir = NULL;
        -:  873:    LinkNode target;
        -:  874:    char *dest;
        -:  875:
        1:  876:    if (!argv[0]) {
    #####:  877:	if (func == BIN_POPD && !nextnode(firstnode(dirstack))) {
    #####:  878:	    zwarnnam(nam, "directory stack empty");
    #####:  879:	    return NULL;
        -:  880:	}
    #####:  881:	if (func == BIN_PUSHD && unset(PUSHDTOHOME))
    #####:  882:	    dir = nextnode(firstnode(dirstack));
    #####:  883:	if (dir)
    #####:  884:	    zinsertlinknode(dirstack, dir, getlinknode(dirstack));
    #####:  885:	else if (func != BIN_POPD) {
    #####:  886:	    if (!home) {
    #####:  887:		zwarnnam(nam, "HOME not set");
    #####:  888:		return NULL;
        -:  889:	    }
    #####:  890:	    zpushnode(dirstack, ztrdup(home));
        -:  891:	}
        1:  892:    } else if (!argv[1]) {
        -:  893:	int dd;
        -:  894:	char *end;
        -:  895:
        1:  896:	doprintdir++;
        1:  897:	if (!isset(POSIXCD) && argv[0][1] && (argv[0][0] == '+' || argv[0][0] == '-')
    #####:  898:	    && strspn(argv[0]+1, "0123456789") == strlen(argv[0]+1)) {
    #####:  899:	    dd = zstrtol(argv[0] + 1, &end, 10);
    #####:  900:	    if (*end == '\0') {
    #####:  901:		if ((argv[0][0] == '+') ^ isset(PUSHDMINUS))
    #####:  902:		    for (dir = firstnode(dirstack); dir && dd; dd--, incnode(dir));
        -:  903:		else
    #####:  904:		    for (dir = lastnode(dirstack); dir != (LinkNode) dirstack && dd;
    #####:  905:			 dd--, dir = prevnode(dir));
    #####:  906:		if (!dir || dir == (LinkNode) dirstack) {
    #####:  907:		    zwarnnam(nam, "no such entry in dir stack");
    #####:  908:		    return NULL;
        -:  909:		}
        -:  910:	    }
        -:  911:	}
        1:  912:	if (!dir)
        1:  913:	    zpushnode(dirstack, ztrdup(strcmp(argv[0], "-")
        -:  914:				       ? (doprintdir--, argv[0]) : oldpwd));
        -:  915:    } else {
        -:  916:	char *u, *d;
        -:  917:	int len1, len2, len3;
        -:  918:
    #####:  919:	if (!(u = strstr(pwd, argv[0]))) {
    #####:  920:	    zwarnnam(nam, "string not in pwd: %s", argv[0]);
    #####:  921:	    return NULL;
        -:  922:	}
    #####:  923:	len1 = strlen(argv[0]);
    #####:  924:	len2 = strlen(argv[1]);
    #####:  925:	len3 = u - pwd;
    #####:  926:	d = (char *)zalloc(len3 + len2 + strlen(u + len1) + 1);
    #####:  927:	strncpy(d, pwd, len3);
    #####:  928:	strcpy(d + len3, argv[1]);
    #####:  929:	strcat(d, u + len1);
    #####:  930:	zpushnode(dirstack, d);
    #####:  931:	doprintdir++;
        -:  932:    }
        -:  933:
        1:  934:    target = dir;
        1:  935:    if (func == BIN_POPD) {
    #####:  936:	if (!dir) {
    #####:  937:	    target = dir = firstnode(dirstack);
    #####:  938:	} else if (dir != firstnode(dirstack)) {
    #####:  939:	    return dir;
        -:  940:	}
    #####:  941:	dir = nextnode(dir);
        -:  942:    }
        1:  943:    if (!dir) {
        1:  944:	dir = firstnode(dirstack);
        -:  945:    }
        1:  946:    if (!dir || !getdata(dir)) {
        -:  947:	DPUTS(1, "Directory not set, not detected early enough");
    #####:  948:	return NULL;
        -:  949:    }
        1:  950:    if (!(dest = cd_do_chdir(nam, getdata(dir), hard))) {
    #####:  951:	if (!target)
    #####:  952:	    zsfree(getlinknode(dirstack));
    #####:  953:	if (func == BIN_POPD)
    #####:  954:	    zsfree(remnode(dirstack, dir));
    #####:  955:	return NULL;
        -:  956:    }
        1:  957:    if (dest != (char *)getdata(dir)) {
        1:  958:	zsfree(getdata(dir));
        1:  959:	setdata(dir, dest);
        -:  960:    }
        1:  961:    return target ? target : dir;
        -:  962:}
        -:  963:
        -:  964:/* Change to given directory, if possible.  This function works out  *
        -:  965: * exactly how the directory should be interpreted, including cdpath *
        -:  966: * and CDABLEVARS.  For each possible interpretation of the given    *
        -:  967: * path, this calls cd_try_chdir(), which attempts to chdir to that  *
        -:  968: * particular path.                                                  */
        -:  969:
        -:  970:/**/
        -:  971:static char *
        1:  972:cd_do_chdir(char *cnam, char *dest, int hard)
        -:  973:{
        -:  974:    char **pp, *ret;
        1:  975:    int hasdot = 0, eno = ENOENT;
        -:  976:    /*
        -:  977:     * nocdpath indicates that cdpath should not be used.
        -:  978:     * This is the case iff dest is a relative path
        -:  979:     * whose first segment is . or .., but if the path is
        -:  980:     * absolute then cdpath won't be used anyway.
        -:  981:     */
        -:  982:    int nocdpath;
        -:  983:#ifdef __CYGWIN__
        -:  984:    /*
        -:  985:     * Normalize path under Cygwin to avoid messing with
        -:  986:     * DOS style names with drives in them
        -:  987:     */
        -:  988:    static char buf[PATH_MAX+1];
        -:  989:#ifdef HAVE_CYGWIN_CONV_PATH
        -:  990:    cygwin_conv_path(CCP_WIN_A_TO_POSIX | CCP_RELATIVE, dest, buf,
        -:  991:		     PATH_MAX);
        -:  992:#else
        -:  993:#ifndef _SYS_CYGWIN_H
        -:  994:    void cygwin_conv_to_posix_path(const char *, char *);
        -:  995:#endif
        -:  996:
        -:  997:    cygwin_conv_to_posix_path(dest, buf);
        -:  998:#endif
        -:  999:    dest = buf;
        -: 1000:#endif
        1: 1001:    nocdpath = dest[0] == '.' &&
    #####: 1002:	(dest[1] == '/' || !dest[1] || (dest[1] == '.' &&
    #####: 1003:					(dest[2] == '/' || !dest[2])));
        -: 1004:
        -: 1005:    /*
        -: 1006:     * If we have an absolute path, use it as-is only
        -: 1007:     */
        1: 1008:    if (*dest == '/') {
        1: 1009:	if ((ret = cd_try_chdir(NULL, dest, hard)))
        1: 1010:	    return ret;
    #####: 1011:	zwarnnam(cnam, "%e: %s", errno, dest);
    #####: 1012:	return NULL;
        -: 1013:    }
        -: 1014:
        -: 1015:    /*
        -: 1016:     * If cdpath is being used, check it for ".".
        -: 1017:     * Don't bother doing this if POSIXCD is set, we don't
        -: 1018:     * need to know (though it doesn't actually matter).
        -: 1019:     */
    #####: 1020:    if (!nocdpath && !isset(POSIXCD))
    #####: 1021:	for (pp = cdpath; *pp; pp++)
    #####: 1022:	    if (!(*pp)[0] || ((*pp)[0] == '.' && (*pp)[1] == '\0'))
    #####: 1023:		hasdot = 1;
        -: 1024:    /*
        -: 1025:     * If 
        -: 1026:     * (- there is no . in cdpath
        -: 1027:     *  - or cdpath is not being used)
        -: 1028:     *  - and the POSIXCD option is not set
        -: 1029:     * try the directory as-is (i.e. from .)
        -: 1030:     */
    #####: 1031:    if (!hasdot && !isset(POSIXCD)) {
    #####: 1032:	if ((ret = cd_try_chdir(NULL, dest, hard)))
    #####: 1033:	    return ret;
    #####: 1034:	if (errno != ENOENT)
    #####: 1035:	    eno = errno;
        -: 1036:    }
        -: 1037:    /* if cdpath is being used, try given directory relative to each element in
        -: 1038:       cdpath in turn */
    #####: 1039:    if (!nocdpath)
    #####: 1040:	for (pp = cdpath; *pp; pp++) {
    #####: 1041:	    if ((ret = cd_try_chdir(*pp, dest, hard))) {
    #####: 1042:		if (isset(POSIXCD)) {
        -: 1043:		    /*
        -: 1044:		     * For POSIX we need to print the directory
        -: 1045:		     * any time CDPATH was used, except in the
        -: 1046:		     * special case of an empty segment being
        -: 1047:		     * treated as a ".".
        -: 1048:		     */
    #####: 1049:		    if (**pp)
    #####: 1050:			doprintdir++;
        -: 1051:		}  else {
    #####: 1052:		    if (strcmp(*pp, ".")) {
    #####: 1053:			doprintdir++;
        -: 1054:		    }
        -: 1055:		}
    #####: 1056:		return ret;
        -: 1057:	    }
    #####: 1058:	    if (errno != ENOENT)
    #####: 1059:		eno = errno;
        -: 1060:	}
        -: 1061:    /*
        -: 1062:     * POSIX requires us to check "." after CDPATH rather than before.
        -: 1063:     */
    #####: 1064:    if (isset(POSIXCD)) {
    #####: 1065:	if ((ret = cd_try_chdir(NULL, dest, hard)))
    #####: 1066:	    return ret;
    #####: 1067:	if (errno != ENOENT)
    #####: 1068:	    eno = errno;
        -: 1069:    }
        -: 1070:
        -: 1071:    /* handle the CDABLEVARS option */
    #####: 1072:    if ((ret = cd_able_vars(dest))) {
    #####: 1073:	if ((ret = cd_try_chdir(NULL, ret,hard))) {
    #####: 1074:	    doprintdir++;
    #####: 1075:	    return ret;
        -: 1076:	}
    #####: 1077:	if (errno != ENOENT)
    #####: 1078:	    eno = errno;
        -: 1079:    }
        -: 1080:
        -: 1081:    /* If we got here, it means that we couldn't chdir to any of the
        -: 1082:       multitudinous possible paths allowed by zsh.  We've run out of options!
        -: 1083:       Add more here! */
    #####: 1084:    zwarnnam(cnam, "%e: %s", eno, dest);
    #####: 1085:    return NULL;
        -: 1086:}
        -: 1087:
        -: 1088:/* If the CDABLEVARS option is set, return the new *
        -: 1089: * interpretation of the given path.               */
        -: 1090:
        -: 1091:/**/
        -: 1092:char *
    #####: 1093:cd_able_vars(char *s)
        -: 1094:{
        -: 1095:    char *rest, save;
        -: 1096:
    #####: 1097:    if (isset(CDABLEVARS)) {
    #####: 1098:	for (rest = s; *rest && *rest != '/'; rest++);
    #####: 1099:	save = *rest;
    #####: 1100:	*rest = 0;
    #####: 1101:	s = getnameddir(s);
    #####: 1102:	*rest = save;
        -: 1103:
    #####: 1104:	if (s && *rest)
    #####: 1105:	    s = dyncat(s, rest);
        -: 1106:
    #####: 1107:	return s;
        -: 1108:    }
    #####: 1109:    return NULL;
        -: 1110:}
        -: 1111:
        -: 1112:/* Attempt to change to a single given directory.  The directory,    *
        -: 1113: * for the convenience of the calling function, may be provided in   *
        -: 1114: * two parts, which must be concatenated before attempting to chdir. *
        -: 1115: * Returns NULL if the chdir fails.  If the directory change is      *
        -: 1116: * possible, it is performed, and a pointer to the new full pathname *
        -: 1117: * is returned.                                                      */
        -: 1118:
        -: 1119:/**/
        -: 1120:static char *
        1: 1121:cd_try_chdir(char *pfix, char *dest, int hard)
        -: 1122:{
        -: 1123:    char *buf;
        1: 1124:    int dlen, dochaselinks = 0;
        -: 1125:
        -: 1126:    /* handle directory prefix */
        1: 1127:    if (pfix && *pfix) {
    #####: 1128:	if (*pfix == '/') {
        -: 1129:#ifdef __CYGWIN__
        -: 1130:/* NB: Don't turn "/"+"bin" into "//"+"bin" by mistake!  "//bin" may *
        -: 1131: * not be what user really wants (probably wants "/bin"), but        *
        -: 1132: * "//bin" could be valid too (see fixdir())!  This is primarily for *
        -: 1133: * handling CDPATH correctly.  Likewise for "//"+"bin" not becoming  *
        -: 1134: * "///bin" (aka "/bin").                                            */
        -: 1135:	    int root = pfix[1] == '\0' || (pfix[1] == '/' && pfix[2] == '\0');
        -: 1136:	    buf = tricat(pfix, ( root ? "" : "/" ), dest);
        -: 1137:#else
    #####: 1138:	    buf = tricat(pfix, "/", dest);
        -: 1139:#endif
        -: 1140:	} else {
    #####: 1141:	    int pfl = strlen(pfix);
    #####: 1142:	    dlen = strlen(pwd);
    #####: 1143:	    if (dlen == 1 && *pwd == '/')
    #####: 1144:		dlen = 0;
    #####: 1145:	    buf = zalloc(dlen + pfl + strlen(dest) + 3);
    #####: 1146:	    if (dlen)
    #####: 1147:		strcpy(buf, pwd);
    #####: 1148:	    buf[dlen] = '/';
    #####: 1149:	    strcpy(buf + dlen + 1, pfix);
    #####: 1150:	    buf[dlen + 1 + pfl] = '/';
    #####: 1151:	    strcpy(buf + dlen + pfl + 2, dest);
        -: 1152:	}
        1: 1153:    } else if (*dest == '/')
        1: 1154:	buf = ztrdup(dest);
        -: 1155:    else {
    #####: 1156:	dlen = strlen(pwd);
    #####: 1157:	if (pwd[dlen-1] == '/')
    #####: 1158:	    --dlen;
    #####: 1159:	buf = zalloc(dlen + strlen(dest) + 2);
    #####: 1160:	strcpy(buf, pwd);
    #####: 1161:	buf[dlen] = '/';
    #####: 1162:	strcpy(buf + dlen + 1, dest);
        -: 1163:    }
        -: 1164:
        -: 1165:    /* Normalise path.  See the definition of fixdir() for what this means.
        -: 1166:     * We do not do this if we are chasing links.
        -: 1167:     */
        1: 1168:    if (!chasinglinks)
        1: 1169:	dochaselinks = fixdir(buf);
        -: 1170:    else
    #####: 1171:	unmetafy(buf, &dlen);
        -: 1172:
        -: 1173:    /* We try the full path first.  If that fails, try the
        -: 1174:     * argument to cd relatively.  This is useful if the cwd
        -: 1175:     * or a parent directory is renamed in the interim.
        -: 1176:     */
        1: 1177:    if (lchdir(buf, NULL, hard) &&
    #####: 1178:	(pfix || *dest == '/' || lchdir(unmeta(dest), NULL, hard))) {
    #####: 1179:	free(buf);
    #####: 1180:	return NULL;
        -: 1181:    }
        -: 1182:    /* the chdir succeeded, so decide if we should force links to be chased */
        1: 1183:    if (dochaselinks)
    #####: 1184:	chasinglinks = 1;
        1: 1185:    return metafy(buf, -1, META_NOALLOC);
        -: 1186:}
        -: 1187:
        -: 1188:/* do the extra processing associated with changing directory */
        -: 1189:
        -: 1190:/**/
        -: 1191:static void
        1: 1192:cd_new_pwd(int func, LinkNode dir, int quiet)
        -: 1193:{
        -: 1194:    char *new_pwd, *s;
        -: 1195:    struct stat st1, st2;
        -: 1196:    int dirstacksize;
        -: 1197:
        1: 1198:    if (func == BIN_PUSHD)
    #####: 1199:	rolllist(dirstack, dir);
        1: 1200:    new_pwd = remnode(dirstack, dir);
        -: 1201:
        1: 1202:    if (func == BIN_POPD && firstnode(dirstack)) {
    #####: 1203:	zsfree(new_pwd);
    #####: 1204:	new_pwd = getlinknode(dirstack);
        1: 1205:    } else if (func == BIN_CD && unset(AUTOPUSHD))
        1: 1206:	zsfree(getlinknode(dirstack));
        -: 1207:
        1: 1208:    if (chasinglinks) {
    #####: 1209:	s = findpwd(new_pwd);
    #####: 1210:	if (s) {
    #####: 1211:	    zsfree(new_pwd);
    #####: 1212:	    new_pwd = s;
        -: 1213:	}
        -: 1214:    }
        1: 1215:    if (isset(PUSHDIGNOREDUPS)) {
        -: 1216:	LinkNode n;
    #####: 1217:	for (n = firstnode(dirstack); n; incnode(n)) {
    #####: 1218:	    if (!strcmp(new_pwd, getdata(n))) {
    #####: 1219:		zsfree(remnode(dirstack, n));
    #####: 1220:		break;
        -: 1221:	    }
        -: 1222:	}
        -: 1223:    }
        -: 1224:
        1: 1225:    if (stat(unmeta(new_pwd), &st1) < 0) {
    #####: 1226:	zsfree(new_pwd);
    #####: 1227:	new_pwd = NULL;
    #####: 1228:	new_pwd = metafy(zgetcwd(), -1, META_DUP);
        1: 1229:    } else if (stat(".", &st2) < 0) {
    #####: 1230:	if (chdir(unmeta(new_pwd)) < 0)
    #####: 1231:	    zwarn("unable to chdir(%s): %e", new_pwd, errno);
        1: 1232:    } else if (st1.st_ino != st2.st_ino || st1.st_dev != st2.st_dev) {
    #####: 1233:	if (chasinglinks) {
    #####: 1234:	    zsfree(new_pwd);
    #####: 1235:	    new_pwd = NULL;
    #####: 1236:	    new_pwd = metafy(zgetcwd(), -1, META_DUP);
    #####: 1237:	} else if (chdir(unmeta(new_pwd)) < 0)
    #####: 1238:	    zwarn("unable to chdir(%s): %e", new_pwd, errno);
        -: 1239:    }
        -: 1240:
        -: 1241:    /* shift around the pwd variables, to make oldpwd and pwd relate to the
        -: 1242:       current (i.e. new) pwd */
        1: 1243:    zsfree(oldpwd);
        1: 1244:    oldpwd = pwd;
        1: 1245:    setjobpwd();
        1: 1246:    pwd = new_pwd;
        1: 1247:    set_pwd_env();
        -: 1248:
        1: 1249:    if (isset(INTERACTIVE) || isset(POSIXCD)) {
    #####: 1250:	if (func != BIN_CD && isset(INTERACTIVE)) {
    #####: 1251:            if (unset(PUSHDSILENT) && !quiet)
    #####: 1252:	        printdirstack();
    #####: 1253:	} else if (unset(CDSILENT) && doprintdir) {
    #####: 1254:	    fprintdir(pwd, stdout);
    #####: 1255:	    putchar('\n');
        -: 1256:	}
        -: 1257:    }
        -: 1258:
        -: 1259:    /* execute the chpwd function */
        1: 1260:    fflush(stdout);
        1: 1261:    fflush(stderr);
        1: 1262:    if (!quiet)
        1: 1263:	callhookfunc("chpwd", NULL, 1, NULL);
        -: 1264:
        1: 1265:    dirstacksize = getiparam("DIRSTACKSIZE");
        -: 1266:    /* handle directory stack sizes out of range */
        1: 1267:    if (dirstacksize > 0) {
    #####: 1268:	int remove = countlinknodes(dirstack) -
    #####: 1269:	    (dirstacksize < 2 ? 2 : dirstacksize);
    #####: 1270:	while (remove-- >= 0)
    #####: 1271:	    zsfree(remnode(dirstack, lastnode(dirstack)));
        -: 1272:    }
        1: 1273:}
        -: 1274:
        -: 1275:/* Print the directory stack */
        -: 1276:
        -: 1277:/**/
        -: 1278:static void
    #####: 1279:printdirstack(void)
        -: 1280:{
        -: 1281:    LinkNode node;
        -: 1282:
    #####: 1283:    fprintdir(pwd, stdout);
    #####: 1284:    for (node = firstnode(dirstack); node; incnode(node)) {
    #####: 1285:	putchar(' ');
    #####: 1286:	fprintdir(getdata(node), stdout);
        -: 1287:    }
    #####: 1288:    putchar('\n');
    #####: 1289:}
        -: 1290:
        -: 1291:/* Normalise a path.  Segments consisting of ., and foo/.. *
        -: 1292: * combinations, are removed and the path is unmetafied.
        -: 1293: * Returns 1 if we found a ../ path which should force links to
        -: 1294: * be chased, 0 otherwise.
        -: 1295: */
        -: 1296:
        -: 1297:/**/
        -: 1298:int
        1: 1299:fixdir(char *src)
        -: 1300:{
        1: 1301:    char *dest = src, *d0 = dest;
        -: 1302:#ifdef __CYGWIN__
        -: 1303:    char *s0 = src;
        -: 1304:#endif
        -: 1305:    /* This function is always called with n path containing at
        -: 1306:     * least one slash, either because one was input by the user or
        -: 1307:     * because the caller has prepended either pwd or a cdpath dir.
        -: 1308:     * If asked to make a relative change and pwd is set to ".",
        -: 1309:     * the current directory has been removed out from under us,
        -: 1310:     * so force links to be chased.
        -: 1311:     *
        -: 1312:     * Ordinarily we can't get here with "../" as the first component
        -: 1313:     * but handle the silly special case of ".." in cdpath.
        -: 1314:     *
        -: 1315:     * Order of comparisons here looks funny, but it short-circuits
        -: 1316:     * most rapidly in the event of a false condition.  Set to 2
        -: 1317:     * here so we still obey the (lack of) CHASEDOTS option after
        -: 1318:     * the first "../" is preserved (test chasedots > 1 below).
        -: 1319:     */
        1: 1320:    int chasedots = (src[0] == '.' && pwd[0] == '.' && pwd[1] == '\0' &&
    #####: 1321:		     (src[1] == '/' || (src[1] == '.' && src[2] == '/'))) * 2;
        -: 1322:
        -: 1323:/*** if have RFS superroot directory ***/
        -: 1324:#ifdef HAVE_SUPERROOT
        -: 1325:    /* allow /.. segments to remain */
        -: 1326:    while (*src == '/' && src[1] == '.' && src[2] == '.' &&
        -: 1327:	   (!src[3] || src[3] == '/')) {
        -: 1328:	*dest++ = '/';
        -: 1329:	*dest++ = '.';
        -: 1330:	*dest++ = '.';
        -: 1331:	src += 3;
        -: 1332:    }
        -: 1333:#endif
        -: 1334:
        -: 1335:    for (;;) {
        -: 1336:	/* compress multiple /es into single */
        7: 1337:	if (*src == '/') {
        -: 1338:#ifdef __CYGWIN__
        -: 1339:	    /* allow leading // under cygwin, but /// still becomes / */
        -: 1340:	    if (src == s0 && src[1] == '/' && src[2] != '/')
        -: 1341:		*dest++ = *src++;
        -: 1342:#endif
        3: 1343:	    *dest++ = *src++;
        6: 1344:	    while (*src == '/')
    #####: 1345:		src++;
        -: 1346:	}
        -: 1347:	/* if we are at the end of the input path, remove a trailing / (if it
        -: 1348:	   exists), and return ct */
        4: 1349:	if (!*src) {
        2: 1350:	    while (dest > d0 + 1 && dest[-1] == '/')
    #####: 1351:		dest--;
        1: 1352:	    *dest = '\0';
        1: 1353:	    return chasedots;
        -: 1354:	}
        3: 1355:	if (src[0] == '.' && src[1] == '.' &&
    #####: 1356:	    (src[2] == '\0' || src[2] == '/')) {
    #####: 1357:	    if (isset(CHASEDOTS) || chasedots > 1) {
    #####: 1358:		chasedots = 1;
        -: 1359:		/* and treat as normal path segment */
        -: 1360:	    } else {
    #####: 1361:		if (dest > d0 + 1) {
        -: 1362:		    /*
        -: 1363:		     * remove a foo/.. combination:
        -: 1364:		     * first check foo exists, else return.
        -: 1365:		     */
        -: 1366:		    struct stat st;
    #####: 1367:		    *dest = '\0';
    #####: 1368:		    if (stat(d0, &st) < 0 || !S_ISDIR(st.st_mode)) {
        -: 1369:			char *ptrd, *ptrs;
    #####: 1370:			if (dest == src)
    #####: 1371:			    *dest = '.';
    #####: 1372:			for (ptrs = src, ptrd = dest; *ptrs; ptrs++, ptrd++)
    #####: 1373:			    *ptrd = (*ptrs == Meta) ? (*++ptrs ^ 32) : *ptrs;
    #####: 1374:			*ptrd = '\0';
    #####: 1375:			return 1;
        -: 1376:		    }
    #####: 1377:		    for (dest--; dest > d0 + 1 && dest[-1] != '/'; dest--);
    #####: 1378:		    if (dest[-1] != '/')
    #####: 1379:			dest--;
        -: 1380:		}
    #####: 1381:		src++;
    #####: 1382:		while (*++src == '/');
    #####: 1383:		continue;
        -: 1384:	    }
        -: 1385:	}
        3: 1386:	if (src[0] == '.' && (src[1] == '/' || src[1] == '\0')) {
        -: 1387:	    /* skip a . section */
    #####: 1388:	    while (*++src == '/');
        -: 1389:	} else {
        -: 1390:	    /* copy a normal segment into the output */
       23: 1391:	    while (*src != '/' && *src != '\0')
       17: 1392:		if ((*dest++ = *src++) == Meta)
    #####: 1393:		    dest[-1] = *src++ ^ 32;
        -: 1394:	}
        -: 1395:    }
        -: 1396:    /* unreached */
        -: 1397:}
        -: 1398:
        -: 1399:/**/
        -: 1400:mod_export void
    #####: 1401:printqt(char *str)
        -: 1402:{
        -: 1403:    /* Print str, but turn any single quote into '\'' or ''. */
    #####: 1404:    for (; *str; str++)
    #####: 1405:	if (*str == '\'')
    #####: 1406:	    printf(isset(RCQUOTES) ? "''" : "'\\''");
        -: 1407:	else
    #####: 1408:	    putchar(*str);
    #####: 1409:}
        -: 1410:
        -: 1411:/**/
        -: 1412:mod_export void
    #####: 1413:printif(char *str, int c)
        -: 1414:{
        -: 1415:    /* If flag c has an argument, print that */
    #####: 1416:    if (str) {
    #####: 1417:	printf(" -%c ", c);
    #####: 1418:	quotedzputs(str, stdout);
        -: 1419:    }
    #####: 1420:}
        -: 1421:
        -: 1422:/**** history list functions ****/
        -: 1423:
        -: 1424:/* fc, history, r */
        -: 1425:
        -: 1426:/**/
        -: 1427:int
    #####: 1428:bin_fc(char *nam, char **argv, Options ops, int func)
        -: 1429:{
    #####: 1430:    zlong first = -1, last = -1;
        -: 1431:    int retval;
        -: 1432:    char *s;
    #####: 1433:    struct asgment *asgf = NULL, *asgl = NULL;
    #####: 1434:    Patprog pprog = NULL;
        -: 1435:
        -: 1436:    /* fc is only permitted in interactive shells */
        -: 1437:#ifdef FACIST_INTERACTIVE
        -: 1438:    if (!interact) {
        -: 1439:	zwarnnam(nam, "not interactive shell");
        -: 1440:	return 1;
        -: 1441:    }
        -: 1442:#endif
    #####: 1443:    if (OPT_ISSET(ops,'p')) {
    #####: 1444:	char *hf = "";
    #####: 1445:	zlong hs = DEFAULT_HISTSIZE;
    #####: 1446:	zlong shs = 0;
    #####: 1447:	int level = OPT_ISSET(ops,'a') ? locallevel : -1;
    #####: 1448:	if (*argv) {
    #####: 1449:	    hf = *argv++;
    #####: 1450:	    if (*argv) {
        -: 1451:		char *check;
    #####: 1452:		hs = zstrtol(*argv++, &check, 10);
    #####: 1453:		if (*check) {
    #####: 1454:		    zwarnnam("fc", "HISTSIZE must be an integer");
    #####: 1455:		    return 1;
        -: 1456:		}
    #####: 1457:		if (*argv) {
    #####: 1458:		    shs = zstrtol(*argv++, &check, 10);
    #####: 1459:		    if (*check) {
    #####: 1460:			zwarnnam("fc", "SAVEHIST must be an integer");
    #####: 1461:			return 1;
        -: 1462:		    }
        -: 1463:		} else
    #####: 1464:		    shs = hs;
    #####: 1465:		if (*argv) {
    #####: 1466:		    zwarnnam("fc", "too many arguments");
    #####: 1467:		    return 1;
        -: 1468:		}
        -: 1469:	    } else {
    #####: 1470:		hs = histsiz;
    #####: 1471:		shs = savehistsiz;
        -: 1472:	    }
        -: 1473:	}
    #####: 1474:	if (!pushhiststack(hf, hs, shs, level))
    #####: 1475:	    return 1;
    #####: 1476:	if (*hf) {
        -: 1477:	    struct stat st;
    #####: 1478:	    if (stat(hf, &st) >= 0 || errno != ENOENT)
    #####: 1479:		readhistfile(hf, 1, HFILE_USE_OPTIONS);
        -: 1480:	}
    #####: 1481:	return 0;
        -: 1482:    }
    #####: 1483:    if (OPT_ISSET(ops,'P')) {
    #####: 1484:	if (*argv) {
    #####: 1485:	    zwarnnam("fc", "too many arguments");
    #####: 1486:	    return 1;
        -: 1487:	}
    #####: 1488:	return !saveandpophiststack(-1, HFILE_USE_OPTIONS);
        -: 1489:    }
        -: 1490:    /* with the -m option, the first argument is taken *
        -: 1491:     * as a pattern that history lines have to match   */
    #####: 1492:    if (*argv && OPT_ISSET(ops,'m')) {
    #####: 1493:	tokenize(*argv);
    #####: 1494:	if (!(pprog = patcompile(*argv++, 0, NULL))) {
    #####: 1495:	    zwarnnam(nam, "invalid match pattern");
    #####: 1496:	    return 1;
        -: 1497:	}
        -: 1498:    }
    #####: 1499:    queue_signals();
    #####: 1500:    if (OPT_ISSET(ops,'R')) {
        -: 1501:	/* read history from a file */
    #####: 1502:	readhistfile(*argv, 1, OPT_ISSET(ops,'I') ? HFILE_SKIPOLD : 0);
    #####: 1503:	unqueue_signals();
    #####: 1504:	return 0;
        -: 1505:    }
    #####: 1506:    if (OPT_ISSET(ops,'W')) {
        -: 1507:	/* write history to a file */
    #####: 1508:	savehistfile(*argv, 1, OPT_ISSET(ops,'I') ? HFILE_SKIPOLD : 0);
    #####: 1509:	unqueue_signals();
    #####: 1510:	return 0;
        -: 1511:    }
    #####: 1512:    if (OPT_ISSET(ops,'A')) {
        -: 1513:	/* append history to a file */
    #####: 1514:	savehistfile(*argv, 1, HFILE_APPEND |
    #####: 1515:		     (OPT_ISSET(ops,'I') ? HFILE_SKIPOLD : 0));
    #####: 1516:	unqueue_signals();
    #####: 1517:	return 0;
        -: 1518:    }
        -: 1519:
    #####: 1520:    if (zleactive) {
    #####: 1521:	unqueue_signals();
    #####: 1522:	zwarnnam(nam, "no interactive history within ZLE");
    #####: 1523:	return 1;
        -: 1524:    }
        -: 1525:
        -: 1526:    /* put foo=bar type arguments into the substitution list */
    #####: 1527:    while (*argv && equalsplit(*argv, &s)) {
    #####: 1528:	Asgment a = (Asgment) zhalloc(sizeof *a);
        -: 1529:
    #####: 1530:	if (!**argv) {
    #####: 1531:	    zwarnnam(nam, "invalid replacement pattern: =%s", s);
    #####: 1532:	    return 1;
        -: 1533:	}
    #####: 1534:	if (!asgf)
    #####: 1535:	    asgf = asgl = a;
        -: 1536:	else {
    #####: 1537:	    asgl->node.next = &a->node;
    #####: 1538:	    asgl = a;
        -: 1539:	}
    #####: 1540:	a->name = *argv;
    #####: 1541:	a->flags = 0;
    #####: 1542:	a->value.scalar = s;
    #####: 1543:	a->node.next = a->node.prev = NULL;
    #####: 1544:	argv++;
        -: 1545:    }
        -: 1546:    /* interpret and check first history line specifier */
    #####: 1547:    if (*argv) {
    #####: 1548:	first = fcgetcomm(*argv);
    #####: 1549:	if (first == -1) {
    #####: 1550:	    unqueue_signals();
    #####: 1551:	    return 1;
        -: 1552:	}
    #####: 1553:	argv++;
        -: 1554:    }
        -: 1555:    /* interpret and check second history line specifier */
    #####: 1556:    if (*argv) {
    #####: 1557:	last = fcgetcomm(*argv);
    #####: 1558:	if (last == -1) {
    #####: 1559:	    unqueue_signals();
    #####: 1560:	    return 1;
        -: 1561:	}
    #####: 1562:	argv++;
        -: 1563:    }
        -: 1564:    /* There is a maximum of two history specifiers.  At least, there *
        -: 1565:     * will be as long as the history list is one-dimensional.        */
    #####: 1566:    if (*argv) {
    #####: 1567:	unqueue_signals();
    #####: 1568:	zwarnnam("fc", "too many arguments");
    #####: 1569:	return 1;
        -: 1570:    }
        -: 1571:    /* default values of first and last, and range checking */
    #####: 1572:    if (last == -1) {
    #####: 1573:	if (OPT_ISSET(ops,'l') && first < curhist) {
        -: 1574:	    /*
        -: 1575:	     * When listing base our calculations on curhist,
        -: 1576:	     * to show anything added since the edited history line.
        -: 1577:	     * Also, in that case curhist will have been modified
        -: 1578:	     * past the current history line; then we want to
        -: 1579:	     * show everything, because the user expects to
        -: 1580:	     * see the result of "print -s".  Otherwise, we subtract
        -: 1581:	     * -1 from the line, because the user doesn't usually expect
        -: 1582:	     * to see the command line that caused history to be
        -: 1583:	     * listed.
        -: 1584:	     */
    #####: 1585:	    last = (curline.histnum == curhist) ? addhistnum(curhist,-1,0)
    #####: 1586:		: curhist;
    #####: 1587:	    if (last < firsthist())
    #####: 1588:		last = firsthist();
        -: 1589:	}
        -: 1590:	else
    #####: 1591:	    last = first;
        -: 1592:    }
    #####: 1593:    if (first == -1) {
        -: 1594:	/*
        -: 1595:	 * When listing, we want to see everything that's been
        -: 1596:	 * added to the history, including by print -s, so use
        -: 1597:	 * curhist.
        -: 1598:	 * When reexecuting, we want to restrict to the last edited
        -: 1599:	 * command line to avoid giving the user a nasty turn
        -: 1600:	 * if some helpful soul ran "print -s 'rm -rf /'".
        -: 1601:	 */
    #####: 1602:	int xflags = OPT_ISSET(ops,'L') ? HIST_FOREIGN : 0;
    #####: 1603:	first = OPT_ISSET(ops,'l')? addhistnum(curhist,-16,xflags)
    #####: 1604:			: addhistnum(curline.histnum,-1,xflags);
    #####: 1605:	if (first < 1)
    #####: 1606:	    first = 1;
    #####: 1607:	if (last < first)
    #####: 1608:	    last = first;
        -: 1609:    }
    #####: 1610:    if (OPT_ISSET(ops,'l')) {
        -: 1611:	/* list the required part of the history */
    #####: 1612:	retval = fclist(stdout, ops, first, last, asgf, pprog, 0);
    #####: 1613:	unqueue_signals();
        -: 1614:    }
        -: 1615:    else {
        -: 1616:	/* edit history file, and (if successful) use the result as a new command */
        -: 1617:	int tempfd;
        -: 1618:	FILE *out;
        -: 1619:	char *fil;
        -: 1620:
    #####: 1621:	retval = 1;
    #####: 1622:	if ((tempfd = gettempfile(NULL, 1, &fil)) < 0
    #####: 1623:	 || ((out = fdopen(tempfd, "w")) == NULL)) {
    #####: 1624:	    unqueue_signals();
    #####: 1625:	    zwarnnam("fc", "can't open temp file: %e", errno);
        -: 1626:	} else {
        -: 1627:	    /*
        -: 1628:	     * Nasty behaviour results if we use the current history
        -: 1629:	     * line here.  Treat it as if it doesn't exist, unless
        -: 1630:	     * that gives us an empty range.
        -: 1631:	     */
    #####: 1632:	    if (last >= curhist) {
    #####: 1633:		last = curhist - 1;
    #####: 1634:		if (first > last) {
    #####: 1635:		    unqueue_signals();
    #####: 1636:		    zwarnnam("fc",
        -: 1637:		      "current history line would recurse endlessly, aborted");
    #####: 1638:		    fclose(out);
    #####: 1639:		    unlink(fil);
    #####: 1640:		    return 1;
        -: 1641:		}
        -: 1642:	    }
    #####: 1643:	    ops->ind['n'] = 1;	/* No line numbers here. */
    #####: 1644:	    if (!fclist(out, ops, first, last, asgf, pprog, 1)) {
        -: 1645:		char *editor;
        -: 1646:
    #####: 1647:		if (func == BIN_R || OPT_ISSET(ops, 's'))
    #####: 1648:		    editor = "-";
    #####: 1649:		else if (OPT_HASARG(ops, 'e'))
    #####: 1650:		    editor = OPT_ARG(ops, 'e');
        -: 1651:		else
    #####: 1652:		    editor = getsparam("FCEDIT");
    #####: 1653:		if (!editor)
    #####: 1654:		    editor = getsparam("EDITOR");
    #####: 1655:		if (!editor)
    #####: 1656:		    editor = DEFAULT_FCEDIT;
        -: 1657:
    #####: 1658:		unqueue_signals();
    #####: 1659:		if (fcedit(editor, fil)) {
    #####: 1660:		    if (stuff(fil))
    #####: 1661:			zwarnnam("fc", "%e: %s", errno, fil);
        -: 1662:		    else {
    #####: 1663:			loop(0,1);
    #####: 1664:			retval = lastval;
        -: 1665:		    }
        -: 1666:		}
        -: 1667:	    } else
    #####: 1668:		unqueue_signals();
        -: 1669:	}
    #####: 1670:	unlink(fil);
        -: 1671:    }
    #####: 1672:    return retval;
        -: 1673:}
        -: 1674:
        -: 1675:/* History handling functions: these are called by ZLE, as well as  *
        -: 1676: * the actual builtins.  fcgetcomm() gets a history line, specified *
        -: 1677: * either by number or leading string.  fcsubs() performs a given   *
        -: 1678: * set of simple old=new substitutions on a given command line.     *
        -: 1679: * fclist() outputs a given range of history lines to a text file.  */
        -: 1680:
        -: 1681:/* get the history event associated with s */
        -: 1682:
        -: 1683:/**/
        -: 1684:static zlong
    #####: 1685:fcgetcomm(char *s)
        -: 1686:{
        -: 1687:    zlong cmd;
        -: 1688:
        -: 1689:    /* First try to match a history number.  Negative *
        -: 1690:     * numbers indicate reversed numbering.           */
    #####: 1691:    if ((cmd = atoi(s)) != 0 || *s == '0') {
    #####: 1692:	if (cmd < 0)
    #####: 1693:	    cmd = addhistnum(curline.histnum,cmd,HIST_FOREIGN);
    #####: 1694:	if (cmd < 0)
    #####: 1695:	    cmd = 0;
    #####: 1696:	return cmd;
        -: 1697:    }
        -: 1698:    /* not a number, so search by string */
    #####: 1699:    cmd = hcomsearch(s);
    #####: 1700:    if (cmd == -1)
    #####: 1701:	zwarnnam("fc", "event not found: %s", s);
    #####: 1702:    return cmd;
        -: 1703:}
        -: 1704:
        -: 1705:/* Perform old=new substitutions.  Uses the asgment structure from zsh.h, *
        -: 1706: * which is essentially a linked list of string,replacement pairs.       */
        -: 1707:
        -: 1708:/**/
        -: 1709:static int
    #####: 1710:fcsubs(char **sp, struct asgment *sub)
        -: 1711:{
    #####: 1712:    char *oldstr, *newstr, *oldpos, *newpos, *newmem, *s = *sp;
    #####: 1713:    int subbed = 0;
        -: 1714:
        -: 1715:    /* loop through the linked list */
    #####: 1716:    while (sub) {
    #####: 1717:	oldstr = sub->name;
    #####: 1718:	newstr = sub->value.scalar;
    #####: 1719:	sub = (Asgment)sub->node.next;
    #####: 1720:	oldpos = s;
        -: 1721:	/* loop over occurrences of oldstr in s, replacing them with newstr */
    #####: 1722:	while ((newpos = (char *)strstr(oldpos, oldstr))) {
    #####: 1723:	    newmem = (char *) zhalloc(1 + (newpos - s)
    #####: 1724:				      + strlen(newstr) + strlen(newpos + strlen(oldstr)));
    #####: 1725:	    ztrncpy(newmem, s, newpos - s);
    #####: 1726:	    strcat(newmem, newstr);
    #####: 1727:	    oldpos = newmem + strlen(newmem);
    #####: 1728:	    strcat(newmem, newpos + strlen(oldstr));
    #####: 1729:	    s = newmem;
    #####: 1730:	    subbed = 1;
        -: 1731:	}
        -: 1732:    }
    #####: 1733:    *sp = s;
    #####: 1734:    return subbed;
        -: 1735:}
        -: 1736:
        -: 1737:/* Print a series of history events to a file.  The file pointer is     *
        -: 1738: * given by f, and the required range of events by first and last.      *
        -: 1739: * subs is an optional list of foo=bar substitutions to perform on the  *
        -: 1740: * history lines before output.  com is an optional comp structure      *
        -: 1741: * that the history lines are required to match.  n, r, D and d are     *
        -: 1742: * options: n indicates that each line should be numbered.  r indicates *
        -: 1743: * that the lines should be output in reverse order (newest first).     *
        -: 1744: * D indicates that the real time taken by each command should be       *
        -: 1745: * output.  d indicates that the time of execution of each command      *
        -: 1746: * should be output; d>1 means that the date should be output too; d>3  *
        -: 1747: * means that mm/dd/yyyy form should be used for the dates, as opposed  *
        -: 1748: * to dd.mm.yyyy form; d>7 means that yyyy-mm-dd form should be used.   */
        -: 1749:
        -: 1750:/**/
        -: 1751:static int
    #####: 1752:fclist(FILE *f, Options ops, zlong first, zlong last,
        -: 1753:       struct asgment *subs, Patprog pprog, int is_command)
        -: 1754:{
    #####: 1755:    int fclistdone = 0, xflags = 0;
        -: 1756:    zlong tmp;
        -: 1757:    char *s, *tdfmt, *timebuf;
        -: 1758:    Histent ent;
        -: 1759:
        -: 1760:    /* reverse range if required */
    #####: 1761:    if (OPT_ISSET(ops,'r')) {
    #####: 1762:	tmp = last;
    #####: 1763:	last = first;
    #####: 1764:	first = tmp;
        -: 1765:    }
    #####: 1766:    if (is_command && first > last) {
    #####: 1767:	zwarnnam("fc", "history events can't be executed backwards, aborted");
    #####: 1768:	if (f != stdout)
    #####: 1769:	    fclose(f);
    #####: 1770:	return 1;
        -: 1771:    }
        -: 1772:
    #####: 1773:    ent = gethistent(first, first < last? GETHIST_DOWNWARD : GETHIST_UPWARD);
    #####: 1774:    if (!ent || (first < last? ent->histnum > last : ent->histnum < last)) {
    #####: 1775:	if (first == last) {
        -: 1776:	    char buf[DIGBUFSIZE];
    #####: 1777:	    convbase(buf, first, 10);
    #####: 1778:	    zwarnnam("fc", "no such event: %s", buf);
        -: 1779:	} else
    #####: 1780:	    zwarnnam("fc", "no events in that range");
    #####: 1781:	if (f != stdout)
    #####: 1782:	    fclose(f);
    #####: 1783:	return 1;
        -: 1784:    }
        -: 1785:
    #####: 1786:    if (OPT_ISSET(ops,'d') || OPT_ISSET(ops,'f') ||
    #####: 1787:	OPT_ISSET(ops,'E') || OPT_ISSET(ops,'i') ||
    #####: 1788:	OPT_ISSET(ops,'t')) {
    #####: 1789:	if (OPT_ISSET(ops,'t')) {
    #####: 1790:	    tdfmt = OPT_ARG(ops,'t');
    #####: 1791:	} else if (OPT_ISSET(ops,'i')) {
    #####: 1792:	    tdfmt = "%Y-%m-%d %H:%M";
    #####: 1793:	} else if (OPT_ISSET(ops,'E')) {
    #####: 1794:	    tdfmt = "%f.%-m.%Y %H:%M";
    #####: 1795:	} else if (OPT_ISSET(ops,'f')) {
    #####: 1796:	    tdfmt = "%-m/%f/%Y %H:%M";
        -: 1797:	} else {
    #####: 1798:	    tdfmt = "%H:%M";
        -: 1799:	}
    #####: 1800:	timebuf = zhalloc(256);
        -: 1801:    } else {
    #####: 1802:	tdfmt = timebuf = NULL;
        -: 1803:    }
        -: 1804:
        -: 1805:    /* xflags exclude events */
    #####: 1806:    if (OPT_ISSET(ops,'L')) {
    #####: 1807:	xflags |= HIST_FOREIGN;
        -: 1808:    }
    #####: 1809:    if (OPT_ISSET(ops,'I')) {
    #####: 1810:	xflags |= HIST_READ;
        -: 1811:    }
        -: 1812:
        -: 1813:    for (;;) {
    #####: 1814:	if (ent->node.flags & xflags)
    #####: 1815:	    s = NULL;
        -: 1816:	else
    #####: 1817:	    s = dupstring(ent->node.nam);
        -: 1818:	/* this if does the pattern matching, if required */
    #####: 1819:	if (s && (!pprog || pattry(pprog, s))) {
        -: 1820:	    /* perform substitution */
    #####: 1821:	    fclistdone |= (subs ? fcsubs(&s, subs) : 1);
        -: 1822:
        -: 1823:	    /* do numbering */
    #####: 1824:	    if (!OPT_ISSET(ops,'n')) {
        -: 1825:		char buf[DIGBUFSIZE];
    #####: 1826:		convbase(buf, ent->histnum, 10);
    #####: 1827:		fprintf(f, "%5s%c ", buf,
    #####: 1828:			ent->node.flags & HIST_FOREIGN ? '*' : ' ');
        -: 1829:	    }
        -: 1830:	    /* output actual time (and possibly date) of execution of the
        -: 1831:	       command, if required */
    #####: 1832:	    if (tdfmt != NULL) {
        -: 1833:		struct tm *ltm;
        -: 1834:		int len;
    #####: 1835:		ltm = localtime(&ent->stim);
    #####: 1836:		if ((len = ztrftime(timebuf, 256, tdfmt, ltm, 0L)) >= 0) {
    #####: 1837:		    fwrite(timebuf, 1, len, f);
    #####: 1838:		    fprintf(f, "  ");
        -: 1839:		}
        -: 1840:	    }
        -: 1841:	    /* display the time taken by the command, if required */
    #####: 1842:	    if (OPT_ISSET(ops,'D')) {
        -: 1843:		long diff;
    #####: 1844:		diff = (ent->ftim) ? ent->ftim - ent->stim : 0;
    #####: 1845:		fprintf(f, "%ld:%02ld  ", diff / 60, diff % 60);
        -: 1846:	    }
        -: 1847:
        -: 1848:	    /* output the command */
    #####: 1849:	    if (f == stdout) {
    #####: 1850:		nicezputs(s, f);
    #####: 1851:		putc('\n', f);
        -: 1852:	    } else {
        -: 1853:		int len;
    #####: 1854:		unmetafy(s, &len);
    #####: 1855:		fwrite(s, 1, len, f);
    #####: 1856:		putc('\n', f);
        -: 1857:	    }
        -: 1858:	}
        -: 1859:	/* move on to the next history line, or quit the loop */
    #####: 1860:	if (first < last) {
    #####: 1861:	    if (!(ent = down_histent(ent)) || ent->histnum > last)
        -: 1862:		break;
        -: 1863:	}
        -: 1864:	else {
    #####: 1865:	    if (!(ent = up_histent(ent)) || ent->histnum < last)
        -: 1866:		break;
        -: 1867:	}
        -: 1868:    }
        -: 1869:
        -: 1870:    /* final processing */
    #####: 1871:    if (f != stdout)
    #####: 1872:	fclose(f);
    #####: 1873:    if (!fclistdone) {
    #####: 1874:	if (subs)
    #####: 1875:	    zwarnnam("fc", "no substitutions performed");
    #####: 1876:	else if (xflags || pprog)
    #####: 1877:	    zwarnnam("fc", "no matching events found");
    #####: 1878:	return 1;
        -: 1879:    }
    #####: 1880:    return 0;
        -: 1881:}
        -: 1882:
        -: 1883:/* edit a history file */
        -: 1884:
        -: 1885:/**/
        -: 1886:static int
    #####: 1887:fcedit(char *ename, char *fn)
        -: 1888:{
        -: 1889:    char *s;
        -: 1890:
    #####: 1891:    if (!strcmp(ename, "-"))
    #####: 1892:	return 1;
        -: 1893:
    #####: 1894:    s = tricat(ename, " ", fn);
    #####: 1895:    execstring(s, 1, 0, "fc");
    #####: 1896:    zsfree(s);
        -: 1897:
    #####: 1898:    return !lastval;
        -: 1899:}
        -: 1900:
        -: 1901:/**** parameter builtins ****/
        -: 1902:
        -: 1903:/* Separate an argument into name=value parts, returning them in an     *
        -: 1904: * asgment structure.  Because the asgment structure used is global,    *
        -: 1905: * only one of these can be active at a time.  The string s gets placed *
        -: 1906: * in this global structure, so it needs to be in permanent memory.     */
        -: 1907:
        -: 1908:/**/
        -: 1909:static Asgment
     1452: 1910:getasg(char ***argvp, LinkList assigns)
        -: 1911:{
     1452: 1912:    char *s = **argvp;
        -: 1913:    static struct asgment asg;
        -: 1914:
        -: 1915:    /* sanity check for valid argument */
     1452: 1916:    if (!s) {
     1298: 1917:	if (assigns) {
     1202: 1918:	    Asgment asgp = (Asgment)firstnode(assigns);
     1202: 1919:	    if (!asgp)
      590: 1920:		return NULL;
      612: 1921:	    (void)uremnode(assigns, &asgp->node);
      612: 1922:	    return asgp;
        -: 1923:	}
       96: 1924:	return NULL;
        -: 1925:    }
        -: 1926:
        -: 1927:    /* check if name is empty */
      154: 1928:    if (*s == '=') {
    #####: 1929:	zerr("bad assignment");
    #####: 1930:	return NULL;
        -: 1931:    }
      154: 1932:    asg.name = s;
      154: 1933:    asg.flags = 0;
        -: 1934:
        -: 1935:    /* search for `=' */
      154: 1936:    for (; *s && *s != '='; s++);
        -: 1937:
        -: 1938:    /* found `=', so return with a value */
      154: 1939:    if (*s) {
    #####: 1940:	*s = '\0';
    #####: 1941:	asg.value.scalar = s + 1;
        -: 1942:    } else {
        -: 1943:	/* didn't find `=', so we only have a name */
      154: 1944:	asg.value.scalar = NULL;
        -: 1945:    }
      154: 1946:    (*argvp)++;
      154: 1947:    return &asg;
        -: 1948:}
        -: 1949:
        -: 1950:/* for new special parameters */
        -: 1951:enum {
        -: 1952:    NS_NONE,
        -: 1953:    NS_NORMAL,
        -: 1954:    NS_SECONDS
        -: 1955:};
        -: 1956:
        -: 1957:static const struct gsu_scalar tiedarr_gsu =
        -: 1958:{ tiedarrgetfn, tiedarrsetfn, tiedarrunsetfn };
        -: 1959:
        -: 1960:/* Install a base if we are turning on a numeric option with an argument */
        -: 1961:
        -: 1962:static int
       92: 1963:typeset_setbase(const char *name, Param pm, Options ops, int on, int always)
        -: 1964:{
       92: 1965:    char *arg = NULL;
        -: 1966:
       92: 1967:    if ((on & PM_INTEGER) && OPT_HASARG(ops,'i'))
    #####: 1968:	arg = OPT_ARG(ops,'i');
       92: 1969:    else if ((on & PM_EFLOAT) && OPT_HASARG(ops,'E'))
    #####: 1970:	arg = OPT_ARG(ops,'E');
       92: 1971:    else if ((on & PM_FFLOAT) && OPT_HASARG(ops,'F'))
    #####: 1972:	arg = OPT_ARG(ops,'F');
        -: 1973:
       92: 1974:    if (arg) {
        -: 1975:	char *eptr;
    #####: 1976:	int base = (int)zstrtol(arg, &eptr, 10);
    #####: 1977:	if (*eptr) {
    #####: 1978:	    if (on & PM_INTEGER)
    #####: 1979:		zwarnnam(name, "bad base value: %s", arg);
        -: 1980:	    else
    #####: 1981:		zwarnnam(name, "bad precision value: %s", arg);
    #####: 1982:	    return 1;
        -: 1983:	}
    #####: 1984:	if ((on & PM_INTEGER) && (base < 2 || base > 36)) {
    #####: 1985:	    zwarnnam(name, "invalid base (must be 2 to 36 inclusive): %d",
        -: 1986:		     base);
    #####: 1987:	    return 1;
        -: 1988:	}
    #####: 1989:	pm->base = base;
       92: 1990:    } else if (always)
    #####: 1991:	pm->base = 0;
        -: 1992:
       92: 1993:    return 0;
        -: 1994:}
        -: 1995:
        -: 1996:/* Install a width if we are turning on a padding option with an argument */
        -: 1997:
        -: 1998:static int
    #####: 1999:typeset_setwidth(const char * name, Param pm, Options ops, int on, int always)
        -: 2000:{
    #####: 2001:    char *arg = NULL;
        -: 2002:
    #####: 2003:    if ((on & PM_LEFT) && OPT_HASARG(ops,'L'))
    #####: 2004:	arg = OPT_ARG(ops,'L');
    #####: 2005:    else if ((on & PM_RIGHT_B) && OPT_HASARG(ops,'R'))
    #####: 2006:	arg = OPT_ARG(ops,'R');
    #####: 2007:    else if ((on & PM_RIGHT_Z) && OPT_HASARG(ops,'Z'))
    #####: 2008:	arg = OPT_ARG(ops,'Z');
        -: 2009:
    #####: 2010:    if (arg) {
        -: 2011:	char *eptr;
    #####: 2012:	pm->width = (int)zstrtol(arg, &eptr, 10);
    #####: 2013:	if (*eptr) {
    #####: 2014:	    zwarnnam(name, "bad width value: %s", arg);
    #####: 2015:	    return 1;
        -: 2016:	}
    #####: 2017:    } else if (always)
    #####: 2018:	pm->width = 0;
        -: 2019:
    #####: 2020:    return 0;
        -: 2021:}
        -: 2022:
        -: 2023:/* function to set a single parameter */
        -: 2024:
        -: 2025:/**/
        -: 2026:static Param
      766: 2027:typeset_single(char *cname, char *pname, Param pm, int func,
        -: 2028:	       int on, int off, int roff, Asgment asg, Param altpm,
        -: 2029:	       Options ops, int joinchar)
        -: 2030:{
      766: 2031:    int usepm, tc, keeplocal = 0, newspecial = NS_NONE, readonly, dont_set = 0;
        -: 2032:    char *subscript;
        -: 2033:
        -: 2034:    /*
        -: 2035:     * Do we use the existing pm?  Note that this isn't the end of the
        -: 2036:     * story, because if we try and create a new pm at the same
        -: 2037:     * locallevel as an unset one we use the pm struct anyway: that's
        -: 2038:     * handled in createparam().  Here we just avoid using it for the
        -: 2039:     * present tests if it's unset.
        -: 2040:     *
        -: 2041:     * POSIXBUILTINS horror: we need to retain the 'readonly' or 'export'
        -: 2042:     * flags of an unset parameter.
        -: 2043:     */
     1110: 2044:    usepm = pm && (!(pm->node.flags & PM_UNSET) ||
    #####: 2045:		   (isset(POSIXBUILTINS) &&
    #####: 2046:		    (pm->node.flags & (PM_READONLY|PM_EXPORTED))));
        -: 2047:
        -: 2048:    /*
        -: 2049:     * We need to compare types with an existing pm if special,
        -: 2050:     * even if that's unset
        -: 2051:     */
      766: 2052:    if (!usepm && pm && (pm->node.flags & PM_SPECIAL))
    #####: 2053:	usepm = 2;	/* indicate that we preserve the PM_UNSET flag */
        -: 2054:
        -: 2055:    /*
        -: 2056:     * Don't use an existing param if
        -: 2057:     *   - the local level has changed, and
        -: 2058:     *   - we are really locallizing the parameter
        -: 2059:     */
      766: 2060:    if (usepm && locallevel != pm->level && (on & PM_LOCAL)) {
        -: 2061:	/*
        -: 2062:	 * If the original parameter was special and we're creating
        -: 2063:	 * a new one, we need to keep it special.
        -: 2064:	 *
        -: 2065:	 * The -h (hide) flag prevents an existing special being made
        -: 2066:	 * local.  It can be applied either to the special or in the
        -: 2067:	 * typeset/local statement for the local variable.
        -: 2068:	 */
      342: 2069:	if ((pm->node.flags & PM_SPECIAL)
      302: 2070:	    && !(on & PM_HIDE) && !(pm->node.flags & PM_HIDE & ~off))
      302: 2071:	    newspecial = NS_NORMAL;
      342: 2072:	usepm = 0;
        -: 2073:    }
        -: 2074:
        -: 2075:    /* attempting a type conversion, or making a tied colonarray? */
      766: 2076:    tc = 0;
      766: 2077:    if (ASG_ARRAYP(asg) && PM_TYPE(on) == PM_SCALAR &&
    #####: 2078:	!(usepm && (PM_TYPE(pm->node.flags) & (PM_ARRAY|PM_HASHED))))
    #####: 2079:	on |= PM_ARRAY;
      766: 2080:    if (usepm && ASG_ARRAYP(asg) && newspecial == NS_NONE &&
    #####: 2081:	PM_TYPE(pm->node.flags) != PM_ARRAY &&
    #####: 2082:	PM_TYPE(pm->node.flags) != PM_HASHED) {
    #####: 2083:	if (on & (PM_EFLOAT|PM_FFLOAT|PM_INTEGER)) {
    #####: 2084:	    zerrnam(cname, "%s: can't assign array value to non-array", pname);
    #####: 2085:	    return NULL;
        -: 2086:	}
    #####: 2087:	if (pm->node.flags & PM_SPECIAL) {
    #####: 2088:	    zerrnam(cname, "%s: can't assign array value to non-array special", pname);
    #####: 2089:	    return NULL;
        -: 2090:	}
    #####: 2091:	tc = 1;
    #####: 2092:	usepm = 0;
        -: 2093:    }
      766: 2094:    else if (usepm || newspecial != NS_NONE) {
      304: 2095:	int chflags = ((off & pm->node.flags) | (on & ~pm->node.flags)) &
        -: 2096:	    (PM_INTEGER|PM_EFLOAT|PM_FFLOAT|PM_HASHED|
        -: 2097:	     PM_ARRAY|PM_TIED|PM_AUTOLOAD);
        -: 2098:	/* keep the parameter if just switching between floating types */
      304: 2099:	if ((tc = chflags && chflags != (PM_EFLOAT|PM_FFLOAT)))
    #####: 2100:	    usepm = 0;
        -: 2101:    }
        -: 2102:
        -: 2103:    /*
        -: 2104:     * Extra checks if converting the type of a parameter, or if
        -: 2105:     * trying to remove readonlyness.  It's dangerous doing either
        -: 2106:     * with a special or a parameter which isn't loaded yet (which
        -: 2107:     * may be special when it is loaded; we can't tell yet).
        -: 2108:     */
      766: 2109:    if ((readonly =
     1070: 2110:	 ((usepm || newspecial != NS_NONE) &&
     1070: 2111:	  (off & pm->node.flags & PM_READONLY))) ||
        -: 2112:	tc) {
    #####: 2113:	if (pm->node.flags & PM_SPECIAL) {
    #####: 2114:	    int err = 1;
    #####: 2115:	    if (!readonly && !strcmp(pname, "SECONDS"))
        -: 2116:	    {
        -: 2117:		/*
        -: 2118:		 * We allow SECONDS to change type between integer
        -: 2119:		 * and floating point.  If we are creating a new
        -: 2120:		 * local copy we check the type here and allow
        -: 2121:		 * a new special to be created with that type.
        -: 2122:		 * We then need to make sure the correct type
        -: 2123:		 * for the special is restored at the end of the scope.
        -: 2124:		 * If we are changing the type of an existing
        -: 2125:		 * parameter, we do the whole thing here.
        -: 2126:		 */
    #####: 2127:		if (newspecial != NS_NONE)
        -: 2128:		{
        -: 2129:		    /*
        -: 2130:		     * The first test allows `typeset' to copy the
        -: 2131:		     * existing type.  This is the usual behaviour
        -: 2132:		     * for making special parameters local.
        -: 2133:		     */
    #####: 2134:		    if (PM_TYPE(on) == 0 || PM_TYPE(on) == PM_INTEGER ||
    #####: 2135:			PM_TYPE(on) == PM_FFLOAT || PM_TYPE(on) == PM_EFLOAT)
        -: 2136:		    {
    #####: 2137:			newspecial = NS_SECONDS;
    #####: 2138:			err = 0;	/* and continue */
    #####: 2139:			tc = 0;	/* but don't do a normal conversion */
        -: 2140:		    }
    #####: 2141:		} else if (!setsecondstype(pm, on, off)) {
    #####: 2142:		    if (asg->value.scalar &&
    #####: 2143:			!(pm = assignsparam(
    #####: 2144:			      pname, ztrdup(asg->value.scalar), 0)))
    #####: 2145:			return NULL;
    #####: 2146:		    usepm = 1;
    #####: 2147:		    err = 0;
        -: 2148:		}
        -: 2149:	    }
    #####: 2150:	    if (err)
        -: 2151:	    {
    #####: 2152:		zerrnam(cname, "%s: can't change type of a special parameter",
        -: 2153:			pname);
    #####: 2154:		return NULL;
        -: 2155:	    }
    #####: 2156:	} else if (pm->node.flags & PM_AUTOLOAD) {
    #####: 2157:	    zerrnam(cname, "%s: can't change type of autoloaded parameter",
        -: 2158:		    pname);
    #####: 2159:	    return NULL;
        -: 2160:	}
        -: 2161:    }
      766: 2162:    else if (newspecial != NS_NONE && strcmp(pname, "SECONDS") == 0)
    #####: 2163:	newspecial = NS_SECONDS;
        -: 2164:
      766: 2165:    if (isset(POSIXBUILTINS)) {
        -: 2166:	/*
        -: 2167:	 * Stricter rules about retaining readonly attribute in this case.
        -: 2168:	 */
    #####: 2169:	if ((on & (PM_READONLY|PM_EXPORTED)) &&
    #####: 2170:	    (!usepm || (pm->node.flags & PM_UNSET)) &&
    #####: 2171:	    !ASG_VALUEP(asg))
    #####: 2172:	    on |= PM_UNSET;
    #####: 2173:	else if (usepm && (pm->node.flags & PM_READONLY) &&
    #####: 2174:		 !(on & PM_READONLY) && func != BIN_EXPORT) {
    #####: 2175:	    zerr("read-only variable: %s", pm->node.nam);
    #####: 2176:	    return NULL;
        -: 2177:	}
        -: 2178:	/* This is handled by createparam():
        -: 2179:	if (usepm && (pm->node.flags & PM_EXPORTED) && !(off & PM_EXPORTED))
        -: 2180:	    on |= PM_EXPORTED;
        -: 2181:	*/
        -: 2182:    }
        -: 2183:
        -: 2184:    /*
        -: 2185:     * A parameter will be local if
        -: 2186:     * 1. we are re-using an existing local parameter
        -: 2187:     *    or
        -: 2188:     * 2. we are not using an existing parameter, but
        -: 2189:     *   i. there is already a parameter, which will be hidden
        -: 2190:     *     or
        -: 2191:     *   ii. we are creating a new local parameter
        -: 2192:     */
      766: 2193:    if (usepm) {
        4: 2194:	if ((asg->flags & ASG_ARRAY) ?
    #####: 2195:	    !(PM_TYPE(pm->node.flags) & (PM_ARRAY|PM_HASHED)) :
        2: 2196:	    (asg->value.scalar && (PM_TYPE(pm->node.flags &
        -: 2197:					   (PM_ARRAY|PM_HASHED))))) {
    #####: 2198:	    zerrnam(cname, "%s: inconsistent type for assignment", pname);
    #####: 2199:	    return NULL;
        -: 2200:	}
        2: 2201:	on &= ~PM_LOCAL;
        2: 2202:	if (!on && !roff && !ASG_VALUEP(asg)) {
    #####: 2203:	    if (OPT_ISSET(ops,'p'))
    #####: 2204:		paramtab->printnode(&pm->node, PRINT_TYPESET);
    #####: 2205:	    else if (!OPT_ISSET(ops,'g') &&
    #####: 2206:		     (unset(TYPESETSILENT) || OPT_ISSET(ops,'m')))
    #####: 2207:		paramtab->printnode(&pm->node, PRINT_INCLUDEVALUE);
    #####: 2208:	    return pm;
        -: 2209:	}
        2: 2210:	if ((pm->node.flags & PM_RESTRICTED) && isset(RESTRICTED)) {
    #####: 2211:	    zerrnam(cname, "%s: restricted", pname);
    #####: 2212:	    return pm;
        -: 2213:	}
        2: 2214:	if ((on & PM_UNIQUE) && !(pm->node.flags & PM_READONLY & ~off)) {
        -: 2215:	    Param apm;
        -: 2216:	    char **x;
    #####: 2217:	    if (PM_TYPE(pm->node.flags) == PM_ARRAY) {
    #####: 2218:		x = (*pm->gsu.a->getfn)(pm);
    #####: 2219:		uniqarray(x);
    #####: 2220:		if (pm->node.flags & PM_SPECIAL) {
    #####: 2221:		    if (zheapptr(x))
    #####: 2222:			x = zarrdup(x);
    #####: 2223:		    (*pm->gsu.a->setfn)(pm, x);
    #####: 2224:		} else if (pm->ename && x)
    #####: 2225:		    arrfixenv(pm->ename, x);
    #####: 2226:	    } else if (PM_TYPE(pm->node.flags) == PM_SCALAR && pm->ename &&
        -: 2227:		       (apm =
    #####: 2228:			(Param) paramtab->getnode(paramtab, pm->ename))) {
    #####: 2229:		x = (*apm->gsu.a->getfn)(apm);
    #####: 2230:		uniqarray(x);
    #####: 2231:		if (x)
    #####: 2232:		    arrfixenv(pm->node.nam, x);
        -: 2233:	    }
        -: 2234:	}
        2: 2235:	if (usepm == 2)		/* do not change the PM_UNSET flag */
    #####: 2236:	    pm->node.flags = (pm->node.flags | (on & ~PM_READONLY)) & ~off;
        -: 2237:	else {
        -: 2238:	    /*
        -: 2239:	     * Keep unset if using readonly in POSIX mode.
        -: 2240:	     */
        2: 2241:	    if (!(on & PM_READONLY) || !isset(POSIXBUILTINS))
        2: 2242:		off |= PM_UNSET;
        6: 2243:	    pm->node.flags = (pm->node.flags |
        4: 2244:			      (on & ~PM_READONLY)) & ~off;
        -: 2245:	}
        2: 2246:	if (on & (PM_LEFT | PM_RIGHT_B | PM_RIGHT_Z)) {
    #####: 2247:	    if (typeset_setwidth(cname, pm, ops, on, 0))
    #####: 2248:		return NULL;
        -: 2249:	}
        2: 2250:	if (on & (PM_INTEGER | PM_EFLOAT | PM_FFLOAT)) {
    #####: 2251:	    if (typeset_setbase(cname, pm, ops, on, 0))
    #####: 2252:		return NULL;
        -: 2253:	}
        2: 2254:	if (!(pm->node.flags & (PM_ARRAY|PM_HASHED))) {
        2: 2255:	    if (pm->node.flags & PM_EXPORTED) {
        1: 2256:		if (!(pm->node.flags & PM_UNSET) && !pm->env && !ASG_VALUEP(asg))
        1: 2257:		    addenv(pm, getsparam(pname));
        1: 2258:	    } else if (pm->env && !(pm->node.flags & PM_HASHELEM))
    #####: 2259:		delenv(pm);
        -: 2260:	    DPUTS(ASG_ARRAYP(asg), "BUG: typeset got array value where scalar expected");
        2: 2261:	    if (altpm && !(pm->node.flags & PM_SPECIAL)) {
    #####: 2262:		struct tieddata* tdp = (struct tieddata *) pm->u.data;
    #####: 2263:		if (tdp) {
    #####: 2264:		    if (tdp->joinchar != joinchar && !asg->value.scalar) {
        -: 2265:			/*
        -: 2266:			 * Reassign the scalar to itself to do the splitting with
        -: 2267:			 * the new joinchar
        -: 2268:			 */
    #####: 2269:			tdp->joinchar = joinchar;
    #####: 2270:			if (!(pm = assignsparam(pname, ztrdup(getsparam(pname)), 0)))
    #####: 2271:			    return NULL;
        -: 2272:		    }
        -: 2273:		}
        -: 2274:		else
        -: 2275:		    DPUTS(!tdp, "BUG: no join character to update");
        -: 2276:	    }
        2: 2277:	    if (asg->value.scalar &&
    #####: 2278:		!(pm = assignsparam(pname, ztrdup(asg->value.scalar), 0)))
    #####: 2279:		return NULL;
    #####: 2280:	} else if (asg->flags & ASG_ARRAY) {
    #####: 2281:	    int flags = (asg->flags & ASG_KEY_VALUE) ? ASSPM_KEY_VALUE : 0;
    #####: 2282:	    if (!(pm = assignaparam(pname, asg->value.array ?
    #####: 2283:				 zlinklist2array(asg->value.array, 1) :
        -: 2284:				 mkarray(NULL), flags)))
    #####: 2285:		return NULL;
        -: 2286:	}
        2: 2287:	if (errflag)
    #####: 2288:	    return NULL;
        2: 2289:	pm->node.flags |= (on & PM_READONLY);
        2: 2290:	if (OPT_ISSET(ops,'p'))
    #####: 2291:	    paramtab->printnode(&pm->node, PRINT_TYPESET);
        2: 2292:	return pm;
        -: 2293:    }
        -: 2294:
     1528: 2295:    if ((asg->flags & ASG_ARRAY) ?
    #####: 2296:	!(on & (PM_ARRAY|PM_HASHED)) :
      764: 2297:	(asg->value.scalar && (on & (PM_ARRAY|PM_HASHED)))) {
    #####: 2298:	zerrnam(cname, "%s: inconsistent type for assignment", pname);
    #####: 2299:	return NULL;
        -: 2300:    }
        -: 2301:
        -: 2302:    /*
        -: 2303:     * We're here either because we're creating a new parameter,
        -: 2304:     * or we're adding a parameter at a different local level,
        -: 2305:     * or we're converting the type of a parameter.  In the
        -: 2306:     * last case only, we need to delete the old parameter.
        -: 2307:     */
      764: 2308:    if (tc) {
        -: 2309:	/* Maintain existing readonly/exported status... */
    #####: 2310:	on |= ~off & (PM_READONLY|PM_EXPORTED) & pm->node.flags;
        -: 2311:	/* ...but turn off existing readonly so we can delete it */
    #####: 2312:	pm->node.flags &= ~PM_READONLY;
        -: 2313:	/*
        -: 2314:	 * If we're just changing the type, we should keep the
        -: 2315:	 * variable at the current level of localness.
        -: 2316:	 */
    #####: 2317:	keeplocal = pm->level;
        -: 2318:	/*
        -: 2319:	 * Try to carry over a value, but not when changing from,
        -: 2320:	 * to, or between non-scalar types.
        -: 2321:	 *
        -: 2322:	 * (We can do better now, but it does have user-visible
        -: 2323:	 * implications.)
        -: 2324:	 */
    #####: 2325:	if (!ASG_VALUEP(asg) && !((pm->node.flags|on) & (PM_ARRAY|PM_HASHED))) {
    #####: 2326:	    asg->value.scalar = dupstring(getsparam(pname));
    #####: 2327:	    asg->flags = 0;
        -: 2328:	}
        -: 2329:	/* pname may point to pm->nam which is about to disappear */
    #####: 2330:	pname = dupstring(pname);
    #####: 2331:	unsetparam_pm(pm, 0, 1);
        -: 2332:    }
        -: 2333:
      764: 2334:    if (newspecial != NS_NONE) {
        -: 2335:	Param tpm, pm2;
      302: 2336:	if ((pm->node.flags & PM_RESTRICTED) && isset(RESTRICTED)) {
    #####: 2337:	    zerrnam(cname, "%s: restricted", pname);
    #####: 2338:	    return pm;
        -: 2339:	}
      302: 2340:	if (pm->node.flags & PM_SINGLE) {
    #####: 2341:	    zerrnam(cname, "%s: can only have a single instance", pname);
    #####: 2342:	    return pm;
        -: 2343:	}
        -: 2344:
      302: 2345:	on |= pm->node.flags & PM_TIED;
        -: 2346:
        -: 2347:	/*
        -: 2348:	 * For specials, we keep the same struct but zero everything.
        -: 2349:	 * Maybe it would be easier to create a new struct but copy
        -: 2350:	 * the get/set methods.
        -: 2351:	 */
      302: 2352:	tpm = (Param) zshcalloc(sizeof *tpm);
        -: 2353:
      302: 2354:	tpm->node.nam = pm->node.nam;
      302: 2355:	if (pm->ename &&
    #####: 2356:	    (pm2 = (Param) paramtab->getnode(paramtab, pm->ename)) &&
    #####: 2357:	    pm2->level == locallevel) {
        -: 2358:	    /* This is getting silly, but anyway:  if one of a path/PATH
        -: 2359:	     * pair has already been made local at the current level, we
        -: 2360:	     * have to make sure that the other one does not have its value
        -: 2361:	     * saved:  since that comes from an internal variable it will
        -: 2362:	     * already reflect the local value, so restoring it on exit
        -: 2363:	     * would be wrong.
        -: 2364:	     *
        -: 2365:	     * This problem is also why we make sure we have a copy
        -: 2366:	     * of the environment entry in tpm->env, rather than relying
        -: 2367:	     * on the restored value to provide it.
        -: 2368:	     */
    #####: 2369:	    tpm->node.flags = pm->node.flags | PM_NORESTORE;
        -: 2370:	} else {
      302: 2371:	    copyparam(tpm, pm, 1);
        -: 2372:	}
      302: 2373:	tpm->old = pm->old;
      302: 2374:	tpm->level = pm->level;
      302: 2375:	tpm->base = pm->base;
      302: 2376:	tpm->width = pm->width;
      302: 2377:	if (pm->env)
    #####: 2378:	    delenv(pm);
      302: 2379:	tpm->env = NULL;
        -: 2380:
      302: 2381:	pm->old = tpm;
        -: 2382:	/*
        -: 2383:	 * The remaining on/off flags should be harmless to use,
        -: 2384:	 * because we've checked for unpleasant surprises above.
        -: 2385:	 */
      302: 2386:	pm->node.flags = (PM_TYPE(pm->node.flags) | on | PM_SPECIAL) & ~off;
        -: 2387:	/*
        -: 2388:	 * Readonlyness of special parameters must be preserved.
        -: 2389:	 */
      302: 2390:	pm->node.flags |= tpm->node.flags & PM_READONLY;
      302: 2391:	if (newspecial == NS_SECONDS) {
        -: 2392:	    /* We save off the raw internal value of the SECONDS var */
    #####: 2393:	    tpm->u.dval = getrawseconds();
    #####: 2394:	    setsecondstype(pm, on, off);
        -: 2395:	}
        -: 2396:
        -: 2397:	/*
        -: 2398:	 * Final tweak: if we've turned on one of the flags with
        -: 2399:	 * numbers, we should use the appropriate integer.
        -: 2400:	 */
      302: 2401:	if (on & (PM_LEFT|PM_RIGHT_B|PM_RIGHT_Z)) {
    #####: 2402:	    if (typeset_setwidth(cname, pm, ops, on, 1))
    #####: 2403:		return NULL;
        -: 2404:	}
      302: 2405:	if (on & (PM_INTEGER|PM_EFLOAT|PM_FFLOAT)) {
    #####: 2406:	    if (typeset_setbase(cname, pm, ops, on, 1))
    #####: 2407:		return NULL;
        -: 2408:	}
      462: 2409:    } else if ((subscript = strchr(pname, '['))) {
    #####: 2410:	if (on & PM_READONLY) {
    #####: 2411:	    zerrnam(cname,
        -: 2412:		    "%s: can't create readonly array elements", pname);
    #####: 2413:	    return NULL;
    #####: 2414:	} else if ((on & PM_LOCAL) && locallevel) {
    #####: 2415:	    *subscript = 0;
    #####: 2416:	    pm = (Param) (paramtab == realparamtab ?
        -: 2417:			  /* getnode2() to avoid autoloading */
    #####: 2418:			  paramtab->getnode2(paramtab, pname) :
    #####: 2419:			  paramtab->getnode(paramtab, pname));
    #####: 2420:	    *subscript = '[';
    #####: 2421:	    if (!pm || pm->level != locallevel) {
    #####: 2422:		zerrnam(cname,
        -: 2423:			"%s: can't create local array elements", pname);
    #####: 2424:		return NULL;
        -: 2425:	    }
        -: 2426:	}
    #####: 2427:	if (PM_TYPE(on) == PM_SCALAR && !ASG_ARRAYP(asg)) {
        -: 2428:	    /*
        -: 2429:	     * This will either complain about bad identifiers, or will set
        -: 2430:	     * a hash element or array slice.  This once worked by accident,
        -: 2431:	     * creating a stray parameter along the way via createparam(),
        -: 2432:	     * now called below in the isident() branch.
        -: 2433:	     */
    #####: 2434:	    if (!(pm = assignsparam(
        -: 2435:		      pname,
    #####: 2436:		      ztrdup(asg->value.scalar ? asg->value.scalar : ""), 0)))
    #####: 2437:		return NULL;
    #####: 2438:	    dont_set = 1;
    #####: 2439:	    asg->flags = 0;
    #####: 2440:	    keeplocal = 0;
    #####: 2441:	    on = pm->node.flags;
    #####: 2442:	} else if (PM_TYPE(on) == PM_ARRAY && ASG_ARRAYP(asg)) {
    #####: 2443:	    int flags = (asg->flags & ASG_KEY_VALUE) ? ASSPM_KEY_VALUE : 0;
    #####: 2444:	    if (!(pm = assignaparam(pname, asg->value.array ?
    #####: 2445:				    zlinklist2array(asg->value.array, 1) :
        -: 2446:				    mkarray(NULL), flags)))
    #####: 2447:		return NULL;
    #####: 2448:	    dont_set = 1;
    #####: 2449:	    keeplocal = 0;
    #####: 2450:	    on = pm->node.flags;
        -: 2451:	} else {
    #####: 2452:	    zerrnam(cname,
        -: 2453:		    "%s: inconsistent array element or slice assignment", pname);
    #####: 2454:	    return NULL;
        -: 2455:	}
        -: 2456:    }
        -: 2457:    /*
        -: 2458:     * As we can hide existing parameters, we allow a name if
        -: 2459:     * it's not a normal identifier but is one of the special
        -: 2460:     * set found in the parameter table.  The second test is
        -: 2461:     * because we can set individual positional parameters;
        -: 2462:     * however "0" is not a positional parameter and is OK.
        -: 2463:     *
        -: 2464:     * It would be neater to extend isident() and be clearer
        -: 2465:     * about where we allow various parameter types.  It's
        -: 2466:     * not entirely clear to me isident() should reject
        -: 2467:     * specially named parameters given that it accepts digits.
        -: 2468:     */
      462: 2469:    else if ((isident(pname) || paramtab->getnode(paramtab, pname))
      462: 2470:	     && (!idigit(*pname) || !strcmp(pname, "0"))) {
        -: 2471:	/*
        -: 2472:	 * Create a new node for a parameter with the flags in `on' minus the
        -: 2473:	 * readonly flag
        -: 2474:	 */
      462: 2475:	pm = createparam(pname, on & ~PM_READONLY);
      462: 2476:	if (!pm) {
    #####: 2477:	    if (on & (PM_LEFT | PM_RIGHT_B | PM_RIGHT_Z |
        -: 2478:		      PM_INTEGER | PM_EFLOAT | PM_FFLOAT))
    #####: 2479:		zerrnam(cname, "can't change variable attribute: %s", pname);
    #####: 2480:	    return NULL;
        -: 2481:	}
      462: 2482:	if (on & (PM_LEFT | PM_RIGHT_B | PM_RIGHT_Z)) {
    #####: 2483:	    if (typeset_setwidth(cname, pm, ops, on, 0)) {
    #####: 2484:		unsetparam_pm(pm, 0, 1);
    #####: 2485:		return NULL;
        -: 2486:	    }
        -: 2487:	}
      462: 2488:	if (on & (PM_INTEGER | PM_EFLOAT | PM_FFLOAT)) {
       92: 2489:	    if (typeset_setbase(cname, pm, ops, on, 0)) {
    #####: 2490:		unsetparam_pm(pm, 0, 1);
    #####: 2491:		return NULL;
        -: 2492:	    }
        -: 2493:	}
      924: 2494:	if (isset(TYPESETTOUNSET))
    #####: 2495:	    pm->node.flags |= PM_DEFAULTED;
        -: 2496:    } else {
    #####: 2497:	if (idigit(*pname))
    #####: 2498:	    zerrnam(cname, "not an identifier: %s", pname);
        -: 2499:	else
    #####: 2500:	    zerrnam(cname, "not valid in this context: %s", pname);
    #####: 2501:	return NULL;
        -: 2502:    }
        -: 2503:
      764: 2504:    if (altpm && PM_TYPE(pm->node.flags) == PM_SCALAR && !(pm->node.flags & PM_SPECIAL)) {
        -: 2505:	/*
        -: 2506:	 * It seems safer to set this here than in createparam(),
        -: 2507:	 * to make sure we only ever use the colonarr functions
        -: 2508:	 * when u.data is correctly set.
        -: 2509:	 */
    #####: 2510:	struct tieddata *tdp = (struct tieddata *)
        -: 2511:	    zalloc(sizeof(struct tieddata));
    #####: 2512:	if (!tdp) {
    #####: 2513:	    unsetparam_pm(pm, 0, 1);
    #####: 2514:	    return NULL;
        -: 2515:	}
    #####: 2516:	tdp->joinchar = joinchar;
    #####: 2517:	tdp->arrptr = &altpm->u.arr;
        -: 2518:
    #####: 2519:	pm->gsu.s = &tiedarr_gsu;
    #####: 2520:	pm->u.data = tdp;
        -: 2521:    }
        -: 2522:
      764: 2523:    if (keeplocal)
    #####: 2524:	pm->level = keeplocal;
      764: 2525:    else if (on & PM_LOCAL)
      764: 2526:	pm->level = locallevel;
     1356: 2527:    if (ASG_VALUEP(asg) && !dont_set) {
      592: 2528:	Param ipm = pm;
      592: 2529:	if (pm->node.flags & (PM_ARRAY|PM_HASHED)) {
        -: 2530:	    char **arrayval;
    #####: 2531:	    int flags = (asg->flags & ASG_KEY_VALUE) ? ASSPM_KEY_VALUE : 0;
    #####: 2532:	    if (!ASG_ARRAYP(asg)) {
        -: 2533:		/*
        -: 2534:		 * Attempt to assign a scalar value to an array.
        -: 2535:		 * This can happen if the array is special.
        -: 2536:		 * We'll be lenient and guess what the user meant.
        -: 2537:		 * This is how normal assignment works.
        -: 2538:		 */
    #####: 2539:		if (*asg->value.scalar) {
        -: 2540:		    /* Array with one value */
    #####: 2541:		    arrayval = mkarray(ztrdup(asg->value.scalar));
        -: 2542:		} else {
        -: 2543:		    /* Empty array */
    #####: 2544:		    arrayval = mkarray(NULL);
        -: 2545:		}
    #####: 2546:	    } else if (asg->value.array)
    #####: 2547:		arrayval = zlinklist2array(asg->value.array, 1);
        -: 2548:	    else
    #####: 2549:		arrayval = mkarray(NULL);
    #####: 2550:	    if (!(pm=assignaparam(pname, arrayval, flags)))
    #####: 2551:		return NULL;
        -: 2552:	} else {
        -: 2553:	    DPUTS(ASG_ARRAYP(asg), "BUG: inconsistent array value for scalar");
      592: 2554:	    if (!(pm = assignsparam(pname, ztrdup(asg->value.scalar), 0)))
    #####: 2555:		return NULL;
        -: 2556:	}
      592: 2557:	if (pm != ipm) {
        -: 2558:	    DPUTS(ipm->node.flags != pm->node.flags,
        -: 2559:		  "BUG: parameter recreated with wrong flags");
    #####: 2560:	    unsetparam_pm(ipm, 0, 1);
        -: 2561:	}
      172: 2562:    } else if (newspecial != NS_NONE &&
    #####: 2563:	       !(pm->old->node.flags & (PM_NORESTORE|PM_READONLY))) {
        -: 2564:	/*
        -: 2565:	 * We need to use the special setting function to re-initialise
        -: 2566:	 * the special parameter to empty.
        -: 2567:	 */
    #####: 2568:	switch (PM_TYPE(pm->node.flags)) {
    #####: 2569:	case PM_SCALAR:
    #####: 2570:	    pm->gsu.s->setfn(pm, ztrdup(""));
    #####: 2571:	    break;
    #####: 2572:	case PM_INTEGER:
        -: 2573:	    /*
        -: 2574:	     * Restricted integers are dangerous to initialize to 0,
        -: 2575:	     * so don't do that.
        -: 2576:	     */
    #####: 2577:	    if (!(pm->old->node.flags & PM_RESTRICTED))
    #####: 2578:		pm->gsu.i->setfn(pm, 0);
    #####: 2579:	    break;
    #####: 2580:	case PM_EFLOAT:
        -: 2581:	case PM_FFLOAT:
    #####: 2582:	    pm->gsu.f->setfn(pm, 0.0);
    #####: 2583:	    break;
    #####: 2584:	case PM_ARRAY:
    #####: 2585:	    pm->gsu.a->setfn(pm, mkarray(NULL));
    #####: 2586:	    break;
    #####: 2587:	case PM_HASHED:
    #####: 2588:	    pm->gsu.h->setfn(pm, newparamtable(17, pm->node.nam));
    #####: 2589:	    break;
        -: 2590:	}
        -: 2591:    }
      764: 2592:    pm->node.flags |= (on & PM_READONLY);
        -: 2593:    DPUTS(OPT_ISSET(ops,'p'), "BUG: -p not handled");
        -: 2594:
      764: 2595:    return pm;
        -: 2596:}
        -: 2597:
        -: 2598:/*
        -: 2599: * declare, export, float, integer, local, readonly, typeset
        -: 2600: *
        -: 2601: * Note the difference in interface from most builtins, covered by the
        -: 2602: * BINF_ASSIGN builtin flag.  This is only made use of by builtins
        -: 2603: * called by reserved word, which only covers declare, local, readonly
        -: 2604: * and typeset.  Otherwise assigns is NULL.
        -: 2605: */
        -: 2606:
        -: 2607:/**/
        -: 2608:mod_export int
      686: 2609:bin_typeset(char *name, char **argv, LinkList assigns, Options ops, int func)
        -: 2610:{
        -: 2611:    Param pm;
        -: 2612:    Asgment asg;
        -: 2613:    Patprog pprog;
      686: 2614:    char *optstr = TYPESET_OPTSTR;
      686: 2615:    int on = 0, off = 0, roff, bit = PM_ARRAY;
        -: 2616:    int i;
      686: 2617:    int returnval = 0, printflags = 0;
      686: 2618:    int hasargs = *argv != NULL || (assigns && firstnode(assigns));
        -: 2619:
        -: 2620:    /* POSIXBUILTINS is set for bash/ksh and both ignore -p with args */
      687: 2621:    if ((func == BIN_READONLY || func == BIN_EXPORT) &&
        1: 2622:	isset(POSIXBUILTINS) && hasargs)
    #####: 2623:	ops->ind['p'] = 0;
        -: 2624:
        -: 2625:    /* hash -f is really the builtin `functions' */
      686: 2626:    if (OPT_ISSET(ops,'f'))
    #####: 2627:	return bin_functions(name, argv, ops, func);
        -: 2628:
        -: 2629:    /* POSIX handles "readonly" specially */
      686: 2630:    if (func == BIN_READONLY && isset(POSIXBUILTINS) && !OPT_PLUS(ops, 'g'))
    #####: 2631:	ops->ind['g'] = 1;
        -: 2632:
        -: 2633:    /* Translate the options into PM_* flags.   *
        -: 2634:     * Unfortunately, this depends on the order *
        -: 2635:     * these flags are defined in zsh.h         */
    13720: 2636:    for (; *optstr; optstr++, bit <<= 1)
        -: 2637:    {
    13034: 2638:	int optval = STOUC(*optstr);
    13034: 2639:	if (OPT_MINUS(ops,optval))
       49: 2640:	    on |= bit;
    12985: 2641:	else if (OPT_PLUS(ops,optval))
        1: 2642:	    off |= bit;
        -: 2643:    }
      686: 2644:    roff = off;
        -: 2645:
        -: 2646:    /* Sanity checks on the options.  Remove conflicting options. */
      686: 2647:    if (on & PM_FFLOAT) {
    #####: 2648:	off |= PM_UPPER | PM_ARRAY | PM_HASHED | PM_INTEGER | PM_EFLOAT;
        -: 2649:	/* Allow `float -F' to work even though float sets -E by default */
    #####: 2650:	on &= ~PM_EFLOAT;
        -: 2651:    }
      686: 2652:    if (on & PM_EFLOAT)
    #####: 2653:	off |= PM_UPPER | PM_ARRAY | PM_HASHED | PM_INTEGER | PM_FFLOAT;
      686: 2654:    if (on & PM_INTEGER)
       45: 2655:	off |= PM_UPPER | PM_ARRAY | PM_HASHED | PM_EFLOAT | PM_FFLOAT;
        -: 2656:    /*
        -: 2657:     * Allowing -Z with -L is a feature: left justify, suppressing
        -: 2658:     * leading zeroes.
        -: 2659:     */
      686: 2660:    if (on & (PM_LEFT|PM_RIGHT_Z))
    #####: 2661:	off |= PM_RIGHT_B;
      686: 2662:    if (on & PM_RIGHT_B)
    #####: 2663:	off |= PM_LEFT | PM_RIGHT_Z;
      686: 2664:    if (on & PM_UPPER)
    #####: 2665:	off |= PM_LOWER;
      686: 2666:    if (on & PM_LOWER)
    #####: 2667:	off |= PM_UPPER;
      686: 2668:    if (on & PM_HASHED)
        1: 2669:	off |= PM_ARRAY;
      686: 2670:    if (on & PM_TIED)
    #####: 2671:	off |= PM_INTEGER | PM_EFLOAT | PM_FFLOAT | PM_ARRAY | PM_HASHED;
        -: 2672:
      686: 2673:    on &= ~off;
        -: 2674:
      686: 2675:    queue_signals();
        -: 2676:
        -: 2677:    /* Given no arguments, list whatever the options specify. */
      686: 2678:    if (OPT_ISSET(ops,'p')) {
        -: 2679:
    #####: 2680:	if (isset(POSIXBUILTINS) && SHELL_EMULATION() != EMULATE_KSH) {
    #####: 2681:	  if (func == BIN_EXPORT)
    #####: 2682:	    printflags |= PRINT_POSIX_EXPORT;
    #####: 2683:	  else if (func == BIN_READONLY)
    #####: 2684:	    printflags |= PRINT_POSIX_READONLY;
        -: 2685:	  else
    #####: 2686:	    printflags |= PRINT_TYPESET;
        -: 2687:	} else
    #####: 2688:	    printflags |= PRINT_TYPESET;
        -: 2689:
    #####: 2690:	if (OPT_HASARG(ops,'p')) {
        -: 2691:	    char *eptr;
    #####: 2692:	    int pflag = (int)zstrtol(OPT_ARG(ops,'p'), &eptr, 10);
    #####: 2693:	    if (pflag == 1 && !*eptr)
    #####: 2694:		printflags |= PRINT_LINE;
    #####: 2695:	    else if (pflag || *eptr) {
    #####: 2696:		zwarnnam(name, "bad argument to -p: %s", OPT_ARG(ops,'p'));
    #####: 2697:		unqueue_signals();
    #####: 2698:		return 1;
        -: 2699:	    }
        -: 2700:	    /* -p0 treated as -p for consistency */
        -: 2701:	}
        -: 2702:    }
      686: 2703:    if (!hasargs) {
    #####: 2704:	int exclude = 0;
    #####: 2705:	if (!OPT_ISSET(ops,'p')) {
    #####: 2706:	    if (!(on|roff))
    #####: 2707:		printflags |= PRINT_TYPE;
    #####: 2708:	    if (roff || OPT_ISSET(ops,'+'))
    #####: 2709:		printflags |= PRINT_NAMEONLY;
    #####: 2710:	} else if (printflags & (PRINT_POSIX_EXPORT|PRINT_POSIX_READONLY)) {
        -: 2711:	    /*
        -: 2712:	     * For POSIX export/readonly, exclude non-scalars unless
        -: 2713:	     * explicitly requested.
        -: 2714:	     */
    #####: 2715:	    exclude = (PM_ARRAY|PM_HASHED) & ~(on|roff);
        -: 2716:	}
    #####: 2717:	scanhashtable(paramtab, 1, on|roff, exclude, paramtab->printnode, printflags);
    #####: 2718:	unqueue_signals();
    #####: 2719:	return 0;
        -: 2720:    }
        -: 2721:
      688: 2722:    if (!(OPT_ISSET(ops,'g') || OPT_ISSET(ops,'x') || OPT_ISSET(ops,'m')) ||
        6: 2723:	OPT_PLUS(ops,'g') || *name == 'l' ||
        2: 2724:	(!isset(GLOBALEXPORT) && !OPT_ISSET(ops,'g')))
      684: 2725:	on |= PM_LOCAL;
        -: 2726:
      686: 2727:    if ((on & PM_TIED) && !OPT_ISSET(ops, 'p')) {
        -: 2728:	Param apm;
        -: 2729:	struct asgment asg0, asg2;
    #####: 2730:	char *oldval = NULL, *joinstr;
        -: 2731:	int joinchar, nargs;
    #####: 2732:	int already_tied = 0;
        -: 2733:
    #####: 2734:	if (OPT_ISSET(ops,'m')) {
    #####: 2735:	    zwarnnam(name, "incompatible options for -T");
    #####: 2736:	    unqueue_signals();
    #####: 2737:	    return 1;
        -: 2738:	}
    #####: 2739:	on &= ~off;
    #####: 2740:	nargs = arrlen(argv) + (assigns ? countlinknodes(assigns) : 0);
    #####: 2741:	if (nargs < 2) {
    #####: 2742:	    zwarnnam(name, "-T requires names of scalar and array");
    #####: 2743:	    unqueue_signals();
    #####: 2744:	    return 1;
        -: 2745:	}
    #####: 2746:	if (nargs > 3) {
    #####: 2747:	    zwarnnam(name, "too many arguments for -T");
    #####: 2748:	    unqueue_signals();
    #####: 2749:	    return 1;
        -: 2750:	}
        -: 2751:
    #####: 2752:	if (!(asg = getasg(&argv, assigns))) {
    #####: 2753:	    unqueue_signals();
    #####: 2754:	    return 1;
        -: 2755:	}
    #####: 2756:	asg0 = *asg;
    #####: 2757:	if (ASG_ARRAYP(&asg0)) {
    #####: 2758:	    unqueue_signals();
    #####: 2759:	    zwarnnam(name, "first argument of tie must be scalar: %s",
        -: 2760:		     asg0.name);
    #####: 2761:	    return 1;
        -: 2762:	}
        -: 2763:
    #####: 2764:	if (!(asg = getasg(&argv, assigns))) {
    #####: 2765:	    unqueue_signals();
    #####: 2766:	    return 1;
        -: 2767:	}
    #####: 2768:	if (!ASG_ARRAYP(asg) && asg->value.scalar) {
    #####: 2769:	    unqueue_signals();
    #####: 2770:	    zwarnnam(name, "second argument of tie must be array: %s",
        -: 2771:		     asg->name);
    #####: 2772:	    return 1;
        -: 2773:	}
        -: 2774:
    #####: 2775:	if (!strcmp(asg0.name, asg->name)) {
    #####: 2776:	    unqueue_signals();
    #####: 2777:	    zerrnam(name, "can't tie a variable to itself: %s", asg0.name);
    #####: 2778:	    return 1;
        -: 2779:	}
    #####: 2780:	if (strchr(asg0.name, '[') || strchr(asg->name, '[')) {
    #####: 2781:	    unqueue_signals();
    #####: 2782:	    zerrnam(name, "can't tie array elements: %s", asg0.name);
    #####: 2783:	    return 1;
        -: 2784:	}
    #####: 2785:	if (ASG_VALUEP(asg) && ASG_VALUEP(&asg0)) {
    #####: 2786:	    unqueue_signals();
    #####: 2787:	    zerrnam(name, "only one tied parameter can have value: %s", asg0.name);
    #####: 2788:	    return 1;
        -: 2789:	}
        -: 2790:
        -: 2791:	/*
        -: 2792:	 * Third argument, if given, is character used to join
        -: 2793:	 * the elements of the array in the scalar.
        -: 2794:	 */
    #####: 2795:	if (*argv)
    #####: 2796:	    joinstr = *argv;
    #####: 2797:	else if (assigns && firstnode(assigns)) {
    #####: 2798:	    Asgment nextasg = (Asgment)firstnode(assigns);
    #####: 2799:	    if (ASG_ARRAYP(nextasg) || ASG_VALUEP(nextasg)) {
    #####: 2800:		zwarnnam(name, "third argument of tie must be join character");
    #####: 2801:		unqueue_signals();
    #####: 2802:		return 1;
        -: 2803:	    }
    #####: 2804:	    joinstr = nextasg->name;
        -: 2805:	} else
    #####: 2806:	    joinstr = NULL;
    #####: 2807:	if (!joinstr)
    #####: 2808:	    joinchar = ':';
    #####: 2809:	else if (!*joinstr)
    #####: 2810:	    joinchar = 0;
    #####: 2811:	else if (*joinstr == Meta)
    #####: 2812:	    joinchar = joinstr[1] ^ 32;
        -: 2813:	else
    #####: 2814:	    joinchar = *joinstr;
        -: 2815:
    #####: 2816:	pm = (Param) paramtab->getnode(paramtab, asg0.name);
    #####: 2817:	apm = (Param) paramtab->getnode(paramtab, asg->name);
        -: 2818:
    #####: 2819:	if (pm && (pm->node.flags & (PM_SPECIAL|PM_TIED)) == (PM_SPECIAL|PM_TIED)) {
        -: 2820:	    /*
        -: 2821:	     * Only allow typeset -T on special tied parameters if the tied
        -: 2822:	     * parameter and join char are the same
        -: 2823:	     */
    #####: 2824:	    if (strcmp(pm->ename, asg->name) || !(apm->node.flags & PM_SPECIAL)) {
    #####: 2825:		zwarnnam(name, "%s special parameter can only be tied to special parameter %s", asg0.name, pm->ename);
    #####: 2826:		unqueue_signals();
    #####: 2827:		return 1;
        -: 2828:	    }
    #####: 2829:	    if (joinchar != ':') {
    #####: 2830:		zwarnnam(name, "cannot change the join character of special tied parameters");
    #####: 2831:		unqueue_signals();
    #####: 2832:		return 1;
        -: 2833:	    }
    #####: 2834:	    already_tied = 1;
    #####: 2835:	} else if (apm && (apm->node.flags & (PM_SPECIAL|PM_TIED)) == (PM_SPECIAL|PM_TIED)) {
        -: 2836:	    /*
        -: 2837:	     * For the array variable, this covers attempts to tie the
        -: 2838:	     * array to a different scalar or to the scalar after it has
        -: 2839:	     * been made non-special
        -: 2840:	     */
    #####: 2841:	    zwarnnam(name, "%s special parameter can only be tied to special parameter %s", asg->name, apm->ename);
    #####: 2842:	    unqueue_signals();
    #####: 2843:	    return 1;
    #####: 2844:	} else if (pm) {
    #####: 2845:	    if ((!(pm->node.flags & PM_UNSET) || pm->node.flags & PM_DECLARED)
    #####: 2846:		&& (locallevel == pm->level || !(on & PM_LOCAL))) {
    #####: 2847:		if (pm->node.flags & PM_TIED) {
    #####: 2848:		    if (PM_TYPE(pm->node.flags) != PM_SCALAR) {
    #####: 2849:			zwarnnam(name, "already tied as non-scalar: %s", asg0.name);
    #####: 2850:			unqueue_signals();
    #####: 2851:			return 1;
    #####: 2852:		    } else if (!strcmp(asg->name, pm->ename)) {
    #####: 2853:			already_tied = 1;
        -: 2854:		    } else {
    #####: 2855:			zwarnnam(name, "can't tie already tied scalar: %s",
        -: 2856:				 asg0.name);
    #####: 2857:			unqueue_signals();
    #####: 2858:			return 1;
        -: 2859:		    }
        -: 2860:		} else {
        -: 2861:		    /*
        -: 2862:		     * Variable already exists in the current scope but is not tied.
        -: 2863:		     * We're preserving its value and export attribute but no other
        -: 2864:		     * attributes upon converting to "tied".
        -: 2865:		     */
    #####: 2866:		    if (!asg0.value.scalar && !asg->value.array &&
    #####: 2867:			!(PM_TYPE(pm->node.flags) & (PM_ARRAY|PM_HASHED)))
    #####: 2868:			oldval = ztrdup(getsparam(asg0.name));
    #####: 2869:		    on |= (pm->node.flags & ~roff) & PM_EXPORTED;
        -: 2870:		}
        -: 2871:	    }
        -: 2872:	}
    #####: 2873:	if (already_tied) {
        -: 2874:	    int ret;
        -: 2875:	    /*
        -: 2876:	     * If already tied, we still need to call typeset_single on
        -: 2877:	     * both the array and colonarray, if only to update the attributes
        -: 2878:	     * of both, and of course to set the new value if one is provided
        -: 2879:	     * for either of them.
        -: 2880:	     */
    #####: 2881:	    ret = !(typeset_single(name, asg0.name, pm,
        -: 2882:				   func, on, off, roff, &asg0, apm,
        -: 2883:				   ops, joinchar) &&
    #####: 2884:		    typeset_single(name, asg->name, apm,
    #####: 2885:				   func, (on | PM_ARRAY) & ~PM_EXPORTED,
        -: 2886:				   off & ~PM_ARRAY, roff, asg, NULL, ops, 0)
        -: 2887:		   );
    #####: 2888:	    unqueue_signals();
    #####: 2889:	    return ret;
        -: 2890:	}
        -: 2891:	/*
        -: 2892:	 * Create the tied array; this is normal except that
        -: 2893:	 * it has the PM_TIED flag set.  Do it first because
        -: 2894:	 * we need the address.
        -: 2895:	 *
        -: 2896:	 * Don't attempt to set it yet, it's too early
        -: 2897:	 * to be exported properly.
        -: 2898:	 *
        -: 2899:	 * This may create the array with PM_DEFAULTED.
        -: 2900:	 */
    #####: 2901:	asg2.name = asg->name;
    #####: 2902:	asg2.flags = 0;
    #####: 2903:	asg2.value.array = (LinkList)0;
    #####: 2904:	if (!(apm=typeset_single(name, asg->name,
    #####: 2905:				 (Param)paramtab->getnode(paramtab,
    #####: 2906:							  asg->name),
    #####: 2907:				 func, (on | PM_ARRAY) & ~PM_EXPORTED,
        -: 2908:				 off, roff, &asg2, NULL, ops, 0))) {
    #####: 2909:	    if (oldval)
    #####: 2910:		zsfree(oldval);
    #####: 2911:	    unqueue_signals();
    #####: 2912:	    return 1;
        -: 2913:	}
        -: 2914:	/*
        -: 2915:	 * Create the tied colonarray.  We make it as a normal scalar
        -: 2916:	 * and fix up the oddities later.
        -: 2917:	 */
    #####: 2918:	if (!(pm=typeset_single(name, asg0.name, pm,
        -: 2919:				func, on, off, roff, &asg0, apm,
        -: 2920:				ops, joinchar))) {
    #####: 2921:	    if (oldval)
    #####: 2922:		zsfree(oldval);
    #####: 2923:	    unsetparam_pm(apm, 1, 1);
    #####: 2924:	    unqueue_signals();
    #####: 2925:	    return 1;
        -: 2926:	}
        -: 2927:
        -: 2928:	/*
        -: 2929:	 * pm->ename is only deleted when the struct is, so
        -: 2930:	 * we need to free it here if it already exists.
        -: 2931:	 */
    #####: 2932:	if (pm->ename)
    #####: 2933:	    zsfree(pm->ename);
    #####: 2934:	pm->ename = ztrdup(asg->name);
    #####: 2935:	if (apm->ename)
    #####: 2936:	    zsfree(apm->ename);
    #####: 2937:	apm->ename = ztrdup(asg0.name);
    #####: 2938:	if (asg->value.array) {
    #####: 2939:	    int flags = (asg->flags & ASG_KEY_VALUE) ? ASSPM_KEY_VALUE : 0;
    #####: 2940:	    assignaparam(asg->name, zlinklist2array(asg->value.array, 1), flags);
    #####: 2941:	} else if (asg0.value.scalar || oldval) {
        -: 2942:	    /* We have to undo what we did wrong with asg2 */
    #####: 2943:	    apm->node.flags &= ~PM_DEFAULTED;
    #####: 2944:	    if (oldval)
    #####: 2945:		assignsparam(asg0.name, oldval, 0);
        -: 2946:	}
    #####: 2947:	unqueue_signals();
        -: 2948:
    #####: 2949:	return 0;
        -: 2950:    }
      686: 2951:    if (off & PM_TIED) {
    #####: 2952:	unqueue_signals();
    #####: 2953:	zerrnam(name, "use unset to remove tied variables");
    #####: 2954:	return 1;
        -: 2955:    }
        -: 2956:
        -: 2957:    /* With the -m option, treat arguments as glob patterns */
      686: 2958:    if (OPT_ISSET(ops,'m')) {
    #####: 2959:	if (!OPT_ISSET(ops,'p')) {
    #####: 2960:	    if (!(on|roff))
    #####: 2961:		printflags |= PRINT_TYPE;
    #####: 2962:	    if (!on)
    #####: 2963:		printflags |= PRINT_NAMEONLY;
        -: 2964:	}
        -: 2965:
    #####: 2966:	while ((asg = getasg(&argv, assigns))) {
    #####: 2967:	    LinkList pmlist = newlinklist();
        -: 2968:	    LinkNode pmnode;
        -: 2969:
    #####: 2970:	    tokenize(asg->name);   /* expand argument */
    #####: 2971:	    if (!(pprog = patcompile(asg->name, 0, NULL))) {
    #####: 2972:		untokenize(asg->name);
    #####: 2973:		zwarnnam(name, "bad pattern : %s", asg->name);
    #####: 2974:		returnval = 1;
    #####: 2975:		continue;
        -: 2976:	    }
    #####: 2977:	    if (OPT_PLUS(ops,'m') && !ASG_VALUEP(asg)) {
    #####: 2978:		scanmatchtable(paramtab, pprog, 1, on|roff, 0,
    #####: 2979:			       paramtab->printnode, printflags);
    #####: 2980:		continue;
        -: 2981:	    }
        -: 2982:	    /*
        -: 2983:	     * Search through the parameter table and change all parameters
        -: 2984:	     * matching the glob pattern to have these flags and/or value.
        -: 2985:	     * Bad news:  if the parameter gets altered, e.g. by
        -: 2986:	     * a type conversion, then paramtab can be shifted around,
        -: 2987:	     * so we need to store the parameters to alter on a separate
        -: 2988:	     * list for later use.
        -: 2989:	     */
    #####: 2990:	    for (i = 0; i < paramtab->hsize; i++) {
    #####: 2991:		for (pm = (Param) paramtab->nodes[i]; pm;
    #####: 2992:		     pm = (Param) pm->node.next) {
    #####: 2993:		    if (((pm->node.flags & PM_RESTRICTED) && isset(RESTRICTED)) ||
    #####: 2994:			(pm->node.flags & PM_UNSET))
    #####: 2995:			continue;
    #####: 2996:		    if (pattry(pprog, pm->node.nam))
    #####: 2997:			addlinknode(pmlist, pm);
        -: 2998:		}
        -: 2999:	    }
    #####: 3000:	    for (pmnode = firstnode(pmlist); pmnode; incnode(pmnode)) {
    #####: 3001:		pm = (Param) getdata(pmnode);
    #####: 3002:		if (!typeset_single(name, pm->node.nam, pm, func, on, off, roff,
        -: 3003:				    asg, NULL, ops, 0))
    #####: 3004:		    returnval = 1;
        -: 3005:	    }
        -: 3006:	}
    #####: 3007:	unqueue_signals();
    #####: 3008:	return returnval;
        -: 3009:    }
        -: 3010:
        -: 3011:    /* Take arguments literally.  Don't glob */
     2138: 3012:    while ((asg = getasg(&argv, assigns))) {
     1532: 3013:	HashNode hn = (paramtab == realparamtab ?
        -: 3014:		       /* getnode2() to avoid autoloading */
      766: 3015:		       paramtab->getnode2(paramtab, asg->name) :
    #####: 3016:		       paramtab->getnode(paramtab, asg->name));
      766: 3017:	if (OPT_ISSET(ops,'p')) {
    #####: 3018:	    if (hn)
    #####: 3019:		paramtab->printnode(hn, printflags);
        -: 3020:	    else {
    #####: 3021:		zwarnnam(name, "no such variable: %s", asg->name);
    #####: 3022:		returnval = 1;
        -: 3023:	    }
    #####: 3024:	    continue;
        -: 3025:	}
      766: 3026:	if (!typeset_single(name, asg->name, (Param)hn,
        -: 3027:			    func, on, off, roff, asg, NULL,
        -: 3028:			    ops, 0))
    #####: 3029:	    returnval = 1;
        -: 3030:    }
      686: 3031:    unqueue_signals();
      686: 3032:    return returnval;
        -: 3033:}
        -: 3034:
        -: 3035:/* Helper for bin_functions() when run as "autoload -X" */
        -: 3036:
        -: 3037:/**/
        -: 3038:int
    #####: 3039:eval_autoload(Shfunc shf, char *name, Options ops, int func)
        -: 3040:{
    #####: 3041:    if (!(shf->node.flags & PM_UNDEFINED))
    #####: 3042:	return 1;
        -: 3043:
    #####: 3044:    if (shf->funcdef) {
    #####: 3045:	freeeprog(shf->funcdef);
    #####: 3046:	shf->funcdef = &dummy_eprog;
        -: 3047:    }
    #####: 3048:    if (OPT_MINUS(ops,'X')) {
        -: 3049:	char *fargv[3];
    #####: 3050:	fargv[0] = quotestring(name, QT_SINGLE_OPTIONAL);
    #####: 3051:	fargv[1] = "\"$@\"";
    #####: 3052:	fargv[2] = 0;
    #####: 3053:	shf->funcdef = mkautofn(shf);
    #####: 3054:	return bin_eval(name, fargv, ops, func);
        -: 3055:    }
        -: 3056:
    #####: 3057:    return !loadautofn(shf, (OPT_ISSET(ops,'k') ? 2 :
    #####: 3058:			     (OPT_ISSET(ops,'z') ? 0 : 1)), 1,
    #####: 3059:		       OPT_ISSET(ops,'d'));
        -: 3060:}
        -: 3061:
        -: 3062:/* Helper for bin_functions() for -X and -r options */
        -: 3063:
        -: 3064:/**/
        -: 3065:static int
    #####: 3066:check_autoload(Shfunc shf, char *name, Options ops, int func)
        -: 3067:{
    #####: 3068:    if (OPT_ISSET(ops,'X'))
        -: 3069:    {
    #####: 3070:	return eval_autoload(shf, name, ops, func);
        -: 3071:    }
    #####: 3072:    if ((OPT_ISSET(ops,'r') || OPT_ISSET(ops,'R')) &&
    #####: 3073:	(shf->node.flags & PM_UNDEFINED))
        -: 3074:    {
        -: 3075:	char *dir_path;
    #####: 3076:	if (shf->filename && (shf->node.flags & PM_LOADDIR)) {
        -: 3077:	    char *spec_path[2];
    #####: 3078:	    spec_path[0] = shf->filename;
    #####: 3079:	    spec_path[1] = NULL;
    #####: 3080:	    if (getfpfunc(shf->node.nam, NULL, &dir_path, spec_path, 1)) {
        -: 3081:		/* shf->filename is already correct. */
    #####: 3082:		return 0;
        -: 3083:	    }
    #####: 3084:	    if (!OPT_ISSET(ops,'d')) {
    #####: 3085:		if (OPT_ISSET(ops,'R')) {
    #####: 3086:		    zerr("%s: function definition file not found",
        -: 3087:			 shf->node.nam);
    #####: 3088:		    return 1;
        -: 3089:		}
    #####: 3090:		return 0;
        -: 3091:	    }
        -: 3092:	}
    #####: 3093:	if (getfpfunc(shf->node.nam, NULL, &dir_path, NULL, 1)) {
    #####: 3094:	    dircache_set(&shf->filename, NULL);
    #####: 3095:	    if (*dir_path != '/') {
    #####: 3096:		dir_path = zhtricat(metafy(zgetcwd(), -1, META_HEAPDUP),
        -: 3097:				    "/", dir_path);
    #####: 3098:		dir_path = xsymlink(dir_path, 1);
        -: 3099:	    }
    #####: 3100:	    dircache_set(&shf->filename, dir_path);
    #####: 3101:	    shf->node.flags |= PM_LOADDIR;
    #####: 3102:	    return 0;
        -: 3103:	}
    #####: 3104:	if (OPT_ISSET(ops,'R')) {
    #####: 3105:	    zerr("%s: function definition file not found",
        -: 3106:		 shf->node.nam);
    #####: 3107:	    return 1;
        -: 3108:	}
        -: 3109:	/* with -r, we don't flag an error, just let it be found later. */
        -: 3110:    }
    #####: 3111:    return 0;
        -: 3112:}
        -: 3113:
        -: 3114:/* List a user-defined math function. */
        -: 3115:static void
    #####: 3116:listusermathfunc(MathFunc p)
        -: 3117:{
        -: 3118:    int showargs;
        -: 3119:
    #####: 3120:    if (p->module)
    #####: 3121:	showargs = 3;
    #####: 3122:    else if (p->maxargs != (p->minargs ? p->minargs : -1))
    #####: 3123:	showargs = 2;
    #####: 3124:    else if (p->minargs)
    #####: 3125:	showargs = 1;
        -: 3126:    else
    #####: 3127:	showargs = 0;
        -: 3128:
    #####: 3129:    printf("functions -M%s %s", (p->flags & MFF_STR) ? "s" : "", p->name);
    #####: 3130:    if (showargs) {
    #####: 3131:	printf(" %d", p->minargs);
    #####: 3132:	showargs--;
        -: 3133:    }
    #####: 3134:    if (showargs) {
    #####: 3135:	printf(" %d", p->maxargs);
    #####: 3136:	showargs--;
        -: 3137:    }
    #####: 3138:    if (showargs) {
        -: 3139:	/*
        -: 3140:	 * function names are not required to consist of ident characters
        -: 3141:	 */
    #####: 3142:	putchar(' ');
    #####: 3143:	quotedzputs(p->module, stdout);
    #####: 3144:	showargs--;
        -: 3145:    }
    #####: 3146:    putchar('\n');
    #####: 3147:}
        -: 3148:
        -: 3149:
        -: 3150:static void
    #####: 3151:add_autoload_function(Shfunc shf, char *funcname)
        -: 3152:{
        -: 3153:    char *nam;
    #####: 3154:    if (*funcname == '/' && funcname[1] &&
    #####: 3155:	(nam = strrchr(funcname, '/')) && nam[1] &&
    #####: 3156:	(shf->node.flags & PM_UNDEFINED)) {
        -: 3157:	char *dir;
    #####: 3158:	nam = strrchr(funcname, '/');
    #####: 3159:	if (nam == funcname) {
    #####: 3160:	    dir = "/";
        -: 3161:	} else {
    #####: 3162:	    *nam++ = '\0';
    #####: 3163:	    dir = funcname;
        -: 3164:	}
    #####: 3165:	dircache_set(&shf->filename, NULL);
    #####: 3166:	dircache_set(&shf->filename, dir);
    #####: 3167:	shf->node.flags |= PM_LOADDIR;
    #####: 3168:	shf->node.flags |= PM_ABSPATH_USED;
    #####: 3169:	shfunctab->addnode(shfunctab, ztrdup(nam), shf);
        -: 3170:    } else {
        -: 3171:        Shfunc shf2;
        -: 3172:        Funcstack fs;
    #####: 3173:        const char *calling_f = NULL;
        -: 3174:        char buf[PATH_MAX+1];
        -: 3175:
        -: 3176:        /* Find calling function */
    #####: 3177:        for (fs = funcstack; fs; fs = fs->prev) {
    #####: 3178:            if (fs->tp == FS_FUNC && fs->name && (!shf->node.nam || 0 != strcmp(fs->name,shf->node.nam))) {
    #####: 3179:                calling_f = fs->name;
    #####: 3180:                break;
        -: 3181:            }
        -: 3182:        }
        -: 3183:
        -: 3184:        /* Get its directory */
    #####: 3185:        if (calling_f) {
        -: 3186:            /* Should contain load directory, and be loaded via absolute path */
    #####: 3187:            if ((shf2 = (Shfunc) shfunctab->getnode2(shfunctab, calling_f))
    #####: 3188:                    && (shf2->node.flags & PM_LOADDIR) && (shf2->node.flags & PM_ABSPATH_USED)
    #####: 3189:                    && shf2->filename)
        -: 3190:            {
    #####: 3191:                if (strlen(shf2->filename) + strlen(funcname) + 1 < PATH_MAX)
        -: 3192:                {
    #####: 3193:                    sprintf(buf, "%s/%s", shf2->filename, funcname);
        -: 3194:                    /* Set containing directory if the function file
        -: 3195:                     * exists (do normal FPATH processing otherwise) */
    #####: 3196:                    if (!access(buf, R_OK)) {
    #####: 3197:                        dircache_set(&shf->filename, NULL);
    #####: 3198:                        dircache_set(&shf->filename, shf2->filename);
    #####: 3199:                        shf->node.flags |= PM_LOADDIR;
    #####: 3200:                        shf->node.flags |= PM_ABSPATH_USED;
        -: 3201:                    }
        -: 3202:                }
        -: 3203:            }
        -: 3204:        }
        -: 3205:
    #####: 3206:	shfunctab->addnode(shfunctab, ztrdup(funcname), shf);
        -: 3207:    }
    #####: 3208:}
        -: 3209:
        -: 3210:/* Display or change the attributes of shell functions.   *
        -: 3211: * If called as autoload, it will define a new autoloaded *
        -: 3212: * (undefined) shell function.                            */
        -: 3213:
        -: 3214:/**/
        -: 3215:int
    #####: 3216:bin_functions(char *name, char **argv, Options ops, int func)
        -: 3217:{
        -: 3218:    Patprog pprog;
        -: 3219:    Shfunc shf;
    #####: 3220:    int i, returnval = 0;
    #####: 3221:    int on = 0, off = 0, pflags = 0, roff, expand = 0;
        -: 3222:
        -: 3223:    /* Do we have any flags defined? */
    #####: 3224:    if (OPT_PLUS(ops,'u'))
    #####: 3225:	off |= PM_UNDEFINED;
    #####: 3226:    else if (OPT_MINUS(ops,'u') || OPT_ISSET(ops,'X'))
    #####: 3227:	on |= PM_UNDEFINED;
    #####: 3228:    if (OPT_MINUS(ops,'U'))
    #####: 3229:	on |= PM_UNALIASED|PM_UNDEFINED;
    #####: 3230:    else if (OPT_PLUS(ops,'U'))
    #####: 3231:	off |= PM_UNALIASED;
    #####: 3232:    if (OPT_MINUS(ops,'t'))
    #####: 3233:	on |= PM_TAGGED;
    #####: 3234:    else if (OPT_PLUS(ops,'t'))
    #####: 3235:	off |= PM_TAGGED;
    #####: 3236:    if (OPT_MINUS(ops,'T'))
    #####: 3237:	on |= PM_TAGGED_LOCAL;
    #####: 3238:    else if (OPT_PLUS(ops,'T'))
    #####: 3239:	off |= PM_TAGGED_LOCAL;
    #####: 3240:    if (OPT_MINUS(ops,'W'))
    #####: 3241:	on |= PM_WARNNESTED;
    #####: 3242:    else if (OPT_PLUS(ops,'W'))
    #####: 3243:	off |= PM_WARNNESTED;
    #####: 3244:    roff = off;
    #####: 3245:    if (OPT_MINUS(ops,'z')) {
    #####: 3246:	on |= PM_ZSHSTORED;
    #####: 3247:	off |= PM_KSHSTORED;
    #####: 3248:    } else if (OPT_PLUS(ops,'z')) {
    #####: 3249:	off |= PM_ZSHSTORED;
    #####: 3250:	roff |= PM_ZSHSTORED;
        -: 3251:    }
    #####: 3252:    if (OPT_MINUS(ops,'k')) {
    #####: 3253:	on |= PM_KSHSTORED;
    #####: 3254:	off |= PM_ZSHSTORED;
    #####: 3255:    } else if (OPT_PLUS(ops,'k')) {
    #####: 3256:	off |= PM_KSHSTORED;
    #####: 3257:	roff |= PM_KSHSTORED;
        -: 3258:    }
    #####: 3259:    if (OPT_MINUS(ops,'d')) {
    #####: 3260:	on |= PM_CUR_FPATH;
    #####: 3261:	off |= PM_CUR_FPATH;
    #####: 3262:    } else if (OPT_PLUS(ops,'d')) {
    #####: 3263:	off |= PM_CUR_FPATH;
    #####: 3264:	roff |= PM_CUR_FPATH;
        -: 3265:    }
        -: 3266:
    #####: 3267:    if ((off & PM_UNDEFINED) || (OPT_ISSET(ops,'k') && OPT_ISSET(ops,'z')) ||
    #####: 3268:	(OPT_ISSET(ops,'x') && !OPT_HASARG(ops,'x')) ||
    #####: 3269:	(OPT_MINUS(ops,'X') && (OPT_ISSET(ops,'m') || !scriptname)) ||
    #####: 3270:	(OPT_ISSET(ops,'c') && (OPT_ISSET(ops,'x') || OPT_ISSET(ops,'X') ||
    #####: 3271:				OPT_ISSET(ops,'m')))) {
    #####: 3272:	zwarnnam(name, "invalid option(s)");
    #####: 3273:	return 1;
        -: 3274:    }
        -: 3275:
    #####: 3276:    if (OPT_ISSET(ops,'c')) {
        -: 3277:	Shfunc newsh;
    #####: 3278:	if (!*argv || !argv[1] || argv[2]) {
    #####: 3279:	    zwarnnam(name, "-c: requires two arguments");
    #####: 3280:	    return 1;
        -: 3281:	}
    #####: 3282:	shf = (Shfunc) shfunctab->getnode(shfunctab, *argv);
    #####: 3283:	if (!shf) {
    #####: 3284:	    zwarnnam(name, "no such function: %s", *argv);
    #####: 3285:	    return 1;
        -: 3286:	}
    #####: 3287:	if (shf->node.flags & PM_UNDEFINED) {
    #####: 3288:	    if (shf->funcdef) {
    #####: 3289:		freeeprog(shf->funcdef);
    #####: 3290:		shf->funcdef = &dummy_eprog;
        -: 3291:	    }
    #####: 3292:	    shf = loadautofn(shf, 1, 0, 0);
    #####: 3293:	    if (!shf)
    #####: 3294:		return 1;
        -: 3295:	}
    #####: 3296:	newsh = zalloc(sizeof(*newsh));
    #####: 3297:	memcpy(newsh, shf, sizeof(*newsh));
    #####: 3298:	if (newsh->node.flags & PM_LOADDIR) {
        -: 3299:	    /* Expand original location of autoloaded file */
    #####: 3300:	    newsh->node.flags &= ~PM_LOADDIR;
    #####: 3301:	    newsh->filename = tricat(shf->filename, "/", shf->node.nam);
        -: 3302:	} else
    #####: 3303:	    newsh->filename = ztrdup(shf->filename);
    #####: 3304:	newsh->funcdef->nref++;
    #####: 3305:	if (newsh->redir)
    #####: 3306:	    newsh->redir->nref++;
    #####: 3307:	if (shf->sticky)
    #####: 3308:	    newsh->sticky = sticky_emulation_dup(sticky, 0);
    #####: 3309:	shfunctab->addnode(shfunctab, ztrdup(argv[1]), &newsh->node);
    #####: 3310:	return 0;
        -: 3311:    }
        -: 3312:
    #####: 3313:    if (OPT_ISSET(ops,'x')) {
        -: 3314:	char *eptr;
    #####: 3315:	expand = (int)zstrtol(OPT_ARG(ops,'x'), &eptr, 10);
    #####: 3316:	if (*eptr) {
    #####: 3317:	    zwarnnam(name, "number expected after -x");
    #####: 3318:	    return 1;
        -: 3319:	}
    #####: 3320:	if (expand == 0)	/* no indentation at all */
    #####: 3321:	    expand = -1;
        -: 3322:    }
        -: 3323:
    #####: 3324:    if (OPT_PLUS(ops,'f') || roff || OPT_ISSET(ops,'+'))
    #####: 3325:	pflags |= PRINT_NAMEONLY;
        -: 3326:
    #####: 3327:    if (OPT_MINUS(ops,'M') || OPT_PLUS(ops,'M')) {
        -: 3328:	MathFunc p, q, prev;
        -: 3329:	/*
        -: 3330:	 * Add/remove/list function as mathematical.
        -: 3331:	 */
    #####: 3332:	if (on || off || pflags || OPT_ISSET(ops,'X') || OPT_ISSET(ops,'u')
    #####: 3333:	    || OPT_ISSET(ops,'U') || OPT_ISSET(ops,'w')) {
    #####: 3334:	    zwarnnam(name, "invalid option(s)");
    #####: 3335:	    return 1;
        -: 3336:	}
    #####: 3337:	if (!*argv) {
        -: 3338:	    /* List functions. */
    #####: 3339:	    queue_signals();
    #####: 3340:	    for (p = mathfuncs; p; p = p->next)
    #####: 3341:		if (p->flags & MFF_USERFUNC)
    #####: 3342:		    listusermathfunc(p);
    #####: 3343:	    unqueue_signals();
    #####: 3344:	} else if (OPT_ISSET(ops,'m')) {
        -: 3345:	    /* List matching functions. */
    #####: 3346:	    for (; *argv; argv++) {
    #####: 3347:		queue_signals();
    #####: 3348:		tokenize(*argv);
    #####: 3349:		if ((pprog = patcompile(*argv, PAT_STATIC, 0))) {
    #####: 3350:		    for (p = mathfuncs, q = NULL; p; q = p) {
        -: 3351:			MathFunc next;
        -: 3352:			do {
    #####: 3353:			    next = NULL;
    #####: 3354:			    if ((p->flags & MFF_USERFUNC) &&
    #####: 3355:				pattry(pprog, p->name)) {
    #####: 3356:				if (OPT_PLUS(ops,'M')) {
    #####: 3357:				    next = p->next;
    #####: 3358:				    removemathfunc(q, p);
    #####: 3359:				    p = next;
        -: 3360:				} else
    #####: 3361:				    listusermathfunc(p);
        -: 3362:			    }
        -: 3363:			    /* if we deleted one, retry with the new p */
    #####: 3364:			} while (next);
    #####: 3365:			if (p)
    #####: 3366:			    p = p->next;
        -: 3367:		    }
        -: 3368:		} else {
    #####: 3369:		    untokenize(*argv);
    #####: 3370:		    zwarnnam(name, "bad pattern : %s", *argv);
    #####: 3371:		    returnval = 1;
        -: 3372:		}
    #####: 3373:		unqueue_signals();
        -: 3374:	    }
    #####: 3375:	} else if (OPT_PLUS(ops,'M')) {
        -: 3376:	    /* Delete functions. -m is allowed but is handled above. */
    #####: 3377:	    for (; *argv; argv++) {
    #####: 3378:		queue_signals();
    #####: 3379:		for (p = mathfuncs, q = NULL; p; q = p, p = p->next) {
    #####: 3380:		    if (!strcmp(p->name, *argv)) {
    #####: 3381:			if (!(p->flags & MFF_USERFUNC)) {
    #####: 3382:			    zwarnnam(name, "+M %s: is a library function",
        -: 3383:				     *argv);
    #####: 3384:			    returnval = 1;
    #####: 3385:			    break;
        -: 3386:			}
    #####: 3387:			removemathfunc(q, p);
    #####: 3388:			break;
        -: 3389:		    }
        -: 3390:		}
    #####: 3391:		unqueue_signals();
        -: 3392:	    }
        -: 3393:	} else {
        -: 3394:	    /* Add a function */
        -: 3395:	    int minargs, maxargs;
    #####: 3396:	    char *funcname = *argv++;
    #####: 3397:	    char *modname = NULL;
        -: 3398:	    char *ptr;
        -: 3399:
    #####: 3400:	    if (OPT_ISSET(ops,'s')) {
    #####: 3401:		minargs = maxargs = 1;
        -: 3402:	    } else {
    #####: 3403:		minargs = 0;
    #####: 3404:		maxargs = -1;
        -: 3405:	    }
        -: 3406:
    #####: 3407:	    ptr = itype_end(funcname, IIDENT, 0);
    #####: 3408:	    if (idigit(*funcname) || funcname == ptr || *ptr) {
    #####: 3409:		zwarnnam(name, "-M %s: bad math function name", funcname);
    #####: 3410:		return 1;
        -: 3411:	    }
        -: 3412:
    #####: 3413:	    if (*argv) {
    #####: 3414:		minargs = (int)zstrtol(*argv, &ptr, 0);
    #####: 3415:		if (minargs < 0 || *ptr) {
    #####: 3416:		    zwarnnam(name, "-M: invalid min number of arguments: %s",
        -: 3417:			     *argv);
    #####: 3418:		    return 1;
        -: 3419:		}
    #####: 3420:		if (OPT_ISSET(ops,'s') && minargs != 1) {
    #####: 3421:		    zwarnnam(name, "-Ms: must take a single string argument");
    #####: 3422:		    return 1;
        -: 3423:		}
    #####: 3424:		maxargs = minargs;
    #####: 3425:		argv++;
        -: 3426:	    }
    #####: 3427:	    if (*argv) {
    #####: 3428:		maxargs = (int)zstrtol(*argv, &ptr, 0);
    #####: 3429:		if (maxargs < -1 ||
    #####: 3430:		    (maxargs != -1 && maxargs < minargs) ||
    #####: 3431:		    *ptr) {
    #####: 3432:		    zwarnnam(name,
        -: 3433:			     "-M: invalid max number of arguments: %s",
        -: 3434:			     *argv);
    #####: 3435:		    return 1;
        -: 3436:		}
    #####: 3437:		if (OPT_ISSET(ops,'s') && maxargs != 1) {
    #####: 3438:		    zwarnnam(name, "-Ms: must take a single string argument");
    #####: 3439:		    return 1;
        -: 3440:		}
    #####: 3441:		argv++;
        -: 3442:	    }
    #####: 3443:	    if (*argv)
    #####: 3444:		modname = *argv++;
    #####: 3445:	    if (*argv) {
    #####: 3446:		zwarnnam(name, "-M: too many arguments");
    #####: 3447:		return 1;
        -: 3448:	    }
        -: 3449:
    #####: 3450:	    p = (MathFunc)zshcalloc(sizeof(struct mathfunc));
    #####: 3451:	    p->name = ztrdup(funcname);
    #####: 3452:	    p->flags = MFF_USERFUNC;
    #####: 3453:	    if (OPT_ISSET(ops,'s'))
    #####: 3454:		p->flags |= MFF_STR;
    #####: 3455:	    p->module = modname ? ztrdup(modname) : NULL;
    #####: 3456:	    p->minargs = minargs;
    #####: 3457:	    p->maxargs = maxargs;
        -: 3458:
    #####: 3459:	    queue_signals();
    #####: 3460:	    for (q = mathfuncs, prev = NULL; q; prev = q, q = q->next) {
    #####: 3461:		if (!strcmp(q->name, funcname)) {
    #####: 3462:		    removemathfunc(prev, q);
    #####: 3463:		    break;
        -: 3464:		}
        -: 3465:	    }
        -: 3466:
    #####: 3467:	    p->next = mathfuncs;
    #####: 3468:	    mathfuncs = p;
    #####: 3469:	    unqueue_signals();
        -: 3470:	}
        -: 3471:
    #####: 3472:	return returnval;
        -: 3473:    }
        -: 3474:
    #####: 3475:    if (OPT_MINUS(ops,'X')) {
        -: 3476:	Funcstack fs;
    #####: 3477:	char *funcname = NULL;
        -: 3478:	int ret;
    #####: 3479:	if (*argv && argv[1]) {
    #####: 3480:	    zwarnnam(name, "-X: too many arguments");
    #####: 3481:	    return 1;
        -: 3482:	}
    #####: 3483:	queue_signals();
    #####: 3484:	for (fs = funcstack; fs; fs = fs->prev) {
    #####: 3485:	    if (fs->tp == FS_FUNC) {
        -: 3486:		/*
        -: 3487:		 * dupstring here is paranoia but unlikely to be
        -: 3488:		 * problematic
        -: 3489:		 */
    #####: 3490:		funcname = dupstring(fs->name);
    #####: 3491:		break;
        -: 3492:	    }
        -: 3493:	}
    #####: 3494:	if (!funcname)
        -: 3495:	{
    #####: 3496:	    zerrnam(name, "bad autoload");
    #####: 3497:	    ret = 1;
        -: 3498:	} else {
    #####: 3499:	    if ((shf = (Shfunc) shfunctab->getnode(shfunctab, funcname))) {
        -: 3500:		DPUTS(!shf->funcdef,
        -: 3501:		      "BUG: Calling autoload from empty function");
        -: 3502:	    } else {
    #####: 3503:		shf = (Shfunc) zshcalloc(sizeof *shf);
    #####: 3504:		shfunctab->addnode(shfunctab, ztrdup(funcname), shf);
        -: 3505:	    }
    #####: 3506:	    if (*argv) {
    #####: 3507:		dircache_set(&shf->filename, NULL);
    #####: 3508:		dircache_set(&shf->filename, *argv);
    #####: 3509:		on |= PM_LOADDIR;
        -: 3510:	    }
    #####: 3511:	    shf->node.flags = on;
    #####: 3512:	    ret = eval_autoload(shf, funcname, ops, func);
        -: 3513:	}
    #####: 3514:	unqueue_signals();
    #####: 3515:	return ret;
    #####: 3516:    } else if (!*argv) {
        -: 3517:	/* If no arguments given, we will print functions.  If flags *
        -: 3518:	 * are given, we will print only functions containing these  *
        -: 3519:	 * flags, else we'll print them all.                         */
    #####: 3520:	int ret = 0;
        -: 3521:
    #####: 3522:	queue_signals();
    #####: 3523:	if (OPT_ISSET(ops,'U') && !OPT_ISSET(ops,'u'))
    #####: 3524:		on &= ~PM_UNDEFINED;
    #####: 3525:	    scanshfunc(1, on|off, DISABLED, shfunctab->printnode,
        -: 3526:		       pflags, expand);
    #####: 3527:	unqueue_signals();
    #####: 3528:	return ret;
        -: 3529:    }
        -: 3530:
        -: 3531:    /* With the -m option, treat arguments as glob patterns */
    #####: 3532:    if (OPT_ISSET(ops,'m')) {
    #####: 3533:	on &= ~PM_UNDEFINED;
    #####: 3534:	for (; *argv; argv++) {
    #####: 3535:	    queue_signals();
        -: 3536:	    /* expand argument */
    #####: 3537:	    tokenize(*argv);
    #####: 3538:	    if ((pprog = patcompile(*argv, PAT_STATIC, 0))) {
        -: 3539:		/* with no options, just print all functions matching the glob pattern */
    #####: 3540:		if (!(on|off) && !OPT_ISSET(ops,'X')) {
    #####: 3541:		    scanmatchshfunc(pprog, 1, 0, DISABLED,
    #####: 3542:				   shfunctab->printnode, pflags, expand);
        -: 3543:		} else {
        -: 3544:		    /* apply the options to all functions matching the glob pattern */
    #####: 3545:		    for (i = 0; i < shfunctab->hsize; i++) {
    #####: 3546:			for (shf = (Shfunc) shfunctab->nodes[i]; shf;
    #####: 3547:			     shf = (Shfunc) shf->node.next)
    #####: 3548:			    if (pattry(pprog, shf->node.nam) &&
    #####: 3549:				!(shf->node.flags & DISABLED)) {
    #####: 3550:				shf->node.flags = (shf->node.flags |
    #####: 3551:					      (on & ~PM_UNDEFINED)) & ~off;
    #####: 3552:				if (check_autoload(shf, shf->node.nam,
        -: 3553:						   ops, func)) {
    #####: 3554:				    returnval = 1;
        -: 3555:				}
        -: 3556:			    }
        -: 3557:		    }
        -: 3558:		}
        -: 3559:	    } else {
    #####: 3560:		untokenize(*argv);
    #####: 3561:		zwarnnam(name, "bad pattern : %s", *argv);
    #####: 3562:		returnval = 1;
        -: 3563:	    }
    #####: 3564:	    unqueue_signals();
        -: 3565:	}
    #####: 3566:	return returnval;
        -: 3567:    }
        -: 3568:
        -: 3569:    /* Take the arguments literally -- do not glob */
    #####: 3570:    queue_signals();
    #####: 3571:    for (; *argv; argv++) {
    #####: 3572:	if (OPT_ISSET(ops,'w'))
    #####: 3573:	    returnval = dump_autoload(name, *argv, on, ops, func);
    #####: 3574:	else if ((shf = (Shfunc) shfunctab->getnode(shfunctab, *argv))) {
        -: 3575:	    /* if any flag was given */
    #####: 3576:	    if (on|off) {
        -: 3577:		/* turn on/off the given flags */
    #####: 3578:		shf->node.flags = (shf->node.flags | (on & ~PM_UNDEFINED)) & ~off;
    #####: 3579:		if (check_autoload(shf, shf->node.nam, ops, func))
    #####: 3580:		    returnval = 1;
        -: 3581:	    } else
        -: 3582:		/* no flags, so just print */
    #####: 3583:		printshfuncexpand(&shf->node, pflags, expand);
    #####: 3584:	} else if (on & PM_UNDEFINED) {
    #####: 3585:	    int signum = -1, ok = 1;
        -: 3586:
    #####: 3587:	    if (!strncmp(*argv, "TRAP", 4) &&
    #####: 3588:		(signum = getsignum(*argv + 4)) != -1) {
        -: 3589:		/*
        -: 3590:		 * Because of the possibility of alternative names,
        -: 3591:		 * we must remove the trap explicitly.
        -: 3592:		 */
    #####: 3593:		removetrapnode(signum);
        -: 3594:	    }
        -: 3595:
    #####: 3596:	    if (**argv == '/') {
    #####: 3597:		char *base = strrchr(*argv, '/') + 1;
    #####: 3598:		if (*base &&
    #####: 3599:		    (shf = (Shfunc) shfunctab->getnode(shfunctab, base))) {
        -: 3600:		    char *dir;
        -: 3601:		    /* turn on/off the given flags */
    #####: 3602:		    shf->node.flags =
    #####: 3603:			(shf->node.flags | (on & ~PM_UNDEFINED)) & ~off;
    #####: 3604:		    if (shf->node.flags & PM_UNDEFINED) {
        -: 3605:			/* update path if not yet loaded */
    #####: 3606:			if (base == *argv + 1)
    #####: 3607:			    dir = "/";
        -: 3608:			else {
    #####: 3609:			    dir = *argv;
    #####: 3610:			    base[-1] = '\0';
        -: 3611:			}
    #####: 3612:			dircache_set(&shf->filename, NULL);
    #####: 3613:			dircache_set(&shf->filename, dir);
        -: 3614:		    }
    #####: 3615:		    if (check_autoload(shf, shf->node.nam, ops, func))
    #####: 3616:			returnval = 1;
    #####: 3617:		    continue;
        -: 3618:		}
        -: 3619:	    }
        -: 3620:
        -: 3621:	    /* Add a new undefined (autoloaded) function to the *
        -: 3622:	     * hash table with the corresponding flags set.     */
    #####: 3623:	    shf = (Shfunc) zshcalloc(sizeof *shf);
    #####: 3624:	    shf->node.flags = on;
    #####: 3625:	    shf->funcdef = mkautofn(shf);
    #####: 3626:	    shfunc_set_sticky(shf);
    #####: 3627:	    add_autoload_function(shf, *argv);
        -: 3628:
    #####: 3629:	    if (signum != -1) {
    #####: 3630:		if (settrap(signum, NULL, ZSIG_FUNC)) {
    #####: 3631:		    shfunctab->removenode(shfunctab, *argv);
    #####: 3632:		    shfunctab->freenode(&shf->node);
    #####: 3633:		    returnval = 1;
    #####: 3634:		    ok = 0;
        -: 3635:		}
        -: 3636:	    }
        -: 3637:
    #####: 3638:	    if (ok && check_autoload(shf, shf->node.nam, ops, func))
    #####: 3639:		returnval = 1;
        -: 3640:	} else
    #####: 3641:	    returnval = 1;
        -: 3642:    }
    #####: 3643:    unqueue_signals();
    #####: 3644:    return returnval;
        -: 3645:}
        -: 3646:
        -: 3647:/**/
        -: 3648:Eprog
    #####: 3649:mkautofn(Shfunc shf)
        -: 3650:{
        -: 3651:    Eprog p;
        -: 3652:
    #####: 3653:    p = (Eprog) zalloc(sizeof(*p));
    #####: 3654:    p->len = 5 * sizeof(wordcode);
    #####: 3655:    p->prog = (Wordcode) zalloc(p->len);
    #####: 3656:    p->strs = NULL;
    #####: 3657:    p->shf = shf;
    #####: 3658:    p->npats = 0;
    #####: 3659:    p->nref = 1; /* allocated from permanent storage */
    #####: 3660:    p->pats = (Patprog *) p->prog;
    #####: 3661:    p->flags = EF_REAL;
    #####: 3662:    p->dump = NULL;
        -: 3663:
    #####: 3664:    p->prog[0] = WCB_LIST((Z_SYNC | Z_END), 0);
    #####: 3665:    p->prog[1] = WCB_SUBLIST(WC_SUBLIST_END, 0, 3);
    #####: 3666:    p->prog[2] = WCB_PIPE(WC_PIPE_END, 0);
    #####: 3667:    p->prog[3] = WCB_AUTOFN();
    #####: 3668:    p->prog[4] = WCB_END();
        -: 3669:
    #####: 3670:    return p;
        -: 3671:}
        -: 3672:
        -: 3673:/* unset: unset parameters */
        -: 3674:
        -: 3675:/**/
        -: 3676:int
    #####: 3677:bin_unset(char *name, char **argv, Options ops, int func)
        -: 3678:{
        -: 3679:    Param pm, next;
        -: 3680:    Patprog pprog;
        -: 3681:    char *s;
    #####: 3682:    int match = 0, returnval = 0;
        -: 3683:    int i;
        -: 3684:
        -: 3685:    /* unset -f is the same as unfunction */
    #####: 3686:    if (OPT_ISSET(ops,'f'))
    #####: 3687:	return bin_unhash(name, argv, ops, func);
        -: 3688:
        -: 3689:    /* with -m option, treat arguments as glob patterns */
    #####: 3690:    if (OPT_ISSET(ops,'m')) {
    #####: 3691:	while ((s = *argv++)) {
    #####: 3692:	    queue_signals();
        -: 3693:	    /* expand */
    #####: 3694:	    tokenize(s);
    #####: 3695:	    if ((pprog = patcompile(s, PAT_STATIC, NULL))) {
        -: 3696:		/* Go through the parameter table, and unset any matches */
    #####: 3697:		for (i = 0; i < paramtab->hsize; i++) {
    #####: 3698:		    for (pm = (Param) paramtab->nodes[i]; pm; pm = next) {
        -: 3699:			/* record pointer to next, since we may free this one */
    #####: 3700:			next = (Param) pm->node.next;
    #####: 3701:			if ((!(pm->node.flags & PM_RESTRICTED) ||
    #####: 3702:			     unset(RESTRICTED)) &&
    #####: 3703:			    pattry(pprog, pm->node.nam)) {
    #####: 3704:			    unsetparam_pm(pm, 0, 1);
    #####: 3705:			    match++;
        -: 3706:			}
        -: 3707:		    }
        -: 3708:		}
        -: 3709:	    } else {
    #####: 3710:		untokenize(s);
    #####: 3711:		zwarnnam(name, "bad pattern : %s", s);
    #####: 3712:		returnval = 1;
        -: 3713:	    }
    #####: 3714:	    unqueue_signals();
        -: 3715:	}
        -: 3716:	/* If we didn't match anything, we return 1. */
    #####: 3717:	if (!match)
    #####: 3718:	    returnval = 1;
    #####: 3719:	return returnval;
        -: 3720:    }
        -: 3721:
        -: 3722:    /* do not glob -- unset the given parameter */
    #####: 3723:    queue_signals();
    #####: 3724:    while ((s = *argv++)) {
    #####: 3725:	char *ss = strchr(s, '['), *subscript = 0;
    #####: 3726:	if (ss) {
    #####: 3727:	    char *sse = ss + strlen(ss)-1;
    #####: 3728:	    *ss = 0;
    #####: 3729:	    if (*sse == ']') {
    #####: 3730:		*sse = 0;
    #####: 3731:		subscript = dupstring(ss+1);
    #####: 3732:		*sse = ']';
        -: 3733:	    }
        -: 3734:	}
    #####: 3735:	if ((ss && !subscript) || !isident(s)) {
    #####: 3736:	    if (ss)
    #####: 3737:		*ss = '[';
    #####: 3738:	    zerrnam(name, "%s: invalid parameter name", s);
    #####: 3739:	    returnval = 1;
    #####: 3740:	    continue;
        -: 3741:	}
    #####: 3742:	pm = (Param) (paramtab == realparamtab ?
        -: 3743:		      /* getnode2() to avoid autoloading */
    #####: 3744:		      paramtab->getnode2(paramtab, s) :
    #####: 3745:		      paramtab->getnode(paramtab, s));
        -: 3746:	/*
        -: 3747:	 * Unsetting an unset variable is not an error.
        -: 3748:	 * This appears to be reasonably standard behaviour.
        -: 3749:	 */
    #####: 3750:	if (!pm)
    #####: 3751:	    continue;
    #####: 3752:	else if ((pm->node.flags & PM_RESTRICTED) && isset(RESTRICTED)) {
    #####: 3753:	    zerrnam(name, "%s: restricted", pm->node.nam);
    #####: 3754:	    returnval = 1;
    #####: 3755:	} else if (ss) {
    #####: 3756:	    if (PM_TYPE(pm->node.flags) == PM_HASHED) {
    #####: 3757:		HashTable tht = paramtab;
    #####: 3758:		if ((paramtab = pm->gsu.h->getfn(pm)))
    #####: 3759:		    unsetparam(subscript);
    #####: 3760:		paramtab = tht;
    #####: 3761:	    } else if (PM_TYPE(pm->node.flags) == PM_SCALAR ||
    #####: 3762:		       PM_TYPE(pm->node.flags) == PM_ARRAY) {
        -: 3763:		struct value vbuf;
    #####: 3764:		vbuf.isarr = (PM_TYPE(pm->node.flags) == PM_ARRAY ?
    #####: 3765:			      SCANPM_ARRONLY : 0);
    #####: 3766:		vbuf.pm = pm;
    #####: 3767:		vbuf.flags = 0;
    #####: 3768:		vbuf.start = 0;
    #####: 3769:		vbuf.end = -1;
    #####: 3770:		vbuf.arr = 0;
    #####: 3771:		*ss = '[';
    #####: 3772:		if (getindex(&ss, &vbuf, SCANPM_ASSIGNING) == 0 &&
    #####: 3773:		    vbuf.pm && !(vbuf.pm->node.flags & PM_UNSET)) {
    #####: 3774:		    if (PM_TYPE(pm->node.flags) == PM_SCALAR) {
    #####: 3775:			setstrvalue(&vbuf, ztrdup(""));
        -: 3776:		    } else {
        -: 3777:			/* start is after the element for reverse index */
    #####: 3778:			int start = vbuf.start - !!(vbuf.flags & VALFLAG_INV);
    #####: 3779:			if (arrlen_gt(vbuf.pm->u.arr, start)) {
        -: 3780:			    char *arr[2];
    #####: 3781:			    arr[0] = "";
    #####: 3782:			    arr[1] = 0;
    #####: 3783:			    setarrvalue(&vbuf, zarrdup(arr));
        -: 3784:			}
        -: 3785:		    }
        -: 3786:		}
    #####: 3787:		returnval = errflag;
    #####: 3788:		errflag &= ~ERRFLAG_ERROR;
        -: 3789:	    } else {
    #####: 3790:		zerrnam(name, "%s: invalid element for unset", s);
    #####: 3791:		returnval = 1;
        -: 3792:	    }
        -: 3793:	} else {
    #####: 3794:	    if (unsetparam_pm(pm, 0, 1))
    #####: 3795:		returnval = 1;
        -: 3796:	}
    #####: 3797:	if (ss)
    #####: 3798:	    *ss = '[';
        -: 3799:    }
    #####: 3800:    unqueue_signals();
    #####: 3801:    return returnval;
        -: 3802:}
        -: 3803:
        -: 3804:/* type, whence, which, command */
        -: 3805:
        -: 3806:static LinkList matchednodes;
        -: 3807:
        -: 3808:static void
    #####: 3809:fetchcmdnamnode(HashNode hn, UNUSED(int printflags))
        -: 3810:{
    #####: 3811:    Cmdnam cn = (Cmdnam) hn;
    #####: 3812:    addlinknode(matchednodes, cn->node.nam);
    #####: 3813:}
        -: 3814:
        -: 3815:/**/
        -: 3816:int
    #####: 3817:bin_whence(char *nam, char **argv, Options ops, int func)
        -: 3818:{
        -: 3819:    HashNode hn;
        -: 3820:    Patprog pprog;
    #####: 3821:    int returnval = 0;
    #####: 3822:    int printflags = 0;
        -: 3823:    int aliasflags;
        -: 3824:    int csh, all, v, wd;
    #####: 3825:    int informed = 0;
    #####: 3826:    int expand = 0;
    #####: 3827:    char *cnam, **allmatched = 0;
        -: 3828:
        -: 3829:    /* Check some option information */
    #####: 3830:    csh = OPT_ISSET(ops,'c');
    #####: 3831:    v   = OPT_ISSET(ops,'v');
    #####: 3832:    all = OPT_ISSET(ops,'a');
    #####: 3833:    wd  = OPT_ISSET(ops,'w');
        -: 3834:
    #####: 3835:    if (OPT_ISSET(ops,'x')) {
        -: 3836:	char *eptr;
    #####: 3837:	expand = (int)zstrtol(OPT_ARG(ops,'x'), &eptr, 10);
    #####: 3838:	if (*eptr) {
    #####: 3839:	    zwarnnam(nam, "number expected after -x");
    #####: 3840:	    return 1;
        -: 3841:	}
    #####: 3842:	if (expand == 0)	/* no indentation at all */
    #####: 3843:	    expand = -1;
        -: 3844:    }
        -: 3845:
    #####: 3846:    if (OPT_ISSET(ops,'w'))
    #####: 3847:	printflags |= PRINT_WHENCE_WORD;
    #####: 3848:    else if (OPT_ISSET(ops,'c'))
    #####: 3849:	printflags |= PRINT_WHENCE_CSH;
    #####: 3850:    else if (OPT_ISSET(ops,'v'))
    #####: 3851:	printflags |= PRINT_WHENCE_VERBOSE;
        -: 3852:    else
    #####: 3853:	printflags |= PRINT_WHENCE_SIMPLE;
    #####: 3854:    if (OPT_ISSET(ops,'f'))
    #####: 3855:	printflags |= PRINT_WHENCE_FUNCDEF;
        -: 3856:
    #####: 3857:    if (func == BIN_COMMAND)
    #####: 3858:	if (OPT_ISSET(ops,'V')) {
    #####: 3859:	    printflags = aliasflags = PRINT_WHENCE_VERBOSE;
    #####: 3860:	    v = 1;
        -: 3861:	} else {
    #####: 3862:	    aliasflags = PRINT_LIST;
    #####: 3863:	    printflags = PRINT_WHENCE_SIMPLE;
    #####: 3864:	    v = 0;
        -: 3865:	}
        -: 3866:    else
    #####: 3867:	aliasflags = printflags;
        -: 3868:
        -: 3869:    /* With -m option -- treat arguments as a glob patterns */
    #####: 3870:    if (OPT_ISSET(ops,'m')) {
    #####: 3871:	cmdnamtab->filltable(cmdnamtab);
    #####: 3872:	if (all) {
    #####: 3873:	    pushheap();
    #####: 3874:	    matchednodes = newlinklist();
        -: 3875:	}
    #####: 3876:	queue_signals();
    #####: 3877:	for (; *argv; argv++) {
        -: 3878:	    /* parse the pattern */
    #####: 3879:	    tokenize(*argv);
    #####: 3880:	    if (!(pprog = patcompile(*argv, PAT_STATIC, NULL))) {
    #####: 3881:		untokenize(*argv);
    #####: 3882:		zwarnnam(nam, "bad pattern : %s", *argv);
    #####: 3883:		returnval = 1;
    #####: 3884:		continue;
        -: 3885:	    }
    #####: 3886:	    if (!OPT_ISSET(ops,'p')) {
        -: 3887:		/* -p option is for path search only.    *
        -: 3888:		 * We're not using it, so search for ... */
        -: 3889:
        -: 3890:		/* aliases ... */
    #####: 3891:		informed +=
    #####: 3892:		scanmatchtable(aliastab, pprog, 1, 0, DISABLED,
    #####: 3893:			       aliastab->printnode, printflags);
        -: 3894:
        -: 3895:		/* and reserved words ... */
    #####: 3896:		informed +=
    #####: 3897:		scanmatchtable(reswdtab, pprog, 1, 0, DISABLED,
    #####: 3898:			       reswdtab->printnode, printflags);
        -: 3899:
        -: 3900:		/* and shell functions... */
    #####: 3901:		informed +=
    #####: 3902:		scanmatchshfunc(pprog, 1, 0, DISABLED,
    #####: 3903:			       shfunctab->printnode, printflags, expand);
        -: 3904:
        -: 3905:		/* and builtins. */
    #####: 3906:		informed +=
    #####: 3907:		scanmatchtable(builtintab, pprog, 1, 0, DISABLED,
    #####: 3908:			       builtintab->printnode, printflags);
        -: 3909:	    }
        -: 3910:	    /* Done search for `internal' commands, if the -p option *
        -: 3911:	     * was not used.  Now search the path.                   */
    #####: 3912:	    informed +=
    #####: 3913:	    scanmatchtable(cmdnamtab, pprog, 1, 0, 0,
    #####: 3914:			   (all ? fetchcmdnamnode : cmdnamtab->printnode),
        -: 3915:			   printflags);
    #####: 3916:	    run_queued_signals();
        -: 3917:	}
    #####: 3918:	unqueue_signals();
    #####: 3919:	if (all) {
    #####: 3920:	    allmatched = argv = zlinklist2array(matchednodes, 1);
    #####: 3921:	    matchednodes = NULL;
    #####: 3922:	    popheap();
        -: 3923:	} else
    #####: 3924:	    return returnval || !informed;
        -: 3925:    }
        -: 3926:
        -: 3927:    /* Take arguments literally -- do not glob */
    #####: 3928:    queue_signals();
    #####: 3929:    for (; *argv; argv++) {
    #####: 3930:	if (!OPT_ISSET(ops,'p') && !allmatched) {
        -: 3931:	    char *suf;
        -: 3932:
        -: 3933:	    /* Look for alias */
    #####: 3934:	    if ((hn = aliastab->getnode(aliastab, *argv))) {
    #####: 3935:		aliastab->printnode(hn, aliasflags);
    #####: 3936:		informed = 1;
    #####: 3937:		if (!all)
    #####: 3938:		    continue;
        -: 3939:	    }
        -: 3940:	    /* Look for suffix alias */
    #####: 3941:	    if ((suf = strrchr(*argv, '.')) && suf[1] &&
    #####: 3942:		suf > *argv && suf[-1] != Meta &&
    #####: 3943:		(hn = sufaliastab->getnode(sufaliastab, suf+1))) {
    #####: 3944:		sufaliastab->printnode(hn, printflags);
    #####: 3945:		informed = 1;
    #####: 3946:		if (!all)
    #####: 3947:		    continue;
        -: 3948:	    }
        -: 3949:	    /* Look for reserved word */
    #####: 3950:	    if ((hn = reswdtab->getnode(reswdtab, *argv))) {
    #####: 3951:		reswdtab->printnode(hn, printflags);
    #####: 3952:		informed = 1;
    #####: 3953:		if (!all)
    #####: 3954:		    continue;
        -: 3955:	    }
        -: 3956:	    /* Look for shell function */
    #####: 3957:	    if ((hn = shfunctab->getnode(shfunctab, *argv))) {
    #####: 3958:		printshfuncexpand(hn, printflags, expand);
    #####: 3959:		informed = 1;
    #####: 3960:		if (!all)
    #####: 3961:		    continue;
        -: 3962:	    }
        -: 3963:	    /* Look for builtin command */
    #####: 3964:	    if ((hn = builtintab->getnode(builtintab, *argv))) {
    #####: 3965:		builtintab->printnode(hn, printflags);
    #####: 3966:		informed = 1;
    #####: 3967:		if (!all)
    #####: 3968:		    continue;
        -: 3969:	    }
        -: 3970:	    /* Look for commands that have been added to the *
        -: 3971:	     * cmdnamtab with the builtin `hash foo=bar'.    */
    #####: 3972:	    if ((hn = cmdnamtab->getnode(cmdnamtab, *argv)) && (hn->flags & HASHED)) {
    #####: 3973:		cmdnamtab->printnode(hn, printflags);
    #####: 3974:		informed = 1;
    #####: 3975:		if (!all)
    #####: 3976:		    continue;
        -: 3977:	    }
        -: 3978:	}
        -: 3979:
        -: 3980:	/* Option -a is to search the entire path, *
        -: 3981:	 * rather than just looking for one match. */
    #####: 3982:	if (all && **argv != '/') {
        -: 3983:	    char **pp, *buf;
        -: 3984:
    #####: 3985:	    pushheap();
    #####: 3986:	    for (pp = path; *pp; pp++) {
    #####: 3987:		if (**pp) {
    #####: 3988:		    buf = zhtricat(*pp, "/", *argv);
    #####: 3989:		} else buf = dupstring(*argv);
        -: 3990:
    #####: 3991:		if (iscom(buf)) {
    #####: 3992:		    if (wd) {
    #####: 3993:			printf("%s: command\n", *argv);
        -: 3994:		    } else {
    #####: 3995:			if (v && !csh) {
    #####: 3996:			    zputs(*argv, stdout), fputs(" is ", stdout);
    #####: 3997:			    quotedzputs(buf, stdout);
        -: 3998:			} else
    #####: 3999:			    zputs(buf, stdout);
    #####: 4000:			if (OPT_ISSET(ops,'s') || OPT_ISSET(ops, 'S'))
    #####: 4001:			    print_if_link(buf, OPT_ISSET(ops, 'S'));
    #####: 4002:			fputc('\n', stdout);
        -: 4003:		    }
    #####: 4004:		    informed = 1;
        -: 4005:		}
        -: 4006:	    }
    #####: 4007:	    if (!informed && (wd || v || csh)) {
        -: 4008:		/* this is information and not an error so, as in csh, use stdout */
    #####: 4009:		zputs(*argv, stdout);
    #####: 4010:		puts(wd ? ": none" : " not found");
    #####: 4011:		returnval = 1;
        -: 4012:	    }
    #####: 4013:	    popheap();
    #####: 4014:	} else if (func == BIN_COMMAND && OPT_ISSET(ops,'p') &&
    #####: 4015:		   (hn = builtintab->getnode(builtintab, *argv))) {
        -: 4016:	    /*
        -: 4017:	     * Special case for "command -p[vV]" which needs to
        -: 4018:	     * show a builtin in preference to an external command.
        -: 4019:	     */
    #####: 4020:	    builtintab->printnode(hn, printflags);
    #####: 4021:	    informed = 1;
    #####: 4022:	} else if ((cnam = findcmd(*argv, 1,
        -: 4023:				   func == BIN_COMMAND &&
    #####: 4024:				   OPT_ISSET(ops,'p')))) {
        -: 4025:	    /* Found external command. */
    #####: 4026:	    if (wd) {
    #####: 4027:		printf("%s: command\n", *argv);
        -: 4028:	    } else {
    #####: 4029:		if (v && !csh) {
    #####: 4030:		    zputs(*argv, stdout), fputs(" is ", stdout);
    #####: 4031:		    quotedzputs(cnam, stdout);
        -: 4032:		} else
    #####: 4033:		    zputs(cnam, stdout);
    #####: 4034:		if (OPT_ISSET(ops,'s') || OPT_ISSET(ops,'S'))
    #####: 4035:		    print_if_link(cnam, OPT_ISSET(ops,'S'));
    #####: 4036:		fputc('\n', stdout);
        -: 4037:	    }
    #####: 4038:	    informed = 1;
        -: 4039:	} else {
        -: 4040:	    /* Not found at all. That's not an error as such so this goes to stdout */
    #####: 4041:	    if (v || csh || wd)
    #####: 4042:		zputs(*argv, stdout), puts(wd ? ": none" : " not found");
    #####: 4043:	    returnval = 1;
        -: 4044:	}
        -: 4045:    }
    #####: 4046:    if (allmatched)
    #####: 4047:	freearray(allmatched);
        -: 4048:
    #####: 4049:    unqueue_signals();
    #####: 4050:    return returnval || !informed;
        -: 4051:}
        -: 4052:
        -: 4053:/**** command & named directory hash table builtins ****/
        -: 4054:
        -: 4055:/*****************************************************************
        -: 4056: * hash -- explicitly hash a command.                            *
        -: 4057: * 1) Given no arguments, list the hash table.                   *
        -: 4058: * 2) The -m option prints out commands in the hash table that   *
        -: 4059: *    match a given glob pattern.                                *
        -: 4060: * 3) The -f option causes the entire path to be added to the    *
        -: 4061: *    hash table (cannot be combined with any arguments).        *
        -: 4062: * 4) The -r option causes the entire hash table to be discarded *
        -: 4063: *    (cannot be combined with any arguments).                   *
        -: 4064: * 5) Given argument of the form foo=bar, add element to command *
        -: 4065: *    hash table, so that when `foo' is entered, then `bar' is   *
        -: 4066: *    executed.                                                  *
        -: 4067: * 6) Given arguments not of the previous form, add it to the    *
        -: 4068: *    command hash table as if it were being executed.           *
        -: 4069: * 7) The -d option causes analogous things to be done using     *
        -: 4070: *    the named directory hash table.                            *
        -: 4071: *****************************************************************/
        -: 4072:
        -: 4073:/**/
        -: 4074:int
    #####: 4075:bin_hash(char *name, char **argv, Options ops, UNUSED(int func))
        -: 4076:{
        -: 4077:    HashTable ht;
        -: 4078:    Patprog pprog;
        -: 4079:    Asgment asg;
    #####: 4080:    int returnval = 0;
    #####: 4081:    int printflags = 0;
        -: 4082:
    #####: 4083:    if (OPT_ISSET(ops,'d'))
    #####: 4084:	ht = nameddirtab;
        -: 4085:    else
    #####: 4086:	ht = cmdnamtab;
        -: 4087:
    #####: 4088:    if (OPT_ISSET(ops,'r') || OPT_ISSET(ops,'f')) {
        -: 4089:	/* -f and -r can't be used with any arguments */
    #####: 4090:	if (*argv) {
    #####: 4091:	    zwarnnam("hash", "too many arguments");
    #####: 4092:	    return 1;
        -: 4093:	}
        -: 4094:
        -: 4095:	/* empty the hash table */
    #####: 4096:	if (OPT_ISSET(ops,'r'))
    #####: 4097:	    ht->emptytable(ht);
        -: 4098:
        -: 4099:	/* fill the hash table in a standard way */
    #####: 4100:	if (OPT_ISSET(ops,'f'))
    #####: 4101:	    ht->filltable(ht);
        -: 4102:
    #####: 4103:	return 0;
        -: 4104:    }
        -: 4105:
    #####: 4106:    if (OPT_ISSET(ops,'L')) printflags |= PRINT_LIST;
        -: 4107:
        -: 4108:    /* Given no arguments, display current hash table. */
    #####: 4109:    if (!*argv) {
    #####: 4110:	queue_signals();
    #####: 4111:	scanhashtable(ht, 1, 0, 0, ht->printnode, printflags);
    #####: 4112:	unqueue_signals();
    #####: 4113:	return 0;
        -: 4114:    }
        -: 4115:
    #####: 4116:    queue_signals();
    #####: 4117:    while (*argv) {
        -: 4118:	void *hn;
    #####: 4119:	if (OPT_ISSET(ops,'m')) {
        -: 4120:	    /* with the -m option, treat the argument as a glob pattern */
    #####: 4121:	    tokenize(*argv);  /* expand */
    #####: 4122:	    if ((pprog = patcompile(*argv, PAT_STATIC, NULL))) {
        -: 4123:		/* display matching hash table elements */
    #####: 4124:		scanmatchtable(ht, pprog, 1, 0, 0, ht->printnode, printflags);
        -: 4125:	    } else {
    #####: 4126:		untokenize(*argv);
    #####: 4127:		zwarnnam(name, "bad pattern : %s", *argv);
    #####: 4128:		returnval = 1;
        -: 4129:	    }
    #####: 4130:	    argv++;
    #####: 4131:            continue;
        -: 4132:	}
    #####: 4133:        if (!(asg = getasg(&argv, NULL))) {
    #####: 4134:	    zwarnnam(name, "bad assignment");
    #####: 4135:	    returnval = 1;
    #####: 4136:	    break;
    #####: 4137:        } else if (ASG_VALUEP(asg)) {
    #####: 4138:	    if(isset(RESTRICTED)) {
    #####: 4139:		zwarnnam(name, "restricted: %s", asg->value.scalar);
    #####: 4140:		returnval = 1;
        -: 4141:	    } else {
        -: 4142:		/* The argument is of the form foo=bar, *
        -: 4143:		 * so define an entry for the table.    */
    #####: 4144:		if(OPT_ISSET(ops,'d')) {
        -: 4145:		    /* shouldn't return NULL if asg->name is not NULL */
    #####: 4146:		    if (*itype_end(asg->name, IUSER, 0)) {
    #####: 4147:			zwarnnam(name,
        -: 4148:				 "invalid character in directory name: %s",
        -: 4149:				 asg->name);
    #####: 4150:			returnval = 1;
    #####: 4151:			continue;
        -: 4152:		    } else {
    #####: 4153:			Nameddir nd = hn = zshcalloc(sizeof *nd);
    #####: 4154:			nd->node.flags = 0;
    #####: 4155:			nd->dir = ztrdup(asg->value.scalar);
        -: 4156:		    }
        -: 4157:		} else {
    #####: 4158:		    Cmdnam cn = hn = zshcalloc(sizeof *cn);
    #####: 4159:		    cn->node.flags = HASHED;
    #####: 4160:		    cn->u.cmd = ztrdup(asg->value.scalar);
        -: 4161:		}
    #####: 4162:		ht->addnode(ht, ztrdup(asg->name), hn);
    #####: 4163:		if(OPT_ISSET(ops,'v'))
    #####: 4164:		    ht->printnode(hn, 0);
        -: 4165:	    }
    #####: 4166:	} else if (!(hn = ht->getnode2(ht, asg->name))) {
        -: 4167:	    /* With no `=value' part to the argument, *
        -: 4168:	     * work out what it ought to be.          */
    #####: 4169:	    if(OPT_ISSET(ops,'d')) {
    #####: 4170:		if(!getnameddir(asg->name)) {
    #####: 4171:		    zwarnnam(name, "no such directory name: %s", asg->name);
    #####: 4172:		    returnval = 1;
        -: 4173:		}
        -: 4174:	    } else {
    #####: 4175:		if (!hashcmd(asg->name, path)) {
    #####: 4176:		    zwarnnam(name, "no such command: %s", asg->name);
    #####: 4177:		    returnval = 1;
        -: 4178:		}
        -: 4179:	    }
    #####: 4180:	    if(OPT_ISSET(ops,'v') && (hn = ht->getnode2(ht, asg->name)))
    #####: 4181:		ht->printnode(hn, 0);
    #####: 4182:	} else if(OPT_ISSET(ops,'v'))
    #####: 4183:	    ht->printnode(hn, 0);
        -: 4184:    }
    #####: 4185:    unqueue_signals();
    #####: 4186:    return returnval;
        -: 4187:}
        -: 4188:
        -: 4189:/* unhash: remove specified elements from a hash table */
        -: 4190:
        -: 4191:/**/
        -: 4192:int
    #####: 4193:bin_unhash(char *name, char **argv, Options ops, int func)
        -: 4194:{
        -: 4195:    HashTable ht;
        -: 4196:    HashNode hn, nhn;
        -: 4197:    Patprog pprog;
    #####: 4198:    int match = 0, returnval = 0, all = 0;
        -: 4199:    int i;
        -: 4200:
        -: 4201:    /* Check which hash table we are working with. */
    #####: 4202:    if (func == BIN_UNALIAS) {
    #####: 4203:	if (OPT_ISSET(ops,'s'))
    #####: 4204:	    ht = sufaliastab;	/* suffix aliases */
        -: 4205:	else
    #####: 4206:	    ht = aliastab;	/* aliases           */
    #####: 4207:	if (OPT_ISSET(ops, 'a')) {
    #####: 4208:	    if (*argv) {
    #####: 4209:		zwarnnam(name, "-a: too many arguments");
    #####: 4210:		return 1;
        -: 4211:	    }
    #####: 4212:	    all = 1;
    #####: 4213:	} else if (!*argv) {
    #####: 4214:	    zwarnnam(name, "not enough arguments");
    #####: 4215:	    return 1;
        -: 4216:	}
    #####: 4217:    } else if (OPT_ISSET(ops,'d'))
    #####: 4218:	ht = nameddirtab;	/* named directories */
    #####: 4219:    else if (OPT_ISSET(ops,'f'))
    #####: 4220:	ht = shfunctab;		/* shell functions   */
    #####: 4221:    else if (OPT_ISSET(ops,'s'))
    #####: 4222:	ht = sufaliastab;	/* suffix aliases, must precede aliases */
    #####: 4223:    else if (func == BIN_UNHASH && (OPT_ISSET(ops,'a')))
    #####: 4224:	ht = aliastab;		/* aliases           */
        -: 4225:    else
    #####: 4226:	ht = cmdnamtab;		/* external commands */
        -: 4227:
    #####: 4228:    if (all) {
    #####: 4229:	queue_signals();
    #####: 4230:	for (i = 0; i < ht->hsize; i++) {
    #####: 4231:	    for (hn = ht->nodes[i]; hn; hn = nhn) {
        -: 4232:		/* record pointer to next, since we may free this one */
    #####: 4233:		nhn = hn->next;
    #####: 4234:		ht->freenode(ht->removenode(ht, hn->nam));
        -: 4235:	    }
        -: 4236:	}
    #####: 4237:	unqueue_signals();
    #####: 4238:	return 0;
        -: 4239:    }
        -: 4240:
        -: 4241:    /* With -m option, treat arguments as glob patterns. *
        -: 4242:     * "unhash -m '*'" is legal, but not recommended.    */
    #####: 4243:    if (OPT_ISSET(ops,'m')) {
    #####: 4244:	for (; *argv; argv++) {
    #####: 4245:	    queue_signals();
        -: 4246:	    /* expand argument */
    #####: 4247:	    tokenize(*argv);
    #####: 4248:	    if ((pprog = patcompile(*argv, PAT_STATIC, NULL))) {
        -: 4249:		/* remove all nodes matching glob pattern */
    #####: 4250:		for (i = 0; i < ht->hsize; i++) {
    #####: 4251:		    for (hn = ht->nodes[i]; hn; hn = nhn) {
        -: 4252:			/* record pointer to next, since we may free this one */
    #####: 4253:			nhn = hn->next;
    #####: 4254:			if (pattry(pprog, hn->nam)) {
    #####: 4255:			    ht->freenode(ht->removenode(ht, hn->nam));
    #####: 4256:			    match++;
        -: 4257:			}
        -: 4258:		    }
        -: 4259:		}
        -: 4260:	    } else {
    #####: 4261:		untokenize(*argv);
    #####: 4262:		zwarnnam(name, "bad pattern : %s", *argv);
    #####: 4263:		returnval = 1;
        -: 4264:	    }
    #####: 4265:	    unqueue_signals();
        -: 4266:	}
        -: 4267:	/* If we didn't match anything, we return 1. */
    #####: 4268:	if (!match)
    #####: 4269:	    returnval = 1;
    #####: 4270:	return returnval;
        -: 4271:    }
        -: 4272:
        -: 4273:    /* Take arguments literally -- do not glob */
    #####: 4274:    queue_signals();
    #####: 4275:    for (; *argv; argv++) {
    #####: 4276:	if ((hn = ht->removenode(ht, *argv))) {
    #####: 4277:	    ht->freenode(hn);
    #####: 4278:	} else if (func == BIN_UNSET && isset(POSIXBUILTINS)) {
        -: 4279:	    /* POSIX: unset: "Unsetting a variable or function that was *
        -: 4280:	     * not previously set shall not be considered an error."    */
    #####: 4281:	    returnval = 0;
        -: 4282:	} else {
    #####: 4283:	    zwarnnam(name, "no such hash table element: %s", *argv);
    #####: 4284:	    returnval = 1;
        -: 4285:	}
        -: 4286:    }
    #####: 4287:    unqueue_signals();
    #####: 4288:    return returnval;
        -: 4289:}
        -: 4290:
        -: 4291:/**** alias builtins ****/
        -: 4292:
        -: 4293:/* alias: display or create aliases. */
        -: 4294:
        -: 4295:/**/
        -: 4296:int
    #####: 4297:bin_alias(char *name, char **argv, Options ops, UNUSED(int func))
        -: 4298:{
        -: 4299:    Alias a;
        -: 4300:    Patprog pprog;
        -: 4301:    Asgment asg;
    #####: 4302:    int returnval = 0;
    #####: 4303:    int flags1 = 0, flags2 = DISABLED;
    #####: 4304:    int printflags = 0;
        -: 4305:    int type_opts;
    #####: 4306:    HashTable ht = aliastab;
        -: 4307:
        -: 4308:    /* Did we specify the type of alias? */
    #####: 4309:    type_opts = OPT_ISSET(ops, 'r') + OPT_ISSET(ops, 'g') +
    #####: 4310:	OPT_ISSET(ops, 's');
    #####: 4311:    if (type_opts) {
    #####: 4312:	if (type_opts > 1) {
    #####: 4313:	    zwarnnam(name, "illegal combination of options");
    #####: 4314:	    return 1;
        -: 4315:	}
    #####: 4316:	if (OPT_ISSET(ops,'g'))
    #####: 4317:	    flags1 |= ALIAS_GLOBAL;
        -: 4318:	else
    #####: 4319:	    flags2 |= ALIAS_GLOBAL;
    #####: 4320:	if (OPT_ISSET(ops, 's')) {
        -: 4321:	    /*
        -: 4322:	     * Although we keep suffix aliases in a different table,
        -: 4323:	     * it is useful to be able to distinguish Alias structures
        -: 4324:	     * without reference to the table, so we have a separate
        -: 4325:	     * flag, too.
        -: 4326:	     */
    #####: 4327:	    flags1 |= ALIAS_SUFFIX;
    #####: 4328:	    ht = sufaliastab;
        -: 4329:	} else
    #####: 4330:	    flags2 |= ALIAS_SUFFIX;
        -: 4331:    }
        -: 4332:
    #####: 4333:    if (OPT_ISSET(ops,'L'))
    #####: 4334:	printflags |= PRINT_LIST;
    #####: 4335:    else if (OPT_PLUS(ops,'g') || OPT_PLUS(ops,'r') || OPT_PLUS(ops,'s') ||
    #####: 4336:	     OPT_PLUS(ops,'m') || OPT_ISSET(ops,'+'))
    #####: 4337:	printflags |= PRINT_NAMEONLY;
        -: 4338:
        -: 4339:    /* In the absence of arguments, list all aliases.  If a command *
        -: 4340:     * line flag is specified, list only those of that type.        */
    #####: 4341:    if (!*argv) {
    #####: 4342:	queue_signals();
    #####: 4343:	scanhashtable(ht, 1, flags1, flags2, ht->printnode, printflags);
    #####: 4344:	unqueue_signals();
    #####: 4345:	return 0;
        -: 4346:    }
        -: 4347:
        -: 4348:    /* With the -m option, treat the arguments as *
        -: 4349:     * glob patterns of aliases to display.       */
    #####: 4350:    if (OPT_ISSET(ops,'m')) {
    #####: 4351:	for (; *argv; argv++) {
    #####: 4352:	    queue_signals();
    #####: 4353:	    tokenize(*argv);  /* expand argument */
    #####: 4354:	    if ((pprog = patcompile(*argv, PAT_STATIC, NULL))) {
        -: 4355:		/* display the matching aliases */
    #####: 4356:		scanmatchtable(ht, pprog, 1, flags1, flags2,
        -: 4357:			       ht->printnode, printflags);
        -: 4358:	    } else {
    #####: 4359:		untokenize(*argv);
    #####: 4360:		zwarnnam(name, "bad pattern : %s", *argv);
    #####: 4361:		returnval = 1;
        -: 4362:	    }
    #####: 4363:	    unqueue_signals();
        -: 4364:	}
    #####: 4365:	return returnval;
        -: 4366:    }
        -: 4367:
        -: 4368:    /* Take arguments literally.  Don't glob */
    #####: 4369:    queue_signals();
    #####: 4370:    while ((asg = getasg(&argv, NULL))) {
    #####: 4371:	if (asg->value.scalar && !OPT_ISSET(ops,'L')) {
        -: 4372:	    /* The argument is of the form foo=bar and we are not *
        -: 4373:	     * forcing a listing with -L, so define an alias      */
    #####: 4374:	    ht->addnode(ht, ztrdup(asg->name),
    #####: 4375:			createaliasnode(ztrdup(asg->value.scalar), flags1));
    #####: 4376:	} else if ((a = (Alias) ht->getnode(ht, asg->name))) {
        -: 4377:	    /* display alias if appropriate */
    #####: 4378:	    if (!type_opts || ht == sufaliastab ||
    #####: 4379:		(OPT_ISSET(ops,'r') &&
    #####: 4380:		 !(a->node.flags & (ALIAS_GLOBAL|ALIAS_SUFFIX))) ||
    #####: 4381:		(OPT_ISSET(ops,'g') && (a->node.flags & ALIAS_GLOBAL)))
    #####: 4382:		ht->printnode(&a->node, printflags);
        -: 4383:	} else
    #####: 4384:	    returnval = 1;
        -: 4385:    }
    #####: 4386:    unqueue_signals();
    #####: 4387:    return returnval;
        -: 4388:}
        -: 4389:
        -: 4390:
        -: 4391:/**** miscellaneous builtins ****/
        -: 4392:
        -: 4393:/* true, : (colon) */
        -: 4394:
        -: 4395:/**/
        -: 4396:int
      407: 4397:bin_true(UNUSED(char *name), UNUSED(char **argv), UNUSED(Options ops), UNUSED(int func))
        -: 4398:{
      407: 4399:    return 0;
        -: 4400:}
        -: 4401:
        -: 4402:/* false builtin */
        -: 4403:
        -: 4404:/**/
        -: 4405:int
    #####: 4406:bin_false(UNUSED(char *name), UNUSED(char **argv), UNUSED(Options ops), UNUSED(int func))
        -: 4407:{
    #####: 4408:    return 1;
        -: 4409:}
        -: 4410:
        -: 4411:/* the zle buffer stack */
        -: 4412:
        -: 4413:/**/
        -: 4414:mod_export LinkList bufstack;
        -: 4415:
        -: 4416:/* echo, print, printf, pushln */
        -: 4417:
        -: 4418:#define print_val(VAL) \
        -: 4419:    if (prec >= 0) \
        -: 4420:	count += fprintf(fout, spec, width, prec, VAL); \
        -: 4421:    else \
        -: 4422:	count += fprintf(fout, spec, width, VAL);
        -: 4423:
        -: 4424:/*
        -: 4425: * Because of the use of getkeystring() to interpret the arguments,
        -: 4426: * the elements of args spend a large part of the function unmetafied
        -: 4427: * with the lengths in len.  This may have seemed a good idea once.
        -: 4428: * As we are stuck with this for now, we need to be very careful
        -: 4429: * deciding what state args is in.
        -: 4430: */
        -: 4431:
        -: 4432:/**/
        -: 4433:int
      137: 4434:bin_print(char *name, char **args, Options ops, int func)
        -: 4435:{
      137: 4436:    int flen, width, prec, type, argc, n, narg, curlen = 0;
      137: 4437:    int nnl = 0, fmttrunc = 0, ret = 0, maxarg = 0, nc = 0;
      137: 4438:    int flags[6], *len, visarr = 0;
      137: 4439:    char *start, *endptr, *c, *d, *flag, *buf = NULL, spec[14], *fmt = NULL;
      137: 4440:    char **first, **argp, *curarg, *flagch = "'0+- #", save = '\0', nullstr = '\0';
      137: 4441:    size_t rcount = 0, count = 0;
      137: 4442:    size_t *cursplit = 0, *splits = 0;
      137: 4443:    FILE *fout = stdout;
        -: 4444:#ifdef HAVE_OPEN_MEMSTREAM
        -: 4445:    size_t mcount;
        -: 4446:#define ASSIGN_MSTREAM(BUF,FOUT) \
        -: 4447:    do { \
        -: 4448:        if ((FOUT = open_memstream(&BUF, &mcount)) == NULL) { \
        -: 4449:            zwarnnam(name, "open_memstream failed"); \
        -: 4450:            return 1; \
        -: 4451:        } \
        -: 4452:    } while (0)
        -: 4453:    /*
        -: 4454:     * Some implementations of open_memstream() have a bug such that,
        -: 4455:     * if fflush() is followed by fclose(), another NUL byte is written
        -: 4456:     * to the buffer at the wrong position.  Therefore we must fclose()
        -: 4457:     * before reading.
        -: 4458:     */
        -: 4459:#define READ_MSTREAM(BUF,FOUT) \
        -: 4460:    ((fclose(FOUT) == 0) ? mcount : (size_t)-1)
        -: 4461:#define CLOSE_MSTREAM(FOUT) 0
        -: 4462:
        -: 4463:#else /* simulate HAVE_OPEN_MEMSTREAM */
        -: 4464:
        -: 4465:#define ASSIGN_MSTREAM(BUF,FOUT) \
        -: 4466:    do { \
        -: 4467:        int tempfd; \
        -: 4468:        char *tmpf; \
        -: 4469:        if ((tempfd = gettempfile(NULL, 1, &tmpf)) < 0) { \
        -: 4470:            zwarnnam(name, "can't open temp file: %e", errno); \
        -: 4471:            return 1; \
        -: 4472:        } \
        -: 4473:        unlink(tmpf); \
        -: 4474:        if ((FOUT = fdopen(tempfd, "w+")) == NULL) { \
        -: 4475:            close(tempfd); \
        -: 4476:            zwarnnam(name, "can't open temp file: %e", errno); \
        -: 4477:            return 1; \
        -: 4478:        } \
        -: 4479:    } while (0)
        -: 4480:#define READ_MSTREAM(BUF,FOUT) \
        -: 4481:    ((((count = ftell(FOUT)), (BUF = (char *)zalloc(count + 1))) && \
        -: 4482:      ((fseek(FOUT, 0L, SEEK_SET) == 0) && !(BUF[count] = '\0')) && \
        -: 4483:      (fread(BUF, 1, count, FOUT) == count)) ? count : (size_t)-1)
        -: 4484:#define CLOSE_MSTREAM(FOUT) fclose(FOUT)
        -: 4485:
        -: 4486:#endif
        -: 4487:
        -: 4488:#define IS_MSTREAM(FOUT) \
        -: 4489:    (FOUT != stdout && \
        -: 4490:     (OPT_ISSET(ops,'z') || OPT_ISSET(ops,'s') || OPT_ISSET(ops,'v')))
        -: 4491:
        -: 4492:    /* Testing EBADF special-cases >&- redirections */
        -: 4493:#define CLOSE_CLEANLY(FOUT) \
        -: 4494:    (IS_MSTREAM(FOUT) ? CLOSE_MSTREAM(FOUT) == 0 : \
        -: 4495:     ((FOUT == stdout) ? (fflush(FOUT) == 0 || errno == EBADF) : \
        -: 4496:      (fclose(FOUT) == 0)))	/* implies error for -u on a closed fd */
        -: 4497:
        -: 4498:    Histent ent;
        -: 4499:    mnumber mnumval;
        -: 4500:    double doubleval;
        -: 4501:    int intval;
        -: 4502:    zlong zlongval;
        -: 4503:    zulong zulongval;
        -: 4504:    char *stringval;
        -: 4505:
        -: 4506:    /* Error check option combinations and option arguments */
        -: 4507:
      411: 4508:    if (OPT_ISSET(ops, 'z') +
      411: 4509:	OPT_ISSET(ops, 's') + OPT_ISSET(ops, 'S') +
      137: 4510:	OPT_ISSET(ops, 'v') > 1) {
    #####: 4511:	zwarnnam(name, "only one of -s, -S, -v, or -z allowed");
    #####: 4512:	return 1;
        -: 4513:    }
      274: 4514:    if ((OPT_ISSET(ops, 'z') | OPT_ISSET(ops, 's') | OPT_ISSET(ops, 'S')) +
      137: 4515:	(OPT_ISSET(ops, 'c') | OPT_ISSET(ops, 'C')) > 1) {
    #####: 4516:	zwarnnam(name, "-c or -C not allowed with -s, -S, or -z");
    #####: 4517:	return 1;
        -: 4518:    }
      411: 4519:    if ((OPT_ISSET(ops, 'z') | OPT_ISSET(ops, 'v') |
      411: 4520:         OPT_ISSET(ops, 's') | OPT_ISSET(ops, 'S')) +
      137: 4521:	(OPT_ISSET(ops, 'p') | OPT_ISSET(ops, 'u')) > 1) {
    #####: 4522:	zwarnnam(name, "-p or -u not allowed with -s, -S, -v, or -z");
    #####: 4523:	return 1;
        -: 4524:    }
        -: 4525:    /*
        -: 4526:    if (OPT_ISSET(ops, 'f') &&
        -: 4527:	(OPT_ISSET(ops, 'S') || OPT_ISSET(ops, 'c') || OPT_ISSET(ops, 'C'))) {
        -: 4528:	zwarnnam(name, "-f not allowed with -c, -C, or -S");
        -: 4529:	return 1;
        -: 4530:    }
        -: 4531:    */
        -: 4532:
        -: 4533:    /* -C -- number of columns */
      137: 4534:    if (!fmt && OPT_ISSET(ops,'C')) {
    #####: 4535:	char *eptr, *argptr = OPT_ARG(ops,'C');
    #####: 4536:	nc = (int)zstrtol(argptr, &eptr, 10);
    #####: 4537:	if (*eptr) {
    #####: 4538:	    zwarnnam(name, "number expected after -%c: %s", 'C', argptr);
    #####: 4539:	    return 1;
        -: 4540:	}
    #####: 4541:	if (nc <= 0) {
    #####: 4542:	    zwarnnam(name, "invalid number of columns: %s", argptr);
    #####: 4543:	    return 1;
        -: 4544:	}
        -: 4545:    }
        -: 4546:
      137: 4547:    if (func == BIN_PRINTF) {
    #####: 4548:        if (!strcmp(*args, "--") && !*++args) {
    #####: 4549:            zwarnnam(name, "not enough arguments");
    #####: 4550:	    return 1;
        -: 4551:        }
    #####: 4552:  	fmt = *args++;
      137: 4553:    } else if (func == BIN_ECHO && isset(BSDECHO))
        5: 4554:	ops->ind['E'] = 1;
      132: 4555:    else if (OPT_HASARG(ops,'f'))
    #####: 4556:	fmt = OPT_ARG(ops,'f');
      137: 4557:    if (fmt)
    #####: 4558:	fmt = getkeystring(fmt, &flen, OPT_ISSET(ops,'b') ? GETKEYS_BINDKEY :
        -: 4559:			   GETKEYS_PRINTF_FMT, &fmttrunc);
        -: 4560:
      137: 4561:    first = args;
        -: 4562:
        -: 4563:    /* -m option -- treat the first argument as a pattern and remove
        -: 4564:     * arguments not matching */
      137: 4565:    if (OPT_ISSET(ops,'m')) {
        -: 4566:	Patprog pprog;
        -: 4567:	char **t, **p;
        -: 4568:
    #####: 4569:	if (!*args) {
    #####: 4570:	    zwarnnam(name, "no pattern specified");
    #####: 4571:	    return 1;
        -: 4572:	}
    #####: 4573:	queue_signals();
    #####: 4574:	tokenize(*args);
    #####: 4575:	if (!(pprog = patcompile(*args, PAT_STATIC, NULL))) {
    #####: 4576:	    untokenize(*args);
    #####: 4577:	    zwarnnam(name, "bad pattern: %s", *args);
    #####: 4578:	    unqueue_signals();
    #####: 4579:	    return 1;
        -: 4580:	}
    #####: 4581:	for (t = p = ++args; *p; p++)
    #####: 4582:	    if (pattry(pprog, *p))
    #####: 4583:		*t++ = *p;
    #####: 4584:	*t = NULL;
    #####: 4585:	first = args;
    #####: 4586:	unqueue_signals();
    #####: 4587:	if (fmt && !*args) return 0;
        -: 4588:    }
        -: 4589:    /* compute lengths, and interpret according to -P, -D, -e, etc. */
      137: 4590:    argc = arrlen(args);
      137: 4591:    len = (int *) hcalloc(argc * sizeof(int));
      309: 4592:    for (n = 0; n < argc; n++) {
        -: 4593:	/* first \ sequences */
      344: 4594:	if (fmt ||
      344: 4595:	    (!OPT_ISSET(ops,'e') &&
      344: 4596:	     (OPT_ISSET(ops,'R') || OPT_ISSET(ops,'r') || OPT_ISSET(ops,'E'))))
       23: 4597:	    unmetafy(args[n], &len[n]);
        -: 4598:	else {
        -: 4599:	    int escape_how;
      149: 4600:	    if (OPT_ISSET(ops,'b'))
    #####: 4601:		escape_how = GETKEYS_BINDKEY;
      149: 4602:	    else if (func != BIN_ECHO && !OPT_ISSET(ops,'e'))
      149: 4603:		escape_how = GETKEYS_PRINT;
        -: 4604:	    else
    #####: 4605:		escape_how = GETKEYS_ECHO;
      149: 4606:	    args[n] = getkeystring(args[n], &len[n], escape_how, &nnl);
      149: 4607:	    if (nnl) {
        -: 4608:		/* If there was a \c escape, make this the last arg. */
    #####: 4609:		argc = n + 1;
    #####: 4610:		args[argc] = NULL;
        -: 4611:	    }
        -: 4612:	}
        -: 4613:	/* -P option -- interpret as a prompt sequence */
      172: 4614:	if (OPT_ISSET(ops,'P')) {
        -: 4615:	    /*
        -: 4616:	     * promptexpand uses permanent storage: to avoid
        -: 4617:	     * messy memory management, stick it on the heap
        -: 4618:	     * instead.
        -: 4619:	     */
    #####: 4620:	    char *str = unmetafy(
    #####: 4621:		promptexpand(metafy(args[n], len[n], META_NOALLOC),
        -: 4622:			     0, NULL, NULL, NULL),
    #####: 4623:		&len[n]);
    #####: 4624:	    args[n] = dupstrpfx(str, len[n]);
    #####: 4625:	    free(str);
        -: 4626:	}
        -: 4627:	/* -D option -- interpret as a directory, and use ~ */
      172: 4628:	if (OPT_ISSET(ops,'D')) {
        -: 4629:	    Nameddir d;
        -: 4630:
    #####: 4631:	    queue_signals();
        -: 4632:	    /* TODO: finddir takes a metafied file */
    #####: 4633:	    d = finddir(args[n]);
    #####: 4634:	    if (d) {
    #####: 4635:		int dirlen = strlen(d->dir);
    #####: 4636:		char *arg = zhalloc(len[n] - dirlen + strlen(d->node.nam) + 2);
    #####: 4637:		sprintf(arg, "~%s%s", d->node.nam, args[n] + dirlen);
    #####: 4638:		args[n] = arg;
    #####: 4639:		len[n] = strlen(args[n]);
        -: 4640:	    }
    #####: 4641:	    unqueue_signals();
        -: 4642:	}
        -: 4643:    }
        -: 4644:
        -: 4645:    /* -o and -O -- sort the arguments */
      137: 4646:    if (OPT_ISSET(ops,'o') || OPT_ISSET(ops,'O')) {
        -: 4647:	int flags;
        -: 4648:
    #####: 4649:	if (fmt && !*args)
    #####: 4650:	    return 0;
    #####: 4651:	flags = OPT_ISSET(ops,'i') ? SORTIT_IGNORING_CASE : 0;
    #####: 4652:	if (OPT_ISSET(ops,'O'))
    #####: 4653:	    flags |= SORTIT_BACKWARDS;
    #####: 4654:	strmetasort(args, flags, len);
        -: 4655:    }
        -: 4656:
        -: 4657:    /* -u and -p -- output to other than standard output */
      137: 4658:    if ((OPT_HASARG(ops,'u') || OPT_ISSET(ops,'p')) &&
        -: 4659:	/* rule out conflicting options -- historical precedence */
    #####: 4660:	((!fmt && (OPT_ISSET(ops,'c') || OPT_ISSET(ops,'C'))) ||
    #####: 4661:	 !(OPT_ISSET(ops, 'z') || OPT_ISSET(ops, 'v') ||
    #####: 4662:	   OPT_ISSET(ops, 's') || OPT_ISSET(ops, 'S')))) {
        -: 4663:	int fdarg, fd;
        -: 4664:
    #####: 4665:	if (OPT_ISSET(ops, 'p')) {
    #####: 4666:	    fdarg = coprocout;
    #####: 4667:	    if (fdarg < 0) {
    #####: 4668:		zwarnnam(name, "-p: no coprocess");
    #####: 4669:		return 1;
        -: 4670:	    }
        -: 4671:	} else {
    #####: 4672:	    char *argptr = OPT_ARG(ops,'u'), *eptr;
        -: 4673:	    /* Handle undocumented feature that -up worked */
    #####: 4674:	    if (!strcmp(argptr, "p")) {
    #####: 4675:		fdarg = coprocout;
    #####: 4676:		if (fdarg < 0) {
    #####: 4677:		    zwarnnam(name, "-p: no coprocess");
    #####: 4678:		    return 1;
        -: 4679:		}
        -: 4680:	    } else {
    #####: 4681:		fdarg = (int)zstrtol(argptr, &eptr, 10);
    #####: 4682:		if (*eptr) {
    #####: 4683:		    zwarnnam(name, "number expected after -u: %s", argptr);
    #####: 4684:		    return 1;
        -: 4685:		}
        -: 4686:	    }
        -: 4687:	}
        -: 4688:
    #####: 4689:	if ((fd = dup(fdarg)) < 0) {
    #####: 4690:	    zwarnnam(name, "bad file number: %d", fdarg);
    #####: 4691:	    return 1;
        -: 4692:	}
    #####: 4693:	if ((fout = fdopen(fd, "w")) == 0) {
    #####: 4694:	    close(fd);
    #####: 4695:	    zwarnnam(name, "bad mode on fd %d", fd);
    #####: 4696:	    return 1;
        -: 4697:	}
        -: 4698:    }
        -: 4699:
      137: 4700:    if (OPT_ISSET(ops, 'v') ||
    #####: 4701:	(fmt && (OPT_ISSET(ops,'z') || OPT_ISSET(ops,'s'))))
    #####: 4702:	ASSIGN_MSTREAM(buf,fout);
        -: 4703:
        -: 4704:    /* -c -- output in columns */
      137: 4705:    if (!fmt && (OPT_ISSET(ops,'c') || OPT_ISSET(ops,'C'))) {
        -: 4706:	int l, nr, sc, n, t, i;
        -: 4707:#ifdef MULTIBYTE_SUPPORT
        -: 4708:	int *widths;
        -: 4709:
    #####: 4710:	if (isset(MULTIBYTE)) {
        -: 4711:	    int *wptr;
        -: 4712:
        -: 4713:	    /*
        -: 4714:	     * We need the character widths to align output in
        -: 4715:	     * columns.
        -: 4716:	     */
    #####: 4717:	    wptr = widths = (int *) zhalloc(argc * sizeof(int));
    #####: 4718:	    for (i = 0; i < argc && args[i]; i++, wptr++) {
    #####: 4719:		int l = len[i], width = 0;
    #####: 4720:		char *aptr = args[i];
        -: 4721:		mbstate_t mbs;
        -: 4722:
    #####: 4723:		memset(&mbs, 0, sizeof(mbstate_t));
    #####: 4724:		while (l > 0) {
        -: 4725:		    wchar_t wc;
        -: 4726:		    size_t cnt;
        -: 4727:		    int wcw;
        -: 4728:
        -: 4729:		    /*
        -: 4730:		     * Prevent misaligned columns due to escape sequences by
        -: 4731:		     * skipping over them. Octals \033 and \233 are the
        -: 4732:		     * possible escape characters recognized by ANSI.
        -: 4733:		     *
        -: 4734:		     * It ought to be possible to do this in the case
        -: 4735:		     * of prompt expansion by propagating the information
        -: 4736:		     * about escape sequences (currently we strip this
        -: 4737:		     * out).
        -: 4738:		     */
    #####: 4739:		    if (*aptr == '\033' || *aptr == '\233') {
    #####: 4740:			for (aptr++, l--;
    #####: 4741:			     l && !isalpha(STOUC(*aptr));
    #####: 4742:			     aptr++, l--)
        -: 4743:			    ;
    #####: 4744:			aptr++;
    #####: 4745:			l--;
    #####: 4746:			continue;
        -: 4747:		    }
        -: 4748:
    #####: 4749:		    cnt = mbrtowc(&wc, aptr, l, &mbs);
        -: 4750:
    #####: 4751:		    if (cnt == MB_INCOMPLETE || cnt == MB_INVALID)
        -: 4752:		    {
        -: 4753:			/* treat as ordinary string */
    #####: 4754:			width += l;
    #####: 4755:			break;
        -: 4756:		    }
    #####: 4757:		    wcw = WCWIDTH(wc);
        -: 4758:		    /* treat unprintable as 0 */
    #####: 4759:		    if (wcw > 0)
    #####: 4760:			width += wcw;
        -: 4761:		    /* skip over NUL normally */
    #####: 4762:		    if (cnt == 0)
    #####: 4763:			cnt = 1;
    #####: 4764:		    aptr += cnt;
    #####: 4765:		    l -= cnt;
        -: 4766:		}
    #####: 4767:		widths[i] = width;
        -: 4768:	    }
        -: 4769:	}
        -: 4770:	else
    #####: 4771:	    widths = len;
        -: 4772:#else
        -: 4773:	int *widths = len;
        -: 4774:#endif
        -: 4775:
    #####: 4776:	if (OPT_ISSET(ops,'C')) {
        -: 4777:	    /*
        -: 4778:	     * n: number of elements
        -: 4779:	     * nc: number of columns (above)
        -: 4780:	     * nr: number of rows
        -: 4781:	     */
    #####: 4782:	    n = arrlen(args);
    #####: 4783:	    nr = (n + nc - 1) / nc;
        -: 4784:
        -: 4785:	    /*
        -: 4786:	     * i: loop counter
        -: 4787:	     * l: maximum length seen
        -: 4788:	     *
        -: 4789:	     * Ignore lengths in last column since they don't affect
        -: 4790:	     * the separation.
        -: 4791:	     */
    #####: 4792:	    for (i = l = 0; i < argc; i++) {
    #####: 4793:		if (OPT_ISSET(ops, 'a')) {
    #####: 4794:		    if ((i % nc) == nc - 1)
    #####: 4795:			continue;
        -: 4796:		} else {
    #####: 4797:		    if (i >= nr * (nc - 1))
    #####: 4798:			break;
        -: 4799:		}
    #####: 4800:		if (l < widths[i])
    #####: 4801:		    l = widths[i];
        -: 4802:	    }
    #####: 4803:	    sc = l + 2;
        -: 4804:	}
        -: 4805:	else
        -: 4806:	{
        -: 4807:	    /*
        -: 4808:	     * n: loop counter
        -: 4809:	     * l: maximum length seen
        -: 4810:	     */
    #####: 4811:	    for (n = l = 0; n < argc; n++)
    #####: 4812:		if (l < widths[n])
    #####: 4813:		    l = widths[n];
        -: 4814:
        -: 4815:	    /*
        -: 4816:	     * sc: column width
        -: 4817:	     * nc: number of columns (at least one)
        -: 4818:	     */
    #####: 4819:	    sc = l + 2;
    #####: 4820:	    nc = (zterm_columns + 1) / sc;
    #####: 4821:	    if (!nc)
    #####: 4822:		nc = 1;
    #####: 4823:	    nr = (n + nc - 1) / nc;
        -: 4824:	}
        -: 4825:
    #####: 4826:	if (OPT_ISSET(ops,'a'))	/* print across, i.e. columns first */
    #####: 4827:	    n = 0;
    #####: 4828:	for (i = 0; i < nr; i++) {
    #####: 4829:	    if (OPT_ISSET(ops,'a'))
        -: 4830:	    {
        -: 4831:		int ic;
    #####: 4832:		for (ic = 0; ic < nc && n < argc; ic++, n++)
        -: 4833:		{
    #####: 4834:		    fwrite(args[n], len[n], 1, fout);
    #####: 4835:		    l = widths[n];
    #####: 4836:		    if (n < argc && ic < nc - 1)
    #####: 4837:			for (; l < sc; l++)
    #####: 4838:			    fputc(' ', fout);
        -: 4839:		}
        -: 4840:	    }
        -: 4841:	    else
        -: 4842:	    {
    #####: 4843:		n = i;
        -: 4844:		do {
    #####: 4845:		    fwrite(args[n], len[n], 1, fout);
    #####: 4846:		    l = widths[n];
    #####: 4847:		    for (t = nr; t && n < argc; t--, n++);
    #####: 4848:		    if (n < argc)
    #####: 4849:			for (; l < sc; l++)
    #####: 4850:			    fputc(' ', fout);
    #####: 4851:		} while (n < argc);
        -: 4852:	    }
    #####: 4853:	    fputc(OPT_ISSET(ops,'N') ? '\0' : '\n', fout);
        -: 4854:	}
    #####: 4855:	if (IS_MSTREAM(fout) && (rcount = READ_MSTREAM(buf,fout)) == -1)
    #####: 4856:	    ret = 1;
    #####: 4857:	if (!CLOSE_CLEANLY(fout) || ret) {
    #####: 4858:            zwarnnam(name, "write error: %e", errno);
    #####: 4859:            ret = 1;
        -: 4860:	}
    #####: 4861:	if (buf) {
        -: 4862:	    /* assert: we must be doing -v at this point */
    #####: 4863:	    queue_signals();
    #####: 4864:	    if (ret)
    #####: 4865:		free(buf);
        -: 4866:	    else
    #####: 4867:		setsparam(OPT_ARG(ops, 'v'),
        -: 4868:			  metafy(buf, rcount, META_REALLOC));
    #####: 4869:	    unqueue_signals();
        -: 4870:	}
    #####: 4871:	return ret;
        -: 4872:    }
        -: 4873:
        -: 4874:    /* normal output */
      137: 4875:    if (!fmt) {
      274: 4876:	if (OPT_ISSET(ops, 'z') ||
      274: 4877:	    OPT_ISSET(ops, 's') || OPT_ISSET(ops, 'S')) {
        -: 4878:	    /*
        -: 4879:	     * We don't want the arguments unmetafied after all.
        -: 4880:	     */
    #####: 4881:	    for (n = 0; n < argc; n++)
    #####: 4882:		metafy(args[n], len[n], META_NOALLOC);
        -: 4883:	}
        -: 4884:
        -: 4885:	/* -z option -- push the arguments onto the editing buffer stack */
      137: 4886:	if (OPT_ISSET(ops,'z')) {
    #####: 4887:	    queue_signals();
    #####: 4888:	    zpushnode(bufstack, sepjoin(args, NULL, 0));
    #####: 4889:	    unqueue_signals();
    #####: 4890:	    return 0;
        -: 4891:	}
        -: 4892:	/* -s option -- add the arguments to the history list */
      137: 4893:	if (OPT_ISSET(ops,'s') || OPT_ISSET(ops,'S')) {
    #####: 4894:	    int nwords = 0, nlen, iwords;
    #####: 4895:	    char **pargs = args;
        -: 4896:
    #####: 4897:	    queue_signals();
    #####: 4898:	    while (*pargs++)
    #####: 4899:		nwords++;
    #####: 4900:	    if (nwords) {
    #####: 4901:		if (OPT_ISSET(ops,'S')) {
        -: 4902:		    int wordsize;
        -: 4903:		    short *words;
    #####: 4904:		    if (nwords > 1) {
    #####: 4905:			zwarnnam(name, "option -S takes a single argument");
    #####: 4906:			unqueue_signals();
    #####: 4907:			return 1;
        -: 4908:		    }
    #####: 4909:		    words = NULL;
    #####: 4910:		    wordsize = 0;
    #####: 4911:		    histsplitwords(*args, &words, &wordsize, &nwords, 1);
    #####: 4912:		    ent = prepnexthistent();
    #####: 4913:		    ent->words = (short *)zalloc(nwords*sizeof(short));
    #####: 4914:		    memcpy(ent->words, words, nwords*sizeof(short));
    #####: 4915:		    free(words);
    #####: 4916:		    ent->nwords = nwords/2;
        -: 4917:		} else {
    #####: 4918:		    ent = prepnexthistent();
    #####: 4919:		    ent->words = (short *)zalloc(nwords*2*sizeof(short));
    #####: 4920:		    ent->nwords = nwords;
    #####: 4921:		    nlen = iwords = 0;
    #####: 4922:		    for (pargs = args; *pargs; pargs++) {
    #####: 4923:			ent->words[iwords++] = nlen;
    #####: 4924:			nlen += strlen(*pargs);
    #####: 4925:			ent->words[iwords++] = nlen;
    #####: 4926:			nlen++;
        -: 4927:		    }
        -: 4928:		}
        -: 4929:	    } else {
    #####: 4930:		ent = prepnexthistent();
    #####: 4931:		ent->words = (short *)NULL;
        -: 4932:	    }
    #####: 4933:	    ent->node.nam = zjoin(args, ' ', 0);
    #####: 4934:	    ent->stim = ent->ftim = time(NULL);
    #####: 4935:	    ent->node.flags = 0;
    #####: 4936:	    addhistnode(histtab, ent->node.nam, ent);
    #####: 4937:	    unqueue_signals();
    #####: 4938:	    return 0;
        -: 4939:	}
        -: 4940:
      137: 4941:	if (OPT_HASARG(ops, 'x') || OPT_HASARG(ops, 'X')) {
        -: 4942:	    char *eptr;
    #####: 4943:	    int expand, startpos = 0;
    #####: 4944:	    int all = OPT_HASARG(ops, 'X');
    #####: 4945:	    char *xarg = all ? OPT_ARG(ops, 'X') : OPT_ARG(ops, 'x');
        -: 4946:
    #####: 4947:	    expand = (int)zstrtol(xarg, &eptr, 10);
    #####: 4948:	    if (*eptr || expand <= 0) {
    #####: 4949:		zwarnnam(name, "positive integer expected after -%c: %s", 'x',
        -: 4950:			 xarg);
    #####: 4951:		return 1;
        -: 4952:	    }
    #####: 4953:	    for (; *args; args++, len++) {
    #####: 4954:		startpos = zexpandtabs(*args, *len, expand, startpos, fout,
        -: 4955:				       all);
    #####: 4956:		if (args[1]) {
    #####: 4957:		    if (OPT_ISSET(ops, 'l')) {
    #####: 4958:			fputc('\n', fout);
    #####: 4959:			startpos = 0;
    #####: 4960:		    } else if (OPT_ISSET(ops,'N')) {
    #####: 4961:			fputc('\0', fout);
        -: 4962:		    } else {
    #####: 4963:			fputc(' ', fout);
    #####: 4964:			startpos++;
        -: 4965:		    }
        -: 4966:		}
        -: 4967:	    }
        -: 4968:	} else {
      309: 4969:	    for (; *args; args++, len++) {
      172: 4970:		fwrite(*args, *len, 1, fout);
      172: 4971:		if (args[1])
       72: 4972:		    fputc(OPT_ISSET(ops,'l') ? '\n' :
       36: 4973:			  OPT_ISSET(ops,'N') ? '\0' : ' ', fout);
        -: 4974:	    }
        -: 4975:	}
      233: 4976:	if (!(OPT_ISSET(ops,'n') || nnl ||
       96: 4977:	    (OPT_ISSET(ops, 'v') && !OPT_ISSET(ops, 'l'))))
       96: 4978:	    fputc(OPT_ISSET(ops,'N') ? '\0' : '\n', fout);
      137: 4979:	if (IS_MSTREAM(fout) && (rcount = READ_MSTREAM(buf,fout)) == -1)
    #####: 4980:	    ret = 1;
      137: 4981:	if (!CLOSE_CLEANLY(fout) || ret) {
    #####: 4982:            zwarnnam(name, "write error: %e", errno);
    #####: 4983:            ret = 1;
        -: 4984:	}
      137: 4985:	if (buf) {
        -: 4986:	    /* assert: we must be doing -v at this point */
    #####: 4987:	    queue_signals();
    #####: 4988:	    if (ret)
    #####: 4989:		free(buf);
        -: 4990:	    else
    #####: 4991:		setsparam(OPT_ARG(ops, 'v'),
        -: 4992:			  metafy(buf, rcount, META_REALLOC));
    #####: 4993:	    unqueue_signals();
        -: 4994:	}
      137: 4995:	return ret;
        -: 4996:    }
        -: 4997:
        -: 4998:    /*
        -: 4999:     * All the remaining code in this function is for printf-style
        -: 5000:     * output (printf itself, or print -f).  We still have to handle
        -: 5001:     * special cases of printing to a ZLE buffer or the history, however.
        -: 5002:     */
        -: 5003:
    #####: 5004:    if (OPT_ISSET(ops,'v')) {
        -: 5005:	struct value vbuf;
    #####: 5006:	char* s = OPT_ARG(ops,'v');
    #####: 5007:	Value v = getvalue(&vbuf, &s, 0);
    #####: 5008:	visarr = v && PM_TYPE(v->pm->node.flags) == PM_ARRAY;
        -: 5009:    }
        -: 5010:    /* printf style output */
    #####: 5011:    *spec = '%';
    #####: 5012:    argp = args;
        -: 5013:    do {
    #####: 5014:    	rcount = count;
    #####: 5015:	if (argp > args && visarr) { /* reusing format string */
    #####: 5016:	    if (!splits)
    #####: 5017:		cursplit = splits = (size_t *)zhalloc(sizeof(size_t) *
    #####: 5018:			(arrlen(args) / (argp - args) + 1));
    #####: 5019:	    *cursplit++ = count;
        -: 5020:	}
    #####: 5021:    	if (maxarg) {
    #####: 5022:	    first += maxarg;
    #####: 5023:	    argc -= maxarg;
    #####: 5024:    	    maxarg = 0;
        -: 5025:	}
    #####: 5026:	for (c = fmt; c-fmt < flen; c++) {
    #####: 5027:	    if (*c != '%') {
    #####: 5028:		putc(*c, fout);
    #####: 5029:		++count;
    #####: 5030:		continue;
        -: 5031:	    }
        -: 5032:
    #####: 5033:	    start = c++;
    #####: 5034:	    if (*c == '%') {
    #####: 5035:		putc('%', fout);
    #####: 5036:		++count;
    #####: 5037:		continue;
        -: 5038:	    }
        -: 5039:
    #####: 5040:	    type = prec = -1;
    #####: 5041:	    width = 0;
    #####: 5042:	    curarg = NULL;
    #####: 5043:	    d = spec + 1;
        -: 5044:
    #####: 5045:	    if (*c >= '1' && *c <= '9') {
    #####: 5046:	    	narg = strtoul(c, &endptr, 0);
    #####: 5047:		if (*endptr == '$') {
    #####: 5048:		    c = endptr + 1;
    #####: 5049:		    if (narg <= 0 || narg > argc) {
    #####: 5050:		    	zwarnnam(name, "%d: argument specifier out of range",
        -: 5051:				 narg);
    #####: 5052:			if (fout != stdout)
    #####: 5053:			    fclose(fout);
        -: 5054:#ifdef HAVE_OPEN_MEMSTREAM
    #####: 5055:			if (buf)
    #####: 5056:			    free(buf);
        -: 5057:#endif
    #####: 5058:			return 1;
        -: 5059:		    } else {
    #####: 5060:		    	if (narg > maxarg) maxarg = narg;
    #####: 5061:		    	curarg = *(first + narg - 1);
    #####: 5062:			curlen = len[first - args + narg - 1];
        -: 5063:		    }
        -: 5064:		}
        -: 5065:	    }
        -: 5066:
        -: 5067:	    /* copy only one of each flag as spec has finite size */
    #####: 5068:	    memset(flags, 0, sizeof(flags));
    #####: 5069:	    while (*c && (flag = strchr(flagch, *c))) {
    #####: 5070:	    	if (!flags[flag - flagch]) {
    #####: 5071:	    	    flags[flag - flagch] = 1;
    #####: 5072:		    *d++ = *c;
        -: 5073:		}
    #####: 5074:	    	c++;
        -: 5075:	    }
        -: 5076:
    #####: 5077:	    if (idigit(*c)) {
    #####: 5078:		width = strtoul(c, &endptr, 0);
    #####: 5079:		c = endptr;
    #####: 5080:	    } else if (*c == '*') {
    #####: 5081:		if (idigit(*++c)) {
    #####: 5082:		    narg = strtoul(c, &endptr, 0);
    #####: 5083:		    if (*endptr == '$') {
    #####: 5084:		    	c = endptr + 1;
    #####: 5085:			if (narg > argc || narg <= 0) {
    #####: 5086:		    	    zwarnnam(name,
        -: 5087:				     "%d: argument specifier out of range",
        -: 5088:				     narg);
    #####: 5089:			    if (fout != stdout)
    #####: 5090:				fclose(fout);
        -: 5091:#ifdef HAVE_OPEN_MEMSTREAM
    #####: 5092:			    if (buf)
    #####: 5093:				free(buf);
        -: 5094:#endif
    #####: 5095:			    return 1;
        -: 5096:			} else {
    #####: 5097:		    	    if (narg > maxarg) maxarg = narg;
    #####: 5098:		    	    argp = first + narg - 1;
        -: 5099:			}
        -: 5100:		    }
        -: 5101:		}
    #####: 5102:		if (*argp) {
    #####: 5103:		    width = (int)mathevali(*argp++);
    #####: 5104:		    if (errflag) {
    #####: 5105:			errflag &= ~ERRFLAG_ERROR;
    #####: 5106:			ret = 1;
        -: 5107:		    }
        -: 5108:		}
        -: 5109:	    }
    #####: 5110:	    *d++ = '*';
        -: 5111:
    #####: 5112:	    if (*c == '.') {
    #####: 5113:		if (*++c == '*') {
    #####: 5114:		    if (idigit(*++c)) {
    #####: 5115:			narg = strtoul(c, &endptr, 0);
    #####: 5116:			if (*endptr == '$') {
    #####: 5117:			    c = endptr + 1;
    #####: 5118:			    if (narg > argc || narg <= 0) {
    #####: 5119:		    		zwarnnam(name,
        -: 5120:					 "%d: argument specifier out of range",
        -: 5121:					 narg);
    #####: 5122:				if (fout != stdout)
    #####: 5123:				    fclose(fout);
        -: 5124:#ifdef HAVE_OPEN_MEMSTREAM
    #####: 5125:				if (buf)
    #####: 5126:				    free(buf);
        -: 5127:#endif
    #####: 5128:				return 1;
        -: 5129:			    } else {
    #####: 5130:		    		if (narg > maxarg) maxarg = narg;
    #####: 5131:		    		argp = first + narg - 1;
        -: 5132:			    }
        -: 5133:			}
        -: 5134:		    }
        -: 5135:
    #####: 5136:		    if (*argp) {
    #####: 5137:			prec = (int)mathevali(*argp++);
    #####: 5138:			if (errflag) {
    #####: 5139:			    errflag &= ~ERRFLAG_ERROR;
    #####: 5140:			    ret = 1;
        -: 5141:			}
        -: 5142:		    }
    #####: 5143:		} else if (idigit(*c)) {
    #####: 5144:		    prec = strtoul(c, &endptr, 0);
    #####: 5145:		    c = endptr;
        -: 5146:		} else
    #####: 5147:		    prec = 0;
    #####: 5148:		if (prec >= 0) *d++ = '.', *d++ = '*';
        -: 5149:	    }
        -: 5150:
        -: 5151:	    /* ignore any size modifier */
    #####: 5152:	    if (*c == 'l' || *c == 'L' || *c == 'h') c++;
        -: 5153:
    #####: 5154:	    if (!curarg && *argp) {
    #####: 5155:		curarg = *argp;
    #####: 5156:		curlen = len[argp++ - args];
        -: 5157:	    }
    #####: 5158:	    d[1] = '\0';
    #####: 5159:	    switch (*d = *c) {
    #####: 5160:	    case 'c':
    #####: 5161:		if (curarg)
    #####: 5162:		    intval = *curarg;
        -: 5163:		else
    #####: 5164:		    intval = 0;
    #####: 5165:		print_val(intval);
    #####: 5166:		break;
    #####: 5167:	    case 's':
        -: 5168:	    case 'b':
    #####: 5169:		if (curarg) {
        -: 5170:		    char *b, *ptr;
        -: 5171:		    int lbytes, lchars, lleft;
        -: 5172:#ifdef MULTIBYTE_SUPPORT
        -: 5173:		    mbstate_t mbs;
        -: 5174:#endif
        -: 5175:
    #####: 5176:		    if (*c == 'b') {
    #####: 5177:			b = getkeystring(metafy(curarg, curlen, META_USEHEAP),
        -: 5178:					 &lbytes,
    #####: 5179:					 OPT_ISSET(ops,'b') ? GETKEYS_BINDKEY :
        -: 5180:					 GETKEYS_PRINTF_ARG, &nnl);
        -: 5181:		    } else {
    #####: 5182:			b = curarg;
    #####: 5183:			lbytes = curlen;
        -: 5184:		    }
        -: 5185:		    /*
        -: 5186:		     * Handle width/precision here and use fwrite so that
        -: 5187:		     * nul characters can be output.
        -: 5188:		     *
        -: 5189:		     * First, examine width of string given that it
        -: 5190:		     * may contain multibyte characters.  The output
        -: 5191:		     * widths are for characters, so we need to count
        -: 5192:		     * (in lchars).  However, if we need to truncate
        -: 5193:		     * the string we need the width in bytes (in lbytes).
        -: 5194:		     */
    #####: 5195:		    ptr = b;
        -: 5196:#ifdef MULTIBYTE_SUPPORT
    #####: 5197:		    memset(&mbs, 0, sizeof(mbs));
        -: 5198:#endif
        -: 5199:
    #####: 5200:		    for (lchars = 0, lleft = lbytes; lleft > 0; lchars++) {
        -: 5201:			int chars;
        -: 5202:
    #####: 5203:			if (lchars == prec) {
        -: 5204:			    /* Truncate at this point. */
    #####: 5205:			    lbytes = ptr - b;
    #####: 5206:			    break;
        -: 5207:			}
        -: 5208:#ifdef MULTIBYTE_SUPPORT
    #####: 5209:			if (isset(MULTIBYTE)) {
    #####: 5210:			    chars = mbrlen(ptr, lleft, &mbs);
    #####: 5211:			    if (chars < 0) {
        -: 5212:				/*
        -: 5213:				 * Invalid/incomplete character at this
        -: 5214:				 * point.  Assume all the rest are a
        -: 5215:				 * single byte.  That's about the best we
        -: 5216:				 * can do.
        -: 5217:				 */
    #####: 5218:				lchars += lleft;
    #####: 5219:				lbytes = (ptr - b) + lleft;
    #####: 5220:				break;
    #####: 5221:			    } else if (chars == 0) {
        -: 5222:				/* NUL, handle as real character */
    #####: 5223:				chars = 1;
        -: 5224:			    }
        -: 5225:			}
        -: 5226:			else	/* use the non-multibyte code below */
        -: 5227:#endif
    #####: 5228:			    chars = 1; /* compiler can optimise this...*/
    #####: 5229:			lleft -= chars;
    #####: 5230:			ptr += chars;
        -: 5231:		    }
    #####: 5232:		    if (width > 0 && flags[3]) width = -width;
    #####: 5233:		    if (width > 0 && lchars < width)
    #####: 5234:		    	count += fprintf(fout, "%*c", width - lchars, ' ');
    #####: 5235:		    count += fwrite(b, 1, lbytes, fout);
    #####: 5236:		    if (width < 0 && lchars < -width)
    #####: 5237:		    	count += fprintf(fout, "%*c", -width - lchars, ' ');
    #####: 5238:		    if (nnl) {
        -: 5239:			/* If the %b arg had a \c escape, truncate the fmt. */
    #####: 5240:			flen = c - fmt + 1;
    #####: 5241:			fmttrunc = 1;
        -: 5242:		    }
    #####: 5243:		} else if (width)
    #####: 5244:		    count += fprintf(fout, "%*c", width, ' ');
    #####: 5245:		break;
    #####: 5246:	    case 'q':
    #####: 5247:		stringval = curarg ?
    #####: 5248:		    quotestring(metafy(curarg, curlen, META_USEHEAP),
    #####: 5249:				QT_BACKSLASH_SHOWNULL) : &nullstr;
    #####: 5250:		*d = 's';
    #####: 5251:		print_val(unmetafy(stringval, &curlen));
    #####: 5252:		break;
    #####: 5253:	    case 'd':
        -: 5254:	    case 'i':
    #####: 5255:		type=1;
    #####: 5256:		break;
    #####: 5257:	    case 'e':
        -: 5258:	    case 'E':
        -: 5259:	    case 'f':
        -: 5260:	    case 'g':
        -: 5261:	    case 'G':
    #####: 5262:		type=2;
    #####: 5263:		break;
    #####: 5264:	    case 'o':
        -: 5265:	    case 'u':
        -: 5266:	    case 'x':
        -: 5267:	    case 'X':
    #####: 5268:		type=3;
    #####: 5269:		break;
    #####: 5270:	    case 'n':
    #####: 5271:		if (curarg) setiparam(curarg, count - rcount);
    #####: 5272:		break;
    #####: 5273:	    default:
    #####: 5274:	        if (*c) {
    #####: 5275:		    save = c[1];
    #####: 5276:	            c[1] = '\0';
        -: 5277:		}
    #####: 5278:		zwarnnam(name, "%s: invalid directive", start);
    #####: 5279:		if (*c) c[1] = save;
        -: 5280:		/* Why do we care about a clean close here? */
    #####: 5281:		if (!CLOSE_CLEANLY(fout))
    #####: 5282:		    zwarnnam(name, "write error: %e", errno);
        -: 5283:#ifdef HAVE_OPEN_MEMSTREAM
    #####: 5284:		if (buf)
    #####: 5285:		    free(buf);
        -: 5286:#endif
    #####: 5287:		return 1;
        -: 5288:	    }
        -: 5289:
    #####: 5290:	    if (type > 0) {
    #####: 5291:		if (curarg && (*curarg == '\'' || *curarg == '"' )) {
        -: 5292:		    convchar_t cc;
        -: 5293:#ifdef MULTIBYTE_SUPPORT
    #####: 5294:		    if (isset(MULTIBYTE)) {
    #####: 5295:			mb_charinit();
    #####: 5296:			(void)mb_metacharlenconv(metafy(curarg+1, curlen-1,
        -: 5297:							META_USEHEAP), &cc);
        -: 5298:		    }
        -: 5299:		    else
    #####: 5300:			cc = WEOF;
    #####: 5301:		    if (cc == WEOF)
    #####: 5302:			cc = (curlen > 1) ? STOUC(curarg[1]) : 0;
        -: 5303:#else
        -: 5304:		    cc = (curlen > 1) ? STOUC(curarg[1]) : 0;
        -: 5305:#endif
    #####: 5306:		    if (type == 2) {
    #####: 5307:			doubleval = cc;
    #####: 5308:			print_val(doubleval);
        -: 5309:		    } else {
    #####: 5310:			intval = cc;
    #####: 5311:			print_val(intval);
        -: 5312:		    }
        -: 5313:		} else {
    #####: 5314:		    switch (type) {
    #####: 5315:		    case 1:
        -: 5316:#ifdef ZSH_64_BIT_TYPE
        -: 5317: 		    	*d++ = 'l';
        -: 5318:#endif
    #####: 5319:		    	*d++ = 'l', *d++ = *c, *d = '\0';
    #####: 5320:			zlongval = (curarg) ? mathevali(curarg) : 0;
    #####: 5321:			if (errflag) {
    #####: 5322:			    zlongval = 0;
    #####: 5323:			    errflag &= ~ERRFLAG_ERROR;
    #####: 5324:			    ret = 1;
        -: 5325:			}
    #####: 5326:			print_val(zlongval)
    #####: 5327:			    break;
    #####: 5328:		    case 2:
    #####: 5329:			if (curarg) {
        -: 5330:			    char *eptr;
        -: 5331:			    /*
        -: 5332:			     * First attempt to parse as a floating
        -: 5333:			     * point constant.  If we go through
        -: 5334:			     * a math evaluation, we can lose
        -: 5335:			     * mostly unimportant information
        -: 5336:			     * that people in standards organizations
        -: 5337:			     * worry about.
        -: 5338:			     */
    #####: 5339:			    doubleval = strtod(curarg, &eptr);
        -: 5340:			    /*
        -: 5341:			     * If it didn't parse as a constant,
        -: 5342:			     * parse it as an expression.
        -: 5343:			     */
    #####: 5344:			    if (*eptr != '\0') {
    #####: 5345:				mnumval = matheval(curarg);
    #####: 5346:				doubleval = (mnumval.type & MN_FLOAT) ?
    #####: 5347:				    mnumval.u.d : (double)mnumval.u.l;
        -: 5348:			    }
    #####: 5349:			} else doubleval = 0;
    #####: 5350:			if (errflag) {
    #####: 5351:			    doubleval = 0;
    #####: 5352:			    errflag &= ~ERRFLAG_ERROR;
    #####: 5353:			    ret = 1;
        -: 5354:			}
        -: 5355:			/* force consistent form for Inf/NaN output */
    #####: 5356:			if (isnan(doubleval))
    #####: 5357:			    count += fputs("nan", fout);
    #####: 5358:			else if (isinf(doubleval))
    #####: 5359:			    count += fputs((doubleval < 0.0) ? "-inf" : "inf", fout);
        -: 5360:		        else
    #####: 5361:			    print_val(doubleval)
    #####: 5362:			break;
    #####: 5363:		    case 3:
        -: 5364:#ifdef ZSH_64_BIT_UTYPE
        -: 5365: 		    	*d++ = 'l';
        -: 5366:#endif
    #####: 5367:		    	*d++ = 'l', *d++ = *c, *d = '\0';
    #####: 5368:			if (!curarg)
    #####: 5369:			    zulongval = (zulong)0;
    #####: 5370:			else if (!zstrtoul_underscore(curarg, &zulongval))
    #####: 5371:			    zulongval = mathevali(curarg);
    #####: 5372:			if (errflag) {
    #####: 5373:			    zulongval = 0;
    #####: 5374:			    errflag &= ~ERRFLAG_ERROR;
    #####: 5375:			    ret = 1;
        -: 5376:			}
    #####: 5377:			print_val(zulongval)
        -: 5378:		    }
        -: 5379:		}
        -: 5380:	    }
    #####: 5381:	    if (maxarg && (argp - first > maxarg))
    #####: 5382:	    	maxarg = argp - first;
        -: 5383:	}
        -: 5384:
    #####: 5385:    	if (maxarg) argp = first + maxarg;
        -: 5386:	/* if there are remaining args, reuse format string */
    #####: 5387:    } while (*argp && argp != first && !fmttrunc && !OPT_ISSET(ops,'r'));
        -: 5388:
    #####: 5389:    if (IS_MSTREAM(fout)) {
    #####: 5390:	queue_signals();
    #####: 5391:	if ((rcount = READ_MSTREAM(buf,fout)) == -1) {
    #####: 5392:	    zwarnnam(name, "i/o error: %e", errno);
    #####: 5393:	    if (buf)
    #####: 5394:		free(buf);
        -: 5395:	} else {
    #####: 5396:	    if (visarr && splits) {
    #####: 5397:		char **arrayval = zshcalloc((cursplit - splits + 2) * sizeof(char *));
    #####: 5398:		for (;cursplit >= splits; cursplit--) {
    #####: 5399:		    int start = cursplit == splits ? 0 : cursplit[-1];
    #####: 5400:		    arrayval[cursplit - splits] =
    #####: 5401:			    metafy(buf + start, count - start, META_DUP);
    #####: 5402:		    count = start;
        -: 5403:		}
    #####: 5404:		setaparam(OPT_ARG(ops, 'v'), arrayval);
    #####: 5405:		free(buf);
        -: 5406:	    } else {
    #####: 5407:		stringval = metafy(buf, rcount, META_REALLOC);
    #####: 5408:		if (OPT_ISSET(ops,'z')) {
    #####: 5409:		    zpushnode(bufstack, stringval);
    #####: 5410:		} else if (OPT_ISSET(ops,'v')) {
    #####: 5411:		    setsparam(OPT_ARG(ops, 'v'), stringval);
        -: 5412:		} else {
    #####: 5413:		    ent = prepnexthistent();
    #####: 5414:		    ent->node.nam = stringval;
    #####: 5415:		    ent->stim = ent->ftim = time(NULL);
    #####: 5416:		    ent->node.flags = 0;
    #####: 5417:		    ent->words = (short *)NULL;
    #####: 5418:		    addhistnode(histtab, ent->node.nam, ent);
        -: 5419:		}
        -: 5420:	    }
        -: 5421:	}
    #####: 5422:	unqueue_signals();
        -: 5423:    }
        -: 5424:
    #####: 5425:    if (!CLOSE_CLEANLY(fout))
        -: 5426:    {
    #####: 5427:	zwarnnam(name, "write error: %e", errno);
    #####: 5428:	ret = 1;
        -: 5429:    }
    #####: 5430:    return ret;
        -: 5431:}
        -: 5432:
        -: 5433:/* shift builtin */
        -: 5434:
        -: 5435:/**/
        -: 5436:int
      307: 5437:bin_shift(char *name, char **argv, Options ops, UNUSED(int func))
        -: 5438:{
      307: 5439:    int num = 1, l, ret = 0;
        -: 5440:    char **s;
        -: 5441:
        -: 5442:    /* optional argument can be either numeric or an array */
      307: 5443:    queue_signals();
      307: 5444:    if (*argv && !getaparam(*argv)) {
    #####: 5445:        num = mathevali(*argv++);
    #####: 5446:	if (errflag) {
    #####: 5447:	    unqueue_signals();
    #####: 5448:	    return 1;
        -: 5449:	}
        -: 5450:    }
        -: 5451:
      307: 5452:    if (num < 0) {
    #####: 5453:	unqueue_signals();
    #####: 5454:        zwarnnam(name, "argument to shift must be non-negative");
    #####: 5455:        return 1;
        -: 5456:    }
        -: 5457:
      307: 5458:    if (*argv) {
    #####: 5459:        for (; *argv; argv++)
    #####: 5460:            if ((s = getaparam(*argv))) {
    #####: 5461:                if (arrlen_lt(s, num)) {
    #####: 5462:		    zwarnnam(name, "shift count must be <= $#");
    #####: 5463:		    ret++;
    #####: 5464:		    continue;
        -: 5465:		}
    #####: 5466:		if (OPT_ISSET(ops,'p')) {
        -: 5467:		    char **s2, **src, **dst;
        -: 5468:		    int count;
    #####: 5469:		    l = arrlen(s);
    #####: 5470:		    src = s;
    #####: 5471:		    dst = s2 = (char **)zalloc((l - num + 1) * sizeof(char *));
    #####: 5472:		    for (count = l - num; count; count--)
    #####: 5473:			*dst++ = ztrdup(*src++);
    #####: 5474:		    *dst = NULL;
    #####: 5475:		    s = s2;
        -: 5476:		} else {
    #####: 5477:		    s = zarrdup(s + num);
        -: 5478:		}
    #####: 5479:                setaparam(*argv, s);
        -: 5480:            }
        -: 5481:    } else {
      307: 5482:        if (num > (l = arrlen(pparams))) {
    #####: 5483:	    zwarnnam(name, "shift count must be <= $#");
    #####: 5484:	    ret = 1;
        -: 5485:	} else {
      307: 5486:	    s = zalloc((l - num + 1) * sizeof(char *));
      307: 5487:	    if (OPT_ISSET(ops,'p')) {
    #####: 5488:		memcpy(s, pparams, (l - num) * sizeof(char *));
    #####: 5489:		s[l-num] = NULL;
    #####: 5490:		while (num--)
    #####: 5491:		    zsfree(pparams[l-1-num]);
        -: 5492:	    } else {
      307: 5493:		memcpy(s, pparams + num, (l - num + 1) * sizeof(char *));
      921: 5494:		while (num--)
      307: 5495:		    zsfree(pparams[num]);
        -: 5496:	    }
      307: 5497:	    zfree(pparams, (l + 1) * sizeof(char *));
      307: 5498:	    pparams = s;
        -: 5499:	}
        -: 5500:    }
      307: 5501:    unqueue_signals();
      307: 5502:    return ret;
        -: 5503:}
        -: 5504:
        -: 5505:/*
        -: 5506: * Position of getopts option within OPTIND argument with multiple options.
        -: 5507: */
        -: 5508:
        -: 5509:/**/
        -: 5510:int optcind;
        -: 5511:
        -: 5512:/* getopts: automagical option handling for shell scripts */
        -: 5513:
        -: 5514:/**/
        -: 5515:int
    #####: 5516:bin_getopts(UNUSED(char *name), char **argv, UNUSED(Options ops), UNUSED(int func))
        -: 5517:{
        -: 5518:    int lenstr, lenoptstr, quiet, lenoptbuf;
    #####: 5519:    char *optstr = unmetafy(*argv++, &lenoptstr), *var = *argv++;
    #####: 5520:    char **args = (*argv) ? argv : pparams;
    #####: 5521:    char *str, optbuf[2] = " ", *p, opch;
        -: 5522:
        -: 5523:    /* zoptind keeps count of the current argument number.  The *
        -: 5524:     * user can set it to zero to start a new option parse.     */
    #####: 5525:    if (zoptind < 1) {
        -: 5526:	/* first call */
    #####: 5527:	zoptind = 1;
    #####: 5528:	optcind = 0;
        -: 5529:    }
    #####: 5530:    if (arrlen_lt(args, zoptind))
        -: 5531:	/* no more options */
    #####: 5532:	return 1;
        -: 5533:
        -: 5534:    /* leading ':' in optstr means don't print an error message */
    #####: 5535:    quiet = *optstr == ':';
    #####: 5536:    optstr += quiet;
    #####: 5537:    lenoptstr -= quiet;
        -: 5538:
        -: 5539:    /* find place in relevant argument */
    #####: 5540:    str = unmetafy(dupstring(args[zoptind - 1]), &lenstr);
    #####: 5541:    if (!lenstr)		/* Definitely not an option. */
    #####: 5542:	return 1;
    #####: 5543:    if(optcind >= lenstr) {
    #####: 5544:	optcind = 0;
    #####: 5545:	if(!args[zoptind++])
    #####: 5546:	    return 1;
    #####: 5547:	str = unmetafy(dupstring(args[zoptind - 1]), &lenstr);
        -: 5548:    }
    #####: 5549:    if(!optcind) {
    #####: 5550:	if(lenstr < 2 || (*str != '-' && *str != '+'))
    #####: 5551:	    return 1;
    #####: 5552:	if(lenstr == 2 && str[0] == '-' && str[1] == '-') {
    #####: 5553:	    zoptind++;
    #####: 5554:	    return 1;
        -: 5555:	}
    #####: 5556:	optcind++;
        -: 5557:    }
    #####: 5558:    opch = str[optcind++];
    #####: 5559:    if(str[0] == '+') {
    #####: 5560:	optbuf[0] = '+';
    #####: 5561:	lenoptbuf = 2;
        -: 5562:    } else
    #####: 5563:	lenoptbuf = 1;
    #####: 5564:    optbuf[lenoptbuf - 1] = opch;
        -: 5565:
        -: 5566:    /* check for legality */
    #####: 5567:    if(opch == ':' || !(p = memchr(optstr, opch, lenoptstr))) {
    #####: 5568:	p = "?";
        -: 5569:	/* Keep OPTIND correct if the user doesn't return after the error */
    #####: 5570:	if (isset(POSIXBUILTINS)) {
    #####: 5571:	    optcind = 0;
    #####: 5572:	    zoptind++;
        -: 5573:	}
    #####: 5574:	zsfree(zoptarg);
    #####: 5575:	setsparam(var, ztrdup(p));
    #####: 5576:	if(quiet) {
    #####: 5577:	    zoptarg = metafy(optbuf, lenoptbuf, META_DUP);
        -: 5578:	} else {
    #####: 5579:	    zwarn("bad option: %c%c",
    #####: 5580:		  "?-+"[lenoptbuf], opch);
    #####: 5581:	    zoptarg=ztrdup("");
        -: 5582:	}
    #####: 5583:	return 0;
        -: 5584:    }
        -: 5585:
        -: 5586:    /* check for required argument */
    #####: 5587:    if(p[1] == ':') {
    #####: 5588:	if(optcind == lenstr) {
    #####: 5589:	    if(!args[zoptind]) {
        -: 5590:		/* Fix OPTIND as above */
    #####: 5591:		if (isset(POSIXBUILTINS)) {
    #####: 5592:		    optcind = 0;
    #####: 5593:		    zoptind++;
        -: 5594:		}
    #####: 5595:		zsfree(zoptarg);
    #####: 5596:		if(quiet) {
    #####: 5597:		    setsparam(var, ztrdup(":"));
    #####: 5598:		    zoptarg = metafy(optbuf, lenoptbuf, META_DUP);
        -: 5599:		} else {
    #####: 5600:		    setsparam(var, ztrdup("?"));
    #####: 5601:		    zoptarg = ztrdup("");
    #####: 5602:		    zwarn("argument expected after %c%c option",
    #####: 5603:			  "?-+"[lenoptbuf], opch);
        -: 5604:		}
    #####: 5605:		return 0;
        -: 5606:	    }
    #####: 5607:	    p = ztrdup(args[zoptind++]);
        -: 5608:	} else
    #####: 5609:	    p = metafy(str+optcind, lenstr-optcind, META_DUP);
        -: 5610:	/*
        -: 5611:	 * Careful:  I've just changed the following two lines from
        -: 5612:	 *   optcind = ztrlen(args[zoptind - 1]);
        -: 5613:	 * and it's a rigorous theorem that every change in getopts breaks
        -: 5614:	 * something.  See zsh-workers/9095 for the bug fixed here.
        -: 5615:	 *   PWS 2000/05/02
        -: 5616:	 */
    #####: 5617:	optcind = 0;
    #####: 5618:	zoptind++;
    #####: 5619:	zsfree(zoptarg);
    #####: 5620:	zoptarg = p;
        -: 5621:    } else {
    #####: 5622:	zsfree(zoptarg);
    #####: 5623:	zoptarg = ztrdup("");
        -: 5624:    }
        -: 5625:
    #####: 5626:    setsparam(var, metafy(optbuf, lenoptbuf, META_DUP));
    #####: 5627:    return 0;
        -: 5628:}
        -: 5629:
        -: 5630:/* Boolean flag that we should exit the shell as soon as all functions return.
        -: 5631: *
        -: 5632: * Set by the 'exit' builtin.
        -: 5633: */
        -: 5634:
        -: 5635:/**/
        -: 5636:mod_export volatile int exit_pending;
        -: 5637:
        -: 5638:/* Shell level at which we exit if exit_pending */
        -: 5639:/**/
        -: 5640:mod_export volatile int exit_level;
        -: 5641:
        -: 5642:/* we have printed a 'you have stopped (running) jobs.' message */
        -: 5643:
        -: 5644:/**/
        -: 5645:mod_export volatile int stopmsg;
        -: 5646:
        -: 5647:/* break, bye, continue, exit, logout, return -- most of these take   *
        -: 5648: * one numeric argument, and the other (logout) is related to return. *
        -: 5649: * (return is treated as a logout when in a login shell.)             */
        -: 5650:
        -: 5651:/**/
        -: 5652:int
      447: 5653:bin_break(char *name, char **argv, UNUSED(Options ops), int func)
        -: 5654:{
      447: 5655:    int num = lastval, nump = 0, implicit;
        -: 5656:
        -: 5657:    /* handle one optional numeric argument */
      447: 5658:    implicit = !*argv;
      447: 5659:    if (*argv) {
      388: 5660:	num = mathevali(*argv++);
      388: 5661:	nump = 1;
        -: 5662:    }
        -: 5663:
      447: 5664:    if (nump > 0 && (func == BIN_CONTINUE || func == BIN_BREAK) && num <= 0) {
    #####: 5665:	zerrnam(name, "argument is not positive: %d", num);
    #####: 5666:	return 1;
        -: 5667:    }
        -: 5668:
      447: 5669:    switch (func) {
       21: 5670:    case BIN_CONTINUE:
       21: 5671:	if (!loops) {   /* continue is only permitted in loops */
    #####: 5672:	    zerrnam(name, "not in while, until, select, or repeat loop");
    #####: 5673:	    return 1;
        -: 5674:	}
       21: 5675:	contflag = 1; /* FALLTHROUGH */
       60: 5676:    case BIN_BREAK:
       60: 5677:	if (!loops) {   /* break is only permitted in loops */
    #####: 5678:	    zerrnam(name, "not in while, until, select, or repeat loop");
    #####: 5679:	    return 1;
        -: 5680:	}
       60: 5681:	breaks = nump ? minimum(num,loops) : 1;
       60: 5682:	break;
      386: 5683:    case BIN_RETURN:
      386: 5684:	if ((isset(INTERACTIVE) && isset(SHINSTDIN))
      386: 5685:	    || locallevel || sourcelevel) {
      385: 5686:	    retflag = 1;
      385: 5687:	    breaks = loops;
      385: 5688:	    lastval = num;
      385: 5689:	    if (trap_state == TRAP_STATE_PRIMED && trap_return == -2
        -: 5690:		/*
        -: 5691:		 * With POSIX, "return" on its own in a trap doesn't
        -: 5692:		 * update $? --- we keep the status from before the
        -: 5693:		 * trap.
        -: 5694:		 */
    #####: 5695:		&& !(isset(POSIXTRAPS) && implicit)) {
    #####: 5696:		trap_state = TRAP_STATE_FORCE_RETURN;
    #####: 5697:		trap_return = lastval;
        -: 5698:	    }
      385: 5699:	    return lastval;
        -: 5700:	}
        1: 5701:	zexit(num, ZEXIT_NORMAL);	/* else treat return as logout/exit */
    #####: 5702:	break;
    #####: 5703:    case BIN_LOGOUT:
    #####: 5704:	if (unset(LOGINSHELL)) {
    #####: 5705:	    zerrnam(name, "not login shell");
    #####: 5706:	    return 1;
        -: 5707:	}
        -: 5708:	/*FALLTHROUGH*/
        -: 5709:    case BIN_EXIT:
        1: 5710:	if (locallevel > forklevel && shell_exiting != -1) {
        -: 5711:	    /*
        -: 5712:	     * We don't exit directly from functions to allow tidying
        -: 5713:	     * up, in particular EXIT traps.  We still need to perform
        -: 5714:	     * the usual interactive tests to see if we can exit at
        -: 5715:	     * all, however.
        -: 5716:	     *
        -: 5717:	     * If we are forked, we exit the shell at the function depth
        -: 5718:	     * at which we became a subshell, hence the comparison.
        -: 5719:	     *
        -: 5720:	     * If we are already exiting... give this all up as
        -: 5721:	     * a bad job.
        -: 5722:	     */
    #####: 5723:	    if (stopmsg || (zexit(0, ZEXIT_DEFERRED), !stopmsg)) {
    #####: 5724:		retflag = 1;
    #####: 5725:		breaks = loops;
    #####: 5726:		exit_pending = 1;
    #####: 5727:		exit_level = locallevel;
    #####: 5728:		exit_val = num;
        -: 5729:	    }
        -: 5730:	} else
        1: 5731:	    zexit(num, ZEXIT_NORMAL);
    #####: 5732:	break;
        -: 5733:    }
       60: 5734:    return 0;
        -: 5735:}
        -: 5736:
        -: 5737:/* check to see if user has jobs running/stopped */
        -: 5738:
        -: 5739:/**/
        -: 5740:static void
    #####: 5741:checkjobs(void)
        -: 5742:{
        -: 5743:    int i;
        -: 5744:
    #####: 5745:    for (i = 1; i <= maxjob; i++)
    #####: 5746:	if (i != thisjob && (jobtab[i].stat & STAT_LOCKED) &&
    #####: 5747:	    !(jobtab[i].stat & STAT_NOPRINT) &&
    #####: 5748:	    (isset(CHECKRUNNINGJOBS) || jobtab[i].stat & STAT_STOPPED))
        -: 5749:	    break;
    #####: 5750:    if (i <= maxjob) {
    #####: 5751:	if (jobtab[i].stat & STAT_STOPPED) {
        -: 5752:
        -: 5753:#ifdef USE_SUSPENDED
    #####: 5754:	    zerr("you have suspended jobs.");
        -: 5755:#else
        -: 5756:	    zerr("you have stopped jobs.");
        -: 5757:#endif
        -: 5758:
        -: 5759:	} else
    #####: 5760:	    zerr("you have running jobs.");
    #####: 5761:	stopmsg = 1;
        -: 5762:    }
    #####: 5763:}
        -: 5764:
        -: 5765:/*
        -: 5766: * -1 if the shell is already committed to exit.
        -: 5767: * positive if zexit() was already called.
        -: 5768: */
        -: 5769:
        -: 5770:/**/
        -: 5771:int shell_exiting;
        -: 5772:
        -: 5773:/*
        -: 5774: * Exit status if explicitly set by an exit command.
        -: 5775: * This is complicated by the fact the exit command may be within
        -: 5776: * a function whose state we need to unwind (exit_pending set
        -: 5777: * and the exit will happen up the stack), or we may need to execute
        -: 5778: * additional code such as a trap after we are committed to exiting
        -: 5779: * (shell_exiting and the exit will happen down the stack).
        -: 5780: *
        -: 5781: * It's lucky this is all so obvious there is no possibility of any
        -: 5782: * bugs.  (C.f. the entire rest of the shell.)
        -: 5783: */
        -: 5784:/**/
        -: 5785:int exit_val;
        -: 5786:
        -: 5787:/*
        -: 5788: * Actually exit the shell, working out the status locally.
        -: 5789: * This is exit_val if "exit" has explicitly been called in the shell,
        -: 5790: * else lastval.
        -: 5791: */
        -: 5792:
        -: 5793:/**/
        -: 5794:void
    #####: 5795:realexit(void)
        -: 5796:{
    #####: 5797:    exit((shell_exiting || exit_pending) ? exit_val : lastval);
        -: 5798:}
        -: 5799:
        -: 5800:/* As realexit(), but call _exit instead */
        -: 5801:
        -: 5802:/**/
        -: 5803:void
    #####: 5804:_realexit(void)
        -: 5805:{
    #####: 5806:    _exit((shell_exiting || exit_pending) ? exit_val : lastval);
        -: 5807:}
        -: 5808:
        -: 5809:/* exit the shell.  val is the return value of the shell.  *
        -: 5810: * from_where is
        -: 5811: *   ZEXIT_SIGNAL   if zexit is called because of a signal
        -: 5812: *   ZEXIT_DEFERRED if we can't actually exit yet (e.g., functions need
        -: 5813: *                  terminating) but should perform the usual interactive
        -: 5814: *                  tests.
        -: 5815: */
        -: 5816:
        -: 5817:/**/
        -: 5818:mod_export void
        7: 5819:zexit(int val, enum zexit_t from_where)
        -: 5820:{
        -: 5821:    /*
        -: 5822:     * Don't do anything recursively:  see below.
        -: 5823:     * Do, however, update exit status --- there's no nesting,
        -: 5824:     * a later value always overrides an earlier.
        -: 5825:     */
        7: 5826:    exit_val = val;
        7: 5827:    if (shell_exiting == -1) {
    #####: 5828:	retflag = 1;
    #####: 5829:	breaks = loops;
    #####: 5830:	return;
        -: 5831:    }
        -: 5832:
        7: 5833:    if (isset(MONITOR) && !stopmsg && from_where != ZEXIT_SIGNAL) {
    #####: 5834:	scanjobs();    /* check if jobs need printing           */
    #####: 5835:	if (isset(CHECKJOBS))
    #####: 5836:	    checkjobs();   /* check if any jobs are running/stopped */
    #####: 5837:	if (stopmsg) {
    #####: 5838:	    stopmsg = 2;
    #####: 5839:	    return;
        -: 5840:	}
        -: 5841:    }
        -: 5842:    /* Positive shell_exiting means we have been here before */
       14: 5843:    if (from_where == ZEXIT_DEFERRED ||
        7: 5844:	(shell_exiting++ && from_where != ZEXIT_NORMAL))
    #####: 5845:	return;
        -: 5846:
        -: 5847:    /*
        -: 5848:     * We're now committed to exiting.  Set shell_exiting to -1 to
        -: 5849:     * indicate we shouldn't do any recursive processing.
        -: 5850:     */
        7: 5851:    shell_exiting = -1;
        -: 5852:    /*
        -: 5853:     * We want to do all remaining processing regardless of preceding
        -: 5854:     * errors, even user interrupts.
        -: 5855:     */
        7: 5856:    errflag = 0;
        -: 5857:
        7: 5858:    if (isset(MONITOR)) {
        -: 5859:	/* send SIGHUP to any jobs left running  */
    #####: 5860:	killrunjobs(from_where == ZEXIT_SIGNAL);
        -: 5861:    }
        7: 5862:    if (isset(RCS) && interact) {
    #####: 5863:	if (!nohistsave) {
    #####: 5864:	    int writeflags = HFILE_USE_OPTIONS;
    #####: 5865:	    if (from_where == ZEXIT_SIGNAL)
    #####: 5866:		writeflags |= HFILE_NO_REWRITE;
    #####: 5867:	    saveandpophiststack(1, writeflags);
    #####: 5868:	    savehistfile(NULL, 1, writeflags);
        -: 5869:	}
    #####: 5870:	if (islogin && !subsh) {
    #####: 5871:	    sourcehome(".zlogout");
        -: 5872:#ifdef GLOBAL_ZLOGOUT
    #####: 5873:	    if (isset(RCS) && isset(GLOBALRCS))
    #####: 5874:		source(GLOBAL_ZLOGOUT);
        -: 5875:#endif
        -: 5876:	}
        -: 5877:    }
        7: 5878:    lastval = exit_val;
        -: 5879:    /*
        -: 5880:     * Now we are committed to exiting any previous state
        -: 5881:     * is irrelevant.  Ensure trap can run.
        -: 5882:     */
        7: 5883:    errflag = intrap = 0;
        7: 5884:    if (sigtrapped[SIGEXIT])
    #####: 5885:	dotrap(SIGEXIT);
        7: 5886:    callhookfunc("zshexit", NULL, 1, NULL);
        7: 5887:    runhookdef(EXITHOOK, NULL);
        7: 5888:    if (opts[MONITOR] && interact && (SHTTY != -1)) {
    #####: 5889:       release_pgrp();
        -: 5890:    }
        7: 5891:    if (mypid != getpid())
    #####: 5892:	_exit(exit_val);
        -: 5893:    else
        7: 5894:	exit(exit_val);
        -: 5895:}
        -: 5896:
        -: 5897:/* . (dot), source */
        -: 5898:
        -: 5899:/**/
        -: 5900:int
    #####: 5901:bin_dot(char *name, char **argv, UNUSED(Options ops), UNUSED(int func))
        -: 5902:{
    #####: 5903:    char **old, *old0 = NULL;
    #####: 5904:    int diddot = 0, dotdot = 0;
        -: 5905:    char *s, **t, *enam, *arg0, *buf;
        -: 5906:    struct stat st;
        -: 5907:    enum source_return ret;
        -: 5908:
    #####: 5909:    if (!*argv)
    #####: 5910:	return 0;
    #####: 5911:    old = pparams;
        -: 5912:    /* get arguments for the script */
    #####: 5913:    if (argv[1])
    #####: 5914:	pparams = zarrdup(argv + 1);
        -: 5915:
    #####: 5916:    enam = arg0 = ztrdup(*argv);
    #####: 5917:    if (isset(FUNCTIONARGZERO)) {
    #####: 5918:	old0 = argzero;
    #####: 5919:	argzero = ztrdup(arg0);
        -: 5920:    }
    #####: 5921:    s = unmeta(enam);
    #####: 5922:    errno = ENOENT;
    #####: 5923:    ret = SOURCE_NOT_FOUND;
        -: 5924:    /* for source only, check in current directory first */
    #####: 5925:    if (*name != '.' && access(s, F_OK) == 0
    #####: 5926:	&& stat(s, &st) >= 0 && !S_ISDIR(st.st_mode)) {
    #####: 5927:	diddot = 1;
    #####: 5928:	ret = source(enam);
        -: 5929:    }
    #####: 5930:    if (ret == SOURCE_NOT_FOUND) {
        -: 5931:	/* use a path with / in it */
    #####: 5932:	for (s = arg0; *s; s++)
    #####: 5933:	    if (*s == '/') {
    #####: 5934:		if (*arg0 == '.') {
    #####: 5935:		    if (arg0 + 1 == s)
    #####: 5936:			++diddot;
    #####: 5937:		    else if (arg0[1] == '.' && arg0 + 2 == s)
    #####: 5938:			++dotdot;
        -: 5939:		}
    #####: 5940:		ret = source(arg0);
    #####: 5941:		break;
        -: 5942:	    }
    #####: 5943:	if (!*s || (ret == SOURCE_NOT_FOUND &&
    #####: 5944:		    isset(PATHDIRS) && diddot < 2 && dotdot == 0)) {
    #####: 5945:	    pushheap();
        -: 5946:	    /* search path for script */
    #####: 5947:	    for (t = path; *t; t++) {
    #####: 5948:		if (!(*t)[0] || ((*t)[0] == '.' && !(*t)[1])) {
    #####: 5949:		    if (diddot)
    #####: 5950:			continue;
    #####: 5951:		    diddot = 1;
    #####: 5952:		    buf = dupstring(arg0);
        -: 5953:		} else
    #####: 5954:		    buf = zhtricat(*t, "/", arg0);
        -: 5955:
    #####: 5956:		s = unmeta(buf);
    #####: 5957:		if (access(s, F_OK) == 0 && stat(s, &st) >= 0
    #####: 5958:		    && !S_ISDIR(st.st_mode)) {
    #####: 5959:		    ret = source(enam = buf);
    #####: 5960:		    break;
        -: 5961:		}
        -: 5962:	    }
    #####: 5963:	    popheap();
        -: 5964:	}
        -: 5965:    }
        -: 5966:    /* clean up and return */
    #####: 5967:    if (argv[1]) {
    #####: 5968:	freearray(pparams);
    #####: 5969:	pparams = old;
        -: 5970:    }
    #####: 5971:    if (ret == SOURCE_NOT_FOUND) {
    #####: 5972:	if (isset(POSIXBUILTINS)) {
        -: 5973:	    /* hard error in POSIX (we'll exit later) */
    #####: 5974:	    zerrnam(name, "%e: %s", errno, enam);
        -: 5975:	} else {
    #####: 5976:	    zwarnnam(name, "%e: %s", errno, enam);
        -: 5977:	}
        -: 5978:    }
    #####: 5979:    zsfree(arg0);
    #####: 5980:    if (old0) {
    #####: 5981:	zsfree(argzero);
    #####: 5982:	argzero = old0;
        -: 5983:    }
    #####: 5984:    return ret == SOURCE_OK ? lastval : 128 - ret;
        -: 5985:}
        -: 5986:
        -: 5987:/*
        -: 5988: * common for bin_emulate and bin_eval
        -: 5989: */
        -: 5990:
        -: 5991:static int
       39: 5992:eval(char **argv)
        -: 5993:{
        -: 5994:    Eprog prog;
       39: 5995:    char *oscriptname = scriptname;
       39: 5996:    int oineval = ineval, fpushed;
        -: 5997:    struct funcstack fstack;
        -: 5998:
        -: 5999:    /*
        -: 6000:     * If EVALLINENO is not set, we use the line number of the
        -: 6001:     * environment and must flag this up to exec.c.  Otherwise,
        -: 6002:     * we use a special script name to indicate the special line number.
        -: 6003:     */
       39: 6004:    ineval = !isset(EVALLINENO);
       39: 6005:    if (!ineval) {
       27: 6006:	scriptname = "(eval)";
       27: 6007:	fstack.prev = funcstack;
       27: 6008:	fstack.name = scriptname;
       27: 6009:	fstack.caller = funcstack ? funcstack->name : dupstring(argzero);
       27: 6010:	fstack.lineno = lineno;
       27: 6011:	fstack.tp = FS_EVAL;
        -: 6012:
        -: 6013:	/*
        -: 6014:	 * To get file line numbers, we need to know if parent is
        -: 6015:	 * the original script/shell or a sourced file, in which
        -: 6016:	 * case we use the line number raw, or a function or eval,
        -: 6017:	 * in which case we need to deduce where that came from.
        -: 6018:	 *
        -: 6019:	 * This replicates the logic for working out the information
        -: 6020:	 * for $funcfiletrace---eval is similar to an inlined function
        -: 6021:	 * call from a tracing perspective.
        -: 6022:	 */
       27: 6023:	if (!funcstack || funcstack->tp == FS_SOURCE) {
    #####: 6024:	    fstack.flineno = fstack.lineno;
    #####: 6025:	    fstack.filename = fstack.caller;
        -: 6026:	} else {
       27: 6027:	    fstack.flineno = funcstack->flineno + lineno;
        -: 6028:	    /*
        -: 6029:	     * Line numbers in eval start from 1, not zero,
        -: 6030:	     * so offset by one to get line in file.
        -: 6031:	     */
       27: 6032:	    if (funcstack->tp == FS_EVAL)
        6: 6033:		fstack.flineno--;
       27: 6034:	    fstack.filename = funcstack->filename;
       27: 6035:	    if (!fstack.filename)
    #####: 6036:		fstack.filename = "";
        -: 6037:	}
       27: 6038:	funcstack = &fstack;
        -: 6039:
       27: 6040:	fpushed = 1;
        -: 6041:    } else
       12: 6042:	fpushed = 0;
        -: 6043:
       39: 6044:    prog = parse_string(zjoin(argv, ' ', 1), 1);
       39: 6045:    if (prog) {
       39: 6046:	if (wc_code(*prog->prog) != WC_LIST) {
        -: 6047:	    /* No code to execute */
    #####: 6048:	    lastval = 0;
        -: 6049:	} else {
       39: 6050:	    execode(prog, 1, 0, "eval");
        -: 6051:
       39: 6052:	    if (errflag && !lastval)
    #####: 6053:		lastval = errflag;
        -: 6054:	}
        -: 6055:    } else {
    #####: 6056:	lastval = 1;
        -: 6057:    }
        -: 6058:
       39: 6059:    if (fpushed)
       27: 6060:	funcstack = funcstack->prev;
        -: 6061:
       39: 6062:    errflag &= ~ERRFLAG_ERROR;
       39: 6063:    scriptname = oscriptname;
       39: 6064:    ineval = oineval;
        -: 6065:
       39: 6066:    return lastval;
        -: 6067:}
        -: 6068:
        -: 6069:/* emulate: set emulation mode and optionally evaluate shell code */
        -: 6070:
        -: 6071:/**/
        -: 6072:int
       65: 6073:bin_emulate(char *nam, char **argv, Options ops, UNUSED(int func))
        -: 6074:{
       65: 6075:    int opt_L = OPT_ISSET(ops, 'L');
       65: 6076:    int opt_R = OPT_ISSET(ops, 'R');
       65: 6077:    int opt_l = OPT_ISSET(ops, 'l');
        -: 6078:    int saveemulation, savehackchar;
       65: 6079:    int ret = 1, new_emulation;
        -: 6080:    unsigned int savepatterns;
        -: 6081:    char saveopts[OPT_SIZE], new_opts[OPT_SIZE];
       65: 6082:    char *cmd = 0;
       65: 6083:    const char *shname = *argv;
        -: 6084:    LinkList optlist;
        -: 6085:    LinkNode optnode;
        -: 6086:    Emulation_options save_sticky;
        -: 6087:    OptIndex *on_ptr, *off_ptr;
        -: 6088:
        -: 6089:    /* without arguments just print current emulation */
       65: 6090:    if (!shname) {
        3: 6091:	if (opt_L || opt_R) {
    #####: 6092:	    zwarnnam(nam, "not enough arguments");
    #####: 6093:	    return 1;
        -: 6094:	}
        -: 6095:
        3: 6096:	switch(SHELL_EMULATION()) {
    #####: 6097:	case EMULATE_CSH:
    #####: 6098:	    shname = "csh";
    #####: 6099:	    break;
        -: 6100:
        1: 6101:	case EMULATE_KSH:
        1: 6102:	    shname = "ksh";
        1: 6103:	    break;
        -: 6104:
        1: 6105:	case EMULATE_SH:
        1: 6106:	    shname = "sh";
        1: 6107:	    break;
        -: 6108:
        1: 6109:	default:
        1: 6110:	    shname = "zsh";
        1: 6111:	    break;
        -: 6112:	}
        -: 6113:
        3: 6114:	printf("%s\n", shname);
        3: 6115:	return 0;
        -: 6116:    }
        -: 6117:
        -: 6118:    /* with single argument set current emulation */
       62: 6119:    if (!argv[1]) {
        -: 6120:	char *cmdopts;
       43: 6121:	if (opt_l) {
    #####: 6122:	    cmdopts = (char *)zhalloc(OPT_SIZE);
    #####: 6123:	    memcpy(cmdopts, opts, OPT_SIZE);
        -: 6124:	} else
       43: 6125:	    cmdopts = opts;
       43: 6126:	emulate(shname, opt_R, &emulation, cmdopts);
       43: 6127:	if (opt_L)
       82: 6128:	    cmdopts[LOCALOPTIONS] = cmdopts[LOCALTRAPS] =
       82: 6129:		cmdopts[LOCALPATTERNS] = 1;
       43: 6130:	if (opt_l) {
    #####: 6131:	    list_emulate_options(cmdopts, opt_R);
    #####: 6132:	    return 0;
        -: 6133:	}
       43: 6134:	clearpatterndisables();
       43: 6135:	return 0;
        -: 6136:    }
        -: 6137:
       19: 6138:    if (opt_l) {
    #####: 6139:	zwarnnam(nam, "too many arguments for -l");
    #####: 6140:	return 1;
        -: 6141:    }
        -: 6142:
       19: 6143:    argv++;
       19: 6144:    memcpy(saveopts, opts, sizeof(opts));
       19: 6145:    memcpy(new_opts, opts, sizeof(opts));
       19: 6146:    savehackchar = keyboardhackchar;
       19: 6147:    emulate(shname, opt_R, &new_emulation, new_opts);
       19: 6148:    optlist = newlinklist();
       19: 6149:    if (parseopts(nam, &argv, new_opts, &cmd, optlist, 0, NULL)) {
        1: 6150:	ret = 1;
        1: 6151:	goto restore;
        -: 6152:    }
        -: 6153:
        -: 6154:    /* parseopts() has consumed anything that looks like an option */
       18: 6155:    if (*argv) {
    #####: 6156:	zwarnnam(nam, "unknown argument %s", *argv);
    #####: 6157:	goto restore;
        -: 6158:    }
        -: 6159:
       18: 6160:    savepatterns = savepatterndisables();
        -: 6161:    /*
        -: 6162:     * All emulations start with an empty set of pattern disables,
        -: 6163:     * hence no special "sticky" behaviour is required.
        -: 6164:     */
       18: 6165:    clearpatterndisables();
        -: 6166:
       18: 6167:    saveemulation = emulation;
       18: 6168:    emulation = new_emulation;
       18: 6169:    memcpy(opts, new_opts, sizeof(opts));
        -: 6170:    /* If "-c command" is given, evaluate command using specified
        -: 6171:     * emulation mode.
        -: 6172:     */
       18: 6173:    if (cmd) {
       18: 6174:	if (opt_L) {
    #####: 6175:	    zwarnnam(nam, "option -L incompatible with -c");
    #####: 6176:	    goto restore2;
        -: 6177:	}
       18: 6178:	*--argv = cmd;	/* on stack, never free()d, see execbuiltin() */
        -: 6179:    } else {
    #####: 6180:	if (opt_L)
    #####: 6181:	    opts[LOCALOPTIONS] = opts[LOCALTRAPS] = opts[LOCALPATTERNS] = 1;
    #####: 6182:	return 0;
        -: 6183:    }
        -: 6184:
       18: 6185:    save_sticky = sticky;
       18: 6186:    sticky = hcalloc(sizeof(*sticky));
       18: 6187:    sticky->emulation = emulation;
       24: 6188:    for (optnode = firstnode(optlist); optnode; incnode(optnode)) {
        -: 6189:	/* Data is index into new_opts */
        6: 6190:	char *optptr = (char *)getdata(optnode);
        6: 6191:	if (*optptr)
        6: 6192:	    sticky->n_on_opts++;
        -: 6193:	else
    #####: 6194:	    sticky->n_off_opts++;
        -: 6195:    }
       18: 6196:    if (sticky->n_on_opts)
       10: 6197:	on_ptr = sticky->on_opts =
       10: 6198:	    zhalloc(sticky->n_on_opts * sizeof(*sticky->on_opts));
        -: 6199:    else
       13: 6200:	on_ptr = NULL;
       18: 6201:    if (sticky->n_off_opts)
    #####: 6202:	off_ptr = sticky->off_opts = zhalloc(sticky->n_off_opts *
        -: 6203:					     sizeof(*sticky->off_opts));
        -: 6204:    else
       18: 6205:	off_ptr = NULL;
       24: 6206:    for (optnode = firstnode(optlist); optnode; incnode(optnode)) {
        -: 6207:	/* Data is index into new_opts */
        6: 6208:	char *optptr = (char *)getdata(optnode);
        6: 6209:	int optno = optptr - new_opts;
        6: 6210:	if (*optptr)
        6: 6211:	    *on_ptr++ = optno;
        -: 6212:	else
    #####: 6213:	    *off_ptr++ = optno;
        -: 6214:    }
       18: 6215:    ret = eval(argv);
       18: 6216:    sticky = save_sticky;
       18: 6217:restore2:
       18: 6218:    emulation = saveemulation;
       18: 6219:    memcpy(opts, saveopts, sizeof(opts));
       18: 6220:    restorepatterndisables(savepatterns);
       19: 6221:restore:
       19: 6222:    keyboardhackchar = savehackchar;
       19: 6223:    inittyptab();	/* restore banghist */
       19: 6224:    return ret;
        -: 6225:}
        -: 6226:
        -: 6227:/* eval: simple evaluation */
        -: 6228:
        -: 6229:/**/
        -: 6230:mod_export int ineval;
        -: 6231:
        -: 6232:/**/
        -: 6233:int
       21: 6234:bin_eval(UNUSED(char *nam), char **argv, UNUSED(Options ops), UNUSED(int func))
        -: 6235:{
       21: 6236:    return eval(argv);
        -: 6237:}
        -: 6238:
        -: 6239:static char *zbuf;
        -: 6240:static int readfd;
        -: 6241:
        -: 6242:/* Read a character from readfd, or from the buffer zbuf.  Return EOF on end of
        -: 6243:file/buffer. */
        -: 6244:
        -: 6245:/* read: get a line of input, or (for compctl functions) return some *
        -: 6246: * useful data about the state of the editing line.  The -E and -e   *
        -: 6247: * options mean that the result should be sent to stdout.  -e means, *
        -: 6248: * in addition, that the result should not actually be assigned to   *
        -: 6249: * the specified parameters.                                         */
        -: 6250:
        -: 6251:/**/
        -: 6252:int
      303: 6253:bin_read(char *name, char **args, Options ops, UNUSED(int func))
        -: 6254:{
        -: 6255:    char *reply, *readpmpt;
      303: 6256:    int bsiz, c = 0, gotnl = 0, al = 0, first, nchars = 1, bslash, keys = 0;
      303: 6257:    int haso = 0;	/* true if /dev/tty has been opened specially */
      303: 6258:    int isem = !strcmp(term, "emacs"), izle = zleactive;
        -: 6259:    char *buf, *bptr, *firstarg, *zbuforig;
      303: 6260:    LinkList readll = newlinklist();
      303: 6261:    FILE *oshout = NULL;
      303: 6262:    int readchar = -1, val, resettty = 0;
        -: 6263:    struct ttyinfo saveti;
        -: 6264:    char d;
      303: 6265:    long izle_timeout = 0;
        -: 6266:#ifdef MULTIBYTE_SUPPORT
      303: 6267:    wchar_t delim = L'\n', wc;
        -: 6268:    mbstate_t mbs;
        -: 6269:    char *laststart;
        -: 6270:    size_t ret;
        -: 6271:#else
        -: 6272:    char delim = '\n';
        -: 6273:#endif
        -: 6274:
      303: 6275:    if (OPT_HASARG(ops,c='k')) {
    #####: 6276:	char *eptr, *optarg = OPT_ARG(ops,c);
    #####: 6277:	nchars = (int)zstrtol(optarg, &eptr, 10);
    #####: 6278:	if (*eptr) {
    #####: 6279:	    zwarnnam(name, "number expected after -%c: %s", c, optarg);
    #####: 6280:	    return 1;
        -: 6281:	}
        -: 6282:    }
        -: 6283:    /* This `*args++ : *args' looks a bit weird, but it works around a bug
        -: 6284:     * in gcc-2.8.1 under DU 4.0. */
      303: 6285:    firstarg = (*args && **args == '?' ? *args++ : *args);
      303: 6286:    reply = *args ? *args++ : OPT_ISSET(ops,'A') ? "reply" : "REPLY";
        -: 6287:
      303: 6288:    if (OPT_ISSET(ops,'A') && *args) {
    #####: 6289:	zwarnnam(name, "only one array argument allowed");
    #####: 6290:	return 1;
        -: 6291:    }
        -: 6292:
        -: 6293:    /* handle compctl case */
      303: 6294:    if(OPT_ISSET(ops,'l') || OPT_ISSET(ops,'c'))
    #####: 6295:	return compctlreadptr(name, args, ops, reply);
        -: 6296:
      303: 6297:    if ((OPT_ISSET(ops,'k') || OPT_ISSET(ops,'q')) &&
    #####: 6298:	!OPT_ISSET(ops,'u') && !OPT_ISSET(ops,'p')) {
    #####: 6299:	if (!zleactive) {
    #####: 6300:	    if (SHTTY == -1) {
        -: 6301:		/* need to open /dev/tty specially */
    #####: 6302:		if ((SHTTY = open("/dev/tty", O_RDWR|O_NOCTTY)) != -1) {
    #####: 6303:		    haso = 1;
    #####: 6304:		    oshout = shout;
    #####: 6305:		    init_shout();
        -: 6306:		}
    #####: 6307:	    } else if (!shout) {
        -: 6308:		/* We need an output FILE* on the tty */
    #####: 6309:		init_shout();
        -: 6310:	    }
        -: 6311:	    /* We should have a SHTTY opened by now. */
    #####: 6312:	    if (SHTTY == -1) {
        -: 6313:		/* Unfortunately, we didn't. */
    #####: 6314:		fprintf(stderr, "not interactive and can't open terminal\n");
    #####: 6315:		fflush(stderr);
    #####: 6316:		return 1;
        -: 6317:	    }
    #####: 6318:	    if (unset(INTERACTIVE))
    #####: 6319:		gettyinfo(&shttyinfo);
        -: 6320:	    /* attach to the tty */
    #####: 6321:	    attachtty(mypgrp);
    #####: 6322:	    if (!isem)
    #####: 6323:		setcbreak();
    #####: 6324:	    readfd = SHTTY;
        -: 6325:	}
    #####: 6326:	keys = 1;
      606: 6327:    } else if (OPT_HASARG(ops,'u') && !OPT_ISSET(ops,'p')) {
        -: 6328:	/* -u means take input from the specified file descriptor. */
      303: 6329:	char *eptr, *argptr = OPT_ARG(ops,'u');
        -: 6330:	/* The old code handled -up, but that was never documented. Still...*/
      303: 6331:	if (!strcmp(argptr, "p")) {
    #####: 6332:	    readfd = coprocin;
    #####: 6333:	    if (readfd < 0) {
    #####: 6334:		zwarnnam(name, "-p: no coprocess");
    #####: 6335:		return 1;
        -: 6336:	    }
        -: 6337:	} else {
      303: 6338:	    readfd = (int)zstrtol(argptr, &eptr, 10);
      303: 6339:	    if (*eptr) {
    #####: 6340:		zwarnnam(name, "number expected after -%c: %s", 'u', argptr);
    #####: 6341:		return 1;
        -: 6342:	    }
        -: 6343:	}
        -: 6344:#if 0
        -: 6345:	/* This code is left as a warning to future generations --- pws. */
        -: 6346:	for (readfd = 9; readfd && !OPT_ISSET(ops,readfd + '0'); --readfd);
        -: 6347:#endif
      303: 6348:	izle = 0;
    #####: 6349:    } else if (OPT_ISSET(ops,'p')) {
    #####: 6350:	readfd = coprocin;
    #####: 6351:	if (readfd < 0) {
    #####: 6352:	    zwarnnam(name, "-p: no coprocess");
    #####: 6353:	    return 1;
        -: 6354:	}
    #####: 6355:	izle = 0;
        -: 6356:    } else
    #####: 6357:	readfd = izle = 0;
        -: 6358:
      303: 6359:    if (OPT_ISSET(ops,'s') && SHTTY != -1) {
        -: 6360:	struct ttyinfo ti;
    #####: 6361:	gettyinfo(&ti);
    #####: 6362:	saveti = ti;
    #####: 6363:	resettty = 1;
        -: 6364:#ifdef HAS_TIO
    #####: 6365:	ti.tio.c_lflag &= ~ECHO;
        -: 6366:#else
        -: 6367:	ti.sgttyb.sg_flags &= ~ECHO;
        -: 6368:#endif
    #####: 6369:	settyinfo(&ti);
        -: 6370:    }
        -: 6371:
        -: 6372:    /* handle prompt */
      303: 6373:    if (firstarg) {
     4242: 6374:	for (readpmpt = firstarg;
     7272: 6375:	     *readpmpt && *readpmpt != '?'; readpmpt++);
      303: 6376:	if (*readpmpt++) {
    #####: 6377:	    if (keys || isatty(0)) {
    #####: 6378:		zputs(readpmpt, (shout ? shout : stderr));
    #####: 6379:		fflush(shout ? shout : stderr);
        -: 6380:	    }
    #####: 6381:	    readpmpt[-1] = '\0';
        -: 6382:	}
        -: 6383:    }
        -: 6384:
      303: 6385:    if (OPT_ISSET(ops,'d')) {
    #####: 6386:	char *delimstr = OPT_ARG(ops,'d');
        -: 6387:#ifdef MULTIBYTE_SUPPORT
        -: 6388:	wint_t wi;
        -: 6389:
    #####: 6390:	if (isset(MULTIBYTE)) {
    #####: 6391:	    mb_charinit();
    #####: 6392:	    (void)mb_metacharlenconv(delimstr, &wi);
        -: 6393:	}
        -: 6394:	else
    #####: 6395:	    wi = WEOF;
    #####: 6396:	if (wi != WEOF)
    #####: 6397:	    delim = (wchar_t)wi;
        -: 6398:	else
    #####: 6399:	    delim = (wchar_t)((delimstr[0] == Meta) ?
    #####: 6400:			      delimstr[1] ^ 32 : delimstr[0]);
        -: 6401:#else
        -: 6402:        delim = (delimstr[0] == Meta) ? delimstr[1] ^ 32 : delimstr[0];
        -: 6403:#endif
    #####: 6404:	if (SHTTY != -1) {
        -: 6405:	    struct ttyinfo ti;
    #####: 6406:	    gettyinfo(&ti);
    #####: 6407:	    if (! resettty) {
    #####: 6408:	      saveti = ti;
    #####: 6409:	      resettty = 1;
        -: 6410:	    }
        -: 6411:#ifdef HAS_TIO
    #####: 6412:	    ti.tio.c_lflag &= ~ICANON;
    #####: 6413:	    ti.tio.c_cc[VMIN] = 1;
    #####: 6414:	    ti.tio.c_cc[VTIME] = 0;
        -: 6415:#else
        -: 6416:	    ti.sgttyb.sg_flags |= CBREAK;
        -: 6417:#endif
    #####: 6418:	    settyinfo(&ti);
        -: 6419:	}
        -: 6420:    }
      303: 6421:    if (OPT_ISSET(ops,'t')) {
    #####: 6422:	zlong timeout = 0;
    #####: 6423:	if (OPT_HASARG(ops,'t')) {
    #####: 6424:	    mnumber mn = zero_mnumber;
    #####: 6425:	    mn = matheval(OPT_ARG(ops,'t'));
    #####: 6426:	    if (errflag)
    #####: 6427:		return 1;
    #####: 6428:	    if (mn.type == MN_FLOAT) {
    #####: 6429:		mn.u.d *= 1e6;
    #####: 6430:		timeout = (zlong)mn.u.d;
        -: 6431:	    } else {
    #####: 6432:		timeout = (zlong)mn.u.l * (zlong)1000000;
        -: 6433:	    }
        -: 6434:	}
    #####: 6435:	if (izle) {
        -: 6436:	    /*
        -: 6437:	     * Timeout is in 100ths of a second rather than us.
        -: 6438:	     * See calc_timeout() in zle_main for format of this.
        -: 6439:	     */
    #####: 6440:	    timeout = -(timeout/(zlong)10000 + 1L);
    #####: 6441:	    izle_timeout = (long)timeout;
        -: 6442:#ifdef LONG_MAX
        -: 6443:	    /* saturate if range exceeded */
    #####: 6444:	    if ((zlong)izle_timeout != timeout)
    #####: 6445:		izle_timeout = LONG_MAX;
        -: 6446:#endif
        -: 6447:	} else {
    #####: 6448:	    if (readfd == -1 ||
    #####: 6449:		!read_poll(readfd, &readchar, keys && !zleactive,
        -: 6450:			   timeout)) {
    #####: 6451:		if (keys && !zleactive && !isem)
    #####: 6452:		    settyinfo(&shttyinfo);
    #####: 6453:		else if (resettty && SHTTY != -1)
    #####: 6454:		    settyinfo(&saveti);
    #####: 6455:		if (haso) {
    #####: 6456:		    fclose(shout);
    #####: 6457:		    shout = oshout;
    #####: 6458:		    SHTTY = -1;
        -: 6459:		}
    #####: 6460:		return OPT_ISSET(ops,'q') ? 2 : 1;
        -: 6461:	    }
        -: 6462:	}
        -: 6463:    }
        -: 6464:
        -: 6465:#ifdef MULTIBYTE_SUPPORT
      303: 6466:    memset(&mbs, 0, sizeof(mbs));
        -: 6467:#endif
        -: 6468:
        -: 6469:    /*
        -: 6470:     * option -k means read only a given number of characters (default 1)
        -: 6471:     * option -q means get one character, and interpret it as a Y or N
        -: 6472:     */
      303: 6473:    if (OPT_ISSET(ops,'k') || OPT_ISSET(ops,'q')) {
    #####: 6474:	int eof = 0;
        -: 6475:	/* allocate buffer space for result */
        -: 6476:#ifdef MULTIBYTE_SUPPORT
    #####: 6477:	bptr = buf = (char *)zalloc(nchars*MB_CUR_MAX+1);
        -: 6478:#else
        -: 6479:	bptr = buf = (char *)zalloc(nchars+1);
        -: 6480:#endif
        -: 6481:
        -: 6482:	do {
    #####: 6483:	    if (izle) {
    #####: 6484:		zleentry(ZLE_CMD_GET_KEY, izle_timeout, NULL, &val);
    #####: 6485:		if (val < 0) {
    #####: 6486:		    eof = 1;
    #####: 6487:		    break;
        -: 6488:		}
    #####: 6489:		*bptr = (char) val;
        -: 6490:#ifdef MULTIBYTE_SUPPORT
    #####: 6491:		if (isset(MULTIBYTE)) {
    #####: 6492:		    ret = mbrlen(bptr++, 1, &mbs);
    #####: 6493:		    if (ret == MB_INVALID)
    #####: 6494:			memset(&mbs, 0, sizeof(mbs));
        -: 6495:		    /* treat invalid as single character */
    #####: 6496:		    if (ret != MB_INCOMPLETE)
    #####: 6497:			nchars--;
    #####: 6498:		    continue;
        -: 6499:		} else {
    #####: 6500:		    bptr++;
    #####: 6501:		    nchars--;
        -: 6502:		}
        -: 6503:#else
        -: 6504:		bptr++;
        -: 6505:		nchars--;
        -: 6506:#endif
        -: 6507:	    } else {
        -: 6508:		/* If read returns 0, is end of file */
    #####: 6509:		if (readchar >= 0) {
    #####: 6510:		    *bptr = readchar;
    #####: 6511:		    val = 1;
    #####: 6512:		    readchar = -1;
        -: 6513:		} else {
    #####: 6514:		    while ((val = read(readfd, bptr, nchars)) < 0) {
    #####: 6515:			if (errno != EINTR ||
    #####: 6516:			    errflag || retflag || breaks || contflag)
        -: 6517:			    break;
        -: 6518:		    }
    #####: 6519:		    if (val <= 0) {
    #####: 6520:			eof = 1;
    #####: 6521:			break;
        -: 6522:		    }
        -: 6523:		}
        -: 6524:
        -: 6525:#ifdef MULTIBYTE_SUPPORT
    #####: 6526:		if (isset(MULTIBYTE)) {
    #####: 6527:		    while (val > 0) {
    #####: 6528:			ret = mbrlen(bptr, val, &mbs);
    #####: 6529:			if (ret == MB_INCOMPLETE) {
    #####: 6530:			    bptr += val;
    #####: 6531:			    break;
        -: 6532:			} else {
    #####: 6533:			    if (ret == MB_INVALID) {
    #####: 6534:				memset(&mbs, 0, sizeof(mbs));
        -: 6535:				/* treat as single byte */
    #####: 6536:				ret = 1;
        -: 6537:			    }
    #####: 6538:			    else if (ret == 0) /* handle null as normal char */
    #####: 6539:				ret = 1;
    #####: 6540:			    else if (ret > (size_t)val) {
        -: 6541:				/* Some mbrlen()s return the full char len */
    #####: 6542:				ret = val;
        -: 6543:			    }
    #####: 6544:			    nchars--;
    #####: 6545:			    val -= ret;
    #####: 6546:			    bptr += ret;
        -: 6547:			}
        -: 6548:		    }
    #####: 6549:		    continue;
        -: 6550:		}
        -: 6551:#endif
        -: 6552:		/* decrement number of characters read from number required */
    #####: 6553:		nchars -= val;
        -: 6554:
        -: 6555:		/* increment pointer past read characters */
    #####: 6556:		bptr += val;
        -: 6557:	    }
    #####: 6558:	} while (nchars > 0);
        -: 6559:
    #####: 6560:	if (!izle && !OPT_ISSET(ops,'u') && !OPT_ISSET(ops,'p')) {
        -: 6561:	    /* dispose of result appropriately, etc. */
    #####: 6562:	    if (isem)
    #####: 6563:		while (val > 0 && read(SHTTY, &d, 1) == 1 && d != '\n');
        -: 6564:	    else {
    #####: 6565:		settyinfo(&shttyinfo);
    #####: 6566:		resettty = 0;
        -: 6567:	    }
    #####: 6568:	    if (haso) {
    #####: 6569:		fclose(shout);	/* close(SHTTY) */
    #####: 6570:		shout = oshout;
    #####: 6571:		SHTTY = -1;
        -: 6572:	    }
        -: 6573:	}
        -: 6574:
    #####: 6575:	if (OPT_ISSET(ops,'q'))
        -: 6576:	{
        -: 6577:	    /*
        -: 6578:	     * Keep eof as status but status is now whether we read
        -: 6579:	     * 'y' or 'Y'.  If we timed out, status is 2.
        -: 6580:	     */
    #####: 6581:	    if (eof)
    #####: 6582:		eof = 2;
        -: 6583:	    else
    #####: 6584:		eof = (bptr - buf != 1 || (buf[0] != 'y' && buf[0] != 'Y'));
    #####: 6585:	    buf[0] = eof ? 'n' : 'y';
    #####: 6586:	    bptr = buf + 1;
        -: 6587:	}
    #####: 6588:	if (OPT_ISSET(ops,'e') || OPT_ISSET(ops,'E'))
    #####: 6589:	    fwrite(buf, bptr - buf, 1, stdout);
    #####: 6590:	if (!OPT_ISSET(ops,'e'))
    #####: 6591:	    setsparam(reply, metafy(buf, bptr - buf, META_REALLOC));
        -: 6592:	else
    #####: 6593:	    zfree(buf, bptr - buf + 1);
    #####: 6594:	if (resettty && SHTTY != -1)
    #####: 6595:	    settyinfo(&saveti);
    #####: 6596:	return eof;
        -: 6597:    }
        -: 6598:
        -: 6599:    /* All possible special types of input have been exhausted.  Take one line,
        -: 6600:       and assign words to the parameters until they run out.  Leftover words go
        -: 6601:       onto the last parameter.  If an array is specified, all the words become
        -: 6602:       separate elements of the array. */
        -: 6603:
      303: 6604:    zbuforig = zbuf = (!OPT_ISSET(ops,'z')) ? NULL :
    #####: 6605:	(nonempty(bufstack)) ? (char *) getlinknode(bufstack) : ztrdup("");
      303: 6606:    first = 1;
      303: 6607:    bslash = 0;
      606: 6608:    while (*args || (OPT_ISSET(ops,'A') && !gotnl)) {
    #####: 6609:	sigset_t s = child_unblock();
    #####: 6610:	buf = bptr = (char *)zalloc(bsiz = 64);
        -: 6611:#ifdef MULTIBYTE_SUPPORT
    #####: 6612:	laststart = buf;
    #####: 6613:	ret = MB_INCOMPLETE;
        -: 6614:#endif
        -: 6615:	/* get input, a character at a time */
    #####: 6616:	while (!gotnl) {
    #####: 6617:	    c = zread(izle, &readchar, izle_timeout);
        -: 6618:	    /* \ at the end of a line indicates a continuation *
        -: 6619:	     * line, except in raw mode (-r option)            */
        -: 6620:#ifdef MULTIBYTE_SUPPORT
    #####: 6621:	    if (c == EOF) {
        -: 6622:		/* not waiting to be completed any more */
    #####: 6623:		ret = 0;
    #####: 6624:		break;
        -: 6625:	    }
    #####: 6626:	    *bptr = (char)c;
    #####: 6627:	    if (isset(MULTIBYTE)) {
    #####: 6628:		ret = mbrtowc(&wc, bptr, 1, &mbs);
    #####: 6629:		if (!ret)	/* NULL */
    #####: 6630:		    ret = 1;
        -: 6631:	    } else {
    #####: 6632:		ret = 1;
    #####: 6633:		wc = (wchar_t)c;
        -: 6634:	    }
    #####: 6635:	    if (ret != MB_INCOMPLETE) {
    #####: 6636:		if (ret == MB_INVALID) {
    #####: 6637:		    memset(&mbs, 0, sizeof(mbs));
        -: 6638:		    /* Treat this as a single character */
    #####: 6639:		    wc = (wchar_t)c;
    #####: 6640:		    laststart = bptr;
        -: 6641:		}
    #####: 6642:		if (bslash && wc == delim) {
    #####: 6643:		    bslash = 0;
    #####: 6644:		    continue;
        -: 6645:		}
    #####: 6646:		if (wc == delim)
    #####: 6647:		    break;
        -: 6648:		/*
        -: 6649:		 * `first' is non-zero if any separator we encounter is a
        -: 6650:		 * non-whitespace separator, which means that anything
        -: 6651:		 * (even an empty string) between, before or after separators
        -: 6652:		 * is significant.  If it is zero, we have a whitespace
        -: 6653:		 * separator, which shouldn't cause extra empty strings to
        -: 6654:		 * be emitted.  Hence the test for (*buf || first) when
        -: 6655:		 * we assign the result of reading a word.
        -: 6656:		 */
    #####: 6657:		if (!bslash && wcsitype(wc, ISEP)) {
    #####: 6658:		    if (bptr != buf ||
    #####: 6659:			(!(c < 128 && iwsep(c)) && first)) {
    #####: 6660:			first |= !(c < 128 && iwsep(c));
    #####: 6661:			break;
        -: 6662:		    }
    #####: 6663:		    first |= !(c < 128 && iwsep(c));
    #####: 6664:		    continue;
        -: 6665:		}
    #####: 6666:		bslash = (wc == L'\\' && !bslash && !OPT_ISSET(ops,'r'));
    #####: 6667:		if (bslash)
    #####: 6668:		    continue;
    #####: 6669:		first = 0;
        -: 6670:	    }
    #####: 6671:	    if (imeta(STOUC(*bptr))) {
    #####: 6672:		bptr[1] = bptr[0] ^ 32;
    #####: 6673:		bptr[0] = Meta;
    #####: 6674:		bptr += 2;
        -: 6675:	    }
        -: 6676:	    else
    #####: 6677:		bptr++;
    #####: 6678:	    if (ret != MB_INCOMPLETE)
    #####: 6679:		laststart = bptr;
        -: 6680:#else
        -: 6681:	    if (c == EOF)
        -: 6682:		break;
        -: 6683:	    if (bslash && c == delim) {
        -: 6684:		bslash = 0;
        -: 6685:		continue;
        -: 6686:	    }
        -: 6687:	    if (c == delim)
        -: 6688:		break;
        -: 6689:	    /*
        -: 6690:	     * `first' is non-zero if any separator we encounter is a
        -: 6691:	     * non-whitespace separator, which means that anything
        -: 6692:	     * (even an empty string) between, before or after separators
        -: 6693:	     * is significant.  If it is zero, we have a whitespace
        -: 6694:	     * separator, which shouldn't cause extra empty strings to
        -: 6695:	     * be emitted.  Hence the test for (*buf || first) when
        -: 6696:	     * we assign the result of reading a word.
        -: 6697:	     */
        -: 6698:	    if (!bslash && isep(c)) {
        -: 6699:		if (bptr != buf || (!iwsep(c) && first)) {
        -: 6700:		    first |= !iwsep(c);
        -: 6701:		    break;
        -: 6702:		}
        -: 6703:		first |= !iwsep(c);
        -: 6704:		continue;
        -: 6705:	    }
        -: 6706:	    bslash = c == '\\' && !bslash && !OPT_ISSET(ops,'r');
        -: 6707:	    if (bslash)
        -: 6708:		continue;
        -: 6709:	    first = 0;
        -: 6710:	    if (imeta(c)) {
        -: 6711:		*bptr++ = Meta;
        -: 6712:		*bptr++ = c ^ 32;
        -: 6713:	    } else
        -: 6714:		*bptr++ = c;
        -: 6715:#endif
        -: 6716:	    /* increase the buffer size, if necessary */
    #####: 6717:	    if (bptr >= buf + bsiz - 1) {
    #####: 6718:		int blen = bptr - buf;
        -: 6719:#ifdef MULTIBYTE_SUPPORT
    #####: 6720:		int llen = laststart - buf;
        -: 6721:#endif
        -: 6722:
    #####: 6723:		buf = realloc(buf, bsiz *= 2);
    #####: 6724:		bptr = buf + blen;
        -: 6725:#ifdef MULTIBYTE_SUPPORT
    #####: 6726:		laststart = buf + llen;
        -: 6727:#endif
        -: 6728:	    }
        -: 6729:	}
    #####: 6730:	signal_setmask(s);
        -: 6731:#ifdef MULTIBYTE_SUPPORT
    #####: 6732:	if (c == EOF) {
    #####: 6733:	    gotnl = 1;
    #####: 6734:	    *bptr = '\0';	/* see below */
    #####: 6735:	} else if (ret == MB_INCOMPLETE) {
        -: 6736:	    /*
        -: 6737:	     * We can only get here if there is an EOF in the
        -: 6738:	     * middle of a character... safest to keep the debris,
        -: 6739:	     * I suppose.
        -: 6740:	     */
    #####: 6741:	    *bptr = '\0';
        -: 6742:	} else {
    #####: 6743:	    if (wc == delim)
    #####: 6744:		gotnl = 1;
    #####: 6745:	    *laststart = '\0';
        -: 6746:	}
        -: 6747:#else
        -: 6748:	if (c == delim || c == EOF)
        -: 6749:	    gotnl = 1;
        -: 6750:	*bptr = '\0';
        -: 6751:#endif
        -: 6752:	/* dispose of word appropriately */
    #####: 6753:	if (OPT_ISSET(ops,'e') ||
        -: 6754:	    /*
        -: 6755:	     * When we're doing an array assignment, we'll
        -: 6756:	     * handle echoing at that point.  In all other
        -: 6757:	     * cases (including -A with no assignment)
        -: 6758:	     * we'll do it here.
        -: 6759:	     */
    #####: 6760:	    (OPT_ISSET(ops,'E') && !OPT_ISSET(ops,'A'))) {
    #####: 6761:	    zputs(buf, stdout);
    #####: 6762:	    putchar('\n');
        -: 6763:	}
    #####: 6764:	if (!OPT_ISSET(ops,'e') && (*buf || first || gotnl)) {
    #####: 6765:	    if (OPT_ISSET(ops,'A')) {
    #####: 6766:		addlinknode(readll, buf);
    #####: 6767:		al++;
        -: 6768:	    } else
    #####: 6769:		setsparam(reply, buf);
        -: 6770:	} else
    #####: 6771:	    free(buf);
    #####: 6772:	if (!OPT_ISSET(ops,'A'))
    #####: 6773:	    reply = *args++;
        -: 6774:    }
        -: 6775:    /* handle EOF */
      303: 6776:    if (c == EOF) {
    #####: 6777:	if (readfd == coprocin) {
    #####: 6778:	    close(coprocin);
    #####: 6779:	    close(coprocout);
    #####: 6780:	    coprocin = coprocout = -1;
        -: 6781:	}
        -: 6782:    }
        -: 6783:    /* final assignment (and display) of array parameter */
      303: 6784:    if (OPT_ISSET(ops,'A')) {
    #####: 6785:	char **pp, **p = NULL;
        -: 6786:	LinkNode n;
        -: 6787:
    #####: 6788:	p = (OPT_ISSET(ops,'e') ? (char **)NULL
    #####: 6789:	     : (char **)zalloc((al + 1) * sizeof(char *)));
        -: 6790:
    #####: 6791:	for (pp = p, n = firstnode(readll); n; incnode(n)) {
    #####: 6792:	    if (OPT_ISSET(ops,'E')) {
    #####: 6793:		zputs((char *) getdata(n), stdout);
    #####: 6794:		putchar('\n');
        -: 6795:	    }
    #####: 6796:	    if (p)
    #####: 6797:		*pp++ = (char *)getdata(n);
        -: 6798:	    else
    #####: 6799:		zsfree(getdata(n));
        -: 6800:	}
    #####: 6801:	if (p) {
    #####: 6802:	    *pp++ = NULL;
    #####: 6803:	    setaparam(reply, p);
        -: 6804:	}
    #####: 6805:	if (resettty && SHTTY != -1)
    #####: 6806:	    settyinfo(&saveti);
    #####: 6807:	return c == EOF;
        -: 6808:    }
      303: 6809:    buf = bptr = (char *)zalloc(bsiz = 64);
        -: 6810:#ifdef MULTIBYTE_SUPPORT
      303: 6811:    laststart = buf;
      303: 6812:    ret = MB_INCOMPLETE;
        -: 6813:#endif
        -: 6814:    /* any remaining part of the line goes into one parameter */
      303: 6815:    bslash = 0;
      303: 6816:    if (!gotnl) {
      303: 6817:	sigset_t s = child_unblock();
        -: 6818:	for (;;) {
    11997: 6819:	    c = zread(izle, &readchar, izle_timeout);
        -: 6820:#ifdef MULTIBYTE_SUPPORT
     6150: 6821:	    if (c == EOF) {
        -: 6822:		/* not waiting to be completed any more */
        3: 6823:		ret = 0;
        3: 6824:		break;
        -: 6825:	    }
     6147: 6826:	    *bptr = (char)c;
     6147: 6827:	    if (isset(MULTIBYTE)) {
     6147: 6828:		ret = mbrtowc(&wc, bptr, 1, &mbs);
     6147: 6829:		if (!ret)	/* NULL */
    #####: 6830:		    ret = 1;
        -: 6831:	    } else {
    #####: 6832:		ret = 1;
    #####: 6833:		wc = (wchar_t)c;
        -: 6834:	    }
     6147: 6835:	    if (ret != MB_INCOMPLETE) {
     6147: 6836:		if (ret == MB_INVALID) {
    #####: 6837:		    memset(&mbs, 0, sizeof(mbs));
        -: 6838:		    /* Treat this as a single character */
    #####: 6839:		    wc = (wchar_t)c;
    #####: 6840:		    laststart = bptr;
        -: 6841:		}
        -: 6842:		/*
        -: 6843:		 * \ at the end of a line introduces a continuation line,
        -: 6844:		 * except in raw mode (-r option)
        -: 6845:		 */
     6147: 6846:		if (bslash && wc == delim) {
    #####: 6847:		    bslash = 0;
    #####: 6848:		    continue;
        -: 6849:		}
     6147: 6850:		if (wc == delim && !zbuf)
      300: 6851:		    break;
     5847: 6852:		if (!bslash && bptr == buf && wcsitype(wc, ISEP)) {
    #####: 6853:		    if (c < 128 && iwsep(c))
    #####: 6854:			continue;
    #####: 6855:		    else if (!first) {
    #####: 6856:			first = 1;
    #####: 6857:			continue;
        -: 6858:		    }
        -: 6859:		}
     5847: 6860:		bslash = (wc == L'\\' && !bslash && !OPT_ISSET(ops,'r'));
     5847: 6861:		if (bslash)
    #####: 6862:		    continue;
        -: 6863:	    }
     5847: 6864:	    if (imeta(STOUC(*bptr))) {
    #####: 6865:		bptr[1] = bptr[0] ^ 32;
    #####: 6866:		bptr[0] = Meta;
    #####: 6867:		bptr += 2;
        -: 6868:	    }
        -: 6869:	    else
     5847: 6870:		bptr++;
     5847: 6871:	    if (ret != MB_INCOMPLETE)
     5847: 6872:		laststart = bptr;
        -: 6873:#else
        -: 6874:	    /* \ at the end of a line introduces a continuation line, except in
        -: 6875:	       raw mode (-r option) */
        -: 6876:	    if (bslash && c == delim) {
        -: 6877:		bslash = 0;
        -: 6878:		continue;
        -: 6879:	    }
        -: 6880:	    if (c == EOF || (c == delim && !zbuf))
        -: 6881:		break;
        -: 6882:	    if (!bslash && isep(c) && bptr == buf) {
        -: 6883:		if (iwsep(c))
        -: 6884:		    continue;
        -: 6885:		else if (!first) {
        -: 6886:		    first = 1;
        -: 6887:		    continue;
        -: 6888:		}
        -: 6889:	    }
        -: 6890:	    bslash = c == '\\' && !bslash && !OPT_ISSET(ops,'r');
        -: 6891:	    if (bslash)
        -: 6892:		continue;
        -: 6893:	    if (imeta(c)) {
        -: 6894:		*bptr++ = Meta;
        -: 6895:		*bptr++ = c ^ 32;
        -: 6896:	    } else
        -: 6897:		*bptr++ = c;
        -: 6898:#endif
        -: 6899:	    /* increase the buffer size, if necessary */
     5847: 6900:	    if (bptr >= buf + bsiz - 1) {
        8: 6901:		int blen = bptr - buf;
        -: 6902:#ifdef MULTIBYTE_SUPPORT
        8: 6903:		int llen = laststart - buf;
        -: 6904:#endif
        -: 6905:
        8: 6906:		buf = realloc(buf, bsiz *= 2);
        8: 6907:		bptr = buf + blen;
        -: 6908:#ifdef MULTIBYTE_SUPPORT
        8: 6909:		laststart = buf + llen;
        -: 6910:#endif
        -: 6911:	    }
        -: 6912:	}
      303: 6913:	signal_setmask(s);
        -: 6914:    }
        -: 6915:#ifdef MULTIBYTE_SUPPORT
      303: 6916:    if (ret != MB_INCOMPLETE)
      303: 6917:	bptr = laststart;
        -: 6918:#endif
        -: 6919:    /*
        -: 6920:     * Strip trailing IFS whitespace.
        -: 6921:     * iwsep can only be certain single-byte ASCII bytes, but we
        -: 6922:     * must check the byte isn't metafied.
        -: 6923:     */
      606: 6924:    while (bptr > buf) {
      277: 6925:	if (bptr > buf + 1 && bptr[-2] == Meta) {
        -: 6926:	    /* non-ASCII, can't be IWSEP */
        -: 6927:	    break;
      277: 6928:	} else if (iwsep(bptr[-1]))
    #####: 6929:	    bptr--;
        -: 6930:	else
      277: 6931:	    break;
        -: 6932:    }
      303: 6933:    *bptr = '\0';
      303: 6934:    if (resettty && SHTTY != -1)
    #####: 6935:	settyinfo(&saveti);
        -: 6936:    /* final assignment of reply, etc. */
      303: 6937:    if (OPT_ISSET(ops,'e') || OPT_ISSET(ops,'E')) {
    #####: 6938:	zputs(buf, stdout);
    #####: 6939:	putchar('\n');
        -: 6940:    }
      303: 6941:    if (!OPT_ISSET(ops,'e'))
      303: 6942:	setsparam(reply, buf);
        -: 6943:    else
    #####: 6944:	zsfree(buf);
      303: 6945:    if (zbuforig) {
    #####: 6946:	char first = *zbuforig;
        -: 6947:
    #####: 6948:	zsfree(zbuforig);
    #####: 6949:	if (!first)
    #####: 6950:	    return 1;
      303: 6951:    } else if (c == EOF) {
        3: 6952:	if (readfd == coprocin) {
    #####: 6953:	    close(coprocin);
    #####: 6954:	    close(coprocout);
    #####: 6955:	    coprocin = coprocout = -1;
        -: 6956:	}
        3: 6957:	return 1;
        -: 6958:    }
        -: 6959:    /*
        -: 6960:     * The following is to ensure a failure to set the parameter
        -: 6961:     * causes a non-zero status return.  There are arguments for
        -: 6962:     * turning a non-zero status into errflag more widely.
        -: 6963:     */
      300: 6964:    return errflag;
        -: 6965:}
        -: 6966:
        -: 6967:/**/
        -: 6968:static int
     6150: 6969:zread(int izle, int *readchar, long izle_timeout)
        -: 6970:{
     6150: 6971:    char cc, retry = 0;
        -: 6972:    int ret;
        -: 6973:
     6150: 6974:    if (izle) {
        -: 6975:	int c;
    #####: 6976:	zleentry(ZLE_CMD_GET_KEY, izle_timeout, NULL, &c);
        -: 6977:
    #####: 6978:	return (c < 0 ? EOF : c);
        -: 6979:    }
        -: 6980:    /* use zbuf if possible */
     6150: 6981:    if (zbuf) {
        -: 6982:	/* If zbuf points to anything, it points to the next character in the
        -: 6983:	   buffer.  This may be a null byte to indicate EOF.  If reading from the
        -: 6984:	   buffer, move on the buffer pointer. */
    #####: 6985:	if (*zbuf == Meta)
    #####: 6986:	    return zbuf++, STOUC(*zbuf++ ^ 32);
        -: 6987:	else
    #####: 6988:	    return (*zbuf) ? STOUC(*zbuf++) : EOF;
        -: 6989:    }
     6150: 6990:    if (*readchar >= 0) {
    #####: 6991:	cc = *readchar;
    #####: 6992:	*readchar = -1;
    #####: 6993:	return STOUC(cc);
        -: 6994:    }
        -: 6995:    for (;;) {
        -: 6996:	/* read a character from readfd */
     6150: 6997:	ret = read(readfd, &cc, 1);
     6150: 6998:	switch (ret) {
     6147: 6999:	case 1:
        -: 7000:	    /* return the character read */
     6147: 7001:	    return STOUC(cc);
    #####: 7002:	case -1:
        -: 7003:#if defined(EAGAIN) || defined(EWOULDBLOCK)
    #####: 7004:	    if (!retry && readfd == 0 && (
        -: 7005:# ifdef EAGAIN
    #####: 7006:		errno == EAGAIN
        -: 7007:#  ifdef EWOULDBLOCK
    #####: 7008:		||
        -: 7009:#  endif /* EWOULDBLOCK */
        -: 7010:# endif /* EAGAIN */
        -: 7011:# ifdef EWOULDBLOCK
    #####: 7012:		errno == EWOULDBLOCK
        -: 7013:# endif /* EWOULDBLOCK */
    #####: 7014:		) && setblock_stdin()) {
    #####: 7015:		retry = 1;
    #####: 7016:		continue;
        -: 7017:	    } else
        -: 7018:#endif /* EAGAIN || EWOULDBLOCK */
    #####: 7019:		if (errno == EINTR && !(errflag || retflag || breaks || contflag))
    #####: 7020:		    continue;
    #####: 7021:	    break;
        -: 7022:	}
        3: 7023:	return EOF;
        -: 7024:    }
        -: 7025:}
        -: 7026:
        -: 7027:/* holds arguments for testlex() */
        -: 7028:/**/
        -: 7029:char **testargs, **curtestarg;
        -: 7030:
        -: 7031:/* test, [: the old-style general purpose logical expression builtin */
        -: 7032:
        -: 7033:/**/
        -: 7034:void
    #####: 7035:testlex(void)
        -: 7036:{
    #####: 7037:    if (tok == LEXERR)
    #####: 7038:	return;
        -: 7039:
    #####: 7040:    tokstr = *(curtestarg = testargs);
    #####: 7041:    if (!*testargs) {
        -: 7042:	/* if tok is already zero, reading past the end:  error */
    #####: 7043:	tok = tok ? NULLTOK : LEXERR;
    #####: 7044:	return;
    #####: 7045:    } else if (!strcmp(*testargs, "-o"))
    #####: 7046:	tok = DBAR;
    #####: 7047:    else if (!strcmp(*testargs, "-a"))
    #####: 7048:	tok = DAMPER;
    #####: 7049:    else if (!strcmp(*testargs, "!"))
    #####: 7050:	tok = BANG;
    #####: 7051:    else if (!strcmp(*testargs, "("))
    #####: 7052:	tok = INPAR;
    #####: 7053:    else if (!strcmp(*testargs, ")"))
    #####: 7054:	tok = OUTPAR;
        -: 7055:    else
    #####: 7056:	tok = STRING;
    #####: 7057:    testargs++;
        -: 7058:}
        -: 7059:
        -: 7060:/**/
        -: 7061:int
    #####: 7062:bin_test(char *name, char **argv, UNUSED(Options ops), int func)
        -: 7063:{
        -: 7064:    char **s;
        -: 7065:    Eprog prog;
        -: 7066:    struct estate state;
    #####: 7067:    int nargs, sense = 0, ret;
        -: 7068:
        -: 7069:    /* if "test" was invoked as "[", it needs a matching "]" *
        -: 7070:     * which is subsequently ignored                         */
    #####: 7071:    if (func == BIN_BRACKET) {
    #####: 7072:	for (s = argv; *s; s++);
    #####: 7073:	if (s == argv || strcmp(s[-1], "]")) {
    #####: 7074:	    zwarnnam(name, "']' expected");
    #####: 7075:	    return 2;
        -: 7076:	}
    #####: 7077:	s[-1] = NULL;
        -: 7078:    }
        -: 7079:    /* an empty argument list evaluates to false (1) */
    #####: 7080:    if (!*argv)
    #####: 7081:	return 1;
        -: 7082:
        -: 7083:    /*
        -: 7084:     * Implement some XSI extensions to POSIX here.
        -: 7085:     * See
        -: 7086:     * http://pubs.opengroup.org/onlinepubs/9699919799/utilities/test.html
        -: 7087:     */
    #####: 7088:    nargs = arrlen(argv);
    #####: 7089:    if (nargs == 3 || nargs == 4)
        -: 7090:    {
        -: 7091:	/*
        -: 7092:	 * As parentheses are an extension, we need to be careful ---
        -: 7093:	 * if this is a three-argument expression that could
        -: 7094:	 * be a binary operator, prefer that.
        -: 7095:	 */
    #####: 7096:	if (!strcmp(argv[0], "(") && !strcmp(argv[nargs-1],")") &&
    #####: 7097:	    (nargs != 3 || !is_cond_binary_op(argv[1]))) {
    #####: 7098:	    argv[nargs-1] = NULL;
    #####: 7099:	    argv++;
        -: 7100:	}
    #####: 7101:	if (nargs == 4 && !strcmp("!", argv[0])) {
    #####: 7102:	    sense = 1;
    #####: 7103:	    argv++;
        -: 7104:	}
        -: 7105:    }
        -: 7106:
    #####: 7107:    zcontext_save();
    #####: 7108:    testargs = argv;
    #####: 7109:    tok = NULLTOK;
    #####: 7110:    condlex = testlex;
    #####: 7111:    testlex();
    #####: 7112:    prog = parse_cond();
    #####: 7113:    condlex = zshlex;
        -: 7114:
    #####: 7115:    if (errflag) {
    #####: 7116:	errflag &= ~ERRFLAG_ERROR;
    #####: 7117:	zcontext_restore();
    #####: 7118:	return 2;
        -: 7119:    }
        -: 7120:
    #####: 7121:    if (!prog || tok == LEXERR) {
    #####: 7122:	zwarnnam(name, tokstr ? "parse error" : "argument expected");
    #####: 7123:	zcontext_restore();
    #####: 7124:	return 2;
        -: 7125:    }
    #####: 7126:    zcontext_restore();
        -: 7127:
    #####: 7128:    if (*curtestarg) {
    #####: 7129:	zwarnnam(name, "too many arguments");
    #####: 7130:	return 2;
        -: 7131:    }
        -: 7132:
        -: 7133:    /* syntax is OK, so evaluate */
        -: 7134:
    #####: 7135:    state.prog = prog;
    #####: 7136:    state.pc = prog->prog;
    #####: 7137:    state.strs = prog->strs;
        -: 7138:
    #####: 7139:    ret = evalcond(&state, name);
    #####: 7140:    if (ret < 2 && sense)
    #####: 7141:	ret = ! ret;
        -: 7142:
    #####: 7143:    return ret;
        -: 7144:}
        -: 7145:
        -: 7146:/* display a time, provided in units of 1/60s, as minutes and seconds */
        -: 7147:#define pttime(X) printf("%ldm%ld.%02lds",((long) (X))/(60 * clktck),\
        -: 7148:			 ((long) (X))/clktck%clktck,\
        -: 7149:			 ((long) (X))*100/clktck%100)
        -: 7150:
        -: 7151:/* times: display, in a two-line format, the times provided by times(3) */
        -: 7152:
        -: 7153:/**/
        -: 7154:int
    #####: 7155:bin_times(UNUSED(char *name), UNUSED(char **argv), UNUSED(Options ops), UNUSED(int func))
        -: 7156:{
        -: 7157:    struct tms buf;
    #####: 7158:    long clktck = get_clktck();
        -: 7159:
        -: 7160:    /* get time accounting information */
    #####: 7161:    if (times(&buf) == -1)
    #####: 7162:	return 1;
    #####: 7163:    pttime(buf.tms_utime);	/* user time */
    #####: 7164:    putchar(' ');
    #####: 7165:    pttime(buf.tms_stime);	/* system time */
    #####: 7166:    putchar('\n');
    #####: 7167:    pttime(buf.tms_cutime);	/* user time, children */
    #####: 7168:    putchar(' ');
    #####: 7169:    pttime(buf.tms_cstime);	/* system time, children */
    #####: 7170:    putchar('\n');
    #####: 7171:    return 0;
        -: 7172:}
        -: 7173:
        -: 7174:/* trap: set/unset signal traps */
        -: 7175:
        -: 7176:/**/
        -: 7177:int
    #####: 7178:bin_trap(char *name, char **argv, UNUSED(Options ops), UNUSED(int func))
        -: 7179:{
        -: 7180:    Eprog prog;
        -: 7181:    char *arg, *s;
        -: 7182:    int sig;
        -: 7183:
    #####: 7184:    if (*argv && !strcmp(*argv, "--"))
    #####: 7185:	argv++;
        -: 7186:
        -: 7187:    /* If given no arguments, list all currently-set traps */
    #####: 7188:    if (!*argv) {
    #####: 7189:	queue_signals();
    #####: 7190:	for (sig = 0; sig < VSIGCOUNT; sig++) {
    #####: 7191:	    if (sigtrapped[sig] & ZSIG_FUNC) {
        -: 7192:		HashNode hn;
        -: 7193:
    #####: 7194:		if ((hn = gettrapnode(sig, 0)))
    #####: 7195:		    shfunctab->printnode(hn, 0);
        -: 7196:		DPUTS(!hn, "BUG: I did not find any trap functions!");
    #####: 7197:	    } else if (sigtrapped[sig]) {
    #####: 7198:		const char *name = getsigname(sig);
    #####: 7199:		if (!siglists[sig])
    #####: 7200:		    printf("trap -- '' %s\n", name);
        -: 7201:		else {
    #####: 7202:		    s = getpermtext(siglists[sig], NULL, 0);
    #####: 7203:		    printf("trap -- ");
    #####: 7204:		    quotedzputs(s, stdout);
    #####: 7205:		    printf(" %s\n", name);
    #####: 7206:		    zsfree(s);
        -: 7207:		}
        -: 7208:	    }
        -: 7209:	}
    #####: 7210:	unqueue_signals();
    #####: 7211:	return 0;
        -: 7212:    }
        -: 7213:
        -: 7214:    /* If we have a signal number, unset the specified *
        -: 7215:     * signals.  With only -, remove all traps.        */
    #####: 7216:    if ((getsignum(*argv) != -1) || (!strcmp(*argv, "-") && argv++)) {
    #####: 7217:	if (!*argv) {
    #####: 7218:	    for (sig = 0; sig < VSIGCOUNT; sig++)
    #####: 7219:		unsettrap(sig);
        -: 7220:	} else {
    #####: 7221:	    for (; *argv; argv++) {
    #####: 7222:		sig = getsignum(*argv);
    #####: 7223:		if (sig == -1) {
    #####: 7224:		    zwarnnam(name, "undefined signal: %s", *argv);
    #####: 7225:		    break;
        -: 7226:		}
    #####: 7227:		unsettrap(sig);
        -: 7228:	    }
        -: 7229:	}
    #####: 7230:	return *argv != NULL;
        -: 7231:    }
        -: 7232:
        -: 7233:    /* Sort out the command to execute on trap */
    #####: 7234:    arg = *argv++;
    #####: 7235:    if (!*arg)
    #####: 7236:	prog = &dummy_eprog;
    #####: 7237:    else if (!(prog = parse_string(arg, 1))) {
    #####: 7238:	zwarnnam(name, "couldn't parse trap command");
    #####: 7239:	return 1;
        -: 7240:    }
        -: 7241:
        -: 7242:    /* set traps */
    #####: 7243:    for (; *argv; argv++) {
        -: 7244:	Eprog t;
        -: 7245:	int flags;
        -: 7246:
    #####: 7247:	sig = getsignum(*argv);
    #####: 7248:	if (sig == -1) {
    #####: 7249:	    zwarnnam(name, "undefined signal: %s", *argv);
    #####: 7250:	    break;
        -: 7251:	}
    #####: 7252:	if (idigit(**argv) ||
    #####: 7253:	    !strcmp(sigs[sig], *argv) ||
    #####: 7254:	    (!strncmp("SIG", *argv, 3) && !strcmp(sigs[sig], *argv+3))) {
        -: 7255:	    /* The signal was specified by number or by canonical name (with
        -: 7256:	     * or without SIG prefix).
        -: 7257:	     */
    #####: 7258:	    flags = 0;
        -: 7259:	}
        -: 7260:	else {
        -: 7261:	    /*
        -: 7262:	     * Record that the signal is used under an assumed name.
        -: 7263:	     * If we ever have more than one alias per signal this
        -: 7264:	     * will need improving.
        -: 7265:	     */
    #####: 7266:	    flags = ZSIG_ALIAS;
        -: 7267:	}
    #####: 7268:	t = dupeprog(prog, 0);
    #####: 7269:	if (settrap(sig, t, flags))
    #####: 7270:	    freeeprog(t);
        -: 7271:    }
    #####: 7272:    return *argv != NULL;
        -: 7273:}
        -: 7274:
        -: 7275:/**/
        -: 7276:int
    #####: 7277:bin_ttyctl(UNUSED(char *name), UNUSED(char **argv), Options ops, UNUSED(int func))
        -: 7278:{
    #####: 7279:    if (OPT_ISSET(ops,'f'))
    #####: 7280:	ttyfrozen = 1;
    #####: 7281:    else if (OPT_ISSET(ops,'u'))
    #####: 7282:	ttyfrozen = 0;
        -: 7283:    else
    #####: 7284:	printf("tty is %sfrozen\n", ttyfrozen ? "" : "not ");
    #####: 7285:    return 0;
        -: 7286:}
        -: 7287:
        -: 7288:/* let -- mathematical evaluation */
        -: 7289:
        -: 7290:/**/
        -: 7291:int
    #####: 7292:bin_let(UNUSED(char *name), char **argv, UNUSED(Options ops), UNUSED(int func))
        -: 7293:{
    #####: 7294:    mnumber val = zero_mnumber;
        -: 7295:
    #####: 7296:    while (*argv)
    #####: 7297:	val = matheval(*argv++);
        -: 7298:    /* Errors in math evaluation in let are non-fatal. */
    #####: 7299:    errflag &= ~ERRFLAG_ERROR;
        -: 7300:    /* should test for fabs(val.u.d) < epsilon? */
    #####: 7301:    return (val.type == MN_INTEGER) ? val.u.l == 0 : val.u.d == 0.0;
        -: 7302:}
        -: 7303:
        -: 7304:/* umask command.  umask may be specified as octal digits, or in the  *
        -: 7305: * symbolic form that chmod(1) uses.  Well, a subset of it.  Remember *
        -: 7306: * that only the bottom nine bits of umask are used, so there's no    *
        -: 7307: * point allowing the set{u,g}id and sticky bits to be specified.     */
        -: 7308:
        -: 7309:/**/
        -: 7310:int
    #####: 7311:bin_umask(char *nam, char **args, Options ops, UNUSED(int func))
        -: 7312:{
        -: 7313:    mode_t um;
    #####: 7314:    char *s = *args;
        -: 7315:
        -: 7316:    /* Get the current umask. */
    #####: 7317:    queue_signals();
    #####: 7318:    um = umask(0777);
    #####: 7319:    umask(um);
    #####: 7320:    unqueue_signals();
        -: 7321:
        -: 7322:    /* No arguments means to display the current setting. */
    #####: 7323:    if (!s) {
    #####: 7324:	if (OPT_ISSET(ops,'S')) {
    #####: 7325:	    char *who = "ugo";
        -: 7326:
    #####: 7327:	    while (*who) {
    #####: 7328:		char *what = "rwx";
    #####: 7329:		printf("%c=", *who++);
    #####: 7330:		while (*what) {
    #####: 7331:		    if (!(um & 0400))
    #####: 7332:			putchar(*what);
    #####: 7333:		    um <<= 1;
    #####: 7334:		    what++;
        -: 7335:		}
    #####: 7336:		putchar(*who ? ',' : '\n');
        -: 7337:	    }
        -: 7338:	} else {
    #####: 7339:	    if (um & 0700)
    #####: 7340:		putchar('0');
    #####: 7341:	    printf("%03o\n", (unsigned)um);
        -: 7342:	}
    #####: 7343:	return 0;
        -: 7344:    }
        -: 7345:
    #####: 7346:    if (idigit(*s)) {
        -: 7347:	/* Simple digital umask. */
    #####: 7348:	um = zstrtol(s, &s, 8);
    #####: 7349:	if (*s) {
    #####: 7350:	    zwarnnam(nam, "bad umask");
    #####: 7351:	    return 1;
        -: 7352:	}
        -: 7353:    } else {
        -: 7354:	/* Symbolic notation -- slightly complicated. */
        -: 7355:	int whomask, umaskop, mask;
        -: 7356:
        -: 7357:	/* More than one symbolic argument may be used at once, each separated
        -: 7358:	   by commas. */
        -: 7359:	for (;;) {
        -: 7360:	    /* First part of the argument -- who does this apply to?
        -: 7361:	       u=owner, g=group, o=other. */
    #####: 7362:	    whomask = 0;
    #####: 7363:	    while (*s == 'u' || *s == 'g' || *s == 'o' || *s == 'a')
    #####: 7364:		if (*s == 'u')
    #####: 7365:		    s++, whomask |= 0700;
    #####: 7366:		else if (*s == 'g')
    #####: 7367:		    s++, whomask |= 0070;
    #####: 7368:		else if (*s == 'o')
    #####: 7369:		    s++, whomask |= 0007;
    #####: 7370:		else if (*s == 'a')
    #####: 7371:		    s++, whomask |= 0777;
        -: 7372:	    /* Default whomask is everyone. */
    #####: 7373:	    if (!whomask)
    #####: 7374:		whomask = 0777;
        -: 7375:	    /* Operation may be +, - or =. */
    #####: 7376:	    umaskop = (int)*s;
    #####: 7377:	    if (!(umaskop == '+' || umaskop == '-' || umaskop == '=')) {
    #####: 7378:		if (umaskop)
    #####: 7379:		    zwarnnam(nam, "bad symbolic mode operator: %c", umaskop);
        -: 7380:		else
    #####: 7381:		    zwarnnam(nam, "bad umask");
    #####: 7382:		return 1;
        -: 7383:	    }
        -: 7384:	    /* Permissions mask -- r=read, w=write, x=execute. */
    #####: 7385:	    mask = 0;
    #####: 7386:	    while (*++s && *s != ',')
    #####: 7387:		if (*s == 'r')
    #####: 7388:		    mask |= 0444 & whomask;
    #####: 7389:		else if (*s == 'w')
    #####: 7390:		    mask |= 0222 & whomask;
    #####: 7391:		else if (*s == 'x')
    #####: 7392:		    mask |= 0111 & whomask;
        -: 7393:		else {
    #####: 7394:		    zwarnnam(nam, "bad symbolic mode permission: %c", *s);
    #####: 7395:		    return 1;
        -: 7396:		}
        -: 7397:	    /* Apply parsed argument to um. */
    #####: 7398:	    if (umaskop == '+')
    #####: 7399:		um &= ~mask;
    #####: 7400:	    else if (umaskop == '-')
    #####: 7401:		um |= mask;
        -: 7402:	    else		/* umaskop == '=' */
    #####: 7403:		um = (um | (whomask)) & ~mask;
    #####: 7404:	    if (*s == ',')
    #####: 7405:		s++;
        -: 7406:	    else
    #####: 7407:		break;
        -: 7408:	}
    #####: 7409:	if (*s) {
    #####: 7410:	    zwarnnam(nam, "bad character in symbolic mode: %c", *s);
    #####: 7411:	    return 1;
        -: 7412:	}
        -: 7413:    }
        -: 7414:
        -: 7415:    /* Finally, set the new umask. */
    #####: 7416:    umask(um);
    #####: 7417:    return 0;
        -: 7418:}
        -: 7419:
        -: 7420:/* Generic builtin for facilities not available on this OS */
        -: 7421:
        -: 7422:/**/
        -: 7423:mod_export int
    #####: 7424:bin_notavail(char *nam, UNUSED(char **argv), UNUSED(Options ops), UNUSED(int func))
        -: 7425:{
    #####: 7426:    zwarnnam(nam, "not available on this system");
    #####: 7427:    return 1;
        -: 7428:}
