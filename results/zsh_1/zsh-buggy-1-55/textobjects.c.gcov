        -:    0:Source:textobjects.c
        -:    0:Graph:/home/workspace/Src/Zle/textobjects.gcno
        -:    0:Data:/home/workspace/Src/Zle/textobjects.gcda
        -:    0:Runs:3
        -:    0:Programs:1
        -:    1:/*
        -:    2: * textobjects.c - ZLE widgets implementing Vim style text objects
        -:    3: *
        -:    4: * This file is part of zsh, the Z shell.
        -:    5: *
        -:    6: * Copyright (c) 2014 Oliver Kiddle
        -:    7: * All rights reserved.
        -:    8: *
        -:    9: * Permission is hereby granted, without written agreement and without
        -:   10: * license or royalty fees, to use, copy, modify, and distribute this
        -:   11: * software and to distribute modified versions of this software for any
        -:   12: * purpose, provided that the above copyright notice and the following
        -:   13: * two paragraphs appear in all copies of this software.
        -:   14: *
        -:   15: * In no event shall Oliver Kiddle or the Zsh Development Group be liable
        -:   16: * to any party for direct, indirect, special, incidental, or consequential
        -:   17: * damages arising out of the use of this software and its documentation,
        -:   18: * even if Oliver Kiddle and the Zsh Development Group have been advised of
        -:   19: * the possibility of such damage.
        -:   20: *
        -:   21: * Oliver Kiddle and the Zsh Development Group specifically disclaim any
        -:   22: * warranties, including, but not limited to, the implied warranties of
        -:   23: * merchantability and fitness for a particular purpose.  The software
        -:   24: * provided hereunder is on an "as is" basis, and Oliver Kiddle and the
        -:   25: * Zsh Development Group have no obligation to provide maintenance,
        -:   26: * support, updates, enhancements, or modifications.
        -:   27: *
        -:   28: */
        -:   29:
        -:   30:#include "zle.mdh"
        -:   31:#include "textobjects.pro"
        -:   32:
        -:   33:static int
    #####:   34:blankwordclass(ZLE_CHAR_T x)
        -:   35:{
    #####:   36:    return (ZC_iblank(x) ? 0 : 1);
        -:   37:}
        -:   38:
        -:   39:/**/
        -:   40:int
       40:   41:selectword(UNUSED(char **args))
        -:   42:{
       40:   43:    int n = zmult;
       80:   44:    int all = IS_THINGY(bindk, selectaword) ||
       24:   45:	IS_THINGY(bindk, selectablankword);
      104:   46:    int (*viclass)(ZLE_CHAR_T) = (IS_THINGY(bindk, selectaword) ||
       52:   47:	    IS_THINGY(bindk, selectinword)) ? wordclass : blankwordclass;
       40:   48:    int sclass = viclass(zleline[zlecs]);
       40:   49:    int doblanks = all && sclass;
        -:   50:
       40:   51:    if (!region_active || zlecs == mark || mark == -1) {
        -:   52:	/* search back to first character of same class as the start position
        -:   53:	 * also stop at the beginning of the line */
       17:   54:	mark = zlecs;
       51:   55:	while (mark) {
       33:   56:	    int pos = mark;
       33:   57:	    DECPOS(pos);
       33:   58:	    if (zleline[pos] == ZWC('\n') || viclass(zleline[pos]) != sclass)
        -:   59:		break;
       17:   60:	    mark = pos;
        -:   61:	}
        -:   62:	/* similarly scan forward over characters of the same class */
       67:   63:	while (zlecs < zlell) {
       50:   64:	    INCCS();
       50:   65:	    int pos = zlecs;
        -:   66:	    /* single newlines within blanks are included */
       50:   67:	    if (all && !sclass && pos < zlell && zleline[pos] == ZWC('\n'))
    #####:   68:		INCPOS(pos);
        -:   69:
       50:   70:	    if (zleline[pos] == ZWC('\n') || viclass(zleline[pos]) != sclass)
        -:   71:		break;
        -:   72:	}
        -:   73:
       34:   74:	if (all) {
       17:   75:	    int nclass = viclass(zleline[zlecs]);
        -:   76:	    /* if either start or new position is blank advance over
        -:   77:	     * a new block of characters of a common type */
       17:   78:	    if (!nclass || !sclass) {
       53:   79:		while (zlecs < zlell) {
       42:   80:		    INCCS();
       84:   81:		    if (zleline[zlecs] == ZWC('\n') ||
       42:   82:			    viclass(zleline[zlecs]) != nclass)
        -:   83:			break;
        -:   84:		}
       11:   85:		if (n < 2)
       10:   86:		    doblanks = 0;
        -:   87:	    }
        -:   88:	}
        -:   89:    } else {
        -:   90:	/* For visual mode, advance one char so repeated
        -:   91:	 * invocations select subsequent words */
       23:   92:	if (zlecs > mark) {
        9:   93:	    if (zlecs < zlell)
        9:   94:		INCCS();
       14:   95:	} else if (zlecs)
       14:   96:	    DECCS();
       23:   97:	if (zlecs < mark) {
        -:   98:	    /* visual mode with the cursor before the mark: move cursor back */
       42:   99:	    while (n-- > 0) {
       14:  100:		int pos = zlecs;
        -:  101:		/* first over blanks */
       24:  102:		if (all && (!viclass(zleline[pos]) ||
        7:  103:			zleline[pos] == ZWC('\n'))) {
        3:  104:		    all = 0;
       10:  105:		    while (pos) {
        7:  106:			DECPOS(pos);
        7:  107:			if (zleline[pos] == ZWC('\n'))
        1:  108:			    break;
        6:  109:			zlecs = pos;
        6:  110:			if (viclass(zleline[pos]))
        2:  111:			    break;
        -:  112:		    }
       11:  113:		} else if (zlecs && zleline[zlecs] == ZWC('\n')) {
        -:  114:		    /* for in widgets pass over one newline */
        2:  115:		    DECPOS(pos);
        2:  116:		    if (zleline[pos] != ZWC('\n'))
        1:  117:			zlecs = pos;
        -:  118:		}
       14:  119:		pos = zlecs;
       14:  120:		sclass = viclass(zleline[zlecs]);
        -:  121:		/* now retreat over non-blanks */
      102:  122:		while (zleline[pos] != ZWC('\n') &&
       42:  123:			viclass(zleline[pos]) == sclass) {
       34:  124:		    zlecs = pos;
       34:  125:		    if (!pos) {
        2:  126:			zlecs = 0;
        2:  127:			break;
        -:  128:		    }
       32:  129:		    DECPOS(pos);
        -:  130:		}
        -:  131:		/* blanks again but only if there were none first time */
       14:  132:		if (all && zlecs) {
        3:  133:		    pos = zlecs;
        3:  134:		    DECPOS(pos);
        3:  135:		    if (!viclass(zleline[pos])) {
       10:  136:			while (pos) {
        8:  137:			    DECPOS(pos);
       16:  138:			    if (zleline[pos] == ZWC('\n') ||
        8:  139:				    viclass(zleline[pos]))
        -:  140:				break;
        6:  141:			    zlecs = pos;
        -:  142:			}
        -:  143:		    }
        -:  144:		}
        -:  145:	    }
       14:  146:	    return 0;
        -:  147:	}
        9:  148:	n++;
        9:  149:	doblanks = 0;
        -:  150:    }
       26:  151:    region_active = !!region_active; /* force to character wise */
        -:  152:
        -:  153:    /* for each digit argument, advance over further block of one class */
       62:  154:    while (--n > 0) {
       10:  155:	if (zlecs < zlell && zleline[zlecs] == ZWC('\n'))
        1:  156:	    INCCS();
       10:  157:	sclass = viclass(zleline[zlecs]);
       37:  158:	while (zlecs < zlell) {
       27:  159:	    INCCS();
       54:  160:	    if (zleline[zlecs] == ZWC('\n') ||
       27:  161:		    viclass(zleline[zlecs]) != sclass)
        -:  162:		break;
        -:  163:	}
        -:  164:	/* for 'a' widgets, advance extra block if either consists of blanks */
       10:  165:	if (all) {
        5:  166:	    if (zlecs < zlell && zleline[zlecs] == ZWC('\n'))
    #####:  167:		INCCS();
        5:  168:	    if (!sclass || !viclass(zleline[zlecs]) ) {
        2:  169:		sclass = viclass(zleline[zlecs]);
        2:  170:		if (n == 1 && !sclass)
        2:  171:		    doblanks = 0;
       10:  172:		while (zlecs < zlell) {
        8:  173:		    INCCS();
       16:  174:		    if (zleline[zlecs] == ZWC('\n') ||
        8:  175:			    viclass(zleline[zlecs]) != sclass)
        -:  176:			break;
        -:  177:		}
        -:  178:	    }
        -:  179:	}
        -:  180:    }
        -:  181:
        -:  182:    /* if we didn't remove blanks at either end we remove some at the start */
       26:  183:    if (doblanks) {
        7:  184:	int pos = mark;
       31:  185:	while (pos) {
       22:  186:	    DECPOS(pos);
        -:  187:	    /* don't remove blanks at the start of the line, i.e indentation */
       22:  188:	    if (zleline[pos] == ZWC('\n'))
    #####:  189:		break;
       22:  190:	    if (!ZC_iblank(zleline[pos])) {
        5:  191:		INCPOS(pos);
        5:  192:		mark = pos;
        5:  193:		break;
        -:  194:	    }
        -:  195:	}
        -:  196:    }
        -:  197:    /* Adjustment: vi operators don't include the cursor position, in insert
        -:  198:     * or emacs mode the region also doesn't but for vi visual mode it is
        -:  199:     * included. */
       26:  200:    if (!virangeflag) {
        9:  201:	if (!invicmdmode())
    #####:  202:	    region_active = 1;
        9:  203:	else if (zlecs && zlecs > mark)
        9:  204:	    DECCS();
        -:  205:    }
        -:  206:
       26:  207:    return 0;
        -:  208:}
        -:  209:
        -:  210:/**/
        -:  211:int
       12:  212:selectargument(UNUSED(char **args))
        -:  213:{
       12:  214:    int ne = noerrs, ocs = zlemetacs;
       12:  215:    int owb = wb, owe= we, oadx = addedx, ona = noaliases;
        -:  216:    char *p;
        -:  217:    int ll, cs;
        -:  218:    char *linein;
       12:  219:    int wend = 0, wcur = 0;
       12:  220:    int n = zmult;
        -:  221:    int *wstarts;
        -:  222:    int tmpsz;
        -:  223:
       12:  224:    if (n < 1 || 2*n > zlell + 1)
    #####:  225:	return 1;
        -:  226:
        -:  227:    /* if used from emacs mode enable the region */
       12:  228:    if (!invicmdmode()) {
    #####:  229:	region_active = 1;
    #####:  230:	mark = zlecs;
        -:  231:    }
        -:  232:
       12:  233:    wstarts = (int *) zhalloc(n * sizeof(int));
       12:  234:    memset(wstarts, 0, n * sizeof(int));
        -:  235:
       12:  236:    addedx = 0;
       12:  237:    noerrs = 1;
       12:  238:    zcontext_save();
       12:  239:    lexflags = LEXFLAGS_ACTIVE;
       12:  240:    linein = zlegetline(&ll, &cs);
       12:  241:    zlemetall = ll;
       12:  242:    zlemetacs = cs;
        -:  243:
       12:  244:    if (!isfirstln && chline) {
    #####:  245:       p = (char *) zhalloc(hptr - chline + zlemetall + 2);
    #####:  246:       memcpy(p, chline, hptr - chline);
    #####:  247:       memcpy(p + (hptr - chline), linein, ll);
    #####:  248:       p[(hptr - chline) + ll] = '\0';
    #####:  249:       inpush(p, 0, NULL);
    #####:  250:       zlemetacs += hptr - chline;
        -:  251:    } else {
       12:  252:       p = (char *) zhalloc(ll + 1);
       12:  253:       memcpy(p, linein, ll);
       12:  254:       p[ll] = '\0';
       12:  255:       inpush(p, 0, NULL);
        -:  256:    }
       12:  257:    if (zlemetacs)
       11:  258:       zlemetacs--;
       12:  259:    strinbeg(0);
       12:  260:    noaliases = 1;
        -:  261:    do {
       47:  262:       wstarts[wcur++] = wend;
       47:  263:       wcur %= n;
       47:  264:       ctxtlex();
       47:  265:       if (tok == ENDINPUT || tok == LEXERR)
        -:  266:           break;
       47:  267:       wend = zlemetall - inbufct;
       47:  268:    } while (tok != ENDINPUT && tok != LEXERR && wend <= zlemetacs);
       12:  269:    noaliases = ona;
       12:  270:    strinend();
       12:  271:    inpop();
       12:  272:    errflag &= ~ERRFLAG_ERROR;
       12:  273:    noerrs = ne;
       12:  274:    zcontext_restore();
       12:  275:    zlemetacs = ocs;
       12:  276:    wb = owb;
       12:  277:    we = owe;
       12:  278:    addedx = oadx;
        -:  279:
        -:  280:    /* convert offsets for mark and zlecs back to ZLE internal format */
       12:  281:    linein[wend] = '\0'; /* a bit of a hack to get two offsets */
       12:  282:    free(stringaszleline(linein, wstarts[wcur], &zlecs, &tmpsz, &mark));
       12:  283:    free(linein);
        -:  284:
       12:  285:    if (IS_THINGY(bindk, selectinshellword)) {
        6:  286:	ZLE_CHAR_T *match = ZWS("`\'\"");
        6:  287:	ZLE_CHAR_T *lmatch = ZWS("\'({"), *rmatch = ZWS("\')}");
        6:  288:	ZLE_CHAR_T *ematch = match, *found;
        6:  289:	int start, end = zlecs;
        -:  290:	/* for 'in' widget, don't include initial blanks ... */
       18:  291:	while (mark < zlecs && ZC_iblank(zleline[mark]))
        6:  292:	    INCPOS(mark);
        -:  293:	/* ... or a matching pair of quotes */
        6:  294:	start = mark;
        6:  295:	if (zleline[start] == ZWC('$')) {
        3:  296:	    match = lmatch;
        3:  297:	    ematch = rmatch;
        3:  298:	    INCPOS(start);
        -:  299:	}
        6:  300:	found = ZS_strchr(match, zleline[start]);
        6:  301:	if (found) {
        5:  302:	    DECPOS(end);
        5:  303:	    if (zleline[end] == ematch[found-match]) {
        5:  304:		zlecs = end;
        5:  305:		INCPOS(start);
        5:  306:		mark = start;
        -:  307:	    }
        -:  308:	}
        -:  309:    }
        -:  310:
        -:  311:    /* Adjustment: vi operators don't include the cursor position */
       12:  312:    if (!virangeflag && invicmdmode())
        6:  313:       DECCS();
        -:  314:
       12:  315:    return 0;
        -:  316:}
