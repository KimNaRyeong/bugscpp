        -:    0:Source:zle_refresh.c
        -:    0:Graph:/home/workspace/Src/Zle/zle_refresh.gcno
        -:    0:Data:/home/workspace/Src/Zle/zle_refresh.gcda
        -:    0:Runs:3
        -:    0:Programs:1
        -:    1:/*
        -:    2: * zle_refresh.c - screen update
        -:    3: *
        -:    4: * This file is part of zsh, the Z shell.
        -:    5: *
        -:    6: * Copyright (c) 1992-1997 Paul Falstad
        -:    7: * All rights reserved.
        -:    8: *
        -:    9: * Permission is hereby granted, without written agreement and without
        -:   10: * license or royalty fees, to use, copy, modify, and distribute this
        -:   11: * software and to distribute modified versions of this software for any
        -:   12: * purpose, provided that the above copyright notice and the following
        -:   13: * two paragraphs appear in all copies of this software.
        -:   14: *
        -:   15: * In no event shall Paul Falstad or the Zsh Development Group be liable
        -:   16: * to any party for direct, indirect, special, incidental, or consequential
        -:   17: * damages arising out of the use of this software and its documentation,
        -:   18: * even if Paul Falstad and the Zsh Development Group have been advised of
        -:   19: * the possibility of such damage.
        -:   20: *
        -:   21: * Paul Falstad and the Zsh Development Group specifically disclaim any
        -:   22: * warranties, including, but not limited to, the implied warranties of
        -:   23: * merchantability and fitness for a particular purpose.  The software
        -:   24: * provided hereunder is on an "as is" basis, and Paul Falstad and the
        -:   25: * Zsh Development Group have no obligation to provide maintenance,
        -:   26: * support, updates, enhancements, or modifications.
        -:   27: *
        -:   28: */
        -:   29:
        -:   30:#include "zle.mdh"
        -:   31:
        -:   32:#ifdef MULTIBYTE_SUPPORT
        -:   33:/*
        -:   34: * Handling for glyphs that contain more than one wide character,
        -:   35: * if ZLE_COMBINING_CHARS is set.  Each glyph is one character with
        -:   36: * non-zero width followed by an arbitrary (but typically small)
        -:   37: * number of characters that have zero width (combining characters).
        -:   38: *
        -:   39: * The allocated size for each array is given by ?mw_size; nmw_ind
        -:   40: * is the next free element, i.e. nmwbuf[nmw_ind] will be the next
        -:   41: * element to be written (we never insert into omwbuf).  We initialise
        -:   42: * nmw_ind to 1 to avoid the index stored in the character looking like a
        -:   43: * NULL.  This wastees a word but it's safer than messing with pointers.
        -:   44: *
        -:   45: * The layout of the buffer is as a string of entries that consist of multiple
        -:   46: * elements of the allocated array with no boundary (the code keeps track of
        -:   47: * where each entry starts).  Note distinction between (logical) entries and
        -:   48: * (array) elements.  Each entry consists of an element giving the total
        -:   49: * number of wide characters for the entry (there are N+1 wide characters,
        -:   50: * where N >= 1 is the number of trailing zero width characters), followed by
        -:   51: * those characters.
        -:   52: */
        -:   53:static REFRESH_CHAR
        -:   54:    *omwbuf = NULL,		/* old multiword glyph buffer */
        -:   55:    *nmwbuf = NULL;		/* new multiword glyph buffer */
        -:   56:#endif
        -:   57:
        -:   58:/*
        -:   59: * Compare if two characters are equal.
        -:   60: */
        -:   61:#ifdef MULTIBYTE_SUPPORT
        -:   62:/*
        -:   63: * We may need to compare values in multiword arrays.  As the arrays are
        -:   64: * different for the old and new video arrays, it is vital that the comparison
        -:   65: * always be done in the correct order: an element of the old video array,
        -:   66: * followed by an element of the new one.  In this case, having ascertained
        -:   67: * that both elements are multiword (because they have the some attributes),
        -:   68: * we do the character comparison in two stages: first we check that the
        -:   69: * lengths are the same, then we check that the characters stored are the
        -:   70: * same.  This ensures we can't read past the end of either array.  If either
        -:   71: * character is a constant, then TXT_MULTIWORD_MASK is guaranteed not to be
        -:   72: * set and this doesn't matter.
        -:   73: */
        -:   74:#define ZR_equal(oldzr, newzr)					   \
        -:   75:    ((oldzr).atr == (newzr).atr &&				   \
        -:   76:     (((oldzr).atr & TXT_MULTIWORD_MASK) ?			   \
        -:   77:      (omwbuf[(oldzr).chr] == nmwbuf[(newzr).chr] &&		   \
        -:   78:       !memcmp(omwbuf + (oldzr).chr + 1, nmwbuf + (newzr).chr + 1, \
        -:   79:	       omwbuf[(oldzr).chr] * sizeof(*omwbuf))) :	   \
        -:   80:      (oldzr).chr == (newzr).chr))
        -:   81:#else
        -:   82:#define ZR_equal(zr1, zr2) ((zr1).chr == (zr2).chr && (zr1).atr == (zr2).atr)
        -:   83:#endif
        -:   84:
        -:   85:static void
      393:   86:ZR_memset(REFRESH_ELEMENT *dst, REFRESH_ELEMENT rc, int len)
        -:   87:{
    11794:   88:    while (len--)
    11008:   89:	*dst++ = rc;
      393:   90:}
        -:   91:
        -:   92:#define ZR_memcpy(d, s, l)  memcpy((d), (s), (l)*sizeof(REFRESH_ELEMENT))
        -:   93:
        -:   94:static void
    #####:   95:ZR_strcpy(REFRESH_ELEMENT *dst, const REFRESH_ELEMENT *src)
        -:   96:{
    #####:   97:    while ((*dst++ = *src++).chr != ZWC('\0'))
        -:   98:	;
    #####:   99:}
        -:  100:
        -:  101:static size_t
     3808:  102:ZR_strlen(const REFRESH_ELEMENT *wstr)
        -:  103:{
     3808:  104:    int len = 0;
        -:  105:
    71253:  106:    while (wstr++->chr != ZWC('\0'))
    63637:  107:	len++;
        -:  108:
     3808:  109:    return len;
        -:  110:}
        -:  111:
        -:  112:/*
        -:  113: * Simplified strcmp: we don't need the sign, just whether
        -:  114: * the strings and their attributes are equal.
        -:  115: *
        -:  116: * In the multibyte case, the two elements must be in the order
        -:  117: * element from old video array, element from new video array.
        -:  118: */
        -:  119:static int
    #####:  120:ZR_strncmp(const REFRESH_ELEMENT *oldwstr, const REFRESH_ELEMENT *newwstr,
        -:  121:	   int len)
        -:  122:{
    #####:  123:    while (len--) {
    #####:  124:	if ((!(oldwstr->atr & TXT_MULTIWORD_MASK) && !oldwstr->chr) ||
    #####:  125:	    (!(newwstr->atr & TXT_MULTIWORD_MASK) && !newwstr->chr))
    #####:  126:	    return !ZR_equal(*oldwstr, *newwstr);
    #####:  127:	if (!ZR_equal(*oldwstr, *newwstr))
    #####:  128:	    return 1;
    #####:  129:	oldwstr++;
    #####:  130:	newwstr++;
        -:  131:    }
        -:  132:
    #####:  133:    return 0;
        -:  134:}
        -:  135:
        -:  136:#include "zle_refresh.pro"
        -:  137:
        -:  138:/*
        -:  139: * Expanded prompts.
        -:  140: *
        -:  141: * These are always output from the start, except in the special
        -:  142: * case where we are sure each character in the prompt corresponds
        -:  143: * to a character on screen.
        -:  144: */
        -:  145:
        -:  146:/**/
        -:  147:char *lpromptbuf, *rpromptbuf;
        -:  148:
        -:  149:/* Text attributes after displaying prompts */
        -:  150:
        -:  151:/**/
        -:  152:zattr pmpt_attr, rpmpt_attr;
        -:  153:
        -:  154:/* number of lines displayed */
        -:  155:
        -:  156:/**/
        -:  157:mod_export int nlnct;
        -:  158:
        -:  159:/* Most lines of the buffer we've shown at once with the current list *
        -:  160: * showing.  == 0 if there is no list.  == -1 if a new list has just  *
        -:  161: * been put on the screen.  == -2 if zrefresh() needs to put up a new *
        -:  162: * list.                                                              */
        -:  163:
        -:  164:/**/
        -:  165:mod_export int showinglist;
        -:  166:
        -:  167:/* > 0 if a completion list is displayed below the prompt,
        -:  168: * < 0 if a list is displayed above the prompt. */
        -:  169:
        -:  170:/**/
        -:  171:mod_export int listshown;
        -:  172:
        -:  173:/* Length of last list displayed (if it is below the prompt). */
        -:  174:
        -:  175:/**/
        -:  176:mod_export int lastlistlen;
        -:  177:
        -:  178:/* Non-zero if ALWAYS_LAST_PROMPT has been used, meaning that the *
        -:  179: * screen below the buffer display should not be cleared by       *
        -:  180: * zrefresh(), but should be by trashzle().                       */
        -:  181:
        -:  182:/**/
        -:  183:mod_export int clearflag;
        -:  184:
        -:  185:/* Non-zero if zrefresh() should clear the list below the prompt. */
        -:  186:
        -:  187:/**/
        -:  188:mod_export int clearlist;
        -:  189:
        -:  190:/* Zle in trashed state - updates may be subtly altered */
        -:  191:
        -:  192:/**/
        -:  193:int trashedzle;
        -:  194:
        -:  195:/*
        -:  196: * Information used by PREDISPLAY and POSTDISPLAY parameters which
        -:  197: * add non-editable text to that being displayed.
        -:  198: */
        -:  199:/**/
        -:  200:ZLE_STRING_T predisplay, postdisplay;
        -:  201:/**/
        -:  202:int predisplaylen, postdisplaylen;
        -:  203:
        -:  204:
        -:  205:/*
        -:  206: * Attributes used by default on the command line, and
        -:  207: * attributes for highlighting special (unprintable) characters
        -:  208: * displayed on screen.
        -:  209: */
        -:  210:
        -:  211:static zattr default_atr_on, special_atr_on;
        -:  212:
        -:  213:/*
        -:  214: * Array of region highlights, no special termination.
        -:  215: * The first N_SPECIAL_HIGHLIGHTS elements describe special uses of
        -:  216: * highlighting, documented under N_SPECIAL_HIGHLIGHTS.
        -:  217: * Any other elements are set by the user via the parameter region_highlight.
        -:  218: */
        -:  219:
        -:  220:/**/
        -:  221:struct region_highlight *region_highlights;
        -:  222:
        -:  223:/*
        -:  224: * Number of elements in region_highlights.
        -:  225: * This includes the special elements above.
        -:  226: */
        -:  227:/**/
        -:  228:int n_region_highlights;
        -:  229:
        -:  230:/*
        -:  231: * Flag that highlighting of the region is active.
        -:  232: */
        -:  233:/**/
        -:  234:int region_active;
        -:  235:
        -:  236:/*
        -:  237: * Name of function to use to output termcap values, if defined.
        -:  238: */
        -:  239:/**/
        -:  240:char *tcout_func_name;
        -:  241:
        -:  242:#ifdef HAVE_SELECT
        -:  243:/* cost of last update */
        -:  244:/**/
        -:  245:int cost;
        -:  246:
        -:  247:# define SELECT_ADD_COST(X)	(cost += X)
        -:  248:# define zputc(a)		(zwcputc(a, NULL), cost++)
        -:  249:# define zwrite(a, b)		(zwcwrite((a), (b)), \
        -:  250:				 cost += ((b) * ZLE_CHAR_SIZE))
        -:  251:#else
        -:  252:# define SELECT_ADD_COST(X)
        -:  253:# define zputc(a)		zwcputc(a, NULL)
        -:  254:# define zwrite(a, b)		zwcwrite((a), (b))
        -:  255:#endif
        -:  256:
        -:  257:static const REFRESH_ELEMENT zr_cr = { ZWC('\r'), 0 };
        -:  258:static const REFRESH_ELEMENT zr_dt = { ZWC('.'), 0 };
        -:  259:static const REFRESH_ELEMENT zr_nl = { ZWC('\n'), 0 };
        -:  260:static const REFRESH_ELEMENT zr_sp = { ZWC(' '), 0 };
        -:  261:static const REFRESH_ELEMENT zr_zr = { ZWC('\0'), 0 };
        -:  262:
        -:  263:/*
        -:  264: * Constant arrays to be copied into place: these are memcpy'd,
        -:  265: * so don't have terminating NULLs.
        -:  266: */
        -:  267:static const REFRESH_ELEMENT zr_end_ellipsis[] = {
        -:  268:    { ZWC(' '), 0 },
        -:  269:    { ZWC('<'), 0 },
        -:  270:    { ZWC('.'), 0 },
        -:  271:    { ZWC('.'), 0 },
        -:  272:    { ZWC('.'), 0 },
        -:  273:    { ZWC('.'), 0 },
        -:  274:    { ZWC(' '), 0 },
        -:  275:};
        -:  276:#define ZR_END_ELLIPSIS_SIZE	\
        -:  277:    ((int)(sizeof(zr_end_ellipsis)/sizeof(zr_end_ellipsis[0])))
        -:  278:
        -:  279:static const REFRESH_ELEMENT zr_mid_ellipsis1[] = {
        -:  280:    { ZWC(' '), 0 },
        -:  281:    { ZWC('<'), 0 },
        -:  282:    { ZWC('.'), 0 },
        -:  283:    { ZWC('.'), 0 },
        -:  284:    { ZWC('.'), 0 },
        -:  285:    { ZWC('.'), 0 },
        -:  286:};
        -:  287:#define ZR_MID_ELLIPSIS1_SIZE	\
        -:  288:    ((int)(sizeof(zr_mid_ellipsis1)/sizeof(zr_mid_ellipsis1[0])))
        -:  289:
        -:  290:static const REFRESH_ELEMENT zr_mid_ellipsis2[] = {
        -:  291:    { ZWC('>'), 0 },
        -:  292:    { ZWC(' '), 0 },
        -:  293:};
        -:  294:#define ZR_MID_ELLIPSIS2_SIZE	\
        -:  295:    ((int)(sizeof(zr_mid_ellipsis2)/sizeof(zr_mid_ellipsis2[0])))
        -:  296:
        -:  297:static const REFRESH_ELEMENT zr_start_ellipsis[] = {
        -:  298:    { ZWC('>'), 0 },
        -:  299:    { ZWC('.'), 0 },
        -:  300:    { ZWC('.'), 0 },
        -:  301:    { ZWC('.'), 0 },
        -:  302:    { ZWC('.'), 0 },
        -:  303:};
        -:  304:#define ZR_START_ELLIPSIS_SIZE	\
        -:  305:    ((int)(sizeof(zr_start_ellipsis)/sizeof(zr_start_ellipsis[0])))
        -:  306:
        -:  307:/*
        -:  308: * Parse the variable zle_highlight to decide how to highlight characters
        -:  309: * and regions.  Set defaults for anything not explicitly covered.
        -:  310: */
        -:  311:
        -:  312:/**/
        -:  313:static void
     1313:  314:zle_set_highlight(void)
        -:  315:{
     1313:  316:    char **atrs = getaparam("zle_highlight");
     1313:  317:    int special_atr_on_set = 0;
     1313:  318:    int region_atr_on_set = 0;
     1313:  319:    int isearch_atr_on_set = 0;
     1313:  320:    int suffix_atr_on_set = 0;
     1313:  321:    int paste_atr_on_set = 0;
        -:  322:    struct region_highlight *rhp;
        -:  323:
     1313:  324:    special_atr_on = default_atr_on = 0;
     1313:  325:    if (!region_highlights) {
       32:  326:	region_highlights = (struct region_highlight *)
       32:  327:	    zshcalloc(N_SPECIAL_HIGHLIGHTS*sizeof(struct region_highlight));
       32:  328:	n_region_highlights = N_SPECIAL_HIGHLIGHTS;
        -:  329:    } else {
     7686:  330:	for (rhp = region_highlights;
     6405:  331:	     rhp < region_highlights + N_SPECIAL_HIGHLIGHTS;
     5124:  332:	     rhp++) {
     5124:  333:	    rhp->atr = 0;
        -:  334:	}
        -:  335:    }
        -:  336:
     1313:  337:    if (atrs) {
    #####:  338:	for (; *atrs; atrs++) {
    #####:  339:	    if (!strcmp(*atrs, "none")) {
        -:  340:		/* reset attributes for consistency... usually unnecessary */
    #####:  341:		special_atr_on = default_atr_on = 0;
    #####:  342:		special_atr_on_set = 1;
    #####:  343:		paste_atr_on_set = region_atr_on_set =
    #####:  344:		    isearch_atr_on_set = suffix_atr_on_set = 1;
    #####:  345:	    } else if (strpfx("default:", *atrs)) {
    #####:  346:		match_highlight(*atrs + 8, &default_atr_on);
    #####:  347:	    } else if (strpfx("special:", *atrs)) {
    #####:  348:		match_highlight(*atrs + 8, &special_atr_on);
    #####:  349:		special_atr_on_set = 1;
    #####:  350:	    } else if (strpfx("region:", *atrs)) {
    #####:  351:		match_highlight(*atrs + 7, &region_highlights[0].atr);
    #####:  352:		region_atr_on_set = 1;
    #####:  353:	    } else if (strpfx("isearch:", *atrs)) {
    #####:  354:		match_highlight(*atrs + 8, &(region_highlights[1].atr));
    #####:  355:		isearch_atr_on_set = 1;
    #####:  356:	    } else if (strpfx("suffix:", *atrs)) {
    #####:  357:		match_highlight(*atrs + 7, &(region_highlights[2].atr));
    #####:  358:		suffix_atr_on_set = 1;
    #####:  359:	    } else if (strpfx("paste:", *atrs)) {
    #####:  360:		match_highlight(*atrs + 6, &(region_highlights[3].atr));
    #####:  361:		paste_atr_on_set = 1;
        -:  362:	    }
        -:  363:	}
        -:  364:    }
        -:  365:
        -:  366:    /* Defaults */
     1313:  367:    if (!special_atr_on_set)
     1313:  368:	special_atr_on = TXTSTANDOUT;
     1313:  369:    if (!region_atr_on_set)
     1313:  370:	region_highlights[0].atr = TXTSTANDOUT;
     1313:  371:    if (!isearch_atr_on_set)
     1313:  372:	region_highlights[1].atr = TXTUNDERLINE;
     1313:  373:    if (!suffix_atr_on_set)
     1313:  374:	region_highlights[2].atr = TXTBOLDFACE;
     1313:  375:    if (!paste_atr_on_set)
     1313:  376:	region_highlights[3].atr = TXTSTANDOUT;
        -:  377:
     1313:  378:    allocate_colour_buffer();
     1313:  379:}
        -:  380:
        -:  381:
        -:  382:/**/
        -:  383:static void
     1313:  384:zle_free_highlight(void)
        -:  385:{
     1313:  386:    free_colour_buffer();
     1313:  387:}
        -:  388:
        -:  389:/*
        -:  390: * Interface to the region_highlight ZLE parameter.
        -:  391: * Converts between a format like "P32 42 underline,bold" to
        -:  392: * the format in the region_highlights variable.  Note that
        -:  393: * the region_highlights variable stores the internal (point/mark)
        -:  394: * region in element zero.
        -:  395: */
        -:  396:
        -:  397:/**/
        -:  398:char **
    #####:  399:get_region_highlight(UNUSED(Param pm))
        -:  400:{
    #####:  401:    int arrsize = n_region_highlights;
        -:  402:    char **retarr, **arrp;
        -:  403:    struct region_highlight *rhp;
        -:  404:
        -:  405:    /* region_highlights may not have been set yet */
    #####:  406:    if (!arrsize)
    #####:  407:	return hmkarray(NULL);
    #####:  408:    arrsize -= N_SPECIAL_HIGHLIGHTS;
        -:  409:    DPUTS(arrsize < 0, "arrsize is negative from n_region_highlights");
    #####:  410:    arrp = retarr = (char **)zhalloc((arrsize+1)*sizeof(char *));
        -:  411:
        -:  412:    /* ignore special highlighting */
    #####:  413:    for (rhp = region_highlights + N_SPECIAL_HIGHLIGHTS;
    #####:  414:	 arrsize--;
    #####:  415:	 rhp++, arrp++) {
        -:  416:	char digbuf1[DIGBUFSIZE], digbuf2[DIGBUFSIZE];
        -:  417:	int atrlen, alloclen;
    #####:  418:	const char memo_equals[] = "memo=";
        -:  419:
    #####:  420:	sprintf(digbuf1, "%d", rhp->start);
    #####:  421:	sprintf(digbuf2, "%d", rhp->end);
        -:  422:
    #####:  423:	atrlen = output_highlight(rhp->atr, NULL);
    #####:  424:	alloclen = atrlen + strlen(digbuf1) + strlen(digbuf2) +
        -:  425:	    3; /* 2 spaces, 1 terminating NUL */
    #####:  426:	if (rhp->flags & ZRH_PREDISPLAY)
    #####:  427:	    alloclen += 2; /* "P " */
    #####:  428:	if (rhp->memo)
    #####:  429:	    alloclen += 1 /* space */ + strlen(memo_equals) + strlen(rhp->memo);
    #####:  430:	*arrp = (char *)zhalloc(alloclen * sizeof(char));
        -:  431:	/*
        -:  432:	 * On input we allow a space after the flags.
        -:  433:	 * I haven't put a space here because I think it's
        -:  434:	 * marginally easier to have the output always split
        -:  435:	 * into three words, and then check the first to
        -:  436:	 * see if there are flags.  However, it's arguable.
        -:  437:	 */
    #####:  438:	sprintf(*arrp, "%s%s %s ",
    #####:  439:		(rhp->flags & ZRH_PREDISPLAY) ? "P" : "",
        -:  440:		digbuf1, digbuf2);
    #####:  441:	(void)output_highlight(rhp->atr, *arrp + strlen(*arrp));
        -:  442:
    #####:  443:	if (rhp->memo) {
    #####:  444:	    strcat(*arrp, " ");
    #####:  445:	    strcat(*arrp, memo_equals);
    #####:  446:	    strcat(*arrp, rhp->memo);
        -:  447:	}
        -:  448:    }
    #####:  449:    *arrp = NULL;
    #####:  450:    return retarr;
        -:  451:}
        -:  452:
        -:  453:
        -:  454:/*
        -:  455: * The parameter system requires the pm argument, but this
        -:  456: * may be NULL if called directly.
        -:  457: */
        -:  458:
        -:  459:/**/
        -:  460:void
       39:  461:set_region_highlight(UNUSED(Param pm), char **aval)
        -:  462:{
        -:  463:    int len;
       39:  464:    char **av = aval;
        -:  465:    struct region_highlight *rhp;
        -:  466:
       39:  467:    len = aval ? arrlen(aval) : 0;
       39:  468:    if (n_region_highlights != len + N_SPECIAL_HIGHLIGHTS) {
        -:  469:	/* no null termination, but include special highlighting at start */
    #####:  470:	int newsize = len + N_SPECIAL_HIGHLIGHTS;
    #####:  471:	int diffsize = newsize - n_region_highlights;
        -:  472:
    #####:  473:	free_region_highlights_memos();
    #####:  474:	region_highlights = (struct region_highlight *)
    #####:  475:	    zrealloc(region_highlights,
        -:  476:		     sizeof(struct region_highlight) * newsize);
    #####:  477:	if (diffsize > 0)
    #####:  478:	    memset(region_highlights + newsize - diffsize, 0,
        -:  479:		   sizeof(struct region_highlight) * diffsize);
    #####:  480:	n_region_highlights = newsize;
        -:  481:    }
        -:  482:
       39:  483:    if (!aval)
       39:  484:	return;
        -:  485:
    #####:  486:    for (rhp = region_highlights + N_SPECIAL_HIGHLIGHTS;
    #####:  487:	 *aval;
    #####:  488:	 rhp++, aval++) {
        -:  489:	char *strp, *oldstrp;
    #####:  490:	const char memo_equals[] = "memo=";
        -:  491:
    #####:  492:	oldstrp = *aval;
    #####:  493:	if (*oldstrp == 'P') {
    #####:  494:	    rhp->flags = ZRH_PREDISPLAY;
    #####:  495:	    oldstrp++;
        -:  496:	}
        -:  497:	else
    #####:  498:	    rhp->flags = 0;
    #####:  499:	while (inblank(*oldstrp))
    #####:  500:	    oldstrp++;
        -:  501:
    #####:  502:	rhp->start = (int)zstrtol(oldstrp, &strp, 10);
    #####:  503:	if (strp == oldstrp)
    #####:  504:	    rhp->start = -1;
        -:  505:
    #####:  506:	while (inblank(*strp))
    #####:  507:	    strp++;
        -:  508:
    #####:  509:	oldstrp = strp;
    #####:  510:	rhp->end = (int)zstrtol(strp, &strp, 10);
    #####:  511:	if (strp == oldstrp)
    #####:  512:	    rhp->end = -1;
        -:  513:
    #####:  514:	while (inblank(*strp))
    #####:  515:	    strp++;
        -:  516:
    #####:  517:	strp = (char*) match_highlight(strp, &rhp->atr);
        -:  518:
    #####:  519:	while (inblank(*strp))
    #####:  520:	    strp++;
        -:  521:
    #####:  522:	if (strpfx(memo_equals, strp)) {
    #####:  523:	    const char *memo_start = strp + strlen(memo_equals);
        -:  524:	    const char *i, *memo_end;
        -:  525:
        -:  526:	    /* 
        -:  527:	     * Forward compatibility: end parsing at a comma or whitespace to
        -:  528:	     * allow the following extensions:
        -:  529:	     *
        -:  530:	     * - A fifth field: "0 20 bold memo=foo bar".
        -:  531:	     *
        -:  532:	     * - Additional attributes in the fourth field: "0 20 bold memo=foo,bar"
        -:  533:	     *   and "0 20 bold memo=foo\0bar".
        -:  534:	     *
        -:  535:	     * For similar reasons, we don't flag an error if the fourth field
        -:  536:	     * doesn't start with "memo=" as we expect.
        -:  537:	     */
    #####:  538:	    i = memo_start;
        -:  539:
        -:  540:	    /* ### TODO: Consider optimizing the common case that memo_start to
        -:  541:	     *           end-of-string is entirely ASCII */
    #####:  542:	    while (1) {
        -:  543:		int nbytes;
    #####:  544:		convchar_t c = unmeta_one(i, &nbytes);
        -:  545:
    #####:  546:		if (c == '\0' || c == ',' || inblank(c)) {
    #####:  547:		    memo_end = i;
    #####:  548:		    break;
        -:  549:		} else
    #####:  550:		    i += nbytes;
        -:  551:	    }
    #####:  552:	    rhp->memo = ztrduppfx(memo_start, memo_end - memo_start);
        -:  553:	} else
    #####:  554:	    rhp->memo = NULL;
        -:  555:    }
        -:  556:
    #####:  557:    freearray(av);
        -:  558:}
        -:  559:
        -:  560:
        -:  561:/**/
        -:  562:void
      101:  563:unset_region_highlight(Param pm, int exp)
        -:  564:{
      101:  565:    if (exp) {
    #####:  566:	set_region_highlight(pm, NULL);
    #####:  567:	stdunsetfn(pm, exp);
        -:  568:    }
      101:  569:}
        -:  570:
        -:  571:
        -:  572:/* The last attributes that were on. */
        -:  573:static zattr lastatr;
        -:  574:
        -:  575:/*
        -:  576: * Clear the last attributes that we set:  used when we're going
        -:  577: * to be outputting stuff that shouldn't show up as text.
        -:  578: */
        -:  579:static void
      332:  580:clearattributes(void)
        -:  581:{
      332:  582:    if (lastatr) {
    #####:  583:	settextattributes(TXT_ATTR_OFF_FROM_ON(lastatr));
    #####:  584:	lastatr = 0;
        -:  585:    }
      332:  586:}
        -:  587:
        -:  588:/*
        -:  589: * Output a termcap capability, clearing any text attributes so
        -:  590: * as not to mess up the display.
        -:  591: */
        -:  592:
        -:  593:static void
      332:  594:tcoutclear(int cap)
        -:  595:{
      332:  596:    clearattributes();
      332:  597:    tcout(cap);
      332:  598:}
        -:  599:
        -:  600:/*
        -:  601: * Output the character.  This must come from the new video
        -:  602: * buffer, nbuf, since we access the multiword buffer nmwbuf
        -:  603: * directly.
        -:  604: *
        -:  605: * curatrp may be NULL, otherwise points to an integer specifying
        -:  606: * what attributes were turned on for a character output immediately
        -:  607: * before, in order to optimise output of attribute changes.
        -:  608: */
        -:  609:
        -:  610:/**/
        -:  611:void
     1714:  612:zwcputc(const REFRESH_ELEMENT *c, zattr *curatrp)
        -:  613:{
        -:  614:    /*
        -:  615:     * Safety: turn attributes off if last heard of turned on.
        -:  616:     * This differs from *curatrp, which is an optimisation for
        -:  617:     * writing lots of stuff at once.
        -:  618:     */
        -:  619:#ifdef MULTIBYTE_SUPPORT
        -:  620:    mbstate_t mbstate;
        -:  621:    int i;
     1714:  622:    VARARR(char, mbtmp, MB_CUR_MAX + 1);
        -:  623:#endif
        -:  624:
     1714:  625:    if (lastatr & ~c->atr) {
        -:  626:	/* Stuff on we don't want, turn it off */
    #####:  627:	settextattributes(TXT_ATTR_OFF_FROM_ON(lastatr & ~c->atr));
    #####:  628:	lastatr = 0;
        -:  629:    }
        -:  630:
        -:  631:    /*
        -:  632:     * Don't output "on" attributes in a string of characters with
        -:  633:     * the same attributes.  Be careful in case a different colour
        -:  634:     * needs setting.
        -:  635:     */
     1714:  636:    if ((c->atr & TXT_ATTR_ON_MASK) &&
       15:  637:	(!curatrp ||
       30:  638:	 ((*curatrp & TXT_ATTR_ON_VALUES_MASK) !=
       15:  639:	  (c->atr & TXT_ATTR_ON_VALUES_MASK)))) {
        -:  640:	/* Record just the control flags we might need to turn off... */
       15:  641:	lastatr = c->atr & TXT_ATTR_ON_MASK;
        -:  642:	/* ...but set including the values for colour attributes */
       15:  643:	settextattributes(c->atr & TXT_ATTR_ON_VALUES_MASK);
        -:  644:    }
        -:  645:
        -:  646:#ifdef MULTIBYTE_SUPPORT
     1714:  647:    if (c->atr & TXT_MULTIWORD_MASK) {
        -:  648:	/* Multiword glyph stored in nmwbuf */
    #####:  649:	int nchars = nmwbuf[c->chr];
    #####:  650:	REFRESH_CHAR *wcptr = nmwbuf + c->chr + 1;
        -:  651:
    #####:  652:	memset(&mbstate, 0, sizeof(mbstate_t));
    #####:  653:	while (nchars--) {
    #####:  654:	    if ((i = wcrtomb(mbtmp, (wchar_t)*wcptr++, &mbstate)) > 0)
    #####:  655:		fwrite(mbtmp, i, 1, shout);
        -:  656:	}
     1714:  657:    } else if (c->chr != WEOF) {
     1714:  658:	memset(&mbstate, 0, sizeof(mbstate_t));
     1714:  659:	if ((i = wcrtomb(mbtmp, (wchar_t)c->chr, &mbstate)) > 0)
     1714:  660:	    fwrite(mbtmp, i, 1, shout);
        -:  661:    }
        -:  662:#else
        -:  663:    fputc(c->chr, shout);
        -:  664:#endif
        -:  665:
        -:  666:    /*
        -:  667:     * Always output "off" attributes since we only turn off at
        -:  668:     * the end of a chunk of highlighted text.
        -:  669:     */
     1714:  670:    if (c->atr & TXT_ATTR_OFF_MASK) {
       15:  671:	settextattributes(c->atr & TXT_ATTR_OFF_MASK);
       15:  672:	lastatr &= ~((c->atr & TXT_ATTR_OFF_MASK) >> TXT_ATTR_OFF_ON_SHIFT);
        -:  673:    }
     1714:  674:    if (curatrp) {
        -:  675:	/*
        -:  676:	 * Remember the current attributes:  those that are turned
        -:  677:	 * on, less those that are turned off again.  Include
        -:  678:	 * colour attributes here in case the colour changes to
        -:  679:	 * another non-default one.
        -:  680:	 */
     3032:  681:	*curatrp = (c->atr & TXT_ATTR_ON_VALUES_MASK) &
     1516:  682:	    ~((c->atr & TXT_ATTR_OFF_MASK) >> TXT_ATTR_OFF_ON_SHIFT);
        -:  683:    }
     1714:  684:}
        -:  685:
        -:  686:static int
     1048:  687:zwcwrite(const REFRESH_STRING s, size_t i)
        -:  688:{
        -:  689:    size_t j;
     1048:  690:    zattr curatr = 0;
        -:  691:
     2564:  692:    for (j = 0; j < i; j++)
     1516:  693:	zwcputc(s + j, &curatr);
     1048:  694:    return i; /* TODO something better for error indication */
        -:  695:}
        -:  696:
        -:  697:/* Oct/Nov 94: <mason> some code savagely redesigned to fix several bugs -
        -:  698:   refreshline() & tc_rightcurs() majorly rewritten; zrefresh() fixed -
        -:  699:   I've put my fingers into just about every routine in here -
        -:  700:   any queries about updates to mason@primenet.com.au */
        -:  701:
        -:  702:static REFRESH_STRING 
        -:  703:    *nbuf = NULL,		/* new video buffer line-by-line array */
        -:  704:    *obuf = NULL;		/* old video buffer line-by-line array */
        -:  705:static int more_start,		/* more text before start of screen?	    */
        -:  706:    more_end,			/* more stuff after end of screen?	    */
        -:  707:    olnct,			/* previous number of lines		    */
        -:  708:    ovln,			/* previous video cursor position line	    */
        -:  709:    lpromptw, rpromptw,		/* prompt widths on screen                  */
        -:  710:    lpromptwof,			/* left prompt width with real end position */
        -:  711:    lprompth,			/* lines taken up by the prompt		    */
        -:  712:    rprompth,			/* right prompt height                      */
        -:  713:    vcs, vln,			/* video cursor position column & line	    */
        -:  714:    vmaxln,			/* video maximum number of lines	    */
        -:  715:    winw, winh, rwinh,		/* window width & height		    */
        -:  716:    winpos,			/* singlelinezle: line's position in window */
        -:  717:    winprompt,			/* singlelinezle: part of lprompt showing   */
        -:  718:    winw_alloc = -1,		/* allocated window width */
        -:  719:    winh_alloc = -1;		/* allocates window height */
        -:  720:#ifdef MULTIBYTE_SUPPORT
        -:  721:static int
        -:  722:    omw_size,			/* allocated size of omwbuf */
        -:  723:    nmw_size,			/* allocated size of nmwbuf */
        -:  724:    nmw_ind;			/* next insert point in nmw_ind */
        -:  725:#endif
        -:  726:
        -:  727:/*
        -:  728: * Number of words to allocate in one go for the multiword buffers.
        -:  729: */
        -:  730:#define DEF_MWBUF_ALLOC	(32)
        -:  731:
        -:  732:static void
        1:  733:freevideo(void)
        -:  734:{
        1:  735:    if (nbuf) {
        -:  736:	int ln;
    #####:  737:	for (ln = 0; ln != winh_alloc; ln++) {
    #####:  738:	    zfree(nbuf[ln], (winw_alloc + 2) * sizeof(**nbuf));
    #####:  739:	    zfree(obuf[ln], (winw_alloc + 2) * sizeof(**obuf));
        -:  740:	}
    #####:  741:	free(nbuf);
    #####:  742:	free(obuf);
        -:  743:#ifdef MULTIBYTE_SUPPORT
    #####:  744:	zfree(nmwbuf, nmw_size * sizeof(*nmwbuf));
    #####:  745:	zfree(omwbuf, omw_size * sizeof(*omwbuf));
    #####:  746:	omw_size = nmw_size = 0;
    #####:  747:	nmw_ind = 1;
        -:  748:#endif
    #####:  749:	nbuf = NULL;
    #####:  750:	obuf = NULL;
    #####:  751:	winw_alloc = -1;
    #####:  752:	winh_alloc = -1;
        -:  753:    }
        1:  754:}
        -:  755:
        -:  756:/**/
        -:  757:void
      131:  758:resetvideo(void)
        -:  759:{
        -:  760:    int ln;
        -:  761: 
      131:  762:    winw = zterm_columns;  /* terminal width */
      131:  763:    if (termflags & TERM_SHORT)
    #####:  764:	winh = 1;
        -:  765:    else
      131:  766:	winh = (zterm_lines < 2) ? 24 : zterm_lines;
      131:  767:    rwinh = zterm_lines;		/* keep the real number of lines */
      131:  768:    vln = vmaxln = winprompt = 0;
      131:  769:    winpos = -1;
      131:  770:    if (winw_alloc != winw || winh_alloc != winh) {
        1:  771:	freevideo();
        1:  772:	nbuf = (REFRESH_STRING *)zshcalloc((winh + 1) * sizeof(*nbuf));
        1:  773:	obuf = (REFRESH_STRING *)zshcalloc((winh + 1) * sizeof(*obuf));
        1:  774:	nbuf[0] = (REFRESH_STRING)zalloc((winw + 2) * sizeof(**nbuf));
        1:  775:	obuf[0] = (REFRESH_STRING)zalloc((winw + 2) * sizeof(**obuf));
        -:  776:
        -:  777:#ifdef MULTIBYTE_SUPPORT
        1:  778:	nmw_size = DEF_MWBUF_ALLOC;
        1:  779:	nmw_ind = 1;
        1:  780:	nmwbuf = (REFRESH_CHAR *)zalloc(nmw_size * sizeof(*nmwbuf));
        -:  781:
        1:  782:	omw_size = DEF_MWBUF_ALLOC;
        1:  783:	omwbuf = (REFRESH_CHAR *)zalloc(omw_size * sizeof(*omwbuf));
        -:  784:#endif
        -:  785:
        1:  786:	winw_alloc = winw;
        1:  787:	winh_alloc = winh;
        -:  788:    }
     3406:  789:    for (ln = 0; ln != winh + 1; ln++) {
     3275:  790:	if (nbuf[ln]) {
      131:  791:	    nbuf[ln][0] = zr_nl;
      131:  792:	    nbuf[ln][1] = zr_zr;
        -:  793:	}
     3275:  794:	if (obuf[ln]) {
      131:  795:	    obuf[ln][0] = zr_nl;
      131:  796:	    obuf[ln][1] = zr_zr;
        -:  797:	}
        -:  798:    }
        -:  799:
        -:  800:    /*
        -:  801:     * countprompt() now correctly handles multibyte input.
        -:  802:     */
      131:  803:    countprompt(lpromptbuf, &lpromptwof, &lprompth, 1);
      131:  804:    countprompt(rpromptbuf, &rpromptw, &rprompth, 0);
      131:  805:    if (lpromptwof != winw)
      131:  806:	lpromptw = lpromptwof;
        -:  807:    else {
    #####:  808:	lpromptw = 0;
    #####:  809:	lprompth++;
        -:  810:    }
        -:  811:
      131:  812:    if (lpromptw) {
      131:  813:    	ZR_memset(nbuf[0], zr_sp, lpromptw);
      131:  814:	ZR_memset(obuf[0], zr_sp, lpromptw);
      131:  815:	nbuf[0][lpromptw] = obuf[0][lpromptw] = zr_zr;
        -:  816:    }
        -:  817:
      131:  818:    vcs = lpromptw;
      131:  819:    olnct = nlnct = 0;
      131:  820:    if (showinglist > 0)
    #####:  821:	showinglist = -2;
      131:  822:    trashedzle = 0;
      131:  823:}
        -:  824:
        -:  825:/*
        -:  826: * Nov 96: <mason> changed to single line scroll
        -:  827: */
        -:  828:
        -:  829:/**/
        -:  830:static void
    #####:  831:scrollwindow(int tline)
        -:  832:{
        -:  833:    int t0;
        -:  834:    REFRESH_STRING s;
        -:  835:
    #####:  836:    s = nbuf[tline];
    #####:  837:    for (t0 = tline; t0 < winh - 1; t0++)
    #####:  838:	nbuf[t0] = nbuf[t0 + 1];
    #####:  839:    nbuf[winh - 1] = s;
    #####:  840:    if (!tline)
    #####:  841:	more_start = 1;
    #####:  842:    return;
        -:  843:}
        -:  844:
        -:  845:/*
        -:  846: * Parameters in zrefresh used for communicating with next-line functions.
        -:  847: */
        -:  848:struct rparams {
        -:  849:    int canscroll;		/* number of lines we are allowed to scroll */
        -:  850:    int ln;			/* current line we're working on */
        -:  851:    int more_status;		/* more stuff in status line */
        -:  852:    int nvcs;			/* video cursor column */
        -:  853:    int nvln;			/* video cursor line */
        -:  854:    int tosln;			/* tmp in statusline stuff */
        -:  855:    REFRESH_STRING s;		/* pointer into the video buffer */
        -:  856:    REFRESH_STRING sen;		/* pointer to end of the video buffer (eol) */
        -:  857:};
        -:  858:typedef struct rparams *Rparams;
        -:  859:
        -:  860:static int cleareol,		/* clear to end-of-line (if can't cleareod) */
        -:  861:    clearf,			/* alwayslastprompt used immediately before */
        -:  862:    put_rpmpt,			/* whether we should display right-prompt   */
        -:  863:    oput_rpmpt,			/* whether displayed right-prompt last time */
        -:  864:    oxtabs,			/* oxtabs - tabs expand to spaces if set    */
        -:  865:    numscrolls, onumscrolls;
        -:  866:
        -:  867:/*
        -:  868: * Go to the next line in the main display area.  Return 1 if we should abort
        -:  869: * processing the line loop at this point, else 0.
        -:  870: *
        -:  871: * If wrapped is non-zero, text wrapped, so output newline.
        -:  872: * Otherwise, text not wrapped, so output null.
        -:  873: */
        -:  874:static int
    #####:  875:nextline(Rparams rpms, int wrapped)
        -:  876:{
    #####:  877:    nbuf[rpms->ln][winw+1] = wrapped ? zr_nl : zr_zr;
    #####:  878:    *rpms->s = zr_zr;
    #####:  879:    if (rpms->ln != winh - 1)
    #####:  880:	rpms->ln++;
        -:  881:    else {
    #####:  882:	if (!rpms->canscroll)	{
    #####:  883:	    if (rpms->nvln != -1 && rpms->nvln != winh - 1
    #####:  884:		&& (numscrolls != onumscrolls - 1
    #####:  885:		    || rpms->nvln <= winh / 2))
    #####:  886:		return 1;
    #####:  887:	    numscrolls++;
    #####:  888:	    rpms->canscroll = winh / 2;
        -:  889:	}
    #####:  890:	rpms->canscroll--;
    #####:  891:	scrollwindow(0);
    #####:  892:	if (rpms->nvln != -1)
    #####:  893:	    rpms->nvln--;
        -:  894:    }
    #####:  895:    if (!nbuf[rpms->ln])
    #####:  896:	nbuf[rpms->ln] = (REFRESH_STRING)zalloc((winw + 2) * sizeof(**nbuf));
    #####:  897:    rpms->s = nbuf[rpms->ln];
    #####:  898:    rpms->sen = rpms->s + winw;
        -:  899:
    #####:  900:    return 0;
        -:  901:}
        -:  902:
        -:  903:
        -:  904:/*
        -:  905: * Go to the next line in the status area.
        -:  906: */
        -:  907:static void
    #####:  908:snextline(Rparams rpms)
        -:  909:{
    #####:  910:    *rpms->s = zr_zr;
    #####:  911:    if (rpms->ln != winh - 1)
    #####:  912:	rpms->ln++;
        -:  913:    else
    #####:  914:	if (rpms->tosln > rpms->ln) {
    #####:  915:	    rpms->tosln--;
    #####:  916:	    if (rpms->nvln > 1) {
    #####:  917:		scrollwindow(0);
    #####:  918:		rpms->nvln--;
        -:  919:	    } else
    #####:  920:		more_end = 1;
    #####:  921:	} else if (rpms->tosln > 2 && rpms->nvln > 1) {
    #####:  922:	    rpms->tosln--;
    #####:  923:	    if (rpms->tosln <= rpms->nvln) {
    #####:  924:		scrollwindow(0);
    #####:  925:		rpms->nvln--;
        -:  926:	    } else {
    #####:  927:		scrollwindow(rpms->tosln);
    #####:  928:		more_end = 1;
        -:  929:	    }
        -:  930:	} else {
    #####:  931:	    rpms->more_status = 1;
    #####:  932:	    scrollwindow(rpms->tosln + 1);
        -:  933:	}
    #####:  934:    if (!nbuf[rpms->ln])
    #####:  935:	nbuf[rpms->ln] = (REFRESH_STRING)zalloc((winw + 2) * sizeof(**nbuf));
    #####:  936:    rpms->s = nbuf[rpms->ln];
    #####:  937:    rpms->sen = rpms->s + winw;
    #####:  938:}
        -:  939:
        -:  940:
        -:  941:/**/
        -:  942:static void
       34:  943:settextattributes(zattr atr)
        -:  944:{
       34:  945:    if (txtchangeisset(atr, TXTNOBOLDFACE))
       15:  946:	tsetcap(TCALLATTRSOFF, 0);
       34:  947:    if (txtchangeisset(atr, TXTNOSTANDOUT))
    #####:  948:	tsetcap(TCSTANDOUTEND, 0);
       34:  949:    if (txtchangeisset(atr, TXTNOUNDERLINE))
    #####:  950:	tsetcap(TCUNDERLINEEND, 0);
       34:  951:    if (txtchangeisset(atr, TXTBOLDFACE))
       15:  952:	tsetcap(TCBOLDFACEBEG, 0);
       34:  953:    if (txtchangeisset(atr, TXTSTANDOUT))
    #####:  954:	tsetcap(TCSTANDOUTBEG, 0);
       34:  955:    if (txtchangeisset(atr, TXTUNDERLINE))
    #####:  956:	tsetcap(TCUNDERLINEBEG, 0);
       34:  957:    if (txtchangeisset(atr, TXTFGCOLOUR|TXTNOFGCOLOUR))
    #####:  958:	set_colour_attribute(atr, COL_SEQ_FG, 0);
       34:  959:    if (txtchangeisset(atr, TXTBGCOLOUR|TXTNOBGCOLOUR))
    #####:  960:	set_colour_attribute(atr, COL_SEQ_BG, 0);
       34:  961:}
        -:  962:
        -:  963:#ifdef MULTIBYTE_SUPPORT
        -:  964:/*
        -:  965: * Add a multiword glyph at the screen location base.
        -:  966: * tptr points to the source and there are ichars characters.
        -:  967: */
        -:  968:static void
    #####:  969:addmultiword(REFRESH_ELEMENT *base, ZLE_STRING_T tptr, int ichars)
        -:  970:{
        -:  971:    /* Number of characters needed in buffer incl. count */
    #####:  972:    int iadd = ichars + 1, icnt;
        -:  973:    REFRESH_CHAR *nmwptr;
    #####:  974:    base->atr |= TXT_MULTIWORD_MASK;
        -:  975:    /* check allocation */
    #####:  976:    if (nmw_ind + iadd > nmw_size) {
        -:  977:	/* need more space in buffer */
    #####:  978:	int mw_more = (iadd > DEF_MWBUF_ALLOC) ? iadd :
        -:  979:	    DEF_MWBUF_ALLOC;
    #####:  980:	nmwbuf = (REFRESH_CHAR *)
    #####:  981:	    zrealloc(nmwbuf, (nmw_size += mw_more) *
        -:  982:		     sizeof(*nmwbuf));
        -:  983:    }
        -:  984:    /* make buffer entry: count, then characters */
    #####:  985:    nmwptr = nmwbuf + nmw_ind;
    #####:  986:    *nmwptr++ = ichars;
    #####:  987:    for (icnt = 0; icnt < ichars; icnt++)
    #####:  988:	*nmwptr++ = tptr[icnt];
        -:  989:    /* save index and update */
    #####:  990:    base->chr = (wint_t)nmw_ind;
    #####:  991:    nmw_ind += iadd;
    #####:  992:}
        -:  993:#endif
        -:  994:
        -:  995:
        -:  996:/*
        -:  997: * Swap the old and new video buffers, plus any associated multiword
        -:  998: * buffers.  The new buffer becomes the old one; the new buffer
        -:  999: * will be filled with the command line next time.
        -: 1000: */
        -: 1001:static void
     1313: 1002:bufswap(void)
        -: 1003:{
        -: 1004:    REFRESH_STRING	*qbuf;
        -: 1005:#ifdef MULTIBYTE_SUPPORT
        -: 1006:    REFRESH_CHAR *qmwbuf;
        -: 1007:    int itmp;
        -: 1008:#endif
        -: 1009:
     1313: 1010:    qbuf = nbuf;
     1313: 1011:    nbuf = obuf;
     1313: 1012:    obuf = qbuf;
        -: 1013:
        -: 1014:#ifdef MULTIBYTE_SUPPORT
        -: 1015:/* likewise multiword buffers */
     1313: 1016:    qmwbuf = nmwbuf;
     1313: 1017:    nmwbuf = omwbuf;
     1313: 1018:    omwbuf = qmwbuf;
        -: 1019:
     1313: 1020:    itmp = nmw_size;
     1313: 1021:    nmw_size = omw_size;
     1313: 1022:    omw_size = itmp;
        -: 1023:
     1313: 1024:    nmw_ind = 1;
        -: 1025:#endif
     1313: 1026:}
        -: 1027:
        -: 1028:
        -: 1029:/**/
        -: 1030:mod_export void
     1334: 1031:zrefresh(void)
        -: 1032:{
        -: 1033:    static int inlist;		/* avoiding recursion			     */
        -: 1034:    int iln;			/* current line as index in loops	     */
     1334: 1035:    int t0 = -1;		/* tmp					     */
        -: 1036:    ZLE_STRING_T tmpline,	/* line with added pre/post text	     */
        -: 1037:	t,			/* pointer into the real buffer		     */
        -: 1038:	scs,			/* pointer to cursor position in real buffer */
        -: 1039:	u;			/* pointer for status line stuff	     */
        -: 1040:    int tmpcs, tmpll;		/* ditto cursor position and line length     */
        -: 1041:    int tmppos;			/* t - tmpline				     */
        -: 1042:    int tmpalloced;		/* flag to free tmpline when finished	     */
        -: 1043:    int remetafy;		/* flag that zle line is metafied	     */
        -: 1044:    zattr txtchange;		/* attributes set after prompts              */
     1334: 1045:    int rprompt_off = 1;	/* Offset of rprompt from right of screen    */
        -: 1046:    struct rparams rpms;
        -: 1047:#ifdef MULTIBYTE_SUPPORT
        -: 1048:    int width;			/* width of wide character		     */
        -: 1049:#endif
        -: 1050:
        -: 1051:
        -: 1052:    /* If this is called from listmatches() (indirectly via trashzle()), and *
        -: 1053:     * that was called from the end of zrefresh(), then we don't need to do  *
        -: 1054:     * anything.  All this `inlist' code is actually unnecessary, but it     *
        -: 1055:     * improves speed a little in a common case.                             */
     1334: 1056:    if (inlist)
       21: 1057:	return;
        -: 1058:
        -: 1059:    /*
        -: 1060:     * zrefresh() is called from all over the place, so we can't
        -: 1061:     * be sure if the line is metafied for completion or not.
        -: 1062:     */
     1313: 1063:    if (zlemetaline != NULL) {
        2: 1064:	remetafy = 1;
        2: 1065:	unmetafy_line();
        -: 1066:    }
        -: 1067:    else
     1311: 1068:	remetafy = 0;
        -: 1069:
     1313: 1070:    if (predisplaylen || postdisplaylen) {
        -: 1071:	/* There is extra text to display at the start or end of the line */
    #####: 1072:	tmpline = zalloc((zlell + predisplaylen + postdisplaylen)*sizeof(*tmpline));
    #####: 1073:	if (predisplaylen)
    #####: 1074:	    ZS_memcpy(tmpline, predisplay, predisplaylen);
    #####: 1075:	if (zlell)
    #####: 1076:	    ZS_memcpy(tmpline+predisplaylen, zleline, zlell);
    #####: 1077:	if (postdisplaylen)
    #####: 1078:	    ZS_memcpy(tmpline+predisplaylen+zlell, postdisplay,
        -: 1079:		      postdisplaylen);
        -: 1080:
    #####: 1081:	tmpcs = zlecs + predisplaylen;
    #####: 1082:	tmpll = predisplaylen + zlell + postdisplaylen;
    #####: 1083:	tmpalloced = 1;
        -: 1084:    } else {
     1313: 1085:	tmpline = zleline;
     1313: 1086:	tmpcs = zlecs;
     1313: 1087:	tmpll = zlell;
     1313: 1088:	tmpalloced = 0;
        -: 1089:    }
        -: 1090:
        -: 1091:    /* this will create region_highlights if it's still NULL */
     1313: 1092:    zle_set_highlight();
        -: 1093:
        -: 1094:    DPUTS(!region_highlights, "region_highlights not created");
        -: 1095:
        -: 1096:    /* check for region between point ($CURSOR) and mark ($MARK) */
     1313: 1097:    if (region_active) {
    #####: 1098:	if (zlecs <= mark) {
    #####: 1099:	    region_highlights[0].start = zlecs;
    #####: 1100:	    region_highlights[0].end = mark;
        -: 1101:	} else {
    #####: 1102:	    region_highlights[0].start = mark;
    #####: 1103:	    region_highlights[0].end = zlecs;
        -: 1104:	}
    #####: 1105:	if (region_active == 2) {
    #####: 1106:	    int origcs = zlecs;
    #####: 1107:	    zlecs = region_highlights[0].end;
    #####: 1108:	    region_highlights[0].end = findeol();
    #####: 1109:	    zlecs = region_highlights[0].start;
    #####: 1110:	    region_highlights[0].start = findbol();
    #####: 1111:	    zlecs = origcs;
    #####: 1112:	} else if (invicmdmode())
    #####: 1113:	    INCPOS(region_highlights[0].end);
        -: 1114:    } else {
     1313: 1115:	region_highlights[0].start = region_highlights[0].end = -1;
        -: 1116:    }
        -: 1117:    /* check for isearch string to highlight */
     1313: 1118:    if (isearch_active) {
    #####: 1119:	region_highlights[1].start = isearch_startpos;
    #####: 1120:	region_highlights[1].end = isearch_endpos;
        -: 1121:    } else {
     1313: 1122:	region_highlights[1].start = region_highlights[1].end = -1;
        -: 1123:    }
        -: 1124:    /* check for an active completion suffix */
     1313: 1125:    if (suffixlen) {
       29: 1126:	region_highlights[2].start = zlecs - suffixlen;
       29: 1127:	region_highlights[2].end = zlecs;
        -: 1128:    } else {
     1284: 1129:	region_highlights[2].start = region_highlights[2].end = -1;
        -: 1130:    }
        -: 1131:
     1313: 1132:    if (lastcmd & ZLE_YANK) {
    #####: 1133:	region_highlights[3].start = yankb;
    #####: 1134:	region_highlights[3].end = yanke;
        -: 1135:    } else {
     1313: 1136:	region_highlights[3].start = region_highlights[3].end = -1;
        -: 1137:    }
        -: 1138:
     1313: 1139:    if (clearlist && listshown > 0) {
        4: 1140:	if (tccan(TCCLEAREOD)) {
        4: 1141:	    int ovln = vln, ovcs = vcs;
        4: 1142:	    REFRESH_STRING nb = nbuf[vln];
        -: 1143:
        4: 1144:	    nbuf[vln] = obuf[vln];
        4: 1145:	    moveto(nlnct, 0);
        4: 1146:	    tcoutclear(TCCLEAREOD);
        4: 1147:	    moveto(ovln, ovcs);
        4: 1148:	    nbuf[vln] = nb;
        -: 1149:	} else {
    #####: 1150:	    invalidatelist();
    #####: 1151:	    moveto(0, 0);
    #####: 1152:	    clearflag = 0;
    #####: 1153:	    resetneeded = 1;
        -: 1154:	}
        4: 1155:	listshown = lastlistlen = 0;
        4: 1156:	if (showinglist != -2)
        4: 1157:	    showinglist = 0;
        -: 1158:    }
     1313: 1159:    clearlist = 0;
        -: 1160:
        -: 1161:#ifdef HAVE_SELECT
     1313: 1162:    cost = 0;			/* reset */
        -: 1163:#endif
        -: 1164:
        -: 1165:/* Nov 96: <mason>  I haven't checked how complete this is.  sgtty stuff may
        -: 1166:   or may not work */
        -: 1167:#if defined(SGTABTYPE)
     1313: 1168:    oxtabs = ((SGTTYFLAG & SGTABTYPE) == SGTABTYPE);
        -: 1169:#else
        -: 1170:    oxtabs = 0;
        -: 1171:#endif
        -: 1172:
     1313: 1173:    cleareol = 0;		/* unset */
     1313: 1174:    more_start = more_end = 0;	/* unset */
     1313: 1175:    if (isset(SINGLELINEZLE) || zterm_lines < 3
     1313: 1176:	|| (termflags & (TERM_NOUP | TERM_BAD | TERM_UNKNOWN)))
    #####: 1177:	termflags |= TERM_SHORT;
        -: 1178:    else
     1313: 1179:	termflags &= ~TERM_SHORT;
     1313: 1180:    if (resetneeded) {
      131: 1181:	onumscrolls = 0;
      131: 1182:	zsetterm();
        -: 1183:#ifdef TIOCGWINSZ
      131: 1184:	if (winchanged) {
    #####: 1185:	    moveto(0, 0);
    #####: 1186:	    t0 = olnct;		/* this is to clear extra lines even when */
    #####: 1187:	    winchanged = 0;	/* the terminal cannot TCCLEAREOD	  */
    #####: 1188:	    listshown = 0;
        -: 1189:	}
        -: 1190:#endif
        -: 1191:	/* we probably should only have explicitly set attributes */
      131: 1192:	tsetcap(TCALLATTRSOFF, 0);
      131: 1193:	tsetcap(TCSTANDOUTEND, 0);
      131: 1194:	tsetcap(TCUNDERLINEEND, 0);
      131: 1195:	txtattrmask = 0;
        -: 1196:
      131: 1197:	if (trashedzle && !clearflag)
       17: 1198:	    reexpandprompt(); 
      131: 1199:	resetvideo();
      131: 1200:	resetneeded = 0;	/* unset */
      131: 1201:	oput_rpmpt = 0;		/* no right-prompt currently on screen */
        -: 1202:
      131: 1203:	if (!clearflag) {
      127: 1204:	    if (tccan(TCCLEAREOD))
      127: 1205:		tcoutclear(TCCLEAREOD);
        -: 1206:	    else
    #####: 1207:		cleareol = 1;   /* request: clear to end of line */
      127: 1208:	    if (listshown > 0)
    #####: 1209:		listshown = 0;
        -: 1210:	}
      131: 1211:	if (t0 > -1)
    #####: 1212:	    olnct = (t0 < winh) ? t0 : winh;
      131: 1213:	if (termflags & TERM_SHORT)
    #####: 1214:	    vcs = 0;
      131: 1215:	else if (!clearflag && lpromptbuf[0]) {
      127: 1216:	    zputs(lpromptbuf, shout);
      254: 1217:	    if (lpromptwof == winw)
    #####: 1218:		zputs("\n", shout);	/* works with both hasam and !hasam */
        -: 1219:	} else {
        4: 1220:	    txtchange = pmpt_attr;
        4: 1221:	    settextattributes(txtchange);
        -: 1222:	}
      131: 1223:	if (clearflag) {
        4: 1224:	    zputc(&zr_cr);
        4: 1225:	    vcs = 0;
        4: 1226:	    moveto(0, lpromptw);
        -: 1227:	}
      131: 1228:	fflush(shout);
      131: 1229:	clearf = clearflag;
     1182: 1230:    } else if (winw != zterm_columns || rwinh != zterm_lines)
    #####: 1231:	resetvideo();
        -: 1232:
        -: 1233:/* now winw equals columns and winh equals lines 
        -: 1234:   width comparisons can be made with winw, height comparisons with winh */
        -: 1235:
     1313: 1236:    if (termflags & TERM_SHORT) {
    #####: 1237:	singlerefresh(tmpline, tmpll, tmpcs);
    #####: 1238:	goto singlelineout;
        -: 1239:    }
        -: 1240:
     1313: 1241:    if (tmpcs < 0) {
        -: 1242:#ifdef DEBUG
        -: 1243:	fprintf(stderr, "BUG: negative cursor position\n");
        -: 1244:	fflush(stderr); 
        -: 1245:#endif
    #####: 1246:	tmpcs = 0;
        -: 1247:    }
     1313: 1248:    scs = tmpline + tmpcs;
     1313: 1249:    numscrolls = 0;
        -: 1250:
        -: 1251:/* first, we generate the video line buffers so we know what to put on
        -: 1252:   the screen - also determine final cursor position (nvln, nvcs) */
        -: 1253:
        -: 1254:    /* Deemed necessary by PWS 1995/05/15 due to kill-line problems */
     1313: 1255:    if (!*nbuf)
    #####: 1256:	*nbuf = (REFRESH_STRING)zalloc((winw + 2) * sizeof(**nbuf));
        -: 1257:
     1313: 1258:    memset(&rpms, 0, sizeof(rpms));
     1313: 1259:    rpms.nvln = -1;
        -: 1260:
     1313: 1261:    rpms.s = nbuf[rpms.ln = 0] + lpromptw;
     1313: 1262:    rpms.sen = *nbuf + winw;
    13736: 1263:    for (t = tmpline, tmppos = 0; tmppos < tmpll; t++, tmppos++) {
        -: 1264:	unsigned ireg;
    12423: 1265:	zattr base_atr_on = default_atr_on, base_atr_off = 0;
        -: 1266:	zattr all_atr_on, all_atr_off;
        -: 1267:	struct region_highlight *rhp;
        -: 1268:	/*
        -: 1269:	 * Calculate attribute based on region.
        -: 1270:	 */
    74538: 1271:	for (ireg = 0, rhp = region_highlights;
    62115: 1272:	     ireg < n_region_highlights;
    49692: 1273:	     ireg++, rhp++) {
        -: 1274:	    int offset;
    49692: 1275:	    if (rhp->flags & ZRH_PREDISPLAY)
    #####: 1276:		offset = 0;	/* include predisplay in start end */
        -: 1277:	    else
    49692: 1278:		offset = predisplaylen; /* increment over it */
    99146: 1279:	    if (rhp->start + offset <= tmppos &&
    49454: 1280:		tmppos < rhp->end + offset) {
       29: 1281:		if (rhp->atr & (TXTFGCOLOUR|TXTBGCOLOUR)) {
        -: 1282:		    /* override colour with later entry */
    #####: 1283:		    base_atr_on = (base_atr_on & ~TXT_ATTR_ON_VALUES_MASK) |
    #####: 1284:			rhp->atr;
        -: 1285:		} else {
        -: 1286:		    /* no colour set yet */
       29: 1287:		    base_atr_on |= rhp->atr;
        -: 1288:		}
       29: 1289:		if (tmppos == rhp->end + offset - 1 ||
    #####: 1290:		    tmppos == tmpll - 1)
       29: 1291:		    base_atr_off |= TXT_ATTR_OFF_FROM_ON(rhp->atr);
        -: 1292:	    }
        -: 1293:	}
    12423: 1294:	if (special_atr_on & (TXTFGCOLOUR|TXTBGCOLOUR)) {
        -: 1295:	    /* keep colours from special attributes */
    #####: 1296:	    all_atr_on = special_atr_on |
    #####: 1297:		(base_atr_on & ~TXT_ATTR_COLOUR_ON_MASK);
        -: 1298:	} else {
        -: 1299:	    /* keep colours from standard attributes */
    12423: 1300:	    all_atr_on = special_atr_on | base_atr_on;
        -: 1301:	}
    12423: 1302:	all_atr_off = TXT_ATTR_OFF_FROM_ON(all_atr_on);
        -: 1303:
    12423: 1304:	if (t == scs)			/* if cursor is here, remember it */
       21: 1305:	    rpms.nvcs = rpms.s - nbuf[rpms.nvln = rpms.ln];
        -: 1306:
    12423: 1307:	if (*t == ZWC('\n')){		/* newline */
        -: 1308:	    /* text not wrapped */
    #####: 1309:	    if (nextline(&rpms, 0))
    #####: 1310:		break;
    12423: 1311:	} else if (*t == ZWC('\t')) {		/* tab */
    #####: 1312:	    t0 = rpms.s - nbuf[rpms.ln];
    #####: 1313:	    if ((t0 | 7) + 1 >= winw) {
        -: 1314:		/* text wrapped */
    #####: 1315:		if (nextline(&rpms, 1))
    #####: 1316:		    break;
        -: 1317:	    } else {
        -: 1318:		do {
    #####: 1319:		    rpms.s->chr = ZWC(' ');
    #####: 1320:		    rpms.s->atr = base_atr_on;
    #####: 1321:		    rpms.s++;
    #####: 1322:		} while ((++t0) & 7);
    #####: 1323:		rpms.s[-1].atr |= base_atr_off;
        -: 1324:	    }
        -: 1325:	}
        -: 1326:#ifdef MULTIBYTE_SUPPORT
    12423: 1327:	else if (
        -: 1328:#ifdef __STDC_ISO_10646__
    24846: 1329:		 !ZSH_INVALID_WCHAR_TEST(*t) &&
        -: 1330:#endif
    37269: 1331:		 WC_ISPRINT(*t) && (width = WCWIDTH(*t)) > 0) {
        -: 1332:	    int ichars;
    12423: 1333:	    if (width > rpms.sen - rpms.s) {
    #####: 1334:		int started = 0;
        -: 1335:		/*
        -: 1336:		 * Too wide to fit.  Insert spaces to end of current line.
        -: 1337:		 */
        -: 1338:		do {
    #####: 1339:		    rpms.s->chr = ZWC(' ');
    #####: 1340:		    if (!started)
    #####: 1341:			started = 1;
    #####: 1342:		    rpms.s->atr = all_atr_on;
    #####: 1343:		    rpms.s++;
    #####: 1344:		} while (rpms.s < rpms.sen);
    #####: 1345:		if (started)
    #####: 1346:		    rpms.s[-1].atr |= all_atr_off;
    #####: 1347:		if (nextline(&rpms, 1))
    #####: 1348:		    break;
    #####: 1349:		if (t == scs) {
        -: 1350:		    /* Update cursor to this point */
    #####: 1351:		    rpms.nvcs = rpms.s - nbuf[rpms.nvln = rpms.ln];
        -: 1352:		}
        -: 1353:	    }
    12423: 1354:	    if (isset(COMBININGCHARS) && IS_BASECHAR(*t)) {
        -: 1355:		/*
        -: 1356:		 * Look for combining characters.
        -: 1357:		 */
    #####: 1358:		for (ichars = 1; tmppos + ichars < tmpll; ichars++) {
    #####: 1359:		    if (!IS_COMBINING(t[ichars]))
        -: 1360:			break;
        -: 1361:		}
        -: 1362:	    } else
    12423: 1363:		ichars = 1;
    12423: 1364:	    if (width > rpms.sen - rpms.s || width == 0) {
        -: 1365:		/*
        -: 1366:		 * The screen width is too small to fit even one
        -: 1367:		 * occurrence.
        -: 1368:		 */
    #####: 1369:		rpms.s->chr = ZWC('?');
    #####: 1370:		rpms.s->atr = all_atr_on | all_atr_off;
    #####: 1371:		rpms.s++;
        -: 1372:	    } else {
        -: 1373:		/* We can fit it without reaching the end of the line. */
        -: 1374:		/*
        -: 1375:		 * As we don't actually output the WEOF, we attach
        -: 1376:		 * any off attributes to the character itself.
        -: 1377:		 */
    12423: 1378:		rpms.s->atr = base_atr_on | base_atr_off;
    12423: 1379:		if (ichars > 1) {
        -: 1380:		    /*
        -: 1381:		     * Glyph includes combining characters.
        -: 1382:		     * Write these into the multiword buffer and put
        -: 1383:		     * the index into the value at the screen location.
        -: 1384:		     */
    #####: 1385:		    addmultiword(rpms.s, t, ichars);
        -: 1386:		} else {
        -: 1387:		    /* Single wide character */
    12423: 1388:		    rpms.s->chr = *t;
        -: 1389:		}
    12423: 1390:		rpms.s++;
    24846: 1391:		while (--width > 0) {
    #####: 1392:		    rpms.s->chr = WEOF;
        -: 1393:		    /* Not used, but be consistent... */
    #####: 1394:		    rpms.s->atr = base_atr_on | base_atr_off;
    #####: 1395:		    rpms.s++;
        -: 1396:		}
        -: 1397:	    }
    12423: 1398:	    if (ichars > 1) {
        -: 1399:		/* allow for normal increment */
    #####: 1400:		tmppos += ichars - 1;
    #####: 1401:		t += ichars - 1;
        -: 1402:	    }
        -: 1403:	}
        -: 1404:#endif
    #####: 1405:	else if (ZC_icntrl(*t)
        -: 1406:#ifdef MULTIBYTE_SUPPORT
    #####: 1407:		 && (unsigned)*t <= 0xffU
        -: 1408:#endif
        -: 1409:	    ) {	/* other control character */
    #####: 1410:	    rpms.s->chr = ZWC('^');
    #####: 1411:	    rpms.s->atr = all_atr_on;
    #####: 1412:	    rpms.s++;
    #####: 1413:	    if (rpms.s == rpms.sen) {
        -: 1414:		/* text wrapped */
    #####: 1415:		rpms.s[-1].atr |= all_atr_off;
    #####: 1416:		if (nextline(&rpms, 1))
    #####: 1417:		    break;
        -: 1418:	    }
    #####: 1419:	    rpms.s->chr = (((unsigned int)*t & ~0x80u) > 31) ?
    #####: 1420:		ZWC('?') : (*t | ZWC('@'));
    #####: 1421:	    rpms.s->atr = all_atr_on | all_atr_off;
    #####: 1422:	    rpms.s++;
        -: 1423:	}
        -: 1424:#ifdef MULTIBYTE_SUPPORT
        -: 1425:	else {
        -: 1426:	    /*
        -: 1427:	     * Not printable or zero width.
        -: 1428:	     * Resort to hackery.
        -: 1429:	     */
        -: 1430:	    char dispchars[11];
    #####: 1431:	    char *dispptr = dispchars;
        -: 1432:	    wchar_t wc;
    #####: 1433:	    int started = 0;
        -: 1434:
        -: 1435:#ifdef __STDC_ISO_10646__
    #####: 1436:	    if (ZSH_INVALID_WCHAR_TEST(*t)) {
    #####: 1437:		int c = ZSH_INVALID_WCHAR_TO_INT(*t);
    #####: 1438:		sprintf(dispchars, "<%.02x>", c);
        -: 1439:	    } else
        -: 1440:#endif
    #####: 1441:	    if ((unsigned)*t > 0xffffU) {
    #####: 1442:		sprintf(dispchars, "<%.08x>", (unsigned)*t);
        -: 1443:	    } else {
    #####: 1444:		sprintf(dispchars, "<%.04x>", (unsigned)*t);
        -: 1445:	    }
    #####: 1446:	    while (*dispptr) {
    #####: 1447:		if (mbtowc(&wc, dispptr, 1) == 1 /* paranoia */)
        -: 1448:		{
    #####: 1449:		    rpms.s->chr = wc;
    #####: 1450:		    if (!started)
    #####: 1451:			started = 1;
    #####: 1452:		    rpms.s->atr = all_atr_on;
    #####: 1453:		    rpms.s++;
    #####: 1454:		    if (rpms.s == rpms.sen) {
        -: 1455:			/* text wrapped */
    #####: 1456:			if (started) {
    #####: 1457:			    rpms.s[-1].atr |= all_atr_off;
    #####: 1458:			    started = 0;
        -: 1459:			}
    #####: 1460:			if (nextline(&rpms, 1))
    #####: 1461:			    break;
        -: 1462:		    }
        -: 1463:		}
    #####: 1464:		dispptr++;
        -: 1465:	    }
    #####: 1466:	    if (started)
    #####: 1467:		rpms.s[-1].atr |= all_atr_off;
    #####: 1468:	    if (*dispptr) /* nextline said stop processing */
    #####: 1469:		break;
        -: 1470:	}
        -: 1471:#else
        -: 1472:	else {			/* normal character */
        -: 1473:	    rpms.s->chr = *t;
        -: 1474:	    rpms.s->atr = base_atr_on | base_atr_off;
        -: 1475:	    rpms.s++;
        -: 1476:	}
        -: 1477:#endif
    12423: 1478:	if (rpms.s == rpms.sen) {
        -: 1479:	    /* text wrapped */
    #####: 1480:	    if (nextline(&rpms, 1))
    #####: 1481:		break;
        -: 1482:	}
        -: 1483:    }
        -: 1484:
        -: 1485:/* if we're really on the next line, don't fake it; do everything properly */
     2605: 1486:    if (t == scs &&
     1292: 1487:	(rpms.nvcs = rpms.s - (nbuf[rpms.nvln = rpms.ln])) == winw) {
        -: 1488:	/* text wrapped */
    #####: 1489:	(void)nextline(&rpms, 1);
    #####: 1490:	*rpms.s = zr_zr;
    #####: 1491:	rpms.nvcs = 0;
    #####: 1492:	rpms.nvln++;
        -: 1493:    }
        -: 1494:
     1313: 1495:    if (t != tmpline + tmpll)
    #####: 1496:	more_end = 1;
        -: 1497:
     1313: 1498:    if (statusline) {
        -: 1499:	int outll, outsz;
        -: 1500:	zattr all_atr_on, all_atr_off;
    #####: 1501:	char *statusdup = ztrdup(statusline);
    #####: 1502:	ZLE_STRING_T outputline =
        -: 1503:	    stringaszleline(statusdup, 0, &outll, &outsz, NULL); 
        -: 1504:
    #####: 1505:	all_atr_on = special_atr_on;
    #####: 1506:	all_atr_off = TXT_ATTR_OFF_FROM_ON(all_atr_on);
        -: 1507:
    #####: 1508:	rpms.tosln = rpms.ln + 1;
    #####: 1509:	nbuf[rpms.ln][winw + 1] = zr_zr;	/* text not wrapped */
    #####: 1510:	snextline(&rpms);
    #####: 1511:	u = outputline;
    #####: 1512:	for (; u < outputline + outll; u++) {
        -: 1513:#ifdef MULTIBYTE_SUPPORT
    #####: 1514:	    if (WC_ISPRINT(*u)) {
    #####: 1515:		int width = WCWIDTH(*u);
        -: 1516:		/* Handle wide characters as above */
    #####: 1517:		if (width > rpms.sen - rpms.s) {
        -: 1518:		    do {
    #####: 1519:			*rpms.s++ = zr_sp;
    #####: 1520:		    } while (rpms.s < rpms.sen);
    #####: 1521:		    nbuf[rpms.ln][winw + 1] = zr_nl;
    #####: 1522:		    snextline(&rpms);
        -: 1523:		}
    #####: 1524:		if (width > rpms.sen - rpms.s) {
    #####: 1525:		    rpms.s->chr = ZWC('?');
    #####: 1526:		    rpms.s->atr = all_atr_on | all_atr_off;
    #####: 1527:		    rpms.s++;
        -: 1528:		} else {
    #####: 1529:		    rpms.s->chr = *u;
    #####: 1530:		    rpms.s->atr = 0;
    #####: 1531:		    rpms.s++;
    #####: 1532:		    while (--width > 0) {
    #####: 1533:			rpms.s->chr = WEOF;
    #####: 1534:			rpms.s->atr = 0;
    #####: 1535:			rpms.s++;
        -: 1536:		    }
        -: 1537:		}
        -: 1538:	    }
        -: 1539:	    else
        -: 1540:#endif
    #####: 1541:	    if (ZC_icntrl(*u)) { /* simplified processing in the status line */
    #####: 1542:		rpms.s->chr = ZWC('^');
    #####: 1543:		rpms.s->atr = all_atr_on;
    #####: 1544:		rpms.s++;
    #####: 1545:		if (rpms.s == rpms.sen) {
    #####: 1546:		    nbuf[rpms.ln][winw + 1] = zr_nl;/* text wrapped */
    #####: 1547:		    snextline(&rpms);
        -: 1548:		}
    #####: 1549:		rpms.s->chr = (((unsigned int)*u & ~0x80u) > 31)
    #####: 1550:		    ? ZWC('?') : (*u | ZWC('@'));
    #####: 1551:		rpms.s->atr = all_atr_on | all_atr_off;
    #####: 1552:		rpms.s++;
        -: 1553:	    } else {
    #####: 1554:		rpms.s->chr = *u;
    #####: 1555:		rpms.s->atr = 0;
    #####: 1556:		rpms.s++;
        -: 1557:	    }
    #####: 1558:	    if (rpms.s == rpms.sen) {
    #####: 1559:		nbuf[rpms.ln][winw + 1] = zr_nl;	/* text wrapped */
    #####: 1560:		snextline(&rpms);
        -: 1561:	    }
        -: 1562:	}
    #####: 1563:	if (rpms.s == rpms.sen) {
        -: 1564:	    /*
        -: 1565:	     * I suppose we don't modify nbuf[rpms.ln][winw+1] here
        -: 1566:	     * since we're right at the end?
        -: 1567:	     */
    #####: 1568:	    snextline(&rpms);
        -: 1569:	}
    #####: 1570:	zfree(outputline, outsz);
    #####: 1571:	free(statusdup);
        -: 1572:    }
     1313: 1573:    *rpms.s = zr_zr;
        -: 1574:
        -: 1575:/* insert <.... at end of last line if there is more text past end of screen */
     1313: 1576:    if (more_end) {
        -: 1577:#ifdef MULTIBYTE_SUPPORT
    #####: 1578:	int extra_ellipsis = 0;
        -: 1579:#endif
    #####: 1580:	if (!statusline)
    #####: 1581:	    rpms.tosln = winh;
    #####: 1582:	rpms.s = nbuf[rpms.tosln - 1];
    #####: 1583:	rpms.sen = rpms.s + winw - 7;
    #####: 1584:	for (; rpms.s < rpms.sen; rpms.s++) {
    #####: 1585:	    if (rpms.s->chr == ZWC('\0')) {
    #####: 1586:		ZR_memset(rpms.s, zr_sp, rpms.sen - rpms.s);
        -: 1587:		/* make sure we don't trigger the WEOF test */
    #####: 1588:		rpms.sen->chr = ZWC('\0');
    #####: 1589:		break;
        -: 1590:	    }
        -: 1591:	}
        -: 1592:	/* rpms.s is no longer needed */
        -: 1593:#ifdef MULTIBYTE_SUPPORT
        -: 1594:	/*
        -: 1595:	 * Ensure we don't start overwriting in the middle of a wide
        -: 1596:	 * character.
        -: 1597:	 */
    #####: 1598:	while(rpms.sen > nbuf[rpms.tosln - 1] && rpms.sen->chr == WEOF) {
    #####: 1599:	    extra_ellipsis++;
    #####: 1600:	    rpms.sen--;
        -: 1601:	}
        -: 1602:#endif
    #####: 1603:	ZR_memcpy(rpms.sen, zr_end_ellipsis, ZR_END_ELLIPSIS_SIZE);
        -: 1604:#ifdef MULTIBYTE_SUPPORT
        -: 1605:	/* Extend to the end if we backed off for a wide character */
    #####: 1606:	if (extra_ellipsis) {
    #####: 1607:	    rpms.sen += ZR_END_ELLIPSIS_SIZE;
    #####: 1608:	    ZR_memset(rpms.sen, zr_dt, extra_ellipsis);
        -: 1609:	}
        -: 1610:#endif
    #####: 1611:	nbuf[rpms.tosln - 1][winw] = nbuf[rpms.tosln - 1][winw + 1] = zr_zr;
        -: 1612:    }
        -: 1613:
        -: 1614:/* insert <....> at end of first status line if status is too big */
     1313: 1615:    if (rpms.more_status) {
        -: 1616:#ifdef MULTIBYTE_SUPPORT
    #####: 1617:	int extra_ellipsis = 0;
        -: 1618:#endif
    #####: 1619:	rpms.s = nbuf[rpms.tosln];
    #####: 1620:	rpms.sen = rpms.s + winw - 8;
    #####: 1621:	for (; rpms.s < rpms.sen; rpms.s++) {
    #####: 1622:	    if (rpms.s->chr == ZWC('\0')) {
    #####: 1623:		ZR_memset(rpms.s, zr_sp, rpms.sen - rpms.s);
    #####: 1624:		break;
        -: 1625:	    }
        -: 1626:	}
        -: 1627:	/* rpms.s is no longer needed */
        -: 1628:#ifdef MULTIBYTE_SUPPORT
        -: 1629:	/*
        -: 1630:	 * Ensure we don't start overwriting in the middle of a wide
        -: 1631:	 * character.
        -: 1632:	 */
    #####: 1633:	while(rpms.sen > nbuf[rpms.tosln - 1] && rpms.sen->chr == WEOF) {
    #####: 1634:	    extra_ellipsis++;
    #####: 1635:	    rpms.sen--;
        -: 1636:	}
        -: 1637:#endif
    #####: 1638:	ZR_memcpy(rpms.sen, zr_mid_ellipsis1, ZR_MID_ELLIPSIS1_SIZE);
    #####: 1639:	rpms.sen += ZR_MID_ELLIPSIS1_SIZE;
        -: 1640:#ifdef MULTIBYTE_SUPPORT
        -: 1641:	/* Extend if we backed off for a wide character */
    #####: 1642:	if (extra_ellipsis) {
    #####: 1643:	    ZR_memset(rpms.sen, zr_dt, extra_ellipsis);
    #####: 1644:	    rpms.sen += extra_ellipsis;
        -: 1645:	}
        -: 1646:#endif
    #####: 1647:	ZR_memcpy(rpms.sen, zr_mid_ellipsis2, ZR_MID_ELLIPSIS2_SIZE);
    #####: 1648:	nbuf[rpms.tosln][winw] = nbuf[rpms.tosln][winw + 1] = zr_zr;
        -: 1649:    }
        -: 1650:
     1313: 1651:    nlnct = rpms.ln + 1;
    31512: 1652:    for (iln = nlnct; iln < winh; iln++) {
    30199: 1653:	zfree(nbuf[iln], (winw + 2) * sizeof(**nbuf));
    30199: 1654:	nbuf[iln] = NULL;
        -: 1655:    }
        -: 1656:
        -: 1657:/* determine whether the right-prompt exists and can fit on the screen */
     1313: 1658:    if (!more_start) {
     1313: 1659:	if (trashedzle && opts[TRANSIENTRPROMPT])
    #####: 1660:	    put_rpmpt = 0;
        -: 1661:	else {
     1313: 1662:	    put_rpmpt = rprompth == 1 && rpromptbuf[0] &&
    #####: 1663:		!strchr(rpromptbuf, '\t');
     1313: 1664:	    if (put_rpmpt)
        -: 1665:	    {
    #####: 1666:	      rprompt_off = rprompt_indent;
        -: 1667:	      /* sanity to avoid horrible things happening */
    #####: 1668:	      if (rprompt_off < 0)
    #####: 1669:		rprompt_off = 0;
    #####: 1670:	      put_rpmpt =
    #####: 1671:		(int)ZR_strlen(nbuf[0]) + rpromptw < winw - rprompt_off;
        -: 1672:	    }
        -: 1673:	}
        -: 1674:    } else {
        -: 1675:/* insert >.... on first line if there is more text before start of screen */
    #####: 1676:	ZR_memset(nbuf[0], zr_sp, lpromptw);
    #####: 1677:	t0 = winw - lpromptw;
    #####: 1678:	t0 = t0 > ZR_START_ELLIPSIS_SIZE ? ZR_START_ELLIPSIS_SIZE : t0;
    #####: 1679:	ZR_memcpy(nbuf[0] + lpromptw, zr_start_ellipsis, t0);
    #####: 1680:	ZR_memset(nbuf[0] + lpromptw + t0, zr_sp, winw - t0 - lpromptw);
    #####: 1681:	nbuf[0][winw] = nbuf[0][winw + 1] = zr_zr;
        -: 1682:    }
        -: 1683:
     2626: 1684:    for (iln = 0; iln < nlnct; iln++) {
        -: 1685:	/* if we have more lines than last time, clear the newly-used lines */
     1313: 1686:	if (iln >= olnct)
      131: 1687:	    cleareol = 1;
        -: 1688:
        -: 1689:    /* if old line and new line are different,
        -: 1690:       see if we can insert/delete a line to speed up update */
        -: 1691:
     1313: 1692:	if (!clearf && iln > 0 && iln < olnct - 1 &&
    #####: 1693:	    !(hasam && vcs == winw) &&
    #####: 1694:	    nbuf[iln] && obuf[iln] &&
    #####: 1695:	    ZR_strncmp(obuf[iln], nbuf[iln], 16)) {
    #####: 1696:	    if (tccan(TCDELLINE) && obuf[iln + 1] &&
    #####: 1697:		obuf[iln + 1][0].chr && nbuf[iln] &&
    #####: 1698:		!ZR_strncmp(obuf[iln + 1], nbuf[iln], 16)) {
    #####: 1699:		moveto(iln, 0);
    #####: 1700:		tcout(TCDELLINE);
    #####: 1701:		zfree(obuf[iln], (winw + 2) * sizeof(**obuf));
    #####: 1702:		for (t0 = iln; t0 != olnct; t0++)
    #####: 1703:		    obuf[t0] = obuf[t0 + 1];
    #####: 1704:		obuf[--olnct] = NULL;
        -: 1705:	    }
        -: 1706:	/* don't try to insert a line if olnct = vmaxln (vmaxln is the number
        -: 1707:	   of lines that have been displayed by this routine) so that we don't
        -: 1708:	   go off the end of the screen. */
        -: 1709:
    #####: 1710:	    else if (tccan(TCINSLINE) && olnct < vmaxln && nbuf[iln + 1] &&
    #####: 1711:		     obuf[iln] && !ZR_strncmp(obuf[iln], nbuf[iln + 1], 16)) {
    #####: 1712:		moveto(iln, 0);
    #####: 1713:		tcout(TCINSLINE);
    #####: 1714:		for (t0 = olnct; t0 != iln; t0--)
    #####: 1715:		    obuf[t0] = obuf[t0 - 1];
    #####: 1716:		obuf[iln] = NULL;
    #####: 1717:		olnct++;
        -: 1718:	    }
        -: 1719:	}
        -: 1720:
        -: 1721:    /* update the single line */
     1313: 1722:	refreshline(iln);
        -: 1723:
        -: 1724:    /* output the right-prompt if appropriate */
     1313: 1725:	if (put_rpmpt && !iln && !oput_rpmpt) {
        -: 1726:	    zattr attrchange;
        -: 1727:
    #####: 1728:	    moveto(0, winw - rprompt_off - rpromptw);
    #####: 1729:	    zputs(rpromptbuf, shout);
    #####: 1730:	    if (rprompt_off) {
    #####: 1731:		vcs = winw - rprompt_off;
        -: 1732:	    } else {
    #####: 1733:		zputc(&zr_cr);
    #####: 1734:		vcs = 0;
        -: 1735:	    }
        -: 1736:	/* reset character attributes to that set by the main prompt */
    #####: 1737:	    txtchange = pmpt_attr;
        -: 1738:	    /*
        -: 1739:	     * Keep attributes that have actually changed,
        -: 1740:	     * which are ones off in rpmpt_attr and on in
        -: 1741:	     * pmpt_attr, and vice versa.
        -: 1742:	     */
    #####: 1743:	    attrchange = txtchange &
    #####: 1744:		(TXT_ATTR_OFF_FROM_ON(rpmpt_attr) |
    #####: 1745:		 TXT_ATTR_ON_FROM_OFF(rpmpt_attr));
        -: 1746:	    /*
        -: 1747:	     * Careful in case the colour changed.
        -: 1748:	     */
    #####: 1749:	    if (txtchangeisset(txtchange, TXTFGCOLOUR) &&
    #####: 1750:		(!txtchangeisset(rpmpt_attr, TXTFGCOLOUR) ||
    #####: 1751:		 ((txtchange ^ rpmpt_attr) & TXT_ATTR_FG_COL_MASK)))
        -: 1752:	    {
    #####: 1753:		attrchange |=
    #####: 1754:		    txtchange & (TXTFGCOLOUR | TXT_ATTR_FG_COL_MASK);
        -: 1755:	    }
    #####: 1756:	    if (txtchangeisset(txtchange, TXTBGCOLOUR) &&
    #####: 1757:		(!txtchangeisset(rpmpt_attr, TXTBGCOLOUR) ||
    #####: 1758:		 ((txtchange ^ rpmpt_attr) & TXT_ATTR_BG_COL_MASK)))
        -: 1759:	    {
    #####: 1760:		attrchange |=
    #####: 1761:		    txtchange & (TXTBGCOLOUR | TXT_ATTR_BG_COL_MASK);
        -: 1762:	    }
        -: 1763:	    /*
        -: 1764:	     * Now feed these changes into the usual function,
        -: 1765:	     * if necessary.
        -: 1766:	     */
    #####: 1767:	    if (attrchange)
    #####: 1768:		settextattributes(attrchange);
        -: 1769:	}
        -: 1770:    }
        -: 1771:
        -: 1772:/* if old buffer had extra lines, set them to be cleared and refresh them
        -: 1773:individually */
        -: 1774:
     1313: 1775:    if (olnct > nlnct) {
    #####: 1776:	cleareol = 1;
    #####: 1777:	for (iln = nlnct; iln < olnct; iln++)
    #####: 1778:	    refreshline(iln);
        -: 1779:    }
        -: 1780:
        -: 1781:/* reset character attributes */
     1313: 1782:    if (clearf && postedit) {
        4: 1783:	if ((txtchange = pmpt_attr ? pmpt_attr : rpmpt_attr))
    #####: 1784:	    settextattributes(txtchange);
        -: 1785:    }
     1313: 1786:    clearf = 0;
     1313: 1787:    oput_rpmpt = put_rpmpt;
        -: 1788:
        -: 1789:/* move to the new cursor position */
     1313: 1790:    moveto(rpms.nvln, rpms.nvcs);
        -: 1791:
        -: 1792:/* swap old and new buffers - better than freeing/allocating every time */
     1313: 1793:    bufswap();
        -: 1794:
        -: 1795:/* store current values so we can use them next time */
     1313: 1796:    ovln = rpms.nvln;
     1313: 1797:    olnct = nlnct;
     1313: 1798:    onumscrolls = numscrolls;
     1313: 1799:    if (nlnct > vmaxln)
      131: 1800:	vmaxln = nlnct;
     2495: 1801:singlelineout:
     1313: 1802:    fflush(shout);		/* make sure everything is written out */
        -: 1803:
     1313: 1804:    if (tmpalloced)
    #####: 1805:	zfree(tmpline, tmpll * sizeof(*tmpline));
        -: 1806:
     1313: 1807:    zle_free_highlight();
        -: 1808:
        -: 1809:    /* if we have a new list showing, note it; if part of the list has been
        -: 1810:    overwritten, redisplay it. We have to metafy line back before calling
        -: 1811:    completion code */
     1313: 1812:    if (showinglist == -2 || (showinglist > 0 && showinglist < nlnct)) {
       22: 1813:	if (remetafy) {
        1: 1814:	    metafy_line();
        1: 1815:	    remetafy = 0;
        -: 1816:	}
       22: 1817:	inlist = 1;
       22: 1818:	listmatches();
       22: 1819:	inlist = 0;
       22: 1820:	if (!errflag)
       22: 1821:	    zrefresh();
        -: 1822:    }
     1313: 1823:    if (showinglist == -1)
        4: 1824:	showinglist = nlnct;
        -: 1825:
     1313: 1826:    if (remetafy)
        1: 1827:	metafy_line();
        -: 1828:}
        -: 1829:
        -: 1830:#define tcinscost(X)   (tccan(TCMULTINS) ? tclen[TCMULTINS] : (X)*tclen[TCINS])
        -: 1831:#define tcdelcost(X)   (tccan(TCMULTDEL) ? tclen[TCMULTDEL] : (X)*tclen[TCDEL])
        -: 1832:#define tc_delchars(X)	(void) tcmultout(TCDEL, TCMULTDEL, (X))
        -: 1833:#define tc_inschars(X)	(void) tcmultout(TCINS, TCMULTINS, (X))
        -: 1834:#define tc_upcurs(X)	(void) tcmultout(TCUP, TCMULTUP, (X))
        -: 1835:#define tc_leftcurs(X)	(void) tcmultout(TCLEFT, TCMULTLEFT, (X))
        -: 1836:
        -: 1837:/*
        -: 1838: * Once again, in the multibyte case the arguments must be in the
        -: 1839: * order:  element of old video array, element of new video array.
        -: 1840: */
        -: 1841:static int
    #####: 1842:wpfxlen(const REFRESH_ELEMENT *olds, const REFRESH_ELEMENT *news)
        -: 1843:{
    #####: 1844:    int i = 0;
        -: 1845:
    #####: 1846:    while (olds->chr && ZR_equal(*olds, *news))
    #####: 1847:	olds++, news++, i++;
    #####: 1848:    return i;
        -: 1849:}
        -: 1850:
        -: 1851:/* refresh one line, using whatever speed-up tricks are provided by the tty */
        -: 1852:
        -: 1853:/**/
        -: 1854:static void
     1313: 1855:refreshline(int ln)
        -: 1856:{
        -: 1857:    REFRESH_STRING nl, ol, p1;	/* line buffer pointers			 */
     1313: 1858:    int ccs = 0,		/* temporary count for cursor position	 */
     1313: 1859:	char_ins = 0,		/* number of characters inserted/deleted */
        -: 1860:	col_cleareol,		/* clear to end-of-line from this column */
        -: 1861:	i, j,			/* tmp					 */
        -: 1862:	ins_last,		/* insert pushed last character off line */
        -: 1863:	nllen, ollen,		/* new and old line buffer lengths	 */
        -: 1864:	rnllen;			/* real new line buffer length		 */
        -: 1865:
        -: 1866:/* 0: setup */
     1313: 1867:    nl = nbuf[ln];
     1313: 1868:    rnllen = nllen = nl ? ZR_strlen(nl) : 0;
     1313: 1869:    if (ln < olnct && obuf[ln]) {
     1182: 1870:	ol = obuf[ln];
     1182: 1871:	ollen = ZR_strlen(ol);
        -: 1872:    }
        -: 1873:    else {
        -: 1874:	static REFRESH_ELEMENT nullchr = { ZWC('\0'), 0 };
      131: 1875:	ol = &nullchr;
      131: 1876:	ollen = 0;
        -: 1877:    }
        -: 1878:
        -: 1879:/* optimisation: can easily happen for clearing old lines.  If the terminal has
        -: 1880:   the capability, then this is the easiest way to skip unnecessary stuff */
     1313: 1881:    if (cleareol && !nllen && !(hasam && ln < nlnct - 1)
    #####: 1882:	&& tccan(TCCLEAREOL)) {
    #####: 1883:	moveto(ln, 0);
    #####: 1884:	tcoutclear(TCCLEAREOL);
    #####: 1885:	return;	
        -: 1886:    }
        -: 1887:
        -: 1888:/* 1: pad out the new buffer with spaces to contain _all_ of the characters
        -: 1889:      which need to be written. do this now to allow some pre-processing */
        -: 1890:
     1313: 1891:    if (cleareol 		/* request to clear to end of line */
     1182: 1892:	|| (!nllen && (ln != 0 || !put_rpmpt))	/* no line buffer given */
     1182: 1893:	|| (ln == 0 && (put_rpmpt != oput_rpmpt))) {	/* prompt changed */
      131: 1894:	p1 = zhalloc((winw + 2) * sizeof(*p1));
      131: 1895:	if (nllen)
      131: 1896:	    ZR_memcpy(p1, nl, nllen);
      131: 1897:	ZR_memset(p1 + nllen, zr_sp, winw - nllen);
      131: 1898:	p1[winw] = zr_zr;
      131: 1899:	if (nllen < winw)
      131: 1900:	    p1[winw + 1] = zr_zr;
        -: 1901:	else
    #####: 1902:	    p1[winw + 1] = nl[winw + 1];
      131: 1903:	if (ln && nbuf[ln])
    #####: 1904:	    ZR_memcpy(nl, p1, winw + 2);	/* next time obuf will be up-to-date */
        -: 1905:	else
      131: 1906:	    nl = p1;		/* don't keep the padding for prompt line */
      131: 1907:	nllen = winw;
     1182: 1908:    } else if (ollen > nllen) { /* make new line at least as long as old */
    #####: 1909:	p1 = zhalloc((ollen + 1) * sizeof(*p1));
    #####: 1910:	ZR_memcpy(p1, nl, nllen);
    #####: 1911:	ZR_memset(p1 + nllen, zr_sp, ollen - nllen);
    #####: 1912:	p1[ollen] = zr_zr;
    #####: 1913:	nl = p1;
    #####: 1914:	nllen = ollen;
        -: 1915:    }
        -: 1916:
        -: 1917:/* 2: see if we can clear to end-of-line, and if it's faster, work out where
        -: 1918:   to do it from - we can normally only do so if there's no right-prompt.
        -: 1919:   With automatic margins, we shouldn't do it if there is another line, in
        -: 1920:   case it messes up cut and paste. */
        -: 1921:
     1313: 1922:    if (hasam && ln < nlnct - 1 && rnllen == winw)
    #####: 1923:	col_cleareol = -2;	/* clearing eol would be evil so don't */
        -: 1924:    else {
     1313: 1925:	col_cleareol = -1;
     1313: 1926:	if (tccan(TCCLEAREOL) && (nllen == winw || put_rpmpt != oput_rpmpt)) {
      131: 1927:	    for (i = nllen; i && ZR_equal(zr_sp, nl[i - 1]); i--)
        -: 1928:		;
      131: 1929:	    for (j = ollen; j && ZR_equal(ol[j - 1], zr_sp); j--)
        -: 1930:		;
      262: 1931:	    if ((j > i + tclen[TCCLEAREOL])	/* new buf has enough spaces */
      131: 1932:		|| (nllen == winw && ZR_equal(zr_sp, nl[winw - 1])))
      131: 1933:		col_cleareol = i;
        -: 1934:	}
        -: 1935:    }
        -: 1936:
        -: 1937:/* 2b: first a new trick for automargin niceness - good for cut and paste */
        -: 1938:
     1313: 1939:    if (hasam && vcs == winw) {
    #####: 1940:	if (nbuf[vln] && nbuf[vln][vcs + 1].chr == ZWC('\n')) {
    #####: 1941:	    vln++, vcs = 1;
    #####: 1942:	    if (nbuf[vln]  && nbuf[vln]->chr) {
    #####: 1943:		zputc(nbuf[vln]);
        -: 1944:	    } else
    #####: 1945:		zputc(&zr_sp);  /* I don't think this should happen */
    #####: 1946:	    if (ln == vln) {	/* better safe than sorry */
    #####: 1947:		nl++;
    #####: 1948:		if (ol->chr)
    #####: 1949:		    ol++;
    #####: 1950:		ccs = 1;
        -: 1951:	    }			/* else  hmmm... I wonder what happened */
        -: 1952:	} else {
    #####: 1953:	    vln++, vcs = 0;
    #####: 1954:	    zputc(&zr_nl);
        -: 1955:	}
        -: 1956:    }
     1313: 1957:    ins_last = 0;
        -: 1958:
        -: 1959:/* 2c: if we're on the first line, start checking at the end of the prompt;
        -: 1960:   we shouldn't be doing anything within the prompt */
        -: 1961:
     1313: 1962:    if (ln == 0 && lpromptw) {
     1313: 1963:	i = lpromptw - ccs;
     1313: 1964:	j = ZR_strlen(ol);
     1313: 1965:	nl += i;
     1313: 1966:	ol += (i > j ? j : i);	/* if ol is too short, point it to '\0' */
     1313: 1967:	ccs = lpromptw;
        -: 1968:    }
        -: 1969:
        -: 1970:#ifdef MULTIBYTE_SUPPORT
        -: 1971:    /*
        -: 1972:     * Realign to a real character after any jiggery pokery at
        -: 1973:     * the start of the line.
        -: 1974:     */
     2626: 1975:    while (nl->chr == WEOF) {
    #####: 1976:	nl++, ccs++, vcs++;
    #####: 1977:	if (ol->chr)
    #####: 1978:	    ol++;
        -: 1979:    }
        -: 1980:#endif
        -: 1981:
        -: 1982:/* 3: main display loop - write out the buffer using whatever tricks we can */
        -: 1983:
       66: 1984:    for (;;) {
        -: 1985:	zattr now_off;
        -: 1986:
        -: 1987:#ifdef MULTIBYTE_SUPPORT
     1379: 1988:	if ((!nl->chr || nl->chr != WEOF) && (!ol->chr || ol->chr != WEOF)) {
        -: 1989:#endif
     1379: 1990:	    if (nl->chr && ol->chr && ZR_equal(ol[1], nl[1])) {
        -: 1991:		/* skip only if second chars match */
        -: 1992:#ifdef MULTIBYTE_SUPPORT
      982: 1993:		int ccs_was = ccs;
        -: 1994:#endif
        -: 1995:		/* skip past all matching characters */
      982: 1996:		for (; nl->chr && ZR_equal(*ol, *nl); nl++, ol++, ccs++)
        -: 1997:		    ;
        -: 1998:#ifdef MULTIBYTE_SUPPORT
        -: 1999:		/* Make sure ol and nl are pointing to real characters */
     1964: 2000:		while ((nl->chr == WEOF || ol->chr == WEOF) && ccs > ccs_was) {
    #####: 2001:		    nl--;
    #####: 2002:		    ol--;
    #####: 2003:		    ccs--;
        -: 2004:		}
        -: 2005:#endif
        -: 2006:	    }
        -: 2007:
     1379: 2008:	    if (!nl->chr) {
      198: 2009:		if (ccs == winw && hasam && char_ins > 0 && ins_last
    #####: 2010:		    && vcs != winw) {
    #####: 2011:		    nl--;	   /* we can assume we can go back here */
    #####: 2012:		    moveto(ln, winw - 1);
    #####: 2013:		    zputc(nl);
    #####: 2014:		    vcs++;
    #####: 2015:		    return;	 /* write last character in line */
        -: 2016:		}
      198: 2017:		if ((char_ins <= 0) || (ccs >= winw))    /* written everything */
      198: 2018:		    return;
    #####: 2019:		if (tccan(TCCLEAREOL) && (char_ins >= tclen[TCCLEAREOL])
    #####: 2020:		    && col_cleareol != -2)
        -: 2021:		    /* we've got junk on the right yet to clear */
    #####: 2022:		    col_cleareol = 0;	/* force a clear to end of line */
        -: 2023:	    }
        -: 2024:
     1181: 2025:	    moveto(ln, ccs);	/* move to where we do all output from */
        -: 2026:
        -: 2027:	    /* if we can finish quickly, do so */
     1181: 2028:	    if ((col_cleareol >= 0) && (ccs >= col_cleareol)) {
       67: 2029:		tcoutclear(TCCLEAREOL);
       67: 2030:		return;
        -: 2031:	    }
        -: 2032:
        -: 2033:	    /* we've written out the new but yet to clear rubbish due to inserts */
     1114: 2034:	    if (!nl->chr) {
    #####: 2035:		i = (winw - ccs < char_ins) ? (winw - ccs) : char_ins;
    #####: 2036:		if (tccan(TCDEL) && (tcdelcost(i) <= i + 1))
    #####: 2037:		    tc_delchars(i);
        -: 2038:		else {
    #####: 2039:		    vcs += i;
    #####: 2040:		    while (i-- > 0)
    #####: 2041:			zputc(&zr_sp);
        -: 2042:		}
    #####: 2043:		return;
        -: 2044:	    }
        -: 2045:
        -: 2046:	    /* if we've reached the end of the old buffer, then there are few tricks
        -: 2047:	       we can do, so we just dump out what we must and clear if we can */
     1114: 2048:	    if (!ol->chr) {
     1048: 2049:		i = (col_cleareol >= 0) ? col_cleareol : nllen;
     1048: 2050:		i -= vcs;
     1048: 2051:		if (i < 0) {
        -: 2052:		    /*
        -: 2053:		     * This shouldn't be necessary, but it's better
        -: 2054:		     * than a crash if there's a bug somewhere else,
        -: 2055:		     * so report in debug mode.
        -: 2056:		     */
        -: 2057:		    DPUTS(1, "BUG: badly calculated old line width in refresh");
    #####: 2058:		    i = 0;
        -: 2059:		}
     1048: 2060:		zwrite(nl, i);
     1048: 2061:		vcs += i;
     1048: 2062:		if (col_cleareol >= 0)
       64: 2063:		    tcoutclear(TCCLEAREOL);
     1048: 2064:		return;
        -: 2065:	    }
        -: 2066:
        -: 2067:	    /* inserting & deleting chars: we can if there's no right-prompt */
       66: 2068:	    if ((ln || !put_rpmpt || !oput_rpmpt) 
        -: 2069:#ifdef MULTIBYTE_SUPPORT
       66: 2070:		&& ol->chr != WEOF && nl->chr != WEOF
        -: 2071:#endif
       66: 2072:		&& nl[1].chr && ol[1].chr && !ZR_equal(ol[1], nl[1])) { 
        -: 2073:
        -: 2074:		/* deleting characters - see if we can find a match series that
        -: 2075:		   makes it cheaper to delete intermediate characters
        -: 2076:		   eg. oldline: hifoobar \ hopefully cheaper here to delete two
        -: 2077:		   newline: foobar	 / characters, then we have six matches */
    #####: 2078:		if (tccan(TCDEL)) {
    #####: 2079:		    int first = 1;
    #####: 2080:		    for (i = 1; ol[i].chr; i++) {
    #####: 2081:			if (tcdelcost(i) < wpfxlen(ol + i, nl)) {
        -: 2082:			    /*
        -: 2083:			     * Some terminals will output the current
        -: 2084:			     * attributes into cells added at the end by
        -: 2085:			     * deletions, so turn off text attributes.
        -: 2086:			     */
    #####: 2087:			    if (first) {
    #####: 2088:				clearattributes();
    #####: 2089:				first = 0;
        -: 2090:			    }
    #####: 2091:			    tc_delchars(i);
    #####: 2092:			    ol += i;
    #####: 2093:			    char_ins -= i;
        -: 2094:#ifdef MULTIBYTE_SUPPORT
    #####: 2095:			    while (ol->chr == WEOF) {
    #####: 2096:				ol++;
    #####: 2097:				char_ins--;
        -: 2098:			    }
        -: 2099:#endif
    #####: 2100:			    i = 0;
    #####: 2101:			    break;
        -: 2102:			}
        -: 2103:		    }
    #####: 2104:		    if (!i)
    #####: 2105:			continue;
        -: 2106:		}
        -: 2107:		/*
        -: 2108:		 * inserting characters - characters pushed off the right
        -: 2109:		 * should be annihilated, but we don't do this if we're on the
        -: 2110:		 * last line lest undesired scrolling occurs due to `illegal'
        -: 2111:		 * characters on screen
        -: 2112:		 */ 
    #####: 2113:		if (tccan(TCINS) && (vln != zterm_lines - 1)) {
        -: 2114:		    /* not on last line */
    #####: 2115:		    for (i = 1; nl[i].chr; i++) {
    #####: 2116:			if (tcinscost(i) < wpfxlen(ol, nl + i)) {
    #####: 2117:			    tc_inschars(i);
    #####: 2118:			    zwrite(nl, i);
    #####: 2119:			    nl += i;
        -: 2120:#ifdef MULTIBYTE_SUPPORT
    #####: 2121:			    while (nl->chr == WEOF) {
    #####: 2122:				nl++;
    #####: 2123:				i++;
        -: 2124:			    }
        -: 2125:#endif
    #####: 2126:			    char_ins += i;
    #####: 2127:			    ccs = (vcs += i);
        -: 2128:			    /*
        -: 2129:			     * if we've pushed off the right, truncate
        -: 2130:			     * oldline
        -: 2131:			     */
    #####: 2132:			    for (i = 0; ol[i].chr && i < winw - ccs; i++)
        -: 2133:				;
        -: 2134:#ifdef MULTIBYTE_SUPPORT
    #####: 2135:			    while (ol[i].chr == WEOF)
    #####: 2136:				i++;
    #####: 2137:			    if (i >= winw - ccs) {
        -: 2138:				/*
        -: 2139:				 * Yes, we're over the right.
        -: 2140:				 * Make sure we truncate at the real
        -: 2141:				 * character, not a WEOF added to
        -: 2142:				 * make up the width.
        -: 2143:				 */
    #####: 2144:				while (ol[i-1].chr == WEOF)
    #####: 2145:				    i--;
    #####: 2146:				ol[i] = zr_zr;
    #####: 2147:				ins_last = 1;
        -: 2148:			    }
        -: 2149:#else
        -: 2150:			    if (i >= winw - ccs) {
        -: 2151:				ol[i] = zr_zr;
        -: 2152:				ins_last = 1;
        -: 2153:			    }
        -: 2154:#endif
    #####: 2155:			    i = 0;
    #####: 2156:			    break;
        -: 2157:			}
        -: 2158:		    }
    #####: 2159:		    if (!i)
    #####: 2160:			continue;
        -: 2161:		}
        -: 2162:	    }
        -: 2163:#ifdef MULTIBYTE_SUPPORT
        -: 2164:	}
        -: 2165:#endif
        -: 2166:    /* we can't do any fancy tricks, so just dump the single character
        -: 2167:       and keep on trying */
        -: 2168:#ifdef MULTIBYTE_SUPPORT
        -: 2169:	/*
        -: 2170:	 * in case we were tidying up a funny-width character when we
        -: 2171:	 * reached the end of the new line...
        -: 2172:	 */
       66: 2173:	if (!nl->chr)
    #####: 2174:	    break;
        -: 2175:	do {
        -: 2176:#endif
        -: 2177:	    /*
        -: 2178:	     * If an attribute was on here but isn't any more,
        -: 2179:	     * output the sequence to turn it off.
        -: 2180:	     */
       66: 2181:	    now_off = ol->atr & ~nl->atr & TXT_ATTR_ON_MASK;
       66: 2182:	    if (now_off)
    #####: 2183:		settextattributes(TXT_ATTR_OFF_FROM_ON(now_off));
        -: 2184:
        -: 2185:	    /*
        -: 2186:	     * This is deliberately called if nl->chr is WEOF
        -: 2187:	     * in order to keep text attributes consistent.
        -: 2188:	     * We check for WEOF inside.
        -: 2189:	     */
       66: 2190:	    zputc(nl);
       66: 2191:	    nl++;
       66: 2192:	    if (ol->chr)
       66: 2193:	      ol++;
       66: 2194:	    ccs++, vcs++;
        -: 2195:#ifdef MULTIBYTE_SUPPORT
        -: 2196:	    /*
        -: 2197:	     * Make sure we always overwrite the complete width of
        -: 2198:	     * a character that was there before.
        -: 2199:	     */
      132: 2200:	} while ((ol->chr == WEOF && nl->chr) ||
      132: 2201:		 (nl->chr == WEOF && ol->chr));
        -: 2202:#endif
        -: 2203:    }
        -: 2204:}
        -: 2205:
        -: 2206:/* move the cursor to line ln (relative to the prompt line),
        -: 2207:   absolute column cl; update vln, vcs - video line and column */
        -: 2208:
        -: 2209:/**/
        -: 2210:void
     2566: 2211:moveto(int ln, int cl)
        -: 2212:{
        -: 2213:    const REFRESH_ELEMENT *rep;
        -: 2214:
     2566: 2215:    if (vcs == winw) {
    #####: 2216:	vln++, vcs = 0;
    #####: 2217:	if (!hasam) {
    #####: 2218:	    zputc(&zr_cr);
    #####: 2219:	    zputc(&zr_nl);
        -: 2220:	} else {
    #####: 2221:	    if ((vln < nlnct) && nbuf[vln] && nbuf[vln]->chr)
    #####: 2222:		rep = nbuf[vln];
        -: 2223:	    else
    #####: 2224:		rep = &zr_sp;
    #####: 2225:	    zputc(rep);
    #####: 2226:	    zputc(&zr_cr);
    #####: 2227:	    if ((vln < olnct) && obuf[vln] && obuf[vln]->chr)
    #####: 2228:		*obuf[vln] = *rep;
        -: 2229:	}
        -: 2230:    }
        -: 2231:
     2566: 2232:    if (ln == vln && cl == vcs)
     2404: 2233:	return;
        -: 2234:
        -: 2235:/* move up */
      162: 2236:    if (ln < vln) {
        4: 2237:	tc_upcurs(vln - ln);
        4: 2238:	vln = ln;
        -: 2239:    }
        -: 2240:/* move down; if we might go off the end of the screen, use newlines
        -: 2241:   instead of TCDOWN */
        -: 2242:
      388: 2243:    while (ln > vln) {
       64: 2244:	if (vln < vmaxln - 1) {
    #####: 2245:	    if (ln > vmaxln - 1) {
    #####: 2246:		if (tc_downcurs(vmaxln - 1 - vln))
    #####: 2247:		    vcs = 0;
    #####: 2248:		vln = vmaxln - 1;
        -: 2249:	    } else {
    #####: 2250:		if (tc_downcurs(ln - vln))
    #####: 2251:		    vcs = 0;
    #####: 2252:		vln = ln;
    #####: 2253:		continue;
        -: 2254:	    }
        -: 2255:	}
       64: 2256:	zputc(&zr_cr), vcs = 0; /* safety precaution */
      192: 2257:	while (ln > vln) {
       64: 2258:	    zputc(&zr_nl);
       64: 2259:	    vln++;
        -: 2260:	}
        -: 2261:    }
        -: 2262:
      162: 2263:    if (cl != vcs)
       98: 2264:	singmoveto(cl);
        -: 2265:}
        -: 2266:
        -: 2267:/**/
        -: 2268:mod_export int
       90: 2269:tcmultout(int cap, int multcap, int ct)
        -: 2270:{
       90: 2271:    if (tccan(multcap) && (!tccan(cap) || tclen[multcap] <= tclen[cap] * ct)) {
        4: 2272:	tcoutarg(multcap, ct);
        4: 2273:	return 1;
       86: 2274:    } else if (tccan(cap)) {
      277: 2275:	while (ct--)
      105: 2276:	    tcout(cap);
       86: 2277:	return 1;
        -: 2278:    }
    #####: 2279:    return 0;
        -: 2280:}
        -: 2281:
        -: 2282:/* ct: number of characters to move across */
        -: 2283:/**/
        -: 2284:static void
       16: 2285:tc_rightcurs(int ct)
        -: 2286:{
        -: 2287:    int cl,			/* ``desired'' absolute horizontal position */
       16: 2288:	i = vcs,		/* cursor position after initial movements  */
        -: 2289:	j;
        -: 2290:    REFRESH_STRING t;
        -: 2291:
       16: 2292:    cl = ct + vcs;
        -: 2293:
        -: 2294:/* do a multright if we can - it's the most reliable */
       16: 2295:    if (tccan(TCMULTRIGHT)) {
       16: 2296:	tcoutarg(TCMULTRIGHT, ct);
       16: 2297:	return;
        -: 2298:    }
        -: 2299:
        -: 2300:/* do an absolute horizontal position if we can */
    #####: 2301:    if (tccan(TCHORIZPOS)) {
    #####: 2302:	tcoutarg(TCHORIZPOS, cl);
    #####: 2303:	return;
        -: 2304:    }
        -: 2305:
        -: 2306:/* XXX: should really check "it" in termcap and use / and % */
        -: 2307:/* try tabs if tabs are non destructive and multright is not possible */
    #####: 2308:    if (!oxtabs && tccan(TCNEXTTAB) && ((vcs | 7) < cl)) {
    #####: 2309:	i = (vcs | 7) + 1;
    #####: 2310:	tcout(TCNEXTTAB);
    #####: 2311:	for ( ; i + 8 <= cl; i += 8)
    #####: 2312:	    tcout(TCNEXTTAB);
    #####: 2313:	if ((ct = cl - i) == 0) /* number of chars still to move across */
    #####: 2314:	    return;
        -: 2315:    }
        -: 2316:
        -: 2317:/* otherwise _carefully_ write the contents of the video buffer.
        -: 2318:   if we're anywhere in the prompt, goto the left column and write the whole
        -: 2319:   prompt out.
        -: 2320:
        -: 2321:   If strlen(lpromptbuf) == lpromptw, we can cheat and output
        -: 2322:   the appropriate chunk of the string.  This test relies on the
        -: 2323:   fact that any funny business will always make the length of
        -: 2324:   the string larger than the printing width, so if they're the same
        -: 2325:   we have only ASCII characters or a single-byte extension of ASCII.
        -: 2326:   Unfortunately this trick won't work if there are potentially
        -: 2327:   characters occupying more than one column.  We could flag that
        -: 2328:   this has happened (since it's not that common to have characters
        -: 2329:   wider than one column), but for now it's easier not to use the
        -: 2330:   trick if we are using WCWIDTH() on the prompt.  It's not that
        -: 2331:   common to be editing in the middle of the prompt anyway, I would
        -: 2332:   think.
        -: 2333:   */
    #####: 2334:    if (vln == 0 && i < lpromptw && !(termflags & TERM_SHORT)) {
        -: 2335:#ifndef MULTIBYTE_SUPPORT
        -: 2336:	if ((int)strlen(lpromptbuf) == lpromptw)
        -: 2337:	    fputs(lpromptbuf + i, shout);
        -: 2338:	else 
        -: 2339:#endif
    #####: 2340:	if (tccan(TCRIGHT) && (tclen[TCRIGHT] * ct <= ztrlen(lpromptbuf)))
        -: 2341:	    /* it is cheaper to send TCRIGHT than reprint the whole prompt */
    #####: 2342:	    for (ct = lpromptw - i; ct--; )
    #####: 2343:		tcout(TCRIGHT);
        -: 2344:	else {
    #####: 2345:	    if (i != 0)
    #####: 2346:		zputc(&zr_cr);
    #####: 2347:	    tc_upcurs(lprompth - 1);
    #####: 2348:	    zputs(lpromptbuf, shout);
    #####: 2349:	    if (lpromptwof == winw)
    #####: 2350:		zputs("\n", shout);	/* works with both hasam and !hasam */
        -: 2351:	}
    #####: 2352:	i = lpromptw;
    #####: 2353:	ct = cl - i;
        -: 2354:    }
        -: 2355:
    #####: 2356:    if (nbuf[vln]) {
    #####: 2357:	for (j = 0, t = nbuf[vln]; t->chr && (j < i); j++, t++);
    #####: 2358:	if (j == i)
    #####: 2359:	    for ( ; t->chr && ct; ct--, t++)
    #####: 2360:		zputc(t);
        -: 2361:    }
    #####: 2362:    while (ct--)
    #####: 2363:	zputc(&zr_sp);	/* not my fault your terminal can't go right */
        -: 2364:}
        -: 2365:
        -: 2366:/**/
        -: 2367:mod_export int
    #####: 2368:tc_downcurs(int ct)
        -: 2369:{
    #####: 2370:    int ret = 0;
        -: 2371:
    #####: 2372:    if (ct && !tcmultout(TCDOWN, TCMULTDOWN, ct)) {
    #####: 2373:	while (ct--)
    #####: 2374:	    zputc(&zr_nl);
    #####: 2375:	zputc(&zr_cr), ret = -1;
        -: 2376:    }
    #####: 2377:    return ret;
        -: 2378:}
        -: 2379:
        -: 2380:/*
        -: 2381: * Output a termcap value using a function defined by "zle -T tc".
        -: 2382: * Loosely inspired by subst_string_by_func().
        -: 2383: *
        -: 2384: * cap is the internal index for the capability; it will be looked up
        -: 2385: * in the table and the string passed to the function.
        -: 2386: *
        -: 2387: * arg is eithr an argument to the capability or -1 if there is none;
        -: 2388: * if it is not -1 it will be passed as an additional argument to the
        -: 2389: * function.
        -: 2390: *
        -: 2391: * outc is the output function; currently this is always putshout
        -: 2392: * but in principle it may be used to output to a string.
        -: 2393: */
        -: 2394:
        -: 2395:/**/
        -: 2396:static void
    #####: 2397:tcout_via_func(int cap, int arg, int (*outc)(int))
        -: 2398:{
        -: 2399:    Shfunc tcout_func;
        -: 2400:    int osc, osm, old_incompfunc;
        -: 2401:
    #####: 2402:    osc = sfcontext;
    #####: 2403:    osm = stopmsg;
    #####: 2404:    old_incompfunc = incompfunc;
        -: 2405:
    #####: 2406:    sfcontext = SFC_SUBST;
    #####: 2407:    incompfunc = 0;
        -: 2408:
    #####: 2409:    if ((tcout_func = getshfunc(tcout_func_name))) {
    #####: 2410:	LinkList l = newlinklist();
        -: 2411:	char buf[DIGBUFSIZE], *str;
        -: 2412:
    #####: 2413:	addlinknode(l, tcout_func_name);
    #####: 2414:	addlinknode(l, tccap_get_name(cap));
        -: 2415:
    #####: 2416:	if (arg != -1) {
    #####: 2417:	    sprintf(buf, "%d", arg);
    #####: 2418:	    addlinknode(l, buf);
        -: 2419:	}
        -: 2420:
    #####: 2421:	(void)doshfunc(tcout_func, l, 1);
        -: 2422:
    #####: 2423:	str = getsparam("REPLY");
    #####: 2424:	if (str) {
    #####: 2425:	    while (*str) {
        -: 2426:		int chr;
    #####: 2427:		if (*str == Meta) {
    #####: 2428:		    chr = str[1] ^ 32;
    #####: 2429:		    str += 2;
        -: 2430:		} else {
    #####: 2431:		    chr = *str++;
        -: 2432:		}
    #####: 2433:		(void)outc(chr);
        -: 2434:	    }
        -: 2435:	}
        -: 2436:    }
        -: 2437:
    #####: 2438:    sfcontext = osc;
    #####: 2439:    stopmsg = osm;
    #####: 2440:    incompfunc = old_incompfunc;
    #####: 2441:}
        -: 2442:
        -: 2443:/**/
        -: 2444:mod_export void
      519: 2445:tcout(int cap)
        -: 2446:{
      519: 2447:    if (tcout_func_name) {
    #####: 2448:	tcout_via_func(cap, -1, putshout);
        -: 2449:    } else {
      519: 2450:	tputs(tcstr[cap], 1, putshout);
        -: 2451:    }
      519: 2452:    SELECT_ADD_COST(tclen[cap]);
      519: 2453:}
        -: 2454:
        -: 2455:/**/
        -: 2456:static void
       20: 2457:tcoutarg(int cap, int arg)
        -: 2458:{
        -: 2459:    char *result;
        -: 2460:
       20: 2461:    result = tgoto(tcstr[cap], arg, arg);
       20: 2462:    if (tcout_func_name) {
    #####: 2463:	tcout_via_func(cap, arg, putshout);
        -: 2464:    } else {
       20: 2465:	tputs(result, 1, putshout);
        -: 2466:    }
       20: 2467:    SELECT_ADD_COST(strlen(result));
       20: 2468:}
        -: 2469:
        -: 2470:/**/
        -: 2471:mod_export int
       70: 2472:clearscreen(UNUSED(char **args))
        -: 2473:{
       70: 2474:    tcoutclear(TCCLEARSCREEN);
       70: 2475:    resetneeded = 1;
       70: 2476:    clearflag = 0;
       70: 2477:    reexpandprompt();
       70: 2478:    return 0;
        -: 2479:}
        -: 2480:
        -: 2481:/**/
        -: 2482:mod_export int
    #####: 2483:redisplay(UNUSED(char **args))
        -: 2484:{
    #####: 2485:    moveto(0, 0);
    #####: 2486:    zputc(&zr_cr);		/* extra care */
    #####: 2487:    tc_upcurs(lprompth - 1);
    #####: 2488:    resetneeded = 1;
    #####: 2489:    clearflag = 0;
    #####: 2490:    return 0;
        -: 2491:}
        -: 2492:
        -: 2493:/*
        -: 2494: * Show as much of the line buffer as we can in single line mode.
        -: 2495: * TBD: all termcap effects are turned off in this mode, so
        -: 2496: * there's no point in using character attributes.  We should
        -: 2497: * decide what we're going to do and either remove the handling
        -: 2498: * from here or enable it in tsetcap().
        -: 2499: */
        -: 2500:
        -: 2501:/**/
        -: 2502:static void
    #####: 2503:singlerefresh(ZLE_STRING_T tmpline, int tmpll, int tmpcs)
        -: 2504:{
        -: 2505:    REFRESH_STRING vbuf, vp,	/* video buffer and pointer    */
        -: 2506:	refreshop;	        /* pointer to old video buffer */
        -: 2507:    int t0,			/* tmp			       */
        -: 2508:	vsiz,			/* size of new video buffer    */
    #####: 2509:	nvcs = 0,		/* new video cursor column     */
    #####: 2510:	owinpos = winpos,	/* previous window position    */
    #####: 2511:	owinprompt = winprompt;	/* previous winprompt          */
        -: 2512:#ifdef MULTIBYTE_SUPPORT
        -: 2513:    int width;			/* width of multibyte character */
        -: 2514:#endif
        -: 2515:
    #####: 2516:    nlnct = 1;
        -: 2517:/* generate the new line buffer completely */
    #####: 2518:    for (vsiz = 1 + lpromptw, t0 = 0; t0 != tmpll; t0++) {
    #####: 2519:	if (tmpline[t0] == ZWC('\t'))
    #####: 2520:	    vsiz = (vsiz | 7) + 2;
        -: 2521:#ifdef MULTIBYTE_SUPPORT
    #####: 2522:	else if (WC_ISPRINT(tmpline[t0]) && ((width = WCWIDTH(tmpline[t0])) > 0)) {
    #####: 2523:	    vsiz += width;
    #####: 2524:	    if (isset(COMBININGCHARS) && IS_BASECHAR(tmpline[t0])) {
    #####: 2525:		while (t0 < tmpll-1 && IS_COMBINING(tmpline[t0+1]))
    #####: 2526:		    t0++;
        -: 2527:	    }
        -: 2528:	}
        -: 2529:#endif
    #####: 2530:	else if (ZC_icntrl(tmpline[t0])
        -: 2531:#ifdef MULTIBYTE_SUPPORT
    #####: 2532:		 && (unsigned)tmpline[t0] <= 0xffU
        -: 2533:#endif
        -: 2534:		 )
    #####: 2535:	    vsiz += 2;
        -: 2536:#ifdef MULTIBYTE_SUPPORT
        -: 2537:	else
    #####: 2538:	    vsiz += 10;
        -: 2539:#else
        -: 2540:	else
        -: 2541:	    vsiz++;
        -: 2542:#endif
        -: 2543:    }
    #####: 2544:    vbuf = (REFRESH_STRING)zalloc(vsiz * sizeof(*vbuf));
        -: 2545:
    #####: 2546:    if (tmpcs < 0) {
        -: 2547:#ifdef DEBUG
        -: 2548:	fprintf(stderr, "BUG: negative cursor position\n");
        -: 2549:	fflush(stderr);
        -: 2550:#endif
    #####: 2551:	tmpcs = 0;
        -: 2552:    }
        -: 2553:
        -: 2554:    /* prompt is not directly copied into the video buffer */
    #####: 2555:    ZR_memset(vbuf, zr_sp, lpromptw);
    #####: 2556:    vp = vbuf + lpromptw;
    #####: 2557:    *vp = zr_zr;
        -: 2558:
    #####: 2559:    for (t0 = 0; t0 < tmpll; t0++) {
        -: 2560:	unsigned ireg;
    #####: 2561:	zattr base_atr_on = 0, base_atr_off = 0;
        -: 2562:	zattr all_atr_on, all_atr_off;
        -: 2563:	struct region_highlight *rhp;
        -: 2564:	/*
        -: 2565:	 * Calculate attribute based on region.
        -: 2566:	 */
    #####: 2567:	for (ireg = 0, rhp = region_highlights;
    #####: 2568:	     ireg < n_region_highlights;
    #####: 2569:	     ireg++, rhp++) {
        -: 2570:	    int offset;
    #####: 2571:	    if (rhp->flags & ZRH_PREDISPLAY)
    #####: 2572:		offset = 0;	/* include predisplay in start end */
        -: 2573:	    else
    #####: 2574:		offset = predisplaylen; /* increment over it */
    #####: 2575:	    if (rhp->start + offset <= t0 &&
    #####: 2576:		t0 < rhp->end + offset) {
    #####: 2577:		if (base_atr_on & (TXTFGCOLOUR|TXTBGCOLOUR)) {
        -: 2578:		    /* keep colour already set */
    #####: 2579:		    base_atr_on |= rhp->atr & ~TXT_ATTR_COLOUR_ON_MASK;
        -: 2580:		} else {
        -: 2581:		    /* no colour set yet */
    #####: 2582:		    base_atr_on |= rhp->atr;
        -: 2583:		}
    #####: 2584:		if (t0 == rhp->end + offset - 1 ||
    #####: 2585:		    t0 == tmpll - 1)
    #####: 2586:		    base_atr_off |= TXT_ATTR_OFF_FROM_ON(rhp->atr);
        -: 2587:	    }
        -: 2588:	}
    #####: 2589:	if (special_atr_on & (TXTFGCOLOUR|TXTBGCOLOUR)) {
        -: 2590:	    /* keep colours from special attributes */
    #####: 2591:	    all_atr_on = special_atr_on |
    #####: 2592:		(base_atr_on & ~TXT_ATTR_COLOUR_ON_MASK);
        -: 2593:	} else {
        -: 2594:	    /* keep colours from standard attributes */
    #####: 2595:	    all_atr_on = special_atr_on | base_atr_on;
        -: 2596:	}
    #####: 2597:	all_atr_off = TXT_ATTR_OFF_FROM_ON(all_atr_on);
        -: 2598:
    #####: 2599:	if (tmpline[t0] == ZWC('\t')) {
    #####: 2600:	    for (*vp++ = zr_sp; (vp - vbuf) & 7; )
    #####: 2601:		*vp++ = zr_sp;
    #####: 2602:	    vp[-1].atr |= base_atr_off;
    #####: 2603:	} else if (tmpline[t0] == ZWC('\n')) {
    #####: 2604:	    vp->chr = ZWC('\\');
    #####: 2605:	    vp->atr = all_atr_on;
    #####: 2606:	    vp++;
    #####: 2607:	    vp->chr = ZWC('n');
    #####: 2608:	    vp->atr = all_atr_on | all_atr_off;
    #####: 2609:	    vp++;
        -: 2610:#ifdef MULTIBYTE_SUPPORT
    #####: 2611:	} else if (WC_ISPRINT(tmpline[t0]) &&
    #####: 2612:		   (width = WCWIDTH(tmpline[t0])) > 0) {
        -: 2613:	    int ichars;
    #####: 2614:	    if (isset(COMBININGCHARS) && IS_BASECHAR(tmpline[t0])) {
        -: 2615:		/*
        -: 2616:		 * Look for combining characters.
        -: 2617:		 */
    #####: 2618:		for (ichars = 1; t0 + ichars < tmpll; ichars++) {
    #####: 2619:		    if (!IS_COMBINING(tmpline[t0+ichars]))
        -: 2620:			break;
        -: 2621:		}
        -: 2622:	    } else
    #####: 2623:		ichars = 1;
    #####: 2624:	    vp->atr = base_atr_on | base_atr_off;
    #####: 2625:	    if (ichars > 1)
    #####: 2626:		addmultiword(vp, tmpline+t0, ichars);
        -: 2627:	    else
    #####: 2628:		vp->chr = tmpline[t0];
    #####: 2629:	    vp++;
    #####: 2630:	    while (--width > 0) {
    #####: 2631:		vp->chr = WEOF;
    #####: 2632:		vp->atr = base_atr_on | base_atr_off;
    #####: 2633:		vp++;
        -: 2634:	    }
    #####: 2635:	    t0 += ichars - 1;
        -: 2636:#endif
    #####: 2637:	} else if (ZC_icntrl(tmpline[t0])
        -: 2638:#ifdef MULTIBYTE_SUPPORT
    #####: 2639:		   && (unsigned)tmpline[t0] <= 0xffU
        -: 2640:#endif
    #####: 2641:		   ) {
    #####: 2642:	    ZLE_INT_T t = tmpline[++t0];
        -: 2643:
    #####: 2644:	    vp->chr = ZWC('^');
    #####: 2645:	    vp->atr = all_atr_on;
    #####: 2646:	    vp++;
    #####: 2647:	    vp->chr = (((unsigned int)t & ~0x80u) > 31) ?
    #####: 2648:		ZWC('?') : (t | ZWC('@'));
    #####: 2649:	    vp->atr = all_atr_on | all_atr_off;
    #####: 2650:	    vp++;
        -: 2651:	}
        -: 2652:#ifdef MULTIBYTE_SUPPORT
        -: 2653:	else {
        -: 2654:	    char dispchars[11];
    #####: 2655:	    char *dispptr = dispchars;
        -: 2656:	    wchar_t wc;
    #####: 2657:	    int started = 0;
        -: 2658:
    #####: 2659:	    if ((unsigned)tmpline[t0] > 0xffffU) {
    #####: 2660:		sprintf(dispchars, "<%.08x>", (unsigned)tmpline[t0]);
        -: 2661:	    } else {
    #####: 2662:		sprintf(dispchars, "<%.04x>", (unsigned)tmpline[t0]);
        -: 2663:	    }
    #####: 2664:	    while (*dispptr) {
    #####: 2665:		if (mbtowc(&wc, dispptr, 1) == 1 /* paranoia */) {
    #####: 2666:		    vp->chr = wc;
    #####: 2667:		    if (!started)
    #####: 2668:			started = 1;
    #####: 2669:		    vp->atr = all_atr_on;
    #####: 2670:		    vp++;
        -: 2671:		}
    #####: 2672:		dispptr++;
        -: 2673:	    }
    #####: 2674:	    if (started)
    #####: 2675:		vp[-1].atr |= all_atr_off;
        -: 2676:	}
        -: 2677:#else
        -: 2678:	else {
        -: 2679:	    vp->chr = tmpline[t0];
        -: 2680:	    vp->atr = base_atr_on | base_atr_off;
        -: 2681:	    vp++;
        -: 2682:	}
        -: 2683:#endif
    #####: 2684:	if (t0 == tmpcs)
    #####: 2685:	    nvcs = vp - vbuf - 1;
        -: 2686:    }
    #####: 2687:    if (t0 == tmpcs)
    #####: 2688:	nvcs = vp - vbuf;
    #####: 2689:    *vp = zr_zr;
        -: 2690:
        -: 2691:/* determine which part of the new line buffer we want for the display */
    #####: 2692:    if (winpos == -1)
    #####: 2693:	winpos = 0;
    #####: 2694:    if ((winpos && nvcs < winpos + 1) || (nvcs > winpos + winw - 2)) {
    #####: 2695:	if ((winpos = nvcs - ((winw - hasam) / 2)) < 0)
    #####: 2696:	    winpos = 0;
        -: 2697:    }
    #####: 2698:    if (winpos) {
    #####: 2699:	vbuf[winpos].chr = ZWC('<');	/* line continues to the left */
    #####: 2700:	vbuf[winpos].atr = 0;
        -: 2701:    }
    #####: 2702:    if ((int)ZR_strlen(vbuf + winpos) > (winw - hasam)) {
    #####: 2703:	vbuf[winpos + winw - hasam - 1].chr = ZWC('>');	/* line continues to right */
    #####: 2704:	vbuf[winpos + winw - hasam - 1].atr = 0;
    #####: 2705:	vbuf[winpos + winw - hasam] = zr_zr;
        -: 2706:    }
    #####: 2707:    ZR_strcpy(nbuf[0], vbuf + winpos);
    #####: 2708:    zfree(vbuf, vsiz * sizeof(*vbuf));
    #####: 2709:    nvcs -= winpos;
        -: 2710:
    #####: 2711:    if (winpos < lpromptw) {
        -: 2712:	/* skip start of buffer corresponding to prompt */
    #####: 2713:	winprompt = lpromptw - winpos;
        -: 2714:    } else {
        -: 2715:	/* don't */
    #####: 2716:	winprompt = 0;
        -: 2717:    }
    #####: 2718:    if (winpos != owinpos && winprompt) {
        -: 2719:	char *pptr;
    #####: 2720:	int skipping = 0, skipchars = winpos;
        -: 2721:	/*
        -: 2722:	 * Need to output such part of the left prompt as fits.
        -: 2723:	 * Skip the first winpos characters, outputting
        -: 2724:	 * any characters marked with %{...%}.
        -: 2725:	 */
    #####: 2726:	singmoveto(0);
    #####: 2727:	MB_METACHARINIT();
    #####: 2728:	for (pptr = lpromptbuf; *pptr; ) {
    #####: 2729:	    if (*pptr == Inpar) {
    #####: 2730:		skipping = 1;
    #####: 2731:		pptr++;
    #####: 2732:	    } else if (*pptr == Outpar) {
    #####: 2733:		skipping = 0;
    #####: 2734:		pptr++;
        -: 2735:	    } else {
        -: 2736:		convchar_t cc;
    #####: 2737:		int mblen = MB_METACHARLENCONV(pptr, &cc);
    #####: 2738:		if (skipping || skipchars == 0)
        -: 2739:		{
    #####: 2740:		    while (mblen) {
        -: 2741:#ifdef MULTIBYTE_SUPPORT
    #####: 2742:			if (cc == WEOF)
    #####: 2743:			    fputc('?', shout);
        -: 2744:			else
        -: 2745:#endif
    #####: 2746:			    if (*pptr == Meta) {
    #####: 2747:				mblen--;
    #####: 2748:				fputc(*++pptr ^ 32, shout);
        -: 2749:			    } else {
    #####: 2750:				fputc(*pptr, shout);
        -: 2751:			    }
    #####: 2752:			pptr++;
    #####: 2753:			mblen--;
        -: 2754:		    }
        -: 2755:		} else {
    #####: 2756:		    skipchars--;
    #####: 2757:		    pptr += mblen;
        -: 2758:		}
        -: 2759:	    }
        -: 2760:	}
    #####: 2761:	vcs = winprompt;
        -: 2762:    }
        -: 2763:
        -: 2764:/* display the `visible' portion of the line buffer */
    #####: 2765:    t0 = winprompt;
    #####: 2766:    vp = *nbuf + winprompt;
    #####: 2767:    refreshop = *obuf + winprompt;
        -: 2768:    for (;;) {
        -: 2769:	/*
        -: 2770:	 * Skip past all matching characters, but if there used
        -: 2771:	 * to be a prompt here be careful since all manner of
        -: 2772:	 * nastiness may be around.
        -: 2773:	 */
    #####: 2774:	if (vp - *nbuf >= owinprompt)
    #####: 2775:	    for (; vp->chr && ZR_equal(*refreshop, *vp);
    #####: 2776:		 t0++, vp++, refreshop++)
        -: 2777:		;
        -: 2778:
    #####: 2779:	if (!vp->chr && !refreshop->chr)
    #####: 2780:	    break;
        -: 2781:
    #####: 2782:	singmoveto(t0);		/* move to where we do all output from */
        -: 2783:
    #####: 2784:	if (!refreshop->chr) {
    #####: 2785:	    if ((t0 = ZR_strlen(vp)))
    #####: 2786:		zwrite(vp, t0);
    #####: 2787:	    vcs += t0;
    #####: 2788:	    break;
        -: 2789:	}
    #####: 2790:	if (!vp->chr) {
    #####: 2791:	    if (tccan(TCCLEAREOL))
    #####: 2792:		tcoutclear(TCCLEAREOL);
        -: 2793:	    else
    #####: 2794:		for (; refreshop++->chr; vcs++)
    #####: 2795:		    zputc(&zr_sp);
    #####: 2796:	    break;
        -: 2797:	}
    #####: 2798:	zputc(vp);
    #####: 2799:	vcs++, t0++;
    #####: 2800:	vp++, refreshop++;
        -: 2801:    }
        -: 2802:/* move to the new cursor position */
    #####: 2803:    singmoveto(nvcs);
        -: 2804:
    #####: 2805:    bufswap();
    #####: 2806:}
        -: 2807:
        -: 2808:/**/
        -: 2809:static void
       98: 2810:singmoveto(int pos)
        -: 2811:{
       98: 2812:    if (pos == vcs)
    #####: 2813:	return;
        -: 2814:
        -: 2815:/* choose cheapest movements for ttys without multiple movement capabilities -
        -: 2816:   do this now because it's easier (to code) */
        -: 2817:
       98: 2818:    if ((!tccan(TCMULTLEFT) || pos == 0) && (pos <= vcs / 2)) {
    #####: 2819:	zputc(&zr_cr);
    #####: 2820:	vcs = 0;
        -: 2821:    }
        -: 2822:
       98: 2823:    if (pos < vcs)
       82: 2824:	tc_leftcurs(vcs - pos);
       16: 2825:    else if (pos > vcs)
       16: 2826:	tc_rightcurs(pos - vcs);
        -: 2827:
       98: 2828:    vcs = pos;
        -: 2829:}
        -: 2830:
        -: 2831:/* Provided for loading the module in a modular fashion */
        -: 2832:
        -: 2833:/**/
        -: 2834:void
        1: 2835:zle_refresh_boot(void)
        -: 2836:{
        1: 2837:}
        -: 2838:
        -: 2839:/* Provided for unloading the module in a modular fashion */
        -: 2840:
        -: 2841:/**/
        -: 2842:void
    #####: 2843:zle_refresh_finish(void)
        -: 2844:{
    #####: 2845:    freevideo();
        -: 2846:
    #####: 2847:    if (region_highlights)
        -: 2848:    {
    #####: 2849:	free_region_highlights_memos();
    #####: 2850:	zfree(region_highlights,
        -: 2851:	      sizeof(struct region_highlight) * n_region_highlights);
    #####: 2852:	region_highlights = NULL;
    #####: 2853:	n_region_highlights = 0;
        -: 2854:    }
    #####: 2855:}
