        -:    0:Source:lex.c
        -:    0:Programs:1
        -:    1:/*
        -:    2: * lex.c - lexical analysis
        -:    3: *
        -:    4: * This file is part of zsh, the Z shell.
        -:    5: *
        -:    6: * Copyright (c) 1992-1997 Paul Falstad
        -:    7: * All rights reserved.
        -:    8: *
        -:    9: * Permission is hereby granted, without written agreement and without
        -:   10: * license or royalty fees, to use, copy, modify, and distribute this
        -:   11: * software and to distribute modified versions of this software for any
        -:   12: * purpose, provided that the above copyright notice and the following
        -:   13: * two paragraphs appear in all copies of this software.
        -:   14: *
        -:   15: * In no event shall Paul Falstad or the Zsh Development Group be liable
        -:   16: * to any party for direct, indirect, special, incidental, or consequential
        -:   17: * damages arising out of the use of this software and its documentation,
        -:   18: * even if Paul Falstad and the Zsh Development Group have been advised of
        -:   19: * the possibility of such damage.
        -:   20: *
        -:   21: * Paul Falstad and the Zsh Development Group specifically disclaim any
        -:   22: * warranties, including, but not limited to, the implied warranties of
        -:   23: * merchantability and fitness for a particular purpose.  The software
        -:   24: * provided hereunder is on an "as is" basis, and Paul Falstad and the
        -:   25: * Zsh Development Group have no obligation to provide maintenance,
        -:   26: * support, updates, enhancements, or modifications.
        -:   27: *
        -:   28: */
        -:   29:
        -:   30:#include "zsh.mdh"
        -:   31:#include "lex.pro"
        -:   32:
        -:   33:#define LEX_HEAP_SIZE (32)
        -:   34:
        -:   35:/* tokens */
        -:   36:
        -:   37:/**/
        -:   38:mod_export char ztokens[] = "#$^*(())$=|{}[]`<>>?~`,-!'\"\\\\";
        -:   39:
        -:   40:/* parts of the current token */
        -:   41:
        -:   42:/**/
        -:   43:char *zshlextext;
        -:   44:/**/
        -:   45:mod_export char *tokstr;
        -:   46:/**/
        -:   47:mod_export enum lextok tok;
        -:   48:/**/
        -:   49:mod_export int tokfd;
        -:   50:
        -:   51:/*
        -:   52: * Line number at which the first character of a token was found.
        -:   53: * We always set this in gettok(), which is always called from
        -:   54: * zshlex() unless we have reached an error.  So it is always
        -:   55: * valid when parsing.  It is not useful during execution
        -:   56: * of the parsed structure.
        -:   57: */
        -:   58:
        -:   59:/**/
        -:   60:zlong toklineno;
        -:   61:
        -:   62:/* lexical analyzer error flag */
        -:   63: 
        -:   64:/**/
        -:   65:mod_export int lexstop;
        -:   66:
        -:   67:/* if != 0, this is the first line of the command */
        -:   68: 
        -:   69:/**/
        -:   70:mod_export int isfirstln;
        -:   71: 
        -:   72:/* if != 0, this is the first char of the command (not including white space) */
        -:   73: 
        -:   74:/**/
        -:   75:int isfirstch;
        -:   76:
        -:   77:/* flag that an alias should be expanded after expansion ending in space */
        -:   78:
        -:   79:/**/
        -:   80:int inalmore;
        -:   81:
        -:   82:/*
        -:   83: * Don't do spelling correction.
        -:   84: * Bit 1 is only valid for the current word.  It's
        -:   85: * set when we detect a lookahead that stops the word from
        -:   86: * needing correction.
        -:   87: */
        -:   88: 
        -:   89:/**/
        -:   90:int nocorrect;
        -:   91:
        -:   92:/*
        -:   93: * TBD: the following exported variables are part of the non-interface
        -:   94: * with ZLE for completion.  They are poorly named and the whole
        -:   95: * scheme is incredibly brittle.  One piece of robustness is applied:
        -:   96: * the variables are only set if LEXFLAGS_ZLE is set.  Improvements
        -:   97: * should therefore concentrate on areas with this flag set.
        -:   98: *
        -:   99: * Cursor position and line length in zle when the line is
        -:  100: * metafied for access from the main shell.
        -:  101: */
        -:  102:
        -:  103:/**/
        -:  104:mod_export int zlemetacs, zlemetall;
        -:  105:
        -:  106:/* inwhat says what exactly we are in     *
        -:  107: * (its value is one of the IN_* things). */
        -:  108:
        -:  109:/**/
        -:  110:mod_export int inwhat;
        -:  111:
        -:  112:/* 1 if x added to complete in a blank between words */
        -:  113:
        -:  114:/**/
        -:  115:mod_export int addedx;
        -:  116:
        -:  117:/* wb and we hold the beginning/end position of the word we are completing. */
        -:  118:
        -:  119:/**/
        -:  120:mod_export int wb, we;
        -:  121:
        -:  122:/**/
        -:  123:mod_export int wordbeg;
        -:  124:
        -:  125:/**/
        -:  126:mod_export int parbegin;
        -:  127:
        -:  128:/**/
        -:  129:mod_export int parend;
        -:  130:
        -:  131:
        -:  132:/* 1 if aliases should not be expanded */
        -:  133:
        -:  134:/**/
        -:  135:mod_export int noaliases;
        -:  136:
        -:  137:/*
        -:  138: * If non-zero, we are parsing a line sent to use by the editor, or some
        -:  139: * other string that's not part of standard command input (e.g. eval is
        -:  140: * part of normal command input).
        -:  141: *
        -:  142: * Set of bits from LEXFLAGS_*.
        -:  143: *
        -:  144: * Note that although it is passed into the lexer as an input, the
        -:  145: * lexer can set it to zero after finding the word it's searching for.
        -:  146: * This only happens if the line being parsed actually does come from
        -:  147: * ZLE, and hence the bit LEXFLAGS_ZLE is set.
        -:  148: */
        -:  149:
        -:  150:/**/
        -:  151:mod_export int lexflags;
        -:  152:
        -:  153:/* don't recognize comments */
        -:  154:
        -:  155:/**/
        -:  156:mod_export int nocomments;
        -:  157:
        -:  158:/* add raw input characters while parsing command substitution */
        -:  159:
        -:  160:/**/
        -:  161:int lex_add_raw;
        -:  162:
        -:  163:/* variables associated with the above */
        -:  164:
        -:  165:static char *tokstr_raw;
        -:  166:static struct lexbufstate lexbuf_raw;
        -:  167:
        -:  168:/* text of punctuation tokens */
        -:  169:
        -:  170:/**/
        -:  171:mod_export char *tokstrings[WHILE + 1] = {
        -:  172:    NULL,	/* NULLTOK	  0  */
        -:  173:    ";",	/* SEPER	     */
        -:  174:    "\\n",	/* NEWLIN	     */
        -:  175:    ";",	/* SEMI		     */
        -:  176:    ";;",	/* DSEMI	     */
        -:  177:    "&",	/* AMPER	  5  */
        -:  178:    "(",	/* INPAR	     */
        -:  179:    ")",	/* OUTPAR	     */
        -:  180:    "||",	/* DBAR		     */
        -:  181:    "&&",	/* DAMPER	     */
        -:  182:    ">",	/* OUTANG	  10 */
        -:  183:    ">|",	/* OUTANGBANG	     */
        -:  184:    ">>",	/* DOUTANG	     */
        -:  185:    ">>|",	/* DOUTANGBANG	     */
        -:  186:    "<",	/* INANG	     */
        -:  187:    "<>",	/* INOUTANG	  15 */
        -:  188:    "<<",	/* DINANG	     */
        -:  189:    "<<-",	/* DINANGDASH	     */
        -:  190:    "<&",	/* INANGAMP	     */
        -:  191:    ">&",	/* OUTANGAMP	     */
        -:  192:    "&>",	/* AMPOUTANG	  20 */
        -:  193:    "&>|",	/* OUTANGAMPBANG     */
        -:  194:    ">>&",	/* DOUTANGAMP	     */
        -:  195:    ">>&|",	/* DOUTANGAMPBANG    */
        -:  196:    "<<<",	/* TRINANG	     */
        -:  197:    "|",	/* BAR		  25 */
        -:  198:    "|&",	/* BARAMP	     */
        -:  199:    "()",	/* INOUTPAR	     */
        -:  200:    "((",	/* DINPAR	     */
        -:  201:    "))",	/* DOUTPAR	     */
        -:  202:    "&|",	/* AMPERBANG	  30 */
        -:  203:    ";&",	/* SEMIAMP	     */
        -:  204:    ";|",	/* SEMIBAR	     */
        -:  205:};
        -:  206:
        -:  207:/* lexical state */
        -:  208:
        -:  209:static int dbparens;
        -:  210:static struct lexbufstate lexbuf = { NULL, 256, 0 };
        -:  211:
        -:  212:/* save lexical context */
        -:  213:
        -:  214:/**/
        -:  215:void
     5783:  216:lex_context_save(struct lex_stack *ls, int toplevel)
        -:  217:{
        -:  218:    (void)toplevel;
        -:  219:
     5783:  220:    ls->dbparens = dbparens;
     5783:  221:    ls->isfirstln = isfirstln;
     5783:  222:    ls->isfirstch = isfirstch;
     5783:  223:    ls->lexflags = lexflags;
        -:  224:
     5783:  225:    ls->tok = tok;
     5783:  226:    ls->tokstr = tokstr;
     5783:  227:    ls->zshlextext = zshlextext;
     5783:  228:    ls->lexbuf = lexbuf;
     5783:  229:    ls->lex_add_raw = lex_add_raw;
     5783:  230:    ls->tokstr_raw = tokstr_raw;
     5783:  231:    ls->lexbuf_raw = lexbuf_raw;
     5783:  232:    ls->lexstop = lexstop;
     5783:  233:    ls->toklineno = toklineno;
        -:  234:
     5783:  235:    tokstr = zshlextext = lexbuf.ptr = NULL;
     5783:  236:    lexbuf.siz = 256;
     5783:  237:    tokstr_raw = lexbuf_raw.ptr = NULL;
     5783:  238:    lexbuf_raw.siz = lexbuf_raw.len = lex_add_raw = 0;
     5783:  239:}
        -:  240:
        -:  241:/* restore lexical context */
        -:  242:
        -:  243:/**/
        -:  244:mod_export void
     5783:  245:lex_context_restore(const struct lex_stack *ls, int toplevel)
        -:  246:{
        -:  247:    (void)toplevel;
        -:  248:
     5783:  249:    dbparens = ls->dbparens;
     5783:  250:    isfirstln = ls->isfirstln;
     5783:  251:    isfirstch = ls->isfirstch;
     5783:  252:    lexflags = ls->lexflags;
     5783:  253:    tok = ls->tok;
     5783:  254:    tokstr = ls->tokstr;
     5783:  255:    zshlextext = ls->zshlextext;
     5783:  256:    lexbuf = ls->lexbuf;
     5783:  257:    lex_add_raw = ls->lex_add_raw;
     5783:  258:    tokstr_raw = ls->tokstr_raw;
     5783:  259:    lexbuf_raw = ls->lexbuf_raw;
     5783:  260:    lexstop = ls->lexstop;
     5783:  261:    toklineno = ls->toklineno;
     5783:  262:}
        -:  263:
        -:  264:/**/
        -:  265:void
    10025:  266:zshlex(void)
        -:  267:{
    10025:  268:    if (tok == LEXERR)
    #####:  269:	return;
        -:  270:    do {
    10027:  271:	if (inrepeat_)
       31:  272:	    ++inrepeat_;
    10027:  273:	if (inrepeat_ == 3 && (isset(SHORTLOOPS) || isset(SHORTREPEAT)))
        7:  274:	    incmdpos = 1;
    10027:  275:	tok = gettok();
    10027:  276:    } while (tok != ENDINPUT && exalias());
    10025:  277:    nocorrect &= 1;
    10025:  278:    if (tok == NEWLIN || tok == ENDINPUT) {
     5488:  279:	while (hdocs) {
    #####:  280:	    struct heredocs *next = hdocs->next;
        -:  281:	    char *doc, *munged_term;
        -:  282:
    #####:  283:	    hwbegin(0);
    #####:  284:	    cmdpush(hdocs->type == REDIR_HEREDOC ? CS_HEREDOC : CS_HEREDOCD);
    #####:  285:	    munged_term = dupstring(hdocs->str);
    #####:  286:	    STOPHIST
    #####:  287:	    doc = gethere(&munged_term, hdocs->type);
    #####:  288:	    ALLOWHIST
    #####:  289:	    cmdpop();
    #####:  290:	    hwend();
    #####:  291:	    if (!doc) {
    #####:  292:		zerr("here document too large");
    #####:  293:		while (hdocs) {
    #####:  294:		    next = hdocs->next;
    #####:  295:		    zfree(hdocs, sizeof(struct heredocs));
    #####:  296:		    hdocs = next;
        -:  297:		}
    #####:  298:		tok = LEXERR;
    #####:  299:		break;
        -:  300:	    }
    #####:  301:	    setheredoc(hdocs->pc, REDIR_HERESTR, doc, hdocs->str,
        -:  302:		       munged_term);
    #####:  303:	    zfree(hdocs, sizeof(struct heredocs));
    #####:  304:	    hdocs = next;
        -:  305:	}
        -:  306:    }
    10025:  307:    if (tok != NEWLIN)
     8506:  308:	isnewlin = 0;
        -:  309:    else
     1519:  310:	isnewlin = (inbufct) ? -1 : 1;
    10025:  311:    if (tok == SEMI || (tok == NEWLIN && !(lexflags & LEXFLAGS_NEWLINE)))
     1623:  312:	tok = SEPER;
        -:  313:}
        -:  314:
        -:  315:/**/
        -:  316:mod_export void
      190:  317:ctxtlex(void)
        -:  318:{
        -:  319:    static int oldpos;
        -:  320:
      190:  321:    zshlex();
      190:  322:    switch (tok) {
       19:  323:    case SEPER:
        -:  324:    case NEWLIN:
        -:  325:    case SEMI:
        -:  326:    case DSEMI:
        -:  327:    case SEMIAMP:
        -:  328:    case SEMIBAR:
        -:  329:    case AMPER:
        -:  330:    case AMPERBANG:
        -:  331:    case INPAR:
        -:  332:    case INBRACE:
        -:  333:    case DBAR:
        -:  334:    case DAMPER:
        -:  335:    case BAR:
        -:  336:    case BARAMP:
        -:  337:    case INOUTPAR:
        -:  338:    case DOLOOP:
        -:  339:    case THEN:
        -:  340:    case ELIF:
        -:  341:    case ELSE:
        -:  342:    case DOUTBRACK:
       19:  343:	incmdpos = 1;
       19:  344:	break;
      132:  345:    case STRING:
        -:  346:    case TYPESET:
        -:  347: /* case ENVSTRING: */
        -:  348:    case ENVARRAY:
        -:  349:    case OUTPAR:
        -:  350:    case CASE:
        -:  351:    case DINBRACK:
      132:  352:	incmdpos = 0;
      132:  353:	break;
        -:  354:
       39:  355:    default:
        -:  356:	/* nothing to do, keep compiler happy */
       39:  357:	break;
        -:  358:    }
      190:  359:    if (tok != DINPAR)
      186:  360:	infor = tok == FOR ? 2 : 0;
      190:  361:    if (IS_REDIROP(tok) || tok == FOR || tok == FOREACH || tok == SELECT) {
        5:  362:	inredir = 1;
        5:  363:	oldpos = incmdpos;
        5:  364:	incmdpos = 0;
      185:  365:    } else if (inredir) {
        5:  366:	incmdpos = oldpos;
        5:  367:	inredir = 0;
        -:  368:    }
      190:  369:}
        -:  370:
        -:  371:#define LX1_BKSLASH 0
        -:  372:#define LX1_COMMENT 1
        -:  373:#define LX1_NEWLIN 2
        -:  374:#define LX1_SEMI 3
        -:  375:#define LX1_AMPER 5
        -:  376:#define LX1_BAR 6
        -:  377:#define LX1_INPAR 7
        -:  378:#define LX1_OUTPAR 8
        -:  379:#define LX1_INANG 13
        -:  380:#define LX1_OUTANG 14
        -:  381:#define LX1_OTHER 15
        -:  382:
        -:  383:#define LX2_BREAK 0
        -:  384:#define LX2_OUTPAR 1
        -:  385:#define LX2_BAR 2
        -:  386:#define LX2_STRING 3
        -:  387:#define LX2_INBRACK 4
        -:  388:#define LX2_OUTBRACK 5
        -:  389:#define LX2_TILDE 6
        -:  390:#define LX2_INPAR 7
        -:  391:#define LX2_INBRACE 8
        -:  392:#define LX2_OUTBRACE 9
        -:  393:#define LX2_OUTANG 10
        -:  394:#define LX2_INANG 11
        -:  395:#define LX2_EQUALS 12
        -:  396:#define LX2_BKSLASH 13
        -:  397:#define LX2_QUOTE 14
        -:  398:#define LX2_DQUOTE 15
        -:  399:#define LX2_BQUOTE 16
        -:  400:#define LX2_COMMA 17
        -:  401:#define LX2_DASH 18
        -:  402:#define LX2_BANG 19
        -:  403:#define LX2_OTHER 20
        -:  404:#define LX2_META 21
        -:  405:
        -:  406:static unsigned char lexact1[256], lexact2[256], lextok2[256];
        -:  407:
        -:  408:/**/
        -:  409:void
       17:  410:initlextabs(void)
        -:  411:{
        -:  412:    int t0;
        -:  413:    static char *lx1 = "\\q\n;!&|(){}[]<>";
        -:  414:    static char *lx2 = ";)|$[]~({}><=\\\'\"`,-!";
        -:  415:
     4369:  416:    for (t0 = 0; t0 != 256; t0++) {
     4352:  417:       lexact1[t0] = LX1_OTHER;
     4352:  418:	lexact2[t0] = LX2_OTHER;
     4352:  419:	lextok2[t0] = t0;
        -:  420:    }
      272:  421:    for (t0 = 0; lx1[t0]; t0++)
      255:  422:	lexact1[(int)lx1[t0]] = t0;
      357:  423:    for (t0 = 0; lx2[t0]; t0++)
      340:  424:	lexact2[(int)lx2[t0]] = t0;
       17:  425:    lexact2['&'] = LX2_BREAK;
       17:  426:    lexact2[STOUC(Meta)] = LX2_META;
       17:  427:    lextok2['*'] = Star;
       17:  428:    lextok2['?'] = Quest;
       17:  429:    lextok2['{'] = Inbrace;
       17:  430:    lextok2['['] = Inbrack;
       17:  431:    lextok2['$'] = String;
       17:  432:    lextok2['~'] = Tilde;
       17:  433:    lextok2['#'] = Pound;
       17:  434:    lextok2['^'] = Hat;
       17:  435:}
        -:  436:
        -:  437:/* initialize lexical state */
        -:  438:
        -:  439:/**/
        -:  440:void
     5920:  441:lexinit(void)
        -:  442:{
     5920:  443:    nocorrect = dbparens = lexstop = 0;
     5920:  444:    tok = ENDINPUT;
     5920:  445:}
        -:  446:
        -:  447:/* add a char to the string buffer */
        -:  448:
        -:  449:/**/
        -:  450:void
    54697:  451:add(int c)
        -:  452:{
    54697:  453:    *lexbuf.ptr++ = c;
    54697:  454:    if (lexbuf.siz == ++lexbuf.len) {
      159:  455:	int newbsiz = lexbuf.siz * 2;
        -:  456:
      159:  457:	if (newbsiz > inbufct && inbufct > lexbuf.siz)
       17:  458:	    newbsiz = inbufct;
        -:  459:
      159:  460:	tokstr = (char *)hrealloc(tokstr, lexbuf.siz, newbsiz);
      159:  461:	lexbuf.ptr = tokstr + lexbuf.len;
        -:  462:	/* len == bsiz, so bptr is at the start of newly allocated memory */
      159:  463:	memset(lexbuf.ptr, 0, newbsiz - lexbuf.siz);
      159:  464:	lexbuf.siz = newbsiz;
        -:  465:    }
    54697:  466:}
        -:  467:
        -:  468:#define SETPARBEGIN {							\
        -:  469:	if ((lexflags & LEXFLAGS_ZLE) && !(inbufflags & INP_ALIAS) &&	\
        -:  470:	    zlemetacs >= zlemetall+1-inbufct)				\
        -:  471:	    parbegin = inbufct;		      \
        -:  472:    }
        -:  473:#define SETPAREND {						      \
        -:  474:	if ((lexflags & LEXFLAGS_ZLE) && !(inbufflags & INP_ALIAS) && \
        -:  475:	    parbegin != -1 && parend == -1) {			      \
        -:  476:	    if (zlemetacs >= zlemetall + 1 - inbufct)		      \
        -:  477:		parbegin = -1;					      \
        -:  478:	    else						      \
        -:  479:		parend = inbufct;				      \
        -:  480:	}							      \
        -:  481:    }
        -:  482:
        -:  483:enum {
        -:  484:    CMD_OR_MATH_CMD,
        -:  485:    CMD_OR_MATH_MATH,
        -:  486:    CMD_OR_MATH_ERR
        -:  487:};
        -:  488:
        -:  489:/*
        -:  490: * Return one of the above.  If it couldn't be
        -:  491: * parsed as math, but there was no gross error, it's a command.
        -:  492: */
        -:  493:
        -:  494:static int
       59:  495:cmd_or_math(int cs_type)
        -:  496:{
       59:  497:    int oldlen = lexbuf.len;
        -:  498:    int c;
       59:  499:    int oinflags = inbufflags;
        -:  500:
       59:  501:    cmdpush(cs_type);
       59:  502:    inbufflags |= INP_APPEND;
       59:  503:    c = dquote_parse(')', 0);
       59:  504:    if (!(oinflags & INP_APPEND))
       59:  505:	inbufflags &= ~INP_APPEND;
       59:  506:    cmdpop();
       59:  507:    *lexbuf.ptr = '\0';
       59:  508:    if (!c) {
        -:  509:	/* Successfully parsed, see if it was math */
       58:  510:	c = hgetc();
       58:  511:	if (c == ')')
       56:  512:	    return CMD_OR_MATH_MATH; /* yes */
        2:  513:	hungetc(c);
        2:  514:	lexstop = 0;
        2:  515:	c = ')';
        1:  516:    } else if (lexstop) {
        -:  517:	/* we haven't got anything to unget */
        1:  518:	return CMD_OR_MATH_ERR;
        -:  519:    }
        -:  520:    /* else unsuccessful: unget the whole thing */
        2:  521:    hungetc(c);
        2:  522:    lexstop = 0;
       22:  523:    while (lexbuf.len > oldlen && !(errflag & ERRFLAG_ERROR)) {
       18:  524:	lexbuf.len--;
       36:  525:	hungetc(itok(*--lexbuf.ptr) ?
       18:  526:		ztokens[*lexbuf.ptr - Pound] : *lexbuf.ptr);
        -:  527:    }
        2:  528:    if (errflag)
    #####:  529:	return CMD_OR_MATH_ERR;
        2:  530:    hungetc('(');
        2:  531:    return errflag ? CMD_OR_MATH_ERR : CMD_OR_MATH_CMD;
        -:  532:}
        -:  533:
        -:  534:
        -:  535:/*
        -:  536: * Parse either a $(( ... )) or a $(...)
        -:  537: * Return the same as cmd_or_math().
        -:  538: */
        -:  539:static int
       80:  540:cmd_or_math_sub(void)
        -:  541:{
       80:  542:    int c = hgetc(), ret;
        -:  543:
       80:  544:    if (c == '\\') {
        2:  545:	c = hgetc();
        2:  546:	if (c != '\n') {
        1:  547:	    hungetc(c);
        1:  548:	    hungetc('\\');
        1:  549:	    lexstop = 0;
        1:  550:	    return skipcomm() ? CMD_OR_MATH_ERR : CMD_OR_MATH_CMD;
        -:  551:	}
        1:  552:	c = hgetc();
        -:  553:    }
        -:  554:
       79:  555:    if (c == '(') {
       34:  556:	int lexpos = (int)(lexbuf.ptr - tokstr);
       34:  557:	add(Inpar);
       34:  558:	add('(');
       34:  559:	if ((ret = cmd_or_math(CS_MATHSUBST)) == CMD_OR_MATH_MATH) {
       33:  560:	    tokstr[lexpos] = Inparmath;
       33:  561:	    add(')');
       33:  562:	    return CMD_OR_MATH_MATH;
        -:  563:	}
        1:  564:	if (ret == CMD_OR_MATH_ERR)
    #####:  565:	    return CMD_OR_MATH_ERR;
        1:  566:	lexbuf.ptr -= 2;
        1:  567:	lexbuf.len -= 2;
        -:  568:    } else {
       45:  569:	hungetc(c);
       45:  570:	lexstop = 0;
        -:  571:    }
       46:  572:    return skipcomm() ? CMD_OR_MATH_ERR : CMD_OR_MATH_CMD;
        -:  573:}
        -:  574:
        -:  575:/* Check whether we're looking at valid numeric globbing syntax      *
        -:  576: * (/\<[0-9]*-[0-9]*\>/).  Call pointing just after the opening "<". *
        -:  577: * Leaves the input in the same place, returning 0 or 1.             */
        -:  578:
        -:  579:/**/
        -:  580:static int
      476:  581:isnumglob(void)
        -:  582:{
      476:  583:    int c, ec = '-', ret = 0;
      476:  584:    int tbs = 256, n = 0;
      476:  585:    char *tbuf = (char *)zalloc(tbs);
        -:  586:
        -:  587:    while(1) {
      484:  588:	c = hgetc();
      480:  589:	if(lexstop) {
        2:  590:	    lexstop = 0;
        2:  591:	    break;
        -:  592:	}
      478:  593:	tbuf[n++] = c;
      478:  594:	if(!idigit(c)) {
      477:  595:	    if(c != ec)
      471:  596:		break;
        6:  597:	    if(ec == '>') {
        3:  598:		ret = 1;
        3:  599:		break;
        -:  600:	    }
        3:  601:	    ec = '>';
        -:  602:	}
        4:  603:	if(n == tbs)
    #####:  604:	    tbuf = (char *)realloc(tbuf, tbs *= 2);
        -:  605:    }
     1430:  606:    while(n--)
      478:  607:	hungetc(tbuf[n]);
      476:  608:    zfree(tbuf, tbs);
      476:  609:    return ret;
        -:  610:}
        -:  611:
        -:  612:/**/
        -:  613:static enum lextok
    10027:  614:gettok(void)
        -:  615:{
        -:  616:    int c, d;
    10027:  617:    int peekfd = -1;
        -:  618:    enum lextok peek;
        -:  619:
    10027:  620:  beginning:
    10027:  621:    tokstr = NULL;
    10027:  622:    while (iblank(c = hgetc()) && !lexstop);
    10027:  623:    toklineno = lineno;
    10027:  624:    if (lexstop)
     1224:  625:	return (errflag) ? LEXERR : ENDINPUT;
     8803:  626:    isfirstln = 0;
     8803:  627:    if ((lexflags & LEXFLAGS_ZLE) && !(inbufflags & INP_ALIAS))
    #####:  628:	wordbeg = inbufct - (qbang && c == bangchar);
     8803:  629:    hwbegin(-1-(qbang && c == bangchar));
        -:  630:    /* word includes the last character read and possibly \ before ! */
     8803:  631:    if (dbparens) {
       27:  632:	lexbuf.len = 0;
       27:  633:	lexbuf.ptr = tokstr = (char *) hcalloc(lexbuf.siz = LEX_HEAP_SIZE);
       27:  634:	hungetc(c);
       27:  635:	cmdpush(CS_MATH);
       27:  636:	c = dquote_parse(infor ? ';' : ')', 0);
       27:  637:	cmdpop();
       27:  638:	*lexbuf.ptr = '\0';
       27:  639:	if (!c && infor) {
       18:  640:	    infor--;
       18:  641:	    return DINPAR;
        -:  642:	}
        9:  643:	if (c || (c = hgetc()) != ')') {
    #####:  644:	    hungetc(c);
    #####:  645:	    return LEXERR;
        -:  646:	}
        9:  647:	dbparens = 0;
        9:  648:	return DOUTPAR;
     8776:  649:    } else if (idigit(c)) {	/* handle 1< foo */
      193:  650:	d = hgetc();
      193:  651:	if(d == '&') {
    #####:  652:	    d = hgetc();
    #####:  653:	    if(d == '>') {
    #####:  654:		peekfd = c - '0';
    #####:  655:		hungetc('>');
    #####:  656:		c = '&';
        -:  657:	    } else {
    #####:  658:		hungetc(d);
    #####:  659:		lexstop = 0;
    #####:  660:		hungetc('&');
        -:  661:	    }
      193:  662:	} else if (d == '>' || d == '<') {
        4:  663:	    peekfd = c - '0';
        4:  664:	    c = d;
        -:  665:	} else {
      189:  666:	    hungetc(d);
      189:  667:	    lexstop = 0;
        -:  668:	}
        -:  669:    }
        -:  670:
        -:  671:    /* chars in initial position in word */
        -:  672:
        -:  673:    /*
        -:  674:     * Handle comments.  There are some special cases when this
        -:  675:     * is not normal command input: lexflags implies we are examining
        -:  676:     * a line lexically without it being used for normal command input.
        -:  677:     */
     8902:  678:    if (c == hashchar && !nocomments &&
      252:  679:	(isset(INTERACTIVECOMMENTS) ||
      258:  680:	 ((!lexflags || (lexflags & LEXFLAGS_COMMENTS)) && !expanding &&
      126:  681:	  (!interact || unset(SHINSTDIN) || strin)))) {
        -:  682:	/* History is handled here to prevent extra  *
        -:  683:	 * newlines being inserted into the history. */
        -:  684:
      126:  685:	if (lexflags & LEXFLAGS_COMMENTS_KEEP) {
        3:  686:	    lexbuf.len = 0;
        3:  687:	    lexbuf.ptr = tokstr =
        3:  688:		(char *)hcalloc(lexbuf.siz = LEX_HEAP_SIZE);
        3:  689:	    add(c);
        -:  690:	}
      126:  691:	hwabort();
     6196:  692:	while ((c = ingetc()) != '\n' && !lexstop) {
     5944:  693:	    hwaddc(c);
     5944:  694:	    addtoline(c);
     5944:  695:	    if (lexflags & LEXFLAGS_COMMENTS_KEEP)
       41:  696:		add(c);
        -:  697:	}
        -:  698:
      126:  699:	if (errflag)
    #####:  700:	    peek = LEXERR;
        -:  701:	else {
      126:  702:	    if (lexflags & LEXFLAGS_COMMENTS_KEEP) {
        3:  703:		*lexbuf.ptr = '\0';
        3:  704:		if (!lexstop)
        3:  705:		    hungetc(c);
        3:  706:		peek = STRING;
        -:  707:	    } else {
      123:  708:		hwend();
      123:  709:		hwbegin(0);
      123:  710:		hwaddc('\n');
      123:  711:		addtoline('\n');
        -:  712:		/*
        -:  713:		 * If splitting a line and removing comments,
        -:  714:		 * we don't want a newline token since it's
        -:  715:		 * treated specially.
        -:  716:		 */
      123:  717:		if ((lexflags & LEXFLAGS_COMMENTS_STRIP) && lexstop)
        1:  718:		    peek = ENDINPUT;
        -:  719:		else
      122:  720:		    peek = NEWLIN;
        -:  721:	    }
        -:  722:	}
      126:  723:	return peek;
        -:  724:    }
     8650:  725:    switch (lexact1[STOUC(c)]) {
        5:  726:    case LX1_BKSLASH:
        5:  727:	d = hgetc();
        5:  728:	if (d == '\n')
    #####:  729:	    goto beginning;
        5:  730:	hungetc(d);
        5:  731:	lexstop = 0;
        5:  732:	break;
     1397:  733:    case LX1_NEWLIN:
     1397:  734:	return NEWLIN;
      132:  735:    case LX1_SEMI:
      132:  736:	d = hgetc();
      132:  737:	if(d == ';')
       24:  738:	    return DSEMI;
      108:  739:	else if(d == '&')
        2:  740:	    return SEMIAMP;
      106:  741:	else if (d == '|')
    #####:  742:	    return SEMIBAR;
      106:  743:	hungetc(d);
      106:  744:	lexstop = 0;
      106:  745:	return SEMI;
       34:  746:    case LX1_AMPER:
       34:  747:	d = hgetc();
       34:  748:	if (d == '&')
       34:  749:	    return DAMPER;
    #####:  750:	else if (d == '!' || d == '|')
    #####:  751:	    return AMPERBANG;
    #####:  752:	else if (d == '>') {
    #####:  753:	    tokfd = peekfd;
    #####:  754:	    d = hgetc();
    #####:  755:	    if (d == '!' || d == '|')
    #####:  756:		return OUTANGAMPBANG;
    #####:  757:	    else if (d == '>') {
    #####:  758:		d = hgetc();
    #####:  759:		if (d == '!' || d == '|')
    #####:  760:		    return DOUTANGAMPBANG;
    #####:  761:		hungetc(d);
    #####:  762:		lexstop = 0;
    #####:  763:		return DOUTANGAMP;
        -:  764:	    }
    #####:  765:	    hungetc(d);
    #####:  766:	    lexstop = 0;
    #####:  767:	    return AMPOUTANG;
        -:  768:	}
    #####:  769:	hungetc(d);
    #####:  770:	lexstop = 0;
    #####:  771:	return AMPER;
       35:  772:    case LX1_BAR:
       35:  773:	d = hgetc();
       35:  774:	if (d == '|' && !incasepat)
       31:  775:	    return DBAR;
        4:  776:	else if (d == '&')
    #####:  777:	    return BARAMP;
        4:  778:	hungetc(d);
        4:  779:	lexstop = 0;
        4:  780:	return BAR;
      147:  781:    case LX1_INPAR:
      147:  782:	d = hgetc();
      147:  783:	if (d == '(') {
       34:  784:	    if (infor) {
        9:  785:		dbparens = 1;
        9:  786:		return DINPAR;
        -:  787:	    }
       25:  788:	    if (incmdpos || (isset(SHGLOB) && !isset(KSHGLOB))) {
       25:  789:		lexbuf.len = 0;
       25:  790:		lexbuf.ptr = tokstr = (char *)
       25:  791:		    hcalloc(lexbuf.siz = LEX_HEAP_SIZE);
       25:  792:		switch (cmd_or_math(CS_MATH)) {
       23:  793:		case CMD_OR_MATH_MATH:
       23:  794:		    return DINPAR;
        -:  795:
        1:  796:		case CMD_OR_MATH_CMD:
        -:  797:		    /*
        -:  798:		     * Not math, so we don't return the contents
        -:  799:		     * as a string in this case.
        -:  800:		     */
        1:  801:		    tokstr = NULL;
        1:  802:		    return INPAR;
        -:  803:		    
        1:  804:		case CMD_OR_MATH_ERR:
        -:  805:		    /*
        -:  806:		     * LEXFLAGS_ACTIVE means we came from bufferwords(),
        -:  807:		     * so we treat as an incomplete math expression
        -:  808:		     */
        1:  809:		    if (lexflags & LEXFLAGS_ACTIVE)
        1:  810:			tokstr = dyncat("((", tokstr ? tokstr : "");
        -:  811:		    /* fall through */
        -:  812:
        -:  813:		default:
        1:  814:		    return LEXERR;
        -:  815:		}
        -:  816:	    }
      113:  817:	} else if (d == ')')
       40:  818:	    return INOUTPAR;
       73:  819:	hungetc(d);
       73:  820:	lexstop = 0;
       73:  821:	if (!(isset(SHGLOB) || incond == 1 || incmdpos))
       21:  822:	    break;
       52:  823:	return INPAR;
      245:  824:    case LX1_OUTPAR:
      245:  825:	return OUTPAR;
      470:  826:    case LX1_INANG:
      470:  827:	d = hgetc();
      470:  828:	if (d == '(') {
    #####:  829:	    hungetc(d);
    #####:  830:	    lexstop = 0;
    #####:  831:	    unpeekfd:
    #####:  832:	    if(peekfd != -1) {
    #####:  833:		hungetc(c);
    #####:  834:		c = '0' + peekfd;
        -:  835:	    }
    #####:  836:	    break;
        -:  837:	}
      470:  838:	if (d == '>') {
    #####:  839:	    peek = INOUTANG;
      470:  840:	} else if (d == '<') {
        2:  841:	    int e = hgetc();
        -:  842:
        2:  843:	    if (e == '(') {
    #####:  844:		hungetc(e);
    #####:  845:		hungetc(d);
    #####:  846:		peek = INANG;
        2:  847:	    } else if (e == '<')
        2:  848:		peek = TRINANG;
    #####:  849:	    else if (e == '-')
    #####:  850:		peek = DINANGDASH;
        -:  851:	    else {
    #####:  852:		hungetc(e);
    #####:  853:		lexstop = 0;
    #####:  854:		peek = DINANG;
        -:  855:	    }
      468:  856:	} else if (d == '&') {
    #####:  857:	    peek = INANGAMP;
        -:  858:	} else {
      468:  859:	    hungetc(d);
      468:  860:	    if(isnumglob())
    #####:  861:		goto unpeekfd;
      468:  862:	    peek = INANG;
        -:  863:	}
      470:  864:	tokfd = peekfd;
      470:  865:	return peek;
       15:  866:    case LX1_OUTANG:
       15:  867:	d = hgetc();
       15:  868:	if (d == '(') {
    #####:  869:	    hungetc(d);
    #####:  870:	    goto unpeekfd;
       15:  871:	} else if (d == '&') {
        3:  872:	    d = hgetc();
        3:  873:	    if (d == '!' || d == '|')
    #####:  874:		peek = OUTANGAMPBANG;
        -:  875:	    else {
        3:  876:		hungetc(d);
        3:  877:		lexstop = 0;
        3:  878:		peek = OUTANGAMP;
        -:  879:	    }
       12:  880:	} else if (d == '!' || d == '|')
    #####:  881:	    peek = OUTANGBANG;
       12:  882:	else if (d == '>') {
        2:  883:	    d = hgetc();
        2:  884:	    if (d == '&') {
    #####:  885:		d = hgetc();
    #####:  886:		if (d == '!' || d == '|')
    #####:  887:		    peek = DOUTANGAMPBANG;
        -:  888:		else {
    #####:  889:		    hungetc(d);
    #####:  890:		    lexstop = 0;
    #####:  891:		    peek = DOUTANGAMP;
        -:  892:		}
        2:  893:	    } else if (d == '!' || d == '|')
    #####:  894:		peek = DOUTANGBANG;
        2:  895:	    else if (d == '(') {
    #####:  896:		hungetc(d);
    #####:  897:		hungetc('>');
    #####:  898:		peek = OUTANG;
        -:  899:	    } else {
        2:  900:		hungetc(d);
        2:  901:		lexstop = 0;
        2:  902:		peek = DOUTANG;
        2:  903:		if (isset(HISTALLOWCLOBBER))
    #####:  904:		    hwaddc('|');
        -:  905:	    }
        -:  906:	} else {
       10:  907:	    hungetc(d);
       10:  908:	    lexstop = 0;
       10:  909:	    peek = OUTANG;
       10:  910:	    if (!incond && isset(HISTALLOWCLOBBER))
    #####:  911:		hwaddc('|');
        -:  912:	}
       15:  913:	tokfd = peekfd;
       15:  914:	return peek;
        -:  915:    }
        -:  916:
        -:  917:    /* we've started a string, now get the *
        -:  918:     * rest of it, performing tokenization */
     6196:  919:    return gettokstr(c, 0);
        -:  920:}
        -:  921:
        -:  922:/*
        -:  923: * Get the remains of a token string.  This has two uses.
        -:  924: * When called from gettok(), with sub = 0, we have already identified
        -:  925: * any interesting initial character and want to get the rest of
        -:  926: * what we now know is a string.  However, the string may still include
        -:  927: * metacharacters and potentially substitutions.
        -:  928: *
        -:  929: * When called from parse_subst_string() with sub = 1, we are not
        -:  930: * fully parsing a command line, merely tokenizing a string.
        -:  931: * In this case we always add characters to the parsed string
        -:  932: * unless there is a parse error.
        -:  933: */
        -:  934:
        -:  935:/**/
        -:  936:static enum lextok
     6301:  937:gettokstr(int c, int sub)
        -:  938:{
     6301:  939:    int bct = 0, pct = 0, brct = 0, seen_brct = 0, fdpar = 0;
     6301:  940:    int intpos = 1, in_brace_param = 0;
     6301:  941:    int inquote, unmatched = 0;
        -:  942:    enum lextok peek;
        -:  943:#ifdef DEBUG
        -:  944:    int ocmdsp = cmdsp;
        -:  945:#endif
        -:  946:
     6301:  947:    peek = STRING;
     6301:  948:    if (!sub) {
     6196:  949:	lexbuf.len = 0;
     6196:  950:	lexbuf.ptr = tokstr = (char *) hcalloc(lexbuf.siz = LEX_HEAP_SIZE);
        -:  951:    }
    32609:  952:    for (;;) {
        -:  953:	int act;
        -:  954:	int e;
    38910:  955:	int inbl = inblank(c);
        -:  956:	
    38910:  957:	if (fdpar && !inbl && c != ')')
    #####:  958:	    fdpar = 0;
        -:  959:
    38910:  960:	if (inbl && !in_brace_param && !pct)
     4545:  961:	    act = LX2_BREAK;
        -:  962:	else {
    34365:  963:	    act = lexact2[STOUC(c)];
    34365:  964:	    c = lextok2[STOUC(c)];
        -:  965:	}
    38910:  966:	switch (act) {
     4625:  967:	case LX2_BREAK:
     4625:  968:	    if (!in_brace_param && !sub)
     4609:  969:		goto brk;
       16:  970:	    break;
    #####:  971:	case LX2_META:
    #####:  972:	    c = hgetc();
        -:  973:#ifdef DEBUG
        -:  974:	    if (lexstop) {
        -:  975:		fputs("BUG: input terminated by Meta\n", stderr);
        -:  976:		fflush(stderr);
        -:  977:		goto brk;
        -:  978:	    }
        -:  979:#endif
    #####:  980:	    add(Meta);
    #####:  981:	    break;
      493:  982:	case LX2_OUTPAR:
      493:  983:	    if (fdpar) {
        -:  984:		/* this is a single word `(   )', treat as INOUTPAR */
    #####:  985:		add(c);
    #####:  986:		*lexbuf.ptr = '\0';
    #####:  987:		return INOUTPAR;
        -:  988:	    }
      493:  989:	    if ((sub || in_brace_param) && isset(SHGLOB))
    #####:  990:		break;
      493:  991:	    if (!in_brace_param && !pct--) {
      202:  992:		if (sub) {
        2:  993:		    pct = 0;
        2:  994:		    break;
        -:  995:		} else
      200:  996:		    goto brk;
        -:  997:	    }
      291:  998:	    c = Outpar;
      291:  999:	    break;
       23: 1000:	case LX2_BAR:
       23: 1001:	    if (!pct && !in_brace_param) {
        3: 1002:		if (sub)
        2: 1003:		    break;
        -: 1004:		else
        1: 1005:		    goto brk;
        -: 1006:	    }
       20: 1007:	    if (unset(SHGLOB) || (!sub && !in_brace_param))
       20: 1008:		c = Bar;
       20: 1009:	    break;
     1376: 1010:	case LX2_STRING:
     1376: 1011:	    e = hgetc();
     1376: 1012:	    if (e == '\\') {
        3: 1013:		e = hgetc();
        3: 1014:		if (e != '\n') {
    #####: 1015:		    hungetc(e);
    #####: 1016:		    hungetc('\\');
    #####: 1017:		    lexstop = 0;
    #####: 1018:		    break;
        -: 1019:		}
        3: 1020:		e = hgetc();
        -: 1021:	    }
     1376: 1022:	    if (e == '[') {
    #####: 1023:		cmdpush(CS_MATHSUBST);
    #####: 1024:		add(String);
    #####: 1025:		add(Inbrack);
    #####: 1026:		c = dquote_parse(']', sub);
    #####: 1027:		cmdpop();
    #####: 1028:		if (c) {
    #####: 1029:		    peek = LEXERR;
    #####: 1030:		    goto brk;
        -: 1031:		}
    #####: 1032:		c = Outbrack;
     1376: 1033:	    } else if (e == '(') {
       38: 1034:		add(String);
       38: 1035:		switch (cmd_or_math_sub()) {
       19: 1036:		case CMD_OR_MATH_CMD:
       19: 1037:		    c = Outpar;
       19: 1038:		    break;
        -: 1039:
       17: 1040:		case CMD_OR_MATH_MATH:
       17: 1041:		    c = Outparmath;
       17: 1042:		    break;
        -: 1043:
        2: 1044:		default:
        2: 1045:		    peek = LEXERR;
        2: 1046:		    goto brk;
        -: 1047:		}
        -: 1048:	    } else {
     1338: 1049:		if (e == '{') {
      490: 1050:		    add(c);
      490: 1051:		    c = Inbrace;
      490: 1052:		    ++bct;
      490: 1053:		    cmdpush(CS_BRACEPAR);
      490: 1054:		    if (!in_brace_param) {
      463: 1055:			if ((in_brace_param = bct))
      463: 1056:			    seen_brct = 0;
        -: 1057:		    }
        -: 1058:		} else {
      848: 1059:		    hungetc(e);
      848: 1060:		    lexstop = 0;
        -: 1061:		}
        -: 1062:	    }
     1374: 1063:	    break;
      374: 1064:	case LX2_INBRACK:
      374: 1065:	    if (!in_brace_param) {
      282: 1066:		brct++;
      282: 1067:		seen_brct = 1;
        -: 1068:	    }
      374: 1069:	    c = Inbrack;
      374: 1070:	    break;
      374: 1071:	case LX2_OUTBRACK:
      374: 1072:	    if (!in_brace_param)
      282: 1073:		brct--;
      374: 1074:	    if (brct < 0)
      134: 1075:		brct = 0;
      374: 1076:	    c = Outbrack;
      374: 1077:	    break;
      329: 1078:	case LX2_INPAR:
      329: 1079:	    if (isset(SHGLOB)) {
        1: 1080:		if (sub || in_brace_param)
        -: 1081:		    break;
        1: 1082:		if (incasepat > 0 && !lexbuf.len)
    #####: 1083:		    return INPAR;
        1: 1084:		if (!isset(KSHGLOB) && lexbuf.len)
        1: 1085:		    goto brk;
        -: 1086:	    }
      328: 1087:	    if (!in_brace_param) {
       93: 1088:		if (!sub) {
       70: 1089:		    e = hgetc();
       70: 1090:		    hungetc(e);
       70: 1091:		    lexstop = 0;
        -: 1092:		    /* For command words, parentheses are only
        -: 1093:		     * special at the start.  But now we're tokenising
        -: 1094:		     * the remaining string.  So I don't see what
        -: 1095:		     * the old incmdpos test here is for.
        -: 1096:		     *   pws 1999/6/8
        -: 1097:		     *
        -: 1098:		     * Oh, no.
        -: 1099:		     *  func1(   )
        -: 1100:		     * is a valid function definition in [k]sh.  The best
        -: 1101:		     * thing we can do, without really nasty lookahead tricks,
        -: 1102:		     * is break if we find a blank after a parenthesis.  At
        -: 1103:		     * least this can't happen inside braces or brackets.  We
        -: 1104:		     * only allow this with SHGLOB (set for both sh and ksh).
        -: 1105:		     *
        -: 1106:		     * Things like `print @( |foo)' should still
        -: 1107:		     * work, because [k]sh don't allow multiple words
        -: 1108:		     * in a function definition, so we only do this
        -: 1109:		     * in command position.
        -: 1110:		     *   pws 1999/6/14
        -: 1111:		     */
       70: 1112:		    if (e == ')' || (isset(SHGLOB) && inblank(e) && !bct &&
    #####: 1113:				     !brct && !intpos && incmdpos)) {
        -: 1114:			/*
        -: 1115:			 * Either a () token, or a command word with
        -: 1116:			 * something suspiciously like a ksh function
        -: 1117:			 * definition.
        -: 1118:			 * The current word isn't spellcheckable.
        -: 1119:			 */
       34: 1120:			nocorrect |= 2;
       34: 1121:			goto brk;
        -: 1122:		    }
        -: 1123:		}
        -: 1124:		/*
        -: 1125:		 * This also handles the [k]sh `foo( )' function definition.
        -: 1126:		 * Maintain a variable fdpar, set as long as a single set of
        -: 1127:		 * parentheses contains only space.  Then if we get to the
        -: 1128:		 * closing parenthesis and it is still set, we can assume we
        -: 1129:		 * have a function definition.  Only do this at the start of
        -: 1130:		 * the word, since the (...) must be a separate token.
        -: 1131:		 */
       59: 1132:		if (!pct++ && isset(SHGLOB) && intpos && !bct && !brct)
    #####: 1133:		    fdpar = 1;
        -: 1134:	    }
      294: 1135:	    c = Inpar;
      294: 1136:	    break;
       53: 1137:	case LX2_INBRACE:
       53: 1138:	    if (isset(IGNOREBRACES) || sub)
        3: 1139:		c = '{';
        -: 1140:	    else {
       50: 1141:		if (!lexbuf.len && incmdpos) {
       40: 1142:		    add('{');
       40: 1143:		    *lexbuf.ptr = '\0';
       40: 1144:		    return STRING;
        -: 1145:		}
       10: 1146:		if (in_brace_param) {
        1: 1147:		    cmdpush(CS_BRACE);
        -: 1148:		}
       10: 1149:		bct++;
        -: 1150:	    }
       13: 1151:	    break;
      543: 1152:	case LX2_OUTBRACE:
      543: 1153:	    if ((isset(IGNOREBRACES) || sub) && !in_brace_param)
        3: 1154:		break;
      540: 1155:	    if (!bct)
       44: 1156:		break;
      496: 1157:	    if (in_brace_param) {
      491: 1158:		cmdpop();
        -: 1159:	    }
      496: 1160:	    if (bct-- == in_brace_param)
      463: 1161:		in_brace_param = 0;
      496: 1162:	    c = Outbrace;
      496: 1163:	    break;
       36: 1164:	case LX2_COMMA:
       36: 1165:	    if (unset(IGNOREBRACES) && !sub && bct > in_brace_param)
        4: 1166:		c = Comma;
       36: 1167:	    break;
        5: 1168:	case LX2_OUTANG:
        5: 1169:	    if (in_brace_param || sub)
        -: 1170:		break;
        2: 1171:	    e = hgetc();
        2: 1172:	    if (e != '(') {
        2: 1173:		hungetc(e);
        2: 1174:		lexstop = 0;
        2: 1175:		goto brk;
        -: 1176:	    }
    #####: 1177:	    add(OutangProc);
    #####: 1178:	    if (skipcomm()) {
    #####: 1179:		peek = LEXERR;
    #####: 1180:		goto brk;
        -: 1181:	    }
    #####: 1182:	    c = Outpar;
    #####: 1183:	    break;
        8: 1184:	case LX2_INANG:
        8: 1185:	    if (isset(SHGLOB) && sub)
    #####: 1186:		break;
        8: 1187:	    e = hgetc();
        8: 1188:	    if (!(in_brace_param || sub) && e == '(') {
    #####: 1189:		add(Inang);
    #####: 1190:		if (skipcomm()) {
    #####: 1191:		    peek = LEXERR;
    #####: 1192:		    goto brk;
        -: 1193:		}
    #####: 1194:		c = Outpar;
    #####: 1195:		break;
        -: 1196:	    }
        8: 1197:	    hungetc(e);
        8: 1198:	    if(isnumglob()) {
        3: 1199:		add(Inang);
        9: 1200:		while ((c = hgetc()) != '>')
        3: 1201:		    add(c);
        3: 1202:		c = Outang;
        3: 1203:		break;
        -: 1204:	    }
        5: 1205:	    lexstop = 0;
        5: 1206:	    if (in_brace_param || sub)
        -: 1207:		break;
        2: 1208:	    goto brk;
      551: 1209:	case LX2_EQUALS:
      551: 1210:	    if (!sub) {
      551: 1211:		if (intpos) {
       39: 1212:		    e = hgetc();
       39: 1213:		    if (e != '(') {
       38: 1214:			hungetc(e);
       38: 1215:			lexstop = 0;
       38: 1216:			c = Equals;
        -: 1217:		    } else {
        1: 1218:			add(Equals);
        1: 1219:			if (skipcomm()) {
    #####: 1220:			    peek = LEXERR;
    #####: 1221:			    goto brk;
        -: 1222:			}
        1: 1223:			c = Outpar;
        -: 1224:		    }
     1024: 1225:		} else if (peek != ENVSTRING &&
      923: 1226:			   (incmdpos || intypeset) && !bct && !brct) {
      401: 1227:		    char *t = tokstr;
      401: 1228:		    if (idigit(*t))
    #####: 1229:			while (++t < lexbuf.ptr && idigit(*t));
        -: 1230:		    else {
      401: 1231:			int sav = *lexbuf.ptr;
      401: 1232:			*lexbuf.ptr = '\0';
      401: 1233:			t = itype_end(t, IIDENT, 0);
      401: 1234:			if (t < lexbuf.ptr) {
       18: 1235:			    skipparens(Inbrack, Outbrack, &t);
        -: 1236:			} else {
      383: 1237:			    *lexbuf.ptr = sav;
        -: 1238:			}
        -: 1239:		    }
      401: 1240:		    if (*t == '+')
       11: 1241:			t++;
      401: 1242:		    if (t == lexbuf.ptr) {
      401: 1243:			e = hgetc();
      401: 1244:			if (e == '(') {
      139: 1245:			    *lexbuf.ptr = '\0';
      139: 1246:			    return ENVARRAY;
        -: 1247:			}
      262: 1248:			hungetc(e);
      262: 1249:			lexstop = 0;
      262: 1250:			peek = ENVSTRING;
      262: 1251:			intpos = 2;
        -: 1252:		    } else
    #####: 1253:			c = Equals;
        -: 1254:		} else
      111: 1255:		    c = Equals;
        -: 1256:	    }
      412: 1257:	    break;
       87: 1258:	case LX2_BKSLASH:
       87: 1259:	    c = hgetc();
       87: 1260:	    if (c == '\n') {
    #####: 1261:		c = hgetc();
    #####: 1262:		if (!lexstop)
    #####: 1263:		    continue;
        -: 1264:	    } else {
       87: 1265:		add(Bnull);
       87: 1266:		if (c == STOUC(Meta)) {
    #####: 1267:		    c = hgetc();
        -: 1268:#ifdef DEBUG
        -: 1269:		    if (lexstop) {
        -: 1270:			fputs("BUG: input terminated by Meta\n", stderr);
        -: 1271:			fflush(stderr);
        -: 1272:			goto brk;
        -: 1273:		    }
        -: 1274:#endif
    #####: 1275:		    add(Meta);
        -: 1276:		}
        -: 1277:	    }
       87: 1278:	    if (lexstop)
    #####: 1279:		goto brk;
       87: 1280:	    break;
      203: 1281:	case LX2_QUOTE: {
      203: 1282:	    int strquote = (lexbuf.len && lexbuf.ptr[-1] == String);
        -: 1283:
      203: 1284:	    add(Snull);
      203: 1285:	    cmdpush(CS_QUOTE);
        -: 1286:	    for (;;) {
      203: 1287:		STOPHIST
     3099: 1288:		while ((c = hgetc()) != '\'' && !lexstop) {
     2693: 1289:		    if (strquote && c == '\\') {
       88: 1290:			c = hgetc();
       88: 1291:			if (lexstop)
    #####: 1292:			    break;
        -: 1293:			/*
        -: 1294:			 * Mostly we don't need to do anything special
        -: 1295:			 * with escape backslashes or closing quotes
        -: 1296:			 * inside $'...'; however in completion we
        -: 1297:			 * need to be able to strip multiple backslashes
        -: 1298:			 * neatly.
        -: 1299:			 */
      176: 1300:			if (c == '\\' || c == '\'')
       21: 1301:			    add(Bnull);
        -: 1302:			else
       67: 1303:			    add('\\');
     2605: 1304:		    } else if (!sub && isset(CSHJUNKIEQUOTES) && c == '\n') {
    #####: 1305:			if (lexbuf.ptr[-1] == '\\')
    #####: 1306:			    lexbuf.ptr--, lexbuf.len--;
        -: 1307:			else
    #####: 1308:			    break;
        -: 1309:		    }
     2693: 1310:		    add(c);
        -: 1311:		}
      203: 1312:		ALLOWHIST
      203: 1313:		if (c != '\'') {
        1: 1314:		    unmatched = '\'';
        -: 1315:		    /* Not an error when called from bufferwords() */
        1: 1316:		    if (!(lexflags & LEXFLAGS_ACTIVE))
    #####: 1317:			peek = LEXERR;
        1: 1318:		    cmdpop();
        1: 1319:		    goto brk;
        -: 1320:		}
      202: 1321:		e = hgetc();
      202: 1322:		if (e != '\'' || unset(RCQUOTES) || strquote)
        -: 1323:		    break;
    #####: 1324:		add(c);
        -: 1325:	    }
      202: 1326:	    cmdpop();
      202: 1327:	    hungetc(e);
      202: 1328:	    lexstop = 0;
      202: 1329:	    c = Snull;
      202: 1330:	    break;
        -: 1331:	}
      728: 1332:	case LX2_DQUOTE:
      728: 1333:	    add(Dnull);
      728: 1334:	    cmdpush(CS_DQUOTE);
      728: 1335:	    c = dquote_parse('"', sub);
      728: 1336:	    cmdpop();
      728: 1337:	    if (c) {
        1: 1338:		unmatched = '"';
        -: 1339:		/* Not an error when called from bufferwords() */
        1: 1340:		if (!(lexflags & LEXFLAGS_ACTIVE))
        1: 1341:		    peek = LEXERR;
        1: 1342:		goto brk;
        -: 1343:	    }
      727: 1344:	    c = Dnull;
      727: 1345:	    break;
        2: 1346:	case LX2_BQUOTE:
        2: 1347:	    add(Tick);
        2: 1348:	    cmdpush(CS_BQUOTE);
        2: 1349:	    SETPARBEGIN
        2: 1350:	    inquote = 0;
       24: 1351:	    while ((c = hgetc()) != '`' && !lexstop) {
       20: 1352:		if (c == '\\') {
    #####: 1353:		    c = hgetc();
    #####: 1354:		    if (c != '\n') {
    #####: 1355:			add(c == '`' || c == '\\' || c == '$' ? Bnull : '\\');
    #####: 1356:			add(c);
        -: 1357:		    }
    #####: 1358:		    else if (!sub && isset(CSHJUNKIEQUOTES))
    #####: 1359:			add(c);
        -: 1360:		} else {
       20: 1361:		    if (!sub && isset(CSHJUNKIEQUOTES) && c == '\n') {
    #####: 1362:			break;
        -: 1363:		    }
       20: 1364:		    add(c);
       20: 1365:		    if (c == '\'') {
    #####: 1366:			if ((inquote = !inquote))
    #####: 1367:			    STOPHIST
        -: 1368:			else
    #####: 1369:			    ALLOWHIST
        -: 1370:		    }
        -: 1371:		}
        -: 1372:	    }
        2: 1373:	    if (inquote)
    #####: 1374:		ALLOWHIST
        2: 1375:	    cmdpop();
        2: 1376:	    if (c != '`') {
    #####: 1377:		unmatched = '`';
        -: 1378:		/* Not an error when called from bufferwords() */
    #####: 1379:		if (!(lexflags & LEXFLAGS_ACTIVE))
    #####: 1380:		    peek = LEXERR;
    #####: 1381:		goto brk;
        -: 1382:	    }
        2: 1383:	    c = Tick;
        2: 1384:	    SETPAREND
        2: 1385:	    break;
      974: 1386:	case LX2_DASH:
        -: 1387:	    /*
        -: 1388:	     * - shouldn't be treated as a special character unless
        -: 1389:	     * we're in a pattern.  Unfortunately, working out for
        -: 1390:	     * sure in complicated expressions whether we're in a
        -: 1391:	     * pattern is tricky.  So we'll make it special and
        -: 1392:	     * turn it back any time we don't need it special.
        -: 1393:	     * This is not ideal as it's a lot of work.
        -: 1394:	     */
      974: 1395:	    c = Dash;
      974: 1396:           break;
       20: 1397:       case LX2_BANG:
        -: 1398:           /*
        -: 1399:            * Same logic as Dash, for ! to perform negation in range.
        -: 1400:            */
       20: 1401:           if (seen_brct)
    #####: 1402:               c = Bang;
        -: 1403:           else
       20: 1404:               c = '!';
        -: 1405:       }
    33878: 1406:       add(c);
    33878: 1407:       c = hgetc();
    33878: 1408:	if (intpos)
     6766: 1409:	    intpos--;
    33878: 1410:	if (lexstop)
     1269: 1411:	    break;
        -: 1412:    }
     6122: 1413:  brk:
     6122: 1414:    if (errflag) {
    #####: 1415:	if (in_brace_param) {
    #####: 1416:	    while(bct-- >= in_brace_param)
    #####: 1417:		cmdpop();
        -: 1418:	}
    #####: 1419:	return LEXERR;
        -: 1420:    }
     6122: 1421:    hungetc(c);
     6122: 1422:    if (unmatched && !(lexflags & LEXFLAGS_ACTIVE))
        1: 1423:	zerr("unmatched %c", unmatched);
     6122: 1424:    if (in_brace_param) {
    #####: 1425:	while(bct-- >= in_brace_param)
    #####: 1426:	    cmdpop();
    #####: 1427:	zerr("closing brace expected");
     6122: 1428:    } else if (unset(IGNOREBRACES) && !sub && lexbuf.len > 1 &&
     5378: 1429:	       peek == STRING && lexbuf.ptr[-1] == '}' &&
    #####: 1430:	       lexbuf.ptr[-2] != Bnull) {
        -: 1431:	/* hack to get {foo} command syntax work */
    #####: 1432:	lexbuf.ptr--;
    #####: 1433:	lexbuf.len--;
    #####: 1434:	lexstop = 0;
    #####: 1435:	hungetc('}');
        -: 1436:    }
     6122: 1437:    *lexbuf.ptr = '\0';
        -: 1438:    DPUTS(cmdsp != ocmdsp, "BUG: gettok: cmdstack changed.");
     6122: 1439:    return peek;
        -: 1440:}
        -: 1441:
        -: 1442:
        -: 1443:/*
        -: 1444: * Parse input as if in double quotes.
        -: 1445: * endchar is the end character to expect.
        -: 1446: * sub has got something to do with whether we are doing quoted substitution.
        -: 1447: * Return non-zero for error (character to unget), else zero
        -: 1448: */
        -: 1449:
        -: 1450:/**/
        -: 1451:static int
     5220: 1452:dquote_parse(char endchar, int sub)
        -: 1453:{
     5220: 1454:    int pct = 0, brct = 0, bct = 0, intick = 0, err = 0;
        -: 1455:    int c;
     5220: 1456:    int math = endchar == ')' || endchar == ']' || infor;
     5220: 1457:    int zlemath = math && zlemetacs > zlemetall + addedx - inbufct;
        -: 1458:
    26412: 1459:    while (((c = hgetc()) != endchar || bct ||
     4257: 1460:	    (math && ((pct > 0) || (brct > 0))) ||
    16187: 1461:	    intick) && !lexstop) {
    31980: 1462:      cont:
    16006: 1463:	switch (c) {
       70: 1464:	case '\\':
       70: 1465:	    c = hgetc();
       70: 1466:	    if (c != '\n') {
      107: 1467:		if (c == '$' || c == '\\' || (c == '}' && !intick && bct) ||
       77: 1468:		    c == endchar || c == '`' ||
        3: 1469:		    (endchar == ']' && (c == '[' || c == ']' ||
        2: 1470:					c == '(' || c == ')' ||
        1: 1471:					c == '{' || c == '}' ||
    #####: 1472:					(c == '"' && sub))))
       35: 1473:		    add(Bnull);
        -: 1474:		else {
        -: 1475:		    /* lexstop is implicitly handled here */
       32: 1476:		    add('\\');
       32: 1477:		    goto cont;
        -: 1478:		}
        3: 1479:	    } else if (sub || unset(CSHJUNKIEQUOTES) || endchar != '"')
        3: 1480:		continue;
       35: 1481:	    break;
       24: 1482:	case '\n':
       24: 1483:	    err = !sub && isset(CSHJUNKIEQUOTES) && endchar == '"';
       24: 1484:	    break;
      811: 1485:	case '$':
      811: 1486:	    if (intick)
    #####: 1487:		break;
      811: 1488:	    c = hgetc();
      811: 1489:	    if (c == '(') {
       42: 1490:		add(Qstring);
       42: 1491:		switch (cmd_or_math_sub()) {
       26: 1492:		case CMD_OR_MATH_CMD:
       26: 1493:		    c = Outpar;
       26: 1494:		    break;
        -: 1495:
       16: 1496:		case CMD_OR_MATH_MATH:
       16: 1497:		    c = Outparmath;
       16: 1498:		    break;
        -: 1499:
    #####: 1500:		default:
    #####: 1501:		    err = 1;
    #####: 1502:		    break;
        -: 1503:		}
      769: 1504:	    } else if (c == '[') {
    #####: 1505:		add(String);
    #####: 1506:		add(Inbrack);
    #####: 1507:		cmdpush(CS_MATHSUBST);
    #####: 1508:		err = dquote_parse(']', sub);
    #####: 1509:		cmdpop();
    #####: 1510:		c = Outbrack;
      769: 1511:	    } else if (c == '{') {
      150: 1512:		add(Qstring);
      150: 1513:		c = Inbrace;
      150: 1514:		cmdpush(CS_BRACEPAR);
      150: 1515:		bct++;
      619: 1516:	    } else if (c == '$')
    #####: 1517:		add(Qstring);
        -: 1518:	    else {
      619: 1519:		hungetc(c);
      619: 1520:		lexstop = 0;
      619: 1521:		c = Qstring;
        -: 1522:	    }
      811: 1523:	    break;
      152: 1524:	case '}':
      152: 1525:	    if (intick || !bct)
        -: 1526:		break;
      148: 1527:	    c = Outbrace;
      148: 1528:	    bct--;
      148: 1529:	    cmdpop();
      148: 1530:	    break;
       16: 1531:	case '`':
       16: 1532:	    c = Qtick;
       16: 1533:	    if (intick == 2)
    #####: 1534:		ALLOWHIST
       16: 1535:	    if ((intick = !intick)) {
        8: 1536:		SETPARBEGIN
        8: 1537:		cmdpush(CS_BQUOTE);
        -: 1538:	    } else {
        8: 1539:		SETPAREND
        8: 1540:	        cmdpop();
        -: 1541:	    }
       16: 1542:	    break;
       57: 1543:	case '\'':
       57: 1544:	    if (!intick)
       57: 1545:		break;
    #####: 1546:	    if (intick == 1)
    #####: 1547:		intick = 2, STOPHIST
        -: 1548:	    else
    #####: 1549:		intick = 1, ALLOWHIST
    #####: 1550:	    break;
      125: 1551:	case '(':
      125: 1552:	    if (!math || !bct)
      121: 1553:		pct++;
      125: 1554:	    break;
      123: 1555:	case ')':
      123: 1556:	    if (!math || !bct)
      119: 1557:		err = (!pct-- && math);
      123: 1558:	    break;
       63: 1559:	case '[':
       63: 1560:	    if (!math || !bct)
       54: 1561:		brct++;
       63: 1562:	    break;
       62: 1563:	case ']':
       62: 1564:	    if (!math || !bct)
       53: 1565:		err = (!brct-- && math);
       62: 1566:	    break;
        2: 1567:	case '"':
        2: 1568:	    if (intick || (endchar != '"' && !bct))
        -: 1569:		break;
        2: 1570:	    if (bct) {
        2: 1571:		add(Dnull);
        2: 1572:		cmdpush(CS_DQUOTE);
        2: 1573:		err = dquote_parse('"', sub);
        2: 1574:		cmdpop();
        2: 1575:		c = Dnull;
        -: 1576:	    } else
    #####: 1577:		err = 1;
        2: 1578:	    break;
        -: 1579:	}
    15971: 1580:	if (err || lexstop)
        -: 1581:	    break;
    15969: 1582:	add(c);
        -: 1583:    }
     5220: 1584:    if (intick == 2)
    #####: 1585:	ALLOWHIST
     5220: 1586:    if (intick) {
    #####: 1587:	cmdpop();
        -: 1588:    }
    10442: 1589:    while (bct--)
        2: 1590:	cmdpop();
     5220: 1591:    if (lexstop)
      215: 1592:	err = intick || endchar || err;
     5005: 1593:    else if (err == 1) {
        -: 1594:	/*
        -: 1595:	 * TODO: as far as I can see, this hack is used in gettokstr()
        -: 1596:	 * to hungetc() a character on an error.  However, I don't
        -: 1597:	 * understand what that actually gets us, and we can't guarantee
        -: 1598:	 * it's a character anyway, because of the previous test.
        -: 1599:	 *
        -: 1600:	 * We use the same feature in cmd_or_math where we actually do
        -: 1601:	 * need to unget if we decide it's really a command substitution.
        -: 1602:	 * We try to handle the other case by testing for lexstop.
        -: 1603:	 */
    #####: 1604:	err = c;
        -: 1605:    }
     5220: 1606:    if (zlemath && zlemetacs <= zlemetall + 1 - inbufct)
     2793: 1607:	inwhat = IN_MATH;
     5220: 1608:    return err;
        -: 1609:}
        -: 1610:
        -: 1611:/*
        -: 1612: * Tokenize a string given in s. Parsing is done as in double
        -: 1613: * quotes.  This is usually called before singsub().
        -: 1614: *
        -: 1615: * parsestr() is noisier, reporting an error if the parse failed.
        -: 1616: *
        -: 1617: * On entry, *s must point to a string allocated from the stack of
        -: 1618: * exactly the right length, i.e. strlen(*s) + 1, as the string
        -: 1619: * is used as the lexical token string whose memory management
        -: 1620: * demands this.  Usually the input string will therefore be
        -: 1621: * the result of an immediately preceding dupstring().
        -: 1622: */
        -: 1623:
        -: 1624:/**/
        -: 1625:mod_export int
      130: 1626:parsestr(char **s)
        -: 1627:{
        -: 1628:    int err;
        -: 1629:
      130: 1630:    if ((err = parsestrnoerr(s))) {
    #####: 1631:	untokenize(*s);
    #####: 1632:	if (!(errflag & ERRFLAG_INT)) {
    #####: 1633:	    if (err > 32 && err < 127)
    #####: 1634:		zerr("parse error near `%c'", err);
        -: 1635:	    else
    #####: 1636:		zerr("parse error");
    #####: 1637:	    tok = LEXERR;
        -: 1638:	}
        -: 1639:    }
      130: 1640:    return err;
        -: 1641:}
        -: 1642:
        -: 1643:/**/
        -: 1644:mod_export int
      137: 1645:parsestrnoerr(char **s)
        -: 1646:{
      137: 1647:    int l = strlen(*s), err;
        -: 1648:
      137: 1649:    zcontext_save();
      137: 1650:    untokenize(*s);
      137: 1651:    inpush(dupstring_wlen(*s, l), 0, NULL);
      137: 1652:    strinbeg(0);
      137: 1653:    lexbuf.len = 0;
      137: 1654:    lexbuf.ptr = tokstr = *s;
      137: 1655:    lexbuf.siz = l + 1;
      137: 1656:    err = dquote_parse('\0', 1);
      137: 1657:    if (tokstr)
      137: 1658:	*s = tokstr;
      137: 1659:    *lexbuf.ptr = '\0';
      137: 1660:    strinend();
      137: 1661:    inpop();
        -: 1662:    DPUTS(cmdsp, "BUG: parsestr: cmdstack not empty.");
      137: 1663:    zcontext_restore();
      137: 1664:    return err;
        -: 1665:}
        -: 1666:
        -: 1667:/*
        -: 1668: * Parse a subscript in string s.
        -: 1669: * sub is passed down to dquote_parse().
        -: 1670: * endchar is the final character.
        -: 1671: * Return the next character, or NULL.
        -: 1672: */
        -: 1673:/**/
        -: 1674:mod_export char *
     4267: 1675:parse_subscript(char *s, int sub, int endchar)
        -: 1676:{
     4267: 1677:    int l = strlen(s), err, toklen;
        -: 1678:    char *t;
        -: 1679:
     4267: 1680:    if (!*s || *s == endchar)
    #####: 1681:	return 0;
     4267: 1682:    zcontext_save();
     4267: 1683:    untokenize(t = dupstring_wlen(s, l));
     4267: 1684:    inpush(t, 0, NULL);
     4267: 1685:    strinbeg(0);
        -: 1686:    /*
        -: 1687:     * Warning to Future Generations:
        -: 1688:     *
        -: 1689:     * This way of passing the subscript through the lexer is brittle.
        -: 1690:     * Code above this for several layers assumes that when we tokenise
        -: 1691:     * the input it goes into the same place as the original string.
        -: 1692:     * However, the lexer may overwrite later bits of the string or
        -: 1693:     * reallocate it, in particular when expanding aliaes.  To get
        -: 1694:     * around this, we copy the string and then copy it back.  This is a
        -: 1695:     * bit more robust but still relies on the underlying assumption of
        -: 1696:     * length preservation.
        -: 1697:     */
     4267: 1698:    lexbuf.len = 0;
     4267: 1699:    lexbuf.ptr = tokstr = dupstring_wlen(s, l);
     4267: 1700:    lexbuf.siz = l + 1;
     4267: 1701:    err = dquote_parse(endchar, sub);
     4267: 1702:    toklen = (int)(lexbuf.ptr - tokstr);
        -: 1703:    DPUTS(toklen > l, "Bad length for parsed subscript");
     4267: 1704:    memcpy(s, tokstr, toklen);
     4267: 1705:    if (err) {
       38: 1706:	char *strend = s + toklen;
       38: 1707:	err = *strend;
       38: 1708:	*strend = '\0';
       38: 1709:	untokenize(s);
       38: 1710:	*strend = err;
       38: 1711:	s = NULL;
        -: 1712:    } else {
     4229: 1713:	s += toklen;
        -: 1714:    }
     4267: 1715:    strinend();
     4267: 1716:    inpop();
        -: 1717:    DPUTS(cmdsp, "BUG: parse_subscript: cmdstack not empty.");
     4267: 1718:    zcontext_restore();
     4267: 1719:    return s;
        -: 1720:}
        -: 1721:
        -: 1722:/* Tokenize a string given in s. Parsing is done as if s were a normal *
        -: 1723: * command-line argument but it may contain separators.  This is used  *
        -: 1724: * to parse the right-hand side of ${...%...} substitutions.           */
        -: 1725:
        -: 1726:/**/
        -: 1727:mod_export int
      105: 1728:parse_subst_string(char *s)
        -: 1729:{
      105: 1730:    int c, l = strlen(s), err;
        -: 1731:    char *ptr;
        -: 1732:    enum lextok ctok;
        -: 1733:
      105: 1734:    if (!*s || !strcmp(s, nulstring))
    #####: 1735:	return 0;
      105: 1736:    zcontext_save();
      105: 1737:    untokenize(s);
      105: 1738:    inpush(dupstring_wlen(s, l), 0, NULL);
      105: 1739:    strinbeg(0);
      105: 1740:    lexbuf.len = 0;
      105: 1741:    lexbuf.ptr = tokstr = s;
      105: 1742:    lexbuf.siz = l + 1;
      105: 1743:    c = hgetc();
      105: 1744:    ctok = gettokstr(c, 1);
      105: 1745:    err = errflag;
      105: 1746:    strinend();
      105: 1747:    inpop();
        -: 1748:    DPUTS(cmdsp, "BUG: parse_subst_string: cmdstack not empty.");
      105: 1749:    zcontext_restore();
        -: 1750:    /* Keep any interrupt error status */
      105: 1751:    errflag = err | (errflag & ERRFLAG_INT);
      105: 1752:    if (ctok == LEXERR) {
        1: 1753:	untokenize(s);
        1: 1754:	return 1;
        -: 1755:    }
        -: 1756:#ifdef DEBUG
        -: 1757:    /*
        -: 1758:     * Historical note: we used to check here for olen (the value of lexbuf.len
        -: 1759:     * before zcontext_restore()) == l, but that's not necessarily the case if
        -: 1760:     * we stripped an RCQUOTE.
        -: 1761:     */
        -: 1762:    if (ctok != STRING || (errflag && !noerrs)) {
        -: 1763:	fprintf(stderr, "Oops. Bug in parse_subst_string: %s\n",
        -: 1764:		errflag ? "errflag" : "ctok != STRING");
        -: 1765:	fflush(stderr);
        -: 1766:	untokenize(s);
        -: 1767:	return 1;
        -: 1768:    }
        -: 1769:#endif
        -: 1770:    /* Check for $'...' quoting.  This needs special handling. */
      778: 1771:    for (ptr = s; *ptr; )
        -: 1772:    {
      570: 1773:	if (*ptr == String && ptr[1] == Snull)
       17: 1774:	{
        -: 1775:	    char *t;
        -: 1776:	    int len, tlen, diff;
       17: 1777:	    t = getkeystring(ptr + 2, &len, GETKEYS_DOLLARS_QUOTE, NULL);
       17: 1778:	    len += 2;
       17: 1779:	    tlen = strlen(t);
       17: 1780:	    diff = len - tlen;
        -: 1781:	    /*
        -: 1782:	     * Yuk.
        -: 1783:	     * parse_subst_string() currently handles strings in-place.
        -: 1784:	     * That's not so easy to fix without knowing whether
        -: 1785:	     * additional memory should come off the heap or
        -: 1786:	     * otherwise.  So we cheat by copying the unquoted string
        -: 1787:	     * into place, unless it's too long.  That's not the
        -: 1788:	     * normal case, but I'm worried there are pathological
        -: 1789:	     * cases with converting metafied multibyte strings.
        -: 1790:	     * If someone can prove there aren't I will be very happy.
        -: 1791:	     */
       17: 1792:	    if (diff < 0) {
        -: 1793:		DPUTS(1, "$'...' subst too long: fix get_parse_string()");
    #####: 1794:		return 1;
        -: 1795:	    }
       17: 1796:	    memcpy(ptr, t, tlen);
       17: 1797:	    ptr += tlen;
       17: 1798:	    if (diff > 0) {
       17: 1799:		char *dptr = ptr;
       17: 1800:		char *sptr = ptr + diff;
       17: 1801:		while ((*dptr++ = *sptr++))
        -: 1802:		    ;
        -: 1803:	    }
        -: 1804:	} else
      553: 1805:	    ptr++;
        -: 1806:    }
      104: 1807:    return 0;
        -: 1808:}
        -: 1809:
        -: 1810:/* Called below to report word positions. */
        -: 1811:
        -: 1812:/**/
        -: 1813:static void
    #####: 1814:gotword(void)
        -: 1815:{
    #####: 1816:    int nwe = zlemetall + 1 - inbufct + (addedx == 2 ? 1 : 0);
    #####: 1817:    if (zlemetacs <= nwe) {
    #####: 1818:	int nwb = zlemetall - wordbeg + addedx;
    #####: 1819:	if (zlemetacs >= nwb) {
    #####: 1820:	    wb = nwb;
    #####: 1821:	    we = nwe;
        -: 1822:	} else {
    #####: 1823:	    wb = zlemetacs + addedx;
    #####: 1824:	    if (we < wb)
    #####: 1825:		we = wb;
        -: 1826:	}
    #####: 1827:	lexflags = 0;
        -: 1828:    }
    #####: 1829:}
        -: 1830:
        -: 1831:/* Check if current lex text matches an alias: 1 if so, else 0 */
        -: 1832:
        -: 1833:static int
     6828: 1834:checkalias(void)
        -: 1835:{
        -: 1836:    Alias an;
        -: 1837:
     6828: 1838:    if (!zshlextext)
    #####: 1839:	return 0;
        -: 1840:
    13479: 1841:    if (!noaliases && isset(ALIASESOPT) &&
     6657: 1842:	(!isset(POSIXALIASES) ||
       10: 1843:	 (tok == STRING && !reswdtab->getnode(reswdtab, zshlextext)))) {
        -: 1844:	char *suf;
        -: 1845:
     6647: 1846:	an = (Alias) aliastab->getnode(aliastab, zshlextext);
     6649: 1847:	if (an && !an->inuse &&
        4: 1848:	    ((an->node.flags & ALIAS_GLOBAL) ||
        4: 1849:	     (incmdpos && tok == STRING) || inalmore)) {
        2: 1850:	    if (!lexstop) {
        -: 1851:		/*
        -: 1852:		 * Tokens that don't require a space after, get one,
        -: 1853:		 * because they are treated as if preceded by one.
        -: 1854:		 */
        1: 1855:		int c = hgetc();
        1: 1856:		hungetc(c);
        1: 1857:		if (!iblank(c))
        1: 1858:		    inpush(" ", INP_ALIAS, 0);
        -: 1859:	    }
        2: 1860:	    inpush(an->text, INP_ALIAS, an);
        2: 1861:	    if (an->text[0] == ' ' && !(an->node.flags & ALIAS_GLOBAL))
    #####: 1862:		aliasspaceflag = 1;
        2: 1863:	    lexstop = 0;
        2: 1864:	    return 1;
        -: 1865:	}
     6740: 1866:	if ((suf = strrchr(zshlextext, '.')) && suf[1] &&
      285: 1867:	    suf > zshlextext && suf[-1] != Meta &&
       95: 1868:	    (an = (Alias)sufaliastab->getnode(sufaliastab, suf+1)) &&
    #####: 1869:	    !an->inuse && incmdpos) {
    #####: 1870:	    inpush(dupstring(zshlextext), INP_ALIAS, an);
    #####: 1871:	    inpush(" ", INP_ALIAS, NULL);
    #####: 1872:	    inpush(an->text, INP_ALIAS, NULL);
    #####: 1873:	    lexstop = 0;
    #####: 1874:	    return 1;
        -: 1875:	}
        -: 1876:    }
        -: 1877:
     6826: 1878:    return 0;
        -: 1879:}
        -: 1880:
        -: 1881:/* expand aliases and reserved words */
        -: 1882:
        -: 1883:/**/
        -: 1884:int
     8802: 1885:exalias(void)
        -: 1886:{
        -: 1887:    Reswd rw;
        -: 1888:
     8802: 1889:    hwend();
     8836: 1890:    if (interact && isset(SHINSTDIN) && !strin && incasepat <= 0 &&
       62: 1891:	tok == STRING && !nocorrect && !(inbufflags & INP_ALIAS) &&
       26: 1892:	!hist_is_in_word()  &&
       26: 1893:	(isset(CORRECTALL) || (isset(CORRECT) && incmdpos)))
    #####: 1894:	spckword(&tokstr, 1, incmdpos, 1);
        -: 1895:
     8802: 1896:    if (!tokstr) {
     2552: 1897:	zshlextext = tokstrings[tok];
        -: 1898:
     2552: 1899:	if (tok == NEWLIN)
     1519: 1900:	    return 0;
     1033: 1901:	return checkalias();
        -: 1902:    } else {
     6250: 1903:	VARARR(char, copy, (strlen(tokstr) + 1));
        -: 1904:
     6250: 1905:	if (has_token(tokstr)) {
        -: 1906:	    char *p, *t;
        -: 1907:
     3185: 1908:	    zshlextext = p = copy;
    36578: 1909:	    for (t = tokstr;
    33393: 1910:		 (*p++ = itok(*t) ? ztokens[*t++ - Pound] : *t++););
        -: 1911:	} else
     3065: 1912:	    zshlextext = tokstr;
        -: 1913:
     6250: 1914:	if ((lexflags & LEXFLAGS_ZLE) && !(inbufflags & INP_ALIAS)) {
    #####: 1915:	    int zp = lexflags;
        -: 1916:
    #####: 1917:	    gotword();
    #####: 1918:	    if ((zp & LEXFLAGS_ZLE) && !lexflags) {
    #####: 1919:		if (zshlextext == copy)
    #####: 1920:		    zshlextext = tokstr;
    #####: 1921:		return 0;
        -: 1922:	    }
        -: 1923:	}
        -: 1924:
     6250: 1925:	if (tok == STRING) {
        -: 1926:	    /* Check for an alias */
     5796: 1927:	    if ((zshlextext != copy || !isset(POSIXALIASES)) && checkalias()) {
        2: 1928:		if (zshlextext == copy)
        2: 1929:		    zshlextext = tokstr;
        2: 1930:		return 1;
        -: 1931:	    }
        -: 1932:
        -: 1933:	    /* Then check for a reserved word */
     9595: 1934:	    if ((incmdpos ||
    11401: 1935:		 (unset(IGNOREBRACES) && unset(IGNORECLOSEBRACES) &&
     5798: 1936:		  zshlextext[0] == '}' && !zshlextext[1])) &&
     1995: 1937:		(rw = (Reswd) reswdtab->getnode(reswdtab, zshlextext))) {
      503: 1938:		tok = rw->token;
      503: 1939:		inrepeat_ = (tok == REPEAT);
     1006: 1940:		if (tok == DINBRACK)
       67: 1941:		    incond = 1;
     5291: 1942:	    } else if (incond && !strcmp(zshlextext, "]]")) {
       67: 1943:		tok = DOUTBRACK;
       67: 1944:		incond = 0;
     5224: 1945:	    } else if (incond == 1 && zshlextext[0] == '!' && !zshlextext[1])
        1: 1946:		tok = BANG;
        -: 1947:	}
     6248: 1948:	inalmore = 0;
     6248: 1949:	if (zshlextext == copy)
     3183: 1950:	    zshlextext = tokstr;
        -: 1951:    }
     6248: 1952:    return 0;
        -: 1953:}
        -: 1954:
        -: 1955:/**/
        -: 1956:void
    84053: 1957:zshlex_raw_add(int c)
        -: 1958:{
    84053: 1959:    if (!lex_add_raw)
    82974: 1960:	return;
        -: 1961:
     1079: 1962:    *lexbuf_raw.ptr++ = c;
     1079: 1963:    if (lexbuf_raw.siz == ++lexbuf_raw.len) {
       11: 1964:	int newbsiz = lexbuf_raw.siz * 2;
        -: 1965:
       11: 1966:	tokstr_raw = (char *)hrealloc(tokstr_raw, lexbuf_raw.siz, newbsiz);
       11: 1967:	lexbuf_raw.ptr = tokstr_raw + lexbuf_raw.len;
       11: 1968:	memset(lexbuf_raw.ptr, 0, newbsiz - lexbuf_raw.siz);
       11: 1969:	lexbuf_raw.siz = newbsiz;
        -: 1970:    }
        -: 1971:}
        -: 1972:
        -: 1973:/**/
        -: 1974:void
     8352: 1975:zshlex_raw_back(void)
        -: 1976:{
     8352: 1977:    if (!lex_add_raw)
     8083: 1978:	return;
      269: 1979:    lexbuf_raw.ptr--;
      269: 1980:    lexbuf_raw.len--;
        -: 1981:}
        -: 1982:
        -: 1983:/**/
        -: 1984:int
      210: 1985:zshlex_raw_mark(int offset)
        -: 1986:{
      210: 1987:    if (!lex_add_raw)
      210: 1988:	return 0;
    #####: 1989:    return lexbuf_raw.len + offset;
        -: 1990:}
        -: 1991:
        -: 1992:/**/
        -: 1993:void
    #####: 1994:zshlex_raw_back_to_mark(int mark)
        -: 1995:{
    #####: 1996:    if (!lex_add_raw)
    #####: 1997:	return;
    #####: 1998:    lexbuf_raw.ptr = tokstr_raw + mark;
    #####: 1999:    lexbuf_raw.len = mark;
        -: 2000:}
        -: 2001:
        -: 2002:/*
        -: 2003: * Skip (...) for command-style substitutions: $(...), <(...), >(...)
        -: 2004: *
        -: 2005: * In order to ensure we don't stop at closing parentheses with
        -: 2006: * some other syntactic significance, we'll parse the input until
        -: 2007: * we find an unmatched closing parenthesis.  However, we'll throw
        -: 2008: * away the result of the parsing and just keep the string we've built
        -: 2009: * up on the way.
        -: 2010: */
        -: 2011:
        -: 2012:/**/
        -: 2013:static int
       48: 2014:skipcomm(void)
        -: 2015:{
        -: 2016:#ifdef ZSH_OLD_SKIPCOMM
        -: 2017:    int pct = 1, c, start = 1;
        -: 2018:
        -: 2019:    cmdpush(CS_CMDSUBST);
        -: 2020:    SETPARBEGIN
        -: 2021:    c = Inpar;
        -: 2022:    do {
        -: 2023:	int iswhite;
        -: 2024:	add(c);
        -: 2025:	c = hgetc();
        -: 2026:	if (itok(c) || lexstop)
        -: 2027:	    break;
        -: 2028:	iswhite = inblank(c);
        -: 2029:	switch (c) {
        -: 2030:	case '(':
        -: 2031:	    pct++;
        -: 2032:	    break;
        -: 2033:	case ')':
        -: 2034:	    pct--;
        -: 2035:	    break;
        -: 2036:	case '\\':
        -: 2037:	    add(c);
        -: 2038:	    c = hgetc();
        -: 2039:	    break;
        -: 2040:	case '\'': {
        -: 2041:	    int strquote = lexbuf.ptr[-1] == '$';
        -: 2042:	    add(c);
        -: 2043:	    STOPHIST
        -: 2044:	    while ((c = hgetc()) != '\'' && !lexstop) {
        -: 2045:		if (c == '\\' && strquote) {
        -: 2046:		    add(c);
        -: 2047:		    c = hgetc();
        -: 2048:		}
        -: 2049:		add(c);
        -: 2050:	    }
        -: 2051:	    ALLOWHIST
        -: 2052:	    break;
        -: 2053:	}
        -: 2054:	case '\"':
        -: 2055:	    add(c);
        -: 2056:	    while ((c = hgetc()) != '\"' && !lexstop)
        -: 2057:		if (c == '\\') {
        -: 2058:		    add(c);
        -: 2059:		    add(hgetc());
        -: 2060:		} else
        -: 2061:		    add(c);
        -: 2062:	    break;
        -: 2063:	case '`':
        -: 2064:	    add(c);
        -: 2065:	    while ((c = hgetc()) != '`' && !lexstop)
        -: 2066:		if (c == '\\')
        -: 2067:		    add(c), add(hgetc());
        -: 2068:		else
        -: 2069:		    add(c);
        -: 2070:	    break;
        -: 2071:	case '#':
        -: 2072:	    if (start) {
        -: 2073:		add(c);
        -: 2074:		while ((c = hgetc()) != '\n' && !lexstop)
        -: 2075:		    add(c);
        -: 2076:		iswhite = 1;
        -: 2077:	    }
        -: 2078:	    break;
        -: 2079:	}
        -: 2080:	start = iswhite;
        -: 2081:    }
        -: 2082:    while (pct);
        -: 2083:    if (!lexstop)
        -: 2084:	SETPAREND
        -: 2085:    cmdpop();
        -: 2086:    return lexstop;
        -: 2087:#else
        -: 2088:    char *new_tokstr;
        -: 2089:    int new_lexstop, new_lex_add_raw;
       48: 2090:    int save_infor = infor;
        -: 2091:    struct lexbufstate new_lexbuf;
        -: 2092:
       48: 2093:    infor = 0;
       48: 2094:    cmdpush(CS_CMDSUBST);
       48: 2095:    SETPARBEGIN
       48: 2096:    add(Inpar);
        -: 2097:
       48: 2098:    new_lex_add_raw = lex_add_raw + 1;
       48: 2099:    if (!lex_add_raw) {
        -: 2100:	/*
        -: 2101:	 * We'll combine the string so far with the input
        -: 2102:	 * read in for the command substitution.  To do this
        -: 2103:	 * we'll just propagate the current tokstr etc. as the
        -: 2104:	 * variables used for adding raw input, and
        -: 2105:	 * ensure we swap those for the real tokstr etc. at the end.
        -: 2106:	 *
        -: 2107:	 * However, we need to save and restore the rest of the
        -: 2108:	 * lexical and parse state as we're effectively parsing
        -: 2109:	 * an internal string.  Because we're still parsing it from
        -: 2110:	 * the original input source (we have to --- we don't know
        -: 2111:	 * when to stop inputting it otherwise and can't rely on
        -: 2112:	 * the input being recoverable until we've read it) we need
        -: 2113:	 * to keep the same history context.
        -: 2114:	 */
       48: 2115:	new_tokstr = tokstr;
       48: 2116:	new_lexbuf = lexbuf;
        -: 2117:
        -: 2118:	/*
        -: 2119:	 * If we're expanding an alias at this point, we need the whole
        -: 2120:	 * remaining text as part of the string for the command in
        -: 2121:	 * parentheses, so don't backtrack.  This is different from the
        -: 2122:	 * usual case where the alias is fully within the command, where
        -: 2123:	 * we want the unexpanded text so that it will be expanded
        -: 2124:	 * again when the command in the parentheses is executed.
        -: 2125:	 *
        -: 2126:	 * I never wanted to be a software engineer, you know.
        -: 2127:	 */
       48: 2128:	if (inbufflags & INP_ALIAS)
    #####: 2129:	    inbufflags |= INP_RAW_KEEP;
       48: 2130:	zcontext_save_partial(ZCONTEXT_LEX|ZCONTEXT_PARSE);
       48: 2131:	hist_in_word(1);
        -: 2132:    } else {
        -: 2133:	/*
        -: 2134:	 * Set up for nested command substitution, however
        -: 2135:	 * we don't actually need the string until we get
        -: 2136:	 * back to the top level and recover the lot.
        -: 2137:	 * The $() body just appears empty.
        -: 2138:	 *
        -: 2139:	 * We do need to propagate the raw variables which would
        -: 2140:	 * otherwise by cleared, though.
        -: 2141:	 */
    #####: 2142:	new_tokstr = tokstr_raw;
    #####: 2143:	new_lexbuf = lexbuf_raw;
        -: 2144:
    #####: 2145:	zcontext_save_partial(ZCONTEXT_LEX|ZCONTEXT_PARSE);
        -: 2146:    }
       48: 2147:    tokstr_raw = new_tokstr;
       48: 2148:    lexbuf_raw = new_lexbuf;
       48: 2149:    lex_add_raw = new_lex_add_raw;
        -: 2150:    /*
        -: 2151:     * Don't do any ZLE specials down here: they're only needed
        -: 2152:     * when we return the string from the recursive parse.
        -: 2153:     * (TBD: this probably means we should be initialising lexflags
        -: 2154:     * more consistently.)
        -: 2155:     *
        -: 2156:     * Note that in that case we're still using the ZLE line reading
        -: 2157:     * function at the history layer --- this is consistent with the
        -: 2158:     * intention of maintaining the history and input layers across
        -: 2159:     * the recursive parsing.
        -: 2160:     *
        -: 2161:     * Also turn off LEXFLAGS_NEWLINE because this is already skipping
        -: 2162:     * across the entire construct, and parse_event() needs embedded
        -: 2163:     * newlines to be "real" when looking for the OUTPAR token.
        -: 2164:     */
       48: 2165:    lexflags &= ~(LEXFLAGS_ZLE|LEXFLAGS_NEWLINE);
       48: 2166:    dbparens = 0;	/* restored by zcontext_restore_partial() */
        -: 2167:
       48: 2168:    if (!parse_event(OUTPAR) || tok != OUTPAR) {
        2: 2169:	if (strin) {
        -: 2170:	    /*
        -: 2171:	     * Get the rest of the string raw since we don't
        -: 2172:	     * know where this token ends.
        -: 2173:	     */
        5: 2174:	    while (!lexstop)
        1: 2175:		(void)ingetc();
        -: 2176:	} else
    #####: 2177:	    lexstop = 1;
        -: 2178:    }
        -: 2179:     /* Outpar lexical token gets added in caller if present */
        -: 2180:
        -: 2181:    /*
        -: 2182:     * We're going to keep the full raw input string
        -: 2183:     * as the current token string after popping the stack.
        -: 2184:     */
       48: 2185:    new_tokstr = tokstr_raw;
       48: 2186:    new_lexbuf = lexbuf_raw;
        -: 2187:    /*
        -: 2188:     * We're also going to propagate the lexical state:
        -: 2189:     * if we couldn't parse the command substitution we
        -: 2190:     * can't continue.
        -: 2191:     */
       48: 2192:    new_lexstop = lexstop;
        -: 2193:
       48: 2194:    zcontext_restore_partial(ZCONTEXT_LEX|ZCONTEXT_PARSE);
        -: 2195:
       48: 2196:    if (lex_add_raw) {
        -: 2197:	/*
        -: 2198:	 * Keep going, so retain the raw variables.
        -: 2199:	 */
    #####: 2200:	tokstr_raw = new_tokstr;
    #####: 2201:	lexbuf_raw = new_lexbuf;
        -: 2202:    } else {
       48: 2203:	if (!new_lexstop) {
        -: 2204:	    /* Ignore the ')' added on input */
       46: 2205:	    new_lexbuf.len--;
       46: 2206:	    *--new_lexbuf.ptr = '\0';
        -: 2207:	}
        -: 2208:
        -: 2209:	/*
        -: 2210:	 * Convince the rest of lex.c we were examining a string
        -: 2211:	 * all along.
        -: 2212:	 */
       48: 2213:	tokstr = new_tokstr;
       48: 2214:	lexbuf = new_lexbuf;
       48: 2215:	lexstop = new_lexstop;
       48: 2216:	hist_in_word(0);
        -: 2217:    }
        -: 2218:
       48: 2219:    if (!lexstop)
       46: 2220:	SETPAREND
       48: 2221:    cmdpop();
       48: 2222:    infor = save_infor;
        -: 2223:
       48: 2224:    return lexstop;
        -: 2225:#endif
        -: 2226:}
