        -:    0:Source:/home/workspace/test/test1.cc
        -:    0:Programs:4
        -:    1:﻿#include "catch.hh"
        -:    2:#include <peglib.h>
        -:    3:
        -:    4:using namespace peg;
        -:    5:
        -:    6:#if !defined(PEGLIB_NO_UNICODE_CHARS)
        1:    7:TEST_CASE("Simple syntax test (with unicode)", "[general]")
        -:    8:{
        -:    9:    parser parser(
        -:   10:        u8" ROOT ← _ "
        -:   11:        " _ <- ' ' "
    #####:   12:    );
        -:   13:
    #####:   14:    bool ret = parser;
    #####:   15:    REQUIRE(ret == true);
    #####:   16:}
        -:   17:#endif
        -:   18:
        1:   19:TEST_CASE("Simple syntax test", "[general]")
        -:   20:{
        -:   21:    parser parser(R"(
        -:   22:        ROOT <- _
        -:   23:        _ <- ' '
    #####:   24:    )");
        -:   25:
    #####:   26:    bool ret = parser;
    #####:   27:    REQUIRE(ret == true);
    #####:   28:}
        -:   29:
        1:   30:TEST_CASE("Empty syntax test", "[general]")
        -:   31:{
    #####:   32:    parser parser("");
    #####:   33:    bool ret = parser;
    #####:   34:    REQUIRE(ret == false);
    #####:   35:}
        -:   36:
        1:   37:TEST_CASE("Start rule with ignore operator test", "[general]")
        -:   38:{
        -:   39:    parser parser(R"(
        -:   40:        ~ROOT <- _
        -:   41:        _ <- ' '
    #####:   42:    )");
        -:   43:
    #####:   44:    bool ret = parser;
    #####:   45:    REQUIRE(ret == false);
    #####:   46:}
        -:   47:
        1:   48:TEST_CASE("Backslash escape sequence test", "[general]")
        -:   49:{
        -:   50:    parser parser(R"(
        -:   51:        ROOT <- _
        -:   52:        _ <- '\\'
    #####:   53:    )");
        -:   54:
    #####:   55:    bool ret = parser;
    #####:   56:    REQUIRE(ret == true);
    #####:   57:}
        -:   58:
        2:   59:TEST_CASE("Invalid escape sequence test", "[general]")
        -:   60:{
        -:   61:    parser parser(R"(
        -:   62:        ROOT <- _
        -:   63:        _ <- '\'
        2:   64:    )");
        -:   65:
        1:   66:    bool ret = parser;
        1:   67:    REQUIRE(ret == false);
        1:   68:}
        -:   69:
        1:   70:TEST_CASE("Action taking non const Semantic Values parameter", "[general]")
        -:   71:{
        -:   72:    parser parser(R"(
        -:   73:        ROOT <- TEXT
        -:   74:        TEXT <- [a-zA-Z]+
    #####:   75:    )");
        -:   76:
    #####:   77:    parser["ROOT"] = [&](SemanticValues& sv) {
    #####:   78:        auto s = any_cast<std::string>(sv[0]);
    #####:   79:        s[0] = 'H'; // mutate
    #####:   80:        return std::string(std::move(s)); // move
        -:   81:    };
        -:   82:
    #####:   83:    parser["TEXT"] = [&](SemanticValues& sv) {
        -:   84:        return sv.token();
    #####:   85:    };
        -:   86:
    #####:   87:    std::string val;
    #####:   88:    auto ret = parser.parse("hello", val);
    #####:   89:    REQUIRE(ret == true);
    #####:   90:    REQUIRE(val == "Hello");
    #####:   91:}
        -:   92:
        1:   93:TEST_CASE("String capture test", "[general]")
        -:   94:{
        -:   95:    parser parser(R"(
        -:   96:        ROOT      <-  _ ('[' TAG_NAME ']' _)*
        -:   97:        TAG_NAME  <-  (!']' .)+
        -:   98:        _         <-  [ \t]*
    #####:   99:    )");
        -:  100:
    #####:  101:    std::vector<std::string> tags;
        -:  102:
    #####:  103:    parser["TAG_NAME"] = [&](const SemanticValues& sv) {
    #####:  104:        tags.push_back(sv.str());
    #####:  105:    };
        -:  106:
    #####:  107:    auto ret = parser.parse(" [tag1] [tag:2] [tag-3] ");
        -:  108:
    #####:  109:    REQUIRE(ret == true);
    #####:  110:    REQUIRE(tags.size() == 3);
    #####:  111:    REQUIRE(tags[0] == "tag1");
    #####:  112:    REQUIRE(tags[1] == "tag:2");
    #####:  113:    REQUIRE(tags[2] == "tag-3");
    #####:  114:}
        -:  115:
        -:  116:using namespace peg;
        -:  117:
        1:  118:TEST_CASE("String capture test2", "[general]")
        -:  119:{
    #####:  120:    std::vector<std::string> tags;
        -:  121:
    #####:  122:    Definition ROOT, TAG, TAG_NAME, WS;
    #####:  123:    ROOT     <= seq(WS, zom(TAG));
    #####:  124:    TAG      <= seq(chr('['), TAG_NAME, chr(']'), WS);
    #####:  125:    TAG_NAME <= oom(seq(npd(chr(']')), dot())), [&](const SemanticValues& sv) { tags.push_back(sv.str()); };
    #####:  126:    WS       <= zom(cls(" \t"));
        -:  127:
    #####:  128:    auto r = ROOT.parse(" [tag1] [tag:2] [tag-3] ");
        -:  129:
    #####:  130:    REQUIRE(r.ret == true);
    #####:  131:    REQUIRE(tags.size() == 3);
    #####:  132:    REQUIRE(tags[0] == "tag1");
    #####:  133:    REQUIRE(tags[1] == "tag:2");
    #####:  134:    REQUIRE(tags[2] == "tag-3");
    #####:  135:}
        -:  136:
        1:  137:TEST_CASE("String capture test3", "[general]")
        -:  138:{
        -:  139:    parser pg(R"(
        -:  140:        ROOT  <- _ TOKEN*
        -:  141:        TOKEN <- '[' < (!']' .)+ > ']' _
        -:  142:        _     <- [ \t\r\n]*
    #####:  143:    )");
        -:  144:
        -:  145:
    #####:  146:    std::vector<std::string> tags;
        -:  147:
    #####:  148:    pg["TOKEN"] = [&](const SemanticValues& sv) {
    #####:  149:        tags.push_back(sv.token());
    #####:  150:    };
        -:  151:
    #####:  152:    auto ret = pg.parse(" [tag1] [tag:2] [tag-3] ");
        -:  153:
    #####:  154:    REQUIRE(ret == true);
    #####:  155:    REQUIRE(tags.size() == 3);
    #####:  156:    REQUIRE(tags[0] == "tag1");
    #####:  157:    REQUIRE(tags[1] == "tag:2");
    #####:  158:    REQUIRE(tags[2] == "tag-3");
    #####:  159:}
        -:  160:
        1:  161:TEST_CASE("Cyclic grammer test", "[general]")
        -:  162:{
    #####:  163:    Definition PARENT;
    #####:  164:    Definition CHILD;
        -:  165:
    #####:  166:    PARENT <= seq(CHILD);
    #####:  167:    CHILD  <= seq(PARENT);
    #####:  168:}
        -:  169:
        1:  170:TEST_CASE("Visit test", "[general]")
        -:  171:{
    #####:  172:    Definition ROOT, TAG, TAG_NAME, WS;
        -:  173:
    #####:  174:    ROOT     <= seq(WS, zom(TAG));
    #####:  175:    TAG      <= seq(chr('['), TAG_NAME, chr(']'), WS);
    #####:  176:    TAG_NAME <= oom(seq(npd(chr(']')), dot()));
    #####:  177:    WS       <= zom(cls(" \t"));
        -:  178:
    #####:  179:    AssignIDToDefinition defIds;
    #####:  180:    ROOT.accept(defIds);
        -:  181:
    #####:  182:    REQUIRE(defIds.ids.size() == 4);
    #####:  183:}
        -:  184:
        1:  185:TEST_CASE("Token check test", "[general]")
        -:  186:{
        -:  187:    parser parser(R"(
        -:  188:        EXPRESSION       <-  _ TERM (TERM_OPERATOR TERM)*
        -:  189:        TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*
        -:  190:        FACTOR           <-  NUMBER / '(' _ EXPRESSION ')' _
        -:  191:        TERM_OPERATOR    <-  < [-+] > _
        -:  192:        FACTOR_OPERATOR  <-  < [/*] > _
        -:  193:        NUMBER           <-  < [0-9]+ > _
        -:  194:        _                <-  [ \t\r\n]*
    #####:  195:    )");
        -:  196:
    #####:  197:    REQUIRE(parser["EXPRESSION"].is_token() == false);
    #####:  198:    REQUIRE(parser["FACTOR"].is_token() == false);
    #####:  199:    REQUIRE(parser["FACTOR_OPERATOR"].is_token() == true);
    #####:  200:    REQUIRE(parser["NUMBER"].is_token() == true);
    #####:  201:    REQUIRE(parser["_"].is_token() == true);
    #####:  202:}
        -:  203:
        1:  204:TEST_CASE("Lambda action test", "[general]")
        -:  205:{
        -:  206:    parser parser(R"(
        -:  207:       START <- (CHAR)*
        -:  208:       CHAR  <- .
    #####:  209:    )");
        -:  210:
    #####:  211:    std::string ss;
    #####:  212:    parser["CHAR"] = [&](const SemanticValues& sv) {
    #####:  213:        ss += *sv.c_str();
    #####:  214:    };
        -:  215:
    #####:  216:    bool ret = parser.parse("hello");
    #####:  217:    REQUIRE(ret == true);
    #####:  218:    REQUIRE(ss == "hello");
    #####:  219:}
        -:  220:
        1:  221:TEST_CASE("enter/leave handlers test", "[general]")
        -:  222:{
        -:  223:    parser parser(R"(
        -:  224:        START  <- LTOKEN '=' RTOKEN
        -:  225:        LTOKEN <- TOKEN
        -:  226:        RTOKEN <- TOKEN
        -:  227:        TOKEN  <- [A-Za-z]+
    #####:  228:    )");
        -:  229:
    #####:  230:    parser["LTOKEN"].enter = [&](const char*, size_t, any& dt) {
    #####:  231:        auto& require_upper_case = *any_cast<bool*>(dt);
    #####:  232:        require_upper_case = false;
    #####:  233:    };
    #####:  234:    parser["LTOKEN"].leave = [&](const char*, size_t, size_t, any&, any& dt) {
    #####:  235:        auto& require_upper_case = *any_cast<bool*>(dt);
    #####:  236:        require_upper_case = true;
    #####:  237:    };
        -:  238:
    #####:  239:    auto message = "should be upper case string...";
        -:  240:
    #####:  241:    parser["TOKEN"] = [&](const SemanticValues& sv, any& dt) {
    #####:  242:        auto& require_upper_case = *any_cast<bool*>(dt);
    #####:  243:        if (require_upper_case) {
    #####:  244:            const auto& s = sv.str();
    #####:  245:            if (!std::all_of(s.begin(), s.end(), ::isupper)) {
    #####:  246:                throw parse_error(message);
        -:  247:            }
        -:  248:        }
    #####:  249:    };
        -:  250:
    #####:  251:    bool require_upper_case = false;
    #####:  252:    any dt = &require_upper_case;
    #####:  253:    REQUIRE(parser.parse("hello=world", dt) == false);
    #####:  254:    REQUIRE(parser.parse("HELLO=world", dt) == false);
    #####:  255:    REQUIRE(parser.parse("hello=WORLD", dt) == true);
    #####:  256:    REQUIRE(parser.parse("HELLO=WORLD", dt) == true);
        -:  257:
    #####:  258:    parser.log = [&](size_t ln, size_t col, const std::string& msg) {
    #####:  259:        REQUIRE(ln == 1);
    #####:  260:        REQUIRE(col == 7);
    #####:  261:        REQUIRE(msg == message);
    #####:  262:    };
    #####:  263:    parser.parse("hello=world", dt);
    #####:  264:}
        -:  265:
        1:  266:TEST_CASE("WHITESPACE test", "[general]")
        -:  267:{
        -:  268:    parser parser(R"(
        -:  269:        # Rules
        -:  270:        ROOT         <-  ITEM (',' ITEM)*
        -:  271:        ITEM         <-  WORD / PHRASE
        -:  272:
        -:  273:        # Tokens
        -:  274:        WORD         <-  < [a-zA-Z0-9_]+ >
        -:  275:        PHRASE       <-  < '"' (!'"' .)* '"' >
        -:  276:
        -:  277:        %whitespace  <-  [ \t\r\n]*
    #####:  278:    )");
        -:  279:
    #####:  280:    auto ret = parser.parse(R"(  one, 	 "two, three",   four  )");
        -:  281:
    #####:  282:    REQUIRE(ret == true);
    #####:  283:}
        -:  284:
        1:  285:TEST_CASE("WHITESPACE test2", "[general]")
        -:  286:{
        -:  287:    parser parser(R"(
        -:  288:        # Rules
        -:  289:        ROOT         <-  ITEM (',' ITEM)*
        -:  290:        ITEM         <-  '[' < [a-zA-Z0-9_]+ > ']'
        -:  291:
        -:  292:        %whitespace  <-  (SPACE / TAB)*
        -:  293:        SPACE        <-  ' '
        -:  294:        TAB          <-  '\t'
    #####:  295:    )");
        -:  296:
    #####:  297:    std::vector<std::string> items;
    #####:  298:    parser["ITEM"] = [&](const SemanticValues& sv) {
    #####:  299:        items.push_back(sv.token());
    #####:  300:    };
        -:  301:
    #####:  302:    auto ret = parser.parse(R"([one], 	[two] ,[three] )");
        -:  303:
    #####:  304:    REQUIRE(ret == true);
    #####:  305:    REQUIRE(items.size() == 3);
    #####:  306:    REQUIRE(items[0] == "one");
    #####:  307:    REQUIRE(items[1] == "two");
    #####:  308:    REQUIRE(items[2] == "three");
    #####:  309:}
        -:  310:
        1:  311:TEST_CASE("WHITESPACE test3", "[general]") {
        -:  312:    parser parser(R"(
        -:  313:        StrQuot      <- < '"' < (StrEscape / StrChars)* > '"' >
        -:  314:        StrEscape    <- '\\' any
        -:  315:        StrChars     <- (!'"' !'\\' any)+
        -:  316:        any          <- .
        -:  317:        %whitespace  <- [ \t]*
    #####:  318:    )");
        -:  319:
    #####:  320:    parser["StrQuot"] = [](const SemanticValues& sv) {
    #####:  321:        REQUIRE(sv.token() == R"(  aaa \" bbb  )");
    #####:  322:    };
        -:  323:
    #####:  324:    auto ret = parser.parse(R"( "  aaa \" bbb  " )");
    #####:  325:    REQUIRE(ret == true);
    #####:  326:}
        -:  327:
        1:  328:TEST_CASE("WHITESPACE test4", "[general]") {
        -:  329:    parser parser(R"(
        -:  330:        ROOT         <-  HELLO OPE WORLD
        -:  331:        HELLO        <-  'hello'
        -:  332:        OPE          <-  < [-+] >
        -:  333:        WORLD        <-  'world' / 'WORLD'
        -:  334:        %whitespace  <-  [ \t\r\n]*
    #####:  335:    )");
        -:  336:
    #####:  337:    parser["HELLO"] = [](const SemanticValues& sv) {
    #####:  338:        REQUIRE(sv.token() == "hello");
    #####:  339:    };
        -:  340:
    #####:  341:    parser["OPE"] = [](const SemanticValues& sv) {
    #####:  342:        REQUIRE(sv.token() == "+");
    #####:  343:    };
        -:  344:
    #####:  345:    parser["WORLD"] = [](const SemanticValues& sv) {
    #####:  346:        REQUIRE(sv.token() == "world");
    #####:  347:    };
        -:  348:
    #####:  349:    auto ret = parser.parse("  hello + world  ");
    #####:  350:    REQUIRE(ret == true);
    #####:  351:}
        -:  352:
        1:  353:TEST_CASE("Word expression test", "[general]") {
        -:  354:    parser parser(R"(
        -:  355:        ROOT         <-  'hello' ','? 'world'
        -:  356:        %whitespace  <-  [ \t\r\n]*
        -:  357:        %word        <-  [a-z]+
    #####:  358:    )");
        -:  359:
    #####:  360:	REQUIRE(parser.parse("helloworld") == false);
    #####:  361:	REQUIRE(parser.parse("hello world") == true);
    #####:  362:	REQUIRE(parser.parse("hello,world") == true);
    #####:  363:	REQUIRE(parser.parse("hello, world") == true);
    #####:  364:	REQUIRE(parser.parse("hello , world") == true);
    #####:  365:}
        -:  366:
        1:  367:TEST_CASE("Skip token test", "[general]")
        -:  368:{
        -:  369:    parser parser(
        -:  370:        "  ROOT  <-  _ ITEM (',' _ ITEM _)* "
        -:  371:        "  ITEM  <-  ([a-z0-9])+  "
        -:  372:        "  ~_    <-  [ \t]*    "
    #####:  373:    );
        -:  374:
    #####:  375:    parser["ROOT"] = [&](const SemanticValues& sv) {
    #####:  376:        REQUIRE(sv.size() == 2);
    #####:  377:    };
        -:  378:
    #####:  379:    auto ret = parser.parse(" item1, item2 ");
        -:  380:
    #####:  381:    REQUIRE(ret == true);
    #####:  382:}
        -:  383:
        1:  384:TEST_CASE("Skip token test2", "[general]")
        -:  385:{
        -:  386:    parser parser(R"(
        -:  387:        ROOT        <-  ITEM (',' ITEM)*
        -:  388:        ITEM        <-  < ([a-z0-9])+ >
        -:  389:        %whitespace <-  [ \t]*
    #####:  390:    )");
        -:  391:
    #####:  392:    parser["ROOT"] = [&](const SemanticValues& sv) {
    #####:  393:        REQUIRE(sv.size() == 2);
    #####:  394:    };
        -:  395:
    #####:  396:    auto ret = parser.parse(" item1, item2 ");
        -:  397:
    #####:  398:    REQUIRE(ret == true);
    #####:  399:}
        -:  400:
        1:  401:TEST_CASE("Custom AST test", "[general]")
        -:  402:{
        -:  403:	struct CustomType {};
        -:  404:	using CustomAst = AstBase<CustomType>;
        -:  405:	
        -:  406:    parser parser(R"(
        -:  407:        ROOT <- _ TEXT*
        -:  408:        TEXT <- [a-zA-Z]+ _
        -:  409:        _ <- [ \t\r\n]*
    #####:  410:    )");
        -:  411:
    #####:  412:    parser.enable_ast<CustomAst>();
    #####:  413:    std::shared_ptr<CustomAst> ast;
    #####:  414:    bool ret = parser.parse("a b c", ast);
    #####:  415:    REQUIRE(ret == true);
    #####:  416:    REQUIRE(ast->nodes.size() == 4);
    #####:  417:}
        -:  418:
        1:  419:TEST_CASE("Backtracking test", "[general]")
        -:  420:{
        -:  421:    parser parser(R"(
        -:  422:       START <- PAT1 / PAT2
        -:  423:       PAT1  <- HELLO ' One'
        -:  424:       PAT2  <- HELLO ' Two'
        -:  425:       HELLO <- 'Hello'
    #####:  426:    )");
        -:  427:
    #####:  428:    size_t count = 0;
    #####:  429:    parser["HELLO"] = [&](const SemanticValues& /*sv*/) {
    #####:  430:        count++;
    #####:  431:    };
        -:  432:
    #####:  433:    parser.enable_packrat_parsing();
        -:  434:
    #####:  435:    bool ret = parser.parse("Hello Two");
    #####:  436:    REQUIRE(ret == true);
    #####:  437:    REQUIRE(count == 1); // Skip second time
    #####:  438:}
        -:  439:
        1:  440:TEST_CASE("Backtracking with AST", "[general]")
        -:  441:{
        -:  442:    parser parser(R"(
        -:  443:        S <- A? B (A B)* A
        -:  444:        A <- 'a'
        -:  445:        B <- 'b'
    #####:  446:    )");
        -:  447:
    #####:  448:    parser.enable_ast();
    #####:  449:    std::shared_ptr<Ast> ast;
    #####:  450:    bool ret = parser.parse("ba", ast);
    #####:  451:    REQUIRE(ret == true);
    #####:  452:    REQUIRE(ast->nodes.size() == 2);
    #####:  453:}
        -:  454:
        1:  455:TEST_CASE("Octal/Hex/Unicode value test", "[general]")
        -:  456:{
        -:  457:    parser parser(
        -:  458:        R"( ROOT <- '\132\x7a\u30f3' )"
    #####:  459:    );
        -:  460:
    #####:  461:    auto ret = parser.parse("Zzン");
        -:  462:
    #####:  463:    REQUIRE(ret == true);
    #####:  464:}
        -:  465:
        1:  466:TEST_CASE("Ignore case test", "[general]") {
        -:  467:    parser parser(R"(
        -:  468:        ROOT         <-  HELLO WORLD
        -:  469:        HELLO        <-  'hello'i
        -:  470:        WORLD        <-  'world'i
        -:  471:        %whitespace  <-  [ \t\r\n]*
    #####:  472:    )");
        -:  473:
    #####:  474:    parser["HELLO"] = [](const SemanticValues& sv) {
    #####:  475:        REQUIRE(sv.token() == "Hello");
    #####:  476:    };
        -:  477:
    #####:  478:    parser["WORLD"] = [](const SemanticValues& sv) {
    #####:  479:        REQUIRE(sv.token() == "World");
    #####:  480:    };
        -:  481:
    #####:  482:    auto ret = parser.parse("  Hello World  ");
    #####:  483:    REQUIRE(ret == true);
    #####:  484:}
        -:  485:
        1:  486:TEST_CASE("mutable lambda test", "[general]")
        -:  487:{
    #####:  488:    std::vector<std::string> vec;
        -:  489:
    #####:  490:    parser pg("ROOT <- 'mutable lambda test'");
        -:  491:
        -:  492:    // This test makes sure if the following code can be compiled.
    #####:  493:    pg["TOKEN"] = [=](const SemanticValues& sv) mutable {
    #####:  494:        vec.push_back(sv.str());
    #####:  495:    };
    #####:  496:}
        -:  497:
        1:  498:TEST_CASE("Simple calculator test", "[general]")
        -:  499:{
        -:  500:    parser parser(R"(
        -:  501:        Additive  <- Multitive '+' Additive / Multitive
        -:  502:        Multitive <- Primary '*' Multitive / Primary
        -:  503:        Primary   <- '(' Additive ')' / Number
        -:  504:        Number    <- [0-9]+
    #####:  505:    )");
        -:  506:
    #####:  507:    parser["Additive"] = [](const SemanticValues& sv) {
    #####:  508:        switch (sv.choice()) {
    #####:  509:        case 0:
    #####:  510:            return any_cast<int>(sv[0]) + any_cast<int>(sv[1]);
    #####:  511:        default:
    #####:  512:            return any_cast<int>(sv[0]);
        -:  513:        }
        -:  514:    };
        -:  515:
    #####:  516:    parser["Multitive"] = [](const SemanticValues& sv) {
    #####:  517:        switch (sv.choice()) {
    #####:  518:        case 0:
    #####:  519:            return any_cast<int>(sv[0]) * any_cast<int>(sv[1]);
    #####:  520:        default:
    #####:  521:            return any_cast<int>(sv[0]);
        -:  522:        }
        -:  523:    };
        -:  524:
    #####:  525:    parser["Number"] = [](const SemanticValues& sv) {
    #####:  526:        return atoi(sv.c_str());
    #####:  527:    };
        -:  528:
        -:  529:    int val;
    #####:  530:    parser.parse("(1+2)*3", val);
        -:  531:
    #####:  532:    REQUIRE(val == 9);
    #####:  533:}
        -:  534:
        1:  535:TEST_CASE("Calculator test", "[general]")
        -:  536:{
        -:  537:    // Construct grammer
    #####:  538:    Definition EXPRESSION, TERM, FACTOR, TERM_OPERATOR, FACTOR_OPERATOR, NUMBER;
        -:  539:
    #####:  540:    EXPRESSION      <= seq(TERM, zom(seq(TERM_OPERATOR, TERM)));
    #####:  541:    TERM            <= seq(FACTOR, zom(seq(FACTOR_OPERATOR, FACTOR)));
    #####:  542:    FACTOR          <= cho(NUMBER, seq(chr('('), EXPRESSION, chr(')')));
    #####:  543:    TERM_OPERATOR   <= cls("+-");
    #####:  544:    FACTOR_OPERATOR <= cls("*/");
    #####:  545:    NUMBER          <= oom(cls("0-9"));
        -:  546:
        -:  547:    // Setup actions
    #####:  548:    auto reduce = [](const SemanticValues& sv) -> long {
    #####:  549:        long ret = any_cast<long>(sv[0]);
    #####:  550:        for (auto i = 1u; i < sv.size(); i += 2) {
    #####:  551:            auto num = any_cast<long>(sv[i + 1]);
    #####:  552:            switch (any_cast<char>(sv[i])) {
    #####:  553:                case '+': ret += num; break;
    #####:  554:                case '-': ret -= num; break;
    #####:  555:                case '*': ret *= num; break;
    #####:  556:                case '/': ret /= num; break;
        -:  557:            }
        -:  558:        }
    #####:  559:        return ret;
        -:  560:    };
        -:  561:
    #####:  562:    EXPRESSION      = reduce;
    #####:  563:    TERM            = reduce;
    #####:  564:    TERM_OPERATOR   = [](const SemanticValues& sv) { return *sv.c_str(); };
    #####:  565:    FACTOR_OPERATOR = [](const SemanticValues& sv) { return *sv.c_str(); };
    #####:  566:    NUMBER          = [](const SemanticValues& sv) { return stol(sv.str(), nullptr, 10); };
        -:  567:
        -:  568:    // Parse
        -:  569:    long val;
    #####:  570:    auto r = EXPRESSION.parse_and_get_value("1+2*3*(4-5+6)/7-8", val);
        -:  571:
    #####:  572:    REQUIRE(r.ret == true);
    #####:  573:    REQUIRE(val == -3);
    #####:  574:}
        -:  575:
        1:  576:TEST_CASE("Calculator test2", "[general]")
        -:  577:{
        -:  578:    // Parse syntax
    #####:  579:    auto syntax = R"(
        -:  580:        # Grammar for Calculator...
        -:  581:        EXPRESSION       <-  TERM (TERM_OPERATOR TERM)*
        -:  582:        TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*
        -:  583:        FACTOR           <-  NUMBER / '(' EXPRESSION ')'
        -:  584:        TERM_OPERATOR    <-  [-+]
        -:  585:        FACTOR_OPERATOR  <-  [/*]
        -:  586:        NUMBER           <-  [0-9]+
        -:  587:    )";
        -:  588:
    #####:  589:    std::string start;
    #####:  590:    auto grammar = ParserGenerator::parse(syntax, strlen(syntax), start, nullptr);
    #####:  591:    auto& g = *grammar;
        -:  592:
        -:  593:    // Setup actions
    #####:  594:    auto reduce = [](const SemanticValues& sv) -> long {
    #####:  595:        long ret = any_cast<long>(sv[0]);
    #####:  596:        for (auto i = 1u; i < sv.size(); i += 2) {
    #####:  597:            auto num = any_cast<long>(sv[i + 1]);
    #####:  598:            switch (any_cast<char>(sv[i])) {
    #####:  599:                case '+': ret += num; break;
    #####:  600:                case '-': ret -= num; break;
    #####:  601:                case '*': ret *= num; break;
    #####:  602:                case '/': ret /= num; break;
        -:  603:            }
        -:  604:        }
    #####:  605:        return ret;
        -:  606:    };
        -:  607:
    #####:  608:    g["EXPRESSION"]      = reduce;
    #####:  609:    g["TERM"]            = reduce;
    #####:  610:    g["TERM_OPERATOR"]   = [](const SemanticValues& sv) { return *sv.c_str(); };
    #####:  611:    g["FACTOR_OPERATOR"] = [](const SemanticValues& sv) { return *sv.c_str(); };
    #####:  612:    g["NUMBER"]          = [](const SemanticValues& sv) { return stol(sv.str(), nullptr, 10); };
        -:  613:
        -:  614:    // Parse
        -:  615:    long val;
    #####:  616:    auto r = g[start].parse_and_get_value("1+2*3*(4-5+6)/7-8", val);
        -:  617:
    #####:  618:    REQUIRE(r.ret == true);
    #####:  619:    REQUIRE(val == -3);
    #####:  620:}
        -:  621:
        1:  622:TEST_CASE("Calculator test3", "[general]")
        -:  623:{
        -:  624:    // Parse syntax
        -:  625:    parser parser(R"(
        -:  626:        # Grammar for Calculator...
        -:  627:        EXPRESSION       <-  TERM (TERM_OPERATOR TERM)*
        -:  628:        TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*
        -:  629:        FACTOR           <-  NUMBER / '(' EXPRESSION ')'
        -:  630:        TERM_OPERATOR    <-  [-+]
        -:  631:        FACTOR_OPERATOR  <-  [/*]
        -:  632:        NUMBER           <-  [0-9]+
    #####:  633:    )");
        -:  634:
    #####:  635:    auto reduce = [](const SemanticValues& sv) -> long {
    #####:  636:        long ret = any_cast<long>(sv[0]);
    #####:  637:        for (auto i = 1u; i < sv.size(); i += 2) {
    #####:  638:            auto num = any_cast<long>(sv[i + 1]);
    #####:  639:            switch (any_cast<char>(sv[i])) {
    #####:  640:                case '+': ret += num; break;
    #####:  641:                case '-': ret -= num; break;
    #####:  642:                case '*': ret *= num; break;
    #####:  643:                case '/': ret /= num; break;
        -:  644:            }
        -:  645:        }
    #####:  646:        return ret;
        -:  647:    };
        -:  648:
        -:  649:    // Setup actions
    #####:  650:    parser["EXPRESSION"]      = reduce;
    #####:  651:    parser["TERM"]            = reduce;
    #####:  652:    parser["TERM_OPERATOR"]   = [](const SemanticValues& sv) { return static_cast<char>(*sv.c_str()); };
    #####:  653:    parser["FACTOR_OPERATOR"] = [](const SemanticValues& sv) { return static_cast<char>(*sv.c_str()); };
    #####:  654:    parser["NUMBER"]          = [](const SemanticValues& sv) { return stol(sv.str(), nullptr, 10); };
        -:  655:
        -:  656:    // Parse
        -:  657:    long val;
    #####:  658:    auto ret = parser.parse("1+2*3*(4-5+6)/7-8", val);
        -:  659:
    #####:  660:    REQUIRE(ret == true);
    #####:  661:    REQUIRE(val == -3);
    #####:  662:}
        -:  663:
        1:  664:TEST_CASE("Calculator test with AST", "[general]")
        -:  665:{
        -:  666:    parser parser(R"(
        -:  667:        EXPRESSION       <-  _ TERM (TERM_OPERATOR TERM)*
        -:  668:        TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*
        -:  669:        FACTOR           <-  NUMBER / '(' _ EXPRESSION ')' _
        -:  670:        TERM_OPERATOR    <-  < [-+] > _
        -:  671:        FACTOR_OPERATOR  <-  < [/*] > _
        -:  672:        NUMBER           <-  < [0-9]+ > _
        -:  673:        ~_               <-  [ \t\r\n]*
    #####:  674:    )");
        -:  675:
    #####:  676:    parser.enable_ast();
        -:  677:
    #####:  678:    std::function<long (const Ast&)> eval = [&](const Ast& ast) {
    #####:  679:        if (ast.name == "NUMBER") {
    #####:  680:            return stol(ast.token);
        -:  681:        } else {
    #####:  682:            const auto& nodes = ast.nodes;
    #####:  683:            auto result = eval(*nodes[0]);
    #####:  684:            for (auto i = 1u; i < nodes.size(); i += 2) {
    #####:  685:                auto num = eval(*nodes[i + 1]);
    #####:  686:                auto ope = nodes[i]->token[0];
    #####:  687:                switch (ope) {
    #####:  688:                    case '+': result += num; break;
    #####:  689:                    case '-': result -= num; break;
    #####:  690:                    case '*': result *= num; break;
    #####:  691:                    case '/': result /= num; break;
        -:  692:                }
        -:  693:            }
    #####:  694:            return result;
        -:  695:        }
    #####:  696:    };
        -:  697:
    #####:  698:    std::shared_ptr<Ast> ast;
    #####:  699:    auto ret = parser.parse("1+2*3*(4-5+6)/7-8", ast);
    #####:  700:    ast = AstOptimizer(true).optimize(ast);
    #####:  701:    auto val = eval(*ast);
        -:  702:
    #####:  703:    REQUIRE(ret == true);
    #####:  704:    REQUIRE(val == -3);
    #####:  705:}
        -:  706:
        1:  707:TEST_CASE("Calculator test with combinators and AST", "[general]") {
        -:  708:  // Construct grammer
    #####:  709:  AST_DEFINITIONS(EXPRESSION, TERM, FACTOR, TERM_OPERATOR, FACTOR_OPERATOR, NUMBER);
        -:  710:
    #####:  711:  EXPRESSION <= seq(TERM, zom(seq(TERM_OPERATOR, TERM)));
    #####:  712:  TERM <= seq(FACTOR, zom(seq(FACTOR_OPERATOR, FACTOR)));
    #####:  713:  FACTOR <= cho(NUMBER, seq(chr('('), EXPRESSION, chr(')')));
    #####:  714:  TERM_OPERATOR <= cls("+-");
    #####:  715:  FACTOR_OPERATOR <= cls("*/");
    #####:  716:  NUMBER <= oom(cls("0-9"));
        -:  717:
    #####:  718:  std::function<long(const Ast &)> eval = [&](const Ast &ast) {
    #####:  719:    if (ast.name == "NUMBER") {
    #####:  720:      return stol(ast.token);
        -:  721:    } else {
    #####:  722:      const auto &nodes = ast.nodes;
    #####:  723:      auto result = eval(*nodes[0]);
    #####:  724:      for (auto i = 1u; i < nodes.size(); i += 2) {
    #####:  725:        auto num = eval(*nodes[i + 1]);
    #####:  726:        auto ope = nodes[i]->token[0];
    #####:  727:        switch (ope) {
    #####:  728:        case '+': result += num; break;
    #####:  729:        case '-': result -= num; break;
    #####:  730:        case '*': result *= num; break;
    #####:  731:        case '/': result /= num; break;
        -:  732:        }
        -:  733:      }
    #####:  734:      return result;
        -:  735:    }
    #####:  736:  };
        -:  737:
    #####:  738:  std::shared_ptr<Ast> ast;
    #####:  739:  auto r = EXPRESSION.parse_and_get_value("1+2*3*(4-5+6)/7-8", ast);
    #####:  740:  ast = AstOptimizer(true).optimize(ast);
    #####:  741:  auto val = eval(*ast);
        -:  742:
    #####:  743:  REQUIRE(r.ret == true);
    #####:  744:  REQUIRE(val == -3);
    #####:  745:}
        -:  746:
        1:  747:TEST_CASE("Ignore semantic value test", "[general]")
        -:  748:{
        -:  749:    parser parser(R"(
        -:  750:       START <-  ~HELLO WORLD
        -:  751:       HELLO <- 'Hello' _
        -:  752:       WORLD <- 'World' _
        -:  753:       _     <- [ \t\r\n]*
    #####:  754:    )");
        -:  755:
    #####:  756:    parser.enable_ast();
        -:  757:
    #####:  758:    std::shared_ptr<Ast> ast;
    #####:  759:    auto ret = parser.parse("Hello World", ast);
        -:  760:
    #####:  761:    REQUIRE(ret == true);
    #####:  762:    REQUIRE(ast->nodes.size() == 1);
    #####:  763:    REQUIRE(ast->nodes[0]->name == "WORLD");
    #####:  764:}
        -:  765:
        1:  766:TEST_CASE("Ignore semantic value of 'or' predicate test", "[general]")
        -:  767:{
        -:  768:    parser parser(R"(
        -:  769:       START       <- _ !DUMMY HELLO_WORLD '.'
        -:  770:       HELLO_WORLD <- HELLO 'World' _
        -:  771:       HELLO       <- 'Hello' _
        -:  772:       DUMMY       <- 'dummy' _
        -:  773:       ~_          <- [ \t\r\n]*
    #####:  774:   )");
        -:  775:
    #####:  776:    parser.enable_ast();
        -:  777:
    #####:  778:    std::shared_ptr<Ast> ast;
    #####:  779:    auto ret = parser.parse("Hello World.", ast);
        -:  780:
    #####:  781:    REQUIRE(ret == true);
    #####:  782:    REQUIRE(ast->nodes.size() == 1);
    #####:  783:    REQUIRE(ast->nodes[0]->name == "HELLO_WORLD");
    #####:  784:}
        -:  785:
        1:  786:TEST_CASE("Ignore semantic value of 'and' predicate test", "[general]")
        -:  787:{
        -:  788:    parser parser(R"(
        -:  789:       START       <- _ &HELLO HELLO_WORLD '.'
        -:  790:       HELLO_WORLD <- HELLO 'World' _
        -:  791:       HELLO       <- 'Hello' _
        -:  792:       ~_          <- [ \t\r\n]*
    #####:  793:    )");
        -:  794:
    #####:  795:    parser.enable_ast();
        -:  796:
    #####:  797:    std::shared_ptr<Ast> ast;
    #####:  798:    auto ret = parser.parse("Hello World.", ast);
        -:  799:
    #####:  800:    REQUIRE(ret == true);
    #####:  801:    REQUIRE(ast->nodes.size() == 1);
    #####:  802:    REQUIRE(ast->nodes[0]->name == "HELLO_WORLD");
    #####:  803:}
        -:  804:
        1:  805:TEST_CASE("Literal token on AST test1", "[general]")
        -:  806:{
        -:  807:    parser parser(R"(
        -:  808:        STRING_LITERAL  <- '"' (('\\"' / '\\t' / '\\n') / (!["] .))* '"'
    #####:  809:    )");
    #####:  810:    parser.enable_ast();
        -:  811:
    #####:  812:    std::shared_ptr<Ast> ast;
    #####:  813:    auto ret = parser.parse(R"("a\tb")", ast);
        -:  814:
    #####:  815:    REQUIRE(ret == true);
    #####:  816:    REQUIRE(ast->is_token == true);
    #####:  817:    REQUIRE(ast->token == R"("a\tb")");
    #####:  818:    REQUIRE(ast->nodes.empty());
    #####:  819:}
        -:  820:
        1:  821:TEST_CASE("Literal token on AST test2", "[general]")
        -:  822:{
        -:  823:    parser parser(R"(
        -:  824:        STRING_LITERAL  <-  '"' (ESC / CHAR)* '"'
        -:  825:        ESC             <-  ('\\"' / '\\t' / '\\n')
        -:  826:        CHAR            <-  (!["] .)
    #####:  827:    )");
    #####:  828:    parser.enable_ast();
        -:  829:
    #####:  830:    std::shared_ptr<Ast> ast;
    #####:  831:    auto ret = parser.parse(R"("a\tb")", ast);
        -:  832:
    #####:  833:    REQUIRE(ret == true);
    #####:  834:    REQUIRE(ast->is_token == false);
    #####:  835:    REQUIRE(ast->token.empty());
    #####:  836:    REQUIRE(ast->nodes.size() == 3);
    #####:  837:}
        -:  838:
        1:  839:TEST_CASE("Literal token on AST test3", "[general]")
        -:  840:{
        -:  841:    parser parser(R"(
        -:  842:        STRING_LITERAL  <-  < '"' (ESC / CHAR)* '"' >
        -:  843:        ESC             <-  ('\\"' / '\\t' / '\\n')
        -:  844:        CHAR            <-  (!["] .)
    #####:  845:    )");
    #####:  846:    parser.enable_ast();
        -:  847:
    #####:  848:    std::shared_ptr<Ast> ast;
    #####:  849:    auto ret = parser.parse(R"("a\tb")", ast);
        -:  850:
    #####:  851:    REQUIRE(ret == true);
    #####:  852:    REQUIRE(ast->is_token == true);
    #####:  853:    REQUIRE(ast->token == R"("a\tb")");
    #####:  854:    REQUIRE(ast->nodes.empty());
    #####:  855:}
        -:  856:
        1:  857:TEST_CASE("Missing missing definitions test", "[general]")
        -:  858:{
        -:  859:    parser parser(R"(
        -:  860:        A <- B C
    #####:  861:    )");
        -:  862:
    #####:  863:    REQUIRE(!parser);
    #####:  864:}
        -:  865:
        1:  866:TEST_CASE("Definition duplicates test", "[general]")
        -:  867:{
        -:  868:    parser parser(R"(
        -:  869:        A <- ''
        -:  870:        A <- ''
    #####:  871:    )");
        -:  872:
    #####:  873:    REQUIRE(!parser);
    #####:  874:}
        -:  875:
        1:  876:TEST_CASE("Semantic values test", "[general]")
        -:  877:{
        -:  878:    parser parser(R"(
        -:  879:        term <- ( a b c x )? a b c
        -:  880:        a <- 'a'
        -:  881:        b <- 'b'
        -:  882:        c <- 'c'
        -:  883:        x <- 'x'
    #####:  884:    )");
        -:  885:
    #####:  886:	for (const auto& rule: parser.get_rule_names()){
    #####:  887:		parser[rule.c_str()] = [rule](const SemanticValues& sv, any&) {
    #####:  888:            if (rule == "term") {
    #####:  889:                REQUIRE(any_cast<std::string>(sv[0]) == "a at 0");
    #####:  890:                REQUIRE(any_cast<std::string>(sv[1]) == "b at 1");
    #####:  891:                REQUIRE(any_cast<std::string>(sv[2]) == "c at 2");
    #####:  892:                return std::string();
        -:  893:            } else {
    #####:  894:                return rule + " at " + std::to_string(sv.c_str() - sv.ss);
        -:  895:            }
        -:  896:		};
        -:  897:	}
        -:  898:
    #####:  899:	REQUIRE(parser.parse("abc"));
    #####:  900:}
        -:  901:
        1:  902:TEST_CASE("Ordered choice count", "[general]")
        -:  903:{
        -:  904:    parser parser(R"(
        -:  905:        S <- 'a' / 'b'
    #####:  906:    )");
        -:  907:
    #####:  908:    parser["S"] = [](const SemanticValues& sv) {
    #####:  909:        REQUIRE(sv.choice() == 1);
    #####:  910:        REQUIRE(sv.choice_count() == 2);
    #####:  911:    };
        -:  912:
    #####:  913:    parser.parse("b");
    #####:  914:}
        -:  915:
        1:  916:TEST_CASE("Ordered choice count 2", "[general]")
        -:  917:{
        -:  918:    parser parser(R"(
        -:  919:        S <- ('a' / 'b')*
    #####:  920:    )");
        -:  921:
    #####:  922:    parser["S"] = [](const SemanticValues& sv) {
    #####:  923:        REQUIRE(sv.choice() == 0);
    #####:  924:        REQUIRE(sv.choice_count() == 0);
    #####:  925:    };
        -:  926:
    #####:  927:    parser.parse("b");
    #####:  928:}
        -:  929:
        1:  930:TEST_CASE("Semantic value tag", "[general]")
        -:  931:{
        -:  932:    parser parser(R"(
        -:  933:        S <- A? B* C?
        -:  934:        A <- 'a'
        -:  935:        B <- 'b'
        -:  936:        C <- 'c'
    #####:  937:    )");
        -:  938:
        -:  939:    {
        -:  940:        using namespace udl;
    #####:  941:        parser["S"] = [](const SemanticValues& sv) {
    #####:  942:            REQUIRE(sv.size() == 1);
    #####:  943:            REQUIRE(sv.tags.size() == 1);
    #####:  944:            REQUIRE(sv.tags[0] == "C"_);
    #####:  945:        };
    #####:  946:        auto ret = parser.parse("c");
    #####:  947:        REQUIRE(ret == true);
        -:  948:    }
        -:  949:
        -:  950:    {
        -:  951:        using namespace udl;
    #####:  952:        parser["S"] = [](const SemanticValues& sv) {
    #####:  953:            REQUIRE(sv.size() == 2);
    #####:  954:            REQUIRE(sv.tags.size() == 2);
    #####:  955:            REQUIRE(sv.tags[0] == "B"_);
    #####:  956:            REQUIRE(sv.tags[1] == "B"_);
    #####:  957:        };
    #####:  958:        auto ret = parser.parse("bb");
    #####:  959:        REQUIRE(ret == true);
        -:  960:    }
        -:  961:
        -:  962:    {
        -:  963:        using namespace udl;
    #####:  964:        parser["S"] = [](const SemanticValues& sv) {
    #####:  965:            REQUIRE(sv.size() == 2);
    #####:  966:            REQUIRE(sv.tags.size() == 2);
    #####:  967:            REQUIRE(sv.tags[0] == "A"_);
    #####:  968:            REQUIRE(sv.tags[1] == "C"_);
    #####:  969:        };
    #####:  970:        auto ret = parser.parse("ac");
    #####:  971:        REQUIRE(ret == true);
        -:  972:    }
    #####:  973:}
        -:  974:
        1:  975:TEST_CASE("Negated Class test", "[general]")
        -:  976:{
        -:  977:    parser parser(R"(
        -:  978:        ROOT <- [^a-z_]+
    #####:  979:    )");
        -:  980:
    #####:  981:    bool ret = parser;
    #####:  982:    REQUIRE(ret == true);
        -:  983:
    #####:  984:    REQUIRE(parser.parse("ABC123"));
    #####:  985:    REQUIRE_FALSE(parser.parse("ABcZ"));
    #####:  986:    REQUIRE_FALSE(parser.parse("ABCZ_"));
    #####:  987:    REQUIRE_FALSE(parser.parse(""));
        3:  988:}
        -:  989:
        -:  990:// vim: et ts=4 sw=4 cin cino={1s ff=unix
