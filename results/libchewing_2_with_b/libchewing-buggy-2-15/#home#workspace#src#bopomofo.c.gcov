        -:    0:Source:/home/workspace/src/bopomofo.c
        -:    1:/**
        -:    2: * bopomofo.c
        -:    3: *
        -:    4: * Copyright (c) 1999, 2000, 2001
        -:    5: *      Lu-chuan Kung and Kang-pen Chen.
        -:    6: *      All rights reserved.
        -:    7: *
        -:    8: * Copyright (c) 2004-2006, 2008-2010, 2012-2014
        -:    9: *      libchewing Core Team. See ChangeLog for details.
        -:   10: *
        -:   11: * See the file "COPYING" for information on usage and redistribution
        -:   12: * of this file.
        -:   13: */
        -:   14:
        -:   15:/**
        -:   16: * @file bopomofo.c
        -:   17: *
        -:   18: * control keyboard mapping
        -:   19: * include the definition of BopomofoData structure
        -:   20: */
        -:   21:
        -:   22:#include <ctype.h>
        -:   23:#include <string.h>
        -:   24:
        -:   25:#include "bopomofo-private.h"
        -:   26:#include "chewingutil.h"
        -:   27:#include "dict-private.h"
        -:   28:#include "key2pho-private.h"
        -:   29:#include "pinyin-private.h"
        -:   30:#include "private.h"
        -:   31:
        -:   32:/*
        -:   33: * process a key input
        -:   34: * return value:
        -:   35: *      BOPOMOFO_ABSORB
        -:   36: *      BOPOMOFO_COMMIT
        -:   37: *      BOPOMOFO_KEY_ERROR
        -:   38: *      BOPOMOFO_ERROR
        -:   39: */
    #####:   40:static int IsHsuPhoEndKey(const int pho_inx[], int key)
        -:   41:{
    #####:   42:    switch (key) {
    #####:   43:    case 's':
        -:   44:    case 'd':
        -:   45:    case 'f':
        -:   46:    case 'j':
        -:   47:    case ' ':
    #####:   48:        return (pho_inx[0] || pho_inx[1] || pho_inx[2]);
    #####:   49:    default:
    #####:   50:        return 0;
        -:   51:    }
        -:   52:}
        -:   53:
        -:   54:/* copy the idea from HSU keyboard */
    #####:   55:static int IsET26PhoEndKey(const int pho_inx[], int key)
        -:   56:{
    #####:   57:    switch (key) {
    #####:   58:    case 'd':
        -:   59:    case 'f':
        -:   60:    case 'j':
        -:   61:    case 'k':
        -:   62:    case ' ':
    #####:   63:        return (pho_inx[0] || pho_inx[1] || pho_inx[2]);
    #####:   64:    default:
    #####:   65:        return 0;
        -:   66:    }
        -:   67:}
        -:   68:
        -:   69:/* copy the idea from HSU keyboard */
    #####:   70:static int IsDACHENCP26PhoEndKey(const int pho_inx[], int key)
        -:   71:{
    #####:   72:    switch (key) {
    #####:   73:    case 'e':
        -:   74:    case 'r':
        -:   75:    case 'd':
        -:   76:    case 'y':
        -:   77:    case ' ':
    #####:   78:        return (pho_inx[0] || pho_inx[1] || pho_inx[2]);
    #####:   79:    default:
    #####:   80:        return 0;
        -:   81:    }
        -:   82:}
        -:   83:
    #####:   84:static int IsDefPhoEndKey(int key, int kbtype)
        -:   85:{
    #####:   86:    if (PhoneInxFromKey(key, 3, kbtype, 1))
    #####:   87:        return 1;
        -:   88:
    #####:   89:    if (key == ' ')
    #####:   90:        return 1;
    #####:   91:    return 0;
        -:   92:}
        -:   93:
    #####:   94:static int EndKeyProcess(ChewingData *pgdata, int key, int searchTimes)
        -:   95:{
    #####:   96:    BopomofoData *pBopomofo = &(pgdata->bopomofoData);
        -:   97:    uint16_t u16Pho, u16PhoAlt;
        -:   98:    Phrase tempword;
        -:   99:    int pho_inx;
        -:  100:
    #####:  101:    if (pBopomofo->pho_inx[0] == 0 && pBopomofo->pho_inx[1] == 0 && pBopomofo->pho_inx[2] == 0 && pBopomofo->pho_inx[3] == 0) {
        -:  102:        /*
        -:  103:         * Special handle for space key (Indeed very special one).
        -:  104:         * Un-break the situation that OnKeySpace() is not called,
        -:  105:         * hence the Candidate window doesn't show up, because
        -:  106:         * BOPOMOFO_NO_WORD is returned.
        -:  107:         */
    #####:  108:        return (key == ' ') ? BOPOMOFO_KEY_ERROR : BOPOMOFO_NO_WORD;
        -:  109:    }
        -:  110:
    #####:  111:    pho_inx = PhoneInxFromKey(key, 3, pBopomofo->kbtype, searchTimes);
    #####:  112:    if (pBopomofo->pho_inx[3] == 0) {
    #####:  113:        pBopomofo->pho_inx[3] = pho_inx;
    #####:  114:        pBopomofo->pho_inx_alt[3] = pho_inx;
    #####:  115:    } else if (key != ' ') {
    #####:  116:        pBopomofo->pho_inx[3] = pho_inx;
    #####:  117:        pBopomofo->pho_inx_alt[3] = pho_inx;
    #####:  118:        return BOPOMOFO_NO_WORD;
        -:  119:    }
        -:  120:
    #####:  121:    u16Pho = UintFromPhoneInx(pBopomofo->pho_inx);
    #####:  122:    if (GetCharFirst(pgdata, &tempword, u16Pho) == 0) {
    #####:  123:        BopomofoRemoveAll(pBopomofo);
    #####:  124:        return BOPOMOFO_NO_WORD;
        -:  125:    }
        -:  126:
    #####:  127:    pBopomofo->phone = u16Pho;
        -:  128:
    #####:  129:    if (pBopomofo->pho_inx_alt[0] == 0 && pBopomofo->pho_inx_alt[1] == 0 && pBopomofo->pho_inx_alt[2] == 0) {
        -:  130:        /* no alternative phone, copy from default as alt */
    #####:  131:        pBopomofo->phoneAlt = u16Pho;
        -:  132:    } else {
    #####:  133:        u16PhoAlt = UintFromPhoneInx(pBopomofo->pho_inx_alt);
    #####:  134:        pBopomofo->phoneAlt = u16PhoAlt;
        -:  135:    }
        -:  136:
    #####:  137:    memset(pBopomofo->pho_inx, 0, sizeof(pBopomofo->pho_inx));
    #####:  138:    memset(pBopomofo->pho_inx_alt, 0, sizeof(pBopomofo->pho_inx_alt));
    #####:  139:    return BOPOMOFO_COMMIT;
        -:  140:}
        -:  141:
    #####:  142:static int DefPhoInput(ChewingData *pgdata, int key)
        -:  143:{
    #####:  144:    BopomofoData *pBopomofo = &(pgdata->bopomofoData);
    #####:  145:    int type = 0, inx = 0;
        -:  146:    int i;
        -:  147:
    #####:  148:    if (IsDefPhoEndKey(key, pBopomofo->kbtype)) {
    #####:  149:        for (i = 0; i < BOPOMOFO_SIZE; ++i)
    #####:  150:            if (pBopomofo->pho_inx[i] != 0)
    #####:  151:                break;
    #####:  152:        if (i < BOPOMOFO_SIZE)
    #####:  153:            return EndKeyProcess(pgdata, key, 1);
        -:  154:    } else {
    #####:  155:        pBopomofo->pho_inx[3] = 0;
        -:  156:    }
        -:  157:
        -:  158:    /* decide if the key is a phone */
    #####:  159:    for (type = 0; type <= 3; type++) {
    #####:  160:        inx = PhoneInxFromKey(key, type, pBopomofo->kbtype, 1);
    #####:  161:        if (inx)
    #####:  162:            break;
        -:  163:    }
        -:  164:
        -:  165:    /* the key is NOT a phone */
    #####:  166:    if (type > 3) {
    #####:  167:        return BOPOMOFO_KEY_ERROR;
        -:  168:    }
        -:  169:
        -:  170:    /* fill the key into the phone buffer */
    #####:  171:    pBopomofo->pho_inx[type] = inx;
    #####:  172:    return BOPOMOFO_ABSORB;
        -:  173:}
        -:  174:
    #####:  175:static int HsuPhoInput(ChewingData *pgdata, int key)
        -:  176:{
    #####:  177:    BopomofoData *pBopomofo = &(pgdata->bopomofoData);
    #####:  178:    int type = 0, searchTimes = 0, inx = 0;
        -:  179:
        -:  180:    /* Dvorak Hsu key has already converted to Hsu */
    #####:  181:    if (IsHsuPhoEndKey(pBopomofo->pho_inx, key)) {
    #####:  182:        if (pBopomofo->pho_inx[1] == 0 && pBopomofo->pho_inx[2] == 0) {
        -:  183:            /* convert "ㄐㄑㄒ" to "ㄓㄔㄕ" */
    #####:  184:            if (12 <= pBopomofo->pho_inx[0] && pBopomofo->pho_inx[0] <= 14) {
    #####:  185:                pBopomofo->pho_inx[0] += 3;
        -:  186:            }
        -:  187:            /* convert "ㄏ" to "ㄛ" */
    #####:  188:            else if (pBopomofo->pho_inx[0] == 11) {
    #####:  189:                pBopomofo->pho_inx[0] = 0;
    #####:  190:                pBopomofo->pho_inx[2] = 2;
        -:  191:            }
        -:  192:            /* convert "ㄍ" to "ㄜ" */
    #####:  193:            else if (pBopomofo->pho_inx[0] == 9) {
    #####:  194:                pBopomofo->pho_inx[0] = 0;
    #####:  195:                pBopomofo->pho_inx[2] = 3;
        -:  196:            }
        -:  197:            /* convert "ㄇ" to "ㄢ" */
    #####:  198:            else if (pBopomofo->pho_inx[0] == 3) {
    #####:  199:                pBopomofo->pho_inx[0] = 0;
    #####:  200:                pBopomofo->pho_inx[2] = 9;
        -:  201:            }
        -:  202:            /* convert "ㄋ" to "ㄣ" */
    #####:  203:            else if (pBopomofo->pho_inx[0] == 7) {
    #####:  204:                pBopomofo->pho_inx[0] = 0;
    #####:  205:                pBopomofo->pho_inx[2] = 10;
        -:  206:            }
        -:  207:            /* convert "ㄎ" to "ㄤ" */
    #####:  208:            else if (pBopomofo->pho_inx[0] == 10) {
    #####:  209:                pBopomofo->pho_inx[0] = 0;
    #####:  210:                pBopomofo->pho_inx[2] = 11;
        -:  211:            }
        -:  212:            /* convert "ㄌ" to "ㄦ" */
    #####:  213:            else if (pBopomofo->pho_inx[0] == 8) {
    #####:  214:                pBopomofo->pho_inx[0] = 0;
    #####:  215:                pBopomofo->pho_inx[2] = 13;
        -:  216:            }
        -:  217:        }
        -:  218:
        -:  219:        /* fuzzy ㄍㄧ to ㄐㄧ and ㄍㄩ to ㄐㄩ */
    #####:  220:        if ((pBopomofo->pho_inx[0] == 9) && ((pBopomofo->pho_inx[1] == 1) || (pBopomofo->pho_inx[1] == 3))) {
    #####:  221:            pBopomofo->pho_inx[0] = 12;
        -:  222:        }
        -:  223:
    #####:  224:        searchTimes = (key == 'j') ? 3 : 2;
        -:  225:
    #####:  226:        return EndKeyProcess(pgdata, key, searchTimes);
        -:  227:    } else {
        -:  228:        /* decide if the key is a phone */
    #####:  229:        for (type = 0, searchTimes = 1; type < 3; type++) {
    #####:  230:            inx = PhoneInxFromKey(key, type, pBopomofo->kbtype, searchTimes);
    #####:  231:            if (!inx)
    #####:  232:                continue;       /* if inx == 0, next type */
    #####:  233:            else if (type == 0) {
        -:  234:                /**
        -:  235:                 * Hsu maps multiple bopomofo into one single key.
        -:  236:                 * Therefore, if a consonant or a medial already exists
        -:  237:                 * in buffer, and the user presses a key with consonant
        -:  238:                 * and rhyme, libchewing should consider that the user
        -:  239:                 * wants to input the rhyme.
        -:  240:                 */
    #####:  241:                if ((inx == 3 || (7 <= inx && inx <= 11) || inx == 20)
    #####:  242:                    && (pBopomofo->pho_inx[0] || pBopomofo->pho_inx[1])) {
        -:  243:                    /* if inx !=0 */
    #####:  244:                    searchTimes = 2;    /* possible infinite loop here */
    #####:  245:                } else if (12 <= inx && inx <= 14) {
        -:  246:                    /* ㄐㄑㄒ always come with ㄧㄩ, so set ㄓㄔㄕ as default. */
    #####:  247:                    pBopomofo->pho_inx[0] = inx + 3;
        -:  248:                } else
        -:  249:                    break;
    #####:  250:            } else if (type == 1 && inx == 1) { /* handle i and e */
    #####:  251:                if (pBopomofo->pho_inx[1]) {
    #####:  252:                    searchTimes = 2;
        -:  253:                } else
    #####:  254:                    break;
        -:  255:            } else
        -:  256:                break;
        -:  257:        }
        -:  258:
        -:  259:        /* fuzzy ㄍㄧ to ㄐㄧ and ㄍㄩ to ㄐㄩ */
    #####:  260:        if ((pBopomofo->pho_inx[0] == 9) && ((pBopomofo->pho_inx[1] == 1) || (pBopomofo->pho_inx[1] == 3))) {
    #####:  261:            pBopomofo->pho_inx[0] = 12;
        -:  262:        }
        -:  263:
        -:  264:        /* ㄐㄑㄒ must be followed by ㄧ or ㄩ. If not, convert them to ㄓㄔㄕ. */
    #####:  265:        if (12 <= pBopomofo->pho_inx[0] && pBopomofo->pho_inx[0] <= 14) {
    #####:  266:	        if ((type == 1 && inx == 2) || (type == 2 && pBopomofo->pho_inx[1] == 0)) {
    #####:  267:		        pBopomofo->pho_inx[0] += 3;
        -:  268:	        }
        -:  269:        }
        -:  270:
        -:  271:        /* Likeweis, when ㄓㄔㄕ is followed by ㄧ or ㄩ, convert them to ㄐㄑㄒ. */
    #####:  272:        if (15 <= pBopomofo->pho_inx[0] && pBopomofo->pho_inx[0] <= 17) {
    #####:  273:	        if ((type == 1) && (inx == 1 || inx == 3)) {
    #####:  274:		        pBopomofo->pho_inx[0] -= 3;
        -:  275:	        }
        -:  276:        }
        -:  277:
    #####:  278:        if (type == 3) {        /* the key is NOT a phone */
    #####:  279:            if (isalpha(key))
    #####:  280:                return BOPOMOFO_NO_WORD;
    #####:  281:            return BOPOMOFO_KEY_ERROR;
        -:  282:        }
        -:  283:        /* fill the key into the phone buffer */
    #####:  284:        pBopomofo->pho_inx[type] = inx;
    #####:  285:        return BOPOMOFO_ABSORB;
        -:  286:    }
        -:  287:}
        -:  288:
        -:  289:/* copy the idea from hsu */
    #####:  290:static int ET26PhoInput(ChewingData *pgdata, int key)
        -:  291:{
    #####:  292:    BopomofoData *pBopomofo = &(pgdata->bopomofoData);
    #####:  293:    int type = 0, searchTimes = 0, inx = 0;
        -:  294:
    #####:  295:    if (IsET26PhoEndKey(pBopomofo->pho_inx, key)) {
    #####:  296:        if (pBopomofo->pho_inx[1] == 0 && pBopomofo->pho_inx[2] == 0) {
        -:  297:            /* convert "ㄐㄒ" to "ㄓㄕ" */
    #####:  298:            if (pBopomofo->pho_inx[0] == 12 || pBopomofo->pho_inx[0] == 14) {
    #####:  299:                pBopomofo->pho_inx[0] += 3;
        -:  300:            }
        -:  301:            /* convert "ㄆ" to "ㄡ" */
    #####:  302:            else if (pBopomofo->pho_inx[0] == 2) {
    #####:  303:                pBopomofo->pho_inx[0] = 0;
    #####:  304:                pBopomofo->pho_inx[2] = 8;
        -:  305:            }
        -:  306:            /* convert "ㄇ" to "ㄢ" */
    #####:  307:            else if (pBopomofo->pho_inx[0] == 3) {
    #####:  308:                pBopomofo->pho_inx[0] = 0;
    #####:  309:                pBopomofo->pho_inx[2] = 9;
        -:  310:            }
        -:  311:            /* convert "ㄋ" to "ㄣ" */
    #####:  312:            else if (pBopomofo->pho_inx[0] == 7) {
    #####:  313:                pBopomofo->pho_inx[0] = 0;
    #####:  314:                pBopomofo->pho_inx[2] = 10;
        -:  315:            }
        -:  316:            /* convert "ㄊ" to "ㄤ" */
    #####:  317:            else if (pBopomofo->pho_inx[0] == 6) {
    #####:  318:                pBopomofo->pho_inx[0] = 0;
    #####:  319:                pBopomofo->pho_inx[2] = 11;
        -:  320:            }
        -:  321:            /* convert "ㄌ" to "ㄥ" */
    #####:  322:            else if (pBopomofo->pho_inx[0] == 8) {
    #####:  323:                pBopomofo->pho_inx[0] = 0;
    #####:  324:                pBopomofo->pho_inx[2] = 12;
        -:  325:            }
        -:  326:            /* convert "ㄏ" to "ㄦ" */
    #####:  327:            else if (pBopomofo->pho_inx[0] == 11) {
    #####:  328:                pBopomofo->pho_inx[0] = 0;
    #####:  329:                pBopomofo->pho_inx[2] = 13;
        -:  330:            }
        -:  331:        }
    #####:  332:        searchTimes = 2;
    #####:  333:        return EndKeyProcess(pgdata, key, searchTimes);
        -:  334:    } else {
        -:  335:        /* decide if the key is a phone */
    #####:  336:        for (type = 0, searchTimes = 1; type < 3; type++) {
    #####:  337:            inx = PhoneInxFromKey(key, type, pBopomofo->kbtype, searchTimes);
    #####:  338:            if (!inx)
    #####:  339:                continue;       /* if inx == 0, next type */
    #####:  340:            else if (type == 0) {
        -:  341:                 /**
        -:  342:                  * Same as Hsu: If a consonant or a medial already exists
        -:  343:                  * in buffer, and the user presses a key with consonant
        -:  344:                  * and rhyme, libchewing should consider that the user
        -:  345:                  * wants to input the rhyme.
        -:  346:                  */
    #####:  347:                if ((inx == 2 || inx == 3 || inx == 11 || inx == 19 || inx == 20 ||
    #####:  348:                    (6 <= inx && inx <= 8)) && (pBopomofo->pho_inx[0] || pBopomofo->pho_inx[1])) {
        -:  349:                    /* if inx !=0 */
    #####:  350:                    searchTimes = 2;    /* possible infinite loop here */
        -:  351:                } else
        -:  352:                    break;
        -:  353:            } else
    #####:  354:                break;
        -:  355:        }
        -:  356:        /* convert "ㄐㄒ" to "ㄓㄕ" */
    #####:  357:        if (type == 1) {
    #####:  358:            if (inx == 2) {
    #####:  359:                if (pBopomofo->pho_inx[0] == 12 || pBopomofo->pho_inx[0] == 14) {
    #####:  360:                    pBopomofo->pho_inx[0] += 3;
        -:  361:                }
        -:  362:            } else {
        -:  363:                /* convert "ㄍ" to "ㄑ" */
    #####:  364:                if (pBopomofo->pho_inx[0] == 9) {
    #####:  365:                    pBopomofo->pho_inx[0] = 13;
        -:  366:                }
        -:  367:            }
        -:  368:        }
        -:  369:
    #####:  370:        if (type == 2 && pBopomofo->pho_inx[1] == 0 && (pBopomofo->pho_inx[0] == 12 || pBopomofo->pho_inx[0] == 14)) {
    #####:  371:            pBopomofo->pho_inx[0] += 3;
        -:  372:        }
        -:  373:
    #####:  374:        if (type == 3) {        /* the key is NOT a phone */
    #####:  375:            if (isalpha(key))
    #####:  376:                return BOPOMOFO_NO_WORD;
    #####:  377:            return BOPOMOFO_KEY_ERROR;
        -:  378:        }
        -:  379:        /* fill the key into the phone buffer */
    #####:  380:        pBopomofo->pho_inx[type] = inx;
    #####:  381:        return BOPOMOFO_ABSORB;
        -:  382:    }
        -:  383:}
        -:  384:
    #####:  385:static int SwitchingBetween(int *pho_idx, int a, int b)
        -:  386:{
    #####:  387:    if (*pho_idx == a) {
    #####:  388:        *pho_idx = b;
    #####:  389:        return 1;
    #####:  390:    } else if (*pho_idx == b) {
    #####:  391:        *pho_idx = a;
    #####:  392:        return 1;
        -:  393:    }
    #####:  394:    return 0;
        -:  395:}
        -:  396:
    #####:  397:static int DACHENCP26PhoInput(ChewingData *pgdata, int key)
        -:  398:{
    #####:  399:    BopomofoData *pBopomofo = &(pgdata->bopomofoData);
    #####:  400:    int type = 0, searchTimes = 0, inx = 0;
        -:  401:
    #####:  402:    if (IsDACHENCP26PhoEndKey(pBopomofo->pho_inx, key)) {
    #####:  403:        searchTimes = 2;
    #####:  404:        return EndKeyProcess(pgdata, key, searchTimes);
        -:  405:    } else {
        -:  406:        /* decide if the key is a phone */
    #####:  407:        for (type = 0, searchTimes = 1; type < 3; type++) {
    #####:  408:            inx = PhoneInxFromKey(key, type, pBopomofo->kbtype, searchTimes);
    #####:  409:            if (!inx)
    #####:  410:                continue;       /* if inx == 0, next type */
    #####:  411:            else if (type == 0) {
    #####:  412:                break;
        -:  413:                if (pBopomofo->pho_inx[0] || pBopomofo->pho_inx[1]) {
        -:  414:                    /* if inx !=0 */
        -:  415:                    searchTimes = 2;    /* possible infinite loop here */
        -:  416:                } else
        -:  417:                    break;
        -:  418:            } else
    #####:  419:                break;
        -:  420:        }
        -:  421:        /* switching between "ㄅ" and "ㄆ" */
    #####:  422:        if (key == 'q') {
    #####:  423:            if (SwitchingBetween(&pBopomofo->pho_inx[0], 1, 2)) {
    #####:  424:                return BOPOMOFO_ABSORB;
        -:  425:            }
        -:  426:        }
        -:  427:        /* switching between "ㄉ" and "ㄊ" */
    #####:  428:        else if (key == 'w') {
    #####:  429:            if (SwitchingBetween(&pBopomofo->pho_inx[0], 5, 6)) {
    #####:  430:                return BOPOMOFO_ABSORB;
        -:  431:            }
        -:  432:        }
        -:  433:        /* switching between "ㄓ" and "ㄔ" */
    #####:  434:        else if (key == 't') {
    #####:  435:            if (SwitchingBetween(&pBopomofo->pho_inx[0], 15, 16)) {
    #####:  436:                return BOPOMOFO_ABSORB;
        -:  437:            }
        -:  438:        }
        -:  439:        /* converting "ㄖ" to "ㄝ" */
    #####:  440:        else if (key == 'b') {
    #####:  441:            if (pBopomofo->pho_inx[0] != 0 || pBopomofo->pho_inx[1] != 0) {
    #####:  442:                pBopomofo->pho_inx[2] = 4;
    #####:  443:                return BOPOMOFO_ABSORB;
        -:  444:            }
        -:  445:        }
        -:  446:        /* converting "ㄙ" to "ㄥ" */
    #####:  447:        else if (key == 'n') {
    #####:  448:            if (pBopomofo->pho_inx[0] != 0 || pBopomofo->pho_inx[1] != 0) {
    #####:  449:                pBopomofo->pho_inx[2] = 12;
    #####:  450:                return BOPOMOFO_ABSORB;
        -:  451:            }
        -:  452:        }
        -:  453:        /* switching between "ㄧ", "ㄚ", and "ㄧㄚ" */
    #####:  454:        else if (key == 'u') {
    #####:  455:            if (pBopomofo->pho_inx[1] == 1 && pBopomofo->pho_inx[2] != 1) {
    #####:  456:                pBopomofo->pho_inx[1] = 0;
    #####:  457:                pBopomofo->pho_inx[2] = 1;
    #####:  458:                return BOPOMOFO_ABSORB;
    #####:  459:            } else if (pBopomofo->pho_inx[1] != 1 && pBopomofo->pho_inx[2] == 1) {
    #####:  460:                pBopomofo->pho_inx[1] = 1;
    #####:  461:                return BOPOMOFO_ABSORB;
    #####:  462:            } else if (pBopomofo->pho_inx[1] == 1 && pBopomofo->pho_inx[2] == 1) {
    #####:  463:                pBopomofo->pho_inx[1] = 0;
    #####:  464:                pBopomofo->pho_inx[2] = 0;
    #####:  465:                return BOPOMOFO_ABSORB;
    #####:  466:            } else if (pBopomofo->pho_inx[1] != 0) {
    #####:  467:                pBopomofo->pho_inx[2] = 1;
    #####:  468:                return BOPOMOFO_ABSORB;
        -:  469:            }
        -:  470:        }
        -:  471:        /* switching between "ㄩ" and "ㄡ" */
    #####:  472:        else if (key == 'm') {
    #####:  473:            if (pBopomofo->pho_inx[1] == 3 && pBopomofo->pho_inx[2] != 8) {
    #####:  474:                pBopomofo->pho_inx[1] = 0;
    #####:  475:                pBopomofo->pho_inx[2] = 8;
    #####:  476:                return BOPOMOFO_ABSORB;
    #####:  477:            } else if (pBopomofo->pho_inx[1] != 3 && pBopomofo->pho_inx[2] == 8) {
    #####:  478:                pBopomofo->pho_inx[1] = 3;
    #####:  479:                pBopomofo->pho_inx[2] = 0;
    #####:  480:                return BOPOMOFO_ABSORB;
    #####:  481:            } else if (pBopomofo->pho_inx[1] != 0) {
    #####:  482:                pBopomofo->pho_inx[2] = 8;
    #####:  483:                return BOPOMOFO_ABSORB;
        -:  484:            }
        -:  485:        }
        -:  486:        /* switching between "ㄛ" and "ㄞ" */
    #####:  487:        else if (key == 'i') {
    #####:  488:            if (SwitchingBetween(&pBopomofo->pho_inx[2], 2, 5)) {
    #####:  489:                return BOPOMOFO_ABSORB;
        -:  490:            }
        -:  491:        }
        -:  492:        /* switching between "ㄟ" and "ㄢ" */
    #####:  493:        else if (key == 'o') {
    #####:  494:            if (SwitchingBetween(&pBopomofo->pho_inx[2], 6, 9)) {
    #####:  495:                return BOPOMOFO_ABSORB;
        -:  496:            }
        -:  497:        }
        -:  498:        /* switching between "ㄠ" and "ㄤ" */
    #####:  499:        else if (key == 'l') {
    #####:  500:            if (SwitchingBetween(&pBopomofo->pho_inx[2], 7, 11)) {
    #####:  501:                return BOPOMOFO_ABSORB;
        -:  502:            }
        -:  503:        }
        -:  504:        /* switching between "ㄣ" and "ㄦ" */
    #####:  505:        else if (key == 'p') {
    #####:  506:            if (SwitchingBetween(&pBopomofo->pho_inx[2], 10, 13)) {
    #####:  507:                return BOPOMOFO_ABSORB;
        -:  508:            }
        -:  509:        }
    #####:  510:        if (type == 3) {        /* the key is NOT a phone */
    #####:  511:            if (isalpha(key))
    #####:  512:                return BOPOMOFO_NO_WORD;
    #####:  513:            return BOPOMOFO_KEY_ERROR;
        -:  514:        }
        -:  515:        /* fill the key into the phone buffer */
    #####:  516:        pBopomofo->pho_inx[type] = inx;
    #####:  517:        return BOPOMOFO_ABSORB;
        -:  518:    }
        -:  519:}
        -:  520:
    #####:  521:static int IsPinYinEndKey(int key)
        -:  522:{
    #####:  523:    if ((key == ' ') || (key == '1') || (key == '2') || (key == '3') || (key == '4') || (key == '5')) {
    #####:  524:        return 1;
        -:  525:    }
    #####:  526:    return 0;
        -:  527:}
        -:  528:
    #####:  529:static int IsSymbolKey(int key)
        -:  530:{
    #####:  531:    if ((key < 97) || (key > 122)) {
    #####:  532:        return 1;
        -:  533:    }
        -:  534:
    #####:  535:    return 0;
        -:  536:}
        -:  537:
    #####:  538:static int PinYinInput(ChewingData *pgdata, int key)
        -:  539:{
    #####:  540:    BopomofoData *pBopomofo = &(pgdata->bopomofoData);
    #####:  541:    int err = 0;
        -:  542:    unsigned int i;
        -:  543:    char bopomofoKeySeq[5], bopomofoKeySeqAlt[5], buf[2];
        -:  544:    size_t len;
        -:  545:
    #####:  546:    DEBUG_CHECKPOINT();
        -:  547:
    #####:  548:    if (pBopomofo->pinYinData.keySeq[0] == 0 && IsSymbolKey(key)) {
    #####:  549:        return BOPOMOFO_KEY_ERROR;
        -:  550:    }
        -:  551:
    #####:  552:    if (IsPinYinEndKey(key)) {
    #####:  553:        err = PinyinToBopomofo(pgdata, pBopomofo->pinYinData.keySeq, bopomofoKeySeq, bopomofoKeySeqAlt);
    #####:  554:        if (err) {
    #####:  555:            pBopomofo->pinYinData.keySeq[0] = '\0';
    #####:  556:            return BOPOMOFO_ABSORB;
        -:  557:        }
        -:  558:
    #####:  559:        DEBUG_OUT("bopomofoKeySeq: %s\n", bopomofoKeySeq);
    #####:  560:        DEBUG_OUT("bopomofoKeySeqAlt: %s\n", bopomofoKeySeqAlt);
        -:  561:
    #####:  562:        len = strlen(bopomofoKeySeq);
    #####:  563:        for (i = 0; i < len; i++) {
    #####:  564:            int type = 0, inx = 0;
        -:  565:
    #####:  566:            for (type = 0; type <= 3; type++) {
    #####:  567:                inx = PhoneInxFromKey(bopomofoKeySeq[i], type, pBopomofo->kbtype, 1);
    #####:  568:                if (inx)
    #####:  569:                    break;
        -:  570:            }
        -:  571:
        -:  572:            /* the key is NOT a phone */
    #####:  573:            if (type > 3) {
    #####:  574:                return BOPOMOFO_KEY_ERROR;
        -:  575:            }
        -:  576:
    #####:  577:            pBopomofo->pho_inx[type] = inx;
        -:  578:
        -:  579:        }
        -:  580:
    #####:  581:        len = strlen(bopomofoKeySeqAlt);
    #####:  582:        for (i = 0; i < len; i++) {
    #####:  583:            int type = 0, inx = 0;
        -:  584:
    #####:  585:            for (type = 0; type <= 3; type++) {
    #####:  586:                inx = PhoneInxFromKey(bopomofoKeySeqAlt[i], type, pBopomofo->kbtype, 1);
    #####:  587:                if (inx)
    #####:  588:                    break;
        -:  589:            }
        -:  590:
        -:  591:            /* the key is NOT a phone */
    #####:  592:            if (type > 3) {
    #####:  593:                return BOPOMOFO_KEY_ERROR;
        -:  594:            }
        -:  595:
    #####:  596:            pBopomofo->pho_inx_alt[type] = inx;
        -:  597:
        -:  598:        }
        -:  599:
    #####:  600:        switch (key) {
    #####:  601:        case '1':
    #####:  602:            key = ' ';
    #####:  603:            break;
    #####:  604:        case '2':
    #####:  605:            key = '6';
    #####:  606:            break;
    #####:  607:        case '5':
    #####:  608:            key = '7';
        -:  609:        }
    #####:  610:        pBopomofo->pinYinData.keySeq[0] = '\0';
    #####:  611:        return EndKeyProcess(pgdata, key, 1);
        -:  612:    }
        -:  613:
    #####:  614:    if (strlen(pBopomofo->pinYinData.keySeq) + 1 < sizeof(pBopomofo->pinYinData.keySeq)) {
    #####:  615:        buf[0] = key;
    #####:  616:        buf[1] = '\0';
    #####:  617:        strcat(pBopomofo->pinYinData.keySeq, buf);
        -:  618:    } else {
        -:  619:        /* buffer is full, ignore this keystroke */
    #####:  620:        return BOPOMOFO_NO_WORD;
        -:  621:    }
        -:  622:
    #####:  623:    DEBUG_OUT("PinYin Seq: %s\n", pBopomofo->pinYinData.keySeq);
        -:  624:
    #####:  625:    return BOPOMOFO_ABSORB;
        -:  626:}
        -:  627:
        -:  628:/* key: ascii code of input, including space */
    #####:  629:int BopomofoPhoInput(ChewingData *pgdata, int key)
        -:  630:{
    #####:  631:    BopomofoData *pBopomofo = &(pgdata->bopomofoData);
        -:  632:
        -:  633:    /* open symbol table */
    #####:  634:    if (key == '`') {
    #####:  635:        pgdata->bSelect = 1;
    #####:  636:        pgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;
    #####:  637:        HaninSymbolInput(pgdata);
    #####:  638:        return BOPOMOFO_OPEN_SYMBOL_TABLE;
        -:  639:    }
    #####:  640:    switch (pBopomofo->kbtype) {
    #####:  641:    case KB_HSU:
        -:  642:    case KB_DVORAK_HSU:
    #####:  643:        return HsuPhoInput(pgdata, key);
        -:  644:        break;
    #####:  645:    case KB_ET26:
    #####:  646:        return ET26PhoInput(pgdata, key);
        -:  647:        break;
    #####:  648:    case KB_DACHEN_CP26:
    #####:  649:        return DACHENCP26PhoInput(pgdata, key);
        -:  650:        break;
    #####:  651:    case KB_HANYU_PINYIN:
        -:  652:    case KB_THL_PINYIN:
        -:  653:    case KB_MPS2_PINYIN:
    #####:  654:        return PinYinInput(pgdata, key);
        -:  655:        break;
    #####:  656:    default:
    #####:  657:        return DefPhoInput(pgdata, key);
        -:  658:    }
        -:  659:    return BOPOMOFO_ERROR;
        -:  660:}
        -:  661:
        -:  662:/* remove the latest key */
    #####:  663:int BopomofoRemoveLast(BopomofoData *pBopomofo)
        -:  664:{
        -:  665:    int i;
        -:  666:
    #####:  667:    if (pBopomofo->kbtype >= KB_HANYU_PINYIN) {
    #####:  668:        i = strlen(pBopomofo->pinYinData.keySeq);
    #####:  669:        pBopomofo->pinYinData.keySeq[i - 1] = '\0';
        -:  670:    } else {
    #####:  671:        for (i = 3; i >= 0; i--) {
    #####:  672:            if (pBopomofo->pho_inx[i]) {
    #####:  673:                pBopomofo->pho_inx[i] = 0;
    #####:  674:                return 0;
        -:  675:            }
        -:  676:        }
        -:  677:    }
    #####:  678:    return 0;
        -:  679:}
        -:  680:
        -:  681:/* remove all the key entered */
    #####:  682:int BopomofoRemoveAll(BopomofoData *pBopomofo)
        -:  683:{
    #####:  684:    memset(pBopomofo->pho_inx, 0, sizeof(pBopomofo->pho_inx));
    #####:  685:    memset(pBopomofo->pinYinData.keySeq, 0, sizeof(pBopomofo->pinYinData.keySeq));
    #####:  686:    return 0;
        -:  687:}
        -:  688:
    #####:  689:int BopomofoIsEntering(BopomofoData *pBopomofo)
        -:  690:{
        -:  691:    int i;
        -:  692:
    #####:  693:    if (pBopomofo->kbtype >= KB_HANYU_PINYIN) {
    #####:  694:        if (pBopomofo->pinYinData.keySeq[0])
    #####:  695:            return 1;
        -:  696:    } else {
    #####:  697:        for (i = 0; i < BOPOMOFO_SIZE; i++)
    #####:  698:            if (pBopomofo->pho_inx[i])
    #####:  699:                return 1;
        -:  700:    }
    #####:  701:    return 0;
        -:  702:}
