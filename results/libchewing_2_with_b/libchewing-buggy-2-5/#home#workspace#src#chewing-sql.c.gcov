        -:    0:Source:/home/workspace/src/chewing-sql.c
        -:    1:/**
        -:    2: * chewing-sql.c
        -:    3: *
        -:    4: * Copyright (c) 2013, 2014
        -:    5: *      libchewing Core Team. See ChangeLog for details.
        -:    6: *
        -:    7: * See the file "COPYING" for information on usage and redistribution
        -:    8: * of this file.
        -:    9: */
        -:   10:
        -:   11:#include "chewing-sql.h"
        -:   12:#include "chewing-private.h"
        -:   13:
        -:   14:#include <assert.h>
        -:   15:#include <stdlib.h>
        -:   16:#include <stdio.h>
        -:   17:#include <string.h>
        -:   18:
        -:   19:#include "memory-private.h"
        -:   20:#include "plat_types.h"
        -:   21:#include "private.h"
        -:   22:#include "sqlite3.h"
        -:   23:#include "userphrase-private.h"
        -:   24:
        -:   25:const SqlStmtUserphrase SQL_STMT_USERPHRASE[STMT_USERPHRASE_COUNT] = {
        -:   26:    {
        -:   27:     "SELECT length, phrase, "
        -:   28:     "phone_0, phone_1, phone_2, phone_3, phone_4, phone_5, "
        -:   29:     "phone_6, phone_7, phone_8, phone_9, phone_10 " "FROM userphrase_v1",
        -:   30:     {-1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12},
        -:   31:     },
        -:   32:    {
        -:   33:     "SELECT time, orig_freq, max_freq, user_freq, phrase "
        -:   34:     "FROM userphrase_v1 WHERE length = ?5 AND "
        -:   35:     "phone_0 = ?10 AND phone_1 = ?11 AND phone_2 = ?12 AND "
        -:   36:     "phone_3 = ?13 AND phone_4 = ?14 AND phone_5 = ?15 AND "
        -:   37:     "phone_6 = ?16 AND phone_7 = ?17 AND phone_8 = ?18 AND " "phone_9 = ?19 AND phone_10 = ?20",
        -:   38:     {0, 1, 2, 3, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        -:   39:     },
        -:   40:    {
        -:   41:     "SELECT time, orig_freq, max_freq, user_freq "
        -:   42:     "FROM userphrase_v1 WHERE length = ?5 AND phrase = ?6 AND "
        -:   43:     "phone_0 = ?10 AND phone_1 = ?11 AND phone_2 = ?12 AND "
        -:   44:     "phone_3 = ?13 AND phone_4 = ?14 AND phone_5 = ?15 AND "
        -:   45:     "phone_6 = ?16 AND phone_7 = ?17 AND phone_8 = ?18 AND " "phone_9 = ?19 AND phone_10 = ?20",
        -:   46:     {0, 1, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        -:   47:     },
        -:   48:    {
        -:   49:     "INSERT OR REPLACE INTO userphrase_v1 ("
        -:   50:     "time, orig_freq, max_freq, user_freq, length, phrase, "
        -:   51:     "phone_0, phone_1, phone_2, phone_3, phone_4, phone_5, "
        -:   52:     "phone_6, phone_7, phone_8, phone_9, phone_10) "
        -:   53:     "VALUES (?1, ?2, ?3, ?4, ?5, ?6, " "?10, ?11, ?12, ?13, ?14, ?15, ?16, ?17, ?18, ?19, ?20)",
        -:   54:     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        -:   55:     },
        -:   56:    {
        -:   57:     "DELETE FROM userphrase_v1 WHERE length = ?5 AND phrase = ?6 AND "
        -:   58:     "phone_0 = ?10 AND phone_1 = ?11 AND phone_2 = ?12 AND "
        -:   59:     "phone_3 = ?13 AND phone_4 = ?14 AND phone_5 = ?15 AND "
        -:   60:     "phone_6 = ?16 AND phone_7 = ?17 AND phone_8 = ?18 AND " "phone_9 = ?19 AND phone_10 = ?20",
        -:   61:     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        -:   62:     },
        -:   63:    {
        -:   64:     "SELECT MAX(user_freq) FROM userphrase_v1 WHERE length = ?5 AND "
        -:   65:     "phone_0 = ?10 AND phone_1 = ?11 AND phone_2 = ?12 AND "
        -:   66:     "phone_3 = ?13 AND phone_4 = ?14 AND phone_5 = ?15 AND "
        -:   67:     "phone_6 = ?16 AND phone_7 = ?17 AND phone_8 = ?18 AND " "phone_9 = ?19 AND phone_10 = ?20",
        -:   68:     {-1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        -:   69:     },
        -:   70:};
        -:   71:
        -:   72:const SqlStmtConfig SQL_STMT_CONFIG[STMT_CONFIG_COUNT] = {
        -:   73:    {
        -:   74:     "SELECT value FROM config_v1 WHERE id = ?1",
        -:   75:     {-1, 0},
        -:   76:     },
        -:   77:    {
        -:   78:     "INSERT OR IGNORE INTO config_v1 (id, value) VALUES (?1, ?2)",
        -:   79:     {-1, -1},
        -:   80:     },
        -:   81:    {
        -:   82:     "UPDATE config_v1 SET value = value + ?2 WHERE id = ?1",
        -:   83:     {-1, -1},
        -:   84:     },
        -:   85:};
        -:   86:
        -:   87:#define HASH_FIELD_SIZE		(125)
        -:   88:#define HASH_FIELD_START	(8)
        -:   89:#define HASH_LENGTH_OFFSET	(16)
        -:   90:#define HASH_NAME		"uhash.dat"
        -:   91:#define HASH_OLD_NAME		"uhash.old"
        -:   92:#define HASH_SIGS		"CBiH"
        -:   93:
        2:   94:static sqlite3 *GetSQLiteInstance(ChewingData *pgdata, const char *path)
        -:   95:{
        -:   96:    int ret;
        2:   97:    sqlite3 *db = NULL;
        -:   98:
       2*:   99:    assert(pgdata);
       2*:  100:    assert(path);
        -:  101:
        2:  102:    ret = sqlite3_open(path, &db);
        2:  103:    if (ret != SQLITE_OK) {
    #####:  104:        LOG_ERROR("sqlite3_open returns %d", ret);
    #####:  105:        goto end;
        -:  106:    }
        -:  107:
        2:  108:  end:
        2:  109:    return db;
        -:  110:}
        -:  111:
        -:  112:
        2:  113:static int CreateTable(ChewingData *pgdata)
        -:  114:{
        -:  115:    int ret;
        -:  116:
        -:  117:    STATIC_ASSERT(MAX_PHRASE_LEN == 11);
        -:  118:
        2:  119:    ret = sqlite3_exec(pgdata->static_data.db,
        -:  120:                       "CREATE TABLE IF NOT EXISTS userphrase_v1 ("
        -:  121:                       "time INTEGER,"
        -:  122:                       "user_freq INTEGER,"
        -:  123:                       "max_freq INTEGER,"
        -:  124:                       "orig_freq INTEGER,"
        -:  125:                       "length INTEGER,"
        -:  126:                       "phone_0 INTEGER,"
        -:  127:                       "phone_1 INTEGER,"
        -:  128:                       "phone_2 INTEGER,"
        -:  129:                       "phone_3 INTEGER,"
        -:  130:                       "phone_4 INTEGER,"
        -:  131:                       "phone_5 INTEGER,"
        -:  132:                       "phone_6 INTEGER,"
        -:  133:                       "phone_7 INTEGER,"
        -:  134:                       "phone_8 INTEGER,"
        -:  135:                       "phone_9 INTEGER,"
        -:  136:                       "phone_10 INTEGER,"
        -:  137:                       "phrase TEXT,"
        -:  138:                       "PRIMARY KEY ("
        -:  139:                       "phone_0,"
        -:  140:                       "phone_1,"
        -:  141:                       "phone_2,"
        -:  142:                       "phone_3,"
        -:  143:                       "phone_4,"
        -:  144:                       "phone_5,"
        -:  145:                       "phone_6,"
        -:  146:                       "phone_7,"
        -:  147:                       "phone_8,"
        -:  148:                       "phone_9,"
        -:  149:                       "phone_10,"
        -:  150:                       "phrase)" ")", NULL, NULL, NULL);
        2:  151:    if (ret != SQLITE_OK) {
    #####:  152:        LOG_ERROR("Cannot create table userphrase_v1, error = %d", ret);
    #####:  153:        return -1;
        -:  154:    }
        -:  155:
        2:  156:    ret = sqlite3_exec(pgdata->static_data.db,
        -:  157:                       "CREATE TABLE IF NOT EXISTS config_v1 ("
        -:  158:                       "id INTEGER,"
        -:  159:                       "value INTEGER,"
        -:  160:                       "PRIMARY KEY (id)" ")", NULL, NULL, NULL);
        2:  161:    if (ret != SQLITE_OK) {
    #####:  162:        LOG_ERROR("Cannot create table config_v1, error = %d", ret);
    #####:  163:        return -1;
        -:  164:    }
        -:  165:
        2:  166:    return 0;
        -:  167:}
        -:  168:
        2:  169:static int SetupUserphraseLifeTime(ChewingData *pgdata)
        -:  170:{
        -:  171:    int ret;
        -:  172:
       2*:  173:    assert(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT]);
        -:  174:
        2:  175:    ret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT], BIND_CONFIG_ID, CONFIG_ID_LIFETIME);
        2:  176:    if (ret != SQLITE_OK) {
    #####:  177:        LOG_ERROR("Cannot bind ?%d to %d in stmt %s, error = %d",
        -:  178:                  BIND_CONFIG_ID, CONFIG_ID_LIFETIME, SQL_STMT_CONFIG[STMT_CONFIG_INSERT].stmt, ret);
    #####:  179:        return -1;
        -:  180:    }
        -:  181:
        2:  182:    ret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT], BIND_CONFIG_VALUE, 0);
        2:  183:    if (ret != SQLITE_OK) {
    #####:  184:        LOG_ERROR("Cannot bind ?%d to %d in stmt %s, error = %d",
        -:  185:                  BIND_CONFIG_VALUE, 0, SQL_STMT_CONFIG[STMT_CONFIG_INSERT].stmt, ret);
    #####:  186:        return -1;
        -:  187:    }
        -:  188:
        2:  189:    ret = sqlite3_step(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT]);
        2:  190:    if (ret != SQLITE_DONE) {
    #####:  191:        LOG_ERROR("sqlite3_step returns %d", ret);
    #####:  192:        return -1;
        -:  193:    }
        -:  194:
        2:  195:    ret = sqlite3_reset(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT]);
        2:  196:    if (ret != SQLITE_OK) {
    #####:  197:        LOG_ERROR("sqlite3_reset returns %d", ret);
    #####:  198:        return -1;
        -:  199:    }
        -:  200:
       2*:  201:    assert(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT]);
        -:  202:
        2:  203:    ret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT], BIND_CONFIG_ID, CONFIG_ID_LIFETIME);
        2:  204:    if (ret != SQLITE_OK) {
    #####:  205:        LOG_ERROR("Cannot bind ?%d to %d in stmt %s, error = %d",
        -:  206:                  BIND_CONFIG_ID, CONFIG_ID_LIFETIME, SQL_STMT_CONFIG[STMT_CONFIG_SELECT].stmt, ret);
    #####:  207:        return -1;
        -:  208:    }
        -:  209:
        2:  210:    ret = sqlite3_step(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT]);
        2:  211:    if (ret != SQLITE_ROW) {
    #####:  212:        LOG_ERROR("sqlite3_step returns %d", ret);
    #####:  213:        return -1;
        -:  214:    }
        -:  215:
        4:  216:    pgdata->static_data.original_lifetime = sqlite3_column_int(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT],
        -:  217:                                                               SQL_STMT_CONFIG[STMT_CONFIG_SELECT].column
        2:  218:                                                               [COLUMN_CONFIG_VALUE]);
        2:  219:    pgdata->static_data.new_lifetime = pgdata->static_data.original_lifetime;
        -:  220:
        2:  221:    ret = sqlite3_reset(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT]);
        2:  222:    if (ret != SQLITE_OK) {
    #####:  223:        LOG_ERROR("sqlite3_reset returns %d", ret);
    #####:  224:        return -1;
        -:  225:    }
        -:  226:
        2:  227:    return 0;
        -:  228:}
        -:  229:
        2:  230:static int UpdateLifeTime(ChewingData *pgdata)
        -:  231:{
        -:  232:    int ret;
        2:  233:    int result = 0;
        -:  234:
        2:  235:    if (!pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE]) {
    #####:  236:        LOG_ERROR("pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE] is NULL");
    #####:  237:        result = -1;
    #####:  238:        goto end;
        -:  239:    }
        -:  240:
        2:  241:    ret = sqlite3_clear_bindings(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE]);
        2:  242:    if (ret != SQLITE_OK) {
    #####:  243:        LOG_ERROR("sqlite3_clear_bindings returns %d", ret);
    #####:  244:        result = -1;
    #####:  245:        goto end;
        -:  246:    }
        -:  247:
        2:  248:    ret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE], BIND_CONFIG_ID, CONFIG_ID_LIFETIME);
        2:  249:    if (ret != SQLITE_OK) {
    #####:  250:        LOG_ERROR("Cannot bind ?%d to %d in stmt %s, error = %d",
        -:  251:                  BIND_CONFIG_ID, CONFIG_ID_LIFETIME, SQL_STMT_CONFIG[STMT_CONFIG_INCREASE].stmt, ret);
    #####:  252:        result = -1;
    #####:  253:        goto end;
        -:  254:    }
        -:  255:
        2:  256:    ret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE],
        2:  257:                           BIND_CONFIG_VALUE, pgdata->static_data.new_lifetime - pgdata->static_data.original_lifetime);
        2:  258:    if (ret != SQLITE_OK) {
    #####:  259:        LOG_ERROR("Cannot bind ?%d to %d in stmt %s, error = %d",
        -:  260:                  BIND_CONFIG_VALUE,
        -:  261:                  pgdata->static_data.new_lifetime - pgdata->static_data.original_lifetime,
        -:  262:                  SQL_STMT_CONFIG[STMT_CONFIG_INCREASE].stmt, ret);
    #####:  263:        result = -1;
    #####:  264:        goto end;
        -:  265:    }
        -:  266:
        2:  267:    ret = sqlite3_step(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE]);
        2:  268:    if (ret != SQLITE_DONE) {
    #####:  269:        LOG_ERROR("sqlite3_step returns %d", ret);
    #####:  270:        result = -1;
    #####:  271:        goto end;
        -:  272:    }
        -:  273:
        2:  274:  end:
        2:  275:    ret = sqlite3_reset(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE]);
        2:  276:    if (ret != SQLITE_OK) {
    #####:  277:        LOG_ERROR("sqlite3_reset returns %d", ret);
    #####:  278:        result = -1;
        -:  279:    }
        -:  280:
        2:  281:    return result;
        -:  282:}
        -:  283:
        2:  284:static int ConfigDatabase(ChewingData *pgdata)
        -:  285:{
        -:  286:    int ret;
        -:  287:
       2*:  288:    assert(pgdata);
       2*:  289:    assert(pgdata->static_data.db);
        -:  290:
        2:  291:    ret = sqlite3_exec(pgdata->static_data.db, "PRAGMA synchronous=OFF", NULL, NULL, NULL);
        2:  292:    if (ret != SQLITE_OK) {
    #####:  293:        LOG_ERROR("Cannot set synchronous=OFF, error = %d", ret);
    #####:  294:        return -1;
        -:  295:    }
        -:  296:
        2:  297:    return 0;
        -:  298:}
        -:  299:
        2:  300:static int CreateStmt(ChewingData *pgdata)
        -:  301:{
        -:  302:    size_t i;
        -:  303:    int ret;
        -:  304:
       2*:  305:    assert(pgdata);
        -:  306:
        -:  307:    STATIC_ASSERT(ARRAY_SIZE(SQL_STMT_CONFIG) == ARRAY_SIZE(pgdata->static_data.stmt_config));
        -:  308:    STATIC_ASSERT(ARRAY_SIZE(SQL_STMT_USERPHRASE) == ARRAY_SIZE(pgdata->static_data.stmt_userphrase));
        -:  309:
        8:  310:    for (i = 0; i < ARRAY_SIZE(SQL_STMT_CONFIG); ++i) {
        6:  311:        ret = sqlite3_prepare_v2(pgdata->static_data.db,
        -:  312:                                 SQL_STMT_CONFIG[i].stmt, -1, &pgdata->static_data.stmt_config[i], NULL);
        6:  313:        if (ret != SQLITE_OK) {
    #####:  314:            LOG_ERROR("Cannot create stmt %s", SQL_STMT_CONFIG[i].stmt);
    #####:  315:            return -1;
        -:  316:        }
        -:  317:    }
        -:  318:
       14:  319:    for (i = 0; i < ARRAY_SIZE(SQL_STMT_USERPHRASE); ++i) {
       12:  320:        ret = sqlite3_prepare_v2(pgdata->static_data.db,
        -:  321:                                 SQL_STMT_USERPHRASE[i].stmt, -1, &pgdata->static_data.stmt_userphrase[i], NULL);
       12:  322:        if (ret != SQLITE_OK) {
    #####:  323:            LOG_ERROR("Cannot create stmt %s", SQL_STMT_USERPHRASE[i].stmt);
    #####:  324:            return -1;
        -:  325:        }
        -:  326:    }
        -:  327:
        2:  328:    return 0;
        -:  329:}
        -:  330:
        2:  331:static void MigrateOldFormat(ChewingData *pgdata, const char *path)
        -:  332:{
        -:  333:    char *uhash;
        -:  334:    char *old_uhash;
        2:  335:    FILE *fd = NULL;
        -:  336:    char buf[HASH_FIELD_SIZE];
        -:  337:    uint16_t phoneSeq[MAX_PHRASE_LEN + 1];
        -:  338:    char *pos;
        -:  339:    int len;
        -:  340:    int i;
        -:  341:    int ret;
        -:  342:
       2*:  343:    assert(pgdata);
       2*:  344:    assert(path);
        -:  345:
        2:  346:    len = strlen(path) + 1 + strlen(HASH_NAME) + 1;
        2:  347:    uhash = calloc(sizeof(*uhash), len);
        2:  348:    if (!uhash) {
    #####:  349:        LOG_ERROR("calloc returns %#p", uhash);
    #####:  350:        exit(-1);
        -:  351:    }
        2:  352:    snprintf(uhash, len, "%s" PLAT_SEPARATOR "%s", path, HASH_NAME);
        -:  353:
        2:  354:    len = strlen(path) + 1 + strlen(HASH_OLD_NAME) + 1;
        2:  355:    old_uhash = calloc(sizeof(*old_uhash), len);
        2:  356:    if (!old_uhash) {
    #####:  357:        LOG_ERROR("calloc returns %#p", old_uhash);
    #####:  358:        exit(-1);
        -:  359:    }
        2:  360:    snprintf(old_uhash, len, "%s" PLAT_SEPARATOR "%s", path, HASH_OLD_NAME);
        -:  361:
        -:  362:    /*
        -:  363:     * The binary format is described as following:
        -:  364:     *
        -:  365:     * 0 ~ 3                signature (CBiH)
        -:  366:     * 4 ~ 7                lifttime, platform endianness
        -:  367:     * 8 ~ 8 + 125 * n      array of hash item, 125 bytes each
        -:  368:     *
        -:  369:     * 0 ~ 3                user frequency, platform endianness
        -:  370:     * 4 ~ 7                recent time, platform endianness
        -:  371:     * 8 ~ 11               max frequency, platform endianness
        -:  372:     * 12 ~ 15              original frequency, platform endianness
        -:  373:     * 16                   phone length
        -:  374:     * 17 ~ 17 + 2 * n      phone sequence, uint16_t, platform endianness
        -:  375:     * 17 + 2 * n + 1       phrase length in bytes
        -:  376:     * 17 + 2 * n + 2 ~ y   phrase in UTF-8
        -:  377:     *
        -:  378:     */
        -:  379:
        2:  380:    fd = fopen(uhash, "r");
        2:  381:    if (!fd)
        2:  382:        goto end;
        -:  383:
    #####:  384:    LOG_INFO("Migrate old format from %s", uhash);
    #####:  385:    ret = fread(buf, 4, 1, fd);
    #####:  386:    if (ret != 1) {
    #####:  387:        LOG_WARN("fread returns %d", ret);
    #####:  388:        goto end_remove_hash;
        -:  389:    }
        -:  390:
    #####:  391:    if (memcmp(buf, HASH_SIGS, 4) != 0) {
    #####:  392:        LOG_WARN("signature is not %d", HASH_SIGS);
    #####:  393:        goto end_remove_hash;
        -:  394:    }
        -:  395:
    #####:  396:    ret = fseek(fd, 8, SEEK_SET);
    #####:  397:    if (ret) {
    #####:  398:        LOG_WARN("fseek returns %d", ret);
    #####:  399:        goto end_remove_hash;
        -:  400:    }
        -:  401:
    #####:  402:    while (fread(buf, HASH_FIELD_SIZE, 1, fd) == 1) {
    #####:  403:        pos = &buf[HASH_LENGTH_OFFSET];
    #####:  404:        len = *pos;
    #####:  405:        ++pos;
        -:  406:
    #####:  407:        if (len > MAX_PHRASE_LEN || len < 1) {
    #####:  408:            LOG_WARN("skip field due to len = %d", len);
    #####:  409:            continue;
        -:  410:        }
        -:  411:
    #####:  412:        for (i = 0; i < len; ++i) {
    #####:  413:            phoneSeq[i] = GetUint16PreservedEndian(pos);
    #####:  414:            pos += 2;
        -:  415:        }
    #####:  416:        phoneSeq[len] = 0;
        -:  417:
    #####:  418:        ++pos;
    #####:  419:        UserUpdatePhrase(pgdata, phoneSeq, pos);
        -:  420:    }
        -:  421:
    #####:  422:  end_remove_hash:
    #####:  423:    if (fd)
    #####:  424:        fclose(fd);
    #####:  425:    PLAT_RENAME(uhash, old_uhash);
    #####:  426:  end:
        2:  427:    free(old_uhash);
        2:  428:    free(uhash);
        2:  429:}
        -:  430:
        2:  431:int InitUserphrase(ChewingData *pgdata, const char *path)
        -:  432:{
        -:  433:    int ret;
        -:  434:
       2*:  435:    assert(!pgdata->static_data.db);
       2*:  436:    assert(path);
        -:  437:
        2:  438:    pgdata->static_data.db = GetSQLiteInstance(pgdata, path);
        2:  439:    if (!pgdata->static_data.db) {
    #####:  440:        LOG_ERROR("GetSQLiteInstance fails");
    #####:  441:        goto error;
        -:  442:    }
        -:  443:
        2:  444:    ret = ConfigDatabase(pgdata);
        2:  445:    if (ret) {
    #####:  446:        LOG_ERROR("ConfigDatabase returns %d", ret);
    #####:  447:        goto error;
        -:  448:    }
        -:  449:
        2:  450:    ret = CreateTable(pgdata);
        2:  451:    if (ret) {
    #####:  452:        LOG_ERROR("CreateTable returns %d", ret);
    #####:  453:        goto error;
        -:  454:    }
        -:  455:
        2:  456:    ret = CreateStmt(pgdata);
        2:  457:    if (ret) {
    #####:  458:        LOG_ERROR("CreateStmt returns %d", ret);
    #####:  459:        goto error;
        -:  460:    }
        -:  461:
        2:  462:    ret = SetupUserphraseLifeTime(pgdata);
        2:  463:    if (ret) {
    #####:  464:        LOG_ERROR("SetupUserphraseLiftTime returns %d", ret);
    #####:  465:        goto error;
        -:  466:    }
        -:  467:
        -:  468:    /* FIXME: Normalize lifttime when necessary. */
        -:  469:
        2:  470:    MigrateOldFormat(pgdata, path);
        -:  471:
        2:  472:    return 0;
        -:  473:
    #####:  474:  error:
    #####:  475:    TerminateUserphrase(pgdata);
    #####:  476:    return -1;
        -:  477:}
        -:  478:
        2:  479:void TerminateUserphrase(ChewingData *pgdata)
        -:  480:{
        -:  481:    size_t i;
        -:  482:    int ret;
        -:  483:
        2:  484:    UpdateLifeTime(pgdata);
        -:  485:
        8:  486:    for (i = 0; i < ARRAY_SIZE(pgdata->static_data.stmt_config); ++i) {
        6:  487:        sqlite3_finalize(pgdata->static_data.stmt_config[i]);
        6:  488:        pgdata->static_data.stmt_config[i] = NULL;
        -:  489:    }
        -:  490:
       14:  491:    for (i = 0; i < ARRAY_SIZE(pgdata->static_data.stmt_userphrase); ++i) {
       12:  492:        sqlite3_finalize(pgdata->static_data.stmt_userphrase[i]);
       12:  493:        pgdata->static_data.stmt_userphrase[i] = NULL;
        -:  494:    }
        -:  495:
        2:  496:    ret = sqlite3_close(pgdata->static_data.db);
       2*:  497:    assert(SQLITE_OK == ret);
        2:  498:    pgdata->static_data.db = NULL;
        2:  499:}
