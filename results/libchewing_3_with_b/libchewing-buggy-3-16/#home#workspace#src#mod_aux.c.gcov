        -:    0:Source:/home/workspace/src/mod_aux.c
        -:    1:/*
        -:    2: * mod_aux.c
        -:    3: *
        -:    4: * Copyright (c) 2005, 2006, 2008
        -:    5: *	libchewing Core Team. See ChangeLog for details.
        -:    6: *
        -:    7: * See the file "COPYING" for information on usage and redistribution
        -:    8: * of this file.
        -:    9: */
        -:   10:
        -:   11:/**
        -:   12: * @file mod_aux.c
        -:   13: * @brief Auxiliary module
        -:   14: */
        -:   15:
        -:   16:#include <string.h>
        -:   17:#include <stdlib.h>
        -:   18:
        -:   19:#include "global.h"
        -:   20:#include "chewing-private.h"
        -:   21:#include "zuin-private.h"
        -:   22:#include "chewingio.h"
        -:   23:#include "chewing-utf8-util.h"
        -:   24:
        -:   25:/**
        -:   26: * @param ctx handle to Chewing IM context
        -:   27: * @retval TRUE if it currnet input state is at the "end-of-a-char"
        -:   28: */
        2:   29:CHEWING_API int chewing_commit_Check( ChewingContext *ctx )
        -:   30:{
        2:   31:	return !!(ctx->output->keystrokeRtn & KEYSTROKE_COMMIT);
        -:   32:}
        -:   33:
        -:   34:/**
        -:   35: * @param ctx handle to Chewing IM context
        -:   36: *
        -:   37: * retrun current commit string, regardless current input state.
        -:   38: * Alwasy returns a char pointer, caller must free it.
        -:   39: */
    #####:   40:CHEWING_API char *chewing_commit_String( ChewingContext *ctx )
        -:   41:{
    #####:   42:	return strdup( ctx->output->commitBuf );
        -:   43:}
        -:   44:
        4:   45:CHEWING_API int chewing_buffer_Check( ChewingContext *ctx )
        -:   46:{
        4:   47:	return (ctx->output->chiSymbolBufLen != 0);
        -:   48:}
        -:   49:
        4:   50:CHEWING_API int chewing_buffer_Len( ChewingContext *ctx )
        -:   51:{
        4:   52:	return ctx->output->chiSymbolBufLen;
        -:   53:}
        -:   54:
        4:   55:CHEWING_API char *chewing_buffer_String( ChewingContext *ctx )
        -:   56:{
        4:   57:	return strdup( ctx->output->preeditBuf );
        -:   58:}
        -:   59:
        -:   60:
        -:   61:/**
        -:   62: * @param ctx handle to Chewing IM context
        -:   63: *
        -:   64: * Always returns a char pointer, caller must free it.
        -:   65: */
    #####:   66:CHEWING_API char *chewing_bopomofo_String( ChewingContext *ctx)
        -:   67:{
    #####:   68:	return strdup( ctx->output->bopomofoBuf );
        -:   69:}
        -:   70:
        -:   71:/**
        -:   72: * @param ctx handle to Chewing IM context
        -:   73: * @param zuin_count pointer to the integer of available Zuin preedit string
        -:   74: *
        -:   75: * Always returns a char pointer, caller must free it.
        -:   76: */
    #####:   77:CHEWING_API char *chewing_zuin_String( ChewingContext *ctx, int *zuin_count )
        -:   78:{
    #####:   79:	char *s = chewing_bopomofo_String(ctx);
        -:   80:
    #####:   81:	if ( zuin_count )
    #####:   82:		*zuin_count = ueStrLen(s);
        -:   83:
    #####:   84:	return s;
        -:   85:}
        -:   86:
    #####:   87:CHEWING_API int chewing_bopomofo_Check( ChewingContext *ctx )
        -:   88:{
    #####:   89:	return ctx->output->bopomofoBuf[0] != 0;
        -:   90:}
        -:   91:
    #####:   92:CHEWING_API int chewing_zuin_Check( ChewingContext *ctx )
        -:   93:{
    #####:   94:	return !chewing_bopomofo_Check(ctx);
        -:   95:}
        -:   96:
        6:   97:CHEWING_API int chewing_cursor_Current( ChewingContext *ctx )
        -:   98:{
        6:   99:	return (ctx->output->chiSymbolCursor);
        -:  100:}
        -:  101:
    #####:  102:CHEWING_API int chewing_cand_CheckDone( ChewingContext *ctx )
        -:  103:{
    #####:  104:	return (! ctx->output->pci);
        -:  105:}
        -:  106:
    #####:  107:CHEWING_API int chewing_cand_TotalPage( ChewingContext *ctx )
        -:  108:{
    #####:  109:	return (ctx->output->pci ? ctx->output->pci->nPage : 0);
        -:  110:}
        -:  111:
    #####:  112:CHEWING_API int chewing_cand_ChoicePerPage( ChewingContext *ctx )
        -:  113:{
    #####:  114:	return (ctx->output->pci ? ctx->output->pci->nChoicePerPage : 0);
        -:  115:}
        -:  116:
    #####:  117:CHEWING_API int chewing_cand_TotalChoice( ChewingContext *ctx )
        -:  118:{
    #####:  119:	return (ctx->output->pci ? ctx->output->pci->nTotalChoice : 0);
        -:  120:}
        -:  121:
    #####:  122:CHEWING_API int chewing_cand_CurrentPage( ChewingContext *ctx )
        -:  123:{
    #####:  124:	return (ctx->output->pci ? ctx->output->pci->pageNo : -1);
        -:  125:}
        -:  126:
    #####:  127:CHEWING_API void chewing_cand_Enumerate( ChewingContext *ctx )
        -:  128:{
    #####:  129:	ctx->cand_no = ctx->output->pci->pageNo * ctx->output->pci->nChoicePerPage;
    #####:  130:}
        -:  131:
    #####:  132:CHEWING_API int chewing_cand_hasNext( ChewingContext *ctx )
        -:  133:{
    #####:  134:	return (ctx->cand_no < ctx->output->pci->nTotalChoice);
        -:  135:}
        -:  136:
    #####:  137:CHEWING_API char *chewing_cand_String( ChewingContext *ctx )
        -:  138:{
        -:  139:	char *s;
    #####:  140:	if ( chewing_cand_hasNext( ctx ) ) {
    #####:  141:		s = strdup( ctx->output->pci->totalChoiceStr[ ctx->cand_no ] );
    #####:  142:		ctx->cand_no++;
        -:  143:	} else {
    #####:  144:		s = strdup( "" );
        -:  145:	}
    #####:  146:	return s;
        -:  147:}
        -:  148:
    #####:  149:CHEWING_API void chewing_interval_Enumerate( ChewingContext *ctx )
        -:  150:{
    #####:  151:	ctx->it_no = 0;
    #####:  152:}
        -:  153:
    #####:  154:CHEWING_API int chewing_interval_hasNext( ChewingContext *ctx )
        -:  155:{
    #####:  156:	return (ctx->it_no < ctx->output->nDispInterval);
        -:  157:}
        -:  158:
    #####:  159:CHEWING_API void chewing_interval_Get( ChewingContext *ctx, IntervalType *it )
        -:  160:{
    #####:  161:	if ( chewing_interval_hasNext( ctx ) ) {
    #####:  162:		if ( it ) {
    #####:  163:			it->from = ctx->output->dispInterval[ ctx->it_no ].from;
    #####:  164:			it->to = ctx->output->dispInterval[ ctx->it_no ].to;
        -:  165:		}
    #####:  166:		ctx->it_no++;
        -:  167:	}
    #####:  168:}
        -:  169:
        4:  170:CHEWING_API int chewing_aux_Check( ChewingContext *ctx )
        -:  171:{
        4:  172:	return (ctx->data->bShowMsg);
        -:  173:}
        -:  174:
        4:  175:CHEWING_API int chewing_aux_Length( ChewingContext *ctx )
        -:  176:{
       4*:  177:	return (ctx->data->bShowMsg ? ctx->data->showMsgLen : 0);
        -:  178:}
        -:  179:
        4:  180:CHEWING_API char *chewing_aux_String( ChewingContext *ctx )
        -:  181:{
        4:  182:	return strdup( ctx->data->showMsg );
        -:  183:}
        -:  184:
        2:  185:CHEWING_API int chewing_keystroke_CheckIgnore( ChewingContext *ctx )
        -:  186:{
        2:  187:	return !!(ctx->output->keystrokeRtn & KEYSTROKE_IGNORE);
        -:  188:}
        -:  189:
        2:  190:CHEWING_API int chewing_keystroke_CheckAbsorb( ChewingContext *ctx )
        -:  191:{
        2:  192:	return !!(ctx->output->keystrokeRtn & KEYSTROKE_ABSORB);
        -:  193:}
        -:  194:
    #####:  195:CHEWING_API int chewing_kbtype_Total( ChewingContext *ctx UNUSED )
        -:  196:{
    #####:  197:	return KB_TYPE_NUM;
        -:  198:}
        -:  199:
    #####:  200:CHEWING_API void chewing_kbtype_Enumerate( ChewingContext *ctx )
        -:  201:{
    #####:  202:	ctx->kb_no = 0;
    #####:  203:}
        -:  204:
    #####:  205:CHEWING_API int chewing_kbtype_hasNext( ChewingContext *ctx )
        -:  206:{
    #####:  207:	return ctx->kb_no < KB_TYPE_NUM;
        -:  208:}
        -:  209:
        -:  210:extern const char * const kb_type_str[];
        -:  211:
    #####:  212:CHEWING_API char *chewing_kbtype_String( ChewingContext *ctx )
        -:  213:{
        -:  214:	char *s;
    #####:  215:	if ( chewing_kbtype_hasNext( ctx ) ) {
    #####:  216:		s = strdup( kb_type_str[ ctx->kb_no ] );
    #####:  217:		ctx->kb_no++;
        -:  218:	}
        -:  219:	else {
    #####:  220:		s = strdup( "" );
        -:  221:	}
    #####:  222:	return s;
        -:  223:}
