[
    {
        "name": "md2html.cmdline.readoptions#16",
        "src_path": "md2html/cmdline.c",
        "class_name": "md2html.cmdline",
        "signature": "md2html.cmdline.readoptions(option const* list, int argc, char **argv, int (*callback)(int, char const*, void*), void *data)",
        "snippet": "int readoptions(option const* list, int argc, char **argv,\n\t\tint (*callback)(int, char const*, void*), void *data)\n{\n    char\t\targstring[] = \"--\";\n    option const       *opt;\n    char const\t       *val;\n    char const\t       *p;\n    int\t\t\tstop = 0;\n    int\t\t\targi, len, r;\n\n    if (!list || !callback)\n\treturn -1;\n\n    for (argi = 1 ; argi < argc ; ++argi)\n    {\n\t/* First, check for \"--\", which forces all remaining arguments\n\t * to be treated as non-options.\n\t */\n\tif (!stop && argv[argi][0] == '-' && argv[argi][1] == '-'\n\t\t\t\t\t  && argv[argi][2] == '\\0') {\n\t    stop = 1;\n\t    continue;\n\t}\n\n\t/* Arguments that do not begin with '-' (or are only \"-\") are\n\t * not options.\n\t */\n\tif (stop || argv[argi][0] != '-' || argv[argi][1] == '\\0') {\n\t    docallback(0, argv[argi]);\n\t    continue;\n\t}\n\n\tif (argv[argi][1] == '-')\n\t{\n\t    /* Arguments that begin with a double-dash are long\n\t     * options.\n\t     */\n\t    p = argv[argi] + 2;\n\t    val = strchr(p, '=');\n\t    if (val)\n\t\tlen = val++ - p;\n\t    else\n\t\tlen = strlen(p);\n\n\t    /* Is it on the list of valid options? If so, does it\n\t     * expect a parameter?\n\t     */\n\t    for (opt = list ; opt->optval ; ++opt)\n\t\tif (opt->name && !strncmp(p, opt->name, len)\n\t\t\t      && !opt->name[len])\n\t\t    break;\n\t    if (!opt->optval) {\n\t\tdocallback('?', argv[argi]);\n\t    } else if (!val && opt->arg == 1) {\n\t\tdocallback(':', argv[argi]);\n\t    } else if (val && opt->arg == 0) {\n\t\tdocallback('=', argv[argi]);\n\t    } else {\n\t\tdocallback(opt->optval, val);\n\t    }\n\t}\n\telse\n\t{\n\t    /* Arguments that begin with a single dash contain one or\n\t     * more short options. Each character in the argument is\n\t     * examined in turn, unless a parameter consumes the rest\n\t     * of the argument (or possibly even the following\n\t     * argument).\n\t     */\n\t    for (p = argv[argi] + 1 ; *p ; ++p) {\n\t\tfor (opt = list ; opt->optval ; ++opt)\n\t\t    if (opt->chname == *p)\n\t\t\tbreak;\n\t\tif (!opt->optval) {\n\t\t    argstring[1] = *p;\n\t\t    docallback('?', argstring);\n\t\t    continue;\n\t\t} else if (opt->arg == 0) {\n\t\t    docallback(opt->optval, NULL);\n\t\t    continue;\n\t\t} else if (p[1]) {\n\t\t    docallback(opt->optval, p + 1);\n\t\t    break;\n\t\t} else if (argi + 1 < argc && strcmp(argv[argi + 1], \"--\")) {\n\t\t    ++argi;\n\t\t    docallback(opt->optval, argv[argi]);\n\t\t    break;\n\t\t} else if (opt->arg == 2) {\n\t\t    docallback(opt->optval, NULL);\n\t\t    continue;\n\t\t} else {\n\t\t    argstring[1] = *p;\n\t\t    docallback(':', argstring);\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n    return 0;\n}",
        "begin_line": 16,
        "end_line": 115,
        "is_bug": false
    },
    {
        "name": "md2html.md2html.cmdline_callback#270",
        "src_path": "md2html/md2html.c",
        "class_name": "md2html.md2html",
        "signature": "md2html.md2html.cmdline_callback(int opt, char const* value, void* data)",
        "snippet": "static int\ncmdline_callback(int opt, char const* value, void* data)\n{\n    switch(opt) {\n        case 0:\n            if(input_path) {\n                fprintf(stderr, \"Too many arguments. Only one input file can be specified.\\n\");\n                fprintf(stderr, \"Use --help for more info.\\n\");\n                exit(1);\n            }\n            input_path = value;\n            break;\n\n        case 'o':   output_path = value; break;\n        case 'f':   want_fullhtml = 1; break;\n        case 's':   want_stat = 1; break;\n        case 'h':   usage(); exit(0); break;\n        case 'v':   version(); exit(0); break;\n\n        case 'c':   parser_flags = MD_DIALECT_COMMONMARK; break;\n        case 'g':   parser_flags = MD_DIALECT_GITHUB; break;\n\n        case 'E':   renderer_flags |= MD_RENDER_FLAG_VERBATIM_ENTITIES; break;\n        case 'A':   parser_flags |= MD_FLAG_PERMISSIVEATXHEADERS; break;\n        case 'I':   parser_flags |= MD_FLAG_NOINDENTEDCODEBLOCKS; break;\n        case 'F':   parser_flags |= MD_FLAG_NOHTMLBLOCKS; break;\n        case 'G':   parser_flags |= MD_FLAG_NOHTMLSPANS; break;\n        case 'H':   parser_flags |= MD_FLAG_NOHTML; break;\n        case 'W':   parser_flags |= MD_FLAG_COLLAPSEWHITESPACE; break;\n        case 'U':   parser_flags |= MD_FLAG_PERMISSIVEURLAUTOLINKS; break;\n        case '.':   parser_flags |= MD_FLAG_PERMISSIVEWWWAUTOLINKS; break;\n        case '@':   parser_flags |= MD_FLAG_PERMISSIVEEMAILAUTOLINKS; break;\n        case 'V':   parser_flags |= MD_FLAG_PERMISSIVEAUTOLINKS; break;\n        case 'T':   parser_flags |= MD_FLAG_TABLES; break;\n        case 'S':   parser_flags |= MD_FLAG_STRIKETHROUGH; break;\n\n        default:\n            fprintf(stderr, \"Illegal option: %s\\n\", value);\n            fprintf(stderr, \"Use --help for more info.\\n\");\n            exit(1);\n            break;\n    }\n\n    return 0;\n}",
        "begin_line": 270,
        "end_line": 314,
        "is_bug": false
    },
    {
        "name": "md2html.md2html.main#324",
        "src_path": "md2html/md2html.c",
        "class_name": "md2html.md2html",
        "signature": "md2html.md2html.main(int argc, char** argv)",
        "snippet": "int\nmain(int argc, char** argv)\n{\n    FILE* in = stdin;\n    FILE* out = stdout;\n    int ret = 0;\n\n    if(readoptions(cmdline_options, argc, argv, cmdline_callback, NULL) < 0) {\n        usage();\n        exit(1);\n    }\n\n    if(input_path != NULL && strcmp(input_path, \"-\") != 0) {\n        in = fopen(input_path, \"rb\");\n        if(in == NULL) {\n            fprintf(stderr, \"Cannot open %s.\\n\", input_path);\n            exit(1);\n        }\n    }\n    if(output_path != NULL && strcmp(output_path, \"-\") != 0) {\n        out = fopen(output_path, \"wt\");\n        if(out == NULL) {\n            fprintf(stderr, \"Cannot open %s.\\n\", input_path);\n            exit(1);\n        }\n    }\n\n    ret = process_file(in, out);\n    if(in != stdin)\n        fclose(in);\n    if(out != stdout)\n        fclose(out);\n\n    return ret;\n}",
        "begin_line": 324,
        "end_line": 358,
        "is_bug": false
    },
    {
        "name": "md2html.md2html.membuf_init#59",
        "src_path": "md2html/md2html.c",
        "class_name": "md2html.md2html",
        "signature": "md2html.md2html.membuf_init(struct membuffer* buf, MD_SIZE new_asize)",
        "snippet": "static void\nmembuf_init(struct membuffer* buf, MD_SIZE new_asize)\n{\n    buf->size = 0;\n    buf->asize = new_asize;\n    buf->data = malloc(buf->asize);\n    if(buf->data == NULL) {\n        fprintf(stderr, \"membuf_init: malloc() failed.\\n\");\n        exit(1);\n    }\n}",
        "begin_line": 59,
        "end_line": 69,
        "is_bug": false
    },
    {
        "name": "md2html.md2html.process_file#109",
        "src_path": "md2html/md2html.c",
        "class_name": "md2html.md2html",
        "signature": "md2html.md2html.process_file(FILE* in, FILE* out)",
        "snippet": "static int\nprocess_file(FILE* in, FILE* out)\n{\n    MD_SIZE n;\n    struct membuffer buf_in = {0};\n    struct membuffer buf_out = {0};\n    int ret = -1;\n    clock_t t0, t1;\n\n    membuf_init(&buf_in, 32 * 1024);\n\n    /* Read the input file into a buffer. */\n    while(1) {\n        if(buf_in.size >= buf_in.asize)\n            membuf_grow(&buf_in, 2 * buf_in.asize);\n\n        n = fread(buf_in.data + buf_in.size, 1, buf_in.asize - buf_in.size, in);\n        if(n == 0)\n            break;\n        buf_in.size += n;\n    }\n\n    /* Input size is good estimation of output size. Add some more reserve to\n     * deal with the HTML header/footer and tags. */\n    membuf_init(&buf_out, buf_in.size + buf_in.size/8 + 64);\n\n    /* Parse the document. This shall call our callbacks provided via the\n     * md_renderer_t structure. */\n    t0 = clock();\n\n    ret = md_render_html(buf_in.data, buf_in.size, process_output,\n                (void*) &buf_out, parser_flags, renderer_flags);\n\n    t1 = clock();\n    if(ret != 0) {\n        fprintf(stderr, \"Parsing failed.\\n\");\n        goto out;\n    }\n\n    /* Write down the document in the HTML format. */\n    if(want_fullhtml) {\n        fprintf(out, \"<html>\\n\");\n        fprintf(out, \"<head>\\n\");\n        fprintf(out, \"<title></title>\\n\");\n        fprintf(out, \"<meta name=\\\"generator\\\" content=\\\"md2html\\\">\\n\");\n        fprintf(out, \"</head>\\n\");\n        fprintf(out, \"<body>\\n\");\n    }\n\n    fwrite(buf_out.data, 1, buf_out.size, out);\n\n    if(want_fullhtml) {\n        fprintf(out, \"</body>\\n\");\n        fprintf(out, \"</html>\\n\");\n    }\n\n    if(want_stat) {\n        if(t0 != (clock_t)-1  &&  t1 != (clock_t)-1) {\n            double elapsed = (double)(t1 - t0) / CLOCKS_PER_SEC;\n            if (elapsed < 1)\n                fprintf(stderr, \"Time spent on parsing: %7.2f ms.\\n\", elapsed*1e3);\n            else\n                fprintf(stderr, \"Time spent on parsing: %6.3f s.\\n\", elapsed);\n        }\n    }\n\n    /* Success if we have reached here. */\n    ret = 0;\n\nout:\n    membuf_fini(&buf_in);\n    membuf_fini(&buf_out);\n\n    return ret;\n}",
        "begin_line": 109,
        "end_line": 183,
        "is_bug": false
    },
    {
        "name": "md2html.render_html.enter_block_callback#342",
        "src_path": "md2html/render_html.c",
        "class_name": "md2html.render_html",
        "signature": "md2html.render_html.enter_block_callback(MD_BLOCKTYPE type, void* detail, void* userdata)",
        "snippet": "static int\nenter_block_callback(MD_BLOCKTYPE type, void* detail, void* userdata)\n{\n    static const MD_CHAR* head[6] = { \"<h1>\", \"<h2>\", \"<h3>\", \"<h4>\", \"<h5>\", \"<h6>\" };\n    MD_RENDER_HTML* r = (MD_RENDER_HTML*) userdata;\n\n    switch(type) {\n        case MD_BLOCK_DOC:      /* noop */ break;\n        case MD_BLOCK_QUOTE:    RENDER_LITERAL(r, \"<blockquote>\\n\"); break;\n        case MD_BLOCK_UL:       RENDER_LITERAL(r, \"<ul>\\n\"); break;\n        case MD_BLOCK_OL:       render_open_ol_block(r, (const MD_BLOCK_OL_DETAIL*)detail); break;\n        case MD_BLOCK_LI:       RENDER_LITERAL(r, \"<li>\"); break;\n        case MD_BLOCK_HR:       RENDER_LITERAL(r, \"<hr>\\n\"); break;\n        case MD_BLOCK_H:        RENDER_LITERAL(r, head[((MD_BLOCK_H_DETAIL*)detail)->level - 1]); break;\n        case MD_BLOCK_CODE:     render_open_code_block(r, (const MD_BLOCK_CODE_DETAIL*) detail); break;\n        case MD_BLOCK_HTML:     /* noop */ break;\n        case MD_BLOCK_P:        RENDER_LITERAL(r, \"<p>\"); break;\n        case MD_BLOCK_TABLE:    RENDER_LITERAL(r, \"<table>\\n\"); break;\n        case MD_BLOCK_THEAD:    RENDER_LITERAL(r, \"<thead>\\n\"); break;\n        case MD_BLOCK_TBODY:    RENDER_LITERAL(r, \"<tbody>\\n\"); break;\n        case MD_BLOCK_TR:       RENDER_LITERAL(r, \"<tr>\\n\"); break;\n        case MD_BLOCK_TH:       render_open_td_block(r, \"th\", (MD_BLOCK_TD_DETAIL*)detail); break;\n        case MD_BLOCK_TD:       render_open_td_block(r, \"td\", (MD_BLOCK_TD_DETAIL*)detail); break;\n    }\n\n    return 0;\n}",
        "begin_line": 342,
        "end_line": 368,
        "is_bug": false
    },
    {
        "name": "md2html.render_html.md_render_html#471",
        "src_path": "md2html/render_html.c",
        "class_name": "md2html.render_html",
        "signature": "md2html.render_html.md_render_html(const MD_CHAR* input, MD_SIZE input_size, void (*process_output)(const MD_CHAR*, MD_SIZE, void*), void* userdata, unsigned parser_flags, unsigned renderer_flags)",
        "snippet": "int\nmd_render_html(const MD_CHAR* input, MD_SIZE input_size,\n               void (*process_output)(const MD_CHAR*, MD_SIZE, void*),\n               void* userdata, unsigned parser_flags, unsigned renderer_flags)\n{\n    MD_RENDER_HTML render = { process_output, userdata, renderer_flags, 0 };\n\n    MD_RENDERER renderer = {\n        enter_block_callback,\n        leave_block_callback,\n        enter_span_callback,\n        leave_span_callback,\n        text_callback,\n        debug_log_callback,\n        parser_flags\n    };\n\n    return md_parse(input, input_size, &renderer, (void*) &render);\n}",
        "begin_line": 471,
        "end_line": 489,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_add_line_into_current_block#4722",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_add_line_into_current_block(MD_CTX* ctx, const MD_LINE_ANALYSIS* analysis)",
        "snippet": "static int\nmd_add_line_into_current_block(MD_CTX* ctx, const MD_LINE_ANALYSIS* analysis)\n{\n    MD_ASSERT(ctx->current_block != NULL);\n\n    if(ctx->current_block->type == MD_BLOCK_CODE || ctx->current_block->type == MD_BLOCK_HTML) {\n        MD_VERBATIMLINE* line;\n\n        line = (MD_VERBATIMLINE*) md_push_block_bytes(ctx, sizeof(MD_VERBATIMLINE));\n        if(line == NULL)\n            return -1;\n\n        line->indent = analysis->indent;\n        line->beg = analysis->beg;\n        line->end = analysis->end;\n    } else {\n        MD_LINE* line;\n\n        line = (MD_LINE*) md_push_block_bytes(ctx, sizeof(MD_LINE));\n        if(line == NULL)\n            return -1;\n\n        line->beg = analysis->beg;\n        line->end = analysis->end;\n    }\n    ctx->current_block->n_lines++;\n\n    return 0;\n}",
        "begin_line": 4722,
        "end_line": 4750,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_analyze_inlines#3776",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_analyze_inlines(MD_CTX* ctx, const MD_LINE* lines, int n_lines, int table_mode)",
        "snippet": "static int\nmd_analyze_inlines(MD_CTX* ctx, const MD_LINE* lines, int n_lines, int table_mode)\n{\n    int ret;\n\n    /* Reset the previously collected stack of marks. */\n    ctx->n_marks = 0;\n\n    /* Collect all marks. */\n    if(md_collect_marks(ctx, lines, n_lines, table_mode) != 0)\n        return -1;\n\n    /* We analyze marks in few groups to handle their precedence. */\n    /* (1) Entities; code spans; autolinks; raw HTML. */\n    md_analyze_marks(ctx, lines, n_lines, 0, ctx->n_marks, _T(\"&`<>\"));\n    BACKTICK_OPENERS.head = -1;\n    BACKTICK_OPENERS.tail = -1;\n    LOWERTHEN_OPENERS.head = -1;\n    LOWERTHEN_OPENERS.tail = -1;\n    /* (2) Links. */\n    md_analyze_marks(ctx, lines, n_lines, 0, ctx->n_marks, _T(\"[]!\"));\n    MD_CHECK(md_resolve_links(ctx, lines, n_lines));\n    BRACKET_OPENERS.head = -1;\n    BRACKET_OPENERS.tail = -1;\n    ctx->unresolved_link_head = -1;\n    ctx->unresolved_link_tail = -1;\n    if(table_mode) {\n        /* (3a) Analyze table cell boundaries.\n         * Note we reset TABLECELLBOUNDARIES chain prior to the call md_analyze_marks(),\n         * not after, because caller may need it. */\n        MD_ASSERT(n_lines == 1);\n        TABLECELLBOUNDARIES.head = -1;\n        TABLECELLBOUNDARIES.tail = -1;\n        ctx->n_table_cell_boundaries = 0;\n        md_analyze_marks(ctx, lines, n_lines, 0, ctx->n_marks, _T(\"|\"));\n    } else {\n        /* (3b) Emphasis and strong emphasis; permissive autolinks. */\n        md_analyze_link_contents(ctx, lines, n_lines, 0, ctx->n_marks);\n    }\n\nabort:\n    return ret;\n}",
        "begin_line": 3776,
        "end_line": 3818,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_analyze_line#5359",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_analyze_line(MD_CTX* ctx, OFF beg, OFF* p_end, const MD_LINE_ANALYSIS* pivot_line, MD_LINE_ANALYSIS* line)",
        "snippet": "static int\nmd_analyze_line(MD_CTX* ctx, OFF beg, OFF* p_end,\n                const MD_LINE_ANALYSIS* pivot_line, MD_LINE_ANALYSIS* line)\n{\n    unsigned total_indent = 0;\n    int n_parents = 0;\n    int n_brothers = 0;\n    int n_children = 0;\n    MD_CONTAINER container;\n    int prev_line_has_list_loosening_effect = ctx->last_line_has_list_loosening_effect;\n    OFF off = beg;\n    int ret = 0;\n\n    line->indent = md_line_indentation(ctx, total_indent, off, &off);\n    total_indent += line->indent;\n    line->beg = off;\n\n    /* Given the indentation and block quote marks '>', determine how many of\n     * the current containers are our parents. */\n    while(n_parents < ctx->n_containers) {\n        MD_CONTAINER* c = &ctx->containers[n_parents];\n\n        if(c->ch == _T('>')  &&  line->indent < ctx->code_indent_offset  &&\n            off < ctx->size  &&  CH(off) == _T('>'))\n        {\n            /* Block quote mark. */\n            off++;\n            total_indent++;\n            line->indent = md_line_indentation(ctx, total_indent, off, &off);\n            total_indent += line->indent;\n\n            /* The optional 1st space after '>' is part of the block quote mark. */\n            if(line->indent > 0)\n                line->indent--;\n\n            line->beg = off;\n        } else if(c->ch != _T('>')  &&  line->indent >= c->contents_indent) {\n            /* List. */\n            line->indent -= c->contents_indent;\n        } else {\n            break;\n        }\n\n        n_parents++;\n    }\n\nredo:\n    /* Check whether we are fenced code continuation. */\n    if(pivot_line->type == MD_LINE_FENCEDCODE) {\n        line->beg = off;\n\n        /* We are another MD_LINE_FENCEDCODE unless we are closing fence\n         * which we transform into MD_LINE_BLANK. */\n        if(line->indent < ctx->code_indent_offset) {\n            if(md_is_closing_code_fence(ctx, CH(pivot_line->beg), off, &off)) {\n                line->type = MD_LINE_BLANK;\n                ctx->last_line_has_list_loosening_effect = FALSE;\n                goto done;\n            }\n        }\n\n        if(off >= ctx->size  ||  ISNEWLINE(off)) {\n            /* Blank line does not need any real indentation to be nested inside\n             * a list. */\n            if(n_brothers + n_children == 0) {\n                while(n_parents < ctx->n_containers  &&  ctx->containers[n_parents].ch != _T('>'))\n                    n_parents++;\n            }\n        }\n\n        /* Change indentation accordingly to the initial code fence. */\n        if(n_parents == ctx->n_containers) {\n            if(line->indent > pivot_line->indent)\n                line->indent -= pivot_line->indent;\n            else\n                line->indent = 0;\n\n            line->type = MD_LINE_FENCEDCODE;\n            goto done;\n        }\n    }\n\n    /* Check whether we are HTML block continuation. */\n    if(pivot_line->type == MD_LINE_HTML  &&  ctx->html_block_type > 0) {\n        int html_block_type;\n\n        html_block_type = md_is_html_block_end_condition(ctx, off, &off);\n        if(html_block_type > 0) {\n            MD_ASSERT(html_block_type == ctx->html_block_type);\n\n            /* Make sure this is the last line of the block. */\n            ctx->html_block_type = 0;\n\n            /* Some end conditions serve as blank lines at the same time. */\n            if(html_block_type == 6 || html_block_type == 7) {\n                line->type = MD_LINE_BLANK;\n                line->indent = 0;\n                goto done;\n            }\n        }\n\n        if(n_parents == ctx->n_containers) {\n            line->type = MD_LINE_HTML;\n            goto done;\n        }\n    }\n\n    /* Check for blank line. */\n    if(off >= ctx->size  ||  ISNEWLINE(off)) {\n        /* Blank line does not need any real indentation to be nested inside\n         * a list. */\n        if(n_brothers + n_children == 0) {\n            while(n_parents < ctx->n_containers  &&  ctx->containers[n_parents].ch != _T('>'))\n                n_parents++;\n        }\n\n        if(pivot_line->type == MD_LINE_INDENTEDCODE  &&  n_parents == ctx->n_containers) {\n            line->type = MD_LINE_INDENTEDCODE;\n            if(line->indent > ctx->code_indent_offset)\n                line->indent -= ctx->code_indent_offset;\n            else\n                line->indent = 0;\n            ctx->last_line_has_list_loosening_effect = FALSE;\n        } else {\n            line->type = MD_LINE_BLANK;\n            ctx->last_line_has_list_loosening_effect = (n_parents > 0  &&\n                    n_brothers + n_children == 0  &&\n                    ctx->containers[n_parents-1].ch != _T('>'));\n\n#if 1\n            /* See https://github.com/mity/md4c/issues/6\n             *\n             * This ugly checking tests we are in (yet empty) list item but not\n             * its very first line (with the list item mark).\n             *\n             * If we are such blank line, then any following non-blank line\n             * which would be part of this list item actually ends the list\n             * because \"a list item can begin with at most one blank line.\"\n             */\n            if(n_parents > 0  &&  ctx->containers[n_parents-1].ch != _T('>')  &&\n               n_brothers + n_children == 0  &&  ctx->current_block == NULL  &&\n               ctx->n_block_bytes > sizeof(MD_BLOCK))\n            {\n                MD_BLOCK* top_block = (MD_BLOCK*) ((char*)ctx->block_bytes + ctx->n_block_bytes - sizeof(MD_BLOCK));\n                if(top_block->type == MD_BLOCK_LI)\n                    ctx->last_list_item_starts_with_two_blank_lines = TRUE;\n            }\n#endif\n        }\n        goto done_on_eol;\n    } else {\n#if 1\n        /* This is 2nd half of the hack. If the flag is set (that is there\n         * were 2nd blank line at the start of the list item) and we would also\n         * belonging to such list item, then interrupt the list. */\n        ctx->last_line_has_list_loosening_effect = FALSE;\n        if(ctx->last_list_item_starts_with_two_blank_lines) {\n            if(n_parents > 0  &&  ctx->containers[n_parents-1].ch != _T('>')  &&\n               n_brothers + n_children == 0  &&  ctx->current_block == NULL  &&\n               ctx->n_block_bytes > sizeof(MD_BLOCK))\n            {\n                MD_BLOCK* top_block = (MD_BLOCK*) ((char*)ctx->block_bytes + ctx->n_block_bytes - sizeof(MD_BLOCK));\n                if(top_block->type == MD_BLOCK_LI)\n                    n_parents--;\n            }\n\n            ctx->last_list_item_starts_with_two_blank_lines = FALSE;\n        }\n#endif\n    }\n\n    /* Check whether we are Setext underline. */\n    if(line->indent < ctx->code_indent_offset  &&  pivot_line->type == MD_LINE_TEXT\n        &&  (CH(off) == _T('=') || CH(off) == _T('-'))\n        &&  (n_parents == ctx->n_containers))\n    {\n        unsigned level;\n\n        if(md_is_setext_underline(ctx, off, &off, &level)) {\n            line->type = MD_LINE_SETEXTUNDERLINE;\n            line->data = level;\n            goto done;\n        }\n    }\n\n    /* Check for thematic break line. */\n    if(line->indent < ctx->code_indent_offset  &&  ISANYOF(off, _T(\"-_*\"))) {\n        if(md_is_hr_line(ctx, off, &off)) {\n            line->type = MD_LINE_HR;\n            goto done;\n        }\n    }\n\n    /* Check for \"brother\" container. I.e. whether we are another list item\n     * in already started list. */\n    if(n_parents < ctx->n_containers  &&  n_brothers + n_children == 0) {\n        OFF tmp;\n\n        if(md_is_container_mark(ctx, line->indent, off, &tmp, &container)  &&\n           md_is_container_compatible(&ctx->containers[n_parents], &container))\n        {\n            pivot_line = &md_dummy_blank_line;\n\n            off = tmp;\n\n            total_indent += container.contents_indent - container.mark_indent;\n            line->indent = md_line_indentation(ctx, total_indent, off, &off);\n            total_indent += line->indent;\n            line->beg = off;\n\n            /* Some of the following whitespace actually still belongs to the mark. */\n            if(off >= ctx->size || ISNEWLINE(off)) {\n                container.contents_indent++;\n            } else if(line->indent <= ctx->code_indent_offset) {\n                container.contents_indent += line->indent;\n                line->indent = 0;\n            } else {\n                container.contents_indent += 1;\n                line->indent--;\n            }\n\n            ctx->containers[n_parents].mark_indent = container.mark_indent;\n            ctx->containers[n_parents].contents_indent = container.contents_indent;\n\n            n_brothers++;\n            goto redo;\n        }\n    }\n\n    /* Check for indented code.\n     * Note indented code block cannot interrupt a paragraph. */\n    if(line->indent >= ctx->code_indent_offset  &&\n        (pivot_line->type == MD_LINE_BLANK || pivot_line->type == MD_LINE_INDENTEDCODE))\n    {\n        line->type = MD_LINE_INDENTEDCODE;\n        MD_ASSERT(line->indent >= ctx->code_indent_offset);\n        line->indent -= ctx->code_indent_offset;\n        line->data = 0;\n        goto done;\n    }\n\n    /* Check for start of a new container block. */\n    if(line->indent < ctx->code_indent_offset  &&\n       md_is_container_mark(ctx, line->indent, off, &off, &container))\n    {\n        if(pivot_line->type == MD_LINE_TEXT  &&  n_parents == ctx->n_containers  &&\n                    (off >= ctx->size || ISNEWLINE(off)))\n        {\n            /* Noop. List mark followed by a blank line cannot interrupt a paragraph. */\n        } else if(pivot_line->type == MD_LINE_TEXT  &&  n_parents == ctx->n_containers  &&\n                    (container.ch == _T('.') || container.ch == _T(')'))  &&  container.start != 1)\n        {\n            /* Noop. Ordered list cannot interrupt a paragraph unless the start index is 1. */\n        } else {\n            total_indent += container.contents_indent - container.mark_indent;\n            line->indent = md_line_indentation(ctx, total_indent, off, &off);\n            total_indent += line->indent;\n\n            line->beg = off;\n            line->data = container.ch;\n\n            /* Some of the following whitespace actually still belongs to the mark. */\n            if(off >= ctx->size || ISNEWLINE(off)) {\n                container.contents_indent++;\n            } else if(line->indent <= ctx->code_indent_offset) {\n                container.contents_indent += line->indent;\n                line->indent = 0;\n            } else {\n                container.contents_indent += 1;\n                line->indent--;\n            }\n\n            if(n_brothers + n_children == 0)\n                pivot_line = &md_dummy_blank_line;\n\n            if(n_children == 0)\n                MD_CHECK(md_leave_child_containers(ctx, n_parents + n_brothers));\n\n            n_children++;\n            MD_CHECK(md_push_container(ctx, &container));\n            goto redo;\n        }\n    }\n\n    /* Check whether we are table continuation. */\n    if(pivot_line->type == MD_LINE_TABLE  &&  md_is_table_row(ctx, off, &off))\n    {\n        line->type = MD_LINE_TABLE;\n        goto done;\n    }\n\n    /* Check for ATX header. */\n    if(line->indent < ctx->code_indent_offset  &&  CH(off) == _T('#')) {\n        unsigned level;\n\n        if(md_is_atxheader_line(ctx, off, &line->beg, &off, &level)) {\n            line->type = MD_LINE_ATXHEADER;\n            line->data = level;\n            goto done;\n        }\n    }\n\n    /* Check whether we are starting code fence. */\n    if(CH(off) == _T('`') || CH(off) == _T('~')) {\n        if(md_is_opening_code_fence(ctx, off, &off)) {\n            line->type = MD_LINE_FENCEDCODE;\n            line->data = 1;\n            goto done;\n        }\n    }\n\n    /* Check for start of raw HTML block. */\n    if(CH(off) == _T('<')  &&  !(ctx->r.flags & MD_FLAG_NOHTMLBLOCKS))\n    {\n        ctx->html_block_type = md_is_html_block_start_condition(ctx, off);\n\n        /* HTML block type 7 cannot interrupt paragraph. */\n        if(ctx->html_block_type == 7  &&  pivot_line->type == MD_LINE_TEXT)\n            ctx->html_block_type = 0;\n\n        if(ctx->html_block_type > 0) {\n            /* The line itself also may immediately close the block. */\n            if(md_is_html_block_end_condition(ctx, off, &off) == ctx->html_block_type) {\n                /* Make sure this is the last line of the block. */\n                ctx->html_block_type = 0;\n            }\n\n            line->type = MD_LINE_HTML;\n            goto done;\n        }\n    }\n\n    /* Check for table underline. */\n    if((ctx->r.flags & MD_FLAG_TABLES)  &&  pivot_line->type == MD_LINE_TEXT  &&\n       (CH(off) == _T('|') || CH(off) == _T('-') || CH(off) == _T(':'))  &&\n       n_parents == ctx->n_containers)\n    {\n        unsigned col_count;\n\n        if(ctx->current_block != NULL  &&  ctx->current_block->n_lines == 1  &&\n            md_is_table_underline(ctx, off, &off, &col_count)  &&\n            md_is_table_row(ctx, pivot_line->beg, NULL))\n        {\n            line->data = col_count;\n            line->type = MD_LINE_TABLEUNDERLINE;\n            goto done;\n        }\n    }\n\n    /* By default, we are normal text line. */\n    line->type = MD_LINE_TEXT;\n    if(pivot_line->type == MD_LINE_TEXT  &&  n_brothers + n_children == 0) {\n        /* Lazy continuation. */\n        n_parents = ctx->n_containers;\n    }\n\ndone:\n    /* Scan for end of the line.\n     *\n     * Note this is bottleneck of this function as we itereate over (almost)\n     * all line contents after some initial line indentation. To optimize, we\n     * try to eat multiple chars in every loop iteration.\n     *\n     * (Measured ~6% performance boost of md2html with this optimization for\n     * normal kind of input.)\n     */\n    while(off + 4 < ctx->size  &&  !ISNEWLINE(off+0)  &&  !ISNEWLINE(off+1)\n                               &&  !ISNEWLINE(off+2)  &&  !ISNEWLINE(off+3))\n        off += 4;\n    while(off < ctx->size  &&  !ISNEWLINE(off))\n        off++;\n\ndone_on_eol:\n    /* Set end of the line. */\n    line->end = off;\n\n    /* But for ATX header, we should exclude the optional trailing mark. */\n    if(line->type == MD_LINE_ATXHEADER) {\n        OFF tmp = line->end;\n        while(tmp > line->beg && CH(tmp-1) == _T(' '))\n            tmp--;\n        while(tmp > line->beg && CH(tmp-1) == _T('#'))\n            tmp--;\n        if(tmp == line->beg || CH(tmp-1) == _T(' ') || (ctx->r.flags & MD_FLAG_PERMISSIVEATXHEADERS))\n            line->end = tmp;\n    }\n\n    /* Trim trailing spaces. */\n    if(line->type != MD_LINE_INDENTEDCODE  &&  line->type != MD_LINE_FENCEDCODE) {\n        while(line->end > line->beg && CH(line->end-1) == _T(' '))\n            line->end--;\n    }\n\n    /* Eat also the new line. */\n    if(off < ctx->size && CH(off) == _T('\\r'))\n        off++;\n    if(off < ctx->size && CH(off) == _T('\\n'))\n        off++;\n\n    *p_end = off;\n\n    /* If we belong to a list after seeing a blank line, the list is loose. */\n    if(prev_line_has_list_loosening_effect  &&  line->type != MD_LINE_BLANK  &&  n_parents + n_brothers > 0) {\n        MD_CONTAINER* c = &ctx->containers[n_parents + n_brothers - 1];\n        if(c->ch != _T('>')) {\n            MD_BLOCK* block = (MD_BLOCK*) (((char*)ctx->block_bytes) + c->block_byte_off);\n            block->flags |= MD_BLOCK_LOOSE_LIST;\n        }\n    }\n\n    /* Leave any containers we are not part of anymore. */\n    if(n_children == 0  &&  n_parents + n_brothers < ctx->n_containers)\n        MD_CHECK(md_leave_child_containers(ctx, n_parents + n_brothers));\n\n    /* Enter any container we found a mark for. */\n    if(n_brothers > 0) {\n        MD_ASSERT(n_brothers == 1);\n        MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI, 0, 0,\n                MD_BLOCK_CONTAINER_CLOSER | MD_BLOCK_CONTAINER_OPENER));\n    }\n\n    if(n_children > 0)\n        MD_CHECK(md_enter_child_containers(ctx, n_children, line->data));\n\nabort:\n    return ret;\n}",
        "begin_line": 5359,
        "end_line": 5785,
        "is_bug": true
    },
    {
        "name": "md4c.md4c.md_analyze_marks#3727",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_analyze_marks(MD_CTX* ctx, const MD_LINE* lines, int n_lines, int mark_beg, int mark_end, const CHAR* mark_chars)",
        "snippet": "static inline void\nmd_analyze_marks(MD_CTX* ctx, const MD_LINE* lines, int n_lines,\n                 int mark_beg, int mark_end, const CHAR* mark_chars)\n{\n    int i = mark_beg;\n\n    while(i < mark_end) {\n        MD_MARK* mark = &ctx->marks[i];\n\n        /* Skip resolved spans. */\n        if(mark->flags & MD_MARK_RESOLVED) {\n            if(mark->flags & MD_MARK_OPENER) {\n                MD_ASSERT(i < mark->next);\n                i = mark->next + 1;\n            } else {\n                i++;\n            }\n            continue;\n        }\n\n        /* Skip marks we do not want to deal with. */\n        if(!ISANYOF_(mark->ch, mark_chars)) {\n            i++;\n            continue;\n        }\n\n        /* Analyze the mark. */\n        switch(mark->ch) {\n            case '`':   md_analyze_backtick(ctx, i); break;\n            case '<':   /* Pass through. */\n            case '>':   md_analyze_lt_gt(ctx, i, lines, n_lines); break;\n            case '[':   /* Pass through. */\n            case '!':   /* Pass through. */\n            case ']':   md_analyze_bracket(ctx, i); break;\n            case '&':   md_analyze_entity(ctx, i); break;\n            case '|':   md_analyze_table_cell_boundary(ctx, i); break;\n            case '*':   md_analyze_asterisk(ctx, i); break;\n            case '_':   md_analyze_underscore(ctx, i); break;\n            case '~':   md_analyze_tilde(ctx, i); break;\n            case '.':   /* Pass through. */\n            case ':':   md_analyze_permissive_url_autolink(ctx, i); break;\n            case '@':   md_analyze_permissive_email_autolink(ctx, i); break;\n        }\n\n        i++;\n    }\n}",
        "begin_line": 3727,
        "end_line": 3773,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_analyze_table_cell_boundary#3486",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_analyze_table_cell_boundary(MD_CTX* ctx, int mark_index)",
        "snippet": "static void\nmd_analyze_table_cell_boundary(MD_CTX* ctx, int mark_index)\n{\n    MD_MARK* mark = &ctx->marks[mark_index];\n    mark->flags |= MD_MARK_RESOLVED;\n\n    md_mark_chain_append(ctx, &TABLECELLBOUNDARIES, mark_index);\n    ctx->n_table_cell_boundaries++;\n}",
        "begin_line": 3486,
        "end_line": 3494,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_build_mark_char_map#2694",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_build_mark_char_map(MD_CTX* ctx)",
        "snippet": "static void\nmd_build_mark_char_map(MD_CTX* ctx)\n{\n    memset(ctx->mark_char_map, 0, sizeof(ctx->mark_char_map));\n\n    ctx->mark_char_map['\\\\'] = 1;\n    ctx->mark_char_map['*'] = 1;\n    ctx->mark_char_map['_'] = 1;\n    ctx->mark_char_map['`'] = 1;\n    ctx->mark_char_map['&'] = 1;\n    ctx->mark_char_map[';'] = 1;\n    ctx->mark_char_map['<'] = 1;\n    ctx->mark_char_map['>'] = 1;\n    ctx->mark_char_map['['] = 1;\n    ctx->mark_char_map['!'] = 1;\n    ctx->mark_char_map[']'] = 1;\n    ctx->mark_char_map['\\0'] = 1;\n\n    if(ctx->r.flags & MD_FLAG_STRIKETHROUGH)\n        ctx->mark_char_map['~'] = 1;\n\n    if(ctx->r.flags & MD_FLAG_PERMISSIVEEMAILAUTOLINKS)\n        ctx->mark_char_map['@'] = 1;\n\n    if(ctx->r.flags & MD_FLAG_PERMISSIVEURLAUTOLINKS)\n        ctx->mark_char_map[':'] = 1;\n\n    if(ctx->r.flags & MD_FLAG_PERMISSIVEWWWAUTOLINKS)\n        ctx->mark_char_map['.'] = 1;\n\n    if(ctx->r.flags & MD_FLAG_TABLES)\n        ctx->mark_char_map['|'] = 1;\n\n    if(ctx->r.flags & MD_FLAG_COLLAPSEWHITESPACE) {\n        int i;\n\n        for(i = 0; i < sizeof(ctx->mark_char_map); i++) {\n            if(ISWHITESPACE_(i))\n                ctx->mark_char_map[i] = 1;\n        }\n    }\n}",
        "begin_line": 2694,
        "end_line": 2735,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_collect_marks#2737",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_collect_marks(MD_CTX* ctx, const MD_LINE* lines, int n_lines, int table_mode)",
        "snippet": "static int\nmd_collect_marks(MD_CTX* ctx, const MD_LINE* lines, int n_lines, int table_mode)\n{\n    int i;\n    int ret = 0;\n    MD_MARK* mark;\n\n    for(i = 0; i < n_lines; i++) {\n        const MD_LINE* line = &lines[i];\n        OFF off = line->beg;\n        OFF line_end = line->end;\n\n        while(TRUE) {\n            CHAR ch;\n\n#ifdef MD4C_USE_UTF16\n    /* For UTF-16, mark_char_map[] covers only ASCII. */\n    #define IS_MARK_CHAR(off)   ((CH(off) < SIZEOF_ARRAY(ctx->mark_char_map))  &&  \\\n                                (ctx->mark_char_map[(unsigned char) CH(off)]))\n#else\n    /* For 8-bit encodings, mark_char_map[] covers all 256 elements. */\n    #define IS_MARK_CHAR(off)   (ctx->mark_char_map[(unsigned char) CH(off)])\n#endif\n\n            /* Optimization: Fast path (with some loop unrolling). */\n            while(off + 4 < line_end  &&  !IS_MARK_CHAR(off+0)  &&  !IS_MARK_CHAR(off+1)\n                                      &&  !IS_MARK_CHAR(off+2)  &&  !IS_MARK_CHAR(off+3))\n                off += 4;\n            while(off < line_end  &&  !IS_MARK_CHAR(off+0))\n                off++;\n\n            if(off >= line_end)\n                break;\n\n            ch = CH(off);\n\n            /* A backslash escape.\n             * It can go beyond line->end as it may involve escaped new\n             * line to form a hard break. */\n            if(ch == _T('\\\\')  &&  off+1 < ctx->size  &&  (ISPUNCT(off+1) || ISNEWLINE(off+1))) {\n                /* Hard-break cannot be on the last line of the block. */\n                if(!ISNEWLINE(off+1)  ||  i+1 < n_lines)\n                    PUSH_MARK(ch, off, off+2, MD_MARK_RESOLVED);\n\n                /* If '`' or '>' follows, we need both marks as the backslash\n                 * may be inside a code span or an autolink where escaping is\n                 * disabled. */\n                if(CH(off+1) == _T('`') || CH(off+1) == _T('>'))\n                    off++;\n                else\n                    off += 2;\n                continue;\n            }\n\n            /* A potential (string) emphasis start/end. */\n            if(ch == _T('*')  ||  ch == _T('_')) {\n                OFF tmp = off+1;\n                int left_level;     /* What precedes: 0 = whitespace; 1 = punctuation; 2 = other char. */\n                int right_level;    /* What follows: 0 = whitespace; 1 = punctuation; 2 = other char. */\n\n                while(tmp < line_end  &&  CH(tmp) == ch)\n                    tmp++;\n\n                if(off == line->beg  ||  ISUNICODEWHITESPACEBEFORE(off))\n                    left_level = 0;\n                else if(ISUNICODEPUNCTBEFORE(off))\n                    left_level = 1;\n                else\n                    left_level = 2;\n\n                if(tmp == line_end  ||  ISUNICODEWHITESPACE(tmp))\n                    right_level = 0;\n                else if(ISUNICODEPUNCT(tmp))\n                    right_level = 1;\n                else\n                    right_level = 2;\n\n                /* Intra-word underscore doesn't have special meaning. */\n                if(ch == _T('_')  &&  left_level == 2  &&  right_level == 2) {\n                    left_level = 0;\n                    right_level = 0;\n                }\n\n                if(left_level != 0  ||  right_level != 0) {\n                    unsigned flags = 0;\n\n                    if(left_level > 0  &&  left_level >= right_level)\n                        flags |= MD_MARK_POTENTIAL_CLOSER;\n                    if(right_level > 0  &&  right_level >= left_level)\n                        flags |= MD_MARK_POTENTIAL_OPENER;\n                    if(left_level == 2  &&  right_level == 2)\n                        flags |= MD_MARK_EMPH_INTRAWORD;\n\n                    /* For \"the rule of three\" we need to remember the original\n                     * size of the mark (modulo three), before we potentially\n                     * split the mark when being later resolved partially by some\n                     * shorter closer. */\n                    switch((tmp - off) % 3) {\n                        case 0: flags |= MD_MARK_EMPH_MODULO3_0; break;\n                        case 1: flags |= MD_MARK_EMPH_MODULO3_1; break;\n                        case 2: flags |= MD_MARK_EMPH_MODULO3_2; break;\n                    }\n\n                    PUSH_MARK(ch, off, tmp, flags);\n\n                    /* During resolving, multiple asterisks may have to be\n                     * split into independent span start/ends. Consider e.g.\n                     * \"**foo* bar*\". Therefore we push also some empty dummy\n                     * marks to have enough space for that. */\n                    off++;\n                    while(off < tmp) {\n                        PUSH_MARK('D', off, off, 0);\n                        off++;\n                    }\n                    continue;\n                }\n\n                off = tmp;\n                continue;\n            }\n\n            /* A potential code span start/end. */\n            if(ch == _T('`')) {\n                OFF tmp = off+1;\n\n                while(tmp < line_end  &&  CH(tmp) == _T('`'))\n                    tmp++;\n\n                /* We limit code span marks to lower then 256 backticks. This\n                 * solves a pathologic case of too many openers, each of\n                 * different length: Their resolving is then O(n^2). */\n                if(tmp - off < 256)\n                    PUSH_MARK(ch, off, tmp, MD_MARK_POTENTIAL_OPENER | MD_MARK_POTENTIAL_CLOSER);\n\n                off = tmp;\n                continue;\n            }\n\n            /* A potential entity start. */\n            if(ch == _T('&')) {\n                PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_OPENER);\n                off++;\n                continue;\n            }\n\n            /* A potential entity end. */\n            if(ch == _T(';')) {\n                /* We surely cannot be entity unless the previous mark is '&'. */\n                if(ctx->n_marks > 0  &&  ctx->marks[ctx->n_marks-1].ch == _T('&'))\n                    PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_CLOSER);\n\n                off++;\n                continue;\n            }\n\n            /* A potential autolink or raw HTML start/end. */\n            if(ch == _T('<') || ch == _T('>')) {\n                if(!(ctx->r.flags & MD_FLAG_NOHTMLSPANS))\n                    PUSH_MARK(ch, off, off+1, (ch == _T('<') ? MD_MARK_POTENTIAL_OPENER : MD_MARK_POTENTIAL_CLOSER));\n\n                off++;\n                continue;\n            }\n\n            /* A potential link or its part. */\n            if(ch == _T('[')  ||  (ch == _T('!') && off+1 < line_end && CH(off+1) == _T('['))) {\n                OFF tmp = (ch == _T('[') ? off+1 : off+2);\n                PUSH_MARK(ch, off, tmp, MD_MARK_POTENTIAL_OPENER);\n                off = tmp;\n                /* Two dummies to make enough place for data we need if it is\n                 * a link. */\n                PUSH_MARK('D', off, off, 0);\n                PUSH_MARK('D', off, off, 0);\n                continue;\n            }\n            if(ch == _T(']')) {\n                PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_CLOSER);\n                off++;\n                continue;\n            }\n\n            /* A potential permissive e-mail autolink. */\n            if(ch == _T('@')) {\n                if(line->beg + 1 <= off  &&  ISALNUM(off-1)  &&\n                    off + 3 < line->end  &&  ISALNUM(off+1))\n                {\n                    PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_OPENER);\n                    /* Push a dummy as a reserve for a closer. */\n                    PUSH_MARK('D', off, off, 0);\n                }\n\n                off++;\n                continue;\n            }\n\n            /* A potential permissive URL autolink. */\n            if(ch == _T(':')) {\n                static struct {\n                    const CHAR* scheme;\n                    SZ scheme_size;\n                    const CHAR* suffix;\n                    SZ suffix_size;\n                } scheme_map[] = {\n                    /* In the order from the most frequently used, arguably. */\n                    { _T(\"http\"), 4,    _T(\"//\"), 2 },\n                    { _T(\"https\"), 5,   _T(\"//\"), 2 },\n                    { _T(\"ftp\"), 3,     _T(\"//\"), 2 }\n                };\n                int scheme_index;\n\n                for(scheme_index = 0; scheme_index < SIZEOF_ARRAY(scheme_map); scheme_index++) {\n                    const CHAR* scheme = scheme_map[scheme_index].scheme;\n                    const SZ scheme_size = scheme_map[scheme_index].scheme_size;\n                    const CHAR* suffix = scheme_map[scheme_index].suffix;\n                    const SZ suffix_size = scheme_map[scheme_index].suffix_size;\n\n                    if(line->beg + scheme_size <= off  &&  md_ascii_eq(STR(off-scheme_size), scheme, scheme_size)  &&\n                        (line->beg + scheme_size == off || ISWHITESPACE(off-scheme_size-1) || ISANYOF(off-scheme_size-1, _T(\"*_~([\")))  &&\n                        off + 1 + suffix_size < line->end  &&  md_ascii_eq(STR(off+1), suffix, suffix_size))\n                    {\n                        PUSH_MARK(ch, off-scheme_size, off+1+suffix_size, MD_MARK_POTENTIAL_OPENER);\n                        /* Push a dummy as a reserve for a closer. */\n                        PUSH_MARK('D', off, off, 0);\n                        off += 1 + suffix_size;\n                        continue;\n                    }\n                }\n\n                off++;\n                continue;\n            }\n\n            /* A potential permissive WWW autolink. */\n            if(ch == _T('.')) {\n                if(line->beg + 3 <= off  &&  md_ascii_eq(STR(off-3), _T(\"www\"), 3)  &&\n                    (line->beg + 3 == off || ISWHITESPACE(off-4) || ISANYOF(off-4, _T(\"*_~([\")))  &&\n                    off + 1 < line_end)\n                {\n                    PUSH_MARK(ch, off-3, off+1, MD_MARK_POTENTIAL_OPENER);\n                    /* Push a dummy as a reserve for a closer. */\n                    PUSH_MARK('D', off, off, 0);\n                    off++;\n                    continue;\n                }\n\n                off++;\n                continue;\n            }\n\n            /* A potential table cell boundary. */\n            if(table_mode  &&  ch == _T('|')) {\n                PUSH_MARK(ch, off, off+1, 0);\n                off++;\n                continue;\n            }\n\n            /* A potential strikethrough start/end. */\n            if(ch == _T('~')) {\n                OFF tmp = off+1;\n\n                while(tmp < line_end  &&  CH(tmp) == _T('~'))\n                    tmp++;\n\n                PUSH_MARK(ch, off, tmp, MD_MARK_POTENTIAL_OPENER | MD_MARK_POTENTIAL_CLOSER);\n                off = tmp;\n            }\n\n            /* Turn non-trivial whitespace into single space. */\n            if(ISWHITESPACE_(ch)) {\n                OFF tmp = off+1;\n\n                while(tmp < line_end  &&  ISWHITESPACE(tmp))\n                    tmp++;\n\n                if(tmp - off > 1  ||  ch != _T(' '))\n                    PUSH_MARK(ch, off, tmp, MD_MARK_RESOLVED);\n\n                off = tmp;\n                continue;\n            }\n\n            /* NULL character. */\n            if(ch == _T('\\0')) {\n                PUSH_MARK(ch, off, off+1, MD_MARK_RESOLVED);\n                off++;\n                continue;\n            }\n\n            off++;\n        }\n    }\n\n    /* Add a dummy mark after the end of processed block to simplify\n     * md_process_inlines(). */\n    PUSH_MARK(127, ctx->size+1, ctx->size+1, MD_MARK_RESOLVED);\n\nabort:\n    return ret;\n}",
        "begin_line": 2737,
        "end_line": 3035,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_end_current_block#4698",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_end_current_block(MD_CTX* ctx)",
        "snippet": "static int\nmd_end_current_block(MD_CTX* ctx)\n{\n    int ret = 0;\n\n    if(ctx->current_block == NULL)\n        return ret;\n\n    /* Check whether there is a reference definition. (We do this here instead\n     * of in md_analyze_line() because reference definition can take multiple\n     * lines.) */\n    if(ctx->current_block->type == MD_BLOCK_P) {\n        MD_LINE* lines = (MD_LINE*) (ctx->current_block + 1);\n        if(CH(lines[0].beg) == _T('['))\n            MD_CHECK(md_consume_link_reference_definitions(ctx));\n    }\n\n    /* Mark we are not building any block anymore. */\n    ctx->current_block = NULL;\n\nabort:\n    return ret;\n}",
        "begin_line": 4698,
        "end_line": 4720,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_enter_child_containers#5203",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_enter_child_containers(MD_CTX* ctx, int n_children, unsigned data)",
        "snippet": "static int\nmd_enter_child_containers(MD_CTX* ctx, int n_children, unsigned data)\n{\n    int i;\n    int ret = 0;\n\n    for(i = ctx->n_containers - n_children; i < ctx->n_containers; i++) {\n        MD_CONTAINER* c = &ctx->containers[i];\n        int is_ordered_list = FALSE;\n\n        switch(c->ch) {\n            case _T(')'):\n            case _T('.'):\n                is_ordered_list = TRUE;\n                /* Pass through */\n\n            case _T('-'):\n            case _T('+'):\n            case _T('*'):\n                /* Remember offset in ctx->block_bytes so we can revisit the\n                 * block if we detect it is a loose list. */\n                md_end_current_block(ctx);\n                c->block_byte_off = ctx->n_block_bytes;\n\n                MD_CHECK(md_push_container_bytes(ctx,\n                                (is_ordered_list ? MD_BLOCK_OL : MD_BLOCK_UL),\n                                c->start, data, MD_BLOCK_CONTAINER_OPENER));\n                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI, 0, data, MD_BLOCK_CONTAINER_OPENER));\n                break;\n\n            case _T('>'):\n                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_QUOTE, 0, data, MD_BLOCK_CONTAINER_OPENER));\n                break;\n\n            default:\n                MD_UNREACHABLE();\n                break;\n        }\n    }\n\nabort:\n    return ret;\n}",
        "begin_line": 5203,
        "end_line": 5245,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_is_container_mark#5289",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_is_container_mark(MD_CTX* ctx, unsigned indent, OFF beg, OFF* p_end, MD_CONTAINER* p_container)",
        "snippet": "static int\nmd_is_container_mark(MD_CTX* ctx, unsigned indent, OFF beg, OFF* p_end, MD_CONTAINER* p_container)\n{\n    OFF off = beg;\n    OFF max_end;\n\n    /* Check for block quote mark. */\n    if(off < ctx->size  &&  CH(off) == _T('>')) {\n        off++;\n        p_container->ch = _T('>');\n        p_container->is_loose = FALSE;\n        p_container->mark_indent = indent;\n        p_container->contents_indent = indent + 1;\n        *p_end = off;\n        return TRUE;\n    }\n\n    /* Check for list item bullet mark. */\n    if(off+1 < ctx->size  &&  ISANYOF(off, _T(\"-+*\"))  &&  (ISBLANK(off+1) || ISNEWLINE(off+1))) {\n        p_container->ch = CH(off);\n        p_container->is_loose = FALSE;\n        p_container->mark_indent = indent;\n        p_container->contents_indent = indent + 1;\n        *p_end = off+1;\n        return TRUE;\n    }\n\n    /* Check for ordered list item marks. */\n    max_end = off + 9;\n    if(max_end > ctx->size)\n        max_end = ctx->size;\n    p_container->start = 0;\n    while(off < max_end  &&  ISDIGIT(off)) {\n        p_container->start = p_container->start * 10 + CH(off) - _T('0');\n        off++;\n    }\n    if(off+1 < ctx->size  &&  (CH(off) == _T('.') || CH(off) == _T(')'))   &&  (ISBLANK(off+1) || ISNEWLINE(off+1))) {\n        p_container->ch = CH(off);\n        p_container->is_loose = FALSE;\n        p_container->mark_indent = indent;\n        p_container->contents_indent = indent + off - beg + 1;\n        *p_end = off+1;\n        return TRUE;\n    }\n\n    return FALSE;\n}",
        "begin_line": 5289,
        "end_line": 5335,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_is_hr_line#4780",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_is_hr_line(MD_CTX* ctx, OFF beg, OFF* p_end)",
        "snippet": "static int\nmd_is_hr_line(MD_CTX* ctx, OFF beg, OFF* p_end)\n{\n    OFF off = beg + 1;\n    int n = 1;\n\n    while(off < ctx->size  &&  (CH(off) == CH(beg) || CH(off) == _T(' ') || CH(off) == _T('\\t'))) {\n        if(CH(off) == CH(beg))\n            n++;\n        off++;\n    }\n\n    if(n < 3)\n        return FALSE;\n\n    /* Nothing else can be present on the line. */\n    if(off < ctx->size  &&  !ISNEWLINE(off))\n        return FALSE;\n\n    *p_end = off;\n    return TRUE;\n}",
        "begin_line": 4780,
        "end_line": 4801,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_is_setext_underline#4828",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_is_setext_underline(MD_CTX* ctx, OFF beg, OFF* p_end, unsigned* p_level)",
        "snippet": "static int\nmd_is_setext_underline(MD_CTX* ctx, OFF beg, OFF* p_end, unsigned* p_level)\n{\n    OFF off = beg + 1;\n\n    while(off < ctx->size  &&  CH(off) == CH(beg))\n        off++;\n\n    while(off < ctx->size  && CH(off) == _T(' '))\n        off++;\n\n    /* Optionally, space(s) can follow. */\n    while(off < ctx->size  &&  CH(off) == _T(' '))\n        off++;\n\n    /* But nothing more is allowed on the line. */\n    if(off < ctx->size  &&  !ISNEWLINE(off))\n        return FALSE;\n\n    *p_level = (CH(beg) == _T('=') ? 1 : 2);\n    *p_end = off;\n    return TRUE;\n}",
        "begin_line": 4828,
        "end_line": 4850,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_is_table_row#4230",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_is_table_row(MD_CTX* ctx, OFF beg, OFF* p_end)",
        "snippet": "static int\nmd_is_table_row(MD_CTX* ctx, OFF beg, OFF* p_end)\n{\n    MD_LINE line = { beg, beg };\n    int i;\n    int ret = FALSE;\n\n    /* Find end of line. */\n    while(line.end < ctx->size  &&  !ISNEWLINE(line.end))\n        line.end++;\n\n    MD_CHECK(md_analyze_inlines(ctx, &line, 1, TRUE));\n\n    if(TABLECELLBOUNDARIES.head >= 0) {\n        if(p_end != NULL)\n            *p_end = line.end;\n        ret = TRUE;\n    }\n\nabort:\n    /* Free any temporary memory blocks stored within some dummy marks. */\n    for(i = PTR_CHAIN.head; i >= 0; i = ctx->marks[i].next)\n        free(md_mark_get_ptr(ctx, i));\n    PTR_CHAIN.head = -1;\n    PTR_CHAIN.tail = -1;\n\n    return ret;\n}",
        "begin_line": 4230,
        "end_line": 4257,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_is_table_underline#4852",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_is_table_underline(MD_CTX* ctx, OFF beg, OFF* p_end, unsigned* p_col_count)",
        "snippet": "static int\nmd_is_table_underline(MD_CTX* ctx, OFF beg, OFF* p_end, unsigned* p_col_count)\n{\n    OFF off = beg;\n    int found_pipe = FALSE;\n    unsigned col_count = 0;\n\n    if(off < ctx->size  &&  CH(off) == _T('|')) {\n        found_pipe = TRUE;\n        off++;\n        while(off < ctx->size  &&  ISWHITESPACE(off))\n            off++;\n    }\n\n    while(1) {\n        OFF cell_beg;\n        int delimited = FALSE;\n\n        /* Cell underline (\"-----\", \":----\", \"----:\" or \":----:\") */\n        cell_beg = off;\n        if(off < ctx->size  &&  CH(off) == _T(':'))\n            off++;\n        while(off < ctx->size  &&  CH(off) == _T('-'))\n            off++;\n        if(off < ctx->size  &&  CH(off) == _T(':'))\n            off++;\n        if(off - cell_beg < 3)\n            return FALSE;\n\n        col_count++;\n\n        /* Pipe delimiter (optional at the end of line). */\n        while(off < ctx->size  &&  ISWHITESPACE(off))\n            off++;\n        if(off < ctx->size  &&  CH(off) == _T('|')) {\n            delimited = TRUE;\n            found_pipe =  TRUE;\n            off++;\n            while(off < ctx->size  &&  ISWHITESPACE(off))\n                off++;\n        }\n\n        /* Success, if we reach end of line. */\n        if(off >= ctx->size  ||  ISNEWLINE(off))\n            break;\n\n        if(!delimited)\n            return FALSE;\n    }\n\n    if(!found_pipe)\n        return FALSE;\n\n    *p_end = off;\n    *p_col_count = col_count;\n    return TRUE;\n}",
        "begin_line": 4852,
        "end_line": 4908,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_leave_child_containers#5247",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_leave_child_containers(MD_CTX* ctx, int n_keep)",
        "snippet": "static int\nmd_leave_child_containers(MD_CTX* ctx, int n_keep)\n{\n    int ret = 0;\n\n    while(ctx->n_containers > n_keep) {\n        MD_CONTAINER* c = &ctx->containers[ctx->n_containers-1];\n        int is_ordered_list = FALSE;\n\n        switch(c->ch) {\n            case _T(')'):\n            case _T('.'):\n                is_ordered_list = TRUE;\n                /* Pass through */\n\n            case _T('-'):\n            case _T('+'):\n            case _T('*'):\n                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI, 0,\n                                0, MD_BLOCK_CONTAINER_CLOSER));\n                MD_CHECK(md_push_container_bytes(ctx,\n                                (is_ordered_list ? MD_BLOCK_OL : MD_BLOCK_UL), 0,\n                                c->ch, MD_BLOCK_CONTAINER_CLOSER));\n                break;\n\n            case _T('>'):\n                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_QUOTE, 0,\n                                0, MD_BLOCK_CONTAINER_CLOSER));\n                break;\n\n            default:\n                MD_UNREACHABLE();\n                break;\n        }\n\n        ctx->n_containers--;\n    }\n\nabort:\n    return ret;\n}",
        "begin_line": 5247,
        "end_line": 5287,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_line_indentation#5337",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_line_indentation(MD_CTX* ctx, unsigned total_indent, OFF beg, OFF* p_end)",
        "snippet": "static unsigned\nmd_line_indentation(MD_CTX* ctx, unsigned total_indent, OFF beg, OFF* p_end)\n{\n    OFF off = beg;\n    unsigned indent = total_indent;\n\n    while(off < ctx->size  &&  ISBLANK(off)) {\n        if(CH(off) == _T('\\t'))\n            indent = (indent + 4) & ~3;\n        else\n            indent++;\n        off++;\n    }\n\n    *p_end = off;\n    return indent - total_indent;\n}",
        "begin_line": 5337,
        "end_line": 5353,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_mark_chain_append#2540",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_mark_chain_append(MD_CTX* ctx, MD_MARKCHAIN* chain, int mark_index)",
        "snippet": "static void\nmd_mark_chain_append(MD_CTX* ctx, MD_MARKCHAIN* chain, int mark_index)\n{\n    if(chain->tail >= 0)\n        ctx->marks[chain->tail].next = mark_index;\n    else\n        chain->head = mark_index;\n\n    ctx->marks[mark_index].prev = chain->tail;\n    chain->tail = mark_index;\n}",
        "begin_line": 2540,
        "end_line": 2550,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_parse#5912",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_parse(const MD_CHAR* text, MD_SIZE size, const MD_RENDERER* renderer, void* userdata)",
        "snippet": "int\nmd_parse(const MD_CHAR* text, MD_SIZE size, const MD_RENDERER* renderer, void* userdata)\n{\n    MD_CTX ctx;\n    int i;\n    int ret;\n\n    /* Setup context structure. */\n    memset(&ctx, 0, sizeof(MD_CTX));\n    ctx.text = text;\n    ctx.size = size;\n    memcpy(&ctx.r, renderer, sizeof(MD_RENDERER));\n    ctx.userdata = userdata;\n    ctx.code_indent_offset = (ctx.r.flags & MD_FLAG_NOINDENTEDCODEBLOCKS) ? (OFF)(-1) : 4;\n    md_build_mark_char_map(&ctx);\n\n    /* Reset all unresolved opener mark chains. */\n    for(i = 0; i < SIZEOF_ARRAY(ctx.mark_chains); i++) {\n        ctx.mark_chains[i].head = -1;\n        ctx.mark_chains[i].tail = -1;\n    }\n    ctx.unresolved_link_head = -1;\n    ctx.unresolved_link_tail = -1;\n\n    /* All the work. */\n    ret = md_process_doc(&ctx);\n\n    /* Clean-up. */\n    md_free_ref_defs(&ctx);\n    md_free_ref_def_hashtable(&ctx);\n    free(ctx.buffer);\n    free(ctx.marks);\n    free(ctx.block_bytes);\n    free(ctx.containers);\n\n    return ret;\n}",
        "begin_line": 5912,
        "end_line": 5948,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_process_doc#5851",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_process_doc(MD_CTX *ctx)",
        "snippet": "static int\nmd_process_doc(MD_CTX *ctx)\n{\n    const MD_LINE_ANALYSIS* pivot_line = &md_dummy_blank_line;\n    MD_LINE_ANALYSIS line_buf[2];\n    MD_LINE_ANALYSIS* line = &line_buf[0];\n    OFF off = 0;\n    int ret = 0;\n\n    MD_ENTER_BLOCK(MD_BLOCK_DOC, NULL);\n\n    while(off < ctx->size) {\n        if(line == pivot_line)\n            line = (line == &line_buf[0] ? &line_buf[1] : &line_buf[0]);\n\n        MD_CHECK(md_analyze_line(ctx, off, &off, pivot_line, line));\n        MD_CHECK(md_process_line(ctx, &pivot_line, line));\n    }\n\n    md_end_current_block(ctx);\n\n    MD_CHECK(md_build_ref_def_hashtable(ctx));\n\n    /* Process all blocks. */\n    MD_CHECK(md_leave_child_containers(ctx, 0));\n    MD_CHECK(md_process_all_blocks(ctx));\n\n    MD_LEAVE_BLOCK(MD_BLOCK_DOC, NULL);\n\nabort:\n\n#if 0\n    /* Output some memory consumption statistics. */\n    {\n        char buffer[256];\n        sprintf(buffer, \"Alloced %u bytes for block buffer.\",\n                    (unsigned)(ctx->alloc_block_bytes));\n        MD_LOG(buffer);\n\n        sprintf(buffer, \"Alloced %u bytes for containers buffer.\",\n                    (unsigned)(ctx->alloc_containers * sizeof(MD_CONTAINER)));\n        MD_LOG(buffer);\n\n        sprintf(buffer, \"Alloced %u bytes for marks buffer.\",\n                    (unsigned)(ctx->alloc_marks * sizeof(MD_MARK)));\n        MD_LOG(buffer);\n\n        sprintf(buffer, \"Alloced %u bytes for aux. buffer.\",\n                    (unsigned)(ctx->alloc_buffer * sizeof(MD_CHAR)));\n        MD_LOG(buffer);\n    }\n#endif\n\n    return ret;\n}",
        "begin_line": 5851,
        "end_line": 5905,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_process_line#5787",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_process_line(MD_CTX* ctx, const MD_LINE_ANALYSIS** p_pivot_line, const MD_LINE_ANALYSIS* line)",
        "snippet": "static int\nmd_process_line(MD_CTX* ctx, const MD_LINE_ANALYSIS** p_pivot_line, const MD_LINE_ANALYSIS* line)\n{\n    const MD_LINE_ANALYSIS* pivot_line = *p_pivot_line;\n    int ret = 0;\n\n    /* Blank line ends current leaf block. */\n    if(line->type == MD_LINE_BLANK) {\n        MD_CHECK(md_end_current_block(ctx));\n        *p_pivot_line = &md_dummy_blank_line;\n        return 0;\n    }\n\n    /* Some line types form block on their own. */\n    if(line->type == MD_LINE_HR || line->type == MD_LINE_ATXHEADER) {\n        MD_CHECK(md_end_current_block(ctx));\n\n        /* Add our single-line block. */\n        MD_CHECK(md_start_new_block(ctx, line));\n        MD_CHECK(md_add_line_into_current_block(ctx, line));\n        MD_CHECK(md_end_current_block(ctx));\n        *p_pivot_line = &md_dummy_blank_line;\n        return 0;\n    }\n\n    /* MD_LINE_SETEXTUNDERLINE changes meaning of the current block and ends it. */\n    if(line->type == MD_LINE_SETEXTUNDERLINE) {\n        MD_ASSERT(ctx->current_block != NULL);\n        ctx->current_block->type = MD_BLOCK_H;\n        ctx->current_block->data = line->data;\n        MD_CHECK(md_end_current_block(ctx));\n        *p_pivot_line = &md_dummy_blank_line;\n        return 0;\n    }\n\n    /* MD_LINE_TABLEUNDERLINE changes meaning of the current block. */\n    if(line->type == MD_LINE_TABLEUNDERLINE) {\n        MD_ASSERT(ctx->current_block != NULL);\n        MD_ASSERT(ctx->current_block->n_lines == 1);\n        ctx->current_block->type = MD_BLOCK_TABLE;\n        ctx->current_block->data = line->data;\n        MD_ASSERT(pivot_line != &md_dummy_blank_line);\n        ((MD_LINE_ANALYSIS*)pivot_line)->type = MD_LINE_TABLE;\n        MD_CHECK(md_add_line_into_current_block(ctx, line));\n        return 0;\n    }\n\n    /* The current block also ends if the line has different type. */\n    if(line->type != pivot_line->type)\n        MD_CHECK(md_end_current_block(ctx));\n\n    /* The current line may start a new block. */\n    if(ctx->current_block == NULL) {\n        MD_CHECK(md_start_new_block(ctx, line));\n        *p_pivot_line = line;\n    }\n\n    /* In all other cases the line is just a continuation of the current block. */\n    MD_CHECK(md_add_line_into_current_block(ctx, line));\n\nabort:\n    return ret;\n}",
        "begin_line": 5787,
        "end_line": 5849,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_push_block_bytes#4569",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_push_block_bytes(MD_CTX* ctx, int n_bytes)",
        "snippet": "static void*\nmd_push_block_bytes(MD_CTX* ctx, int n_bytes)\n{\n    void* ptr;\n\n    if(ctx->n_block_bytes + n_bytes > ctx->alloc_block_bytes) {\n        void* new_block_bytes;\n\n        ctx->alloc_block_bytes = (ctx->alloc_block_bytes > 0 ? ctx->alloc_block_bytes * 2 : 512);\n        new_block_bytes = realloc(ctx->block_bytes, ctx->alloc_block_bytes);\n        if(new_block_bytes == NULL) {\n            MD_LOG(\"realloc() failed.\");\n            return NULL;\n        }\n\n        /* Fix the ->current_block after the reallocation. */\n        if(ctx->current_block != NULL) {\n            OFF off_current_block = (char*) ctx->current_block - (char*) ctx->block_bytes;\n            ctx->current_block = (MD_BLOCK*) ((char*) new_block_bytes + off_current_block);\n        }\n\n        ctx->block_bytes = new_block_bytes;\n    }\n\n    ptr = (char*)ctx->block_bytes + ctx->n_block_bytes;\n    ctx->n_block_bytes += n_bytes;\n    return ptr;\n}",
        "begin_line": 4569,
        "end_line": 4596,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_push_container#5183",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_push_container(MD_CTX* ctx, const MD_CONTAINER* container)",
        "snippet": "static int\nmd_push_container(MD_CTX* ctx, const MD_CONTAINER* container)\n{\n    if(ctx->n_containers >= ctx->alloc_containers) {\n        MD_CONTAINER* new_containers;\n\n        ctx->alloc_containers = (ctx->alloc_containers > 0 ? ctx->alloc_containers * 2 : 16);\n        new_containers = realloc(ctx->containers, ctx->alloc_containers * sizeof(MD_CONTAINER));\n        if(new_containers == NULL) {\n            MD_LOG(\"realloc() failed.\");\n            return -1;\n        }\n\n        ctx->containers = new_containers;\n    }\n\n    memcpy(&ctx->containers[ctx->n_containers++], container, sizeof(MD_CONTAINER));\n    return 0;\n}",
        "begin_line": 5183,
        "end_line": 5201,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_push_container_bytes#4752",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_push_container_bytes(MD_CTX* ctx, MD_BLOCKTYPE type, unsigned start, unsigned data, unsigned flags)",
        "snippet": "static int\nmd_push_container_bytes(MD_CTX* ctx, MD_BLOCKTYPE type, unsigned start,\n                        unsigned data, unsigned flags)\n{\n    MD_BLOCK* block;\n    int ret = 0;\n\n    MD_CHECK(md_end_current_block(ctx));\n\n    block = (MD_BLOCK*) md_push_block_bytes(ctx, sizeof(MD_BLOCK));\n    if(block == NULL)\n        return -1;\n\n    block->type = type;\n    block->flags = flags;\n    block->data = data;\n    block->n_lines = start;\n\nabort:\n    return ret;\n}",
        "begin_line": 4752,
        "end_line": 4772,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_push_mark#2500",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_push_mark(MD_CTX* ctx)",
        "snippet": "static MD_MARK*\nmd_push_mark(MD_CTX* ctx)\n{\n    if(ctx->n_marks >= ctx->alloc_marks) {\n        MD_MARK* new_marks;\n\n        ctx->alloc_marks = (ctx->alloc_marks > 0 ? ctx->alloc_marks * 2 : 64);\n        new_marks = realloc(ctx->marks, ctx->alloc_marks * sizeof(MD_MARK));\n        if(new_marks == NULL) {\n            MD_LOG(\"realloc() failed.\");\n            return NULL;\n        }\n\n        ctx->marks = new_marks;\n    }\n\n    return &ctx->marks[ctx->n_marks++];\n}",
        "begin_line": 2500,
        "end_line": 2517,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_resolve_links#3315",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_resolve_links(MD_CTX* ctx, const MD_LINE* lines, int n_lines)",
        "snippet": "static int\nmd_resolve_links(MD_CTX* ctx, const MD_LINE* lines, int n_lines)\n{\n    int opener_index = ctx->unresolved_link_head;\n    OFF last_link_beg = 0;\n    OFF last_link_end = 0;\n    OFF last_img_beg = 0;\n    OFF last_img_end = 0;\n\n    while(opener_index >= 0) {\n        MD_MARK* opener = &ctx->marks[opener_index];\n        int closer_index = opener->next;\n        MD_MARK* closer = &ctx->marks[closer_index];\n        int next_index = opener->prev;\n        MD_MARK* next_opener;\n        MD_MARK* next_closer;\n        MD_LINK_ATTR attr;\n        int is_link = FALSE;\n\n        if(next_index >= 0) {\n            next_opener = &ctx->marks[next_index];\n            next_closer = &ctx->marks[next_opener->next];\n        } else {\n            next_opener = NULL;\n            next_closer = NULL;\n        }\n\n        /* If nested (\"[ [ ] ]\"), we need to make sure that:\n         *   - The outer does not end inside of (...) belonging to the inner.\n         *   - The outer cannot be link if the inner is link (i.e. not image).\n         *\n         * (Note we here analyze from inner to outer as the marks are ordered\n         * by closer->beg.)\n         */\n        if((opener->beg < last_link_beg  &&  closer->end < last_link_end)  ||\n           (opener->beg < last_img_beg  &&  closer->end < last_img_end)  ||\n           (opener->beg < last_link_end  &&  opener->ch == '['))\n        {\n            opener_index = next_index;\n            continue;\n        }\n\n        if(next_opener != NULL  &&  next_opener->beg == closer->end) {\n            if(next_closer->beg > closer->end + 1) {\n                /* Might be full reference link. */\n                is_link = md_is_link_reference(ctx, lines, n_lines, next_opener->beg, next_closer->end, &attr);\n            } else {\n                /* Might be shortcut reference link. */\n                is_link = md_is_link_reference(ctx, lines, n_lines, opener->beg, closer->end, &attr);\n            }\n\n            if(is_link < 0)\n                return -1;\n\n            if(is_link) {\n                /* Eat the 2nd \"[...]\". */\n                closer->end = next_closer->end;\n            }\n        } else {\n            if(closer->end < ctx->size  &&  CH(closer->end) == _T('(')) {\n                /* Might be inline link. */\n                OFF inline_link_end = -1;\n\n                is_link = md_is_inline_link_spec(ctx, lines, n_lines, closer->end, &inline_link_end, &attr);\n                if(is_link < 0)\n                    return -1;\n\n                /* Check the closing ')' is not inside an already resolved range\n                 * (i.e. a range with a higher priority), e.g. a code span. */\n                if(is_link) {\n                    int i = closer_index + 1;\n\n                    while(i < ctx->n_marks) {\n                        MD_MARK* mark = &ctx->marks[i];\n\n                        if(mark->beg >= inline_link_end)\n                            break;\n                        if((mark->flags & (MD_MARK_OPENER | MD_MARK_RESOLVED)) == (MD_MARK_OPENER | MD_MARK_RESOLVED)) {\n                            if(ctx->marks[mark->next].beg >= inline_link_end) {\n                                /* Cancel the link status. */\n                                if(attr.title_needs_free)\n                                    free(attr.title);\n                                is_link = FALSE;\n                                break;\n                            }\n\n                            i = mark->next + 1;\n                        } else {\n                            i++;\n                        }\n                    }\n                }\n\n                if(is_link) {\n                    /* Eat the \"(...)\" */\n                    closer->end = inline_link_end;\n                }\n            }\n\n            if(!is_link) {\n                /* Might be collapsed reference link. */\n                is_link = md_is_link_reference(ctx, lines, n_lines, opener->beg, closer->end, &attr);\n                if(is_link < 0)\n                    return -1;\n            }\n        }\n\n        if(is_link) {\n            /* Resolve the brackets as a link. */\n            opener->flags |= MD_MARK_OPENER | MD_MARK_RESOLVED;\n            closer->flags |= MD_MARK_CLOSER | MD_MARK_RESOLVED;\n\n            /* If it is a link, we store the destination and title in the two\n             * dummy marks after the opener. */\n            MD_ASSERT(ctx->marks[opener_index+1].ch == 'D');\n            ctx->marks[opener_index+1].beg = attr.dest_beg;\n            ctx->marks[opener_index+1].end = attr.dest_end;\n\n            MD_ASSERT(ctx->marks[opener_index+2].ch == 'D');\n            md_mark_store_ptr(ctx, opener_index+2, attr.title);\n            if(attr.title_needs_free)\n                md_mark_chain_append(ctx, &PTR_CHAIN, opener_index+2);\n            ctx->marks[opener_index+2].prev = attr.title_size;\n\n            if(opener->ch == '[') {\n                last_link_beg = opener->beg;\n                last_link_end = closer->end;\n            } else {\n                last_img_beg = opener->beg;\n                last_img_end = closer->end;\n            }\n\n            md_analyze_link_contents(ctx, lines, n_lines, opener_index+1, closer_index);\n        }\n\n        opener_index = next_index;\n    }\n\n    return 0;\n}",
        "begin_line": 3315,
        "end_line": 3454,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_start_new_block#4598",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_start_new_block(MD_CTX* ctx, const MD_LINE_ANALYSIS* line)",
        "snippet": "static int\nmd_start_new_block(MD_CTX* ctx, const MD_LINE_ANALYSIS* line)\n{\n    MD_BLOCK* block;\n\n    MD_ASSERT(ctx->current_block == NULL);\n\n    block = (MD_BLOCK*) md_push_block_bytes(ctx, sizeof(MD_BLOCK));\n    if(block == NULL)\n        return -1;\n\n    switch(line->type) {\n        case MD_LINE_HR:\n            block->type = MD_BLOCK_HR;\n            break;\n\n        case MD_LINE_ATXHEADER:\n        case MD_LINE_SETEXTHEADER:\n            block->type = MD_BLOCK_H;\n            break;\n\n        case MD_LINE_FENCEDCODE:\n        case MD_LINE_INDENTEDCODE:\n            block->type = MD_BLOCK_CODE;\n            break;\n\n        case MD_LINE_TEXT:\n            block->type = MD_BLOCK_P;\n            break;\n\n        case MD_LINE_HTML:\n            block->type = MD_BLOCK_HTML;\n            break;\n\n        case MD_LINE_BLANK:\n        case MD_LINE_SETEXTUNDERLINE:\n        case MD_LINE_TABLEUNDERLINE:\n        default:\n            MD_UNREACHABLE();\n            break;\n    }\n\n    block->flags = 0;\n    block->data = line->data;\n    block->n_lines = 0;\n\n    ctx->current_block = block;\n    return 0;\n}",
        "begin_line": 4598,
        "end_line": 4646,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_strchr#285",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_strchr(const CHAR* str, CHAR ch)",
        "snippet": "static inline const CHAR*\nmd_strchr(const CHAR* str, CHAR ch)\n{\n    OFF i;\n    for(i = 0; str[i] != _T('\\0'); i++) {\n        if(ch == str[i])\n            return (str + i);\n    }\n    return NULL;\n}",
        "begin_line": 285,
        "end_line": 294,
        "is_bug": false
    }
]