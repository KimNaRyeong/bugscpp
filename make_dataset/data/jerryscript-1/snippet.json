[
    {
        "name": "jerry-core.api.jerry.jerry_create_external_function#1502",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_create_external_function (jerry_external_handler_t handler_p) /**< pointer to native handler                                                                      *   for the function */",
        "snippet": "jerry_value_t\njerry_create_external_function (jerry_external_handler_t handler_p) /**< pointer to native handler\n                                                                     *   for the function */\n{\n  jerry_assert_api_available ();\n\n  ecma_object_t *func_obj_p = ecma_op_create_external_function_object (handler_p);\n  return ecma_make_object_value (func_obj_p);\n}",
        "begin_line": 1502,
        "end_line": 1510,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_create_string#1704",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_create_string (const jerry_char_t *str_p) /**< pointer to string */",
        "snippet": "jerry_value_t\njerry_create_string (const jerry_char_t *str_p) /**< pointer to string */\n{\n  return jerry_create_string_sz (str_p, lit_zt_utf8_string_size ((lit_utf8_byte_t *) str_p));\n}",
        "begin_line": 1704,
        "end_line": 1708,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_create_string_sz#1718",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_create_string_sz (const jerry_char_t *str_p, /**< pointer to string */                         jerry_size_t str_size) /**< string size */",
        "snippet": "jerry_value_t\njerry_create_string_sz (const jerry_char_t *str_p, /**< pointer to string */\n                        jerry_size_t str_size) /**< string size */\n{\n  jerry_assert_api_available ();\n\n  ecma_string_t *ecma_str_p = ecma_new_ecma_string_from_utf8 ((lit_utf8_byte_t *) str_p,\n                                                              (lit_utf8_size_t) str_size);\n  return ecma_make_string_value (ecma_str_p);\n}",
        "begin_line": 1718,
        "end_line": 1727,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_create_undefined#1566",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_create_undefined (void)",
        "snippet": "jerry_value_t\njerry_create_undefined (void)\n{\n  jerry_assert_api_available ();\n\n  return ECMA_VALUE_UNDEFINED;\n}",
        "begin_line": 1566,
        "end_line": 1572,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_get_global_object#646",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_get_global_object (void)",
        "snippet": "jerry_value_t\njerry_get_global_object (void)\n{\n  jerry_assert_api_available ();\n  ecma_object_t *global_obj_p = ecma_builtin_get_global ();\n  ecma_ref_object (global_obj_p);\n  return ecma_make_object_value (global_obj_p);\n}",
        "begin_line": 646,
        "end_line": 653,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_init#189",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_init (jerry_init_flag_t flags) /**< combination of Jerry flags */",
        "snippet": "void\njerry_init (jerry_init_flag_t flags) /**< combination of Jerry flags */\n{\n  /* This function cannot be called twice unless jerry_cleanup is called. */\n  JERRY_ASSERT (!(JERRY_CONTEXT (status_flags) & ECMA_STATUS_API_AVAILABLE));\n\n  /* Zero out all non-external members. */\n  memset ((char *) &JERRY_CONTEXT_STRUCT + offsetof (jerry_context_t, JERRY_CONTEXT_FIRST_MEMBER), 0,\n          sizeof (jerry_context_t) - offsetof (jerry_context_t, JERRY_CONTEXT_FIRST_MEMBER));\n\n  JERRY_CONTEXT (jerry_init_flags) = flags;\n\n  jerry_make_api_available ();\n\n  jmem_init ();\n  ecma_init ();\n}",
        "begin_line": 189,
        "end_line": 205,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_is_feature_enabled#939",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_is_feature_enabled (const jerry_feature_t feature) /**< feature to check */",
        "snippet": "bool\njerry_is_feature_enabled (const jerry_feature_t feature) /**< feature to check */\n{\n  JERRY_ASSERT (feature < JERRY_FEATURE__COUNT);\n\n  return (false\n#if ENABLED (JERRY_CPOINTER_32_BIT)\n          || feature == JERRY_FEATURE_CPOINTER_32_BIT\n#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */\n#if ENABLED (JERRY_ERROR_MESSAGES)\n          || feature == JERRY_FEATURE_ERROR_MESSAGES\n#endif /* ENABLED (JERRY_ERROR_MESSAGES) */\n#if ENABLED (JERRY_PARSER)\n          || feature == JERRY_FEATURE_JS_PARSER\n#endif /* ENABLED (JERRY_PARSER) */\n#if ENABLED (JERRY_MEM_STATS)\n          || feature == JERRY_FEATURE_MEM_STATS\n#endif /* ENABLED (JERRY_MEM_STATS) */\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n          || feature == JERRY_FEATURE_PARSER_DUMP\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n#if ENABLED (JERRY_REGEXP_DUMP_BYTE_CODE)\n          || feature == JERRY_FEATURE_REGEXP_DUMP\n#endif /* ENABLED (JERRY_REGEXP_DUMP_BYTE_CODE) */\n#if ENABLED (JERRY_SNAPSHOT_SAVE)\n          || feature == JERRY_FEATURE_SNAPSHOT_SAVE\n#endif /* ENABLED (JERRY_SNAPSHOT_SAVE) */\n#if ENABLED (JERRY_SNAPSHOT_EXEC)\n          || feature == JERRY_FEATURE_SNAPSHOT_EXEC\n#endif /* ENABLED (JERRY_SNAPSHOT_EXEC) */\n#if ENABLED (JERRY_DEBUGGER)\n          || feature == JERRY_FEATURE_DEBUGGER\n#endif /* ENABLED (JERRY_DEBUGGER) */\n#if ENABLED (JERRY_VM_EXEC_STOP)\n          || feature == JERRY_FEATURE_VM_EXEC_STOP\n#endif /* ENABLED (JERRY_VM_EXEC_STOP) */\n#if ENABLED (JERRY_BUILTIN_JSON)\n          || feature == JERRY_FEATURE_JSON\n#endif /* ENABLED (JERRY_BUILTIN_JSON) */\n#if ENABLED (JERRY_ES2015_BUILTIN_PROMISE)\n          || feature == JERRY_FEATURE_PROMISE\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */\n#if ENABLED (JERRY_ES2015)\n          || feature == JERRY_FEATURE_SYMBOL\n#endif /* ENABLED (JERRY_ES2015) */\n#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n          || feature == JERRY_FEATURE_TYPEDARRAY\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n#if ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW)\n          || feature == JERRY_FEATURE_DATAVIEW\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW) */\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n          || feature == JERRY_FEATURE_PROXY\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n#if ENABLED (JERRY_BUILTIN_DATE)\n          || feature == JERRY_FEATURE_DATE\n#endif /* ENABLED (JERRY_BUILTIN_DATE) */\n#if ENABLED (JERRY_BUILTIN_REGEXP)\n          || feature == JERRY_FEATURE_REGEXP\n#endif /* ENABLED (JERRY_BUILTIN_REGEXP) */\n#if ENABLED (JERRY_LINE_INFO)\n          || feature == JERRY_FEATURE_LINE_INFO\n#endif /* ENABLED (JERRY_LINE_INFO) */\n#if ENABLED (JERRY_LOGGING)\n          || feature == JERRY_FEATURE_LOGGING\n#endif /* ENABLED (JERRY_LOGGING) */\n#if ENABLED (JERRY_ES2015_BUILTIN_MAP)\n          || feature == JERRY_FEATURE_MAP\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_MAP) */\n#if ENABLED (JERRY_ES2015_BUILTIN_SET)\n          || feature == JERRY_FEATURE_SET\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_SET) */\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP)\n          || feature == JERRY_FEATURE_WEAKMAP\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) */\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)\n          || feature == JERRY_FEATURE_WEAKSET\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */\n          );\n}",
        "begin_line": 939,
        "end_line": 1018,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_is_valid_utf8_string#3378",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_is_valid_utf8_string (const jerry_char_t *utf8_buf_p, /**< UTF-8 string */                             jerry_size_t buf_size) /**< string size */",
        "snippet": "bool\njerry_is_valid_utf8_string (const jerry_char_t *utf8_buf_p, /**< UTF-8 string */\n                            jerry_size_t buf_size) /**< string size */\n{\n  return lit_is_valid_utf8_string ((lit_utf8_byte_t *) utf8_buf_p,\n                                   (lit_utf8_size_t) buf_size);\n}",
        "begin_line": 3378,
        "end_line": 3384,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_parse#408",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_parse (const jerry_char_t *resource_name_p, /**< resource name (usually a file name) */              size_t resource_name_length, /**< length of resource name */              const jerry_char_t *source_p, /**< script source */              size_t source_size, /**< script source size */              uint32_t parse_opts) /**< jerry_parse_opts_t option bits */",
        "snippet": "jerry_value_t\njerry_parse (const jerry_char_t *resource_name_p, /**< resource name (usually a file name) */\n             size_t resource_name_length, /**< length of resource name */\n             const jerry_char_t *source_p, /**< script source */\n             size_t source_size, /**< script source size */\n             uint32_t parse_opts) /**< jerry_parse_opts_t option bits */\n{\n#if ENABLED (JERRY_DEBUGGER) && ENABLED (JERRY_PARSER)\n  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n      && resource_name_length > 0)\n  {\n    jerry_debugger_send_string (JERRY_DEBUGGER_SOURCE_CODE_NAME,\n                                JERRY_DEBUGGER_NO_SUBTYPE,\n                                resource_name_p,\n                                resource_name_length);\n  }\n#else /* !(ENABLED (JERRY_DEBUGGER) && ENABLED (JERRY_PARSER)) */\n  JERRY_UNUSED (resource_name_p);\n  JERRY_UNUSED (resource_name_length);\n#endif /* ENABLED (JERRY_DEBUGGER) && ENABLED (JERRY_PARSER) */\n\n#if ENABLED (JERRY_PARSER)\n  jerry_assert_api_available ();\n\n#if ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ERROR_MESSAGES) || ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n  if (resource_name_length == 0)\n  {\n    JERRY_CONTEXT (resource_name) = ecma_make_magic_string_value (LIT_MAGIC_STRING_RESOURCE_ANON);\n  }\n  else\n  {\n    JERRY_CONTEXT (resource_name) = ecma_find_or_create_literal_string (resource_name_p,\n                                                                        (lit_utf8_size_t) resource_name_length);\n  }\n#endif /* ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ERROR_MESSAGES) || ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n  ecma_compiled_code_t *bytecode_data_p;\n  ecma_value_t parse_status;\n\n  parse_status = parser_parse_script (NULL,\n                                      0,\n                                      source_p,\n                                      source_size,\n                                      parse_opts,\n                                      &bytecode_data_p);\n\n  if (ECMA_IS_VALUE_ERROR (parse_status))\n  {\n    return ecma_create_error_reference_from_context ();\n  }\n\n  ecma_free_value (parse_status);\n\n  ecma_object_t *lex_env_p = ecma_get_global_environment ();\n  ecma_object_t *func_obj_p = ecma_op_create_simple_function_object (lex_env_p, bytecode_data_p);\n  ecma_bytecode_deref (bytecode_data_p);\n\n  return ecma_make_object_value (func_obj_p);\n#else /* !ENABLED (JERRY_PARSER) */\n  JERRY_UNUSED (source_p);\n  JERRY_UNUSED (source_size);\n  JERRY_UNUSED (parse_opts);\n\n  return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG (\"The parser has been disabled.\")));\n#endif /* ENABLED (JERRY_PARSER) */\n}",
        "begin_line": 408,
        "end_line": 473,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_release_value#1389",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_release_value (jerry_value_t value) /**< API value */",
        "snippet": "void\njerry_release_value (jerry_value_t value) /**< API value */\n{\n  jerry_assert_api_available ();\n\n  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))\n  {\n    ecma_deref_error_reference (ecma_get_error_reference_from_value (value));\n    return;\n  }\n\n  ecma_free_value (value);\n}",
        "begin_line": 1389,
        "end_line": 1401,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_return#163",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_return (jerry_value_t value) /**< return value */",
        "snippet": "static jerry_value_t\njerry_return (jerry_value_t value) /**< return value */\n{\n  if (ECMA_IS_VALUE_ERROR (value))\n  {\n    value = ecma_create_error_reference_from_context ();\n  }\n\n  return value;\n}",
        "begin_line": 163,
        "end_line": 172,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_run#567",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_run (const jerry_value_t func_val) /**< function to run */",
        "snippet": "jerry_value_t\njerry_run (const jerry_value_t func_val) /**< function to run */\n{\n  jerry_assert_api_available ();\n\n  if (!ecma_is_value_object (func_val))\n  {\n    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));\n  }\n\n  ecma_object_t *func_obj_p = ecma_get_object_from_value (func_val);\n\n  if (ecma_get_object_type (func_obj_p) != ECMA_OBJECT_TYPE_FUNCTION\n      || ecma_get_object_is_builtin (func_obj_p))\n  {\n    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));\n  }\n\n  ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_obj_p;\n\n  ecma_object_t *scope_p = ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t,\n                                                                       ext_func_p->u.function.scope_cp);\n\n  if (scope_p != ecma_get_global_environment ())\n  {\n    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));\n  }\n\n  return jerry_return (vm_run_global (ecma_op_function_get_compiled_code (ext_func_p)));\n}",
        "begin_line": 567,
        "end_line": 596,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_set_property#2394",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_set_property (const jerry_value_t obj_val, /**< object value */                     const jerry_value_t prop_name_val, /**< property name (string value) */                     const jerry_value_t value_to_set) /**< value to set */",
        "snippet": "jerry_value_t\njerry_set_property (const jerry_value_t obj_val, /**< object value */\n                    const jerry_value_t prop_name_val, /**< property name (string value) */\n                    const jerry_value_t value_to_set) /**< value to set */\n{\n  jerry_assert_api_available ();\n\n  if (ecma_is_value_error_reference (value_to_set)\n      || !ecma_is_value_object (obj_val)\n      || !ecma_is_value_prop_name (prop_name_val))\n  {\n    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));\n  }\n\n  return jerry_return (ecma_op_object_put (ecma_get_object_from_value (obj_val),\n                                           ecma_get_prop_name_from_value (prop_name_val),\n                                           value_to_set,\n                                           true));\n}",
        "begin_line": 2394,
        "end_line": 2412,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_value_is_error#725",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_value_is_error (const jerry_value_t value) /**< api value */",
        "snippet": "bool\njerry_value_is_error (const jerry_value_t value) /**< api value */\n{\n  jerry_assert_api_available ();\n\n  return ecma_is_value_error_reference (value);\n}",
        "begin_line": 725,
        "end_line": 731,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_free_unused_memory#1479",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_free_unused_memory (jmem_pressure_t pressure) /**< current pressure */",
        "snippet": "void\necma_free_unused_memory (jmem_pressure_t pressure) /**< current pressure */\n{\n#if ENABLED (JERRY_DEBUGGER)\n  while ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n         && JERRY_CONTEXT (debugger_byte_code_free_tail) != ECMA_NULL_POINTER)\n  {\n    /* Wait until all byte code is freed or the connection is aborted. */\n    jerry_debugger_receive (NULL);\n  }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n  if (JERRY_LIKELY (pressure == JMEM_PRESSURE_LOW))\n  {\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n    if (JERRY_CONTEXT (ecma_prop_hashmap_alloc_state) > ECMA_PROP_HASHMAP_ALLOC_ON)\n    {\n      --JERRY_CONTEXT (ecma_prop_hashmap_alloc_state);\n    }\n    JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_HIGH_PRESSURE_GC;\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n    /*\n     * If there is enough newly allocated objects since last GC, probably it is worthwhile to start GC now.\n     * Otherwise, probability to free sufficient space is considered to be low.\n     */\n    size_t new_objects_fraction = CONFIG_ECMA_GC_NEW_OBJECTS_FRACTION;\n\n    if (JERRY_CONTEXT (ecma_gc_new_objects) * new_objects_fraction > JERRY_CONTEXT (ecma_gc_objects_number))\n    {\n      ecma_gc_run ();\n    }\n\n    return;\n  }\n  else if (pressure == JMEM_PRESSURE_HIGH)\n  {\n    /* Freeing as much memory as we currently can */\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n    if (JERRY_CONTEXT (status_flags) & ECMA_STATUS_HIGH_PRESSURE_GC)\n    {\n      JERRY_CONTEXT (ecma_prop_hashmap_alloc_state) = ECMA_PROP_HASHMAP_ALLOC_MAX;\n    }\n    else if (JERRY_CONTEXT (ecma_prop_hashmap_alloc_state) < ECMA_PROP_HASHMAP_ALLOC_MAX)\n    {\n      ++JERRY_CONTEXT (ecma_prop_hashmap_alloc_state);\n      JERRY_CONTEXT (status_flags) |= ECMA_STATUS_HIGH_PRESSURE_GC;\n    }\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n    ecma_gc_run ();\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n    /* Free hashmaps of remaining objects. */\n    jmem_cpointer_t obj_iter_cp = JERRY_CONTEXT (ecma_gc_objects_cp);\n\n    while (obj_iter_cp != JMEM_CP_NULL)\n    {\n      ecma_object_t *obj_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_iter_cp);\n\n      if (!ecma_is_lexical_environment (obj_iter_p)\n          || ecma_get_lex_env_type (obj_iter_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n      {\n        if (!ecma_is_lexical_environment (obj_iter_p)\n            && ecma_op_object_is_fast_array (obj_iter_p))\n        {\n          obj_iter_cp = obj_iter_p->gc_next_cp;\n          continue;\n        }\n\n        jmem_cpointer_t prop_iter_cp = obj_iter_p->u1.property_list_cp;\n\n        if (prop_iter_cp != JMEM_CP_NULL)\n        {\n          ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n\n          if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n          {\n            ecma_property_hashmap_free (obj_iter_p);\n          }\n        }\n\n      }\n\n      obj_iter_cp = obj_iter_p->gc_next_cp;\n    }\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n    jmem_pools_collect_empty ();\n    return;\n  }\n  else if (JERRY_UNLIKELY (pressure == JMEM_PRESSURE_FULL))\n  {\n    jerry_fatal (ERR_OUT_OF_MEMORY);\n  }\n  else\n  {\n    JERRY_ASSERT (pressure == JMEM_PRESSURE_NONE);\n    JERRY_UNREACHABLE ();\n  }\n}",
        "begin_line": 1479,
        "end_line": 1578,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_gc_free_object#1011",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_gc_free_object (ecma_object_t *object_p) /**< object to free */",
        "snippet": "static void\necma_gc_free_object (ecma_object_t *object_p) /**< object to free */\n{\n  JERRY_ASSERT (object_p != NULL\n                && !ecma_gc_is_object_visited (object_p)\n                && ((object_p->type_flags_refs & ECMA_OBJECT_REF_MASK) == ECMA_OBJECT_NON_VISITED));\n\n  JERRY_ASSERT (JERRY_CONTEXT (ecma_gc_objects_number) > 0);\n  JERRY_CONTEXT (ecma_gc_objects_number)--;\n\n  if (ecma_is_lexical_environment (object_p))\n  {\n    if (ecma_get_lex_env_type (object_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n    {\n      ecma_gc_free_properties (object_p);\n    }\n\n    ecma_dealloc_object (object_p);\n    return;\n  }\n\n  ecma_object_type_t object_type = ecma_get_object_type (object_p);\n\n  size_t ext_object_size = sizeof (ecma_extended_object_t);\n\n  if (JERRY_UNLIKELY (ecma_get_object_is_builtin (object_p)))\n  {\n    uint8_t length_and_bitset_size;\n\n    if (object_type == ECMA_OBJECT_TYPE_CLASS\n        || object_type == ECMA_OBJECT_TYPE_ARRAY)\n    {\n      ext_object_size = sizeof (ecma_extended_built_in_object_t);\n      length_and_bitset_size = ((ecma_extended_built_in_object_t *) object_p)->built_in.length_and_bitset_size;\n      ext_object_size += (2 * sizeof (uint32_t)) * (length_and_bitset_size >> ECMA_BUILT_IN_BITSET_SHIFT);\n    }\n    else\n    {\n      length_and_bitset_size = ((ecma_extended_object_t *) object_p)->u.built_in.length_and_bitset_size;\n      ext_object_size += (2 * sizeof (uint32_t)) * (length_and_bitset_size >> ECMA_BUILT_IN_BITSET_SHIFT);\n\n      ecma_gc_free_properties (object_p);\n      ecma_dealloc_extended_object (object_p, ext_object_size);\n      return;\n    }\n  }\n\n  switch (object_type)\n  {\n    case ECMA_OBJECT_TYPE_GENERAL:\n    {\n      ecma_gc_free_properties (object_p);\n      ecma_dealloc_object (object_p);\n      return;\n    }\n    case ECMA_OBJECT_TYPE_ARRAY:\n    {\n      if (ecma_op_array_is_fast_array ((ecma_extended_object_t *) object_p))\n      {\n        ecma_free_fast_access_array (object_p);\n        return;\n      }\n      break;\n    }\n    case ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION:\n    {\n#if ENABLED (JERRY_ES2015)\n      ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;\n\n      if (ext_func_p->u.external_handler_cb == ecma_proxy_revoke_cb)\n      {\n        ext_object_size = sizeof (ecma_revocable_proxy_object_t);\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      break;\n    }\n    case ECMA_OBJECT_TYPE_CLASS:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      switch (ext_object_p->u.class_prop.class_id)\n      {\n#if ENABLED (JERRY_ES2015)\n        case LIT_MAGIC_STRING_SYMBOL_UL:\n#endif /* ENABLED (JERRY_ES2015) */\n        case LIT_MAGIC_STRING_STRING_UL:\n        case LIT_MAGIC_STRING_NUMBER_UL:\n        {\n          ecma_free_value (ext_object_p->u.class_prop.u.value);\n          break;\n        }\n\n        case LIT_MAGIC_STRING_DATE_UL:\n        {\n          ecma_number_t *num_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_number_t,\n                                                                  ext_object_p->u.class_prop.u.value);\n          ecma_dealloc_number (num_p);\n          break;\n        }\n        case LIT_MAGIC_STRING_REGEXP_UL:\n        {\n          ecma_compiled_code_t *bytecode_p = ECMA_GET_INTERNAL_VALUE_ANY_POINTER (ecma_compiled_code_t,\n                                                                                  ext_object_p->u.class_prop.u.value);\n\n          ecma_bytecode_deref (bytecode_p);\n\n          break;\n        }\n#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n        case LIT_MAGIC_STRING_ARRAY_BUFFER_UL:\n        {\n          ecma_length_t arraybuffer_length = ext_object_p->u.class_prop.u.length;\n\n          if (ECMA_ARRAYBUFFER_HAS_EXTERNAL_MEMORY (ext_object_p))\n          {\n            ext_object_size = sizeof (ecma_arraybuffer_external_info);\n\n            /* Call external free callback if any. */\n            ecma_arraybuffer_external_info *array_p = (ecma_arraybuffer_external_info *) ext_object_p;\n            JERRY_ASSERT (array_p != NULL);\n\n            if (array_p->free_cb != NULL)\n            {\n              (array_p->free_cb) (array_p->buffer_p);\n            }\n          }\n          else\n          {\n            ext_object_size += arraybuffer_length;\n          }\n\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n#if ENABLED (JERRY_ES2015_BUILTIN_PROMISE)\n        case LIT_MAGIC_STRING_PROMISE_UL:\n        {\n          ecma_free_value_if_not_object (ext_object_p->u.class_prop.u.value);\n\n          /* Reactions only contains objects. */\n          ecma_collection_destroy (((ecma_promise_object_t *) object_p)->reactions);\n\n          ext_object_size = sizeof (ecma_promise_object_t);\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */\n#if ENABLED (JERRY_ES2015_BUILTIN_CONTAINER)\n#if ENABLED (JERRY_ES2015_BUILTIN_MAP)\n        case LIT_MAGIC_STRING_MAP_UL:\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_MAP) */\n#if ENABLED (JERRY_ES2015_BUILTIN_SET)\n        case LIT_MAGIC_STRING_SET_UL:\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_SET) */\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP)\n        case LIT_MAGIC_STRING_WEAKMAP_UL:\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) */\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)\n        case LIT_MAGIC_STRING_WEAKSET_UL:\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */\n        {\n          ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) object_p;\n          ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                            map_object_p->u.class_prop.u.value);\n          ecma_op_container_free_entries (object_p);\n          ecma_collection_destroy (container_p);\n\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_CONTAINER) */\n#if ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW)\n        case LIT_MAGIC_STRING_DATAVIEW_UL:\n        {\n          ext_object_size = sizeof (ecma_dataview_object_t);\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW) */\n#if ENABLED (JERRY_ES2015)\n        case LIT_MAGIC_STRING_GENERATOR_UL:\n        {\n          ext_object_size = ecma_gc_free_executable_object (object_p);\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n        default:\n        {\n          /* The undefined id represents an uninitialized class. */\n          JERRY_ASSERT (ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_UNDEFINED\n                        || ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_ARGUMENTS_UL\n                        || ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_BOOLEAN_UL\n                        || ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_ERROR_UL\n                        || ext_object_p->u.class_prop.class_id == LIT_INTERNAL_MAGIC_STRING_INTERNAL_OBJECT);\n          break;\n        }\n      }\n\n      break;\n    }\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n    case ECMA_OBJECT_TYPE_PROXY:\n    {\n      ext_object_size = sizeof (ecma_proxy_object_t);\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n    case ECMA_OBJECT_TYPE_FUNCTION:\n    {\n      /* Function with byte-code (not a built-in function). */\n      ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;\n\n#if ENABLED (JERRY_SNAPSHOT_EXEC)\n      if (ext_func_p->u.function.bytecode_cp != ECMA_NULL_POINTER)\n      {\n#endif /* ENABLED (JERRY_SNAPSHOT_EXEC) */\n        ecma_compiled_code_t *byte_code_p = (ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,\n                                                                              ext_func_p->u.function.bytecode_cp));\n\n#if ENABLED (JERRY_ES2015)\n        if (byte_code_p->status_flags & CBC_CODE_FLAGS_ARROW_FUNCTION)\n        {\n          ecma_free_value_if_not_object (((ecma_arrow_function_t *) object_p)->this_binding);\n          ecma_free_value_if_not_object (((ecma_arrow_function_t *) object_p)->new_target);\n          ext_object_size = sizeof (ecma_arrow_function_t);\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        ecma_bytecode_deref (byte_code_p);\n#if ENABLED (JERRY_SNAPSHOT_EXEC)\n      }\n      else\n      {\n        ext_object_size = sizeof (ecma_static_function_t);\n      }\n#endif /* ENABLED (JERRY_SNAPSHOT_EXEC) */\n      break;\n    }\n    case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      switch (ext_object_p->u.pseudo_array.type)\n      {\n        case ECMA_PSEUDO_ARRAY_ARGUMENTS:\n        {\n          JERRY_ASSERT (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS);\n\n          ecma_length_t formal_params_number = ext_object_p->u.pseudo_array.u1.length;\n          ecma_value_t *arg_Literal_p = (ecma_value_t *) (ext_object_p + 1);\n\n          for (ecma_length_t i = 0; i < formal_params_number; i++)\n          {\n            if (arg_Literal_p[i] != ECMA_VALUE_EMPTY)\n            {\n              ecma_string_t *name_p = ecma_get_string_from_value (arg_Literal_p[i]);\n              ecma_deref_ecma_string (name_p);\n            }\n          }\n\n          size_t formal_params_size = formal_params_number * sizeof (ecma_value_t);\n          ext_object_size += formal_params_size;\n          break;\n        }\n#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n        case ECMA_PSEUDO_ARRAY_TYPEDARRAY_WITH_INFO:\n        {\n          ext_object_size = sizeof (ecma_extended_typedarray_object_t);\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n#if ENABLED (JERRY_ES2015)\n        case ECMA_PSEUDO_STRING_ITERATOR:\n        {\n          ecma_value_t iterated_value = ext_object_p->u.pseudo_array.u2.iterated_value;\n\n          if (!ecma_is_value_empty (iterated_value))\n          {\n            ecma_deref_ecma_string (ecma_get_string_from_value (iterated_value));\n          }\n\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n        default:\n        {\n          JERRY_ASSERT (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_TYPEDARRAY\n                        || ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ITERATOR\n                        || ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_SET_ITERATOR\n                        || ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_MAP_ITERATOR);\n          break;\n        }\n      }\n\n      break;\n    }\n    case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n    {\n      ext_object_size = sizeof (ecma_bound_function_t);\n      ecma_bound_function_t *bound_func_p = (ecma_bound_function_t *) object_p;\n\n      ecma_value_t args_len_or_this = bound_func_p->header.u.bound_function.args_len_or_this;\n\n      if (!ecma_is_value_integer_number (args_len_or_this))\n      {\n        ecma_free_value_if_not_object (args_len_or_this);\n        break;\n      }\n\n      ecma_integer_value_t args_length = ecma_get_integer_from_value (args_len_or_this);\n      ecma_value_t *args_p = (ecma_value_t *) (bound_func_p + 1);\n\n      for (ecma_integer_value_t i = 0; i < args_length; i++)\n      {\n        ecma_free_value_if_not_object (args_p[i]);\n      }\n\n      size_t args_size = ((size_t) args_length) * sizeof (ecma_value_t);\n      ext_object_size += args_size;\n      break;\n    }\n    default:\n    {\n      JERRY_UNREACHABLE ();\n    }\n  }\n\n  ecma_gc_free_properties (object_p);\n  ecma_dealloc_extended_object (object_p, ext_object_size);\n}",
        "begin_line": 1011,
        "end_line": 1337,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_gc_free_properties#933",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_gc_free_properties (ecma_object_t *object_p) /**< object */",
        "snippet": "static void\necma_gc_free_properties (ecma_object_t *object_p) /**< object */\n{\n  jmem_cpointer_t prop_iter_cp = object_p->u1.property_list_cp;\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n  if (prop_iter_cp != JMEM_CP_NULL)\n  {\n    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,\n                                                                     prop_iter_cp);\n    if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n    {\n      ecma_property_hashmap_free (object_p);\n      prop_iter_cp = object_p->u1.property_list_cp;\n    }\n  }\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n  while (prop_iter_cp != JMEM_CP_NULL)\n  {\n    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n    /* Both cannot be deleted. */\n    JERRY_ASSERT (prop_iter_p->types[0] != ECMA_PROPERTY_TYPE_DELETED\n                  || prop_iter_p->types[1] != ECMA_PROPERTY_TYPE_DELETED);\n\n    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)\n    {\n      ecma_property_t *property_p = (ecma_property_t *) (prop_iter_p->types + i);\n      jmem_cpointer_t name_cp = prop_pair_p->names_cp[i];\n\n      if (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_MAGIC)\n      {\n        /* Call the native's free callback. */\n        if (JERRY_UNLIKELY (name_cp == LIT_INTERNAL_MAGIC_STRING_NATIVE_POINTER))\n        {\n          ecma_gc_free_native_pointer (property_p);\n        }\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) || ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)\n        else if (JERRY_UNLIKELY (name_cp == LIT_INTERNAL_MAGIC_STRING_WEAK_REFS))\n        {\n          ecma_collection_t *refs_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                       ECMA_PROPERTY_VALUE_PTR (property_p)->value);\n          for (uint32_t j = 0; j < refs_p->item_count; j++)\n          {\n            const ecma_value_t value = refs_p->buffer_p[j];\n            if (!ecma_is_value_empty (value))\n            {\n              ecma_object_t *container_p = ecma_get_object_from_value (value);\n\n              ecma_op_container_remove_weak_entry (container_p,\n                                                   ecma_make_object_value (object_p));\n            }\n          }\n\n          ecma_collection_destroy (refs_p);\n        }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) || ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */\n      }\n\n      if (prop_iter_p->types[i] != ECMA_PROPERTY_TYPE_DELETED)\n      {\n        ecma_free_property (object_p, name_cp, property_p);\n      }\n    }\n\n    prop_iter_cp = prop_iter_p->next_property_cp;\n\n    ecma_dealloc_property_pair (prop_pair_p);\n  }\n}",
        "begin_line": 933,
        "end_line": 1006,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_gc_mark#515",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_gc_mark (ecma_object_t *object_p) /**< object to mark from */",
        "snippet": "static void\necma_gc_mark (ecma_object_t *object_p) /**< object to mark from */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (ecma_gc_is_object_visited (object_p));\n\n  if (ecma_is_lexical_environment (object_p))\n  {\n    jmem_cpointer_t outer_lex_env_cp = object_p->u2.outer_reference_cp;\n\n    if (outer_lex_env_cp != JMEM_CP_NULL)\n    {\n      ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER (ecma_object_t, outer_lex_env_cp));\n    }\n\n    if (ecma_get_lex_env_type (object_p) != ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n    {\n      ecma_object_t *binding_object_p = ecma_get_lex_env_binding_object (object_p);\n      ecma_gc_set_object_visited (binding_object_p);\n\n      return;\n    }\n  }\n  else\n  {\n    jmem_cpointer_t proto_cp = object_p->u2.prototype_cp;\n\n    if (proto_cp != JMEM_CP_NULL)\n    {\n      ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp));\n    }\n\n    switch (ecma_get_object_type (object_p))\n    {\n      case ECMA_OBJECT_TYPE_CLASS:\n      {\n        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n        switch (ext_object_p->u.class_prop.class_id)\n        {\n#if ENABLED (JERRY_ES2015_BUILTIN_PROMISE)\n          case LIT_MAGIC_STRING_PROMISE_UL:\n          {\n            ecma_gc_mark_promise_object (ext_object_p);\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */\n#if ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW)\n          case LIT_MAGIC_STRING_DATAVIEW_UL:\n          {\n            ecma_dataview_object_t *dataview_p = (ecma_dataview_object_t *) object_p;\n            ecma_gc_set_object_visited (dataview_p->buffer_p);\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW) */\n#if ENABLED (JERRY_ES2015_BUILTIN_CONTAINER)\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)\n          case LIT_MAGIC_STRING_WEAKSET_UL:\n          {\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */\n#if ENABLED (JERRY_ES2015_BUILTIN_SET)\n          case LIT_MAGIC_STRING_SET_UL:\n          {\n            ecma_gc_mark_set_object (object_p);\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_SET) */\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP)\n          case LIT_MAGIC_STRING_WEAKMAP_UL:\n          {\n            ecma_gc_mark_weakmap_object (object_p);\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) */\n#if ENABLED (JERRY_ES2015_BUILTIN_MAP)\n          case LIT_MAGIC_STRING_MAP_UL:\n          {\n            ecma_gc_mark_map_object (object_p);\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_MAP) */\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_CONTAINER) */\n#if ENABLED (JERRY_ES2015)\n          case LIT_MAGIC_STRING_GENERATOR_UL:\n          {\n            ecma_gc_mark_executable_object (object_p);\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n          default:\n          {\n            break;\n          }\n        }\n\n        break;\n      }\n      case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:\n      {\n        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n        switch (ext_object_p->u.pseudo_array.type)\n        {\n#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n          case ECMA_PSEUDO_ARRAY_TYPEDARRAY:\n          case ECMA_PSEUDO_ARRAY_TYPEDARRAY_WITH_INFO:\n          {\n            ecma_gc_set_object_visited (ecma_typedarray_get_arraybuffer (object_p));\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n#if ENABLED (JERRY_ES2015)\n          case ECMA_PSEUDO_ARRAY_ITERATOR:\n          case ECMA_PSEUDO_SET_ITERATOR:\n          case ECMA_PSEUDO_MAP_ITERATOR:\n          {\n            ecma_value_t iterated_value = ext_object_p->u.pseudo_array.u2.iterated_value;\n            if (!ecma_is_value_empty (iterated_value))\n            {\n              ecma_gc_set_object_visited (ecma_get_object_from_value (iterated_value));\n            }\n            break;\n          }\n          case ECMA_PSEUDO_STRING_ITERATOR:\n          {\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n          default:\n          {\n            JERRY_ASSERT (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS);\n\n            ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t,\n                                                                        ext_object_p->u.pseudo_array.u2.lex_env_cp);\n\n            ecma_gc_set_object_visited (lex_env_p);\n            break;\n          }\n        }\n\n        break;\n      }\n      case ECMA_OBJECT_TYPE_ARRAY:\n      {\n        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n        if (ecma_op_array_is_fast_array (ext_object_p))\n        {\n          if (object_p->u1.property_list_cp != JMEM_CP_NULL)\n          {\n            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);\n\n            for (uint32_t i = 0; i < ext_object_p->u.array.length; i++)\n            {\n              if (ecma_is_value_object (values_p[i]))\n              {\n                ecma_gc_set_object_visited (ecma_get_object_from_value (values_p[i]));\n              }\n            }\n          }\n\n          return;\n        }\n        break;\n      }\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n      case ECMA_OBJECT_TYPE_PROXY:\n      {\n        ecma_gc_mark_proxy_object (object_p);\n        break;\n      }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n      {\n        ecma_gc_mark_bound_function_object (object_p);\n        break;\n      }\n      case ECMA_OBJECT_TYPE_FUNCTION:\n      {\n        if (!ecma_get_object_is_builtin (object_p))\n        {\n          ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;\n          ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t,\n                                                                                  ext_func_p->u.function.scope_cp));\n\n#if ENABLED (JERRY_ES2015)\n          const ecma_compiled_code_t *byte_code_p = ecma_op_function_get_compiled_code (ext_func_p);\n\n          if (byte_code_p->status_flags & CBC_CODE_FLAG_HAS_TAGGED_LITERALS)\n          {\n            ecma_gc_mark_tagged_template_literals (byte_code_p);\n          }\n\n          if (byte_code_p->status_flags & CBC_CODE_FLAGS_ARROW_FUNCTION)\n          {\n            ecma_arrow_function_t *arrow_func_p = (ecma_arrow_function_t *) object_p;\n\n            if (ecma_is_value_object (arrow_func_p->this_binding))\n            {\n              ecma_gc_set_object_visited (ecma_get_object_from_value (arrow_func_p->this_binding));\n            }\n\n            if (ecma_is_value_object (arrow_func_p->new_target))\n            {\n              ecma_gc_set_object_visited (ecma_get_object_from_value (arrow_func_p->new_target));\n            }\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n        }\n        break;\n      }\n#if ENABLED (JERRY_ES2015)\n      case ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION:\n      {\n        ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;\n\n        if (ext_func_p->u.external_handler_cb == ecma_proxy_revoke_cb)\n        {\n          ecma_revocable_proxy_object_t *rev_proxy_p = (ecma_revocable_proxy_object_t *) object_p;\n\n          if (!ecma_is_value_null (rev_proxy_p->proxy))\n          {\n            ecma_gc_set_object_visited (ecma_get_object_from_value (rev_proxy_p->proxy));\n          }\n        }\n        break;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      default:\n      {\n        break;\n      }\n    }\n  }\n\n  jmem_cpointer_t prop_iter_cp = object_p->u1.property_list_cp;\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n  if (prop_iter_cp != JMEM_CP_NULL)\n  {\n    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n    if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n    {\n      prop_iter_cp = prop_iter_p->next_property_cp;\n    }\n  }\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n  while (prop_iter_cp != JMEM_CP_NULL)\n  {\n    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n    ecma_gc_mark_properties ((ecma_property_pair_t *) prop_iter_p);\n\n    prop_iter_cp = prop_iter_p->next_property_cp;\n  }\n}",
        "begin_line": 515,
        "end_line": 774,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_gc_run#1342",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_gc_run (void)",
        "snippet": "void\necma_gc_run (void)\n{\n#if (JERRY_GC_MARK_LIMIT != 0)\n  JERRY_ASSERT (JERRY_CONTEXT (ecma_gc_mark_recursion_limit) == JERRY_GC_MARK_LIMIT);\n#endif /* (JERRY_GC_MARK_LIMIT != 0) */\n\n  JERRY_CONTEXT (ecma_gc_new_objects) = 0;\n\n  ecma_object_t black_list_head;\n  black_list_head.gc_next_cp = JMEM_CP_NULL;\n  ecma_object_t *black_end_p = &black_list_head;\n\n  ecma_object_t white_gray_list_head;\n  white_gray_list_head.gc_next_cp = JERRY_CONTEXT (ecma_gc_objects_cp);\n\n  ecma_object_t *obj_prev_p = &white_gray_list_head;\n  jmem_cpointer_t obj_iter_cp = obj_prev_p->gc_next_cp;\n  ecma_object_t *obj_iter_p;\n\n  /* Move root objects (i.e. they have global or stack references) to the black list. */\n  while (obj_iter_cp != JMEM_CP_NULL)\n  {\n    obj_iter_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_object_t, obj_iter_cp);\n    const jmem_cpointer_t obj_next_cp = obj_iter_p->gc_next_cp;\n\n    JERRY_ASSERT (obj_prev_p == NULL\n                  || ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_prev_p->gc_next_cp) == obj_iter_p);\n\n    if (obj_iter_p->type_flags_refs >= ECMA_OBJECT_REF_ONE)\n    {\n      /* Moving the object to list of marked objects. */\n      obj_prev_p->gc_next_cp = obj_next_cp;\n\n      black_end_p->gc_next_cp = obj_iter_cp;\n      black_end_p = obj_iter_p;\n    }\n    else\n    {\n      obj_iter_p->type_flags_refs |= ECMA_OBJECT_NON_VISITED;\n      obj_prev_p = obj_iter_p;\n    }\n\n    obj_iter_cp = obj_next_cp;\n  }\n\n  black_end_p->gc_next_cp = JMEM_CP_NULL;\n\n  /* Mark root objects. */\n  obj_iter_cp = black_list_head.gc_next_cp;\n  while (obj_iter_cp != JMEM_CP_NULL)\n  {\n    obj_iter_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_object_t, obj_iter_cp);\n    ecma_gc_mark (obj_iter_p);\n    obj_iter_cp = obj_iter_p->gc_next_cp;\n  }\n\n  /* Mark non-root objects. */\n  bool marked_anything_during_current_iteration;\n\n  do\n  {\n#if (JERRY_GC_MARK_LIMIT != 0)\n    JERRY_ASSERT (JERRY_CONTEXT (ecma_gc_mark_recursion_limit) == JERRY_GC_MARK_LIMIT);\n#endif /* (JERRY_GC_MARK_LIMIT != 0) */\n\n    marked_anything_during_current_iteration = false;\n\n    obj_prev_p = &white_gray_list_head;\n    obj_iter_cp = obj_prev_p->gc_next_cp;\n\n    while (obj_iter_cp != JMEM_CP_NULL)\n    {\n      obj_iter_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_object_t, obj_iter_cp);\n      const jmem_cpointer_t obj_next_cp = obj_iter_p->gc_next_cp;\n\n      JERRY_ASSERT (obj_prev_p == NULL\n                    || ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_prev_p->gc_next_cp) == obj_iter_p);\n\n      if (ecma_gc_is_object_visited (obj_iter_p))\n      {\n        /* Moving the object to list of marked objects */\n        obj_prev_p->gc_next_cp = obj_next_cp;\n\n        black_end_p->gc_next_cp = obj_iter_cp;\n        black_end_p = obj_iter_p;\n\n#if (JERRY_GC_MARK_LIMIT != 0)\n        if (obj_iter_p->type_flags_refs >= ECMA_OBJECT_REF_ONE)\n        {\n          /* Set the reference count of non-marked gray object to 0 */\n          obj_iter_p->type_flags_refs = (uint16_t) (obj_iter_p->type_flags_refs & (ECMA_OBJECT_REF_ONE - 1));\n          ecma_gc_mark (obj_iter_p);\n          marked_anything_during_current_iteration = true;\n        }\n#else /* (JERRY_GC_MARK_LIMIT == 0) */\n        marked_anything_during_current_iteration = true;\n#endif /* (JERRY_GC_MARK_LIMIT != 0) */\n      }\n      else\n      {\n        obj_prev_p = obj_iter_p;\n      }\n\n      obj_iter_cp = obj_next_cp;\n    }\n  }\n  while (marked_anything_during_current_iteration);\n\n  black_end_p->gc_next_cp = JMEM_CP_NULL;\n  JERRY_CONTEXT (ecma_gc_objects_cp) = black_list_head.gc_next_cp;\n\n  /* Sweep objects that are currently unmarked. */\n  obj_iter_cp = white_gray_list_head.gc_next_cp;\n\n  while (obj_iter_cp != JMEM_CP_NULL)\n  {\n    obj_iter_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_object_t, obj_iter_cp);\n    const jmem_cpointer_t obj_next_cp = obj_iter_p->gc_next_cp;\n\n    JERRY_ASSERT (!ecma_gc_is_object_visited (obj_iter_p));\n\n    ecma_gc_free_object (obj_iter_p);\n    obj_iter_cp = obj_next_cp;\n  }\n\n#if ENABLED (JERRY_BUILTIN_REGEXP)\n  /* Free RegExp bytecodes stored in cache */\n  re_cache_gc ();\n#endif /* ENABLED (JERRY_BUILTIN_REGEXP) */\n}",
        "begin_line": 1342,
        "end_line": 1472,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_gc_set_object_visited#82",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_gc_set_object_visited (ecma_object_t *object_p) /**< object */",
        "snippet": "static void\necma_gc_set_object_visited (ecma_object_t *object_p) /**< object */\n{\n  if (object_p->type_flags_refs >= ECMA_OBJECT_NON_VISITED)\n  {\n#if (JERRY_GC_MARK_LIMIT != 0)\n    if (JERRY_CONTEXT (ecma_gc_mark_recursion_limit) != 0)\n    {\n      JERRY_CONTEXT (ecma_gc_mark_recursion_limit)--;\n      /* Set the reference count of gray object to 0 */\n      object_p->type_flags_refs = (uint16_t) (object_p->type_flags_refs & (ECMA_OBJECT_REF_ONE - 1));\n      ecma_gc_mark (object_p);\n      JERRY_CONTEXT (ecma_gc_mark_recursion_limit)++;\n    }\n    else\n    {\n      /* Set the reference count of the non-marked gray object to 1 */\n      object_p->type_flags_refs = (uint16_t) (object_p->type_flags_refs & ((ECMA_OBJECT_REF_ONE << 1) - 1));\n      JERRY_ASSERT (object_p->type_flags_refs >= ECMA_OBJECT_REF_ONE);\n    }\n#else /* (JERRY_GC_MARK_LIMIT == 0) */\n    /* Set the reference count of gray object to 0 */\n    object_p->type_flags_refs = (uint16_t) (object_p->type_flags_refs & (ECMA_OBJECT_REF_ONE - 1));\n#endif /* (JERRY_GC_MARK_LIMIT != 0) */\n  }\n}",
        "begin_line": 82,
        "end_line": 107,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_init_gc_info#112",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_init_gc_info (ecma_object_t *object_p) /**< object */",
        "snippet": "inline void\necma_init_gc_info (ecma_object_t *object_p) /**< object */\n{\n  JERRY_CONTEXT (ecma_gc_objects_number)++;\n  JERRY_CONTEXT (ecma_gc_new_objects)++;\n\n  JERRY_ASSERT (JERRY_CONTEXT (ecma_gc_new_objects) <= JERRY_CONTEXT (ecma_gc_objects_number));\n\n  JERRY_ASSERT (object_p->type_flags_refs < ECMA_OBJECT_REF_ONE);\n  object_p->type_flags_refs = (uint16_t) (object_p->type_flags_refs | ECMA_OBJECT_REF_ONE);\n\n  object_p->gc_next_cp = JERRY_CONTEXT (ecma_gc_objects_cp);\n  ECMA_SET_NON_NULL_POINTER (JERRY_CONTEXT (ecma_gc_objects_cp), object_p);\n}",
        "begin_line": 112,
        "end_line": 125,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_ref_object#130",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_ref_object (ecma_object_t *object_p) /**< object */",
        "snippet": "void\necma_ref_object (ecma_object_t *object_p) /**< object */\n{\n  if (JERRY_LIKELY (object_p->type_flags_refs < ECMA_OBJECT_MAX_REF))\n  {\n    object_p->type_flags_refs = (uint16_t) (object_p->type_flags_refs + ECMA_OBJECT_REF_ONE);\n  }\n  else\n  {\n    jerry_fatal (ERR_REF_COUNT_LIMIT);\n  }\n}",
        "begin_line": 130,
        "end_line": 141,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-collection.ecma_new_collection#34",
        "src_path": "jerry-core/ecma/base/ecma-helpers-collection.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-collection",
        "signature": "jerry-core.ecma.base.ecma-helpers-collection.ecma_new_collection (void)",
        "snippet": "ecma_collection_t *\necma_new_collection (void)\n{\n  ecma_collection_t *collection_p;\n  collection_p = (ecma_collection_t *) jmem_heap_alloc_block (sizeof (ecma_collection_t));\n\n  collection_p->item_count = 0;\n  collection_p->capacity = ECMA_COLLECTION_INITIAL_CAPACITY;\n  const uint32_t size = ECMA_COLLECTION_ALLOCATED_SIZE (ECMA_COLLECTION_INITIAL_CAPACITY);\n  collection_p->buffer_p = (ecma_value_t *) jmem_heap_alloc_block (size);\n\n  return collection_p;\n}",
        "begin_line": 34,
        "end_line": 46,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-conversion.ecma_number_to_uint32#759",
        "src_path": "jerry-core/ecma/base/ecma-helpers-conversion.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-conversion",
        "signature": "jerry-core.ecma.base.ecma-helpers-conversion.ecma_number_to_uint32 (ecma_number_t num) /**< ecma-number */",
        "snippet": "uint32_t\necma_number_to_uint32 (ecma_number_t num) /**< ecma-number */\n{\n  if (JERRY_UNLIKELY (ecma_number_is_zero (num) || !ecma_number_is_finite (num)))\n  {\n    return 0;\n  }\n\n  const bool sign = ecma_number_is_negative (num);\n  const ecma_number_t abs_num = sign ? -num : num;\n\n  /* 2 ^ 32 */\n  const uint64_t uint64_2_pow_32 = (1ull << 32);\n\n  const ecma_number_t num_2_pow_32 = (float) uint64_2_pow_32;\n\n  ecma_number_t num_in_uint32_range;\n\n  if (abs_num >= num_2_pow_32)\n  {\n    num_in_uint32_range = ecma_number_calc_remainder (abs_num,\n                                                      num_2_pow_32);\n  }\n  else\n  {\n    num_in_uint32_range = abs_num;\n  }\n\n  /* Check that the floating point value can be represented with uint32_t. */\n  JERRY_ASSERT (num_in_uint32_range < uint64_2_pow_32);\n  uint32_t uint32_num = (uint32_t) num_in_uint32_range;\n\n  const uint32_t ret = sign ? -uint32_num : uint32_num;\n\n#ifndef JERRY_NDEBUG\n  if (sign\n      && uint32_num != 0)\n  {\n    JERRY_ASSERT (ret == uint64_2_pow_32 - uint32_num);\n  }\n  else\n  {\n    JERRY_ASSERT (ret == uint32_num);\n  }\n#endif /* !JERRY_NDEBUG */\n\n  return ret;\n}",
        "begin_line": 759,
        "end_line": 806,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-conversion.ecma_uint32_to_utf8_string#722",
        "src_path": "jerry-core/ecma/base/ecma-helpers-conversion.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-conversion",
        "signature": "jerry-core.ecma.base.ecma-helpers-conversion.ecma_uint32_to_utf8_string (uint32_t value, /**< value to convert */                             lit_utf8_byte_t *out_buffer_p, /**< buffer for string */                             lit_utf8_size_t buffer_size) /**< size of buffer */",
        "snippet": "lit_utf8_size_t\necma_uint32_to_utf8_string (uint32_t value, /**< value to convert */\n                            lit_utf8_byte_t *out_buffer_p, /**< buffer for string */\n                            lit_utf8_size_t buffer_size) /**< size of buffer */\n{\n  lit_utf8_byte_t *buf_p = out_buffer_p + buffer_size;\n\n  do\n  {\n    JERRY_ASSERT (buf_p >= out_buffer_p);\n\n    buf_p--;\n    *buf_p = (lit_utf8_byte_t) ((value % 10) + LIT_CHAR_0);\n    value /= 10;\n  }\n  while (value != 0);\n\n  JERRY_ASSERT (buf_p >= out_buffer_p);\n\n  lit_utf8_size_t bytes_copied = (lit_utf8_size_t) (out_buffer_p + buffer_size - buf_p);\n\n  if (JERRY_LIKELY (buf_p != out_buffer_p))\n  {\n    memmove (out_buffer_p, buf_p, bytes_copied);\n  }\n\n  return bytes_copied;\n}",
        "begin_line": 722,
        "end_line": 749,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-conversion.ecma_utf8_string_to_number#365",
        "src_path": "jerry-core/ecma/base/ecma-helpers-conversion.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-conversion",
        "signature": "jerry-core.ecma.base.ecma-helpers-conversion.ecma_utf8_string_to_number (const lit_utf8_byte_t *str_p, /**< utf-8 string */                             lit_utf8_size_t str_size) /**< string size */",
        "snippet": "ecma_number_t\necma_utf8_string_to_number (const lit_utf8_byte_t *str_p, /**< utf-8 string */\n                            lit_utf8_size_t str_size) /**< string size */\n{\n  /* TODO: Check license issues */\n\n  if (str_size == 0)\n  {\n    return ECMA_NUMBER_ZERO;\n  }\n\n  ecma_string_trim_helper (&str_p, &str_size);\n  const lit_utf8_byte_t *end_p = str_p + (str_size - 1);\n\n  if (str_size < 1)\n  {\n    return ECMA_NUMBER_ZERO;\n  }\n\n  if (end_p >= str_p + 2\n      && str_p[0] == LIT_CHAR_0)\n  {\n    switch (LEXER_TO_ASCII_LOWERCASE (str_p[1]))\n    {\n      case LIT_CHAR_LOWERCASE_X :\n      {\n        return ecma_utf8_string_to_number_by_radix (str_p + 2, end_p, 16);\n      }\n      case LIT_CHAR_LOWERCASE_O :\n      {\n        return ecma_utf8_string_to_number_by_radix (str_p + 2, end_p, 8);\n      }\n      case LIT_CHAR_LOWERCASE_B :\n      {\n        return ecma_utf8_string_to_number_by_radix (str_p + 2, end_p, 2);\n      }\n      default:\n      {\n        break;\n      }\n    }\n  }\n\n  bool sign = false; /* positive */\n\n  if (*str_p == LIT_CHAR_PLUS)\n  {\n    str_p++;\n  }\n  else if (*str_p == LIT_CHAR_MINUS)\n  {\n    sign = true; /* negative */\n\n    str_p++;\n  }\n\n  if (str_p > end_p)\n  {\n    return ecma_number_make_nan ();\n  }\n\n  /* Checking if significant part of parse string is equal to \"Infinity\" */\n  const lit_utf8_byte_t *infinity_zt_str_p = lit_get_magic_string_utf8 (LIT_MAGIC_STRING_INFINITY_UL);\n\n  JERRY_ASSERT (strlen ((const char *) infinity_zt_str_p) == 8);\n\n  if ((end_p - str_p) == (8 - 1) && memcmp (infinity_zt_str_p, str_p, 8) == 0)\n  {\n    return ecma_number_make_infinity (sign);\n  }\n\n  uint64_t fraction_uint64 = 0;\n  uint32_t digits = 0;\n  int32_t e = 0;\n  bool digit_seen = false;\n\n  /* Parsing digits before dot (or before end of digits part if there is no dot in number) */\n  while (str_p <= end_p)\n  {\n    int32_t digit_value;\n\n    if (*str_p >= LIT_CHAR_0\n        && *str_p <= LIT_CHAR_9)\n    {\n      digit_seen = true;\n      digit_value = (*str_p - LIT_CHAR_0);\n    }\n    else\n    {\n      break;\n    }\n\n    if (digits != 0 || digit_value != 0)\n    {\n      if (digits < ECMA_NUMBER_MAX_DIGITS)\n      {\n        fraction_uint64 = fraction_uint64 * 10 + (uint32_t) digit_value;\n        digits++;\n      }\n      else\n      {\n        e++;\n      }\n    }\n\n    str_p++;\n  }\n\n  if (str_p <= end_p\n      && *str_p == LIT_CHAR_DOT)\n  {\n    str_p++;\n\n    if (!digit_seen && str_p > end_p)\n    {\n      return ecma_number_make_nan ();\n    }\n\n    /* Parsing number's part that is placed after dot */\n    while (str_p <= end_p)\n    {\n      int32_t digit_value;\n\n      if (*str_p >= LIT_CHAR_0\n          && *str_p <= LIT_CHAR_9)\n      {\n        digit_seen = true;\n        digit_value = (*str_p - LIT_CHAR_0);\n      }\n      else\n      {\n        break;\n      }\n\n      if (digits < ECMA_NUMBER_MAX_DIGITS)\n      {\n        if (digits != 0 || digit_value != 0)\n        {\n          fraction_uint64 = fraction_uint64 * 10 + (uint32_t) digit_value;\n          digits++;\n        }\n\n        e--;\n      }\n\n      str_p++;\n    }\n  }\n\n  /* Parsing exponent literal */\n  int32_t e_in_lit = 0;\n  bool e_in_lit_sign = false;\n\n  if (str_p <= end_p\n      && (*str_p == LIT_CHAR_LOWERCASE_E\n          || *str_p == LIT_CHAR_UPPERCASE_E))\n  {\n    str_p++;\n\n    if (!digit_seen || str_p > end_p)\n    {\n      return ecma_number_make_nan ();\n    }\n\n    if (*str_p == LIT_CHAR_PLUS)\n    {\n      str_p++;\n    }\n    else if (*str_p == LIT_CHAR_MINUS)\n    {\n      e_in_lit_sign = true;\n      str_p++;\n    }\n\n    if (str_p > end_p)\n    {\n      return ecma_number_make_nan ();\n    }\n\n    while (str_p <= end_p)\n    {\n      int32_t digit_value;\n\n      if (*str_p >= LIT_CHAR_0\n          && *str_p <= LIT_CHAR_9)\n      {\n        digit_value = (*str_p - LIT_CHAR_0);\n      }\n      else\n      {\n        return ecma_number_make_nan ();\n      }\n\n      e_in_lit = e_in_lit * 10 + digit_value;\n      int32_t e_check = e + (int32_t) digits - 1  + (e_in_lit_sign ? -e_in_lit : e_in_lit);\n\n      if (e_check > NUMBER_MAX_DECIMAL_EXPONENT)\n      {\n        return ecma_number_make_infinity (sign);\n      }\n      else if (e_check < NUMBER_MIN_DECIMAL_EXPONENT)\n      {\n        return sign ? -ECMA_NUMBER_ZERO : ECMA_NUMBER_ZERO;\n      }\n\n      str_p++;\n    }\n  }\n\n  /* Adding value of exponent literal to exponent value */\n  if (e_in_lit_sign)\n  {\n    e -= e_in_lit;\n  }\n  else\n  {\n    e += e_in_lit;\n  }\n\n  bool e_sign;\n\n  if (e < 0)\n  {\n    e_sign = true;\n    e = -e;\n  }\n  else\n  {\n    e_sign = false;\n  }\n\n  if (str_p <= end_p)\n  {\n    return ecma_number_make_nan ();\n  }\n\n  JERRY_ASSERT (str_p == end_p + 1);\n\n  if (fraction_uint64 == 0)\n  {\n    return sign ? -ECMA_NUMBER_ZERO : ECMA_NUMBER_ZERO;\n  }\n\n#if ENABLED (JERRY_NUMBER_TYPE_FLOAT64)\n  /*\n   * 128-bit mantissa storage\n   *\n   * Normalized: |4 bits zero|124-bit mantissa with highest bit set to 1|\n   */\n  ecma_uint128_t fraction_uint128 = { 0, fraction_uint64 };\n\n  /* Normalizing mantissa */\n  int shift = 4 - ECMA_UINT128_CLZ_MAX63 (fraction_uint128);\n  if (shift < 0)\n  {\n    ECMA_UINT128_LEFT_SHIFT_MAX63 (fraction_uint128, -shift);\n  }\n  else\n  {\n    ECMA_UINT128_RIGHT_SHIFT_MAX63 (fraction_uint128, shift);\n  }\n  int32_t binary_exponent = 1 + shift;\n\n  if (!e_sign)\n  {\n    /* positive or zero decimal exponent */\n    JERRY_ASSERT (e >= 0);\n\n    while (e > 0)\n    {\n      JERRY_ASSERT (ECMA_UINT128_CLZ_MAX63 (fraction_uint128) == 4);\n\n      ECMA_UINT128_MUL10 (fraction_uint128);\n\n      e--;\n\n      /* Normalizing mantissa */\n      shift = 4 - ECMA_UINT128_CLZ_MAX4 (fraction_uint128);\n      JERRY_ASSERT (shift >= 0);\n      ECMA_UINT128_RIGHT_SHIFT_MAX63 (fraction_uint128, shift);\n      binary_exponent += shift;\n    }\n  }\n  else\n  {\n    /* negative decimal exponent */\n    JERRY_ASSERT (e != 0);\n\n    while (e > 0)\n    {\n      /* Denormalizing mantissa, moving highest 1 to bit 127 */\n      shift = ECMA_UINT128_CLZ_MAX4 (fraction_uint128);\n      JERRY_ASSERT (shift <= 4);\n      ECMA_UINT128_LEFT_SHIFT_MAX63 (fraction_uint128, shift);\n      binary_exponent -= shift;\n\n      JERRY_ASSERT (!ECMA_UINT128_IS_ZERO (fraction_uint128));\n\n      ECMA_UINT128_DIV10 (fraction_uint128);\n\n      e--;\n    }\n\n    /* Normalizing mantissa */\n    shift = 4 - ECMA_UINT128_CLZ_MAX4 (fraction_uint128);\n    JERRY_ASSERT (shift >= 0);\n    ECMA_UINT128_RIGHT_SHIFT_MAX63 (fraction_uint128, shift);\n    binary_exponent += shift;\n\n    JERRY_ASSERT (ECMA_UINT128_CLZ_MAX63 (fraction_uint128) == 4);\n  }\n\n  JERRY_ASSERT (!ECMA_UINT128_IS_ZERO (fraction_uint128));\n  JERRY_ASSERT (ECMA_UINT128_CLZ_MAX63 (fraction_uint128) == 4);\n\n  /*\n   * Preparing mantissa for conversion to 52-bit representation, converting it to:\n   *\n   * |11 zero bits|1|116 mantissa bits|\n   */\n  ECMA_UINT128_RIGHT_SHIFT_MAX63 (fraction_uint128, 7u);\n  binary_exponent += 7;\n\n  JERRY_ASSERT (ECMA_UINT128_CLZ_MAX63 (fraction_uint128) == 11);\n\n  fraction_uint64 = ecma_round_high_to_uint64 (&fraction_uint128);\n\n  return ecma_number_make_from_sign_mantissa_and_exponent (sign, fraction_uint64, binary_exponent);\n#elif !ENABLED (JERRY_NUMBER_TYPE_FLOAT64)\n  /* Less precise conversion */\n  ecma_number_t num = (ecma_number_t) (uint32_t) fraction_uint64;\n\n  ecma_number_t m = e_sign ? (ecma_number_t) 0.1 : (ecma_number_t) 10.0;\n\n  while (e)\n  {\n    if (e % 2)\n    {\n      num *= m;\n    }\n\n    m *= m;\n    e /= 2;\n  }\n\n  return num;\n#endif /* ENABLED (JERRY_NUMBER_TYPE_FLOAT64) */\n}",
        "begin_line": 365,
        "end_line": 712,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_get_biased_exponent_field#190",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_get_biased_exponent_field (ecma_number_t num) /**< ecma-number */",
        "snippet": "static uint32_t\necma_number_get_biased_exponent_field (ecma_number_t num) /**< ecma-number */\n{\n  uint32_t biased_exp;\n\n  ecma_number_unpack (num, NULL, &biased_exp, NULL);\n\n  return biased_exp;\n}",
        "begin_line": 190,
        "end_line": 198,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_get_fraction_field#175",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_get_fraction_field (ecma_number_t num) /**< ecma-number */",
        "snippet": "static uint64_t\necma_number_get_fraction_field (ecma_number_t num) /**< ecma-number */\n{\n  uint64_t fraction;\n\n  ecma_number_unpack (num, NULL, NULL, &fraction);\n\n  return fraction;\n}",
        "begin_line": 175,
        "end_line": 183,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_get_sign_field#205",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_get_sign_field (ecma_number_t num) /**< ecma-number */",
        "snippet": "static uint32_t\necma_number_get_sign_field (ecma_number_t num) /**< ecma-number */\n{\n  bool sign;\n\n  ecma_number_unpack (num, &sign, NULL, NULL);\n\n  return sign;\n}",
        "begin_line": 205,
        "end_line": 213,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_is_zero#300",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_is_zero (ecma_number_t num) /**< ecma-number */",
        "snippet": "bool\necma_number_is_zero (ecma_number_t num) /**< ecma-number */\n{\n  bool is_zero = (num == ECMA_NUMBER_ZERO);\n\n#ifndef JERRY_NDEBUG\n  /* IEEE-754 2008, 3.4, e */\n  bool is_zero_ieee754 = (ecma_number_get_fraction_field (num) == 0\n                          && ecma_number_get_biased_exponent_field (num) == 0);\n\n  JERRY_ASSERT (is_zero == is_zero_ieee754);\n#endif /* !JERRY_NDEBUG */\n\n  return is_zero;\n}",
        "begin_line": 300,
        "end_line": 314,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_make_from_sign_mantissa_and_exponent#435",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_make_from_sign_mantissa_and_exponent (bool sign, /**< true - for negative sign, false - for positive sign */                                                   uint64_t mantissa, /**< mantissa */                                                   int32_t exponent) /**< binary exponent */",
        "snippet": "ecma_number_t\necma_number_make_from_sign_mantissa_and_exponent (bool sign, /**< true - for negative sign,\n                                                                  false - for positive sign */\n                                                  uint64_t mantissa, /**< mantissa */\n                                                  int32_t exponent) /**< binary exponent */\n{\n  /* Rounding mantissa to fit into fraction field width */\n  if (mantissa & ~((1ull << (ECMA_NUMBER_FRACTION_WIDTH + 1)) - 1))\n  {\n    /* Rounded mantissa looks like the following: |00...0|1|fraction_width mantissa bits| */\n    while ((mantissa & ~((1ull << (ECMA_NUMBER_FRACTION_WIDTH + 1)) - 1)) != 0)\n    {\n      uint64_t rightmost_bit = (mantissa & 1);\n\n      exponent++;\n      mantissa >>= 1;\n\n      if ((mantissa & ~((1ull << (ECMA_NUMBER_FRACTION_WIDTH + 1)) - 1)) == 0)\n      {\n        /* Rounding to nearest value */\n        mantissa += rightmost_bit;\n\n        /* In the first case loop is finished,\n           and in the second - just one shift follows and then loop finishes */\n        JERRY_ASSERT (((mantissa & ~((1ull << (ECMA_NUMBER_FRACTION_WIDTH + 1)) - 1)) == 0)\n                      || (mantissa == (1ull << (ECMA_NUMBER_FRACTION_WIDTH + 1))));\n      }\n    }\n  }\n\n  /* Normalizing mantissa */\n  while (mantissa != 0\n         && ((mantissa & (1ull << ECMA_NUMBER_FRACTION_WIDTH)) == 0))\n  {\n    exponent--;\n    mantissa <<= 1;\n  }\n\n  /* Moving floating point */\n  exponent += ECMA_NUMBER_FRACTION_WIDTH - 1;\n\n  int32_t biased_exp_signed = exponent + ecma_number_exponent_bias;\n\n  if (biased_exp_signed < 1)\n  {\n    /* Denormalizing mantissa if biased_exponent is less than zero */\n    while (biased_exp_signed < 0)\n    {\n      biased_exp_signed++;\n      mantissa >>= 1;\n    }\n\n    /* Rounding to nearest value */\n    mantissa += 1;\n    mantissa >>= 1;\n\n    /* Encoding denormalized exponent */\n    biased_exp_signed = 0;\n  }\n  else\n  {\n    /* Clearing highest mantissa bit that should have been non-zero if mantissa is non-zero */\n    mantissa &= ~(1ull << ECMA_NUMBER_FRACTION_WIDTH);\n  }\n\n  uint32_t biased_exp = (uint32_t) biased_exp_signed;\n\n  if (biased_exp >= ((1u << ECMA_NUMBER_BIASED_EXP_WIDTH) - 1))\n  {\n    return ecma_number_make_infinity (sign);\n  }\n\n  JERRY_ASSERT (biased_exp < (1u << ECMA_NUMBER_BIASED_EXP_WIDTH) - 1);\n  JERRY_ASSERT ((mantissa & ~((1ull << ECMA_NUMBER_FRACTION_WIDTH) - 1)) == 0);\n\n  return ecma_number_pack (sign,\n                           biased_exp,\n                           mantissa);\n}",
        "begin_line": 435,
        "end_line": 513,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_deref_ecma_string#789",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_deref_ecma_string (ecma_string_t *string_p) /**< ecma-string */",
        "snippet": "void\necma_deref_ecma_string (ecma_string_t *string_p) /**< ecma-string */\n{\n  JERRY_ASSERT (string_p != NULL);\n\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    return;\n  }\n\n#ifdef JERRY_NDEBUG\n  if (ECMA_STRING_IS_STATIC (string_p))\n  {\n    return;\n  }\n#endif /* JERRY_NDEBUG */\n\n  JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);\n\n  /* Decrease reference counter. */\n  string_p->refs_and_container -= ECMA_STRING_REF_ONE;\n\n  if (string_p->refs_and_container >= ECMA_STRING_REF_ONE)\n  {\n    return;\n  }\n\n  ecma_destroy_ecma_string (string_p);\n}",
        "begin_line": 789,
        "end_line": 817,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_destroy_ecma_string#822",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_destroy_ecma_string (ecma_string_t *string_p) /**< ecma-string */",
        "snippet": "void\necma_destroy_ecma_string (ecma_string_t *string_p) /**< ecma-string */\n{\n  JERRY_ASSERT (string_p != NULL);\n  JERRY_ASSERT (!ECMA_IS_DIRECT_STRING (string_p));\n  JERRY_ASSERT ((string_p->refs_and_container < ECMA_STRING_REF_ONE) || ECMA_STRING_IS_STATIC (string_p));\n\n  switch (ECMA_STRING_GET_CONTAINER (string_p))\n  {\n    case ECMA_STRING_CONTAINER_HEAP_UTF8_STRING:\n    {\n      ecma_dealloc_string_buffer (string_p, ((ecma_utf8_string_t *) string_p)->size + sizeof (ecma_utf8_string_t));\n      return;\n    }\n    case ECMA_STRING_CONTAINER_HEAP_LONG_UTF8_STRING:\n    {\n      ecma_dealloc_string_buffer (string_p,\n                                  ((ecma_long_utf8_string_t *) string_p)->size + sizeof (ecma_long_utf8_string_t));\n      return;\n    }\n    case ECMA_STRING_CONTAINER_HEAP_ASCII_STRING:\n    {\n      ecma_dealloc_string_buffer (string_p,\n                                  ((ecma_ascii_string_t *) string_p)->size + sizeof (ecma_ascii_string_t));\n      return;\n    }\n#if ENABLED (JERRY_ES2015)\n    case ECMA_STRING_CONTAINER_SYMBOL:\n    {\n      ecma_extended_string_t * symbol_p = (ecma_extended_string_t *) string_p;\n      ecma_free_value (symbol_p->u.symbol_descriptor);\n      ecma_dealloc_extended_string (symbol_p);\n      return;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    default:\n    {\n      JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC\n                    || ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);\n\n      /* only the string descriptor itself should be freed */\n      ecma_dealloc_string (string_p);\n    }\n  }\n}",
        "begin_line": 822,
        "end_line": 866,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_find_special_string#296",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_find_special_string (const lit_utf8_byte_t *string_p, /**< utf8 string */                           lit_utf8_size_t string_size) /**< string size */",
        "snippet": "static ecma_string_t *\necma_find_special_string (const lit_utf8_byte_t *string_p, /**< utf8 string */\n                          lit_utf8_size_t string_size) /**< string size */\n{\n  JERRY_ASSERT (string_p != NULL || string_size == 0);\n  lit_magic_string_id_t magic_string_id = lit_is_utf8_string_magic (string_p, string_size);\n\n  if (magic_string_id != LIT_MAGIC_STRING__COUNT)\n  {\n    return ecma_get_magic_string (magic_string_id);\n  }\n\n  JERRY_ASSERT (string_size > 0);\n\n  if (*string_p >= LIT_CHAR_0 && *string_p <= LIT_CHAR_9)\n  {\n    uint32_t array_index;\n\n    if (ecma_string_to_array_index (string_p, string_size, &array_index))\n    {\n      return ecma_new_ecma_string_from_uint32 (array_index);\n    }\n  }\n\n  if (lit_get_magic_string_ex_count () > 0)\n  {\n    lit_magic_string_ex_id_t magic_string_ex_id = lit_is_ex_utf8_string_magic (string_p, string_size);\n\n    if (magic_string_ex_id < lit_get_magic_string_ex_count ())\n    {\n      return ecma_new_ecma_string_from_magic_string_ex_id (magic_string_ex_id);\n    }\n  }\n\n  return NULL;\n}",
        "begin_line": 296,
        "end_line": 331,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_get_string_magic#2261",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_get_string_magic (const ecma_string_t *string_p) /**< ecma-string */",
        "snippet": "lit_magic_string_id_t\necma_get_string_magic (const ecma_string_t *string_p) /**< ecma-string */\n{\n  if (ECMA_IS_DIRECT_STRING_WITH_TYPE (string_p, ECMA_DIRECT_STRING_MAGIC))\n  {\n    uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);\n\n    if (id < LIT_MAGIC_STRING__COUNT)\n    {\n      return (lit_magic_string_id_t) id;\n    }\n  }\n\n  return LIT_MAGIC_STRING__COUNT;\n}",
        "begin_line": 2261,
        "end_line": 2275,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_new_ecma_string_from_uint32#505",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_new_ecma_string_from_uint32 (uint32_t uint32_number) /**< uint32 value of the string */",
        "snippet": "ecma_string_t *\necma_new_ecma_string_from_uint32 (uint32_t uint32_number) /**< uint32 value of the string */\n{\n  if (JERRY_LIKELY (uint32_number <= ECMA_DIRECT_STRING_MAX_IMM))\n  {\n    return (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_UINT, (uintptr_t) uint32_number);\n  }\n\n  return ecma_new_non_direct_string_from_uint32 (uint32_number);\n}",
        "begin_line": 505,
        "end_line": 514,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_new_ecma_string_from_utf8#338",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_new_ecma_string_from_utf8 (const lit_utf8_byte_t *string_p, /**< utf-8 string */                                 lit_utf8_size_t string_size) /**< string size */",
        "snippet": "ecma_string_t *\necma_new_ecma_string_from_utf8 (const lit_utf8_byte_t *string_p, /**< utf-8 string */\n                                lit_utf8_size_t string_size) /**< string size */\n{\n  JERRY_ASSERT (string_p != NULL || string_size == 0);\n  JERRY_ASSERT (lit_is_valid_cesu8_string (string_p, string_size));\n\n  ecma_string_t *string_desc_p = ecma_find_special_string (string_p, string_size);\n\n  if (string_desc_p != NULL)\n  {\n    return string_desc_p;\n  }\n\n  lit_utf8_byte_t *data_p;\n  string_desc_p = ecma_new_ecma_string_from_utf8_buffer (lit_utf8_string_length (string_p, string_size),\n                                                         string_size,\n                                                         &data_p);\n\n  string_desc_p->u.hash = lit_utf8_string_calc_hash (string_p, string_size);\n  memcpy (data_p, string_p, string_size);\n\n  return string_desc_p;\n}",
        "begin_line": 338,
        "end_line": 361,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_ref_ecma_string#755",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_ref_ecma_string (ecma_string_t *string_p) /**< string descriptor */",
        "snippet": "void\necma_ref_ecma_string (ecma_string_t *string_p) /**< string descriptor */\n{\n  JERRY_ASSERT (string_p != NULL);\n\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    return;\n  }\n\n#ifdef JERRY_NDEBUG\n  if (ECMA_STRING_IS_STATIC (string_p))\n  {\n    return;\n  }\n#endif /* JERRY_NDEBUG */\n\n  JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);\n\n  if (JERRY_LIKELY (string_p->refs_and_container < ECMA_STRING_MAX_REF))\n  {\n    /* Increase reference counter. */\n    string_p->refs_and_container += ECMA_STRING_REF_ONE;\n  }\n  else\n  {\n    jerry_fatal (ERR_REF_COUNT_LIMIT);\n  }\n}",
        "begin_line": 755,
        "end_line": 783,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_ascii_size#1899",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_ascii_size (const ecma_string_t *string_p) /**< ecma-string */",
        "snippet": "static ecma_length_t\necma_string_get_ascii_size (const ecma_string_t *string_p) /**< ecma-string */\n{\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    switch (ECMA_GET_DIRECT_STRING_TYPE (string_p))\n    {\n      case ECMA_DIRECT_STRING_MAGIC:\n      {\n        uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);\n\n        if (id >= LIT_MAGIC_STRING__COUNT)\n        {\n          return ECMA_STRING_NO_ASCII_SIZE;\n        }\n\n        JERRY_ASSERT (ECMA_STRING_IS_ASCII (lit_get_magic_string_utf8 (id),\n                                            lit_get_magic_string_size (id)));\n\n        return lit_get_magic_string_size (id);\n      }\n      default:\n      {\n        JERRY_ASSERT (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_UINT);\n        uint32_t uint32_number = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);\n        return ecma_string_get_uint32_size (uint32_number);\n      }\n    }\n  }\n\n  JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);\n\n  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC)\n  {\n    return ecma_string_get_uint32_size (string_p->u.uint32_number);\n  }\n  else if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_HEAP_ASCII_STRING)\n  {\n    return ((ecma_ascii_string_t *) string_p)->size;\n  }\n\n  return ECMA_STRING_NO_ASCII_SIZE;\n}",
        "begin_line": 1899,
        "end_line": 1941,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_chars#1323",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_chars (const ecma_string_t *string_p, /**< ecma-string */                        lit_utf8_size_t *size_p, /**< [out] size of the ecma string */                        lit_utf8_size_t *length_p, /**< [out] optional argument. If the pointer is not NULL the pointed                                                    *    memory area is filled with the length of the ecma string */                        lit_utf8_byte_t *uint32_buff_p, /**< [out] optional argument. If the pointer is not NULL the                                                         *    pointed memory area is filled with the string converted                                                         *    uint32 string descriptor */                        uint8_t *flags_p) /**< [in, out] any combination of ecma_string_flag_t bits */",
        "snippet": "const lit_utf8_byte_t *\necma_string_get_chars (const ecma_string_t *string_p, /**< ecma-string */\n                       lit_utf8_size_t *size_p, /**< [out] size of the ecma string */\n                       lit_utf8_size_t *length_p, /**< [out] optional argument. If the pointer is not NULL the pointed\n                                                   *    memory area is filled with the length of the ecma string */\n                       lit_utf8_byte_t *uint32_buff_p, /**< [out] optional argument. If the pointer is not NULL the\n                                                        *    pointed memory area is filled with the string converted\n                                                        *    uint32 string descriptor */\n                       uint8_t *flags_p) /**< [in,out] any combination of ecma_string_flag_t bits */\n{\n  ecma_length_t length;\n  lit_utf8_size_t size;\n  const lit_utf8_byte_t *result_p;\n\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    *flags_p |= ECMA_STRING_FLAG_REHASH_NEEDED;\n\n    switch (ECMA_GET_DIRECT_STRING_TYPE (string_p))\n    {\n      case ECMA_DIRECT_STRING_MAGIC:\n      {\n        uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);\n\n        if (id >= LIT_MAGIC_STRING__COUNT)\n        {\n          id -= LIT_MAGIC_STRING__COUNT;\n          size = lit_get_magic_string_ex_size (id);\n          result_p = lit_get_magic_string_ex_utf8 (id);\n          length = 0;\n\n          if (JERRY_UNLIKELY (*flags_p & ECMA_STRING_FLAG_IS_ASCII))\n          {\n            length = lit_utf8_string_length (result_p, size);\n          }\n        }\n        else\n        {\n          size = lit_get_magic_string_size (id);\n          length = size;\n\n          result_p = lit_get_magic_string_utf8 (id);\n\n          /* All magic strings must be ascii strings. */\n          JERRY_ASSERT (ECMA_STRING_IS_ASCII (result_p, size));\n        }\n        break;\n      }\n      default:\n      {\n        JERRY_ASSERT (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_UINT);\n        uint32_t uint32_number = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);\n        size = (lit_utf8_size_t) ecma_string_get_uint32_size (uint32_number);\n\n        if (uint32_buff_p != NULL)\n        {\n          result_p = uint32_buff_p;\n        }\n        else\n        {\n          result_p = (const lit_utf8_byte_t *) jmem_heap_alloc_block (size);\n          *flags_p |= ECMA_STRING_FLAG_MUST_BE_FREED;\n        }\n\n        length = ecma_uint32_to_utf8_string (uint32_number, (lit_utf8_byte_t *) result_p, size);\n\n        JERRY_ASSERT (length == size);\n        *flags_p |= ECMA_STRING_FLAG_IS_UINT32;\n        break;\n      }\n    }\n  }\n  else\n  {\n    JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);\n\n    switch (ECMA_STRING_GET_CONTAINER (string_p))\n    {\n      case ECMA_STRING_CONTAINER_HEAP_UTF8_STRING:\n      {\n        ecma_utf8_string_t *utf8_string_desc_p = (ecma_utf8_string_t *) string_p;\n        size = utf8_string_desc_p->size;\n        length = utf8_string_desc_p->length;\n        result_p = ECMA_UTF8_STRING_GET_BUFFER (utf8_string_desc_p);\n        break;\n      }\n      case ECMA_STRING_CONTAINER_HEAP_LONG_UTF8_STRING:\n      {\n        ecma_long_utf8_string_t *long_utf8_string_desc_p = (ecma_long_utf8_string_t *) string_p;\n        size = long_utf8_string_desc_p->size;\n        length = long_utf8_string_desc_p->length;\n        result_p = ECMA_LONG_UTF8_STRING_GET_BUFFER (long_utf8_string_desc_p);\n        break;\n      }\n      case ECMA_STRING_CONTAINER_HEAP_ASCII_STRING:\n      {\n        ecma_ascii_string_t *ascii_string_desc_p = (ecma_ascii_string_t *) string_p;\n        size = ascii_string_desc_p->size;\n        length = ascii_string_desc_p->size;\n        result_p = ECMA_ASCII_STRING_GET_BUFFER (ascii_string_desc_p);\n        break;\n      }\n      case ECMA_STRING_CONTAINER_UINT32_IN_DESC:\n      {\n        size = (lit_utf8_size_t) ecma_string_get_uint32_size (string_p->u.uint32_number);\n\n        if (uint32_buff_p != NULL)\n        {\n          result_p = uint32_buff_p;\n        }\n        else\n        {\n          result_p = (const lit_utf8_byte_t *) jmem_heap_alloc_block (size);\n          *flags_p |= ECMA_STRING_FLAG_MUST_BE_FREED;\n        }\n\n        length = ecma_uint32_to_utf8_string (string_p->u.uint32_number, (lit_utf8_byte_t *) result_p, size);\n\n        JERRY_ASSERT (length == size);\n        *flags_p |= ECMA_STRING_FLAG_IS_UINT32 | ECMA_STRING_FLAG_REHASH_NEEDED;\n        break;\n\n      }\n      default:\n      {\n        JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);\n\n        lit_magic_string_ex_id_t id = LIT_MAGIC_STRING__COUNT - string_p->u.magic_string_ex_id;\n        size = lit_get_magic_string_ex_size (id);\n        length = 0;\n\n        if (JERRY_UNLIKELY (*flags_p & ECMA_STRING_FLAG_IS_ASCII))\n        {\n          length = lit_utf8_string_length (lit_get_magic_string_ex_utf8 (id), size);\n        }\n\n        result_p = lit_get_magic_string_ex_utf8 (id);\n        *flags_p |= ECMA_STRING_FLAG_REHASH_NEEDED;\n        break;\n      }\n    }\n  }\n\n  *size_p = size;\n  if (length_p != NULL)\n  {\n    *length_p = length;\n  }\n\n  if ((*flags_p & ECMA_STRING_FLAG_IS_ASCII)\n      && length != size)\n  {\n    *flags_p = (uint8_t) (*flags_p & (uint8_t) ~ECMA_STRING_FLAG_IS_ASCII);\n  }\n\n  return result_p;\n}",
        "begin_line": 1323,
        "end_line": 1479,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_chars_fast#129",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_chars_fast (const ecma_string_t *string_p, /**< ecma-string */                             lit_utf8_size_t *size_p) /**< [out] size of the ecma string */",
        "snippet": "static const lit_utf8_byte_t *\necma_string_get_chars_fast (const ecma_string_t *string_p, /**< ecma-string */\n                            lit_utf8_size_t *size_p) /**< [out] size of the ecma string */\n{\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    if (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_MAGIC)\n    {\n      uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);\n\n      if (id >= LIT_MAGIC_STRING__COUNT)\n      {\n        id -= LIT_MAGIC_STRING__COUNT;\n\n        *size_p = lit_get_magic_string_ex_size (id);\n        return lit_get_magic_string_ex_utf8 (id);\n      }\n\n      *size_p = lit_get_magic_string_size (id);\n      return lit_get_magic_string_utf8 (id);\n    }\n  }\n\n  JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);\n\n  switch (ECMA_STRING_GET_CONTAINER (string_p))\n  {\n    case ECMA_STRING_CONTAINER_HEAP_UTF8_STRING:\n    {\n      *size_p = ((ecma_utf8_string_t *) string_p)->size;\n      return ECMA_UTF8_STRING_GET_BUFFER (string_p);\n    }\n    case ECMA_STRING_CONTAINER_HEAP_LONG_UTF8_STRING:\n    {\n      *size_p = ((ecma_long_utf8_string_t *) string_p)->size;\n      return ECMA_LONG_UTF8_STRING_GET_BUFFER (string_p);\n    }\n    case ECMA_STRING_CONTAINER_HEAP_ASCII_STRING:\n    {\n      *size_p = ((ecma_ascii_string_t *) string_p)->size;\n      return ECMA_ASCII_STRING_GET_BUFFER (string_p);\n    }\n    default:\n    {\n      JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);\n\n      lit_magic_string_ex_id_t id = LIT_MAGIC_STRING__COUNT - string_p->u.magic_string_ex_id;\n      *size_p = lit_get_magic_string_ex_size (id);\n      return lit_get_magic_string_ex_utf8 (id);\n    }\n  }\n}",
        "begin_line": 129,
        "end_line": 180,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_size#2048",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_size (const ecma_string_t *string_p) /**< ecma-string */",
        "snippet": "lit_utf8_size_t\necma_string_get_size (const ecma_string_t *string_p) /**< ecma-string */\n{\n  ecma_length_t length = ecma_string_get_ascii_size (string_p);\n\n  if (length != ECMA_STRING_NO_ASCII_SIZE)\n  {\n    return length;\n  }\n\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    JERRY_ASSERT (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_MAGIC);\n    JERRY_ASSERT ((uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p) >= LIT_MAGIC_STRING__COUNT);\n\n    return lit_get_magic_string_ex_size ((uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p) - LIT_MAGIC_STRING__COUNT);\n  }\n\n  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_HEAP_UTF8_STRING)\n  {\n    return (lit_utf8_size_t) (((ecma_utf8_string_t *) string_p)->size);\n  }\n\n  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_HEAP_LONG_UTF8_STRING)\n  {\n    return (lit_utf8_size_t) (((ecma_long_utf8_string_t *) string_p)->size);\n  }\n\n  JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);\n\n  return lit_get_magic_string_ex_size (LIT_MAGIC_STRING__COUNT - string_p->u.magic_string_ex_id);\n}",
        "begin_line": 2048,
        "end_line": 2079,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_trim_helper#2352",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_trim_helper (const lit_utf8_byte_t **utf8_str_p, /**< [in, out] current string position */                          lit_utf8_size_t *utf8_str_size) /**< [in, out] size of the given string */",
        "snippet": "void\necma_string_trim_helper (const lit_utf8_byte_t **utf8_str_p, /**< [in, out] current string position */\n                         lit_utf8_size_t *utf8_str_size) /**< [in, out] size of the given string */\n{\n  ecma_char_t ch;\n  lit_utf8_size_t read_size;\n  const lit_utf8_byte_t *nonws_start_p = *utf8_str_p + *utf8_str_size;\n  const lit_utf8_byte_t *current_p = *utf8_str_p;\n\n  while (current_p < nonws_start_p)\n  {\n    read_size = lit_read_code_unit_from_utf8 (current_p, &ch);\n\n    if (!lit_char_is_white_space (ch))\n    {\n      nonws_start_p = current_p;\n      break;\n    }\n\n    current_p += read_size;\n  }\n\n  current_p = *utf8_str_p + *utf8_str_size;\n\n  while (current_p > nonws_start_p)\n  {\n    read_size = lit_read_prev_code_unit_from_utf8 (current_p, &ch);\n\n    if (!lit_char_is_white_space (ch))\n    {\n      break;\n    }\n\n    current_p -= read_size;\n  }\n\n  *utf8_str_p = nonws_start_p;\n  *utf8_str_size = (lit_utf8_size_t) (current_p - nonws_start_p);\n}",
        "begin_line": 2352,
        "end_line": 2390,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_append#2569",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_append (ecma_stringbuilder_t *builder_p, /**< string builder */                            const ecma_string_t *string_p) /**< ecma string */",
        "snippet": "void\necma_stringbuilder_append (ecma_stringbuilder_t *builder_p, /**< string builder */\n                           const ecma_string_t *string_p) /**< ecma string */\n{\n  const lit_utf8_size_t string_size = ecma_string_get_size (string_p);\n  lit_utf8_byte_t *dest_p = ecma_stringbuilder_grow (builder_p, string_size);\n\n  size_t copied_size = ecma_string_copy_to_cesu8_buffer (string_p,\n                                                         dest_p,\n                                                         string_size);\n  JERRY_ASSERT (copied_size == string_size);\n}",
        "begin_line": 2569,
        "end_line": 2580,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_append_magic#2585",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_append_magic (ecma_stringbuilder_t *builder_p, /**< string builder */                                  const lit_magic_string_id_t id) /**< magic string id */",
        "snippet": "void\necma_stringbuilder_append_magic (ecma_stringbuilder_t *builder_p, /**< string builder */\n                                 const lit_magic_string_id_t id) /**< magic string id */\n{\n  const lit_utf8_size_t string_size = lit_get_magic_string_size (id);\n  lit_utf8_byte_t *dest_p = ecma_stringbuilder_grow (builder_p, string_size);\n\n  const lit_utf8_byte_t *string_data_p = lit_get_magic_string_utf8 (id);\n  memcpy (dest_p, string_data_p, string_size);\n}",
        "begin_line": 2585,
        "end_line": 2594,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_append_raw#2599",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_append_raw (ecma_stringbuilder_t *builder_p, /**< string builder */                                const lit_utf8_byte_t *data_p, /**< pointer to data */                                const lit_utf8_size_t data_size) /**< size of the data */",
        "snippet": "void\necma_stringbuilder_append_raw (ecma_stringbuilder_t *builder_p, /**< string builder */\n                               const lit_utf8_byte_t *data_p, /**< pointer to data */\n                               const lit_utf8_size_t data_size) /**< size of the data */\n{\n  lit_utf8_byte_t *dest_p = ecma_stringbuilder_grow (builder_p, data_size);\n  memcpy (dest_p, data_p, data_size);\n}",
        "begin_line": 2599,
        "end_line": 2606,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_create#2429",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_create (void)",
        "snippet": "ecma_stringbuilder_t\necma_stringbuilder_create (void)\n{\n  const lit_utf8_size_t initial_size = sizeof (ecma_ascii_string_t);\n  ecma_stringbuilder_header_t *header_p = (ecma_stringbuilder_header_t *) jmem_heap_alloc_block (initial_size);\n  header_p->current_size = initial_size;\n#if ENABLED (JERRY_MEM_STATS)\n  jmem_stats_allocate_string_bytes (initial_size);\n#endif /* ENABLED (JERRY_MEM_STATS) */\n\n  ecma_stringbuilder_t ret = {.header_p = header_p};\n  return ret;\n}",
        "begin_line": 2429,
        "end_line": 2441,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_create_raw#2474",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_create_raw (const lit_utf8_byte_t *data_p, /**< pointer to data */                                const lit_utf8_size_t data_size) /**< size of the data */",
        "snippet": "ecma_stringbuilder_t\necma_stringbuilder_create_raw (const lit_utf8_byte_t *data_p, /**< pointer to data */\n                               const lit_utf8_size_t data_size) /**< size of the data */\n{\n  const lit_utf8_size_t initial_size = data_size + (lit_utf8_size_t) sizeof (ecma_ascii_string_t);\n\n  ecma_stringbuilder_header_t *header_p = (ecma_stringbuilder_header_t *) jmem_heap_alloc_block (initial_size);\n  header_p->current_size = initial_size;\n#if ENABLED (JERRY_MEM_STATS)\n  jmem_stats_allocate_string_bytes (initial_size);\n#endif /* ENABLED (JERRY_MEM_STATS) */\n\n  memcpy (ECMA_STRINGBUILDER_STRING_PTR (header_p), data_p, data_size);\n\n  ecma_stringbuilder_t ret = {.header_p = header_p};\n  return ret;\n}",
        "begin_line": 2474,
        "end_line": 2490,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_finalize#2640",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_finalize (ecma_stringbuilder_t *builder_p) /**< string builder */",
        "snippet": "ecma_string_t *\necma_stringbuilder_finalize (ecma_stringbuilder_t *builder_p) /**< string builder */\n{\n  ecma_stringbuilder_header_t *header_p = builder_p->header_p;\n  JERRY_ASSERT (header_p != NULL);\n\n  const lit_utf8_size_t string_size = ECMA_STRINGBUILDER_STRING_SIZE (header_p);\n  lit_utf8_byte_t *string_begin_p = ECMA_STRINGBUILDER_STRING_PTR (header_p);\n\n  ecma_string_t *string_p = ecma_find_special_string (string_begin_p, string_size);\n\n  if (JERRY_UNLIKELY (string_p != NULL))\n  {\n    ecma_stringbuilder_destroy (builder_p);\n    return string_p;\n  }\n\n#ifndef JERRY_NDEBUG\n  builder_p->header_p = NULL;\n#endif\n\n  size_t container_size = sizeof (ecma_utf8_string_t);\n  const lit_string_hash_t hash = lit_utf8_string_calc_hash (string_begin_p, string_size);\n  const lit_utf8_size_t length = lit_utf8_string_length (string_begin_p, string_size);\n\n  if (JERRY_LIKELY (string_size <= UINT16_MAX))\n  {\n    if (JERRY_LIKELY (length == string_size))\n    {\n      ecma_ascii_string_t *ascii_string_p = (ecma_ascii_string_t *) header_p;\n      ascii_string_p->header.refs_and_container = ECMA_STRING_CONTAINER_HEAP_ASCII_STRING | ECMA_STRING_REF_ONE;\n      ascii_string_p->header.u.hash = hash;\n      ascii_string_p->size = (uint16_t) string_size;\n\n      return (ecma_string_t *) ascii_string_p;\n    }\n  }\n  else\n  {\n    container_size = sizeof (ecma_long_utf8_string_t);\n  }\n\n  const size_t utf8_string_size = string_size + container_size;\n  header_p = jmem_heap_realloc_block (header_p, header_p->current_size, utf8_string_size);\n  memmove (((lit_utf8_byte_t *) header_p + container_size),\n           ECMA_STRINGBUILDER_STRING_PTR (header_p),\n           string_size);\n\n#if ENABLED (JERRY_MEM_STATS)\n  jmem_stats_allocate_string_bytes (container_size - sizeof (ecma_ascii_string_t));\n#endif /* ENABLED (JERRY_MEM_STATS) */\n\n  if (JERRY_LIKELY (string_size <= UINT16_MAX))\n  {\n    ecma_utf8_string_t *utf8_string_p = (ecma_utf8_string_t *) header_p;\n\n    utf8_string_p->header.refs_and_container = ECMA_STRING_CONTAINER_HEAP_UTF8_STRING | ECMA_STRING_REF_ONE;\n    utf8_string_p->header.u.hash = hash;\n    utf8_string_p->size = (uint16_t) string_size;\n    utf8_string_p->length = (uint16_t) length;\n\n    return (ecma_string_t *) utf8_string_p;\n  }\n\n  ecma_long_utf8_string_t *long_utf8_string_p = (ecma_long_utf8_string_t *) header_p;\n\n  long_utf8_string_p->header.refs_and_container = ECMA_STRING_CONTAINER_HEAP_LONG_UTF8_STRING | ECMA_STRING_REF_ONE;\n  long_utf8_string_p->header.u.hash = hash;\n  long_utf8_string_p->size = string_size;\n  long_utf8_string_p->length = length;\n\n  return (ecma_string_t *) long_utf8_string_p;\n}",
        "begin_line": 2640,
        "end_line": 2712,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_grow#2497",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_grow (ecma_stringbuilder_t *builder_p, /**< string builder */                          lit_utf8_size_t required_size) /**< required size */",
        "snippet": "static lit_utf8_byte_t *\necma_stringbuilder_grow (ecma_stringbuilder_t *builder_p, /**< string builder */\n                         lit_utf8_size_t required_size) /**< required size */\n{\n  ecma_stringbuilder_header_t *header_p = builder_p->header_p;\n  JERRY_ASSERT (header_p != NULL);\n\n  const lit_utf8_size_t new_size = header_p->current_size + required_size;\n  header_p = jmem_heap_realloc_block (header_p, header_p->current_size, new_size);\n  header_p->current_size = new_size;\n  builder_p->header_p = header_p;\n\n#if ENABLED (JERRY_MEM_STATS)\n  jmem_stats_allocate_string_bytes (required_size);\n#endif /* ENABLED (JERRY_MEM_STATS) */\n\n  return ((lit_utf8_byte_t *)  header_p) + header_p->current_size - required_size;\n}",
        "begin_line": 2497,
        "end_line": 2514,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_check_value_type_is_spec_defined#401",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_check_value_type_is_spec_defined (ecma_value_t value) /**< ecma value */",
        "snippet": "void\necma_check_value_type_is_spec_defined (ecma_value_t value) /**< ecma value */\n{\n  JERRY_ASSERT (ecma_is_value_undefined (value)\n                || ecma_is_value_null (value)\n                || ecma_is_value_boolean (value)\n                || ecma_is_value_number (value)\n                || ecma_is_value_string (value)\n                || ECMA_ASSERT_VALUE_IS_SYMBOL (value)\n                || ecma_is_value_object (value));\n}",
        "begin_line": 401,
        "end_line": 411,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_copy_value#829",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_copy_value (ecma_value_t value)  /**< value description */",
        "snippet": "ecma_value_t\necma_copy_value (ecma_value_t value)  /**< value description */\n{\n  switch (ecma_get_value_type_field (value))\n  {\n    case ECMA_TYPE_FLOAT:\n    {\n      ecma_number_t *num_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (value);\n\n      return ecma_create_float_number (*num_p);\n    }\n    case ECMA_TYPE_STRING:\n    {\n      ecma_ref_ecma_string (ecma_get_string_from_value (value));\n      return value;\n    }\n#if ENABLED (JERRY_ES2015)\n    case ECMA_TYPE_SYMBOL:\n    {\n      ecma_ref_ecma_string (ecma_get_symbol_from_value (value));\n      return value;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case ECMA_TYPE_OBJECT:\n    {\n      ecma_ref_object (ecma_get_object_from_value (value));\n      return value;\n    }\n    default:\n    {\n      JERRY_ASSERT (ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT\n                    || ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT_STRING);\n\n      return value;\n    }\n  }\n}",
        "begin_line": 829,
        "end_line": 865,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_free_value#1048",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_free_value (ecma_value_t value) /**< value description */",
        "snippet": "void\necma_free_value (ecma_value_t value) /**< value description */\n{\n  switch (ecma_get_value_type_field (value))\n  {\n    case ECMA_TYPE_FLOAT:\n    {\n      ecma_number_t *number_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (value);\n      ecma_dealloc_number (number_p);\n      break;\n    }\n\n    case ECMA_TYPE_STRING:\n    {\n      ecma_string_t *string_p = ecma_get_string_from_value (value);\n      ecma_deref_ecma_string (string_p);\n      break;\n    }\n#if ENABLED (JERRY_ES2015)\n    case ECMA_TYPE_SYMBOL:\n    {\n      ecma_deref_ecma_string (ecma_get_symbol_from_value (value));\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case ECMA_TYPE_OBJECT:\n    {\n      ecma_deref_object (ecma_get_object_from_value (value));\n      break;\n    }\n\n    default:\n    {\n      JERRY_ASSERT (ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT\n                    || ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT_STRING);\n\n      /* no memory is allocated */\n      break;\n    }\n  }\n}",
        "begin_line": 1048,
        "end_line": 1088,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_free_value_if_not_object#1111",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_free_value_if_not_object (ecma_value_t value) /**< value description */",
        "snippet": "void\necma_free_value_if_not_object (ecma_value_t value) /**< value description */\n{\n  if (ecma_get_value_type_field (value) != ECMA_TYPE_OBJECT)\n  {\n    ecma_free_value (value);\n  }\n}",
        "begin_line": 1111,
        "end_line": 1118,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_int32_value#558",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_int32_value (int32_t int32_number) /**< int32 number to be encoded */",
        "snippet": "ecma_value_t\necma_make_int32_value (int32_t int32_number) /**< int32 number to be encoded */\n{\n  if (ECMA_IS_INTEGER_NUMBER (int32_number))\n  {\n    return ecma_make_integer_value ((ecma_integer_value_t) int32_number);\n  }\n\n  return ecma_create_float_number ((ecma_number_t) int32_number);\n}",
        "begin_line": 558,
        "end_line": 567,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_number_value#538",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_number_value (ecma_number_t ecma_number) /**< number to be encoded */",
        "snippet": "ecma_value_t\necma_make_number_value (ecma_number_t ecma_number) /**< number to be encoded */\n{\n  ecma_integer_value_t integer_value = (ecma_integer_value_t) ecma_number;\n\n  if ((ecma_number_t) integer_value == ecma_number\n      && ((integer_value == 0) ? ecma_is_number_equal_to_positive_zero (ecma_number)\n                               : ECMA_IS_INTEGER_NUMBER (integer_value)))\n  {\n    return ecma_make_integer_value (integer_value);\n  }\n\n  return ecma_create_float_number (ecma_number);\n}",
        "begin_line": 538,
        "end_line": 551,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_uint32_value#574",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_uint32_value (uint32_t uint32_number) /**< uint32 number to be encoded */",
        "snippet": "ecma_value_t\necma_make_uint32_value (uint32_t uint32_number) /**< uint32 number to be encoded */\n{\n  if (uint32_number <= ECMA_INTEGER_NUMBER_MAX)\n  {\n    return ecma_make_integer_value ((ecma_integer_value_t) uint32_number);\n  }\n\n  return ecma_create_float_number ((ecma_number_t) uint32_number);\n}",
        "begin_line": 574,
        "end_line": 583,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_value_assign_value#930",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_value_assign_value (ecma_value_t *value_p, /**< [in, out] ecma value */                          ecma_value_t ecma_value) /**< value to assign */",
        "snippet": "void\necma_value_assign_value (ecma_value_t *value_p, /**< [in, out] ecma value */\n                         ecma_value_t ecma_value) /**< value to assign */\n{\n  JERRY_STATIC_ASSERT (ECMA_TYPE_DIRECT == 0,\n                       ecma_type_direct_must_be_zero_for_the_next_check);\n\n  if (*value_p == ecma_value)\n  {\n    return;\n  }\n\n  if (ecma_get_value_type_field (ecma_value || *value_p) == ECMA_TYPE_DIRECT)\n  {\n    *value_p = ecma_value;\n  }\n  else if (ecma_is_value_float_number (ecma_value)\n           && ecma_is_value_float_number (*value_p))\n  {\n    const ecma_number_t *num_src_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (ecma_value);\n    ecma_number_t *num_dst_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (*value_p);\n\n    *num_dst_p = *num_src_p;\n  }\n  else\n  {\n    ecma_free_value_if_not_object (*value_p);\n    *value_p = ecma_copy_value_if_not_object (ecma_value);\n  }\n}",
        "begin_line": 930,
        "end_line": 959,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_assert_object_contains_the_property#911",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_assert_object_contains_the_property (const ecma_object_t *object_p, /**< ecma-object */                                           const ecma_property_value_t *prop_value_p, /**< property value */                                           ecma_property_types_t type) /**< expected property type */",
        "snippet": "static void\necma_assert_object_contains_the_property (const ecma_object_t *object_p, /**< ecma-object */\n                                          const ecma_property_value_t *prop_value_p, /**< property value */\n                                          ecma_property_types_t type) /**< expected property type */\n{\n#ifndef JERRY_NDEBUG\n  jmem_cpointer_t prop_iter_cp = object_p->u1.property_list_cp;\n  JERRY_ASSERT (prop_iter_cp != JMEM_CP_NULL);\n\n  ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n\n  if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n  {\n    prop_iter_cp = prop_iter_p->next_property_cp;\n  }\n\n  while (prop_iter_cp != JMEM_CP_NULL)\n  {\n    prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n\n    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)\n    {\n      if ((prop_pair_p->values + i) == prop_value_p)\n      {\n        JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (prop_pair_p->header.types[i]) == type);\n        return;\n      }\n    }\n\n    prop_iter_cp = prop_iter_p->next_property_cp;\n  }\n#else /* JERRY_NDEBUG */\n  JERRY_UNUSED (object_p);\n  JERRY_UNUSED (prop_value_p);\n  JERRY_UNUSED (type);\n#endif /* !JERRY_NDEBUG */\n}",
        "begin_line": 911,
        "end_line": 951,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_bytecode_deref#1356",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_bytecode_deref (ecma_compiled_code_t *bytecode_p) /**< byte code pointer */",
        "snippet": "void\necma_bytecode_deref (ecma_compiled_code_t *bytecode_p) /**< byte code pointer */\n{\n  JERRY_ASSERT (bytecode_p->refs > 0);\n  JERRY_ASSERT (!(bytecode_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION));\n\n  bytecode_p->refs--;\n\n  if (bytecode_p->refs > 0)\n  {\n    /* Non-zero reference counter. */\n    return;\n  }\n\n  if (bytecode_p->status_flags & CBC_CODE_FLAGS_FUNCTION)\n  {\n    ecma_value_t *literal_start_p = NULL;\n    uint32_t literal_end;\n    uint32_t const_literal_end;\n\n    if (bytecode_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n    {\n      cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_p;\n      literal_end = args_p->literal_end;\n      const_literal_end = args_p->const_literal_end;\n\n      literal_start_p = (ecma_value_t *) ((uint8_t *) bytecode_p + sizeof (cbc_uint16_arguments_t));\n      literal_start_p -= args_p->register_end;\n    }\n    else\n    {\n      cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_p;\n      literal_end = args_p->literal_end;\n      const_literal_end = args_p->const_literal_end;\n\n      literal_start_p = (ecma_value_t *) ((uint8_t *) bytecode_p + sizeof (cbc_uint8_arguments_t));\n      literal_start_p -= args_p->register_end;\n    }\n\n    for (uint32_t i = const_literal_end; i < literal_end; i++)\n    {\n      ecma_compiled_code_t *bytecode_literal_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,\n                                                                                  literal_start_p[i]);\n\n      /* Self references are ignored. */\n      if (bytecode_literal_p != bytecode_p)\n      {\n        ecma_bytecode_deref (bytecode_literal_p);\n      }\n    }\n\n#if ENABLED (JERRY_DEBUGGER)\n    if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n        && !(bytecode_p->status_flags & CBC_CODE_FLAGS_DEBUGGER_IGNORE)\n        && jerry_debugger_send_function_cp (JERRY_DEBUGGER_RELEASE_BYTE_CODE_CP, bytecode_p))\n    {\n      /* Delay the byte code free until the debugger client is notified.\n       * If the connection is aborted the pointer is still freed by\n       * jerry_debugger_close_connection(). */\n      jerry_debugger_byte_code_free_t *byte_code_free_p = (jerry_debugger_byte_code_free_t *) bytecode_p;\n      jmem_cpointer_t byte_code_free_head = JERRY_CONTEXT (debugger_byte_code_free_head);\n\n      byte_code_free_p->prev_cp = ECMA_NULL_POINTER;\n\n      jmem_cpointer_t byte_code_free_cp;\n      JMEM_CP_SET_NON_NULL_POINTER (byte_code_free_cp, byte_code_free_p);\n\n      if (byte_code_free_head == ECMA_NULL_POINTER)\n      {\n        JERRY_CONTEXT (debugger_byte_code_free_tail) = byte_code_free_cp;\n      }\n      else\n      {\n        jerry_debugger_byte_code_free_t *first_byte_code_free_p;\n\n        first_byte_code_free_p = JMEM_CP_GET_NON_NULL_POINTER (jerry_debugger_byte_code_free_t,\n                                                               byte_code_free_head);\n        first_byte_code_free_p->prev_cp = byte_code_free_cp;\n      }\n\n      JERRY_CONTEXT (debugger_byte_code_free_head) = byte_code_free_cp;\n      return;\n    }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n#if ENABLED (JERRY_ES2015)\n    if (bytecode_p->status_flags & CBC_CODE_FLAG_HAS_TAGGED_LITERALS)\n    {\n      ecma_length_t formal_params_number = ecma_compiled_code_get_formal_params (bytecode_p);\n\n      uint8_t *byte_p = (uint8_t *) bytecode_p;\n      byte_p += ((size_t) bytecode_p->size) << JMEM_ALIGNMENT_LOG;\n\n      ecma_value_t *tagged_base_p = (ecma_value_t *) byte_p;\n      tagged_base_p -= formal_params_number;\n\n      ecma_collection_t *coll_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, tagged_base_p[-1]);\n\n      ecma_collection_destroy (coll_p);\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_MEM_STATS)\n    jmem_stats_free_byte_code_bytes (((size_t) bytecode_p->size) << JMEM_ALIGNMENT_LOG);\n#endif /* ENABLED (JERRY_MEM_STATS) */\n  }\n  else\n  {\n#if ENABLED (JERRY_BUILTIN_REGEXP)\n    re_compiled_code_t *re_bytecode_p = (re_compiled_code_t *) bytecode_p;\n\n    ecma_deref_ecma_string (ecma_get_string_from_value (re_bytecode_p->source));\n#endif /* ENABLED (JERRY_BUILTIN_REGEXP) */\n  }\n\n  jmem_heap_free_block (bytecode_p,\n                        ((size_t) bytecode_p->size) << JMEM_ALIGNMENT_LOG);\n}",
        "begin_line": 1356,
        "end_line": 1473,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_bytecode_ref#1340",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_bytecode_ref (ecma_compiled_code_t *bytecode_p) /**< byte code pointer */",
        "snippet": "void\necma_bytecode_ref (ecma_compiled_code_t *bytecode_p) /**< byte code pointer */\n{\n  /* Abort program if maximum reference number is reached. */\n  if (bytecode_p->refs >= UINT16_MAX)\n  {\n    jerry_fatal (ERR_REF_COUNT_LIMIT);\n  }\n\n  bytecode_p->refs++;\n}",
        "begin_line": 1340,
        "end_line": 1350,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_create_decl_lex_env#110",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_create_decl_lex_env (ecma_object_t *outer_lexical_environment_p) /**< outer lexical environment */",
        "snippet": "ecma_object_t *\necma_create_decl_lex_env (ecma_object_t *outer_lexical_environment_p) /**< outer lexical environment */\n{\n  ecma_object_t *new_lexical_environment_p = ecma_alloc_object ();\n\n  uint16_t type = ECMA_OBJECT_FLAG_BUILT_IN_OR_LEXICAL_ENV | ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE;\n  new_lexical_environment_p->type_flags_refs = type;\n\n  ecma_init_gc_info (new_lexical_environment_p);\n\n  new_lexical_environment_p->u1.property_list_cp = JMEM_CP_NULL;\n\n  ECMA_SET_POINTER (new_lexical_environment_p->u2.outer_reference_cp, outer_lexical_environment_p);\n\n  return new_lexical_environment_p;\n}",
        "begin_line": 110,
        "end_line": 125,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_create_named_accessor_property#541",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_create_named_accessor_property (ecma_object_t *object_p, /**< object */                                      ecma_string_t *name_p, /**< property name */                                      ecma_object_t *get_p, /**< getter */                                      ecma_object_t *set_p, /**< setter */                                      uint8_t prop_attributes, /**< property attributes */                                      ecma_property_t **out_prop_p) /**< [out] the property is also returned                                                                     *         if this field is non-NULL */",
        "snippet": "ecma_property_value_t *\necma_create_named_accessor_property (ecma_object_t *object_p, /**< object */\n                                     ecma_string_t *name_p, /**< property name */\n                                     ecma_object_t *get_p, /**< getter */\n                                     ecma_object_t *set_p, /**< setter */\n                                     uint8_t prop_attributes, /**< property attributes */\n                                     ecma_property_t **out_prop_p) /**< [out] the property is also returned\n                                                                    *         if this field is non-NULL */\n{\n  JERRY_ASSERT (object_p != NULL && name_p != NULL);\n  JERRY_ASSERT (ecma_is_lexical_environment (object_p)\n                || !ecma_op_object_is_fast_array (object_p));\n  JERRY_ASSERT (ecma_find_named_property (object_p, name_p) == NULL);\n  JERRY_ASSERT ((prop_attributes & ~ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE) == 0);\n\n  uint8_t type_and_flags = ECMA_PROPERTY_TYPE_NAMEDACCESSOR | prop_attributes;\n\n  ecma_property_value_t value;\n#if ENABLED (JERRY_CPOINTER_32_BIT)\n  ecma_getter_setter_pointers_t *getter_setter_pair_p;\n  getter_setter_pair_p = jmem_pools_alloc (sizeof (ecma_getter_setter_pointers_t));\n  ECMA_SET_POINTER (getter_setter_pair_p->getter_cp, get_p);\n  ECMA_SET_POINTER (getter_setter_pair_p->setter_cp, set_p);\n  ECMA_SET_NON_NULL_POINTER (value.getter_setter_pair_cp, getter_setter_pair_p);\n#else /* !ENABLED (JERRY_CPOINTER_32_BIT) */\n  ECMA_SET_POINTER (value.getter_setter_pair.getter_cp, get_p);\n  ECMA_SET_POINTER (value.getter_setter_pair.setter_cp, set_p);\n#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */\n\n  return ecma_create_property (object_p, name_p, type_and_flags, value, out_prop_p);\n}",
        "begin_line": 541,
        "end_line": 571,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_create_named_data_property#515",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_create_named_data_property (ecma_object_t *object_p, /**< object */                                  ecma_string_t *name_p, /**< property name */                                  uint8_t prop_attributes, /**< property attributes (See: ecma_property_flags_t) */                                  ecma_property_t **out_prop_p) /**< [out] the property is also returned                                                                 *         if this field is non-NULL */",
        "snippet": "ecma_property_value_t *\necma_create_named_data_property (ecma_object_t *object_p, /**< object */\n                                 ecma_string_t *name_p, /**< property name */\n                                 uint8_t prop_attributes, /**< property attributes (See: ecma_property_flags_t) */\n                                 ecma_property_t **out_prop_p) /**< [out] the property is also returned\n                                                                *         if this field is non-NULL */\n{\n  JERRY_ASSERT (object_p != NULL && name_p != NULL);\n  JERRY_ASSERT (ecma_is_lexical_environment (object_p)\n                || !ecma_op_object_is_fast_array (object_p));\n  JERRY_ASSERT (ecma_find_named_property (object_p, name_p) == NULL);\n  JERRY_ASSERT ((prop_attributes & ~ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE) == 0);\n\n  uint8_t type_and_flags = ECMA_PROPERTY_TYPE_NAMEDDATA | prop_attributes;\n\n  ecma_property_value_t value;\n  value.value = ECMA_VALUE_UNDEFINED;\n\n  return ecma_create_property (object_p, name_p, type_and_flags, value, out_prop_p);\n}",
        "begin_line": 515,
        "end_line": 534,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_create_object#73",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_create_object (ecma_object_t *prototype_object_p, /**< pointer to prototybe of the object (or NULL) */                     size_t ext_object_size, /**< size of extended objects */                     ecma_object_type_t type) /**< object type */",
        "snippet": "ecma_object_t *\necma_create_object (ecma_object_t *prototype_object_p, /**< pointer to prototybe of the object (or NULL) */\n                    size_t ext_object_size, /**< size of extended objects */\n                    ecma_object_type_t type) /**< object type */\n{\n  ecma_object_t *new_object_p;\n\n  if (ext_object_size > 0)\n  {\n    new_object_p = (ecma_object_t *) ecma_alloc_extended_object (ext_object_size);\n  }\n  else\n  {\n    new_object_p = ecma_alloc_object ();\n  }\n\n  new_object_p->type_flags_refs = (uint16_t) (type | ECMA_OBJECT_FLAG_EXTENSIBLE);\n\n  ecma_init_gc_info (new_object_p);\n\n  new_object_p->u1.property_list_cp = JMEM_CP_NULL;\n\n  ECMA_SET_POINTER (new_object_p->u2.prototype_cp, prototype_object_p);\n\n  return new_object_p;\n}",
        "begin_line": 73,
        "end_line": 98,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_create_object_lex_env#137",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_create_object_lex_env (ecma_object_t *outer_lexical_environment_p, /**< outer lexical environment */                             ecma_object_t *binding_obj_p, /**< binding object */                             ecma_lexical_environment_type_t type) /**< type of the new lexical environment */",
        "snippet": "ecma_object_t *\necma_create_object_lex_env (ecma_object_t *outer_lexical_environment_p, /**< outer lexical environment */\n                            ecma_object_t *binding_obj_p, /**< binding object */\n                            ecma_lexical_environment_type_t type) /**< type of the new lexical environment */\n{\n#if ENABLED (JERRY_ES2015)\n  JERRY_ASSERT (type == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND\n                || type == ECMA_LEXICAL_ENVIRONMENT_HOME_OBJECT_BOUND);\n#else /* !ENABLED (JERRY_ES2015) */\n  JERRY_ASSERT (type == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n#endif /* ENABLED (JERRY_ES2015) */\n\n  JERRY_ASSERT (binding_obj_p != NULL\n                && !ecma_is_lexical_environment (binding_obj_p));\n\n  ecma_object_t *new_lexical_environment_p = ecma_alloc_object ();\n\n  new_lexical_environment_p->type_flags_refs = (uint16_t) (ECMA_OBJECT_FLAG_BUILT_IN_OR_LEXICAL_ENV | type);\n\n  ecma_init_gc_info (new_lexical_environment_p);\n\n  ECMA_SET_NON_NULL_POINTER (new_lexical_environment_p->u1.bound_object_cp,\n                             binding_obj_p);\n\n  ECMA_SET_POINTER (new_lexical_environment_p->u2.outer_reference_cp, outer_lexical_environment_p);\n\n  return new_lexical_environment_p;\n}",
        "begin_line": 137,
        "end_line": 164,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_create_property#375",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_create_property (ecma_object_t *object_p, /**< the object */                       ecma_string_t *name_p, /**< property name */                       uint8_t type_and_flags, /**< type and flags, see ecma_property_info_t */                       ecma_property_value_t value, /**< property value */                       ecma_property_t **out_prop_p) /**< [out] the property is also returned                                                      *         if this field is non-NULL */",
        "snippet": "static ecma_property_value_t *\necma_create_property (ecma_object_t *object_p, /**< the object */\n                      ecma_string_t *name_p, /**< property name */\n                      uint8_t type_and_flags, /**< type and flags, see ecma_property_info_t */\n                      ecma_property_value_t value, /**< property value */\n                      ecma_property_t **out_prop_p) /**< [out] the property is also returned\n                                                     *         if this field is non-NULL */\n{\n  JERRY_ASSERT (ECMA_PROPERTY_PAIR_ITEM_COUNT == 2);\n  JERRY_ASSERT (name_p != NULL);\n  JERRY_ASSERT (object_p != NULL);\n\n  jmem_cpointer_t *property_list_head_p = &object_p->u1.property_list_cp;\n\n  if (*property_list_head_p != ECMA_NULL_POINTER)\n  {\n    /* If the first entry is free (deleted), it is reused. */\n    ecma_property_header_t *first_property_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,\n                                                                          *property_list_head_p);\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n    bool has_hashmap = false;\n\n    if (first_property_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n    {\n      property_list_head_p = &first_property_p->next_property_cp;\n      first_property_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,\n                                                    *property_list_head_p);\n      has_hashmap = true;\n    }\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (first_property_p));\n\n    if (first_property_p->types[0] == ECMA_PROPERTY_TYPE_DELETED)\n    {\n      ecma_property_pair_t *first_property_pair_p = (ecma_property_pair_t *) first_property_p;\n\n      ecma_property_t name_type;\n      first_property_pair_p->names_cp[0] = ecma_string_to_property_name (name_p,\n                                                                         &name_type);\n      first_property_p->types[0] = (ecma_property_t) (type_and_flags | name_type);\n\n      ecma_property_t *property_p = first_property_p->types + 0;\n\n      JERRY_ASSERT (ECMA_PROPERTY_VALUE_PTR (property_p) == first_property_pair_p->values + 0);\n\n      if (out_prop_p != NULL)\n      {\n        *out_prop_p = property_p;\n      }\n\n      first_property_pair_p->values[0] = value;\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n      /* The property must be fully initialized before ecma_property_hashmap_insert\n       * is called, because the insert operation may reallocate the hashmap, and\n       * that triggers garbage collection which scans all properties of all objects.\n       * A not fully initialized but queued property may cause a crash. */\n\n      if (has_hashmap)\n      {\n        ecma_property_hashmap_insert (object_p,\n                                      name_p,\n                                      first_property_pair_p,\n                                      0);\n      }\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n      return first_property_pair_p->values + 0;\n    }\n  }\n\n  /* Otherwise we create a new property pair and use its second value. */\n  ecma_property_pair_t *first_property_pair_p = ecma_alloc_property_pair ();\n\n  /* Need to query property_list_head_p again and recheck the existennce\n   * of property hasmap, because ecma_alloc_property_pair may delete them. */\n  property_list_head_p = &object_p->u1.property_list_cp;\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n  bool has_hashmap = false;\n\n  if (*property_list_head_p != ECMA_NULL_POINTER)\n  {\n    ecma_property_header_t *first_property_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,\n                                                                          *property_list_head_p);\n\n    if (first_property_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n    {\n      property_list_head_p = &first_property_p->next_property_cp;\n      has_hashmap = true;\n    }\n  }\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n  /* Just copy the previous value (no need to decompress, compress). */\n  first_property_pair_p->header.next_property_cp = *property_list_head_p;\n  first_property_pair_p->header.types[0] = ECMA_PROPERTY_TYPE_DELETED;\n  first_property_pair_p->names_cp[0] = LIT_INTERNAL_MAGIC_STRING_DELETED;\n\n  ecma_property_t name_type;\n  first_property_pair_p->names_cp[1] = ecma_string_to_property_name (name_p,\n                                                                     &name_type);\n\n  first_property_pair_p->header.types[1] = (ecma_property_t) (type_and_flags | name_type);\n\n  ECMA_SET_NON_NULL_POINTER (*property_list_head_p, &first_property_pair_p->header);\n\n  ecma_property_t *property_p = first_property_pair_p->header.types + 1;\n\n  JERRY_ASSERT (ECMA_PROPERTY_VALUE_PTR (property_p) == first_property_pair_p->values + 1);\n\n  if (out_prop_p != NULL)\n  {\n    *out_prop_p = property_p;\n  }\n\n  first_property_pair_p->values[1] = value;\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n  /* See the comment before the other ecma_property_hashmap_insert above. */\n\n  if (has_hashmap)\n  {\n    ecma_property_hashmap_insert (object_p,\n                                  name_p,\n                                  first_property_pair_p,\n                                  1);\n  }\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n  return first_property_pair_p->values + 1;\n}",
        "begin_line": 375,
        "end_line": 507,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_find_named_property#579",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_find_named_property (ecma_object_t *obj_p, /**< object to find property in */                           ecma_string_t *name_p) /**< property's name */",
        "snippet": "ecma_property_t *\necma_find_named_property (ecma_object_t *obj_p, /**< object to find property in */\n                          ecma_string_t *name_p) /**< property's name */\n{\n  JERRY_ASSERT (obj_p != NULL);\n  JERRY_ASSERT (name_p != NULL);\n  JERRY_ASSERT (ecma_is_lexical_environment (obj_p)\n                || !ecma_op_object_is_fast_array (obj_p));\n\n  ecma_property_t *property_p = NULL;\n\n#if ENABLED (JERRY_LCACHE)\n  property_p = ecma_lcache_lookup (obj_p, name_p);\n  if (property_p != NULL)\n  {\n    return property_p;\n  }\n#endif /* ENABLED (JERRY_LCACHE) */\n\n  jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp;\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n  if (prop_iter_cp != JMEM_CP_NULL)\n  {\n    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,\n                                                                     prop_iter_cp);\n    if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n    {\n      jmem_cpointer_t property_real_name_cp;\n      property_p = ecma_property_hashmap_find ((ecma_property_hashmap_t *) prop_iter_p,\n                                               name_p,\n                                               &property_real_name_cp);\n#if ENABLED (JERRY_LCACHE)\n      if (property_p != NULL\n          && !ecma_is_property_lcached (property_p))\n      {\n        ecma_lcache_insert (obj_p, property_real_name_cp, property_p);\n      }\n#endif /* ENABLED (JERRY_LCACHE) */\n      return property_p;\n    }\n  }\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n  uint32_t steps = 0;\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n  jmem_cpointer_t property_name_cp = ECMA_NULL_POINTER;\n\n  if (ECMA_IS_DIRECT_STRING (name_p))\n  {\n    ecma_property_t prop_name_type = (ecma_property_t) ECMA_GET_DIRECT_STRING_TYPE (name_p);\n    property_name_cp = (jmem_cpointer_t) ECMA_GET_DIRECT_STRING_VALUE (name_p);\n\n    JERRY_ASSERT (prop_name_type > 0);\n\n    while (prop_iter_cp != JMEM_CP_NULL)\n    {\n      ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,\n                                                                       prop_iter_cp);\n\n      JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n      ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n      if (prop_pair_p->names_cp[0] == property_name_cp\n          && ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[0]) == prop_name_type)\n      {\n        JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (prop_iter_p->types[0]));\n\n        property_p = prop_iter_p->types + 0;\n        break;\n      }\n\n      if (prop_pair_p->names_cp[1] == property_name_cp\n          && ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[1]) == prop_name_type)\n      {\n        JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (prop_iter_p->types[1]));\n\n        property_p = prop_iter_p->types + 1;\n        break;\n      }\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n      steps++;\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n      prop_iter_cp = prop_iter_p->next_property_cp;\n    }\n  }\n  else\n  {\n    while (prop_iter_cp != JMEM_CP_NULL)\n    {\n      ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,\n                                                                       prop_iter_cp);\n\n      JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n      ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n      if (ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[0]) == ECMA_DIRECT_STRING_PTR)\n      {\n        property_name_cp = prop_pair_p->names_cp[0];\n        ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, property_name_cp);\n\n        if (ecma_compare_ecma_non_direct_strings (name_p, prop_name_p))\n        {\n          property_p = prop_iter_p->types + 0;\n          break;\n        }\n      }\n\n      if (ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[1]) == ECMA_DIRECT_STRING_PTR)\n      {\n        property_name_cp = prop_pair_p->names_cp[1];\n        ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, property_name_cp);\n\n        if (ecma_compare_ecma_non_direct_strings (name_p, prop_name_p))\n        {\n          property_p = prop_iter_p->types + 1;\n          break;\n        }\n      }\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n      steps++;\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n      prop_iter_cp = prop_iter_p->next_property_cp;\n    }\n  }\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n  if (steps >= (ECMA_PROPERTY_HASMAP_MINIMUM_SIZE / 2))\n  {\n    ecma_property_hashmap_create (obj_p);\n  }\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n#if ENABLED (JERRY_LCACHE)\n  if (property_p != NULL\n      && !ecma_is_property_lcached (property_p))\n  {\n    ecma_lcache_insert (obj_p, property_name_cp, property_p);\n  }\n#endif /* ENABLED (JERRY_LCACHE) */\n\n  return property_p;\n}",
        "begin_line": 579,
        "end_line": 726,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_free_property#757",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_free_property (ecma_object_t *object_p, /**< object the property belongs to */                     jmem_cpointer_t name_cp, /**< name of the property or ECMA_NULL_POINTER */                     ecma_property_t *property_p) /**< property */",
        "snippet": "void\necma_free_property (ecma_object_t *object_p, /**< object the property belongs to */\n                    jmem_cpointer_t name_cp, /**< name of the property or ECMA_NULL_POINTER */\n                    ecma_property_t *property_p) /**< property */\n{\n  JERRY_ASSERT (object_p != NULL && property_p != NULL);\n\n  switch (ECMA_PROPERTY_GET_TYPE (*property_p))\n  {\n    case ECMA_PROPERTY_TYPE_NAMEDDATA:\n    {\n      ecma_free_value_if_not_object (ECMA_PROPERTY_VALUE_PTR (property_p)->value);\n      break;\n    }\n    case ECMA_PROPERTY_TYPE_NAMEDACCESSOR:\n    {\n#if ENABLED (JERRY_CPOINTER_32_BIT)\n      ecma_getter_setter_pointers_t *getter_setter_pair_p;\n      getter_setter_pair_p = ECMA_GET_NON_NULL_POINTER (ecma_getter_setter_pointers_t,\n                                                        ECMA_PROPERTY_VALUE_PTR (property_p)->getter_setter_pair_cp);\n      jmem_pools_free (getter_setter_pair_p, sizeof (ecma_getter_setter_pointers_t));\n#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */\n      break;\n    }\n    default:\n    {\n      JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_INTERNAL);\n\n      /* Must be a native pointer. */\n      JERRY_ASSERT (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_MAGIC\n                    && name_cp >= LIT_FIRST_INTERNAL_MAGIC_STRING);\n      break;\n    }\n  }\n\n#if ENABLED (JERRY_LCACHE)\n  if (ecma_is_property_lcached (property_p))\n  {\n    ecma_lcache_invalidate (object_p, name_cp, property_p);\n  }\n#endif /* ENABLED (JERRY_LCACHE) */\n\n  if (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_PTR)\n  {\n    ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, name_cp);\n    ecma_deref_ecma_string (prop_name_p);\n  }\n}",
        "begin_line": 757,
        "end_line": 804,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_get_named_accessor_property#974",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_get_named_accessor_property (const ecma_property_value_t *prop_value_p) /**< property value reference */",
        "snippet": "ecma_getter_setter_pointers_t *\necma_get_named_accessor_property (const ecma_property_value_t *prop_value_p) /**< property value reference */\n{\n#if ENABLED (JERRY_CPOINTER_32_BIT)\n  return ECMA_GET_NON_NULL_POINTER (ecma_getter_setter_pointers_t, prop_value_p->getter_setter_pair_cp);\n#else /* !ENABLED (JERRY_CPOINTER_32_BIT) */\n  return (ecma_getter_setter_pointers_t *) &prop_value_p->getter_setter_pair;\n#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */\n}",
        "begin_line": 974,
        "end_line": 982,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_make_empty_property_descriptor#1176",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_make_empty_property_descriptor (void)",
        "snippet": "ecma_property_descriptor_t\necma_make_empty_property_descriptor (void)\n{\n  ecma_property_descriptor_t prop_desc;\n\n  prop_desc.flags = 0;\n  prop_desc.value = ECMA_VALUE_UNDEFINED;\n  prop_desc.get_p = NULL;\n  prop_desc.set_p = NULL;\n\n  return prop_desc;\n}",
        "begin_line": 1176,
        "end_line": 1187,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_op_ordinary_object_set_extensible#185",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_op_ordinary_object_set_extensible (ecma_object_t *object_p) /**< object */",
        "snippet": "inline void\necma_op_ordinary_object_set_extensible (ecma_object_t *object_p) /**< object */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (!ecma_is_lexical_environment (object_p));\n\n  object_p->type_flags_refs = (uint16_t) (object_p->type_flags_refs | ECMA_OBJECT_FLAG_EXTENSIBLE);\n}",
        "begin_line": 185,
        "end_line": 192,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_set_object_is_builtin#226",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_set_object_is_builtin (ecma_object_t *object_p) /**< object */",
        "snippet": "inline void\necma_set_object_is_builtin (ecma_object_t *object_p) /**< object */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (!(object_p->type_flags_refs & ECMA_OBJECT_FLAG_BUILT_IN_OR_LEXICAL_ENV));\n  JERRY_ASSERT ((object_p->type_flags_refs & ECMA_OBJECT_TYPE_MASK) < ECMA_LEXICAL_ENVIRONMENT_TYPE_START);\n\n  object_p->type_flags_refs = (uint16_t) (object_p->type_flags_refs | ECMA_OBJECT_FLAG_BUILT_IN_OR_LEXICAL_ENV);\n}",
        "begin_line": 226,
        "end_line": 234,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-init-finalize.ecma_init#40",
        "src_path": "jerry-core/ecma/base/ecma-init-finalize.c",
        "class_name": "jerry-core.ecma.base.ecma-init-finalize",
        "signature": "jerry-core.ecma.base.ecma-init-finalize.ecma_init (void)",
        "snippet": "void\necma_init (void)\n{\n#if (JERRY_GC_MARK_LIMIT != 0)\n  JERRY_CONTEXT (ecma_gc_mark_recursion_limit) = JERRY_GC_MARK_LIMIT;\n#endif /* (JERRY_GC_MARK_LIMIT != 0) */\n\n  ecma_init_global_environment ();\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n  JERRY_CONTEXT (ecma_prop_hashmap_alloc_state) = ECMA_PROP_HASHMAP_ALLOC_ON;\n  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_HIGH_PRESSURE_GC;\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n#if (JERRY_STACK_LIMIT != 0)\n  volatile int sp;\n  JERRY_CONTEXT (stack_base) = (uintptr_t) &sp;\n#endif /* (JERRY_STACK_LIMIT != 0) */\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROMISE)\n  ecma_job_queue_init ();\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */\n\n#if ENABLED (JERRY_ES2015)\n  JERRY_CONTEXT (current_new_target) = NULL;\n  JERRY_CONTEXT (current_function_obj_p) = NULL;\n#endif /* ENABLED (JERRY_ES2015) */\n}",
        "begin_line": 40,
        "end_line": 67,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-literal-storage.ecma_find_or_create_literal_number#204",
        "src_path": "jerry-core/ecma/base/ecma-literal-storage.c",
        "class_name": "jerry-core.ecma.base.ecma-literal-storage",
        "signature": "jerry-core.ecma.base.ecma-literal-storage.ecma_find_or_create_literal_number (ecma_number_t number_arg) /**< number to be searched */",
        "snippet": "ecma_value_t\necma_find_or_create_literal_number (ecma_number_t number_arg) /**< number to be searched */\n{\n  ecma_value_t num = ecma_make_number_value (number_arg);\n\n  if (ecma_is_value_integer_number (num))\n  {\n    return num;\n  }\n\n  JERRY_ASSERT (ecma_is_value_float_number (num));\n\n  jmem_cpointer_t number_list_cp = JERRY_CONTEXT (number_list_first_cp);\n  jmem_cpointer_t *empty_cpointer_p = NULL;\n\n  while (number_list_cp != JMEM_CP_NULL)\n  {\n    ecma_number_storage_item_t *number_list_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_number_storage_item_t,\n                                                                              number_list_cp);\n\n    for (int i = 0; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)\n    {\n      if (number_list_p->values[i] == JMEM_CP_NULL)\n      {\n        if (empty_cpointer_p == NULL)\n        {\n          empty_cpointer_p = number_list_p->values + i;\n        }\n      }\n      else\n      {\n        ecma_number_t *number_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_number_t,\n                                                                number_list_p->values[i]);\n\n        if (*number_p == number_arg)\n        {\n          ecma_free_value (num);\n          return ecma_make_float_value (number_p);\n        }\n      }\n    }\n\n    number_list_cp = number_list_p->next_cp;\n  }\n\n  ecma_number_t *num_p = ecma_get_pointer_from_float_value (num);\n\n  jmem_cpointer_t result;\n  JMEM_CP_SET_NON_NULL_POINTER (result, num_p);\n\n  if (empty_cpointer_p != NULL)\n  {\n    *empty_cpointer_p = result;\n    return num;\n  }\n\n  ecma_number_storage_item_t *new_item_p;\n  new_item_p = (ecma_number_storage_item_t *) jmem_pools_alloc (sizeof (ecma_number_storage_item_t));\n\n  new_item_p->values[0] = result;\n  for (int i = 1; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)\n  {\n    new_item_p->values[i] = JMEM_CP_NULL;\n  }\n\n  new_item_p->next_cp = JERRY_CONTEXT (number_list_first_cp);\n  JMEM_CP_SET_NON_NULL_POINTER (JERRY_CONTEXT (number_list_first_cp), new_item_p);\n\n  return num;\n}",
        "begin_line": 204,
        "end_line": 273,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-literal-storage.ecma_find_or_create_literal_string#130",
        "src_path": "jerry-core/ecma/base/ecma-literal-storage.c",
        "class_name": "jerry-core.ecma.base.ecma-literal-storage",
        "signature": "jerry-core.ecma.base.ecma-literal-storage.ecma_find_or_create_literal_string (const lit_utf8_byte_t *chars_p, /**< string to be searched */                                     lit_utf8_size_t size) /**< size of the string */",
        "snippet": "ecma_value_t\necma_find_or_create_literal_string (const lit_utf8_byte_t *chars_p, /**< string to be searched */\n                                    lit_utf8_size_t size) /**< size of the string */\n{\n  ecma_string_t *string_p = ecma_new_ecma_string_from_utf8 (chars_p, size);\n\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    return ecma_make_string_value (string_p);\n  }\n\n  jmem_cpointer_t string_list_cp = JERRY_CONTEXT (string_list_first_cp);\n  jmem_cpointer_t *empty_cpointer_p = NULL;\n\n  while (string_list_cp != JMEM_CP_NULL)\n  {\n    ecma_lit_storage_item_t *string_list_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_lit_storage_item_t, string_list_cp);\n\n    for (int i = 0; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)\n    {\n      if (string_list_p->values[i] == JMEM_CP_NULL)\n      {\n        if (empty_cpointer_p == NULL)\n        {\n          empty_cpointer_p = string_list_p->values + i;\n        }\n      }\n      else\n      {\n        ecma_string_t *value_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_string_t,\n                                                               string_list_p->values[i]);\n\n        if (ecma_compare_ecma_strings (string_p, value_p))\n        {\n          /* Return with string if found in the list. */\n          ecma_deref_ecma_string (string_p);\n          return ecma_make_string_value (value_p);\n        }\n      }\n    }\n\n    string_list_cp = string_list_p->next_cp;\n  }\n\n  ECMA_SET_STRING_AS_STATIC (string_p);\n  jmem_cpointer_t result;\n  JMEM_CP_SET_NON_NULL_POINTER (result, string_p);\n\n  if (empty_cpointer_p != NULL)\n  {\n    *empty_cpointer_p = result;\n    return ecma_make_string_value (string_p);\n  }\n\n  ecma_lit_storage_item_t *new_item_p;\n  new_item_p = (ecma_lit_storage_item_t *) jmem_pools_alloc (sizeof (ecma_lit_storage_item_t));\n\n  new_item_p->values[0] = result;\n  for (int i = 1; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)\n  {\n    new_item_p->values[i] = JMEM_CP_NULL;\n  }\n\n  new_item_p->next_cp = JERRY_CONTEXT (string_list_first_cp);\n  JMEM_CP_SET_NON_NULL_POINTER (JERRY_CONTEXT (string_list_first_cp), new_item_p);\n\n  return ecma_make_string_value (string_p);\n}",
        "begin_line": 130,
        "end_line": 197,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-function-prototype.ecma_builtin_function_prototype_dispatch_routine#385",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-function-prototype.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-function-prototype",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-function-prototype.ecma_builtin_function_prototype_dispatch_routine (uint16_t builtin_routine_id, /**< built-in wide routine                                                                                 *   identifier */                                                   ecma_value_t this_arg, /**< 'this' argument value */                                                   const ecma_value_t arguments_list_p[], /**< list of arguments                                                                                         *   passed to routine */                                                   ecma_length_t arguments_number) /**< length of arguments' list */",
        "snippet": "ecma_value_t\necma_builtin_function_prototype_dispatch_routine (uint16_t builtin_routine_id, /**< built-in wide routine\n                                                                                *   identifier */\n                                                  ecma_value_t this_arg, /**< 'this' argument value */\n                                                  const ecma_value_t arguments_list_p[], /**< list of arguments\n                                                                                        *   passed to routine */\n                                                  ecma_length_t arguments_number) /**< length of arguments' list */\n{\n  if (!ecma_op_is_callable (this_arg))\n  {\n#if ENABLED (JERRY_ES2015)\n    if (JERRY_UNLIKELY (builtin_routine_id == ECMA_FUNCTION_PROTOTYPE_SYMBOL_HAS_INSTANCE))\n    {\n      return ECMA_VALUE_FALSE;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Argument 'this' is not a function.\"));\n  }\n\n  ecma_object_t *func_obj_p = ecma_get_object_from_value (this_arg);\n\n  switch (builtin_routine_id)\n  {\n    case ECMA_FUNCTION_PROTOTYPE_TO_STRING:\n    {\n      return ecma_builtin_function_prototype_object_to_string ();\n    }\n    case ECMA_FUNCTION_PROTOTYPE_APPLY:\n    {\n      return ecma_builtin_function_prototype_object_apply (func_obj_p,\n                                                           arguments_list_p[0],\n                                                           arguments_list_p[1]);\n    }\n    case ECMA_FUNCTION_PROTOTYPE_CALL:\n    {\n      return ecma_builtin_function_prototype_object_call (func_obj_p, arguments_list_p, arguments_number);\n    }\n    case ECMA_FUNCTION_PROTOTYPE_BIND:\n    {\n      return ecma_builtin_function_prototype_object_bind (func_obj_p, arguments_list_p, arguments_number);\n    }\n#if ENABLED (JERRY_ES2015)\n    case ECMA_FUNCTION_PROTOTYPE_SYMBOL_HAS_INSTANCE:\n    {\n      return ecma_op_object_has_instance (func_obj_p, arguments_list_p[0]);\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    default:\n    {\n      JERRY_UNREACHABLE ();\n    }\n  }\n}",
        "begin_line": 385,
        "end_line": 438,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-function-prototype.ecma_builtin_function_prototype_object_to_string#82",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-function-prototype.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-function-prototype",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-function-prototype.ecma_builtin_function_prototype_object_to_string (void)",
        "snippet": "static ecma_value_t\necma_builtin_function_prototype_object_to_string (void)\n{\n  return ecma_make_magic_string_value (LIT_MAGIC_STRING__FUNCTION_TO_STRING);\n}",
        "begin_line": 82,
        "end_line": 86,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-global.ecma_builtin_global_dispatch_routine#777",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-global.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-global",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-global.ecma_builtin_global_dispatch_routine (uint16_t builtin_routine_id, /**< built-in wide routine identifier */                                       ecma_value_t this_arg, /**< 'this' argument value */                                       const ecma_value_t arguments_list_p[], /**< list of arguments                                                                               *   passed to routine */                                       ecma_length_t arguments_number) /**< length of arguments' list */",
        "snippet": "ecma_value_t\necma_builtin_global_dispatch_routine (uint16_t builtin_routine_id, /**< built-in wide routine identifier */\n                                      ecma_value_t this_arg, /**< 'this' argument value */\n                                      const ecma_value_t arguments_list_p[], /**< list of arguments\n                                                                              *   passed to routine */\n                                      ecma_length_t arguments_number) /**< length of arguments' list */\n{\n  JERRY_UNUSED (this_arg);\n  JERRY_UNUSED (arguments_list_p);\n  JERRY_UNUSED (arguments_number);\n\n  ecma_value_t routine_arg_1 = arguments_list_p[0];\n\n  if (builtin_routine_id == ECMA_GLOBAL_EVAL)\n  {\n    return ecma_builtin_global_object_eval (routine_arg_1);\n  }\n\n  if (builtin_routine_id <= ECMA_GLOBAL_IS_FINITE)\n  {\n    ecma_number_t arg_num;\n\n    routine_arg_1 = ecma_get_number (routine_arg_1, &arg_num);\n\n    if (!ecma_is_value_empty (routine_arg_1))\n    {\n      return routine_arg_1;\n    }\n\n    if (builtin_routine_id == ECMA_GLOBAL_IS_NAN)\n    {\n      return ecma_builtin_global_object_is_nan (arg_num);\n    }\n\n    JERRY_ASSERT (builtin_routine_id == ECMA_GLOBAL_IS_FINITE);\n\n    return ecma_builtin_global_object_is_finite (arg_num);\n  }\n\n  ecma_string_t *str_p = ecma_op_to_string (routine_arg_1);\n\n  if (JERRY_UNLIKELY (str_p == NULL))\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_value_t ret_value;\n\n  if (builtin_routine_id <= ECMA_GLOBAL_PARSE_FLOAT)\n  {\n    ECMA_STRING_TO_UTF8_STRING (str_p, string_buff, string_buff_size);\n\n    if (builtin_routine_id == ECMA_GLOBAL_PARSE_INT)\n    {\n      ret_value = ecma_number_parse_int (string_buff,\n                                         string_buff_size,\n                                         arguments_list_p[1]);\n    }\n    else\n    {\n      JERRY_ASSERT (builtin_routine_id == ECMA_GLOBAL_PARSE_FLOAT);\n      ret_value = ecma_number_parse_float (string_buff,\n                                           string_buff_size);\n    }\n\n    ECMA_FINALIZE_UTF8_STRING (string_buff, string_buff_size);\n    ecma_deref_ecma_string (str_p);\n    return ret_value;\n  }\n\n  lit_utf8_size_t input_size = ecma_string_get_size (str_p);\n\n  JMEM_DEFINE_LOCAL_ARRAY (input_start_p,\n                           input_size + 1,\n                           lit_utf8_byte_t);\n\n  ecma_string_to_utf8_bytes (str_p, input_start_p, input_size);\n\n  input_start_p[input_size] = LIT_BYTE_NULL;\n\n  switch (builtin_routine_id)\n  {\n#if ENABLED (JERRY_BUILTIN_ANNEXB)\n    case ECMA_GLOBAL_ESCAPE:\n    {\n      ret_value = ecma_builtin_global_object_escape (input_start_p, input_size);\n      break;\n    }\n    case ECMA_GLOBAL_UNESCAPE:\n    {\n      ret_value = ecma_builtin_global_object_unescape (input_start_p, input_size);\n      break;\n    }\n#endif /* ENABLED (JERRY_BUILTIN_ANNEXB) */\n    case ECMA_GLOBAL_DECODE_URI:\n    case ECMA_GLOBAL_DECODE_URI_COMPONENT:\n    {\n      const uint8_t *uri_set = (builtin_routine_id == ECMA_GLOBAL_DECODE_URI ? unescaped_uri_set\n                                                                             : unescaped_uri_component_set);\n\n      ret_value = ecma_builtin_global_object_decode_uri_helper (input_start_p, input_size, uri_set);\n      break;\n    }\n    default:\n    {\n      JERRY_ASSERT (builtin_routine_id == ECMA_GLOBAL_ENCODE_URI\n                    || builtin_routine_id == ECMA_GLOBAL_ENCODE_URI_COMPONENT);\n\n      const uint8_t *uri_set = (builtin_routine_id == ECMA_GLOBAL_ENCODE_URI ? unescaped_uri_set\n                                                                             : unescaped_uri_component_set);\n\n      ret_value = ecma_builtin_global_object_encode_uri_helper (input_start_p, input_size, uri_set);\n      break;\n    }\n  }\n\n  JMEM_FINALIZE_LOCAL_ARRAY (input_start_p);\n\n  ecma_deref_ecma_string (str_p);\n  return ret_value;\n}",
        "begin_line": 777,
        "end_line": 897,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-global.ecma_builtin_global_object_eval#85",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-global.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-global",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-global.ecma_builtin_global_object_eval (ecma_value_t x) /**< routine's first argument */",
        "snippet": "static ecma_value_t\necma_builtin_global_object_eval (ecma_value_t x) /**< routine's first argument */\n{\n  if (JERRY_UNLIKELY (!ecma_is_value_string (x)))\n  {\n    /* step 1 */\n    return ecma_copy_value (x);\n  }\n\n  uint32_t parse_opts = vm_is_direct_eval_form_call () ? ECMA_PARSE_DIRECT_EVAL : ECMA_PARSE_NO_OPTS;\n\n  /* See also: ECMA-262 v5, 10.1.1 */\n  if (parse_opts && vm_is_strict_mode ())\n  {\n    JERRY_ASSERT (parse_opts & ECMA_PARSE_DIRECT_EVAL);\n    parse_opts |= ECMA_PARSE_STRICT_MODE;\n  }\n\n#if ENABLED (JERRY_ES2015)\n  if (vm_is_direct_eval_form_call ())\n  {\n    parse_opts |= ECMA_GET_LOCAL_PARSE_OPTS ();\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  /* steps 2 to 8 */\n  return ecma_op_eval (ecma_get_string_from_value (x), parse_opts);\n}",
        "begin_line": 85,
        "end_line": 112,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-helpers.ecma_builtin_helper_def_prop#818",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-helpers.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-helpers",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-helpers.ecma_builtin_helper_def_prop (ecma_object_t *obj_p, /**< object */                               ecma_string_t *name_p, /**< name string */                               ecma_value_t value, /**< value */                               uint32_t opts) /**< any combination of ecma_property_flag_t bits                                               *   with the optional ECMA_IS_THROW flag */",
        "snippet": "ecma_value_t\necma_builtin_helper_def_prop (ecma_object_t *obj_p, /**< object */\n                              ecma_string_t *name_p, /**< name string */\n                              ecma_value_t value, /**< value */\n                              uint32_t opts) /**< any combination of ecma_property_flag_t bits\n                                              *   with the optional ECMA_IS_THROW flag */\n{\n  ecma_property_descriptor_t prop_desc;\n\n  prop_desc.flags = (uint16_t) (ECMA_NAME_DATA_PROPERTY_DESCRIPTOR_BITS | opts);\n\n  prop_desc.value = value;\n\n  return ecma_op_object_define_own_property (obj_p,\n                                             name_p,\n                                             &prop_desc);\n}",
        "begin_line": 818,
        "end_line": 834,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-object-prototype.ecma_builtin_object_prototype_dispatch_routine#233",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-object-prototype.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-object-prototype",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-object-prototype.ecma_builtin_object_prototype_dispatch_routine (uint16_t builtin_routine_id, /**< built-in wide routine                                                                               *   identifier */                                                 ecma_value_t this_arg, /**< 'this' argument value */                                                 const ecma_value_t arguments_list_p[], /**< list of arguments                                                                                       *   passed to routine */                                                 ecma_length_t arguments_number) /**< length of arguments' list */",
        "snippet": "ecma_value_t\necma_builtin_object_prototype_dispatch_routine (uint16_t builtin_routine_id, /**< built-in wide routine\n                                                                              *   identifier */\n                                                ecma_value_t this_arg, /**< 'this' argument value */\n                                                const ecma_value_t arguments_list_p[], /**< list of arguments\n                                                                                      *   passed to routine */\n                                                ecma_length_t arguments_number) /**< length of arguments' list */\n{\n  JERRY_UNUSED (arguments_number);\n\n  /* no specialization */\n  if (builtin_routine_id <= ECMA_OBJECT_PROTOTYPE_VALUE_OF)\n  {\n    if (builtin_routine_id == ECMA_OBJECT_PROTOTYPE_TO_STRING)\n    {\n      return ecma_builtin_object_prototype_object_to_string (this_arg);\n    }\n\n    JERRY_ASSERT (builtin_routine_id <= ECMA_OBJECT_PROTOTYPE_VALUE_OF);\n\n    return ecma_builtin_object_prototype_object_value_of (this_arg);\n  }\n\n  if (builtin_routine_id <= ECMA_OBJECT_PROTOTYPE_IS_PROTOTYPE_OF)\n  {\n    if (builtin_routine_id == ECMA_OBJECT_PROTOTYPE_IS_PROTOTYPE_OF)\n    {\n      /* 15.2.4.6.1. */\n      if (!ecma_is_value_object (arguments_list_p[0]))\n      {\n        return ECMA_VALUE_FALSE;\n      }\n    }\n\n    ecma_value_t to_object = ecma_op_to_object (this_arg);\n\n    if (ECMA_IS_VALUE_ERROR (to_object))\n    {\n      return to_object;\n    }\n\n    ecma_object_t *obj_p = ecma_get_object_from_value (to_object);\n\n    ecma_value_t ret_value;\n\n    if (builtin_routine_id == ECMA_OBJECT_PROTOTYPE_IS_PROTOTYPE_OF)\n    {\n      ret_value = ecma_builtin_object_prototype_object_is_prototype_of (obj_p, arguments_list_p[0]);\n    }\n\n#if ENABLED (JERRY_ES2015)\n    else if (builtin_routine_id == ECMA_OBJECT_PROTOTYPE_GET_PROTO)\n    {\n      ret_value = ecma_builtin_object_object_get_prototype_of (obj_p);\n    }\n#endif /* ENABLED (JERRY_ES2015)*/\n\n    else\n    {\n      ret_value = ecma_builtin_object_prototype_object_to_locale_string (obj_p);\n    }\n\n    ecma_deref_object (obj_p);\n\n    return ret_value;\n  }\n\n  JERRY_ASSERT (builtin_routine_id >= ECMA_OBJECT_PROTOTYPE_HAS_OWN_PROPERTY);\n\n#if ENABLED (JERRY_ES2015)\n  if (builtin_routine_id == ECMA_OBJECT_PROTOTYPE_SET_PROTO)\n  {\n    return ecma_builtin_object_object_set_proto (this_arg, arguments_list_p[0]);\n  }\n#endif /* ENABLED (JERRY_ES2015)*/\n\n  ecma_string_t *prop_name_p = ecma_op_to_prop_name (arguments_list_p[0]);\n\n  if (prop_name_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_value_t to_object = ecma_op_to_object (this_arg);\n\n  if (ECMA_IS_VALUE_ERROR (to_object))\n  {\n    ecma_deref_ecma_string (prop_name_p);\n    return to_object;\n  }\n\n  ecma_object_t *obj_p = ecma_get_object_from_value (to_object);\n\n  ecma_value_t ret_value;\n\n  if (builtin_routine_id == ECMA_OBJECT_PROTOTYPE_HAS_OWN_PROPERTY)\n  {\n    ret_value = ecma_builtin_object_prototype_object_has_own_property (obj_p, prop_name_p);\n  }\n  else\n  {\n    ret_value = ecma_builtin_object_prototype_object_property_is_enumerable (obj_p, prop_name_p);\n  }\n\n  ecma_deref_ecma_string (prop_name_p);\n  ecma_deref_object (obj_p);\n\n  return ret_value;\n}",
        "begin_line": 233,
        "end_line": 341,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-object-prototype.ecma_builtin_object_prototype_object_to_locale_string#110",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-object-prototype.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-object-prototype",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-object-prototype.ecma_builtin_object_prototype_object_to_locale_string (ecma_object_t *obj_p) /**< this argument */",
        "snippet": "static ecma_value_t\necma_builtin_object_prototype_object_to_locale_string (ecma_object_t *obj_p) /**< this argument */\n{\n  /* 2. */\n  ecma_value_t to_string_val = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_TO_STRING_UL);\n\n  if (ECMA_IS_VALUE_ERROR (to_string_val))\n  {\n    return to_string_val;\n  }\n\n  /* 3. */\n  if (!ecma_op_is_callable (to_string_val))\n  {\n    ecma_free_value (to_string_val);\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"'toString is missing or not a function.'\"));\n  }\n\n  /* 4. */\n  ecma_object_t *to_string_func_obj_p = ecma_get_object_from_value (to_string_val);\n  ecma_value_t ret_value = ecma_op_function_call (to_string_func_obj_p, ecma_make_object_value (obj_p), NULL, 0);\n\n  ecma_deref_object (to_string_func_obj_p);\n\n  return ret_value;\n}",
        "begin_line": 110,
        "end_line": 135,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_dispatch_call#1126",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_dispatch_call (ecma_object_t *obj_p, /**< built-in object */                             ecma_value_t this_arg_value, /**< 'this' argument value */                             const ecma_value_t *arguments_list_p, /**< arguments list */                             ecma_length_t arguments_list_len) /**< arguments list length */",
        "snippet": "ecma_value_t\necma_builtin_dispatch_call (ecma_object_t *obj_p, /**< built-in object */\n                            ecma_value_t this_arg_value, /**< 'this' argument value */\n                            const ecma_value_t *arguments_list_p, /**< arguments list */\n                            ecma_length_t arguments_list_len) /**< arguments list length */\n{\n  JERRY_ASSERT (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_FUNCTION);\n  JERRY_ASSERT (ecma_get_object_is_builtin (obj_p));\n\n  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;\n\n  if (ecma_builtin_function_is_routine (obj_p))\n  {\n    return ecma_builtin_dispatch_routine (ext_obj_p,\n                                          this_arg_value,\n                                          arguments_list_p,\n                                          arguments_list_len);\n  }\n\n  ecma_builtin_id_t builtin_object_id = ext_obj_p->u.built_in.id;\n  JERRY_ASSERT (builtin_object_id < sizeof (ecma_builtin_call_functions) / sizeof (ecma_builtin_dispatch_call_t));\n  return ecma_builtin_call_functions[builtin_object_id] (arguments_list_p, arguments_list_len);\n}",
        "begin_line": 1126,
        "end_line": 1148,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_dispatch_construct#1155",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_dispatch_construct (ecma_object_t *obj_p, /**< built-in object */                                  ecma_object_t *new_target_p, /**< new target */                                  const ecma_value_t *arguments_list_p, /**< arguments list */                                  ecma_length_t arguments_list_len) /**< arguments list length */",
        "snippet": "ecma_value_t\necma_builtin_dispatch_construct (ecma_object_t *obj_p, /**< built-in object */\n                                 ecma_object_t *new_target_p, /**< new target */\n                                 const ecma_value_t *arguments_list_p, /**< arguments list */\n                                 ecma_length_t arguments_list_len) /**< arguments list length */\n{\n  JERRY_ASSERT (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_FUNCTION);\n  JERRY_ASSERT (ecma_get_object_is_builtin (obj_p));\n\n  if (ecma_builtin_function_is_routine (obj_p))\n  {\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Built-in routines have no constructor.\"));\n  }\n\n  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;\n  ecma_builtin_id_t builtin_object_id = ext_obj_p->u.built_in.id;\n  JERRY_ASSERT (builtin_object_id < sizeof (ecma_builtin_construct_functions) / sizeof (ecma_builtin_dispatch_call_t));\n\n#if ENABLED (JERRY_ES2015)\n  ecma_object_t *old_new_target = JERRY_CONTEXT (current_new_target);\n  JERRY_CONTEXT (current_new_target) = new_target_p;\n#else /* !ENABLED (JERRY_ES2015) */\n  JERRY_UNUSED (new_target_p);\n#endif /* ENABLED (JERRY_ES2015) */\n\n  ecma_value_t ret_value = ecma_builtin_construct_functions[builtin_object_id] (arguments_list_p, arguments_list_len);\n\n#if ENABLED (JERRY_ES2015)\n  JERRY_CONTEXT (current_new_target) = old_new_target;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  return ret_value;\n}",
        "begin_line": 1155,
        "end_line": 1187,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_dispatch_routine#1082",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_dispatch_routine (ecma_extended_object_t *func_obj_p, /**< builtin object */                                ecma_value_t this_arg_value, /**< 'this' argument value */                                const ecma_value_t *arguments_list_p, /**< list of arguments passed to routine */                                ecma_length_t arguments_list_len) /**< length of arguments' list */",
        "snippet": "static ecma_value_t\necma_builtin_dispatch_routine (ecma_extended_object_t *func_obj_p, /**< builtin object */\n                               ecma_value_t this_arg_value, /**< 'this' argument value */\n                               const ecma_value_t *arguments_list_p, /**< list of arguments passed to routine */\n                               ecma_length_t arguments_list_len) /**< length of arguments' list */\n{\n  JERRY_ASSERT (ecma_builtin_function_is_routine ((ecma_object_t *) func_obj_p));\n\n  ecma_value_t padded_arguments_list_p[3] = { ECMA_VALUE_UNDEFINED, ECMA_VALUE_UNDEFINED, ECMA_VALUE_UNDEFINED };\n\n  if (arguments_list_len <= 2)\n  {\n    switch (arguments_list_len)\n    {\n      case 2:\n      {\n        padded_arguments_list_p[1] = arguments_list_p[1];\n        /* FALLTHRU */\n      }\n      case 1:\n      {\n        padded_arguments_list_p[0] = arguments_list_p[0];\n        break;\n      }\n      default:\n      {\n        JERRY_ASSERT (arguments_list_len == 0);\n      }\n    }\n\n    arguments_list_p = padded_arguments_list_p;\n  }\n\n  return ecma_builtin_routines[func_obj_p->u.built_in.id] (func_obj_p->u.built_in.routine_id,\n                                                           this_arg_value,\n                                                           arguments_list_p,\n                                                           arguments_list_len);\n}",
        "begin_line": 1082,
        "end_line": 1119,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get#293",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get (ecma_builtin_id_t builtin_id) /**< id of built-in to check on */",
        "snippet": "ecma_object_t *\necma_builtin_get (ecma_builtin_id_t builtin_id) /**< id of built-in to check on */\n{\n  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_ID__COUNT);\n\n  if (JERRY_UNLIKELY (JERRY_CONTEXT (ecma_builtin_objects)[builtin_id] == JMEM_CP_NULL))\n  {\n    ecma_instantiate_builtin (builtin_id);\n  }\n\n  return ECMA_GET_NON_NULL_POINTER (ecma_object_t, JERRY_CONTEXT (ecma_builtin_objects)[builtin_id]);\n}",
        "begin_line": 293,
        "end_line": 304,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get_property_count#249",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get_property_count (ecma_builtin_id_t builtin_id) /**< built-in ID */",
        "snippet": "static size_t\necma_builtin_get_property_count (ecma_builtin_id_t builtin_id) /**< built-in ID */\n{\n  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_ID__COUNT);\n  const ecma_builtin_property_descriptor_t *property_list_p = ecma_builtin_property_list_references[builtin_id];\n\n  const ecma_builtin_property_descriptor_t *curr_property_p = property_list_p;\n\n  while (curr_property_p->magic_string_id != LIT_MAGIC_STRING__COUNT)\n  {\n    curr_property_p++;\n  }\n\n  return (size_t) (curr_property_p - property_list_p);\n}",
        "begin_line": 249,
        "end_line": 263,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_is#271",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_is (ecma_object_t *obj_p, /**< pointer to an object */                  ecma_builtin_id_t builtin_id) /**< id of built-in to check on */",
        "snippet": "bool\necma_builtin_is (ecma_object_t *obj_p, /**< pointer to an object */\n                 ecma_builtin_id_t builtin_id) /**< id of built-in to check on */\n{\n  JERRY_ASSERT (obj_p != NULL && !ecma_is_lexical_environment (obj_p));\n  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_ID__COUNT);\n\n  /* If a built-in object is not instantiated, its value is NULL,\n     hence it cannot be equal to a valid object. */\n  jmem_cpointer_t builtin_cp = JERRY_CONTEXT (ecma_builtin_objects)[builtin_id];\n\n  return (builtin_cp != JMEM_CP_NULL && (obj_p == ECMA_GET_NON_NULL_POINTER (ecma_object_t, builtin_cp)));\n}",
        "begin_line": 271,
        "end_line": 283,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_make_function_object_for_routine#554",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_make_function_object_for_routine (ecma_builtin_id_t builtin_id, /**< identifier of built-in object */                                                uint16_t routine_id, /**< builtin-wide identifier of the built-in                                                                      *   object's routine property */                                                uint16_t name_id, /**< magic string id of 'name' property */                                                uint8_t length_prop_value) /**< value of 'length' property */",
        "snippet": "static ecma_object_t *\necma_builtin_make_function_object_for_routine (ecma_builtin_id_t builtin_id, /**< identifier of built-in object */\n                                               uint16_t routine_id, /**< builtin-wide identifier of the built-in\n                                                                     *   object's routine property */\n                                               uint16_t name_id, /**< magic string id of 'name' property */\n                                               uint8_t length_prop_value) /**< value of 'length' property */\n{\n  JERRY_ASSERT (length_prop_value < (1 << ECMA_BUILT_IN_BITSET_SHIFT));\n\n  ecma_object_t *prototype_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_FUNCTION_PROTOTYPE);\n\n  size_t ext_object_size = sizeof (ecma_extended_object_t);\n\n  ecma_object_t *func_obj_p = ecma_create_object (prototype_obj_p,\n                                                  ext_object_size,\n                                                  ECMA_OBJECT_TYPE_FUNCTION);\n\n  ecma_set_object_is_builtin (func_obj_p);\n\n  JERRY_ASSERT (routine_id >= ECMA_BUILTIN_ID__COUNT);\n\n  ecma_extended_object_t *ext_func_obj_p = (ecma_extended_object_t *) func_obj_p;\n  ext_func_obj_p->u.built_in.id = (uint8_t) builtin_id;\n  ext_func_obj_p->u.built_in.routine_id = routine_id;\n  ext_func_obj_p->u.built_in.u.builtin_routine.name = name_id;\n  ext_func_obj_p->u.built_in.u.builtin_routine.bitset = 0;\n\n  ext_func_obj_p->u.built_in.length_and_bitset_size = length_prop_value;\n\n  return func_obj_p;\n}",
        "begin_line": 554,
        "end_line": 584,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_try_to_instantiate_property#681",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_try_to_instantiate_property (ecma_object_t *object_p, /**< object */                                           ecma_string_t *string_p) /**< property's name */",
        "snippet": "ecma_property_t *\necma_builtin_try_to_instantiate_property (ecma_object_t *object_p, /**< object */\n                                          ecma_string_t *string_p) /**< property's name */\n{\n  JERRY_ASSERT (ecma_get_object_is_builtin (object_p));\n\n  lit_magic_string_id_t magic_string_id = ecma_get_string_magic (string_p);\n\n#if ENABLED (JERRY_ES2015)\n  if (JERRY_UNLIKELY (ecma_prop_name_is_symbol (string_p)))\n  {\n    if (string_p->u.hash & ECMA_GLOBAL_SYMBOL_FLAG)\n    {\n      magic_string_id = (string_p->u.hash >> ECMA_GLOBAL_SYMBOL_SHIFT);\n    }\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  if (magic_string_id == LIT_MAGIC_STRING__COUNT)\n  {\n    return NULL;\n  }\n\n  ecma_built_in_props_t *built_in_props_p;\n  ecma_object_type_t object_type = ecma_get_object_type (object_p);\n  JERRY_ASSERT (object_type != ECMA_OBJECT_TYPE_FUNCTION || !ecma_builtin_function_is_routine (object_p));\n\n  if (object_type == ECMA_OBJECT_TYPE_CLASS || object_type == ECMA_OBJECT_TYPE_ARRAY)\n  {\n    built_in_props_p = &((ecma_extended_built_in_object_t *) object_p)->built_in;\n  }\n  else\n  {\n    built_in_props_p = &((ecma_extended_object_t *) object_p)->u.built_in;\n  }\n\n  ecma_builtin_id_t builtin_id = (ecma_builtin_id_t) built_in_props_p->id;\n\n  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_ID__COUNT);\n  JERRY_ASSERT (ecma_builtin_is (object_p, builtin_id));\n\n  const ecma_builtin_property_descriptor_t *property_list_p = ecma_builtin_property_list_references[builtin_id];\n\n  const ecma_builtin_property_descriptor_t *curr_property_p = property_list_p;\n\n  while (curr_property_p->magic_string_id != magic_string_id)\n  {\n    if (curr_property_p->magic_string_id == LIT_MAGIC_STRING__COUNT)\n    {\n      return NULL;\n    }\n    curr_property_p++;\n  }\n\n  uint32_t index = (uint32_t) (curr_property_p - property_list_p);\n\n  uint32_t *bitset_p = built_in_props_p->u.instantiated_bitset + (index >> 5);\n\n  uint32_t bit_for_index = (uint32_t) (1u << (index & 0x1f));\n\n  if (*bitset_p & bit_for_index)\n  {\n    /* This property was instantiated before. */\n    return NULL;\n  }\n\n  *bitset_p |= bit_for_index;\n\n  ecma_value_t value = ECMA_VALUE_EMPTY;\n  bool is_accessor = false;\n  ecma_object_t *getter_p = NULL;\n  ecma_object_t *setter_p = NULL;\n\n  switch (curr_property_p->type)\n  {\n    case ECMA_BUILTIN_PROPERTY_SIMPLE:\n    {\n      value = curr_property_p->value;\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_NUMBER:\n    {\n      ecma_number_t num = 0.0;\n\n      if (curr_property_p->value < ECMA_BUILTIN_NUMBER_MAX)\n      {\n        num = curr_property_p->value;\n      }\n      else if (curr_property_p->value < ECMA_BUILTIN_NUMBER_NAN)\n      {\n        static const ecma_number_t builtin_number_list[] =\n        {\n          ECMA_NUMBER_MAX_VALUE,\n          ECMA_NUMBER_MIN_VALUE,\n#if ENABLED (JERRY_ES2015)\n          ECMA_NUMBER_EPSILON,\n          ECMA_NUMBER_MAX_SAFE_INTEGER,\n          ECMA_NUMBER_MIN_SAFE_INTEGER,\n#endif /* ENABLED (JERRY_ES2015) */\n          ECMA_NUMBER_E,\n          ECMA_NUMBER_PI,\n          ECMA_NUMBER_LN10,\n          ECMA_NUMBER_LN2,\n          ECMA_NUMBER_LOG2E,\n          ECMA_NUMBER_LOG10E,\n          ECMA_NUMBER_SQRT2,\n          ECMA_NUMBER_SQRT_1_2,\n        };\n\n        num = builtin_number_list[curr_property_p->value - ECMA_BUILTIN_NUMBER_MAX];\n      }\n      else\n      {\n        switch (curr_property_p->value)\n        {\n          case ECMA_BUILTIN_NUMBER_POSITIVE_INFINITY:\n          {\n            num = ecma_number_make_infinity (false);\n            break;\n          }\n          case ECMA_BUILTIN_NUMBER_NEGATIVE_INFINITY:\n          {\n            num = ecma_number_make_infinity (true);\n            break;\n          }\n          default:\n          {\n            JERRY_ASSERT (curr_property_p->value == ECMA_BUILTIN_NUMBER_NAN);\n\n            num = ecma_number_make_nan ();\n            break;\n          }\n        }\n      }\n\n      value = ecma_make_number_value (num);\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_STRING:\n    {\n      value = ecma_make_magic_string_value ((lit_magic_string_id_t) curr_property_p->value);\n      break;\n    }\n#if ENABLED (JERRY_ES2015)\n    case ECMA_BUILTIN_PROPERTY_SYMBOL:\n    {\n      ecma_stringbuilder_t builder = ecma_stringbuilder_create_raw ((lit_utf8_byte_t *) \"Symbol.\", 7);\n\n      lit_magic_string_id_t symbol_desc_id = (lit_magic_string_id_t) curr_property_p->value;\n\n      ecma_stringbuilder_append_magic (&builder, symbol_desc_id);\n\n      ecma_value_t symbol_desc_value = ecma_make_string_value (ecma_stringbuilder_finalize (&builder));\n\n      ecma_string_t *symbol_p = ecma_new_symbol_from_descriptor_string (symbol_desc_value);\n      lit_magic_string_id_t symbol_id = (lit_magic_string_id_t) curr_property_p->magic_string_id;\n      symbol_p->u.hash = (uint16_t) ((symbol_id << ECMA_GLOBAL_SYMBOL_SHIFT) | ECMA_GLOBAL_SYMBOL_FLAG);\n\n      value = ecma_make_symbol_value (symbol_p);\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_INTRINSIC_PROPERTY:\n    {\n      value = ecma_op_object_get_by_magic_id (ecma_builtin_get (ECMA_BUILTIN_ID_INTRINSIC_OBJECT),\n                                              (lit_magic_string_id_t) curr_property_p->value);\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_ACCESSOR_BUILTIN_FUNCTION:\n    {\n      is_accessor = true;\n      uint16_t getter_id = ECMA_ACCESSOR_READ_WRITE_GET_GETTER_ID (curr_property_p->value);\n      uint16_t setter_id = ECMA_ACCESSOR_READ_WRITE_GET_SETTER_ID (curr_property_p->value);\n      getter_p = ecma_builtin_get (getter_id);\n      setter_p = ecma_builtin_get (setter_id);\n      ecma_ref_object (getter_p);\n      ecma_ref_object (setter_p);\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case ECMA_BUILTIN_PROPERTY_OBJECT:\n    {\n      ecma_object_t *builtin_object_p = ecma_builtin_get ((ecma_builtin_id_t) curr_property_p->value);\n      ecma_ref_object (builtin_object_p);\n      value = ecma_make_object_value (builtin_object_p);\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_ROUTINE:\n    {\n      ecma_object_t *func_obj_p;\n      func_obj_p = ecma_builtin_make_function_object_for_routine (builtin_id,\n                                                                  ECMA_GET_ROUTINE_ID (curr_property_p->value),\n                                                                  curr_property_p->magic_string_id,\n                                                                  ECMA_GET_ROUTINE_LENGTH (curr_property_p->value));\n      value = ecma_make_object_value (func_obj_p);\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_ACCESSOR_READ_WRITE:\n    {\n      is_accessor = true;\n      uint16_t getter_id = ECMA_ACCESSOR_READ_WRITE_GET_GETTER_ID (curr_property_p->value);\n      uint16_t setter_id = ECMA_ACCESSOR_READ_WRITE_GET_SETTER_ID (curr_property_p->value);\n      getter_p = ecma_builtin_make_function_object_for_getter_accessor (builtin_id,\n                                                                        getter_id,\n                                                                        curr_property_p->magic_string_id);\n      setter_p = ecma_builtin_make_function_object_for_setter_accessor (builtin_id,\n                                                                        setter_id,\n                                                                        curr_property_p->magic_string_id);\n      break;\n    }\n    default:\n    {\n      JERRY_ASSERT (curr_property_p->type == ECMA_BUILTIN_PROPERTY_ACCESSOR_READ_ONLY);\n\n      is_accessor = true;\n      getter_p = ecma_builtin_make_function_object_for_getter_accessor (builtin_id,\n                                                                        curr_property_p->value,\n                                                                        curr_property_p->magic_string_id);\n      break;\n    }\n  }\n\n  ecma_property_t *prop_p;\n\n  if (is_accessor)\n  {\n    ecma_create_named_accessor_property (object_p,\n                                         string_p,\n                                         getter_p,\n                                         setter_p,\n                                         curr_property_p->attributes,\n                                         &prop_p);\n\n    if (setter_p)\n    {\n      ecma_deref_object (setter_p);\n    }\n    if (getter_p)\n    {\n      ecma_deref_object (getter_p);\n    }\n  }\n  else\n  {\n    ecma_property_value_t *prop_value_p = ecma_create_named_data_property (object_p,\n                                                                           string_p,\n                                                                           curr_property_p->attributes,\n                                                                           &prop_p);\n    prop_value_p->value = value;\n\n    /* Reference count of objects must be decreased. */\n    if (ecma_is_value_object (value))\n    {\n      ecma_free_value (value);\n    }\n  }\n\n  return prop_p;\n}",
        "begin_line": 681,
        "end_line": 938,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_instantiate_builtin#341",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_instantiate_builtin (ecma_builtin_id_t obj_builtin_id) /**< built-in id */",
        "snippet": "static void\necma_instantiate_builtin (ecma_builtin_id_t obj_builtin_id) /**< built-in id */\n{\n  JERRY_ASSERT (obj_builtin_id < ECMA_BUILTIN_ID__COUNT);\n  JERRY_ASSERT (JERRY_CONTEXT (ecma_builtin_objects)[obj_builtin_id] == JMEM_CP_NULL);\n\n  ecma_builtin_descriptor_t builtin_desc = ecma_builtin_descriptors[obj_builtin_id];\n  ecma_builtin_id_t object_prototype_builtin_id = (ecma_builtin_id_t) (builtin_desc >> ECMA_BUILTIN_PROTOTYPE_ID_SHIFT);\n\n  ecma_object_t *prototype_obj_p;\n\n  /* cppcheck-suppress arrayIndexOutOfBoundsCond */\n  if (JERRY_UNLIKELY (object_prototype_builtin_id == ECMA_BUILTIN_ID__COUNT))\n  {\n    prototype_obj_p = NULL;\n  }\n  else\n  {\n    if (JERRY_CONTEXT (ecma_builtin_objects)[object_prototype_builtin_id] == JMEM_CP_NULL)\n    {\n      ecma_instantiate_builtin (object_prototype_builtin_id);\n    }\n    prototype_obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t,\n                                                 JERRY_CONTEXT (ecma_builtin_objects)[object_prototype_builtin_id]);\n    JERRY_ASSERT (prototype_obj_p != NULL);\n  }\n\n  ecma_object_type_t obj_type = (ecma_object_type_t) (builtin_desc & ECMA_BUILTIN_OBJECT_TYPE_MASK);\n\n  bool is_extended_built_in = (obj_type == ECMA_OBJECT_TYPE_CLASS\n                               || obj_type == ECMA_OBJECT_TYPE_ARRAY);\n\n  size_t ext_object_size = (is_extended_built_in ? sizeof (ecma_extended_built_in_object_t)\n                                                 : sizeof (ecma_extended_object_t));\n\n  size_t property_count = ecma_builtin_get_property_count (obj_builtin_id);\n\n  if (property_count > 32)\n  {\n    /* Only 64 extra properties supported at the moment.\n     * This can be extended to 256 later. */\n    JERRY_ASSERT (property_count <= (32 + 64));\n\n    ext_object_size += sizeof (uint32_t) * 2;\n  }\n\n  ecma_object_t *obj_p = ecma_create_object (prototype_obj_p, ext_object_size, obj_type);\n\n  if (JERRY_UNLIKELY (obj_builtin_id == ECMA_BUILTIN_ID_TYPE_ERROR_THROWER))\n  {\n    ecma_op_ordinary_object_prevent_extensions (obj_p);\n  }\n  else\n  {\n    ecma_op_ordinary_object_set_extensible (obj_p);\n  }\n\n  /*\n   * [[Class]] property of built-in object is not stored explicitly.\n   *\n   * See also: ecma_object_get_class_name\n   */\n\n  ecma_set_object_is_builtin (obj_p);\n  ecma_built_in_props_t *built_in_props_p;\n\n  if (is_extended_built_in)\n  {\n    built_in_props_p = &((ecma_extended_built_in_object_t *) obj_p)->built_in;\n  }\n  else\n  {\n    built_in_props_p = &((ecma_extended_object_t *) obj_p)->u.built_in;\n  }\n\n  built_in_props_p->id = (uint8_t) obj_builtin_id;\n  built_in_props_p->routine_id = (uint16_t) obj_builtin_id;\n  built_in_props_p->u.instantiated_bitset[0] = 0;\n\n  if (property_count > 32)\n  {\n    built_in_props_p->length_and_bitset_size = 1 << ECMA_BUILT_IN_BITSET_SHIFT;\n\n    uint32_t *instantiated_bitset_p = built_in_props_p->u.instantiated_bitset;\n    instantiated_bitset_p[1] = 0;\n    instantiated_bitset_p[2] = 0;\n  }\n  else\n  {\n    built_in_props_p->length_and_bitset_size = 0;\n  }\n\n  /** Initializing [[PrimitiveValue]] properties of built-in prototype objects */\n  switch (obj_builtin_id)\n  {\n#if ENABLED (JERRY_BUILTIN_ARRAY)\n    case ECMA_BUILTIN_ID_ARRAY_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_ARRAY);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.array.length = 0;\n      ext_object_p->u.array.u.length_prop = ECMA_PROPERTY_FLAG_WRITABLE | ECMA_PROPERTY_TYPE_VIRTUAL;\n      break;\n    }\n#endif /* ENABLED (JERRY_BUILTIN_ARRAY) */\n\n#if !ENABLED (JERRY_ES2015)\n#if ENABLED (JERRY_BUILTIN_STRING)\n    case ECMA_BUILTIN_ID_STRING_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_CLASS);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.class_prop.class_id = LIT_MAGIC_STRING_STRING_UL;\n      ext_object_p->u.class_prop.u.value = ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);\n      break;\n    }\n#endif /* ENABLED (JERRY_BUILTIN_STRING) */\n\n#if ENABLED (JERRY_BUILTIN_NUMBER)\n    case ECMA_BUILTIN_ID_NUMBER_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_CLASS);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.class_prop.class_id = LIT_MAGIC_STRING_NUMBER_UL;\n      ext_object_p->u.class_prop.u.value = ecma_make_integer_value (0);\n      break;\n    }\n#endif /* ENABLED (JERRY_BUILTIN_NUMBER) */\n\n#if ENABLED (JERRY_BUILTIN_BOOLEAN)\n    case ECMA_BUILTIN_ID_BOOLEAN_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_CLASS);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.class_prop.class_id = LIT_MAGIC_STRING_BOOLEAN_UL;\n      ext_object_p->u.class_prop.u.value = ECMA_VALUE_FALSE;\n      break;\n    }\n#endif /* ENABLED (JERRY_BUILTIN_BOOLEAN) */\n\n#if ENABLED (JERRY_BUILTIN_DATE)\n    case ECMA_BUILTIN_ID_DATE_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_CLASS);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.class_prop.class_id = LIT_MAGIC_STRING_DATE_UL;\n\n      ecma_number_t *prim_prop_num_value_p = ecma_alloc_number ();\n      *prim_prop_num_value_p = ecma_number_make_nan ();\n      ECMA_SET_INTERNAL_VALUE_POINTER (ext_object_p->u.class_prop.u.value, prim_prop_num_value_p);\n      break;\n    }\n#endif /* ENABLED (JERRY_BUILTIN_DATE) */\n\n#if ENABLED (JERRY_BUILTIN_REGEXP)\n    case ECMA_BUILTIN_ID_REGEXP_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_CLASS);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.class_prop.class_id = LIT_MAGIC_STRING_REGEXP_UL;\n\n      re_compiled_code_t *bc_p = re_compile_bytecode (ecma_get_magic_string (LIT_MAGIC_STRING_EMPTY_NON_CAPTURE_GROUP),\n                                                      RE_FLAG_EMPTY);\n\n      JERRY_ASSERT (bc_p != NULL);\n\n      ECMA_SET_INTERNAL_VALUE_POINTER (ext_object_p->u.class_prop.u.value, bc_p);\n\n      break;\n    }\n#endif /* ENABLED (JERRY_BUILTIN_REGEXP) */\n#endif /* !ENABLED (JERRY_ES2015) */\n    default:\n    {\n      JERRY_ASSERT (obj_type != ECMA_OBJECT_TYPE_CLASS);\n      break;\n    }\n  }\n\n  ECMA_SET_NON_NULL_POINTER (JERRY_CONTEXT (ecma_builtin_objects)[obj_builtin_id], obj_p);\n}",
        "begin_line": 341,
        "end_line": 527,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-array-object.ecma_fast_array_convert_to_normal#165",
        "src_path": "jerry-core/ecma/operations/ecma-array-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-array-object",
        "signature": "jerry-core.ecma.operations.ecma-array-object.ecma_fast_array_convert_to_normal (ecma_object_t *object_p) /**< fast access mode array object */",
        "snippet": "void\necma_fast_array_convert_to_normal (ecma_object_t *object_p) /**< fast access mode array object */\n{\n  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));\n\n  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;\n\n  if (object_p->u1.property_list_cp == JMEM_CP_NULL)\n  {\n    ext_obj_p->u.array.u.length_prop = (uint8_t) (ext_obj_p->u.array.u.length_prop & ~ECMA_FAST_ARRAY_FLAG);\n    return;\n  }\n\n  uint32_t length = ext_obj_p->u.array.length;\n  const uint32_t aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (length);\n  ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);\n\n  ecma_ref_object (object_p);\n\n  ecma_property_pair_t *property_pair_p = NULL;\n  jmem_cpointer_t next_property_pair_cp = JMEM_CP_NULL;\n\n  uint32_t prop_index = 1;\n  int32_t index = (int32_t) (length - 1);\n\n  while (index >= 0)\n  {\n    if (ecma_is_value_array_hole (values_p[index]))\n    {\n      index--;\n      continue;\n    }\n\n    if (prop_index == 1)\n    {\n      property_pair_p = ecma_alloc_property_pair ();\n      property_pair_p->header.next_property_cp = next_property_pair_cp;\n      property_pair_p->names_cp[0] = LIT_INTERNAL_MAGIC_STRING_DELETED;\n      property_pair_p->header.types[0] = ECMA_PROPERTY_TYPE_DELETED;\n      ECMA_SET_NON_NULL_POINTER (next_property_pair_cp, property_pair_p);\n    }\n\n    JERRY_ASSERT (index <= ECMA_DIRECT_STRING_MAX_IMM);\n\n    property_pair_p->names_cp[prop_index] = (jmem_cpointer_t) index;\n    property_pair_p->header.types[prop_index] = (ecma_property_t) (ECMA_PROPERTY_TYPE_NAMEDDATA\n                                                                   | ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE\n                                                                   | ECMA_FAST_ARRAY_UINT32_DIRECT_STRING_PROP_TYPE);\n\n    property_pair_p->values[prop_index].value = values_p[index];\n\n    index--;\n    prop_index = !prop_index;\n  }\n\n  ext_obj_p->u.array.u.length_prop = (uint8_t) (ext_obj_p->u.array.u.length_prop & ~ECMA_FAST_ARRAY_FLAG);\n  jmem_heap_free_block (values_p, aligned_length * sizeof (ecma_value_t));\n  ECMA_SET_POINTER (object_p->u1.property_list_cp, property_pair_p);\n\n  ecma_deref_object (object_p);\n}",
        "begin_line": 165,
        "end_line": 225,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-array-object.ecma_fast_array_extend#322",
        "src_path": "jerry-core/ecma/operations/ecma-array-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-array-object",
        "signature": "jerry-core.ecma.operations.ecma-array-object.ecma_fast_array_extend (ecma_object_t *object_p, /**< fast access mode array object */                         uint32_t new_length) /**< new length of the fast access mode array */",
        "snippet": "ecma_value_t *\necma_fast_array_extend (ecma_object_t *object_p, /**< fast access mode array object */\n                        uint32_t new_length) /**< new length of the fast access mode array */\n{\n  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));\n  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;\n  uint32_t old_length = ext_obj_p->u.array.length;\n\n  JERRY_ASSERT (old_length < new_length);\n\n  ecma_ref_object (object_p);\n\n  ecma_value_t *new_values_p;\n  const uint32_t old_length_aligned = ECMA_FAST_ARRAY_ALIGN_LENGTH (old_length);\n  const uint32_t new_length_aligned = ECMA_FAST_ARRAY_ALIGN_LENGTH (new_length);\n\n  if (object_p->u1.property_list_cp == JMEM_CP_NULL)\n  {\n    new_values_p = jmem_heap_alloc_block (new_length_aligned * sizeof (ecma_value_t));\n  }\n  else\n  {\n    ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);\n    new_values_p = (ecma_value_t *) jmem_heap_realloc_block (values_p,\n                                                             old_length_aligned * sizeof (ecma_value_t),\n                                                             new_length_aligned * sizeof (ecma_value_t));\n  }\n\n  for (uint32_t i = old_length; i < new_length_aligned; i++)\n  {\n    new_values_p[i] = ECMA_VALUE_ARRAY_HOLE;\n  }\n\n  ext_obj_p->u.array.u.hole_count += (new_length - old_length) * ECMA_FAST_ARRAY_HOLE_ONE;\n  ext_obj_p->u.array.length = new_length;\n\n  ECMA_SET_NON_NULL_POINTER (object_p->u1.property_list_cp, new_values_p);\n\n  ecma_deref_object (object_p);\n  return new_values_p;\n}",
        "begin_line": 322,
        "end_line": 362,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-array-object.ecma_op_new_array_object#69",
        "src_path": "jerry-core/ecma/operations/ecma-array-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-array-object",
        "signature": "jerry-core.ecma.operations.ecma-array-object.ecma_op_new_array_object (ecma_length_t length) /**< length of the new array */",
        "snippet": "ecma_object_t *\necma_op_new_array_object (ecma_length_t length) /**< length of the new array */\n{\n#if ENABLED (JERRY_BUILTIN_ARRAY)\n  ecma_object_t *array_prototype_object_p = ecma_builtin_get (ECMA_BUILTIN_ID_ARRAY_PROTOTYPE);\n#else /* !ENABLED (JERRY_BUILTIN_ARRAY) */\n  ecma_object_t *array_prototype_object_p = ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);\n#endif /* ENABLED (JERRY_BUILTIN_ARRAY) */\n\n  ecma_object_t *object_p = ecma_create_object (array_prototype_object_p,\n                                                sizeof (ecma_extended_object_t),\n                                                ECMA_OBJECT_TYPE_ARRAY);\n\n  /*\n   * [[Class]] property is not stored explicitly for objects of ECMA_OBJECT_TYPE_ARRAY type.\n   *\n   * See also: ecma_object_get_class_name\n   */\n\n  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;\n  ext_obj_p->u.array.length = length;\n  ext_obj_p->u.array.u.hole_count = 0;\n  ext_obj_p->u.array.u.length_prop = ECMA_PROPERTY_FLAG_WRITABLE | ECMA_PROPERTY_TYPE_VIRTUAL;\n\n  return object_p;\n}",
        "begin_line": 69,
        "end_line": 94,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-array-object.ecma_op_new_fast_array_object#129",
        "src_path": "jerry-core/ecma/operations/ecma-array-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-array-object",
        "signature": "jerry-core.ecma.operations.ecma-array-object.ecma_op_new_fast_array_object (ecma_length_t length) /**< length of the new fast access mode array */",
        "snippet": "ecma_object_t *\necma_op_new_fast_array_object (ecma_length_t length) /**< length of the new fast access mode array */\n{\n  const uint32_t aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (length);\n  ecma_value_t *values_p = NULL;\n\n  if (length != 0)\n  {\n    values_p = (ecma_value_t *) jmem_heap_alloc_block_null_on_error (aligned_length * sizeof (ecma_value_t));\n\n    if (JERRY_UNLIKELY (values_p == NULL))\n    {\n      return NULL;\n    }\n  }\n\n  ecma_object_t *object_p = ecma_op_new_array_object (length);\n  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;\n\n  ext_obj_p->u.array.u.length_prop = (uint8_t) (ext_obj_p->u.array.u.length_prop | ECMA_FAST_ARRAY_FLAG);\n  ext_obj_p->u.array.u.hole_count += length * ECMA_FAST_ARRAY_HOLE_ONE;\n\n  JERRY_ASSERT (object_p->u1.property_list_cp == JMEM_CP_NULL);\n\n  for (uint32_t i = 0; i < aligned_length; i++)\n  {\n    values_p[i] = ECMA_VALUE_ARRAY_HOLE;\n  }\n\n  ECMA_SET_POINTER (object_p->u1.property_list_cp, values_p);\n  return object_p;\n}",
        "begin_line": 129,
        "end_line": 160,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-conversion.ecma_get_number#335",
        "src_path": "jerry-core/ecma/operations/ecma-conversion.c",
        "class_name": "jerry-core.ecma.operations.ecma-conversion",
        "signature": "jerry-core.ecma.operations.ecma-conversion.ecma_get_number (ecma_value_t value, /**< ecma value*/                  ecma_number_t *number_p) /**< [out] ecma number */",
        "snippet": "ecma_value_t\necma_get_number (ecma_value_t value, /**< ecma value*/\n                 ecma_number_t *number_p) /**< [out] ecma number */\n{\n  if (ecma_is_value_integer_number (value))\n  {\n    *number_p = ecma_get_integer_from_value (value);\n    return ECMA_VALUE_EMPTY;\n  }\n\n  if (ecma_is_value_float_number (value))\n  {\n    *number_p = ecma_get_float_from_value (value);\n    return ECMA_VALUE_EMPTY;\n  }\n\n  if (ecma_is_value_string (value))\n  {\n    ecma_string_t *str_p = ecma_get_string_from_value (value);\n    *number_p = ecma_string_to_number (str_p);\n    return ECMA_VALUE_EMPTY;\n  }\n\n  if (ecma_is_value_object (value))\n  {\n    ecma_value_t primitive_value = ecma_op_to_primitive (value, ECMA_PREFERRED_TYPE_NUMBER);\n\n    if (ECMA_IS_VALUE_ERROR (primitive_value))\n    {\n      return primitive_value;\n    }\n\n    ecma_value_t ret_value = ecma_get_number (primitive_value, number_p);\n    ecma_fast_free_value (primitive_value);\n    return ret_value;\n  }\n\n  if (ecma_is_value_undefined (value))\n  {\n    *number_p = ecma_number_make_nan ();\n    return ECMA_VALUE_EMPTY;\n  }\n\n  if (ecma_is_value_null (value))\n  {\n    *number_p = 0;\n    return ECMA_VALUE_EMPTY;\n  }\n\n#if ENABLED (JERRY_ES2015)\n  if (ecma_is_value_symbol (value))\n  {\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Cannot convert a Symbol value to a number.\"));\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  JERRY_ASSERT (ecma_is_value_boolean (value));\n\n  *number_p = ecma_is_value_true (value) ? 1 : 0;\n  return ECMA_VALUE_EMPTY;\n}",
        "begin_line": 335,
        "end_line": 395,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-conversion.ecma_op_to_object#508",
        "src_path": "jerry-core/ecma/operations/ecma-conversion.c",
        "class_name": "jerry-core.ecma.operations.ecma-conversion",
        "signature": "jerry-core.ecma.operations.ecma-conversion.ecma_op_to_object (ecma_value_t value) /**< ecma value */",
        "snippet": "ecma_value_t\necma_op_to_object (ecma_value_t value) /**< ecma value */\n{\n  ecma_check_value_type_is_spec_defined (value);\n\n  if (ecma_is_value_number (value))\n  {\n    return ecma_op_create_number_object (value);\n  }\n  else if (ecma_is_value_string (value))\n  {\n    return ecma_op_create_string_object (&value, 1);\n  }\n  else if (ecma_is_value_object (value))\n  {\n    return ecma_copy_value (value);\n  }\n#if ENABLED (JERRY_ES2015)\n  else if (ecma_is_value_symbol (value))\n  {\n    return ecma_op_create_symbol_object (value);\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n  else\n  {\n    if (ecma_is_value_undefined (value)\n        || ecma_is_value_null (value))\n    {\n      return ecma_raise_type_error (ECMA_ERR_MSG (\"Argument cannot be converted to an object.\"));\n    }\n    else\n    {\n      JERRY_ASSERT (ecma_is_value_boolean (value));\n\n      return ecma_op_create_boolean_object (value);\n    }\n  }\n}",
        "begin_line": 508,
        "end_line": 545,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-conversion.ecma_op_to_prop_name#482",
        "src_path": "jerry-core/ecma/operations/ecma-conversion.c",
        "class_name": "jerry-core.ecma.operations.ecma-conversion",
        "signature": "jerry-core.ecma.operations.ecma-conversion.ecma_op_to_prop_name (ecma_value_t value) /**< ecma value */",
        "snippet": "ecma_string_t *\necma_op_to_prop_name (ecma_value_t value) /**< ecma value */\n{\n  ecma_check_value_type_is_spec_defined (value);\n\n#if ENABLED (JERRY_ES2015)\n  if (ecma_is_value_symbol (value))\n  {\n    ecma_string_t *symbol_p = ecma_get_symbol_from_value (value);\n    ecma_ref_ecma_string (symbol_p);\n    return symbol_p;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  return ecma_op_to_string (value);\n}",
        "begin_line": 482,
        "end_line": 497,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-conversion.ecma_op_to_string#406",
        "src_path": "jerry-core/ecma/operations/ecma-conversion.c",
        "class_name": "jerry-core.ecma.operations.ecma-conversion",
        "signature": "jerry-core.ecma.operations.ecma-conversion.ecma_op_to_string (ecma_value_t value) /**< ecma value */",
        "snippet": "ecma_string_t *\necma_op_to_string (ecma_value_t value) /**< ecma value */\n{\n  ecma_check_value_type_is_spec_defined (value);\n\n  if (JERRY_UNLIKELY (ecma_is_value_object (value)))\n  {\n    ecma_value_t prim_value = ecma_op_to_primitive (value, ECMA_PREFERRED_TYPE_STRING);\n\n    if (ECMA_IS_VALUE_ERROR (prim_value))\n    {\n      return NULL;\n    }\n\n    ecma_string_t *ret_string_p = ecma_op_to_string (prim_value);\n\n    ecma_free_value (prim_value);\n\n    return ret_string_p;\n  }\n\n  if (ecma_is_value_string (value))\n  {\n    ecma_string_t *res_p = ecma_get_string_from_value (value);\n    ecma_ref_ecma_string (res_p);\n    return res_p;\n  }\n  else if (ecma_is_value_integer_number (value))\n  {\n    ecma_integer_value_t num = ecma_get_integer_from_value (value);\n\n    if (num < 0)\n    {\n      return ecma_new_ecma_string_from_number ((ecma_number_t) num);\n    }\n    else\n    {\n      return ecma_new_ecma_string_from_uint32 ((uint32_t) num);\n    }\n  }\n  else if (ecma_is_value_float_number (value))\n  {\n    ecma_number_t num = ecma_get_float_from_value (value);\n    return ecma_new_ecma_string_from_number (num);\n  }\n  else if (ecma_is_value_undefined (value))\n  {\n    return ecma_get_magic_string (LIT_MAGIC_STRING_UNDEFINED);\n  }\n  else if (ecma_is_value_null (value))\n  {\n    return ecma_get_magic_string (LIT_MAGIC_STRING_NULL);\n  }\n#if ENABLED (JERRY_ES2015)\n  else if (ecma_is_value_symbol (value))\n  {\n    ecma_raise_type_error (ECMA_ERR_MSG (\"Cannot convert a Symbol value to a string.\"));\n    return NULL;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n  JERRY_ASSERT (ecma_is_value_boolean (value));\n\n  if (ecma_is_value_true (value))\n  {\n    return ecma_get_magic_string (LIT_MAGIC_STRING_TRUE);\n  }\n\n  return ecma_get_magic_string (LIT_MAGIC_STRING_FALSE);\n}",
        "begin_line": 406,
        "end_line": 474,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-eval.ecma_op_eval#43",
        "src_path": "jerry-core/ecma/operations/ecma-eval.c",
        "class_name": "jerry-core.ecma.operations.ecma-eval",
        "signature": "jerry-core.ecma.operations.ecma-eval.ecma_op_eval (ecma_string_t *code_p, /**< code string */               uint32_t parse_opts) /**< ecma_parse_opts_t option bits */",
        "snippet": "ecma_value_t\necma_op_eval (ecma_string_t *code_p, /**< code string */\n              uint32_t parse_opts) /**< ecma_parse_opts_t option bits */\n{\n  ecma_value_t ret_value;\n\n  lit_utf8_size_t chars_num = ecma_string_get_size (code_p);\n  if (chars_num == 0)\n  {\n    ret_value = ECMA_VALUE_UNDEFINED;\n  }\n  else\n  {\n    ECMA_STRING_TO_UTF8_STRING (code_p, code_utf8_buffer_p, code_utf8_buffer_size);\n\n    ret_value = ecma_op_eval_chars_buffer (code_utf8_buffer_p,\n                                           chars_num,\n                                           parse_opts);\n\n    ECMA_FINALIZE_UTF8_STRING (code_utf8_buffer_p, code_utf8_buffer_size);\n  }\n\n  return ret_value;\n}",
        "begin_line": 43,
        "end_line": 66,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-eval.ecma_op_eval_chars_buffer#77",
        "src_path": "jerry-core/ecma/operations/ecma-eval.c",
        "class_name": "jerry-core.ecma.operations.ecma-eval",
        "signature": "jerry-core.ecma.operations.ecma-eval.ecma_op_eval_chars_buffer (const lit_utf8_byte_t *code_p, /**< code characters buffer */                            size_t code_buffer_size, /**< size of the buffer */                            uint32_t parse_opts) /**< ecma_parse_opts_t option bits */",
        "snippet": "ecma_value_t\necma_op_eval_chars_buffer (const lit_utf8_byte_t *code_p, /**< code characters buffer */\n                           size_t code_buffer_size, /**< size of the buffer */\n                           uint32_t parse_opts) /**< ecma_parse_opts_t option bits */\n{\n#if ENABLED (JERRY_PARSER)\n  JERRY_ASSERT (code_p != NULL);\n\n  ecma_compiled_code_t *bytecode_data_p;\n\n  uint32_t is_strict_call = ECMA_PARSE_STRICT_MODE | ECMA_PARSE_DIRECT_EVAL;\n\n  if ((parse_opts & is_strict_call) != is_strict_call)\n  {\n    parse_opts &= (uint32_t) ~ECMA_PARSE_STRICT_MODE;\n  }\n\n  parse_opts |= ECMA_PARSE_EVAL;\n\n#if ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ERROR_MESSAGES)\n  JERRY_CONTEXT (resource_name) = ecma_make_magic_string_value (LIT_MAGIC_STRING_RESOURCE_EVAL);\n#endif /* ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ERROR_MESSAGES) */\n\n#if ENABLED (JERRY_ES2015)\n  ECMA_CLEAR_LOCAL_PARSE_OPTS ();\n#endif /* ENABLED (JERRY_ES2015) */\n\n  ecma_value_t parse_status = parser_parse_script (NULL,\n                                                   0,\n                                                   code_p,\n                                                   code_buffer_size,\n                                                   parse_opts,\n                                                   &bytecode_data_p);\n\n  if (ECMA_IS_VALUE_ERROR (parse_status))\n  {\n    return parse_status;\n  }\n\n  return vm_run_eval (bytecode_data_p, parse_opts);\n#else /* !ENABLED (JERRY_PARSER) */\n  JERRY_UNUSED (code_p);\n  JERRY_UNUSED (code_buffer_size);\n  JERRY_UNUSED (parse_opts);\n\n  return ecma_raise_syntax_error (ECMA_ERR_MSG (\"The parser has been disabled.\"));\n#endif /* ENABLED (JERRY_PARSER) */\n}",
        "begin_line": 77,
        "end_line": 124,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-exceptions.ecma_new_standard_error#78",
        "src_path": "jerry-core/ecma/operations/ecma-exceptions.c",
        "class_name": "jerry-core.ecma.operations.ecma-exceptions",
        "signature": "jerry-core.ecma.operations.ecma-exceptions.ecma_new_standard_error (ecma_standard_error_t error_type) /**< native error type */",
        "snippet": "ecma_object_t *\necma_new_standard_error (ecma_standard_error_t error_type) /**< native error type */\n{\n#if ENABLED (JERRY_BUILTIN_ERRORS)\n  ecma_builtin_id_t prototype_id = ECMA_BUILTIN_ID__COUNT;\n\n  switch (error_type)\n  {\n    case ECMA_ERROR_EVAL:\n    {\n      prototype_id = ECMA_BUILTIN_ID_EVAL_ERROR_PROTOTYPE;\n      break;\n    }\n\n    case ECMA_ERROR_RANGE:\n    {\n      prototype_id = ECMA_BUILTIN_ID_RANGE_ERROR_PROTOTYPE;\n      break;\n    }\n\n    case ECMA_ERROR_REFERENCE:\n    {\n      prototype_id = ECMA_BUILTIN_ID_REFERENCE_ERROR_PROTOTYPE;\n      break;\n    }\n\n    case ECMA_ERROR_TYPE:\n    {\n      prototype_id = ECMA_BUILTIN_ID_TYPE_ERROR_PROTOTYPE;\n      break;\n    }\n\n    case ECMA_ERROR_URI:\n    {\n      prototype_id = ECMA_BUILTIN_ID_URI_ERROR_PROTOTYPE;\n      break;\n    }\n\n    case ECMA_ERROR_SYNTAX:\n    {\n      prototype_id = ECMA_BUILTIN_ID_SYNTAX_ERROR_PROTOTYPE;\n      break;\n    }\n\n    default:\n    {\n      JERRY_ASSERT (error_type == ECMA_ERROR_COMMON);\n\n      prototype_id = ECMA_BUILTIN_ID_ERROR_PROTOTYPE;\n      break;\n    }\n  }\n#else\n  JERRY_UNUSED (error_type);\n  ecma_builtin_id_t prototype_id = ECMA_BUILTIN_ID_ERROR_PROTOTYPE;\n#endif /* ENABLED (JERRY_BUILTIN_ERRORS) */\n\n  ecma_object_t *prototype_obj_p = ecma_builtin_get (prototype_id);\n\n  ecma_object_t *new_error_obj_p = ecma_create_object (prototype_obj_p,\n                                                       sizeof (ecma_extended_object_t),\n                                                       ECMA_OBJECT_TYPE_CLASS);\n\n  ((ecma_extended_object_t *) new_error_obj_p)->u.class_prop.class_id = LIT_MAGIC_STRING_ERROR_UL;\n\n#if ENABLED (JERRY_LINE_INFO)\n  /* The \"stack\" identifier is not a magic string. */\n  const char * const stack_id_p = \"stack\";\n\n  ecma_string_t *stack_str_p = ecma_new_ecma_string_from_utf8 ((const lit_utf8_byte_t *) stack_id_p, 5);\n\n  ecma_property_value_t *prop_value_p = ecma_create_named_data_property (new_error_obj_p,\n                                                                         stack_str_p,\n                                                                         ECMA_PROPERTY_CONFIGURABLE_WRITABLE,\n                                                                         NULL);\n  ecma_deref_ecma_string (stack_str_p);\n\n  ecma_value_t backtrace_value = vm_get_backtrace (0);\n\n  prop_value_p->value = backtrace_value;\n  ecma_deref_object (ecma_get_object_from_value (backtrace_value));\n#endif /* ENABLED (JERRY_LINE_INFO) */\n\n  return new_error_obj_p;\n}",
        "begin_line": 78,
        "end_line": 162,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-exceptions.ecma_new_standard_error_with_message#199",
        "src_path": "jerry-core/ecma/operations/ecma-exceptions.c",
        "class_name": "jerry-core.ecma.operations.ecma-exceptions",
        "signature": "jerry-core.ecma.operations.ecma-exceptions.ecma_new_standard_error_with_message (ecma_standard_error_t error_type, /**< native error type */                                       ecma_string_t *message_string_p) /**< message string */",
        "snippet": "ecma_object_t *\necma_new_standard_error_with_message (ecma_standard_error_t error_type, /**< native error type */\n                                      ecma_string_t *message_string_p) /**< message string */\n{\n  ecma_object_t *new_error_obj_p = ecma_new_standard_error (error_type);\n\n  ecma_property_value_t *prop_value_p;\n  prop_value_p = ecma_create_named_data_property (new_error_obj_p,\n                                                  ecma_get_magic_string (LIT_MAGIC_STRING_MESSAGE),\n                                                  ECMA_PROPERTY_CONFIGURABLE_WRITABLE,\n                                                  NULL);\n\n  ecma_ref_ecma_string (message_string_p);\n  prop_value_p->value = ecma_make_string_value (message_string_p);\n\n  return new_error_obj_p;\n}",
        "begin_line": 199,
        "end_line": 215,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_create_external_function_object#498",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_create_external_function_object (ecma_external_handler_t handler_cb) /**< pointer to external native handler */",
        "snippet": "ecma_object_t *\necma_op_create_external_function_object (ecma_external_handler_t handler_cb) /**< pointer to external native handler */\n{\n  ecma_object_t *prototype_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_FUNCTION_PROTOTYPE);\n\n  ecma_object_t *function_obj_p;\n  function_obj_p = ecma_create_object (prototype_obj_p,\n                                       sizeof (ecma_extended_object_t),\n                                       ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION);\n\n  /*\n   * [[Class]] property is not stored explicitly for objects of ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION type.\n   *\n   * See also: ecma_object_get_class_name\n   */\n\n  ecma_extended_object_t *ext_func_obj_p = (ecma_extended_object_t *) function_obj_p;\n  ext_func_obj_p->u.external_handler_cb = handler_cb;\n\n  return function_obj_p;\n}",
        "begin_line": 498,
        "end_line": 518,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_create_function_object#218",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_create_function_object (ecma_object_t *scope_p, /**< function's scope */                                 const ecma_compiled_code_t *bytecode_data_p, /**< byte-code array */                                 ecma_builtin_id_t proto_id) /**< builtin id of the prototype object */",
        "snippet": "static ecma_object_t *\necma_op_create_function_object (ecma_object_t *scope_p, /**< function's scope */\n                                const ecma_compiled_code_t *bytecode_data_p, /**< byte-code array */\n                                ecma_builtin_id_t proto_id) /**< builtin id of the prototype object */\n{\n  JERRY_ASSERT (ecma_is_lexical_environment (scope_p));\n\n  /* 1., 4., 13. */\n  ecma_object_t *prototype_obj_p = ecma_builtin_get (proto_id);\n\n  size_t function_object_size = sizeof (ecma_extended_object_t);\n\n#if ENABLED (JERRY_SNAPSHOT_EXEC)\n  if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)\n  {\n    function_object_size = sizeof (ecma_static_function_t);\n  }\n#endif /* ENABLED (JERRY_SNAPSHOT_EXEC) */\n\n  ecma_object_t *func_p = ecma_create_object (prototype_obj_p,\n                                              function_object_size,\n                                              ECMA_OBJECT_TYPE_FUNCTION);\n\n  /* 2., 6., 7., 8. */\n  /*\n   * We don't setup [[Get]], [[Call]], [[Construct]], [[HasInstance]] for each function object.\n   * Instead we set the object's type to ECMA_OBJECT_TYPE_FUNCTION\n   * that defines which version of the routine should be used on demand.\n   */\n\n  /* 3. */\n  /*\n   * [[Class]] property is not stored explicitly for objects of ECMA_OBJECT_TYPE_FUNCTION type.\n   *\n   * See also: ecma_object_get_class_name\n   */\n\n  ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_p;\n\n  /* 9. */\n  ECMA_SET_NON_NULL_POINTER_TAG (ext_func_p->u.function.scope_cp, scope_p, 0);\n\n  /* 10., 11., 12. */\n\n#if ENABLED (JERRY_SNAPSHOT_EXEC)\n  if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)\n  {\n    ext_func_p->u.function.bytecode_cp = ECMA_NULL_POINTER;\n    ((ecma_static_function_t *) func_p)->bytecode_p = bytecode_data_p;\n  }\n  else\n#endif /* ENABLED (JERRY_SNAPSHOT_EXEC) */\n  {\n    ECMA_SET_INTERNAL_VALUE_POINTER (ext_func_p->u.function.bytecode_cp, bytecode_data_p);\n    ecma_bytecode_ref ((ecma_compiled_code_t *) bytecode_data_p);\n  }\n\n  /* 14., 15., 16., 17., 18. */\n  /*\n   * 'length' and 'prototype' properties are instantiated lazily\n   *\n   * See also: ecma_op_function_try_to_lazy_instantiate_property\n   */\n\n  return func_p;\n}",
        "begin_line": 218,
        "end_line": 283,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_create_simple_function_object#408",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_create_simple_function_object (ecma_object_t *scope_p, /**< function's scope */                                        const ecma_compiled_code_t *bytecode_data_p) /**< byte-code array */",
        "snippet": "ecma_object_t *\necma_op_create_simple_function_object (ecma_object_t *scope_p, /**< function's scope */\n                                       const ecma_compiled_code_t *bytecode_data_p) /**< byte-code array */\n{\n  return ecma_op_create_function_object (scope_p, bytecode_data_p, ECMA_BUILTIN_ID_FUNCTION_PROTOTYPE);\n}",
        "begin_line": 408,
        "end_line": 413,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_external_function_try_to_lazy_instantiate_property#1477",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_external_function_try_to_lazy_instantiate_property (ecma_object_t *object_p, /**< object */                                                             ecma_string_t *property_name_p) /**< property's name */",
        "snippet": "ecma_property_t *\necma_op_external_function_try_to_lazy_instantiate_property (ecma_object_t *object_p, /**< object */\n                                                            ecma_string_t *property_name_p) /**< property's name */\n{\n  JERRY_ASSERT (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION);\n\n  if (ecma_compare_ecma_string_to_magic_id (property_name_p, LIT_MAGIC_STRING_PROTOTYPE))\n  {\n    return ecma_op_lazy_instantiate_prototype_object (object_p);\n  }\n\n  return NULL;\n}",
        "begin_line": 1477,
        "end_line": 1489,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_call#1052",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_call (ecma_object_t *func_obj_p, /**< Function object */                        ecma_value_t this_arg_value, /**< 'this' argument's value */                        const ecma_value_t *arguments_list_p, /**< arguments list */                        ecma_length_t arguments_list_len) /**< length of arguments list */",
        "snippet": "ecma_value_t\necma_op_function_call (ecma_object_t *func_obj_p, /**< Function object */\n                       ecma_value_t this_arg_value, /**< 'this' argument's value */\n                       const ecma_value_t *arguments_list_p, /**< arguments list */\n                       ecma_length_t arguments_list_len) /**< length of arguments list */\n{\n  JERRY_ASSERT (func_obj_p != NULL\n                && !ecma_is_lexical_environment (func_obj_p));\n  JERRY_ASSERT (ecma_op_object_is_callable (func_obj_p));\n\n  ECMA_CHECK_STACK_USAGE ();\n\n  const ecma_object_type_t type = ecma_get_object_type (func_obj_p);\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_TYPE_IS_PROXY (type))\n  {\n    return ecma_proxy_object_call (func_obj_p, this_arg_value, arguments_list_p, arguments_list_len);\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n#if ENABLED (JERRY_ES2015)\n  ecma_object_t *old_new_target_p = JERRY_CONTEXT (current_new_target);\n  if (JERRY_UNLIKELY (!(JERRY_CONTEXT (status_flags) & ECMA_STATUS_DIRECT_EVAL)))\n  {\n    JERRY_CONTEXT (current_new_target) = NULL;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  ecma_value_t result;\n\n  if (JERRY_LIKELY (type == ECMA_OBJECT_TYPE_FUNCTION))\n  {\n    result = ecma_op_function_call_simple (func_obj_p, this_arg_value, arguments_list_p, arguments_list_len);\n  }\n  else if (type == ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION)\n  {\n    result = ecma_op_function_call_external (func_obj_p, this_arg_value, arguments_list_p, arguments_list_len);\n  }\n  else\n  {\n    result = ecma_op_function_call_bound (func_obj_p, arguments_list_p, arguments_list_len);\n  }\n\n#if ENABLED (JERRY_ES2015)\n  JERRY_CONTEXT (current_new_target) = old_new_target_p;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  return result;\n}",
        "begin_line": 1052,
        "end_line": 1101,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_call_simple#772",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_call_simple (ecma_object_t *func_obj_p, /**< Function object */                               ecma_value_t this_arg_value, /**< 'this' argument's value */                               const ecma_value_t *arguments_list_p, /**< arguments list */                               ecma_length_t arguments_list_len) /**< length of arguments list */",
        "snippet": "static ecma_value_t\necma_op_function_call_simple (ecma_object_t *func_obj_p, /**< Function object */\n                              ecma_value_t this_arg_value, /**< 'this' argument's value */\n                              const ecma_value_t *arguments_list_p, /**< arguments list */\n                              ecma_length_t arguments_list_len) /**< length of arguments list */\n{\n  JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_FUNCTION);\n\n  if (JERRY_UNLIKELY (ecma_get_object_is_builtin (func_obj_p)))\n  {\n    return ecma_builtin_dispatch_call (func_obj_p, this_arg_value, arguments_list_p, arguments_list_len);\n  }\n\n  /* Entering Function Code (ECMA-262 v5, 10.4.3) */\n  ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_obj_p;\n\n  ecma_object_t *scope_p = ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t,\n                                                                       ext_func_p->u.function.scope_cp);\n\n  /* 8. */\n  ecma_value_t this_binding = this_arg_value;\n  bool free_this_binding = false;\n\n  const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);\n  uint16_t status_flags = bytecode_data_p->status_flags;\n\n#if ENABLED (JERRY_ES2015)\n  bool is_construct_call = JERRY_CONTEXT (current_new_target) != NULL;\n  if (JERRY_UNLIKELY (status_flags & (CBC_CODE_FLAGS_CLASS_CONSTRUCTOR | CBC_CODE_FLAGS_GENERATOR)))\n  {\n    if (!is_construct_call && (status_flags & CBC_CODE_FLAGS_CLASS_CONSTRUCTOR))\n    {\n      return ecma_raise_type_error (ECMA_ERR_MSG (\"Class constructor cannot be invoked without 'new'.\"));\n    }\n\n    if ((status_flags & CBC_CODE_FLAGS_GENERATOR) && is_construct_call)\n    {\n      return ecma_raise_type_error (ECMA_ERR_MSG (\"Generator functions cannot be invoked with 'new'.\"));\n    }\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  /* 1. */\n#if ENABLED (JERRY_ES2015)\n  ecma_object_t *old_function_object_p = JERRY_CONTEXT (current_function_obj_p);\n\n  if (JERRY_UNLIKELY (status_flags & CBC_CODE_FLAGS_ARROW_FUNCTION))\n  {\n    ecma_arrow_function_t *arrow_func_p = (ecma_arrow_function_t *) func_obj_p;\n\n    if (ecma_is_value_undefined (arrow_func_p->new_target))\n    {\n      JERRY_CONTEXT (current_new_target) = NULL;\n    }\n    else\n    {\n      JERRY_CONTEXT (current_new_target) = ecma_get_object_from_value (arrow_func_p->new_target);\n    }\n    this_binding = arrow_func_p->this_binding;\n  }\n  else\n  {\n    JERRY_CONTEXT (current_function_obj_p) = func_obj_p;\n#endif /* ENABLED (JERRY_ES2015) */\n    if (!(status_flags & CBC_CODE_FLAGS_STRICT_MODE))\n    {\n      if (ecma_is_value_undefined (this_binding)\n          || ecma_is_value_null (this_binding))\n      {\n        /* 2. */\n        this_binding = ecma_make_object_value (ecma_builtin_get_global ());\n      }\n      else if (!ecma_is_value_object (this_binding))\n      {\n        /* 3., 4. */\n        this_binding = ecma_op_to_object (this_binding);\n        free_this_binding = true;\n\n        JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (this_binding));\n      }\n    }\n#if ENABLED (JERRY_ES2015)\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  /* 5. */\n  ecma_object_t *local_env_p;\n  if (status_flags & CBC_CODE_FLAGS_LEXICAL_ENV_NOT_NEEDED)\n  {\n    local_env_p = scope_p;\n  }\n  else\n  {\n    local_env_p = ecma_create_decl_lex_env (scope_p);\n    if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_IS_ARGUMENTS_NEEDED)\n    {\n      ecma_op_create_arguments_object (func_obj_p,\n                                       local_env_p,\n                                       arguments_list_p,\n                                       arguments_list_len,\n                                       bytecode_data_p);\n    }\n#if ENABLED (JERRY_ES2015)\n    // ECMAScript v6, 9.2.2.8\n    if (JERRY_UNLIKELY (status_flags & CBC_CODE_FLAGS_CLASS_CONSTRUCTOR))\n    {\n      ecma_value_t lexical_this;\n      lexical_this = (ECMA_GET_THIRD_BIT_FROM_POINTER_TAG (ext_func_p->u.function.scope_cp) ? ECMA_VALUE_UNINITIALIZED\n                                                                                            : this_binding);\n      ecma_op_init_this_binding (local_env_p, lexical_this);\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n  }\n\n  ecma_value_t ret_value = vm_run (bytecode_data_p,\n                                   this_binding,\n                                   local_env_p,\n                                   arguments_list_p,\n                                   arguments_list_len);\n\n#if ENABLED (JERRY_ES2015)\n  JERRY_CONTEXT (current_function_obj_p) = old_function_object_p;\n\n  /* ECMAScript v6, 9.2.2.13 */\n  if (ECMA_GET_THIRD_BIT_FROM_POINTER_TAG (ext_func_p->u.function.scope_cp))\n  {\n    if (!ECMA_IS_VALUE_ERROR (ret_value) && !ecma_is_value_object (ret_value))\n    {\n      if (!ecma_is_value_undefined (ret_value))\n      {\n        ecma_free_value (ret_value);\n        ret_value = ecma_raise_type_error (ECMA_ERR_MSG (\"Derived constructors may only return object or undefined.\"));\n      }\n      else\n      {\n        ret_value = ecma_op_get_this_binding (local_env_p);\n      }\n    }\n  }\n\n#endif /* ENABLED (JERRY_ES2015) */\n\n  if (!(status_flags & CBC_CODE_FLAGS_LEXICAL_ENV_NOT_NEEDED))\n  {\n    ecma_deref_object (local_env_p);\n  }\n\n  if (JERRY_UNLIKELY (free_this_binding))\n  {\n    ecma_free_value (this_binding);\n  }\n\n  return ret_value;\n}",
        "begin_line": 772,
        "end_line": 925,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_construct#1194",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_construct (ecma_object_t *func_obj_p, /**< Function object */                             ecma_object_t *new_target_p, /**< new target */                             const ecma_value_t *arguments_list_p, /**< arguments list */                             ecma_length_t arguments_list_len) /**< length of arguments list */",
        "snippet": "ecma_value_t\necma_op_function_construct (ecma_object_t *func_obj_p, /**< Function object */\n                            ecma_object_t *new_target_p, /**< new target */\n                            const ecma_value_t *arguments_list_p, /**< arguments list */\n                            ecma_length_t arguments_list_len) /**< length of arguments list */\n{\n  JERRY_ASSERT (func_obj_p != NULL\n                && !ecma_is_lexical_environment (func_obj_p));\n\n  const ecma_object_type_t type = ecma_get_object_type (func_obj_p);\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_TYPE_IS_PROXY (type))\n  {\n    return ecma_proxy_object_construct (func_obj_p,\n                                        new_target_p,\n                                        arguments_list_p,\n                                        arguments_list_len);\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  if (JERRY_UNLIKELY (type == ECMA_OBJECT_TYPE_BOUND_FUNCTION))\n  {\n    return ecma_op_function_construct_bound (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n  }\n\n  if (JERRY_UNLIKELY (type == ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION))\n  {\n    return ecma_op_function_construct_external (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n  }\n\n  JERRY_ASSERT (type == ECMA_OBJECT_TYPE_FUNCTION);\n\n  if (JERRY_UNLIKELY (ecma_get_object_is_builtin (func_obj_p)))\n  {\n    return ecma_builtin_dispatch_construct (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n  }\n\n  ecma_object_t *new_this_obj_p = NULL;\n  ecma_value_t this_arg;\n  ecma_extended_object_t *ext_func_obj_p = (ecma_extended_object_t *) func_obj_p;\n  const ecma_compiled_code_t *byte_code_p = ecma_op_function_get_compiled_code (ext_func_obj_p);\n\n  if (byte_code_p->status_flags & (CBC_CODE_FLAGS_ARROW_FUNCTION | CBC_CODE_FLAGS_ACCESSOR))\n  {\n    if (byte_code_p->status_flags & CBC_CODE_FLAGS_ARROW_FUNCTION)\n    {\n      return ecma_raise_type_error (ECMA_ERR_MSG (\"Arrow functions have no constructor.\"));\n    }\n\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Expected a constructor.\"));\n  }\n\n#if ENABLED (JERRY_ES2015)\n  /* 6. */\n  ecma_object_t *old_new_target_p = JERRY_CONTEXT (current_new_target);\n  JERRY_CONTEXT (current_new_target) = new_target_p;\n\n  /* 5. */\n  if (!ECMA_GET_THIRD_BIT_FROM_POINTER_TAG (ext_func_obj_p->u.function.scope_cp))\n  {\n#endif /* ENABLED (JERRY_ES2015) */\n    /* 5.a */\n    ecma_object_t *proto_p = ecma_op_get_prototype_from_constructor (new_target_p, ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);\n\n    /* 5.b */\n    if (JERRY_UNLIKELY (proto_p == NULL))\n    {\n      return ECMA_VALUE_ERROR;\n    }\n\n    new_this_obj_p = ecma_create_object (proto_p, 0, ECMA_OBJECT_TYPE_GENERAL);\n    ecma_deref_object (proto_p);\n    this_arg = ecma_make_object_value (new_this_obj_p);\n#if ENABLED (JERRY_ES2015)\n  }\n  else\n  {\n    this_arg = ECMA_VALUE_UNDEFINED;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  ecma_value_t ret_value = ecma_op_function_call_simple (func_obj_p, this_arg, arguments_list_p, arguments_list_len);\n\n#if ENABLED (JERRY_ES2015)\n  JERRY_CONTEXT (current_new_target) = old_new_target_p;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  /* 13.a */\n  if (ECMA_IS_VALUE_ERROR (ret_value) || ecma_is_value_object (ret_value))\n  {\n#if ENABLED (JERRY_ES2015)\n    if (new_this_obj_p != NULL)\n    {\n      ecma_deref_object (new_this_obj_p);\n    }\n#else /* !ENABLED (JERRY_ES2015) */\n    ecma_deref_object (new_this_obj_p);\n#endif /* ENABLED (JERRY_ES2015) */\n    return ret_value;\n  }\n\n  /* 13.b */\n  ecma_free_value (ret_value);\n  return this_arg;\n}",
        "begin_line": 1194,
        "end_line": 1299,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_get_prototype_from_constructor#735",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_get_prototype_from_constructor (ecma_object_t *ctor_obj_p, /**< constructor to get prototype from  */                                         ecma_builtin_id_t default_proto_id) /**< intrinsicDefaultProto */",
        "snippet": "ecma_object_t *\necma_op_get_prototype_from_constructor (ecma_object_t *ctor_obj_p, /**< constructor to get prototype from  */\n                                        ecma_builtin_id_t default_proto_id) /**< intrinsicDefaultProto */\n{\n  JERRY_ASSERT (ecma_object_is_constructor (ctor_obj_p));\n  JERRY_ASSERT (default_proto_id < ECMA_BUILTIN_ID__COUNT);\n\n  ecma_value_t proto = ecma_op_object_get_by_magic_id (ctor_obj_p, LIT_MAGIC_STRING_PROTOTYPE);\n\n  if (ECMA_IS_VALUE_ERROR (proto))\n  {\n    return NULL;\n  }\n\n  ecma_object_t *proto_obj_p;\n\n  if (!ecma_is_value_object (proto))\n  {\n    ecma_free_value (proto);\n    proto_obj_p = ecma_builtin_get (default_proto_id);\n    ecma_ref_object (proto_obj_p);\n  }\n  else\n  {\n    proto_obj_p = ecma_get_object_from_value (proto);\n  }\n\n  return proto_obj_p;\n}",
        "begin_line": 735,
        "end_line": 763,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_is_callable#99",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_is_callable (ecma_value_t value) /**< ecma value */",
        "snippet": "bool\necma_op_is_callable (ecma_value_t value) /**< ecma value */\n{\n  return (ecma_is_value_object (value)\n          && ecma_op_object_is_callable (ecma_get_object_from_value (value)));\n}",
        "begin_line": 99,
        "end_line": 104,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-get-put-value.ecma_op_get_value_object_base#129",
        "src_path": "jerry-core/ecma/operations/ecma-get-put-value.c",
        "class_name": "jerry-core.ecma.operations.ecma-get-put-value",
        "signature": "jerry-core.ecma.operations.ecma-get-put-value.ecma_op_get_value_object_base (ecma_value_t base_value, /**< base value */                                ecma_string_t *property_name_p) /**< property name */",
        "snippet": "ecma_value_t\necma_op_get_value_object_base (ecma_value_t base_value, /**< base value */\n                               ecma_string_t *property_name_p) /**< property name */\n{\n  ecma_object_t *obj_p;\n\n  if (JERRY_UNLIKELY (ecma_is_value_object (base_value)))\n  {\n    obj_p = ecma_get_object_from_value (base_value);\n  }\n  else\n  {\n    ecma_builtin_id_t id = ECMA_BUILTIN_ID_OBJECT_PROTOTYPE;\n\n    if (JERRY_LIKELY (ecma_is_value_string (base_value)))\n    {\n      ecma_string_t *string_p = ecma_get_string_from_value (base_value);\n\n      if (ecma_string_is_length (property_name_p))\n      {\n        return ecma_make_uint32_value (ecma_string_get_length (string_p));\n      }\n\n      uint32_t index = ecma_string_get_array_index (property_name_p);\n\n      if (index != ECMA_STRING_NOT_ARRAY_INDEX\n          && index < ecma_string_get_length (string_p))\n      {\n        ecma_char_t char_at_idx = ecma_string_get_char_at_pos (string_p, index);\n        return ecma_make_string_value (ecma_new_ecma_string_from_code_unit (char_at_idx));\n      }\n\n#if ENABLED (JERRY_BUILTIN_STRING)\n      id = ECMA_BUILTIN_ID_STRING_PROTOTYPE;\n#endif /* ENABLED (JERRY_BUILTIN_STRING) */\n    }\n    else if (ecma_is_value_number (base_value))\n    {\n#if ENABLED (JERRY_BUILTIN_NUMBER)\n      id = ECMA_BUILTIN_ID_NUMBER_PROTOTYPE;\n#endif /* ENABLED (JERRY_BUILTIN_NUMBER) */\n    }\n#if ENABLED (JERRY_ES2015)\n    else if (ecma_is_value_symbol (base_value))\n    {\n      id = ECMA_BUILTIN_ID_SYMBOL_PROTOTYPE;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    else\n    {\n      JERRY_ASSERT (ecma_is_value_boolean (base_value));\n#if ENABLED (JERRY_BUILTIN_BOOLEAN)\n      id = ECMA_BUILTIN_ID_BOOLEAN_PROTOTYPE;\n#endif /* ENABLED (JERRY_BUILTIN_BOOLEAN) */\n    }\n\n    obj_p = ecma_builtin_get (id);\n  }\n\n  return ecma_op_object_get_with_receiver (obj_p, property_name_p, base_value);\n}",
        "begin_line": 129,
        "end_line": 189,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-get-put-value.ecma_op_put_value_lex_env_base#199",
        "src_path": "jerry-core/ecma/operations/ecma-get-put-value.c",
        "class_name": "jerry-core.ecma.operations.ecma-get-put-value",
        "signature": "jerry-core.ecma.operations.ecma-get-put-value.ecma_op_put_value_lex_env_base (ecma_object_t *lex_env_p, /**< lexical environment */                                 ecma_string_t *name_p, /**< variable name */                                 bool is_strict, /**< flag indicating strict mode */                                 ecma_value_t value) /**< ECMA-value */",
        "snippet": "ecma_value_t\necma_op_put_value_lex_env_base (ecma_object_t *lex_env_p, /**< lexical environment */\n                                ecma_string_t *name_p, /**< variable name */\n                                bool is_strict, /**< flag indicating strict mode */\n                                ecma_value_t value) /**< ECMA-value */\n{\n  JERRY_ASSERT (lex_env_p != NULL\n                && ecma_is_lexical_environment (lex_env_p));\n\n  while (true)\n  {\n    switch (ecma_get_lex_env_type (lex_env_p))\n    {\n      case ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE:\n      {\n        ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n        if (property_p != NULL)\n        {\n          if (ecma_is_property_writable (*property_p))\n          {\n            ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n#if ENABLED (JERRY_ES2015)\n            if (JERRY_UNLIKELY (property_value_p->value == ECMA_VALUE_UNINITIALIZED))\n            {\n              return ecma_raise_reference_error (ECMA_ERR_MSG (\"Variables declared by let/const must be\"\n                                                               \" initialized before writing their value.\"));\n            }\n#endif /* ENABLED (JERRY_ES2015) */\n\n            ecma_named_data_property_assign_value (lex_env_p, property_value_p, value);\n          }\n#if ENABLED (JERRY_ES2015)\n          else if (ecma_is_property_enumerable (*property_p))\n          {\n            return ecma_raise_type_error (ECMA_ERR_MSG (\"Constant bindings cannot be reassigned.\"));\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n          else if (is_strict)\n          {\n            return ecma_raise_type_error (ECMA_ERR_MSG (\"Binding cannot be set.\"));\n          }\n          return ECMA_VALUE_EMPTY;\n        }\n        break;\n      }\n#if ENABLED (JERRY_ES2015)\n      case ECMA_LEXICAL_ENVIRONMENT_HOME_OBJECT_BOUND:\n      {\n        break;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      default:\n      {\n        JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n\n        ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);\n\n        ecma_value_t has_property = ecma_op_object_has_property (binding_obj_p, name_p);\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n        if (ECMA_IS_VALUE_ERROR (has_property))\n        {\n          return has_property;\n        }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n        if (ecma_is_value_true (has_property))\n        {\n          ecma_value_t completion = ecma_op_object_put (binding_obj_p,\n                                                        name_p,\n                                                        value,\n                                                        is_strict);\n\n          if (ECMA_IS_VALUE_ERROR (completion))\n          {\n            return completion;\n          }\n\n          JERRY_ASSERT (ecma_is_value_boolean (completion));\n          return ECMA_VALUE_EMPTY;\n        }\n\n        break;\n      }\n    }\n\n    if (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);\n  }\n\n  if (is_strict)\n  {\n#if ENABLED (JERRY_ERROR_MESSAGES)\n    return ecma_raise_standard_error_with_format (ECMA_ERROR_REFERENCE,\n                                                  \"% is not defined\",\n                                                  ecma_make_string_value (name_p));\n#else /* !ENABLED (JERRY_ERROR_MESSAGES) */\n    return ecma_raise_reference_error (NULL);\n#endif /* ENABLED (JERRY_ERROR_MESSAGES) */\n  }\n\n  ecma_value_t completion = ecma_op_object_put (ecma_builtin_get_global (),\n                                                name_p,\n                                                value,\n                                                false);\n\n  JERRY_ASSERT (ecma_is_value_boolean (completion));\n\n  return ECMA_VALUE_EMPTY;\n}",
        "begin_line": 199,
        "end_line": 314,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_get_global_environment#76",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_get_global_environment (void)",
        "snippet": "ecma_object_t *\necma_get_global_environment (void)\n{\n  JERRY_ASSERT (JERRY_CONTEXT (ecma_global_env_cp) != JMEM_CP_NULL);\n  return ECMA_GET_NON_NULL_POINTER (ecma_object_t, JERRY_CONTEXT (ecma_global_env_cp));\n}",
        "begin_line": 76,
        "end_line": 81,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_get_global_scope#105",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_get_global_scope (void)",
        "snippet": "ecma_object_t *\necma_get_global_scope (void)\n{\n#if ENABLED (JERRY_ES2015)\n  JERRY_ASSERT (JERRY_CONTEXT (ecma_global_scope_cp) != JMEM_CP_NULL);\n  return ECMA_GET_NON_NULL_POINTER (ecma_object_t, JERRY_CONTEXT (ecma_global_scope_cp));\n#else /* !ENABLED (JERRY_ES2015) */\n  return ecma_get_global_environment ();\n#endif /* !ENABLED (JERRY_ES2015) */\n}",
        "begin_line": 105,
        "end_line": 114,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_init_global_environment#39",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_init_global_environment (void)",
        "snippet": "void\necma_init_global_environment (void)\n{\n  ecma_object_t *glob_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_GLOBAL);\n\n  ecma_object_t *global_lex_env_p = ecma_create_object_lex_env (NULL,\n                                                                glob_obj_p,\n                                                                ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n  ECMA_SET_NON_NULL_POINTER (JERRY_CONTEXT (ecma_global_env_cp), global_lex_env_p);\n#if ENABLED (JERRY_ES2015)\n  ECMA_SET_NON_NULL_POINTER (JERRY_CONTEXT (ecma_global_scope_cp), global_lex_env_p);\n#endif /* ENABLED (JERRY_ES2015) */\n}",
        "begin_line": 39,
        "end_line": 51,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_create_immutable_binding#415",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_create_immutable_binding (ecma_object_t *lex_env_p, /**< lexical environment */                                   ecma_string_t *name_p, /**< argument N */                                   ecma_value_t value) /**< argument V */",
        "snippet": "void\necma_op_create_immutable_binding (ecma_object_t *lex_env_p, /**< lexical environment */\n                                  ecma_string_t *name_p, /**< argument N */\n                                  ecma_value_t value) /**< argument V */\n{\n  JERRY_ASSERT (lex_env_p != NULL\n                && ecma_is_lexical_environment (lex_env_p));\n  JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);\n\n  /*\n   * Warning:\n   *         Whether immutable bindings are deletable seems not to be defined by ECMA v5.\n   */\n  ecma_property_value_t *prop_value_p = ecma_create_named_data_property (lex_env_p,\n                                                                         name_p,\n                                                                         ECMA_PROPERTY_FIXED,\n                                                                         NULL);\n\n  prop_value_p->value = ecma_copy_value_if_not_object (value);\n}",
        "begin_line": 415,
        "end_line": 434,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_create_mutable_binding#158",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_create_mutable_binding (ecma_object_t *lex_env_p, /**< lexical environment */                                 ecma_string_t *name_p, /**< argument N */                                 bool is_deletable) /**< argument D */",
        "snippet": "ecma_value_t\necma_op_create_mutable_binding (ecma_object_t *lex_env_p, /**< lexical environment */\n                                ecma_string_t *name_p, /**< argument N */\n                                bool is_deletable) /**< argument D */\n{\n  JERRY_ASSERT (lex_env_p != NULL\n                && ecma_is_lexical_environment (lex_env_p));\n  JERRY_ASSERT (name_p != NULL);\n\n  if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n  {\n    uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;\n\n    if (is_deletable)\n    {\n      prop_attributes = (uint8_t) (prop_attributes | ECMA_PROPERTY_FLAG_CONFIGURABLE);\n    }\n\n    ecma_create_named_data_property (lex_env_p,\n                                     name_p,\n                                     prop_attributes,\n                                     NULL);\n  }\n  else\n  {\n    JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n\n    ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);\n\n    if (!ecma_op_ordinary_object_is_extensible (binding_obj_p))\n    {\n      return ECMA_VALUE_EMPTY;\n    }\n\n    const uint32_t flags = ECMA_PROPERTY_ENUMERABLE_WRITABLE | ECMA_IS_THROW;\n\n    ecma_value_t completion = ecma_builtin_helper_def_prop (binding_obj_p,\n                                                            name_p,\n                                                            ECMA_VALUE_UNDEFINED,\n                                                            is_deletable ? flags | ECMA_PROPERTY_FLAG_CONFIGURABLE\n                                                                         : flags);\n\n    if (ECMA_IS_VALUE_ERROR (completion))\n    {\n      return completion;\n    }\n    else\n    {\n      JERRY_ASSERT (ecma_is_value_boolean (completion));\n    }\n  }\n\n  return ECMA_VALUE_EMPTY;\n}",
        "begin_line": 158,
        "end_line": 211,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_get_binding_value#283",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_get_binding_value (ecma_object_t *lex_env_p, /**< lexical environment */                            ecma_string_t *name_p, /**< argument N */                            bool is_strict) /**< argument S */",
        "snippet": "ecma_value_t\necma_op_get_binding_value (ecma_object_t *lex_env_p, /**< lexical environment */\n                           ecma_string_t *name_p, /**< argument N */\n                           bool is_strict) /**< argument S */\n{\n  JERRY_ASSERT (lex_env_p != NULL\n                && ecma_is_lexical_environment (lex_env_p));\n  JERRY_ASSERT (name_p != NULL);\n\n  if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n  {\n    ecma_property_value_t *prop_value_p = ecma_get_named_data_property (lex_env_p, name_p);\n\n    return ecma_copy_value (prop_value_p->value);\n  }\n  else\n  {\n    JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n\n    ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);\n\n    ecma_value_t result = ecma_op_object_find (binding_obj_p, name_p);\n\n    if (ECMA_IS_VALUE_ERROR (result))\n    {\n      return result;\n    }\n\n    if (!ecma_is_value_found (result))\n    {\n      if (is_strict)\n      {\n        result = ecma_raise_reference_error (ECMA_ERR_MSG (\"Binding does not exist or is uninitialised.\"));\n      }\n      else\n      {\n        result = ECMA_VALUE_UNDEFINED;\n      }\n    }\n\n    return result;\n  }\n}",
        "begin_line": 283,
        "end_line": 325,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_has_binding#127",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_has_binding (ecma_object_t *lex_env_p, /**< lexical environment */                      ecma_string_t *name_p) /**< argument N */",
        "snippet": "ecma_value_t\necma_op_has_binding (ecma_object_t *lex_env_p, /**< lexical environment */\n                     ecma_string_t *name_p) /**< argument N */\n{\n  JERRY_ASSERT (lex_env_p != NULL\n                && ecma_is_lexical_environment (lex_env_p));\n\n  ecma_lexical_environment_type_t lex_env_type = ecma_get_lex_env_type (lex_env_p);\n\n  if (lex_env_type == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n  {\n    ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n    return ecma_make_boolean_value (property_p != NULL);\n  }\n\n  JERRY_ASSERT (lex_env_type == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n\n  ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);\n\n  return ecma_op_object_has_property (binding_obj_p, name_p);\n}",
        "begin_line": 127,
        "end_line": 148,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_set_mutable_binding#221",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_set_mutable_binding (ecma_object_t *lex_env_p, /**< lexical environment */                              ecma_string_t *name_p, /**< argument N */                              ecma_value_t value, /**< argument V */                              bool is_strict) /**< argument S */",
        "snippet": "ecma_value_t\necma_op_set_mutable_binding (ecma_object_t *lex_env_p, /**< lexical environment */\n                             ecma_string_t *name_p, /**< argument N */\n                             ecma_value_t value, /**< argument V */\n                             bool is_strict) /**< argument S */\n{\n  JERRY_ASSERT (lex_env_p != NULL\n                && ecma_is_lexical_environment (lex_env_p));\n  JERRY_ASSERT (name_p != NULL);\n\n  if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n  {\n    ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n    JERRY_ASSERT (property_p != NULL\n                  && ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA);\n\n    if (ecma_is_property_writable (*property_p))\n    {\n      ecma_named_data_property_assign_value (lex_env_p, ECMA_PROPERTY_VALUE_PTR (property_p), value);\n    }\n#if ENABLED (JERRY_ES2015)\n    else if (ecma_is_property_enumerable (*property_p))\n    {\n      return ecma_raise_type_error (ECMA_ERR_MSG (\"Constant bindings cannot be reassigned.\"));\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    else if (is_strict)\n    {\n      return ecma_raise_type_error (ECMA_ERR_MSG (\"Binding cannot be set.\"));\n    }\n  }\n  else\n  {\n    JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n\n    ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);\n\n    ecma_value_t completion = ecma_op_object_put (binding_obj_p,\n                                                  name_p,\n                                                  value,\n                                                  is_strict);\n\n    if (ECMA_IS_VALUE_ERROR (completion))\n    {\n      return completion;\n    }\n\n    JERRY_ASSERT (ecma_is_value_boolean (completion));\n  }\n\n  return ECMA_VALUE_EMPTY;\n}",
        "begin_line": 221,
        "end_line": 273,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects-arguments.ecma_op_create_arguments_object#42",
        "src_path": "jerry-core/ecma/operations/ecma-objects-arguments.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects-arguments",
        "signature": "jerry-core.ecma.operations.ecma-objects-arguments.ecma_op_create_arguments_object (ecma_object_t *func_obj_p, /**< callee function */                                  ecma_object_t *lex_env_p, /**< lexical environment the Arguments                                                                 object is created for */                                  const ecma_value_t *arguments_list_p, /**< arguments list */                                  ecma_length_t arguments_number, /**< length of arguments list */                                  const ecma_compiled_code_t *bytecode_data_p) /**< byte code */",
        "snippet": "void\necma_op_create_arguments_object (ecma_object_t *func_obj_p, /**< callee function */\n                                 ecma_object_t *lex_env_p, /**< lexical environment the Arguments\n                                                                object is created for */\n                                 const ecma_value_t *arguments_list_p, /**< arguments list */\n                                 ecma_length_t arguments_number, /**< length of arguments list */\n                                 const ecma_compiled_code_t *bytecode_data_p) /**< byte code */\n{\n  bool is_strict = (bytecode_data_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE) != 0;\n\n  ecma_length_t formal_params_number;\n\n  if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n  {\n    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_data_p;\n\n    formal_params_number = args_p->argument_end;\n  }\n  else\n  {\n    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_data_p;\n\n    formal_params_number = args_p->argument_end;\n  }\n\n  ecma_object_t *prototype_p = ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);\n\n  ecma_object_t *obj_p;\n\n  if ((bytecode_data_p->status_flags & CBC_CODE_FLAGS_MAPPED_ARGUMENTS_NEEDED)\n      && arguments_number > 0\n      && formal_params_number > 0)\n  {\n    size_t formal_params_size = formal_params_number * sizeof (ecma_value_t);\n\n    obj_p = ecma_create_object (prototype_p,\n                                sizeof (ecma_extended_object_t) + formal_params_size,\n                                ECMA_OBJECT_TYPE_PSEUDO_ARRAY);\n\n    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n    ext_object_p->u.pseudo_array.type = ECMA_PSEUDO_ARRAY_ARGUMENTS;\n\n    ECMA_SET_INTERNAL_VALUE_POINTER (ext_object_p->u.pseudo_array.u2.lex_env_cp, lex_env_p);\n\n    ext_object_p->u.pseudo_array.u1.length = (uint16_t) formal_params_number;\n\n    ecma_value_t *arg_Literal_p = (ecma_value_t *) (ext_object_p + 1);\n\n    uint8_t *byte_p = (uint8_t *) bytecode_data_p;\n    byte_p += ((size_t) bytecode_data_p->size) << JMEM_ALIGNMENT_LOG;\n    byte_p -= formal_params_size;\n\n    memcpy (arg_Literal_p, byte_p, formal_params_size);\n\n    for (ecma_length_t i = 0; i < formal_params_number; i++)\n    {\n      if (arg_Literal_p[i] != ECMA_VALUE_EMPTY)\n      {\n        ecma_string_t *name_p = ecma_get_string_from_value (arg_Literal_p[i]);\n        ecma_ref_ecma_string (name_p);\n      }\n    }\n  }\n  else\n  {\n    obj_p = ecma_create_object (prototype_p, sizeof (ecma_extended_object_t), ECMA_OBJECT_TYPE_CLASS);\n\n    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n    ext_object_p->u.class_prop.class_id = LIT_MAGIC_STRING_ARGUMENTS_UL;\n  }\n\n  ecma_property_value_t *prop_value_p;\n\n  /* 11.a, 11.b */\n  for (ecma_length_t index = 0;\n       index < arguments_number;\n       index++)\n  {\n    ecma_string_t *index_string_p = ecma_new_ecma_string_from_uint32 (index);\n\n    prop_value_p = ecma_create_named_data_property (obj_p,\n                                                    index_string_p,\n                                                    ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,\n                                                    NULL);\n\n    prop_value_p->value = ecma_copy_value_if_not_object (arguments_list_p[index]);\n\n    ecma_deref_ecma_string (index_string_p);\n  }\n\n  /* 7. */\n  prop_value_p = ecma_create_named_data_property (obj_p,\n                                                  ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH),\n                                                  ECMA_PROPERTY_CONFIGURABLE_WRITABLE,\n                                                  NULL);\n\n  prop_value_p->value = ecma_make_uint32_value (arguments_number);\n\n  ecma_property_descriptor_t prop_desc = ecma_make_empty_property_descriptor ();\n\n#if ENABLED (JERRY_ES2015)\n  /* ECMAScript v6, 9.4.4.6.7, 9.4.4.7.22 */\n  ecma_string_t *symbol_p = ecma_op_get_global_symbol (LIT_GLOBAL_SYMBOL_ITERATOR);\n\n  prop_value_p = ecma_create_named_data_property (obj_p,\n                                                  symbol_p,\n                                                  ECMA_PROPERTY_CONFIGURABLE_WRITABLE,\n                                                  NULL);\n  ecma_deref_ecma_string (symbol_p);\n  prop_value_p->value = ecma_op_object_get_by_magic_id (ecma_builtin_get (ECMA_BUILTIN_ID_INTRINSIC_OBJECT),\n                                                        LIT_INTERNAL_MAGIC_STRING_ARRAY_PROTOTYPE_VALUES);\n\n  JERRY_ASSERT (ecma_is_value_object (prop_value_p->value));\n  ecma_deref_object (ecma_get_object_from_value (prop_value_p->value));\n#endif /* ENABLED (JERRY_ES2015) */\n\n  /* 13. */\n  if (!is_strict)\n  {\n    prop_value_p = ecma_create_named_data_property (obj_p,\n                                                    ecma_get_magic_string (LIT_MAGIC_STRING_CALLEE),\n                                                    ECMA_PROPERTY_CONFIGURABLE_WRITABLE,\n                                                    NULL);\n\n    prop_value_p->value = ecma_make_object_value (func_obj_p);\n  }\n  else\n  {\n    ecma_object_t *thrower_p = ecma_builtin_get (ECMA_BUILTIN_ID_TYPE_ERROR_THROWER);\n\n    /* 14. */\n    prop_desc = ecma_make_empty_property_descriptor ();\n    {\n      prop_desc.flags = (ECMA_PROP_IS_GET_DEFINED\n                         | ECMA_PROP_IS_SET_DEFINED\n                         | ECMA_PROP_IS_ENUMERABLE_DEFINED\n                         | ECMA_PROP_IS_CONFIGURABLE_DEFINED);\n    }\n    prop_desc.set_p = thrower_p;\n    prop_desc.get_p = thrower_p;\n\n    ecma_value_t completion = ecma_op_object_define_own_property (obj_p,\n                                                                  ecma_get_magic_string (LIT_MAGIC_STRING_CALLEE),\n                                                                  &prop_desc);\n\n    JERRY_ASSERT (ecma_is_value_true (completion));\n\n    completion = ecma_op_object_define_own_property (obj_p,\n                                                     ecma_get_magic_string (LIT_MAGIC_STRING_CALLER),\n                                                     &prop_desc);\n    JERRY_ASSERT (ecma_is_value_true (completion));\n  }\n\n  ecma_string_t *arguments_string_p = ecma_get_magic_string (LIT_MAGIC_STRING_ARGUMENTS);\n\n  if (is_strict)\n  {\n    ecma_op_create_immutable_binding (lex_env_p,\n                                      arguments_string_p,\n                                      ecma_make_object_value (obj_p));\n  }\n  else\n  {\n    ecma_value_t completion = ecma_op_create_mutable_binding (lex_env_p,\n                                                              arguments_string_p,\n                                                              false);\n    JERRY_ASSERT (ecma_is_value_empty (completion));\n\n    completion = ecma_op_set_mutable_binding (lex_env_p,\n                                              arguments_string_p,\n                                              ecma_make_object_value (obj_p),\n                                              false);\n\n    JERRY_ASSERT (ecma_is_value_empty (completion));\n  }\n\n  ecma_deref_object (obj_p);\n}",
        "begin_line": 42,
        "end_line": 220,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects-general.ecma_op_general_object_define_own_property#360",
        "src_path": "jerry-core/ecma/operations/ecma-objects-general.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects-general",
        "signature": "jerry-core.ecma.operations.ecma-objects-general.ecma_op_general_object_define_own_property (ecma_object_t *object_p, /**< the object */                                             ecma_string_t *property_name_p, /**< property name */                                             const ecma_property_descriptor_t *property_desc_p) /**< property                                                                                                 *   descriptor */",
        "snippet": "ecma_value_t\necma_op_general_object_define_own_property (ecma_object_t *object_p, /**< the object */\n                                            ecma_string_t *property_name_p, /**< property name */\n                                            const ecma_property_descriptor_t *property_desc_p) /**< property\n                                                                                                *   descriptor */\n{\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_IS_PROXY (object_p))\n  {\n    return ecma_proxy_object_define_own_property (object_p, property_name_p, property_desc_p);\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  JERRY_ASSERT (object_p != NULL\n                && !ecma_is_lexical_environment (object_p));\n  JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));\n  JERRY_ASSERT (property_name_p != NULL);\n\n  ecma_property_types_t property_desc_type = ECMA_PROPERTY_TYPE_GENERIC;\n\n  if (property_desc_p->flags & (ECMA_PROP_IS_VALUE_DEFINED | ECMA_PROP_IS_WRITABLE_DEFINED))\n  {\n    /* A property descriptor cannot be both named data and named accessor. */\n    JERRY_ASSERT ((property_desc_p->flags & (ECMA_PROP_IS_GET_DEFINED | ECMA_PROP_IS_SET_DEFINED))\n                   != (ECMA_PROP_IS_GET_DEFINED | ECMA_PROP_IS_SET_DEFINED));\n    property_desc_type = ECMA_PROPERTY_TYPE_NAMEDDATA;\n  }\n  else if (property_desc_p->flags & (ECMA_PROP_IS_GET_DEFINED | ECMA_PROP_IS_SET_DEFINED))\n  {\n    JERRY_ASSERT (!(property_desc_p->flags & ECMA_PROP_IS_WRITABLE_DEFINED));\n    property_desc_type = ECMA_PROPERTY_TYPE_NAMEDACCESSOR;\n  }\n\n  /* These three asserts ensures that a new property is created with the appropriate default flags.\n   * E.g. if ECMA_PROP_IS_CONFIGURABLE_DEFINED is false, the newly created property must be non-configurable. */\n  JERRY_ASSERT ((property_desc_p->flags & ECMA_PROP_IS_CONFIGURABLE_DEFINED)\n                || !(property_desc_p->flags & ECMA_PROP_IS_CONFIGURABLE));\n  JERRY_ASSERT ((property_desc_p->flags & ECMA_PROP_IS_ENUMERABLE_DEFINED)\n                || !(property_desc_p->flags & ECMA_PROP_IS_ENUMERABLE));\n  JERRY_ASSERT ((property_desc_p->flags & ECMA_PROP_IS_WRITABLE_DEFINED)\n                || !(property_desc_p->flags & ECMA_PROP_IS_WRITABLE));\n\n  /* 1. */\n  ecma_extended_property_ref_t ext_property_ref = { .property_ref.value_p = NULL, .property_p = NULL };\n  ecma_property_t current_prop;\n\n  current_prop = ecma_op_object_get_own_property (object_p,\n                                                  property_name_p,\n                                                  &ext_property_ref.property_ref,\n                                                  ECMA_PROPERTY_GET_VALUE | ECMA_PROPERTY_GET_EXT_REFERENCE);\n\n  if (current_prop == ECMA_PROPERTY_TYPE_NOT_FOUND || current_prop == ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP)\n  {\n    /* 3. */\n    if (!ecma_op_ordinary_object_is_extensible (object_p))\n    {\n      /* 2. */\n      return ecma_reject (property_desc_p->flags & ECMA_PROP_IS_THROW);\n    }\n\n    /* 4. */\n    uint8_t prop_attributes = (uint8_t) (property_desc_p->flags & ECMA_PROPERTY_FLAGS_MASK);\n\n    if (property_desc_type != ECMA_PROPERTY_TYPE_NAMEDACCESSOR)\n    {\n      /* a. */\n      JERRY_ASSERT (property_desc_type == ECMA_PROPERTY_TYPE_GENERIC\n                    || property_desc_type == ECMA_PROPERTY_TYPE_NAMEDDATA);\n\n      ecma_property_value_t *new_prop_value_p = ecma_create_named_data_property (object_p,\n                                                                                 property_name_p,\n                                                                                 prop_attributes,\n                                                                                 NULL);\n\n      JERRY_ASSERT ((property_desc_p->flags & ECMA_PROP_IS_VALUE_DEFINED)\n                    || ecma_is_value_undefined (property_desc_p->value));\n\n      new_prop_value_p->value = ecma_copy_value_if_not_object (property_desc_p->value);\n    }\n    else\n    {\n      /* b. */\n\n      ecma_create_named_accessor_property (object_p,\n                                           property_name_p,\n                                           property_desc_p->get_p,\n                                           property_desc_p->set_p,\n                                           prop_attributes,\n                                           NULL);\n    }\n\n    return ECMA_VALUE_TRUE;\n  }\n\n  /* 6. */\n  ecma_property_types_t current_property_type = ECMA_PROPERTY_GET_TYPE (current_prop);\n  const bool is_current_configurable = ecma_is_property_configurable (current_prop);\n\n  JERRY_ASSERT (current_property_type == ECMA_PROPERTY_TYPE_NAMEDDATA\n                || current_property_type == ECMA_PROPERTY_TYPE_NAMEDACCESSOR\n                || current_property_type == ECMA_PROPERTY_TYPE_VIRTUAL);\n\n  /* 7. a., b. */\n  bool is_enumerable = (property_desc_p->flags & ECMA_PROP_IS_ENUMERABLE) != 0;\n  if (!is_current_configurable\n      && ((property_desc_p->flags & ECMA_PROP_IS_CONFIGURABLE)\n          || ((property_desc_p->flags & ECMA_PROP_IS_ENUMERABLE_DEFINED)\n              && (is_enumerable != ecma_is_property_enumerable (current_prop)))))\n  {\n    if (current_property_type == ECMA_PROPERTY_TYPE_VIRTUAL)\n    {\n      ecma_free_value (ext_property_ref.property_ref.virtual_value);\n    }\n    return ecma_reject (property_desc_p->flags & ECMA_PROP_IS_THROW);\n  }\n\n  if (current_property_type == ECMA_PROPERTY_TYPE_VIRTUAL)\n  {\n    JERRY_ASSERT (!is_current_configurable && !ecma_is_property_writable (current_prop));\n\n    ecma_value_t result = ECMA_VALUE_TRUE;\n\n    if (property_desc_type == ECMA_PROPERTY_TYPE_NAMEDACCESSOR\n        || (property_desc_p->flags & ECMA_PROP_IS_WRITABLE)\n        || ((property_desc_p->flags & ECMA_PROP_IS_VALUE_DEFINED)\n            && !ecma_op_same_value (property_desc_p->value,\n                                    ext_property_ref.property_ref.virtual_value)))\n    {\n      result = ecma_reject (property_desc_p->flags & ECMA_PROP_IS_THROW);\n    }\n\n    ecma_free_value (ext_property_ref.property_ref.virtual_value);\n    return result;\n  }\n\n  /* 8. */\n  if (property_desc_type == ECMA_PROPERTY_TYPE_GENERIC)\n  {\n    /* No action required. */\n  }\n  else if (JERRY_LIKELY (property_desc_type == current_property_type))\n  {\n    /* If property is configurable, there is no need for checks. */\n    if (JERRY_UNLIKELY (!is_current_configurable))\n    {\n      if (property_desc_type == ECMA_PROPERTY_TYPE_NAMEDDATA)\n      {\n        /* 10. a. i. & ii. */\n        if (!ecma_is_property_writable (current_prop)\n            && ((property_desc_p->flags & ECMA_PROP_IS_WRITABLE)\n                || ((property_desc_p->flags & ECMA_PROP_IS_VALUE_DEFINED)\n                    && !ecma_op_same_value (property_desc_p->value,\n                                            ext_property_ref.property_ref.value_p->value))))\n        {\n          return ecma_reject (property_desc_p->flags & ECMA_PROP_IS_THROW);\n        }\n      }\n      else\n      {\n        /* 11. */\n\n        /* a. */\n        ecma_property_value_t *value_p = ext_property_ref.property_ref.value_p;\n\n        ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (value_p);\n        jmem_cpointer_t prop_desc_getter_cp, prop_desc_setter_cp;\n        ECMA_SET_POINTER (prop_desc_getter_cp, property_desc_p->get_p);\n        ECMA_SET_POINTER (prop_desc_setter_cp, property_desc_p->set_p);\n\n        if (((property_desc_p->flags & ECMA_PROP_IS_GET_DEFINED)\n             && prop_desc_getter_cp != get_set_pair_p->getter_cp)\n            || ((property_desc_p->flags & ECMA_PROP_IS_SET_DEFINED)\n                && prop_desc_setter_cp != get_set_pair_p->setter_cp))\n        {\n          /* i., ii. */\n          return ecma_reject (property_desc_p->flags & ECMA_PROP_IS_THROW);\n        }\n      }\n    }\n  }\n  else\n  {\n    /* 9. */\n    if (!is_current_configurable)\n    {\n      /* a. */\n      return ecma_reject (property_desc_p->flags & ECMA_PROP_IS_THROW);\n    }\n\n    ecma_property_value_t *value_p = ext_property_ref.property_ref.value_p;\n\n    if (property_desc_type == ECMA_PROPERTY_TYPE_NAMEDACCESSOR)\n    {\n      JERRY_ASSERT (current_property_type == ECMA_PROPERTY_TYPE_NAMEDDATA);\n      ecma_free_value_if_not_object (value_p->value);\n\n#if ENABLED (JERRY_CPOINTER_32_BIT)\n      ecma_getter_setter_pointers_t *getter_setter_pair_p;\n      getter_setter_pair_p = jmem_pools_alloc (sizeof (ecma_getter_setter_pointers_t));\n      getter_setter_pair_p->getter_cp = JMEM_CP_NULL;\n      getter_setter_pair_p->setter_cp = JMEM_CP_NULL;\n      ECMA_SET_NON_NULL_POINTER (value_p->getter_setter_pair_cp, getter_setter_pair_p);\n#else /* !ENABLED (JERRY_CPOINTER_32_BIT) */\n      value_p->getter_setter_pair.getter_cp = JMEM_CP_NULL;\n      value_p->getter_setter_pair.setter_cp = JMEM_CP_NULL;\n#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */\n    }\n    else\n    {\n      JERRY_ASSERT (current_property_type == ECMA_PROPERTY_TYPE_NAMEDACCESSOR);\n#if ENABLED (JERRY_CPOINTER_32_BIT)\n      ecma_getter_setter_pointers_t *getter_setter_pair_p;\n      getter_setter_pair_p = ECMA_GET_NON_NULL_POINTER (ecma_getter_setter_pointers_t,\n                                                        value_p->getter_setter_pair_cp);\n      jmem_pools_free (getter_setter_pair_p, sizeof (ecma_getter_setter_pointers_t));\n#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */\n      value_p->value = ECMA_VALUE_UNDEFINED;\n    }\n\n    /* Update flags */\n    ecma_property_t prop_flags = *(ext_property_ref.property_p);\n    prop_flags = (ecma_property_t) (prop_flags & ~(ECMA_PROPERTY_TYPE_MASK | ECMA_PROPERTY_FLAG_WRITABLE));\n    prop_flags = (ecma_property_t) (prop_flags | property_desc_type);\n    *(ext_property_ref.property_p) = prop_flags;\n  }\n\n  /* 12. */\n  if (property_desc_type == ECMA_PROPERTY_TYPE_NAMEDDATA)\n  {\n    JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*ext_property_ref.property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA);\n\n    if (property_desc_p->flags & ECMA_PROP_IS_VALUE_DEFINED)\n    {\n      ecma_named_data_property_assign_value (object_p,\n                                             ext_property_ref.property_ref.value_p,\n                                             property_desc_p->value);\n    }\n\n    if (property_desc_p->flags & ECMA_PROP_IS_WRITABLE_DEFINED)\n    {\n      ecma_set_property_writable_attr (ext_property_ref.property_p, (property_desc_p->flags & ECMA_PROP_IS_WRITABLE));\n    }\n  }\n  else if (property_desc_type == ECMA_PROPERTY_TYPE_NAMEDACCESSOR)\n  {\n    JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*ext_property_ref.property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR);\n\n    if (property_desc_p->flags & ECMA_PROP_IS_GET_DEFINED)\n    {\n      ecma_set_named_accessor_property_getter (object_p,\n                                               ext_property_ref.property_ref.value_p,\n                                               property_desc_p->get_p);\n    }\n\n    if (property_desc_p->flags & ECMA_PROP_IS_SET_DEFINED)\n    {\n      ecma_set_named_accessor_property_setter (object_p,\n                                               ext_property_ref.property_ref.value_p,\n                                               property_desc_p->set_p);\n    }\n  }\n\n  if (property_desc_p->flags & ECMA_PROP_IS_ENUMERABLE_DEFINED)\n  {\n    ecma_set_property_enumerable_attr (ext_property_ref.property_p,\n                                       (property_desc_p->flags & ECMA_PROP_IS_ENUMERABLE));\n  }\n\n  if (property_desc_p->flags & ECMA_PROP_IS_CONFIGURABLE_DEFINED)\n  {\n    ecma_set_property_configurable_attr (ext_property_ref.property_p,\n                                         (property_desc_p->flags & ECMA_PROP_IS_CONFIGURABLE));\n  }\n\n  return ECMA_VALUE_TRUE;\n}",
        "begin_line": 360,
        "end_line": 635,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_define_own_property#1745",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_define_own_property (ecma_object_t *obj_p, /**< the object */                                     ecma_string_t *property_name_p, /**< property name */                                     const ecma_property_descriptor_t *property_desc_p) /**< property                                                                                         *   descriptor */",
        "snippet": "ecma_value_t\necma_op_object_define_own_property (ecma_object_t *obj_p, /**< the object */\n                                    ecma_string_t *property_name_p, /**< property name */\n                                    const ecma_property_descriptor_t *property_desc_p) /**< property\n                                                                                        *   descriptor */\n{\n  JERRY_ASSERT (obj_p != NULL\n                && !ecma_is_lexical_environment (obj_p));\n  JERRY_ASSERT (property_name_p != NULL);\n\n  const ecma_object_type_t type = ecma_get_object_type (obj_p);\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_IS_PROXY (obj_p))\n  {\n    return ecma_proxy_object_define_own_property (obj_p, property_name_p, property_desc_p);\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  switch (type)\n  {\n    case ECMA_OBJECT_TYPE_GENERAL:\n    case ECMA_OBJECT_TYPE_CLASS:\n    case ECMA_OBJECT_TYPE_FUNCTION:\n    case ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION:\n    case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n    {\n      return ecma_op_general_object_define_own_property (obj_p,\n                                                         property_name_p,\n                                                         property_desc_p);\n    }\n\n    case ECMA_OBJECT_TYPE_ARRAY:\n    {\n      return ecma_op_array_object_define_own_property (obj_p,\n                                                       property_name_p,\n                                                       property_desc_p);\n    }\n\n    default:\n    {\n      JERRY_ASSERT (type == ECMA_OBJECT_TYPE_PSEUDO_ARRAY);\n\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n      if (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS)\n      {\n#else /* !ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n        JERRY_ASSERT (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS);\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n        return ecma_op_arguments_object_define_own_property (obj_p,\n                                                             property_name_p,\n                                                             property_desc_p);\n#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n      }\n      /* ES2015 9.4.5.3 */\n      if (ecma_object_is_typedarray (obj_p))\n      {\n#if ENABLED (JERRY_ES2015)\n        if (ecma_prop_name_is_symbol (property_name_p))\n        {\n          return ecma_op_general_object_define_own_property (obj_p,\n                                                             property_name_p,\n                                                             property_desc_p);\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n        uint32_t array_index = ecma_string_get_array_index (property_name_p);\n\n        if (array_index != ECMA_STRING_NOT_ARRAY_INDEX)\n        {\n          bool define_status = ecma_op_typedarray_define_index_prop (obj_p,\n                                                                     array_index,\n                                                                     property_desc_p);\n\n          if (define_status)\n          {\n            return ECMA_VALUE_TRUE;\n          }\n\n          return ecma_reject (property_desc_p->flags & ECMA_PROP_IS_THROW);\n        }\n\n        ecma_number_t num = ecma_string_to_number (property_name_p);\n        ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);\n\n        if (ecma_compare_ecma_strings (property_name_p, num_to_str))\n        {\n          ecma_deref_ecma_string (num_to_str);\n\n          return ecma_reject (property_desc_p->flags & ECMA_PROP_IS_THROW);\n        }\n\n        ecma_deref_ecma_string (num_to_str);\n      }\n\n      return ecma_op_general_object_define_own_property (obj_p,\n                                                         property_name_p,\n                                                         property_desc_p);\n#else /* !ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n      break;\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n    }\n  }\n}",
        "begin_line": 1745,
        "end_line": 1849,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_find#729",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_find (ecma_object_t *object_p, /**< the object */                      ecma_string_t *property_name_p) /**< property name */",
        "snippet": "ecma_value_t\necma_op_object_find (ecma_object_t *object_p, /**< the object */\n                     ecma_string_t *property_name_p) /**< property name */\n{\n  ecma_value_t base_value = ecma_make_object_value (object_p);\n\n  while (true)\n  {\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n    if (ECMA_OBJECT_IS_PROXY (object_p))\n    {\n      return ecma_proxy_object_find (object_p, property_name_p);\n    }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n    ecma_value_t value = ecma_op_object_find_own (base_value, object_p, property_name_p);\n\n    if (ecma_is_value_found (value))\n    {\n      return value;\n    }\n\n    if (object_p->u2.prototype_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    object_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, object_p->u2.prototype_cp);\n  }\n\n  return ECMA_VALUE_NOT_FOUND;\n}",
        "begin_line": 729,
        "end_line": 760,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_find_own#444",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_find_own (ecma_value_t base_value, /**< base value */                          ecma_object_t *object_p, /**< target object */                          ecma_string_t *property_name_p) /**< property name */",
        "snippet": "ecma_value_t\necma_op_object_find_own (ecma_value_t base_value, /**< base value */\n                         ecma_object_t *object_p, /**< target object */\n                         ecma_string_t *property_name_p) /**< property name */\n{\n  JERRY_ASSERT (object_p != NULL\n                && !ecma_is_lexical_environment (object_p));\n  JERRY_ASSERT (property_name_p != NULL);\n  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));\n\n  ecma_object_type_t type = ecma_get_object_type (object_p);\n\n  switch (type)\n  {\n    case ECMA_OBJECT_TYPE_CLASS:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      if (ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_STRING_UL)\n      {\n        if (ecma_string_is_length (property_name_p))\n        {\n          ecma_value_t prim_value_p = ext_object_p->u.class_prop.u.value;\n\n          ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);\n          ecma_length_t length = ecma_string_get_length (prim_value_str_p);\n\n          return ecma_make_uint32_value (length);\n        }\n\n        uint32_t index = ecma_string_get_array_index (property_name_p);\n\n        if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n        {\n          ecma_value_t prim_value_p = ext_object_p->u.class_prop.u.value;\n\n          ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);\n\n          if (index < ecma_string_get_length (prim_value_str_p))\n          {\n            ecma_char_t char_at_idx = ecma_string_get_char_at_pos (prim_value_str_p, index);\n            return ecma_make_string_value (ecma_new_ecma_string_from_code_unit (char_at_idx));\n          }\n        }\n      }\n\n      break;\n    }\n    case ECMA_OBJECT_TYPE_ARRAY:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      if (ecma_string_is_length (property_name_p))\n      {\n        return ecma_make_uint32_value (ext_object_p->u.array.length);\n      }\n\n      if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)))\n      {\n        uint32_t index = ecma_string_get_array_index (property_name_p);\n\n        if (JERRY_LIKELY (index != ECMA_STRING_NOT_ARRAY_INDEX))\n        {\n          if (JERRY_LIKELY (index < ext_object_p->u.array.length))\n          {\n            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);\n\n            return (ecma_is_value_array_hole (values_p[index]) ? ECMA_VALUE_NOT_FOUND\n                                                               : ecma_fast_copy_value (values_p[index]));\n          }\n        }\n        return ECMA_VALUE_NOT_FOUND;\n      }\n\n      break;\n    }\n    case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      if (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS)\n      {\n        uint32_t index = ecma_string_get_array_index (property_name_p);\n\n        if (index != ECMA_STRING_NOT_ARRAY_INDEX\n            && index < ext_object_p->u.pseudo_array.u1.length)\n        {\n          ecma_value_t *arg_Literal_p = (ecma_value_t *) (ext_object_p + 1);\n\n          if (arg_Literal_p[index] != ECMA_VALUE_EMPTY)\n          {\n            ecma_string_t *arg_name_p = ecma_get_string_from_value (arg_Literal_p[index]);\n\n            ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t,\n                                                                        ext_object_p->u.pseudo_array.u2.lex_env_cp);\n\n            JERRY_ASSERT (lex_env_p != NULL\n                          && ecma_is_lexical_environment (lex_env_p));\n\n            return ecma_op_get_binding_value (lex_env_p, arg_name_p, true);\n          }\n        }\n      }\n#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n      /* ES2015 9.4.5.4 */\n      if (ecma_object_is_typedarray (object_p))\n      {\n#if ENABLED (JERRY_ES2015)\n        if (ecma_prop_name_is_symbol (property_name_p))\n        {\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        uint32_t array_index = ecma_string_get_array_index (property_name_p);\n\n        if (array_index != ECMA_STRING_NOT_ARRAY_INDEX)\n        {\n          ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);\n\n          if (array_index >= info.length)\n          {\n            return ECMA_VALUE_UNDEFINED;\n          }\n\n          ecma_length_t byte_pos = array_index << info.shift;\n          ecma_number_t num = ecma_get_typedarray_element (info.buffer_p + byte_pos, info.id);\n          return ecma_make_number_value (num);\n        }\n\n        ecma_number_t num = ecma_string_to_number (property_name_p);\n        ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);\n\n        if (ecma_compare_ecma_strings (property_name_p, num_to_str))\n        {\n          ecma_deref_ecma_string (num_to_str);\n\n          return ECMA_VALUE_UNDEFINED;\n        }\n\n        ecma_deref_ecma_string (num_to_str);\n      }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n\n      break;\n    }\n    default:\n    {\n      break;\n    }\n  }\n\n  ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);\n\n  if (property_p == NULL)\n  {\n    if (ecma_get_object_is_builtin (object_p))\n    {\n      if (type == ECMA_OBJECT_TYPE_FUNCTION && ecma_builtin_function_is_routine (object_p))\n      {\n        property_p = ecma_builtin_routine_try_to_instantiate_property (object_p, property_name_p);\n      }\n      else\n      {\n        property_p = ecma_builtin_try_to_instantiate_property (object_p, property_name_p);\n      }\n    }\n    else if (type == ECMA_OBJECT_TYPE_FUNCTION)\n    {\n#if !ENABLED (JERRY_ES2015)\n      if (ecma_string_is_length (property_name_p))\n      {\n        /* Get length virtual property. */\n        ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;\n        const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);\n\n        uint32_t len;\n        if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n        {\n          cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_data_p;\n          len = args_p->argument_end;\n        }\n        else\n        {\n          cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_data_p;\n          len = args_p->argument_end;\n        }\n\n        return ecma_make_uint32_value (len);\n      }\n#endif /* !ENABLED (JERRY_ES2015) */\n\n      /* Get prototype physical property. */\n      property_p = ecma_op_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n    }\n    else if (type == ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION)\n    {\n      property_p = ecma_op_external_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n    }\n    else if (type == ECMA_OBJECT_TYPE_BOUND_FUNCTION)\n    {\n      property_p = ecma_op_bound_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n    }\n\n    if (property_p == NULL)\n    {\n      return ECMA_VALUE_NOT_FOUND;\n    }\n  }\n\n  ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n  if (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA)\n  {\n    return ecma_fast_copy_value (prop_value_p->value);\n  }\n\n  JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR);\n\n  ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (prop_value_p);\n\n  if (get_set_pair_p->getter_cp == JMEM_CP_NULL)\n  {\n    return ECMA_VALUE_UNDEFINED;\n  }\n\n  ecma_object_t *getter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp);\n\n  return ecma_op_function_call (getter_p, base_value, NULL, 0);\n}",
        "begin_line": 444,
        "end_line": 673,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_own_property#71",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_own_property (ecma_object_t *object_p, /**< the object */                                  ecma_string_t *property_name_p, /**< property name */                                  ecma_property_ref_t *property_ref_p, /**< property reference */                                  uint32_t options) /**< option bits */",
        "snippet": "ecma_property_t\necma_op_object_get_own_property (ecma_object_t *object_p, /**< the object */\n                                 ecma_string_t *property_name_p, /**< property name */\n                                 ecma_property_ref_t *property_ref_p, /**< property reference */\n                                 uint32_t options) /**< option bits */\n{\n  JERRY_ASSERT (object_p != NULL\n                && !ecma_is_lexical_environment (object_p));\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n  JERRY_ASSERT (property_name_p != NULL);\n  JERRY_ASSERT (options == ECMA_PROPERTY_GET_NO_OPTIONS\n                || options == ECMA_PROPERTY_GET_HAS_OWN_PROP\n                || property_ref_p != NULL);\n\n  ecma_object_type_t type = ecma_get_object_type (object_p);\n\n  switch (type)\n  {\n    case ECMA_OBJECT_TYPE_CLASS:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      if (ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_STRING_UL)\n      {\n        if (ecma_string_is_length (property_name_p))\n        {\n          if (options & ECMA_PROPERTY_GET_VALUE)\n          {\n            ecma_value_t prim_value_p = ext_object_p->u.class_prop.u.value;\n            ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);\n\n            ecma_length_t length = ecma_string_get_length (prim_value_str_p);\n            property_ref_p->virtual_value = ecma_make_uint32_value (length);\n          }\n\n          return ECMA_PROPERTY_TYPE_VIRTUAL;\n        }\n\n        uint32_t index = ecma_string_get_array_index (property_name_p);\n\n        if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n        {\n          ecma_value_t prim_value_p = ext_object_p->u.class_prop.u.value;\n          ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);\n\n          if (index < ecma_string_get_length (prim_value_str_p))\n          {\n            if (options & ECMA_PROPERTY_GET_VALUE)\n            {\n              ecma_char_t char_at_idx = ecma_string_get_char_at_pos (prim_value_str_p, index);\n              ecma_string_t *char_str_p = ecma_new_ecma_string_from_code_unit (char_at_idx);\n              property_ref_p->virtual_value = ecma_make_string_value (char_str_p);\n            }\n\n            return ECMA_PROPERTY_FLAG_ENUMERABLE | ECMA_PROPERTY_TYPE_VIRTUAL;\n          }\n        }\n      }\n      break;\n    }\n    case ECMA_OBJECT_TYPE_ARRAY:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      if (ecma_string_is_length (property_name_p))\n      {\n        if (options & ECMA_PROPERTY_GET_VALUE)\n        {\n          property_ref_p->virtual_value = ecma_make_uint32_value (ext_object_p->u.array.length);\n        }\n\n        return ext_object_p->u.array.u.length_prop & (ECMA_PROPERTY_TYPE_VIRTUAL | ECMA_PROPERTY_FLAG_WRITABLE);\n      }\n\n      if (ecma_op_array_is_fast_array (ext_object_p))\n      {\n        uint32_t index = ecma_string_get_array_index (property_name_p);\n\n        if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n        {\n          if (JERRY_LIKELY (index < ext_object_p->u.array.length))\n          {\n            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);\n\n            if (ecma_is_value_array_hole (values_p[index]))\n            {\n              return ECMA_PROPERTY_TYPE_NOT_FOUND;\n            }\n\n            if (options & ECMA_PROPERTY_GET_VALUE)\n            {\n              property_ref_p->virtual_value = ecma_fast_copy_value (values_p[index]);\n            }\n\n            return (ecma_property_t) (ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | ECMA_PROPERTY_TYPE_VIRTUAL);\n          }\n        }\n\n        return ECMA_PROPERTY_TYPE_NOT_FOUND;\n      }\n\n      break;\n    }\n#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n    case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:\n    {\n      /* ES2015 9.4.5.1 */\n      if (ecma_object_is_typedarray (object_p))\n      {\n#if ENABLED (JERRY_ES2015)\n        if (ecma_prop_name_is_symbol (property_name_p))\n        {\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        uint32_t array_index = ecma_string_get_array_index (property_name_p);\n\n        if (array_index != ECMA_STRING_NOT_ARRAY_INDEX)\n        {\n          ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);\n          ecma_value_t value = ECMA_VALUE_UNDEFINED;\n\n          if (array_index < info.length)\n          {\n            ecma_length_t byte_pos = array_index << info.shift;\n            ecma_number_t num = ecma_get_typedarray_element (info.buffer_p + byte_pos, info.id);\n            value = ecma_make_number_value (num);\n          }\n\n          if (!ecma_is_value_undefined (value))\n          {\n            if (options & ECMA_PROPERTY_GET_VALUE)\n            {\n              property_ref_p->virtual_value = value;\n            }\n            else\n            {\n              ecma_fast_free_value (value);\n            }\n\n            return ECMA_PROPERTY_ENUMERABLE_WRITABLE | ECMA_PROPERTY_TYPE_VIRTUAL;\n          }\n\n          return ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP;\n        }\n\n        ecma_number_t num = ecma_string_to_number (property_name_p);\n        ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);\n\n        if (ecma_compare_ecma_strings (property_name_p, num_to_str))\n        {\n          ecma_deref_ecma_string (num_to_str);\n\n          return ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP;\n        }\n\n        ecma_deref_ecma_string (num_to_str);\n      }\n\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n    default:\n    {\n      break;\n    }\n  }\n\n  ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);\n\n  if (property_p == NULL)\n  {\n    if (ecma_get_object_is_builtin (object_p))\n    {\n      if (type == ECMA_OBJECT_TYPE_FUNCTION && ecma_builtin_function_is_routine (object_p))\n      {\n        property_p = ecma_builtin_routine_try_to_instantiate_property (object_p, property_name_p);\n      }\n      else\n      {\n        property_p = ecma_builtin_try_to_instantiate_property (object_p, property_name_p);\n      }\n    }\n    else if (type == ECMA_OBJECT_TYPE_FUNCTION)\n    {\n#if !ENABLED (JERRY_ES2015)\n      if (ecma_string_is_length (property_name_p))\n      {\n        if (options & ECMA_PROPERTY_GET_VALUE)\n        {\n          /* Get length virtual property. */\n          ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;\n          const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);\n\n          uint32_t len;\n          if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n          {\n            cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_data_p;\n            len = args_p->argument_end;\n          }\n          else\n          {\n            cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_data_p;\n            len = args_p->argument_end;\n          }\n\n          property_ref_p->virtual_value = ecma_make_uint32_value (len);\n        }\n\n        return ECMA_PROPERTY_TYPE_VIRTUAL;\n      }\n#endif /* !ENABLED (JERRY_ES2015) */\n\n      /* Get prototype physical property. */\n      property_p = ecma_op_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n    }\n    else if (type == ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION)\n    {\n      property_p = ecma_op_external_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n    }\n    else if (type == ECMA_OBJECT_TYPE_BOUND_FUNCTION)\n    {\n      property_p = ecma_op_bound_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n    }\n\n    if (property_p == NULL)\n    {\n      return ECMA_PROPERTY_TYPE_NOT_FOUND;\n    }\n  }\n  else if (type == ECMA_OBJECT_TYPE_PSEUDO_ARRAY\n           && (options & ECMA_PROPERTY_GET_HAS_OWN_PROP))\n  {\n    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n    if (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS)\n    {\n      uint32_t index = ecma_string_get_array_index (property_name_p);\n\n      if (index != ECMA_STRING_NOT_ARRAY_INDEX\n          && index < ext_object_p->u.pseudo_array.u1.length)\n      {\n        ecma_value_t *arg_Literal_p = (ecma_value_t *) (ext_object_p + 1);\n\n        if (arg_Literal_p[index] != ECMA_VALUE_EMPTY)\n        {\n          ecma_string_t *arg_name_p = ecma_get_string_from_value (arg_Literal_p[index]);\n\n          ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t,\n                                                                      ext_object_p->u.pseudo_array.u2.lex_env_cp);\n\n          JERRY_ASSERT (lex_env_p != NULL\n                        && ecma_is_lexical_environment (lex_env_p));\n\n          ecma_value_t binding_value = ecma_op_get_binding_value (lex_env_p, arg_name_p, true);\n\n          ecma_named_data_property_assign_value (object_p,\n                                                 ECMA_PROPERTY_VALUE_PTR (property_p),\n                                                 binding_value);\n          ecma_free_value (binding_value);\n        }\n      }\n    }\n  }\n\n  if (options & ECMA_PROPERTY_GET_EXT_REFERENCE)\n  {\n    ((ecma_extended_property_ref_t *) property_ref_p)->property_p = property_p;\n  }\n\n  if (property_ref_p != NULL)\n  {\n    property_ref_p->value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n  }\n\n  return *property_p;\n}",
        "begin_line": 71,
        "end_line": 350,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_own_property_descriptor#1864",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_own_property_descriptor (ecma_object_t *object_p, /**< the object */                                             ecma_string_t *property_name_p, /**< property name */                                             ecma_property_descriptor_t *prop_desc_p) /**< property descriptor */",
        "snippet": "ecma_value_t\necma_op_object_get_own_property_descriptor (ecma_object_t *object_p, /**< the object */\n                                            ecma_string_t *property_name_p, /**< property name */\n                                            ecma_property_descriptor_t *prop_desc_p) /**< property descriptor */\n{\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_IS_PROXY (object_p))\n  {\n    return ecma_proxy_object_get_own_property_descriptor (object_p, property_name_p, prop_desc_p);\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  ecma_property_ref_t property_ref;\n\n  ecma_property_t property = ecma_op_object_get_own_property (object_p,\n                                                              property_name_p,\n                                                              &property_ref,\n                                                              ECMA_PROPERTY_GET_VALUE);\n\n  if (property == ECMA_PROPERTY_TYPE_NOT_FOUND || property == ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP)\n  {\n    return ECMA_VALUE_FALSE;\n  }\n\n  *prop_desc_p = ecma_make_empty_property_descriptor ();\n\n  uint32_t flags = ecma_is_property_enumerable (property) ? ECMA_PROP_IS_ENUMERABLE : ECMA_PROP_NO_OPTS;\n  flags |= ecma_is_property_configurable (property) ? ECMA_PROP_IS_CONFIGURABLE: ECMA_PROP_NO_OPTS;\n\n  prop_desc_p->flags = (uint16_t) (ECMA_PROP_IS_ENUMERABLE_DEFINED | ECMA_PROP_IS_CONFIGURABLE_DEFINED | flags);\n\n  ecma_property_types_t type = ECMA_PROPERTY_GET_TYPE (property);\n\n  if (type != ECMA_PROPERTY_TYPE_NAMEDACCESSOR)\n  {\n    if (type == ECMA_PROPERTY_TYPE_NAMEDDATA)\n    {\n      prop_desc_p->value = ecma_copy_value (property_ref.value_p->value);\n    }\n    else\n    {\n      JERRY_ASSERT (type == ECMA_PROPERTY_TYPE_VIRTUAL);\n      prop_desc_p->value = property_ref.virtual_value;\n    }\n\n    prop_desc_p->flags |= (ECMA_PROP_IS_VALUE_DEFINED | ECMA_PROP_IS_WRITABLE_DEFINED);\n    prop_desc_p->flags = (uint16_t) (prop_desc_p->flags | (ecma_is_property_writable (property) ? ECMA_PROP_IS_WRITABLE\n                                                                                                : ECMA_PROP_NO_OPTS));\n  }\n  else\n  {\n\n    ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (property_ref.value_p);\n    prop_desc_p->flags |= (ECMA_PROP_IS_GET_DEFINED | ECMA_PROP_IS_SET_DEFINED);\n\n    if (get_set_pair_p->getter_cp == JMEM_CP_NULL)\n    {\n      prop_desc_p->get_p = NULL;\n    }\n    else\n    {\n      prop_desc_p->get_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp);\n      ecma_ref_object (prop_desc_p->get_p);\n    }\n\n    if (get_set_pair_p->setter_cp == JMEM_CP_NULL)\n    {\n      prop_desc_p->set_p = NULL;\n    }\n    else\n    {\n      prop_desc_p->set_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->setter_cp);\n      ecma_ref_object (prop_desc_p->set_p);\n    }\n  }\n\n  return ECMA_VALUE_TRUE;\n}",
        "begin_line": 1864,
        "end_line": 1941,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_property#361",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_property (ecma_object_t *object_p, /**< the object */                              ecma_string_t *property_name_p, /**< property name */                              ecma_property_ref_t *property_ref_p, /**< property reference */                              uint32_t options) /**< option bits */",
        "snippet": "static ecma_property_t\necma_op_object_get_property (ecma_object_t *object_p, /**< the object */\n                             ecma_string_t *property_name_p, /**< property name */\n                             ecma_property_ref_t *property_ref_p, /**< property reference */\n                             uint32_t options) /**< option bits */\n{\n  while (true)\n  {\n    ecma_property_t property = ecma_op_object_get_own_property (object_p,\n                                                                property_name_p,\n                                                                property_ref_p,\n                                                                options);\n\n    if (property != ECMA_PROPERTY_TYPE_NOT_FOUND && property != ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP)\n    {\n      return property;\n    }\n\n    if (property == ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP)\n    {\n      break;\n    }\n\n    if (object_p->u2.prototype_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    object_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, object_p->u2.prototype_cp);\n  }\n\n  return ECMA_PROPERTY_TYPE_NOT_FOUND;\n}",
        "begin_line": 361,
        "end_line": 393,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_with_receiver#830",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_with_receiver (ecma_object_t *object_p, /**< the object */                                   ecma_string_t *property_name_p, /**< property name */                                   ecma_value_t receiver) /**< receiver to invoke getter function */",
        "snippet": "ecma_value_t\necma_op_object_get_with_receiver (ecma_object_t *object_p, /**< the object */\n                                  ecma_string_t *property_name_p, /**< property name */\n                                  ecma_value_t receiver) /**< receiver to invoke getter function */\n{\n  while (true)\n  {\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n    if (ECMA_OBJECT_IS_PROXY (object_p))\n    {\n      return ecma_proxy_object_get (object_p, property_name_p, receiver);\n    }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n    ecma_value_t value = ecma_op_object_find_own (receiver, object_p, property_name_p);\n\n    if (ecma_is_value_found (value))\n    {\n      return value;\n    }\n\n    jmem_cpointer_t proto_cp = ecma_op_ordinary_object_get_prototype_of (object_p);\n\n    if (proto_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    object_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp);\n  }\n\n  return ECMA_VALUE_UNDEFINED;\n}",
        "begin_line": 830,
        "end_line": 862,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_put_with_receiver#1250",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_put_with_receiver (ecma_object_t *object_p, /**< the object */                                   ecma_string_t *property_name_p, /**< property name */                                   ecma_value_t value, /**< ecma value */                                   ecma_value_t receiver, /**< receiver */                                   bool is_throw) /**< flag that controls failure handling */",
        "snippet": "ecma_value_t\necma_op_object_put_with_receiver (ecma_object_t *object_p, /**< the object */\n                                  ecma_string_t *property_name_p, /**< property name */\n                                  ecma_value_t value, /**< ecma value */\n                                  ecma_value_t receiver, /**< receiver */\n                                  bool is_throw) /**< flag that controls failure handling */\n{\n  JERRY_ASSERT (object_p != NULL\n                && !ecma_is_lexical_environment (object_p));\n  JERRY_ASSERT (property_name_p != NULL);\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_IS_PROXY (object_p))\n  {\n    return ecma_proxy_object_set (object_p, property_name_p, value, receiver);\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  ecma_object_type_t type = ecma_get_object_type (object_p);\n\n  switch (type)\n  {\n    case ECMA_OBJECT_TYPE_ARRAY:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      if (ecma_string_is_length (property_name_p))\n      {\n        if (ecma_is_property_writable (ext_object_p->u.array.u.length_prop))\n        {\n          return ecma_op_array_object_set_length (object_p, value, 0);\n        }\n\n        return ecma_reject (is_throw);\n      }\n\n      if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)))\n      {\n        if (JERRY_UNLIKELY (!ecma_op_ordinary_object_is_extensible (object_p)))\n        {\n          return ecma_reject (is_throw);\n        }\n\n        uint32_t index = ecma_string_get_array_index (property_name_p);\n\n        if (JERRY_UNLIKELY (index == ECMA_STRING_NOT_ARRAY_INDEX))\n        {\n          ecma_fast_array_convert_to_normal (object_p);\n        }\n        else if (ecma_fast_array_set_property (object_p, index, value))\n        {\n          return ECMA_VALUE_TRUE;\n        }\n      }\n\n      JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));\n\n      break;\n    }\n    case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      if (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS)\n      {\n        uint32_t index = ecma_string_get_array_index (property_name_p);\n\n        if (index != ECMA_STRING_NOT_ARRAY_INDEX\n            && index < ext_object_p->u.pseudo_array.u1.length)\n        {\n          ecma_value_t *arg_Literal_p = (ecma_value_t *) (ext_object_p + 1);\n\n          if (arg_Literal_p[index] != ECMA_VALUE_EMPTY)\n          {\n            ecma_string_t *arg_name_p = ecma_get_string_from_value (arg_Literal_p[index]);\n\n            ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t,\n                                                                        ext_object_p->u.pseudo_array.u2.lex_env_cp);\n\n            JERRY_ASSERT (lex_env_p != NULL\n                          && ecma_is_lexical_environment (lex_env_p));\n\n            ecma_op_set_mutable_binding (lex_env_p, arg_name_p, value, true);\n            return ECMA_VALUE_TRUE;\n          }\n        }\n      }\n#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n      /* ES2015 9.4.5.5 */\n      if (ecma_object_is_typedarray (object_p))\n      {\n#if ENABLED (JERRY_ES2015)\n        if (ecma_prop_name_is_symbol (property_name_p))\n        {\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        uint32_t array_index = ecma_string_get_array_index (property_name_p);\n\n        if (array_index != ECMA_STRING_NOT_ARRAY_INDEX)\n        {\n          ecma_number_t num_var;\n          ecma_value_t error = ecma_get_number (value, &num_var);\n\n          if (ECMA_IS_VALUE_ERROR (error))\n          {\n            jcontext_release_exception ();\n            return ecma_reject (is_throw);\n          }\n\n          ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);\n\n          if (array_index >= info.length)\n          {\n            return ecma_reject (is_throw);\n          }\n\n          ecma_length_t byte_pos = array_index << info.shift;\n          ecma_set_typedarray_element (info.buffer_p + byte_pos, num_var, info.id);\n\n          return ECMA_VALUE_TRUE;\n        }\n\n        ecma_number_t num = ecma_string_to_number (property_name_p);\n        ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);\n\n        if (ecma_compare_ecma_strings (property_name_p, num_to_str))\n        {\n          ecma_deref_ecma_string (num_to_str);\n\n          return ecma_reject (is_throw);\n        }\n\n        ecma_deref_ecma_string (num_to_str);\n      }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n      break;\n    }\n    default:\n    {\n      break;\n    }\n  }\n\n  ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);\n\n  if (property_p == NULL)\n  {\n    if (type == ECMA_OBJECT_TYPE_CLASS)\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      if (ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_STRING_UL)\n      {\n        uint32_t index = ecma_string_get_array_index (property_name_p);\n\n        if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n        {\n          ecma_value_t prim_value_p = ext_object_p->u.class_prop.u.value;\n          ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);\n\n          if (index < ecma_string_get_length (prim_value_str_p))\n          {\n            return ecma_reject (is_throw);\n          }\n        }\n      }\n    }\n\n    if (ecma_get_object_is_builtin (object_p))\n    {\n      if (type == ECMA_OBJECT_TYPE_FUNCTION && ecma_builtin_function_is_routine (object_p))\n      {\n        property_p = ecma_builtin_routine_try_to_instantiate_property (object_p, property_name_p);\n      }\n      else\n      {\n        property_p = ecma_builtin_try_to_instantiate_property (object_p, property_name_p);\n      }\n    }\n    else if (type == ECMA_OBJECT_TYPE_FUNCTION)\n    {\n#if ENABLED (JERRY_ES2015)\n      /* Uninitialized 'length' property is non-writable (ECMA-262 v6, 19.2.4.1) */\n      if ((ecma_string_is_length (property_name_p))\n          && (!ECMA_GET_FIRST_BIT_FROM_POINTER_TAG (((ecma_extended_object_t *) object_p)->u.function.scope_cp)))\n      {\n        return ecma_reject (is_throw);\n      }\n#else /* !ENABLED (JERRY_ES2015) */\n      if (ecma_string_is_length (property_name_p))\n      {\n        return ecma_reject (is_throw);\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      /* Get prototype physical property. */\n      property_p = ecma_op_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n    }\n    else if (type == ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION)\n    {\n      property_p = ecma_op_external_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n    }\n    else if (type == ECMA_OBJECT_TYPE_BOUND_FUNCTION)\n    {\n      property_p = ecma_op_bound_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n    }\n  }\n\n  jmem_cpointer_t setter_cp = JMEM_CP_NULL;\n\n  if (property_p != NULL)\n  {\n    if (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA)\n    {\n      if (ecma_is_property_writable (*property_p))\n      {\n#if ENABLED (JERRY_ES2015)\n        if (ecma_make_object_value (object_p) != receiver)\n        {\n          return ecma_op_object_put_apply_receiver (receiver, property_name_p, value, is_throw);\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        /* There is no need for special casing arrays here because changing the\n         * value of an existing property never changes the length of an array. */\n        ecma_named_data_property_assign_value (object_p,\n                                               ECMA_PROPERTY_VALUE_PTR (property_p),\n                                               value);\n        return ECMA_VALUE_TRUE;\n      }\n    }\n    else\n    {\n      JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR);\n\n      ecma_getter_setter_pointers_t *get_set_pair_p;\n      get_set_pair_p = ecma_get_named_accessor_property (ECMA_PROPERTY_VALUE_PTR (property_p));\n      setter_cp = get_set_pair_p->setter_cp;\n    }\n  }\n  else\n  {\n    bool create_new_property = true;\n\n    jmem_cpointer_t proto_cp = ecma_op_ordinary_object_get_prototype_of (object_p);\n\n    if (proto_cp != JMEM_CP_NULL)\n    {\n      ecma_property_ref_t property_ref = { NULL };\n      ecma_object_t *proto_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp);\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n      if (ECMA_OBJECT_IS_PROXY (proto_p))\n      {\n        return ecma_op_object_put_with_receiver (proto_p,\n                                                 property_name_p,\n                                                 value,\n                                                 receiver,\n                                                 is_throw);\n      }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n      ecma_property_t inherited_property = ecma_op_object_get_property (proto_p,\n                                                                        property_name_p,\n                                                                        &property_ref,\n                                                                        ECMA_PROPERTY_GET_NO_OPTIONS);\n\n      if (inherited_property != ECMA_PROPERTY_TYPE_NOT_FOUND)\n      {\n        if (ECMA_PROPERTY_GET_TYPE (inherited_property) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR)\n        {\n          setter_cp = ecma_get_named_accessor_property (property_ref.value_p)->setter_cp;\n          create_new_property = false;\n        }\n        else\n        {\n          create_new_property = ecma_is_property_writable (inherited_property);\n        }\n      }\n    }\n\n    if (create_new_property\n        && ecma_op_ordinary_object_is_extensible (object_p))\n    {\n      const ecma_object_type_t obj_type = ecma_get_object_type (object_p);\n\n      if (obj_type == ECMA_OBJECT_TYPE_PSEUDO_ARRAY)\n      {\n        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n        if (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS)\n        {\n          return ecma_builtin_helper_def_prop (object_p,\n                                               property_name_p,\n                                               value,\n                                               ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | ECMA_IS_THROW);\n        }\n      }\n\n      uint32_t index = ecma_string_get_array_index (property_name_p);\n\n      if (obj_type == ECMA_OBJECT_TYPE_ARRAY\n          && index != ECMA_STRING_NOT_ARRAY_INDEX)\n      {\n        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n        if (index < UINT32_MAX\n            && index >= ext_object_p->u.array.length)\n        {\n          if (!ecma_is_property_writable (ext_object_p->u.array.u.length_prop))\n          {\n            return ecma_reject (is_throw);\n          }\n\n          ext_object_p->u.array.length = index + 1;\n        }\n      }\n\n#if ENABLED (JERRY_ES2015)\n      return ecma_op_object_put_apply_receiver (receiver, property_name_p, value, is_throw);\n#endif /* ENABLED (JERRY_ES2015) */\n\n      ecma_property_value_t *new_prop_value_p;\n      new_prop_value_p = ecma_create_named_data_property (object_p,\n                                                          property_name_p,\n                                                          ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,\n                                                          NULL);\n\n      JERRY_ASSERT (ecma_is_value_undefined (new_prop_value_p->value));\n      new_prop_value_p->value = ecma_copy_value_if_not_object (value);\n      return ECMA_VALUE_TRUE;\n    }\n  }\n\n  if (setter_cp == JMEM_CP_NULL)\n  {\n    return ecma_reject (is_throw);\n  }\n\n  ecma_value_t ret_value = ecma_op_function_call (ECMA_GET_NON_NULL_POINTER (ecma_object_t, setter_cp),\n                                                  receiver,\n                                                  &value,\n                                                  1);\n\n  if (!ECMA_IS_VALUE_ERROR (ret_value))\n  {\n    ecma_fast_free_value (ret_value);\n    ret_value = ECMA_VALUE_TRUE;\n  }\n\n  return ret_value;\n}",
        "begin_line": 1250,
        "end_line": 1603,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-reference.ecma_op_object_bound_environment_resolve_reference_value#201",
        "src_path": "jerry-core/ecma/operations/ecma-reference.c",
        "class_name": "jerry-core.ecma.operations.ecma-reference",
        "signature": "jerry-core.ecma.operations.ecma-reference.ecma_op_object_bound_environment_resolve_reference_value (ecma_object_t *lex_env_p, /**< lexical environment */                                                           ecma_string_t *name_p) /**< variable name */",
        "snippet": "ecma_value_t\necma_op_object_bound_environment_resolve_reference_value (ecma_object_t *lex_env_p, /**< lexical environment */\n                                                          ecma_string_t *name_p) /**< variable name */\n{\n  ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);\n  ecma_value_t found_binding;\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_IS_PROXY (binding_obj_p))\n  {\n    found_binding = ecma_proxy_object_has (binding_obj_p, name_p);\n\n    if (!ecma_is_value_true (found_binding))\n    {\n      return ECMA_IS_VALUE_ERROR (found_binding) ? found_binding : ECMA_VALUE_NOT_FOUND;\n    }\n  }\n  else\n  {\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n    found_binding = ecma_op_object_find (binding_obj_p, name_p);\n\n    if (ECMA_IS_VALUE_ERROR (found_binding) || !ecma_is_value_found (found_binding))\n    {\n      return found_binding;\n    }\n\n#if ENABLED (JERRY_ES2015)\n    if (JERRY_LIKELY (lex_env_p == ecma_get_global_scope ()))\n#endif /* ENABLED (JERRY_ES2015) */\n    {\n      return found_binding;\n    }\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n#if ENABLED (JERRY_ES2015)\n  ecma_value_t blocked = ecma_op_is_prop_unscopable (binding_obj_p, name_p);\n\n  if (ecma_is_value_false (blocked))\n  {\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n    if (ECMA_OBJECT_IS_PROXY (binding_obj_p))\n    {\n      return ecma_proxy_object_get (binding_obj_p, name_p, ecma_make_object_value (binding_obj_p));\n    }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n    return found_binding;\n  }\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (!ECMA_OBJECT_IS_PROXY (binding_obj_p))\n  {\n    ecma_free_value (found_binding);\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  return ECMA_IS_VALUE_ERROR (blocked) ? blocked : ECMA_VALUE_NOT_FOUND;\n#endif /* ENABLED (JERRY_ES2015) */\n}",
        "begin_line": 201,
        "end_line": 261,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-reference.ecma_op_resolve_reference_value#268",
        "src_path": "jerry-core/ecma/operations/ecma-reference.c",
        "class_name": "jerry-core.ecma.operations.ecma-reference",
        "signature": "jerry-core.ecma.operations.ecma-reference.ecma_op_resolve_reference_value (ecma_object_t *lex_env_p, /**< starting lexical environment */                                  ecma_string_t *name_p) /**< identifier's name */",
        "snippet": "ecma_value_t\necma_op_resolve_reference_value (ecma_object_t *lex_env_p, /**< starting lexical environment */\n                                 ecma_string_t *name_p) /**< identifier's name */\n{\n  JERRY_ASSERT (lex_env_p != NULL);\n\n  while (true)\n  {\n    ecma_lexical_environment_type_t lex_env_type = ecma_get_lex_env_type (lex_env_p);\n\n    if (lex_env_type == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n    {\n      ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n      if (property_p != NULL)\n      {\n        ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n#if ENABLED (JERRY_ES2015)\n        if (JERRY_UNLIKELY (property_value_p->value == ECMA_VALUE_UNINITIALIZED))\n        {\n          return ecma_raise_reference_error (ECMA_ERR_MSG (\"Variables declared by let/const must be\"\n                                                           \" initialized before reading their value.\"));\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        return ecma_fast_copy_value (property_value_p->value);\n      }\n    }\n    else if (lex_env_type == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND)\n    {\n#if ENABLED (JERRY_ES2015)\n      bool lcache_lookup_allowed = (lex_env_p == ecma_get_global_environment ());\n#else /* !ENABLED (JERRY_ES2015)*/\n      bool lcache_lookup_allowed = true;\n#endif /* ENABLED (JERRY_ES2015) */\n\n      if (lcache_lookup_allowed)\n      {\n#if ENABLED (JERRY_LCACHE)\n        ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);\n        ecma_property_t *property_p = ecma_lcache_lookup (binding_obj_p, name_p);\n\n        if (property_p != NULL)\n        {\n          ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n          if (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA)\n          {\n            return ecma_fast_copy_value (prop_value_p->value);\n          }\n\n          JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR);\n\n          ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (prop_value_p);\n\n          if (get_set_pair_p->getter_cp == JMEM_CP_NULL)\n          {\n            return ECMA_VALUE_UNDEFINED;\n          }\n\n          ecma_object_t *getter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp);\n\n          ecma_value_t base_value = ecma_make_object_value (binding_obj_p);\n          return ecma_op_function_call (getter_p, base_value, NULL, 0);\n        }\n#endif /* ENABLED (JERRY_LCACHE) */\n      }\n\n      ecma_value_t result = ecma_op_object_bound_environment_resolve_reference_value (lex_env_p, name_p);\n\n      if (ecma_is_value_found (result))\n      {\n        /* Note: the result may contains ECMA_VALUE_ERROR */\n        return result;\n      }\n    }\n    else\n    {\n#if ENABLED (JERRY_ES2015)\n      JERRY_ASSERT (lex_env_type == ECMA_LEXICAL_ENVIRONMENT_HOME_OBJECT_BOUND);\n#else /* !ENABLED (JERRY_ES2015) */\n      JERRY_UNREACHABLE ();\n#endif /* ENABLED (JERRY_ES2015) */\n    }\n\n    if (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);\n  }\n\n#if ENABLED (JERRY_ERROR_MESSAGES)\n  ecma_value_t name_val = ecma_make_string_value (name_p);\n  ecma_value_t error_value = ecma_raise_standard_error_with_format (ECMA_ERROR_REFERENCE,\n                                                                    \"% is not defined\",\n                                                                    name_val);\n#else /* ENABLED (JERRY_ERROR_MESSAGES) */\n  ecma_value_t error_value = ecma_raise_reference_error (NULL);\n#endif /* !ENABLED (JERRY_ERROR_MESSAGES) */\n  return error_value;\n}",
        "begin_line": 268,
        "end_line": 371,
        "is_bug": false
    },
    {
        "name": "jerry-core.jcontext.jcontext.jcontext_take_exception#111",
        "src_path": "jerry-core/jcontext/jcontext.c",
        "class_name": "jerry-core.jcontext.jcontext",
        "signature": "jerry-core.jcontext.jcontext.jcontext_take_exception (void)",
        "snippet": "ecma_value_t\njcontext_take_exception (void)\n{\n  JERRY_ASSERT (jcontext_has_pending_exception ());\n\n  jcontext_set_abort_flag (false);\n  jcontext_set_exception_flag (false);\n  return JERRY_CONTEXT (error_value);\n}",
        "begin_line": 111,
        "end_line": 119,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-allocator.jmem_init#149",
        "src_path": "jerry-core/jmem/jmem-allocator.c",
        "class_name": "jerry-core.jmem.jmem-allocator",
        "signature": "jerry-core.jmem.jmem-allocator.jmem_init (void)",
        "snippet": "void\njmem_init (void)\n{\n  jmem_heap_init ();\n}",
        "begin_line": 149,
        "end_line": 153,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_gc_and_alloc_block#270",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_gc_and_alloc_block (const size_t size, /**< required memory size */                               jmem_pressure_t max_pressure) /**< pressure limit */",
        "snippet": "static void *\njmem_heap_gc_and_alloc_block (const size_t size, /**< required memory size */\n                              jmem_pressure_t max_pressure) /**< pressure limit */\n{\n  if (JERRY_UNLIKELY (size == 0))\n  {\n    return NULL;\n  }\n\n  jmem_pressure_t pressure = JMEM_PRESSURE_NONE;\n\n#if !ENABLED (JERRY_MEM_GC_BEFORE_EACH_ALLOC)\n  if (JERRY_CONTEXT (jmem_heap_allocated_size) + size >= JERRY_CONTEXT (jmem_heap_limit))\n#endif /* !ENABLED (JERRY_MEM_GC_BEFORE_EACH_ALLOC) */\n  {\n    pressure = JMEM_PRESSURE_LOW;\n    ecma_free_unused_memory (pressure);\n  }\n\n  void *data_space_p = jmem_heap_alloc (size);\n\n  /* cppcheck-suppress memleak */\n  while (JERRY_UNLIKELY (data_space_p == NULL) && JERRY_LIKELY (pressure < max_pressure))\n  {\n    pressure++;\n    ecma_free_unused_memory (pressure);\n    data_space_p = jmem_heap_alloc (size);\n  }\n\n  return data_space_p;\n}",
        "begin_line": 270,
        "end_line": 300,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_init#72",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_init (void)",
        "snippet": "void\njmem_heap_init (void)\n{\n#if !ENABLED (JERRY_SYSTEM_ALLOCATOR)\n#if !ENABLED (JERRY_CPOINTER_32_BIT)\n  /* the maximum heap size for 16bit compressed pointers should be 512K */\n  JERRY_ASSERT (((UINT16_MAX + 1) << JMEM_ALIGNMENT_LOG) >= JMEM_HEAP_SIZE);\n#endif /* !ENABLED (JERRY_CPOINTER_32_BIT) */\n  JERRY_ASSERT ((uintptr_t) JERRY_HEAP_CONTEXT (area) % JMEM_ALIGNMENT == 0);\n\n  JERRY_CONTEXT (jmem_heap_limit) = CONFIG_GC_LIMIT;\n\n  jmem_heap_free_t *const region_p = (jmem_heap_free_t *) JERRY_HEAP_CONTEXT (area);\n\n  region_p->size = JMEM_HEAP_AREA_SIZE;\n  region_p->next_offset = JMEM_HEAP_END_OF_LIST;\n\n  JERRY_HEAP_CONTEXT (first).size = 0;\n  JERRY_HEAP_CONTEXT (first).next_offset = JMEM_HEAP_GET_OFFSET_FROM_ADDR (region_p);\n\n  JERRY_CONTEXT (jmem_heap_list_skip_p) = &JERRY_HEAP_CONTEXT (first);\n\n  JMEM_VALGRIND_NOACCESS_SPACE (&JERRY_HEAP_CONTEXT (first), sizeof (jmem_heap_free_t));\n  JMEM_VALGRIND_NOACCESS_SPACE (JERRY_HEAP_CONTEXT (area), JMEM_HEAP_AREA_SIZE);\n\n#endif /* !ENABLED (JERRY_SYSTEM_ALLOCATOR) */\n  JMEM_HEAP_STAT_INIT ();\n}",
        "begin_line": 72,
        "end_line": 99,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_is_heap_pointer#700",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_is_heap_pointer (const void *pointer) /**< pointer */",
        "snippet": "bool\njmem_is_heap_pointer (const void *pointer) /**< pointer */\n{\n#if !ENABLED (JERRY_SYSTEM_ALLOCATOR)\n  return ((uint8_t *) pointer >= JERRY_HEAP_CONTEXT (area)\n          && (uint8_t *) pointer <= (JERRY_HEAP_CONTEXT (area) + JMEM_HEAP_AREA_SIZE));\n#else /* ENABLED (JERRY_SYSTEM_ALLOCATOR) */\n  JERRY_UNUSED (pointer);\n  return true;\n#endif /* !ENABLED (JERRY_SYSTEM_ALLOCATOR) */\n}",
        "begin_line": 700,
        "end_line": 710,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-poolman.jmem_pools_collect_empty#156",
        "src_path": "jerry-core/jmem/jmem-poolman.c",
        "class_name": "jerry-core.jmem.jmem-poolman",
        "signature": "jerry-core.jmem.jmem-poolman.jmem_pools_collect_empty (void)",
        "snippet": "void\njmem_pools_collect_empty (void)\n{\n  jmem_pools_chunk_t *chunk_p = JERRY_CONTEXT (jmem_free_8_byte_chunk_p);\n  JERRY_CONTEXT (jmem_free_8_byte_chunk_p) = NULL;\n\n  while (chunk_p)\n  {\n    JMEM_VALGRIND_DEFINED_SPACE (chunk_p, sizeof (jmem_pools_chunk_t));\n    jmem_pools_chunk_t *const next_p = chunk_p->next_p;\n    JMEM_VALGRIND_NOACCESS_SPACE (chunk_p, sizeof (jmem_pools_chunk_t));\n\n    jmem_heap_free_block_internal (chunk_p, 8);\n    chunk_p = next_p;\n  }\n\n#if ENABLED (JERRY_CPOINTER_32_BIT)\n  chunk_p = JERRY_CONTEXT (jmem_free_16_byte_chunk_p);\n  JERRY_CONTEXT (jmem_free_16_byte_chunk_p) = NULL;\n\n  while (chunk_p)\n  {\n    JMEM_VALGRIND_DEFINED_SPACE (chunk_p, sizeof (jmem_pools_chunk_t));\n    jmem_pools_chunk_t *const next_p = chunk_p->next_p;\n    JMEM_VALGRIND_NOACCESS_SPACE (chunk_p, sizeof (jmem_pools_chunk_t));\n\n    jmem_heap_free_block_internal (chunk_p, 16);\n    chunk_p = next_p;\n  }\n#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */\n}",
        "begin_line": 156,
        "end_line": 186,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-char-helpers.lit_char_is_white_space#112",
        "src_path": "jerry-core/lit/lit-char-helpers.c",
        "class_name": "jerry-core.lit.lit-char-helpers",
        "signature": "jerry-core.lit.lit-char-helpers.lit_char_is_white_space (lit_code_point_t c) /**< code point */",
        "snippet": "bool\nlit_char_is_white_space (lit_code_point_t c) /**< code point */\n{\n  if (c <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)\n  {\n    return (c == LIT_CHAR_SP || (c >= LIT_CHAR_TAB && c <= LIT_CHAR_CR));\n  }\n  else\n  {\n    if (c == LIT_CHAR_NBSP || c == LIT_CHAR_BOM || c == LIT_CHAR_LS || c == LIT_CHAR_PS)\n    {\n      return true;\n    }\n\n    return (c <= LIT_UTF16_CODE_UNIT_MAX\n            && ((c >= lit_unicode_separator_char_interval_sps[0]\n                 && c < lit_unicode_separator_char_interval_sps[0] + lit_unicode_separator_char_interval_lengths[0])\n                || search_char_in_char_array ((ecma_char_t) c,\n                                              lit_unicode_separator_chars,\n                                              NUM_OF_ELEMENTS (lit_unicode_separator_chars))));\n  }\n}",
        "begin_line": 112,
        "end_line": 133,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-char-helpers.lit_code_point_is_identifier_part#239",
        "src_path": "jerry-core/lit/lit-char-helpers.c",
        "class_name": "jerry-core.lit.lit-char-helpers",
        "signature": "jerry-core.lit.lit-char-helpers.lit_code_point_is_identifier_part (lit_code_point_t code_point) /**< code point */",
        "snippet": "bool\nlit_code_point_is_identifier_part (lit_code_point_t code_point) /**< code point */\n{\n  /* Fast path for ASCII-defined letters. */\n  if (code_point <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)\n  {\n    return ((LEXER_TO_ASCII_LOWERCASE (code_point) >= LIT_CHAR_LOWERCASE_A\n             && LEXER_TO_ASCII_LOWERCASE (code_point) <= LIT_CHAR_LOWERCASE_Z)\n            || (code_point >= LIT_CHAR_0 && code_point <= LIT_CHAR_9)\n            || code_point == LIT_CHAR_DOLLAR_SIGN\n            || code_point == LIT_CHAR_UNDERSCORE);\n  }\n\n#if ENABLED (JERRY_ES2015)\n  if (code_point >= LIT_UTF8_4_BYTE_CODE_POINT_MIN)\n  {\n    /* TODO: detect these ranges correctly. */\n    return (code_point >= 0x10C80 && code_point <= 0x10CF2);\n  }\n#else /* !ENABLED (JERRY_ES2015) */\n  JERRY_ASSERT (code_point <= LIT_UTF8_4_BYTE_CODE_POINT_MIN);\n#endif /* ENABLED (JERRY_ES2015) */\n\n  return (lit_char_is_unicode_letter ((ecma_char_t) code_point)\n          || lit_char_is_unicode_non_letter_ident_part ((ecma_char_t) code_point));\n}",
        "begin_line": 239,
        "end_line": 264,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-char-helpers.lit_code_point_is_identifier_start#209",
        "src_path": "jerry-core/lit/lit-char-helpers.c",
        "class_name": "jerry-core.lit.lit-char-helpers",
        "signature": "jerry-core.lit.lit-char-helpers.lit_code_point_is_identifier_start (lit_code_point_t code_point) /**< code point */",
        "snippet": "bool\nlit_code_point_is_identifier_start (lit_code_point_t code_point) /**< code point */\n{\n  /* Fast path for ASCII-defined letters. */\n  if (code_point <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)\n  {\n    return ((LEXER_TO_ASCII_LOWERCASE (code_point) >= LIT_CHAR_LOWERCASE_A\n             && LEXER_TO_ASCII_LOWERCASE (code_point) <= LIT_CHAR_LOWERCASE_Z)\n            || code_point == LIT_CHAR_DOLLAR_SIGN\n            || code_point == LIT_CHAR_UNDERSCORE);\n  }\n\n#if ENABLED (JERRY_ES2015)\n  if (code_point >= LIT_UTF8_4_BYTE_CODE_POINT_MIN)\n  {\n    /* TODO: detect these ranges correctly. */\n    return (code_point >= 0x10C80 && code_point <= 0x10CF2);\n  }\n#else /* !ENABLED (JERRY_ES2015) */\n  JERRY_ASSERT (code_point <= LIT_UTF8_4_BYTE_CODE_POINT_MIN);\n#endif /* ENABLED (JERRY_ES2015) */\n\n  return lit_char_is_unicode_letter ((ecma_char_t) code_point);\n}",
        "begin_line": 209,
        "end_line": 232,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_size#67",
        "src_path": "jerry-core/lit/lit-magic-strings.c",
        "class_name": "jerry-core.lit.lit-magic-strings",
        "signature": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_size (uint32_t id) /**< magic string id */",
        "snippet": "lit_utf8_size_t\nlit_get_magic_string_size (uint32_t id) /**< magic string id */\n{\n  static const lit_magic_size_t lit_magic_string_sizes[] JERRY_ATTR_CONST_DATA =\n  {\n/** @cond doxygen_suppress */\n#define LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE(size, id)\n#define LIT_MAGIC_STRING_DEF(id, utf8_string) \\\n    sizeof(utf8_string) - 1,\n#include \"lit-magic-strings.inc.h\"\n#undef LIT_MAGIC_STRING_DEF\n#undef LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE\n/** @endcond */\n  };\n\n  JERRY_ASSERT (id < LIT_NON_INTERNAL_MAGIC_STRING__COUNT);\n\n  return lit_magic_string_sizes[id];\n}",
        "begin_line": 67,
        "end_line": 85,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_size_block_start#93",
        "src_path": "jerry-core/lit/lit-magic-strings.c",
        "class_name": "jerry-core.lit.lit-magic-strings",
        "signature": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_size_block_start (lit_utf8_size_t size) /**< magic string size */",
        "snippet": "static lit_magic_string_id_t\nlit_get_magic_string_size_block_start (lit_utf8_size_t size) /**< magic string size */\n{\n  static const lit_magic_string_id_t lit_magic_string_size_block_starts[] JERRY_ATTR_CONST_DATA =\n  {\n/** @cond doxygen_suppress */\n#define LIT_MAGIC_STRING_DEF(id, utf8_string)\n#define LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE(size, id) \\\n    id,\n#include \"lit-magic-strings.inc.h\"\n    LIT_NON_INTERNAL_MAGIC_STRING__COUNT\n#undef LIT_MAGIC_STRING_DEF\n#undef LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE\n/** @endcond */\n  };\n\n  JERRY_ASSERT (size <= (sizeof (lit_magic_string_size_block_starts) / sizeof (lit_magic_string_id_t)));\n\n  return lit_magic_string_size_block_starts[size];\n}",
        "begin_line": 93,
        "end_line": 112,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_utf8#42",
        "src_path": "jerry-core/lit/lit-magic-strings.c",
        "class_name": "jerry-core.lit.lit-magic-strings",
        "signature": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_utf8 (uint32_t id) /**< magic string id */",
        "snippet": "const lit_utf8_byte_t *\nlit_get_magic_string_utf8 (uint32_t id) /**< magic string id */\n{\n  static const lit_utf8_byte_t * const lit_magic_strings[] JERRY_ATTR_CONST_DATA =\n  {\n/** @cond doxygen_suppress */\n#define LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE(size, id)\n#define LIT_MAGIC_STRING_DEF(id, utf8_string) \\\n    (const lit_utf8_byte_t *) utf8_string,\n#include \"lit-magic-strings.inc.h\"\n#undef LIT_MAGIC_STRING_DEF\n#undef LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE\n/** @endcond */\n  };\n\n  JERRY_ASSERT (id < LIT_NON_INTERNAL_MAGIC_STRING__COUNT);\n\n  return lit_magic_strings[id];\n}",
        "begin_line": 42,
        "end_line": 60,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-magic-strings.lit_is_utf8_string_magic#202",
        "src_path": "jerry-core/lit/lit-magic-strings.c",
        "class_name": "jerry-core.lit.lit-magic-strings",
        "signature": "jerry-core.lit.lit-magic-strings.lit_is_utf8_string_magic (const lit_utf8_byte_t *string_p, /**< utf-8 string */                           lit_utf8_size_t string_size) /**< string size in bytes */",
        "snippet": "lit_magic_string_id_t\nlit_is_utf8_string_magic (const lit_utf8_byte_t *string_p, /**< utf-8 string */\n                          lit_utf8_size_t string_size) /**< string size in bytes */\n{\n  if (string_size > lit_get_magic_string_size (LIT_NON_INTERNAL_MAGIC_STRING__COUNT - 1))\n  {\n    return LIT_MAGIC_STRING__COUNT;\n  }\n\n  /**< The string must be in this id range. */\n  lit_utf8_size_t first = lit_get_magic_string_size_block_start (string_size);\n  lit_utf8_size_t last = lit_get_magic_string_size_block_start (string_size + 1);\n\n  while (first < last)\n  {\n    lit_utf8_size_t middle = ((first + last) / 2); /**< mid point of search */\n    int compare = memcmp (lit_get_magic_string_utf8 ((lit_magic_string_id_t) middle), string_p, string_size);\n\n    if (compare == 0)\n    {\n      return (lit_magic_string_id_t) middle;\n    }\n    else if (compare > 0)\n    {\n      last = middle;\n    }\n    else\n    {\n      first = middle + 1;\n    }\n  }\n\n  return LIT_MAGIC_STRING__COUNT;\n}",
        "begin_line": 202,
        "end_line": 235,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_is_valid_cesu8_string#127",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_is_valid_cesu8_string (const lit_utf8_byte_t *cesu8_buf_p, /**< cesu-8 string */                            lit_utf8_size_t buf_size) /**< string size */",
        "snippet": "bool\nlit_is_valid_cesu8_string (const lit_utf8_byte_t *cesu8_buf_p, /**< cesu-8 string */\n                           lit_utf8_size_t buf_size) /**< string size */\n{\n  lit_utf8_size_t idx = 0;\n\n  while (idx < buf_size)\n  {\n    lit_utf8_byte_t c = cesu8_buf_p[idx++];\n    if ((c & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)\n    {\n      continue;\n    }\n\n    lit_code_point_t code_point = 0;\n    lit_code_point_t min_code_point = 0;\n    lit_utf8_size_t extra_bytes_count;\n    if ((c & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)\n    {\n      extra_bytes_count = 1;\n      min_code_point = LIT_UTF8_2_BYTE_CODE_POINT_MIN;\n      code_point = ((uint32_t) (c & LIT_UTF8_LAST_5_BITS_MASK));\n    }\n    else if ((c & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER)\n    {\n      extra_bytes_count = 2;\n      min_code_point = LIT_UTF8_3_BYTE_CODE_POINT_MIN;\n      code_point = ((uint32_t) (c & LIT_UTF8_LAST_4_BITS_MASK));\n    }\n    else\n    {\n      return false;\n    }\n\n    if (idx + extra_bytes_count > buf_size)\n    {\n      /* cesu-8 string breaks in the middle */\n      return false;\n    }\n\n    for (lit_utf8_size_t offset = 0; offset < extra_bytes_count; ++offset)\n    {\n      c = cesu8_buf_p[idx + offset];\n      if ((c & LIT_UTF8_EXTRA_BYTE_MASK) != LIT_UTF8_EXTRA_BYTE_MARKER)\n      {\n        /* invalid continuation byte */\n        return false;\n      }\n      code_point <<= LIT_UTF8_BITS_IN_EXTRA_BYTES;\n      code_point |= (c & LIT_UTF8_LAST_6_BITS_MASK);\n    }\n\n    if (code_point < min_code_point)\n    {\n      /* cesu-8 string doesn't encode valid unicode code point */\n      return false;\n    }\n\n    idx += extra_bytes_count;\n  }\n\n  return true;\n}",
        "begin_line": 127,
        "end_line": 189,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_is_valid_utf8_string#30",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_is_valid_utf8_string (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */                           lit_utf8_size_t buf_size) /**< string size */",
        "snippet": "bool\nlit_is_valid_utf8_string (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */\n                          lit_utf8_size_t buf_size) /**< string size */\n{\n  lit_utf8_size_t idx = 0;\n\n  bool is_prev_code_point_high_surrogate = false;\n  while (idx < buf_size)\n  {\n    lit_utf8_byte_t c = utf8_buf_p[idx++];\n    if ((c & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)\n    {\n      is_prev_code_point_high_surrogate = false;\n      continue;\n    }\n\n    lit_code_point_t code_point = 0;\n    lit_code_point_t min_code_point = 0;\n    lit_utf8_size_t extra_bytes_count;\n    if ((c & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)\n    {\n      extra_bytes_count = 1;\n      min_code_point = LIT_UTF8_2_BYTE_CODE_POINT_MIN;\n      code_point = ((uint32_t) (c & LIT_UTF8_LAST_5_BITS_MASK));\n    }\n    else if ((c & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER)\n    {\n      extra_bytes_count = 2;\n      min_code_point = LIT_UTF8_3_BYTE_CODE_POINT_MIN;\n      code_point = ((uint32_t) (c & LIT_UTF8_LAST_4_BITS_MASK));\n    }\n    else if ((c & LIT_UTF8_4_BYTE_MASK) == LIT_UTF8_4_BYTE_MARKER)\n    {\n      extra_bytes_count = 3;\n      min_code_point = LIT_UTF8_4_BYTE_CODE_POINT_MIN;\n      code_point = ((uint32_t) (c & LIT_UTF8_LAST_3_BITS_MASK));\n    }\n    else\n    {\n      /* utf-8 string could not contain 5- and 6-byte sequences. */\n      return false;\n    }\n\n    if (idx + extra_bytes_count > buf_size)\n    {\n      /* utf-8 string breaks in the middle */\n      return false;\n    }\n\n    for (lit_utf8_size_t offset = 0; offset < extra_bytes_count; ++offset)\n    {\n      c = utf8_buf_p[idx + offset];\n      if ((c & LIT_UTF8_EXTRA_BYTE_MASK) != LIT_UTF8_EXTRA_BYTE_MARKER)\n      {\n        /* invalid continuation byte */\n        return false;\n      }\n      code_point <<= LIT_UTF8_BITS_IN_EXTRA_BYTES;\n      code_point |= (c & LIT_UTF8_LAST_6_BITS_MASK);\n    }\n\n    if (code_point < min_code_point\n        || code_point > LIT_UNICODE_CODE_POINT_MAX)\n    {\n      /* utf-8 string doesn't encode valid unicode code point */\n      return false;\n    }\n\n    if (code_point >= LIT_UTF16_HIGH_SURROGATE_MIN\n        && code_point <= LIT_UTF16_HIGH_SURROGATE_MAX)\n    {\n      is_prev_code_point_high_surrogate = true;\n    }\n    else if (code_point >= LIT_UTF16_LOW_SURROGATE_MIN\n             && code_point <= LIT_UTF16_LOW_SURROGATE_MAX\n             && is_prev_code_point_high_surrogate)\n    {\n      /* sequence of high and low surrogate is not allowed */\n      return false;\n    }\n    else\n    {\n      is_prev_code_point_high_surrogate = false;\n    }\n\n    idx += extra_bytes_count;\n  }\n\n  return true;\n}",
        "begin_line": 30,
        "end_line": 119,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_read_code_unit_from_utf8#425",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_read_code_unit_from_utf8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */                               ecma_char_t *code_point) /**< [out] code point */",
        "snippet": "lit_utf8_size_t\nlit_read_code_unit_from_utf8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */\n                              ecma_char_t *code_point) /**< [out] code point */\n{\n  JERRY_ASSERT (buf_p);\n\n  lit_utf8_byte_t c = buf_p[0];\n  if ((c & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)\n  {\n    *code_point = (ecma_char_t) (c & LIT_UTF8_LAST_7_BITS_MASK);\n    return 1;\n  }\n\n  lit_code_point_t ret = LIT_UNICODE_CODE_POINT_NULL;\n  ecma_length_t bytes_count;\n  if ((c & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)\n  {\n    bytes_count = 2;\n    ret = ((lit_code_point_t) (c & LIT_UTF8_LAST_5_BITS_MASK));\n  }\n  else\n  {\n    JERRY_ASSERT ((c & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER);\n    bytes_count = 3;\n    ret = ((lit_code_point_t) (c & LIT_UTF8_LAST_4_BITS_MASK));\n  }\n\n  for (uint32_t i = 1; i < bytes_count; ++i)\n  {\n    ret <<= LIT_UTF8_BITS_IN_EXTRA_BYTES;\n    ret |= (buf_p[i] & LIT_UTF8_LAST_6_BITS_MASK);\n  }\n\n  JERRY_ASSERT (ret <= LIT_UTF16_CODE_UNIT_MAX);\n  *code_point = (ecma_char_t) ret;\n  return bytes_count;\n}",
        "begin_line": 425,
        "end_line": 461,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_read_prev_code_unit_from_utf8#468",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_read_prev_code_unit_from_utf8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */                                    ecma_char_t *code_point) /**< [out] code point */",
        "snippet": "lit_utf8_size_t\nlit_read_prev_code_unit_from_utf8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */\n                                   ecma_char_t *code_point) /**< [out] code point */\n{\n  JERRY_ASSERT (buf_p);\n\n  lit_utf8_decr (&buf_p);\n  return lit_read_code_unit_from_utf8 (buf_p, code_point);\n}",
        "begin_line": 468,
        "end_line": 476,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_utf8_decr#557",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_utf8_decr (const lit_utf8_byte_t **buf_p) /**< [in, out] buffer with characters */",
        "snippet": "void\nlit_utf8_decr (const lit_utf8_byte_t **buf_p) /**< [in,out] buffer with characters */\n{\n  JERRY_ASSERT (*buf_p);\n  const lit_utf8_byte_t *current_p = *buf_p;\n\n  do\n  {\n    current_p--;\n  }\n  while ((*(current_p) & LIT_UTF8_EXTRA_BYTE_MASK) == LIT_UTF8_EXTRA_BYTE_MARKER);\n\n  *buf_p = current_p;\n}",
        "begin_line": 557,
        "end_line": 570,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_utf8_string_length#290",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_utf8_string_length (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */                         lit_utf8_size_t utf8_buf_size) /**< string size */",
        "snippet": "ecma_length_t\nlit_utf8_string_length (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */\n                        lit_utf8_size_t utf8_buf_size) /**< string size */\n{\n  ecma_length_t length = 0;\n  lit_utf8_size_t size = 0;\n\n  while (size < utf8_buf_size)\n  {\n    size += lit_get_unicode_char_size_by_utf8_first_byte (*(utf8_buf_p + size));\n    length++;\n  }\n\n  JERRY_ASSERT (size == utf8_buf_size);\n\n  return length;\n}",
        "begin_line": 290,
        "end_line": 306,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_zt_utf8_string_size#278",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_zt_utf8_string_size (const lit_utf8_byte_t *utf8_str_p) /**< zero-terminated utf-8 string */",
        "snippet": "lit_utf8_size_t\nlit_zt_utf8_string_size (const lit_utf8_byte_t *utf8_str_p) /**< zero-terminated utf-8 string */\n{\n  JERRY_ASSERT (utf8_str_p != NULL);\n  return (lit_utf8_size_t) strlen ((const char *) utf8_str_p);\n}",
        "begin_line": 278,
        "end_line": 283,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_parse_script#2676",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_parse_script (const uint8_t *arg_list_p, /**< function argument list */                      size_t arg_list_size, /**< size of function argument list */                      const uint8_t *source_p, /**< source code */                      size_t source_size, /**< size of the source code */                      uint32_t parse_opts, /**< ecma_parse_opts_t option bits */                      ecma_compiled_code_t **bytecode_data_p) /**< [out] JS bytecode */",
        "snippet": "ecma_value_t\nparser_parse_script (const uint8_t *arg_list_p, /**< function argument list */\n                     size_t arg_list_size, /**< size of function argument list */\n                     const uint8_t *source_p, /**< source code */\n                     size_t source_size, /**< size of the source code */\n                     uint32_t parse_opts, /**< ecma_parse_opts_t option bits */\n                     ecma_compiled_code_t **bytecode_data_p) /**< [out] JS bytecode */\n{\n#if ENABLED (JERRY_PARSER)\n  parser_error_location_t parser_error;\n\n#if ENABLED (JERRY_DEBUGGER)\n  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n  {\n    jerry_debugger_send_string (JERRY_DEBUGGER_SOURCE_CODE,\n                                JERRY_DEBUGGER_NO_SUBTYPE,\n                                source_p,\n                                source_size);\n  }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n  *bytecode_data_p = parser_parse_source (arg_list_p,\n                                          arg_list_size,\n                                          source_p,\n                                          source_size,\n                                          parse_opts,\n                                          &parser_error);\n\n  if (!*bytecode_data_p)\n  {\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n    if (JERRY_CONTEXT (module_top_context_p) != NULL)\n    {\n      ecma_module_cleanup ();\n    }\n#endif\n#if ENABLED (JERRY_DEBUGGER)\n    if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n    {\n      jerry_debugger_send_type (JERRY_DEBUGGER_PARSE_ERROR);\n    }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n    if (parser_error.error == PARSER_ERR_OUT_OF_MEMORY)\n    {\n      /* It is unlikely that memory can be allocated in an out-of-memory\n       * situation. However, a simple value can still be thrown. */\n      jcontext_raise_exception (ECMA_VALUE_NULL);\n      return ECMA_VALUE_ERROR;\n    }\n\n    if (parser_error.error == PARSER_ERR_INVALID_REGEXP)\n    {\n      /* The RegExp compiler has already raised an exception. */\n      JERRY_ASSERT (jcontext_has_pending_exception ());\n      return ECMA_VALUE_ERROR;\n    }\n\n#if ENABLED (JERRY_ERROR_MESSAGES)\n    const lit_utf8_byte_t *err_bytes_p = (const lit_utf8_byte_t *) parser_error_to_string (parser_error.error);\n    lit_utf8_size_t err_bytes_size = lit_zt_utf8_string_size (err_bytes_p);\n\n    ecma_string_t *err_str_p = ecma_new_ecma_string_from_utf8 (err_bytes_p, err_bytes_size);\n    ecma_value_t err_str_val = ecma_make_string_value (err_str_p);\n    ecma_value_t line_str_val = ecma_make_uint32_value (parser_error.line);\n    ecma_value_t col_str_val = ecma_make_uint32_value (parser_error.column);\n\n    ecma_value_t error_value = ecma_raise_standard_error_with_format (ECMA_ERROR_SYNTAX,\n                                                                      \"% [%:%:%]\",\n                                                                      err_str_val,\n                                                                      JERRY_CONTEXT (resource_name),\n                                                                      line_str_val,\n                                                                      col_str_val);\n\n    ecma_free_value (col_str_val);\n    ecma_free_value (line_str_val);\n    ecma_free_value (err_str_val);\n\n    return error_value;\n#else /* !ENABLED (JERRY_ERROR_MESSAGES) */\n    return ecma_raise_syntax_error (\"\");\n#endif /* ENABLED (JERRY_ERROR_MESSAGES) */\n  }\n\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n  if (JERRY_CONTEXT (module_top_context_p) != NULL)\n  {\n    ecma_value_t ret_value = ecma_module_parse_modules ();\n\n    if (ECMA_IS_VALUE_ERROR (ret_value))\n    {\n      ecma_bytecode_deref (*bytecode_data_p);\n      *bytecode_data_p = NULL;\n      ecma_module_cleanup ();\n\n      return ret_value;\n    }\n  }\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n#if ENABLED (JERRY_DEBUGGER)\n  if ((JERRY_CONTEXT (debugger_flags) & (JERRY_DEBUGGER_CONNECTED | JERRY_DEBUGGER_PARSER_WAIT))\n      == (JERRY_DEBUGGER_CONNECTED | JERRY_DEBUGGER_PARSER_WAIT))\n  {\n    JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_PARSER_WAIT_MODE);\n    jerry_debugger_send_type (JERRY_DEBUGGER_WAITING_AFTER_PARSE);\n\n    while (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_PARSER_WAIT_MODE)\n    {\n      jerry_debugger_receive (NULL);\n\n      if (!(JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED))\n      {\n        break;\n      }\n\n      jerry_debugger_transport_sleep ();\n    }\n  }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n  return ECMA_VALUE_TRUE;\n#else /* !ENABLED (JERRY_PARSER) */\n  JERRY_UNUSED (arg_list_p);\n  JERRY_UNUSED (arg_list_size);\n  JERRY_UNUSED (source_p);\n  JERRY_UNUSED (source_size);\n  JERRY_UNUSED (parse_opts);\n  JERRY_UNUSED (bytecode_data_p);\n\n  return ecma_raise_syntax_error (ECMA_ERR_MSG (\"The parser has been disabled.\"));\n#endif /* ENABLED (JERRY_PARSER) */\n}",
        "begin_line": 2676,
        "end_line": 2808,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm-stack.vm_stack_context_abort#38",
        "src_path": "jerry-core/vm/vm-stack.c",
        "class_name": "jerry-core.vm.vm-stack",
        "signature": "jerry-core.vm.vm-stack.vm_stack_context_abort (vm_frame_ctx_t *frame_ctx_p, /**< frame context */                         ecma_value_t *vm_stack_top_p) /**< current stack top */",
        "snippet": "ecma_value_t *\nvm_stack_context_abort (vm_frame_ctx_t *frame_ctx_p, /**< frame context */\n                        ecma_value_t *vm_stack_top_p) /**< current stack top */\n{\n  ecma_value_t context_info = vm_stack_top_p[-1];\n\n  if (context_info & VM_CONTEXT_HAS_LEX_ENV)\n  {\n    ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;\n    JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);\n    frame_ctx_p->lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);\n    ecma_deref_object (lex_env_p);\n  }\n\n  switch (VM_GET_CONTEXT_TYPE (context_info))\n  {\n    case VM_CONTEXT_FINALLY_THROW:\n    case VM_CONTEXT_FINALLY_RETURN:\n    {\n      ecma_free_value (vm_stack_top_p[-2]);\n      /* FALLTHRU */\n    }\n    case VM_CONTEXT_FINALLY_JUMP:\n    case VM_CONTEXT_TRY:\n    case VM_CONTEXT_CATCH:\n    {\n      VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);\n      vm_stack_top_p -= PARSER_TRY_CONTEXT_STACK_ALLOCATION;\n      break;\n    }\n#if ENABLED (JERRY_ES2015)\n    case VM_CONTEXT_BLOCK:\n#endif /* ENABLED (JERRY_ES2015) */\n    case VM_CONTEXT_WITH:\n    {\n      VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_WITH_CONTEXT_STACK_ALLOCATION);\n      vm_stack_top_p -= PARSER_WITH_CONTEXT_STACK_ALLOCATION;\n      break;\n    }\n#if ENABLED (JERRY_ES2015)\n    case VM_CONTEXT_FOR_OF:\n    {\n      ecma_value_t iterator = vm_stack_top_p[-3];\n\n      if (context_info & VM_CONTEXT_CLOSE_ITERATOR)\n      {\n        ecma_op_iterator_close (iterator);\n      }\n      ecma_free_value (iterator);\n\n      ecma_free_value (vm_stack_top_p[-2]);\n      VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);\n      vm_stack_top_p -= PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION;\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    default:\n    {\n      JERRY_ASSERT (VM_GET_CONTEXT_TYPE (vm_stack_top_p[-1]) == VM_CONTEXT_FOR_IN);\n\n      ecma_collection_t *collection_p;\n      collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, vm_stack_top_p[-2]);\n\n      ecma_value_t *buffer_p = collection_p->buffer_p;\n\n      for (uint32_t index = vm_stack_top_p[-3]; index < collection_p->item_count; index++)\n      {\n        ecma_free_value (buffer_p[index]);\n      }\n\n      ecma_collection_destroy (collection_p);\n\n      ecma_free_value (vm_stack_top_p[-4]);\n\n      VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION);\n      vm_stack_top_p -= PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;\n      break;\n    }\n  }\n\n  return vm_stack_top_p;\n}",
        "begin_line": 38,
        "end_line": 119,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm-utils.vm_is_strict_mode#28",
        "src_path": "jerry-core/vm/vm-utils.c",
        "class_name": "jerry-core.vm.vm-utils",
        "signature": "jerry-core.vm.vm-utils.vm_is_strict_mode (void)",
        "snippet": "bool\nvm_is_strict_mode (void)\n{\n  JERRY_ASSERT (JERRY_CONTEXT (vm_top_context_p) != NULL);\n\n  return JERRY_CONTEXT (vm_top_context_p)->bytecode_header_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE;\n}",
        "begin_line": 28,
        "end_line": 34,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.opfunc_call#732",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.opfunc_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */",
        "snippet": "static void\nopfunc_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */\n{\n  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;\n  uint8_t opcode = byte_code_p[-1];\n  uint32_t arguments_list_len;\n\n  if (opcode >= CBC_CALL0)\n  {\n    arguments_list_len = (unsigned int) ((opcode - CBC_CALL0) / 6);\n  }\n  else\n  {\n    arguments_list_len = *byte_code_p++;\n  }\n\n  bool is_call_prop = ((opcode - CBC_CALL) % 6) >= 3;\n\n  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;\n  ecma_value_t this_value = is_call_prop ? stack_top_p[-3] : ECMA_VALUE_UNDEFINED;\n  ecma_value_t func_value = stack_top_p[-1];\n  ecma_value_t completion_value;\n\n  if (!ecma_is_value_object (func_value)\n      || !ecma_op_object_is_callable (ecma_get_object_from_value (func_value)))\n  {\n    completion_value = ecma_raise_type_error (ECMA_ERR_MSG (\"Expected a function.\"));\n  }\n  else\n  {\n    ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);\n\n    completion_value = ecma_op_function_call (func_obj_p,\n                                              this_value,\n                                              stack_top_p,\n                                              arguments_list_len);\n  }\n\n  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_DIRECT_EVAL;\n\n  /* Free registers. */\n  for (uint32_t i = 0; i < arguments_list_len; i++)\n  {\n    ecma_fast_free_value (stack_top_p[i]);\n  }\n\n  if (is_call_prop)\n  {\n    ecma_free_value (*(--stack_top_p));\n    ecma_free_value (*(--stack_top_p));\n  }\n\n  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))\n  {\n#if ENABLED (JERRY_DEBUGGER)\n    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;\n#endif /* ENABLED (JERRY_DEBUGGER) */\n    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;\n  }\n  else\n  {\n    frame_ctx_p->byte_code_p = byte_code_p;\n    ecma_free_value (*(--stack_top_p));\n    uint32_t opcode_data = vm_decode_table[opcode];\n\n    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))\n    {\n      ecma_fast_free_value (completion_value);\n    }\n    else if (opcode_data & VM_OC_PUT_STACK)\n    {\n      *stack_top_p++ = completion_value;\n    }\n    else\n    {\n      ecma_fast_free_value (frame_ctx_p->block_result);\n      frame_ctx_p->block_result = completion_value;\n    }\n  }\n\n  frame_ctx_p->stack_top_p = stack_top_p;\n}",
        "begin_line": 732,
        "end_line": 813,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.opfunc_construct#820",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.opfunc_construct (vm_frame_ctx_t *frame_ctx_p) /**< frame context */",
        "snippet": "static void\nopfunc_construct (vm_frame_ctx_t *frame_ctx_p) /**< frame context */\n{\n  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;\n  uint8_t opcode = byte_code_p[-1];\n  unsigned int arguments_list_len;\n\n  if (opcode >= CBC_NEW0)\n  {\n    arguments_list_len = (unsigned int) (opcode - CBC_NEW0);\n  }\n  else\n  {\n    arguments_list_len = *byte_code_p++;\n  }\n\n  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;\n  ecma_value_t constructor_value = stack_top_p[-1];\n  ecma_value_t completion_value;\n\n  if (!ecma_is_value_object (constructor_value)\n      || !ecma_object_is_constructor (ecma_get_object_from_value (constructor_value)))\n  {\n    completion_value = ecma_raise_type_error (ECMA_ERR_MSG (\"Expected a constructor.\"));\n  }\n  else\n  {\n    ecma_object_t *constructor_obj_p = ecma_get_object_from_value (constructor_value);\n\n    completion_value = ecma_op_function_construct (constructor_obj_p,\n                                                   constructor_obj_p,\n                                                   stack_top_p,\n                                                   arguments_list_len);\n  }\n\n  /* Free registers. */\n  for (uint32_t i = 0; i < arguments_list_len; i++)\n  {\n    ecma_fast_free_value (stack_top_p[i]);\n  }\n\n  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))\n  {\n#if ENABLED (JERRY_DEBUGGER)\n    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;\n#endif /* ENABLED (JERRY_DEBUGGER) */\n    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;\n  }\n  else\n  {\n    ecma_free_value (stack_top_p[-1]);\n    frame_ctx_p->byte_code_p = byte_code_p;\n    stack_top_p[-1] = completion_value;\n  }\n\n  frame_ctx_p->stack_top_p = stack_top_p;\n}",
        "begin_line": 820,
        "end_line": 876,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_construct_literal_object#420",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_construct_literal_object (vm_frame_ctx_t *frame_ctx_p, /**< frame context */                              ecma_value_t lit_value) /**< literal */",
        "snippet": "static ecma_value_t\nvm_construct_literal_object (vm_frame_ctx_t *frame_ctx_p, /**< frame context */\n                             ecma_value_t lit_value) /**< literal */\n{\n  ecma_compiled_code_t *bytecode_p;\n\n#if ENABLED (JERRY_SNAPSHOT_EXEC)\n  if (JERRY_LIKELY (!(frame_ctx_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))\n  {\n#endif /* ENABLED (JERRY_SNAPSHOT_EXEC) */\n    bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,\n                                                  lit_value);\n#if ENABLED (JERRY_SNAPSHOT_EXEC)\n  }\n  else\n  {\n    uint8_t *byte_p = ((uint8_t *) frame_ctx_p->bytecode_header_p) + lit_value;\n    bytecode_p = (ecma_compiled_code_t *) byte_p;\n  }\n#endif /* ENABLED (JERRY_SNAPSHOT_EXEC) */\n\n#if ENABLED (JERRY_BUILTIN_REGEXP)\n  if (!(bytecode_p->status_flags & CBC_CODE_FLAGS_FUNCTION))\n  {\n    ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);\n\n    if (JERRY_UNLIKELY (regexp_obj_p == NULL))\n    {\n      return ECMA_VALUE_ERROR;\n    }\n\n    return ecma_op_create_regexp_from_bytecode (regexp_obj_p, (re_compiled_code_t *) bytecode_p);;\n  }\n#endif /* ENABLED (JERRY_BUILTIN_REGEXP) */\n\n  JERRY_ASSERT (bytecode_p->status_flags & CBC_CODE_FLAGS_FUNCTION);\n\n  ecma_object_t *func_obj_p;\n\n#if ENABLED (JERRY_ES2015)\n  if (bytecode_p->status_flags & CBC_CODE_FLAGS_ARROW_FUNCTION)\n  {\n    func_obj_p = ecma_op_create_arrow_function_object (frame_ctx_p->lex_env_p,\n                                                       bytecode_p,\n                                                       frame_ctx_p->this_binding);\n  }\n  else if (bytecode_p->status_flags & CBC_CODE_FLAGS_GENERATOR)\n  {\n    func_obj_p = ecma_op_create_generator_function_object (frame_ctx_p->lex_env_p, bytecode_p);\n  }\n  else\n  {\n#endif /* ENABLED (JERRY_ES2015) */\n    func_obj_p = ecma_op_create_simple_function_object (frame_ctx_p->lex_env_p, bytecode_p);\n#if ENABLED (JERRY_ES2015)\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  return ecma_make_object_value (func_obj_p);\n}",
        "begin_line": 420,
        "end_line": 479,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_op_get_value#57",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_op_get_value (ecma_value_t object, /**< base object */                  ecma_value_t property) /**< property name */",
        "snippet": "static ecma_value_t\nvm_op_get_value (ecma_value_t object, /**< base object */\n                 ecma_value_t property) /**< property name */\n{\n  if (ecma_is_value_object (object))\n  {\n    ecma_object_t *object_p = ecma_get_object_from_value (object);\n    ecma_string_t *property_name_p = NULL;\n\n    if (ecma_is_value_integer_number (property))\n    {\n      ecma_integer_value_t int_value = ecma_get_integer_from_value (property);\n\n      if (int_value >= 0 && int_value <= ECMA_DIRECT_STRING_MAX_IMM)\n      {\n        if (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_ARRAY)\n        {\n          ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n          if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)\n                            && (uint32_t) int_value < ext_object_p->u.array.length))\n          {\n            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);\n\n            if (JERRY_LIKELY (!ecma_is_value_array_hole (values_p[int_value])))\n            {\n              return ecma_fast_copy_value (values_p[int_value]);\n            }\n          }\n        }\n\n        property_name_p = (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_UINT,\n                                                                       (uintptr_t) int_value);\n      }\n    }\n    else if (ecma_is_value_string (property))\n    {\n      property_name_p = ecma_get_string_from_value (property);\n    }\n\n#if ENABLED (JERRY_ES2015)\n    if (ecma_is_value_symbol (property))\n    {\n      property_name_p = ecma_get_symbol_from_value (property);\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    if (property_name_p != NULL)\n    {\n#if ENABLED (JERRY_LCACHE)\n      ecma_property_t *property_p = ecma_lcache_lookup (object_p, property_name_p);\n\n      if (property_p != NULL &&\n          ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA)\n      {\n        return ecma_fast_copy_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);\n      }\n#endif /* ENABLED (JERRY_LCACHE) */\n\n      /* There is no need to free the name. */\n      return ecma_op_object_get (object_p, property_name_p);\n    }\n  }\n\n  if (JERRY_UNLIKELY (ecma_is_value_undefined (object) || ecma_is_value_null (object)))\n  {\n#if ENABLED (JERRY_ERROR_MESSAGES)\n    ecma_value_t error_value = ecma_raise_standard_error_with_format (ECMA_ERROR_TYPE,\n                                                                      \"Cannot read property '%' of %\",\n                                                                      property,\n                                                                      object);\n#else /* !ENABLED (JERRY_ERROR_MESSAGES) */\n    ecma_value_t error_value = ecma_raise_type_error (NULL);\n#endif /* ENABLED (JERRY_ERROR_MESSAGES) */\n    return error_value;\n  }\n\n  ecma_string_t *property_name_p = ecma_op_to_prop_name (property);\n\n  if (property_name_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_value_t get_value_result = ecma_op_get_value_object_base (object, property_name_p);\n\n  ecma_deref_ecma_string (property_name_p);\n  return get_value_result;\n}",
        "begin_line": 57,
        "end_line": 145,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_op_set_value#156",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_op_set_value (ecma_value_t object, /**< base object */                  ecma_value_t property, /**< property name */                  ecma_value_t value, /**< ecma value */                  bool is_strict) /**< strict mode */",
        "snippet": "static ecma_value_t\nvm_op_set_value (ecma_value_t object, /**< base object */\n                 ecma_value_t property, /**< property name */\n                 ecma_value_t value, /**< ecma value */\n                 bool is_strict) /**< strict mode */\n{\n  ecma_object_t * object_p;\n\n  if (JERRY_UNLIKELY (!ecma_is_value_object (object)))\n  {\n    ecma_value_t to_object = ecma_op_to_object (object);\n    ecma_free_value (object);\n\n    if (ECMA_IS_VALUE_ERROR (to_object))\n    {\n#if ENABLED (JERRY_ERROR_MESSAGES)\n      ecma_free_value (to_object);\n      jcontext_release_exception ();\n\n      ecma_value_t error_value = ecma_raise_standard_error_with_format (ECMA_ERROR_TYPE,\n                                                                        \"Cannot set property '%' of %\",\n                                                                        property,\n                                                                        object);\n      ecma_free_value (property);\n\n      return error_value;\n#else /* !ENABLED (JERRY_ERROR_MESSAGES) */\n      ecma_free_value (property);\n      return to_object;\n#endif /* ENABLED (JERRY_ERROR_MESSAGES) */\n    }\n\n    object_p = ecma_get_object_from_value (to_object);\n    ecma_op_ordinary_object_prevent_extensions (object_p);\n  }\n  else\n  {\n    object_p = ecma_get_object_from_value (object);\n  }\n\n  ecma_string_t *property_p;\n\n  if (!ecma_is_value_prop_name (property))\n  {\n    property_p = ecma_op_to_prop_name (property);\n    ecma_fast_free_value (property);\n\n    if (JERRY_UNLIKELY (property_p == NULL))\n    {\n      ecma_deref_object (object_p);\n      return ECMA_VALUE_ERROR;\n    }\n  }\n  else\n  {\n    property_p = ecma_get_prop_name_from_value (property);\n  }\n\n  ecma_value_t completion_value = ECMA_VALUE_EMPTY;\n\n  if (!ecma_is_lexical_environment (object_p))\n  {\n    completion_value = ecma_op_object_put (object_p,\n                                           property_p,\n                                           value,\n                                           is_strict);\n  }\n  else\n  {\n    completion_value = ecma_op_set_mutable_binding (object_p,\n                                                    property_p,\n                                                    value,\n                                                    is_strict);\n  }\n\n  ecma_deref_object (object_p);\n  ecma_deref_ecma_string (property_p);\n\n  return completion_value;\n}",
        "begin_line": 156,
        "end_line": 235,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_run#4198",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_run (const ecma_compiled_code_t *bytecode_header_p, /**< byte-code data header */         ecma_value_t this_binding_value, /**< value of 'ThisBinding' */         ecma_object_t *lex_env_p, /**< lexical environment to use */         const ecma_value_t *arg_list_p, /**< arguments list */         ecma_length_t arg_list_len) /**< length of arguments list */",
        "snippet": "ecma_value_t\nvm_run (const ecma_compiled_code_t *bytecode_header_p, /**< byte-code data header */\n        ecma_value_t this_binding_value, /**< value of 'ThisBinding' */\n        ecma_object_t *lex_env_p, /**< lexical environment to use */\n        const ecma_value_t *arg_list_p, /**< arguments list */\n        ecma_length_t arg_list_len) /**< length of arguments list */\n{\n  vm_frame_ctx_t *frame_ctx_p;\n  size_t frame_size;\n\n  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n  {\n    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;\n    frame_size = (size_t) (args_p->register_end + args_p->stack_limit);\n  }\n  else\n  {\n    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;\n    frame_size = (size_t) (args_p->register_end + args_p->stack_limit);\n  }\n\n  frame_size = frame_size * sizeof (ecma_value_t) + sizeof (vm_frame_ctx_t);\n  frame_size = (frame_size + sizeof (uintptr_t) - 1) / sizeof (uintptr_t);\n\n  /* Use JERRY_MAX() to avoid array declaration with size 0. */\n  JERRY_VLA (uintptr_t, stack, frame_size);\n\n  frame_ctx_p = (vm_frame_ctx_t *) stack;\n\n  frame_ctx_p->bytecode_header_p = bytecode_header_p;\n  frame_ctx_p->lex_env_p = lex_env_p;\n  frame_ctx_p->this_binding = this_binding_value;\n\n  vm_init_exec (frame_ctx_p, arg_list_p, arg_list_len);\n  return vm_execute (frame_ctx_p);\n}",
        "begin_line": 4198,
        "end_line": 4233,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_run_global#286",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_run_global (const ecma_compiled_code_t *bytecode_p) /**< pointer to bytecode to run */",
        "snippet": "ecma_value_t\nvm_run_global (const ecma_compiled_code_t *bytecode_p) /**< pointer to bytecode to run */\n{\n  ecma_object_t *glob_obj_p = ecma_builtin_get_global ();\n\n#if ENABLED (JERRY_ES2015)\n  if (bytecode_p->status_flags & CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED)\n  {\n    ecma_create_global_lexical_block ();\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  ecma_object_t *const global_scope_p = ecma_get_global_scope ();\n\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n  if (JERRY_CONTEXT (module_top_context_p) != NULL)\n  {\n    JERRY_ASSERT (JERRY_CONTEXT (module_top_context_p)->parent_p == NULL);\n    ecma_module_t *module_p = JERRY_CONTEXT (module_top_context_p)->module_p;\n\n    JERRY_ASSERT (module_p->scope_p == NULL);\n    ecma_ref_object (global_scope_p);\n    module_p->scope_p = global_scope_p;\n\n    const ecma_value_t module_init_result = ecma_module_initialize_current ();\n    ecma_module_cleanup ();\n    JERRY_CONTEXT (module_top_context_p) = NULL;\n\n    if (ECMA_IS_VALUE_ERROR (module_init_result))\n    {\n      return module_init_result;\n    }\n  }\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n  return vm_run (bytecode_p,\n                 ecma_make_object_value (glob_obj_p),\n                 global_scope_p,\n                 NULL,\n                 0);\n}",
        "begin_line": 286,
        "end_line": 326,
        "is_bug": false
    }
]