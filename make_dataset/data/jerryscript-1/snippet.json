[
    {
        "name": "jerry-core.api.jerry.jerry_assert_api_available#134",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_assert_api_available (void)",
        "snippet": "static inline void JERRY_ATTR_ALWAYS_INLINE\njerry_assert_api_available (void)\n{\n  JERRY_ASSERT (JERRY_CONTEXT (status_flags) & ECMA_STATUS_API_AVAILABLE);\n}",
        "begin_line": 134,
        "end_line": 138,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_create_external_function#1502",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_create_external_function (jerry_external_handler_t handler_p) /**< pointer to native handler                                                                      *   for the function */",
        "snippet": "jerry_value_t\njerry_create_external_function (jerry_external_handler_t handler_p) /**< pointer to native handler\n                                                                     *   for the function */\n{\n  jerry_assert_api_available ();\n\n  ecma_object_t *func_obj_p = ecma_op_create_external_function_object (handler_p);\n  return ecma_make_object_value (func_obj_p);\n}",
        "begin_line": 1502,
        "end_line": 1510,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_create_string#1704",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_create_string (const jerry_char_t *str_p) /**< pointer to string */",
        "snippet": "jerry_value_t\njerry_create_string (const jerry_char_t *str_p) /**< pointer to string */\n{\n  return jerry_create_string_sz (str_p, lit_zt_utf8_string_size ((lit_utf8_byte_t *) str_p));\n}",
        "begin_line": 1704,
        "end_line": 1708,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_create_string_sz#1718",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_create_string_sz (const jerry_char_t *str_p, /**< pointer to string */                         jerry_size_t str_size) /**< string size */",
        "snippet": "jerry_value_t\njerry_create_string_sz (const jerry_char_t *str_p, /**< pointer to string */\n                        jerry_size_t str_size) /**< string size */\n{\n  jerry_assert_api_available ();\n\n  ecma_string_t *ecma_str_p = ecma_new_ecma_string_from_utf8 ((lit_utf8_byte_t *) str_p,\n                                                              (lit_utf8_size_t) str_size);\n  return ecma_make_string_value (ecma_str_p);\n}",
        "begin_line": 1718,
        "end_line": 1727,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_create_undefined#1566",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_create_undefined (void)",
        "snippet": "jerry_value_t\njerry_create_undefined (void)\n{\n  jerry_assert_api_available ();\n\n  return ECMA_VALUE_UNDEFINED;\n}",
        "begin_line": 1566,
        "end_line": 1572,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_get_global_object#646",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_get_global_object (void)",
        "snippet": "jerry_value_t\njerry_get_global_object (void)\n{\n  jerry_assert_api_available ();\n  ecma_object_t *global_obj_p = ecma_builtin_get_global ();\n  ecma_ref_object (global_obj_p);\n  return ecma_make_object_value (global_obj_p);\n}",
        "begin_line": 646,
        "end_line": 653,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_init#189",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_init (jerry_init_flag_t flags) /**< combination of Jerry flags */",
        "snippet": "void\njerry_init (jerry_init_flag_t flags) /**< combination of Jerry flags */\n{\n  /* This function cannot be called twice unless jerry_cleanup is called. */\n  JERRY_ASSERT (!(JERRY_CONTEXT (status_flags) & ECMA_STATUS_API_AVAILABLE));\n\n  /* Zero out all non-external members. */\n  memset ((char *) &JERRY_CONTEXT_STRUCT + offsetof (jerry_context_t, JERRY_CONTEXT_FIRST_MEMBER), 0,\n          sizeof (jerry_context_t) - offsetof (jerry_context_t, JERRY_CONTEXT_FIRST_MEMBER));\n\n  JERRY_CONTEXT (jerry_init_flags) = flags;\n\n  jerry_make_api_available ();\n\n  jmem_init ();\n  ecma_init ();\n}",
        "begin_line": 189,
        "end_line": 205,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_is_feature_enabled#939",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_is_feature_enabled (const jerry_feature_t feature) /**< feature to check */",
        "snippet": "bool\njerry_is_feature_enabled (const jerry_feature_t feature) /**< feature to check */\n{\n  JERRY_ASSERT (feature < JERRY_FEATURE__COUNT);\n\n  return (false\n#if ENABLED (JERRY_CPOINTER_32_BIT)\n          || feature == JERRY_FEATURE_CPOINTER_32_BIT\n#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */\n#if ENABLED (JERRY_ERROR_MESSAGES)\n          || feature == JERRY_FEATURE_ERROR_MESSAGES\n#endif /* ENABLED (JERRY_ERROR_MESSAGES) */\n#if ENABLED (JERRY_PARSER)\n          || feature == JERRY_FEATURE_JS_PARSER\n#endif /* ENABLED (JERRY_PARSER) */\n#if ENABLED (JERRY_MEM_STATS)\n          || feature == JERRY_FEATURE_MEM_STATS\n#endif /* ENABLED (JERRY_MEM_STATS) */\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n          || feature == JERRY_FEATURE_PARSER_DUMP\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n#if ENABLED (JERRY_REGEXP_DUMP_BYTE_CODE)\n          || feature == JERRY_FEATURE_REGEXP_DUMP\n#endif /* ENABLED (JERRY_REGEXP_DUMP_BYTE_CODE) */\n#if ENABLED (JERRY_SNAPSHOT_SAVE)\n          || feature == JERRY_FEATURE_SNAPSHOT_SAVE\n#endif /* ENABLED (JERRY_SNAPSHOT_SAVE) */\n#if ENABLED (JERRY_SNAPSHOT_EXEC)\n          || feature == JERRY_FEATURE_SNAPSHOT_EXEC\n#endif /* ENABLED (JERRY_SNAPSHOT_EXEC) */\n#if ENABLED (JERRY_DEBUGGER)\n          || feature == JERRY_FEATURE_DEBUGGER\n#endif /* ENABLED (JERRY_DEBUGGER) */\n#if ENABLED (JERRY_VM_EXEC_STOP)\n          || feature == JERRY_FEATURE_VM_EXEC_STOP\n#endif /* ENABLED (JERRY_VM_EXEC_STOP) */\n#if ENABLED (JERRY_BUILTIN_JSON)\n          || feature == JERRY_FEATURE_JSON\n#endif /* ENABLED (JERRY_BUILTIN_JSON) */\n#if ENABLED (JERRY_ES2015_BUILTIN_PROMISE)\n          || feature == JERRY_FEATURE_PROMISE\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */\n#if ENABLED (JERRY_ES2015)\n          || feature == JERRY_FEATURE_SYMBOL\n#endif /* ENABLED (JERRY_ES2015) */\n#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n          || feature == JERRY_FEATURE_TYPEDARRAY\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n#if ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW)\n          || feature == JERRY_FEATURE_DATAVIEW\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW) */\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n          || feature == JERRY_FEATURE_PROXY\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n#if ENABLED (JERRY_BUILTIN_DATE)\n          || feature == JERRY_FEATURE_DATE\n#endif /* ENABLED (JERRY_BUILTIN_DATE) */\n#if ENABLED (JERRY_BUILTIN_REGEXP)\n          || feature == JERRY_FEATURE_REGEXP\n#endif /* ENABLED (JERRY_BUILTIN_REGEXP) */\n#if ENABLED (JERRY_LINE_INFO)\n          || feature == JERRY_FEATURE_LINE_INFO\n#endif /* ENABLED (JERRY_LINE_INFO) */\n#if ENABLED (JERRY_LOGGING)\n          || feature == JERRY_FEATURE_LOGGING\n#endif /* ENABLED (JERRY_LOGGING) */\n#if ENABLED (JERRY_ES2015_BUILTIN_MAP)\n          || feature == JERRY_FEATURE_MAP\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_MAP) */\n#if ENABLED (JERRY_ES2015_BUILTIN_SET)\n          || feature == JERRY_FEATURE_SET\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_SET) */\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP)\n          || feature == JERRY_FEATURE_WEAKMAP\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) */\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)\n          || feature == JERRY_FEATURE_WEAKSET\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */\n          );\n}",
        "begin_line": 939,
        "end_line": 1018,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_is_valid_utf8_string#3378",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_is_valid_utf8_string (const jerry_char_t *utf8_buf_p, /**< UTF-8 string */                             jerry_size_t buf_size) /**< string size */",
        "snippet": "bool\njerry_is_valid_utf8_string (const jerry_char_t *utf8_buf_p, /**< UTF-8 string */\n                            jerry_size_t buf_size) /**< string size */\n{\n  return lit_is_valid_utf8_string ((lit_utf8_byte_t *) utf8_buf_p,\n                                   (lit_utf8_size_t) buf_size);\n}",
        "begin_line": 3378,
        "end_line": 3384,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_make_api_available#143",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_make_api_available (void)",
        "snippet": "static inline void JERRY_ATTR_ALWAYS_INLINE\njerry_make_api_available (void)\n{\n  JERRY_CONTEXT (status_flags) |= ECMA_STATUS_API_AVAILABLE;\n}",
        "begin_line": 143,
        "end_line": 147,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_parse#408",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_parse (const jerry_char_t *resource_name_p, /**< resource name (usually a file name) */              size_t resource_name_length, /**< length of resource name */              const jerry_char_t *source_p, /**< script source */              size_t source_size, /**< script source size */              uint32_t parse_opts) /**< jerry_parse_opts_t option bits */",
        "snippet": "jerry_value_t\njerry_parse (const jerry_char_t *resource_name_p, /**< resource name (usually a file name) */\n             size_t resource_name_length, /**< length of resource name */\n             const jerry_char_t *source_p, /**< script source */\n             size_t source_size, /**< script source size */\n             uint32_t parse_opts) /**< jerry_parse_opts_t option bits */\n{\n#if ENABLED (JERRY_DEBUGGER) && ENABLED (JERRY_PARSER)\n  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n      && resource_name_length > 0)\n  {\n    jerry_debugger_send_string (JERRY_DEBUGGER_SOURCE_CODE_NAME,\n                                JERRY_DEBUGGER_NO_SUBTYPE,\n                                resource_name_p,\n                                resource_name_length);\n  }\n#else /* !(ENABLED (JERRY_DEBUGGER) && ENABLED (JERRY_PARSER)) */\n  JERRY_UNUSED (resource_name_p);\n  JERRY_UNUSED (resource_name_length);\n#endif /* ENABLED (JERRY_DEBUGGER) && ENABLED (JERRY_PARSER) */\n\n#if ENABLED (JERRY_PARSER)\n  jerry_assert_api_available ();\n\n#if ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ERROR_MESSAGES) || ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n  if (resource_name_length == 0)\n  {\n    JERRY_CONTEXT (resource_name) = ecma_make_magic_string_value (LIT_MAGIC_STRING_RESOURCE_ANON);\n  }\n  else\n  {\n    JERRY_CONTEXT (resource_name) = ecma_find_or_create_literal_string (resource_name_p,\n                                                                        (lit_utf8_size_t) resource_name_length);\n  }\n#endif /* ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ERROR_MESSAGES) || ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n  ecma_compiled_code_t *bytecode_data_p;\n  ecma_value_t parse_status;\n\n  parse_status = parser_parse_script (NULL,\n                                      0,\n                                      source_p,\n                                      source_size,\n                                      parse_opts,\n                                      &bytecode_data_p);\n\n  if (ECMA_IS_VALUE_ERROR (parse_status))\n  {\n    return ecma_create_error_reference_from_context ();\n  }\n\n  ecma_free_value (parse_status);\n\n  ecma_object_t *lex_env_p = ecma_get_global_environment ();\n  ecma_object_t *func_obj_p = ecma_op_create_simple_function_object (lex_env_p, bytecode_data_p);\n  ecma_bytecode_deref (bytecode_data_p);\n\n  return ecma_make_object_value (func_obj_p);\n#else /* !ENABLED (JERRY_PARSER) */\n  JERRY_UNUSED (source_p);\n  JERRY_UNUSED (source_size);\n  JERRY_UNUSED (parse_opts);\n\n  return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG (\"The parser has been disabled.\")));\n#endif /* ENABLED (JERRY_PARSER) */\n}",
        "begin_line": 408,
        "end_line": 473,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_release_value#1389",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_release_value (jerry_value_t value) /**< API value */",
        "snippet": "void\njerry_release_value (jerry_value_t value) /**< API value */\n{\n  jerry_assert_api_available ();\n\n  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))\n  {\n    ecma_deref_error_reference (ecma_get_error_reference_from_value (value));\n    return;\n  }\n\n  ecma_free_value (value);\n}",
        "begin_line": 1389,
        "end_line": 1401,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_return#163",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_return (jerry_value_t value) /**< return value */",
        "snippet": "static jerry_value_t\njerry_return (jerry_value_t value) /**< return value */\n{\n  if (ECMA_IS_VALUE_ERROR (value))\n  {\n    value = ecma_create_error_reference_from_context ();\n  }\n\n  return value;\n}",
        "begin_line": 163,
        "end_line": 172,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_run#567",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_run (const jerry_value_t func_val) /**< function to run */",
        "snippet": "jerry_value_t\njerry_run (const jerry_value_t func_val) /**< function to run */\n{\n  jerry_assert_api_available ();\n\n  if (!ecma_is_value_object (func_val))\n  {\n    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));\n  }\n\n  ecma_object_t *func_obj_p = ecma_get_object_from_value (func_val);\n\n  if (ecma_get_object_type (func_obj_p) != ECMA_OBJECT_TYPE_FUNCTION\n      || ecma_get_object_is_builtin (func_obj_p))\n  {\n    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));\n  }\n\n  ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_obj_p;\n\n  ecma_object_t *scope_p = ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t,\n                                                                       ext_func_p->u.function.scope_cp);\n\n  if (scope_p != ecma_get_global_environment ())\n  {\n    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));\n  }\n\n  return jerry_return (vm_run_global (ecma_op_function_get_compiled_code (ext_func_p)));\n}",
        "begin_line": 567,
        "end_line": 596,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_set_property#2394",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_set_property (const jerry_value_t obj_val, /**< object value */                     const jerry_value_t prop_name_val, /**< property name (string value) */                     const jerry_value_t value_to_set) /**< value to set */",
        "snippet": "jerry_value_t\njerry_set_property (const jerry_value_t obj_val, /**< object value */\n                    const jerry_value_t prop_name_val, /**< property name (string value) */\n                    const jerry_value_t value_to_set) /**< value to set */\n{\n  jerry_assert_api_available ();\n\n  if (ecma_is_value_error_reference (value_to_set)\n      || !ecma_is_value_object (obj_val)\n      || !ecma_is_value_prop_name (prop_name_val))\n  {\n    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));\n  }\n\n  return jerry_return (ecma_op_object_put (ecma_get_object_from_value (obj_val),\n                                           ecma_get_prop_name_from_value (prop_name_val),\n                                           value_to_set,\n                                           true));\n}",
        "begin_line": 2394,
        "end_line": 2412,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_value_is_error#725",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_value_is_error (const jerry_value_t value) /**< api value */",
        "snippet": "bool\njerry_value_is_error (const jerry_value_t value) /**< api value */\n{\n  jerry_assert_api_available ();\n\n  return ecma_is_value_error_reference (value);\n}",
        "begin_line": 725,
        "end_line": 731,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-alloc.ecma_alloc_extended_object#102",
        "src_path": "jerry-core/ecma/base/ecma-alloc.c",
        "class_name": "jerry-core.ecma.base.ecma-alloc",
        "signature": "jerry-core.ecma.base.ecma-alloc.ecma_alloc_extended_object (size_t size) /**< size of object */",
        "snippet": "inline ecma_extended_object_t * JERRY_ATTR_ALWAYS_INLINE\necma_alloc_extended_object (size_t size) /**< size of object */\n{\n#if ENABLED (JERRY_MEM_STATS)\n  jmem_stats_allocate_object_bytes (size);\n#endif /* ENABLED (JERRY_MEM_STATS) */\n\n  return jmem_heap_alloc_block (size);\n}",
        "begin_line": 102,
        "end_line": 110,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-alloc.ecma_alloc_extended_string#159",
        "src_path": "jerry-core/ecma/base/ecma-alloc.c",
        "class_name": "jerry-core.ecma.base.ecma-alloc",
        "signature": "jerry-core.ecma.base.ecma-alloc.ecma_alloc_extended_string (void)",
        "snippet": "inline ecma_extended_string_t * JERRY_ATTR_ALWAYS_INLINE\necma_alloc_extended_string (void)\n{\n#if ENABLED (JERRY_MEM_STATS)\n  jmem_stats_allocate_string_bytes (sizeof (ecma_extended_string_t));\n#endif /* ENABLED (JERRY_MEM_STATS) */\n\n  return (ecma_extended_string_t *) jmem_heap_alloc_block (sizeof (ecma_extended_string_t));\n}",
        "begin_line": 159,
        "end_line": 167,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-alloc.ecma_alloc_object#74",
        "src_path": "jerry-core/ecma/base/ecma-alloc.c",
        "class_name": "jerry-core.ecma.base.ecma-alloc",
        "signature": "jerry-core.ecma.base.ecma-alloc.ecma_alloc_object (void)",
        "snippet": "inline ecma_object_t * JERRY_ATTR_ALWAYS_INLINE\necma_alloc_object (void)\n{\n#if ENABLED (JERRY_MEM_STATS)\n  jmem_stats_allocate_object_bytes (sizeof (ecma_object_t));\n#endif /* ENABLED (JERRY_MEM_STATS) */\n\n  return (ecma_object_t *) jmem_pools_alloc (sizeof (ecma_object_t));\n}",
        "begin_line": 74,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-alloc.ecma_alloc_property_pair#216",
        "src_path": "jerry-core/ecma/base/ecma-alloc.c",
        "class_name": "jerry-core.ecma.base.ecma-alloc",
        "signature": "jerry-core.ecma.base.ecma-alloc.ecma_alloc_property_pair (void)",
        "snippet": "inline ecma_property_pair_t * JERRY_ATTR_ALWAYS_INLINE\necma_alloc_property_pair (void)\n{\n#if ENABLED (JERRY_MEM_STATS)\n  jmem_stats_allocate_property_bytes (sizeof (ecma_property_pair_t));\n#endif /* ENABLED (JERRY_MEM_STATS) */\n\n  return jmem_heap_alloc_block (sizeof (ecma_property_pair_t));\n}",
        "begin_line": 216,
        "end_line": 224,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-alloc.ecma_alloc_string_buffer#187",
        "src_path": "jerry-core/ecma/base/ecma-alloc.c",
        "class_name": "jerry-core.ecma.base.ecma-alloc",
        "signature": "jerry-core.ecma.base.ecma-alloc.ecma_alloc_string_buffer (size_t size) /**< size of string */",
        "snippet": "inline ecma_string_t * JERRY_ATTR_ALWAYS_INLINE\necma_alloc_string_buffer (size_t size) /**< size of string */\n{\n#if ENABLED (JERRY_MEM_STATS)\n  jmem_stats_allocate_string_bytes (size);\n#endif /* ENABLED (JERRY_MEM_STATS) */\n\n  return jmem_heap_alloc_block (size);\n}",
        "begin_line": 187,
        "end_line": 195,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-alloc.ecma_dealloc_extended_object#115",
        "src_path": "jerry-core/ecma/base/ecma-alloc.c",
        "class_name": "jerry-core.ecma.base.ecma-alloc",
        "signature": "jerry-core.ecma.base.ecma-alloc.ecma_dealloc_extended_object (ecma_object_t *object_p, /**< extended object */                               size_t size) /**< size of object */",
        "snippet": "inline void JERRY_ATTR_ALWAYS_INLINE\necma_dealloc_extended_object (ecma_object_t *object_p, /**< extended object */\n                              size_t size) /**< size of object */\n{\n#if ENABLED (JERRY_MEM_STATS)\n  jmem_stats_free_object_bytes (size);\n#endif /* ENABLED (JERRY_MEM_STATS) */\n\n  jmem_heap_free_block (object_p, size);\n}",
        "begin_line": 115,
        "end_line": 124,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-alloc.ecma_dealloc_object#87",
        "src_path": "jerry-core/ecma/base/ecma-alloc.c",
        "class_name": "jerry-core.ecma.base.ecma-alloc",
        "signature": "jerry-core.ecma.base.ecma-alloc.ecma_dealloc_object (ecma_object_t *object_p) /**< object to be freed */",
        "snippet": "inline void JERRY_ATTR_ALWAYS_INLINE\necma_dealloc_object (ecma_object_t *object_p) /**< object to be freed */\n{\n#if ENABLED (JERRY_MEM_STATS)\n  jmem_stats_free_object_bytes (sizeof (ecma_object_t));\n#endif /* ENABLED (JERRY_MEM_STATS) */\n\n  jmem_pools_free (object_p, sizeof (ecma_object_t));\n}",
        "begin_line": 87,
        "end_line": 95,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-alloc.ecma_dealloc_property_pair#229",
        "src_path": "jerry-core/ecma/base/ecma-alloc.c",
        "class_name": "jerry-core.ecma.base.ecma-alloc",
        "signature": "jerry-core.ecma.base.ecma-alloc.ecma_dealloc_property_pair (ecma_property_pair_t *property_pair_p) /**< property pair to be freed */",
        "snippet": "inline void JERRY_ATTR_ALWAYS_INLINE\necma_dealloc_property_pair (ecma_property_pair_t *property_pair_p) /**< property pair to be freed */\n{\n#if ENABLED (JERRY_MEM_STATS)\n  jmem_stats_free_property_bytes (sizeof (ecma_property_pair_t));\n#endif /* ENABLED (JERRY_MEM_STATS) */\n\n  jmem_heap_free_block (property_pair_p, sizeof (ecma_property_pair_t));\n}",
        "begin_line": 229,
        "end_line": 237,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-alloc.ecma_dealloc_string_buffer#200",
        "src_path": "jerry-core/ecma/base/ecma-alloc.c",
        "class_name": "jerry-core.ecma.base.ecma-alloc",
        "signature": "jerry-core.ecma.base.ecma-alloc.ecma_dealloc_string_buffer (ecma_string_t *string_p, /**< string with data */                             size_t size) /**< size of string */",
        "snippet": "inline void JERRY_ATTR_ALWAYS_INLINE\necma_dealloc_string_buffer (ecma_string_t *string_p, /**< string with data */\n                            size_t size) /**< size of string */\n{\n#if ENABLED (JERRY_MEM_STATS)\n  jmem_stats_free_string_bytes (size);\n#endif /* ENABLED (JERRY_MEM_STATS) */\n\n  jmem_heap_free_block (string_p, size);\n}",
        "begin_line": 200,
        "end_line": 209,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_deref_object#146",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_deref_object (ecma_object_t *object_p) /**< object */",
        "snippet": "inline void JERRY_ATTR_ALWAYS_INLINE\necma_deref_object (ecma_object_t *object_p) /**< object */\n{\n  JERRY_ASSERT (object_p->type_flags_refs >= ECMA_OBJECT_REF_ONE);\n  object_p->type_flags_refs = (uint16_t) (object_p->type_flags_refs - ECMA_OBJECT_REF_ONE);\n}",
        "begin_line": 146,
        "end_line": 151,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_free_unused_memory#1479",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_free_unused_memory (jmem_pressure_t pressure) /**< current pressure */",
        "snippet": "void\necma_free_unused_memory (jmem_pressure_t pressure) /**< current pressure */\n{\n#if ENABLED (JERRY_DEBUGGER)\n  while ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n         && JERRY_CONTEXT (debugger_byte_code_free_tail) != ECMA_NULL_POINTER)\n  {\n    /* Wait until all byte code is freed or the connection is aborted. */\n    jerry_debugger_receive (NULL);\n  }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n  if (JERRY_LIKELY (pressure == JMEM_PRESSURE_LOW))\n  {\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n    if (JERRY_CONTEXT (ecma_prop_hashmap_alloc_state) > ECMA_PROP_HASHMAP_ALLOC_ON)\n    {\n      --JERRY_CONTEXT (ecma_prop_hashmap_alloc_state);\n    }\n    JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_HIGH_PRESSURE_GC;\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n    /*\n     * If there is enough newly allocated objects since last GC, probably it is worthwhile to start GC now.\n     * Otherwise, probability to free sufficient space is considered to be low.\n     */\n    size_t new_objects_fraction = CONFIG_ECMA_GC_NEW_OBJECTS_FRACTION;\n\n    if (JERRY_CONTEXT (ecma_gc_new_objects) * new_objects_fraction > JERRY_CONTEXT (ecma_gc_objects_number))\n    {\n      ecma_gc_run ();\n    }\n\n    return;\n  }\n  else if (pressure == JMEM_PRESSURE_HIGH)\n  {\n    /* Freeing as much memory as we currently can */\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n    if (JERRY_CONTEXT (status_flags) & ECMA_STATUS_HIGH_PRESSURE_GC)\n    {\n      JERRY_CONTEXT (ecma_prop_hashmap_alloc_state) = ECMA_PROP_HASHMAP_ALLOC_MAX;\n    }\n    else if (JERRY_CONTEXT (ecma_prop_hashmap_alloc_state) < ECMA_PROP_HASHMAP_ALLOC_MAX)\n    {\n      ++JERRY_CONTEXT (ecma_prop_hashmap_alloc_state);\n      JERRY_CONTEXT (status_flags) |= ECMA_STATUS_HIGH_PRESSURE_GC;\n    }\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n    ecma_gc_run ();\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n    /* Free hashmaps of remaining objects. */\n    jmem_cpointer_t obj_iter_cp = JERRY_CONTEXT (ecma_gc_objects_cp);\n\n    while (obj_iter_cp != JMEM_CP_NULL)\n    {\n      ecma_object_t *obj_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_iter_cp);\n\n      if (!ecma_is_lexical_environment (obj_iter_p)\n          || ecma_get_lex_env_type (obj_iter_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n      {\n        if (!ecma_is_lexical_environment (obj_iter_p)\n            && ecma_op_object_is_fast_array (obj_iter_p))\n        {\n          obj_iter_cp = obj_iter_p->gc_next_cp;\n          continue;\n        }\n\n        jmem_cpointer_t prop_iter_cp = obj_iter_p->u1.property_list_cp;\n\n        if (prop_iter_cp != JMEM_CP_NULL)\n        {\n          ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n\n          if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n          {\n            ecma_property_hashmap_free (obj_iter_p);\n          }\n        }\n\n      }\n\n      obj_iter_cp = obj_iter_p->gc_next_cp;\n    }\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n    jmem_pools_collect_empty ();\n    return;\n  }\n  else if (JERRY_UNLIKELY (pressure == JMEM_PRESSURE_FULL))\n  {\n    jerry_fatal (ERR_OUT_OF_MEMORY);\n  }\n  else\n  {\n    JERRY_ASSERT (pressure == JMEM_PRESSURE_NONE);\n    JERRY_UNREACHABLE ();\n  }\n}",
        "begin_line": 1479,
        "end_line": 1578,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_gc_free_object#1011",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_gc_free_object (ecma_object_t *object_p) /**< object to free */",
        "snippet": "static void\necma_gc_free_object (ecma_object_t *object_p) /**< object to free */\n{\n  JERRY_ASSERT (object_p != NULL\n                && !ecma_gc_is_object_visited (object_p)\n                && ((object_p->type_flags_refs & ECMA_OBJECT_REF_MASK) == ECMA_OBJECT_NON_VISITED));\n\n  JERRY_ASSERT (JERRY_CONTEXT (ecma_gc_objects_number) > 0);\n  JERRY_CONTEXT (ecma_gc_objects_number)--;\n\n  if (ecma_is_lexical_environment (object_p))\n  {\n    if (ecma_get_lex_env_type (object_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n    {\n      ecma_gc_free_properties (object_p);\n    }\n\n    ecma_dealloc_object (object_p);\n    return;\n  }\n\n  ecma_object_type_t object_type = ecma_get_object_type (object_p);\n\n  size_t ext_object_size = sizeof (ecma_extended_object_t);\n\n  if (JERRY_UNLIKELY (ecma_get_object_is_builtin (object_p)))\n  {\n    uint8_t length_and_bitset_size;\n\n    if (object_type == ECMA_OBJECT_TYPE_CLASS\n        || object_type == ECMA_OBJECT_TYPE_ARRAY)\n    {\n      ext_object_size = sizeof (ecma_extended_built_in_object_t);\n      length_and_bitset_size = ((ecma_extended_built_in_object_t *) object_p)->built_in.length_and_bitset_size;\n      ext_object_size += (2 * sizeof (uint32_t)) * (length_and_bitset_size >> ECMA_BUILT_IN_BITSET_SHIFT);\n    }\n    else\n    {\n      length_and_bitset_size = ((ecma_extended_object_t *) object_p)->u.built_in.length_and_bitset_size;\n      ext_object_size += (2 * sizeof (uint32_t)) * (length_and_bitset_size >> ECMA_BUILT_IN_BITSET_SHIFT);\n\n      ecma_gc_free_properties (object_p);\n      ecma_dealloc_extended_object (object_p, ext_object_size);\n      return;\n    }\n  }\n\n  switch (object_type)\n  {\n    case ECMA_OBJECT_TYPE_GENERAL:\n    {\n      ecma_gc_free_properties (object_p);\n      ecma_dealloc_object (object_p);\n      return;\n    }\n    case ECMA_OBJECT_TYPE_ARRAY:\n    {\n      if (ecma_op_array_is_fast_array ((ecma_extended_object_t *) object_p))\n      {\n        ecma_free_fast_access_array (object_p);\n        return;\n      }\n      break;\n    }\n    case ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION:\n    {\n#if ENABLED (JERRY_ES2015)\n      ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;\n\n      if (ext_func_p->u.external_handler_cb == ecma_proxy_revoke_cb)\n      {\n        ext_object_size = sizeof (ecma_revocable_proxy_object_t);\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      break;\n    }\n    case ECMA_OBJECT_TYPE_CLASS:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      switch (ext_object_p->u.class_prop.class_id)\n      {\n#if ENABLED (JERRY_ES2015)\n        case LIT_MAGIC_STRING_SYMBOL_UL:\n#endif /* ENABLED (JERRY_ES2015) */\n        case LIT_MAGIC_STRING_STRING_UL:\n        case LIT_MAGIC_STRING_NUMBER_UL:\n        {\n          ecma_free_value (ext_object_p->u.class_prop.u.value);\n          break;\n        }\n\n        case LIT_MAGIC_STRING_DATE_UL:\n        {\n          ecma_number_t *num_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_number_t,\n                                                                  ext_object_p->u.class_prop.u.value);\n          ecma_dealloc_number (num_p);\n          break;\n        }\n        case LIT_MAGIC_STRING_REGEXP_UL:\n        {\n          ecma_compiled_code_t *bytecode_p = ECMA_GET_INTERNAL_VALUE_ANY_POINTER (ecma_compiled_code_t,\n                                                                                  ext_object_p->u.class_prop.u.value);\n\n          ecma_bytecode_deref (bytecode_p);\n\n          break;\n        }\n#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n        case LIT_MAGIC_STRING_ARRAY_BUFFER_UL:\n        {\n          ecma_length_t arraybuffer_length = ext_object_p->u.class_prop.u.length;\n\n          if (ECMA_ARRAYBUFFER_HAS_EXTERNAL_MEMORY (ext_object_p))\n          {\n            ext_object_size = sizeof (ecma_arraybuffer_external_info);\n\n            /* Call external free callback if any. */\n            ecma_arraybuffer_external_info *array_p = (ecma_arraybuffer_external_info *) ext_object_p;\n            JERRY_ASSERT (array_p != NULL);\n\n            if (array_p->free_cb != NULL)\n            {\n              (array_p->free_cb) (array_p->buffer_p);\n            }\n          }\n          else\n          {\n            ext_object_size += arraybuffer_length;\n          }\n\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n#if ENABLED (JERRY_ES2015_BUILTIN_PROMISE)\n        case LIT_MAGIC_STRING_PROMISE_UL:\n        {\n          ecma_free_value_if_not_object (ext_object_p->u.class_prop.u.value);\n\n          /* Reactions only contains objects. */\n          ecma_collection_destroy (((ecma_promise_object_t *) object_p)->reactions);\n\n          ext_object_size = sizeof (ecma_promise_object_t);\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */\n#if ENABLED (JERRY_ES2015_BUILTIN_CONTAINER)\n#if ENABLED (JERRY_ES2015_BUILTIN_MAP)\n        case LIT_MAGIC_STRING_MAP_UL:\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_MAP) */\n#if ENABLED (JERRY_ES2015_BUILTIN_SET)\n        case LIT_MAGIC_STRING_SET_UL:\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_SET) */\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP)\n        case LIT_MAGIC_STRING_WEAKMAP_UL:\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) */\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)\n        case LIT_MAGIC_STRING_WEAKSET_UL:\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */\n        {\n          ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) object_p;\n          ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                            map_object_p->u.class_prop.u.value);\n          ecma_op_container_free_entries (object_p);\n          ecma_collection_destroy (container_p);\n\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_CONTAINER) */\n#if ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW)\n        case LIT_MAGIC_STRING_DATAVIEW_UL:\n        {\n          ext_object_size = sizeof (ecma_dataview_object_t);\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW) */\n#if ENABLED (JERRY_ES2015)\n        case LIT_MAGIC_STRING_GENERATOR_UL:\n        {\n          ext_object_size = ecma_gc_free_executable_object (object_p);\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n        default:\n        {\n          /* The undefined id represents an uninitialized class. */\n          JERRY_ASSERT (ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_UNDEFINED\n                        || ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_ARGUMENTS_UL\n                        || ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_BOOLEAN_UL\n                        || ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_ERROR_UL\n                        || ext_object_p->u.class_prop.class_id == LIT_INTERNAL_MAGIC_STRING_INTERNAL_OBJECT);\n          break;\n        }\n      }\n\n      break;\n    }\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n    case ECMA_OBJECT_TYPE_PROXY:\n    {\n      ext_object_size = sizeof (ecma_proxy_object_t);\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n    case ECMA_OBJECT_TYPE_FUNCTION:\n    {\n      /* Function with byte-code (not a built-in function). */\n      ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;\n\n#if ENABLED (JERRY_SNAPSHOT_EXEC)\n      if (ext_func_p->u.function.bytecode_cp != ECMA_NULL_POINTER)\n      {\n#endif /* ENABLED (JERRY_SNAPSHOT_EXEC) */\n        ecma_compiled_code_t *byte_code_p = (ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,\n                                                                              ext_func_p->u.function.bytecode_cp));\n\n#if ENABLED (JERRY_ES2015)\n        if (byte_code_p->status_flags & CBC_CODE_FLAGS_ARROW_FUNCTION)\n        {\n          ecma_free_value_if_not_object (((ecma_arrow_function_t *) object_p)->this_binding);\n          ecma_free_value_if_not_object (((ecma_arrow_function_t *) object_p)->new_target);\n          ext_object_size = sizeof (ecma_arrow_function_t);\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        ecma_bytecode_deref (byte_code_p);\n#if ENABLED (JERRY_SNAPSHOT_EXEC)\n      }\n      else\n      {\n        ext_object_size = sizeof (ecma_static_function_t);\n      }\n#endif /* ENABLED (JERRY_SNAPSHOT_EXEC) */\n      break;\n    }\n    case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      switch (ext_object_p->u.pseudo_array.type)\n      {\n        case ECMA_PSEUDO_ARRAY_ARGUMENTS:\n        {\n          JERRY_ASSERT (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS);\n\n          ecma_length_t formal_params_number = ext_object_p->u.pseudo_array.u1.length;\n          ecma_value_t *arg_Literal_p = (ecma_value_t *) (ext_object_p + 1);\n\n          for (ecma_length_t i = 0; i < formal_params_number; i++)\n          {\n            if (arg_Literal_p[i] != ECMA_VALUE_EMPTY)\n            {\n              ecma_string_t *name_p = ecma_get_string_from_value (arg_Literal_p[i]);\n              ecma_deref_ecma_string (name_p);\n            }\n          }\n\n          size_t formal_params_size = formal_params_number * sizeof (ecma_value_t);\n          ext_object_size += formal_params_size;\n          break;\n        }\n#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n        case ECMA_PSEUDO_ARRAY_TYPEDARRAY_WITH_INFO:\n        {\n          ext_object_size = sizeof (ecma_extended_typedarray_object_t);\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n#if ENABLED (JERRY_ES2015)\n        case ECMA_PSEUDO_STRING_ITERATOR:\n        {\n          ecma_value_t iterated_value = ext_object_p->u.pseudo_array.u2.iterated_value;\n\n          if (!ecma_is_value_empty (iterated_value))\n          {\n            ecma_deref_ecma_string (ecma_get_string_from_value (iterated_value));\n          }\n\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n        default:\n        {\n          JERRY_ASSERT (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_TYPEDARRAY\n                        || ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ITERATOR\n                        || ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_SET_ITERATOR\n                        || ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_MAP_ITERATOR);\n          break;\n        }\n      }\n\n      break;\n    }\n    case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n    {\n      ext_object_size = sizeof (ecma_bound_function_t);\n      ecma_bound_function_t *bound_func_p = (ecma_bound_function_t *) object_p;\n\n      ecma_value_t args_len_or_this = bound_func_p->header.u.bound_function.args_len_or_this;\n\n      if (!ecma_is_value_integer_number (args_len_or_this))\n      {\n        ecma_free_value_if_not_object (args_len_or_this);\n        break;\n      }\n\n      ecma_integer_value_t args_length = ecma_get_integer_from_value (args_len_or_this);\n      ecma_value_t *args_p = (ecma_value_t *) (bound_func_p + 1);\n\n      for (ecma_integer_value_t i = 0; i < args_length; i++)\n      {\n        ecma_free_value_if_not_object (args_p[i]);\n      }\n\n      size_t args_size = ((size_t) args_length) * sizeof (ecma_value_t);\n      ext_object_size += args_size;\n      break;\n    }\n    default:\n    {\n      JERRY_UNREACHABLE ();\n    }\n  }\n\n  ecma_gc_free_properties (object_p);\n  ecma_dealloc_extended_object (object_p, ext_object_size);\n}",
        "begin_line": 1011,
        "end_line": 1337,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_gc_free_properties#933",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_gc_free_properties (ecma_object_t *object_p) /**< object */",
        "snippet": "static void\necma_gc_free_properties (ecma_object_t *object_p) /**< object */\n{\n  jmem_cpointer_t prop_iter_cp = object_p->u1.property_list_cp;\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n  if (prop_iter_cp != JMEM_CP_NULL)\n  {\n    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,\n                                                                     prop_iter_cp);\n    if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n    {\n      ecma_property_hashmap_free (object_p);\n      prop_iter_cp = object_p->u1.property_list_cp;\n    }\n  }\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n  while (prop_iter_cp != JMEM_CP_NULL)\n  {\n    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n    /* Both cannot be deleted. */\n    JERRY_ASSERT (prop_iter_p->types[0] != ECMA_PROPERTY_TYPE_DELETED\n                  || prop_iter_p->types[1] != ECMA_PROPERTY_TYPE_DELETED);\n\n    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)\n    {\n      ecma_property_t *property_p = (ecma_property_t *) (prop_iter_p->types + i);\n      jmem_cpointer_t name_cp = prop_pair_p->names_cp[i];\n\n      if (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_MAGIC)\n      {\n        /* Call the native's free callback. */\n        if (JERRY_UNLIKELY (name_cp == LIT_INTERNAL_MAGIC_STRING_NATIVE_POINTER))\n        {\n          ecma_gc_free_native_pointer (property_p);\n        }\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) || ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)\n        else if (JERRY_UNLIKELY (name_cp == LIT_INTERNAL_MAGIC_STRING_WEAK_REFS))\n        {\n          ecma_collection_t *refs_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                       ECMA_PROPERTY_VALUE_PTR (property_p)->value);\n          for (uint32_t j = 0; j < refs_p->item_count; j++)\n          {\n            const ecma_value_t value = refs_p->buffer_p[j];\n            if (!ecma_is_value_empty (value))\n            {\n              ecma_object_t *container_p = ecma_get_object_from_value (value);\n\n              ecma_op_container_remove_weak_entry (container_p,\n                                                   ecma_make_object_value (object_p));\n            }\n          }\n\n          ecma_collection_destroy (refs_p);\n        }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) || ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */\n      }\n\n      if (prop_iter_p->types[i] != ECMA_PROPERTY_TYPE_DELETED)\n      {\n        ecma_free_property (object_p, name_cp, property_p);\n      }\n    }\n\n    prop_iter_cp = prop_iter_p->next_property_cp;\n\n    ecma_dealloc_property_pair (prop_pair_p);\n  }\n}",
        "begin_line": 933,
        "end_line": 1006,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_gc_is_object_visited#66",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_gc_is_object_visited (ecma_object_t *object_p) /**< object */",
        "snippet": "static inline bool JERRY_ATTR_ALWAYS_INLINE\necma_gc_is_object_visited (ecma_object_t *object_p) /**< object */\n{\n  JERRY_ASSERT (object_p != NULL);\n\n  return (object_p->type_flags_refs < ECMA_OBJECT_NON_VISITED);\n}",
        "begin_line": 66,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_gc_mark#515",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_gc_mark (ecma_object_t *object_p) /**< object to mark from */",
        "snippet": "static void\necma_gc_mark (ecma_object_t *object_p) /**< object to mark from */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (ecma_gc_is_object_visited (object_p));\n\n  if (ecma_is_lexical_environment (object_p))\n  {\n    jmem_cpointer_t outer_lex_env_cp = object_p->u2.outer_reference_cp;\n\n    if (outer_lex_env_cp != JMEM_CP_NULL)\n    {\n      ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER (ecma_object_t, outer_lex_env_cp));\n    }\n\n    if (ecma_get_lex_env_type (object_p) != ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n    {\n      ecma_object_t *binding_object_p = ecma_get_lex_env_binding_object (object_p);\n      ecma_gc_set_object_visited (binding_object_p);\n\n      return;\n    }\n  }\n  else\n  {\n    jmem_cpointer_t proto_cp = object_p->u2.prototype_cp;\n\n    if (proto_cp != JMEM_CP_NULL)\n    {\n      ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp));\n    }\n\n    switch (ecma_get_object_type (object_p))\n    {\n      case ECMA_OBJECT_TYPE_CLASS:\n      {\n        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n        switch (ext_object_p->u.class_prop.class_id)\n        {\n#if ENABLED (JERRY_ES2015_BUILTIN_PROMISE)\n          case LIT_MAGIC_STRING_PROMISE_UL:\n          {\n            ecma_gc_mark_promise_object (ext_object_p);\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */\n#if ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW)\n          case LIT_MAGIC_STRING_DATAVIEW_UL:\n          {\n            ecma_dataview_object_t *dataview_p = (ecma_dataview_object_t *) object_p;\n            ecma_gc_set_object_visited (dataview_p->buffer_p);\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW) */\n#if ENABLED (JERRY_ES2015_BUILTIN_CONTAINER)\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)\n          case LIT_MAGIC_STRING_WEAKSET_UL:\n          {\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */\n#if ENABLED (JERRY_ES2015_BUILTIN_SET)\n          case LIT_MAGIC_STRING_SET_UL:\n          {\n            ecma_gc_mark_set_object (object_p);\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_SET) */\n#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP)\n          case LIT_MAGIC_STRING_WEAKMAP_UL:\n          {\n            ecma_gc_mark_weakmap_object (object_p);\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) */\n#if ENABLED (JERRY_ES2015_BUILTIN_MAP)\n          case LIT_MAGIC_STRING_MAP_UL:\n          {\n            ecma_gc_mark_map_object (object_p);\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_MAP) */\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_CONTAINER) */\n#if ENABLED (JERRY_ES2015)\n          case LIT_MAGIC_STRING_GENERATOR_UL:\n          {\n            ecma_gc_mark_executable_object (object_p);\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n          default:\n          {\n            break;\n          }\n        }\n\n        break;\n      }\n      case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:\n      {\n        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n        switch (ext_object_p->u.pseudo_array.type)\n        {\n#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n          case ECMA_PSEUDO_ARRAY_TYPEDARRAY:\n          case ECMA_PSEUDO_ARRAY_TYPEDARRAY_WITH_INFO:\n          {\n            ecma_gc_set_object_visited (ecma_typedarray_get_arraybuffer (object_p));\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n#if ENABLED (JERRY_ES2015)\n          case ECMA_PSEUDO_ARRAY_ITERATOR:\n          case ECMA_PSEUDO_SET_ITERATOR:\n          case ECMA_PSEUDO_MAP_ITERATOR:\n          {\n            ecma_value_t iterated_value = ext_object_p->u.pseudo_array.u2.iterated_value;\n            if (!ecma_is_value_empty (iterated_value))\n            {\n              ecma_gc_set_object_visited (ecma_get_object_from_value (iterated_value));\n            }\n            break;\n          }\n          case ECMA_PSEUDO_STRING_ITERATOR:\n          {\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n          default:\n          {\n            JERRY_ASSERT (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS);\n\n            ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t,\n                                                                        ext_object_p->u.pseudo_array.u2.lex_env_cp);\n\n            ecma_gc_set_object_visited (lex_env_p);\n            break;\n          }\n        }\n\n        break;\n      }\n      case ECMA_OBJECT_TYPE_ARRAY:\n      {\n        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n        if (ecma_op_array_is_fast_array (ext_object_p))\n        {\n          if (object_p->u1.property_list_cp != JMEM_CP_NULL)\n          {\n            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);\n\n            for (uint32_t i = 0; i < ext_object_p->u.array.length; i++)\n            {\n              if (ecma_is_value_object (values_p[i]))\n              {\n                ecma_gc_set_object_visited (ecma_get_object_from_value (values_p[i]));\n              }\n            }\n          }\n\n          return;\n        }\n        break;\n      }\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n      case ECMA_OBJECT_TYPE_PROXY:\n      {\n        ecma_gc_mark_proxy_object (object_p);\n        break;\n      }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n      {\n        ecma_gc_mark_bound_function_object (object_p);\n        break;\n      }\n      case ECMA_OBJECT_TYPE_FUNCTION:\n      {\n        if (!ecma_get_object_is_builtin (object_p))\n        {\n          ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;\n          ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t,\n                                                                                  ext_func_p->u.function.scope_cp));\n\n#if ENABLED (JERRY_ES2015)\n          const ecma_compiled_code_t *byte_code_p = ecma_op_function_get_compiled_code (ext_func_p);\n\n          if (byte_code_p->status_flags & CBC_CODE_FLAG_HAS_TAGGED_LITERALS)\n          {\n            ecma_gc_mark_tagged_template_literals (byte_code_p);\n          }\n\n          if (byte_code_p->status_flags & CBC_CODE_FLAGS_ARROW_FUNCTION)\n          {\n            ecma_arrow_function_t *arrow_func_p = (ecma_arrow_function_t *) object_p;\n\n            if (ecma_is_value_object (arrow_func_p->this_binding))\n            {\n              ecma_gc_set_object_visited (ecma_get_object_from_value (arrow_func_p->this_binding));\n            }\n\n            if (ecma_is_value_object (arrow_func_p->new_target))\n            {\n              ecma_gc_set_object_visited (ecma_get_object_from_value (arrow_func_p->new_target));\n            }\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n        }\n        break;\n      }\n#if ENABLED (JERRY_ES2015)\n      case ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION:\n      {\n        ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;\n\n        if (ext_func_p->u.external_handler_cb == ecma_proxy_revoke_cb)\n        {\n          ecma_revocable_proxy_object_t *rev_proxy_p = (ecma_revocable_proxy_object_t *) object_p;\n\n          if (!ecma_is_value_null (rev_proxy_p->proxy))\n          {\n            ecma_gc_set_object_visited (ecma_get_object_from_value (rev_proxy_p->proxy));\n          }\n        }\n        break;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      default:\n      {\n        break;\n      }\n    }\n  }\n\n  jmem_cpointer_t prop_iter_cp = object_p->u1.property_list_cp;\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n  if (prop_iter_cp != JMEM_CP_NULL)\n  {\n    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n    if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n    {\n      prop_iter_cp = prop_iter_p->next_property_cp;\n    }\n  }\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n  while (prop_iter_cp != JMEM_CP_NULL)\n  {\n    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n    ecma_gc_mark_properties ((ecma_property_pair_t *) prop_iter_p);\n\n    prop_iter_cp = prop_iter_p->next_property_cp;\n  }\n}",
        "begin_line": 515,
        "end_line": 774,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_gc_mark_properties#156",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_gc_mark_properties (ecma_property_pair_t *property_pair_p) /**< property pair */",
        "snippet": "static inline void JERRY_ATTR_ALWAYS_INLINE\necma_gc_mark_properties (ecma_property_pair_t *property_pair_p) /**< property pair */\n{\n  for (uint32_t index = 0; index < ECMA_PROPERTY_PAIR_ITEM_COUNT; index++)\n  {\n    uint8_t property = property_pair_p->header.types[index];\n\n    switch (ECMA_PROPERTY_GET_TYPE (property))\n    {\n      case ECMA_PROPERTY_TYPE_NAMEDDATA:\n      {\n        ecma_value_t value = property_pair_p->values[index].value;\n\n        if (ecma_is_value_object (value))\n        {\n          ecma_object_t *value_obj_p = ecma_get_object_from_value (value);\n\n          ecma_gc_set_object_visited (value_obj_p);\n        }\n        break;\n      }\n      case ECMA_PROPERTY_TYPE_NAMEDACCESSOR:\n      {\n        ecma_property_value_t *accessor_objs_p = property_pair_p->values + index;\n\n        ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (accessor_objs_p);\n\n        if (get_set_pair_p->getter_cp != JMEM_CP_NULL)\n        {\n          ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp));\n        }\n\n        if (get_set_pair_p->setter_cp != JMEM_CP_NULL)\n        {\n          ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->setter_cp));\n        }\n        break;\n      }\n      case ECMA_PROPERTY_TYPE_INTERNAL:\n      {\n        JERRY_ASSERT (ECMA_PROPERTY_GET_NAME_TYPE (property) == ECMA_DIRECT_STRING_MAGIC\n                      && property_pair_p->names_cp[index] >= LIT_FIRST_INTERNAL_MAGIC_STRING);\n        break;\n      }\n      default:\n      {\n        JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (property) == ECMA_PROPERTY_TYPE_SPECIAL);\n\n        JERRY_ASSERT (property == ECMA_PROPERTY_TYPE_HASHMAP\n                      || property == ECMA_PROPERTY_TYPE_DELETED);\n        break;\n      }\n    }\n  }\n}",
        "begin_line": 156,
        "end_line": 210,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_gc_run#1342",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_gc_run (void)",
        "snippet": "void\necma_gc_run (void)\n{\n#if (JERRY_GC_MARK_LIMIT != 0)\n  JERRY_ASSERT (JERRY_CONTEXT (ecma_gc_mark_recursion_limit) == JERRY_GC_MARK_LIMIT);\n#endif /* (JERRY_GC_MARK_LIMIT != 0) */\n\n  JERRY_CONTEXT (ecma_gc_new_objects) = 0;\n\n  ecma_object_t black_list_head;\n  black_list_head.gc_next_cp = JMEM_CP_NULL;\n  ecma_object_t *black_end_p = &black_list_head;\n\n  ecma_object_t white_gray_list_head;\n  white_gray_list_head.gc_next_cp = JERRY_CONTEXT (ecma_gc_objects_cp);\n\n  ecma_object_t *obj_prev_p = &white_gray_list_head;\n  jmem_cpointer_t obj_iter_cp = obj_prev_p->gc_next_cp;\n  ecma_object_t *obj_iter_p;\n\n  /* Move root objects (i.e. they have global or stack references) to the black list. */\n  while (obj_iter_cp != JMEM_CP_NULL)\n  {\n    obj_iter_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_object_t, obj_iter_cp);\n    const jmem_cpointer_t obj_next_cp = obj_iter_p->gc_next_cp;\n\n    JERRY_ASSERT (obj_prev_p == NULL\n                  || ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_prev_p->gc_next_cp) == obj_iter_p);\n\n    if (obj_iter_p->type_flags_refs >= ECMA_OBJECT_REF_ONE)\n    {\n      /* Moving the object to list of marked objects. */\n      obj_prev_p->gc_next_cp = obj_next_cp;\n\n      black_end_p->gc_next_cp = obj_iter_cp;\n      black_end_p = obj_iter_p;\n    }\n    else\n    {\n      obj_iter_p->type_flags_refs |= ECMA_OBJECT_NON_VISITED;\n      obj_prev_p = obj_iter_p;\n    }\n\n    obj_iter_cp = obj_next_cp;\n  }\n\n  black_end_p->gc_next_cp = JMEM_CP_NULL;\n\n  /* Mark root objects. */\n  obj_iter_cp = black_list_head.gc_next_cp;\n  while (obj_iter_cp != JMEM_CP_NULL)\n  {\n    obj_iter_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_object_t, obj_iter_cp);\n    ecma_gc_mark (obj_iter_p);\n    obj_iter_cp = obj_iter_p->gc_next_cp;\n  }\n\n  /* Mark non-root objects. */\n  bool marked_anything_during_current_iteration;\n\n  do\n  {\n#if (JERRY_GC_MARK_LIMIT != 0)\n    JERRY_ASSERT (JERRY_CONTEXT (ecma_gc_mark_recursion_limit) == JERRY_GC_MARK_LIMIT);\n#endif /* (JERRY_GC_MARK_LIMIT != 0) */\n\n    marked_anything_during_current_iteration = false;\n\n    obj_prev_p = &white_gray_list_head;\n    obj_iter_cp = obj_prev_p->gc_next_cp;\n\n    while (obj_iter_cp != JMEM_CP_NULL)\n    {\n      obj_iter_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_object_t, obj_iter_cp);\n      const jmem_cpointer_t obj_next_cp = obj_iter_p->gc_next_cp;\n\n      JERRY_ASSERT (obj_prev_p == NULL\n                    || ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_prev_p->gc_next_cp) == obj_iter_p);\n\n      if (ecma_gc_is_object_visited (obj_iter_p))\n      {\n        /* Moving the object to list of marked objects */\n        obj_prev_p->gc_next_cp = obj_next_cp;\n\n        black_end_p->gc_next_cp = obj_iter_cp;\n        black_end_p = obj_iter_p;\n\n#if (JERRY_GC_MARK_LIMIT != 0)\n        if (obj_iter_p->type_flags_refs >= ECMA_OBJECT_REF_ONE)\n        {\n          /* Set the reference count of non-marked gray object to 0 */\n          obj_iter_p->type_flags_refs = (uint16_t) (obj_iter_p->type_flags_refs & (ECMA_OBJECT_REF_ONE - 1));\n          ecma_gc_mark (obj_iter_p);\n          marked_anything_during_current_iteration = true;\n        }\n#else /* (JERRY_GC_MARK_LIMIT == 0) */\n        marked_anything_during_current_iteration = true;\n#endif /* (JERRY_GC_MARK_LIMIT != 0) */\n      }\n      else\n      {\n        obj_prev_p = obj_iter_p;\n      }\n\n      obj_iter_cp = obj_next_cp;\n    }\n  }\n  while (marked_anything_during_current_iteration);\n\n  black_end_p->gc_next_cp = JMEM_CP_NULL;\n  JERRY_CONTEXT (ecma_gc_objects_cp) = black_list_head.gc_next_cp;\n\n  /* Sweep objects that are currently unmarked. */\n  obj_iter_cp = white_gray_list_head.gc_next_cp;\n\n  while (obj_iter_cp != JMEM_CP_NULL)\n  {\n    obj_iter_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_object_t, obj_iter_cp);\n    const jmem_cpointer_t obj_next_cp = obj_iter_p->gc_next_cp;\n\n    JERRY_ASSERT (!ecma_gc_is_object_visited (obj_iter_p));\n\n    ecma_gc_free_object (obj_iter_p);\n    obj_iter_cp = obj_next_cp;\n  }\n\n#if ENABLED (JERRY_BUILTIN_REGEXP)\n  /* Free RegExp bytecodes stored in cache */\n  re_cache_gc ();\n#endif /* ENABLED (JERRY_BUILTIN_REGEXP) */\n}",
        "begin_line": 1342,
        "end_line": 1472,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_gc_set_object_visited#82",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_gc_set_object_visited (ecma_object_t *object_p) /**< object */",
        "snippet": "static void\necma_gc_set_object_visited (ecma_object_t *object_p) /**< object */\n{\n  if (object_p->type_flags_refs >= ECMA_OBJECT_NON_VISITED)\n  {\n#if (JERRY_GC_MARK_LIMIT != 0)\n    if (JERRY_CONTEXT (ecma_gc_mark_recursion_limit) != 0)\n    {\n      JERRY_CONTEXT (ecma_gc_mark_recursion_limit)--;\n      /* Set the reference count of gray object to 0 */\n      object_p->type_flags_refs = (uint16_t) (object_p->type_flags_refs & (ECMA_OBJECT_REF_ONE - 1));\n      ecma_gc_mark (object_p);\n      JERRY_CONTEXT (ecma_gc_mark_recursion_limit)++;\n    }\n    else\n    {\n      /* Set the reference count of the non-marked gray object to 1 */\n      object_p->type_flags_refs = (uint16_t) (object_p->type_flags_refs & ((ECMA_OBJECT_REF_ONE << 1) - 1));\n      JERRY_ASSERT (object_p->type_flags_refs >= ECMA_OBJECT_REF_ONE);\n    }\n#else /* (JERRY_GC_MARK_LIMIT == 0) */\n    /* Set the reference count of gray object to 0 */\n    object_p->type_flags_refs = (uint16_t) (object_p->type_flags_refs & (ECMA_OBJECT_REF_ONE - 1));\n#endif /* (JERRY_GC_MARK_LIMIT != 0) */\n  }\n}",
        "begin_line": 82,
        "end_line": 107,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_init_gc_info#112",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_init_gc_info (ecma_object_t *object_p) /**< object */",
        "snippet": "inline void\necma_init_gc_info (ecma_object_t *object_p) /**< object */\n{\n  JERRY_CONTEXT (ecma_gc_objects_number)++;\n  JERRY_CONTEXT (ecma_gc_new_objects)++;\n\n  JERRY_ASSERT (JERRY_CONTEXT (ecma_gc_new_objects) <= JERRY_CONTEXT (ecma_gc_objects_number));\n\n  JERRY_ASSERT (object_p->type_flags_refs < ECMA_OBJECT_REF_ONE);\n  object_p->type_flags_refs = (uint16_t) (object_p->type_flags_refs | ECMA_OBJECT_REF_ONE);\n\n  object_p->gc_next_cp = JERRY_CONTEXT (ecma_gc_objects_cp);\n  ECMA_SET_NON_NULL_POINTER (JERRY_CONTEXT (ecma_gc_objects_cp), object_p);\n}",
        "begin_line": 112,
        "end_line": 125,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_ref_object#130",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_ref_object (ecma_object_t *object_p) /**< object */",
        "snippet": "void\necma_ref_object (ecma_object_t *object_p) /**< object */\n{\n  if (JERRY_LIKELY (object_p->type_flags_refs < ECMA_OBJECT_MAX_REF))\n  {\n    object_p->type_flags_refs = (uint16_t) (object_p->type_flags_refs + ECMA_OBJECT_REF_ONE);\n  }\n  else\n  {\n    jerry_fatal (ERR_REF_COUNT_LIMIT);\n  }\n}",
        "begin_line": 130,
        "end_line": 141,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-collection.ecma_collection_destroy#51",
        "src_path": "jerry-core/ecma/base/ecma-helpers-collection.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-collection",
        "signature": "jerry-core.ecma.base.ecma-helpers-collection.ecma_collection_destroy (ecma_collection_t *collection_p) /**< value collection */",
        "snippet": "inline void JERRY_ATTR_ALWAYS_INLINE\necma_collection_destroy (ecma_collection_t *collection_p) /**< value collection */\n{\n  JERRY_ASSERT (collection_p != NULL);\n\n  jmem_heap_free_block (collection_p->buffer_p, ECMA_COLLECTION_ALLOCATED_SIZE (collection_p->capacity));\n  jmem_heap_free_block (collection_p, sizeof (ecma_collection_t));\n}",
        "begin_line": 51,
        "end_line": 58,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-collection.ecma_new_collection#34",
        "src_path": "jerry-core/ecma/base/ecma-helpers-collection.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-collection",
        "signature": "jerry-core.ecma.base.ecma-helpers-collection.ecma_new_collection (void)",
        "snippet": "ecma_collection_t *\necma_new_collection (void)\n{\n  ecma_collection_t *collection_p;\n  collection_p = (ecma_collection_t *) jmem_heap_alloc_block (sizeof (ecma_collection_t));\n\n  collection_p->item_count = 0;\n  collection_p->capacity = ECMA_COLLECTION_INITIAL_CAPACITY;\n  const uint32_t size = ECMA_COLLECTION_ALLOCATED_SIZE (ECMA_COLLECTION_INITIAL_CAPACITY);\n  collection_p->buffer_p = (ecma_value_t *) jmem_heap_alloc_block (size);\n\n  return collection_p;\n}",
        "begin_line": 34,
        "end_line": 46,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-conversion.ecma_number_to_uint32#759",
        "src_path": "jerry-core/ecma/base/ecma-helpers-conversion.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-conversion",
        "signature": "jerry-core.ecma.base.ecma-helpers-conversion.ecma_number_to_uint32 (ecma_number_t num) /**< ecma-number */",
        "snippet": "uint32_t\necma_number_to_uint32 (ecma_number_t num) /**< ecma-number */\n{\n  if (JERRY_UNLIKELY (ecma_number_is_zero (num) || !ecma_number_is_finite (num)))\n  {\n    return 0;\n  }\n\n  const bool sign = ecma_number_is_negative (num);\n  const ecma_number_t abs_num = sign ? -num : num;\n\n  /* 2 ^ 32 */\n  const uint64_t uint64_2_pow_32 = (1ull << 32);\n\n  const ecma_number_t num_2_pow_32 = (float) uint64_2_pow_32;\n\n  ecma_number_t num_in_uint32_range;\n\n  if (abs_num >= num_2_pow_32)\n  {\n    num_in_uint32_range = ecma_number_calc_remainder (abs_num,\n                                                      num_2_pow_32);\n  }\n  else\n  {\n    num_in_uint32_range = abs_num;\n  }\n\n  /* Check that the floating point value can be represented with uint32_t. */\n  JERRY_ASSERT (num_in_uint32_range < uint64_2_pow_32);\n  uint32_t uint32_num = (uint32_t) num_in_uint32_range;\n\n  const uint32_t ret = sign ? -uint32_num : uint32_num;\n\n#ifndef JERRY_NDEBUG\n  if (sign\n      && uint32_num != 0)\n  {\n    JERRY_ASSERT (ret == uint64_2_pow_32 - uint32_num);\n  }\n  else\n  {\n    JERRY_ASSERT (ret == uint32_num);\n  }\n#endif /* !JERRY_NDEBUG */\n\n  return ret;\n}",
        "begin_line": 759,
        "end_line": 806,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-conversion.ecma_round_high_to_uint64#52",
        "src_path": "jerry-core/ecma/base/ecma-helpers-conversion.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-conversion",
        "signature": "jerry-core.ecma.base.ecma-helpers-conversion.ecma_round_high_to_uint64 (ecma_uint128_t *num_p)",
        "snippet": "static uint64_t\necma_round_high_to_uint64 (ecma_uint128_t *num_p)\n{\n  uint64_t masked_lo = num_p->lo & ~(1ULL << 63u);\n  uint64_t masked_hi = num_p->hi & 0x1;\n\n  if ((num_p->lo >> 63u != 0)\n      && (masked_lo > 0 || masked_hi != 0))\n  {\n    return (num_p->hi + 1);\n  }\n  return num_p->hi;\n}",
        "begin_line": 52,
        "end_line": 64,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-conversion.ecma_uint32_to_utf8_string#722",
        "src_path": "jerry-core/ecma/base/ecma-helpers-conversion.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-conversion",
        "signature": "jerry-core.ecma.base.ecma-helpers-conversion.ecma_uint32_to_utf8_string (uint32_t value, /**< value to convert */                             lit_utf8_byte_t *out_buffer_p, /**< buffer for string */                             lit_utf8_size_t buffer_size) /**< size of buffer */",
        "snippet": "lit_utf8_size_t\necma_uint32_to_utf8_string (uint32_t value, /**< value to convert */\n                            lit_utf8_byte_t *out_buffer_p, /**< buffer for string */\n                            lit_utf8_size_t buffer_size) /**< size of buffer */\n{\n  lit_utf8_byte_t *buf_p = out_buffer_p + buffer_size;\n\n  do\n  {\n    JERRY_ASSERT (buf_p >= out_buffer_p);\n\n    buf_p--;\n    *buf_p = (lit_utf8_byte_t) ((value % 10) + LIT_CHAR_0);\n    value /= 10;\n  }\n  while (value != 0);\n\n  JERRY_ASSERT (buf_p >= out_buffer_p);\n\n  lit_utf8_size_t bytes_copied = (lit_utf8_size_t) (out_buffer_p + buffer_size - buf_p);\n\n  if (JERRY_LIKELY (buf_p != out_buffer_p))\n  {\n    memmove (out_buffer_p, buf_p, bytes_copied);\n  }\n\n  return bytes_copied;\n}",
        "begin_line": 722,
        "end_line": 749,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-conversion.ecma_utf8_string_to_number#365",
        "src_path": "jerry-core/ecma/base/ecma-helpers-conversion.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-conversion",
        "signature": "jerry-core.ecma.base.ecma-helpers-conversion.ecma_utf8_string_to_number (const lit_utf8_byte_t *str_p, /**< utf-8 string */                             lit_utf8_size_t str_size) /**< string size */",
        "snippet": "ecma_number_t\necma_utf8_string_to_number (const lit_utf8_byte_t *str_p, /**< utf-8 string */\n                            lit_utf8_size_t str_size) /**< string size */\n{\n  /* TODO: Check license issues */\n\n  if (str_size == 0)\n  {\n    return ECMA_NUMBER_ZERO;\n  }\n\n  ecma_string_trim_helper (&str_p, &str_size);\n  const lit_utf8_byte_t *end_p = str_p + (str_size - 1);\n\n  if (str_size < 1)\n  {\n    return ECMA_NUMBER_ZERO;\n  }\n\n  if (end_p >= str_p + 2\n      && str_p[0] == LIT_CHAR_0)\n  {\n    switch (LEXER_TO_ASCII_LOWERCASE (str_p[1]))\n    {\n      case LIT_CHAR_LOWERCASE_X :\n      {\n        return ecma_utf8_string_to_number_by_radix (str_p + 2, end_p, 16);\n      }\n      case LIT_CHAR_LOWERCASE_O :\n      {\n        return ecma_utf8_string_to_number_by_radix (str_p + 2, end_p, 8);\n      }\n      case LIT_CHAR_LOWERCASE_B :\n      {\n        return ecma_utf8_string_to_number_by_radix (str_p + 2, end_p, 2);\n      }\n      default:\n      {\n        break;\n      }\n    }\n  }\n\n  bool sign = false; /* positive */\n\n  if (*str_p == LIT_CHAR_PLUS)\n  {\n    str_p++;\n  }\n  else if (*str_p == LIT_CHAR_MINUS)\n  {\n    sign = true; /* negative */\n\n    str_p++;\n  }\n\n  if (str_p > end_p)\n  {\n    return ecma_number_make_nan ();\n  }\n\n  /* Checking if significant part of parse string is equal to \"Infinity\" */\n  const lit_utf8_byte_t *infinity_zt_str_p = lit_get_magic_string_utf8 (LIT_MAGIC_STRING_INFINITY_UL);\n\n  JERRY_ASSERT (strlen ((const char *) infinity_zt_str_p) == 8);\n\n  if ((end_p - str_p) == (8 - 1) && memcmp (infinity_zt_str_p, str_p, 8) == 0)\n  {\n    return ecma_number_make_infinity (sign);\n  }\n\n  uint64_t fraction_uint64 = 0;\n  uint32_t digits = 0;\n  int32_t e = 0;\n  bool digit_seen = false;\n\n  /* Parsing digits before dot (or before end of digits part if there is no dot in number) */\n  while (str_p <= end_p)\n  {\n    int32_t digit_value;\n\n    if (*str_p >= LIT_CHAR_0\n        && *str_p <= LIT_CHAR_9)\n    {\n      digit_seen = true;\n      digit_value = (*str_p - LIT_CHAR_0);\n    }\n    else\n    {\n      break;\n    }\n\n    if (digits != 0 || digit_value != 0)\n    {\n      if (digits < ECMA_NUMBER_MAX_DIGITS)\n      {\n        fraction_uint64 = fraction_uint64 * 10 + (uint32_t) digit_value;\n        digits++;\n      }\n      else\n      {\n        e++;\n      }\n    }\n\n    str_p++;\n  }\n\n  if (str_p <= end_p\n      && *str_p == LIT_CHAR_DOT)\n  {\n    str_p++;\n\n    if (!digit_seen && str_p > end_p)\n    {\n      return ecma_number_make_nan ();\n    }\n\n    /* Parsing number's part that is placed after dot */\n    while (str_p <= end_p)\n    {\n      int32_t digit_value;\n\n      if (*str_p >= LIT_CHAR_0\n          && *str_p <= LIT_CHAR_9)\n      {\n        digit_seen = true;\n        digit_value = (*str_p - LIT_CHAR_0);\n      }\n      else\n      {\n        break;\n      }\n\n      if (digits < ECMA_NUMBER_MAX_DIGITS)\n      {\n        if (digits != 0 || digit_value != 0)\n        {\n          fraction_uint64 = fraction_uint64 * 10 + (uint32_t) digit_value;\n          digits++;\n        }\n\n        e--;\n      }\n\n      str_p++;\n    }\n  }\n\n  /* Parsing exponent literal */\n  int32_t e_in_lit = 0;\n  bool e_in_lit_sign = false;\n\n  if (str_p <= end_p\n      && (*str_p == LIT_CHAR_LOWERCASE_E\n          || *str_p == LIT_CHAR_UPPERCASE_E))\n  {\n    str_p++;\n\n    if (!digit_seen || str_p > end_p)\n    {\n      return ecma_number_make_nan ();\n    }\n\n    if (*str_p == LIT_CHAR_PLUS)\n    {\n      str_p++;\n    }\n    else if (*str_p == LIT_CHAR_MINUS)\n    {\n      e_in_lit_sign = true;\n      str_p++;\n    }\n\n    if (str_p > end_p)\n    {\n      return ecma_number_make_nan ();\n    }\n\n    while (str_p <= end_p)\n    {\n      int32_t digit_value;\n\n      if (*str_p >= LIT_CHAR_0\n          && *str_p <= LIT_CHAR_9)\n      {\n        digit_value = (*str_p - LIT_CHAR_0);\n      }\n      else\n      {\n        return ecma_number_make_nan ();\n      }\n\n      e_in_lit = e_in_lit * 10 + digit_value;\n      int32_t e_check = e + (int32_t) digits - 1  + (e_in_lit_sign ? -e_in_lit : e_in_lit);\n\n      if (e_check > NUMBER_MAX_DECIMAL_EXPONENT)\n      {\n        return ecma_number_make_infinity (sign);\n      }\n      else if (e_check < NUMBER_MIN_DECIMAL_EXPONENT)\n      {\n        return sign ? -ECMA_NUMBER_ZERO : ECMA_NUMBER_ZERO;\n      }\n\n      str_p++;\n    }\n  }\n\n  /* Adding value of exponent literal to exponent value */\n  if (e_in_lit_sign)\n  {\n    e -= e_in_lit;\n  }\n  else\n  {\n    e += e_in_lit;\n  }\n\n  bool e_sign;\n\n  if (e < 0)\n  {\n    e_sign = true;\n    e = -e;\n  }\n  else\n  {\n    e_sign = false;\n  }\n\n  if (str_p <= end_p)\n  {\n    return ecma_number_make_nan ();\n  }\n\n  JERRY_ASSERT (str_p == end_p + 1);\n\n  if (fraction_uint64 == 0)\n  {\n    return sign ? -ECMA_NUMBER_ZERO : ECMA_NUMBER_ZERO;\n  }\n\n#if ENABLED (JERRY_NUMBER_TYPE_FLOAT64)\n  /*\n   * 128-bit mantissa storage\n   *\n   * Normalized: |4 bits zero|124-bit mantissa with highest bit set to 1|\n   */\n  ecma_uint128_t fraction_uint128 = { 0, fraction_uint64 };\n\n  /* Normalizing mantissa */\n  int shift = 4 - ECMA_UINT128_CLZ_MAX63 (fraction_uint128);\n  if (shift < 0)\n  {\n    ECMA_UINT128_LEFT_SHIFT_MAX63 (fraction_uint128, -shift);\n  }\n  else\n  {\n    ECMA_UINT128_RIGHT_SHIFT_MAX63 (fraction_uint128, shift);\n  }\n  int32_t binary_exponent = 1 + shift;\n\n  if (!e_sign)\n  {\n    /* positive or zero decimal exponent */\n    JERRY_ASSERT (e >= 0);\n\n    while (e > 0)\n    {\n      JERRY_ASSERT (ECMA_UINT128_CLZ_MAX63 (fraction_uint128) == 4);\n\n      ECMA_UINT128_MUL10 (fraction_uint128);\n\n      e--;\n\n      /* Normalizing mantissa */\n      shift = 4 - ECMA_UINT128_CLZ_MAX4 (fraction_uint128);\n      JERRY_ASSERT (shift >= 0);\n      ECMA_UINT128_RIGHT_SHIFT_MAX63 (fraction_uint128, shift);\n      binary_exponent += shift;\n    }\n  }\n  else\n  {\n    /* negative decimal exponent */\n    JERRY_ASSERT (e != 0);\n\n    while (e > 0)\n    {\n      /* Denormalizing mantissa, moving highest 1 to bit 127 */\n      shift = ECMA_UINT128_CLZ_MAX4 (fraction_uint128);\n      JERRY_ASSERT (shift <= 4);\n      ECMA_UINT128_LEFT_SHIFT_MAX63 (fraction_uint128, shift);\n      binary_exponent -= shift;\n\n      JERRY_ASSERT (!ECMA_UINT128_IS_ZERO (fraction_uint128));\n\n      ECMA_UINT128_DIV10 (fraction_uint128);\n\n      e--;\n    }\n\n    /* Normalizing mantissa */\n    shift = 4 - ECMA_UINT128_CLZ_MAX4 (fraction_uint128);\n    JERRY_ASSERT (shift >= 0);\n    ECMA_UINT128_RIGHT_SHIFT_MAX63 (fraction_uint128, shift);\n    binary_exponent += shift;\n\n    JERRY_ASSERT (ECMA_UINT128_CLZ_MAX63 (fraction_uint128) == 4);\n  }\n\n  JERRY_ASSERT (!ECMA_UINT128_IS_ZERO (fraction_uint128));\n  JERRY_ASSERT (ECMA_UINT128_CLZ_MAX63 (fraction_uint128) == 4);\n\n  /*\n   * Preparing mantissa for conversion to 52-bit representation, converting it to:\n   *\n   * |11 zero bits|1|116 mantissa bits|\n   */\n  ECMA_UINT128_RIGHT_SHIFT_MAX63 (fraction_uint128, 7u);\n  binary_exponent += 7;\n\n  JERRY_ASSERT (ECMA_UINT128_CLZ_MAX63 (fraction_uint128) == 11);\n\n  fraction_uint64 = ecma_round_high_to_uint64 (&fraction_uint128);\n\n  return ecma_number_make_from_sign_mantissa_and_exponent (sign, fraction_uint64, binary_exponent);\n#elif !ENABLED (JERRY_NUMBER_TYPE_FLOAT64)\n  /* Less precise conversion */\n  ecma_number_t num = (ecma_number_t) (uint32_t) fraction_uint64;\n\n  ecma_number_t m = e_sign ? (ecma_number_t) 0.1 : (ecma_number_t) 10.0;\n\n  while (e)\n  {\n    if (e % 2)\n    {\n      num *= m;\n    }\n\n    m *= m;\n    e /= 2;\n  }\n\n  return num;\n#endif /* ENABLED (JERRY_NUMBER_TYPE_FLOAT64) */\n}",
        "begin_line": 365,
        "end_line": 712,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_get_biased_exponent_field#190",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_get_biased_exponent_field (ecma_number_t num) /**< ecma-number */",
        "snippet": "static uint32_t\necma_number_get_biased_exponent_field (ecma_number_t num) /**< ecma-number */\n{\n  uint32_t biased_exp;\n\n  ecma_number_unpack (num, NULL, &biased_exp, NULL);\n\n  return biased_exp;\n}",
        "begin_line": 190,
        "end_line": 198,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_get_fraction_field#175",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_get_fraction_field (ecma_number_t num) /**< ecma-number */",
        "snippet": "static uint64_t\necma_number_get_fraction_field (ecma_number_t num) /**< ecma-number */\n{\n  uint64_t fraction;\n\n  ecma_number_unpack (num, NULL, NULL, &fraction);\n\n  return fraction;\n}",
        "begin_line": 175,
        "end_line": 183,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_get_sign_field#205",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_get_sign_field (ecma_number_t num) /**< ecma-number */",
        "snippet": "static uint32_t\necma_number_get_sign_field (ecma_number_t num) /**< ecma-number */\n{\n  bool sign;\n\n  ecma_number_unpack (num, &sign, NULL, NULL);\n\n  return sign;\n}",
        "begin_line": 205,
        "end_line": 213,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_is_finite#340",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_is_finite (ecma_number_t num) /**< ecma-number */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\necma_number_is_finite (ecma_number_t num) /**< ecma-number */\n{\n#if defined (__GNUC__) || defined (__clang__)\n  return __builtin_isfinite (num);\n#elif defined (WIN32)\n  return isfinite (num);\n#else\n  return !ecma_number_is_nan (num) && !ecma_number_is_infinity (num);\n#endif /* defined (__GNUC__) || defined (__clang__) */\n}",
        "begin_line": 340,
        "end_line": 350,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_is_nan#222",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_is_nan (ecma_number_t num) /**< ecma-number */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\necma_number_is_nan (ecma_number_t num) /**< ecma-number */\n{\n  bool is_nan = (num != num);\n\n#ifndef JERRY_NDEBUG\n  uint32_t biased_exp = ecma_number_get_biased_exponent_field (num);\n  uint64_t fraction = ecma_number_get_fraction_field (num);\n\n   /* IEEE-754 2008, 3.4, a */\n  bool is_nan_ieee754 = ((biased_exp == (1u << ECMA_NUMBER_BIASED_EXP_WIDTH) - 1)\n                         && (fraction != 0));\n\n  JERRY_ASSERT (is_nan == is_nan_ieee754);\n#endif /* !JERRY_NDEBUG */\n\n  return is_nan;\n}",
        "begin_line": 222,
        "end_line": 239,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_is_negative#285",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_is_negative (ecma_number_t num) /**< ecma-number */",
        "snippet": "inline bool JERRY_ATTR_ALWAYS_INLINE\necma_number_is_negative (ecma_number_t num) /**< ecma-number */\n{\n  JERRY_ASSERT (!ecma_number_is_nan (num));\n\n  /* IEEE-754 2008, 3.4 */\n  return (ecma_number_get_sign_field (num) != 0);\n}",
        "begin_line": 285,
        "end_line": 292,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_is_zero#300",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_is_zero (ecma_number_t num) /**< ecma-number */",
        "snippet": "bool\necma_number_is_zero (ecma_number_t num) /**< ecma-number */\n{\n  bool is_zero = (num == ECMA_NUMBER_ZERO);\n\n#ifndef JERRY_NDEBUG\n  /* IEEE-754 2008, 3.4, e */\n  bool is_zero_ieee754 = (ecma_number_get_fraction_field (num) == 0\n                          && ecma_number_get_biased_exponent_field (num) == 0);\n\n  JERRY_ASSERT (is_zero == is_zero_ieee754);\n#endif /* !JERRY_NDEBUG */\n\n  return is_zero;\n}",
        "begin_line": 300,
        "end_line": 314,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_make_from_sign_mantissa_and_exponent#435",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_make_from_sign_mantissa_and_exponent (bool sign, /**< true - for negative sign, false - for positive sign */                                                   uint64_t mantissa, /**< mantissa */                                                   int32_t exponent) /**< binary exponent */",
        "snippet": "ecma_number_t\necma_number_make_from_sign_mantissa_and_exponent (bool sign, /**< true - for negative sign,\n                                                                  false - for positive sign */\n                                                  uint64_t mantissa, /**< mantissa */\n                                                  int32_t exponent) /**< binary exponent */\n{\n  /* Rounding mantissa to fit into fraction field width */\n  if (mantissa & ~((1ull << (ECMA_NUMBER_FRACTION_WIDTH + 1)) - 1))\n  {\n    /* Rounded mantissa looks like the following: |00...0|1|fraction_width mantissa bits| */\n    while ((mantissa & ~((1ull << (ECMA_NUMBER_FRACTION_WIDTH + 1)) - 1)) != 0)\n    {\n      uint64_t rightmost_bit = (mantissa & 1);\n\n      exponent++;\n      mantissa >>= 1;\n\n      if ((mantissa & ~((1ull << (ECMA_NUMBER_FRACTION_WIDTH + 1)) - 1)) == 0)\n      {\n        /* Rounding to nearest value */\n        mantissa += rightmost_bit;\n\n        /* In the first case loop is finished,\n           and in the second - just one shift follows and then loop finishes */\n        JERRY_ASSERT (((mantissa & ~((1ull << (ECMA_NUMBER_FRACTION_WIDTH + 1)) - 1)) == 0)\n                      || (mantissa == (1ull << (ECMA_NUMBER_FRACTION_WIDTH + 1))));\n      }\n    }\n  }\n\n  /* Normalizing mantissa */\n  while (mantissa != 0\n         && ((mantissa & (1ull << ECMA_NUMBER_FRACTION_WIDTH)) == 0))\n  {\n    exponent--;\n    mantissa <<= 1;\n  }\n\n  /* Moving floating point */\n  exponent += ECMA_NUMBER_FRACTION_WIDTH - 1;\n\n  int32_t biased_exp_signed = exponent + ecma_number_exponent_bias;\n\n  if (biased_exp_signed < 1)\n  {\n    /* Denormalizing mantissa if biased_exponent is less than zero */\n    while (biased_exp_signed < 0)\n    {\n      biased_exp_signed++;\n      mantissa >>= 1;\n    }\n\n    /* Rounding to nearest value */\n    mantissa += 1;\n    mantissa >>= 1;\n\n    /* Encoding denormalized exponent */\n    biased_exp_signed = 0;\n  }\n  else\n  {\n    /* Clearing highest mantissa bit that should have been non-zero if mantissa is non-zero */\n    mantissa &= ~(1ull << ECMA_NUMBER_FRACTION_WIDTH);\n  }\n\n  uint32_t biased_exp = (uint32_t) biased_exp_signed;\n\n  if (biased_exp >= ((1u << ECMA_NUMBER_BIASED_EXP_WIDTH) - 1))\n  {\n    return ecma_number_make_infinity (sign);\n  }\n\n  JERRY_ASSERT (biased_exp < (1u << ECMA_NUMBER_BIASED_EXP_WIDTH) - 1);\n  JERRY_ASSERT ((mantissa & ~((1ull << ECMA_NUMBER_FRACTION_WIDTH) - 1)) == 0);\n\n  return ecma_number_pack (sign,\n                           biased_exp,\n                           mantissa);\n}",
        "begin_line": 435,
        "end_line": 513,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_pack#114",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_pack (bool sign, /**< sign */                   uint32_t biased_exp, /**< biased exponent */                   uint64_t fraction) /**< fraction */",
        "snippet": "static ecma_number_t\necma_number_pack (bool sign, /**< sign */\n                  uint32_t biased_exp, /**< biased exponent */\n                  uint64_t fraction) /**< fraction */\n{\n  uint64_t packed_value = (((sign ? 1ull : 0ull) << ECMA_NUMBER_SIGN_POS) |\n                           (((uint64_t) biased_exp) << ECMA_NUMBER_FRACTION_WIDTH) |\n                           fraction);\n\n  JERRY_ASSERT ((biased_exp & ~((1u << ECMA_NUMBER_BIASED_EXP_WIDTH) - 1)) == 0);\n  JERRY_ASSERT ((fraction & ~((1ull << ECMA_NUMBER_FRACTION_WIDTH) - 1)) == 0);\n\n  ecma_number_accessor_t u;\n  u.as_uint64_t = packed_value;\n  return u.as_ecma_number_t;\n}",
        "begin_line": 114,
        "end_line": 129,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_unpack#134",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_unpack (ecma_number_t num, /**< ecma-number */                     bool *sign_p, /**< [out] sign (optional) */                     uint32_t *biased_exp_p, /**< [out] biased exponent (optional) */                     uint64_t *fraction_p) /**< [out] fraction (optional) */",
        "snippet": "static void\necma_number_unpack (ecma_number_t num, /**< ecma-number */\n                    bool *sign_p, /**< [out] sign (optional) */\n                    uint32_t *biased_exp_p, /**< [out] biased exponent (optional) */\n                    uint64_t *fraction_p) /**< [out] fraction (optional) */\n{\n  ecma_number_accessor_t u;\n  u.as_ecma_number_t = num;\n  uint64_t packed_value = u.as_uint64_t;\n\n  if (sign_p != NULL)\n  {\n    *sign_p = ((packed_value >> ECMA_NUMBER_SIGN_POS) != 0);\n  }\n\n  if (biased_exp_p != NULL)\n  {\n    *biased_exp_p = (uint32_t) (((packed_value) & ~(1ull << ECMA_NUMBER_SIGN_POS)) >> ECMA_NUMBER_FRACTION_WIDTH);\n  }\n\n  if (fraction_p != NULL)\n  {\n    *fraction_p = (packed_value & ((1ull << ECMA_NUMBER_FRACTION_WIDTH) - 1));\n  }\n}",
        "begin_line": 134,
        "end_line": 158,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_compare_ecma_non_direct_strings#1754",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_compare_ecma_non_direct_strings (const ecma_string_t *string1_p, /**< ecma-string */                                       const ecma_string_t *string2_p) /**< ecma-string */",
        "snippet": "inline bool JERRY_ATTR_ALWAYS_INLINE\necma_compare_ecma_non_direct_strings (const ecma_string_t *string1_p, /**< ecma-string */\n                                      const ecma_string_t *string2_p) /**< ecma-string */\n{\n  JERRY_ASSERT (string1_p != NULL && string2_p != NULL);\n  JERRY_ASSERT (!ECMA_IS_DIRECT_STRING (string1_p) && !ECMA_IS_DIRECT_STRING (string2_p));\n\n  /* Fast paths first. */\n  if (string1_p == string2_p)\n  {\n    return true;\n  }\n\n  if (string1_p->u.hash != string2_p->u.hash)\n  {\n    return false;\n  }\n\n  ecma_string_container_t string1_container = ECMA_STRING_GET_CONTAINER (string1_p);\n\n  if (string1_container != ECMA_STRING_GET_CONTAINER (string2_p))\n  {\n    return false;\n  }\n\n  if (string1_container == ECMA_STRING_CONTAINER_UINT32_IN_DESC)\n  {\n    return true;\n  }\n\n#if ENABLED (JERRY_ES2015)\n  if (string1_container == ECMA_STRING_CONTAINER_SYMBOL)\n  {\n    return false;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  return ecma_compare_ecma_strings_longpath (string1_p, string2_p);\n}",
        "begin_line": 1754,
        "end_line": 1792,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_compare_ecma_string_to_magic_id#1487",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_compare_ecma_string_to_magic_id (const ecma_string_t *string_p, /**< property name */                                       lit_magic_string_id_t id) /**< magic string id */",
        "snippet": "inline bool JERRY_ATTR_ALWAYS_INLINE\necma_compare_ecma_string_to_magic_id (const ecma_string_t *string_p, /**< property name */\n                                      lit_magic_string_id_t id) /**< magic string id */\n{\n  return (string_p == ecma_get_magic_string (id));\n}",
        "begin_line": 1487,
        "end_line": 1492,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_compare_ecma_strings#1703",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_compare_ecma_strings (const ecma_string_t *string1_p, /**< ecma-string */                            const ecma_string_t *string2_p) /**< ecma-string */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\necma_compare_ecma_strings (const ecma_string_t *string1_p, /**< ecma-string */\n                           const ecma_string_t *string2_p) /**< ecma-string */\n{\n  JERRY_ASSERT (string1_p != NULL && string2_p != NULL);\n\n  /* Fast paths first. */\n  if (string1_p == string2_p)\n  {\n    return true;\n  }\n\n  /* Either string is direct, return with false. */\n  if (ECMA_IS_DIRECT_STRING (((uintptr_t) string1_p) | ((uintptr_t) string2_p)))\n  {\n    return false;\n  }\n\n  if (string1_p->u.hash != string2_p->u.hash)\n  {\n    return false;\n  }\n\n  ecma_string_container_t string1_container = ECMA_STRING_GET_CONTAINER (string1_p);\n\n  if (string1_container != ECMA_STRING_GET_CONTAINER (string2_p))\n  {\n    return false;\n  }\n\n  if (string1_container == ECMA_STRING_CONTAINER_UINT32_IN_DESC)\n  {\n    return true;\n  }\n\n#if ENABLED (JERRY_ES2015)\n  if (string1_container == ECMA_STRING_CONTAINER_SYMBOL)\n  {\n    return false;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  return ecma_compare_ecma_strings_longpath (string1_p, string2_p);\n}",
        "begin_line": 1703,
        "end_line": 1746,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_deref_ecma_string#789",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_deref_ecma_string (ecma_string_t *string_p) /**< ecma-string */",
        "snippet": "void\necma_deref_ecma_string (ecma_string_t *string_p) /**< ecma-string */\n{\n  JERRY_ASSERT (string_p != NULL);\n\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    return;\n  }\n\n#ifdef JERRY_NDEBUG\n  if (ECMA_STRING_IS_STATIC (string_p))\n  {\n    return;\n  }\n#endif /* JERRY_NDEBUG */\n\n  JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);\n\n  /* Decrease reference counter. */\n  string_p->refs_and_container -= ECMA_STRING_REF_ONE;\n\n  if (string_p->refs_and_container >= ECMA_STRING_REF_ONE)\n  {\n    return;\n  }\n\n  ecma_destroy_ecma_string (string_p);\n}",
        "begin_line": 789,
        "end_line": 817,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_destroy_ecma_string#822",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_destroy_ecma_string (ecma_string_t *string_p) /**< ecma-string */",
        "snippet": "void\necma_destroy_ecma_string (ecma_string_t *string_p) /**< ecma-string */\n{\n  JERRY_ASSERT (string_p != NULL);\n  JERRY_ASSERT (!ECMA_IS_DIRECT_STRING (string_p));\n  JERRY_ASSERT ((string_p->refs_and_container < ECMA_STRING_REF_ONE) || ECMA_STRING_IS_STATIC (string_p));\n\n  switch (ECMA_STRING_GET_CONTAINER (string_p))\n  {\n    case ECMA_STRING_CONTAINER_HEAP_UTF8_STRING:\n    {\n      ecma_dealloc_string_buffer (string_p, ((ecma_utf8_string_t *) string_p)->size + sizeof (ecma_utf8_string_t));\n      return;\n    }\n    case ECMA_STRING_CONTAINER_HEAP_LONG_UTF8_STRING:\n    {\n      ecma_dealloc_string_buffer (string_p,\n                                  ((ecma_long_utf8_string_t *) string_p)->size + sizeof (ecma_long_utf8_string_t));\n      return;\n    }\n    case ECMA_STRING_CONTAINER_HEAP_ASCII_STRING:\n    {\n      ecma_dealloc_string_buffer (string_p,\n                                  ((ecma_ascii_string_t *) string_p)->size + sizeof (ecma_ascii_string_t));\n      return;\n    }\n#if ENABLED (JERRY_ES2015)\n    case ECMA_STRING_CONTAINER_SYMBOL:\n    {\n      ecma_extended_string_t * symbol_p = (ecma_extended_string_t *) string_p;\n      ecma_free_value (symbol_p->u.symbol_descriptor);\n      ecma_dealloc_extended_string (symbol_p);\n      return;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    default:\n    {\n      JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC\n                    || ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);\n\n      /* only the string descriptor itself should be freed */\n      ecma_dealloc_string (string_p);\n    }\n  }\n}",
        "begin_line": 822,
        "end_line": 866,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_find_special_string#296",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_find_special_string (const lit_utf8_byte_t *string_p, /**< utf8 string */                           lit_utf8_size_t string_size) /**< string size */",
        "snippet": "static ecma_string_t *\necma_find_special_string (const lit_utf8_byte_t *string_p, /**< utf8 string */\n                          lit_utf8_size_t string_size) /**< string size */\n{\n  JERRY_ASSERT (string_p != NULL || string_size == 0);\n  lit_magic_string_id_t magic_string_id = lit_is_utf8_string_magic (string_p, string_size);\n\n  if (magic_string_id != LIT_MAGIC_STRING__COUNT)\n  {\n    return ecma_get_magic_string (magic_string_id);\n  }\n\n  JERRY_ASSERT (string_size > 0);\n\n  if (*string_p >= LIT_CHAR_0 && *string_p <= LIT_CHAR_9)\n  {\n    uint32_t array_index;\n\n    if (ecma_string_to_array_index (string_p, string_size, &array_index))\n    {\n      return ecma_new_ecma_string_from_uint32 (array_index);\n    }\n  }\n\n  if (lit_get_magic_string_ex_count () > 0)\n  {\n    lit_magic_string_ex_id_t magic_string_ex_id = lit_is_ex_utf8_string_magic (string_p, string_size);\n\n    if (magic_string_ex_id < lit_get_magic_string_ex_count ())\n    {\n      return ecma_new_ecma_string_from_magic_string_ex_id (magic_string_ex_id);\n    }\n  }\n\n  return NULL;\n}",
        "begin_line": 296,
        "end_line": 331,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_get_magic_string#586",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_get_magic_string (lit_magic_string_id_t id) /**< identifier of magic string */",
        "snippet": "extern inline ecma_string_t * JERRY_ATTR_ALWAYS_INLINE\necma_get_magic_string (lit_magic_string_id_t id) /**< identifier of magic string */\n{\n  JERRY_ASSERT (id < LIT_MAGIC_STRING__COUNT);\n  return (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_MAGIC, (uintptr_t) id);\n}",
        "begin_line": 586,
        "end_line": 591,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_get_string_magic#2261",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_get_string_magic (const ecma_string_t *string_p) /**< ecma-string */",
        "snippet": "lit_magic_string_id_t\necma_get_string_magic (const ecma_string_t *string_p) /**< ecma-string */\n{\n  if (ECMA_IS_DIRECT_STRING_WITH_TYPE (string_p, ECMA_DIRECT_STRING_MAGIC))\n  {\n    uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);\n\n    if (id < LIT_MAGIC_STRING__COUNT)\n    {\n      return (lit_magic_string_id_t) id;\n    }\n  }\n\n  return LIT_MAGIC_STRING__COUNT;\n}",
        "begin_line": 2261,
        "end_line": 2275,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_new_ecma_string_from_uint32#505",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_new_ecma_string_from_uint32 (uint32_t uint32_number) /**< uint32 value of the string */",
        "snippet": "ecma_string_t *\necma_new_ecma_string_from_uint32 (uint32_t uint32_number) /**< uint32 value of the string */\n{\n  if (JERRY_LIKELY (uint32_number <= ECMA_DIRECT_STRING_MAX_IMM))\n  {\n    return (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_UINT, (uintptr_t) uint32_number);\n  }\n\n  return ecma_new_non_direct_string_from_uint32 (uint32_number);\n}",
        "begin_line": 505,
        "end_line": 514,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_new_ecma_string_from_utf8#338",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_new_ecma_string_from_utf8 (const lit_utf8_byte_t *string_p, /**< utf-8 string */                                 lit_utf8_size_t string_size) /**< string size */",
        "snippet": "ecma_string_t *\necma_new_ecma_string_from_utf8 (const lit_utf8_byte_t *string_p, /**< utf-8 string */\n                                lit_utf8_size_t string_size) /**< string size */\n{\n  JERRY_ASSERT (string_p != NULL || string_size == 0);\n  JERRY_ASSERT (lit_is_valid_cesu8_string (string_p, string_size));\n\n  ecma_string_t *string_desc_p = ecma_find_special_string (string_p, string_size);\n\n  if (string_desc_p != NULL)\n  {\n    return string_desc_p;\n  }\n\n  lit_utf8_byte_t *data_p;\n  string_desc_p = ecma_new_ecma_string_from_utf8_buffer (lit_utf8_string_length (string_p, string_size),\n                                                         string_size,\n                                                         &data_p);\n\n  string_desc_p->u.hash = lit_utf8_string_calc_hash (string_p, string_size);\n  memcpy (data_p, string_p, string_size);\n\n  return string_desc_p;\n}",
        "begin_line": 338,
        "end_line": 361,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_new_ecma_string_from_utf8_buffer#248",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_new_ecma_string_from_utf8_buffer (lit_utf8_size_t length, /**< length of the buffer */                                        lit_utf8_size_t size, /**< size of the buffer */                                        lit_utf8_byte_t **data_p) /**< [out] pointer to the start of the string buffer */",
        "snippet": "static inline ecma_string_t * JERRY_ATTR_ALWAYS_INLINE\necma_new_ecma_string_from_utf8_buffer (lit_utf8_size_t length, /**< length of the buffer */\n                                       lit_utf8_size_t size, /**< size of the buffer */\n                                       lit_utf8_byte_t **data_p) /**< [out] pointer to the start of the string buffer */\n{\n  if (JERRY_LIKELY (size <= UINT16_MAX))\n  {\n    if (JERRY_LIKELY (length == size))\n    {\n      ecma_ascii_string_t *string_desc_p;\n      string_desc_p = (ecma_ascii_string_t *) ecma_alloc_string_buffer (size + sizeof (ecma_ascii_string_t));\n      string_desc_p->header.refs_and_container = ECMA_STRING_CONTAINER_HEAP_ASCII_STRING | ECMA_STRING_REF_ONE;\n      string_desc_p->size = (uint16_t) size;\n\n      *data_p = ECMA_ASCII_STRING_GET_BUFFER (string_desc_p);\n      return (ecma_string_t *) string_desc_p;\n    }\n\n    JERRY_ASSERT (length < size);\n\n    ecma_utf8_string_t *string_desc_p;\n    string_desc_p = (ecma_utf8_string_t *) ecma_alloc_string_buffer (size + sizeof (ecma_utf8_string_t));\n    string_desc_p->header.refs_and_container = ECMA_STRING_CONTAINER_HEAP_UTF8_STRING | ECMA_STRING_REF_ONE;\n    string_desc_p->size = (uint16_t) size;\n    string_desc_p->length = (uint16_t) length;\n\n    *data_p = ECMA_UTF8_STRING_GET_BUFFER (string_desc_p);\n    return (ecma_string_t *) string_desc_p;\n  }\n\n  ecma_long_utf8_string_t *string_desc_p;\n  string_desc_p = (ecma_long_utf8_string_t *) ecma_alloc_string_buffer (size + sizeof (ecma_long_utf8_string_t));\n  string_desc_p->header.refs_and_container = ECMA_STRING_CONTAINER_HEAP_LONG_UTF8_STRING | ECMA_STRING_REF_ONE;\n  string_desc_p->size = size;\n  string_desc_p->length = length;\n\n  *data_p = ECMA_LONG_UTF8_STRING_GET_BUFFER (string_desc_p);\n  return (ecma_string_t *) string_desc_p;\n}",
        "begin_line": 248,
        "end_line": 286,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_property_to_string#1523",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_property_to_string (ecma_property_t property, /**< property name type */                          jmem_cpointer_t prop_name_cp) /**< property name compressed pointer */",
        "snippet": "static inline ecma_string_t * JERRY_ATTR_ALWAYS_INLINE\necma_property_to_string (ecma_property_t property, /**< property name type */\n                         jmem_cpointer_t prop_name_cp) /**< property name compressed pointer */\n{\n  uintptr_t property_string = ((uintptr_t) (property)) & (0x3 << ECMA_PROPERTY_NAME_TYPE_SHIFT);\n  property_string = (property_string >> ECMA_STRING_TYPE_CONVERSION_SHIFT) | ECMA_TYPE_DIRECT_STRING;\n  return (ecma_string_t *) (property_string | (((uintptr_t) prop_name_cp) << ECMA_DIRECT_STRING_SHIFT));\n}",
        "begin_line": 1523,
        "end_line": 1530,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_ref_ecma_string#755",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_ref_ecma_string (ecma_string_t *string_p) /**< string descriptor */",
        "snippet": "void\necma_ref_ecma_string (ecma_string_t *string_p) /**< string descriptor */\n{\n  JERRY_ASSERT (string_p != NULL);\n\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    return;\n  }\n\n#ifdef JERRY_NDEBUG\n  if (ECMA_STRING_IS_STATIC (string_p))\n  {\n    return;\n  }\n#endif /* JERRY_NDEBUG */\n\n  JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);\n\n  if (JERRY_LIKELY (string_p->refs_and_container < ECMA_STRING_MAX_REF))\n  {\n    /* Increase reference counter. */\n    string_p->refs_and_container += ECMA_STRING_REF_ONE;\n  }\n  else\n  {\n    jerry_fatal (ERR_REF_COUNT_LIMIT);\n  }\n}",
        "begin_line": 755,
        "end_line": 783,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_compare_to_property_name#1628",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_compare_to_property_name (ecma_property_t property, /**< property name type */                                       jmem_cpointer_t prop_name_cp, /**< property name compressed pointer */                                       const ecma_string_t *string_p) /**< other string */",
        "snippet": "inline bool JERRY_ATTR_ALWAYS_INLINE\necma_string_compare_to_property_name (ecma_property_t property, /**< property name type */\n                                      jmem_cpointer_t prop_name_cp, /**< property name compressed pointer */\n                                      const ecma_string_t *string_p) /**< other string */\n{\n  if (ECMA_PROPERTY_GET_NAME_TYPE (property) != ECMA_DIRECT_STRING_PTR)\n  {\n    return ecma_property_to_string (property, prop_name_cp) == string_p;\n  }\n\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    return false;\n  }\n\n  ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, prop_name_cp);\n  return ecma_compare_ecma_non_direct_strings (prop_name_p, string_p);\n}",
        "begin_line": 1628,
        "end_line": 1645,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_copy_to_cesu8_buffer#940",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_copy_to_cesu8_buffer (const ecma_string_t *string_p, /**< ecma-string descriptor */                                   lit_utf8_byte_t *buffer_p, /**< destination buffer pointer                                                               * (can be NULL if buffer_size == 0) */                                   lit_utf8_size_t buffer_size) /**< size of buffer */",
        "snippet": "lit_utf8_size_t JERRY_ATTR_WARN_UNUSED_RESULT\necma_string_copy_to_cesu8_buffer (const ecma_string_t *string_p, /**< ecma-string descriptor */\n                                  lit_utf8_byte_t *buffer_p, /**< destination buffer pointer\n                                                              * (can be NULL if buffer_size == 0) */\n                                  lit_utf8_size_t buffer_size) /**< size of buffer */\n{\n  JERRY_ASSERT (string_p != NULL);\n  JERRY_ASSERT (buffer_p != NULL || buffer_size == 0);\n  JERRY_ASSERT (ecma_string_get_size (string_p) <= buffer_size);\n\n  lit_utf8_size_t size;\n\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    if (ECMA_IS_DIRECT_STRING_WITH_TYPE (string_p, ECMA_DIRECT_STRING_UINT))\n    {\n      uint32_t uint32_number = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);\n      size = ecma_uint32_to_utf8_string (uint32_number, buffer_p, buffer_size);\n      JERRY_ASSERT (size <= buffer_size);\n      return size;\n    }\n  }\n  else\n  {\n    JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);\n\n    if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC)\n    {\n      uint32_t uint32_number = string_p->u.uint32_number;\n      size = ecma_uint32_to_utf8_string (uint32_number, buffer_p, buffer_size);\n      JERRY_ASSERT (size <= buffer_size);\n      return size;\n    }\n  }\n\n  const lit_utf8_byte_t *chars_p = ecma_string_get_chars_fast (string_p, &size);\n\n  JERRY_ASSERT (chars_p != NULL);\n  JERRY_ASSERT (size <= buffer_size);\n\n  memcpy (buffer_p, chars_p, size);\n  return size;\n}",
        "begin_line": 940,
        "end_line": 982,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_array_index#909",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_array_index (const ecma_string_t *str_p) /**< ecma-string */",
        "snippet": "inline uint32_t JERRY_ATTR_ALWAYS_INLINE\necma_string_get_array_index (const ecma_string_t *str_p) /**< ecma-string */\n{\n  if (ECMA_IS_DIRECT_STRING (str_p))\n  {\n    if (ECMA_IS_DIRECT_STRING_WITH_TYPE (str_p, ECMA_DIRECT_STRING_UINT))\n    {\n      /* Value cannot be equal to the maximum value of a 32 bit unsigned number. */\n      return (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (str_p);\n    }\n\n    return ECMA_STRING_NOT_ARRAY_INDEX;\n  }\n\n  if (ECMA_STRING_GET_CONTAINER (str_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC)\n  {\n    /* When the uint32_number is equal to the maximum value of 32 bit unsigned integer number,\n     * it is also an invalid array index. The comparison to ECMA_STRING_NOT_ARRAY_INDEX will\n     * be true in this case. */\n    return str_p->u.uint32_number;\n  }\n\n  return ECMA_STRING_NOT_ARRAY_INDEX;\n}",
        "begin_line": 909,
        "end_line": 932,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_ascii_size#1899",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_ascii_size (const ecma_string_t *string_p) /**< ecma-string */",
        "snippet": "static ecma_length_t\necma_string_get_ascii_size (const ecma_string_t *string_p) /**< ecma-string */\n{\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    switch (ECMA_GET_DIRECT_STRING_TYPE (string_p))\n    {\n      case ECMA_DIRECT_STRING_MAGIC:\n      {\n        uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);\n\n        if (id >= LIT_MAGIC_STRING__COUNT)\n        {\n          return ECMA_STRING_NO_ASCII_SIZE;\n        }\n\n        JERRY_ASSERT (ECMA_STRING_IS_ASCII (lit_get_magic_string_utf8 (id),\n                                            lit_get_magic_string_size (id)));\n\n        return lit_get_magic_string_size (id);\n      }\n      default:\n      {\n        JERRY_ASSERT (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_UINT);\n        uint32_t uint32_number = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);\n        return ecma_string_get_uint32_size (uint32_number);\n      }\n    }\n  }\n\n  JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);\n\n  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC)\n  {\n    return ecma_string_get_uint32_size (string_p->u.uint32_number);\n  }\n  else if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_HEAP_ASCII_STRING)\n  {\n    return ((ecma_ascii_string_t *) string_p)->size;\n  }\n\n  return ECMA_STRING_NO_ASCII_SIZE;\n}",
        "begin_line": 1899,
        "end_line": 1941,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_chars#1323",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_chars (const ecma_string_t *string_p, /**< ecma-string */                        lit_utf8_size_t *size_p, /**< [out] size of the ecma string */                        lit_utf8_size_t *length_p, /**< [out] optional argument. If the pointer is not NULL the pointed                                                    *    memory area is filled with the length of the ecma string */                        lit_utf8_byte_t *uint32_buff_p, /**< [out] optional argument. If the pointer is not NULL the                                                         *    pointed memory area is filled with the string converted                                                         *    uint32 string descriptor */                        uint8_t *flags_p) /**< [in, out] any combination of ecma_string_flag_t bits */",
        "snippet": "const lit_utf8_byte_t *\necma_string_get_chars (const ecma_string_t *string_p, /**< ecma-string */\n                       lit_utf8_size_t *size_p, /**< [out] size of the ecma string */\n                       lit_utf8_size_t *length_p, /**< [out] optional argument. If the pointer is not NULL the pointed\n                                                   *    memory area is filled with the length of the ecma string */\n                       lit_utf8_byte_t *uint32_buff_p, /**< [out] optional argument. If the pointer is not NULL the\n                                                        *    pointed memory area is filled with the string converted\n                                                        *    uint32 string descriptor */\n                       uint8_t *flags_p) /**< [in,out] any combination of ecma_string_flag_t bits */\n{\n  ecma_length_t length;\n  lit_utf8_size_t size;\n  const lit_utf8_byte_t *result_p;\n\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    *flags_p |= ECMA_STRING_FLAG_REHASH_NEEDED;\n\n    switch (ECMA_GET_DIRECT_STRING_TYPE (string_p))\n    {\n      case ECMA_DIRECT_STRING_MAGIC:\n      {\n        uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);\n\n        if (id >= LIT_MAGIC_STRING__COUNT)\n        {\n          id -= LIT_MAGIC_STRING__COUNT;\n          size = lit_get_magic_string_ex_size (id);\n          result_p = lit_get_magic_string_ex_utf8 (id);\n          length = 0;\n\n          if (JERRY_UNLIKELY (*flags_p & ECMA_STRING_FLAG_IS_ASCII))\n          {\n            length = lit_utf8_string_length (result_p, size);\n          }\n        }\n        else\n        {\n          size = lit_get_magic_string_size (id);\n          length = size;\n\n          result_p = lit_get_magic_string_utf8 (id);\n\n          /* All magic strings must be ascii strings. */\n          JERRY_ASSERT (ECMA_STRING_IS_ASCII (result_p, size));\n        }\n        break;\n      }\n      default:\n      {\n        JERRY_ASSERT (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_UINT);\n        uint32_t uint32_number = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);\n        size = (lit_utf8_size_t) ecma_string_get_uint32_size (uint32_number);\n\n        if (uint32_buff_p != NULL)\n        {\n          result_p = uint32_buff_p;\n        }\n        else\n        {\n          result_p = (const lit_utf8_byte_t *) jmem_heap_alloc_block (size);\n          *flags_p |= ECMA_STRING_FLAG_MUST_BE_FREED;\n        }\n\n        length = ecma_uint32_to_utf8_string (uint32_number, (lit_utf8_byte_t *) result_p, size);\n\n        JERRY_ASSERT (length == size);\n        *flags_p |= ECMA_STRING_FLAG_IS_UINT32;\n        break;\n      }\n    }\n  }\n  else\n  {\n    JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);\n\n    switch (ECMA_STRING_GET_CONTAINER (string_p))\n    {\n      case ECMA_STRING_CONTAINER_HEAP_UTF8_STRING:\n      {\n        ecma_utf8_string_t *utf8_string_desc_p = (ecma_utf8_string_t *) string_p;\n        size = utf8_string_desc_p->size;\n        length = utf8_string_desc_p->length;\n        result_p = ECMA_UTF8_STRING_GET_BUFFER (utf8_string_desc_p);\n        break;\n      }\n      case ECMA_STRING_CONTAINER_HEAP_LONG_UTF8_STRING:\n      {\n        ecma_long_utf8_string_t *long_utf8_string_desc_p = (ecma_long_utf8_string_t *) string_p;\n        size = long_utf8_string_desc_p->size;\n        length = long_utf8_string_desc_p->length;\n        result_p = ECMA_LONG_UTF8_STRING_GET_BUFFER (long_utf8_string_desc_p);\n        break;\n      }\n      case ECMA_STRING_CONTAINER_HEAP_ASCII_STRING:\n      {\n        ecma_ascii_string_t *ascii_string_desc_p = (ecma_ascii_string_t *) string_p;\n        size = ascii_string_desc_p->size;\n        length = ascii_string_desc_p->size;\n        result_p = ECMA_ASCII_STRING_GET_BUFFER (ascii_string_desc_p);\n        break;\n      }\n      case ECMA_STRING_CONTAINER_UINT32_IN_DESC:\n      {\n        size = (lit_utf8_size_t) ecma_string_get_uint32_size (string_p->u.uint32_number);\n\n        if (uint32_buff_p != NULL)\n        {\n          result_p = uint32_buff_p;\n        }\n        else\n        {\n          result_p = (const lit_utf8_byte_t *) jmem_heap_alloc_block (size);\n          *flags_p |= ECMA_STRING_FLAG_MUST_BE_FREED;\n        }\n\n        length = ecma_uint32_to_utf8_string (string_p->u.uint32_number, (lit_utf8_byte_t *) result_p, size);\n\n        JERRY_ASSERT (length == size);\n        *flags_p |= ECMA_STRING_FLAG_IS_UINT32 | ECMA_STRING_FLAG_REHASH_NEEDED;\n        break;\n\n      }\n      default:\n      {\n        JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);\n\n        lit_magic_string_ex_id_t id = LIT_MAGIC_STRING__COUNT - string_p->u.magic_string_ex_id;\n        size = lit_get_magic_string_ex_size (id);\n        length = 0;\n\n        if (JERRY_UNLIKELY (*flags_p & ECMA_STRING_FLAG_IS_ASCII))\n        {\n          length = lit_utf8_string_length (lit_get_magic_string_ex_utf8 (id), size);\n        }\n\n        result_p = lit_get_magic_string_ex_utf8 (id);\n        *flags_p |= ECMA_STRING_FLAG_REHASH_NEEDED;\n        break;\n      }\n    }\n  }\n\n  *size_p = size;\n  if (length_p != NULL)\n  {\n    *length_p = length;\n  }\n\n  if ((*flags_p & ECMA_STRING_FLAG_IS_ASCII)\n      && length != size)\n  {\n    *flags_p = (uint8_t) (*flags_p & (uint8_t) ~ECMA_STRING_FLAG_IS_ASCII);\n  }\n\n  return result_p;\n}",
        "begin_line": 1323,
        "end_line": 1479,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_chars_fast#129",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_chars_fast (const ecma_string_t *string_p, /**< ecma-string */                             lit_utf8_size_t *size_p) /**< [out] size of the ecma string */",
        "snippet": "static const lit_utf8_byte_t *\necma_string_get_chars_fast (const ecma_string_t *string_p, /**< ecma-string */\n                            lit_utf8_size_t *size_p) /**< [out] size of the ecma string */\n{\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    if (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_MAGIC)\n    {\n      uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);\n\n      if (id >= LIT_MAGIC_STRING__COUNT)\n      {\n        id -= LIT_MAGIC_STRING__COUNT;\n\n        *size_p = lit_get_magic_string_ex_size (id);\n        return lit_get_magic_string_ex_utf8 (id);\n      }\n\n      *size_p = lit_get_magic_string_size (id);\n      return lit_get_magic_string_utf8 (id);\n    }\n  }\n\n  JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);\n\n  switch (ECMA_STRING_GET_CONTAINER (string_p))\n  {\n    case ECMA_STRING_CONTAINER_HEAP_UTF8_STRING:\n    {\n      *size_p = ((ecma_utf8_string_t *) string_p)->size;\n      return ECMA_UTF8_STRING_GET_BUFFER (string_p);\n    }\n    case ECMA_STRING_CONTAINER_HEAP_LONG_UTF8_STRING:\n    {\n      *size_p = ((ecma_long_utf8_string_t *) string_p)->size;\n      return ECMA_LONG_UTF8_STRING_GET_BUFFER (string_p);\n    }\n    case ECMA_STRING_CONTAINER_HEAP_ASCII_STRING:\n    {\n      *size_p = ((ecma_ascii_string_t *) string_p)->size;\n      return ECMA_ASCII_STRING_GET_BUFFER (string_p);\n    }\n    default:\n    {\n      JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);\n\n      lit_magic_string_ex_id_t id = LIT_MAGIC_STRING__COUNT - string_p->u.magic_string_ex_id;\n      *size_p = lit_get_magic_string_ex_size (id);\n      return lit_get_magic_string_ex_utf8 (id);\n    }\n  }\n}",
        "begin_line": 129,
        "end_line": 180,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_property_name_hash#1581",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_property_name_hash (ecma_property_t property, /**< property name type */                                     jmem_cpointer_t prop_name_cp) /**< property name compressed pointer */",
        "snippet": "inline lit_string_hash_t JERRY_ATTR_ALWAYS_INLINE\necma_string_get_property_name_hash (ecma_property_t property, /**< property name type */\n                                    jmem_cpointer_t prop_name_cp) /**< property name compressed pointer */\n{\n  if (ECMA_PROPERTY_GET_NAME_TYPE (property) == ECMA_DIRECT_STRING_PTR)\n  {\n    ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, prop_name_cp);\n    return prop_name_p->u.hash;\n  }\n\n  return (lit_string_hash_t) prop_name_cp;\n}",
        "begin_line": 1581,
        "end_line": 1592,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_size#2048",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_size (const ecma_string_t *string_p) /**< ecma-string */",
        "snippet": "lit_utf8_size_t\necma_string_get_size (const ecma_string_t *string_p) /**< ecma-string */\n{\n  ecma_length_t length = ecma_string_get_ascii_size (string_p);\n\n  if (length != ECMA_STRING_NO_ASCII_SIZE)\n  {\n    return length;\n  }\n\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    JERRY_ASSERT (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_MAGIC);\n    JERRY_ASSERT ((uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p) >= LIT_MAGIC_STRING__COUNT);\n\n    return lit_get_magic_string_ex_size ((uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p) - LIT_MAGIC_STRING__COUNT);\n  }\n\n  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_HEAP_UTF8_STRING)\n  {\n    return (lit_utf8_size_t) (((ecma_utf8_string_t *) string_p)->size);\n  }\n\n  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_HEAP_LONG_UTF8_STRING)\n  {\n    return (lit_utf8_size_t) (((ecma_long_utf8_string_t *) string_p)->size);\n  }\n\n  JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);\n\n  return lit_get_magic_string_ex_size (LIT_MAGIC_STRING__COUNT - string_p->u.magic_string_ex_id);\n}",
        "begin_line": 2048,
        "end_line": 2079,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_uint32_size#1283",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_uint32_size (const uint32_t uint32_number) /**< number in the string-descriptor */",
        "snippet": "static inline ecma_length_t JERRY_ATTR_ALWAYS_INLINE\necma_string_get_uint32_size (const uint32_t uint32_number) /**< number in the string-descriptor */\n{\n  uint32_t prev_number = 1;\n  uint32_t next_number = 100;\n  ecma_length_t size = 1;\n\n  const uint32_t max_size = 9;\n\n  while (size < max_size && uint32_number >= next_number)\n  {\n    prev_number = next_number;\n    next_number *= 100;\n    size += 2;\n  }\n\n  if (uint32_number >= prev_number * 10)\n  {\n    size++;\n  }\n\n  return size;\n}",
        "begin_line": 1283,
        "end_line": 1305,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_hash#2282",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_hash (const ecma_string_t *string_p) /**< ecma-string to calculate hash for */",
        "snippet": "inline lit_string_hash_t JERRY_ATTR_ALWAYS_INLINE\necma_string_hash (const ecma_string_t *string_p) /**< ecma-string to calculate hash for */\n{\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    return (lit_string_hash_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);\n  }\n\n  return (lit_string_hash_t) string_p->u.hash;\n}",
        "begin_line": 2282,
        "end_line": 2291,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_is_length#1512",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_is_length (const ecma_string_t *string_p) /**< property name */",
        "snippet": "inline bool JERRY_ATTR_ALWAYS_INLINE\necma_string_is_length (const ecma_string_t *string_p) /**< property name */\n{\n  return ecma_compare_ecma_string_to_magic_id (string_p, LIT_MAGIC_STRING_LENGTH);\n}",
        "begin_line": 1512,
        "end_line": 1516,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_to_property_name#1537",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_to_property_name (ecma_string_t *prop_name_p, /**< property name */                               ecma_property_t *name_type_p) /**< [out] property name type */",
        "snippet": "inline jmem_cpointer_t JERRY_ATTR_ALWAYS_INLINE\necma_string_to_property_name (ecma_string_t *prop_name_p, /**< property name */\n                              ecma_property_t *name_type_p) /**< [out] property name type */\n{\n  if (ECMA_IS_DIRECT_STRING (prop_name_p))\n  {\n    *name_type_p = (ecma_property_t) ECMA_DIRECT_STRING_TYPE_TO_PROP_NAME_TYPE (prop_name_p);\n    return (jmem_cpointer_t) ECMA_GET_DIRECT_STRING_VALUE (prop_name_p);\n  }\n\n  *name_type_p = ECMA_DIRECT_STRING_PTR << ECMA_PROPERTY_NAME_TYPE_SHIFT;\n\n  ecma_ref_ecma_string (prop_name_p);\n\n  jmem_cpointer_t prop_name_cp;\n  ECMA_SET_NON_NULL_POINTER (prop_name_cp, prop_name_p);\n  return prop_name_cp;\n}",
        "begin_line": 1537,
        "end_line": 1554,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_trim_helper#2352",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_trim_helper (const lit_utf8_byte_t **utf8_str_p, /**< [in, out] current string position */                          lit_utf8_size_t *utf8_str_size) /**< [in, out] size of the given string */",
        "snippet": "void\necma_string_trim_helper (const lit_utf8_byte_t **utf8_str_p, /**< [in, out] current string position */\n                         lit_utf8_size_t *utf8_str_size) /**< [in, out] size of the given string */\n{\n  ecma_char_t ch;\n  lit_utf8_size_t read_size;\n  const lit_utf8_byte_t *nonws_start_p = *utf8_str_p + *utf8_str_size;\n  const lit_utf8_byte_t *current_p = *utf8_str_p;\n\n  while (current_p < nonws_start_p)\n  {\n    read_size = lit_read_code_unit_from_utf8 (current_p, &ch);\n\n    if (!lit_char_is_white_space (ch))\n    {\n      nonws_start_p = current_p;\n      break;\n    }\n\n    current_p += read_size;\n  }\n\n  current_p = *utf8_str_p + *utf8_str_size;\n\n  while (current_p > nonws_start_p)\n  {\n    read_size = lit_read_prev_code_unit_from_utf8 (current_p, &ch);\n\n    if (!lit_char_is_white_space (ch))\n    {\n      break;\n    }\n\n    current_p -= read_size;\n  }\n\n  *utf8_str_p = nonws_start_p;\n  *utf8_str_size = (lit_utf8_size_t) (current_p - nonws_start_p);\n}",
        "begin_line": 2352,
        "end_line": 2390,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_append#2569",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_append (ecma_stringbuilder_t *builder_p, /**< string builder */                            const ecma_string_t *string_p) /**< ecma string */",
        "snippet": "void\necma_stringbuilder_append (ecma_stringbuilder_t *builder_p, /**< string builder */\n                           const ecma_string_t *string_p) /**< ecma string */\n{\n  const lit_utf8_size_t string_size = ecma_string_get_size (string_p);\n  lit_utf8_byte_t *dest_p = ecma_stringbuilder_grow (builder_p, string_size);\n\n  size_t copied_size = ecma_string_copy_to_cesu8_buffer (string_p,\n                                                         dest_p,\n                                                         string_size);\n  JERRY_ASSERT (copied_size == string_size);\n}",
        "begin_line": 2569,
        "end_line": 2580,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_append_magic#2585",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_append_magic (ecma_stringbuilder_t *builder_p, /**< string builder */                                  const lit_magic_string_id_t id) /**< magic string id */",
        "snippet": "void\necma_stringbuilder_append_magic (ecma_stringbuilder_t *builder_p, /**< string builder */\n                                 const lit_magic_string_id_t id) /**< magic string id */\n{\n  const lit_utf8_size_t string_size = lit_get_magic_string_size (id);\n  lit_utf8_byte_t *dest_p = ecma_stringbuilder_grow (builder_p, string_size);\n\n  const lit_utf8_byte_t *string_data_p = lit_get_magic_string_utf8 (id);\n  memcpy (dest_p, string_data_p, string_size);\n}",
        "begin_line": 2585,
        "end_line": 2594,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_append_raw#2599",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_append_raw (ecma_stringbuilder_t *builder_p, /**< string builder */                                const lit_utf8_byte_t *data_p, /**< pointer to data */                                const lit_utf8_size_t data_size) /**< size of the data */",
        "snippet": "void\necma_stringbuilder_append_raw (ecma_stringbuilder_t *builder_p, /**< string builder */\n                               const lit_utf8_byte_t *data_p, /**< pointer to data */\n                               const lit_utf8_size_t data_size) /**< size of the data */\n{\n  lit_utf8_byte_t *dest_p = ecma_stringbuilder_grow (builder_p, data_size);\n  memcpy (dest_p, data_p, data_size);\n}",
        "begin_line": 2599,
        "end_line": 2606,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_create#2429",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_create (void)",
        "snippet": "ecma_stringbuilder_t\necma_stringbuilder_create (void)\n{\n  const lit_utf8_size_t initial_size = sizeof (ecma_ascii_string_t);\n  ecma_stringbuilder_header_t *header_p = (ecma_stringbuilder_header_t *) jmem_heap_alloc_block (initial_size);\n  header_p->current_size = initial_size;\n#if ENABLED (JERRY_MEM_STATS)\n  jmem_stats_allocate_string_bytes (initial_size);\n#endif /* ENABLED (JERRY_MEM_STATS) */\n\n  ecma_stringbuilder_t ret = {.header_p = header_p};\n  return ret;\n}",
        "begin_line": 2429,
        "end_line": 2441,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_create_raw#2474",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_create_raw (const lit_utf8_byte_t *data_p, /**< pointer to data */                                const lit_utf8_size_t data_size) /**< size of the data */",
        "snippet": "ecma_stringbuilder_t\necma_stringbuilder_create_raw (const lit_utf8_byte_t *data_p, /**< pointer to data */\n                               const lit_utf8_size_t data_size) /**< size of the data */\n{\n  const lit_utf8_size_t initial_size = data_size + (lit_utf8_size_t) sizeof (ecma_ascii_string_t);\n\n  ecma_stringbuilder_header_t *header_p = (ecma_stringbuilder_header_t *) jmem_heap_alloc_block (initial_size);\n  header_p->current_size = initial_size;\n#if ENABLED (JERRY_MEM_STATS)\n  jmem_stats_allocate_string_bytes (initial_size);\n#endif /* ENABLED (JERRY_MEM_STATS) */\n\n  memcpy (ECMA_STRINGBUILDER_STRING_PTR (header_p), data_p, data_size);\n\n  ecma_stringbuilder_t ret = {.header_p = header_p};\n  return ret;\n}",
        "begin_line": 2474,
        "end_line": 2490,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_finalize#2640",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_finalize (ecma_stringbuilder_t *builder_p) /**< string builder */",
        "snippet": "ecma_string_t *\necma_stringbuilder_finalize (ecma_stringbuilder_t *builder_p) /**< string builder */\n{\n  ecma_stringbuilder_header_t *header_p = builder_p->header_p;\n  JERRY_ASSERT (header_p != NULL);\n\n  const lit_utf8_size_t string_size = ECMA_STRINGBUILDER_STRING_SIZE (header_p);\n  lit_utf8_byte_t *string_begin_p = ECMA_STRINGBUILDER_STRING_PTR (header_p);\n\n  ecma_string_t *string_p = ecma_find_special_string (string_begin_p, string_size);\n\n  if (JERRY_UNLIKELY (string_p != NULL))\n  {\n    ecma_stringbuilder_destroy (builder_p);\n    return string_p;\n  }\n\n#ifndef JERRY_NDEBUG\n  builder_p->header_p = NULL;\n#endif\n\n  size_t container_size = sizeof (ecma_utf8_string_t);\n  const lit_string_hash_t hash = lit_utf8_string_calc_hash (string_begin_p, string_size);\n  const lit_utf8_size_t length = lit_utf8_string_length (string_begin_p, string_size);\n\n  if (JERRY_LIKELY (string_size <= UINT16_MAX))\n  {\n    if (JERRY_LIKELY (length == string_size))\n    {\n      ecma_ascii_string_t *ascii_string_p = (ecma_ascii_string_t *) header_p;\n      ascii_string_p->header.refs_and_container = ECMA_STRING_CONTAINER_HEAP_ASCII_STRING | ECMA_STRING_REF_ONE;\n      ascii_string_p->header.u.hash = hash;\n      ascii_string_p->size = (uint16_t) string_size;\n\n      return (ecma_string_t *) ascii_string_p;\n    }\n  }\n  else\n  {\n    container_size = sizeof (ecma_long_utf8_string_t);\n  }\n\n  const size_t utf8_string_size = string_size + container_size;\n  header_p = jmem_heap_realloc_block (header_p, header_p->current_size, utf8_string_size);\n  memmove (((lit_utf8_byte_t *) header_p + container_size),\n           ECMA_STRINGBUILDER_STRING_PTR (header_p),\n           string_size);\n\n#if ENABLED (JERRY_MEM_STATS)\n  jmem_stats_allocate_string_bytes (container_size - sizeof (ecma_ascii_string_t));\n#endif /* ENABLED (JERRY_MEM_STATS) */\n\n  if (JERRY_LIKELY (string_size <= UINT16_MAX))\n  {\n    ecma_utf8_string_t *utf8_string_p = (ecma_utf8_string_t *) header_p;\n\n    utf8_string_p->header.refs_and_container = ECMA_STRING_CONTAINER_HEAP_UTF8_STRING | ECMA_STRING_REF_ONE;\n    utf8_string_p->header.u.hash = hash;\n    utf8_string_p->size = (uint16_t) string_size;\n    utf8_string_p->length = (uint16_t) length;\n\n    return (ecma_string_t *) utf8_string_p;\n  }\n\n  ecma_long_utf8_string_t *long_utf8_string_p = (ecma_long_utf8_string_t *) header_p;\n\n  long_utf8_string_p->header.refs_and_container = ECMA_STRING_CONTAINER_HEAP_LONG_UTF8_STRING | ECMA_STRING_REF_ONE;\n  long_utf8_string_p->header.u.hash = hash;\n  long_utf8_string_p->size = string_size;\n  long_utf8_string_p->length = length;\n\n  return (ecma_string_t *) long_utf8_string_p;\n}",
        "begin_line": 2640,
        "end_line": 2712,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_grow#2497",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_stringbuilder_grow (ecma_stringbuilder_t *builder_p, /**< string builder */                          lit_utf8_size_t required_size) /**< required size */",
        "snippet": "static lit_utf8_byte_t *\necma_stringbuilder_grow (ecma_stringbuilder_t *builder_p, /**< string builder */\n                         lit_utf8_size_t required_size) /**< required size */\n{\n  ecma_stringbuilder_header_t *header_p = builder_p->header_p;\n  JERRY_ASSERT (header_p != NULL);\n\n  const lit_utf8_size_t new_size = header_p->current_size + required_size;\n  header_p = jmem_heap_realloc_block (header_p, header_p->current_size, new_size);\n  header_p->current_size = new_size;\n  builder_p->header_p = header_p;\n\n#if ENABLED (JERRY_MEM_STATS)\n  jmem_stats_allocate_string_bytes (required_size);\n#endif /* ENABLED (JERRY_MEM_STATS) */\n\n  return ((lit_utf8_byte_t *)  header_p) + header_p->current_size - required_size;\n}",
        "begin_line": 2497,
        "end_line": 2514,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_are_values_integer_numbers#269",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_are_values_integer_numbers (ecma_value_t first_value, /**< first ecma value */                                  ecma_value_t second_value) /**< second ecma value */",
        "snippet": "inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_are_values_integer_numbers (ecma_value_t first_value, /**< first ecma value */\n                                 ecma_value_t second_value) /**< second ecma value */\n{\n  JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_INTEGER_VALUE == 0,\n                       ecma_direct_type_integer_value_must_be_zero);\n\n  return ((first_value | second_value) & ECMA_DIRECT_TYPE_MASK) == ECMA_DIRECT_TYPE_INTEGER_VALUE;\n}",
        "begin_line": 269,
        "end_line": 277,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_check_value_type_is_spec_defined#401",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_check_value_type_is_spec_defined (ecma_value_t value) /**< ecma value */",
        "snippet": "void\necma_check_value_type_is_spec_defined (ecma_value_t value) /**< ecma value */\n{\n  JERRY_ASSERT (ecma_is_value_undefined (value)\n                || ecma_is_value_null (value)\n                || ecma_is_value_boolean (value)\n                || ecma_is_value_number (value)\n                || ecma_is_value_string (value)\n                || ECMA_ASSERT_VALUE_IS_SYMBOL (value)\n                || ecma_is_value_object (value));\n}",
        "begin_line": 401,
        "end_line": 411,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_copy_value#829",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_copy_value (ecma_value_t value)  /**< value description */",
        "snippet": "ecma_value_t\necma_copy_value (ecma_value_t value)  /**< value description */\n{\n  switch (ecma_get_value_type_field (value))\n  {\n    case ECMA_TYPE_FLOAT:\n    {\n      ecma_number_t *num_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (value);\n\n      return ecma_create_float_number (*num_p);\n    }\n    case ECMA_TYPE_STRING:\n    {\n      ecma_ref_ecma_string (ecma_get_string_from_value (value));\n      return value;\n    }\n#if ENABLED (JERRY_ES2015)\n    case ECMA_TYPE_SYMBOL:\n    {\n      ecma_ref_ecma_string (ecma_get_symbol_from_value (value));\n      return value;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case ECMA_TYPE_OBJECT:\n    {\n      ecma_ref_object (ecma_get_object_from_value (value));\n      return value;\n    }\n    default:\n    {\n      JERRY_ASSERT (ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT\n                    || ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT_STRING);\n\n      return value;\n    }\n  }\n}",
        "begin_line": 829,
        "end_line": 865,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_copy_value_if_not_object#889",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_copy_value_if_not_object (ecma_value_t value) /**< value description */",
        "snippet": "inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE\necma_copy_value_if_not_object (ecma_value_t value) /**< value description */\n{\n  if (!ecma_is_value_object (value))\n  {\n    return ecma_copy_value (value);\n  }\n\n  return value;\n}",
        "begin_line": 889,
        "end_line": 898,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_fast_copy_value#878",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_fast_copy_value (ecma_value_t value)  /**< value description */",
        "snippet": "inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE\necma_fast_copy_value (ecma_value_t value)  /**< value description */\n{\n  return (ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT) ? value : ecma_copy_value (value);\n}",
        "begin_line": 878,
        "end_line": 882,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_fast_free_value#1099",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_fast_free_value (ecma_value_t value) /**< value description */",
        "snippet": "inline void JERRY_ATTR_ALWAYS_INLINE\necma_fast_free_value (ecma_value_t value) /**< value description */\n{\n  if (ecma_get_value_type_field (value) != ECMA_TYPE_DIRECT)\n  {\n    ecma_free_value (value);\n  }\n}",
        "begin_line": 1099,
        "end_line": 1106,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_free_value#1048",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_free_value (ecma_value_t value) /**< value description */",
        "snippet": "void\necma_free_value (ecma_value_t value) /**< value description */\n{\n  switch (ecma_get_value_type_field (value))\n  {\n    case ECMA_TYPE_FLOAT:\n    {\n      ecma_number_t *number_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (value);\n      ecma_dealloc_number (number_p);\n      break;\n    }\n\n    case ECMA_TYPE_STRING:\n    {\n      ecma_string_t *string_p = ecma_get_string_from_value (value);\n      ecma_deref_ecma_string (string_p);\n      break;\n    }\n#if ENABLED (JERRY_ES2015)\n    case ECMA_TYPE_SYMBOL:\n    {\n      ecma_deref_ecma_string (ecma_get_symbol_from_value (value));\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case ECMA_TYPE_OBJECT:\n    {\n      ecma_deref_object (ecma_get_object_from_value (value));\n      break;\n    }\n\n    default:\n    {\n      JERRY_ASSERT (ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT\n                    || ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT_STRING);\n\n      /* no memory is allocated */\n      break;\n    }\n  }\n}",
        "begin_line": 1048,
        "end_line": 1088,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_free_value_if_not_object#1111",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_free_value_if_not_object (ecma_value_t value) /**< value description */",
        "snippet": "void\necma_free_value_if_not_object (ecma_value_t value) /**< value description */\n{\n  if (ecma_get_value_type_field (value) != ECMA_TYPE_OBJECT)\n  {\n    ecma_free_value (value);\n  }\n}",
        "begin_line": 1111,
        "end_line": 1118,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_integer_from_value#684",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_integer_from_value (ecma_value_t value) /**< ecma value */",
        "snippet": "inline ecma_integer_value_t JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_get_integer_from_value (ecma_value_t value) /**< ecma value */\n{\n  JERRY_ASSERT (ecma_is_value_integer_number (value));\n\n  return ((ecma_integer_value_t) value) >> ECMA_DIRECT_SHIFT;\n}",
        "begin_line": 684,
        "end_line": 690,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_object_from_value#790",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_object_from_value (ecma_value_t value) /**< ecma value */",
        "snippet": "inline ecma_object_t *JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE\necma_get_object_from_value (ecma_value_t value) /**< ecma value */\n{\n  JERRY_ASSERT (ecma_is_value_object (value));\n\n  return (ecma_object_t *) ecma_get_pointer_from_ecma_value (value);\n}",
        "begin_line": 790,
        "end_line": 796,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_pointer_from_ecma_value#106",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_pointer_from_ecma_value (ecma_value_t value) /**< value */",
        "snippet": "static inline void * JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE\necma_get_pointer_from_ecma_value (ecma_value_t value) /**< value */\n{\n#ifdef ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY\n  void *ptr = (void *) (uintptr_t) ((value) & ~ECMA_VALUE_TYPE_MASK);\n  JERRY_ASSERT (ptr != NULL);\n  return ptr;\n#else /* !ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY */\n  return ECMA_GET_NON_NULL_POINTER (void, value >> ECMA_VALUE_SHIFT);\n#endif /* ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY */\n}",
        "begin_line": 106,
        "end_line": 116,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_prop_name_from_value#772",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_prop_name_from_value (ecma_value_t value) /**< ecma value */",
        "snippet": "inline ecma_string_t *JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE\necma_get_prop_name_from_value (ecma_value_t value) /**< ecma value */\n{\n  JERRY_ASSERT (ecma_is_value_prop_name (value));\n\n  if ((value & ECMA_VALUE_TYPE_MASK) == ECMA_TYPE_DIRECT_STRING)\n  {\n    return (ecma_string_t *) (uintptr_t) value;\n  }\n\n  return (ecma_string_t *) ecma_get_pointer_from_ecma_value (value);\n}",
        "begin_line": 772,
        "end_line": 783,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_string_from_value#739",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_string_from_value (ecma_value_t value) /**< ecma value */",
        "snippet": "inline ecma_string_t *JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE\necma_get_string_from_value (ecma_value_t value) /**< ecma value */\n{\n  JERRY_ASSERT (ecma_is_value_string (value));\n\n  if ((value & ECMA_VALUE_TYPE_MASK) == ECMA_TYPE_DIRECT_STRING)\n  {\n    return (ecma_string_t *) (uintptr_t) value;\n  }\n\n  return (ecma_string_t *) ecma_get_pointer_from_ecma_value (value);\n}",
        "begin_line": 739,
        "end_line": 750,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_value_type_field#71",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_value_type_field (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline ecma_type_t JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_get_value_type_field (ecma_value_t value) /**< ecma value */\n{\n  return value & ECMA_VALUE_TYPE_MASK;\n}",
        "begin_line": 71,
        "end_line": 75,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_array_hole#245",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_array_hole (ecma_value_t value) /**< ecma value */",
        "snippet": "inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_array_hole (ecma_value_t value) /**< ecma value */\n{\n  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_ARRAY_HOLE);\n}",
        "begin_line": 245,
        "end_line": 249,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_boolean#197",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_boolean (ecma_value_t value) /**< ecma value */",
        "snippet": "inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_boolean (ecma_value_t value) /**< ecma value */\n{\n  return ecma_is_value_true (value | (1 << ECMA_DIRECT_SHIFT));\n}",
        "begin_line": 197,
        "end_line": 201,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_empty#161",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_empty (ecma_value_t value) /**< ecma value */",
        "snippet": "inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_empty (ecma_value_t value) /**< ecma value */\n{\n  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_EMPTY);\n}",
        "begin_line": 161,
        "end_line": 165,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_equal_to_simple_value#148",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_equal_to_simple_value (ecma_value_t value, /**< ecma value */                                      ecma_value_t simple_value) /**< simple value */",
        "snippet": "static inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_equal_to_simple_value (ecma_value_t value, /**< ecma value */\n                                     ecma_value_t simple_value) /**< simple value */\n{\n  return value == simple_value;\n}",
        "begin_line": 148,
        "end_line": 153,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_error_reference#391",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_error_reference (ecma_value_t value) /**< ecma value */",
        "snippet": "inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_error_reference (ecma_value_t value) /**< ecma value */\n{\n  return (ecma_get_value_type_field (value) == ECMA_TYPE_ERROR);\n}",
        "begin_line": 391,
        "end_line": 395,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_false#221",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_false (ecma_value_t value) /**< ecma value */",
        "snippet": "inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_false (ecma_value_t value) /**< ecma value */\n{\n  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_FALSE);\n}",
        "begin_line": 221,
        "end_line": 225,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_float_number#285",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_float_number (ecma_value_t value) /**< ecma value */",
        "snippet": "inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_float_number (ecma_value_t value) /**< ecma value */\n{\n  return (ecma_get_value_type_field (value) == ECMA_TYPE_FLOAT);\n}",
        "begin_line": 285,
        "end_line": 289,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_found#233",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_found (ecma_value_t value) /**< ecma value */",
        "snippet": "inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_found (ecma_value_t value) /**< ecma value */\n{\n  return value != ECMA_VALUE_NOT_FOUND;\n}",
        "begin_line": 233,
        "end_line": 237,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_integer_number#257",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_integer_number (ecma_value_t value) /**< ecma value */",
        "snippet": "inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_integer_number (ecma_value_t value) /**< ecma value */\n{\n  return (value & ECMA_DIRECT_TYPE_MASK) == ECMA_DIRECT_TYPE_INTEGER_VALUE;\n}",
        "begin_line": 257,
        "end_line": 261,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_null#185",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_null (ecma_value_t value) /**< ecma value */",
        "snippet": "inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_null (ecma_value_t value) /**< ecma value */\n{\n  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_NULL);\n}",
        "begin_line": 185,
        "end_line": 189,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_number#297",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_number (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_number (ecma_value_t value) /**< ecma value */\n{\n  return (ecma_is_value_integer_number (value)\n          || ecma_is_value_float_number (value));\n}",
        "begin_line": 297,
        "end_line": 302,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_object#379",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_object (ecma_value_t value) /**< ecma value */",
        "snippet": "inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_object (ecma_value_t value) /**< ecma value */\n{\n  return (ecma_get_value_type_field (value) == ECMA_TYPE_OBJECT);\n}",
        "begin_line": 379,
        "end_line": 383,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_prop_name#339",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_prop_name (ecma_value_t value) /**< ecma value */",
        "snippet": "inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_prop_name (ecma_value_t value) /**< ecma value */\n{\n#if ENABLED (JERRY_ES2015)\n  return ecma_is_value_string (value) || ecma_is_value_symbol (value);\n#else /* !ENABLED (JERRY_ES2015) */\n  return ecma_is_value_string (value);\n#endif /* ENABLED (JERRY_ES2015) */\n}",
        "begin_line": 339,
        "end_line": 347,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_string#313",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_string (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_string (ecma_value_t value) /**< ecma value */\n{\n  return ((value & (ECMA_VALUE_TYPE_MASK - 0x4)) == ECMA_TYPE_STRING);\n}",
        "begin_line": 313,
        "end_line": 317,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_true#209",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_true (ecma_value_t value) /**< ecma value */",
        "snippet": "inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_true (ecma_value_t value) /**< ecma value */\n{\n  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_TRUE);\n}",
        "begin_line": 209,
        "end_line": 213,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_undefined#173",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_undefined (ecma_value_t value) /**< ecma value */",
        "snippet": "inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_undefined (ecma_value_t value) /**< ecma value */\n{\n  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_UNDEFINED);\n}",
        "begin_line": 173,
        "end_line": 177,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_int32_value#558",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_int32_value (int32_t int32_number) /**< int32 number to be encoded */",
        "snippet": "ecma_value_t\necma_make_int32_value (int32_t int32_number) /**< int32 number to be encoded */\n{\n  if (ECMA_IS_INTEGER_NUMBER (int32_number))\n  {\n    return ecma_make_integer_value ((ecma_integer_value_t) int32_number);\n  }\n\n  return ecma_create_float_number ((ecma_number_t) int32_number);\n}",
        "begin_line": 558,
        "end_line": 567,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_integer_value#471",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_integer_value (ecma_integer_value_t integer_value) /**< integer number to be encoded */",
        "snippet": "inline ecma_value_t JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_make_integer_value (ecma_integer_value_t integer_value) /**< integer number to be encoded */\n{\n  JERRY_ASSERT (ECMA_IS_INTEGER_NUMBER (integer_value));\n\n  return (((ecma_value_t) integer_value) << ECMA_DIRECT_SHIFT) | ECMA_DIRECT_TYPE_INTEGER_VALUE;\n}",
        "begin_line": 471,
        "end_line": 477,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_magic_string_value#647",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_magic_string_value (lit_magic_string_id_t id) /**< magic string id */",
        "snippet": "inline ecma_value_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE\necma_make_magic_string_value (lit_magic_string_id_t id) /**< magic string id */\n{\n  return (ecma_value_t) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_MAGIC, (uintptr_t) id);\n}",
        "begin_line": 647,
        "end_line": 651,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_number_value#538",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_number_value (ecma_number_t ecma_number) /**< number to be encoded */",
        "snippet": "ecma_value_t\necma_make_number_value (ecma_number_t ecma_number) /**< number to be encoded */\n{\n  ecma_integer_value_t integer_value = (ecma_integer_value_t) ecma_number;\n\n  if ((ecma_number_t) integer_value == ecma_number\n      && ((integer_value == 0) ? ecma_is_number_equal_to_positive_zero (ecma_number)\n                               : ECMA_IS_INTEGER_NUMBER (integer_value)))\n  {\n    return ecma_make_integer_value (integer_value);\n  }\n\n  return ecma_create_float_number (ecma_number);\n}",
        "begin_line": 538,
        "end_line": 551,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_object_value#658",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_object_value (const ecma_object_t *object_p) /**< object to reference in value */",
        "snippet": "inline ecma_value_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE\necma_make_object_value (const ecma_object_t *object_p) /**< object to reference in value */\n{\n  JERRY_ASSERT (object_p != NULL);\n\n  return ecma_pointer_to_ecma_value (object_p) | ECMA_TYPE_OBJECT;\n}",
        "begin_line": 658,
        "end_line": 664,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_string_value#590",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_string_value (const ecma_string_t *ecma_string_p) /**< string to reference in value */",
        "snippet": "inline ecma_value_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE\necma_make_string_value (const ecma_string_t *ecma_string_p) /**< string to reference in value */\n{\n  JERRY_ASSERT (ecma_string_p != NULL);\n#if ENABLED (JERRY_ES2015)\n  JERRY_ASSERT (!ecma_prop_name_is_symbol ((ecma_string_t *) ecma_string_p));\n#endif /* ENABLED (JERRY_ES2015) */\n\n  if ((((uintptr_t) ecma_string_p) & ECMA_VALUE_TYPE_MASK) != 0)\n  {\n    return (ecma_value_t) (uintptr_t) ecma_string_p;\n  }\n\n  return ecma_pointer_to_ecma_value (ecma_string_p) | ECMA_TYPE_STRING;\n}",
        "begin_line": 590,
        "end_line": 604,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_uint32_value#574",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_uint32_value (uint32_t uint32_number) /**< uint32 number to be encoded */",
        "snippet": "ecma_value_t\necma_make_uint32_value (uint32_t uint32_number) /**< uint32 number to be encoded */\n{\n  if (uint32_number <= ECMA_INTEGER_NUMBER_MAX)\n  {\n    return ecma_make_integer_value ((ecma_integer_value_t) uint32_number);\n  }\n\n  return ecma_create_float_number ((ecma_number_t) uint32_number);\n}",
        "begin_line": 574,
        "end_line": 583,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_pointer_to_ecma_value#82",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_pointer_to_ecma_value (const void *ptr) /**< pointer */",
        "snippet": "static inline ecma_value_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE\necma_pointer_to_ecma_value (const void *ptr) /**< pointer */\n{\n#ifdef ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY\n\n  JERRY_ASSERT (ptr != NULL);\n  uintptr_t uint_ptr = (uintptr_t) ptr;\n  JERRY_ASSERT ((uint_ptr & ECMA_VALUE_TYPE_MASK) == 0);\n  return (ecma_value_t) uint_ptr;\n\n#else /* !ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY */\n\n  jmem_cpointer_t ptr_cp;\n  ECMA_SET_NON_NULL_POINTER (ptr_cp, ptr);\n  return ((ecma_value_t) ptr_cp) << ECMA_VALUE_SHIFT;\n\n#endif /* ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY */\n}",
        "begin_line": 82,
        "end_line": 99,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_value_assign_value#930",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_value_assign_value (ecma_value_t *value_p, /**< [in, out] ecma value */                          ecma_value_t ecma_value) /**< value to assign */",
        "snippet": "void\necma_value_assign_value (ecma_value_t *value_p, /**< [in, out] ecma value */\n                         ecma_value_t ecma_value) /**< value to assign */\n{\n  JERRY_STATIC_ASSERT (ECMA_TYPE_DIRECT == 0,\n                       ecma_type_direct_must_be_zero_for_the_next_check);\n\n  if (*value_p == ecma_value)\n  {\n    return;\n  }\n\n  if (ecma_get_value_type_field (ecma_value || *value_p) == ECMA_TYPE_DIRECT)\n  {\n    *value_p = ecma_value;\n  }\n  else if (ecma_is_value_float_number (ecma_value)\n           && ecma_is_value_float_number (*value_p))\n  {\n    const ecma_number_t *num_src_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (ecma_value);\n    ecma_number_t *num_dst_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (*value_p);\n\n    *num_dst_p = *num_src_p;\n  }\n  else\n  {\n    ecma_free_value_if_not_object (*value_p);\n    *value_p = ecma_copy_value_if_not_object (ecma_value);\n  }\n}",
        "begin_line": 930,
        "end_line": 959,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_assert_object_contains_the_property#911",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_assert_object_contains_the_property (const ecma_object_t *object_p, /**< ecma-object */                                           const ecma_property_value_t *prop_value_p, /**< property value */                                           ecma_property_types_t type) /**< expected property type */",
        "snippet": "static void\necma_assert_object_contains_the_property (const ecma_object_t *object_p, /**< ecma-object */\n                                          const ecma_property_value_t *prop_value_p, /**< property value */\n                                          ecma_property_types_t type) /**< expected property type */\n{\n#ifndef JERRY_NDEBUG\n  jmem_cpointer_t prop_iter_cp = object_p->u1.property_list_cp;\n  JERRY_ASSERT (prop_iter_cp != JMEM_CP_NULL);\n\n  ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n\n  if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n  {\n    prop_iter_cp = prop_iter_p->next_property_cp;\n  }\n\n  while (prop_iter_cp != JMEM_CP_NULL)\n  {\n    prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n\n    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)\n    {\n      if ((prop_pair_p->values + i) == prop_value_p)\n      {\n        JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (prop_pair_p->header.types[i]) == type);\n        return;\n      }\n    }\n\n    prop_iter_cp = prop_iter_p->next_property_cp;\n  }\n#else /* JERRY_NDEBUG */\n  JERRY_UNUSED (object_p);\n  JERRY_UNUSED (prop_value_p);\n  JERRY_UNUSED (type);\n#endif /* !JERRY_NDEBUG */\n}",
        "begin_line": 911,
        "end_line": 951,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_bytecode_deref#1356",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_bytecode_deref (ecma_compiled_code_t *bytecode_p) /**< byte code pointer */",
        "snippet": "void\necma_bytecode_deref (ecma_compiled_code_t *bytecode_p) /**< byte code pointer */\n{\n  JERRY_ASSERT (bytecode_p->refs > 0);\n  JERRY_ASSERT (!(bytecode_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION));\n\n  bytecode_p->refs--;\n\n  if (bytecode_p->refs > 0)\n  {\n    /* Non-zero reference counter. */\n    return;\n  }\n\n  if (bytecode_p->status_flags & CBC_CODE_FLAGS_FUNCTION)\n  {\n    ecma_value_t *literal_start_p = NULL;\n    uint32_t literal_end;\n    uint32_t const_literal_end;\n\n    if (bytecode_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n    {\n      cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_p;\n      literal_end = args_p->literal_end;\n      const_literal_end = args_p->const_literal_end;\n\n      literal_start_p = (ecma_value_t *) ((uint8_t *) bytecode_p + sizeof (cbc_uint16_arguments_t));\n      literal_start_p -= args_p->register_end;\n    }\n    else\n    {\n      cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_p;\n      literal_end = args_p->literal_end;\n      const_literal_end = args_p->const_literal_end;\n\n      literal_start_p = (ecma_value_t *) ((uint8_t *) bytecode_p + sizeof (cbc_uint8_arguments_t));\n      literal_start_p -= args_p->register_end;\n    }\n\n    for (uint32_t i = const_literal_end; i < literal_end; i++)\n    {\n      ecma_compiled_code_t *bytecode_literal_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,\n                                                                                  literal_start_p[i]);\n\n      /* Self references are ignored. */\n      if (bytecode_literal_p != bytecode_p)\n      {\n        ecma_bytecode_deref (bytecode_literal_p);\n      }\n    }\n\n#if ENABLED (JERRY_DEBUGGER)\n    if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n        && !(bytecode_p->status_flags & CBC_CODE_FLAGS_DEBUGGER_IGNORE)\n        && jerry_debugger_send_function_cp (JERRY_DEBUGGER_RELEASE_BYTE_CODE_CP, bytecode_p))\n    {\n      /* Delay the byte code free until the debugger client is notified.\n       * If the connection is aborted the pointer is still freed by\n       * jerry_debugger_close_connection(). */\n      jerry_debugger_byte_code_free_t *byte_code_free_p = (jerry_debugger_byte_code_free_t *) bytecode_p;\n      jmem_cpointer_t byte_code_free_head = JERRY_CONTEXT (debugger_byte_code_free_head);\n\n      byte_code_free_p->prev_cp = ECMA_NULL_POINTER;\n\n      jmem_cpointer_t byte_code_free_cp;\n      JMEM_CP_SET_NON_NULL_POINTER (byte_code_free_cp, byte_code_free_p);\n\n      if (byte_code_free_head == ECMA_NULL_POINTER)\n      {\n        JERRY_CONTEXT (debugger_byte_code_free_tail) = byte_code_free_cp;\n      }\n      else\n      {\n        jerry_debugger_byte_code_free_t *first_byte_code_free_p;\n\n        first_byte_code_free_p = JMEM_CP_GET_NON_NULL_POINTER (jerry_debugger_byte_code_free_t,\n                                                               byte_code_free_head);\n        first_byte_code_free_p->prev_cp = byte_code_free_cp;\n      }\n\n      JERRY_CONTEXT (debugger_byte_code_free_head) = byte_code_free_cp;\n      return;\n    }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n#if ENABLED (JERRY_ES2015)\n    if (bytecode_p->status_flags & CBC_CODE_FLAG_HAS_TAGGED_LITERALS)\n    {\n      ecma_length_t formal_params_number = ecma_compiled_code_get_formal_params (bytecode_p);\n\n      uint8_t *byte_p = (uint8_t *) bytecode_p;\n      byte_p += ((size_t) bytecode_p->size) << JMEM_ALIGNMENT_LOG;\n\n      ecma_value_t *tagged_base_p = (ecma_value_t *) byte_p;\n      tagged_base_p -= formal_params_number;\n\n      ecma_collection_t *coll_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, tagged_base_p[-1]);\n\n      ecma_collection_destroy (coll_p);\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_MEM_STATS)\n    jmem_stats_free_byte_code_bytes (((size_t) bytecode_p->size) << JMEM_ALIGNMENT_LOG);\n#endif /* ENABLED (JERRY_MEM_STATS) */\n  }\n  else\n  {\n#if ENABLED (JERRY_BUILTIN_REGEXP)\n    re_compiled_code_t *re_bytecode_p = (re_compiled_code_t *) bytecode_p;\n\n    ecma_deref_ecma_string (ecma_get_string_from_value (re_bytecode_p->source));\n#endif /* ENABLED (JERRY_BUILTIN_REGEXP) */\n  }\n\n  jmem_heap_free_block (bytecode_p,\n                        ((size_t) bytecode_p->size) << JMEM_ALIGNMENT_LOG);\n}",
        "begin_line": 1356,
        "end_line": 1473,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_bytecode_ref#1340",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_bytecode_ref (ecma_compiled_code_t *bytecode_p) /**< byte code pointer */",
        "snippet": "void\necma_bytecode_ref (ecma_compiled_code_t *bytecode_p) /**< byte code pointer */\n{\n  /* Abort program if maximum reference number is reached. */\n  if (bytecode_p->refs >= UINT16_MAX)\n  {\n    jerry_fatal (ERR_REF_COUNT_LIMIT);\n  }\n\n  bytecode_p->refs++;\n}",
        "begin_line": 1340,
        "end_line": 1350,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_create_decl_lex_env#110",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_create_decl_lex_env (ecma_object_t *outer_lexical_environment_p) /**< outer lexical environment */",
        "snippet": "ecma_object_t *\necma_create_decl_lex_env (ecma_object_t *outer_lexical_environment_p) /**< outer lexical environment */\n{\n  ecma_object_t *new_lexical_environment_p = ecma_alloc_object ();\n\n  uint16_t type = ECMA_OBJECT_FLAG_BUILT_IN_OR_LEXICAL_ENV | ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE;\n  new_lexical_environment_p->type_flags_refs = type;\n\n  ecma_init_gc_info (new_lexical_environment_p);\n\n  new_lexical_environment_p->u1.property_list_cp = JMEM_CP_NULL;\n\n  ECMA_SET_POINTER (new_lexical_environment_p->u2.outer_reference_cp, outer_lexical_environment_p);\n\n  return new_lexical_environment_p;\n}",
        "begin_line": 110,
        "end_line": 125,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_create_named_accessor_property#541",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_create_named_accessor_property (ecma_object_t *object_p, /**< object */                                      ecma_string_t *name_p, /**< property name */                                      ecma_object_t *get_p, /**< getter */                                      ecma_object_t *set_p, /**< setter */                                      uint8_t prop_attributes, /**< property attributes */                                      ecma_property_t **out_prop_p) /**< [out] the property is also returned                                                                     *         if this field is non-NULL */",
        "snippet": "ecma_property_value_t *\necma_create_named_accessor_property (ecma_object_t *object_p, /**< object */\n                                     ecma_string_t *name_p, /**< property name */\n                                     ecma_object_t *get_p, /**< getter */\n                                     ecma_object_t *set_p, /**< setter */\n                                     uint8_t prop_attributes, /**< property attributes */\n                                     ecma_property_t **out_prop_p) /**< [out] the property is also returned\n                                                                    *         if this field is non-NULL */\n{\n  JERRY_ASSERT (object_p != NULL && name_p != NULL);\n  JERRY_ASSERT (ecma_is_lexical_environment (object_p)\n                || !ecma_op_object_is_fast_array (object_p));\n  JERRY_ASSERT (ecma_find_named_property (object_p, name_p) == NULL);\n  JERRY_ASSERT ((prop_attributes & ~ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE) == 0);\n\n  uint8_t type_and_flags = ECMA_PROPERTY_TYPE_NAMEDACCESSOR | prop_attributes;\n\n  ecma_property_value_t value;\n#if ENABLED (JERRY_CPOINTER_32_BIT)\n  ecma_getter_setter_pointers_t *getter_setter_pair_p;\n  getter_setter_pair_p = jmem_pools_alloc (sizeof (ecma_getter_setter_pointers_t));\n  ECMA_SET_POINTER (getter_setter_pair_p->getter_cp, get_p);\n  ECMA_SET_POINTER (getter_setter_pair_p->setter_cp, set_p);\n  ECMA_SET_NON_NULL_POINTER (value.getter_setter_pair_cp, getter_setter_pair_p);\n#else /* !ENABLED (JERRY_CPOINTER_32_BIT) */\n  ECMA_SET_POINTER (value.getter_setter_pair.getter_cp, get_p);\n  ECMA_SET_POINTER (value.getter_setter_pair.setter_cp, set_p);\n#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */\n\n  return ecma_create_property (object_p, name_p, type_and_flags, value, out_prop_p);\n}",
        "begin_line": 541,
        "end_line": 571,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_create_named_data_property#515",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_create_named_data_property (ecma_object_t *object_p, /**< object */                                  ecma_string_t *name_p, /**< property name */                                  uint8_t prop_attributes, /**< property attributes (See: ecma_property_flags_t) */                                  ecma_property_t **out_prop_p) /**< [out] the property is also returned                                                                 *         if this field is non-NULL */",
        "snippet": "ecma_property_value_t *\necma_create_named_data_property (ecma_object_t *object_p, /**< object */\n                                 ecma_string_t *name_p, /**< property name */\n                                 uint8_t prop_attributes, /**< property attributes (See: ecma_property_flags_t) */\n                                 ecma_property_t **out_prop_p) /**< [out] the property is also returned\n                                                                *         if this field is non-NULL */\n{\n  JERRY_ASSERT (object_p != NULL && name_p != NULL);\n  JERRY_ASSERT (ecma_is_lexical_environment (object_p)\n                || !ecma_op_object_is_fast_array (object_p));\n  JERRY_ASSERT (ecma_find_named_property (object_p, name_p) == NULL);\n  JERRY_ASSERT ((prop_attributes & ~ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE) == 0);\n\n  uint8_t type_and_flags = ECMA_PROPERTY_TYPE_NAMEDDATA | prop_attributes;\n\n  ecma_property_value_t value;\n  value.value = ECMA_VALUE_UNDEFINED;\n\n  return ecma_create_property (object_p, name_p, type_and_flags, value, out_prop_p);\n}",
        "begin_line": 515,
        "end_line": 534,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_create_object#73",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_create_object (ecma_object_t *prototype_object_p, /**< pointer to prototybe of the object (or NULL) */                     size_t ext_object_size, /**< size of extended objects */                     ecma_object_type_t type) /**< object type */",
        "snippet": "ecma_object_t *\necma_create_object (ecma_object_t *prototype_object_p, /**< pointer to prototybe of the object (or NULL) */\n                    size_t ext_object_size, /**< size of extended objects */\n                    ecma_object_type_t type) /**< object type */\n{\n  ecma_object_t *new_object_p;\n\n  if (ext_object_size > 0)\n  {\n    new_object_p = (ecma_object_t *) ecma_alloc_extended_object (ext_object_size);\n  }\n  else\n  {\n    new_object_p = ecma_alloc_object ();\n  }\n\n  new_object_p->type_flags_refs = (uint16_t) (type | ECMA_OBJECT_FLAG_EXTENSIBLE);\n\n  ecma_init_gc_info (new_object_p);\n\n  new_object_p->u1.property_list_cp = JMEM_CP_NULL;\n\n  ECMA_SET_POINTER (new_object_p->u2.prototype_cp, prototype_object_p);\n\n  return new_object_p;\n}",
        "begin_line": 73,
        "end_line": 98,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_create_object_lex_env#137",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_create_object_lex_env (ecma_object_t *outer_lexical_environment_p, /**< outer lexical environment */                             ecma_object_t *binding_obj_p, /**< binding object */                             ecma_lexical_environment_type_t type) /**< type of the new lexical environment */",
        "snippet": "ecma_object_t *\necma_create_object_lex_env (ecma_object_t *outer_lexical_environment_p, /**< outer lexical environment */\n                            ecma_object_t *binding_obj_p, /**< binding object */\n                            ecma_lexical_environment_type_t type) /**< type of the new lexical environment */\n{\n#if ENABLED (JERRY_ES2015)\n  JERRY_ASSERT (type == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND\n                || type == ECMA_LEXICAL_ENVIRONMENT_HOME_OBJECT_BOUND);\n#else /* !ENABLED (JERRY_ES2015) */\n  JERRY_ASSERT (type == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n#endif /* ENABLED (JERRY_ES2015) */\n\n  JERRY_ASSERT (binding_obj_p != NULL\n                && !ecma_is_lexical_environment (binding_obj_p));\n\n  ecma_object_t *new_lexical_environment_p = ecma_alloc_object ();\n\n  new_lexical_environment_p->type_flags_refs = (uint16_t) (ECMA_OBJECT_FLAG_BUILT_IN_OR_LEXICAL_ENV | type);\n\n  ecma_init_gc_info (new_lexical_environment_p);\n\n  ECMA_SET_NON_NULL_POINTER (new_lexical_environment_p->u1.bound_object_cp,\n                             binding_obj_p);\n\n  ECMA_SET_POINTER (new_lexical_environment_p->u2.outer_reference_cp, outer_lexical_environment_p);\n\n  return new_lexical_environment_p;\n}",
        "begin_line": 137,
        "end_line": 164,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_create_property#375",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_create_property (ecma_object_t *object_p, /**< the object */                       ecma_string_t *name_p, /**< property name */                       uint8_t type_and_flags, /**< type and flags, see ecma_property_info_t */                       ecma_property_value_t value, /**< property value */                       ecma_property_t **out_prop_p) /**< [out] the property is also returned                                                      *         if this field is non-NULL */",
        "snippet": "static ecma_property_value_t *\necma_create_property (ecma_object_t *object_p, /**< the object */\n                      ecma_string_t *name_p, /**< property name */\n                      uint8_t type_and_flags, /**< type and flags, see ecma_property_info_t */\n                      ecma_property_value_t value, /**< property value */\n                      ecma_property_t **out_prop_p) /**< [out] the property is also returned\n                                                     *         if this field is non-NULL */\n{\n  JERRY_ASSERT (ECMA_PROPERTY_PAIR_ITEM_COUNT == 2);\n  JERRY_ASSERT (name_p != NULL);\n  JERRY_ASSERT (object_p != NULL);\n\n  jmem_cpointer_t *property_list_head_p = &object_p->u1.property_list_cp;\n\n  if (*property_list_head_p != ECMA_NULL_POINTER)\n  {\n    /* If the first entry is free (deleted), it is reused. */\n    ecma_property_header_t *first_property_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,\n                                                                          *property_list_head_p);\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n    bool has_hashmap = false;\n\n    if (first_property_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n    {\n      property_list_head_p = &first_property_p->next_property_cp;\n      first_property_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,\n                                                    *property_list_head_p);\n      has_hashmap = true;\n    }\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (first_property_p));\n\n    if (first_property_p->types[0] == ECMA_PROPERTY_TYPE_DELETED)\n    {\n      ecma_property_pair_t *first_property_pair_p = (ecma_property_pair_t *) first_property_p;\n\n      ecma_property_t name_type;\n      first_property_pair_p->names_cp[0] = ecma_string_to_property_name (name_p,\n                                                                         &name_type);\n      first_property_p->types[0] = (ecma_property_t) (type_and_flags | name_type);\n\n      ecma_property_t *property_p = first_property_p->types + 0;\n\n      JERRY_ASSERT (ECMA_PROPERTY_VALUE_PTR (property_p) == first_property_pair_p->values + 0);\n\n      if (out_prop_p != NULL)\n      {\n        *out_prop_p = property_p;\n      }\n\n      first_property_pair_p->values[0] = value;\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n      /* The property must be fully initialized before ecma_property_hashmap_insert\n       * is called, because the insert operation may reallocate the hashmap, and\n       * that triggers garbage collection which scans all properties of all objects.\n       * A not fully initialized but queued property may cause a crash. */\n\n      if (has_hashmap)\n      {\n        ecma_property_hashmap_insert (object_p,\n                                      name_p,\n                                      first_property_pair_p,\n                                      0);\n      }\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n      return first_property_pair_p->values + 0;\n    }\n  }\n\n  /* Otherwise we create a new property pair and use its second value. */\n  ecma_property_pair_t *first_property_pair_p = ecma_alloc_property_pair ();\n\n  /* Need to query property_list_head_p again and recheck the existennce\n   * of property hasmap, because ecma_alloc_property_pair may delete them. */\n  property_list_head_p = &object_p->u1.property_list_cp;\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n  bool has_hashmap = false;\n\n  if (*property_list_head_p != ECMA_NULL_POINTER)\n  {\n    ecma_property_header_t *first_property_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,\n                                                                          *property_list_head_p);\n\n    if (first_property_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n    {\n      property_list_head_p = &first_property_p->next_property_cp;\n      has_hashmap = true;\n    }\n  }\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n  /* Just copy the previous value (no need to decompress, compress). */\n  first_property_pair_p->header.next_property_cp = *property_list_head_p;\n  first_property_pair_p->header.types[0] = ECMA_PROPERTY_TYPE_DELETED;\n  first_property_pair_p->names_cp[0] = LIT_INTERNAL_MAGIC_STRING_DELETED;\n\n  ecma_property_t name_type;\n  first_property_pair_p->names_cp[1] = ecma_string_to_property_name (name_p,\n                                                                     &name_type);\n\n  first_property_pair_p->header.types[1] = (ecma_property_t) (type_and_flags | name_type);\n\n  ECMA_SET_NON_NULL_POINTER (*property_list_head_p, &first_property_pair_p->header);\n\n  ecma_property_t *property_p = first_property_pair_p->header.types + 1;\n\n  JERRY_ASSERT (ECMA_PROPERTY_VALUE_PTR (property_p) == first_property_pair_p->values + 1);\n\n  if (out_prop_p != NULL)\n  {\n    *out_prop_p = property_p;\n  }\n\n  first_property_pair_p->values[1] = value;\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n  /* See the comment before the other ecma_property_hashmap_insert above. */\n\n  if (has_hashmap)\n  {\n    ecma_property_hashmap_insert (object_p,\n                                  name_p,\n                                  first_property_pair_p,\n                                  1);\n  }\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n  return first_property_pair_p->values + 1;\n}",
        "begin_line": 375,
        "end_line": 507,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_find_named_property#579",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_find_named_property (ecma_object_t *obj_p, /**< object to find property in */                           ecma_string_t *name_p) /**< property's name */",
        "snippet": "ecma_property_t *\necma_find_named_property (ecma_object_t *obj_p, /**< object to find property in */\n                          ecma_string_t *name_p) /**< property's name */\n{\n  JERRY_ASSERT (obj_p != NULL);\n  JERRY_ASSERT (name_p != NULL);\n  JERRY_ASSERT (ecma_is_lexical_environment (obj_p)\n                || !ecma_op_object_is_fast_array (obj_p));\n\n  ecma_property_t *property_p = NULL;\n\n#if ENABLED (JERRY_LCACHE)\n  property_p = ecma_lcache_lookup (obj_p, name_p);\n  if (property_p != NULL)\n  {\n    return property_p;\n  }\n#endif /* ENABLED (JERRY_LCACHE) */\n\n  jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp;\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n  if (prop_iter_cp != JMEM_CP_NULL)\n  {\n    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,\n                                                                     prop_iter_cp);\n    if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n    {\n      jmem_cpointer_t property_real_name_cp;\n      property_p = ecma_property_hashmap_find ((ecma_property_hashmap_t *) prop_iter_p,\n                                               name_p,\n                                               &property_real_name_cp);\n#if ENABLED (JERRY_LCACHE)\n      if (property_p != NULL\n          && !ecma_is_property_lcached (property_p))\n      {\n        ecma_lcache_insert (obj_p, property_real_name_cp, property_p);\n      }\n#endif /* ENABLED (JERRY_LCACHE) */\n      return property_p;\n    }\n  }\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n  uint32_t steps = 0;\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n  jmem_cpointer_t property_name_cp = ECMA_NULL_POINTER;\n\n  if (ECMA_IS_DIRECT_STRING (name_p))\n  {\n    ecma_property_t prop_name_type = (ecma_property_t) ECMA_GET_DIRECT_STRING_TYPE (name_p);\n    property_name_cp = (jmem_cpointer_t) ECMA_GET_DIRECT_STRING_VALUE (name_p);\n\n    JERRY_ASSERT (prop_name_type > 0);\n\n    while (prop_iter_cp != JMEM_CP_NULL)\n    {\n      ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,\n                                                                       prop_iter_cp);\n\n      JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n      ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n      if (prop_pair_p->names_cp[0] == property_name_cp\n          && ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[0]) == prop_name_type)\n      {\n        JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (prop_iter_p->types[0]));\n\n        property_p = prop_iter_p->types + 0;\n        break;\n      }\n\n      if (prop_pair_p->names_cp[1] == property_name_cp\n          && ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[1]) == prop_name_type)\n      {\n        JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (prop_iter_p->types[1]));\n\n        property_p = prop_iter_p->types + 1;\n        break;\n      }\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n      steps++;\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n      prop_iter_cp = prop_iter_p->next_property_cp;\n    }\n  }\n  else\n  {\n    while (prop_iter_cp != JMEM_CP_NULL)\n    {\n      ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,\n                                                                       prop_iter_cp);\n\n      JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n      ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n      if (ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[0]) == ECMA_DIRECT_STRING_PTR)\n      {\n        property_name_cp = prop_pair_p->names_cp[0];\n        ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, property_name_cp);\n\n        if (ecma_compare_ecma_non_direct_strings (name_p, prop_name_p))\n        {\n          property_p = prop_iter_p->types + 0;\n          break;\n        }\n      }\n\n      if (ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[1]) == ECMA_DIRECT_STRING_PTR)\n      {\n        property_name_cp = prop_pair_p->names_cp[1];\n        ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, property_name_cp);\n\n        if (ecma_compare_ecma_non_direct_strings (name_p, prop_name_p))\n        {\n          property_p = prop_iter_p->types + 1;\n          break;\n        }\n      }\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n      steps++;\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n      prop_iter_cp = prop_iter_p->next_property_cp;\n    }\n  }\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n  if (steps >= (ECMA_PROPERTY_HASMAP_MINIMUM_SIZE / 2))\n  {\n    ecma_property_hashmap_create (obj_p);\n  }\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n#if ENABLED (JERRY_LCACHE)\n  if (property_p != NULL\n      && !ecma_is_property_lcached (property_p))\n  {\n    ecma_lcache_insert (obj_p, property_name_cp, property_p);\n  }\n#endif /* ENABLED (JERRY_LCACHE) */\n\n  return property_p;\n}",
        "begin_line": 579,
        "end_line": 726,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_free_property#757",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_free_property (ecma_object_t *object_p, /**< object the property belongs to */                     jmem_cpointer_t name_cp, /**< name of the property or ECMA_NULL_POINTER */                     ecma_property_t *property_p) /**< property */",
        "snippet": "void\necma_free_property (ecma_object_t *object_p, /**< object the property belongs to */\n                    jmem_cpointer_t name_cp, /**< name of the property or ECMA_NULL_POINTER */\n                    ecma_property_t *property_p) /**< property */\n{\n  JERRY_ASSERT (object_p != NULL && property_p != NULL);\n\n  switch (ECMA_PROPERTY_GET_TYPE (*property_p))\n  {\n    case ECMA_PROPERTY_TYPE_NAMEDDATA:\n    {\n      ecma_free_value_if_not_object (ECMA_PROPERTY_VALUE_PTR (property_p)->value);\n      break;\n    }\n    case ECMA_PROPERTY_TYPE_NAMEDACCESSOR:\n    {\n#if ENABLED (JERRY_CPOINTER_32_BIT)\n      ecma_getter_setter_pointers_t *getter_setter_pair_p;\n      getter_setter_pair_p = ECMA_GET_NON_NULL_POINTER (ecma_getter_setter_pointers_t,\n                                                        ECMA_PROPERTY_VALUE_PTR (property_p)->getter_setter_pair_cp);\n      jmem_pools_free (getter_setter_pair_p, sizeof (ecma_getter_setter_pointers_t));\n#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */\n      break;\n    }\n    default:\n    {\n      JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_INTERNAL);\n\n      /* Must be a native pointer. */\n      JERRY_ASSERT (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_MAGIC\n                    && name_cp >= LIT_FIRST_INTERNAL_MAGIC_STRING);\n      break;\n    }\n  }\n\n#if ENABLED (JERRY_LCACHE)\n  if (ecma_is_property_lcached (property_p))\n  {\n    ecma_lcache_invalidate (object_p, name_cp, property_p);\n  }\n#endif /* ENABLED (JERRY_LCACHE) */\n\n  if (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_PTR)\n  {\n    ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, name_cp);\n    ecma_deref_ecma_string (prop_name_p);\n  }\n}",
        "begin_line": 757,
        "end_line": 804,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_get_lex_env_binding_object#284",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_get_lex_env_binding_object (const ecma_object_t *object_p) /**< object-bound lexical environment */",
        "snippet": "inline ecma_object_t *JERRY_ATTR_PURE\necma_get_lex_env_binding_object (const ecma_object_t *object_p) /**< object-bound lexical environment */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (ecma_is_lexical_environment (object_p));\n#if ENABLED (JERRY_ES2015)\n  JERRY_ASSERT (ecma_get_lex_env_type (object_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND\n                || ecma_get_lex_env_type (object_p) == ECMA_LEXICAL_ENVIRONMENT_HOME_OBJECT_BOUND);\n#else /* !ENABLED (JERRY_ES2015) */\n  JERRY_ASSERT (ecma_get_lex_env_type (object_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n#endif /* ENABLED (JERRY_ES2015) */\n\n  return ECMA_GET_NON_NULL_POINTER (ecma_object_t, object_p->u1.bound_object_cp);\n}",
        "begin_line": 284,
        "end_line": 297,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_get_lex_env_type#270",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_get_lex_env_type (const ecma_object_t *object_p) /**< lexical environment */",
        "snippet": "inline ecma_lexical_environment_type_t JERRY_ATTR_PURE\necma_get_lex_env_type (const ecma_object_t *object_p) /**< lexical environment */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (ecma_is_lexical_environment (object_p));\n\n  return (ecma_lexical_environment_type_t) (object_p->type_flags_refs & ECMA_OBJECT_TYPE_MASK);\n}",
        "begin_line": 270,
        "end_line": 277,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_get_named_accessor_property#974",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_get_named_accessor_property (const ecma_property_value_t *prop_value_p) /**< property value reference */",
        "snippet": "ecma_getter_setter_pointers_t *\necma_get_named_accessor_property (const ecma_property_value_t *prop_value_p) /**< property value reference */\n{\n#if ENABLED (JERRY_CPOINTER_32_BIT)\n  return ECMA_GET_NON_NULL_POINTER (ecma_getter_setter_pointers_t, prop_value_p->getter_setter_pair_cp);\n#else /* !ENABLED (JERRY_CPOINTER_32_BIT) */\n  return (ecma_getter_setter_pointers_t *) &prop_value_p->getter_setter_pair;\n#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */\n}",
        "begin_line": 974,
        "end_line": 982,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_get_object_is_builtin#214",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_get_object_is_builtin (const ecma_object_t *object_p) /**< object */",
        "snippet": "inline bool JERRY_ATTR_PURE\necma_get_object_is_builtin (const ecma_object_t *object_p) /**< object */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (!ecma_is_lexical_environment (object_p));\n\n  return (object_p->type_flags_refs & ECMA_OBJECT_FLAG_BUILT_IN_OR_LEXICAL_ENV) != 0;\n}",
        "begin_line": 214,
        "end_line": 221,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_get_object_type#199",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_get_object_type (const ecma_object_t *object_p) /**< object */",
        "snippet": "inline ecma_object_type_t JERRY_ATTR_PURE\necma_get_object_type (const ecma_object_t *object_p) /**< object */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (!ecma_is_lexical_environment (object_p));\n\n  return (ecma_object_type_t) (object_p->type_flags_refs & ECMA_OBJECT_TYPE_MASK);\n}",
        "begin_line": 199,
        "end_line": 206,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_is_lexical_environment#172",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_is_lexical_environment (const ecma_object_t *object_p) /**< object or lexical environment */",
        "snippet": "inline bool JERRY_ATTR_PURE\necma_is_lexical_environment (const ecma_object_t *object_p) /**< object or lexical environment */\n{\n  JERRY_ASSERT (object_p != NULL);\n\n  uint32_t full_type = object_p->type_flags_refs & (ECMA_OBJECT_FLAG_BUILT_IN_OR_LEXICAL_ENV | ECMA_OBJECT_TYPE_MASK);\n\n  return full_type >= (ECMA_OBJECT_FLAG_BUILT_IN_OR_LEXICAL_ENV | ECMA_LEXICAL_ENVIRONMENT_TYPE_START);\n}",
        "begin_line": 172,
        "end_line": 180,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_is_property_lcached#1137",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_is_property_lcached (ecma_property_t *property_p) /**< property */",
        "snippet": "inline bool JERRY_ATTR_ALWAYS_INLINE\necma_is_property_lcached (ecma_property_t *property_p) /**< property */\n{\n  JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA\n                || ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR\n                || ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_INTERNAL);\n\n  return (*property_p & ECMA_PROPERTY_FLAG_LCACHED) != 0;\n}",
        "begin_line": 1137,
        "end_line": 1145,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_is_property_writable#1030",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_is_property_writable (ecma_property_t property) /**< property */",
        "snippet": "inline bool JERRY_ATTR_ALWAYS_INLINE\necma_is_property_writable (ecma_property_t property) /**< property */\n{\n  JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (property) == ECMA_PROPERTY_TYPE_NAMEDDATA\n                || ECMA_PROPERTY_GET_TYPE (property) == ECMA_PROPERTY_TYPE_VIRTUAL);\n\n  return (property & ECMA_PROPERTY_FLAG_WRITABLE) != 0;\n}",
        "begin_line": 1030,
        "end_line": 1037,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_make_empty_property_descriptor#1176",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_make_empty_property_descriptor (void)",
        "snippet": "ecma_property_descriptor_t\necma_make_empty_property_descriptor (void)\n{\n  ecma_property_descriptor_t prop_desc;\n\n  prop_desc.flags = 0;\n  prop_desc.value = ECMA_VALUE_UNDEFINED;\n  prop_desc.get_p = NULL;\n  prop_desc.set_p = NULL;\n\n  return prop_desc;\n}",
        "begin_line": 1176,
        "end_line": 1187,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_named_data_property_assign_value#959",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_named_data_property_assign_value (ecma_object_t *obj_p, /**< object */                                        ecma_property_value_t *prop_value_p, /**< property value reference */                                        ecma_value_t value) /**< value to assign */",
        "snippet": "inline void JERRY_ATTR_ALWAYS_INLINE\necma_named_data_property_assign_value (ecma_object_t *obj_p, /**< object */\n                                       ecma_property_value_t *prop_value_p, /**< property value reference */\n                                       ecma_value_t value) /**< value to assign */\n{\n  ecma_assert_object_contains_the_property (obj_p, prop_value_p, ECMA_PROPERTY_TYPE_NAMEDDATA);\n\n  ecma_value_assign_value (&prop_value_p->value, value);\n}",
        "begin_line": 959,
        "end_line": 967,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_op_ordinary_object_set_extensible#185",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_op_ordinary_object_set_extensible (ecma_object_t *object_p) /**< object */",
        "snippet": "inline void\necma_op_ordinary_object_set_extensible (ecma_object_t *object_p) /**< object */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (!ecma_is_lexical_environment (object_p));\n\n  object_p->type_flags_refs = (uint16_t) (object_p->type_flags_refs | ECMA_OBJECT_FLAG_EXTENSIBLE);\n}",
        "begin_line": 185,
        "end_line": 192,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_set_object_is_builtin#226",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_set_object_is_builtin (ecma_object_t *object_p) /**< object */",
        "snippet": "inline void\necma_set_object_is_builtin (ecma_object_t *object_p) /**< object */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (!(object_p->type_flags_refs & ECMA_OBJECT_FLAG_BUILT_IN_OR_LEXICAL_ENV));\n  JERRY_ASSERT ((object_p->type_flags_refs & ECMA_OBJECT_TYPE_MASK) < ECMA_LEXICAL_ENVIRONMENT_TYPE_START);\n\n  object_p->type_flags_refs = (uint16_t) (object_p->type_flags_refs | ECMA_OBJECT_FLAG_BUILT_IN_OR_LEXICAL_ENV);\n}",
        "begin_line": 226,
        "end_line": 234,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_set_property_lcached#1150",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_set_property_lcached (ecma_property_t *property_p, /**< property */                            bool is_lcached) /**< new value for lcached flag */",
        "snippet": "inline void JERRY_ATTR_ALWAYS_INLINE\necma_set_property_lcached (ecma_property_t *property_p, /**< property */\n                           bool is_lcached) /**< new value for lcached flag */\n{\n  JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA\n                || ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR\n                || ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_INTERNAL);\n\n  if (is_lcached)\n  {\n    *property_p = (uint8_t) (*property_p | ECMA_PROPERTY_FLAG_LCACHED);\n  }\n  else\n  {\n    *property_p = (uint8_t) (*property_p & ~ECMA_PROPERTY_FLAG_LCACHED);\n  }\n}",
        "begin_line": 1150,
        "end_line": 1166,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-init-finalize.ecma_init#40",
        "src_path": "jerry-core/ecma/base/ecma-init-finalize.c",
        "class_name": "jerry-core.ecma.base.ecma-init-finalize",
        "signature": "jerry-core.ecma.base.ecma-init-finalize.ecma_init (void)",
        "snippet": "void\necma_init (void)\n{\n#if (JERRY_GC_MARK_LIMIT != 0)\n  JERRY_CONTEXT (ecma_gc_mark_recursion_limit) = JERRY_GC_MARK_LIMIT;\n#endif /* (JERRY_GC_MARK_LIMIT != 0) */\n\n  ecma_init_global_environment ();\n\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n  JERRY_CONTEXT (ecma_prop_hashmap_alloc_state) = ECMA_PROP_HASHMAP_ALLOC_ON;\n  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_HIGH_PRESSURE_GC;\n#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n#if (JERRY_STACK_LIMIT != 0)\n  volatile int sp;\n  JERRY_CONTEXT (stack_base) = (uintptr_t) &sp;\n#endif /* (JERRY_STACK_LIMIT != 0) */\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROMISE)\n  ecma_job_queue_init ();\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */\n\n#if ENABLED (JERRY_ES2015)\n  JERRY_CONTEXT (current_new_target) = NULL;\n  JERRY_CONTEXT (current_function_obj_p) = NULL;\n#endif /* ENABLED (JERRY_ES2015) */\n}",
        "begin_line": 40,
        "end_line": 67,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-lcache.ecma_lcache_insert#87",
        "src_path": "jerry-core/ecma/base/ecma-lcache.c",
        "class_name": "jerry-core.ecma.base.ecma-lcache",
        "signature": "jerry-core.ecma.base.ecma-lcache.ecma_lcache_insert (const ecma_object_t *object_p, /**< object */                     const jmem_cpointer_t name_cp, /**< property name */                     ecma_property_t *prop_p) /**< property */",
        "snippet": "void\necma_lcache_insert (const ecma_object_t *object_p, /**< object */\n                    const jmem_cpointer_t name_cp, /**< property name */\n                    ecma_property_t *prop_p) /**< property */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (prop_p != NULL && !ecma_is_property_lcached (prop_p));\n  JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*prop_p) == ECMA_PROPERTY_TYPE_NAMEDDATA\n                || ECMA_PROPERTY_GET_TYPE (*prop_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR\n                || ECMA_PROPERTY_GET_TYPE (*prop_p) == ECMA_PROPERTY_TYPE_INTERNAL);\n\n  jmem_cpointer_t object_cp;\n\n  ECMA_SET_NON_NULL_POINTER (object_cp, object_p);\n\n  size_t row_index = ecma_lcache_row_index (object_cp, name_cp);\n  ecma_lcache_hash_entry_t *entry_p = JERRY_CONTEXT (lcache) [row_index];\n  ecma_lcache_hash_entry_t *entry_end_p = entry_p + ECMA_LCACHE_HASH_ROW_LENGTH;\n\n  do\n  {\n    if (entry_p->id == 0)\n    {\n      goto insert;\n    }\n\n    entry_p++;\n  }\n  while (entry_p < entry_end_p);\n\n  /* Invalidate the last entry. */\n  ecma_lcache_invalidate_entry (--entry_p);\n\n  /* Shift other entries towards the end. */\n  for (uint32_t i = 0; i < ECMA_LCACHE_HASH_ROW_LENGTH - 1; i++)\n  {\n    entry_p->id = entry_p[-1].id;\n    entry_p->prop_p = entry_p[-1].prop_p;\n    entry_p--;\n  }\n\ninsert:\n  entry_p->prop_p = prop_p;\n  entry_p->id = ECMA_LCACHE_CREATE_ID (object_cp, name_cp);\n\n  ecma_set_property_lcached (entry_p->prop_p, true);\n}",
        "begin_line": 87,
        "end_line": 133,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-lcache.ecma_lcache_invalidate#187",
        "src_path": "jerry-core/ecma/base/ecma-lcache.c",
        "class_name": "jerry-core.ecma.base.ecma-lcache",
        "signature": "jerry-core.ecma.base.ecma-lcache.ecma_lcache_invalidate (const ecma_object_t *object_p, /**< object */                         const jmem_cpointer_t name_cp, /**< property name */                         ecma_property_t *prop_p) /**< property */",
        "snippet": "void\necma_lcache_invalidate (const ecma_object_t *object_p, /**< object */\n                        const jmem_cpointer_t name_cp, /**< property name */\n                        ecma_property_t *prop_p) /**< property */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (prop_p != NULL && ecma_is_property_lcached (prop_p));\n  JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*prop_p) == ECMA_PROPERTY_TYPE_NAMEDDATA\n                || ECMA_PROPERTY_GET_TYPE (*prop_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR\n                || ECMA_PROPERTY_GET_TYPE (*prop_p) == ECMA_PROPERTY_TYPE_INTERNAL);\n\n  jmem_cpointer_t object_cp;\n  ECMA_SET_NON_NULL_POINTER (object_cp, object_p);\n\n  size_t row_index = ecma_lcache_row_index (object_cp, name_cp);\n  ecma_lcache_hash_entry_t *entry_p = JERRY_CONTEXT (lcache) [row_index];\n\n  while (true)\n  {\n    /* The property must be present. */\n    JERRY_ASSERT (entry_p - JERRY_CONTEXT (lcache) [row_index] < ECMA_LCACHE_HASH_ROW_LENGTH);\n\n    if (entry_p->id != 0 && entry_p->prop_p == prop_p)\n    {\n      JERRY_ASSERT (entry_p->id == ECMA_LCACHE_CREATE_ID (object_cp, name_cp));\n\n      ecma_lcache_invalidate_entry (entry_p);\n      return;\n    }\n    entry_p++;\n  }\n}",
        "begin_line": 187,
        "end_line": 218,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-lcache.ecma_lcache_invalidate_entry#59",
        "src_path": "jerry-core/ecma/base/ecma-lcache.c",
        "class_name": "jerry-core.ecma.base.ecma-lcache",
        "signature": "jerry-core.ecma.base.ecma-lcache.ecma_lcache_invalidate_entry (ecma_lcache_hash_entry_t *entry_p) /**< entry to invalidate */",
        "snippet": "static inline void JERRY_ATTR_ALWAYS_INLINE\necma_lcache_invalidate_entry (ecma_lcache_hash_entry_t *entry_p) /**< entry to invalidate */\n{\n  JERRY_ASSERT (entry_p != NULL);\n  JERRY_ASSERT (entry_p->id != 0);\n  JERRY_ASSERT (entry_p->prop_p != NULL);\n\n  entry_p->id = 0;\n  ecma_set_property_lcached (entry_p->prop_p, false);\n}",
        "begin_line": 59,
        "end_line": 68,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-lcache.ecma_lcache_lookup#141",
        "src_path": "jerry-core/ecma/base/ecma-lcache.c",
        "class_name": "jerry-core.ecma.base.ecma-lcache",
        "signature": "jerry-core.ecma.base.ecma-lcache.ecma_lcache_lookup (const ecma_object_t *object_p, /**< object */                     const ecma_string_t *prop_name_p) /**< property's name */",
        "snippet": "inline ecma_property_t * JERRY_ATTR_ALWAYS_INLINE\necma_lcache_lookup (const ecma_object_t *object_p, /**< object */\n                    const ecma_string_t *prop_name_p) /**< property's name */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (prop_name_p != NULL);\n\n  jmem_cpointer_t object_cp;\n  ECMA_SET_NON_NULL_POINTER (object_cp, object_p);\n\n  ecma_property_t prop_name_type = ECMA_DIRECT_STRING_PTR;\n  jmem_cpointer_t prop_name_cp;\n\n  if (JERRY_UNLIKELY (ECMA_IS_DIRECT_STRING (prop_name_p)))\n  {\n    prop_name_type = (ecma_property_t) ECMA_GET_DIRECT_STRING_TYPE (prop_name_p);\n    prop_name_cp = (jmem_cpointer_t) ECMA_GET_DIRECT_STRING_VALUE (prop_name_p);\n  }\n  else\n  {\n    ECMA_SET_NON_NULL_POINTER (prop_name_cp, prop_name_p);\n  }\n\n  size_t row_index = ecma_lcache_row_index (object_cp, prop_name_cp);\n\n  ecma_lcache_hash_entry_t *entry_p = JERRY_CONTEXT (lcache) [row_index];\n  ecma_lcache_hash_entry_t *entry_end_p = entry_p + ECMA_LCACHE_HASH_ROW_LENGTH;\n  ecma_lcache_hash_entry_id_t id = ECMA_LCACHE_CREATE_ID (object_cp, prop_name_cp);\n\n  do\n  {\n    if (entry_p->id == id && JERRY_LIKELY (ECMA_PROPERTY_GET_NAME_TYPE (*entry_p->prop_p) == prop_name_type))\n    {\n      JERRY_ASSERT (entry_p->prop_p != NULL && ecma_is_property_lcached (entry_p->prop_p));\n      return entry_p->prop_p;\n    }\n    entry_p++;\n  }\n  while (entry_p < entry_end_p);\n\n  return NULL;\n}",
        "begin_line": 141,
        "end_line": 182,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-lcache.ecma_lcache_row_index#75",
        "src_path": "jerry-core/ecma/base/ecma-lcache.c",
        "class_name": "jerry-core.ecma.base.ecma-lcache",
        "signature": "jerry-core.ecma.base.ecma-lcache.ecma_lcache_row_index (jmem_cpointer_t object_cp, /**< compressed pointer to object */                        jmem_cpointer_t name_cp) /**< compressed pointer to property name */",
        "snippet": "static inline size_t JERRY_ATTR_ALWAYS_INLINE\necma_lcache_row_index (jmem_cpointer_t object_cp, /**< compressed pointer to object */\n                       jmem_cpointer_t name_cp) /**< compressed pointer to property name */\n{\n  /* Randomize the property name with the object pointer using a xor operation,\n   * so properties of different objects with the same name can be cached effectively. */\n  return (size_t) (((name_cp ^ object_cp) & ECMA_LCACHE_HASH_MASK) >> ECMA_LCACHE_HASH_BITSHIFT_INDEX);\n}",
        "begin_line": 75,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-literal-storage.ecma_find_or_create_literal_number#204",
        "src_path": "jerry-core/ecma/base/ecma-literal-storage.c",
        "class_name": "jerry-core.ecma.base.ecma-literal-storage",
        "signature": "jerry-core.ecma.base.ecma-literal-storage.ecma_find_or_create_literal_number (ecma_number_t number_arg) /**< number to be searched */",
        "snippet": "ecma_value_t\necma_find_or_create_literal_number (ecma_number_t number_arg) /**< number to be searched */\n{\n  ecma_value_t num = ecma_make_number_value (number_arg);\n\n  if (ecma_is_value_integer_number (num))\n  {\n    return num;\n  }\n\n  JERRY_ASSERT (ecma_is_value_float_number (num));\n\n  jmem_cpointer_t number_list_cp = JERRY_CONTEXT (number_list_first_cp);\n  jmem_cpointer_t *empty_cpointer_p = NULL;\n\n  while (number_list_cp != JMEM_CP_NULL)\n  {\n    ecma_number_storage_item_t *number_list_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_number_storage_item_t,\n                                                                              number_list_cp);\n\n    for (int i = 0; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)\n    {\n      if (number_list_p->values[i] == JMEM_CP_NULL)\n      {\n        if (empty_cpointer_p == NULL)\n        {\n          empty_cpointer_p = number_list_p->values + i;\n        }\n      }\n      else\n      {\n        ecma_number_t *number_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_number_t,\n                                                                number_list_p->values[i]);\n\n        if (*number_p == number_arg)\n        {\n          ecma_free_value (num);\n          return ecma_make_float_value (number_p);\n        }\n      }\n    }\n\n    number_list_cp = number_list_p->next_cp;\n  }\n\n  ecma_number_t *num_p = ecma_get_pointer_from_float_value (num);\n\n  jmem_cpointer_t result;\n  JMEM_CP_SET_NON_NULL_POINTER (result, num_p);\n\n  if (empty_cpointer_p != NULL)\n  {\n    *empty_cpointer_p = result;\n    return num;\n  }\n\n  ecma_number_storage_item_t *new_item_p;\n  new_item_p = (ecma_number_storage_item_t *) jmem_pools_alloc (sizeof (ecma_number_storage_item_t));\n\n  new_item_p->values[0] = result;\n  for (int i = 1; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)\n  {\n    new_item_p->values[i] = JMEM_CP_NULL;\n  }\n\n  new_item_p->next_cp = JERRY_CONTEXT (number_list_first_cp);\n  JMEM_CP_SET_NON_NULL_POINTER (JERRY_CONTEXT (number_list_first_cp), new_item_p);\n\n  return num;\n}",
        "begin_line": 204,
        "end_line": 273,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-literal-storage.ecma_find_or_create_literal_string#130",
        "src_path": "jerry-core/ecma/base/ecma-literal-storage.c",
        "class_name": "jerry-core.ecma.base.ecma-literal-storage",
        "signature": "jerry-core.ecma.base.ecma-literal-storage.ecma_find_or_create_literal_string (const lit_utf8_byte_t *chars_p, /**< string to be searched */                                     lit_utf8_size_t size) /**< size of the string */",
        "snippet": "ecma_value_t\necma_find_or_create_literal_string (const lit_utf8_byte_t *chars_p, /**< string to be searched */\n                                    lit_utf8_size_t size) /**< size of the string */\n{\n  ecma_string_t *string_p = ecma_new_ecma_string_from_utf8 (chars_p, size);\n\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    return ecma_make_string_value (string_p);\n  }\n\n  jmem_cpointer_t string_list_cp = JERRY_CONTEXT (string_list_first_cp);\n  jmem_cpointer_t *empty_cpointer_p = NULL;\n\n  while (string_list_cp != JMEM_CP_NULL)\n  {\n    ecma_lit_storage_item_t *string_list_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_lit_storage_item_t, string_list_cp);\n\n    for (int i = 0; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)\n    {\n      if (string_list_p->values[i] == JMEM_CP_NULL)\n      {\n        if (empty_cpointer_p == NULL)\n        {\n          empty_cpointer_p = string_list_p->values + i;\n        }\n      }\n      else\n      {\n        ecma_string_t *value_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_string_t,\n                                                               string_list_p->values[i]);\n\n        if (ecma_compare_ecma_strings (string_p, value_p))\n        {\n          /* Return with string if found in the list. */\n          ecma_deref_ecma_string (string_p);\n          return ecma_make_string_value (value_p);\n        }\n      }\n    }\n\n    string_list_cp = string_list_p->next_cp;\n  }\n\n  ECMA_SET_STRING_AS_STATIC (string_p);\n  jmem_cpointer_t result;\n  JMEM_CP_SET_NON_NULL_POINTER (result, string_p);\n\n  if (empty_cpointer_p != NULL)\n  {\n    *empty_cpointer_p = result;\n    return ecma_make_string_value (string_p);\n  }\n\n  ecma_lit_storage_item_t *new_item_p;\n  new_item_p = (ecma_lit_storage_item_t *) jmem_pools_alloc (sizeof (ecma_lit_storage_item_t));\n\n  new_item_p->values[0] = result;\n  for (int i = 1; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)\n  {\n    new_item_p->values[i] = JMEM_CP_NULL;\n  }\n\n  new_item_p->next_cp = JERRY_CONTEXT (string_list_first_cp);\n  JMEM_CP_SET_NON_NULL_POINTER (JERRY_CONTEXT (string_list_first_cp), new_item_p);\n\n  return ecma_make_string_value (string_p);\n}",
        "begin_line": 130,
        "end_line": 197,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-property-hashmap.ecma_property_hashmap_create#72",
        "src_path": "jerry-core/ecma/base/ecma-property-hashmap.c",
        "class_name": "jerry-core.ecma.base.ecma-property-hashmap",
        "signature": "jerry-core.ecma.base.ecma-property-hashmap.ecma_property_hashmap_create (ecma_object_t *object_p) /**< object */",
        "snippet": "void\necma_property_hashmap_create (ecma_object_t *object_p) /**< object */\n{\n  if (JERRY_CONTEXT (ecma_prop_hashmap_alloc_state) != ECMA_PROP_HASHMAP_ALLOC_ON)\n  {\n    return;\n  }\n\n  jmem_cpointer_t prop_iter_cp = object_p->u1.property_list_cp;\n\n  if (prop_iter_cp == JMEM_CP_NULL)\n  {\n    return;\n  }\n\n  uint32_t named_property_count = 0;\n\n  while (prop_iter_cp != JMEM_CP_NULL)\n  {\n    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)\n    {\n      ecma_property_types_t type = ECMA_PROPERTY_GET_TYPE (prop_iter_p->types[i]);\n\n      if (type != ECMA_PROPERTY_TYPE_SPECIAL)\n      {\n        named_property_count++;\n      }\n    }\n    prop_iter_cp = prop_iter_p->next_property_cp;\n  }\n\n  if (named_property_count < (ECMA_PROPERTY_HASMAP_MINIMUM_SIZE / 2))\n  {\n    return;\n  }\n\n  /* The max_property_count must be power of 2. */\n  uint32_t max_property_count = ECMA_PROPERTY_HASMAP_MINIMUM_SIZE;\n\n  /* At least 1/3 items must be NULL. */\n  while (max_property_count < (named_property_count + (named_property_count >> 1)))\n  {\n    max_property_count <<= 1;\n  }\n\n  size_t total_size = ECMA_PROPERTY_HASHMAP_GET_TOTAL_SIZE (max_property_count);\n\n  ecma_property_hashmap_t *hashmap_p = (ecma_property_hashmap_t *) jmem_heap_alloc_block_null_on_error (total_size);\n\n  if (hashmap_p == NULL)\n  {\n    return;\n  }\n\n  memset (hashmap_p, 0, total_size);\n\n  hashmap_p->header.types[0] = ECMA_PROPERTY_TYPE_HASHMAP;\n  hashmap_p->header.next_property_cp = object_p->u1.property_list_cp;\n  hashmap_p->max_property_count = max_property_count;\n  hashmap_p->null_count = max_property_count - named_property_count;\n  hashmap_p->unused_count = max_property_count - named_property_count;\n\n  jmem_cpointer_t *pair_list_p = (jmem_cpointer_t *) (hashmap_p + 1);\n  uint8_t *bits_p = (uint8_t *) (pair_list_p + max_property_count);\n  uint32_t mask = max_property_count - 1;\n\n  prop_iter_cp = object_p->u1.property_list_cp;\n  ECMA_SET_NON_NULL_POINTER (object_p->u1.property_list_cp, hashmap_p);\n\n  while (prop_iter_cp != JMEM_CP_NULL)\n  {\n    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)\n    {\n      if (!ECMA_PROPERTY_IS_NAMED_PROPERTY (prop_iter_p->types[i]))\n      {\n        continue;\n      }\n\n      ecma_property_pair_t *property_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n      uint32_t entry_index = ecma_string_get_property_name_hash (prop_iter_p->types[i],\n                                                                 property_pair_p->names_cp[i]);\n      uint32_t step = ecma_property_hashmap_steps[entry_index & (ECMA_PROPERTY_HASHMAP_NUMBER_OF_STEPS - 1)];\n\n      entry_index &= mask;\n#ifndef JERRY_NDEBUG\n      /* Because max_property_count (power of 2) and step (a prime\n       * number) are relative primes, all entries of the hasmap are\n       * visited exactly once before the start entry index is reached\n       * again. Furthermore because at least one NULL is present in\n       * the hashmap, the while loop must be terminated before the\n       * the starting index is reached again. */\n      uint32_t start_entry_index = entry_index;\n#endif /* !JERRY_NDEBUG */\n\n      while (pair_list_p[entry_index] != ECMA_NULL_POINTER)\n      {\n        entry_index = (entry_index + step) & mask;\n\n#ifndef JERRY_NDEBUG\n        JERRY_ASSERT (entry_index != start_entry_index);\n#endif /* !JERRY_NDEBUG */\n      }\n\n      ECMA_SET_NON_NULL_POINTER (pair_list_p[entry_index], property_pair_p);\n\n      if (i != 0)\n      {\n        ECMA_PROPERTY_HASHMAP_SET_BIT (bits_p, entry_index);\n      }\n    }\n\n    prop_iter_cp = prop_iter_p->next_property_cp;\n  }\n}",
        "begin_line": 72,
        "end_line": 192,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-property-hashmap.ecma_property_hashmap_find#370",
        "src_path": "jerry-core/ecma/base/ecma-property-hashmap.c",
        "class_name": "jerry-core.ecma.base.ecma-property-hashmap",
        "signature": "jerry-core.ecma.base.ecma-property-hashmap.ecma_property_hashmap_find (ecma_property_hashmap_t *hashmap_p, /**< hashmap */                             ecma_string_t *name_p, /**< property name */                             jmem_cpointer_t *property_real_name_cp) /**< [out] property real name */",
        "snippet": "ecma_property_t *\necma_property_hashmap_find (ecma_property_hashmap_t *hashmap_p, /**< hashmap */\n                            ecma_string_t *name_p, /**< property name */\n                            jmem_cpointer_t *property_real_name_cp) /**< [out] property real name */\n{\n#ifndef JERRY_NDEBUG\n  /* A sanity check in debug mode: a named property must be present\n   * in both the property hashmap and in the property chain, or missing\n   * from both data collection. The following code checks the property\n   * chain, and sets the property_found variable. */\n  bool property_found = false;\n\n  jmem_cpointer_t prop_iter_cp = hashmap_p->header.next_property_cp;\n\n  while (prop_iter_cp != JMEM_CP_NULL && !property_found)\n  {\n    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)\n    {\n      if (ECMA_PROPERTY_IS_NAMED_PROPERTY (prop_iter_p->types[i]))\n      {\n        if (ecma_string_compare_to_property_name (prop_iter_p->types[i],\n                                                  prop_pair_p->names_cp[i],\n                                                  name_p))\n        {\n          /* Property is found */\n          property_found = true;\n          break;\n        }\n      }\n    }\n\n    prop_iter_cp = prop_iter_p->next_property_cp;\n  }\n#endif /* !JERRY_NDEBUG */\n\n  uint32_t entry_index = ecma_string_hash (name_p);\n  uint32_t step = ecma_property_hashmap_steps[entry_index & (ECMA_PROPERTY_HASHMAP_NUMBER_OF_STEPS - 1)];\n  uint32_t mask = hashmap_p->max_property_count - 1;\n  jmem_cpointer_t *pair_list_p = (jmem_cpointer_t *) (hashmap_p + 1);\n  uint8_t *bits_p = (uint8_t *) (pair_list_p + hashmap_p->max_property_count);\n  entry_index &= mask;\n\n#ifndef JERRY_NDEBUG\n  /* See the comment for this variable in ecma_property_hashmap_create. */\n  uint32_t start_entry_index = entry_index;\n#endif /* !JERRY_NDEBUG */\n\n  if (ECMA_IS_DIRECT_STRING (name_p))\n  {\n    ecma_property_t prop_name_type = (ecma_property_t) ECMA_GET_DIRECT_STRING_TYPE (name_p);\n    jmem_cpointer_t property_name_cp = (jmem_cpointer_t) ECMA_GET_DIRECT_STRING_VALUE (name_p);\n\n    JERRY_ASSERT (prop_name_type > 0);\n\n    while (true)\n    {\n      if (pair_list_p[entry_index] != ECMA_NULL_POINTER)\n      {\n        size_t offset = 0;\n        if (ECMA_PROPERTY_HASHMAP_GET_BIT (bits_p, entry_index))\n        {\n          offset = 1;\n        }\n\n        ecma_property_pair_t *property_pair_p = ECMA_GET_NON_NULL_POINTER (ecma_property_pair_t,\n                                                                           pair_list_p[entry_index]);\n\n        ecma_property_t *property_p = property_pair_p->header.types + offset;\n\n        JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (*property_p));\n\n        if (property_pair_p->names_cp[offset] == property_name_cp\n            && ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == prop_name_type)\n        {\n#ifndef JERRY_NDEBUG\n          JERRY_ASSERT (property_found);\n#endif /* !JERRY_NDEBUG */\n\n          *property_real_name_cp = property_name_cp;\n          return property_p;\n        }\n      }\n      else\n      {\n        if (!ECMA_PROPERTY_HASHMAP_GET_BIT (bits_p, entry_index))\n        {\n#ifndef JERRY_NDEBUG\n          JERRY_ASSERT (!property_found);\n#endif /* !JERRY_NDEBUG */\n\n          return NULL;\n        }\n        /* Otherwise it is a deleted entry. */\n      }\n\n      entry_index = (entry_index + step) & mask;\n\n#ifndef JERRY_NDEBUG\n      JERRY_ASSERT (entry_index != start_entry_index);\n#endif /* !JERRY_NDEBUG */\n    }\n  }\n\n  while (true)\n  {\n    if (pair_list_p[entry_index] != ECMA_NULL_POINTER)\n    {\n      size_t offset = 0;\n      if (ECMA_PROPERTY_HASHMAP_GET_BIT (bits_p, entry_index))\n      {\n        offset = 1;\n      }\n\n      ecma_property_pair_t *property_pair_p = ECMA_GET_NON_NULL_POINTER (ecma_property_pair_t,\n                                                                         pair_list_p[entry_index]);\n\n      ecma_property_t *property_p = property_pair_p->header.types + offset;\n\n      JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (*property_p));\n\n      if (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_PTR)\n      {\n        ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, property_pair_p->names_cp[offset]);\n\n        if (ecma_compare_ecma_non_direct_strings (prop_name_p, name_p))\n        {\n#ifndef JERRY_NDEBUG\n          JERRY_ASSERT (property_found);\n#endif /* !JERRY_NDEBUG */\n\n          *property_real_name_cp = property_pair_p->names_cp[offset];\n          return property_p;\n        }\n      }\n    }\n    else\n    {\n      if (!ECMA_PROPERTY_HASHMAP_GET_BIT (bits_p, entry_index))\n      {\n#ifndef JERRY_NDEBUG\n        JERRY_ASSERT (!property_found);\n#endif /* !JERRY_NDEBUG */\n\n        return NULL;\n      }\n      /* Otherwise it is a deleted entry. */\n    }\n\n    entry_index = (entry_index + step) & mask;\n\n#ifndef JERRY_NDEBUG\n    JERRY_ASSERT (entry_index != start_entry_index);\n#endif /* !JERRY_NDEBUG */\n  }\n}",
        "begin_line": 370,
        "end_line": 529,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-property-hashmap.ecma_property_hashmap_free#198",
        "src_path": "jerry-core/ecma/base/ecma-property-hashmap.c",
        "class_name": "jerry-core.ecma.base.ecma-property-hashmap",
        "signature": "jerry-core.ecma.base.ecma-property-hashmap.ecma_property_hashmap_free (ecma_object_t *object_p) /**< object */",
        "snippet": "void\necma_property_hashmap_free (ecma_object_t *object_p) /**< object */\n{\n  /* Property hash must be exists and must be the first property. */\n  JERRY_ASSERT (object_p->u1.property_list_cp != JMEM_CP_NULL);\n\n  ecma_property_header_t *property_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,\n                                                                  object_p->u1.property_list_cp);\n\n  JERRY_ASSERT (property_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP);\n\n  ecma_property_hashmap_t *hashmap_p = (ecma_property_hashmap_t *) property_p;\n\n  object_p->u1.property_list_cp = property_p->next_property_cp;\n\n  jmem_heap_free_block (hashmap_p,\n                        ECMA_PROPERTY_HASHMAP_GET_TOTAL_SIZE (hashmap_p->max_property_count));\n}",
        "begin_line": 198,
        "end_line": 215,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-property-hashmap.ecma_property_hashmap_insert#220",
        "src_path": "jerry-core/ecma/base/ecma-property-hashmap.c",
        "class_name": "jerry-core.ecma.base.ecma-property-hashmap",
        "signature": "jerry-core.ecma.base.ecma-property-hashmap.ecma_property_hashmap_insert (ecma_object_t *object_p, /**< object */                               ecma_string_t *name_p, /**< name of the property */                               ecma_property_pair_t *property_pair_p, /**< property pair */                               int property_index) /**< property index in the pair (0 or 1) */",
        "snippet": "void\necma_property_hashmap_insert (ecma_object_t *object_p, /**< object */\n                              ecma_string_t *name_p, /**< name of the property */\n                              ecma_property_pair_t *property_pair_p, /**< property pair */\n                              int property_index) /**< property index in the pair (0 or 1) */\n{\n  JERRY_ASSERT (property_pair_p != NULL);\n\n  ecma_property_hashmap_t *hashmap_p = ECMA_GET_NON_NULL_POINTER (ecma_property_hashmap_t,\n                                                                  object_p->u1.property_list_cp);\n\n  JERRY_ASSERT (hashmap_p->header.types[0] == ECMA_PROPERTY_TYPE_HASHMAP);\n\n  /* The NULLs are reduced below 1/8 of the hashmap. */\n  if (hashmap_p->null_count < (hashmap_p->max_property_count >> 3))\n  {\n    ecma_property_hashmap_free (object_p);\n    ecma_property_hashmap_create (object_p);\n    return;\n  }\n\n  JERRY_ASSERT (property_index < ECMA_PROPERTY_PAIR_ITEM_COUNT);\n\n  uint32_t entry_index = ecma_string_hash (name_p);\n  uint32_t step = ecma_property_hashmap_steps[entry_index & (ECMA_PROPERTY_HASHMAP_NUMBER_OF_STEPS - 1)];\n  uint32_t mask = hashmap_p->max_property_count - 1;\n  entry_index &= mask;\n\n#ifndef JERRY_NDEBUG\n  /* See the comment for this variable in ecma_property_hashmap_create. */\n  uint32_t start_entry_index = entry_index;\n#endif /* !JERRY_NDEBUG */\n\n  jmem_cpointer_t *pair_list_p = (jmem_cpointer_t *) (hashmap_p + 1);\n\n  while (pair_list_p[entry_index] != ECMA_NULL_POINTER)\n  {\n    entry_index = (entry_index + step) & mask;\n\n#ifndef JERRY_NDEBUG\n    JERRY_ASSERT (entry_index != start_entry_index);\n#endif /* !JERRY_NDEBUG */\n  }\n\n  ECMA_SET_NON_NULL_POINTER (pair_list_p[entry_index], property_pair_p);\n\n  uint8_t *bits_p = (uint8_t *) (pair_list_p + hashmap_p->max_property_count);\n  bits_p += (entry_index >> 3);\n  mask = (uint32_t) (1 << (entry_index & 0x7));\n\n  if (!(*bits_p & mask))\n  {\n    /* Deleted entries also has ECMA_NULL_POINTER\n     * value, but they are not NULL values. */\n    hashmap_p->null_count--;\n    JERRY_ASSERT (hashmap_p->null_count > 0);\n  }\n\n  hashmap_p->unused_count--;\n  JERRY_ASSERT (hashmap_p->unused_count > 0);\n\n  if (property_index == 0)\n  {\n    *bits_p = (uint8_t) ((*bits_p) & ~mask);\n  }\n  else\n  {\n    *bits_p = (uint8_t) ((*bits_p) | mask);\n  }\n}",
        "begin_line": 220,
        "end_line": 289,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-function-prototype.ecma_builtin_function_prototype_dispatch_routine#385",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-function-prototype.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-function-prototype",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-function-prototype.ecma_builtin_function_prototype_dispatch_routine (uint16_t builtin_routine_id, /**< built-in wide routine                                                                                 *   identifier */                                                   ecma_value_t this_arg, /**< 'this' argument value */                                                   const ecma_value_t arguments_list_p[], /**< list of arguments                                                                                         *   passed to routine */                                                   ecma_length_t arguments_number) /**< length of arguments' list */",
        "snippet": "ecma_value_t\necma_builtin_function_prototype_dispatch_routine (uint16_t builtin_routine_id, /**< built-in wide routine\n                                                                                *   identifier */\n                                                  ecma_value_t this_arg, /**< 'this' argument value */\n                                                  const ecma_value_t arguments_list_p[], /**< list of arguments\n                                                                                        *   passed to routine */\n                                                  ecma_length_t arguments_number) /**< length of arguments' list */\n{\n  if (!ecma_op_is_callable (this_arg))\n  {\n#if ENABLED (JERRY_ES2015)\n    if (JERRY_UNLIKELY (builtin_routine_id == ECMA_FUNCTION_PROTOTYPE_SYMBOL_HAS_INSTANCE))\n    {\n      return ECMA_VALUE_FALSE;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Argument 'this' is not a function.\"));\n  }\n\n  ecma_object_t *func_obj_p = ecma_get_object_from_value (this_arg);\n\n  switch (builtin_routine_id)\n  {\n    case ECMA_FUNCTION_PROTOTYPE_TO_STRING:\n    {\n      return ecma_builtin_function_prototype_object_to_string ();\n    }\n    case ECMA_FUNCTION_PROTOTYPE_APPLY:\n    {\n      return ecma_builtin_function_prototype_object_apply (func_obj_p,\n                                                           arguments_list_p[0],\n                                                           arguments_list_p[1]);\n    }\n    case ECMA_FUNCTION_PROTOTYPE_CALL:\n    {\n      return ecma_builtin_function_prototype_object_call (func_obj_p, arguments_list_p, arguments_number);\n    }\n    case ECMA_FUNCTION_PROTOTYPE_BIND:\n    {\n      return ecma_builtin_function_prototype_object_bind (func_obj_p, arguments_list_p, arguments_number);\n    }\n#if ENABLED (JERRY_ES2015)\n    case ECMA_FUNCTION_PROTOTYPE_SYMBOL_HAS_INSTANCE:\n    {\n      return ecma_op_object_has_instance (func_obj_p, arguments_list_p[0]);\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    default:\n    {\n      JERRY_UNREACHABLE ();\n    }\n  }\n}",
        "begin_line": 385,
        "end_line": 438,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-function-prototype.ecma_builtin_function_prototype_object_to_string#82",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-function-prototype.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-function-prototype",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-function-prototype.ecma_builtin_function_prototype_object_to_string (void)",
        "snippet": "static ecma_value_t\necma_builtin_function_prototype_object_to_string (void)\n{\n  return ecma_make_magic_string_value (LIT_MAGIC_STRING__FUNCTION_TO_STRING);\n}",
        "begin_line": 82,
        "end_line": 86,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-global.ecma_builtin_global_dispatch_routine#777",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-global.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-global",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-global.ecma_builtin_global_dispatch_routine (uint16_t builtin_routine_id, /**< built-in wide routine identifier */                                       ecma_value_t this_arg, /**< 'this' argument value */                                       const ecma_value_t arguments_list_p[], /**< list of arguments                                                                               *   passed to routine */                                       ecma_length_t arguments_number) /**< length of arguments' list */",
        "snippet": "ecma_value_t\necma_builtin_global_dispatch_routine (uint16_t builtin_routine_id, /**< built-in wide routine identifier */\n                                      ecma_value_t this_arg, /**< 'this' argument value */\n                                      const ecma_value_t arguments_list_p[], /**< list of arguments\n                                                                              *   passed to routine */\n                                      ecma_length_t arguments_number) /**< length of arguments' list */\n{\n  JERRY_UNUSED (this_arg);\n  JERRY_UNUSED (arguments_list_p);\n  JERRY_UNUSED (arguments_number);\n\n  ecma_value_t routine_arg_1 = arguments_list_p[0];\n\n  if (builtin_routine_id == ECMA_GLOBAL_EVAL)\n  {\n    return ecma_builtin_global_object_eval (routine_arg_1);\n  }\n\n  if (builtin_routine_id <= ECMA_GLOBAL_IS_FINITE)\n  {\n    ecma_number_t arg_num;\n\n    routine_arg_1 = ecma_get_number (routine_arg_1, &arg_num);\n\n    if (!ecma_is_value_empty (routine_arg_1))\n    {\n      return routine_arg_1;\n    }\n\n    if (builtin_routine_id == ECMA_GLOBAL_IS_NAN)\n    {\n      return ecma_builtin_global_object_is_nan (arg_num);\n    }\n\n    JERRY_ASSERT (builtin_routine_id == ECMA_GLOBAL_IS_FINITE);\n\n    return ecma_builtin_global_object_is_finite (arg_num);\n  }\n\n  ecma_string_t *str_p = ecma_op_to_string (routine_arg_1);\n\n  if (JERRY_UNLIKELY (str_p == NULL))\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_value_t ret_value;\n\n  if (builtin_routine_id <= ECMA_GLOBAL_PARSE_FLOAT)\n  {\n    ECMA_STRING_TO_UTF8_STRING (str_p, string_buff, string_buff_size);\n\n    if (builtin_routine_id == ECMA_GLOBAL_PARSE_INT)\n    {\n      ret_value = ecma_number_parse_int (string_buff,\n                                         string_buff_size,\n                                         arguments_list_p[1]);\n    }\n    else\n    {\n      JERRY_ASSERT (builtin_routine_id == ECMA_GLOBAL_PARSE_FLOAT);\n      ret_value = ecma_number_parse_float (string_buff,\n                                           string_buff_size);\n    }\n\n    ECMA_FINALIZE_UTF8_STRING (string_buff, string_buff_size);\n    ecma_deref_ecma_string (str_p);\n    return ret_value;\n  }\n\n  lit_utf8_size_t input_size = ecma_string_get_size (str_p);\n\n  JMEM_DEFINE_LOCAL_ARRAY (input_start_p,\n                           input_size + 1,\n                           lit_utf8_byte_t);\n\n  ecma_string_to_utf8_bytes (str_p, input_start_p, input_size);\n\n  input_start_p[input_size] = LIT_BYTE_NULL;\n\n  switch (builtin_routine_id)\n  {\n#if ENABLED (JERRY_BUILTIN_ANNEXB)\n    case ECMA_GLOBAL_ESCAPE:\n    {\n      ret_value = ecma_builtin_global_object_escape (input_start_p, input_size);\n      break;\n    }\n    case ECMA_GLOBAL_UNESCAPE:\n    {\n      ret_value = ecma_builtin_global_object_unescape (input_start_p, input_size);\n      break;\n    }\n#endif /* ENABLED (JERRY_BUILTIN_ANNEXB) */\n    case ECMA_GLOBAL_DECODE_URI:\n    case ECMA_GLOBAL_DECODE_URI_COMPONENT:\n    {\n      const uint8_t *uri_set = (builtin_routine_id == ECMA_GLOBAL_DECODE_URI ? unescaped_uri_set\n                                                                             : unescaped_uri_component_set);\n\n      ret_value = ecma_builtin_global_object_decode_uri_helper (input_start_p, input_size, uri_set);\n      break;\n    }\n    default:\n    {\n      JERRY_ASSERT (builtin_routine_id == ECMA_GLOBAL_ENCODE_URI\n                    || builtin_routine_id == ECMA_GLOBAL_ENCODE_URI_COMPONENT);\n\n      const uint8_t *uri_set = (builtin_routine_id == ECMA_GLOBAL_ENCODE_URI ? unescaped_uri_set\n                                                                             : unescaped_uri_component_set);\n\n      ret_value = ecma_builtin_global_object_encode_uri_helper (input_start_p, input_size, uri_set);\n      break;\n    }\n  }\n\n  JMEM_FINALIZE_LOCAL_ARRAY (input_start_p);\n\n  ecma_deref_ecma_string (str_p);\n  return ret_value;\n}",
        "begin_line": 777,
        "end_line": 897,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-global.ecma_builtin_global_object_eval#85",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-global.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-global",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-global.ecma_builtin_global_object_eval (ecma_value_t x) /**< routine's first argument */",
        "snippet": "static ecma_value_t\necma_builtin_global_object_eval (ecma_value_t x) /**< routine's first argument */\n{\n  if (JERRY_UNLIKELY (!ecma_is_value_string (x)))\n  {\n    /* step 1 */\n    return ecma_copy_value (x);\n  }\n\n  uint32_t parse_opts = vm_is_direct_eval_form_call () ? ECMA_PARSE_DIRECT_EVAL : ECMA_PARSE_NO_OPTS;\n\n  /* See also: ECMA-262 v5, 10.1.1 */\n  if (parse_opts && vm_is_strict_mode ())\n  {\n    JERRY_ASSERT (parse_opts & ECMA_PARSE_DIRECT_EVAL);\n    parse_opts |= ECMA_PARSE_STRICT_MODE;\n  }\n\n#if ENABLED (JERRY_ES2015)\n  if (vm_is_direct_eval_form_call ())\n  {\n    parse_opts |= ECMA_GET_LOCAL_PARSE_OPTS ();\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  /* steps 2 to 8 */\n  return ecma_op_eval (ecma_get_string_from_value (x), parse_opts);\n}",
        "begin_line": 85,
        "end_line": 112,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-helpers.ecma_builtin_helper_def_prop#818",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-helpers.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-helpers",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-helpers.ecma_builtin_helper_def_prop (ecma_object_t *obj_p, /**< object */                               ecma_string_t *name_p, /**< name string */                               ecma_value_t value, /**< value */                               uint32_t opts) /**< any combination of ecma_property_flag_t bits                                               *   with the optional ECMA_IS_THROW flag */",
        "snippet": "ecma_value_t\necma_builtin_helper_def_prop (ecma_object_t *obj_p, /**< object */\n                              ecma_string_t *name_p, /**< name string */\n                              ecma_value_t value, /**< value */\n                              uint32_t opts) /**< any combination of ecma_property_flag_t bits\n                                              *   with the optional ECMA_IS_THROW flag */\n{\n  ecma_property_descriptor_t prop_desc;\n\n  prop_desc.flags = (uint16_t) (ECMA_NAME_DATA_PROPERTY_DESCRIPTOR_BITS | opts);\n\n  prop_desc.value = value;\n\n  return ecma_op_object_define_own_property (obj_p,\n                                             name_p,\n                                             &prop_desc);\n}",
        "begin_line": 818,
        "end_line": 834,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-object-prototype.ecma_builtin_object_prototype_dispatch_routine#233",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-object-prototype.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-object-prototype",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-object-prototype.ecma_builtin_object_prototype_dispatch_routine (uint16_t builtin_routine_id, /**< built-in wide routine                                                                               *   identifier */                                                 ecma_value_t this_arg, /**< 'this' argument value */                                                 const ecma_value_t arguments_list_p[], /**< list of arguments                                                                                       *   passed to routine */                                                 ecma_length_t arguments_number) /**< length of arguments' list */",
        "snippet": "ecma_value_t\necma_builtin_object_prototype_dispatch_routine (uint16_t builtin_routine_id, /**< built-in wide routine\n                                                                              *   identifier */\n                                                ecma_value_t this_arg, /**< 'this' argument value */\n                                                const ecma_value_t arguments_list_p[], /**< list of arguments\n                                                                                      *   passed to routine */\n                                                ecma_length_t arguments_number) /**< length of arguments' list */\n{\n  JERRY_UNUSED (arguments_number);\n\n  /* no specialization */\n  if (builtin_routine_id <= ECMA_OBJECT_PROTOTYPE_VALUE_OF)\n  {\n    if (builtin_routine_id == ECMA_OBJECT_PROTOTYPE_TO_STRING)\n    {\n      return ecma_builtin_object_prototype_object_to_string (this_arg);\n    }\n\n    JERRY_ASSERT (builtin_routine_id <= ECMA_OBJECT_PROTOTYPE_VALUE_OF);\n\n    return ecma_builtin_object_prototype_object_value_of (this_arg);\n  }\n\n  if (builtin_routine_id <= ECMA_OBJECT_PROTOTYPE_IS_PROTOTYPE_OF)\n  {\n    if (builtin_routine_id == ECMA_OBJECT_PROTOTYPE_IS_PROTOTYPE_OF)\n    {\n      /* 15.2.4.6.1. */\n      if (!ecma_is_value_object (arguments_list_p[0]))\n      {\n        return ECMA_VALUE_FALSE;\n      }\n    }\n\n    ecma_value_t to_object = ecma_op_to_object (this_arg);\n\n    if (ECMA_IS_VALUE_ERROR (to_object))\n    {\n      return to_object;\n    }\n\n    ecma_object_t *obj_p = ecma_get_object_from_value (to_object);\n\n    ecma_value_t ret_value;\n\n    if (builtin_routine_id == ECMA_OBJECT_PROTOTYPE_IS_PROTOTYPE_OF)\n    {\n      ret_value = ecma_builtin_object_prototype_object_is_prototype_of (obj_p, arguments_list_p[0]);\n    }\n\n#if ENABLED (JERRY_ES2015)\n    else if (builtin_routine_id == ECMA_OBJECT_PROTOTYPE_GET_PROTO)\n    {\n      ret_value = ecma_builtin_object_object_get_prototype_of (obj_p);\n    }\n#endif /* ENABLED (JERRY_ES2015)*/\n\n    else\n    {\n      ret_value = ecma_builtin_object_prototype_object_to_locale_string (obj_p);\n    }\n\n    ecma_deref_object (obj_p);\n\n    return ret_value;\n  }\n\n  JERRY_ASSERT (builtin_routine_id >= ECMA_OBJECT_PROTOTYPE_HAS_OWN_PROPERTY);\n\n#if ENABLED (JERRY_ES2015)\n  if (builtin_routine_id == ECMA_OBJECT_PROTOTYPE_SET_PROTO)\n  {\n    return ecma_builtin_object_object_set_proto (this_arg, arguments_list_p[0]);\n  }\n#endif /* ENABLED (JERRY_ES2015)*/\n\n  ecma_string_t *prop_name_p = ecma_op_to_prop_name (arguments_list_p[0]);\n\n  if (prop_name_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_value_t to_object = ecma_op_to_object (this_arg);\n\n  if (ECMA_IS_VALUE_ERROR (to_object))\n  {\n    ecma_deref_ecma_string (prop_name_p);\n    return to_object;\n  }\n\n  ecma_object_t *obj_p = ecma_get_object_from_value (to_object);\n\n  ecma_value_t ret_value;\n\n  if (builtin_routine_id == ECMA_OBJECT_PROTOTYPE_HAS_OWN_PROPERTY)\n  {\n    ret_value = ecma_builtin_object_prototype_object_has_own_property (obj_p, prop_name_p);\n  }\n  else\n  {\n    ret_value = ecma_builtin_object_prototype_object_property_is_enumerable (obj_p, prop_name_p);\n  }\n\n  ecma_deref_ecma_string (prop_name_p);\n  ecma_deref_object (obj_p);\n\n  return ret_value;\n}",
        "begin_line": 233,
        "end_line": 341,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-object-prototype.ecma_builtin_object_prototype_object_to_locale_string#110",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-object-prototype.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-object-prototype",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-object-prototype.ecma_builtin_object_prototype_object_to_locale_string (ecma_object_t *obj_p) /**< this argument */",
        "snippet": "static ecma_value_t\necma_builtin_object_prototype_object_to_locale_string (ecma_object_t *obj_p) /**< this argument */\n{\n  /* 2. */\n  ecma_value_t to_string_val = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_TO_STRING_UL);\n\n  if (ECMA_IS_VALUE_ERROR (to_string_val))\n  {\n    return to_string_val;\n  }\n\n  /* 3. */\n  if (!ecma_op_is_callable (to_string_val))\n  {\n    ecma_free_value (to_string_val);\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"'toString is missing or not a function.'\"));\n  }\n\n  /* 4. */\n  ecma_object_t *to_string_func_obj_p = ecma_get_object_from_value (to_string_val);\n  ecma_value_t ret_value = ecma_op_function_call (to_string_func_obj_p, ecma_make_object_value (obj_p), NULL, 0);\n\n  ecma_deref_object (to_string_func_obj_p);\n\n  return ret_value;\n}",
        "begin_line": 110,
        "end_line": 135,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_dispatch_call#1126",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_dispatch_call (ecma_object_t *obj_p, /**< built-in object */                             ecma_value_t this_arg_value, /**< 'this' argument value */                             const ecma_value_t *arguments_list_p, /**< arguments list */                             ecma_length_t arguments_list_len) /**< arguments list length */",
        "snippet": "ecma_value_t\necma_builtin_dispatch_call (ecma_object_t *obj_p, /**< built-in object */\n                            ecma_value_t this_arg_value, /**< 'this' argument value */\n                            const ecma_value_t *arguments_list_p, /**< arguments list */\n                            ecma_length_t arguments_list_len) /**< arguments list length */\n{\n  JERRY_ASSERT (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_FUNCTION);\n  JERRY_ASSERT (ecma_get_object_is_builtin (obj_p));\n\n  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;\n\n  if (ecma_builtin_function_is_routine (obj_p))\n  {\n    return ecma_builtin_dispatch_routine (ext_obj_p,\n                                          this_arg_value,\n                                          arguments_list_p,\n                                          arguments_list_len);\n  }\n\n  ecma_builtin_id_t builtin_object_id = ext_obj_p->u.built_in.id;\n  JERRY_ASSERT (builtin_object_id < sizeof (ecma_builtin_call_functions) / sizeof (ecma_builtin_dispatch_call_t));\n  return ecma_builtin_call_functions[builtin_object_id] (arguments_list_p, arguments_list_len);\n}",
        "begin_line": 1126,
        "end_line": 1148,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_dispatch_construct#1155",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_dispatch_construct (ecma_object_t *obj_p, /**< built-in object */                                  ecma_object_t *new_target_p, /**< new target */                                  const ecma_value_t *arguments_list_p, /**< arguments list */                                  ecma_length_t arguments_list_len) /**< arguments list length */",
        "snippet": "ecma_value_t\necma_builtin_dispatch_construct (ecma_object_t *obj_p, /**< built-in object */\n                                 ecma_object_t *new_target_p, /**< new target */\n                                 const ecma_value_t *arguments_list_p, /**< arguments list */\n                                 ecma_length_t arguments_list_len) /**< arguments list length */\n{\n  JERRY_ASSERT (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_FUNCTION);\n  JERRY_ASSERT (ecma_get_object_is_builtin (obj_p));\n\n  if (ecma_builtin_function_is_routine (obj_p))\n  {\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Built-in routines have no constructor.\"));\n  }\n\n  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;\n  ecma_builtin_id_t builtin_object_id = ext_obj_p->u.built_in.id;\n  JERRY_ASSERT (builtin_object_id < sizeof (ecma_builtin_construct_functions) / sizeof (ecma_builtin_dispatch_call_t));\n\n#if ENABLED (JERRY_ES2015)\n  ecma_object_t *old_new_target = JERRY_CONTEXT (current_new_target);\n  JERRY_CONTEXT (current_new_target) = new_target_p;\n#else /* !ENABLED (JERRY_ES2015) */\n  JERRY_UNUSED (new_target_p);\n#endif /* ENABLED (JERRY_ES2015) */\n\n  ecma_value_t ret_value = ecma_builtin_construct_functions[builtin_object_id] (arguments_list_p, arguments_list_len);\n\n#if ENABLED (JERRY_ES2015)\n  JERRY_CONTEXT (current_new_target) = old_new_target;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  return ret_value;\n}",
        "begin_line": 1155,
        "end_line": 1187,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_dispatch_routine#1082",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_dispatch_routine (ecma_extended_object_t *func_obj_p, /**< builtin object */                                ecma_value_t this_arg_value, /**< 'this' argument value */                                const ecma_value_t *arguments_list_p, /**< list of arguments passed to routine */                                ecma_length_t arguments_list_len) /**< length of arguments' list */",
        "snippet": "static ecma_value_t\necma_builtin_dispatch_routine (ecma_extended_object_t *func_obj_p, /**< builtin object */\n                               ecma_value_t this_arg_value, /**< 'this' argument value */\n                               const ecma_value_t *arguments_list_p, /**< list of arguments passed to routine */\n                               ecma_length_t arguments_list_len) /**< length of arguments' list */\n{\n  JERRY_ASSERT (ecma_builtin_function_is_routine ((ecma_object_t *) func_obj_p));\n\n  ecma_value_t padded_arguments_list_p[3] = { ECMA_VALUE_UNDEFINED, ECMA_VALUE_UNDEFINED, ECMA_VALUE_UNDEFINED };\n\n  if (arguments_list_len <= 2)\n  {\n    switch (arguments_list_len)\n    {\n      case 2:\n      {\n        padded_arguments_list_p[1] = arguments_list_p[1];\n        /* FALLTHRU */\n      }\n      case 1:\n      {\n        padded_arguments_list_p[0] = arguments_list_p[0];\n        break;\n      }\n      default:\n      {\n        JERRY_ASSERT (arguments_list_len == 0);\n      }\n    }\n\n    arguments_list_p = padded_arguments_list_p;\n  }\n\n  return ecma_builtin_routines[func_obj_p->u.built_in.id] (func_obj_p->u.built_in.routine_id,\n                                                           this_arg_value,\n                                                           arguments_list_p,\n                                                           arguments_list_len);\n}",
        "begin_line": 1082,
        "end_line": 1119,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_function_is_routine#328",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_function_is_routine (ecma_object_t *func_obj_p) /**< function object */",
        "snippet": "inline bool JERRY_ATTR_ALWAYS_INLINE\necma_builtin_function_is_routine (ecma_object_t *func_obj_p) /**< function object */\n{\n  JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_FUNCTION);\n  JERRY_ASSERT (ecma_get_object_is_builtin (func_obj_p));\n\n  ecma_extended_object_t *ext_func_obj_p = (ecma_extended_object_t *) func_obj_p;\n  return (ext_func_obj_p->u.built_in.routine_id >= ECMA_BUILTIN_ID__COUNT);\n}",
        "begin_line": 328,
        "end_line": 336,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get#293",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get (ecma_builtin_id_t builtin_id) /**< id of built-in to check on */",
        "snippet": "ecma_object_t *\necma_builtin_get (ecma_builtin_id_t builtin_id) /**< id of built-in to check on */\n{\n  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_ID__COUNT);\n\n  if (JERRY_UNLIKELY (JERRY_CONTEXT (ecma_builtin_objects)[builtin_id] == JMEM_CP_NULL))\n  {\n    ecma_instantiate_builtin (builtin_id);\n  }\n\n  return ECMA_GET_NON_NULL_POINTER (ecma_object_t, JERRY_CONTEXT (ecma_builtin_objects)[builtin_id]);\n}",
        "begin_line": 293,
        "end_line": 304,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get_global#314",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get_global (void)",
        "snippet": "inline ecma_object_t * JERRY_ATTR_ALWAYS_INLINE\necma_builtin_get_global (void)\n{\n  JERRY_ASSERT (JERRY_CONTEXT (ecma_builtin_objects)[ECMA_BUILTIN_ID_GLOBAL] != JMEM_CP_NULL);\n\n  return ECMA_GET_NON_NULL_POINTER (ecma_object_t, JERRY_CONTEXT (ecma_builtin_objects)[ECMA_BUILTIN_ID_GLOBAL]);\n}",
        "begin_line": 314,
        "end_line": 320,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get_property_count#249",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get_property_count (ecma_builtin_id_t builtin_id) /**< built-in ID */",
        "snippet": "static size_t\necma_builtin_get_property_count (ecma_builtin_id_t builtin_id) /**< built-in ID */\n{\n  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_ID__COUNT);\n  const ecma_builtin_property_descriptor_t *property_list_p = ecma_builtin_property_list_references[builtin_id];\n\n  const ecma_builtin_property_descriptor_t *curr_property_p = property_list_p;\n\n  while (curr_property_p->magic_string_id != LIT_MAGIC_STRING__COUNT)\n  {\n    curr_property_p++;\n  }\n\n  return (size_t) (curr_property_p - property_list_p);\n}",
        "begin_line": 249,
        "end_line": 263,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_is#271",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_is (ecma_object_t *obj_p, /**< pointer to an object */                  ecma_builtin_id_t builtin_id) /**< id of built-in to check on */",
        "snippet": "bool\necma_builtin_is (ecma_object_t *obj_p, /**< pointer to an object */\n                 ecma_builtin_id_t builtin_id) /**< id of built-in to check on */\n{\n  JERRY_ASSERT (obj_p != NULL && !ecma_is_lexical_environment (obj_p));\n  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_ID__COUNT);\n\n  /* If a built-in object is not instantiated, its value is NULL,\n     hence it cannot be equal to a valid object. */\n  jmem_cpointer_t builtin_cp = JERRY_CONTEXT (ecma_builtin_objects)[builtin_id];\n\n  return (builtin_cp != JMEM_CP_NULL && (obj_p == ECMA_GET_NON_NULL_POINTER (ecma_object_t, builtin_cp)));\n}",
        "begin_line": 271,
        "end_line": 283,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_make_function_object_for_routine#554",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_make_function_object_for_routine (ecma_builtin_id_t builtin_id, /**< identifier of built-in object */                                                uint16_t routine_id, /**< builtin-wide identifier of the built-in                                                                      *   object's routine property */                                                uint16_t name_id, /**< magic string id of 'name' property */                                                uint8_t length_prop_value) /**< value of 'length' property */",
        "snippet": "static ecma_object_t *\necma_builtin_make_function_object_for_routine (ecma_builtin_id_t builtin_id, /**< identifier of built-in object */\n                                               uint16_t routine_id, /**< builtin-wide identifier of the built-in\n                                                                     *   object's routine property */\n                                               uint16_t name_id, /**< magic string id of 'name' property */\n                                               uint8_t length_prop_value) /**< value of 'length' property */\n{\n  JERRY_ASSERT (length_prop_value < (1 << ECMA_BUILT_IN_BITSET_SHIFT));\n\n  ecma_object_t *prototype_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_FUNCTION_PROTOTYPE);\n\n  size_t ext_object_size = sizeof (ecma_extended_object_t);\n\n  ecma_object_t *func_obj_p = ecma_create_object (prototype_obj_p,\n                                                  ext_object_size,\n                                                  ECMA_OBJECT_TYPE_FUNCTION);\n\n  ecma_set_object_is_builtin (func_obj_p);\n\n  JERRY_ASSERT (routine_id >= ECMA_BUILTIN_ID__COUNT);\n\n  ecma_extended_object_t *ext_func_obj_p = (ecma_extended_object_t *) func_obj_p;\n  ext_func_obj_p->u.built_in.id = (uint8_t) builtin_id;\n  ext_func_obj_p->u.built_in.routine_id = routine_id;\n  ext_func_obj_p->u.built_in.u.builtin_routine.name = name_id;\n  ext_func_obj_p->u.built_in.u.builtin_routine.bitset = 0;\n\n  ext_func_obj_p->u.built_in.length_and_bitset_size = length_prop_value;\n\n  return func_obj_p;\n}",
        "begin_line": 554,
        "end_line": 584,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_try_to_instantiate_property#681",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_try_to_instantiate_property (ecma_object_t *object_p, /**< object */                                           ecma_string_t *string_p) /**< property's name */",
        "snippet": "ecma_property_t *\necma_builtin_try_to_instantiate_property (ecma_object_t *object_p, /**< object */\n                                          ecma_string_t *string_p) /**< property's name */\n{\n  JERRY_ASSERT (ecma_get_object_is_builtin (object_p));\n\n  lit_magic_string_id_t magic_string_id = ecma_get_string_magic (string_p);\n\n#if ENABLED (JERRY_ES2015)\n  if (JERRY_UNLIKELY (ecma_prop_name_is_symbol (string_p)))\n  {\n    if (string_p->u.hash & ECMA_GLOBAL_SYMBOL_FLAG)\n    {\n      magic_string_id = (string_p->u.hash >> ECMA_GLOBAL_SYMBOL_SHIFT);\n    }\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  if (magic_string_id == LIT_MAGIC_STRING__COUNT)\n  {\n    return NULL;\n  }\n\n  ecma_built_in_props_t *built_in_props_p;\n  ecma_object_type_t object_type = ecma_get_object_type (object_p);\n  JERRY_ASSERT (object_type != ECMA_OBJECT_TYPE_FUNCTION || !ecma_builtin_function_is_routine (object_p));\n\n  if (object_type == ECMA_OBJECT_TYPE_CLASS || object_type == ECMA_OBJECT_TYPE_ARRAY)\n  {\n    built_in_props_p = &((ecma_extended_built_in_object_t *) object_p)->built_in;\n  }\n  else\n  {\n    built_in_props_p = &((ecma_extended_object_t *) object_p)->u.built_in;\n  }\n\n  ecma_builtin_id_t builtin_id = (ecma_builtin_id_t) built_in_props_p->id;\n\n  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_ID__COUNT);\n  JERRY_ASSERT (ecma_builtin_is (object_p, builtin_id));\n\n  const ecma_builtin_property_descriptor_t *property_list_p = ecma_builtin_property_list_references[builtin_id];\n\n  const ecma_builtin_property_descriptor_t *curr_property_p = property_list_p;\n\n  while (curr_property_p->magic_string_id != magic_string_id)\n  {\n    if (curr_property_p->magic_string_id == LIT_MAGIC_STRING__COUNT)\n    {\n      return NULL;\n    }\n    curr_property_p++;\n  }\n\n  uint32_t index = (uint32_t) (curr_property_p - property_list_p);\n\n  uint32_t *bitset_p = built_in_props_p->u.instantiated_bitset + (index >> 5);\n\n  uint32_t bit_for_index = (uint32_t) (1u << (index & 0x1f));\n\n  if (*bitset_p & bit_for_index)\n  {\n    /* This property was instantiated before. */\n    return NULL;\n  }\n\n  *bitset_p |= bit_for_index;\n\n  ecma_value_t value = ECMA_VALUE_EMPTY;\n  bool is_accessor = false;\n  ecma_object_t *getter_p = NULL;\n  ecma_object_t *setter_p = NULL;\n\n  switch (curr_property_p->type)\n  {\n    case ECMA_BUILTIN_PROPERTY_SIMPLE:\n    {\n      value = curr_property_p->value;\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_NUMBER:\n    {\n      ecma_number_t num = 0.0;\n\n      if (curr_property_p->value < ECMA_BUILTIN_NUMBER_MAX)\n      {\n        num = curr_property_p->value;\n      }\n      else if (curr_property_p->value < ECMA_BUILTIN_NUMBER_NAN)\n      {\n        static const ecma_number_t builtin_number_list[] =\n        {\n          ECMA_NUMBER_MAX_VALUE,\n          ECMA_NUMBER_MIN_VALUE,\n#if ENABLED (JERRY_ES2015)\n          ECMA_NUMBER_EPSILON,\n          ECMA_NUMBER_MAX_SAFE_INTEGER,\n          ECMA_NUMBER_MIN_SAFE_INTEGER,\n#endif /* ENABLED (JERRY_ES2015) */\n          ECMA_NUMBER_E,\n          ECMA_NUMBER_PI,\n          ECMA_NUMBER_LN10,\n          ECMA_NUMBER_LN2,\n          ECMA_NUMBER_LOG2E,\n          ECMA_NUMBER_LOG10E,\n          ECMA_NUMBER_SQRT2,\n          ECMA_NUMBER_SQRT_1_2,\n        };\n\n        num = builtin_number_list[curr_property_p->value - ECMA_BUILTIN_NUMBER_MAX];\n      }\n      else\n      {\n        switch (curr_property_p->value)\n        {\n          case ECMA_BUILTIN_NUMBER_POSITIVE_INFINITY:\n          {\n            num = ecma_number_make_infinity (false);\n            break;\n          }\n          case ECMA_BUILTIN_NUMBER_NEGATIVE_INFINITY:\n          {\n            num = ecma_number_make_infinity (true);\n            break;\n          }\n          default:\n          {\n            JERRY_ASSERT (curr_property_p->value == ECMA_BUILTIN_NUMBER_NAN);\n\n            num = ecma_number_make_nan ();\n            break;\n          }\n        }\n      }\n\n      value = ecma_make_number_value (num);\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_STRING:\n    {\n      value = ecma_make_magic_string_value ((lit_magic_string_id_t) curr_property_p->value);\n      break;\n    }\n#if ENABLED (JERRY_ES2015)\n    case ECMA_BUILTIN_PROPERTY_SYMBOL:\n    {\n      ecma_stringbuilder_t builder = ecma_stringbuilder_create_raw ((lit_utf8_byte_t *) \"Symbol.\", 7);\n\n      lit_magic_string_id_t symbol_desc_id = (lit_magic_string_id_t) curr_property_p->value;\n\n      ecma_stringbuilder_append_magic (&builder, symbol_desc_id);\n\n      ecma_value_t symbol_desc_value = ecma_make_string_value (ecma_stringbuilder_finalize (&builder));\n\n      ecma_string_t *symbol_p = ecma_new_symbol_from_descriptor_string (symbol_desc_value);\n      lit_magic_string_id_t symbol_id = (lit_magic_string_id_t) curr_property_p->magic_string_id;\n      symbol_p->u.hash = (uint16_t) ((symbol_id << ECMA_GLOBAL_SYMBOL_SHIFT) | ECMA_GLOBAL_SYMBOL_FLAG);\n\n      value = ecma_make_symbol_value (symbol_p);\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_INTRINSIC_PROPERTY:\n    {\n      value = ecma_op_object_get_by_magic_id (ecma_builtin_get (ECMA_BUILTIN_ID_INTRINSIC_OBJECT),\n                                              (lit_magic_string_id_t) curr_property_p->value);\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_ACCESSOR_BUILTIN_FUNCTION:\n    {\n      is_accessor = true;\n      uint16_t getter_id = ECMA_ACCESSOR_READ_WRITE_GET_GETTER_ID (curr_property_p->value);\n      uint16_t setter_id = ECMA_ACCESSOR_READ_WRITE_GET_SETTER_ID (curr_property_p->value);\n      getter_p = ecma_builtin_get (getter_id);\n      setter_p = ecma_builtin_get (setter_id);\n      ecma_ref_object (getter_p);\n      ecma_ref_object (setter_p);\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case ECMA_BUILTIN_PROPERTY_OBJECT:\n    {\n      ecma_object_t *builtin_object_p = ecma_builtin_get ((ecma_builtin_id_t) curr_property_p->value);\n      ecma_ref_object (builtin_object_p);\n      value = ecma_make_object_value (builtin_object_p);\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_ROUTINE:\n    {\n      ecma_object_t *func_obj_p;\n      func_obj_p = ecma_builtin_make_function_object_for_routine (builtin_id,\n                                                                  ECMA_GET_ROUTINE_ID (curr_property_p->value),\n                                                                  curr_property_p->magic_string_id,\n                                                                  ECMA_GET_ROUTINE_LENGTH (curr_property_p->value));\n      value = ecma_make_object_value (func_obj_p);\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_ACCESSOR_READ_WRITE:\n    {\n      is_accessor = true;\n      uint16_t getter_id = ECMA_ACCESSOR_READ_WRITE_GET_GETTER_ID (curr_property_p->value);\n      uint16_t setter_id = ECMA_ACCESSOR_READ_WRITE_GET_SETTER_ID (curr_property_p->value);\n      getter_p = ecma_builtin_make_function_object_for_getter_accessor (builtin_id,\n                                                                        getter_id,\n                                                                        curr_property_p->magic_string_id);\n      setter_p = ecma_builtin_make_function_object_for_setter_accessor (builtin_id,\n                                                                        setter_id,\n                                                                        curr_property_p->magic_string_id);\n      break;\n    }\n    default:\n    {\n      JERRY_ASSERT (curr_property_p->type == ECMA_BUILTIN_PROPERTY_ACCESSOR_READ_ONLY);\n\n      is_accessor = true;\n      getter_p = ecma_builtin_make_function_object_for_getter_accessor (builtin_id,\n                                                                        curr_property_p->value,\n                                                                        curr_property_p->magic_string_id);\n      break;\n    }\n  }\n\n  ecma_property_t *prop_p;\n\n  if (is_accessor)\n  {\n    ecma_create_named_accessor_property (object_p,\n                                         string_p,\n                                         getter_p,\n                                         setter_p,\n                                         curr_property_p->attributes,\n                                         &prop_p);\n\n    if (setter_p)\n    {\n      ecma_deref_object (setter_p);\n    }\n    if (getter_p)\n    {\n      ecma_deref_object (getter_p);\n    }\n  }\n  else\n  {\n    ecma_property_value_t *prop_value_p = ecma_create_named_data_property (object_p,\n                                                                           string_p,\n                                                                           curr_property_p->attributes,\n                                                                           &prop_p);\n    prop_value_p->value = value;\n\n    /* Reference count of objects must be decreased. */\n    if (ecma_is_value_object (value))\n    {\n      ecma_free_value (value);\n    }\n  }\n\n  return prop_p;\n}",
        "begin_line": 681,
        "end_line": 938,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_instantiate_builtin#341",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_instantiate_builtin (ecma_builtin_id_t obj_builtin_id) /**< built-in id */",
        "snippet": "static void\necma_instantiate_builtin (ecma_builtin_id_t obj_builtin_id) /**< built-in id */\n{\n  JERRY_ASSERT (obj_builtin_id < ECMA_BUILTIN_ID__COUNT);\n  JERRY_ASSERT (JERRY_CONTEXT (ecma_builtin_objects)[obj_builtin_id] == JMEM_CP_NULL);\n\n  ecma_builtin_descriptor_t builtin_desc = ecma_builtin_descriptors[obj_builtin_id];\n  ecma_builtin_id_t object_prototype_builtin_id = (ecma_builtin_id_t) (builtin_desc >> ECMA_BUILTIN_PROTOTYPE_ID_SHIFT);\n\n  ecma_object_t *prototype_obj_p;\n\n  /* cppcheck-suppress arrayIndexOutOfBoundsCond */\n  if (JERRY_UNLIKELY (object_prototype_builtin_id == ECMA_BUILTIN_ID__COUNT))\n  {\n    prototype_obj_p = NULL;\n  }\n  else\n  {\n    if (JERRY_CONTEXT (ecma_builtin_objects)[object_prototype_builtin_id] == JMEM_CP_NULL)\n    {\n      ecma_instantiate_builtin (object_prototype_builtin_id);\n    }\n    prototype_obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t,\n                                                 JERRY_CONTEXT (ecma_builtin_objects)[object_prototype_builtin_id]);\n    JERRY_ASSERT (prototype_obj_p != NULL);\n  }\n\n  ecma_object_type_t obj_type = (ecma_object_type_t) (builtin_desc & ECMA_BUILTIN_OBJECT_TYPE_MASK);\n\n  bool is_extended_built_in = (obj_type == ECMA_OBJECT_TYPE_CLASS\n                               || obj_type == ECMA_OBJECT_TYPE_ARRAY);\n\n  size_t ext_object_size = (is_extended_built_in ? sizeof (ecma_extended_built_in_object_t)\n                                                 : sizeof (ecma_extended_object_t));\n\n  size_t property_count = ecma_builtin_get_property_count (obj_builtin_id);\n\n  if (property_count > 32)\n  {\n    /* Only 64 extra properties supported at the moment.\n     * This can be extended to 256 later. */\n    JERRY_ASSERT (property_count <= (32 + 64));\n\n    ext_object_size += sizeof (uint32_t) * 2;\n  }\n\n  ecma_object_t *obj_p = ecma_create_object (prototype_obj_p, ext_object_size, obj_type);\n\n  if (JERRY_UNLIKELY (obj_builtin_id == ECMA_BUILTIN_ID_TYPE_ERROR_THROWER))\n  {\n    ecma_op_ordinary_object_prevent_extensions (obj_p);\n  }\n  else\n  {\n    ecma_op_ordinary_object_set_extensible (obj_p);\n  }\n\n  /*\n   * [[Class]] property of built-in object is not stored explicitly.\n   *\n   * See also: ecma_object_get_class_name\n   */\n\n  ecma_set_object_is_builtin (obj_p);\n  ecma_built_in_props_t *built_in_props_p;\n\n  if (is_extended_built_in)\n  {\n    built_in_props_p = &((ecma_extended_built_in_object_t *) obj_p)->built_in;\n  }\n  else\n  {\n    built_in_props_p = &((ecma_extended_object_t *) obj_p)->u.built_in;\n  }\n\n  built_in_props_p->id = (uint8_t) obj_builtin_id;\n  built_in_props_p->routine_id = (uint16_t) obj_builtin_id;\n  built_in_props_p->u.instantiated_bitset[0] = 0;\n\n  if (property_count > 32)\n  {\n    built_in_props_p->length_and_bitset_size = 1 << ECMA_BUILT_IN_BITSET_SHIFT;\n\n    uint32_t *instantiated_bitset_p = built_in_props_p->u.instantiated_bitset;\n    instantiated_bitset_p[1] = 0;\n    instantiated_bitset_p[2] = 0;\n  }\n  else\n  {\n    built_in_props_p->length_and_bitset_size = 0;\n  }\n\n  /** Initializing [[PrimitiveValue]] properties of built-in prototype objects */\n  switch (obj_builtin_id)\n  {\n#if ENABLED (JERRY_BUILTIN_ARRAY)\n    case ECMA_BUILTIN_ID_ARRAY_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_ARRAY);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.array.length = 0;\n      ext_object_p->u.array.u.length_prop = ECMA_PROPERTY_FLAG_WRITABLE | ECMA_PROPERTY_TYPE_VIRTUAL;\n      break;\n    }\n#endif /* ENABLED (JERRY_BUILTIN_ARRAY) */\n\n#if !ENABLED (JERRY_ES2015)\n#if ENABLED (JERRY_BUILTIN_STRING)\n    case ECMA_BUILTIN_ID_STRING_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_CLASS);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.class_prop.class_id = LIT_MAGIC_STRING_STRING_UL;\n      ext_object_p->u.class_prop.u.value = ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);\n      break;\n    }\n#endif /* ENABLED (JERRY_BUILTIN_STRING) */\n\n#if ENABLED (JERRY_BUILTIN_NUMBER)\n    case ECMA_BUILTIN_ID_NUMBER_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_CLASS);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.class_prop.class_id = LIT_MAGIC_STRING_NUMBER_UL;\n      ext_object_p->u.class_prop.u.value = ecma_make_integer_value (0);\n      break;\n    }\n#endif /* ENABLED (JERRY_BUILTIN_NUMBER) */\n\n#if ENABLED (JERRY_BUILTIN_BOOLEAN)\n    case ECMA_BUILTIN_ID_BOOLEAN_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_CLASS);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.class_prop.class_id = LIT_MAGIC_STRING_BOOLEAN_UL;\n      ext_object_p->u.class_prop.u.value = ECMA_VALUE_FALSE;\n      break;\n    }\n#endif /* ENABLED (JERRY_BUILTIN_BOOLEAN) */\n\n#if ENABLED (JERRY_BUILTIN_DATE)\n    case ECMA_BUILTIN_ID_DATE_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_CLASS);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.class_prop.class_id = LIT_MAGIC_STRING_DATE_UL;\n\n      ecma_number_t *prim_prop_num_value_p = ecma_alloc_number ();\n      *prim_prop_num_value_p = ecma_number_make_nan ();\n      ECMA_SET_INTERNAL_VALUE_POINTER (ext_object_p->u.class_prop.u.value, prim_prop_num_value_p);\n      break;\n    }\n#endif /* ENABLED (JERRY_BUILTIN_DATE) */\n\n#if ENABLED (JERRY_BUILTIN_REGEXP)\n    case ECMA_BUILTIN_ID_REGEXP_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_CLASS);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.class_prop.class_id = LIT_MAGIC_STRING_REGEXP_UL;\n\n      re_compiled_code_t *bc_p = re_compile_bytecode (ecma_get_magic_string (LIT_MAGIC_STRING_EMPTY_NON_CAPTURE_GROUP),\n                                                      RE_FLAG_EMPTY);\n\n      JERRY_ASSERT (bc_p != NULL);\n\n      ECMA_SET_INTERNAL_VALUE_POINTER (ext_object_p->u.class_prop.u.value, bc_p);\n\n      break;\n    }\n#endif /* ENABLED (JERRY_BUILTIN_REGEXP) */\n#endif /* !ENABLED (JERRY_ES2015) */\n    default:\n    {\n      JERRY_ASSERT (obj_type != ECMA_OBJECT_TYPE_CLASS);\n      break;\n    }\n  }\n\n  ECMA_SET_NON_NULL_POINTER (JERRY_CONTEXT (ecma_builtin_objects)[obj_builtin_id], obj_p);\n}",
        "begin_line": 341,
        "end_line": 527,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-array-object.ecma_fast_array_convert_to_normal#165",
        "src_path": "jerry-core/ecma/operations/ecma-array-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-array-object",
        "signature": "jerry-core.ecma.operations.ecma-array-object.ecma_fast_array_convert_to_normal (ecma_object_t *object_p) /**< fast access mode array object */",
        "snippet": "void\necma_fast_array_convert_to_normal (ecma_object_t *object_p) /**< fast access mode array object */\n{\n  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));\n\n  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;\n\n  if (object_p->u1.property_list_cp == JMEM_CP_NULL)\n  {\n    ext_obj_p->u.array.u.length_prop = (uint8_t) (ext_obj_p->u.array.u.length_prop & ~ECMA_FAST_ARRAY_FLAG);\n    return;\n  }\n\n  uint32_t length = ext_obj_p->u.array.length;\n  const uint32_t aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (length);\n  ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);\n\n  ecma_ref_object (object_p);\n\n  ecma_property_pair_t *property_pair_p = NULL;\n  jmem_cpointer_t next_property_pair_cp = JMEM_CP_NULL;\n\n  uint32_t prop_index = 1;\n  int32_t index = (int32_t) (length - 1);\n\n  while (index >= 0)\n  {\n    if (ecma_is_value_array_hole (values_p[index]))\n    {\n      index--;\n      continue;\n    }\n\n    if (prop_index == 1)\n    {\n      property_pair_p = ecma_alloc_property_pair ();\n      property_pair_p->header.next_property_cp = next_property_pair_cp;\n      property_pair_p->names_cp[0] = LIT_INTERNAL_MAGIC_STRING_DELETED;\n      property_pair_p->header.types[0] = ECMA_PROPERTY_TYPE_DELETED;\n      ECMA_SET_NON_NULL_POINTER (next_property_pair_cp, property_pair_p);\n    }\n\n    JERRY_ASSERT (index <= ECMA_DIRECT_STRING_MAX_IMM);\n\n    property_pair_p->names_cp[prop_index] = (jmem_cpointer_t) index;\n    property_pair_p->header.types[prop_index] = (ecma_property_t) (ECMA_PROPERTY_TYPE_NAMEDDATA\n                                                                   | ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE\n                                                                   | ECMA_FAST_ARRAY_UINT32_DIRECT_STRING_PROP_TYPE);\n\n    property_pair_p->values[prop_index].value = values_p[index];\n\n    index--;\n    prop_index = !prop_index;\n  }\n\n  ext_obj_p->u.array.u.length_prop = (uint8_t) (ext_obj_p->u.array.u.length_prop & ~ECMA_FAST_ARRAY_FLAG);\n  jmem_heap_free_block (values_p, aligned_length * sizeof (ecma_value_t));\n  ECMA_SET_POINTER (object_p->u1.property_list_cp, property_pair_p);\n\n  ecma_deref_object (object_p);\n}",
        "begin_line": 165,
        "end_line": 225,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-array-object.ecma_fast_array_extend#322",
        "src_path": "jerry-core/ecma/operations/ecma-array-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-array-object",
        "signature": "jerry-core.ecma.operations.ecma-array-object.ecma_fast_array_extend (ecma_object_t *object_p, /**< fast access mode array object */                         uint32_t new_length) /**< new length of the fast access mode array */",
        "snippet": "ecma_value_t *\necma_fast_array_extend (ecma_object_t *object_p, /**< fast access mode array object */\n                        uint32_t new_length) /**< new length of the fast access mode array */\n{\n  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));\n  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;\n  uint32_t old_length = ext_obj_p->u.array.length;\n\n  JERRY_ASSERT (old_length < new_length);\n\n  ecma_ref_object (object_p);\n\n  ecma_value_t *new_values_p;\n  const uint32_t old_length_aligned = ECMA_FAST_ARRAY_ALIGN_LENGTH (old_length);\n  const uint32_t new_length_aligned = ECMA_FAST_ARRAY_ALIGN_LENGTH (new_length);\n\n  if (object_p->u1.property_list_cp == JMEM_CP_NULL)\n  {\n    new_values_p = jmem_heap_alloc_block (new_length_aligned * sizeof (ecma_value_t));\n  }\n  else\n  {\n    ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);\n    new_values_p = (ecma_value_t *) jmem_heap_realloc_block (values_p,\n                                                             old_length_aligned * sizeof (ecma_value_t),\n                                                             new_length_aligned * sizeof (ecma_value_t));\n  }\n\n  for (uint32_t i = old_length; i < new_length_aligned; i++)\n  {\n    new_values_p[i] = ECMA_VALUE_ARRAY_HOLE;\n  }\n\n  ext_obj_p->u.array.u.hole_count += (new_length - old_length) * ECMA_FAST_ARRAY_HOLE_ONE;\n  ext_obj_p->u.array.length = new_length;\n\n  ECMA_SET_NON_NULL_POINTER (object_p->u1.property_list_cp, new_values_p);\n\n  ecma_deref_object (object_p);\n  return new_values_p;\n}",
        "begin_line": 322,
        "end_line": 362,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-array-object.ecma_op_array_is_fast_array#115",
        "src_path": "jerry-core/ecma/operations/ecma-array-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-array-object",
        "signature": "jerry-core.ecma.operations.ecma-array-object.ecma_op_array_is_fast_array (ecma_extended_object_t *array_p) /**< ecma-array-object */",
        "snippet": "inline bool JERRY_ATTR_ALWAYS_INLINE\necma_op_array_is_fast_array (ecma_extended_object_t *array_p) /**< ecma-array-object */\n{\n  JERRY_ASSERT (ecma_get_object_type ((ecma_object_t *) array_p) == ECMA_OBJECT_TYPE_ARRAY);\n\n  return array_p->u.array.u.length_prop & ECMA_FAST_ARRAY_FLAG;\n}",
        "begin_line": 115,
        "end_line": 121,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-array-object.ecma_op_new_array_object#69",
        "src_path": "jerry-core/ecma/operations/ecma-array-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-array-object",
        "signature": "jerry-core.ecma.operations.ecma-array-object.ecma_op_new_array_object (ecma_length_t length) /**< length of the new array */",
        "snippet": "ecma_object_t *\necma_op_new_array_object (ecma_length_t length) /**< length of the new array */\n{\n#if ENABLED (JERRY_BUILTIN_ARRAY)\n  ecma_object_t *array_prototype_object_p = ecma_builtin_get (ECMA_BUILTIN_ID_ARRAY_PROTOTYPE);\n#else /* !ENABLED (JERRY_BUILTIN_ARRAY) */\n  ecma_object_t *array_prototype_object_p = ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);\n#endif /* ENABLED (JERRY_BUILTIN_ARRAY) */\n\n  ecma_object_t *object_p = ecma_create_object (array_prototype_object_p,\n                                                sizeof (ecma_extended_object_t),\n                                                ECMA_OBJECT_TYPE_ARRAY);\n\n  /*\n   * [[Class]] property is not stored explicitly for objects of ECMA_OBJECT_TYPE_ARRAY type.\n   *\n   * See also: ecma_object_get_class_name\n   */\n\n  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;\n  ext_obj_p->u.array.length = length;\n  ext_obj_p->u.array.u.hole_count = 0;\n  ext_obj_p->u.array.u.length_prop = ECMA_PROPERTY_FLAG_WRITABLE | ECMA_PROPERTY_TYPE_VIRTUAL;\n\n  return object_p;\n}",
        "begin_line": 69,
        "end_line": 94,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-array-object.ecma_op_new_fast_array_object#129",
        "src_path": "jerry-core/ecma/operations/ecma-array-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-array-object",
        "signature": "jerry-core.ecma.operations.ecma-array-object.ecma_op_new_fast_array_object (ecma_length_t length) /**< length of the new fast access mode array */",
        "snippet": "ecma_object_t *\necma_op_new_fast_array_object (ecma_length_t length) /**< length of the new fast access mode array */\n{\n  const uint32_t aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (length);\n  ecma_value_t *values_p = NULL;\n\n  if (length != 0)\n  {\n    values_p = (ecma_value_t *) jmem_heap_alloc_block_null_on_error (aligned_length * sizeof (ecma_value_t));\n\n    if (JERRY_UNLIKELY (values_p == NULL))\n    {\n      return NULL;\n    }\n  }\n\n  ecma_object_t *object_p = ecma_op_new_array_object (length);\n  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;\n\n  ext_obj_p->u.array.u.length_prop = (uint8_t) (ext_obj_p->u.array.u.length_prop | ECMA_FAST_ARRAY_FLAG);\n  ext_obj_p->u.array.u.hole_count += length * ECMA_FAST_ARRAY_HOLE_ONE;\n\n  JERRY_ASSERT (object_p->u1.property_list_cp == JMEM_CP_NULL);\n\n  for (uint32_t i = 0; i < aligned_length; i++)\n  {\n    values_p[i] = ECMA_VALUE_ARRAY_HOLE;\n  }\n\n  ECMA_SET_POINTER (object_p->u1.property_list_cp, values_p);\n  return object_p;\n}",
        "begin_line": 129,
        "end_line": 160,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-array-object.ecma_op_object_is_fast_array#102",
        "src_path": "jerry-core/ecma/operations/ecma-array-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-array-object",
        "signature": "jerry-core.ecma.operations.ecma-array-object.ecma_op_object_is_fast_array (ecma_object_t *object_p) /**< ecma-object */",
        "snippet": "inline bool JERRY_ATTR_ALWAYS_INLINE\necma_op_object_is_fast_array (ecma_object_t *object_p) /**< ecma-object */\n{\n  return (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_ARRAY &&\n          ecma_op_array_is_fast_array ((ecma_extended_object_t *) object_p));\n}",
        "begin_line": 102,
        "end_line": 107,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-conversion.ecma_get_number#335",
        "src_path": "jerry-core/ecma/operations/ecma-conversion.c",
        "class_name": "jerry-core.ecma.operations.ecma-conversion",
        "signature": "jerry-core.ecma.operations.ecma-conversion.ecma_get_number (ecma_value_t value, /**< ecma value*/                  ecma_number_t *number_p) /**< [out] ecma number */",
        "snippet": "ecma_value_t\necma_get_number (ecma_value_t value, /**< ecma value*/\n                 ecma_number_t *number_p) /**< [out] ecma number */\n{\n  if (ecma_is_value_integer_number (value))\n  {\n    *number_p = ecma_get_integer_from_value (value);\n    return ECMA_VALUE_EMPTY;\n  }\n\n  if (ecma_is_value_float_number (value))\n  {\n    *number_p = ecma_get_float_from_value (value);\n    return ECMA_VALUE_EMPTY;\n  }\n\n  if (ecma_is_value_string (value))\n  {\n    ecma_string_t *str_p = ecma_get_string_from_value (value);\n    *number_p = ecma_string_to_number (str_p);\n    return ECMA_VALUE_EMPTY;\n  }\n\n  if (ecma_is_value_object (value))\n  {\n    ecma_value_t primitive_value = ecma_op_to_primitive (value, ECMA_PREFERRED_TYPE_NUMBER);\n\n    if (ECMA_IS_VALUE_ERROR (primitive_value))\n    {\n      return primitive_value;\n    }\n\n    ecma_value_t ret_value = ecma_get_number (primitive_value, number_p);\n    ecma_fast_free_value (primitive_value);\n    return ret_value;\n  }\n\n  if (ecma_is_value_undefined (value))\n  {\n    *number_p = ecma_number_make_nan ();\n    return ECMA_VALUE_EMPTY;\n  }\n\n  if (ecma_is_value_null (value))\n  {\n    *number_p = 0;\n    return ECMA_VALUE_EMPTY;\n  }\n\n#if ENABLED (JERRY_ES2015)\n  if (ecma_is_value_symbol (value))\n  {\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Cannot convert a Symbol value to a number.\"));\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  JERRY_ASSERT (ecma_is_value_boolean (value));\n\n  *number_p = ecma_is_value_true (value) ? 1 : 0;\n  return ECMA_VALUE_EMPTY;\n}",
        "begin_line": 335,
        "end_line": 395,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-conversion.ecma_op_to_object#508",
        "src_path": "jerry-core/ecma/operations/ecma-conversion.c",
        "class_name": "jerry-core.ecma.operations.ecma-conversion",
        "signature": "jerry-core.ecma.operations.ecma-conversion.ecma_op_to_object (ecma_value_t value) /**< ecma value */",
        "snippet": "ecma_value_t\necma_op_to_object (ecma_value_t value) /**< ecma value */\n{\n  ecma_check_value_type_is_spec_defined (value);\n\n  if (ecma_is_value_number (value))\n  {\n    return ecma_op_create_number_object (value);\n  }\n  else if (ecma_is_value_string (value))\n  {\n    return ecma_op_create_string_object (&value, 1);\n  }\n  else if (ecma_is_value_object (value))\n  {\n    return ecma_copy_value (value);\n  }\n#if ENABLED (JERRY_ES2015)\n  else if (ecma_is_value_symbol (value))\n  {\n    return ecma_op_create_symbol_object (value);\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n  else\n  {\n    if (ecma_is_value_undefined (value)\n        || ecma_is_value_null (value))\n    {\n      return ecma_raise_type_error (ECMA_ERR_MSG (\"Argument cannot be converted to an object.\"));\n    }\n    else\n    {\n      JERRY_ASSERT (ecma_is_value_boolean (value));\n\n      return ecma_op_create_boolean_object (value);\n    }\n  }\n}",
        "begin_line": 508,
        "end_line": 545,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-conversion.ecma_op_to_prop_name#482",
        "src_path": "jerry-core/ecma/operations/ecma-conversion.c",
        "class_name": "jerry-core.ecma.operations.ecma-conversion",
        "signature": "jerry-core.ecma.operations.ecma-conversion.ecma_op_to_prop_name (ecma_value_t value) /**< ecma value */",
        "snippet": "ecma_string_t *\necma_op_to_prop_name (ecma_value_t value) /**< ecma value */\n{\n  ecma_check_value_type_is_spec_defined (value);\n\n#if ENABLED (JERRY_ES2015)\n  if (ecma_is_value_symbol (value))\n  {\n    ecma_string_t *symbol_p = ecma_get_symbol_from_value (value);\n    ecma_ref_ecma_string (symbol_p);\n    return symbol_p;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  return ecma_op_to_string (value);\n}",
        "begin_line": 482,
        "end_line": 497,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-conversion.ecma_op_to_string#406",
        "src_path": "jerry-core/ecma/operations/ecma-conversion.c",
        "class_name": "jerry-core.ecma.operations.ecma-conversion",
        "signature": "jerry-core.ecma.operations.ecma-conversion.ecma_op_to_string (ecma_value_t value) /**< ecma value */",
        "snippet": "ecma_string_t *\necma_op_to_string (ecma_value_t value) /**< ecma value */\n{\n  ecma_check_value_type_is_spec_defined (value);\n\n  if (JERRY_UNLIKELY (ecma_is_value_object (value)))\n  {\n    ecma_value_t prim_value = ecma_op_to_primitive (value, ECMA_PREFERRED_TYPE_STRING);\n\n    if (ECMA_IS_VALUE_ERROR (prim_value))\n    {\n      return NULL;\n    }\n\n    ecma_string_t *ret_string_p = ecma_op_to_string (prim_value);\n\n    ecma_free_value (prim_value);\n\n    return ret_string_p;\n  }\n\n  if (ecma_is_value_string (value))\n  {\n    ecma_string_t *res_p = ecma_get_string_from_value (value);\n    ecma_ref_ecma_string (res_p);\n    return res_p;\n  }\n  else if (ecma_is_value_integer_number (value))\n  {\n    ecma_integer_value_t num = ecma_get_integer_from_value (value);\n\n    if (num < 0)\n    {\n      return ecma_new_ecma_string_from_number ((ecma_number_t) num);\n    }\n    else\n    {\n      return ecma_new_ecma_string_from_uint32 ((uint32_t) num);\n    }\n  }\n  else if (ecma_is_value_float_number (value))\n  {\n    ecma_number_t num = ecma_get_float_from_value (value);\n    return ecma_new_ecma_string_from_number (num);\n  }\n  else if (ecma_is_value_undefined (value))\n  {\n    return ecma_get_magic_string (LIT_MAGIC_STRING_UNDEFINED);\n  }\n  else if (ecma_is_value_null (value))\n  {\n    return ecma_get_magic_string (LIT_MAGIC_STRING_NULL);\n  }\n#if ENABLED (JERRY_ES2015)\n  else if (ecma_is_value_symbol (value))\n  {\n    ecma_raise_type_error (ECMA_ERR_MSG (\"Cannot convert a Symbol value to a string.\"));\n    return NULL;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n  JERRY_ASSERT (ecma_is_value_boolean (value));\n\n  if (ecma_is_value_true (value))\n  {\n    return ecma_get_magic_string (LIT_MAGIC_STRING_TRUE);\n  }\n\n  return ecma_get_magic_string (LIT_MAGIC_STRING_FALSE);\n}",
        "begin_line": 406,
        "end_line": 474,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-eval.ecma_op_eval#43",
        "src_path": "jerry-core/ecma/operations/ecma-eval.c",
        "class_name": "jerry-core.ecma.operations.ecma-eval",
        "signature": "jerry-core.ecma.operations.ecma-eval.ecma_op_eval (ecma_string_t *code_p, /**< code string */               uint32_t parse_opts) /**< ecma_parse_opts_t option bits */",
        "snippet": "ecma_value_t\necma_op_eval (ecma_string_t *code_p, /**< code string */\n              uint32_t parse_opts) /**< ecma_parse_opts_t option bits */\n{\n  ecma_value_t ret_value;\n\n  lit_utf8_size_t chars_num = ecma_string_get_size (code_p);\n  if (chars_num == 0)\n  {\n    ret_value = ECMA_VALUE_UNDEFINED;\n  }\n  else\n  {\n    ECMA_STRING_TO_UTF8_STRING (code_p, code_utf8_buffer_p, code_utf8_buffer_size);\n\n    ret_value = ecma_op_eval_chars_buffer (code_utf8_buffer_p,\n                                           chars_num,\n                                           parse_opts);\n\n    ECMA_FINALIZE_UTF8_STRING (code_utf8_buffer_p, code_utf8_buffer_size);\n  }\n\n  return ret_value;\n}",
        "begin_line": 43,
        "end_line": 66,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-eval.ecma_op_eval_chars_buffer#77",
        "src_path": "jerry-core/ecma/operations/ecma-eval.c",
        "class_name": "jerry-core.ecma.operations.ecma-eval",
        "signature": "jerry-core.ecma.operations.ecma-eval.ecma_op_eval_chars_buffer (const lit_utf8_byte_t *code_p, /**< code characters buffer */                            size_t code_buffer_size, /**< size of the buffer */                            uint32_t parse_opts) /**< ecma_parse_opts_t option bits */",
        "snippet": "ecma_value_t\necma_op_eval_chars_buffer (const lit_utf8_byte_t *code_p, /**< code characters buffer */\n                           size_t code_buffer_size, /**< size of the buffer */\n                           uint32_t parse_opts) /**< ecma_parse_opts_t option bits */\n{\n#if ENABLED (JERRY_PARSER)\n  JERRY_ASSERT (code_p != NULL);\n\n  ecma_compiled_code_t *bytecode_data_p;\n\n  uint32_t is_strict_call = ECMA_PARSE_STRICT_MODE | ECMA_PARSE_DIRECT_EVAL;\n\n  if ((parse_opts & is_strict_call) != is_strict_call)\n  {\n    parse_opts &= (uint32_t) ~ECMA_PARSE_STRICT_MODE;\n  }\n\n  parse_opts |= ECMA_PARSE_EVAL;\n\n#if ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ERROR_MESSAGES)\n  JERRY_CONTEXT (resource_name) = ecma_make_magic_string_value (LIT_MAGIC_STRING_RESOURCE_EVAL);\n#endif /* ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ERROR_MESSAGES) */\n\n#if ENABLED (JERRY_ES2015)\n  ECMA_CLEAR_LOCAL_PARSE_OPTS ();\n#endif /* ENABLED (JERRY_ES2015) */\n\n  ecma_value_t parse_status = parser_parse_script (NULL,\n                                                   0,\n                                                   code_p,\n                                                   code_buffer_size,\n                                                   parse_opts,\n                                                   &bytecode_data_p);\n\n  if (ECMA_IS_VALUE_ERROR (parse_status))\n  {\n    return parse_status;\n  }\n\n  return vm_run_eval (bytecode_data_p, parse_opts);\n#else /* !ENABLED (JERRY_PARSER) */\n  JERRY_UNUSED (code_p);\n  JERRY_UNUSED (code_buffer_size);\n  JERRY_UNUSED (parse_opts);\n\n  return ecma_raise_syntax_error (ECMA_ERR_MSG (\"The parser has been disabled.\"));\n#endif /* ENABLED (JERRY_PARSER) */\n}",
        "begin_line": 77,
        "end_line": 124,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-exceptions.ecma_new_standard_error#78",
        "src_path": "jerry-core/ecma/operations/ecma-exceptions.c",
        "class_name": "jerry-core.ecma.operations.ecma-exceptions",
        "signature": "jerry-core.ecma.operations.ecma-exceptions.ecma_new_standard_error (ecma_standard_error_t error_type) /**< native error type */",
        "snippet": "ecma_object_t *\necma_new_standard_error (ecma_standard_error_t error_type) /**< native error type */\n{\n#if ENABLED (JERRY_BUILTIN_ERRORS)\n  ecma_builtin_id_t prototype_id = ECMA_BUILTIN_ID__COUNT;\n\n  switch (error_type)\n  {\n    case ECMA_ERROR_EVAL:\n    {\n      prototype_id = ECMA_BUILTIN_ID_EVAL_ERROR_PROTOTYPE;\n      break;\n    }\n\n    case ECMA_ERROR_RANGE:\n    {\n      prototype_id = ECMA_BUILTIN_ID_RANGE_ERROR_PROTOTYPE;\n      break;\n    }\n\n    case ECMA_ERROR_REFERENCE:\n    {\n      prototype_id = ECMA_BUILTIN_ID_REFERENCE_ERROR_PROTOTYPE;\n      break;\n    }\n\n    case ECMA_ERROR_TYPE:\n    {\n      prototype_id = ECMA_BUILTIN_ID_TYPE_ERROR_PROTOTYPE;\n      break;\n    }\n\n    case ECMA_ERROR_URI:\n    {\n      prototype_id = ECMA_BUILTIN_ID_URI_ERROR_PROTOTYPE;\n      break;\n    }\n\n    case ECMA_ERROR_SYNTAX:\n    {\n      prototype_id = ECMA_BUILTIN_ID_SYNTAX_ERROR_PROTOTYPE;\n      break;\n    }\n\n    default:\n    {\n      JERRY_ASSERT (error_type == ECMA_ERROR_COMMON);\n\n      prototype_id = ECMA_BUILTIN_ID_ERROR_PROTOTYPE;\n      break;\n    }\n  }\n#else\n  JERRY_UNUSED (error_type);\n  ecma_builtin_id_t prototype_id = ECMA_BUILTIN_ID_ERROR_PROTOTYPE;\n#endif /* ENABLED (JERRY_BUILTIN_ERRORS) */\n\n  ecma_object_t *prototype_obj_p = ecma_builtin_get (prototype_id);\n\n  ecma_object_t *new_error_obj_p = ecma_create_object (prototype_obj_p,\n                                                       sizeof (ecma_extended_object_t),\n                                                       ECMA_OBJECT_TYPE_CLASS);\n\n  ((ecma_extended_object_t *) new_error_obj_p)->u.class_prop.class_id = LIT_MAGIC_STRING_ERROR_UL;\n\n#if ENABLED (JERRY_LINE_INFO)\n  /* The \"stack\" identifier is not a magic string. */\n  const char * const stack_id_p = \"stack\";\n\n  ecma_string_t *stack_str_p = ecma_new_ecma_string_from_utf8 ((const lit_utf8_byte_t *) stack_id_p, 5);\n\n  ecma_property_value_t *prop_value_p = ecma_create_named_data_property (new_error_obj_p,\n                                                                         stack_str_p,\n                                                                         ECMA_PROPERTY_CONFIGURABLE_WRITABLE,\n                                                                         NULL);\n  ecma_deref_ecma_string (stack_str_p);\n\n  ecma_value_t backtrace_value = vm_get_backtrace (0);\n\n  prop_value_p->value = backtrace_value;\n  ecma_deref_object (ecma_get_object_from_value (backtrace_value));\n#endif /* ENABLED (JERRY_LINE_INFO) */\n\n  return new_error_obj_p;\n}",
        "begin_line": 78,
        "end_line": 162,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-exceptions.ecma_new_standard_error_with_message#199",
        "src_path": "jerry-core/ecma/operations/ecma-exceptions.c",
        "class_name": "jerry-core.ecma.operations.ecma-exceptions",
        "signature": "jerry-core.ecma.operations.ecma-exceptions.ecma_new_standard_error_with_message (ecma_standard_error_t error_type, /**< native error type */                                       ecma_string_t *message_string_p) /**< message string */",
        "snippet": "ecma_object_t *\necma_new_standard_error_with_message (ecma_standard_error_t error_type, /**< native error type */\n                                      ecma_string_t *message_string_p) /**< message string */\n{\n  ecma_object_t *new_error_obj_p = ecma_new_standard_error (error_type);\n\n  ecma_property_value_t *prop_value_p;\n  prop_value_p = ecma_create_named_data_property (new_error_obj_p,\n                                                  ecma_get_magic_string (LIT_MAGIC_STRING_MESSAGE),\n                                                  ECMA_PROPERTY_CONFIGURABLE_WRITABLE,\n                                                  NULL);\n\n  ecma_ref_ecma_string (message_string_p);\n  prop_value_p->value = ecma_make_string_value (message_string_p);\n\n  return new_error_obj_p;\n}",
        "begin_line": 199,
        "end_line": 215,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_object_is_constructor#112",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_object_is_constructor (ecma_object_t *obj_p) /**< ecma object */",
        "snippet": "inline bool JERRY_ATTR_ALWAYS_INLINE\necma_object_is_constructor (ecma_object_t *obj_p) /**< ecma object */\n{\n  JERRY_ASSERT (!ecma_is_lexical_environment (obj_p));\n\n  ecma_object_type_t type = ecma_get_object_type (obj_p);\n\n  while (type == ECMA_OBJECT_TYPE_BOUND_FUNCTION)\n  {\n    ecma_bound_function_t *bound_func_p = (ecma_bound_function_t *) obj_p;\n\n    obj_p = ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t,\n                                                        bound_func_p->header.u.bound_function.target_function);\n\n    type = ecma_get_object_type (obj_p);\n  }\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_TYPE_IS_PROXY (type))\n  {\n    return ecma_is_constructor (((ecma_proxy_object_t *) obj_p)->target);\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  if (type == ECMA_OBJECT_TYPE_FUNCTION)\n  {\n    return (!ecma_get_object_is_builtin (obj_p) || !ecma_builtin_function_is_routine (obj_p));\n  }\n\n  return (type >= ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION);\n}",
        "begin_line": 112,
        "end_line": 142,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_create_external_function_object#498",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_create_external_function_object (ecma_external_handler_t handler_cb) /**< pointer to external native handler */",
        "snippet": "ecma_object_t *\necma_op_create_external_function_object (ecma_external_handler_t handler_cb) /**< pointer to external native handler */\n{\n  ecma_object_t *prototype_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_FUNCTION_PROTOTYPE);\n\n  ecma_object_t *function_obj_p;\n  function_obj_p = ecma_create_object (prototype_obj_p,\n                                       sizeof (ecma_extended_object_t),\n                                       ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION);\n\n  /*\n   * [[Class]] property is not stored explicitly for objects of ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION type.\n   *\n   * See also: ecma_object_get_class_name\n   */\n\n  ecma_extended_object_t *ext_func_obj_p = (ecma_extended_object_t *) function_obj_p;\n  ext_func_obj_p->u.external_handler_cb = handler_cb;\n\n  return function_obj_p;\n}",
        "begin_line": 498,
        "end_line": 518,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_create_function_object#218",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_create_function_object (ecma_object_t *scope_p, /**< function's scope */                                 const ecma_compiled_code_t *bytecode_data_p, /**< byte-code array */                                 ecma_builtin_id_t proto_id) /**< builtin id of the prototype object */",
        "snippet": "static ecma_object_t *\necma_op_create_function_object (ecma_object_t *scope_p, /**< function's scope */\n                                const ecma_compiled_code_t *bytecode_data_p, /**< byte-code array */\n                                ecma_builtin_id_t proto_id) /**< builtin id of the prototype object */\n{\n  JERRY_ASSERT (ecma_is_lexical_environment (scope_p));\n\n  /* 1., 4., 13. */\n  ecma_object_t *prototype_obj_p = ecma_builtin_get (proto_id);\n\n  size_t function_object_size = sizeof (ecma_extended_object_t);\n\n#if ENABLED (JERRY_SNAPSHOT_EXEC)\n  if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)\n  {\n    function_object_size = sizeof (ecma_static_function_t);\n  }\n#endif /* ENABLED (JERRY_SNAPSHOT_EXEC) */\n\n  ecma_object_t *func_p = ecma_create_object (prototype_obj_p,\n                                              function_object_size,\n                                              ECMA_OBJECT_TYPE_FUNCTION);\n\n  /* 2., 6., 7., 8. */\n  /*\n   * We don't setup [[Get]], [[Call]], [[Construct]], [[HasInstance]] for each function object.\n   * Instead we set the object's type to ECMA_OBJECT_TYPE_FUNCTION\n   * that defines which version of the routine should be used on demand.\n   */\n\n  /* 3. */\n  /*\n   * [[Class]] property is not stored explicitly for objects of ECMA_OBJECT_TYPE_FUNCTION type.\n   *\n   * See also: ecma_object_get_class_name\n   */\n\n  ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_p;\n\n  /* 9. */\n  ECMA_SET_NON_NULL_POINTER_TAG (ext_func_p->u.function.scope_cp, scope_p, 0);\n\n  /* 10., 11., 12. */\n\n#if ENABLED (JERRY_SNAPSHOT_EXEC)\n  if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)\n  {\n    ext_func_p->u.function.bytecode_cp = ECMA_NULL_POINTER;\n    ((ecma_static_function_t *) func_p)->bytecode_p = bytecode_data_p;\n  }\n  else\n#endif /* ENABLED (JERRY_SNAPSHOT_EXEC) */\n  {\n    ECMA_SET_INTERNAL_VALUE_POINTER (ext_func_p->u.function.bytecode_cp, bytecode_data_p);\n    ecma_bytecode_ref ((ecma_compiled_code_t *) bytecode_data_p);\n  }\n\n  /* 14., 15., 16., 17., 18. */\n  /*\n   * 'length' and 'prototype' properties are instantiated lazily\n   *\n   * See also: ecma_op_function_try_to_lazy_instantiate_property\n   */\n\n  return func_p;\n}",
        "begin_line": 218,
        "end_line": 283,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_create_simple_function_object#408",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_create_simple_function_object (ecma_object_t *scope_p, /**< function's scope */                                        const ecma_compiled_code_t *bytecode_data_p) /**< byte-code array */",
        "snippet": "ecma_object_t *\necma_op_create_simple_function_object (ecma_object_t *scope_p, /**< function's scope */\n                                       const ecma_compiled_code_t *bytecode_data_p) /**< byte-code array */\n{\n  return ecma_op_create_function_object (scope_p, bytecode_data_p, ECMA_BUILTIN_ID_FUNCTION_PROTOTYPE);\n}",
        "begin_line": 408,
        "end_line": 413,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_external_function_try_to_lazy_instantiate_property#1477",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_external_function_try_to_lazy_instantiate_property (ecma_object_t *object_p, /**< object */                                                             ecma_string_t *property_name_p) /**< property's name */",
        "snippet": "ecma_property_t *\necma_op_external_function_try_to_lazy_instantiate_property (ecma_object_t *object_p, /**< object */\n                                                            ecma_string_t *property_name_p) /**< property's name */\n{\n  JERRY_ASSERT (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION);\n\n  if (ecma_compare_ecma_string_to_magic_id (property_name_p, LIT_MAGIC_STRING_PROTOTYPE))\n  {\n    return ecma_op_lazy_instantiate_prototype_object (object_p);\n  }\n\n  return NULL;\n}",
        "begin_line": 1477,
        "end_line": 1489,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_call#1052",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_call (ecma_object_t *func_obj_p, /**< Function object */                        ecma_value_t this_arg_value, /**< 'this' argument's value */                        const ecma_value_t *arguments_list_p, /**< arguments list */                        ecma_length_t arguments_list_len) /**< length of arguments list */",
        "snippet": "ecma_value_t\necma_op_function_call (ecma_object_t *func_obj_p, /**< Function object */\n                       ecma_value_t this_arg_value, /**< 'this' argument's value */\n                       const ecma_value_t *arguments_list_p, /**< arguments list */\n                       ecma_length_t arguments_list_len) /**< length of arguments list */\n{\n  JERRY_ASSERT (func_obj_p != NULL\n                && !ecma_is_lexical_environment (func_obj_p));\n  JERRY_ASSERT (ecma_op_object_is_callable (func_obj_p));\n\n  ECMA_CHECK_STACK_USAGE ();\n\n  const ecma_object_type_t type = ecma_get_object_type (func_obj_p);\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_TYPE_IS_PROXY (type))\n  {\n    return ecma_proxy_object_call (func_obj_p, this_arg_value, arguments_list_p, arguments_list_len);\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n#if ENABLED (JERRY_ES2015)\n  ecma_object_t *old_new_target_p = JERRY_CONTEXT (current_new_target);\n  if (JERRY_UNLIKELY (!(JERRY_CONTEXT (status_flags) & ECMA_STATUS_DIRECT_EVAL)))\n  {\n    JERRY_CONTEXT (current_new_target) = NULL;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  ecma_value_t result;\n\n  if (JERRY_LIKELY (type == ECMA_OBJECT_TYPE_FUNCTION))\n  {\n    result = ecma_op_function_call_simple (func_obj_p, this_arg_value, arguments_list_p, arguments_list_len);\n  }\n  else if (type == ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION)\n  {\n    result = ecma_op_function_call_external (func_obj_p, this_arg_value, arguments_list_p, arguments_list_len);\n  }\n  else\n  {\n    result = ecma_op_function_call_bound (func_obj_p, arguments_list_p, arguments_list_len);\n  }\n\n#if ENABLED (JERRY_ES2015)\n  JERRY_CONTEXT (current_new_target) = old_new_target_p;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  return result;\n}",
        "begin_line": 1052,
        "end_line": 1101,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_call_external#932",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_call_external (ecma_object_t *func_obj_p, /**< Function object */                                 ecma_value_t this_arg_value, /**< 'this' argument's value */                                 const ecma_value_t *arguments_list_p, /**< arguments list */                                 ecma_length_t arguments_list_len) /**< length of arguments list */",
        "snippet": "static ecma_value_t JERRY_ATTR_NOINLINE\necma_op_function_call_external (ecma_object_t *func_obj_p, /**< Function object */\n                                ecma_value_t this_arg_value, /**< 'this' argument's value */\n                                const ecma_value_t *arguments_list_p, /**< arguments list */\n                                ecma_length_t arguments_list_len) /**< length of arguments list */\n\n{\n  JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION);\n  ecma_extended_object_t *ext_func_obj_p = (ecma_extended_object_t *) func_obj_p;\n  JERRY_ASSERT (ext_func_obj_p->u.external_handler_cb != NULL);\n\n  ecma_value_t ret_value = ext_func_obj_p->u.external_handler_cb (ecma_make_object_value (func_obj_p),\n                                                                  this_arg_value,\n                                                                  arguments_list_p,\n                                                                  arguments_list_len);\n  if (JERRY_UNLIKELY (ecma_is_value_error_reference (ret_value)))\n  {\n    ecma_raise_error_from_error_reference (ret_value);\n    return ECMA_VALUE_ERROR;\n  }\n\n#if ENABLED (JERRY_DEBUGGER)\n  JERRY_DEBUGGER_CLEAR_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);\n#endif /* ENABLED (JERRY_DEBUGGER) */\n  return ret_value;\n}",
        "begin_line": 932,
        "end_line": 957,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_call_simple#772",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_call_simple (ecma_object_t *func_obj_p, /**< Function object */                               ecma_value_t this_arg_value, /**< 'this' argument's value */                               const ecma_value_t *arguments_list_p, /**< arguments list */                               ecma_length_t arguments_list_len) /**< length of arguments list */",
        "snippet": "static ecma_value_t\necma_op_function_call_simple (ecma_object_t *func_obj_p, /**< Function object */\n                              ecma_value_t this_arg_value, /**< 'this' argument's value */\n                              const ecma_value_t *arguments_list_p, /**< arguments list */\n                              ecma_length_t arguments_list_len) /**< length of arguments list */\n{\n  JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_FUNCTION);\n\n  if (JERRY_UNLIKELY (ecma_get_object_is_builtin (func_obj_p)))\n  {\n    return ecma_builtin_dispatch_call (func_obj_p, this_arg_value, arguments_list_p, arguments_list_len);\n  }\n\n  /* Entering Function Code (ECMA-262 v5, 10.4.3) */\n  ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_obj_p;\n\n  ecma_object_t *scope_p = ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t,\n                                                                       ext_func_p->u.function.scope_cp);\n\n  /* 8. */\n  ecma_value_t this_binding = this_arg_value;\n  bool free_this_binding = false;\n\n  const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);\n  uint16_t status_flags = bytecode_data_p->status_flags;\n\n#if ENABLED (JERRY_ES2015)\n  bool is_construct_call = JERRY_CONTEXT (current_new_target) != NULL;\n  if (JERRY_UNLIKELY (status_flags & (CBC_CODE_FLAGS_CLASS_CONSTRUCTOR | CBC_CODE_FLAGS_GENERATOR)))\n  {\n    if (!is_construct_call && (status_flags & CBC_CODE_FLAGS_CLASS_CONSTRUCTOR))\n    {\n      return ecma_raise_type_error (ECMA_ERR_MSG (\"Class constructor cannot be invoked without 'new'.\"));\n    }\n\n    if ((status_flags & CBC_CODE_FLAGS_GENERATOR) && is_construct_call)\n    {\n      return ecma_raise_type_error (ECMA_ERR_MSG (\"Generator functions cannot be invoked with 'new'.\"));\n    }\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  /* 1. */\n#if ENABLED (JERRY_ES2015)\n  ecma_object_t *old_function_object_p = JERRY_CONTEXT (current_function_obj_p);\n\n  if (JERRY_UNLIKELY (status_flags & CBC_CODE_FLAGS_ARROW_FUNCTION))\n  {\n    ecma_arrow_function_t *arrow_func_p = (ecma_arrow_function_t *) func_obj_p;\n\n    if (ecma_is_value_undefined (arrow_func_p->new_target))\n    {\n      JERRY_CONTEXT (current_new_target) = NULL;\n    }\n    else\n    {\n      JERRY_CONTEXT (current_new_target) = ecma_get_object_from_value (arrow_func_p->new_target);\n    }\n    this_binding = arrow_func_p->this_binding;\n  }\n  else\n  {\n    JERRY_CONTEXT (current_function_obj_p) = func_obj_p;\n#endif /* ENABLED (JERRY_ES2015) */\n    if (!(status_flags & CBC_CODE_FLAGS_STRICT_MODE))\n    {\n      if (ecma_is_value_undefined (this_binding)\n          || ecma_is_value_null (this_binding))\n      {\n        /* 2. */\n        this_binding = ecma_make_object_value (ecma_builtin_get_global ());\n      }\n      else if (!ecma_is_value_object (this_binding))\n      {\n        /* 3., 4. */\n        this_binding = ecma_op_to_object (this_binding);\n        free_this_binding = true;\n\n        JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (this_binding));\n      }\n    }\n#if ENABLED (JERRY_ES2015)\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  /* 5. */\n  ecma_object_t *local_env_p;\n  if (status_flags & CBC_CODE_FLAGS_LEXICAL_ENV_NOT_NEEDED)\n  {\n    local_env_p = scope_p;\n  }\n  else\n  {\n    local_env_p = ecma_create_decl_lex_env (scope_p);\n    if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_IS_ARGUMENTS_NEEDED)\n    {\n      ecma_op_create_arguments_object (func_obj_p,\n                                       local_env_p,\n                                       arguments_list_p,\n                                       arguments_list_len,\n                                       bytecode_data_p);\n    }\n#if ENABLED (JERRY_ES2015)\n    // ECMAScript v6, 9.2.2.8\n    if (JERRY_UNLIKELY (status_flags & CBC_CODE_FLAGS_CLASS_CONSTRUCTOR))\n    {\n      ecma_value_t lexical_this;\n      lexical_this = (ECMA_GET_THIRD_BIT_FROM_POINTER_TAG (ext_func_p->u.function.scope_cp) ? ECMA_VALUE_UNINITIALIZED\n                                                                                            : this_binding);\n      ecma_op_init_this_binding (local_env_p, lexical_this);\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n  }\n\n  ecma_value_t ret_value = vm_run (bytecode_data_p,\n                                   this_binding,\n                                   local_env_p,\n                                   arguments_list_p,\n                                   arguments_list_len);\n\n#if ENABLED (JERRY_ES2015)\n  JERRY_CONTEXT (current_function_obj_p) = old_function_object_p;\n\n  /* ECMAScript v6, 9.2.2.13 */\n  if (ECMA_GET_THIRD_BIT_FROM_POINTER_TAG (ext_func_p->u.function.scope_cp))\n  {\n    if (!ECMA_IS_VALUE_ERROR (ret_value) && !ecma_is_value_object (ret_value))\n    {\n      if (!ecma_is_value_undefined (ret_value))\n      {\n        ecma_free_value (ret_value);\n        ret_value = ecma_raise_type_error (ECMA_ERR_MSG (\"Derived constructors may only return object or undefined.\"));\n      }\n      else\n      {\n        ret_value = ecma_op_get_this_binding (local_env_p);\n      }\n    }\n  }\n\n#endif /* ENABLED (JERRY_ES2015) */\n\n  if (!(status_flags & CBC_CODE_FLAGS_LEXICAL_ENV_NOT_NEEDED))\n  {\n    ecma_deref_object (local_env_p);\n  }\n\n  if (JERRY_UNLIKELY (free_this_binding))\n  {\n    ecma_free_value (this_binding);\n  }\n\n  return ret_value;\n}",
        "begin_line": 772,
        "end_line": 925,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_construct#1194",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_construct (ecma_object_t *func_obj_p, /**< Function object */                             ecma_object_t *new_target_p, /**< new target */                             const ecma_value_t *arguments_list_p, /**< arguments list */                             ecma_length_t arguments_list_len) /**< length of arguments list */",
        "snippet": "ecma_value_t\necma_op_function_construct (ecma_object_t *func_obj_p, /**< Function object */\n                            ecma_object_t *new_target_p, /**< new target */\n                            const ecma_value_t *arguments_list_p, /**< arguments list */\n                            ecma_length_t arguments_list_len) /**< length of arguments list */\n{\n  JERRY_ASSERT (func_obj_p != NULL\n                && !ecma_is_lexical_environment (func_obj_p));\n\n  const ecma_object_type_t type = ecma_get_object_type (func_obj_p);\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_TYPE_IS_PROXY (type))\n  {\n    return ecma_proxy_object_construct (func_obj_p,\n                                        new_target_p,\n                                        arguments_list_p,\n                                        arguments_list_len);\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  if (JERRY_UNLIKELY (type == ECMA_OBJECT_TYPE_BOUND_FUNCTION))\n  {\n    return ecma_op_function_construct_bound (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n  }\n\n  if (JERRY_UNLIKELY (type == ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION))\n  {\n    return ecma_op_function_construct_external (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n  }\n\n  JERRY_ASSERT (type == ECMA_OBJECT_TYPE_FUNCTION);\n\n  if (JERRY_UNLIKELY (ecma_get_object_is_builtin (func_obj_p)))\n  {\n    return ecma_builtin_dispatch_construct (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n  }\n\n  ecma_object_t *new_this_obj_p = NULL;\n  ecma_value_t this_arg;\n  ecma_extended_object_t *ext_func_obj_p = (ecma_extended_object_t *) func_obj_p;\n  const ecma_compiled_code_t *byte_code_p = ecma_op_function_get_compiled_code (ext_func_obj_p);\n\n  if (byte_code_p->status_flags & (CBC_CODE_FLAGS_ARROW_FUNCTION | CBC_CODE_FLAGS_ACCESSOR))\n  {\n    if (byte_code_p->status_flags & CBC_CODE_FLAGS_ARROW_FUNCTION)\n    {\n      return ecma_raise_type_error (ECMA_ERR_MSG (\"Arrow functions have no constructor.\"));\n    }\n\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Expected a constructor.\"));\n  }\n\n#if ENABLED (JERRY_ES2015)\n  /* 6. */\n  ecma_object_t *old_new_target_p = JERRY_CONTEXT (current_new_target);\n  JERRY_CONTEXT (current_new_target) = new_target_p;\n\n  /* 5. */\n  if (!ECMA_GET_THIRD_BIT_FROM_POINTER_TAG (ext_func_obj_p->u.function.scope_cp))\n  {\n#endif /* ENABLED (JERRY_ES2015) */\n    /* 5.a */\n    ecma_object_t *proto_p = ecma_op_get_prototype_from_constructor (new_target_p, ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);\n\n    /* 5.b */\n    if (JERRY_UNLIKELY (proto_p == NULL))\n    {\n      return ECMA_VALUE_ERROR;\n    }\n\n    new_this_obj_p = ecma_create_object (proto_p, 0, ECMA_OBJECT_TYPE_GENERAL);\n    ecma_deref_object (proto_p);\n    this_arg = ecma_make_object_value (new_this_obj_p);\n#if ENABLED (JERRY_ES2015)\n  }\n  else\n  {\n    this_arg = ECMA_VALUE_UNDEFINED;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  ecma_value_t ret_value = ecma_op_function_call_simple (func_obj_p, this_arg, arguments_list_p, arguments_list_len);\n\n#if ENABLED (JERRY_ES2015)\n  JERRY_CONTEXT (current_new_target) = old_new_target_p;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  /* 13.a */\n  if (ECMA_IS_VALUE_ERROR (ret_value) || ecma_is_value_object (ret_value))\n  {\n#if ENABLED (JERRY_ES2015)\n    if (new_this_obj_p != NULL)\n    {\n      ecma_deref_object (new_this_obj_p);\n    }\n#else /* !ENABLED (JERRY_ES2015) */\n    ecma_deref_object (new_this_obj_p);\n#endif /* ENABLED (JERRY_ES2015) */\n    return ret_value;\n  }\n\n  /* 13.b */\n  ecma_free_value (ret_value);\n  return this_arg;\n}",
        "begin_line": 1194,
        "end_line": 1299,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_get_compiled_code#525",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_get_compiled_code (ecma_extended_object_t *function_p) /**< function pointer */",
        "snippet": "inline const ecma_compiled_code_t * JERRY_ATTR_ALWAYS_INLINE\necma_op_function_get_compiled_code (ecma_extended_object_t *function_p) /**< function pointer */\n{\n#if ENABLED (JERRY_SNAPSHOT_EXEC)\n  if (function_p->u.function.bytecode_cp != ECMA_NULL_POINTER)\n  {\n    return ECMA_GET_INTERNAL_VALUE_POINTER (const ecma_compiled_code_t,\n                                            function_p->u.function.bytecode_cp);\n  }\n  else\n  {\n    return ((ecma_static_function_t *) function_p)->bytecode_p;\n  }\n#else /* !ENABLED (JERRY_SNAPSHOT_EXEC) */\n  return ECMA_GET_INTERNAL_VALUE_POINTER (const ecma_compiled_code_t,\n                                          function_p->u.function.bytecode_cp);\n#endif /* ENABLED (JERRY_SNAPSHOT_EXEC) */\n}",
        "begin_line": 525,
        "end_line": 542,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_get_prototype_from_constructor#735",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_get_prototype_from_constructor (ecma_object_t *ctor_obj_p, /**< constructor to get prototype from  */                                         ecma_builtin_id_t default_proto_id) /**< intrinsicDefaultProto */",
        "snippet": "ecma_object_t *\necma_op_get_prototype_from_constructor (ecma_object_t *ctor_obj_p, /**< constructor to get prototype from  */\n                                        ecma_builtin_id_t default_proto_id) /**< intrinsicDefaultProto */\n{\n  JERRY_ASSERT (ecma_object_is_constructor (ctor_obj_p));\n  JERRY_ASSERT (default_proto_id < ECMA_BUILTIN_ID__COUNT);\n\n  ecma_value_t proto = ecma_op_object_get_by_magic_id (ctor_obj_p, LIT_MAGIC_STRING_PROTOTYPE);\n\n  if (ECMA_IS_VALUE_ERROR (proto))\n  {\n    return NULL;\n  }\n\n  ecma_object_t *proto_obj_p;\n\n  if (!ecma_is_value_object (proto))\n  {\n    ecma_free_value (proto);\n    proto_obj_p = ecma_builtin_get (default_proto_id);\n    ecma_ref_object (proto_obj_p);\n  }\n  else\n  {\n    proto_obj_p = ecma_get_object_from_value (proto);\n  }\n\n  return proto_obj_p;\n}",
        "begin_line": 735,
        "end_line": 763,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_is_callable#99",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_is_callable (ecma_value_t value) /**< ecma value */",
        "snippet": "bool\necma_op_is_callable (ecma_value_t value) /**< ecma value */\n{\n  return (ecma_is_value_object (value)\n          && ecma_op_object_is_callable (ecma_get_object_from_value (value)));\n}",
        "begin_line": 99,
        "end_line": 104,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_object_is_callable#74",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_object_is_callable (ecma_object_t *obj_p) /**< ecma object */",
        "snippet": "inline bool JERRY_ATTR_ALWAYS_INLINE\necma_op_object_is_callable (ecma_object_t *obj_p) /**< ecma object */\n{\n  JERRY_ASSERT (!ecma_is_lexical_environment (obj_p));\n\n  const ecma_object_type_t type = ecma_get_object_type (obj_p);\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_TYPE_IS_PROXY (type))\n  {\n    return ecma_op_is_callable (((ecma_proxy_object_t *) obj_p)->target);\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  return type >= ECMA_OBJECT_TYPE_FUNCTION;\n}",
        "begin_line": 74,
        "end_line": 89,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-get-put-value.ecma_op_get_value_object_base#129",
        "src_path": "jerry-core/ecma/operations/ecma-get-put-value.c",
        "class_name": "jerry-core.ecma.operations.ecma-get-put-value",
        "signature": "jerry-core.ecma.operations.ecma-get-put-value.ecma_op_get_value_object_base (ecma_value_t base_value, /**< base value */                                ecma_string_t *property_name_p) /**< property name */",
        "snippet": "ecma_value_t\necma_op_get_value_object_base (ecma_value_t base_value, /**< base value */\n                               ecma_string_t *property_name_p) /**< property name */\n{\n  ecma_object_t *obj_p;\n\n  if (JERRY_UNLIKELY (ecma_is_value_object (base_value)))\n  {\n    obj_p = ecma_get_object_from_value (base_value);\n  }\n  else\n  {\n    ecma_builtin_id_t id = ECMA_BUILTIN_ID_OBJECT_PROTOTYPE;\n\n    if (JERRY_LIKELY (ecma_is_value_string (base_value)))\n    {\n      ecma_string_t *string_p = ecma_get_string_from_value (base_value);\n\n      if (ecma_string_is_length (property_name_p))\n      {\n        return ecma_make_uint32_value (ecma_string_get_length (string_p));\n      }\n\n      uint32_t index = ecma_string_get_array_index (property_name_p);\n\n      if (index != ECMA_STRING_NOT_ARRAY_INDEX\n          && index < ecma_string_get_length (string_p))\n      {\n        ecma_char_t char_at_idx = ecma_string_get_char_at_pos (string_p, index);\n        return ecma_make_string_value (ecma_new_ecma_string_from_code_unit (char_at_idx));\n      }\n\n#if ENABLED (JERRY_BUILTIN_STRING)\n      id = ECMA_BUILTIN_ID_STRING_PROTOTYPE;\n#endif /* ENABLED (JERRY_BUILTIN_STRING) */\n    }\n    else if (ecma_is_value_number (base_value))\n    {\n#if ENABLED (JERRY_BUILTIN_NUMBER)\n      id = ECMA_BUILTIN_ID_NUMBER_PROTOTYPE;\n#endif /* ENABLED (JERRY_BUILTIN_NUMBER) */\n    }\n#if ENABLED (JERRY_ES2015)\n    else if (ecma_is_value_symbol (base_value))\n    {\n      id = ECMA_BUILTIN_ID_SYMBOL_PROTOTYPE;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    else\n    {\n      JERRY_ASSERT (ecma_is_value_boolean (base_value));\n#if ENABLED (JERRY_BUILTIN_BOOLEAN)\n      id = ECMA_BUILTIN_ID_BOOLEAN_PROTOTYPE;\n#endif /* ENABLED (JERRY_BUILTIN_BOOLEAN) */\n    }\n\n    obj_p = ecma_builtin_get (id);\n  }\n\n  return ecma_op_object_get_with_receiver (obj_p, property_name_p, base_value);\n}",
        "begin_line": 129,
        "end_line": 189,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-get-put-value.ecma_op_put_value_lex_env_base#199",
        "src_path": "jerry-core/ecma/operations/ecma-get-put-value.c",
        "class_name": "jerry-core.ecma.operations.ecma-get-put-value",
        "signature": "jerry-core.ecma.operations.ecma-get-put-value.ecma_op_put_value_lex_env_base (ecma_object_t *lex_env_p, /**< lexical environment */                                 ecma_string_t *name_p, /**< variable name */                                 bool is_strict, /**< flag indicating strict mode */                                 ecma_value_t value) /**< ECMA-value */",
        "snippet": "ecma_value_t\necma_op_put_value_lex_env_base (ecma_object_t *lex_env_p, /**< lexical environment */\n                                ecma_string_t *name_p, /**< variable name */\n                                bool is_strict, /**< flag indicating strict mode */\n                                ecma_value_t value) /**< ECMA-value */\n{\n  JERRY_ASSERT (lex_env_p != NULL\n                && ecma_is_lexical_environment (lex_env_p));\n\n  while (true)\n  {\n    switch (ecma_get_lex_env_type (lex_env_p))\n    {\n      case ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE:\n      {\n        ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n        if (property_p != NULL)\n        {\n          if (ecma_is_property_writable (*property_p))\n          {\n            ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n#if ENABLED (JERRY_ES2015)\n            if (JERRY_UNLIKELY (property_value_p->value == ECMA_VALUE_UNINITIALIZED))\n            {\n              return ecma_raise_reference_error (ECMA_ERR_MSG (\"Variables declared by let/const must be\"\n                                                               \" initialized before writing their value.\"));\n            }\n#endif /* ENABLED (JERRY_ES2015) */\n\n            ecma_named_data_property_assign_value (lex_env_p, property_value_p, value);\n          }\n#if ENABLED (JERRY_ES2015)\n          else if (ecma_is_property_enumerable (*property_p))\n          {\n            return ecma_raise_type_error (ECMA_ERR_MSG (\"Constant bindings cannot be reassigned.\"));\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n          else if (is_strict)\n          {\n            return ecma_raise_type_error (ECMA_ERR_MSG (\"Binding cannot be set.\"));\n          }\n          return ECMA_VALUE_EMPTY;\n        }\n        break;\n      }\n#if ENABLED (JERRY_ES2015)\n      case ECMA_LEXICAL_ENVIRONMENT_HOME_OBJECT_BOUND:\n      {\n        break;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      default:\n      {\n        JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n\n        ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);\n\n        ecma_value_t has_property = ecma_op_object_has_property (binding_obj_p, name_p);\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n        if (ECMA_IS_VALUE_ERROR (has_property))\n        {\n          return has_property;\n        }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n        if (ecma_is_value_true (has_property))\n        {\n          ecma_value_t completion = ecma_op_object_put (binding_obj_p,\n                                                        name_p,\n                                                        value,\n                                                        is_strict);\n\n          if (ECMA_IS_VALUE_ERROR (completion))\n          {\n            return completion;\n          }\n\n          JERRY_ASSERT (ecma_is_value_boolean (completion));\n          return ECMA_VALUE_EMPTY;\n        }\n\n        break;\n      }\n    }\n\n    if (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);\n  }\n\n  if (is_strict)\n  {\n#if ENABLED (JERRY_ERROR_MESSAGES)\n    return ecma_raise_standard_error_with_format (ECMA_ERROR_REFERENCE,\n                                                  \"% is not defined\",\n                                                  ecma_make_string_value (name_p));\n#else /* !ENABLED (JERRY_ERROR_MESSAGES) */\n    return ecma_raise_reference_error (NULL);\n#endif /* ENABLED (JERRY_ERROR_MESSAGES) */\n  }\n\n  ecma_value_t completion = ecma_op_object_put (ecma_builtin_get_global (),\n                                                name_p,\n                                                value,\n                                                false);\n\n  JERRY_ASSERT (ecma_is_value_boolean (completion));\n\n  return ECMA_VALUE_EMPTY;\n}",
        "begin_line": 199,
        "end_line": 314,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_get_global_environment#76",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_get_global_environment (void)",
        "snippet": "ecma_object_t *\necma_get_global_environment (void)\n{\n  JERRY_ASSERT (JERRY_CONTEXT (ecma_global_env_cp) != JMEM_CP_NULL);\n  return ECMA_GET_NON_NULL_POINTER (ecma_object_t, JERRY_CONTEXT (ecma_global_env_cp));\n}",
        "begin_line": 76,
        "end_line": 81,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_get_global_scope#105",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_get_global_scope (void)",
        "snippet": "ecma_object_t *\necma_get_global_scope (void)\n{\n#if ENABLED (JERRY_ES2015)\n  JERRY_ASSERT (JERRY_CONTEXT (ecma_global_scope_cp) != JMEM_CP_NULL);\n  return ECMA_GET_NON_NULL_POINTER (ecma_object_t, JERRY_CONTEXT (ecma_global_scope_cp));\n#else /* !ENABLED (JERRY_ES2015) */\n  return ecma_get_global_environment ();\n#endif /* !ENABLED (JERRY_ES2015) */\n}",
        "begin_line": 105,
        "end_line": 114,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_init_global_environment#39",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_init_global_environment (void)",
        "snippet": "void\necma_init_global_environment (void)\n{\n  ecma_object_t *glob_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_GLOBAL);\n\n  ecma_object_t *global_lex_env_p = ecma_create_object_lex_env (NULL,\n                                                                glob_obj_p,\n                                                                ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n  ECMA_SET_NON_NULL_POINTER (JERRY_CONTEXT (ecma_global_env_cp), global_lex_env_p);\n#if ENABLED (JERRY_ES2015)\n  ECMA_SET_NON_NULL_POINTER (JERRY_CONTEXT (ecma_global_scope_cp), global_lex_env_p);\n#endif /* ENABLED (JERRY_ES2015) */\n}",
        "begin_line": 39,
        "end_line": 51,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_create_immutable_binding#415",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_create_immutable_binding (ecma_object_t *lex_env_p, /**< lexical environment */                                   ecma_string_t *name_p, /**< argument N */                                   ecma_value_t value) /**< argument V */",
        "snippet": "void\necma_op_create_immutable_binding (ecma_object_t *lex_env_p, /**< lexical environment */\n                                  ecma_string_t *name_p, /**< argument N */\n                                  ecma_value_t value) /**< argument V */\n{\n  JERRY_ASSERT (lex_env_p != NULL\n                && ecma_is_lexical_environment (lex_env_p));\n  JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);\n\n  /*\n   * Warning:\n   *         Whether immutable bindings are deletable seems not to be defined by ECMA v5.\n   */\n  ecma_property_value_t *prop_value_p = ecma_create_named_data_property (lex_env_p,\n                                                                         name_p,\n                                                                         ECMA_PROPERTY_FIXED,\n                                                                         NULL);\n\n  prop_value_p->value = ecma_copy_value_if_not_object (value);\n}",
        "begin_line": 415,
        "end_line": 434,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_create_mutable_binding#158",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_create_mutable_binding (ecma_object_t *lex_env_p, /**< lexical environment */                                 ecma_string_t *name_p, /**< argument N */                                 bool is_deletable) /**< argument D */",
        "snippet": "ecma_value_t\necma_op_create_mutable_binding (ecma_object_t *lex_env_p, /**< lexical environment */\n                                ecma_string_t *name_p, /**< argument N */\n                                bool is_deletable) /**< argument D */\n{\n  JERRY_ASSERT (lex_env_p != NULL\n                && ecma_is_lexical_environment (lex_env_p));\n  JERRY_ASSERT (name_p != NULL);\n\n  if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n  {\n    uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;\n\n    if (is_deletable)\n    {\n      prop_attributes = (uint8_t) (prop_attributes | ECMA_PROPERTY_FLAG_CONFIGURABLE);\n    }\n\n    ecma_create_named_data_property (lex_env_p,\n                                     name_p,\n                                     prop_attributes,\n                                     NULL);\n  }\n  else\n  {\n    JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n\n    ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);\n\n    if (!ecma_op_ordinary_object_is_extensible (binding_obj_p))\n    {\n      return ECMA_VALUE_EMPTY;\n    }\n\n    const uint32_t flags = ECMA_PROPERTY_ENUMERABLE_WRITABLE | ECMA_IS_THROW;\n\n    ecma_value_t completion = ecma_builtin_helper_def_prop (binding_obj_p,\n                                                            name_p,\n                                                            ECMA_VALUE_UNDEFINED,\n                                                            is_deletable ? flags | ECMA_PROPERTY_FLAG_CONFIGURABLE\n                                                                         : flags);\n\n    if (ECMA_IS_VALUE_ERROR (completion))\n    {\n      return completion;\n    }\n    else\n    {\n      JERRY_ASSERT (ecma_is_value_boolean (completion));\n    }\n  }\n\n  return ECMA_VALUE_EMPTY;\n}",
        "begin_line": 158,
        "end_line": 211,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_get_binding_value#283",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_get_binding_value (ecma_object_t *lex_env_p, /**< lexical environment */                            ecma_string_t *name_p, /**< argument N */                            bool is_strict) /**< argument S */",
        "snippet": "ecma_value_t\necma_op_get_binding_value (ecma_object_t *lex_env_p, /**< lexical environment */\n                           ecma_string_t *name_p, /**< argument N */\n                           bool is_strict) /**< argument S */\n{\n  JERRY_ASSERT (lex_env_p != NULL\n                && ecma_is_lexical_environment (lex_env_p));\n  JERRY_ASSERT (name_p != NULL);\n\n  if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n  {\n    ecma_property_value_t *prop_value_p = ecma_get_named_data_property (lex_env_p, name_p);\n\n    return ecma_copy_value (prop_value_p->value);\n  }\n  else\n  {\n    JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n\n    ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);\n\n    ecma_value_t result = ecma_op_object_find (binding_obj_p, name_p);\n\n    if (ECMA_IS_VALUE_ERROR (result))\n    {\n      return result;\n    }\n\n    if (!ecma_is_value_found (result))\n    {\n      if (is_strict)\n      {\n        result = ecma_raise_reference_error (ECMA_ERR_MSG (\"Binding does not exist or is uninitialised.\"));\n      }\n      else\n      {\n        result = ECMA_VALUE_UNDEFINED;\n      }\n    }\n\n    return result;\n  }\n}",
        "begin_line": 283,
        "end_line": 325,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_has_binding#127",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_has_binding (ecma_object_t *lex_env_p, /**< lexical environment */                      ecma_string_t *name_p) /**< argument N */",
        "snippet": "ecma_value_t\necma_op_has_binding (ecma_object_t *lex_env_p, /**< lexical environment */\n                     ecma_string_t *name_p) /**< argument N */\n{\n  JERRY_ASSERT (lex_env_p != NULL\n                && ecma_is_lexical_environment (lex_env_p));\n\n  ecma_lexical_environment_type_t lex_env_type = ecma_get_lex_env_type (lex_env_p);\n\n  if (lex_env_type == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n  {\n    ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n    return ecma_make_boolean_value (property_p != NULL);\n  }\n\n  JERRY_ASSERT (lex_env_type == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n\n  ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);\n\n  return ecma_op_object_has_property (binding_obj_p, name_p);\n}",
        "begin_line": 127,
        "end_line": 148,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_set_mutable_binding#221",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_set_mutable_binding (ecma_object_t *lex_env_p, /**< lexical environment */                              ecma_string_t *name_p, /**< argument N */                              ecma_value_t value, /**< argument V */                              bool is_strict) /**< argument S */",
        "snippet": "ecma_value_t\necma_op_set_mutable_binding (ecma_object_t *lex_env_p, /**< lexical environment */\n                             ecma_string_t *name_p, /**< argument N */\n                             ecma_value_t value, /**< argument V */\n                             bool is_strict) /**< argument S */\n{\n  JERRY_ASSERT (lex_env_p != NULL\n                && ecma_is_lexical_environment (lex_env_p));\n  JERRY_ASSERT (name_p != NULL);\n\n  if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n  {\n    ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n    JERRY_ASSERT (property_p != NULL\n                  && ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA);\n\n    if (ecma_is_property_writable (*property_p))\n    {\n      ecma_named_data_property_assign_value (lex_env_p, ECMA_PROPERTY_VALUE_PTR (property_p), value);\n    }\n#if ENABLED (JERRY_ES2015)\n    else if (ecma_is_property_enumerable (*property_p))\n    {\n      return ecma_raise_type_error (ECMA_ERR_MSG (\"Constant bindings cannot be reassigned.\"));\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    else if (is_strict)\n    {\n      return ecma_raise_type_error (ECMA_ERR_MSG (\"Binding cannot be set.\"));\n    }\n  }\n  else\n  {\n    JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n\n    ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);\n\n    ecma_value_t completion = ecma_op_object_put (binding_obj_p,\n                                                  name_p,\n                                                  value,\n                                                  is_strict);\n\n    if (ECMA_IS_VALUE_ERROR (completion))\n    {\n      return completion;\n    }\n\n    JERRY_ASSERT (ecma_is_value_boolean (completion));\n  }\n\n  return ECMA_VALUE_EMPTY;\n}",
        "begin_line": 221,
        "end_line": 273,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects-arguments.ecma_op_create_arguments_object#42",
        "src_path": "jerry-core/ecma/operations/ecma-objects-arguments.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects-arguments",
        "signature": "jerry-core.ecma.operations.ecma-objects-arguments.ecma_op_create_arguments_object (ecma_object_t *func_obj_p, /**< callee function */                                  ecma_object_t *lex_env_p, /**< lexical environment the Arguments                                                                 object is created for */                                  const ecma_value_t *arguments_list_p, /**< arguments list */                                  ecma_length_t arguments_number, /**< length of arguments list */                                  const ecma_compiled_code_t *bytecode_data_p) /**< byte code */",
        "snippet": "void\necma_op_create_arguments_object (ecma_object_t *func_obj_p, /**< callee function */\n                                 ecma_object_t *lex_env_p, /**< lexical environment the Arguments\n                                                                object is created for */\n                                 const ecma_value_t *arguments_list_p, /**< arguments list */\n                                 ecma_length_t arguments_number, /**< length of arguments list */\n                                 const ecma_compiled_code_t *bytecode_data_p) /**< byte code */\n{\n  bool is_strict = (bytecode_data_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE) != 0;\n\n  ecma_length_t formal_params_number;\n\n  if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n  {\n    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_data_p;\n\n    formal_params_number = args_p->argument_end;\n  }\n  else\n  {\n    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_data_p;\n\n    formal_params_number = args_p->argument_end;\n  }\n\n  ecma_object_t *prototype_p = ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);\n\n  ecma_object_t *obj_p;\n\n  if ((bytecode_data_p->status_flags & CBC_CODE_FLAGS_MAPPED_ARGUMENTS_NEEDED)\n      && arguments_number > 0\n      && formal_params_number > 0)\n  {\n    size_t formal_params_size = formal_params_number * sizeof (ecma_value_t);\n\n    obj_p = ecma_create_object (prototype_p,\n                                sizeof (ecma_extended_object_t) + formal_params_size,\n                                ECMA_OBJECT_TYPE_PSEUDO_ARRAY);\n\n    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n    ext_object_p->u.pseudo_array.type = ECMA_PSEUDO_ARRAY_ARGUMENTS;\n\n    ECMA_SET_INTERNAL_VALUE_POINTER (ext_object_p->u.pseudo_array.u2.lex_env_cp, lex_env_p);\n\n    ext_object_p->u.pseudo_array.u1.length = (uint16_t) formal_params_number;\n\n    ecma_value_t *arg_Literal_p = (ecma_value_t *) (ext_object_p + 1);\n\n    uint8_t *byte_p = (uint8_t *) bytecode_data_p;\n    byte_p += ((size_t) bytecode_data_p->size) << JMEM_ALIGNMENT_LOG;\n    byte_p -= formal_params_size;\n\n    memcpy (arg_Literal_p, byte_p, formal_params_size);\n\n    for (ecma_length_t i = 0; i < formal_params_number; i++)\n    {\n      if (arg_Literal_p[i] != ECMA_VALUE_EMPTY)\n      {\n        ecma_string_t *name_p = ecma_get_string_from_value (arg_Literal_p[i]);\n        ecma_ref_ecma_string (name_p);\n      }\n    }\n  }\n  else\n  {\n    obj_p = ecma_create_object (prototype_p, sizeof (ecma_extended_object_t), ECMA_OBJECT_TYPE_CLASS);\n\n    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n    ext_object_p->u.class_prop.class_id = LIT_MAGIC_STRING_ARGUMENTS_UL;\n  }\n\n  ecma_property_value_t *prop_value_p;\n\n  /* 11.a, 11.b */\n  for (ecma_length_t index = 0;\n       index < arguments_number;\n       index++)\n  {\n    ecma_string_t *index_string_p = ecma_new_ecma_string_from_uint32 (index);\n\n    prop_value_p = ecma_create_named_data_property (obj_p,\n                                                    index_string_p,\n                                                    ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,\n                                                    NULL);\n\n    prop_value_p->value = ecma_copy_value_if_not_object (arguments_list_p[index]);\n\n    ecma_deref_ecma_string (index_string_p);\n  }\n\n  /* 7. */\n  prop_value_p = ecma_create_named_data_property (obj_p,\n                                                  ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH),\n                                                  ECMA_PROPERTY_CONFIGURABLE_WRITABLE,\n                                                  NULL);\n\n  prop_value_p->value = ecma_make_uint32_value (arguments_number);\n\n  ecma_property_descriptor_t prop_desc = ecma_make_empty_property_descriptor ();\n\n#if ENABLED (JERRY_ES2015)\n  /* ECMAScript v6, 9.4.4.6.7, 9.4.4.7.22 */\n  ecma_string_t *symbol_p = ecma_op_get_global_symbol (LIT_GLOBAL_SYMBOL_ITERATOR);\n\n  prop_value_p = ecma_create_named_data_property (obj_p,\n                                                  symbol_p,\n                                                  ECMA_PROPERTY_CONFIGURABLE_WRITABLE,\n                                                  NULL);\n  ecma_deref_ecma_string (symbol_p);\n  prop_value_p->value = ecma_op_object_get_by_magic_id (ecma_builtin_get (ECMA_BUILTIN_ID_INTRINSIC_OBJECT),\n                                                        LIT_INTERNAL_MAGIC_STRING_ARRAY_PROTOTYPE_VALUES);\n\n  JERRY_ASSERT (ecma_is_value_object (prop_value_p->value));\n  ecma_deref_object (ecma_get_object_from_value (prop_value_p->value));\n#endif /* ENABLED (JERRY_ES2015) */\n\n  /* 13. */\n  if (!is_strict)\n  {\n    prop_value_p = ecma_create_named_data_property (obj_p,\n                                                    ecma_get_magic_string (LIT_MAGIC_STRING_CALLEE),\n                                                    ECMA_PROPERTY_CONFIGURABLE_WRITABLE,\n                                                    NULL);\n\n    prop_value_p->value = ecma_make_object_value (func_obj_p);\n  }\n  else\n  {\n    ecma_object_t *thrower_p = ecma_builtin_get (ECMA_BUILTIN_ID_TYPE_ERROR_THROWER);\n\n    /* 14. */\n    prop_desc = ecma_make_empty_property_descriptor ();\n    {\n      prop_desc.flags = (ECMA_PROP_IS_GET_DEFINED\n                         | ECMA_PROP_IS_SET_DEFINED\n                         | ECMA_PROP_IS_ENUMERABLE_DEFINED\n                         | ECMA_PROP_IS_CONFIGURABLE_DEFINED);\n    }\n    prop_desc.set_p = thrower_p;\n    prop_desc.get_p = thrower_p;\n\n    ecma_value_t completion = ecma_op_object_define_own_property (obj_p,\n                                                                  ecma_get_magic_string (LIT_MAGIC_STRING_CALLEE),\n                                                                  &prop_desc);\n\n    JERRY_ASSERT (ecma_is_value_true (completion));\n\n    completion = ecma_op_object_define_own_property (obj_p,\n                                                     ecma_get_magic_string (LIT_MAGIC_STRING_CALLER),\n                                                     &prop_desc);\n    JERRY_ASSERT (ecma_is_value_true (completion));\n  }\n\n  ecma_string_t *arguments_string_p = ecma_get_magic_string (LIT_MAGIC_STRING_ARGUMENTS);\n\n  if (is_strict)\n  {\n    ecma_op_create_immutable_binding (lex_env_p,\n                                      arguments_string_p,\n                                      ecma_make_object_value (obj_p));\n  }\n  else\n  {\n    ecma_value_t completion = ecma_op_create_mutable_binding (lex_env_p,\n                                                              arguments_string_p,\n                                                              false);\n    JERRY_ASSERT (ecma_is_value_empty (completion));\n\n    completion = ecma_op_set_mutable_binding (lex_env_p,\n                                              arguments_string_p,\n                                              ecma_make_object_value (obj_p),\n                                              false);\n\n    JERRY_ASSERT (ecma_is_value_empty (completion));\n  }\n\n  ecma_deref_object (obj_p);\n}",
        "begin_line": 42,
        "end_line": 220,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects-general.ecma_op_general_object_define_own_property#360",
        "src_path": "jerry-core/ecma/operations/ecma-objects-general.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects-general",
        "signature": "jerry-core.ecma.operations.ecma-objects-general.ecma_op_general_object_define_own_property (ecma_object_t *object_p, /**< the object */                                             ecma_string_t *property_name_p, /**< property name */                                             const ecma_property_descriptor_t *property_desc_p) /**< property                                                                                                 *   descriptor */",
        "snippet": "ecma_value_t\necma_op_general_object_define_own_property (ecma_object_t *object_p, /**< the object */\n                                            ecma_string_t *property_name_p, /**< property name */\n                                            const ecma_property_descriptor_t *property_desc_p) /**< property\n                                                                                                *   descriptor */\n{\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_IS_PROXY (object_p))\n  {\n    return ecma_proxy_object_define_own_property (object_p, property_name_p, property_desc_p);\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  JERRY_ASSERT (object_p != NULL\n                && !ecma_is_lexical_environment (object_p));\n  JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));\n  JERRY_ASSERT (property_name_p != NULL);\n\n  ecma_property_types_t property_desc_type = ECMA_PROPERTY_TYPE_GENERIC;\n\n  if (property_desc_p->flags & (ECMA_PROP_IS_VALUE_DEFINED | ECMA_PROP_IS_WRITABLE_DEFINED))\n  {\n    /* A property descriptor cannot be both named data and named accessor. */\n    JERRY_ASSERT ((property_desc_p->flags & (ECMA_PROP_IS_GET_DEFINED | ECMA_PROP_IS_SET_DEFINED))\n                   != (ECMA_PROP_IS_GET_DEFINED | ECMA_PROP_IS_SET_DEFINED));\n    property_desc_type = ECMA_PROPERTY_TYPE_NAMEDDATA;\n  }\n  else if (property_desc_p->flags & (ECMA_PROP_IS_GET_DEFINED | ECMA_PROP_IS_SET_DEFINED))\n  {\n    JERRY_ASSERT (!(property_desc_p->flags & ECMA_PROP_IS_WRITABLE_DEFINED));\n    property_desc_type = ECMA_PROPERTY_TYPE_NAMEDACCESSOR;\n  }\n\n  /* These three asserts ensures that a new property is created with the appropriate default flags.\n   * E.g. if ECMA_PROP_IS_CONFIGURABLE_DEFINED is false, the newly created property must be non-configurable. */\n  JERRY_ASSERT ((property_desc_p->flags & ECMA_PROP_IS_CONFIGURABLE_DEFINED)\n                || !(property_desc_p->flags & ECMA_PROP_IS_CONFIGURABLE));\n  JERRY_ASSERT ((property_desc_p->flags & ECMA_PROP_IS_ENUMERABLE_DEFINED)\n                || !(property_desc_p->flags & ECMA_PROP_IS_ENUMERABLE));\n  JERRY_ASSERT ((property_desc_p->flags & ECMA_PROP_IS_WRITABLE_DEFINED)\n                || !(property_desc_p->flags & ECMA_PROP_IS_WRITABLE));\n\n  /* 1. */\n  ecma_extended_property_ref_t ext_property_ref = { .property_ref.value_p = NULL, .property_p = NULL };\n  ecma_property_t current_prop;\n\n  current_prop = ecma_op_object_get_own_property (object_p,\n                                                  property_name_p,\n                                                  &ext_property_ref.property_ref,\n                                                  ECMA_PROPERTY_GET_VALUE | ECMA_PROPERTY_GET_EXT_REFERENCE);\n\n  if (current_prop == ECMA_PROPERTY_TYPE_NOT_FOUND || current_prop == ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP)\n  {\n    /* 3. */\n    if (!ecma_op_ordinary_object_is_extensible (object_p))\n    {\n      /* 2. */\n      return ecma_reject (property_desc_p->flags & ECMA_PROP_IS_THROW);\n    }\n\n    /* 4. */\n    uint8_t prop_attributes = (uint8_t) (property_desc_p->flags & ECMA_PROPERTY_FLAGS_MASK);\n\n    if (property_desc_type != ECMA_PROPERTY_TYPE_NAMEDACCESSOR)\n    {\n      /* a. */\n      JERRY_ASSERT (property_desc_type == ECMA_PROPERTY_TYPE_GENERIC\n                    || property_desc_type == ECMA_PROPERTY_TYPE_NAMEDDATA);\n\n      ecma_property_value_t *new_prop_value_p = ecma_create_named_data_property (object_p,\n                                                                                 property_name_p,\n                                                                                 prop_attributes,\n                                                                                 NULL);\n\n      JERRY_ASSERT ((property_desc_p->flags & ECMA_PROP_IS_VALUE_DEFINED)\n                    || ecma_is_value_undefined (property_desc_p->value));\n\n      new_prop_value_p->value = ecma_copy_value_if_not_object (property_desc_p->value);\n    }\n    else\n    {\n      /* b. */\n\n      ecma_create_named_accessor_property (object_p,\n                                           property_name_p,\n                                           property_desc_p->get_p,\n                                           property_desc_p->set_p,\n                                           prop_attributes,\n                                           NULL);\n    }\n\n    return ECMA_VALUE_TRUE;\n  }\n\n  /* 6. */\n  ecma_property_types_t current_property_type = ECMA_PROPERTY_GET_TYPE (current_prop);\n  const bool is_current_configurable = ecma_is_property_configurable (current_prop);\n\n  JERRY_ASSERT (current_property_type == ECMA_PROPERTY_TYPE_NAMEDDATA\n                || current_property_type == ECMA_PROPERTY_TYPE_NAMEDACCESSOR\n                || current_property_type == ECMA_PROPERTY_TYPE_VIRTUAL);\n\n  /* 7. a., b. */\n  bool is_enumerable = (property_desc_p->flags & ECMA_PROP_IS_ENUMERABLE) != 0;\n  if (!is_current_configurable\n      && ((property_desc_p->flags & ECMA_PROP_IS_CONFIGURABLE)\n          || ((property_desc_p->flags & ECMA_PROP_IS_ENUMERABLE_DEFINED)\n              && (is_enumerable != ecma_is_property_enumerable (current_prop)))))\n  {\n    if (current_property_type == ECMA_PROPERTY_TYPE_VIRTUAL)\n    {\n      ecma_free_value (ext_property_ref.property_ref.virtual_value);\n    }\n    return ecma_reject (property_desc_p->flags & ECMA_PROP_IS_THROW);\n  }\n\n  if (current_property_type == ECMA_PROPERTY_TYPE_VIRTUAL)\n  {\n    JERRY_ASSERT (!is_current_configurable && !ecma_is_property_writable (current_prop));\n\n    ecma_value_t result = ECMA_VALUE_TRUE;\n\n    if (property_desc_type == ECMA_PROPERTY_TYPE_NAMEDACCESSOR\n        || (property_desc_p->flags & ECMA_PROP_IS_WRITABLE)\n        || ((property_desc_p->flags & ECMA_PROP_IS_VALUE_DEFINED)\n            && !ecma_op_same_value (property_desc_p->value,\n                                    ext_property_ref.property_ref.virtual_value)))\n    {\n      result = ecma_reject (property_desc_p->flags & ECMA_PROP_IS_THROW);\n    }\n\n    ecma_free_value (ext_property_ref.property_ref.virtual_value);\n    return result;\n  }\n\n  /* 8. */\n  if (property_desc_type == ECMA_PROPERTY_TYPE_GENERIC)\n  {\n    /* No action required. */\n  }\n  else if (JERRY_LIKELY (property_desc_type == current_property_type))\n  {\n    /* If property is configurable, there is no need for checks. */\n    if (JERRY_UNLIKELY (!is_current_configurable))\n    {\n      if (property_desc_type == ECMA_PROPERTY_TYPE_NAMEDDATA)\n      {\n        /* 10. a. i. & ii. */\n        if (!ecma_is_property_writable (current_prop)\n            && ((property_desc_p->flags & ECMA_PROP_IS_WRITABLE)\n                || ((property_desc_p->flags & ECMA_PROP_IS_VALUE_DEFINED)\n                    && !ecma_op_same_value (property_desc_p->value,\n                                            ext_property_ref.property_ref.value_p->value))))\n        {\n          return ecma_reject (property_desc_p->flags & ECMA_PROP_IS_THROW);\n        }\n      }\n      else\n      {\n        /* 11. */\n\n        /* a. */\n        ecma_property_value_t *value_p = ext_property_ref.property_ref.value_p;\n\n        ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (value_p);\n        jmem_cpointer_t prop_desc_getter_cp, prop_desc_setter_cp;\n        ECMA_SET_POINTER (prop_desc_getter_cp, property_desc_p->get_p);\n        ECMA_SET_POINTER (prop_desc_setter_cp, property_desc_p->set_p);\n\n        if (((property_desc_p->flags & ECMA_PROP_IS_GET_DEFINED)\n             && prop_desc_getter_cp != get_set_pair_p->getter_cp)\n            || ((property_desc_p->flags & ECMA_PROP_IS_SET_DEFINED)\n                && prop_desc_setter_cp != get_set_pair_p->setter_cp))\n        {\n          /* i., ii. */\n          return ecma_reject (property_desc_p->flags & ECMA_PROP_IS_THROW);\n        }\n      }\n    }\n  }\n  else\n  {\n    /* 9. */\n    if (!is_current_configurable)\n    {\n      /* a. */\n      return ecma_reject (property_desc_p->flags & ECMA_PROP_IS_THROW);\n    }\n\n    ecma_property_value_t *value_p = ext_property_ref.property_ref.value_p;\n\n    if (property_desc_type == ECMA_PROPERTY_TYPE_NAMEDACCESSOR)\n    {\n      JERRY_ASSERT (current_property_type == ECMA_PROPERTY_TYPE_NAMEDDATA);\n      ecma_free_value_if_not_object (value_p->value);\n\n#if ENABLED (JERRY_CPOINTER_32_BIT)\n      ecma_getter_setter_pointers_t *getter_setter_pair_p;\n      getter_setter_pair_p = jmem_pools_alloc (sizeof (ecma_getter_setter_pointers_t));\n      getter_setter_pair_p->getter_cp = JMEM_CP_NULL;\n      getter_setter_pair_p->setter_cp = JMEM_CP_NULL;\n      ECMA_SET_NON_NULL_POINTER (value_p->getter_setter_pair_cp, getter_setter_pair_p);\n#else /* !ENABLED (JERRY_CPOINTER_32_BIT) */\n      value_p->getter_setter_pair.getter_cp = JMEM_CP_NULL;\n      value_p->getter_setter_pair.setter_cp = JMEM_CP_NULL;\n#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */\n    }\n    else\n    {\n      JERRY_ASSERT (current_property_type == ECMA_PROPERTY_TYPE_NAMEDACCESSOR);\n#if ENABLED (JERRY_CPOINTER_32_BIT)\n      ecma_getter_setter_pointers_t *getter_setter_pair_p;\n      getter_setter_pair_p = ECMA_GET_NON_NULL_POINTER (ecma_getter_setter_pointers_t,\n                                                        value_p->getter_setter_pair_cp);\n      jmem_pools_free (getter_setter_pair_p, sizeof (ecma_getter_setter_pointers_t));\n#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */\n      value_p->value = ECMA_VALUE_UNDEFINED;\n    }\n\n    /* Update flags */\n    ecma_property_t prop_flags = *(ext_property_ref.property_p);\n    prop_flags = (ecma_property_t) (prop_flags & ~(ECMA_PROPERTY_TYPE_MASK | ECMA_PROPERTY_FLAG_WRITABLE));\n    prop_flags = (ecma_property_t) (prop_flags | property_desc_type);\n    *(ext_property_ref.property_p) = prop_flags;\n  }\n\n  /* 12. */\n  if (property_desc_type == ECMA_PROPERTY_TYPE_NAMEDDATA)\n  {\n    JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*ext_property_ref.property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA);\n\n    if (property_desc_p->flags & ECMA_PROP_IS_VALUE_DEFINED)\n    {\n      ecma_named_data_property_assign_value (object_p,\n                                             ext_property_ref.property_ref.value_p,\n                                             property_desc_p->value);\n    }\n\n    if (property_desc_p->flags & ECMA_PROP_IS_WRITABLE_DEFINED)\n    {\n      ecma_set_property_writable_attr (ext_property_ref.property_p, (property_desc_p->flags & ECMA_PROP_IS_WRITABLE));\n    }\n  }\n  else if (property_desc_type == ECMA_PROPERTY_TYPE_NAMEDACCESSOR)\n  {\n    JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*ext_property_ref.property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR);\n\n    if (property_desc_p->flags & ECMA_PROP_IS_GET_DEFINED)\n    {\n      ecma_set_named_accessor_property_getter (object_p,\n                                               ext_property_ref.property_ref.value_p,\n                                               property_desc_p->get_p);\n    }\n\n    if (property_desc_p->flags & ECMA_PROP_IS_SET_DEFINED)\n    {\n      ecma_set_named_accessor_property_setter (object_p,\n                                               ext_property_ref.property_ref.value_p,\n                                               property_desc_p->set_p);\n    }\n  }\n\n  if (property_desc_p->flags & ECMA_PROP_IS_ENUMERABLE_DEFINED)\n  {\n    ecma_set_property_enumerable_attr (ext_property_ref.property_p,\n                                       (property_desc_p->flags & ECMA_PROP_IS_ENUMERABLE));\n  }\n\n  if (property_desc_p->flags & ECMA_PROP_IS_CONFIGURABLE_DEFINED)\n  {\n    ecma_set_property_configurable_attr (ext_property_ref.property_p,\n                                         (property_desc_p->flags & ECMA_PROP_IS_CONFIGURABLE));\n  }\n\n  return ECMA_VALUE_TRUE;\n}",
        "begin_line": 360,
        "end_line": 635,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_object_class_is#2830",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_object_class_is (ecma_object_t *object_p, /**< object */                       uint32_t class_id) /**< class id */",
        "snippet": "inline bool JERRY_ATTR_ALWAYS_INLINE\necma_object_class_is (ecma_object_t *object_p, /**< object */\n                      uint32_t class_id) /**< class id */\n{\n  if (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_CLASS)\n  {\n    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n    if (ext_object_p->u.class_prop.class_id == class_id)\n    {\n      return true;\n    }\n  }\n\n  return false;\n}",
        "begin_line": 2830,
        "end_line": 2845,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_define_own_property#1745",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_define_own_property (ecma_object_t *obj_p, /**< the object */                                     ecma_string_t *property_name_p, /**< property name */                                     const ecma_property_descriptor_t *property_desc_p) /**< property                                                                                         *   descriptor */",
        "snippet": "ecma_value_t\necma_op_object_define_own_property (ecma_object_t *obj_p, /**< the object */\n                                    ecma_string_t *property_name_p, /**< property name */\n                                    const ecma_property_descriptor_t *property_desc_p) /**< property\n                                                                                        *   descriptor */\n{\n  JERRY_ASSERT (obj_p != NULL\n                && !ecma_is_lexical_environment (obj_p));\n  JERRY_ASSERT (property_name_p != NULL);\n\n  const ecma_object_type_t type = ecma_get_object_type (obj_p);\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_IS_PROXY (obj_p))\n  {\n    return ecma_proxy_object_define_own_property (obj_p, property_name_p, property_desc_p);\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  switch (type)\n  {\n    case ECMA_OBJECT_TYPE_GENERAL:\n    case ECMA_OBJECT_TYPE_CLASS:\n    case ECMA_OBJECT_TYPE_FUNCTION:\n    case ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION:\n    case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n    {\n      return ecma_op_general_object_define_own_property (obj_p,\n                                                         property_name_p,\n                                                         property_desc_p);\n    }\n\n    case ECMA_OBJECT_TYPE_ARRAY:\n    {\n      return ecma_op_array_object_define_own_property (obj_p,\n                                                       property_name_p,\n                                                       property_desc_p);\n    }\n\n    default:\n    {\n      JERRY_ASSERT (type == ECMA_OBJECT_TYPE_PSEUDO_ARRAY);\n\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n      if (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS)\n      {\n#else /* !ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n        JERRY_ASSERT (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS);\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n        return ecma_op_arguments_object_define_own_property (obj_p,\n                                                             property_name_p,\n                                                             property_desc_p);\n#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n      }\n      /* ES2015 9.4.5.3 */\n      if (ecma_object_is_typedarray (obj_p))\n      {\n#if ENABLED (JERRY_ES2015)\n        if (ecma_prop_name_is_symbol (property_name_p))\n        {\n          return ecma_op_general_object_define_own_property (obj_p,\n                                                             property_name_p,\n                                                             property_desc_p);\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n        uint32_t array_index = ecma_string_get_array_index (property_name_p);\n\n        if (array_index != ECMA_STRING_NOT_ARRAY_INDEX)\n        {\n          bool define_status = ecma_op_typedarray_define_index_prop (obj_p,\n                                                                     array_index,\n                                                                     property_desc_p);\n\n          if (define_status)\n          {\n            return ECMA_VALUE_TRUE;\n          }\n\n          return ecma_reject (property_desc_p->flags & ECMA_PROP_IS_THROW);\n        }\n\n        ecma_number_t num = ecma_string_to_number (property_name_p);\n        ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);\n\n        if (ecma_compare_ecma_strings (property_name_p, num_to_str))\n        {\n          ecma_deref_ecma_string (num_to_str);\n\n          return ecma_reject (property_desc_p->flags & ECMA_PROP_IS_THROW);\n        }\n\n        ecma_deref_ecma_string (num_to_str);\n      }\n\n      return ecma_op_general_object_define_own_property (obj_p,\n                                                         property_name_p,\n                                                         property_desc_p);\n#else /* !ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n      break;\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n    }\n  }\n}",
        "begin_line": 1745,
        "end_line": 1849,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_find#729",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_find (ecma_object_t *object_p, /**< the object */                      ecma_string_t *property_name_p) /**< property name */",
        "snippet": "ecma_value_t\necma_op_object_find (ecma_object_t *object_p, /**< the object */\n                     ecma_string_t *property_name_p) /**< property name */\n{\n  ecma_value_t base_value = ecma_make_object_value (object_p);\n\n  while (true)\n  {\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n    if (ECMA_OBJECT_IS_PROXY (object_p))\n    {\n      return ecma_proxy_object_find (object_p, property_name_p);\n    }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n    ecma_value_t value = ecma_op_object_find_own (base_value, object_p, property_name_p);\n\n    if (ecma_is_value_found (value))\n    {\n      return value;\n    }\n\n    if (object_p->u2.prototype_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    object_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, object_p->u2.prototype_cp);\n  }\n\n  return ECMA_VALUE_NOT_FOUND;\n}",
        "begin_line": 729,
        "end_line": 760,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_find_own#444",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_find_own (ecma_value_t base_value, /**< base value */                          ecma_object_t *object_p, /**< target object */                          ecma_string_t *property_name_p) /**< property name */",
        "snippet": "ecma_value_t\necma_op_object_find_own (ecma_value_t base_value, /**< base value */\n                         ecma_object_t *object_p, /**< target object */\n                         ecma_string_t *property_name_p) /**< property name */\n{\n  JERRY_ASSERT (object_p != NULL\n                && !ecma_is_lexical_environment (object_p));\n  JERRY_ASSERT (property_name_p != NULL);\n  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));\n\n  ecma_object_type_t type = ecma_get_object_type (object_p);\n\n  switch (type)\n  {\n    case ECMA_OBJECT_TYPE_CLASS:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      if (ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_STRING_UL)\n      {\n        if (ecma_string_is_length (property_name_p))\n        {\n          ecma_value_t prim_value_p = ext_object_p->u.class_prop.u.value;\n\n          ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);\n          ecma_length_t length = ecma_string_get_length (prim_value_str_p);\n\n          return ecma_make_uint32_value (length);\n        }\n\n        uint32_t index = ecma_string_get_array_index (property_name_p);\n\n        if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n        {\n          ecma_value_t prim_value_p = ext_object_p->u.class_prop.u.value;\n\n          ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);\n\n          if (index < ecma_string_get_length (prim_value_str_p))\n          {\n            ecma_char_t char_at_idx = ecma_string_get_char_at_pos (prim_value_str_p, index);\n            return ecma_make_string_value (ecma_new_ecma_string_from_code_unit (char_at_idx));\n          }\n        }\n      }\n\n      break;\n    }\n    case ECMA_OBJECT_TYPE_ARRAY:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      if (ecma_string_is_length (property_name_p))\n      {\n        return ecma_make_uint32_value (ext_object_p->u.array.length);\n      }\n\n      if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)))\n      {\n        uint32_t index = ecma_string_get_array_index (property_name_p);\n\n        if (JERRY_LIKELY (index != ECMA_STRING_NOT_ARRAY_INDEX))\n        {\n          if (JERRY_LIKELY (index < ext_object_p->u.array.length))\n          {\n            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);\n\n            return (ecma_is_value_array_hole (values_p[index]) ? ECMA_VALUE_NOT_FOUND\n                                                               : ecma_fast_copy_value (values_p[index]));\n          }\n        }\n        return ECMA_VALUE_NOT_FOUND;\n      }\n\n      break;\n    }\n    case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      if (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS)\n      {\n        uint32_t index = ecma_string_get_array_index (property_name_p);\n\n        if (index != ECMA_STRING_NOT_ARRAY_INDEX\n            && index < ext_object_p->u.pseudo_array.u1.length)\n        {\n          ecma_value_t *arg_Literal_p = (ecma_value_t *) (ext_object_p + 1);\n\n          if (arg_Literal_p[index] != ECMA_VALUE_EMPTY)\n          {\n            ecma_string_t *arg_name_p = ecma_get_string_from_value (arg_Literal_p[index]);\n\n            ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t,\n                                                                        ext_object_p->u.pseudo_array.u2.lex_env_cp);\n\n            JERRY_ASSERT (lex_env_p != NULL\n                          && ecma_is_lexical_environment (lex_env_p));\n\n            return ecma_op_get_binding_value (lex_env_p, arg_name_p, true);\n          }\n        }\n      }\n#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n      /* ES2015 9.4.5.4 */\n      if (ecma_object_is_typedarray (object_p))\n      {\n#if ENABLED (JERRY_ES2015)\n        if (ecma_prop_name_is_symbol (property_name_p))\n        {\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        uint32_t array_index = ecma_string_get_array_index (property_name_p);\n\n        if (array_index != ECMA_STRING_NOT_ARRAY_INDEX)\n        {\n          ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);\n\n          if (array_index >= info.length)\n          {\n            return ECMA_VALUE_UNDEFINED;\n          }\n\n          ecma_length_t byte_pos = array_index << info.shift;\n          ecma_number_t num = ecma_get_typedarray_element (info.buffer_p + byte_pos, info.id);\n          return ecma_make_number_value (num);\n        }\n\n        ecma_number_t num = ecma_string_to_number (property_name_p);\n        ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);\n\n        if (ecma_compare_ecma_strings (property_name_p, num_to_str))\n        {\n          ecma_deref_ecma_string (num_to_str);\n\n          return ECMA_VALUE_UNDEFINED;\n        }\n\n        ecma_deref_ecma_string (num_to_str);\n      }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n\n      break;\n    }\n    default:\n    {\n      break;\n    }\n  }\n\n  ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);\n\n  if (property_p == NULL)\n  {\n    if (ecma_get_object_is_builtin (object_p))\n    {\n      if (type == ECMA_OBJECT_TYPE_FUNCTION && ecma_builtin_function_is_routine (object_p))\n      {\n        property_p = ecma_builtin_routine_try_to_instantiate_property (object_p, property_name_p);\n      }\n      else\n      {\n        property_p = ecma_builtin_try_to_instantiate_property (object_p, property_name_p);\n      }\n    }\n    else if (type == ECMA_OBJECT_TYPE_FUNCTION)\n    {\n#if !ENABLED (JERRY_ES2015)\n      if (ecma_string_is_length (property_name_p))\n      {\n        /* Get length virtual property. */\n        ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;\n        const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);\n\n        uint32_t len;\n        if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n        {\n          cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_data_p;\n          len = args_p->argument_end;\n        }\n        else\n        {\n          cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_data_p;\n          len = args_p->argument_end;\n        }\n\n        return ecma_make_uint32_value (len);\n      }\n#endif /* !ENABLED (JERRY_ES2015) */\n\n      /* Get prototype physical property. */\n      property_p = ecma_op_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n    }\n    else if (type == ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION)\n    {\n      property_p = ecma_op_external_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n    }\n    else if (type == ECMA_OBJECT_TYPE_BOUND_FUNCTION)\n    {\n      property_p = ecma_op_bound_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n    }\n\n    if (property_p == NULL)\n    {\n      return ECMA_VALUE_NOT_FOUND;\n    }\n  }\n\n  ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n  if (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA)\n  {\n    return ecma_fast_copy_value (prop_value_p->value);\n  }\n\n  JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR);\n\n  ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (prop_value_p);\n\n  if (get_set_pair_p->getter_cp == JMEM_CP_NULL)\n  {\n    return ECMA_VALUE_UNDEFINED;\n  }\n\n  ecma_object_t *getter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp);\n\n  return ecma_op_function_call (getter_p, base_value, NULL, 0);\n}",
        "begin_line": 444,
        "end_line": 673,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get#809",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get (ecma_object_t *object_p, /**< the object */                     ecma_string_t *property_name_p) /**< property name */",
        "snippet": "inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE\necma_op_object_get (ecma_object_t *object_p, /**< the object */\n                    ecma_string_t *property_name_p) /**< property name */\n{\n  return ecma_op_object_get_with_receiver (object_p, property_name_p, ecma_make_object_value (object_p));\n}",
        "begin_line": 809,
        "end_line": 814,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_by_magic_id#927",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_by_magic_id (ecma_object_t *object_p, /**< the object */                                 lit_magic_string_id_t property_id) /**< property magic string id */",
        "snippet": "inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE\necma_op_object_get_by_magic_id (ecma_object_t *object_p, /**< the object */\n                                lit_magic_string_id_t property_id) /**< property magic string id */\n{\n  return ecma_op_object_get (object_p, ecma_get_magic_string (property_id));\n}",
        "begin_line": 927,
        "end_line": 932,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_own_property#71",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_own_property (ecma_object_t *object_p, /**< the object */                                  ecma_string_t *property_name_p, /**< property name */                                  ecma_property_ref_t *property_ref_p, /**< property reference */                                  uint32_t options) /**< option bits */",
        "snippet": "ecma_property_t\necma_op_object_get_own_property (ecma_object_t *object_p, /**< the object */\n                                 ecma_string_t *property_name_p, /**< property name */\n                                 ecma_property_ref_t *property_ref_p, /**< property reference */\n                                 uint32_t options) /**< option bits */\n{\n  JERRY_ASSERT (object_p != NULL\n                && !ecma_is_lexical_environment (object_p));\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n  JERRY_ASSERT (property_name_p != NULL);\n  JERRY_ASSERT (options == ECMA_PROPERTY_GET_NO_OPTIONS\n                || options == ECMA_PROPERTY_GET_HAS_OWN_PROP\n                || property_ref_p != NULL);\n\n  ecma_object_type_t type = ecma_get_object_type (object_p);\n\n  switch (type)\n  {\n    case ECMA_OBJECT_TYPE_CLASS:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      if (ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_STRING_UL)\n      {\n        if (ecma_string_is_length (property_name_p))\n        {\n          if (options & ECMA_PROPERTY_GET_VALUE)\n          {\n            ecma_value_t prim_value_p = ext_object_p->u.class_prop.u.value;\n            ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);\n\n            ecma_length_t length = ecma_string_get_length (prim_value_str_p);\n            property_ref_p->virtual_value = ecma_make_uint32_value (length);\n          }\n\n          return ECMA_PROPERTY_TYPE_VIRTUAL;\n        }\n\n        uint32_t index = ecma_string_get_array_index (property_name_p);\n\n        if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n        {\n          ecma_value_t prim_value_p = ext_object_p->u.class_prop.u.value;\n          ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);\n\n          if (index < ecma_string_get_length (prim_value_str_p))\n          {\n            if (options & ECMA_PROPERTY_GET_VALUE)\n            {\n              ecma_char_t char_at_idx = ecma_string_get_char_at_pos (prim_value_str_p, index);\n              ecma_string_t *char_str_p = ecma_new_ecma_string_from_code_unit (char_at_idx);\n              property_ref_p->virtual_value = ecma_make_string_value (char_str_p);\n            }\n\n            return ECMA_PROPERTY_FLAG_ENUMERABLE | ECMA_PROPERTY_TYPE_VIRTUAL;\n          }\n        }\n      }\n      break;\n    }\n    case ECMA_OBJECT_TYPE_ARRAY:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      if (ecma_string_is_length (property_name_p))\n      {\n        if (options & ECMA_PROPERTY_GET_VALUE)\n        {\n          property_ref_p->virtual_value = ecma_make_uint32_value (ext_object_p->u.array.length);\n        }\n\n        return ext_object_p->u.array.u.length_prop & (ECMA_PROPERTY_TYPE_VIRTUAL | ECMA_PROPERTY_FLAG_WRITABLE);\n      }\n\n      if (ecma_op_array_is_fast_array (ext_object_p))\n      {\n        uint32_t index = ecma_string_get_array_index (property_name_p);\n\n        if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n        {\n          if (JERRY_LIKELY (index < ext_object_p->u.array.length))\n          {\n            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);\n\n            if (ecma_is_value_array_hole (values_p[index]))\n            {\n              return ECMA_PROPERTY_TYPE_NOT_FOUND;\n            }\n\n            if (options & ECMA_PROPERTY_GET_VALUE)\n            {\n              property_ref_p->virtual_value = ecma_fast_copy_value (values_p[index]);\n            }\n\n            return (ecma_property_t) (ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | ECMA_PROPERTY_TYPE_VIRTUAL);\n          }\n        }\n\n        return ECMA_PROPERTY_TYPE_NOT_FOUND;\n      }\n\n      break;\n    }\n#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n    case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:\n    {\n      /* ES2015 9.4.5.1 */\n      if (ecma_object_is_typedarray (object_p))\n      {\n#if ENABLED (JERRY_ES2015)\n        if (ecma_prop_name_is_symbol (property_name_p))\n        {\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        uint32_t array_index = ecma_string_get_array_index (property_name_p);\n\n        if (array_index != ECMA_STRING_NOT_ARRAY_INDEX)\n        {\n          ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);\n          ecma_value_t value = ECMA_VALUE_UNDEFINED;\n\n          if (array_index < info.length)\n          {\n            ecma_length_t byte_pos = array_index << info.shift;\n            ecma_number_t num = ecma_get_typedarray_element (info.buffer_p + byte_pos, info.id);\n            value = ecma_make_number_value (num);\n          }\n\n          if (!ecma_is_value_undefined (value))\n          {\n            if (options & ECMA_PROPERTY_GET_VALUE)\n            {\n              property_ref_p->virtual_value = value;\n            }\n            else\n            {\n              ecma_fast_free_value (value);\n            }\n\n            return ECMA_PROPERTY_ENUMERABLE_WRITABLE | ECMA_PROPERTY_TYPE_VIRTUAL;\n          }\n\n          return ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP;\n        }\n\n        ecma_number_t num = ecma_string_to_number (property_name_p);\n        ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);\n\n        if (ecma_compare_ecma_strings (property_name_p, num_to_str))\n        {\n          ecma_deref_ecma_string (num_to_str);\n\n          return ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP;\n        }\n\n        ecma_deref_ecma_string (num_to_str);\n      }\n\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n    default:\n    {\n      break;\n    }\n  }\n\n  ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);\n\n  if (property_p == NULL)\n  {\n    if (ecma_get_object_is_builtin (object_p))\n    {\n      if (type == ECMA_OBJECT_TYPE_FUNCTION && ecma_builtin_function_is_routine (object_p))\n      {\n        property_p = ecma_builtin_routine_try_to_instantiate_property (object_p, property_name_p);\n      }\n      else\n      {\n        property_p = ecma_builtin_try_to_instantiate_property (object_p, property_name_p);\n      }\n    }\n    else if (type == ECMA_OBJECT_TYPE_FUNCTION)\n    {\n#if !ENABLED (JERRY_ES2015)\n      if (ecma_string_is_length (property_name_p))\n      {\n        if (options & ECMA_PROPERTY_GET_VALUE)\n        {\n          /* Get length virtual property. */\n          ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;\n          const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);\n\n          uint32_t len;\n          if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n          {\n            cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_data_p;\n            len = args_p->argument_end;\n          }\n          else\n          {\n            cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_data_p;\n            len = args_p->argument_end;\n          }\n\n          property_ref_p->virtual_value = ecma_make_uint32_value (len);\n        }\n\n        return ECMA_PROPERTY_TYPE_VIRTUAL;\n      }\n#endif /* !ENABLED (JERRY_ES2015) */\n\n      /* Get prototype physical property. */\n      property_p = ecma_op_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n    }\n    else if (type == ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION)\n    {\n      property_p = ecma_op_external_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n    }\n    else if (type == ECMA_OBJECT_TYPE_BOUND_FUNCTION)\n    {\n      property_p = ecma_op_bound_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n    }\n\n    if (property_p == NULL)\n    {\n      return ECMA_PROPERTY_TYPE_NOT_FOUND;\n    }\n  }\n  else if (type == ECMA_OBJECT_TYPE_PSEUDO_ARRAY\n           && (options & ECMA_PROPERTY_GET_HAS_OWN_PROP))\n  {\n    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n    if (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS)\n    {\n      uint32_t index = ecma_string_get_array_index (property_name_p);\n\n      if (index != ECMA_STRING_NOT_ARRAY_INDEX\n          && index < ext_object_p->u.pseudo_array.u1.length)\n      {\n        ecma_value_t *arg_Literal_p = (ecma_value_t *) (ext_object_p + 1);\n\n        if (arg_Literal_p[index] != ECMA_VALUE_EMPTY)\n        {\n          ecma_string_t *arg_name_p = ecma_get_string_from_value (arg_Literal_p[index]);\n\n          ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t,\n                                                                      ext_object_p->u.pseudo_array.u2.lex_env_cp);\n\n          JERRY_ASSERT (lex_env_p != NULL\n                        && ecma_is_lexical_environment (lex_env_p));\n\n          ecma_value_t binding_value = ecma_op_get_binding_value (lex_env_p, arg_name_p, true);\n\n          ecma_named_data_property_assign_value (object_p,\n                                                 ECMA_PROPERTY_VALUE_PTR (property_p),\n                                                 binding_value);\n          ecma_free_value (binding_value);\n        }\n      }\n    }\n  }\n\n  if (options & ECMA_PROPERTY_GET_EXT_REFERENCE)\n  {\n    ((ecma_extended_property_ref_t *) property_ref_p)->property_p = property_p;\n  }\n\n  if (property_ref_p != NULL)\n  {\n    property_ref_p->value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n  }\n\n  return *property_p;\n}",
        "begin_line": 71,
        "end_line": 350,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_own_property_descriptor#1864",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_own_property_descriptor (ecma_object_t *object_p, /**< the object */                                             ecma_string_t *property_name_p, /**< property name */                                             ecma_property_descriptor_t *prop_desc_p) /**< property descriptor */",
        "snippet": "ecma_value_t\necma_op_object_get_own_property_descriptor (ecma_object_t *object_p, /**< the object */\n                                            ecma_string_t *property_name_p, /**< property name */\n                                            ecma_property_descriptor_t *prop_desc_p) /**< property descriptor */\n{\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_IS_PROXY (object_p))\n  {\n    return ecma_proxy_object_get_own_property_descriptor (object_p, property_name_p, prop_desc_p);\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  ecma_property_ref_t property_ref;\n\n  ecma_property_t property = ecma_op_object_get_own_property (object_p,\n                                                              property_name_p,\n                                                              &property_ref,\n                                                              ECMA_PROPERTY_GET_VALUE);\n\n  if (property == ECMA_PROPERTY_TYPE_NOT_FOUND || property == ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP)\n  {\n    return ECMA_VALUE_FALSE;\n  }\n\n  *prop_desc_p = ecma_make_empty_property_descriptor ();\n\n  uint32_t flags = ecma_is_property_enumerable (property) ? ECMA_PROP_IS_ENUMERABLE : ECMA_PROP_NO_OPTS;\n  flags |= ecma_is_property_configurable (property) ? ECMA_PROP_IS_CONFIGURABLE: ECMA_PROP_NO_OPTS;\n\n  prop_desc_p->flags = (uint16_t) (ECMA_PROP_IS_ENUMERABLE_DEFINED | ECMA_PROP_IS_CONFIGURABLE_DEFINED | flags);\n\n  ecma_property_types_t type = ECMA_PROPERTY_GET_TYPE (property);\n\n  if (type != ECMA_PROPERTY_TYPE_NAMEDACCESSOR)\n  {\n    if (type == ECMA_PROPERTY_TYPE_NAMEDDATA)\n    {\n      prop_desc_p->value = ecma_copy_value (property_ref.value_p->value);\n    }\n    else\n    {\n      JERRY_ASSERT (type == ECMA_PROPERTY_TYPE_VIRTUAL);\n      prop_desc_p->value = property_ref.virtual_value;\n    }\n\n    prop_desc_p->flags |= (ECMA_PROP_IS_VALUE_DEFINED | ECMA_PROP_IS_WRITABLE_DEFINED);\n    prop_desc_p->flags = (uint16_t) (prop_desc_p->flags | (ecma_is_property_writable (property) ? ECMA_PROP_IS_WRITABLE\n                                                                                                : ECMA_PROP_NO_OPTS));\n  }\n  else\n  {\n\n    ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (property_ref.value_p);\n    prop_desc_p->flags |= (ECMA_PROP_IS_GET_DEFINED | ECMA_PROP_IS_SET_DEFINED);\n\n    if (get_set_pair_p->getter_cp == JMEM_CP_NULL)\n    {\n      prop_desc_p->get_p = NULL;\n    }\n    else\n    {\n      prop_desc_p->get_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp);\n      ecma_ref_object (prop_desc_p->get_p);\n    }\n\n    if (get_set_pair_p->setter_cp == JMEM_CP_NULL)\n    {\n      prop_desc_p->set_p = NULL;\n    }\n    else\n    {\n      prop_desc_p->set_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->setter_cp);\n      ecma_ref_object (prop_desc_p->set_p);\n    }\n  }\n\n  return ECMA_VALUE_TRUE;\n}",
        "begin_line": 1864,
        "end_line": 1941,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_property#361",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_property (ecma_object_t *object_p, /**< the object */                              ecma_string_t *property_name_p, /**< property name */                              ecma_property_ref_t *property_ref_p, /**< property reference */                              uint32_t options) /**< option bits */",
        "snippet": "static ecma_property_t\necma_op_object_get_property (ecma_object_t *object_p, /**< the object */\n                             ecma_string_t *property_name_p, /**< property name */\n                             ecma_property_ref_t *property_ref_p, /**< property reference */\n                             uint32_t options) /**< option bits */\n{\n  while (true)\n  {\n    ecma_property_t property = ecma_op_object_get_own_property (object_p,\n                                                                property_name_p,\n                                                                property_ref_p,\n                                                                options);\n\n    if (property != ECMA_PROPERTY_TYPE_NOT_FOUND && property != ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP)\n    {\n      return property;\n    }\n\n    if (property == ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP)\n    {\n      break;\n    }\n\n    if (object_p->u2.prototype_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    object_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, object_p->u2.prototype_cp);\n  }\n\n  return ECMA_PROPERTY_TYPE_NOT_FOUND;\n}",
        "begin_line": 361,
        "end_line": 393,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_with_receiver#830",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_with_receiver (ecma_object_t *object_p, /**< the object */                                   ecma_string_t *property_name_p, /**< property name */                                   ecma_value_t receiver) /**< receiver to invoke getter function */",
        "snippet": "ecma_value_t\necma_op_object_get_with_receiver (ecma_object_t *object_p, /**< the object */\n                                  ecma_string_t *property_name_p, /**< property name */\n                                  ecma_value_t receiver) /**< receiver to invoke getter function */\n{\n  while (true)\n  {\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n    if (ECMA_OBJECT_IS_PROXY (object_p))\n    {\n      return ecma_proxy_object_get (object_p, property_name_p, receiver);\n    }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n    ecma_value_t value = ecma_op_object_find_own (receiver, object_p, property_name_p);\n\n    if (ecma_is_value_found (value))\n    {\n      return value;\n    }\n\n    jmem_cpointer_t proto_cp = ecma_op_ordinary_object_get_prototype_of (object_p);\n\n    if (proto_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    object_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp);\n  }\n\n  return ECMA_VALUE_UNDEFINED;\n}",
        "begin_line": 830,
        "end_line": 862,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_has_property#404",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_has_property (ecma_object_t *object_p, /**< the object */                              ecma_string_t *property_name_p) /**< property name */",
        "snippet": "inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE\necma_op_object_has_property (ecma_object_t *object_p, /**< the object */\n                             ecma_string_t *property_name_p) /**< property name */\n{\n  while (true)\n  {\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n    if (ECMA_OBJECT_IS_PROXY (object_p))\n    {\n      return ecma_proxy_object_has (object_p, property_name_p);\n    }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n    /* 2 - 3. */\n    if (ecma_op_ordinary_object_has_own_property (object_p, property_name_p))\n    {\n      return ECMA_VALUE_TRUE;\n    }\n\n    jmem_cpointer_t proto_cp = ecma_op_ordinary_object_get_prototype_of (object_p);\n\n    /* 7. */\n    if (proto_cp == JMEM_CP_NULL)\n    {\n      return ECMA_VALUE_FALSE;\n    }\n\n    object_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp);\n  }\n}",
        "begin_line": 404,
        "end_line": 433,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_put#1128",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_put (ecma_object_t *object_p, /**< the object */                     ecma_string_t *property_name_p, /**< property name */                     ecma_value_t value, /**< ecma value */                     bool is_throw) /**< flag that controls failure handling */",
        "snippet": "inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE\necma_op_object_put (ecma_object_t *object_p, /**< the object */\n                    ecma_string_t *property_name_p, /**< property name */\n                    ecma_value_t value, /**< ecma value */\n                    bool is_throw) /**< flag that controls failure handling */\n{\n  return ecma_op_object_put_with_receiver (object_p,\n                                           property_name_p,\n                                           value,\n                                           ecma_make_object_value (object_p),\n                                           is_throw);\n}",
        "begin_line": 1128,
        "end_line": 1139,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_put_with_receiver#1250",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_put_with_receiver (ecma_object_t *object_p, /**< the object */                                   ecma_string_t *property_name_p, /**< property name */                                   ecma_value_t value, /**< ecma value */                                   ecma_value_t receiver, /**< receiver */                                   bool is_throw) /**< flag that controls failure handling */",
        "snippet": "ecma_value_t\necma_op_object_put_with_receiver (ecma_object_t *object_p, /**< the object */\n                                  ecma_string_t *property_name_p, /**< property name */\n                                  ecma_value_t value, /**< ecma value */\n                                  ecma_value_t receiver, /**< receiver */\n                                  bool is_throw) /**< flag that controls failure handling */\n{\n  JERRY_ASSERT (object_p != NULL\n                && !ecma_is_lexical_environment (object_p));\n  JERRY_ASSERT (property_name_p != NULL);\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_IS_PROXY (object_p))\n  {\n    return ecma_proxy_object_set (object_p, property_name_p, value, receiver);\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  ecma_object_type_t type = ecma_get_object_type (object_p);\n\n  switch (type)\n  {\n    case ECMA_OBJECT_TYPE_ARRAY:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      if (ecma_string_is_length (property_name_p))\n      {\n        if (ecma_is_property_writable (ext_object_p->u.array.u.length_prop))\n        {\n          return ecma_op_array_object_set_length (object_p, value, 0);\n        }\n\n        return ecma_reject (is_throw);\n      }\n\n      if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)))\n      {\n        if (JERRY_UNLIKELY (!ecma_op_ordinary_object_is_extensible (object_p)))\n        {\n          return ecma_reject (is_throw);\n        }\n\n        uint32_t index = ecma_string_get_array_index (property_name_p);\n\n        if (JERRY_UNLIKELY (index == ECMA_STRING_NOT_ARRAY_INDEX))\n        {\n          ecma_fast_array_convert_to_normal (object_p);\n        }\n        else if (ecma_fast_array_set_property (object_p, index, value))\n        {\n          return ECMA_VALUE_TRUE;\n        }\n      }\n\n      JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));\n\n      break;\n    }\n    case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      if (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS)\n      {\n        uint32_t index = ecma_string_get_array_index (property_name_p);\n\n        if (index != ECMA_STRING_NOT_ARRAY_INDEX\n            && index < ext_object_p->u.pseudo_array.u1.length)\n        {\n          ecma_value_t *arg_Literal_p = (ecma_value_t *) (ext_object_p + 1);\n\n          if (arg_Literal_p[index] != ECMA_VALUE_EMPTY)\n          {\n            ecma_string_t *arg_name_p = ecma_get_string_from_value (arg_Literal_p[index]);\n\n            ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t,\n                                                                        ext_object_p->u.pseudo_array.u2.lex_env_cp);\n\n            JERRY_ASSERT (lex_env_p != NULL\n                          && ecma_is_lexical_environment (lex_env_p));\n\n            ecma_op_set_mutable_binding (lex_env_p, arg_name_p, value, true);\n            return ECMA_VALUE_TRUE;\n          }\n        }\n      }\n#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n      /* ES2015 9.4.5.5 */\n      if (ecma_object_is_typedarray (object_p))\n      {\n#if ENABLED (JERRY_ES2015)\n        if (ecma_prop_name_is_symbol (property_name_p))\n        {\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        uint32_t array_index = ecma_string_get_array_index (property_name_p);\n\n        if (array_index != ECMA_STRING_NOT_ARRAY_INDEX)\n        {\n          ecma_number_t num_var;\n          ecma_value_t error = ecma_get_number (value, &num_var);\n\n          if (ECMA_IS_VALUE_ERROR (error))\n          {\n            jcontext_release_exception ();\n            return ecma_reject (is_throw);\n          }\n\n          ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);\n\n          if (array_index >= info.length)\n          {\n            return ecma_reject (is_throw);\n          }\n\n          ecma_length_t byte_pos = array_index << info.shift;\n          ecma_set_typedarray_element (info.buffer_p + byte_pos, num_var, info.id);\n\n          return ECMA_VALUE_TRUE;\n        }\n\n        ecma_number_t num = ecma_string_to_number (property_name_p);\n        ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);\n\n        if (ecma_compare_ecma_strings (property_name_p, num_to_str))\n        {\n          ecma_deref_ecma_string (num_to_str);\n\n          return ecma_reject (is_throw);\n        }\n\n        ecma_deref_ecma_string (num_to_str);\n      }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n      break;\n    }\n    default:\n    {\n      break;\n    }\n  }\n\n  ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);\n\n  if (property_p == NULL)\n  {\n    if (type == ECMA_OBJECT_TYPE_CLASS)\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      if (ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_STRING_UL)\n      {\n        uint32_t index = ecma_string_get_array_index (property_name_p);\n\n        if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n        {\n          ecma_value_t prim_value_p = ext_object_p->u.class_prop.u.value;\n          ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);\n\n          if (index < ecma_string_get_length (prim_value_str_p))\n          {\n            return ecma_reject (is_throw);\n          }\n        }\n      }\n    }\n\n    if (ecma_get_object_is_builtin (object_p))\n    {\n      if (type == ECMA_OBJECT_TYPE_FUNCTION && ecma_builtin_function_is_routine (object_p))\n      {\n        property_p = ecma_builtin_routine_try_to_instantiate_property (object_p, property_name_p);\n      }\n      else\n      {\n        property_p = ecma_builtin_try_to_instantiate_property (object_p, property_name_p);\n      }\n    }\n    else if (type == ECMA_OBJECT_TYPE_FUNCTION)\n    {\n#if ENABLED (JERRY_ES2015)\n      /* Uninitialized 'length' property is non-writable (ECMA-262 v6, 19.2.4.1) */\n      if ((ecma_string_is_length (property_name_p))\n          && (!ECMA_GET_FIRST_BIT_FROM_POINTER_TAG (((ecma_extended_object_t *) object_p)->u.function.scope_cp)))\n      {\n        return ecma_reject (is_throw);\n      }\n#else /* !ENABLED (JERRY_ES2015) */\n      if (ecma_string_is_length (property_name_p))\n      {\n        return ecma_reject (is_throw);\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      /* Get prototype physical property. */\n      property_p = ecma_op_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n    }\n    else if (type == ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION)\n    {\n      property_p = ecma_op_external_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n    }\n    else if (type == ECMA_OBJECT_TYPE_BOUND_FUNCTION)\n    {\n      property_p = ecma_op_bound_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n    }\n  }\n\n  jmem_cpointer_t setter_cp = JMEM_CP_NULL;\n\n  if (property_p != NULL)\n  {\n    if (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA)\n    {\n      if (ecma_is_property_writable (*property_p))\n      {\n#if ENABLED (JERRY_ES2015)\n        if (ecma_make_object_value (object_p) != receiver)\n        {\n          return ecma_op_object_put_apply_receiver (receiver, property_name_p, value, is_throw);\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        /* There is no need for special casing arrays here because changing the\n         * value of an existing property never changes the length of an array. */\n        ecma_named_data_property_assign_value (object_p,\n                                               ECMA_PROPERTY_VALUE_PTR (property_p),\n                                               value);\n        return ECMA_VALUE_TRUE;\n      }\n    }\n    else\n    {\n      JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR);\n\n      ecma_getter_setter_pointers_t *get_set_pair_p;\n      get_set_pair_p = ecma_get_named_accessor_property (ECMA_PROPERTY_VALUE_PTR (property_p));\n      setter_cp = get_set_pair_p->setter_cp;\n    }\n  }\n  else\n  {\n    bool create_new_property = true;\n\n    jmem_cpointer_t proto_cp = ecma_op_ordinary_object_get_prototype_of (object_p);\n\n    if (proto_cp != JMEM_CP_NULL)\n    {\n      ecma_property_ref_t property_ref = { NULL };\n      ecma_object_t *proto_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp);\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n      if (ECMA_OBJECT_IS_PROXY (proto_p))\n      {\n        return ecma_op_object_put_with_receiver (proto_p,\n                                                 property_name_p,\n                                                 value,\n                                                 receiver,\n                                                 is_throw);\n      }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n      ecma_property_t inherited_property = ecma_op_object_get_property (proto_p,\n                                                                        property_name_p,\n                                                                        &property_ref,\n                                                                        ECMA_PROPERTY_GET_NO_OPTIONS);\n\n      if (inherited_property != ECMA_PROPERTY_TYPE_NOT_FOUND)\n      {\n        if (ECMA_PROPERTY_GET_TYPE (inherited_property) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR)\n        {\n          setter_cp = ecma_get_named_accessor_property (property_ref.value_p)->setter_cp;\n          create_new_property = false;\n        }\n        else\n        {\n          create_new_property = ecma_is_property_writable (inherited_property);\n        }\n      }\n    }\n\n    if (create_new_property\n        && ecma_op_ordinary_object_is_extensible (object_p))\n    {\n      const ecma_object_type_t obj_type = ecma_get_object_type (object_p);\n\n      if (obj_type == ECMA_OBJECT_TYPE_PSEUDO_ARRAY)\n      {\n        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n        if (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS)\n        {\n          return ecma_builtin_helper_def_prop (object_p,\n                                               property_name_p,\n                                               value,\n                                               ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | ECMA_IS_THROW);\n        }\n      }\n\n      uint32_t index = ecma_string_get_array_index (property_name_p);\n\n      if (obj_type == ECMA_OBJECT_TYPE_ARRAY\n          && index != ECMA_STRING_NOT_ARRAY_INDEX)\n      {\n        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n        if (index < UINT32_MAX\n            && index >= ext_object_p->u.array.length)\n        {\n          if (!ecma_is_property_writable (ext_object_p->u.array.u.length_prop))\n          {\n            return ecma_reject (is_throw);\n          }\n\n          ext_object_p->u.array.length = index + 1;\n        }\n      }\n\n#if ENABLED (JERRY_ES2015)\n      return ecma_op_object_put_apply_receiver (receiver, property_name_p, value, is_throw);\n#endif /* ENABLED (JERRY_ES2015) */\n\n      ecma_property_value_t *new_prop_value_p;\n      new_prop_value_p = ecma_create_named_data_property (object_p,\n                                                          property_name_p,\n                                                          ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,\n                                                          NULL);\n\n      JERRY_ASSERT (ecma_is_value_undefined (new_prop_value_p->value));\n      new_prop_value_p->value = ecma_copy_value_if_not_object (value);\n      return ECMA_VALUE_TRUE;\n    }\n  }\n\n  if (setter_cp == JMEM_CP_NULL)\n  {\n    return ecma_reject (is_throw);\n  }\n\n  ecma_value_t ret_value = ecma_op_function_call (ECMA_GET_NON_NULL_POINTER (ecma_object_t, setter_cp),\n                                                  receiver,\n                                                  &value,\n                                                  1);\n\n  if (!ECMA_IS_VALUE_ERROR (ret_value))\n  {\n    ecma_fast_free_value (ret_value);\n    ret_value = ECMA_VALUE_TRUE;\n  }\n\n  return ret_value;\n}",
        "begin_line": 1250,
        "end_line": 1603,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_ordinary_object_get_prototype_of#3076",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_ordinary_object_get_prototype_of (ecma_object_t *obj_p) /**< object */",
        "snippet": "inline jmem_cpointer_t JERRY_ATTR_ALWAYS_INLINE\necma_op_ordinary_object_get_prototype_of (ecma_object_t *obj_p) /**< object */\n{\n  JERRY_ASSERT (!ecma_is_lexical_environment (obj_p));\n  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (obj_p));\n\n  return obj_p->u2.prototype_cp;\n}",
        "begin_line": 3076,
        "end_line": 3083,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_ordinary_object_has_own_property#3190",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_ordinary_object_has_own_property (ecma_object_t *object_p, /**< the object */                                           ecma_string_t *property_name_p) /**< property name */",
        "snippet": "inline bool JERRY_ATTR_ALWAYS_INLINE\necma_op_ordinary_object_has_own_property (ecma_object_t *object_p, /**< the object */\n                                          ecma_string_t *property_name_p) /**< property name */\n{\n  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));\n\n  ecma_property_t property = ecma_op_object_get_own_property (object_p,\n                                                              property_name_p,\n                                                              NULL,\n                                                              ECMA_PROPERTY_GET_HAS_OWN_PROP);\n\n  return property != ECMA_PROPERTY_TYPE_NOT_FOUND && property != ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP;\n}",
        "begin_line": 3190,
        "end_line": 3202,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_ordinary_object_is_extensible#3166",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_ordinary_object_is_extensible (ecma_object_t *object_p) /**< object */",
        "snippet": "inline bool JERRY_ATTR_PURE\necma_op_ordinary_object_is_extensible (ecma_object_t *object_p) /**< object */\n{\n  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));\n\n  return (object_p->type_flags_refs & ECMA_OBJECT_FLAG_EXTENSIBLE) != 0;\n}",
        "begin_line": 3166,
        "end_line": 3172,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_ordinary_object_prevent_extensions#3177",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_ordinary_object_prevent_extensions (ecma_object_t *object_p) /**< object */",
        "snippet": "void JERRY_ATTR_NOINLINE\necma_op_ordinary_object_prevent_extensions (ecma_object_t *object_p) /**< object */\n{\n  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));\n  object_p->type_flags_refs = (uint16_t) (object_p->type_flags_refs & ~ECMA_OBJECT_FLAG_EXTENSIBLE);\n}",
        "begin_line": 3177,
        "end_line": 3182,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-reference.ecma_op_object_bound_environment_resolve_reference_value#201",
        "src_path": "jerry-core/ecma/operations/ecma-reference.c",
        "class_name": "jerry-core.ecma.operations.ecma-reference",
        "signature": "jerry-core.ecma.operations.ecma-reference.ecma_op_object_bound_environment_resolve_reference_value (ecma_object_t *lex_env_p, /**< lexical environment */                                                           ecma_string_t *name_p) /**< variable name */",
        "snippet": "ecma_value_t\necma_op_object_bound_environment_resolve_reference_value (ecma_object_t *lex_env_p, /**< lexical environment */\n                                                          ecma_string_t *name_p) /**< variable name */\n{\n  ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);\n  ecma_value_t found_binding;\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_IS_PROXY (binding_obj_p))\n  {\n    found_binding = ecma_proxy_object_has (binding_obj_p, name_p);\n\n    if (!ecma_is_value_true (found_binding))\n    {\n      return ECMA_IS_VALUE_ERROR (found_binding) ? found_binding : ECMA_VALUE_NOT_FOUND;\n    }\n  }\n  else\n  {\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n    found_binding = ecma_op_object_find (binding_obj_p, name_p);\n\n    if (ECMA_IS_VALUE_ERROR (found_binding) || !ecma_is_value_found (found_binding))\n    {\n      return found_binding;\n    }\n\n#if ENABLED (JERRY_ES2015)\n    if (JERRY_LIKELY (lex_env_p == ecma_get_global_scope ()))\n#endif /* ENABLED (JERRY_ES2015) */\n    {\n      return found_binding;\n    }\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n#if ENABLED (JERRY_ES2015)\n  ecma_value_t blocked = ecma_op_is_prop_unscopable (binding_obj_p, name_p);\n\n  if (ecma_is_value_false (blocked))\n  {\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n    if (ECMA_OBJECT_IS_PROXY (binding_obj_p))\n    {\n      return ecma_proxy_object_get (binding_obj_p, name_p, ecma_make_object_value (binding_obj_p));\n    }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n    return found_binding;\n  }\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (!ECMA_OBJECT_IS_PROXY (binding_obj_p))\n  {\n    ecma_free_value (found_binding);\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  return ECMA_IS_VALUE_ERROR (blocked) ? blocked : ECMA_VALUE_NOT_FOUND;\n#endif /* ENABLED (JERRY_ES2015) */\n}",
        "begin_line": 201,
        "end_line": 261,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-reference.ecma_op_resolve_reference_value#268",
        "src_path": "jerry-core/ecma/operations/ecma-reference.c",
        "class_name": "jerry-core.ecma.operations.ecma-reference",
        "signature": "jerry-core.ecma.operations.ecma-reference.ecma_op_resolve_reference_value (ecma_object_t *lex_env_p, /**< starting lexical environment */                                  ecma_string_t *name_p) /**< identifier's name */",
        "snippet": "ecma_value_t\necma_op_resolve_reference_value (ecma_object_t *lex_env_p, /**< starting lexical environment */\n                                 ecma_string_t *name_p) /**< identifier's name */\n{\n  JERRY_ASSERT (lex_env_p != NULL);\n\n  while (true)\n  {\n    ecma_lexical_environment_type_t lex_env_type = ecma_get_lex_env_type (lex_env_p);\n\n    if (lex_env_type == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n    {\n      ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n      if (property_p != NULL)\n      {\n        ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n#if ENABLED (JERRY_ES2015)\n        if (JERRY_UNLIKELY (property_value_p->value == ECMA_VALUE_UNINITIALIZED))\n        {\n          return ecma_raise_reference_error (ECMA_ERR_MSG (\"Variables declared by let/const must be\"\n                                                           \" initialized before reading their value.\"));\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        return ecma_fast_copy_value (property_value_p->value);\n      }\n    }\n    else if (lex_env_type == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND)\n    {\n#if ENABLED (JERRY_ES2015)\n      bool lcache_lookup_allowed = (lex_env_p == ecma_get_global_environment ());\n#else /* !ENABLED (JERRY_ES2015)*/\n      bool lcache_lookup_allowed = true;\n#endif /* ENABLED (JERRY_ES2015) */\n\n      if (lcache_lookup_allowed)\n      {\n#if ENABLED (JERRY_LCACHE)\n        ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);\n        ecma_property_t *property_p = ecma_lcache_lookup (binding_obj_p, name_p);\n\n        if (property_p != NULL)\n        {\n          ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n          if (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA)\n          {\n            return ecma_fast_copy_value (prop_value_p->value);\n          }\n\n          JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR);\n\n          ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (prop_value_p);\n\n          if (get_set_pair_p->getter_cp == JMEM_CP_NULL)\n          {\n            return ECMA_VALUE_UNDEFINED;\n          }\n\n          ecma_object_t *getter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp);\n\n          ecma_value_t base_value = ecma_make_object_value (binding_obj_p);\n          return ecma_op_function_call (getter_p, base_value, NULL, 0);\n        }\n#endif /* ENABLED (JERRY_LCACHE) */\n      }\n\n      ecma_value_t result = ecma_op_object_bound_environment_resolve_reference_value (lex_env_p, name_p);\n\n      if (ecma_is_value_found (result))\n      {\n        /* Note: the result may contains ECMA_VALUE_ERROR */\n        return result;\n      }\n    }\n    else\n    {\n#if ENABLED (JERRY_ES2015)\n      JERRY_ASSERT (lex_env_type == ECMA_LEXICAL_ENVIRONMENT_HOME_OBJECT_BOUND);\n#else /* !ENABLED (JERRY_ES2015) */\n      JERRY_UNREACHABLE ();\n#endif /* ENABLED (JERRY_ES2015) */\n    }\n\n    if (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);\n  }\n\n#if ENABLED (JERRY_ERROR_MESSAGES)\n  ecma_value_t name_val = ecma_make_string_value (name_p);\n  ecma_value_t error_value = ecma_raise_standard_error_with_format (ECMA_ERROR_REFERENCE,\n                                                                    \"% is not defined\",\n                                                                    name_val);\n#else /* ENABLED (JERRY_ERROR_MESSAGES) */\n  ecma_value_t error_value = ecma_raise_reference_error (NULL);\n#endif /* !ENABLED (JERRY_ERROR_MESSAGES) */\n  return error_value;\n}",
        "begin_line": 268,
        "end_line": 371,
        "is_bug": false
    },
    {
        "name": "jerry-core.jcontext.jcontext.jcontext_has_pending_abort#40",
        "src_path": "jerry-core/jcontext/jcontext.c",
        "class_name": "jerry-core.jcontext.jcontext",
        "signature": "jerry-core.jcontext.jcontext.jcontext_has_pending_abort (void)",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\njcontext_has_pending_abort (void)\n{\n  return JERRY_CONTEXT (status_flags) & ECMA_STATUS_ABORT;\n}",
        "begin_line": 40,
        "end_line": 44,
        "is_bug": false
    },
    {
        "name": "jerry-core.jcontext.jcontext.jcontext_has_pending_exception#28",
        "src_path": "jerry-core/jcontext/jcontext.c",
        "class_name": "jerry-core.jcontext.jcontext",
        "signature": "jerry-core.jcontext.jcontext.jcontext_has_pending_exception (void)",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\njcontext_has_pending_exception (void)\n{\n  return JERRY_CONTEXT (status_flags) & ECMA_STATUS_EXCEPTION;\n}",
        "begin_line": 28,
        "end_line": 32,
        "is_bug": false
    },
    {
        "name": "jerry-core.jcontext.jcontext.jcontext_raise_exception#85",
        "src_path": "jerry-core/jcontext/jcontext.c",
        "class_name": "jerry-core.jcontext.jcontext",
        "signature": "jerry-core.jcontext.jcontext.jcontext_raise_exception (ecma_value_t error) /**< error to raise */",
        "snippet": "extern inline void JERRY_ATTR_ALWAYS_INLINE\njcontext_raise_exception (ecma_value_t error) /**< error to raise */\n{\n  JERRY_ASSERT (!jcontext_has_pending_exception ());\n  JERRY_ASSERT (!jcontext_has_pending_abort ());\n\n  JERRY_CONTEXT (error_value) = error;\n  jcontext_set_exception_flag (true);\n}",
        "begin_line": 85,
        "end_line": 93,
        "is_bug": false
    },
    {
        "name": "jerry-core.jcontext.jcontext.jcontext_set_abort_flag#49",
        "src_path": "jerry-core/jcontext/jcontext.c",
        "class_name": "jerry-core.jcontext.jcontext",
        "signature": "jerry-core.jcontext.jcontext.jcontext_set_abort_flag (bool is_abort) /**< true - if the abort flag should be set                                          *   false - if the abort flag should be removed */",
        "snippet": "extern inline void JERRY_ATTR_ALWAYS_INLINE\njcontext_set_abort_flag (bool is_abort) /**< true - if the abort flag should be set\n                                         *   false - if the abort flag should be removed */\n{\n  JERRY_ASSERT (jcontext_has_pending_exception ());\n\n  if (is_abort)\n  {\n    JERRY_CONTEXT (status_flags) |= ECMA_STATUS_ABORT;\n  }\n  else\n  {\n    JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_ABORT;\n  }\n}",
        "begin_line": 49,
        "end_line": 63,
        "is_bug": false
    },
    {
        "name": "jerry-core.jcontext.jcontext.jcontext_set_exception_flag#68",
        "src_path": "jerry-core/jcontext/jcontext.c",
        "class_name": "jerry-core.jcontext.jcontext",
        "signature": "jerry-core.jcontext.jcontext.jcontext_set_exception_flag (bool is_exception) /**< true - if the exception flag should be set                                                  *   false - if the exception flag should be removed */",
        "snippet": "extern inline void JERRY_ATTR_ALWAYS_INLINE\njcontext_set_exception_flag (bool is_exception) /**< true - if the exception flag should be set\n                                                 *   false - if the exception flag should be removed */\n{\n  if (is_exception)\n  {\n    JERRY_CONTEXT (status_flags) |= ECMA_STATUS_EXCEPTION;\n  }\n  else\n  {\n    JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_EXCEPTION;\n  }\n}",
        "begin_line": 68,
        "end_line": 80,
        "is_bug": false
    },
    {
        "name": "jerry-core.jcontext.jcontext.jcontext_take_exception#111",
        "src_path": "jerry-core/jcontext/jcontext.c",
        "class_name": "jerry-core.jcontext.jcontext",
        "signature": "jerry-core.jcontext.jcontext.jcontext_take_exception (void)",
        "snippet": "ecma_value_t\njcontext_take_exception (void)\n{\n  JERRY_ASSERT (jcontext_has_pending_exception ());\n\n  jcontext_set_abort_flag (false);\n  jcontext_set_exception_flag (false);\n  return JERRY_CONTEXT (error_value);\n}",
        "begin_line": 111,
        "end_line": 119,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-allocator.jmem_compress_pointer#178",
        "src_path": "jerry-core/jmem/jmem-allocator.c",
        "class_name": "jerry-core.jmem.jmem-allocator",
        "signature": "jerry-core.jmem.jmem-allocator.jmem_compress_pointer (const void *pointer_p) /**< pointer to compress */",
        "snippet": "inline jmem_cpointer_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE\njmem_compress_pointer (const void *pointer_p) /**< pointer to compress */\n{\n  JERRY_ASSERT (pointer_p != NULL);\n  JERRY_ASSERT (jmem_is_heap_pointer (pointer_p));\n\n  uintptr_t uint_ptr = (uintptr_t) pointer_p;\n\n  JERRY_ASSERT (uint_ptr % JMEM_ALIGNMENT == 0);\n\n#if defined (ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY) && ENABLED (JERRY_CPOINTER_32_BIT)\n  JERRY_ASSERT (((jmem_cpointer_t) uint_ptr) == uint_ptr);\n#else /* !ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY || !ENABLED (JERRY_CPOINTER_32_BIT) */\n  const uintptr_t heap_start = (uintptr_t) &JERRY_HEAP_CONTEXT (first);\n\n  uint_ptr -= heap_start;\n  uint_ptr >>= JMEM_ALIGNMENT_LOG;\n\n#if ENABLED (JERRY_CPOINTER_32_BIT)\n  JERRY_ASSERT (uint_ptr <= UINT32_MAX);\n#else /* !ENABLED (JERRY_CPOINTER_32_BIT) */\n  JERRY_ASSERT (uint_ptr <= UINT16_MAX);\n#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */\n  JERRY_ASSERT (uint_ptr != JMEM_CP_NULL);\n#endif /* ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY && ENABLED (JERRY_CPOINTER_32_BIT) */\n\n  return (jmem_cpointer_t) uint_ptr;\n}",
        "begin_line": 178,
        "end_line": 205,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-allocator.jmem_decompress_pointer#212",
        "src_path": "jerry-core/jmem/jmem-allocator.c",
        "class_name": "jerry-core.jmem.jmem-allocator",
        "signature": "jerry-core.jmem.jmem-allocator.jmem_decompress_pointer (uintptr_t compressed_pointer) /**< pointer to decompress */",
        "snippet": "inline void * JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE\njmem_decompress_pointer (uintptr_t compressed_pointer) /**< pointer to decompress */\n{\n  JERRY_ASSERT (compressed_pointer != JMEM_CP_NULL);\n\n  uintptr_t uint_ptr = compressed_pointer;\n\n  JERRY_ASSERT (((jmem_cpointer_t) uint_ptr) == uint_ptr);\n\n#if defined (ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY) && ENABLED (JERRY_CPOINTER_32_BIT)\n  JERRY_ASSERT (uint_ptr % JMEM_ALIGNMENT == 0);\n#else /* !ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY || !ENABLED (JERRY_CPOINTER_32_BIT) */\n  const uintptr_t heap_start = (uintptr_t) &JERRY_HEAP_CONTEXT (first);\n\n  uint_ptr <<= JMEM_ALIGNMENT_LOG;\n  uint_ptr += heap_start;\n\n  JERRY_ASSERT (jmem_is_heap_pointer ((void *) uint_ptr));\n#endif /* ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY && ENABLED (JERRY_CPOINTER_32_BIT) */\n\n  return (void *) uint_ptr;\n}",
        "begin_line": 212,
        "end_line": 233,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-allocator.jmem_init#149",
        "src_path": "jerry-core/jmem/jmem-allocator.c",
        "class_name": "jerry-core.jmem.jmem-allocator",
        "signature": "jerry-core.jmem.jmem-allocator.jmem_init (void)",
        "snippet": "void\njmem_init (void)\n{\n  jmem_heap_init ();\n}",
        "begin_line": 149,
        "end_line": 153,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_alloc#122",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_alloc (const size_t size) /**< size of requested block */",
        "snippet": "static void * JERRY_ATTR_HOT\njmem_heap_alloc (const size_t size) /**< size of requested block */\n{\n#if !ENABLED (JERRY_SYSTEM_ALLOCATOR)\n  /* Align size. */\n  const size_t required_size = ((size + JMEM_ALIGNMENT - 1) / JMEM_ALIGNMENT) * JMEM_ALIGNMENT;\n  jmem_heap_free_t *data_space_p = NULL;\n\n  JMEM_VALGRIND_DEFINED_SPACE (&JERRY_HEAP_CONTEXT (first), sizeof (jmem_heap_free_t));\n\n  /* Fast path for 8 byte chunks, first region is guaranteed to be sufficient. */\n  if (required_size == JMEM_ALIGNMENT\n      && JERRY_LIKELY (JERRY_HEAP_CONTEXT (first).next_offset != JMEM_HEAP_END_OF_LIST))\n  {\n    data_space_p = JMEM_HEAP_GET_ADDR_FROM_OFFSET (JERRY_HEAP_CONTEXT (first).next_offset);\n    JERRY_ASSERT (jmem_is_heap_pointer (data_space_p));\n\n    JMEM_VALGRIND_DEFINED_SPACE (data_space_p, sizeof (jmem_heap_free_t));\n    JERRY_CONTEXT (jmem_heap_allocated_size) += JMEM_ALIGNMENT;\n\n    if (JERRY_CONTEXT (jmem_heap_allocated_size) >= JERRY_CONTEXT (jmem_heap_limit))\n    {\n      JERRY_CONTEXT (jmem_heap_limit) += CONFIG_GC_LIMIT;\n    }\n\n    if (data_space_p->size == JMEM_ALIGNMENT)\n    {\n      JERRY_HEAP_CONTEXT (first).next_offset = data_space_p->next_offset;\n    }\n    else\n    {\n      JERRY_ASSERT (data_space_p->size > JMEM_ALIGNMENT);\n\n      jmem_heap_free_t *remaining_p;\n      remaining_p = JMEM_HEAP_GET_ADDR_FROM_OFFSET (JERRY_HEAP_CONTEXT (first).next_offset) + 1;\n\n      JMEM_VALGRIND_DEFINED_SPACE (remaining_p, sizeof (jmem_heap_free_t));\n      remaining_p->size = data_space_p->size - JMEM_ALIGNMENT;\n      remaining_p->next_offset = data_space_p->next_offset;\n      JMEM_VALGRIND_NOACCESS_SPACE (remaining_p, sizeof (jmem_heap_free_t));\n\n      JERRY_HEAP_CONTEXT (first).next_offset = JMEM_HEAP_GET_OFFSET_FROM_ADDR (remaining_p);\n    }\n\n    JMEM_VALGRIND_NOACCESS_SPACE (data_space_p, sizeof (jmem_heap_free_t));\n\n    if (JERRY_UNLIKELY (data_space_p == JERRY_CONTEXT (jmem_heap_list_skip_p)))\n    {\n      JERRY_CONTEXT (jmem_heap_list_skip_p) = JMEM_HEAP_GET_ADDR_FROM_OFFSET (JERRY_HEAP_CONTEXT (first).next_offset);\n    }\n  }\n  /* Slow path for larger regions. */\n  else\n  {\n    uint32_t current_offset = JERRY_HEAP_CONTEXT (first).next_offset;\n    jmem_heap_free_t *prev_p = &JERRY_HEAP_CONTEXT (first);\n\n    while (JERRY_LIKELY (current_offset != JMEM_HEAP_END_OF_LIST))\n    {\n      jmem_heap_free_t *current_p = JMEM_HEAP_GET_ADDR_FROM_OFFSET (current_offset);\n      JERRY_ASSERT (jmem_is_heap_pointer (current_p));\n      JMEM_VALGRIND_DEFINED_SPACE (current_p, sizeof (jmem_heap_free_t));\n\n      const uint32_t next_offset = current_p->next_offset;\n      JERRY_ASSERT (next_offset == JMEM_HEAP_END_OF_LIST\n                    || jmem_is_heap_pointer (JMEM_HEAP_GET_ADDR_FROM_OFFSET (next_offset)));\n\n      if (current_p->size >= required_size)\n      {\n        /* Region is sufficiently big, store address. */\n        data_space_p = current_p;\n\n        /* Region was larger than necessary. */\n        if (current_p->size > required_size)\n        {\n          /* Get address of remaining space. */\n          jmem_heap_free_t *const remaining_p = (jmem_heap_free_t *) ((uint8_t *) current_p + required_size);\n\n          /* Update metadata. */\n          JMEM_VALGRIND_DEFINED_SPACE (remaining_p, sizeof (jmem_heap_free_t));\n          remaining_p->size = current_p->size - (uint32_t) required_size;\n          remaining_p->next_offset = next_offset;\n          JMEM_VALGRIND_NOACCESS_SPACE (remaining_p, sizeof (jmem_heap_free_t));\n\n          /* Update list. */\n          JMEM_VALGRIND_DEFINED_SPACE (prev_p, sizeof (jmem_heap_free_t));\n          prev_p->next_offset = JMEM_HEAP_GET_OFFSET_FROM_ADDR (remaining_p);\n          JMEM_VALGRIND_NOACCESS_SPACE (prev_p, sizeof (jmem_heap_free_t));\n        }\n        /* Block is an exact fit. */\n        else\n        {\n          /* Remove the region from the list. */\n          JMEM_VALGRIND_DEFINED_SPACE (prev_p, sizeof (jmem_heap_free_t));\n          prev_p->next_offset = next_offset;\n          JMEM_VALGRIND_NOACCESS_SPACE (prev_p, sizeof (jmem_heap_free_t));\n        }\n\n        JERRY_CONTEXT (jmem_heap_list_skip_p) = prev_p;\n\n        /* Found enough space. */\n        JERRY_CONTEXT (jmem_heap_allocated_size) += required_size;\n\n        while (JERRY_CONTEXT (jmem_heap_allocated_size) >= JERRY_CONTEXT (jmem_heap_limit))\n        {\n          JERRY_CONTEXT (jmem_heap_limit) += CONFIG_GC_LIMIT;\n        }\n\n        break;\n      }\n\n      JMEM_VALGRIND_NOACCESS_SPACE (current_p, sizeof (jmem_heap_free_t));\n      /* Next in list. */\n      prev_p = current_p;\n      current_offset = next_offset;\n    }\n  }\n\n  JMEM_VALGRIND_NOACCESS_SPACE (&JERRY_HEAP_CONTEXT (first), sizeof (jmem_heap_free_t));\n\n  JERRY_ASSERT ((uintptr_t) data_space_p % JMEM_ALIGNMENT == 0);\n  JMEM_VALGRIND_MALLOCLIKE_SPACE (data_space_p, size);\n\n  return (void *) data_space_p;\n#else /* ENABLED (JERRY_SYSTEM_ALLOCATOR) */\n  JERRY_CONTEXT (jmem_heap_allocated_size) += size;\n\n  while (JERRY_CONTEXT (jmem_heap_allocated_size) >= JERRY_CONTEXT (jmem_heap_limit))\n  {\n    JERRY_CONTEXT (jmem_heap_limit) += CONFIG_GC_LIMIT;\n  }\n\n  return malloc (size);\n#endif /* !ENABLED (JERRY_SYSTEM_ALLOCATOR) */\n}",
        "begin_line": 122,
        "end_line": 256,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_alloc_block#320",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_alloc_block (const size_t size) /**< required memory size */",
        "snippet": "extern inline void * JERRY_ATTR_HOT JERRY_ATTR_ALWAYS_INLINE\njmem_heap_alloc_block (const size_t size) /**< required memory size */\n{\n  void *block_p = jmem_heap_gc_and_alloc_block (size, JMEM_PRESSURE_FULL);\n  JMEM_HEAP_STAT_ALLOC (size);\n  return block_p;\n}",
        "begin_line": 320,
        "end_line": 326,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_alloc_block_internal#305",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_alloc_block_internal (const size_t size) /**< required memory size */",
        "snippet": "inline void * JERRY_ATTR_HOT JERRY_ATTR_ALWAYS_INLINE\njmem_heap_alloc_block_internal (const size_t size) /**< required memory size */\n{\n  return jmem_heap_gc_and_alloc_block (size, JMEM_PRESSURE_FULL);\n}",
        "begin_line": 305,
        "end_line": 309,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_alloc_block_null_on_error#338",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_alloc_block_null_on_error (const size_t size) /**< required memory size */",
        "snippet": "inline void * JERRY_ATTR_HOT JERRY_ATTR_ALWAYS_INLINE\njmem_heap_alloc_block_null_on_error (const size_t size) /**< required memory size */\n{\n  void *block_p = jmem_heap_gc_and_alloc_block (size, JMEM_PRESSURE_HIGH);\n\n#if ENABLED (JERRY_MEM_STATS)\n  if (block_p != NULL)\n  {\n    JMEM_HEAP_STAT_ALLOC (size);\n  }\n#endif /* ENABLED (JERRY_MEM_STATS) */\n\n  return block_p;\n}",
        "begin_line": 338,
        "end_line": 351,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_find_prev#359",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_find_prev (const jmem_heap_free_t * const block_p) /**< which memory block's predecessor we're looking for */",
        "snippet": "static jmem_heap_free_t *\njmem_heap_find_prev (const jmem_heap_free_t * const block_p) /**< which memory block's predecessor we're looking for */\n{\n  const jmem_heap_free_t *prev_p;\n\n  if (block_p > JERRY_CONTEXT (jmem_heap_list_skip_p))\n  {\n    prev_p = JERRY_CONTEXT (jmem_heap_list_skip_p);\n  }\n  else\n  {\n    prev_p = &JERRY_HEAP_CONTEXT (first);\n  }\n\n  JERRY_ASSERT (jmem_is_heap_pointer (block_p));\n  const uint32_t block_offset = JMEM_HEAP_GET_OFFSET_FROM_ADDR (block_p);\n\n  JMEM_VALGRIND_DEFINED_SPACE (prev_p, sizeof (jmem_heap_free_t));\n  /* Find position of region in the list. */\n  while (prev_p->next_offset < block_offset)\n  {\n    const jmem_heap_free_t * const next_p = JMEM_HEAP_GET_ADDR_FROM_OFFSET (prev_p->next_offset);\n    JERRY_ASSERT (jmem_is_heap_pointer (next_p));\n\n    JMEM_VALGRIND_DEFINED_SPACE (next_p, sizeof (jmem_heap_free_t));\n    JMEM_VALGRIND_NOACCESS_SPACE (prev_p, sizeof (jmem_heap_free_t));\n    prev_p = next_p;\n  }\n\n  JMEM_VALGRIND_NOACCESS_SPACE (prev_p, sizeof (jmem_heap_free_t));\n  return (jmem_heap_free_t *) prev_p;\n}",
        "begin_line": 359,
        "end_line": 390,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_free_block#681",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_free_block (void *ptr, /**< pointer to beginning of data space of the block */                       const size_t size) /**< size of allocated region */",
        "snippet": "extern inline void JERRY_ATTR_HOT JERRY_ATTR_ALWAYS_INLINE\njmem_heap_free_block (void *ptr, /**< pointer to beginning of data space of the block */\n                      const size_t size) /**< size of allocated region */\n{\n  jmem_heap_free_block_internal (ptr, size);\n  JMEM_HEAP_STAT_FREE (size);\n  return;\n}",
        "begin_line": 681,
        "end_line": 688,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_free_block_internal#452",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_free_block_internal (void *ptr, /**< pointer to beginning of data space of the block */                                const size_t size) /**< size of allocated region */",
        "snippet": "void JERRY_ATTR_HOT\njmem_heap_free_block_internal (void *ptr, /**< pointer to beginning of data space of the block */\n                               const size_t size) /**< size of allocated region */\n{\n  JERRY_ASSERT (size > 0);\n  JERRY_ASSERT (JERRY_CONTEXT (jmem_heap_limit) >= JERRY_CONTEXT (jmem_heap_allocated_size));\n  JERRY_ASSERT (JERRY_CONTEXT (jmem_heap_allocated_size) > 0);\n\n#if !ENABLED (JERRY_SYSTEM_ALLOCATOR)\n  /* checking that ptr points to the heap */\n  JERRY_ASSERT (jmem_is_heap_pointer (ptr));\n  JERRY_ASSERT ((uintptr_t) ptr % JMEM_ALIGNMENT == 0);\n\n  const size_t aligned_size = (size + JMEM_ALIGNMENT - 1) / JMEM_ALIGNMENT * JMEM_ALIGNMENT;\n\n  jmem_heap_free_t *const block_p = (jmem_heap_free_t *) ptr;\n  jmem_heap_free_t *const prev_p = jmem_heap_find_prev (block_p);\n  jmem_heap_insert_block (block_p, prev_p, aligned_size);\n\n  JERRY_CONTEXT (jmem_heap_allocated_size) -= aligned_size;\n\n  JMEM_VALGRIND_FREELIKE_SPACE (ptr);\n#else /* ENABLED (JERRY_SYSTEM_ALLOCATOR) */\n  JERRY_CONTEXT (jmem_heap_allocated_size) -= size;\n  free (ptr);\n#endif /* !ENABLED (JERRY_SYSTEM_ALLOCATOR) */\n  while (JERRY_CONTEXT (jmem_heap_allocated_size) + CONFIG_GC_LIMIT <= JERRY_CONTEXT (jmem_heap_limit))\n  {\n    JERRY_CONTEXT (jmem_heap_limit) -= CONFIG_GC_LIMIT;\n  }\n\n  JERRY_ASSERT (JERRY_CONTEXT (jmem_heap_limit) >= JERRY_CONTEXT (jmem_heap_allocated_size));\n}",
        "begin_line": 452,
        "end_line": 484,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_gc_and_alloc_block#270",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_gc_and_alloc_block (const size_t size, /**< required memory size */                               jmem_pressure_t max_pressure) /**< pressure limit */",
        "snippet": "static void *\njmem_heap_gc_and_alloc_block (const size_t size, /**< required memory size */\n                              jmem_pressure_t max_pressure) /**< pressure limit */\n{\n  if (JERRY_UNLIKELY (size == 0))\n  {\n    return NULL;\n  }\n\n  jmem_pressure_t pressure = JMEM_PRESSURE_NONE;\n\n#if !ENABLED (JERRY_MEM_GC_BEFORE_EACH_ALLOC)\n  if (JERRY_CONTEXT (jmem_heap_allocated_size) + size >= JERRY_CONTEXT (jmem_heap_limit))\n#endif /* !ENABLED (JERRY_MEM_GC_BEFORE_EACH_ALLOC) */\n  {\n    pressure = JMEM_PRESSURE_LOW;\n    ecma_free_unused_memory (pressure);\n  }\n\n  void *data_space_p = jmem_heap_alloc (size);\n\n  /* cppcheck-suppress memleak */\n  while (JERRY_UNLIKELY (data_space_p == NULL) && JERRY_LIKELY (pressure < max_pressure))\n  {\n    pressure++;\n    ecma_free_unused_memory (pressure);\n    data_space_p = jmem_heap_alloc (size);\n  }\n\n  return data_space_p;\n}",
        "begin_line": 270,
        "end_line": 300,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_get_region_end#62",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_get_region_end (jmem_heap_free_t *curr_p) /**< current region */",
        "snippet": "static inline jmem_heap_free_t *  JERRY_ATTR_ALWAYS_INLINE JERRY_ATTR_PURE\njmem_heap_get_region_end (jmem_heap_free_t *curr_p) /**< current region */\n{\n  return (jmem_heap_free_t *) ((uint8_t *) curr_p + curr_p->size);\n}",
        "begin_line": 62,
        "end_line": 66,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_init#72",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_init (void)",
        "snippet": "void\njmem_heap_init (void)\n{\n#if !ENABLED (JERRY_SYSTEM_ALLOCATOR)\n#if !ENABLED (JERRY_CPOINTER_32_BIT)\n  /* the maximum heap size for 16bit compressed pointers should be 512K */\n  JERRY_ASSERT (((UINT16_MAX + 1) << JMEM_ALIGNMENT_LOG) >= JMEM_HEAP_SIZE);\n#endif /* !ENABLED (JERRY_CPOINTER_32_BIT) */\n  JERRY_ASSERT ((uintptr_t) JERRY_HEAP_CONTEXT (area) % JMEM_ALIGNMENT == 0);\n\n  JERRY_CONTEXT (jmem_heap_limit) = CONFIG_GC_LIMIT;\n\n  jmem_heap_free_t *const region_p = (jmem_heap_free_t *) JERRY_HEAP_CONTEXT (area);\n\n  region_p->size = JMEM_HEAP_AREA_SIZE;\n  region_p->next_offset = JMEM_HEAP_END_OF_LIST;\n\n  JERRY_HEAP_CONTEXT (first).size = 0;\n  JERRY_HEAP_CONTEXT (first).next_offset = JMEM_HEAP_GET_OFFSET_FROM_ADDR (region_p);\n\n  JERRY_CONTEXT (jmem_heap_list_skip_p) = &JERRY_HEAP_CONTEXT (first);\n\n  JMEM_VALGRIND_NOACCESS_SPACE (&JERRY_HEAP_CONTEXT (first), sizeof (jmem_heap_free_t));\n  JMEM_VALGRIND_NOACCESS_SPACE (JERRY_HEAP_CONTEXT (area), JMEM_HEAP_AREA_SIZE);\n\n#endif /* !ENABLED (JERRY_SYSTEM_ALLOCATOR) */\n  JMEM_HEAP_STAT_INIT ();\n}",
        "begin_line": 72,
        "end_line": 99,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_insert_block#398",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_insert_block (jmem_heap_free_t *block_p, /**< block to insert */                         jmem_heap_free_t *prev_p, /**< the free block after which to insert 'block_p' */                         const size_t size) /**< size of the inserted block */",
        "snippet": "static void\njmem_heap_insert_block (jmem_heap_free_t *block_p, /**< block to insert */\n                        jmem_heap_free_t *prev_p, /**< the free block after which to insert 'block_p' */\n                        const size_t size) /**< size of the inserted block */\n{\n  JERRY_ASSERT ((uintptr_t) block_p % JMEM_ALIGNMENT == 0);\n  JERRY_ASSERT (size % JMEM_ALIGNMENT == 0);\n\n  JMEM_VALGRIND_NOACCESS_SPACE (block_p, size);\n\n  JMEM_VALGRIND_DEFINED_SPACE (prev_p, sizeof (jmem_heap_free_t));\n  jmem_heap_free_t *next_p = JMEM_HEAP_GET_ADDR_FROM_OFFSET (prev_p->next_offset);\n  JMEM_VALGRIND_DEFINED_SPACE (block_p, sizeof (jmem_heap_free_t));\n  JMEM_VALGRIND_DEFINED_SPACE (next_p, sizeof (jmem_heap_free_t));\n\n  const uint32_t block_offset = JMEM_HEAP_GET_OFFSET_FROM_ADDR (block_p);\n\n  /* Update prev. */\n  if (jmem_heap_get_region_end (prev_p) == block_p)\n  {\n    /* Can be merged. */\n    prev_p->size += (uint32_t) size;\n    JMEM_VALGRIND_NOACCESS_SPACE (block_p, sizeof (jmem_heap_free_t));\n    block_p = prev_p;\n  }\n  else\n  {\n    block_p->size = (uint32_t) size;\n    prev_p->next_offset = block_offset;\n  }\n\n  /* Update next. */\n  if (jmem_heap_get_region_end (block_p) == next_p)\n  {\n    /* Can be merged. */\n    block_p->size += next_p->size;\n    block_p->next_offset = next_p->next_offset;\n  }\n  else\n  {\n    block_p->next_offset = JMEM_HEAP_GET_OFFSET_FROM_ADDR (next_p);\n  }\n\n  JERRY_CONTEXT (jmem_heap_list_skip_p) = prev_p;\n\n  JMEM_VALGRIND_NOACCESS_SPACE (prev_p, sizeof (jmem_heap_free_t));\n  JMEM_VALGRIND_NOACCESS_SPACE (block_p, sizeof (jmem_heap_free_t));\n  JMEM_VALGRIND_NOACCESS_SPACE (next_p, sizeof (jmem_heap_free_t));\n}",
        "begin_line": 398,
        "end_line": 446,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_realloc_block#491",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_realloc_block (void *ptr, /**< memory region to reallocate */                          const size_t old_size, /**< current size of the region */                          const size_t new_size) /**< desired new size */",
        "snippet": "void * JERRY_ATTR_HOT\njmem_heap_realloc_block (void *ptr, /**< memory region to reallocate */\n                         const size_t old_size, /**< current size of the region */\n                         const size_t new_size) /**< desired new size */\n{\n#if !ENABLED (JERRY_SYSTEM_ALLOCATOR)\n  JERRY_ASSERT (jmem_is_heap_pointer (ptr));\n  JERRY_ASSERT ((uintptr_t) ptr % JMEM_ALIGNMENT == 0);\n  JERRY_ASSERT (old_size != 0);\n  JERRY_ASSERT (new_size != 0);\n\n  jmem_heap_free_t * const block_p = (jmem_heap_free_t *) ptr;\n  const size_t aligned_new_size = (new_size + JMEM_ALIGNMENT - 1) / JMEM_ALIGNMENT * JMEM_ALIGNMENT;\n  const size_t aligned_old_size = (old_size + JMEM_ALIGNMENT - 1) / JMEM_ALIGNMENT * JMEM_ALIGNMENT;\n\n  if (aligned_old_size == aligned_new_size)\n  {\n    JMEM_VALGRIND_RESIZE_SPACE (block_p, old_size, new_size);\n    JMEM_HEAP_STAT_FREE (old_size);\n    JMEM_HEAP_STAT_ALLOC (new_size);\n    return block_p;\n  }\n\n  if (aligned_new_size < aligned_old_size)\n  {\n    JMEM_VALGRIND_RESIZE_SPACE (block_p, old_size, new_size);\n    JMEM_HEAP_STAT_FREE (old_size);\n    JMEM_HEAP_STAT_ALLOC (new_size);\n    jmem_heap_insert_block ((jmem_heap_free_t *) ((uint8_t *) block_p + aligned_new_size),\n                            jmem_heap_find_prev (block_p),\n                            aligned_old_size - aligned_new_size);\n\n    JERRY_CONTEXT (jmem_heap_allocated_size) -= (aligned_old_size - aligned_new_size);\n    while (JERRY_CONTEXT (jmem_heap_allocated_size) + CONFIG_GC_LIMIT <= JERRY_CONTEXT (jmem_heap_limit))\n    {\n      JERRY_CONTEXT (jmem_heap_limit) -= CONFIG_GC_LIMIT;\n    }\n\n    return block_p;\n  }\n\n  void *ret_block_p = NULL;\n  const size_t required_size = aligned_new_size - aligned_old_size;\n\n#if !ENABLED (JERRY_MEM_GC_BEFORE_EACH_ALLOC)\n  if (JERRY_CONTEXT (jmem_heap_allocated_size) + required_size >= JERRY_CONTEXT (jmem_heap_limit))\n#endif /* !ENABLED (JERRY_MEM_GC_BEFORE_EACH_ALLOC) */\n  {\n    ecma_free_unused_memory (JMEM_PRESSURE_LOW);\n  }\n\n  jmem_heap_free_t *prev_p = jmem_heap_find_prev (block_p);\n  JMEM_VALGRIND_DEFINED_SPACE (prev_p, sizeof (jmem_heap_free_t));\n  jmem_heap_free_t * const next_p = JMEM_HEAP_GET_ADDR_FROM_OFFSET (prev_p->next_offset);\n\n  /* Check if block can be extended at the end */\n  if (((jmem_heap_free_t *) ((uint8_t *) block_p + aligned_old_size)) == next_p)\n  {\n    JMEM_VALGRIND_DEFINED_SPACE (next_p, sizeof (jmem_heap_free_t));\n\n    if (required_size <= next_p->size)\n    {\n      /* Block can be extended, update the list. */\n      if (required_size == next_p->size)\n      {\n        prev_p->next_offset = next_p->next_offset;\n      }\n      else\n      {\n        jmem_heap_free_t *const new_next_p = (jmem_heap_free_t *) ((uint8_t *) next_p + required_size);\n        JMEM_VALGRIND_DEFINED_SPACE (new_next_p, sizeof (jmem_heap_free_t));\n        new_next_p->next_offset = next_p->next_offset;\n        new_next_p->size = (uint32_t) (next_p->size - required_size);\n        JMEM_VALGRIND_NOACCESS_SPACE (new_next_p, sizeof (jmem_heap_free_t));\n        prev_p->next_offset = JMEM_HEAP_GET_OFFSET_FROM_ADDR (new_next_p);\n      }\n\n      /* next_p will be marked as undefined space. */\n      JMEM_VALGRIND_RESIZE_SPACE (block_p, old_size, new_size);\n      ret_block_p = block_p;\n    }\n    else\n    {\n      JMEM_VALGRIND_NOACCESS_SPACE (next_p, sizeof (jmem_heap_free_t));\n    }\n\n    JMEM_VALGRIND_NOACCESS_SPACE (prev_p, sizeof (jmem_heap_free_t));\n  }\n  /*\n   * Check if block can be extended at the front.\n   * This is less optimal because we need to copy the data, but still better than allocting a new block.\n   */\n  else if (jmem_heap_get_region_end (prev_p) == block_p)\n  {\n    if (required_size <= prev_p->size)\n    {\n      if (required_size == prev_p->size)\n      {\n        JMEM_VALGRIND_NOACCESS_SPACE (prev_p, sizeof (jmem_heap_free_t));\n        prev_p = jmem_heap_find_prev (prev_p);\n        JMEM_VALGRIND_DEFINED_SPACE (prev_p, sizeof (jmem_heap_free_t));\n        prev_p->next_offset = JMEM_HEAP_GET_OFFSET_FROM_ADDR (next_p);\n      }\n      else\n      {\n        prev_p->size = (uint32_t) (prev_p->size - required_size);\n      }\n\n      JMEM_VALGRIND_NOACCESS_SPACE (prev_p, sizeof (jmem_heap_free_t));\n\n      ret_block_p = (uint8_t *) block_p - required_size;\n\n      /* Mark the the new block as undefined so that we are able to write to it. */\n      JMEM_VALGRIND_UNDEFINED_SPACE (ret_block_p, old_size);\n      /* The blocks are likely to overlap, so mark the old block as defined memory again. */\n      JMEM_VALGRIND_DEFINED_SPACE (block_p, old_size);\n      memmove (ret_block_p, block_p, old_size);\n\n      JMEM_VALGRIND_FREELIKE_SPACE (block_p);\n      JMEM_VALGRIND_MALLOCLIKE_SPACE (ret_block_p, new_size);\n      JMEM_VALGRIND_DEFINED_SPACE (ret_block_p, old_size);\n    }\n    else\n    {\n      JMEM_VALGRIND_NOACCESS_SPACE (prev_p, sizeof (jmem_heap_free_t));\n    }\n  }\n\n  if (ret_block_p != NULL)\n  {\n    /* Managed to extend the block. Update memory usage and the skip pointer. */\n    JERRY_CONTEXT (jmem_heap_list_skip_p) = prev_p;\n    JERRY_CONTEXT (jmem_heap_allocated_size) += required_size;\n\n    while (JERRY_CONTEXT (jmem_heap_allocated_size) >= JERRY_CONTEXT (jmem_heap_limit))\n    {\n      JERRY_CONTEXT (jmem_heap_limit) += CONFIG_GC_LIMIT;\n    }\n  }\n  else\n  {\n    /* Could not extend block. Allocate new region and copy the data. */\n    /* jmem_heap_alloc_block_internal will adjust the allocated_size, but insert_block will not,\n       so we reduce it here first, so that the limit calculation remains consistent. */\n    JERRY_CONTEXT (jmem_heap_allocated_size) -= aligned_old_size;\n    ret_block_p = jmem_heap_alloc_block_internal (new_size);\n\n    /* jmem_heap_alloc_block_internal may trigger garbage collection, which can create new free blocks\n     * in the heap structure, so we need to look up the previous block again. */\n    prev_p = jmem_heap_find_prev (block_p);\n\n    memcpy (ret_block_p, block_p, old_size);\n    jmem_heap_insert_block (block_p, prev_p, aligned_old_size);\n    /* jmem_heap_alloc_block_internal will call JMEM_VALGRIND_MALLOCLIKE_SPACE */\n    JMEM_VALGRIND_FREELIKE_SPACE (block_p);\n  }\n\n  JMEM_HEAP_STAT_FREE (old_size);\n  JMEM_HEAP_STAT_ALLOC (new_size);\n  return ret_block_p;\n#else /* ENABLED (JERRY_SYSTEM_ALLOCATOR) */\n  const size_t required_size = new_size - old_size;\n#if !ENABLED (JERRY_MEM_GC_BEFORE_EACH_ALLOC)\n  if (JERRY_CONTEXT (jmem_heap_allocated_size) + required_size >= JERRY_CONTEXT (jmem_heap_limit))\n#endif /* !ENABLED (JERRY_MEM_GC_BEFORE_EACH_ALLOC) */\n  {\n    ecma_free_unused_memory (JMEM_PRESSURE_LOW);\n  }\n\n  JERRY_CONTEXT (jmem_heap_allocated_size) += required_size;\n\n  while (JERRY_CONTEXT (jmem_heap_allocated_size) >= JERRY_CONTEXT (jmem_heap_limit))\n  {\n    JERRY_CONTEXT (jmem_heap_limit) += CONFIG_GC_LIMIT;\n  }\n\n  while (JERRY_CONTEXT (jmem_heap_allocated_size) + CONFIG_GC_LIMIT <= JERRY_CONTEXT (jmem_heap_limit))\n  {\n    JERRY_CONTEXT (jmem_heap_limit) -= CONFIG_GC_LIMIT;\n  }\n\n  JMEM_HEAP_STAT_FREE (old_size);\n  JMEM_HEAP_STAT_ALLOC (new_size);\n  return realloc (ptr, new_size);\n#endif /* !ENABLED (JERRY_SYSTEM_ALLOCATOR) */\n}",
        "begin_line": 491,
        "end_line": 676,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-poolman.jmem_pools_alloc#58",
        "src_path": "jerry-core/jmem/jmem-poolman.c",
        "class_name": "jerry-core.jmem.jmem-poolman",
        "signature": "jerry-core.jmem.jmem-poolman.jmem_pools_alloc (size_t size) /**< size of the chunk */",
        "snippet": "extern inline void * JERRY_ATTR_HOT JERRY_ATTR_ALWAYS_INLINE\njmem_pools_alloc (size_t size) /**< size of the chunk */\n{\n#if ENABLED (JERRY_MEM_GC_BEFORE_EACH_ALLOC)\n  ecma_free_unused_memory (JMEM_PRESSURE_LOW);\n#endif /* ENABLED (JERRY_MEM_GC_BEFORE_EACH_ALLOC) */\n\n#if ENABLED (JERRY_CPOINTER_32_BIT)\n  if (size <= 8)\n  {\n#else /* !ENABLED (JERRY_CPOINTER_32_BIT) */\n    JERRY_ASSERT (size <= 8);\n#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */\n\n    if (JERRY_CONTEXT (jmem_free_8_byte_chunk_p) != NULL)\n    {\n      const jmem_pools_chunk_t *const chunk_p = JERRY_CONTEXT (jmem_free_8_byte_chunk_p);\n\n      JMEM_VALGRIND_DEFINED_SPACE (chunk_p, sizeof (jmem_pools_chunk_t));\n      JERRY_CONTEXT (jmem_free_8_byte_chunk_p) = chunk_p->next_p;\n      JMEM_VALGRIND_UNDEFINED_SPACE (chunk_p, sizeof (jmem_pools_chunk_t));\n\n      JMEM_HEAP_STAT_ALLOC (8);\n      return (void *) chunk_p;\n    }\n    else\n    {\n      void *chunk_p = jmem_heap_alloc_block_internal (8);\n      JMEM_HEAP_STAT_ALLOC (8);\n      return chunk_p;\n    }\n\n#if ENABLED (JERRY_CPOINTER_32_BIT)\n  }\n\n  JERRY_ASSERT (size <= 16);\n\n  if (JERRY_CONTEXT (jmem_free_16_byte_chunk_p) != NULL)\n  {\n    const jmem_pools_chunk_t *const chunk_p = JERRY_CONTEXT (jmem_free_16_byte_chunk_p);\n\n    JMEM_VALGRIND_DEFINED_SPACE (chunk_p, sizeof (jmem_pools_chunk_t));\n    JERRY_CONTEXT (jmem_free_16_byte_chunk_p) = chunk_p->next_p;\n    JMEM_VALGRIND_UNDEFINED_SPACE (chunk_p, sizeof (jmem_pools_chunk_t));\n\n    JMEM_HEAP_STAT_ALLOC (16);\n    return (void *) chunk_p;\n  }\n  else\n  {\n    void *chunk_p = jmem_heap_alloc_block_internal (16);\n    JMEM_HEAP_STAT_ALLOC (16);\n    return chunk_p;\n  }\n#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */\n}",
        "begin_line": 58,
        "end_line": 113,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-poolman.jmem_pools_collect_empty#156",
        "src_path": "jerry-core/jmem/jmem-poolman.c",
        "class_name": "jerry-core.jmem.jmem-poolman",
        "signature": "jerry-core.jmem.jmem-poolman.jmem_pools_collect_empty (void)",
        "snippet": "void\njmem_pools_collect_empty (void)\n{\n  jmem_pools_chunk_t *chunk_p = JERRY_CONTEXT (jmem_free_8_byte_chunk_p);\n  JERRY_CONTEXT (jmem_free_8_byte_chunk_p) = NULL;\n\n  while (chunk_p)\n  {\n    JMEM_VALGRIND_DEFINED_SPACE (chunk_p, sizeof (jmem_pools_chunk_t));\n    jmem_pools_chunk_t *const next_p = chunk_p->next_p;\n    JMEM_VALGRIND_NOACCESS_SPACE (chunk_p, sizeof (jmem_pools_chunk_t));\n\n    jmem_heap_free_block_internal (chunk_p, 8);\n    chunk_p = next_p;\n  }\n\n#if ENABLED (JERRY_CPOINTER_32_BIT)\n  chunk_p = JERRY_CONTEXT (jmem_free_16_byte_chunk_p);\n  JERRY_CONTEXT (jmem_free_16_byte_chunk_p) = NULL;\n\n  while (chunk_p)\n  {\n    JMEM_VALGRIND_DEFINED_SPACE (chunk_p, sizeof (jmem_pools_chunk_t));\n    jmem_pools_chunk_t *const next_p = chunk_p->next_p;\n    JMEM_VALGRIND_NOACCESS_SPACE (chunk_p, sizeof (jmem_pools_chunk_t));\n\n    jmem_heap_free_block_internal (chunk_p, 16);\n    chunk_p = next_p;\n  }\n#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */\n}",
        "begin_line": 156,
        "end_line": 186,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-poolman.jmem_pools_free#118",
        "src_path": "jerry-core/jmem/jmem-poolman.c",
        "class_name": "jerry-core.jmem.jmem-poolman",
        "signature": "jerry-core.jmem.jmem-poolman.jmem_pools_free (void *chunk_p, /**< pointer to the chunk */                  size_t size) /**< size of the chunk */",
        "snippet": "extern inline void JERRY_ATTR_HOT JERRY_ATTR_ALWAYS_INLINE\njmem_pools_free (void *chunk_p, /**< pointer to the chunk */\n                 size_t size) /**< size of the chunk */\n{\n  JERRY_ASSERT (chunk_p != NULL);\n  JMEM_HEAP_STAT_FREE (size);\n\n  jmem_pools_chunk_t *const chunk_to_free_p = (jmem_pools_chunk_t *) chunk_p;\n\n  JMEM_VALGRIND_DEFINED_SPACE (chunk_to_free_p, size);\n\n#if ENABLED (JERRY_CPOINTER_32_BIT)\n  if (size <= 8)\n  {\n#else /* !ENABLED (JERRY_CPOINTER_32_BIT) */\n    JERRY_ASSERT (size <= 8);\n#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */\n\n    chunk_to_free_p->next_p = JERRY_CONTEXT (jmem_free_8_byte_chunk_p);\n    JERRY_CONTEXT (jmem_free_8_byte_chunk_p) = chunk_to_free_p;\n\n#if ENABLED (JERRY_CPOINTER_32_BIT)\n  }\n  else\n  {\n    JERRY_ASSERT (size <= 16);\n\n    chunk_to_free_p->next_p = JERRY_CONTEXT (jmem_free_16_byte_chunk_p);\n    JERRY_CONTEXT (jmem_free_16_byte_chunk_p) = chunk_to_free_p;\n  }\n#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */\n\n  JMEM_VALGRIND_NOACCESS_SPACE (chunk_to_free_p, size);\n}",
        "begin_line": 118,
        "end_line": 151,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-char-helpers.lit_char_is_white_space#112",
        "src_path": "jerry-core/lit/lit-char-helpers.c",
        "class_name": "jerry-core.lit.lit-char-helpers",
        "signature": "jerry-core.lit.lit-char-helpers.lit_char_is_white_space (lit_code_point_t c) /**< code point */",
        "snippet": "bool\nlit_char_is_white_space (lit_code_point_t c) /**< code point */\n{\n  if (c <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)\n  {\n    return (c == LIT_CHAR_SP || (c >= LIT_CHAR_TAB && c <= LIT_CHAR_CR));\n  }\n  else\n  {\n    if (c == LIT_CHAR_NBSP || c == LIT_CHAR_BOM || c == LIT_CHAR_LS || c == LIT_CHAR_PS)\n    {\n      return true;\n    }\n\n    return (c <= LIT_UTF16_CODE_UNIT_MAX\n            && ((c >= lit_unicode_separator_char_interval_sps[0]\n                 && c < lit_unicode_separator_char_interval_sps[0] + lit_unicode_separator_char_interval_lengths[0])\n                || search_char_in_char_array ((ecma_char_t) c,\n                                              lit_unicode_separator_chars,\n                                              NUM_OF_ELEMENTS (lit_unicode_separator_chars))));\n  }\n}",
        "begin_line": 112,
        "end_line": 133,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-char-helpers.lit_code_point_is_identifier_part#239",
        "src_path": "jerry-core/lit/lit-char-helpers.c",
        "class_name": "jerry-core.lit.lit-char-helpers",
        "signature": "jerry-core.lit.lit-char-helpers.lit_code_point_is_identifier_part (lit_code_point_t code_point) /**< code point */",
        "snippet": "bool\nlit_code_point_is_identifier_part (lit_code_point_t code_point) /**< code point */\n{\n  /* Fast path for ASCII-defined letters. */\n  if (code_point <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)\n  {\n    return ((LEXER_TO_ASCII_LOWERCASE (code_point) >= LIT_CHAR_LOWERCASE_A\n             && LEXER_TO_ASCII_LOWERCASE (code_point) <= LIT_CHAR_LOWERCASE_Z)\n            || (code_point >= LIT_CHAR_0 && code_point <= LIT_CHAR_9)\n            || code_point == LIT_CHAR_DOLLAR_SIGN\n            || code_point == LIT_CHAR_UNDERSCORE);\n  }\n\n#if ENABLED (JERRY_ES2015)\n  if (code_point >= LIT_UTF8_4_BYTE_CODE_POINT_MIN)\n  {\n    /* TODO: detect these ranges correctly. */\n    return (code_point >= 0x10C80 && code_point <= 0x10CF2);\n  }\n#else /* !ENABLED (JERRY_ES2015) */\n  JERRY_ASSERT (code_point <= LIT_UTF8_4_BYTE_CODE_POINT_MIN);\n#endif /* ENABLED (JERRY_ES2015) */\n\n  return (lit_char_is_unicode_letter ((ecma_char_t) code_point)\n          || lit_char_is_unicode_non_letter_ident_part ((ecma_char_t) code_point));\n}",
        "begin_line": 239,
        "end_line": 264,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-char-helpers.lit_code_point_is_identifier_start#209",
        "src_path": "jerry-core/lit/lit-char-helpers.c",
        "class_name": "jerry-core.lit.lit-char-helpers",
        "signature": "jerry-core.lit.lit-char-helpers.lit_code_point_is_identifier_start (lit_code_point_t code_point) /**< code point */",
        "snippet": "bool\nlit_code_point_is_identifier_start (lit_code_point_t code_point) /**< code point */\n{\n  /* Fast path for ASCII-defined letters. */\n  if (code_point <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)\n  {\n    return ((LEXER_TO_ASCII_LOWERCASE (code_point) >= LIT_CHAR_LOWERCASE_A\n             && LEXER_TO_ASCII_LOWERCASE (code_point) <= LIT_CHAR_LOWERCASE_Z)\n            || code_point == LIT_CHAR_DOLLAR_SIGN\n            || code_point == LIT_CHAR_UNDERSCORE);\n  }\n\n#if ENABLED (JERRY_ES2015)\n  if (code_point >= LIT_UTF8_4_BYTE_CODE_POINT_MIN)\n  {\n    /* TODO: detect these ranges correctly. */\n    return (code_point >= 0x10C80 && code_point <= 0x10CF2);\n  }\n#else /* !ENABLED (JERRY_ES2015) */\n  JERRY_ASSERT (code_point <= LIT_UTF8_4_BYTE_CODE_POINT_MIN);\n#endif /* ENABLED (JERRY_ES2015) */\n\n  return lit_char_is_unicode_letter ((ecma_char_t) code_point);\n}",
        "begin_line": 209,
        "end_line": 232,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_ex_count#31",
        "src_path": "jerry-core/lit/lit-magic-strings.c",
        "class_name": "jerry-core.lit.lit-magic-strings",
        "signature": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_ex_count (void)",
        "snippet": "inline uint32_t JERRY_ATTR_ALWAYS_INLINE\nlit_get_magic_string_ex_count (void)\n{\n  return JERRY_CONTEXT (lit_magic_string_ex_count);\n}",
        "begin_line": 31,
        "end_line": 35,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_size#67",
        "src_path": "jerry-core/lit/lit-magic-strings.c",
        "class_name": "jerry-core.lit.lit-magic-strings",
        "signature": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_size (uint32_t id) /**< magic string id */",
        "snippet": "lit_utf8_size_t\nlit_get_magic_string_size (uint32_t id) /**< magic string id */\n{\n  static const lit_magic_size_t lit_magic_string_sizes[] JERRY_ATTR_CONST_DATA =\n  {\n/** @cond doxygen_suppress */\n#define LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE(size, id)\n#define LIT_MAGIC_STRING_DEF(id, utf8_string) \\\n    sizeof(utf8_string) - 1,\n#include \"lit-magic-strings.inc.h\"\n#undef LIT_MAGIC_STRING_DEF\n#undef LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE\n/** @endcond */\n  };\n\n  JERRY_ASSERT (id < LIT_NON_INTERNAL_MAGIC_STRING__COUNT);\n\n  return lit_magic_string_sizes[id];\n}",
        "begin_line": 67,
        "end_line": 85,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_size_block_start#93",
        "src_path": "jerry-core/lit/lit-magic-strings.c",
        "class_name": "jerry-core.lit.lit-magic-strings",
        "signature": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_size_block_start (lit_utf8_size_t size) /**< magic string size */",
        "snippet": "static lit_magic_string_id_t\nlit_get_magic_string_size_block_start (lit_utf8_size_t size) /**< magic string size */\n{\n  static const lit_magic_string_id_t lit_magic_string_size_block_starts[] JERRY_ATTR_CONST_DATA =\n  {\n/** @cond doxygen_suppress */\n#define LIT_MAGIC_STRING_DEF(id, utf8_string)\n#define LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE(size, id) \\\n    id,\n#include \"lit-magic-strings.inc.h\"\n    LIT_NON_INTERNAL_MAGIC_STRING__COUNT\n#undef LIT_MAGIC_STRING_DEF\n#undef LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE\n/** @endcond */\n  };\n\n  JERRY_ASSERT (size <= (sizeof (lit_magic_string_size_block_starts) / sizeof (lit_magic_string_id_t)));\n\n  return lit_magic_string_size_block_starts[size];\n}",
        "begin_line": 93,
        "end_line": 112,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_utf8#42",
        "src_path": "jerry-core/lit/lit-magic-strings.c",
        "class_name": "jerry-core.lit.lit-magic-strings",
        "signature": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_utf8 (uint32_t id) /**< magic string id */",
        "snippet": "const lit_utf8_byte_t *\nlit_get_magic_string_utf8 (uint32_t id) /**< magic string id */\n{\n  static const lit_utf8_byte_t * const lit_magic_strings[] JERRY_ATTR_CONST_DATA =\n  {\n/** @cond doxygen_suppress */\n#define LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE(size, id)\n#define LIT_MAGIC_STRING_DEF(id, utf8_string) \\\n    (const lit_utf8_byte_t *) utf8_string,\n#include \"lit-magic-strings.inc.h\"\n#undef LIT_MAGIC_STRING_DEF\n#undef LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE\n/** @endcond */\n  };\n\n  JERRY_ASSERT (id < LIT_NON_INTERNAL_MAGIC_STRING__COUNT);\n\n  return lit_magic_strings[id];\n}",
        "begin_line": 42,
        "end_line": 60,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-magic-strings.lit_is_utf8_string_magic#202",
        "src_path": "jerry-core/lit/lit-magic-strings.c",
        "class_name": "jerry-core.lit.lit-magic-strings",
        "signature": "jerry-core.lit.lit-magic-strings.lit_is_utf8_string_magic (const lit_utf8_byte_t *string_p, /**< utf-8 string */                           lit_utf8_size_t string_size) /**< string size in bytes */",
        "snippet": "lit_magic_string_id_t\nlit_is_utf8_string_magic (const lit_utf8_byte_t *string_p, /**< utf-8 string */\n                          lit_utf8_size_t string_size) /**< string size in bytes */\n{\n  if (string_size > lit_get_magic_string_size (LIT_NON_INTERNAL_MAGIC_STRING__COUNT - 1))\n  {\n    return LIT_MAGIC_STRING__COUNT;\n  }\n\n  /**< The string must be in this id range. */\n  lit_utf8_size_t first = lit_get_magic_string_size_block_start (string_size);\n  lit_utf8_size_t last = lit_get_magic_string_size_block_start (string_size + 1);\n\n  while (first < last)\n  {\n    lit_utf8_size_t middle = ((first + last) / 2); /**< mid point of search */\n    int compare = memcmp (lit_get_magic_string_utf8 ((lit_magic_string_id_t) middle), string_p, string_size);\n\n    if (compare == 0)\n    {\n      return (lit_magic_string_id_t) middle;\n    }\n    else if (compare > 0)\n    {\n      last = middle;\n    }\n    else\n    {\n      first = middle + 1;\n    }\n  }\n\n  return LIT_MAGIC_STRING__COUNT;\n}",
        "begin_line": 202,
        "end_line": 235,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_get_unicode_char_size_by_utf8_first_byte#646",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_get_unicode_char_size_by_utf8_first_byte (const lit_utf8_byte_t first_byte) /**< buffer with characters */",
        "snippet": "inline lit_utf8_size_t JERRY_ATTR_ALWAYS_INLINE\nlit_get_unicode_char_size_by_utf8_first_byte (const lit_utf8_byte_t first_byte) /**< buffer with characters */\n{\n  if ((first_byte & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)\n  {\n    return 1;\n  }\n  else if ((first_byte & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)\n  {\n    return 2;\n  }\n  else\n  {\n    JERRY_ASSERT ((first_byte & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER);\n    return 3;\n  }\n}",
        "begin_line": 646,
        "end_line": 662,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_is_valid_cesu8_string#127",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_is_valid_cesu8_string (const lit_utf8_byte_t *cesu8_buf_p, /**< cesu-8 string */                            lit_utf8_size_t buf_size) /**< string size */",
        "snippet": "bool\nlit_is_valid_cesu8_string (const lit_utf8_byte_t *cesu8_buf_p, /**< cesu-8 string */\n                           lit_utf8_size_t buf_size) /**< string size */\n{\n  lit_utf8_size_t idx = 0;\n\n  while (idx < buf_size)\n  {\n    lit_utf8_byte_t c = cesu8_buf_p[idx++];\n    if ((c & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)\n    {\n      continue;\n    }\n\n    lit_code_point_t code_point = 0;\n    lit_code_point_t min_code_point = 0;\n    lit_utf8_size_t extra_bytes_count;\n    if ((c & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)\n    {\n      extra_bytes_count = 1;\n      min_code_point = LIT_UTF8_2_BYTE_CODE_POINT_MIN;\n      code_point = ((uint32_t) (c & LIT_UTF8_LAST_5_BITS_MASK));\n    }\n    else if ((c & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER)\n    {\n      extra_bytes_count = 2;\n      min_code_point = LIT_UTF8_3_BYTE_CODE_POINT_MIN;\n      code_point = ((uint32_t) (c & LIT_UTF8_LAST_4_BITS_MASK));\n    }\n    else\n    {\n      return false;\n    }\n\n    if (idx + extra_bytes_count > buf_size)\n    {\n      /* cesu-8 string breaks in the middle */\n      return false;\n    }\n\n    for (lit_utf8_size_t offset = 0; offset < extra_bytes_count; ++offset)\n    {\n      c = cesu8_buf_p[idx + offset];\n      if ((c & LIT_UTF8_EXTRA_BYTE_MASK) != LIT_UTF8_EXTRA_BYTE_MARKER)\n      {\n        /* invalid continuation byte */\n        return false;\n      }\n      code_point <<= LIT_UTF8_BITS_IN_EXTRA_BYTES;\n      code_point |= (c & LIT_UTF8_LAST_6_BITS_MASK);\n    }\n\n    if (code_point < min_code_point)\n    {\n      /* cesu-8 string doesn't encode valid unicode code point */\n      return false;\n    }\n\n    idx += extra_bytes_count;\n  }\n\n  return true;\n}",
        "begin_line": 127,
        "end_line": 189,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_is_valid_utf8_string#30",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_is_valid_utf8_string (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */                           lit_utf8_size_t buf_size) /**< string size */",
        "snippet": "bool\nlit_is_valid_utf8_string (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */\n                          lit_utf8_size_t buf_size) /**< string size */\n{\n  lit_utf8_size_t idx = 0;\n\n  bool is_prev_code_point_high_surrogate = false;\n  while (idx < buf_size)\n  {\n    lit_utf8_byte_t c = utf8_buf_p[idx++];\n    if ((c & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)\n    {\n      is_prev_code_point_high_surrogate = false;\n      continue;\n    }\n\n    lit_code_point_t code_point = 0;\n    lit_code_point_t min_code_point = 0;\n    lit_utf8_size_t extra_bytes_count;\n    if ((c & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)\n    {\n      extra_bytes_count = 1;\n      min_code_point = LIT_UTF8_2_BYTE_CODE_POINT_MIN;\n      code_point = ((uint32_t) (c & LIT_UTF8_LAST_5_BITS_MASK));\n    }\n    else if ((c & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER)\n    {\n      extra_bytes_count = 2;\n      min_code_point = LIT_UTF8_3_BYTE_CODE_POINT_MIN;\n      code_point = ((uint32_t) (c & LIT_UTF8_LAST_4_BITS_MASK));\n    }\n    else if ((c & LIT_UTF8_4_BYTE_MASK) == LIT_UTF8_4_BYTE_MARKER)\n    {\n      extra_bytes_count = 3;\n      min_code_point = LIT_UTF8_4_BYTE_CODE_POINT_MIN;\n      code_point = ((uint32_t) (c & LIT_UTF8_LAST_3_BITS_MASK));\n    }\n    else\n    {\n      /* utf-8 string could not contain 5- and 6-byte sequences. */\n      return false;\n    }\n\n    if (idx + extra_bytes_count > buf_size)\n    {\n      /* utf-8 string breaks in the middle */\n      return false;\n    }\n\n    for (lit_utf8_size_t offset = 0; offset < extra_bytes_count; ++offset)\n    {\n      c = utf8_buf_p[idx + offset];\n      if ((c & LIT_UTF8_EXTRA_BYTE_MASK) != LIT_UTF8_EXTRA_BYTE_MARKER)\n      {\n        /* invalid continuation byte */\n        return false;\n      }\n      code_point <<= LIT_UTF8_BITS_IN_EXTRA_BYTES;\n      code_point |= (c & LIT_UTF8_LAST_6_BITS_MASK);\n    }\n\n    if (code_point < min_code_point\n        || code_point > LIT_UNICODE_CODE_POINT_MAX)\n    {\n      /* utf-8 string doesn't encode valid unicode code point */\n      return false;\n    }\n\n    if (code_point >= LIT_UTF16_HIGH_SURROGATE_MIN\n        && code_point <= LIT_UTF16_HIGH_SURROGATE_MAX)\n    {\n      is_prev_code_point_high_surrogate = true;\n    }\n    else if (code_point >= LIT_UTF16_LOW_SURROGATE_MIN\n             && code_point <= LIT_UTF16_LOW_SURROGATE_MAX\n             && is_prev_code_point_high_surrogate)\n    {\n      /* sequence of high and low surrogate is not allowed */\n      return false;\n    }\n    else\n    {\n      is_prev_code_point_high_surrogate = false;\n    }\n\n    idx += extra_bytes_count;\n  }\n\n  return true;\n}",
        "begin_line": 30,
        "end_line": 119,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_read_code_unit_from_utf8#425",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_read_code_unit_from_utf8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */                               ecma_char_t *code_point) /**< [out] code point */",
        "snippet": "lit_utf8_size_t\nlit_read_code_unit_from_utf8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */\n                              ecma_char_t *code_point) /**< [out] code point */\n{\n  JERRY_ASSERT (buf_p);\n\n  lit_utf8_byte_t c = buf_p[0];\n  if ((c & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)\n  {\n    *code_point = (ecma_char_t) (c & LIT_UTF8_LAST_7_BITS_MASK);\n    return 1;\n  }\n\n  lit_code_point_t ret = LIT_UNICODE_CODE_POINT_NULL;\n  ecma_length_t bytes_count;\n  if ((c & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)\n  {\n    bytes_count = 2;\n    ret = ((lit_code_point_t) (c & LIT_UTF8_LAST_5_BITS_MASK));\n  }\n  else\n  {\n    JERRY_ASSERT ((c & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER);\n    bytes_count = 3;\n    ret = ((lit_code_point_t) (c & LIT_UTF8_LAST_4_BITS_MASK));\n  }\n\n  for (uint32_t i = 1; i < bytes_count; ++i)\n  {\n    ret <<= LIT_UTF8_BITS_IN_EXTRA_BYTES;\n    ret |= (buf_p[i] & LIT_UTF8_LAST_6_BITS_MASK);\n  }\n\n  JERRY_ASSERT (ret <= LIT_UTF16_CODE_UNIT_MAX);\n  *code_point = (ecma_char_t) ret;\n  return bytes_count;\n}",
        "begin_line": 425,
        "end_line": 461,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_read_prev_code_unit_from_utf8#468",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_read_prev_code_unit_from_utf8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */                                    ecma_char_t *code_point) /**< [out] code point */",
        "snippet": "lit_utf8_size_t\nlit_read_prev_code_unit_from_utf8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */\n                                   ecma_char_t *code_point) /**< [out] code point */\n{\n  JERRY_ASSERT (buf_p);\n\n  lit_utf8_decr (&buf_p);\n  return lit_read_code_unit_from_utf8 (buf_p, code_point);\n}",
        "begin_line": 468,
        "end_line": 476,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_utf8_decr#557",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_utf8_decr (const lit_utf8_byte_t **buf_p) /**< [in, out] buffer with characters */",
        "snippet": "void\nlit_utf8_decr (const lit_utf8_byte_t **buf_p) /**< [in,out] buffer with characters */\n{\n  JERRY_ASSERT (*buf_p);\n  const lit_utf8_byte_t *current_p = *buf_p;\n\n  do\n  {\n    current_p--;\n  }\n  while ((*(current_p) & LIT_UTF8_EXTRA_BYTE_MASK) == LIT_UTF8_EXTRA_BYTE_MARKER);\n\n  *buf_p = current_p;\n}",
        "begin_line": 557,
        "end_line": 570,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_utf8_string_calc_hash#605",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_utf8_string_calc_hash (const lit_utf8_byte_t *utf8_buf_p, /**< characters buffer */                            lit_utf8_size_t utf8_buf_size) /**< number of characters in the buffer */",
        "snippet": "inline lit_string_hash_t JERRY_ATTR_ALWAYS_INLINE\nlit_utf8_string_calc_hash (const lit_utf8_byte_t *utf8_buf_p, /**< characters buffer */\n                           lit_utf8_size_t utf8_buf_size) /**< number of characters in the buffer */\n{\n  JERRY_ASSERT (utf8_buf_p != NULL || utf8_buf_size == 0);\n\n  /* 32 bit offset_basis for FNV = 2166136261 */\n  return lit_utf8_string_hash_combine ((lit_string_hash_t) 2166136261, utf8_buf_p, utf8_buf_size);\n}",
        "begin_line": 605,
        "end_line": 613,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_utf8_string_hash_combine#582",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_utf8_string_hash_combine (lit_string_hash_t hash_basis, /**< hash to be combined with */                               const lit_utf8_byte_t *utf8_buf_p, /**< characters buffer */                               lit_utf8_size_t utf8_buf_size) /**< number of characters in the buffer */",
        "snippet": "inline lit_string_hash_t JERRY_ATTR_ALWAYS_INLINE\nlit_utf8_string_hash_combine (lit_string_hash_t hash_basis, /**< hash to be combined with */\n                              const lit_utf8_byte_t *utf8_buf_p, /**< characters buffer */\n                              lit_utf8_size_t utf8_buf_size) /**< number of characters in the buffer */\n{\n  JERRY_ASSERT (utf8_buf_p != NULL || utf8_buf_size == 0);\n\n  uint32_t hash = hash_basis;\n\n  for (uint32_t i = 0; i < utf8_buf_size; i++)\n  {\n    /* 16777619 is 32 bit FNV_prime = 2^24 + 2^8 + 0x93 = 16777619 */\n    hash = (hash ^ utf8_buf_p[i]) * 16777619;\n  }\n\n  return (lit_string_hash_t) hash;\n}",
        "begin_line": 582,
        "end_line": 598,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_utf8_string_length#290",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_utf8_string_length (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */                         lit_utf8_size_t utf8_buf_size) /**< string size */",
        "snippet": "ecma_length_t\nlit_utf8_string_length (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */\n                        lit_utf8_size_t utf8_buf_size) /**< string size */\n{\n  ecma_length_t length = 0;\n  lit_utf8_size_t size = 0;\n\n  while (size < utf8_buf_size)\n  {\n    size += lit_get_unicode_char_size_by_utf8_first_byte (*(utf8_buf_p + size));\n    length++;\n  }\n\n  JERRY_ASSERT (size == utf8_buf_size);\n\n  return length;\n}",
        "begin_line": 290,
        "end_line": 306,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_zt_utf8_string_size#278",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_zt_utf8_string_size (const lit_utf8_byte_t *utf8_str_p) /**< zero-terminated utf-8 string */",
        "snippet": "lit_utf8_size_t\nlit_zt_utf8_string_size (const lit_utf8_byte_t *utf8_str_p) /**< zero-terminated utf-8 string */\n{\n  JERRY_ASSERT (utf8_str_p != NULL);\n  return (lit_utf8_size_t) strlen ((const char *) utf8_str_p);\n}",
        "begin_line": 278,
        "end_line": 283,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_check_next_character#1787",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_check_next_character (parser_context_t *context_p, /**< context */                             lit_utf8_byte_t character) /**< specified character */",
        "snippet": "bool\nlexer_check_next_character (parser_context_t *context_p, /**< context */\n                            lit_utf8_byte_t character) /**< specified character */\n{\n  if (!(context_p->token.flags & LEXER_NO_SKIP_SPACES))\n  {\n    lexer_skip_spaces (context_p);\n    context_p->token.flags = (uint8_t) (context_p->token.flags | LEXER_NO_SKIP_SPACES);\n  }\n\n  return (context_p->source_p < context_p->source_end_p\n          && context_p->source_p[0] == (uint8_t) character);\n}",
        "begin_line": 1787,
        "end_line": 1799,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_check_next_characters#1807",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_check_next_characters (parser_context_t *context_p, /**< context */                              lit_utf8_byte_t character1, /**< first alternative character */                              lit_utf8_byte_t character2) /**< second alternative character */",
        "snippet": "bool\nlexer_check_next_characters (parser_context_t *context_p, /**< context */\n                             lit_utf8_byte_t character1, /**< first alternative character */\n                             lit_utf8_byte_t character2) /**< second alternative character */\n{\n  if (!(context_p->token.flags & LEXER_NO_SKIP_SPACES))\n  {\n    lexer_skip_spaces (context_p);\n    context_p->token.flags = (uint8_t) (context_p->token.flags | LEXER_NO_SKIP_SPACES);\n  }\n\n  return (context_p->source_p < context_p->source_end_p\n          && (context_p->source_p[0] == (uint8_t) character1\n              || context_p->source_p[0] == (uint8_t) character2));\n}",
        "begin_line": 1807,
        "end_line": 1821,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_check_property_modifier#3137",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_check_property_modifier (parser_context_t *context_p) /**< context */",
        "snippet": "void\nlexer_check_property_modifier (parser_context_t *context_p) /**< context */\n{\n  JERRY_ASSERT (!(context_p->token.flags & LEXER_NO_SKIP_SPACES));\n  JERRY_ASSERT (context_p->token.type = LEXER_LITERAL\n                && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);\n\n  lexer_skip_spaces (context_p);\n  context_p->token.flags = (uint8_t) (context_p->token.flags | LEXER_NO_SKIP_SPACES);\n\n  if (context_p->source_p >= context_p->source_end_p\n#if ENABLED (JERRY_ES2015)\n      || context_p->source_p[0] == LIT_CHAR_COMMA\n      || context_p->source_p[0] == LIT_CHAR_RIGHT_BRACE\n      || context_p->source_p[0] == LIT_CHAR_LEFT_PAREN\n      || context_p->source_p[0] == LIT_CHAR_EQUALS\n#endif /* ENABLED (JERRY_ES2015) */\n      || context_p->source_p[0] == LIT_CHAR_COLON)\n  {\n    return;\n  }\n\n  if (lexer_compare_literal_to_string (context_p, \"get\", 3))\n  {\n    context_p->token.type = LEXER_PROPERTY_GETTER;\n    return;\n  }\n\n  if (lexer_compare_literal_to_string (context_p, \"set\", 3))\n  {\n    context_p->token.type = LEXER_PROPERTY_SETTER;\n    return;\n  }\n\n#if ENABLED (JERRY_ES2015)\n  if (lexer_compare_literal_to_string (context_p, \"async\", 5))\n  {\n    context_p->token.type = LEXER_KEYW_ASYNC;\n    return;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n}",
        "begin_line": 3137,
        "end_line": 3178,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_compare_identifier_to_string#3250",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_compare_identifier_to_string (const lexer_lit_location_t *left_p, /**< left literal */                                     const uint8_t *right_p, /**< right identifier string */                                     size_t size) /**< byte size of the right identifier */",
        "snippet": "bool\nlexer_compare_identifier_to_string (const lexer_lit_location_t *left_p, /**< left literal */\n                                    const uint8_t *right_p, /**< right identifier string */\n                                    size_t size) /**< byte size of the right identifier */\n{\n  if (left_p->length != size)\n  {\n    return false;\n  }\n\n  if (!left_p->has_escape)\n  {\n    return memcmp (left_p->char_p, right_p, size) == 0;\n  }\n\n  return lexer_compare_identifier_to_chars (left_p->char_p, right_p, size);\n}",
        "begin_line": 3250,
        "end_line": 3266,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_construct_literal_object#2335",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_construct_literal_object (parser_context_t *context_p, /**< context */                                 const lexer_lit_location_t *lit_location_p, /**< literal location */                                 uint8_t literal_type) /**< final literal type */",
        "snippet": "void\nlexer_construct_literal_object (parser_context_t *context_p, /**< context */\n                                const lexer_lit_location_t *lit_location_p, /**< literal location */\n                                uint8_t literal_type) /**< final literal type */\n{\n  uint8_t local_byte_array[LEXER_MAX_LITERAL_LOCAL_BUFFER_SIZE];\n\n  const uint8_t *char_p = lexer_convert_literal_to_chars (context_p,\n                                                          lit_location_p,\n                                                          local_byte_array,\n                                                          LEXER_STRING_NO_OPTS);\n\n  size_t length = lit_location_p->length;\n  parser_list_iterator_t literal_iterator;\n  lexer_literal_t *literal_p;\n  uint32_t literal_index = 0;\n  bool search_scope_stack = (literal_type == LEXER_IDENT_LITERAL);\n\n  if (JERRY_UNLIKELY (literal_type == LEXER_NEW_IDENT_LITERAL))\n  {\n    literal_type = LEXER_IDENT_LITERAL;\n  }\n\n  JERRY_ASSERT (literal_type == LEXER_IDENT_LITERAL\n                || literal_type == LEXER_STRING_LITERAL);\n\n  JERRY_ASSERT (literal_type != LEXER_IDENT_LITERAL || length <= PARSER_MAXIMUM_IDENT_LENGTH);\n  JERRY_ASSERT (literal_type != LEXER_STRING_LITERAL || length <= PARSER_MAXIMUM_STRING_LENGTH);\n\n  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n\n  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n    if (literal_p->type == literal_type\n        && literal_p->prop.length == length\n        && memcmp (literal_p->u.char_p, char_p, length) == 0)\n    {\n      context_p->lit_object.literal_p = literal_p;\n      context_p->lit_object.index = (uint16_t) literal_index;\n\n      parser_free_allocated_buffer (context_p);\n\n      if (search_scope_stack)\n      {\n        parser_scope_stack_t *scope_stack_start_p = context_p->scope_stack_p;\n        parser_scope_stack_t *scope_stack_p = scope_stack_start_p + context_p->scope_stack_top;\n\n        while (scope_stack_p > scope_stack_start_p)\n        {\n          scope_stack_p--;\n\n          if (scope_stack_p->map_from == literal_index)\n          {\n            JERRY_ASSERT (scanner_decode_map_to (scope_stack_p) >= PARSER_REGISTER_START\n                          || (literal_p->status_flags & LEXER_FLAG_USED));\n            context_p->lit_object.index = scanner_decode_map_to (scope_stack_p);\n            return;\n          }\n        }\n\n        literal_p->status_flags |= LEXER_FLAG_USED;\n      }\n      return;\n    }\n\n    literal_index++;\n  }\n\n  JERRY_ASSERT (literal_index == context_p->literal_count);\n\n  if (literal_index >= PARSER_MAXIMUM_NUMBER_OF_LITERALS)\n  {\n    parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);\n  }\n\n  literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);\n  literal_p->prop.length = (prop_length_t) length;\n  literal_p->type = literal_type;\n\n  uint8_t status_flags = LEXER_FLAG_SOURCE_PTR;\n\n  if (length > 0 && char_p == local_byte_array)\n  {\n    literal_p->u.char_p = (uint8_t *) jmem_heap_alloc_block (length);\n    memcpy ((uint8_t *) literal_p->u.char_p, char_p, length);\n    status_flags = 0;\n  }\n  else\n  {\n    literal_p->u.char_p = char_p;\n\n    /* Buffer is taken over when a new literal is constructed. */\n    if (context_p->u.allocated_buffer_p != NULL)\n    {\n      JERRY_ASSERT (char_p == context_p->u.allocated_buffer_p);\n\n      context_p->u.allocated_buffer_p = NULL;\n      status_flags = 0;\n    }\n  }\n\n  if (search_scope_stack)\n  {\n    status_flags |= LEXER_FLAG_USED;\n  }\n\n  literal_p->status_flags = status_flags;\n\n  context_p->lit_object.literal_p = literal_p;\n  context_p->lit_object.index = (uint16_t) literal_index;\n  context_p->literal_count++;\n\n  JERRY_ASSERT (context_p->u.allocated_buffer_p == NULL);\n}",
        "begin_line": 2335,
        "end_line": 2448,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_construct_number_object#2455",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_construct_number_object (parser_context_t *context_p, /**< context */                                bool is_expr, /**< expression is parsed */                                bool is_negative_number) /**< sign is negative */",
        "snippet": "bool\nlexer_construct_number_object (parser_context_t *context_p, /**< context */\n                               bool is_expr, /**< expression is parsed */\n                               bool is_negative_number) /**< sign is negative */\n{\n  parser_list_iterator_t literal_iterator;\n  lexer_literal_t *literal_p;\n  ecma_number_t num;\n  uint32_t literal_index = 0;\n  prop_length_t length = context_p->token.lit_location.length;\n\n  if (context_p->token.extra_value < LEXER_NUMBER_OCTAL)\n  {\n    num = ecma_utf8_string_to_number (context_p->token.lit_location.char_p,\n                                      length);\n  }\n  else\n  {\n    const uint8_t *src_p = context_p->token.lit_location.char_p;\n    const uint8_t *src_end_p = src_p + length - 1;\n    ecma_number_t multiplier = 8.0;\n\n#if ENABLED (JERRY_ES2015)\n    if (context_p->token.extra_value == LEXER_NUMBER_BINARY)\n    {\n      multiplier = 2.0;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    num = 0;\n    do\n    {\n      src_p++;\n      num = num * multiplier + (ecma_number_t) (*src_p - LIT_CHAR_0);\n    }\n    while (src_p < src_end_p);\n  }\n\n  if (is_expr)\n  {\n    int32_t int_num = (int32_t) num;\n\n    if (int_num == num\n        && int_num <= CBC_PUSH_NUMBER_BYTE_RANGE_END\n        && (int_num != 0 || !is_negative_number))\n    {\n      context_p->lit_object.index = (uint16_t) int_num;\n      return true;\n    }\n  }\n\n  if (is_negative_number)\n  {\n    num = -num;\n  }\n\n  ecma_value_t lit_value = ecma_find_or_create_literal_number (num);\n  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n\n  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n    if (literal_p->type == LEXER_NUMBER_LITERAL\n        && literal_p->u.value == lit_value)\n    {\n      context_p->lit_object.literal_p = literal_p;\n      context_p->lit_object.index = (uint16_t) literal_index;\n      return false;\n    }\n\n    literal_index++;\n  }\n\n  JERRY_ASSERT (literal_index == context_p->literal_count);\n\n  if (literal_index >= PARSER_MAXIMUM_NUMBER_OF_LITERALS)\n  {\n    parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);\n  }\n\n  literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);\n  literal_p->u.value = lit_value;\n  literal_p->prop.length = 0; /* Unused. */\n  literal_p->type = LEXER_NUMBER_LITERAL;\n  literal_p->status_flags = 0;\n\n  context_p->lit_object.literal_p = literal_p;\n  context_p->lit_object.index = (uint16_t) literal_index;\n\n  context_p->literal_count++;\n  return false;\n}",
        "begin_line": 2455,
        "end_line": 2545,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_convert_literal_to_chars#2093",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_convert_literal_to_chars (parser_context_t *context_p, /**< context */                                 const lexer_lit_location_t *literal_p, /**< literal location */                                 uint8_t *local_byte_array_p, /**< local byte array to store chars */                                 lexer_string_options_t opts) /**< options */",
        "snippet": "const uint8_t *\nlexer_convert_literal_to_chars (parser_context_t *context_p, /**< context */\n                                const lexer_lit_location_t *literal_p, /**< literal location */\n                                uint8_t *local_byte_array_p, /**< local byte array to store chars */\n                                lexer_string_options_t opts) /**< options */\n{\n  JERRY_ASSERT (context_p->u.allocated_buffer_p == NULL);\n\n  if (!literal_p->has_escape)\n  {\n    return literal_p->char_p;\n  }\n\n  uint8_t *destination_start_p;\n  if (literal_p->length > LEXER_MAX_LITERAL_LOCAL_BUFFER_SIZE)\n  {\n    context_p->u.allocated_buffer_p = (uint8_t *) parser_malloc_local (context_p, literal_p->length);\n    context_p->allocated_buffer_size = literal_p->length;\n    destination_start_p = context_p->u.allocated_buffer_p;\n  }\n  else\n  {\n    destination_start_p = local_byte_array_p;\n  }\n\n  if (literal_p->type == LEXER_IDENT_LITERAL)\n  {\n    lexer_convert_ident_to_cesu8 (destination_start_p, literal_p->char_p, literal_p->length);\n    return destination_start_p;\n  }\n\n  const uint8_t *source_p = literal_p->char_p;\n  uint8_t *destination_p = destination_start_p;\n\n  uint8_t str_end_character = source_p[-1];\n\n#if ENABLED (JERRY_ES2015)\n  if (str_end_character == LIT_CHAR_RIGHT_BRACE)\n  {\n    str_end_character = LIT_CHAR_GRAVE_ACCENT;\n  }\n\n  bool is_raw = (opts & LEXER_STRING_RAW) != 0;\n#else /* !ENABLED (JERRY_ES2015) */\n  JERRY_UNUSED (opts);\n  bool is_raw = false;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  while (true)\n  {\n    if (*source_p == str_end_character)\n    {\n      break;\n    }\n\n    if (*source_p == LIT_CHAR_BACKSLASH && !is_raw)\n    {\n      uint8_t conv_character;\n\n      source_p++;\n      JERRY_ASSERT (source_p < context_p->source_end_p);\n\n      /* Newline is ignored. */\n      if (*source_p == LIT_CHAR_CR)\n      {\n        source_p++;\n        JERRY_ASSERT (source_p < context_p->source_end_p);\n\n        if (*source_p == LIT_CHAR_LF)\n        {\n          source_p++;\n        }\n        continue;\n      }\n      else if (*source_p == LIT_CHAR_LF)\n      {\n        source_p++;\n        continue;\n      }\n      else if (*source_p == LEXER_NEWLINE_LS_PS_BYTE_1 && LEXER_NEWLINE_LS_PS_BYTE_23 (source_p))\n      {\n        source_p += 3;\n        continue;\n      }\n\n      if (*source_p >= LIT_CHAR_0 && *source_p <= LIT_CHAR_3)\n      {\n        lit_code_point_t octal_number = (uint32_t) (*source_p - LIT_CHAR_0);\n\n        source_p++;\n        JERRY_ASSERT (source_p < context_p->source_end_p);\n\n        if (*source_p >= LIT_CHAR_0 && *source_p <= LIT_CHAR_7)\n        {\n          octal_number = octal_number * 8 + (uint32_t) (*source_p - LIT_CHAR_0);\n          source_p++;\n          JERRY_ASSERT (source_p < context_p->source_end_p);\n\n          if (*source_p >= LIT_CHAR_0 && *source_p <= LIT_CHAR_7)\n          {\n            octal_number = octal_number * 8 + (uint32_t) (*source_p - LIT_CHAR_0);\n            source_p++;\n            JERRY_ASSERT (source_p < context_p->source_end_p);\n          }\n        }\n\n        destination_p += lit_code_point_to_cesu8_bytes (destination_p, octal_number);\n        continue;\n      }\n\n      if (*source_p >= LIT_CHAR_4 && *source_p <= LIT_CHAR_7)\n      {\n        uint32_t octal_number = (uint32_t) (*source_p - LIT_CHAR_0);\n\n        source_p++;\n        JERRY_ASSERT (source_p < context_p->source_end_p);\n\n        if (*source_p >= LIT_CHAR_0 && *source_p <= LIT_CHAR_7)\n        {\n          octal_number = octal_number * 8 + (uint32_t) (*source_p - LIT_CHAR_0);\n          source_p++;\n          JERRY_ASSERT (source_p < context_p->source_end_p);\n        }\n\n        *destination_p++ = (uint8_t) octal_number;\n        continue;\n      }\n\n      if (*source_p == LIT_CHAR_LOWERCASE_X || *source_p == LIT_CHAR_LOWERCASE_U)\n      {\n        source_p++;\n        destination_p += lit_code_point_to_cesu8_bytes (destination_p,\n                                                        lexer_unchecked_hex_to_character (&source_p));\n        continue;\n      }\n\n      conv_character = *source_p;\n      switch (*source_p)\n      {\n        case LIT_CHAR_LOWERCASE_B:\n        {\n          conv_character = 0x08;\n          break;\n        }\n        case LIT_CHAR_LOWERCASE_T:\n        {\n          conv_character = 0x09;\n          break;\n        }\n        case LIT_CHAR_LOWERCASE_N:\n        {\n          conv_character = 0x0a;\n          break;\n        }\n        case LIT_CHAR_LOWERCASE_V:\n        {\n          conv_character = 0x0b;\n          break;\n        }\n        case LIT_CHAR_LOWERCASE_F:\n        {\n          conv_character = 0x0c;\n          break;\n        }\n        case LIT_CHAR_LOWERCASE_R:\n        {\n          conv_character = 0x0d;\n          break;\n        }\n      }\n\n      if (conv_character != *source_p)\n      {\n        *destination_p++ = conv_character;\n        source_p++;\n        continue;\n      }\n    }\n#if ENABLED (JERRY_ES2015)\n    else if (str_end_character == LIT_CHAR_GRAVE_ACCENT)\n    {\n      if (source_p[0] == LIT_CHAR_DOLLAR_SIGN\n          && source_p[1] == LIT_CHAR_LEFT_BRACE)\n      {\n        source_p++;\n        JERRY_ASSERT (source_p < context_p->source_end_p);\n        break;\n      }\n      if (*source_p == LIT_CHAR_CR)\n      {\n        *destination_p++ = LIT_CHAR_LF;\n        source_p++;\n        if (*source_p != str_end_character\n            && *source_p == LIT_CHAR_LF)\n        {\n          source_p++;\n        }\n        continue;\n      }\n      if ((*source_p == LIT_CHAR_BACKSLASH) && is_raw)\n      {\n        JERRY_ASSERT (source_p + 1 < context_p->source_end_p);\n        if ((*(source_p + 1) == LIT_CHAR_GRAVE_ACCENT) || (*(source_p + 1) == LIT_CHAR_BACKSLASH))\n        {\n          *destination_p++ = *source_p++;\n          *destination_p++ = *source_p++;\n          continue;\n        }\n      }\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    if (*source_p >= LIT_UTF8_4_BYTE_MARKER)\n    {\n      /* Processing 4 byte unicode sequence (even if it is\n        * after a backslash). Always converted to two 3 byte\n        * long sequence. */\n      lit_four_byte_utf8_char_to_cesu8 (destination_p, source_p);\n\n      destination_p += 6;\n      source_p += 4;\n      continue;\n    }\n\n    *destination_p++ = *source_p++;\n\n    /* There is no need to check the source_end_p\n      * since the string is terminated by a quotation mark. */\n    while (IS_UTF8_INTERMEDIATE_OCTET (*source_p))\n    {\n      *destination_p++ = *source_p++;\n    }\n  }\n\n  JERRY_ASSERT (destination_p == destination_start_p + literal_p->length);\n\n  return destination_start_p;\n}",
        "begin_line": 2093,
        "end_line": 2330,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_convert_push_number_to_push_literal#2550",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_convert_push_number_to_push_literal (parser_context_t *context_p) /**< context */",
        "snippet": "void\nlexer_convert_push_number_to_push_literal (parser_context_t *context_p) /**< context */\n{\n  ecma_integer_value_t value;\n  bool two_literals = !PARSER_IS_BASIC_OPCODE (context_p->last_cbc_opcode);\n\n  if (context_p->last_cbc_opcode == CBC_PUSH_NUMBER_0\n      || context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_LITERAL_PUSH_NUMBER_0))\n  {\n    value = 0;\n  }\n  else if (context_p->last_cbc_opcode == CBC_PUSH_NUMBER_POS_BYTE\n           || context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE))\n  {\n    value = ((ecma_integer_value_t) context_p->last_cbc.value) + 1;\n  }\n  else\n  {\n    JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_NUMBER_NEG_BYTE\n                  || context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_LITERAL_PUSH_NUMBER_NEG_BYTE));\n    value = -((ecma_integer_value_t) context_p->last_cbc.value) - 1;\n  }\n\n  ecma_value_t lit_value = ecma_make_integer_value (value);\n\n  parser_list_iterator_t literal_iterator;\n  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n\n  context_p->last_cbc_opcode = two_literals ? CBC_PUSH_TWO_LITERALS : CBC_PUSH_LITERAL;\n\n  uint32_t literal_index = 0;\n  lexer_literal_t *literal_p;\n\n  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n    if (literal_p->type == LEXER_NUMBER_LITERAL\n        && literal_p->u.value == lit_value)\n    {\n      if (two_literals)\n      {\n        context_p->last_cbc.value = (uint16_t) literal_index;\n      }\n      else\n      {\n        context_p->last_cbc.literal_index = (uint16_t) literal_index;\n      }\n      return;\n    }\n\n    literal_index++;\n  }\n\n  JERRY_ASSERT (literal_index == context_p->literal_count);\n\n  if (literal_index >= PARSER_MAXIMUM_NUMBER_OF_LITERALS)\n  {\n    parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);\n  }\n\n  literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);\n  literal_p->u.value = lit_value;\n  literal_p->prop.length = 0; /* Unused. */\n  literal_p->type = LEXER_NUMBER_LITERAL;\n  literal_p->status_flags = 0;\n\n  context_p->literal_count++;\n\n  if (two_literals)\n  {\n    context_p->last_cbc.value = (uint16_t) literal_index;\n  }\n  else\n  {\n    context_p->last_cbc.literal_index = (uint16_t) literal_index;\n  }\n}",
        "begin_line": 2550,
        "end_line": 2625,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_expect_identifier#2888",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_expect_identifier (parser_context_t *context_p, /**< context */                          uint8_t literal_type) /**< literal type */",
        "snippet": "void\nlexer_expect_identifier (parser_context_t *context_p, /**< context */\n                         uint8_t literal_type) /**< literal type */\n{\n  JERRY_ASSERT (literal_type == LEXER_STRING_LITERAL\n                || literal_type == LEXER_IDENT_LITERAL\n                || literal_type == LEXER_NEW_IDENT_LITERAL);\n\n  lexer_skip_spaces (context_p);\n  context_p->token.line = context_p->line;\n  context_p->token.column = context_p->column;\n\n  if (context_p->source_p < context_p->source_end_p\n      && lexer_parse_identifier (context_p, (literal_type != LEXER_STRING_LITERAL ? LEXER_PARSE_CHECK_KEYWORDS\n                                                                                  : LEXER_PARSE_NO_OPTS)))\n  {\n    if (context_p->token.type == LEXER_LITERAL)\n    {\n      JERRY_ASSERT (context_p->token.lit_location.type == LEXER_IDENT_LITERAL);\n\n      lexer_construct_literal_object (context_p,\n                                      &context_p->token.lit_location,\n                                      literal_type);\n\n      if (literal_type != LEXER_STRING_LITERAL\n          && (context_p->status_flags & PARSER_IS_STRICT))\n      {\n        if (context_p->token.keyword_type == LEXER_KEYW_EVAL)\n        {\n          parser_raise_error (context_p, PARSER_ERR_EVAL_NOT_ALLOWED);\n        }\n        else if (context_p->token.keyword_type == LEXER_KEYW_ARGUMENTS)\n        {\n          parser_raise_error (context_p, PARSER_ERR_ARGUMENTS_NOT_ALLOWED);\n        }\n      }\n      return;\n    }\n  }\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n  else if (context_p->status_flags & PARSER_MODULE_DEFAULT_CLASS_OR_FUNC)\n  {\n    /* When parsing default exports for modules, it is not required by functions or classes to have identifiers.\n     * In this case we use a synthetic name for them. */\n    context_p->token.type = LEXER_LITERAL;\n    context_p->token.keyword_type = LEXER_EOS;\n    context_p->token.lit_location = lexer_default_literal;\n    lexer_construct_literal_object (context_p, &context_p->token.lit_location, literal_type);\n    context_p->status_flags &= (uint32_t) ~(PARSER_MODULE_DEFAULT_CLASS_OR_FUNC);\n    return;\n  }\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n#if ENABLED (JERRY_ES2015)\n  if (context_p->token.type == LEXER_KEYW_YIELD)\n  {\n    parser_raise_error (context_p, PARSER_ERR_YIELD_NOT_ALLOWED);\n  }\n  if (context_p->token.type == LEXER_KEYW_AWAIT)\n  {\n    parser_raise_error (context_p, PARSER_ERR_AWAIT_NOT_ALLOWED);\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n  parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);\n}",
        "begin_line": 2888,
        "end_line": 2952,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_expect_object_literal_id#2957",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_expect_object_literal_id (parser_context_t *context_p, /**< context */                                 uint32_t ident_opts) /**< lexer_obj_ident_opts_t option bits */",
        "snippet": "void\nlexer_expect_object_literal_id (parser_context_t *context_p, /**< context */\n                                uint32_t ident_opts) /**< lexer_obj_ident_opts_t option bits */\n{\n  lexer_skip_spaces (context_p);\n\n  if (context_p->source_p >= context_p->source_end_p)\n  {\n    parser_raise_error (context_p, PARSER_ERR_PROPERTY_IDENTIFIER_EXPECTED);\n  }\n\n#if ENABLED (JERRY_ES2015)\n  int is_class_method = ((ident_opts & LEXER_OBJ_IDENT_CLASS_METHOD)\n                         && !(ident_opts & LEXER_OBJ_IDENT_ONLY_IDENTIFIERS)\n                         && (context_p->token.type != LEXER_KEYW_STATIC));\n#endif /* ENABLED (JERRY_ES2015) */\n\n  context_p->token.line = context_p->line;\n  context_p->token.column = context_p->column;\n  bool create_literal_object = false;\n\n  if (lexer_parse_identifier (context_p, LEXER_PARSE_NO_OPTS))\n  {\n    if (!(ident_opts & (LEXER_OBJ_IDENT_ONLY_IDENTIFIERS | LEXER_OBJ_IDENT_OBJECT_PATTERN)))\n    {\n      lexer_skip_spaces (context_p);\n      context_p->token.flags = (uint8_t) (context_p->token.flags | LEXER_NO_SKIP_SPACES);\n\n      if (context_p->source_p < context_p->source_end_p\n#if ENABLED (JERRY_ES2015)\n          && context_p->source_p[0] != LIT_CHAR_COMMA\n          && context_p->source_p[0] != LIT_CHAR_RIGHT_BRACE\n          && context_p->source_p[0] != LIT_CHAR_LEFT_PAREN\n#endif /* ENABLED (JERRY_ES2015) */\n          && context_p->source_p[0] != LIT_CHAR_COLON)\n      {\n        if (lexer_compare_literal_to_string (context_p, \"get\", 3))\n        {\n          context_p->token.type = LEXER_PROPERTY_GETTER;\n          return;\n        }\n\n        if (lexer_compare_literal_to_string (context_p, \"set\", 3))\n        {\n          context_p->token.type = LEXER_PROPERTY_SETTER;\n          return;\n        }\n\n#if ENABLED (JERRY_ES2015)\n        if (lexer_compare_literal_to_string (context_p, \"async\", 5))\n        {\n          context_p->token.type = LEXER_KEYW_ASYNC;\n          return;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n      }\n    }\n\n#if ENABLED (JERRY_ES2015)\n    if (is_class_method && lexer_compare_literal_to_string (context_p, \"static\", 6))\n    {\n      context_p->token.type = LEXER_KEYW_STATIC;\n      return;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    create_literal_object = true;\n  }\n  else\n  {\n    switch (context_p->source_p[0])\n    {\n      case LIT_CHAR_DOUBLE_QUOTE:\n      case LIT_CHAR_SINGLE_QUOTE:\n      {\n        lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);\n        create_literal_object = true;\n        break;\n      }\n#if ENABLED (JERRY_ES2015)\n      case LIT_CHAR_LEFT_SQUARE:\n      {\n        lexer_consume_next_character (context_p);\n\n        lexer_next_token (context_p);\n        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);\n\n        if (context_p->token.type != LEXER_RIGHT_SQUARE)\n        {\n          parser_raise_error (context_p, PARSER_ERR_RIGHT_SQUARE_EXPECTED);\n        }\n        return;\n      }\n      case LIT_CHAR_ASTERISK:\n#endif /* ENABLED (JERRY_ES2015) */\n      case LIT_CHAR_RIGHT_BRACE:\n      {\n        if (ident_opts & LEXER_OBJ_IDENT_ONLY_IDENTIFIERS)\n        {\n          break;\n        }\n\n        context_p->token.type = LEXER_RIGHT_BRACE;\n#if ENABLED (JERRY_ES2015)\n        if (context_p->source_p[0] == LIT_CHAR_ASTERISK)\n        {\n          context_p->token.type = LEXER_MULTIPLY;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        lexer_consume_next_character (context_p);\n        return;\n      }\n      default:\n      {\n        const uint8_t *char_p = context_p->source_p;\n\n        if (char_p[0] == LIT_CHAR_DOT)\n        {\n          char_p++;\n        }\n\n        if (char_p < context_p->source_end_p\n            && char_p[0] >= LIT_CHAR_0\n            && char_p[0] <= LIT_CHAR_9)\n        {\n          lexer_parse_number (context_p);\n          lexer_construct_number_object (context_p, false, false);\n          return;\n        }\n        break;\n      }\n    }\n  }\n\n  if (create_literal_object)\n  {\n#if ENABLED (JERRY_ES2015)\n    if (is_class_method && lexer_compare_literal_to_string (context_p, \"constructor\", 11))\n    {\n      context_p->token.type = LEXER_CLASS_CONSTRUCTOR;\n      context_p->token.flags &= (uint8_t) ~LEXER_NO_SKIP_SPACES;\n      return;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    lexer_construct_literal_object (context_p,\n                                    &context_p->token.lit_location,\n                                    LEXER_STRING_LITERAL);\n    return;\n  }\n\n  parser_raise_error (context_p, PARSER_ERR_PROPERTY_IDENTIFIER_EXPECTED);\n}",
        "begin_line": 2957,
        "end_line": 3110,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_next_token#1504",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_next_token (parser_context_t *context_p) /**< context */",
        "snippet": "void\nlexer_next_token (parser_context_t *context_p) /**< context */\n{\n  size_t length;\n\n  lexer_skip_spaces (context_p);\n\n  context_p->token.line = context_p->line;\n  context_p->token.column = context_p->column;\n\n  length = (size_t) (context_p->source_end_p - context_p->source_p);\n  if (length == 0)\n  {\n    context_p->token.type = LEXER_EOS;\n    return;\n  }\n\n  if (lexer_parse_identifier (context_p, LEXER_PARSE_CHECK_KEYWORDS))\n  {\n    return;\n  }\n\n  if (context_p->source_p[0] >= LIT_CHAR_0 && context_p->source_p[0] <= LIT_CHAR_9)\n  {\n    lexer_parse_number (context_p);\n    return;\n  }\n\n  switch (context_p->source_p[0])\n  {\n    LEXER_TYPE_A_TOKEN (LIT_CHAR_LEFT_BRACE, LEXER_LEFT_BRACE);\n    LEXER_TYPE_A_TOKEN (LIT_CHAR_LEFT_PAREN, LEXER_LEFT_PAREN);\n    LEXER_TYPE_A_TOKEN (LIT_CHAR_LEFT_SQUARE, LEXER_LEFT_SQUARE);\n    LEXER_TYPE_A_TOKEN (LIT_CHAR_RIGHT_BRACE, LEXER_RIGHT_BRACE);\n    LEXER_TYPE_A_TOKEN (LIT_CHAR_RIGHT_PAREN, LEXER_RIGHT_PAREN);\n    LEXER_TYPE_A_TOKEN (LIT_CHAR_RIGHT_SQUARE, LEXER_RIGHT_SQUARE);\n    LEXER_TYPE_A_TOKEN (LIT_CHAR_SEMICOLON, LEXER_SEMICOLON);\n    LEXER_TYPE_A_TOKEN (LIT_CHAR_COMMA, LEXER_COMMA);\n\n    case (uint8_t) LIT_CHAR_DOT:\n    {\n      if (length >= 2\n          && (context_p->source_p[1] >= LIT_CHAR_0 && context_p->source_p[1] <= LIT_CHAR_9))\n      {\n        lexer_parse_number (context_p);\n        return;\n      }\n\n#if ENABLED (JERRY_ES2015)\n      if (length >= 3\n          && context_p->source_p[1] == LIT_CHAR_DOT\n          && context_p->source_p[2] == LIT_CHAR_DOT)\n      {\n        context_p->token.type = LEXER_THREE_DOTS;\n        length = 3;\n        break;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      context_p->token.type = LEXER_DOT;\n      length = 1;\n      break;\n    }\n\n    case (uint8_t) LIT_CHAR_LESS_THAN:\n    {\n      if (length >= 2)\n      {\n        if (context_p->source_p[1] == (uint8_t) LIT_CHAR_EQUALS)\n        {\n          context_p->token.type = LEXER_LESS_EQUAL;\n          length = 2;\n          break;\n        }\n\n        if (context_p->source_p[1] == (uint8_t) LIT_CHAR_LESS_THAN)\n        {\n          if (length >= 3 && context_p->source_p[2] == (uint8_t) LIT_CHAR_EQUALS)\n          {\n            context_p->token.type = LEXER_ASSIGN_LEFT_SHIFT;\n            length = 3;\n            break;\n          }\n\n          context_p->token.type = LEXER_LEFT_SHIFT;\n          length = 2;\n          break;\n        }\n      }\n\n      context_p->token.type = LEXER_LESS;\n      length = 1;\n      break;\n    }\n\n    case (uint8_t) LIT_CHAR_GREATER_THAN:\n    {\n      if (length >= 2)\n      {\n        if (context_p->source_p[1] == (uint8_t) LIT_CHAR_EQUALS)\n        {\n          context_p->token.type = LEXER_GREATER_EQUAL;\n          length = 2;\n          break;\n        }\n\n        if (context_p->source_p[1] == (uint8_t) LIT_CHAR_GREATER_THAN)\n        {\n          if (length >= 3)\n          {\n            if (context_p->source_p[2] == (uint8_t) LIT_CHAR_EQUALS)\n            {\n              context_p->token.type = LEXER_ASSIGN_RIGHT_SHIFT;\n              length = 3;\n              break;\n            }\n\n            if (context_p->source_p[2] == (uint8_t) LIT_CHAR_GREATER_THAN)\n            {\n              if (length >= 4 && context_p->source_p[3] == (uint8_t) LIT_CHAR_EQUALS)\n              {\n                context_p->token.type = LEXER_ASSIGN_UNS_RIGHT_SHIFT;\n                length = 4;\n                break;\n              }\n\n              context_p->token.type = LEXER_UNS_RIGHT_SHIFT;\n              length = 3;\n              break;\n            }\n          }\n\n          context_p->token.type = LEXER_RIGHT_SHIFT;\n          length = 2;\n          break;\n        }\n      }\n\n      context_p->token.type = LEXER_GREATER;\n      length = 1;\n      break;\n    }\n\n    case (uint8_t) LIT_CHAR_EQUALS:\n    {\n      if (length >= 2)\n      {\n        if (context_p->source_p[1] == (uint8_t) LIT_CHAR_EQUALS)\n        {\n          if (length >= 3 && context_p->source_p[2] == (uint8_t) LIT_CHAR_EQUALS)\n          {\n            context_p->token.type = LEXER_STRICT_EQUAL;\n            length = 3;\n            break;\n          }\n\n          context_p->token.type = LEXER_EQUAL;\n          length = 2;\n          break;\n        }\n\n#if ENABLED (JERRY_ES2015)\n        if (context_p->source_p[1] == (uint8_t) LIT_CHAR_GREATER_THAN)\n        {\n          context_p->token.type = LEXER_ARROW;\n          length = 2;\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n      }\n\n      context_p->token.type = LEXER_ASSIGN;\n      length = 1;\n      break;\n    }\n\n    case (uint8_t) LIT_CHAR_EXCLAMATION:\n    {\n      if (length >= 2 && context_p->source_p[1] == (uint8_t) LIT_CHAR_EQUALS)\n      {\n        if (length >= 3 && context_p->source_p[2] == (uint8_t) LIT_CHAR_EQUALS)\n        {\n          context_p->token.type = LEXER_STRICT_NOT_EQUAL;\n          length = 3;\n          break;\n        }\n\n        context_p->token.type = LEXER_NOT_EQUAL;\n        length = 2;\n        break;\n      }\n\n      context_p->token.type = LEXER_LOGICAL_NOT;\n      length = 1;\n      break;\n    }\n\n    LEXER_TYPE_C_TOKEN (LIT_CHAR_PLUS, LEXER_ADD, LIT_CHAR_EQUALS,\n                        LEXER_ASSIGN_ADD, LIT_CHAR_PLUS, LEXER_INCREASE)\n    LEXER_TYPE_C_TOKEN (LIT_CHAR_MINUS, LEXER_SUBTRACT, LIT_CHAR_EQUALS,\n                        LEXER_ASSIGN_SUBTRACT, LIT_CHAR_MINUS, LEXER_DECREASE)\n\n    case (uint8_t) LIT_CHAR_ASTERISK:\n    {\n      if (length >= 2)\n      {\n        if (context_p->source_p[1] == (uint8_t) LIT_CHAR_EQUALS)\n        {\n          context_p->token.type = LEXER_ASSIGN_MULTIPLY;\n          length = 2;\n          break;\n        }\n\n#if ENABLED (JERRY_ES2015)\n        if (context_p->source_p[1] == (uint8_t) LIT_CHAR_ASTERISK)\n        {\n          if (length >= 3 && context_p->source_p[2] == (uint8_t) LIT_CHAR_EQUALS)\n          {\n            context_p->token.type = LEXER_ASSIGN_EXPONENTIATION;\n            length = 3;\n            break;\n          }\n\n          context_p->token.type = LEXER_EXPONENTIATION;\n          length = 2;\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n      }\n\n      context_p->token.type = LEXER_MULTIPLY;\n      length = 1;\n      break;\n    }\n\n    LEXER_TYPE_B_TOKEN (LIT_CHAR_SLASH, LEXER_DIVIDE, LIT_CHAR_EQUALS,\n                        LEXER_ASSIGN_DIVIDE)\n    LEXER_TYPE_B_TOKEN (LIT_CHAR_PERCENT, LEXER_MODULO, LIT_CHAR_EQUALS,\n                        LEXER_ASSIGN_MODULO)\n\n    LEXER_TYPE_C_TOKEN (LIT_CHAR_AMPERSAND, LEXER_BIT_AND, LIT_CHAR_EQUALS,\n                        LEXER_ASSIGN_BIT_AND, LIT_CHAR_AMPERSAND, LEXER_LOGICAL_AND)\n    LEXER_TYPE_C_TOKEN (LIT_CHAR_VLINE, LEXER_BIT_OR, LIT_CHAR_EQUALS,\n                        LEXER_ASSIGN_BIT_OR, LIT_CHAR_VLINE, LEXER_LOGICAL_OR)\n\n    LEXER_TYPE_B_TOKEN (LIT_CHAR_CIRCUMFLEX, LEXER_BIT_XOR, LIT_CHAR_EQUALS,\n                        LEXER_ASSIGN_BIT_XOR)\n\n    LEXER_TYPE_A_TOKEN (LIT_CHAR_TILDE, LEXER_BIT_NOT);\n    LEXER_TYPE_A_TOKEN (LIT_CHAR_QUESTION, LEXER_QUESTION_MARK);\n    LEXER_TYPE_A_TOKEN (LIT_CHAR_COLON, LEXER_COLON);\n\n    case LIT_CHAR_SINGLE_QUOTE:\n    case LIT_CHAR_DOUBLE_QUOTE:\n#if ENABLED (JERRY_ES2015)\n    case LIT_CHAR_GRAVE_ACCENT:\n#endif /* ENABLED (JERRY_ES2015) */\n    {\n      lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);\n      return;\n    }\n\n    default:\n    {\n      parser_raise_error (context_p, PARSER_ERR_INVALID_CHARACTER);\n    }\n  }\n\n  context_p->source_p += length;\n  PARSER_PLUS_EQUAL_LC (context_p->column, length);\n}",
        "begin_line": 1504,
        "end_line": 1774,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_parse_identifier#617",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_parse_identifier (parser_context_t *context_p, /**< context */                         lexer_parse_options_t options) /**< check keywords */",
        "snippet": "static bool\nlexer_parse_identifier (parser_context_t *context_p, /**< context */\n                        lexer_parse_options_t options) /**< check keywords */\n{\n  /* Only very few identifiers contains \\u escape sequences. */\n  const uint8_t *source_p = context_p->source_p;\n  /* Note: newline or tab cannot be part of an identifier. */\n  parser_line_counter_t column = context_p->column;\n  const uint8_t *source_end_p = context_p->source_end_p;\n  size_t length = 0;\n  uint8_t has_escape = false;\n\n  do\n  {\n    if (*source_p == LIT_CHAR_BACKSLASH)\n    {\n      /* After a backslash an identifier must start. */\n      lit_code_point_t code_point = UINT32_MAX;\n      uint32_t escape_length = 6;\n\n      if (options & (LEXER_PARSE_CHECK_START_AND_RETURN | LEXER_PARSE_CHECK_PART_AND_RETURN))\n      {\n        return true;\n      }\n\n      has_escape = true;\n\n#if ENABLED (JERRY_ES2015)\n      if (source_p + 5 <= source_end_p && source_p[1] == LIT_CHAR_LOWERCASE_U)\n      {\n        if (source_p[2] == LIT_CHAR_LEFT_BRACE)\n        {\n          code_point = lexer_hex_in_braces_to_code_point (source_p + 3, source_end_p, &escape_length);\n        }\n        else if (source_p + 6 <= source_end_p)\n        {\n          code_point = lexer_hex_to_code_point (source_p + 2, 4);\n        }\n      }\n#else /* !ENABLED (JERRY_ES2015) */\n      if (source_p + 6 <= source_end_p && source_p[1] == LIT_CHAR_LOWERCASE_U)\n      {\n        code_point = lexer_hex_to_code_point (source_p + 2, 4);\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      if (code_point == UINT32_MAX)\n      {\n        context_p->source_p = source_p;\n        context_p->token.column = column;\n        parser_raise_error (context_p, PARSER_ERR_INVALID_UNICODE_ESCAPE_SEQUENCE);\n      }\n\n      if (length == 0)\n      {\n        if (!lit_code_point_is_identifier_start (code_point))\n        {\n          parser_raise_error (context_p, PARSER_ERR_INVALID_IDENTIFIER_START);\n        }\n      }\n      else\n      {\n        if (!lit_code_point_is_identifier_part (code_point))\n        {\n          parser_raise_error (context_p, PARSER_ERR_INVALID_IDENTIFIER_PART);\n        }\n      }\n\n      length += lit_code_point_get_cesu8_length (code_point);\n      source_p += escape_length;\n      PARSER_PLUS_EQUAL_LC (column, escape_length);\n      continue;\n    }\n\n    lit_code_point_t code_point = *source_p;\n    lit_utf8_size_t utf8_length = 1, decoded_length = 1, char_count = 1;\n\n    if (JERRY_UNLIKELY (code_point >= LIT_UTF8_2_BYTE_MARKER))\n    {\n#if ENABLED (JERRY_ES2015)\n      utf8_length = lit_read_code_point_from_utf8 (source_p,\n                                                   (lit_utf8_size_t) (source_end_p - source_p),\n                                                   &code_point);\n      decoded_length = utf8_length;\n\n      /* Only ES2015 supports code points outside of the basic plane which can be part of an identifier. */\n      if ((code_point >= LIT_UTF16_HIGH_SURROGATE_MIN && code_point <= LIT_UTF16_HIGH_SURROGATE_MAX)\n          && source_p + 3 < source_end_p)\n      {\n        lit_code_point_t low_surrogate;\n        lit_read_code_point_from_utf8 (source_p + 3,\n                                       (lit_utf8_size_t) (source_end_p - (source_p + 3)),\n                                       &low_surrogate);\n\n        if (low_surrogate >= LIT_UTF16_LOW_SURROGATE_MIN && low_surrogate <= LIT_UTF16_LOW_SURROGATE_MAX)\n        {\n          code_point = lit_convert_surrogate_pair_to_code_point ((ecma_char_t) code_point,\n                                                                 (ecma_char_t) low_surrogate);\n          utf8_length = 2 * 3;\n          decoded_length = 2 * 3;\n          char_count = 2;\n        }\n      }\n      else if (source_p[0] >= LIT_UTF8_4_BYTE_MARKER)\n      {\n        decoded_length = 2 * 3;\n        has_escape = true;\n      }\n#else /* !ENABLED (JERRY_ES2015) */\n      if (code_point < LIT_UTF8_4_BYTE_MARKER)\n      {\n        utf8_length = lit_read_code_point_from_utf8 (source_p,\n                                                     (lit_utf8_size_t) (source_end_p - source_p),\n                                                     &code_point);\n        decoded_length = utf8_length;\n      }\n      else\n      {\n        code_point = 0;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n    }\n\n    if (length == 0)\n    {\n      if (JERRY_UNLIKELY (options & (LEXER_PARSE_CHECK_START_AND_RETURN | LEXER_PARSE_CHECK_PART_AND_RETURN)))\n      {\n        if (options & LEXER_PARSE_CHECK_START_AND_RETURN)\n        {\n          return lit_code_point_is_identifier_start (code_point);\n        }\n        else\n        {\n          return lit_code_point_is_identifier_part (code_point);\n        }\n      }\n\n      if (!lit_code_point_is_identifier_start (code_point))\n      {\n        return false;\n      }\n    }\n    else if (!lit_code_point_is_identifier_part (code_point))\n    {\n      break;\n    }\n\n    source_p += utf8_length;\n    length += decoded_length;\n    PARSER_PLUS_EQUAL_LC (column, char_count);\n  }\n  while (source_p < source_end_p);\n\n  JERRY_ASSERT (length > 0);\n\n  context_p->token.type = LEXER_LITERAL;\n  context_p->token.keyword_type = LEXER_EOS;\n  context_p->token.lit_location.type = LEXER_IDENT_LITERAL;\n  context_p->token.lit_location.has_escape = has_escape;\n\n  context_p->token.column = context_p->column;\n  context_p->token.lit_location.char_p = context_p->source_p;\n  context_p->token.lit_location.length = (prop_length_t) length;\n\n  if (JERRY_UNLIKELY (length > PARSER_MAXIMUM_IDENT_LENGTH))\n  {\n    parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_TOO_LONG);\n  }\n\n  /* Check keywords. */\n  if ((options & LEXER_PARSE_CHECK_KEYWORDS)\n      && (length >= LEXER_KEYWORD_MIN_LENGTH && length <= LEXER_KEYWORD_MAX_LENGTH))\n  {\n    const uint8_t *ident_start_p = context_p->source_p;\n    uint8_t buffer_p[LEXER_KEYWORD_MAX_LENGTH];\n\n    if (JERRY_UNLIKELY (context_p->token.lit_location.has_escape))\n    {\n      lexer_convert_ident_to_cesu8 (buffer_p, ident_start_p, (prop_length_t) length);\n      ident_start_p = buffer_p;\n    }\n\n    const keyword_string_t *keyword_list_p = keyword_strings_list[length - LEXER_KEYWORD_MIN_LENGTH];\n\n    int start = 0;\n    int end = keyword_lengths_list[length - LEXER_KEYWORD_MIN_LENGTH];\n    int middle = end / 2;\n\n    do\n    {\n      const keyword_string_t *keyword_p = keyword_list_p + middle;\n      int compare_result = ident_start_p[0] - keyword_p->keyword_p[0];\n\n      if (compare_result == 0)\n      {\n        compare_result = memcmp (ident_start_p, keyword_p->keyword_p, length);\n\n        if (compare_result == 0)\n        {\n          context_p->token.keyword_type = (uint8_t) keyword_p->type;\n\n          if (JERRY_LIKELY (keyword_p->type < LEXER_FIRST_NON_RESERVED_KEYWORD))\n          {\n#if ENABLED (JERRY_ES2015)\n            if (JERRY_UNLIKELY (keyword_p->type == LEXER_KEYW_AWAIT))\n            {\n              if (!(context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)\n                  && !(context_p->global_status_flags & ECMA_PARSE_MODULE))\n              {\n                break;\n              }\n\n              if (context_p->status_flags & PARSER_DISALLOW_AWAIT_YIELD)\n              {\n                if (ident_start_p == buffer_p)\n                {\n                  parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);\n                }\n                parser_raise_error (context_p, PARSER_ERR_AWAIT_NOT_ALLOWED);\n              }\n\n              context_p->token.type = (uint8_t) LEXER_KEYW_AWAIT;\n              break;\n            }\n#endif /* ENABLED (JERRY_ES2015) */\n\n            if (ident_start_p == buffer_p)\n            {\n              /* Escape sequences are not allowed in a keyword. */\n              parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);\n            }\n\n            context_p->token.type = (uint8_t) keyword_p->type;\n            break;\n          }\n\n#if ENABLED (JERRY_ES2015)\n          if (keyword_p->type == LEXER_KEYW_LET && (context_p->status_flags & PARSER_IS_STRICT))\n          {\n            if (ident_start_p == buffer_p)\n            {\n              parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);\n            }\n\n            context_p->token.type = (uint8_t) LEXER_KEYW_LET;\n            break;\n          }\n\n          if (keyword_p->type == LEXER_KEYW_YIELD && (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION))\n          {\n            if (context_p->status_flags & PARSER_DISALLOW_AWAIT_YIELD)\n            {\n              if (ident_start_p == buffer_p)\n              {\n                parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);\n              }\n              parser_raise_error (context_p, PARSER_ERR_YIELD_NOT_ALLOWED);\n            }\n\n            context_p->token.type = (uint8_t) LEXER_KEYW_YIELD;\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n\n          if (keyword_p->type >= LEXER_FIRST_FUTURE_STRICT_RESERVED_WORD\n              && (context_p->status_flags & PARSER_IS_STRICT))\n          {\n            parser_raise_error (context_p, PARSER_ERR_STRICT_IDENT_NOT_ALLOWED);\n          }\n          break;\n        }\n      }\n\n      if (compare_result > 0)\n      {\n        start = middle + 1;\n      }\n      else\n      {\n        JERRY_ASSERT (compare_result < 0);\n        end = middle;\n      }\n\n      middle = (start + end) / 2;\n    }\n    while (start < end);\n  }\n\n  context_p->source_p = source_p;\n  context_p->column = column;\n  return true;\n}",
        "begin_line": 617,
        "end_line": 908,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_parse_number#1261",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_parse_number (parser_context_t *context_p) /**< context */",
        "snippet": "static void\nlexer_parse_number (parser_context_t *context_p) /**< context */\n{\n  const uint8_t *source_p = context_p->source_p;\n  const uint8_t *source_end_p = context_p->source_end_p;\n  bool can_be_float = false;\n  size_t length;\n\n  context_p->token.type = LEXER_LITERAL;\n  context_p->token.keyword_type = LEXER_EOS;\n  context_p->token.extra_value = LEXER_NUMBER_DECIMAL;\n  context_p->token.lit_location.char_p = source_p;\n  context_p->token.lit_location.type = LEXER_NUMBER_LITERAL;\n  context_p->token.lit_location.has_escape = false;\n\n  if (source_p[0] == LIT_CHAR_0\n      && source_p + 1 < source_end_p)\n  {\n    if (LEXER_TO_ASCII_LOWERCASE (source_p[1]) == LIT_CHAR_LOWERCASE_X)\n    {\n      context_p->token.extra_value = LEXER_NUMBER_HEXADECIMAL;\n      source_p += 2;\n\n      if (source_p >= source_end_p\n          || !lit_char_is_hex_digit (source_p[0]))\n      {\n        parser_raise_error (context_p, PARSER_ERR_INVALID_HEX_DIGIT);\n      }\n\n      do\n      {\n        source_p++;\n      }\n      while (source_p < source_end_p\n             && lit_char_is_hex_digit (source_p[0]));\n    }\n#if ENABLED (JERRY_ES2015)\n    else if (LEXER_TO_ASCII_LOWERCASE (source_p[1]) == LIT_CHAR_LOWERCASE_O)\n    {\n      context_p->token.extra_value = LEXER_NUMBER_OCTAL;\n      context_p->token.lit_location.char_p++;\n      context_p->source_p++;\n      source_p += 2;\n\n      if (source_p >= source_end_p\n          || !lit_char_is_octal_digit (source_p[0]))\n      {\n        parser_raise_error (context_p, PARSER_ERR_INVALID_OCTAL_DIGIT);\n      }\n\n      lexer_parse_octal_number (context_p, &source_p);\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    else if (source_p[1] >= LIT_CHAR_0\n             && source_p[1] <= LIT_CHAR_7)\n    {\n      context_p->token.extra_value = LEXER_NUMBER_OCTAL;\n\n      if (context_p->status_flags & PARSER_IS_STRICT)\n      {\n        parser_raise_error (context_p, PARSER_ERR_OCTAL_NUMBER_NOT_ALLOWED);\n      }\n\n      lexer_parse_octal_number (context_p, &source_p);\n    }\n    else if (source_p[1] >= LIT_CHAR_8\n             && source_p[1] <= LIT_CHAR_9)\n    {\n      parser_raise_error (context_p, PARSER_ERR_INVALID_NUMBER);\n    }\n#if ENABLED (JERRY_ES2015)\n    else if (LEXER_TO_ASCII_LOWERCASE (source_p[1]) == LIT_CHAR_LOWERCASE_B)\n    {\n      context_p->token.extra_value = LEXER_NUMBER_BINARY;\n      context_p->token.lit_location.char_p++;\n      context_p->source_p++;\n      source_p += 2;\n\n      if (source_p >= source_end_p\n          || !lit_char_is_binary_digit (source_p[0]))\n      {\n        parser_raise_error (context_p, PARSER_ERR_INVALID_BIN_DIGIT);\n      }\n\n      do\n      {\n        source_p++;\n      }\n      while (source_p < source_end_p\n               && lit_char_is_binary_digit (source_p[0]));\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    else\n    {\n      can_be_float = true;\n      source_p++;\n    }\n  }\n  else\n  {\n    while (source_p < source_end_p\n           && source_p[0] >= LIT_CHAR_0\n           && source_p[0] <= LIT_CHAR_9)\n    {\n      source_p++;\n    }\n\n    can_be_float = true;\n  }\n\n  if (can_be_float)\n  {\n    if (source_p < source_end_p\n        && source_p[0] == LIT_CHAR_DOT)\n    {\n      source_p++;\n      while (source_p < source_end_p\n             && source_p[0] >= LIT_CHAR_0\n             && source_p[0] <= LIT_CHAR_9)\n      {\n        source_p++;\n      }\n    }\n\n    if (source_p < source_end_p\n        && LEXER_TO_ASCII_LOWERCASE (source_p[0]) == LIT_CHAR_LOWERCASE_E)\n    {\n      source_p++;\n\n      if (source_p < source_end_p\n          && (source_p[0] == LIT_CHAR_PLUS || source_p[0] == LIT_CHAR_MINUS))\n      {\n        source_p++;\n      }\n\n      if (source_p >= source_end_p\n          || source_p[0] < LIT_CHAR_0\n          || source_p[0] > LIT_CHAR_9)\n      {\n        parser_raise_error (context_p, PARSER_ERR_MISSING_EXPONENT);\n      }\n\n      do\n      {\n        source_p++;\n      }\n      while (source_p < source_end_p\n             && source_p[0] >= LIT_CHAR_0\n             && source_p[0] <= LIT_CHAR_9);\n    }\n  }\n\n  length = (size_t) (source_p - context_p->source_p);\n  if (length > PARSER_MAXIMUM_IDENT_LENGTH)\n  {\n    parser_raise_error (context_p, PARSER_ERR_NUMBER_TOO_LONG);\n  }\n\n  context_p->token.lit_location.length = (prop_length_t) length;\n  PARSER_PLUS_EQUAL_LC (context_p->column, length);\n  context_p->source_p = source_p;\n\n  if (source_p < source_end_p && lexer_parse_identifier (context_p, LEXER_PARSE_CHECK_START_AND_RETURN))\n  {\n    parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_AFTER_NUMBER);\n  }\n}",
        "begin_line": 1261,
        "end_line": 1427,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_parse_string#913",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_parse_string (parser_context_t *context_p, /**< context */                     lexer_string_options_t opts) /**< options */",
        "snippet": "void\nlexer_parse_string (parser_context_t *context_p, /**< context */\n                    lexer_string_options_t opts) /**< options */\n{\n#if ENABLED (JERRY_ES2015)\n  size_t raw_length_dec = 0;\n#else /* ENABLED (JERRY_ES2015) */\n  JERRY_UNUSED (opts);\n#endif /* ENABLED (JERRY_ES2015) */\n\n  uint8_t str_end_character = context_p->source_p[0];\n  const uint8_t *source_p = context_p->source_p + 1;\n  const uint8_t *string_start_p = source_p;\n  const uint8_t *source_end_p = context_p->source_end_p;\n  parser_line_counter_t line = context_p->line;\n  parser_line_counter_t column = (parser_line_counter_t) (context_p->column + 1);\n  parser_line_counter_t original_line = line;\n  parser_line_counter_t original_column = column;\n  size_t length = 0;\n  uint8_t has_escape = false;\n\n#if ENABLED (JERRY_ES2015)\n  if (str_end_character == LIT_CHAR_RIGHT_BRACE)\n  {\n    str_end_character = LIT_CHAR_GRAVE_ACCENT;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  while (true)\n  {\n    if (source_p >= source_end_p)\n    {\n      context_p->token.line = original_line;\n      context_p->token.column = (parser_line_counter_t) (original_column - 1);\n      parser_raise_error (context_p, PARSER_ERR_UNTERMINATED_STRING);\n    }\n\n    if (*source_p == str_end_character)\n    {\n      break;\n    }\n\n    if (*source_p == LIT_CHAR_BACKSLASH)\n    {\n      source_p++;\n      column++;\n      if (source_p >= source_end_p)\n      {\n        /* Will throw an unterminated string error. */\n        continue;\n      }\n\n      has_escape = true;\n\n      /* Newline is ignored. */\n      if (*source_p == LIT_CHAR_CR)\n      {\n        source_p++;\n        if (source_p < source_end_p\n            && *source_p == LIT_CHAR_LF)\n        {\n#if ENABLED (JERRY_ES2015)\n          raw_length_dec++;\n#endif /* ENABLED (JERRY_ES2015) */\n          source_p++;\n        }\n\n        line++;\n        column = 1;\n        continue;\n      }\n      else if (*source_p == LIT_CHAR_LF)\n      {\n        source_p++;\n        line++;\n        column = 1;\n        continue;\n      }\n      else if (*source_p == LEXER_NEWLINE_LS_PS_BYTE_1 && LEXER_NEWLINE_LS_PS_BYTE_23 (source_p))\n      {\n        source_p += 3;\n        line++;\n        column = 1;\n        continue;\n      }\n\n#if ENABLED (JERRY_ES2015)\n      if (opts & LEXER_STRING_RAW)\n      {\n        if ((*source_p == LIT_CHAR_GRAVE_ACCENT) || (*source_p == LIT_CHAR_BACKSLASH))\n        {\n          source_p++;\n          column++;\n          length++;\n        }\n        continue;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      if (*source_p == LIT_CHAR_0\n          && source_p + 1 < source_end_p\n          && (*(source_p + 1) < LIT_CHAR_0 || *(source_p + 1) > LIT_CHAR_9))\n      {\n        source_p++;\n        column++;\n        length++;\n        continue;\n      }\n\n      /* Except \\x, \\u, and octal numbers, everything is\n       * converted to a character which has the same byte length. */\n      if (*source_p >= LIT_CHAR_0 && *source_p <= LIT_CHAR_3)\n      {\n        if (context_p->status_flags & PARSER_IS_STRICT)\n        {\n          parser_raise_error (context_p, PARSER_ERR_OCTAL_ESCAPE_NOT_ALLOWED);\n        }\n\n        source_p++;\n        column++;\n\n        if (source_p < source_end_p && *source_p >= LIT_CHAR_0 && *source_p <= LIT_CHAR_7)\n        {\n          source_p++;\n          column++;\n\n          if (source_p < source_end_p && *source_p >= LIT_CHAR_0 && *source_p <= LIT_CHAR_7)\n          {\n            /* Numbers >= 0x200 (0x80) requires\n             * two bytes for encoding in UTF-8. */\n            if (source_p[-2] >= LIT_CHAR_2)\n            {\n              length++;\n            }\n\n            source_p++;\n            column++;\n          }\n        }\n\n        length++;\n        continue;\n      }\n\n      if (*source_p >= LIT_CHAR_4 && *source_p <= LIT_CHAR_7)\n      {\n        if (context_p->status_flags & PARSER_IS_STRICT)\n        {\n          parser_raise_error (context_p, PARSER_ERR_OCTAL_ESCAPE_NOT_ALLOWED);\n        }\n\n        source_p++;\n        column++;\n\n        if (source_p < source_end_p && *source_p >= LIT_CHAR_0 && *source_p <= LIT_CHAR_7)\n        {\n          source_p++;\n          column++;\n        }\n\n        /* The maximum number is 0x4d so the UTF-8\n         * representation is always one byte. */\n        length++;\n        continue;\n      }\n\n      if (*source_p == LIT_CHAR_LOWERCASE_X || *source_p == LIT_CHAR_LOWERCASE_U)\n      {\n        uint32_t escape_length = (*source_p == LIT_CHAR_LOWERCASE_X) ? 3 : 5;\n        lit_code_point_t code_point = UINT32_MAX;\n\n        context_p->token.line = line;\n        context_p->token.column = (parser_line_counter_t) (column - 1);\n\n#if ENABLED (JERRY_ES2015)\n        if (source_p + 4 <= source_end_p\n            && source_p[0] == LIT_CHAR_LOWERCASE_U\n            && source_p[1] == LIT_CHAR_LEFT_BRACE)\n        {\n          code_point = lexer_hex_in_braces_to_code_point (source_p + 2, source_end_p, &escape_length);\n          escape_length--;\n        }\n        else\n        {\n#endif /* ENABLED (JERRY_ES2015) */\n          if (source_p + escape_length <= source_end_p)\n          {\n            code_point = lexer_hex_to_code_point (source_p + 1, escape_length - 1);\n          }\n#if ENABLED (JERRY_ES2015)\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        if (code_point == UINT32_MAX)\n        {\n          parser_raise_error (context_p, PARSER_ERR_INVALID_UNICODE_ESCAPE_SEQUENCE);\n        }\n\n        length += lit_code_point_get_cesu8_length (code_point);\n\n        source_p += escape_length;\n        PARSER_PLUS_EQUAL_LC (column, escape_length);\n        continue;\n      }\n    }\n#if ENABLED (JERRY_ES2015)\n    else if (str_end_character == LIT_CHAR_GRAVE_ACCENT &&\n             source_p[0] == LIT_CHAR_DOLLAR_SIGN &&\n             source_p + 1 < source_end_p &&\n             source_p[1] == LIT_CHAR_LEFT_BRACE)\n    {\n      raw_length_dec++;\n      source_p++;\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    if (*source_p >= LIT_UTF8_4_BYTE_MARKER)\n    {\n      /* Processing 4 byte unicode sequence (even if it is\n       * after a backslash). Always converted to two 3 byte\n       * long sequence. */\n      length += 2 * 3;\n      has_escape = true;\n      source_p += 4;\n      column++;\n      continue;\n    }\n    else if (*source_p == LIT_CHAR_TAB)\n    {\n      column = align_column_to_tab (column);\n      /* Subtract -1 because column is increased below. */\n      column--;\n    }\n#if ENABLED (JERRY_ES2015)\n    else if (str_end_character == LIT_CHAR_GRAVE_ACCENT)\n    {\n      /* Newline (without backslash) is part of the string.\n         Note: ECMAScript v6, 11.8.6.1 <CR> or <CR><LF> are both normalized to <LF> */\n      if (*source_p == LIT_CHAR_CR)\n      {\n        has_escape = true;\n        source_p++;\n        length++;\n        if (source_p < source_end_p\n            && *source_p == LIT_CHAR_LF)\n        {\n          source_p++;\n          raw_length_dec++;\n        }\n        line++;\n        column = 1;\n        continue;\n      }\n      else if (*source_p == LIT_CHAR_LF)\n      {\n        source_p++;\n        length++;\n        line++;\n        column = 1;\n        continue;\n      }\n      else if (*source_p == LEXER_NEWLINE_LS_PS_BYTE_1 && LEXER_NEWLINE_LS_PS_BYTE_23 (source_p))\n      {\n        source_p += 3;\n        length += 3;\n        line++;\n        column = 1;\n        continue;\n      }\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    else if (*source_p == LIT_CHAR_CR\n             || *source_p == LIT_CHAR_LF\n             || (*source_p == LEXER_NEWLINE_LS_PS_BYTE_1 && LEXER_NEWLINE_LS_PS_BYTE_23 (source_p)))\n    {\n      context_p->token.line = line;\n      context_p->token.column = column;\n      parser_raise_error (context_p, PARSER_ERR_NEWLINE_NOT_ALLOWED);\n    }\n\n    source_p++;\n    column++;\n    length++;\n\n    while (source_p < source_end_p\n           && IS_UTF8_INTERMEDIATE_OCTET (*source_p))\n    {\n      source_p++;\n      length++;\n    }\n  }\n\n#if ENABLED (JERRY_ES2015)\n  if (opts & LEXER_STRING_RAW)\n  {\n    length = (size_t) (source_p - string_start_p) - raw_length_dec;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  if (length > PARSER_MAXIMUM_STRING_LENGTH)\n  {\n    parser_raise_error (context_p, PARSER_ERR_STRING_TOO_LONG);\n  }\n\n#if ENABLED (JERRY_ES2015)\n  context_p->token.type = ((str_end_character != LIT_CHAR_GRAVE_ACCENT) ? LEXER_LITERAL\n                                                                        : LEXER_TEMPLATE_LITERAL);\n#else /* !ENABLED (JERRY_ES2015) */\n  context_p->token.type = LEXER_LITERAL;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  /* Fill literal data. */\n  context_p->token.lit_location.char_p = string_start_p;\n  context_p->token.lit_location.length = (prop_length_t) length;\n  context_p->token.lit_location.type = LEXER_STRING_LITERAL;\n  context_p->token.lit_location.has_escape = has_escape;\n\n  context_p->source_p = source_p + 1;\n  context_p->line = line;\n  context_p->column = (parser_line_counter_t) (column + 1);\n}",
        "begin_line": 913,
        "end_line": 1234,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_scan_identifier#3117",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_scan_identifier (parser_context_t *context_p) /**< context */",
        "snippet": "bool\nlexer_scan_identifier (parser_context_t *context_p) /**< context */\n{\n  lexer_skip_spaces (context_p);\n  context_p->token.line = context_p->line;\n  context_p->token.column = context_p->column;\n\n  if (context_p->source_p < context_p->source_end_p\n      && lexer_parse_identifier (context_p, LEXER_PARSE_NO_OPTS))\n  {\n    return true;\n  }\n\n  lexer_next_token (context_p);\n  return false;\n}",
        "begin_line": 3117,
        "end_line": 3132,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_skip_spaces#224",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_skip_spaces (parser_context_t *context_p) /**< context */",
        "snippet": "static void\nlexer_skip_spaces (parser_context_t *context_p) /**< context */\n{\n  skip_mode_t mode = LEXER_SKIP_SPACES;\n  const uint8_t *source_end_p = context_p->source_end_p;\n\n  if (context_p->token.flags & LEXER_NO_SKIP_SPACES)\n  {\n    context_p->token.flags &= (uint8_t) ~LEXER_NO_SKIP_SPACES;\n    return;\n  }\n\n  context_p->token.flags = 0;\n\n  while (true)\n  {\n    if (context_p->source_p >= source_end_p)\n    {\n      if (mode == LEXER_SKIP_MULTI_LINE_COMMENT)\n      {\n        parser_raise_error (context_p, PARSER_ERR_UNTERMINATED_MULTILINE_COMMENT);\n      }\n      return;\n    }\n\n    switch (context_p->source_p[0])\n    {\n      case LIT_CHAR_CR:\n      {\n        if (context_p->source_p + 1 < source_end_p\n            && context_p->source_p[1] == LIT_CHAR_LF)\n        {\n          context_p->source_p++;\n        }\n        /* FALLTHRU */\n      }\n\n      case LIT_CHAR_LF:\n      {\n        context_p->line++;\n        context_p->column = 0;\n        context_p->token.flags = LEXER_WAS_NEWLINE;\n\n        if (mode == LEXER_SKIP_SINGLE_LINE_COMMENT)\n        {\n          mode = LEXER_SKIP_SPACES;\n        }\n        /* FALLTHRU */\n      }\n\n      case LIT_CHAR_VTAB:\n      case LIT_CHAR_FF:\n      case LIT_CHAR_SP:\n      {\n        context_p->source_p++;\n        context_p->column++;\n        continue;\n      }\n\n      case LIT_CHAR_TAB:\n      {\n        context_p->column = align_column_to_tab (context_p->column);\n        context_p->source_p++;\n        continue;\n      }\n\n      case LIT_CHAR_SLASH:\n      {\n        if (mode == LEXER_SKIP_SPACES\n            && context_p->source_p + 1 < source_end_p)\n        {\n          if (context_p->source_p[1] == LIT_CHAR_SLASH)\n          {\n            mode = LEXER_SKIP_SINGLE_LINE_COMMENT;\n          }\n          else if (context_p->source_p[1] == LIT_CHAR_ASTERISK)\n          {\n            mode = LEXER_SKIP_MULTI_LINE_COMMENT;\n            context_p->token.line = context_p->line;\n            context_p->token.column = context_p->column;\n          }\n\n          if (mode != LEXER_SKIP_SPACES)\n          {\n            context_p->source_p += 2;\n            PARSER_PLUS_EQUAL_LC (context_p->column, 2);\n            continue;\n          }\n        }\n        break;\n      }\n\n      case LIT_CHAR_ASTERISK:\n      {\n        if (mode == LEXER_SKIP_MULTI_LINE_COMMENT\n            && context_p->source_p + 1 < source_end_p\n            && context_p->source_p[1] == LIT_CHAR_SLASH)\n        {\n          mode = LEXER_SKIP_SPACES;\n          context_p->source_p += 2;\n          PARSER_PLUS_EQUAL_LC (context_p->column, 2);\n          continue;\n        }\n        break;\n      }\n\n      case 0xc2:\n      {\n        if (context_p->source_p + 1 < source_end_p\n            && context_p->source_p[1] == 0xa0)\n        {\n          /* Codepoint \\u00A0 */\n          context_p->source_p += 2;\n          context_p->column++;\n          continue;\n        }\n        break;\n      }\n\n      case LEXER_NEWLINE_LS_PS_BYTE_1:\n      {\n        JERRY_ASSERT (context_p->source_p + 2 < source_end_p);\n        if (LEXER_NEWLINE_LS_PS_BYTE_23 (context_p->source_p))\n        {\n          /* Codepoint \\u2028 and \\u2029 */\n          context_p->source_p += 3;\n          context_p->line++;\n          context_p->column = 1;\n          context_p->token.flags = LEXER_WAS_NEWLINE;\n\n          if (mode == LEXER_SKIP_SINGLE_LINE_COMMENT)\n          {\n            mode = LEXER_SKIP_SPACES;\n          }\n          continue;\n        }\n        break;\n      }\n\n      case 0xef:\n      {\n        if (context_p->source_p + 2 < source_end_p\n            && context_p->source_p[1] == 0xbb\n            && context_p->source_p[2] == 0xbf)\n        {\n          /* Codepoint \\uFEFF */\n          context_p->source_p += 3;\n          context_p->column++;\n          continue;\n        }\n        break;\n      }\n\n      default:\n      {\n        break;\n      }\n    }\n\n    if (mode == LEXER_SKIP_SPACES)\n    {\n      return;\n    }\n\n    context_p->source_p++;\n\n    if (context_p->source_p < source_end_p\n        && IS_UTF8_INTERMEDIATE_OCTET (context_p->source_p[0]))\n    {\n      context_p->column++;\n    }\n  }\n}",
        "begin_line": 224,
        "end_line": 396,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_string_is_directive#3371",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_string_is_directive (parser_context_t *context_p) /**< context */",
        "snippet": "inline bool JERRY_ATTR_ALWAYS_INLINE\nlexer_string_is_directive (parser_context_t *context_p) /**< context */\n{\n  return (context_p->token.type == LEXER_SEMICOLON\n          || context_p->token.type == LEXER_RIGHT_BRACE\n          || ((context_p->token.flags & LEXER_WAS_NEWLINE)\n              && !LEXER_IS_BINARY_OP_TOKEN (context_p->token.type)\n              && context_p->token.type != LEXER_LEFT_PAREN\n              && context_p->token.type != LEXER_LEFT_SQUARE\n              && context_p->token.type != LEXER_DOT));\n}",
        "begin_line": 3371,
        "end_line": 3381,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_string_is_use_strict#3355",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_string_is_use_strict (parser_context_t *context_p) /**< context */",
        "snippet": "inline bool JERRY_ATTR_ALWAYS_INLINE\nlexer_string_is_use_strict (parser_context_t *context_p) /**< context */\n{\n  JERRY_ASSERT (context_p->token.type == LEXER_LITERAL\n                && context_p->token.lit_location.type == LEXER_STRING_LITERAL);\n\n  return (context_p->token.lit_location.length == 10\n          && !context_p->token.lit_location.has_escape\n          && memcmp (context_p->token.lit_location.char_p, \"use strict\", 10) == 0);\n}",
        "begin_line": 3355,
        "end_line": 3364,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_append_binary_single_assignment_token#2333",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_append_binary_single_assignment_token (parser_context_t *context_p, /**< context */                                               uint32_t pattern_flags) /**< pattern flags */",
        "snippet": "static uint8_t\nparser_append_binary_single_assignment_token (parser_context_t *context_p, /**< context */\n                                              uint32_t pattern_flags) /**< pattern flags */\n{\n  JERRY_UNUSED (pattern_flags);\n\n  /* Unlike other tokens, the whole byte code is saved for binary\n   * assignment, since it has multiple forms depending on the\n   * previous instruction. */\n\n  uint8_t assign_opcode = CBC_ASSIGN;\n\n  if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)\n      && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)\n  {\n    parser_check_invalid_assign (context_p);\n\n    uint16_t literal_index;\n\n    switch (context_p->last_cbc_opcode)\n    {\n      case CBC_PUSH_LITERAL:\n      {\n        literal_index = context_p->last_cbc.literal_index;\n        context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n        break;\n      }\n      case CBC_PUSH_TWO_LITERALS:\n      {\n        literal_index = context_p->last_cbc.value;\n        context_p->last_cbc_opcode = CBC_PUSH_LITERAL;\n        break;\n      }\n      case CBC_PUSH_THIS_LITERAL:\n      {\n        literal_index = context_p->last_cbc.literal_index;\n        context_p->last_cbc_opcode = CBC_PUSH_THIS;\n        parser_flush_cbc (context_p);\n        break;\n      }\n      default:\n      {\n        JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_THREE_LITERALS);\n        literal_index = context_p->last_cbc.third_literal_index;\n        context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;\n        break;\n      }\n    }\n\n    assign_opcode = CBC_ASSIGN_SET_IDENT;\n\n#if ENABLED (JERRY_ES2015)\n    if (!(pattern_flags & (PARSER_PATTERN_LET | PARSER_PATTERN_CONST | PARSER_PATTERN_LOCAL)))\n    {\n      if (scanner_literal_is_const_reg (context_p, literal_index))\n      {\n        parser_stack_push_uint8 (context_p, LEXER_ASSIGN_CONST);\n      }\n    }\n    else if (literal_index < PARSER_REGISTER_START)\n    {\n      assign_opcode = CBC_INIT_LET;\n\n      if (scanner_literal_is_created (context_p, literal_index))\n      {\n        assign_opcode = CBC_ASSIGN_LET_CONST;\n      }\n      else if (pattern_flags & PARSER_PATTERN_CONST)\n      {\n        assign_opcode = CBC_INIT_CONST;\n      }\n      else if (pattern_flags & PARSER_PATTERN_LOCAL)\n      {\n        assign_opcode = CBC_INIT_ARG_OR_CATCH;\n      }\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    parser_stack_push_uint16 (context_p, literal_index);\n    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_LITERAL, assign_opcode));\n  }\n  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP)\n  {\n    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP, CBC_ASSIGN));\n    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n  }\n  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP_LITERAL)\n  {\n    if (context_p->last_cbc.literal_type != LEXER_IDENT_LITERAL)\n    {\n      JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP_LITERAL, CBC_ASSIGN_PROP_LITERAL));\n      parser_stack_push_uint16 (context_p, context_p->last_cbc.literal_index);\n      assign_opcode = CBC_ASSIGN_PROP_LITERAL;\n      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n    }\n    else\n    {\n      context_p->last_cbc_opcode = CBC_PUSH_LITERAL;\n    }\n  }\n  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP_LITERAL_LITERAL)\n  {\n    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP_LITERAL_LITERAL, CBC_PUSH_TWO_LITERALS));\n    context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;\n  }\n  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP_THIS_LITERAL)\n  {\n    if (context_p->last_cbc.literal_type != LEXER_IDENT_LITERAL)\n    {\n      JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP_THIS_LITERAL, CBC_ASSIGN_PROP_THIS_LITERAL));\n      parser_stack_push_uint16 (context_p, context_p->last_cbc.literal_index);\n      assign_opcode = CBC_ASSIGN_PROP_THIS_LITERAL;\n      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n    }\n    else\n    {\n      context_p->last_cbc_opcode = CBC_PUSH_THIS_LITERAL;\n    }\n  }\n#if ENABLED (JERRY_ES2015)\n  else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL))\n  {\n    context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_LITERAL_ASSIGNMENT_REFERENCE);\n    assign_opcode = CBC_ASSIGN_SUPER;\n  }\n  else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP))\n  {\n    context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_ASSIGNMENT_REFERENCE);\n    assign_opcode = CBC_ASSIGN_SUPER;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n  else\n  {\n    /* Invalid LeftHandSide expression. */\n#if ENABLED (JERRY_ES2015)\n    parser_check_invalid_new_target (context_p, CBC_ASSIGN);\n#endif /* ENABLED (JERRY_ES2015) */\n\n    parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);\n  }\n\n  parser_stack_push_uint8 (context_p, assign_opcode);\n  parser_stack_push_uint8 (context_p, LEXER_ASSIGN);\n\n  return assign_opcode;\n}",
        "begin_line": 2333,
        "end_line": 2478,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_append_binary_token#2483",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_append_binary_token (parser_context_t *context_p) /**< context */",
        "snippet": "static void\nparser_append_binary_token (parser_context_t *context_p) /**< context */\n{\n  JERRY_ASSERT (LEXER_IS_BINARY_OP_TOKEN (context_p->token.type));\n\n  parser_push_result (context_p);\n\n  if (context_p->token.type == LEXER_ASSIGN)\n  {\n    parser_append_binary_single_assignment_token (context_p, 0);\n    return;\n  }\n\n  if (LEXER_IS_BINARY_LVALUE_TOKEN (context_p->token.type))\n  {\n    if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)\n        && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)\n    {\n      parser_check_invalid_assign (context_p);\n\n      parser_emit_ident_reference (context_p, CBC_PUSH_IDENT_REFERENCE);\n\n#if ENABLED (JERRY_ES2015)\n      if (scanner_literal_is_const_reg (context_p, context_p->last_cbc.literal_index))\n      {\n        parser_stack_push_uint8 (context_p, LEXER_ASSIGN_CONST);\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n    }\n    else if (PARSER_IS_PUSH_PROP (context_p->last_cbc_opcode))\n    {\n      context_p->last_cbc_opcode = PARSER_PUSH_PROP_TO_PUSH_PROP_REFERENCE (context_p->last_cbc_opcode);\n    }\n    else\n    {\n      /* Invalid LeftHandSide expression. */\n#if ENABLED (JERRY_ES2015)\n      parser_check_invalid_new_target (context_p, CBC_ASSIGN);\n#endif /* ENABLED (JERRY_ES2015) */\n\n      parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);\n      parser_emit_cbc (context_p, CBC_PUSH_PROP_REFERENCE);\n    }\n  }\n  else if (context_p->token.type == LEXER_LOGICAL_OR\n           || context_p->token.type == LEXER_LOGICAL_AND)\n  {\n    parser_branch_t branch;\n    uint16_t opcode = CBC_BRANCH_IF_LOGICAL_TRUE;\n\n    if (context_p->token.type == LEXER_LOGICAL_AND)\n    {\n      opcode = CBC_BRANCH_IF_LOGICAL_FALSE;\n    }\n\n    parser_emit_cbc_forward_branch (context_p, opcode, &branch);\n    parser_stack_push (context_p, &branch, sizeof (parser_branch_t));\n  }\n\n  parser_stack_push_uint8 (context_p, context_p->token.type);\n}",
        "begin_line": 2483,
        "end_line": 2543,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_check_invalid_assign#117",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_check_invalid_assign (parser_context_t *context_p) /**< context */",
        "snippet": "static void\nparser_check_invalid_assign (parser_context_t *context_p) /**< context */\n{\n  JERRY_ASSERT (context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL);\n\n  if (JERRY_UNLIKELY (context_p->status_flags & PARSER_IS_STRICT))\n  {\n    if (context_p->last_cbc.literal_keyword_type == LEXER_KEYW_EVAL)\n    {\n      parser_raise_error (context_p, PARSER_ERR_EVAL_CANNOT_ASSIGNED);\n    }\n    else if (context_p->last_cbc.literal_keyword_type == LEXER_KEYW_ARGUMENTS)\n    {\n      parser_raise_error (context_p, PARSER_ERR_ARGUMENTS_CANNOT_ASSIGNED);\n    }\n  }\n}",
        "begin_line": 117,
        "end_line": 133,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_parse_array_literal#281",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_parse_array_literal (parser_context_t *context_p) /**< context */",
        "snippet": "static void\nparser_parse_array_literal (parser_context_t *context_p) /**< context */\n{\n  uint32_t pushed_items = 0;\n  uint16_t opcode = (uint16_t) CBC_ARRAY_APPEND;\n\n  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_SQUARE);\n\n  parser_emit_cbc (context_p, CBC_CREATE_ARRAY);\n  lexer_next_token (context_p);\n\n  while (true)\n  {\n    if (context_p->token.type == LEXER_RIGHT_SQUARE)\n    {\n      if (pushed_items > 0)\n      {\n        parser_emit_cbc_call (context_p, opcode, pushed_items);\n      }\n      return;\n    }\n\n    pushed_items++;\n\n    if (context_p->token.type == LEXER_COMMA)\n    {\n      parser_emit_cbc (context_p, CBC_PUSH_ELISION);\n      lexer_next_token (context_p);\n    }\n    else\n    {\n#if ENABLED (JERRY_ES2015)\n      if (context_p->token.type == LEXER_THREE_DOTS)\n      {\n        opcode = (uint16_t) (PARSER_TO_EXT_OPCODE (CBC_EXT_SPREAD_ARRAY_APPEND));\n        pushed_items++;\n        lexer_next_token (context_p);\n        parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SPREAD_ELEMENT);\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);\n\n      if (context_p->last_cbc_opcode == CBC_PUSH_THIS)\n      {\n        parser_flush_cbc (context_p);\n      }\n\n      if (context_p->token.type == LEXER_COMMA)\n      {\n        lexer_next_token (context_p);\n      }\n      else if (context_p->token.type != LEXER_RIGHT_SQUARE)\n      {\n        parser_raise_error (context_p, PARSER_ERR_ARRAY_ITEM_SEPARATOR_EXPECTED);\n      }\n    }\n\n    if (pushed_items >= 64)\n    {\n      parser_emit_cbc_call (context_p, opcode, pushed_items);\n#if ENABLED (JERRY_ES2015)\n      opcode = (uint16_t) CBC_ARRAY_APPEND;\n#endif /* ENABLED (JERRY_ES2015) */\n      pushed_items = 0;\n    }\n  }\n}",
        "begin_line": 281,
        "end_line": 348,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_parse_block_expression#3263",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_parse_block_expression (parser_context_t *context_p, /**< context */                                int options) /**< option flags */",
        "snippet": "void\nparser_parse_block_expression (parser_context_t *context_p, /**< context */\n                               int options) /**< option flags */\n{\n  parser_parse_expression (context_p, options | PARSE_EXPR_NO_PUSH_RESULT);\n\n  if (CBC_NO_RESULT_OPERATION (context_p->last_cbc_opcode))\n  {\n    JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, context_p->last_cbc_opcode + 2));\n    PARSER_PLUS_EQUAL_U16 (context_p->last_cbc_opcode, 2);\n    parser_flush_cbc (context_p);\n  }\n  else\n  {\n    parser_emit_cbc (context_p, CBC_POP_BLOCK);\n  }\n}",
        "begin_line": 3263,
        "end_line": 3279,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_parse_expression#3302",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_parse_expression (parser_context_t *context_p, /**< context */                          int options) /**< option flags */",
        "snippet": "void\nparser_parse_expression (parser_context_t *context_p, /**< context */\n                         int options) /**< option flags */\n{\n  size_t grouping_level = (options & PARSE_EXPR_LEFT_HAND_SIDE);\n\n  parser_stack_push_uint8 (context_p, LEXER_EXPRESSION_START);\n\n  if (options & PARSE_EXPR_HAS_LITERAL)\n  {\n    JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);\n    goto process_unary_expression;\n  }\n\n  while (true)\n  {\n    if (parser_parse_unary_expression (context_p, &grouping_level))\n    {\n      parser_process_binary_opcodes (context_p, 0);\n      break;\n    }\n\n    while (true)\n    {\nprocess_unary_expression:\n      parser_process_unary_expression (context_p, grouping_level);\n\n      if (JERRY_LIKELY (grouping_level != PARSE_EXPR_LEFT_HAND_SIDE))\n      {\n        uint8_t min_prec_treshold = 0;\n\n        if (LEXER_IS_BINARY_OP_TOKEN (context_p->token.type))\n        {\n          min_prec_treshold = parser_binary_precedence_table[context_p->token.type - LEXER_FIRST_BINARY_OP];\n\n#if ENABLED (JERRY_ES2015)\n          /* Check for BINARY_LVALUE tokens + LEXER_LOGICAL_OR + LEXER_LOGICAL_AND + LEXER_EXPONENTIATION */\n          if ((min_prec_treshold == PARSER_RIGHT_TO_LEFT_ORDER_EXPONENTIATION)\n              || (min_prec_treshold <= PARSER_RIGHT_TO_LEFT_ORDER_MAX_PRECEDENCE\n                  && min_prec_treshold != PARSER_RIGHT_TO_LEFT_ORDER_TERNARY_PRECEDENCE))\n          {\n            /* Right-to-left evaluation order. */\n            min_prec_treshold++;\n          }\n#else /* !ENABLED (JERRY_ES2015) */\n          /* Check for BINARY_LVALUE tokens + LEXER_LOGICAL_OR + LEXER_LOGICAL_AND */\n          if (min_prec_treshold <= PARSER_RIGHT_TO_LEFT_ORDER_MAX_PRECEDENCE\n              && min_prec_treshold != PARSER_RIGHT_TO_LEFT_ORDER_TERNARY_PRECEDENCE)\n          {\n            /* Right-to-left evaluation order. */\n            min_prec_treshold++;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n        }\n\n        parser_process_binary_opcodes (context_p, min_prec_treshold);\n      }\n\n      if (context_p->token.type == LEXER_RIGHT_PAREN\n          && (context_p->stack_top_uint8 == LEXER_LEFT_PAREN\n              || context_p->stack_top_uint8 == LEXER_COMMA_SEP_LIST))\n      {\n        parser_process_group_expression (context_p, &grouping_level);\n        continue;\n      }\n\n      if (JERRY_UNLIKELY (context_p->token.type == LEXER_QUESTION_MARK)\n          && (grouping_level != PARSE_EXPR_LEFT_HAND_SIDE)\n          && parser_process_ternary_expression (context_p, grouping_level))\n      {\n        continue;\n      }\n      break;\n    }\n\n    if (grouping_level == PARSE_EXPR_LEFT_HAND_SIDE)\n    {\n      break;\n    }\n\n    if (JERRY_UNLIKELY (context_p->token.type == LEXER_COMMA)\n        && (!(options & PARSE_EXPR_NO_COMMA) || grouping_level >= PARSER_GROUPING_LEVEL_INCREASE))\n    {\n      parser_process_expression_sequence (context_p);\n      continue;\n    }\n\n    if (LEXER_IS_BINARY_OP_TOKEN (context_p->token.type))\n    {\n      parser_append_binary_token (context_p);\n      lexer_next_token (context_p);\n      continue;\n    }\n    break;\n  }\n\n  if (grouping_level >= PARSER_GROUPING_LEVEL_INCREASE)\n  {\n    parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);\n  }\n\n  JERRY_ASSERT (context_p->stack_top_uint8 == LEXER_EXPRESSION_START);\n  parser_stack_pop_uint8 (context_p);\n\n  if (!(options & PARSE_EXPR_NO_PUSH_RESULT))\n  {\n    parser_push_result (context_p);\n  }\n}",
        "begin_line": 3302,
        "end_line": 3410,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_parse_expression_statement#3284",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_parse_expression_statement (parser_context_t *context_p, /**< context */                                    int options) /**< option flags */",
        "snippet": "void\nparser_parse_expression_statement (parser_context_t *context_p, /**< context */\n                                   int options) /**< option flags */\n{\n  parser_parse_expression (context_p, options | PARSE_EXPR_NO_PUSH_RESULT);\n\n  if (!CBC_NO_RESULT_OPERATION (context_p->last_cbc_opcode))\n  {\n    parser_emit_cbc (context_p, CBC_POP);\n  }\n}",
        "begin_line": 3284,
        "end_line": 3294,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_parse_object_literal#892",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_parse_object_literal (parser_context_t *context_p) /**< context */",
        "snippet": "static void\nparser_parse_object_literal (parser_context_t *context_p) /**< context */\n{\n  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_BRACE);\n\n  parser_emit_cbc (context_p, CBC_CREATE_OBJECT);\n\n#if !ENABLED (JERRY_ES2015)\n  parser_stack_push_uint8 (context_p, PARSER_OBJECT_PROPERTY_START);\n#endif /* !ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_ES2015)\n  bool proto_seen = false;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  while (true)\n  {\n    lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_NO_OPTS);\n\n    switch (context_p->token.type)\n    {\n      case LEXER_RIGHT_BRACE:\n      {\n        break;\n      }\n      case LEXER_PROPERTY_GETTER:\n      case LEXER_PROPERTY_SETTER:\n      {\n        uint32_t status_flags;\n        cbc_ext_opcode_t opcode;\n#if !ENABLED (JERRY_ES2015)\n        parser_object_literal_item_types_t item_type;\n#endif /* !ENABLED (JERRY_ES2015) */\n\n        if (context_p->token.type == LEXER_PROPERTY_GETTER)\n        {\n          status_flags = PARSER_FUNCTION_CLOSURE | PARSER_IS_PROPERTY_GETTER;\n          opcode = CBC_EXT_SET_GETTER;\n#if !ENABLED (JERRY_ES2015)\n          item_type = PARSER_OBJECT_PROPERTY_GETTER;\n#endif /* !ENABLED (JERRY_ES2015) */\n        }\n        else\n        {\n          status_flags = PARSER_FUNCTION_CLOSURE | PARSER_IS_PROPERTY_SETTER;\n          opcode = CBC_EXT_SET_SETTER;\n#if !ENABLED (JERRY_ES2015)\n          item_type = PARSER_OBJECT_PROPERTY_SETTER;\n#endif /* !ENABLED (JERRY_ES2015) */\n        }\n\n        lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_ONLY_IDENTIFIERS);\n\n        /* This assignment is a nop for computed getters/setters. */\n        uint16_t literal_index = context_p->lit_object.index;\n\n#if ENABLED (JERRY_ES2015)\n        if (context_p->token.type == LEXER_RIGHT_SQUARE)\n        {\n          opcode = ((opcode == CBC_EXT_SET_GETTER) ? CBC_EXT_SET_COMPUTED_GETTER\n                                                   : CBC_EXT_SET_COMPUTED_SETTER);\n        }\n#else /* !ENABLED (JERRY_ES2015) */\n        parser_append_object_literal_item (context_p, literal_index, item_type);\n#endif /* ENABLED (JERRY_ES2015) */\n\n        uint16_t function_literal_index = lexer_construct_function_object (context_p, status_flags);\n\n#if ENABLED (JERRY_ES2015)\n        if (opcode >= CBC_EXT_SET_COMPUTED_GETTER)\n        {\n          literal_index = function_literal_index;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        parser_emit_cbc_literal (context_p,\n                                 CBC_PUSH_LITERAL,\n                                 literal_index);\n\n        JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);\n        context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (opcode);\n        context_p->last_cbc.value = function_literal_index;\n\n        lexer_next_token (context_p);\n        break;\n      }\n#if ENABLED (JERRY_ES2015)\n      case LEXER_RIGHT_SQUARE:\n      {\n        lexer_next_token (context_p);\n\n        if (context_p->token.type == LEXER_LEFT_PAREN)\n        {\n          parser_parse_object_method (context_p);\n\n          JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);\n          context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SET_COMPUTED_PROPERTY_LITERAL);\n          break;\n        }\n\n        if (context_p->token.type != LEXER_COLON)\n        {\n          parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);\n        }\n\n        lexer_next_token (context_p);\n        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);\n\n        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)\n        {\n          context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SET_COMPUTED_PROPERTY_LITERAL);\n        }\n        else\n        {\n          parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_PROPERTY);\n        }\n        break;\n      }\n      case LEXER_KEYW_ASYNC:\n      case LEXER_MULTIPLY:\n      {\n        uint32_t status_flags = PARSER_FUNCTION_CLOSURE;\n\n        if (context_p->token.type == LEXER_KEYW_ASYNC)\n        {\n          status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;\n          lexer_consume_generator (context_p);\n        }\n\n        if (context_p->token.type == LEXER_MULTIPLY)\n        {\n          status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;\n        }\n\n        lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_ONLY_IDENTIFIERS);\n\n        uint16_t opcode = CBC_SET_LITERAL_PROPERTY;\n        /* This assignment is a nop for CBC_EXT_SET_COMPUTED_PROPERTY_LITERAL. */\n        uint16_t literal_index = context_p->lit_object.index;\n\n        if (context_p->token.type == LEXER_RIGHT_SQUARE)\n        {\n          opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SET_COMPUTED_PROPERTY_LITERAL);\n        }\n\n        uint16_t function_literal_index = lexer_construct_function_object (context_p, status_flags);\n\n        parser_emit_cbc_literal (context_p,\n                                 CBC_PUSH_LITERAL,\n                                 function_literal_index);\n\n        JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);\n        context_p->last_cbc_opcode = opcode;\n        context_p->last_cbc.value = literal_index;\n\n        lexer_next_token (context_p);\n        break;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      default:\n      {\n#if ENABLED (JERRY_ES2015)\n        const lexer_lit_location_t *literal_p = (const lexer_lit_location_t *) context_p->lit_object.literal_p;\n        bool is_proto = ((context_p->token.lit_location.type == LEXER_IDENT_LITERAL\n                          || context_p->token.lit_location.type == LEXER_STRING_LITERAL)\n                         && lexer_compare_identifier_to_string (literal_p, (uint8_t *) \"__proto__\", 9)\n                         && lexer_check_next_character (context_p, LIT_CHAR_COLON));\n        if (is_proto)\n        {\n          if (proto_seen)\n          {\n            parser_raise_error (context_p, PARSER_ERR_DUPLICATED_PROTO);\n          }\n\n          proto_seen = true;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        uint16_t literal_index = context_p->lit_object.index;\n\n#if ENABLED (JERRY_ES2015)\n        parser_line_counter_t start_line = context_p->token.line;\n        parser_line_counter_t start_column = context_p->token.column;\n#else /* !ENABLED (JERRY_ES2015) */\n        parser_append_object_literal_item (context_p,\n                                           literal_index,\n                                           PARSER_OBJECT_PROPERTY_VALUE);\n#endif /* ENABLED (JERRY_ES2015) */\n\n        lexer_next_token (context_p);\n\n#if ENABLED (JERRY_ES2015)\n        if (context_p->token.type == LEXER_LEFT_PAREN && !is_proto)\n        {\n          parser_parse_object_method (context_p);\n\n          JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);\n          context_p->last_cbc_opcode = CBC_SET_LITERAL_PROPERTY;\n          context_p->last_cbc.value = literal_index;\n          break;\n        }\n\n        if ((context_p->token.type == LEXER_RIGHT_BRACE || context_p->token.type == LEXER_COMMA)\n            && !is_proto)\n        {\n          parser_reparse_as_common_identifier (context_p, start_line, start_column);\n          parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);\n\n          context_p->last_cbc_opcode = CBC_SET_LITERAL_PROPERTY;\n          context_p->last_cbc.value = literal_index;\n\n          lexer_next_token (context_p);\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        if (context_p->token.type != LEXER_COLON)\n        {\n          parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);\n        }\n\n        lexer_next_token (context_p);\n        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);\n\n#if ENABLED (JERRY_ES2015)\n        if (is_proto)\n        {\n          parser_emit_cbc_ext (context_p, CBC_EXT_SET__PROTO__);\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)\n        {\n          context_p->last_cbc_opcode = CBC_SET_LITERAL_PROPERTY;\n          context_p->last_cbc.value = literal_index;\n        }\n        else\n        {\n          parser_emit_cbc_literal (context_p, CBC_SET_PROPERTY, literal_index);\n        }\n\n        break;\n      }\n    }\n\n    if (context_p->token.type == LEXER_RIGHT_BRACE)\n    {\n      break;\n    }\n    else if (context_p->token.type != LEXER_COMMA)\n    {\n      parser_raise_error (context_p, PARSER_ERR_OBJECT_ITEM_SEPARATOR_EXPECTED);\n    }\n  }\n\n#if !ENABLED (JERRY_ES2015)\n  while (context_p->stack_top_uint8 != PARSER_OBJECT_PROPERTY_START)\n  {\n    parser_stack_pop (context_p, NULL, 3);\n  }\n\n  parser_stack_pop_uint8 (context_p);\n#endif /* !ENABLED (JERRY_ES2015) */\n}",
        "begin_line": 892,
        "end_line": 1156,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_parse_unary_expression#1506",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_parse_unary_expression (parser_context_t *context_p, /**< context */                                size_t *grouping_level_p) /**< grouping level */",
        "snippet": "static bool\nparser_parse_unary_expression (parser_context_t *context_p, /**< context */\n                               size_t *grouping_level_p) /**< grouping level */\n{\n  bool new_was_seen = false;\n\n  /* Collect unary operators. */\n  while (true)\n  {\n    /* Convert plus and minus binary operators to unary operators. */\n    switch (context_p->token.type)\n    {\n      case LEXER_ADD:\n      {\n        context_p->token.type = LEXER_PLUS;\n        break;\n      }\n      case LEXER_SUBTRACT:\n      {\n        context_p->token.type = LEXER_NEGATE;\n        break;\n      }\n#if ENABLED (JERRY_ES2015)\n      case LEXER_KEYW_AWAIT:\n      {\n        if (JERRY_UNLIKELY (context_p->token.lit_location.has_escape))\n        {\n          parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);\n        }\n        break;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n    }\n\n    /* Bracketed expressions are primary expressions. At this\n     * point their left paren is pushed onto the stack and\n     * they are processed when their closing paren is reached. */\n    if (context_p->token.type == LEXER_LEFT_PAREN)\n    {\n#if ENABLED (JERRY_ES2015)\n      if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n      {\n        JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);\n        break;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      (*grouping_level_p) += PARSER_GROUPING_LEVEL_INCREASE;\n      new_was_seen = false;\n    }\n    else if (context_p->token.type == LEXER_KEYW_NEW)\n    {\n      /* After 'new' unary operators are not allowed. */\n      new_was_seen = true;\n\n#if ENABLED (JERRY_ES2015)\n      /* Check if \"new.target\" is written here. */\n      if (scanner_try_scan_new_target (context_p))\n      {\n        if (!(context_p->status_flags & PARSER_ALLOW_NEW_TARGET))\n        {\n          parser_raise_error (context_p, PARSER_ERR_NEW_TARGET_NOT_ALLOWED);\n        }\n\n        parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_NEW_TARGET);\n        lexer_next_token (context_p);\n        /* Found \"new.target\" return here */\n        return false;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n    }\n    else if (new_was_seen\n             || (*grouping_level_p == PARSE_EXPR_LEFT_HAND_SIDE)\n             || !LEXER_IS_UNARY_OP_TOKEN (context_p->token.type))\n    {\n      break;\n    }\n\n    parser_stack_push_uint8 (context_p, context_p->token.type);\n    lexer_next_token (context_p);\n  }\n\n  /* Parse primary expression. */\n  switch (context_p->token.type)\n  {\n#if ENABLED (JERRY_ES2015)\n    case LEXER_TEMPLATE_LITERAL:\n    {\n      if (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)\n      {\n        parser_parse_template_literal (context_p);\n        break;\n      }\n\n      /* The string is a normal string literal. */\n      /* FALLTHRU */\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case LEXER_LITERAL:\n    {\n#if ENABLED (JERRY_ES2015)\n      if (JERRY_UNLIKELY (context_p->next_scanner_info_p->source_p == context_p->source_p))\n      {\n        JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);\n\n        uint32_t arrow_status_flags = (PARSER_IS_FUNCTION | PARSER_IS_ARROW_FUNCTION);\n\n        if (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_ASYNC)\n        {\n          JERRY_ASSERT (lexer_token_is_async (context_p));\n          JERRY_ASSERT (!(context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_STATEMENT));\n\n          uint32_t saved_status_flags = context_p->status_flags;\n\n          context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;\n          lexer_next_token (context_p);\n          context_p->status_flags = saved_status_flags;\n\n          if (context_p->token.type == LEXER_KEYW_FUNCTION)\n          {\n            uint32_t status_flags = (PARSER_FUNCTION_CLOSURE\n                                     | PARSER_IS_FUNC_EXPRESSION\n                                     | PARSER_IS_ASYNC_FUNCTION\n                                     | PARSER_DISALLOW_AWAIT_YIELD);\n            parser_parse_function_expression (context_p, status_flags);\n            break;\n          }\n\n          arrow_status_flags = (PARSER_IS_FUNCTION\n                                | PARSER_IS_ARROW_FUNCTION\n                                | PARSER_IS_ASYNC_FUNCTION\n                                | PARSER_DISALLOW_AWAIT_YIELD);\n        }\n\n        parser_check_assignment_expr (context_p);\n        parser_parse_function_expression (context_p, arrow_status_flags);\n        return parser_abort_parsing_after_arrow (context_p);\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      uint8_t type = context_p->token.lit_location.type;\n\n      if (type == LEXER_IDENT_LITERAL || type == LEXER_STRING_LITERAL)\n      {\n        lexer_construct_literal_object (context_p,\n                                        &context_p->token.lit_location,\n                                        context_p->token.lit_location.type);\n\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n        if ((context_p->status_flags & PARSER_MODULE_STORE_IDENT)\n            && type == LEXER_IDENT_LITERAL)\n        {\n          context_p->module_identifier_lit_p = context_p->lit_object.literal_p;\n          context_p->status_flags &= (uint32_t) ~(PARSER_MODULE_STORE_IDENT);\n        }\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n      }\n      else if (type == LEXER_NUMBER_LITERAL)\n      {\n        bool is_negative_number = false;\n\n        if ((context_p->stack_top_uint8 == LEXER_PLUS || context_p->stack_top_uint8 == LEXER_NEGATE)\n            && !lexer_check_post_primary_exp (context_p))\n        {\n          do\n          {\n            if (context_p->stack_top_uint8 == LEXER_NEGATE)\n            {\n              is_negative_number = !is_negative_number;\n            }\n            parser_stack_pop_uint8 (context_p);\n          }\n          while (context_p->stack_top_uint8 == LEXER_PLUS\n                 || context_p->stack_top_uint8 == LEXER_NEGATE);\n        }\n\n        if (lexer_construct_number_object (context_p, true, is_negative_number))\n        {\n          JERRY_ASSERT (context_p->lit_object.index <= CBC_PUSH_NUMBER_BYTE_RANGE_END);\n\n          parser_emit_cbc_push_number (context_p, is_negative_number);\n          break;\n        }\n      }\n\n      cbc_opcode_t opcode = CBC_PUSH_LITERAL;\n\n      if (context_p->token.keyword_type != LEXER_KEYW_EVAL)\n      {\n        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)\n        {\n          context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;\n          context_p->last_cbc.value = context_p->lit_object.index;\n          context_p->last_cbc.literal_type = context_p->token.lit_location.type;\n          context_p->last_cbc.literal_keyword_type = context_p->token.keyword_type;\n          break;\n        }\n\n        if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)\n        {\n          context_p->last_cbc_opcode = CBC_PUSH_THREE_LITERALS;\n          context_p->last_cbc.third_literal_index = context_p->lit_object.index;\n          context_p->last_cbc.literal_type = context_p->token.lit_location.type;\n          context_p->last_cbc.literal_keyword_type = context_p->token.keyword_type;\n          break;\n        }\n\n        if (context_p->last_cbc_opcode == CBC_PUSH_THIS)\n        {\n          context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n          opcode = CBC_PUSH_THIS_LITERAL;\n        }\n      }\n\n      parser_emit_cbc_literal_from_token (context_p, (uint16_t) opcode);\n      break;\n    }\n    case LEXER_KEYW_FUNCTION:\n    {\n      parser_parse_function_expression (context_p, PARSER_FUNCTION_CLOSURE | PARSER_IS_FUNC_EXPRESSION);\n      break;\n    }\n    case LEXER_LEFT_BRACE:\n    {\n#if ENABLED (JERRY_ES2015)\n      if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n      {\n        JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER);\n\n        if (parser_is_assignment_expr (context_p))\n        {\n          parser_parse_object_initializer (context_p, PARSER_PATTERN_NO_OPTS);\n          return false;\n        }\n\n        scanner_release_next (context_p, sizeof (scanner_location_info_t));\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      parser_parse_object_literal (context_p);\n      break;\n    }\n    case LEXER_LEFT_SQUARE:\n    {\n#if ENABLED (JERRY_ES2015)\n      if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n      {\n        JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER);\n\n        if (parser_is_assignment_expr (context_p))\n        {\n          parser_parse_array_initializer (context_p, PARSER_PATTERN_NO_OPTS);\n          return false;\n        }\n\n        scanner_release_next (context_p, sizeof (scanner_location_info_t));\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      parser_parse_array_literal (context_p);\n      break;\n    }\n    case LEXER_DIVIDE:\n    case LEXER_ASSIGN_DIVIDE:\n    {\n      lexer_construct_regexp_object (context_p, false);\n\n      uint16_t literal_index = (uint16_t) (context_p->literal_count - 1);\n\n      if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)\n      {\n        context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;\n        context_p->last_cbc.value = literal_index;\n      }\n      else if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)\n      {\n        context_p->last_cbc_opcode = CBC_PUSH_THREE_LITERALS;\n        context_p->last_cbc.third_literal_index = literal_index;\n      }\n      else\n      {\n        parser_emit_cbc_literal (context_p, CBC_PUSH_LITERAL, literal_index);\n      }\n\n      context_p->last_cbc.literal_type = LEXER_REGEXP_LITERAL;\n      context_p->last_cbc.literal_keyword_type = LEXER_EOS;\n      break;\n    }\n    case LEXER_KEYW_THIS:\n    {\n#if ENABLED (JERRY_ES2015)\n      if (context_p->status_flags & PARSER_ALLOW_SUPER_CALL)\n      {\n        parser_emit_cbc_ext (context_p, CBC_EXT_RESOLVE_LEXICAL_THIS);\n      }\n      else\n      {\n#endif /* ENABLED (JERRY_ES2015) */\n        parser_emit_cbc (context_p, CBC_PUSH_THIS);\n#if ENABLED (JERRY_ES2015)\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      break;\n    }\n    case LEXER_LIT_TRUE:\n    {\n      parser_emit_cbc (context_p, CBC_PUSH_TRUE);\n      break;\n    }\n    case LEXER_LIT_FALSE:\n    {\n      parser_emit_cbc (context_p, CBC_PUSH_FALSE);\n      break;\n    }\n    case LEXER_LIT_NULL:\n    {\n      parser_emit_cbc (context_p, CBC_PUSH_NULL);\n      break;\n    }\n#if ENABLED (JERRY_ES2015)\n    case LEXER_KEYW_CLASS:\n    {\n      parser_parse_class (context_p, false);\n      return false;\n    }\n    case LEXER_KEYW_SUPER:\n    {\n      if (context_p->status_flags & PARSER_ALLOW_SUPER)\n      {\n        if (lexer_check_next_characters (context_p, LIT_CHAR_DOT, LIT_CHAR_LEFT_SQUARE))\n        {\n          parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SUPER);\n          break;\n        }\n\n        if (lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN)\n            && (context_p->status_flags & PARSER_ALLOW_SUPER_CALL))\n        {\n          parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SUPER_CONSTRUCTOR);\n          break;\n        }\n      }\n\n      parser_raise_error (context_p, PARSER_ERR_UNEXPECTED_SUPER_KEYWORD);\n    }\n    case LEXER_LEFT_PAREN:\n    {\n      JERRY_ASSERT (context_p->next_scanner_info_p->source_p == context_p->source_p\n                    && context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);\n\n      parser_check_assignment_expr (context_p);\n\n      parser_parse_function_expression (context_p, PARSER_IS_FUNCTION | PARSER_IS_ARROW_FUNCTION);\n      return parser_abort_parsing_after_arrow (context_p);\n    }\n    case LEXER_KEYW_YIELD:\n    {\n      JERRY_ASSERT ((context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)\n                    && !(context_p->status_flags & PARSER_DISALLOW_AWAIT_YIELD));\n\n      if (context_p->token.lit_location.has_escape)\n      {\n        parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);\n      }\n\n      parser_check_assignment_expr (context_p);\n      lexer_next_token (context_p);\n\n      cbc_ext_opcode_t opcode = CBC_EXT_YIELD;\n\n      if (!lexer_check_yield_no_arg (context_p))\n      {\n        if (context_p->token.type == LEXER_MULTIPLY)\n        {\n          lexer_next_token (context_p);\n          opcode = CBC_EXT_YIELD_ITERATOR;\n        }\n\n        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);\n      }\n      else\n      {\n        parser_emit_cbc (context_p, CBC_PUSH_UNDEFINED);\n      }\n\n      parser_emit_cbc_ext (context_p, opcode);\n\n      return (context_p->token.type != LEXER_RIGHT_PAREN\n              && context_p->token.type != LEXER_COMMA);\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    default:\n    {\n      bool is_left_hand_side = (*grouping_level_p == PARSE_EXPR_LEFT_HAND_SIDE);\n      parser_raise_error (context_p, (is_left_hand_side ? PARSER_ERR_LEFT_HAND_SIDE_EXP_EXPECTED\n                                                        : PARSER_ERR_PRIMARY_EXP_EXPECTED));\n      break;\n    }\n  }\n  lexer_next_token (context_p);\n  return false;\n}",
        "begin_line": 1506,
        "end_line": 1906,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_process_binary_opcodes#2548",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_process_binary_opcodes (parser_context_t *context_p, /**< context */                                uint8_t min_prec_treshold) /**< minimal precedence of tokens */",
        "snippet": "static void\nparser_process_binary_opcodes (parser_context_t *context_p, /**< context */\n                               uint8_t min_prec_treshold) /**< minimal precedence of tokens */\n{\n  while (true)\n  {\n    uint8_t token = context_p->stack_top_uint8;\n    cbc_opcode_t opcode;\n\n    /* For left-to-right operators (all binary operators except assignment\n     * and logical operators), the byte code is flushed if the precedence\n     * of the next operator is less or equal than the current operator. For\n     * assignment and logical operators, we add 1 to the min precendence to\n     * force right-to-left evaluation order. */\n\n    if (!LEXER_IS_BINARY_OP_TOKEN (token)\n        || parser_binary_precedence_table[token - LEXER_FIRST_BINARY_OP] < min_prec_treshold)\n    {\n      return;\n    }\n\n    parser_push_result (context_p);\n    parser_stack_pop_uint8 (context_p);\n\n    if (token == LEXER_ASSIGN)\n    {\n      opcode = (cbc_opcode_t) context_p->stack_top_uint8;\n      parser_stack_pop_uint8 (context_p);\n\n      int32_t index = -1;\n      if (cbc_flags[opcode] & CBC_HAS_LITERAL_ARG)\n      {\n        JERRY_ASSERT (opcode == CBC_ASSIGN_SET_IDENT\n                      || opcode == CBC_ASSIGN_PROP_LITERAL\n                      || opcode == CBC_ASSIGN_PROP_THIS_LITERAL\n                      || opcode == CBC_ASSIGN_LET_CONST\n                      || opcode == CBC_INIT_ARG_OR_CATCH\n                      || opcode == CBC_INIT_LET\n                      || opcode == CBC_INIT_CONST);\n\n        index = parser_stack_pop_uint16 (context_p);\n      }\n\n#if ENABLED (JERRY_ES2015)\n      if (JERRY_UNLIKELY (context_p->stack_top_uint8 == LEXER_ASSIGN_CONST))\n      {\n        parser_stack_pop_uint8 (context_p);\n        parser_emit_cbc_ext (context_p, CBC_EXT_THROW_ASSIGN_CONST_ERROR);\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      if (index >= 0)\n      {\n        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL\n            && opcode == CBC_ASSIGN_SET_IDENT)\n        {\n          JERRY_ASSERT (CBC_ARGS_EQ (CBC_ASSIGN_LITERAL_SET_IDENT,\n                                     CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2));\n\n          context_p->last_cbc.value = (uint16_t) index;\n          context_p->last_cbc_opcode = CBC_ASSIGN_LITERAL_SET_IDENT;\n          continue;\n        }\n\n        parser_emit_cbc_literal (context_p, (uint16_t) opcode, (uint16_t) index);\n\n        if (opcode == CBC_ASSIGN_PROP_THIS_LITERAL\n            && (context_p->stack_depth >= context_p->stack_limit))\n        {\n          /* Stack limit is increased for VM_OC_ASSIGN_PROP_THIS. Needed by vm.c. */\n          JERRY_ASSERT (context_p->stack_depth == context_p->stack_limit);\n\n          context_p->stack_limit++;\n\n          if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)\n          {\n            parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);\n          }\n        }\n        continue;\n      }\n    }\n    else if (LEXER_IS_BINARY_LVALUE_TOKEN (token))\n    {\n      parser_stack_push_uint8 (context_p, CBC_ASSIGN);\n      parser_stack_push_uint8 (context_p, LEXER_ASSIGN);\n      parser_stack_push_uint8 (context_p, lexer_convert_binary_lvalue_token_to_binary (token));\n      continue;\n    }\n    else if (token == LEXER_LOGICAL_OR || token == LEXER_LOGICAL_AND)\n    {\n      parser_branch_t branch;\n      parser_stack_pop (context_p, &branch, sizeof (parser_branch_t));\n      parser_set_branch_to_current_position (context_p, &branch);\n      continue;\n    }\n    else\n    {\n      opcode = LEXER_BINARY_OP_TOKEN_TO_OPCODE (token);\n\n      if (PARSER_IS_PUSH_NUMBER (context_p->last_cbc_opcode))\n      {\n        lexer_convert_push_number_to_push_literal (context_p);\n      }\n\n      if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)\n      {\n        JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, opcode + CBC_BINARY_WITH_LITERAL));\n        context_p->last_cbc_opcode = (uint16_t) (opcode + CBC_BINARY_WITH_LITERAL);\n        continue;\n      }\n      else if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)\n      {\n        JERRY_ASSERT (CBC_ARGS_EQ (opcode + CBC_BINARY_WITH_TWO_LITERALS,\n                                   CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2));\n        context_p->last_cbc_opcode = (uint16_t) (opcode + CBC_BINARY_WITH_TWO_LITERALS);\n        continue;\n      }\n    }\n    parser_emit_cbc (context_p, (uint16_t) opcode);\n  }\n}",
        "begin_line": 2548,
        "end_line": 2669,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_process_unary_expression#1912",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_process_unary_expression (parser_context_t *context_p, /**< context */                                  size_t grouping_level) /**< grouping level */",
        "snippet": "static void\nparser_process_unary_expression (parser_context_t *context_p, /**< context */\n                                 size_t grouping_level) /**< grouping level */\n{\n  /* Parse postfix part of a primary expression. */\n  while (true)\n  {\n    /* Since break would only break the switch, we use\n     * continue to continue this loop. Without continue,\n     * the code abandons the loop. */\n    switch (context_p->token.type)\n    {\n      case LEXER_DOT:\n      {\n        parser_push_result (context_p);\n\n        lexer_expect_identifier (context_p, LEXER_STRING_LITERAL);\n        JERRY_ASSERT (context_p->token.type == LEXER_LITERAL\n                      && context_p->lit_object.literal_p->type == LEXER_STRING_LITERAL);\n        context_p->token.lit_location.type = LEXER_STRING_LITERAL;\n\n        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)\n        {\n          JERRY_ASSERT (CBC_ARGS_EQ (CBC_PUSH_PROP_LITERAL_LITERAL,\n                                     CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2));\n          context_p->last_cbc_opcode = CBC_PUSH_PROP_LITERAL_LITERAL;\n          context_p->last_cbc.value = context_p->lit_object.index;\n        }\n        else if (context_p->last_cbc_opcode == CBC_PUSH_THIS)\n        {\n          context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n          parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_PROP_THIS_LITERAL);\n        }\n#if ENABLED (JERRY_ES2015)\n        else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER))\n        {\n          context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL);\n          context_p->last_cbc.literal_index = context_p->lit_object.index;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n        else\n        {\n          parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_PROP_LITERAL);\n        }\n        lexer_next_token (context_p);\n        continue;\n      }\n\n      case LEXER_LEFT_SQUARE:\n      {\n        parser_push_result (context_p);\n\n#if ENABLED (JERRY_ES2015)\n        uint16_t last_cbc_opcode = context_p->last_cbc_opcode;\n\n        if (last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER))\n        {\n          context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        lexer_next_token (context_p);\n        parser_parse_expression (context_p, PARSE_EXPR);\n        if (context_p->token.type != LEXER_RIGHT_SQUARE)\n        {\n          parser_raise_error (context_p, PARSER_ERR_RIGHT_SQUARE_EXPECTED);\n        }\n        lexer_next_token (context_p);\n\n#if ENABLED (JERRY_ES2015)\n        if (last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER))\n        {\n          parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SUPER_PROP);\n          continue;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        if (PARSER_IS_MUTABLE_PUSH_LITERAL (context_p->last_cbc_opcode))\n        {\n          context_p->last_cbc_opcode = PARSER_PUSH_LITERAL_TO_PUSH_PROP_LITERAL (context_p->last_cbc_opcode);\n        }\n        else\n        {\n          parser_emit_cbc (context_p, CBC_PUSH_PROP);\n        }\n        continue;\n      }\n\n#if ENABLED (JERRY_ES2015)\n      case LEXER_TEMPLATE_LITERAL:\n#endif /* ENABLED (JERRY_ES2015) */\n      case LEXER_LEFT_PAREN:\n      {\n        size_t call_arguments = 0;\n        uint16_t opcode = CBC_CALL;\n        bool is_eval = false;\n\n        parser_push_result (context_p);\n\n        if (context_p->stack_top_uint8 == LEXER_KEYW_NEW)\n        {\n          parser_stack_pop_uint8 (context_p);\n          opcode = CBC_NEW;\n        }\n        else\n        {\n          if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL\n              && context_p->last_cbc.literal_keyword_type == LEXER_KEYW_EVAL\n              && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)\n          {\n            is_eval = true;\n          }\n\n          if (PARSER_IS_PUSH_PROP (context_p->last_cbc_opcode))\n          {\n            opcode = CBC_CALL_PROP;\n            context_p->last_cbc_opcode = PARSER_PUSH_PROP_TO_PUSH_PROP_REFERENCE (context_p->last_cbc_opcode);\n          }\n#if ENABLED (JERRY_ES2015)\n          else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_CONSTRUCTOR))\n          {\n            opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_CALL);\n          }\n          else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL))\n          {\n            context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_LITERAL_REFERENCE);\n            opcode = CBC_CALL_PROP;\n          }\n          else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP))\n          {\n            context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_REFERENCE);\n            opcode = CBC_CALL_PROP;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n          else if (JERRY_UNLIKELY (context_p->status_flags & PARSER_INSIDE_WITH)\n                   && PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)\n                   && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)\n          {\n            opcode = CBC_CALL_PROP;\n            parser_emit_ident_reference (context_p, CBC_PUSH_IDENT_REFERENCE);\n            parser_emit_cbc_ext (context_p, CBC_EXT_RESOLVE_BASE);\n          }\n        }\n\n#if ENABLED (JERRY_ES2015)\n        bool has_spread_element = false;\n\n        if (context_p->token.type == LEXER_TEMPLATE_LITERAL)\n        {\n          call_arguments = parser_parse_tagged_template_literal (context_p);\n        }\n        else\n        {\n          lexer_next_token (context_p);\n\n          while (context_p->token.type != LEXER_RIGHT_PAREN)\n          {\n            if (++call_arguments > CBC_MAXIMUM_BYTE_VALUE)\n            {\n              parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);\n            }\n\n            if (context_p->token.type == LEXER_THREE_DOTS)\n            {\n              has_spread_element = true;\n              call_arguments++;\n              parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SPREAD_ELEMENT);\n              lexer_next_token (context_p);\n            }\n\n            parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);\n\n            if (context_p->token.type == LEXER_COMMA)\n            {\n              lexer_next_token (context_p);\n              continue;\n            }\n\n            if (context_p->token.type != LEXER_RIGHT_PAREN)\n            {\n              parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);\n            }\n\n            break;\n          }\n        }\n#else /* !ENABLED (JERRY_ES2015) */\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_RIGHT_PAREN)\n        {\n          while (true)\n          {\n            if (++call_arguments > CBC_MAXIMUM_BYTE_VALUE)\n            {\n              parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);\n            }\n\n            parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);\n\n            if (context_p->token.type != LEXER_COMMA)\n            {\n              break;\n            }\n            lexer_next_token (context_p);\n          }\n\n          if (context_p->token.type != LEXER_RIGHT_PAREN)\n          {\n            parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);\n          }\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        lexer_next_token (context_p);\n\n        if (is_eval)\n        {\n          context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;\n\n#if ENABLED (JERRY_ES2015)\n          if (context_p->status_flags & PARSER_FUNCTION_IS_PARSING_ARGS)\n          {\n            context_p->status_flags |= PARSER_LEXICAL_BLOCK_NEEDED;\n          }\n\n          if (context_p->status_flags & (PARSER_ALLOW_SUPER_CALL | PARSER_ALLOW_SUPER | PARSER_ALLOW_NEW_TARGET))\n          {\n            parser_emit_cbc_ext_call (context_p,\n                                      CBC_EXT_LOCAL_EVAL,\n                                      PARSER_SAVE_STATUS_FLAGS (context_p->status_flags));\n          }\n          else\n          {\n#endif /* ENABLED (JERRY_ES2015) */\n            parser_emit_cbc (context_p, CBC_EVAL);\n#if ENABLED (JERRY_ES2015)\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n        }\n\n#if ENABLED (JERRY_ES2015)\n        if (has_spread_element)\n        {\n          uint16_t spread_opcode;\n\n          if (opcode == CBC_CALL)\n          {\n            spread_opcode = CBC_EXT_SPREAD_CALL;\n          }\n          else if (opcode == CBC_CALL_PROP)\n          {\n            spread_opcode = CBC_EXT_SPREAD_CALL_PROP;\n          }\n          else if (opcode == CBC_NEW)\n          {\n            spread_opcode = CBC_EXT_SPREAD_NEW;\n          }\n          else\n          {\n            /* opcode is unchanged */\n            JERRY_ASSERT (opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_CALL));\n            spread_opcode = CBC_EXT_SPREAD_SUPER_CALL;\n          }\n\n          parser_emit_cbc_ext_call (context_p, spread_opcode, call_arguments);\n          continue;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        if (call_arguments <= 1)\n        {\n          if (opcode == CBC_CALL)\n          {\n            parser_emit_cbc (context_p, (uint16_t) (CBC_CALL0 + (call_arguments * 6)));\n            continue;\n          }\n          if (opcode == CBC_CALL_PROP)\n          {\n            parser_emit_cbc (context_p, (uint16_t) (CBC_CALL0_PROP + (call_arguments * 6)));\n            continue;\n          }\n          if (opcode == CBC_NEW)\n          {\n            parser_emit_cbc (context_p, (uint16_t) (CBC_NEW0 + call_arguments));\n            continue;\n          }\n        }\n\n        if (call_arguments == 2)\n        {\n          if (opcode == CBC_CALL)\n          {\n            parser_emit_cbc (context_p, CBC_CALL2);\n            continue;\n          }\n          if (opcode == CBC_CALL_PROP)\n          {\n            parser_flush_cbc (context_p);\n            /* Manually adjusting stack usage. */\n            JERRY_ASSERT (context_p->stack_depth > 0);\n            context_p->stack_depth--;\n            parser_emit_cbc (context_p, CBC_CALL2_PROP);\n            continue;\n          }\n        }\n\n        parser_emit_cbc_call (context_p, opcode, call_arguments);\n        continue;\n      }\n\n      default:\n      {\n        if (context_p->stack_top_uint8 == LEXER_KEYW_NEW)\n        {\n          parser_push_result (context_p);\n          parser_emit_cbc (context_p, CBC_NEW0);\n          parser_stack_pop_uint8 (context_p);\n          continue;\n        }\n\n        if (!(context_p->token.flags & LEXER_WAS_NEWLINE)\n            && (context_p->token.type == LEXER_INCREASE || context_p->token.type == LEXER_DECREASE)\n            && grouping_level != PARSE_EXPR_LEFT_HAND_SIDE)\n        {\n          cbc_opcode_t opcode = (context_p->token.type == LEXER_INCREASE) ? CBC_POST_INCR : CBC_POST_DECR;\n          parser_push_result (context_p);\n          parser_emit_unary_lvalue_opcode (context_p, opcode);\n          lexer_next_token (context_p);\n        }\n        break;\n      }\n    }\n    break;\n  }\n\n#if ENABLED (JERRY_ES2015)\n  uint8_t last_unary_token = LEXER_INCREASE;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  /* Generate byte code for the unary operators. */\n  while (true)\n  {\n    uint8_t token = context_p->stack_top_uint8;\n    if (!LEXER_IS_UNARY_OP_TOKEN (token))\n    {\n#if ENABLED (JERRY_ES2015)\n      if (context_p->token.type == LEXER_EXPONENTIATION\n          && last_unary_token != LEXER_INCREASE\n          && last_unary_token != LEXER_DECREASE)\n      {\n        parser_raise_error (context_p, PARSER_ERR_INVALID_EXPONENTIATION);\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      break;\n    }\n\n#if ENABLED (JERRY_ES2015)\n    last_unary_token = token;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    parser_push_result (context_p);\n    parser_stack_pop_uint8 (context_p);\n\n    if (LEXER_IS_UNARY_LVALUE_OP_TOKEN (token))\n    {\n      if (token == LEXER_KEYW_DELETE)\n      {\n        token = CBC_DELETE_PUSH_RESULT;\n      }\n      else\n      {\n        token = (uint8_t) (LEXER_UNARY_LVALUE_OP_TOKEN_TO_OPCODE (token));\n      }\n      parser_emit_unary_lvalue_opcode (context_p, (cbc_opcode_t) token);\n    }\n#if ENABLED (JERRY_ES2015)\n    else if (JERRY_UNLIKELY (token == LEXER_KEYW_AWAIT))\n    {\n      parser_emit_cbc_ext (context_p, CBC_EXT_AWAIT);\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    else\n    {\n      token = (uint8_t) (LEXER_UNARY_OP_TOKEN_TO_OPCODE (token));\n\n      if (token == CBC_TYPEOF)\n      {\n        if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)\n            && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)\n        {\n          parser_emit_ident_reference (context_p, CBC_TYPEOF_IDENT);\n        }\n        else\n        {\n          parser_emit_cbc (context_p, token);\n        }\n      }\n      else\n      {\n        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)\n        {\n          /* It is not worth to combine with push multiple literals\n           * since the byte code size will not decrease. */\n          JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, token + 1));\n          context_p->last_cbc_opcode = (uint16_t) (token + 1);\n        }\n        else\n        {\n          parser_emit_cbc (context_p, token);\n        }\n      }\n    }\n  }\n}",
        "begin_line": 1912,
        "end_line": 2326,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_push_result#86",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_push_result (parser_context_t *context_p) /**< context */",
        "snippet": "static inline void\nparser_push_result (parser_context_t *context_p) /**< context */\n{\n  if (CBC_NO_RESULT_OPERATION (context_p->last_cbc_opcode))\n  {\n    JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, context_p->last_cbc_opcode + 1));\n\n    if ((context_p->last_cbc_opcode == CBC_POST_INCR\n         || context_p->last_cbc_opcode == CBC_POST_DECR)\n        && context_p->stack_depth >= context_p->stack_limit)\n    {\n      /* Stack limit is increased for CBC_POST_INCR_PUSH_RESULT\n       * and CBC_POST_DECR_PUSH_RESULT opcodes. Needed by vm.c. */\n      JERRY_ASSERT (context_p->stack_depth == context_p->stack_limit);\n\n      context_p->stack_limit++;\n\n      if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)\n      {\n        parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);\n      }\n    }\n\n    context_p->last_cbc_opcode++;\n    parser_flush_cbc (context_p);\n  }\n}",
        "begin_line": 86,
        "end_line": 112,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_cbc_stream_alloc_page#166",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_cbc_stream_alloc_page (parser_context_t *context_p, /**< context */                               parser_mem_data_t *data_p) /**< memory manager */",
        "snippet": "void\nparser_cbc_stream_alloc_page (parser_context_t *context_p, /**< context */\n                              parser_mem_data_t *data_p) /**< memory manager */\n{\n  size_t size = sizeof (parser_mem_page_t *) + PARSER_CBC_STREAM_PAGE_SIZE;\n  parser_mem_page_t *page_p = (parser_mem_page_t *) parser_malloc (context_p, size);\n\n  page_p->next_p = NULL;\n  data_p->last_position = 0;\n\n  if (data_p->last_p != NULL)\n  {\n    data_p->last_p->next_p = page_p;\n  }\n  else\n  {\n    data_p->first_p = page_p;\n  }\n  data_p->last_p = page_p;\n}",
        "begin_line": 166,
        "end_line": 185,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_cbc_stream_free#156",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_cbc_stream_free (parser_mem_data_t *data_p) /**< memory manager */",
        "snippet": "void\nparser_cbc_stream_free (parser_mem_data_t *data_p) /**< memory manager */\n{\n  parser_data_free (data_p,\n                    sizeof (parser_mem_page_t *) + PARSER_CBC_STREAM_PAGE_SIZE);\n}",
        "begin_line": 156,
        "end_line": 161,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_cbc_stream_init#147",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_cbc_stream_init (parser_mem_data_t *data_p) /**< memory manager */",
        "snippet": "void\nparser_cbc_stream_init (parser_mem_data_t *data_p) /**< memory manager */\n{\n  parser_data_init (data_p, PARSER_CBC_STREAM_PAGE_SIZE);\n}",
        "begin_line": 147,
        "end_line": 151,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_data_free#125",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_data_free (parser_mem_data_t *data_p, /**< memory manager */                   uint32_t page_size) /**< size of each page */",
        "snippet": "static void\nparser_data_free (parser_mem_data_t *data_p, /**< memory manager */\n                  uint32_t page_size) /**< size of each page */\n{\n  parser_mem_page_t *page_p = data_p->first_p;\n\n  while (page_p != NULL)\n  {\n    parser_mem_page_t *next_p = page_p->next_p;\n\n    parser_free (page_p, page_size);\n    page_p = next_p;\n  }\n}",
        "begin_line": 125,
        "end_line": 138,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_data_init#113",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_data_init (parser_mem_data_t *data_p, /**< memory manager */                   uint32_t page_size) /**< size of each page */",
        "snippet": "static void\nparser_data_init (parser_mem_data_t *data_p, /**< memory manager */\n                  uint32_t page_size) /**< size of each page */\n{\n  data_p->first_p = NULL;\n  data_p->last_p = NULL;\n  data_p->last_position = page_size;\n}",
        "begin_line": 113,
        "end_line": 120,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_free#55",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_free (void *ptr, /**< pointer to free */              size_t size) /**< size of the memory block */",
        "snippet": "inline void JERRY_ATTR_ALWAYS_INLINE\nparser_free (void *ptr, /**< pointer to free */\n             size_t size) /**< size of the memory block */\n{\n  jmem_heap_free_block (ptr, size);\n}",
        "begin_line": 55,
        "end_line": 60,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_free_allocated_buffer#95",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_free_allocated_buffer (parser_context_t *context_p) /**< context */",
        "snippet": "inline void JERRY_ATTR_ALWAYS_INLINE\nparser_free_allocated_buffer (parser_context_t *context_p) /**< context */\n{\n  if (context_p->u.allocated_buffer_p != NULL)\n  {\n    parser_free_local (context_p->u.allocated_buffer_p,\n                       context_p->allocated_buffer_size);\n    context_p->u.allocated_buffer_p = NULL;\n  }\n}",
        "begin_line": 95,
        "end_line": 104,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_list_append#231",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_list_append (parser_context_t *context_p, /**< context */                     parser_list_t *list_p) /**< parser list */",
        "snippet": "void *\nparser_list_append (parser_context_t *context_p, /**< context */\n                    parser_list_t *list_p) /**< parser list */\n{\n  parser_mem_page_t *page_p = list_p->data.last_p;\n  void *result;\n\n  if (list_p->data.last_position + list_p->item_size > list_p->page_size)\n  {\n    size_t size = sizeof (parser_mem_page_t *) + list_p->page_size;\n\n    page_p = (parser_mem_page_t *) parser_malloc (context_p, size);\n\n    page_p->next_p = NULL;\n    list_p->data.last_position = 0;\n\n    if (list_p->data.last_p != NULL)\n    {\n      list_p->data.last_p->next_p = page_p;\n    }\n    else\n    {\n      list_p->data.first_p = page_p;\n    }\n    list_p->data.last_p = page_p;\n  }\n\n  result = page_p->bytes + list_p->data.last_position;\n  list_p->data.last_position += list_p->item_size;\n  return result;\n}",
        "begin_line": 231,
        "end_line": 261,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_list_free#210",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_list_free (parser_list_t *list_p) /**< parser list */",
        "snippet": "void\nparser_list_free (parser_list_t *list_p) /**< parser list */\n{\n  parser_data_free (&list_p->data,\n                    (uint32_t) (sizeof (parser_mem_page_t *) + list_p->page_size));\n}",
        "begin_line": 210,
        "end_line": 215,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_list_get#268",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_list_get (parser_list_t *list_p, /**< parser list */                  size_t index) /**< item index */",
        "snippet": "void *\nparser_list_get (parser_list_t *list_p, /**< parser list */\n                 size_t index) /**< item index */\n{\n  size_t item_count = list_p->item_count;\n  parser_mem_page_t *page_p = list_p->data.first_p;\n\n  while (index >= item_count)\n  {\n    JERRY_ASSERT (page_p != NULL);\n    page_p = page_p->next_p;\n    index -= item_count;\n  }\n\n  JERRY_ASSERT (page_p != NULL);\n  JERRY_ASSERT (page_p != list_p->data.last_p\n                || (index * list_p->item_size < list_p->data.last_position));\n  return page_p->bytes + (index * list_p->item_size);\n}",
        "begin_line": 268,
        "end_line": 286,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_list_init#194",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_list_init (parser_list_t *list_p, /**< parser list */                   uint32_t item_size, /**< size for each page */                   uint32_t item_count) /**< number of items on each page */",
        "snippet": "void\nparser_list_init (parser_list_t *list_p, /**< parser list */\n                  uint32_t item_size, /**< size for each page */\n                  uint32_t item_count) /**< number of items on each page */\n{\n  /* Align to pointer size. */\n  item_size = (uint32_t) (((item_size) + sizeof (void *) - 1) & ~(sizeof (void *) - 1));\n  parser_data_init (&list_p->data, item_size * item_count);\n  list_p->page_size = item_size * item_count;\n  list_p->item_size = item_size;\n  list_p->item_count = item_count;\n}",
        "begin_line": 194,
        "end_line": 205,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_list_iterator_init#291",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_list_iterator_init (parser_list_t *list_p, /**< parser list */                            parser_list_iterator_t *iterator_p) /**< iterator */",
        "snippet": "void\nparser_list_iterator_init (parser_list_t *list_p, /**< parser list */\n                           parser_list_iterator_t *iterator_p) /**< iterator */\n{\n  iterator_p->list_p = list_p;\n  iterator_p->current_p = list_p->data.first_p;\n  iterator_p->current_position = 0;\n}",
        "begin_line": 291,
        "end_line": 298,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_list_iterator_next#305",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_list_iterator_next (parser_list_iterator_t *iterator_p) /**< iterator */",
        "snippet": "void *\nparser_list_iterator_next (parser_list_iterator_t *iterator_p) /**< iterator */\n{\n  void *result;\n\n  if (iterator_p->current_p == NULL)\n  {\n    return NULL;\n  }\n\n  result = iterator_p->current_p->bytes + iterator_p->current_position;\n  iterator_p->current_position += iterator_p->list_p->item_size;\n\n  if (iterator_p->current_p->next_p == NULL)\n  {\n    if (iterator_p->current_position >= iterator_p->list_p->data.last_position)\n    {\n      iterator_p->current_p = NULL;\n      iterator_p->current_position = 0;\n    }\n  }\n  else if (iterator_p->current_position >= iterator_p->list_p->page_size)\n  {\n    iterator_p->current_p = iterator_p->current_p->next_p;\n    iterator_p->current_position = 0;\n  }\n  return result;\n}",
        "begin_line": 305,
        "end_line": 332,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_list_reset#220",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_list_reset (parser_list_t *list_p) /**< parser list */",
        "snippet": "void\nparser_list_reset (parser_list_t *list_p) /**< parser list */\n{\n  parser_data_init (&list_p->data, list_p->page_size);\n}",
        "begin_line": 220,
        "end_line": 224,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_malloc#36",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_malloc (parser_context_t *context_p, /**< context */                size_t size) /**< size of the memory block */",
        "snippet": "void *\nparser_malloc (parser_context_t *context_p, /**< context */\n               size_t size) /**< size of the memory block */\n{\n  void *result;\n\n  JERRY_ASSERT (size > 0);\n  result = jmem_heap_alloc_block_null_on_error (size);\n\n  if (result == NULL)\n  {\n    parser_raise_error (context_p, PARSER_ERR_OUT_OF_MEMORY);\n  }\n  return result;\n}",
        "begin_line": 36,
        "end_line": 50,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_stack_free#353",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_stack_free (parser_context_t *context_p) /**< context */",
        "snippet": "void\nparser_stack_free (parser_context_t *context_p) /**< context */\n{\n  parser_data_free (&context_p->stack,\n                    sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE);\n\n  if (context_p->free_page_p != NULL)\n  {\n    parser_free (context_p->free_page_p,\n                 sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE);\n  }\n}",
        "begin_line": 353,
        "end_line": 364,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_stack_init#343",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_stack_init (parser_context_t *context_p) /**< context */",
        "snippet": "void\nparser_stack_init (parser_context_t *context_p) /**< context */\n{\n  parser_data_init (&context_p->stack, PARSER_STACK_PAGE_SIZE);\n  context_p->free_page_p = NULL;\n}",
        "begin_line": 343,
        "end_line": 348,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_stack_iterator_read#631",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_stack_iterator_read (parser_stack_iterator_t *iterator, /**< iterator */                             void *data_p, /**< destination buffer */                             size_t length) /**< length of the data */",
        "snippet": "void\nparser_stack_iterator_read (parser_stack_iterator_t *iterator, /**< iterator */\n                            void *data_p, /**< destination buffer */\n                            size_t length) /**< length of the data */\n{\n  uint8_t *bytes_p = (uint8_t *) data_p;\n\n  JERRY_ASSERT (length < PARSER_STACK_PAGE_SIZE && length > 0);\n\n  if (length <= iterator->current_position)\n  {\n    memcpy (bytes_p,\n            iterator->current_p->bytes + iterator->current_position - length,\n            length);\n  }\n  else\n  {\n    JERRY_ASSERT (iterator->current_p->next_p != NULL);\n\n    length -= iterator->current_position;\n    memcpy (bytes_p + length,\n            iterator->current_p->bytes,\n            iterator->current_position);\n    memcpy (bytes_p,\n            iterator->current_p->next_p->bytes + PARSER_STACK_PAGE_SIZE - length,\n            length);\n  }\n}",
        "begin_line": 631,
        "end_line": 658,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_stack_iterator_skip#611",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_stack_iterator_skip (parser_stack_iterator_t *iterator, /**< iterator */                             size_t length) /**< number of skipped bytes */",
        "snippet": "void\nparser_stack_iterator_skip (parser_stack_iterator_t *iterator, /**< iterator */\n                            size_t length) /**< number of skipped bytes */\n{\n  JERRY_ASSERT (length < PARSER_STACK_PAGE_SIZE && length > 0);\n\n  if (length < iterator->current_position)\n  {\n    iterator->current_position -= length;\n  }\n  else\n  {\n    iterator->current_position = PARSER_STACK_PAGE_SIZE - (length - iterator->current_position);\n    iterator->current_p = iterator->current_p->next_p;\n  }\n}",
        "begin_line": 611,
        "end_line": 626,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_stack_pop#555",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_stack_pop (parser_context_t *context_p, /**< context */                   void *data_p, /**< destination buffer, can be NULL */                   uint32_t length) /**< length of the data */",
        "snippet": "void\nparser_stack_pop (parser_context_t *context_p, /**< context */\n                  void *data_p, /**< destination buffer, can be NULL */\n                  uint32_t length) /**< length of the data */\n{\n  uint8_t *bytes_p = (uint8_t *) data_p;\n  parser_mem_page_t *page_p = context_p->stack.first_p;\n\n  JERRY_ASSERT (length < PARSER_STACK_PAGE_SIZE && length > 0);\n\n  if (context_p->stack.last_position > length)\n  {\n    context_p->stack.last_position -= length;\n    context_p->stack_top_uint8 = page_p->bytes[context_p->stack.last_position - 1];\n\n    if (bytes_p != NULL)\n    {\n      memcpy (bytes_p, context_p->stack.first_p->bytes + context_p->stack.last_position, length);\n    }\n    return;\n  }\n\n  JERRY_ASSERT (page_p->next_p != NULL);\n\n  length -= context_p->stack.last_position;\n\n  if (bytes_p != NULL)\n  {\n    memcpy (bytes_p + length, page_p->bytes, context_p->stack.last_position);\n  }\n\n  context_p->stack.first_p = page_p->next_p;\n  context_p->stack.last_position = PARSER_STACK_PAGE_SIZE - length;\n  context_p->stack_top_uint8 = page_p->next_p->bytes[context_p->stack.last_position - 1];\n\n  if (bytes_p != NULL && length > 0)\n  {\n    memcpy (bytes_p, page_p->next_p->bytes + context_p->stack.last_position, length);\n  }\n\n  JERRY_ASSERT (context_p->stack.last_position > 0);\n\n  if (context_p->free_page_p == NULL)\n  {\n    context_p->free_page_p = page_p;\n  }\n  else\n  {\n    parser_free (page_p,\n                 sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE);\n  }\n}",
        "begin_line": 555,
        "end_line": 606,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_stack_pop_uint16#469",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_stack_pop_uint16 (parser_context_t *context_p) /**< context */",
        "snippet": "uint16_t\nparser_stack_pop_uint16 (parser_context_t *context_p) /**< context */\n{\n  uint32_t value = context_p->stack_top_uint8;\n\n  if (context_p->stack.last_position >= 3)\n  {\n    parser_mem_page_t *page_p = context_p->stack.first_p;\n\n    JERRY_ASSERT (page_p != NULL\n                  && context_p->stack_top_uint8 == page_p->bytes[context_p->stack.last_position - 1]);\n\n    value |= ((uint32_t) page_p->bytes[context_p->stack.last_position - 2]) << 8;\n    context_p->stack_top_uint8 = page_p->bytes[context_p->stack.last_position - 3];\n    context_p->stack.last_position -= 2;\n  }\n  else\n  {\n    parser_stack_pop_uint8 (context_p);\n    value |= ((uint32_t) context_p->stack_top_uint8) << 8;\n    parser_stack_pop_uint8 (context_p);\n  }\n  return (uint16_t) value;\n}",
        "begin_line": 469,
        "end_line": 492,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_stack_pop_uint8#406",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_stack_pop_uint8 (parser_context_t *context_p) /**< context */",
        "snippet": "void\nparser_stack_pop_uint8 (parser_context_t *context_p) /**< context */\n{\n  parser_mem_page_t *page_p = context_p->stack.first_p;\n\n  JERRY_ASSERT (page_p != NULL\n                && context_p->stack_top_uint8 == page_p->bytes[context_p->stack.last_position - 1]);\n\n  context_p->stack.last_position--;\n\n  if (context_p->stack.last_position == 0)\n  {\n    context_p->stack.first_p = page_p->next_p;\n    context_p->stack.last_position = PARSER_STACK_PAGE_SIZE;\n\n    if (context_p->free_page_p == NULL)\n    {\n      context_p->free_page_p = page_p;\n    }\n    else\n    {\n      parser_free (page_p,\n                   sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE);\n    }\n\n    page_p = context_p->stack.first_p;\n\n    JERRY_ASSERT (page_p != NULL);\n  }\n\n  context_p->stack_top_uint8 = page_p->bytes[context_p->stack.last_position - 1];\n}",
        "begin_line": 406,
        "end_line": 437,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_stack_push#497",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_stack_push (parser_context_t *context_p, /**< context */                    const void *data_p, /**< data pushed onto the stack */                    uint32_t length) /**< length of the data */",
        "snippet": "void\nparser_stack_push (parser_context_t *context_p, /**< context */\n                   const void *data_p, /**< data pushed onto the stack */\n                   uint32_t length) /**< length of the data */\n{\n  uint32_t fragment_length = PARSER_STACK_PAGE_SIZE - context_p->stack.last_position;\n  const uint8_t *bytes_p = (const uint8_t *) data_p;\n  parser_mem_page_t *page_p;\n\n  JERRY_ASSERT (length < PARSER_STACK_PAGE_SIZE && length > 0);\n\n  context_p->stack_top_uint8 = bytes_p[length - 1];\n\n  if (fragment_length > 0)\n  {\n    /* Fill the remaining bytes. */\n    if (fragment_length > length)\n    {\n      fragment_length = length;\n    }\n\n    memcpy (context_p->stack.first_p->bytes + context_p->stack.last_position,\n            bytes_p,\n            fragment_length);\n\n    if (fragment_length == length)\n    {\n      context_p->stack.last_position += length;\n      return;\n    }\n\n    bytes_p += fragment_length;\n    length -= fragment_length;\n  }\n\n  if (context_p->free_page_p != NULL)\n  {\n    page_p = context_p->free_page_p;\n    context_p->free_page_p = NULL;\n  }\n  else\n  {\n    size_t size = sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE;\n\n    page_p = (parser_mem_page_t *) parser_malloc (context_p, size);\n  }\n\n  page_p->next_p = context_p->stack.first_p;\n\n  context_p->stack.first_p = page_p;\n\n  memcpy (page_p->bytes, bytes_p, length);\n  context_p->stack.last_position = length;\n}",
        "begin_line": 497,
        "end_line": 550,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_stack_push_uint16#442",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_stack_push_uint16 (parser_context_t *context_p, /**< context */                           uint16_t uint16_value) /**< value pushed onto the stack */",
        "snippet": "void\nparser_stack_push_uint16 (parser_context_t *context_p, /**< context */\n                          uint16_t uint16_value) /**< value pushed onto the stack */\n{\n  if (context_p->stack.last_position + 2 <= PARSER_STACK_PAGE_SIZE)\n  {\n    parser_mem_page_t *page_p = context_p->stack.first_p;\n\n    JERRY_ASSERT (page_p != NULL\n                  && context_p->stack_top_uint8 == page_p->bytes[context_p->stack.last_position - 1]);\n\n    page_p->bytes[context_p->stack.last_position++] = (uint8_t) (uint16_value >> 8);\n    page_p->bytes[context_p->stack.last_position++] = (uint8_t) uint16_value;\n    context_p->stack_top_uint8 = (uint8_t) uint16_value;\n  }\n  else\n  {\n    parser_stack_push_uint8 (context_p, (uint8_t) (uint16_value >> 8));\n    parser_stack_push_uint8 (context_p, (uint8_t) uint16_value);\n  }\n}",
        "begin_line": 442,
        "end_line": 462,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_stack_push_uint8#369",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_stack_push_uint8 (parser_context_t *context_p, /**< context */                          uint8_t uint8_value) /**< value pushed onto the stack */",
        "snippet": "void\nparser_stack_push_uint8 (parser_context_t *context_p, /**< context */\n                         uint8_t uint8_value) /**< value pushed onto the stack */\n{\n  parser_mem_page_t *page_p = context_p->stack.first_p;\n\n  /* This assert might trigger false positive valgrind errors, when\n   * parser_stack_push() pushes not fully initialized structures.\n   * More precisely when the last byte of the structure is uninitialized. */\n  JERRY_ASSERT (page_p == NULL\n                || context_p->stack_top_uint8 == page_p->bytes[context_p->stack.last_position - 1]);\n\n  if (context_p->stack.last_position >= PARSER_STACK_PAGE_SIZE)\n  {\n    if (context_p->free_page_p != NULL)\n    {\n      page_p = context_p->free_page_p;\n      context_p->free_page_p = NULL;\n    }\n    else\n    {\n      size_t size = sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE;\n      page_p = (parser_mem_page_t *) parser_malloc (context_p, size);\n    }\n\n    page_p->next_p = context_p->stack.first_p;\n    context_p->stack.last_position = 0;\n    context_p->stack.first_p = page_p;\n  }\n\n  page_p->bytes[context_p->stack.last_position++] = uint8_value;\n  context_p->stack_top_uint8 = uint8_value;\n}",
        "begin_line": 369,
        "end_line": 401,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-statm.parser_free_jumps#3354",
        "src_path": "jerry-core/parser/js/js-parser-statm.c",
        "class_name": "jerry-core.parser.js.js-parser-statm",
        "signature": "jerry-core.parser.js.js-parser-statm.parser_free_jumps (parser_stack_iterator_t iterator) /**< iterator position */",
        "snippet": "void JERRY_ATTR_NOINLINE\nparser_free_jumps (parser_stack_iterator_t iterator) /**< iterator position */\n{\n  while (true)\n  {\n    uint8_t type = parser_stack_iterator_read_uint8 (&iterator);\n    parser_branch_node_t *branch_list_p = NULL;\n\n    switch (type)\n    {\n      case PARSER_STATEMENT_START:\n      {\n        return;\n      }\n\n      case PARSER_STATEMENT_LABEL:\n      {\n        parser_label_statement_t label;\n\n        parser_stack_iterator_skip (&iterator, 1);\n        parser_stack_iterator_read (&iterator, &label, sizeof (parser_label_statement_t));\n        parser_stack_iterator_skip (&iterator, sizeof (parser_label_statement_t));\n        branch_list_p = label.break_list_p;\n        break;\n      }\n\n      case PARSER_STATEMENT_SWITCH:\n      case PARSER_STATEMENT_SWITCH_NO_DEFAULT:\n      {\n        parser_switch_statement_t switch_statement;\n        parser_loop_statement_t loop;\n\n        parser_stack_iterator_skip (&iterator, 1);\n        parser_stack_iterator_read (&iterator, &loop, sizeof (parser_loop_statement_t));\n        parser_stack_iterator_skip (&iterator, sizeof (parser_loop_statement_t));\n        parser_stack_iterator_read (&iterator, &switch_statement, sizeof (parser_switch_statement_t));\n        parser_stack_iterator_skip (&iterator, sizeof (parser_switch_statement_t));\n\n        branch_list_p = switch_statement.branch_list_p;\n        while (branch_list_p != NULL)\n        {\n          parser_branch_node_t *next_p = branch_list_p->next_p;\n          parser_free (branch_list_p, sizeof (parser_branch_node_t));\n          branch_list_p = next_p;\n        }\n        branch_list_p = loop.branch_list_p;\n        break;\n      }\n\n      case PARSER_STATEMENT_DO_WHILE:\n      case PARSER_STATEMENT_WHILE:\n      case PARSER_STATEMENT_FOR:\n      case PARSER_STATEMENT_FOR_IN:\n#if ENABLED (JERRY_ES2015)\n      case PARSER_STATEMENT_FOR_OF:\n#endif /* ENABLED (JERRY_ES2015) */\n      {\n        parser_loop_statement_t loop;\n\n        parser_stack_iterator_skip (&iterator, 1);\n        parser_stack_iterator_read (&iterator, &loop, sizeof (parser_loop_statement_t));\n        parser_stack_iterator_skip (&iterator, parser_statement_length (type) - 1);\n        branch_list_p = loop.branch_list_p;\n        break;\n      }\n\n      default:\n      {\n        parser_stack_iterator_skip (&iterator, parser_statement_length (type));\n        continue;\n      }\n    }\n\n    while (branch_list_p != NULL)\n    {\n      parser_branch_node_t *next_p = branch_list_p->next_p;\n      parser_free (branch_list_p, sizeof (parser_branch_node_t));\n      branch_list_p = next_p;\n    }\n  }\n}",
        "begin_line": 3354,
        "end_line": 3434,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-statm.parser_parse_do_while_statement_end#962",
        "src_path": "jerry-core/parser/js/js-parser-statm.c",
        "class_name": "jerry-core.parser.js.js-parser-statm",
        "signature": "jerry-core.parser.js.js-parser-statm.parser_parse_do_while_statement_end (parser_context_t *context_p) /**< context */",
        "snippet": "static void\nparser_parse_do_while_statement_end (parser_context_t *context_p) /**< context */\n{\n  parser_loop_statement_t loop;\n\n  JERRY_ASSERT (context_p->stack_top_uint8 == PARSER_STATEMENT_DO_WHILE);\n\n  if (context_p->token.type != LEXER_KEYW_WHILE)\n  {\n    parser_raise_error (context_p, PARSER_ERR_WHILE_EXPECTED);\n  }\n\n  parser_stack_iterator_t iterator;\n  parser_stack_iterator_init (context_p, &iterator);\n\n  parser_stack_iterator_skip (&iterator, 1);\n  parser_stack_iterator_read (&iterator, &loop, sizeof (parser_loop_statement_t));\n\n  parser_set_continues_to_current_position (context_p, loop.branch_list_p);\n\n  JERRY_ASSERT (context_p->next_scanner_info_p->source_p != context_p->source_p);\n\n  parser_parse_enclosed_expr (context_p);\n\n  if (context_p->last_cbc_opcode != CBC_PUSH_FALSE)\n  {\n    cbc_opcode_t opcode = CBC_BRANCH_IF_TRUE_BACKWARD;\n    if (context_p->last_cbc_opcode == CBC_LOGICAL_NOT)\n    {\n      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n      opcode = CBC_BRANCH_IF_FALSE_BACKWARD;\n    }\n    else if (context_p->last_cbc_opcode == CBC_PUSH_TRUE)\n    {\n      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n      opcode = CBC_JUMP_BACKWARD;\n    }\n\n    parser_do_while_statement_t do_while_statement;\n    parser_stack_iterator_skip (&iterator, sizeof (parser_loop_statement_t));\n    parser_stack_iterator_read (&iterator, &do_while_statement, sizeof (parser_do_while_statement_t));\n\n    parser_emit_cbc_backward_branch (context_p, (uint16_t) opcode, do_while_statement.start_offset);\n  }\n  else\n  {\n    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n  }\n\n  parser_stack_pop (context_p, NULL, 1 + sizeof (parser_loop_statement_t) + sizeof (parser_do_while_statement_t));\n  parser_stack_iterator_init (context_p, &context_p->last_statement);\n\n  parser_set_breaks_to_current_position (context_p, loop.branch_list_p);\n}",
        "begin_line": 962,
        "end_line": 1015,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-statm.parser_parse_enclosed_expr#348",
        "src_path": "jerry-core/parser/js/js-parser-statm.c",
        "class_name": "jerry-core.parser.js.js-parser-statm",
        "signature": "jerry-core.parser.js.js-parser-statm.parser_parse_enclosed_expr (parser_context_t *context_p) /**< context */",
        "snippet": "static inline void\nparser_parse_enclosed_expr (parser_context_t *context_p) /**< context */\n{\n  lexer_next_token (context_p);\n\n  if (context_p->token.type != LEXER_LEFT_PAREN)\n  {\n    parser_raise_error (context_p, PARSER_ERR_LEFT_PAREN_EXPECTED);\n  }\n\n  lexer_next_token (context_p);\n  parser_parse_expression (context_p, PARSE_EXPR);\n\n  if (context_p->token.type != LEXER_RIGHT_PAREN)\n  {\n    parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);\n  }\n  lexer_next_token (context_p);\n}",
        "begin_line": 348,
        "end_line": 366,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-statm.parser_parse_function_statement#629",
        "src_path": "jerry-core/parser/js/js-parser-statm.c",
        "class_name": "jerry-core.parser.js.js-parser-statm",
        "signature": "jerry-core.parser.js.js-parser-statm.parser_parse_function_statement (parser_context_t *context_p) /**< context */",
        "snippet": "static void\nparser_parse_function_statement (parser_context_t *context_p) /**< context */\n{\n  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_FUNCTION);\n\n#if ENABLED (JERRY_ES2015)\n  if (JERRY_UNLIKELY (parser_statement_flags[context_p->stack_top_uint8] & PARSER_STATM_SINGLE_STATM))\n  {\n    if (context_p->status_flags & PARSER_IS_STRICT)\n    {\n      parser_raise_error (context_p, PARSER_ERR_LEXICAL_SINGLE_STATEMENT);\n    }\n\n    if (context_p->stack_top_uint8 == PARSER_STATEMENT_IF\n        || context_p->stack_top_uint8 == PARSER_STATEMENT_ELSE)\n    {\n      /* There must be a parser error later if this check fails. */\n      if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n      {\n        parser_push_block_context (context_p, true);\n      }\n    }\n    else if (context_p->stack_top_uint8 == PARSER_STATEMENT_LABEL)\n    {\n      parser_stack_iterator_t iterator;\n      parser_stack_iterator_init (context_p, &iterator);\n      parser_stack_iterator_skip (&iterator, sizeof (parser_label_statement_t) + 1);\n\n      while (true)\n      {\n        uint8_t type = parser_stack_iterator_read_uint8 (&iterator);\n\n        if (type == PARSER_STATEMENT_LABEL)\n        {\n          parser_stack_iterator_skip (&iterator, sizeof (parser_label_statement_t) + 1);\n          continue;\n        }\n\n        if (parser_statement_flags[type] & PARSER_STATM_HAS_BLOCK)\n        {\n          break;\n        }\n\n        parser_raise_error (context_p, PARSER_ERR_LABELLED_FUNC_NOT_IN_BLOCK);\n      }\n    }\n    else\n    {\n      parser_raise_error (context_p, PARSER_ERR_LEXICAL_SINGLE_STATEMENT);\n    }\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_DEBUGGER)\n  parser_line_counter_t debugger_line = context_p->token.line;\n  parser_line_counter_t debugger_column = context_p->token.column;\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n#if ENABLED (JERRY_ES2015)\n  bool is_generator_function = false;\n\n  if (lexer_consume_generator (context_p))\n  {\n    is_generator_function = true;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  lexer_expect_identifier (context_p, LEXER_NEW_IDENT_LITERAL);\n  JERRY_ASSERT (context_p->token.type == LEXER_LITERAL\n                && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);\n\n#if ENABLED (JERRY_ES2015)\n  if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n  {\n    JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED);\n    parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n  parser_module_append_export_name (context_p);\n  context_p->status_flags &= (uint32_t) ~(PARSER_MODULE_STORE_IDENT);\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n  uint32_t status_flags = PARSER_FUNCTION_CLOSURE;\n\n  if (context_p->token.keyword_type >= LEXER_FIRST_NON_STRICT_ARGUMENTS)\n  {\n    status_flags |= PARSER_HAS_NON_STRICT_ARG;\n  }\n\n  JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);\n\n#if ENABLED (JERRY_ES2015)\n  if (is_generator_function)\n  {\n    status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;\n  }\n\n  if (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_ASYNC)\n  {\n    status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_DEBUGGER)\n  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n  {\n    lexer_literal_t *name_p = context_p->lit_object.literal_p;\n    jerry_debugger_send_string (JERRY_DEBUGGER_FUNCTION_NAME,\n                                JERRY_DEBUGGER_NO_SUBTYPE,\n                                name_p->u.char_p,\n                                name_p->prop.length);\n\n    /* Reset token position for the function. */\n    context_p->token.line = debugger_line;\n    context_p->token.column = debugger_column;\n  }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n  JERRY_ASSERT (context_p->scope_stack_top >= 2);\n  parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top - 2;\n\n  uint16_t literal_index = context_p->lit_object.index;\n\n  while (literal_index != scope_stack_p->map_from)\n  {\n    scope_stack_p--;\n\n    JERRY_ASSERT (scope_stack_p >= context_p->scope_stack_p);\n  }\n\n  JERRY_ASSERT (scope_stack_p[1].map_from == PARSER_SCOPE_STACK_FUNC);\n\n#if ENABLED (JERRY_ES2015)\n  if (!(context_p->status_flags & PARSER_IS_STRICT)\n      && (scope_stack_p >= context_p->scope_stack_p + context_p->scope_stack_global_end))\n  {\n    bool copy_value = true;\n\n    parser_scope_stack_t *stack_p = context_p->scope_stack_p;\n\n    while (stack_p < scope_stack_p)\n    {\n      if (literal_index == stack_p->map_from\n          && (stack_p->map_to & PARSER_SCOPE_STACK_NO_FUNCTION_COPY))\n      {\n        copy_value = false;\n        break;\n      }\n      stack_p++;\n    }\n\n    if (copy_value)\n    {\n      stack_p = context_p->scope_stack_p;\n\n      while (stack_p < scope_stack_p)\n      {\n        if (literal_index == stack_p->map_from)\n        {\n          JERRY_ASSERT (!(stack_p->map_to & PARSER_SCOPE_STACK_NO_FUNCTION_COPY));\n\n          uint16_t map_to = scanner_decode_map_to (stack_p);\n          uint16_t opcode = ((map_to >= PARSER_REGISTER_START) ? CBC_ASSIGN_LITERAL_SET_IDENT\n                                                               : CBC_COPY_TO_GLOBAL);\n\n          parser_emit_cbc_literal_value (context_p,\n                                         opcode,\n                                         scanner_decode_map_to (scope_stack_p),\n                                         map_to);\n          break;\n        }\n        stack_p++;\n      }\n\n      parser_flush_cbc (context_p);\n    }\n\n    if (JERRY_UNLIKELY (context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_SCOPE\n                        || context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_CONTEXT))\n    {\n      parser_pop_block_context (context_p);\n    }\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  lexer_literal_t *literal_p = PARSER_GET_LITERAL ((size_t) scope_stack_p[1].map_to);\n\n  JERRY_ASSERT ((literal_p->type == LEXER_UNUSED_LITERAL || literal_p->type == LEXER_FUNCTION_LITERAL)\n                && literal_p->status_flags == 0);\n\n  ecma_compiled_code_t *compiled_code_p = parser_parse_function (context_p, status_flags);\n\n  if (literal_p->type == LEXER_FUNCTION_LITERAL)\n  {\n    ecma_bytecode_deref (literal_p->u.bytecode_p);\n  }\n\n  literal_p->u.bytecode_p = compiled_code_p;\n  literal_p->type = LEXER_FUNCTION_LITERAL;\n\n  lexer_next_token (context_p);\n}",
        "begin_line": 629,
        "end_line": 832,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-statm.parser_parse_statements#2609",
        "src_path": "jerry-core/parser/js/js-parser-statm.c",
        "class_name": "jerry-core.parser.js.js-parser-statm",
        "signature": "jerry-core.parser.js.js-parser-statm.parser_parse_statements (parser_context_t *context_p) /**< context */",
        "snippet": "void\nparser_parse_statements (parser_context_t *context_p) /**< context */\n{\n  /* Statement parsing cannot be nested. */\n  JERRY_ASSERT (context_p->last_statement.current_p == NULL);\n  parser_stack_push_uint8 (context_p, PARSER_STATEMENT_START);\n  parser_stack_iterator_init (context_p, &context_p->last_statement);\n\n#if ENABLED (JERRY_DEBUGGER)\n  /* Set lexical enviroment for the debugger. */\n  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n  {\n    context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;\n    context_p->last_breakpoint_line = 0;\n  }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n#if ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n  if (JERRY_CONTEXT (resource_name) != ECMA_VALUE_UNDEFINED)\n  {\n    parser_emit_cbc_ext (context_p, CBC_EXT_RESOURCE_NAME);\n    parser_flush_cbc (context_p);\n  }\n#endif /* ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n#if ENABLED (JERRY_LINE_INFO)\n  context_p->last_line_info_line = 0;\n#endif /* ENABLED (JERRY_LINE_INFO) */\n\n  while (context_p->token.type == LEXER_LITERAL\n         && context_p->token.lit_location.type == LEXER_STRING_LITERAL)\n  {\n    lexer_lit_location_t lit_location;\n    parser_strict_mode_type_t strict_mode = PARSER_USE_STRICT_NOT_FOUND;\n\n    JERRY_ASSERT (context_p->stack_depth <= 1);\n#ifndef JERRY_NDEBUG\n    JERRY_ASSERT (context_p->context_stack_depth == context_p->stack_depth);\n#endif /* !JERRY_NDEBUG */\n\n    if (lexer_string_is_use_strict (context_p))\n    {\n      strict_mode = PARSER_USE_STRICT_FOUND;\n\n      if (!(context_p->status_flags & PARSER_IS_STRICT))\n      {\n        /* The next token should be parsed in strict mode. */\n        context_p->status_flags |= PARSER_IS_STRICT;\n        strict_mode = PARSER_USE_STRICT_SET;\n      }\n    }\n\n    lit_location = context_p->token.lit_location;\n    lexer_next_token (context_p);\n\n    if (!lexer_string_is_directive (context_p))\n    {\n      /* The string is part of an expression statement. */\n      if (strict_mode == PARSER_USE_STRICT_SET)\n      {\n        context_p->status_flags &= (uint32_t) ~PARSER_IS_STRICT;\n      }\n\n#if ENABLED (JERRY_DEBUGGER)\n      if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n      {\n        JERRY_ASSERT (context_p->last_breakpoint_line == 0);\n\n        parser_emit_cbc (context_p, CBC_BREAKPOINT_DISABLED);\n        parser_flush_cbc (context_p);\n\n        parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST, context_p->token.line);\n\n        context_p->last_breakpoint_line = context_p->token.line;\n      }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n#if ENABLED (JERRY_LINE_INFO)\n      parser_emit_line_info (context_p, context_p->token.line, false);\n#endif /* ENABLED (JERRY_LINE_INFO) */\n\n      lexer_construct_literal_object (context_p, &lit_location, LEXER_STRING_LITERAL);\n      parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);\n      /* The extra_value is used for saving the token. */\n      context_p->token.extra_value = context_p->token.type;\n      context_p->token.type = LEXER_EXPRESSION_START;\n      break;\n    }\n\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n    if (strict_mode == PARSER_USE_STRICT_SET && context_p->is_show_opcodes)\n    {\n      JERRY_DEBUG_MSG (\"  Note: switch to strict mode\\n\\n\");\n    }\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n\n#if ENABLED (JERRY_ES2015)\n    if (strict_mode != PARSER_USE_STRICT_NOT_FOUND\n        && (context_p->status_flags & PARSER_FUNCTION_HAS_NON_SIMPLE_PARAM))\n    {\n      parser_raise_error (context_p, PARSER_ERR_USE_STRICT_NOT_ALLOWED);\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    if (context_p->token.type == LEXER_SEMICOLON)\n    {\n      lexer_next_token (context_p);\n    }\n\n    /* The last directive prologue can be the result of the script. */\n    if (!(context_p->status_flags & PARSER_IS_FUNCTION)\n        && (context_p->token.type != LEXER_LITERAL\n            || context_p->token.lit_location.type != LEXER_STRING_LITERAL))\n    {\n      lexer_construct_literal_object (context_p, &lit_location, LEXER_STRING_LITERAL);\n      parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);\n      parser_emit_cbc (context_p, CBC_POP_BLOCK);\n      parser_flush_cbc (context_p);\n      break;\n    }\n  }\n\n  if (context_p->status_flags & PARSER_IS_STRICT\n      && context_p->status_flags & PARSER_HAS_NON_STRICT_ARG)\n  {\n    parser_raise_error (context_p, PARSER_ERR_NON_STRICT_ARG_DEFINITION);\n  }\n\n  while (context_p->token.type != LEXER_EOS\n         || context_p->stack_top_uint8 != PARSER_STATEMENT_START)\n  {\n#ifndef JERRY_NDEBUG\n    JERRY_ASSERT (context_p->stack_depth == context_p->context_stack_depth);\n#endif /* !JERRY_NDEBUG */\n\n#if ENABLED (JERRY_ES2015)\n    JERRY_ASSERT (context_p->stack_top_uint8 != PARSER_STATEMENT_PRIVATE_SCOPE\n                  && context_p->stack_top_uint8 != PARSER_STATEMENT_PRIVATE_CONTEXT);\n#endif /* ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_DEBUGGER)\n    if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED\n        && context_p->token.line != context_p->last_breakpoint_line\n        && context_p->token.type != LEXER_SEMICOLON\n        && context_p->token.type != LEXER_LEFT_BRACE\n        && context_p->token.type != LEXER_RIGHT_BRACE\n        && context_p->token.type != LEXER_KEYW_VAR\n        && context_p->token.type != LEXER_KEYW_LET\n        && context_p->token.type != LEXER_KEYW_CONST\n        && context_p->token.type != LEXER_KEYW_FUNCTION\n        && context_p->token.type != LEXER_KEYW_CASE\n        && context_p->token.type != LEXER_KEYW_DEFAULT)\n    {\n      parser_emit_cbc (context_p, CBC_BREAKPOINT_DISABLED);\n      parser_flush_cbc (context_p);\n\n      parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST, context_p->token.line);\n\n      context_p->last_breakpoint_line = context_p->token.line;\n    }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n#if ENABLED (JERRY_LINE_INFO)\n    if (context_p->token.line != context_p->last_line_info_line\n        && context_p->token.type != LEXER_SEMICOLON\n        && context_p->token.type != LEXER_LEFT_BRACE\n        && context_p->token.type != LEXER_RIGHT_BRACE\n        && context_p->token.type != LEXER_KEYW_VAR\n        && context_p->token.type != LEXER_KEYW_LET\n        && context_p->token.type != LEXER_KEYW_CONST\n        && context_p->token.type != LEXER_KEYW_FUNCTION\n        && context_p->token.type != LEXER_KEYW_CASE\n        && context_p->token.type != LEXER_KEYW_DEFAULT)\n    {\n      parser_emit_line_info (context_p, context_p->token.line, true);\n    }\n#endif /* ENABLED (JERRY_LINE_INFO) */\n\n    switch (context_p->token.type)\n    {\n      case LEXER_SEMICOLON:\n      {\n        break;\n      }\n\n      case LEXER_RIGHT_BRACE:\n      {\n        if (parser_statement_flags[context_p->stack_top_uint8] & PARSER_STATM_SINGLE_STATM)\n        {\n          parser_raise_error (context_p, PARSER_ERR_STATEMENT_EXPECTED);\n        }\n        break;\n      }\n\n      case LEXER_LEFT_BRACE:\n      {\n#if ENABLED (JERRY_ES2015)\n        if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n        {\n          parser_push_block_context (context_p, false);\n        }\n        else\n        {\n          parser_stack_push_uint8 (context_p, PARSER_STATEMENT_BLOCK);\n        }\n#else /* !ENABLED (JERRY_ES2015) */\n        parser_stack_push_uint8 (context_p, PARSER_STATEMENT_BLOCK);\n#endif /* ENABLED (JERRY_ES2015) */\n\n        parser_stack_iterator_init (context_p, &context_p->last_statement);\n        lexer_next_token (context_p);\n        continue;\n      }\n\n      case LEXER_KEYW_VAR:\n#if ENABLED (JERRY_ES2015)\n      case LEXER_KEYW_LET:\n      case LEXER_KEYW_CONST:\n#endif /* ENABLED (JERRY_ES2015) */\n      {\n        parser_parse_var_statement (context_p);\n        break;\n      }\n\n#if ENABLED (JERRY_ES2015)\n      case LEXER_KEYW_CLASS:\n      {\n        parser_validate_lexical_context (context_p);\n        parser_parse_class (context_p, true);\n        goto consume_last_statement;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n      case LEXER_KEYW_IMPORT:\n      {\n        parser_parse_import_statement (context_p);\n        break;\n      }\n\n      case LEXER_KEYW_EXPORT:\n      {\n        parser_parse_export_statement (context_p);\n        break;\n      }\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n      case LEXER_KEYW_FUNCTION:\n      {\n        parser_parse_function_statement (context_p);\n        goto consume_last_statement;\n      }\n\n      case LEXER_KEYW_IF:\n      {\n        parser_parse_if_statement_start (context_p);\n        continue;\n      }\n\n      case LEXER_KEYW_SWITCH:\n      {\n        parser_parse_switch_statement_start (context_p);\n        continue;\n      }\n\n      case LEXER_KEYW_DO:\n      {\n        parser_do_while_statement_t do_while_statement;\n        parser_loop_statement_t loop;\n\n        JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);\n\n        do_while_statement.start_offset = context_p->byte_code_size;\n        loop.branch_list_p = NULL;\n\n        parser_stack_push (context_p, &do_while_statement, sizeof (parser_do_while_statement_t));\n        parser_stack_push (context_p, &loop, sizeof (parser_loop_statement_t));\n        parser_stack_push_uint8 (context_p, PARSER_STATEMENT_DO_WHILE);\n        parser_stack_iterator_init (context_p, &context_p->last_statement);\n        lexer_next_token (context_p);\n        continue;\n      }\n\n      case LEXER_KEYW_WHILE:\n      {\n        parser_parse_while_statement_start (context_p);\n        continue;\n      }\n\n      case LEXER_KEYW_FOR:\n      {\n        parser_parse_for_statement_start (context_p);\n        continue;\n      }\n\n      case LEXER_KEYW_WITH:\n      {\n        parser_parse_with_statement_start (context_p);\n        continue;\n      }\n\n      case LEXER_KEYW_TRY:\n      {\n        parser_try_statement_t try_statement;\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_LEFT_BRACE)\n        {\n          parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_EXPECTED);\n        }\n\n#ifndef JERRY_NDEBUG\n        PARSER_PLUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);\n#endif /* !JERRY_NDEBUG */\n\n        try_statement.type = parser_try_block;\n        parser_emit_cbc_ext_forward_branch (context_p,\n                                            CBC_EXT_TRY_CREATE_CONTEXT,\n                                            &try_statement.branch);\n\n#if ENABLED (JERRY_ES2015)\n        try_statement.scope_stack_top = context_p->scope_stack_top;\n        try_statement.scope_stack_reg_top = context_p->scope_stack_reg_top;\n\n        if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n        {\n          JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_BLOCK);\n\n          if (scanner_is_context_needed (context_p, PARSER_CHECK_BLOCK_CONTEXT))\n          {\n            parser_emit_cbc_ext (context_p, CBC_EXT_TRY_CREATE_ENV);\n          }\n\n          scanner_create_variables (context_p, SCANNER_CREATE_VARS_NO_OPTS);\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        parser_stack_push (context_p, &try_statement, sizeof (parser_try_statement_t));\n        parser_stack_push_uint8 (context_p, PARSER_STATEMENT_TRY);\n        parser_stack_iterator_init (context_p, &context_p->last_statement);\n        lexer_next_token (context_p);\n        continue;\n      }\n\n      case LEXER_KEYW_DEFAULT:\n      {\n        parser_parse_default_statement (context_p);\n        continue;\n      }\n\n      case LEXER_KEYW_CASE:\n      {\n        parser_parse_case_statement (context_p);\n        continue;\n      }\n\n      case LEXER_KEYW_BREAK:\n      {\n        parser_parse_break_statement (context_p);\n        break;\n      }\n\n      case LEXER_KEYW_CONTINUE:\n      {\n        parser_parse_continue_statement (context_p);\n        break;\n      }\n\n      case LEXER_KEYW_THROW:\n      {\n        lexer_next_token (context_p);\n        if (context_p->token.flags & LEXER_WAS_NEWLINE)\n        {\n          parser_raise_error (context_p, PARSER_ERR_EXPRESSION_EXPECTED);\n        }\n        parser_parse_expression (context_p, PARSE_EXPR);\n        parser_emit_cbc (context_p, CBC_THROW);\n        break;\n      }\n\n      case LEXER_KEYW_RETURN:\n      {\n        if (!(context_p->status_flags & PARSER_IS_FUNCTION))\n        {\n          parser_raise_error (context_p, PARSER_ERR_INVALID_RETURN);\n        }\n\n        lexer_next_token (context_p);\n\n        if ((context_p->token.flags & LEXER_WAS_NEWLINE)\n            || context_p->token.type == LEXER_SEMICOLON\n            || context_p->token.type == LEXER_EOS\n            || context_p->token.type == LEXER_RIGHT_BRACE)\n        {\n#if ENABLED (JERRY_ES2015)\n          if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)\n          {\n            parser_emit_cbc (context_p, CBC_PUSH_UNDEFINED);\n            parser_emit_cbc_ext (context_p, CBC_EXT_RETURN_PROMISE);\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n\n          parser_emit_cbc (context_p, CBC_RETURN_WITH_BLOCK);\n          break;\n        }\n\n        parser_parse_expression (context_p, PARSE_EXPR);\n\n#if ENABLED (JERRY_ES2015)\n        if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)\n        {\n          parser_emit_cbc_ext (context_p, CBC_EXT_RETURN_PROMISE);\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)\n        {\n          context_p->last_cbc_opcode = CBC_RETURN_WITH_LITERAL;\n          break;\n        }\n\n        parser_emit_cbc (context_p, CBC_RETURN);\n        break;\n      }\n\n      case LEXER_KEYW_DEBUGGER:\n      {\n#if ENABLED (JERRY_DEBUGGER)\n        /* This breakpoint location is not reported to the\n         * debugger, so it is impossible to disable it. */\n        if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n        {\n          parser_emit_cbc (context_p, CBC_BREAKPOINT_ENABLED);\n        }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n        lexer_next_token (context_p);\n        break;\n      }\n\n      case LEXER_LITERAL:\n      {\n        if (context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n        {\n          if (JERRY_UNLIKELY (lexer_check_next_character (context_p, LIT_CHAR_COLON)))\n          {\n            parser_parse_label (context_p);\n            lexer_consume_next_character (context_p);\n            lexer_next_token (context_p);\n            continue;\n          }\n#if ENABLED (JERRY_ES2015)\n          if (JERRY_UNLIKELY (lexer_token_is_let (context_p)))\n          {\n            if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n            {\n              if (context_p->next_scanner_info_p->type == SCANNER_TYPE_LET_EXPRESSION)\n              {\n                scanner_release_next (context_p, sizeof (scanner_info_t));\n              }\n\n              if (context_p->status_flags & PARSER_IS_FUNCTION)\n              {\n                parser_parse_expression_statement (context_p, PARSE_EXPR);\n                break;\n              }\n\n              parser_parse_block_expression (context_p, PARSE_EXPR);\n              break;\n            }\n\n            context_p->token.type = LEXER_KEYW_LET;\n            parser_parse_var_statement (context_p);\n            break;\n          }\n\n          if (JERRY_UNLIKELY (lexer_token_is_async (context_p))\n              && context_p->next_scanner_info_p->source_p == context_p->source_p)\n          {\n            bool is_statement = true;\n\n            if (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION)\n            {\n              is_statement = (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_STATEMENT) != 0;\n\n              JERRY_ASSERT (!is_statement || (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_ASYNC));\n            }\n            else\n            {\n              JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_ASYNC_FUNCTION);\n\n              scanner_release_next (context_p, sizeof (scanner_info_t));\n            }\n\n            if (is_statement)\n            {\n              if (parser_statement_flags[context_p->stack_top_uint8] & PARSER_STATM_SINGLE_STATM)\n              {\n                parser_raise_error (context_p, PARSER_ERR_LEXICAL_SINGLE_STATEMENT);\n              }\n\n              lexer_next_token (context_p);\n              JERRY_ASSERT (context_p->token.type == LEXER_KEYW_FUNCTION);\n              continue;\n            }\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n        }\n        /* FALLTHRU */\n      }\n\n      default:\n      {\n        int options = PARSE_EXPR;\n\n        if (context_p->token.type == LEXER_EXPRESSION_START)\n        {\n          /* Restore the token type form the extra_value. */\n          context_p->token.type = context_p->token.extra_value;\n          options |= PARSE_EXPR_HAS_LITERAL;\n        }\n\n        if (context_p->status_flags & PARSER_IS_FUNCTION)\n        {\n          parser_parse_expression_statement (context_p, options);\n        }\n        else\n        {\n          parser_parse_block_expression (context_p, options);\n        }\n\n        break;\n      }\n    }\n\n    parser_flush_cbc (context_p);\n\n    if (context_p->token.type == LEXER_RIGHT_BRACE)\n    {\n      if (context_p->stack_top_uint8 == PARSER_STATEMENT_BLOCK)\n      {\n        parser_stack_pop_uint8 (context_p);\n        parser_stack_iterator_init (context_p, &context_p->last_statement);\n        lexer_next_token (context_p);\n      }\n#if ENABLED (JERRY_ES2015)\n      else if (context_p->stack_top_uint8 == PARSER_STATEMENT_BLOCK_SCOPE\n               || context_p->stack_top_uint8 == PARSER_STATEMENT_BLOCK_CONTEXT)\n      {\n        parser_pop_block_context (context_p);\n        lexer_next_token (context_p);\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      else if (context_p->stack_top_uint8 == PARSER_STATEMENT_SWITCH\n               || context_p->stack_top_uint8 == PARSER_STATEMENT_SWITCH_NO_DEFAULT)\n      {\n        int has_default = (context_p->stack_top_uint8 == PARSER_STATEMENT_SWITCH);\n        parser_loop_statement_t loop;\n        parser_switch_statement_t switch_statement;\n\n        parser_stack_pop_uint8 (context_p);\n        parser_stack_pop (context_p, &loop, sizeof (parser_loop_statement_t));\n        parser_stack_pop (context_p, &switch_statement, sizeof (parser_switch_statement_t));\n        parser_stack_iterator_init (context_p, &context_p->last_statement);\n\n        JERRY_ASSERT (switch_statement.branch_list_p == NULL);\n\n        if (!has_default)\n        {\n          parser_set_branch_to_current_position (context_p, &switch_statement.default_branch);\n        }\n\n        parser_set_breaks_to_current_position (context_p, loop.branch_list_p);\n        lexer_next_token (context_p);\n\n#if ENABLED (JERRY_ES2015)\n        if (context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_SCOPE\n            || context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_CONTEXT)\n        {\n          parser_pop_block_context (context_p);\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n      }\n      else if (context_p->stack_top_uint8 == PARSER_STATEMENT_TRY)\n      {\n        parser_parse_try_statement_end (context_p);\n      }\n      else if (context_p->stack_top_uint8 == PARSER_STATEMENT_START)\n      {\n        if (context_p->status_flags & PARSER_IS_CLOSURE)\n        {\n          parser_stack_pop_uint8 (context_p);\n          context_p->last_statement.current_p = NULL;\n          /* There is no lexer_next_token here, since the\n           * next token belongs to the parent context. */\n          return;\n        }\n        parser_raise_error (context_p, PARSER_ERR_INVALID_RIGHT_SQUARE);\n      }\n    }\n    else if (context_p->token.type == LEXER_SEMICOLON)\n    {\n      lexer_next_token (context_p);\n    }\n    else if (context_p->token.type != LEXER_EOS\n             && !(context_p->token.flags & LEXER_WAS_NEWLINE))\n    {\n      parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);\n    }\n\nconsume_last_statement:\n    while (true)\n    {\n      switch (context_p->stack_top_uint8)\n      {\n        case PARSER_STATEMENT_LABEL:\n        {\n          parser_label_statement_t label;\n\n          parser_stack_pop_uint8 (context_p);\n          parser_stack_pop (context_p, &label, sizeof (parser_label_statement_t));\n          parser_stack_iterator_init (context_p, &context_p->last_statement);\n\n          parser_set_breaks_to_current_position (context_p, label.break_list_p);\n          continue;\n        }\n\n        case PARSER_STATEMENT_IF:\n        {\n          if (parser_parse_if_statement_end (context_p))\n          {\n            break;\n          }\n          continue;\n        }\n\n        case PARSER_STATEMENT_ELSE:\n        {\n          parser_if_else_statement_t else_statement;\n\n          parser_stack_pop_uint8 (context_p);\n          parser_stack_pop (context_p, &else_statement, sizeof (parser_if_else_statement_t));\n          parser_stack_iterator_init (context_p, &context_p->last_statement);\n\n          parser_set_branch_to_current_position (context_p, &else_statement.branch);\n          continue;\n        }\n\n        case PARSER_STATEMENT_DO_WHILE:\n        {\n          parser_parse_do_while_statement_end (context_p);\n          if (context_p->token.type == LEXER_SEMICOLON)\n          {\n            lexer_next_token (context_p);\n          }\n          continue;\n        }\n\n        case PARSER_STATEMENT_WHILE:\n        {\n          parser_parse_while_statement_end (context_p);\n          continue;\n        }\n\n        case PARSER_STATEMENT_FOR:\n        {\n          parser_parse_for_statement_end (context_p);\n          continue;\n        }\n\n        case PARSER_STATEMENT_FOR_IN:\n#if ENABLED (JERRY_ES2015)\n        case PARSER_STATEMENT_FOR_OF:\n#endif /* ENABLED (JERRY_ES2015) */\n        {\n          parser_for_in_of_statement_t for_in_of_statement;\n          parser_loop_statement_t loop;\n\n#if ENABLED (JERRY_ES2015)\n          bool is_for_in = (context_p->stack_top_uint8 == PARSER_STATEMENT_FOR_IN);\n#else\n          bool is_for_in = true;\n#endif /* ENABLED (JERRY_ES2015) */\n\n          parser_stack_pop_uint8 (context_p);\n          parser_stack_pop (context_p, &loop, sizeof (parser_loop_statement_t));\n          parser_stack_pop (context_p, &for_in_of_statement, sizeof (parser_for_in_of_statement_t));\n          parser_stack_iterator_init (context_p, &context_p->last_statement);\n\n          parser_set_continues_to_current_position (context_p, loop.branch_list_p);\n\n          parser_flush_cbc (context_p);\n          PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, is_for_in ? PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION\n                                                                    : PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);\n#ifndef JERRY_NDEBUG\n          PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth,\n                                  is_for_in ? PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION\n                                            : PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);\n#endif /* !JERRY_NDEBUG */\n\n          parser_emit_cbc_ext_backward_branch (context_p,\n                                               is_for_in ? CBC_EXT_BRANCH_IF_FOR_IN_HAS_NEXT\n                                                         : CBC_EXT_BRANCH_IF_FOR_OF_HAS_NEXT,\n                                               for_in_of_statement.start_offset);\n\n          parser_set_breaks_to_current_position (context_p, loop.branch_list_p);\n          parser_set_branch_to_current_position (context_p, &for_in_of_statement.branch);\n\n#if ENABLED (JERRY_ES2015)\n          if (context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_SCOPE\n              || context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_CONTEXT)\n          {\n            parser_pop_block_context (context_p);\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n          continue;\n        }\n\n        case PARSER_STATEMENT_WITH:\n        {\n          parser_parse_with_statement_end (context_p);\n          continue;\n        }\n\n        default:\n        {\n          break;\n        }\n      }\n      break;\n    }\n  }\n\n  parser_stack_pop_uint8 (context_p);\n  context_p->last_statement.current_p = NULL;\n\n  if (context_p->status_flags & PARSER_IS_CLOSURE)\n  {\n    parser_raise_error (context_p, PARSER_ERR_STATEMENT_EXPECTED);\n  }\n}",
        "begin_line": 2609,
        "end_line": 3349,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-statm.parser_parse_var_statement#479",
        "src_path": "jerry-core/parser/js/js-parser-statm.c",
        "class_name": "jerry-core.parser.js.js-parser-statm",
        "signature": "jerry-core.parser.js.js-parser-statm.parser_parse_var_statement (parser_context_t *context_p) /**< context */",
        "snippet": "static void\nparser_parse_var_statement (parser_context_t *context_p) /**< context */\n{\n  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_VAR\n                || context_p->token.type == LEXER_KEYW_LET\n                || context_p->token.type == LEXER_KEYW_CONST);\n\n#if ENABLED (JERRY_ES2015)\n  uint8_t declaration_type = context_p->token.type;\n\n  if (declaration_type != LEXER_KEYW_VAR)\n  {\n    parser_validate_lexical_context (context_p);\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  while (true)\n  {\n#if ENABLED (JERRY_ES2015)\n    if (lexer_check_next_characters (context_p, LIT_CHAR_LEFT_SQUARE, LIT_CHAR_LEFT_BRACE))\n    {\n      parser_pattern_flags_t flags = PARSER_PATTERN_BINDING;\n\n      if (declaration_type == LEXER_KEYW_LET)\n      {\n        flags |= PARSER_PATTERN_LET;\n      }\n      else if (declaration_type == LEXER_KEYW_CONST)\n      {\n        flags |= PARSER_PATTERN_CONST;\n      }\n\n      parser_parse_initializer_by_next_char (context_p, flags);\n    }\n    else\n    {\n#endif /* ENABLED (JERRY_ES2015) */\n      lexer_expect_identifier (context_p, LEXER_IDENT_LITERAL);\n      JERRY_ASSERT (context_p->token.type == LEXER_LITERAL\n                    && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);\n\n#if ENABLED (JERRY_DEBUGGER) || ENABLED (JERRY_LINE_INFO)\n      parser_line_counter_t ident_line_counter = context_p->token.line;\n#endif /* ENABLED (JERRY_DEBUGGER) || ENABLED (JERRY_LINE_INFO) */\n\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n      parser_module_append_export_name (context_p);\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n#if ENABLED (JERRY_ES2015)\n      if (declaration_type != LEXER_KEYW_VAR\n          && context_p->token.keyword_type == LEXER_KEYW_LET)\n      {\n        parser_raise_error (context_p, PARSER_ERR_LEXICAL_LET_BINDING);\n      }\n\n      if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n      {\n        JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED);\n        parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type == LEXER_ASSIGN)\n      {\n#if ENABLED (JERRY_DEBUGGER)\n        if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n            && ident_line_counter != context_p->last_breakpoint_line)\n        {\n          parser_emit_cbc (context_p, CBC_BREAKPOINT_DISABLED);\n          parser_flush_cbc (context_p);\n\n          parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST, ident_line_counter);\n\n          context_p->last_breakpoint_line = ident_line_counter;\n        }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n#if ENABLED (JERRY_LINE_INFO)\n        if (ident_line_counter != context_p->last_line_info_line)\n        {\n          parser_emit_line_info (context_p, ident_line_counter, false);\n        }\n#endif /* ENABLED (JERRY_LINE_INFO) */\n\n        uint16_t index = context_p->lit_object.index;\n\n        lexer_next_token (context_p);\n        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);\n\n        cbc_opcode_t opcode = CBC_ASSIGN_SET_IDENT;\n\n#if ENABLED (JERRY_ES2015)\n        if (declaration_type != LEXER_KEYW_VAR\n            && (index < PARSER_REGISTER_START))\n        {\n          opcode = CBC_INIT_LET;\n\n          if (scanner_literal_is_created (context_p, index))\n          {\n            opcode = CBC_ASSIGN_LET_CONST;\n          }\n          else if (declaration_type == LEXER_KEYW_CONST)\n          {\n            opcode = CBC_INIT_CONST;\n          }\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        parser_emit_cbc_literal (context_p, (uint16_t) opcode, index);\n      }\n#if ENABLED (JERRY_ES2015)\n      else if (declaration_type == LEXER_KEYW_LET)\n      {\n        parser_emit_cbc (context_p, CBC_PUSH_UNDEFINED);\n\n        uint16_t index = context_p->lit_object.index;\n        cbc_opcode_t opcode = CBC_MOV_IDENT;\n\n        if (index < PARSER_REGISTER_START)\n        {\n          opcode = (scanner_literal_is_created (context_p, index) ? CBC_ASSIGN_LET_CONST\n                                                                  : CBC_INIT_LET);\n        }\n\n        parser_emit_cbc_literal (context_p, (uint16_t) opcode, index);\n      }\n      else if (declaration_type == LEXER_KEYW_CONST)\n      {\n        parser_raise_error (context_p, PARSER_ERR_MISSING_ASSIGN_AFTER_CONST);\n      }\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    if (context_p->token.type != LEXER_COMMA)\n    {\n      break;\n    }\n  }\n\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n  context_p->status_flags &= (uint32_t) ~(PARSER_MODULE_STORE_IDENT);\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n}",
        "begin_line": 479,
        "end_line": 624,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-statm.parser_stack_iterator_init#309",
        "src_path": "jerry-core/parser/js/js-parser-statm.c",
        "class_name": "jerry-core.parser.js.js-parser-statm",
        "signature": "jerry-core.parser.js.js-parser-statm.parser_stack_iterator_init (parser_context_t *context_p, /**< context */                             parser_stack_iterator_t *iterator) /**< iterator */",
        "snippet": "static inline void\nparser_stack_iterator_init (parser_context_t *context_p, /**< context */\n                            parser_stack_iterator_t *iterator) /**< iterator */\n{\n  iterator->current_p = context_p->stack.first_p;\n  iterator->current_position = context_p->stack.last_position;\n}",
        "begin_line": 309,
        "end_line": 315,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-statm.parser_stack_iterator_read_uint8#322",
        "src_path": "jerry-core/parser/js/js-parser-statm.c",
        "class_name": "jerry-core.parser.js.js-parser-statm",
        "signature": "jerry-core.parser.js.js-parser-statm.parser_stack_iterator_read_uint8 (parser_stack_iterator_t *iterator) /**< iterator */",
        "snippet": "static inline uint8_t\nparser_stack_iterator_read_uint8 (parser_stack_iterator_t *iterator) /**< iterator */\n{\n  JERRY_ASSERT (iterator->current_position > 0 && iterator->current_position <= PARSER_STACK_PAGE_SIZE);\n  return iterator->current_p->bytes[iterator->current_position - 1];\n}",
        "begin_line": 322,
        "end_line": 327,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_emit_cbc#290",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_emit_cbc (parser_context_t *context_p, /**< context */                  uint16_t opcode) /**< opcode */",
        "snippet": "void\nparser_emit_cbc (parser_context_t *context_p, /**< context */\n                 uint16_t opcode) /**< opcode */\n{\n  JERRY_ASSERT (PARSER_ARGS_EQ (opcode, 0));\n\n  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)\n  {\n    parser_flush_cbc (context_p);\n  }\n\n  context_p->last_cbc_opcode = opcode;\n}",
        "begin_line": 290,
        "end_line": 302,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_backward_branch#621",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_backward_branch (parser_context_t *context_p, /**< context */                                  uint16_t opcode, /**< opcode */                                  uint32_t offset) /**< destination offset */",
        "snippet": "void\nparser_emit_cbc_backward_branch (parser_context_t *context_p, /**< context */\n                                 uint16_t opcode, /**< opcode */\n                                 uint32_t offset) /**< destination offset */\n{\n  uint8_t flags;\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n  const char *name;\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n\n  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)\n  {\n    parser_flush_cbc (context_p);\n  }\n\n  context_p->status_flags |= PARSER_NO_END_LABEL;\n  offset = context_p->byte_code_size - offset;\n\n  if (PARSER_IS_BASIC_OPCODE (opcode))\n  {\n    JERRY_ASSERT (opcode < CBC_END);\n    flags = cbc_flags[opcode];\n\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n    name = cbc_names[opcode];\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n  }\n  else\n  {\n    PARSER_APPEND_TO_BYTE_CODE (context_p, CBC_EXT_OPCODE);\n    opcode = (uint16_t) PARSER_GET_EXT_OPCODE (opcode);\n\n    JERRY_ASSERT (opcode < CBC_EXT_END);\n    flags = cbc_ext_flags[opcode];\n    context_p->byte_code_size++;\n\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n    name = cbc_ext_names[opcode];\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n  }\n\n  JERRY_ASSERT (flags & CBC_HAS_BRANCH_ARG);\n  JERRY_ASSERT (CBC_BRANCH_IS_BACKWARD (flags));\n  JERRY_ASSERT (CBC_BRANCH_OFFSET_LENGTH (opcode) == 1);\n  JERRY_ASSERT (offset <= context_p->byte_code_size);\n\n  /* Branch opcodes never push anything onto the stack. */\n  JERRY_ASSERT ((flags >> CBC_STACK_ADJUST_SHIFT) >= CBC_STACK_ADJUST_BASE\n                 || (CBC_STACK_ADJUST_BASE - (flags >> CBC_STACK_ADJUST_SHIFT)) <= context_p->stack_depth);\n  PARSER_PLUS_EQUAL_U16 (context_p->stack_depth, CBC_STACK_ADJUST_VALUE (flags));\n\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n  if (context_p->is_show_opcodes)\n  {\n    JERRY_DEBUG_MSG (\"  [%3d] %s\\n\", (int) context_p->stack_depth, name);\n  }\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n\n  context_p->byte_code_size += 2;\n#if PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX\n  if (offset > UINT16_MAX)\n  {\n    opcode++;\n    context_p->byte_code_size++;\n  }\n#endif /* PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX */\n\n  if (offset > UINT8_MAX)\n  {\n    opcode++;\n    context_p->byte_code_size++;\n  }\n\n  PARSER_APPEND_TO_BYTE_CODE (context_p, (uint8_t) opcode);\n\n#if PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX\n  if (offset > UINT16_MAX)\n  {\n    PARSER_APPEND_TO_BYTE_CODE (context_p, offset >> 16);\n  }\n#endif /* PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX */\n\n  if (offset > UINT8_MAX)\n  {\n    PARSER_APPEND_TO_BYTE_CODE (context_p, (offset >> 8) & 0xff);\n  }\n\n  PARSER_APPEND_TO_BYTE_CODE (context_p, offset & 0xff);\n}",
        "begin_line": 621,
        "end_line": 709,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_call#371",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_call (parser_context_t *context_p, /**< context */                       uint16_t opcode, /**< opcode */                       size_t call_arguments) /**< number of arguments */",
        "snippet": "void\nparser_emit_cbc_call (parser_context_t *context_p, /**< context */\n                      uint16_t opcode, /**< opcode */\n                      size_t call_arguments) /**< number of arguments */\n{\n  JERRY_ASSERT (PARSER_ARGS_EQ (opcode, CBC_HAS_BYTE_ARG));\n  JERRY_ASSERT (call_arguments <= CBC_MAXIMUM_BYTE_VALUE);\n\n  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)\n  {\n    parser_flush_cbc (context_p);\n  }\n\n  context_p->last_cbc_opcode = opcode;\n  context_p->last_cbc.value = (uint16_t) call_arguments;\n}",
        "begin_line": 371,
        "end_line": 386,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_forward_branch#520",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_forward_branch (parser_context_t *context_p, /**< context */                                 uint16_t opcode, /**< opcode */                                 parser_branch_t *branch_p) /**< branch result */",
        "snippet": "void\nparser_emit_cbc_forward_branch (parser_context_t *context_p, /**< context */\n                                uint16_t opcode, /**< opcode */\n                                parser_branch_t *branch_p) /**< branch result */\n{\n  uint8_t flags;\n  uint32_t extra_byte_code_increase;\n\n  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)\n  {\n    parser_flush_cbc (context_p);\n  }\n\n  context_p->status_flags |= PARSER_NO_END_LABEL;\n\n  if (PARSER_IS_BASIC_OPCODE (opcode))\n  {\n    JERRY_ASSERT (opcode < CBC_END);\n    flags = cbc_flags[opcode];\n    extra_byte_code_increase = 0;\n  }\n  else\n  {\n    PARSER_APPEND_TO_BYTE_CODE (context_p, CBC_EXT_OPCODE);\n    opcode = (uint16_t) PARSER_GET_EXT_OPCODE (opcode);\n\n    JERRY_ASSERT (opcode < CBC_EXT_END);\n    flags = cbc_ext_flags[opcode];\n    extra_byte_code_increase = 1;\n  }\n\n  JERRY_ASSERT (flags & CBC_HAS_BRANCH_ARG);\n  JERRY_ASSERT (CBC_BRANCH_IS_FORWARD (flags));\n  JERRY_ASSERT (CBC_BRANCH_OFFSET_LENGTH (opcode) == 1);\n\n  /* Branch opcodes never push anything onto the stack. */\n  JERRY_ASSERT ((flags >> CBC_STACK_ADJUST_SHIFT) >= CBC_STACK_ADJUST_BASE\n                 || (CBC_STACK_ADJUST_BASE - (flags >> CBC_STACK_ADJUST_SHIFT)) <= context_p->stack_depth);\n  PARSER_PLUS_EQUAL_U16 (context_p->stack_depth, CBC_STACK_ADJUST_VALUE (flags));\n\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n  if (context_p->is_show_opcodes)\n  {\n    JERRY_DEBUG_MSG (\"  [%3d] %s\\n\",\n                     (int) context_p->stack_depth,\n                     extra_byte_code_increase == 0 ? cbc_names[opcode] : cbc_ext_names[opcode]);\n  }\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n\n  PARSER_PLUS_EQUAL_U16 (opcode, PARSER_MAX_BRANCH_LENGTH - 1);\n\n  parser_emit_two_bytes (context_p, (uint8_t) opcode, 0);\n  branch_p->page_p = context_p->byte_code.last_p;\n  branch_p->offset = (context_p->byte_code.last_position - 1) | (context_p->byte_code_size << 8);\n\n  context_p->byte_code_size += extra_byte_code_increase;\n\n#if PARSER_MAXIMUM_CODE_SIZE <= UINT16_MAX\n  PARSER_APPEND_TO_BYTE_CODE (context_p, 0);\n#else /* PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX */\n  parser_emit_two_bytes (context_p, 0, 0);\n#endif /* PARSER_MAXIMUM_CODE_SIZE <= UINT16_MAX */\n\n  context_p->byte_code_size += PARSER_MAX_BRANCH_LENGTH + 1;\n\n  if (context_p->stack_depth > context_p->stack_limit)\n  {\n    context_p->stack_limit = context_p->stack_depth;\n    if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)\n    {\n      parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);\n    }\n  }\n}",
        "begin_line": 520,
        "end_line": 593,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_literal#307",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_literal (parser_context_t *context_p, /**< context */                          uint16_t opcode, /**< opcode */                          uint16_t literal_index) /**< literal index */",
        "snippet": "void\nparser_emit_cbc_literal (parser_context_t *context_p, /**< context */\n                         uint16_t opcode, /**< opcode */\n                         uint16_t literal_index) /**< literal index */\n{\n  JERRY_ASSERT (PARSER_ARGS_EQ (opcode, CBC_HAS_LITERAL_ARG));\n\n  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)\n  {\n    parser_flush_cbc (context_p);\n  }\n\n  context_p->last_cbc_opcode = opcode;\n  context_p->last_cbc.literal_index = literal_index;\n  context_p->last_cbc.literal_type = LEXER_UNUSED_LITERAL;\n  context_p->last_cbc.literal_keyword_type = LEXER_EOS;\n}",
        "begin_line": 307,
        "end_line": 323,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_literal_from_token#351",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_literal_from_token (parser_context_t *context_p, /**< context */                                     uint16_t opcode) /**< opcode */",
        "snippet": "void\nparser_emit_cbc_literal_from_token (parser_context_t *context_p, /**< context */\n                                    uint16_t opcode) /**< opcode */\n{\n  JERRY_ASSERT (PARSER_ARGS_EQ (opcode, CBC_HAS_LITERAL_ARG));\n\n  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)\n  {\n    parser_flush_cbc (context_p);\n  }\n\n  context_p->last_cbc_opcode = opcode;\n  context_p->last_cbc.literal_index = context_p->lit_object.index;\n  context_p->last_cbc.literal_type = context_p->token.lit_location.type;\n  context_p->last_cbc.literal_keyword_type = context_p->token.keyword_type;\n}",
        "begin_line": 351,
        "end_line": 366,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_literal_value#328",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_literal_value (parser_context_t *context_p, /**< context */                                uint16_t opcode, /**< opcode */                                uint16_t literal_index, /**< literal index */                                uint16_t value) /**< value */",
        "snippet": "void\nparser_emit_cbc_literal_value (parser_context_t *context_p, /**< context */\n                               uint16_t opcode, /**< opcode */\n                               uint16_t literal_index, /**< literal index */\n                               uint16_t value) /**< value */\n{\n  JERRY_ASSERT (PARSER_ARGS_EQ (opcode, CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2));\n\n  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)\n  {\n    parser_flush_cbc (context_p);\n  }\n\n  context_p->last_cbc_opcode = opcode;\n  context_p->last_cbc.literal_index = literal_index;\n  context_p->last_cbc.literal_type = LEXER_UNUSED_LITERAL;\n  context_p->last_cbc.literal_keyword_type = LEXER_EOS;\n  context_p->last_cbc.value = value;\n}",
        "begin_line": 328,
        "end_line": 346,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_push_number#391",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_push_number (parser_context_t *context_p, /**< context */                              bool is_negative_number) /**< sign is negative */",
        "snippet": "void\nparser_emit_cbc_push_number (parser_context_t *context_p, /**< context */\n                             bool is_negative_number) /**< sign is negative */\n{\n  uint16_t value = context_p->lit_object.index;\n  uint16_t lit_value = UINT16_MAX;\n\n  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)\n  {\n    if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)\n    {\n      lit_value = context_p->last_cbc.literal_index;\n    }\n    else\n    {\n      if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)\n      {\n        context_p->last_cbc_opcode = CBC_PUSH_LITERAL;\n        lit_value = context_p->last_cbc.value;\n      }\n      else if (context_p->last_cbc_opcode == CBC_PUSH_THREE_LITERALS)\n      {\n        context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;\n        lit_value = context_p->last_cbc.third_literal_index;\n      }\n\n      parser_flush_cbc (context_p);\n    }\n  }\n\n  if (value == 0)\n  {\n    if (lit_value == UINT16_MAX)\n    {\n      context_p->last_cbc_opcode = CBC_PUSH_NUMBER_0;\n      return;\n    }\n\n    context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_LITERAL_PUSH_NUMBER_0);\n    context_p->last_cbc.literal_index = lit_value;\n    return;\n  }\n\n  uint16_t opcode;\n\n  if (lit_value == UINT16_MAX)\n  {\n    opcode = (is_negative_number ? CBC_PUSH_NUMBER_NEG_BYTE\n                                 : CBC_PUSH_NUMBER_POS_BYTE);\n\n    JERRY_ASSERT (CBC_STACK_ADJUST_VALUE (PARSER_GET_FLAGS (opcode)) == 1);\n  }\n  else\n  {\n    opcode = PARSER_TO_EXT_OPCODE (is_negative_number ? CBC_EXT_PUSH_LITERAL_PUSH_NUMBER_NEG_BYTE\n                                                      : CBC_EXT_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE);\n    JERRY_ASSERT (CBC_STACK_ADJUST_VALUE (PARSER_GET_FLAGS (opcode)) == 2);\n\n    context_p->last_cbc.literal_index = lit_value;\n  }\n\n  JERRY_ASSERT (value > 0 && value <= CBC_PUSH_NUMBER_BYTE_RANGE_END);\n\n  context_p->last_cbc_opcode = opcode;\n  context_p->last_cbc.value = (uint16_t) (value - 1);\n}",
        "begin_line": 391,
        "end_line": 456,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_emit_two_bytes#41",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_emit_two_bytes (parser_context_t *context_p, /**< context */                        uint8_t first_byte, /**< first byte */                        uint8_t second_byte) /**< second byte */",
        "snippet": "static void\nparser_emit_two_bytes (parser_context_t *context_p, /**< context */\n                       uint8_t first_byte, /**< first byte */\n                       uint8_t second_byte) /**< second byte */\n{\n  uint32_t last_position = context_p->byte_code.last_position;\n\n  if (last_position + 2 <= PARSER_CBC_STREAM_PAGE_SIZE)\n  {\n    parser_mem_page_t *page_p = context_p->byte_code.last_p;\n\n    page_p->bytes[last_position] = first_byte;\n    page_p->bytes[last_position + 1] = second_byte;\n    context_p->byte_code.last_position = last_position + 2;\n  }\n  else if (last_position >= PARSER_CBC_STREAM_PAGE_SIZE)\n  {\n    parser_mem_page_t *page_p;\n\n    parser_cbc_stream_alloc_page (context_p, &context_p->byte_code);\n    page_p = context_p->byte_code.last_p;\n    page_p->bytes[0] = first_byte;\n    page_p->bytes[1] = second_byte;\n    context_p->byte_code.last_position = 2;\n  }\n  else\n  {\n    context_p->byte_code.last_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] = first_byte;\n    parser_cbc_stream_alloc_page (context_p, &context_p->byte_code);\n    context_p->byte_code.last_p->bytes[0] = second_byte;\n    context_p->byte_code.last_position = 1;\n  }\n}",
        "begin_line": 41,
        "end_line": 73,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_flush_cbc#145",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_flush_cbc (parser_context_t *context_p) /**< context */",
        "snippet": "void\nparser_flush_cbc (parser_context_t *context_p) /**< context */\n{\n  uint8_t flags;\n  uint16_t last_opcode = context_p->last_cbc_opcode;\n\n  if (last_opcode == PARSER_CBC_UNAVAILABLE)\n  {\n    return;\n  }\n\n  JERRY_ASSERT (last_opcode != PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER));\n\n  context_p->status_flags |= PARSER_NO_END_LABEL;\n\n  if (PARSER_IS_BASIC_OPCODE (last_opcode))\n  {\n    cbc_opcode_t opcode = (cbc_opcode_t) last_opcode;\n\n    JERRY_ASSERT (opcode < CBC_END);\n    flags = cbc_flags[opcode];\n\n    PARSER_APPEND_TO_BYTE_CODE (context_p, opcode);\n    context_p->byte_code_size++;\n  }\n  else\n  {\n    cbc_ext_opcode_t opcode = (cbc_ext_opcode_t) PARSER_GET_EXT_OPCODE (last_opcode);\n\n    JERRY_ASSERT (opcode < CBC_EXT_END);\n    flags = cbc_ext_flags[opcode];\n    parser_emit_two_bytes (context_p, CBC_EXT_OPCODE, (uint8_t) opcode);\n    context_p->byte_code_size += 2;\n  }\n\n  JERRY_ASSERT ((flags >> CBC_STACK_ADJUST_SHIFT) >= CBC_STACK_ADJUST_BASE\n                 || (CBC_STACK_ADJUST_BASE - (flags >> CBC_STACK_ADJUST_SHIFT)) <= context_p->stack_depth);\n  PARSER_PLUS_EQUAL_U16 (context_p->stack_depth, CBC_STACK_ADJUST_VALUE (flags));\n\n  if (flags & (CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2))\n  {\n    uint16_t literal_index = context_p->last_cbc.literal_index;\n\n    parser_emit_two_bytes (context_p,\n                           (uint8_t) (literal_index & 0xff),\n                           (uint8_t) (literal_index >> 8));\n    context_p->byte_code_size += 2;\n  }\n\n  if (flags & CBC_HAS_LITERAL_ARG2)\n  {\n    uint16_t literal_index = context_p->last_cbc.value;\n\n    parser_emit_two_bytes (context_p,\n                           (uint8_t) (literal_index & 0xff),\n                           (uint8_t) (literal_index >> 8));\n    context_p->byte_code_size += 2;\n\n    if (!(flags & CBC_HAS_LITERAL_ARG))\n    {\n      literal_index = context_p->last_cbc.third_literal_index;\n\n      parser_emit_two_bytes (context_p,\n                             (uint8_t) (literal_index & 0xff),\n                             (uint8_t) (literal_index >> 8));\n      context_p->byte_code_size += 2;\n    }\n  }\n\n  if (flags & CBC_HAS_BYTE_ARG)\n  {\n    uint8_t byte_argument = (uint8_t) context_p->last_cbc.value;\n\n    JERRY_ASSERT (context_p->last_cbc.value <= CBC_MAXIMUM_BYTE_VALUE);\n\n    if (flags & CBC_POP_STACK_BYTE_ARG)\n    {\n      JERRY_ASSERT (context_p->stack_depth >= byte_argument);\n      PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, byte_argument);\n    }\n\n    PARSER_APPEND_TO_BYTE_CODE (context_p, byte_argument);\n    context_p->byte_code_size++;\n  }\n\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n  if (context_p->is_show_opcodes)\n  {\n    JERRY_DEBUG_MSG (\"  [%3d] %s\",\n                     (int) context_p->stack_depth,\n                     PARSER_IS_BASIC_OPCODE (last_opcode) ? cbc_names[last_opcode]\n                                                          : cbc_ext_names[PARSER_GET_EXT_OPCODE (last_opcode)]);\n\n    if (flags & (CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2))\n    {\n      parser_print_literal (context_p, context_p->last_cbc.literal_index);\n    }\n\n    if (flags & CBC_HAS_LITERAL_ARG2)\n    {\n      parser_print_literal (context_p, context_p->last_cbc.value);\n\n      if (!(flags & CBC_HAS_LITERAL_ARG))\n      {\n        parser_print_literal (context_p, context_p->last_cbc.third_literal_index);\n      }\n    }\n\n    if (flags & CBC_HAS_BYTE_ARG)\n    {\n      if ((last_opcode == CBC_PUSH_NUMBER_POS_BYTE)\n          || (last_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE)))\n      {\n        JERRY_DEBUG_MSG (\" number:%d\", (int) context_p->last_cbc.value + 1);\n      }\n      else if ((last_opcode == CBC_PUSH_NUMBER_NEG_BYTE)\n               || (last_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_LITERAL_PUSH_NUMBER_NEG_BYTE)))\n      {\n        JERRY_DEBUG_MSG (\" number:%d\", -((int) context_p->last_cbc.value + 1));\n      }\n      else\n      {\n        JERRY_DEBUG_MSG (\" byte_arg:%d\", (int) context_p->last_cbc.value);\n      }\n    }\n\n    JERRY_DEBUG_MSG (\"\\n\");\n  }\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n\n  if (context_p->stack_depth > context_p->stack_limit)\n  {\n    context_p->stack_limit = context_p->stack_depth;\n    if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)\n    {\n      parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);\n    }\n  }\n\n  context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n}",
        "begin_line": 145,
        "end_line": 285,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_set_branch_to_current_position#717",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_set_branch_to_current_position (parser_context_t *context_p, /**< context */                                        parser_branch_t *branch_p) /**< branch result */",
        "snippet": "void\nparser_set_branch_to_current_position (parser_context_t *context_p, /**< context */\n                                       parser_branch_t *branch_p) /**< branch result */\n{\n  uint32_t delta;\n  size_t offset;\n  parser_mem_page_t *page_p = branch_p->page_p;\n\n  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)\n  {\n    parser_flush_cbc (context_p);\n  }\n\n  context_p->status_flags &= (uint32_t) ~PARSER_NO_END_LABEL;\n\n  JERRY_ASSERT (context_p->byte_code_size > (branch_p->offset >> 8));\n\n  delta = context_p->byte_code_size - (branch_p->offset >> 8);\n  offset = (branch_p->offset & CBC_LOWER_SEVEN_BIT_MASK);\n\n  JERRY_ASSERT (delta <= PARSER_MAXIMUM_CODE_SIZE);\n\n#if PARSER_MAXIMUM_CODE_SIZE <= UINT16_MAX\n  page_p->bytes[offset++] = (uint8_t) (delta >> 8);\n  if (offset >= PARSER_CBC_STREAM_PAGE_SIZE)\n  {\n    page_p = page_p->next_p;\n    offset = 0;\n  }\n#else /* PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX */\n  page_p->bytes[offset++] = (uint8_t) (delta >> 16);\n  if (offset >= PARSER_CBC_STREAM_PAGE_SIZE)\n  {\n    page_p = page_p->next_p;\n    offset = 0;\n  }\n  page_p->bytes[offset++] = (uint8_t) ((delta >> 8) & 0xff);\n  if (offset >= PARSER_CBC_STREAM_PAGE_SIZE)\n  {\n    page_p = page_p->next_p;\n    offset = 0;\n  }\n#endif /* PARSER_MAXIMUM_CODE_SIZE <= UINT16_MAX */\n  page_p->bytes[offset] = delta & 0xff;\n}",
        "begin_line": 717,
        "end_line": 761,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_set_breaks_to_current_position#766",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_set_breaks_to_current_position (parser_context_t *context_p, /**< context */                                        parser_branch_node_t *current_p) /**< branch list */",
        "snippet": "void\nparser_set_breaks_to_current_position (parser_context_t *context_p, /**< context */\n                                       parser_branch_node_t *current_p) /**< branch list */\n{\n  while (current_p != NULL)\n  {\n    parser_branch_node_t *next_p = current_p->next_p;\n\n    if (!(current_p->branch.offset & CBC_HIGHEST_BIT_MASK))\n    {\n      parser_set_branch_to_current_position (context_p, &current_p->branch);\n    }\n    parser_free (current_p, sizeof (parser_branch_node_t));\n    current_p = next_p;\n  }\n}",
        "begin_line": 766,
        "end_line": 781,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_set_continues_to_current_position#786",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_set_continues_to_current_position (parser_context_t *context_p, /**< context */                                           parser_branch_node_t *current_p) /**< branch list */",
        "snippet": "void\nparser_set_continues_to_current_position (parser_context_t *context_p, /**< context */\n                                          parser_branch_node_t *current_p) /**< branch list */\n{\n  while (current_p != NULL)\n  {\n    if (current_p->branch.offset & CBC_HIGHEST_BIT_MASK)\n    {\n      parser_set_branch_to_current_position (context_p, &current_p->branch);\n    }\n    current_p = current_p->next_p;\n  }\n}",
        "begin_line": 786,
        "end_line": 798,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parse_update_branches#375",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parse_update_branches (parser_context_t *context_p, /**< context */                        uint8_t *byte_code_p) /**< byte code */",
        "snippet": "static void\nparse_update_branches (parser_context_t *context_p, /**< context */\n                       uint8_t *byte_code_p) /**< byte code */\n{\n  parser_mem_page_t *page_p = context_p->byte_code.first_p;\n  parser_mem_page_t *prev_page_p = NULL;\n  parser_mem_page_t *last_page_p = context_p->byte_code.last_p;\n  size_t last_position = context_p->byte_code.last_position;\n  size_t offset = 0;\n  size_t bytes_copied = 0;\n\n  if (last_position >= PARSER_CBC_STREAM_PAGE_SIZE)\n  {\n    last_page_p = NULL;\n    last_position = 0;\n  }\n\n  while (page_p != last_page_p || offset < last_position)\n  {\n    /* Branch instructions are marked to improve search speed. */\n    if (page_p->bytes[offset] & CBC_HIGHEST_BIT_MASK)\n    {\n      uint8_t *bytes_p = byte_code_p + bytes_copied;\n      uint8_t flags;\n      uint8_t bytes_copied_before_jump = 0;\n      size_t branch_argument_length;\n      size_t target_distance;\n      size_t length;\n\n      if (offset > 0)\n      {\n        bytes_copied_before_jump = page_p->bytes[offset - 1] & CBC_LOWER_SEVEN_BIT_MASK;\n      }\n      bytes_p += bytes_copied_before_jump;\n\n      if (*bytes_p == CBC_EXT_OPCODE)\n      {\n        bytes_p++;\n        flags = cbc_ext_flags[*bytes_p];\n      }\n      else\n      {\n        flags = cbc_flags[*bytes_p];\n      }\n\n      JERRY_ASSERT (flags & CBC_HAS_BRANCH_ARG);\n      branch_argument_length = CBC_BRANCH_OFFSET_LENGTH (*bytes_p);\n      bytes_p++;\n\n      /* Decoding target. */\n      length = branch_argument_length;\n      target_distance = 0;\n      do\n      {\n        target_distance = (target_distance << 8) | *bytes_p;\n        bytes_p++;\n      }\n      while (--length > 0);\n\n      if (CBC_BRANCH_IS_FORWARD (flags))\n      {\n        /* Branch target was not set. */\n        JERRY_ASSERT (target_distance > 0);\n\n        target_distance = parser_update_forward_branch (page_p,\n                                                        offset + target_distance,\n                                                        bytes_copied_before_jump);\n      }\n      else\n      {\n        if (target_distance < offset)\n        {\n          uint8_t bytes_copied_before_target = page_p->bytes[offset - target_distance - 1];\n          bytes_copied_before_target = bytes_copied_before_target & CBC_LOWER_SEVEN_BIT_MASK;\n\n          target_distance = (size_t) (bytes_copied_before_jump - bytes_copied_before_target);\n        }\n        else if (target_distance == offset)\n        {\n          target_distance = bytes_copied_before_jump;\n        }\n        else\n        {\n          target_distance = parser_update_backward_branch (prev_page_p,\n                                                           target_distance - offset,\n                                                           bytes_copied_before_jump);\n        }\n      }\n\n      /* Encoding target again. */\n      do\n      {\n        bytes_p--;\n        *bytes_p = (uint8_t) (target_distance & 0xff);\n        target_distance >>= 8;\n      }\n      while (--branch_argument_length > 0);\n    }\n\n    offset++;\n    if (offset >= PARSER_CBC_STREAM_PAGE_SIZE)\n    {\n      parser_mem_page_t *next_p = page_p->next_p;\n\n      /* We reverse the pages before the current page. */\n      page_p->next_p = prev_page_p;\n      prev_page_p = page_p;\n\n      bytes_copied += page_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] & CBC_LOWER_SEVEN_BIT_MASK;\n      page_p = next_p;\n      offset = 0;\n    }\n  }\n\n  /* After this point the pages of the byte code stream are\n   * not used anymore. However, they needs to be freed during\n   * cleanup, so the first and last pointers of the stream\n   * descriptor are reversed as well. */\n  if (last_page_p != NULL)\n  {\n    JERRY_ASSERT (last_page_p == context_p->byte_code.last_p);\n    last_page_p->next_p = prev_page_p;\n  }\n  else\n  {\n    last_page_p = context_p->byte_code.last_p;\n  }\n\n  context_p->byte_code.last_p = context_p->byte_code.first_p;\n  context_p->byte_code.first_p = last_page_p;\n}",
        "begin_line": 375,
        "end_line": 505,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_compute_indicies#49",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_compute_indicies (parser_context_t *context_p, /**< context */                          uint16_t *ident_end, /**< end of the identifier group */                          uint16_t *const_literal_end) /**< end of the const literal group */",
        "snippet": "static void\nparser_compute_indicies (parser_context_t *context_p, /**< context */\n                         uint16_t *ident_end, /**< end of the identifier group */\n                         uint16_t *const_literal_end) /**< end of the const literal group */\n{\n  parser_list_iterator_t literal_iterator;\n  lexer_literal_t *literal_p;\n\n  uint16_t ident_count = 0;\n  uint16_t const_literal_count = 0;\n\n  uint16_t ident_index;\n  uint16_t const_literal_index;\n  uint16_t literal_index;\n\n  /* First phase: count the number of items in each group. */\n  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))\n  {\n    switch (literal_p->type)\n    {\n      case LEXER_IDENT_LITERAL:\n      {\n        if (literal_p->status_flags & LEXER_FLAG_USED)\n        {\n          ident_count++;\n          break;\n        }\n#if !ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n        else if (!(literal_p->status_flags & LEXER_FLAG_SOURCE_PTR))\n        {\n          jmem_heap_free_block ((void *) literal_p->u.char_p, literal_p->prop.length);\n          /* This literal should not be freed even if an error is encountered later. */\n          literal_p->status_flags |= LEXER_FLAG_SOURCE_PTR;\n        }\n#endif /* !ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n        continue;\n      }\n      case LEXER_STRING_LITERAL:\n      {\n        const_literal_count++;\n        break;\n      }\n      case LEXER_NUMBER_LITERAL:\n      {\n        const_literal_count++;\n        continue;\n      }\n      case LEXER_FUNCTION_LITERAL:\n      case LEXER_REGEXP_LITERAL:\n      {\n        continue;\n      }\n      default:\n      {\n        JERRY_ASSERT (literal_p->type == LEXER_UNUSED_LITERAL);\n        continue;\n      }\n    }\n\n#if !ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n    const uint8_t *char_p = literal_p->u.char_p;\n    uint32_t status_flags = context_p->status_flags;\n\n    if ((literal_p->status_flags & LEXER_FLAG_SOURCE_PTR)\n        && literal_p->prop.length < 0xfff)\n    {\n      size_t bytes_to_end = (size_t) (context_p->source_end_p - char_p);\n\n      if (bytes_to_end < 0xfffff)\n      {\n        literal_p->u.source_data = ((uint32_t) bytes_to_end) | (((uint32_t) literal_p->prop.length) << 20);\n        literal_p->status_flags |= LEXER_FLAG_LATE_INIT;\n        status_flags |= PARSER_HAS_LATE_LIT_INIT;\n        context_p->status_flags = status_flags;\n        char_p = NULL;\n      }\n    }\n\n    if (char_p != NULL)\n    {\n      literal_p->u.value = ecma_find_or_create_literal_string (char_p,\n                                                               literal_p->prop.length);\n\n      if (!(literal_p->status_flags & LEXER_FLAG_SOURCE_PTR))\n      {\n        jmem_heap_free_block ((void *) char_p, literal_p->prop.length);\n        /* This literal should not be freed even if an error is encountered later. */\n        literal_p->status_flags |= LEXER_FLAG_SOURCE_PTR;\n      }\n    }\n#endif /* !ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n  }\n\n  ident_index = context_p->register_count;\n  const_literal_index = (uint16_t) (ident_index + ident_count);\n  literal_index = (uint16_t) (const_literal_index + const_literal_count);\n\n  /* Second phase: Assign an index to each literal. */\n  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n\n  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))\n  {\n    switch (literal_p->type)\n    {\n      case LEXER_IDENT_LITERAL:\n      {\n        if (literal_p->status_flags & LEXER_FLAG_USED)\n        {\n          literal_p->prop.index = ident_index;\n          ident_index++;\n        }\n        break;\n      }\n      case LEXER_STRING_LITERAL:\n      case LEXER_NUMBER_LITERAL:\n      {\n        JERRY_ASSERT ((literal_p->status_flags & ~(LEXER_FLAG_SOURCE_PTR | LEXER_FLAG_LATE_INIT)) == 0);\n        literal_p->prop.index = const_literal_index;\n        const_literal_index++;\n        break;\n      }\n      case LEXER_FUNCTION_LITERAL:\n      case LEXER_REGEXP_LITERAL:\n      {\n        JERRY_ASSERT (literal_p->status_flags == 0);\n\n        literal_p->prop.index = literal_index;\n        literal_index++;\n        break;\n      }\n      default:\n      {\n        JERRY_ASSERT (literal_p->type == LEXER_UNUSED_LITERAL\n                      && literal_p->status_flags == LEXER_FLAG_FUNCTION_ARGUMENT);\n        break;\n      }\n    }\n  }\n\n  JERRY_ASSERT (ident_index == context_p->register_count + ident_count);\n  JERRY_ASSERT (const_literal_index == ident_index + const_literal_count);\n  JERRY_ASSERT (literal_index <= context_p->register_count + context_p->literal_count);\n\n  context_p->literal_count = literal_index;\n\n  *ident_end = ident_index;\n  *const_literal_end = const_literal_index;\n}",
        "begin_line": 49,
        "end_line": 197,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_free_literals#1690",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_free_literals (parser_list_t *literal_pool_p) /**< literals */",
        "snippet": "static void\nparser_free_literals (parser_list_t *literal_pool_p) /**< literals */\n{\n  parser_list_iterator_t literal_iterator;\n  lexer_literal_t *literal_p;\n\n  parser_list_iterator_init (literal_pool_p, &literal_iterator);\n  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n    util_free_literal (literal_p);\n  }\n\n  parser_list_free (literal_pool_p);\n}",
        "begin_line": 1690,
        "end_line": 1703,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_init_literal_pool#202",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_init_literal_pool (parser_context_t *context_p, /**< context */                           ecma_value_t *literal_pool_p) /**< start of literal pool */",
        "snippet": "static void\nparser_init_literal_pool (parser_context_t *context_p, /**< context */\n                          ecma_value_t *literal_pool_p) /**< start of literal pool */\n{\n  parser_list_iterator_t literal_iterator;\n  lexer_literal_t *literal_p;\n\n  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n\n  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))\n  {\n    switch (literal_p->type)\n    {\n      case LEXER_IDENT_LITERAL:\n      {\n        if (!(literal_p->status_flags & LEXER_FLAG_USED))\n        {\n          break;\n        }\n        /* FALLTHRU */\n      }\n      case LEXER_STRING_LITERAL:\n      {\n        ecma_value_t lit_value;\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n        lit_value = ecma_find_or_create_literal_string (literal_p->u.char_p,\n                                                        literal_p->prop.length);\n#else /* !ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n        lit_value = literal_p->u.value;\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n\n        JERRY_ASSERT (literal_p->prop.index >= context_p->register_count);\n        literal_pool_p[literal_p->prop.index] = lit_value;\n\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n        if (!context_p->is_show_opcodes\n            && !(literal_p->status_flags & LEXER_FLAG_SOURCE_PTR))\n        {\n          jmem_heap_free_block ((void *) literal_p->u.char_p, literal_p->prop.length);\n        }\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n        break;\n      }\n      case LEXER_NUMBER_LITERAL:\n      {\n        JERRY_ASSERT (literal_p->prop.index >= context_p->register_count);\n\n        literal_pool_p[literal_p->prop.index] = literal_p->u.value;\n        break;\n      }\n      case LEXER_FUNCTION_LITERAL:\n      case LEXER_REGEXP_LITERAL:\n      {\n        JERRY_ASSERT (literal_p->prop.index >= context_p->register_count);\n\n        ECMA_SET_INTERNAL_VALUE_POINTER (literal_pool_p[literal_p->prop.index],\n                                         literal_p->u.bytecode_p);\n        break;\n      }\n      default:\n      {\n        JERRY_ASSERT (literal_p->type == LEXER_UNUSED_LITERAL);\n        break;\n      }\n    }\n  }\n}",
        "begin_line": 202,
        "end_line": 268,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_parse_function#2403",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_parse_function (parser_context_t *context_p, /**< context */                        uint32_t status_flags) /**< extra status flags */",
        "snippet": "ecma_compiled_code_t *\nparser_parse_function (parser_context_t *context_p, /**< context */\n                       uint32_t status_flags) /**< extra status flags */\n{\n  parser_saved_context_t saved_context;\n  ecma_compiled_code_t *compiled_code_p;\n\n  JERRY_ASSERT (status_flags & PARSER_IS_FUNCTION);\n  parser_save_context (context_p, &saved_context);\n  context_p->status_flags |= status_flags;\n#if ENABLED (JERRY_ES2015)\n  context_p->status_flags |= PARSER_ALLOW_NEW_TARGET;\n#endif /* ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n  if (context_p->is_show_opcodes)\n  {\n#if ENABLED (JERRY_ES2015)\n    JERRY_DEBUG_MSG (\"\\n--- %s parsing start ---\\n\\n\",\n                     (context_p->status_flags & PARSER_CLASS_CONSTRUCTOR) ? \"Class constructor\"\n                                                                          : \"Function\");\n#else /* !ENABLED (JERRY_ES2015) */\n    JERRY_DEBUG_MSG (\"\\n--- Function parsing start ---\\n\\n\");\n#endif /* ENABLED (JERRY_ES2015) */\n  }\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n\n#if ENABLED (JERRY_DEBUGGER)\n  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n  {\n    jerry_debugger_send_parse_function (context_p->token.line, context_p->token.column);\n  }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n  lexer_next_token (context_p);\n\n  if (context_p->token.type != LEXER_LEFT_PAREN)\n  {\n    parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIST_EXPECTED);\n  }\n\n  lexer_next_token (context_p);\n\n  parser_parse_function_arguments (context_p, LEXER_RIGHT_PAREN);\n  lexer_next_token (context_p);\n\n  if ((context_p->status_flags & PARSER_IS_PROPERTY_GETTER)\n      && context_p->argument_count != 0)\n  {\n    parser_raise_error (context_p, PARSER_ERR_NO_ARGUMENTS_EXPECTED);\n  }\n\n  if ((context_p->status_flags & PARSER_IS_PROPERTY_SETTER)\n      && context_p->argument_count != 1)\n  {\n    parser_raise_error (context_p, PARSER_ERR_ONE_ARGUMENT_EXPECTED);\n  }\n\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n  if (context_p->is_show_opcodes\n      && (context_p->status_flags & PARSER_HAS_NON_STRICT_ARG))\n  {\n    JERRY_DEBUG_MSG (\"  Note: legacy (non-strict) argument definition\\n\\n\");\n  }\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n\n  if (context_p->token.type != LEXER_LEFT_BRACE)\n  {\n    parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_EXPECTED);\n  }\n\n  lexer_next_token (context_p);\n  parser_parse_statements (context_p);\n  compiled_code_p = parser_post_processing (context_p);\n\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n  if (context_p->is_show_opcodes)\n  {\n#if ENABLED (JERRY_ES2015)\n    JERRY_DEBUG_MSG (\"\\n--- %s parsing end ---\\n\\n\",\n                     (context_p->status_flags & PARSER_CLASS_CONSTRUCTOR) ? \"Class constructor\"\n                                                                          : \"Function\");\n#else /* !ENABLED (JERRY_ES2015) */\n    JERRY_DEBUG_MSG (\"\\n--- Function parsing end ---\\n\\n\");\n#endif /* ENABLED (JERRY_ES2015) */\n  }\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n\n  parser_restore_context (context_p, &saved_context);\n\n  return compiled_code_p;\n}",
        "begin_line": 2403,
        "end_line": 2494,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_parse_function_arguments#1708",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_parse_function_arguments (parser_context_t *context_p, /**< context */                                  lexer_token_type_t end_type) /**< expected end type */",
        "snippet": "static void\nparser_parse_function_arguments (parser_context_t *context_p, /**< context */\n                                 lexer_token_type_t end_type) /**< expected end type */\n{\n  JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);\n\n#if ENABLED (JERRY_ES2015)\n  JERRY_ASSERT (context_p->status_flags & PARSER_IS_FUNCTION);\n  JERRY_ASSERT (!(context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED));\n\n  bool has_duplicated_arg_names = false;\n\n  /* TODO: Currently async iterators are not supported, so generators ignore the async modifier. */\n  uint32_t mask = (PARSER_IS_GENERATOR_FUNCTION | PARSER_IS_ASYNC_FUNCTION);\n  if ((context_p->status_flags & mask) == mask)\n  {\n    context_p->status_flags &= (uint32_t) ~PARSER_IS_ASYNC_FUNCTION;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  if (context_p->token.type == end_type)\n  {\n#if ENABLED (JERRY_ES2015)\n    if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)\n    {\n      parser_emit_cbc_ext (context_p, CBC_EXT_CREATE_GENERATOR);\n      parser_emit_cbc (context_p, CBC_POP);\n    }\n\n    context_p->status_flags &= (uint32_t) ~PARSER_DISALLOW_AWAIT_YIELD;\n#endif /* ENABLED (JERRY_ES2015) */\n    scanner_create_variables (context_p, SCANNER_CREATE_VARS_NO_OPTS);\n    return;\n  }\n\n#if ENABLED (JERRY_ES2015)\n  bool has_mapped_arguments = (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_MAPPED_ARGUMENTS) != 0;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  scanner_create_variables (context_p, SCANNER_CREATE_VARS_IS_FUNCTION_ARGS);\n  scanner_set_active (context_p);\n\n#if ENABLED (JERRY_ES2015)\n  context_p->status_flags |= PARSER_FUNCTION_IS_PARSING_ARGS;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  while (true)\n  {\n#if ENABLED (JERRY_ES2015)\n    if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)\n    {\n      parser_raise_error (context_p, PARSER_ERR_FORMAL_PARAM_AFTER_REST_PARAMETER);\n    }\n    else if (context_p->token.type == LEXER_THREE_DOTS)\n    {\n      if (context_p->status_flags & PARSER_IS_PROPERTY_SETTER)\n      {\n        parser_raise_error (context_p, PARSER_ERR_SETTER_REST_PARAMETER);\n      }\n      lexer_next_token (context_p);\n\n      if (has_duplicated_arg_names)\n      {\n        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);\n      }\n\n      context_p->status_flags |= PARSER_FUNCTION_HAS_REST_PARAM | PARSER_FUNCTION_HAS_NON_SIMPLE_PARAM;\n    }\n\n    if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)\n    {\n      if (has_duplicated_arg_names)\n      {\n        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);\n      }\n\n      context_p->status_flags |= PARSER_FUNCTION_HAS_NON_SIMPLE_PARAM;\n\n      parser_emit_cbc_literal (context_p,\n                               CBC_PUSH_LITERAL,\n                               (uint16_t) (PARSER_REGISTER_START + context_p->argument_count));\n\n      uint32_t flags = (PARSER_PATTERN_BINDING\n                        | PARSER_PATTERN_TARGET_ON_STACK\n                        | PARSER_PATTERN_LOCAL\n                        | PARSER_PATTERN_ARGUMENTS);\n\n      if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n      {\n        JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER);\n\n        if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)\n        {\n          parser_raise_error (context_p, PARSER_ERR_REST_PARAMETER_DEFAULT_INITIALIZER);\n        }\n\n        flags |= PARSER_PATTERN_TARGET_DEFAULT;\n      }\n\n      parser_parse_initializer (context_p, flags);\n\n      context_p->argument_count++;\n      if (context_p->argument_count >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)\n      {\n        parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);\n      }\n\n      if (context_p->token.type != LEXER_COMMA)\n      {\n        break;\n      }\n\n      lexer_next_token (context_p);\n      continue;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    if (context_p->token.type != LEXER_LITERAL\n        || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n    {\n      parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);\n    }\n\n    lexer_construct_literal_object (context_p,\n                                    &context_p->token.lit_location,\n                                    LEXER_IDENT_LITERAL);\n\n    if (context_p->token.keyword_type >= LEXER_FIRST_NON_STRICT_ARGUMENTS)\n    {\n      context_p->status_flags |= PARSER_HAS_NON_STRICT_ARG;\n    }\n\n    if (JERRY_UNLIKELY (context_p->lit_object.literal_p->status_flags & LEXER_FLAG_FUNCTION_ARGUMENT))\n    {\n#if ENABLED (JERRY_ES2015)\n      if ((context_p->status_flags & PARSER_FUNCTION_HAS_NON_SIMPLE_PARAM)\n          || (context_p->status_flags & PARSER_IS_ARROW_FUNCTION))\n      {\n        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);\n      }\n      has_duplicated_arg_names = true;\n#endif /* ENABLED (JERRY_ES2015) */\n\n      context_p->status_flags |= PARSER_HAS_NON_STRICT_ARG;\n    }\n    else\n    {\n      context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_FUNCTION_ARGUMENT;\n    }\n\n    lexer_next_token (context_p);\n\n#if ENABLED (JERRY_ES2015)\n    uint16_t literal_index = context_p->lit_object.index;\n\n    if (context_p->token.type == LEXER_ASSIGN)\n    {\n      JERRY_ASSERT (!has_mapped_arguments);\n\n      if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)\n      {\n        parser_raise_error (context_p, PARSER_ERR_REST_PARAMETER_DEFAULT_INITIALIZER);\n      }\n\n      parser_branch_t skip_init;\n\n      if (has_duplicated_arg_names)\n      {\n        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);\n      }\n\n      context_p->status_flags |= PARSER_FUNCTION_HAS_NON_SIMPLE_PARAM;\n\n      /* LEXER_ASSIGN does not overwrite lit_object. */\n      parser_emit_cbc_literal (context_p,\n                               CBC_PUSH_LITERAL,\n                               (uint16_t) (PARSER_REGISTER_START + context_p->argument_count));\n      parser_emit_cbc_ext_forward_branch (context_p, CBC_EXT_DEFAULT_INITIALIZER, &skip_init);\n\n      lexer_next_token (context_p);\n      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);\n\n      parser_set_branch_to_current_position (context_p, &skip_init);\n\n      uint16_t opcode = CBC_ASSIGN_LET_CONST;\n\n      if (literal_index >= PARSER_REGISTER_START)\n      {\n        opcode = CBC_ASSIGN_SET_IDENT;\n      }\n      else if (!scanner_literal_is_created (context_p, literal_index))\n      {\n        opcode = CBC_INIT_ARG_OR_CATCH;\n      }\n\n      parser_emit_cbc_literal (context_p, opcode, literal_index);\n    }\n    else if (!has_mapped_arguments && literal_index < PARSER_REGISTER_START)\n    {\n      uint16_t opcode = CBC_INIT_ARG_OR_FUNC;\n\n      if (scanner_literal_is_created (context_p, literal_index))\n      {\n        opcode = CBC_ASSIGN_LET_CONST_LITERAL;\n      }\n\n      parser_emit_cbc_literal_value (context_p,\n                                     opcode,\n                                     (uint16_t) (PARSER_REGISTER_START + context_p->argument_count),\n                                     literal_index);\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    context_p->argument_count++;\n    if (context_p->argument_count >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)\n    {\n      parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);\n    }\n\n    if (context_p->token.type != LEXER_COMMA)\n    {\n      break;\n    }\n\n    lexer_next_token (context_p);\n  }\n\n  if (context_p->token.type != end_type)\n  {\n    parser_error_t error = ((end_type == LEXER_RIGHT_PAREN) ? PARSER_ERR_RIGHT_PAREN_EXPECTED\n                                                            : PARSER_ERR_IDENTIFIER_EXPECTED);\n\n    parser_raise_error (context_p, error);\n  }\n\n  scanner_revert_active (context_p);\n\n#if ENABLED (JERRY_ES2015)\n  JERRY_ASSERT (!has_mapped_arguments || !(context_p->status_flags & PARSER_FUNCTION_HAS_NON_SIMPLE_PARAM));\n\n  if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)\n  {\n    parser_emit_cbc_ext (context_p, CBC_EXT_CREATE_GENERATOR);\n    parser_emit_cbc (context_p, CBC_POP);\n  }\n\n  if (context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED)\n  {\n    if ((context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_LEXICAL_ENV_NEEDED)\n        || scanner_is_context_needed (context_p, PARSER_CHECK_FUNCTION_CONTEXT))\n    {\n      context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;\n\n      parser_branch_t branch;\n      parser_emit_cbc_forward_branch (context_p, CBC_BLOCK_CREATE_CONTEXT, &branch);\n      parser_stack_push (context_p, &branch, sizeof (parser_branch_t));\n\n#ifndef JERRY_NDEBUG\n      context_p->context_stack_depth = PARSER_BLOCK_CONTEXT_STACK_ALLOCATION;\n#endif /* !JERRY_NDEBUG */\n    }\n    else\n    {\n      context_p->status_flags &= (uint32_t) ~PARSER_LEXICAL_BLOCK_NEEDED;\n    }\n  }\n\n  context_p->status_flags &= (uint32_t) ~(PARSER_DISALLOW_AWAIT_YIELD | PARSER_FUNCTION_IS_PARSING_ARGS);\n#endif /* ENABLED (JERRY_ES2015) */\n\n  scanner_create_variables (context_p, SCANNER_CREATE_VARS_IS_FUNCTION_BODY);\n}",
        "begin_line": 1708,
        "end_line": 1979,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_parse_script#2676",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_parse_script (const uint8_t *arg_list_p, /**< function argument list */                      size_t arg_list_size, /**< size of function argument list */                      const uint8_t *source_p, /**< source code */                      size_t source_size, /**< size of the source code */                      uint32_t parse_opts, /**< ecma_parse_opts_t option bits */                      ecma_compiled_code_t **bytecode_data_p) /**< [out] JS bytecode */",
        "snippet": "ecma_value_t\nparser_parse_script (const uint8_t *arg_list_p, /**< function argument list */\n                     size_t arg_list_size, /**< size of function argument list */\n                     const uint8_t *source_p, /**< source code */\n                     size_t source_size, /**< size of the source code */\n                     uint32_t parse_opts, /**< ecma_parse_opts_t option bits */\n                     ecma_compiled_code_t **bytecode_data_p) /**< [out] JS bytecode */\n{\n#if ENABLED (JERRY_PARSER)\n  parser_error_location_t parser_error;\n\n#if ENABLED (JERRY_DEBUGGER)\n  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n  {\n    jerry_debugger_send_string (JERRY_DEBUGGER_SOURCE_CODE,\n                                JERRY_DEBUGGER_NO_SUBTYPE,\n                                source_p,\n                                source_size);\n  }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n  *bytecode_data_p = parser_parse_source (arg_list_p,\n                                          arg_list_size,\n                                          source_p,\n                                          source_size,\n                                          parse_opts,\n                                          &parser_error);\n\n  if (!*bytecode_data_p)\n  {\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n    if (JERRY_CONTEXT (module_top_context_p) != NULL)\n    {\n      ecma_module_cleanup ();\n    }\n#endif\n#if ENABLED (JERRY_DEBUGGER)\n    if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n    {\n      jerry_debugger_send_type (JERRY_DEBUGGER_PARSE_ERROR);\n    }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n    if (parser_error.error == PARSER_ERR_OUT_OF_MEMORY)\n    {\n      /* It is unlikely that memory can be allocated in an out-of-memory\n       * situation. However, a simple value can still be thrown. */\n      jcontext_raise_exception (ECMA_VALUE_NULL);\n      return ECMA_VALUE_ERROR;\n    }\n\n    if (parser_error.error == PARSER_ERR_INVALID_REGEXP)\n    {\n      /* The RegExp compiler has already raised an exception. */\n      JERRY_ASSERT (jcontext_has_pending_exception ());\n      return ECMA_VALUE_ERROR;\n    }\n\n#if ENABLED (JERRY_ERROR_MESSAGES)\n    const lit_utf8_byte_t *err_bytes_p = (const lit_utf8_byte_t *) parser_error_to_string (parser_error.error);\n    lit_utf8_size_t err_bytes_size = lit_zt_utf8_string_size (err_bytes_p);\n\n    ecma_string_t *err_str_p = ecma_new_ecma_string_from_utf8 (err_bytes_p, err_bytes_size);\n    ecma_value_t err_str_val = ecma_make_string_value (err_str_p);\n    ecma_value_t line_str_val = ecma_make_uint32_value (parser_error.line);\n    ecma_value_t col_str_val = ecma_make_uint32_value (parser_error.column);\n\n    ecma_value_t error_value = ecma_raise_standard_error_with_format (ECMA_ERROR_SYNTAX,\n                                                                      \"% [%:%:%]\",\n                                                                      err_str_val,\n                                                                      JERRY_CONTEXT (resource_name),\n                                                                      line_str_val,\n                                                                      col_str_val);\n\n    ecma_free_value (col_str_val);\n    ecma_free_value (line_str_val);\n    ecma_free_value (err_str_val);\n\n    return error_value;\n#else /* !ENABLED (JERRY_ERROR_MESSAGES) */\n    return ecma_raise_syntax_error (\"\");\n#endif /* ENABLED (JERRY_ERROR_MESSAGES) */\n  }\n\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n  if (JERRY_CONTEXT (module_top_context_p) != NULL)\n  {\n    ecma_value_t ret_value = ecma_module_parse_modules ();\n\n    if (ECMA_IS_VALUE_ERROR (ret_value))\n    {\n      ecma_bytecode_deref (*bytecode_data_p);\n      *bytecode_data_p = NULL;\n      ecma_module_cleanup ();\n\n      return ret_value;\n    }\n  }\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n#if ENABLED (JERRY_DEBUGGER)\n  if ((JERRY_CONTEXT (debugger_flags) & (JERRY_DEBUGGER_CONNECTED | JERRY_DEBUGGER_PARSER_WAIT))\n      == (JERRY_DEBUGGER_CONNECTED | JERRY_DEBUGGER_PARSER_WAIT))\n  {\n    JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_PARSER_WAIT_MODE);\n    jerry_debugger_send_type (JERRY_DEBUGGER_WAITING_AFTER_PARSE);\n\n    while (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_PARSER_WAIT_MODE)\n    {\n      jerry_debugger_receive (NULL);\n\n      if (!(JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED))\n      {\n        break;\n      }\n\n      jerry_debugger_transport_sleep ();\n    }\n  }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n  return ECMA_VALUE_TRUE;\n#else /* !ENABLED (JERRY_PARSER) */\n  JERRY_UNUSED (arg_list_p);\n  JERRY_UNUSED (arg_list_size);\n  JERRY_UNUSED (source_p);\n  JERRY_UNUSED (source_size);\n  JERRY_UNUSED (parse_opts);\n  JERRY_UNUSED (bytecode_data_p);\n\n  return ecma_raise_syntax_error (ECMA_ERR_MSG (\"The parser has been disabled.\"));\n#endif /* ENABLED (JERRY_PARSER) */\n}",
        "begin_line": 2676,
        "end_line": 2808,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_parse_source#1993",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_parse_source (const uint8_t *arg_list_p, /**< function argument list */                      size_t arg_list_size, /**< size of function argument list */                      const uint8_t *source_p, /**< valid UTF-8 source code */                      size_t source_size, /**< size of the source code */                      uint32_t parse_opts, /**< ecma_parse_opts_t option bits */                      parser_error_location_t *error_location_p) /**< error location */",
        "snippet": "static ecma_compiled_code_t *\nparser_parse_source (const uint8_t *arg_list_p, /**< function argument list */\n                     size_t arg_list_size, /**< size of function argument list */\n                     const uint8_t *source_p, /**< valid UTF-8 source code */\n                     size_t source_size, /**< size of the source code */\n                     uint32_t parse_opts, /**< ecma_parse_opts_t option bits */\n                     parser_error_location_t *error_location_p) /**< error location */\n{\n  parser_context_t context;\n  ecma_compiled_code_t *compiled_code_p;\n\n  context.error = PARSER_ERR_NO_ERROR;\n\n  if (error_location_p != NULL)\n  {\n    error_location_p->error = PARSER_ERR_NO_ERROR;\n  }\n\n  context.status_flags = parse_opts & PARSER_STRICT_MODE_MASK;\n  context.global_status_flags = parse_opts;\n\n  if (arg_list_p != NULL)\n  {\n    context.status_flags |= PARSER_IS_FUNCTION;\n#if ENABLED (JERRY_ES2015)\n    if (parse_opts & ECMA_PARSE_GENERATOR_FUNCTION)\n    {\n      context.status_flags |= PARSER_IS_GENERATOR_FUNCTION;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n  }\n\n#if ENABLED (JERRY_ES2015)\n  context.status_flags |= PARSER_GET_SAVED_FLAGS (parse_opts);\n  context.tagged_template_literal_cp = JMEM_CP_NULL;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  context.stack_depth = 0;\n  context.stack_limit = 0;\n  context.last_context_p = NULL;\n  context.last_statement.current_p = NULL;\n\n  context.token.flags = 0;\n  context.line = 1;\n  context.column = 1;\n\n  scanner_info_t scanner_info_end;\n  scanner_info_end.next_p = NULL;\n  scanner_info_end.source_p = NULL;\n  scanner_info_end.type = SCANNER_TYPE_END;\n  context.next_scanner_info_p = &scanner_info_end;\n  context.active_scanner_info_p = NULL;\n  context.skipped_scanner_info_p = NULL;\n  context.skipped_scanner_info_end_p = NULL;\n\n  context.last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n\n  context.argument_count = 0;\n  context.register_count = 0;\n  context.literal_count = 0;\n\n  parser_cbc_stream_init (&context.byte_code);\n  context.byte_code_size = 0;\n  parser_list_init (&context.literal_pool,\n                    sizeof (lexer_literal_t),\n                    (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_literal_t)));\n  context.scope_stack_p = NULL;\n  context.scope_stack_size = 0;\n  context.scope_stack_top = 0;\n  context.scope_stack_reg_top = 0;\n#if ENABLED (JERRY_ES2015)\n  context.scope_stack_global_end = 0;\n  context.tagged_template_literal_cp = JMEM_CP_NULL;\n#endif /* ENABLED (JERRY_ES2015) */\n\n#ifndef JERRY_NDEBUG\n  context.context_stack_depth = 0;\n#endif /* !JERRY_NDEBUG */\n\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n  context.is_show_opcodes = (JERRY_CONTEXT (jerry_init_flags) & ECMA_INIT_SHOW_OPCODES);\n  context.total_byte_code_size = 0;\n\n  if (context.is_show_opcodes)\n  {\n    JERRY_DEBUG_MSG (\"\\n--- %s parsing start ---\\n\\n\",\n                     (arg_list_p == NULL) ? \"Script\"\n                                          : \"Function\");\n  }\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n\n  scanner_scan_all (&context,\n                    arg_list_p,\n                    arg_list_p + arg_list_size,\n                    source_p,\n                    source_p + source_size);\n\n  if (JERRY_UNLIKELY (context.error != PARSER_ERR_NO_ERROR))\n  {\n    JERRY_ASSERT (context.error == PARSER_ERR_OUT_OF_MEMORY);\n\n    if (error_location_p != NULL)\n    {\n      error_location_p->error = context.error;\n      error_location_p->line = context.token.line;\n      error_location_p->column = context.token.column;\n    }\n    return NULL;\n  }\n\n  if (arg_list_p == NULL)\n  {\n    context.source_p = source_p;\n    context.source_end_p = source_p + source_size;\n  }\n  else\n  {\n    context.source_p = arg_list_p;\n    context.source_end_p = arg_list_p + arg_list_size;\n  }\n\n  context.u.allocated_buffer_p = NULL;\n  context.line = 1;\n  context.column = 1;\n  context.token.flags = 0;\n\n  parser_stack_init (&context);\n\n#if ENABLED (JERRY_DEBUGGER)\n  context.breakpoint_info_count = 0;\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n  if (context.global_status_flags & ECMA_PARSE_MODULE)\n  {\n    context.status_flags |= PARSER_IS_STRICT;\n  }\n\n  context.module_current_node_p = NULL;\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n  PARSER_TRY (context.try_buffer)\n  {\n    /* Pushing a dummy value ensures the stack is never empty.\n     * This simplifies the stack management routines. */\n    parser_stack_push_uint8 (&context, CBC_MAXIMUM_BYTE_VALUE);\n    /* The next token must always be present to make decisions\n     * in the parser. Therefore when a token is consumed, the\n     * lexer_next_token() must be immediately called. */\n    lexer_next_token (&context);\n\n    if (arg_list_p != NULL)\n    {\n      parser_parse_function_arguments (&context, LEXER_EOS);\n\n      JERRY_ASSERT (context.next_scanner_info_p->type == SCANNER_TYPE_END_ARGUMENTS);\n      scanner_release_next (&context, sizeof (scanner_info_t));\n\n      context.source_p = source_p;\n      context.source_end_p = source_p + source_size;\n      context.line = 1;\n      context.column = 1;\n\n      lexer_next_token (&context);\n    }\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n    else if (parse_opts & ECMA_PARSE_MODULE)\n    {\n      scanner_create_variables (&context, SCANNER_CREATE_VARS_NO_OPTS);\n    }\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n    else\n    {\n      JERRY_ASSERT (context.next_scanner_info_p->source_p == source_p\n                    && context.next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);\n\n#if ENABLED (JERRY_ES2015)\n      if (scanner_is_context_needed (&context, PARSER_CHECK_GLOBAL_CONTEXT))\n      {\n        context.status_flags |= PARSER_LEXICAL_BLOCK_NEEDED;\n      }\n\n      if ((parse_opts & ECMA_PARSE_EVAL) == 0)\n      {\n        scanner_check_variables (&context);\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scanner_create_variables (&context, SCANNER_CREATE_VARS_IS_SCRIPT);\n    }\n\n    parser_parse_statements (&context);\n\n    JERRY_ASSERT (context.last_statement.current_p == NULL);\n\n    JERRY_ASSERT (context.last_cbc_opcode == PARSER_CBC_UNAVAILABLE);\n    JERRY_ASSERT (context.u.allocated_buffer_p == NULL);\n\n#ifndef JERRY_NDEBUG\n    JERRY_ASSERT (context.status_flags & PARSER_SCANNING_SUCCESSFUL);\n    JERRY_ASSERT (!(context.global_status_flags & ECMA_PARSE_INTERNAL_FOR_IN_OFF_CONTEXT_ERROR));\n    context.status_flags &= (uint32_t) ~PARSER_SCANNING_SUCCESSFUL;\n#endif /* !JERRY_NDEBUG */\n\n    JERRY_ASSERT (!(context.status_flags & PARSER_HAS_LATE_LIT_INIT));\n\n    compiled_code_p = parser_post_processing (&context);\n    parser_list_free (&context.literal_pool);\n\n    /* When parsing is successful, only the dummy value can be remained on the stack. */\n    JERRY_ASSERT (context.stack_top_uint8 == CBC_MAXIMUM_BYTE_VALUE\n                  && context.stack.last_position == 1\n                  && context.stack.first_p != NULL\n                  && context.stack.first_p->next_p == NULL\n                  && context.stack.last_p == NULL);\n\n    JERRY_ASSERT (arg_list_p != NULL || !(context.status_flags & PARSER_ARGUMENTS_NEEDED));\n\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n    if (context.is_show_opcodes)\n    {\n      JERRY_DEBUG_MSG (\"\\n%s parsing successfully completed. Total byte code size: %d bytes\\n\",\n                       (arg_list_p == NULL) ? \"Script\"\n                                            : \"Function\",\n                       (int) context.total_byte_code_size);\n    }\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n  }\n  PARSER_CATCH\n  {\n    if (context.last_statement.current_p != NULL)\n    {\n      parser_free_jumps (context.last_statement);\n    }\n\n    parser_free_allocated_buffer (&context);\n\n    scanner_cleanup (&context);\n\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n    if (context.module_current_node_p != NULL)\n    {\n      ecma_module_release_module_nodes (context.module_current_node_p);\n    }\n#endif\n\n    if (error_location_p != NULL)\n    {\n      error_location_p->error = context.error;\n      error_location_p->line = context.token.line;\n      error_location_p->column = context.token.column;\n    }\n\n    compiled_code_p = NULL;\n    parser_free_literals (&context.literal_pool);\n    parser_cbc_stream_free (&context.byte_code);\n  }\n  PARSER_TRY_END\n\n  if (context.scope_stack_p != NULL)\n  {\n    parser_free (context.scope_stack_p, context.scope_stack_size * sizeof (parser_scope_stack_t));\n  }\n\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n  if (context.is_show_opcodes)\n  {\n    JERRY_DEBUG_MSG (\"\\n--- %s parsing end ---\\n\\n\",\n                     (arg_list_p == NULL) ? \"Script\"\n                                          : \"Function\");\n  }\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n\n  parser_stack_free (&context);\n\n  return compiled_code_p;\n}",
        "begin_line": 1993,
        "end_line": 2269,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_post_processing#897",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_post_processing (parser_context_t *context_p) /**< context */",
        "snippet": "static ecma_compiled_code_t *\nparser_post_processing (parser_context_t *context_p) /**< context */\n{\n  uint16_t literal_one_byte_limit;\n  uint16_t ident_end;\n  uint16_t const_literal_end;\n  parser_mem_page_t *page_p;\n  parser_mem_page_t *last_page_p;\n  size_t last_position;\n  size_t offset;\n  size_t length;\n  size_t literal_length;\n  size_t total_size;\n#if ENABLED (JERRY_SNAPSHOT_SAVE)\n  size_t total_size_used;\n#endif /* ENABLED (JERRY_SNAPSHOT_SAVE) */\n  uint8_t real_offset;\n  uint8_t *byte_code_p;\n  bool needs_uint16_arguments;\n  cbc_opcode_t last_opcode = CBC_EXT_OPCODE;\n  ecma_compiled_code_t *compiled_code_p;\n  ecma_value_t *literal_pool_p;\n  uint8_t *dst_p;\n\n#if ENABLED (JERRY_ES2015)\n  if ((context_p->status_flags & (PARSER_IS_FUNCTION | PARSER_LEXICAL_BLOCK_NEEDED))\n      == (PARSER_IS_FUNCTION | PARSER_LEXICAL_BLOCK_NEEDED))\n  {\n    PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);\n#ifndef JERRY_NDEBUG\n    PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);\n#endif /* !JERRY_NDEBUG */\n\n    context_p->status_flags &= (uint32_t) ~PARSER_LEXICAL_BLOCK_NEEDED;\n\n    parser_emit_cbc (context_p, CBC_CONTEXT_END);\n\n    parser_branch_t branch;\n    parser_stack_pop (context_p, &branch, sizeof (parser_branch_t));\n    parser_set_branch_to_current_position (context_p, &branch);\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  JERRY_ASSERT (context_p->stack_depth == 0);\n#ifndef JERRY_NDEBUG\n  JERRY_ASSERT (context_p->context_stack_depth == 0);\n#endif /* !JERRY_NDEBUG */\n\n  if ((size_t) context_p->stack_limit + (size_t) context_p->register_count > PARSER_MAXIMUM_STACK_LIMIT)\n  {\n    parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);\n  }\n\n  JERRY_ASSERT (context_p->literal_count <= PARSER_MAXIMUM_NUMBER_OF_LITERALS);\n\n#if ENABLED (JERRY_DEBUGGER)\n  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n      && !(context_p->status_flags & PARSER_DEBUGGER_BREAKPOINT_APPENDED))\n  {\n    /* Always provide at least one breakpoint. */\n    parser_emit_cbc (context_p, CBC_BREAKPOINT_DISABLED);\n    parser_flush_cbc (context_p);\n\n    parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST, context_p->token.line);\n\n    context_p->last_breakpoint_line = context_p->token.line;\n  }\n\n  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n      && context_p->breakpoint_info_count > 0)\n  {\n    parser_send_breakpoints (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST);\n    JERRY_ASSERT (context_p->breakpoint_info_count == 0);\n  }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n  parser_compute_indicies (context_p, &ident_end, &const_literal_end);\n\n  if (context_p->literal_count <= CBC_MAXIMUM_SMALL_VALUE)\n  {\n    literal_one_byte_limit = CBC_MAXIMUM_BYTE_VALUE - 1;\n  }\n  else\n  {\n    literal_one_byte_limit = CBC_LOWER_SEVEN_BIT_MASK;\n  }\n\n  last_page_p = context_p->byte_code.last_p;\n  last_position = context_p->byte_code.last_position;\n\n  if (last_position >= PARSER_CBC_STREAM_PAGE_SIZE)\n  {\n    last_page_p = NULL;\n    last_position = 0;\n  }\n\n  page_p = context_p->byte_code.first_p;\n  offset = 0;\n  length = 0;\n\n  while (page_p != last_page_p || offset < last_position)\n  {\n    uint8_t *opcode_p;\n    uint8_t flags;\n    size_t branch_offset_length;\n\n    opcode_p = page_p->bytes + offset;\n    last_opcode = (cbc_opcode_t) (*opcode_p);\n    PARSER_NEXT_BYTE (page_p, offset);\n    branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (last_opcode);\n    flags = cbc_flags[last_opcode];\n    length++;\n\n    if (last_opcode == CBC_EXT_OPCODE)\n    {\n      cbc_ext_opcode_t ext_opcode;\n\n      ext_opcode = (cbc_ext_opcode_t) page_p->bytes[offset];\n      branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (ext_opcode);\n      flags = cbc_ext_flags[ext_opcode];\n      PARSER_NEXT_BYTE (page_p, offset);\n      length++;\n\n#if ENABLED (JERRY_ES2015)\n      if (ext_opcode == CBC_EXT_RETURN_PROMISE)\n      {\n        last_opcode = CBC_RETURN;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_LINE_INFO)\n      if (ext_opcode == CBC_EXT_LINE)\n      {\n        uint8_t last_byte = 0;\n\n        do\n        {\n          last_byte = page_p->bytes[offset];\n          PARSER_NEXT_BYTE (page_p, offset);\n          length++;\n        }\n        while (last_byte & CBC_HIGHEST_BIT_MASK);\n\n        continue;\n      }\n#endif /* ENABLED (JERRY_LINE_INFO) */\n    }\n\n    while (flags & (CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2))\n    {\n      uint8_t *first_byte = page_p->bytes + offset;\n      uint32_t literal_index = *first_byte;\n\n      PARSER_NEXT_BYTE (page_p, offset);\n      length++;\n\n      literal_index |= ((uint32_t) page_p->bytes[offset]) << 8;\n\n      if (literal_index >= PARSER_REGISTER_START)\n      {\n        literal_index -= PARSER_REGISTER_START;\n      }\n      else\n      {\n        literal_index = (PARSER_GET_LITERAL (literal_index))->prop.index;\n      }\n\n      if (literal_index <= literal_one_byte_limit)\n      {\n        *first_byte = (uint8_t) literal_index;\n      }\n      else\n      {\n        if (context_p->literal_count <= CBC_MAXIMUM_SMALL_VALUE)\n        {\n          JERRY_ASSERT (literal_index <= CBC_MAXIMUM_SMALL_VALUE);\n          *first_byte = CBC_MAXIMUM_BYTE_VALUE;\n          page_p->bytes[offset] = (uint8_t) (literal_index - CBC_MAXIMUM_BYTE_VALUE);\n          length++;\n        }\n        else\n        {\n          JERRY_ASSERT (literal_index <= CBC_MAXIMUM_FULL_VALUE);\n          *first_byte = (uint8_t) ((literal_index >> 8) | CBC_HIGHEST_BIT_MASK);\n          page_p->bytes[offset] = (uint8_t) (literal_index & 0xff);\n          length++;\n        }\n      }\n      PARSER_NEXT_BYTE (page_p, offset);\n\n      if (flags & CBC_HAS_LITERAL_ARG2)\n      {\n        if (flags & CBC_HAS_LITERAL_ARG)\n        {\n          flags = CBC_HAS_LITERAL_ARG;\n        }\n        else\n        {\n          flags = CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2;\n        }\n      }\n      else\n      {\n        break;\n      }\n    }\n\n    if (flags & CBC_HAS_BYTE_ARG)\n    {\n      /* This argument will be copied without modification. */\n      PARSER_NEXT_BYTE (page_p, offset);\n      length++;\n    }\n\n    if (flags & CBC_HAS_BRANCH_ARG)\n    {\n      bool prefix_zero = true;\n\n      /* The leading zeroes are dropped from the stream.\n       * Although dropping these zeroes for backward\n       * branches are unnecessary, we use the same\n       * code path for simplicity. */\n      JERRY_ASSERT (branch_offset_length > 0 && branch_offset_length <= 3);\n\n      while (--branch_offset_length > 0)\n      {\n        uint8_t byte = page_p->bytes[offset];\n        if (byte > 0 || !prefix_zero)\n        {\n          prefix_zero = false;\n          length++;\n        }\n        else\n        {\n          JERRY_ASSERT (CBC_BRANCH_IS_FORWARD (flags));\n        }\n        PARSER_NEXT_BYTE (page_p, offset);\n      }\n\n      if (last_opcode == (cbc_opcode_t) (CBC_JUMP_FORWARD + PARSER_MAX_BRANCH_LENGTH - 1)\n          && prefix_zero\n          && page_p->bytes[offset] == PARSER_MAX_BRANCH_LENGTH + 1)\n      {\n        /* Uncoditional jumps which jump right after the instruction\n         * are effectively NOPs. These jumps are removed from the\n         * stream. The 1 byte long CBC_JUMP_FORWARD form marks these\n         * instructions, since this form is constructed during post\n         * processing and cannot be emitted directly. */\n        *opcode_p = CBC_JUMP_FORWARD;\n        length--;\n      }\n      else\n      {\n        /* Other last bytes are always copied. */\n        length++;\n      }\n\n      PARSER_NEXT_BYTE (page_p, offset);\n    }\n  }\n\n  if (!(context_p->status_flags & PARSER_NO_END_LABEL)\n      || !(PARSER_OPCODE_IS_RETURN (last_opcode)))\n  {\n    context_p->status_flags &= (uint32_t) ~PARSER_NO_END_LABEL;\n\n#if ENABLED (JERRY_ES2015)\n    if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)\n    {\n      length += 2;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    length++;\n  }\n\n  needs_uint16_arguments = false;\n  total_size = sizeof (cbc_uint8_arguments_t);\n\n  if (context_p->stack_limit > CBC_MAXIMUM_BYTE_VALUE\n      || context_p->register_count > CBC_MAXIMUM_BYTE_VALUE\n      || context_p->literal_count > CBC_MAXIMUM_BYTE_VALUE)\n  {\n    needs_uint16_arguments = true;\n    total_size = sizeof (cbc_uint16_arguments_t);\n  }\n\n  literal_length = (size_t) (context_p->literal_count - context_p->register_count) * sizeof (ecma_value_t);\n\n  total_size += literal_length + length;\n\n  if (PARSER_NEEDS_MAPPED_ARGUMENTS (context_p->status_flags))\n  {\n    total_size += context_p->argument_count * sizeof (ecma_value_t);\n  }\n\n#if ENABLED (JERRY_ES2015)\n  if (context_p->tagged_template_literal_cp != JMEM_CP_NULL)\n  {\n    total_size += sizeof (ecma_value_t);\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n  if (JERRY_CONTEXT (resource_name) != ECMA_VALUE_UNDEFINED)\n  {\n    total_size += sizeof (ecma_value_t);\n  }\n#endif /* ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n#if ENABLED (JERRY_SNAPSHOT_SAVE)\n  total_size_used = total_size;\n#endif /* ENABLED (JERRY_SNAPSHOT_SAVE) */\n  total_size = JERRY_ALIGNUP (total_size, JMEM_ALIGNMENT);\n\n  compiled_code_p = (ecma_compiled_code_t *) parser_malloc (context_p, total_size);\n\n#if ENABLED (JERRY_SNAPSHOT_SAVE)\n  // Avoid getting junk bytes at the end when bytes at the end remain unused:\n  if (total_size_used < total_size)\n  {\n    memset (((uint8_t *) compiled_code_p) + total_size_used, 0, total_size - total_size_used);\n  }\n#endif /* ENABLED (JERRY_SNAPSHOT_SAVE) */\n\n#if ENABLED (JERRY_MEM_STATS)\n  jmem_stats_allocate_byte_code_bytes (total_size);\n#endif /* ENABLED (JERRY_MEM_STATS) */\n\n  byte_code_p = (uint8_t *) compiled_code_p;\n  compiled_code_p->size = (uint16_t) (total_size >> JMEM_ALIGNMENT_LOG);\n  compiled_code_p->refs = 1;\n  compiled_code_p->status_flags = CBC_CODE_FLAGS_FUNCTION;\n\n#if ENABLED (JERRY_ES2015)\n  if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)\n  {\n    JERRY_ASSERT (context_p->argument_count > 0);\n    context_p->argument_count--;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  if (needs_uint16_arguments)\n  {\n    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) compiled_code_p;\n\n    args_p->stack_limit = context_p->stack_limit;\n    args_p->argument_end = context_p->argument_count;\n    args_p->register_end = context_p->register_count;\n    args_p->ident_end = ident_end;\n    args_p->const_literal_end = const_literal_end;\n    args_p->literal_end = context_p->literal_count;\n\n    compiled_code_p->status_flags |= CBC_CODE_FLAGS_UINT16_ARGUMENTS;\n    byte_code_p += sizeof (cbc_uint16_arguments_t);\n  }\n  else\n  {\n    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) compiled_code_p;\n\n    args_p->stack_limit = (uint8_t) context_p->stack_limit;\n    args_p->argument_end = (uint8_t) context_p->argument_count;\n    args_p->register_end = (uint8_t) context_p->register_count;\n    args_p->ident_end = (uint8_t) ident_end;\n    args_p->const_literal_end = (uint8_t) const_literal_end;\n    args_p->literal_end = (uint8_t) context_p->literal_count;\n\n    byte_code_p += sizeof (cbc_uint8_arguments_t);\n  }\n\n  uint16_t encoding_limit;\n  uint16_t encoding_delta;\n\n  if (context_p->literal_count > CBC_MAXIMUM_SMALL_VALUE)\n  {\n    compiled_code_p->status_flags |= CBC_CODE_FLAGS_FULL_LITERAL_ENCODING;\n    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;\n    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;\n  }\n  else\n  {\n    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;\n    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;\n  }\n\n  if (context_p->status_flags & PARSER_IS_STRICT)\n  {\n    compiled_code_p->status_flags |= CBC_CODE_FLAGS_STRICT_MODE;\n  }\n\n  if (context_p->status_flags & PARSER_ARGUMENTS_NEEDED)\n  {\n    if (PARSER_NEEDS_MAPPED_ARGUMENTS (context_p->status_flags))\n    {\n      compiled_code_p->status_flags |= CBC_CODE_FLAGS_MAPPED_ARGUMENTS_NEEDED;\n    }\n    else\n    {\n      compiled_code_p->status_flags |= CBC_CODE_FLAGS_UNMAPPED_ARGUMENTS_NEEDED;\n    }\n\n    /* Arguments is stored in the lexical environment. */\n    JERRY_ASSERT (context_p->status_flags & PARSER_LEXICAL_ENV_NEEDED);\n  }\n\n  if (!(context_p->status_flags & PARSER_LEXICAL_ENV_NEEDED))\n  {\n    compiled_code_p->status_flags |= CBC_CODE_FLAGS_LEXICAL_ENV_NOT_NEEDED;\n  }\n\n#if ENABLED (JERRY_ES2015)\n  if (context_p->status_flags & (PARSER_IS_PROPERTY_GETTER | PARSER_IS_PROPERTY_SETTER))\n  {\n    compiled_code_p->status_flags |= CBC_CODE_FLAGS_ACCESSOR;\n  }\n\n  if (context_p->status_flags & PARSER_IS_ARROW_FUNCTION)\n  {\n    compiled_code_p->status_flags |= CBC_CODE_FLAGS_ARROW_FUNCTION;\n  }\n\n  if (context_p->status_flags & PARSER_CLASS_CONSTRUCTOR)\n  {\n    compiled_code_p->status_flags |= CBC_CODE_FLAGS_CLASS_CONSTRUCTOR;\n  }\n\n  if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)\n  {\n    compiled_code_p->status_flags |= CBC_CODE_FLAGS_GENERATOR;\n  }\n\n  if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)\n  {\n    compiled_code_p->status_flags |= CBC_CODE_FLAGS_REST_PARAMETER;\n  }\n\n  if (context_p->tagged_template_literal_cp != JMEM_CP_NULL)\n  {\n    compiled_code_p->status_flags |= CBC_CODE_FLAG_HAS_TAGGED_LITERALS;\n  }\n\n  if (context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED)\n  {\n    JERRY_ASSERT (!(context_p->status_flags & PARSER_IS_FUNCTION));\n    compiled_code_p->status_flags |= CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  literal_pool_p = ((ecma_value_t *) byte_code_p) - context_p->register_count;\n  byte_code_p += literal_length;\n  dst_p = byte_code_p;\n\n  parser_init_literal_pool (context_p, literal_pool_p);\n\n  page_p = context_p->byte_code.first_p;\n  offset = 0;\n  real_offset = 0;\n  uint8_t last_register_index = (uint8_t) JERRY_MIN (context_p->register_count,\n                                                     (PARSER_MAXIMUM_NUMBER_OF_REGISTERS - 1));\n\n  while (page_p != last_page_p || offset < last_position)\n  {\n    uint8_t flags;\n    uint8_t *opcode_p;\n    uint8_t *branch_mark_p;\n    cbc_opcode_t opcode;\n    size_t branch_offset_length;\n\n    opcode_p = dst_p;\n    branch_mark_p = page_p->bytes + offset;\n    opcode = (cbc_opcode_t) (*branch_mark_p);\n    branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (opcode);\n\n    if (opcode == CBC_JUMP_FORWARD)\n    {\n      /* These opcodes are deleted from the stream. */\n      size_t counter = PARSER_MAX_BRANCH_LENGTH + 1;\n\n      do\n      {\n        PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);\n      }\n      while (--counter > 0);\n\n      continue;\n    }\n\n    /* Storing the opcode */\n    *dst_p++ = (uint8_t) opcode;\n    real_offset++;\n    PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);\n    flags = cbc_flags[opcode];\n\n#if ENABLED (JERRY_DEBUGGER)\n    if (opcode == CBC_BREAKPOINT_DISABLED)\n    {\n      uint32_t bp_offset = (uint32_t) (((uint8_t *) dst_p) - ((uint8_t *) compiled_code_p) - 1);\n      parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_OFFSET_LIST, bp_offset);\n    }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n    if (opcode == CBC_EXT_OPCODE)\n    {\n      cbc_ext_opcode_t ext_opcode;\n\n      ext_opcode = (cbc_ext_opcode_t) page_p->bytes[offset];\n      flags = cbc_ext_flags[ext_opcode];\n      branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (ext_opcode);\n\n      /* Storing the extended opcode */\n      *dst_p++ = (uint8_t) ext_opcode;\n      opcode_p++;\n      real_offset++;\n      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);\n\n#if ENABLED (JERRY_LINE_INFO)\n      if (ext_opcode == CBC_EXT_LINE)\n      {\n        uint8_t last_byte = 0;\n\n        do\n        {\n          last_byte = page_p->bytes[offset];\n          *dst_p++ = last_byte;\n\n          real_offset++;\n          PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);\n        }\n        while (last_byte & CBC_HIGHEST_BIT_MASK);\n\n        continue;\n      }\n#endif /* ENABLED (JERRY_LINE_INFO) */\n    }\n\n    /* Only literal and call arguments can be combined. */\n    JERRY_ASSERT (!(flags & CBC_HAS_BRANCH_ARG)\n                   || !(flags & (CBC_HAS_BYTE_ARG | CBC_HAS_LITERAL_ARG)));\n\n    while (flags & (CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2))\n    {\n      uint16_t first_byte = page_p->bytes[offset];\n\n      uint8_t *opcode_pos_p = dst_p - 1;\n      *dst_p++ = (uint8_t) first_byte;\n      real_offset++;\n      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);\n\n      if (first_byte > literal_one_byte_limit)\n      {\n        *dst_p++ = page_p->bytes[offset];\n\n        if (first_byte > encoding_limit)\n        {\n          first_byte = (uint16_t) (((first_byte << 8) | dst_p[-1]) - encoding_delta);\n        }\n        real_offset++;\n      }\n      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);\n\n      if (flags & CBC_HAS_LITERAL_ARG2)\n      {\n        if (flags & CBC_HAS_LITERAL_ARG)\n        {\n          flags = CBC_HAS_LITERAL_ARG;\n        }\n        else\n        {\n          flags = CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2;\n        }\n      }\n      else\n      {\n        if (opcode == CBC_ASSIGN_SET_IDENT && JERRY_LIKELY (first_byte < last_register_index))\n        {\n          *opcode_pos_p = CBC_MOV_IDENT;\n        }\n\n        break;\n      }\n    }\n\n    if (flags & CBC_HAS_BYTE_ARG)\n    {\n      /* This argument will be copied without modification. */\n      *dst_p++ = page_p->bytes[offset];\n      real_offset++;\n      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);\n      continue;\n    }\n\n    if (flags & CBC_HAS_BRANCH_ARG)\n    {\n      *branch_mark_p |= CBC_HIGHEST_BIT_MASK;\n      bool prefix_zero = true;\n\n      /* The leading zeroes are dropped from the stream. */\n      JERRY_ASSERT (branch_offset_length > 0 && branch_offset_length <= 3);\n\n      while (--branch_offset_length > 0)\n      {\n        uint8_t byte = page_p->bytes[offset];\n        if (byte > 0 || !prefix_zero)\n        {\n          prefix_zero = false;\n          *dst_p++ = page_p->bytes[offset];\n          real_offset++;\n        }\n        else\n        {\n          /* When a leading zero is dropped, the branch\n           * offset length must be decreased as well. */\n          (*opcode_p)--;\n        }\n        PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);\n      }\n\n      *dst_p++ = page_p->bytes[offset];\n      real_offset++;\n      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);\n      continue;\n    }\n  }\n\n#if ENABLED (JERRY_DEBUGGER)\n  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n      && context_p->breakpoint_info_count > 0)\n  {\n    parser_send_breakpoints (context_p, JERRY_DEBUGGER_BREAKPOINT_OFFSET_LIST);\n    JERRY_ASSERT (context_p->breakpoint_info_count == 0);\n  }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n  if (!(context_p->status_flags & PARSER_NO_END_LABEL))\n  {\n    *dst_p++ = CBC_RETURN_WITH_BLOCK;\n\n#if ENABLED (JERRY_ES2015)\n    if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)\n    {\n      dst_p[-1] = CBC_PUSH_UNDEFINED;\n      dst_p[0] = CBC_EXT_OPCODE;\n      dst_p[1] = CBC_EXT_RETURN_PROMISE;\n      dst_p += 2;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n  }\n  JERRY_ASSERT (dst_p == byte_code_p + length);\n\n  parse_update_branches (context_p, byte_code_p);\n\n  parser_cbc_stream_free (&context_p->byte_code);\n\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n  if (context_p->is_show_opcodes)\n  {\n    parser_list_iterator_t literal_iterator;\n    lexer_literal_t *literal_p;\n\n    parse_print_final_cbc (compiled_code_p, &context_p->literal_pool, length);\n    JERRY_DEBUG_MSG (\"\\nByte code size: %d bytes\\n\", (int) length);\n    context_p->total_byte_code_size += (uint32_t) length;\n\n    parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n    while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))\n    {\n      if ((literal_p->type == LEXER_IDENT_LITERAL || literal_p->type == LEXER_STRING_LITERAL)\n          && !(literal_p->status_flags & LEXER_FLAG_SOURCE_PTR))\n      {\n        jmem_heap_free_block ((void *) literal_p->u.char_p, literal_p->prop.length);\n      }\n    }\n  }\n#else /* !ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n  if (context_p->status_flags & PARSER_HAS_LATE_LIT_INIT)\n  {\n    parser_list_iterator_t literal_iterator;\n    lexer_literal_t *literal_p;\n    uint16_t register_count = context_p->register_count;\n\n    parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n    while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))\n    {\n      if ((literal_p->status_flags & LEXER_FLAG_LATE_INIT)\n          && literal_p->prop.index >= register_count)\n      {\n        uint32_t source_data = literal_p->u.source_data;\n        const uint8_t *char_p = context_p->source_end_p - (source_data & 0xfffff);\n        ecma_value_t lit_value = ecma_find_or_create_literal_string (char_p,\n                                                                     source_data >> 20);\n        literal_pool_p[literal_p->prop.index] = lit_value;\n      }\n    }\n  }\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n\n  if (PARSER_NEEDS_MAPPED_ARGUMENTS (context_p->status_flags))\n  {\n    parser_list_iterator_t literal_iterator;\n    uint16_t argument_count = 0;\n    uint16_t register_count = context_p->register_count;\n    ecma_value_t *argument_base_p = (ecma_value_t *) (((uint8_t *) compiled_code_p) + total_size);\n    argument_base_p -= context_p->argument_count;\n\n    parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n    while (argument_count < context_p->argument_count)\n    {\n      lexer_literal_t *literal_p;\n      literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator);\n\n      JERRY_ASSERT (literal_p != NULL);\n\n      if (!(literal_p->status_flags & LEXER_FLAG_FUNCTION_ARGUMENT))\n      {\n        continue;\n      }\n\n      /* All arguments must be moved to initialized registers. */\n      if (literal_p->type == LEXER_UNUSED_LITERAL)\n      {\n        argument_base_p[argument_count] = ECMA_VALUE_EMPTY;\n        argument_count++;\n        continue;\n      }\n\n      JERRY_ASSERT (literal_p->type == LEXER_IDENT_LITERAL);\n\n      JERRY_ASSERT (literal_p->prop.index >= register_count);\n\n      argument_base_p[argument_count] = literal_pool_p[literal_p->prop.index];\n      argument_count++;\n    }\n  }\n\n#if ENABLED (JERRY_ES2015)\n  if (context_p->tagged_template_literal_cp != JMEM_CP_NULL)\n  {\n    ecma_value_t *tagged_base_p = (ecma_value_t *) (((uint8_t *) compiled_code_p) + total_size);\n\n    if (PARSER_NEEDS_MAPPED_ARGUMENTS (context_p->status_flags))\n    {\n      tagged_base_p -= context_p->argument_count;\n    }\n\n    tagged_base_p[-1] = (ecma_value_t) context_p->tagged_template_literal_cp;\n\n    ecma_collection_t *collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                                       context_p->tagged_template_literal_cp);\n\n    for (uint32_t i = 0; i < collection_p->item_count; i++)\n    {\n      ecma_free_value (collection_p->buffer_p[i]);\n    }\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n  if (JERRY_CONTEXT (resource_name) != ECMA_VALUE_UNDEFINED)\n  {\n    ecma_value_t *resource_name_p = (ecma_value_t *) (((uint8_t *) compiled_code_p) + total_size);\n\n    if (PARSER_NEEDS_MAPPED_ARGUMENTS (context_p->status_flags))\n    {\n      resource_name_p -= context_p->argument_count;\n    }\n\n#if ENABLED (JERRY_ES2015)\n    if (context_p->tagged_template_literal_cp != JMEM_CP_NULL)\n    {\n      resource_name_p--;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    resource_name_p[-1] = JERRY_CONTEXT (resource_name);\n  }\n#endif /* ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n#if ENABLED (JERRY_DEBUGGER)\n  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n  {\n    jerry_debugger_send_function_cp (JERRY_DEBUGGER_BYTE_CODE_CP, compiled_code_p);\n  }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n  return compiled_code_p;\n}",
        "begin_line": 897,
        "end_line": 1682,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_raise_error#2607",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_raise_error (parser_context_t *context_p, /**< context */                     parser_error_t error) /**< error code */",
        "snippet": "void\nparser_raise_error (parser_context_t *context_p, /**< context */\n                    parser_error_t error) /**< error code */\n{\n  /* Must be compatible with the scanner because\n   * the lexer might throws errors during prescanning. */\n  parser_saved_context_t *saved_context_p = context_p->last_context_p;\n\n  while (saved_context_p != NULL)\n  {\n    parser_cbc_stream_free (&saved_context_p->byte_code);\n\n    /* First the current literal pool is freed, and then it is replaced\n     * by the literal pool coming from the saved context. Since literals\n     * are not used anymore, this is a valid replacement. The last pool\n     * is freed by parser_parse_source. */\n\n    parser_free_literals (&context_p->literal_pool);\n    context_p->literal_pool.data = saved_context_p->literal_pool_data;\n\n    if (context_p->scope_stack_p != NULL)\n    {\n      parser_free (context_p->scope_stack_p, context_p->scope_stack_size * sizeof (parser_scope_stack_t));\n    }\n    context_p->scope_stack_p = saved_context_p->scope_stack_p;\n    context_p->scope_stack_size = saved_context_p->scope_stack_size;\n\n    if (saved_context_p->last_statement.current_p != NULL)\n    {\n      parser_free_jumps (saved_context_p->last_statement);\n    }\n\n#if ENABLED (JERRY_ES2015)\n    if (saved_context_p->tagged_template_literal_cp != JMEM_CP_NULL)\n    {\n      ecma_collection_free (ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                             saved_context_p->tagged_template_literal_cp));\n    }\n#endif /* ENABLED (JERRY_ES2015)  */\n\n    saved_context_p = saved_context_p->prev_context_p;\n  }\n\n#if ENABLED (JERRY_ES2015)\n  if (context_p->tagged_template_literal_cp != JMEM_CP_NULL)\n  {\n    ecma_collection_free (ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,\n                                                           context_p->tagged_template_literal_cp));\n  }\n#endif /* ENABLED (JERRY_ES2015)  */\n\n  context_p->error = error;\n  PARSER_THROW (context_p->try_buffer);\n  /* Should never been reached. */\n  JERRY_ASSERT (0);\n}",
        "begin_line": 2607,
        "end_line": 2662,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_restore_context#2356",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_restore_context (parser_context_t *context_p, /**< context */                         parser_saved_context_t *saved_context_p) /**< target for saving the context */",
        "snippet": "static void\nparser_restore_context (parser_context_t *context_p, /**< context */\n                        parser_saved_context_t *saved_context_p) /**< target for saving the context */\n{\n  parser_list_free (&context_p->literal_pool);\n\n  if (context_p->scope_stack_p != NULL)\n  {\n    parser_free (context_p->scope_stack_p, context_p->scope_stack_size * sizeof (parser_scope_stack_t));\n  }\n\n  /* Restore private part of the context. */\n\n  JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);\n\n  context_p->status_flags = saved_context_p->status_flags;\n  context_p->stack_depth = saved_context_p->stack_depth;\n  context_p->stack_limit = saved_context_p->stack_limit;\n  context_p->last_context_p = saved_context_p->prev_context_p;\n  context_p->last_statement = saved_context_p->last_statement;\n\n  context_p->argument_count = saved_context_p->argument_count;\n  context_p->register_count = saved_context_p->register_count;\n  context_p->literal_count = saved_context_p->literal_count;\n\n  context_p->byte_code = saved_context_p->byte_code;\n  context_p->byte_code_size = saved_context_p->byte_code_size;\n  context_p->literal_pool.data = saved_context_p->literal_pool_data;\n  context_p->scope_stack_p = saved_context_p->scope_stack_p;\n  context_p->scope_stack_size = saved_context_p->scope_stack_size;\n  context_p->scope_stack_top = saved_context_p->scope_stack_top;\n  context_p->scope_stack_reg_top = saved_context_p->scope_stack_reg_top;\n#if ENABLED (JERRY_ES2015)\n  context_p->scope_stack_global_end = saved_context_p->scope_stack_global_end;\n  context_p->tagged_template_literal_cp = saved_context_p->tagged_template_literal_cp;\n#endif /* ENABLED (JERRY_ES2015) */\n\n#ifndef JERRY_NDEBUG\n  context_p->context_stack_depth = saved_context_p->context_stack_depth;\n#endif /* !JERRY_NDEBUG */\n}",
        "begin_line": 2356,
        "end_line": 2396,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_save_context#2274",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_save_context (parser_context_t *context_p, /**< context */                      parser_saved_context_t *saved_context_p) /**< target for saving the context */",
        "snippet": "static void\nparser_save_context (parser_context_t *context_p, /**< context */\n                     parser_saved_context_t *saved_context_p) /**< target for saving the context */\n{\n  JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);\n\n#if ENABLED (JERRY_DEBUGGER)\n  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n      && context_p->breakpoint_info_count > 0)\n  {\n    parser_send_breakpoints (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST);\n    context_p->breakpoint_info_count = 0;\n  }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n#if ENABLED (JERRY_ES2015)\n  if (context_p->status_flags & PARSER_FUNCTION_IS_PARSING_ARGS)\n  {\n    context_p->status_flags |= PARSER_LEXICAL_BLOCK_NEEDED;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  /* Save private part of the context. */\n\n  saved_context_p->status_flags = context_p->status_flags;\n  saved_context_p->stack_depth = context_p->stack_depth;\n  saved_context_p->stack_limit = context_p->stack_limit;\n  saved_context_p->prev_context_p = context_p->last_context_p;\n  saved_context_p->last_statement = context_p->last_statement;\n\n  saved_context_p->argument_count = context_p->argument_count;\n  saved_context_p->register_count = context_p->register_count;\n  saved_context_p->literal_count = context_p->literal_count;\n\n  saved_context_p->byte_code = context_p->byte_code;\n  saved_context_p->byte_code_size = context_p->byte_code_size;\n  saved_context_p->literal_pool_data = context_p->literal_pool.data;\n  saved_context_p->scope_stack_p = context_p->scope_stack_p;\n  saved_context_p->scope_stack_size = context_p->scope_stack_size;\n  saved_context_p->scope_stack_top = context_p->scope_stack_top;\n  saved_context_p->scope_stack_reg_top = context_p->scope_stack_reg_top;\n#if ENABLED (JERRY_ES2015)\n  saved_context_p->scope_stack_global_end = context_p->scope_stack_global_end;\n  saved_context_p->tagged_template_literal_cp = context_p->tagged_template_literal_cp;\n#endif /* ENABLED (JERRY_ES2015) */\n\n#ifndef JERRY_NDEBUG\n  saved_context_p->context_stack_depth = context_p->context_stack_depth;\n#endif /* !JERRY_NDEBUG */\n\n  /* Reset private part of the context. */\n\n  context_p->status_flags &= PARSER_IS_STRICT;\n  context_p->stack_depth = 0;\n  context_p->stack_limit = 0;\n  context_p->last_context_p = saved_context_p;\n  context_p->last_statement.current_p = NULL;\n\n  context_p->argument_count = 0;\n  context_p->register_count = 0;\n  context_p->literal_count = 0;\n\n  parser_cbc_stream_init (&context_p->byte_code);\n  context_p->byte_code_size = 0;\n  parser_list_reset (&context_p->literal_pool);\n  context_p->scope_stack_p = NULL;\n  context_p->scope_stack_size = 0;\n  context_p->scope_stack_top = 0;\n  context_p->scope_stack_reg_top = 0;\n#if ENABLED (JERRY_ES2015)\n  context_p->scope_stack_global_end = 0;\n  context_p->tagged_template_literal_cp = JMEM_CP_NULL;\n#endif /* ENABLED (JERRY_ES2015) */\n\n#ifndef JERRY_NDEBUG\n  context_p->context_stack_depth = 0;\n#endif /* !JERRY_NDEBUG */\n}",
        "begin_line": 2274,
        "end_line": 2351,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_update_forward_branch#321",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_update_forward_branch (parser_mem_page_t *page_p, /**< current page */                               size_t full_distance, /**< full distance */                               uint8_t bytes_copied_before_jump) /**< bytes copied before jump */",
        "snippet": "static size_t\nparser_update_forward_branch (parser_mem_page_t *page_p, /**< current page */\n                              size_t full_distance, /**< full distance */\n                              uint8_t bytes_copied_before_jump) /**< bytes copied before jump */\n{\n  size_t new_distance = 0;\n\n  while (full_distance > PARSER_CBC_STREAM_PAGE_SIZE)\n  {\n    new_distance += page_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] & CBC_LOWER_SEVEN_BIT_MASK;\n    full_distance -= PARSER_CBC_STREAM_PAGE_SIZE;\n    page_p = page_p->next_p;\n  }\n\n  new_distance += page_p->bytes[full_distance - 1] & CBC_LOWER_SEVEN_BIT_MASK;\n  return new_distance - bytes_copied_before_jump;\n}",
        "begin_line": 321,
        "end_line": 337,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-ops.scanner_check_directives#531",
        "src_path": "jerry-core/parser/js/js-scanner-ops.c",
        "class_name": "jerry-core.parser.js.js-scanner-ops",
        "signature": "jerry-core.parser.js.js-scanner-ops.scanner_check_directives (parser_context_t *context_p, /**< context */                           scanner_context_t *scanner_context_p) /**< scanner context */",
        "snippet": "void\nscanner_check_directives (parser_context_t *context_p, /**< context */\n                          scanner_context_t *scanner_context_p) /**< scanner context */\n{\n  scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n\n  while (context_p->token.type == LEXER_LITERAL\n         && context_p->token.lit_location.type == LEXER_STRING_LITERAL)\n  {\n    bool is_use_strict = false;\n\n    if (lexer_string_is_use_strict (context_p)\n        && !(context_p->status_flags & PARSER_IS_STRICT))\n    {\n      is_use_strict = true;\n      context_p->status_flags |= PARSER_IS_STRICT;\n    }\n\n    lexer_next_token (context_p);\n\n    if (!lexer_string_is_directive (context_p))\n    {\n      if (is_use_strict)\n      {\n        context_p->status_flags &= (uint32_t) ~PARSER_IS_STRICT;\n      }\n\n      /* The string is part of an expression statement. */\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      break;\n    }\n\n    if (is_use_strict)\n    {\n      scanner_context_p->active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_IS_STRICT;\n    }\n\n    if (context_p->token.type == LEXER_SEMICOLON)\n    {\n      lexer_next_token (context_p);\n    }\n  }\n}",
        "begin_line": 531,
        "end_line": 573,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_add_custom_literal#1100",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_add_custom_literal (parser_context_t *context_p, /**< context */                             scanner_literal_pool_t *literal_pool_p, /**< literal pool */                             const lexer_lit_location_t *literal_location_p) /**< literal */",
        "snippet": "lexer_lit_location_t *\nscanner_add_custom_literal (parser_context_t *context_p, /**< context */\n                            scanner_literal_pool_t *literal_pool_p, /**< literal pool */\n                            const lexer_lit_location_t *literal_location_p) /**< literal */\n{\n  parser_list_iterator_t literal_iterator;\n  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);\n  lexer_lit_location_t *literal_p;\n\n  const uint8_t *char_p = literal_location_p->char_p;\n  prop_length_t length = literal_location_p->length;\n\n  if (JERRY_LIKELY (!literal_location_p->has_escape))\n  {\n    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n    {\n      if (literal_p->length == length)\n      {\n        if (JERRY_LIKELY (!literal_p->has_escape))\n        {\n          if (memcmp (literal_p->char_p, char_p, length) == 0)\n          {\n            return literal_p;\n          }\n        }\n        else if (lexer_compare_identifier_to_string (literal_p, char_p, length))\n        {\n          /* The non-escaped version is preferred. */\n          literal_p->char_p = char_p;\n          literal_p->has_escape = 0;\n          return literal_p;\n        }\n      }\n    }\n  }\n  else\n  {\n    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n    {\n      if (lexer_compare_identifiers (context_p, literal_p, literal_location_p))\n      {\n        return literal_p;\n      }\n    }\n  }\n\n  literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &literal_pool_p->literal_pool);\n  *literal_p = *literal_location_p;\n\n  literal_p->type = 0;\n\n  return literal_p;\n}",
        "begin_line": 1100,
        "end_line": 1152,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_add_literal#1159",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_add_literal (parser_context_t *context_p, /**< context */                      scanner_context_t *scanner_context_p) /**< scanner context */",
        "snippet": "inline lexer_lit_location_t * JERRY_ATTR_ALWAYS_INLINE\nscanner_add_literal (parser_context_t *context_p, /**< context */\n                     scanner_context_t *scanner_context_p) /**< scanner context */\n{\n  return scanner_add_custom_literal (context_p,\n                                     scanner_context_p->active_literal_pool_p,\n                                     &context_p->token.lit_location);\n}",
        "begin_line": 1159,
        "end_line": 1166,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_add_reference#1174",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_add_reference (parser_context_t *context_p, /**< context */                        scanner_context_t *scanner_context_p) /**< scanner context */",
        "snippet": "inline void JERRY_ATTR_ALWAYS_INLINE\nscanner_add_reference (parser_context_t *context_p, /**< context */\n                       scanner_context_t *scanner_context_p) /**< scanner context */\n{\n  lexer_lit_location_t *lit_location_p = scanner_add_custom_literal (context_p,\n                                                                     scanner_context_p->active_literal_pool_p,\n                                                                     &context_p->token.lit_location);\n#if ENABLED (JERRY_ES2015)\n  lit_location_p->type |= SCANNER_LITERAL_IS_USED;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)\n  {\n    lit_location_p->type |= SCANNER_LITERAL_NO_REG;\n  }\n\n  scanner_detect_eval_call (context_p, scanner_context_p);\n}",
        "begin_line": 1174,
        "end_line": 1191,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_append_argument#1198",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_append_argument (parser_context_t *context_p, /**< context */                          scanner_context_t *scanner_context_p) /**< scanner context */",
        "snippet": "lexer_lit_location_t *\nscanner_append_argument (parser_context_t *context_p, /**< context */\n                         scanner_context_t *scanner_context_p) /**< scanner context */\n{\n  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;\n  parser_list_iterator_t literal_iterator;\n  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);\n  lexer_lit_location_t *literal_location_p = &context_p->token.lit_location;\n  lexer_lit_location_t *literal_p;\n\n  const uint8_t *char_p = literal_location_p->char_p;\n  prop_length_t length = literal_location_p->length;\n\n  if (JERRY_LIKELY (!context_p->token.lit_location.has_escape))\n  {\n    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n    {\n      if (literal_p->length == length)\n      {\n        if (JERRY_LIKELY (!literal_p->has_escape))\n        {\n          if (memcmp (literal_p->char_p, char_p, length) == 0)\n          {\n            break;\n          }\n        }\n        else if (lexer_compare_identifier_to_string (literal_p, char_p, length))\n        {\n          break;\n        }\n      }\n    }\n  }\n  else\n  {\n    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n    {\n      if (lexer_compare_identifiers (context_p, literal_p, literal_location_p))\n      {\n        break;\n      }\n    }\n  }\n\n  uint8_t literal_type = SCANNER_LITERAL_IS_ARG;\n\n  if (literal_p != NULL)\n  {\n    literal_p->length = 0;\n\n#if ENABLED (JERRY_ES2015)\n    if (literal_p->type & SCANNER_LITERAL_IS_USED)\n    {\n      literal_type = SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_EARLY_CREATE;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n  }\n\n  literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &literal_pool_p->literal_pool);\n\n  *literal_p = context_p->token.lit_location;\n  literal_p->type = literal_type;\n\n  return literal_p;\n}",
        "begin_line": 1198,
        "end_line": 1262,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_cleanup#1580",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_cleanup (parser_context_t *context_p) /**< context */",
        "snippet": "void\nscanner_cleanup (parser_context_t *context_p) /**< context */\n{\n  if (context_p->skipped_scanner_info_p != NULL)\n  {\n    context_p->skipped_scanner_info_end_p->next_p = context_p->next_scanner_info_p;\n    context_p->next_scanner_info_p = context_p->skipped_scanner_info_p;\n    context_p->skipped_scanner_info_p = NULL;\n  }\n\n  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;\n\n  while (scanner_info_p != NULL)\n  {\n    scanner_info_t *next_scanner_info_p = scanner_info_p->next_p;\n\n    size_t size = sizeof (scanner_info_t);\n\n    switch (scanner_info_p->type)\n    {\n      case SCANNER_TYPE_END:\n      {\n        scanner_info_p = context_p->active_scanner_info_p;\n        continue;\n      }\n      case SCANNER_TYPE_FUNCTION:\n      case SCANNER_TYPE_BLOCK:\n      {\n        size = scanner_get_stream_size (scanner_info_p, sizeof (scanner_info_t));\n        break;\n      }\n      case SCANNER_TYPE_WHILE:\n      case SCANNER_TYPE_FOR_IN:\n#if ENABLED (JERRY_ES2015)\n      case SCANNER_TYPE_FOR_OF:\n#endif /* ENABLED (JERRY_ES2015) */\n      case SCANNER_TYPE_CASE:\n#if ENABLED (JERRY_ES2015)\n      case SCANNER_TYPE_INITIALIZER:\n#endif /* ENABLED (JERRY_ES2015) */\n      {\n        size = sizeof (scanner_location_info_t);\n        break;\n      }\n      case SCANNER_TYPE_FOR:\n      {\n        size = sizeof (scanner_for_info_t);\n        break;\n      }\n      case SCANNER_TYPE_SWITCH:\n      {\n        scanner_release_switch_cases (((scanner_switch_info_t *) scanner_info_p)->case_p);\n        size = sizeof (scanner_switch_info_t);\n        break;\n      }\n      default:\n      {\n#if ENABLED (JERRY_ES2015)\n        JERRY_ASSERT (scanner_info_p->type == SCANNER_TYPE_END_ARGUMENTS\n                      || scanner_info_p->type == SCANNER_TYPE_LET_EXPRESSION\n                      || scanner_info_p->type == SCANNER_TYPE_CLASS_CONSTRUCTOR\n                      || scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED\n                      || scanner_info_p->type == SCANNER_TYPE_ERR_ASYNC_FUNCTION);\n#else /* !ENABLED (JERRY_ES2015) */\n        JERRY_ASSERT (scanner_info_p->type == SCANNER_TYPE_END_ARGUMENTS);\n#endif /* ENABLED (JERRY_ES2015) */\n        break;\n      }\n    }\n\n    scanner_free (scanner_info_p, size);\n    scanner_info_p = next_scanner_info_p;\n  }\n\n  context_p->next_scanner_info_p = NULL;\n  context_p->active_scanner_info_p = NULL;\n}",
        "begin_line": 1580,
        "end_line": 1656,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_create_unused_literal#1856",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_create_unused_literal (parser_context_t *context_p, /**< context */                                uint8_t status_flags) /**< initial status flags */",
        "snippet": "static void\nscanner_create_unused_literal (parser_context_t *context_p, /**< context */\n                               uint8_t status_flags) /**< initial status flags */\n{\n  if (JERRY_UNLIKELY (context_p->literal_count >= PARSER_MAXIMUM_NUMBER_OF_LITERALS))\n  {\n    parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);\n  }\n\n  lexer_literal_t *literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);\n\n  literal_p->type = LEXER_UNUSED_LITERAL;\n  literal_p->status_flags = status_flags;\n\n  context_p->literal_count++;\n}",
        "begin_line": 1856,
        "end_line": 1871,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_create_variables#1960",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_create_variables (parser_context_t *context_p, /**< context */                           uint32_t option_flags) /**< combination of scanner_create_variables_flags_t bits */",
        "snippet": "void\nscanner_create_variables (parser_context_t *context_p, /**< context */\n                          uint32_t option_flags) /**< combination of scanner_create_variables_flags_t bits */\n{\n  scanner_info_t *info_p = context_p->next_scanner_info_p;\n  const uint8_t *next_data_p = (const uint8_t *) (info_p + 1);\n  uint8_t info_type = info_p->type;\n  uint8_t info_u8_arg = info_p->u8_arg;\n  lexer_lit_location_t literal;\n  parser_scope_stack_t *scope_stack_p;\n  parser_scope_stack_t *scope_stack_end_p;\n\n  JERRY_ASSERT (info_type == SCANNER_TYPE_FUNCTION || info_type == SCANNER_TYPE_BLOCK);\n  JERRY_ASSERT (!(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_ARGS)\n                || !(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY));\n  JERRY_ASSERT (info_type == SCANNER_TYPE_FUNCTION\n                || !(option_flags & (SCANNER_CREATE_VARS_IS_FUNCTION_ARGS | SCANNER_CREATE_VARS_IS_FUNCTION_BODY)));\n\n  if (info_type == SCANNER_TYPE_FUNCTION && !(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY))\n  {\n    JERRY_ASSERT (context_p->scope_stack_p == NULL);\n\n    size_t stack_size = info_p->u16_arg * sizeof (parser_scope_stack_t);\n    context_p->scope_stack_size = info_p->u16_arg;\n\n    scope_stack_p = NULL;\n\n    if (stack_size > 0)\n    {\n      scope_stack_p = (parser_scope_stack_t *) parser_malloc (context_p, stack_size);\n    }\n\n    context_p->scope_stack_p = scope_stack_p;\n    scope_stack_end_p = scope_stack_p + context_p->scope_stack_size;\n  }\n  else\n  {\n    JERRY_ASSERT (context_p->scope_stack_p != NULL || context_p->scope_stack_size == 0);\n\n    scope_stack_p = context_p->scope_stack_p;\n    scope_stack_end_p = scope_stack_p + context_p->scope_stack_size;\n    scope_stack_p += context_p->scope_stack_top;\n  }\n\n  uint32_t scope_stack_reg_top = context_p->scope_stack_reg_top;\n\n  literal.char_p = info_p->source_p - 1;\n\n  while (next_data_p[0] != SCANNER_STREAM_TYPE_END)\n  {\n    uint32_t type = next_data_p[0] & SCANNER_STREAM_TYPE_MASK;\n    const uint8_t *data_p = next_data_p;\n\n    JERRY_ASSERT ((option_flags & (SCANNER_CREATE_VARS_IS_FUNCTION_BODY | SCANNER_CREATE_VARS_IS_FUNCTION_ARGS))\n                  || (type != SCANNER_STREAM_TYPE_HOLE\n                      && !SCANNER_STREAM_TYPE_IS_ARG (type)\n                      && !SCANNER_STREAM_TYPE_IS_ARG_FUNC (type)));\n\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n    JERRY_ASSERT (type != SCANNER_STREAM_TYPE_IMPORT || (data_p[0] & SCANNER_STREAM_NO_REG));\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n    if (type == SCANNER_STREAM_TYPE_HOLE)\n    {\n      next_data_p++;\n\n      if (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY)\n      {\n        continue;\n      }\n\n      if (info_u8_arg & SCANNER_FUNCTION_MAPPED_ARGUMENTS)\n      {\n        scanner_create_unused_literal (context_p, LEXER_FLAG_FUNCTION_ARGUMENT);\n      }\n\n      if (scope_stack_reg_top < PARSER_MAXIMUM_NUMBER_OF_REGISTERS)\n      {\n        scope_stack_reg_top++;\n      }\n      continue;\n    }\n\n    JERRY_ASSERT (context_p->scope_stack_size != 0);\n\n    if (!(data_p[0] & SCANNER_STREAM_UINT16_DIFF))\n    {\n      if (data_p[2] != 0)\n      {\n        literal.char_p += data_p[2];\n        next_data_p += 2 + 1;\n      }\n      else\n      {\n        memcpy (&literal.char_p, data_p + 2 + 1, sizeof (const uint8_t *));\n        next_data_p += 2 + 1 + sizeof (const uint8_t *);\n      }\n    }\n    else\n    {\n      int32_t diff = ((int32_t) data_p[2]) | ((int32_t) data_p[3]) << 8;\n\n      if (diff <= UINT8_MAX)\n      {\n        diff = -diff;\n      }\n\n      literal.char_p += diff;\n      next_data_p += 2 + 2;\n    }\n\n    if (SCANNER_STREAM_TYPE_IS_ARG (type))\n    {\n      if (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY)\n      {\n        literal.char_p += data_p[1];\n        continue;\n      }\n    }\n    else if ((option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_ARGS)\n             && !SCANNER_STREAM_TYPE_IS_ARG_FUNC (type))\n    {\n      /* Function arguments must come first. */\n      break;\n    }\n\n    literal.length = data_p[1];\n    literal.type = LEXER_IDENT_LITERAL;\n    literal.has_escape = (data_p[0] & SCANNER_STREAM_HAS_ESCAPE) ? 1 : 0;\n\n    lexer_construct_literal_object (context_p, &literal, LEXER_NEW_IDENT_LITERAL);\n    literal.char_p += data_p[1];\n\n    if (SCANNER_STREAM_TYPE_IS_ARG_FUNC (type) && (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY))\n    {\n      JERRY_ASSERT (scope_stack_p >= context_p->scope_stack_p + 2);\n      JERRY_ASSERT (context_p->status_flags & PARSER_IS_FUNCTION);\n#if ENABLED (JERRY_ES2015)\n      JERRY_ASSERT (!(context_p->status_flags & PARSER_FUNCTION_IS_PARSING_ARGS));\n#endif /* ENABLED (JERRY_ES2015) */\n\n      parser_scope_stack_t *function_map_p = scope_stack_p - 2;\n      uint16_t literal_index = context_p->lit_object.index;\n\n      while (literal_index != function_map_p->map_from)\n      {\n        function_map_p--;\n\n        JERRY_ASSERT (function_map_p >= context_p->scope_stack_p);\n      }\n\n      JERRY_ASSERT (function_map_p[1].map_from == PARSER_SCOPE_STACK_FUNC);\n\n      cbc_opcode_t opcode = CBC_SET_VAR_FUNC;\n\n#if ENABLED (JERRY_ES2015)\n      if (JERRY_UNLIKELY (context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED)\n          && (function_map_p[0].map_to & PARSER_SCOPE_STACK_REGISTER_MASK) == 0)\n      {\n        opcode = CBC_INIT_ARG_OR_FUNC;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      parser_emit_cbc_literal_value (context_p,\n                                     (uint16_t) opcode,\n                                     function_map_p[1].map_to,\n                                     scanner_decode_map_to (function_map_p));\n      continue;\n    }\n\n    if (JERRY_UNLIKELY (scope_stack_p >= scope_stack_end_p))\n    {\n      JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);\n      parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);\n    }\n\n    scope_stack_p->map_from = context_p->lit_object.index;\n\n#if ENABLED (JERRY_ES2015)\n    if (info_type == SCANNER_TYPE_FUNCTION)\n    {\n      if (type != SCANNER_STREAM_TYPE_LET\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n          && type != SCANNER_STREAM_TYPE_IMPORT\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n          && type != SCANNER_STREAM_TYPE_CONST)\n      {\n        context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_GLOBAL;\n      }\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    uint16_t map_to;\n    uint16_t func_init_opcode = CBC_INIT_ARG_OR_FUNC;\n\n    if (!(data_p[0] & SCANNER_STREAM_NO_REG)\n        && scope_stack_reg_top < PARSER_MAXIMUM_NUMBER_OF_REGISTERS)\n    {\n      map_to = (uint16_t) (PARSER_REGISTER_START + scope_stack_reg_top);\n\n#if ENABLED (JERRY_ES2015)\n      scope_stack_p->map_to = (uint16_t) (scope_stack_reg_top + 1);\n#else /* !ENABLED (JERRY_ES2015) */\n      scope_stack_p->map_to = map_to;\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scope_stack_reg_top++;\n#if ENABLED (JERRY_ES2015)\n      switch (type)\n      {\n        case SCANNER_STREAM_TYPE_CONST:\n        {\n          scope_stack_p->map_to |= PARSER_SCOPE_STACK_IS_CONST_REG;\n          /* FALLTHRU */\n        }\n        case SCANNER_STREAM_TYPE_LET:\n        case SCANNER_STREAM_TYPE_ARG:\n        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:\n        case SCANNER_STREAM_TYPE_ARG_FUNC:\n        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:\n        {\n          scope_stack_p->map_to |= PARSER_SCOPE_STACK_NO_FUNCTION_COPY;\n          break;\n        }\n      }\n\n      func_init_opcode = CBC_SET_VAR_FUNC;\n#endif /* ENABLED (JERRY_ES2015) */\n    }\n    else\n    {\n      context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_USED;\n      map_to = context_p->lit_object.index;\n\n#if ENABLED (JERRY_ES2015)\n      uint16_t scope_stack_map_to = 0;\n#else /* !ENABLED (JERRY_ES2015) */\n      scope_stack_p->map_to = map_to;\n#endif /* ENABLED (JERRY_ES2015) */\n\n      if (info_type == SCANNER_TYPE_FUNCTION)\n      {\n        context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;\n      }\n\n      switch (type)\n      {\n#if ENABLED (JERRY_ES2015)\n        case SCANNER_STREAM_TYPE_LET:\n        case SCANNER_STREAM_TYPE_CONST:\n        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:\n        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:\n        {\n          scope_stack_map_to |= PARSER_SCOPE_STACK_NO_FUNCTION_COPY;\n\n          if (!(data_p[0] & SCANNER_STREAM_EARLY_CREATE))\n          {\n            break;\n          }\n          scope_stack_map_to |= PARSER_SCOPE_STACK_IS_LOCAL_CREATED;\n          /* FALLTHRU */\n        }\n        case SCANNER_STREAM_TYPE_LOCAL:\n#endif /* ENABLED (JERRY_ES2015) */\n        case SCANNER_STREAM_TYPE_VAR:\n        {\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n          context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n\n          uint16_t opcode = ((option_flags & SCANNER_CREATE_VARS_IS_SCRIPT) ? CBC_CREATE_VAR_EVAL\n                                                                            : CBC_CREATE_VAR);\n#if ENABLED (JERRY_ES2015)\n          switch (type)\n          {\n            case SCANNER_STREAM_TYPE_LET:\n            {\n              opcode = CBC_CREATE_LET;\n              break;\n            }\n            case SCANNER_STREAM_TYPE_CONST:\n            {\n              opcode = CBC_CREATE_CONST;\n              break;\n            }\n            case SCANNER_STREAM_TYPE_LOCAL:\n            case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:\n            case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:\n            {\n              opcode = CBC_CREATE_LOCAL;\n              break;\n            }\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n\n          parser_emit_cbc_literal (context_p, opcode, map_to);\n          break;\n        }\n        case SCANNER_STREAM_TYPE_ARG:\n        case SCANNER_STREAM_TYPE_ARG_FUNC:\n        {\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n          context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n\n#if ENABLED (JERRY_ES2015)\n          scope_stack_map_to |= PARSER_SCOPE_STACK_NO_FUNCTION_COPY;\n\n          /* Argument initializers of functions with mapped arguments (e.g. function f(a,b,a) {}) are\n           * generated here. The other initializers are handled by parser_parse_function_arguments(). */\n          if (info_u8_arg & SCANNER_FUNCTION_MAPPED_ARGUMENTS)\n          {\n#endif /* ENABLED (JERRY_ES2015) */\n            parser_emit_cbc_literal_value (context_p,\n                                           CBC_INIT_ARG_OR_FUNC,\n                                           (uint16_t) (PARSER_REGISTER_START + scope_stack_reg_top),\n                                           map_to);\n#if ENABLED (JERRY_ES2015)\n          }\n          else if (data_p[0] & SCANNER_STREAM_EARLY_CREATE)\n          {\n            parser_emit_cbc_literal (context_p, CBC_CREATE_LOCAL, map_to);\n            scope_stack_map_to |= PARSER_SCOPE_STACK_IS_LOCAL_CREATED;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n\n          if (scope_stack_reg_top < PARSER_MAXIMUM_NUMBER_OF_REGISTERS)\n          {\n            scope_stack_reg_top++;\n          }\n          break;\n        }\n      }\n\n#if ENABLED (JERRY_ES2015)\n      scope_stack_p->map_to = scope_stack_map_to;\n#endif /* ENABLED (JERRY_ES2015) */\n    }\n\n    scope_stack_p++;\n\n    if (!SCANNER_STREAM_TYPE_IS_FUNCTION (type))\n    {\n      continue;\n    }\n\n    if (JERRY_UNLIKELY (scope_stack_p >= scope_stack_end_p))\n    {\n      JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);\n      parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);\n    }\n\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n    context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n\n    if (!SCANNER_STREAM_TYPE_IS_ARG_FUNC (type))\n    {\n      if (func_init_opcode == CBC_INIT_ARG_OR_FUNC && (option_flags & SCANNER_CREATE_VARS_IS_SCRIPT))\n      {\n#if ENABLED (JERRY_ES2015)\n        literal.char_p -= data_p[1];\n        if (!(context_p->global_status_flags & ECMA_PARSE_DIRECT_EVAL)\n            || !scanner_scope_find_let_declaration (context_p, &literal))\n        {\n          func_init_opcode = CBC_CREATE_VAR_FUNC_EVAL;\n        }\n        literal.char_p += data_p[1];\n#else /* !ENABLED (JERRY_ES2015) */\n        func_init_opcode = CBC_CREATE_VAR_FUNC_EVAL;\n#endif /* ENABLED (JERRY_ES2015) */\n      }\n\n      parser_emit_cbc_literal_value (context_p, func_init_opcode, context_p->literal_count, map_to);\n    }\n\n    scope_stack_p->map_from = PARSER_SCOPE_STACK_FUNC;\n    scope_stack_p->map_to = context_p->literal_count;\n    scope_stack_p++;\n\n    scanner_create_unused_literal (context_p, 0);\n  }\n\n  if (info_type == SCANNER_TYPE_FUNCTION\n      && !(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY)\n      && (info_u8_arg & SCANNER_FUNCTION_ARGUMENTS_NEEDED))\n  {\n    JERRY_ASSERT (info_type == SCANNER_TYPE_FUNCTION);\n\n    if (JERRY_UNLIKELY (scope_stack_p >= scope_stack_end_p))\n    {\n      JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);\n      parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);\n    }\n\n    context_p->status_flags |= PARSER_ARGUMENTS_NEEDED | PARSER_LEXICAL_ENV_NEEDED;\n\n    lexer_construct_literal_object (context_p, &lexer_arguments_literal, lexer_arguments_literal.type);\n\n    scope_stack_p->map_from = context_p->lit_object.index;\n#if ENABLED (JERRY_ES2015)\n    scope_stack_p->map_to = 0;\n#else /* !ENABLED (JERRY_ES2015) */\n    scope_stack_p->map_to = context_p->lit_object.index;\n#endif /* ENABLED (JERRY_ES2015) */\n    scope_stack_p++;\n  }\n\n  context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);\n  context_p->scope_stack_reg_top = (uint16_t) scope_stack_reg_top;\n\n#if ENABLED (JERRY_ES2015)\n  if (info_type == SCANNER_TYPE_FUNCTION)\n  {\n    context_p->scope_stack_global_end = context_p->scope_stack_top;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  if (context_p->register_count < scope_stack_reg_top)\n  {\n    context_p->register_count = (uint16_t) scope_stack_reg_top;\n  }\n\n  if (!(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_ARGS))\n  {\n    scanner_release_next (context_p, (size_t) (next_data_p + 1 - ((const uint8_t *) info_p)));\n  }\n  parser_flush_cbc (context_p);\n}",
        "begin_line": 1960,
        "end_line": 2388,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_decode_map_to#2417",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_decode_map_to (parser_scope_stack_t *stack_item_p) /**< scope stack item */",
        "snippet": "inline uint16_t JERRY_ATTR_ALWAYS_INLINE\nscanner_decode_map_to (parser_scope_stack_t *stack_item_p) /**< scope stack item */\n{\n  JERRY_ASSERT (stack_item_p->map_from != PARSER_SCOPE_STACK_FUNC);\n\n#if ENABLED (JERRY_ES2015)\n  uint16_t value = (stack_item_p->map_to & PARSER_SCOPE_STACK_REGISTER_MASK);\n  return (value == 0) ? stack_item_p->map_from : (uint16_t) (value + (PARSER_REGISTER_START - 1));\n#else /* !ENABLED (JERRY_ES2015) */\n  return stack_item_p->map_to;\n#endif /* ENABLED (JERRY_ES2015) */\n}",
        "begin_line": 2417,
        "end_line": 2428,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_detect_eval_call#1267",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_detect_eval_call (parser_context_t *context_p, /**< context */                           scanner_context_t *scanner_context_p) /**< scanner context */",
        "snippet": "void\nscanner_detect_eval_call (parser_context_t *context_p, /**< context */\n                          scanner_context_t *scanner_context_p) /**< scanner context */\n{\n  if (context_p->token.keyword_type == LEXER_KEYW_EVAL\n      && lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))\n  {\n    scanner_context_p->active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;\n  }\n}",
        "begin_line": 1267,
        "end_line": 1276,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_filter_arguments#941",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_filter_arguments (parser_context_t *context_p, /**< context */                           scanner_context_t *scanner_context_p) /**< scanner context */",
        "snippet": "void\nscanner_filter_arguments (parser_context_t *context_p, /**< context */\n                          scanner_context_t *scanner_context_p) /**< scanner context */\n{\n  /* Fast case: check whether all literals are arguments. */\n  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;\n  scanner_literal_pool_t *prev_literal_pool_p = literal_pool_p->prev_p;\n  parser_list_iterator_t literal_iterator;\n  lexer_lit_location_t *literal_p;\n  bool can_eval = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) != 0;\n  bool has_arguments = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS) == 0;\n\n  if (can_eval && prev_literal_pool_p != NULL)\n  {\n    prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;\n  }\n\n  literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_CAN_EVAL;\n\n  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);\n\n  while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n#if ENABLED (JERRY_ES2015)\n    if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE))\n    {\n      literal_p->type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE;\n    }\n#else /* !ENABLED (JERRY_ES2015) */\n    if (can_eval)\n    {\n      literal_p->type |= SCANNER_LITERAL_NO_REG;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    uint8_t type = literal_p->type;\n\n    if (!(type & SCANNER_LITERAL_IS_ARG) && !(has_arguments && scanner_literal_is_arguments (literal_p)))\n    {\n      break;\n    }\n\n#if ENABLED (JERRY_ES2015)\n    if (type & (SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG))\n    {\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n  }\n\n  if (literal_p == NULL)\n  {\n    return;\n  }\n\n  scanner_literal_pool_t *new_literal_pool_p;\n\n  new_literal_pool_p = (scanner_literal_pool_t *) scanner_malloc (context_p, sizeof (scanner_literal_pool_t));\n\n  new_literal_pool_p->prev_p = literal_pool_p;\n  scanner_context_p->active_literal_pool_p = new_literal_pool_p;\n\n  *new_literal_pool_p = *literal_pool_p;\n  parser_list_init (&new_literal_pool_p->literal_pool,\n                    sizeof (lexer_lit_location_t),\n                    (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_lit_location_t)));\n\n  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);\n\n#if ENABLED (JERRY_ES2015)\n  /* Destructured args are placed after the other arguments because of register assignments. */\n  bool has_destructured_arg = false;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n    uint8_t type = literal_p->type;\n\n    if ((type & SCANNER_LITERAL_IS_ARG) || (has_arguments && scanner_literal_is_arguments (literal_p)))\n    {\n#if ENABLED (JERRY_ES2015)\n      if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE))\n      {\n        type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE;\n        literal_p->type = type;\n      }\n\n      if (type & (SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG))\n      {\n        has_destructured_arg = true;\n\n        if (type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG)\n        {\n          continue;\n        }\n\n        type &= (uint8_t) ~SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG;\n        type |= SCANNER_LITERAL_IS_DESTRUCTURED_ARG;\n\n        literal_p->type = type;\n        continue;\n      }\n#else /* !ENABLED (JERRY_ES2015) */\n      if (can_eval)\n      {\n        literal_p->type |= SCANNER_LITERAL_NO_REG;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      lexer_lit_location_t *new_literal_p;\n      new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool);\n      *new_literal_p = *literal_p;\n    }\n    else if (prev_literal_pool_p != NULL)\n    {\n      /* Propagate literal to upper level. */\n      lexer_lit_location_t *literal_location_p = scanner_add_custom_literal (context_p,\n                                                                             prev_literal_pool_p,\n                                                                             literal_p);\n      type |= SCANNER_LITERAL_NO_REG;\n\n#if ENABLED (JERRY_ES2015)\n      type |= SCANNER_LITERAL_IS_USED;\n#endif /* ENABLED (JERRY_ES2015) */\n\n      literal_location_p->type |= type;\n    }\n  }\n\n#if ENABLED (JERRY_ES2015)\n  if (has_destructured_arg)\n  {\n    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);\n\n    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n    {\n      const uint8_t expected_flags = SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG;\n\n      if ((literal_p->type & expected_flags) == expected_flags)\n      {\n        lexer_lit_location_t *new_literal_p;\n        new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool);\n        *new_literal_p = *literal_p;\n      }\n    }\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  new_literal_pool_p->prev_p = prev_literal_pool_p;\n\n  parser_list_free (&literal_pool_p->literal_pool);\n  scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));\n}",
        "begin_line": 941,
        "end_line": 1093,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_free#117",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_free (void *ptr, /**< pointer to free */               size_t size) /**< size of the memory block */",
        "snippet": "inline void JERRY_ATTR_ALWAYS_INLINE\nscanner_free (void *ptr, /**< pointer to free */\n              size_t size) /**< size of the memory block */\n{\n  jmem_heap_free_block (ptr, size);\n}",
        "begin_line": 117,
        "end_line": 122,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_insert_info#189",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_insert_info (parser_context_t *context_p, /**< context */                      const uint8_t *source_p, /**< triggering position */                      size_t size) /**< size of the memory block */",
        "snippet": "scanner_info_t *\nscanner_insert_info (parser_context_t *context_p, /**< context */\n                     const uint8_t *source_p, /**< triggering position */\n                     size_t size) /**< size of the memory block */\n{\n  scanner_info_t *new_scanner_info_p = (scanner_info_t *) scanner_malloc (context_p, size);\n  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;\n  scanner_info_t *prev_scanner_info_p = NULL;\n\n  JERRY_ASSERT (scanner_info_p != NULL);\n  JERRY_ASSERT (source_p != NULL);\n\n  new_scanner_info_p->source_p = source_p;\n\n  while (source_p < scanner_info_p->source_p)\n  {\n    prev_scanner_info_p = scanner_info_p;\n    scanner_info_p = scanner_info_p->next_p;\n\n    JERRY_ASSERT (scanner_info_p != NULL);\n  }\n\n  /* Multiple scanner info blocks cannot be assigned to the same position. */\n  JERRY_ASSERT (source_p != scanner_info_p->source_p);\n\n  new_scanner_info_p->next_p = scanner_info_p;\n\n  if (JERRY_LIKELY (prev_scanner_info_p == NULL))\n  {\n    context_p->next_scanner_info_p = new_scanner_info_p;\n  }\n  else\n  {\n    prev_scanner_info_p->next_p = new_scanner_info_p;\n  }\n\n  return new_scanner_info_p;\n}",
        "begin_line": 189,
        "end_line": 226,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_is_context_needed#1664",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_is_context_needed (parser_context_t *context_p, /**< context */                            parser_check_context_type_t check_type) /**< context type */",
        "snippet": "bool\nscanner_is_context_needed (parser_context_t *context_p, /**< context */\n                           parser_check_context_type_t check_type) /**< context type */\n{\n  scanner_info_t *info_p = context_p->next_scanner_info_p;\n  const uint8_t *data_p = (const uint8_t *) (info_p + 1);\n\n  JERRY_UNUSED (check_type);\n\n#if ENABLED (JERRY_ES2015)\n  JERRY_ASSERT ((check_type == PARSER_CHECK_BLOCK_CONTEXT ? info_p->type == SCANNER_TYPE_BLOCK\n                                                          : info_p->type == SCANNER_TYPE_FUNCTION));\n\n  uint32_t scope_stack_reg_top = (check_type != PARSER_CHECK_GLOBAL_CONTEXT ? context_p->scope_stack_reg_top\n                                                                            : 0);\n#else /* !ENABLED (JERRY_ES2015) */\n  JERRY_ASSERT (check_type == PARSER_CHECK_BLOCK_CONTEXT);\n  JERRY_ASSERT (info_p->type == SCANNER_TYPE_BLOCK);\n\n  uint32_t scope_stack_reg_top = context_p->scope_stack_reg_top;\n#endif /* !JERRY_NDEBUG */\n\n  while (data_p[0] != SCANNER_STREAM_TYPE_END)\n  {\n    uint8_t data = data_p[0];\n\n#if ENABLED (JERRY_ES2015)\n    uint32_t type = data & SCANNER_STREAM_TYPE_MASK;\n\n    if (JERRY_UNLIKELY (type == SCANNER_STREAM_TYPE_HOLE))\n    {\n      JERRY_ASSERT (check_type == PARSER_CHECK_FUNCTION_CONTEXT);\n      data_p++;\n      continue;\n    }\n\n#ifndef JERRY_NDEBUG\n    if (check_type == PARSER_CHECK_BLOCK_CONTEXT)\n    {\n      JERRY_ASSERT (type == SCANNER_STREAM_TYPE_VAR\n                    || type == SCANNER_STREAM_TYPE_LET\n                    || type == SCANNER_STREAM_TYPE_CONST\n                    || type == SCANNER_STREAM_TYPE_LOCAL\n                    || type == SCANNER_STREAM_TYPE_FUNC);\n    }\n    else if (check_type == PARSER_CHECK_GLOBAL_CONTEXT)\n    {\n      /* FIXME: a private declarative lexical environment should always be present\n       * for modules. Remove SCANNER_STREAM_TYPE_IMPORT after it is implemented. */\n      JERRY_ASSERT (type == SCANNER_STREAM_TYPE_VAR\n                    || type == SCANNER_STREAM_TYPE_LET\n                    || type == SCANNER_STREAM_TYPE_CONST\n                    || type == SCANNER_STREAM_TYPE_FUNC\n                    || type == SCANNER_STREAM_TYPE_IMPORT);\n\n      /* Only let/const can be stored in registers */\n      JERRY_ASSERT ((data & SCANNER_STREAM_NO_REG)\n                    || (type == SCANNER_STREAM_TYPE_FUNC && (context_p->global_status_flags & ECMA_PARSE_DIRECT_EVAL))\n                    || type == SCANNER_STREAM_TYPE_LET\n                    || type == SCANNER_STREAM_TYPE_CONST);\n    }\n    else\n    {\n      JERRY_ASSERT (check_type == PARSER_CHECK_FUNCTION_CONTEXT);\n\n      JERRY_ASSERT (type == SCANNER_STREAM_TYPE_VAR\n                    || type == SCANNER_STREAM_TYPE_LET\n                    || type == SCANNER_STREAM_TYPE_CONST\n                    || type == SCANNER_STREAM_TYPE_LOCAL\n                    || type == SCANNER_STREAM_TYPE_ARG\n                    || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG\n                    || type == SCANNER_STREAM_TYPE_ARG_FUNC\n                    || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC\n                    || type == SCANNER_STREAM_TYPE_FUNC);\n    }\n#endif /* !JERRY_NDEBUG */\n\n#else /* !ENABLED (JERRY_ES2015) */\n    JERRY_ASSERT ((data & SCANNER_STREAM_TYPE_MASK) == SCANNER_STREAM_TYPE_VAR);\n#endif /* ENABLED (JERRY_ES2015) */\n\n    if (!(data & SCANNER_STREAM_UINT16_DIFF))\n    {\n      if (data_p[2] != 0)\n      {\n        data_p += 2 + 1;\n      }\n      else\n      {\n        data_p += 2 + 1 + sizeof (const uint8_t *);\n      }\n    }\n    else\n    {\n      data_p += 2 + 2;\n    }\n\n#if ENABLED (JERRY_ES2015)\n    if (JERRY_UNLIKELY (check_type == PARSER_CHECK_GLOBAL_CONTEXT)\n        && (type == SCANNER_STREAM_TYPE_VAR\n            || (type == SCANNER_STREAM_TYPE_FUNC && !(context_p->global_status_flags & ECMA_PARSE_DIRECT_EVAL))\n            || type == SCANNER_STREAM_TYPE_IMPORT))\n    {\n      continue;\n    }\n\n    if (JERRY_UNLIKELY (check_type == PARSER_CHECK_FUNCTION_CONTEXT))\n    {\n      if (SCANNER_STREAM_TYPE_IS_ARG (type))\n      {\n        continue;\n      }\n\n      if (SCANNER_STREAM_TYPE_IS_ARG_FUNC (type))\n      {\n        /* The return value is true, if the variable is stored in the lexical environment\n         * or all registers have already been used for function arguments. This can be\n         * inprecise in the latter case, but that is a very rare corner case. A more\n         * sophisticated check would require to decode the literal. */\n        if ((data & SCANNER_STREAM_NO_REG)\n            || scope_stack_reg_top >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)\n        {\n          return true;\n        }\n        continue;\n      }\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    if ((data & SCANNER_STREAM_NO_REG)\n        || scope_stack_reg_top >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)\n    {\n      return true;\n    }\n\n    scope_stack_reg_top++;\n  }\n\n  return false;\n}",
        "begin_line": 1664,
        "end_line": 1803,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_literal_is_arguments#460",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_literal_is_arguments (lexer_lit_location_t *literal_p) /**< literal */",
        "snippet": "static inline bool JERRY_ATTR_ALWAYS_INLINE\nscanner_literal_is_arguments (lexer_lit_location_t *literal_p) /**< literal */\n{\n  return lexer_compare_identifier_to_string (literal_p, (const uint8_t *) \"arguments\", 9);\n}",
        "begin_line": 460,
        "end_line": 464,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_malloc#94",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_malloc (parser_context_t *context_p, /**< context */                 size_t size) /**< size of the memory block */",
        "snippet": "void *\nscanner_malloc (parser_context_t *context_p, /**< context */\n                size_t size) /**< size of the memory block */\n{\n  void *result;\n\n  JERRY_ASSERT (size > 0);\n  result = jmem_heap_alloc_block_null_on_error (size);\n\n  if (result == NULL)\n  {\n    scanner_cleanup (context_p);\n\n    /* This is the only error which specify its reason. */\n    context_p->error = PARSER_ERR_OUT_OF_MEMORY;\n    PARSER_THROW (context_p->try_buffer);\n  }\n  return result;\n}",
        "begin_line": 94,
        "end_line": 112,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_pop_literal_pool#469",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_pop_literal_pool (parser_context_t *context_p, /**< context */                           scanner_context_t *scanner_context_p) /**< scanner context */",
        "snippet": "void\nscanner_pop_literal_pool (parser_context_t *context_p, /**< context */\n                          scanner_context_t *scanner_context_p) /**< scanner context */\n{\n  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;\n  scanner_literal_pool_t *prev_literal_pool_p = literal_pool_p->prev_p;\n\n  if (literal_pool_p->source_p == NULL)\n  {\n    JERRY_ASSERT (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION);\n    JERRY_ASSERT (literal_pool_p->literal_pool.data.first_p == NULL\n                  && literal_pool_p->literal_pool.data.last_p == NULL);\n\n    scanner_context_p->active_literal_pool_p = literal_pool_p->prev_p;\n    scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));\n    return;\n  }\n\n  parser_list_iterator_t literal_iterator;\n  lexer_lit_location_t *literal_p;\n  uint16_t status_flags = literal_pool_p->status_flags;\n  bool arguments_required = ((status_flags & (SCANNER_LITERAL_POOL_CAN_EVAL | SCANNER_LITERAL_POOL_NO_ARGUMENTS))\n                             == SCANNER_LITERAL_POOL_CAN_EVAL);\n\n  uint8_t can_eval_types = 0;\n#if ENABLED (JERRY_ES2015)\n  if (prev_literal_pool_p == NULL && !(context_p->global_status_flags & ECMA_PARSE_DIRECT_EVAL))\n  {\n    can_eval_types |= SCANNER_LITERAL_IS_FUNC;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) && prev_literal_pool_p != NULL)\n  {\n    prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;\n  }\n\n#if ENABLED (JERRY_DEBUGGER)\n  if (scanner_context_p->status_flags & SCANNER_CONTEXT_DEBUGGER_ENABLED)\n  {\n    /* When debugger is enabled, identifiers are not stored in registers. However,\n     * this does not affect 'eval' detection, so 'arguments' object is not created. */\n    status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;\n  }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);\n\n  const uint8_t *prev_source_p = literal_pool_p->source_p - 1;\n  size_t compressed_size = 1;\n  uint32_t no_declarations = literal_pool_p->no_declarations;\n\n  while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n    uint8_t type = literal_p->type;\n\n    if (JERRY_UNLIKELY (no_declarations > PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK))\n    {\n      continue;\n    }\n\n    if (!(status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS) && scanner_literal_is_arguments (literal_p))\n    {\n      status_flags |= SCANNER_LITERAL_POOL_NO_ARGUMENTS;\n\n      if (type & (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LOCAL))\n      {\n        arguments_required = false;\n      }\n      else\n      {\n        literal_p->type = 0;\n        arguments_required = true;\n        continue;\n      }\n    }\n\n#if ENABLED (JERRY_ES2015)\n    if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION)\n        && (type & (SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_FUNC_DECLARATION)) == SCANNER_LITERAL_IS_FUNC)\n    {\n      if (prev_literal_pool_p == NULL\n          && (context_p->global_status_flags & ECMA_PARSE_DIRECT_EVAL)\n          && scanner_scope_find_let_declaration (context_p, literal_p))\n      {\n        literal_p->type = 0;\n        continue;\n      }\n\n      type = (uint8_t) ((type & ~SCANNER_LITERAL_IS_FUNC) | SCANNER_LITERAL_IS_VAR);\n      literal_p->type = type;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    if ((type & SCANNER_LITERAL_IS_LOCAL)\n        || ((type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_ARG))\n            && (status_flags & SCANNER_LITERAL_POOL_FUNCTION)))\n    {\n      JERRY_ASSERT ((status_flags & SCANNER_LITERAL_POOL_FUNCTION)\n                    || !(literal_p->type & SCANNER_LITERAL_IS_ARG));\n\n      if (literal_p->length == 0)\n      {\n        compressed_size += 1;\n        continue;\n      }\n\n      no_declarations++;\n\n      if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) || (type & can_eval_types))\n      {\n        type |= SCANNER_LITERAL_NO_REG;\n        literal_p->type = type;\n      }\n\n      if (type & SCANNER_LITERAL_IS_FUNC)\n      {\n        no_declarations++;\n\n#if ENABLED (JERRY_ES2015)\n        if ((type & (SCANNER_LITERAL_IS_CONST | SCANNER_LITERAL_IS_ARG)) == SCANNER_LITERAL_IS_CONST)\n        {\n          JERRY_ASSERT (type & SCANNER_LITERAL_IS_LET);\n\n          /* Catch parameters cannot be functions. */\n          literal_p->type = (uint8_t) (type & ~SCANNER_LITERAL_IS_FUNC);\n          no_declarations--;\n        }\n#else /* !ENABLED (JERRY_ES2015) */\n        if (type & SCANNER_LITERAL_IS_LOCAL)\n        {\n          /* Catch parameters cannot be functions. */\n          literal_p->type = (uint8_t) (type & ~SCANNER_LITERAL_IS_FUNC);\n          no_declarations--;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n      }\n\n      intptr_t diff = (intptr_t) (literal_p->char_p - prev_source_p);\n\n      if (diff >= 1 && diff <= UINT8_MAX)\n      {\n        compressed_size += 2 + 1;\n      }\n      else if (diff >= -UINT8_MAX && diff <= UINT16_MAX)\n      {\n        compressed_size += 2 + 2;\n      }\n      else\n      {\n        compressed_size += 2 + 1 + sizeof (const uint8_t *);\n      }\n\n      prev_source_p = literal_p->char_p + literal_p->length;\n\n      if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION)\n#if ENABLED (JERRY_ES2015)\n          || ((type & SCANNER_LITERAL_IS_FUNC) && (status_flags & SCANNER_LITERAL_POOL_IS_STRICT))\n#endif /* ENABLED (JERRY_ES2015) */\n          || !(type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC)))\n      {\n        continue;\n      }\n    }\n\n    if (prev_literal_pool_p != NULL && literal_p->length > 0)\n    {\n      /* Propagate literal to upper level. */\n      lexer_lit_location_t *literal_location_p = scanner_add_custom_literal (context_p,\n                                                                             prev_literal_pool_p,\n                                                                             literal_p);\n      uint8_t extended_type = literal_location_p->type;\n\n      if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION) || (type & SCANNER_LITERAL_NO_REG))\n      {\n        extended_type |= SCANNER_LITERAL_NO_REG;\n      }\n\n#if ENABLED (JERRY_ES2015)\n      extended_type |= SCANNER_LITERAL_IS_USED;\n\n      if (status_flags & SCANNER_LITERAL_POOL_FUNCTION_STATEMENT)\n      {\n        extended_type |= SCANNER_LITERAL_EARLY_CREATE;\n      }\n\n      const uint8_t mask = (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_LOCAL);\n\n      if ((type & SCANNER_LITERAL_IS_ARG)\n          || (literal_location_p->type & mask) == SCANNER_LITERAL_IS_LET\n          || (literal_location_p->type & mask) == SCANNER_LITERAL_IS_CONST)\n      {\n        /* Clears the SCANNER_LITERAL_IS_VAR and SCANNER_LITERAL_IS_FUNC flags\n         * for speculative arrow parameters and local (non-var) functions. */\n        type = 0;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      type = (uint8_t) (type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC));\n      JERRY_ASSERT (type == 0 || !(status_flags & SCANNER_LITERAL_POOL_FUNCTION));\n\n      literal_location_p->type = (uint8_t) (extended_type | type);\n    }\n  }\n\n  if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION) || (compressed_size > 1))\n  {\n    compressed_size += sizeof (scanner_info_t);\n\n    scanner_info_t *info_p;\n\n    if (prev_literal_pool_p != NULL || scanner_context_p->end_arguments_p == NULL)\n    {\n      info_p = scanner_insert_info (context_p, literal_pool_p->source_p, compressed_size);\n    }\n    else\n    {\n      scanner_info_t *start_info_p = scanner_context_p->end_arguments_p;\n      info_p = scanner_insert_info_before (context_p, literal_pool_p->source_p, start_info_p, compressed_size);\n    }\n\n    if (no_declarations > PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK)\n    {\n      no_declarations = PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK;\n    }\n\n    uint8_t *data_p = (uint8_t *) (info_p + 1);\n\n    if (status_flags & SCANNER_LITERAL_POOL_FUNCTION)\n    {\n      info_p->type = SCANNER_TYPE_FUNCTION;\n\n      uint8_t u8_arg = 0;\n\n      if (arguments_required)\n      {\n        u8_arg |= SCANNER_FUNCTION_ARGUMENTS_NEEDED;\n\n        if (no_declarations < PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK)\n        {\n          no_declarations++;\n        }\n\n#if ENABLED (JERRY_ES2015)\n        const uint16_t is_unmapped = SCANNER_LITERAL_POOL_IS_STRICT | SCANNER_LITERAL_POOL_ARGUMENTS_UNMAPPED;\n#else /* !ENABLED (JERRY_ES2015) */\n        const uint16_t is_unmapped = SCANNER_LITERAL_POOL_IS_STRICT;\n#endif /* ENABLED (JERRY_ES2015) */\n\n        if (status_flags & is_unmapped)\n        {\n          arguments_required = false;\n        }\n        else\n        {\n          u8_arg |= SCANNER_FUNCTION_MAPPED_ARGUMENTS;\n        }\n      }\n\n#if ENABLED (JERRY_ES2015)\n      if (status_flags & SCANNER_LITERAL_POOL_ASYNC)\n      {\n        u8_arg |= SCANNER_FUNCTION_ASYNC;\n\n        if (status_flags & SCANNER_LITERAL_POOL_FUNCTION_STATEMENT)\n        {\n          u8_arg |= SCANNER_FUNCTION_STATEMENT;\n        }\n      }\n\n      if (status_flags & SCANNER_LITERAL_POOL_CAN_EVAL)\n      {\n        u8_arg |= SCANNER_FUNCTION_LEXICAL_ENV_NEEDED;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      info_p->u8_arg = u8_arg;\n      info_p->u16_arg = (uint16_t) no_declarations;\n    }\n    else\n    {\n      info_p->type = SCANNER_TYPE_BLOCK;\n\n      JERRY_ASSERT (prev_literal_pool_p != NULL);\n    }\n\n    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);\n    prev_source_p = literal_pool_p->source_p - 1;\n    no_declarations = literal_pool_p->no_declarations;\n\n    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n    {\n      if (JERRY_UNLIKELY (no_declarations > PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK)\n          || (!(literal_p->type & SCANNER_LITERAL_IS_LOCAL)\n              && (!(literal_p->type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_ARG))\n                  || !(status_flags & SCANNER_LITERAL_POOL_FUNCTION))))\n      {\n        continue;\n      }\n\n      if (literal_p->length == 0)\n      {\n        *data_p++ = SCANNER_STREAM_TYPE_HOLE;\n        continue;\n      }\n\n      no_declarations++;\n\n      uint8_t type = SCANNER_STREAM_TYPE_VAR;\n\n      if (literal_p->type & SCANNER_LITERAL_IS_FUNC)\n      {\n        no_declarations++;\n        type = SCANNER_STREAM_TYPE_FUNC;\n\n        if (literal_p->type & SCANNER_LITERAL_IS_ARG)\n        {\n          type = SCANNER_STREAM_TYPE_ARG_FUNC;\n\n#if ENABLED (JERRY_ES2015)\n          if (literal_p->type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG)\n          {\n            type = SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n        }\n      }\n      else if (literal_p->type & SCANNER_LITERAL_IS_ARG)\n      {\n        type = SCANNER_STREAM_TYPE_ARG;\n\n#if ENABLED (JERRY_ES2015)\n        if (literal_p->type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG)\n        {\n          type = SCANNER_STREAM_TYPE_DESTRUCTURED_ARG;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n      }\n#if ENABLED (JERRY_ES2015)\n      else if (literal_p->type & SCANNER_LITERAL_IS_LET)\n      {\n        if (!(literal_p->type & SCANNER_LITERAL_IS_CONST))\n        {\n          type = SCANNER_STREAM_TYPE_LET;\n\n          if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) && (literal_p->type & SCANNER_LITERAL_NO_REG))\n          {\n            literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n          }\n        }\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n        else if (prev_literal_pool_p == NULL)\n        {\n          type = SCANNER_STREAM_TYPE_IMPORT;\n        }\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n        else\n        {\n          type = SCANNER_STREAM_TYPE_LOCAL;\n        }\n      }\n      else if (literal_p->type & SCANNER_LITERAL_IS_CONST)\n      {\n        type = SCANNER_STREAM_TYPE_CONST;\n\n        if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) && (literal_p->type & SCANNER_LITERAL_NO_REG))\n        {\n          literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n        }\n      }\n\n      if (literal_p->type & SCANNER_LITERAL_EARLY_CREATE)\n      {\n        type |= SCANNER_STREAM_NO_REG | SCANNER_STREAM_EARLY_CREATE;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      if (literal_p->has_escape)\n      {\n        type |= SCANNER_STREAM_HAS_ESCAPE;\n      }\n\n      if ((literal_p->type & SCANNER_LITERAL_NO_REG)\n          || (arguments_required && (literal_p->type & SCANNER_LITERAL_IS_ARG)))\n      {\n        type |= SCANNER_STREAM_NO_REG;\n      }\n\n      data_p[0] = type;\n      data_p[1] = (uint8_t) literal_p->length;\n      data_p += 3;\n\n      intptr_t diff = (intptr_t) (literal_p->char_p - prev_source_p);\n\n      if (diff >= 1 && diff <= UINT8_MAX)\n      {\n        data_p[-1] = (uint8_t) diff;\n      }\n      else if (diff >= -UINT8_MAX && diff <= UINT16_MAX)\n      {\n        if (diff < 0)\n        {\n          diff = -diff;\n        }\n\n        data_p[-3] |= SCANNER_STREAM_UINT16_DIFF;\n        data_p[-1] = (uint8_t) diff;\n        data_p[0] = (uint8_t) (diff >> 8);\n        data_p += 1;\n      }\n      else\n      {\n        data_p[-1] = 0;\n        memcpy (data_p, &literal_p->char_p, sizeof (const uint8_t *));\n        data_p += sizeof (const uint8_t *);\n      }\n\n      prev_source_p = literal_p->char_p + literal_p->length;\n    }\n\n    data_p[0] = SCANNER_STREAM_TYPE_END;\n\n    JERRY_ASSERT (((uint8_t *) info_p) + compressed_size == data_p + 1);\n  }\n\n  if (!(status_flags & SCANNER_LITERAL_POOL_FUNCTION)\n      && prev_literal_pool_p->no_declarations < no_declarations)\n  {\n    prev_literal_pool_p->no_declarations = (uint16_t) no_declarations;\n  }\n\n  if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION) && prev_literal_pool_p != NULL)\n  {\n    if (prev_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IS_STRICT)\n    {\n      context_p->status_flags |= PARSER_IS_STRICT;\n    }\n    else\n    {\n      context_p->status_flags &= (uint32_t) ~PARSER_IS_STRICT;\n    }\n\n#if ENABLED (JERRY_ES2015)\n    if (prev_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_GENERATOR)\n    {\n      context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION;\n    }\n    else\n    {\n      context_p->status_flags &= (uint32_t) ~PARSER_IS_GENERATOR_FUNCTION;\n    }\n\n    if (prev_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_ASYNC)\n    {\n      context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION;\n    }\n    else\n    {\n      context_p->status_flags &= (uint32_t) ~PARSER_IS_ASYNC_FUNCTION;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n  }\n\n  scanner_context_p->active_literal_pool_p = literal_pool_p->prev_p;\n\n  parser_list_free (&literal_pool_p->literal_pool);\n  scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));\n}",
        "begin_line": 469,
        "end_line": 936,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_push_literal_pool#390",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_push_literal_pool (parser_context_t *context_p, /**< context */                            scanner_context_t *scanner_context_p, /**< scanner context */                            uint16_t status_flags) /**< combination of scanner_literal_pool_flags_t flags */",
        "snippet": "scanner_literal_pool_t *\nscanner_push_literal_pool (parser_context_t *context_p, /**< context */\n                           scanner_context_t *scanner_context_p, /**< scanner context */\n                           uint16_t status_flags) /**< combination of scanner_literal_pool_flags_t flags */\n{\n  scanner_literal_pool_t *prev_literal_pool_p = scanner_context_p->active_literal_pool_p;\n  scanner_literal_pool_t *literal_pool_p;\n\n  literal_pool_p = (scanner_literal_pool_t *) scanner_malloc (context_p, sizeof (scanner_literal_pool_t));\n\n  if (!(status_flags & SCANNER_LITERAL_POOL_FUNCTION))\n  {\n    JERRY_ASSERT (prev_literal_pool_p != NULL);\n    status_flags |= SCANNER_LITERAL_POOL_NO_ARGUMENTS;\n\n#if ENABLED (JERRY_ES2015)\n    const uint16_t copied_flags = (SCANNER_LITERAL_POOL_IN_WITH\n                                   | SCANNER_LITERAL_POOL_GENERATOR\n                                   | SCANNER_LITERAL_POOL_ASYNC);\n#else /* !ENABLED (JERRY_ES2015) */\n    const uint16_t copied_flags = SCANNER_LITERAL_POOL_IN_WITH;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    status_flags |= (uint16_t) (prev_literal_pool_p->status_flags & copied_flags);\n  }\n#if ENABLED (JERRY_ES2015)\n  else\n  {\n    context_p->status_flags &= (uint32_t) ~(PARSER_IS_GENERATOR_FUNCTION | PARSER_IS_ASYNC_FUNCTION);\n\n    if (status_flags & SCANNER_LITERAL_POOL_GENERATOR)\n    {\n      context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION;\n    }\n\n    if (status_flags & SCANNER_LITERAL_POOL_ASYNC)\n    {\n      context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION;\n    }\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  if (prev_literal_pool_p != NULL)\n  {\n    const uint16_t copied_flags = SCANNER_LITERAL_POOL_IS_STRICT;\n    status_flags |= (uint16_t) (prev_literal_pool_p->status_flags & copied_flags);\n\n    /* The logical value of these flags must be the same. */\n    JERRY_ASSERT (!(status_flags & SCANNER_LITERAL_POOL_IS_STRICT) == !(context_p->status_flags & PARSER_IS_STRICT));\n  }\n\n  parser_list_init (&literal_pool_p->literal_pool,\n                    sizeof (lexer_lit_location_t),\n                    (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_lit_location_t)));\n  literal_pool_p->source_p = NULL;\n  literal_pool_p->status_flags = status_flags;\n  literal_pool_p->no_declarations = 0;\n\n  literal_pool_p->prev_p = prev_literal_pool_p;\n  scanner_context_p->active_literal_pool_p = literal_pool_p;\n\n  return literal_pool_p;\n}",
        "begin_line": 390,
        "end_line": 452,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_raise_error#65",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_raise_error (parser_context_t *context_p) /**< context */",
        "snippet": "void\nscanner_raise_error (parser_context_t *context_p) /**< context */\n{\n  PARSER_THROW (context_p->try_buffer);\n  /* Should never been reached. */\n  JERRY_ASSERT (0);\n}",
        "begin_line": 65,
        "end_line": 71,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_release_next#267",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_release_next (parser_context_t *context_p, /**< context */                       size_t size) /**< size of the memory block */",
        "snippet": "inline void JERRY_ATTR_ALWAYS_INLINE\nscanner_release_next (parser_context_t *context_p, /**< context */\n                      size_t size) /**< size of the memory block */\n{\n  scanner_info_t *next_p = context_p->next_scanner_info_p->next_p;\n\n  jmem_heap_free_block (context_p->next_scanner_info_p, size);\n  context_p->next_scanner_info_p = next_p;\n}",
        "begin_line": 267,
        "end_line": 275,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_reverse_info_list#1551",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_reverse_info_list (parser_context_t *context_p) /**< context */",
        "snippet": "void\nscanner_reverse_info_list (parser_context_t *context_p) /**< context */\n{\n  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;\n  scanner_info_t *last_scanner_info_p = NULL;\n\n  if (scanner_info_p->type == SCANNER_TYPE_END)\n  {\n    return;\n  }\n\n  do\n  {\n    scanner_info_t *next_scanner_info_p = scanner_info_p->next_p;\n    scanner_info_p->next_p = last_scanner_info_p;\n\n    last_scanner_info_p = scanner_info_p;\n    scanner_info_p = next_scanner_info_p;\n  }\n  while (scanner_info_p->type != SCANNER_TYPE_END);\n\n  context_p->next_scanner_info_p->next_p = scanner_info_p;\n  context_p->next_scanner_info_p = last_scanner_info_p;\n}",
        "begin_line": 1551,
        "end_line": 1574,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_revert_active#293",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_revert_active (parser_context_t *context_p) /**< context */",
        "snippet": "inline void JERRY_ATTR_ALWAYS_INLINE\nscanner_revert_active (parser_context_t *context_p) /**< context */\n{\n  scanner_info_t *scanner_info_p = context_p->active_scanner_info_p;\n\n  context_p->active_scanner_info_p = scanner_info_p->next_p;\n  scanner_info_p->next_p = context_p->next_scanner_info_p;\n  context_p->next_scanner_info_p = scanner_info_p;\n}",
        "begin_line": 293,
        "end_line": 301,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_set_active#280",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_set_active (parser_context_t *context_p) /**< context */",
        "snippet": "inline void JERRY_ATTR_ALWAYS_INLINE\nscanner_set_active (parser_context_t *context_p) /**< context */\n{\n  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;\n\n  context_p->next_scanner_info_p = scanner_info_p->next_p;\n  scanner_info_p->next_p = context_p->active_scanner_info_p;\n  context_p->active_scanner_info_p = scanner_info_p;\n}",
        "begin_line": 280,
        "end_line": 288,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner.scanner_scan_all#2256",
        "src_path": "jerry-core/parser/js/js-scanner.c",
        "class_name": "jerry-core.parser.js.js-scanner",
        "signature": "jerry-core.parser.js.js-scanner.scanner_scan_all (parser_context_t *context_p, /**< context */                   const uint8_t *arg_list_p, /**< function argument list */                   const uint8_t *arg_list_end_p, /**< end of argument list */                   const uint8_t *source_p, /**< valid UTF-8 source code */                   const uint8_t *source_end_p) /**< end of source code */",
        "snippet": "void JERRY_ATTR_NOINLINE\nscanner_scan_all (parser_context_t *context_p, /**< context */\n                  const uint8_t *arg_list_p, /**< function argument list */\n                  const uint8_t *arg_list_end_p, /**< end of argument list */\n                  const uint8_t *source_p, /**< valid UTF-8 source code */\n                  const uint8_t *source_end_p) /**< end of source code */\n{\n  scanner_context_t scanner_context;\n\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n  if (context_p->is_show_opcodes)\n  {\n    JERRY_DEBUG_MSG (\"\\n--- Scanning start ---\\n\\n\");\n  }\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n\n  scanner_context.context_status_flags = context_p->status_flags;\n  scanner_context.status_flags = SCANNER_CONTEXT_NO_FLAGS;\n#if ENABLED (JERRY_DEBUGGER)\n  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n  {\n    scanner_context.status_flags |= SCANNER_CONTEXT_DEBUGGER_ENABLED;\n  }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n#if ENABLED (JERRY_ES2015)\n  scanner_context.binding_type = SCANNER_BINDING_NONE;\n  scanner_context.active_binding_list_p = NULL;\n#endif /* ENABLED (JERRY_ES2015) */\n  scanner_context.active_literal_pool_p = NULL;\n  scanner_context.active_switch_statement.last_case_p = NULL;\n  scanner_context.end_arguments_p = NULL;\n#if ENABLED (JERRY_ES2015)\n  scanner_context.async_source_p = NULL;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  /* This assignment must be here because of Apple compilers. */\n  context_p->u.scanner_context_p = &scanner_context;\n\n  parser_stack_init (context_p);\n\n  PARSER_TRY (context_p->try_buffer)\n  {\n    context_p->line = 1;\n    context_p->column = 1;\n\n    if (arg_list_p == NULL)\n    {\n      context_p->source_p = source_p;\n      context_p->source_end_p = source_end_p;\n\n      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION_WITHOUT_ARGUMENTS | SCANNER_LITERAL_POOL_CAN_EVAL;\n\n      if (context_p->status_flags & PARSER_IS_STRICT)\n      {\n        status_flags |= SCANNER_LITERAL_POOL_IS_STRICT;\n      }\n\n      scanner_literal_pool_t *literal_pool_p = scanner_push_literal_pool (context_p, &scanner_context, status_flags);\n      literal_pool_p->source_p = source_p;\n\n      parser_stack_push_uint8 (context_p, SCAN_STACK_SCRIPT);\n\n      lexer_next_token (context_p);\n      scanner_check_directives (context_p, &scanner_context);\n    }\n    else\n    {\n      context_p->source_p = arg_list_p;\n      context_p->source_end_p = arg_list_end_p;\n\n      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION;\n\n      if (context_p->status_flags & PARSER_IS_STRICT)\n      {\n        status_flags |= SCANNER_LITERAL_POOL_IS_STRICT;\n      }\n\n#if ENABLED (JERRY_ES2015)\n      if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)\n      {\n        status_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scanner_push_literal_pool (context_p, &scanner_context, status_flags);\n      scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_SCRIPT_FUNCTION);\n\n      /* Faking the first token. */\n      context_p->token.type = LEXER_LEFT_PAREN;\n    }\n\n    while (true)\n    {\n      lexer_token_type_t type = (lexer_token_type_t) context_p->token.type;\n      scan_stack_modes_t stack_top = (scan_stack_modes_t) context_p->stack_top_uint8;\n\n      switch (scanner_context.mode)\n      {\n        case SCAN_MODE_PRIMARY_EXPRESSION:\n        {\n          if (type == LEXER_ADD\n              || type == LEXER_SUBTRACT\n              || LEXER_IS_UNARY_OP_TOKEN (type))\n          {\n            break;\n          }\n          /* FALLTHRU */\n        }\n        case SCAN_MODE_PRIMARY_EXPRESSION_AFTER_NEW:\n        {\n          if (scanner_scan_primary_expression (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)\n          {\n            continue;\n          }\n          break;\n        }\n#if ENABLED (JERRY_ES2015)\n        case SCAN_MODE_CLASS_DECLARATION:\n        {\n          if (context_p->token.type == LEXER_KEYW_EXTENDS)\n          {\n            parser_stack_push_uint8 (context_p, SCAN_STACK_CLASS_EXTENDS);\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n            break;\n          }\n          else if (context_p->token.type != LEXER_LEFT_BRACE)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          scanner_context.mode = SCAN_MODE_CLASS_METHOD;\n          /* FALLTHRU */\n        }\n        case SCAN_MODE_CLASS_METHOD:\n        {\n          JERRY_ASSERT (stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR\n                        || stack_top == SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR);\n\n          lexer_skip_empty_statements (context_p);\n\n          lexer_scan_identifier (context_p);\n\n          if (context_p->token.type == LEXER_RIGHT_BRACE)\n          {\n            scanner_source_start_t source_start;\n\n            parser_stack_pop_uint8 (context_p);\n\n            if (stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)\n            {\n              parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));\n            }\n\n            stack_top = context_p->stack_top_uint8;\n\n            JERRY_ASSERT (stack_top == SCAN_STACK_CLASS_STATEMENT || stack_top == SCAN_STACK_CLASS_EXPRESSION);\n\n            if (stack_top == SCAN_STACK_CLASS_STATEMENT)\n            {\n              /* The token is kept to disallow consuming a semicolon after it. */\n              scanner_context.mode = SCAN_MODE_STATEMENT_END;\n              continue;\n            }\n\n            scanner_context.mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n            parser_stack_pop_uint8 (context_p);\n            break;\n          }\n\n          if (context_p->token.type == LEXER_LITERAL\n              && LEXER_IS_IDENT_OR_STRING (context_p->token.lit_location.type)\n              && lexer_compare_literal_to_string (context_p, \"constructor\", 11))\n          {\n            if (stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)\n            {\n              scanner_source_start_t source_start;\n              parser_stack_pop_uint8 (context_p);\n              parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));\n\n              scanner_info_t *info_p = scanner_insert_info (context_p, source_start.source_p, sizeof (scanner_info_t));\n              info_p->type = SCANNER_TYPE_CLASS_CONSTRUCTOR;\n              parser_stack_push_uint8 (context_p, SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR);\n            }\n          }\n\n          if (lexer_token_is_identifier (context_p, \"static\", 6))\n          {\n            lexer_scan_identifier (context_p);\n          }\n\n          parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n          scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n\n          uint16_t literal_pool_flags = SCANNER_LITERAL_POOL_FUNCTION;\n\n          if (lexer_token_is_identifier (context_p, \"get\", 3)\n              || lexer_token_is_identifier (context_p, \"set\", 3))\n          {\n            lexer_scan_identifier (context_p);\n\n            if (context_p->token.type == LEXER_LEFT_PAREN)\n            {\n              scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);\n              continue;\n            }\n          }\n          else if (lexer_token_is_identifier (context_p, \"async\", 5))\n          {\n            lexer_scan_identifier (context_p);\n\n            if (context_p->token.type == LEXER_LEFT_PAREN)\n            {\n              scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);\n              continue;\n            }\n\n            literal_pool_flags |= SCANNER_LITERAL_POOL_ASYNC;\n\n            if (context_p->token.type == LEXER_MULTIPLY)\n            {\n              lexer_scan_identifier (context_p);\n              literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n            }\n          }\n          else if (context_p->token.type == LEXER_MULTIPLY)\n          {\n            lexer_scan_identifier (context_p);\n            literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n          }\n\n          if (context_p->token.type == LEXER_LEFT_SQUARE)\n          {\n            parser_stack_push_uint8 (context_p, SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (literal_pool_flags));\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n            break;\n          }\n\n          if (context_p->token.type != LEXER_LITERAL)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          if (literal_pool_flags & SCANNER_LITERAL_POOL_GENERATOR)\n          {\n            context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION;\n          }\n\n          scanner_push_literal_pool (context_p, &scanner_context, literal_pool_flags);\n          lexer_next_token (context_p);\n          continue;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n        case SCAN_MODE_POST_PRIMARY_EXPRESSION:\n        {\n          if (scanner_scan_post_primary_expression (context_p, &scanner_context, type, stack_top))\n          {\n            break;\n          }\n          type = (lexer_token_type_t) context_p->token.type;\n          /* FALLTHRU */\n        }\n        case SCAN_MODE_PRIMARY_EXPRESSION_END:\n        {\n          if (scanner_scan_primary_expression_end (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)\n          {\n            continue;\n          }\n          break;\n        }\n        case SCAN_MODE_STATEMENT_OR_TERMINATOR:\n        {\n          if (type == LEXER_RIGHT_BRACE || type == LEXER_EOS)\n          {\n            scanner_context.mode = SCAN_MODE_STATEMENT_END;\n            continue;\n          }\n          /* FALLTHRU */\n        }\n        case SCAN_MODE_STATEMENT:\n        {\n          if (scanner_scan_statement (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)\n          {\n            continue;\n          }\n          break;\n        }\n        case SCAN_MODE_STATEMENT_END:\n        {\n          if (scanner_scan_statement_end (context_p, &scanner_context, type) != SCAN_NEXT_TOKEN)\n          {\n            continue;\n          }\n\n          if (context_p->token.type == LEXER_EOS)\n          {\n            goto scan_completed;\n          }\n\n          break;\n        }\n        case SCAN_MODE_VAR_STATEMENT:\n        {\n#if ENABLED (JERRY_ES2015)\n          if (type == LEXER_LEFT_SQUARE || type == LEXER_LEFT_BRACE)\n          {\n            uint8_t binding_type = SCANNER_BINDING_VAR;\n\n            if (stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_FOR_LET_START)\n            {\n              binding_type = SCANNER_BINDING_LET;\n            }\n            else if (stack_top == SCAN_STACK_CONST || stack_top == SCAN_STACK_FOR_CONST_START)\n            {\n              binding_type = SCANNER_BINDING_CONST;\n            }\n\n            scanner_push_destructuring_pattern (context_p, &scanner_context, binding_type, false);\n\n            if (type == LEXER_LEFT_SQUARE)\n            {\n              parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n              scanner_context.mode = SCAN_MODE_BINDING;\n              break;\n            }\n\n            parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n            scanner_context.mode = SCAN_MODE_PROPERTY_NAME;\n            continue;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n\n          if (type != LEXER_LITERAL\n              || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          lexer_lit_location_t *literal_p = scanner_add_literal (context_p, &scanner_context);\n\n#if ENABLED (JERRY_ES2015)\n          if (stack_top != SCAN_STACK_VAR && stack_top != SCAN_STACK_FOR_VAR_START)\n          {\n            scanner_detect_invalid_let (context_p, literal_p);\n\n            if (stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_FOR_LET_START)\n            {\n              literal_p->type |= SCANNER_LITERAL_IS_LET;\n            }\n            else\n            {\n              JERRY_ASSERT (stack_top == SCAN_STACK_CONST || stack_top == SCAN_STACK_FOR_CONST_START);\n              literal_p->type |= SCANNER_LITERAL_IS_CONST;\n            }\n\n            lexer_next_token (context_p);\n\n            if (literal_p->type & SCANNER_LITERAL_IS_USED)\n            {\n              literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n            }\n            else if (context_p->token.type == LEXER_ASSIGN)\n            {\n              scanner_binding_literal_t binding_literal;\n              binding_literal.literal_p = literal_p;\n\n              parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));\n              parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);\n            }\n          }\n          else\n          {\n            if (!(literal_p->type & SCANNER_LITERAL_IS_VAR))\n            {\n              scanner_detect_invalid_var (context_p, &scanner_context, literal_p);\n              literal_p->type |= SCANNER_LITERAL_IS_VAR;\n\n              if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)\n              {\n                literal_p->type |= SCANNER_LITERAL_NO_REG;\n              }\n            }\n\n            lexer_next_token (context_p);\n          }\n#else /* !ENABLED (JERRY_ES2015) */\n          literal_p->type |= SCANNER_LITERAL_IS_VAR;\n\n          if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)\n          {\n            literal_p->type |= SCANNER_LITERAL_NO_REG;\n          }\n\n          lexer_next_token (context_p);\n#endif /* ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n          if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT)\n          {\n            literal_p->type |= SCANNER_LITERAL_NO_REG;\n          }\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n          switch (context_p->token.type)\n          {\n            case LEXER_ASSIGN:\n            {\n              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n              /* FALLTHRU */\n            }\n            case LEXER_COMMA:\n            {\n              lexer_next_token (context_p);\n              continue;\n            }\n          }\n\n          if (SCANNER_IS_FOR_START (stack_top))\n          {\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n            JERRY_ASSERT (!(scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT));\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n            if (context_p->token.type != LEXER_SEMICOLON\n                && context_p->token.type != LEXER_KEYW_IN\n                && !SCANNER_IDENTIFIER_IS_OF ())\n            {\n              scanner_raise_error (context_p);\n            }\n\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n            continue;\n          }\n\n#if ENABLED (JERRY_ES2015)\n          JERRY_ASSERT (stack_top == SCAN_STACK_VAR || stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_CONST);\n#else /* !ENABLED (JERRY_ES2015) */\n          JERRY_ASSERT (stack_top == SCAN_STACK_VAR);\n#endif /* ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n          scanner_context.active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n          scanner_context.mode = SCAN_MODE_STATEMENT_END;\n          parser_stack_pop_uint8 (context_p);\n          continue;\n        }\n        case SCAN_MODE_FUNCTION_ARGUMENTS:\n        {\n          JERRY_ASSERT (stack_top == SCAN_STACK_SCRIPT_FUNCTION\n                        || stack_top == SCAN_STACK_FUNCTION_STATEMENT\n                        || stack_top == SCAN_STACK_FUNCTION_EXPRESSION\n                        || stack_top == SCAN_STACK_FUNCTION_PROPERTY);\n\n          scanner_literal_pool_t *literal_pool_p = scanner_context.active_literal_pool_p;\n\n          JERRY_ASSERT (literal_pool_p != NULL && (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION));\n\n          literal_pool_p->source_p = context_p->source_p;\n\n#if ENABLED (JERRY_ES2015)\n          if (JERRY_UNLIKELY (scanner_context.async_source_p != NULL))\n          {\n            literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ASYNC;\n            literal_pool_p->source_p = scanner_context.async_source_p;\n            scanner_context.async_source_p = NULL;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n\n          if (type != LEXER_LEFT_PAREN)\n          {\n            scanner_raise_error (context_p);\n          }\n          lexer_next_token (context_p);\n\n#if ENABLED (JERRY_ES2015)\n          /* FALLTHRU */\n        }\n        case SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS:\n        {\n#endif /* ENABLED (JERRY_ES2015) */\n          if (context_p->token.type != LEXER_RIGHT_PAREN && context_p->token.type != LEXER_EOS)\n          {\n#if ENABLED (JERRY_ES2015)\n            lexer_lit_location_t *argument_literal_p;\n#endif /* ENABLED (JERRY_ES2015) */\n\n            while (true)\n            {\n#if ENABLED (JERRY_ES2015)\n              if (context_p->token.type == LEXER_THREE_DOTS)\n              {\n                scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_UNMAPPED;\n\n                lexer_next_token (context_p);\n              }\n\n              if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)\n              {\n                argument_literal_p = NULL;\n                break;\n              }\n#endif /* ENABLED (JERRY_ES2015) */\n\n              if (context_p->token.type != LEXER_LITERAL\n                  || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n              {\n                scanner_raise_error (context_p);\n              }\n\n#if ENABLED (JERRY_ES2015)\n              argument_literal_p = scanner_append_argument (context_p, &scanner_context);\n#else /* !ENABLED (JERRY_ES2015) */\n              scanner_append_argument (context_p, &scanner_context);\n#endif /* ENABLED (JERRY_ES2015) */\n\n              lexer_next_token (context_p);\n\n              if (context_p->token.type != LEXER_COMMA)\n              {\n                break;\n              }\n              lexer_next_token (context_p);\n            }\n\n#if ENABLED (JERRY_ES2015)\n            if (argument_literal_p == NULL)\n            {\n              scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_UNMAPPED;\n\n              parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PARAMETERS);\n              scanner_append_hole (context_p, &scanner_context);\n              scanner_push_destructuring_pattern (context_p, &scanner_context, SCANNER_BINDING_ARG, false);\n\n              if (context_p->token.type == LEXER_LEFT_SQUARE)\n              {\n                parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n                scanner_context.mode = SCAN_MODE_BINDING;\n                break;\n              }\n\n              parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n              scanner_context.mode = SCAN_MODE_PROPERTY_NAME;\n              continue;\n            }\n\n            if (context_p->token.type == LEXER_ASSIGN)\n            {\n              scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_UNMAPPED;\n\n              parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PARAMETERS);\n              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n              if (argument_literal_p->type & SCANNER_LITERAL_IS_USED)\n              {\n                JERRY_ASSERT (argument_literal_p->type & SCANNER_LITERAL_EARLY_CREATE);\n                break;\n              }\n\n              scanner_binding_literal_t binding_literal;\n              binding_literal.literal_p = argument_literal_p;\n\n              parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));\n              parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);\n              break;\n            }\n#endif /* ENABLED (JERRY_ES2015) */\n          }\n\n          if (context_p->token.type == LEXER_EOS && stack_top == SCAN_STACK_SCRIPT_FUNCTION)\n          {\n            /* End of argument parsing. */\n            scanner_info_t *scanner_info_p = (scanner_info_t *) scanner_malloc (context_p, sizeof (scanner_info_t));\n            scanner_info_p->next_p = context_p->next_scanner_info_p;\n            scanner_info_p->source_p = NULL;\n            scanner_info_p->type = SCANNER_TYPE_END_ARGUMENTS;\n            scanner_context.end_arguments_p = scanner_info_p;\n\n            context_p->next_scanner_info_p = scanner_info_p;\n            context_p->source_p = source_p;\n            context_p->source_end_p = source_end_p;\n            context_p->line = 1;\n            context_p->column = 1;\n\n            scanner_filter_arguments (context_p, &scanner_context);\n            lexer_next_token (context_p);\n            scanner_check_directives (context_p, &scanner_context);\n            continue;\n          }\n\n          if (context_p->token.type != LEXER_RIGHT_PAREN)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          lexer_next_token (context_p);\n\n          if (context_p->token.type != LEXER_LEFT_BRACE)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          scanner_filter_arguments (context_p, &scanner_context);\n          lexer_next_token (context_p);\n          scanner_check_directives (context_p, &scanner_context);\n          continue;\n        }\n        case SCAN_MODE_PROPERTY_NAME:\n        {\n          JERRY_ASSERT (stack_top == SCAN_STACK_OBJECT_LITERAL);\n\n          if (lexer_scan_identifier (context_p))\n          {\n            lexer_check_property_modifier (context_p);\n          }\n\n#if ENABLED (JERRY_ES2015)\n          if (context_p->token.type == LEXER_LEFT_SQUARE)\n          {\n            parser_stack_push_uint8 (context_p, SCAN_STACK_COMPUTED_PROPERTY);\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n\n          if (context_p->token.type == LEXER_RIGHT_BRACE)\n          {\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n            continue;\n          }\n\n          if (context_p->token.type == LEXER_PROPERTY_GETTER\n#if ENABLED (JERRY_ES2015)\n              || context_p->token.type == LEXER_KEYW_ASYNC\n              || context_p->token.type == LEXER_MULTIPLY\n#endif /* ENABLED (JERRY_ES2015) */\n              || context_p->token.type == LEXER_PROPERTY_SETTER)\n          {\n            uint16_t literal_pool_flags = SCANNER_LITERAL_POOL_FUNCTION;\n\n#if ENABLED (JERRY_ES2015)\n            if (context_p->token.type == LEXER_MULTIPLY)\n            {\n              literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n            }\n            else if (context_p->token.type == LEXER_KEYW_ASYNC)\n            {\n              literal_pool_flags |= SCANNER_LITERAL_POOL_ASYNC;\n\n              if (lexer_consume_generator (context_p))\n              {\n                literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n              }\n            }\n#endif /* ENABLED (JERRY_ES2015) */\n\n            parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n            lexer_scan_identifier (context_p);\n\n#if ENABLED (JERRY_ES2015)\n            if (context_p->token.type == LEXER_LEFT_SQUARE)\n            {\n              parser_stack_push_uint8 (context_p, SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (literal_pool_flags));\n              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n              break;\n            }\n#endif /* ENABLED (JERRY_ES2015) */\n\n            if (context_p->token.type != LEXER_LITERAL)\n            {\n              scanner_raise_error (context_p);\n            }\n\n            scanner_push_literal_pool (context_p, &scanner_context, literal_pool_flags);\n            scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n            break;\n          }\n\n          if (context_p->token.type != LEXER_LITERAL)\n          {\n            scanner_raise_error (context_p);\n          }\n\n#if ENABLED (JERRY_ES2015)\n          parser_line_counter_t start_line = context_p->token.line;\n          parser_line_counter_t start_column = context_p->token.column;\n          bool is_ident = (context_p->token.lit_location.type == LEXER_IDENT_LITERAL);\n#endif /* ENABLED (JERRY_ES2015) */\n\n          lexer_next_token (context_p);\n\n#if ENABLED (JERRY_ES2015)\n          if (context_p->token.type == LEXER_LEFT_PAREN)\n          {\n            scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);\n\n            parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n            scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n            continue;\n          }\n\n          if (is_ident\n              && (context_p->token.type == LEXER_COMMA\n                  || context_p->token.type == LEXER_RIGHT_BRACE\n                  || context_p->token.type == LEXER_ASSIGN))\n          {\n            context_p->source_p = context_p->token.lit_location.char_p;\n            context_p->line = start_line;\n            context_p->column = start_column;\n\n            lexer_next_token (context_p);\n\n            JERRY_ASSERT (context_p->token.type != LEXER_LITERAL\n                          || context_p->token.lit_location.type == LEXER_IDENT_LITERAL);\n\n            if (context_p->token.type != LEXER_LITERAL)\n            {\n              scanner_raise_error (context_p);\n            }\n\n            if (scanner_context.binding_type != SCANNER_BINDING_NONE)\n            {\n              scanner_context.mode = SCAN_MODE_BINDING;\n              continue;\n            }\n\n            scanner_add_reference (context_p, &scanner_context);\n\n            lexer_next_token (context_p);\n\n            if (context_p->token.type == LEXER_ASSIGN)\n            {\n              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n              break;\n            }\n\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n            continue;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n\n          if (context_p->token.type != LEXER_COLON)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n#if ENABLED (JERRY_ES2015)\n          if (scanner_context.binding_type != SCANNER_BINDING_NONE)\n          {\n            scanner_context.mode = SCAN_MODE_BINDING;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n          break;\n        }\n#if ENABLED (JERRY_ES2015)\n        case SCAN_MODE_BINDING:\n        {\n          JERRY_ASSERT (scanner_context.binding_type == SCANNER_BINDING_VAR\n                        || scanner_context.binding_type == SCANNER_BINDING_LET\n                        || scanner_context.binding_type == SCANNER_BINDING_CATCH\n                        || scanner_context.binding_type == SCANNER_BINDING_CONST\n                        || scanner_context.binding_type == SCANNER_BINDING_ARG\n                        || scanner_context.binding_type == SCANNER_BINDING_ARROW_ARG);\n\n          if (type == LEXER_THREE_DOTS)\n          {\n            lexer_next_token (context_p);\n            type = (lexer_token_type_t) context_p->token.type;\n          }\n\n          if (type == LEXER_LEFT_SQUARE || type == LEXER_LEFT_BRACE)\n          {\n            scanner_push_destructuring_pattern (context_p, &scanner_context, scanner_context.binding_type, true);\n\n            if (type == LEXER_LEFT_SQUARE)\n            {\n              parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n              break;\n            }\n\n            parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n            scanner_context.mode = SCAN_MODE_PROPERTY_NAME;\n            continue;\n          }\n\n          if (type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n          {\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n            continue;\n          }\n\n          lexer_lit_location_t *literal_p = scanner_add_literal (context_p, &scanner_context);\n\n          scanner_context.mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n\n          if (scanner_context.binding_type == SCANNER_BINDING_VAR)\n          {\n            if (!(literal_p->type & SCANNER_LITERAL_IS_VAR))\n            {\n              scanner_detect_invalid_var (context_p, &scanner_context, literal_p);\n              literal_p->type |= SCANNER_LITERAL_IS_VAR;\n\n              if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)\n              {\n                literal_p->type |= SCANNER_LITERAL_NO_REG;\n              }\n            }\n            break;\n          }\n\n          if (scanner_context.binding_type == SCANNER_BINDING_ARROW_ARG)\n          {\n            literal_p->type |= SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG;\n\n            if (literal_p->type & SCANNER_LITERAL_IS_USED)\n            {\n              literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n              break;\n            }\n          }\n          else\n          {\n            scanner_detect_invalid_let (context_p, literal_p);\n\n            if (scanner_context.binding_type <= SCANNER_BINDING_CATCH)\n            {\n              JERRY_ASSERT ((scanner_context.binding_type == SCANNER_BINDING_LET)\n                            || (scanner_context.binding_type == SCANNER_BINDING_CATCH));\n\n              literal_p->type |= SCANNER_LITERAL_IS_LET;\n            }\n            else\n            {\n              literal_p->type |= SCANNER_LITERAL_IS_CONST;\n\n              if (scanner_context.binding_type == SCANNER_BINDING_ARG)\n              {\n                literal_p->type |= SCANNER_LITERAL_IS_ARG;\n\n                if (literal_p->type & SCANNER_LITERAL_IS_USED)\n                {\n                  literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n                  break;\n                }\n              }\n            }\n\n            if (literal_p->type & SCANNER_LITERAL_IS_USED)\n            {\n              literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n              break;\n            }\n          }\n\n          scanner_binding_item_t *binding_item_p;\n          binding_item_p = (scanner_binding_item_t *) scanner_malloc (context_p, sizeof (scanner_binding_item_t));\n\n          binding_item_p->next_p = scanner_context.active_binding_list_p->items_p;\n          binding_item_p->literal_p = literal_p;\n\n          scanner_context.active_binding_list_p->items_p = binding_item_p;\n\n          lexer_next_token (context_p);\n          if (context_p->token.type != LEXER_ASSIGN)\n          {\n            continue;\n          }\n\n          scanner_binding_literal_t binding_literal;\n          binding_literal.literal_p = literal_p;\n\n          parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));\n          parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);\n\n          scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n      }\n\n      lexer_next_token (context_p);\n    }\n\nscan_completed:\n    if (context_p->stack_top_uint8 != SCAN_STACK_SCRIPT\n        && context_p->stack_top_uint8 != SCAN_STACK_SCRIPT_FUNCTION)\n    {\n      scanner_raise_error (context_p);\n    }\n\n    scanner_pop_literal_pool (context_p, &scanner_context);\n\n#if ENABLED (JERRY_ES2015)\n    JERRY_ASSERT (scanner_context.active_binding_list_p == NULL);\n#endif /* ENABLED (JERRY_ES2015) */\n    JERRY_ASSERT (scanner_context.active_literal_pool_p == NULL);\n\n#ifndef JERRY_NDEBUG\n    scanner_context.context_status_flags |= PARSER_SCANNING_SUCCESSFUL;\n#endif /* !JERRY_NDEBUG */\n  }\n  PARSER_CATCH\n  {\n    if (context_p->error != PARSER_ERR_OUT_OF_MEMORY)\n    {\n      context_p->error = PARSER_ERR_NO_ERROR;\n    }\n\n#if ENABLED (JERRY_ES2015)\n    while (scanner_context.active_binding_list_p != NULL)\n    {\n      scanner_pop_binding_list (&scanner_context);\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    PARSER_TRY (context_p->try_buffer)\n    {\n#if ENABLED (JERRY_ES2015)\n      if (scanner_context.status_flags & SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION)\n      {\n        JERRY_ASSERT (scanner_context.async_source_p != NULL);\n\n        scanner_info_t *info_p;\n        info_p = scanner_insert_info (context_p, scanner_context.async_source_p, sizeof (scanner_info_t));\n        info_p->type = SCANNER_TYPE_ERR_ASYNC_FUNCTION;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      while (scanner_context.active_literal_pool_p != NULL)\n      {\n        scanner_pop_literal_pool (context_p, &scanner_context);\n      }\n    }\n    PARSER_CATCH\n    {\n      JERRY_ASSERT (context_p->error == PARSER_ERR_NO_ERROR);\n\n      while (scanner_context.active_literal_pool_p != NULL)\n      {\n        scanner_literal_pool_t *literal_pool_p = scanner_context.active_literal_pool_p;\n\n        scanner_context.active_literal_pool_p = literal_pool_p->prev_p;\n\n        parser_list_free (&literal_pool_p->literal_pool);\n        scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));\n      }\n    }\n    PARSER_TRY_END\n\n#if ENABLED (JERRY_ES2015)\n    context_p->status_flags &= (uint32_t) ~PARSER_IS_GENERATOR_FUNCTION;\n#endif /* ENABLED (JERRY_ES2015) */\n  }\n  PARSER_TRY_END\n\n  context_p->status_flags = scanner_context.context_status_flags;\n  scanner_reverse_info_list (context_p);\n\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n  if (context_p->is_show_opcodes)\n  {\n    scanner_info_t *info_p = context_p->next_scanner_info_p;\n    const uint8_t *source_start_p = (arg_list_p == NULL) ? source_p : arg_list_p;\n\n    while (info_p->type != SCANNER_TYPE_END)\n    {\n      const char *name_p = NULL;\n      bool print_location = false;\n\n      switch (info_p->type)\n      {\n        case SCANNER_TYPE_END_ARGUMENTS:\n        {\n          JERRY_DEBUG_MSG (\"  END_ARGUMENTS\\n\");\n          source_start_p = source_p;\n          break;\n        }\n        case SCANNER_TYPE_FUNCTION:\n        case SCANNER_TYPE_BLOCK:\n        {\n          const uint8_t *prev_source_p = info_p->source_p - 1;\n          const uint8_t *data_p;\n\n          if (info_p->type == SCANNER_TYPE_FUNCTION)\n          {\n            data_p = (const uint8_t *) (info_p + 1);\n\n            JERRY_DEBUG_MSG (\"  FUNCTION: flags: 0x%x declarations: %d\",\n                             (int) info_p->u8_arg,\n                             (int) info_p->u16_arg);\n          }\n          else\n          {\n            data_p = (const uint8_t *) (info_p + 1);\n\n            JERRY_DEBUG_MSG (\"  BLOCK:\");\n          }\n\n          JERRY_DEBUG_MSG (\" source:%d\\n\", (int) (info_p->source_p - source_start_p));\n\n          while (data_p[0] != SCANNER_STREAM_TYPE_END)\n          {\n            switch (data_p[0] & SCANNER_STREAM_TYPE_MASK)\n            {\n              case SCANNER_STREAM_TYPE_VAR:\n              {\n                JERRY_DEBUG_MSG (\"    VAR \");\n                break;\n              }\n#if ENABLED (JERRY_ES2015)\n              case SCANNER_STREAM_TYPE_LET:\n              {\n                JERRY_DEBUG_MSG (\"    LET \");\n                break;\n              }\n              case SCANNER_STREAM_TYPE_CONST:\n              {\n                JERRY_DEBUG_MSG (\"    CONST \");\n                break;\n              }\n              case SCANNER_STREAM_TYPE_LOCAL:\n              {\n                JERRY_DEBUG_MSG (\"    LOCAL \");\n                break;\n              }\n#endif /* ENABLED (JERRY_ES2015) */\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n              case SCANNER_STREAM_TYPE_IMPORT:\n              {\n                JERRY_DEBUG_MSG (\"    IMPORT \");\n                break;\n              }\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n              case SCANNER_STREAM_TYPE_ARG:\n              {\n                JERRY_DEBUG_MSG (\"    ARG \");\n                break;\n              }\n#if ENABLED (JERRY_ES2015)\n              case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:\n              {\n                JERRY_DEBUG_MSG (\"    DESTRUCTURED_ARG \");\n                break;\n              }\n#endif /* ENABLED (JERRY_ES2015) */\n              case SCANNER_STREAM_TYPE_ARG_FUNC:\n              {\n                JERRY_DEBUG_MSG (\"    ARG_FUNC \");\n                break;\n              }\n#if ENABLED (JERRY_ES2015)\n              case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:\n              {\n                JERRY_DEBUG_MSG (\"    DESTRUCTURED_ARG_FUNC \");\n                break;\n              }\n#endif /* ENABLED (JERRY_ES2015) */\n              case SCANNER_STREAM_TYPE_FUNC:\n              {\n                JERRY_DEBUG_MSG (\"    FUNC \");\n                break;\n              }\n              default:\n              {\n                JERRY_ASSERT ((data_p[0] & SCANNER_STREAM_TYPE_MASK) == SCANNER_STREAM_TYPE_HOLE);\n                JERRY_DEBUG_MSG (\"    HOLE\\n\");\n                data_p++;\n                continue;\n              }\n            }\n\n            size_t length;\n\n            if (!(data_p[0] & SCANNER_STREAM_UINT16_DIFF))\n            {\n              if (data_p[2] != 0)\n              {\n                prev_source_p += data_p[2];\n                length = 2 + 1;\n              }\n              else\n              {\n                memcpy (&prev_source_p, data_p + 2 + 1, sizeof (const uint8_t *));\n                length = 2 + 1 + sizeof (const uint8_t *);\n              }\n            }\n            else\n            {\n              int32_t diff = ((int32_t) data_p[2]) | ((int32_t) data_p[3]) << 8;\n\n              if (diff <= UINT8_MAX)\n              {\n                diff = -diff;\n              }\n\n              prev_source_p += diff;\n              length = 2 + 2;\n            }\n\n#if ENABLED (JERRY_ES2015)\n            if (data_p[0] & SCANNER_STREAM_EARLY_CREATE)\n            {\n              JERRY_ASSERT (data_p[0] & SCANNER_STREAM_NO_REG);\n              JERRY_DEBUG_MSG (\"*\");\n            }\n#endif /* ENABLED (JERRY_ES2015) */\n\n            if (data_p[0] & SCANNER_STREAM_NO_REG)\n            {\n              JERRY_DEBUG_MSG (\"* \");\n            }\n\n            JERRY_DEBUG_MSG (\"'%.*s'\\n\", data_p[1], (char *) prev_source_p);\n            prev_source_p += data_p[1];\n            data_p += length;\n          }\n          break;\n        }\n        case SCANNER_TYPE_WHILE:\n        {\n          name_p = \"WHILE\";\n          print_location = true;\n          break;\n        }\n        case SCANNER_TYPE_FOR:\n        {\n          scanner_for_info_t *for_info_p = (scanner_for_info_t *) info_p;\n          JERRY_DEBUG_MSG (\"  FOR: source:%d expression:%d[%d:%d] end:%d[%d:%d]\\n\",\n                           (int) (for_info_p->info.source_p - source_start_p),\n                           (int) (for_info_p->expression_location.source_p - source_start_p),\n                           (int) for_info_p->expression_location.line,\n                           (int) for_info_p->expression_location.column,\n                           (int) (for_info_p->end_location.source_p - source_start_p),\n                           (int) for_info_p->end_location.line,\n                           (int) for_info_p->end_location.column);\n          break;\n        }\n        case SCANNER_TYPE_FOR_IN:\n        {\n          name_p = \"FOR-IN\";\n          print_location = true;\n          break;\n        }\n#if ENABLED (JERRY_ES2015)\n        case SCANNER_TYPE_FOR_OF:\n        {\n          name_p = \"FOR-OF\";\n          print_location = true;\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n        case SCANNER_TYPE_SWITCH:\n        {\n          JERRY_DEBUG_MSG (\"  SWITCH: source:%d\\n\",\n                           (int) (info_p->source_p - source_start_p));\n\n          scanner_case_info_t *current_case_p = ((scanner_switch_info_t *) info_p)->case_p;\n\n          while (current_case_p != NULL)\n          {\n            JERRY_DEBUG_MSG (\"    CASE: location:%d[%d:%d]\\n\",\n                             (int) (current_case_p->location.source_p - source_start_p),\n                             (int) current_case_p->location.line,\n                             (int) current_case_p->location.column);\n\n            current_case_p = current_case_p->next_p;\n          }\n          break;\n        }\n        case SCANNER_TYPE_CASE:\n        {\n          name_p = \"CASE\";\n          print_location = true;\n          break;\n        }\n#if ENABLED (JERRY_ES2015)\n        case SCANNER_TYPE_INITIALIZER:\n        {\n          name_p = \"INITIALIZER\";\n          print_location = true;\n          break;\n        }\n        case SCANNER_TYPE_CLASS_CONSTRUCTOR:\n        {\n          JERRY_DEBUG_MSG (\"  CLASS-CONSTRUCTOR: source:%d\\n\",\n                           (int) (info_p->source_p - source_start_p));\n          print_location = false;\n          break;\n        }\n        case SCANNER_TYPE_LET_EXPRESSION:\n        {\n          JERRY_DEBUG_MSG (\"  LET_EXPRESSION: source:%d\\n\",\n                           (int) (info_p->source_p - source_start_p));\n          break;\n        }\n        case SCANNER_TYPE_ERR_REDECLARED:\n        {\n          JERRY_DEBUG_MSG (\"  ERR_REDECLARED: source:%d\\n\",\n                           (int) (info_p->source_p - source_start_p));\n          break;\n        }\n        case SCANNER_TYPE_ERR_ASYNC_FUNCTION:\n        {\n          JERRY_DEBUG_MSG (\"  ERR_ASYNC_FUNCTION: source:%d\\n\",\n                           (int) (info_p->source_p - source_start_p));\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n      }\n\n      if (print_location)\n      {\n        scanner_location_info_t *location_info_p = (scanner_location_info_t *) info_p;\n        JERRY_DEBUG_MSG (\"  %s: source:%d location:%d[%d:%d]\\n\",\n                         name_p,\n                         (int) (location_info_p->info.source_p - source_start_p),\n                         (int) (location_info_p->location.source_p - source_start_p),\n                         (int) location_info_p->location.line,\n                         (int) location_info_p->location.column);\n      }\n\n      info_p = info_p->next_p;\n    }\n\n    JERRY_DEBUG_MSG (\"\\n--- Scanning end ---\\n\\n\");\n  }\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n\n  parser_stack_free (context_p);\n}",
        "begin_line": 2256,
        "end_line": 3488,
        "is_bug": true
    },
    {
        "name": "jerry-core.parser.js.js-scanner.scanner_scan_post_primary_expression#294",
        "src_path": "jerry-core/parser/js/js-scanner.c",
        "class_name": "jerry-core.parser.js.js-scanner",
        "signature": "jerry-core.parser.js.js-scanner.scanner_scan_post_primary_expression (parser_context_t *context_p, /**< context */                                       scanner_context_t *scanner_context_p, /**< scanner context */                                       lexer_token_type_t type, /**< current token type */                                       scan_stack_modes_t stack_top) /**< current stack top */",
        "snippet": "static bool\nscanner_scan_post_primary_expression (parser_context_t *context_p, /**< context */\n                                      scanner_context_t *scanner_context_p, /**< scanner context */\n                                      lexer_token_type_t type, /**< current token type */\n                                      scan_stack_modes_t stack_top) /**< current stack top */\n{\n  switch (type)\n  {\n    case LEXER_DOT:\n    {\n      lexer_scan_identifier (context_p);\n\n      if (context_p->token.type != LEXER_LITERAL\n          || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      return true;\n    }\n    case LEXER_LEFT_PAREN:\n    {\n      parser_stack_push_uint8 (context_p, SCAN_STACK_PAREN_EXPRESSION);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      return true;\n    }\n#if ENABLED (JERRY_ES2015)\n    case LEXER_TEMPLATE_LITERAL:\n    {\n      if (JERRY_UNLIKELY (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT))\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        parser_stack_push_uint8 (context_p, SCAN_STACK_TAGGED_TEMPLATE_LITERAL);\n      }\n      return true;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case LEXER_LEFT_SQUARE:\n    {\n      parser_stack_push_uint8 (context_p, SCAN_STACK_PROPERTY_ACCESSOR);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      return true;\n    }\n    case LEXER_INCREASE:\n    case LEXER_DECREASE:\n    {\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n\n      if (context_p->token.flags & LEXER_WAS_NEWLINE)\n      {\n        return false;\n      }\n\n      lexer_next_token (context_p);\n      type = (lexer_token_type_t) context_p->token.type;\n\n      if (type != LEXER_QUESTION_MARK)\n      {\n        break;\n      }\n      /* FALLTHRU */\n    }\n    case LEXER_QUESTION_MARK:\n    {\n      parser_stack_push_uint8 (context_p, SCAN_STACK_COLON_EXPRESSION);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      return true;\n    }\n    default:\n    {\n      break;\n    }\n  }\n\n  if (LEXER_IS_BINARY_OP_TOKEN (type)\n      && (type != LEXER_KEYW_IN || !SCANNER_IS_FOR_START (stack_top)))\n  {\n    scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n    return true;\n  }\n\n  return false;\n}",
        "begin_line": 294,
        "end_line": 376,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner.scanner_scan_primary_expression#74",
        "src_path": "jerry-core/parser/js/js-scanner.c",
        "class_name": "jerry-core.parser.js.js-scanner",
        "signature": "jerry-core.parser.js.js-scanner.scanner_scan_primary_expression (parser_context_t *context_p, /**< context */                                  scanner_context_t *scanner_context_p, /* scanner context */                                  lexer_token_type_t type, /**< current token type */                                  scan_stack_modes_t stack_top) /**< current stack top */",
        "snippet": "static scan_return_types_t\nscanner_scan_primary_expression (parser_context_t *context_p, /**< context */\n                                 scanner_context_t *scanner_context_p, /* scanner context */\n                                 lexer_token_type_t type, /**< current token type */\n                                 scan_stack_modes_t stack_top) /**< current stack top */\n{\n  switch (type)\n  {\n    case LEXER_KEYW_NEW:\n    {\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_AFTER_NEW;\n\n#if ENABLED (JERRY_ES2015)\n      if (scanner_try_scan_new_target (context_p))\n      {\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      break;\n    }\n    case LEXER_DIVIDE:\n    case LEXER_ASSIGN_DIVIDE:\n    {\n      lexer_construct_regexp_object (context_p, true);\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      break;\n    }\n    case LEXER_KEYW_FUNCTION:\n    {\n      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION;\n\n#if ENABLED (JERRY_ES2015)\n      if (scanner_context_p->async_source_p != NULL)\n      {\n        status_flags |= SCANNER_LITERAL_POOL_ASYNC;\n      }\n\n      if (lexer_consume_generator (context_p))\n      {\n        status_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scanner_push_literal_pool (context_p, scanner_context_p, status_flags);\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type == LEXER_LITERAL\n          && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n      {\n        lexer_next_token (context_p);\n      }\n\n      parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_EXPRESSION);\n      scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n      return SCAN_KEEP_TOKEN;\n    }\n    case LEXER_LEFT_PAREN:\n    {\n      scanner_scan_bracket (context_p, scanner_context_p);\n      return SCAN_KEEP_TOKEN;\n    }\n    case LEXER_LEFT_SQUARE:\n    {\n#if ENABLED (JERRY_ES2015)\n      scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_NONE, false);\n#endif /* ENABLED (JERRY_ES2015) */\n\n      parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      break;\n    }\n    case LEXER_LEFT_BRACE:\n    {\n#if ENABLED (JERRY_ES2015)\n      scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_NONE, false);\n#endif /* ENABLED (JERRY_ES2015) */\n\n      parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n      scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;\n      return SCAN_KEEP_TOKEN;\n    }\n#if ENABLED (JERRY_ES2015)\n    case LEXER_TEMPLATE_LITERAL:\n    {\n      if (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)\n      {\n        parser_stack_push_uint8 (context_p, SCAN_STACK_TEMPLATE_STRING);\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        break;\n      }\n\n      /* The string is a normal string literal. */\n      /* FALLTHRU */\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case LEXER_LITERAL:\n    {\n#if ENABLED (JERRY_ES2015)\n      const uint8_t *source_p = context_p->source_p;\n\n      if (context_p->token.lit_location.type == LEXER_IDENT_LITERAL\n          && lexer_check_arrow (context_p))\n      {\n        scanner_scan_simple_arrow (context_p, scanner_context_p, source_p);\n        return SCAN_KEEP_TOKEN;\n      }\n      else if (JERRY_UNLIKELY (lexer_token_is_async (context_p)))\n      {\n        scanner_context_p->async_source_p = source_p;\n        scanner_check_async_function (context_p, scanner_context_p);\n        return SCAN_KEEP_TOKEN;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      if (context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n      {\n        scanner_add_reference (context_p, scanner_context_p);\n      }\n      /* FALLTHRU */\n    }\n    case LEXER_KEYW_THIS:\n    case LEXER_KEYW_SUPER:\n    case LEXER_LIT_TRUE:\n    case LEXER_LIT_FALSE:\n    case LEXER_LIT_NULL:\n    {\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      break;\n    }\n#if ENABLED (JERRY_ES2015)\n    case LEXER_KEYW_CLASS:\n    {\n      scanner_push_class_declaration (context_p, scanner_context_p, SCAN_STACK_CLASS_EXPRESSION);\n\n      if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n      {\n        return SCAN_KEEP_TOKEN;\n      }\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case LEXER_RIGHT_SQUARE:\n    {\n      if (stack_top != SCAN_STACK_ARRAY_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n      return SCAN_KEEP_TOKEN;\n    }\n#if ENABLED (JERRY_ES2015)\n    case LEXER_THREE_DOTS:\n    {\n      /* Elision or spread arguments */\n      if (stack_top != SCAN_STACK_PAREN_EXPRESSION && stack_top != SCAN_STACK_ARRAY_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case LEXER_COMMA:\n    {\n      if (stack_top != SCAN_STACK_ARRAY_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n#if ENABLED (JERRY_ES2015)\n      if (scanner_context_p->binding_type != SCANNER_BINDING_NONE)\n      {\n        scanner_context_p->mode = SCAN_MODE_BINDING;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      break;\n    }\n#if ENABLED (JERRY_ES2015)\n    case LEXER_KEYW_YIELD:\n    {\n      lexer_next_token (context_p);\n\n      if (lexer_check_yield_no_arg (context_p))\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n      }\n\n      if (context_p->token.type == LEXER_MULTIPLY)\n      {\n        return SCAN_NEXT_TOKEN;\n      }\n      return SCAN_KEEP_TOKEN;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case LEXER_RIGHT_PAREN:\n    {\n      if (stack_top == SCAN_STACK_PAREN_EXPRESSION)\n      {\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n        parser_stack_pop_uint8 (context_p);\n        break;\n      }\n      /* FALLTHRU */\n    }\n    default:\n    {\n      scanner_raise_error (context_p);\n    }\n  }\n  return SCAN_NEXT_TOKEN;\n}",
        "begin_line": 74,
        "end_line": 287,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner.scanner_scan_primary_expression_end#383",
        "src_path": "jerry-core/parser/js/js-scanner.c",
        "class_name": "jerry-core.parser.js.js-scanner",
        "signature": "jerry-core.parser.js.js-scanner.scanner_scan_primary_expression_end (parser_context_t *context_p, /**< context */                                      scanner_context_t *scanner_context_p, /**< scanner context */                                      lexer_token_type_t type, /**< current token type */                                      scan_stack_modes_t stack_top) /**< current stack top */",
        "snippet": "static scan_return_types_t\nscanner_scan_primary_expression_end (parser_context_t *context_p, /**< context */\n                                     scanner_context_t *scanner_context_p, /**< scanner context */\n                                     lexer_token_type_t type, /**< current token type */\n                                     scan_stack_modes_t stack_top) /**< current stack top */\n{\n  if (type == LEXER_COMMA)\n  {\n    switch (stack_top)\n    {\n      case SCAN_STACK_VAR:\n#if ENABLED (JERRY_ES2015)\n      case SCAN_STACK_LET:\n      case SCAN_STACK_CONST:\n#endif /* ENABLED (JERRY_ES2015) */\n      case SCAN_STACK_FOR_VAR_START:\n#if ENABLED (JERRY_ES2015)\n      case SCAN_STACK_FOR_LET_START:\n      case SCAN_STACK_FOR_CONST_START:\n#endif /* ENABLED (JERRY_ES2015) */\n      {\n        scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n        return SCAN_NEXT_TOKEN;\n      }\n      case SCAN_STACK_COLON_EXPRESSION:\n      {\n        scanner_raise_error (context_p);\n        break;\n      }\n#if ENABLED (JERRY_ES2015)\n      case SCAN_STACK_BINDING_INIT:\n      case SCAN_STACK_BINDING_LIST_INIT:\n      {\n        break;\n      }\n      case SCAN_STACK_ARROW_ARGUMENTS:\n      {\n        lexer_next_token (context_p);\n        scanner_check_arrow_arg (context_p, scanner_context_p);\n        return SCAN_KEEP_TOKEN;\n      }\n      case SCAN_STACK_ARROW_EXPRESSION:\n      {\n        break;\n      }\n      case SCAN_STACK_FUNCTION_PARAMETERS:\n      {\n        scanner_context_p->mode = SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS;\n        parser_stack_pop_uint8 (context_p);\n        return SCAN_NEXT_TOKEN;\n      }\n      case SCAN_STACK_ARRAY_LITERAL:\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n        if (scanner_context_p->binding_type != SCANNER_BINDING_NONE)\n        {\n          scanner_context_p->mode = SCAN_MODE_BINDING;\n        }\n\n        return SCAN_NEXT_TOKEN;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      case SCAN_STACK_OBJECT_LITERAL:\n      {\n        scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;\n        return SCAN_KEEP_TOKEN;\n      }\n      default:\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_NEXT_TOKEN;\n      }\n    }\n  }\n\n  switch (stack_top)\n  {\n    case SCAN_STACK_WITH_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      parser_stack_pop_uint8 (context_p);\n\n      uint16_t status_flags = scanner_context_p->active_literal_pool_p->status_flags;\n      parser_stack_push_uint8 (context_p, (status_flags & SCANNER_LITERAL_POOL_IN_WITH) ? 1 : 0);\n      parser_stack_push_uint8 (context_p, SCAN_STACK_WITH_STATEMENT);\n      status_flags |= SCANNER_LITERAL_POOL_IN_WITH;\n      scanner_context_p->active_literal_pool_p->status_flags = status_flags;\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_DO_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_WHILE_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      scanner_source_start_t source_start;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));\n\n      scanner_location_info_t *location_info_p;\n      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,\n                                                                         source_start.source_p,\n                                                                         sizeof (scanner_location_info_t));\n      location_info_p->info.type = SCANNER_TYPE_WHILE;\n\n      scanner_get_location (&location_info_p->location, context_p);\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_PAREN_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      parser_stack_pop_uint8 (context_p);\n\n#if ENABLED (JERRY_ES2015)\n      if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)\n      {\n        scanner_add_async_literal (context_p, scanner_context_p);\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_STATEMENT_WITH_EXPR:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      parser_stack_pop_uint8 (context_p);\n\n#if ENABLED (JERRY_ES2015)\n      if (context_p->stack_top_uint8 == SCAN_STACK_IF_STATEMENT)\n      {\n        scanner_check_function_after_if (context_p, scanner_context_p);\n        return SCAN_KEEP_TOKEN;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_NEXT_TOKEN;\n    }\n#if ENABLED (JERRY_ES2015)\n    case SCAN_STACK_BINDING_LIST_INIT:\n    {\n      parser_stack_pop_uint8 (context_p);\n\n      JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_ARRAY_LITERAL\n                    || context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL\n                    || context_p->stack_top_uint8 == SCAN_STACK_LET\n                    || context_p->stack_top_uint8 == SCAN_STACK_CONST\n                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_LET_START\n                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_CONST_START\n                    || context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_PARAMETERS\n                    || context_p->stack_top_uint8 == SCAN_STACK_ARROW_ARGUMENTS);\n\n      scanner_binding_item_t *item_p = scanner_context_p->active_binding_list_p->items_p;\n\n      while (item_p != NULL)\n      {\n        if (item_p->literal_p->type & SCANNER_LITERAL_IS_USED)\n        {\n          item_p->literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n        }\n        item_p = item_p->next_p;\n      }\n\n      scanner_pop_binding_list (scanner_context_p);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_BINDING_INIT:\n    {\n      scanner_binding_literal_t binding_literal;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &binding_literal, sizeof (scanner_binding_literal_t));\n\n      JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_ARRAY_LITERAL\n                    || context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL\n                    || context_p->stack_top_uint8 == SCAN_STACK_LET\n                    || context_p->stack_top_uint8 == SCAN_STACK_CONST\n                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_LET_START\n                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_CONST_START\n                    || context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_PARAMETERS\n                    || context_p->stack_top_uint8 == SCAN_STACK_ARROW_ARGUMENTS);\n\n      JERRY_ASSERT ((stack_top != SCAN_STACK_ARRAY_LITERAL && stack_top != SCAN_STACK_OBJECT_LITERAL)\n                    || SCANNER_NEEDS_BINDING_LIST (scanner_context_p->binding_type));\n\n      if (binding_literal.literal_p->type & SCANNER_LITERAL_IS_USED)\n      {\n        binding_literal.literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n      return SCAN_KEEP_TOKEN;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case SCAN_STACK_VAR:\n#if ENABLED (JERRY_ES2015)\n    case SCAN_STACK_LET:\n    case SCAN_STACK_CONST:\n#endif /* ENABLED (JERRY_ES2015) */\n    {\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n      scanner_context_p->active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n      parser_stack_pop_uint8 (context_p);\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_FOR_VAR_START:\n#if ENABLED (JERRY_ES2015)\n    case SCAN_STACK_FOR_LET_START:\n    case SCAN_STACK_FOR_CONST_START:\n#endif /* ENABLED (JERRY_ES2015) */\n    case SCAN_STACK_FOR_START:\n    {\n      if (type == LEXER_KEYW_IN || SCANNER_IDENTIFIER_IS_OF ())\n      {\n        scanner_for_statement_t for_statement;\n\n        parser_stack_pop_uint8 (context_p);\n        parser_stack_pop (context_p, &for_statement, sizeof (scanner_for_statement_t));\n\n        scanner_location_info_t *location_info;\n        location_info = (scanner_location_info_t *) scanner_insert_info (context_p,\n                                                                         for_statement.u.source_p,\n                                                                         sizeof (scanner_location_info_t));\n#if ENABLED (JERRY_ES2015)\n        location_info->info.type = (type == LEXER_KEYW_IN) ? SCANNER_TYPE_FOR_IN : SCANNER_TYPE_FOR_OF;\n\n        if (stack_top == SCAN_STACK_FOR_LET_START || stack_top == SCAN_STACK_FOR_CONST_START)\n        {\n          parser_stack_push_uint8 (context_p, SCAN_STACK_PRIVATE_BLOCK_EARLY);\n        }\n#else /* !ENABLED (JERRY_ES2015) */\n        location_info->info.type = SCANNER_TYPE_FOR_IN;\n#endif /* ENABLED (JERRY_ES2015) */\n\n        scanner_get_location (&location_info->location, context_p);\n\n        parser_stack_push_uint8 (context_p, SCAN_STACK_STATEMENT_WITH_EXPR);\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_NEXT_TOKEN;\n      }\n\n      if (type != LEXER_SEMICOLON)\n      {\n        break;\n      }\n\n      scanner_for_statement_t for_statement;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, NULL, sizeof (scanner_for_statement_t));\n\n#if ENABLED (JERRY_ES2015)\n      if (stack_top == SCAN_STACK_FOR_LET_START || stack_top == SCAN_STACK_FOR_CONST_START)\n      {\n        parser_stack_push_uint8 (context_p, SCAN_STACK_PRIVATE_BLOCK);\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      for_statement.u.source_p = context_p->source_p;\n      parser_stack_push (context_p, &for_statement, sizeof (scanner_for_statement_t));\n      parser_stack_push_uint8 (context_p, SCAN_STACK_FOR_CONDITION);\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_SEMICOLON)\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      type = LEXER_SEMICOLON;\n      /* FALLTHRU */\n    }\n    case SCAN_STACK_FOR_CONDITION:\n    {\n      if (type != LEXER_SEMICOLON)\n      {\n        break;\n      }\n\n      scanner_for_statement_t for_statement;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &for_statement, sizeof (scanner_for_statement_t));\n\n      scanner_for_info_t *for_info_p;\n      for_info_p = (scanner_for_info_t *) scanner_insert_info (context_p,\n                                                               for_statement.u.source_p,\n                                                               sizeof (scanner_for_info_t));\n      for_info_p->info.type = SCANNER_TYPE_FOR;\n\n      scanner_get_location (&for_info_p->expression_location, context_p);\n      for_info_p->end_location.source_p = NULL;\n\n      for_statement.u.for_info_p = for_info_p;\n\n      parser_stack_push (context_p, &for_statement, sizeof (scanner_for_statement_t));\n      parser_stack_push_uint8 (context_p, SCAN_STACK_FOR_EXPRESSION);\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_RIGHT_PAREN)\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      type = LEXER_RIGHT_PAREN;\n      /* FALLTHRU */\n    }\n    case SCAN_STACK_FOR_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      scanner_for_statement_t for_statement;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &for_statement, sizeof (scanner_for_statement_t));\n\n      scanner_get_location (&for_statement.u.for_info_p->end_location, context_p);\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_SWITCH_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_LEFT_BRACE)\n      {\n        break;\n      }\n\n#if ENABLED (JERRY_ES2015)\n      scanner_literal_pool_t *literal_pool_p;\n      literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_BLOCK);\n      literal_pool_p->source_p = context_p->source_p - 1;\n#endif /* ENABLED (JERRY_ES2015) */\n\n      parser_stack_pop_uint8 (context_p);\n\n      scanner_switch_statement_t switch_statement = scanner_context_p->active_switch_statement;\n      parser_stack_push (context_p, &switch_statement, sizeof (scanner_switch_statement_t));\n      parser_stack_push_uint8 (context_p, SCAN_STACK_SWITCH_BLOCK);\n\n      scanner_switch_info_t *switch_info_p;\n      switch_info_p = (scanner_switch_info_t *) scanner_insert_info (context_p,\n                                                                     context_p->source_p,\n                                                                     sizeof (scanner_switch_info_t));\n      switch_info_p->info.type = SCANNER_TYPE_SWITCH;\n      switch_info_p->case_p = NULL;\n      scanner_context_p->active_switch_statement.last_case_p = &switch_info_p->case_p;\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_RIGHT_BRACE\n          && context_p->token.type != LEXER_KEYW_CASE\n          && context_p->token.type != LEXER_KEYW_DEFAULT)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_CASE_STATEMENT:\n    {\n      if (type != LEXER_COLON)\n      {\n        break;\n      }\n\n      scanner_source_start_t source_start;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));\n\n      scanner_location_info_t *location_info_p;\n      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,\n                                                                         source_start.source_p,\n                                                                         sizeof (scanner_location_info_t));\n      location_info_p->info.type = SCANNER_TYPE_CASE;\n\n      scanner_get_location (&location_info_p->location, context_p);\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_COLON_EXPRESSION:\n    {\n      if (type != LEXER_COLON)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      parser_stack_pop_uint8 (context_p);\n      return SCAN_NEXT_TOKEN;\n    }\n#if ENABLED (JERRY_ES2015)\n    case SCAN_STACK_ARRAY_LITERAL:\n    case SCAN_STACK_OBJECT_LITERAL:\n    {\n      if (((stack_top == SCAN_STACK_ARRAY_LITERAL) && (type != LEXER_RIGHT_SQUARE))\n          || ((stack_top == SCAN_STACK_OBJECT_LITERAL) && (type != LEXER_RIGHT_BRACE)))\n      {\n        break;\n      }\n\n      scanner_source_start_t source_start;\n      uint8_t binding_type = scanner_context_p->binding_type;\n\n      parser_stack_pop_uint8 (context_p);\n      scanner_context_p->binding_type = context_p->stack_top_uint8;\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));\n\n      lexer_next_token (context_p);\n\n      if (binding_type == SCANNER_BINDING_CATCH && context_p->stack_top_uint8 == SCAN_STACK_CATCH_STATEMENT)\n      {\n        scanner_pop_binding_list (scanner_context_p);\n\n        if (context_p->token.type != LEXER_RIGHT_PAREN)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_LEFT_BRACE)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n        return SCAN_NEXT_TOKEN;\n      }\n\n      if (context_p->token.type != LEXER_ASSIGN)\n      {\n        if (SCANNER_NEEDS_BINDING_LIST (binding_type))\n        {\n          scanner_pop_binding_list (scanner_context_p);\n        }\n\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      scanner_location_info_t *location_info_p;\n      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,\n                                                                         source_start.source_p,\n                                                                         sizeof (scanner_location_info_t));\n      location_info_p->info.type = SCANNER_TYPE_INITIALIZER;\n      scanner_get_location (&location_info_p->location, context_p);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n      if (SCANNER_NEEDS_BINDING_LIST (binding_type))\n      {\n        scanner_binding_item_t *item_p = scanner_context_p->active_binding_list_p->items_p;\n\n        while (item_p != NULL)\n        {\n          item_p->literal_p->type &= (uint8_t) ~SCANNER_LITERAL_IS_USED;\n          item_p = item_p->next_p;\n        }\n\n        parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_LIST_INIT);\n      }\n      return SCAN_NEXT_TOKEN;\n    }\n#else /* !ENABLED (JERRY_ES2015) */\n    case SCAN_STACK_ARRAY_LITERAL:\n#endif /* ENABLED (JERRY_ES2015) */\n    case SCAN_STACK_PROPERTY_ACCESSOR:\n    {\n      if (type != LEXER_RIGHT_SQUARE)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      parser_stack_pop_uint8 (context_p);\n      return SCAN_NEXT_TOKEN;\n    }\n#if !ENABLED (JERRY_ES2015)\n    case SCAN_STACK_OBJECT_LITERAL:\n    {\n      if (type != LEXER_RIGHT_BRACE)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      parser_stack_pop_uint8 (context_p);\n      return SCAN_NEXT_TOKEN;\n    }\n#endif /* !ENABLED (JERRY_ES2015) */\n#if ENABLED (JERRY_ES2015)\n    case SCAN_STACK_COMPUTED_PROPERTY:\n    {\n      if (type != LEXER_RIGHT_SQUARE)\n      {\n        break;\n      }\n\n      lexer_next_token (context_p);\n\n      parser_stack_pop_uint8 (context_p);\n      stack_top = (scan_stack_modes_t) context_p->stack_top_uint8;\n\n      if (stack_top == SCAN_STACK_FUNCTION_PROPERTY)\n      {\n        scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_FUNCTION);\n\n        scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      JERRY_ASSERT (stack_top == SCAN_STACK_OBJECT_LITERAL);\n\n      if (context_p->token.type == LEXER_LEFT_PAREN)\n      {\n        scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_FUNCTION);\n\n        parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n        scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      if (context_p->token.type != LEXER_COLON)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n      if (scanner_context_p->binding_type != SCANNER_BINDING_NONE)\n      {\n        scanner_context_p->mode = SCAN_MODE_BINDING;\n      }\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_COMPUTED_GENERATOR:\n    case SCAN_STACK_COMPUTED_ASYNC:\n    case SCAN_STACK_COMPUTED_ASYNC_GENERATOR:\n    {\n      if (type != LEXER_RIGHT_SQUARE)\n      {\n        break;\n      }\n\n      lexer_next_token (context_p);\n      parser_stack_pop_uint8 (context_p);\n\n      JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL\n                    || context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_PROPERTY);\n\n      uint16_t status_flags = (uint16_t) (SCANNER_LITERAL_POOL_FUNCTION\n                                          | SCANNER_LITERAL_POOL_GENERATOR\n                                          | SCANNER_FROM_COMPUTED_TO_LITERAL_POOL (stack_top));\n\n      scanner_push_literal_pool (context_p, scanner_context_p, status_flags);\n\n      scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_TEMPLATE_STRING:\n    case SCAN_STACK_TAGGED_TEMPLATE_LITERAL:\n    {\n      if (type != LEXER_RIGHT_BRACE)\n      {\n        break;\n      }\n\n      context_p->source_p--;\n      context_p->column--;\n      lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);\n\n      if (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      }\n      else\n      {\n        parser_stack_pop_uint8 (context_p);\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      }\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_ARROW_ARGUMENTS:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      scanner_check_arrow (context_p, scanner_context_p);\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_ARROW_EXPRESSION:\n    {\n      scanner_pop_literal_pool (context_p, scanner_context_p);\n      parser_stack_pop_uint8 (context_p);\n      lexer_update_await_yield (context_p, context_p->status_flags);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_CLASS_EXTENDS:\n    {\n      if (type != LEXER_LEFT_BRACE)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_CLASS_METHOD;\n      parser_stack_pop_uint8 (context_p);\n\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_FUNCTION_PARAMETERS:\n    {\n      parser_stack_pop_uint8 (context_p);\n\n      if (type != LEXER_RIGHT_PAREN\n          && (type != LEXER_EOS || context_p->stack_top_uint8 != SCAN_STACK_SCRIPT_FUNCTION))\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS;\n      return SCAN_KEEP_TOKEN;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    default:\n    {\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      return SCAN_KEEP_TOKEN;\n    }\n  }\n\n  scanner_raise_error (context_p);\n  return SCAN_NEXT_TOKEN;\n}",
        "begin_line": 383,
        "end_line": 1068,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner.scanner_scan_statement#1075",
        "src_path": "jerry-core/parser/js/js-scanner.c",
        "class_name": "jerry-core.parser.js.js-scanner",
        "signature": "jerry-core.parser.js.js-scanner.scanner_scan_statement (parser_context_t *context_p, /**< context */                         scanner_context_t *scanner_context_p, /**< scanner context */                         lexer_token_type_t type, /**< current token type */                         scan_stack_modes_t stack_top) /**< current stack top */",
        "snippet": "static scan_return_types_t\nscanner_scan_statement (parser_context_t *context_p, /**< context */\n                        scanner_context_t *scanner_context_p, /**< scanner context */\n                        lexer_token_type_t type, /**< current token type */\n                        scan_stack_modes_t stack_top) /**< current stack top */\n{\n  switch (type)\n  {\n    case LEXER_SEMICOLON:\n    {\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      return SCAN_KEEP_TOKEN;\n    }\n    case LEXER_LEFT_BRACE:\n    {\n#if ENABLED (JERRY_ES2015)\n      scanner_literal_pool_t *literal_pool_p;\n      literal_pool_p = scanner_push_literal_pool (context_p,\n                                                  scanner_context_p,\n                                                  SCANNER_LITERAL_POOL_BLOCK);\n      literal_pool_p->source_p = context_p->source_p;\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_BLOCK_STATEMENT);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_DO:\n    {\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_DO_STATEMENT);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_TRY:\n    {\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_LEFT_BRACE)\n      {\n        scanner_raise_error (context_p);\n      }\n\n#if ENABLED (JERRY_ES2015)\n      scanner_literal_pool_t *literal_pool_p;\n      literal_pool_p = scanner_push_literal_pool (context_p,\n                                                  scanner_context_p,\n                                                  SCANNER_LITERAL_POOL_BLOCK);\n      literal_pool_p->source_p = context_p->source_p;\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_TRY_STATEMENT);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_DEBUGGER:\n    {\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_IF:\n    case LEXER_KEYW_WITH:\n    case LEXER_KEYW_SWITCH:\n    {\n      lexer_next_token (context_p);\n      if (context_p->token.type != LEXER_LEFT_PAREN)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      uint8_t mode = SCAN_STACK_STATEMENT_WITH_EXPR;\n\n      if (type == LEXER_KEYW_IF)\n      {\n        parser_stack_push_uint8 (context_p, SCAN_STACK_IF_STATEMENT);\n      }\n      else if (type == LEXER_KEYW_WITH)\n      {\n        mode = SCAN_STACK_WITH_EXPRESSION;\n      }\n      else if (type == LEXER_KEYW_SWITCH)\n      {\n        mode = SCAN_STACK_SWITCH_EXPRESSION;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      parser_stack_push_uint8 (context_p, mode);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_WHILE:\n    {\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_LEFT_PAREN)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n      scanner_source_start_t source_start;\n      source_start.source_p = context_p->source_p;\n\n      parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));\n      parser_stack_push_uint8 (context_p, SCAN_STACK_WHILE_EXPRESSION);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_FOR:\n    {\n      lexer_next_token (context_p);\n      if (context_p->token.type != LEXER_LEFT_PAREN)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_for_statement_t for_statement;\n      for_statement.u.source_p = context_p->source_p;\n      uint8_t stack_mode = SCAN_STACK_FOR_START;\n      scan_return_types_t return_type = SCAN_KEEP_TOKEN;\n\n      lexer_next_token (context_p);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n#if ENABLED (JERRY_ES2015)\n      const uint8_t *source_p = context_p->source_p;\n#endif /* ENABLED (JERRY_ES2015) */\n\n      switch (context_p->token.type)\n      {\n        case LEXER_SEMICOLON:\n        {\n          scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n          break;\n        }\n        case LEXER_KEYW_VAR:\n        {\n          scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n          stack_mode = SCAN_STACK_FOR_VAR_START;\n          return_type = SCAN_NEXT_TOKEN;\n          break;\n        }\n#if ENABLED (JERRY_ES2015)\n        case LEXER_LITERAL:\n        {\n          if (!lexer_token_is_let (context_p))\n          {\n            break;\n          }\n\n          parser_line_counter_t line = context_p->line;\n          parser_line_counter_t column = context_p->column;\n\n          if (lexer_check_arrow (context_p))\n          {\n            context_p->source_p = source_p;\n            context_p->line = line;\n            context_p->column = column;\n            context_p->token.flags &= (uint8_t) ~LEXER_NO_SKIP_SPACES;\n            break;\n          }\n\n          lexer_next_token (context_p);\n\n          type = (lexer_token_type_t) context_p->token.type;\n\n          if (type != LEXER_LEFT_SQUARE\n              && type != LEXER_LEFT_BRACE\n              && (type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL))\n          {\n            scanner_info_t *info_p = scanner_insert_info (context_p, source_p, sizeof (scanner_info_t));\n            info_p->type = SCANNER_TYPE_LET_EXPRESSION;\n\n            scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n            break;\n          }\n\n          scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n          /* FALLTHRU */\n        }\n        case LEXER_KEYW_LET:\n        case LEXER_KEYW_CONST:\n        {\n          scanner_literal_pool_t *literal_pool_p;\n          literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_BLOCK);\n          literal_pool_p->source_p = source_p;\n\n          if (scanner_context_p->mode == SCAN_MODE_PRIMARY_EXPRESSION)\n          {\n            scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n            return_type = SCAN_NEXT_TOKEN;\n          }\n\n          stack_mode = ((context_p->token.type == LEXER_KEYW_CONST) ? SCAN_STACK_FOR_CONST_START\n                                                                    : SCAN_STACK_FOR_LET_START);\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n      }\n\n      parser_stack_push (context_p, &for_statement, sizeof (scanner_for_statement_t));\n      parser_stack_push_uint8 (context_p, stack_mode);\n      return return_type;\n    }\n    case LEXER_KEYW_VAR:\n    {\n      scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_VAR);\n      return SCAN_NEXT_TOKEN;\n    }\n#if ENABLED (JERRY_ES2015)\n    case LEXER_KEYW_LET:\n    {\n      scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_LET);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_CONST:\n    {\n      scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_CONST);\n      return SCAN_NEXT_TOKEN;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case LEXER_KEYW_THROW:\n    {\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_RETURN:\n    {\n      lexer_next_token (context_p);\n\n      if (!(context_p->token.flags & LEXER_WAS_NEWLINE)\n          && context_p->token.type != LEXER_SEMICOLON\n          && context_p->token.type != LEXER_EOS\n          && context_p->token.type != LEXER_RIGHT_BRACE)\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      return SCAN_KEEP_TOKEN;\n    }\n    case LEXER_KEYW_BREAK:\n    case LEXER_KEYW_CONTINUE:\n    {\n      lexer_next_token (context_p);\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n\n      if (!(context_p->token.flags & LEXER_WAS_NEWLINE)\n          && context_p->token.type == LEXER_LITERAL\n          && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n      {\n        return SCAN_NEXT_TOKEN;\n      }\n      return SCAN_KEEP_TOKEN;\n    }\n    case LEXER_KEYW_CASE:\n    case LEXER_KEYW_DEFAULT:\n    {\n      if (stack_top != SCAN_STACK_SWITCH_BLOCK)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_case_info_t *case_info_p;\n      case_info_p = (scanner_case_info_t *) scanner_malloc (context_p, sizeof (scanner_case_info_t));\n\n      *(scanner_context_p->active_switch_statement.last_case_p) = case_info_p;\n      scanner_context_p->active_switch_statement.last_case_p = &case_info_p->next_p;\n\n      case_info_p->next_p = NULL;\n      scanner_get_location (&case_info_p->location, context_p);\n\n      if (type == LEXER_KEYW_DEFAULT)\n      {\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_COLON)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n        return SCAN_NEXT_TOKEN;\n      }\n\n      scanner_source_start_t source_start;\n      source_start.source_p = context_p->source_p;\n\n      parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));\n      parser_stack_push_uint8 (context_p, SCAN_STACK_CASE_STATEMENT);\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_FUNCTION:\n    {\n#if ENABLED (JERRY_ES2015)\n      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION | SCANNER_LITERAL_POOL_FUNCTION_STATEMENT;\n\n      if (scanner_context_p->async_source_p != NULL)\n      {\n        scanner_context_p->status_flags |= SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION;\n        status_flags |= SCANNER_LITERAL_POOL_ASYNC;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      lexer_next_token (context_p);\n\n#if ENABLED (JERRY_ES2015)\n      if (context_p->token.type == LEXER_MULTIPLY)\n      {\n        status_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n        lexer_next_token (context_p);\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      if (context_p->token.type != LEXER_LITERAL\n          || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);\n\n#if ENABLED (JERRY_ES2015)\n      const uint8_t mask = (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LOCAL);\n\n      if ((literal_p->type & SCANNER_LITERAL_IS_LOCAL)\n          && (literal_p->type & mask) != (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG)\n          && (literal_p->type & mask) != (SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_FUNC_DECLARATION))\n      {\n        scanner_raise_redeclaration_error (context_p);\n      }\n\n      literal_p->type |= SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_FUNC_DECLARATION;\n\n      scanner_context_p->status_flags &= (uint16_t) ~SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION;\n#else\n      literal_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC;\n\n      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION;\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scanner_push_literal_pool (context_p, scanner_context_p, status_flags);\n\n      scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_STATEMENT);\n      return SCAN_NEXT_TOKEN;\n    }\n#if ENABLED (JERRY_ES2015)\n    case LEXER_KEYW_CLASS:\n    {\n      scanner_push_class_declaration (context_p, scanner_context_p, SCAN_STACK_CLASS_STATEMENT);\n\n      if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);\n\n      scanner_detect_invalid_let (context_p, literal_p);\n      literal_p->type |= SCANNER_LITERAL_IS_LET;\n\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n      if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT)\n      {\n        literal_p->type |= SCANNER_LITERAL_NO_REG;\n        scanner_context_p->active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;\n      }\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n      return SCAN_NEXT_TOKEN;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n    case LEXER_KEYW_IMPORT:\n    {\n      if (stack_top != SCAN_STACK_SCRIPT)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      context_p->global_status_flags |= ECMA_PARSE_MODULE;\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      lexer_next_token (context_p);\n\n      if (context_p->token.type == LEXER_LITERAL\n          && context_p->token.lit_location.type == LEXER_STRING_LITERAL)\n      {\n        return SCAN_NEXT_TOKEN;\n      }\n\n      bool parse_imports = true;\n\n      if (context_p->token.type == LEXER_LITERAL\n          && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n      {\n        lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);\n\n#if ENABLED (JERRY_ES2015)\n        scanner_detect_invalid_let (context_p, literal_p);\n        literal_p->type |= SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_NO_REG;\n#else /* !ENABLED (JERRY_ES2015) */\n        literal_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_NO_REG;\n#endif /* ENABLED (JERRY_ES2015) */\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type == LEXER_COMMA)\n        {\n          lexer_next_token (context_p);\n        }\n        else\n        {\n          parse_imports = false;\n        }\n      }\n\n      if (parse_imports)\n      {\n        if (context_p->token.type == LEXER_MULTIPLY)\n        {\n          lexer_next_token (context_p);\n          if (!lexer_token_is_identifier (context_p, \"as\", 2))\n          {\n            scanner_raise_error (context_p);\n          }\n\n          lexer_next_token (context_p);\n\n          if (context_p->token.type != LEXER_LITERAL\n              && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);\n\n#if ENABLED (JERRY_ES2015)\n          scanner_detect_invalid_let (context_p, literal_p);\n          literal_p->type |= SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_NO_REG;\n#else /* !ENABLED (JERRY_ES2015) */\n          literal_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_NO_REG;\n#endif /* ENABLED (JERRY_ES2015) */\n\n          lexer_next_token (context_p);\n        }\n        else if (context_p->token.type == LEXER_LEFT_BRACE)\n        {\n          lexer_next_token (context_p);\n\n          while (context_p->token.type != LEXER_RIGHT_BRACE)\n          {\n            if (context_p->token.type != LEXER_LITERAL\n                || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n            {\n              scanner_raise_error (context_p);\n            }\n\n#if ENABLED (JERRY_ES2015)\n            const uint8_t *source_p = context_p->source_p;\n#endif /* ENABLED (JERRY_ES2015) */\n\n            if (lexer_check_next_character (context_p, LIT_CHAR_LOWERCASE_A))\n            {\n              lexer_next_token (context_p);\n\n              if (!lexer_token_is_identifier (context_p, \"as\", 2))\n              {\n                scanner_raise_error (context_p);\n              }\n\n              lexer_next_token (context_p);\n\n              if (context_p->token.type != LEXER_LITERAL\n                  && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n              {\n                scanner_raise_error (context_p);\n              }\n\n#if ENABLED (JERRY_ES2015)\n              source_p = context_p->source_p;\n#endif /* ENABLED (JERRY_ES2015) */\n            }\n\n            lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);\n\n#if ENABLED (JERRY_ES2015)\n            if (literal_p->type & (SCANNER_LITERAL_IS_ARG\n                                   | SCANNER_LITERAL_IS_VAR\n                                   | SCANNER_LITERAL_IS_LOCAL))\n            {\n              context_p->source_p = source_p;\n              scanner_raise_redeclaration_error (context_p);\n            }\n\n            if (literal_p->type & SCANNER_LITERAL_IS_FUNC)\n            {\n              literal_p->type &= (uint8_t) ~SCANNER_LITERAL_IS_FUNC;\n            }\n\n            literal_p->type |= SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_NO_REG;\n#else /* !ENABLED (JERRY_ES2015) */\n            literal_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_NO_REG;\n#endif /* ENABLED (JERRY_ES2015) */\n\n            lexer_next_token (context_p);\n\n            if (context_p->token.type != LEXER_RIGHT_BRACE)\n            {\n              if (context_p->token.type != LEXER_COMMA)\n              {\n                scanner_raise_error (context_p);\n              }\n\n              lexer_next_token (context_p);\n            }\n          }\n\n          lexer_next_token (context_p);\n        }\n        else\n        {\n          scanner_raise_error (context_p);\n        }\n      }\n\n      if (!lexer_token_is_identifier (context_p, \"from\", 4))\n      {\n        scanner_raise_error (context_p);\n      }\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_LITERAL\n          && context_p->token.lit_location.type != LEXER_STRING_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_EXPORT:\n    {\n      if (stack_top != SCAN_STACK_SCRIPT)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      context_p->global_status_flags |= ECMA_PARSE_MODULE;\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type == LEXER_KEYW_DEFAULT)\n      {\n        lexer_next_token (context_p);\n\n        if (context_p->token.type == LEXER_KEYW_FUNCTION)\n        {\n          lexer_next_token (context_p);\n          if (context_p->token.type == LEXER_LITERAL\n              && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n          {\n            lexer_lit_location_t *location_p = scanner_add_literal (context_p, scanner_context_p);\n\n#if ENABLED (JERRY_ES2015)\n            if (location_p->type & SCANNER_LITERAL_IS_LOCAL\n                && !(location_p->type & SCANNER_LITERAL_IS_FUNC))\n            {\n              scanner_raise_redeclaration_error (context_p);\n            }\n            location_p->type |= SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LET;\n#else /* !ENABLED (JERRY_ES2015) */\n            location_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC;\n#endif /* ENABLED (JERRY_ES2015) */\n\n            lexer_next_token (context_p);\n          }\n          else\n          {\n            lexer_lit_location_t *location_p;\n            location_p = scanner_add_custom_literal (context_p,\n                                                     scanner_context_p->active_literal_pool_p,\n                                                     &lexer_default_literal);\n#if ENABLED (JERRY_ES2015)\n            location_p->type |= SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LET;\n#else /* !ENABLED (JERRY_ES2015) */\n            location_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC;\n#endif /* ENABLED (JERRY_ES2015) */\n          }\n\n          scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_FUNCTION);\n\n          parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_STATEMENT);\n          scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n          return SCAN_KEEP_TOKEN;\n        }\n#if ENABLED (JERRY_ES2015)\n        if (context_p->token.type == LEXER_KEYW_CLASS)\n        {\n          scanner_push_class_declaration (context_p, scanner_context_p, SCAN_STACK_CLASS_STATEMENT);\n\n          if (context_p->token.type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n          {\n            lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);\n\n            scanner_detect_invalid_let (context_p, literal_p);\n\n            literal_p->type |= SCANNER_LITERAL_IS_LET | SCANNER_LITERAL_NO_REG;\n            return SCAN_NEXT_TOKEN;\n          }\n\n          lexer_lit_location_t *literal_p;\n          literal_p = scanner_add_custom_literal (context_p,\n                                                  scanner_context_p->active_literal_pool_p,\n                                                  &lexer_default_literal);\n          literal_p->type |= SCANNER_LITERAL_IS_LET | SCANNER_LITERAL_NO_REG;\n          return SCAN_KEEP_TOKEN;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        /* Assignment expression. */\n        lexer_lit_location_t *location_p;\n        location_p = scanner_add_custom_literal (context_p,\n                                                 scanner_context_p->active_literal_pool_p,\n                                                 &lexer_default_literal);\n        location_p->type |= SCANNER_LITERAL_IS_VAR;\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n        if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n        {\n          return SCAN_KEEP_TOKEN;\n        }\n\n        location_p = scanner_add_literal (context_p, scanner_context_p);\n        location_p->type |= SCANNER_LITERAL_IS_VAR;\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n        return SCAN_NEXT_TOKEN;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n\n      if (context_p->token.type == LEXER_MULTIPLY)\n      {\n        lexer_next_token (context_p);\n        if (!lexer_token_is_identifier (context_p, \"from\", 4))\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_LITERAL\n            && context_p->token.lit_location.type == LEXER_STRING_LITERAL)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        return SCAN_NEXT_TOKEN;\n      }\n\n      if (context_p->token.type == LEXER_LEFT_BRACE)\n      {\n        lexer_next_token (context_p);\n\n        while (context_p->token.type != LEXER_RIGHT_BRACE)\n        {\n          if (context_p->token.type != LEXER_LITERAL\n              || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          lexer_next_token (context_p);\n\n          if (lexer_token_is_identifier (context_p, \"as\", 2))\n          {\n            lexer_next_token (context_p);\n\n            if (context_p->token.type != LEXER_LITERAL\n                && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n            {\n              scanner_raise_error (context_p);\n            }\n\n            lexer_next_token (context_p);\n          }\n\n          if (context_p->token.type != LEXER_RIGHT_BRACE)\n          {\n            if (context_p->token.type != LEXER_COMMA)\n            {\n              scanner_raise_error (context_p);\n            }\n\n            lexer_next_token (context_p);\n          }\n        }\n\n        lexer_next_token (context_p);\n\n        if (!lexer_token_is_identifier (context_p, \"from\", 4))\n        {\n          return SCAN_KEEP_TOKEN;\n        }\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_LITERAL\n            && context_p->token.lit_location.type == LEXER_STRING_LITERAL)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        return SCAN_NEXT_TOKEN;\n      }\n\n      switch (context_p->token.type)\n      {\n#if ENABLED (JERRY_ES2015)\n        case LEXER_KEYW_CLASS:\n        case LEXER_KEYW_LET:\n        case LEXER_KEYW_CONST:\n#endif /* ENABLED (JERRY_ES2015) */\n        case LEXER_KEYW_VAR:\n        {\n          scanner_context_p->active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_IN_EXPORT;\n          break;\n        }\n      }\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_KEEP_TOKEN;\n    }\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n    default:\n    {\n      break;\n    }\n  }\n\n  scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n  if (type == LEXER_LITERAL\n      && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n  {\n    if (JERRY_UNLIKELY (lexer_check_next_character (context_p, LIT_CHAR_COLON)))\n    {\n      lexer_consume_next_character (context_p);\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_NEXT_TOKEN;\n    }\n\n    JERRY_ASSERT (context_p->token.flags & LEXER_NO_SKIP_SPACES);\n\n#if ENABLED (JERRY_ES2015)\n    /* The colon needs to be checked first because the parser also checks\n     * it first, and this check skips the spaces which affects source_p. */\n    if (JERRY_UNLIKELY (lexer_check_arrow (context_p)))\n    {\n      scanner_scan_simple_arrow (context_p, scanner_context_p, context_p->source_p);\n      return SCAN_KEEP_TOKEN;\n    }\n\n    if (JERRY_UNLIKELY (lexer_token_is_let (context_p)))\n    {\n      lexer_lit_location_t let_literal = context_p->token.lit_location;\n      const uint8_t *source_p = context_p->source_p;\n\n      lexer_next_token (context_p);\n\n      type = (lexer_token_type_t) context_p->token.type;\n\n      if (type == LEXER_LEFT_SQUARE\n          || type == LEXER_LEFT_BRACE\n          || (type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL))\n      {\n        scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n        parser_stack_push_uint8 (context_p, SCAN_STACK_LET);\n        return SCAN_KEEP_TOKEN;\n      }\n\n      scanner_info_t *info_p = scanner_insert_info (context_p, source_p, sizeof (scanner_info_t));\n      info_p->type = SCANNER_TYPE_LET_EXPRESSION;\n\n      lexer_lit_location_t *lit_location_p = scanner_add_custom_literal (context_p,\n                                                                         scanner_context_p->active_literal_pool_p,\n                                                                         &let_literal);\n      lit_location_p->type |= SCANNER_LITERAL_IS_USED;\n\n      if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)\n      {\n        lit_location_p->type |= SCANNER_LITERAL_NO_REG;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      return SCAN_KEEP_TOKEN;\n    }\n\n    if (JERRY_UNLIKELY (lexer_token_is_async (context_p)))\n    {\n      scanner_context_p->async_source_p = context_p->source_p;\n\n      if (scanner_check_async_function (context_p, scanner_context_p))\n      {\n        scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      }\n      return SCAN_KEEP_TOKEN;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    scanner_add_reference (context_p, scanner_context_p);\n\n    scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n    return SCAN_NEXT_TOKEN;\n  }\n\n  return SCAN_KEEP_TOKEN;\n}",
        "begin_line": 1075,
        "end_line": 1897,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner.scanner_scan_statement_end#1904",
        "src_path": "jerry-core/parser/js/js-scanner.c",
        "class_name": "jerry-core.parser.js.js-scanner",
        "signature": "jerry-core.parser.js.js-scanner.scanner_scan_statement_end (parser_context_t *context_p, /**< context */                             scanner_context_t *scanner_context_p, /**< scanner context */                             lexer_token_type_t type) /**< current token type */",
        "snippet": "static scan_return_types_t\nscanner_scan_statement_end (parser_context_t *context_p, /**< context */\n                            scanner_context_t *scanner_context_p, /**< scanner context */\n                            lexer_token_type_t type) /**< current token type */\n{\n  bool terminator_found = false;\n\n  if (type == LEXER_SEMICOLON)\n  {\n    lexer_next_token (context_p);\n    terminator_found = true;\n  }\n\n  while (true)\n  {\n    type = (lexer_token_type_t) context_p->token.type;\n\n    switch (context_p->stack_top_uint8)\n    {\n      case SCAN_STACK_SCRIPT:\n      case SCAN_STACK_SCRIPT_FUNCTION:\n      {\n        if (type == LEXER_EOS)\n        {\n          return SCAN_NEXT_TOKEN;\n        }\n        break;\n      }\n      case SCAN_STACK_BLOCK_STATEMENT:\n#if ENABLED (JERRY_ES2015)\n      case SCAN_STACK_CLASS_STATEMENT:\n#endif /* ENABLED (JERRY_ES2015) */\n      case SCAN_STACK_FUNCTION_STATEMENT:\n      {\n        if (type != LEXER_RIGHT_BRACE)\n        {\n          break;\n        }\n\n#if ENABLED (JERRY_ES2015)\n        if (context_p->stack_top_uint8 != SCAN_STACK_CLASS_STATEMENT)\n        {\n          scanner_pop_literal_pool (context_p, scanner_context_p);\n        }\n#else /* !ENABLED (JERRY_ES2015) */\n        if (context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_STATEMENT)\n        {\n          scanner_pop_literal_pool (context_p, scanner_context_p);\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        terminator_found = true;\n        parser_stack_pop_uint8 (context_p);\n        lexer_next_token (context_p);\n        continue;\n      }\n      case SCAN_STACK_FUNCTION_EXPRESSION:\n#if ENABLED (JERRY_ES2015)\n      case SCAN_STACK_FUNCTION_ARROW:\n#endif /* ENABLED (JERRY_ES2015) */\n      {\n        if (type != LEXER_RIGHT_BRACE)\n        {\n          break;\n        }\n\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n#if ENABLED (JERRY_ES2015)\n        if (context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_ARROW)\n        {\n          scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        scanner_pop_literal_pool (context_p, scanner_context_p);\n        parser_stack_pop_uint8 (context_p);\n        return SCAN_NEXT_TOKEN;\n      }\n      case SCAN_STACK_FUNCTION_PROPERTY:\n      {\n        if (type != LEXER_RIGHT_BRACE)\n        {\n          break;\n        }\n\n        scanner_pop_literal_pool (context_p, scanner_context_p);\n        parser_stack_pop_uint8 (context_p);\n\n#if ENABLED (JERRY_ES2015)\n        if (context_p->stack_top_uint8 == SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR\n            || context_p->stack_top_uint8 == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)\n        {\n          scanner_context_p->mode = SCAN_MODE_CLASS_METHOD;\n          return SCAN_KEEP_TOKEN;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL);\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type == LEXER_RIGHT_BRACE)\n        {\n          scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n          return SCAN_KEEP_TOKEN;\n        }\n\n        if (context_p->token.type != LEXER_COMMA)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;\n        return SCAN_KEEP_TOKEN;\n      }\n      case SCAN_STACK_SWITCH_BLOCK:\n      {\n        if (type != LEXER_RIGHT_BRACE)\n        {\n          break;\n        }\n\n        scanner_switch_statement_t switch_statement;\n\n        parser_stack_pop_uint8 (context_p);\n        parser_stack_pop (context_p, &switch_statement, sizeof (scanner_switch_statement_t));\n\n        scanner_context_p->active_switch_statement = switch_statement;\n\n#if ENABLED (JERRY_ES2015)\n        scanner_pop_literal_pool (context_p, scanner_context_p);\n#endif /* ENABLED (JERRY_ES2015) */\n\n        terminator_found = true;\n        lexer_next_token (context_p);\n        continue;\n      }\n      case SCAN_STACK_IF_STATEMENT:\n      {\n        parser_stack_pop_uint8 (context_p);\n\n        if (type == LEXER_KEYW_ELSE\n            && (terminator_found || (context_p->token.flags & LEXER_WAS_NEWLINE)))\n        {\n#if ENABLED (JERRY_ES2015)\n          scanner_check_function_after_if (context_p, scanner_context_p);\n          return SCAN_KEEP_TOKEN;\n#else /* !ENABLED (JERRY_ES2015) */\n          scanner_context_p->mode = SCAN_MODE_STATEMENT;\n          return SCAN_NEXT_TOKEN;\n#endif /* ENABLED (JERRY_ES2015) */\n        }\n        continue;\n      }\n      case SCAN_STACK_WITH_STATEMENT:\n      {\n        scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;\n\n        JERRY_ASSERT (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH);\n\n        parser_stack_pop_uint8 (context_p);\n\n        if (context_p->stack_top_uint8 == 0)\n        {\n          literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_WITH;\n        }\n\n        parser_stack_pop_uint8 (context_p);\n        continue;\n      }\n      case SCAN_STACK_DO_STATEMENT:\n      {\n        parser_stack_pop_uint8 (context_p);\n\n        if (type != LEXER_KEYW_WHILE\n            || (!terminator_found && !(context_p->token.flags & LEXER_WAS_NEWLINE)))\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_next_token (context_p);\n        if (context_p->token.type != LEXER_LEFT_PAREN)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        parser_stack_push_uint8 (context_p, SCAN_STACK_DO_EXPRESSION);\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_NEXT_TOKEN;\n      }\n      case SCAN_STACK_DO_EXPRESSION:\n      {\n        parser_stack_pop_uint8 (context_p);\n        terminator_found = true;\n        continue;\n      }\n#if ENABLED (JERRY_ES2015)\n      case SCAN_STACK_PRIVATE_BLOCK_EARLY:\n      {\n        parser_list_iterator_t literal_iterator;\n        lexer_lit_location_t *literal_p;\n\n        parser_list_iterator_init (&scanner_context_p->active_literal_pool_p->literal_pool, &literal_iterator);\n\n        while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n        {\n          if ((literal_p->type & (SCANNER_LITERAL_IS_LET | SCANNER_LITERAL_IS_CONST))\n              && literal_p->type & SCANNER_LITERAL_NO_REG)\n          {\n            literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n          }\n        }\n        /* FALLTHRU */\n      }\n      case SCAN_STACK_PRIVATE_BLOCK:\n      {\n        parser_stack_pop_uint8 (context_p);\n        scanner_pop_literal_pool (context_p, scanner_context_p);\n        continue;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      default:\n      {\n        JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_TRY_STATEMENT\n                      || context_p->stack_top_uint8 == SCAN_STACK_CATCH_STATEMENT);\n\n        if (type != LEXER_RIGHT_BRACE)\n        {\n          break;\n        }\n\n        uint8_t stack_top = context_p->stack_top_uint8;\n        parser_stack_pop_uint8 (context_p);\n        lexer_next_token (context_p);\n\n#if ENABLED (JERRY_ES2015)\n        scanner_pop_literal_pool (context_p, scanner_context_p);\n#else /* !ENABLED (JERRY_ES2015) */\n        if (stack_top == SCAN_STACK_CATCH_STATEMENT)\n        {\n          scanner_pop_literal_pool (context_p, scanner_context_p);\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        /* A finally statement is optional after a try or catch statement. */\n        if (context_p->token.type == LEXER_KEYW_FINALLY)\n        {\n          lexer_next_token (context_p);\n\n          if (context_p->token.type != LEXER_LEFT_BRACE)\n          {\n            scanner_raise_error (context_p);\n          }\n\n#if ENABLED (JERRY_ES2015)\n          scanner_literal_pool_t *literal_pool_p;\n          literal_pool_p = scanner_push_literal_pool (context_p,\n                                                      scanner_context_p,\n                                                      SCANNER_LITERAL_POOL_BLOCK);\n          literal_pool_p->source_p = context_p->source_p;\n#endif /* ENABLED (JERRY_ES2015) */\n\n          parser_stack_push_uint8 (context_p, SCAN_STACK_BLOCK_STATEMENT);\n          scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n          return SCAN_NEXT_TOKEN;\n        }\n\n        if (stack_top == SCAN_STACK_CATCH_STATEMENT)\n        {\n          terminator_found = true;\n          continue;\n        }\n\n        /* A catch statement must be present after a try statement unless a finally is provided. */\n        if (context_p->token.type != LEXER_KEYW_CATCH)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_LEFT_PAREN)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        scanner_literal_pool_t *literal_pool_p;\n        literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_BLOCK);\n        literal_pool_p->source_p = context_p->source_p;\n\n        lexer_next_token (context_p);\n        parser_stack_push_uint8 (context_p, SCAN_STACK_CATCH_STATEMENT);\n\n#if ENABLED (JERRY_ES2015)\n        if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)\n        {\n          scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_CATCH, false);\n\n          if (context_p->token.type == LEXER_LEFT_SQUARE)\n          {\n            parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n            scanner_context_p->mode = SCAN_MODE_BINDING;\n            return SCAN_NEXT_TOKEN;\n          }\n\n          parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n          scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;\n          return SCAN_KEEP_TOKEN;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        if (context_p->token.type != LEXER_LITERAL\n            || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_lit_location_t *lit_location_p = scanner_add_literal (context_p, scanner_context_p);\n        lit_location_p->type |= SCANNER_LITERAL_IS_LOCAL;\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_RIGHT_PAREN)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_LEFT_BRACE)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n        return SCAN_NEXT_TOKEN;\n      }\n    }\n\n    if (!terminator_found && !(context_p->token.flags & LEXER_WAS_NEWLINE))\n    {\n      scanner_raise_error (context_p);\n    }\n\n    scanner_context_p->mode = SCAN_MODE_STATEMENT;\n    return SCAN_KEEP_TOKEN;\n  }\n}",
        "begin_line": 1904,
        "end_line": 2251,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.regexp.re-compiler.re_cache_gc#77",
        "src_path": "jerry-core/parser/regexp/re-compiler.c",
        "class_name": "jerry-core.parser.regexp.re-compiler",
        "signature": "jerry-core.parser.regexp.re-compiler.re_cache_gc (void)",
        "snippet": "void\nre_cache_gc (void)\n{\n  re_compiled_code_t **cache_p = JERRY_CONTEXT (re_cache);\n\n  for (uint32_t i = 0u; i < RE_CACHE_SIZE; i++)\n  {\n    const re_compiled_code_t *cached_bytecode_p = cache_p[i];\n\n    if (cached_bytecode_p == NULL)\n    {\n      break;\n    }\n\n    ecma_bytecode_deref ((ecma_compiled_code_t *) cached_bytecode_p);\n    cache_p[i] = NULL;\n  }\n\n  JERRY_CONTEXT (re_cache_idx) = 0;\n}",
        "begin_line": 77,
        "end_line": 96,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.opcodes.opfunc_append_array#494",
        "src_path": "jerry-core/vm/opcodes.c",
        "class_name": "jerry-core.vm.opcodes",
        "signature": "jerry-core.vm.opcodes.opfunc_append_array (ecma_value_t *stack_top_p, /**< current stack top */                      uint16_t values_length) /**< number of elements to set                                               *   with potential OPFUNC_HAS_SPREAD_ELEMENT flag */",
        "snippet": "ecma_value_t JERRY_ATTR_NOINLINE\nopfunc_append_array (ecma_value_t *stack_top_p, /**< current stack top */\n                     uint16_t values_length) /**< number of elements to set\n                                              *   with potential OPFUNC_HAS_SPREAD_ELEMENT flag */\n{\n#if ENABLED (JERRY_ES2015)\n  if (values_length >= OPFUNC_HAS_SPREAD_ELEMENT)\n  {\n    return opfunc_append_to_spread_array (stack_top_p, (uint16_t) (values_length & ~OPFUNC_HAS_SPREAD_ELEMENT));\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  ecma_object_t *array_obj_p = ecma_get_object_from_value (stack_top_p[-1]);\n  JERRY_ASSERT (ecma_get_object_type (array_obj_p) == ECMA_OBJECT_TYPE_ARRAY);\n\n  ecma_extended_object_t *ext_array_obj_p = (ecma_extended_object_t *) array_obj_p;\n  uint32_t old_length = ext_array_obj_p->u.array.length;\n\n  if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_array_obj_p)))\n  {\n    uint32_t filled_holes = 0;\n    ecma_value_t *values_p = ecma_fast_array_extend (array_obj_p, old_length + values_length);\n\n    for (uint32_t i = 0; i < values_length; i++)\n    {\n      values_p[old_length + i] = stack_top_p[i];\n\n      if (!ecma_is_value_array_hole (stack_top_p[i]))\n      {\n        filled_holes++;\n\n        if (ecma_is_value_object (stack_top_p[i]))\n        {\n          ecma_deref_object (ecma_get_object_from_value (stack_top_p[i]));\n        }\n      }\n    }\n\n    ext_array_obj_p->u.array.u.hole_count -= filled_holes * ECMA_FAST_ARRAY_HOLE_ONE;\n\n    if (JERRY_UNLIKELY ((values_length - filled_holes) > ECMA_FAST_ARRAY_MAX_NEW_HOLES_COUNT))\n    {\n      ecma_fast_array_convert_to_normal (array_obj_p);\n    }\n  }\n  else\n  {\n    for (uint32_t i = 0; i < values_length; i++)\n    {\n      if (!ecma_is_value_array_hole (stack_top_p[i]))\n      {\n        ecma_string_t *index_str_p = ecma_new_ecma_string_from_uint32 (old_length + i);\n\n        ecma_property_value_t *prop_value_p;\n\n        prop_value_p = ecma_create_named_data_property (array_obj_p,\n                                                        index_str_p,\n                                                        ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,\n                                                        NULL);\n\n        ecma_deref_ecma_string (index_str_p);\n        prop_value_p->value = stack_top_p[i];\n\n        if (ecma_is_value_object (stack_top_p[i]))\n        {\n          ecma_free_value (stack_top_p[i]);\n        }\n\n      }\n\n      ext_array_obj_p->u.array.length = old_length + values_length;\n    }\n  }\n\n  return ECMA_VALUE_EMPTY;\n}",
        "begin_line": 494,
        "end_line": 569,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.opcodes.vm_set_var#91",
        "src_path": "jerry-core/vm/opcodes.c",
        "class_name": "jerry-core.vm.opcodes",
        "signature": "jerry-core.vm.opcodes.vm_set_var (ecma_object_t *lex_env_p, /**< target lexical environment */             ecma_string_t *var_name_str_p, /**< variable name */             bool is_strict, /**< true, if the engine is in strict mode */             ecma_value_t lit_value) /**< function value */",
        "snippet": "inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE\nvm_set_var (ecma_object_t *lex_env_p, /**< target lexical environment */\n            ecma_string_t *var_name_str_p, /**< variable name */\n            bool is_strict, /**< true, if the engine is in strict mode */\n            ecma_value_t lit_value) /**< function value */\n{\n  ecma_value_t put_value_result;\n  put_value_result = ecma_op_put_value_lex_env_base (lex_env_p, var_name_str_p, is_strict, lit_value);\n\n  JERRY_ASSERT (ecma_is_value_boolean (put_value_result)\n                || ecma_is_value_empty (put_value_result)\n                || ECMA_IS_VALUE_ERROR (put_value_result));\n\n  ecma_free_value (lit_value);\n\n  return put_value_result;\n}",
        "begin_line": 91,
        "end_line": 107,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.opcodes.vm_var_decl#52",
        "src_path": "jerry-core/vm/opcodes.c",
        "class_name": "jerry-core.vm.opcodes",
        "signature": "jerry-core.vm.opcodes.vm_var_decl (ecma_object_t *lex_env_p, /**< target lexical environment */              ecma_string_t *var_name_str_p, /**< variable name */              bool is_configurable_bindings) /**< true if the binding can be deleted */",
        "snippet": "inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE\nvm_var_decl (ecma_object_t *lex_env_p, /**< target lexical environment */\n             ecma_string_t *var_name_str_p, /**< variable name */\n             bool is_configurable_bindings) /**< true if the binding can be deleted */\n{\n  ecma_value_t has_binding = ecma_op_has_binding (lex_env_p, var_name_str_p);\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_IS_VALUE_ERROR (has_binding))\n  {\n    return has_binding;\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  if (ecma_is_value_false (has_binding))\n  {\n    ecma_value_t completion_value = ecma_op_create_mutable_binding (lex_env_p,\n                                                                    var_name_str_p,\n                                                                    is_configurable_bindings);\n\n    JERRY_ASSERT (ecma_is_value_empty (completion_value));\n\n    /* Skipping SetMutableBinding as we have already checked that there were not\n     * any binding with specified name in current lexical environment\n     * and CreateMutableBinding sets the created binding's value to undefined */\n    JERRY_ASSERT (ecma_is_value_undefined (ecma_op_get_binding_value (lex_env_p,\n                                                                      var_name_str_p,\n                                                                      vm_is_strict_mode ())));\n  }\n\n  return ECMA_VALUE_EMPTY;\n}",
        "begin_line": 52,
        "end_line": 83,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm-stack.vm_stack_context_abort#38",
        "src_path": "jerry-core/vm/vm-stack.c",
        "class_name": "jerry-core.vm.vm-stack",
        "signature": "jerry-core.vm.vm-stack.vm_stack_context_abort (vm_frame_ctx_t *frame_ctx_p, /**< frame context */                         ecma_value_t *vm_stack_top_p) /**< current stack top */",
        "snippet": "ecma_value_t *\nvm_stack_context_abort (vm_frame_ctx_t *frame_ctx_p, /**< frame context */\n                        ecma_value_t *vm_stack_top_p) /**< current stack top */\n{\n  ecma_value_t context_info = vm_stack_top_p[-1];\n\n  if (context_info & VM_CONTEXT_HAS_LEX_ENV)\n  {\n    ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;\n    JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);\n    frame_ctx_p->lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);\n    ecma_deref_object (lex_env_p);\n  }\n\n  switch (VM_GET_CONTEXT_TYPE (context_info))\n  {\n    case VM_CONTEXT_FINALLY_THROW:\n    case VM_CONTEXT_FINALLY_RETURN:\n    {\n      ecma_free_value (vm_stack_top_p[-2]);\n      /* FALLTHRU */\n    }\n    case VM_CONTEXT_FINALLY_JUMP:\n    case VM_CONTEXT_TRY:\n    case VM_CONTEXT_CATCH:\n    {\n      VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);\n      vm_stack_top_p -= PARSER_TRY_CONTEXT_STACK_ALLOCATION;\n      break;\n    }\n#if ENABLED (JERRY_ES2015)\n    case VM_CONTEXT_BLOCK:\n#endif /* ENABLED (JERRY_ES2015) */\n    case VM_CONTEXT_WITH:\n    {\n      VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_WITH_CONTEXT_STACK_ALLOCATION);\n      vm_stack_top_p -= PARSER_WITH_CONTEXT_STACK_ALLOCATION;\n      break;\n    }\n#if ENABLED (JERRY_ES2015)\n    case VM_CONTEXT_FOR_OF:\n    {\n      ecma_value_t iterator = vm_stack_top_p[-3];\n\n      if (context_info & VM_CONTEXT_CLOSE_ITERATOR)\n      {\n        ecma_op_iterator_close (iterator);\n      }\n      ecma_free_value (iterator);\n\n      ecma_free_value (vm_stack_top_p[-2]);\n      VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);\n      vm_stack_top_p -= PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION;\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    default:\n    {\n      JERRY_ASSERT (VM_GET_CONTEXT_TYPE (vm_stack_top_p[-1]) == VM_CONTEXT_FOR_IN);\n\n      ecma_collection_t *collection_p;\n      collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, vm_stack_top_p[-2]);\n\n      ecma_value_t *buffer_p = collection_p->buffer_p;\n\n      for (uint32_t index = vm_stack_top_p[-3]; index < collection_p->item_count; index++)\n      {\n        ecma_free_value (buffer_p[index]);\n      }\n\n      ecma_collection_destroy (collection_p);\n\n      ecma_free_value (vm_stack_top_p[-4]);\n\n      VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION);\n      vm_stack_top_p -= PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;\n      break;\n    }\n  }\n\n  return vm_stack_top_p;\n}",
        "begin_line": 38,
        "end_line": 119,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm-utils.vm_is_direct_eval_form_call#48",
        "src_path": "jerry-core/vm/vm-utils.c",
        "class_name": "jerry-core.vm.vm-utils",
        "signature": "jerry-core.vm.vm-utils.vm_is_direct_eval_form_call (void)",
        "snippet": "inline bool JERRY_ATTR_ALWAYS_INLINE\nvm_is_direct_eval_form_call (void)\n{\n  return (JERRY_CONTEXT (status_flags) & ECMA_STATUS_DIRECT_EVAL) != 0;\n}",
        "begin_line": 48,
        "end_line": 52,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm-utils.vm_is_strict_mode#28",
        "src_path": "jerry-core/vm/vm-utils.c",
        "class_name": "jerry-core.vm.vm-utils",
        "signature": "jerry-core.vm.vm-utils.vm_is_strict_mode (void)",
        "snippet": "bool\nvm_is_strict_mode (void)\n{\n  JERRY_ASSERT (JERRY_CONTEXT (vm_top_context_p) != NULL);\n\n  return JERRY_CONTEXT (vm_top_context_p)->bytecode_header_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE;\n}",
        "begin_line": 28,
        "end_line": 34,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.opfunc_call#732",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.opfunc_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */",
        "snippet": "static void\nopfunc_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */\n{\n  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;\n  uint8_t opcode = byte_code_p[-1];\n  uint32_t arguments_list_len;\n\n  if (opcode >= CBC_CALL0)\n  {\n    arguments_list_len = (unsigned int) ((opcode - CBC_CALL0) / 6);\n  }\n  else\n  {\n    arguments_list_len = *byte_code_p++;\n  }\n\n  bool is_call_prop = ((opcode - CBC_CALL) % 6) >= 3;\n\n  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;\n  ecma_value_t this_value = is_call_prop ? stack_top_p[-3] : ECMA_VALUE_UNDEFINED;\n  ecma_value_t func_value = stack_top_p[-1];\n  ecma_value_t completion_value;\n\n  if (!ecma_is_value_object (func_value)\n      || !ecma_op_object_is_callable (ecma_get_object_from_value (func_value)))\n  {\n    completion_value = ecma_raise_type_error (ECMA_ERR_MSG (\"Expected a function.\"));\n  }\n  else\n  {\n    ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);\n\n    completion_value = ecma_op_function_call (func_obj_p,\n                                              this_value,\n                                              stack_top_p,\n                                              arguments_list_len);\n  }\n\n  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_DIRECT_EVAL;\n\n  /* Free registers. */\n  for (uint32_t i = 0; i < arguments_list_len; i++)\n  {\n    ecma_fast_free_value (stack_top_p[i]);\n  }\n\n  if (is_call_prop)\n  {\n    ecma_free_value (*(--stack_top_p));\n    ecma_free_value (*(--stack_top_p));\n  }\n\n  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))\n  {\n#if ENABLED (JERRY_DEBUGGER)\n    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;\n#endif /* ENABLED (JERRY_DEBUGGER) */\n    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;\n  }\n  else\n  {\n    frame_ctx_p->byte_code_p = byte_code_p;\n    ecma_free_value (*(--stack_top_p));\n    uint32_t opcode_data = vm_decode_table[opcode];\n\n    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))\n    {\n      ecma_fast_free_value (completion_value);\n    }\n    else if (opcode_data & VM_OC_PUT_STACK)\n    {\n      *stack_top_p++ = completion_value;\n    }\n    else\n    {\n      ecma_fast_free_value (frame_ctx_p->block_result);\n      frame_ctx_p->block_result = completion_value;\n    }\n  }\n\n  frame_ctx_p->stack_top_p = stack_top_p;\n}",
        "begin_line": 732,
        "end_line": 813,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.opfunc_construct#820",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.opfunc_construct (vm_frame_ctx_t *frame_ctx_p) /**< frame context */",
        "snippet": "static void\nopfunc_construct (vm_frame_ctx_t *frame_ctx_p) /**< frame context */\n{\n  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;\n  uint8_t opcode = byte_code_p[-1];\n  unsigned int arguments_list_len;\n\n  if (opcode >= CBC_NEW0)\n  {\n    arguments_list_len = (unsigned int) (opcode - CBC_NEW0);\n  }\n  else\n  {\n    arguments_list_len = *byte_code_p++;\n  }\n\n  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;\n  ecma_value_t constructor_value = stack_top_p[-1];\n  ecma_value_t completion_value;\n\n  if (!ecma_is_value_object (constructor_value)\n      || !ecma_object_is_constructor (ecma_get_object_from_value (constructor_value)))\n  {\n    completion_value = ecma_raise_type_error (ECMA_ERR_MSG (\"Expected a constructor.\"));\n  }\n  else\n  {\n    ecma_object_t *constructor_obj_p = ecma_get_object_from_value (constructor_value);\n\n    completion_value = ecma_op_function_construct (constructor_obj_p,\n                                                   constructor_obj_p,\n                                                   stack_top_p,\n                                                   arguments_list_len);\n  }\n\n  /* Free registers. */\n  for (uint32_t i = 0; i < arguments_list_len; i++)\n  {\n    ecma_fast_free_value (stack_top_p[i]);\n  }\n\n  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))\n  {\n#if ENABLED (JERRY_DEBUGGER)\n    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;\n#endif /* ENABLED (JERRY_DEBUGGER) */\n    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;\n  }\n  else\n  {\n    ecma_free_value (stack_top_p[-1]);\n    frame_ctx_p->byte_code_p = byte_code_p;\n    stack_top_p[-1] = completion_value;\n  }\n\n  frame_ctx_p->stack_top_p = stack_top_p;\n}",
        "begin_line": 820,
        "end_line": 876,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_construct_literal_object#420",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_construct_literal_object (vm_frame_ctx_t *frame_ctx_p, /**< frame context */                              ecma_value_t lit_value) /**< literal */",
        "snippet": "static ecma_value_t\nvm_construct_literal_object (vm_frame_ctx_t *frame_ctx_p, /**< frame context */\n                             ecma_value_t lit_value) /**< literal */\n{\n  ecma_compiled_code_t *bytecode_p;\n\n#if ENABLED (JERRY_SNAPSHOT_EXEC)\n  if (JERRY_LIKELY (!(frame_ctx_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))\n  {\n#endif /* ENABLED (JERRY_SNAPSHOT_EXEC) */\n    bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,\n                                                  lit_value);\n#if ENABLED (JERRY_SNAPSHOT_EXEC)\n  }\n  else\n  {\n    uint8_t *byte_p = ((uint8_t *) frame_ctx_p->bytecode_header_p) + lit_value;\n    bytecode_p = (ecma_compiled_code_t *) byte_p;\n  }\n#endif /* ENABLED (JERRY_SNAPSHOT_EXEC) */\n\n#if ENABLED (JERRY_BUILTIN_REGEXP)\n  if (!(bytecode_p->status_flags & CBC_CODE_FLAGS_FUNCTION))\n  {\n    ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);\n\n    if (JERRY_UNLIKELY (regexp_obj_p == NULL))\n    {\n      return ECMA_VALUE_ERROR;\n    }\n\n    return ecma_op_create_regexp_from_bytecode (regexp_obj_p, (re_compiled_code_t *) bytecode_p);;\n  }\n#endif /* ENABLED (JERRY_BUILTIN_REGEXP) */\n\n  JERRY_ASSERT (bytecode_p->status_flags & CBC_CODE_FLAGS_FUNCTION);\n\n  ecma_object_t *func_obj_p;\n\n#if ENABLED (JERRY_ES2015)\n  if (bytecode_p->status_flags & CBC_CODE_FLAGS_ARROW_FUNCTION)\n  {\n    func_obj_p = ecma_op_create_arrow_function_object (frame_ctx_p->lex_env_p,\n                                                       bytecode_p,\n                                                       frame_ctx_p->this_binding);\n  }\n  else if (bytecode_p->status_flags & CBC_CODE_FLAGS_GENERATOR)\n  {\n    func_obj_p = ecma_op_create_generator_function_object (frame_ctx_p->lex_env_p, bytecode_p);\n  }\n  else\n  {\n#endif /* ENABLED (JERRY_ES2015) */\n    func_obj_p = ecma_op_create_simple_function_object (frame_ctx_p->lex_env_p, bytecode_p);\n#if ENABLED (JERRY_ES2015)\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  return ecma_make_object_value (func_obj_p);\n}",
        "begin_line": 420,
        "end_line": 479,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_execute#4119",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_execute (vm_frame_ctx_t *frame_ctx_p) /**< frame context */",
        "snippet": "ecma_value_t JERRY_ATTR_NOINLINE\nvm_execute (vm_frame_ctx_t *frame_ctx_p) /**< frame context */\n{\n  while (true)\n  {\n    ecma_value_t completion_value = vm_loop (frame_ctx_p);\n\n    switch (frame_ctx_p->call_operation)\n    {\n      case VM_EXEC_CALL:\n      {\n        opfunc_call (frame_ctx_p);\n        break;\n      }\n#if ENABLED (JERRY_ES2015)\n      case VM_EXEC_SUPER_CALL:\n      {\n        vm_super_call (frame_ctx_p);\n        break;\n      }\n      case VM_EXEC_SPREAD_OP:\n      {\n        vm_spread_operation (frame_ctx_p);\n        break;\n      }\n      case VM_EXEC_RETURN:\n      {\n        return completion_value;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      case VM_EXEC_CONSTRUCT:\n      {\n        opfunc_construct (frame_ctx_p);\n        break;\n      }\n      default:\n      {\n        JERRY_ASSERT (frame_ctx_p->call_operation == VM_NO_EXEC_OP);\n\n        const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->bytecode_header_p;\n        uint32_t register_end;\n\n        if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n        {\n          register_end = ((cbc_uint16_arguments_t *) bytecode_header_p)->register_end;\n        }\n        else\n        {\n          register_end = ((cbc_uint8_arguments_t *) bytecode_header_p)->register_end;\n        }\n\n        /* Free arguments and registers */\n        ecma_value_t *registers_p = VM_GET_REGISTERS (frame_ctx_p);\n        for (uint32_t i = 0; i < register_end; i++)\n        {\n          ecma_fast_free_value (registers_p[i]);\n        }\n\n#if ENABLED (JERRY_DEBUGGER)\n        if (JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p))\n        {\n          /* The engine will stop when the next breakpoint is reached. */\n          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP);\n          JERRY_CONTEXT (debugger_stop_context) = NULL;\n        }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n        JERRY_CONTEXT (vm_top_context_p) = frame_ctx_p->prev_context_p;\n        return completion_value;\n      }\n    }\n  }\n}",
        "begin_line": 4119,
        "end_line": 4191,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_init_exec#4023",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_init_exec (vm_frame_ctx_t *frame_ctx_p, /**< frame context */               const ecma_value_t *arg_p, /**< arguments list */               ecma_length_t arg_list_len) /**< length of arguments list */",
        "snippet": "static void JERRY_ATTR_NOINLINE\nvm_init_exec (vm_frame_ctx_t *frame_ctx_p, /**< frame context */\n              const ecma_value_t *arg_p, /**< arguments list */\n              ecma_length_t arg_list_len) /**< length of arguments list */\n{\n  frame_ctx_p->prev_context_p = JERRY_CONTEXT (vm_top_context_p);\n  frame_ctx_p->block_result = ECMA_VALUE_UNDEFINED;\n#if ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n  frame_ctx_p->resource_name = ECMA_VALUE_UNDEFINED;\n#endif /* ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n#if ENABLED (JERRY_LINE_INFO)\n  frame_ctx_p->current_line = 0;\n#endif /* ENABLED (JERRY_LINE_INFO) */\n  frame_ctx_p->context_depth = 0;\n  frame_ctx_p->is_eval_code = (arg_p == VM_DIRECT_EVAL);\n\n  const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->bytecode_header_p;\n  uint16_t argument_end, register_end;\n  ecma_value_t *literal_p;\n\n  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n  {\n    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;\n\n    argument_end = args_p->argument_end;\n    register_end = args_p->register_end;\n\n    literal_p = (ecma_value_t *) ((uint8_t *) bytecode_header_p + sizeof (cbc_uint16_arguments_t));\n    literal_p -= register_end;\n    frame_ctx_p->literal_start_p = literal_p;\n    literal_p += args_p->literal_end;\n  }\n  else\n  {\n    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;\n\n    argument_end = args_p->argument_end;\n    register_end = args_p->register_end;\n\n    literal_p = (ecma_value_t *) ((uint8_t *) bytecode_header_p + sizeof (cbc_uint8_arguments_t));\n    literal_p -= register_end;\n    frame_ctx_p->literal_start_p = literal_p;\n    literal_p += args_p->literal_end;\n  }\n\n  frame_ctx_p->byte_code_p = (uint8_t *) literal_p;\n  frame_ctx_p->byte_code_start_p = (uint8_t *) literal_p;\n  frame_ctx_p->stack_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end;\n\n#if ENABLED (JERRY_ES2015)\n  uint32_t function_call_argument_count = arg_list_len;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  if (arg_list_len > argument_end)\n  {\n    arg_list_len = argument_end;\n  }\n\n  for (uint32_t i = 0; i < arg_list_len; i++)\n  {\n    VM_GET_REGISTER (frame_ctx_p, i) = ecma_fast_copy_value (arg_p[i]);\n  }\n\n  /* The arg_list_len contains the end of the copied arguments.\n   * Fill everything else with undefined. */\n  if (register_end > arg_list_len)\n  {\n    ecma_value_t *stack_p = VM_GET_REGISTERS (frame_ctx_p) + arg_list_len;\n\n    for (uint32_t i = arg_list_len; i < register_end; i++)\n    {\n      *stack_p++ = ECMA_VALUE_UNDEFINED;\n    }\n  }\n\n#if ENABLED (JERRY_ES2015)\n  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_REST_PARAMETER)\n  {\n    JERRY_ASSERT (function_call_argument_count >= arg_list_len);\n    ecma_value_t new_array = ecma_op_create_array_object (arg_p + arg_list_len,\n                                                          function_call_argument_count - arg_list_len,\n                                                          false);\n    JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (new_array));\n    VM_GET_REGISTER (frame_ctx_p, argument_end) = new_array;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_DIRECT_EVAL;\n  JERRY_CONTEXT (vm_top_context_p) = frame_ctx_p;\n}",
        "begin_line": 4023,
        "end_line": 4112,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_loop#946",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_loop (vm_frame_ctx_t *frame_ctx_p) /**< frame context */",
        "snippet": "static ecma_value_t JERRY_ATTR_NOINLINE\nvm_loop (vm_frame_ctx_t *frame_ctx_p) /**< frame context */\n{\n  const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->bytecode_header_p;\n  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p;\n  ecma_value_t *literal_start_p = frame_ctx_p->literal_start_p;\n\n  ecma_value_t *stack_top_p;\n  uint16_t encoding_limit;\n  uint16_t encoding_delta;\n  uint16_t register_end;\n  uint16_t ident_end;\n  uint16_t const_literal_end;\n  int32_t branch_offset = 0;\n  uint8_t branch_offset_length = 0;\n  ecma_value_t left_value;\n  ecma_value_t right_value;\n  ecma_value_t result = ECMA_VALUE_EMPTY;\n  bool is_strict = ((frame_ctx_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE) != 0);\n\n  /* Prepare for byte code execution. */\n  if (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_FULL_LITERAL_ENCODING))\n  {\n    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;\n    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;\n  }\n  else\n  {\n    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;\n    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;\n  }\n\n  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n  {\n    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) (bytecode_header_p);\n    register_end = args_p->register_end;\n    ident_end = args_p->ident_end;\n    const_literal_end = args_p->const_literal_end;\n  }\n  else\n  {\n    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) (bytecode_header_p);\n    register_end = args_p->register_end;\n    ident_end = args_p->ident_end;\n    const_literal_end = args_p->const_literal_end;\n  }\n\n  stack_top_p = frame_ctx_p->stack_top_p;\n\n  /* Outer loop for exception handling. */\n  while (true)\n  {\n    /* Internal loop for byte code execution. */\n    while (true)\n    {\n      const uint8_t *byte_code_start_p = byte_code_p;\n      uint8_t opcode = *byte_code_p++;\n      uint32_t opcode_data = opcode;\n\n      if (opcode == CBC_EXT_OPCODE)\n      {\n        opcode = *byte_code_p++;\n        opcode_data = (uint32_t) ((CBC_END + 1) + opcode);\n      }\n\n      opcode_data = vm_decode_table[opcode_data];\n\n      left_value = ECMA_VALUE_UNDEFINED;\n      right_value = ECMA_VALUE_UNDEFINED;\n\n      uint32_t operands = VM_OC_GET_ARGS_INDEX (opcode_data);\n\n      if (operands >= VM_OC_GET_LITERAL)\n      {\n        uint16_t literal_index;\n        READ_LITERAL_INDEX (literal_index);\n        READ_LITERAL (literal_index, left_value);\n\n        if (operands != VM_OC_GET_LITERAL)\n        {\n          switch (operands)\n          {\n            case VM_OC_GET_LITERAL_LITERAL:\n            {\n              uint16_t second_literal_index;\n              READ_LITERAL_INDEX (second_literal_index);\n              READ_LITERAL (second_literal_index, right_value);\n              break;\n            }\n            case VM_OC_GET_STACK_LITERAL:\n            {\n              JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);\n              right_value = left_value;\n              left_value = *(--stack_top_p);\n              break;\n            }\n            default:\n            {\n              JERRY_ASSERT (operands == VM_OC_GET_THIS_LITERAL);\n\n              right_value = left_value;\n              left_value = ecma_copy_value (frame_ctx_p->this_binding);\n              break;\n            }\n          }\n        }\n      }\n      else if (operands >= VM_OC_GET_STACK)\n      {\n        JERRY_ASSERT (operands == VM_OC_GET_STACK\n                      || operands == VM_OC_GET_STACK_STACK);\n\n        JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);\n        left_value = *(--stack_top_p);\n\n        if (operands == VM_OC_GET_STACK_STACK)\n        {\n          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);\n          right_value = left_value;\n          left_value = *(--stack_top_p);\n        }\n      }\n      else if (operands == VM_OC_GET_BRANCH)\n      {\n        branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (opcode);\n        JERRY_ASSERT (branch_offset_length >= 1 && branch_offset_length <= 3);\n\n        branch_offset = *(byte_code_p++);\n\n        if (JERRY_UNLIKELY (branch_offset_length != 1))\n        {\n          branch_offset <<= 8;\n          branch_offset |= *(byte_code_p++);\n\n          if (JERRY_UNLIKELY (branch_offset_length == 3))\n          {\n            branch_offset <<= 8;\n            branch_offset |= *(byte_code_p++);\n          }\n        }\n\n        if (opcode_data & VM_OC_BACKWARD_BRANCH)\n        {\n#if ENABLED (JERRY_VM_EXEC_STOP)\n          if (JERRY_CONTEXT (vm_exec_stop_cb) != NULL\n              && --JERRY_CONTEXT (vm_exec_stop_counter) == 0)\n          {\n            result = JERRY_CONTEXT (vm_exec_stop_cb) (JERRY_CONTEXT (vm_exec_stop_user_p));\n\n            if (ecma_is_value_undefined (result))\n            {\n              JERRY_CONTEXT (vm_exec_stop_counter) = JERRY_CONTEXT (vm_exec_stop_frequency);\n            }\n            else\n            {\n              JERRY_CONTEXT (vm_exec_stop_counter) = 1;\n\n              if (ecma_is_value_error_reference (result))\n              {\n                ecma_raise_error_from_error_reference (result);\n              }\n              else\n              {\n                jcontext_raise_exception (result);\n              }\n\n              JERRY_ASSERT (jcontext_has_pending_exception ());\n              jcontext_set_abort_flag (true);\n              result = ECMA_VALUE_ERROR;\n              goto error;\n            }\n          }\n#endif /* ENABLED (JERRY_VM_EXEC_STOP) */\n\n          branch_offset = -branch_offset;\n        }\n      }\n\n      switch (VM_OC_GROUP_GET_INDEX (opcode_data))\n      {\n        case VM_OC_POP:\n        {\n          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);\n          ecma_free_value (*(--stack_top_p));\n          continue;\n        }\n        case VM_OC_POP_BLOCK:\n        {\n          ecma_fast_free_value (frame_ctx_p->block_result);\n          frame_ctx_p->block_result = *(--stack_top_p);\n          continue;\n        }\n        case VM_OC_PUSH:\n        {\n          *stack_top_p++ = left_value;\n          continue;\n        }\n        case VM_OC_PUSH_TWO:\n        {\n          *stack_top_p++ = left_value;\n          *stack_top_p++ = right_value;\n          continue;\n        }\n        case VM_OC_PUSH_THREE:\n        {\n          uint16_t literal_index;\n\n          *stack_top_p++ = left_value;\n          left_value = ECMA_VALUE_UNDEFINED;\n\n          READ_LITERAL_INDEX (literal_index);\n          READ_LITERAL (literal_index, left_value);\n\n          *stack_top_p++ = right_value;\n          *stack_top_p++ = left_value;\n          continue;\n        }\n        case VM_OC_PUSH_UNDEFINED:\n        {\n          *stack_top_p++ = ECMA_VALUE_UNDEFINED;\n          continue;\n        }\n        case VM_OC_PUSH_TRUE:\n        {\n          *stack_top_p++ = ECMA_VALUE_TRUE;\n          continue;\n        }\n        case VM_OC_PUSH_FALSE:\n        {\n          *stack_top_p++ = ECMA_VALUE_FALSE;\n          continue;\n        }\n        case VM_OC_PUSH_NULL:\n        {\n          *stack_top_p++ = ECMA_VALUE_NULL;\n          continue;\n        }\n        case VM_OC_PUSH_THIS:\n        {\n          *stack_top_p++ = ecma_copy_value (frame_ctx_p->this_binding);\n          continue;\n        }\n        case VM_OC_PUSH_0:\n        {\n          *stack_top_p++ = ecma_make_integer_value (0);\n          continue;\n        }\n        case VM_OC_PUSH_POS_BYTE:\n        {\n          ecma_integer_value_t number = *byte_code_p++;\n          *stack_top_p++ = ecma_make_integer_value (number + 1);\n          continue;\n        }\n        case VM_OC_PUSH_NEG_BYTE:\n        {\n          ecma_integer_value_t number = *byte_code_p++;\n          *stack_top_p++ = ecma_make_integer_value (-(number + 1));\n          continue;\n        }\n        case VM_OC_PUSH_LIT_0:\n        {\n          stack_top_p[0] = left_value;\n          stack_top_p[1] = ecma_make_integer_value (0);\n          stack_top_p += 2;\n          continue;\n        }\n        case VM_OC_PUSH_LIT_POS_BYTE:\n        {\n          ecma_integer_value_t number = *byte_code_p++;\n          stack_top_p[0] = left_value;\n          stack_top_p[1] = ecma_make_integer_value (number + 1);\n          stack_top_p += 2;\n          continue;\n        }\n        case VM_OC_PUSH_LIT_NEG_BYTE:\n        {\n          ecma_integer_value_t number = *byte_code_p++;\n          stack_top_p[0] = left_value;\n          stack_top_p[1] = ecma_make_integer_value (-(number + 1));\n          stack_top_p += 2;\n          continue;\n        }\n        case VM_OC_PUSH_OBJECT:\n        {\n          ecma_object_t *obj_p = ecma_create_object (ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE),\n                                                     0,\n                                                     ECMA_OBJECT_TYPE_GENERAL);\n\n          *stack_top_p++ = ecma_make_object_value (obj_p);\n          continue;\n        }\n        case VM_OC_PUSH_NAMED_FUNC_EXPR:\n        {\n          ecma_object_t *func_p = ecma_get_object_from_value (left_value);\n\n          JERRY_ASSERT (ecma_get_object_type (func_p) == ECMA_OBJECT_TYPE_FUNCTION);\n\n          ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_p;\n\n          JERRY_ASSERT (frame_ctx_p->lex_env_p ==\n                        ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t, ext_func_p->u.function.scope_cp));\n\n          ecma_object_t *name_lex_env = ecma_create_decl_lex_env (frame_ctx_p->lex_env_p);\n\n          ecma_op_create_immutable_binding (name_lex_env, ecma_get_string_from_value (right_value), left_value);\n\n          ECMA_SET_NON_NULL_POINTER_TAG (ext_func_p->u.function.scope_cp, name_lex_env, 0);\n\n          ecma_free_value (right_value);\n          ecma_deref_object (name_lex_env);\n          *stack_top_p++ = left_value;\n          continue;\n        }\n        case VM_OC_CREATE_BINDING:\n        {\n#if !ENABLED (JERRY_ES2015)\n          JERRY_ASSERT (opcode == CBC_CREATE_VAR);\n#endif /* !ENABLED (JERRY_ES2015) */\n\n          uint32_t literal_index;\n\n          READ_LITERAL_INDEX (literal_index);\n\n          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n\n          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);\n          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);\n\n          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;\n\n#if ENABLED (JERRY_ES2015)\n          if (opcode == CBC_CREATE_LET)\n          {\n            prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;\n          }\n          else if (opcode == CBC_CREATE_CONST)\n          {\n            prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;\n          }\n\n          ecma_property_value_t *property_value_p;\n          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);\n\n          if (opcode != CBC_CREATE_VAR)\n          {\n            property_value_p->value = ECMA_VALUE_UNINITIALIZED;\n          }\n#else /* !ENABLED (JERRY_ES2015) */\n          ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);\n#endif /* ENABLED (JERRY_ES2015) */\n\n          continue;\n        }\n        case VM_OC_VAR_EVAL:\n        {\n          uint32_t literal_index;\n          ecma_value_t lit_value = ECMA_VALUE_UNDEFINED;\n\n          if (opcode == CBC_CREATE_VAR_FUNC_EVAL)\n          {\n            uint32_t value_index;\n            READ_LITERAL_INDEX (value_index);\n\n            lit_value = vm_construct_literal_object (frame_ctx_p,\n                                                     literal_start_p[value_index]);\n          }\n\n          READ_LITERAL_INDEX (literal_index);\n\n          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;\n\n          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)\n          {\n  #if ENABLED (JERRY_ES2015) && !(defined JERRY_NDEBUG)\n            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n            {\n              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));\n            }\n  #endif /* ENABLED (JERRY_ES2015) && !JERRY_NDEBUG */\n\n            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);\n            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);\n          }\n\n  #if ENABLED (JERRY_ES2015) && !(defined JERRY_NDEBUG)\n          if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n          {\n            ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n            JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));\n          }\n  #endif /* ENABLED (JERRY_ES2015) && !JERRY_NDEBUG */\n\n          result = vm_var_decl (lex_env_p, name_p, frame_ctx_p->is_eval_code);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          if (lit_value != ECMA_VALUE_UNDEFINED)\n          {\n            result = vm_set_var (lex_env_p, name_p, is_strict, lit_value);\n\n            if (ECMA_IS_VALUE_ERROR (result))\n            {\n              goto error;\n            }\n          }\n\n          continue;\n        }\n#if ENABLED (JERRY_SNAPSHOT_EXEC)\n        case VM_OC_SET_BYTECODE_PTR:\n        {\n          memcpy (&byte_code_p, byte_code_p++, sizeof (uint8_t *));\n          frame_ctx_p->byte_code_start_p = byte_code_p;\n          continue;\n        }\n#endif /* ENABLED (JERRY_SNAPSHOT_EXEC) */\n        case VM_OC_INIT_ARG_OR_FUNC:\n        {\n          uint32_t literal_index, value_index;\n          ecma_value_t lit_value;\n\n          READ_LITERAL_INDEX (value_index);\n          READ_LITERAL_INDEX (literal_index);\n\n          JERRY_ASSERT (value_index != literal_index);\n          JERRY_ASSERT (value_index >= register_end || literal_index >= register_end);\n\n          if (value_index < register_end)\n          {\n            /* Take (not copy) the reference. */\n            lit_value = ecma_copy_value_if_not_object (VM_GET_REGISTER (frame_ctx_p, value_index));\n          }\n          else\n          {\n            lit_value = vm_construct_literal_object (frame_ctx_p,\n                                                     literal_start_p[value_index]);\n          }\n\n          if (literal_index < register_end)\n          {\n            ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));\n            VM_GET_REGISTER (frame_ctx_p, literal_index) = lit_value;\n            continue;\n          }\n\n          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n\n          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);\n          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);\n\n          ecma_property_value_t *property_value_p;\n          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p,\n                                                              name_p,\n                                                              ECMA_PROPERTY_FLAG_WRITABLE,\n                                                              NULL);\n\n          JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);\n          property_value_p->value = lit_value;\n\n          if (value_index >= register_end)\n          {\n            ecma_free_value (lit_value);\n          }\n\n          continue;\n        }\n#if ENABLED (JERRY_ES2015)\n        case VM_OC_CHECK_VAR:\n        {\n          JERRY_ASSERT (ecma_get_global_scope () == frame_ctx_p->lex_env_p);\n\n          uint32_t literal_index;\n          READ_LITERAL_INDEX (literal_index);\n\n          if ((frame_ctx_p->lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK) == 0)\n          {\n            continue;\n          }\n\n          ecma_string_t *const literal_name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n          ecma_property_t *const binding_p = ecma_find_named_property (frame_ctx_p->lex_env_p, literal_name_p);\n\n          if (binding_p != NULL)\n          {\n            result = ecma_raise_syntax_error (ECMA_ERR_MSG (\"Local variable is redeclared.\"));\n            goto error;\n          }\n\n          continue;\n        }\n        case VM_OC_CHECK_LET:\n        {\n          JERRY_ASSERT (ecma_get_global_scope () == frame_ctx_p->lex_env_p);\n\n          uint32_t literal_index;\n          READ_LITERAL_INDEX (literal_index);\n\n          ecma_string_t *literal_name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;\n          ecma_property_t *binding_p = NULL;\n\n          if (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)\n          {\n            binding_p = ecma_find_named_property (lex_env_p, literal_name_p);\n\n            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);\n            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);\n          }\n\n          if (binding_p != NULL)\n          {\n            result = ecma_raise_syntax_error (ECMA_ERR_MSG (\"Local variable is redeclared.\"));\n            goto error;\n          }\n\n          result = ecma_op_has_binding (lex_env_p, literal_name_p);\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n          if (ecma_is_value_true (result))\n          {\n            result = ecma_raise_syntax_error (ECMA_ERR_MSG (\"Local variable is redeclared.\"));\n            goto error;\n          }\n\n          continue;\n        }\n        case VM_OC_ASSIGN_LET_CONST:\n        {\n          uint32_t literal_index;\n          READ_LITERAL_INDEX (literal_index);\n\n          JERRY_ASSERT (literal_index >= register_end);\n          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);\n\n          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n          ecma_property_t *property_p = ecma_find_named_property (frame_ctx_p->lex_env_p, name_p);\n\n          JERRY_ASSERT (property_p != NULL\n                        && ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA);\n          JERRY_ASSERT (ECMA_PROPERTY_VALUE_PTR (property_p)->value == ECMA_VALUE_UNINITIALIZED);\n\n          ECMA_PROPERTY_VALUE_PTR (property_p)->value = left_value;\n\n          if (ecma_is_value_object (left_value))\n          {\n            ecma_deref_object (ecma_get_object_from_value (left_value));\n          }\n          continue;\n        }\n        case VM_OC_INIT_BINDING:\n        {\n          uint32_t literal_index;\n\n          READ_LITERAL_INDEX (literal_index);\n\n          JERRY_ASSERT (literal_index >= register_end);\n\n          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n\n          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);\n          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);\n\n          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;\n\n          if (opcode == CBC_INIT_LET)\n          {\n            prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;\n          }\n          else if (opcode == CBC_INIT_CONST)\n          {\n            prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;\n          }\n\n          ecma_property_value_t *property_value_p;\n          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p,\n                                                              name_p,\n                                                              prop_attributes,\n                                                              NULL);\n\n          JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);\n\n          ecma_value_t value = *(--stack_top_p);\n\n          property_value_p->value = value;\n          ecma_deref_if_object (value);\n          continue;\n        }\n        case VM_OC_THROW_CONST_ERROR:\n        {\n          result = ecma_raise_type_error (ECMA_ERR_MSG (\"Constant bindings cannot be reassigned.\"));\n          goto error;\n        }\n        case VM_OC_COPY_TO_GLOBAL:\n        {\n          uint32_t literal_index;\n          READ_LITERAL_INDEX (literal_index);\n\n          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;\n\n          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)\n          {\n#ifndef JERRY_NDEBUG\n            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n            {\n              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));\n            }\n#endif /* !JERRY_NDEBUG */\n\n            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);\n            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);\n          }\n\n          if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n          {\n            ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n            ecma_property_value_t *prop_value_p;\n\n            if (property_p == NULL)\n            {\n              prop_value_p = ecma_create_named_data_property (lex_env_p,\n                                                              name_p,\n                                                              ECMA_PROPERTY_FLAG_WRITABLE,\n                                                              NULL);\n            }\n            else\n            {\n#ifndef JERRY_NDEBUG\n              JERRY_ASSERT (!(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));\n#endif /* !JERRY_NDEBUG */\n              prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n            }\n\n            ecma_named_data_property_assign_value (lex_env_p, prop_value_p, left_value);\n          }\n          else\n          {\n            result = ecma_op_set_mutable_binding (lex_env_p, name_p, left_value, is_strict);\n\n            if (ECMA_IS_VALUE_ERROR (result))\n            {\n              goto error;\n            }\n          }\n\n          goto free_left_value;\n        }\n        case VM_OC_CLONE_CONTEXT:\n        {\n          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE);\n\n          bool copy_values = (byte_code_start_p[1] == CBC_EXT_CLONE_FULL_CONTEXT);\n          frame_ctx_p->lex_env_p = ecma_clone_decl_lexical_environment (frame_ctx_p->lex_env_p, copy_values);\n          continue;\n        }\n        case VM_OC_SET__PROTO__:\n        {\n          result = ecma_builtin_object_object_set_proto (stack_top_p[-1], left_value);\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n          goto free_left_value;\n        }\n        case VM_OC_SET_COMPUTED_PROPERTY:\n        {\n          /* Swap values. */\n          left_value ^= right_value;\n          right_value ^= left_value;\n          left_value ^= right_value;\n          /* FALLTHRU */\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n        case VM_OC_SET_PROPERTY:\n        {\n          JERRY_STATIC_ASSERT (VM_OC_NON_STATIC_FLAG == VM_OC_BACKWARD_BRANCH,\n                               vm_oc_non_static_flag_must_be_equal_to_vm_oc_backward_branch);\n\n          JERRY_ASSERT ((opcode_data >> VM_OC_NON_STATIC_SHIFT) <= 0x1);\n\n          ecma_string_t *prop_name_p = ecma_op_to_prop_name (right_value);\n\n          if (JERRY_UNLIKELY (prop_name_p == NULL))\n          {\n            result = ECMA_VALUE_ERROR;\n            goto error;\n          }\n\n#if ENABLED (JERRY_ES2015)\n          if (JERRY_UNLIKELY (ecma_compare_ecma_string_to_magic_id (prop_name_p, LIT_MAGIC_STRING_PROTOTYPE))\n              && !(opcode_data & VM_OC_NON_STATIC_FLAG))\n          {\n            result = ecma_raise_type_error (ECMA_ERR_MSG (\"prototype property of a class is non-configurable\"));\n            goto error;\n          }\n\n          const int index = (int) (opcode_data >> VM_OC_NON_STATIC_SHIFT) - 2;\n#else /* !ENABLED (JERRY_ES2015) */\n          const int index = -1;\n#endif /* ENABLED (JERRY_ES2015) */\n\n          ecma_object_t *object_p = ecma_get_object_from_value (stack_top_p[index]);\n\n          JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));\n\n          ecma_property_t *property_p = ecma_find_named_property (object_p, prop_name_p);\n\n          if (property_p != NULL\n              && ECMA_PROPERTY_GET_TYPE (*property_p) != ECMA_PROPERTY_TYPE_NAMEDDATA)\n          {\n            ecma_delete_property (object_p, ECMA_PROPERTY_VALUE_PTR (property_p));\n            property_p = NULL;\n          }\n\n          ecma_property_value_t *prop_value_p;\n\n          if (property_p == NULL)\n          {\n            prop_value_p = ecma_create_named_data_property (object_p,\n                                                            prop_name_p,\n                                                            ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,\n                                                            NULL);\n          }\n          else\n          {\n            prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n          }\n\n          ecma_named_data_property_assign_value (object_p, prop_value_p, left_value);\n\n          ecma_deref_ecma_string (prop_name_p);\n\n          goto free_both_values;\n        }\n        case VM_OC_SET_GETTER:\n        case VM_OC_SET_SETTER:\n        {\n          JERRY_ASSERT ((opcode_data >> VM_OC_NON_STATIC_SHIFT) <= 0x1);\n\n          ecma_string_t *prop_name_p = ecma_op_to_prop_name (left_value);\n\n          if (JERRY_UNLIKELY (prop_name_p == NULL))\n          {\n            result = ECMA_VALUE_ERROR;\n            goto error;\n          }\n\n#if ENABLED (JERRY_ES2015)\n          if (JERRY_UNLIKELY (ecma_compare_ecma_string_to_magic_id (prop_name_p, LIT_MAGIC_STRING_PROTOTYPE))\n              && !(opcode_data & VM_OC_NON_STATIC_FLAG))\n          {\n            result = ecma_raise_type_error (ECMA_ERR_MSG (\"prototype property of a class is non-configurable\"));\n            goto error;\n          }\n\n          const int index = (int) (opcode_data >> VM_OC_NON_STATIC_SHIFT) - 2;\n#else /* !ENABLED (JERRY_ES2015) */\n          const int index = -1;\n#endif /* ENABLED (JERRY_ES2015) */\n\n          opfunc_set_accessor (VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_SET_GETTER,\n                               stack_top_p[index],\n                               prop_name_p,\n                               right_value);\n\n          ecma_deref_ecma_string (prop_name_p);\n\n          goto free_both_values;\n        }\n        case VM_OC_PUSH_ARRAY:\n        {\n          // Note: this operation cannot throw an exception\n          *stack_top_p++ = ecma_make_object_value (ecma_op_new_fast_array_object (0));\n          continue;\n        }\n#if ENABLED (JERRY_ES2015)\n        case VM_OC_LOCAL_EVAL:\n        {\n          ECMA_CLEAR_LOCAL_PARSE_OPTS ();\n          uint8_t parse_opts = *byte_code_p++;\n          ECMA_SET_LOCAL_PARSE_OPTS (parse_opts);\n          continue;\n        }\n        case VM_OC_SUPER_CALL:\n        {\n          uint8_t arguments_list_len = *byte_code_p++;\n\n          if (opcode >= CBC_EXT_SPREAD_SUPER_CALL)\n          {\n            stack_top_p -= arguments_list_len;\n            ecma_collection_t *arguments_p = opfunc_spread_arguments (stack_top_p, arguments_list_len);\n\n            if (JERRY_UNLIKELY (arguments_p == NULL))\n            {\n              result = ECMA_VALUE_ERROR;\n              goto error;\n            }\n\n            stack_top_p++;\n            ECMA_SET_INTERNAL_VALUE_POINTER (stack_top_p[-1], arguments_p);\n          }\n          else\n          {\n            stack_top_p -= arguments_list_len;\n          }\n\n          frame_ctx_p->call_operation = VM_EXEC_SUPER_CALL;\n          frame_ctx_p->byte_code_p = byte_code_start_p;\n          frame_ctx_p->stack_top_p = stack_top_p;\n          return ECMA_VALUE_UNDEFINED;\n        }\n        case VM_OC_PUSH_CLASS_ENVIRONMENT:\n        {\n          opfunc_push_class_environment (frame_ctx_p, &stack_top_p, left_value);\n          goto free_left_value;\n        }\n        case VM_OC_PUSH_IMPLICIT_CTOR:\n        {\n          *stack_top_p++ = opfunc_create_implicit_class_constructor (opcode);\n          continue;\n        }\n        case VM_OC_INIT_CLASS:\n        {\n          result = opfunc_init_class (frame_ctx_p, stack_top_p);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n          continue;\n        }\n        case VM_OC_FINALIZE_CLASS:\n        {\n          opfunc_finalize_class (frame_ctx_p, &stack_top_p, left_value);\n          goto free_left_value;\n        }\n        case VM_OC_PUSH_SUPER_CONSTRUCTOR:\n        {\n          result = ecma_op_function_get_super_constructor (JERRY_CONTEXT (current_function_obj_p));\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          continue;\n        }\n        case VM_OC_RESOLVE_LEXICAL_THIS:\n        {\n          result = ecma_op_get_this_binding (frame_ctx_p->lex_env_p);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          continue;\n        }\n        case VM_OC_SUPER_REFERENCE:\n        {\n          result = opfunc_form_super_reference (&stack_top_p, frame_ctx_p, left_value, opcode);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          goto free_left_value;\n        }\n        case VM_OC_PUSH_SPREAD_ELEMENT:\n        {\n          *stack_top_p++ = ECMA_VALUE_SPREAD_ELEMENT;\n          continue;\n        }\n        case VM_OC_GET_ITERATOR:\n        {\n          result = ecma_op_get_iterator (stack_top_p[-1], ECMA_VALUE_EMPTY);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          continue;\n        }\n        case VM_OC_ITERATOR_STEP:\n        {\n          JERRY_ASSERT (opcode >= CBC_EXT_ITERATOR_STEP && opcode <= CBC_EXT_ITERATOR_STEP_3);\n          const uint8_t index = (uint8_t) (1 + (opcode - CBC_EXT_ITERATOR_STEP));\n          result = ecma_op_iterator_step (stack_top_p[-index]);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          ecma_value_t value = ECMA_VALUE_UNDEFINED;\n\n          if (!ecma_is_value_false (result))\n          {\n            value = ecma_op_iterator_value (result);\n            ecma_free_value (result);\n\n            if (ECMA_IS_VALUE_ERROR (value))\n            {\n              result = value;\n              goto error;\n            }\n          }\n\n          *stack_top_p++ = value;\n          continue;\n        }\n        case VM_OC_ITERATOR_CLOSE:\n        {\n          result = ecma_op_iterator_close (left_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          goto free_left_value;\n        }\n        case VM_OC_DEFAULT_INITIALIZER:\n        {\n          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);\n\n          if (stack_top_p[-1] != ECMA_VALUE_UNDEFINED)\n          {\n            byte_code_p = byte_code_start_p + branch_offset;\n            continue;\n          }\n\n          stack_top_p--;\n          continue;\n        }\n        case VM_OC_REST_INITIALIZER:\n        {\n          JERRY_ASSERT (opcode >= CBC_EXT_REST_INITIALIZER && opcode <= CBC_EXT_REST_INITIALIZER_3);\n          const uint8_t iterator_index = (uint8_t) (1 + (opcode - CBC_EXT_REST_INITIALIZER));\n          ecma_object_t *array_p = ecma_op_new_fast_array_object (0);\n          ecma_value_t iterator = stack_top_p[-iterator_index];\n          uint32_t index = 0;\n\n          while (true)\n          {\n            result = ecma_op_iterator_step (iterator);\n\n            if (ECMA_IS_VALUE_ERROR (result))\n            {\n              ecma_deref_object (array_p);\n              goto error;\n            }\n\n            if (ecma_is_value_false (result))\n            {\n              break;\n            }\n\n            ecma_value_t value = ecma_op_iterator_value (result);\n            ecma_free_value (result);\n\n            if (ECMA_IS_VALUE_ERROR (value))\n            {\n              ecma_deref_object (array_p);\n              result = value;\n              goto error;\n            }\n\n            bool set_result = ecma_fast_array_set_property (array_p, index++, value);\n            JERRY_ASSERT (set_result);\n            ecma_free_value (value);\n          }\n\n          *stack_top_p++ = ecma_make_object_value (array_p);\n          continue;\n        }\n        case VM_OC_INITIALIZER_PUSH_PROP:\n        {\n          result = vm_op_get_value (stack_top_p[-1], left_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_left_value;\n        }\n        case VM_OC_SPREAD_ARGUMENTS:\n        {\n          uint8_t arguments_list_len = *byte_code_p++;\n          stack_top_p -= arguments_list_len;\n\n          ecma_collection_t *arguments_p = opfunc_spread_arguments (stack_top_p, arguments_list_len);\n\n          if (JERRY_UNLIKELY (arguments_p == NULL))\n          {\n            result = ECMA_VALUE_ERROR;\n            goto error;\n          }\n\n          stack_top_p++;\n          ECMA_SET_INTERNAL_VALUE_POINTER (stack_top_p[-1], arguments_p);\n\n          frame_ctx_p->call_operation = VM_EXEC_SPREAD_OP;\n          frame_ctx_p->byte_code_p = byte_code_start_p;\n          frame_ctx_p->stack_top_p = stack_top_p;\n          return ECMA_VALUE_UNDEFINED;\n        }\n        case VM_OC_CREATE_GENERATOR:\n        {\n          frame_ctx_p->call_operation = VM_EXEC_RETURN;\n          frame_ctx_p->byte_code_p = byte_code_p;\n          frame_ctx_p->stack_top_p = stack_top_p;\n          result = opfunc_create_executable_object (frame_ctx_p);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          return result;\n        }\n        case VM_OC_YIELD:\n        {\n          frame_ctx_p->call_operation = VM_EXEC_RETURN;\n          frame_ctx_p->byte_code_p = byte_code_p;\n          frame_ctx_p->stack_top_p = --stack_top_p;\n          return *stack_top_p;\n        }\n        case VM_OC_AWAIT:\n        {\n          continue;\n        }\n        case VM_OC_EXT_RETURN:\n        {\n          result = left_value;\n          left_value = ECMA_VALUE_UNDEFINED;\n\n          ecma_value_t *stack_bottom_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;\n\n          while (stack_top_p > stack_bottom_p)\n          {\n            ecma_fast_free_value (*(--stack_top_p));\n          }\n\n          goto error;\n        }\n        case VM_OC_RETURN_PROMISE:\n        {\n          result = opfunc_return_promise (left_value);\n          left_value = ECMA_VALUE_UNDEFINED;\n          goto error;\n        }\n        case VM_OC_STRING_CONCAT:\n        {\n          ecma_string_t *left_str_p = ecma_op_to_string (left_value);\n\n          if (JERRY_UNLIKELY (left_str_p == NULL))\n          {\n            result = ECMA_VALUE_ERROR;\n            goto error;\n          }\n          ecma_string_t *right_str_p = ecma_op_to_string (right_value);\n\n          if (JERRY_UNLIKELY (right_str_p == NULL))\n          {\n            ecma_deref_ecma_string (left_str_p);\n            result = ECMA_VALUE_ERROR;\n            goto error;\n          }\n\n          ecma_string_t *result_str_p = ecma_concat_ecma_strings (left_str_p, right_str_p);\n          ecma_deref_ecma_string (right_str_p);\n\n          *stack_top_p++ = ecma_make_string_value (result_str_p);\n          goto free_both_values;\n        }\n        case VM_OC_GET_TEMPLATE_OBJECT:\n        {\n          uint8_t tagged_idx = *byte_code_p++;\n          ecma_collection_t *collection_p = ecma_compiled_code_get_tagged_template_collection (bytecode_header_p);\n          JERRY_ASSERT (tagged_idx < collection_p->item_count);\n\n          *stack_top_p++ = ecma_copy_value (collection_p->buffer_p[tagged_idx]);\n          continue;\n        }\n        case VM_OC_PUSH_NEW_TARGET:\n        {\n          ecma_object_t *new_target_object = JERRY_CONTEXT (current_new_target);\n          if (new_target_object == NULL)\n          {\n            *stack_top_p++ = ECMA_VALUE_UNDEFINED;\n          }\n          else\n          {\n            ecma_ref_object (new_target_object);\n            *stack_top_p++ = ecma_make_object_value (new_target_object);\n          }\n          continue;\n        }\n        case VM_OC_REQUIRE_OBJECT_COERCIBLE:\n        {\n          result = ecma_op_check_object_coercible (stack_top_p[-1]);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n          continue;\n        }\n        case VM_OC_ASSIGN_SUPER:\n        {\n          result = opfunc_assign_super_reference (&stack_top_p, frame_ctx_p, opcode_data);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n          continue;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n        case VM_OC_PUSH_ELISON:\n        {\n          *stack_top_p++ = ECMA_VALUE_ARRAY_HOLE;\n          continue;\n        }\n        case VM_OC_APPEND_ARRAY:\n        {\n          uint16_t values_length = *byte_code_p++;\n          stack_top_p -= values_length;\n\n#if ENABLED (JERRY_ES2015)\n          if (*byte_code_start_p == CBC_EXT_OPCODE)\n          {\n            values_length = (uint16_t) (values_length | OPFUNC_HAS_SPREAD_ELEMENT);\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n          result = opfunc_append_array (stack_top_p, values_length);\n\n#if ENABLED (JERRY_ES2015)\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n#else /* !ENABLED (JERRY_ES2015) */\n          JERRY_ASSERT (ecma_is_value_empty (result));\n#endif /* ENABLED (JERRY_ES2015) */\n          continue;\n        }\n        case VM_OC_IDENT_REFERENCE:\n        {\n          uint16_t literal_index;\n\n          READ_LITERAL_INDEX (literal_index);\n\n          JERRY_ASSERT (literal_index < ident_end);\n\n          if (literal_index < register_end)\n          {\n            *stack_top_p++ = ECMA_VALUE_REGISTER_REF;\n            *stack_top_p++ = ecma_make_integer_value (literal_index);\n            *stack_top_p++ = ecma_fast_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index));\n          }\n          else\n          {\n            ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n\n            ecma_object_t *ref_base_lex_env_p;\n\n            result = ecma_op_get_value_lex_env_base (frame_ctx_p->lex_env_p,\n                                                     &ref_base_lex_env_p,\n                                                     name_p);\n\n            if (ECMA_IS_VALUE_ERROR (result))\n            {\n              goto error;\n            }\n\n            ecma_ref_object (ref_base_lex_env_p);\n            ecma_ref_ecma_string (name_p);\n            *stack_top_p++ = ecma_make_object_value (ref_base_lex_env_p);\n            *stack_top_p++ = ecma_make_string_value (name_p);\n            *stack_top_p++ = result;\n          }\n          continue;\n        }\n        case VM_OC_PROP_GET:\n        {\n          result = vm_op_get_value (left_value, right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_PROP_REFERENCE:\n        {\n          /* Forms with reference requires preserving the base and offset. */\n\n          if (opcode == CBC_PUSH_PROP_REFERENCE)\n          {\n            left_value = stack_top_p[-2];\n            right_value = stack_top_p[-1];\n          }\n          else if (opcode == CBC_PUSH_PROP_LITERAL_REFERENCE)\n          {\n            *stack_top_p++ = left_value;\n            right_value = left_value;\n            left_value = stack_top_p[-2];\n          }\n          else\n          {\n            JERRY_ASSERT (opcode == CBC_PUSH_PROP_LITERAL_LITERAL_REFERENCE\n                          || opcode == CBC_PUSH_PROP_THIS_LITERAL_REFERENCE);\n            *stack_top_p++ = left_value;\n            *stack_top_p++ = right_value;\n          }\n          /* FALLTHRU */\n        }\n        case VM_OC_PROP_PRE_INCR:\n        case VM_OC_PROP_PRE_DECR:\n        case VM_OC_PROP_POST_INCR:\n        case VM_OC_PROP_POST_DECR:\n        {\n          result = vm_op_get_value (left_value,\n                                    right_value);\n\n          if (opcode < CBC_PRE_INCR)\n          {\n            left_value = ECMA_VALUE_UNDEFINED;\n            right_value = ECMA_VALUE_UNDEFINED;\n          }\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          if (opcode < CBC_PRE_INCR)\n          {\n            break;\n          }\n\n          stack_top_p += 2;\n          left_value = result;\n          right_value = ECMA_VALUE_UNDEFINED;\n          /* FALLTHRU */\n        }\n        case VM_OC_PRE_INCR:\n        case VM_OC_PRE_DECR:\n        case VM_OC_POST_INCR:\n        case VM_OC_POST_DECR:\n        {\n          uint32_t opcode_flags = VM_OC_GROUP_GET_INDEX (opcode_data) - VM_OC_PROP_PRE_INCR;\n\n          byte_code_p = byte_code_start_p + 1;\n\n          if (ecma_is_value_integer_number (left_value))\n          {\n            result = left_value;\n            left_value = ECMA_VALUE_UNDEFINED;\n\n            ecma_integer_value_t int_value = (ecma_integer_value_t) result;\n            ecma_integer_value_t int_increase = 0;\n\n            if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)\n            {\n              if (int_value > ECMA_INTEGER_NUMBER_MIN_SHIFTED)\n              {\n                int_increase = -(1 << ECMA_DIRECT_SHIFT);\n              }\n            }\n            else if (int_value < ECMA_INTEGER_NUMBER_MAX_SHIFTED)\n            {\n              int_increase = 1 << ECMA_DIRECT_SHIFT;\n            }\n\n            if (JERRY_LIKELY (int_increase != 0))\n            {\n              /* Postfix operators require the unmodifed number value. */\n              if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)\n              {\n                if (opcode_data & VM_OC_PUT_STACK)\n                {\n                  if (opcode_flags & VM_OC_IDENT_INCR_DECR_OPERATOR_FLAG)\n                  {\n                    JERRY_ASSERT (opcode == CBC_POST_INCR_IDENT_PUSH_RESULT\n                                  || opcode == CBC_POST_DECR_IDENT_PUSH_RESULT);\n\n                    *stack_top_p++ = result;\n                  }\n                  else\n                  {\n                    /* The parser ensures there is enough space for the\n                     * extra value on the stack. See js-parser-expr.c. */\n\n                    JERRY_ASSERT (opcode == CBC_POST_INCR_PUSH_RESULT\n                                  || opcode == CBC_POST_DECR_PUSH_RESULT);\n\n                    stack_top_p++;\n                    stack_top_p[-1] = stack_top_p[-2];\n                    stack_top_p[-2] = stack_top_p[-3];\n                    stack_top_p[-3] = result;\n                  }\n                  opcode_data &= (uint32_t) ~VM_OC_PUT_STACK;\n                }\n                else if (opcode_data & VM_OC_PUT_BLOCK)\n                {\n                  ecma_free_value (frame_ctx_p->block_result);\n                  frame_ctx_p->block_result = result;\n                  opcode_data &= (uint32_t) ~VM_OC_PUT_BLOCK;\n                }\n              }\n\n              result = (ecma_value_t) (int_value + int_increase);\n              break;\n            }\n          }\n          else if (ecma_is_value_float_number (left_value))\n          {\n            result = left_value;\n            left_value = ECMA_VALUE_UNDEFINED;\n          }\n          else\n          {\n            result = ecma_op_to_number (left_value);\n\n            if (ECMA_IS_VALUE_ERROR (result))\n            {\n              goto error;\n            }\n          }\n\n          ecma_number_t increase = ECMA_NUMBER_ONE;\n          ecma_number_t result_number = ecma_get_number_from_value (result);\n\n          if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)\n          {\n            /* For decrement operators */\n            increase = ECMA_NUMBER_MINUS_ONE;\n          }\n\n          /* Post operators require the unmodifed number value. */\n          if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)\n          {\n            if (opcode_data & VM_OC_PUT_STACK)\n            {\n              if (opcode_flags & VM_OC_IDENT_INCR_DECR_OPERATOR_FLAG)\n              {\n                JERRY_ASSERT (opcode == CBC_POST_INCR_IDENT_PUSH_RESULT\n                              || opcode == CBC_POST_DECR_IDENT_PUSH_RESULT);\n\n                *stack_top_p++ = ecma_copy_value (result);\n              }\n              else\n              {\n                /* The parser ensures there is enough space for the\n                 * extra value on the stack. See js-parser-expr.c. */\n\n                JERRY_ASSERT (opcode == CBC_POST_INCR_PUSH_RESULT\n                              || opcode == CBC_POST_DECR_PUSH_RESULT);\n\n                stack_top_p++;\n                stack_top_p[-1] = stack_top_p[-2];\n                stack_top_p[-2] = stack_top_p[-3];\n                stack_top_p[-3] = ecma_copy_value (result);\n              }\n              opcode_data &= (uint32_t) ~VM_OC_PUT_STACK;\n            }\n            else if (opcode_data & VM_OC_PUT_BLOCK)\n            {\n              ecma_free_value (frame_ctx_p->block_result);\n              frame_ctx_p->block_result = ecma_copy_value (result);\n              opcode_data &= (uint32_t) ~VM_OC_PUT_BLOCK;\n            }\n          }\n\n          if (ecma_is_value_integer_number (result))\n          {\n            result = ecma_make_number_value (result_number + increase);\n          }\n          else\n          {\n            result = ecma_update_float_number (result, result_number + increase);\n          }\n          break;\n        }\n        case VM_OC_ASSIGN:\n        {\n          result = left_value;\n          left_value = ECMA_VALUE_UNDEFINED;\n          break;\n        }\n        case VM_OC_MOV_IDENT:\n        {\n          uint32_t literal_index;\n\n          READ_LITERAL_INDEX (literal_index);\n\n          JERRY_ASSERT (literal_index < register_end);\n          JERRY_ASSERT (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)));\n\n          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));\n          VM_GET_REGISTER (frame_ctx_p, literal_index) = left_value;\n          continue;\n        }\n        case VM_OC_ASSIGN_PROP:\n        {\n          result = stack_top_p[-1];\n          stack_top_p[-1] = left_value;\n          left_value = ECMA_VALUE_UNDEFINED;\n          break;\n        }\n        case VM_OC_ASSIGN_PROP_THIS:\n        {\n          result = stack_top_p[-1];\n          stack_top_p[-1] = ecma_copy_value (frame_ctx_p->this_binding);\n          *stack_top_p++ = left_value;\n          left_value = ECMA_VALUE_UNDEFINED;\n          break;\n        }\n        case VM_OC_RETURN:\n        {\n          JERRY_ASSERT (opcode == CBC_RETURN\n                        || opcode == CBC_RETURN_WITH_BLOCK\n                        || opcode == CBC_RETURN_WITH_LITERAL);\n\n          if (opcode == CBC_RETURN_WITH_BLOCK)\n          {\n            left_value = frame_ctx_p->block_result;\n            frame_ctx_p->block_result = ECMA_VALUE_UNDEFINED;\n          }\n\n          result = left_value;\n          left_value = ECMA_VALUE_UNDEFINED;\n          goto error;\n        }\n        case VM_OC_THROW:\n        {\n          jcontext_raise_exception (left_value);\n\n          result = ECMA_VALUE_ERROR;\n          left_value = ECMA_VALUE_UNDEFINED;\n          goto error;\n        }\n        case VM_OC_THROW_REFERENCE_ERROR:\n        {\n          result = ecma_raise_reference_error (ECMA_ERR_MSG (\"Undefined reference.\"));\n          goto error;\n        }\n        case VM_OC_EVAL:\n        {\n          JERRY_CONTEXT (status_flags) |= ECMA_STATUS_DIRECT_EVAL;\n          JERRY_ASSERT ((*byte_code_p >= CBC_CALL && *byte_code_p <= CBC_CALL2_PROP_BLOCK)\n                        || (*byte_code_p == CBC_EXT_OPCODE\n                            && byte_code_p[1] >= CBC_EXT_SPREAD_CALL\n                            && byte_code_p[1] <= CBC_EXT_SPREAD_CALL_PROP_BLOCK));\n          continue;\n        }\n        case VM_OC_CALL:\n        {\n          frame_ctx_p->call_operation = VM_EXEC_CALL;\n          frame_ctx_p->byte_code_p = byte_code_start_p;\n          frame_ctx_p->stack_top_p = stack_top_p;\n          return ECMA_VALUE_UNDEFINED;\n        }\n        case VM_OC_NEW:\n        {\n          frame_ctx_p->call_operation = VM_EXEC_CONSTRUCT;\n          frame_ctx_p->byte_code_p = byte_code_start_p;\n          frame_ctx_p->stack_top_p = stack_top_p;\n          return ECMA_VALUE_UNDEFINED;\n        }\n        case VM_OC_ERROR:\n        {\n          JERRY_ASSERT (frame_ctx_p->byte_code_p[1] == CBC_EXT_ERROR);\n#if ENABLED (JERRY_DEBUGGER)\n          frame_ctx_p->byte_code_p = JERRY_CONTEXT (debugger_exception_byte_code_p);\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n          result = ECMA_VALUE_ERROR;\n          goto error;\n        }\n        case VM_OC_RESOLVE_BASE_FOR_CALL:\n        {\n          ecma_value_t this_value = stack_top_p[-3];\n\n          if (this_value == ECMA_VALUE_REGISTER_REF)\n          {\n            /* Lexical environment cannot be 'this' value. */\n            stack_top_p[-2] = ECMA_VALUE_UNDEFINED;\n            stack_top_p[-3] = ECMA_VALUE_UNDEFINED;\n          }\n          else if (vm_get_implicit_this_value (&this_value))\n          {\n            ecma_free_value (stack_top_p[-3]);\n            stack_top_p[-3] = this_value;\n          }\n\n          continue;\n        }\n        case VM_OC_PROP_DELETE:\n        {\n          result = vm_op_delete_prop (left_value, right_value, is_strict);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          JERRY_ASSERT (ecma_is_value_boolean (result));\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_DELETE:\n        {\n          uint16_t literal_index;\n\n          READ_LITERAL_INDEX (literal_index);\n\n          if (literal_index < register_end)\n          {\n            *stack_top_p++ = ECMA_VALUE_FALSE;\n            continue;\n          }\n\n          result = vm_op_delete_var (literal_start_p[literal_index],\n                                     frame_ctx_p->lex_env_p);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          JERRY_ASSERT (ecma_is_value_boolean (result));\n\n          *stack_top_p++ = result;\n          continue;\n        }\n        case VM_OC_JUMP:\n        {\n          byte_code_p = byte_code_start_p + branch_offset;\n          continue;\n        }\n        case VM_OC_BRANCH_IF_STRICT_EQUAL:\n        {\n          ecma_value_t value = *(--stack_top_p);\n\n          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);\n\n          if (ecma_op_strict_equality_compare (value, stack_top_p[-1]))\n          {\n            byte_code_p = byte_code_start_p + branch_offset;\n            ecma_free_value (*--stack_top_p);\n          }\n          ecma_free_value (value);\n          continue;\n        }\n        case VM_OC_BRANCH_IF_TRUE:\n        case VM_OC_BRANCH_IF_FALSE:\n        case VM_OC_BRANCH_IF_LOGICAL_TRUE:\n        case VM_OC_BRANCH_IF_LOGICAL_FALSE:\n        {\n          uint32_t opcode_flags = VM_OC_GROUP_GET_INDEX (opcode_data) - VM_OC_BRANCH_IF_TRUE;\n          ecma_value_t value = *(--stack_top_p);\n\n          bool boolean_value = ecma_op_to_boolean (value);\n\n          if (opcode_flags & VM_OC_BRANCH_IF_FALSE_FLAG)\n          {\n            boolean_value = !boolean_value;\n          }\n\n          if (boolean_value)\n          {\n            byte_code_p = byte_code_start_p + branch_offset;\n            if (opcode_flags & VM_OC_LOGICAL_BRANCH_FLAG)\n            {\n              /* \"Push\" the value back to the stack. */\n              ++stack_top_p;\n              continue;\n            }\n          }\n\n          ecma_fast_free_value (value);\n          continue;\n        }\n        case VM_OC_PLUS:\n        case VM_OC_MINUS:\n        {\n          result = opfunc_unary_operation (left_value, VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_PLUS);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_left_value;\n        }\n        case VM_OC_NOT:\n        {\n          *stack_top_p++ = ecma_make_boolean_value (!ecma_op_to_boolean (left_value));\n          JERRY_ASSERT (ecma_is_value_boolean (stack_top_p[-1]));\n          goto free_left_value;\n        }\n        case VM_OC_BIT_NOT:\n        {\n          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),\n                               direct_type_mask_must_fill_all_bits_before_the_value_starts);\n\n          if (ecma_is_value_integer_number (left_value))\n          {\n            *stack_top_p++ = (~left_value) & (ecma_value_t) (~ECMA_DIRECT_TYPE_MASK);\n            goto free_left_value;\n          }\n\n          result = do_number_bitwise_logic (NUMBER_BITWISE_NOT,\n                                            left_value,\n                                            left_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_left_value;\n        }\n        case VM_OC_VOID:\n        {\n          *stack_top_p++ = ECMA_VALUE_UNDEFINED;\n          goto free_left_value;\n        }\n        case VM_OC_TYPEOF_IDENT:\n        {\n          uint16_t literal_index;\n\n          READ_LITERAL_INDEX (literal_index);\n\n          JERRY_ASSERT (literal_index < ident_end);\n\n          if (literal_index < register_end)\n          {\n            left_value = ecma_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index));\n          }\n          else\n          {\n            ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n\n            ecma_object_t *ref_base_lex_env_p;\n\n            result = ecma_op_get_value_lex_env_base (frame_ctx_p->lex_env_p,\n                                                     &ref_base_lex_env_p,\n                                                     name_p);\n\n            if (ref_base_lex_env_p == NULL)\n            {\n              jcontext_release_exception ();\n              result = ECMA_VALUE_UNDEFINED;\n            }\n            else if (ECMA_IS_VALUE_ERROR (result))\n            {\n              goto error;\n            }\n\n            left_value = result;\n          }\n          /* FALLTHRU */\n        }\n        case VM_OC_TYPEOF:\n        {\n          result = opfunc_typeof (left_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_left_value;\n        }\n        case VM_OC_ADD:\n        {\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);\n            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);\n            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer + right_integer));\n            continue;\n          }\n\n          if (ecma_is_value_float_number (left_value)\n              && ecma_is_value_number (right_value))\n          {\n            ecma_number_t new_value = (ecma_get_float_from_value (left_value) +\n                                       ecma_get_number_from_value (right_value));\n\n            *stack_top_p++ = ecma_update_float_number (left_value, new_value);\n            ecma_free_number (right_value);\n            continue;\n          }\n\n          if (ecma_is_value_float_number (right_value)\n              && ecma_is_value_integer_number (left_value))\n          {\n            ecma_number_t new_value = ((ecma_number_t) ecma_get_integer_from_value (left_value) +\n                                       ecma_get_float_from_value (right_value));\n\n            *stack_top_p++ = ecma_update_float_number (right_value, new_value);\n            continue;\n          }\n\n          result = opfunc_addition (left_value, right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_SUB:\n        {\n          JERRY_STATIC_ASSERT (ECMA_INTEGER_NUMBER_MAX * 2 <= INT32_MAX\n                               && ECMA_INTEGER_NUMBER_MIN * 2 >= INT32_MIN,\n                               doubled_ecma_numbers_must_fit_into_int32_range);\n\n          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)\n                        && !ECMA_IS_VALUE_ERROR (right_value));\n\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);\n            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);\n            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer - right_integer));\n            continue;\n          }\n\n          if (ecma_is_value_float_number (left_value)\n              && ecma_is_value_number (right_value))\n          {\n            ecma_number_t new_value = (ecma_get_float_from_value (left_value) -\n                                       ecma_get_number_from_value (right_value));\n\n            *stack_top_p++ = ecma_update_float_number (left_value, new_value);\n            ecma_free_number (right_value);\n            continue;\n          }\n\n          if (ecma_is_value_float_number (right_value)\n              && ecma_is_value_integer_number (left_value))\n          {\n            ecma_number_t new_value = ((ecma_number_t) ecma_get_integer_from_value (left_value) -\n                                       ecma_get_float_from_value (right_value));\n\n            *stack_top_p++ = ecma_update_float_number (right_value, new_value);\n            continue;\n          }\n\n          result = do_number_arithmetic (NUMBER_ARITHMETIC_SUBTRACTION,\n                                         left_value,\n                                         right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_MUL:\n        {\n          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)\n                        && !ECMA_IS_VALUE_ERROR (right_value));\n\n          JERRY_STATIC_ASSERT (ECMA_INTEGER_MULTIPLY_MAX * ECMA_INTEGER_MULTIPLY_MAX <= ECMA_INTEGER_NUMBER_MAX\n                               && -(ECMA_INTEGER_MULTIPLY_MAX * ECMA_INTEGER_MULTIPLY_MAX) >= ECMA_INTEGER_NUMBER_MIN,\n                               square_of_integer_multiply_max_must_fit_into_integer_value_range);\n\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);\n            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);\n\n            if (-ECMA_INTEGER_MULTIPLY_MAX <= left_integer\n                && left_integer <= ECMA_INTEGER_MULTIPLY_MAX\n                && -ECMA_INTEGER_MULTIPLY_MAX <= right_integer\n                && right_integer <= ECMA_INTEGER_MULTIPLY_MAX\n                && left_value != 0\n                && right_value != 0)\n            {\n              *stack_top_p++ = ecma_integer_multiply (left_integer, right_integer);\n              continue;\n            }\n\n            ecma_number_t multiply = (ecma_number_t) left_integer * (ecma_number_t) right_integer;\n            *stack_top_p++ = ecma_make_number_value (multiply);\n            continue;\n          }\n\n          if (ecma_is_value_float_number (left_value)\n              && ecma_is_value_number (right_value))\n          {\n            ecma_number_t new_value = (ecma_get_float_from_value (left_value) *\n                                       ecma_get_number_from_value (right_value));\n\n            *stack_top_p++ = ecma_update_float_number (left_value, new_value);\n            ecma_free_number (right_value);\n            continue;\n          }\n\n          if (ecma_is_value_float_number (right_value)\n              && ecma_is_value_integer_number (left_value))\n          {\n            ecma_number_t new_value = ((ecma_number_t) ecma_get_integer_from_value (left_value) *\n                                       ecma_get_float_from_value (right_value));\n\n            *stack_top_p++ = ecma_update_float_number (right_value, new_value);\n            continue;\n          }\n\n          result = do_number_arithmetic (NUMBER_ARITHMETIC_MULTIPLICATION,\n                                         left_value,\n                                         right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_DIV:\n        {\n          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)\n                        && !ECMA_IS_VALUE_ERROR (right_value));\n\n          result = do_number_arithmetic (NUMBER_ARITHMETIC_DIVISION,\n                                         left_value,\n                                         right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_MOD:\n        {\n          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)\n                        && !ECMA_IS_VALUE_ERROR (right_value));\n\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);\n            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);\n\n            if (right_integer != 0)\n            {\n              ecma_integer_value_t mod_result = left_integer % right_integer;\n\n              if (mod_result != 0 || left_integer >= 0)\n              {\n                *stack_top_p++ = ecma_make_integer_value (mod_result);\n                continue;\n              }\n            }\n          }\n\n          result = do_number_arithmetic (NUMBER_ARITHMETIC_REMAINDER,\n                                         left_value,\n                                         right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n#if ENABLED (JERRY_ES2015)\n        case VM_OC_EXP:\n        {\n          result = do_number_arithmetic (NUMBER_ARITHMETIC_EXPONENTIATION,\n                                         left_value,\n                                         right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n        case VM_OC_EQUAL:\n        {\n          result = opfunc_equality (left_value, right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_NOT_EQUAL:\n        {\n          result = opfunc_equality (left_value, right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = ecma_invert_boolean_value (result);\n          goto free_both_values;\n        }\n        case VM_OC_STRICT_EQUAL:\n        {\n          bool is_equal = ecma_op_strict_equality_compare (left_value, right_value);\n\n          result = ecma_make_boolean_value (is_equal);\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_STRICT_NOT_EQUAL:\n        {\n          bool is_equal = ecma_op_strict_equality_compare (left_value, right_value);\n\n          result = ecma_make_boolean_value (!is_equal);\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_BIT_OR:\n        {\n          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),\n                               direct_type_mask_must_fill_all_bits_before_the_value_starts);\n\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            *stack_top_p++ = left_value | right_value;\n            continue;\n          }\n\n          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_OR,\n                                            left_value,\n                                            right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_BIT_XOR:\n        {\n          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),\n                               direct_type_mask_must_fill_all_bits_before_the_value_starts);\n\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            *stack_top_p++ = (left_value ^ right_value) & (ecma_value_t) (~ECMA_DIRECT_TYPE_MASK);\n            continue;\n          }\n\n          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_XOR,\n                                            left_value,\n                                            right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_BIT_AND:\n        {\n          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),\n                               direct_type_mask_must_fill_all_bits_before_the_value_starts);\n\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            *stack_top_p++ = left_value & right_value;\n            continue;\n          }\n\n          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_AND,\n                                            left_value,\n                                            right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_LEFT_SHIFT:\n        {\n          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),\n                               direct_type_mask_must_fill_all_bits_before_the_value_starts);\n\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);\n            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);\n            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer << (right_integer & 0x1f)));\n            continue;\n          }\n\n          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_LEFT,\n                                            left_value,\n                                            right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_RIGHT_SHIFT:\n        {\n          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),\n                               direct_type_mask_must_fill_all_bits_before_the_value_starts);\n\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);\n            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);\n            *stack_top_p++ = ecma_make_integer_value (left_integer >> (right_integer & 0x1f));\n            continue;\n          }\n\n          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_RIGHT,\n                                            left_value,\n                                            right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_UNS_RIGHT_SHIFT:\n        {\n          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),\n                               direct_type_mask_must_fill_all_bits_before_the_value_starts);\n\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            uint32_t left_uint32 = (uint32_t) ecma_get_integer_from_value (left_value);\n            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);\n            *stack_top_p++ = ecma_make_uint32_value (left_uint32 >> (right_integer & 0x1f));\n            continue;\n          }\n\n          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_URIGHT,\n                                            left_value,\n                                            right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_LESS:\n        {\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            bool is_less = (ecma_integer_value_t) left_value < (ecma_integer_value_t) right_value;\n#if !ENABLED (JERRY_VM_EXEC_STOP)\n            /* This is a lookahead to the next opcode to improve performance.\n             * If it is CBC_BRANCH_IF_TRUE_BACKWARD, execute it. */\n            if (*byte_code_p <= CBC_BRANCH_IF_TRUE_BACKWARD_3 && *byte_code_p >= CBC_BRANCH_IF_TRUE_BACKWARD)\n            {\n              byte_code_start_p = byte_code_p++;\n              branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (*byte_code_start_p);\n              JERRY_ASSERT (branch_offset_length >= 1 && branch_offset_length <= 3);\n\n              if (is_less)\n              {\n                branch_offset = *(byte_code_p++);\n\n                if (JERRY_UNLIKELY (branch_offset_length != 1))\n                {\n                  branch_offset <<= 8;\n                  branch_offset |= *(byte_code_p++);\n                  if (JERRY_UNLIKELY (branch_offset_length == 3))\n                  {\n                    branch_offset <<= 8;\n                    branch_offset |= *(byte_code_p++);\n                  }\n                }\n\n                /* Note: The opcode is a backward branch. */\n                byte_code_p = byte_code_start_p - branch_offset;\n              }\n              else\n              {\n                byte_code_p += branch_offset_length;\n              }\n\n              continue;\n            }\n#endif /* !ENABLED (JERRY_VM_EXEC_STOP) */\n            *stack_top_p++ = ecma_make_boolean_value (is_less);\n            continue;\n          }\n\n          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))\n          {\n            ecma_number_t left_number = ecma_get_number_from_value (left_value);\n            ecma_number_t right_number = ecma_get_number_from_value (right_value);\n\n            *stack_top_p++ = ecma_make_boolean_value (left_number < right_number);\n            goto free_both_values;\n          }\n\n          result = opfunc_relation (left_value, right_value, true, false);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_GREATER:\n        {\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;\n            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;\n\n            *stack_top_p++ = ecma_make_boolean_value (left_integer > right_integer);\n            continue;\n          }\n\n          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))\n          {\n            ecma_number_t left_number = ecma_get_number_from_value (left_value);\n            ecma_number_t right_number = ecma_get_number_from_value (right_value);\n\n            *stack_top_p++ = ecma_make_boolean_value (left_number > right_number);\n            goto free_both_values;\n          }\n\n          result = opfunc_relation (left_value, right_value, false, false);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_LESS_EQUAL:\n        {\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;\n            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;\n\n            *stack_top_p++ = ecma_make_boolean_value (left_integer <= right_integer);\n            continue;\n          }\n\n          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))\n          {\n            ecma_number_t left_number = ecma_get_number_from_value (left_value);\n            ecma_number_t right_number = ecma_get_number_from_value (right_value);\n\n            *stack_top_p++ = ecma_make_boolean_value (left_number <= right_number);\n            goto free_both_values;\n          }\n\n          result = opfunc_relation (left_value, right_value, false, true);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_GREATER_EQUAL:\n        {\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;\n            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;\n\n            *stack_top_p++ = ecma_make_boolean_value (left_integer >= right_integer);\n            continue;\n          }\n\n          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))\n          {\n            ecma_number_t left_number = ecma_get_number_from_value (left_value);\n            ecma_number_t right_number = ecma_get_number_from_value (right_value);\n\n            *stack_top_p++ = ecma_make_boolean_value (left_number >= right_number);\n            goto free_both_values;\n          }\n\n          result = opfunc_relation (left_value, right_value, true, true);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_IN:\n        {\n          result = opfunc_in (left_value, right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_INSTANCEOF:\n        {\n          result = opfunc_instanceof (left_value, right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_BLOCK_CREATE_CONTEXT:\n        {\n#if ENABLED (JERRY_ES2015)\n          ecma_value_t *stack_context_top_p;\n          stack_context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;\n\n          JERRY_ASSERT (stack_context_top_p == stack_top_p || stack_context_top_p == stack_top_p - 1);\n\n          if (byte_code_start_p[0] != CBC_EXT_OPCODE)\n          {\n            branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);\n\n            if (stack_context_top_p != stack_top_p)\n            {\n               /* Preserve the value of switch statement. */\n              stack_context_top_p[1] = stack_context_top_p[0];\n            }\n\n            stack_context_top_p[0] = VM_CREATE_CONTEXT_WITH_ENV (VM_CONTEXT_BLOCK, branch_offset);\n\n            VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);\n            stack_top_p += PARSER_BLOCK_CONTEXT_STACK_ALLOCATION;\n          }\n          else\n          {\n            JERRY_ASSERT (byte_code_start_p[1] == CBC_EXT_TRY_CREATE_ENV);\n\n            JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_TRY\n                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_CATCH\n                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP\n                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_THROW\n                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);\n\n            JERRY_ASSERT (!(stack_context_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV));\n\n            stack_context_top_p[-1] |= VM_CONTEXT_HAS_LEX_ENV;\n          }\n#else /* !ENABLED (JERRY_ES2015) */\n          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-2]) == VM_CONTEXT_CATCH\n                        && !(stack_top_p[-2] & VM_CONTEXT_HAS_LEX_ENV));\n\n          stack_top_p[-2] |= VM_CONTEXT_HAS_LEX_ENV;\n#endif /* ENABLED (JERRY_ES2015) */\n\n          frame_ctx_p->lex_env_p = ecma_create_decl_lex_env (frame_ctx_p->lex_env_p);\n          frame_ctx_p->lex_env_p->type_flags_refs |= (uint16_t) ECMA_OBJECT_FLAG_BLOCK;\n\n          continue;\n        }\n        case VM_OC_WITH:\n        {\n          ecma_value_t value = *(--stack_top_p);\n          ecma_object_t *object_p;\n          ecma_object_t *with_env_p;\n\n          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);\n\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n\n          result = ecma_op_to_object (value);\n          ecma_free_value (value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          object_p = ecma_get_object_from_value (result);\n\n          with_env_p = ecma_create_object_lex_env (frame_ctx_p->lex_env_p,\n                                                   object_p,\n                                                   ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n          ecma_deref_object (object_p);\n\n          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_WITH_CONTEXT_STACK_ALLOCATION);\n          stack_top_p += PARSER_WITH_CONTEXT_STACK_ALLOCATION;\n\n          stack_top_p[-1] = VM_CREATE_CONTEXT_WITH_ENV (VM_CONTEXT_WITH, branch_offset);\n\n          with_env_p->type_flags_refs |= (uint16_t) ECMA_OBJECT_FLAG_BLOCK;\n          frame_ctx_p->lex_env_p = with_env_p;\n          continue;\n        }\n        case VM_OC_FOR_IN_CREATE_CONTEXT:\n        {\n          ecma_value_t value = *(--stack_top_p);\n\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n          if (ecma_is_value_object (value)\n              && ECMA_OBJECT_IS_PROXY (ecma_get_object_from_value (value)))\n          {\n            /* Note: - For proxy objects we should create a new object which implements the iterable protocol,\n                       and iterates through the enumerated collection below.\n                     - This inkoves that the VM context type should be adjusted and checked in all FOR-IN related\n                       instruction.\n                     - For other objects we should keep the current implementation due to performance reasons.*/\n            result = ecma_raise_type_error (ECMA_ERR_MSG (\"UNIMPLEMENTED: Proxy support in for-in.\"));\n            goto error;\n          }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n          ecma_value_t expr_obj_value = ECMA_VALUE_UNDEFINED;\n          ecma_collection_t *prop_names_p = opfunc_for_in (value, &expr_obj_value);\n          ecma_free_value (value);\n\n          if (prop_names_p == NULL)\n          {\n            /* The collection is already released */\n            byte_code_p = byte_code_start_p + branch_offset;\n            continue;\n          }\n\n          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);\n\n          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION);\n          stack_top_p += PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;\n          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_IN, branch_offset);\n          ECMA_SET_INTERNAL_VALUE_ANY_POINTER (stack_top_p[-2], prop_names_p);\n          stack_top_p[-3] = 0;\n          stack_top_p[-4] = expr_obj_value;\n\n#if ENABLED (JERRY_ES2015)\n          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)\n          {\n            /* No need to duplicate the first context. */\n            byte_code_p += 2;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n          continue;\n        }\n        case VM_OC_FOR_IN_GET_NEXT:\n        {\n          ecma_value_t *context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;\n\n          ecma_collection_t *collection_p;\n          collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, context_top_p[-2]);\n\n          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_IN);\n\n          uint32_t index = context_top_p[-3];\n          ecma_value_t *buffer_p = collection_p->buffer_p;\n\n          *stack_top_p++ = buffer_p[index];\n          context_top_p[-3]++;\n          continue;\n        }\n        case VM_OC_FOR_IN_HAS_NEXT:\n        {\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n\n          ecma_collection_t *collection_p;\n          collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, stack_top_p[-2]);\n\n          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_IN);\n\n          ecma_value_t *buffer_p = collection_p->buffer_p;\n          ecma_object_t *object_p = ecma_get_object_from_value (stack_top_p[-4]);\n          uint32_t index = stack_top_p[-3];\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n          JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n          while (index < collection_p->item_count)\n          {\n            ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (buffer_p[index]);\n\n            result = ecma_op_object_has_property (object_p, prop_name_p);\n\n            if (JERRY_LIKELY (ecma_is_value_true (result)))\n            {\n              byte_code_p = byte_code_start_p + branch_offset;\n              break;\n            }\n\n            ecma_deref_ecma_string (prop_name_p);\n            index++;\n          }\n\n          if (index == collection_p->item_count)\n          {\n            ecma_deref_object (object_p);\n            ecma_collection_destroy (collection_p);\n            VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION);\n            stack_top_p -= PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;\n          }\n          else\n          {\n            stack_top_p[-3] = index;\n          }\n          continue;\n        }\n#if ENABLED (JERRY_ES2015)\n        case VM_OC_FOR_OF_CREATE_CONTEXT:\n        {\n          ecma_value_t value = *(--stack_top_p);\n\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n\n          ecma_value_t iterator = ecma_op_get_iterator (value, ECMA_VALUE_EMPTY);\n\n          ecma_free_value (value);\n\n          if (ECMA_IS_VALUE_ERROR (iterator))\n          {\n            result = iterator;\n            goto error;\n          }\n\n          ecma_value_t next_value = ecma_op_iterator_step (iterator);\n\n          if (ECMA_IS_VALUE_ERROR (next_value))\n          {\n            ecma_free_value (iterator);\n            result = next_value;\n            goto error;\n          }\n\n          if (ecma_is_value_false (next_value))\n          {\n            ecma_free_value (iterator);\n            byte_code_p = byte_code_start_p + branch_offset;\n            continue;\n          }\n\n          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);\n\n          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);\n          stack_top_p += PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION;\n          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_OF, branch_offset) | VM_CONTEXT_CLOSE_ITERATOR;\n          stack_top_p[-2] = next_value;\n          stack_top_p[-3] = iterator;\n\n          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)\n          {\n            /* No need to duplicate the first context. */\n            byte_code_p += 2;\n          }\n          continue;\n        }\n        case VM_OC_FOR_OF_GET_NEXT:\n        {\n          ecma_value_t *context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;\n          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_OF);\n\n          ecma_value_t next_value = ecma_op_iterator_value (context_top_p[-2]);\n\n          if (ECMA_IS_VALUE_ERROR (next_value))\n          {\n            result = next_value;\n            goto error;\n          }\n\n          *stack_top_p++ = next_value;\n          continue;\n        }\n        case VM_OC_FOR_OF_HAS_NEXT:\n        {\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n\n          ecma_value_t next_value = ecma_op_iterator_step (stack_top_p[-3]);\n\n          if (ECMA_IS_VALUE_ERROR (next_value))\n          {\n            result = next_value;\n            goto error;\n          }\n\n          if (!ecma_is_value_false (next_value))\n          {\n            ecma_free_value (stack_top_p[-2]);\n            stack_top_p[-2] = next_value;\n            byte_code_p = byte_code_start_p + branch_offset;\n            continue;\n          }\n\n          ecma_free_value (stack_top_p[-2]);\n          ecma_free_value (stack_top_p[-3]);\n          VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);\n          stack_top_p -= PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION;\n          continue;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n        case VM_OC_TRY:\n        {\n          /* Try opcode simply creates the try context. */\n          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);\n\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n\n          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);\n          stack_top_p += PARSER_TRY_CONTEXT_STACK_ALLOCATION;\n\n          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_TRY, branch_offset);\n          continue;\n        }\n        case VM_OC_CATCH:\n        {\n          /* Catches are ignored and turned to jumps. */\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_TRY);\n\n          byte_code_p = byte_code_start_p + branch_offset;\n          continue;\n        }\n        case VM_OC_FINALLY:\n        {\n          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);\n\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n\n          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_TRY\n                        || VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_CATCH);\n\n          if (stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV)\n          {\n            ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;\n            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);\n            frame_ctx_p->lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);\n            ecma_deref_object (lex_env_p);\n\n            stack_top_p[-1] &= (ecma_value_t) ~VM_CONTEXT_HAS_LEX_ENV;\n          }\n\n          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FINALLY_JUMP, branch_offset);\n          stack_top_p[-2] = (ecma_value_t) branch_offset;\n          continue;\n        }\n        case VM_OC_CONTEXT_END:\n        {\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n          JERRY_ASSERT (!(stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR));\n\n          ecma_value_t context_type = VM_GET_CONTEXT_TYPE (stack_top_p[-1]);\n\n          if (!VM_CONTEXT_IS_FINALLY (context_type))\n          {\n            stack_top_p = vm_stack_context_abort (frame_ctx_p, stack_top_p);\n\n            JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n            continue;\n          }\n\n#if ENABLED (JERRY_ES2015)\n          if (stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV)\n          {\n            ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;\n            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);\n            frame_ctx_p->lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);\n            ecma_deref_object (lex_env_p);\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n\n          VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth,\n                              PARSER_TRY_CONTEXT_STACK_ALLOCATION);\n          stack_top_p -= PARSER_TRY_CONTEXT_STACK_ALLOCATION;\n\n          if (context_type == VM_CONTEXT_FINALLY_RETURN)\n          {\n            result = *stack_top_p;\n            goto error;\n          }\n\n          if (context_type == VM_CONTEXT_FINALLY_THROW)\n          {\n            jcontext_raise_exception (*stack_top_p);\n            result = ECMA_VALUE_ERROR;\n\n#if ENABLED (JERRY_DEBUGGER)\n            JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);\n#endif /* ENABLED (JERRY_DEBUGGER) */\n            goto error;\n          }\n\n          JERRY_ASSERT (context_type == VM_CONTEXT_FINALLY_JUMP);\n\n          uint32_t jump_target = *stack_top_p;\n\n          if (vm_stack_find_finally (frame_ctx_p,\n                                     &stack_top_p,\n                                     VM_CONTEXT_FINALLY_JUMP,\n                                     jump_target))\n          {\n            JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);\n            byte_code_p = frame_ctx_p->byte_code_p;\n            stack_top_p[-2] = jump_target;\n          }\n          else\n          {\n            byte_code_p = frame_ctx_p->byte_code_start_p + jump_target;\n          }\n\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n          continue;\n        }\n        case VM_OC_JUMP_AND_EXIT_CONTEXT:\n        {\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n          JERRY_ASSERT (!jcontext_has_pending_exception ());\n\n          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);\n\n          if (vm_stack_find_finally (frame_ctx_p,\n                                     &stack_top_p,\n                                     VM_CONTEXT_FINALLY_JUMP,\n                                     (uint32_t) branch_offset))\n          {\n            JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);\n            byte_code_p = frame_ctx_p->byte_code_p;\n            stack_top_p[-2] = (uint32_t) branch_offset;\n          }\n          else\n          {\n            byte_code_p = frame_ctx_p->byte_code_start_p + branch_offset;\n          }\n\n#if ENABLED (JERRY_ES2015)\n          if (jcontext_has_pending_exception ())\n          {\n            result = ECMA_VALUE_ERROR;\n            goto error;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n          continue;\n        }\n#if ENABLED (JERRY_DEBUGGER)\n        case VM_OC_BREAKPOINT_ENABLED:\n        {\n          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_IGNORE)\n          {\n            continue;\n          }\n\n          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);\n\n          JERRY_ASSERT (!(frame_ctx_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_DEBUGGER_IGNORE));\n\n          frame_ctx_p->byte_code_p = byte_code_start_p;\n\n          jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);\n          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)\n          {\n            result = ECMA_VALUE_ERROR;\n            goto error;\n          }\n          continue;\n        }\n        case VM_OC_BREAKPOINT_DISABLED:\n        {\n          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_IGNORE)\n          {\n            continue;\n          }\n\n          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);\n\n          JERRY_ASSERT (!(frame_ctx_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_DEBUGGER_IGNORE));\n\n          frame_ctx_p->byte_code_p = byte_code_start_p;\n\n          if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP)\n              && (JERRY_CONTEXT (debugger_stop_context) == NULL\n                  || JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p)))\n          {\n            jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);\n            if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)\n            {\n              result = ECMA_VALUE_ERROR;\n              goto error;\n            }\n            continue;\n          }\n\n          if (JERRY_CONTEXT (debugger_message_delay) > 0)\n          {\n            JERRY_CONTEXT (debugger_message_delay)--;\n            continue;\n          }\n\n          JERRY_CONTEXT (debugger_message_delay) = JERRY_DEBUGGER_MESSAGE_FREQUENCY;\n\n          if (jerry_debugger_receive (NULL))\n          {\n            continue;\n          }\n\n          if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP)\n              && (JERRY_CONTEXT (debugger_stop_context) == NULL\n                  || JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p)))\n          {\n            jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);\n            if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)\n            {\n              result = ECMA_VALUE_ERROR;\n              goto error;\n            }\n          }\n          continue;\n        }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n#if ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n        case VM_OC_RESOURCE_NAME:\n        {\n          frame_ctx_p->resource_name = ecma_op_resource_name (bytecode_header_p);\n          continue;\n        }\n#endif /* ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n#if ENABLED (JERRY_LINE_INFO)\n        case VM_OC_LINE:\n        {\n          uint32_t value = 0;\n          uint8_t byte;\n\n          do\n          {\n            byte = *byte_code_p++;\n            value = (value << 7) | (byte & CBC_LOWER_SEVEN_BIT_MASK);\n          }\n          while (byte & CBC_HIGHEST_BIT_MASK);\n\n          frame_ctx_p->current_line = value;\n          continue;\n        }\n#endif /* ENABLED (JERRY_LINE_INFO) */\n        case VM_OC_NONE:\n        default:\n        {\n          JERRY_ASSERT (VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_NONE);\n\n          jerry_fatal (ERR_DISABLED_BYTE_CODE);\n        }\n      }\n\n      JERRY_ASSERT (VM_OC_HAS_PUT_RESULT (opcode_data));\n\n      if (opcode_data & VM_OC_PUT_IDENT)\n      {\n        uint16_t literal_index;\n\n        READ_LITERAL_INDEX (literal_index);\n\n        if (literal_index < register_end)\n        {\n          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));\n          VM_GET_REGISTER (frame_ctx_p, literal_index) = result;\n\n          if (opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK))\n          {\n            result = ecma_fast_copy_value (result);\n          }\n        }\n        else\n        {\n          ecma_string_t *var_name_str_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n\n          ecma_value_t put_value_result = ecma_op_put_value_lex_env_base (frame_ctx_p->lex_env_p,\n                                                                          var_name_str_p,\n                                                                          is_strict,\n                                                                          result);\n\n          if (ECMA_IS_VALUE_ERROR (put_value_result))\n          {\n            ecma_free_value (result);\n            result = put_value_result;\n            goto error;\n          }\n\n          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))\n          {\n            ecma_fast_free_value (result);\n          }\n        }\n      }\n      else if (opcode_data & VM_OC_PUT_REFERENCE)\n      {\n        ecma_value_t property = *(--stack_top_p);\n        ecma_value_t object = *(--stack_top_p);\n\n        if (object == ECMA_VALUE_REGISTER_REF)\n        {\n          property = (ecma_value_t) ecma_get_integer_from_value (property);\n          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, property));\n          VM_GET_REGISTER (frame_ctx_p, property) = result;\n\n          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))\n          {\n            goto free_both_values;\n          }\n          result = ecma_fast_copy_value (result);\n        }\n        else\n        {\n          ecma_value_t set_value_result = vm_op_set_value (object,\n                                                           property,\n                                                           result,\n                                                           is_strict);\n\n          if (ECMA_IS_VALUE_ERROR (set_value_result))\n          {\n            ecma_free_value (result);\n            result = set_value_result;\n            goto error;\n          }\n\n          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))\n          {\n            ecma_fast_free_value (result);\n            goto free_both_values;\n          }\n        }\n      }\n\n      if (opcode_data & VM_OC_PUT_STACK)\n      {\n        *stack_top_p++ = result;\n      }\n      else if (opcode_data & VM_OC_PUT_BLOCK)\n      {\n        ecma_fast_free_value (frame_ctx_p->block_result);\n        frame_ctx_p->block_result = result;\n      }\n\nfree_both_values:\n      ecma_fast_free_value (right_value);\nfree_left_value:\n      ecma_fast_free_value (left_value);\n    }\n\nerror:\n    ecma_fast_free_value (left_value);\n    ecma_fast_free_value (right_value);\n\n    if (ECMA_IS_VALUE_ERROR (result))\n    {\n      JERRY_ASSERT (jcontext_has_pending_exception ());\n      ecma_value_t *stack_bottom_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;\n\n      while (stack_top_p > stack_bottom_p)\n      {\n        ecma_value_t stack_item = *(--stack_top_p);\n#if ENABLED (JERRY_ES2015)\n        if (stack_item == ECMA_VALUE_RELEASE_LEX_ENV)\n        {\n          opfunc_pop_lexical_environment (frame_ctx_p);\n          continue;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n        ecma_fast_free_value (stack_item);\n      }\n\n#if ENABLED (JERRY_DEBUGGER)\n      const uint32_t dont_stop = (JERRY_DEBUGGER_VM_IGNORE_EXCEPTION\n                                  | JERRY_DEBUGGER_VM_IGNORE\n                                  | JERRY_DEBUGGER_VM_EXCEPTION_THROWN);\n\n      if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n          && !(frame_ctx_p->bytecode_header_p->status_flags\n               & (CBC_CODE_FLAGS_DEBUGGER_IGNORE | CBC_CODE_FLAGS_STATIC_FUNCTION))\n          && !(JERRY_CONTEXT (debugger_flags) & dont_stop))\n      {\n        /* Save the error to a local value, because the engine enters breakpoint mode after,\n           therefore an evaluation error, or user-created error throw would overwrite it. */\n        ecma_value_t current_error_value = JERRY_CONTEXT (error_value);\n\n        if (jerry_debugger_send_exception_string (current_error_value))\n        {\n          jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_EXCEPTION_HIT);\n\n          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)\n          {\n            ecma_free_value (current_error_value);\n          }\n          else\n          {\n            JERRY_CONTEXT (error_value) = current_error_value;\n          }\n\n          JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);\n        }\n      }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n    }\n\n    JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n\n    if (frame_ctx_p->context_depth == 0)\n    {\n      /* In most cases there is no context. */\n\n      ecma_fast_free_value (frame_ctx_p->block_result);\n      frame_ctx_p->call_operation = VM_NO_EXEC_OP;\n      return result;\n    }\n\n    if (!ECMA_IS_VALUE_ERROR (result))\n    {\n      if (vm_stack_find_finally (frame_ctx_p,\n                                 &stack_top_p,\n                                 VM_CONTEXT_FINALLY_RETURN,\n                                 0))\n      {\n        JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);\n        JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n\n#if ENABLED (JERRY_ES2015)\n        if (jcontext_has_pending_exception ())\n        {\n          stack_top_p[-1] = (ecma_value_t) (stack_top_p[-1] - VM_CONTEXT_FINALLY_RETURN + VM_CONTEXT_FINALLY_THROW);\n          ecma_free_value (result);\n          result = jcontext_take_exception ();\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        byte_code_p = frame_ctx_p->byte_code_p;\n        stack_top_p[-2] = result;\n        continue;\n      }\n\n#if ENABLED (JERRY_ES2015)\n      if (jcontext_has_pending_exception ())\n      {\n        ecma_free_value (result);\n        result = ECMA_VALUE_ERROR;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n    }\n    else if (jcontext_has_pending_exception () && !jcontext_has_pending_abort ())\n    {\n      if (vm_stack_find_finally (frame_ctx_p,\n                                 &stack_top_p,\n                                 VM_CONTEXT_FINALLY_THROW,\n                                 0))\n      {\n        JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n        JERRY_ASSERT (!(stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV));\n\n#if ENABLED (JERRY_DEBUGGER)\n        JERRY_DEBUGGER_CLEAR_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n        result = jcontext_take_exception ();\n\n        byte_code_p = frame_ctx_p->byte_code_p;\n\n        if (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_THROW)\n        {\n          stack_top_p[-2] = result;\n          continue;\n        }\n\n        JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_CATCH);\n\n        *stack_top_p++ = result;\n        continue;\n      }\n    }\n    else\n    {\n      do\n      {\n        JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n\n        stack_top_p = vm_stack_context_abort (frame_ctx_p, stack_top_p);\n      }\n      while (frame_ctx_p->context_depth > 0);\n    }\n\n    ecma_free_value (frame_ctx_p->block_result);\n    frame_ctx_p->call_operation = VM_NO_EXEC_OP;\n\n    return result;\n  }\n}",
        "begin_line": 946,
        "end_line": 4012,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_op_get_value#57",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_op_get_value (ecma_value_t object, /**< base object */                  ecma_value_t property) /**< property name */",
        "snippet": "static ecma_value_t\nvm_op_get_value (ecma_value_t object, /**< base object */\n                 ecma_value_t property) /**< property name */\n{\n  if (ecma_is_value_object (object))\n  {\n    ecma_object_t *object_p = ecma_get_object_from_value (object);\n    ecma_string_t *property_name_p = NULL;\n\n    if (ecma_is_value_integer_number (property))\n    {\n      ecma_integer_value_t int_value = ecma_get_integer_from_value (property);\n\n      if (int_value >= 0 && int_value <= ECMA_DIRECT_STRING_MAX_IMM)\n      {\n        if (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_ARRAY)\n        {\n          ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n          if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)\n                            && (uint32_t) int_value < ext_object_p->u.array.length))\n          {\n            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);\n\n            if (JERRY_LIKELY (!ecma_is_value_array_hole (values_p[int_value])))\n            {\n              return ecma_fast_copy_value (values_p[int_value]);\n            }\n          }\n        }\n\n        property_name_p = (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_UINT,\n                                                                       (uintptr_t) int_value);\n      }\n    }\n    else if (ecma_is_value_string (property))\n    {\n      property_name_p = ecma_get_string_from_value (property);\n    }\n\n#if ENABLED (JERRY_ES2015)\n    if (ecma_is_value_symbol (property))\n    {\n      property_name_p = ecma_get_symbol_from_value (property);\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    if (property_name_p != NULL)\n    {\n#if ENABLED (JERRY_LCACHE)\n      ecma_property_t *property_p = ecma_lcache_lookup (object_p, property_name_p);\n\n      if (property_p != NULL &&\n          ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA)\n      {\n        return ecma_fast_copy_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);\n      }\n#endif /* ENABLED (JERRY_LCACHE) */\n\n      /* There is no need to free the name. */\n      return ecma_op_object_get (object_p, property_name_p);\n    }\n  }\n\n  if (JERRY_UNLIKELY (ecma_is_value_undefined (object) || ecma_is_value_null (object)))\n  {\n#if ENABLED (JERRY_ERROR_MESSAGES)\n    ecma_value_t error_value = ecma_raise_standard_error_with_format (ECMA_ERROR_TYPE,\n                                                                      \"Cannot read property '%' of %\",\n                                                                      property,\n                                                                      object);\n#else /* !ENABLED (JERRY_ERROR_MESSAGES) */\n    ecma_value_t error_value = ecma_raise_type_error (NULL);\n#endif /* ENABLED (JERRY_ERROR_MESSAGES) */\n    return error_value;\n  }\n\n  ecma_string_t *property_name_p = ecma_op_to_prop_name (property);\n\n  if (property_name_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_value_t get_value_result = ecma_op_get_value_object_base (object, property_name_p);\n\n  ecma_deref_ecma_string (property_name_p);\n  return get_value_result;\n}",
        "begin_line": 57,
        "end_line": 145,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_op_set_value#156",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_op_set_value (ecma_value_t object, /**< base object */                  ecma_value_t property, /**< property name */                  ecma_value_t value, /**< ecma value */                  bool is_strict) /**< strict mode */",
        "snippet": "static ecma_value_t\nvm_op_set_value (ecma_value_t object, /**< base object */\n                 ecma_value_t property, /**< property name */\n                 ecma_value_t value, /**< ecma value */\n                 bool is_strict) /**< strict mode */\n{\n  ecma_object_t * object_p;\n\n  if (JERRY_UNLIKELY (!ecma_is_value_object (object)))\n  {\n    ecma_value_t to_object = ecma_op_to_object (object);\n    ecma_free_value (object);\n\n    if (ECMA_IS_VALUE_ERROR (to_object))\n    {\n#if ENABLED (JERRY_ERROR_MESSAGES)\n      ecma_free_value (to_object);\n      jcontext_release_exception ();\n\n      ecma_value_t error_value = ecma_raise_standard_error_with_format (ECMA_ERROR_TYPE,\n                                                                        \"Cannot set property '%' of %\",\n                                                                        property,\n                                                                        object);\n      ecma_free_value (property);\n\n      return error_value;\n#else /* !ENABLED (JERRY_ERROR_MESSAGES) */\n      ecma_free_value (property);\n      return to_object;\n#endif /* ENABLED (JERRY_ERROR_MESSAGES) */\n    }\n\n    object_p = ecma_get_object_from_value (to_object);\n    ecma_op_ordinary_object_prevent_extensions (object_p);\n  }\n  else\n  {\n    object_p = ecma_get_object_from_value (object);\n  }\n\n  ecma_string_t *property_p;\n\n  if (!ecma_is_value_prop_name (property))\n  {\n    property_p = ecma_op_to_prop_name (property);\n    ecma_fast_free_value (property);\n\n    if (JERRY_UNLIKELY (property_p == NULL))\n    {\n      ecma_deref_object (object_p);\n      return ECMA_VALUE_ERROR;\n    }\n  }\n  else\n  {\n    property_p = ecma_get_prop_name_from_value (property);\n  }\n\n  ecma_value_t completion_value = ECMA_VALUE_EMPTY;\n\n  if (!ecma_is_lexical_environment (object_p))\n  {\n    completion_value = ecma_op_object_put (object_p,\n                                           property_p,\n                                           value,\n                                           is_strict);\n  }\n  else\n  {\n    completion_value = ecma_op_set_mutable_binding (object_p,\n                                                    property_p,\n                                                    value,\n                                                    is_strict);\n  }\n\n  ecma_deref_object (object_p);\n  ecma_deref_ecma_string (property_p);\n\n  return completion_value;\n}",
        "begin_line": 156,
        "end_line": 235,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_run#4198",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_run (const ecma_compiled_code_t *bytecode_header_p, /**< byte-code data header */         ecma_value_t this_binding_value, /**< value of 'ThisBinding' */         ecma_object_t *lex_env_p, /**< lexical environment to use */         const ecma_value_t *arg_list_p, /**< arguments list */         ecma_length_t arg_list_len) /**< length of arguments list */",
        "snippet": "ecma_value_t\nvm_run (const ecma_compiled_code_t *bytecode_header_p, /**< byte-code data header */\n        ecma_value_t this_binding_value, /**< value of 'ThisBinding' */\n        ecma_object_t *lex_env_p, /**< lexical environment to use */\n        const ecma_value_t *arg_list_p, /**< arguments list */\n        ecma_length_t arg_list_len) /**< length of arguments list */\n{\n  vm_frame_ctx_t *frame_ctx_p;\n  size_t frame_size;\n\n  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n  {\n    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;\n    frame_size = (size_t) (args_p->register_end + args_p->stack_limit);\n  }\n  else\n  {\n    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;\n    frame_size = (size_t) (args_p->register_end + args_p->stack_limit);\n  }\n\n  frame_size = frame_size * sizeof (ecma_value_t) + sizeof (vm_frame_ctx_t);\n  frame_size = (frame_size + sizeof (uintptr_t) - 1) / sizeof (uintptr_t);\n\n  /* Use JERRY_MAX() to avoid array declaration with size 0. */\n  JERRY_VLA (uintptr_t, stack, frame_size);\n\n  frame_ctx_p = (vm_frame_ctx_t *) stack;\n\n  frame_ctx_p->bytecode_header_p = bytecode_header_p;\n  frame_ctx_p->lex_env_p = lex_env_p;\n  frame_ctx_p->this_binding = this_binding_value;\n\n  vm_init_exec (frame_ctx_p, arg_list_p, arg_list_len);\n  return vm_execute (frame_ctx_p);\n}",
        "begin_line": 4198,
        "end_line": 4233,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_run_global#286",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_run_global (const ecma_compiled_code_t *bytecode_p) /**< pointer to bytecode to run */",
        "snippet": "ecma_value_t\nvm_run_global (const ecma_compiled_code_t *bytecode_p) /**< pointer to bytecode to run */\n{\n  ecma_object_t *glob_obj_p = ecma_builtin_get_global ();\n\n#if ENABLED (JERRY_ES2015)\n  if (bytecode_p->status_flags & CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED)\n  {\n    ecma_create_global_lexical_block ();\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  ecma_object_t *const global_scope_p = ecma_get_global_scope ();\n\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n  if (JERRY_CONTEXT (module_top_context_p) != NULL)\n  {\n    JERRY_ASSERT (JERRY_CONTEXT (module_top_context_p)->parent_p == NULL);\n    ecma_module_t *module_p = JERRY_CONTEXT (module_top_context_p)->module_p;\n\n    JERRY_ASSERT (module_p->scope_p == NULL);\n    ecma_ref_object (global_scope_p);\n    module_p->scope_p = global_scope_p;\n\n    const ecma_value_t module_init_result = ecma_module_initialize_current ();\n    ecma_module_cleanup ();\n    JERRY_CONTEXT (module_top_context_p) = NULL;\n\n    if (ECMA_IS_VALUE_ERROR (module_init_result))\n    {\n      return module_init_result;\n    }\n  }\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n  return vm_run (bytecode_p,\n                 ecma_make_object_value (glob_obj_p),\n                 global_scope_p,\n                 NULL,\n                 0);\n}",
        "begin_line": 286,
        "end_line": 326,
        "is_bug": false
    }
]