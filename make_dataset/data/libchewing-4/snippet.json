[
    {
        "name": "chewing-sql.ConfigDatabase#303",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.ConfigDatabase(ChewingData *pgdata)",
        "snippet": "static int ConfigDatabase(ChewingData *pgdata)\n{\n\tint ret;\n\n\tassert(pgdata);\n\tassert(pgdata->static_data.db);\n\n\tret = sqlite3_exec(pgdata->static_data.db, \"PRAGMA synchronous=OFF\", NULL, NULL, NULL);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"Cannot set synchronous=OFF, error = %d\", ret);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
        "begin_line": 303,
        "end_line": 317,
        "is_bug": false
    },
    {
        "name": "chewing-sql.CreateStmt#319",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.CreateStmt(ChewingData *pgdata)",
        "snippet": "static int CreateStmt(ChewingData *pgdata)\n{\n\tint i;\n\tint ret;\n\n\tassert(pgdata);\n\n\tSTATIC_ASSERT(ARRAY_SIZE(SQL_STMT_CONFIG) == ARRAY_SIZE(pgdata->static_data.stmt_config));\n\tSTATIC_ASSERT(ARRAY_SIZE(SQL_STMT_USERPHRASE) == ARRAY_SIZE(pgdata->static_data.stmt_userphrase))\n\n\tfor (i = 0; i < ARRAY_SIZE(SQL_STMT_CONFIG); ++i) {\n\t\tret = sqlite3_prepare_v2(pgdata->static_data.db,\n\t\t\tSQL_STMT_CONFIG[i].stmt, -1,\n\t\t\t&pgdata->static_data.stmt_config[i], NULL);\n\t\tif (ret != SQLITE_OK) {\n\t\t\tLOG_ERROR(\"Cannot create stmt %s\", SQL_STMT_CONFIG[i].stmt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(SQL_STMT_USERPHRASE); ++i) {\n\t\tret = sqlite3_prepare_v2(pgdata->static_data.db,\n\t\t\tSQL_STMT_USERPHRASE[i].stmt, -1,\n\t\t\t&pgdata->static_data.stmt_userphrase[i], NULL);\n\t\tif (ret != SQLITE_OK) {\n\t\t\tLOG_ERROR(\"Cannot create stmt %s\", SQL_STMT_USERPHRASE[i].stmt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "begin_line": 319,
        "end_line": 350,
        "is_bug": false
    },
    {
        "name": "chewing-sql.CreateTable#119",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.CreateTable(ChewingData *pgdata)",
        "snippet": "static int CreateTable(ChewingData *pgdata)\n{\n\tint ret;\n\n\tSTATIC_ASSERT(MAX_PHRASE_LEN == 11);\n\n\tret = sqlite3_exec(pgdata->static_data.db,\n\t\t\"CREATE TABLE IF NOT EXISTS userphrase_v1 (\"\n\t\t\"time INTEGER,\"\n\t\t\"user_freq INTEGER,\"\n\t\t\"max_freq INTEGER,\"\n\t\t\"orig_freq INTEGER,\"\n\t\t\"length INTEGER,\"\n\t\t\"phone_0 INTEGER,\"\n\t\t\"phone_1 INTEGER,\"\n\t\t\"phone_2 INTEGER,\"\n\t\t\"phone_3 INTEGER,\"\n\t\t\"phone_4 INTEGER,\"\n\t\t\"phone_5 INTEGER,\"\n\t\t\"phone_6 INTEGER,\"\n\t\t\"phone_7 INTEGER,\"\n\t\t\"phone_8 INTEGER,\"\n\t\t\"phone_9 INTEGER,\"\n\t\t\"phone_10 INTEGER,\"\n\t\t\"phrase TEXT,\"\n\t\t\"PRIMARY KEY (\"\n\t\t\t\"phone_0,\"\n\t\t\t\"phone_1,\"\n\t\t\t\"phone_2,\"\n\t\t\t\"phone_3,\"\n\t\t\t\"phone_4,\"\n\t\t\t\"phone_5,\"\n\t\t\t\"phone_6,\"\n\t\t\t\"phone_7,\"\n\t\t\t\"phone_8,\"\n\t\t\t\"phone_9,\"\n\t\t\t\"phone_10,\"\n\t\t\t\"phrase)\"\n\t\t\")\",\n\t\tNULL, NULL, NULL );\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"Cannot create table userphrase_v1, error = %d\", ret);\n\t\treturn -1;\n\t}\n\n\tret = sqlite3_exec(pgdata->static_data.db,\n\t\t\"CREATE TABLE IF NOT EXISTS config_v1 (\"\n\t\t\"id INTEGER,\"\n\t\t\"value INTEGER,\"\n\t\t\"PRIMARY KEY (id)\"\n\t\t\")\",\n\t\tNULL, NULL, NULL);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"Cannot create table config_v1, error = %d\", ret);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
        "begin_line": 119,
        "end_line": 177,
        "is_bug": false
    },
    {
        "name": "chewing-sql.GetSQLiteInstance#100",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.GetSQLiteInstance(ChewingData *pgdata, const char *path)",
        "snippet": "static sqlite3 *GetSQLiteInstance(ChewingData *pgdata, const char *path)\n{\n\tint ret;\n\tsqlite3 *db = NULL;\n\n\tassert(pgdata);\n\tassert(path);\n\n\tret = sqlite3_open(path, &db);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"sqlite3_open returns %d\", ret);\n\t\tgoto end;\n\t}\n\nend:\n\treturn db;\n}",
        "begin_line": 100,
        "end_line": 116,
        "is_bug": false
    },
    {
        "name": "chewing-sql.InitUserphrase#450",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.InitUserphrase(ChewingData *pgdata, const char *path)",
        "snippet": "int InitUserphrase(ChewingData *pgdata, const char *path)\n{\n\tint ret;\n\n\tassert(!pgdata->static_data.db);\n\tassert(path);\n\n\tpgdata->static_data.db = GetSQLiteInstance(pgdata, path);\n\tif (!pgdata->static_data.db) {\n\t\tLOG_ERROR(\"GetSQLiteInstance fails\");\n\t\tgoto error;\n\t}\n\n\tret = ConfigDatabase(pgdata);\n\tif (ret) {\n\t\tLOG_ERROR(\"ConfigDatabase returns %d\", ret);\n\t\tgoto error;\n\t}\n\n\tret = CreateTable(pgdata);\n\tif (ret) {\n\t\tLOG_ERROR(\"CreateTable returns %d\", ret);\n\t\tgoto error;\n\t}\n\n\tret = CreateStmt(pgdata);\n\tif (ret) {\n\t\tLOG_ERROR(\"CreateStmt returns %d\", ret);\n\t\tgoto error;\n\t}\n\n\tret = SetupUserphraseLifeTime(pgdata);\n\tif (ret) {\n\t\tLOG_ERROR(\"SetupUserphraseLiftTime returns %d\", ret);\n\t\tgoto error;\n\t}\n\n\t/* FIXME: Normalize lifttime when necessary. */\n\n\tMigrateOldFormat(pgdata, path);\n\n\treturn 0;\n\nerror:\n\tTerminateUserphrase(pgdata);\n\treturn -1;\n}",
        "begin_line": 450,
        "end_line": 496,
        "is_bug": false
    },
    {
        "name": "chewing-sql.MigrateOldFormat#352",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.MigrateOldFormat(ChewingData *pgdata, const char *path)",
        "snippet": "static void MigrateOldFormat(ChewingData *pgdata, const char *path)\n{\n\tchar *uhash;\n\tchar *old_uhash;\n\tFILE *fd = NULL;\n\tchar buf[HASH_FIELD_SIZE];\n\tuint16_t phoneSeq[MAX_PHRASE_LEN + 1];\n\tchar *pos;\n\tint len;\n\tint i;\n\tint ret;\n\n\tassert(pgdata);\n\tassert(path);\n\n\tlen = strlen(path) + 1 + strlen(HASH_NAME) + 1;\n\tuhash = calloc(sizeof(*uhash), len);\n\tif (!uhash) {\n\t\tLOG_ERROR(\"calloc returns %#p\", uhash);\n\t\texit(-1);\n\t}\n\tsnprintf(uhash, len, \"%s\" PLAT_SEPARATOR \"%s\", path, HASH_NAME);\n\n\tlen = strlen(path) + 1 + strlen(HASH_OLD_NAME) + 1;\n\told_uhash = calloc(sizeof(*old_uhash), len);\n\tif (!old_uhash) {\n\t\tLOG_ERROR(\"calloc returns %#p\", old_uhash);\n\t\texit(-1);\n\t}\n\tsnprintf(old_uhash, len, \"%s\" PLAT_SEPARATOR \"%s\", path, HASH_OLD_NAME);\n\n\t/*\n\t * The binary format is described as following:\n\t *\n\t * 0 ~ 3                signature (CBiH)\n\t * 4 ~ 7                lifttime, platform endianness\n\t * 8 ~ 8 + 125 * n      array of hash item, 125 bytes each\n\t *\n\t * 0 ~ 3                user frequency, platform endianness\n\t * 4 ~ 7                recent time, platform endianness\n\t * 8 ~ 11               max frequency, platform endianness\n\t * 12 ~ 15              original frequency, platform endianness\n\t * 16                   phone length\n\t * 17 ~ 17 + 2 * n      phone sequence, uint16_t, platform endianness\n\t * 17 + 2 * n + 1       phrase length in bytes\n\t * 17 + 2 * n + 2 ~ y   phrase in UTF-8\n\t *\n\t */\n\n\tfd = fopen(uhash, \"r\");\n\tif (!fd) goto end;\n\n\tLOG_INFO(\"Migrate old format from %s\", uhash);\n\tret = fread(buf, 4, 1, fd);\n\tif (ret != 1) {\n\t\tLOG_WARN(\"fread returns %d\", ret);\n\t\tgoto end_remove_hash;\n\t}\n\n\tif (memcmp(buf, HASH_SIGS, 4) != 0) {\n\t\tLOG_WARN(\"signature is not %d\", HASH_SIGS);\n\t\tgoto end_remove_hash;\n\t}\n\n\tret = fseek(fd, 8, SEEK_SET);\n\tif (ret) {\n\t\tLOG_WARN(\"fseek returns %d\", ret);\n\t\tgoto end_remove_hash;\n\t}\n\n\twhile (fread(buf, HASH_FIELD_SIZE, 1, fd) == 1) {\n\t\tpos = &buf[HASH_LENGTH_OFFSET];\n\t\tlen = *pos;\n\t\t++pos;\n\n\t\tif (len > MAX_PHRASE_LEN || len < 1) {\n\t\t\tLOG_WARN(\"skip field due to len = %d\", len);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tphoneSeq[i] = GetUint16PreservedEndian(pos);\n\t\t\tpos += 2;\n\t\t}\n\t\tphoneSeq[len] = 0;\n\n\t\t++pos;\n\t\tUserUpdatePhrase(pgdata, phoneSeq, pos);\n\t}\n\nend_remove_hash:\n\tif (fd) fclose(fd);\n\tPLAT_RENAME(uhash, old_uhash);\nend:\n\tfree(old_uhash);\n\tfree(uhash);\n}",
        "begin_line": 352,
        "end_line": 448,
        "is_bug": false
    },
    {
        "name": "chewing-sql.SetupUserphraseLifeTime#179",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.SetupUserphraseLifeTime(ChewingData *pgdata)",
        "snippet": "static int SetupUserphraseLifeTime(ChewingData *pgdata)\n{\n\tint ret;\n\n\tassert(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT]);\n\n\tret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT],\n\t\tBIND_CONFIG_ID, CONFIG_ID_LIFETIME);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"Cannot bind ?%d to %d in stmt %s, error = %d\",\n\t\t\tBIND_CONFIG_ID, CONFIG_ID_LIFETIME,\n\t\t\tSQL_STMT_CONFIG[STMT_CONFIG_INSERT].stmt, ret);\n\t\treturn -1;\n\t}\n\n\tret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT],\n\t\tBIND_CONFIG_VALUE, 0);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"Cannot bind ?%d to %d in stmt %s, error = %d\",\n\t\t\tBIND_CONFIG_VALUE, 0,\n\t\t\tSQL_STMT_CONFIG[STMT_CONFIG_INSERT].stmt, ret);\n\t\treturn -1;\n\t}\n\n\tret = sqlite3_step(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT]);\n\tif (ret != SQLITE_DONE) {\n\t\tLOG_ERROR(\"sqlite3_step returns %d\", ret);\n\t\treturn -1;\n\t}\n\n\tret = sqlite3_reset(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT]);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"sqlite3_reset returns %d\", ret);\n\t\treturn -1;\n\t}\n\n\tassert(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT]);\n\n\tret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT],\n\t\tBIND_CONFIG_ID, CONFIG_ID_LIFETIME);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"Cannot bind ?%d to %d in stmt %s, error = %d\",\n\t\t\tBIND_CONFIG_ID, CONFIG_ID_LIFETIME,\n\t\t\tSQL_STMT_CONFIG[STMT_CONFIG_SELECT].stmt, ret);\n\t\treturn -1;\n\t}\n\n\tret = sqlite3_step(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT]);\n\tif (ret != SQLITE_ROW) {\n\t\tLOG_ERROR(\"sqlite3_step returns %d\", ret);\n\t\treturn -1;\n\t}\n\n\tpgdata->static_data.original_lifetime = sqlite3_column_int(\n\t\tpgdata->static_data.stmt_config[STMT_CONFIG_SELECT],\n\t\tSQL_STMT_CONFIG[STMT_CONFIG_SELECT].column[COLUMN_CONFIG_VALUE]);\n\tpgdata->static_data.new_lifetime = pgdata->static_data.original_lifetime;\n\n\tret = sqlite3_reset(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT]);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"sqlite3_reset returns %d\", ret);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
        "begin_line": 179,
        "end_line": 244,
        "is_bug": false
    },
    {
        "name": "chewing-sql.TerminateUserphrase#498",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.TerminateUserphrase(ChewingData *pgdata)",
        "snippet": "void TerminateUserphrase(ChewingData *pgdata)\n{\n\tint i;\n\tint ret;\n\n\tUpdateLifeTime(pgdata);\n\n\tfor (i = 0; i < ARRAY_SIZE(pgdata->static_data.stmt_config); ++i) {\n\t\tsqlite3_finalize(pgdata->static_data.stmt_config[i]);\n\t\tpgdata->static_data.stmt_config[i] = NULL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(pgdata->static_data.stmt_userphrase); ++i) {\n\t\tsqlite3_finalize(pgdata->static_data.stmt_userphrase[i]);\n\t\tpgdata->static_data.stmt_userphrase[i] = NULL;\n\t}\n\n\tret = sqlite3_close(pgdata->static_data.db);\n\tassert(SQLITE_OK == ret);\n\tpgdata->static_data.db = NULL;\n}",
        "begin_line": 498,
        "end_line": 518,
        "is_bug": false
    },
    {
        "name": "chewing-sql.UpdateLifeTime#246",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.UpdateLifeTime(ChewingData *pgdata)",
        "snippet": "static int UpdateLifeTime(ChewingData *pgdata)\n{\n\tint ret;\n\tint result = 0;\n\n\tif (!pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE]) {\n\t\tLOG_ERROR(\"pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE] is NULL\");\n\t\tresult = -1;\n\t\tgoto end;\n\t}\n\n\tret = sqlite3_clear_bindings(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE]);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"sqlite3_clear_bindings returns %d\", ret);\n\t\tresult = -1;\n\t\tgoto end;\n\t}\n\n\tret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE],\n\t\tBIND_CONFIG_ID, CONFIG_ID_LIFETIME);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"Cannot bind ?%d to %d in stmt %s, error = %d\",\n\t\t\tBIND_CONFIG_ID, CONFIG_ID_LIFETIME,\n\t\t\tSQL_STMT_CONFIG[STMT_CONFIG_INCREASE].stmt, ret);\n\t\tresult = -1;\n\t\tgoto end;\n\t}\n\n\tret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE],\n\t\tBIND_CONFIG_VALUE,\n\t\tpgdata->static_data.new_lifetime - pgdata->static_data.original_lifetime);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"Cannot bind ?%d to %d in stmt %s, error = %d\",\n\t\t\tBIND_CONFIG_VALUE,\n\t\t\tpgdata->static_data.new_lifetime - pgdata->static_data.original_lifetime,\n\t\t\tSQL_STMT_CONFIG[STMT_CONFIG_INCREASE].stmt, ret);\n\t\tresult = -1;\n\t\tgoto end;\n\t}\n\n\tret = sqlite3_step(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE]);\n\tif (ret != SQLITE_DONE) {\n\t\tLOG_ERROR(\"sqlite3_step returns %d\", ret);\n\t\tresult = -1;\n\t\tgoto end;\n\t}\n\nend:\n\tret = sqlite3_reset(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE]);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"sqlite3_reset returns %d\", ret);\n\t\tresult = -1;\n\t}\n\n\treturn result;\n}",
        "begin_line": 246,
        "end_line": 301,
        "is_bug": false
    },
    {
        "name": "chewingio.CheckAndResetRange#802",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.CheckAndResetRange( ChewingData *pgdata )",
        "snippet": "static void CheckAndResetRange( ChewingData *pgdata )\n{\n\tif ( pgdata->PointStart > -1 ) {\n\t\tpgdata->PointStart = -1;\n\t\tpgdata->PointEnd = 0;\n\t}\n}",
        "begin_line": 802,
        "end_line": 808,
        "is_bug": false
    },
    {
        "name": "chewingio.DoSelect#842",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.DoSelect( ChewingData *pgdata, int num )",
        "snippet": "static void DoSelect( ChewingData *pgdata, int num )\n{\n\tassert( pgdata->choiceInfo.pageNo >= 0 );\n\tif ( num >= 0 ) {\n\t\tnum += pgdata->choiceInfo.pageNo * pgdata->choiceInfo.nChoicePerPage;\n\t\tSelectCandidate( pgdata, num );\n\t}\n}",
        "begin_line": 842,
        "end_line": 849,
        "is_bug": false
    },
    {
        "name": "chewingio.NullLogger#152",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.NullLogger( void *data UNUSED, int level UNUSED, const char *fmt UNUSED, ...)",
        "snippet": "static void NullLogger( void *data UNUSED, int level UNUSED, const char *fmt UNUSED, ...)\n{\n}",
        "begin_line": 152,
        "end_line": 154,
        "is_bug": false
    },
    {
        "name": "chewingio.SelectCandidate#810",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.SelectCandidate( ChewingData *pgdata, int num )",
        "snippet": "static int SelectCandidate( ChewingData *pgdata, int num )\n{\n\tassert( pgdata );\n\tassert( pgdata->choiceInfo.pageNo >= 0 );\n\n\tif ( 0 <= num && num < pgdata->choiceInfo.nTotalChoice ) {\n\t\tif ( pgdata->choiceInfo.isSymbol != WORD_CHOICE ) {\n\t\t\tSymbolChoice( pgdata, num );\n\t\t}\n\t\telse {\n\t\t\t/* change the select interval & selectStr & nSelect */\n\t\t\tAddSelect( pgdata, num );\n\t\t\t/* second, call choice module */\n\t\t\tChoiceSelect( pgdata, num );\n\t\t\t/* automatically shift the cursor to next phrase */\n\t\t\tif ( pgdata->config.bAutoShiftCur != 0 &&\n\t\t\t     /* if cursor at end of string, do not shift the cursor. */\n\t\t\t     pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen ) {\n\t\t\t\tif ( pgdata->config.bPhraseChoiceRearward ) {\n\t\t\t\t\t++pgdata->chiSymbolCursor;\n\t\t\t\t} else {\n\t\t\t\t\tpgdata->chiSymbolCursor +=\n\t\t\t\t\t\tpgdata->availInfo.avail[ pgdata->availInfo.currentAvail ].len;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}",
        "begin_line": 810,
        "end_line": 840,
        "is_bug": false
    },
    {
        "name": "chewingio.allocate_ChewingData#156",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.allocate_ChewingData( \tvoid (*logger)( void *data, int level, const char *fmt, ... ), void *loggerdata )",
        "snippet": "static ChewingData * allocate_ChewingData(\n\tvoid (*logger)( void *data, int level, const char *fmt, ... ),\n\tvoid *loggerdata\n)\n{\n\tstatic const int DEFAULT_SELKEY[] = { '1', '2', '3', '4', '5', '6', '7', '8', '9', '0' };\n\n\tChewingData *data = ALC( ChewingData, 1 );\n\tif ( data ) {\n\t\tdata->config.candPerPage = MAX_SELKEY;\n\t\tdata->config.maxChiSymbolLen = MAX_CHI_SYMBOL_LEN;\n\t\tdata->logger = logger;\n\t\tdata->loggerData = loggerdata;\n\t\tmemcpy( data->config.selKey, DEFAULT_SELKEY, sizeof( data->config.selKey ) );\n\t}\n\n\treturn data;\n}",
        "begin_line": 156,
        "end_line": 173,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_Reset#317",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_Reset( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_Reset( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\tChewingStaticData static_data;\n\tChewingConfigData old_config;\n\tvoid (*logger)( void *data, int level, const char *fmt, ...);\n\tvoid *loggerData;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\t/* Backup old config and restore it after clearing pgdata structure. */\n\told_config = pgdata->config;\n\tstatic_data = pgdata->static_data;\n\tlogger = pgdata->logger;\n\tloggerData = pgdata->loggerData;\n\tmemset( pgdata, 0, sizeof( ChewingData ) );\n\tpgdata->config = old_config;\n\tpgdata->static_data = static_data;\n\tpgdata->logger = logger;\n\tpgdata->loggerData = loggerData;\n\n\t/* zuinData */\n\tmemset( &( pgdata->zuinData ), 0, sizeof( ZuinData ) );\n\n\t/* choiceInfo */\n\tmemset( &( pgdata->choiceInfo ), 0, sizeof( ChoiceInfo ) );\n\n\tpgdata->chiSymbolCursor = 0;\n\tpgdata->chiSymbolBufLen = 0;\n\tpgdata->nPhoneSeq = 0;\n\tmemset( pgdata->bUserArrCnnct, 0, sizeof( int ) * ( MAX_PHONE_SEQ_LEN + 1 ) );\n\tmemset( pgdata->bUserArrBrkpt, 0, sizeof( int ) * ( MAX_PHONE_SEQ_LEN + 1 ) );\n\tpgdata->bChiSym = CHINESE_MODE;\n\tpgdata->bFullShape = HALFSHAPE_MODE;\n\tpgdata->bSelect = 0;\n\tpgdata->nSelect = 0;\n\tpgdata->PointStart = -1;\n\tpgdata->PointEnd = 0;\n\tpgdata->phrOut.nNumCut = 0;\n\treturn 0;\n}",
        "begin_line": 317,
        "end_line": 362,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_cand_close#2304",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_cand_close( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_cand_close( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\tif ( ctx->data->bSelect ) {\n\t\tChoiceEndChoice( ctx->data );\n\t}\n\n\treturn 0;\n\n}",
        "begin_line": 2304,
        "end_line": 2320,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_cand_string_by_index_static#2236",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_cand_string_by_index_static( ChewingContext *ctx, int index )",
        "snippet": "CHEWING_API const char *chewing_cand_string_by_index_static( ChewingContext *ctx, int index )\n{\n\tChewingData *pgdata;\n\tchar *s;\n\n\tif ( !ctx ) {\n\t\treturn NULL;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API(\"index = %d\", index);\n\n\tif ( 0 <= index && index < ctx->output->pci->nTotalChoice ) {\n\t\ts = ctx->output->pci->totalChoiceStr[ index ];\n\t} else {\n\t\ts = \"\";\n\t}\n\treturn s;\n}",
        "begin_line": 2236,
        "end_line": 2254,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_delete#416",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_delete( ChewingContext *ctx )",
        "snippet": "CHEWING_API void chewing_delete( ChewingContext *ctx )\n{\n\tif ( ctx ) {\n\t\tif ( ctx->data ) {\n\t\t\tTerminatePinyin( ctx->data );\n\t\t\tTerminateEasySymbolTable( ctx->data );\n\t\t\tTerminateSymbolTable( ctx->data );\n\t\t\tTerminateUserphrase( ctx->data );\n\t\t\tTerminateTree( ctx->data );\n\t\t\tTerminateDict( ctx->data );\n\t\t\tfree( ctx->data );\n\t\t}\n\n\t\tif ( ctx->output )\n\t\t\tfree( ctx->output);\n\t\tfree( ctx );\n\t}\n\treturn;\n}",
        "begin_line": 416,
        "end_line": 434,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_free#436",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_free( void *p )",
        "snippet": "CHEWING_API void chewing_free( void *p )\n{\n\tfree( p );\n}",
        "begin_line": 436,
        "end_line": 439,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_get_ChiEngMode#759",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_get_ChiEngMode( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_get_ChiEngMode( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API( \"bChiSym = %d\", ctx->data->bChiSym );\n\n\treturn ctx->data->bChiSym;\n}",
        "begin_line": 759,
        "end_line": 771,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_get_phoneSeq#1928",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_get_phoneSeq( ChewingContext *ctx )",
        "snippet": "CHEWING_API unsigned short *chewing_get_phoneSeq( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\tuint16_t *seq;\n\n\tif ( !ctx ) {\n\t\treturn NULL;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\tseq = ALC( uint16_t, ctx->data->nPhoneSeq );\n\tif ( seq )\n\t\tmemcpy( seq, ctx->data->phoneSeq, sizeof(uint16_t)*ctx->data->nPhoneSeq );\n\treturn seq;\n}",
        "begin_line": 1928,
        "end_line": 1944,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_get_phoneSeqLen#1946",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_get_phoneSeqLen( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_get_phoneSeqLen( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API(\"nPhoneSeq = %d\", ctx->data->nPhoneSeq);\n\n\treturn ctx->data->nPhoneSeq;\n}",
        "begin_line": 1946,
        "end_line": 1958,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Backspace#1022",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Backspace( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Backspace( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\tChewingOutput *pgo;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\tpgo = ctx->output;\n\n\tLOG_API();\n\n\tpgdata = ctx->data;\n\tpgo = ctx->output;\n\n\tCheckAndResetRange( pgdata );\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\n\tif ( ! pgdata->bSelect ) {\n\t\tif ( ZuinIsEntering( &( pgdata->zuinData ) ) ) {\n\t\t\tZuinRemoveLast( &( pgdata->zuinData ) );\n\t\t}\n\t\telse if ( pgdata->chiSymbolCursor > 0 ) {\n\t\t\tChewingKillChar(\n\t\t\t\tpgdata,\n\t\t\t\tpgdata->chiSymbolCursor - 1,\n\t\t\t\tDECREASE_CURSOR );\n\t\t}\n\t\tCallPhrasing( pgdata, 0 );\n\t}\n\telse if ( pgdata->bSelect ) {\n\t\tchewing_cand_close( ctx );\n\t}\n\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 1022,
        "end_line": 1063,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Capslock#1371",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Capslock( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Capslock( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\tChewingOutput *pgo;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\tpgo = ctx->output;\n\n\tLOG_API();\n\n\tchewing_set_ChiEngMode( ctx, 1 - chewing_get_ChiEngMode(ctx) );\n\tMakeOutputWithRtn( pgo, pgdata, KEYSTROKE_ABSORB );\n\treturn 0;\n}",
        "begin_line": 1371,
        "end_line": 1387,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Default#1536",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Default( ChewingContext *ctx, int key )",
        "snippet": "CHEWING_API int chewing_handle_Default( ChewingContext *ctx, int key )\n{\n\tChewingData *pgdata;\n\tChewingOutput *pgo;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\tint rtn;\n\tint num;\n\tint bQuickCommit = 0;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\tpgo = ctx->output;\n\n\tLOG_API( \"key = %d\", key );\n\n\t/* Update lifetime */\n\tIncreaseLifeTime( ctx->data );\n\n\t/* Skip the special key */\n\tif ( key & 0xFF00 ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t\tgoto End_KeyDefault;\n\t}\n\n\t/* We ignore non-printable input */\n\tif ( ! isprint( key ) )\n\t\tgoto End_KeyDefault;\n\n\tCheckAndResetRange( pgdata );\n\n\tDEBUG_CHECKPOINT();\n\tDEBUG_OUT( \"   key=%d\", key );\n\n\t/* Dvorak Hsu */\n\tif ( pgdata->zuinData.kbtype == KB_DVORAK_HSU ) {\n\t\tkey = dvorak_convert( key );\n\t}\n\n\t/* selecting */\n\tif ( pgdata->bSelect ) {\n\t\tif ( key == ' ' )\n\t\t\treturn chewing_handle_Right( ctx );\n\t\t/* num starts from 0 */\n\t\tnum = CountSelKeyNum( key, pgdata );\n\t\tif ( num >= 0 ) {\n\t\t\tDoSelect( pgdata, num );\n\t\t\tgoto End_keyproc;\n\t\t}\n\n\t\t/* Otherwise, use 'j' and 'k' for paging in selection mode */\n\t\tDEBUG_OUT(\n\t\t\t\"\\t\\tchecking paging key, got '%c'\\n\",\n\t\t\tkey );\n\t\tswitch ( key ) {\n\t\t\tcase 'j':\n\t\t\tcase 'J':\n\t\t\t\tif ( pgdata->chiSymbolCursor > 0 ) {\n\t\t\t\t\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\t\t\t\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t\t\t\t\t}\n\t\t\t\t\tCheckAndResetRange( pgdata );\n\t\t\t\t\tpgdata->chiSymbolCursor--;\n\t\t\t\t\tif ( ChewingIsChiAt( pgdata->chiSymbolCursor, pgdata ) )\n\t\t\t\t\t\tChoiceInitAvail( pgdata );\n\t\t\t\t\telse\n\t\t\t\t\t\tOpenSymbolChoice( pgdata );\n\n\t\t\t\t}\n\t\t\t\tgoto End_Paging;\n\t\t\tcase 'k':\n\t\t\tcase 'K':\n\t\t\t\tif ( pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen ) {\n\t\t\t\t\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\t\t\t\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t\t\t\t\t}\n\t\t\t\t\tCheckAndResetRange( pgdata );\n\t\t\t\t\tpgdata->chiSymbolCursor++;\n\t\t\t\t\tif ( ChewingIsChiAt( pgdata->chiSymbolCursor, pgdata ) )\n\t\t\t\t\t\tChoiceInitAvail( pgdata );\n\t\t\t\t\telse\n\t\t\t\t\t\tOpenSymbolChoice( pgdata );\n\t\t\t\t}\n\t\t\t\tgoto End_Paging;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* editing */\n\telse {\n\t\tif ( pgdata->bChiSym == CHINESE_MODE ) {\n\t\t\tif ( pgdata->config.bEasySymbolInput != 0 ) {\n\t\t\t\tEasySymbolInput( key, pgdata );\n\t\t\t\tgoto End_keyproc;\n\t\t\t}\n\n\t\t\trtn = ZuinPhoInput( pgdata, key );\n\t\t\tDEBUG_OUT(\n\t\t\t\t\"\\t\\tChinese mode key, \"\n\t\t\t\t\"ZuinPhoInput return value = %d\\n\",\n\t\t\t\trtn );\n\n\t\t\tif ( rtn == ZUIN_KEY_ERROR )\n\t\t\t\trtn = SpecialSymbolInput( key, pgdata );\n\t\t\tswitch ( rtn ) {\n\t\t\t\tcase ZUIN_ABSORB:\n\t\t\t\t\tkeystrokeRtn = KEYSTROKE_ABSORB;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ZUIN_COMMIT:\n\t\t\t\t\tAddChi( pgdata->zuinData.phone, pgdata->zuinData.phoneAlt, pgdata );\n\t\t\t\t\tbreak;\n\t\t\t\tcase ZUIN_NO_WORD:\n\t\t\t\t\tkeystrokeRtn = KEYSTROKE_BELL | KEYSTROKE_ABSORB;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ZUIN_KEY_ERROR:\n\t\t\t\tcase ZUIN_IGNORE:\n\t\t\t\t\tDEBUG_OUT(\n\t\t\t\t\t\t\"\\t\\tbefore isupper(key),key=%d\\n\",\n\t\t\t\t\t\tkey );\n\t\t\t\t\t/* change upper case into lower case */\n\t\t\t\t\tif ( isupper( key ) )\n\t\t\t\t\t\tkey = tolower( key );\n\n\t\t\t\t\tDEBUG_OUT(\n\t\t\t\t\t\t\"\\t\\tafter isupper(key),key=%d\\n\",\n\t\t\t\t\t\tkey );\n\n\t\t\t\t\t/* see if buffer contains nothing */\n\t\t\t\t\tif ( pgdata->chiSymbolBufLen == 0 ) {\n\t\t\t\t\t\tbQuickCommit = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( pgdata->config.bEasySymbolInput == 0 ) {\n\t\t\t\t\t\tif ( pgdata->bFullShape )\n\t\t\t\t\t\t\trtn = FullShapeSymbolInput( key, pgdata );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\trtn = SymbolInput( key, pgdata );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( rtn == SYMBOL_KEY_ERROR ) {\n\t\t\t\t\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * If the key is not a printable symbol,\n\t\t\t\t\t\t * then it's wrong to commit it.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tbQuickCommit = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tkeystrokeRtn = KEYSTROKE_ABSORB;\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tgoto End_KeyDefault;\n\t\t\t}\n\t\t}\n\t\t/* English mode */\n\t\telse {\n\t\t\t/* see if buffer contains nothing */\n\t\t\tif ( pgdata->chiSymbolBufLen == 0 ) {\n\t\t\t\tbQuickCommit = 1;\n\t\t\t}\n\t\t\tif ( pgdata->bFullShape ) {\n\t\t\t\trtn = FullShapeSymbolInput( key, pgdata );\n\t\t\t}\n\t\t\telse {\n\t\t\t\trtn = SymbolInput( key, pgdata );\n\t\t\t}\n\n\t\t\tif ( rtn == SYMBOL_KEY_ERROR ) {\n\t\t\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t\t\t\tbQuickCommit = 0;\n\t\t\t}\n\t\t}\n\t}\n\nEnd_keyproc:\n\tif ( ! bQuickCommit ) {\n\t\tCallPhrasing( pgdata, 0 );\n\t\tif ( ReleaseChiSymbolBuf( pgdata, pgo ) != 0 )\n\t\t\tkeystrokeRtn = KEYSTROKE_COMMIT;\n\t}\n\t/* Quick commit */\n\telse {\n\t\tDEBUG_OUT(\n\t\t\t\t\"\\t\\tQuick commit buf[0]=%c\\n\",\n\t\t\t\tpgdata->preeditBuf[ 0 ].char_ );\n\t\tWriteChiSymbolToCommitBuf( pgdata, pgo, 1 );\n\t\tpgdata->chiSymbolBufLen = 0;\n\t\tpgdata->chiSymbolCursor = 0;\n\t\tkeystrokeRtn = KEYSTROKE_COMMIT;\n\t}\n\n\tif ( pgdata->phrOut.nNumCut > 0 ) {\n\t\tint i;\n\t\tfor ( i = 0; i < pgdata->phrOut.nDispInterval; i++ ) {\n\t\t\tpgdata->bUserArrBrkpt[ pgdata->phrOut.dispInterval[ i ].from ] = 1;\n\t\t\tpgdata->bUserArrBrkpt[ pgdata->phrOut.dispInterval[ i ].to ] = 1;\n\t\t}\n\t\tpgdata->phrOut.nNumCut = 0;\n\t}\n\nEnd_KeyDefault:\n\tCallPhrasing( pgdata, 0 );\nEnd_Paging:\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 1536,
        "end_line": 1743,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Del#987",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Del( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Del( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\tChewingOutput *pgo;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\tpgo = ctx->output;\n\n\tLOG_API();\n\n\tCheckAndResetRange( pgdata );\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\n\tif ( ! pgdata->bSelect ) {\n\t\tif (\n\t\t\t! ZuinIsEntering( &( pgdata->zuinData ) ) &&\n\t\t\tpgdata->chiSymbolCursor < pgdata->chiSymbolBufLen ) {\n\t\t\tChewingKillChar(\n\t\t\t\tpgdata,\n\t\t\t\tpgdata->chiSymbolCursor,\n\t\t\t\tNONDECREASE_CURSOR );\n\t\t}\n\t\tCallPhrasing( pgdata, 0 );\n\t}\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 987,
        "end_line": 1020,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Down#1102",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Down( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Down( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\tChewingOutput *pgo;\n\tint toSelect = 0;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\tint key_buf_cursor;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\tpgo = ctx->output;\n\n\tLOG_API();\n\n\tCheckAndResetRange( pgdata );\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\n\tkey_buf_cursor = pgdata->chiSymbolCursor;\n\tif ( pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen && key_buf_cursor > 0 )\n\t\tkey_buf_cursor--;\n\n\t/* see if to select */\n\tif ( ChewingIsChiAt( key_buf_cursor, pgdata ) )\n\t\t\ttoSelect = 1;\n\n\tchooseCandidate( ctx, toSelect, key_buf_cursor );\n\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 1102,
        "end_line": 1136,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_End#1415",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_End( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_End( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\tChewingOutput *pgo;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\tpgo = ctx->output;\n\n\tLOG_API();\n\n\tCheckAndResetRange( pgdata );\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\telse if ( ! pgdata->bSelect ) {\n\t\tpgdata->chiSymbolCursor = pgdata->chiSymbolBufLen;\n\t}\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 1415,
        "end_line": 1439,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Enter#926",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Enter( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Enter( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\tChewingOutput *pgo;\n\tint nCommitStr;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\tpgo = ctx->output;\n\n\tLOG_API();\n\n\tnCommitStr = pgdata->chiSymbolBufLen;\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\telse if ( pgdata->bSelect ) {\n\t\tkeystrokeRtn = KEYSTROKE_ABSORB | KEYSTROKE_BELL;\n\t}\n\telse if ( pgdata->PointStart > -1 ) {\n\t\tint buf = pgdata->chiSymbolCursor;\n\t\tint key;\n\t\tif ( pgdata->PointEnd > 1 ) {\n\t\t\tif ( ! pgdata->config.bAddPhraseForward ) {\n\t\t\t\tpgdata->chiSymbolCursor = pgdata->PointStart;\n\t\t\t\tkey = '0' + pgdata->PointEnd;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpgdata->chiSymbolCursor = pgdata->PointStart + pgdata->PointEnd;\n\t\t\t\tkey = '0' + pgdata->PointEnd;\n\t\t\t}\n\n\t\t\tchewing_handle_CtrlNum( ctx, key );\n\t\t\tpgdata->chiSymbolCursor = buf;\n\t\t}\n\t\telse if ( pgdata->PointEnd < 1 ) {\n\t\t\tif ( pgdata->config.bAddPhraseForward )\n\t\t\t\tpgdata->chiSymbolCursor = buf - pgdata->PointEnd;\n\t\t\tkey = '0' - pgdata->PointEnd;\n\t\t\tchewing_handle_CtrlNum( ctx, key );\n\t\t\tpgdata->chiSymbolCursor = buf;\n\t\t}\n\t\tpgdata->PointStart = -1;\n\t\tpgdata->PointEnd = 0;\n\t}\n\telse {\n\t\tkeystrokeRtn = KEYSTROKE_COMMIT;\n\t\tWriteChiSymbolToCommitBuf( pgdata, pgo, nCommitStr );\n\t\tAutoLearnPhrase( pgdata );\n\t\tCleanAllBuf( pgdata );\n\t\tpgo->commitBufLen = nCommitStr;\n\t}\n\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 926,
        "end_line": 985,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Esc#892",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Esc( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Esc( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\tChewingOutput *pgo;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\tpgo = ctx->output;\n\n\tLOG_API();\n\n\tCheckAndResetRange( pgdata );\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\telse if ( pgdata->bSelect ) {\n\t\tChoiceEndChoice( pgdata );\n\t}\n\telse if ( ZuinIsEntering( &( pgdata->zuinData ) ) ) {\n\t\tZuinRemoveAll( &( pgdata->zuinData ) );\n\t}\n\telse if ( pgdata->config.bEscCleanAllBuf ) {\n\t\tCleanAllBuf( pgdata );\n\t\tpgo->commitBufLen = pgdata->chiSymbolBufLen;\n\t}\n\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 892,
        "end_line": 924,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Home#1389",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Home( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Home( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\tChewingOutput *pgo;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\tpgo = ctx->output;\n\n\tLOG_API();\n\n\tCheckAndResetRange( pgdata );\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\telse if ( ! pgdata->bSelect ) {\n\t\tpgdata->chiSymbolCursor = 0;\n\t}\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 1389,
        "end_line": 1413,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Left#1178",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Left( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Left( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\tChewingOutput *pgo;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\tpgo = ctx->output;\n\n\tLOG_API();\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\n\tif ( pgdata->bSelect ) {\n\t\tassert( pgdata->choiceInfo.nPage > 0 );\n\t\tif ( pgdata->choiceInfo.pageNo > 0 )\n\t\t\tpgdata->choiceInfo.pageNo--;\n\t\telse\n\t\t\tpgdata->choiceInfo.pageNo = pgdata->choiceInfo.nPage - 1;\n\t}\n\telse {\n\t\tif (\n\t\t\t! ZuinIsEntering( &( pgdata->zuinData ) ) &&\n\t\t\tpgdata->chiSymbolCursor > 0 ) {\n\t\t\tCheckAndResetRange( pgdata );\n\t\t\tpgdata->chiSymbolCursor--;\n\t\t}\n\t}\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 1178,
        "end_line": 1213,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Numlock#1869",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Numlock( ChewingContext *ctx, int key )",
        "snippet": "CHEWING_API int chewing_handle_Numlock( ChewingContext *ctx, int key )\n{\n\tChewingData *pgdata;\n\tChewingOutput *pgo;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\tint rtn;\n\tint QuickCommit = 0;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\tpgo = ctx->output;\n\n\tLOG_API();\n\n\tif ( ! pgdata->bSelect ) {\n\t\t/* If we're not selecting words, we should send out numeric\n\t\t * characters at once.\n\t\t */\n\t\tif ( pgdata->chiSymbolBufLen == 0 ) {\n\t\t\tQuickCommit = 1;\n\t\t}\n\t\trtn = SymbolInput( key, pgdata );\n\t\t/* copied from chewing_handle_Default */\n\t\tif ( rtn == SYMBOL_KEY_ERROR ) {\n\t\t\tkeystrokeRtn = KEYSTROKE_IGNORE ;\n\t\t}\n\t\telse if ( QuickCommit ) {\n\t\t\tWriteChiSymbolToCommitBuf( pgdata, pgo, 1 );\n\t\t\tpgdata->chiSymbolBufLen = 0;\n\t\t\tpgdata->chiSymbolCursor = 0;\n\t\t\tkeystrokeRtn = KEYSTROKE_COMMIT;\n\t\t}\n\t\telse {\t/* Not quick commit */\n\t\t\tCallPhrasing( pgdata, 0 );\n\t\t\tif( ReleaseChiSymbolBuf( pgdata, pgo ) != 0 )\n\t\t\t\tkeystrokeRtn = KEYSTROKE_COMMIT;\n\t\t}\n\t}\n\telse {\n\t\t/* Otherwise, if we are selecting words, we use numeric keys\n\t\t * as selkey\n\t\t * and submit the words.\n\t\t */\n\t\tint num = -1;\n\t\tif ( key > '0' && key <= '9' )\n\t\t\tnum = key - '1';\n\t\telse if ( key == '0' )\n\t\t\tnum = 9;\n\t\tDoSelect( pgdata, num );\n\t}\n\tCallPhrasing( pgdata, 0 );\n\tif ( ReleaseChiSymbolBuf( pgdata, pgo ) != 0 )\n\t\tkeystrokeRtn = KEYSTROKE_COMMIT;\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 1869,
        "end_line": 1926,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_PageDown#1474",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_PageDown( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_PageDown( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\tChewingOutput *pgo;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\tpgo = ctx->output;\n\n\tLOG_API();\n\n\tCheckAndResetRange( pgdata );\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\telse if ( ! pgdata->bSelect ) {\n\t\tpgdata->chiSymbolCursor = pgdata->chiSymbolBufLen;\n\t}\n\telse if ( pgdata->bSelect ) {\n\t\tif ( pgdata->choiceInfo.pageNo < pgdata->choiceInfo.nPage - 1)\n\t\t\tpgdata->choiceInfo.pageNo++;\n\t\telse\n\t\t\tpgdata->choiceInfo.pageNo = 0;\n\t}\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 1474,
        "end_line": 1504,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_PageUp#1441",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_PageUp( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_PageUp( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\tChewingOutput *pgo;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\tpgo = ctx->output;\n\n\tLOG_API();\n\n\tCheckAndResetRange( pgdata );\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\telse if ( ! pgdata->bSelect ) {\n\t\tpgdata->chiSymbolCursor = pgdata->chiSymbolBufLen;\n\t}\n\telse if ( pgdata->bSelect ) {\n\t\tassert( pgdata->choiceInfo.nPage > 0 );\n\t\tif ( pgdata->choiceInfo.pageNo > 0 )\n\t\t\tpgdata->choiceInfo.pageNo--;\n\t\telse\n\t\t\tpgdata->choiceInfo.pageNo = pgdata->choiceInfo.nPage - 1;\n\t}\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 1441,
        "end_line": 1472,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Right#1256",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Right( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Right( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\tChewingOutput *pgo;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\tpgo = ctx->output;\n\n\tLOG_API();\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\n\tif ( pgdata->bSelect ) {\n\t\tif ( pgdata->choiceInfo.pageNo < pgdata->choiceInfo.nPage - 1)\n\t\t\tpgdata->choiceInfo.pageNo++;\n\t\telse\n\t\t\tpgdata->choiceInfo.pageNo = 0;\n\t}\n\telse {\n\t\tif (\n\t\t\t! ZuinIsEntering( &( pgdata->zuinData ) ) &&\n\t\t\tpgdata->chiSymbolCursor < pgdata->chiSymbolBufLen ) {\n\t\t\tCheckAndResetRange( pgdata );\n\t\t\tpgdata->chiSymbolCursor++;\n\t\t}\n\t}\n\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 1256,
        "end_line": 1291,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Space#851",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Space( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Space( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\t/*\n\t * Use chewing_handle_Default( ctx, ' ' ) to handle space when:\n\t * - \"space as selection\" mode is disable\n\t * - mode is not CHINESE_MODE\n\t * - has incompleted bopomofo (space is needed to complete it)\n\t */\n\tif ( !pgdata->config.bSpaceAsSelection\n\t     || pgdata->bChiSym != CHINESE_MODE\n\t     || ZuinIsEntering( &ctx->data->zuinData ) ) {\n\t\treturn chewing_handle_Default( ctx, ' ' );\n\t}\n\n\tCheckAndResetRange( pgdata );\n\n\t/*\n\t * space = right when the follogin conditions are true\n\t * 1. In select mode\n\t * 2. The candidate page is not last page\n\t *\n\t * Otherwise, space = down\n\t */\n\tif ( pgdata->bSelect &&\n\t     ctx->output->pci->pageNo < ctx->output->pci->nPage - 1 ) {\n\t\treturn chewing_handle_Right( ctx );\n\t} else {\n\t\treturn chewing_handle_Down( ctx );\n\t}\n\treturn 0;\n}",
        "begin_line": 851,
        "end_line": 890,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Tab#1293",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Tab( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Tab( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\tChewingOutput *pgo;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\tint all_phrasing = 0;\n\tint cursor;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\tpgo = ctx->output;\n\n\tLOG_API();\n\n\tCheckAndResetRange( pgdata );\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\n\n\tif ( ! pgdata->bSelect ) {\n\t\tif ( pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen ) {\n\t\t\tpgdata->phrOut.nNumCut++;\n\t\t\tall_phrasing = 1;\n\t\t}\n\t\telse if ( ChewingIsChiAt( pgdata->chiSymbolCursor - 1, pgdata ) ) {\n\t\t\tcursor = PhoneSeqCursor( pgdata );\n\t\t\tif ( IsPreferIntervalConnted( cursor, pgdata) ) {\n\t\t\t\tpgdata->bUserArrBrkpt[ cursor ] = 1;\n\t\t\t\tpgdata->bUserArrCnnct[ cursor ] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpgdata->bUserArrBrkpt[ cursor ] = 0;\n\t\t\t\tpgdata->bUserArrCnnct[ cursor ] = 1;\n\t\t\t}\n\t\t}\n\t\tCallPhrasing( pgdata, all_phrasing );\n\t}\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 1293,
        "end_line": 1336,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Up#1065",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Up( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Up( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\tChewingOutput *pgo;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\tint key_buf_cursor;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\tpgo = ctx->output;\n\n\tLOG_API();\n\n\tCheckAndResetRange( pgdata );\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\n\tkey_buf_cursor = pgdata->chiSymbolCursor;\n\t// FIXME: when pgdata->chiSymbolBufLen == 0, key_buf_cursor will be -1.\n\tif ( pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen )\n\t\tkey_buf_cursor--;\n\n\t/* close candidate list, compared to Down key to open candidate list. */\n\tif ( ! pgdata->symbolKeyBuf[ key_buf_cursor ] ) {\n\t\tif ( pgdata->bSelect ) {\n\t\t\tChoiceEndChoice( pgdata );\n\t\t}\n\t}\n\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 1065,
        "end_line": 1100,
        "is_bug": true
    },
    {
        "name": "chewingio.chewing_set_ChiEngMode#740",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_ChiEngMode( ChewingContext *ctx, int mode )",
        "snippet": "CHEWING_API void chewing_set_ChiEngMode( ChewingContext *ctx, int mode )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API( \"mode = %d\", mode );\n\n\tif ( mode == CHINESE_MODE || mode == SYMBOL_MODE ) {\n\t\t// remove all data inside buffer as switching mode.\n\t\tZuinRemoveAll( &( ctx->data->zuinData ) );\n\t\tMakeOutputWithRtn( ctx->output, ctx->data, KEYSTROKE_ABSORB);\n\t\tctx->data->bChiSym = mode;\n\t}\n}",
        "begin_line": 740,
        "end_line": 757,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_autoShiftCur#653",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_autoShiftCur( ChewingContext *ctx, int mode )",
        "snippet": "CHEWING_API void chewing_set_autoShiftCur( ChewingContext *ctx, int mode )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API( \"mode = %d\", mode );\n\n\tif ( mode == 0 || mode == 1 )\n\t\tctx->data->config.bAutoShiftCur = mode;\n}",
        "begin_line": 653,
        "end_line": 666,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_candPerPage#456",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_candPerPage( ChewingContext *ctx, int n )",
        "snippet": "CHEWING_API void chewing_set_candPerPage( ChewingContext *ctx, int n )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API( \"n = %d\", n );\n\n\tif ( MIN_SELKEY <= n && n <= MAX_SELKEY )\n\t\tctx->data->config.candPerPage = n;\n}",
        "begin_line": 456,
        "end_line": 469,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_escCleanAllBuf#612",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_escCleanAllBuf( ChewingContext *ctx, int mode )",
        "snippet": "CHEWING_API void chewing_set_escCleanAllBuf( ChewingContext *ctx, int mode )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API( \"mode = %d\", mode );\n\n\tif ( mode == 0 || mode == 1 )\n\t\tctx->data->config.bEscCleanAllBuf = mode;\n}",
        "begin_line": 612,
        "end_line": 625,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_logger#1960",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_logger( ChewingContext *ctx, void (*logger)( void *data, int level, const char *fmt, ... ), void *data )",
        "snippet": "CHEWING_API void chewing_set_logger( ChewingContext *ctx,\n\tvoid (*logger)( void *data, int level, const char *fmt, ... ),\n\tvoid *data )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\tif ( !logger ) {\n\t\tlogger = NullLogger;\n\t\tdata = 0;\n\t}\n\tctx->data->logger = logger;\n\tctx->data->loggerData = data;\n}",
        "begin_line": 1960,
        "end_line": 1979,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_maxChiSymbolLen#485",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_maxChiSymbolLen( ChewingContext *ctx, int n )",
        "snippet": "CHEWING_API void chewing_set_maxChiSymbolLen( ChewingContext *ctx, int n )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API( \"n = %d\", n );\n\n\tif ( MIN_CHI_SYMBOL_LEN <= n && n <= MAX_CHI_SYMBOL_LEN )\n\t\tctx->data->config.maxChiSymbolLen = n;\n}",
        "begin_line": 485,
        "end_line": 498,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_phraseChoiceRearward#711",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_phraseChoiceRearward( ChewingContext *ctx, int mode )",
        "snippet": "CHEWING_API void chewing_set_phraseChoiceRearward( ChewingContext *ctx, int mode )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API( \"mode = %d\", mode );\n\n\tif ( mode == 0 || mode == 1 )\n\t\tctx->data->config.bPhraseChoiceRearward = mode;\n}",
        "begin_line": 711,
        "end_line": 724,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_spaceAsSelection#583",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_spaceAsSelection( ChewingContext *ctx, int mode )",
        "snippet": "CHEWING_API void chewing_set_spaceAsSelection( ChewingContext *ctx, int mode )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API( \"mode = %d\", mode );\n\n\tif ( mode == 0 || mode == 1 )\n\t\tctx->data->config.bSpaceAsSelection = mode;\n}",
        "begin_line": 583,
        "end_line": 596,
        "is_bug": false
    },
    {
        "name": "chewingio.chooseCandidate#100",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chooseCandidate( ChewingContext *ctx, int toSelect, int key_buf_cursor )",
        "snippet": "static void chooseCandidate( ChewingContext *ctx, int toSelect, int key_buf_cursor )\n{\n\tChewingData *pgdata = ctx->data;\n\n\tif ( toSelect ) {\n\t\tif ( ! pgdata->bSelect ) {\n\t\t\tChoiceInitAvail( pgdata );\n\t\t} else {\n\t\t\tif ( pgdata->config.bPhraseChoiceRearward ) {\n\t\t\t\tint avail_willbe = (pgdata->availInfo.currentAvail > 0) ?\n\t\t\t\t\tpgdata->availInfo.currentAvail - 1 :\n\t\t\t\t\tpgdata->availInfo.nAvail - 1;\n\t\t\t\tpgdata->chiSymbolCursor = pgdata->choiceInfo.oldChiSymbolCursor -\n\t\t\t\t\tpgdata->availInfo.avail[ avail_willbe ].len;\n\t\t\t\tif ( chewing_buffer_Len( ctx ) >\n\t\t\t\t\t\tpgdata->choiceInfo.oldChiSymbolCursor ) {\n\t\t\t\t\tpgdata->chiSymbolCursor++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( ChoiceHasNextAvail( pgdata ) )\n\t\t\t\tChoiceNextAvail( pgdata );\n\t\t\telse /* rollover */\n\t\t\t\tChoiceFirstAvail( pgdata );\n\t\t}\n\t} else if ( pgdata->symbolKeyBuf[ key_buf_cursor ] ) {\n\t\t/* Open Symbol Choice List */\n\t\tif ( pgdata->choiceInfo.isSymbol == WORD_CHOICE ) {\n\t\t\tOpenSymbolChoice( pgdata );\n\t\t}\n\t\t/**\n\t\t * If these's only one candidate list available, ChoiceFirstAvail\n\t\t * will re-open the list, namely turn back to the firt page.\n\t\t * However, it doesn't work for symbols, therefore we\n\t\t * set the page number to 0 directly.\n\t\t */\n\t\telse if ( pgdata->bSelect ) {\n\t\t\tpgdata->choiceInfo.pageNo = 0;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * The cursor position is not word, nor symbol. The only\n\t\t * possible case is that user just uses ` to open symbol\n\t\t * selection. In this case, when chooseCandidate is called,\n\t\t * libchewing needs to reset pageNo to 0 to do rollover.\n\t\t */\n\t\tif ( pgdata-> bSelect ) {\n\t\t\tpgdata->choiceInfo.pageNo = 0;\n\t\t}\n\t}\n}",
        "begin_line": 100,
        "end_line": 150,
        "is_bug": false
    },
    {
        "name": "chewingutil.AddChi#669",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.AddChi( uint16_t phone, uint16_t phoneAlt, ChewingData *pgdata )",
        "snippet": "int AddChi( uint16_t phone, uint16_t phoneAlt, ChewingData *pgdata )\n{\n\tint i;\n\tint cursor = PhoneSeqCursor( pgdata );\n\n\t/* shift the selectInterval */\n\tfor ( i = 0; i < pgdata->nSelect; i++ ) {\n\t\tif ( pgdata->selectInterval[ i ].from >= cursor ) {\n\t\t\tpgdata->selectInterval[ i ].from++;\n\t\t\tpgdata->selectInterval[ i ].to++;\n\t\t}\n\t}\n\n\t/* shift the Brkpt */\n\tassert( pgdata->nPhoneSeq >= cursor );\n\tmemmove(\n\t\t&( pgdata->bUserArrBrkpt[ cursor + 2 ] ),\n\t\t&( pgdata->bUserArrBrkpt[ cursor + 1 ] ),\n\t\tsizeof( int ) * ( pgdata->nPhoneSeq - cursor ) );\n\tmemmove(\n\t\t&( pgdata->bUserArrCnnct[ cursor + 2 ] ),\n\t\t&( pgdata->bUserArrCnnct[ cursor + 1 ] ),\n\t\tsizeof( int ) * ( pgdata->nPhoneSeq - cursor ) );\n\n\t/* add to phoneSeq */\n\tmemmove(\n\t\t&( pgdata->phoneSeq[ cursor + 1 ] ),\n\t\t&( pgdata->phoneSeq[ cursor ] ) ,\n\t\tsizeof( uint16_t ) * ( pgdata->nPhoneSeq - cursor ) );\n\tpgdata->phoneSeq[ cursor ] = phone;\n\tmemmove(\n\t\t&( pgdata->phoneSeqAlt[ cursor + 1 ] ),\n\t\t&( pgdata->phoneSeqAlt[ cursor ] ) ,\n\t\tsizeof( uint16_t ) * ( pgdata->nPhoneSeq - cursor ) );\n\tpgdata->phoneSeqAlt[ cursor ] = phoneAlt;\n\tpgdata->nPhoneSeq ++;\n\n\t/* add to chiSymbolBuf */\n\tassert( pgdata->chiSymbolBufLen >= pgdata->chiSymbolCursor );\n\tmemmove(\n\t\t&( pgdata->preeditBuf[ pgdata->chiSymbolCursor + 1 ] ),\n\t\t&( pgdata->preeditBuf[ pgdata->chiSymbolCursor ] ) ,\n\t\tsizeof( pgdata->preeditBuf[0] ) * ( pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor ) );\n\t/* \"0\" means Chinese word */\n\tpgdata->preeditBuf[ pgdata->chiSymbolCursor ].category = CHEWING_CHINESE;\n\tpgdata->chiSymbolBufLen++;\n\tpgdata->chiSymbolCursor++;\n\n\treturn 0;\n}",
        "begin_line": 669,
        "end_line": 718,
        "is_bug": false
    },
    {
        "name": "chewingutil.AddSelect#951",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.AddSelect( ChewingData *pgdata, int sel_i )",
        "snippet": "int AddSelect( ChewingData *pgdata, int sel_i )\n{\n\tint length, nSelect, cursor;\n\n\t/* save the typing time */\n\tlength = pgdata->availInfo.avail[ pgdata->availInfo.currentAvail ].len;\n\tnSelect = pgdata->nSelect;\n\n\t/* change \"selectStr\" , \"selectInterval\" , and \"nSelect\" of ChewingData */\n\tueStrNCpy( pgdata->selectStr[ nSelect ],\n\t\t\tpgdata->choiceInfo.totalChoiceStr[ sel_i ],\n\t\t\tlength, 1 );\n\tcursor = PhoneSeqCursor( pgdata );\n\tpgdata->selectInterval[ nSelect ].from = cursor;\n\tpgdata->selectInterval[ nSelect ].to = cursor + length;\n\tpgdata->nSelect++;\n\treturn 0;\n}",
        "begin_line": 951,
        "end_line": 968,
        "is_bug": false
    },
    {
        "name": "chewingutil.AutoLearnPhrase#591",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.AutoLearnPhrase( ChewingData *pgdata )",
        "snippet": "void AutoLearnPhrase( ChewingData *pgdata )\n{\n\tuint16_t bufPhoneSeq[ MAX_PHONE_SEQ_LEN + 1 ];\n\tchar bufWordSeq[ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ] = { 0 };\n\tchar *pos;\n\tint i;\n\tint from;\n\tint fromPreeditBuf;\n\tint len;\n\tint prev_pos = 0;\n\tint pending_pos = 0;\n\n\t/*\n\t * FIXME: pgdata->preferInterval does not consider symbol, so we need to\n\t * do translate when using APIs that considering symbol.\n\t */\n\n\tUserUpdatePhraseBegin( pgdata );\n\n\tfor ( i = 0; i < pgdata->nPrefer; i++ ) {\n\t\tfrom = pgdata->preferInterval[ i ].from;\n\t\tlen = pgdata->preferInterval[i].to - from;\n\t\tfromPreeditBuf = toPreeditBufIndex( pgdata, from );\n\n\t\tLOG_VERBOSE( \"interval from = %d, fromPreeditBuf = %d, len = %d, pending_pos = %d\", from, fromPreeditBuf, len, pending_pos );\n\n\t\tif ( pending_pos != 0 && pending_pos < fromPreeditBuf ) {\n\t\t\t/*\n\t\t\t * There is a pending phrase in buffer and it is not\n\t\t\t * connected to current phrase. We store it as\n\t\t\t * userphrase here.\n\t\t\t */\n\t\t\tUserUpdatePhrase( pgdata, bufPhoneSeq, bufWordSeq );\n\t\t\tprev_pos = 0;\n\t\t\tpending_pos = 0;\n\t\t}\n\n\t\tif ( len == 1 && !ChewingIsBreakPoint( fromPreeditBuf, pgdata ) ) {\n\t\t\t/*\n\t\t\t * There is a length one phrase and it is not a break\n\t\t\t * point. We store it and try to connect to other length\n\t\t\t * one phrase if possible.\n\t\t\t */\n\t\t\tmemcpy( bufPhoneSeq + prev_pos, &pgdata->phoneSeq[ from ], sizeof( uint16_t ) * len );\n\t\t\tbufPhoneSeq[ prev_pos + len ] = (uint16_t) 0;\n\n\t\t\tpos = ueStrSeek( bufWordSeq, prev_pos );\n\t\t\tcopyStringFromPreeditBuf( pgdata, fromPreeditBuf, len,\n\t\t\t\tpos, bufWordSeq + sizeof( bufWordSeq ) - pos );\n\t\t\tprev_pos += len;\n\t\t\tpending_pos = fromPreeditBuf + len;\n\n\t\t} else {\n\t\t\tif ( pending_pos ) {\n\t\t\t\t/*\n\t\t\t\t * Clean pending phrase because we cannot join\n\t\t\t\t * it with current phrase.\n\t\t\t\t */\n\t\t\t\tUserUpdatePhrase( pgdata, bufPhoneSeq, bufWordSeq );\n\t\t\t\tprev_pos = 0;\n\t\t\t\tpending_pos = 0;\n\t\t\t}\n\t\t\tmemcpy( bufPhoneSeq, &pgdata->phoneSeq[ from ], sizeof( uint16_t ) * len );\n\t\t\tbufPhoneSeq[ len ] = (uint16_t) 0;\n\t\t\tcopyStringFromPreeditBuf( pgdata, fromPreeditBuf, len, bufWordSeq, sizeof( bufWordSeq ) );\n\t\t\tUserUpdatePhrase( pgdata, bufPhoneSeq, bufWordSeq );\n\t\t}\n\t}\n\n\tif ( pending_pos ) {\n\t\tUserUpdatePhrase( pgdata, bufPhoneSeq, bufWordSeq );\n\t\tprev_pos = 0;\n\t\tpending_pos = 0;\n\t}\n\n\tUserUpdatePhraseEnd( pgdata );\n}",
        "begin_line": 591,
        "end_line": 667,
        "is_bug": false
    },
    {
        "name": "chewingutil.CallPhrasing#765",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.CallPhrasing( ChewingData *pgdata, int all_phrasing )",
        "snippet": "int CallPhrasing( ChewingData *pgdata, int all_phrasing )\n{\n\t/* set \"bSymbolArrBrkpt\" && \"bArrBrkpt\" */\n\tint i, ch_count = 0;\n\n\tmemcpy(\n\t\tpgdata->bArrBrkpt,\n\t\tpgdata->bUserArrBrkpt,\n\t\t(MAX_PHONE_SEQ_LEN + 1) * sizeof( int ) );\n\tmemset(\n\t\tpgdata->bSymbolArrBrkpt, 0,\n\t\t(MAX_PHONE_SEQ_LEN + 1) * sizeof( int ) );\n\n\tfor ( i = 0; i < pgdata->chiSymbolBufLen; i++ ) {\n\t\tif ( ChewingIsChiAt( i, pgdata ) )\n\t\t\tch_count++;\n\t\telse {\n\t\t\tpgdata->bArrBrkpt[ ch_count ] = 1;\n\t\t\tpgdata->bSymbolArrBrkpt[ ch_count ] = 1;\n\t\t}\n\t}\n\n\t/* kill select interval */\n\tfor ( i = 0; i < pgdata->nPhoneSeq; i++ ) {\n\t\tif ( pgdata->bArrBrkpt[ i ] ) {\n\t\t\tChewingKillSelectIntervalAcross( i, pgdata );\n\t\t}\n\t}\n\n\tShowChewingData(pgdata);\n\n\t/* then phrasing */\n\tPhrasing( pgdata, all_phrasing );\n\n\t/* and then make prefer interval */\n\tMakePreferInterval( pgdata );\n\n\treturn 0;\n}",
        "begin_line": 765,
        "end_line": 803,
        "is_bug": false
    },
    {
        "name": "chewingutil.ChewingIsBreakPoint#553",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ChewingIsBreakPoint( int cursor, ChewingData *pgdata )",
        "snippet": "static int ChewingIsBreakPoint( int cursor, ChewingData *pgdata )\n{\n\tstatic const char * const BREAK_WORD[] = {\n\t\t\"\\xE6\\x98\\xAF\", \"\\xE7\\x9A\\x84\", \"\\xE4\\xBA\\x86\", \"\\xE4\\xB8\\x8D\",\n\t\t/* \u662f              \u7684              \u4e86              \u4e0d */\n\t\t\"\\xE4\\xB9\\x9F\", \"\\xE8\\x80\\x8C\", \"\\xE4\\xBD\\xA0\", \"\\xE6\\x88\\x91\",\n\t\t/* \u4e5f              \u800c              \u4f60              \u6211 */\n\t\t\"\\xE4\\xBB\\x96\", \"\\xE8\\x88\\x87\", \"\\xE5\\xAE\\x83\", \"\\xE5\\xA5\\xB9\",\n\t\t/* \u4ed6              \u8207              \u5b83              \u5979 */\n\t\t\"\\xE5\\x85\\xB6\", \"\\xE5\\xB0\\xB1\", \"\\xE5\\x92\\x8C\", \"\\xE6\\x88\\x96\",\n\t\t/* \u5176              \u5c31              \u548c              \u6216 */\n\t\t\"\\xE5\\x80\\x91\", \"\\xE6\\x80\\xA7\", \"\\xE5\\x93\\xA1\", \"\\xE5\\xAD\\x90\",\n\t\t/* \u5011              \u6027              \u54e1              \u5b50 */\n\t\t\"\\xE4\\xB8\\x8A\", \"\\xE4\\xB8\\x8B\", \"\\xE4\\xB8\\xAD\", \"\\xE5\\x85\\xA7\",\n\t\t/* \u4e0a              \u4e0b              \u4e2d              \u5167 */\n\t\t\"\\xE5\\xA4\\x96\", \"\\xE5\\x8C\\x96\", \"\\xE8\\x80\\x85\", \"\\xE5\\xAE\\xB6\",\n\t\t/* \u5916              \u5316              \u8005              \u5bb6 */\n\t\t\"\\xE5\\x85\\x92\", \"\\xE5\\xB9\\xB4\", \"\\xE6\\x9C\\x88\", \"\\xE6\\x97\\xA5\",\n\t\t/* \u5152              \u5e74              \u6708              \u65e5 */\n\t\t\"\\xE6\\x99\\x82\", \"\\xE5\\x88\\x86\", \"\\xE7\\xA7\\x92\", \"\\xE8\\xA1\\x97\",\n\t\t/* \u6642              \u5206              \u79d2              \u8857 */\n\t\t\"\\xE8\\xB7\\xAF\", \"\\xE6\\x9D\\x91\",\n\t\t/* \u8def              \u6751 */\n\t\t\"\\xE5\\x9C\\xA8\",\n\t\t/* \u5728 */\n\t};\n\tint i;\n\n\tif ( ! ChewingIsChiAt( cursor, pgdata ) )\n\t\treturn 1;\n\n\tfor ( i = 0; i < ARRAY_SIZE( BREAK_WORD ); ++i )\n\t\tif ( ! strcmp( pgdata->preeditBuf[ cursor ].char_, BREAK_WORD[ i ]) )\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nvoid AutoLearnPhrase( ChewingData *pgdata )\n{\n\tuint16_t bufPhoneSeq[ MAX_PHO",
        "begin_line": 553,
        "end_line": 589,
        "is_bug": false
    },
    {
        "name": "chewingutil.ChewingIsChiAt#998",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ChewingIsChiAt( int chiSymbolCursor, ChewingData *pgdata )",
        "snippet": "int ChewingIsChiAt( int chiSymbolCursor, ChewingData *pgdata )\n{\n\treturn pgdata->preeditBuf[ chiSymbolCursor ].category == CHEWING_CHINESE;\n}",
        "begin_line": 998,
        "end_line": 1001,
        "is_bug": false
    },
    {
        "name": "chewingutil.ChewingIsEntering#109",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ChewingIsEntering( ChewingData *pgdata )",
        "snippet": "int ChewingIsEntering( ChewingData *pgdata )\n{\n\tif ( pgdata->choiceInfo.isSymbol != WORD_CHOICE )\n\t\treturn 1;\n\treturn (\n\t\tpgdata->chiSymbolBufLen != 0 ||\n\t\tZuinIsEntering( &( pgdata->zuinData ) ) );\n}",
        "begin_line": 109,
        "end_line": 116,
        "is_bug": false
    },
    {
        "name": "chewingutil.ChewingKillChar#1052",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ChewingKillChar( \t\tChewingData *pgdata, int chiSymbolCursorToKill, int minus )",
        "snippet": "int ChewingKillChar(\n\t\tChewingData *pgdata,\n\t\tint chiSymbolCursorToKill,\n\t\tint minus )\n{\n\tint tmp, cursorToKill;\n\ttmp = pgdata->chiSymbolCursor;\n\tpgdata->chiSymbolCursor = chiSymbolCursorToKill;\n\tcursorToKill = PhoneSeqCursor( pgdata );\n\tpgdata->chiSymbolCursor = tmp;\n\tif ( ChewingIsChiAt( chiSymbolCursorToKill, pgdata ) ) {\n\t\tKillCharInSelectIntervalAndBrkpt(pgdata, cursorToKill);\n\t\tassert( pgdata->nPhoneSeq - cursorToKill - 1 >= 0 );\n\t\tmemmove(\n\t\t\t&( pgdata->phoneSeq[ cursorToKill ] ),\n\t\t\t&(pgdata->phoneSeq[ cursorToKill + 1 ] ),\n\t\t\t(pgdata->nPhoneSeq - cursorToKill - 1) * sizeof( uint16_t ) );\n\t\tpgdata->nPhoneSeq--;\n\t}\n\tpgdata->symbolKeyBuf[ chiSymbolCursorToKill ] = 0;\n\tassert( pgdata->chiSymbolBufLen - chiSymbolCursorToKill );\n\tmemmove(\n\t\t& pgdata->preeditBuf[ chiSymbolCursorToKill ],\n\t\t& pgdata->preeditBuf[ chiSymbolCursorToKill + 1 ],\n\t\tsizeof ( pgdata->preeditBuf[0] ) * (pgdata->chiSymbolBufLen - chiSymbolCursorToKill) );\n\tpgdata->chiSymbolBufLen--;\n\tpgdata->chiSymbolCursor -= minus;\n\tif (pgdata->chiSymbolCursor < 0)\n\t\tpgdata->chiSymbolCursor = 0;\n\treturn 0;\n}",
        "begin_line": 1052,
        "end_line": 1082,
        "is_bug": false
    },
    {
        "name": "chewingutil.ChewingKillSelectIntervalAcross#1011",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ChewingKillSelectIntervalAcross( int cursor, ChewingData *pgdata )",
        "snippet": "static int ChewingKillSelectIntervalAcross( int cursor, ChewingData *pgdata )\n{\n\tint i;\n\tfor ( i = 0; i < pgdata->nSelect; i++ ) {\n\t\tif ( pgdata->selectInterval[ i ].from < cursor &&\n\t\t\tpgdata->selectInterval[ i ].to > cursor ) {\n\t\t\tRemoveSelectElement( i, pgdata );\n\t\t\ti--;\n\t\t}\n\t}\n\treturn 0;\n}",
        "begin_line": 1011,
        "end_line": 1022,
        "is_bug": false
    },
    {
        "name": "chewingutil.CleanAllBuf#507",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.CleanAllBuf( ChewingData *pgdata )",
        "snippet": "void CleanAllBuf( ChewingData *pgdata )\n{\n\t/* 1 */\n\tpgdata->nPhoneSeq = 0 ;\n\tmemset( pgdata->phoneSeq, 0, sizeof( pgdata->phoneSeq ) );\n\t/* 2 */\n\tpgdata->chiSymbolBufLen = 0;\n\tmemset( pgdata->preeditBuf, 0, sizeof( pgdata->preeditBuf ) );\n\t/* 3 */\n\tmemset( pgdata->bUserArrBrkpt, 0, sizeof( pgdata->bUserArrBrkpt ) );\n\t/* 4 */\n\tpgdata->nSelect = 0;\n\t/* 5 */\n\tpgdata->chiSymbolCursor = 0;\n\t/* 6 */\n\tmemset( pgdata->bUserArrCnnct, 0, sizeof( pgdata->bUserArrCnnct ) );\n\n\tpgdata->phrOut.nNumCut = 0;\n\n\tmemset( pgdata->symbolKeyBuf, 0, sizeof( pgdata->symbolKeyBuf ) );\n\n\tpgdata->nPrefer = 0;\n}",
        "begin_line": 507,
        "end_line": 529,
        "is_bug": false
    },
    {
        "name": "chewingutil.CompInterval#431",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.CompInterval( const IntervalType *a, const IntervalType *b )",
        "snippet": "static int CompInterval( const IntervalType *a, const IntervalType *b )\n{\n\tint cmp = a->from - b->from;\n\tif ( cmp )\n\t\treturn cmp;\n\treturn ( a->to - b->to );\n}",
        "begin_line": 431,
        "end_line": 437,
        "is_bug": false
    },
    {
        "name": "chewingutil.CountReleaseNum#468",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.CountReleaseNum( ChewingData *pgdata )",
        "snippet": "static int CountReleaseNum( ChewingData *pgdata )\n{\n\tint remain, i;\n\n\tremain = pgdata->config.maxChiSymbolLen - pgdata->chiSymbolBufLen;\n\tif ( remain >= 0 )\n\t\treturn 0;\n\n\tqsort(\n\t\tpgdata->preferInterval,\n\t\tpgdata->nPrefer,\n\t\tsizeof( IntervalType ),\n\t\t(CompFuncType) CompInterval );\n\n\tif ( ! ChewingIsChiAt( 0, pgdata ) ) {\n\t\tfor ( i = 0; i < pgdata->chiSymbolCursor; ++i ) {\n\t\t\tif ( ChewingIsChiAt( i, pgdata ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn i;\n\t}\n\n\ti = FindIntervalFrom( 0, pgdata->preferInterval, pgdata->nPrefer );\n\tif ( i >= 0 ) {\n\t\treturn ( pgdata->preferInterval[ i ].to - pgdata->preferInterval[ i ].from );\n\t}\n\n\treturn 1;\n}",
        "begin_line": 468,
        "end_line": 497,
        "is_bug": false
    },
    {
        "name": "chewingutil.CountSelKeyNum#970",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.CountSelKeyNum( int key, ChewingData *pgdata ) \t/* return value starts from 0.  If less than zero : error key */",
        "snippet": "int CountSelKeyNum( int key, ChewingData *pgdata )\n\t/* return value starts from 0.  If less than zero : error key */\n{\n\tint i;\n\n\tfor ( i = 0; i < MAX_SELKEY; i++ )\n\t\tif ( pgdata->config.selKey[ i ] == key )\n\t\t\treturn i;\n\treturn -1;\n}",
        "begin_line": 970,
        "end_line": 979,
        "is_bug": false
    },
    {
        "name": "chewingutil.CountSymbols#981",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.CountSymbols( ChewingData *pgdata, int to )",
        "snippet": "int CountSymbols( ChewingData *pgdata, int to )\n{\n\tint chi;\n\tint i;\n\tfor ( chi = i = 0; i < to; i++ ) {\n\t\tif ( ChewingIsChiAt( i, pgdata ) )\n\t\t\tchi++;\n\t}\n\treturn to - chi;\n}",
        "begin_line": 981,
        "end_line": 990,
        "is_bug": false
    },
    {
        "name": "chewingutil.FindEasySymbolIndex#65",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.FindEasySymbolIndex( char ch )",
        "snippet": "static int FindEasySymbolIndex( char ch )\n{\n\t/**\n\t * '0' => 0, ..., '9' => 9\n\t * 'A' => 10, 'B' => 11, ... 'Z' => 35\n\t */\n\tif ( isdigit( ch ) ) {\n\t\treturn ch - '0';\n\t}\n\telse if ( isupper( ch ) ) {\n\t\treturn ch - 'A' + 10;\n\t}\n\telse {\n\t\treturn -1;\n\t}\n}",
        "begin_line": 65,
        "end_line": 80,
        "is_bug": false
    },
    {
        "name": "chewingutil.FindIntervalFrom#439",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.FindIntervalFrom( int from, IntervalType inte[], int nInte )",
        "snippet": "static int FindIntervalFrom( int from, IntervalType inte[], int nInte )\n{\n\tint i;\n\n\tfor ( i = 0; i < nInte; i++ )\n\t\tif ( inte[ i ].from == from )\n\t\t\treturn i;\n\treturn -1;\n}",
        "begin_line": 439,
        "end_line": 447,
        "is_bug": false
    },
    {
        "name": "chewingutil.FindSymbolKey#1255",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.FindSymbolKey( const char *symbol )",
        "snippet": "static int FindSymbolKey( const char *symbol )\n{\n\tunsigned int i;\n\tconst char * const *buf;\n\tfor ( i = 0; i < ARRAY_SIZE( symbol_buf ); ++i ) {\n\t\tfor ( buf = symbol_buf[ i ]; *buf; ++buf )\t{\n\t\t\tif (  0 == strcmp( *buf, symbol ) )\n\t\t\t\treturn *symbol_buf[ i ][ 0 ];\n\t\t}\n\t}\n\treturn 0;\n}",
        "begin_line": 1255,
        "end_line": 1266,
        "is_bug": false
    },
    {
        "name": "chewingutil.HaninSymbolInput#118",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.HaninSymbolInput( ChewingData *pgdata )",
        "snippet": "int HaninSymbolInput( ChewingData *pgdata )\n{\n\tunsigned int i;\n\n\tChoiceInfo *pci = &( pgdata->choiceInfo );\n\tAvailInfo *pai = &( pgdata->availInfo );\n\n\t/* No available symbol table */\n\tif ( ! pgdata->static_data.symbol_table )\n\t\treturn ZUIN_ABSORB;\n\n\tpci->nTotalChoice = 0;\n\tfor ( i = 0; i < pgdata->static_data.n_symbol_entry; i++ ) {\n\t\tstrcpy( pci->totalChoiceStr[ pci->nTotalChoice ],\n\t\t\tpgdata->static_data.symbol_table[ i ]->category );\n\t\tpci->nTotalChoice++;\n\t}\n\tpai->avail[ 0 ].len = 1;\n\tpai->avail[ 0 ].id = NULL;\n\tpai->nAvail = 1;\n\tpai->currentAvail = 0;\n\tpci->nChoicePerPage = pgdata->config.candPerPage;\n\tassert( pci->nTotalChoice > 0 );\n\tpci->nPage = CEIL_DIV( pci->nTotalChoice, pci->nChoicePerPage );\n\tpci->pageNo = 0;\n\tpci->isSymbol = SYMBOL_CATEGORY_CHOICE;\n\treturn ZUIN_ABSORB;\n}",
        "begin_line": 118,
        "end_line": 145,
        "is_bug": false
    },
    {
        "name": "chewingutil.InitEasySymbolInput#1437",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.InitEasySymbolInput( ChewingData *pgdata, const char *prefix )",
        "snippet": "int InitEasySymbolInput( ChewingData *pgdata, const char *prefix )\n{\n\tstatic const size_t LINE_LEN = 512; // shall be long enough?\n\n\tFILE *file = NULL;\n\tchar *filename = NULL;\n\tchar *line = NULL;\n\tint len;\n\tint _index;\n\tchar *symbol;\n\tint ret = -1;\n\n\tret = asprintf( &filename, \"%s\" PLAT_SEPARATOR \"%s\",\n\t\t\tprefix, SOFTKBD_TABLE_FILE );\n\tif ( ret == -1 )\n\t\tgoto end;\n\n\tfile = fopen( filename, \"r\" );\n\tif ( !file )\n\t\tgoto end;\n\n\tline = ALC( char, LINE_LEN );\n\tif ( !line )\n\t\tgoto end;\n\n\twhile ( fgets( line, LINE_LEN, file ) ) {\n\t\tif ( ' ' != line[ 1 ] )\n\t\t\tcontinue;\n\n\t\t// Remove tailing \\n\n\t\tlen = strcspn( line, \"\\r\\n\" );\n\n\t\tline[ len ] = '\\0';\n\n\t\t_index = FindEasySymbolIndex( line[ 0 ] );\n\t\tif ( -1 == _index )\n\t\t\tcontinue;\n\n\t\tlen = ueStrLen( &line[ 2 ] );\n\t\tif ( 0 == len || len > MAX_PHRASE_LEN )\n\t\t\tcontinue;\n\n\t\tsymbol = ALC( char, strlen( &line[2] ) + 1 );\n\t\tif ( !symbol )\n\t\t\tgoto end;\n\n\t\tueStrNCpy( symbol, &line[ 2 ], len, 1 );\n\n\t\tfree( pgdata->static_data.g_easy_symbol_value[ _index ] );\n\t\tpgdata->static_data.g_easy_symbol_value[ _index ] = symbol;\n\t\tpgdata->static_data.g_easy_symbol_num[ _index ] = len;\n\t}\n\tret = 0;\nend:\n\tfree( line );\n\tfclose( file );\n\tfree ( filename );\n\treturn ret;\n}",
        "begin_line": 1437,
        "end_line": 1495,
        "is_bug": false
    },
    {
        "name": "chewingutil.InitSymbolTable#1315",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.InitSymbolTable( ChewingData *pgdata, const char *prefix )",
        "snippet": "int InitSymbolTable( ChewingData *pgdata, const char *prefix )\n{\n\tstatic const unsigned int MAX_SYMBOL_ENTRY = 100;\n\tstatic const size_t LINE_LEN = 512; // shall be long enough?\n\n\tchar *filename = NULL;\n\tFILE *file = NULL;\n\tchar *line = NULL;\n\tSymbolEntry **entry = NULL;\n\tchar *category_end;\n\tconst char *symbols;\n\tchar *symbols_end;\n\tconst char *symbol;\n\tsize_t i;\n\tsize_t len;\n\tsize_t size;\n\tint ret = -1;\n\n\tpgdata->static_data.n_symbol_entry = 0;\n\tpgdata->static_data.symbol_table = NULL;\n\n\tret = asprintf( &filename, \"%s\" PLAT_SEPARATOR \"%s\",\n\t\tprefix, SYMBOL_TABLE_FILE );\n\tif ( ret == -1 )\n\t\tgoto error;\n\n\tfile = fopen( filename, \"r\" );\n\tif ( !file )\n\t\tgoto error;\n\n\tline = ALC( char, LINE_LEN );\n\tif ( !line )\n\t\tgoto error;\n\n\tentry = ALC( SymbolEntry* , MAX_SYMBOL_ENTRY );\n\tif ( !entry )\n\t\tgoto error;\n\n\twhile ( fgets( line, LINE_LEN, file ) &&\n\t\tpgdata->static_data.n_symbol_entry < MAX_SYMBOL_ENTRY ) {\n\n\t\tcategory_end = strpbrk( line, \"=\\r\\n\" );\n\t\tif ( !category_end )\n\t\t\tgoto error;\n\n\t\tsymbols = category_end + 1;\n\t\tsymbols_end = strpbrk( symbols, \"\\r\\n\" );\n\t\tif ( symbols_end ) {\n\t\t\t*symbols_end = 0;\n\t\t\tlen = ueStrLen( symbols );\n\n\t\t\tentry[ pgdata->static_data.n_symbol_entry ] =\n\t\t\t\t( SymbolEntry* ) malloc( sizeof ( entry[0][0] ) +\n\t\t\t\t\tsizeof( entry[0][0].symbols[0] ) * len);\n\t\t\tif ( !entry[ pgdata->static_data.n_symbol_entry ] )\n\t\t\t\tgoto error;\n\t\t\tentry[ pgdata->static_data.n_symbol_entry ]\n\t\t\t\t->nSymbols = len;\n\n\t\t\tsymbol = symbols;\n\n\t\t\tfor ( i = 0; i < len; ++i ) {\n\t\t\t\tueStrNCpy(\n\t\t\t\t\tentry[ pgdata->static_data.n_symbol_entry ]->symbols[ i ],\n\t\t\t\t\tsymbol, 1, 1 );\n\t\t\t\t// FIXME: What if symbol is combining sequences.\n\t\t\t\tsymbol += ueBytesFromChar( symbol[0] );\n\t\t\t}\n\n\n\t\t} else {\n\t\t\tentry[ pgdata->static_data.n_symbol_entry ] =\n\t\t\t\t( SymbolEntry* ) malloc( sizeof ( entry[0][0] ) );\n\t\t\tif ( !entry[ pgdata->static_data.n_symbol_entry ] )\n\t\t\t\tgoto error;\n\n\t\t\tentry[ pgdata->static_data.n_symbol_entry ]\n\t\t\t\t->nSymbols = 0;\n\t\t}\n\n\t\t*category_end = 0;\n\t\tueStrNCpy(\n\t\t\tentry[pgdata->static_data.n_symbol_entry]->category,\n\t\t\tline, MAX_PHRASE_LEN, 1);\n\n\t\t++pgdata->static_data.n_symbol_entry;\n\t}\n\n\tsize = sizeof( *pgdata->static_data.symbol_table ) *\n\t\tpgdata->static_data.n_symbol_entry;\n\tpgdata->static_data.symbol_table = ( SymbolEntry ** ) malloc( size );\n\tif ( !pgdata->static_data.symbol_table )\n\t\tgoto error;\n\tmemcpy( pgdata->static_data.symbol_table, entry, size );\n\n\tret = 0;\nend:\n\tfree( entry );\n\tfree( line );\n\tfclose( file );\n\tfree ( filename );\n\treturn ret;\n\nerror:\n\tfor ( i = 0; i < pgdata->static_data.n_symbol_entry; ++i ) {\n\t\tfree( entry[ i ] );\n\t}\n\tgoto end;\n}",
        "begin_line": 1315,
        "end_line": 1423,
        "is_bug": false
    },
    {
        "name": "chewingutil.InternalSpecialSymbol#187",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.InternalSpecialSymbol( \t\tint key, ChewingData *pgdata, int nSpecial, const char keybuf[], const char * const chibuf[] )",
        "snippet": "static int InternalSpecialSymbol(\n\t\tint key, ChewingData *pgdata,\n\t\tint nSpecial, const char keybuf[], const char * const chibuf[] )\n{\n\tint i, rtn = ZUIN_IGNORE; /* very strange and difficult to understand */\n\n\tfor ( i = 0; i < nSpecial; i++ ) {\n\t\tif ( 1 == _Inner_InternalSpecialSymbol( key, pgdata, keybuf[ i ], chibuf[ i ]) ) {\n\t\t\trtn = ZUIN_ABSORB;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rtn;\n}",
        "begin_line": 187,
        "end_line": 200,
        "is_bug": false
    },
    {
        "name": "chewingutil.IsPreferIntervalConnted#1084",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.IsPreferIntervalConnted( int cursor, ChewingData *pgdata )",
        "snippet": "int IsPreferIntervalConnted( int cursor, ChewingData *pgdata )\n{\n\tint i;\n\n\tfor ( i = 0; i < pgdata->nPrefer; i++ ) {\n\t\tif (\n\t\t\tpgdata->preferInterval[ i ].from < cursor &&\n\t\t\tpgdata->preferInterval[ i ].to > cursor )\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "begin_line": 1084,
        "end_line": 1095,
        "is_bug": false
    },
    {
        "name": "chewingutil.KillCharInSelectIntervalAndBrkpt#1024",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.KillCharInSelectIntervalAndBrkpt( ChewingData *pgdata, int cursorToKill )",
        "snippet": "static int KillCharInSelectIntervalAndBrkpt( ChewingData *pgdata, int cursorToKill )\n{\n\tint i;\n\n\tfor ( i = 0; i < pgdata->nSelect; i++ ) {\n\t\tif ( pgdata->selectInterval[ i ].from <= cursorToKill &&\n\t\t\tpgdata->selectInterval[ i ].to > cursorToKill ) {\n\t\t\tRemoveSelectElement( i, pgdata );\n\t\t\ti--;      /* the last one was swap to i, we need to recheck i */\n\t\t}\n\t\telse if( pgdata->selectInterval[ i ].from > cursorToKill ) {\n\t\t\tpgdata->selectInterval[ i ].from--;\n\t\t\tpgdata->selectInterval[ i ].to--;\n\t\t}\n\t}\n\tassert ( pgdata->nPhoneSeq >= cursorToKill );\n\tmemmove(\n\t\t&( pgdata->bUserArrBrkpt[ cursorToKill ] ),\n\t\t&( pgdata->bUserArrBrkpt[ cursorToKill + 1 ] ),\n\t\tsizeof( int ) * ( pgdata->nPhoneSeq - cursorToKill ) );\n\tmemmove(\n\t\t&( pgdata->bUserArrCnnct[ cursorToKill ] ),\n\t\t&( pgdata->bUserArrCnnct[ cursorToKill + 1 ] ),\n\t\tsizeof( int ) * ( pgdata->nPhoneSeq - cursorToKill ) );\n\n\treturn 0;\n}",
        "begin_line": 1024,
        "end_line": 1050,
        "is_bug": false
    },
    {
        "name": "chewingutil.KillFromLeft#499",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.KillFromLeft( ChewingData *pgdata, int nKill )",
        "snippet": "static void KillFromLeft( ChewingData *pgdata, int nKill )\n{\n\tint i;\n\n\tfor ( i = 0; i < nKill; i++ )\n\t\tChewingKillChar( pgdata, 0, DECREASE_CURSOR );\n}",
        "begin_line": 499,
        "end_line": 505,
        "is_bug": false
    },
    {
        "name": "chewingutil.MakeOutput#890",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.MakeOutput( ChewingOutput *pgo, ChewingData *pgdata )",
        "snippet": "int MakeOutput( ChewingOutput *pgo, ChewingData *pgdata )\n{\n\tint i;\n\tchar *pos;\n\n\t/* fill zero to chiSymbolBuf first */\n\tpgo->preeditBuf[0] = 0;\n\tpgo->bopomofoBuf[0] = 0;\n\n\tpos = pgo->preeditBuf;\n\tfor ( i = 0; i < pgdata->chiSymbolBufLen &&\n\t\tpos < pgo->preeditBuf + sizeof( pgo->preeditBuf ) + MAX_UTF8_SIZE + 1; ++i ) {\n\t\tstrncpy( pos, pgdata->preeditBuf[ i ].char_, MAX_UTF8_SIZE + 1 );\n\t\tpos += strlen( pgdata->preeditBuf[ i ].char_ );\n\t}\n\n\t/* fill point */\n\tpgo->PointStart = pgdata->PointStart;\n\tpgo->PointEnd = pgdata->PointEnd;\n\n\t/* fill other fields */\n\tpgo->chiSymbolBufLen = pgdata->chiSymbolBufLen;\n\tpgo->chiSymbolCursor = pgdata->chiSymbolCursor;\n\n\t/* fill zuinBuf */\n\tif ( pgdata->zuinData.kbtype >= KB_HANYU_PINYIN ) {\n\t\tstrcpy( pgo->bopomofoBuf, pgdata->zuinData.pinYinData.keySeq );\n\t} else {\n\t\tfor ( i = 0; i < ZUIN_SIZE; i++ ) {\n\t\t\tif ( pgdata->zuinData.pho_inx[ i ] != 0 ) {\n\t\t\t\tueStrNCpy( pgo->bopomofoBuf + strlen( pgo->bopomofoBuf ),\n\t\t\t\t\tueConstStrSeek( (zhuin_tab[ i ] + 2),\n\t\t\t\t\t\tpgdata->zuinData.pho_inx[ i ] - 1 ),\n\t\t\t\t\t1, STRNCPY_CLOSE );\n\t\t\t}\n\t\t}\n\t}\n\n\tShiftInterval( pgo, pgdata );\n\tmemcpy(\n\t\tpgo->dispBrkpt, pgdata->bUserArrBrkpt,\n\t\tsizeof( pgo->dispBrkpt[ 0 ] ) * ( MAX_PHONE_SEQ_LEN + 1 ) );\n\tpgo->pci = &( pgdata->choiceInfo );\n\tpgo->bChiSym = pgdata->bChiSym;\n\tmemcpy( pgo->selKey, pgdata->config.selKey, sizeof( pgdata->config.selKey ) );\n\tpgdata->bShowMsg = 0;\n\treturn 0;\n}",
        "begin_line": 890,
        "end_line": 937,
        "is_bug": false
    },
    {
        "name": "chewingutil.MakeOutputWithRtn#939",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.MakeOutputWithRtn( ChewingOutput *pgo, ChewingData *pgdata, int keystrokeRtn )",
        "snippet": "int MakeOutputWithRtn( ChewingOutput *pgo, ChewingData *pgdata, int keystrokeRtn )\n{\n\tpgo->keystrokeRtn = keystrokeRtn;\n\treturn MakeOutput( pgo, pgdata );\n}",
        "begin_line": 939,
        "end_line": 943,
        "is_bug": false
    },
    {
        "name": "chewingutil.MakePreferInterval#824",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.MakePreferInterval( ChewingData *pgdata )",
        "snippet": "static void MakePreferInterval( ChewingData *pgdata )\n{\n\tint i, j, set_no;\n\tint belong_set[ MAX_PHONE_SEQ_LEN + 1 ];\n\tint parent[ MAX_PHONE_SEQ_LEN + 1 ];\n\n\tmemset( belong_set, 0 , sizeof( int ) * ( MAX_PHONE_SEQ_LEN + 1 ) );\n\tmemset( parent, 0, sizeof( int ) * ( MAX_PHONE_SEQ_LEN + 1 ) );\n\n\t/* for each interval */\n\tfor ( i = 0; i < pgdata->phrOut.nDispInterval; i++ ) {\n\t\tfor (\n\t\t\tj = pgdata->phrOut.dispInterval[ i ].from;\n\t\t\tj < pgdata->phrOut.dispInterval[ i ].to;\n\t\t\tj++ ) {\n\t\t\tbelong_set[ j ] = i + 1;\n\t\t}\n\t}\n\tset_no = i + 1;\n\tfor ( i = 0; i < pgdata->nPhoneSeq; i++ )\n\t\tif ( belong_set[i] == 0 )\n\t\t\tbelong_set[ i ] = set_no++;\n\n\t/* for each connect point */\n\tfor ( i = 1; i < pgdata->nPhoneSeq; i++ ) {\n\t\tif ( pgdata->bUserArrCnnct[ i ] ) {\n\t\t\tUnion( belong_set[ i - 1 ], belong_set[ i ], parent );\n\t\t}\n\t}\n\n\t/* generate new intervals */\n\tpgdata->nPrefer = 0;\n\ti = 0;\n\twhile ( i < pgdata->nPhoneSeq ) {\n\t\tfor ( j = i + 1; j < pgdata->nPhoneSeq; j++ )\n\t\t\tif ( ! SameSet( belong_set[ i ], belong_set[ j ], parent ) )\n\t\t\t\tbreak;\n\n\t\tpgdata->preferInterval[ pgdata->nPrefer ].from = i;\n\t\tpgdata->preferInterval[ pgdata->nPrefer ].to = j;\n\t\tpgdata->nPrefer++;\n\t\ti = j;\n\t}\n}",
        "begin_line": 824,
        "end_line": 867,
        "is_bug": false
    },
    {
        "name": "chewingutil.OpenSymbolChoice#1268",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.OpenSymbolChoice( ChewingData *pgdata )",
        "snippet": "int OpenSymbolChoice( ChewingData *pgdata )\n{\n\tint i, symbol_buf_len = ARRAY_SIZE( symbol_buf );\n\tconst char * const *pBuf;\n\tChoiceInfo *pci = &( pgdata->choiceInfo );\n\tpci->oldChiSymbolCursor = pgdata->chiSymbolCursor;\n\n\t/* see if there is some word in the cursor position */\n\tif ( pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen )\n\t\tpgdata->chiSymbolCursor--;\n\tif ( pgdata->symbolKeyBuf[ pgdata->chiSymbolCursor ] == '1' ) {\n\t\tpgdata->bSelect = 1;\n\t\tHaninSymbolInput( pgdata );\n\t\treturn 0;\n\t}\n\tfor ( i = 0; i < symbol_buf_len; i++ ) {\n\t\tif ( symbol_buf[ i ][ 0 ][ 0 ] ==\n\t\t\t\tpgdata->symbolKeyBuf[ pgdata->chiSymbolCursor ] ) {\n\t\t\tpBuf = symbol_buf[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ( i == symbol_buf_len ) {\n\t\tChoiceEndChoice( pgdata );\n\t\treturn 0;\n\t}\n\tpci->nTotalChoice = 0;\n\tfor ( i = 1; pBuf[ i ]; i++ ) {\n\t\tueStrNCpy( pci->totalChoiceStr[ pci->nTotalChoice ],\n\t\t\t\tpBuf[ i ], ueStrLen( pBuf[i] ), 1 );\n\t\tpci->nTotalChoice++;\n\t}\n\n\tpci->nChoicePerPage = pgdata->config.candPerPage;\n\tassert( pci->nTotalChoice > 0 );\n\tpci->nPage = CEIL_DIV( pci->nTotalChoice, pci->nChoicePerPage );\n\tpci->pageNo = 0;\n\tpci->isSymbol = SYMBOL_CHOICE_UPDATE;\n\n\tpgdata->bSelect = 1;\n\tpgdata->availInfo.nAvail = 1;\n\tpgdata->availInfo.currentAvail = 0;\n\tpgdata->availInfo.avail[ 0 ].id = NULL;\n\tpgdata->availInfo.avail[ 0 ].len = 1;\n\treturn 0;\n}",
        "begin_line": 1268,
        "end_line": 1313,
        "is_bug": false
    },
    {
        "name": "chewingutil.PhoneSeqCursor#992",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.PhoneSeqCursor( ChewingData *pgdata )",
        "snippet": "int PhoneSeqCursor( ChewingData *pgdata )\n{\n\tint cursor = pgdata->chiSymbolCursor - CountSymbols( pgdata, pgdata->chiSymbolCursor );\n\treturn cursor > 0 ? cursor : 0;\n}",
        "begin_line": 992,
        "end_line": 996,
        "is_bug": false
    },
    {
        "name": "chewingutil.ReleaseChiSymbolBuf#531",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ReleaseChiSymbolBuf( ChewingData *pgdata, ChewingOutput *pgo )",
        "snippet": "int ReleaseChiSymbolBuf( ChewingData *pgdata, ChewingOutput *pgo )\n{\n\tint throwEnd;\n\n\tthrowEnd = CountReleaseNum( pgdata );\n\n\t/*\n\t* When current buffer size exceeds maxChiSymbolLen,\n\t* we need to throw some of the characters at the head of the buffer and\n\t* commit them.\n\t*/\n\tif ( throwEnd ) {\n\t\t/*\n\t\t * count how many chinese words in \"chiSymbolBuf[ 0 .. (throwEnd - 1)]\"\n\t\t * And release from \"chiSymbolBuf\" && \"phoneSeq\"\n\t\t */\n\t\tWriteChiSymbolToCommitBuf( pgdata, pgo, throwEnd );\n\t\tKillFromLeft( pgdata, throwEnd );\n\t}\n\treturn throwEnd;\n}",
        "begin_line": 531,
        "end_line": 551,
        "is_bug": false
    },
    {
        "name": "chewingutil.RemoveSelectElement#1003",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.RemoveSelectElement( int i, ChewingData *pgdata )",
        "snippet": "void RemoveSelectElement( int i, ChewingData *pgdata )\n{\n\tif ( --pgdata->nSelect == i )\n\t\treturn;\n\tpgdata->selectInterval[ i ] = pgdata->selectInterval[ pgdata->nSelect ];\n\tstrcpy( pgdata->selectStr[ i ], pgdata->selectStr[ pgdata->nSelect ] );\n}",
        "begin_line": 1003,
        "end_line": 1009,
        "is_bug": false
    },
    {
        "name": "chewingutil.SameSet#812",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.SameSet( int set1, int set2, int parent[] )",
        "snippet": "static int SameSet( int set1,int set2, int parent[] )\n{\n\twhile ( parent[ set1 ] != 0 ) {\n\t\tset1 = parent[ set1 ];\n\t}\n\twhile ( parent[ set2 ] != 0 ) {\n\t\tset2 = parent[ set2 ];\n\t}\n\treturn ( set1 == set2 );\n}",
        "begin_line": 812,
        "end_line": 821,
        "is_bug": false
    },
    {
        "name": "chewingutil.ShiftInterval#870",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ShiftInterval( ChewingOutput *pgo, ChewingData *pgdata )",
        "snippet": "static void ShiftInterval( ChewingOutput *pgo, ChewingData *pgdata )\n{\n\tint i, arrPos[ MAX_PHONE_SEQ_LEN ], k = 0, from, len;\n\n\tfor ( i = 0; i < pgdata->chiSymbolBufLen; i++ ) {\n\t\tif ( ChewingIsChiAt( i, pgdata ) ) {\n\t\t\tarrPos[ k++ ] = i;\n\t\t}\n\t}\n\tarrPos[ k ] = i;\n\n\tpgo->nDispInterval = pgdata->nPrefer;\n\tfor ( i = 0; i < pgdata->nPrefer; i++ ) {\n\t\tfrom = pgdata->preferInterval[ i ].from;\n\t\tlen = pgdata->preferInterval[ i ].to - from;\n\t\tpgo->dispInterval[ i ].from = arrPos[ from ];\n\t\tpgo->dispInterval[ i ].to = arrPos[ from ] + len;\n\t}\n}",
        "begin_line": 870,
        "end_line": 888,
        "is_bug": false
    },
    {
        "name": "chewingutil.ShowChewingData#720",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ShowChewingData( ChewingData *pgdata )",
        "snippet": "static void ShowChewingData( ChewingData *pgdata )\n{\n\tint i ;\n\n\tDEBUG_OUT(\n\t\t\"nPhoneSeq : %d\\n\"\n\t\t\"phoneSeq  : \",\n\t\tpgdata->nPhoneSeq );\n\tfor ( i = 0; i < pgdata->nPhoneSeq; i++ )\n\t\tDEBUG_OUT( \"%hu \", pgdata->phoneSeq[ i ] );\n\tDEBUG_OUT(\n\t\t\"[cursor : %d]\\n\"\n\t\t\"nSelect : %d\\n\"\n\t\t\"selectStr       selectInterval\\n\",\n\t\tPhoneSeqCursor( pgdata ),\n\t\tpgdata->nSelect );\n\tfor ( i = 0; i < pgdata->nSelect; i++ ) {\n\t\tDEBUG_OUT(\n\t\t\t\"  %14s%4d%4d\\n\",\n\t\t\tpgdata->selectStr[ i ],\n\t\t\tpgdata->selectInterval[ i ].from,\n\t\t\tpgdata->selectInterval[ i ].to );\n\t}\n\n\tDEBUG_OUT( \"bUserArrCnnct : \" );\n\tfor ( i = 0; i <= pgdata->nPhoneSeq; i++ )\n\t\tDEBUG_OUT( \"%d \", pgdata->bUserArrCnnct[ i ] );\n\tDEBUG_OUT( \"\\n\" );\n\n\tDEBUG_OUT( \"bUserArrBrkpt : \" );\n\tfor ( i = 0; i <= pgdata->nPhoneSeq; i++ )\n\t\tDEBUG_OUT( \"%d \", pgdata->bUserArrBrkpt[ i ] );\n\tDEBUG_OUT( \"\\n\" );\n\n\tDEBUG_OUT( \"bArrBrkpt     : \" );\n\tfor ( i = 0; i <= pgdata->nPhoneSeq; i++ )\n\t\tDEBUG_OUT( \"%d \", pgdata->bArrBrkpt[ i ] );\n\tDEBUG_OUT( \"\\n\" );\n\n\tDEBUG_OUT(\n\t\t\"bChiSym : %d , bSelect : %d\\n\",\n\t\tpgdata->bChiSym,\n\t\tpgdata->bSelect );\n}",
        "begin_line": 720,
        "end_line": 763,
        "is_bug": false
    },
    {
        "name": "chewingutil.SpecialSymbolInput#202",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.SpecialSymbolInput( int key, ChewingData *pgdata )",
        "snippet": "int SpecialSymbolInput( int key, ChewingData *pgdata )\n{\n\tstatic const char keybuf[] = {\n\t\t'[', ']', '{', '}', '\\'','<', ':', '\\\"', '>',\n\t\t'~', '!', '@', '#', '$', '%', '^', '&', '*',\n\t\t'(', ')', '_', '+', '=','\\\\', '|', '?',\n\t\t',', '.', ';'\n\t};\n\n\tstatic const char * const chibuf[] = {\n\t\t\"\\xE3\\x80\\x8C\", \"\\xE3\\x80\\x8D\", \"\\xE3\\x80\\x8E\", \"\\xE3\\x80\\x8F\",\n\t\t\t/* \"\u300c\", \"\u300d\", \"\u300e\", \"\u300f\" */\n\t\t\"\\xE3\\x80\\x81\", \"\\xEF\\xBC\\x8C\", \"\\xEF\\xBC\\x9A\", \"\\xEF\\xBC\\x9B\",\n\t\t\t/* \"\u3001\", \"\uff0c\", \"\uff1a\", \"\uff1b\" */\n\t\t\"\\xE3\\x80\\x82\", \"\\xEF\\xBD\\x9E\", \"\\xEF\\xBC\\x81\", \"\\xEF\\xBC\\xA0\",\n\t\t\t/* \"\u3002\", \"\uff5e\", \"\uff01\", \"\uff20\" */\n\t\t\"\\xEF\\xBC\\x83\", \"\\xEF\\xBC\\x84\", \"\\xEF\\xBC\\x85\", \"\\xEF\\xB8\\xBF\",\n\t\t\t/* \"\uff03\", \"\uff04\", \"\uff05\", \"\ufe3f\" */\n\t\t\"\\xEF\\xBC\\x86\", \"\\xEF\\xBC\\x8A\", \"\\xEF\\xBC\\x88\", \"\\xEF\\xBC\\x89\",\n\t\t\t/* \"\uff06\", \"\uff0a\", \"\uff08\", \"\uff09\" */\n\t\t\"\\xE2\\x80\\x94\", \"\\xEF\\xBC\\x8B\", \"\\xEF\\xBC\\x9D\", \"\\xEF\\xBC\\xBC\",\n\t\t\t/* \"\u2014\", \"\uff0b\", \"\uff1d\", \"\uff3c\" */\n\t\t\"\\xEF\\xBD\\x9C\", \"\\xEF\\xBC\\x9F\", \"\\xEF\\xBC\\x8C\", \"\\xE3\\x80\\x82\",\n\t\t\t/* \"\uff5c\", \"\uff1f\", \"\uff0c\", \"\u3002\" */\n\t\t\"\\xEF\\xBC\\x9B\"\n\t\t\t/* \"\uff1b\" */\n\t};\n\tSTATIC_ASSERT( ARRAY_SIZE( keybuf ) == ARRAY_SIZE( chibuf ) );\n\n\treturn InternalSpecialSymbol( key, pgdata, ARRAY_SIZE( keybuf ), keybuf, chibuf );\n}\n\nint FullShapeSymbolInput( int key, ChewingData *pgdata )",
        "begin_line": 202,
        "end_line": 232,
        "is_bug": false
    },
    {
        "name": "chewingutil.SymbolChoice#323",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.SymbolChoice( ChewingData *pgdata, int sel_i )",
        "snippet": "int SymbolChoice( ChewingData *pgdata, int sel_i )\n{\n\tint kbtype;\n\tint i;\n\tint symbol_type;\n\tint key;\n\n\tif ( ! pgdata->static_data.symbol_table && pgdata->choiceInfo.isSymbol != SYMBOL_CHOICE_UPDATE )\n\t\treturn ZUIN_ABSORB;\n\n\tif ( pgdata->choiceInfo.isSymbol == SYMBOL_CATEGORY_CHOICE &&\n\t\t\t0 == pgdata->static_data.symbol_table[sel_i]->nSymbols )\n\t\tsymbol_type = SYMBOL_CHOICE_INSERT;\n\telse\n\t\tsymbol_type = pgdata->choiceInfo.isSymbol;\n\n\t/* level one, symbol category */\n\tif ( symbol_type == SYMBOL_CATEGORY_CHOICE ) {\n\t\tChoiceInfo* pci = &pgdata->choiceInfo;\n\t\tAvailInfo* pai = &pgdata->availInfo;\n\n\t\t/* Display all symbols in this category */\n\t\tpci->nTotalChoice = 0;\n\t\tfor ( i = 0; i < pgdata->static_data.symbol_table[ sel_i ]->nSymbols; i++ ) {\n\t\t\tueStrNCpy( pci->totalChoiceStr[ pci->nTotalChoice ],\n\t\t\t\t\tpgdata->static_data.symbol_table[ sel_i ]->symbols[ i ], 1, 1 );\n\t\t\tpci->nTotalChoice++;\n\t\t}\n\t\tpai->avail[ 0 ].len = 1;\n\t\tpai->avail[ 0 ].id = NULL;\n\t\tpai->nAvail = 1;\n\t\tpai->currentAvail = 0;\n\t\tpci->nChoicePerPage = pgdata->config.candPerPage;\n\t\tassert( pci->nTotalChoice > 0 );\n\t\tpci->nPage = CEIL_DIV( pci->nTotalChoice, pci->nChoicePerPage );\n\t\tpci->pageNo = 0;\n\t\tpci->isSymbol = SYMBOL_CHOICE_INSERT;\n\t}\n\telse { /* level 2 symbol or OpenSymbolChoice */\n\t\t/* TODO: FIXME, this part is buggy! */\n\t\tPreeditBuf *buf = &pgdata->preeditBuf[ pgdata->chiSymbolCursor ];\n\n\t\tif ( symbol_type == SYMBOL_CHOICE_INSERT ) {\n\t\t\tassert( pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen );\n\n\t\t\tmemmove( &pgdata->preeditBuf[ pgdata->chiSymbolCursor + 1 ],\n\t\t\t\t&pgdata->preeditBuf[ pgdata->chiSymbolCursor ],\n\t\t\t\tsizeof( pgdata->preeditBuf[ 0 ] ) *\n\t\t\t\t( pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor ) );\n\t\t}\n\t\tstrncpy( buf->char_,\n\t\t\tpgdata->choiceInfo.totalChoiceStr[ sel_i ],\n\t\t\tsizeof( buf->char_) );\n\t\tbuf->category = CHEWING_SYMBOL;\n\n\t\t/* This is very strange */\n\t\tkey = FindSymbolKey( pgdata->choiceInfo.totalChoiceStr[ sel_i ] );\n\t\tpgdata->symbolKeyBuf[ pgdata->chiSymbolCursor ] = key ? key : '0';\n\n\t\tpgdata->bUserArrCnnct[ PhoneSeqCursor( pgdata ) ] = 0;\n\t\tChoiceEndChoice(pgdata);\n\t\t/* Don't forget the kbtype */\n\t\tkbtype = pgdata->zuinData.kbtype;\n\t\tmemset( &( pgdata->zuinData ), 0, sizeof( ZuinData ) );\n\t\tpgdata->zuinData.kbtype = kbtype;\n\n\t\tif ( symbol_type == SYMBOL_CHOICE_INSERT ) {\n\t\t\tpgdata->chiSymbolBufLen++;\n\t\t\tpgdata->chiSymbolCursor ++ ;\n\t\t}\n\n\t\tpgdata->choiceInfo.isSymbol = WORD_CHOICE;\n\t}\n\treturn ZUIN_ABSORB;\n}",
        "begin_line": 323,
        "end_line": 397,
        "is_bug": false
    },
    {
        "name": "chewingutil.SymbolInput#399",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.SymbolInput( int key, ChewingData *pgdata )",
        "snippet": "int SymbolInput( int key, ChewingData *pgdata )\n{\n\tif ( isprint( (char) key ) && /* other character was ignored */\n\t     (pgdata->chiSymbolBufLen < MAX_PHONE_SEQ_LEN) ) { /* protect the buffer */\n\t\tPreeditBuf *buf = &pgdata->preeditBuf[ pgdata->chiSymbolCursor ];\n\n\t\tassert( pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen );\n\n\t\tmemmove( &pgdata->preeditBuf[ pgdata->chiSymbolCursor + 1 ],\n\t\t\t&pgdata->preeditBuf[ pgdata->chiSymbolCursor ],\n\t\t\tsizeof( pgdata->preeditBuf[ 0 ] ) *\n\t\t\t( pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor ) );\n\n\t\tbuf->char_[0] = (char) key;\n\t\tbuf->char_[1] = 0;\n\t\tbuf->category = CHEWING_SYMBOL;\n\n\t\t/* Save Symbol Key */\n\t\tmemmove( &( pgdata->symbolKeyBuf[ pgdata->chiSymbolCursor + 1 ] ),\n\t\t\t&( pgdata->symbolKeyBuf[ pgdata->chiSymbolCursor ] ),\n\t\t\tsizeof( pgdata->symbolKeyBuf[ 0 ] ) *\n\t\t\t( pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor ) );\n\t\t\tpgdata->symbolKeyBuf[ pgdata->chiSymbolCursor ] = toupper( key );\n\n\t\tpgdata->bUserArrCnnct[ PhoneSeqCursor( pgdata ) ] = 0;\n\t\tpgdata->chiSymbolCursor++;\n\t\tpgdata->chiSymbolBufLen++;\n\t\treturn SYMBOL_KEY_OK;\n\t}\n\treturn SYMBOL_KEY_ERROR;\n}",
        "begin_line": 399,
        "end_line": 429,
        "is_bug": false
    },
    {
        "name": "chewingutil.TerminateEasySymbolTable#1497",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.TerminateEasySymbolTable( ChewingData *pgdata )",
        "snippet": "void TerminateEasySymbolTable( ChewingData *pgdata )\n{\n\tunsigned int i;\n\tfor ( i = 0; i < EASY_SYMBOL_KEY_TAB_LEN ; ++i ) {\n\t\tif ( NULL != pgdata->static_data.g_easy_symbol_value[ i ] ) {\n\t\t\tfree( pgdata->static_data.g_easy_symbol_value[ i ] );\n\t\t\tpgdata->static_data.g_easy_symbol_value[ i ] = NULL;\n\t\t}\n\t\tpgdata->static_data.g_easy_symbol_num[ i ] = 0;\n\t}\n}",
        "begin_line": 1497,
        "end_line": 1507,
        "is_bug": false
    },
    {
        "name": "chewingutil.TerminateSymbolTable#1425",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.TerminateSymbolTable( ChewingData *pgdata )",
        "snippet": "void TerminateSymbolTable( ChewingData *pgdata )\n{\n\tunsigned int i;\n\tif ( pgdata->static_data.symbol_table ) {\n\t\tfor ( i = 0; i < pgdata->static_data.n_symbol_entry; ++i )\n\t\t\tfree( pgdata->static_data.symbol_table[ i ] );\n\t\tfree( pgdata->static_data.symbol_table );\n\t\tpgdata->static_data.n_symbol_entry = 0;\n\t\tpgdata->static_data.symbol_table = NULL;\n\t}\n}",
        "begin_line": 1425,
        "end_line": 1435,
        "is_bug": false
    },
    {
        "name": "chewingutil.Union#806",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.Union( int set1, int set2, int parent[] )",
        "snippet": "static void Union( int set1,int set2, int parent[] )\n{\n\tif ( set1 != set2 )\n\t\tparent[ max( set1, set2 ) ] = min( set1, set2 );\n}",
        "begin_line": 806,
        "end_line": 810,
        "is_bug": false
    },
    {
        "name": "chewingutil.WriteChiSymbolToCommitBuf#449",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.WriteChiSymbolToCommitBuf( ChewingData *pgdata, ChewingOutput *pgo, int len )",
        "snippet": "void WriteChiSymbolToCommitBuf( ChewingData *pgdata, ChewingOutput *pgo, int len )\n{\n\tint i;\n\tchar *pos;\n\n\tassert( pgdata );\n\tassert( pgo );\n\n\tpgo->commitBufLen = len;\n\n\tpos = pgo->commitBuf;\n\tfor ( i = 0; i < pgo->commitBufLen; ++i ) {\n\t\tassert( pos + MAX_UTF8_SIZE + 1 < pgo->commitBuf + sizeof( pgo->commitBuf ) );\n\t\tstrcpy( pos, pgdata->preeditBuf[ i ].char_ );\n\t\tpos += strlen( pgdata->preeditBuf[ i ].char_ );\n\t}\n\t*pos = 0;\n}",
        "begin_line": 449,
        "end_line": 466,
        "is_bug": false
    },
    {
        "name": "chewingutil._Inner_InternalSpecialSymbol#147",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil._Inner_InternalSpecialSymbol( \t\tint key, ChewingData *pgdata, char symkey, const char * const chibuf )",
        "snippet": "static int _Inner_InternalSpecialSymbol(\n\t\tint key, ChewingData *pgdata,\n\t\tchar symkey, const char * const chibuf )\n{\n\tint kbtype;\n\tPreeditBuf *buf;\n\n\tif ( key == symkey && NULL != chibuf ) {\n\t\tassert( pgdata->chiSymbolBufLen >= pgdata->chiSymbolCursor );\n\n\t\tbuf = &pgdata->preeditBuf[ pgdata->chiSymbolCursor ];\n\n\t\tmemmove( &pgdata->preeditBuf[ pgdata->chiSymbolCursor + 1 ],\n\t\t\t&pgdata->preeditBuf[ pgdata->chiSymbolCursor ],\n\t\t\tsizeof( pgdata->preeditBuf[ 0 ] ) *\n\t\t\t( pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor ) );\n\n\t\tstrncpy( buf->char_, chibuf, sizeof( buf->char_) );\n\t\tbuf->category = CHEWING_SYMBOL;\n\n\t\t/* Save Symbol Key */\n\t\tmemmove(\n\t\t\t&( pgdata->symbolKeyBuf[ pgdata->chiSymbolCursor + 1 ] ),\n\t\t\t&( pgdata->symbolKeyBuf[ pgdata->chiSymbolCursor ] ),\n\t\t\tsizeof( pgdata->symbolKeyBuf[0] ) *\n\t\t\t( pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor ) );\n\t\tpgdata->symbolKeyBuf[ pgdata->chiSymbolCursor ] = key;\n\t\tpgdata->bUserArrCnnct[ PhoneSeqCursor( pgdata ) ] = 0;\n\t\tpgdata->chiSymbolCursor++;\n\t\tpgdata->chiSymbolBufLen++;\n\t\t/* reset Zuin data */\n\t\t/* Don't forget the kbtype */\n\t\tkbtype = pgdata->zuinData.kbtype;\n\t\tmemset( &( pgdata->zuinData ), 0, sizeof( ZuinData ) );\n\t\tpgdata->zuinData.kbtype = kbtype;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "begin_line": 147,
        "end_line": 185,
        "is_bug": false
    },
    {
        "name": "chewingutil.copyStringFromPreeditBuf#1509",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.copyStringFromPreeditBuf( \tChewingData *pgdata, int pos, int len, char *output, int output_len )",
        "snippet": "void copyStringFromPreeditBuf(\n\tChewingData *pgdata, int pos, int len,\n\tchar *output, int output_len )\n{\n\tint i;\n\tint x;\n\n\tassert( pgdata );\n\tassert( 0 <= pos && pos + len < ARRAY_SIZE( pgdata->preeditBuf ) );\n\tassert( output );\n\tassert( output_len );\n\n\tLOG_VERBOSE(\"Copy pos %d, len %d from preeditBuf\", pos, len);\n\n\tfor ( i = pos; i < pos + len; ++i ) {\n\t\tx = strlen( pgdata->preeditBuf[ i ].char_ );\n\t\tif ( x >= output_len ) // overflow\n\t\t\treturn;\n\t\tmemcpy( output, pgdata->preeditBuf[ i ].char_, x );\n\t\toutput += x;\n\t\toutput_len -= x;\n\t}\n\toutput[0] = 0;\n}",
        "begin_line": 1509,
        "end_line": 1532,
        "is_bug": false
    },
    {
        "name": "chewingutil.toPreeditBufIndex#1538",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.toPreeditBufIndex( ChewingData *pgdata, int pos )",
        "snippet": "int toPreeditBufIndex( ChewingData *pgdata, int pos )\n{\n\tint word_count;\n\tint i;\n\n\tassert( pgdata );\n\tassert( 0 <= pos && pos <= MAX_CHI_SYMBOL_LEN );\n\n\tfor ( i = 0, word_count = 0 ; i < MAX_CHI_SYMBOL_LEN ; ++i ) {\n\t\tif ( ChewingIsChiAt( i, pgdata ) )\n\t\t\t++word_count;\n\n\t\t/*\n\t\t * pos = 0 means finding the first word, so we need to add one\n\t\t * here.\n\t\t */\n\t\tif ( word_count == pos + 1 )\n\t\t\tbreak;\n\t}\n\n\tLOG_VERBOSE( \"translate phoneSeq index %d to preeditBuf index %d\",\n\t\tpos, i );\n\n\treturn i;\n}",
        "begin_line": 1538,
        "end_line": 1562,
        "is_bug": false
    },
    {
        "name": "choice.ChangeSelectIntervalAndBreakpoint#33",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChangeSelectIntervalAndBreakpoint( \t\tChewingData *pgdata, int from, int to, const char *str )",
        "snippet": "static void ChangeSelectIntervalAndBreakpoint(\n\t\tChewingData *pgdata,\n\t\tint from,\n\t\tint to,\n\t\tconst char *str )\n{\n\tint i;\n\tint user_alloc;\n\n\tIntervalType inte;\n\n\tinte.from = from;\n\tinte.to = to;\n\tfor ( i = 0; i < pgdata->nSelect; i++ ) {\n\t\tif ( IsIntersect( inte, pgdata->selectInterval[ i ] ) ) {\n\t\t\tRemoveSelectElement( i, pgdata );\n\t\t\ti--;\n\t\t}\n\t}\n\n\tpgdata->selectInterval[ pgdata->nSelect ].from = from;\n\tpgdata->selectInterval[ pgdata->nSelect ].to = to;\n\n\t/* No available selection */\n\tif ( ( user_alloc = ( to - from ) ) == 0 )\n\t\treturn;\n\n\tueStrNCpy( pgdata->selectStr[ pgdata->nSelect ],\n\t\t\tstr,\n\t\t\tuser_alloc, 1);\n\tpgdata->nSelect++;\n\n\tif ( user_alloc > 1 ) {\n\t\tmemset( &pgdata->bUserArrBrkpt[ from + 1 ], 0, sizeof( int ) * ( user_alloc - 1 ) );\n\t\tmemset( &pgdata->bUserArrCnnct[ from + 1 ], 0, sizeof( int ) * ( user_alloc - 1 ) );\n\t}\n}",
        "begin_line": 33,
        "end_line": 69,
        "is_bug": false
    },
    {
        "name": "choice.ChangeUserData#493",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChangeUserData( ChewingData *pgdata, int selectNo )",
        "snippet": "static void ChangeUserData( ChewingData *pgdata, int selectNo )\n{\n\tuint16_t userPhoneSeq[ MAX_PHONE_SEQ_LEN ];\n\tint len;\n\n\tlen = ueStrLen( pgdata->choiceInfo.totalChoiceStr[ selectNo ] );\n\tmemcpy(\n\t\tuserPhoneSeq,\n\t\t&( pgdata->phoneSeq[ PhoneSeqCursor( pgdata ) ] ),\n\t\tlen * sizeof( uint16_t ) );\n\tuserPhoneSeq[ len ] = 0;\n\tUserUpdatePhrase( pgdata, userPhoneSeq, pgdata->choiceInfo.totalChoiceStr[ selectNo ] );\n}",
        "begin_line": 493,
        "end_line": 505,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceEndChoice#478",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceEndChoice( ChewingData *pgdata )",
        "snippet": "int ChoiceEndChoice( ChewingData *pgdata )\n{\n\tpgdata->bSelect = 0;\n\tpgdata->choiceInfo.nTotalChoice = 0;\n\tpgdata->choiceInfo.nPage = 0;\n\n\tif ( pgdata->choiceInfo.isSymbol != WORD_CHOICE || pgdata->choiceInfo.isSymbol != SYMBOL_CHOICE_INSERT ) {\n\t\t/* return to the old chiSymbolCursor position */\n\t\tpgdata->chiSymbolCursor = pgdata->choiceInfo.oldChiSymbolCursor;\n\t\tassert ( pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen );\n\t}\n\tpgdata->choiceInfo.isSymbol = WORD_CHOICE;\n\treturn 0;\n}",
        "begin_line": 478,
        "end_line": 491,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceFirstAvail#403",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceFirstAvail( ChewingData *pgdata )",
        "snippet": "int ChoiceFirstAvail( ChewingData *pgdata )\n{\n\tassert( pgdata );\n\tassert( pgdata->bSelect );\n\n\tif ( pgdata->choiceInfo.isSymbol != WORD_CHOICE ) return 0;\n\n\tpgdata->availInfo.currentAvail = pgdata->availInfo.nAvail - 1;\n\tSetChoiceInfo( pgdata );\n\n\treturn 0;\n}",
        "begin_line": 403,
        "end_line": 414,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceHasNextAvail#429",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceHasNextAvail( ChewingData *pgdata )",
        "snippet": "int ChoiceHasNextAvail( ChewingData *pgdata )\n{\n\tassert( pgdata );\n\tassert( pgdata->bSelect );\n\n\tif ( pgdata->choiceInfo.isSymbol != WORD_CHOICE ) return 0;\n\n\treturn pgdata->availInfo.currentAvail > 0;\n}",
        "begin_line": 429,
        "end_line": 437,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceInfoAppendChi#180",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceInfoAppendChi( ChewingData *pgdata, ChoiceInfo *pci, uint16_t phone )",
        "snippet": "static void ChoiceInfoAppendChi( ChewingData *pgdata,  ChoiceInfo *pci, uint16_t phone )\n{\n\tPhrase tempWord;\n\tint len;\n\tif ( GetCharFirst( pgdata, &tempWord, phone ) ) {\n\t\tdo {\n\t\t\tlen = ueBytesFromChar( tempWord.phrase[ 0 ] );\n\t\t\tif ( ChoiceTheSame( pci, tempWord.phrase,\n\t\t\t\t\t    len) )\n\t\t\t\tcontinue;\n\t\t\tassert( pci->nTotalChoice < MAX_CHOICE );\n\t\t\tmemcpy(\n\t\t\t\tpci->totalChoiceStr[ pci->nTotalChoice ],\n\t\t\t\ttempWord.phrase, len );\n\t\t\tpci->totalChoiceStr[ pci->nTotalChoice ]\n\t\t\t\t\t   [ len ] = '\\0';\n\t\t\tpci->nTotalChoice++;\n\t\t} while ( GetVocabNext( pgdata, &tempWord ) );\n\t}\n}",
        "begin_line": 180,
        "end_line": 199,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceInitAvail#371",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceInitAvail( ChewingData *pgdata )",
        "snippet": "int ChoiceInitAvail( ChewingData *pgdata )\n{\n\tint end, begin;\n\n\t/* save old cursor position */\n\tpgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;\n\n\t/* see if there is some word in the cursor position */\n\tif ( pgdata->chiSymbolBufLen == pgdata->chiSymbolCursor ) {\n\t\tpgdata->chiSymbolCursor--;\n\t}\n\n\tend = PhoneSeqCursor( pgdata );\n\n\tif ( pgdata->config.bPhraseChoiceRearward ) {\n\t\tpgdata->chiSymbolCursor = SeekPhraseHead( pgdata ) +\n\t\t\tCountSymbols( pgdata, pgdata->chiSymbolCursor );\n\t}\n\tbegin = PhoneSeqCursor( pgdata );\n\n\tpgdata->bSelect = 1;\n\n\tSetAvailInfo( pgdata, begin, end );\n\n\tif ( ! pgdata->availInfo.nAvail )\n\t\treturn ChoiceEndChoice( pgdata );\n\n\tpgdata->availInfo.currentAvail = pgdata->availInfo.nAvail - 1;\n\tSetChoiceInfo( pgdata );\n\treturn 0;\n}",
        "begin_line": 371,
        "end_line": 401,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceNextAvail#464",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceNextAvail( ChewingData *pgdata )",
        "snippet": "int ChoiceNextAvail( ChewingData *pgdata )\n{\n\tassert( pgdata );\n\tassert( pgdata->bSelect );\n\n\tif ( ChoiceHasNextAvail( pgdata ) ) {\n\t\t--pgdata->availInfo.currentAvail;\n\t\tSetChoiceInfo( pgdata );\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}",
        "begin_line": 464,
        "end_line": 476,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceSelect#508",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceSelect( ChewingData *pgdata, int selectNo )",
        "snippet": "int ChoiceSelect( ChewingData *pgdata, int selectNo )\n{\n\tChoiceInfo *pci = &( pgdata->choiceInfo );\n\tAvailInfo *pai = &( pgdata->availInfo );\n\n\tChangeUserData( pgdata, selectNo );\n\tChangeSelectIntervalAndBreakpoint(\n\t\t\tpgdata,\n\t\t\tPhoneSeqCursor( pgdata ),\n\t\t\tPhoneSeqCursor( pgdata ) + pai->avail[ pai->currentAvail ].len,\n\t\t\tpci->totalChoiceStr[ selectNo ] );\n\tChoiceEndChoice( pgdata );\n\treturn 0;\n}",
        "begin_line": 508,
        "end_line": 521,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceTheSame#170",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceTheSame( ChoiceInfo *pci, const char *str, int len )",
        "snippet": "static int ChoiceTheSame( ChoiceInfo *pci, const char *str, int len )\n{\n\tint i;\n\n\tfor ( i = 0; i < pci->nTotalChoice; i++ )\n\t\tif ( ! memcmp( pci->totalChoiceStr[ i ], str, len ) )\n\t\t\treturn 1;\n\treturn 0;\n}",
        "begin_line": 170,
        "end_line": 178,
        "is_bug": false
    },
    {
        "name": "choice.SeekPhraseHead#357",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.SeekPhraseHead( ChewingData *pgdata )",
        "snippet": "static int SeekPhraseHead( ChewingData *pgdata )\n{\n\tint i;\n\tint phoneSeq = PhoneSeqCursor( pgdata );\n\tfor ( i = pgdata->nPrefer - 1; i >= 0; i-- ) {\n\t\tif ( pgdata->preferInterval[ i ].from > phoneSeq\n\t\t\t\t|| pgdata->preferInterval[ i ].to < phoneSeq )\n\t\t\tcontinue;\n\t\treturn pgdata->preferInterval[ i ].from;\n\t}\n\treturn 0;\n}",
        "begin_line": 357,
        "end_line": 368,
        "is_bug": false
    },
    {
        "name": "choice.SetAvailInfo#72",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.SetAvailInfo( ChewingData *pgdata, int begin, int end)",
        "snippet": "static void SetAvailInfo( ChewingData *pgdata, int begin, int end)\n{\n\tAvailInfo *pai = &( pgdata->availInfo );\n\tconst uint16_t *phoneSeq = pgdata->phoneSeq;\n\tint nPhoneSeq = pgdata->nPhoneSeq;\n\tconst int *bSymbolArrBrkpt = pgdata->bSymbolArrBrkpt;\n\tint symbolArrBrkpt[ ARRAY_SIZE(pgdata->bSymbolArrBrkpt) ] = { 0 };\n\n\tconst TreeType *tree_pos;\n\tint diff;\n\tuint16_t userPhoneSeq[ MAX_PHONE_SEQ_LEN ];\n\n\tint i, head, head_tmp;\n\tint tail, tail_tmp;\n\tint pos;\n\n\thead = tail = 0;\n\n\tpai->nAvail = 0;\n\n\t/*\n\t * XXX: The phoneSeq, nPhoneSeq skip any symbol in preedit buffer,\n\t * while bSymbolArrBrkpt, does not skip any symbol in preedit\n\t * buffer. So we need to do some translate here.\n\t */\n\tfor ( i = 0; i < pgdata->chiSymbolBufLen; ++i ) {\n\t\tif ( bSymbolArrBrkpt[i] ) {\n\t\t\t/*\n\t\t\t * XXX: If preedit buffer starts with symbol, the pos\n\t\t\t * will become negative. In this case, we just ignore\n\t\t\t * this symbol because it does not create any break\n\t\t\t * point.\n\t\t\t */\n\t\t\tpos = i - CountSymbols( pgdata, i + 1 );\n\t\t\tif (pos >= 0)\n\t\t\t\tsymbolArrBrkpt[ pos ] = 1;\n\t\t}\n\t}\n\n\tif ( pgdata->config.bPhraseChoiceRearward ) {\n\t\tfor ( i = end; i >= begin; i--){\n\t\t\tif ( symbolArrBrkpt[ i ] )\n\t\t\t\tbreak;\n\t\t\thead = i;\n\t\t}\n\t\thead_tmp = end;\n\t} else {\n\t\thead_tmp = head = begin;\n\t}\n\n\tif ( pgdata->config.bPhraseChoiceRearward ) {\n\t\ttail_tmp = tail = end;\n\t} else {\n\t\tfor ( i = begin; i < nPhoneSeq; i++ ) {\n\t\t\ttail = i;\n\t\t\tif ( symbolArrBrkpt[ i ] )\n\t\t\t\tbreak;\n\t\t}\n\t\ttail_tmp = begin;\n\t}\n\n\twhile ( head <= head_tmp && tail_tmp <= tail ) {\n\t\tdiff = tail_tmp - head_tmp;\n\t\ttree_pos = TreeFindPhrase( pgdata, head_tmp, tail_tmp, phoneSeq );\n\n\t\tif ( tree_pos ) {\n\t\t\t/* save it! */\n\t\t\tpai->avail[ pai->nAvail ].len = diff + 1;\n\t\t\tpai->avail[ pai->nAvail ].id = tree_pos;\n\t\t\tpai->nAvail++;\n\t\t}\n\t\telse {\n\t\t\tmemcpy(\n\t\t\t\tuserPhoneSeq,\n\t\t\t\t&phoneSeq[ head_tmp ],\n\t\t\t\tsizeof( uint16_t ) * ( diff + 1 ) ) ;\n\t\t\tuserPhoneSeq[ diff + 1 ] = 0;\n\t\t\tif ( UserGetPhraseFirst( pgdata, userPhoneSeq ) ) {\n\t\t\t\t/* save it! */\n\t\t\t\tpai->avail[ pai->nAvail ].len = diff + 1;\n\t\t\t\tpai->avail[ pai->nAvail ].id = NULL;\n\t\t\t\tpai->nAvail++;\n\t\t\t} else {\n\t\t\t\tpai->avail[ pai->nAvail ].len = 0;\n\t\t\t\tpai->avail[ pai->nAvail ].id = NULL;\n\t\t\t}\n\t\t\tUserGetPhraseEnd( pgdata, userPhoneSeq );\n\t\t}\n\n\t\tif ( pgdata->config.bPhraseChoiceRearward ) {\n\t\t\thead_tmp--;\n\t\t} else {\n\t\t\ttail_tmp++;\n\t\t}\n\t}\n}",
        "begin_line": 72,
        "end_line": 167,
        "is_bug": false
    },
    {
        "name": "choice.SetChoiceInfo#207",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.SetChoiceInfo( ChewingData *pgdata )",
        "snippet": "static void SetChoiceInfo( ChewingData *pgdata )\n{\n\tPhrase tempPhrase;\n\tint len;\n\tUserPhraseData *pUserPhraseData;\n\tuint16_t userPhoneSeq[ MAX_PHONE_SEQ_LEN ];\n\n\tChoiceInfo *pci = &( pgdata->choiceInfo );\n\tAvailInfo *pai = &( pgdata->availInfo );\n\tuint16_t *phoneSeq = pgdata->phoneSeq;\n\tuint16_t *phoneSeqAlt = pgdata->phoneSeqAlt;\n\tint cursor = PhoneSeqCursor( pgdata );\n\tint candPerPage = pgdata->config.candPerPage;\n\n\t/* Clears previous candidates. */\n\tmemset( pci->totalChoiceStr, '\\0',\n\t\tMAX_CHOICE * MAX_PHRASE_LEN * MAX_UTF8_SIZE + 1);\n\n\tpci->nTotalChoice = 0;\n\tlen = pai->avail[ pai->currentAvail ].len;\n\tassert(len);\n\n\t/* secondly, read tree phrase */\n\tif ( len == 1 ) { /* single character */\n\t\tChoiceInfoAppendChi( pgdata, pci, phoneSeq[ cursor ] );\n\n\t\tif ( phoneSeq[ cursor ] != phoneSeqAlt[ cursor ] ) {\n\t\t\tChoiceInfoAppendChi( pgdata, pci, phoneSeqAlt[ cursor ] );\n\t\t}\n\n\t\tif ( pgdata->zuinData.kbtype == KB_HSU ||\n\t\t     pgdata->zuinData.kbtype == KB_DVORAK_HSU ) {\n\t\t\tswitch ( phoneSeq[ cursor ] ) {\n\t\t\t\tcase 0x2800:\t/* '\u3118' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x30 );\t\t/* '\u311f' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x80:\t/* '\u3127' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x20 );\t\t/* '\u311d' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x2A00:\t/* '\u3119' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1 );\t\t/* '\u02d9' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xA00:\t/* '\u3109' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x2 );\t\t/* '\u02ca' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x800:\t/* '\u3108' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x3 ); \t\t/* '\u02c7' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x18:\t/* '\u311c' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1200 );\t/* '\u310d' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x10:\t/* '\u311b' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1600 );\t/* '\u310f' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x1E00:\t/* '\u3113' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1800 );\t/* '\u3110' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x4 );\t\t/* '\u02cb' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x58:\t/* '\u3124' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1400 );\t/* '\u310e' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x68:\t/* '\u3126' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1000 );\t/* '\u310c' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x60 );\t\t/* '\u3125' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x2200:\t/* '\u3115' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1C00 );\t/* '\u3112' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x2000:\t/* '\u3114' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1A00 );\t/* '\u3111' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x50:\t/* '\u3123' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0xE00 );\t/* '\u310b' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x48:\t/* '\u3122' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x600 );\t/* '\u3107' */\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* phrase */\n\telse {\n\t\tif ( pai->avail[ pai->currentAvail ].id ) {\n\t\t\tGetPhraseFirst( pgdata, &tempPhrase, pai->avail[ pai->currentAvail ].id );\n\t\t\tdo {\n\t\t\t\tif ( ChoiceTheSame(\n\t\t\t\t\tpci,\n\t\t\t\t\ttempPhrase.phrase,\n\t\t\t\t\tlen * ueBytesFromChar( tempPhrase.phrase[0] ) ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tueStrNCpy( pci->totalChoiceStr[ pci->nTotalChoice ],\n\t\t\t\t\t\ttempPhrase.phrase, len, 1);\n\t\t\t\tpci->nTotalChoice++;\n\t\t\t} while( GetVocabNext( pgdata, &tempPhrase ) );\n\t\t}\n\n\t\tmemcpy( userPhoneSeq, &phoneSeq[ cursor ], sizeof( uint16_t ) * len );\n\t\tuserPhoneSeq[ len ] = 0;\n\t\tpUserPhraseData = UserGetPhraseFirst( pgdata, userPhoneSeq );\n\t\tif ( pUserPhraseData ) {\n\t\t\tdo {\n\t\t\t\t/* check if the phrase is already in the choice list */\n\t\t\t\tif ( ChoiceTheSame(\n\t\t\t\t\tpci,\n\t\t\t\t\tpUserPhraseData->wordSeq,\n\t\t\t\t\tlen * ueBytesFromChar( pUserPhraseData->wordSeq[0] ) ) )\n\t\t\t\t\tcontinue;\n\t\t\t\t/* otherwise store it */\n\t\t\t\tueStrNCpy(\n\t\t\t\t\t\tpci->totalChoiceStr[ pci->nTotalChoice ],\n\t\t\t\t\t\tpUserPhraseData->wordSeq,\n\t\t\t\t\t\tlen, 1);\n\t\t\t\tpci->nTotalChoice++;\n\t\t\t} while ( ( pUserPhraseData =\n\t\t\t\t    UserGetPhraseNext( pgdata, userPhoneSeq ) ) != NULL );\n\t\t}\n\t\tUserGetPhraseEnd( pgdata, userPhoneSeq );\n\n\t}\n\n\t/* magic number */\n\tpci->nChoicePerPage = candPerPage;\n\tassert( pci->nTotalChoice > 0 );\n\tpci->nPage = CEIL_DIV( pci->nTotalChoice, pci->nChoicePerPage );\n\tpci->pageNo = 0;\n\tpci->isSymbol = WORD_CHOICE;\n}\n\n/*\n * Seek the start of the phrase (English characters",
        "begin_line": 207,
        "end_line": 352,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueBytesFromChar#42",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueBytesFromChar( unsigned char b )",
        "snippet": "int ueBytesFromChar( unsigned char b )\n{\n\treturn utf8len_tab[ b ];\n}",
        "begin_line": 42,
        "end_line": 45,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueConstStrSeek#69",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueConstStrSeek( const char *src, size_t n )",
        "snippet": "const char *ueConstStrSeek( const char *src, size_t n )\n{\n\tsize_t i = 0;\n\tconst char *iter = src;\n\tfor ( i = 0; i < n; i++ ) {\n\t\titer += ueBytesFromChar( iter[0] );\n\t}\n\treturn iter;\n}",
        "begin_line": 69,
        "end_line": 77,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueStrLen#29",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueStrLen( const char *str )",
        "snippet": "int ueStrLen( const char *str )\n{\n\tint length = 0;\n\tconst char *strptr = str;\n\n\twhile ( strptr[ 0 ] != '\\0' ) {\n\t\tstrptr += ueBytesFromChar( strptr[0] );\n\t\t++length;\n\t}\n\treturn length;\n}",
        "begin_line": 29,
        "end_line": 39,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueStrNBytes#48",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueStrNBytes( const char *str, int n )",
        "snippet": "int ueStrNBytes( const char *str, int n )\n{\n\tint i = 0, len = 0;\n\tconst char *iter = str;\n\tfor ( i = 0; i < n; i++ ) {\n\t\tlen += ueBytesFromChar( iter[ len ] );\n\t}\n\treturn len;\n}",
        "begin_line": 48,
        "end_line": 56,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueStrNCpy#59",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueStrNCpy( char dest[], const char *src, size_t n, int end )",
        "snippet": "int ueStrNCpy( char dest[], const char *src, size_t n, int end )\n{\n\tint len = 0;\n\tlen = ueStrNBytes( src, n );\n\tmemcpy( dest, src, len );\n\tif ( end == STRNCPY_CLOSE )\n\t\tdest[ len ] = '\\0';\n\treturn len;\n}",
        "begin_line": 59,
        "end_line": 67,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueStrSeek#79",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueStrSeek( char *src, size_t n )",
        "snippet": "char *ueStrSeek( char *src, size_t n )\n{\n\tsize_t i = 0;\n\tchar *iter = src;\n\tfor ( i = 0; i < n; i++ ) {\n\t\titer += ueBytesFromChar( iter[0] );\n\t}\n\treturn iter;\n}",
        "begin_line": 79,
        "end_line": 87,
        "is_bug": false
    },
    {
        "name": "common.key2pho.GetPhoneLen#204",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.GetPhoneLen( const uint16_t *phoneSeq )",
        "snippet": "size_t GetPhoneLen( const uint16_t *phoneSeq )\n{\n\tsize_t len = 0;\n\tassert( phoneSeq );\n\n\twhile ( phoneSeq[len] )\n\t\t++len;\n\treturn len;\n}",
        "begin_line": 204,
        "end_line": 212,
        "is_bug": false
    },
    {
        "name": "common.key2pho.PhoneFromKey#128",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.PhoneFromKey( char *pho, const char *inputkey, int kbtype, int searchTimes )",
        "snippet": "int PhoneFromKey( char *pho, const char *inputkey, int kbtype, int searchTimes )\n{\n\tint len = strlen( inputkey ), i, s;\n\tconst char *pTarget;\n\n\tpho[ 0 ] = '\\0';\n\tfor ( i = 0; i < len; i++ ) {\n\t\tchar *findptr = NULL;\n\t\tint _index;\n\n\t\tfor (\n\t\t\t\ts = 0, pTarget = key_str[ kbtype ];\n\t\t\t\ts < searchTimes;\n\t\t\t\ts++, pTarget = findptr + 1 ) {\n\t\t\tfindptr = strchr( pTarget, inputkey[ i ] );\n\t\t\tif ( ! findptr ) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t_index = findptr - key_str[ kbtype ];\n\t\tueStrNCpy( ueStrSeek( pho, i ),\n\t\t           ueConstStrSeek( ph_str, _index ),\n\t\t\t   1, 0);\n\t}\n\tpho = ueStrSeek( pho, len );\n\tpho[0] = '\\0';\n\treturn 1;\n}",
        "begin_line": 128,
        "end_line": 155,
        "is_bug": false
    },
    {
        "name": "common.key2pho.PhoneInxFromKey#180",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.PhoneInxFromKey( int key, int type, int kbtype, int searchTimes )",
        "snippet": "int PhoneInxFromKey( int key, int type, int kbtype, int searchTimes )\n{\n\tchar keyStr[ 2 ], rtStr[ 10 ], *p;\n\n\tkeyStr[ 0 ] = key;\n\tkeyStr[ 1 ] = '\\0';\n\tif ( ! PhoneFromKey( rtStr, keyStr, kbtype, searchTimes ) )\n\t\treturn 0;\n\tp = strstr( zhuin_tab[ type ], rtStr );\n\tif ( ! p )\n\t\treturn 0;\n\treturn zhuin_tab_num[type] - ueStrLen(p);\n}",
        "begin_line": 180,
        "end_line": 192,
        "is_bug": false
    },
    {
        "name": "common.key2pho.UintFromPhone#97",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.UintFromPhone( const char *zhuin )",
        "snippet": "uint16_t UintFromPhone( const char *zhuin )\n{\n\tconst char *iter;\n\tchar *pos;\n\tchar buf[ MAX_UTF8_SIZE + 1 ];\n\tint len, result = 0;\n\tint zhuin_index = 0;\n\n\titer = zhuin;\n\n\twhile ( *iter && *iter != 0x20 ) {\n\t\tlen = ueStrNCpy( buf, iter, 1, STRNCPY_CLOSE );\n\n\t\tfor (; zhuin_index < ZUIN_SIZE; ++zhuin_index ) {\n\t\t\tpos = strstr( zhuin_tab[ zhuin_index ], buf );\n\t\t\tif ( pos ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ( zhuin_index >= ZUIN_SIZE ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tresult |= (zhuin_tab_num[ zhuin_index ] - ueStrLen( pos )) << shift[ zhuin_index ];\n\t\t++zhuin_index;\n\t\titer += len;\n\t}\n\treturn result;\n}",
        "begin_line": 97,
        "end_line": 126,
        "is_bug": false
    },
    {
        "name": "common.key2pho.UintFromPhoneInx#194",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.UintFromPhoneInx( const int ph_inx[] )",
        "snippet": "uint16_t UintFromPhoneInx( const int ph_inx[] )\n{\n\tint i;\n\tuint16_t result = 0;\n\n\tfor ( i = 0; i < ZUIN_SIZE; i++ )\n\t\tresult |= ph_inx[ i ] << shift[ i ];\n\treturn result;\n}",
        "begin_line": 194,
        "end_line": 202,
        "is_bug": false
    },
    {
        "name": "dict.GetCharFirst#72",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.GetCharFirst( ChewingData *pgdata, Phrase *wrd_ptr, uint16_t key )",
        "snippet": "int GetCharFirst( ChewingData *pgdata, Phrase *wrd_ptr, uint16_t key )\n{\n\t/* &key serves as an array whose begin and end are both 0. */\n\tconst TreeType *pinx = TreeFindPhrase( pgdata, 0, 0, &key );\n\n\tif ( ! pinx )\n\t\treturn 0;\n\tTreeChildRange( pgdata, pinx );\n\tGetVocabFromDict( pgdata, wrd_ptr );\n\treturn 1;\n}",
        "begin_line": 72,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "dict.GetPhraseFirst#89",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.GetPhraseFirst( ChewingData *pgdata, Phrase *phr_ptr, const TreeType *phrase_parent )",
        "snippet": "int GetPhraseFirst( ChewingData *pgdata, Phrase *phr_ptr, const TreeType *phrase_parent )\n{\n\tassert( phrase_parent );\n\n\tTreeChildRange( pgdata, phrase_parent );\n\tGetVocabFromDict( pgdata, phr_ptr );\n\treturn 1;\n}",
        "begin_line": 89,
        "end_line": 96,
        "is_bug": false
    },
    {
        "name": "dict.GetVocabFromDict#65",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.GetVocabFromDict( ChewingData *pgdata, Phrase *phr_ptr )",
        "snippet": "static void GetVocabFromDict( ChewingData *pgdata, Phrase *phr_ptr )\n{\n\tstrcpy(phr_ptr->phrase, pgdata->static_data.dict + GetUint24(pgdata->static_data.tree_cur_pos->phrase.pos));\n\tphr_ptr->freq = GetUint24(pgdata->static_data.tree_cur_pos->phrase.freq);\n\tpgdata->static_data.tree_cur_pos++;\n}",
        "begin_line": 65,
        "end_line": 70,
        "is_bug": false
    },
    {
        "name": "dict.GetVocabNext#98",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.GetVocabNext( ChewingData *pgdata, Phrase *phr_ptr )",
        "snippet": "int GetVocabNext( ChewingData *pgdata, Phrase *phr_ptr )\n{\n\tif ( pgdata->static_data.tree_cur_pos >= pgdata->static_data.tree_end_pos\n\t\t|| GetUint16(pgdata->static_data.tree_cur_pos->key) != 0)\n\t\treturn 0;\n\tGetVocabFromDict( pgdata, phr_ptr );\n\treturn 1;\n}",
        "begin_line": 98,
        "end_line": 105,
        "is_bug": false
    },
    {
        "name": "dict.InitDict#35",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.InitDict( ChewingData *pgdata, const char *prefix )",
        "snippet": "int InitDict( ChewingData *pgdata, const char *prefix )\n{\n\tchar filename[ PATH_MAX ];\n\tsize_t len;\n\tsize_t offset;\n\tsize_t file_size;\n\tsize_t csize;\n\n\tlen = snprintf( filename, sizeof( filename ), \"%s\" PLAT_SEPARATOR \"%s\", prefix, DICT_FILE );\n\tif ( len + 1 > sizeof( filename ) )\n\t\treturn -1;\n\n\tplat_mmap_set_invalid( &pgdata->static_data.dict_mmap );\n\tfile_size = plat_mmap_create( &pgdata->static_data.dict_mmap, filename, FLAG_ATTRIBUTE_READ );\n\tif ( file_size <= 0 )\n\t\treturn -1;\n\n\toffset = 0;\n\tcsize = file_size;\n\tpgdata->static_data.dict = (const char*)plat_mmap_set_view( &pgdata->static_data.dict_mmap, &offset, &csize );\n\tif ( !pgdata->static_data.dict )\n\t\treturn -1;\n\n\treturn 0;\n}",
        "begin_line": 35,
        "end_line": 59,
        "is_bug": false
    },
    {
        "name": "dict.TerminateDict#30",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.TerminateDict( ChewingData *pgdata )",
        "snippet": "void TerminateDict( ChewingData *pgdata )\n{\n\tplat_mmap_close( &pgdata->static_data.dict_mmap );\n}",
        "begin_line": 30,
        "end_line": 33,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_bopomofo_Check#175",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_bopomofo_Check( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_bopomofo_Check( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\treturn ctx->output->bopomofoBuf[0] != 0;\n}",
        "begin_line": 175,
        "end_line": 187,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_bopomofo_String_static#146",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_bopomofo_String_static( ChewingContext *ctx)",
        "snippet": "CHEWING_API const char *chewing_bopomofo_String_static( ChewingContext *ctx)\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn \"\";\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\treturn ctx->output->bopomofoBuf;\n}",
        "begin_line": 146,
        "end_line": 158,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_buffer_Check#84",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_buffer_Check( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_buffer_Check( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\treturn (ctx->output->chiSymbolBufLen != 0);\n}",
        "begin_line": 84,
        "end_line": 96,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_buffer_Len#98",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_buffer_Len( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_buffer_Len( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\treturn ctx->output->chiSymbolBufLen;\n}",
        "begin_line": 98,
        "end_line": 110,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_buffer_String#112",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_buffer_String( ChewingContext *ctx )",
        "snippet": "CHEWING_API char *chewing_buffer_String( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn strdup(\"\");\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\treturn strdup( ctx->output->preeditBuf );\n}",
        "begin_line": 112,
        "end_line": 124,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_buffer_String_static#126",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_buffer_String_static( ChewingContext *ctx )",
        "snippet": "CHEWING_API const char *chewing_buffer_String_static( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn \"\";\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\treturn ctx->output->preeditBuf;\n}",
        "begin_line": 126,
        "end_line": 138,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_cand_CurrentPage#268",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_cand_CurrentPage( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_cand_CurrentPage( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\treturn (ctx->output->pci ? ctx->output->pci->pageNo : -1);\n}",
        "begin_line": 268,
        "end_line": 280,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_cand_Enumerate#282",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_cand_Enumerate( ChewingContext *ctx )",
        "snippet": "CHEWING_API void chewing_cand_Enumerate( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\tctx->cand_no = ctx->output->pci->pageNo * ctx->output->pci->nChoicePerPage;\n}",
        "begin_line": 282,
        "end_line": 294,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_cand_String#331",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_cand_String( ChewingContext *ctx )",
        "snippet": "CHEWING_API char *chewing_cand_String( ChewingContext *ctx )\n{\n\treturn strdup(chewing_cand_String_static(ctx));\n}",
        "begin_line": 331,
        "end_line": 334,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_cand_String_static#310",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_cand_String_static( ChewingContext *ctx )",
        "snippet": "CHEWING_API const char *chewing_cand_String_static( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn \"\";\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\tchar *s;\n\tif ( chewing_cand_hasNext( ctx ) ) {\n\t\ts = ctx->output->pci->totalChoiceStr[ ctx->cand_no ];\n\t\tctx->cand_no++;\n\t} else {\n\t\ts = \"\";\n\t}\n\treturn s;\n}",
        "begin_line": 310,
        "end_line": 329,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_cand_TotalChoice#254",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_cand_TotalChoice( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_cand_TotalChoice( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\treturn (ctx->output->pci ? ctx->output->pci->nTotalChoice : 0);\n}",
        "begin_line": 254,
        "end_line": 266,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_cand_TotalPage#226",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_cand_TotalPage( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_cand_TotalPage( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\treturn (ctx->output->pci ? ctx->output->pci->nPage : 0);\n}",
        "begin_line": 226,
        "end_line": 238,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_cand_hasNext#296",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_cand_hasNext( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_cand_hasNext( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\treturn (ctx->cand_no < ctx->output->pci->nTotalChoice);\n}",
        "begin_line": 296,
        "end_line": 308,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_commit_Check#30",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_commit_Check( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_commit_Check( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\treturn !!(ctx->output->keystrokeRtn & KEYSTROKE_COMMIT);\n}",
        "begin_line": 30,
        "end_line": 42,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_commit_String#50",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_commit_String( ChewingContext *ctx )",
        "snippet": "CHEWING_API char *chewing_commit_String( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn strdup(\"\");\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\treturn strdup( ctx->output->commitBuf );\n}",
        "begin_line": 50,
        "end_line": 62,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_commit_String_static#70",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_commit_String_static( ChewingContext *ctx )",
        "snippet": "CHEWING_API const char *chewing_commit_String_static( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn \"\";\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\treturn ctx->output->commitBuf;\n}",
        "begin_line": 70,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_cursor_Current#198",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_cursor_Current( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_cursor_Current( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\treturn (ctx->output->chiSymbolCursor);\n}",
        "begin_line": 198,
        "end_line": 210,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_interval_Enumerate#336",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_interval_Enumerate( ChewingContext *ctx )",
        "snippet": "CHEWING_API void chewing_interval_Enumerate( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\tctx->it_no = 0;\n}",
        "begin_line": 336,
        "end_line": 348,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_interval_Get#364",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_interval_Get( ChewingContext *ctx, IntervalType *it )",
        "snippet": "CHEWING_API void chewing_interval_Get( ChewingContext *ctx, IntervalType *it )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\tif ( chewing_interval_hasNext( ctx ) ) {\n\t\tif ( it ) {\n\t\t\tit->from = ctx->output->dispInterval[ ctx->it_no ].from;\n\t\t\tit->to = ctx->output->dispInterval[ ctx->it_no ].to;\n\t\t}\n\t\tctx->it_no++;\n\t}\n}",
        "begin_line": 364,
        "end_line": 382,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_interval_hasNext#350",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_interval_hasNext( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_interval_hasNext( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\treturn (ctx->it_no < ctx->output->nDispInterval);\n}",
        "begin_line": 350,
        "end_line": 362,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_keystroke_CheckAbsorb#454",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_keystroke_CheckAbsorb( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_keystroke_CheckAbsorb( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\treturn !!(ctx->output->keystrokeRtn & KEYSTROKE_ABSORB);\n}",
        "begin_line": 454,
        "end_line": 466,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_keystroke_CheckIgnore#440",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_keystroke_CheckIgnore( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_keystroke_CheckIgnore( ChewingContext *ctx )\n{\n\tChewingData *pgdata;\n\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\tpgdata = ctx->data;\n\n\tLOG_API();\n\n\treturn !!(ctx->output->keystrokeRtn & KEYSTROKE_IGNORE);\n}",
        "begin_line": 440,
        "end_line": 452,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_zuin_Check#189",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_zuin_Check( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_zuin_Check( ChewingContext *ctx )\n{\n\tif ( !ctx ) {\n\t\treturn -1;\n\t}\n\n\treturn !chewing_bopomofo_Check(ctx);\n}",
        "begin_line": 189,
        "end_line": 196,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_zuin_String#165",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_zuin_String( ChewingContext *ctx, int *zuin_count )",
        "snippet": "CHEWING_API char *chewing_zuin_String( ChewingContext *ctx, int *zuin_count )\n{\n\tchar *s = strdup(chewing_bopomofo_String_static(ctx));\n\n\tif ( zuin_count )\n\t\t*zuin_count = ueStrLen(s);\n\n\treturn s;\n}",
        "begin_line": 165,
        "end_line": 173,
        "is_bug": false
    },
    {
        "name": "pinyin.InitPinyin#29",
        "src_path": "src/pinyin.c",
        "class_name": "pinyin",
        "signature": "pinyin.InitPinyin( ChewingData *pgdata, const char *prefix )",
        "snippet": "int InitPinyin( ChewingData *pgdata, const char *prefix )\n{\n\tchar filename[ PATH_MAX ];\n\tint i;\n\tFILE *fd;\n\tint ret;\n\n\tsprintf( filename,\n\t\t\"%s\" PLAT_SEPARATOR \"%s\",\n\t\tprefix, PINYIN_TAB_NAME );\n\n\tfd = fopen(filename, \"r\");\n\n\tif ( ! fd )\n\t\treturn 0;\n\n\tret = fscanf( fd, \"%d\", &pgdata->static_data.HANYU_INITIALS );\n\tif ( ret != 1 ) {\n\t\treturn 0;\n\t}\n\t++pgdata->static_data.HANYU_INITIALS;\n\tpgdata->static_data.hanyuInitialsMap = ALC( keymap, pgdata->static_data.HANYU_INITIALS );\n\tfor ( i = 0; i < pgdata->static_data.HANYU_INITIALS - 1; i++ ) {\n\t\tret = fscanf( fd, \"%s %s\",\n\t\t\tpgdata->static_data.hanyuInitialsMap[ i ].pinyin,\n\t\t\tpgdata->static_data.hanyuInitialsMap[ i ].zuin );\n\t\tif ( ret != 2 ) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tret = fscanf( fd, \"%d\", &pgdata->static_data.HANYU_FINALS );\n\tif ( ret != 1 ) {\n\t\treturn 0;\n\t}\n\t++pgdata->static_data.HANYU_FINALS;\n\tpgdata->static_data.hanyuFinalsMap = ALC( keymap, pgdata->static_data.HANYU_FINALS );\n\tfor ( i = 0; i < pgdata->static_data.HANYU_FINALS - 1; i++ ) {\n\t\tret = fscanf( fd, \"%s %s\",\n\t\t\tpgdata->static_data.hanyuFinalsMap[ i ].pinyin,\n\t\t\tpgdata->static_data.hanyuFinalsMap[ i ].zuin );\n\t\tif ( ret != 2 ) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfclose( fd );\n\n\treturn 1;\n}",
        "begin_line": 29,
        "end_line": 78,
        "is_bug": false
    },
    {
        "name": "pinyin.TerminatePinyin#23",
        "src_path": "src/pinyin.c",
        "class_name": "pinyin",
        "signature": "pinyin.TerminatePinyin( ChewingData *pgdata )",
        "snippet": "void TerminatePinyin( ChewingData *pgdata )\n{\n\tfree( pgdata->static_data.hanyuInitialsMap );\n\tfree( pgdata->static_data.hanyuFinalsMap );\n}",
        "begin_line": 23,
        "end_line": 27,
        "is_bug": false
    },
    {
        "name": "porting_layer.plat_path.are_all_files_readable#130",
        "src_path": "src/porting_layer/src/plat_path.c",
        "class_name": "porting_layer.plat_path",
        "signature": "porting_layer.plat_path.are_all_files_readable( \tconst char *path, const char * const *files, char *output, size_t output_len )",
        "snippet": "static int are_all_files_readable(\n\tconst char *path,\n\tconst char * const *files,\n\tchar *output,\n\tsize_t output_len )\n{\n\tint i;\n\n\tassert( path );\n\tassert( files );\n\n\tfor ( i = 0; files[i] != NULL; ++i ) {\n\t\tsnprintf( output, output_len, \"%s\" PLAT_SEPARATOR \"%s\", path,\n\t\t\t\tfiles[i] );\n\t\tif ( access( output, R_OK ) != 0 ) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}",
        "begin_line": 130,
        "end_line": 150,
        "is_bug": false
    },
    {
        "name": "porting_layer.plat_path.find_path_by_files#152",
        "src_path": "src/porting_layer/src/plat_path.c",
        "class_name": "porting_layer.plat_path",
        "signature": "porting_layer.plat_path.find_path_by_files( \tconst char *search_path, const char * const *files, char *output, size_t output_len )",
        "snippet": "int find_path_by_files(\n\tconst char *search_path,\n\tconst char * const *files,\n\tchar *output,\n\tsize_t output_len )\n{\n\tchar buffer[PATH_MAX];\n\tchar *path;\n\tchar *saveptr;\n\tint ret;\n\n\tassert( search_path );\n\tassert( files );\n\tassert( output );\n\tassert( output_len );\n\n\t// strtok_r will modify its first parameter.\n\tstrncpy( buffer, search_path, sizeof( buffer ) );\n\n\tfor ( path = strtok_r( buffer, SEARCH_PATH_SEP, &saveptr );\n\t\tpath; path = strtok_r( NULL, SEARCH_PATH_SEP, &saveptr ) ) {\n\n\t\tret = are_all_files_readable( path, files, output, output_len );\n\t\tif ( ret ) {\n\t\t\tsnprintf( output, output_len, \"%s\", path );\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}",
        "begin_line": 152,
        "end_line": 181,
        "is_bug": false
    },
    {
        "name": "tree.AddInterval#288",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.AddInterval( \t\tTreeDataType *ptd, int begin, int end, Phrase *p_phrase, int dict_or_user )",
        "snippet": "static void AddInterval(\n\t\tTreeDataType *ptd, int begin , int end,\n\t\tPhrase *p_phrase, int dict_or_user )\n{\n\tptd->interval[ ptd->nInterval ].from = begin;\n\tptd->interval[ ptd->nInterval ].to = end + 1;\n\tptd->interval[ ptd->nInterval ].p_phr = p_phrase;\n\tptd->interval[ ptd->nInterval ].source = dict_or_user;\n\tptd->nInterval++;\n}",
        "begin_line": 288,
        "end_line": 297,
        "is_bug": false
    },
    {
        "name": "tree.CheckBreakpoint#109",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CheckBreakpoint( int from, int to, int bArrBrkpt[] )",
        "snippet": "static int CheckBreakpoint( int from, int to, int bArrBrkpt[] )\n{\n\tint i;\n\tfor ( i = from + 1; i < to; i++ )\n\t\tif ( bArrBrkpt[ i ] )\n\t\t\treturn 0;\n\treturn 1;\n}",
        "begin_line": 109,
        "end_line": 116,
        "is_bug": false
    },
    {
        "name": "tree.CheckChoose#197",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CheckChoose( \t\tChewingData *pgdata, const TreeType *phrase_parent, int from, int to, Phrase **pp_phr, char selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ], IntervalType selectInterval[], int nSelect )",
        "snippet": "static int CheckChoose(\n\t\tChewingData *pgdata,\n\t\tconst TreeType *phrase_parent, int from, int to, Phrase **pp_phr,\n\t\tchar selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ],\n\t\tIntervalType selectInterval[], int nSelect )\n{\n\tIntervalType inte, c;\n\tint chno, len;\n\tPhrase *phrase = ALC( Phrase, 1 );\n\n\tassert( phrase );\n\tinte.from = from;\n\tinte.to = to;\n\t*pp_phr = NULL;\n\n\t/* if there exist one phrase satisfied all selectStr then return 1, else return 0. */\n\tGetPhraseFirst( pgdata, phrase, phrase_parent );\n\tdo {\n\t\tfor ( chno = 0; chno < nSelect; chno++ ) {\n\t\t\tc = selectInterval[ chno ];\n\n\t\t\tif ( IsContain( inte, c ) ) {\n\t\t\t\t/* find a phrase under phrase_parent where the text contains\n\t\t\t\t * 'selectStr[chno]' test if not ok then return 0, if ok\n\t\t\t\t * then continue to test\n\t\t\t\t */\n\t\t\t\tlen = c.to - c.from;\n\t\t\t\tif ( memcmp(\n\t\t\t\t\tueStrSeek( phrase->phrase, c.from - from ),\n\t\t\t\t\tselectStr[ chno ],\n\t\t\t\t\tueStrNBytes( selectStr[ chno ], len ) ) )\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ( IsIntersect( inte, selectInterval[ chno ] ) ) {\n\t\t\t\tfree( phrase );\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif ( chno == nSelect ) {\n\t\t\t*pp_phr = phrase;\n\t\t\treturn 1;\n\t\t}\n\t} while ( GetVocabNext( pgdata, phrase ) );\n\tfree( phrase );\n\treturn 0;\n}",
        "begin_line": 197,
        "end_line": 242,
        "is_bug": false
    },
    {
        "name": "tree.CheckUserChoose#118",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CheckUserChoose( \t\tChewingData *pgdata, uint16_t *new_phoneSeq, int from, int to, Phrase **pp_phr, char selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ], IntervalType selectInterval[], int nSelect )",
        "snippet": "static int CheckUserChoose(\n\t\tChewingData *pgdata,\n\t\tuint16_t *new_phoneSeq, int from , int to,\n\t\tPhrase **pp_phr,\n\t\tchar selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ],\n\t\tIntervalType selectInterval[], int nSelect )\n{\n\tIntervalType inte, c;\n\tint chno, len;\n\tint user_alloc;\n\tUserPhraseData *pUserPhraseData;\n\tPhrase *p_phr = ALC( Phrase, 1 );\n\n\tassert( p_phr );\n\tinte.from = from;\n\tinte.to = to;\n\t*pp_phr = NULL;\n\n\t/* pass 1\n\t * if these exist one selected interval which is not contained by inte\n\t * but has intersection with inte, then inte is an unacceptable interval\n\t */\n\tfor ( chno = 0; chno < nSelect; chno++ ) {\n\t\tc = selectInterval[ chno ];\n\t\tif ( IsIntersect( inte, c ) && ! IsContain( inte, c ) ) {\n\t\t\tfree( p_phr );\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* pass 2\n\t * if there exist one phrase satisfied all selectStr then return 1, else return 0.\n\t * also store the phrase with highest freq\n\t */\n\tpUserPhraseData = UserGetPhraseFirst( pgdata, new_phoneSeq );\n\tp_phr->freq = -1;\n\tdo {\n\t\tfor ( chno = 0; chno < nSelect; chno++ ) {\n\t\t\tc = selectInterval[ chno ];\n\n\t\t\tif ( IsContain( inte, c ) ) {\n\t\t\t\t/*\n\t\t\t\t * find a phrase of ph_id where the text contains\n\t\t\t\t * 'selectStr[chno]' test if not ok then return 0,\n\t\t\t\t * if ok then continue to test. */\n\t\t\t\tlen = c.to - c.from;\n\t\t\t\tif ( memcmp(\n\t\t\t\t\tueStrSeek( pUserPhraseData->wordSeq, c.from - from ),\n\t\t\t\t\tselectStr[ chno ],\n\t\t\t\t\tueStrNBytes( selectStr[ chno ], len ) ) )\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tif ( chno == nSelect ) {\n\t\t\t/* save phrase data to \"pp_phr\" */\n\t\t\tif ( pUserPhraseData->userfreq > p_phr->freq ) {\n\t\t\t\tif ( ( user_alloc = ( to - from ) ) > 0 ) {\n\t\t\t\t\tueStrNCpy( p_phr->phrase,\n\t\t\t\t\t\t\tpUserPhraseData->wordSeq,\n\t\t\t\t\t\t\tuser_alloc, 1);\n\t\t\t\t}\n\t\t\t\tp_phr->freq = pUserPhraseData->userfreq;\n\t\t\t\t*pp_phr = p_phr;\n\t\t\t}\n\t\t}\n\t} while ( ( pUserPhraseData = UserGetPhraseNext( pgdata, new_phoneSeq ) ) != NULL );\n\tUserGetPhraseEnd( pgdata, new_phoneSeq );\n\n\tif ( p_phr->freq != -1 )\n\t\treturn 1;\n\n\tfree( p_phr );\n\treturn 0;\n}",
        "begin_line": 118,
        "end_line": 192,
        "is_bug": false
    },
    {
        "name": "tree.CleanUpMem#814",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CleanUpMem( TreeDataType *ptd )",
        "snippet": "static void CleanUpMem( TreeDataType *ptd )\n{\n\tint i;\n\tRecordNode *pNode;\n\n\tfor ( i = 0; i < ptd->nInterval; i++ ) {\n\t\tif ( ptd->interval[ i ].p_phr ) {\n\t\t\tfree( ptd->interval[ i ].p_phr );\n\t\t\tptd->interval[ i ].p_phr = NULL;\n\t\t}\n\t}\n\twhile ( ptd->phList != NULL ) {\n\t\tpNode = ptd->phList;\n\t\tptd->phList = pNode->next;\n\t\tfree( pNode->arrIndex );\n\t\tfree( pNode );\n\t}\n}",
        "begin_line": 814,
        "end_line": 831,
        "is_bug": false
    },
    {
        "name": "tree.CompRecord#441",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CompRecord( const RecordNode **pa, const RecordNode **pb )",
        "snippet": "static int CompRecord( const RecordNode **pa, const RecordNode **pb )\n{\n\tint diff = (*pb)->nMatchCnnct - (*pa)->nMatchCnnct;\n\n\tif ( diff )\n\t\treturn diff;\n\treturn ( (*pb)->score - (*pa)->score );\n}",
        "begin_line": 441,
        "end_line": 448,
        "is_bug": false
    },
    {
        "name": "tree.CompTreeType#244",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CompTreeType( const void *a, const void *b )",
        "snippet": "static int CompTreeType( const void *a, const void *b )\n{\n\treturn GetUint16(((TreeType*)a)->key) - GetUint16(((TreeType*)b)->key);\n}",
        "begin_line": 244,
        "end_line": 247,
        "is_bug": false
    },
    {
        "name": "tree.CountMatchCnnct#833",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CountMatchCnnct( TreeDataType *ptd, const int *bUserArrCnnct, int nPhoneSeq )",
        "snippet": "static void CountMatchCnnct( TreeDataType *ptd, const int *bUserArrCnnct, int nPhoneSeq )\n{\n\tRecordNode *p;\n\tint i, k, sum;\n\n\tfor ( p = ptd->phList; p; p = p->next ) {\n\t\t/* for each record, count its 'nMatchCnnct' */\n\t\tfor ( sum = 0, i = 1; i < nPhoneSeq; i++ ) {\n\t\t\tif ( !bUserArrCnnct[ i ] )\n\t\t\t\tcontinue;\n\t\t\t/* check if matching 'cnnct' */\n\t\t\tfor ( k = 0; k < p->nInter; k++ ) {\n\t\t\t\tif (\n\t\t\t\t\tptd->interval[ p->arrIndex[ k ] ].from < i &&\n\t\t\t\t\tptd->interval[ p->arrIndex[ k ] ].to > i ) {\n\t\t\t\t\tsum++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp->nMatchCnnct = sum;\n\t}\n}",
        "begin_line": 833,
        "end_line": 855,
        "is_bug": false
    },
    {
        "name": "tree.CreateNullIntervalRecord#978",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CreateNullIntervalRecord()",
        "snippet": "static RecordNode * CreateNullIntervalRecord()\n{\n\tRecordNode *ret = NULL;\n\tret = ALC( RecordNode, 1 );\n\tif ( !ret )\n\t\treturn NULL;\n\n\tret->arrIndex = ALC( int, 1 );\n\tif ( !ret->arrIndex ) {\n\t\tfree( ret );\n\t\treturn NULL;\n\t}\n\n\tret->nInter = 0;\n\tret->score = 0;\n\n\treturn ret;\n}",
        "begin_line": 978,
        "end_line": 995,
        "is_bug": false
    },
    {
        "name": "tree.CreateSingleIntervalRecord#954",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CreateSingleIntervalRecord( TreeDataType *pdt, const int interval_id )",
        "snippet": "static RecordNode * CreateSingleIntervalRecord( TreeDataType *pdt, const int interval_id )\n{\n\tRecordNode *ret = NULL;\n\n\tassert( pdt );\n\n\tret = ALC( RecordNode, 1 );\n\tif ( !ret )\n\t\treturn NULL;\n\n\tret->arrIndex = ALC( int, 1 );\n\tif ( !ret->arrIndex ) {\n\t\tfree( ret );\n\t\treturn NULL;\n\t}\n\n\tret->nInter = 1;\n\tret->arrIndex[0] = interval_id;\n\n\tret->score = LoadPhraseAndCountScore( ret->arrIndex, ret->nInter, pdt );\n\n\treturn ret;\n}",
        "begin_line": 954,
        "end_line": 976,
        "is_bug": false
    },
    {
        "name": "tree.Discard1#457",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.Discard1( TreeDataType *ptd )",
        "snippet": "static void Discard1( TreeDataType *ptd )\n{\n\tint a, b;\n\tchar failflag[ INTERVAL_SIZE ];\n\tint nInterval2;\n\n\tmemset( failflag, 0, sizeof( failflag ) );\n\tfor ( a = 0; a < ptd->nInterval; a++ ) {\n\t\tif ( failflag[ a ] )\n\t\t\tcontinue;\n\t\tfor ( b = 0; b < ptd->nInterval; b++ ) {\n\t\t\tif ( a == b || failflag[ b ] )\n\t\t\t\tcontinue ;\n\n\t\t\t/* interval b is in interval a */\n\t\t\tif ( PhraseIntervalContain( ptd->interval[ a ], ptd->interval[ b ] ) )\n\t\t\t\tcontinue;\n\n\t\t\t/* interval b is in front of interval a */\n\t\t\tif ( ptd->interval[ b ].to <= ptd->interval[ a ].from )\n\t\t\t\tcontinue;\n\n\t\t\t/* interval b is in back of interval a */\n\t\t\tif ( ptd->interval[ a ].to <= ptd->interval[ b ].from )\n\t\t\t\tcontinue;\n\n\t\t\tbreak;\n\t\t}\n\t\t/* if any other interval b is inside or leftside or rightside the\n\t\t * interval a */\n\t\tif ( b >= ptd->nInterval ) {\n\t\t\t/* then kill all the intervals inside the interval a */\n\t\t\tint i;\n\t\t\tfor ( i = 0; i < ptd->nInterval; i++ ) {\n\t\t\t\tif (! failflag[ i ] && i != a &&\n\t\t\t\t\tPhraseIntervalContain( ptd->interval[ a ], ptd->interval[ i ] ) ) {\n\t\t\t\t\tfailflag[ i ] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/* discard all the intervals whose failflag[a] = 1 */\n\tnInterval2 = 0;\n\tfor ( a = 0; a < ptd->nInterval; a++ ) {\n\t\tif ( ! failflag[ a ] ) {\n\t\t\tptd->interval[ nInterval2++ ] = ptd->interval[ a ];\n\t\t}\n\t\telse {\n\t\t\tif ( ptd->interval[ a ].p_phr != NULL ) {\n\t\t\t\tfree( ptd->interval[ a ].p_phr );\n\t\t\t}\n\t\t}\n\t}\n\tptd->nInterval = nInterval2;\n}",
        "begin_line": 457,
        "end_line": 511,
        "is_bug": false
    },
    {
        "name": "tree.Discard2#524",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.Discard2( TreeDataType *ptd )",
        "snippet": "static void Discard2( TreeDataType *ptd )\n{\n\tint i, j;\n\tchar overwrite[ MAX_PHONE_SEQ_LEN ];\n\tchar failflag[ INTERVAL_SIZE ];\n\tint nInterval2;\n\n\tmemset( failflag, 0, sizeof( failflag ) );\n\tfor ( i = 0; i < ptd->nInterval; i++ ) {\n\t\tif ( ptd->leftmost[ ptd->interval[ i ].from ] == 0 )\n\t\t\tcontinue;\n\t\t/* test if interval i is overwrited by other intervals */\n\t\tmemset( overwrite, 0, sizeof( overwrite ) );\n\t\tfor ( j = 0; j < ptd->nInterval; j++ ) {\n\t\t\tif ( j == i )\n\t\t\t\tcontinue;\n\t\t\tmemset(\n\t\t\t\t&overwrite[ ptd->interval[ j ].from ],\n\t\t\t\t1,\n\t\t\t\tptd->interval[ j ].to - ptd->interval[ j ].from );\n\t\t}\n\t\tif ( memchr(\n\t\t\t&overwrite[ ptd->interval[ i ].from ],\n\t\t\t1,\n\t\t\tptd->interval[ i ].to - ptd->interval[ i ].from ) )\n\t\t\tfailflag[ i ] = 1;\n\t}\n\t/* discard all the intervals whose failflag[a] = 1 */\n\tnInterval2 = 0;\n\tfor ( i = 0; i < ptd->nInterval; i++ )\n\t\tif ( ! failflag[ i ] )\n\t\t\tptd->interval[ nInterval2++ ] = ptd->interval[ i ];\n\tptd->nInterval = nInterval2;\n}",
        "begin_line": 524,
        "end_line": 557,
        "is_bug": false
    },
    {
        "name": "tree.DoDpPhrasing#1005",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.DoDpPhrasing( ChewingData *pgdata, TreeDataType *pdt )",
        "snippet": "static void DoDpPhrasing( ChewingData *pgdata, TreeDataType *pdt )\n{\n\tRecordNode *highest_score[ MAX_PHONE_SEQ_LEN ] = { 0 };\n\tRecordNode *tmp;\n\tint prev_end;\n\tint end;\n\tint interval_id;\n\n\tassert( pgdata );\n\tassert( pdt );\n\n\t/*\n\t * Assume P(x,y) is the highest score phrasing result from x to y. The\n\t * following is formula for P(x,y):\n\t *\n\t * P(x,y) = MAX( P(x,y-1)+P(y-1,y), P(x,y-2)+P(y-2,y), ... )\n\t *\n\t * While P(x,y-1) is stored in highest_score array, and P(y-1,y) is\n\t * interval end at y. In this formula, x is always 0.\n\t *\n\t * The format of highest_score array is described as following:\n\t *\n\t * highest_score[0] = P(0,0)\n\t * highest_score[1] = P(0,1)\n\t * ...\n\t * highest_score[y-1] = P(0,y-1)\n\t */\n\n\t/* The interval shall be sorted by the increase order of end. */\n\tqsort( pdt->interval, pdt->nInterval, sizeof( pdt->interval[0] ), SortByIncreaseEnd );\n\n\tfor ( interval_id = 0; interval_id < pdt->nInterval; ++interval_id ) {\n\t\t/*\n\t\t * XXX: pdt->interval.to is excluding, while end is\n\t\t * including, so we need to minus one here.\n\t\t */\n\t\tend = pdt->interval[interval_id].to - 1;\n\n\t\tprev_end = pdt->interval[interval_id].from - 1;\n\n\t\tif ( prev_end >= 0 )\n\t\t\ttmp = DuplicateRecordAndInsertInterval(\n\t\t\t\thighest_score[ prev_end ],\n\t\t\t\tpdt,\n\t\t\t\tinterval_id );\n\t\telse\n\t\t\ttmp = CreateSingleIntervalRecord( pdt, interval_id );\n\n\t\t/* FIXME: shall exit immediately? */\n\t\tif (!tmp)\n\t\t\tcontinue;\n\n\t\tif ( highest_score[end] == NULL || highest_score[end]->score < tmp->score ) {\n\t\t\tFreeRecord( highest_score[end] );\n\t\t\thighest_score[end] = tmp;\n\t\t} else\n\t\t\tFreeRecord( tmp );\n\t}\n\n\tif ( pgdata->nPhoneSeq - 1 < 0 || highest_score[ pgdata->nPhoneSeq - 1 ] == NULL ) {\n\t\tpdt->phList = CreateNullIntervalRecord();\n\t} else {\n\t\tpdt->phList = highest_score[ pgdata->nPhoneSeq - 1 ];\n\t}\n\tpdt->nPhListLen = 1;\n\n\tfor ( end = 0; end < pgdata->nPhoneSeq - 1; ++end )\n\t\tFreeRecord( highest_score[end] );\n}",
        "begin_line": 1005,
        "end_line": 1073,
        "is_bug": false
    },
    {
        "name": "tree.DuplicateRecordAndInsertInterval#925",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.DuplicateRecordAndInsertInterval( \tconst RecordNode *record, TreeDataType *pdt, const int interval_id )",
        "snippet": "static RecordNode * DuplicateRecordAndInsertInterval(\n\tconst RecordNode *record,\n\tTreeDataType *pdt,\n\tconst int interval_id )\n{\n\tRecordNode *ret = NULL;\n\n\tassert( record );\n\tassert( pdt );\n\n\tret = ALC( RecordNode, 1 );\n\tif ( !ret )\n\t\treturn NULL;\n\n\tret->arrIndex = ALC( int, record->nInter + 1 );\n\tif ( !ret->arrIndex ) {\n\t\tfree( ret );\n\t\treturn NULL;\n\t}\n\tret->nInter = record->nInter + 1;\n\tmemcpy( ret->arrIndex, record->arrIndex, sizeof(record->arrIndex[0]) * record->nInter );\n\n\tret->arrIndex[ ret->nInter - 1 ] = interval_id;\n\n\tret->score = LoadPhraseAndCountScore( ret->arrIndex, ret->nInter, pdt );\n\n\treturn ret;\n}",
        "begin_line": 925,
        "end_line": 952,
        "is_bug": false
    },
    {
        "name": "tree.FillPreeditBuf#559",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.FillPreeditBuf( ChewingData *pgdata, char *phrase, int from, int to )",
        "snippet": "static void FillPreeditBuf( ChewingData *pgdata, char *phrase, int from, int to )\n{\n\tint i;\n\tint start = 0;\n\n\tassert( pgdata );\n\tassert( phrase );\n\tassert( from < to );\n\n\tstart = toPreeditBufIndex( pgdata, from );\n\n\tLOG_VERBOSE( \"Fill preeditBuf start %d, from = %d, to = %d\", start, from, to );\n\n\tfor ( i = start; i < start - from + to; ++i ) {\n\t\tueStrNCpy( pgdata->preeditBuf[ i ].char_,\n\t\t\tueStrSeek( phrase, i - start ), 1, STRNCPY_CLOSE );\n\t}\n}",
        "begin_line": 559,
        "end_line": 576,
        "is_bug": false
    },
    {
        "name": "tree.FindInterval#327",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.FindInterval( ChewingData *pgdata, TreeDataType *ptd )",
        "snippet": "static void FindInterval( ChewingData *pgdata, TreeDataType *ptd )\n{\n\tint end, begin;\n\tconst TreeType *phrase_parent;\n\tPhrase *p_phrase, *puserphrase, *pdictphrase;\n\tUsedPhraseMode i_used_phrase;\n\tuint16_t new_phoneSeq[ MAX_PHONE_SEQ_LEN ];\n\tUserPhraseData *userphrase;\n\n\tfor ( begin = 0; begin < pgdata->nPhoneSeq; begin++ ) {\n\t\tfor ( end = begin; end < min( pgdata->nPhoneSeq, begin + MAX_PHRASE_LEN ); end++ ) {\n\t\t\tif ( ! CheckBreakpoint( begin, end + 1, pgdata->bArrBrkpt ) )\n\t\t\t\tbreak;\n\n\t\t\t/* set new_phoneSeq */\n\t\t\tmemcpy(\n\t\t\t\tnew_phoneSeq,\n\t\t\t\t&pgdata->phoneSeq[ begin ],\n\t\t\t\tsizeof( uint16_t ) * ( end - begin + 1 ) );\n\t\t\tnew_phoneSeq[ end - begin + 1 ] = 0;\n\t\t\tpuserphrase = pdictphrase = NULL;\n\t\t\ti_used_phrase = USED_PHRASE_NONE;\n\n\t\t\tuserphrase = UserGetPhraseFirst(pgdata, new_phoneSeq);\n\t\t\tUserGetPhraseEnd( pgdata, new_phoneSeq );\n\n\t\t\tif ( userphrase && CheckUserChoose( pgdata, new_phoneSeq, begin, end + 1,\n\t\t\t\t&p_phrase, pgdata->selectStr, pgdata->selectInterval, pgdata->nSelect )) {\n\t\t\t\tpuserphrase = p_phrase;\n\t\t\t}\n\n\t\t\t/* check dict phrase */\n\t\t\tphrase_parent = TreeFindPhrase( pgdata, begin, end, pgdata->phoneSeq );\n\t\t\tif (\n\t\t\t\tphrase_parent &&\n\t\t\t\tCheckChoose(\n\t\t\t\t\tpgdata,\n\t\t\t\t\tphrase_parent, begin, end + 1,\n\t\t\t\t\t&p_phrase, pgdata->selectStr,\n\t\t\t\t\tpgdata->selectInterval, pgdata->nSelect ) ) {\n\t\t\t\tpdictphrase = p_phrase;\n\t\t\t}\n\n\t\t\t/* add only one interval, which has the largest freqency\n\t\t\t * but when the phrase is the same, the user phrase overrides\n\t\t\t * static dict\n\t\t\t */\n\t\t\tif ( puserphrase != NULL && pdictphrase == NULL ) {\n\t\t\t\ti_used_phrase = USED_PHRASE_USER;\n\t\t\t}\n\t\t\telse if ( puserphrase == NULL && pdictphrase != NULL ) {\n\t\t\t\ti_used_phrase = USED_PHRASE_DICT;\n\t\t\t}\n\t\t\telse if ( puserphrase != NULL && pdictphrase != NULL ) {\n\t\t\t\t/* the same phrase, userphrase overrides */\n\t\t\t\tif ( ! strcmp(\n\t\t\t\t\tpuserphrase->phrase,\n\t\t\t\t\tpdictphrase->phrase ) ) {\n\t\t\t\t\ti_used_phrase = USED_PHRASE_USER;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( puserphrase->freq > pdictphrase->freq ) {\n\t\t\t\t\t\ti_used_phrase = USED_PHRASE_USER;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ti_used_phrase = USED_PHRASE_DICT;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch ( i_used_phrase ) {\n\t\t\t\tcase USED_PHRASE_USER:\n\t\t\t\t\tAddInterval( ptd, begin, end, puserphrase, IS_USER_PHRASE );\n\t\t\t\t\tbreak;\n\t\t\t\tcase USED_PHRASE_DICT:\n\t\t\t\t\tAddInterval( ptd, begin, end, pdictphrase, IS_DICT_PHRASE );\n\t\t\t\t\tbreak;\n\t\t\t\tcase USED_PHRASE_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinternal_release_Phrase(\n\t\t\t\ti_used_phrase,\n\t\t\t\tpuserphrase,\n\t\t\t\tpdictphrase );\n\t\t}\n\t}\n}",
        "begin_line": 327,
        "end_line": 413,
        "is_bug": false
    },
    {
        "name": "tree.FreeRecord#997",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.FreeRecord( RecordNode *node )",
        "snippet": "static void FreeRecord( RecordNode *node )\n{\n\tif ( node ) {\n\t\tfree( node->arrIndex );\n\t\tfree( node );\n\t}\n}",
        "begin_line": 997,
        "end_line": 1003,
        "is_bug": false
    },
    {
        "name": "tree.InitPhrasing#796",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.InitPhrasing( TreeDataType *ptd )",
        "snippet": "static void InitPhrasing( TreeDataType *ptd )\n{\n\tmemset( ptd, 0, sizeof( TreeDataType ) );\n}",
        "begin_line": 796,
        "end_line": 799,
        "is_bug": false
    },
    {
        "name": "tree.InitTree#86",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.InitTree( ChewingData *pgdata, const char * prefix )",
        "snippet": "int InitTree( ChewingData *pgdata, const char * prefix )\n{\n\tchar filename[ PATH_MAX ];\n\tsize_t len;\n\tsize_t offset;\n\n\tlen = snprintf( filename, sizeof( filename ), \"%s\" PLAT_SEPARATOR \"%s\", prefix, PHONE_TREE_FILE );\n\tif ( len + 1 > sizeof( filename ) )\n\t\treturn -1;\n\n\tplat_mmap_set_invalid( &pgdata->static_data.tree_mmap );\n\tpgdata->static_data.tree_size = plat_mmap_create( &pgdata->static_data.tree_mmap, filename, FLAG_ATTRIBUTE_READ );\n\tif ( pgdata->static_data.tree_size <= 0 )\n\t\treturn -1;\n\n\toffset = 0;\n\tpgdata->static_data.tree = (const TreeType *) plat_mmap_set_view( &pgdata->static_data.tree_mmap, &offset, &pgdata->static_data.tree_size );\n\tif ( !pgdata->static_data.tree )\n\t\treturn -1;\n\n\treturn 0;\n}",
        "begin_line": 86,
        "end_line": 107,
        "is_bug": false
    },
    {
        "name": "tree.IsContain#59",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.IsContain( IntervalType in1, IntervalType in2 )",
        "snippet": "static int IsContain( IntervalType in1, IntervalType in2 )\n{\n\treturn ( in1.from <= in2.from && in1.to >= in2.to );\n}",
        "begin_line": 59,
        "end_line": 62,
        "is_bug": false
    },
    {
        "name": "tree.IsIntersect#64",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.IsIntersect( IntervalType in1, IntervalType in2 )",
        "snippet": "int IsIntersect( IntervalType in1, IntervalType in2 )\n{\n\treturn ( max( in1.from, in2.from ) < min( in1.to, in2.to ) );\n}",
        "begin_line": 64,
        "end_line": 67,
        "is_bug": false
    },
    {
        "name": "tree.IsRecContain#663",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.IsRecContain( const int *intA, int nA, const int *intB, int nB, const TreeDataType *ptd )",
        "snippet": "static int IsRecContain( const int *intA, int nA, const int *intB, int nB, const TreeDataType *ptd )\n{\n\tint big, sml;\n\n\tfor ( big = 0, sml = 0; sml < nB; sml++ ) {\n\t\twhile (\n\t\t\t( big < nA ) &&\n\t\t\tptd->interval[ intA[ big ] ].from <\n\t\t\t\tptd->interval[ intB[ sml ] ].to ) {\n\t\t\tif ( PhraseIntervalContain(\n\t\t\t\tptd->interval[ intA[ big ] ],\n\t\t\t\tptd->interval[ intB[ sml ] ] ) )\n\t\t\t\tbreak;\n\t\t\tbig++;\n\t\t}\n\t\tif (\n\t\t\t( big >= nA ) ||\n\t\t\tptd->interval[ intA[ big ] ].from >=\n\t\t\t\tptd->interval[ intB[ sml ] ].to )\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
        "begin_line": 663,
        "end_line": 685,
        "is_bug": false
    },
    {
        "name": "tree.LoadPhraseAndCountScore#650",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.LoadPhraseAndCountScore( const int *record, int nRecord, const TreeDataType *ptd )",
        "snippet": "static int LoadPhraseAndCountScore( const int *record, int nRecord, const TreeDataType *ptd )\n{\n\tint total_score = 0;\n\t/* NOTE: the balance factor is tuneable */\n\tif (nRecord) {\n\t\ttotal_score += 1000*rule_largest_sum( record, nRecord, ptd );\n\t\ttotal_score += 1000*rule_largest_avgwordlen( record, nRecord, ptd );\n\t\ttotal_score += 100*rule_smallest_lenvariance( record, nRecord, ptd );\n\t\ttotal_score += rule_largest_freqsum( record, nRecord, ptd );\n\t}\n\treturn total_score;\n}",
        "begin_line": 650,
        "end_line": 661,
        "is_bug": false
    },
    {
        "name": "tree.NextCut#880",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.NextCut( TreeDataType *tdt, PhrasingOutput *ppo )",
        "snippet": "static RecordNode* NextCut( TreeDataType *tdt, PhrasingOutput *ppo )\n{\n\t/* pop nNumCut-th candidate to first */\n\tint i;\n\tRecordNode *former;\n\tRecordNode *want;\n\n\tif ( ppo->nNumCut >= tdt->nPhListLen )\n\t\tppo->nNumCut = 0;\n\tif (ppo->nNumCut == 0)\n\t\treturn tdt->phList;\n\n\t/* find the former of our candidate */\n\tformer = tdt->phList;\n\tfor ( i = 0; i < ppo->nNumCut - 1; i++ ) {\n\t\tformer = former->next;\n\t\tassert( former );\n\t}\n\n\t/* take the candidate out of the listed list */\n\twant = former->next;\n\tassert( want );\n\tformer->next = former->next->next;\n\n\t/* prepend to front of list */\n\twant->next = tdt->phList;\n\ttdt->phList = want;\n\n\treturn tdt->phList;\n}",
        "begin_line": 880,
        "end_line": 909,
        "is_bug": false
    },
    {
        "name": "tree.OutputRecordStr#579",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.OutputRecordStr( ChewingData *pgdata, const TreeDataType *ptd )",
        "snippet": "static void OutputRecordStr( ChewingData *pgdata, const TreeDataType *ptd )\n{\n\tPhraseIntervalType inter;\n\tint i;\n\n\tfor ( i = 0; i < ptd->phList->nInter; i++ ) {\n\t\tinter = ptd->interval[ ptd->phList->arrIndex[ i ] ];\n\t\tFillPreeditBuf( pgdata, inter.p_phr->phrase, inter.from, inter.to );\n\t}\n\n\tfor ( i = 0; i < pgdata->nSelect; i++ ) {\n\t\tFillPreeditBuf( pgdata,\n\t\t\tpgdata->selectStr[ i ],\n\t\t\tpgdata->selectInterval[ i ].from,\n\t\t\tpgdata->selectInterval[ i ].to);\n\t}\n}",
        "begin_line": 579,
        "end_line": 595,
        "is_bug": false
    },
    {
        "name": "tree.PhraseIntervalContain#69",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.PhraseIntervalContain(PhraseIntervalType in1, PhraseIntervalType in2)",
        "snippet": "static int PhraseIntervalContain(PhraseIntervalType in1, PhraseIntervalType in2)\n{\n\treturn ( in1.from <= in2.from && in1.to >= in2.to );\n}",
        "begin_line": 69,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "tree.PhraseIntervalIntersect#74",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.PhraseIntervalIntersect(PhraseIntervalType in1, PhraseIntervalType in2)",
        "snippet": "static int PhraseIntervalIntersect(PhraseIntervalType in1, PhraseIntervalType in2)\n{\n\treturn ( max( in1.from, in2.from ) < min( in1.to, in2.to ) );\n}",
        "begin_line": 74,
        "end_line": 77,
        "is_bug": false
    },
    {
        "name": "tree.Phrasing#1075",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.Phrasing( ChewingData *pgdata, int all_phrasing )",
        "snippet": "int Phrasing( ChewingData *pgdata, int all_phrasing )\n{\n\tTreeDataType treeData;\n\n\tInitPhrasing( &treeData );\n\n\tFindInterval( pgdata, &treeData );\n\tSetInfo( pgdata->nPhoneSeq, &treeData );\n\tDiscard1( &treeData );\n\tDiscard2( &treeData );\n\tif ( all_phrasing ) {\n\t\tSaveList( &treeData );\n\t\tCountMatchCnnct( &treeData, pgdata->bUserArrCnnct, pgdata->nPhoneSeq );\n\t\tSortListByScore( &treeData );\n\t\tNextCut( &treeData, &pgdata->phrOut );\n\t} else {\n\t\tDoDpPhrasing( pgdata, &treeData );\n\t}\n\n\tShowList( pgdata, &treeData );\n\n\t/* set phrasing output */\n\tOutputRecordStr( pgdata, &treeData );\n\tSaveDispInterval( &pgdata->phrOut, &treeData );\n\n\t/* free \"phrase\" */\n\tCleanUpMem( &treeData );\n\treturn 0;\n}",
        "begin_line": 1075,
        "end_line": 1103,
        "is_bug": false
    },
    {
        "name": "tree.RecursiveSave#761",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.RecursiveSave( int depth, int to, int *record, TreeDataType *ptd )",
        "snippet": "static void RecursiveSave( int depth, int to, int *record, TreeDataType *ptd )\n{\n\tint first, i;\n\t/* to find first interval */\n\tfor (\n\t\tfirst = record[ depth - 1 ] + 1;\n\t\tptd->interval[ first ].from < to && first < ptd->nInterval;\n\t\tfirst++ )\n\t\t;\n\n\tif ( first == ptd->nInterval ) {\n\t\tSaveRecord( record + 1, depth - 1, ptd );\n\t\treturn;\n\t}\n\trecord[ depth ] = first;\n\tRecursiveSave( depth + 1, ptd->interval[ first ].to, record, ptd );\n\t/* for each interval which intersects first */\n\tfor (\n\t\ti= first + 1;\n\t\tPhraseIntervalIntersect(\n\t\t\tptd->interval[ first ],\n\t\t\tptd->interval[ i ] ) && i < ptd->nInterval;\n\t\t\ti++ ) {\n\t\trecord[ depth ] = i;\n\t\tRecursiveSave( depth + 1, ptd->interval[ i ].to,record, ptd );\n\t}\n}",
        "begin_line": 761,
        "end_line": 787,
        "is_bug": false
    },
    {
        "name": "tree.SaveDispInterval#801",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.SaveDispInterval( PhrasingOutput *ppo, TreeDataType *ptd )",
        "snippet": "static void SaveDispInterval( PhrasingOutput *ppo, TreeDataType *ptd )\n{\n\tint i;\n\n\tfor ( i = 0; i < ptd->phList->nInter; i++ ) {\n\t\tppo->dispInterval[ i ].from =\n\t\t\tptd->interval[ ptd->phList->arrIndex[ i ] ].from;\n\t\tppo->dispInterval[ i ].to =\n\t\t\tptd->interval[ ptd->phList->arrIndex[ i ] ].to;\n\t}\n\tppo->nDispInterval = ptd->phList->nInter;\n}",
        "begin_line": 801,
        "end_line": 812,
        "is_bug": false
    },
    {
        "name": "tree.SaveList#789",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.SaveList( TreeDataType *ptd )",
        "snippet": "static void SaveList( TreeDataType *ptd )\n{\n\tint record[ MAX_PHONE_SEQ_LEN + 1 ] = { -1 };\n\n\tRecursiveSave( 1, 0, record, ptd );\n}",
        "begin_line": 789,
        "end_line": 794,
        "is_bug": false
    },
    {
        "name": "tree.SaveRecord#725",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.SaveRecord( const int *record, int nInter, TreeDataType *ptd )",
        "snippet": "static void SaveRecord( const int *record, int nInter, TreeDataType *ptd )\n{\n\tRecordNode *now, *p, *pre;\n\n\tpre = NULL;\n\tfor ( p = ptd->phList; p; ) {\n\t\t/* if  'p' contains 'record', then discard 'record'. */\n\t\tif ( IsRecContain( p->arrIndex, p->nInter, record, nInter, ptd ) )\n\t\t\treturn;\n\n\t\t/* if 'record' contains 'p', then discard 'p'\n\t\t * -- We must deal with the linked list. */\n\t\tif ( IsRecContain( record, nInter, p->arrIndex, p->nInter, ptd ) ) {\n\t\t\tRecordNode *tp = p;\n\n\t\t\tif ( pre )\n\t\t\t\tpre->next = p->next;\n\t\t\telse\n\t\t\t\tptd->phList = ptd->phList->next;\n\t\t\tp = p->next;\n\t\t\tfree( tp->arrIndex );\n\t\t\tfree( tp );\n\t\t}\n\t\telse\n\t\t\tpre = p, p = p->next;\n\t}\n\tnow = ALC( RecordNode, 1 );\n\tassert( now );\n\tnow->next = ptd->phList;\n\tnow->arrIndex = ALC( int, nInter );\n\tassert( now->arrIndex );\n\tnow->nInter = nInter;\n\tmemcpy( now->arrIndex, record, nInter * sizeof( int ) );\n\tptd->phList = now;\n}",
        "begin_line": 725,
        "end_line": 759,
        "is_bug": false
    },
    {
        "name": "tree.SetInfo#415",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.SetInfo( int len, TreeDataType *ptd )",
        "snippet": "static void SetInfo( int len, TreeDataType *ptd )\n{\n\tint i, a;\n\n\tfor ( i = 0; i <= len; i++ )\n\t\tptd->leftmost[ i ] = i;\n\tfor ( i = 0; i < ptd->nInterval; i++ ) {\n\t\tptd->graph[ ptd->interval[ i ].from ][ ptd->interval[ i ].to ] = 1;\n\t\tptd->graph[ ptd->interval[ i ].to ][ ptd->interval[ i ].from ] = 1;\n\t}\n\n\t/* set leftmost */\n\tfor ( a = 0; a <= len; a++ ) {\n\t\tfor ( i = 0; i <= len; i++ ) {\n\t\t\tif ( ! ( ptd->graph[ a ][ i ] ) )\n\t\t\t\tcontinue;\n\t\t\tif ( ptd->leftmost[ i ] < ptd->leftmost[ a ] )\n\t\t\t\tptd->leftmost[ a ] = ptd->leftmost[ i ];\n\t\t}\n\t}\n}",
        "begin_line": 415,
        "end_line": 435,
        "is_bug": false
    },
    {
        "name": "tree.ShowList#857",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.ShowList( ChewingData *pgdata, const TreeDataType *ptd )",
        "snippet": "static void ShowList( ChewingData *pgdata, const TreeDataType *ptd )\n{\n\tconst RecordNode *p;\n\tint i;\n\n\tDEBUG_OUT( \"After SaveList :\\n\" );\n\tfor ( p = ptd->phList; p; p = p->next ) {\n\t\tDEBUG_OUT( \"  interval : \" );\n\t\tfor ( i = 0; i < p->nInter; i++ ) {\n\t\t\tDEBUG_OUT(\n\t\t\t\t\"[%d %d] \",\n\t\t\t\tptd->interval[ p->arrIndex[ i ] ].from,\n\t\t\t\tptd->interval[ p->arrIndex[ i ] ].to );\n\t\t}\n\t\tDEBUG_OUT(\n\t\t\t\"\\n\"\n\t\t\t   \"      score : %d , nMatchCnnct : %d\\n\",\n\t\t\tp->score,\n\t\t\tp->nMatchCnnct );\n\t}\n\tDEBUG_OUT( \"\\n\" );\n}",
        "begin_line": 857,
        "end_line": 878,
        "is_bug": false
    },
    {
        "name": "tree.SortByIncreaseEnd#911",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.SortByIncreaseEnd( const void *x, const void *y)",
        "snippet": "static int SortByIncreaseEnd( const void *x, const void *y)\n{\n\tconst PhraseIntervalType *interval_x = (const PhraseIntervalType *) x;\n\tconst PhraseIntervalType *interval_y = (const PhraseIntervalType *) y;\n\n\tif ( interval_x->to < interval_y->to )\n\t\treturn -1;\n\n\tif ( interval_x->to > interval_y->to )\n\t\treturn 1;\n\n\treturn 0;\n}",
        "begin_line": 911,
        "end_line": 923,
        "is_bug": false
    },
    {
        "name": "tree.SortListByScore#687",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.SortListByScore( TreeDataType *ptd )",
        "snippet": "static void SortListByScore( TreeDataType *ptd )\n{\n\tint i, listLen;\n\tRecordNode *p, **arr;\n\n\tfor (\n\t\tlistLen = 0, p = ptd->phList;\n\t\tp;\n\t\tlistLen++, p = p->next )\n\t\t;\n\tptd->nPhListLen = listLen;\n\n\tarr = ALC( RecordNode *, listLen );\n\tassert( arr );\n\n\tfor (\n\t\ti = 0, p = ptd->phList;\n\t\ti < listLen;\n\t\tp = p->next, i++ ) {\n\t\tarr[ i ] = p;\n\t\tp->score = LoadPhraseAndCountScore(\n\t\t\tp->arrIndex,\n\t\t\tp->nInter,\n\t\t\tptd );\n\t}\n\n\tqsort( arr, listLen, sizeof( RecordNode * ), (CompFuncType) CompRecord );\n\n\tptd->phList = arr[ 0 ];\n\tfor ( i = 1; i < listLen; i++ ) {\n\t\tarr[ i - 1 ]->next = arr[ i ];\n\t}\n\tarr[ listLen - 1 ]->next = NULL;\n\n\tfree( arr );\n}",
        "begin_line": 687,
        "end_line": 722,
        "is_bug": false
    },
    {
        "name": "tree.TerminateTree#79",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.TerminateTree( ChewingData *pgdata )",
        "snippet": "void TerminateTree( ChewingData *pgdata )\n{\n\t\tpgdata->static_data.tree = NULL;\n\t\tplat_mmap_close( &pgdata->static_data.tree_mmap );\n}",
        "begin_line": 79,
        "end_line": 83,
        "is_bug": false
    },
    {
        "name": "tree.TreeChildRange#282",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.TreeChildRange( ChewingData *pgdata, const TreeType *parent )",
        "snippet": "void TreeChildRange( ChewingData *pgdata, const TreeType *parent )\n{\n\tpgdata->static_data.tree_cur_pos = pgdata->static_data.tree + GetUint24(parent->child.begin);\n\tpgdata->static_data.tree_end_pos = pgdata->static_data.tree + GetUint24(parent->child.end);\n}",
        "begin_line": 282,
        "end_line": 286,
        "is_bug": false
    },
    {
        "name": "tree.TreeFindPhrase#253",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.TreeFindPhrase( ChewingData *pgdata, int begin, int end, const uint16_t *phoneSeq )",
        "snippet": "const TreeType *TreeFindPhrase( ChewingData *pgdata, int begin, int end, const uint16_t *phoneSeq )\n{\n\tTreeType target;\n\tconst TreeType *tree_p = pgdata->static_data.tree;\n\tuint32_t range[2];\n\tint i;\n\n\tfor ( i = begin; i <= end; i++ ) {\n\t\tPutUint16(phoneSeq[i], target.key);\n\t\trange[0] = GetUint24(tree_p->child.begin);\n\t\trange[1] = GetUint24(tree_p->child.end);\n\t\tassert(range[1] >= range[0]);\n\t\ttree_p = (const TreeType*)bsearch(&target, pgdata->static_data.tree + range[0],\n\t\t\t\t\t\t  range[1] - range[0], sizeof(TreeType), CompTreeType);\n\n\t\t/* if not found any word then fail. */\n\t\tif( !tree_p )\n\t\t\treturn NULL;\n\t}\n\n\t/* If its child has no key value of 0, then it is only a \"half\" phrase. */\n\tif( GetUint16(pgdata->static_data.tree[ GetUint24(tree_p->child.begin) ].key) != 0)\n\t\treturn NULL;\n\treturn tree_p;\n}",
        "begin_line": 253,
        "end_line": 277,
        "is_bug": false
    },
    {
        "name": "tree.internal_release_Phrase#306",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.internal_release_Phrase( UsedPhraseMode mode, Phrase *pUser, Phrase *pDict )",
        "snippet": "static void internal_release_Phrase( UsedPhraseMode mode, Phrase *pUser, Phrase *pDict )\n{\n\t/* we must free unused phrase entry to avoid memory leak. */\n\tswitch ( mode ) {\n\t\tcase USED_PHRASE_USER:\n\t\t\tif ( pDict != NULL )\n\t\t\t\tfree( pDict );\n\t\t\tbreak;\n\t\tcase USED_PHRASE_DICT:\n\t\t\tif ( pUser != NULL )\n\t\t\t\tfree( pUser );\n\t\t\tbreak;\n\t\tdefault: /* In fact, it is alwyas 0 */\n\t\t\tif ( pDict != NULL )\n\t\t\t\tfree( pDict );\n\t\t\tif ( pUser != NULL )\n\t\t\t\tfree( pUser );\n\t\t\tbreak;\n\t}\n}",
        "begin_line": 306,
        "end_line": 325,
        "is_bug": false
    },
    {
        "name": "tree.rule_largest_avgwordlen#610",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.rule_largest_avgwordlen( const int *record, int nRecord, const TreeDataType *ptd )",
        "snippet": "static int rule_largest_avgwordlen( const int *record, int nRecord, const TreeDataType *ptd )\n{\n\t/* constant factor 6=1*2*3, to keep value as integer */\n\treturn 6 * rule_largest_sum( record, nRecord, ptd ) / nRecord;\n}",
        "begin_line": 610,
        "end_line": 614,
        "is_bug": false
    },
    {
        "name": "tree.rule_largest_freqsum#633",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.rule_largest_freqsum( const int *record, int nRecord, const TreeDataType *ptd )",
        "snippet": "static int rule_largest_freqsum( const int *record, int nRecord, const TreeDataType *ptd )\n{\n\tint i, score = 0;\n\tPhraseIntervalType inter;\n\n\tfor ( i = 0; i < nRecord; i++ ) {\n\t\tinter = ptd->interval[ record[ i ] ];\n\t\tassert( inter.p_phr );\n\n\t\t/* We adjust the 'freq' of One-word Phrase */\n\t\tscore += ( inter.to - inter.from == 1 ) ?\n\t\t\t( inter.p_phr->freq / 512 ) :\n\t\t\tinter.p_phr->freq;\n\t}\n\treturn score;\n}",
        "begin_line": 633,
        "end_line": 648,
        "is_bug": false
    },
    {
        "name": "tree.rule_largest_sum#597",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.rule_largest_sum( const int *record, int nRecord, const TreeDataType *ptd )",
        "snippet": "static int rule_largest_sum( const int *record, int nRecord, const TreeDataType *ptd )\n{\n\tint i, score = 0;\n\tPhraseIntervalType inter;\n\n\tfor ( i = 0; i < nRecord; i++ ) {\n\t\tinter = ptd->interval[ record[ i ] ];\n\t\tassert( inter.p_phr );\n\t\tscore += inter.to - inter.from;\n\t}\n\treturn score;\n}",
        "begin_line": 597,
        "end_line": 608,
        "is_bug": false
    },
    {
        "name": "tree.rule_smallest_lenvariance#616",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.rule_smallest_lenvariance( const int *record, int nRecord, const TreeDataType *ptd )",
        "snippet": "static int rule_smallest_lenvariance( const int *record, int nRecord, const TreeDataType *ptd )\n{\n\tint i, j, score = 0;\n\tPhraseIntervalType inter1, inter2;\n\n\t/* kcwu: heuristic? why variance no square function? */\n\tfor ( i = 0; i < nRecord; i++ ) {\n\t\tfor ( j = i + 1; j < nRecord; j++ ) {\n\t\t\tinter1 = ptd->interval[ record[ i ] ];\n\t\t\tinter2 = ptd->interval[ record[ j ] ];\n\t\t\tassert( inter1.p_phr && inter2.p_phr );\n\t\t\tscore += abs((inter1.to - inter1.from) - (inter2.to - inter2.from));\n\t\t}\n\t}\n\treturn -score;\n}",
        "begin_line": 616,
        "end_line": 631,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.GetCurrentLifeTime#181",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.GetCurrentLifeTime( ChewingData *pgdata )",
        "snippet": "static int GetCurrentLifeTime( ChewingData *pgdata )\n{\n\treturn pgdata->static_data.new_lifetime;\n}",
        "begin_line": 181,
        "end_line": 184,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.IncreaseLifeTime#489",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.IncreaseLifeTime( ChewingData *pgdata )",
        "snippet": "void IncreaseLifeTime( ChewingData *pgdata )\n{\n\t++pgdata->static_data.new_lifetime;\n}",
        "begin_line": 489,
        "end_line": 492,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.LoadMaxFreq#101",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.LoadMaxFreq(ChewingData *pgdata, const uint16_t phoneSeq[], int len)",
        "snippet": "static int LoadMaxFreq(ChewingData *pgdata, const uint16_t phoneSeq[], int len)\n{\n\tconst TreeType *tree_pos;\n\tPhrase *phrase = ALC(Phrase, 1);\n\tint maxFreq = FREQ_INIT_VALUE;\n\tint max_userphrase_freq;\n\tint ret;\n\n\ttree_pos = TreeFindPhrase(pgdata, 0, len - 1, phoneSeq);\n\tif (tree_pos) {\n\t\tGetPhraseFirst(pgdata, phrase, tree_pos);\n\t\tdo {\n\t\t\tif (phrase->freq > maxFreq)\n\t\t\t\tmaxFreq = phrase->freq;\n\t\t} while(GetVocabNext(pgdata, phrase));\n\t}\n\tfree(phrase);\n\n\tassert(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_GET_MAX_FREQ]);\n\n\tret = UserBindPhone(pgdata, STMT_USERPHRASE_GET_MAX_FREQ, phoneSeq, len);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"UserBindPhone returns %d\", ret);\n\t\treturn maxFreq;\n\t}\n\n\tret = sqlite3_step(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_GET_MAX_FREQ]);\n\tif (ret !=  SQLITE_ROW)\n\t\treturn maxFreq;\n\n\tret = sqlite3_reset(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_GET_MAX_FREQ]);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"sqlite3_reset returns %d\", ret);\n\t\treturn maxFreq;\n\t}\n\n\tmax_userphrase_freq = sqlite3_column_int(\n\t\tpgdata->static_data.stmt_userphrase[STMT_USERPHRASE_GET_MAX_FREQ],\n\t\tSQL_STMT_USERPHRASE[STMT_USERPHRASE_GET_MAX_FREQ].column[COLUMN_USERPHRASE_USER_FREQ]);\n\n\tif (max_userphrase_freq > maxFreq)\n\t\tmaxFreq = max_userphrase_freq;\n\n\treturn maxFreq;\n}",
        "begin_line": 101,
        "end_line": 145,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.LoadOriginalFreq#75",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.LoadOriginalFreq( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int len )",
        "snippet": "static int LoadOriginalFreq( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int len )\n{\n\tconst TreeType *tree_pos;\n\tint retval;\n\tPhrase *phrase = ALC( Phrase, 1 );\n\n\ttree_pos = TreeFindPhrase( pgdata, 0, len - 1, phoneSeq );\n\tif ( tree_pos ) {\n\t\tGetPhraseFirst( pgdata, phrase, tree_pos );\n\t\tdo {\n\t\t\t/* find the same phrase */\n\t\t\tif ( ! strcmp(\n\t\t\t\tphrase->phrase,\n\t\t\t\twordSeq ) ) {\n\t\t\t\tretval = phrase->freq;\n\t\t\t\tfree( phrase );\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t} while ( GetVocabNext( pgdata, phrase ) );\n\t}\n\n\tfree( phrase );\n\treturn FREQ_INIT_VALUE;\n}",
        "begin_line": 75,
        "end_line": 98,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.LogUserPhrase#186",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.LogUserPhrase( \tChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int orig_freq, int max_freq, int user_freq, int recent_time)",
        "snippet": "static void LogUserPhrase(\n\tChewingData *pgdata,\n\tconst uint16_t phoneSeq[],\n\tconst char wordSeq[],\n\tint orig_freq,\n\tint max_freq,\n\tint user_freq,\n\tint recent_time)\n{\n\t/* Size of each phone is len(\"0x1234 \") = 7 */\n\tchar buf[7 * MAX_PHRASE_LEN + 1] = { 0 };\n\tint i;\n\n\tfor (i = 0; i < MAX_PHRASE_LEN; ++i) {\n\t\tif (phoneSeq[i] == 0)\n\t\t\tbreak;\n\t\tsnprintf(buf + 7 * i, 7 + 1, \"%#06x \", phoneSeq[i]);\n\t}\n\n\tLOG_INFO( \"userphrase %s, phone = %s, orig_freq = %d, max_freq = %d, user_freq = %d, recent_time = %d\",\n\t\twordSeq, buf, orig_freq, max_freq, user_freq, recent_time );\n}",
        "begin_line": 186,
        "end_line": 207,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UpdateFreq#148",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UpdateFreq( int freq, int maxfreq, int origfreq, int deltatime )",
        "snippet": "static int UpdateFreq( int freq, int maxfreq, int origfreq, int deltatime )\n{\n\tint delta;\n\n\t/* Short interval */\n\tif ( deltatime < 4000 ) {\n\t\tdelta = ( freq >= maxfreq ) ?\n\t\t\tmin(\n\t\t\t\t( maxfreq - origfreq ) / 5 + 1,\n\t\t\t\tSHORT_INCREASE_FREQ ) :\n\t\t\tmax(\n\t\t\t\t( maxfreq - origfreq ) / 5 + 1,\n\t\t\t\tSHORT_INCREASE_FREQ );\n\t\treturn min( freq + delta, MAX_ALLOW_FREQ );\n\t}\n\t/* Medium interval */\n\telse if ( deltatime < 50000 ) {\n\t\tdelta = ( freq >= maxfreq ) ?\n\t\t\tmin(\n\t\t\t\t( maxfreq - origfreq ) / 10 + 1,\n\t\t\t\tMEDIUM_INCREASE_FREQ ) :\n\t\t\tmax(\n\t\t\t\t( maxfreq - origfreq ) / 10 + 1,\n\t\t\t\tMEDIUM_INCREASE_FREQ );\n\t\treturn min( freq + delta, MAX_ALLOW_FREQ );\n\t}\n\t/* long interval */\n\telse {\n\t\tdelta = max( ( freq - origfreq ) / 5, LONG_DECREASE_FREQ );\n\t\treturn max( freq - delta, origfreq );\n\t}\n}",
        "begin_line": 148,
        "end_line": 179,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UserBindPhone#23",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UserBindPhone( \tChewingData *pgdata, int index, const uint16_t phoneSeq[], int len)",
        "snippet": "static int UserBindPhone(\n\tChewingData *pgdata,\n\tint index,\n\tconst uint16_t phoneSeq[],\n\tint len)\n{\n\tint i;\n\tint ret;\n\n\tassert(pgdata);\n\tassert(phoneSeq);\n\n\tif (len > MAX_PHRASE_LEN) {\n\t\tLOG_WARN(\"phoneSeq length %d > MAX_PHRASE_LEN(%d)\", len, MAX_PHRASE_LEN);\n\t\treturn -1;\n\t}\n\n\tret = sqlite3_bind_int(\n\t\tpgdata->static_data.stmt_userphrase[index],\n\t\tBIND_USERPHRASE_LENGTH, len);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < len; ++i) {\n\t\tret = sqlite3_bind_int(\n\t\t\tpgdata->static_data.stmt_userphrase[index],\n\t\t\tBIND_USERPHRASE_PHONE_0 + i,\n\t\t\tphoneSeq[i]);\n\t\tif (ret != SQLITE_OK) {\n\t\t\tLOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (i = len; i < MAX_PHRASE_LEN; ++i) {\n\t\tret = sqlite3_bind_int(\n\t\t\tpgdata->static_data.stmt_userphrase[index],\n\t\t\tBIND_USERPHRASE_PHONE_0 + i,\n\t\t\t0);\n\t\tif (ret != SQLITE_OK) {\n\t\t\tLOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn SQLITE_OK;\n}",
        "begin_line": 23,
        "end_line": 71,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UserGetPhraseEnd#484",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UserGetPhraseEnd(ChewingData *pgdata, const uint16_t phoneSeq[])",
        "snippet": "void UserGetPhraseEnd(ChewingData *pgdata, const uint16_t phoneSeq[])\n{\n\t/* FIXME: Remove this */\n}",
        "begin_line": 484,
        "end_line": 487,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UserGetPhraseFirst#424",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UserGetPhraseFirst(ChewingData *pgdata, const uint16_t phoneSeq[])",
        "snippet": "UserPhraseData *UserGetPhraseFirst(ChewingData *pgdata, const uint16_t phoneSeq[])\n{\n\tint ret;\n\tint len;\n\n\tassert(pgdata);\n\tassert(phoneSeq);\n\n\tassert(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE]);\n\tret = sqlite3_reset(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE]);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"sqlite3_reset returns %d\", ret);\n\t\treturn NULL;\n\t}\n\n\tlen = GetPhoneLen(phoneSeq);\n\tret = UserBindPhone(pgdata, STMT_USERPHRASE_SELECT_BY_PHONE, phoneSeq, len);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"UserBindPhone returns %d\", ret);\n\t\treturn NULL;\n\t}\n\n\treturn UserGetPhraseNext(pgdata, phoneSeq);\n}",
        "begin_line": 424,
        "end_line": 447,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UserGetPhraseNext#449",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UserGetPhraseNext(ChewingData *pgdata, const uint16_t phoneSeq[])",
        "snippet": "UserPhraseData *UserGetPhraseNext(ChewingData *pgdata, const uint16_t phoneSeq[])\n{\n\tint ret;\n\n\tassert(pgdata);\n\tassert(phoneSeq);\n\n\tret = sqlite3_step(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE]);\n\tif (ret !=  SQLITE_ROW) return NULL;\n\n\t/* FIXME: shall not remove const here. */\n\tpgdata->userphrase_data.wordSeq = (char *) sqlite3_column_text(\n\t\tpgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE],\n\t\tSQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE].column[COLUMN_USERPHRASE_PHRASE]);\n\tpgdata->userphrase_data.phoneSeq = (uint16_t *) phoneSeq;\n\n\tpgdata->userphrase_data.recentTime = sqlite3_column_int(\n\t\tpgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE],\n\t\tSQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE].column[COLUMN_USERPHRASE_TIME]);\n\n\tpgdata->userphrase_data.userfreq = sqlite3_column_int(\n\t\tpgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE],\n\t\tSQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE].column[COLUMN_USERPHRASE_USER_FREQ]);\n\n\tpgdata->userphrase_data.maxfreq = sqlite3_column_int(\n\t\tpgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE],\n\t\tSQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE].column[COLUMN_USERPHRASE_MAX_FREQ]);\n\n\tpgdata->userphrase_data.origfreq = sqlite3_column_int(\n\t\tpgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE],\n\t\tSQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE].column[COLUMN_USERPHRASE_ORIG_FREQ]);\n\n\treturn &pgdata->userphrase_data;\n}",
        "begin_line": 449,
        "end_line": 482,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UserUpdatePhrase#214",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UserUpdatePhrase(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[])",
        "snippet": "int UserUpdatePhrase(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[])\n{\n\tint ret;\n\tint action;\n\tint phone_len;\n\tint word_len;\n\n\tint orig_freq;\n\tint max_freq;\n\tint user_freq;\n\tint recent_time;\n\tint orig_time;\n\n\tassert(pgdata);\n\tassert(phoneSeq);\n\tassert(wordSeq);\n\n\tphone_len = GetPhoneLen(phoneSeq);\n\tword_len = ueStrLen(wordSeq);\n\n\tif (phone_len != word_len) {\n\t\tLOG_WARN(\"Do not update userphrase because phoneSeq length %d != wordSeq length %d\", phone_len, word_len);\n\t\treturn USER_UPDATE_FAIL;\n\t}\n\n\tif (word_len > MAX_PHRASE_LEN) {\n\t\tLOG_WARN(\"wordSeq length %d > MAX_PHRASE_LEN (%d)\", word_len, MAX_PHRASE_LEN);\n\t\treturn USER_UPDATE_FAIL;\n\t}\n\n\tret = UserBindPhone(pgdata, STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE, phoneSeq, phone_len);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"UserBindPhone returns %d\", ret);\n\t\taction = USER_UPDATE_FAIL;\n\t\tgoto end;\n\t}\n\n\tret = sqlite3_bind_text(\n\t\tpgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE],\n\t\tBIND_USERPHRASE_PHRASE,\n\t\twordSeq, -1, SQLITE_STATIC);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"sqlite3_bind_text returns %d\", ret);\n\t\taction = USER_UPDATE_FAIL;\n\t\tgoto end;\n\t}\n\n\trecent_time = GetCurrentLifeTime(pgdata);\n\n\tret = sqlite3_step(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE]);\n\tif (ret == SQLITE_ROW) {\n\t\taction = USER_UPDATE_MODIFY;\n\n\t\torig_freq = sqlite3_column_int(\n\t\t\tpgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE],\n\t\t\tSQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE].column[COLUMN_USERPHRASE_ORIG_FREQ]);\n\n\t\tmax_freq = LoadMaxFreq(pgdata, phoneSeq, phone_len);\n\n\t\tuser_freq = sqlite3_column_int(\n\t\t\tpgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE],\n\t\t\tSQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE].column[COLUMN_USERPHRASE_USER_FREQ]);\n\n\t\torig_time = sqlite3_column_int(\n\t\t\tpgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE],\n\t\t\tSQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE].column[COLUMN_USERPHRASE_TIME]);\n\n\t\tuser_freq = UpdateFreq(user_freq, max_freq, orig_freq, recent_time - orig_time);\n\t} else {\n\t\taction = USER_UPDATE_INSERT;\n\n\t\torig_freq = LoadOriginalFreq(pgdata, phoneSeq, wordSeq, word_len);\n\t\tmax_freq = LoadMaxFreq(pgdata, phoneSeq, phone_len);\n\t\tuser_freq = orig_freq;\n\t}\n\n\tassert(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT]);\n\n\tret = sqlite3_bind_int(\n\t\tpgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT],\n\t\tBIND_USERPHRASE_TIME,\n\t\trecent_time);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n\t\taction = USER_UPDATE_FAIL;\n\t\tgoto end;\n\t}\n\n\tret = sqlite3_bind_int(\n\t\tpgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT],\n\t\tBIND_USERPHRASE_USER_FREQ,\n\t\tuser_freq);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n\t\taction = USER_UPDATE_FAIL;\n\t\tgoto end;\n\t}\n\n\tret = sqlite3_bind_int(\n\t\tpgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT],\n\t\tBIND_USERPHRASE_MAX_FREQ,\n\t\tmax_freq);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n\t\taction = USER_UPDATE_FAIL;\n\t\tgoto end;\n\t}\n\n\tret = sqlite3_bind_int(\n\t\tpgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT],\n\t\tBIND_USERPHRASE_ORIG_FREQ,\n\t\torig_freq);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n\t\taction = USER_UPDATE_FAIL;\n\t\tgoto end;\n\t}\n\n\tret = UserBindPhone(pgdata, STMT_USERPHRASE_UPSERT, phoneSeq, phone_len);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"UserBindPhone returns %d\", ret);\n\t\taction = USER_UPDATE_FAIL;\n\t\tgoto end;\n\t}\n\n\tret = sqlite3_bind_text(\n\t\tpgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT],\n\t\tBIND_USERPHRASE_PHRASE,\n\t\twordSeq, -1, SQLITE_STATIC);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"sqlite3_bind_text returns %d\", ret);\n\t\taction = USER_UPDATE_FAIL;\n\t\tgoto end;\n\t}\n\n\tret = sqlite3_step(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT]);\n\tif (ret != SQLITE_DONE) {\n\t\tLOG_ERROR(\"sqlite3_step returns %d\", ret);\n\t\taction = USER_UPDATE_FAIL;\n\t\tgoto end;\n\t}\n\n\tLogUserPhrase(pgdata, phoneSeq, wordSeq, orig_freq, max_freq, user_freq, recent_time);\n\nend:\n\tret = sqlite3_reset(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT]);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"sqlite3_reset returns %d\", ret);\n\t}\n\n\tret = sqlite3_reset(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE]);\n\tif (ret != SQLITE_OK) {\n\t\tLOG_ERROR(\"sqlite3_reset returns %d\", ret);\n\t}\n\n\treturn action;\n}",
        "begin_line": 214,
        "end_line": 370,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UserUpdatePhraseBegin#209",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UserUpdatePhraseBegin( ChewingData *pgdata )",
        "snippet": "void UserUpdatePhraseBegin( ChewingData *pgdata )\n{\n\tsqlite3_exec( pgdata->static_data.db, \"BEGIN\", 0, 0, 0 );\n}",
        "begin_line": 209,
        "end_line": 212,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UserUpdatePhraseEnd#372",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UserUpdatePhraseEnd( ChewingData *pgdata )",
        "snippet": "void UserUpdatePhraseEnd( ChewingData *pgdata )\n{\n\tsqlite3_exec( pgdata->static_data.db, \"END\", 0, 0, 0 );\n}",
        "begin_line": 372,
        "end_line": 375,
        "is_bug": false
    },
    {
        "name": "userphrase.GetDefaultUserPhrasePath#98",
        "src_path": "src/userphrase.c",
        "class_name": "userphrase",
        "signature": "userphrase.GetDefaultUserPhrasePath(ChewingData *pgdata)",
        "snippet": "char *GetDefaultUserPhrasePath(ChewingData *pgdata)\n{\n\tchar *tmp;\n\tchar *path;\n\tint len;\n\tint ret;\n\n\tassert(pgdata);\n\n\ttmp = getenv(\"CHEWING_USER_PATH\");\n\tif (tmp && access(tmp, W_OK) == 0) {\n\t\tret = asprintf(&path, \"%s/%s\", tmp, DB_NAME);\n\t\tif (ret == -1) {\n\t\t\tLOG_ERROR(\"asprintf returns %d\", ret);\n\t\t\texit(-1);\n\t\t}\n\t\treturn path;\n\t}\n\n\ttmp = getenv(\"HOME\");\n\tif (!tmp) {\n\t\ttmp = PLAT_TMPDIR;\n\t}\n\n\tlen = snprintf(NULL, 0, \"%s/%s/%s\", tmp, USERPHRASE_DIR, DB_NAME);\n\t++len;\n\tpath = malloc(len);\n\tif (!path) {\n\t\tLOG_ERROR(\"malloc returns %#p\", path);\n\t\texit(-1);\n\t}\n\n\tsnprintf(path, len, \"%s/%s\", tmp, USERPHRASE_DIR);\n\tPLAT_MKDIR(path);\n\tsnprintf(path, len, \"%s/%s/%s\", tmp, USERPHRASE_DIR, DB_NAME);\n\n\treturn path;\n}",
        "begin_line": 98,
        "end_line": 135,
        "is_bug": false
    },
    {
        "name": "zuin.DefPhoInput#150",
        "src_path": "src/zuin.c",
        "class_name": "zuin",
        "signature": "zuin.DefPhoInput( ChewingData *pgdata, int key )",
        "snippet": "static int DefPhoInput( ChewingData *pgdata, int key )\n{\n\tZuinData *pZuin = &(pgdata->zuinData);\n\tint type = 0, inx = 0;\n\tint i;\n\n\tif ( IsDefPhoEndKey( key, pZuin->kbtype ) ) {\n\t\tfor ( i = 0; i < ZUIN_SIZE; ++i )\n\t\t\tif ( pZuin->pho_inx[ i ] != 0 )\n\t\t\t\tbreak;\n\t\tif ( i < ZUIN_SIZE )\n\t\t\treturn EndKeyProcess( pgdata, key, 1 );\n\t}\n\telse {\n\t\tpZuin->pho_inx[ 3 ] = 0;\n\t}\n\n\t/* decide if the key is a phone */\n\tfor ( type = 0; type <= 3; type++ ) {\n\t\tinx = PhoneInxFromKey( key, type, pZuin->kbtype, 1 );\n\t\tif ( inx )\n\t\t\tbreak;\n\t}\n\n\t/* the key is NOT a phone */\n\tif ( type > 3 ) {\n\t\treturn ZUIN_KEY_ERROR;\n\t}\n\n\t/* fill the key into the phone buffer */\n\tpZuin->pho_inx[ type ] = inx;\n\treturn ZUIN_ABSORB;\n}",
        "begin_line": 150,
        "end_line": 182,
        "is_bug": false
    },
    {
        "name": "zuin.EndKeyProcess#94",
        "src_path": "src/zuin.c",
        "class_name": "zuin",
        "signature": "zuin.EndKeyProcess( ChewingData *pgdata, int key, int searchTimes )",
        "snippet": "static int EndKeyProcess( ChewingData *pgdata, int key, int searchTimes )\n{\n\tZuinData *pZuin = &(pgdata->zuinData);\n\tuint16_t u16Pho, u16PhoAlt;\n\tPhrase tempword;\n\tint pho_inx;\n\n\tif (\n\t\tpZuin->pho_inx[ 0 ] == 0 &&\n\t\tpZuin->pho_inx[ 1 ] == 0 &&\n\t\tpZuin->pho_inx[ 2 ] == 0 &&\n\t\tpZuin->pho_inx[ 3 ] == 0 ) {\n\t\t/*\n\t\t * Special handle for space key (Indeed very special one).\n\t\t * Un-break the situation that OnKeySpace() is not called,\n\t\t * hence the Candidate window doesn't show up, because\n\t\t * ZUIN_NO_WORD is returned.\n\t\t */\n\t\treturn (key == ' ') ? ZUIN_KEY_ERROR : ZUIN_NO_WORD;\n\t}\n\n\tpho_inx = PhoneInxFromKey( key, 3, pZuin->kbtype, searchTimes );\n\tif ( pZuin->pho_inx[ 3 ] == 0 ) {\n\t\tpZuin->pho_inx[ 3 ] = pho_inx;\n\t\tpZuin->pho_inx_alt[ 3 ] = pho_inx;\n\t}\n\telse if ( key != ' ' ) {\n\t\tpZuin->pho_inx[ 3 ] = pho_inx;\n\t\tpZuin->pho_inx_alt[ 3 ] = pho_inx;\n\t\treturn ZUIN_NO_WORD;\n\t}\n\n\tu16Pho = UintFromPhoneInx( pZuin->pho_inx );\n\tif ( GetCharFirst( pgdata, &tempword, u16Pho ) == 0 ) {\n\t\tZuinRemoveAll( pZuin );\n\t\treturn ZUIN_NO_WORD;\n\t}\n\n\tpZuin->phone = u16Pho;\n\n\tif ( pZuin->pho_inx_alt[ 0 ] == 0 &&\n\t     pZuin->pho_inx_alt[ 1 ] == 0 &&\n\t     pZuin->pho_inx_alt[ 2 ] == 0 ) {\n\t\t/* no alternative phone, copy from default as alt */\n\t\tpZuin->phoneAlt = u16Pho;\n\t}\n\telse {\n\t\tu16PhoAlt = UintFromPhoneInx( pZuin->pho_inx_alt );\n\t\tpZuin->phoneAlt = u16PhoAlt;\n\t}\n\n\tmemset( pZuin->pho_inx, 0, sizeof( pZuin->pho_inx ) );\n\tmemset( pZuin->pho_inx_alt, 0, sizeof( pZuin->pho_inx_alt ) );\n\treturn ZUIN_COMMIT;\n}",
        "begin_line": 94,
        "end_line": 148,
        "is_bug": false
    },
    {
        "name": "zuin.IsDefPhoEndKey#84",
        "src_path": "src/zuin.c",
        "class_name": "zuin",
        "signature": "zuin.IsDefPhoEndKey( int key, int kbtype )",
        "snippet": "static int IsDefPhoEndKey( int key, int kbtype )\n{\n\tif ( PhoneInxFromKey( key, 3, kbtype, 1 )  )\n\t\treturn 1;\n\n\tif ( key == ' ' )\n\t\treturn 1;\n\treturn 0;\n}",
        "begin_line": 84,
        "end_line": 92,
        "is_bug": false
    },
    {
        "name": "zuin.ZuinIsEntering#702",
        "src_path": "src/zuin.c",
        "class_name": "zuin",
        "signature": "zuin.ZuinIsEntering( ZuinData *pZuin )",
        "snippet": "int ZuinIsEntering( ZuinData *pZuin )\n{\n\tint i;\n\tif ( pZuin->kbtype >= KB_HANYU_PINYIN ) {\n\t\tif ( pZuin->pinYinData.keySeq[0] )\n\t\t\treturn 1;\n\t} else {\n\t\tfor ( i = 0; i < ZUIN_SIZE; i++ )\n\t\t\tif ( pZuin->pho_inx[ i ] )\n\t\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "begin_line": 702,
        "end_line": 714,
        "is_bug": false
    },
    {
        "name": "zuin.ZuinPhoInput#643",
        "src_path": "src/zuin.c",
        "class_name": "zuin",
        "signature": "zuin.ZuinPhoInput( ChewingData *pgdata, int key )",
        "snippet": "int ZuinPhoInput( ChewingData *pgdata, int key )\n{\n\tZuinData *pZuin = &(pgdata->zuinData);\n\n\t/* open symbol table */\n\tif ( key == '`' ) {\n\t\tpgdata->bSelect = 1;\n\t\tpgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;\n\t\tHaninSymbolInput( pgdata );\n\t\treturn ZUIN_OPEN_SYMBOL_TABLE;\n\t}\n\tswitch ( pZuin->kbtype ) {\n\t\tcase KB_HSU:\n\t\tcase KB_DVORAK_HSU:\n\t\t\treturn HsuPhoInput( pgdata, key );\n\t\t\tbreak;\n\t\tcase KB_ET26:\n\t\t\treturn ET26PhoInput( pgdata, key );\n\t\t\tbreak;\n\t\tcase KB_DACHEN_CP26:\n\t\t\treturn DACHENCP26PhoInput( pgdata, key );\n\t\t\tbreak;\n\t\tcase KB_HANYU_PINYIN:\n\t\tcase KB_THL_PINYIN:\n\t\tcase KB_MPS2_PINYIN:\n\t\t\treturn PinYinInput( pgdata, key );\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn DefPhoInput( pgdata, key );\n\t}\n\treturn ZUIN_ERROR;\n}",
        "begin_line": 643,
        "end_line": 674,
        "is_bug": false
    },
    {
        "name": "zuin.ZuinRemoveAll#695",
        "src_path": "src/zuin.c",
        "class_name": "zuin",
        "signature": "zuin.ZuinRemoveAll( ZuinData *pZuin )",
        "snippet": "int ZuinRemoveAll( ZuinData *pZuin )\n{\n\tmemset( pZuin->pho_inx, 0, sizeof( pZuin->pho_inx ) );\n\tmemset( pZuin->pinYinData.keySeq, 0, sizeof( pZuin->pinYinData.keySeq ) );\n\treturn 0;\n}",
        "begin_line": 695,
        "end_line": 700,
        "is_bug": false
    },
    {
        "name": "zuin.ZuinRemoveLast#677",
        "src_path": "src/zuin.c",
        "class_name": "zuin",
        "signature": "zuin.ZuinRemoveLast( ZuinData *pZuin )",
        "snippet": "int ZuinRemoveLast( ZuinData *pZuin )\n{\n\tint i;\n\tif ( pZuin->kbtype >= KB_HANYU_PINYIN ) {\n\t\ti = strlen( pZuin->pinYinData.keySeq );\n\t\tpZuin->pinYinData.keySeq[ i - 1 ] = '\\0';\n\t} else {\n\t\tfor ( i = 3; i >= 0; i-- ) {\n\t\t\tif ( pZuin->pho_inx[ i ] ) {\n\t\t\t\tpZuin->pho_inx[ i ] = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
        "begin_line": 677,
        "end_line": 692,
        "is_bug": false
    }
]