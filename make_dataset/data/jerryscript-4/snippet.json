[
    {
        "name": "jerry-core.api.jerry.jerry_assert_api_available#113",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_assert_api_available (void)",
        "snippet": "static inline void JERRY_ATTR_ALWAYS_INLINE\njerry_assert_api_available (void)\n{\n  JERRY_ASSERT (JERRY_CONTEXT (status_flags) & ECMA_STATUS_API_AVAILABLE);\n}",
        "begin_line": 113,
        "end_line": 117,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_create_external_function#2524",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_create_external_function (jerry_external_handler_t handler_p) /**< pointer to native handler                                                                      *   for the function */",
        "snippet": "jerry_value_t\njerry_create_external_function (jerry_external_handler_t handler_p) /**< pointer to native handler\n                                                                     *   for the function */\n{\n  jerry_assert_api_available ();\n\n  ecma_object_t *func_obj_p = ecma_op_create_external_function_object (handler_p);\n  return ecma_make_object_value (func_obj_p);\n}",
        "begin_line": 2524,
        "end_line": 2532,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_create_string#2757",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_create_string (const jerry_char_t *str_p) /**< pointer to string */",
        "snippet": "jerry_value_t\njerry_create_string (const jerry_char_t *str_p) /**< pointer to string */\n{\n  return jerry_create_string_sz (str_p, lit_zt_utf8_string_size ((lit_utf8_byte_t *) str_p));\n}",
        "begin_line": 2757,
        "end_line": 2761,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_create_string_sz#2771",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_create_string_sz (const jerry_char_t *str_p, /**< pointer to string */                         jerry_size_t str_size) /**< string size */",
        "snippet": "jerry_value_t\njerry_create_string_sz (const jerry_char_t *str_p, /**< pointer to string */\n                        jerry_size_t str_size) /**< string size */\n{\n  jerry_assert_api_available ();\n\n  ecma_string_t *ecma_str_p = ecma_new_ecma_string_from_utf8 ((lit_utf8_byte_t *) str_p,\n                                                              (lit_utf8_size_t) str_size);\n  return ecma_make_string_value (ecma_str_p);\n}",
        "begin_line": 2771,
        "end_line": 2780,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_get_global_object#1139",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_get_global_object (void)",
        "snippet": "jerry_value_t\njerry_get_global_object (void)\n{\n  jerry_assert_api_available ();\n  ecma_object_t *global_obj_p = ecma_builtin_get_global ();\n  ecma_ref_object (global_obj_p);\n  return ecma_make_object_value (global_obj_p);\n}",
        "begin_line": 1139,
        "end_line": 1146,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_init#168",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_init (jerry_init_flag_t flags) /**< combination of Jerry flags */",
        "snippet": "void\njerry_init (jerry_init_flag_t flags) /**< combination of Jerry flags */\n{\n  /* This function cannot be called twice unless jerry_cleanup is called. */\n  JERRY_ASSERT (!(JERRY_CONTEXT (status_flags) & ECMA_STATUS_API_AVAILABLE));\n\n  /* Zero out all non-external members. */\n  memset ((char *) &JERRY_CONTEXT_STRUCT + offsetof (jerry_context_t, JERRY_CONTEXT_FIRST_MEMBER), 0,\n          sizeof (jerry_context_t) - offsetof (jerry_context_t, JERRY_CONTEXT_FIRST_MEMBER));\n\n  JERRY_CONTEXT (jerry_init_flags) = flags;\n\n  jerry_make_api_available ();\n\n  jmem_init ();\n  ecma_init ();\n}",
        "begin_line": 168,
        "end_line": 184,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_is_valid_utf8_string#5217",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_is_valid_utf8_string (const jerry_char_t *utf8_buf_p, /**< UTF-8 string */                             jerry_size_t buf_size) /**< string size */",
        "snippet": "bool\njerry_is_valid_utf8_string (const jerry_char_t *utf8_buf_p, /**< UTF-8 string */\n                            jerry_size_t buf_size) /**< string size */\n{\n  return lit_is_valid_utf8_string ((lit_utf8_byte_t *) utf8_buf_p,\n                                   (lit_utf8_size_t) buf_size,\n                                   true);\n}",
        "begin_line": 5217,
        "end_line": 5224,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_make_api_available#122",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_make_api_available (void)",
        "snippet": "static inline void JERRY_ATTR_ALWAYS_INLINE\njerry_make_api_available (void)\n{\n  JERRY_CONTEXT (status_flags) |= ECMA_STATUS_API_AVAILABLE;\n}",
        "begin_line": 122,
        "end_line": 126,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_parse#507",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_parse (const jerry_char_t *source_p, /**< script source */              size_t source_size, /**< script source size */              const jerry_parse_options_t *options_p) /**< parsing options, can be NULL if not used */",
        "snippet": "jerry_value_t\njerry_parse (const jerry_char_t *source_p, /**< script source */\n             size_t source_size, /**< script source size */\n             const jerry_parse_options_t *options_p) /**< parsing options, can be NULL if not used */\n{\n#if JERRY_PARSER\n  parser_source_char_t source_char;\n  source_char.source_p = source_p;\n  source_char.source_size = source_size;\n\n  return jerry_parse_common ((void *) &source_char, options_p, JERRY_PARSE_NO_OPTS);\n#else /* !JERRY_PARSER */\n  JERRY_UNUSED (source_p);\n  JERRY_UNUSED (source_size);\n  JERRY_UNUSED (options_p);\n\n  return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_parser_not_supported_p)));\n#endif /* JERRY_PARSER */\n}",
        "begin_line": 507,
        "end_line": 525,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_parse_common#388",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_parse_common (void *source_p, /**< script source */                     const jerry_parse_options_t *options_p, /**< parsing options, can be NULL if not used */                     uint32_t parse_opts) /**< internal parsing options */",
        "snippet": "static jerry_value_t\njerry_parse_common (void *source_p, /**< script source */\n                    const jerry_parse_options_t *options_p, /**< parsing options, can be NULL if not used */\n                    uint32_t parse_opts) /**< internal parsing options */\n{\n  jerry_assert_api_available ();\n\n  if (options_p != NULL)\n  {\n    const uint32_t allowed_options = (JERRY_PARSE_STRICT_MODE\n                                      | JERRY_PARSE_MODULE\n                                      | JERRY_PARSE_HAS_ARGUMENT_LIST\n                                      | JERRY_PARSE_HAS_RESOURCE\n                                      | JERRY_PARSE_HAS_START\n                                      | JERRY_PARSE_HAS_USER_VALUE);\n    uint32_t options = options_p->options;\n\n    if ((options & ~allowed_options) != 0\n        || ((options_p->options & JERRY_PARSE_HAS_ARGUMENT_LIST)\n            && ((options_p->options & JERRY_PARSE_MODULE)\n                || !ecma_is_value_string (options_p->argument_list)))\n        || ((options_p->options & JERRY_PARSE_HAS_RESOURCE)\n            && !ecma_is_value_string (options_p->resource_name)))\n    {\n      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));\n    }\n  }\n\n#if JERRY_DEBUGGER\n  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n      && options_p != NULL\n      && (options_p->options & JERRY_PARSE_HAS_RESOURCE)\n      && ecma_is_value_string (options_p->resource_name))\n  {\n    ECMA_STRING_TO_UTF8_STRING (ecma_get_string_from_value (options_p->resource_name),\n                                resource_name_start_p,\n                                resource_name_size);\n    jerry_debugger_send_string (JERRY_DEBUGGER_SOURCE_CODE_NAME,\n                                JERRY_DEBUGGER_NO_SUBTYPE,\n                                resource_name_start_p,\n                                resource_name_size);\n    ECMA_FINALIZE_UTF8_STRING (resource_name_start_p, resource_name_size);\n  }\n#endif /* JERRY_DEBUGGER */\n\n  if (options_p != NULL)\n  {\n    parse_opts |= options_p->options & (JERRY_PARSE_STRICT_MODE | JERRY_PARSE_MODULE);\n  }\n\n  if ((parse_opts & JERRY_PARSE_MODULE) != 0)\n  {\n#if JERRY_MODULE_SYSTEM\n    JERRY_CONTEXT (module_current_p) = ecma_module_create ();\n#else /* !JERRY_MODULE_SYSTEM */\n    return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));\n#endif /* JERRY_MODULE_SYSTEM */\n  }\n\n  ecma_compiled_code_t *bytecode_data_p;\n  bytecode_data_p = parser_parse_script (source_p, parse_opts, options_p);\n\n  if (JERRY_UNLIKELY (bytecode_data_p == NULL))\n  {\n#if JERRY_MODULE_SYSTEM\n    if ((parse_opts & JERRY_PARSE_MODULE) != 0)\n    {\n      ecma_module_cleanup_context ();\n    }\n#endif /* JERRY_MODULE_SYSTEM */\n\n    return ecma_create_error_reference_from_context ();\n  }\n\n#if JERRY_MODULE_SYSTEM\n  if (JERRY_UNLIKELY (parse_opts & JERRY_PARSE_MODULE))\n  {\n    ecma_module_t *module_p = JERRY_CONTEXT (module_current_p);\n    module_p->u.compiled_code_p = bytecode_data_p;\n\n    JERRY_CONTEXT (module_current_p) = NULL;\n\n    return ecma_make_object_value ((ecma_object_t *) module_p);\n  }\n#endif /* JERRY_MODULE_SYSTEM */\n\n  if (JERRY_UNLIKELY (options_p != NULL\n                      && (options_p->options & JERRY_PARSE_HAS_ARGUMENT_LIST)))\n  {\n    ecma_object_t *global_object_p = ecma_builtin_get_global ();\n\n#if JERRY_BUILTIN_REALMS\n    JERRY_ASSERT (global_object_p == (ecma_object_t *) ecma_op_function_get_realm (bytecode_data_p));\n#endif /* JERRY_BUILTIN_REALMS */\n\n    ecma_object_t *lex_env_p = ecma_get_global_environment (global_object_p);\n    ecma_object_t *func_obj_p = ecma_op_create_simple_function_object (lex_env_p, bytecode_data_p);\n    ecma_bytecode_deref (bytecode_data_p);\n\n    return ecma_make_object_value (func_obj_p);\n  }\n\n  ecma_object_t *object_p = ecma_create_object (NULL, sizeof (ecma_extended_object_t), ECMA_OBJECT_TYPE_CLASS);\n\n  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n  ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_SCRIPT;\n  ECMA_SET_INTERNAL_VALUE_POINTER (ext_object_p->u.cls.u3.value, bytecode_data_p);\n\n  return ecma_make_object_value (object_p);\n}",
        "begin_line": 388,
        "end_line": 497,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_promise_set_callback#4978",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_promise_set_callback (jerry_promise_event_filter_t filters, /**< combination of event filters */                                  jerry_promise_callback_t callback, /**< notification callback */                                  void *user_p) /**< user pointer passed to the callback */",
        "snippet": "void jerry_promise_set_callback (jerry_promise_event_filter_t filters, /**< combination of event filters */\n                                 jerry_promise_callback_t callback, /**< notification callback */\n                                 void *user_p) /**< user pointer passed to the callback */\n{\n  jerry_assert_api_available ();\n\n#if JERRY_ESNEXT && JERRY_PROMISE_CALLBACK\n  if (filters == JERRY_PROMISE_EVENT_FILTER_DISABLE || callback == NULL)\n  {\n    JERRY_CONTEXT (promise_callback_filters) = JERRY_PROMISE_EVENT_FILTER_DISABLE;\n    return;\n  }\n\n  JERRY_CONTEXT (promise_callback_filters) = (uint32_t) filters;\n  JERRY_CONTEXT (promise_callback) = callback;\n  JERRY_CONTEXT (promise_callback_user_p) = user_p;\n#else /* !JERRY_ESNEXT && !JERRY_PROMISE_CALLBACK */\n  JERRY_UNUSED (filters);\n  JERRY_UNUSED (callback);\n  JERRY_UNUSED (user_p);\n#endif /* JERRY_ESNEXT && JERRY_PROMISE_CALLBACK */\n}",
        "begin_line": 4978,
        "end_line": 4999,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_release_value#2418",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_release_value (jerry_value_t value) /**< API value */",
        "snippet": "void\njerry_release_value (jerry_value_t value) /**< API value */\n{\n  jerry_assert_api_available ();\n\n  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))\n  {\n    ecma_deref_error_reference (ecma_get_extended_primitive_from_value (value));\n    return;\n  }\n\n  ecma_free_value (value);\n}",
        "begin_line": 2418,
        "end_line": 2430,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_return#142",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_return (jerry_value_t value) /**< return value */",
        "snippet": "static jerry_value_t\njerry_return (jerry_value_t value) /**< return value */\n{\n  if (ECMA_IS_VALUE_ERROR (value))\n  {\n    value = ecma_create_error_reference_from_context ();\n  }\n\n  return value;\n}",
        "begin_line": 142,
        "end_line": 151,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_run#564",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_run (const jerry_value_t func_val) /**< function to run */",
        "snippet": "jerry_value_t\njerry_run (const jerry_value_t func_val) /**< function to run */\n{\n  jerry_assert_api_available ();\n\n  if (!ecma_is_value_object (func_val))\n  {\n    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));\n  }\n\n  ecma_object_t *object_p = ecma_get_object_from_value (func_val);\n\n  if (!ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_SCRIPT))\n  {\n    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));\n  }\n\n  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n  const ecma_compiled_code_t *bytecode_data_p;\n  bytecode_data_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, ext_object_p->u.cls.u3.value);\n\n  JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (bytecode_data_p->status_flags) == CBC_FUNCTION_SCRIPT);\n\n  return jerry_return (vm_run_global (bytecode_data_p, object_p));\n}",
        "begin_line": 564,
        "end_line": 589,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_set_property#3637",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_set_property (const jerry_value_t obj_val, /**< object value */                     const jerry_value_t prop_name_val, /**< property name (string value) */                     const jerry_value_t value_to_set) /**< value to set */",
        "snippet": "jerry_value_t\njerry_set_property (const jerry_value_t obj_val, /**< object value */\n                    const jerry_value_t prop_name_val, /**< property name (string value) */\n                    const jerry_value_t value_to_set) /**< value to set */\n{\n  jerry_assert_api_available ();\n\n  if (ecma_is_value_error_reference (value_to_set)\n      || !ecma_is_value_object (obj_val)\n      || !ecma_is_value_prop_name (prop_name_val))\n  {\n    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));\n  }\n\n  return jerry_return (ecma_op_object_put (ecma_get_object_from_value (obj_val),\n                                           ecma_get_prop_name_from_value (prop_name_val),\n                                           value_to_set,\n                                           true));\n}",
        "begin_line": 3637,
        "end_line": 3655,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerry.jerry_value_is_error#1246",
        "src_path": "jerry-core/api/jerry.c",
        "class_name": "jerry-core.api.jerry",
        "signature": "jerry-core.api.jerry.jerry_value_is_error (const jerry_value_t value) /**< api value */",
        "snippet": "bool\njerry_value_is_error (const jerry_value_t value) /**< api value */\n{\n  jerry_assert_api_available ();\n\n  return ecma_is_value_error_reference (value);\n}",
        "begin_line": 1246,
        "end_line": 1252,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-alloc.ecma_alloc_extended_object#102",
        "src_path": "jerry-core/ecma/base/ecma-alloc.c",
        "class_name": "jerry-core.ecma.base.ecma-alloc",
        "signature": "jerry-core.ecma.base.ecma-alloc.ecma_alloc_extended_object (size_t size) /**< size of object */",
        "snippet": "extern inline ecma_extended_object_t * JERRY_ATTR_ALWAYS_INLINE\necma_alloc_extended_object (size_t size) /**< size of object */\n{\n#if JERRY_MEM_STATS\n  jmem_stats_allocate_object_bytes (size);\n#endif /* JERRY_MEM_STATS */\n\n  return jmem_heap_alloc_block (size);\n}",
        "begin_line": 102,
        "end_line": 110,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-alloc.ecma_alloc_extended_string#159",
        "src_path": "jerry-core/ecma/base/ecma-alloc.c",
        "class_name": "jerry-core.ecma.base.ecma-alloc",
        "signature": "jerry-core.ecma.base.ecma-alloc.ecma_alloc_extended_string (void)",
        "snippet": "extern inline ecma_extended_string_t * JERRY_ATTR_ALWAYS_INLINE\necma_alloc_extended_string (void)\n{\n#if JERRY_MEM_STATS\n  jmem_stats_allocate_string_bytes (sizeof (ecma_extended_string_t));\n#endif /* JERRY_MEM_STATS */\n\n  return (ecma_extended_string_t *) jmem_heap_alloc_block (sizeof (ecma_extended_string_t));\n}",
        "begin_line": 159,
        "end_line": 167,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-alloc.ecma_alloc_number#54",
        "src_path": "jerry-core/ecma/base/ecma-alloc.c",
        "class_name": "jerry-core.ecma.base.ecma-alloc",
        "signature": "jerry-core.ecma.base.ecma-alloc.ecma_alloc_number (void)",
        "snippet": "extern inline ecma_number_t * JERRY_ATTR_ALWAYS_INLINE\necma_alloc_number (void)\n{\n  return (ecma_number_t *) jmem_pools_alloc (sizeof (ecma_number_t));\n}",
        "begin_line": 54,
        "end_line": 58,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-alloc.ecma_alloc_object#74",
        "src_path": "jerry-core/ecma/base/ecma-alloc.c",
        "class_name": "jerry-core.ecma.base.ecma-alloc",
        "signature": "jerry-core.ecma.base.ecma-alloc.ecma_alloc_object (void)",
        "snippet": "extern inline ecma_object_t * JERRY_ATTR_ALWAYS_INLINE\necma_alloc_object (void)\n{\n#if JERRY_MEM_STATS\n  jmem_stats_allocate_object_bytes (sizeof (ecma_object_t));\n#endif /* JERRY_MEM_STATS */\n\n  return (ecma_object_t *) jmem_pools_alloc (sizeof (ecma_object_t));\n}",
        "begin_line": 74,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-alloc.ecma_alloc_property_pair#244",
        "src_path": "jerry-core/ecma/base/ecma-alloc.c",
        "class_name": "jerry-core.ecma.base.ecma-alloc",
        "signature": "jerry-core.ecma.base.ecma-alloc.ecma_alloc_property_pair (void)",
        "snippet": "extern inline ecma_property_pair_t * JERRY_ATTR_ALWAYS_INLINE\necma_alloc_property_pair (void)\n{\n#if JERRY_MEM_STATS\n  jmem_stats_allocate_property_bytes (sizeof (ecma_property_pair_t));\n#endif /* JERRY_MEM_STATS */\n\n  return jmem_heap_alloc_block (sizeof (ecma_property_pair_t));\n}",
        "begin_line": 244,
        "end_line": 252,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-alloc.ecma_alloc_string_buffer#215",
        "src_path": "jerry-core/ecma/base/ecma-alloc.c",
        "class_name": "jerry-core.ecma.base.ecma-alloc",
        "signature": "jerry-core.ecma.base.ecma-alloc.ecma_alloc_string_buffer (size_t size) /**< size of string */",
        "snippet": "extern inline ecma_string_t * JERRY_ATTR_ALWAYS_INLINE\necma_alloc_string_buffer (size_t size) /**< size of string */\n{\n#if JERRY_MEM_STATS\n  jmem_stats_allocate_string_bytes (size);\n#endif /* JERRY_MEM_STATS */\n\n  return jmem_heap_alloc_block (size);\n}",
        "begin_line": 215,
        "end_line": 223,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-alloc.ecma_dealloc_number#63",
        "src_path": "jerry-core/ecma/base/ecma-alloc.c",
        "class_name": "jerry-core.ecma.base.ecma-alloc",
        "signature": "jerry-core.ecma.base.ecma-alloc.ecma_dealloc_number (ecma_number_t *number_p) /**< number to be freed */",
        "snippet": "extern inline void JERRY_ATTR_ALWAYS_INLINE\necma_dealloc_number (ecma_number_t *number_p) /**< number to be freed */\n{\n  jmem_pools_free ((uint8_t *) number_p, sizeof (ecma_number_t));\n}",
        "begin_line": 63,
        "end_line": 67,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-alloc.ecma_dealloc_string_buffer#228",
        "src_path": "jerry-core/ecma/base/ecma-alloc.c",
        "class_name": "jerry-core.ecma.base.ecma-alloc",
        "signature": "jerry-core.ecma.base.ecma-alloc.ecma_dealloc_string_buffer (ecma_string_t *string_p, /**< string with data */                             size_t size) /**< size of string */",
        "snippet": "extern inline void JERRY_ATTR_ALWAYS_INLINE\necma_dealloc_string_buffer (ecma_string_t *string_p, /**< string with data */\n                            size_t size) /**< size of string */\n{\n#if JERRY_MEM_STATS\n  jmem_stats_free_string_bytes (size);\n#endif /* JERRY_MEM_STATS */\n\n  jmem_heap_free_block (string_p, size);\n}",
        "begin_line": 228,
        "end_line": 237,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_deref_object#155",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_deref_object (ecma_object_t *object_p) /**< object */",
        "snippet": "extern inline void JERRY_ATTR_ALWAYS_INLINE\necma_deref_object (ecma_object_t *object_p) /**< object */\n{\n  JERRY_ASSERT (object_p->type_flags_refs >= ECMA_OBJECT_REF_ONE);\n  object_p->type_flags_refs = (ecma_object_descriptor_t) (object_p->type_flags_refs - ECMA_OBJECT_REF_ONE);\n}",
        "begin_line": 155,
        "end_line": 160,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_free_unused_memory#2241",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_free_unused_memory (jmem_pressure_t pressure) /**< current pressure */",
        "snippet": "void\necma_free_unused_memory (jmem_pressure_t pressure) /**< current pressure */\n{\n#if JERRY_DEBUGGER\n  while ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n         && JERRY_CONTEXT (debugger_byte_code_free_tail) != ECMA_NULL_POINTER)\n  {\n    /* Wait until all byte code is freed or the connection is aborted. */\n    jerry_debugger_receive (NULL);\n  }\n#endif /* JERRY_DEBUGGER */\n\n  if (JERRY_LIKELY (pressure == JMEM_PRESSURE_LOW))\n  {\n#if JERRY_PROPERTY_HASHMAP\n    if (JERRY_CONTEXT (ecma_prop_hashmap_alloc_state) > ECMA_PROP_HASHMAP_ALLOC_ON)\n    {\n      --JERRY_CONTEXT (ecma_prop_hashmap_alloc_state);\n    }\n    JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_HIGH_PRESSURE_GC;\n#endif /* JERRY_PROPERTY_HASHMAP */\n    /*\n     * If there is enough newly allocated objects since last GC, probably it is worthwhile to start GC now.\n     * Otherwise, probability to free sufficient space is considered to be low.\n     */\n    size_t new_objects_fraction = CONFIG_ECMA_GC_NEW_OBJECTS_FRACTION;\n\n    if (JERRY_CONTEXT (ecma_gc_new_objects) * new_objects_fraction > JERRY_CONTEXT (ecma_gc_objects_number))\n    {\n      ecma_gc_run ();\n    }\n\n    return;\n  }\n  else if (pressure == JMEM_PRESSURE_HIGH)\n  {\n    /* Freeing as much memory as we currently can */\n#if JERRY_PROPERTY_HASHMAP\n    if (JERRY_CONTEXT (status_flags) & ECMA_STATUS_HIGH_PRESSURE_GC)\n    {\n      JERRY_CONTEXT (ecma_prop_hashmap_alloc_state) = ECMA_PROP_HASHMAP_ALLOC_MAX;\n    }\n    else if (JERRY_CONTEXT (ecma_prop_hashmap_alloc_state) < ECMA_PROP_HASHMAP_ALLOC_MAX)\n    {\n      ++JERRY_CONTEXT (ecma_prop_hashmap_alloc_state);\n      JERRY_CONTEXT (status_flags) |= ECMA_STATUS_HIGH_PRESSURE_GC;\n    }\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n    ecma_gc_run ();\n\n#if JERRY_PROPERTY_HASHMAP\n    /* Free hashmaps of remaining objects. */\n    jmem_cpointer_t obj_iter_cp = JERRY_CONTEXT (ecma_gc_objects_cp);\n\n    while (obj_iter_cp != JMEM_CP_NULL)\n    {\n      ecma_object_t *obj_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_iter_cp);\n\n      if (!ecma_is_lexical_environment (obj_iter_p)\n          || ecma_get_lex_env_type (obj_iter_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n      {\n        if (!ecma_is_lexical_environment (obj_iter_p)\n            && ecma_op_object_is_fast_array (obj_iter_p))\n        {\n          obj_iter_cp = obj_iter_p->gc_next_cp;\n          continue;\n        }\n\n        jmem_cpointer_t prop_iter_cp = obj_iter_p->u1.property_list_cp;\n\n        if (prop_iter_cp != JMEM_CP_NULL)\n        {\n          ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n\n          if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n          {\n            ecma_property_hashmap_free (obj_iter_p);\n          }\n        }\n\n      }\n\n      obj_iter_cp = obj_iter_p->gc_next_cp;\n    }\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n    jmem_pools_collect_empty ();\n    return;\n  }\n  else if (JERRY_UNLIKELY (pressure == JMEM_PRESSURE_FULL))\n  {\n    jerry_fatal (ERR_OUT_OF_MEMORY);\n  }\n  else\n  {\n    JERRY_ASSERT (pressure == JMEM_PRESSURE_NONE);\n    JERRY_UNREACHABLE ();\n  }\n}",
        "begin_line": 2241,
        "end_line": 2340,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_init_gc_info#114",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_init_gc_info (ecma_object_t *object_p) /**< object */",
        "snippet": "extern inline void\necma_init_gc_info (ecma_object_t *object_p) /**< object */\n{\n  JERRY_CONTEXT (ecma_gc_objects_number)++;\n  JERRY_CONTEXT (ecma_gc_new_objects)++;\n\n  JERRY_ASSERT (object_p->type_flags_refs < ECMA_OBJECT_REF_ONE);\n  object_p->type_flags_refs |= ECMA_OBJECT_REF_ONE;\n\n  object_p->gc_next_cp = JERRY_CONTEXT (ecma_gc_objects_cp);\n  ECMA_SET_NON_NULL_POINTER (JERRY_CONTEXT (ecma_gc_objects_cp), object_p);\n}",
        "begin_line": 114,
        "end_line": 125,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_ref_object#146",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_ref_object (ecma_object_t *object_p) /**< object */",
        "snippet": "void\necma_ref_object (ecma_object_t *object_p) /**< object */\n{\n  ecma_ref_object_inline (object_p);\n}",
        "begin_line": 146,
        "end_line": 150,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_ref_object_inline#130",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_ref_object_inline (ecma_object_t *object_p) /**< object */",
        "snippet": "extern inline void JERRY_ATTR_ALWAYS_INLINE\necma_ref_object_inline (ecma_object_t *object_p) /**< object */\n{\n  if (JERRY_LIKELY (object_p->type_flags_refs < ECMA_OBJECT_MAX_REF))\n  {\n    object_p->type_flags_refs = (ecma_object_descriptor_t) (object_p->type_flags_refs + ECMA_OBJECT_REF_ONE);\n  }\n  else\n  {\n    jerry_fatal (ERR_REF_COUNT_LIMIT);\n  }\n}",
        "begin_line": 130,
        "end_line": 141,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-conversion.ecma_number_to_uint32#790",
        "src_path": "jerry-core/ecma/base/ecma-helpers-conversion.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-conversion",
        "signature": "jerry-core.ecma.base.ecma-helpers-conversion.ecma_number_to_uint32 (ecma_number_t num) /**< ecma-number */",
        "snippet": "uint32_t\necma_number_to_uint32 (ecma_number_t num) /**< ecma-number */\n{\n  if (JERRY_UNLIKELY (ecma_number_is_zero (num) || !ecma_number_is_finite (num)))\n  {\n    return 0;\n  }\n\n  const bool sign = ecma_number_is_negative (num);\n  const ecma_number_t abs_num = sign ? -num : num;\n\n  /* 2 ^ 32 */\n  const uint64_t uint64_2_pow_32 = (1ull << 32);\n\n  const ecma_number_t num_2_pow_32 = (float) uint64_2_pow_32;\n\n  ecma_number_t num_in_uint32_range;\n\n  if (abs_num >= num_2_pow_32)\n  {\n    num_in_uint32_range = ecma_number_calc_remainder (abs_num,\n                                                      num_2_pow_32);\n  }\n  else\n  {\n    num_in_uint32_range = abs_num;\n  }\n\n  /* Check that the floating point value can be represented with uint32_t. */\n  JERRY_ASSERT (num_in_uint32_range < uint64_2_pow_32);\n  uint32_t uint32_num = (uint32_t) num_in_uint32_range;\n\n  const uint32_t ret = sign ? -uint32_num : uint32_num;\n\n#ifndef JERRY_NDEBUG\n  if (sign\n      && uint32_num != 0)\n  {\n    JERRY_ASSERT (ret == uint64_2_pow_32 - uint32_num);\n  }\n  else\n  {\n    JERRY_ASSERT (ret == uint32_num);\n  }\n#endif /* !JERRY_NDEBUG */\n\n  return ret;\n}",
        "begin_line": 790,
        "end_line": 837,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-conversion.ecma_round_high_to_uint64#52",
        "src_path": "jerry-core/ecma/base/ecma-helpers-conversion.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-conversion",
        "signature": "jerry-core.ecma.base.ecma-helpers-conversion.ecma_round_high_to_uint64 (ecma_uint128_t *num_p)",
        "snippet": "static uint64_t\necma_round_high_to_uint64 (ecma_uint128_t *num_p)\n{\n  uint64_t masked_lo = num_p->lo & ~(1ULL << 63u);\n  uint64_t masked_hi = num_p->hi & 0x1;\n\n  if ((num_p->lo >> 63u != 0)\n      && (masked_lo > 0 || masked_hi != 0))\n  {\n    return (num_p->hi + 1);\n  }\n  return num_p->hi;\n}",
        "begin_line": 52,
        "end_line": 64,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-conversion.ecma_utf8_string_to_number#376",
        "src_path": "jerry-core/ecma/base/ecma-helpers-conversion.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-conversion",
        "signature": "jerry-core.ecma.base.ecma-helpers-conversion.ecma_utf8_string_to_number (const lit_utf8_byte_t *str_p, /**< utf-8 string */                             lit_utf8_size_t str_size, /**< string size */                             uint32_t options) /**< allowing underscore option bit */",
        "snippet": "ecma_number_t\necma_utf8_string_to_number (const lit_utf8_byte_t *str_p, /**< utf-8 string */\n                            lit_utf8_size_t str_size, /**< string size */\n                            uint32_t options) /**< allowing underscore option bit */\n{\n  /* TODO: Check license issues */\n\n  if (str_size == 0)\n  {\n    return ECMA_NUMBER_ZERO;\n  }\n\n  ecma_string_trim_helper (&str_p, &str_size);\n  const lit_utf8_byte_t *end_p = str_p + (str_size - 1);\n\n  if (str_size < 1)\n  {\n    return ECMA_NUMBER_ZERO;\n  }\n\n  if (end_p >= str_p + 2\n      && str_p[0] == LIT_CHAR_0)\n  {\n    switch (LEXER_TO_ASCII_LOWERCASE (str_p[1]))\n    {\n      case LIT_CHAR_LOWERCASE_X :\n      {\n        return ecma_utf8_string_to_number_by_radix (str_p + 2, end_p, 16 | options);\n      }\n      case LIT_CHAR_LOWERCASE_O :\n      {\n        return ecma_utf8_string_to_number_by_radix (str_p + 2, end_p, 8 | options);\n      }\n      case LIT_CHAR_LOWERCASE_B :\n      {\n        return ecma_utf8_string_to_number_by_radix (str_p + 2, end_p, 2 | options);\n      }\n      default:\n      {\n        break;\n      }\n    }\n  }\n\n  bool sign = false; /* positive */\n\n  if (*str_p == LIT_CHAR_PLUS)\n  {\n    str_p++;\n  }\n  else if (*str_p == LIT_CHAR_MINUS)\n  {\n    sign = true; /* negative */\n\n    str_p++;\n  }\n\n  if (str_p > end_p)\n  {\n    return ecma_number_make_nan ();\n  }\n\n  /* Checking if significant part of parse string is equal to \"Infinity\" */\n  const lit_utf8_byte_t *infinity_zt_str_p = lit_get_magic_string_utf8 (LIT_MAGIC_STRING_INFINITY_UL);\n\n  JERRY_ASSERT (strlen ((const char *) infinity_zt_str_p) == 8);\n\n  if ((end_p - str_p) == (8 - 1) && memcmp (infinity_zt_str_p, str_p, 8) == 0)\n  {\n    return ecma_number_make_infinity (sign);\n  }\n\n  uint64_t fraction_uint64 = 0;\n  uint32_t digits = 0;\n  int32_t e = 0;\n  bool digit_seen = false;\n\n  /* Parsing digits before dot (or before end of digits part if there is no dot in number) */\n  while (str_p <= end_p)\n  {\n    int32_t digit_value;\n\n    if (*str_p >= LIT_CHAR_0\n        && *str_p <= LIT_CHAR_9)\n    {\n      digit_seen = true;\n      digit_value = (*str_p - LIT_CHAR_0);\n    }\n#if JERRY_ESNEXT\n    else if (*str_p == LIT_CHAR_UNDERSCORE && (options & ECMA_CONVERSION_ALLOW_UNDERSCORE))\n    {\n      str_p++;\n      continue;\n    }\n#endif /* JERRY_ESNEXT */\n    else\n    {\n      break;\n    }\n\n    if (digits != 0 || digit_value != 0)\n    {\n      if (digits < ECMA_NUMBER_MAX_DIGITS)\n      {\n        fraction_uint64 = fraction_uint64 * 10 + (uint32_t) digit_value;\n        digits++;\n      }\n      else\n      {\n        e++;\n      }\n    }\n\n    str_p++;\n  }\n\n  if (str_p <= end_p\n      && *str_p == LIT_CHAR_DOT)\n  {\n    str_p++;\n\n    if (!digit_seen && str_p > end_p)\n    {\n      return ecma_number_make_nan ();\n    }\n\n    /* Parsing number's part that is placed after dot */\n    while (str_p <= end_p)\n    {\n      int32_t digit_value;\n\n      if (*str_p >= LIT_CHAR_0\n          && *str_p <= LIT_CHAR_9)\n      {\n        digit_seen = true;\n        digit_value = (*str_p - LIT_CHAR_0);\n      }\n      else if (*str_p == LIT_CHAR_UNDERSCORE && (options & ECMA_CONVERSION_ALLOW_UNDERSCORE))\n      {\n        str_p++;\n        continue;\n      }\n      else\n      {\n        break;\n      }\n\n      if (digits < ECMA_NUMBER_MAX_DIGITS)\n      {\n        if (digits != 0 || digit_value != 0)\n        {\n          fraction_uint64 = fraction_uint64 * 10 + (uint32_t) digit_value;\n          digits++;\n        }\n\n        e--;\n      }\n\n      str_p++;\n    }\n  }\n\n  /* Parsing exponent literal */\n  int32_t e_in_lit = 0;\n  bool e_in_lit_sign = false;\n\n  if (str_p <= end_p\n      && (*str_p == LIT_CHAR_LOWERCASE_E\n          || *str_p == LIT_CHAR_UPPERCASE_E))\n  {\n    str_p++;\n\n    if (!digit_seen || str_p > end_p)\n    {\n      return ecma_number_make_nan ();\n    }\n\n    if (*str_p == LIT_CHAR_PLUS)\n    {\n      str_p++;\n    }\n    else if (*str_p == LIT_CHAR_MINUS)\n    {\n      e_in_lit_sign = true;\n      str_p++;\n    }\n\n    if (str_p > end_p)\n    {\n      return ecma_number_make_nan ();\n    }\n\n    while (str_p <= end_p)\n    {\n      int32_t digit_value;\n\n      if (*str_p >= LIT_CHAR_0\n          && *str_p <= LIT_CHAR_9)\n      {\n        digit_value = (*str_p - LIT_CHAR_0);\n      }\n#if JERRY_ESNEXT\n      else if (*str_p == LIT_CHAR_UNDERSCORE && (options & ECMA_CONVERSION_ALLOW_UNDERSCORE))\n      {\n        str_p++;\n        continue;\n      }\n#endif /* JERRY_ESNEXT */\n      else\n      {\n        return ecma_number_make_nan ();\n      }\n\n      e_in_lit = e_in_lit * 10 + digit_value;\n      int32_t e_check = e + (int32_t) digits - 1  + (e_in_lit_sign ? -e_in_lit : e_in_lit);\n\n      if (e_check > NUMBER_MAX_DECIMAL_EXPONENT)\n      {\n        return ecma_number_make_infinity (sign);\n      }\n      else if (e_check < NUMBER_MIN_DECIMAL_EXPONENT)\n      {\n        return sign ? -ECMA_NUMBER_ZERO : ECMA_NUMBER_ZERO;\n      }\n\n      str_p++;\n    }\n  }\n\n  /* Adding value of exponent literal to exponent value */\n  if (e_in_lit_sign)\n  {\n    e -= e_in_lit;\n  }\n  else\n  {\n    e += e_in_lit;\n  }\n\n  bool e_sign;\n\n  if (e < 0)\n  {\n    e_sign = true;\n    e = -e;\n  }\n  else\n  {\n    e_sign = false;\n  }\n\n  if (str_p <= end_p)\n  {\n    return ecma_number_make_nan ();\n  }\n\n  JERRY_ASSERT (str_p == end_p + 1);\n\n  if (fraction_uint64 == 0)\n  {\n    return sign ? -ECMA_NUMBER_ZERO : ECMA_NUMBER_ZERO;\n  }\n\n#if JERRY_NUMBER_TYPE_FLOAT64\n  /*\n   * 128-bit mantissa storage\n   *\n   * Normalized: |4 bits zero|124-bit mantissa with highest bit set to 1|\n   */\n  ecma_uint128_t fraction_uint128 = { 0, fraction_uint64 };\n\n  /* Normalizing mantissa */\n  int shift = 4 - ECMA_UINT128_CLZ_MAX63 (fraction_uint128);\n  if (shift < 0)\n  {\n    ECMA_UINT128_LEFT_SHIFT_MAX63 (fraction_uint128, -shift);\n  }\n  else\n  {\n    ECMA_UINT128_RIGHT_SHIFT_MAX63 (fraction_uint128, shift);\n  }\n  int32_t binary_exponent = 1 + shift;\n\n  if (!e_sign)\n  {\n    /* positive or zero decimal exponent */\n    JERRY_ASSERT (e >= 0);\n\n    while (e > 0)\n    {\n      JERRY_ASSERT (ECMA_UINT128_CLZ_MAX63 (fraction_uint128) == 4);\n\n      ECMA_UINT128_MUL10 (fraction_uint128);\n\n      e--;\n\n      /* Normalizing mantissa */\n      shift = 4 - ECMA_UINT128_CLZ_MAX4 (fraction_uint128);\n      JERRY_ASSERT (shift >= 0);\n      ECMA_UINT128_RIGHT_SHIFT_MAX63 (fraction_uint128, shift);\n      binary_exponent += shift;\n    }\n  }\n  else\n  {\n    /* negative decimal exponent */\n    JERRY_ASSERT (e != 0);\n\n    while (e > 0)\n    {\n      /* Denormalizing mantissa, moving highest 1 to bit 127 */\n      shift = ECMA_UINT128_CLZ_MAX4 (fraction_uint128);\n      JERRY_ASSERT (shift <= 4);\n      ECMA_UINT128_LEFT_SHIFT_MAX63 (fraction_uint128, shift);\n      binary_exponent -= shift;\n\n      JERRY_ASSERT (!ECMA_UINT128_IS_ZERO (fraction_uint128));\n\n      ECMA_UINT128_DIV10 (fraction_uint128);\n\n      e--;\n    }\n\n    /* Normalizing mantissa */\n    shift = 4 - ECMA_UINT128_CLZ_MAX4 (fraction_uint128);\n    JERRY_ASSERT (shift >= 0);\n    ECMA_UINT128_RIGHT_SHIFT_MAX63 (fraction_uint128, shift);\n    binary_exponent += shift;\n\n    JERRY_ASSERT (ECMA_UINT128_CLZ_MAX63 (fraction_uint128) == 4);\n  }\n\n  JERRY_ASSERT (!ECMA_UINT128_IS_ZERO (fraction_uint128));\n  JERRY_ASSERT (ECMA_UINT128_CLZ_MAX63 (fraction_uint128) == 4);\n\n  /*\n   * Preparing mantissa for conversion to 52-bit representation, converting it to:\n   *\n   * |11 zero bits|1|116 mantissa bits|\n   */\n  ECMA_UINT128_RIGHT_SHIFT_MAX63 (fraction_uint128, 7u);\n  binary_exponent += 7;\n\n  JERRY_ASSERT (ECMA_UINT128_CLZ_MAX63 (fraction_uint128) == 11);\n\n  fraction_uint64 = ecma_round_high_to_uint64 (&fraction_uint128);\n\n  return ecma_number_make_from_sign_mantissa_and_exponent (sign, fraction_uint64, binary_exponent);\n#elif !JERRY_NUMBER_TYPE_FLOAT64\n  /* Less precise conversion */\n  ecma_number_t num = (ecma_number_t) (uint32_t) fraction_uint64;\n\n  ecma_number_t m = e_sign ? (ecma_number_t) 0.1 : (ecma_number_t) 10.0;\n\n  while (e)\n  {\n    if (e % 2)\n    {\n      num *= m;\n    }\n\n    m *= m;\n    e /= 2;\n  }\n\n  return num;\n#endif /* JERRY_NUMBER_TYPE_FLOAT64 */\n}",
        "begin_line": 376,
        "end_line": 743,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_get_biased_exponent_field#190",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_get_biased_exponent_field (ecma_number_t num) /**< ecma-number */",
        "snippet": "static uint32_t\necma_number_get_biased_exponent_field (ecma_number_t num) /**< ecma-number */\n{\n  uint32_t biased_exp;\n\n  ecma_number_unpack (num, NULL, &biased_exp, NULL);\n\n  return biased_exp;\n}",
        "begin_line": 190,
        "end_line": 198,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_get_fraction_field#175",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_get_fraction_field (ecma_number_t num) /**< ecma-number */",
        "snippet": "static uint64_t\necma_number_get_fraction_field (ecma_number_t num) /**< ecma-number */\n{\n  uint64_t fraction;\n\n  ecma_number_unpack (num, NULL, NULL, &fraction);\n\n  return fraction;\n}",
        "begin_line": 175,
        "end_line": 183,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_get_sign_field#205",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_get_sign_field (ecma_number_t num) /**< ecma-number */",
        "snippet": "static uint32_t\necma_number_get_sign_field (ecma_number_t num) /**< ecma-number */\n{\n  bool sign;\n\n  ecma_number_unpack (num, &sign, NULL, NULL);\n\n  return sign;\n}",
        "begin_line": 205,
        "end_line": 213,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_is_finite#340",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_is_finite (ecma_number_t num) /**< ecma-number */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\necma_number_is_finite (ecma_number_t num) /**< ecma-number */\n{\n#if defined (__GNUC__) || defined (__clang__)\n  return __builtin_isfinite (num);\n#elif defined (_WIN32)\n  return isfinite (num);\n#else\n  return !ecma_number_is_nan (num) && !ecma_number_is_infinity (num);\n#endif /* defined (__GNUC__) || defined (__clang__) */\n}",
        "begin_line": 340,
        "end_line": 350,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_is_infinity#323",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_is_infinity (ecma_number_t num) /**< ecma-number */",
        "snippet": "bool\necma_number_is_infinity (ecma_number_t num) /**< ecma-number */\n{\n  uint32_t biased_exp = ecma_number_get_biased_exponent_field (num);\n  uint64_t fraction = ecma_number_get_fraction_field (num);\n\n  /* IEEE-754 2008, 3.4, b */\n  return ((biased_exp  == (1u << ECMA_NUMBER_BIASED_EXP_WIDTH) - 1)\n          && (fraction == 0));\n}",
        "begin_line": 323,
        "end_line": 332,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_is_nan#222",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_is_nan (ecma_number_t num) /**< ecma-number */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\necma_number_is_nan (ecma_number_t num) /**< ecma-number */\n{\n  bool is_nan = (num != num);\n\n#ifndef JERRY_NDEBUG\n  uint32_t biased_exp = ecma_number_get_biased_exponent_field (num);\n  uint64_t fraction = ecma_number_get_fraction_field (num);\n\n   /* IEEE-754 2008, 3.4, a */\n  bool is_nan_ieee754 = ((biased_exp == (1u << ECMA_NUMBER_BIASED_EXP_WIDTH) - 1)\n                         && (fraction != 0));\n\n  JERRY_ASSERT (is_nan == is_nan_ieee754);\n#endif /* !JERRY_NDEBUG */\n\n  return is_nan;\n}",
        "begin_line": 222,
        "end_line": 239,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_is_negative#285",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_is_negative (ecma_number_t num) /**< ecma-number */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\necma_number_is_negative (ecma_number_t num) /**< ecma-number */\n{\n  JERRY_ASSERT (!ecma_number_is_nan (num));\n\n  /* IEEE-754 2008, 3.4 */\n  return (ecma_number_get_sign_field (num) != 0);\n}",
        "begin_line": 285,
        "end_line": 292,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_is_zero#300",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_is_zero (ecma_number_t num) /**< ecma-number */",
        "snippet": "bool\necma_number_is_zero (ecma_number_t num) /**< ecma-number */\n{\n  bool is_zero = (num == ECMA_NUMBER_ZERO);\n\n#ifndef JERRY_NDEBUG\n  /* IEEE-754 2008, 3.4, e */\n  bool is_zero_ieee754 = (ecma_number_get_fraction_field (num) == 0\n                          && ecma_number_get_biased_exponent_field (num) == 0);\n\n  JERRY_ASSERT (is_zero == is_zero_ieee754);\n#endif /* !JERRY_NDEBUG */\n\n  return is_zero;\n}",
        "begin_line": 300,
        "end_line": 314,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_make_from_sign_mantissa_and_exponent#435",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_make_from_sign_mantissa_and_exponent (bool sign, /**< true - for negative sign, false - for positive sign */                                                   uint64_t mantissa, /**< mantissa */                                                   int32_t exponent) /**< binary exponent */",
        "snippet": "ecma_number_t\necma_number_make_from_sign_mantissa_and_exponent (bool sign, /**< true - for negative sign,\n                                                                  false - for positive sign */\n                                                  uint64_t mantissa, /**< mantissa */\n                                                  int32_t exponent) /**< binary exponent */\n{\n  /* Rounding mantissa to fit into fraction field width */\n  if (mantissa & ~((1ull << (ECMA_NUMBER_FRACTION_WIDTH + 1)) - 1))\n  {\n    /* Rounded mantissa looks like the following: |00...0|1|fraction_width mantissa bits| */\n    while ((mantissa & ~((1ull << (ECMA_NUMBER_FRACTION_WIDTH + 1)) - 1)) != 0)\n    {\n      uint64_t rightmost_bit = (mantissa & 1);\n\n      exponent++;\n      mantissa >>= 1;\n\n      if ((mantissa & ~((1ull << (ECMA_NUMBER_FRACTION_WIDTH + 1)) - 1)) == 0)\n      {\n        /* Rounding to nearest value */\n        mantissa += rightmost_bit;\n\n        /* In the first case loop is finished,\n           and in the second - just one shift follows and then loop finishes */\n        JERRY_ASSERT (((mantissa & ~((1ull << (ECMA_NUMBER_FRACTION_WIDTH + 1)) - 1)) == 0)\n                      || (mantissa == (1ull << (ECMA_NUMBER_FRACTION_WIDTH + 1))));\n      }\n    }\n  }\n\n  /* Normalizing mantissa */\n  while (mantissa != 0\n         && ((mantissa & (1ull << ECMA_NUMBER_FRACTION_WIDTH)) == 0))\n  {\n    exponent--;\n    mantissa <<= 1;\n  }\n\n  /* Moving floating point */\n  exponent += ECMA_NUMBER_FRACTION_WIDTH - 1;\n\n  int32_t biased_exp_signed = exponent + ecma_number_exponent_bias;\n\n  if (biased_exp_signed < 1)\n  {\n    /* Denormalizing mantissa if biased_exponent is less than zero */\n    while (biased_exp_signed < 0)\n    {\n      biased_exp_signed++;\n      mantissa >>= 1;\n    }\n\n    /* Rounding to nearest value */\n    mantissa += 1;\n    mantissa >>= 1;\n\n    /* Encoding denormalized exponent */\n    biased_exp_signed = 0;\n  }\n  else\n  {\n    /* Clearing highest mantissa bit that should have been non-zero if mantissa is non-zero */\n    mantissa &= ~(1ull << ECMA_NUMBER_FRACTION_WIDTH);\n  }\n\n  uint32_t biased_exp = (uint32_t) biased_exp_signed;\n\n  if (biased_exp >= ((1u << ECMA_NUMBER_BIASED_EXP_WIDTH) - 1))\n  {\n    return ecma_number_make_infinity (sign);\n  }\n\n  JERRY_ASSERT (biased_exp < (1u << ECMA_NUMBER_BIASED_EXP_WIDTH) - 1);\n  JERRY_ASSERT ((mantissa & ~((1ull << ECMA_NUMBER_FRACTION_WIDTH) - 1)) == 0);\n\n  return ecma_number_pack (sign,\n                           biased_exp,\n                           mantissa);\n}",
        "begin_line": 435,
        "end_line": 513,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_pack#114",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_pack (bool sign, /**< sign */                   uint32_t biased_exp, /**< biased exponent */                   uint64_t fraction) /**< fraction */",
        "snippet": "ecma_number_t\necma_number_pack (bool sign, /**< sign */\n                  uint32_t biased_exp, /**< biased exponent */\n                  uint64_t fraction) /**< fraction */\n{\n  uint64_t packed_value = (((sign ? 1ull : 0ull) << ECMA_NUMBER_SIGN_POS) |\n                           (((uint64_t) biased_exp) << ECMA_NUMBER_FRACTION_WIDTH) |\n                           fraction);\n\n  JERRY_ASSERT ((biased_exp & ~((1u << ECMA_NUMBER_BIASED_EXP_WIDTH) - 1)) == 0);\n  JERRY_ASSERT ((fraction & ~((1ull << ECMA_NUMBER_FRACTION_WIDTH) - 1)) == 0);\n\n  ecma_number_accessor_t u;\n  u.as_uint64_t = packed_value;\n  return u.as_ecma_number_t;\n}",
        "begin_line": 114,
        "end_line": 129,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_unpack#134",
        "src_path": "jerry-core/ecma/base/ecma-helpers-number.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-number",
        "signature": "jerry-core.ecma.base.ecma-helpers-number.ecma_number_unpack (ecma_number_t num, /**< ecma-number */                     bool *sign_p, /**< [out] sign (optional) */                     uint32_t *biased_exp_p, /**< [out] biased exponent (optional) */                     uint64_t *fraction_p) /**< [out] fraction (optional) */",
        "snippet": "void\necma_number_unpack (ecma_number_t num, /**< ecma-number */\n                    bool *sign_p, /**< [out] sign (optional) */\n                    uint32_t *biased_exp_p, /**< [out] biased exponent (optional) */\n                    uint64_t *fraction_p) /**< [out] fraction (optional) */\n{\n  ecma_number_accessor_t u;\n  u.as_ecma_number_t = num;\n  uint64_t packed_value = u.as_uint64_t;\n\n  if (sign_p != NULL)\n  {\n    *sign_p = ((packed_value >> ECMA_NUMBER_SIGN_POS) != 0);\n  }\n\n  if (biased_exp_p != NULL)\n  {\n    *biased_exp_p = (uint32_t) (((packed_value) & ~(1ull << ECMA_NUMBER_SIGN_POS)) >> ECMA_NUMBER_FRACTION_WIDTH);\n  }\n\n  if (fraction_p != NULL)\n  {\n    *fraction_p = (packed_value & ((1ull << ECMA_NUMBER_FRACTION_WIDTH) - 1));\n  }\n}",
        "begin_line": 134,
        "end_line": 158,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_append_chars_to_string#728",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_append_chars_to_string (ecma_string_t *string1_p, /**< base ecma-string */                              const lit_utf8_byte_t *cesu8_string2_p, /**< characters to be appended */                              lit_utf8_size_t cesu8_string2_size, /**< byte size of cesu8_string2_p */                              lit_utf8_size_t cesu8_string2_length) /**< character length of cesu8_string2_p */",
        "snippet": "ecma_string_t *\necma_append_chars_to_string (ecma_string_t *string1_p, /**< base ecma-string */\n                             const lit_utf8_byte_t *cesu8_string2_p, /**< characters to be appended */\n                             lit_utf8_size_t cesu8_string2_size, /**< byte size of cesu8_string2_p */\n                             lit_utf8_size_t cesu8_string2_length) /**< character length of cesu8_string2_p */\n{\n  JERRY_ASSERT (string1_p != NULL && cesu8_string2_size > 0 && cesu8_string2_length > 0);\n\n  if (JERRY_UNLIKELY (ecma_string_is_empty (string1_p)))\n  {\n    return ecma_new_ecma_string_from_utf8 (cesu8_string2_p, cesu8_string2_size);\n  }\n\n  lit_utf8_size_t cesu8_string1_size;\n  lit_utf8_size_t cesu8_string1_length;\n  uint8_t flags = ECMA_STRING_FLAG_IS_ASCII;\n  lit_utf8_byte_t uint32_to_string_buffer[ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32];\n\n  const lit_utf8_byte_t *cesu8_string1_p = ecma_string_get_chars (string1_p,\n                                                                  &cesu8_string1_size,\n                                                                  &cesu8_string1_length,\n                                                                  uint32_to_string_buffer,\n                                                                  &flags);\n\n  JERRY_ASSERT (!(flags & ECMA_STRING_FLAG_MUST_BE_FREED));\n  JERRY_ASSERT (cesu8_string1_length > 0);\n  JERRY_ASSERT (cesu8_string1_length <= cesu8_string1_size);\n\n  lit_utf8_size_t new_size = cesu8_string1_size + cesu8_string2_size;\n\n  /* Poor man's carry flag check: it is impossible to allocate this large string. */\n  if (new_size < (cesu8_string1_size | cesu8_string2_size))\n  {\n    jerry_fatal (ERR_OUT_OF_MEMORY);\n  }\n\n  lit_magic_string_id_t magic_string_id;\n  magic_string_id = lit_is_utf8_string_pair_magic (cesu8_string1_p,\n                                                   cesu8_string1_size,\n                                                   cesu8_string2_p,\n                                                   cesu8_string2_size);\n\n  if (magic_string_id != LIT_MAGIC_STRING__COUNT)\n  {\n    ecma_deref_ecma_string (string1_p);\n    return ecma_get_magic_string (magic_string_id);\n  }\n\n  if ((flags & ECMA_STRING_FLAG_IS_UINT32) && new_size <= ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32)\n  {\n    memcpy (uint32_to_string_buffer + cesu8_string1_size, cesu8_string2_p, cesu8_string2_size);\n\n    uint32_t array_index;\n\n    if (ecma_string_to_array_index (uint32_to_string_buffer, new_size, &array_index))\n    {\n      ecma_deref_ecma_string (string1_p);\n      return ecma_new_ecma_string_from_uint32 (array_index);\n    }\n  }\n\n  if (lit_get_magic_string_ex_count () > 0)\n  {\n    lit_magic_string_ex_id_t magic_string_ex_id;\n    magic_string_ex_id = lit_is_ex_utf8_string_pair_magic (cesu8_string1_p,\n                                                           cesu8_string1_size,\n                                                           cesu8_string2_p,\n                                                           cesu8_string2_size);\n\n    if (magic_string_ex_id < lit_get_magic_string_ex_count ())\n    {\n      ecma_deref_ecma_string (string1_p);\n      return ecma_new_ecma_string_from_magic_string_ex_id (magic_string_ex_id);\n    }\n  }\n\n  lit_utf8_byte_t *data_p;\n  ecma_string_t *string_desc_p = ecma_new_ecma_string_from_utf8_buffer (cesu8_string1_length + cesu8_string2_length,\n                                                                        new_size,\n                                                                        &data_p);\n\n  lit_string_hash_t hash_start;\n\n  if (JERRY_UNLIKELY (flags & ECMA_STRING_FLAG_REHASH_NEEDED))\n  {\n    hash_start = lit_utf8_string_calc_hash (cesu8_string1_p, cesu8_string1_size);\n  }\n  else\n  {\n    JERRY_ASSERT (!ECMA_IS_DIRECT_STRING (string1_p));\n    hash_start = string1_p->u.hash;\n  }\n\n  string_desc_p->u.hash = lit_utf8_string_hash_combine (hash_start, cesu8_string2_p, cesu8_string2_size);\n\n  memcpy (data_p, cesu8_string1_p, cesu8_string1_size);\n  memcpy (data_p + cesu8_string1_size, cesu8_string2_p, cesu8_string2_size);\n\n  ecma_deref_ecma_string (string1_p);\n  return (ecma_string_t *) string_desc_p;\n}",
        "begin_line": 728,
        "end_line": 828,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_compare_ecma_non_direct_strings#1927",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_compare_ecma_non_direct_strings (const ecma_string_t *string1_p, /**< ecma-string */                                       const ecma_string_t *string2_p) /**< ecma-string */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\necma_compare_ecma_non_direct_strings (const ecma_string_t *string1_p, /**< ecma-string */\n                                      const ecma_string_t *string2_p) /**< ecma-string */\n{\n  JERRY_ASSERT (string1_p != NULL && string2_p != NULL);\n  JERRY_ASSERT (!ECMA_IS_DIRECT_STRING (string1_p) && !ECMA_IS_DIRECT_STRING (string2_p));\n\n  /* Fast paths first. */\n  if (string1_p == string2_p)\n  {\n    return true;\n  }\n\n  if (string1_p->u.hash != string2_p->u.hash)\n  {\n    return false;\n  }\n\n  if (ECMA_STRING_GET_CONTAINER (string1_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC)\n  {\n    return ECMA_STRING_GET_CONTAINER (string2_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC;\n  }\n\n  return ecma_compare_ecma_strings_longpath (string1_p, string2_p);\n}",
        "begin_line": 1927,
        "end_line": 1951,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_compare_ecma_string_to_magic_id#1652",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_compare_ecma_string_to_magic_id (const ecma_string_t *string_p, /**< property name */                                       lit_magic_string_id_t id) /**< magic string id */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\necma_compare_ecma_string_to_magic_id (const ecma_string_t *string_p, /**< property name */\n                                      lit_magic_string_id_t id) /**< magic string id */\n{\n  return (string_p == ecma_get_magic_string (id));\n}",
        "begin_line": 1652,
        "end_line": 1657,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_compare_ecma_strings#1889",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_compare_ecma_strings (const ecma_string_t *string1_p, /**< ecma-string */                            const ecma_string_t *string2_p) /**< ecma-string */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\necma_compare_ecma_strings (const ecma_string_t *string1_p, /**< ecma-string */\n                           const ecma_string_t *string2_p) /**< ecma-string */\n{\n  JERRY_ASSERT (string1_p != NULL && string2_p != NULL);\n\n  /* Fast paths first. */\n  if (string1_p == string2_p)\n  {\n    return true;\n  }\n\n  /* Either string is direct, return with false. */\n  if (ECMA_IS_DIRECT_STRING (((uintptr_t) string1_p) | ((uintptr_t) string2_p)))\n  {\n    return false;\n  }\n\n  /* Also compares uint32 values in descriptor. */\n  if (string1_p->u.hash != string2_p->u.hash)\n  {\n    return false;\n  }\n\n  if (ECMA_STRING_GET_CONTAINER (string1_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC)\n  {\n    return ECMA_STRING_GET_CONTAINER (string2_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC;\n  }\n\n  return ecma_compare_ecma_strings_longpath (string1_p, string2_p);\n}",
        "begin_line": 1889,
        "end_line": 1919,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_compare_ecma_strings_longpath#1859",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_compare_ecma_strings_longpath (const ecma_string_t *string1_p, /**< ecma-string */                                     const ecma_string_t *string2_p) /**< ecma-string */",
        "snippet": "static bool JERRY_ATTR_NOINLINE\necma_compare_ecma_strings_longpath (const ecma_string_t *string1_p, /**< ecma-string */\n                                    const ecma_string_t *string2_p) /**< ecma-string */\n{\n  const lit_utf8_byte_t *utf8_string1_p, *utf8_string2_p;\n  lit_utf8_size_t string1_size_and_length[2], string2_size_and_length[2];\n\n  utf8_string1_p = ecma_compare_get_string_chars (string1_p, string1_size_and_length);\n  utf8_string2_p = ecma_compare_get_string_chars (string2_p, string2_size_and_length);\n\n  if (utf8_string1_p == NULL || utf8_string2_p == NULL)\n  {\n    return false;\n  }\n\n  if (string1_size_and_length[0] != string2_size_and_length[0]\n      || string1_size_and_length[1] != string2_size_and_length[1])\n  {\n    return false;\n  }\n\n  return !memcmp ((char *) utf8_string1_p, (char *) utf8_string2_p, string1_size_and_length[0]);\n}",
        "begin_line": 1859,
        "end_line": 1881,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_compare_get_string_chars#1817",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_compare_get_string_chars (const ecma_string_t *string_p, /**< ecma-string */                                lit_utf8_size_t *size_and_length_p) /**< [out] size and length */",
        "snippet": "static const lit_utf8_byte_t *\necma_compare_get_string_chars (const ecma_string_t *string_p, /**< ecma-string */\n                               lit_utf8_size_t *size_and_length_p) /**< [out] size and length */\n{\n  switch (ECMA_STRING_GET_CONTAINER (string_p))\n  {\n    case ECMA_STRING_CONTAINER_HEAP_UTF8_STRING:\n    {\n      ecma_short_string_t *short_string_p = (ecma_short_string_t *) string_p;\n      size_and_length_p[0] = short_string_p->size;\n      size_and_length_p[1] = short_string_p->length;\n      return ECMA_SHORT_STRING_GET_BUFFER (string_p);\n    }\n    case ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING:\n    {\n      ecma_long_string_t *long_string_p = (ecma_long_string_t *) string_p;\n      size_and_length_p[0] = long_string_p->size;\n      size_and_length_p[1] = long_string_p->length;\n      return long_string_p->string_p;\n    }\n    case ECMA_STRING_CONTAINER_HEAP_ASCII_STRING:\n    {\n      size_and_length_p[0] = ECMA_ASCII_STRING_GET_SIZE (string_p);\n      size_and_length_p[1] = size_and_length_p[0];\n      return ECMA_ASCII_STRING_GET_BUFFER (string_p);\n    }\n    default:\n    {\n      return NULL;\n    }\n  }\n}",
        "begin_line": 1817,
        "end_line": 1848,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_concat_ecma_strings#839",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_concat_ecma_strings (ecma_string_t *string1_p, /**< first ecma-string */                           ecma_string_t *string2_p) /**< second ecma-string */",
        "snippet": "ecma_string_t *\necma_concat_ecma_strings (ecma_string_t *string1_p, /**< first ecma-string */\n                          ecma_string_t *string2_p) /**< second ecma-string */\n{\n  JERRY_ASSERT (string1_p != NULL && string2_p != NULL);\n\n  if (JERRY_UNLIKELY (ecma_string_is_empty (string1_p)))\n  {\n    ecma_ref_ecma_string (string2_p);\n    return string2_p;\n  }\n  else if (JERRY_UNLIKELY (ecma_string_is_empty (string2_p)))\n  {\n    return string1_p;\n  }\n\n  lit_utf8_size_t cesu8_string2_size;\n  lit_utf8_size_t cesu8_string2_length;\n  lit_utf8_byte_t uint32_to_string_buffer[ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32];\n  uint8_t flags = ECMA_STRING_FLAG_IS_ASCII;\n\n  const lit_utf8_byte_t *cesu8_string2_p = ecma_string_get_chars (string2_p,\n                                                                  &cesu8_string2_size,\n                                                                  &cesu8_string2_length,\n                                                                  uint32_to_string_buffer,\n                                                                  &flags);\n\n  JERRY_ASSERT (cesu8_string2_p != NULL);\n\n  ecma_string_t *result_p = ecma_append_chars_to_string (string1_p,\n                                                         cesu8_string2_p,\n                                                         cesu8_string2_size,\n                                                         cesu8_string2_length);\n\n  JERRY_ASSERT (!(flags & ECMA_STRING_FLAG_MUST_BE_FREED));\n\n  return result_p;\n}",
        "begin_line": 839,
        "end_line": 876,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_deref_ecma_string#956",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_deref_ecma_string (ecma_string_t *string_p) /**< ecma-string */",
        "snippet": "void\necma_deref_ecma_string (ecma_string_t *string_p) /**< ecma-string */\n{\n  JERRY_ASSERT (string_p != NULL);\n\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    return;\n  }\n\n  ecma_deref_ecma_string_non_direct (string_p);\n}",
        "begin_line": 956,
        "end_line": 967,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_deref_ecma_string_non_direct#927",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_deref_ecma_string_non_direct (ecma_string_t *string_p) /**< ecma-string */",
        "snippet": "extern inline void JERRY_ATTR_ALWAYS_INLINE\necma_deref_ecma_string_non_direct (ecma_string_t *string_p) /**< ecma-string */\n{\n  JERRY_ASSERT (!ECMA_IS_DIRECT_STRING (string_p));\n\n#ifdef JERRY_NDEBUG\n  if (ECMA_STRING_IS_STATIC (string_p))\n  {\n    return;\n  }\n#endif /* JERRY_NDEBUG */\n\n  JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);\n\n  /* Decrease reference counter. */\n  string_p->refs_and_container -= ECMA_STRING_REF_ONE;\n\n  if (string_p->refs_and_container >= ECMA_STRING_REF_ONE)\n  {\n    return;\n  }\n\n  ecma_destroy_ecma_string (string_p);\n}",
        "begin_line": 927,
        "end_line": 950,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_destroy_ecma_string#972",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_destroy_ecma_string (ecma_string_t *string_p) /**< ecma-string */",
        "snippet": "void\necma_destroy_ecma_string (ecma_string_t *string_p) /**< ecma-string */\n{\n  JERRY_ASSERT (string_p != NULL);\n  JERRY_ASSERT (!ECMA_IS_DIRECT_STRING (string_p));\n  JERRY_ASSERT ((string_p->refs_and_container < ECMA_STRING_REF_ONE) || ECMA_STRING_IS_STATIC (string_p));\n\n  switch (ECMA_STRING_GET_CONTAINER (string_p))\n  {\n    case ECMA_STRING_CONTAINER_HEAP_UTF8_STRING:\n    {\n      ecma_dealloc_string_buffer (string_p, ((ecma_short_string_t *) string_p)->size + sizeof (ecma_short_string_t));\n      return;\n    }\n    case ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING:\n    {\n      ecma_long_string_t *long_string_p = (ecma_long_string_t *) string_p;\n\n      if (long_string_p->string_p == ECMA_LONG_STRING_BUFFER_START (long_string_p))\n      {\n        ecma_dealloc_string_buffer (string_p, long_string_p->size + sizeof (ecma_long_string_t));\n        return;\n      }\n\n      ecma_external_string_t *external_string_p = (ecma_external_string_t *) string_p;\n      jerry_external_string_free_callback_t free_cb = JERRY_CONTEXT (external_string_free_callback_p);\n\n      if (free_cb != NULL)\n      {\n        free_cb ((lit_utf8_byte_t *) external_string_p->header.string_p,\n                 external_string_p->header.size,\n                 external_string_p->user_p);\n      }\n\n      ecma_dealloc_external_string (external_string_p);\n      return;\n    }\n    case ECMA_STRING_CONTAINER_HEAP_ASCII_STRING:\n    {\n      ecma_dealloc_string_buffer (string_p, ECMA_ASCII_STRING_GET_SIZE (string_p) + ECMA_ASCII_STRING_HEADER_SIZE);\n      return;\n    }\n#if JERRY_ESNEXT\n    case ECMA_STRING_CONTAINER_SYMBOL:\n    {\n      ecma_extended_string_t *symbol_p = (ecma_extended_string_t *) string_p;\n      ecma_free_value (symbol_p->u.symbol_descriptor);\n      ecma_dealloc_extended_string (symbol_p);\n      return;\n    }\n#endif /* JERRY_ESNEXT */\n    default:\n    {\n      JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC\n                    || ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);\n\n      /* only the string descriptor itself should be freed */\n      ecma_dealloc_string (string_p);\n    }\n  }\n}",
        "begin_line": 972,
        "end_line": 1032,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_find_special_string#301",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_find_special_string (const lit_utf8_byte_t *string_p, /**< utf8 string */                           lit_utf8_size_t string_size) /**< string size */",
        "snippet": "static ecma_string_t *\necma_find_special_string (const lit_utf8_byte_t *string_p, /**< utf8 string */\n                          lit_utf8_size_t string_size) /**< string size */\n{\n  JERRY_ASSERT (string_p != NULL || string_size == 0);\n  lit_magic_string_id_t magic_string_id = lit_is_utf8_string_magic (string_p, string_size);\n\n  if (magic_string_id != LIT_MAGIC_STRING__COUNT)\n  {\n    return ecma_get_magic_string (magic_string_id);\n  }\n\n  JERRY_ASSERT (string_size > 0);\n\n  if (*string_p >= LIT_CHAR_0 && *string_p <= LIT_CHAR_9)\n  {\n    uint32_t array_index;\n\n    if (ecma_string_to_array_index (string_p, string_size, &array_index))\n    {\n      return ecma_new_ecma_string_from_uint32 (array_index);\n    }\n  }\n\n  if (lit_get_magic_string_ex_count () > 0)\n  {\n    lit_magic_string_ex_id_t magic_string_ex_id = lit_is_ex_utf8_string_magic (string_p, string_size);\n\n    if (magic_string_ex_id < lit_get_magic_string_ex_count ())\n    {\n      return ecma_new_ecma_string_from_magic_string_ex_id (magic_string_ex_id);\n    }\n  }\n\n  return NULL;\n}",
        "begin_line": 301,
        "end_line": 336,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_get_magic_string#697",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_get_magic_string (lit_magic_string_id_t id) /**< identifier of magic string */",
        "snippet": "extern inline ecma_string_t * JERRY_ATTR_ALWAYS_INLINE\necma_get_magic_string (lit_magic_string_id_t id) /**< identifier of magic string */\n{\n  JERRY_ASSERT (id < LIT_MAGIC_STRING__COUNT);\n  return (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_MAGIC, (uintptr_t) id);\n}",
        "begin_line": 697,
        "end_line": 702,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_get_string_magic#2421",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_get_string_magic (const ecma_string_t *string_p) /**< ecma-string */",
        "snippet": "lit_magic_string_id_t\necma_get_string_magic (const ecma_string_t *string_p) /**< ecma-string */\n{\n  if (ECMA_IS_DIRECT_STRING_WITH_TYPE (string_p, ECMA_DIRECT_STRING_MAGIC))\n  {\n    uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);\n\n    if (id < LIT_MAGIC_STRING__COUNT)\n    {\n      return (lit_magic_string_id_t) id;\n    }\n  }\n\n  return LIT_MAGIC_STRING__COUNT;\n}",
        "begin_line": 2421,
        "end_line": 2435,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_new_ecma_string_from_uint32#616",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_new_ecma_string_from_uint32 (uint32_t uint32_number) /**< uint32 value of the string */",
        "snippet": "ecma_string_t *\necma_new_ecma_string_from_uint32 (uint32_t uint32_number) /**< uint32 value of the string */\n{\n  if (JERRY_LIKELY (uint32_number <= ECMA_DIRECT_STRING_MAX_IMM))\n  {\n    return (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_UINT, (uintptr_t) uint32_number);\n  }\n\n  return ecma_new_non_direct_string_from_uint32 (uint32_number);\n}",
        "begin_line": 616,
        "end_line": 625,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_new_ecma_string_from_utf8#370",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_new_ecma_string_from_utf8 (const lit_utf8_byte_t *string_p, /**< utf-8 string */                                 lit_utf8_size_t string_size) /**< string size */",
        "snippet": "ecma_string_t *\necma_new_ecma_string_from_utf8 (const lit_utf8_byte_t *string_p, /**< utf-8 string */\n                                lit_utf8_size_t string_size) /**< string size */\n{\n  JERRY_ASSERT (string_p != NULL || string_size == 0);\n  JERRY_ASSERT (lit_is_valid_cesu8_string (string_p, string_size));\n\n  ecma_string_t *string_desc_p = ecma_find_special_string (string_p, string_size);\n\n  if (string_desc_p != NULL)\n  {\n    return string_desc_p;\n  }\n\n  lit_utf8_byte_t *data_p;\n  string_desc_p = ecma_new_ecma_string_from_utf8_buffer (lit_utf8_string_length (string_p, string_size),\n                                                         string_size,\n                                                         &data_p);\n\n  string_desc_p->u.hash = lit_utf8_string_calc_hash (string_p, string_size);\n  memcpy (data_p, string_p, string_size);\n\n  return string_desc_p;\n}",
        "begin_line": 370,
        "end_line": 393,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_new_ecma_string_from_utf8_buffer#254",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_new_ecma_string_from_utf8_buffer (lit_utf8_size_t length, /**< length of the buffer */                                        lit_utf8_size_t size, /**< size of the buffer */                                        lit_utf8_byte_t **data_p) /**< [out] pointer to the start of the string buffer */",
        "snippet": "static inline ecma_string_t * JERRY_ATTR_ALWAYS_INLINE\necma_new_ecma_string_from_utf8_buffer (lit_utf8_size_t length, /**< length of the buffer */\n                                       lit_utf8_size_t size, /**< size of the buffer */\n                                       lit_utf8_byte_t **data_p) /**< [out] pointer to the start of the string buffer */\n{\n  if (JERRY_LIKELY (size <= UINT16_MAX))\n  {\n    if (JERRY_LIKELY (length == size) && size <= (UINT8_MAX + 1))\n    {\n      ecma_string_t *string_desc_p;\n      string_desc_p = (ecma_string_t *) ecma_alloc_string_buffer (size + ECMA_ASCII_STRING_HEADER_SIZE);\n      string_desc_p->refs_and_container = ECMA_STRING_CONTAINER_HEAP_ASCII_STRING | ECMA_STRING_REF_ONE;\n      ECMA_ASCII_STRING_SET_SIZE (string_desc_p, size);\n\n      *data_p = ECMA_ASCII_STRING_GET_BUFFER (string_desc_p);\n      return (ecma_string_t *) string_desc_p;\n    }\n\n    ecma_short_string_t *string_desc_p;\n    string_desc_p = (ecma_short_string_t *) ecma_alloc_string_buffer (size + sizeof (ecma_short_string_t));\n    string_desc_p->header.refs_and_container = ECMA_STRING_CONTAINER_HEAP_UTF8_STRING | ECMA_STRING_REF_ONE;\n    string_desc_p->size = (uint16_t) size;\n    string_desc_p->length = (uint16_t) length;\n\n    *data_p = ECMA_SHORT_STRING_GET_BUFFER (string_desc_p);\n    return (ecma_string_t *) string_desc_p;\n  }\n\n  ecma_long_string_t *long_string_p;\n  long_string_p = (ecma_long_string_t *) ecma_alloc_string_buffer (size + sizeof (ecma_long_string_t));\n  long_string_p->header.refs_and_container = ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING | ECMA_STRING_REF_ONE;\n  long_string_p->string_p = ECMA_LONG_STRING_BUFFER_START (long_string_p);\n  long_string_p->size = size;\n  long_string_p->length = length;\n\n  *data_p = ECMA_LONG_STRING_BUFFER_START (long_string_p);\n  return (ecma_string_t *) long_string_p;\n}",
        "begin_line": 254,
        "end_line": 291,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_new_symbol_from_descriptor_string#219",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_new_symbol_from_descriptor_string (ecma_value_t string_desc) /**< ecma-string */",
        "snippet": "ecma_string_t *\necma_new_symbol_from_descriptor_string (ecma_value_t string_desc) /**< ecma-string */\n{\n  JERRY_ASSERT (!ecma_is_value_symbol (string_desc));\n\n  ecma_extended_string_t *symbol_p = ecma_alloc_extended_string ();\n  symbol_p->header.refs_and_container = ECMA_STRING_REF_ONE | ECMA_STRING_CONTAINER_SYMBOL;\n  symbol_p->u.symbol_descriptor = string_desc;\n  symbol_p->header.u.hash = (lit_string_hash_t) (((uintptr_t) symbol_p) >> ECMA_SYMBOL_HASH_SHIFT);\n  JERRY_ASSERT ((symbol_p->header.u.hash & ECMA_GLOBAL_SYMBOL_FLAG) == 0);\n\n  return (ecma_string_t *) symbol_p;\n}",
        "begin_line": 219,
        "end_line": 231,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_prop_name_is_symbol#239",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_prop_name_is_symbol (ecma_string_t *string_p) /**< ecma-string */",
        "snippet": "bool\necma_prop_name_is_symbol (ecma_string_t *string_p) /**< ecma-string */\n{\n  JERRY_ASSERT (string_p != NULL);\n\n  return (!ECMA_IS_DIRECT_STRING (string_p)\n          && ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_SYMBOL);\n}",
        "begin_line": 239,
        "end_line": 246,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_ref_ecma_string#910",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_ref_ecma_string (ecma_string_t *string_p) /**< string descriptor */",
        "snippet": "void\necma_ref_ecma_string (ecma_string_t *string_p) /**< string descriptor */\n{\n  JERRY_ASSERT (string_p != NULL);\n\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    return;\n  }\n\n  ecma_ref_ecma_string_non_direct (string_p);\n}",
        "begin_line": 910,
        "end_line": 921,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_ref_ecma_string_non_direct#881",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_ref_ecma_string_non_direct (ecma_string_t *string_p) /**< string descriptor */",
        "snippet": "extern inline void JERRY_ATTR_ALWAYS_INLINE\necma_ref_ecma_string_non_direct (ecma_string_t *string_p) /**< string descriptor */\n{\n  JERRY_ASSERT (string_p != NULL);\n  JERRY_ASSERT (!ECMA_IS_DIRECT_STRING (string_p));\n\n#ifdef JERRY_NDEBUG\n  if (ECMA_STRING_IS_STATIC (string_p))\n  {\n    return;\n  }\n#endif /* JERRY_NDEBUG */\n\n  JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);\n\n  if (JERRY_LIKELY (string_p->refs_and_container < ECMA_STRING_MAX_REF))\n  {\n    /* Increase reference counter. */\n    string_p->refs_and_container += ECMA_STRING_REF_ONE;\n  }\n  else\n  {\n    jerry_fatal (ERR_REF_COUNT_LIMIT);\n  }\n}",
        "begin_line": 881,
        "end_line": 905,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_array_index#1075",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_array_index (const ecma_string_t *str_p) /**< ecma-string */",
        "snippet": "extern inline uint32_t JERRY_ATTR_ALWAYS_INLINE\necma_string_get_array_index (const ecma_string_t *str_p) /**< ecma-string */\n{\n  if (ECMA_IS_DIRECT_STRING (str_p))\n  {\n    if (ECMA_IS_DIRECT_STRING_WITH_TYPE (str_p, ECMA_DIRECT_STRING_UINT))\n    {\n      /* Value cannot be equal to the maximum value of a 32 bit unsigned number. */\n      return (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (str_p);\n    }\n\n    return ECMA_STRING_NOT_ARRAY_INDEX;\n  }\n\n  if (ECMA_STRING_GET_CONTAINER (str_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC)\n  {\n    /* When the uint32_number is equal to the maximum value of 32 bit unsigned integer number,\n     * it is also an invalid array index. The comparison to ECMA_STRING_NOT_ARRAY_INDEX will\n     * be true in this case. */\n    return str_p->u.uint32_number;\n  }\n\n  return ECMA_STRING_NOT_ARRAY_INDEX;\n}",
        "begin_line": 1075,
        "end_line": 1098,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_chars#1489",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_get_chars (const ecma_string_t *string_p, /**< ecma-string */                        lit_utf8_size_t *size_p, /**< [out] size of the ecma string */                        lit_utf8_size_t *length_p, /**< [out] optional argument. If the pointer is not NULL the pointed                                                    *    memory area is filled with the length of the ecma string */                        lit_utf8_byte_t *uint32_buff_p, /**< [out] optional argument. If the pointer is not NULL the                                                         *    pointed memory area is filled with the string converted                                                         *    uint32 string descriptor */                        uint8_t *flags_p) /**< [in, out] any combination of ecma_string_flag_t bits */",
        "snippet": "const lit_utf8_byte_t *\necma_string_get_chars (const ecma_string_t *string_p, /**< ecma-string */\n                       lit_utf8_size_t *size_p, /**< [out] size of the ecma string */\n                       lit_utf8_size_t *length_p, /**< [out] optional argument. If the pointer is not NULL the pointed\n                                                   *    memory area is filled with the length of the ecma string */\n                       lit_utf8_byte_t *uint32_buff_p, /**< [out] optional argument. If the pointer is not NULL the\n                                                        *    pointed memory area is filled with the string converted\n                                                        *    uint32 string descriptor */\n                       uint8_t *flags_p) /**< [in,out] any combination of ecma_string_flag_t bits */\n{\n  lit_utf8_size_t length;\n  lit_utf8_size_t size;\n  const lit_utf8_byte_t *result_p;\n\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    *flags_p |= ECMA_STRING_FLAG_REHASH_NEEDED;\n\n    switch (ECMA_GET_DIRECT_STRING_TYPE (string_p))\n    {\n      case ECMA_DIRECT_STRING_MAGIC:\n      {\n        uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);\n\n        if (id >= LIT_MAGIC_STRING__COUNT)\n        {\n          id -= LIT_MAGIC_STRING__COUNT;\n          size = lit_get_magic_string_ex_size (id);\n          result_p = lit_get_magic_string_ex_utf8 (id);\n          length = 0;\n\n          if (JERRY_UNLIKELY (*flags_p & ECMA_STRING_FLAG_IS_ASCII))\n          {\n            length = lit_utf8_string_length (result_p, size);\n          }\n        }\n        else\n        {\n          size = lit_get_magic_string_size (id);\n          length = size;\n\n          result_p = lit_get_magic_string_utf8 (id);\n\n          /* All magic strings must be ascii strings. */\n          JERRY_ASSERT (ECMA_STRING_IS_ASCII (result_p, size));\n        }\n        break;\n      }\n      default:\n      {\n        JERRY_ASSERT (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_UINT);\n        uint32_t uint32_number = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);\n        size = (lit_utf8_size_t) ecma_string_get_uint32_size (uint32_number);\n\n        if (uint32_buff_p != NULL)\n        {\n          result_p = uint32_buff_p;\n        }\n        else\n        {\n          result_p = (const lit_utf8_byte_t *) jmem_heap_alloc_block (size);\n          *flags_p |= ECMA_STRING_FLAG_MUST_BE_FREED;\n        }\n\n        length = ecma_uint32_to_utf8_string (uint32_number, (lit_utf8_byte_t *) result_p, size);\n\n        JERRY_ASSERT (length == size);\n        *flags_p |= ECMA_STRING_FLAG_IS_UINT32;\n        break;\n      }\n    }\n  }\n  else\n  {\n    JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);\n\n    switch (ECMA_STRING_GET_CONTAINER (string_p))\n    {\n      case ECMA_STRING_CONTAINER_HEAP_UTF8_STRING:\n      {\n        ecma_short_string_t *short_string_p = (ecma_short_string_t *) string_p;\n        size = short_string_p->size;\n        length = short_string_p->length;\n        result_p = ECMA_SHORT_STRING_GET_BUFFER (short_string_p);\n        break;\n      }\n      case ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING:\n      {\n        ecma_long_string_t *long_string_desc_p = (ecma_long_string_t *) string_p;\n        size = long_string_desc_p->size;\n        length = long_string_desc_p->length;\n        result_p = long_string_desc_p->string_p;\n        break;\n      }\n      case ECMA_STRING_CONTAINER_HEAP_ASCII_STRING:\n      {\n        size = ECMA_ASCII_STRING_GET_SIZE (string_p);\n        length = size;\n        result_p = ECMA_ASCII_STRING_GET_BUFFER (string_p);\n        break;\n      }\n      case ECMA_STRING_CONTAINER_UINT32_IN_DESC:\n      {\n        size = (lit_utf8_size_t) ecma_string_get_uint32_size (string_p->u.uint32_number);\n\n        if (uint32_buff_p != NULL)\n        {\n          result_p = uint32_buff_p;\n        }\n        else\n        {\n          result_p = (const lit_utf8_byte_t *) jmem_heap_alloc_block (size);\n          *flags_p |= ECMA_STRING_FLAG_MUST_BE_FREED;\n        }\n\n        length = ecma_uint32_to_utf8_string (string_p->u.uint32_number, (lit_utf8_byte_t *) result_p, size);\n\n        JERRY_ASSERT (length == size);\n        *flags_p |= ECMA_STRING_FLAG_IS_UINT32 | ECMA_STRING_FLAG_REHASH_NEEDED;\n        break;\n\n      }\n      default:\n      {\n        JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);\n\n        lit_magic_string_ex_id_t id = LIT_MAGIC_STRING__COUNT - string_p->u.magic_string_ex_id;\n        size = lit_get_magic_string_ex_size (id);\n        length = 0;\n\n        if (JERRY_UNLIKELY (*flags_p & ECMA_STRING_FLAG_IS_ASCII))\n        {\n          length = lit_utf8_string_length (lit_get_magic_string_ex_utf8 (id), size);\n        }\n\n        result_p = lit_get_magic_string_ex_utf8 (id);\n        *flags_p |= ECMA_STRING_FLAG_REHASH_NEEDED;\n        break;\n      }\n    }\n  }\n\n  *size_p = size;\n  if (length_p != NULL)\n  {\n    *length_p = length;\n  }\n\n  if ((*flags_p & ECMA_STRING_FLAG_IS_ASCII)\n      && length != size)\n  {\n    *flags_p = (uint8_t) (*flags_p & (uint8_t) ~ECMA_STRING_FLAG_IS_ASCII);\n  }\n\n  return result_p;\n}",
        "begin_line": 1489,
        "end_line": 1644,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_is_empty#1665",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_is_empty (const ecma_string_t *string_p) /**< ecma-string */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\necma_string_is_empty (const ecma_string_t *string_p) /**< ecma-string */\n{\n  return ecma_compare_ecma_string_to_magic_id (string_p, LIT_MAGIC_STRING__EMPTY);\n}",
        "begin_line": 1665,
        "end_line": 1669,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_is_length#1677",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_is_length (const ecma_string_t *string_p) /**< property name */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\necma_string_is_length (const ecma_string_t *string_p) /**< property name */\n{\n  return ecma_compare_ecma_string_to_magic_id (string_p, LIT_MAGIC_STRING_LENGTH);\n}",
        "begin_line": 1677,
        "end_line": 1681,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_to_array_index#65",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_to_array_index (const lit_utf8_byte_t *string_p, /**< utf-8 string */                             lit_utf8_size_t string_size, /**< string size */                             uint32_t *result_p) /**< [out] converted value */",
        "snippet": "static bool\necma_string_to_array_index (const lit_utf8_byte_t *string_p, /**< utf-8 string */\n                            lit_utf8_size_t string_size, /**< string size */\n                            uint32_t *result_p) /**< [out] converted value */\n{\n  JERRY_ASSERT (string_size > 0 && *string_p >= LIT_CHAR_0 && *string_p <= LIT_CHAR_9);\n\n  if (*string_p == LIT_CHAR_0)\n  {\n    *result_p = 0;\n    return (string_size == 1);\n  }\n\n  if (string_size > ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32)\n  {\n    return false;\n  }\n\n  uint32_t index = 0;\n  const lit_utf8_byte_t *string_end_p = string_p + string_size;\n\n  if (string_size == ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32)\n  {\n    string_end_p--;\n  }\n\n  do\n  {\n    if (*string_p > LIT_CHAR_9 || *string_p < LIT_CHAR_0)\n    {\n      return false;\n    }\n\n    index = (index * 10) + (uint32_t) (*string_p++ - LIT_CHAR_0);\n  }\n  while (string_p < string_end_p);\n\n  if (string_size < ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32)\n  {\n    *result_p = index;\n    return true;\n  }\n\n  /* Overflow must be checked as well when size is\n   * equal to ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32. */\n  if (*string_p > LIT_CHAR_9\n      || *string_p < LIT_CHAR_0\n      || index > (UINT32_MAX / 10)\n      || (index == (UINT32_MAX / 10) && *string_p > LIT_CHAR_5))\n  {\n    return false;\n  }\n\n  *result_p = (index * 10) + (uint32_t) (*string_p - LIT_CHAR_0);\n  return true;\n}",
        "begin_line": 65,
        "end_line": 120,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_to_number#1039",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_to_number (const ecma_string_t *string_p) /**< ecma-string */",
        "snippet": "ecma_number_t\necma_string_to_number (const ecma_string_t *string_p) /**< ecma-string */\n{\n  JERRY_ASSERT (string_p != NULL);\n\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    if (ECMA_IS_DIRECT_STRING_WITH_TYPE (string_p, ECMA_DIRECT_STRING_UINT))\n    {\n      return (ecma_number_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);\n    }\n  }\n  else if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC)\n  {\n    return ((ecma_number_t) string_p->u.uint32_number);\n  }\n\n  lit_utf8_size_t size;\n  const lit_utf8_byte_t *chars_p = ecma_string_get_chars_fast (string_p, &size);\n\n  JERRY_ASSERT (chars_p != NULL);\n\n  if (size == 0)\n  {\n    return ECMA_NUMBER_ZERO;\n  }\n\n  return ecma_utf8_string_to_number (chars_p, size, 0);\n}",
        "begin_line": 1039,
        "end_line": 1067,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_to_property_name#1702",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_to_property_name (ecma_string_t *prop_name_p, /**< property name */                               ecma_property_t *name_type_p) /**< [out] property name type */",
        "snippet": "extern inline jmem_cpointer_t JERRY_ATTR_ALWAYS_INLINE\necma_string_to_property_name (ecma_string_t *prop_name_p, /**< property name */\n                              ecma_property_t *name_type_p) /**< [out] property name type */\n{\n  if (ECMA_IS_DIRECT_STRING (prop_name_p))\n  {\n    *name_type_p = (ecma_property_t) ECMA_DIRECT_STRING_TYPE_TO_PROP_NAME_TYPE (prop_name_p);\n    return (jmem_cpointer_t) ECMA_GET_DIRECT_STRING_VALUE (prop_name_p);\n  }\n\n  *name_type_p = ECMA_DIRECT_STRING_PTR << ECMA_PROPERTY_NAME_TYPE_SHIFT;\n\n  ecma_ref_ecma_string (prop_name_p);\n\n  jmem_cpointer_t prop_name_cp;\n  ECMA_SET_NON_NULL_POINTER (prop_name_cp, prop_name_p);\n  return prop_name_cp;\n}",
        "begin_line": 1702,
        "end_line": 1719,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_trim_back#2541",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_trim_back (const lit_utf8_byte_t *start_p, /**< current string's start position */                        const lit_utf8_byte_t *end_p)  /**< current string's end position */",
        "snippet": "const lit_utf8_byte_t *\necma_string_trim_back (const lit_utf8_byte_t *start_p, /**< current string's start position */\n                       const lit_utf8_byte_t *end_p)  /**< current string's end position */\n{\n  ecma_char_t ch;\n\n  while (end_p > start_p)\n  {\n    lit_utf8_size_t read_size = lit_read_prev_code_unit_from_utf8 (end_p, &ch);\n\n    if (!lit_char_is_white_space (ch))\n    {\n      break;\n    }\n\n    end_p -= read_size;\n  }\n\n  return end_p;\n}",
        "begin_line": 2541,
        "end_line": 2560,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_trim_front#2512",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_trim_front (const lit_utf8_byte_t *start_p, /**< current string's start position */                         const lit_utf8_byte_t *end_p)  /**< current string's end position */",
        "snippet": "const lit_utf8_byte_t *\necma_string_trim_front (const lit_utf8_byte_t *start_p, /**< current string's start position */\n                        const lit_utf8_byte_t *end_p)  /**< current string's end position */\n{\n  ecma_char_t ch;\n\n  while (start_p < end_p)\n  {\n    lit_utf8_size_t read_size = lit_read_code_unit_from_cesu8 (start_p, &ch);\n\n    if (!lit_char_is_white_space (ch))\n    {\n      break;\n    }\n\n    start_p += read_size;\n  }\n\n  return start_p;\n}",
        "begin_line": 2512,
        "end_line": 2531,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_trim_helper#2569",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_string_trim_helper (const lit_utf8_byte_t **utf8_str_p, /**< [in, out] current string position */                          lit_utf8_size_t *utf8_str_size)  /**< [in, out] size of the given string */",
        "snippet": "extern inline void JERRY_ATTR_ALWAYS_INLINE\necma_string_trim_helper (const lit_utf8_byte_t **utf8_str_p, /**< [in, out] current string position */\n                         lit_utf8_size_t *utf8_str_size)  /**< [in, out] size of the given string */\n{\n  const lit_utf8_byte_t *end_p = *utf8_str_p + *utf8_str_size;\n  const lit_utf8_byte_t *start_p = *utf8_str_p;\n\n  const lit_utf8_byte_t *new_start_p = ecma_string_trim_front (start_p, end_p);\n  const lit_utf8_byte_t *new_end_p = ecma_string_trim_back (new_start_p, end_p);\n\n  *utf8_str_size = (lit_utf8_size_t) (new_end_p - new_start_p);\n  *utf8_str_p = new_start_p;\n}",
        "begin_line": 2569,
        "end_line": 2581,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_are_values_integer_numbers#276",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_are_values_integer_numbers (ecma_value_t first_value, /**< first ecma value */                                  ecma_value_t second_value) /**< second ecma value */",
        "snippet": "extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_are_values_integer_numbers (ecma_value_t first_value, /**< first ecma value */\n                                 ecma_value_t second_value) /**< second ecma value */\n{\n  JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_INTEGER_VALUE == 0,\n                       ecma_direct_type_integer_value_must_be_zero);\n\n  return ((first_value | second_value) & ECMA_DIRECT_TYPE_MASK) == ECMA_DIRECT_TYPE_INTEGER_VALUE;\n}",
        "begin_line": 276,
        "end_line": 284,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_check_value_type_is_spec_defined#441",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_check_value_type_is_spec_defined (ecma_value_t value) /**< ecma value */",
        "snippet": "void\necma_check_value_type_is_spec_defined (ecma_value_t value) /**< ecma value */\n{\n  JERRY_ASSERT (ecma_is_value_undefined (value)\n                || ecma_is_value_null (value)\n                || ecma_is_value_boolean (value)\n                || ecma_is_value_number (value)\n                || ecma_is_value_string (value)\n                || ecma_is_value_bigint (value)\n                || ecma_is_value_symbol (value)\n                || ecma_is_value_object (value));\n}",
        "begin_line": 441,
        "end_line": 452,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_copy_value#894",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_copy_value (ecma_value_t value)  /**< value description */",
        "snippet": "ecma_value_t\necma_copy_value (ecma_value_t value)  /**< value description */\n{\n  switch (ecma_get_value_type_field (value))\n  {\n    case ECMA_TYPE_FLOAT:\n    {\n      ecma_number_t *num_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (value);\n      ecma_number_t *new_num_p = ecma_alloc_number ();\n\n      *new_num_p = *num_p;\n\n      return ecma_make_float_value (new_num_p);\n    }\n#if JERRY_ESNEXT\n    case ECMA_TYPE_SYMBOL:\n#endif /* JERRY_ESNEXT */\n    case ECMA_TYPE_STRING:\n    {\n      ecma_string_t *string_p = (ecma_string_t *) ecma_get_pointer_from_ecma_value (value);\n      ecma_ref_ecma_string_non_direct (string_p);\n      return value;\n    }\n#if JERRY_BUILTIN_BIGINT\n    case ECMA_TYPE_BIGINT:\n    {\n      if (value != ECMA_BIGINT_ZERO)\n      {\n        ecma_ref_extended_primitive (ecma_get_extended_primitive_from_value (value));\n      }\n      return value;\n    }\n#endif /* JERRY_BUILTIN_BIGINT */\n    case ECMA_TYPE_OBJECT:\n    {\n      ecma_ref_object_inline (ecma_get_object_from_value (value));\n      return value;\n    }\n    default:\n    {\n      JERRY_ASSERT (ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT\n                    || ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT_STRING);\n\n      return value;\n    }\n  }\n}",
        "begin_line": 894,
        "end_line": 940,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_copy_value_if_not_object#964",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_copy_value_if_not_object (ecma_value_t value) /**< value description */",
        "snippet": "extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE\necma_copy_value_if_not_object (ecma_value_t value) /**< value description */\n{\n  if (!ecma_is_value_object (value))\n  {\n    return ecma_copy_value (value);\n  }\n\n  return value;\n}",
        "begin_line": 964,
        "end_line": 973,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_create_float_number#524",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_create_float_number (ecma_number_t ecma_number) /**< value of the float number */",
        "snippet": "static ecma_value_t\necma_create_float_number (ecma_number_t ecma_number) /**< value of the float number */\n{\n  ecma_number_t *ecma_num_p = ecma_alloc_number ();\n\n  *ecma_num_p = ecma_number;\n\n  return ecma_pointer_to_ecma_value (ecma_num_p) | ECMA_TYPE_FLOAT;\n}",
        "begin_line": 524,
        "end_line": 532,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_deref_if_object#990",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_deref_if_object (ecma_value_t value) /**< value description */",
        "snippet": "extern inline void JERRY_ATTR_ALWAYS_INLINE\necma_deref_if_object (ecma_value_t value) /**< value description */\n{\n  if (ecma_is_value_object (value))\n  {\n    ecma_deref_object (ecma_get_object_from_value (value));\n  }\n}",
        "begin_line": 990,
        "end_line": 997,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_fast_copy_value#953",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_fast_copy_value (ecma_value_t value)  /**< value description */",
        "snippet": "extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE\necma_fast_copy_value (ecma_value_t value)  /**< value description */\n{\n  return (ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT) ? value : ecma_copy_value (value);\n}",
        "begin_line": 953,
        "end_line": 957,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_fast_free_value#1179",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_fast_free_value (ecma_value_t value) /**< value description */",
        "snippet": "extern inline void JERRY_ATTR_ALWAYS_INLINE\necma_fast_free_value (ecma_value_t value) /**< value description */\n{\n  if (ecma_get_value_type_field (value) != ECMA_TYPE_DIRECT)\n  {\n    ecma_free_value (value);\n  }\n}",
        "begin_line": 1179,
        "end_line": 1186,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_free_value#1123",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_free_value (ecma_value_t value) /**< value description */",
        "snippet": "void\necma_free_value (ecma_value_t value) /**< value description */\n{\n  switch (ecma_get_value_type_field (value))\n  {\n    case ECMA_TYPE_FLOAT:\n    {\n      ecma_number_t *number_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (value);\n      ecma_dealloc_number (number_p);\n      break;\n    }\n#if JERRY_ESNEXT\n    case ECMA_TYPE_SYMBOL:\n#endif /* JERRY_ESNEXT */\n    case ECMA_TYPE_STRING:\n    {\n      ecma_string_t *string_p = (ecma_string_t *) ecma_get_pointer_from_ecma_value (value);\n      ecma_deref_ecma_string_non_direct (string_p);\n      break;\n    }\n    case ECMA_TYPE_OBJECT:\n    {\n      ecma_deref_object (ecma_get_object_from_value (value));\n      break;\n    }\n#if JERRY_BUILTIN_BIGINT\n    case ECMA_TYPE_BIGINT:\n    {\n      if (value != ECMA_BIGINT_ZERO)\n      {\n        ecma_deref_bigint (ecma_get_extended_primitive_from_value (value));\n      }\n\n      break;\n    }\n#endif /* JERRY_BUILTIN_BIGINT */\n    default:\n    {\n      JERRY_ASSERT (ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT\n                    || ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT_STRING);\n\n      /* no memory is allocated */\n      break;\n    }\n  }\n}",
        "begin_line": 1123,
        "end_line": 1168,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_free_value_if_not_object#1191",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_free_value_if_not_object (ecma_value_t value) /**< value description */",
        "snippet": "void\necma_free_value_if_not_object (ecma_value_t value) /**< value description */\n{\n  if (ecma_get_value_type_field (value) != ECMA_TYPE_OBJECT)\n  {\n    ecma_free_value (value);\n  }\n}",
        "begin_line": 1191,
        "end_line": 1198,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_float_from_value#758",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_float_from_value (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline ecma_number_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE\necma_get_float_from_value (ecma_value_t value) /**< ecma value */\n{\n  JERRY_ASSERT (ecma_get_value_type_field (value) == ECMA_TYPE_FLOAT);\n\n  return *(ecma_number_t *) ecma_get_pointer_from_ecma_value (value);\n}",
        "begin_line": 758,
        "end_line": 764,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_integer_from_value#745",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_integer_from_value (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline ecma_integer_value_t JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_get_integer_from_value (ecma_value_t value) /**< ecma value */\n{\n  JERRY_ASSERT (ecma_is_value_integer_number (value));\n\n  return ((ecma_integer_value_t) value) >> ECMA_DIRECT_SHIFT;\n}",
        "begin_line": 745,
        "end_line": 751,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_number_from_value#784",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_number_from_value (ecma_value_t value) /**< ecma value */",
        "snippet": "ecma_number_t JERRY_ATTR_PURE\necma_get_number_from_value (ecma_value_t value) /**< ecma value */\n{\n  if (ecma_is_value_integer_number (value))\n  {\n    return (ecma_number_t) ecma_get_integer_from_value (value);\n  }\n\n  return ecma_get_float_from_value (value);\n}",
        "begin_line": 784,
        "end_line": 793,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_object_from_value#851",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_object_from_value (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline ecma_object_t * JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE\necma_get_object_from_value (ecma_value_t value) /**< ecma value */\n{\n  JERRY_ASSERT (ecma_is_value_object (value));\n\n  return (ecma_object_t *) ecma_get_pointer_from_ecma_value (value);\n}",
        "begin_line": 851,
        "end_line": 857,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_pointer_from_ecma_value#113",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_pointer_from_ecma_value (ecma_value_t value) /**< value */",
        "snippet": "static inline void * JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE\necma_get_pointer_from_ecma_value (ecma_value_t value) /**< value */\n{\n#ifdef ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY\n  void *ptr = (void *) (uintptr_t) ((value) & ~ECMA_VALUE_TYPE_MASK);\n  JERRY_ASSERT (ptr != NULL);\n  return ptr;\n#else /* !ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY */\n  return ECMA_GET_NON_NULL_POINTER (void, value >> ECMA_VALUE_SHIFT);\n#endif /* ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY */\n}",
        "begin_line": 113,
        "end_line": 123,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_pointer_from_float_value#771",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_pointer_from_float_value (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline ecma_number_t * JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE\necma_get_pointer_from_float_value (ecma_value_t value) /**< ecma value */\n{\n  JERRY_ASSERT (ecma_get_value_type_field (value) == ECMA_TYPE_FLOAT);\n\n  return (ecma_number_t *) ecma_get_pointer_from_ecma_value (value);\n}",
        "begin_line": 771,
        "end_line": 777,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_prop_name_from_value#833",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_prop_name_from_value (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline ecma_string_t * JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE\necma_get_prop_name_from_value (ecma_value_t value) /**< ecma value */\n{\n  JERRY_ASSERT (ecma_is_value_prop_name (value));\n\n  if ((value & ECMA_VALUE_TYPE_MASK) == ECMA_TYPE_DIRECT_STRING)\n  {\n    return (ecma_string_t *) (uintptr_t) value;\n  }\n\n  return (ecma_string_t *) ecma_get_pointer_from_ecma_value (value);\n}",
        "begin_line": 833,
        "end_line": 844,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_string_from_value#800",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_string_from_value (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline ecma_string_t * JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE\necma_get_string_from_value (ecma_value_t value) /**< ecma value */\n{\n  JERRY_ASSERT (ecma_is_value_string (value));\n\n  if ((value & ECMA_VALUE_TYPE_MASK) == ECMA_TYPE_DIRECT_STRING)\n  {\n    return (ecma_string_t *) (uintptr_t) value;\n  }\n\n  return (ecma_string_t *) ecma_get_pointer_from_ecma_value (value);\n}",
        "begin_line": 800,
        "end_line": 811,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_value_type_field#78",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_get_value_type_field (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline ecma_type_t JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_get_value_type_field (ecma_value_t value) /**< ecma value */\n{\n  return value & ECMA_VALUE_TYPE_MASK;\n}",
        "begin_line": 78,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_array#460",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_array (ecma_value_t arg) /**< argument */",
        "snippet": "ecma_value_t\necma_is_value_array (ecma_value_t arg) /**< argument */\n{\n  if (!ecma_is_value_object (arg))\n  {\n    return ECMA_VALUE_FALSE;\n  }\n\n  ecma_object_t *arg_obj_p = ecma_get_object_from_value (arg);\n\n  if (ecma_get_object_base_type (arg_obj_p) == ECMA_OBJECT_BASE_TYPE_ARRAY)\n  {\n    return ECMA_VALUE_TRUE;\n  }\n\n#if JERRY_BUILTIN_PROXY\n  if (ECMA_OBJECT_IS_PROXY (arg_obj_p))\n  {\n    ecma_proxy_object_t *proxy_obj_p = (ecma_proxy_object_t *) arg_obj_p;\n\n    if (proxy_obj_p->handler == ECMA_VALUE_NULL)\n    {\n      return ecma_raise_type_error (ECMA_ERR_MSG (\"Proxy handler is null for 'isArray' operation\"));\n    }\n\n    return ecma_is_value_array (proxy_obj_p->target);\n  }\n#endif /* JERRY_BUILTIN_PROXY */\n\n  return ECMA_VALUE_FALSE;\n}",
        "begin_line": 460,
        "end_line": 490,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_array_hole#252",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_array_hole (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_array_hole (ecma_value_t value) /**< ecma value */\n{\n  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_ARRAY_HOLE);\n}",
        "begin_line": 252,
        "end_line": 256,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_bigint#362",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_bigint (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_bigint (ecma_value_t value) /**< ecma value */\n{\n  #if JERRY_BUILTIN_BIGINT\n  return (ecma_get_value_type_field (value) == ECMA_TYPE_BIGINT);\n  #else /* !JERRY_BUILTIN_BIGINT */\n  JERRY_UNUSED (value);\n  return false;\n  #endif /* JERRY_BUILTIN_BIGINT */\n}",
        "begin_line": 362,
        "end_line": 371,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_boolean#204",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_boolean (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_boolean (ecma_value_t value) /**< ecma value */\n{\n  return ecma_is_value_true (value | (1 << ECMA_DIRECT_SHIFT));\n}",
        "begin_line": 204,
        "end_line": 208,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_empty#168",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_empty (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_empty (ecma_value_t value) /**< ecma value */\n{\n  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_EMPTY);\n}",
        "begin_line": 168,
        "end_line": 172,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_equal_to_simple_value#155",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_equal_to_simple_value (ecma_value_t value, /**< ecma value */                                      ecma_value_t simple_value) /**< simple value */",
        "snippet": "static inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_equal_to_simple_value (ecma_value_t value, /**< ecma value */\n                                     ecma_value_t simple_value) /**< simple value */\n{\n  return value == simple_value;\n}",
        "begin_line": 155,
        "end_line": 160,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_error_reference#431",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_error_reference (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_error_reference (ecma_value_t value) /**< ecma value */\n{\n  return (ecma_get_value_type_field (value) == ECMA_TYPE_ERROR);\n}",
        "begin_line": 431,
        "end_line": 435,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_false#228",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_false (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_false (ecma_value_t value) /**< ecma value */\n{\n  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_FALSE);\n}",
        "begin_line": 228,
        "end_line": 232,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_float_number#292",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_float_number (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_float_number (ecma_value_t value) /**< ecma value */\n{\n  return (ecma_get_value_type_field (value) == ECMA_TYPE_FLOAT);\n}",
        "begin_line": 292,
        "end_line": 296,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_found#240",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_found (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_found (ecma_value_t value) /**< ecma value */\n{\n  return value != ECMA_VALUE_NOT_FOUND;\n}",
        "begin_line": 240,
        "end_line": 244,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_integer_number#264",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_integer_number (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_integer_number (ecma_value_t value) /**< ecma value */\n{\n  return (value & ECMA_DIRECT_TYPE_MASK) == ECMA_DIRECT_TYPE_INTEGER_VALUE;\n}",
        "begin_line": 264,
        "end_line": 268,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_magic_string#349",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_magic_string (ecma_value_t value, /**< ecma value */                             lit_magic_string_id_t id) /**< magic string id */",
        "snippet": "extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_magic_string (ecma_value_t value, /**< ecma value */\n                            lit_magic_string_id_t id) /**< magic string id */\n{\n  return value == ecma_make_magic_string_value (id);\n}",
        "begin_line": 349,
        "end_line": 354,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_null#192",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_null (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_null (ecma_value_t value) /**< ecma value */\n{\n  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_NULL);\n}",
        "begin_line": 192,
        "end_line": 196,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_number#304",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_number (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_number (ecma_value_t value) /**< ecma value */\n{\n  return (ecma_is_value_integer_number (value)\n          || ecma_is_value_float_number (value));\n}",
        "begin_line": 304,
        "end_line": 309,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_object#419",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_object (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_object (ecma_value_t value) /**< ecma value */\n{\n  return (ecma_get_value_type_field (value) == ECMA_TYPE_OBJECT);\n}",
        "begin_line": 419,
        "end_line": 423,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_prop_name#379",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_prop_name (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_prop_name (ecma_value_t value) /**< ecma value */\n{\n#if JERRY_ESNEXT\n  return ecma_is_value_string (value) || ecma_is_value_symbol (value);\n#else /* !JERRY_ESNEXT */\n  return ecma_is_value_string (value);\n#endif /* JERRY_ESNEXT */\n}",
        "begin_line": 379,
        "end_line": 387,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_string#320",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_string (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_string (ecma_value_t value) /**< ecma value */\n{\n  return ((value & (ECMA_VALUE_TYPE_MASK - 0x4)) == ECMA_TYPE_STRING);\n}",
        "begin_line": 320,
        "end_line": 324,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_symbol#332",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_symbol (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_symbol (ecma_value_t value) /**< ecma value */\n{\n#if JERRY_ESNEXT\n  return (ecma_get_value_type_field (value) == ECMA_TYPE_SYMBOL);\n#else /* JERRY_ESNEXT */\n  JERRY_UNUSED (value);\n  return false;\n#endif /* JERRY_ESNEXT */\n}",
        "begin_line": 332,
        "end_line": 341,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_true#216",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_true (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_true (ecma_value_t value) /**< ecma value */\n{\n  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_TRUE);\n}",
        "begin_line": 216,
        "end_line": 220,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_undefined#180",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_is_value_undefined (ecma_value_t value) /**< ecma value */",
        "snippet": "extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_is_value_undefined (ecma_value_t value) /**< ecma value */\n{\n  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_UNDEFINED);\n}",
        "begin_line": 180,
        "end_line": 184,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_float_value#539",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_float_value (ecma_number_t *ecma_num_p) /**< pointer to the float number */",
        "snippet": "extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE\necma_make_float_value (ecma_number_t *ecma_num_p) /**< pointer to the float number */\n{\n  return ecma_pointer_to_ecma_value (ecma_num_p) | ECMA_TYPE_FLOAT;\n}",
        "begin_line": 539,
        "end_line": 543,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_integer_value#511",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_integer_value (ecma_integer_value_t integer_value) /**< integer number to be encoded */",
        "snippet": "extern inline ecma_value_t JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE\necma_make_integer_value (ecma_integer_value_t integer_value) /**< integer number to be encoded */\n{\n  JERRY_ASSERT (ECMA_IS_INTEGER_NUMBER (integer_value));\n\n  return (((ecma_value_t) integer_value) << ECMA_DIRECT_SHIFT) | ECMA_DIRECT_TYPE_INTEGER_VALUE;\n}",
        "begin_line": 511,
        "end_line": 517,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_length_value#578",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_length_value (ecma_length_t number) /**< number to be encoded */",
        "snippet": "ecma_value_t\necma_make_length_value (ecma_length_t number) /**< number to be encoded */\n{\n  if (number <= ECMA_INTEGER_NUMBER_MAX)\n  {\n    return ecma_make_integer_value ((ecma_integer_value_t) number);\n  }\n\n  return ecma_create_float_number ((ecma_number_t) number);\n}",
        "begin_line": 578,
        "end_line": 587,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_magic_string_value#703",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_magic_string_value (lit_magic_string_id_t id) /**< magic string id */",
        "snippet": "extern inline ecma_value_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE\necma_make_magic_string_value (lit_magic_string_id_t id) /**< magic string id */\n{\n  return (ecma_value_t) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_MAGIC, (uintptr_t) id);\n}",
        "begin_line": 703,
        "end_line": 707,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_number_value#594",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_number_value (ecma_number_t ecma_number) /**< number to be encoded */",
        "snippet": "ecma_value_t\necma_make_number_value (ecma_number_t ecma_number) /**< number to be encoded */\n{\n  ecma_integer_value_t integer_value = (ecma_integer_value_t) ecma_number;\n\n  if ((ecma_number_t) integer_value == ecma_number\n      && ((integer_value == 0) ? ecma_is_number_equal_to_positive_zero (ecma_number)\n                               : ECMA_IS_INTEGER_NUMBER (integer_value)))\n  {\n    return ecma_make_integer_value (integer_value);\n  }\n\n  return ecma_create_float_number (ecma_number);\n}",
        "begin_line": 594,
        "end_line": 607,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_object_value#714",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_object_value (const ecma_object_t *object_p) /**< object to reference in value */",
        "snippet": "extern inline ecma_value_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE\necma_make_object_value (const ecma_object_t *object_p) /**< object to reference in value */\n{\n  JERRY_ASSERT (object_p != NULL);\n\n  return ecma_pointer_to_ecma_value (object_p) | ECMA_TYPE_OBJECT;\n}",
        "begin_line": 714,
        "end_line": 720,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_string_value#646",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_string_value (const ecma_string_t *ecma_string_p) /**< string to reference in value */",
        "snippet": "extern inline ecma_value_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE\necma_make_string_value (const ecma_string_t *ecma_string_p) /**< string to reference in value */\n{\n  JERRY_ASSERT (ecma_string_p != NULL);\n#if JERRY_ESNEXT\n  JERRY_ASSERT (!ecma_prop_name_is_symbol ((ecma_string_t *) ecma_string_p));\n#endif /* JERRY_ESNEXT */\n\n  if ((((uintptr_t) ecma_string_p) & ECMA_VALUE_TYPE_MASK) != 0)\n  {\n    return (ecma_value_t) (uintptr_t) ecma_string_p;\n  }\n\n  return ecma_pointer_to_ecma_value (ecma_string_p) | ECMA_TYPE_STRING;\n}",
        "begin_line": 646,
        "end_line": 660,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_uint32_value#630",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_make_uint32_value (uint32_t uint32_number) /**< uint32 number to be encoded */",
        "snippet": "ecma_value_t\necma_make_uint32_value (uint32_t uint32_number) /**< uint32 number to be encoded */\n{\n  if (uint32_number <= ECMA_INTEGER_NUMBER_MAX)\n  {\n    return ecma_make_integer_value ((ecma_integer_value_t) uint32_number);\n  }\n\n  return ecma_create_float_number ((ecma_number_t) uint32_number);\n}",
        "begin_line": 630,
        "end_line": 639,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_pointer_to_ecma_value#89",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_pointer_to_ecma_value (const void *ptr) /**< pointer */",
        "snippet": "static inline ecma_value_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE\necma_pointer_to_ecma_value (const void *ptr) /**< pointer */\n{\n#ifdef ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY\n\n  JERRY_ASSERT (ptr != NULL);\n  uintptr_t uint_ptr = (uintptr_t) ptr;\n  JERRY_ASSERT ((uint_ptr & ECMA_VALUE_TYPE_MASK) == 0);\n  return (ecma_value_t) uint_ptr;\n\n#else /* !ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY */\n\n  jmem_cpointer_t ptr_cp;\n  ECMA_SET_NON_NULL_POINTER (ptr_cp, ptr);\n  return ((ecma_value_t) ptr_cp) << ECMA_VALUE_SHIFT;\n\n#endif /* ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY */\n}",
        "begin_line": 89,
        "end_line": 106,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_update_float_number#1044",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_update_float_number (ecma_value_t float_value, /**< original float value */                           ecma_number_t new_number) /**< updated number value */",
        "snippet": "ecma_value_t\necma_update_float_number (ecma_value_t float_value, /**< original float value */\n                          ecma_number_t new_number) /**< updated number value */\n{\n  JERRY_ASSERT (ecma_is_value_float_number (float_value));\n\n  ecma_integer_value_t integer_number = (ecma_integer_value_t) new_number;\n  ecma_number_t *number_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (float_value);\n\n  if ((ecma_number_t) integer_number == new_number\n      && ((integer_number == 0) ? ecma_is_number_equal_to_positive_zero (new_number)\n                                : ECMA_IS_INTEGER_NUMBER (integer_number)))\n  {\n    ecma_dealloc_number (number_p);\n    return ecma_make_integer_value (integer_number);\n  }\n\n  *number_p = new_number;\n  return float_value;\n}",
        "begin_line": 1044,
        "end_line": 1063,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_value_assign_value#1005",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_value_assign_value (ecma_value_t *value_p, /**< [in, out] ecma value */                          ecma_value_t ecma_value) /**< value to assign */",
        "snippet": "void\necma_value_assign_value (ecma_value_t *value_p, /**< [in, out] ecma value */\n                         ecma_value_t ecma_value) /**< value to assign */\n{\n  JERRY_STATIC_ASSERT (ECMA_TYPE_DIRECT == 0,\n                       ecma_type_direct_must_be_zero_for_the_next_check);\n\n  if (*value_p == ecma_value)\n  {\n    return;\n  }\n\n  if (ecma_get_value_type_field (ecma_value || *value_p) == ECMA_TYPE_DIRECT)\n  {\n    *value_p = ecma_value;\n  }\n  else if (ecma_is_value_float_number (ecma_value)\n           && ecma_is_value_float_number (*value_p))\n  {\n    const ecma_number_t *num_src_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (ecma_value);\n    ecma_number_t *num_dst_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (*value_p);\n\n    *num_dst_p = *num_src_p;\n  }\n  else\n  {\n    ecma_free_value_if_not_object (*value_p);\n    *value_p = ecma_copy_value_if_not_object (ecma_value);\n  }\n}",
        "begin_line": 1005,
        "end_line": 1034,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_assert_object_contains_the_property#906",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_assert_object_contains_the_property (const ecma_object_t *object_p, /**< ecma-object */                                           const ecma_property_value_t *prop_value_p, /**< property value */                                           bool is_data) /**< property should be data property */",
        "snippet": "static void\necma_assert_object_contains_the_property (const ecma_object_t *object_p, /**< ecma-object */\n                                          const ecma_property_value_t *prop_value_p, /**< property value */\n                                          bool is_data) /**< property should be data property */\n{\n#ifndef JERRY_NDEBUG\n  jmem_cpointer_t prop_iter_cp = object_p->u1.property_list_cp;\n  JERRY_ASSERT (prop_iter_cp != JMEM_CP_NULL);\n\n  ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n\n  if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n  {\n    prop_iter_cp = prop_iter_p->next_property_cp;\n  }\n\n  while (prop_iter_cp != JMEM_CP_NULL)\n  {\n    prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n\n    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)\n    {\n      if ((prop_pair_p->values + i) == prop_value_p)\n      {\n        JERRY_ASSERT (is_data == ((prop_pair_p->header.types[i] & ECMA_PROPERTY_FLAG_DATA) != 0));\n        return;\n      }\n    }\n\n    prop_iter_cp = prop_iter_p->next_property_cp;\n  }\n#else /* JERRY_NDEBUG */\n  JERRY_UNUSED (object_p);\n  JERRY_UNUSED (prop_value_p);\n  JERRY_UNUSED (is_data);\n#endif /* !JERRY_NDEBUG */\n}",
        "begin_line": 906,
        "end_line": 946,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_bytecode_ref#1496",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_bytecode_ref (ecma_compiled_code_t *bytecode_p) /**< byte code pointer */",
        "snippet": "void\necma_bytecode_ref (ecma_compiled_code_t *bytecode_p) /**< byte code pointer */\n{\n  /* Abort program if maximum reference number is reached. */\n  if (bytecode_p->refs >= UINT16_MAX)\n  {\n    jerry_fatal (ERR_REF_COUNT_LIMIT);\n  }\n\n  bytecode_p->refs++;\n}",
        "begin_line": 1496,
        "end_line": 1506,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_compiled_code_resolve_arguments_start#1716",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_compiled_code_resolve_arguments_start (const ecma_compiled_code_t *bytecode_header_p) /**< compiled code */",
        "snippet": "ecma_value_t *\necma_compiled_code_resolve_arguments_start (const ecma_compiled_code_t *bytecode_header_p) /**< compiled code */\n{\n  JERRY_ASSERT (bytecode_header_p != NULL);\n\n  uint8_t *byte_p = (uint8_t *) bytecode_header_p;\n  byte_p += ((size_t) bytecode_header_p->size) << JMEM_ALIGNMENT_LOG;\n\n  if (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_MAPPED_ARGUMENTS_NEEDED))\n  {\n    return ((ecma_value_t *) byte_p);\n  }\n\n  if (JERRY_LIKELY (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)))\n  {\n    return ((ecma_value_t *) byte_p) - ((cbc_uint8_arguments_t *) bytecode_header_p)->argument_end;\n  }\n\n  return ((ecma_value_t *) byte_p) - ((cbc_uint16_arguments_t *) bytecode_header_p)->argument_end;\n}",
        "begin_line": 1716,
        "end_line": 1735,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_compiled_code_resolve_function_name#1744",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_compiled_code_resolve_function_name (const ecma_compiled_code_t *bytecode_header_p) /**< compiled code */",
        "snippet": "extern inline ecma_value_t * JERRY_ATTR_ALWAYS_INLINE\necma_compiled_code_resolve_function_name (const ecma_compiled_code_t *bytecode_header_p) /**< compiled code */\n{\n  JERRY_ASSERT (bytecode_header_p != NULL);\n  ecma_value_t *base_p = ecma_compiled_code_resolve_arguments_start (bytecode_header_p);\n\n  if (CBC_FUNCTION_GET_TYPE (bytecode_header_p->status_flags) != CBC_FUNCTION_CONSTRUCTOR)\n  {\n    base_p--;\n  }\n\n  return base_p;\n}",
        "begin_line": 1744,
        "end_line": 1756,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_create_named_accessor_property#563",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_create_named_accessor_property (ecma_object_t *object_p, /**< object */                                      ecma_string_t *name_p, /**< property name */                                      ecma_object_t *get_p, /**< getter */                                      ecma_object_t *set_p, /**< setter */                                      uint8_t prop_attributes, /**< property attributes */                                      ecma_property_t **out_prop_p) /**< [out] the property is also returned                                                                     *         if this field is non-NULL */",
        "snippet": "ecma_property_value_t *\necma_create_named_accessor_property (ecma_object_t *object_p, /**< object */\n                                     ecma_string_t *name_p, /**< property name */\n                                     ecma_object_t *get_p, /**< getter */\n                                     ecma_object_t *set_p, /**< setter */\n                                     uint8_t prop_attributes, /**< property attributes */\n                                     ecma_property_t **out_prop_p) /**< [out] the property is also returned\n                                                                    *         if this field is non-NULL */\n{\n  JERRY_ASSERT (object_p != NULL && name_p != NULL);\n  JERRY_ASSERT (ecma_is_lexical_environment (object_p)\n                || !ecma_op_object_is_fast_array (object_p));\n  JERRY_ASSERT (ecma_find_named_property (object_p, name_p) == NULL);\n  JERRY_ASSERT ((prop_attributes & ~ECMA_PROPERTY_BUILT_IN_CONFIGURABLE_ENUMERABLE) == 0);\n\n  uint8_t type_and_flags = prop_attributes;\n\n  ecma_property_value_t value;\n#if JERRY_CPOINTER_32_BIT\n  ecma_getter_setter_pointers_t *getter_setter_pair_p;\n  getter_setter_pair_p = jmem_pools_alloc (sizeof (ecma_getter_setter_pointers_t));\n  ECMA_SET_POINTER (getter_setter_pair_p->getter_cp, get_p);\n  ECMA_SET_POINTER (getter_setter_pair_p->setter_cp, set_p);\n  ECMA_SET_NON_NULL_POINTER (value.getter_setter_pair_cp, getter_setter_pair_p);\n#else /* !JERRY_CPOINTER_32_BIT */\n  ECMA_SET_POINTER (value.getter_setter_pair.getter_cp, get_p);\n  ECMA_SET_POINTER (value.getter_setter_pair.setter_cp, set_p);\n#endif /* JERRY_CPOINTER_32_BIT */\n\n  return ecma_create_property (object_p, name_p, type_and_flags, value, out_prop_p);\n}",
        "begin_line": 563,
        "end_line": 593,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_create_named_data_property#537",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_create_named_data_property (ecma_object_t *object_p, /**< object */                                  ecma_string_t *name_p, /**< property name */                                  uint8_t prop_attributes, /**< property attributes (See: ecma_property_flags_t) */                                  ecma_property_t **out_prop_p) /**< [out] the property is also returned                                                                 *         if this field is non-NULL */",
        "snippet": "ecma_property_value_t *\necma_create_named_data_property (ecma_object_t *object_p, /**< object */\n                                 ecma_string_t *name_p, /**< property name */\n                                 uint8_t prop_attributes, /**< property attributes (See: ecma_property_flags_t) */\n                                 ecma_property_t **out_prop_p) /**< [out] the property is also returned\n                                                                *         if this field is non-NULL */\n{\n  JERRY_ASSERT (object_p != NULL && name_p != NULL);\n  JERRY_ASSERT (ecma_is_lexical_environment (object_p)\n                || !ecma_op_object_is_fast_array (object_p));\n  JERRY_ASSERT (ecma_find_named_property (object_p, name_p) == NULL);\n  JERRY_ASSERT ((prop_attributes & ~ECMA_PROPERTY_BUILT_IN_CONFIGURABLE_ENUMERABLE_WRITABLE) == 0);\n\n  uint8_t type_and_flags = ECMA_PROPERTY_FLAG_DATA | prop_attributes;\n\n  ecma_property_value_t value;\n  value.value = ECMA_VALUE_UNDEFINED;\n\n  return ecma_create_property (object_p, name_p, type_and_flags, value, out_prop_p);\n}",
        "begin_line": 537,
        "end_line": 556,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_create_object#83",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_create_object (ecma_object_t *prototype_object_p, /**< pointer to prototybe of the object (or NULL) */                     size_t ext_object_size, /**< size of extended objects */                     ecma_object_type_t type) /**< object type */",
        "snippet": "ecma_object_t *\necma_create_object (ecma_object_t *prototype_object_p, /**< pointer to prototybe of the object (or NULL) */\n                    size_t ext_object_size, /**< size of extended objects */\n                    ecma_object_type_t type) /**< object type */\n{\n  ecma_object_t *new_object_p;\n\n  if (ext_object_size > 0)\n  {\n    new_object_p = (ecma_object_t *) ecma_alloc_extended_object (ext_object_size);\n  }\n  else\n  {\n    new_object_p = ecma_alloc_object ();\n  }\n\n  new_object_p->type_flags_refs = (ecma_object_descriptor_t) (type | ECMA_OBJECT_FLAG_EXTENSIBLE);\n\n  ecma_init_gc_info (new_object_p);\n\n  new_object_p->u1.property_list_cp = JMEM_CP_NULL;\n\n  ECMA_SET_POINTER (new_object_p->u2.prototype_cp, prototype_object_p);\n\n  return new_object_p;\n}",
        "begin_line": 83,
        "end_line": 108,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_create_object_lex_env#146",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_create_object_lex_env (ecma_object_t *outer_lexical_environment_p, /**< outer lexical environment */                             ecma_object_t *binding_obj_p) /**< binding object */",
        "snippet": "ecma_object_t *\necma_create_object_lex_env (ecma_object_t *outer_lexical_environment_p, /**< outer lexical environment */\n                            ecma_object_t *binding_obj_p) /**< binding object */\n{\n  JERRY_ASSERT (binding_obj_p != NULL\n                && !ecma_is_lexical_environment (binding_obj_p));\n\n  ecma_object_t *new_lexical_environment_p = ecma_alloc_object ();\n\n  new_lexical_environment_p->type_flags_refs = ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND;\n\n  ecma_init_gc_info (new_lexical_environment_p);\n\n  ECMA_SET_NON_NULL_POINTER (new_lexical_environment_p->u1.bound_object_cp,\n                             binding_obj_p);\n\n  ECMA_SET_POINTER (new_lexical_environment_p->u2.outer_reference_cp, outer_lexical_environment_p);\n\n  return new_lexical_environment_p;\n}",
        "begin_line": 146,
        "end_line": 165,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_create_property#397",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_create_property (ecma_object_t *object_p, /**< the object */                       ecma_string_t *name_p, /**< property name */                       uint8_t type_and_flags, /**< type and flags, see ecma_property_info_t */                       ecma_property_value_t value, /**< property value */                       ecma_property_t **out_prop_p) /**< [out] the property is also returned                                                      *         if this field is non-NULL */",
        "snippet": "static ecma_property_value_t *\necma_create_property (ecma_object_t *object_p, /**< the object */\n                      ecma_string_t *name_p, /**< property name */\n                      uint8_t type_and_flags, /**< type and flags, see ecma_property_info_t */\n                      ecma_property_value_t value, /**< property value */\n                      ecma_property_t **out_prop_p) /**< [out] the property is also returned\n                                                     *         if this field is non-NULL */\n{\n  JERRY_ASSERT (ECMA_PROPERTY_PAIR_ITEM_COUNT == 2);\n  JERRY_ASSERT (name_p != NULL);\n  JERRY_ASSERT (object_p != NULL);\n\n  jmem_cpointer_t *property_list_head_p = &object_p->u1.property_list_cp;\n\n  if (*property_list_head_p != ECMA_NULL_POINTER)\n  {\n    /* If the first entry is free (deleted), it is reused. */\n    ecma_property_header_t *first_property_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,\n                                                                          *property_list_head_p);\n\n#if JERRY_PROPERTY_HASHMAP\n    bool has_hashmap = false;\n\n    if (first_property_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n    {\n      property_list_head_p = &first_property_p->next_property_cp;\n      first_property_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,\n                                                    *property_list_head_p);\n      has_hashmap = true;\n    }\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (first_property_p));\n\n    if (first_property_p->types[0] == ECMA_PROPERTY_TYPE_DELETED)\n    {\n      ecma_property_pair_t *first_property_pair_p = (ecma_property_pair_t *) first_property_p;\n\n      ecma_property_t name_type;\n      first_property_pair_p->names_cp[0] = ecma_string_to_property_name (name_p,\n                                                                         &name_type);\n      first_property_p->types[0] = (ecma_property_t) (type_and_flags | name_type);\n\n      ecma_property_t *property_p = first_property_p->types + 0;\n\n      JERRY_ASSERT (ECMA_PROPERTY_VALUE_PTR (property_p) == first_property_pair_p->values + 0);\n\n      if (out_prop_p != NULL)\n      {\n        *out_prop_p = property_p;\n      }\n\n      first_property_pair_p->values[0] = value;\n\n#if JERRY_PROPERTY_HASHMAP\n      /* The property must be fully initialized before ecma_property_hashmap_insert\n       * is called, because the insert operation may reallocate the hashmap, and\n       * that triggers garbage collection which scans all properties of all objects.\n       * A not fully initialized but queued property may cause a crash. */\n\n      if (has_hashmap)\n      {\n        ecma_property_hashmap_insert (object_p,\n                                      name_p,\n                                      first_property_pair_p,\n                                      0);\n      }\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n      return first_property_pair_p->values + 0;\n    }\n  }\n\n  /* Otherwise we create a new property pair and use its second value. */\n  ecma_property_pair_t *first_property_pair_p = ecma_alloc_property_pair ();\n\n  /* Need to query property_list_head_p again and recheck the existennce\n   * of property hasmap, because ecma_alloc_property_pair may delete them. */\n  property_list_head_p = &object_p->u1.property_list_cp;\n#if JERRY_PROPERTY_HASHMAP\n  bool has_hashmap = false;\n\n  if (*property_list_head_p != ECMA_NULL_POINTER)\n  {\n    ecma_property_header_t *first_property_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,\n                                                                          *property_list_head_p);\n\n    if (first_property_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n    {\n      property_list_head_p = &first_property_p->next_property_cp;\n      has_hashmap = true;\n    }\n  }\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n  /* Just copy the previous value (no need to decompress, compress). */\n  first_property_pair_p->header.next_property_cp = *property_list_head_p;\n  first_property_pair_p->header.types[0] = ECMA_PROPERTY_TYPE_DELETED;\n  first_property_pair_p->names_cp[0] = LIT_INTERNAL_MAGIC_STRING_DELETED;\n\n  ecma_property_t name_type;\n  first_property_pair_p->names_cp[1] = ecma_string_to_property_name (name_p,\n                                                                     &name_type);\n\n  first_property_pair_p->header.types[1] = (ecma_property_t) (type_and_flags | name_type);\n\n  ECMA_SET_NON_NULL_POINTER (*property_list_head_p, &first_property_pair_p->header);\n\n  ecma_property_t *property_p = first_property_pair_p->header.types + 1;\n\n  JERRY_ASSERT (ECMA_PROPERTY_VALUE_PTR (property_p) == first_property_pair_p->values + 1);\n\n  if (out_prop_p != NULL)\n  {\n    *out_prop_p = property_p;\n  }\n\n  first_property_pair_p->values[1] = value;\n\n#if JERRY_PROPERTY_HASHMAP\n  /* See the comment before the other ecma_property_hashmap_insert above. */\n\n  if (has_hashmap)\n  {\n    ecma_property_hashmap_insert (object_p,\n                                  name_p,\n                                  first_property_pair_p,\n                                  1);\n  }\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n  return first_property_pair_p->values + 1;\n}",
        "begin_line": 397,
        "end_line": 529,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_find_named_property#627",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_find_named_property (ecma_object_t *obj_p, /**< object to find property in */                           ecma_string_t *name_p) /**< property's name */",
        "snippet": "ecma_property_t *\necma_find_named_property (ecma_object_t *obj_p, /**< object to find property in */\n                          ecma_string_t *name_p) /**< property's name */\n{\n  JERRY_ASSERT (obj_p != NULL);\n  JERRY_ASSERT (name_p != NULL);\n  JERRY_ASSERT (ecma_is_lexical_environment (obj_p)\n                || !ecma_op_object_is_fast_array (obj_p));\n\n#if JERRY_LCACHE\n  ecma_property_t *property_p = ecma_lcache_lookup (obj_p, name_p);\n  if (property_p != NULL)\n  {\n    return property_p;\n  }\n#else /* !JERRY_LCACHE */\n  ecma_property_t *property_p = NULL;\n#endif /* JERRY_LCACHE */\n\n  jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp;\n\n#if JERRY_PROPERTY_HASHMAP\n  if (prop_iter_cp != JMEM_CP_NULL)\n  {\n    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,\n                                                                     prop_iter_cp);\n    if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n    {\n      jmem_cpointer_t property_real_name_cp;\n      property_p = ecma_property_hashmap_find ((ecma_property_hashmap_t *) prop_iter_p,\n                                               name_p,\n                                               &property_real_name_cp);\n#if JERRY_LCACHE\n      if (property_p != NULL\n          && !ecma_is_property_lcached (property_p))\n      {\n        ecma_lcache_insert (obj_p, property_real_name_cp, property_p);\n      }\n#endif /* JERRY_LCACHE */\n      return property_p;\n    }\n  }\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n#if JERRY_PROPERTY_HASHMAP\n  uint32_t steps = 0;\n#endif /* JERRY_PROPERTY_HASHMAP */\n  jmem_cpointer_t property_name_cp = ECMA_NULL_POINTER;\n\n  if (ECMA_IS_DIRECT_STRING (name_p))\n  {\n    ecma_property_t prop_name_type = (ecma_property_t) ECMA_GET_DIRECT_STRING_TYPE (name_p);\n    property_name_cp = (jmem_cpointer_t) ECMA_GET_DIRECT_STRING_VALUE (name_p);\n\n    JERRY_ASSERT (prop_name_type > 0);\n\n    while (prop_iter_cp != JMEM_CP_NULL)\n    {\n      ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,\n                                                                       prop_iter_cp);\n\n      JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n      ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n      if (prop_pair_p->names_cp[0] == property_name_cp\n          && ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[0]) == prop_name_type)\n      {\n        JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (prop_iter_p->types[0]));\n\n        property_p = prop_iter_p->types + 0;\n        break;\n      }\n\n      if (prop_pair_p->names_cp[1] == property_name_cp\n          && ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[1]) == prop_name_type)\n      {\n        JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (prop_iter_p->types[1]));\n\n        property_p = prop_iter_p->types + 1;\n        break;\n      }\n\n#if JERRY_PROPERTY_HASHMAP\n      steps++;\n#endif /* JERRY_PROPERTY_HASHMAP */\n      prop_iter_cp = prop_iter_p->next_property_cp;\n    }\n  }\n  else\n  {\n    while (prop_iter_cp != JMEM_CP_NULL)\n    {\n      ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,\n                                                                       prop_iter_cp);\n\n      JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n      ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n      if (ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[0]) == ECMA_DIRECT_STRING_PTR)\n      {\n        property_name_cp = prop_pair_p->names_cp[0];\n        ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, property_name_cp);\n\n        if (ecma_compare_ecma_non_direct_strings (name_p, prop_name_p))\n        {\n          property_p = prop_iter_p->types + 0;\n          break;\n        }\n      }\n\n      if (ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[1]) == ECMA_DIRECT_STRING_PTR)\n      {\n        property_name_cp = prop_pair_p->names_cp[1];\n        ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, property_name_cp);\n\n        if (ecma_compare_ecma_non_direct_strings (name_p, prop_name_p))\n        {\n          property_p = prop_iter_p->types + 1;\n          break;\n        }\n      }\n\n#if JERRY_PROPERTY_HASHMAP\n      steps++;\n#endif /* JERRY_PROPERTY_HASHMAP */\n      prop_iter_cp = prop_iter_p->next_property_cp;\n    }\n  }\n\n#if JERRY_PROPERTY_HASHMAP\n  if (steps >= (ECMA_PROPERTY_HASMAP_MINIMUM_SIZE / 2))\n  {\n    ecma_property_hashmap_create (obj_p);\n  }\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n#if JERRY_LCACHE\n  if (property_p != NULL\n      && !ecma_is_property_lcached (property_p))\n  {\n    ecma_lcache_insert (obj_p, property_name_cp, property_p);\n  }\n#endif /* JERRY_LCACHE */\n\n  return property_p;\n}",
        "begin_line": 627,
        "end_line": 774,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_get_lex_env_binding_object#301",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_get_lex_env_binding_object (const ecma_object_t *object_p) /**< object-bound lexical environment */",
        "snippet": "extern inline ecma_object_t * JERRY_ATTR_PURE\necma_get_lex_env_binding_object (const ecma_object_t *object_p) /**< object-bound lexical environment */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (ecma_is_lexical_environment (object_p));\n#if JERRY_ESNEXT\n  JERRY_ASSERT (ecma_get_lex_env_type (object_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND\n                || (ecma_get_lex_env_type (object_p) == ECMA_LEXICAL_ENVIRONMENT_CLASS\n                    && (object_p->type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA) == 0));\n#else /* !JERRY_ESNEXT */\n  JERRY_ASSERT (ecma_get_lex_env_type (object_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n#endif /* JERRY_ESNEXT */\n\n  return ECMA_GET_NON_NULL_POINTER (ecma_object_t, object_p->u1.bound_object_cp);\n}",
        "begin_line": 301,
        "end_line": 315,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_get_lex_env_type#287",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_get_lex_env_type (const ecma_object_t *object_p) /**< lexical environment */",
        "snippet": "extern inline ecma_lexical_environment_type_t JERRY_ATTR_PURE\necma_get_lex_env_type (const ecma_object_t *object_p) /**< lexical environment */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (ecma_is_lexical_environment (object_p));\n\n  return (ecma_lexical_environment_type_t) (object_p->type_flags_refs & ECMA_OBJECT_TYPE_MASK);\n}",
        "begin_line": 287,
        "end_line": 294,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_get_named_accessor_property#969",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_get_named_accessor_property (const ecma_property_value_t *prop_value_p) /**< property value reference */",
        "snippet": "ecma_getter_setter_pointers_t *\necma_get_named_accessor_property (const ecma_property_value_t *prop_value_p) /**< property value reference */\n{\n#if JERRY_CPOINTER_32_BIT\n  return ECMA_GET_NON_NULL_POINTER (ecma_getter_setter_pointers_t, prop_value_p->getter_setter_pair_cp);\n#else /* !JERRY_CPOINTER_32_BIT */\n  return (ecma_getter_setter_pointers_t *) &prop_value_p->getter_setter_pair;\n#endif /* JERRY_CPOINTER_32_BIT */\n}",
        "begin_line": 969,
        "end_line": 977,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_get_object_base_type#250",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_get_object_base_type (const ecma_object_t *object_p) /**< object */",
        "snippet": "extern inline ecma_object_base_type_t JERRY_ATTR_PURE\necma_get_object_base_type (const ecma_object_t *object_p) /**< object */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (!ecma_is_lexical_environment (object_p));\n\n  return (ecma_object_base_type_t) (object_p->type_flags_refs & (ECMA_OBJECT_TYPE_MASK - 0x1));\n}",
        "begin_line": 250,
        "end_line": 257,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_get_object_type#236",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_get_object_type (const ecma_object_t *object_p) /**< object */",
        "snippet": "extern inline ecma_object_type_t JERRY_ATTR_PURE\necma_get_object_type (const ecma_object_t *object_p) /**< object */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (!ecma_is_lexical_environment (object_p));\n\n  return (ecma_object_type_t) (object_p->type_flags_refs & ECMA_OBJECT_TYPE_MASK);\n}",
        "begin_line": 236,
        "end_line": 243,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_is_lexical_environment#211",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_is_lexical_environment (const ecma_object_t *object_p) /**< object or lexical environment */",
        "snippet": "extern inline bool JERRY_ATTR_PURE\necma_is_lexical_environment (const ecma_object_t *object_p) /**< object or lexical environment */\n{\n  JERRY_ASSERT (object_p != NULL);\n\n  return (object_p->type_flags_refs & ECMA_OBJECT_TYPE_MASK) >= ECMA_LEXICAL_ENVIRONMENT_TYPE_START;\n}",
        "begin_line": 211,
        "end_line": 217,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_is_property_lcached#1191",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_is_property_lcached (ecma_property_t *property_p) /**< property */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\necma_is_property_lcached (ecma_property_t *property_p) /**< property */\n{\n  JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (*property_p));\n\n  return (*property_p & ECMA_PROPERTY_FLAG_LCACHED) != 0;\n}",
        "begin_line": 1191,
        "end_line": 1197,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_is_property_writable#1091",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_is_property_writable (ecma_property_t property) /**< property */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\necma_is_property_writable (ecma_property_t property) /**< property */\n{\n  JERRY_ASSERT (property & ECMA_PROPERTY_FLAG_DATA);\n\n  return (property & ECMA_PROPERTY_FLAG_WRITABLE) != 0;\n}",
        "begin_line": 1091,
        "end_line": 1097,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_make_empty_property_descriptor#1226",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_make_empty_property_descriptor (void)",
        "snippet": "ecma_property_descriptor_t\necma_make_empty_property_descriptor (void)\n{\n  ecma_property_descriptor_t prop_desc;\n\n  prop_desc.flags = 0;\n  prop_desc.value = ECMA_VALUE_UNDEFINED;\n  prop_desc.get_p = NULL;\n  prop_desc.set_p = NULL;\n\n  return prop_desc;\n}",
        "begin_line": 1226,
        "end_line": 1237,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_named_data_property_assign_value#954",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_named_data_property_assign_value (ecma_object_t *obj_p, /**< object */                                        ecma_property_value_t *prop_value_p, /**< property value reference */                                        ecma_value_t value) /**< value to assign */",
        "snippet": "extern inline void JERRY_ATTR_ALWAYS_INLINE\necma_named_data_property_assign_value (ecma_object_t *obj_p, /**< object */\n                                       ecma_property_value_t *prop_value_p, /**< property value reference */\n                                       ecma_value_t value) /**< value to assign */\n{\n  ecma_assert_object_contains_the_property (obj_p, prop_value_p, true);\n\n  ecma_value_assign_value (&prop_value_p->value, value);\n}",
        "begin_line": 954,
        "end_line": 962,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_object_class_is#265",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_object_class_is (ecma_object_t *object_p, /**< object */                       ecma_object_class_type_t class_id) /**< class id */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\necma_object_class_is (ecma_object_t *object_p, /**< object */\n                      ecma_object_class_type_t class_id) /**< class id */\n{\n  if (ecma_get_object_base_type (object_p) == ECMA_OBJECT_BASE_TYPE_CLASS)\n  {\n    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n    if (ext_object_p->u.cls.type == (uint8_t) class_id)\n    {\n      return true;\n    }\n  }\n\n  return false;\n}",
        "begin_line": 265,
        "end_line": 280,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_op_ordinary_object_set_extensible#222",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_op_ordinary_object_set_extensible (ecma_object_t *object_p) /**< object */",
        "snippet": "extern inline void\necma_op_ordinary_object_set_extensible (ecma_object_t *object_p) /**< object */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (!ecma_is_lexical_environment (object_p));\n\n  object_p->type_flags_refs |= ECMA_OBJECT_FLAG_EXTENSIBLE;\n}",
        "begin_line": 222,
        "end_line": 229,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_set_property_lcached#1202",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_set_property_lcached (ecma_property_t *property_p, /**< property */                            bool is_lcached) /**< new value for lcached flag */",
        "snippet": "extern inline void JERRY_ATTR_ALWAYS_INLINE\necma_set_property_lcached (ecma_property_t *property_p, /**< property */\n                           bool is_lcached) /**< new value for lcached flag */\n{\n  JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (*property_p));\n\n  if (is_lcached)\n  {\n    *property_p = (uint8_t) (*property_p | ECMA_PROPERTY_FLAG_LCACHED);\n  }\n  else\n  {\n    *property_p = (uint8_t) (*property_p & ~ECMA_PROPERTY_FLAG_LCACHED);\n  }\n}",
        "begin_line": 1202,
        "end_line": 1216,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-init-finalize.ecma_init#40",
        "src_path": "jerry-core/ecma/base/ecma-init-finalize.c",
        "class_name": "jerry-core.ecma.base.ecma-init-finalize",
        "signature": "jerry-core.ecma.base.ecma-init-finalize.ecma_init (void)",
        "snippet": "void\necma_init (void)\n{\n#if (JERRY_GC_MARK_LIMIT != 0)\n  JERRY_CONTEXT (ecma_gc_mark_recursion_limit) = JERRY_GC_MARK_LIMIT;\n#endif /* (JERRY_GC_MARK_LIMIT != 0) */\n\n  ecma_init_global_environment ();\n\n#if JERRY_PROPERTY_HASHMAP\n  JERRY_CONTEXT (ecma_prop_hashmap_alloc_state) = ECMA_PROP_HASHMAP_ALLOC_ON;\n  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_HIGH_PRESSURE_GC;\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n#if (JERRY_STACK_LIMIT != 0)\n  volatile int sp;\n  JERRY_CONTEXT (stack_base) = (uintptr_t) &sp;\n#endif /* (JERRY_STACK_LIMIT != 0) */\n\n#if JERRY_ESNEXT\n  ecma_job_queue_init ();\n#endif /* JERRY_ESNEXT */\n\n#if JERRY_ESNEXT\n  JERRY_CONTEXT (current_new_target_p) = NULL;\n#endif /* JERRY_ESNEXT */\n}",
        "begin_line": 40,
        "end_line": 66,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-lcache.ecma_lcache_insert#87",
        "src_path": "jerry-core/ecma/base/ecma-lcache.c",
        "class_name": "jerry-core.ecma.base.ecma-lcache",
        "signature": "jerry-core.ecma.base.ecma-lcache.ecma_lcache_insert (const ecma_object_t *object_p, /**< object */                     const jmem_cpointer_t name_cp, /**< property name */                     ecma_property_t *prop_p) /**< property */",
        "snippet": "void\necma_lcache_insert (const ecma_object_t *object_p, /**< object */\n                    const jmem_cpointer_t name_cp, /**< property name */\n                    ecma_property_t *prop_p) /**< property */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (prop_p != NULL && !ecma_is_property_lcached (prop_p));\n  JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (*prop_p));\n\n  jmem_cpointer_t object_cp;\n\n  ECMA_SET_NON_NULL_POINTER (object_cp, object_p);\n\n  size_t row_index = ecma_lcache_row_index (object_cp, name_cp);\n  ecma_lcache_hash_entry_t *entry_p = JERRY_CONTEXT (lcache) [row_index];\n  ecma_lcache_hash_entry_t *entry_end_p = entry_p + ECMA_LCACHE_HASH_ROW_LENGTH;\n\n  do\n  {\n    if (entry_p->id == 0)\n    {\n      goto insert;\n    }\n\n    entry_p++;\n  }\n  while (entry_p < entry_end_p);\n\n  /* Invalidate the last entry. */\n  ecma_lcache_invalidate_entry (--entry_p);\n\n  /* Shift other entries towards the end. */\n  for (uint32_t i = 0; i < ECMA_LCACHE_HASH_ROW_LENGTH - 1; i++)\n  {\n    entry_p->id = entry_p[-1].id;\n    entry_p->prop_p = entry_p[-1].prop_p;\n    entry_p--;\n  }\n\ninsert:\n  entry_p->prop_p = prop_p;\n  entry_p->id = ECMA_LCACHE_CREATE_ID (object_cp, name_cp);\n\n  ecma_set_property_lcached (entry_p->prop_p, true);\n}",
        "begin_line": 87,
        "end_line": 131,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-lcache.ecma_lcache_lookup#139",
        "src_path": "jerry-core/ecma/base/ecma-lcache.c",
        "class_name": "jerry-core.ecma.base.ecma-lcache",
        "signature": "jerry-core.ecma.base.ecma-lcache.ecma_lcache_lookup (const ecma_object_t *object_p, /**< object */                     const ecma_string_t *prop_name_p) /**< property's name */",
        "snippet": "extern inline ecma_property_t * JERRY_ATTR_ALWAYS_INLINE\necma_lcache_lookup (const ecma_object_t *object_p, /**< object */\n                    const ecma_string_t *prop_name_p) /**< property's name */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (prop_name_p != NULL);\n\n  jmem_cpointer_t object_cp;\n  ECMA_SET_NON_NULL_POINTER (object_cp, object_p);\n\n  ecma_property_t prop_name_type = ECMA_DIRECT_STRING_PTR;\n  jmem_cpointer_t prop_name_cp;\n\n  if (JERRY_UNLIKELY (ECMA_IS_DIRECT_STRING (prop_name_p)))\n  {\n    prop_name_type = (ecma_property_t) ECMA_GET_DIRECT_STRING_TYPE (prop_name_p);\n    prop_name_cp = (jmem_cpointer_t) ECMA_GET_DIRECT_STRING_VALUE (prop_name_p);\n  }\n  else\n  {\n    ECMA_SET_NON_NULL_POINTER (prop_name_cp, prop_name_p);\n  }\n\n  size_t row_index = ecma_lcache_row_index (object_cp, prop_name_cp);\n\n  ecma_lcache_hash_entry_t *entry_p = JERRY_CONTEXT (lcache) [row_index];\n  ecma_lcache_hash_entry_t *entry_end_p = entry_p + ECMA_LCACHE_HASH_ROW_LENGTH;\n  ecma_lcache_hash_entry_id_t id = ECMA_LCACHE_CREATE_ID (object_cp, prop_name_cp);\n\n  do\n  {\n    if (entry_p->id == id && JERRY_LIKELY (ECMA_PROPERTY_GET_NAME_TYPE (*entry_p->prop_p) == prop_name_type))\n    {\n      JERRY_ASSERT (entry_p->prop_p != NULL && ecma_is_property_lcached (entry_p->prop_p));\n      return entry_p->prop_p;\n    }\n    entry_p++;\n  }\n  while (entry_p < entry_end_p);\n\n  return NULL;\n}",
        "begin_line": 139,
        "end_line": 180,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-lcache.ecma_lcache_row_index#75",
        "src_path": "jerry-core/ecma/base/ecma-lcache.c",
        "class_name": "jerry-core.ecma.base.ecma-lcache",
        "signature": "jerry-core.ecma.base.ecma-lcache.ecma_lcache_row_index (jmem_cpointer_t object_cp, /**< compressed pointer to object */                        jmem_cpointer_t name_cp) /**< compressed pointer to property name */",
        "snippet": "static inline size_t JERRY_ATTR_ALWAYS_INLINE\necma_lcache_row_index (jmem_cpointer_t object_cp, /**< compressed pointer to object */\n                       jmem_cpointer_t name_cp) /**< compressed pointer to property name */\n{\n  /* Randomize the property name with the object pointer using a xor operation,\n   * so properties of different objects with the same name can be cached effectively. */\n  return (size_t) (((name_cp ^ object_cp) & ECMA_LCACHE_HASH_MASK) >> ECMA_LCACHE_HASH_BITSHIFT_INDEX);\n}",
        "begin_line": 75,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-literal-storage.ecma_find_or_create_literal_number#242",
        "src_path": "jerry-core/ecma/base/ecma-literal-storage.c",
        "class_name": "jerry-core.ecma.base.ecma-literal-storage",
        "signature": "jerry-core.ecma.base.ecma-literal-storage.ecma_find_or_create_literal_number (ecma_number_t number_arg) /**< number to be searched */",
        "snippet": "ecma_value_t\necma_find_or_create_literal_number (ecma_number_t number_arg) /**< number to be searched */\n{\n  ecma_value_t num = ecma_make_number_value (number_arg);\n\n  if (ecma_is_value_integer_number (num))\n  {\n    return num;\n  }\n\n  JERRY_ASSERT (ecma_is_value_float_number (num));\n\n  jmem_cpointer_t number_list_cp = JERRY_CONTEXT (number_list_first_cp);\n  jmem_cpointer_t *empty_cpointer_p = NULL;\n\n  while (number_list_cp != JMEM_CP_NULL)\n  {\n    ecma_lit_storage_item_t *number_list_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_lit_storage_item_t,\n                                                                           number_list_cp);\n\n    for (int i = 0; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)\n    {\n      if (number_list_p->values[i] == JMEM_CP_NULL)\n      {\n        if (empty_cpointer_p == NULL)\n        {\n          empty_cpointer_p = number_list_p->values + i;\n        }\n      }\n      else\n      {\n        ecma_number_t *number_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_number_t,\n                                                                number_list_p->values[i]);\n\n        if (*number_p == number_arg)\n        {\n          ecma_free_value (num);\n          return ecma_make_float_value (number_p);\n        }\n      }\n    }\n\n    number_list_cp = number_list_p->next_cp;\n  }\n\n  jmem_cpointer_t result;\n  JMEM_CP_SET_NON_NULL_POINTER (result, ecma_get_pointer_from_float_value (num));\n\n  if (empty_cpointer_p != NULL)\n  {\n    *empty_cpointer_p = result;\n    return num;\n  }\n\n  ecma_lit_storage_item_t *new_item_p;\n  new_item_p = (ecma_lit_storage_item_t *) jmem_pools_alloc (sizeof (ecma_lit_storage_item_t));\n\n  new_item_p->values[0] = result;\n  for (int i = 1; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)\n  {\n    new_item_p->values[i] = JMEM_CP_NULL;\n  }\n\n  new_item_p->next_cp = JERRY_CONTEXT (number_list_first_cp);\n  JMEM_CP_SET_NON_NULL_POINTER (JERRY_CONTEXT (number_list_first_cp), new_item_p);\n\n  return num;\n}",
        "begin_line": 242,
        "end_line": 309,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-literal-storage.ecma_find_or_create_literal_string#166",
        "src_path": "jerry-core/ecma/base/ecma-literal-storage.c",
        "class_name": "jerry-core.ecma.base.ecma-literal-storage",
        "signature": "jerry-core.ecma.base.ecma-literal-storage.ecma_find_or_create_literal_string (const lit_utf8_byte_t *chars_p, /**< string to be searched */                                     lit_utf8_size_t size, /**< size of the string */                                     bool is_ascii) /**< encode of the string */",
        "snippet": "ecma_value_t\necma_find_or_create_literal_string (const lit_utf8_byte_t *chars_p, /**< string to be searched */\n                                    lit_utf8_size_t size, /**< size of the string */\n                                    bool is_ascii) /**< encode of the string */\n{\n  ecma_string_t *string_p = (is_ascii ? ecma_new_ecma_string_from_ascii (chars_p, size)\n                                      : ecma_new_ecma_string_from_utf8 (chars_p, size));\n\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    return ecma_make_string_value (string_p);\n  }\n\n  jmem_cpointer_t string_list_cp = JERRY_CONTEXT (string_list_first_cp);\n  jmem_cpointer_t *empty_cpointer_p = NULL;\n\n  while (string_list_cp != JMEM_CP_NULL)\n  {\n    ecma_lit_storage_item_t *string_list_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_lit_storage_item_t, string_list_cp);\n\n    for (int i = 0; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)\n    {\n      if (string_list_p->values[i] == JMEM_CP_NULL)\n      {\n        if (empty_cpointer_p == NULL)\n        {\n          empty_cpointer_p = string_list_p->values + i;\n        }\n      }\n      else\n      {\n        ecma_string_t *value_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_string_t,\n                                                               string_list_p->values[i]);\n\n        if (ecma_compare_ecma_strings (string_p, value_p))\n        {\n          /* Return with string if found in the list. */\n          ecma_deref_ecma_string (string_p);\n          return ecma_make_string_value (value_p);\n        }\n      }\n    }\n\n    string_list_cp = string_list_p->next_cp;\n  }\n\n  ECMA_SET_STRING_AS_STATIC (string_p);\n  jmem_cpointer_t result;\n  JMEM_CP_SET_NON_NULL_POINTER (result, string_p);\n\n  if (empty_cpointer_p != NULL)\n  {\n    *empty_cpointer_p = result;\n    return ecma_make_string_value (string_p);\n  }\n\n  ecma_lit_storage_item_t *new_item_p;\n  new_item_p = (ecma_lit_storage_item_t *) jmem_pools_alloc (sizeof (ecma_lit_storage_item_t));\n\n  new_item_p->values[0] = result;\n  for (int i = 1; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)\n  {\n    new_item_p->values[i] = JMEM_CP_NULL;\n  }\n\n  new_item_p->next_cp = JERRY_CONTEXT (string_list_first_cp);\n  JMEM_CP_SET_NON_NULL_POINTER (JERRY_CONTEXT (string_list_first_cp), new_item_p);\n\n  return ecma_make_string_value (string_p);\n}",
        "begin_line": 166,
        "end_line": 235,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-array-prototype.ecma_builtin_array_prototype_dispatch_routine#2908",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-array-prototype.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-array-prototype",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-array-prototype.ecma_builtin_array_prototype_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine identifier */                                                ecma_value_t this_arg, /**< 'this' argument value */                                                const ecma_value_t arguments_list_p[], /**< list of arguments                                                                                        *   passed to routine */                                                uint32_t arguments_number) /**< length of arguments' list */",
        "snippet": "ecma_value_t\necma_builtin_array_prototype_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine identifier */\n                                               ecma_value_t this_arg, /**< 'this' argument value */\n                                               const ecma_value_t arguments_list_p[], /**< list of arguments\n                                                                                       *   passed to routine */\n                                               uint32_t arguments_number) /**< length of arguments' list */\n{\n  ecma_value_t obj_this = ecma_op_to_object (this_arg);\n\n  if (ECMA_IS_VALUE_ERROR (obj_this))\n  {\n    return obj_this;\n  }\n\n  ecma_object_t *obj_p = ecma_get_object_from_value (obj_this);\n\n  if (JERRY_UNLIKELY (builtin_routine_id <= ECMA_ARRAY_PROTOTYPE_CONCAT))\n  {\n    ecma_value_t ret_value = ECMA_VALUE_EMPTY;\n\n#if !JERRY_ESNEXT\n    if (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_TO_STRING)\n    {\n      ret_value = ecma_array_object_to_string (obj_this);\n    }\n#endif /* !JERRY_ESNEXT */\n    if (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_SORT)\n    {\n      ret_value = ecma_builtin_array_prototype_object_sort (this_arg,\n                                                            arguments_list_p[0],\n                                                            obj_p);\n\n    }\n    else if (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_CONCAT)\n    {\n      ret_value = ecma_builtin_array_prototype_object_concat (arguments_list_p,\n                                                              arguments_number,\n                                                              obj_p);\n    }\n\n    ecma_deref_object (obj_p);\n    return ret_value;\n  }\n\n#if JERRY_ESNEXT\n  if (JERRY_UNLIKELY (builtin_routine_id >= ECMA_ARRAY_PROTOTYPE_ENTRIES\n                      && builtin_routine_id <= ECMA_ARRAY_PROTOTYPE_KEYS))\n  {\n    ecma_value_t ret_value;\n\n    if (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_ENTRIES)\n    {\n      ret_value = ecma_op_create_array_iterator (obj_p, ECMA_ITERATOR_ENTRIES);\n    }\n    else\n    {\n      JERRY_ASSERT (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_KEYS);\n      ret_value = ecma_op_create_array_iterator (obj_p, ECMA_ITERATOR_KEYS);\n    }\n\n    ecma_deref_object (obj_p);\n    return ret_value;\n  }\n#endif /* JERRY_ESNEXT */\n\n  ecma_length_t length;\n  ecma_value_t len_value = ecma_op_object_get_length (obj_p, &length);\n\n  if (ECMA_IS_VALUE_ERROR (len_value))\n  {\n    ecma_deref_object (obj_p);\n    return len_value;\n  }\n\n  ecma_value_t ret_value;\n\n  switch (builtin_routine_id)\n  {\n    case ECMA_ARRAY_PROTOTYPE_TO_LOCALE_STRING:\n    {\n      ret_value = ecma_builtin_array_prototype_object_to_locale_string (obj_p, length);\n      break;\n    }\n    case ECMA_ARRAY_PROTOTYPE_JOIN:\n    {\n      ret_value = ecma_builtin_array_prototype_join (arguments_list_p[0], obj_p, length);\n      break;\n    }\n    case ECMA_ARRAY_PROTOTYPE_POP:\n    {\n      ret_value = ecma_builtin_array_prototype_object_pop (obj_p, length);\n      break;\n    }\n    case ECMA_ARRAY_PROTOTYPE_PUSH:\n    {\n      ret_value = ecma_builtin_array_prototype_object_push (arguments_list_p,\n                                                            arguments_number,\n                                                            obj_p,\n                                                            length);\n      break;\n    }\n    case ECMA_ARRAY_PROTOTYPE_REVERSE:\n    {\n      ret_value = ecma_builtin_array_prototype_object_reverse (this_arg, obj_p, length);\n      break;\n    }\n    case ECMA_ARRAY_PROTOTYPE_SHIFT:\n    {\n      ret_value = ecma_builtin_array_prototype_object_shift (obj_p, length);\n      break;\n    }\n    case ECMA_ARRAY_PROTOTYPE_SLICE:\n    {\n      ret_value = ecma_builtin_array_prototype_object_slice (arguments_list_p[0],\n                                                             arguments_list_p[1],\n                                                             obj_p,\n                                                             length);\n      break;\n    }\n    case ECMA_ARRAY_PROTOTYPE_SPLICE:\n    {\n      ret_value = ecma_builtin_array_prototype_object_splice (arguments_list_p,\n                                                              arguments_number,\n                                                              obj_p,\n                                                              length);\n      break;\n    }\n    case ECMA_ARRAY_PROTOTYPE_UNSHIFT:\n    {\n      ret_value = ecma_builtin_array_prototype_object_unshift (arguments_list_p,\n                                                               arguments_number,\n                                                               obj_p,\n                                                               length);\n      break;\n    }\n    case ECMA_ARRAY_PROTOTYPE_AT:\n    {\n      ret_value = ecma_builtin_array_prototype_object_at (arguments_list_p[0],\n                                                          obj_p,\n                                                          length);\n      break;\n    }\n    case ECMA_ARRAY_PROTOTYPE_INDEX_OF:\n    {\n      ret_value = ecma_builtin_array_prototype_object_index_of (arguments_list_p,\n                                                                arguments_number,\n                                                                obj_p,\n                                                                length);\n      break;\n    }\n    case ECMA_ARRAY_PROTOTYPE_LAST_INDEX_OF:\n    {\n      ret_value = ecma_builtin_array_prototype_object_last_index_of (arguments_list_p,\n                                                                     arguments_number,\n                                                                     obj_p,\n                                                                     length);\n      break;\n    }\n    case ECMA_ARRAY_PROTOTYPE_EVERY:\n    case ECMA_ARRAY_PROTOTYPE_SOME:\n    case ECMA_ARRAY_PROTOTYPE_FOR_EACH:\n    {\n      ret_value = ecma_builtin_array_apply (arguments_list_p[0],\n                                            arguments_list_p[1],\n                                            (array_routine_mode) builtin_routine_id - ECMA_ARRAY_PROTOTYPE_EVERY,\n                                            obj_p,\n                                            length);\n      break;\n    }\n    case ECMA_ARRAY_PROTOTYPE_MAP:\n    {\n      ret_value = ecma_builtin_array_prototype_object_map (arguments_list_p[0],\n                                                           arguments_list_p[1],\n                                                           obj_p,\n                                                           length);\n      break;\n    }\n    case ECMA_ARRAY_PROTOTYPE_REDUCE:\n    case ECMA_ARRAY_PROTOTYPE_REDUCE_RIGHT:\n    {\n      ret_value = ecma_builtin_array_reduce_from (arguments_list_p,\n                                                  arguments_number,\n                                                  builtin_routine_id == ECMA_ARRAY_PROTOTYPE_REDUCE,\n                                                  obj_p,\n                                                  length);\n      break;\n    }\n#if JERRY_ESNEXT\n    case ECMA_ARRAY_PROTOTYPE_COPY_WITHIN:\n    {\n      ret_value = ecma_builtin_array_prototype_object_copy_within (arguments_list_p,\n                                                                   arguments_number,\n                                                                   obj_p,\n                                                                   length);\n      break;\n    }\n    case ECMA_ARRAY_PROTOTYPE_FIND:\n    case ECMA_ARRAY_PROTOTYPE_FIND_INDEX:\n    {\n      ret_value = ecma_builtin_array_prototype_object_find (arguments_list_p[0],\n                                                            arguments_list_p[1],\n                                                            builtin_routine_id == ECMA_ARRAY_PROTOTYPE_FIND,\n                                                            obj_p,\n                                                            length);\n      break;\n    }\n    case ECMA_ARRAY_PROTOTYPE_FILL:\n    {\n      ret_value = ecma_builtin_array_prototype_fill (arguments_list_p[0],\n                                                     arguments_list_p[1],\n                                                     arguments_list_p[2],\n                                                     obj_p,\n                                                     length);\n      break;\n    }\n    case ECMA_ARRAY_PROTOTYPE_INCLUDES:\n    {\n      ret_value = ecma_builtin_array_prototype_includes (arguments_list_p,\n                                                         arguments_number,\n                                                         obj_p,\n                                                         length);\n      break;\n    }\n    case ECMA_ARRAY_PROTOTYPE_FLAT:\n    {\n      ret_value = ecma_builtin_array_prototype_object_flat (arguments_list_p,\n                                                            arguments_number,\n                                                            obj_p,\n                                                            length);\n      break;\n    }\n    case ECMA_ARRAY_PROTOTYPE_FLATMAP:\n    {\n      ret_value = ecma_builtin_array_prototype_object_flat_map (arguments_list_p[0],\n                                                                arguments_list_p[1],\n                                                                obj_p,\n                                                                length);\n      break;\n    }\n#endif /* JERRY_ESNEXT */\n    default:\n    {\n      JERRY_ASSERT (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_FILTER);\n\n      ret_value = ecma_builtin_array_prototype_object_filter (arguments_list_p[0],\n                                                              arguments_list_p[1],\n                                                              obj_p,\n                                                              length);\n      break;\n    }\n  }\n\n  ecma_free_value (len_value);\n  ecma_deref_object (obj_p);\n\n  return ret_value;\n}",
        "begin_line": 2908,
        "end_line": 3164,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-array-prototype.ecma_builtin_array_prototype_object_push#431",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-array-prototype.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-array-prototype",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-array-prototype.ecma_builtin_array_prototype_object_push (const ecma_value_t *argument_list_p, /**< arguments list */                                           uint32_t arguments_number, /**< number of arguments */                                           ecma_object_t *obj_p, /**< object */                                           ecma_length_t length) /**< object's length */",
        "snippet": "static ecma_value_t\necma_builtin_array_prototype_object_push (const ecma_value_t *argument_list_p, /**< arguments list */\n                                          uint32_t arguments_number, /**< number of arguments */\n                                          ecma_object_t *obj_p, /**< object */\n                                          ecma_length_t length) /**< object's length */\n{\n  if (ecma_op_object_is_fast_array (obj_p))\n  {\n    if ((ecma_number_t) (length + arguments_number) > UINT32_MAX)\n    {\n      return ecma_raise_range_error (ECMA_ERR_MSG (ecma_error_invalid_array_length));\n    }\n\n    if (arguments_number == 0)\n    {\n      return ecma_make_uint32_value ((uint32_t) length);\n    }\n\n    uint32_t new_length = ((uint32_t) length) + arguments_number;\n    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;\n    ecma_value_t *buffer_p = ecma_fast_array_extend (obj_p, new_length) + length;\n\n    for (uint32_t index = 0; index < arguments_number; index++)\n    {\n      buffer_p[index] = ecma_copy_value_if_not_object (argument_list_p[index]);\n    }\n\n    ext_obj_p->u.array.length_prop_and_hole_count -= ECMA_FAST_ARRAY_HOLE_ONE * arguments_number;\n\n    return ecma_make_uint32_value (new_length);\n  }\n\n#if JERRY_ESNEXT\n  /* 5. */\n  if ((ecma_number_t) (length + arguments_number) > ECMA_NUMBER_MAX_SAFE_INTEGER)\n  {\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Pushing element over 2**53-1 length is disallowed\"));\n  }\n\n  /* 6. */\n  for (ecma_length_t index = 0; index < arguments_number; index++, length++)\n  {\n    /* 6.b */\n    ecma_value_t put_value = ecma_op_object_put_by_index (obj_p, length, argument_list_p[index], true);\n\n    if (ECMA_IS_VALUE_ERROR (put_value))\n    {\n      return put_value;\n    }\n  }\n\n  ecma_number_t n = (ecma_number_t) length;\n#else /* JERRY_ESNEXT */\n  ecma_number_t n = (ecma_number_t) length;\n\n  /* 5. */\n  for (ecma_length_t index = 0; index < arguments_number; index++, n++)\n  {\n    /* 5.b */\n    ecma_string_t *index_str_p = ecma_new_ecma_string_from_number (n);\n    ecma_value_t put_value = ecma_op_object_put (obj_p, index_str_p, argument_list_p[index], true);\n    ecma_deref_ecma_string (index_str_p);\n\n    if (ECMA_IS_VALUE_ERROR (put_value))\n    {\n      return put_value;\n    }\n  }\n\n#endif /* JERRY_ESNEXT */\n  /* 6 - 7. */\n  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, n);\n\n  if (ECMA_IS_VALUE_ERROR (set_length_value))\n  {\n    return set_length_value;\n  }\n\n  return ecma_make_number_value (n);\n}",
        "begin_line": 431,
        "end_line": 510,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-array-prototype.ecma_builtin_array_prototype_object_slice#811",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-array-prototype.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-array-prototype",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-array-prototype.ecma_builtin_array_prototype_object_slice (ecma_value_t arg1, /**< start */                                            ecma_value_t arg2, /**< end */                                            ecma_object_t *obj_p, /**< object */                                            ecma_length_t len) /**< object's length */",
        "snippet": "static ecma_value_t\necma_builtin_array_prototype_object_slice (ecma_value_t arg1, /**< start */\n                                           ecma_value_t arg2, /**< end */\n                                           ecma_object_t *obj_p, /**< object */\n                                           ecma_length_t len) /**< object's length */\n{\n  ecma_length_t start = 0, end = len;\n\n  /* 5. 6.*/\n  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (arg1,\n                                                                      len,\n                                                                      &start)))\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  /* 7. */\n  if (ecma_is_value_undefined (arg2))\n  {\n    end = len;\n  }\n  else\n  {\n    /* 7. part 2, 8.*/\n    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (arg2,\n                                                                        len,\n                                                                        &end)))\n    {\n      return ECMA_VALUE_ERROR;\n    }\n  }\n\n  JERRY_ASSERT (start <= len && end <= len);\n\n  bool use_fast_path = ecma_op_object_is_fast_array (obj_p);\n  ecma_length_t copied_length = (end > start) ? end - start : 0;\n#if JERRY_ESNEXT\n  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, copied_length);\n\n  if (JERRY_UNLIKELY (new_array_p == NULL))\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  use_fast_path &= ecma_op_object_is_fast_array (new_array_p);\n#else /* !JERRY_ESNEXT */\n  ecma_object_t *new_array_p = ecma_op_new_array_object (0);\n#endif /* JERRY_ESNEXT */\n\n  if (use_fast_path && copied_length > 0)\n  {\n    ecma_extended_object_t *ext_from_obj_p = (ecma_extended_object_t *) obj_p;\n\n    if (ext_from_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)\n    {\n      if (JERRY_UNLIKELY (obj_p->u1.property_list_cp == JMEM_CP_NULL))\n      {\n        /**\n         * Very unlikely case: the buffer copied from is a fast buffer and the property list was deleted.\n         * There is no need to do any copy.\n         */\n        return ecma_make_object_value (new_array_p);\n      }\n\n      /* Source array's length could be changed during the start/end normalization.\n       * If the \"end\" value is greater than the current length, clamp the value to avoid buffer-overflow. */\n\n      ecma_extended_object_t *ext_to_obj_p = (ecma_extended_object_t *) new_array_p;\n\n#if JERRY_ESNEXT\n      uint32_t target_length = ext_to_obj_p->u.array.length;\n      ecma_value_t *to_buffer_p;\n      JERRY_ASSERT (copied_length <= UINT32_MAX);\n\n      if (copied_length == target_length)\n      {\n        to_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, new_array_p->u1.property_list_cp);\n      }\n      else if (copied_length > target_length)\n      {\n        to_buffer_p = ecma_fast_array_extend (new_array_p, (uint32_t) copied_length);\n      }\n      else\n      {\n        ecma_delete_fast_array_properties (new_array_p, (uint32_t) copied_length);\n        to_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, new_array_p->u1.property_list_cp);\n      }\n#else /* !JERRY_ESNEXT */\n      ecma_value_t *to_buffer_p = ecma_fast_array_extend (new_array_p, copied_length);\n#endif /* JERRY_ESNEXT */\n\n      ecma_value_t *from_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);\n\n      /* 9. */\n      uint32_t n = 0;\n\n      for (uint32_t k = (uint32_t) start; k < (uint32_t) end; k++, n++)\n      {\n#if JERRY_ESNEXT\n        ecma_free_value_if_not_object (to_buffer_p[n]);\n#endif /* JERRY_ESNEXT */\n        to_buffer_p[n] = ecma_copy_value_if_not_object (from_buffer_p[k]);\n      }\n\n      ext_to_obj_p->u.array.length_prop_and_hole_count &= ECMA_FAST_ARRAY_HOLE_ONE - 1;\n\n      return ecma_make_object_value (new_array_p);\n    }\n  }\n\n  /* 9. */\n  ecma_length_t n = 0;\n\n  /* 10. */\n  for (ecma_length_t k = start; k < end; k++, n++)\n  {\n    /* 10.c */\n    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, k);\n\n    if (ECMA_IS_VALUE_ERROR (get_value))\n    {\n      ecma_deref_object (new_array_p);\n      return get_value;\n    }\n\n    if (ecma_is_value_found (get_value))\n    {\n      /* 10.c.ii */\n      ecma_value_t put_comp;\n#if JERRY_ESNEXT\n      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;\n#else /* !JERRY_ESNEXT */\n      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE;\n#endif /* JERRY_ESNEXT */\n      put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p,\n                                                        n,\n                                                        get_value,\n                                                        prop_flags);\n      ecma_free_value (get_value);\n\n#if JERRY_ESNEXT\n      if (ECMA_IS_VALUE_ERROR (put_comp))\n      {\n        ecma_deref_object (new_array_p);\n        return put_comp;\n      }\n#else /* !JERRY_ESNEXT */\n      JERRY_ASSERT (ecma_is_value_true (put_comp));\n#endif /* JERRY_ESNEXT */\n    }\n  }\n\n#if JERRY_ESNEXT\n  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (new_array_p, ((ecma_number_t) n));\n\n  if (ECMA_IS_VALUE_ERROR (set_length_value))\n  {\n    ecma_deref_object (new_array_p);\n    return set_length_value;\n  }\n#endif /* JERRY_ESNEXT */\n\n  return ecma_make_object_value (new_array_p);\n}",
        "begin_line": 811,
        "end_line": 974,
        "is_bug": true
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-array.ecma_builtin_array_dispatch_call#479",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-array.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-array",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-array.ecma_builtin_array_dispatch_call (const ecma_value_t *arguments_list_p, /**< arguments list */                                   uint32_t arguments_list_len) /**< number of arguments */",
        "snippet": "ecma_value_t\necma_builtin_array_dispatch_call (const ecma_value_t *arguments_list_p, /**< arguments list */\n                                  uint32_t arguments_list_len) /**< number of arguments */\n{\n  JERRY_ASSERT (arguments_list_len == 0 || arguments_list_p != NULL);\n\n  if (arguments_list_len != 1\n      || !ecma_is_value_number (arguments_list_p[0]))\n  {\n    return ecma_op_new_array_object_from_buffer (arguments_list_p, arguments_list_len);\n  }\n\n  ecma_number_t num = ecma_get_number_from_value (arguments_list_p[0]);\n  uint32_t num_uint32 = ecma_number_to_uint32 (num);\n\n  if (num != ((ecma_number_t) num_uint32))\n  {\n    return ecma_raise_range_error (ECMA_ERR_MSG (ecma_error_invalid_array_length));\n  }\n\n  return ecma_make_object_value (ecma_op_new_array_object (num_uint32));\n}",
        "begin_line": 479,
        "end_line": 500,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-array.ecma_builtin_array_dispatch_construct#508",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-array.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-array",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-array.ecma_builtin_array_dispatch_construct (const ecma_value_t *arguments_list_p, /**< arguments list */                                        uint32_t arguments_list_len) /**< number of arguments */",
        "snippet": "ecma_value_t\necma_builtin_array_dispatch_construct (const ecma_value_t *arguments_list_p, /**< arguments list */\n                                       uint32_t arguments_list_len) /**< number of arguments */\n{\n  JERRY_ASSERT (arguments_list_len == 0 || arguments_list_p != NULL);\n\n#if !JERRY_ESNEXT\n  return ecma_builtin_array_dispatch_call (arguments_list_p, arguments_list_len);\n#else /* JERRY_ESNEXT */\n  ecma_object_t *proto_p = ecma_op_get_prototype_from_constructor (JERRY_CONTEXT (current_new_target_p),\n                                                                   ECMA_BUILTIN_ID_ARRAY_PROTOTYPE);\n\n  if (proto_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_value_t result = ecma_builtin_array_dispatch_call (arguments_list_p, arguments_list_len);\n\n  if (ECMA_IS_VALUE_ERROR (result))\n  {\n    ecma_deref_object (proto_p);\n    return result;\n  }\n\n  ecma_object_t *object_p = ecma_get_object_from_value (result);\n  ECMA_SET_NON_NULL_POINTER (object_p->u2.prototype_cp, proto_p);\n  ecma_deref_object (proto_p);\n  return result;\n#endif /* JERRY_ESNEXT */\n}",
        "begin_line": 508,
        "end_line": 538,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-array.ecma_builtin_array_dispatch_routine#546",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-array.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-array",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-array.ecma_builtin_array_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine identifier */                                      ecma_value_t this_arg, /**< 'this' argument value */                                      const ecma_value_t arguments_list_p[], /**< list of arguments                                                                              *   passed to routine */                                      uint32_t arguments_number) /**< length of arguments' list */",
        "snippet": "ecma_value_t\necma_builtin_array_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine identifier */\n                                     ecma_value_t this_arg, /**< 'this' argument value */\n                                     const ecma_value_t arguments_list_p[], /**< list of arguments\n                                                                             *   passed to routine */\n                                     uint32_t arguments_number) /**< length of arguments' list */\n{\n  JERRY_UNUSED (arguments_number);\n\n  switch (builtin_routine_id)\n  {\n    case ECMA_ARRAY_ROUTINE_IS_ARRAY:\n    {\n      JERRY_UNUSED (this_arg);\n\n      return ecma_is_value_array (arguments_list_p[0]);\n    }\n#if JERRY_ESNEXT\n    case ECMA_ARRAY_ROUTINE_FROM:\n    {\n      return ecma_builtin_array_object_from (this_arg, arguments_list_p, arguments_number);\n    }\n    case ECMA_ARRAY_ROUTINE_OF:\n    {\n      return ecma_builtin_array_object_of (this_arg, arguments_list_p, arguments_number);\n    }\n    case ECMA_ARRAY_ROUTINE_SPECIES_GET:\n    {\n      return ecma_copy_value (this_arg);\n    }\n#endif /* JERRY_ESNEXT */\n    default:\n    {\n      JERRY_UNREACHABLE ();\n    }\n  }\n}",
        "begin_line": 546,
        "end_line": 582,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-helpers.ecma_builtin_helper_array_index_normalize#258",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-helpers.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-helpers",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-helpers.ecma_builtin_helper_array_index_normalize (ecma_value_t arg, /**< index */                                            ecma_length_t length, /**< array's length */                                            ecma_length_t *number_p) /**< [out] ecma_length_t */",
        "snippet": "ecma_value_t\necma_builtin_helper_array_index_normalize (ecma_value_t arg, /**< index */\n                                           ecma_length_t length, /**< array's length */\n                                           ecma_length_t *number_p) /**< [out] ecma_length_t */\n{\n#if JERRY_ESNEXT\n  ecma_number_t to_int;\n\n  if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (arg, &to_int)))\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  *number_p = ((to_int < 0) ? (ecma_length_t) JERRY_MAX (((ecma_number_t) length + to_int), 0)\n                            : (ecma_length_t) JERRY_MIN (to_int, (ecma_number_t) length));\n\n  return ECMA_VALUE_EMPTY;\n#else /* !JERRY_ESNEXT */\n  return ecma_builtin_helper_uint32_index_normalize (arg, length, number_p);\n#endif /* JERRY_ESNEXT */\n}",
        "begin_line": 258,
        "end_line": 278,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-helpers.ecma_builtin_helper_def_prop#884",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-helpers.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-helpers",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-helpers.ecma_builtin_helper_def_prop (ecma_object_t *obj_p, /**< object */                               ecma_string_t *name_p, /**< name string */                               ecma_value_t value, /**< value */                               uint32_t opts) /**< any combination of ecma_property_descriptor_status_flags_t bits */",
        "snippet": "ecma_value_t\necma_builtin_helper_def_prop (ecma_object_t *obj_p, /**< object */\n                              ecma_string_t *name_p, /**< name string */\n                              ecma_value_t value, /**< value */\n                              uint32_t opts) /**< any combination of ecma_property_descriptor_status_flags_t bits */\n{\n  ecma_property_descriptor_t prop_desc;\n\n  prop_desc.flags = (uint16_t) (ECMA_NAME_DATA_PROPERTY_DESCRIPTOR_BITS | opts);\n\n  prop_desc.value = value;\n\n  return ecma_op_object_define_own_property (obj_p,\n                                             name_p,\n                                             &prop_desc);\n}",
        "begin_line": 884,
        "end_line": 899,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_create_global_object#557",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_create_global_object (void)",
        "snippet": "ecma_global_object_t *\necma_builtin_create_global_object (void)\n{\n  ecma_builtin_descriptor_t builtin_desc = ecma_builtin_descriptors[ECMA_BUILTIN_ID_GLOBAL];\n  ecma_builtin_id_t prototype_builtin_id = (ecma_builtin_id_t) (builtin_desc >> ECMA_BUILTIN_PROTOTYPE_ID_SHIFT);\n  ecma_object_type_t obj_type = (ecma_object_type_t) (builtin_desc & ECMA_BUILTIN_OBJECT_TYPE_MASK);\n  size_t property_count = ecma_builtin_get_property_count (ECMA_BUILTIN_ID_GLOBAL);\n\n  JERRY_ASSERT (prototype_builtin_id != ECMA_BUILTIN_ID__COUNT);\n  JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_GENERAL);\n\n  /* Whenever this assertion fails, the size of extra_instantiated_bitset in ecma_global_object_t\n   * must be increased and 32 must be added to these constants. Furthermore the new uint32 item\n   * must be set to zero. */\n#if JERRY_BUILTIN_REALMS\n  JERRY_ASSERT (property_count <= ECMA_BUILTIN_INSTANTIATED_BITSET_MIN_SIZE + 64);\n#else /* !JERRY_BUILTIN_REALMS */\n  JERRY_ASSERT (property_count <= ECMA_BUILTIN_INSTANTIATED_BITSET_MIN_SIZE + 32);\n#endif /* JERRY_BUILTIN_REALMS */\n\n  ecma_object_t *object_p = ecma_create_object (NULL, sizeof (ecma_global_object_t), obj_type);\n\n  ecma_op_ordinary_object_set_extensible (object_p);\n\n  ecma_global_object_t *global_object_p = (ecma_global_object_t *) object_p;\n\n  global_object_p->extended_object.u.built_in.id = (uint8_t) ECMA_BUILTIN_ID_GLOBAL;\n  global_object_p->extended_object.u.built_in.routine_id = 0;\n  /* Bitset size is ignored by the gc. */\n  global_object_p->extended_object.u.built_in.u.length_and_bitset_size = 0;\n  global_object_p->extended_object.u.built_in.u2.instantiated_bitset[0] = 0;\n  global_object_p->extra_instantiated_bitset[0] = 0;\n#if JERRY_BUILTIN_REALMS\n  ECMA_SET_INTERNAL_VALUE_POINTER (global_object_p->extended_object.u.built_in.realm_value, global_object_p);\n  global_object_p->extra_realms_bitset = 0;\n  global_object_p->this_binding = ecma_make_object_value (object_p);\n#else /* !JERRY_BUILTIN_REALMS */\n  global_object_p->extended_object.u.built_in.continue_instantiated_bitset[0] = 0;\n#endif /* JERRY_BUILTIN_REALMS */\n\n  memset (global_object_p->builtin_objects, 0, (sizeof (jmem_cpointer_t) * ECMA_BUILTIN_OBJECTS_COUNT));\n\n  /* Temporary self reference for GC mark. */\n  ECMA_SET_NON_NULL_POINTER (global_object_p->global_env_cp, object_p);\n#if JERRY_ESNEXT\n  global_object_p->global_scope_cp = global_object_p->global_env_cp;\n#endif /* JERRY_ESNEXT */\n\n  ecma_object_t *global_lex_env_p = ecma_create_object_lex_env (NULL, object_p);\n  ECMA_SET_NON_NULL_POINTER (global_object_p->global_env_cp, global_lex_env_p);\n#if JERRY_ESNEXT\n  global_object_p->global_scope_cp = global_object_p->global_env_cp;\n#endif /* JERRY_ESNEXT */\n  ecma_deref_object (global_lex_env_p);\n\n  ecma_object_t *prototype_object_p;\n  prototype_object_p = ecma_instantiate_builtin (global_object_p, prototype_builtin_id);\n  JERRY_ASSERT (prototype_object_p != NULL);\n\n  ECMA_SET_NON_NULL_POINTER (object_p->u2.prototype_cp, prototype_object_p);\n\n  return global_object_p;\n}",
        "begin_line": 557,
        "end_line": 619,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_dispatch_call#1624",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_dispatch_call (ecma_object_t *obj_p, /**< built-in object */                             ecma_value_t this_arg_value, /**< 'this' argument value */                             const ecma_value_t *arguments_list_p, /**< arguments list */                             uint32_t arguments_list_len) /**< arguments list length */",
        "snippet": "ecma_value_t\necma_builtin_dispatch_call (ecma_object_t *obj_p, /**< built-in object */\n                            ecma_value_t this_arg_value, /**< 'this' argument value */\n                            const ecma_value_t *arguments_list_p, /**< arguments list */\n                            uint32_t arguments_list_len) /**< arguments list length */\n{\n  JERRY_ASSERT (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);\n\n  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;\n\n  if (ecma_builtin_function_is_routine (obj_p))\n  {\n#if JERRY_ESNEXT\n    if (JERRY_UNLIKELY (ext_obj_p->u.built_in.id == ECMA_BUILTIN_ID_HANDLER))\n    {\n      ecma_builtin_handler_t handler = ecma_builtin_handler_get (ext_obj_p->u.built_in.routine_id);\n      return handler (obj_p, arguments_list_p, arguments_list_len);\n    }\n#endif /* !JERRY_ESNEXT */\n\n    return ecma_builtin_dispatch_routine (ext_obj_p,\n                                          this_arg_value,\n                                          arguments_list_p,\n                                          arguments_list_len);\n  }\n\n  ecma_builtin_id_t builtin_object_id = ext_obj_p->u.built_in.id;\n  JERRY_ASSERT (builtin_object_id < sizeof (ecma_builtin_call_functions) / sizeof (ecma_builtin_dispatch_call_t));\n  return ecma_builtin_call_functions[builtin_object_id] (arguments_list_p, arguments_list_len);\n}",
        "begin_line": 1624,
        "end_line": 1653,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_dispatch_construct#1660",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_dispatch_construct (ecma_object_t *obj_p, /**< built-in object */                                  const ecma_value_t *arguments_list_p, /**< arguments list */                                  uint32_t arguments_list_len) /**< arguments list length */",
        "snippet": "ecma_value_t\necma_builtin_dispatch_construct (ecma_object_t *obj_p, /**< built-in object */\n                                 const ecma_value_t *arguments_list_p, /**< arguments list */\n                                 uint32_t arguments_list_len) /**< arguments list length */\n{\n  JERRY_ASSERT (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);\n\n  if (ecma_builtin_function_is_routine (obj_p))\n  {\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Built-in routines have no constructor\"));\n  }\n\n  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;\n  ecma_builtin_id_t builtin_object_id = ext_obj_p->u.built_in.id;\n  JERRY_ASSERT (builtin_object_id < sizeof (ecma_builtin_construct_functions) / sizeof (ecma_builtin_dispatch_call_t));\n\n  return ecma_builtin_construct_functions[builtin_object_id] (arguments_list_p, arguments_list_len);\n}",
        "begin_line": 1660,
        "end_line": 1677,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_dispatch_routine#1580",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_dispatch_routine (ecma_extended_object_t *func_obj_p, /**< builtin object */                                ecma_value_t this_arg_value, /**< 'this' argument value */                                const ecma_value_t *arguments_list_p, /**< list of arguments passed to routine */                                uint32_t arguments_list_len) /**< length of arguments' list */",
        "snippet": "static ecma_value_t\necma_builtin_dispatch_routine (ecma_extended_object_t *func_obj_p, /**< builtin object */\n                               ecma_value_t this_arg_value, /**< 'this' argument value */\n                               const ecma_value_t *arguments_list_p, /**< list of arguments passed to routine */\n                               uint32_t arguments_list_len) /**< length of arguments' list */\n{\n  JERRY_ASSERT (ecma_builtin_function_is_routine ((ecma_object_t *) func_obj_p));\n\n  ecma_value_t padded_arguments_list_p[3] = { ECMA_VALUE_UNDEFINED, ECMA_VALUE_UNDEFINED, ECMA_VALUE_UNDEFINED };\n\n  if (arguments_list_len <= 2)\n  {\n    switch (arguments_list_len)\n    {\n      case 2:\n      {\n        padded_arguments_list_p[1] = arguments_list_p[1];\n        /* FALLTHRU */\n      }\n      case 1:\n      {\n        padded_arguments_list_p[0] = arguments_list_p[0];\n        break;\n      }\n      default:\n      {\n        JERRY_ASSERT (arguments_list_len == 0);\n      }\n    }\n\n    arguments_list_p = padded_arguments_list_p;\n  }\n\n  return ecma_builtin_routines[func_obj_p->u.built_in.id] (func_obj_p->u.built_in.routine_id,\n                                                           this_arg_value,\n                                                           arguments_list_p,\n                                                           arguments_list_len);\n}",
        "begin_line": 1580,
        "end_line": 1617,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_function_is_routine#308",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_function_is_routine (ecma_object_t *func_obj_p) /**< function object */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\necma_builtin_function_is_routine (ecma_object_t *func_obj_p) /**< function object */\n{\n  JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);\n\n  ecma_extended_object_t *ext_func_obj_p = (ecma_extended_object_t *) func_obj_p;\n  return (ext_func_obj_p->u.built_in.routine_id != 0);\n}",
        "begin_line": 308,
        "end_line": 315,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get#629",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get (ecma_builtin_id_t builtin_id) /**< id of built-in to check on */",
        "snippet": "ecma_object_t *\necma_builtin_get (ecma_builtin_id_t builtin_id) /**< id of built-in to check on */\n{\n  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_OBJECTS_COUNT);\n\n  ecma_global_object_t *global_object_p = (ecma_global_object_t *) ecma_builtin_get_global ();\n  jmem_cpointer_t *builtin_p = global_object_p->builtin_objects + builtin_id;\n\n  if (JERRY_UNLIKELY (*builtin_p == JMEM_CP_NULL))\n  {\n    return ecma_instantiate_builtin (global_object_p, builtin_id);\n  }\n\n  return ECMA_GET_NON_NULL_POINTER (ecma_object_t, *builtin_p);\n}",
        "begin_line": 629,
        "end_line": 643,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get_from_builtin#681",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get_from_builtin (ecma_object_t *builtin_object_p, /**< built-in object */                                ecma_builtin_id_t builtin_id) /**< id of built-in to check on */",
        "snippet": "static inline ecma_object_t * JERRY_ATTR_ALWAYS_INLINE\necma_builtin_get_from_builtin (ecma_object_t *builtin_object_p, /**< built-in object */\n                               ecma_builtin_id_t builtin_id) /**< id of built-in to check on */\n{\n  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_OBJECTS_COUNT);\n\n#if JERRY_BUILTIN_REALMS\n  return ecma_builtin_get_from_realm (ecma_builtin_get_realm (builtin_object_p), builtin_id);\n#else /* !JERRY_BUILTIN_REALMS */\n  JERRY_UNUSED (builtin_object_p);\n  return ecma_builtin_get (builtin_id);\n#endif /* JERRY_BUILTIN_REALMS */\n}",
        "begin_line": 681,
        "end_line": 693,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get_from_realm#655",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get_from_realm (ecma_global_object_t *global_object_p, /**< global object */                              ecma_builtin_id_t builtin_id) /**< id of built-in to check on */",
        "snippet": "ecma_object_t *\necma_builtin_get_from_realm (ecma_global_object_t *global_object_p, /**< global object */\n                             ecma_builtin_id_t builtin_id) /**< id of built-in to check on */\n{\n  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_OBJECTS_COUNT);\n\n  jmem_cpointer_t *builtin_p = global_object_p->builtin_objects + builtin_id;\n\n  if (JERRY_UNLIKELY (*builtin_p == JMEM_CP_NULL))\n  {\n    return ecma_instantiate_builtin (global_object_p, builtin_id);\n  }\n\n  return ECMA_GET_NON_NULL_POINTER (ecma_object_t, *builtin_p);\n}",
        "begin_line": 655,
        "end_line": 669,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get_global#294",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get_global (void)",
        "snippet": "extern inline ecma_object_t * JERRY_ATTR_ALWAYS_INLINE\necma_builtin_get_global (void)\n{\n  JERRY_ASSERT (JERRY_CONTEXT (global_object_p) != NULL);\n\n  return (ecma_object_t *) JERRY_CONTEXT (global_object_p);\n}",
        "begin_line": 294,
        "end_line": 300,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get_property_count#257",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get_property_count (ecma_builtin_id_t builtin_id) /**< built-in ID */",
        "snippet": "static size_t\necma_builtin_get_property_count (ecma_builtin_id_t builtin_id) /**< built-in ID */\n{\n  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_ID__COUNT);\n  const ecma_builtin_property_descriptor_t *property_list_p = ecma_builtin_property_list_references[builtin_id];\n\n  const ecma_builtin_property_descriptor_t *curr_property_p = property_list_p;\n\n  while (curr_property_p->magic_string_id != LIT_MAGIC_STRING__COUNT)\n  {\n    curr_property_p++;\n  }\n\n  return (size_t) (curr_property_p - property_list_p);\n}",
        "begin_line": 257,
        "end_line": 271,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get_realm#327",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get_realm (ecma_object_t *builtin_object_p) /**< built-in object */",
        "snippet": "static ecma_global_object_t *\necma_builtin_get_realm (ecma_object_t *builtin_object_p) /**< built-in object */\n{\n  ecma_object_type_t object_type = ecma_get_object_type (builtin_object_p);\n  ecma_value_t realm_value;\n\n  JERRY_ASSERT (object_type == ECMA_OBJECT_TYPE_BUILT_IN_GENERAL\n                || object_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS\n                || object_type == ECMA_OBJECT_TYPE_BUILT_IN_ARRAY\n                || object_type == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);\n\n  if (ECMA_BUILTIN_IS_EXTENDED_BUILT_IN (object_type))\n  {\n    realm_value = ((ecma_extended_built_in_object_t *) builtin_object_p)->built_in.realm_value;\n  }\n  else\n  {\n    realm_value = ((ecma_extended_object_t *) builtin_object_p)->u.built_in.realm_value;\n  }\n\n  return ECMA_GET_INTERNAL_VALUE_POINTER (ecma_global_object_t, realm_value);\n}",
        "begin_line": 327,
        "end_line": 348,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_is_global#279",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_is_global (ecma_object_t *object_p) /**< pointer to an object */",
        "snippet": "bool\necma_builtin_is_global (ecma_object_t *object_p) /**< pointer to an object */\n{\n  return (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_BUILT_IN_GENERAL\n          && ((ecma_extended_object_t *) object_p)->u.built_in.id == ECMA_BUILTIN_ID_GLOBAL);\n}",
        "begin_line": 279,
        "end_line": 284,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_make_function_object_for_getter_accessor#750",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_make_function_object_for_getter_accessor (ecma_object_t *builtin_object_p, /**< builtin object */                                                        uint8_t routine_id, /**< builtin-wide id of the built-in                                                                             *   object's routine property */                                                        uint32_t routine_index) /**< property descriptor index                                                                                 *   of routine */",
        "snippet": "static ecma_object_t *\necma_builtin_make_function_object_for_getter_accessor (ecma_object_t *builtin_object_p, /**< builtin object */\n                                                       uint8_t routine_id, /**< builtin-wide id of the built-in\n                                                                            *   object's routine property */\n                                                       uint32_t routine_index) /**< property descriptor index\n                                                                                *   of routine */\n{\n  return ecma_builtin_make_function_object_for_routine (builtin_object_p,\n                                                        routine_id,\n                                                        routine_index,\n                                                        ECMA_BUILTIN_ROUTINE_GETTER);\n}",
        "begin_line": 750,
        "end_line": 761,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_make_function_object_for_routine#702",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_make_function_object_for_routine (ecma_object_t *builtin_object_p, /**< builtin object */                                                uint8_t routine_id, /**< builtin-wide identifier of the built-in                                                                     *   object's routine property */                                                uint32_t routine_index, /**< property descriptor index of routine */                                                uint8_t flags) /**< see also: ecma_builtin_routine_flags */",
        "snippet": "static ecma_object_t *\necma_builtin_make_function_object_for_routine (ecma_object_t *builtin_object_p, /**< builtin object */\n                                               uint8_t routine_id, /**< builtin-wide identifier of the built-in\n                                                                    *   object's routine property */\n                                               uint32_t routine_index, /**< property descriptor index of routine */\n                                               uint8_t flags) /**< see also: ecma_builtin_routine_flags */\n{\n  ecma_object_t *prototype_obj_p = ecma_builtin_get_from_builtin (builtin_object_p,\n                                                                  ECMA_BUILTIN_ID_FUNCTION_PROTOTYPE);\n\n  size_t ext_object_size = sizeof (ecma_extended_object_t);\n\n  ecma_object_t *func_obj_p = ecma_create_object (prototype_obj_p,\n                                                  ext_object_size,\n                                                  ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);\n\n  JERRY_ASSERT (routine_id > 0);\n  JERRY_ASSERT (routine_index <= UINT8_MAX);\n\n  ecma_built_in_props_t *built_in_props_p;\n\n  if (ECMA_BUILTIN_IS_EXTENDED_BUILT_IN (ecma_get_object_type (builtin_object_p)))\n  {\n    built_in_props_p = &((ecma_extended_built_in_object_t *) builtin_object_p)->built_in;\n  }\n  else\n  {\n    built_in_props_p = &((ecma_extended_object_t *) builtin_object_p)->u.built_in;\n  }\n\n  ecma_extended_object_t *ext_func_obj_p = (ecma_extended_object_t *) func_obj_p;\n  ext_func_obj_p->u.built_in.id = built_in_props_p->id;\n  ext_func_obj_p->u.built_in.routine_id = routine_id;\n  ext_func_obj_p->u.built_in.u.routine_index = (uint8_t) routine_index;\n  ext_func_obj_p->u.built_in.u2.routine_flags = flags;\n\n#if JERRY_BUILTIN_REALMS\n  ext_func_obj_p->u.built_in.realm_value = built_in_props_p->realm_value;\n#endif /* JERRY_BUILTIN_REALMS */\n\n  return func_obj_p;\n}",
        "begin_line": 702,
        "end_line": 743,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_try_to_instantiate_property#995",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_try_to_instantiate_property (ecma_object_t *object_p, /**< object */                                           ecma_string_t *property_name_p) /**< property's name */",
        "snippet": "ecma_property_t *\necma_builtin_try_to_instantiate_property (ecma_object_t *object_p, /**< object */\n                                          ecma_string_t *property_name_p) /**< property's name */\n{\n  lit_magic_string_id_t magic_string_id = ecma_get_string_magic (property_name_p);\n\n#if JERRY_ESNEXT\n  if (JERRY_UNLIKELY (ecma_prop_name_is_symbol (property_name_p))\n      && property_name_p->u.hash & ECMA_GLOBAL_SYMBOL_FLAG)\n  {\n    magic_string_id = (property_name_p->u.hash >> ECMA_GLOBAL_SYMBOL_SHIFT);\n  }\n#endif /* JERRY_ESNEXT */\n\n  if (magic_string_id == LIT_MAGIC_STRING__COUNT)\n  {\n    return NULL;\n  }\n\n  ecma_built_in_props_t *built_in_props_p;\n  ecma_object_type_t object_type = ecma_get_object_type (object_p);\n\n  JERRY_ASSERT (object_type == ECMA_OBJECT_TYPE_BUILT_IN_GENERAL\n                || object_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS\n                || object_type == ECMA_OBJECT_TYPE_BUILT_IN_ARRAY\n                || (object_type == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION\n                    && !ecma_builtin_function_is_routine (object_p)));\n\n  if (ECMA_BUILTIN_IS_EXTENDED_BUILT_IN (object_type))\n  {\n    built_in_props_p = &((ecma_extended_built_in_object_t *) object_p)->built_in;\n  }\n  else\n  {\n    built_in_props_p = &((ecma_extended_object_t *) object_p)->u.built_in;\n  }\n\n  ecma_builtin_id_t builtin_id = (ecma_builtin_id_t) built_in_props_p->id;\n\n  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_ID__COUNT);\n\n  const ecma_builtin_property_descriptor_t *property_list_p = ecma_builtin_property_list_references[builtin_id];\n  const ecma_builtin_property_descriptor_t *curr_property_p = property_list_p;\n\n  while (curr_property_p->magic_string_id != magic_string_id)\n  {\n    if (curr_property_p->magic_string_id == LIT_MAGIC_STRING__COUNT)\n    {\n      return NULL;\n    }\n    curr_property_p++;\n  }\n\n  uint32_t index = (uint32_t) (curr_property_p - property_list_p);\n  uint8_t *bitset_p = built_in_props_p->u2.instantiated_bitset + (index >> 3);\n\n#if JERRY_BUILTIN_REALMS\n  if (index >= 8 * sizeof (uint8_t))\n  {\n    bitset_p += sizeof (ecma_value_t);\n  }\n#endif /* JERRY_BUILTIN_REALMS */\n\n  uint8_t bit_for_index = (uint8_t) (1u << (index & 0x7));\n\n  if (*bitset_p & bit_for_index)\n  {\n    /* This property was instantiated before. */\n    return NULL;\n  }\n\n  ecma_value_t value = ECMA_VALUE_EMPTY;\n  bool is_accessor = false;\n  ecma_object_t *getter_p = NULL;\n  ecma_object_t *setter_p = NULL;\n\n  switch (curr_property_p->type)\n  {\n    case ECMA_BUILTIN_PROPERTY_SIMPLE:\n    {\n      value = curr_property_p->value;\n\n#if JERRY_BUILTIN_GLOBAL_THIS\n      if (value == ECMA_VALUE_GLOBAL_THIS)\n      {\n        /* Only the global object has globalThis property. */\n        JERRY_ASSERT (ecma_builtin_is_global (object_p));\n        ecma_ref_object (object_p);\n        value = ecma_make_object_value (object_p);\n      }\n#endif /* JERRY_BUILTIN_GLOBAL_THIS */\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_NUMBER:\n    {\n      ecma_number_t num = 0.0;\n\n      if (curr_property_p->value < ECMA_BUILTIN_NUMBER_MAX)\n      {\n        num = curr_property_p->value;\n      }\n      else if (curr_property_p->value < ECMA_BUILTIN_NUMBER_NAN)\n      {\n        static const ecma_number_t builtin_number_list[] =\n        {\n          ECMA_NUMBER_MAX_VALUE,\n          ECMA_NUMBER_MIN_VALUE,\n#if JERRY_ESNEXT\n          ECMA_NUMBER_EPSILON,\n          ECMA_NUMBER_MAX_SAFE_INTEGER,\n          ECMA_NUMBER_MIN_SAFE_INTEGER,\n#endif /* JERRY_ESNEXT */\n          ECMA_NUMBER_E,\n          ECMA_NUMBER_PI,\n          ECMA_NUMBER_LN10,\n          ECMA_NUMBER_LN2,\n          ECMA_NUMBER_LOG2E,\n          ECMA_NUMBER_LOG10E,\n          ECMA_NUMBER_SQRT2,\n          ECMA_NUMBER_SQRT_1_2,\n        };\n\n        num = builtin_number_list[curr_property_p->value - ECMA_BUILTIN_NUMBER_MAX];\n      }\n      else\n      {\n        switch (curr_property_p->value)\n        {\n          case ECMA_BUILTIN_NUMBER_POSITIVE_INFINITY:\n          {\n            num = ecma_number_make_infinity (false);\n            break;\n          }\n          case ECMA_BUILTIN_NUMBER_NEGATIVE_INFINITY:\n          {\n            num = ecma_number_make_infinity (true);\n            break;\n          }\n          default:\n          {\n            JERRY_ASSERT (curr_property_p->value == ECMA_BUILTIN_NUMBER_NAN);\n\n            num = ecma_number_make_nan ();\n            break;\n          }\n        }\n      }\n\n      value = ecma_make_number_value (num);\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_STRING:\n    {\n      value = ecma_make_magic_string_value ((lit_magic_string_id_t) curr_property_p->value);\n      break;\n    }\n#if JERRY_ESNEXT\n    case ECMA_BUILTIN_PROPERTY_SYMBOL:\n    {\n      lit_magic_string_id_t symbol_id = (lit_magic_string_id_t) curr_property_p->value;\n\n      value = ecma_make_symbol_value (ecma_op_get_global_symbol (symbol_id));\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_INTRINSIC_PROPERTY:\n    {\n      ecma_object_t *intrinsic_object_p = ecma_builtin_get_from_builtin (object_p, ECMA_BUILTIN_ID_INTRINSIC_OBJECT);\n      value = ecma_op_object_get_by_magic_id (intrinsic_object_p, (lit_magic_string_id_t) curr_property_p->value);\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_ACCESSOR_BUILTIN_FUNCTION:\n    {\n      is_accessor = true;\n      uint16_t getter_id = ECMA_ACCESSOR_READ_WRITE_GET_GETTER_ID (curr_property_p->value);\n      uint16_t setter_id = ECMA_ACCESSOR_READ_WRITE_GET_SETTER_ID (curr_property_p->value);\n      getter_p = ecma_builtin_get_from_builtin (object_p, getter_id);\n      setter_p = ecma_builtin_get_from_builtin (object_p, setter_id);\n      ecma_ref_object (getter_p);\n      ecma_ref_object (setter_p);\n      break;\n    }\n#endif /* JERRY_ESNEXT */\n    case ECMA_BUILTIN_PROPERTY_OBJECT:\n    {\n      ecma_object_t *builtin_object_p;\n      builtin_object_p = ecma_builtin_get_from_builtin (object_p, (ecma_builtin_id_t) curr_property_p->value);\n      ecma_ref_object (builtin_object_p);\n      value = ecma_make_object_value (builtin_object_p);\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_ROUTINE:\n    {\n      ecma_object_t *func_obj_p;\n      func_obj_p = ecma_builtin_make_function_object_for_routine (object_p,\n                                                                  ECMA_GET_ROUTINE_ID (curr_property_p->value),\n                                                                  index,\n                                                                  ECMA_BUILTIN_ROUTINE_NO_OPTS);\n      value = ecma_make_object_value (func_obj_p);\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_ACCESSOR_READ_WRITE:\n    {\n      is_accessor = true;\n      uint8_t getter_id = ECMA_ACCESSOR_READ_WRITE_GET_GETTER_ID (curr_property_p->value);\n      uint8_t setter_id = ECMA_ACCESSOR_READ_WRITE_GET_SETTER_ID (curr_property_p->value);\n      getter_p = ecma_builtin_make_function_object_for_getter_accessor (object_p, getter_id, index);\n      setter_p = ecma_builtin_make_function_object_for_setter_accessor (object_p, setter_id, index);\n      break;\n    }\n    default:\n    {\n      JERRY_ASSERT (curr_property_p->type == ECMA_BUILTIN_PROPERTY_ACCESSOR_READ_ONLY);\n\n      is_accessor = true;\n      uint8_t getter_id = (uint8_t) curr_property_p->value;\n      getter_p = ecma_builtin_make_function_object_for_getter_accessor (object_p, getter_id, index);\n      break;\n    }\n  }\n\n  ecma_property_t *prop_p;\n\n  JERRY_ASSERT (curr_property_p->attributes & ECMA_PROPERTY_FLAG_BUILT_IN);\n\n  if (is_accessor)\n  {\n    ecma_create_named_accessor_property (object_p,\n                                         property_name_p,\n                                         getter_p,\n                                         setter_p,\n                                         curr_property_p->attributes,\n                                         &prop_p);\n\n    if (setter_p)\n    {\n      ecma_deref_object (setter_p);\n    }\n    if (getter_p)\n    {\n      ecma_deref_object (getter_p);\n    }\n  }\n  else\n  {\n    ecma_property_value_t *prop_value_p = ecma_create_named_data_property (object_p,\n                                                                           property_name_p,\n                                                                           curr_property_p->attributes,\n                                                                           &prop_p);\n    prop_value_p->value = value;\n\n    /* Reference count of objects must be decreased. */\n    ecma_deref_if_object (value);\n  }\n\n  return prop_p;\n}",
        "begin_line": 995,
        "end_line": 1250,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_instantiate_builtin#357",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_instantiate_builtin (ecma_global_object_t *global_object_p, /**< global object */                           ecma_builtin_id_t obj_builtin_id) /**< built-in id */",
        "snippet": "static ecma_object_t *\necma_instantiate_builtin (ecma_global_object_t *global_object_p, /**< global object */\n                          ecma_builtin_id_t obj_builtin_id) /**< built-in id */\n{\n  jmem_cpointer_t *builtin_objects = global_object_p->builtin_objects;\n\n  JERRY_ASSERT (obj_builtin_id < ECMA_BUILTIN_OBJECTS_COUNT);\n  JERRY_ASSERT (builtin_objects[obj_builtin_id] == JMEM_CP_NULL);\n\n  ecma_builtin_descriptor_t builtin_desc = ecma_builtin_descriptors[obj_builtin_id];\n  ecma_builtin_id_t object_prototype_builtin_id = (ecma_builtin_id_t) (builtin_desc >> ECMA_BUILTIN_PROTOTYPE_ID_SHIFT);\n\n  ecma_object_t *prototype_obj_p;\n\n  if (JERRY_UNLIKELY (object_prototype_builtin_id == ECMA_BUILTIN_ID__COUNT))\n  {\n    prototype_obj_p = NULL;\n  }\n  else\n  {\n    if (builtin_objects[object_prototype_builtin_id] == JMEM_CP_NULL)\n    {\n      ecma_instantiate_builtin (global_object_p, object_prototype_builtin_id);\n    }\n    prototype_obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, builtin_objects[object_prototype_builtin_id]);\n    JERRY_ASSERT (prototype_obj_p != NULL);\n  }\n\n  ecma_object_type_t obj_type = (ecma_object_type_t) (builtin_desc & ECMA_BUILTIN_OBJECT_TYPE_MASK);\n\n  JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_GENERAL\n                || obj_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS\n                || obj_type == ECMA_OBJECT_TYPE_BUILT_IN_ARRAY\n                || obj_type == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);\n\n  bool is_extended_built_in = ECMA_BUILTIN_IS_EXTENDED_BUILT_IN (obj_type);\n\n  size_t ext_object_size = (is_extended_built_in ? sizeof (ecma_extended_built_in_object_t)\n                                                 : sizeof (ecma_extended_object_t));\n\n  size_t property_count = ecma_builtin_get_property_count (obj_builtin_id);\n\n  if (property_count > ECMA_BUILTIN_INSTANTIATED_BITSET_MIN_SIZE)\n  {\n    /* Only 64 extra properties supported at the moment.\n     * This can be extended to 256 later. */\n    JERRY_ASSERT (property_count <= (ECMA_BUILTIN_INSTANTIATED_BITSET_MIN_SIZE + 64));\n\n    ext_object_size += sizeof (uint64_t);\n  }\n\n  ecma_object_t *obj_p = ecma_create_object (prototype_obj_p, ext_object_size, obj_type);\n\n  if (JERRY_UNLIKELY (obj_builtin_id == ECMA_BUILTIN_ID_TYPE_ERROR_THROWER))\n  {\n    ecma_op_ordinary_object_prevent_extensions (obj_p);\n  }\n  else\n  {\n    ecma_op_ordinary_object_set_extensible (obj_p);\n  }\n\n  /*\n   * [[Class]] property of built-in object is not stored explicitly.\n   *\n   * See also: ecma_object_get_class_name\n   */\n\n  ecma_built_in_props_t *built_in_props_p;\n\n  if (is_extended_built_in)\n  {\n    built_in_props_p = &((ecma_extended_built_in_object_t *) obj_p)->built_in;\n  }\n  else\n  {\n    built_in_props_p = &((ecma_extended_object_t *) obj_p)->u.built_in;\n  }\n\n  built_in_props_p->id = (uint8_t) obj_builtin_id;\n  built_in_props_p->routine_id = 0;\n  built_in_props_p->u.length_and_bitset_size = 0;\n  built_in_props_p->u2.instantiated_bitset[0] = 0;\n#if JERRY_BUILTIN_REALMS\n  ECMA_SET_INTERNAL_VALUE_POINTER (built_in_props_p->realm_value, global_object_p);\n#else /* !JERRY_BUILTIN_REALMS */\n  built_in_props_p->continue_instantiated_bitset[0] = 0;\n#endif /* JERRY_BUILTIN_REALMS */\n\n  if (property_count > ECMA_BUILTIN_INSTANTIATED_BITSET_MIN_SIZE)\n  {\n    built_in_props_p->u.length_and_bitset_size = 1 << ECMA_BUILT_IN_BITSET_SHIFT;\n\n    uint32_t *instantiated_bitset_p = (uint32_t *) (built_in_props_p + 1);\n    instantiated_bitset_p[0] = 0;\n    instantiated_bitset_p[1] = 0;\n  }\n\n  /** Initializing [[PrimitiveValue]] properties of built-in prototype objects */\n  switch (obj_builtin_id)\n  {\n#if JERRY_BUILTIN_ARRAY\n    case ECMA_BUILTIN_ID_ARRAY_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_ARRAY);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.array.length = 0;\n      ext_object_p->u.array.length_prop_and_hole_count = ECMA_PROPERTY_FLAG_WRITABLE | ECMA_PROPERTY_VIRTUAL;\n      break;\n    }\n#endif /* JERRY_BUILTIN_ARRAY */\n\n#if JERRY_BUILTIN_STRING\n    case ECMA_BUILTIN_ID_STRING_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_STRING;\n      ext_object_p->u.cls.u3.value = ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);\n      break;\n    }\n#endif /* JERRY_BUILTIN_STRING */\n\n#if JERRY_BUILTIN_NUMBER\n    case ECMA_BUILTIN_ID_NUMBER_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_NUMBER;\n      ext_object_p->u.cls.u3.value = ecma_make_integer_value (0);\n      break;\n    }\n#endif /* JERRY_BUILTIN_NUMBER */\n\n#if JERRY_BUILTIN_BOOLEAN\n    case ECMA_BUILTIN_ID_BOOLEAN_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_BOOLEAN;\n      ext_object_p->u.cls.u3.value = ECMA_VALUE_FALSE;\n      break;\n    }\n#endif /* JERRY_BUILTIN_BOOLEAN */\n\n#if !JERRY_ESNEXT\n#if JERRY_BUILTIN_DATE\n    case ECMA_BUILTIN_ID_DATE_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_DATE;\n\n      ecma_number_t *prim_prop_num_value_p = ecma_alloc_number ();\n      *prim_prop_num_value_p = ecma_number_make_nan ();\n      ECMA_SET_INTERNAL_VALUE_POINTER (ext_object_p->u.cls.u3.value, prim_prop_num_value_p);\n      break;\n    }\n#endif /* JERRY_BUILTIN_DATE */\n\n#if JERRY_BUILTIN_REGEXP\n    case ECMA_BUILTIN_ID_REGEXP_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_REGEXP;\n\n      re_compiled_code_t *bc_p = re_compile_bytecode (ecma_get_magic_string (LIT_MAGIC_STRING_EMPTY_NON_CAPTURE_GROUP),\n                                                      RE_FLAG_EMPTY);\n\n      JERRY_ASSERT (bc_p != NULL);\n\n      ECMA_SET_INTERNAL_VALUE_POINTER (ext_object_p->u.cls.u3.value, bc_p);\n      break;\n    }\n#endif /* JERRY_BUILTIN_REGEXP */\n#endif /* !JERRY_ESNEXT */\n    default:\n    {\n      JERRY_ASSERT (obj_type != ECMA_OBJECT_TYPE_BUILT_IN_CLASS);\n      break;\n    }\n  }\n\n  ECMA_SET_NON_NULL_POINTER (builtin_objects[obj_builtin_id], obj_p);\n  ecma_deref_object (obj_p);\n  return obj_p;\n}",
        "begin_line": 357,
        "end_line": 550,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-array-object.ecma_array_get_length#1203",
        "src_path": "jerry-core/ecma/operations/ecma-array-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-array-object",
        "signature": "jerry-core.ecma.operations.ecma-array-object.ecma_array_get_length (ecma_object_t *array_p) /**< array object */",
        "snippet": "extern inline uint32_t JERRY_ATTR_ALWAYS_INLINE\necma_array_get_length (ecma_object_t *array_p) /**< array object */\n{\n  JERRY_ASSERT (ecma_get_object_base_type (array_p) == ECMA_OBJECT_BASE_TYPE_ARRAY);\n\n  return ((ecma_extended_object_t *) array_p)->u.array.length;\n}",
        "begin_line": 1203,
        "end_line": 1209,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-array-object.ecma_delete_array_properties#822",
        "src_path": "jerry-core/ecma/operations/ecma-array-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-array-object",
        "signature": "jerry-core.ecma.operations.ecma-array-object.ecma_delete_array_properties (ecma_object_t *object_p, /**< object */                               uint32_t new_length, /**< new length */                               uint32_t old_length) /**< old length */",
        "snippet": "static uint32_t\necma_delete_array_properties (ecma_object_t *object_p, /**< object */\n                              uint32_t new_length, /**< new length */\n                              uint32_t old_length) /**< old length */\n{\n  JERRY_ASSERT (new_length < old_length);\n  JERRY_ASSERT (ecma_get_object_base_type (object_p) == ECMA_OBJECT_BASE_TYPE_ARRAY);\n\n  if (ecma_op_object_is_fast_array (object_p))\n  {\n    return ecma_delete_fast_array_properties (object_p, new_length);\n  }\n\n  /* First the minimum value of new_length is updated. */\n  jmem_cpointer_t current_prop_cp = object_p->u1.property_list_cp;\n\n  if (current_prop_cp == JMEM_CP_NULL)\n  {\n    return new_length;\n  }\n\n  ecma_property_header_t *current_prop_p;\n\n#if JERRY_PROPERTY_HASHMAP\n  current_prop_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, current_prop_cp);\n\n  if (current_prop_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n  {\n    current_prop_cp = current_prop_p->next_property_cp;\n  }\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n  while (current_prop_cp != JMEM_CP_NULL)\n  {\n    current_prop_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, current_prop_cp);\n    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (current_prop_p));\n\n    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) current_prop_p;\n\n    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)\n    {\n      if (current_prop_p->types[i] != ECMA_PROPERTY_TYPE_DELETED\n          && !ecma_is_property_configurable (current_prop_p->types[i]))\n      {\n        uint32_t index = ecma_string_get_property_index (current_prop_p->types[i],\n                                                         prop_pair_p->names_cp[i]);\n\n        if (index < old_length && index >= new_length)\n        {\n          JERRY_ASSERT (index != ECMA_STRING_NOT_ARRAY_INDEX);\n\n          new_length = index + 1;\n\n          if (new_length == old_length)\n          {\n            /* Early return. */\n            return new_length;\n          }\n        }\n      }\n    }\n\n    current_prop_cp = current_prop_p->next_property_cp;\n  }\n\n  /* Second all properties between new_length and old_length are deleted. */\n  current_prop_cp = object_p->u1.property_list_cp;\n  ecma_property_header_t *prev_prop_p = NULL;\n\n#if JERRY_PROPERTY_HASHMAP\n  JERRY_ASSERT (current_prop_cp != JMEM_CP_NULL);\n\n  ecma_property_hashmap_delete_status hashmap_status = ECMA_PROPERTY_HASHMAP_DELETE_NO_HASHMAP;\n  current_prop_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, current_prop_cp);\n\n  if (current_prop_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n  {\n    prev_prop_p = current_prop_p;\n    current_prop_cp = current_prop_p->next_property_cp;\n    hashmap_status = ECMA_PROPERTY_HASHMAP_DELETE_HAS_HASHMAP;\n  }\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n  while (current_prop_cp != JMEM_CP_NULL)\n  {\n    current_prop_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, current_prop_cp);\n\n    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (current_prop_p));\n    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) current_prop_p;\n\n    for (uint32_t i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)\n    {\n      if (current_prop_p->types[i] != ECMA_PROPERTY_TYPE_DELETED\n          && ecma_is_property_configurable (current_prop_p->types[i]))\n      {\n        uint32_t index = ecma_string_get_property_index (current_prop_p->types[i],\n                                                         prop_pair_p->names_cp[i]);\n\n        if (index < old_length && index >= new_length)\n        {\n          JERRY_ASSERT (index != ECMA_STRING_NOT_ARRAY_INDEX);\n\n#if JERRY_PROPERTY_HASHMAP\n          if (hashmap_status == ECMA_PROPERTY_HASHMAP_DELETE_HAS_HASHMAP)\n          {\n            hashmap_status = ecma_property_hashmap_delete (object_p,\n                                                           prop_pair_p->names_cp[i],\n                                                           current_prop_p->types + i);\n          }\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n          ecma_gc_free_property (object_p, prop_pair_p, i);\n          current_prop_p->types[i] = ECMA_PROPERTY_TYPE_DELETED;\n          prop_pair_p->names_cp[i] = LIT_INTERNAL_MAGIC_STRING_DELETED;\n        }\n      }\n    }\n\n    if (current_prop_p->types[0] == ECMA_PROPERTY_TYPE_DELETED\n        && current_prop_p->types[1] == ECMA_PROPERTY_TYPE_DELETED)\n    {\n      if (prev_prop_p == NULL)\n      {\n        object_p->u1.property_list_cp = current_prop_p->next_property_cp;\n      }\n      else\n      {\n        prev_prop_p->next_property_cp = current_prop_p->next_property_cp;\n      }\n\n      jmem_cpointer_t next_prop_cp = current_prop_p->next_property_cp;\n      ecma_dealloc_property_pair ((ecma_property_pair_t *) current_prop_p);\n      current_prop_cp = next_prop_cp;\n    }\n    else\n    {\n      prev_prop_p = current_prop_p;\n      current_prop_cp = current_prop_p->next_property_cp;\n    }\n  }\n\n#if JERRY_PROPERTY_HASHMAP\n  if (hashmap_status == ECMA_PROPERTY_HASHMAP_DELETE_RECREATE_HASHMAP)\n  {\n    ecma_property_hashmap_free (object_p);\n    ecma_property_hashmap_create (object_p);\n  }\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n  return new_length;\n}",
        "begin_line": 822,
        "end_line": 972,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-array-object.ecma_delete_fast_array_properties#546",
        "src_path": "jerry-core/ecma/operations/ecma-array-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-array-object",
        "signature": "jerry-core.ecma.operations.ecma-array-object.ecma_delete_fast_array_properties (ecma_object_t *object_p, /**< fast access mode array */                                    uint32_t new_length) /**< new length of the fast access mode array */",
        "snippet": "uint32_t\necma_delete_fast_array_properties (ecma_object_t *object_p, /**< fast access mode array */\n                                   uint32_t new_length) /**< new length of the fast access mode array */\n{\n  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));\n\n  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;\n\n  ecma_ref_object (object_p);\n  ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);\n\n  uint32_t old_length = ext_obj_p->u.array.length;\n  const uint32_t old_aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (old_length);\n  JERRY_ASSERT (new_length < old_length);\n\n  for (uint32_t i = new_length; i < old_length; i++)\n  {\n    if (ecma_is_value_array_hole (values_p[i]))\n    {\n      ext_obj_p->u.array.length_prop_and_hole_count -= ECMA_FAST_ARRAY_HOLE_ONE;\n    }\n    else\n    {\n      ecma_free_value_if_not_object (values_p[i]);\n    }\n  }\n\n  jmem_cpointer_t new_property_list_cp;\n\n  if (new_length == 0)\n  {\n    jmem_heap_free_block (values_p, old_aligned_length * sizeof (ecma_value_t));\n    new_property_list_cp = JMEM_CP_NULL;\n  }\n  else\n  {\n    const uint32_t new_aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (new_length);\n\n    ecma_value_t *new_values_p;\n    new_values_p = (ecma_value_t *) jmem_heap_realloc_block (values_p,\n                                                             old_aligned_length * sizeof (ecma_value_t),\n                                                             new_aligned_length * sizeof (ecma_value_t));\n\n    for (uint32_t i = new_length; i < new_aligned_length; i++)\n    {\n      new_values_p[i] = ECMA_VALUE_ARRAY_HOLE;\n    }\n\n    ECMA_SET_NON_NULL_POINTER (new_property_list_cp, new_values_p);\n  }\n\n  ext_obj_p->u.array.length = new_length;\n  object_p->u1.property_list_cp = new_property_list_cp;\n\n  ecma_deref_object (object_p);\n\n  return new_length;\n}",
        "begin_line": 546,
        "end_line": 603,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-array-object.ecma_fast_array_extend#458",
        "src_path": "jerry-core/ecma/operations/ecma-array-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-array-object",
        "signature": "jerry-core.ecma.operations.ecma-array-object.ecma_fast_array_extend (ecma_object_t *object_p, /**< fast access mode array object */                         uint32_t new_length) /**< new length of the fast access mode array */",
        "snippet": "ecma_value_t *\necma_fast_array_extend (ecma_object_t *object_p, /**< fast access mode array object */\n                        uint32_t new_length) /**< new length of the fast access mode array */\n{\n  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));\n  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;\n  uint32_t old_length = ext_obj_p->u.array.length;\n\n  JERRY_ASSERT (old_length < new_length);\n\n  ecma_ref_object (object_p);\n\n  ecma_value_t *new_values_p;\n  const uint32_t old_length_aligned = ECMA_FAST_ARRAY_ALIGN_LENGTH (old_length);\n  const uint32_t new_length_aligned = ECMA_FAST_ARRAY_ALIGN_LENGTH (new_length);\n\n  if (object_p->u1.property_list_cp == JMEM_CP_NULL)\n  {\n    new_values_p = jmem_heap_alloc_block (new_length_aligned * sizeof (ecma_value_t));\n  }\n  else\n  {\n    ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);\n    new_values_p = (ecma_value_t *) jmem_heap_realloc_block (values_p,\n                                                             old_length_aligned * sizeof (ecma_value_t),\n                                                             new_length_aligned * sizeof (ecma_value_t));\n  }\n\n  for (uint32_t i = old_length; i < new_length_aligned; i++)\n  {\n    new_values_p[i] = ECMA_VALUE_ARRAY_HOLE;\n  }\n\n  ext_obj_p->u.array.length_prop_and_hole_count += (new_length - old_length) * ECMA_FAST_ARRAY_HOLE_ONE;\n  ext_obj_p->u.array.length = new_length;\n\n  ECMA_SET_NON_NULL_POINTER (object_p->u1.property_list_cp, new_values_p);\n\n  ecma_deref_object (object_p);\n  return new_values_p;\n}",
        "begin_line": 458,
        "end_line": 498,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-array-object.ecma_op_alloc_array_object#65",
        "src_path": "jerry-core/ecma/operations/ecma-array-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-array-object",
        "signature": "jerry-core.ecma.operations.ecma-array-object.ecma_op_alloc_array_object (uint32_t length) /**< length of the new array */",
        "snippet": "static ecma_object_t *\necma_op_alloc_array_object (uint32_t length) /**< length of the new array */\n{\n#if JERRY_BUILTIN_ARRAY\n  ecma_object_t *array_prototype_object_p = ecma_builtin_get (ECMA_BUILTIN_ID_ARRAY_PROTOTYPE);\n#else /* !JERRY_BUILTIN_ARRAY */\n  ecma_object_t *array_prototype_object_p = ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);\n#endif /* JERRY_BUILTIN_ARRAY */\n\n  ecma_object_t *object_p = ecma_create_object (array_prototype_object_p,\n                                                sizeof (ecma_extended_object_t),\n                                                ECMA_OBJECT_TYPE_ARRAY);\n\n  /*\n   * [[Class]] property is not stored explicitly for objects of ECMA_OBJECT_TYPE_ARRAY type.\n   *\n   * See also: ecma_object_get_class_name\n   */\n\n  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;\n  ext_obj_p->u.array.length = length;\n  ext_obj_p->u.array.length_prop_and_hole_count = ECMA_PROPERTY_FLAG_WRITABLE | ECMA_PROPERTY_VIRTUAL;\n\n  return object_p;\n}",
        "begin_line": 65,
        "end_line": 89,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-array-object.ecma_op_array_is_fast_array#110",
        "src_path": "jerry-core/ecma/operations/ecma-array-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-array-object",
        "signature": "jerry-core.ecma.operations.ecma-array-object.ecma_op_array_is_fast_array (ecma_extended_object_t *array_p) /**< ecma-array-object */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\necma_op_array_is_fast_array (ecma_extended_object_t *array_p) /**< ecma-array-object */\n{\n  JERRY_ASSERT (ecma_get_object_base_type ((ecma_object_t *) array_p) == ECMA_OBJECT_BASE_TYPE_ARRAY);\n\n  return array_p->u.array.length_prop_and_hole_count & ECMA_FAST_ARRAY_FLAG;\n}",
        "begin_line": 110,
        "end_line": 116,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-array-object.ecma_op_array_object_set_length#980",
        "src_path": "jerry-core/ecma/operations/ecma-array-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-array-object",
        "signature": "jerry-core.ecma.operations.ecma-array-object.ecma_op_array_object_set_length (ecma_object_t *object_p, /**< the array object */                                  ecma_value_t new_value, /**< new length value */                                  uint16_t flags) /**< property descriptor flags */",
        "snippet": "ecma_value_t\necma_op_array_object_set_length (ecma_object_t *object_p, /**< the array object */\n                                 ecma_value_t new_value, /**< new length value */\n                                 uint16_t flags) /**< property descriptor flags */\n{\n  ecma_number_t new_len_num;\n  ecma_value_t completion = ecma_op_to_number (new_value, &new_len_num);\n\n  if (ECMA_IS_VALUE_ERROR (completion))\n  {\n    return completion;\n  }\n\n  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (completion));\n\n  if (ecma_is_value_object (new_value))\n  {\n    ecma_value_t compared_num_val = ecma_op_to_number (new_value, &new_len_num);\n\n    if (ECMA_IS_VALUE_ERROR (compared_num_val))\n    {\n      return compared_num_val;\n    }\n  }\n\n  uint32_t new_len_uint32 = ecma_number_to_uint32 (new_len_num);\n\n  if (((ecma_number_t) new_len_uint32) != new_len_num)\n  {\n    return ecma_raise_range_error (ECMA_ERR_MSG (ecma_error_invalid_array_length));\n  }\n\n  /* Only the writable and data properties can be modified. */\n  if (flags & (JERRY_PROP_IS_CONFIGURABLE\n               | JERRY_PROP_IS_ENUMERABLE\n               | JERRY_PROP_IS_GET_DEFINED\n               | JERRY_PROP_IS_SET_DEFINED))\n  {\n    return ecma_raise_property_redefinition (ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH), flags);\n  }\n\n  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n  uint32_t old_len_uint32 = ext_object_p->u.array.length;\n\n  if (new_len_num == old_len_uint32)\n  {\n    /* Only the writable flag must be updated. */\n    if (flags & JERRY_PROP_IS_WRITABLE_DEFINED)\n    {\n      if (!(flags & JERRY_PROP_IS_WRITABLE))\n      {\n        if (ecma_op_array_is_fast_array (ext_object_p))\n        {\n          ecma_fast_array_convert_to_normal (object_p);\n        }\n\n        ext_object_p->u.array.length_prop_and_hole_count &= (uint32_t) ~ECMA_PROPERTY_FLAG_WRITABLE;\n      }\n      else if (!ecma_is_property_writable ((ecma_property_t) ext_object_p->u.array.length_prop_and_hole_count))\n      {\n        return ecma_raise_property_redefinition (ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH), flags);\n      }\n    }\n    return ECMA_VALUE_TRUE;\n  }\n  else if (!ecma_is_property_writable ((ecma_property_t) ext_object_p->u.array.length_prop_and_hole_count))\n  {\n    return ecma_raise_property_redefinition (ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH), flags);\n  }\n\n  uint32_t current_len_uint32 = new_len_uint32;\n\n  if (new_len_uint32 < old_len_uint32)\n  {\n    current_len_uint32 = ecma_delete_array_properties (object_p, new_len_uint32, old_len_uint32);\n  }\n  else if (ecma_op_object_is_fast_array (object_p))\n  {\n    ecma_fast_array_set_length (object_p, new_len_uint32);\n  }\n\n  ext_object_p->u.array.length = current_len_uint32;\n\n  if ((flags & JERRY_PROP_IS_WRITABLE_DEFINED)\n      && !(flags & JERRY_PROP_IS_WRITABLE))\n  {\n    if (ecma_op_array_is_fast_array (ext_object_p))\n    {\n      ecma_fast_array_convert_to_normal (object_p);\n    }\n\n    ext_object_p->u.array.length_prop_and_hole_count &= (uint32_t) ~ECMA_PROPERTY_FLAG_WRITABLE;\n  }\n\n  if (current_len_uint32 == new_len_uint32)\n  {\n    return ECMA_VALUE_TRUE;\n  }\n\n  return ecma_raise_property_redefinition (ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH), flags);\n}",
        "begin_line": 980,
        "end_line": 1081,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-array-object.ecma_op_array_species_create#699",
        "src_path": "jerry-core/ecma/operations/ecma-array-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-array-object",
        "signature": "jerry-core.ecma.operations.ecma-array-object.ecma_op_array_species_create (ecma_object_t *original_array_p, /**< The object from whom the new array object                                                                 *   is being created */                               ecma_length_t length) /**< length of the array */",
        "snippet": "ecma_object_t *\necma_op_array_species_create (ecma_object_t *original_array_p, /**< The object from whom the new array object\n                                                                *   is being created */\n                              ecma_length_t length) /**< length of the array */\n{\n  ecma_value_t constructor = ECMA_VALUE_UNDEFINED;\n  ecma_value_t original_array = ecma_make_object_value (original_array_p);\n\n  ecma_value_t is_array = ecma_is_value_array (original_array);\n\n  if (ECMA_IS_VALUE_ERROR (is_array))\n  {\n    return NULL;\n  }\n\n  if (ecma_is_value_true (is_array))\n  {\n    constructor = ecma_op_object_get_by_magic_id (original_array_p, LIT_MAGIC_STRING_CONSTRUCTOR);\n    if (ECMA_IS_VALUE_ERROR (constructor))\n    {\n      return NULL;\n    }\n\n#if JERRY_BUILTIN_REALMS\n    if (ecma_is_constructor (constructor))\n    {\n      ecma_object_t *constructor_p = ecma_get_object_from_value (constructor);\n      ecma_global_object_t *global_object_p = ecma_op_function_get_function_realm (constructor_p);\n\n      if ((ecma_object_t *) global_object_p != ecma_builtin_get_global ()\n          && constructor_p == ecma_builtin_get_from_realm (global_object_p, ECMA_BUILTIN_ID_ARRAY))\n      {\n        ecma_deref_object (constructor_p);\n        constructor = ECMA_VALUE_UNDEFINED;\n      }\n    }\n#endif /* JERRY_BUILTIN_REALMS */\n\n    if (ecma_is_value_object (constructor))\n    {\n      ecma_object_t *ctor_object_p = ecma_get_object_from_value (constructor);\n      constructor = ecma_op_object_get_by_symbol_id (ctor_object_p, LIT_GLOBAL_SYMBOL_SPECIES);\n      ecma_deref_object (ctor_object_p);\n\n      if (ECMA_IS_VALUE_ERROR (constructor))\n      {\n        return NULL;\n      }\n\n      if (ecma_is_value_null (constructor))\n      {\n        constructor = ECMA_VALUE_UNDEFINED;\n      }\n    }\n  }\n\n  if (ecma_is_value_undefined (constructor))\n  {\n    return ecma_op_new_array_object_from_length (length);\n  }\n\n  if (!ecma_is_constructor (constructor))\n  {\n    ecma_free_value (constructor);\n    ecma_raise_type_error (ECMA_ERR_MSG (\"Invalid species constructor\"));\n    return NULL;\n  }\n\n  ecma_value_t len_val = ecma_make_length_value (length);\n  ecma_object_t *ctor_object_p = ecma_get_object_from_value (constructor);\n  ecma_value_t ret_val = ecma_op_function_construct (ctor_object_p,\n                                                     ctor_object_p,\n                                                     &len_val,\n                                                     1);\n\n  ecma_deref_object (ctor_object_p);\n  ecma_free_value (len_val);\n\n  if (ECMA_IS_VALUE_ERROR (ret_val))\n  {\n    return NULL;\n  }\n\n  return ecma_get_object_from_value (ret_val);\n}",
        "begin_line": 699,
        "end_line": 783,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-array-object.ecma_op_new_array_object#125",
        "src_path": "jerry-core/ecma/operations/ecma-array-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-array-object",
        "signature": "jerry-core.ecma.operations.ecma-array-object.ecma_op_new_array_object (uint32_t length) /**< length of the new array */",
        "snippet": "ecma_object_t *\necma_op_new_array_object (uint32_t length) /**< length of the new array */\n{\n  ecma_object_t *object_p = ecma_op_alloc_array_object (length);\n\n  const uint32_t aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (length);\n  ecma_value_t *values_p = NULL;\n\n  if (length > 0)\n  {\n    if (length >= ECMA_FAST_ARRAY_MAX_INITIAL_LENGTH)\n    {\n      return object_p;\n    }\n\n    values_p = (ecma_value_t *) jmem_heap_alloc_block_null_on_error (aligned_length * sizeof (ecma_value_t));\n\n    if (JERRY_UNLIKELY (values_p == NULL))\n    {\n      return object_p;\n    }\n  }\n\n  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;\n  ext_obj_p->u.array.length_prop_and_hole_count |= ECMA_FAST_ARRAY_FLAG;\n  ext_obj_p->u.array.length_prop_and_hole_count += length * ECMA_FAST_ARRAY_HOLE_ONE;\n\n  for (uint32_t i = 0; i < aligned_length; i++)\n  {\n    values_p[i] = ECMA_VALUE_ARRAY_HOLE;\n  }\n\n  JERRY_ASSERT (object_p->u1.property_list_cp == JMEM_CP_NULL);\n  ECMA_SET_POINTER (object_p->u1.property_list_cp, values_p);\n  return object_p;\n}",
        "begin_line": 125,
        "end_line": 160,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-array-object.ecma_op_object_is_fast_array#97",
        "src_path": "jerry-core/ecma/operations/ecma-array-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-array-object",
        "signature": "jerry-core.ecma.operations.ecma-array-object.ecma_op_object_is_fast_array (ecma_object_t *object_p) /**< ecma-object */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\necma_op_object_is_fast_array (ecma_object_t *object_p) /**< ecma-object */\n{\n  return (ecma_get_object_base_type (object_p) == ECMA_OBJECT_BASE_TYPE_ARRAY &&\n          ecma_op_array_is_fast_array ((ecma_extended_object_t *) object_p));\n}",
        "begin_line": 97,
        "end_line": 102,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-conversion.ecma_op_to_integer#931",
        "src_path": "jerry-core/ecma/operations/ecma-conversion.c",
        "class_name": "jerry-core.ecma.operations.ecma-conversion",
        "signature": "jerry-core.ecma.operations.ecma-conversion.ecma_op_to_integer (ecma_value_t value, /**< ecma value */                     ecma_number_t *number_p) /**< [out] ecma number */",
        "snippet": "ecma_value_t\necma_op_to_integer (ecma_value_t value, /**< ecma value */\n                    ecma_number_t *number_p) /**< [out] ecma number */\n{\n  if (ECMA_IS_VALUE_ERROR (value))\n  {\n    return value;\n  }\n\n  /* 1 */\n  ecma_value_t to_number = ecma_op_to_number (value, number_p);\n\n  /* 2 */\n  if (ECMA_IS_VALUE_ERROR (to_number))\n  {\n    return to_number;\n  }\n\n  ecma_number_t number = *number_p;\n\n  /* 3 */\n  if (ecma_number_is_nan (number))\n  {\n    *number_p = ECMA_NUMBER_ZERO;\n    return ECMA_VALUE_EMPTY;\n  }\n\n  /* 4 */\n  if (ecma_number_is_zero (number) || ecma_number_is_infinity (number))\n  {\n    return ECMA_VALUE_EMPTY;\n  }\n\n  ecma_number_t floor_fabs = (ecma_number_t) floor (fabs (number));\n  /* 5 */\n  *number_p = ecma_number_is_negative (number) ? -floor_fabs : floor_fabs;\n  return ECMA_VALUE_EMPTY;\n}",
        "begin_line": 931,
        "end_line": 968,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-conversion.ecma_op_to_number#277",
        "src_path": "jerry-core/ecma/operations/ecma-conversion.c",
        "class_name": "jerry-core.ecma.operations.ecma-conversion",
        "signature": "jerry-core.ecma.operations.ecma-conversion.ecma_op_to_number (ecma_value_t value, /**< ecma value */                    ecma_number_t *number_p) /**< [out] ecma number */",
        "snippet": "extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE\necma_op_to_number (ecma_value_t value, /**< ecma value */\n                   ecma_number_t *number_p) /**< [out] ecma number */\n{\n  return ecma_op_to_numeric (value, number_p, ECMA_TO_NUMERIC_NO_OPTS);\n}",
        "begin_line": 277,
        "end_line": 282,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-conversion.ecma_op_to_numeric#294",
        "src_path": "jerry-core/ecma/operations/ecma-conversion.c",
        "class_name": "jerry-core.ecma.operations.ecma-conversion",
        "signature": "jerry-core.ecma.operations.ecma-conversion.ecma_op_to_numeric (ecma_value_t value, /**< ecma value */                     ecma_number_t *number_p, /**< [out] ecma number */                     ecma_to_numeric_options_t options) /**< option bits */",
        "snippet": "ecma_value_t\necma_op_to_numeric (ecma_value_t value, /**< ecma value */\n                    ecma_number_t *number_p, /**< [out] ecma number */\n                    ecma_to_numeric_options_t options) /**< option bits */\n{\n  JERRY_UNUSED (options);\n\n  if (ecma_is_value_integer_number (value))\n  {\n    *number_p = (ecma_number_t) ecma_get_integer_from_value (value);\n    return ECMA_VALUE_EMPTY;\n  }\n\n  if (ecma_is_value_float_number (value))\n  {\n    *number_p = ecma_get_float_from_value (value);\n    return ECMA_VALUE_EMPTY;\n  }\n\n  if (ecma_is_value_string (value))\n  {\n    ecma_string_t *str_p = ecma_get_string_from_value (value);\n    *number_p = ecma_string_to_number (str_p);\n    return ECMA_VALUE_EMPTY;\n  }\n\n  if (ecma_is_value_undefined (value))\n  {\n    *number_p = ecma_number_make_nan ();\n    return ECMA_VALUE_EMPTY;\n  }\n\n  if (ecma_is_value_null (value))\n  {\n    *number_p = 0;\n    return ECMA_VALUE_EMPTY;\n  }\n\n  if (ecma_is_value_true (value))\n  {\n    *number_p = 1;\n    return ECMA_VALUE_EMPTY;\n  }\n\n  if (ecma_is_value_false (value))\n  {\n    *number_p = 0;\n    return ECMA_VALUE_EMPTY;\n  }\n\n#if JERRY_ESNEXT\n  if (ecma_is_value_symbol (value))\n  {\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Cannot convert a Symbol value to a number\"));\n  }\n#endif /* JERRY_ESNEXT */\n\n#if JERRY_BUILTIN_BIGINT\n  if (ecma_is_value_bigint (value))\n  {\n    if (options & ECMA_TO_NUMERIC_ALLOW_BIGINT)\n    {\n      return ecma_copy_value (value);\n    }\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Cannot convert a BigInt value to a number\"));\n  }\n#endif /* JERRY_BUILTIN_BIGINT */\n\n  JERRY_ASSERT (ecma_is_value_object (value));\n\n  ecma_object_t *object_p = ecma_get_object_from_value (value);\n\n  ecma_value_t def_value = ecma_op_object_default_value (object_p, ECMA_PREFERRED_TYPE_NUMBER);\n\n  if (ECMA_IS_VALUE_ERROR (def_value))\n  {\n    return def_value;\n  }\n\n  ecma_value_t ret_value = ecma_op_to_numeric (def_value, number_p, options);\n\n  ecma_fast_free_value (def_value);\n\n  return ret_value;\n}",
        "begin_line": 294,
        "end_line": 378,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-conversion.ecma_op_to_object#530",
        "src_path": "jerry-core/ecma/operations/ecma-conversion.c",
        "class_name": "jerry-core.ecma.operations.ecma-conversion",
        "signature": "jerry-core.ecma.operations.ecma-conversion.ecma_op_to_object (ecma_value_t value) /**< ecma value */",
        "snippet": "ecma_value_t\necma_op_to_object (ecma_value_t value) /**< ecma value */\n{\n  ecma_check_value_type_is_spec_defined (value);\n  ecma_builtin_id_t proto_id = ECMA_BUILTIN_ID_OBJECT_PROTOTYPE;\n  uint8_t class_type;\n\n  if (ecma_is_value_number (value))\n  {\n#if JERRY_BUILTIN_NUMBER\n    proto_id =  ECMA_BUILTIN_ID_NUMBER_PROTOTYPE;\n#endif /* JERRY_BUILTIN_NUMBER */\n    class_type = ECMA_OBJECT_CLASS_NUMBER;\n  }\n  else if (ecma_is_value_string (value))\n  {\n#if JERRY_BUILTIN_STRING\n    proto_id = ECMA_BUILTIN_ID_STRING_PROTOTYPE;\n#endif /* JERRY_BUILTIN_STRING */\n    class_type = ECMA_OBJECT_CLASS_STRING;\n  }\n  else if (ecma_is_value_object (value))\n  {\n    return ecma_copy_value (value);\n  }\n#if JERRY_ESNEXT\n  else if (ecma_is_value_symbol (value))\n  {\n    proto_id = ECMA_BUILTIN_ID_SYMBOL_PROTOTYPE;\n    class_type = ECMA_OBJECT_CLASS_SYMBOL;\n  }\n#endif /* JERRY_ESNEXT */\n#if JERRY_BUILTIN_BIGINT\n  else if (ecma_is_value_bigint (value))\n  {\n    return ecma_op_create_bigint_object (value);\n  }\n#endif /* JERRY_BUILTIN_BIGINT */\n  else\n  {\n    if (ecma_is_value_undefined (value)\n        || ecma_is_value_null (value))\n    {\n      return ecma_raise_type_error (ECMA_ERR_MSG (\"Argument cannot be converted to an object\"));\n    }\n    else\n    {\n      JERRY_ASSERT (ecma_is_value_boolean (value));\n#if JERRY_BUILTIN_BOOLEAN\n      proto_id = ECMA_BUILTIN_ID_BOOLEAN_PROTOTYPE;\n#endif /* JERRY_BUILTIN_BOOLEAN */\n      class_type = ECMA_OBJECT_CLASS_BOOLEAN;\n    }\n  }\n\n  ecma_object_t *object_p = ecma_create_object (ecma_builtin_get (proto_id),\n                                                sizeof (ecma_extended_object_t),\n                                                ECMA_OBJECT_TYPE_CLASS);\n\n  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n  ext_object_p->u.cls.type = class_type;\n  ext_object_p->u.cls.u3.value = ecma_copy_value_if_not_object (value);\n\n  return ecma_make_object_value (object_p);\n}",
        "begin_line": 530,
        "end_line": 594,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-conversion.ecma_op_to_property_key#485",
        "src_path": "jerry-core/ecma/operations/ecma-conversion.c",
        "class_name": "jerry-core.ecma.operations.ecma-conversion",
        "signature": "jerry-core.ecma.operations.ecma-conversion.ecma_op_to_property_key (ecma_value_t value) /**< ecma value */",
        "snippet": "ecma_string_t *\necma_op_to_property_key (ecma_value_t value) /**< ecma value */\n{\n  /* Fast path for strings and symbols */\n  if (JERRY_LIKELY (ecma_is_value_prop_name (value)))\n  {\n    ecma_string_t *key_p = ecma_get_prop_name_from_value (value);\n    ecma_ref_ecma_string (key_p);\n    return key_p;\n  }\n\n#if JERRY_ESNEXT\n  ecma_value_t key = ecma_op_to_primitive (value, ECMA_PREFERRED_TYPE_STRING);\n\n  if (ECMA_IS_VALUE_ERROR (key))\n  {\n    return NULL;\n  }\n\n  if (ecma_is_value_symbol (key))\n  {\n    ecma_string_t *symbol_p = ecma_get_symbol_from_value (key);\n    return symbol_p;\n  }\n\n  ecma_string_t *result = ecma_op_to_string (key);\n  ecma_free_value (key);\n\n  return result;\n#else /* !JERRY_ESNEXT */\n  ecma_check_value_type_is_spec_defined (value);\n\n  return ecma_op_to_string (value);\n#endif /* JERRY_ESNEXT */\n}",
        "begin_line": 485,
        "end_line": 519,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_is_constructor#281",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_is_constructor (ecma_value_t value) /**< ecma value */",
        "snippet": "bool\necma_is_constructor (ecma_value_t value) /**< ecma value */\n{\n  return (ecma_is_value_object (value)\n          && ecma_object_is_constructor (ecma_get_object_from_value (value)));\n}",
        "begin_line": 281,
        "end_line": 286,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_object_check_constructor#140",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_object_check_constructor (ecma_object_t *obj_p) /**< ecma object */",
        "snippet": "char *\necma_object_check_constructor (ecma_object_t *obj_p) /**< ecma object */\n{\n  JERRY_ASSERT (!ecma_is_lexical_environment (obj_p));\n\n  ecma_object_type_t type = ecma_get_object_type (obj_p);\n\n  if (JERRY_UNLIKELY (type < ECMA_OBJECT_TYPE_PROXY))\n  {\n    return ECMA_ERR_MSG (\"Invalid type for constructor call\");\n  }\n\n  while (JERRY_UNLIKELY (type == ECMA_OBJECT_TYPE_BOUND_FUNCTION))\n  {\n    ecma_bound_function_t *bound_func_p = (ecma_bound_function_t *) obj_p;\n\n    obj_p = ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t,\n                                                        bound_func_p->header.u.bound_function.target_function);\n\n    type = ecma_get_object_type (obj_p);\n  }\n\n  if (JERRY_LIKELY (type == ECMA_OBJECT_TYPE_FUNCTION))\n  {\n#if JERRY_ESNEXT\n    const ecma_compiled_code_t *byte_code_p = ecma_op_function_get_compiled_code ((ecma_extended_object_t *) obj_p);\n\n    if (!CBC_FUNCTION_IS_CONSTRUCTABLE (byte_code_p->status_flags))\n    {\n#if JERRY_ERROR_MESSAGES\n      switch (CBC_FUNCTION_GET_TYPE (byte_code_p->status_flags))\n      {\n        case CBC_FUNCTION_SCRIPT:\n        {\n          return \"Script (global) functions cannot be invoked with 'new'\";\n        }\n        case CBC_FUNCTION_GENERATOR:\n        {\n          return \"Generator functions cannot be invoked with 'new'\";\n        }\n        case CBC_FUNCTION_ASYNC:\n        {\n          return \"Async functions cannot be invoked with 'new'\";\n        }\n        case CBC_FUNCTION_ASYNC_GENERATOR:\n        {\n          return \"Async generator functions cannot be invoked with 'new'\";\n        }\n        case CBC_FUNCTION_ACCESSOR:\n        {\n          return \"Accessor functions cannot be invoked with 'new'\";\n        }\n        case CBC_FUNCTION_METHOD:\n        {\n          return \"Methods cannot be invoked with 'new'\";\n        }\n        case CBC_FUNCTION_ARROW:\n        {\n          return \"Arrow functions cannot be invoked with 'new'\";\n        }\n        default:\n        {\n          JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (byte_code_p->status_flags) == CBC_FUNCTION_ASYNC_ARROW);\n          return \"Async arrow functions cannot be invoked with 'new'\";\n        }\n      }\n#else /* !JERRY_ERROR_MESSAGES */\n      return NULL;\n#endif /* JERRY_ERROR_MESSAGES */\n    }\n#endif /* JERRY_NEXT */\n\n    return ECMA_IS_VALID_CONSTRUCTOR;\n  }\n\n#if JERRY_BUILTIN_PROXY\n  if (ECMA_OBJECT_TYPE_IS_PROXY (type))\n  {\n    if (!(obj_p->u2.prototype_cp & ECMA_PROXY_IS_CONSTRUCTABLE))\n    {\n      return ECMA_ERR_MSG (\"Proxy target is not a constructor\");\n    }\n\n    return ECMA_IS_VALID_CONSTRUCTOR;\n  }\n#endif /* JERRY_BUILTIN_PROXY */\n\n  JERRY_ASSERT (type == ECMA_OBJECT_TYPE_NATIVE_FUNCTION\n                || type == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION\n                || type == ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION);\n\n  if (type == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION)\n  {\n    if (ecma_builtin_function_is_routine (obj_p))\n    {\n      return ECMA_ERR_MSG (\"Built-in routines have no constructor\");\n    }\n\n#if JERRY_ESNEXT\n    JERRY_ASSERT (((ecma_extended_object_t *) obj_p)->u.built_in.id != ECMA_BUILTIN_ID_HANDLER);\n#endif /* !JERRY_ESNEXT */\n  }\n\n  return ECMA_IS_VALID_CONSTRUCTOR;\n}",
        "begin_line": 140,
        "end_line": 244,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_object_is_constructor#269",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_object_is_constructor (ecma_object_t *obj_p) /**< ecma object */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\necma_object_is_constructor (ecma_object_t *obj_p) /**< ecma object */\n{\n  return ecma_object_check_constructor (obj_p) == ECMA_IS_VALID_CONSTRUCTOR;\n}",
        "begin_line": 269,
        "end_line": 273,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_create_any_function_object#557",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_create_any_function_object (ecma_object_t *scope_p, /**< function's scope */                                     const ecma_compiled_code_t *bytecode_data_p) /**< byte-code array */",
        "snippet": "ecma_object_t *\necma_op_create_any_function_object (ecma_object_t *scope_p, /**< function's scope */\n                                    const ecma_compiled_code_t *bytecode_data_p) /**< byte-code array */\n{\n  ecma_builtin_id_t proto_id;\n\n  switch (CBC_FUNCTION_GET_TYPE (bytecode_data_p->status_flags))\n  {\n    case CBC_FUNCTION_GENERATOR:\n    {\n      proto_id = ECMA_BUILTIN_ID_GENERATOR;\n      break;\n    }\n    case CBC_FUNCTION_ASYNC:\n    {\n      proto_id = ECMA_BUILTIN_ID_ASYNC_FUNCTION_PROTOTYPE;\n      break;\n    }\n    case CBC_FUNCTION_ASYNC_GENERATOR:\n    {\n      proto_id = ECMA_BUILTIN_ID_ASYNC_GENERATOR;\n      break;\n    }\n    default:\n    {\n      proto_id = ECMA_BUILTIN_ID_FUNCTION_PROTOTYPE;\n      break;\n    }\n  }\n\n  return ecma_op_create_function_object (scope_p, bytecode_data_p, proto_id);\n}",
        "begin_line": 557,
        "end_line": 588,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_create_external_function_object#667",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_create_external_function_object (ecma_native_handler_t handler_cb) /**< pointer to external native handler */",
        "snippet": "ecma_object_t *\necma_op_create_external_function_object (ecma_native_handler_t handler_cb) /**< pointer to external native handler */\n{\n  ecma_object_t *prototype_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_FUNCTION_PROTOTYPE);\n\n  ecma_object_t *function_obj_p = ecma_create_object (prototype_obj_p,\n                                                      sizeof (ecma_native_function_t),\n                                                      ECMA_OBJECT_TYPE_NATIVE_FUNCTION);\n\n  /*\n   * [[Class]] property is not stored explicitly for objects of ECMA_OBJECT_TYPE_NATIVE_FUNCTION type.\n   *\n   * See also: ecma_object_get_class_name\n   */\n\n  ecma_native_function_t *native_function_p = (ecma_native_function_t *) function_obj_p;\n#if JERRY_BUILTIN_REALMS\n  ECMA_SET_INTERNAL_VALUE_POINTER (native_function_p->realm_value,\n                                   ecma_builtin_get_global ());\n#endif /* JERRY_BUILTIN_REALMS */\n  native_function_p->native_handler_cb = handler_cb;\n\n  return function_obj_p;\n}",
        "begin_line": 667,
        "end_line": 690,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_create_function_object#349",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_create_function_object (ecma_object_t *scope_p, /**< function's scope */                                 const ecma_compiled_code_t *bytecode_data_p, /**< byte-code array */                                 ecma_builtin_id_t proto_id) /**< builtin id of the prototype object */",
        "snippet": "static ecma_object_t *\necma_op_create_function_object (ecma_object_t *scope_p, /**< function's scope */\n                                const ecma_compiled_code_t *bytecode_data_p, /**< byte-code array */\n                                ecma_builtin_id_t proto_id) /**< builtin id of the prototype object */\n{\n  JERRY_ASSERT (ecma_is_lexical_environment (scope_p));\n\n  /* 1., 4., 13. */\n  ecma_object_t *prototype_obj_p = ecma_builtin_get (proto_id);\n\n  size_t function_object_size = sizeof (ecma_extended_object_t);\n\n#if JERRY_SNAPSHOT_EXEC\n  if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)\n  {\n    function_object_size = sizeof (ecma_static_function_t);\n  }\n#endif /* JERRY_SNAPSHOT_EXEC */\n\n  ecma_object_t *func_p = ecma_create_object (prototype_obj_p,\n                                              function_object_size,\n                                              ECMA_OBJECT_TYPE_FUNCTION);\n\n  /* 2., 6., 7., 8. */\n  /*\n   * We don't setup [[Get]], [[Call]], [[Construct]], [[HasInstance]] for each function object.\n   * Instead we set the object's type to ECMA_OBJECT_TYPE_FUNCTION\n   * that defines which version of the routine should be used on demand.\n   */\n\n  /* 3. */\n  /*\n   * [[Class]] property is not stored explicitly for objects of ECMA_OBJECT_TYPE_FUNCTION type.\n   *\n   * See also: ecma_object_get_class_name\n   */\n\n  ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_p;\n\n  /* 9. */\n  ECMA_SET_NON_NULL_POINTER_TAG (ext_func_p->u.function.scope_cp, scope_p, 0);\n\n  /* 10., 11., 12. */\n\n#if JERRY_SNAPSHOT_EXEC\n  if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)\n  {\n    ext_func_p->u.function.bytecode_cp = JMEM_CP_NULL;\n    ((ecma_static_function_t *) func_p)->bytecode_p = bytecode_data_p;\n  }\n  else\n#endif /* JERRY_SNAPSHOT_EXEC */\n  {\n    ECMA_SET_INTERNAL_VALUE_POINTER (ext_func_p->u.function.bytecode_cp, bytecode_data_p);\n    ecma_bytecode_ref ((ecma_compiled_code_t *) bytecode_data_p);\n  }\n\n  /* 14., 15., 16., 17., 18. */\n  /*\n   * 'length' and 'prototype' properties are instantiated lazily\n   *\n   * See also: ecma_op_function_try_to_lazy_instantiate_property\n   */\n\n  return func_p;\n}",
        "begin_line": 349,
        "end_line": 414,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_call#1362",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_call (ecma_object_t *func_obj_p, /**< Function object */                        ecma_value_t this_arg_value, /**< 'this' argument's value */                        const ecma_value_t *arguments_list_p, /**< arguments list */                        uint32_t arguments_list_len) /**< length of arguments list */",
        "snippet": "ecma_value_t\necma_op_function_call (ecma_object_t *func_obj_p, /**< Function object */\n                       ecma_value_t this_arg_value, /**< 'this' argument's value */\n                       const ecma_value_t *arguments_list_p, /**< arguments list */\n                       uint32_t arguments_list_len) /**< length of arguments list */\n{\n  JERRY_ASSERT (func_obj_p != NULL\n                && !ecma_is_lexical_environment (func_obj_p));\n  JERRY_ASSERT (ecma_op_object_is_callable (func_obj_p));\n\n  ECMA_CHECK_STACK_USAGE ();\n\n  const ecma_object_type_t type = ecma_get_object_type (func_obj_p);\n\n#if JERRY_BUILTIN_PROXY\n  if (ECMA_OBJECT_TYPE_IS_PROXY (type))\n  {\n    return ecma_proxy_object_call (func_obj_p, this_arg_value, arguments_list_p, arguments_list_len);\n  }\n#endif /* JERRY_BUILTIN_PROXY */\n\n#if JERRY_ESNEXT\n  ecma_object_t *old_new_target_p = JERRY_CONTEXT (current_new_target_p);\n  if (JERRY_UNLIKELY (!(JERRY_CONTEXT (status_flags) & ECMA_STATUS_DIRECT_EVAL)))\n  {\n    JERRY_CONTEXT (current_new_target_p) = NULL;\n  }\n#endif /* JERRY_ESNEXT */\n\n  ecma_value_t result;\n\n  if (JERRY_LIKELY (type == ECMA_OBJECT_TYPE_FUNCTION))\n  {\n    result = ecma_op_function_call_simple (func_obj_p, this_arg_value, arguments_list_p, arguments_list_len);\n  }\n  else if (type == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION)\n  {\n    result = ecma_op_function_call_native_built_in (func_obj_p, this_arg_value, arguments_list_p, arguments_list_len);\n  }\n  else if (type == ECMA_OBJECT_TYPE_NATIVE_FUNCTION)\n  {\n    result = ecma_op_function_call_native (func_obj_p, this_arg_value, arguments_list_p, arguments_list_len);\n  }\n#if JERRY_ESNEXT\n  else if (JERRY_UNLIKELY (type == ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION))\n  {\n    result = ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_class_constructor_new));\n  }\n#endif /* JERRY_ESNEXT */\n  else\n  {\n    result = ecma_op_function_call_bound (func_obj_p, arguments_list_p, arguments_list_len);\n  }\n\n#if JERRY_ESNEXT\n  JERRY_CONTEXT (current_new_target_p) = old_new_target_p;\n#endif /* JERRY_ESNEXT */\n\n  return result;\n}",
        "begin_line": 1362,
        "end_line": 1421,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_call_native_built_in#1190",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_call_native_built_in (ecma_object_t *func_obj_p, /**< Function object */                                        ecma_value_t this_arg_value, /**< 'this' argument's value */                                        const ecma_value_t *arguments_list_p, /**< arguments list */                                        uint32_t arguments_list_len) /**< length of arguments list */",
        "snippet": "static ecma_value_t JERRY_ATTR_NOINLINE\necma_op_function_call_native_built_in (ecma_object_t *func_obj_p, /**< Function object */\n                                       ecma_value_t this_arg_value, /**< 'this' argument's value */\n                                       const ecma_value_t *arguments_list_p, /**< arguments list */\n                                       uint32_t arguments_list_len) /**< length of arguments list */\n{\n  JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);\n\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);\n\n  ecma_extended_object_t *ext_func_obj_p = (ecma_extended_object_t *) func_obj_p;\n  JERRY_CONTEXT (global_object_p) = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_global_object_t,\n                                                                     ext_func_obj_p->u.built_in.realm_value);\n#endif /* JERRY_BUILTIN_REALMS */\n\n  ecma_value_t ret_value = ecma_builtin_dispatch_call (func_obj_p,\n                                                       this_arg_value,\n                                                       arguments_list_p,\n                                                       arguments_list_len);\n\n#if JERRY_BUILTIN_REALMS\n  JERRY_CONTEXT (global_object_p) = saved_global_object_p;\n#endif /* JERRY_BUILTIN_REALMS */\n  return ret_value;\n}",
        "begin_line": 1190,
        "end_line": 1215,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_call_simple#1032",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_call_simple (ecma_object_t *func_obj_p, /**< Function object */                               ecma_value_t this_arg_value, /**< 'this' argument's value */                               const ecma_value_t *arguments_list_p, /**< arguments list */                               uint32_t arguments_list_len) /**< length of arguments list */",
        "snippet": "static ecma_value_t\necma_op_function_call_simple (ecma_object_t *func_obj_p, /**< Function object */\n                              ecma_value_t this_arg_value, /**< 'this' argument's value */\n                              const ecma_value_t *arguments_list_p, /**< arguments list */\n                              uint32_t arguments_list_len) /**< length of arguments list */\n{\n  JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_FUNCTION);\n\n  vm_frame_ctx_shared_args_t shared_args;\n  shared_args.header.status_flags = VM_FRAME_CTX_SHARED_HAS_ARG_LIST;\n  shared_args.header.function_object_p = func_obj_p;\n  shared_args.arg_list_p = arguments_list_p;\n  shared_args.arg_list_len = arguments_list_len;\n\n  /* Entering Function Code (ECMA-262 v5, 10.4.3) */\n  ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_obj_p;\n\n  ecma_object_t *scope_p = ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t,\n                                                                       ext_func_p->u.function.scope_cp);\n\n  /* 8. */\n  ecma_value_t this_binding = this_arg_value;\n\n  const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);\n  uint16_t status_flags = bytecode_data_p->status_flags;\n\n  shared_args.header.bytecode_header_p = bytecode_data_p;\n\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *realm_p = ecma_op_function_get_realm (bytecode_data_p);\n#endif /* JERRY_BUILTIN_REALMS */\n\n  /* 1. */\n#if JERRY_ESNEXT\n  if (JERRY_UNLIKELY (CBC_FUNCTION_IS_ARROW (status_flags)))\n  {\n    ecma_arrow_function_t *arrow_func_p = (ecma_arrow_function_t *) func_obj_p;\n\n    if (ecma_is_value_undefined (arrow_func_p->new_target))\n    {\n      JERRY_CONTEXT (current_new_target_p) = NULL;\n    }\n    else\n    {\n      JERRY_CONTEXT (current_new_target_p) = ecma_get_object_from_value (arrow_func_p->new_target);\n    }\n    this_binding = arrow_func_p->this_binding;\n  }\n  else\n  {\n    shared_args.header.status_flags |= VM_FRAME_CTX_SHARED_NON_ARROW_FUNC;\n#endif /* JERRY_ESNEXT */\n\n    if (!(status_flags & CBC_CODE_FLAGS_STRICT_MODE))\n    {\n      if (ecma_is_value_undefined (this_binding)\n          || ecma_is_value_null (this_binding))\n      {\n        /* 2. */\n#if JERRY_BUILTIN_REALMS\n        this_binding = realm_p->this_binding;\n#else /* !JERRY_BUILTIN_REALMS */\n        this_binding = ecma_make_object_value (ecma_builtin_get_global ());\n#endif /* JERRY_BUILTIN_REALMS */\n      }\n      else if (!ecma_is_value_object (this_binding))\n      {\n        /* 3., 4. */\n        this_binding = ecma_op_to_object (this_binding);\n        shared_args.header.status_flags |= VM_FRAME_CTX_SHARED_FREE_THIS;\n\n        JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (this_binding));\n      }\n    }\n#if JERRY_ESNEXT\n  }\n#endif /* JERRY_ESNEXT */\n\n  /* 5. */\n  if (!(status_flags & CBC_CODE_FLAGS_LEXICAL_ENV_NOT_NEEDED))\n  {\n    shared_args.header.status_flags |= VM_FRAME_CTX_SHARED_FREE_LOCAL_ENV;\n    scope_p = ecma_create_decl_lex_env (scope_p);\n  }\n\n  ecma_value_t ret_value;\n\n#if JERRY_ESNEXT\n  if (JERRY_UNLIKELY (CBC_FUNCTION_GET_TYPE (status_flags) == CBC_FUNCTION_CONSTRUCTOR))\n  {\n    if (JERRY_CONTEXT (current_new_target_p) == NULL)\n    {\n      ret_value = ecma_raise_type_error (ECMA_ERR_MSG (\"Class constructor requires 'new'\"));\n      goto exit;\n    }\n\n    ecma_value_t lexical_this = this_binding;\n\n    if (ECMA_GET_THIRD_BIT_FROM_POINTER_TAG (ext_func_p->u.function.scope_cp))\n    {\n      shared_args.header.status_flags |= VM_FRAME_CTX_SHARED_HERITAGE_PRESENT;\n      lexical_this = ECMA_VALUE_UNINITIALIZED;\n    }\n\n    ecma_op_create_environment_record (scope_p, lexical_this, func_obj_p);\n  }\n#endif /* JERRY_ESNEXT */\n\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);\n  JERRY_CONTEXT (global_object_p) = realm_p;\n#endif /* JERRY_BUILTIN_REALMS */\n\n  ret_value = vm_run (&shared_args.header, this_binding, scope_p);\n\n#if JERRY_BUILTIN_REALMS\n  JERRY_CONTEXT (global_object_p) = saved_global_object_p;\n#endif /* JERRY_BUILTIN_REALMS */\n\n#if JERRY_ESNEXT\n  /* ECMAScript v6, 9.2.2.13 */\n  if (JERRY_UNLIKELY (shared_args.header.status_flags & VM_FRAME_CTX_SHARED_HERITAGE_PRESENT))\n  {\n    if (!ECMA_IS_VALUE_ERROR (ret_value) && !ecma_is_value_object (ret_value))\n    {\n      if (!ecma_is_value_undefined (ret_value))\n      {\n        ecma_free_value (ret_value);\n        ret_value = ecma_raise_type_error (ECMA_ERR_MSG (\"Derived constructors may only return object or undefined\"));\n      }\n      else\n      {\n        ret_value = ecma_op_get_this_binding (scope_p);\n      }\n    }\n  }\n\nexit:\n#endif /* JERRY_ESNEXT */\n\n  if (JERRY_UNLIKELY (shared_args.header.status_flags & VM_FRAME_CTX_SHARED_FREE_LOCAL_ENV))\n  {\n    ecma_deref_object (scope_p);\n  }\n\n  if (JERRY_UNLIKELY (shared_args.header.status_flags & VM_FRAME_CTX_SHARED_FREE_THIS))\n  {\n    ecma_free_value (this_binding);\n  }\n\n  return ret_value;\n}",
        "begin_line": 1032,
        "end_line": 1183,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_construct#1698",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_construct (ecma_object_t *func_obj_p, /**< Function object */                             ecma_object_t *new_target_p, /**< new target */                             const ecma_value_t *arguments_list_p, /**< arguments list */                             uint32_t arguments_list_len) /**< length of arguments list */",
        "snippet": "ecma_value_t\necma_op_function_construct (ecma_object_t *func_obj_p, /**< Function object */\n                            ecma_object_t *new_target_p, /**< new target */\n                            const ecma_value_t *arguments_list_p, /**< arguments list */\n                            uint32_t arguments_list_len) /**< length of arguments list */\n{\n  JERRY_ASSERT (func_obj_p != NULL\n                && !ecma_is_lexical_environment (func_obj_p));\n\n  const ecma_object_type_t type = ecma_get_object_type (func_obj_p);\n\n  if (JERRY_LIKELY (type == ECMA_OBJECT_TYPE_FUNCTION))\n  {\n    return ecma_op_function_construct_simple (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n  }\n\n  if (type == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION)\n  {\n    return ecma_op_function_construct_built_in (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n  }\n\n#if JERRY_BUILTIN_PROXY\n  if (ECMA_OBJECT_TYPE_IS_PROXY (type))\n  {\n    return ecma_proxy_object_construct (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n  }\n#endif /* JERRY_BUILTIN_PROXY */\n\n  if (JERRY_UNLIKELY (type == ECMA_OBJECT_TYPE_BOUND_FUNCTION))\n  {\n    return ecma_op_function_construct_bound (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n  }\n\n#if JERRY_ESNEXT\n  if (type == ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION)\n  {\n    return ecma_op_function_construct_constructor (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n  }\n#endif /* JERRY_ESNEXT */\n\n  JERRY_ASSERT (type == ECMA_OBJECT_TYPE_NATIVE_FUNCTION);\n  return ecma_op_function_construct_native (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n}",
        "begin_line": 1698,
        "end_line": 1740,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_construct_built_in#1502",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_construct_built_in (ecma_object_t *func_obj_p, /**< Function object */                                      ecma_object_t *new_target_p, /**< new target */                                      const ecma_value_t *arguments_list_p, /**< arguments list */                                      uint32_t arguments_list_len) /**< length of arguments list */",
        "snippet": "static ecma_value_t\necma_op_function_construct_built_in (ecma_object_t *func_obj_p, /**< Function object */\n                                     ecma_object_t *new_target_p, /**< new target */\n                                     const ecma_value_t *arguments_list_p, /**< arguments list */\n                                     uint32_t arguments_list_len) /**< length of arguments list */\n{\n  JERRY_UNUSED (new_target_p);\n\n  JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);\n\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);\n  ecma_value_t realm_value = ((ecma_extended_object_t *) func_obj_p)->u.built_in.realm_value;\n  JERRY_CONTEXT (global_object_p) = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_global_object_t, realm_value);\n#endif /* JERRY_BUILTIN_REALMS */\n\n#if JERRY_ESNEXT\n  ecma_object_t *old_new_target = JERRY_CONTEXT (current_new_target_p);\n  JERRY_CONTEXT (current_new_target_p) = new_target_p;\n#endif /* JERRY_ESNEXT */\n\n  ecma_value_t ret_value = ecma_builtin_dispatch_construct (func_obj_p, arguments_list_p, arguments_list_len);\n\n#if JERRY_ESNEXT\n  JERRY_CONTEXT (current_new_target_p) = old_new_target;\n#endif /* JERRY_ESNEXT */\n\n#if JERRY_BUILTIN_REALMS\n  JERRY_CONTEXT (global_object_p) = saved_global_object_p;\n#endif /* JERRY_BUILTIN_REALMS */\n  return ret_value;\n}",
        "begin_line": 1502,
        "end_line": 1533,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_get_compiled_code#729",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_get_compiled_code (ecma_extended_object_t *function_p) /**< function pointer */",
        "snippet": "extern inline const ecma_compiled_code_t * JERRY_ATTR_ALWAYS_INLINE\necma_op_function_get_compiled_code (ecma_extended_object_t *function_p) /**< function pointer */\n{\n#if JERRY_SNAPSHOT_EXEC\n  if (JERRY_LIKELY (function_p->u.function.bytecode_cp != ECMA_NULL_POINTER))\n  {\n    return ECMA_GET_INTERNAL_VALUE_POINTER (const ecma_compiled_code_t,\n                                            function_p->u.function.bytecode_cp);\n  }\n\n  return ((ecma_static_function_t *) function_p)->bytecode_p;\n#else /* !JERRY_SNAPSHOT_EXEC */\n  return ECMA_GET_INTERNAL_VALUE_POINTER (const ecma_compiled_code_t,\n                                          function_p->u.function.bytecode_cp);\n#endif /* JERRY_SNAPSHOT_EXEC */\n}",
        "begin_line": 729,
        "end_line": 744,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_get_function_realm#780",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_get_function_realm (ecma_object_t *func_obj_p) /**< function object */",
        "snippet": "ecma_global_object_t *\necma_op_function_get_function_realm (ecma_object_t *func_obj_p) /**< function object */\n{\n  while (true)\n  {\n    ecma_object_type_t type = ecma_get_object_type (func_obj_p);\n\n    if (type == ECMA_OBJECT_TYPE_FUNCTION)\n    {\n      ecma_extended_object_t *ext_function_obj_p = (ecma_extended_object_t *) func_obj_p;\n      const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_function_obj_p);\n      return ecma_op_function_get_realm (bytecode_data_p);\n    }\n\n    if (type == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION)\n    {\n      ecma_extended_object_t *ext_function_obj_p = (ecma_extended_object_t *) func_obj_p;\n      return ECMA_GET_INTERNAL_VALUE_POINTER (ecma_global_object_t,\n                                              ext_function_obj_p->u.built_in.realm_value);\n    }\n\n    if (type == ECMA_OBJECT_TYPE_NATIVE_FUNCTION)\n    {\n      ecma_native_function_t *native_function_p = (ecma_native_function_t *) func_obj_p;\n      return ECMA_GET_INTERNAL_VALUE_POINTER (ecma_global_object_t,\n                                              native_function_p->realm_value);\n    }\n\n#if JERRY_ESNEXT\n    if (type == ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION)\n    {\n      ecma_value_t script_value = ((ecma_extended_object_t *) func_obj_p)->u.constructor_function.script_value;\n      cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);\n\n      return (ecma_global_object_t *) script_p->realm_p;\n    }\n#endif /* JERRY_ESNEXT */\n\n#if JERRY_BUILTIN_PROXY\n    if (ECMA_OBJECT_IS_PROXY (func_obj_p))\n    {\n      ecma_proxy_object_t *proxy_obj_p = (ecma_proxy_object_t *) func_obj_p;\n      if (ecma_is_value_null (proxy_obj_p->handler))\n      {\n        ecma_raise_type_error (ECMA_ERR_MSG (\"Prototype from revoked Proxy is invalid\"));\n        return NULL;\n      }\n      func_obj_p = ecma_get_object_from_value (proxy_obj_p->target);\n      continue;\n    }\n#endif /* JERRY_BUILTIN_PROXY */\n\n    JERRY_ASSERT (type == ECMA_OBJECT_TYPE_BOUND_FUNCTION);\n    ecma_bound_function_t *bound_func_p = (ecma_bound_function_t *) func_obj_p;\n    func_obj_p = ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t,\n                                                             bound_func_p->header.u.bound_function.target_function);\n  }\n}",
        "begin_line": 780,
        "end_line": 837,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_get_realm#756",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_get_realm (const ecma_compiled_code_t *bytecode_header_p) /**< byte code header */",
        "snippet": "extern inline ecma_global_object_t * JERRY_ATTR_ALWAYS_INLINE\necma_op_function_get_realm (const ecma_compiled_code_t *bytecode_header_p) /**< byte code header */\n{\n#if JERRY_SNAPSHOT_EXEC\n  if (JERRY_UNLIKELY (bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION))\n  {\n    return (ecma_global_object_t *) ecma_builtin_get_global ();\n  }\n#endif /* JERRY_SNAPSHOT_EXEC */\n\n  ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_header_p)->script_value;\n  cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);\n\n  return (ecma_global_object_t *) script_p->realm_p;\n}",
        "begin_line": 756,
        "end_line": 770,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_get_prototype_from_constructor#978",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_get_prototype_from_constructor (ecma_object_t *ctor_obj_p, /**< constructor to get prototype from  */                                         ecma_builtin_id_t default_proto_id) /**< intrinsicDefaultProto */",
        "snippet": "ecma_object_t *\necma_op_get_prototype_from_constructor (ecma_object_t *ctor_obj_p, /**< constructor to get prototype from  */\n                                        ecma_builtin_id_t default_proto_id) /**< intrinsicDefaultProto */\n{\n  JERRY_ASSERT (ecma_op_object_is_callable (ctor_obj_p));\n  JERRY_ASSERT (default_proto_id < ECMA_BUILTIN_ID__COUNT);\n\n  ecma_value_t proto = ecma_op_object_get_by_magic_id (ctor_obj_p, LIT_MAGIC_STRING_PROTOTYPE);\n\n  if (ECMA_IS_VALUE_ERROR (proto))\n  {\n    return NULL;\n  }\n\n  ecma_object_t *proto_obj_p;\n\n  if (!ecma_is_value_object (proto))\n  {\n    ecma_free_value (proto);\n\n#if JERRY_BUILTIN_PROXY\n    if (ECMA_OBJECT_IS_PROXY (ctor_obj_p))\n    {\n      ecma_proxy_object_t *proxy_obj_p = (ecma_proxy_object_t *) ctor_obj_p;\n      if (ecma_is_value_null (proxy_obj_p->handler))\n      {\n        ecma_raise_type_error (ECMA_ERR_MSG (\"Prototype from revoked Proxy is invalid\"));\n        return NULL;\n      }\n    }\n#endif /* JERRY_BUILTIN_PROXY */\n\n#if JERRY_BUILTIN_REALMS\n    proto_obj_p = ecma_builtin_get_from_realm (ecma_op_function_get_function_realm (ctor_obj_p), default_proto_id);\n#else /* !JERRY_BUILTIN_REALMS */\n    proto_obj_p = ecma_builtin_get (default_proto_id);\n#endif /* JERRY_BUILTIN_REALMS */\n    ecma_ref_object (proto_obj_p);\n  }\n  else\n  {\n    proto_obj_p = ecma_get_object_from_value (proto);\n  }\n\n  return proto_obj_p;\n}",
        "begin_line": 978,
        "end_line": 1023,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_is_callable#126",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_is_callable (ecma_value_t value) /**< ecma value */",
        "snippet": "bool\necma_op_is_callable (ecma_value_t value) /**< ecma value */\n{\n  return (ecma_is_value_object (value)\n          && ecma_op_object_is_callable (ecma_get_object_from_value (value)));\n}",
        "begin_line": 126,
        "end_line": 131,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_object_is_callable#101",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_object_is_callable (ecma_object_t *obj_p) /**< ecma object */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\necma_op_object_is_callable (ecma_object_t *obj_p) /**< ecma object */\n{\n  JERRY_ASSERT (!ecma_is_lexical_environment (obj_p));\n\n  const ecma_object_type_t type = ecma_get_object_type (obj_p);\n\n#if JERRY_BUILTIN_PROXY\n  if (ECMA_OBJECT_TYPE_IS_PROXY (type))\n  {\n    return (obj_p->u2.prototype_cp & ECMA_PROXY_IS_CALLABLE) != 0;\n  }\n#endif /* JERRY_BUILTIN_PROXY */\n\n  return type >= ECMA_OBJECT_TYPE_FUNCTION;\n}",
        "begin_line": 101,
        "end_line": 116,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-get-put-value.ecma_op_put_value_lex_env_base#228",
        "src_path": "jerry-core/ecma/operations/ecma-get-put-value.c",
        "class_name": "jerry-core.ecma.operations.ecma-get-put-value",
        "signature": "jerry-core.ecma.operations.ecma-get-put-value.ecma_op_put_value_lex_env_base (ecma_object_t *lex_env_p, /**< lexical environment */                                 ecma_string_t *name_p, /**< variable name */                                 bool is_strict, /**< flag indicating strict mode */                                 ecma_value_t value) /**< ECMA-value */",
        "snippet": "ecma_value_t\necma_op_put_value_lex_env_base (ecma_object_t *lex_env_p, /**< lexical environment */\n                                ecma_string_t *name_p, /**< variable name */\n                                bool is_strict, /**< flag indicating strict mode */\n                                ecma_value_t value) /**< ECMA-value */\n{\n  JERRY_ASSERT (lex_env_p != NULL\n                && ecma_is_lexical_environment (lex_env_p));\n\n  while (true)\n  {\n    switch (ecma_get_lex_env_type (lex_env_p))\n    {\n#if JERRY_ESNEXT\n      case ECMA_LEXICAL_ENVIRONMENT_CLASS:\n      {\n        if ((lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA) == 0)\n        {\n          break;\n        }\n        /* FALLTHRU */\n      }\n#endif /* JERRY_ESNEXT */\n      case ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE:\n      {\n        ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n        if (property_p != NULL)\n        {\n#if JERRY_ESNEXT\n          ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n          JERRY_ASSERT (!(*property_p & ECMA_PROPERTY_FLAG_WRITABLE)\n                        || (*property_p & ECMA_PROPERTY_FLAG_DATA));\n\n          if ((*property_p & ECMA_PROPERTY_FLAG_WRITABLE)\n              && property_value_p->value != ECMA_VALUE_UNINITIALIZED)\n          {\n            ecma_named_data_property_assign_value (lex_env_p, property_value_p, value);\n            return ECMA_VALUE_EMPTY;\n          }\n#else /* JERRY_ESNEXT */\n          if (ecma_is_property_writable (*property_p))\n          {\n            ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n            ecma_named_data_property_assign_value (lex_env_p, property_value_p, value);\n            return ECMA_VALUE_EMPTY;\n          }\n#endif /* JERRY_ESNEXT */\n\n          return ecma_op_raise_set_binding_error (property_p, is_strict);\n        }\n        break;\n      }\n      default:\n      {\n        JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n\n        ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);\n\n        ecma_value_t has_property = ecma_op_object_has_property (binding_obj_p, name_p);\n\n#if JERRY_BUILTIN_PROXY\n        if (ECMA_IS_VALUE_ERROR (has_property))\n        {\n          return has_property;\n        }\n#endif /* JERRY_BUILTIN_PROXY */\n\n        if (ecma_is_value_true (has_property))\n        {\n          ecma_value_t completion = ecma_op_object_put (binding_obj_p,\n                                                        name_p,\n                                                        value,\n                                                        is_strict);\n\n          if (ECMA_IS_VALUE_ERROR (completion))\n          {\n            return completion;\n          }\n\n          JERRY_ASSERT (ecma_is_value_boolean (completion));\n          return ECMA_VALUE_EMPTY;\n        }\n\n        break;\n      }\n    }\n\n    if (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);\n  }\n\n  JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n\n  if (is_strict)\n  {\n#if JERRY_ERROR_MESSAGES\n    return ecma_raise_standard_error_with_format (JERRY_ERROR_REFERENCE,\n                                                  \"% is not defined\",\n                                                  ecma_make_string_value (name_p));\n#else /* !JERRY_ERROR_MESSAGES */\n    return ecma_raise_reference_error (NULL);\n#endif /* JERRY_ERROR_MESSAGES */\n  }\n\n  ecma_value_t completion = ecma_op_object_put (ecma_get_lex_env_binding_object (lex_env_p),\n                                                name_p,\n                                                value,\n                                                false);\n\n  JERRY_ASSERT (ecma_is_value_boolean (completion));\n\n  return ECMA_VALUE_EMPTY;\n}",
        "begin_line": 228,
        "end_line": 346,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-jobqueue.ecma_job_queue_init#85",
        "src_path": "jerry-core/ecma/operations/ecma-jobqueue.c",
        "class_name": "jerry-core.ecma.operations.ecma-jobqueue",
        "signature": "jerry-core.ecma.operations.ecma-jobqueue.ecma_job_queue_init (void)",
        "snippet": "void ecma_job_queue_init (void)\n{\n  JERRY_CONTEXT (job_queue_head_p) = NULL;\n  JERRY_CONTEXT (job_queue_tail_p) = NULL;\n}",
        "begin_line": 85,
        "end_line": 89,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_get_global_scope#133",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_get_global_scope (ecma_object_t *global_object_p) /**< global object */",
        "snippet": "ecma_object_t *\necma_get_global_scope (ecma_object_t *global_object_p) /**< global object */\n{\n#if JERRY_ESNEXT\n  JERRY_ASSERT (global_object_p != NULL && ecma_builtin_is_global (global_object_p));\n  return ECMA_GET_NON_NULL_POINTER (ecma_object_t, ((ecma_global_object_t *) global_object_p)->global_scope_cp);\n#else /* !JERRY_ESNEXT */\n  return ecma_get_global_environment (global_object_p);\n#endif /* !JERRY_ESNEXT */\n}",
        "begin_line": 133,
        "end_line": 142,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_init_global_environment#40",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_init_global_environment (void)",
        "snippet": "void\necma_init_global_environment (void)\n{\n  JERRY_CONTEXT (global_object_p) = ecma_builtin_create_global_object ();\n}",
        "begin_line": 40,
        "end_line": 44,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_create_mutable_binding#202",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_create_mutable_binding (ecma_object_t *lex_env_p, /**< lexical environment */                                 ecma_string_t *name_p, /**< argument N */                                 bool is_deletable) /**< argument D */",
        "snippet": "ecma_property_t *\necma_op_create_mutable_binding (ecma_object_t *lex_env_p, /**< lexical environment */\n                                ecma_string_t *name_p, /**< argument N */\n                                bool is_deletable) /**< argument D */\n{\n  JERRY_ASSERT (lex_env_p != NULL\n                && ecma_is_lexical_environment (lex_env_p));\n  JERRY_ASSERT (name_p != NULL);\n\n  if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n  {\n    uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;\n\n    if (is_deletable)\n    {\n      prop_attributes = (uint8_t) (prop_attributes | ECMA_PROPERTY_FLAG_CONFIGURABLE);\n    }\n\n    ecma_property_t *prop_p;\n\n    ecma_create_named_data_property (lex_env_p,\n                                     name_p,\n                                     prop_attributes,\n                                     &prop_p);\n    return prop_p;\n  }\n  else\n  {\n    JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n\n    ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);\n\n#if JERRY_BUILTIN_PROXY && JERRY_BUILTIN_REALMS\n    if (ECMA_OBJECT_IS_PROXY (binding_obj_p))\n    {\n      ecma_value_t result = ecma_proxy_object_is_extensible (binding_obj_p);\n\n      if (ECMA_IS_VALUE_ERROR (result))\n      {\n        return ECMA_PROPERTY_POINTER_ERROR;\n      }\n\n      if (result == ECMA_VALUE_FALSE)\n      {\n        return NULL;\n      }\n    }\n    else if (!ecma_op_ordinary_object_is_extensible (binding_obj_p))\n    {\n      return NULL;\n    }\n#else /* !JERRY_BUILTIN_PROXY || !JERRY_BUILTIN_REALMS */\n    if (!ecma_op_ordinary_object_is_extensible (binding_obj_p))\n    {\n      return NULL;\n    }\n#endif /* JERRY_BUILTIN_PROXY && JERRY_BUILTIN_REALMS */\n\n    const uint32_t flags = ECMA_PROPERTY_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;\n\n    ecma_value_t completion = ecma_builtin_helper_def_prop (binding_obj_p,\n                                                            name_p,\n                                                            ECMA_VALUE_UNDEFINED,\n                                                            is_deletable ? flags | ECMA_PROPERTY_FLAG_CONFIGURABLE\n                                                                         : flags);\n\n    if (ECMA_IS_VALUE_ERROR (completion))\n    {\n      return ECMA_PROPERTY_POINTER_ERROR;\n    }\n    else\n    {\n      JERRY_ASSERT (ecma_is_value_boolean (completion));\n    }\n  }\n\n  return NULL;\n}",
        "begin_line": 202,
        "end_line": 279,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_has_binding#155",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_has_binding (ecma_object_t *lex_env_p, /**< lexical environment */                      ecma_string_t *name_p) /**< argument N */",
        "snippet": "ecma_value_t\necma_op_has_binding (ecma_object_t *lex_env_p, /**< lexical environment */\n                     ecma_string_t *name_p) /**< argument N */\n{\n  JERRY_ASSERT (lex_env_p != NULL\n                && ecma_is_lexical_environment (lex_env_p));\n\n  ecma_lexical_environment_type_t lex_env_type = ecma_get_lex_env_type (lex_env_p);\n\n  switch (lex_env_type)\n  {\n#if JERRY_ESNEXT\n    case ECMA_LEXICAL_ENVIRONMENT_CLASS:\n    {\n      if ((lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA) == 0)\n      {\n        return ECMA_VALUE_FALSE;\n      }\n      /* FALLTHRU */\n    }\n#endif /* JERRY_ESNEXT */\n    case ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE:\n    {\n      ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n      return ecma_make_boolean_value (property_p != NULL);\n    }\n    default:\n    {\n      JERRY_ASSERT (lex_env_type == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n\n      ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);\n\n      return ecma_op_object_has_property (binding_obj_p, name_p);\n    }\n  }\n}",
        "begin_line": 155,
        "end_line": 191,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects-general.ecma_op_general_object_default_value#234",
        "src_path": "jerry-core/ecma/operations/ecma-objects-general.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects-general",
        "signature": "jerry-core.ecma.operations.ecma-objects-general.ecma_op_general_object_default_value (ecma_object_t *obj_p, /**< the object */                                       ecma_preferred_type_hint_t hint) /**< hint on preferred result type */",
        "snippet": "ecma_value_t\necma_op_general_object_default_value (ecma_object_t *obj_p, /**< the object */\n                                      ecma_preferred_type_hint_t hint) /**< hint on preferred result type */\n{\n  JERRY_ASSERT (obj_p != NULL\n                && !ecma_is_lexical_environment (obj_p));\n\n#if JERRY_ESNEXT\n  ecma_value_t obj_value = ecma_make_object_value (obj_p);\n\n  ecma_value_t exotic_to_prim = ecma_op_get_method_by_symbol_id (obj_value,\n                                                                 LIT_GLOBAL_SYMBOL_TO_PRIMITIVE);\n\n  if (ECMA_IS_VALUE_ERROR (exotic_to_prim))\n  {\n    return exotic_to_prim;\n  }\n\n  if (!ecma_is_value_undefined (exotic_to_prim))\n  {\n    ecma_object_t *call_func_p = ecma_get_object_from_value (exotic_to_prim);\n    ecma_value_t argument = ecma_make_magic_string_value (hints[hint]);\n\n    ecma_value_t result = ecma_op_function_call (call_func_p,\n                                                 obj_value,\n                                                 &argument,\n                                                 1);\n\n    ecma_free_value (exotic_to_prim);\n\n    if (ECMA_IS_VALUE_ERROR (result)\n        || !ecma_is_value_object (result))\n    {\n      return result;\n    }\n\n    ecma_free_value (result);\n\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Result of [[DefaultValue]] is invalid\"));\n  }\n\n  ecma_free_value (exotic_to_prim);\n\n  if (hint == ECMA_PREFERRED_TYPE_NO)\n  {\n    hint = ECMA_PREFERRED_TYPE_NUMBER;\n  }\n#else /* !JERRY_ESNEXT */\n  if (hint == ECMA_PREFERRED_TYPE_NO)\n  {\n    hint = ECMA_PREFERRED_TYPE_NUMBER;\n\n#if JERRY_BUILTIN_DATE\n    if (ecma_object_class_is (obj_p, ECMA_OBJECT_CLASS_DATE))\n    {\n      hint = ECMA_PREFERRED_TYPE_STRING;\n    }\n#endif /* JERRY_BUILTIN_DATE */\n  }\n#endif /* JERRY_ESNEXT */\n\n  return ecma_op_general_object_ordinary_value (obj_p, hint);\n}",
        "begin_line": 234,
        "end_line": 296,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects-general.ecma_op_general_object_define_own_property#371",
        "src_path": "jerry-core/ecma/operations/ecma-objects-general.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects-general",
        "signature": "jerry-core.ecma.operations.ecma-objects-general.ecma_op_general_object_define_own_property (ecma_object_t *object_p, /**< the object */                                             ecma_string_t *property_name_p, /**< property name */                                             const ecma_property_descriptor_t *property_desc_p) /**< property                                                                                                 *   descriptor */",
        "snippet": "ecma_value_t\necma_op_general_object_define_own_property (ecma_object_t *object_p, /**< the object */\n                                            ecma_string_t *property_name_p, /**< property name */\n                                            const ecma_property_descriptor_t *property_desc_p) /**< property\n                                                                                                *   descriptor */\n{\n#if JERRY_BUILTIN_PROXY\n  if (ECMA_OBJECT_IS_PROXY (object_p))\n  {\n    return ecma_proxy_object_define_own_property (object_p, property_name_p, property_desc_p);\n  }\n#endif /* JERRY_BUILTIN_PROXY */\n\n  JERRY_ASSERT (object_p != NULL\n                && !ecma_is_lexical_environment (object_p));\n  JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));\n  JERRY_ASSERT (property_name_p != NULL);\n\n  uint8_t property_desc_type = ECMA_OP_OBJECT_DEFINE_GENERIC;\n\n  if (property_desc_p->flags & (JERRY_PROP_IS_VALUE_DEFINED | JERRY_PROP_IS_WRITABLE_DEFINED))\n  {\n    /* A property descriptor cannot be both named data and named accessor. */\n    JERRY_ASSERT ((property_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED))\n                   != (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED));\n    property_desc_type = ECMA_OP_OBJECT_DEFINE_DATA;\n  }\n  else if (property_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED))\n  {\n    JERRY_ASSERT (!(property_desc_p->flags & JERRY_PROP_IS_WRITABLE_DEFINED));\n    property_desc_type = ECMA_OP_OBJECT_DEFINE_ACCESSOR;\n  }\n\n  /* These three asserts ensures that a new property is created with the appropriate default flags.\n   * E.g. if JERRY_PROP_IS_CONFIGURABLE_DEFINED is false, the newly created property must be non-configurable. */\n  JERRY_ASSERT ((property_desc_p->flags & JERRY_PROP_IS_CONFIGURABLE_DEFINED)\n                || !(property_desc_p->flags & JERRY_PROP_IS_CONFIGURABLE));\n  JERRY_ASSERT ((property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE_DEFINED)\n                || !(property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE));\n  JERRY_ASSERT ((property_desc_p->flags & JERRY_PROP_IS_WRITABLE_DEFINED)\n                || !(property_desc_p->flags & JERRY_PROP_IS_WRITABLE));\n\n  /* 1. */\n  ecma_extended_property_ref_t ext_property_ref = { .property_ref.value_p = NULL, .property_p = NULL };\n  ecma_property_t current_prop;\n\n  current_prop = ecma_op_object_get_own_property (object_p,\n                                                  property_name_p,\n                                                  &ext_property_ref.property_ref,\n                                                  ECMA_PROPERTY_GET_VALUE | ECMA_PROPERTY_GET_EXT_REFERENCE);\n\n  if (current_prop == ECMA_PROPERTY_TYPE_NOT_FOUND || current_prop == ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP)\n  {\n    /* 3. */\n    if (!ecma_op_ordinary_object_is_extensible (object_p))\n    {\n      /* 2. */\n      return ECMA_REJECT_WITH_FORMAT (property_desc_p->flags & JERRY_PROP_SHOULD_THROW,\n                                      \"Cannot define property '%', object is not extensible\",\n                                      ecma_make_prop_name_value (property_name_p));\n    }\n\n    /* 4. */\n    uint8_t prop_attributes = (uint8_t) (property_desc_p->flags & ECMA_PROPERTY_FLAGS_MASK);\n\n    if (property_desc_type != ECMA_OP_OBJECT_DEFINE_ACCESSOR)\n    {\n      /* a. */\n      JERRY_ASSERT (property_desc_type == ECMA_OP_OBJECT_DEFINE_GENERIC\n                    || property_desc_type == ECMA_OP_OBJECT_DEFINE_DATA);\n\n      ecma_property_value_t *new_prop_value_p = ecma_create_named_data_property (object_p,\n                                                                                 property_name_p,\n                                                                                 prop_attributes,\n                                                                                 NULL);\n\n      JERRY_ASSERT ((property_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)\n                    || ecma_is_value_undefined (property_desc_p->value));\n\n      new_prop_value_p->value = ecma_copy_value_if_not_object (property_desc_p->value);\n    }\n    else\n    {\n      /* b. */\n      ecma_create_named_accessor_property (object_p,\n                                           property_name_p,\n                                           property_desc_p->get_p,\n                                           property_desc_p->set_p,\n                                           prop_attributes,\n                                           NULL);\n    }\n\n    return ECMA_VALUE_TRUE;\n  }\n\n  /* 6. */\n  const bool is_current_configurable = ecma_is_property_configurable (current_prop);\n\n  /* 7. a., b. */\n  bool is_enumerable = (property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE) != 0;\n  if (!is_current_configurable\n      && ((property_desc_p->flags & JERRY_PROP_IS_CONFIGURABLE)\n          || ((property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE_DEFINED)\n              && (is_enumerable != ecma_is_property_enumerable (current_prop)))))\n  {\n    if (ECMA_PROPERTY_IS_VIRTUAL (current_prop))\n    {\n      ecma_free_value (ext_property_ref.property_ref.virtual_value);\n    }\n\n    return ecma_raise_property_redefinition (property_name_p, property_desc_p->flags);\n  }\n\n  if (ECMA_PROPERTY_IS_VIRTUAL (current_prop))\n  {\n    bool writable_check_failed = (property_desc_p->flags & JERRY_PROP_IS_WRITABLE);\n\n#if JERRY_MODULE_SYSTEM\n    if (ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_MODULE_NAMESPACE))\n    {\n      if (JERRY_UNLIKELY (ext_property_ref.property_ref.virtual_value == ECMA_VALUE_UNINITIALIZED))\n      {\n        return ecma_raise_reference_error (ECMA_ERR_MSG (ecma_error_let_const_not_initialized));\n      }\n\n      if (property_desc_p->flags & JERRY_PROP_IS_WRITABLE_DEFINED)\n      {\n        writable_check_failed = ((property_desc_p->flags ^ current_prop) & JERRY_PROP_IS_WRITABLE) != 0;\n      }\n    }\n    else\n    {\n      JERRY_ASSERT (!is_current_configurable && !ecma_is_property_writable (current_prop));\n    }\n#else /* !JERRY_MODULE_SYSTEM */\n    JERRY_ASSERT (!is_current_configurable && !ecma_is_property_writable (current_prop));\n#endif /* JERRY_MODULE_SYSTEM */\n\n    ecma_value_t result = ECMA_VALUE_TRUE;\n\n    if (property_desc_type == ECMA_OP_OBJECT_DEFINE_ACCESSOR\n        || writable_check_failed\n        || ((property_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)\n            && !ecma_op_same_value (property_desc_p->value,\n                                    ext_property_ref.property_ref.virtual_value)))\n    {\n      result = ecma_raise_property_redefinition (property_name_p, property_desc_p->flags);\n    }\n\n    ecma_free_value (ext_property_ref.property_ref.virtual_value);\n    return result;\n  }\n\n  /* 8. */\n  if (property_desc_type == ECMA_OP_OBJECT_DEFINE_GENERIC)\n  {\n    /* No action required. */\n  }\n  else if (JERRY_LIKELY (property_desc_type == (current_prop & ECMA_PROPERTY_FLAG_DATA)))\n  {\n    /* If property is configurable, there is no need for checks. */\n    if (JERRY_UNLIKELY (!is_current_configurable))\n    {\n      if (property_desc_type == ECMA_OP_OBJECT_DEFINE_DATA)\n      {\n        /* 10. a. i. & ii. */\n        if (!ecma_is_property_writable (current_prop)\n            && ((property_desc_p->flags & JERRY_PROP_IS_WRITABLE)\n                || ((property_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)\n                    && !ecma_op_same_value (property_desc_p->value,\n                                            ext_property_ref.property_ref.value_p->value))))\n        {\n          return ecma_raise_property_redefinition (property_name_p, property_desc_p->flags);\n        }\n      }\n      else\n      {\n        /* 11. */\n\n        /* a. */\n        ecma_property_value_t *value_p = ext_property_ref.property_ref.value_p;\n\n        ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (value_p);\n        jmem_cpointer_t prop_desc_getter_cp, prop_desc_setter_cp;\n        ECMA_SET_POINTER (prop_desc_getter_cp, property_desc_p->get_p);\n        ECMA_SET_POINTER (prop_desc_setter_cp, property_desc_p->set_p);\n\n        if (((property_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)\n             && prop_desc_getter_cp != get_set_pair_p->getter_cp)\n            || ((property_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)\n                && prop_desc_setter_cp != get_set_pair_p->setter_cp))\n        {\n          /* i., ii. */\n          return ecma_raise_property_redefinition (property_name_p, property_desc_p->flags);\n        }\n      }\n    }\n  }\n  else\n  {\n    /* 9. */\n    if (!is_current_configurable)\n    {\n      /* a. */\n      return ecma_raise_property_redefinition (property_name_p, property_desc_p->flags);\n    }\n\n    ecma_property_value_t *value_p = ext_property_ref.property_ref.value_p;\n\n    if (property_desc_type == ECMA_OP_OBJECT_DEFINE_ACCESSOR)\n    {\n      JERRY_ASSERT (current_prop & ECMA_PROPERTY_FLAG_DATA);\n      ecma_free_value_if_not_object (value_p->value);\n\n#if JERRY_CPOINTER_32_BIT\n      ecma_getter_setter_pointers_t *getter_setter_pair_p;\n      getter_setter_pair_p = jmem_pools_alloc (sizeof (ecma_getter_setter_pointers_t));\n      getter_setter_pair_p->getter_cp = JMEM_CP_NULL;\n      getter_setter_pair_p->setter_cp = JMEM_CP_NULL;\n      ECMA_SET_NON_NULL_POINTER (value_p->getter_setter_pair_cp, getter_setter_pair_p);\n#else /* !JERRY_CPOINTER_32_BIT */\n      value_p->getter_setter_pair.getter_cp = JMEM_CP_NULL;\n      value_p->getter_setter_pair.setter_cp = JMEM_CP_NULL;\n#endif /* JERRY_CPOINTER_32_BIT */\n    }\n    else\n    {\n      JERRY_ASSERT (!(current_prop & ECMA_PROPERTY_FLAG_DATA));\n#if JERRY_CPOINTER_32_BIT\n      ecma_getter_setter_pointers_t *getter_setter_pair_p;\n      getter_setter_pair_p = ECMA_GET_NON_NULL_POINTER (ecma_getter_setter_pointers_t,\n                                                        value_p->getter_setter_pair_cp);\n      jmem_pools_free (getter_setter_pair_p, sizeof (ecma_getter_setter_pointers_t));\n#endif /* JERRY_CPOINTER_32_BIT */\n      value_p->value = ECMA_VALUE_UNDEFINED;\n    }\n\n    /* Update flags */\n    ecma_property_t prop_flags = *(ext_property_ref.property_p);\n    prop_flags = (ecma_property_t) (prop_flags & ~ECMA_PROPERTY_FLAG_WRITABLE);\n    prop_flags ^= ECMA_PROPERTY_FLAG_DATA;\n    *(ext_property_ref.property_p) = prop_flags;\n  }\n\n  /* 12. */\n  if (property_desc_type == ECMA_OP_OBJECT_DEFINE_DATA)\n  {\n    JERRY_ASSERT (ECMA_PROPERTY_IS_RAW_DATA (*ext_property_ref.property_p));\n\n    if (property_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)\n    {\n      ecma_named_data_property_assign_value (object_p,\n                                             ext_property_ref.property_ref.value_p,\n                                             property_desc_p->value);\n    }\n\n    if (property_desc_p->flags & JERRY_PROP_IS_WRITABLE_DEFINED)\n    {\n      ecma_set_property_writable_attr (ext_property_ref.property_p, (property_desc_p->flags & JERRY_PROP_IS_WRITABLE));\n    }\n  }\n  else if (property_desc_type == ECMA_OP_OBJECT_DEFINE_ACCESSOR)\n  {\n    JERRY_ASSERT (!(*ext_property_ref.property_p & ECMA_PROPERTY_FLAG_DATA));\n\n    if (property_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)\n    {\n      ecma_set_named_accessor_property_getter (object_p,\n                                               ext_property_ref.property_ref.value_p,\n                                               property_desc_p->get_p);\n    }\n\n    if (property_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)\n    {\n      ecma_set_named_accessor_property_setter (object_p,\n                                               ext_property_ref.property_ref.value_p,\n                                               property_desc_p->set_p);\n    }\n  }\n\n  if (property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE_DEFINED)\n  {\n    ecma_set_property_enumerable_attr (ext_property_ref.property_p,\n                                       (property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE));\n  }\n\n  if (property_desc_p->flags & JERRY_PROP_IS_CONFIGURABLE_DEFINED)\n  {\n    ecma_set_property_configurable_attr (ext_property_ref.property_p,\n                                         (property_desc_p->flags & JERRY_PROP_IS_CONFIGURABLE));\n  }\n\n  return ECMA_VALUE_TRUE;\n}",
        "begin_line": 371,
        "end_line": 664,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects-general.ecma_op_general_object_ordinary_value#307",
        "src_path": "jerry-core/ecma/operations/ecma-objects-general.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects-general",
        "signature": "jerry-core.ecma.operations.ecma-objects-general.ecma_op_general_object_ordinary_value (ecma_object_t *obj_p, /**< the object */                                        ecma_preferred_type_hint_t hint) /**< hint on preferred result type */",
        "snippet": "ecma_value_t\necma_op_general_object_ordinary_value (ecma_object_t *obj_p, /**< the object */\n                                       ecma_preferred_type_hint_t hint) /**< hint on preferred result type */\n{\n  const lit_magic_string_id_t *function_name_ids_p = (hint == ECMA_PREFERRED_TYPE_STRING\n                                                      ? to_primitive_string_hint_method_names\n                                                      : to_primitive_non_string_hint_method_names);\n\n  for (uint32_t i = 0; i < 2; i++)\n  {\n    ecma_value_t function_value = ecma_op_object_get_by_magic_id (obj_p, function_name_ids_p[i]);\n\n    if (ECMA_IS_VALUE_ERROR (function_value))\n    {\n      return function_value;\n    }\n\n    ecma_value_t call_completion = ECMA_VALUE_EMPTY;\n\n    if (ecma_op_is_callable (function_value))\n    {\n      ecma_object_t *func_obj_p = ecma_get_object_from_value (function_value);\n\n      call_completion = ecma_op_function_call (func_obj_p,\n                                               ecma_make_object_value (obj_p),\n                                               NULL,\n                                               0);\n    }\n\n    ecma_free_value (function_value);\n\n    if (ECMA_IS_VALUE_ERROR (call_completion)\n        || (!ecma_is_value_empty (call_completion)\n           && !ecma_is_value_object (call_completion)))\n    {\n      return call_completion;\n    }\n\n    ecma_free_value (call_completion);\n  }\n\n  return ecma_raise_type_error (ECMA_ERR_MSG (\"Result of [[DefaultValue]] is invalid\"));\n}",
        "begin_line": 307,
        "end_line": 349,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_get_global_symbol#1042",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_get_global_symbol (lit_magic_string_id_t property_id) /**< property symbol id */",
        "snippet": "ecma_string_t *\necma_op_get_global_symbol (lit_magic_string_id_t property_id) /**< property symbol id */\n{\n  JERRY_ASSERT (LIT_IS_GLOBAL_SYMBOL (property_id));\n\n  uint32_t symbol_index = (uint32_t) property_id - (uint32_t) LIT_GLOBAL_SYMBOL__FIRST;\n  jmem_cpointer_t symbol_cp = JERRY_CONTEXT (global_symbols_cp)[symbol_index];\n\n  if (symbol_cp != JMEM_CP_NULL)\n  {\n    ecma_string_t *symbol_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, symbol_cp);\n    ecma_ref_ecma_string (symbol_p);\n    return symbol_p;\n  }\n\n  ecma_string_t *symbol_dot_p = ecma_get_magic_string (LIT_MAGIC_STRING_SYMBOL_DOT_UL);\n  uint16_t description = ecma_global_symbol_descriptions[symbol_index];\n  ecma_string_t *name_p = ecma_get_magic_string ((lit_magic_string_id_t) description);\n  ecma_string_t *descriptor_p = ecma_concat_ecma_strings (symbol_dot_p, name_p);\n\n  ecma_string_t *symbol_p = ecma_new_symbol_from_descriptor_string (ecma_make_string_value (descriptor_p));\n  symbol_p->u.hash = (uint16_t) ((property_id << ECMA_GLOBAL_SYMBOL_SHIFT) | ECMA_GLOBAL_SYMBOL_FLAG);\n\n  ECMA_SET_NON_NULL_POINTER (JERRY_CONTEXT (global_symbols_cp)[symbol_index], symbol_p);\n\n  ecma_ref_ecma_string (symbol_p);\n  return symbol_p;\n}",
        "begin_line": 1042,
        "end_line": 1069,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_get_method#1118",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_get_method (ecma_value_t value, /**< ecma value */                     ecma_string_t *prop_name_p) /** property name */",
        "snippet": "static ecma_value_t\necma_op_get_method (ecma_value_t value, /**< ecma value */\n                    ecma_string_t *prop_name_p) /** property name */\n{\n  /* 2. */\n  ecma_value_t obj_value = ecma_op_to_object (value);\n\n  if (ECMA_IS_VALUE_ERROR (obj_value))\n  {\n    return obj_value;\n  }\n\n  ecma_object_t *obj_p = ecma_get_object_from_value (obj_value);\n  ecma_value_t func;\n\n  func = ecma_op_object_get (obj_p, prop_name_p);\n  ecma_deref_object (obj_p);\n\n  /* 3. */\n  if (ECMA_IS_VALUE_ERROR (func))\n  {\n    return func;\n  }\n\n  /* 4. */\n  if (ecma_is_value_undefined (func) || ecma_is_value_null (func))\n  {\n    return ECMA_VALUE_UNDEFINED;\n  }\n\n  /* 5. */\n  if (!ecma_op_is_callable (func))\n  {\n    ecma_free_value (func);\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Iterator is not callable\"));\n  }\n\n  /* 6. */\n  return func;\n}",
        "begin_line": 1118,
        "end_line": 1157,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_get_method_by_symbol_id#1170",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_get_method_by_symbol_id (ecma_value_t value, /**< ecma value */                                  lit_magic_string_id_t symbol_id) /**< property symbol id */",
        "snippet": "ecma_value_t\necma_op_get_method_by_symbol_id (ecma_value_t value, /**< ecma value */\n                                 lit_magic_string_id_t symbol_id) /**< property symbol id */\n{\n  ecma_string_t *prop_name_p = ecma_op_get_global_symbol (symbol_id);\n  ecma_value_t ret_value = ecma_op_get_method (value, prop_name_p);\n  ecma_deref_ecma_string (prop_name_p);\n\n  return ret_value;\n}",
        "begin_line": 1170,
        "end_line": 1179,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_default_value#1838",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_default_value (ecma_object_t *obj_p, /**< the object */                               ecma_preferred_type_hint_t hint) /**< hint on preferred result type */",
        "snippet": "ecma_value_t\necma_op_object_default_value (ecma_object_t *obj_p, /**< the object */\n                              ecma_preferred_type_hint_t hint) /**< hint on preferred result type */\n{\n  JERRY_ASSERT (obj_p != NULL\n                && !ecma_is_lexical_environment (obj_p));\n\n  JERRY_ASSERT_OBJECT_TYPE_IS_VALID (ecma_get_object_type (obj_p));\n\n  /*\n   * typedef ecma_property_t * (*default_value_ptr_t) (ecma_object_t *, ecma_string_t *);\n   * static const default_value_ptr_t default_value [ECMA_OBJECT_TYPE__COUNT] =\n   * {\n   *   [ECMA_OBJECT_TYPE_GENERAL]           = &ecma_op_general_object_default_value,\n   *   [ECMA_OBJECT_TYPE_CLASS]             = &ecma_op_general_object_default_value,\n   *   [ECMA_OBJECT_TYPE_FUNCTION]          = &ecma_op_general_object_default_value,\n   *   [ECMA_OBJECT_TYPE_NATIVE_FUNCTION]   = &ecma_op_general_object_default_value,\n   *   [ECMA_OBJECT_TYPE_ARRAY]             = &ecma_op_general_object_default_value,\n   *   [ECMA_OBJECT_TYPE_BOUND_FUNCTION]    = &ecma_op_general_object_default_value,\n   *   [ECMA_OBJECT_TYPE_PSEUDO_ARRAY]      = &ecma_op_general_object_default_value\n   * };\n   *\n   * return default_value[type] (obj_p, property_name_p);\n   */\n\n  return ecma_op_general_object_default_value (obj_p, hint);\n}",
        "begin_line": 1838,
        "end_line": 1864,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_define_own_property#1875",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_define_own_property (ecma_object_t *obj_p, /**< the object */                                     ecma_string_t *property_name_p, /**< property name */                                     const ecma_property_descriptor_t *property_desc_p) /**< property                                                                                         *   descriptor */",
        "snippet": "ecma_value_t\necma_op_object_define_own_property (ecma_object_t *obj_p, /**< the object */\n                                    ecma_string_t *property_name_p, /**< property name */\n                                    const ecma_property_descriptor_t *property_desc_p) /**< property\n                                                                                        *   descriptor */\n{\n  JERRY_ASSERT (obj_p != NULL\n                && !ecma_is_lexical_environment (obj_p));\n  JERRY_ASSERT (property_name_p != NULL);\n\n  const ecma_object_type_t type = ecma_get_object_type (obj_p);\n\n  switch (type)\n  {\n    case ECMA_OBJECT_TYPE_CLASS:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      switch (ext_object_p->u.cls.type)\n      {\n        case ECMA_OBJECT_CLASS_ARGUMENTS:\n        {\n          return ecma_op_arguments_object_define_own_property (obj_p, property_name_p, property_desc_p);\n        }\n#if JERRY_BUILTIN_TYPEDARRAY\n        /* ES2015 9.4.5.1 */\n        case ECMA_OBJECT_CLASS_TYPEDARRAY:\n        {\n          return ecma_op_typedarray_define_own_property (obj_p, property_name_p, property_desc_p);\n        }\n#endif /* JERRY_BUILTIN_TYPEDARRAY */\n      }\n      break;\n    }\n    case ECMA_OBJECT_TYPE_ARRAY:\n    case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:\n    {\n      return ecma_op_array_object_define_own_property (obj_p, property_name_p, property_desc_p);\n    }\n#if JERRY_BUILTIN_PROXY\n    case ECMA_OBJECT_TYPE_PROXY:\n    {\n      return ecma_proxy_object_define_own_property (obj_p, property_name_p, property_desc_p);\n    }\n#endif /* JERRY_BUILTIN_PROXY */\n    default:\n    {\n      break;\n    }\n  }\n\n  return ecma_op_general_object_define_own_property (obj_p, property_name_p, property_desc_p);\n}",
        "begin_line": 1875,
        "end_line": 1927,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_find_own#525",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_find_own (ecma_value_t base_value, /**< base value */                          ecma_object_t *object_p, /**< target object */                          ecma_string_t *property_name_p) /**< property name */",
        "snippet": "ecma_value_t\necma_op_object_find_own (ecma_value_t base_value, /**< base value */\n                         ecma_object_t *object_p, /**< target object */\n                         ecma_string_t *property_name_p) /**< property name */\n{\n  JERRY_ASSERT (object_p != NULL\n                && !ecma_is_lexical_environment (object_p));\n  JERRY_ASSERT (property_name_p != NULL);\n  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));\n\n  ecma_object_base_type_t base_type = ecma_get_object_base_type (object_p);\n\n  switch (base_type)\n  {\n    case ECMA_OBJECT_BASE_TYPE_CLASS:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      switch (ext_object_p->u.cls.type)\n      {\n        case ECMA_OBJECT_CLASS_STRING:\n        {\n          if (ecma_string_is_length (property_name_p))\n          {\n            ecma_value_t prim_value_p = ext_object_p->u.cls.u3.value;\n\n            ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);\n            lit_utf8_size_t length = ecma_string_get_length (prim_value_str_p);\n\n            return ecma_make_uint32_value (length);\n          }\n\n          uint32_t index = ecma_string_get_array_index (property_name_p);\n\n          if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n          {\n            ecma_value_t prim_value_p = ext_object_p->u.cls.u3.value;\n\n            ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);\n\n            if (index < ecma_string_get_length (prim_value_str_p))\n            {\n              ecma_char_t char_at_idx = ecma_string_get_char_at_pos (prim_value_str_p, index);\n              return ecma_make_string_value (ecma_new_ecma_string_from_code_unit (char_at_idx));\n            }\n          }\n          break;\n        }\n        case ECMA_OBJECT_CLASS_ARGUMENTS:\n        {\n          if (!(ext_object_p->u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED))\n          {\n            break;\n          }\n\n          uint32_t index = ecma_string_get_array_index (property_name_p);\n\n          if (index < ext_object_p->u.cls.u2.formal_params_number)\n          {\n            ecma_mapped_arguments_t *mapped_arguments_p = (ecma_mapped_arguments_t *) ext_object_p;\n\n            ecma_value_t *argv_p = (ecma_value_t *) (mapped_arguments_p + 1);\n\n            if (!ecma_is_value_empty (argv_p[index]) && argv_p[index] != ECMA_VALUE_ARGUMENT_NO_TRACK)\n            {\n              ecma_string_t *name_p = ecma_op_arguments_object_get_formal_parameter (mapped_arguments_p, index);\n              ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, mapped_arguments_p->lex_env);\n\n              return ecma_op_get_binding_value (lex_env_p, name_p, true);\n            }\n          }\n          break;\n        }\n#if JERRY_BUILTIN_TYPEDARRAY\n        /* ES2015 9.4.5.4 */\n        case ECMA_OBJECT_CLASS_TYPEDARRAY:\n        {\n          if (ecma_prop_name_is_symbol (property_name_p))\n          {\n            break;\n          }\n\n          ecma_number_t num = ecma_string_to_number (property_name_p);\n          bool is_same;\n          if (num <= 0)\n          {\n            is_same = true;\n          }\n          else\n          {\n            ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);\n            is_same = ecma_compare_ecma_strings (property_name_p, num_to_str);\n            ecma_deref_ecma_string (num_to_str);\n          }\n\n          if (is_same)\n          {\n            ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);\n            return ecma_get_typedarray_element (&info, num);\n          }\n\n          break;\n        }\n#endif /* JERRY_BUILTIN_TYPEDARRAY */\n#if JERRY_MODULE_SYSTEM\n        case ECMA_OBJECT_CLASS_MODULE_NAMESPACE:\n        {\n          if (JERRY_UNLIKELY (ecma_prop_name_is_symbol (property_name_p)))\n          {\n            /* ECMA-262 v11, 26.3.1 */\n            if (ecma_op_compare_string_to_global_symbol (property_name_p, LIT_GLOBAL_SYMBOL_TO_STRING_TAG))\n            {\n              return ecma_make_magic_string_value (LIT_MAGIC_STRING_MODULE_UL);\n            }\n\n            return ECMA_VALUE_NOT_FOUND;\n          }\n\n          ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);\n\n          if (property_p == NULL)\n          {\n            return ECMA_VALUE_NOT_FOUND;\n          }\n\n          JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));\n\n          ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n          if (!(*property_p & ECMA_PROPERTY_FLAG_DATA))\n          {\n            prop_value_p = ecma_get_property_value_from_named_reference (prop_value_p);\n\n            if (JERRY_UNLIKELY (prop_value_p->value == ECMA_VALUE_UNINITIALIZED))\n            {\n              return ecma_raise_reference_error (ECMA_ERR_MSG (ecma_error_let_const_not_initialized));\n            }\n          }\n\n          return ecma_fast_copy_value (prop_value_p->value);\n        }\n#endif /* JERRY_MODULE_SYSTEM */\n      }\n      break;\n    }\n    case ECMA_OBJECT_BASE_TYPE_ARRAY:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      if (ecma_string_is_length (property_name_p))\n      {\n        return ecma_make_uint32_value (ext_object_p->u.array.length);\n      }\n\n      if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)))\n      {\n        uint32_t index = ecma_string_get_array_index (property_name_p);\n\n        if (JERRY_LIKELY (index != ECMA_STRING_NOT_ARRAY_INDEX))\n        {\n          if (JERRY_LIKELY (index < ext_object_p->u.array.length))\n          {\n            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);\n\n            return (ecma_is_value_array_hole (values_p[index]) ? ECMA_VALUE_NOT_FOUND\n                                                               : ecma_fast_copy_value (values_p[index]));\n          }\n        }\n        return ECMA_VALUE_NOT_FOUND;\n      }\n\n      break;\n    }\n    default:\n    {\n      break;\n    }\n  }\n\n  ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);\n\n  if (property_p == NULL)\n  {\n    switch (ecma_get_object_type (object_p))\n    {\n      case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:\n      {\n        if (ecma_builtin_function_is_routine (object_p))\n        {\n          property_p = ecma_builtin_routine_try_to_instantiate_property (object_p, property_name_p);\n          break;\n        }\n        /* FALLTHRU */\n      }\n      case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:\n      case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:\n      case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:\n      {\n        property_p = ecma_builtin_try_to_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      case ECMA_OBJECT_TYPE_CLASS:\n      {\n        if (((ecma_extended_object_t *) object_p)->u.cls.type == ECMA_OBJECT_CLASS_ARGUMENTS)\n        {\n          property_p = ecma_op_arguments_object_try_to_lazy_instantiate_property (object_p, property_name_p);\n        }\n        break;\n      }\n      case ECMA_OBJECT_TYPE_FUNCTION:\n      {\n#if !JERRY_ESNEXT\n        if (ecma_string_is_length (property_name_p))\n        {\n          /* Get length virtual property. */\n          ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;\n          const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);\n\n          uint32_t len;\n          if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n          {\n            cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_data_p;\n            len = args_p->argument_end;\n          }\n          else\n          {\n            cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_data_p;\n            len = args_p->argument_end;\n          }\n\n          return ecma_make_uint32_value (len);\n        }\n#endif /* !JERRY_ESNEXT */\n\n        /* Get prototype physical property. */\n        property_p = ecma_op_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:\n      {\n        property_p = ecma_op_external_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n      {\n        property_p = ecma_op_bound_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      default:\n      {\n        break;\n      }\n    }\n\n    if (property_p == NULL)\n    {\n      return ECMA_VALUE_NOT_FOUND;\n    }\n  }\n\n  JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));\n\n  ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n  if (*property_p & ECMA_PROPERTY_FLAG_DATA)\n  {\n    return ecma_fast_copy_value (prop_value_p->value);\n  }\n\n  ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (prop_value_p);\n\n  if (get_set_pair_p->getter_cp == JMEM_CP_NULL)\n  {\n    return ECMA_VALUE_UNDEFINED;\n  }\n\n  ecma_object_t *getter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp);\n\n  return ecma_op_function_call (getter_p, base_value, NULL, 0);\n}",
        "begin_line": 525,
        "end_line": 804,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get#887",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get (ecma_object_t *object_p, /**< the object */                     ecma_string_t *property_name_p) /**< property name */",
        "snippet": "extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE\necma_op_object_get (ecma_object_t *object_p, /**< the object */\n                    ecma_string_t *property_name_p) /**< property name */\n{\n  return ecma_op_object_get_with_receiver (object_p, property_name_p, ecma_make_object_value (object_p));\n}",
        "begin_line": 887,
        "end_line": 892,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_by_magic_id#1005",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_by_magic_id (ecma_object_t *object_p, /**< the object */                                 lit_magic_string_id_t property_id) /**< property magic string id */",
        "snippet": "extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE\necma_op_object_get_by_magic_id (ecma_object_t *object_p, /**< the object */\n                                lit_magic_string_id_t property_id) /**< property magic string id */\n{\n  return ecma_op_object_get (object_p, ecma_get_magic_string (property_id));\n}",
        "begin_line": 1005,
        "end_line": 1010,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_by_symbol_id#1096",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_by_symbol_id (ecma_object_t *object_p, /**< the object */                                  lit_magic_string_id_t property_id) /**< property symbol id */",
        "snippet": "ecma_value_t\necma_op_object_get_by_symbol_id (ecma_object_t *object_p, /**< the object */\n                                 lit_magic_string_id_t property_id) /**< property symbol id */\n{\n  ecma_string_t *symbol_p = ecma_op_get_global_symbol (property_id);\n  ecma_value_t ret_value = ecma_op_object_get (object_p, symbol_p);\n  ecma_deref_ecma_string (symbol_p);\n\n  return ret_value;\n}",
        "begin_line": 1096,
        "end_line": 1105,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_length#972",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_length (ecma_object_t *object_p, /**< the object */                            ecma_length_t *length_p) /**< [out] length value converted to uint32 */",
        "snippet": "ecma_value_t\necma_op_object_get_length (ecma_object_t *object_p, /**< the object */\n                           ecma_length_t *length_p) /**< [out] length value converted to uint32 */\n{\n  if (JERRY_LIKELY (ecma_get_object_base_type (object_p) == ECMA_OBJECT_BASE_TYPE_ARRAY))\n  {\n    *length_p = (ecma_length_t) ecma_array_get_length (object_p);\n    return ECMA_VALUE_EMPTY;\n  }\n\n  ecma_value_t len_value = ecma_op_object_get_by_magic_id (object_p, LIT_MAGIC_STRING_LENGTH);\n  ecma_value_t len_number = ecma_op_to_length (len_value, length_p);\n  ecma_free_value (len_value);\n\n  JERRY_ASSERT (ECMA_IS_VALUE_ERROR (len_number) || ecma_is_value_empty (len_number));\n\n  return len_number;\n}",
        "begin_line": 972,
        "end_line": 989,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_own_property#72",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_own_property (ecma_object_t *object_p, /**< the object */                                  ecma_string_t *property_name_p, /**< property name */                                  ecma_property_ref_t *property_ref_p, /**< property reference */                                  uint32_t options) /**< option bits */",
        "snippet": "ecma_property_t\necma_op_object_get_own_property (ecma_object_t *object_p, /**< the object */\n                                 ecma_string_t *property_name_p, /**< property name */\n                                 ecma_property_ref_t *property_ref_p, /**< property reference */\n                                 uint32_t options) /**< option bits */\n{\n  JERRY_ASSERT (object_p != NULL\n                && !ecma_is_lexical_environment (object_p));\n#if JERRY_BUILTIN_PROXY\n  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));\n#endif /* JERRY_BUILTIN_PROXY */\n  JERRY_ASSERT (property_name_p != NULL);\n  JERRY_ASSERT (options == ECMA_PROPERTY_GET_NO_OPTIONS\n                || property_ref_p != NULL);\n\n  ecma_object_base_type_t base_type = ecma_get_object_base_type (object_p);\n\n  switch (base_type)\n  {\n    case ECMA_OBJECT_BASE_TYPE_CLASS:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      switch (ext_object_p->u.cls.type)\n      {\n        case ECMA_OBJECT_CLASS_STRING:\n        {\n          if (ecma_string_is_length (property_name_p))\n          {\n            if (options & ECMA_PROPERTY_GET_VALUE)\n            {\n              ecma_value_t prim_value_p = ext_object_p->u.cls.u3.value;\n              ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);\n\n              lit_utf8_size_t length = ecma_string_get_length (prim_value_str_p);\n              property_ref_p->virtual_value = ecma_make_uint32_value (length);\n            }\n\n            return ECMA_PROPERTY_VIRTUAL;\n          }\n\n          uint32_t index = ecma_string_get_array_index (property_name_p);\n\n          if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n          {\n            ecma_value_t prim_value_p = ext_object_p->u.cls.u3.value;\n            ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);\n\n            if (index < ecma_string_get_length (prim_value_str_p))\n            {\n              if (options & ECMA_PROPERTY_GET_VALUE)\n              {\n                ecma_char_t char_at_idx = ecma_string_get_char_at_pos (prim_value_str_p, index);\n                ecma_string_t *char_str_p = ecma_new_ecma_string_from_code_unit (char_at_idx);\n                property_ref_p->virtual_value = ecma_make_string_value (char_str_p);\n              }\n\n              return ECMA_PROPERTY_FLAG_ENUMERABLE | ECMA_PROPERTY_VIRTUAL;\n            }\n          }\n          break;\n        }\n#if JERRY_BUILTIN_TYPEDARRAY\n        /* ES2015 9.4.5.1 */\n        case ECMA_OBJECT_CLASS_TYPEDARRAY:\n        {\n          if (ecma_prop_name_is_symbol (property_name_p))\n          {\n            break;\n          }\n          ecma_number_t num = ecma_string_to_number (property_name_p);\n          bool is_same;\n          if (num <= 0)\n          {\n            is_same = true;\n          }\n          else\n          {\n            ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);\n            is_same = ecma_compare_ecma_strings (property_name_p, num_to_str);\n            ecma_deref_ecma_string (num_to_str);\n          }\n\n          if (is_same)\n          {\n            ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);\n            ecma_value_t value = ecma_get_typedarray_element (&info, num);\n\n            if (ECMA_IS_VALUE_ERROR (value))\n            {\n              property_ref_p->virtual_value = value;\n              return ECMA_PROPERTY_TYPE_NOT_FOUND;\n            }\n\n            if (!ecma_is_value_undefined (value))\n            {\n              if (options & ECMA_PROPERTY_GET_VALUE)\n              {\n                property_ref_p->virtual_value = value;\n              }\n              else\n              {\n                ecma_fast_free_value (value);\n              }\n\n              return ECMA_PROPERTY_ENUMERABLE_WRITABLE | ECMA_PROPERTY_VIRTUAL;\n            }\n            else\n            {\n              return ECMA_PROPERTY_TYPE_NOT_FOUND;\n            }\n          }\n          break;\n        }\n#endif /* JERRY_BUILTIN_TYPEDARRAY */\n#if JERRY_MODULE_SYSTEM\n        case ECMA_OBJECT_CLASS_MODULE_NAMESPACE:\n        {\n          if (JERRY_UNLIKELY (ecma_prop_name_is_symbol (property_name_p)))\n          {\n            if (!ecma_op_compare_string_to_global_symbol (property_name_p, LIT_GLOBAL_SYMBOL_TO_STRING_TAG))\n            {\n              return ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP;\n            }\n\n            /* ECMA-262 v11, 26.3.1 */\n            if (options & ECMA_PROPERTY_GET_VALUE)\n            {\n              property_ref_p->virtual_value = ecma_make_magic_string_value (LIT_MAGIC_STRING_MODULE_UL);\n            }\n\n            return ECMA_PROPERTY_VIRTUAL;\n          }\n\n          ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);\n\n          if (property_p == NULL)\n          {\n            return ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP;\n          }\n\n          JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));\n\n          if (*property_p & ECMA_PROPERTY_FLAG_DATA)\n          {\n            if (options & ECMA_PROPERTY_GET_EXT_REFERENCE)\n            {\n              ((ecma_extended_property_ref_t *) property_ref_p)->property_p = property_p;\n            }\n\n            if (property_ref_p != NULL)\n            {\n              property_ref_p->value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n            }\n\n            return *property_p;\n          }\n\n          if (options & ECMA_PROPERTY_GET_VALUE)\n          {\n            ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n            prop_value_p = ecma_get_property_value_from_named_reference (prop_value_p);\n            property_ref_p->virtual_value = ecma_fast_copy_value (prop_value_p->value);\n          }\n\n          return ECMA_PROPERTY_ENUMERABLE_WRITABLE | ECMA_PROPERTY_VIRTUAL;\n        }\n#endif /* JERRY_MODULE_SYSTEM */\n      }\n      break;\n    }\n    case ECMA_OBJECT_BASE_TYPE_ARRAY:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      if (ecma_string_is_length (property_name_p))\n      {\n        if (options & ECMA_PROPERTY_GET_VALUE)\n        {\n          property_ref_p->virtual_value = ecma_make_uint32_value (ext_object_p->u.array.length);\n        }\n\n        uint32_t length_prop = ext_object_p->u.array.length_prop_and_hole_count;\n        return length_prop & (ECMA_PROPERTY_FLAG_WRITABLE | ECMA_PROPERTY_VIRTUAL);\n      }\n\n      if (ecma_op_array_is_fast_array (ext_object_p))\n      {\n        uint32_t index = ecma_string_get_array_index (property_name_p);\n\n        if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n        {\n          if (JERRY_LIKELY (index < ext_object_p->u.array.length))\n          {\n            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);\n\n            if (ecma_is_value_array_hole (values_p[index]))\n            {\n              return ECMA_PROPERTY_TYPE_NOT_FOUND;\n            }\n\n            if (options & ECMA_PROPERTY_GET_VALUE)\n            {\n              property_ref_p->virtual_value = ecma_fast_copy_value (values_p[index]);\n            }\n\n            return ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | ECMA_PROPERTY_VIRTUAL;\n          }\n        }\n\n        return ECMA_PROPERTY_TYPE_NOT_FOUND;\n      }\n\n      break;\n    }\n    default:\n    {\n      break;\n    }\n  }\n\n  ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);\n  ecma_object_type_t type = ecma_get_object_type (object_p);\n\n  if (property_p == NULL)\n  {\n    switch (type)\n    {\n      case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:\n      {\n        if (ecma_builtin_function_is_routine (object_p))\n        {\n          property_p = ecma_builtin_routine_try_to_instantiate_property (object_p, property_name_p);\n          break;\n        }\n        /* FALLTHRU */\n      }\n      case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:\n      case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:\n      case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:\n      {\n        property_p = ecma_builtin_try_to_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      case ECMA_OBJECT_TYPE_CLASS:\n      {\n        if (((ecma_extended_object_t *) object_p)->u.cls.type == ECMA_OBJECT_CLASS_ARGUMENTS)\n        {\n          property_p = ecma_op_arguments_object_try_to_lazy_instantiate_property (object_p, property_name_p);\n        }\n        break;\n      }\n      case ECMA_OBJECT_TYPE_FUNCTION:\n      {\n#if !JERRY_ESNEXT\n        if (ecma_string_is_length (property_name_p))\n        {\n          if (options & ECMA_PROPERTY_GET_VALUE)\n          {\n            /* Get length virtual property. */\n            ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;\n            const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);\n\n            uint32_t len;\n            if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n            {\n              cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_data_p;\n              len = args_p->argument_end;\n            }\n            else\n            {\n              cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_data_p;\n              len = args_p->argument_end;\n            }\n\n            property_ref_p->virtual_value = ecma_make_uint32_value (len);\n          }\n\n          return ECMA_PROPERTY_VIRTUAL;\n        }\n#endif /* !JERRY_ESNEXT */\n\n        /* Get prototype physical property. */\n        property_p = ecma_op_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:\n      {\n        property_p = ecma_op_external_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n      {\n        property_p = ecma_op_bound_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      default:\n      {\n        break;\n      }\n    }\n\n    if (property_p == NULL)\n    {\n      return ECMA_PROPERTY_TYPE_NOT_FOUND;\n    }\n  }\n  else if (type == ECMA_OBJECT_TYPE_CLASS\n           && ((ecma_extended_object_t *) object_p)->u.cls.type == ECMA_OBJECT_CLASS_ARGUMENTS\n           && (((ecma_extended_object_t *) object_p)->u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED))\n  {\n    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n    uint32_t index = ecma_string_get_array_index (property_name_p);\n\n    if (index < ext_object_p->u.cls.u2.formal_params_number)\n    {\n      ecma_mapped_arguments_t *mapped_arguments_p = (ecma_mapped_arguments_t *) ext_object_p;\n\n      ecma_value_t *argv_p = (ecma_value_t *) (mapped_arguments_p + 1);\n\n      if (!ecma_is_value_empty (argv_p[index]) && argv_p[index] != ECMA_VALUE_ARGUMENT_NO_TRACK)\n      {\n#if JERRY_LCACHE\n        /* Mapped arguments initialized properties MUST not be lcached */\n        if (ecma_is_property_lcached (property_p))\n        {\n          jmem_cpointer_t prop_name_cp;\n\n          if (JERRY_UNLIKELY (ECMA_IS_DIRECT_STRING (property_name_p)))\n          {\n            prop_name_cp = (jmem_cpointer_t) ECMA_GET_DIRECT_STRING_VALUE (property_name_p);\n          }\n          else\n          {\n            ECMA_SET_NON_NULL_POINTER (prop_name_cp, property_name_p);\n          }\n          ecma_lcache_invalidate (object_p, prop_name_cp, property_p);\n        }\n#endif /* JERRY_LCACHE */\n        ecma_string_t *name_p = ecma_op_arguments_object_get_formal_parameter (mapped_arguments_p, index);\n        ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, mapped_arguments_p->lex_env);\n\n        ecma_value_t binding_value = ecma_op_get_binding_value (lex_env_p, name_p, true);\n\n        ecma_named_data_property_assign_value (object_p,\n                                               ECMA_PROPERTY_VALUE_PTR (property_p),\n                                               binding_value);\n        ecma_free_value (binding_value);\n      }\n    }\n  }\n\n  if (options & ECMA_PROPERTY_GET_EXT_REFERENCE)\n  {\n    ((ecma_extended_property_ref_t *) property_ref_p)->property_p = property_p;\n  }\n\n  if (property_ref_p != NULL)\n  {\n    property_ref_p->value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n  }\n\n  return *property_p;\n}",
        "begin_line": 72,
        "end_line": 436,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_own_property_descriptor#1944",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_own_property_descriptor (ecma_object_t *object_p, /**< the object */                                             ecma_string_t *property_name_p, /**< property name */                                             ecma_property_descriptor_t *prop_desc_p) /**< property descriptor */",
        "snippet": "ecma_value_t\necma_op_object_get_own_property_descriptor (ecma_object_t *object_p, /**< the object */\n                                            ecma_string_t *property_name_p, /**< property name */\n                                            ecma_property_descriptor_t *prop_desc_p) /**< property descriptor */\n{\n  *prop_desc_p = ecma_make_empty_property_descriptor ();\n\n#if JERRY_BUILTIN_PROXY\n  if (ECMA_OBJECT_IS_PROXY (object_p))\n  {\n    return ecma_proxy_object_get_own_property_descriptor (object_p, property_name_p, prop_desc_p);\n  }\n#endif /* JERRY_BUILTIN_PROXY */\n\n  ecma_property_ref_t property_ref;\n  property_ref.virtual_value = ECMA_VALUE_EMPTY;\n  ecma_property_t property = ecma_op_object_get_own_property (object_p,\n                                                              property_name_p,\n                                                              &property_ref,\n                                                              ECMA_PROPERTY_GET_VALUE);\n\n  if (ECMA_IS_VALUE_ERROR (property_ref.virtual_value))\n  {\n    return property_ref.virtual_value;\n  }\n\n  if (property == ECMA_PROPERTY_TYPE_NOT_FOUND || property == ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP)\n  {\n    return ECMA_VALUE_FALSE;\n  }\n\n  uint32_t flags = ecma_is_property_enumerable (property) ? JERRY_PROP_IS_ENUMERABLE : JERRY_PROP_NO_OPTS;\n  flags |= ecma_is_property_configurable (property) ? JERRY_PROP_IS_CONFIGURABLE: JERRY_PROP_NO_OPTS;\n\n  prop_desc_p->flags = (uint16_t) (JERRY_PROP_IS_ENUMERABLE_DEFINED | JERRY_PROP_IS_CONFIGURABLE_DEFINED | flags);\n\n  if (property & ECMA_PROPERTY_FLAG_DATA)\n  {\n    if (!ECMA_PROPERTY_IS_VIRTUAL (property))\n    {\n      prop_desc_p->value = ecma_copy_value (property_ref.value_p->value);\n    }\n    else\n    {\n#if JERRY_MODULE_SYSTEM\n      if (JERRY_UNLIKELY (property_ref.virtual_value == ECMA_VALUE_UNINITIALIZED))\n      {\n        return ecma_raise_reference_error (ECMA_ERR_MSG (ecma_error_let_const_not_initialized));\n      }\n#endif /* JERRY_MODULE_SYSTEM */\n      prop_desc_p->value = property_ref.virtual_value;\n    }\n\n    prop_desc_p->flags |= (JERRY_PROP_IS_VALUE_DEFINED | JERRY_PROP_IS_WRITABLE_DEFINED);\n    prop_desc_p->flags = (uint16_t) (prop_desc_p->flags | (ecma_is_property_writable (property) ? JERRY_PROP_IS_WRITABLE\n                                                                                                : JERRY_PROP_NO_OPTS));\n  }\n  else\n  {\n    ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (property_ref.value_p);\n    prop_desc_p->flags |= (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED);\n\n    if (get_set_pair_p->getter_cp == JMEM_CP_NULL)\n    {\n      prop_desc_p->get_p = NULL;\n    }\n    else\n    {\n      prop_desc_p->get_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp);\n      ecma_ref_object (prop_desc_p->get_p);\n    }\n\n    if (get_set_pair_p->setter_cp == JMEM_CP_NULL)\n    {\n      prop_desc_p->set_p = NULL;\n    }\n    else\n    {\n      prop_desc_p->set_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->setter_cp);\n      ecma_ref_object (prop_desc_p->set_p);\n    }\n  }\n\n  return ECMA_VALUE_TRUE;\n}",
        "begin_line": 1944,
        "end_line": 2028,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_with_receiver#908",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_with_receiver (ecma_object_t *object_p, /**< the object */                                   ecma_string_t *property_name_p, /**< property name */                                   ecma_value_t receiver) /**< receiver to invoke getter function */",
        "snippet": "ecma_value_t\necma_op_object_get_with_receiver (ecma_object_t *object_p, /**< the object */\n                                  ecma_string_t *property_name_p, /**< property name */\n                                  ecma_value_t receiver) /**< receiver to invoke getter function */\n{\n  while (true)\n  {\n#if JERRY_BUILTIN_PROXY\n    if (ECMA_OBJECT_IS_PROXY (object_p))\n    {\n      return ecma_proxy_object_get (object_p, property_name_p, receiver);\n    }\n#endif /* JERRY_BUILTIN_PROXY */\n\n    ecma_value_t value = ecma_op_object_find_own (receiver, object_p, property_name_p);\n\n    if (ecma_is_value_found (value))\n    {\n      return value;\n    }\n\n    jmem_cpointer_t proto_cp = ecma_op_ordinary_object_get_prototype_of (object_p);\n\n    if (proto_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    object_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp);\n  }\n\n  return ECMA_VALUE_UNDEFINED;\n}",
        "begin_line": 908,
        "end_line": 940,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_has_property#447",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_has_property (ecma_object_t *object_p, /**< the object */                              ecma_string_t *property_name_p) /**< property name */",
        "snippet": "extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE\necma_op_object_has_property (ecma_object_t *object_p, /**< the object */\n                             ecma_string_t *property_name_p) /**< property name */\n{\n  while (true)\n  {\n#if JERRY_BUILTIN_PROXY\n    if (ECMA_OBJECT_IS_PROXY (object_p))\n    {\n      return ecma_proxy_object_has (object_p, property_name_p);\n    }\n#endif /* JERRY_BUILTIN_PROXY */\n\n#if JERRY_BUILTIN_TYPEDARRAY\n    if (ecma_object_is_typedarray (object_p) && !ecma_prop_name_is_symbol (property_name_p))\n    {\n      ecma_number_t num = ecma_string_to_number (property_name_p);\n      bool is_same;\n      if (num <= 0)\n      {\n        is_same = true;\n      }\n      else\n      {\n        ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);\n        is_same = ecma_compare_ecma_strings (property_name_p, num_to_str);\n        ecma_deref_ecma_string (num_to_str);\n      }\n\n      if (is_same)\n      {\n        ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);\n\n        if (ecma_arraybuffer_is_detached (info.array_buffer_p))\n        {\n          return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));\n        }\n\n        if (!ecma_op_is_integer (num)\n            || num >= info.length\n            || num < 0\n            || (ecma_number_is_negative (num) && ecma_number_is_zero (num)))\n        {\n          return ECMA_VALUE_FALSE;\n        }\n\n        return ECMA_VALUE_TRUE;\n      }\n    }\n#endif /* JERRY_BUILTIN_TYPEDARRAY */\n\n    /* 2 - 3. */\n    if (ecma_op_ordinary_object_has_own_property (object_p, property_name_p))\n    {\n      return ECMA_VALUE_TRUE;\n    }\n\n    jmem_cpointer_t proto_cp = ecma_op_ordinary_object_get_prototype_of (object_p);\n\n    /* 7. */\n    if (proto_cp == JMEM_CP_NULL)\n    {\n      return ECMA_VALUE_FALSE;\n    }\n\n    object_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp);\n  }\n}",
        "begin_line": 447,
        "end_line": 514,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_put#1247",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_put (ecma_object_t *object_p, /**< the object */                     ecma_string_t *property_name_p, /**< property name */                     ecma_value_t value, /**< ecma value */                     bool is_throw) /**< flag that controls failure handling */",
        "snippet": "extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE\necma_op_object_put (ecma_object_t *object_p, /**< the object */\n                    ecma_string_t *property_name_p, /**< property name */\n                    ecma_value_t value, /**< ecma value */\n                    bool is_throw) /**< flag that controls failure handling */\n{\n  return ecma_op_object_put_with_receiver (object_p,\n                                           property_name_p,\n                                           value,\n                                           ecma_make_object_value (object_p),\n                                           is_throw);\n}",
        "begin_line": 1247,
        "end_line": 1258,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_put_apply_receiver#1269",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_put_apply_receiver (ecma_value_t receiver, /**< receiver */                                    ecma_string_t *property_name_p, /**< property name */                                    ecma_value_t value, /**< value to set */                                    bool is_throw) /**< flag that controls failure handling */",
        "snippet": "static ecma_value_t\necma_op_object_put_apply_receiver (ecma_value_t receiver, /**< receiver */\n                                   ecma_string_t *property_name_p, /**< property name */\n                                   ecma_value_t value, /**< value to set */\n                                   bool is_throw) /**< flag that controls failure handling */\n{\n  /* 5.b */\n  if (!ecma_is_value_object (receiver))\n  {\n    return ECMA_REJECT (is_throw, \"Receiver must be an object\");\n  }\n\n  ecma_object_t *receiver_obj_p = ecma_get_object_from_value (receiver);\n\n  ecma_property_descriptor_t prop_desc;\n  /* 5.c */\n  ecma_value_t status = ecma_op_object_get_own_property_descriptor (receiver_obj_p,\n                                                                    property_name_p,\n                                                                    &prop_desc);\n\n  /* 5.d */\n  if (ECMA_IS_VALUE_ERROR (status))\n  {\n    return status;\n  }\n\n  /* 5.e */\n  if (ecma_is_value_true (status))\n  {\n    ecma_value_t result;\n\n    /* 5.e.i - 5.e.ii */\n    if (prop_desc.flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED)\n        || !(prop_desc.flags & JERRY_PROP_IS_WRITABLE))\n    {\n      result = ecma_raise_property_redefinition (property_name_p, prop_desc.flags);\n    }\n    else\n    {\n      /* 5.e.iii */\n      JERRY_ASSERT (prop_desc.flags & JERRY_PROP_IS_VALUE_DEFINED);\n      ecma_free_value (prop_desc.value);\n      prop_desc.value = ecma_copy_value (value);\n\n      /* 5.e.iv */\n      result = ecma_op_object_define_own_property (receiver_obj_p, property_name_p, &prop_desc);\n\n      if (JERRY_UNLIKELY (ecma_is_value_false (result)))\n      {\n        result = ECMA_REJECT (is_throw, \"Proxy trap returned falsish\");\n      }\n    }\n\n    ecma_free_property_descriptor (&prop_desc);\n\n    return result;\n  }\n\n#if JERRY_BUILTIN_PROXY\n  if (ECMA_OBJECT_IS_PROXY (receiver_obj_p))\n  {\n    ecma_property_descriptor_t desc;\n    /* Based on: ES6 9.1.9 [[Set]] 4.d.i. / ES11 9.1.9.2 OrdinarySetWithOwnDescriptor 2.c.i. */\n    desc.flags = (JERRY_PROP_IS_CONFIGURABLE\n                  | JERRY_PROP_IS_CONFIGURABLE_DEFINED\n                  | JERRY_PROP_IS_ENUMERABLE\n                  | JERRY_PROP_IS_ENUMERABLE_DEFINED\n                  | JERRY_PROP_IS_WRITABLE\n                  | JERRY_PROP_IS_WRITABLE_DEFINED\n                  | JERRY_PROP_IS_VALUE_DEFINED);\n    desc.value = value;\n    ecma_value_t ret_value = ecma_proxy_object_define_own_property (receiver_obj_p, property_name_p, &desc);\n\n    if (JERRY_UNLIKELY (ecma_is_value_false (ret_value)))\n    {\n      ret_value = ECMA_REJECT (is_throw, \"Proxy trap returned falsish\");\n    }\n\n    return ret_value;\n  }\n#endif /* JERRY_BUILTIN_PROXY */\n\n  if (JERRY_UNLIKELY (ecma_op_object_is_fast_array (receiver_obj_p)))\n  {\n    ecma_fast_array_convert_to_normal (receiver_obj_p);\n  }\n\n  /* 5.f.i */\n  ecma_property_value_t *new_prop_value_p;\n  new_prop_value_p = ecma_create_named_data_property (receiver_obj_p,\n                                                      property_name_p,\n                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,\n                                                      NULL);\n  JERRY_ASSERT (ecma_is_value_undefined (new_prop_value_p->value));\n  new_prop_value_p->value = ecma_copy_value_if_not_object (value);\n\n  return ECMA_VALUE_TRUE;\n}",
        "begin_line": 1269,
        "end_line": 1366,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_put_with_receiver#1388",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_put_with_receiver (ecma_object_t *object_p, /**< the object */                                   ecma_string_t *property_name_p, /**< property name */                                   ecma_value_t value, /**< ecma value */                                   ecma_value_t receiver, /**< receiver */                                   bool is_throw) /**< flag that controls failure handling */",
        "snippet": "ecma_value_t\necma_op_object_put_with_receiver (ecma_object_t *object_p, /**< the object */\n                                  ecma_string_t *property_name_p, /**< property name */\n                                  ecma_value_t value, /**< ecma value */\n                                  ecma_value_t receiver, /**< receiver */\n                                  bool is_throw) /**< flag that controls failure handling */\n{\n  JERRY_ASSERT (object_p != NULL\n                && !ecma_is_lexical_environment (object_p));\n  JERRY_ASSERT (property_name_p != NULL);\n\n#if JERRY_BUILTIN_PROXY\n  if (ECMA_OBJECT_IS_PROXY (object_p))\n  {\n    return ecma_proxy_object_set (object_p, property_name_p, value, receiver, is_throw);\n  }\n#endif /* JERRY_BUILTIN_PROXY */\n\n  ecma_object_base_type_t base_type = ecma_get_object_base_type (object_p);\n\n  switch (base_type)\n  {\n    case ECMA_OBJECT_BASE_TYPE_CLASS:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      switch (ext_object_p->u.cls.type)\n      {\n        case ECMA_OBJECT_CLASS_ARGUMENTS:\n        {\n          if (!(ext_object_p->u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED))\n          {\n            break;\n          }\n\n          uint32_t index = ecma_string_get_array_index (property_name_p);\n\n          if (index < ext_object_p->u.cls.u2.formal_params_number)\n          {\n            ecma_mapped_arguments_t *mapped_arguments_p = (ecma_mapped_arguments_t *) ext_object_p;\n\n            ecma_value_t *argv_p = (ecma_value_t *) (mapped_arguments_p + 1);\n\n            if (!ecma_is_value_empty (argv_p[index]) && argv_p[index] != ECMA_VALUE_ARGUMENT_NO_TRACK)\n            {\n              ecma_string_t *name_p = ecma_op_arguments_object_get_formal_parameter (mapped_arguments_p, index);\n              ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, mapped_arguments_p->lex_env);\n              ecma_op_set_mutable_binding (lex_env_p, name_p, value, true);\n              return ECMA_VALUE_TRUE;\n            }\n          }\n          break;\n        }\n#if JERRY_BUILTIN_TYPEDARRAY\n        /* ES2015 9.4.5.5 */\n        case ECMA_OBJECT_CLASS_TYPEDARRAY:\n        {\n          if (ecma_prop_name_is_symbol (property_name_p))\n          {\n            break;\n          }\n\n          ecma_number_t num = ecma_string_to_number (property_name_p);\n          bool is_same;\n          if (num <= 0)\n          {\n            is_same = true;\n          }\n          else\n          {\n            ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);\n            is_same = ecma_compare_ecma_strings (property_name_p, num_to_str);\n            ecma_deref_ecma_string (num_to_str);\n          }\n\n          if (is_same)\n          {\n            ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);\n            return ecma_set_typedarray_element (&info, value, num);\n          }\n          break;\n        }\n#endif /* JERRY_BUILTIN_TYPEDARRAY */\n#if JERRY_MODULE_SYSTEM\n        case ECMA_OBJECT_CLASS_MODULE_NAMESPACE:\n        {\n          return ecma_raise_readonly_assignment (property_name_p, is_throw);\n        }\n#endif /* JERRY_MODULE_SYSTEM */\n      }\n      break;\n    }\n    case ECMA_OBJECT_BASE_TYPE_ARRAY:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      if (ecma_string_is_length (property_name_p))\n      {\n        if (ecma_is_property_writable ((ecma_property_t) ext_object_p->u.array.length_prop_and_hole_count))\n        {\n          return ecma_op_array_object_set_length (object_p, value, 0);\n        }\n\n        return ecma_raise_readonly_assignment (property_name_p, is_throw);\n      }\n\n      if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)))\n      {\n        uint32_t index = ecma_string_get_array_index (property_name_p);\n\n        if (JERRY_UNLIKELY (index == ECMA_STRING_NOT_ARRAY_INDEX))\n        {\n          ecma_fast_array_convert_to_normal (object_p);\n        }\n        else if (ecma_fast_array_set_property (object_p, index, value))\n        {\n          return ECMA_VALUE_TRUE;\n        }\n      }\n\n      JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));\n      break;\n    }\n    default:\n    {\n      break;\n    }\n  }\n\n  ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);\n\n  if (property_p == NULL)\n  {\n    switch (ecma_get_object_type (object_p))\n    {\n      case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:\n      {\n        if (ecma_builtin_function_is_routine (object_p))\n        {\n          property_p = ecma_builtin_routine_try_to_instantiate_property (object_p, property_name_p);\n          break;\n        }\n        /* FALLTHRU */\n      }\n      case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:\n      case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:\n      case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:\n      {\n        property_p = ecma_builtin_try_to_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      case ECMA_OBJECT_TYPE_CLASS:\n      {\n        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n        switch (ext_object_p->u.cls.type)\n        {\n          case ECMA_OBJECT_CLASS_STRING:\n          {\n            uint32_t index = ecma_string_get_array_index (property_name_p);\n\n            if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n            {\n              ecma_value_t prim_value_p = ext_object_p->u.cls.u3.value;\n              ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);\n\n              if (index < ecma_string_get_length (prim_value_str_p))\n              {\n                return ecma_raise_readonly_assignment (property_name_p, is_throw);\n              }\n            }\n            break;\n          }\n          case ECMA_OBJECT_CLASS_ARGUMENTS:\n          {\n            property_p = ecma_op_arguments_object_try_to_lazy_instantiate_property (object_p, property_name_p);\n            break;\n          }\n        }\n        break;\n      }\n      case ECMA_OBJECT_TYPE_FUNCTION:\n      {\n        if (ecma_string_is_length (property_name_p))\n        {\n          /* Uninitialized 'length' property is non-writable (ECMA-262 v6, 19.2.4.1) */\n#if JERRY_ESNEXT\n          if (!ECMA_GET_FIRST_BIT_FROM_POINTER_TAG (((ecma_extended_object_t *) object_p)->u.function.scope_cp))\n#endif /* JERRY_ESNEXT */\n          {\n            return ecma_raise_readonly_assignment (property_name_p, is_throw);\n          }\n        }\n\n        /* Get prototype physical property. */\n        property_p = ecma_op_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:\n      {\n        property_p = ecma_op_external_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n      {\n        property_p = ecma_op_bound_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      default:\n      {\n        break;\n      }\n    }\n  }\n\n  jmem_cpointer_t setter_cp = JMEM_CP_NULL;\n\n  if (property_p != NULL)\n  {\n    JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));\n\n    if (*property_p & ECMA_PROPERTY_FLAG_DATA)\n    {\n      if (ecma_is_property_writable (*property_p))\n      {\n#if JERRY_ESNEXT\n        if (ecma_make_object_value (object_p) != receiver)\n        {\n          return ecma_op_object_put_apply_receiver (receiver, property_name_p, value, is_throw);\n        }\n#endif /* JERRY_ESNEXT */\n\n        /* There is no need for special casing arrays here because changing the\n         * value of an existing property never changes the length of an array. */\n        ecma_named_data_property_assign_value (object_p,\n                                               ECMA_PROPERTY_VALUE_PTR (property_p),\n                                               value);\n        return ECMA_VALUE_TRUE;\n      }\n    }\n    else\n    {\n      ecma_getter_setter_pointers_t *get_set_pair_p;\n      get_set_pair_p = ecma_get_named_accessor_property (ECMA_PROPERTY_VALUE_PTR (property_p));\n      setter_cp = get_set_pair_p->setter_cp;\n    }\n  }\n  else\n  {\n    bool create_new_property = true;\n\n    jmem_cpointer_t obj_cp;\n    ECMA_SET_NON_NULL_POINTER (obj_cp, object_p);\n    ecma_object_t *proto_p = object_p;\n\n    while (true)\n    {\n      obj_cp = ecma_op_ordinary_object_get_prototype_of (proto_p);\n\n      if (obj_cp == JMEM_CP_NULL)\n      {\n        break;\n      }\n\n      ecma_property_ref_t property_ref = { NULL };\n      proto_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_cp);\n\n#if JERRY_BUILTIN_PROXY\n      if (ECMA_OBJECT_IS_PROXY (proto_p))\n      {\n        return ecma_op_object_put_with_receiver (proto_p,\n                                                 property_name_p,\n                                                 value,\n                                                 receiver,\n                                                 is_throw);\n      }\n#endif /* JERRY_BUILTIN_PROXY */\n\n      ecma_property_t inherited_property = ecma_op_object_get_own_property (proto_p,\n                                                                            property_name_p,\n                                                                            &property_ref,\n                                                                            ECMA_PROPERTY_GET_NO_OPTIONS);\n\n      if (inherited_property != ECMA_PROPERTY_TYPE_NOT_FOUND\n          && inherited_property != ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP)\n      {\n        JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (inherited_property));\n\n        if (!(inherited_property & ECMA_PROPERTY_FLAG_DATA))\n        {\n          setter_cp = ecma_get_named_accessor_property (property_ref.value_p)->setter_cp;\n          create_new_property = false;\n          break;\n        }\n\n        create_new_property = ecma_is_property_writable (inherited_property);\n        break;\n      }\n    }\n\n#if JERRY_BUILTIN_PROXY\n    if (create_new_property\n        && ecma_is_value_object (receiver)\n        && ECMA_OBJECT_IS_PROXY (ecma_get_object_from_value (receiver)))\n    {\n      return ecma_op_object_put_apply_receiver (receiver, property_name_p, value, is_throw);\n    }\n#endif /* JERRY_BUILTIN_PROXY */\n\n    if (create_new_property\n        && ecma_op_ordinary_object_is_extensible (object_p))\n    {\n      const ecma_object_base_type_t obj_base_type = ecma_get_object_base_type (object_p);\n\n      if (obj_base_type == ECMA_OBJECT_BASE_TYPE_CLASS)\n      {\n        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n        if (ext_object_p->u.cls.type == ECMA_OBJECT_CLASS_ARGUMENTS\n            && ext_object_p->u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED)\n        {\n          const uint32_t flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;\n          return ecma_builtin_helper_def_prop (object_p, property_name_p, value, flags);\n        }\n      }\n\n      uint32_t index = ecma_string_get_array_index (property_name_p);\n\n      if (obj_base_type == ECMA_OBJECT_BASE_TYPE_ARRAY\n          && index != ECMA_STRING_NOT_ARRAY_INDEX)\n      {\n        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n        if (index < UINT32_MAX\n            && index >= ext_object_p->u.array.length)\n        {\n          if (!ecma_is_property_writable ((ecma_property_t) ext_object_p->u.array.length_prop_and_hole_count))\n          {\n            return ecma_raise_readonly_assignment (property_name_p, is_throw);\n          }\n\n          ext_object_p->u.array.length = index + 1;\n        }\n      }\n\n#if JERRY_ESNEXT\n      return ecma_op_object_put_apply_receiver (receiver, property_name_p, value, is_throw);\n#endif /* JERRY_ESNEXT */\n\n      ecma_property_value_t *new_prop_value_p;\n      new_prop_value_p = ecma_create_named_data_property (object_p,\n                                                          property_name_p,\n                                                          ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,\n                                                          NULL);\n\n      JERRY_ASSERT (ecma_is_value_undefined (new_prop_value_p->value));\n      new_prop_value_p->value = ecma_copy_value_if_not_object (value);\n      return ECMA_VALUE_TRUE;\n    }\n  }\n\n  if (setter_cp == JMEM_CP_NULL)\n  {\n    return ecma_raise_readonly_assignment (property_name_p, is_throw);\n  }\n\n  ecma_value_t ret_value = ecma_op_function_call (ECMA_GET_NON_NULL_POINTER (ecma_object_t, setter_cp),\n                                                  receiver,\n                                                  &value,\n                                                  1);\n\n  if (!ECMA_IS_VALUE_ERROR (ret_value))\n  {\n    ecma_fast_free_value (ret_value);\n    ret_value = ECMA_VALUE_TRUE;\n  }\n\n  return ret_value;\n}",
        "begin_line": 1388,
        "end_line": 1766,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_ordinary_object_get_prototype_of#3356",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_ordinary_object_get_prototype_of (ecma_object_t *obj_p) /**< object */",
        "snippet": "extern inline jmem_cpointer_t JERRY_ATTR_ALWAYS_INLINE\necma_op_ordinary_object_get_prototype_of (ecma_object_t *obj_p) /**< object */\n{\n  JERRY_ASSERT (!ecma_is_lexical_environment (obj_p));\n  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (obj_p));\n\n  return obj_p->u2.prototype_cp;\n}",
        "begin_line": 3356,
        "end_line": 3363,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_ordinary_object_has_own_property#3490",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_ordinary_object_has_own_property (ecma_object_t *object_p, /**< the object */                                           ecma_string_t *property_name_p) /**< property name */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\necma_op_ordinary_object_has_own_property (ecma_object_t *object_p, /**< the object */\n                                          ecma_string_t *property_name_p) /**< property name */\n{\n  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));\n\n  ecma_property_t property = ecma_op_object_get_own_property (object_p,\n                                                              property_name_p,\n                                                              NULL,\n                                                              ECMA_PROPERTY_GET_NO_OPTIONS);\n\n  return property != ECMA_PROPERTY_TYPE_NOT_FOUND && property != ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP;\n}",
        "begin_line": 3490,
        "end_line": 3502,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_ordinary_object_is_extensible#3456",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_ordinary_object_is_extensible (ecma_object_t *object_p) /**< object */",
        "snippet": "extern inline bool JERRY_ATTR_PURE\necma_op_ordinary_object_is_extensible (ecma_object_t *object_p) /**< object */\n{\n  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));\n\n  bool is_extensible = (object_p->type_flags_refs & ECMA_OBJECT_FLAG_EXTENSIBLE) != 0;\n\n  JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p) || is_extensible);\n\n  return is_extensible;\n}",
        "begin_line": 3456,
        "end_line": 3466,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-reference.ecma_op_is_global_environment#81",
        "src_path": "jerry-core/ecma/operations/ecma-reference.c",
        "class_name": "jerry-core.ecma.operations.ecma-reference",
        "signature": "jerry-core.ecma.operations.ecma-reference.ecma_op_is_global_environment (ecma_object_t *lex_env_p) /**< lexical environment */",
        "snippet": "static inline bool JERRY_ATTR_ALWAYS_INLINE\necma_op_is_global_environment (ecma_object_t *lex_env_p) /**< lexical environment */\n{\n  JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n#if JERRY_BUILTIN_REALMS\n  JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL\n                || (ecma_make_object_value (ecma_get_lex_env_binding_object (lex_env_p))\n                    == ((ecma_global_object_t *) ecma_builtin_get_global ())->this_binding));\n#else /* !JERRY_BUILTIN_REALMS */\n  JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL\n                || ecma_get_lex_env_binding_object (lex_env_p) == ecma_builtin_get_global ());\n#endif /* JERRY_BUILTIN_REALMS */\n\n  return lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL;\n}",
        "begin_line": 81,
        "end_line": 95,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-reference.ecma_op_resolve_reference_value#285",
        "src_path": "jerry-core/ecma/operations/ecma-reference.c",
        "class_name": "jerry-core.ecma.operations.ecma-reference",
        "signature": "jerry-core.ecma.operations.ecma-reference.ecma_op_resolve_reference_value (ecma_object_t *lex_env_p, /**< starting lexical environment */                                  ecma_string_t *name_p) /**< identifier's name */",
        "snippet": "ecma_value_t\necma_op_resolve_reference_value (ecma_object_t *lex_env_p, /**< starting lexical environment */\n                                 ecma_string_t *name_p) /**< identifier's name */\n{\n  JERRY_ASSERT (lex_env_p != NULL);\n\n  while (true)\n  {\n    switch (ecma_get_lex_env_type (lex_env_p))\n    {\n      case ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE:\n      {\n        ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n        if (property_p == NULL)\n        {\n          break;\n        }\n\n        ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n#if JERRY_ESNEXT\n        if (JERRY_UNLIKELY (property_value_p->value == ECMA_VALUE_UNINITIALIZED))\n        {\n          return ecma_raise_reference_error (ECMA_ERR_MSG (ecma_error_let_const_not_initialized));\n        }\n#endif /* JERRY_ESNEXT */\n\n        return ecma_fast_copy_value (property_value_p->value);\n      }\n#if JERRY_ESNEXT\n      case ECMA_LEXICAL_ENVIRONMENT_CLASS:\n      {\n#if JERRY_MODULE_SYSTEM\n        if (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA)\n        {\n          ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n          if (property_p == NULL)\n          {\n            break;\n          }\n\n          ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n          if (!(*property_p & ECMA_PROPERTY_FLAG_DATA))\n          {\n            property_value_p = ecma_get_property_value_from_named_reference (property_value_p);\n          }\n\n          if (JERRY_UNLIKELY (property_value_p->value == ECMA_VALUE_UNINITIALIZED))\n          {\n            return ecma_raise_reference_error (ECMA_ERR_MSG (ecma_error_let_const_not_initialized));\n          }\n\n          return ecma_fast_copy_value (property_value_p->value);\n        }\n#endif /* JERRY_MODULE_SYSTEM */\n        break;\n      }\n#endif /* JERRY_ESNEXT */\n      default:\n      {\n        JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n#if JERRY_ESNEXT\n        bool lcache_lookup_allowed = ecma_op_is_global_environment (lex_env_p);\n#else /* !JERRY_ESNEXT*/\n        bool lcache_lookup_allowed = true;\n#endif /* JERRY_ESNEXT */\n\n        if (lcache_lookup_allowed)\n        {\n#if JERRY_LCACHE\n          ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);\n          ecma_property_t *property_p = ecma_lcache_lookup (binding_obj_p, name_p);\n\n          if (property_p != NULL)\n          {\n            JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));\n\n            ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n            if (*property_p & ECMA_PROPERTY_FLAG_DATA)\n            {\n              return ecma_fast_copy_value (prop_value_p->value);\n            }\n\n            ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (prop_value_p);\n\n            if (get_set_pair_p->getter_cp == JMEM_CP_NULL)\n            {\n              return ECMA_VALUE_UNDEFINED;\n            }\n\n            ecma_object_t *getter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp);\n\n            ecma_value_t base_value = ecma_make_object_value (binding_obj_p);\n            return ecma_op_function_call (getter_p, base_value, NULL, 0);\n          }\n#endif /* JERRY_LCACHE */\n        }\n\n        ecma_value_t result = ecma_op_object_bound_environment_resolve_reference_value (lex_env_p, name_p);\n\n        if (ecma_is_value_found (result))\n        {\n          /* Note: the result may contains ECMA_VALUE_ERROR */\n          return result;\n        }\n        break;\n      }\n    }\n\n    if (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);\n  }\n\n#if JERRY_ERROR_MESSAGES\n  ecma_value_t name_val = ecma_make_string_value (name_p);\n  ecma_value_t error_value = ecma_raise_standard_error_with_format (JERRY_ERROR_REFERENCE,\n                                                                    \"% is not defined\",\n                                                                    name_val);\n#else /* JERRY_ERROR_MESSAGES */\n  ecma_value_t error_value = ecma_raise_reference_error (NULL);\n#endif /* !JERRY_ERROR_MESSAGES */\n  return error_value;\n}",
        "begin_line": 285,
        "end_line": 415,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-typedarray-object.ecma_object_is_typedarray#1797",
        "src_path": "jerry-core/ecma/operations/ecma-typedarray-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-typedarray-object",
        "signature": "jerry-core.ecma.operations.ecma-typedarray-object.ecma_object_is_typedarray (ecma_object_t *obj_p) /**< the target object need to be checked */",
        "snippet": "bool\necma_object_is_typedarray (ecma_object_t *obj_p) /**< the target object need to be checked */\n{\n  JERRY_ASSERT (!ecma_is_lexical_environment (obj_p));\n\n  return ecma_object_class_is (obj_p, ECMA_OBJECT_CLASS_TYPEDARRAY);\n}",
        "begin_line": 1797,
        "end_line": 1803,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-allocator.jmem_compress_pointer#178",
        "src_path": "jerry-core/jmem/jmem-allocator.c",
        "class_name": "jerry-core.jmem.jmem-allocator",
        "signature": "jerry-core.jmem.jmem-allocator.jmem_compress_pointer (const void *pointer_p) /**< pointer to compress */",
        "snippet": "extern inline jmem_cpointer_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE\njmem_compress_pointer (const void *pointer_p) /**< pointer to compress */\n{\n  JERRY_ASSERT (pointer_p != NULL);\n  JERRY_ASSERT (jmem_is_heap_pointer (pointer_p));\n\n  uintptr_t uint_ptr = (uintptr_t) pointer_p;\n\n  JERRY_ASSERT (uint_ptr % JMEM_ALIGNMENT == 0);\n\n#if defined (ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY) && JERRY_CPOINTER_32_BIT\n  JERRY_ASSERT (((jmem_cpointer_t) uint_ptr) == uint_ptr);\n#else /* !ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY || !JERRY_CPOINTER_32_BIT */\n  const uintptr_t heap_start = (uintptr_t) &JERRY_HEAP_CONTEXT (first);\n\n  uint_ptr -= heap_start;\n  uint_ptr >>= JMEM_ALIGNMENT_LOG;\n\n#if JERRY_CPOINTER_32_BIT\n  JERRY_ASSERT (uint_ptr <= UINT32_MAX);\n#else /* !JERRY_CPOINTER_32_BIT */\n  JERRY_ASSERT (uint_ptr <= UINT16_MAX);\n#endif /* JERRY_CPOINTER_32_BIT */\n  JERRY_ASSERT (uint_ptr != JMEM_CP_NULL);\n#endif /* ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY && JERRY_CPOINTER_32_BIT */\n\n  return (jmem_cpointer_t) uint_ptr;\n}",
        "begin_line": 178,
        "end_line": 205,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-allocator.jmem_decompress_pointer#212",
        "src_path": "jerry-core/jmem/jmem-allocator.c",
        "class_name": "jerry-core.jmem.jmem-allocator",
        "signature": "jerry-core.jmem.jmem-allocator.jmem_decompress_pointer (uintptr_t compressed_pointer) /**< pointer to decompress */",
        "snippet": "extern inline void * JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE\njmem_decompress_pointer (uintptr_t compressed_pointer) /**< pointer to decompress */\n{\n  JERRY_ASSERT (compressed_pointer != JMEM_CP_NULL);\n\n  uintptr_t uint_ptr = compressed_pointer;\n\n  JERRY_ASSERT (((jmem_cpointer_t) uint_ptr) == uint_ptr);\n\n#if defined (ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY) && JERRY_CPOINTER_32_BIT\n  JERRY_ASSERT (uint_ptr % JMEM_ALIGNMENT == 0);\n#else /* !ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY || !JERRY_CPOINTER_32_BIT */\n  const uintptr_t heap_start = (uintptr_t) &JERRY_HEAP_CONTEXT (first);\n\n  uint_ptr <<= JMEM_ALIGNMENT_LOG;\n  uint_ptr += heap_start;\n\n  JERRY_ASSERT (jmem_is_heap_pointer ((void *) uint_ptr));\n#endif /* ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY && JERRY_CPOINTER_32_BIT */\n\n  return (void *) uint_ptr;\n}",
        "begin_line": 212,
        "end_line": 233,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-allocator.jmem_init#149",
        "src_path": "jerry-core/jmem/jmem-allocator.c",
        "class_name": "jerry-core.jmem.jmem-allocator",
        "signature": "jerry-core.jmem.jmem-allocator.jmem_init (void)",
        "snippet": "void\njmem_init (void)\n{\n  jmem_heap_init ();\n}",
        "begin_line": 149,
        "end_line": 153,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_alloc#122",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_alloc (const size_t size) /**< size of requested block */",
        "snippet": "static void * JERRY_ATTR_HOT\njmem_heap_alloc (const size_t size) /**< size of requested block */\n{\n#if !JERRY_SYSTEM_ALLOCATOR\n  /* Align size. */\n  const size_t required_size = ((size + JMEM_ALIGNMENT - 1) / JMEM_ALIGNMENT) * JMEM_ALIGNMENT;\n  jmem_heap_free_t *data_space_p = NULL;\n\n  JMEM_VALGRIND_DEFINED_SPACE (&JERRY_HEAP_CONTEXT (first), sizeof (jmem_heap_free_t));\n\n  /* Fast path for 8 byte chunks, first region is guaranteed to be sufficient. */\n  if (required_size == JMEM_ALIGNMENT\n      && JERRY_LIKELY (JERRY_HEAP_CONTEXT (first).next_offset != JMEM_HEAP_END_OF_LIST))\n  {\n    data_space_p = JMEM_HEAP_GET_ADDR_FROM_OFFSET (JERRY_HEAP_CONTEXT (first).next_offset);\n    JERRY_ASSERT (jmem_is_heap_pointer (data_space_p));\n\n    JMEM_VALGRIND_DEFINED_SPACE (data_space_p, sizeof (jmem_heap_free_t));\n    JERRY_CONTEXT (jmem_heap_allocated_size) += JMEM_ALIGNMENT;\n\n    if (JERRY_CONTEXT (jmem_heap_allocated_size) >= JERRY_CONTEXT (jmem_heap_limit))\n    {\n      JERRY_CONTEXT (jmem_heap_limit) += CONFIG_GC_LIMIT;\n    }\n\n    if (data_space_p->size == JMEM_ALIGNMENT)\n    {\n      JERRY_HEAP_CONTEXT (first).next_offset = data_space_p->next_offset;\n    }\n    else\n    {\n      JERRY_ASSERT (data_space_p->size > JMEM_ALIGNMENT);\n\n      jmem_heap_free_t *remaining_p;\n      remaining_p = JMEM_HEAP_GET_ADDR_FROM_OFFSET (JERRY_HEAP_CONTEXT (first).next_offset) + 1;\n\n      JMEM_VALGRIND_DEFINED_SPACE (remaining_p, sizeof (jmem_heap_free_t));\n      remaining_p->size = data_space_p->size - JMEM_ALIGNMENT;\n      remaining_p->next_offset = data_space_p->next_offset;\n      JMEM_VALGRIND_NOACCESS_SPACE (remaining_p, sizeof (jmem_heap_free_t));\n\n      JERRY_HEAP_CONTEXT (first).next_offset = JMEM_HEAP_GET_OFFSET_FROM_ADDR (remaining_p);\n    }\n\n    JMEM_VALGRIND_NOACCESS_SPACE (data_space_p, sizeof (jmem_heap_free_t));\n\n    if (JERRY_UNLIKELY (data_space_p == JERRY_CONTEXT (jmem_heap_list_skip_p)))\n    {\n      JERRY_CONTEXT (jmem_heap_list_skip_p) = JMEM_HEAP_GET_ADDR_FROM_OFFSET (JERRY_HEAP_CONTEXT (first).next_offset);\n    }\n  }\n  /* Slow path for larger regions. */\n  else\n  {\n    uint32_t current_offset = JERRY_HEAP_CONTEXT (first).next_offset;\n    jmem_heap_free_t *prev_p = &JERRY_HEAP_CONTEXT (first);\n\n    while (JERRY_LIKELY (current_offset != JMEM_HEAP_END_OF_LIST))\n    {\n      jmem_heap_free_t *current_p = JMEM_HEAP_GET_ADDR_FROM_OFFSET (current_offset);\n      JERRY_ASSERT (jmem_is_heap_pointer (current_p));\n      JMEM_VALGRIND_DEFINED_SPACE (current_p, sizeof (jmem_heap_free_t));\n\n      const uint32_t next_offset = current_p->next_offset;\n      JERRY_ASSERT (next_offset == JMEM_HEAP_END_OF_LIST\n                    || jmem_is_heap_pointer (JMEM_HEAP_GET_ADDR_FROM_OFFSET (next_offset)));\n\n      if (current_p->size >= required_size)\n      {\n        /* Region is sufficiently big, store address. */\n        data_space_p = current_p;\n\n        /* Region was larger than necessary. */\n        if (current_p->size > required_size)\n        {\n          /* Get address of remaining space. */\n          jmem_heap_free_t *const remaining_p = (jmem_heap_free_t *) ((uint8_t *) current_p + required_size);\n\n          /* Update metadata. */\n          JMEM_VALGRIND_DEFINED_SPACE (remaining_p, sizeof (jmem_heap_free_t));\n          remaining_p->size = current_p->size - (uint32_t) required_size;\n          remaining_p->next_offset = next_offset;\n          JMEM_VALGRIND_NOACCESS_SPACE (remaining_p, sizeof (jmem_heap_free_t));\n\n          /* Update list. */\n          JMEM_VALGRIND_DEFINED_SPACE (prev_p, sizeof (jmem_heap_free_t));\n          prev_p->next_offset = JMEM_HEAP_GET_OFFSET_FROM_ADDR (remaining_p);\n          JMEM_VALGRIND_NOACCESS_SPACE (prev_p, sizeof (jmem_heap_free_t));\n        }\n        /* Block is an exact fit. */\n        else\n        {\n          /* Remove the region from the list. */\n          JMEM_VALGRIND_DEFINED_SPACE (prev_p, sizeof (jmem_heap_free_t));\n          prev_p->next_offset = next_offset;\n          JMEM_VALGRIND_NOACCESS_SPACE (prev_p, sizeof (jmem_heap_free_t));\n        }\n\n        JERRY_CONTEXT (jmem_heap_list_skip_p) = prev_p;\n\n        /* Found enough space. */\n        JERRY_CONTEXT (jmem_heap_allocated_size) += required_size;\n\n        while (JERRY_CONTEXT (jmem_heap_allocated_size) >= JERRY_CONTEXT (jmem_heap_limit))\n        {\n          JERRY_CONTEXT (jmem_heap_limit) += CONFIG_GC_LIMIT;\n        }\n\n        break;\n      }\n\n      JMEM_VALGRIND_NOACCESS_SPACE (current_p, sizeof (jmem_heap_free_t));\n      /* Next in list. */\n      prev_p = current_p;\n      current_offset = next_offset;\n    }\n  }\n\n  JMEM_VALGRIND_NOACCESS_SPACE (&JERRY_HEAP_CONTEXT (first), sizeof (jmem_heap_free_t));\n\n  JERRY_ASSERT ((uintptr_t) data_space_p % JMEM_ALIGNMENT == 0);\n  JMEM_VALGRIND_MALLOCLIKE_SPACE (data_space_p, size);\n\n  return (void *) data_space_p;\n#else /* JERRY_SYSTEM_ALLOCATOR */\n  JERRY_CONTEXT (jmem_heap_allocated_size) += size;\n\n  while (JERRY_CONTEXT (jmem_heap_allocated_size) >= JERRY_CONTEXT (jmem_heap_limit))\n  {\n    JERRY_CONTEXT (jmem_heap_limit) += CONFIG_GC_LIMIT;\n  }\n\n  return malloc (size);\n#endif /* !JERRY_SYSTEM_ALLOCATOR */\n}",
        "begin_line": 122,
        "end_line": 256,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_alloc_block#321",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_alloc_block (const size_t size) /**< required memory size */",
        "snippet": "extern inline void * JERRY_ATTR_HOT JERRY_ATTR_ALWAYS_INLINE\njmem_heap_alloc_block (const size_t size) /**< required memory size */\n{\n  void *block_p = jmem_heap_gc_and_alloc_block (size, JMEM_PRESSURE_FULL);\n  JMEM_HEAP_STAT_ALLOC (size);\n  return block_p;\n}",
        "begin_line": 321,
        "end_line": 327,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_alloc_block_internal#306",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_alloc_block_internal (const size_t size) /**< required memory size */",
        "snippet": "extern inline void * JERRY_ATTR_HOT JERRY_ATTR_ALWAYS_INLINE\njmem_heap_alloc_block_internal (const size_t size) /**< required memory size */\n{\n  return jmem_heap_gc_and_alloc_block (size, JMEM_PRESSURE_FULL);\n}",
        "begin_line": 306,
        "end_line": 310,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_alloc_block_null_on_error#339",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_alloc_block_null_on_error (const size_t size) /**< required memory size */",
        "snippet": "extern inline void * JERRY_ATTR_HOT JERRY_ATTR_ALWAYS_INLINE\njmem_heap_alloc_block_null_on_error (const size_t size) /**< required memory size */\n{\n  void *block_p = jmem_heap_gc_and_alloc_block (size, JMEM_PRESSURE_HIGH);\n\n#if JERRY_MEM_STATS\n  if (block_p != NULL)\n  {\n    JMEM_HEAP_STAT_ALLOC (size);\n  }\n#endif /* JERRY_MEM_STATS */\n\n  return block_p;\n}",
        "begin_line": 339,
        "end_line": 352,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_free_block#687",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_free_block (void *ptr, /**< pointer to beginning of data space of the block */                       const size_t size) /**< size of allocated region */",
        "snippet": "extern inline void JERRY_ATTR_HOT JERRY_ATTR_ALWAYS_INLINE\njmem_heap_free_block (void *ptr, /**< pointer to beginning of data space of the block */\n                      const size_t size) /**< size of allocated region */\n{\n  jmem_heap_free_block_internal (ptr, size);\n  JMEM_HEAP_STAT_FREE (size);\n  return;\n}",
        "begin_line": 687,
        "end_line": 694,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_free_block_internal#453",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_free_block_internal (void *ptr, /**< pointer to beginning of data space of the block */                                const size_t size) /**< size of allocated region */",
        "snippet": "void JERRY_ATTR_HOT\njmem_heap_free_block_internal (void *ptr, /**< pointer to beginning of data space of the block */\n                               const size_t size) /**< size of allocated region */\n{\n  JERRY_ASSERT (size > 0);\n  JERRY_ASSERT (JERRY_CONTEXT (jmem_heap_limit) >= JERRY_CONTEXT (jmem_heap_allocated_size));\n  JERRY_ASSERT (JERRY_CONTEXT (jmem_heap_allocated_size) > 0);\n\n#if !JERRY_SYSTEM_ALLOCATOR\n  /* checking that ptr points to the heap */\n  JERRY_ASSERT (jmem_is_heap_pointer (ptr));\n  JERRY_ASSERT ((uintptr_t) ptr % JMEM_ALIGNMENT == 0);\n\n  const size_t aligned_size = (size + JMEM_ALIGNMENT - 1) / JMEM_ALIGNMENT * JMEM_ALIGNMENT;\n\n  jmem_heap_free_t *const block_p = (jmem_heap_free_t *) ptr;\n  jmem_heap_free_t *const prev_p = jmem_heap_find_prev (block_p);\n  jmem_heap_insert_block (block_p, prev_p, aligned_size);\n\n  JERRY_CONTEXT (jmem_heap_allocated_size) -= aligned_size;\n\n  JMEM_VALGRIND_FREELIKE_SPACE (ptr);\n#else /* JERRY_SYSTEM_ALLOCATOR */\n  JERRY_CONTEXT (jmem_heap_allocated_size) -= size;\n  free (ptr);\n#endif /* !JERRY_SYSTEM_ALLOCATOR */\n  while (JERRY_CONTEXT (jmem_heap_allocated_size) + CONFIG_GC_LIMIT <= JERRY_CONTEXT (jmem_heap_limit))\n  {\n    JERRY_CONTEXT (jmem_heap_limit) -= CONFIG_GC_LIMIT;\n  }\n\n  JERRY_ASSERT (JERRY_CONTEXT (jmem_heap_limit) >= JERRY_CONTEXT (jmem_heap_allocated_size));\n}",
        "begin_line": 453,
        "end_line": 485,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_gc_and_alloc_block#270",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_gc_and_alloc_block (const size_t size, /**< required memory size */                               jmem_pressure_t max_pressure) /**< pressure limit */",
        "snippet": "static void *\njmem_heap_gc_and_alloc_block (const size_t size, /**< required memory size */\n                              jmem_pressure_t max_pressure) /**< pressure limit */\n{\n  if (JERRY_UNLIKELY (size == 0))\n  {\n    return NULL;\n  }\n\n  jmem_pressure_t pressure = JMEM_PRESSURE_NONE;\n\n#if !JERRY_MEM_GC_BEFORE_EACH_ALLOC\n  if (JERRY_CONTEXT (jmem_heap_allocated_size) + size >= JERRY_CONTEXT (jmem_heap_limit))\n  {\n    pressure = JMEM_PRESSURE_LOW;\n    ecma_free_unused_memory (pressure);\n  }\n#else /* !JERRY_MEM_GC_BEFORE_EACH_ALLOC */\n  ecma_gc_run ();\n#endif /* JERRY_MEM_GC_BEFORE_EACH_ALLOC */\n\n  void *data_space_p = jmem_heap_alloc (size);\n\n  while (JERRY_UNLIKELY (data_space_p == NULL) && JERRY_LIKELY (pressure < max_pressure))\n  {\n    pressure++;\n    ecma_free_unused_memory (pressure);\n    data_space_p = jmem_heap_alloc (size);\n  }\n\n  return data_space_p;\n}",
        "begin_line": 270,
        "end_line": 301,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_init#72",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_init (void)",
        "snippet": "void\njmem_heap_init (void)\n{\n#if !JERRY_SYSTEM_ALLOCATOR\n#if !JERRY_CPOINTER_32_BIT\n  /* the maximum heap size for 16bit compressed pointers should be 512K */\n  JERRY_ASSERT (((UINT16_MAX + 1) << JMEM_ALIGNMENT_LOG) >= JMEM_HEAP_SIZE);\n#endif /* !JERRY_CPOINTER_32_BIT */\n  JERRY_ASSERT ((uintptr_t) JERRY_HEAP_CONTEXT (area) % JMEM_ALIGNMENT == 0);\n\n  JERRY_CONTEXT (jmem_heap_limit) = CONFIG_GC_LIMIT;\n\n  jmem_heap_free_t *const region_p = (jmem_heap_free_t *) JERRY_HEAP_CONTEXT (area);\n\n  region_p->size = JMEM_HEAP_AREA_SIZE;\n  region_p->next_offset = JMEM_HEAP_END_OF_LIST;\n\n  JERRY_HEAP_CONTEXT (first).size = 0;\n  JERRY_HEAP_CONTEXT (first).next_offset = JMEM_HEAP_GET_OFFSET_FROM_ADDR (region_p);\n\n  JERRY_CONTEXT (jmem_heap_list_skip_p) = &JERRY_HEAP_CONTEXT (first);\n\n  JMEM_VALGRIND_NOACCESS_SPACE (&JERRY_HEAP_CONTEXT (first), sizeof (jmem_heap_free_t));\n  JMEM_VALGRIND_NOACCESS_SPACE (JERRY_HEAP_CONTEXT (area), JMEM_HEAP_AREA_SIZE);\n\n#endif /* !JERRY_SYSTEM_ALLOCATOR */\n  JMEM_HEAP_STAT_INIT ();\n}",
        "begin_line": 72,
        "end_line": 99,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_realloc_block#492",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_realloc_block (void *ptr, /**< memory region to reallocate */                          const size_t old_size, /**< current size of the region */                          const size_t new_size) /**< desired new size */",
        "snippet": "void * JERRY_ATTR_HOT\njmem_heap_realloc_block (void *ptr, /**< memory region to reallocate */\n                         const size_t old_size, /**< current size of the region */\n                         const size_t new_size) /**< desired new size */\n{\n#if !JERRY_SYSTEM_ALLOCATOR\n  JERRY_ASSERT (jmem_is_heap_pointer (ptr));\n  JERRY_ASSERT ((uintptr_t) ptr % JMEM_ALIGNMENT == 0);\n  JERRY_ASSERT (old_size != 0);\n  JERRY_ASSERT (new_size != 0);\n\n  jmem_heap_free_t * const block_p = (jmem_heap_free_t *) ptr;\n  const size_t aligned_new_size = (new_size + JMEM_ALIGNMENT - 1) / JMEM_ALIGNMENT * JMEM_ALIGNMENT;\n  const size_t aligned_old_size = (old_size + JMEM_ALIGNMENT - 1) / JMEM_ALIGNMENT * JMEM_ALIGNMENT;\n\n  if (aligned_old_size == aligned_new_size)\n  {\n    JMEM_VALGRIND_RESIZE_SPACE (block_p, old_size, new_size);\n    JMEM_HEAP_STAT_FREE (old_size);\n    JMEM_HEAP_STAT_ALLOC (new_size);\n    return block_p;\n  }\n\n  if (aligned_new_size < aligned_old_size)\n  {\n    JMEM_VALGRIND_RESIZE_SPACE (block_p, old_size, new_size);\n    JMEM_HEAP_STAT_FREE (old_size);\n    JMEM_HEAP_STAT_ALLOC (new_size);\n    jmem_heap_insert_block ((jmem_heap_free_t *) ((uint8_t *) block_p + aligned_new_size),\n                            jmem_heap_find_prev (block_p),\n                            aligned_old_size - aligned_new_size);\n\n    JERRY_CONTEXT (jmem_heap_allocated_size) -= (aligned_old_size - aligned_new_size);\n    while (JERRY_CONTEXT (jmem_heap_allocated_size) + CONFIG_GC_LIMIT <= JERRY_CONTEXT (jmem_heap_limit))\n    {\n      JERRY_CONTEXT (jmem_heap_limit) -= CONFIG_GC_LIMIT;\n    }\n\n    return block_p;\n  }\n\n  void *ret_block_p = NULL;\n  const size_t required_size = aligned_new_size - aligned_old_size;\n\n#if !JERRY_MEM_GC_BEFORE_EACH_ALLOC\n  if (JERRY_CONTEXT (jmem_heap_allocated_size) + required_size >= JERRY_CONTEXT (jmem_heap_limit))\n  {\n    ecma_free_unused_memory (JMEM_PRESSURE_LOW);\n  }\n#else /* !JERRY_MEM_GC_BEFORE_EACH_ALLOC */\n  ecma_gc_run ();\n#endif /* JERRY_MEM_GC_BEFORE_EACH_ALLOC */\n\n  jmem_heap_free_t *prev_p = jmem_heap_find_prev (block_p);\n  JMEM_VALGRIND_DEFINED_SPACE (prev_p, sizeof (jmem_heap_free_t));\n  jmem_heap_free_t * const next_p = JMEM_HEAP_GET_ADDR_FROM_OFFSET (prev_p->next_offset);\n\n  /* Check if block can be extended at the end */\n  if (((jmem_heap_free_t *) ((uint8_t *) block_p + aligned_old_size)) == next_p)\n  {\n    JMEM_VALGRIND_DEFINED_SPACE (next_p, sizeof (jmem_heap_free_t));\n\n    if (required_size <= next_p->size)\n    {\n      /* Block can be extended, update the list. */\n      if (required_size == next_p->size)\n      {\n        prev_p->next_offset = next_p->next_offset;\n      }\n      else\n      {\n        jmem_heap_free_t *const new_next_p = (jmem_heap_free_t *) ((uint8_t *) next_p + required_size);\n        JMEM_VALGRIND_DEFINED_SPACE (new_next_p, sizeof (jmem_heap_free_t));\n        new_next_p->next_offset = next_p->next_offset;\n        new_next_p->size = (uint32_t) (next_p->size - required_size);\n        JMEM_VALGRIND_NOACCESS_SPACE (new_next_p, sizeof (jmem_heap_free_t));\n        prev_p->next_offset = JMEM_HEAP_GET_OFFSET_FROM_ADDR (new_next_p);\n      }\n\n      /* next_p will be marked as undefined space. */\n      JMEM_VALGRIND_RESIZE_SPACE (block_p, old_size, new_size);\n      ret_block_p = block_p;\n    }\n    else\n    {\n      JMEM_VALGRIND_NOACCESS_SPACE (next_p, sizeof (jmem_heap_free_t));\n    }\n\n    JMEM_VALGRIND_NOACCESS_SPACE (prev_p, sizeof (jmem_heap_free_t));\n  }\n  /*\n   * Check if block can be extended at the front.\n   * This is less optimal because we need to copy the data, but still better than allocting a new block.\n   */\n  else if (jmem_heap_get_region_end (prev_p) == block_p)\n  {\n    if (required_size <= prev_p->size)\n    {\n      if (required_size == prev_p->size)\n      {\n        JMEM_VALGRIND_NOACCESS_SPACE (prev_p, sizeof (jmem_heap_free_t));\n        prev_p = jmem_heap_find_prev (prev_p);\n        JMEM_VALGRIND_DEFINED_SPACE (prev_p, sizeof (jmem_heap_free_t));\n        prev_p->next_offset = JMEM_HEAP_GET_OFFSET_FROM_ADDR (next_p);\n      }\n      else\n      {\n        prev_p->size = (uint32_t) (prev_p->size - required_size);\n      }\n\n      JMEM_VALGRIND_NOACCESS_SPACE (prev_p, sizeof (jmem_heap_free_t));\n\n      ret_block_p = (uint8_t *) block_p - required_size;\n\n      /* Mark the the new block as undefined so that we are able to write to it. */\n      JMEM_VALGRIND_UNDEFINED_SPACE (ret_block_p, old_size);\n      /* The blocks are likely to overlap, so mark the old block as defined memory again. */\n      JMEM_VALGRIND_DEFINED_SPACE (block_p, old_size);\n      memmove (ret_block_p, block_p, old_size);\n\n      JMEM_VALGRIND_FREELIKE_SPACE (block_p);\n      JMEM_VALGRIND_MALLOCLIKE_SPACE (ret_block_p, new_size);\n      JMEM_VALGRIND_DEFINED_SPACE (ret_block_p, old_size);\n    }\n    else\n    {\n      JMEM_VALGRIND_NOACCESS_SPACE (prev_p, sizeof (jmem_heap_free_t));\n    }\n  }\n\n  if (ret_block_p != NULL)\n  {\n    /* Managed to extend the block. Update memory usage and the skip pointer. */\n    JERRY_CONTEXT (jmem_heap_list_skip_p) = prev_p;\n    JERRY_CONTEXT (jmem_heap_allocated_size) += required_size;\n\n    while (JERRY_CONTEXT (jmem_heap_allocated_size) >= JERRY_CONTEXT (jmem_heap_limit))\n    {\n      JERRY_CONTEXT (jmem_heap_limit) += CONFIG_GC_LIMIT;\n    }\n  }\n  else\n  {\n    /* Could not extend block. Allocate new region and copy the data. */\n    /* jmem_heap_alloc_block_internal will adjust the allocated_size, but insert_block will not,\n       so we reduce it here first, so that the limit calculation remains consistent. */\n    JERRY_CONTEXT (jmem_heap_allocated_size) -= aligned_old_size;\n    ret_block_p = jmem_heap_alloc_block_internal (new_size);\n\n    /* jmem_heap_alloc_block_internal may trigger garbage collection, which can create new free blocks\n     * in the heap structure, so we need to look up the previous block again. */\n    prev_p = jmem_heap_find_prev (block_p);\n\n    memcpy (ret_block_p, block_p, old_size);\n    jmem_heap_insert_block (block_p, prev_p, aligned_old_size);\n    /* jmem_heap_alloc_block_internal will call JMEM_VALGRIND_MALLOCLIKE_SPACE */\n    JMEM_VALGRIND_FREELIKE_SPACE (block_p);\n  }\n\n  JMEM_HEAP_STAT_FREE (old_size);\n  JMEM_HEAP_STAT_ALLOC (new_size);\n  return ret_block_p;\n#else /* JERRY_SYSTEM_ALLOCATOR */\n  const size_t required_size = new_size - old_size;\n\n#if !JERRY_MEM_GC_BEFORE_EACH_ALLOC\n  if (JERRY_CONTEXT (jmem_heap_allocated_size) + required_size >= JERRY_CONTEXT (jmem_heap_limit))\n  {\n    ecma_free_unused_memory (JMEM_PRESSURE_LOW);\n  }\n#else /* !JERRY_MEM_GC_BEFORE_EACH_ALLOC */\n  ecma_gc_run ();\n#endif /* JERRY_MEM_GC_BEFORE_EACH_ALLOC */\n\n  JERRY_CONTEXT (jmem_heap_allocated_size) += required_size;\n\n  while (JERRY_CONTEXT (jmem_heap_allocated_size) >= JERRY_CONTEXT (jmem_heap_limit))\n  {\n    JERRY_CONTEXT (jmem_heap_limit) += CONFIG_GC_LIMIT;\n  }\n\n  while (JERRY_CONTEXT (jmem_heap_allocated_size) + CONFIG_GC_LIMIT <= JERRY_CONTEXT (jmem_heap_limit))\n  {\n    JERRY_CONTEXT (jmem_heap_limit) -= CONFIG_GC_LIMIT;\n  }\n\n  JMEM_HEAP_STAT_FREE (old_size);\n  JMEM_HEAP_STAT_ALLOC (new_size);\n  return realloc (ptr, new_size);\n#endif /* !JERRY_SYSTEM_ALLOCATOR */\n}",
        "begin_line": 492,
        "end_line": 682,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-poolman.jmem_pools_alloc#58",
        "src_path": "jerry-core/jmem/jmem-poolman.c",
        "class_name": "jerry-core.jmem.jmem-poolman",
        "signature": "jerry-core.jmem.jmem-poolman.jmem_pools_alloc (size_t size) /**< size of the chunk */",
        "snippet": "extern inline void * JERRY_ATTR_HOT JERRY_ATTR_ALWAYS_INLINE\njmem_pools_alloc (size_t size) /**< size of the chunk */\n{\n#if JERRY_MEM_GC_BEFORE_EACH_ALLOC\n  ecma_gc_run ();\n#endif /* JERRY_MEM_GC_BEFORE_EACH_ALLOC */\n\n#if JERRY_CPOINTER_32_BIT\n  if (size <= 8)\n  {\n#else /* !JERRY_CPOINTER_32_BIT */\n    JERRY_ASSERT (size <= 8);\n#endif /* JERRY_CPOINTER_32_BIT */\n\n    if (JERRY_CONTEXT (jmem_free_8_byte_chunk_p) != NULL)\n    {\n      const jmem_pools_chunk_t *const chunk_p = JERRY_CONTEXT (jmem_free_8_byte_chunk_p);\n\n      JMEM_VALGRIND_DEFINED_SPACE (chunk_p, sizeof (jmem_pools_chunk_t));\n      JERRY_CONTEXT (jmem_free_8_byte_chunk_p) = chunk_p->next_p;\n      JMEM_VALGRIND_UNDEFINED_SPACE (chunk_p, sizeof (jmem_pools_chunk_t));\n\n      JMEM_HEAP_STAT_ALLOC (8);\n      return (void *) chunk_p;\n    }\n    else\n    {\n      void *chunk_p = jmem_heap_alloc_block_internal (8);\n      JMEM_HEAP_STAT_ALLOC (8);\n      return chunk_p;\n    }\n\n#if JERRY_CPOINTER_32_BIT\n  }\n\n  JERRY_ASSERT (size <= 16);\n\n  if (JERRY_CONTEXT (jmem_free_16_byte_chunk_p) != NULL)\n  {\n    const jmem_pools_chunk_t *const chunk_p = JERRY_CONTEXT (jmem_free_16_byte_chunk_p);\n\n    JMEM_VALGRIND_DEFINED_SPACE (chunk_p, sizeof (jmem_pools_chunk_t));\n    JERRY_CONTEXT (jmem_free_16_byte_chunk_p) = chunk_p->next_p;\n    JMEM_VALGRIND_UNDEFINED_SPACE (chunk_p, sizeof (jmem_pools_chunk_t));\n\n    JMEM_HEAP_STAT_ALLOC (16);\n    return (void *) chunk_p;\n  }\n  else\n  {\n    void *chunk_p = jmem_heap_alloc_block_internal (16);\n    JMEM_HEAP_STAT_ALLOC (16);\n    return chunk_p;\n  }\n#endif /* JERRY_CPOINTER_32_BIT */\n}",
        "begin_line": 58,
        "end_line": 113,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-poolman.jmem_pools_free#118",
        "src_path": "jerry-core/jmem/jmem-poolman.c",
        "class_name": "jerry-core.jmem.jmem-poolman",
        "signature": "jerry-core.jmem.jmem-poolman.jmem_pools_free (void *chunk_p, /**< pointer to the chunk */                  size_t size) /**< size of the chunk */",
        "snippet": "extern inline void JERRY_ATTR_HOT JERRY_ATTR_ALWAYS_INLINE\njmem_pools_free (void *chunk_p, /**< pointer to the chunk */\n                 size_t size) /**< size of the chunk */\n{\n  JERRY_ASSERT (chunk_p != NULL);\n  JMEM_HEAP_STAT_FREE (size);\n\n  jmem_pools_chunk_t *const chunk_to_free_p = (jmem_pools_chunk_t *) chunk_p;\n\n  JMEM_VALGRIND_DEFINED_SPACE (chunk_to_free_p, size);\n\n#if JERRY_CPOINTER_32_BIT\n  if (size <= 8)\n  {\n#else /* !JERRY_CPOINTER_32_BIT */\n    JERRY_ASSERT (size <= 8);\n#endif /* JERRY_CPOINTER_32_BIT */\n\n    chunk_to_free_p->next_p = JERRY_CONTEXT (jmem_free_8_byte_chunk_p);\n    JERRY_CONTEXT (jmem_free_8_byte_chunk_p) = chunk_to_free_p;\n\n#if JERRY_CPOINTER_32_BIT\n  }\n  else\n  {\n    JERRY_ASSERT (size <= 16);\n\n    chunk_to_free_p->next_p = JERRY_CONTEXT (jmem_free_16_byte_chunk_p);\n    JERRY_CONTEXT (jmem_free_16_byte_chunk_p) = chunk_to_free_p;\n  }\n#endif /* JERRY_CPOINTER_32_BIT */\n\n  JMEM_VALGRIND_NOACCESS_SPACE (chunk_to_free_p, size);\n}",
        "begin_line": 118,
        "end_line": 151,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-char-helpers.lit_char_is_white_space#134",
        "src_path": "jerry-core/lit/lit-char-helpers.c",
        "class_name": "jerry-core.lit.lit-char-helpers",
        "signature": "jerry-core.lit.lit-char-helpers.lit_char_is_white_space (lit_code_point_t c) /**< code point */",
        "snippet": "bool\nlit_char_is_white_space (lit_code_point_t c) /**< code point */\n{\n  if (c <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)\n  {\n    return (c == LIT_CHAR_SP || (c >= LIT_CHAR_TAB && c <= LIT_CHAR_CR));\n  }\n\n  if (c == LIT_CHAR_BOM\n#if !JERRY_ESNEXT\n      /* Mongolian Vowel Separator (u180e) used to be a whitespace character. */\n      || c == LIT_CHAR_MVS\n#endif /* !JERRY_ESNEXT */\n      || c == LIT_CHAR_LS\n      || c == LIT_CHAR_PS)\n  {\n    return true;\n  }\n\n  return (c <= LIT_UTF16_CODE_UNIT_MAX\n          && ((c >= lit_unicode_white_space_interval_starts[0]\n                 && c <= lit_unicode_white_space_interval_starts[0] + lit_unicode_white_space_interval_lengths[0])\n              || lit_search_char_in_array ((ecma_char_t) c,\n                                            lit_unicode_white_space_chars,\n                                            NUM_OF_ELEMENTS (lit_unicode_white_space_chars))));\n}",
        "begin_line": 134,
        "end_line": 159,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-char-helpers.lit_code_point_is_identifier_part#281",
        "src_path": "jerry-core/lit/lit-char-helpers.c",
        "class_name": "jerry-core.lit.lit-char-helpers",
        "signature": "jerry-core.lit.lit-char-helpers.lit_code_point_is_identifier_part (lit_code_point_t code_point) /**< code point */",
        "snippet": "bool\nlit_code_point_is_identifier_part (lit_code_point_t code_point) /**< code point */\n{\n  /* Fast path for ASCII-defined letters. */\n  if (code_point <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)\n  {\n    return ((LEXER_TO_ASCII_LOWERCASE (code_point) >= LIT_CHAR_LOWERCASE_A\n             && LEXER_TO_ASCII_LOWERCASE (code_point) <= LIT_CHAR_LOWERCASE_Z)\n            || (code_point >= LIT_CHAR_0 && code_point <= LIT_CHAR_9)\n            || code_point == LIT_CHAR_DOLLAR_SIGN\n            || code_point == LIT_CHAR_UNDERSCORE);\n  }\n\n  return lit_char_is_unicode_id_continue (code_point);\n}",
        "begin_line": 281,
        "end_line": 295,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-char-helpers.lit_code_point_is_identifier_start#261",
        "src_path": "jerry-core/lit/lit-char-helpers.c",
        "class_name": "jerry-core.lit.lit-char-helpers",
        "signature": "jerry-core.lit.lit-char-helpers.lit_code_point_is_identifier_start (lit_code_point_t code_point) /**< code point */",
        "snippet": "bool\nlit_code_point_is_identifier_start (lit_code_point_t code_point) /**< code point */\n{\n  /* Fast path for ASCII-defined letters. */\n  if (code_point <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)\n  {\n    return ((LEXER_TO_ASCII_LOWERCASE (code_point) >= LIT_CHAR_LOWERCASE_A\n             && LEXER_TO_ASCII_LOWERCASE (code_point) <= LIT_CHAR_LOWERCASE_Z)\n            || code_point == LIT_CHAR_DOLLAR_SIGN\n            || code_point == LIT_CHAR_UNDERSCORE);\n  }\n\n  return lit_char_is_unicode_id_start (code_point);\n}",
        "begin_line": 261,
        "end_line": 274,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_ex_count#31",
        "src_path": "jerry-core/lit/lit-magic-strings.c",
        "class_name": "jerry-core.lit.lit-magic-strings",
        "signature": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_ex_count (void)",
        "snippet": "extern inline uint32_t JERRY_ATTR_ALWAYS_INLINE\nlit_get_magic_string_ex_count (void)\n{\n  return JERRY_CONTEXT (lit_magic_string_ex_count);\n}",
        "begin_line": 31,
        "end_line": 35,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_size#67",
        "src_path": "jerry-core/lit/lit-magic-strings.c",
        "class_name": "jerry-core.lit.lit-magic-strings",
        "signature": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_size (uint32_t id) /**< magic string id */",
        "snippet": "lit_utf8_size_t\nlit_get_magic_string_size (uint32_t id) /**< magic string id */\n{\n  static const lit_magic_size_t lit_magic_string_sizes[] JERRY_ATTR_CONST_DATA =\n  {\n/** @cond doxygen_suppress */\n#define LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE(size, id)\n#define LIT_MAGIC_STRING_DEF(id, utf8_string) \\\n    sizeof(utf8_string) - 1,\n#include \"lit-magic-strings.inc.h\"\n#undef LIT_MAGIC_STRING_DEF\n#undef LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE\n/** @endcond */\n  };\n\n  JERRY_ASSERT (id < LIT_NON_INTERNAL_MAGIC_STRING__COUNT);\n\n  return lit_magic_string_sizes[id];\n}",
        "begin_line": 67,
        "end_line": 85,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_size_block_start#93",
        "src_path": "jerry-core/lit/lit-magic-strings.c",
        "class_name": "jerry-core.lit.lit-magic-strings",
        "signature": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_size_block_start (lit_utf8_size_t size) /**< magic string size */",
        "snippet": "static lit_magic_string_id_t\nlit_get_magic_string_size_block_start (lit_utf8_size_t size) /**< magic string size */\n{\n  static const lit_magic_string_id_t lit_magic_string_size_block_starts[] JERRY_ATTR_CONST_DATA =\n  {\n/** @cond doxygen_suppress */\n#define LIT_MAGIC_STRING_DEF(id, utf8_string)\n#define LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE(size, id) \\\n    id,\n#include \"lit-magic-strings.inc.h\"\n    LIT_NON_INTERNAL_MAGIC_STRING__COUNT\n#undef LIT_MAGIC_STRING_DEF\n#undef LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE\n/** @endcond */\n  };\n\n  JERRY_ASSERT (size <= (sizeof (lit_magic_string_size_block_starts) / sizeof (lit_magic_string_id_t)));\n\n  return lit_magic_string_size_block_starts[size];\n}",
        "begin_line": 93,
        "end_line": 112,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_utf8#42",
        "src_path": "jerry-core/lit/lit-magic-strings.c",
        "class_name": "jerry-core.lit.lit-magic-strings",
        "signature": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_utf8 (uint32_t id) /**< magic string id */",
        "snippet": "const lit_utf8_byte_t *\nlit_get_magic_string_utf8 (uint32_t id) /**< magic string id */\n{\n  static const lit_utf8_byte_t * const lit_magic_strings[] JERRY_ATTR_CONST_DATA =\n  {\n/** @cond doxygen_suppress */\n#define LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE(size, id)\n#define LIT_MAGIC_STRING_DEF(id, utf8_string) \\\n    (const lit_utf8_byte_t *) utf8_string,\n#include \"lit-magic-strings.inc.h\"\n#undef LIT_MAGIC_STRING_DEF\n#undef LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE\n/** @endcond */\n  };\n\n  JERRY_ASSERT (id < LIT_NON_INTERNAL_MAGIC_STRING__COUNT);\n\n  return lit_magic_strings[id];\n}",
        "begin_line": 42,
        "end_line": 60,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-magic-strings.lit_is_utf8_string_magic#202",
        "src_path": "jerry-core/lit/lit-magic-strings.c",
        "class_name": "jerry-core.lit.lit-magic-strings",
        "signature": "jerry-core.lit.lit-magic-strings.lit_is_utf8_string_magic (const lit_utf8_byte_t *string_p, /**< utf-8 string */                           lit_utf8_size_t string_size) /**< string size in bytes */",
        "snippet": "lit_magic_string_id_t\nlit_is_utf8_string_magic (const lit_utf8_byte_t *string_p, /**< utf-8 string */\n                          lit_utf8_size_t string_size) /**< string size in bytes */\n{\n  if (string_size > lit_get_magic_string_size (LIT_NON_INTERNAL_MAGIC_STRING__COUNT - 1))\n  {\n    return LIT_MAGIC_STRING__COUNT;\n  }\n\n  /**< The string must be in this id range. */\n  lit_utf8_size_t first = lit_get_magic_string_size_block_start (string_size);\n  lit_utf8_size_t last = lit_get_magic_string_size_block_start (string_size + 1);\n\n  while (first < last)\n  {\n    lit_utf8_size_t middle = ((first + last) / 2); /**< mid point of search */\n    int compare = memcmp (lit_get_magic_string_utf8 ((lit_magic_string_id_t) middle), string_p, string_size);\n\n    if (compare == 0)\n    {\n      return (lit_magic_string_id_t) middle;\n    }\n    else if (compare > 0)\n    {\n      last = middle;\n    }\n    else\n    {\n      first = middle + 1;\n    }\n  }\n\n  return LIT_MAGIC_STRING__COUNT;\n}",
        "begin_line": 202,
        "end_line": 235,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-magic-strings.lit_is_utf8_string_pair_magic#243",
        "src_path": "jerry-core/lit/lit-magic-strings.c",
        "class_name": "jerry-core.lit.lit-magic-strings",
        "signature": "jerry-core.lit.lit-magic-strings.lit_is_utf8_string_pair_magic (const lit_utf8_byte_t *string1_p, /**< first utf-8 string */                                lit_utf8_size_t string1_size, /**< first string size in bytes */                                const lit_utf8_byte_t *string2_p, /**< second utf-8 string */                                lit_utf8_size_t string2_size) /**< second string size in bytes */",
        "snippet": "lit_magic_string_id_t\nlit_is_utf8_string_pair_magic (const lit_utf8_byte_t *string1_p, /**< first utf-8 string */\n                               lit_utf8_size_t string1_size, /**< first string size in bytes */\n                               const lit_utf8_byte_t *string2_p, /**< second utf-8 string */\n                               lit_utf8_size_t string2_size) /**< second string size in bytes */\n{\n  lit_utf8_size_t total_string_size = string1_size + string2_size;\n\n  if (total_string_size > lit_get_magic_string_size (LIT_NON_INTERNAL_MAGIC_STRING__COUNT - 1))\n  {\n    return LIT_MAGIC_STRING__COUNT;\n  }\n\n  /**< The string must be in this id range. */\n  lit_utf8_size_t first = lit_get_magic_string_size_block_start (total_string_size);\n  lit_utf8_size_t last = lit_get_magic_string_size_block_start (total_string_size + 1);\n\n  while (first < last)\n  {\n    lit_utf8_size_t middle = ((first + last) / 2); /**< mid point of search */\n    const lit_utf8_byte_t *middle_string_p = lit_get_magic_string_utf8 ((lit_magic_string_id_t) middle);\n\n    int compare = memcmp (middle_string_p, string1_p, string1_size);\n\n    if (compare == 0)\n    {\n      compare = memcmp (middle_string_p + string1_size, string2_p, string2_size);\n    }\n\n    if (compare == 0)\n    {\n      return (lit_magic_string_id_t) middle;\n    }\n    else if (compare > 0)\n    {\n      last = middle;\n    }\n    else\n    {\n      first = middle + 1;\n    }\n  }\n\n  return LIT_MAGIC_STRING__COUNT;\n}",
        "begin_line": 243,
        "end_line": 287,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_get_unicode_char_size_by_utf8_first_byte#686",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_get_unicode_char_size_by_utf8_first_byte (const lit_utf8_byte_t first_byte) /**< buffer with characters */",
        "snippet": "extern inline lit_utf8_size_t JERRY_ATTR_ALWAYS_INLINE\nlit_get_unicode_char_size_by_utf8_first_byte (const lit_utf8_byte_t first_byte) /**< buffer with characters */\n{\n  if ((first_byte & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)\n  {\n    return 1;\n  }\n  else if ((first_byte & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)\n  {\n    return 2;\n  }\n  else\n  {\n    JERRY_ASSERT ((first_byte & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER);\n    return 3;\n  }\n}",
        "begin_line": 686,
        "end_line": 702,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_is_valid_cesu8_string#128",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_is_valid_cesu8_string (const lit_utf8_byte_t *cesu8_buf_p, /**< cesu-8 string */                            lit_utf8_size_t buf_size) /**< string size */",
        "snippet": "bool\nlit_is_valid_cesu8_string (const lit_utf8_byte_t *cesu8_buf_p, /**< cesu-8 string */\n                           lit_utf8_size_t buf_size) /**< string size */\n{\n  lit_utf8_size_t idx = 0;\n\n  while (idx < buf_size)\n  {\n    lit_utf8_byte_t c = cesu8_buf_p[idx++];\n    if ((c & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)\n    {\n      continue;\n    }\n\n    lit_code_point_t code_point = 0;\n    lit_code_point_t min_code_point = 0;\n    lit_utf8_size_t extra_bytes_count;\n    if ((c & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)\n    {\n      extra_bytes_count = 1;\n      min_code_point = LIT_UTF8_2_BYTE_CODE_POINT_MIN;\n      code_point = ((uint32_t) (c & LIT_UTF8_LAST_5_BITS_MASK));\n    }\n    else if ((c & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER)\n    {\n      extra_bytes_count = 2;\n      min_code_point = LIT_UTF8_3_BYTE_CODE_POINT_MIN;\n      code_point = ((uint32_t) (c & LIT_UTF8_LAST_4_BITS_MASK));\n    }\n    else\n    {\n      return false;\n    }\n\n    if (idx + extra_bytes_count > buf_size)\n    {\n      /* cesu-8 string breaks in the middle */\n      return false;\n    }\n\n    for (lit_utf8_size_t offset = 0; offset < extra_bytes_count; ++offset)\n    {\n      c = cesu8_buf_p[idx + offset];\n      if ((c & LIT_UTF8_EXTRA_BYTE_MASK) != LIT_UTF8_EXTRA_BYTE_MARKER)\n      {\n        /* invalid continuation byte */\n        return false;\n      }\n      code_point <<= LIT_UTF8_BITS_IN_EXTRA_BYTES;\n      code_point |= (c & LIT_UTF8_LAST_6_BITS_MASK);\n    }\n\n    if (code_point < min_code_point)\n    {\n      /* cesu-8 string doesn't encode valid unicode code point */\n      return false;\n    }\n\n    idx += extra_bytes_count;\n  }\n\n  return true;\n}",
        "begin_line": 128,
        "end_line": 190,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_is_valid_utf8_string#29",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_is_valid_utf8_string (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */                           lit_utf8_size_t buf_size, /**< string size */                           bool is_strict) /**< true if surrogate pairs are not allowed */",
        "snippet": "bool\nlit_is_valid_utf8_string (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */\n                          lit_utf8_size_t buf_size, /**< string size */\n                          bool is_strict) /**< true if surrogate pairs are not allowed */\n{\n  lit_utf8_size_t idx = 0;\n\n  bool is_prev_code_point_high_surrogate = false;\n  while (idx < buf_size)\n  {\n    lit_utf8_byte_t c = utf8_buf_p[idx++];\n    if ((c & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)\n    {\n      is_prev_code_point_high_surrogate = false;\n      continue;\n    }\n\n    lit_code_point_t code_point = 0;\n    lit_code_point_t min_code_point = 0;\n    lit_utf8_size_t extra_bytes_count;\n    if ((c & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)\n    {\n      extra_bytes_count = 1;\n      min_code_point = LIT_UTF8_2_BYTE_CODE_POINT_MIN;\n      code_point = ((uint32_t) (c & LIT_UTF8_LAST_5_BITS_MASK));\n    }\n    else if ((c & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER)\n    {\n      extra_bytes_count = 2;\n      min_code_point = LIT_UTF8_3_BYTE_CODE_POINT_MIN;\n      code_point = ((uint32_t) (c & LIT_UTF8_LAST_4_BITS_MASK));\n    }\n    else if ((c & LIT_UTF8_4_BYTE_MASK) == LIT_UTF8_4_BYTE_MARKER)\n    {\n      extra_bytes_count = 3;\n      min_code_point = LIT_UTF8_4_BYTE_CODE_POINT_MIN;\n      code_point = ((uint32_t) (c & LIT_UTF8_LAST_3_BITS_MASK));\n    }\n    else\n    {\n      /* utf-8 string could not contain 5- and 6-byte sequences. */\n      return false;\n    }\n\n    if (idx + extra_bytes_count > buf_size)\n    {\n      /* utf-8 string breaks in the middle */\n      return false;\n    }\n\n    for (lit_utf8_size_t offset = 0; offset < extra_bytes_count; ++offset)\n    {\n      c = utf8_buf_p[idx + offset];\n      if ((c & LIT_UTF8_EXTRA_BYTE_MASK) != LIT_UTF8_EXTRA_BYTE_MARKER)\n      {\n        /* invalid continuation byte */\n        return false;\n      }\n      code_point <<= LIT_UTF8_BITS_IN_EXTRA_BYTES;\n      code_point |= (c & LIT_UTF8_LAST_6_BITS_MASK);\n    }\n\n    if (code_point < min_code_point\n        || code_point > LIT_UNICODE_CODE_POINT_MAX)\n    {\n      /* utf-8 string doesn't encode valid unicode code point */\n      return false;\n    }\n\n    if (is_strict)\n    {\n      is_prev_code_point_high_surrogate = false;\n\n      if (code_point >= LIT_UTF16_HIGH_SURROGATE_MIN\n          && code_point <= LIT_UTF16_HIGH_SURROGATE_MAX)\n      {\n        is_prev_code_point_high_surrogate = true;\n      }\n      else if (code_point >= LIT_UTF16_LOW_SURROGATE_MIN\n               && code_point <= LIT_UTF16_LOW_SURROGATE_MAX\n               && is_prev_code_point_high_surrogate)\n      {\n        /* sequence of high and low surrogate is not allowed */\n        return false;\n      }\n    }\n\n    idx += extra_bytes_count;\n  }\n\n  return true;\n}",
        "begin_line": 29,
        "end_line": 120,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_read_code_unit_from_cesu8#426",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_read_code_unit_from_cesu8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */                                ecma_char_t *code_unit) /**< [out] code unit */",
        "snippet": "lit_utf8_size_t\nlit_read_code_unit_from_cesu8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */\n                               ecma_char_t *code_unit) /**< [out] code unit */\n{\n  JERRY_ASSERT (buf_p);\n\n  lit_utf8_byte_t c = buf_p[0];\n  if ((c & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)\n  {\n    *code_unit = (ecma_char_t) (c & LIT_UTF8_LAST_7_BITS_MASK);\n    return 1;\n  }\n\n  lit_code_point_t ret = LIT_UNICODE_CODE_POINT_NULL;\n  lit_utf8_size_t bytes_count;\n\n  if ((c & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)\n  {\n    bytes_count = 2;\n    ret = ((lit_code_point_t) (c & LIT_UTF8_LAST_5_BITS_MASK));\n  }\n  else\n  {\n    JERRY_ASSERT ((c & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER);\n    bytes_count = 3;\n    ret = ((lit_code_point_t) (c & LIT_UTF8_LAST_4_BITS_MASK));\n  }\n\n  for (uint32_t i = 1; i < bytes_count; ++i)\n  {\n    ret <<= LIT_UTF8_BITS_IN_EXTRA_BYTES;\n    ret |= (buf_p[i] & LIT_UTF8_LAST_6_BITS_MASK);\n  }\n\n  JERRY_ASSERT (ret <= LIT_UTF16_CODE_UNIT_MAX);\n  *code_unit = (ecma_char_t) ret;\n  return bytes_count;\n}",
        "begin_line": 426,
        "end_line": 463,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_read_prev_code_unit_from_utf8#508",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_read_prev_code_unit_from_utf8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */                                    ecma_char_t *code_point) /**< [out] code point */",
        "snippet": "lit_utf8_size_t\nlit_read_prev_code_unit_from_utf8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */\n                                   ecma_char_t *code_point) /**< [out] code point */\n{\n  JERRY_ASSERT (buf_p);\n\n  lit_utf8_decr (&buf_p);\n  return lit_read_code_unit_from_cesu8 (buf_p, code_point);\n}",
        "begin_line": 508,
        "end_line": 516,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_utf8_decr#597",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_utf8_decr (const lit_utf8_byte_t **buf_p) /**< [in, out] buffer with characters */",
        "snippet": "void\nlit_utf8_decr (const lit_utf8_byte_t **buf_p) /**< [in,out] buffer with characters */\n{\n  JERRY_ASSERT (*buf_p);\n  const lit_utf8_byte_t *current_p = *buf_p;\n\n  do\n  {\n    current_p--;\n  }\n  while ((*(current_p) & LIT_UTF8_EXTRA_BYTE_MASK) == LIT_UTF8_EXTRA_BYTE_MARKER);\n\n  *buf_p = current_p;\n}",
        "begin_line": 597,
        "end_line": 610,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_utf8_string_calc_hash#645",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_utf8_string_calc_hash (const lit_utf8_byte_t *utf8_buf_p, /**< characters buffer */                            lit_utf8_size_t utf8_buf_size) /**< number of characters in the buffer */",
        "snippet": "extern inline lit_string_hash_t JERRY_ATTR_ALWAYS_INLINE\nlit_utf8_string_calc_hash (const lit_utf8_byte_t *utf8_buf_p, /**< characters buffer */\n                           lit_utf8_size_t utf8_buf_size) /**< number of characters in the buffer */\n{\n  JERRY_ASSERT (utf8_buf_p != NULL || utf8_buf_size == 0);\n\n  /* 32 bit offset_basis for FNV = 2166136261 */\n  return lit_utf8_string_hash_combine ((lit_string_hash_t) 2166136261, utf8_buf_p, utf8_buf_size);\n}",
        "begin_line": 645,
        "end_line": 653,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_utf8_string_hash_combine#622",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_utf8_string_hash_combine (lit_string_hash_t hash_basis, /**< hash to be combined with */                               const lit_utf8_byte_t *utf8_buf_p, /**< characters buffer */                               lit_utf8_size_t utf8_buf_size) /**< number of characters in the buffer */",
        "snippet": "extern inline lit_string_hash_t JERRY_ATTR_ALWAYS_INLINE\nlit_utf8_string_hash_combine (lit_string_hash_t hash_basis, /**< hash to be combined with */\n                              const lit_utf8_byte_t *utf8_buf_p, /**< characters buffer */\n                              lit_utf8_size_t utf8_buf_size) /**< number of characters in the buffer */\n{\n  JERRY_ASSERT (utf8_buf_p != NULL || utf8_buf_size == 0);\n\n  uint32_t hash = hash_basis;\n\n  for (uint32_t i = 0; i < utf8_buf_size; i++)\n  {\n    /* 16777619 is 32 bit FNV_prime = 2^24 + 2^8 + 0x93 = 16777619 */\n    hash = (hash ^ utf8_buf_p[i]) * 16777619;\n  }\n\n  return (lit_string_hash_t) hash;\n}",
        "begin_line": 622,
        "end_line": 638,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_utf8_string_length#291",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_utf8_string_length (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */                         lit_utf8_size_t utf8_buf_size) /**< string size */",
        "snippet": "lit_utf8_size_t\nlit_utf8_string_length (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */\n                        lit_utf8_size_t utf8_buf_size) /**< string size */\n{\n  lit_utf8_size_t length = 0;\n  lit_utf8_size_t size = 0;\n\n  while (size < utf8_buf_size)\n  {\n    size += lit_get_unicode_char_size_by_utf8_first_byte (*(utf8_buf_p + size));\n    length++;\n  }\n\n  JERRY_ASSERT (size == utf8_buf_size);\n\n  return length;\n}",
        "begin_line": 291,
        "end_line": 307,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_zt_utf8_string_size#279",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_zt_utf8_string_size (const lit_utf8_byte_t *utf8_str_p) /**< zero-terminated utf-8 string */",
        "snippet": "lit_utf8_size_t\nlit_zt_utf8_string_size (const lit_utf8_byte_t *utf8_str_p) /**< zero-terminated utf-8 string */\n{\n  JERRY_ASSERT (utf8_str_p != NULL);\n  return (lit_utf8_size_t) strlen ((const char *) utf8_str_p);\n}",
        "begin_line": 279,
        "end_line": 284,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_check_arrow#2030",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_check_arrow (parser_context_t *context_p) /**< context */",
        "snippet": "bool\nlexer_check_arrow (parser_context_t *context_p) /**< context */\n{\n  if (!(context_p->token.flags & LEXER_NO_SKIP_SPACES))\n  {\n    lexer_skip_spaces (context_p);\n    context_p->token.flags = (uint8_t) (context_p->token.flags | LEXER_NO_SKIP_SPACES);\n  }\n\n  return (!(context_p->token.flags & LEXER_WAS_NEWLINE)\n          && context_p->source_p + 2 <= context_p->source_end_p\n          && context_p->source_p[0] == (uint8_t) LIT_CHAR_EQUALS\n          && context_p->source_p[1] == (uint8_t) LIT_CHAR_GREATER_THAN);\n}",
        "begin_line": 2030,
        "end_line": 2043,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_check_next_character#1918",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_check_next_character (parser_context_t *context_p, /**< context */                             lit_utf8_byte_t character) /**< specified character */",
        "snippet": "bool\nlexer_check_next_character (parser_context_t *context_p, /**< context */\n                            lit_utf8_byte_t character) /**< specified character */\n{\n  if (!(context_p->token.flags & LEXER_NO_SKIP_SPACES))\n  {\n    lexer_skip_spaces (context_p);\n    context_p->token.flags = (uint8_t) (context_p->token.flags | LEXER_NO_SKIP_SPACES);\n  }\n\n  return (context_p->source_p < context_p->source_end_p\n          && context_p->source_p[0] == (uint8_t) character);\n}",
        "begin_line": 1918,
        "end_line": 1930,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_check_next_characters#1938",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_check_next_characters (parser_context_t *context_p, /**< context */                              lit_utf8_byte_t character1, /**< first alternative character */                              lit_utf8_byte_t character2) /**< second alternative character */",
        "snippet": "bool\nlexer_check_next_characters (parser_context_t *context_p, /**< context */\n                             lit_utf8_byte_t character1, /**< first alternative character */\n                             lit_utf8_byte_t character2) /**< second alternative character */\n{\n  if (!(context_p->token.flags & LEXER_NO_SKIP_SPACES))\n  {\n    lexer_skip_spaces (context_p);\n    context_p->token.flags = (uint8_t) (context_p->token.flags | LEXER_NO_SKIP_SPACES);\n  }\n\n  return (context_p->source_p < context_p->source_end_p\n          && (context_p->source_p[0] == (uint8_t) character1\n              || context_p->source_p[0] == (uint8_t) character2));\n}",
        "begin_line": 1938,
        "end_line": 1952,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_check_numbers#1285",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_check_numbers (parser_context_t *context_p, /**< context */                      const uint8_t **source_p, /**< source_pointer */                      const uint8_t *source_end_p, /**< end of the source */                      const ecma_char_t digit_max, /**< maximum of the number range */                      const bool is_legacy) /**< is legacy octal number  */",
        "snippet": "static void\nlexer_check_numbers (parser_context_t *context_p, /**< context */\n                     const uint8_t **source_p, /**< source_pointer */\n                     const uint8_t *source_end_p, /**< end of the source */\n                     const ecma_char_t digit_max, /**< maximum of the number range */\n                     const bool is_legacy) /**< is legacy octal number  */\n{\n#if !JERRY_ESNEXT\n  JERRY_UNUSED (context_p);\n  JERRY_UNUSED (is_legacy);\n#endif /* !JERRY_ESNEXT */\n  while (true)\n  {\n    while (*source_p < source_end_p\n           && *source_p[0] >= LIT_CHAR_0\n           && *source_p[0] <= digit_max)\n    {\n      *source_p += 1;\n    }\n#if JERRY_ESNEXT\n    if (*source_p != source_end_p && *source_p[0] == LIT_CHAR_UNDERSCORE)\n    {\n      *source_p += 1;\n      if (is_legacy\n          || *source_p == source_end_p\n          || *source_p[0] == LIT_CHAR_UNDERSCORE\n          || *source_p[0] > digit_max\n          || *source_p[0] < LIT_CHAR_0)\n      {\n        parser_raise_error (context_p, PARSER_ERR_INVALID_UNDERSCORE_IN_NUMBER);\n      }\n      continue;\n    }\n#endif /* JERRY_ESNEXT */\n\n    break;\n  }\n}",
        "begin_line": 1285,
        "end_line": 1322,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_check_property_modifier#3406",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_check_property_modifier (parser_context_t *context_p) /**< context */",
        "snippet": "void\nlexer_check_property_modifier (parser_context_t *context_p) /**< context */\n{\n  JERRY_ASSERT (!(context_p->token.flags & LEXER_NO_SKIP_SPACES));\n  JERRY_ASSERT (context_p->token.type == LEXER_LITERAL\n                && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);\n\n  lexer_skip_spaces (context_p);\n  context_p->token.flags = (uint8_t) (context_p->token.flags | LEXER_NO_SKIP_SPACES);\n\n  if (context_p->source_p >= context_p->source_end_p\n#if JERRY_ESNEXT\n      || context_p->source_p[0] == LIT_CHAR_COMMA\n      || context_p->source_p[0] == LIT_CHAR_RIGHT_BRACE\n      || context_p->source_p[0] == LIT_CHAR_LEFT_PAREN\n      || context_p->source_p[0] == LIT_CHAR_EQUALS\n#endif /* JERRY_ESNEXT */\n      || context_p->source_p[0] == LIT_CHAR_COLON)\n  {\n    return;\n  }\n\n  if (lexer_compare_literal_to_string (context_p, \"get\", 3))\n  {\n    context_p->token.type = LEXER_PROPERTY_GETTER;\n    return;\n  }\n\n  if (lexer_compare_literal_to_string (context_p, \"set\", 3))\n  {\n    context_p->token.type = LEXER_PROPERTY_SETTER;\n    return;\n  }\n\n#if JERRY_ESNEXT\n  if (lexer_compare_literal_to_string (context_p, \"async\", 5))\n  {\n    context_p->token.type = LEXER_KEYW_ASYNC;\n    return;\n  }\n#endif /* JERRY_ESNEXT */\n}",
        "begin_line": 3406,
        "end_line": 3447,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_compare_identifier_to_string#3519",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_compare_identifier_to_string (const lexer_lit_location_t *left_p, /**< left literal */                                     const uint8_t *right_p, /**< right identifier string */                                     size_t size) /**< byte size of the right identifier */",
        "snippet": "bool\nlexer_compare_identifier_to_string (const lexer_lit_location_t *left_p, /**< left literal */\n                                    const uint8_t *right_p, /**< right identifier string */\n                                    size_t size) /**< byte size of the right identifier */\n{\n  if (left_p->length != size)\n  {\n    return false;\n  }\n\n  if (!(left_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE))\n  {\n    return memcmp (left_p->char_p, right_p, size) == 0;\n  }\n\n  return lexer_compare_identifier_to_chars (left_p->char_p, right_p, size);\n}",
        "begin_line": 3519,
        "end_line": 3535,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_construct_function_object#2866",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_construct_function_object (parser_context_t *context_p, /**< context */                                  uint32_t extra_status_flags) /**< extra status flags */",
        "snippet": "uint16_t\nlexer_construct_function_object (parser_context_t *context_p, /**< context */\n                                 uint32_t extra_status_flags) /**< extra status flags */\n{\n  ecma_compiled_code_t *compiled_code_p;\n  lexer_literal_t *literal_p;\n  uint16_t result_index;\n\n  if (context_p->status_flags & PARSER_INSIDE_WITH)\n  {\n    extra_status_flags |= PARSER_INSIDE_WITH;\n  }\n\n  literal_p = lexer_construct_unused_literal (context_p);\n  result_index = context_p->literal_count;\n  context_p->literal_count++;\n\n  parser_flush_cbc (context_p);\n\n#if JERRY_ESNEXT\n  if (JERRY_LIKELY (!(extra_status_flags & PARSER_IS_ARROW_FUNCTION)))\n  {\n    compiled_code_p = parser_parse_function (context_p, extra_status_flags);\n  }\n  else\n  {\n    compiled_code_p = parser_parse_arrow_function (context_p, extra_status_flags);\n  }\n#else /* !JERRY_ESNEXT */\n  compiled_code_p = parser_parse_function (context_p, extra_status_flags);\n#endif /* JERRY_ESNEXT */\n\n  literal_p->u.bytecode_p = compiled_code_p;\n  literal_p->type = LEXER_FUNCTION_LITERAL;\n\n  return result_index;\n}",
        "begin_line": 2866,
        "end_line": 2902,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_construct_literal_object#2514",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_construct_literal_object (parser_context_t *context_p, /**< context */                                 const lexer_lit_location_t *lit_location_p, /**< literal location */                                 uint8_t literal_type) /**< final literal type */",
        "snippet": "void\nlexer_construct_literal_object (parser_context_t *context_p, /**< context */\n                                const lexer_lit_location_t *lit_location_p, /**< literal location */\n                                uint8_t literal_type) /**< final literal type */\n{\n  uint8_t local_byte_array[LEXER_MAX_LITERAL_LOCAL_BUFFER_SIZE];\n\n  const uint8_t *char_p = lexer_convert_literal_to_chars (context_p,\n                                                          lit_location_p,\n                                                          local_byte_array,\n                                                          LEXER_STRING_NO_OPTS);\n\n  size_t length = lit_location_p->length;\n  parser_list_iterator_t literal_iterator;\n  lexer_literal_t *literal_p;\n  uint32_t literal_index = 0;\n  bool search_scope_stack = (literal_type == LEXER_IDENT_LITERAL);\n\n  if (JERRY_UNLIKELY (literal_type == LEXER_NEW_IDENT_LITERAL))\n  {\n    literal_type = LEXER_IDENT_LITERAL;\n  }\n\n  JERRY_ASSERT (literal_type == LEXER_IDENT_LITERAL\n                || literal_type == LEXER_STRING_LITERAL);\n\n  JERRY_ASSERT (literal_type != LEXER_IDENT_LITERAL || length <= PARSER_MAXIMUM_IDENT_LENGTH);\n  JERRY_ASSERT (literal_type != LEXER_STRING_LITERAL || length <= PARSER_MAXIMUM_STRING_LENGTH);\n\n  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n\n  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n    if (literal_p->type == literal_type\n        && literal_p->prop.length == length\n        && memcmp (literal_p->u.char_p, char_p, length) == 0)\n    {\n      context_p->lit_object.literal_p = literal_p;\n      context_p->lit_object.index = (uint16_t) literal_index;\n\n      parser_free_allocated_buffer (context_p);\n\n      if (search_scope_stack)\n      {\n        parser_scope_stack_t *scope_stack_start_p = context_p->scope_stack_p;\n        parser_scope_stack_t *scope_stack_p = scope_stack_start_p + context_p->scope_stack_top;\n\n        while (scope_stack_p > scope_stack_start_p)\n        {\n          scope_stack_p--;\n\n          if (scope_stack_p->map_from == literal_index)\n          {\n            JERRY_ASSERT (scanner_decode_map_to (scope_stack_p) >= PARSER_REGISTER_START\n                          || (literal_p->status_flags & LEXER_FLAG_USED));\n            context_p->lit_object.index = scanner_decode_map_to (scope_stack_p);\n            return;\n          }\n        }\n\n        literal_p->status_flags |= LEXER_FLAG_USED;\n      }\n      return;\n    }\n\n    literal_index++;\n  }\n\n  JERRY_ASSERT (literal_index == context_p->literal_count);\n\n  if (literal_index >= PARSER_MAXIMUM_NUMBER_OF_LITERALS)\n  {\n    parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);\n  }\n\n  literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);\n  literal_p->prop.length = (prop_length_t) length;\n  literal_p->type = literal_type;\n\n  uint8_t status_flags = LEXER_FLAG_SOURCE_PTR;\n\n  if (length > 0 && char_p == local_byte_array)\n  {\n    literal_p->u.char_p = (uint8_t *) jmem_heap_alloc_block (length);\n    memcpy ((uint8_t *) literal_p->u.char_p, char_p, length);\n    status_flags = 0;\n  }\n  else\n  {\n    literal_p->u.char_p = char_p;\n\n    /* Buffer is taken over when a new literal is constructed. */\n    if (context_p->u.allocated_buffer_p != NULL)\n    {\n      JERRY_ASSERT (char_p == context_p->u.allocated_buffer_p);\n\n      context_p->u.allocated_buffer_p = NULL;\n      status_flags = 0;\n    }\n  }\n\n  if (search_scope_stack)\n  {\n    status_flags |= LEXER_FLAG_USED;\n  }\n\n  if (lit_location_p->status_flags & LEXER_LIT_LOCATION_IS_ASCII)\n  {\n    literal_p->status_flags |= LEXER_FLAG_ASCII;\n  }\n\n  literal_p->status_flags = status_flags;\n\n  context_p->lit_object.literal_p = literal_p;\n  context_p->lit_object.index = (uint16_t) literal_index;\n  context_p->literal_count++;\n\n  JERRY_ASSERT (context_p->u.allocated_buffer_p == NULL);\n}",
        "begin_line": 2514,
        "end_line": 2632,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_construct_number_object#2639",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_construct_number_object (parser_context_t *context_p, /**< context */                                bool is_expr, /**< expression is parsed */                                bool is_negative_number) /**< sign is negative */",
        "snippet": "bool\nlexer_construct_number_object (parser_context_t *context_p, /**< context */\n                               bool is_expr, /**< expression is parsed */\n                               bool is_negative_number) /**< sign is negative */\n{\n  parser_list_iterator_t literal_iterator;\n  lexer_literal_t *literal_p;\n  ecma_value_t lit_value;\n  uint32_t literal_index = 0;\n  prop_length_t length = context_p->token.lit_location.length;\n\n#if JERRY_BUILTIN_BIGINT\n  if (JERRY_LIKELY (context_p->token.extra_value != LEXER_NUMBER_BIGINT))\n  {\n#endif /* JERRY_BUILTIN_BIGINT */\n    ecma_number_t num;\n\n    if (context_p->token.extra_value < LEXER_NUMBER_OCTAL)\n    {\n#if JERRY_ESNEXT\n      num = ecma_utf8_string_to_number (context_p->token.lit_location.char_p,\n                                        length,\n                                        ECMA_CONVERSION_ALLOW_UNDERSCORE);\n#else\n      num = ecma_utf8_string_to_number (context_p->token.lit_location.char_p, length, 0);\n#endif /* JERRY_ESNEXT */\n    }\n    else\n    {\n      const uint8_t *src_p = context_p->token.lit_location.char_p;\n      const uint8_t *src_end_p = src_p + length - 1;\n      ecma_number_t multiplier = 8.0;\n\n      JERRY_ASSERT (src_p[0] == LIT_CHAR_0);\n\n#if JERRY_ESNEXT\n      if (context_p->token.extra_value == LEXER_NUMBER_BINARY)\n      {\n        src_p++;\n        multiplier = 2.0;\n      }\n      else if (LEXER_TO_ASCII_LOWERCASE (src_p[1]) == LIT_CHAR_LOWERCASE_O)\n      {\n        src_p++;\n      }\n#endif /* JERRY_ESNEXT */\n\n      num = 0;\n      do\n      {\n        if (src_p[1] == LIT_CHAR_UNDERSCORE)\n        {\n          src_p++;\n        }\n        num = num * multiplier + (ecma_number_t) (*(++src_p) - LIT_CHAR_0);\n      }\n      while (src_p < src_end_p);\n    }\n\n    if (is_expr)\n    {\n      int32_t int_num = (int32_t) num;\n\n      if (int_num == num\n          && int_num <= CBC_PUSH_NUMBER_BYTE_RANGE_END\n          && (int_num != 0 || !is_negative_number))\n      {\n        context_p->lit_object.index = (uint16_t) int_num;\n        return true;\n      }\n    }\n\n    if (is_negative_number)\n    {\n      num = -num;\n    }\n\n    lit_value = ecma_find_or_create_literal_number (num);\n#if JERRY_BUILTIN_BIGINT\n  }\n  else\n  {\n    uint32_t options = (ECMA_BIGINT_PARSE_DISALLOW_SYNTAX_ERROR\n                        | ECMA_BIGINT_PARSE_DISALLOW_MEMORY_ERROR\n                        | ECMA_BIGINT_PARSE_ALLOW_UNDERSCORE);\n\n    if (is_negative_number)\n    {\n      options |= ECMA_BIGINT_PARSE_SET_NEGATIVE;\n    }\n\n    JERRY_ASSERT (length >= 2);\n    lit_value = ecma_bigint_parse_string (context_p->token.lit_location.char_p,\n                                          (lit_utf8_size_t) (length - 1),\n                                          options);\n\n    JERRY_ASSERT (lit_value != ECMA_VALUE_FALSE && !ECMA_IS_VALUE_ERROR (lit_value));\n\n    if (lit_value == ECMA_VALUE_NULL)\n    {\n      parser_raise_error (context_p, PARSER_ERR_OUT_OF_MEMORY);\n    }\n\n    lit_value = ecma_find_or_create_literal_bigint (lit_value);\n  }\n#endif /* JERRY_BUILTIN_BIGINT */\n\n  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n\n  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n    if (literal_p->type == LEXER_NUMBER_LITERAL\n        && literal_p->u.value == lit_value)\n    {\n      context_p->lit_object.literal_p = literal_p;\n      context_p->lit_object.index = (uint16_t) literal_index;\n      return false;\n    }\n\n    literal_index++;\n  }\n\n  JERRY_ASSERT (literal_index == context_p->literal_count);\n\n  if (literal_index >= PARSER_MAXIMUM_NUMBER_OF_LITERALS)\n  {\n    parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);\n  }\n\n  literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);\n  literal_p->u.value = lit_value;\n  literal_p->prop.length = 0; /* Unused. */\n  literal_p->type = LEXER_NUMBER_LITERAL;\n  literal_p->status_flags = 0;\n\n  context_p->lit_object.literal_p = literal_p;\n  context_p->lit_object.index = (uint16_t) literal_index;\n\n  context_p->literal_count++;\n  return false;\n}",
        "begin_line": 2639,
        "end_line": 2779,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_construct_unused_literal#2495",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_construct_unused_literal (parser_context_t *context_p) /**< context */",
        "snippet": "lexer_literal_t *\nlexer_construct_unused_literal (parser_context_t *context_p) /**< context */\n{\n  lexer_literal_t *literal_p;\n\n  if (context_p->literal_count >= PARSER_MAXIMUM_NUMBER_OF_LITERALS)\n  {\n    parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);\n  }\n\n  literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);\n  literal_p->type = LEXER_UNUSED_LITERAL;\n  literal_p->status_flags = 0;\n  return literal_p;\n}",
        "begin_line": 2495,
        "end_line": 2509,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_consume_generator#2111",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_consume_generator (parser_context_t *context_p) /**< context */",
        "snippet": "bool\nlexer_consume_generator (parser_context_t *context_p) /**< context */\n{\n  if (!(context_p->token.flags & LEXER_NO_SKIP_SPACES))\n  {\n    lexer_skip_spaces (context_p);\n    context_p->token.flags = (uint8_t) (context_p->token.flags | LEXER_NO_SKIP_SPACES);\n  }\n\n  if (context_p->source_p >= context_p->source_end_p\n      || context_p->source_p[0] != LIT_CHAR_ASTERISK\n      || (context_p->source_p + 1 < context_p->source_end_p\n          && (context_p->source_p[1] == LIT_CHAR_EQUALS || context_p->source_p[1] == LIT_CHAR_ASTERISK)))\n  {\n    return false;\n  }\n\n  lexer_consume_next_character (context_p);\n  context_p->token.type = LEXER_MULTIPLY;\n  return true;\n}",
        "begin_line": 2111,
        "end_line": 2131,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_convert_literal_to_chars#2251",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_convert_literal_to_chars (parser_context_t *context_p, /**< context */                                 const lexer_lit_location_t *literal_p, /**< literal location */                                 uint8_t *local_byte_array_p, /**< local byte array to store chars */                                 lexer_string_options_t opts) /**< options */",
        "snippet": "const uint8_t *\nlexer_convert_literal_to_chars (parser_context_t *context_p, /**< context */\n                                const lexer_lit_location_t *literal_p, /**< literal location */\n                                uint8_t *local_byte_array_p, /**< local byte array to store chars */\n                                lexer_string_options_t opts) /**< options */\n{\n  JERRY_ASSERT (context_p->u.allocated_buffer_p == NULL);\n\n  if (!(literal_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE))\n  {\n    return literal_p->char_p;\n  }\n\n  uint8_t *destination_start_p;\n  if (literal_p->length > LEXER_MAX_LITERAL_LOCAL_BUFFER_SIZE)\n  {\n    context_p->u.allocated_buffer_p = (uint8_t *) parser_malloc_local (context_p, literal_p->length);\n    context_p->allocated_buffer_size = literal_p->length;\n    destination_start_p = context_p->u.allocated_buffer_p;\n  }\n  else\n  {\n    destination_start_p = local_byte_array_p;\n  }\n\n  if (literal_p->type == LEXER_IDENT_LITERAL)\n  {\n    lexer_convert_ident_to_cesu8 (destination_start_p, literal_p->char_p, literal_p->length);\n    return destination_start_p;\n  }\n\n  const uint8_t *source_p = literal_p->char_p;\n  uint8_t *destination_p = destination_start_p;\n\n  uint8_t str_end_character = source_p[-1];\n\n#if JERRY_ESNEXT\n  if (str_end_character == LIT_CHAR_RIGHT_BRACE)\n  {\n    str_end_character = LIT_CHAR_GRAVE_ACCENT;\n  }\n\n  bool is_raw = (opts & LEXER_STRING_RAW) != 0;\n#else /* !JERRY_ESNEXT */\n  JERRY_UNUSED (opts);\n  bool is_raw = false;\n#endif /* JERRY_ESNEXT */\n\n  while (true)\n  {\n    if (*source_p == str_end_character)\n    {\n      break;\n    }\n\n    if (*source_p == LIT_CHAR_BACKSLASH && !is_raw)\n    {\n      uint8_t conv_character;\n\n      source_p++;\n      JERRY_ASSERT (source_p < context_p->source_end_p);\n\n      /* Newline is ignored. */\n      if (*source_p == LIT_CHAR_CR)\n      {\n        source_p++;\n        JERRY_ASSERT (source_p < context_p->source_end_p);\n\n        if (*source_p == LIT_CHAR_LF)\n        {\n          source_p++;\n        }\n        continue;\n      }\n      else if (*source_p == LIT_CHAR_LF)\n      {\n        source_p++;\n        continue;\n      }\n      else if (*source_p == LEXER_NEWLINE_LS_PS_BYTE_1 && LEXER_NEWLINE_LS_PS_BYTE_23 (source_p))\n      {\n        source_p += 3;\n        continue;\n      }\n\n      if (*source_p >= LIT_CHAR_0 && *source_p <= LIT_CHAR_3)\n      {\n        lit_code_point_t octal_number = (uint32_t) (*source_p - LIT_CHAR_0);\n\n        source_p++;\n        JERRY_ASSERT (source_p < context_p->source_end_p);\n\n        if (*source_p >= LIT_CHAR_0 && *source_p <= LIT_CHAR_7)\n        {\n          octal_number = octal_number * 8 + (uint32_t) (*source_p - LIT_CHAR_0);\n          source_p++;\n          JERRY_ASSERT (source_p < context_p->source_end_p);\n\n          if (*source_p >= LIT_CHAR_0 && *source_p <= LIT_CHAR_7)\n          {\n            octal_number = octal_number * 8 + (uint32_t) (*source_p - LIT_CHAR_0);\n            source_p++;\n            JERRY_ASSERT (source_p < context_p->source_end_p);\n          }\n        }\n\n        destination_p += lit_code_point_to_cesu8_bytes (destination_p, octal_number);\n        continue;\n      }\n\n      if (*source_p >= LIT_CHAR_4 && *source_p <= LIT_CHAR_7)\n      {\n        uint32_t octal_number = (uint32_t) (*source_p - LIT_CHAR_0);\n\n        source_p++;\n        JERRY_ASSERT (source_p < context_p->source_end_p);\n\n        if (*source_p >= LIT_CHAR_0 && *source_p <= LIT_CHAR_7)\n        {\n          octal_number = octal_number * 8 + (uint32_t) (*source_p - LIT_CHAR_0);\n          source_p++;\n          JERRY_ASSERT (source_p < context_p->source_end_p);\n        }\n\n        *destination_p++ = (uint8_t) octal_number;\n        continue;\n      }\n\n      if (*source_p == LIT_CHAR_LOWERCASE_X || *source_p == LIT_CHAR_LOWERCASE_U)\n      {\n        source_p++;\n        destination_p += lit_code_point_to_cesu8_bytes (destination_p,\n                                                        lexer_unchecked_hex_to_character (&source_p));\n        continue;\n      }\n\n      conv_character = *source_p;\n      switch (*source_p)\n      {\n        case LIT_CHAR_LOWERCASE_B:\n        {\n          conv_character = 0x08;\n          break;\n        }\n        case LIT_CHAR_LOWERCASE_T:\n        {\n          conv_character = 0x09;\n          break;\n        }\n        case LIT_CHAR_LOWERCASE_N:\n        {\n          conv_character = 0x0a;\n          break;\n        }\n        case LIT_CHAR_LOWERCASE_V:\n        {\n          conv_character = 0x0b;\n          break;\n        }\n        case LIT_CHAR_LOWERCASE_F:\n        {\n          conv_character = 0x0c;\n          break;\n        }\n        case LIT_CHAR_LOWERCASE_R:\n        {\n          conv_character = 0x0d;\n          break;\n        }\n      }\n\n      if (conv_character != *source_p)\n      {\n        *destination_p++ = conv_character;\n        source_p++;\n        continue;\n      }\n    }\n#if JERRY_ESNEXT\n    else if (str_end_character == LIT_CHAR_GRAVE_ACCENT)\n    {\n      if (source_p[0] == LIT_CHAR_DOLLAR_SIGN\n          && source_p[1] == LIT_CHAR_LEFT_BRACE)\n      {\n        source_p++;\n        JERRY_ASSERT (source_p < context_p->source_end_p);\n        break;\n      }\n      if (*source_p == LIT_CHAR_CR)\n      {\n        *destination_p++ = LIT_CHAR_LF;\n        source_p++;\n        if (*source_p != str_end_character\n            && *source_p == LIT_CHAR_LF)\n        {\n          source_p++;\n        }\n        continue;\n      }\n      if ((*source_p == LIT_CHAR_BACKSLASH) && is_raw)\n      {\n        JERRY_ASSERT (source_p + 1 < context_p->source_end_p);\n        if ((*(source_p + 1) == LIT_CHAR_GRAVE_ACCENT) || (*(source_p + 1) == LIT_CHAR_BACKSLASH))\n        {\n          *destination_p++ = *source_p++;\n          *destination_p++ = *source_p++;\n          continue;\n        }\n      }\n    }\n#endif /* JERRY_ESNEXT */\n\n    if (*source_p >= LIT_UTF8_4_BYTE_MARKER)\n    {\n      /* Processing 4 byte unicode sequence (even if it is\n        * after a backslash). Always converted to two 3 byte\n        * long sequence. */\n      lit_four_byte_utf8_char_to_cesu8 (destination_p, source_p);\n\n      destination_p += 6;\n      source_p += 4;\n      continue;\n    }\n\n    *destination_p++ = *source_p++;\n\n    /* There is no need to check the source_end_p\n      * since the string is terminated by a quotation mark. */\n    while (IS_UTF8_INTERMEDIATE_OCTET (*source_p))\n    {\n      *destination_p++ = *source_p++;\n    }\n  }\n\n  JERRY_ASSERT (destination_p == destination_start_p + literal_p->length);\n\n  return destination_start_p;\n}",
        "begin_line": 2251,
        "end_line": 2488,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_convert_push_number_to_push_literal#2784",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_convert_push_number_to_push_literal (parser_context_t *context_p) /**< context */",
        "snippet": "void\nlexer_convert_push_number_to_push_literal (parser_context_t *context_p) /**< context */\n{\n  ecma_integer_value_t value;\n  bool two_literals = context_p->last_cbc_opcode >= CBC_PUSH_LITERAL_PUSH_NUMBER_0;\n\n  if (context_p->last_cbc_opcode == CBC_PUSH_NUMBER_0\n      || context_p->last_cbc_opcode == CBC_PUSH_LITERAL_PUSH_NUMBER_0)\n  {\n    value = 0;\n  }\n  else if (context_p->last_cbc_opcode == CBC_PUSH_NUMBER_POS_BYTE\n           || context_p->last_cbc_opcode == CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE)\n  {\n    value = ((ecma_integer_value_t) context_p->last_cbc.value) + 1;\n  }\n  else\n  {\n    JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_NUMBER_NEG_BYTE\n                  || context_p->last_cbc_opcode == CBC_PUSH_LITERAL_PUSH_NUMBER_NEG_BYTE);\n    value = -((ecma_integer_value_t) context_p->last_cbc.value) - 1;\n  }\n\n  ecma_value_t lit_value = ecma_make_integer_value (value);\n\n  parser_list_iterator_t literal_iterator;\n  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n\n  context_p->last_cbc_opcode = two_literals ? CBC_PUSH_TWO_LITERALS : CBC_PUSH_LITERAL;\n\n  uint32_t literal_index = 0;\n  lexer_literal_t *literal_p;\n\n  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n    if (literal_p->type == LEXER_NUMBER_LITERAL\n        && literal_p->u.value == lit_value)\n    {\n      if (two_literals)\n      {\n        context_p->last_cbc.value = (uint16_t) literal_index;\n      }\n      else\n      {\n        context_p->last_cbc.literal_index = (uint16_t) literal_index;\n      }\n      return;\n    }\n\n    literal_index++;\n  }\n\n  JERRY_ASSERT (literal_index == context_p->literal_count);\n\n  if (literal_index >= PARSER_MAXIMUM_NUMBER_OF_LITERALS)\n  {\n    parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);\n  }\n\n  literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);\n  literal_p->u.value = lit_value;\n  literal_p->prop.length = 0; /* Unused. */\n  literal_p->type = LEXER_NUMBER_LITERAL;\n  literal_p->status_flags = 0;\n\n  context_p->literal_count++;\n\n  if (two_literals)\n  {\n    context_p->last_cbc.value = (uint16_t) literal_index;\n  }\n  else\n  {\n    context_p->last_cbc.literal_index = (uint16_t) literal_index;\n  }\n}",
        "begin_line": 2784,
        "end_line": 2859,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_expect_identifier#3118",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_expect_identifier (parser_context_t *context_p, /**< context */                          uint8_t literal_type) /**< literal type */",
        "snippet": "void\nlexer_expect_identifier (parser_context_t *context_p, /**< context */\n                         uint8_t literal_type) /**< literal type */\n{\n  JERRY_ASSERT (literal_type == LEXER_STRING_LITERAL\n                || literal_type == LEXER_IDENT_LITERAL\n                || literal_type == LEXER_NEW_IDENT_LITERAL);\n\n  lexer_skip_spaces (context_p);\n  context_p->token.keyword_type = LEXER_EOS;\n  context_p->token.line = context_p->line;\n  context_p->token.column = context_p->column;\n\n  if (context_p->source_p < context_p->source_end_p\n      && lexer_parse_identifier (context_p, (literal_type != LEXER_STRING_LITERAL ? LEXER_PARSE_CHECK_KEYWORDS\n                                                                                  : LEXER_PARSE_NO_OPTS)))\n  {\n    if (context_p->token.type == LEXER_LITERAL)\n    {\n      JERRY_ASSERT (context_p->token.lit_location.type == LEXER_IDENT_LITERAL);\n\n      lexer_construct_literal_object (context_p,\n                                      &context_p->token.lit_location,\n                                      literal_type);\n\n      if (literal_type != LEXER_STRING_LITERAL\n          && (context_p->status_flags & PARSER_IS_STRICT))\n      {\n        if (context_p->token.keyword_type == LEXER_KEYW_EVAL)\n        {\n          parser_raise_error (context_p, PARSER_ERR_EVAL_NOT_ALLOWED);\n        }\n        else if (context_p->token.keyword_type == LEXER_KEYW_ARGUMENTS)\n        {\n          parser_raise_error (context_p, PARSER_ERR_ARGUMENTS_NOT_ALLOWED);\n        }\n      }\n      return;\n    }\n  }\n#if JERRY_MODULE_SYSTEM\n  else if (context_p->status_flags & PARSER_MODULE_DEFAULT_CLASS_OR_FUNC)\n  {\n    /* When parsing default exports for modules, it is not required by functions or classes to have identifiers.\n     * In this case we use a synthetic name for them. */\n    context_p->token.type = LEXER_LITERAL;\n    context_p->token.lit_location = lexer_default_literal;\n    lexer_construct_literal_object (context_p, &context_p->token.lit_location, literal_type);\n    context_p->status_flags &= (uint32_t) ~(PARSER_MODULE_DEFAULT_CLASS_OR_FUNC);\n    return;\n  }\n#endif /* JERRY_MODULE_SYSTEM */\n\n#if JERRY_ESNEXT\n  if (context_p->token.type == LEXER_KEYW_YIELD)\n  {\n    parser_raise_error (context_p, PARSER_ERR_YIELD_NOT_ALLOWED);\n  }\n  if (context_p->token.type == LEXER_KEYW_AWAIT)\n  {\n    parser_raise_error (context_p, PARSER_ERR_AWAIT_NOT_ALLOWED);\n  }\n#endif /* JERRY_ESNEXT */\n  parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);\n}",
        "begin_line": 3118,
        "end_line": 3182,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_expect_object_literal_id#3187",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_expect_object_literal_id (parser_context_t *context_p, /**< context */                                 uint32_t ident_opts) /**< lexer_obj_ident_opts_t option bits */",
        "snippet": "void\nlexer_expect_object_literal_id (parser_context_t *context_p, /**< context */\n                                uint32_t ident_opts) /**< lexer_obj_ident_opts_t option bits */\n{\n  lexer_skip_spaces (context_p);\n\n  if (context_p->source_p >= context_p->source_end_p)\n  {\n    parser_raise_error (context_p, PARSER_ERR_PROPERTY_IDENTIFIER_EXPECTED);\n  }\n\n  context_p->token.keyword_type = LEXER_EOS;\n  context_p->token.line = context_p->line;\n  context_p->token.column = context_p->column;\n  bool create_literal_object = false;\n\n  JERRY_ASSERT ((ident_opts & LEXER_OBJ_IDENT_CLASS_IDENTIFIER)\n                || !(ident_opts & LEXER_OBJ_IDENT_CLASS_NO_STATIC));\n\n#if JERRY_FUNCTION_TO_STRING\n  if (ident_opts & LEXER_OBJ_IDENT_SET_FUNCTION_START)\n  {\n    context_p->function_start_p = context_p->source_p;\n  }\n#endif /* JERRY_FUNCTION_TO_STRING */\n\n  if (lexer_parse_identifier (context_p, LEXER_PARSE_NO_OPTS))\n  {\n    if (!(ident_opts & (LEXER_OBJ_IDENT_ONLY_IDENTIFIERS | LEXER_OBJ_IDENT_OBJECT_PATTERN)))\n    {\n      lexer_skip_spaces (context_p);\n      context_p->token.flags = (uint8_t) (context_p->token.flags | LEXER_NO_SKIP_SPACES);\n\n      if (context_p->source_p < context_p->source_end_p\n#if JERRY_ESNEXT\n          && context_p->source_p[0] != LIT_CHAR_COMMA\n          && context_p->source_p[0] != LIT_CHAR_RIGHT_BRACE\n          && context_p->source_p[0] != LIT_CHAR_LEFT_PAREN\n          && context_p->source_p[0] != LIT_CHAR_SEMICOLON\n          && context_p->source_p[0] != LIT_CHAR_EQUALS\n#endif /* JERRY_ESNEXT */\n          && context_p->source_p[0] != LIT_CHAR_COLON)\n      {\n        if (lexer_compare_literal_to_string (context_p, \"get\", 3))\n        {\n          context_p->token.type = LEXER_PROPERTY_GETTER;\n          return;\n        }\n\n        if (lexer_compare_literal_to_string (context_p, \"set\", 3))\n        {\n          context_p->token.type = LEXER_PROPERTY_SETTER;\n          return;\n        }\n\n#if JERRY_ESNEXT\n        if (lexer_compare_literal_to_string (context_p, \"async\", 5))\n        {\n          context_p->token.type = LEXER_KEYW_ASYNC;\n          return;\n        }\n\n        if (ident_opts & LEXER_OBJ_IDENT_CLASS_NO_STATIC)\n        {\n          if (lexer_compare_literal_to_string (context_p, \"static\", 6))\n          {\n            context_p->token.type = LEXER_KEYW_STATIC;\n          }\n          return;\n        }\n#endif /* JERRY_ESNEXT */\n      }\n    }\n\n    create_literal_object = true;\n  }\n  else\n  {\n    switch (context_p->source_p[0])\n    {\n      case LIT_CHAR_DOUBLE_QUOTE:\n      case LIT_CHAR_SINGLE_QUOTE:\n      {\n        lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);\n        create_literal_object = true;\n        break;\n      }\n#if JERRY_ESNEXT\n      case LIT_CHAR_LEFT_SQUARE:\n      {\n#if JERRY_FUNCTION_TO_STRING\n        const uint8_t *function_start_p = context_p->function_start_p;\n#endif /* JERRY_FUNCTION_TO_STRING */\n\n        lexer_consume_next_character (context_p);\n\n        lexer_next_token (context_p);\n        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);\n\n        if (context_p->token.type != LEXER_RIGHT_SQUARE)\n        {\n          parser_raise_error (context_p, PARSER_ERR_RIGHT_SQUARE_EXPECTED);\n        }\n\n#if JERRY_FUNCTION_TO_STRING\n        context_p->function_start_p = function_start_p;\n#endif /* JERRY_FUNCTION_TO_STRING */\n        return;\n      }\n      case LIT_CHAR_ASTERISK:\n      {\n        if (ident_opts & (LEXER_OBJ_IDENT_ONLY_IDENTIFIERS | LEXER_OBJ_IDENT_OBJECT_PATTERN))\n        {\n          break;\n        }\n\n        context_p->token.type = LEXER_MULTIPLY;\n        lexer_consume_next_character (context_p);\n        return;\n      }\n      case LIT_CHAR_DOT:\n      {\n        if ((ident_opts & ((uint32_t) ~(LEXER_OBJ_IDENT_OBJECT_PATTERN | LEXER_OBJ_IDENT_SET_FUNCTION_START)))\n            || context_p->source_p + 2 >= context_p->source_end_p\n            || context_p->source_p[1] != LIT_CHAR_DOT\n            || context_p->source_p[2] != LIT_CHAR_DOT)\n        {\n          break;\n        }\n\n        context_p->token.type = LEXER_THREE_DOTS;\n        context_p->token.flags &= (uint8_t) ~LEXER_NO_SKIP_SPACES;\n        PARSER_PLUS_EQUAL_LC (context_p->column, 3);\n        context_p->source_p += 3;\n        return;\n      }\n#endif /* JERRY_ESNEXT */\n      case LIT_CHAR_RIGHT_BRACE:\n      {\n        if (ident_opts & LEXER_OBJ_IDENT_ONLY_IDENTIFIERS)\n        {\n          break;\n        }\n\n        context_p->token.type = LEXER_RIGHT_BRACE;\n        lexer_consume_next_character (context_p);\n        return;\n      }\n      default:\n      {\n        const uint8_t *char_p = context_p->source_p;\n\n        if (char_p[0] == LIT_CHAR_DOT)\n        {\n          char_p++;\n        }\n\n        if (char_p < context_p->source_end_p\n            && char_p[0] >= LIT_CHAR_0\n            && char_p[0] <= LIT_CHAR_9)\n        {\n          lexer_parse_number (context_p);\n\n          if (!(ident_opts & LEXER_OBJ_IDENT_CLASS_IDENTIFIER))\n          {\n            lexer_construct_number_object (context_p, false, false);\n          }\n          return;\n        }\n        break;\n      }\n    }\n  }\n\n  if (create_literal_object)\n  {\n#if JERRY_ESNEXT\n    if (ident_opts & LEXER_OBJ_IDENT_CLASS_IDENTIFIER)\n    {\n      return;\n    }\n#endif /* JERRY_ESNEXT */\n\n    lexer_construct_literal_object (context_p,\n                                    &context_p->token.lit_location,\n                                    LEXER_STRING_LITERAL);\n    return;\n  }\n\n  parser_raise_error (context_p, PARSER_ERR_PROPERTY_IDENTIFIER_EXPECTED);\n}",
        "begin_line": 3187,
        "end_line": 3377,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_init_line_info#3736",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_init_line_info (parser_context_t *context_p) /**< context */",
        "snippet": "void\nlexer_init_line_info (parser_context_t *context_p) /**< context */\n{\n  context_p->line = 1;\n  context_p->column = 1;\n\n  const jerry_parse_options_t *options_p = context_p->options_p;\n\n  if (options_p != NULL && (options_p->options & JERRY_PARSE_HAS_START))\n  {\n    if (options_p->start_line > 0)\n    {\n      context_p->line = options_p->start_line;\n    }\n\n    if (options_p->start_column > 0)\n    {\n      context_p->column = options_p->start_column;\n    }\n  }\n}",
        "begin_line": 3736,
        "end_line": 3756,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_next_token#1612",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_next_token (parser_context_t *context_p) /**< context */",
        "snippet": "void\nlexer_next_token (parser_context_t *context_p) /**< context */\n{\n  size_t length;\n\n#if JERRY_ESNEXT && JERRY_FUNCTION_TO_STRING\n  /* Needed by arrow functions with expression body */\n  context_p->function_end_p = context_p->source_p;\n#endif /* JERRY_ESNEXT && JERRY_FUNCTION_TO_STRING */\n\n  lexer_skip_spaces (context_p);\n\n  context_p->token.keyword_type = LEXER_EOS;\n  context_p->token.line = context_p->line;\n  context_p->token.column = context_p->column;\n\n  length = (size_t) (context_p->source_end_p - context_p->source_p);\n  if (length == 0)\n  {\n    context_p->token.type = LEXER_EOS;\n    return;\n  }\n\n  if (lexer_parse_identifier (context_p, LEXER_PARSE_CHECK_KEYWORDS))\n  {\n    return;\n  }\n\n  if (context_p->source_p[0] >= LIT_CHAR_0 && context_p->source_p[0] <= LIT_CHAR_9)\n  {\n    lexer_parse_number (context_p);\n    return;\n  }\n\n  switch (context_p->source_p[0])\n  {\n    LEXER_TYPE_A_TOKEN (LIT_CHAR_LEFT_BRACE, LEXER_LEFT_BRACE);\n    LEXER_TYPE_A_TOKEN (LIT_CHAR_LEFT_PAREN, LEXER_LEFT_PAREN);\n    LEXER_TYPE_A_TOKEN (LIT_CHAR_LEFT_SQUARE, LEXER_LEFT_SQUARE);\n    LEXER_TYPE_A_TOKEN (LIT_CHAR_RIGHT_BRACE, LEXER_RIGHT_BRACE);\n    LEXER_TYPE_A_TOKEN (LIT_CHAR_RIGHT_PAREN, LEXER_RIGHT_PAREN);\n    LEXER_TYPE_A_TOKEN (LIT_CHAR_RIGHT_SQUARE, LEXER_RIGHT_SQUARE);\n    LEXER_TYPE_A_TOKEN (LIT_CHAR_SEMICOLON, LEXER_SEMICOLON);\n    LEXER_TYPE_A_TOKEN (LIT_CHAR_COMMA, LEXER_COMMA);\n\n    case (uint8_t) LIT_CHAR_DOT:\n    {\n      if (length >= 2\n          && (context_p->source_p[1] >= LIT_CHAR_0 && context_p->source_p[1] <= LIT_CHAR_9))\n      {\n        lexer_parse_number (context_p);\n        return;\n      }\n\n#if JERRY_ESNEXT\n      if (length >= 3\n          && context_p->source_p[1] == LIT_CHAR_DOT\n          && context_p->source_p[2] == LIT_CHAR_DOT)\n      {\n        context_p->token.type = LEXER_THREE_DOTS;\n        length = 3;\n        break;\n      }\n#endif /* JERRY_ESNEXT */\n\n      context_p->token.type = LEXER_DOT;\n      length = 1;\n      break;\n    }\n\n    case (uint8_t) LIT_CHAR_LESS_THAN:\n    {\n      if (length >= 2)\n      {\n        if (context_p->source_p[1] == (uint8_t) LIT_CHAR_EQUALS)\n        {\n          context_p->token.type = LEXER_LESS_EQUAL;\n          length = 2;\n          break;\n        }\n\n        if (context_p->source_p[1] == (uint8_t) LIT_CHAR_LESS_THAN)\n        {\n          if (length >= 3 && context_p->source_p[2] == (uint8_t) LIT_CHAR_EQUALS)\n          {\n            context_p->token.type = LEXER_ASSIGN_LEFT_SHIFT;\n            length = 3;\n            break;\n          }\n\n          context_p->token.type = LEXER_LEFT_SHIFT;\n          length = 2;\n          break;\n        }\n      }\n\n      context_p->token.type = LEXER_LESS;\n      length = 1;\n      break;\n    }\n\n    case (uint8_t) LIT_CHAR_GREATER_THAN:\n    {\n      if (length >= 2)\n      {\n        if (context_p->source_p[1] == (uint8_t) LIT_CHAR_EQUALS)\n        {\n          context_p->token.type = LEXER_GREATER_EQUAL;\n          length = 2;\n          break;\n        }\n\n        if (context_p->source_p[1] == (uint8_t) LIT_CHAR_GREATER_THAN)\n        {\n          if (length >= 3)\n          {\n            if (context_p->source_p[2] == (uint8_t) LIT_CHAR_EQUALS)\n            {\n              context_p->token.type = LEXER_ASSIGN_RIGHT_SHIFT;\n              length = 3;\n              break;\n            }\n\n            if (context_p->source_p[2] == (uint8_t) LIT_CHAR_GREATER_THAN)\n            {\n              if (length >= 4 && context_p->source_p[3] == (uint8_t) LIT_CHAR_EQUALS)\n              {\n                context_p->token.type = LEXER_ASSIGN_UNS_RIGHT_SHIFT;\n                length = 4;\n                break;\n              }\n\n              context_p->token.type = LEXER_UNS_RIGHT_SHIFT;\n              length = 3;\n              break;\n            }\n          }\n\n          context_p->token.type = LEXER_RIGHT_SHIFT;\n          length = 2;\n          break;\n        }\n      }\n\n      context_p->token.type = LEXER_GREATER;\n      length = 1;\n      break;\n    }\n\n    case (uint8_t) LIT_CHAR_EQUALS:\n    {\n      if (length >= 2)\n      {\n        if (context_p->source_p[1] == (uint8_t) LIT_CHAR_EQUALS)\n        {\n          if (length >= 3 && context_p->source_p[2] == (uint8_t) LIT_CHAR_EQUALS)\n          {\n            context_p->token.type = LEXER_STRICT_EQUAL;\n            length = 3;\n            break;\n          }\n\n          context_p->token.type = LEXER_EQUAL;\n          length = 2;\n          break;\n        }\n\n#if JERRY_ESNEXT\n        if (context_p->source_p[1] == (uint8_t) LIT_CHAR_GREATER_THAN)\n        {\n          context_p->token.type = LEXER_ARROW;\n          length = 2;\n          break;\n        }\n#endif /* JERRY_ESNEXT */\n      }\n\n      context_p->token.type = LEXER_ASSIGN;\n      length = 1;\n      break;\n    }\n\n    case (uint8_t) LIT_CHAR_EXCLAMATION:\n    {\n      if (length >= 2 && context_p->source_p[1] == (uint8_t) LIT_CHAR_EQUALS)\n      {\n        if (length >= 3 && context_p->source_p[2] == (uint8_t) LIT_CHAR_EQUALS)\n        {\n          context_p->token.type = LEXER_STRICT_NOT_EQUAL;\n          length = 3;\n          break;\n        }\n\n        context_p->token.type = LEXER_NOT_EQUAL;\n        length = 2;\n        break;\n      }\n\n      context_p->token.type = LEXER_LOGICAL_NOT;\n      length = 1;\n      break;\n    }\n\n    LEXER_TYPE_C_TOKEN (LIT_CHAR_PLUS, LEXER_ADD, LIT_CHAR_EQUALS,\n                        LEXER_ASSIGN_ADD, LIT_CHAR_PLUS, LEXER_INCREASE)\n    LEXER_TYPE_C_TOKEN (LIT_CHAR_MINUS, LEXER_SUBTRACT, LIT_CHAR_EQUALS,\n                        LEXER_ASSIGN_SUBTRACT, LIT_CHAR_MINUS, LEXER_DECREASE)\n\n    case (uint8_t) LIT_CHAR_ASTERISK:\n    {\n      if (length >= 2)\n      {\n        if (context_p->source_p[1] == (uint8_t) LIT_CHAR_EQUALS)\n        {\n          context_p->token.type = LEXER_ASSIGN_MULTIPLY;\n          length = 2;\n          break;\n        }\n\n#if JERRY_ESNEXT\n        if (context_p->source_p[1] == (uint8_t) LIT_CHAR_ASTERISK)\n        {\n          if (length >= 3 && context_p->source_p[2] == (uint8_t) LIT_CHAR_EQUALS)\n          {\n            context_p->token.type = LEXER_ASSIGN_EXPONENTIATION;\n            length = 3;\n            break;\n          }\n\n          context_p->token.type = LEXER_EXPONENTIATION;\n          length = 2;\n          break;\n        }\n#endif /* JERRY_ESNEXT */\n      }\n\n      context_p->token.type = LEXER_MULTIPLY;\n      length = 1;\n      break;\n    }\n\n    LEXER_TYPE_B_TOKEN (LIT_CHAR_SLASH, LEXER_DIVIDE, LIT_CHAR_EQUALS,\n                        LEXER_ASSIGN_DIVIDE)\n    LEXER_TYPE_B_TOKEN (LIT_CHAR_PERCENT, LEXER_MODULO, LIT_CHAR_EQUALS,\n                        LEXER_ASSIGN_MODULO)\n\n    LEXER_TYPE_C_TOKEN (LIT_CHAR_AMPERSAND, LEXER_BIT_AND, LIT_CHAR_EQUALS,\n                        LEXER_ASSIGN_BIT_AND, LIT_CHAR_AMPERSAND, LEXER_LOGICAL_AND)\n    LEXER_TYPE_C_TOKEN (LIT_CHAR_VLINE, LEXER_BIT_OR, LIT_CHAR_EQUALS,\n                        LEXER_ASSIGN_BIT_OR, LIT_CHAR_VLINE, LEXER_LOGICAL_OR)\n\n    LEXER_TYPE_B_TOKEN (LIT_CHAR_CIRCUMFLEX, LEXER_BIT_XOR, LIT_CHAR_EQUALS,\n                        LEXER_ASSIGN_BIT_XOR)\n\n    LEXER_TYPE_A_TOKEN (LIT_CHAR_TILDE, LEXER_BIT_NOT);\n    case (uint8_t) (LIT_CHAR_QUESTION):\n    {\n#if JERRY_ESNEXT\n      if (length >= 2)\n      {\n        if (context_p->source_p[1] == (uint8_t) LIT_CHAR_QUESTION)\n        {\n          context_p->token.type = LEXER_NULLISH_COALESCING;\n          length = 2;\n          break;\n        }\n      }\n#endif /* JERRY_ESNEXT */\n      context_p->token.type = LEXER_QUESTION_MARK;\n      length = 1;\n      break;\n    }\n\n    LEXER_TYPE_A_TOKEN (LIT_CHAR_COLON, LEXER_COLON);\n\n    case LIT_CHAR_SINGLE_QUOTE:\n    case LIT_CHAR_DOUBLE_QUOTE:\n#if JERRY_ESNEXT\n    case LIT_CHAR_GRAVE_ACCENT:\n#endif /* JERRY_ESNEXT */\n    {\n      lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);\n      return;\n    }\n\n    default:\n    {\n      parser_raise_error (context_p, PARSER_ERR_INVALID_CHARACTER);\n    }\n  }\n\n  context_p->source_p += length;\n  PARSER_PLUS_EQUAL_LC (context_p->column, length);\n}",
        "begin_line": 1612,
        "end_line": 1905,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_parse_identifier#638",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_parse_identifier (parser_context_t *context_p, /**< context */                         lexer_parse_options_t options) /**< check keywords */",
        "snippet": "static bool\nlexer_parse_identifier (parser_context_t *context_p, /**< context */\n                        lexer_parse_options_t options) /**< check keywords */\n{\n  /* Only very few identifiers contains \\u escape sequences. */\n  const uint8_t *source_p = context_p->source_p;\n  /* Note: newline or tab cannot be part of an identifier. */\n  parser_line_counter_t column = context_p->column;\n  const uint8_t *source_end_p = context_p->source_end_p;\n  size_t length = 0;\n  lexer_lit_location_flags_t status_flags = LEXER_LIT_LOCATION_IS_ASCII;\n\n  do\n  {\n    if (*source_p == LIT_CHAR_BACKSLASH)\n    {\n      /* After a backslash an identifier must start. */\n      lit_code_point_t code_point = UINT32_MAX;\n      uint32_t escape_length = 6;\n\n      if (options & (LEXER_PARSE_CHECK_START_AND_RETURN | LEXER_PARSE_CHECK_PART_AND_RETURN))\n      {\n        return true;\n      }\n\n      status_flags = LEXER_LIT_LOCATION_HAS_ESCAPE;\n\n#if JERRY_ESNEXT\n      if (source_p + 5 <= source_end_p && source_p[1] == LIT_CHAR_LOWERCASE_U)\n      {\n        if (source_p[2] == LIT_CHAR_LEFT_BRACE)\n        {\n          code_point = lexer_hex_in_braces_to_code_point (source_p + 3, source_end_p, &escape_length);\n        }\n        else if (source_p + 6 <= source_end_p)\n        {\n          code_point = lexer_hex_to_code_point (source_p + 2, 4);\n        }\n      }\n#else /* !JERRY_ESNEXT */\n      if (source_p + 6 <= source_end_p && source_p[1] == LIT_CHAR_LOWERCASE_U)\n      {\n        code_point = lexer_hex_to_code_point (source_p + 2, 4);\n      }\n#endif /* JERRY_ESNEXT */\n\n      if (code_point == UINT32_MAX)\n      {\n        context_p->source_p = source_p;\n        context_p->token.column = column;\n        parser_raise_error (context_p, PARSER_ERR_INVALID_UNICODE_ESCAPE_SEQUENCE);\n      }\n\n      if (length == 0)\n      {\n        if (!lit_code_point_is_identifier_start (code_point))\n        {\n          parser_raise_error (context_p, PARSER_ERR_INVALID_IDENTIFIER_START);\n        }\n      }\n      else\n      {\n        if (!lit_code_point_is_identifier_part (code_point))\n        {\n          parser_raise_error (context_p, PARSER_ERR_INVALID_IDENTIFIER_PART);\n        }\n      }\n\n      length += lit_code_point_get_cesu8_length (code_point);\n      source_p += escape_length;\n      PARSER_PLUS_EQUAL_LC (column, escape_length);\n      continue;\n    }\n\n    lit_code_point_t code_point = *source_p;\n    lit_utf8_size_t utf8_length = 1, decoded_length = 1, char_count = 1;\n\n    if (JERRY_UNLIKELY (code_point >= LIT_UTF8_2_BYTE_MARKER))\n    {\n      status_flags &= (uint32_t) ~LEXER_LIT_LOCATION_IS_ASCII;\n\n#if JERRY_ESNEXT\n      utf8_length = lit_read_code_point_from_utf8 (source_p,\n                                                   (lit_utf8_size_t) (source_end_p - source_p),\n                                                   &code_point);\n      decoded_length = utf8_length;\n\n      /* Only ES2015+ supports code points outside of the basic plane which can be part of an identifier. */\n      if ((code_point >= LIT_UTF16_HIGH_SURROGATE_MIN && code_point <= LIT_UTF16_HIGH_SURROGATE_MAX)\n          && source_p + 3 < source_end_p)\n      {\n        lit_code_point_t low_surrogate;\n        lit_read_code_point_from_utf8 (source_p + 3,\n                                       (lit_utf8_size_t) (source_end_p - (source_p + 3)),\n                                       &low_surrogate);\n\n        if (low_surrogate >= LIT_UTF16_LOW_SURROGATE_MIN && low_surrogate <= LIT_UTF16_LOW_SURROGATE_MAX)\n        {\n          code_point = lit_convert_surrogate_pair_to_code_point ((ecma_char_t) code_point,\n                                                                 (ecma_char_t) low_surrogate);\n          utf8_length = 2 * 3;\n          decoded_length = 2 * 3;\n          char_count = 2;\n        }\n      }\n      else if (source_p[0] >= LIT_UTF8_4_BYTE_MARKER)\n      {\n        decoded_length = 2 * 3;\n        status_flags = LEXER_LIT_LOCATION_HAS_ESCAPE;\n#if JERRY_FUNCTION_TO_STRING\n        context_p->global_status_flags |= ECMA_PARSE_INTERNAL_HAS_4_BYTE_MARKER;\n#endif /* JERRY_FUNCTION_TO_STRING */\n      }\n#else /* !JERRY_ESNEXT */\n      if (code_point < LIT_UTF8_4_BYTE_MARKER)\n      {\n        utf8_length = lit_read_code_point_from_utf8 (source_p,\n                                                     (lit_utf8_size_t) (source_end_p - source_p),\n                                                     &code_point);\n        decoded_length = utf8_length;\n      }\n      else\n      {\n        code_point = 0;\n      }\n#endif /* JERRY_ESNEXT */\n    }\n\n    if (length == 0)\n    {\n      if (JERRY_UNLIKELY (options & (LEXER_PARSE_CHECK_START_AND_RETURN | LEXER_PARSE_CHECK_PART_AND_RETURN)))\n      {\n        if (options & LEXER_PARSE_CHECK_START_AND_RETURN)\n        {\n          return lit_code_point_is_identifier_start (code_point);\n        }\n        else\n        {\n          return lit_code_point_is_identifier_part (code_point);\n        }\n      }\n\n      if (!lit_code_point_is_identifier_start (code_point))\n      {\n        return false;\n      }\n    }\n    else if (!lit_code_point_is_identifier_part (code_point))\n    {\n      break;\n    }\n\n    source_p += utf8_length;\n    length += decoded_length;\n    PARSER_PLUS_EQUAL_LC (column, char_count);\n  }\n  while (source_p < source_end_p);\n\n  JERRY_ASSERT (length > 0);\n\n  context_p->token.type = LEXER_LITERAL;\n  context_p->token.lit_location.type = LEXER_IDENT_LITERAL;\n  context_p->token.lit_location.status_flags = (uint8_t) status_flags;\n\n  context_p->token.column = context_p->column;\n  context_p->token.lit_location.char_p = context_p->source_p;\n  context_p->token.lit_location.length = (prop_length_t) length;\n\n  if (JERRY_UNLIKELY (length > PARSER_MAXIMUM_IDENT_LENGTH))\n  {\n    parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_TOO_LONG);\n  }\n\n  /* Check keywords. */\n  if ((options & LEXER_PARSE_CHECK_KEYWORDS)\n      && (length >= LEXER_KEYWORD_MIN_LENGTH && length <= LEXER_KEYWORD_MAX_LENGTH))\n  {\n    const uint8_t *ident_start_p = context_p->source_p;\n    uint8_t buffer_p[LEXER_KEYWORD_MAX_LENGTH];\n\n    if (JERRY_UNLIKELY (context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE))\n    {\n      lexer_convert_ident_to_cesu8 (buffer_p, ident_start_p, (prop_length_t) length);\n      ident_start_p = buffer_p;\n    }\n\n    const keyword_string_t *keyword_list_p = keyword_strings_list[length - LEXER_KEYWORD_MIN_LENGTH];\n\n    int start = 0;\n    int end = keyword_lengths_list[length - LEXER_KEYWORD_MIN_LENGTH];\n    int middle = end / 2;\n\n    do\n    {\n      const keyword_string_t *keyword_p = keyword_list_p + middle;\n      int compare_result = ident_start_p[0] - keyword_p->keyword_p[0];\n\n      if (compare_result == 0)\n      {\n        compare_result = memcmp (ident_start_p, keyword_p->keyword_p, length);\n\n        if (compare_result == 0)\n        {\n          context_p->token.keyword_type = (uint8_t) keyword_p->type;\n\n          if (JERRY_LIKELY (keyword_p->type < LEXER_FIRST_NON_RESERVED_KEYWORD))\n          {\n#if JERRY_ESNEXT\n            if (JERRY_UNLIKELY (keyword_p->type == LEXER_KEYW_AWAIT))\n            {\n              if (!(context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)\n                  && !(context_p->global_status_flags & ECMA_PARSE_MODULE))\n              {\n                break;\n              }\n\n              if (context_p->status_flags & PARSER_DISALLOW_AWAIT_YIELD)\n              {\n                if (LEXER_CHECK_INVALID_KEYWORD (ident_start_p, buffer_p))\n                {\n                  parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);\n                }\n                parser_raise_error (context_p, PARSER_ERR_AWAIT_NOT_ALLOWED);\n              }\n\n              context_p->token.type = (uint8_t) LEXER_KEYW_AWAIT;\n              break;\n            }\n#endif /* JERRY_ESNEXT */\n\n            if (LEXER_CHECK_INVALID_KEYWORD (ident_start_p, buffer_p))\n            {\n              /* Escape sequences are not allowed in a keyword. */\n              parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);\n            }\n\n            context_p->token.type = (uint8_t) keyword_p->type;\n            break;\n          }\n\n#if JERRY_ESNEXT\n          if (keyword_p->type == LEXER_KEYW_LET && (context_p->status_flags & PARSER_IS_STRICT))\n          {\n            if (LEXER_CHECK_INVALID_KEYWORD (ident_start_p, buffer_p))\n            {\n              parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);\n            }\n\n            context_p->token.type = (uint8_t) LEXER_KEYW_LET;\n            break;\n          }\n\n          if (keyword_p->type == LEXER_KEYW_YIELD && (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION))\n          {\n            if (context_p->status_flags & PARSER_DISALLOW_AWAIT_YIELD)\n            {\n              if (LEXER_CHECK_INVALID_KEYWORD (ident_start_p, buffer_p))\n              {\n                parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);\n              }\n              parser_raise_error (context_p, PARSER_ERR_YIELD_NOT_ALLOWED);\n            }\n\n            context_p->token.type = (uint8_t) LEXER_KEYW_YIELD;\n            break;\n          }\n\n          if (keyword_p->type == LEXER_KEYW_ARGUMENTS && (context_p->status_flags & PARSER_INSIDE_CLASS_FIELD))\n          {\n            parser_raise_error (context_p, PARSER_ERR_ARGUMENTS_IN_CLASS_FIELD);\n          }\n#endif /* JERRY_ESNEXT */\n\n          if (keyword_p->type >= LEXER_FIRST_FUTURE_STRICT_RESERVED_WORD\n              && (context_p->status_flags & PARSER_IS_STRICT))\n          {\n            parser_raise_error (context_p, PARSER_ERR_STRICT_IDENT_NOT_ALLOWED);\n          }\n          break;\n        }\n      }\n\n      if (compare_result > 0)\n      {\n        start = middle + 1;\n      }\n      else\n      {\n        JERRY_ASSERT (compare_result < 0);\n        end = middle;\n      }\n\n      middle = (start + end) / 2;\n    }\n    while (start < end);\n  }\n\n  context_p->source_p = source_p;\n  context_p->column = column;\n  return true;\n}",
        "begin_line": 638,
        "end_line": 938,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_parse_number#1327",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_parse_number (parser_context_t *context_p) /**< context */",
        "snippet": "static void\nlexer_parse_number (parser_context_t *context_p) /**< context */\n{\n  const uint8_t *source_p = context_p->source_p;\n  const uint8_t *source_end_p = context_p->source_end_p;\n  bool can_be_float = false;\n#if JERRY_BUILTIN_BIGINT\n  bool can_be_bigint = true;\n#endif /* JERRY_BUILTIN_BIGINT */\n  size_t length;\n\n  context_p->token.type = LEXER_LITERAL;\n  context_p->token.extra_value = LEXER_NUMBER_DECIMAL;\n  context_p->token.lit_location.char_p = source_p;\n  context_p->token.lit_location.type = LEXER_NUMBER_LITERAL;\n  context_p->token.lit_location.status_flags = LEXER_LIT_LOCATION_IS_ASCII;\n\n  if (source_p[0] == LIT_CHAR_0\n      && source_p + 1 < source_end_p)\n  {\n#if JERRY_ESNEXT\n    if (source_p[1] == LIT_CHAR_UNDERSCORE)\n    {\n      parser_raise_error (context_p, PARSER_ERR_INVALID_UNDERSCORE_IN_NUMBER);\n    }\n#endif /* JERRY_ESNEXT */\n    if (LEXER_TO_ASCII_LOWERCASE (source_p[1]) == LIT_CHAR_LOWERCASE_X)\n    {\n      context_p->token.extra_value = LEXER_NUMBER_HEXADECIMAL;\n      source_p += 2;\n\n      if (source_p >= source_end_p\n          || !lit_char_is_hex_digit (source_p[0]))\n      {\n        parser_raise_error (context_p, PARSER_ERR_INVALID_HEX_DIGIT);\n      }\n\n      do\n      {\n        source_p++;\n#if JERRY_ESNEXT\n        if (source_p < source_end_p && source_p[0] == LIT_CHAR_UNDERSCORE)\n        {\n          source_p++;\n          if (source_p == source_end_p || !lit_char_is_hex_digit (source_p[0]))\n          {\n            parser_raise_error (context_p, PARSER_ERR_INVALID_UNDERSCORE_IN_NUMBER);\n          }\n        }\n#endif /* JERRY_ESNEXT */\n      }\n      while (source_p < source_end_p\n             && lit_char_is_hex_digit (source_p[0]));\n    }\n#if JERRY_ESNEXT\n    else if (LEXER_TO_ASCII_LOWERCASE (source_p[1]) == LIT_CHAR_LOWERCASE_O)\n    {\n      context_p->token.extra_value = LEXER_NUMBER_OCTAL;\n      source_p += 2;\n\n      if (source_p >= source_end_p\n          || !lit_char_is_octal_digit (source_p[0]))\n      {\n        parser_raise_error (context_p, PARSER_ERR_INVALID_OCTAL_DIGIT);\n      }\n\n      lexer_check_numbers (context_p, &source_p, source_end_p, LIT_CHAR_7, false);\n    }\n#endif /* JERRY_ESNEXT */\n    else if (source_p[1] >= LIT_CHAR_0\n             && source_p[1] <= LIT_CHAR_9)\n    {\n      context_p->token.extra_value = LEXER_NUMBER_OCTAL;\n#if JERRY_BUILTIN_BIGINT\n      can_be_bigint = false;\n#endif /* JERRY_BUILTIN_BIGINT */\n\n      if (context_p->status_flags & PARSER_IS_STRICT)\n      {\n        parser_raise_error (context_p, PARSER_ERR_OCTAL_NUMBER_NOT_ALLOWED);\n      }\n\n      lexer_check_numbers (context_p, &source_p, source_end_p, LIT_CHAR_7, true);\n\n      if (source_p < source_end_p\n          && source_p[0] >= LIT_CHAR_8\n          && source_p[0] <= LIT_CHAR_9)\n      {\n#if JERRY_ESNEXT\n        lexer_check_numbers (context_p, &source_p, source_end_p, LIT_CHAR_9, true);\n        context_p->token.extra_value = LEXER_NUMBER_DECIMAL;\n#else /* !JERRY_ESNEXT */\n        parser_raise_error (context_p, PARSER_ERR_INVALID_NUMBER);\n#endif /* JERRY_ESNEXT */\n      }\n    }\n#if JERRY_ESNEXT\n    else if (LEXER_TO_ASCII_LOWERCASE (source_p[1]) == LIT_CHAR_LOWERCASE_B)\n    {\n      context_p->token.extra_value = LEXER_NUMBER_BINARY;\n      source_p += 2;\n\n      if (source_p >= source_end_p\n          || !lit_char_is_binary_digit (source_p[0]))\n      {\n        parser_raise_error (context_p, PARSER_ERR_INVALID_BIN_DIGIT);\n      }\n\n      do\n      {\n        source_p++;\n        if (source_p < source_end_p && source_p[0] == LIT_CHAR_UNDERSCORE)\n        {\n          source_p++;\n          if (source_p == source_end_p\n              || source_p[0] > LIT_CHAR_9\n              || source_p[0] < LIT_CHAR_0)\n          {\n            parser_raise_error (context_p, PARSER_ERR_INVALID_UNDERSCORE_IN_NUMBER);\n          }\n        }\n      }\n      while (source_p < source_end_p\n               && lit_char_is_binary_digit (source_p[0]));\n    }\n#endif /* JERRY_ESNEXT */\n    else\n    {\n      can_be_float = true;\n      source_p++;\n    }\n  }\n  else\n  {\n    lexer_check_numbers (context_p, &source_p, source_end_p, LIT_CHAR_9, false);\n    can_be_float = true;\n  }\n\n  if (can_be_float)\n  {\n    if (source_p < source_end_p\n        && source_p[0] == LIT_CHAR_DOT)\n    {\n      source_p++;\n#if JERRY_BUILTIN_BIGINT\n      can_be_bigint = false;\n#endif /* JERRY_BUILTIN_BIGINT */\n\n#if JERRY_ESNEXT\n      if (source_p < source_end_p && source_p[0] == LIT_CHAR_UNDERSCORE)\n      {\n        parser_raise_error (context_p, PARSER_ERR_INVALID_UNDERSCORE_IN_NUMBER);\n      }\n#endif /* JERRY_ESNEXT */\n      lexer_check_numbers (context_p, &source_p, source_end_p, LIT_CHAR_9, false);\n    }\n\n    if (source_p < source_end_p\n        && LEXER_TO_ASCII_LOWERCASE (source_p[0]) == LIT_CHAR_LOWERCASE_E)\n    {\n      source_p++;\n#if JERRY_BUILTIN_BIGINT\n      can_be_bigint = false;\n#endif /* JERRY_BUILTIN_BIGINT */\n\n      if (source_p < source_end_p\n          && (source_p[0] == LIT_CHAR_PLUS || source_p[0] == LIT_CHAR_MINUS))\n      {\n        source_p++;\n      }\n\n      if (source_p >= source_end_p\n          || source_p[0] < LIT_CHAR_0\n          || source_p[0] > LIT_CHAR_9)\n      {\n        parser_raise_error (context_p, PARSER_ERR_MISSING_EXPONENT);\n      }\n\n      lexer_check_numbers (context_p, &source_p, source_end_p, LIT_CHAR_9, false);\n    }\n  }\n\n#if JERRY_BUILTIN_BIGINT\n  if (source_p < source_end_p && source_p[0] == LIT_CHAR_LOWERCASE_N)\n  {\n    if (!can_be_bigint)\n    {\n      parser_raise_error (context_p, PARSER_ERR_INVALID_BIGINT);\n    }\n    context_p->token.extra_value = LEXER_NUMBER_BIGINT;\n    source_p++;\n  }\n#endif /* JERRY_BUILTIN_BIGINT */\n\n  length = (size_t) (source_p - context_p->source_p);\n  if (length > PARSER_MAXIMUM_STRING_LENGTH)\n  {\n    parser_raise_error (context_p, PARSER_ERR_NUMBER_TOO_LONG);\n  }\n\n  context_p->token.lit_location.length = (prop_length_t) length;\n  PARSER_PLUS_EQUAL_LC (context_p->column, length);\n  context_p->source_p = source_p;\n\n  if (source_p < source_end_p && lexer_parse_identifier (context_p, LEXER_PARSE_CHECK_START_AND_RETURN))\n  {\n    parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_AFTER_NUMBER);\n  }\n}",
        "begin_line": 1327,
        "end_line": 1535,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_parse_string#945",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_parse_string (parser_context_t *context_p, /**< context */                     lexer_string_options_t opts) /**< options */",
        "snippet": "void\nlexer_parse_string (parser_context_t *context_p, /**< context */\n                    lexer_string_options_t opts) /**< options */\n{\n#if JERRY_ESNEXT\n  int32_t raw_length_adjust = 0;\n#else /* JERRY_ESNEXT */\n  JERRY_UNUSED (opts);\n#endif /* JERRY_ESNEXT */\n\n  uint8_t str_end_character = context_p->source_p[0];\n  const uint8_t *source_p = context_p->source_p + 1;\n  const uint8_t *string_start_p = source_p;\n  const uint8_t *source_end_p = context_p->source_end_p;\n  parser_line_counter_t line = context_p->line;\n  parser_line_counter_t column = (parser_line_counter_t) (context_p->column + 1);\n  parser_line_counter_t original_line = line;\n  parser_line_counter_t original_column = column;\n  size_t length = 0;\n  lexer_lit_location_flags_t status_flags = LEXER_LIT_LOCATION_IS_ASCII;\n\n#if JERRY_ESNEXT\n  if (str_end_character == LIT_CHAR_RIGHT_BRACE)\n  {\n    str_end_character = LIT_CHAR_GRAVE_ACCENT;\n  }\n#endif /* JERRY_ESNEXT */\n\n  while (true)\n  {\n    if (source_p >= source_end_p)\n    {\n      context_p->token.line = original_line;\n      context_p->token.column = (parser_line_counter_t) (original_column - 1);\n      parser_raise_error (context_p, PARSER_ERR_UNTERMINATED_STRING);\n    }\n\n    if (*source_p == str_end_character)\n    {\n      break;\n    }\n\n    if (*source_p == LIT_CHAR_BACKSLASH)\n    {\n      source_p++;\n      column++;\n      if (source_p >= source_end_p)\n      {\n        /* Will throw an unterminated string error. */\n        continue;\n      }\n\n      status_flags = LEXER_LIT_LOCATION_HAS_ESCAPE;\n\n      /* Newline is ignored. */\n      if (*source_p == LIT_CHAR_CR)\n      {\n        source_p++;\n        if (source_p < source_end_p\n            && *source_p == LIT_CHAR_LF)\n        {\n#if JERRY_ESNEXT\n          raw_length_adjust--;\n#endif /* JERRY_ESNEXT */\n          source_p++;\n        }\n\n        line++;\n        column = 1;\n        continue;\n      }\n      else if (*source_p == LIT_CHAR_LF)\n      {\n        source_p++;\n        line++;\n        column = 1;\n        continue;\n      }\n      else if (*source_p == LEXER_NEWLINE_LS_PS_BYTE_1 && LEXER_NEWLINE_LS_PS_BYTE_23 (source_p))\n      {\n        source_p += 3;\n        line++;\n        column = 1;\n        continue;\n      }\n\n#if JERRY_ESNEXT\n      if (opts & LEXER_STRING_RAW)\n      {\n        if ((*source_p == LIT_CHAR_GRAVE_ACCENT) || (*source_p == LIT_CHAR_BACKSLASH))\n        {\n          source_p++;\n          column++;\n          length++;\n        }\n        continue;\n      }\n#endif /* JERRY_ESNEXT */\n\n      if (*source_p == LIT_CHAR_0\n          && source_p + 1 < source_end_p\n          && (*(source_p + 1) < LIT_CHAR_0 || *(source_p + 1) > LIT_CHAR_9))\n      {\n        source_p++;\n        column++;\n        length++;\n        continue;\n      }\n\n      /* Except \\x, \\u, and octal numbers, everything is\n       * converted to a character which has the same byte length. */\n      if (*source_p >= LIT_CHAR_0 && *source_p <= LIT_CHAR_3)\n      {\n#if JERRY_ESNEXT\n        if (str_end_character == LIT_CHAR_GRAVE_ACCENT)\n        {\n          parser_raise_error (context_p, PARSER_ERR_TEMPLATE_STR_OCTAL_ESCAPE);\n        }\n#endif\n\n        if (context_p->status_flags & PARSER_IS_STRICT)\n        {\n          parser_raise_error (context_p, PARSER_ERR_OCTAL_ESCAPE_NOT_ALLOWED);\n        }\n\n        source_p++;\n        column++;\n\n        if (source_p < source_end_p && *source_p >= LIT_CHAR_0 && *source_p <= LIT_CHAR_7)\n        {\n          source_p++;\n          column++;\n\n          if (source_p < source_end_p && *source_p >= LIT_CHAR_0 && *source_p <= LIT_CHAR_7)\n          {\n            /* Numbers >= 0x200 (0x80) requires\n             * two bytes for encoding in UTF-8. */\n            if (source_p[-2] >= LIT_CHAR_2)\n            {\n              length++;\n            }\n\n            source_p++;\n            column++;\n          }\n        }\n\n        length++;\n        continue;\n      }\n\n      if (*source_p >= LIT_CHAR_4 && *source_p <= LIT_CHAR_7)\n      {\n        if (context_p->status_flags & PARSER_IS_STRICT)\n        {\n          parser_raise_error (context_p, PARSER_ERR_OCTAL_ESCAPE_NOT_ALLOWED);\n        }\n\n        source_p++;\n        column++;\n\n        if (source_p < source_end_p && *source_p >= LIT_CHAR_0 && *source_p <= LIT_CHAR_7)\n        {\n          source_p++;\n          column++;\n        }\n\n        /* The maximum number is 0x4d so the UTF-8\n         * representation is always one byte. */\n        length++;\n        continue;\n      }\n\n      if (*source_p == LIT_CHAR_LOWERCASE_X || *source_p == LIT_CHAR_LOWERCASE_U)\n      {\n        uint32_t escape_length = (*source_p == LIT_CHAR_LOWERCASE_X) ? 3 : 5;\n        lit_code_point_t code_point = UINT32_MAX;\n\n#if JERRY_ESNEXT\n        if (source_p + 4 <= source_end_p\n            && source_p[0] == LIT_CHAR_LOWERCASE_U\n            && source_p[1] == LIT_CHAR_LEFT_BRACE)\n        {\n          code_point = lexer_hex_in_braces_to_code_point (source_p + 2, source_end_p, &escape_length);\n          escape_length--;\n        }\n        else\n        {\n#endif /* JERRY_ESNEXT */\n          if (source_p + escape_length <= source_end_p)\n          {\n            code_point = lexer_hex_to_code_point (source_p + 1, escape_length - 1);\n          }\n#if JERRY_ESNEXT\n        }\n#endif /* JERRY_ESNEXT */\n\n        if (code_point == UINT32_MAX)\n        {\n          context_p->token.line = line;\n          context_p->token.column = (parser_line_counter_t) (column - 1);\n          parser_raise_error (context_p, PARSER_ERR_INVALID_UNICODE_ESCAPE_SEQUENCE);\n        }\n\n        length += lit_code_point_get_cesu8_length (code_point);\n\n        source_p += escape_length;\n        PARSER_PLUS_EQUAL_LC (column, escape_length);\n        continue;\n      }\n    }\n#if JERRY_ESNEXT\n    else if (str_end_character == LIT_CHAR_GRAVE_ACCENT &&\n             source_p[0] == LIT_CHAR_DOLLAR_SIGN &&\n             source_p + 1 < source_end_p &&\n             source_p[1] == LIT_CHAR_LEFT_BRACE)\n    {\n      raw_length_adjust--;\n      source_p++;\n      break;\n    }\n#endif /* JERRY_ESNEXT */\n\n    if (*source_p >= LIT_UTF8_4_BYTE_MARKER)\n    {\n      /* Processing 4 byte unicode sequence (even if it is\n       * after a backslash). Always converted to two 3 byte\n       * long sequence. */\n      length += 2 * 3;\n      status_flags = LEXER_LIT_LOCATION_HAS_ESCAPE;\n      source_p += 4;\n#if JERRY_ESNEXT\n      raw_length_adjust += 2;\n#endif /* JERRY_ESNEXT */\n      column++;\n#if JERRY_FUNCTION_TO_STRING\n      context_p->global_status_flags |= ECMA_PARSE_INTERNAL_HAS_4_BYTE_MARKER;\n#endif /* JERRY_FUNCTION_TO_STRING */\n      continue;\n    }\n    else if (*source_p == LIT_CHAR_TAB)\n    {\n      column = align_column_to_tab (column);\n      /* Subtract -1 because column is increased below. */\n      column--;\n    }\n#if JERRY_ESNEXT\n    else if (*source_p == LEXER_NEWLINE_LS_PS_BYTE_1 && LEXER_NEWLINE_LS_PS_BYTE_23 (source_p))\n    {\n      source_p += 3;\n      length += 3;\n      line++;\n      column = 1;\n      continue;\n    }\n    else if (str_end_character == LIT_CHAR_GRAVE_ACCENT)\n    {\n      /* Newline (without backslash) is part of the string.\n         Note: ECMAScript v6, 11.8.6.1 <CR> or <CR><LF> are both normalized to <LF> */\n      if (*source_p == LIT_CHAR_CR)\n      {\n        status_flags = LEXER_LIT_LOCATION_HAS_ESCAPE;\n        source_p++;\n        length++;\n        if (source_p < source_end_p\n            && *source_p == LIT_CHAR_LF)\n        {\n          source_p++;\n          raw_length_adjust--;\n        }\n        line++;\n        column = 1;\n        continue;\n      }\n      else if (*source_p == LIT_CHAR_LF)\n      {\n        source_p++;\n        length++;\n        line++;\n        column = 1;\n        continue;\n      }\n    }\n#endif /* JERRY_ESNEXT */\n    else if (*source_p == LIT_CHAR_CR\n#if !JERRY_ESNEXT\n             || (*source_p == LEXER_NEWLINE_LS_PS_BYTE_1 && LEXER_NEWLINE_LS_PS_BYTE_23 (source_p))\n#endif /* !JERRY_ESNEXT */\n             || *source_p == LIT_CHAR_LF)\n    {\n      context_p->token.line = line;\n      context_p->token.column = column;\n      parser_raise_error (context_p, PARSER_ERR_NEWLINE_NOT_ALLOWED);\n    }\n\n    source_p++;\n    column++;\n    length++;\n\n    while (source_p < source_end_p\n           && IS_UTF8_INTERMEDIATE_OCTET (*source_p))\n    {\n      source_p++;\n      length++;\n    }\n  }\n\n#if JERRY_ESNEXT\n  if (opts & LEXER_STRING_RAW)\n  {\n    length = (size_t) ((source_p - string_start_p) + raw_length_adjust);\n  }\n#endif /* JERRY_ESNEXT */\n\n  if (length > PARSER_MAXIMUM_STRING_LENGTH)\n  {\n    parser_raise_error (context_p, PARSER_ERR_STRING_TOO_LONG);\n  }\n\n#if JERRY_ESNEXT\n  context_p->token.type = ((str_end_character != LIT_CHAR_GRAVE_ACCENT) ? LEXER_LITERAL\n                                                                        : LEXER_TEMPLATE_LITERAL);\n#else /* !JERRY_ESNEXT */\n  context_p->token.type = LEXER_LITERAL;\n#endif /* JERRY_ESNEXT */\n\n  /* Fill literal data. */\n  context_p->token.lit_location.char_p = string_start_p;\n  context_p->token.lit_location.length = (prop_length_t) length;\n  context_p->token.lit_location.type = LEXER_STRING_LITERAL;\n  context_p->token.lit_location.status_flags = (uint8_t) status_flags;\n\n  context_p->source_p = source_p + 1;\n  context_p->line = line;\n  context_p->column = (parser_line_counter_t) (column + 1);\n}",
        "begin_line": 945,
        "end_line": 1280,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_scan_identifier#3384",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_scan_identifier (parser_context_t *context_p) /**< context */",
        "snippet": "bool\nlexer_scan_identifier (parser_context_t *context_p) /**< context */\n{\n  lexer_skip_spaces (context_p);\n  context_p->token.keyword_type = LEXER_EOS;\n  context_p->token.line = context_p->line;\n  context_p->token.column = context_p->column;\n\n  if (context_p->source_p < context_p->source_end_p\n      && lexer_parse_identifier (context_p, LEXER_PARSE_NO_OPTS))\n  {\n    return true;\n  }\n\n  context_p->token.flags |= LEXER_NO_SKIP_SPACES;\n  lexer_next_token (context_p);\n  return false;\n}",
        "begin_line": 3384,
        "end_line": 3401,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_skip_spaces#225",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_skip_spaces (parser_context_t *context_p) /**< context */",
        "snippet": "static void\nlexer_skip_spaces (parser_context_t *context_p) /**< context */\n{\n  skip_mode_t mode = LEXER_SKIP_SPACES;\n  const uint8_t *source_end_p = context_p->source_end_p;\n\n  if (context_p->token.flags & LEXER_NO_SKIP_SPACES)\n  {\n    context_p->token.flags &= (uint8_t) ~LEXER_NO_SKIP_SPACES;\n    return;\n  }\n\n  context_p->token.flags = 0;\n\n  while (true)\n  {\n    if (context_p->source_p >= source_end_p)\n    {\n      if (mode == LEXER_SKIP_MULTI_LINE_COMMENT)\n      {\n        parser_raise_error (context_p, PARSER_ERR_UNTERMINATED_MULTILINE_COMMENT);\n      }\n      return;\n    }\n\n    switch (context_p->source_p[0])\n    {\n      case LIT_CHAR_CR:\n      {\n        if (context_p->source_p + 1 < source_end_p\n            && context_p->source_p[1] == LIT_CHAR_LF)\n        {\n          context_p->source_p++;\n        }\n        /* FALLTHRU */\n      }\n\n      case LIT_CHAR_LF:\n      {\n        context_p->line++;\n        context_p->column = 0;\n        context_p->token.flags = LEXER_WAS_NEWLINE;\n\n        if (mode == LEXER_SKIP_SINGLE_LINE_COMMENT)\n        {\n          mode = LEXER_SKIP_SPACES;\n        }\n        /* FALLTHRU */\n      }\n\n      case LIT_CHAR_VTAB:\n      case LIT_CHAR_FF:\n      case LIT_CHAR_SP:\n      {\n        context_p->source_p++;\n        context_p->column++;\n        continue;\n      }\n\n      case LIT_CHAR_TAB:\n      {\n        context_p->column = align_column_to_tab (context_p->column);\n        context_p->source_p++;\n        continue;\n      }\n\n      case LIT_CHAR_SLASH:\n      {\n        if (mode == LEXER_SKIP_SPACES\n            && context_p->source_p + 1 < source_end_p)\n        {\n          if (context_p->source_p[1] == LIT_CHAR_SLASH)\n          {\n            mode = LEXER_SKIP_SINGLE_LINE_COMMENT;\n          }\n          else if (context_p->source_p[1] == LIT_CHAR_ASTERISK)\n          {\n            mode = LEXER_SKIP_MULTI_LINE_COMMENT;\n            context_p->token.line = context_p->line;\n            context_p->token.column = context_p->column;\n          }\n\n          if (mode != LEXER_SKIP_SPACES)\n          {\n            context_p->source_p += 2;\n            PARSER_PLUS_EQUAL_LC (context_p->column, 2);\n            continue;\n          }\n        }\n        break;\n      }\n\n      case LIT_CHAR_ASTERISK:\n      {\n        if (mode == LEXER_SKIP_MULTI_LINE_COMMENT\n            && context_p->source_p + 1 < source_end_p\n            && context_p->source_p[1] == LIT_CHAR_SLASH)\n        {\n          mode = LEXER_SKIP_SPACES;\n          context_p->source_p += 2;\n          PARSER_PLUS_EQUAL_LC (context_p->column, 2);\n          continue;\n        }\n        break;\n      }\n\n      case 0xc2:\n      {\n        if (context_p->source_p + 1 < source_end_p\n            && context_p->source_p[1] == 0xa0)\n        {\n          /* Codepoint \\u00A0 */\n          context_p->source_p += 2;\n          context_p->column++;\n          continue;\n        }\n        break;\n      }\n\n      case LEXER_NEWLINE_LS_PS_BYTE_1:\n      {\n        JERRY_ASSERT (context_p->source_p + 2 < source_end_p);\n        if (LEXER_NEWLINE_LS_PS_BYTE_23 (context_p->source_p))\n        {\n          /* Codepoint \\u2028 and \\u2029 */\n          context_p->source_p += 3;\n          context_p->line++;\n          context_p->column = 1;\n          context_p->token.flags = LEXER_WAS_NEWLINE;\n\n          if (mode == LEXER_SKIP_SINGLE_LINE_COMMENT)\n          {\n            mode = LEXER_SKIP_SPACES;\n          }\n          continue;\n        }\n        break;\n      }\n\n      case 0xef:\n      {\n        if (context_p->source_p + 2 < source_end_p\n            && context_p->source_p[1] == 0xbb\n            && context_p->source_p[2] == 0xbf)\n        {\n          /* Codepoint \\uFEFF */\n          context_p->source_p += 3;\n          context_p->column++;\n          continue;\n        }\n        break;\n      }\n\n      default:\n      {\n        break;\n      }\n    }\n\n    if (mode == LEXER_SKIP_SPACES)\n    {\n      return;\n    }\n\n    context_p->source_p++;\n\n    if (context_p->source_p < source_end_p\n        && !IS_UTF8_INTERMEDIATE_OCTET (context_p->source_p[0]))\n    {\n      context_p->column++;\n    }\n  }\n}",
        "begin_line": 225,
        "end_line": 397,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_token_is_async#3699",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_token_is_async (parser_context_t *context_p) /**< context */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\nlexer_token_is_async (parser_context_t *context_p) /**< context */\n{\n  JERRY_ASSERT (context_p->token.type == LEXER_LITERAL\n                || context_p->token.type == LEXER_TEMPLATE_LITERAL);\n\n  return (context_p->token.keyword_type == LEXER_KEYW_ASYNC\n          && !(context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE));\n}",
        "begin_line": 3699,
        "end_line": 3707,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_token_is_identifier#3662",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_token_is_identifier (parser_context_t *context_p, /**< context */                            const char *identifier_p, /**< identifier */                            size_t identifier_length) /**< identifier length */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\nlexer_token_is_identifier (parser_context_t *context_p, /**< context */\n                           const char *identifier_p, /**< identifier */\n                           size_t identifier_length) /**< identifier length */\n{\n  /* Checking has_escape is unnecessary because memcmp will fail if escape sequences are present. */\n  return (context_p->token.type == LEXER_LITERAL\n          && context_p->token.lit_location.type == LEXER_IDENT_LITERAL\n          && context_p->token.lit_location.length == identifier_length\n          && memcmp (context_p->token.lit_location.char_p, identifier_p, identifier_length) == 0);\n}",
        "begin_line": 3662,
        "end_line": 3672,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-lexer.lexer_token_is_let#3682",
        "src_path": "jerry-core/parser/js/js-lexer.c",
        "class_name": "jerry-core.parser.js.js-lexer",
        "signature": "jerry-core.parser.js.js-lexer.lexer_token_is_let (parser_context_t *context_p) /**< context */",
        "snippet": "extern inline bool JERRY_ATTR_ALWAYS_INLINE\nlexer_token_is_let (parser_context_t *context_p) /**< context */\n{\n  JERRY_ASSERT (context_p->token.type == LEXER_LITERAL);\n\n  return (context_p->token.keyword_type == LEXER_KEYW_LET\n          && !(context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE));\n}",
        "begin_line": 3682,
        "end_line": 3689,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_append_binary_single_assignment_token#2818",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_append_binary_single_assignment_token (parser_context_t *context_p, /**< context */                                               uint32_t pattern_flags) /**< pattern flags */",
        "snippet": "static void\nparser_append_binary_single_assignment_token (parser_context_t *context_p, /**< context */\n                                              uint32_t pattern_flags) /**< pattern flags */\n{\n  JERRY_UNUSED (pattern_flags);\n\n  /* Unlike other tokens, the whole byte code is saved for binary\n   * assignment, since it has multiple forms depending on the\n   * previous instruction. */\n\n  uint8_t assign_opcode = CBC_ASSIGN;\n\n  if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)\n      && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)\n  {\n    parser_check_invalid_assign (context_p);\n\n    uint16_t literal_index;\n\n    switch (context_p->last_cbc_opcode)\n    {\n      case CBC_PUSH_LITERAL:\n      {\n        literal_index = context_p->last_cbc.literal_index;\n        context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n        break;\n      }\n      case CBC_PUSH_TWO_LITERALS:\n      {\n        literal_index = context_p->last_cbc.value;\n        context_p->last_cbc_opcode = CBC_PUSH_LITERAL;\n        break;\n      }\n      case CBC_PUSH_THIS_LITERAL:\n      {\n        literal_index = context_p->last_cbc.literal_index;\n        context_p->last_cbc_opcode = CBC_PUSH_THIS;\n        parser_flush_cbc (context_p);\n        break;\n      }\n      default:\n      {\n        JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_THREE_LITERALS);\n        literal_index = context_p->last_cbc.third_literal_index;\n        context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;\n        break;\n      }\n    }\n\n    assign_opcode = CBC_ASSIGN_SET_IDENT;\n\n#if JERRY_ESNEXT\n    if (!(pattern_flags & (PARSER_PATTERN_LET | PARSER_PATTERN_CONST | PARSER_PATTERN_LOCAL)))\n    {\n      if (scanner_literal_is_const_reg (context_p, literal_index))\n      {\n        parser_stack_push_uint8 (context_p, LEXER_ASSIGN_CONST);\n      }\n    }\n    else if (literal_index < PARSER_REGISTER_START)\n    {\n      assign_opcode = CBC_INIT_LET;\n\n      if (scanner_literal_is_created (context_p, literal_index))\n      {\n        assign_opcode = CBC_ASSIGN_LET_CONST;\n      }\n      else if (pattern_flags & PARSER_PATTERN_CONST)\n      {\n        assign_opcode = CBC_INIT_CONST;\n      }\n      else if (pattern_flags & PARSER_PATTERN_LOCAL)\n      {\n        assign_opcode = CBC_INIT_ARG_OR_CATCH;\n      }\n    }\n#endif /* JERRY_ESNEXT */\n\n    parser_stack_push_uint16 (context_p, literal_index);\n    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_LITERAL, assign_opcode));\n  }\n  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP)\n  {\n    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP, CBC_ASSIGN));\n    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n  }\n  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP_LITERAL)\n  {\n    if (context_p->last_cbc.literal_type != LEXER_IDENT_LITERAL)\n    {\n      JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP_LITERAL, CBC_ASSIGN_PROP_LITERAL));\n      parser_stack_push_uint16 (context_p, context_p->last_cbc.literal_index);\n      assign_opcode = CBC_ASSIGN_PROP_LITERAL;\n      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n    }\n    else\n    {\n      context_p->last_cbc_opcode = CBC_PUSH_LITERAL;\n    }\n  }\n  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP_LITERAL_LITERAL)\n  {\n    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP_LITERAL_LITERAL, CBC_PUSH_TWO_LITERALS));\n    context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;\n  }\n  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP_THIS_LITERAL)\n  {\n    if (context_p->last_cbc.literal_type != LEXER_IDENT_LITERAL)\n    {\n      JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP_THIS_LITERAL, CBC_ASSIGN_PROP_THIS_LITERAL));\n      parser_stack_push_uint16 (context_p, context_p->last_cbc.literal_index);\n      assign_opcode = CBC_ASSIGN_PROP_THIS_LITERAL;\n      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n    }\n    else\n    {\n      context_p->last_cbc_opcode = CBC_PUSH_THIS_LITERAL;\n    }\n  }\n#if JERRY_ESNEXT\n  else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL))\n  {\n    context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_LITERAL_ASSIGNMENT_REFERENCE);\n    parser_stack_push_uint8 (context_p, CBC_EXT_ASSIGN_SUPER);\n    assign_opcode = CBC_EXT_OPCODE;\n  }\n  else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP))\n  {\n    context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_ASSIGNMENT_REFERENCE);\n    parser_stack_push_uint8 (context_p, CBC_EXT_ASSIGN_SUPER);\n    assign_opcode = CBC_EXT_OPCODE;\n  }\n#endif /* JERRY_ESNEXT */\n  else\n  {\n    /* Invalid LeftHandSide expression. */ //3820, 3815\n#if JERRY_ESNEXT\n    parser_check_invalid_new_target (context_p, CBC_ASSIGN);\n    parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_ASSIGNMENT);\n#else /* !JERRY_ESNEXT */\n    parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);\n#endif /* JERRY_ESNEXT */\n  }\n\n  parser_stack_push_uint8 (context_p, assign_opcode);\n  parser_stack_push_uint8 (context_p, LEXER_ASSIGN);\n}",
        "begin_line": 2818,
        "end_line": 2964,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_append_binary_token#3009",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_append_binary_token (parser_context_t *context_p) /**< context */",
        "snippet": "static void\nparser_append_binary_token (parser_context_t *context_p) /**< context */\n{\n  JERRY_ASSERT (LEXER_IS_BINARY_OP_TOKEN (context_p->token.type));\n  parser_push_result (context_p);\n\n  if (context_p->token.type == LEXER_ASSIGN)\n  {\n    parser_append_binary_single_assignment_token (context_p, 0);\n    return;\n  }\n\n  if (LEXER_IS_BINARY_LVALUE_OP_TOKEN (context_p->token.type))\n  {\n    if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)\n        && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)\n    {\n      parser_check_invalid_assign (context_p);\n\n      parser_emit_ident_reference (context_p, CBC_PUSH_IDENT_REFERENCE);\n\n#if JERRY_ESNEXT\n      if (scanner_literal_is_const_reg (context_p, context_p->last_cbc.literal_index))\n      {\n        parser_stack_push_uint8 (context_p, LEXER_ASSIGN_CONST);\n      }\n#endif /* JERRY_ESNEXT */\n    }\n    else if (PARSER_IS_PUSH_PROP (context_p->last_cbc_opcode))\n    {\n      context_p->last_cbc_opcode = PARSER_PUSH_PROP_TO_PUSH_PROP_REFERENCE (context_p->last_cbc_opcode);\n    }\n    else\n    {\n      /* Invalid LeftHandSide expression. */\n#if JERRY_ESNEXT\n      parser_check_invalid_new_target (context_p, CBC_ASSIGN);\n      parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_ASSIGNMENT);\n#else /* !JERRY_ESNEXT */\n      parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);\n#endif /* JERRY_ESNEXT */\n\n      parser_emit_cbc (context_p, CBC_PUSH_PROP_REFERENCE);\n    }\n  }\n  else if (context_p->token.type == LEXER_LOGICAL_OR\n           || context_p->token.type == LEXER_LOGICAL_AND)\n  {\n    parser_branch_t branch;\n    uint16_t opcode = CBC_BRANCH_IF_LOGICAL_TRUE;\n\n    if (context_p->token.type == LEXER_LOGICAL_AND)\n    {\n      opcode = CBC_BRANCH_IF_LOGICAL_FALSE;\n    }\n\n#if JERRY_ESNEXT\n    parser_check_invalid_logical_op (context_p, LEXER_NULLISH_COALESCING, LEXER_NULLISH_COALESCING);\n#endif /* JERRY_ESNEXT */\n\n    parser_emit_cbc_forward_branch (context_p, opcode, &branch);\n    parser_stack_push (context_p, &branch, sizeof (parser_branch_t));\n    parser_stack_push_uint8 (context_p, context_p->token.type);\n    return;\n  }\n#if JERRY_ESNEXT\n  else if (context_p->token.type == LEXER_NULLISH_COALESCING)\n  {\n    parser_branch_t branch;\n\n    uint16_t opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_BRANCH_IF_NULLISH);\n    parser_emit_cbc_forward_branch (context_p, opcode, &branch);\n    parser_stack_push (context_p, &branch, sizeof (parser_branch_t));\n    parser_stack_push_uint8 (context_p, context_p->token.type);\n    return;\n  }\n#endif /* JERRY_ESNEXT */\n\n  parser_stack_push_uint8 (context_p, context_p->token.type);\n}",
        "begin_line": 3009,
        "end_line": 3088,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_check_invalid_assign#152",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_check_invalid_assign (parser_context_t *context_p) /**< context */",
        "snippet": "static void\nparser_check_invalid_assign (parser_context_t *context_p) /**< context */\n{\n  JERRY_ASSERT (context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL);\n\n  if (JERRY_UNLIKELY (context_p->status_flags & PARSER_IS_STRICT))\n  {\n    if (context_p->last_cbc.literal_keyword_type == LEXER_KEYW_EVAL)\n    {\n      parser_raise_error (context_p, PARSER_ERR_EVAL_CANNOT_ASSIGNED);\n    }\n    else if (context_p->last_cbc.literal_keyword_type == LEXER_KEYW_ARGUMENTS)\n    {\n      parser_raise_error (context_p, PARSER_ERR_ARGUMENTS_CANNOT_ASSIGNED);\n    }\n  }\n}",
        "begin_line": 152,
        "end_line": 168,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_emit_ident_reference#198",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_emit_ident_reference (parser_context_t *context_p, /**< context */                              uint16_t opcode) /* opcode */",
        "snippet": "static void\nparser_emit_ident_reference (parser_context_t *context_p, /**< context */\n                             uint16_t opcode) /* opcode */\n{\n  if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)\n  {\n    context_p->last_cbc_opcode = opcode;\n    return;\n  }\n\n  uint16_t literal_index;\n\n  if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)\n  {\n    context_p->last_cbc_opcode = CBC_PUSH_LITERAL;\n    literal_index = context_p->last_cbc.value;\n  }\n  else if (context_p->last_cbc_opcode == CBC_PUSH_THIS_LITERAL)\n  {\n    context_p->last_cbc_opcode = CBC_PUSH_THIS;\n    literal_index = context_p->last_cbc.literal_index;\n  }\n  else\n  {\n    JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_THREE_LITERALS);\n    context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;\n    literal_index = context_p->last_cbc.third_literal_index;\n  }\n\n  parser_emit_cbc_literal (context_p, opcode, literal_index);\n}",
        "begin_line": 198,
        "end_line": 228,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_emit_unary_lvalue_opcode#233",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_emit_unary_lvalue_opcode (parser_context_t *context_p, /**< context */                                  cbc_opcode_t opcode) /**< opcode */",
        "snippet": "static void\nparser_emit_unary_lvalue_opcode (parser_context_t *context_p, /**< context */\n                                 cbc_opcode_t opcode) /**< opcode */\n{\n  if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)\n      && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)\n  {\n    parser_check_invalid_assign (context_p);\n\n    uint16_t unary_opcode;\n\n    if (opcode == CBC_DELETE_PUSH_RESULT)\n    {\n      if (JERRY_UNLIKELY (context_p->status_flags & PARSER_IS_STRICT))\n      {\n        parser_raise_error (context_p, PARSER_ERR_DELETE_IDENT_NOT_ALLOWED);\n      }\n\n      unary_opcode = CBC_DELETE_IDENT_PUSH_RESULT;\n    }\n    else\n    {\n      JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_LITERAL, opcode + CBC_UNARY_LVALUE_WITH_IDENT));\n      unary_opcode = (uint16_t) (opcode + CBC_UNARY_LVALUE_WITH_IDENT);\n    }\n\n    parser_emit_ident_reference (context_p, unary_opcode);\n\n#if JERRY_ESNEXT\n    if (unary_opcode != CBC_DELETE_IDENT_PUSH_RESULT\n        && scanner_literal_is_const_reg (context_p, context_p->last_cbc.literal_index))\n    {\n      /* The current value must be read, but it cannot be changed. */\n      context_p->last_cbc_opcode = CBC_PUSH_LITERAL;\n      parser_emit_cbc_ext (context_p, CBC_EXT_THROW_ASSIGN_CONST_ERROR);\n    }\n#endif /* JERRY_ESNEXT */\n    return;\n  }\n\n  if (context_p->last_cbc_opcode == CBC_PUSH_PROP)\n  {\n    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP, opcode));\n    context_p->last_cbc_opcode = (uint16_t) opcode;\n    return;\n  }\n\n  if (PARSER_IS_PUSH_PROP_LITERAL (context_p->last_cbc_opcode))\n  {\n    context_p->last_cbc_opcode = PARSER_PUSH_PROP_LITERAL_TO_PUSH_LITERAL (context_p->last_cbc_opcode);\n  }\n  else\n  {\n    /* Invalid LeftHandSide expression. */\n    if (opcode == CBC_DELETE_PUSH_RESULT)\n    {\n#if JERRY_ESNEXT\n      if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL)\n          || context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP))\n      {\n        parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);\n        parser_emit_cbc (context_p, CBC_POP);\n        return;\n      }\n#endif /* JERRY_ESNEXT */\n      parser_emit_cbc (context_p, CBC_POP);\n      parser_emit_cbc (context_p, CBC_PUSH_TRUE);\n      return;\n    }\n\n#if JERRY_ESNEXT\n    parser_check_invalid_new_target (context_p, opcode);\n    if (opcode == CBC_PRE_INCR || opcode == CBC_PRE_DECR)\n    {\n      parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_PREFIX_OP);\n    }\n    else\n    {\n      parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_POSTFIX_OP);\n    }\n#else /* JERRY_ESNEXT */\n    parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);\n#endif /* JERRY_ESNEXT */\n  }\n\n  parser_emit_cbc (context_p, (uint16_t) opcode);\n}",
        "begin_line": 233,
        "end_line": 319,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_parse_array_literal#324",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_parse_array_literal (parser_context_t *context_p) /**< context */",
        "snippet": "static void\nparser_parse_array_literal (parser_context_t *context_p) /**< context */\n{\n  uint32_t pushed_items = 0;\n  uint16_t opcode = (uint16_t) CBC_ARRAY_APPEND;\n\n  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_SQUARE);\n\n  parser_emit_cbc (context_p, CBC_CREATE_ARRAY);\n  lexer_next_token (context_p);\n\n  while (true)\n  {\n    if (context_p->token.type == LEXER_RIGHT_SQUARE)\n    {\n      if (pushed_items > 0)\n      {\n        parser_emit_cbc_call (context_p, opcode, pushed_items);\n      }\n      return;\n    }\n\n    pushed_items++;\n\n    if (context_p->token.type == LEXER_COMMA)\n    {\n      parser_emit_cbc (context_p, CBC_PUSH_ELISION);\n      lexer_next_token (context_p);\n    }\n    else\n    {\n#if JERRY_ESNEXT\n      if (context_p->token.type == LEXER_THREE_DOTS)\n      {\n        opcode = (uint16_t) (PARSER_TO_EXT_OPCODE (CBC_EXT_SPREAD_ARRAY_APPEND));\n        pushed_items++;\n        lexer_next_token (context_p);\n        parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SPREAD_ELEMENT);\n      }\n#endif /* JERRY_ESNEXT */\n\n      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);\n\n      if (context_p->last_cbc_opcode == CBC_PUSH_THIS)\n      {\n        parser_flush_cbc (context_p);\n      }\n\n      if (context_p->token.type == LEXER_COMMA)\n      {\n        lexer_next_token (context_p);\n      }\n      else if (context_p->token.type != LEXER_RIGHT_SQUARE)\n      {\n        parser_raise_error (context_p, PARSER_ERR_ARRAY_ITEM_SEPARATOR_EXPECTED);\n      }\n    }\n\n    if (pushed_items >= 64)\n    {\n      parser_emit_cbc_call (context_p, opcode, pushed_items);\n#if JERRY_ESNEXT\n      opcode = (uint16_t) CBC_ARRAY_APPEND;\n#endif /* JERRY_ESNEXT */\n      pushed_items = 0;\n    }\n  }\n}",
        "begin_line": 324,
        "end_line": 391,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_parse_block_expression#3977",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_parse_block_expression (parser_context_t *context_p, /**< context */                                int options) /**< option flags */",
        "snippet": "void\nparser_parse_block_expression (parser_context_t *context_p, /**< context */\n                               int options) /**< option flags */\n{\n  parser_parse_expression (context_p, options | PARSE_EXPR_NO_PUSH_RESULT);\n\n  if (CBC_NO_RESULT_OPERATION (context_p->last_cbc_opcode))\n  {\n    JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, context_p->last_cbc_opcode + 2));\n    PARSER_PLUS_EQUAL_U16 (context_p->last_cbc_opcode, 2);\n    parser_flush_cbc (context_p);\n  }\n  else\n  {\n    parser_emit_cbc (context_p, CBC_POP_BLOCK);\n  }\n}",
        "begin_line": 3977,
        "end_line": 3993,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_parse_expression#4016",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_parse_expression (parser_context_t *context_p, /**< context */                          int options) /**< option flags */",
        "snippet": "void\nparser_parse_expression (parser_context_t *context_p, /**< context */\n                         int options) /**< option flags */\n{\n  size_t grouping_level = (options & PARSE_EXPR_LEFT_HAND_SIDE);\n\n  parser_stack_push_uint8 (context_p, LEXER_EXPRESSION_START);\n\n  if (options & PARSE_EXPR_HAS_LITERAL)\n  {\n    JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);\n    goto process_unary_expression;\n  }\n\n  while (true)\n  {\n    if (parser_parse_unary_expression (context_p, &grouping_level))\n    {\n      parser_process_binary_opcodes (context_p, 0);\n      break;\n    }\n\n    while (true)\n    {\nprocess_unary_expression:\n      parser_process_unary_expression (context_p, grouping_level);\n\n      if (JERRY_LIKELY (grouping_level != PARSE_EXPR_LEFT_HAND_SIDE))\n      {\n        uint8_t min_prec_treshold = 0;\n\n        if (LEXER_IS_BINARY_OP_TOKEN (context_p->token.type))\n        {\n#if JERRY_ESNEXT\n          if (JERRY_UNLIKELY (context_p->token.type == LEXER_NULLISH_COALESCING))\n          {\n            parser_check_invalid_logical_op (context_p, LEXER_LOGICAL_OR, LEXER_LOGICAL_AND);\n          }\n#endif /* JERRY_ESNEXT */\n\n          min_prec_treshold = parser_binary_precedence_table[context_p->token.type - LEXER_FIRST_BINARY_OP];\n\n#if JERRY_ESNEXT\n          /* Check for BINARY_LVALUE tokens + LEXER_LOGICAL_OR + LEXER_LOGICAL_AND + LEXER_EXPONENTIATION */\n          if ((min_prec_treshold == PARSER_RIGHT_TO_LEFT_ORDER_EXPONENTIATION)\n              || (min_prec_treshold <= PARSER_RIGHT_TO_LEFT_ORDER_MAX_PRECEDENCE\n                  && min_prec_treshold != PARSER_RIGHT_TO_LEFT_ORDER_TERNARY_PRECEDENCE))\n          {\n            /* Right-to-left evaluation order. */\n            min_prec_treshold++;\n          }\n#else /* !JERRY_ESNEXT */\n          /* Check for BINARY_LVALUE tokens + LEXER_LOGICAL_OR + LEXER_LOGICAL_AND */\n          if (min_prec_treshold <= PARSER_RIGHT_TO_LEFT_ORDER_MAX_PRECEDENCE\n              && min_prec_treshold != PARSER_RIGHT_TO_LEFT_ORDER_TERNARY_PRECEDENCE)\n          {\n            /* Right-to-left evaluation order. */\n            min_prec_treshold++;\n          }\n#endif /* JERRY_ESNEXT */\n        }\n\n        parser_process_binary_opcodes (context_p, min_prec_treshold);\n      }\n      if (context_p->token.type == LEXER_RIGHT_PAREN\n          && (context_p->stack_top_uint8 == LEXER_LEFT_PAREN\n              || context_p->stack_top_uint8 == LEXER_COMMA_SEP_LIST))\n      {\n        parser_process_group_expression (context_p, &grouping_level);\n        continue;\n      }\n\n      break;\n    }\n\n    if (grouping_level == PARSE_EXPR_LEFT_HAND_SIDE)\n    {\n      break;\n    }\n\n    if (JERRY_UNLIKELY (context_p->token.type == LEXER_QUESTION_MARK))\n    {\n      parser_process_ternary_expression (context_p);\n\n      if (context_p->token.type == LEXER_RIGHT_PAREN)\n      {\n        goto process_unary_expression;\n      }\n    }\n    else if (LEXER_IS_BINARY_OP_TOKEN (context_p->token.type))\n    {\n      parser_append_binary_token (context_p);\n      lexer_next_token (context_p);\n      continue;\n    }\n\n    if (JERRY_UNLIKELY (context_p->token.type == LEXER_COMMA)\n        && (!(options & PARSE_EXPR_NO_COMMA) || grouping_level >= PARSER_GROUPING_LEVEL_INCREASE))\n    {\n      parser_process_expression_sequence (context_p);\n      continue;\n    }\n\n    break;\n  }\n\n  if (grouping_level >= PARSER_GROUPING_LEVEL_INCREASE)\n  {\n    parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);\n  }\n\n  JERRY_ASSERT (context_p->stack_top_uint8 == LEXER_EXPRESSION_START);\n  parser_stack_pop_uint8 (context_p);\n\n  if (!(options & PARSE_EXPR_NO_PUSH_RESULT))\n  {\n    parser_push_result (context_p);\n  }\n}",
        "begin_line": 4016,
        "end_line": 4134,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_parse_expression_statement#3998",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_parse_expression_statement (parser_context_t *context_p, /**< context */                                    int options) /**< option flags */",
        "snippet": "void\nparser_parse_expression_statement (parser_context_t *context_p, /**< context */\n                                   int options) /**< option flags */\n{\n  parser_parse_expression (context_p, options | PARSE_EXPR_NO_PUSH_RESULT);\n\n  if (!CBC_NO_RESULT_OPERATION (context_p->last_cbc_opcode))\n  {\n    parser_emit_cbc (context_p, CBC_POP);\n  }\n}",
        "begin_line": 3998,
        "end_line": 4008,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_parse_function_expression#1541",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_parse_function_expression (parser_context_t *context_p, /**< context */                                   uint32_t status_flags) /**< function status flags */",
        "snippet": "static void\nparser_parse_function_expression (parser_context_t *context_p, /**< context */\n                                  uint32_t status_flags) /**< function status flags */\n{\n  int literals = 0;\n  uint16_t literal1 = 0;\n  uint16_t literal2 = 0;\n  uint16_t function_literal_index;\n  int32_t function_name_index = -1;\n\n#if !JERRY_ESNEXT\n  JERRY_ASSERT (status_flags & PARSER_IS_FUNC_EXPRESSION);\n#endif /* !JERRY_ESNEXT */\n\n#if JERRY_ESNEXT\n  if (status_flags & PARSER_IS_FUNC_EXPRESSION)\n  {\n#endif /* !JERRY_ESNEXT */\n\n#if JERRY_DEBUGGER\n    parser_line_counter_t debugger_line = context_p->token.line;\n    parser_line_counter_t debugger_column = context_p->token.column;\n#endif /* JERRY_DEBUGGER */\n\n#if JERRY_ESNEXT\n    uint32_t parent_status_flags = context_p->status_flags;\n\n    context_p->status_flags &= (uint32_t) ~(PARSER_IS_ASYNC_FUNCTION\n                                            | PARSER_IS_GENERATOR_FUNCTION\n                                            | PARSER_DISALLOW_AWAIT_YIELD);\n\n    if (status_flags & PARSER_IS_ASYNC_FUNCTION)\n    {\n      /* The name of the function cannot be await. */\n      context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;\n    }\n\n    if (lexer_consume_generator (context_p))\n    {\n      /* The name of the function cannot be yield. */\n      context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;\n      status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;\n    }\n#endif /* JERRY_ESNEXT */\n\n    if (!lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))\n    {\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_LITERAL\n          || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n      {\n        parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);\n      }\n\n      parser_flush_cbc (context_p);\n\n      lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_STRING_LITERAL);\n\n#if JERRY_DEBUGGER\n      if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n      {\n        jerry_debugger_send_string (JERRY_DEBUGGER_FUNCTION_NAME,\n                                    JERRY_DEBUGGER_NO_SUBTYPE,\n                                    context_p->lit_object.literal_p->u.char_p,\n                                    context_p->lit_object.literal_p->prop.length);\n\n        /* Reset token position for the function. */\n        context_p->token.line = debugger_line;\n        context_p->token.column = debugger_column;\n      }\n#endif /* JERRY_DEBUGGER */\n\n      if (context_p->token.keyword_type >= LEXER_FIRST_NON_STRICT_ARGUMENTS)\n      {\n        status_flags |= PARSER_HAS_NON_STRICT_ARG;\n      }\n\n      function_name_index = context_p->lit_object.index;\n    }\n\n#if JERRY_ESNEXT\n    context_p->status_flags = parent_status_flags;\n  }\n#endif /* JERRY_ESNEXT */\n\n  if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)\n  {\n    literals = 1;\n    literal1 = context_p->last_cbc.literal_index;\n    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n  }\n  else if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)\n  {\n    literals = 2;\n    literal1 = context_p->last_cbc.literal_index;\n    literal2 = context_p->last_cbc.value;\n    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n  }\n\n  function_literal_index = lexer_construct_function_object (context_p, status_flags);\n\n  JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);\n\n#if JERRY_ESNEXT\n  if (function_name_index != -1)\n  {\n    parser_set_function_name (context_p, function_literal_index, (uint16_t) function_name_index, 0);\n  }\n#endif /* JERRY_ESNEXT */\n\n  if (literals == 1)\n  {\n    context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;\n    context_p->last_cbc.literal_index = literal1;\n    context_p->last_cbc.value = function_literal_index;\n  }\n  else if (literals == 2)\n  {\n    context_p->last_cbc_opcode = CBC_PUSH_THREE_LITERALS;\n    context_p->last_cbc.literal_index = literal1;\n    context_p->last_cbc.value = literal2;\n    context_p->last_cbc.third_literal_index = function_literal_index;\n  }\n  else\n  {\n    parser_emit_cbc_literal (context_p,\n                             CBC_PUSH_LITERAL,\n                             function_literal_index);\n\n    if (function_name_index != -1)\n    {\n      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_NAMED_FUNC_EXPRESSION);\n      context_p->last_cbc.value = (uint16_t) function_name_index;\n    }\n  }\n\n  context_p->last_cbc.literal_type = LEXER_FUNCTION_LITERAL;\n  context_p->last_cbc.literal_keyword_type = LEXER_EOS;\n}",
        "begin_line": 1541,
        "end_line": 1680,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_parse_object_literal#1140",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_parse_object_literal (parser_context_t *context_p) /**< context */",
        "snippet": "static void\nparser_parse_object_literal (parser_context_t *context_p) /**< context */\n{\n  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_BRACE);\n\n  parser_emit_cbc (context_p, CBC_CREATE_OBJECT);\n\n#if !JERRY_ESNEXT\n  parser_stack_push_uint8 (context_p, PARSER_OBJECT_PROPERTY_START);\n#endif /* !JERRY_ESNEXT */\n\n#if JERRY_ESNEXT\n  bool proto_seen = false;\n  bool has_super_env = false;\n\n  if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n  {\n    JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS);\n\n    if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_SUPER)\n    {\n      parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_OBJECT_SUPER_ENVIRONMENT);\n      has_super_env = true;\n    }\n\n    scanner_release_next (context_p, sizeof (scanner_info_t));\n  }\n#endif /* JERRY_ESNEXT */\n\n  while (true)\n  {\n    lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_SET_FUNCTION_START);\n\n    switch (context_p->token.type)\n    {\n      case LEXER_RIGHT_BRACE:\n      {\n        break;\n      }\n      case LEXER_PROPERTY_GETTER:\n      case LEXER_PROPERTY_SETTER:\n      {\n        uint32_t status_flags;\n        cbc_ext_opcode_t opcode;\n#if !JERRY_ESNEXT\n        parser_object_literal_item_types_t item_type;\n#endif /* !JERRY_ESNEXT */\n        bool is_getter = context_p->token.type == LEXER_PROPERTY_GETTER;\n\n        if (is_getter)\n        {\n          status_flags = PARSER_FUNCTION_CLOSURE | PARSER_IS_PROPERTY_GETTER;\n          opcode = CBC_EXT_SET_GETTER;\n#if !JERRY_ESNEXT\n          item_type = PARSER_OBJECT_PROPERTY_GETTER;\n#endif /* !JERRY_ESNEXT */\n        }\n        else\n        {\n          status_flags = PARSER_FUNCTION_CLOSURE | PARSER_IS_PROPERTY_SETTER;\n          opcode = CBC_EXT_SET_SETTER;\n#if !JERRY_ESNEXT\n          item_type = PARSER_OBJECT_PROPERTY_SETTER;\n#endif /* !JERRY_ESNEXT */\n        }\n\n#if JERRY_ESNEXT\n        status_flags |= PARSER_ALLOW_SUPER;\n#endif /* !JERRY_ESNEXT */\n\n        lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_ONLY_IDENTIFIERS);\n\n        /* This assignment is a nop for computed getters/setters. */\n        uint16_t literal_index = context_p->lit_object.index;\n\n#if JERRY_ESNEXT\n        bool is_computed = context_p->token.type == LEXER_RIGHT_SQUARE;\n\n        if (is_computed)\n        {\n          opcode = ((opcode == CBC_EXT_SET_GETTER) ? CBC_EXT_SET_COMPUTED_GETTER\n                                                   : CBC_EXT_SET_COMPUTED_SETTER);\n        }\n#else /* !JERRY_ESNEXT */\n        parser_append_object_literal_item (context_p, literal_index, item_type);\n#endif /* JERRY_ESNEXT */\n\n        uint16_t function_literal_index = lexer_construct_function_object (context_p, status_flags);\n\n#if JERRY_ESNEXT\n        if (opcode >= CBC_EXT_SET_COMPUTED_GETTER)\n        {\n          literal_index = function_literal_index;\n        }\n#endif /* JERRY_ESNEXT */\n\n        parser_emit_cbc_literal (context_p,\n                                 CBC_PUSH_LITERAL,\n                                 literal_index);\n\n        JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);\n\n#if JERRY_ESNEXT\n        if (is_computed)\n        {\n          parser_emit_cbc_ext (context_p, is_getter ? CBC_EXT_SET_COMPUTED_GETTER_NAME\n                                                    : CBC_EXT_SET_COMPUTED_SETTER_NAME);\n\n          if (has_super_env)\n          {\n            parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED);\n          }\n          parser_emit_cbc_ext (context_p, opcode);\n          lexer_next_token (context_p);\n          break;\n        }\n\n        parser_set_function_name (context_p, function_literal_index, literal_index, status_flags);\n\n        if (has_super_env)\n        {\n          context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;\n          context_p->last_cbc.value = function_literal_index;\n          parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED);\n          parser_emit_cbc_ext (context_p, is_getter ? CBC_EXT_SET_COMPUTED_GETTER\n                                                    : CBC_EXT_SET_COMPUTED_SETTER);\n        }\n        else\n#endif /* JERRY_ESNEXT */\n        {\n          context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (opcode);\n          context_p->last_cbc.value = function_literal_index;\n        }\n\n        lexer_next_token (context_p);\n        break;\n      }\n#if JERRY_ESNEXT\n      case LEXER_RIGHT_SQUARE:\n      {\n        lexer_next_token (context_p);\n\n        if (context_p->token.type == LEXER_LEFT_PAREN)\n        {\n          parser_parse_object_method (context_p);\n          JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);\n\n          if (parser_check_anonymous_function_declaration (context_p) < PARSER_NAMED_FUNCTION)\n          {\n            parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_FUNCTION_NAME);\n            if (has_super_env)\n            {\n              parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED);\n            }\n            parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_PROPERTY);\n          }\n          else\n          {\n            context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SET_COMPUTED_PROPERTY_LITERAL);\n          }\n\n          break;\n        }\n\n        if (context_p->token.type != LEXER_COLON)\n        {\n          parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);\n        }\n\n        lexer_next_token (context_p);\n        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);\n\n        if (parser_check_anonymous_function_declaration (context_p) < PARSER_NAMED_FUNCTION)\n        {\n          parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_FUNCTION_NAME);\n        }\n\n        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)\n        {\n          context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SET_COMPUTED_PROPERTY_LITERAL);\n        }\n        else\n        {\n          parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_PROPERTY);\n        }\n        break;\n      }\n      case LEXER_THREE_DOTS:\n      {\n        lexer_next_token (context_p);\n        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);\n        parser_emit_cbc_ext (context_p, CBC_EXT_COPY_DATA_PROPERTIES);\n        break;\n      }\n      case LEXER_KEYW_ASYNC:\n      case LEXER_MULTIPLY:\n      {\n        uint32_t status_flags = PARSER_FUNCTION_CLOSURE;\n\n        if (context_p->token.type == LEXER_KEYW_ASYNC)\n        {\n          status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;\n          lexer_consume_generator (context_p);\n        }\n\n        if (context_p->token.type == LEXER_MULTIPLY)\n        {\n          status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;\n        }\n\n        if (has_super_env)\n        {\n          status_flags |= PARSER_ALLOW_SUPER;\n        }\n\n        lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_ONLY_IDENTIFIERS);\n\n        uint16_t opcode = CBC_SET_LITERAL_PROPERTY;\n        /* This assignment is a nop for CBC_EXT_SET_COMPUTED_PROPERTY_LITERAL. */\n        uint16_t literal_index = context_p->lit_object.index;\n        bool is_computed = context_p->token.type == LEXER_RIGHT_SQUARE;\n\n        if (is_computed)\n        {\n          opcode = CBC_EXT_SET_COMPUTED_PROPERTY;\n        }\n\n        uint16_t function_literal_index = lexer_construct_function_object (context_p, status_flags);\n\n        parser_emit_cbc_literal (context_p,\n                                 CBC_PUSH_LITERAL,\n                                 function_literal_index);\n\n        JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);\n\n        if (is_computed)\n        {\n          parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_FUNCTION_NAME);\n          if (has_super_env)\n          {\n            parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED);\n          }\n          parser_emit_cbc_ext (context_p, opcode);\n          lexer_next_token (context_p);\n          break;\n        }\n\n        parser_set_function_name (context_p, function_literal_index, literal_index, status_flags);\n\n        if (has_super_env)\n        {\n          parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT);\n          parser_emit_cbc_literal (context_p, CBC_SET_PROPERTY, literal_index);\n        }\n        else\n        {\n          context_p->last_cbc_opcode = opcode;\n          context_p->last_cbc.value = literal_index;\n        }\n\n        lexer_next_token (context_p);\n        break;\n      }\n#endif /* JERRY_ESNEXT */\n      default:\n      {\n#if JERRY_ESNEXT\n        const lexer_lit_location_t *literal_p = (const lexer_lit_location_t *) context_p->lit_object.literal_p;\n        bool is_proto = ((context_p->token.lit_location.type == LEXER_IDENT_LITERAL\n                          || context_p->token.lit_location.type == LEXER_STRING_LITERAL)\n                         && lexer_compare_identifier_to_string (literal_p, (uint8_t *) \"__proto__\", 9)\n                         && lexer_check_next_character (context_p, LIT_CHAR_COLON));\n        if (is_proto)\n        {\n          if (proto_seen)\n          {\n            parser_raise_error (context_p, PARSER_ERR_DUPLICATED_PROTO);\n          }\n\n          proto_seen = true;\n        }\n#endif /* JERRY_ESNEXT */\n\n        uint16_t literal_index = context_p->lit_object.index;\n\n#if JERRY_ESNEXT\n        parser_line_counter_t start_line = context_p->token.line;\n        parser_line_counter_t start_column = context_p->token.column;\n#else /* !JERRY_ESNEXT */\n        parser_append_object_literal_item (context_p,\n                                           literal_index,\n                                           PARSER_OBJECT_PROPERTY_VALUE);\n#endif /* JERRY_ESNEXT */\n\n        lexer_next_token (context_p);\n\n#if JERRY_ESNEXT\n        if (context_p->token.type == LEXER_LEFT_PAREN && !is_proto)\n        {\n          parser_parse_object_method (context_p);\n\n          JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);\n          parser_set_function_name (context_p, context_p->last_cbc.literal_index, literal_index, 0);\n\n          if (has_super_env)\n          {\n            parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT);\n            parser_emit_cbc_literal (context_p, CBC_SET_PROPERTY, literal_index);\n            break;\n          }\n\n          context_p->last_cbc_opcode = CBC_SET_LITERAL_PROPERTY;\n          context_p->last_cbc.value = literal_index;\n          break;\n        }\n\n        if ((context_p->token.type == LEXER_RIGHT_BRACE || context_p->token.type == LEXER_COMMA)\n            && !is_proto)\n        {\n          parser_reparse_as_common_identifier (context_p, start_line, start_column);\n          parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);\n\n          context_p->last_cbc_opcode = CBC_SET_LITERAL_PROPERTY;\n          context_p->last_cbc.value = literal_index;\n\n          lexer_next_token (context_p);\n          break;\n        }\n#endif /* JERRY_ESNEXT */\n\n        if (context_p->token.type != LEXER_COLON)\n        {\n          parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);\n        }\n\n        lexer_next_token (context_p);\n        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);\n\n#if JERRY_ESNEXT\n        if (is_proto)\n        {\n          parser_emit_cbc_ext (context_p, CBC_EXT_SET__PROTO__);\n          break;\n        }\n#endif /* JERRY_ESNEXT */\n\n        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)\n        {\n#if JERRY_ESNEXT\n          if (context_p->last_cbc.literal_type == LEXER_FUNCTION_LITERAL)\n          {\n            parser_set_function_name (context_p, context_p->last_cbc.literal_index, literal_index, 0);\n          }\n#endif /* JERRY_ESNEXT */\n          context_p->last_cbc_opcode = CBC_SET_LITERAL_PROPERTY;\n          context_p->last_cbc.value = literal_index;\n        }\n        else\n        {\n#if JERRY_ESNEXT\n          if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_FINALIZE_ANONYMOUS_CLASS))\n          {\n            uint16_t name_index = scanner_save_literal (context_p, literal_index);\n            parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_CLASS_NAME, name_index);\n          }\n#endif /* JERRY_ESNEXT */\n          parser_emit_cbc_literal (context_p, CBC_SET_PROPERTY, literal_index);\n        }\n\n        break;\n      }\n    }\n\n    if (context_p->token.type == LEXER_RIGHT_BRACE)\n    {\n      break;\n    }\n    else if (context_p->token.type != LEXER_COMMA)\n    {\n      parser_raise_error (context_p, PARSER_ERR_OBJECT_ITEM_SEPARATOR_EXPECTED);\n    }\n  }\n\n#if !JERRY_ESNEXT\n  while (context_p->stack_top_uint8 != PARSER_OBJECT_PROPERTY_START)\n  {\n    parser_stack_pop (context_p, NULL, 3);\n  }\n\n  parser_stack_pop_uint8 (context_p);\n#else /* JERRY_ESNEXT */\n  if (has_super_env)\n  {\n    parser_emit_cbc_ext (context_p, CBC_EXT_POP_OBJECT_SUPER_ENVIRONMENT);\n  }\n#endif /* !JERRY_ESNEXT */\n}",
        "begin_line": 1140,
        "end_line": 1536,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_parse_unary_expression#1893",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_parse_unary_expression (parser_context_t *context_p, /**< context */                                size_t *grouping_level_p) /**< grouping level */",
        "snippet": "static bool\nparser_parse_unary_expression (parser_context_t *context_p, /**< context */\n                               size_t *grouping_level_p) /**< grouping level */\n{\n  bool new_was_seen = false;\n\n  /* Collect unary operators. */\n  while (true)\n  {\n    /* Convert plus and minus binary operators to unary operators. */\n    switch (context_p->token.type)\n    {\n      case LEXER_ADD:\n      {\n        context_p->token.type = LEXER_PLUS;\n        break;\n      }\n      case LEXER_SUBTRACT:\n      {\n        context_p->token.type = LEXER_NEGATE;\n        break;\n      }\n#if JERRY_ESNEXT\n      case LEXER_KEYW_AWAIT:\n      {\n#if JERRY_MODULE_SYSTEM\n        if ((context_p->global_status_flags & ECMA_PARSE_MODULE)\n            && !(context_p->status_flags & PARSER_IS_ASYNC_FUNCTION))\n        {\n          parser_raise_error (context_p, PARSER_ERR_AWAIT_NOT_ALLOWED);\n        }\n#endif /* JERRY_MODULE_SYSTEM */\n\n        if (JERRY_UNLIKELY (context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE))\n        {\n          parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);\n        }\n        break;\n      }\n#endif /* JERRY_ESNEXT */\n    }\n\n    /* Bracketed expressions are primary expressions. At this\n     * point their left paren is pushed onto the stack and\n     * they are processed when their closing paren is reached. */\n    if (context_p->token.type == LEXER_LEFT_PAREN)\n    {\n#if JERRY_ESNEXT\n      if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n      {\n        JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);\n        break;\n      }\n#endif /* JERRY_ESNEXT */\n      (*grouping_level_p) += PARSER_GROUPING_LEVEL_INCREASE;\n      new_was_seen = false;\n    }\n    else if (context_p->token.type == LEXER_KEYW_NEW)\n    {\n      /* After 'new' unary operators are not allowed. */\n      new_was_seen = true;\n\n#if JERRY_ESNEXT\n      /* Check if \"new.target\" is written here. */\n      if (scanner_try_scan_new_target (context_p))\n      {\n        if (!(context_p->status_flags & PARSER_ALLOW_NEW_TARGET))\n        {\n          parser_raise_error (context_p, PARSER_ERR_NEW_TARGET_NOT_ALLOWED);\n        }\n\n        parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_NEW_TARGET);\n        lexer_next_token (context_p);\n        /* Found \"new.target\" return here */\n        return false;\n      }\n#endif /* JERRY_ESNEXT */\n    }\n    else if (new_was_seen\n             || (*grouping_level_p == PARSE_EXPR_LEFT_HAND_SIDE)\n             || !LEXER_IS_UNARY_OP_TOKEN (context_p->token.type))\n    {\n      break;\n    }\n\n    parser_stack_push_uint8 (context_p, context_p->token.type);\n    lexer_next_token (context_p);\n  }\n\n  /* Parse primary expression. */\n  switch (context_p->token.type)\n  {\n#if JERRY_ESNEXT\n    case LEXER_TEMPLATE_LITERAL:\n    {\n      if (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)\n      {\n        parser_parse_template_literal (context_p);\n        break;\n      }\n\n      /* The string is a normal string literal. */\n      /* FALLTHRU */\n    }\n#endif /* JERRY_ESNEXT */\n    case LEXER_LITERAL:\n    {\n#if JERRY_ESNEXT\n      if (JERRY_UNLIKELY (context_p->next_scanner_info_p->source_p == context_p->source_p))\n      {\n        JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);\n\n#if JERRY_FUNCTION_TO_STRING\n        context_p->function_start_p = context_p->token.lit_location.char_p;\n#endif /* JERRY_FUNCTION_TO_STRING */\n\n        uint32_t arrow_status_flags = (PARSER_IS_FUNCTION\n                                       | PARSER_IS_ARROW_FUNCTION\n                                       | (context_p->status_flags & PARSER_INSIDE_CLASS_FIELD));\n\n        if (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_ASYNC)\n        {\n          JERRY_ASSERT (lexer_token_is_async (context_p));\n          JERRY_ASSERT (!(context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_STATEMENT));\n\n          uint32_t saved_status_flags = context_p->status_flags;\n\n          context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;\n          lexer_next_token (context_p);\n          context_p->status_flags = saved_status_flags;\n\n          if (context_p->token.type == LEXER_KEYW_FUNCTION)\n          {\n            uint32_t status_flags = (PARSER_FUNCTION_CLOSURE\n                                     | PARSER_IS_FUNC_EXPRESSION\n                                     | PARSER_IS_ASYNC_FUNCTION\n                                     | PARSER_DISALLOW_AWAIT_YIELD);\n            parser_parse_function_expression (context_p, status_flags);\n            break;\n          }\n\n          arrow_status_flags = (PARSER_IS_FUNCTION\n                                | PARSER_IS_ARROW_FUNCTION\n                                | PARSER_IS_ASYNC_FUNCTION\n                                | PARSER_DISALLOW_AWAIT_YIELD);\n        }\n\n        parser_check_assignment_expr (context_p);\n        parser_parse_function_expression (context_p, arrow_status_flags);\n        return parser_abort_parsing_after_assignment_expression (context_p);\n      }\n#endif /* JERRY_ESNEXT */\n\n      uint8_t type = context_p->token.lit_location.type;\n\n      if (type == LEXER_IDENT_LITERAL || type == LEXER_STRING_LITERAL)\n      {\n        lexer_construct_literal_object (context_p,\n                                        &context_p->token.lit_location,\n                                        context_p->token.lit_location.type);\n      }\n      else if (type == LEXER_NUMBER_LITERAL)\n      {\n        bool is_negative_number = false;\n\n        if ((context_p->stack_top_uint8 == LEXER_PLUS || context_p->stack_top_uint8 == LEXER_NEGATE)\n            && !lexer_check_post_primary_exp (context_p))\n        {\n          do\n          {\n            if (context_p->stack_top_uint8 == LEXER_NEGATE)\n            {\n              is_negative_number = !is_negative_number;\n            }\n#if JERRY_BUILTIN_BIGINT\n            else if (JERRY_LIKELY (context_p->token.extra_value == LEXER_NUMBER_BIGINT))\n            {\n              break;\n            }\n#endif /* JERRY_BUILTIN_BIGINT */\n            parser_stack_pop_uint8 (context_p);\n          }\n          while (context_p->stack_top_uint8 == LEXER_PLUS\n                 || context_p->stack_top_uint8 == LEXER_NEGATE);\n        }\n\n        if (lexer_construct_number_object (context_p, true, is_negative_number))\n        {\n          JERRY_ASSERT (context_p->lit_object.index <= CBC_PUSH_NUMBER_BYTE_RANGE_END);\n\n          parser_emit_cbc_push_number (context_p, is_negative_number);\n          break;\n        }\n      }\n\n      cbc_opcode_t opcode = CBC_PUSH_LITERAL;\n\n      if (context_p->token.keyword_type != LEXER_KEYW_EVAL)\n      {\n        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)\n        {\n          context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;\n          context_p->last_cbc.value = context_p->lit_object.index;\n          context_p->last_cbc.literal_type = context_p->token.lit_location.type;\n          context_p->last_cbc.literal_keyword_type = context_p->token.keyword_type;\n          break;\n        }\n\n        if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)\n        {\n          context_p->last_cbc_opcode = CBC_PUSH_THREE_LITERALS;\n          context_p->last_cbc.third_literal_index = context_p->lit_object.index;\n          context_p->last_cbc.literal_type = context_p->token.lit_location.type;\n          context_p->last_cbc.literal_keyword_type = context_p->token.keyword_type;\n          break;\n        }\n\n        if (context_p->last_cbc_opcode == CBC_PUSH_THIS)\n        {\n          context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n          opcode = CBC_PUSH_THIS_LITERAL;\n        }\n      }\n\n      parser_emit_cbc_literal_from_token (context_p, (uint16_t) opcode);\n      break;\n    }\n    case LEXER_KEYW_FUNCTION:\n    {\n#if JERRY_FUNCTION_TO_STRING\n      context_p->function_start_p = context_p->token.lit_location.char_p;\n#endif /* JERRY_FUNCTION_TO_STRING */\n      parser_parse_function_expression (context_p, PARSER_FUNCTION_CLOSURE | PARSER_IS_FUNC_EXPRESSION);\n      break;\n    }\n    case LEXER_LEFT_BRACE:\n    {\n#if JERRY_ESNEXT\n      if (context_p->next_scanner_info_p->source_p == context_p->source_p\n          && context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER)\n      {\n        if (parser_is_assignment_expr (context_p))\n        {\n          uint32_t flags = PARSER_PATTERN_NO_OPTS;\n\n          if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)\n          {\n            flags |= PARSER_PATTERN_HAS_REST_ELEMENT;\n          }\n\n          parser_parse_object_initializer (context_p, flags);\n          return parser_abort_parsing_after_assignment_expression (context_p);\n        }\n\n        scanner_release_next (context_p, sizeof (scanner_location_info_t));\n      }\n#endif /* JERRY_ESNEXT */\n\n      parser_parse_object_literal (context_p);\n      break;\n    }\n    case LEXER_LEFT_SQUARE:\n    {\n#if JERRY_ESNEXT\n      if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n      {\n        if (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER)\n        {\n          if (parser_is_assignment_expr (context_p))\n          {\n            parser_parse_array_initializer (context_p, PARSER_PATTERN_NO_OPTS);\n            return parser_abort_parsing_after_assignment_expression (context_p);\n          }\n\n          scanner_release_next (context_p, sizeof (scanner_location_info_t));\n        }\n        else\n        {\n          JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS\n                        && context_p->next_scanner_info_p->u8_arg == SCANNER_LITERAL_NO_DESTRUCTURING);\n\n          scanner_release_next (context_p, sizeof (scanner_info_t));\n        }\n      }\n#endif /* JERRY_ESNEXT */\n\n      parser_parse_array_literal (context_p);\n      break;\n    }\n    case LEXER_DIVIDE:\n    case LEXER_ASSIGN_DIVIDE:\n    {\n      lexer_construct_regexp_object (context_p, false);\n      uint16_t literal_index = (uint16_t) (context_p->literal_count - 1);\n\n      if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)\n      {\n        context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;\n        context_p->last_cbc.value = literal_index;\n      }\n      else if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)\n      {\n        context_p->last_cbc_opcode = CBC_PUSH_THREE_LITERALS;\n        context_p->last_cbc.third_literal_index = literal_index;\n      }\n      else\n      {\n        parser_emit_cbc_literal (context_p, CBC_PUSH_LITERAL, literal_index);\n      }\n\n      context_p->last_cbc.literal_type = LEXER_REGEXP_LITERAL;\n      context_p->last_cbc.literal_keyword_type = LEXER_EOS;\n      break;\n    }\n    case LEXER_KEYW_THIS:\n    {\n#if JERRY_ESNEXT\n      if (context_p->status_flags & PARSER_ALLOW_SUPER_CALL)\n      {\n        parser_emit_cbc_ext (context_p, CBC_EXT_RESOLVE_LEXICAL_THIS);\n      }\n      else\n      {\n#endif /* JERRY_ESNEXT */\n        parser_emit_cbc (context_p, CBC_PUSH_THIS);\n#if JERRY_ESNEXT\n      }\n#endif /* JERRY_ESNEXT */\n      break;\n    }\n    case LEXER_LIT_TRUE:\n    {\n      parser_emit_cbc (context_p, CBC_PUSH_TRUE);\n      break;\n    }\n    case LEXER_LIT_FALSE:\n    {\n      parser_emit_cbc (context_p, CBC_PUSH_FALSE);\n      break;\n    }\n    case LEXER_LIT_NULL:\n    {\n      parser_emit_cbc (context_p, CBC_PUSH_NULL);\n      break;\n    }\n#if JERRY_ESNEXT\n    case LEXER_KEYW_CLASS:\n    {\n      parser_parse_class (context_p, false);\n      return false;\n    }\n    case LEXER_KEYW_SUPER:\n    {\n      if (context_p->status_flags & PARSER_ALLOW_SUPER)\n      {\n        if (lexer_check_next_characters (context_p, LIT_CHAR_DOT, LIT_CHAR_LEFT_SQUARE))\n        {\n          parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SUPER);\n          break;\n        }\n\n        if (lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN)\n            && (context_p->status_flags & PARSER_ALLOW_SUPER_CALL))\n        {\n          parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SUPER_CONSTRUCTOR);\n          break;\n        }\n      }\n\n      parser_raise_error (context_p, PARSER_ERR_UNEXPECTED_SUPER_KEYWORD);\n    }\n    case LEXER_LEFT_PAREN:\n    {\n      JERRY_ASSERT (context_p->next_scanner_info_p->source_p == context_p->source_p\n                    && context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);\n\n      parser_check_assignment_expr (context_p);\n\n#if JERRY_FUNCTION_TO_STRING\n      context_p->function_start_p = context_p->source_p - 1;\n#endif /* JERRY_FUNCTION_TO_STRING */\n\n      uint32_t arrow_status_flags = (PARSER_IS_FUNCTION\n                                     | PARSER_IS_ARROW_FUNCTION\n                                     | (context_p->status_flags & PARSER_INSIDE_CLASS_FIELD));\n      parser_parse_function_expression (context_p, arrow_status_flags);\n      return parser_abort_parsing_after_assignment_expression (context_p);\n    }\n    case LEXER_KEYW_YIELD:\n    {\n      JERRY_ASSERT ((context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)\n                    && !(context_p->status_flags & PARSER_DISALLOW_AWAIT_YIELD));\n\n      if (context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)\n      {\n        parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);\n      }\n\n      parser_check_assignment_expr (context_p);\n      lexer_next_token (context_p);\n\n      cbc_ext_opcode_t opcode = ((context_p->status_flags & PARSER_IS_ASYNC_FUNCTION) ? CBC_EXT_ASYNC_YIELD\n                                                                                      : CBC_EXT_YIELD);\n      if (!lexer_check_yield_no_arg (context_p))\n      {\n        if (context_p->token.type == LEXER_MULTIPLY)\n        {\n          lexer_next_token (context_p);\n          opcode = ((context_p->status_flags & PARSER_IS_ASYNC_FUNCTION) ? CBC_EXT_ASYNC_YIELD_ITERATOR\n                                                                         : CBC_EXT_YIELD_ITERATOR);\n        }\n\n        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);\n      }\n      else\n      {\n        parser_emit_cbc (context_p, CBC_PUSH_UNDEFINED);\n      }\n\n      parser_emit_cbc_ext (context_p, opcode);\n\n      return (context_p->token.type != LEXER_RIGHT_PAREN\n              && context_p->token.type != LEXER_COMMA);\n    }\n#endif /* JERRY_ESNEXT */\n#if JERRY_MODULE_SYSTEM\n    case LEXER_KEYW_IMPORT:\n    {\n      lexer_next_token (context_p);\n\n      if (context_p->token.type == LEXER_DOT)\n      {\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_LITERAL\n            || context_p->token.lit_location.type != LEXER_IDENT_LITERAL\n            || context_p->token.keyword_type != LEXER_KEYW_META\n            || (context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE))\n        {\n          parser_raise_error (context_p, PARSER_ERR_META_EXPECTED);\n        }\n\n        if (!(context_p->global_status_flags & ECMA_PARSE_MODULE))\n        {\n          parser_raise_error (context_p, PARSER_ERR_IMPORT_META_REQUIRE_MODULE);\n        }\n\n        JERRY_ASSERT (context_p->global_status_flags & ECMA_PARSE_INTERNAL_HAS_IMPORT_META);\n\n        parser_emit_cbc_ext (context_p, CBC_EXT_MODULE_IMPORT_META);\n        break;\n      }\n\n      if (context_p->token.type != LEXER_LEFT_PAREN)\n      {\n        parser_raise_error (context_p, PARSER_ERR_LEFT_PAREN_EXPECTED);\n      }\n\n      if (new_was_seen)\n      {\n        parser_raise_error (context_p, PARSER_ERR_IMPORT_AFTER_NEW);\n      }\n\n      lexer_next_token (context_p);\n      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);\n\n      if (context_p->token.type != LEXER_RIGHT_PAREN)\n      {\n        parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);\n      }\n\n      parser_emit_cbc_ext (context_p, CBC_EXT_MODULE_IMPORT);\n      break;\n    }\n#endif /* JERRY_MODULE_SYSTEM */\n    default:\n    {\n      bool is_left_hand_side = (*grouping_level_p == PARSE_EXPR_LEFT_HAND_SIDE);\n      parser_raise_error (context_p, (is_left_hand_side ? PARSER_ERR_LEFT_HAND_SIDE_EXP_EXPECTED\n                                                        : PARSER_ERR_UNEXPECTED_END));\n      break;\n    }\n  }\n  lexer_next_token (context_p);\n  return false;\n}",
        "begin_line": 1893,
        "end_line": 2378,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_process_binary_opcodes#3093",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_process_binary_opcodes (parser_context_t *context_p, /**< context */                                uint8_t min_prec_treshold) /**< minimal precedence of tokens */",
        "snippet": "static void\nparser_process_binary_opcodes (parser_context_t *context_p, /**< context */\n                               uint8_t min_prec_treshold) /**< minimal precedence of tokens */\n{\n  while (true)\n  {\n    uint8_t token = context_p->stack_top_uint8;\n    uint16_t opcode;\n\n    /* For left-to-right operators (all binary operators except assignment\n     * and logical operators), the byte code is flushed if the precedence\n     * of the next operator is less or equal than the current operator. For\n     * assignment and logical operators, we add 1 to the min precendence to\n     * force right-to-left evaluation order. */\n\n    if (!LEXER_IS_BINARY_OP_TOKEN (token)\n        || parser_binary_precedence_table[token - LEXER_FIRST_BINARY_OP] < min_prec_treshold)\n    {\n      return;\n    }\n\n    parser_push_result (context_p);\n    parser_stack_pop_uint8 (context_p);\n\n    if (token == LEXER_ASSIGN)\n    {\n      uint16_t index = PARSER_INVALID_LITERAL_INDEX;\n      opcode = context_p->stack_top_uint8;\n\n#if JERRY_ESNEXT\n      if (JERRY_UNLIKELY (opcode == CBC_EXT_OPCODE))\n      {\n        parser_stack_pop_uint8 (context_p);\n        JERRY_ASSERT (context_p->stack_top_uint8 == CBC_EXT_ASSIGN_SUPER);\n        opcode = PARSER_TO_EXT_OPCODE (context_p->stack_top_uint8);\n        parser_stack_pop_uint8 (context_p);\n      }\n      else\n#endif /* JERRY_ESNEXT */\n      {\n        parser_stack_pop_uint8 (context_p);\n\n        if (cbc_flags[opcode] & CBC_HAS_LITERAL_ARG)\n        {\n          JERRY_ASSERT (opcode == CBC_ASSIGN_SET_IDENT\n                        || opcode == CBC_ASSIGN_PROP_LITERAL\n                        || opcode == CBC_ASSIGN_PROP_THIS_LITERAL\n                        || opcode == CBC_ASSIGN_LET_CONST\n                        || opcode == CBC_INIT_ARG_OR_CATCH\n                        || opcode == CBC_INIT_LET\n                        || opcode == CBC_INIT_CONST);\n\n          index = parser_stack_pop_uint16 (context_p);\n        }\n      }\n\n#if JERRY_ESNEXT\n      bool group_expr_assingment = false;\n\n      if (JERRY_UNLIKELY (context_p->stack_top_uint8 == LEXER_ASSIGN_GROUP_EXPR))\n      {\n        group_expr_assingment = true;\n        parser_stack_pop_uint8 (context_p);\n      }\n\n      if (JERRY_UNLIKELY (context_p->stack_top_uint8 == LEXER_ASSIGN_CONST))\n      {\n        parser_stack_pop_uint8 (context_p);\n        parser_emit_cbc_ext (context_p, CBC_EXT_THROW_ASSIGN_CONST_ERROR);\n      }\n#endif /* JERRY_ESNEXT */\n\n      if (index != PARSER_INVALID_LITERAL_INDEX)\n      {\n#if JERRY_ESNEXT\n        if (!group_expr_assingment)\n        {\n          uint16_t function_literal_index = parser_check_anonymous_function_declaration (context_p);\n\n          if (function_literal_index == PARSER_ANONYMOUS_CLASS)\n          {\n            uint16_t name_index = scanner_save_literal (context_p, index);\n            parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_CLASS_NAME, name_index);\n          }\n          else if (function_literal_index < PARSER_NAMED_FUNCTION)\n          {\n            parser_set_function_name (context_p, function_literal_index, (uint16_t) index, 0);\n          }\n        }\n#endif /* JERRY_ESNEXT */\n\n        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL\n            && opcode == CBC_ASSIGN_SET_IDENT)\n        {\n          JERRY_ASSERT (CBC_ARGS_EQ (CBC_ASSIGN_LITERAL_SET_IDENT,\n                                     CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2));\n\n          context_p->last_cbc.value = index;\n          context_p->last_cbc_opcode = CBC_ASSIGN_LITERAL_SET_IDENT;\n          continue;\n        }\n\n        parser_emit_cbc_literal (context_p, (uint16_t) opcode, index);\n\n        if (opcode == CBC_ASSIGN_PROP_THIS_LITERAL\n            && (context_p->stack_depth >= context_p->stack_limit))\n        {\n          /* Stack limit is increased for VM_OC_ASSIGN_PROP_THIS. Needed by vm.c. */\n          JERRY_ASSERT (context_p->stack_depth == context_p->stack_limit);\n\n          context_p->stack_limit++;\n\n          if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)\n          {\n            parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);\n          }\n        }\n        continue;\n      }\n    }\n    else if (LEXER_IS_BINARY_LVALUE_OP_TOKEN (token))\n    {\n      parser_stack_push_uint8 (context_p, CBC_ASSIGN);\n      parser_stack_push_uint8 (context_p, LEXER_ASSIGN);\n      parser_stack_push_uint8 (context_p, lexer_convert_binary_lvalue_token_to_binary (token));\n      continue;\n    }\n    else if (token == LEXER_LOGICAL_OR || token == LEXER_LOGICAL_AND)\n    {\n      parser_branch_t branch;\n      parser_stack_pop (context_p, &branch, sizeof (parser_branch_t));\n      parser_set_branch_to_current_position (context_p, &branch);\n      continue;\n    }\n#if JERRY_ESNEXT\n    else if (token == LEXER_NULLISH_COALESCING)\n    {\n      parser_branch_t branch;\n      parser_stack_pop (context_p, &branch, sizeof (parser_branch_t));\n      parser_set_branch_to_current_position (context_p, &branch);\n      continue;\n    }\n#endif /* JERRY_ESNEXT */\n    else\n    {\n      opcode = LEXER_BINARY_OP_TOKEN_TO_OPCODE (token);\n\n      if (PARSER_IS_PUSH_NUMBER (context_p->last_cbc_opcode))\n      {\n        lexer_convert_push_number_to_push_literal (context_p);\n      }\n\n      if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)\n      {\n        JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, opcode + CBC_BINARY_WITH_LITERAL));\n        context_p->last_cbc_opcode = (uint16_t) (opcode + CBC_BINARY_WITH_LITERAL);\n        continue;\n      }\n      else if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)\n      {\n        JERRY_ASSERT (CBC_ARGS_EQ (opcode + CBC_BINARY_WITH_TWO_LITERALS,\n                                   CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2));\n        context_p->last_cbc_opcode = (uint16_t) (opcode + CBC_BINARY_WITH_TWO_LITERALS);\n        continue;\n      }\n    }\n    parser_emit_cbc (context_p, opcode);\n  }\n}",
        "begin_line": 3093,
        "end_line": 3261,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_process_unary_expression#2384",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_process_unary_expression (parser_context_t *context_p, /**< context */                                  size_t grouping_level) /**< grouping level */",
        "snippet": "static void\nparser_process_unary_expression (parser_context_t *context_p, /**< context */\n                                 size_t grouping_level) /**< grouping level */\n{\n  /* Parse postfix part of a primary expression. */\n  while (true)\n  {\n    /* Since break would only break the switch, we use\n     * continue to continue this loop. Without continue,\n     * the code abandons the loop. */\n    switch (context_p->token.type)\n    {\n      case LEXER_DOT:\n      {\n        parser_push_result (context_p);\n\n        lexer_expect_identifier (context_p, LEXER_STRING_LITERAL);\n        JERRY_ASSERT (context_p->token.type == LEXER_LITERAL\n                      && context_p->lit_object.literal_p->type == LEXER_STRING_LITERAL);\n        context_p->token.lit_location.type = LEXER_STRING_LITERAL;\n\n        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)\n        {\n          JERRY_ASSERT (CBC_ARGS_EQ (CBC_PUSH_PROP_LITERAL_LITERAL,\n                                     CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2));\n          context_p->last_cbc_opcode = CBC_PUSH_PROP_LITERAL_LITERAL;\n          context_p->last_cbc.value = context_p->lit_object.index;\n        }\n        else if (context_p->last_cbc_opcode == CBC_PUSH_THIS)\n        {\n          context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n          parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_PROP_THIS_LITERAL);\n        }\n#if JERRY_ESNEXT\n        else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER))\n        {\n          context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL);\n          context_p->last_cbc.literal_index = context_p->lit_object.index;\n        }\n#endif /* JERRY_ESNEXT */\n        else\n        {\n          parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_PROP_LITERAL);\n        }\n        lexer_next_token (context_p);\n        continue;\n      }\n\n      case LEXER_LEFT_SQUARE:\n      {\n        parser_push_result (context_p);\n\n#if JERRY_ESNEXT\n        uint16_t last_cbc_opcode = context_p->last_cbc_opcode;\n\n        if (last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER))\n        {\n          context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n        }\n#endif /* JERRY_ESNEXT */\n\n        lexer_next_token (context_p);\n        parser_parse_expression (context_p, PARSE_EXPR);\n        if (context_p->token.type != LEXER_RIGHT_SQUARE)\n        {\n          parser_raise_error (context_p, PARSER_ERR_RIGHT_SQUARE_EXPECTED);\n        }\n        lexer_next_token (context_p);\n\n#if JERRY_ESNEXT\n        if (last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER))\n        {\n          parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SUPER_PROP);\n          continue;\n        }\n#endif /* JERRY_ESNEXT */\n\n        if (PARSER_IS_MUTABLE_PUSH_LITERAL (context_p->last_cbc_opcode))\n        {\n          context_p->last_cbc_opcode = PARSER_PUSH_LITERAL_TO_PUSH_PROP_LITERAL (context_p->last_cbc_opcode);\n        }\n        else\n        {\n          parser_emit_cbc (context_p, CBC_PUSH_PROP);\n        }\n        continue;\n      }\n\n#if JERRY_ESNEXT\n      case LEXER_TEMPLATE_LITERAL:\n#endif /* JERRY_ESNEXT */\n      case LEXER_LEFT_PAREN:\n      {\n        size_t call_arguments = 0;\n        uint16_t opcode = CBC_CALL;\n        bool is_eval = false;\n\n        parser_push_result (context_p);\n\n        if (context_p->stack_top_uint8 == LEXER_KEYW_NEW)\n        {\n#if JERRY_ESNEXT\n          if (context_p->token.type == LEXER_LEFT_PAREN)\n#endif /* JERRY_ESNEXT */\n          {\n            parser_stack_pop_uint8 (context_p);\n            opcode = CBC_NEW;\n          }\n        }\n        else\n        {\n          if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL\n              && context_p->last_cbc.literal_keyword_type == LEXER_KEYW_EVAL\n              && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)\n          {\n            is_eval = true;\n          }\n\n          if (PARSER_IS_PUSH_PROP (context_p->last_cbc_opcode))\n          {\n            opcode = CBC_CALL_PROP;\n            context_p->last_cbc_opcode = PARSER_PUSH_PROP_TO_PUSH_PROP_REFERENCE (context_p->last_cbc_opcode);\n          }\n#if JERRY_ESNEXT\n          else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_CONSTRUCTOR))\n          {\n            opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_CALL);\n          }\n          else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL))\n          {\n            context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_LITERAL_REFERENCE);\n            opcode = CBC_CALL_PROP;\n          }\n          else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP))\n          {\n            context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_REFERENCE);\n            opcode = CBC_CALL_PROP;\n          }\n#endif /* JERRY_ESNEXT */\n          else if (JERRY_UNLIKELY (context_p->status_flags & PARSER_INSIDE_WITH)\n                   && PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)\n                   && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)\n          {\n            opcode = CBC_CALL_PROP;\n            parser_emit_ident_reference (context_p, CBC_PUSH_IDENT_REFERENCE);\n            parser_emit_cbc_ext (context_p, CBC_EXT_RESOLVE_BASE);\n          }\n        }\n\n#if JERRY_ESNEXT\n        bool has_spread_element = false;\n\n        if (context_p->token.type == LEXER_TEMPLATE_LITERAL)\n        {\n          call_arguments = parser_parse_tagged_template_literal (context_p);\n        }\n        else\n        {\n          lexer_next_token (context_p);\n\n          while (context_p->token.type != LEXER_RIGHT_PAREN)\n          {\n            if (++call_arguments > CBC_MAXIMUM_BYTE_VALUE)\n            {\n              parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);\n            }\n\n            if (context_p->token.type == LEXER_THREE_DOTS)\n            {\n              has_spread_element = true;\n              call_arguments++;\n              parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SPREAD_ELEMENT);\n              lexer_next_token (context_p);\n            }\n\n            parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);\n\n            if (context_p->token.type == LEXER_COMMA)\n            {\n              lexer_next_token (context_p);\n              continue;\n            }\n\n            if (context_p->token.type != LEXER_RIGHT_PAREN)\n            {\n              parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);\n            }\n\n            break;\n          }\n        }\n#else /* !JERRY_ESNEXT */\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_RIGHT_PAREN)\n        {\n          while (true)\n          {\n            if (++call_arguments > CBC_MAXIMUM_BYTE_VALUE)\n            {\n              parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);\n            }\n\n            parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);\n\n            if (context_p->token.type != LEXER_COMMA)\n            {\n              break;\n            }\n            lexer_next_token (context_p);\n          }\n\n          if (context_p->token.type != LEXER_RIGHT_PAREN)\n          {\n            parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);\n          }\n        }\n#endif /* JERRY_ESNEXT */\n\n        lexer_next_token (context_p);\n\n        if (is_eval)\n        {\n          context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;\n\n#if JERRY_ESNEXT\n          uint16_t eval_flags = PARSER_SAVE_STATUS_FLAGS (context_p->status_flags);\n          const uint32_t required_flags = PARSER_IS_FUNCTION | PARSER_LEXICAL_BLOCK_NEEDED;\n\n          if (context_p->status_flags & PARSER_FUNCTION_IS_PARSING_ARGS)\n          {\n            context_p->status_flags |= PARSER_LEXICAL_BLOCK_NEEDED;\n          }\n          else if (((context_p->status_flags & (required_flags | PARSER_IS_STRICT)) == required_flags)\n                   || ((context_p->global_status_flags & ECMA_PARSE_FUNCTION_CONTEXT)\n                       && !(context_p->status_flags & PARSER_IS_FUNCTION)))\n          {\n            eval_flags |= PARSER_GET_EVAL_FLAG (ECMA_PARSE_FUNCTION_CONTEXT);\n          }\n\n          if (eval_flags != 0)\n          {\n            parser_emit_cbc_ext_call (context_p, CBC_EXT_LOCAL_EVAL, eval_flags);\n          }\n          else\n          {\n#endif /* JERRY_ESNEXT */\n            parser_emit_cbc (context_p, CBC_EVAL);\n#if JERRY_ESNEXT\n          }\n#endif /* JERRY_ESNEXT */\n        }\n\n#if JERRY_ESNEXT\n        if (has_spread_element)\n        {\n          uint16_t spread_opcode;\n\n          if (opcode == CBC_CALL)\n          {\n            spread_opcode = CBC_EXT_SPREAD_CALL;\n          }\n          else if (opcode == CBC_CALL_PROP)\n          {\n            spread_opcode = CBC_EXT_SPREAD_CALL_PROP;\n          }\n          else if (opcode == CBC_NEW)\n          {\n            spread_opcode = CBC_EXT_SPREAD_NEW;\n          }\n          else\n          {\n            /* opcode is unchanged */\n            JERRY_ASSERT (opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_CALL));\n            spread_opcode = CBC_EXT_SPREAD_SUPER_CALL;\n          }\n\n          parser_emit_cbc_ext_call (context_p, spread_opcode, call_arguments);\n          continue;\n        }\n#endif /* JERRY_ESNEXT */\n\n        if (call_arguments <= 1)\n        {\n          if (opcode == CBC_CALL)\n          {\n            parser_emit_cbc (context_p, (uint16_t) (CBC_CALL0 + (call_arguments * 6)));\n            continue;\n          }\n          if (opcode == CBC_CALL_PROP)\n          {\n            parser_emit_cbc (context_p, (uint16_t) (CBC_CALL0_PROP + (call_arguments * 6)));\n            continue;\n          }\n          if (opcode == CBC_NEW)\n          {\n            parser_emit_cbc (context_p, (uint16_t) (CBC_NEW0 + call_arguments));\n            continue;\n          }\n        }\n        else if (call_arguments == 2)\n        {\n          if (opcode == CBC_CALL)\n          {\n            parser_emit_cbc (context_p, CBC_CALL2);\n            continue;\n          }\n          if (opcode == CBC_CALL_PROP)\n          {\n            parser_flush_cbc (context_p);\n            /* Manually adjusting stack usage. */\n            JERRY_ASSERT (context_p->stack_depth > 0);\n            context_p->stack_depth--;\n            parser_emit_cbc (context_p, CBC_CALL2_PROP);\n            continue;\n          }\n        }\n\n        parser_emit_cbc_call (context_p, opcode, call_arguments);\n        continue;\n      }\n\n      default:\n      {\n        if (context_p->stack_top_uint8 == LEXER_KEYW_NEW)\n        {\n          parser_push_result (context_p);\n          parser_emit_cbc (context_p, CBC_NEW0);\n          parser_stack_pop_uint8 (context_p);\n          continue;\n        }\n\n        if (!(context_p->token.flags & LEXER_WAS_NEWLINE)\n            && (context_p->token.type == LEXER_INCREASE || context_p->token.type == LEXER_DECREASE)\n            && grouping_level != PARSE_EXPR_LEFT_HAND_SIDE)\n        {\n          cbc_opcode_t opcode = (context_p->token.type == LEXER_INCREASE) ? CBC_POST_INCR : CBC_POST_DECR;\n          parser_push_result (context_p);\n          parser_emit_unary_lvalue_opcode (context_p, opcode);\n          lexer_next_token (context_p);\n        }\n        break;\n      }\n    }\n    break;\n  }\n\n#if JERRY_ESNEXT\n  uint8_t last_unary_token = LEXER_INCREASE;\n#endif /* JERRY_ESNEXT */\n\n  /* Generate byte code for the unary operators. */\n  while (true)\n  {\n    uint8_t token = context_p->stack_top_uint8;\n    if (!LEXER_IS_UNARY_OP_TOKEN (token))\n    {\n#if JERRY_ESNEXT\n      if (context_p->token.type == LEXER_EXPONENTIATION\n          && last_unary_token != LEXER_INCREASE\n          && last_unary_token != LEXER_DECREASE)\n      {\n        parser_raise_error (context_p, PARSER_ERR_INVALID_EXPONENTIATION);\n      }\n#endif /* JERRY_ESNEXT */\n      break;\n    }\n\n#if JERRY_ESNEXT\n    last_unary_token = token;\n#endif /* JERRY_ESNEXT */\n\n    parser_push_result (context_p);\n    parser_stack_pop_uint8 (context_p);\n\n    if (LEXER_IS_UNARY_LVALUE_OP_TOKEN (token))\n    {\n      if (token == LEXER_KEYW_DELETE)\n      {\n        token = CBC_DELETE_PUSH_RESULT;\n      }\n      else\n      {\n        token = (uint8_t) (LEXER_UNARY_LVALUE_OP_TOKEN_TO_OPCODE (token));\n      }\n      parser_emit_unary_lvalue_opcode (context_p, (cbc_opcode_t) token);\n    }\n#if JERRY_ESNEXT\n    else if (JERRY_UNLIKELY (token == LEXER_KEYW_AWAIT))\n    {\n      cbc_ext_opcode_t opcode = ((context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION) ? CBC_EXT_GENERATOR_AWAIT\n                                                                                          : CBC_EXT_AWAIT);\n      parser_emit_cbc_ext (context_p, opcode);\n    }\n#endif /* JERRY_ESNEXT */\n    else\n    {\n      token = (uint8_t) (LEXER_UNARY_OP_TOKEN_TO_OPCODE (token));\n\n      if (token == CBC_TYPEOF)\n      {\n        if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)\n            && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)\n        {\n          parser_emit_ident_reference (context_p, CBC_TYPEOF_IDENT);\n        }\n        else\n        {\n          parser_emit_cbc (context_p, token);\n        }\n      }\n      else\n      {\n        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)\n        {\n          /* It is not worth to combine with push multiple literals\n           * since the byte code size will not decrease. */\n          JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, token + 1));\n          context_p->last_cbc_opcode = (uint16_t) (token + 1);\n        }\n        else\n        {\n          parser_emit_cbc (context_p, token);\n        }\n      }\n    }\n  }\n}",
        "begin_line": 2384,
        "end_line": 2811,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-expr.parser_push_result#121",
        "src_path": "jerry-core/parser/js/js-parser-expr.c",
        "class_name": "jerry-core.parser.js.js-parser-expr",
        "signature": "jerry-core.parser.js.js-parser-expr.parser_push_result (parser_context_t *context_p) /**< context */",
        "snippet": "static inline void\nparser_push_result (parser_context_t *context_p) /**< context */\n{\n  if (CBC_NO_RESULT_OPERATION (context_p->last_cbc_opcode))\n  {\n    JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, context_p->last_cbc_opcode + 1));\n\n    if ((context_p->last_cbc_opcode == CBC_POST_INCR\n         || context_p->last_cbc_opcode == CBC_POST_DECR)\n        && context_p->stack_depth >= context_p->stack_limit)\n    {\n      /* Stack limit is increased for CBC_POST_INCR_PUSH_RESULT\n       * and CBC_POST_DECR_PUSH_RESULT opcodes. Needed by vm.c. */\n      JERRY_ASSERT (context_p->stack_depth == context_p->stack_limit);\n\n      context_p->stack_limit++;\n\n      if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)\n      {\n        parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);\n      }\n    }\n\n    context_p->last_cbc_opcode++;\n    parser_flush_cbc (context_p);\n  }\n}",
        "begin_line": 121,
        "end_line": 147,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_cbc_stream_alloc_page#166",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_cbc_stream_alloc_page (parser_context_t *context_p, /**< context */                               parser_mem_data_t *data_p) /**< memory manager */",
        "snippet": "void\nparser_cbc_stream_alloc_page (parser_context_t *context_p, /**< context */\n                              parser_mem_data_t *data_p) /**< memory manager */\n{\n  size_t size = sizeof (parser_mem_page_t *) + PARSER_CBC_STREAM_PAGE_SIZE;\n  parser_mem_page_t *page_p = (parser_mem_page_t *) parser_malloc (context_p, size);\n\n  page_p->next_p = NULL;\n  data_p->last_position = 0;\n\n  if (data_p->last_p != NULL)\n  {\n    data_p->last_p->next_p = page_p;\n  }\n  else\n  {\n    data_p->first_p = page_p;\n  }\n  data_p->last_p = page_p;\n}",
        "begin_line": 166,
        "end_line": 185,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_cbc_stream_free#156",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_cbc_stream_free (parser_mem_data_t *data_p) /**< memory manager */",
        "snippet": "void\nparser_cbc_stream_free (parser_mem_data_t *data_p) /**< memory manager */\n{\n  parser_data_free (data_p,\n                    sizeof (parser_mem_page_t *) + PARSER_CBC_STREAM_PAGE_SIZE);\n}",
        "begin_line": 156,
        "end_line": 161,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_cbc_stream_init#147",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_cbc_stream_init (parser_mem_data_t *data_p) /**< memory manager */",
        "snippet": "void\nparser_cbc_stream_init (parser_mem_data_t *data_p) /**< memory manager */\n{\n  parser_data_init (data_p, PARSER_CBC_STREAM_PAGE_SIZE);\n}",
        "begin_line": 147,
        "end_line": 151,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_data_free#125",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_data_free (parser_mem_data_t *data_p, /**< memory manager */                   uint32_t page_size) /**< size of each page */",
        "snippet": "static void\nparser_data_free (parser_mem_data_t *data_p, /**< memory manager */\n                  uint32_t page_size) /**< size of each page */\n{\n  parser_mem_page_t *page_p = data_p->first_p;\n\n  while (page_p != NULL)\n  {\n    parser_mem_page_t *next_p = page_p->next_p;\n\n    parser_free (page_p, page_size);\n    page_p = next_p;\n  }\n}",
        "begin_line": 125,
        "end_line": 138,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_data_init#113",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_data_init (parser_mem_data_t *data_p, /**< memory manager */                   uint32_t page_size) /**< size of each page */",
        "snippet": "static void\nparser_data_init (parser_mem_data_t *data_p, /**< memory manager */\n                  uint32_t page_size) /**< size of each page */\n{\n  data_p->first_p = NULL;\n  data_p->last_p = NULL;\n  data_p->last_position = page_size;\n}",
        "begin_line": 113,
        "end_line": 120,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_free#55",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_free (void *ptr, /**< pointer to free */              size_t size) /**< size of the memory block */",
        "snippet": "extern inline void JERRY_ATTR_ALWAYS_INLINE\nparser_free (void *ptr, /**< pointer to free */\n             size_t size) /**< size of the memory block */\n{\n  jmem_heap_free_block (ptr, size);\n}",
        "begin_line": 55,
        "end_line": 60,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_free_allocated_buffer#95",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_free_allocated_buffer (parser_context_t *context_p) /**< context */",
        "snippet": "extern inline void JERRY_ATTR_ALWAYS_INLINE\nparser_free_allocated_buffer (parser_context_t *context_p) /**< context */\n{\n  if (context_p->u.allocated_buffer_p != NULL)\n  {\n    parser_free_local (context_p->u.allocated_buffer_p,\n                       context_p->allocated_buffer_size);\n    context_p->u.allocated_buffer_p = NULL;\n  }\n}",
        "begin_line": 95,
        "end_line": 104,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_list_append#231",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_list_append (parser_context_t *context_p, /**< context */                     parser_list_t *list_p) /**< parser list */",
        "snippet": "void *\nparser_list_append (parser_context_t *context_p, /**< context */\n                    parser_list_t *list_p) /**< parser list */\n{\n  parser_mem_page_t *page_p = list_p->data.last_p;\n  void *result;\n\n  if (list_p->data.last_position + list_p->item_size > list_p->page_size)\n  {\n    size_t size = sizeof (parser_mem_page_t *) + list_p->page_size;\n\n    page_p = (parser_mem_page_t *) parser_malloc (context_p, size);\n\n    page_p->next_p = NULL;\n    list_p->data.last_position = 0;\n\n    if (list_p->data.last_p != NULL)\n    {\n      list_p->data.last_p->next_p = page_p;\n    }\n    else\n    {\n      list_p->data.first_p = page_p;\n    }\n    list_p->data.last_p = page_p;\n  }\n\n  result = page_p->bytes + list_p->data.last_position;\n  list_p->data.last_position += list_p->item_size;\n  return result;\n}",
        "begin_line": 231,
        "end_line": 261,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_list_free#210",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_list_free (parser_list_t *list_p) /**< parser list */",
        "snippet": "void\nparser_list_free (parser_list_t *list_p) /**< parser list */\n{\n  parser_data_free (&list_p->data,\n                    (uint32_t) (sizeof (parser_mem_page_t *) + list_p->page_size));\n}",
        "begin_line": 210,
        "end_line": 215,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_list_get#268",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_list_get (parser_list_t *list_p, /**< parser list */                  size_t index) /**< item index */",
        "snippet": "void *\nparser_list_get (parser_list_t *list_p, /**< parser list */\n                 size_t index) /**< item index */\n{\n  size_t item_count = list_p->item_count;\n  parser_mem_page_t *page_p = list_p->data.first_p;\n\n  while (index >= item_count)\n  {\n    JERRY_ASSERT (page_p != NULL);\n    page_p = page_p->next_p;\n    index -= item_count;\n  }\n\n  JERRY_ASSERT (page_p != NULL);\n  JERRY_ASSERT (page_p != list_p->data.last_p\n                || (index * list_p->item_size < list_p->data.last_position));\n  return page_p->bytes + (index * list_p->item_size);\n}",
        "begin_line": 268,
        "end_line": 286,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_list_init#194",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_list_init (parser_list_t *list_p, /**< parser list */                   uint32_t item_size, /**< size for each page */                   uint32_t item_count) /**< number of items on each page */",
        "snippet": "void\nparser_list_init (parser_list_t *list_p, /**< parser list */\n                  uint32_t item_size, /**< size for each page */\n                  uint32_t item_count) /**< number of items on each page */\n{\n  /* Align to pointer size. */\n  item_size = (uint32_t) (((item_size) + sizeof (void *) - 1) & ~(sizeof (void *) - 1));\n  parser_data_init (&list_p->data, item_size * item_count);\n  list_p->page_size = item_size * item_count;\n  list_p->item_size = item_size;\n  list_p->item_count = item_count;\n}",
        "begin_line": 194,
        "end_line": 205,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_list_iterator_init#291",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_list_iterator_init (parser_list_t *list_p, /**< parser list */                            parser_list_iterator_t *iterator_p) /**< iterator */",
        "snippet": "void\nparser_list_iterator_init (parser_list_t *list_p, /**< parser list */\n                           parser_list_iterator_t *iterator_p) /**< iterator */\n{\n  iterator_p->list_p = list_p;\n  iterator_p->current_p = list_p->data.first_p;\n  iterator_p->current_position = 0;\n}",
        "begin_line": 291,
        "end_line": 298,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_list_iterator_next#305",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_list_iterator_next (parser_list_iterator_t *iterator_p) /**< iterator */",
        "snippet": "void *\nparser_list_iterator_next (parser_list_iterator_t *iterator_p) /**< iterator */\n{\n  void *result;\n\n  if (iterator_p->current_p == NULL)\n  {\n    return NULL;\n  }\n\n  result = iterator_p->current_p->bytes + iterator_p->current_position;\n  iterator_p->current_position += iterator_p->list_p->item_size;\n\n  if (iterator_p->current_p->next_p == NULL)\n  {\n    if (iterator_p->current_position >= iterator_p->list_p->data.last_position)\n    {\n      iterator_p->current_p = NULL;\n      iterator_p->current_position = 0;\n    }\n  }\n  else if (iterator_p->current_position >= iterator_p->list_p->page_size)\n  {\n    iterator_p->current_p = iterator_p->current_p->next_p;\n    iterator_p->current_position = 0;\n  }\n  return result;\n}",
        "begin_line": 305,
        "end_line": 332,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_list_reset#220",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_list_reset (parser_list_t *list_p) /**< parser list */",
        "snippet": "void\nparser_list_reset (parser_list_t *list_p) /**< parser list */\n{\n  parser_data_init (&list_p->data, list_p->page_size);\n}",
        "begin_line": 220,
        "end_line": 224,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_malloc#36",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_malloc (parser_context_t *context_p, /**< context */                size_t size) /**< size of the memory block */",
        "snippet": "void *\nparser_malloc (parser_context_t *context_p, /**< context */\n               size_t size) /**< size of the memory block */\n{\n  void *result;\n\n  JERRY_ASSERT (size > 0);\n  result = jmem_heap_alloc_block_null_on_error (size);\n\n  if (result == NULL)\n  {\n    parser_raise_error (context_p, PARSER_ERR_OUT_OF_MEMORY);\n  }\n  return result;\n}",
        "begin_line": 36,
        "end_line": 50,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_stack_free#353",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_stack_free (parser_context_t *context_p) /**< context */",
        "snippet": "void\nparser_stack_free (parser_context_t *context_p) /**< context */\n{\n  parser_data_free (&context_p->stack,\n                    sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE);\n\n  if (context_p->free_page_p != NULL)\n  {\n    parser_free (context_p->free_page_p,\n                 sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE);\n  }\n}",
        "begin_line": 353,
        "end_line": 364,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_stack_init#343",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_stack_init (parser_context_t *context_p) /**< context */",
        "snippet": "void\nparser_stack_init (parser_context_t *context_p) /**< context */\n{\n  parser_data_init (&context_p->stack, PARSER_STACK_PAGE_SIZE);\n  context_p->free_page_p = NULL;\n}",
        "begin_line": 343,
        "end_line": 348,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_stack_iterator_init#647",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_stack_iterator_init (parser_context_t *context_p, /**< context */                             parser_stack_iterator_t *iterator) /**< iterator */",
        "snippet": "extern inline void\nparser_stack_iterator_init (parser_context_t *context_p, /**< context */\n                            parser_stack_iterator_t *iterator) /**< iterator */\n{\n  iterator->current_p = context_p->stack.first_p;\n  iterator->current_position = context_p->stack.last_position;\n}",
        "begin_line": 647,
        "end_line": 653,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_stack_iterator_read#690",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_stack_iterator_read (parser_stack_iterator_t *iterator, /**< iterator */                             void *data_p, /**< destination buffer */                             size_t length) /**< length of the data */",
        "snippet": "void\nparser_stack_iterator_read (parser_stack_iterator_t *iterator, /**< iterator */\n                            void *data_p, /**< destination buffer */\n                            size_t length) /**< length of the data */\n{\n  uint8_t *bytes_p = (uint8_t *) data_p;\n\n  JERRY_ASSERT (length < PARSER_STACK_PAGE_SIZE && length > 0);\n\n  if (length <= iterator->current_position)\n  {\n    memcpy (bytes_p,\n            iterator->current_p->bytes + iterator->current_position - length,\n            length);\n  }\n  else\n  {\n    JERRY_ASSERT (iterator->current_p->next_p != NULL);\n\n    length -= iterator->current_position;\n    memcpy (bytes_p + length,\n            iterator->current_p->bytes,\n            iterator->current_position);\n    memcpy (bytes_p,\n            iterator->current_p->next_p->bytes + PARSER_STACK_PAGE_SIZE - length,\n            length);\n  }\n}",
        "begin_line": 690,
        "end_line": 717,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_stack_iterator_skip#670",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_stack_iterator_skip (parser_stack_iterator_t *iterator, /**< iterator */                             size_t length) /**< number of skipped bytes */",
        "snippet": "void\nparser_stack_iterator_skip (parser_stack_iterator_t *iterator, /**< iterator */\n                            size_t length) /**< number of skipped bytes */\n{\n  JERRY_ASSERT (length < PARSER_STACK_PAGE_SIZE && length > 0);\n\n  if (length < iterator->current_position)\n  {\n    iterator->current_position -= length;\n  }\n  else\n  {\n    iterator->current_position = PARSER_STACK_PAGE_SIZE - (length - iterator->current_position);\n    iterator->current_p = iterator->current_p->next_p;\n  }\n}",
        "begin_line": 670,
        "end_line": 685,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_stack_pop#591",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_stack_pop (parser_context_t *context_p, /**< context */                   void *data_p, /**< destination buffer, can be NULL */                   uint32_t length) /**< length of the data */",
        "snippet": "void\nparser_stack_pop (parser_context_t *context_p, /**< context */\n                  void *data_p, /**< destination buffer, can be NULL */\n                  uint32_t length) /**< length of the data */\n{\n  uint8_t *bytes_p = (uint8_t *) data_p;\n  parser_mem_page_t *page_p = context_p->stack.first_p;\n\n  JERRY_ASSERT (length < PARSER_STACK_PAGE_SIZE && length > 0);\n\n  if (context_p->stack.last_position > length)\n  {\n    context_p->stack.last_position -= length;\n    context_p->stack_top_uint8 = page_p->bytes[context_p->stack.last_position - 1];\n\n    if (bytes_p != NULL)\n    {\n      memcpy (bytes_p, context_p->stack.first_p->bytes + context_p->stack.last_position, length);\n    }\n    return;\n  }\n\n  JERRY_ASSERT (page_p->next_p != NULL);\n\n  length -= context_p->stack.last_position;\n\n  if (bytes_p != NULL)\n  {\n    memcpy (bytes_p + length, page_p->bytes, context_p->stack.last_position);\n  }\n\n  context_p->stack.first_p = page_p->next_p;\n  context_p->stack.last_position = PARSER_STACK_PAGE_SIZE - length;\n  context_p->stack_top_uint8 = page_p->next_p->bytes[context_p->stack.last_position - 1];\n\n  if (bytes_p != NULL && length > 0)\n  {\n    memcpy (bytes_p, page_p->next_p->bytes + context_p->stack.last_position, length);\n  }\n\n  JERRY_ASSERT (context_p->stack.last_position > 0);\n\n  if (context_p->free_page_p == NULL)\n  {\n    context_p->free_page_p = page_p;\n  }\n  else\n  {\n    parser_free (page_p,\n                 sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE);\n  }\n}",
        "begin_line": 591,
        "end_line": 642,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_stack_pop_uint8#406",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_stack_pop_uint8 (parser_context_t *context_p) /**< context */",
        "snippet": "void\nparser_stack_pop_uint8 (parser_context_t *context_p) /**< context */\n{\n  parser_mem_page_t *page_p = context_p->stack.first_p;\n\n  JERRY_ASSERT (page_p != NULL\n                && context_p->stack_top_uint8 == page_p->bytes[context_p->stack.last_position - 1]);\n\n  context_p->stack.last_position--;\n\n  if (context_p->stack.last_position == 0)\n  {\n    context_p->stack.first_p = page_p->next_p;\n    context_p->stack.last_position = PARSER_STACK_PAGE_SIZE;\n\n    if (context_p->free_page_p == NULL)\n    {\n      context_p->free_page_p = page_p;\n    }\n    else\n    {\n      parser_free (page_p,\n                   sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE);\n    }\n\n    page_p = context_p->stack.first_p;\n\n    JERRY_ASSERT (page_p != NULL);\n  }\n\n  context_p->stack_top_uint8 = page_p->bytes[context_p->stack.last_position - 1];\n}",
        "begin_line": 406,
        "end_line": 437,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_stack_push#533",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_stack_push (parser_context_t *context_p, /**< context */                    const void *data_p, /**< data pushed onto the stack */                    uint32_t length) /**< length of the data */",
        "snippet": "void\nparser_stack_push (parser_context_t *context_p, /**< context */\n                   const void *data_p, /**< data pushed onto the stack */\n                   uint32_t length) /**< length of the data */\n{\n  uint32_t fragment_length = PARSER_STACK_PAGE_SIZE - context_p->stack.last_position;\n  const uint8_t *bytes_p = (const uint8_t *) data_p;\n  parser_mem_page_t *page_p;\n\n  JERRY_ASSERT (length < PARSER_STACK_PAGE_SIZE && length > 0);\n\n  context_p->stack_top_uint8 = bytes_p[length - 1];\n\n  if (fragment_length > 0)\n  {\n    /* Fill the remaining bytes. */\n    if (fragment_length > length)\n    {\n      fragment_length = length;\n    }\n\n    memcpy (context_p->stack.first_p->bytes + context_p->stack.last_position,\n            bytes_p,\n            fragment_length);\n\n    if (fragment_length == length)\n    {\n      context_p->stack.last_position += length;\n      return;\n    }\n\n    bytes_p += fragment_length;\n    length -= fragment_length;\n  }\n\n  if (context_p->free_page_p != NULL)\n  {\n    page_p = context_p->free_page_p;\n    context_p->free_page_p = NULL;\n  }\n  else\n  {\n    size_t size = sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE;\n\n    page_p = (parser_mem_page_t *) parser_malloc (context_p, size);\n  }\n\n  page_p->next_p = context_p->stack.first_p;\n\n  context_p->stack.first_p = page_p;\n\n  memcpy (page_p->bytes, bytes_p, length);\n  context_p->stack.last_position = length;\n}",
        "begin_line": 533,
        "end_line": 586,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-mem.parser_stack_push_uint8#369",
        "src_path": "jerry-core/parser/js/js-parser-mem.c",
        "class_name": "jerry-core.parser.js.js-parser-mem",
        "signature": "jerry-core.parser.js.js-parser-mem.parser_stack_push_uint8 (parser_context_t *context_p, /**< context */                          uint8_t uint8_value) /**< value pushed onto the stack */",
        "snippet": "void\nparser_stack_push_uint8 (parser_context_t *context_p, /**< context */\n                         uint8_t uint8_value) /**< value pushed onto the stack */\n{\n  parser_mem_page_t *page_p = context_p->stack.first_p;\n\n  /* This assert might trigger false positive valgrind errors, when\n   * parser_stack_push() pushes not fully initialized structures.\n   * More precisely when the last byte of the structure is uninitialized. */\n  JERRY_ASSERT (page_p == NULL\n                || context_p->stack_top_uint8 == page_p->bytes[context_p->stack.last_position - 1]);\n\n  if (context_p->stack.last_position >= PARSER_STACK_PAGE_SIZE)\n  {\n    if (context_p->free_page_p != NULL)\n    {\n      page_p = context_p->free_page_p;\n      context_p->free_page_p = NULL;\n    }\n    else\n    {\n      size_t size = sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE;\n      page_p = (parser_mem_page_t *) parser_malloc (context_p, size);\n    }\n\n    page_p->next_p = context_p->stack.first_p;\n    context_p->stack.last_position = 0;\n    context_p->stack.first_p = page_p;\n  }\n\n  page_p->bytes[context_p->stack.last_position++] = uint8_value;\n  context_p->stack_top_uint8 = uint8_value;\n}",
        "begin_line": 369,
        "end_line": 401,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-module.parser_module_append_export_name#83",
        "src_path": "jerry-core/parser/js/js-parser-module.c",
        "class_name": "jerry-core.parser.js.js-parser-module",
        "signature": "jerry-core.parser.js.js-parser-module.parser_module_append_export_name (parser_context_t *context_p) /**< parser context */",
        "snippet": "void\nparser_module_append_export_name (parser_context_t *context_p) /**< parser context */\n{\n  if (!(context_p->status_flags & PARSER_MODULE_STORE_IDENT))\n  {\n    return;\n  }\n\n  context_p->module_identifier_lit_p = context_p->lit_object.literal_p;\n  ecma_string_t *name_p  = parser_new_ecma_string_from_literal (context_p->lit_object.literal_p);\n\n  if (parser_module_check_duplicate_export (context_p, name_p))\n  {\n    ecma_deref_ecma_string (name_p);\n    parser_raise_error (context_p, PARSER_ERR_DUPLICATED_EXPORT_IDENTIFIER);\n  }\n\n  parser_module_add_names_to_node (context_p,\n                                   name_p,\n                                   name_p);\n  ecma_deref_ecma_string (name_p);\n}",
        "begin_line": 83,
        "end_line": 104,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-statm.parser_parse_for_statement_end#1658",
        "src_path": "jerry-core/parser/js/js-parser-statm.c",
        "class_name": "jerry-core.parser.js.js-parser-statm",
        "signature": "jerry-core.parser.js.js-parser-statm.parser_parse_for_statement_end (parser_context_t *context_p) /**< context */",
        "snippet": "static void JERRY_ATTR_NOINLINE\nparser_parse_for_statement_end (parser_context_t *context_p) /**< context */\n{\n  parser_for_statement_t for_statement;\n  parser_loop_statement_t loop;\n  lexer_token_t current_token;\n  scanner_location_t location;\n  cbc_opcode_t opcode;\n\n  JERRY_ASSERT (context_p->stack_top_uint8 == PARSER_STATEMENT_FOR);\n\n  parser_stack_iterator_t iterator;\n  parser_stack_iterator_init (context_p, &iterator);\n\n  parser_stack_iterator_skip (&iterator, 1);\n  parser_stack_iterator_read (&iterator, &loop, sizeof (parser_loop_statement_t));\n  parser_stack_iterator_skip (&iterator, sizeof (parser_loop_statement_t));\n  parser_stack_iterator_read (&iterator, &for_statement, sizeof (parser_for_statement_t));\n\n#if JERRY_ESNEXT\n  bool has_block_context = false;\n  uint8_t next_statement_type;\n\n  parser_stack_iterator_skip (&iterator, sizeof (parser_for_statement_t));\n  parser_stack_iterator_read (&iterator, &next_statement_type, 1);\n\n  if (next_statement_type == PARSER_STATEMENT_PRIVATE_CONTEXT)\n  {\n    has_block_context = true;\n  }\n#endif\n\n  scanner_get_location (&location, context_p);\n  current_token = context_p->token;\n\n  scanner_set_location (context_p, &for_statement.expression_location);\n  scanner_seek (context_p);\n  lexer_next_token (context_p);\n\n  parser_set_continues_to_current_position (context_p, loop.branch_list_p);\n\n#if JERRY_ESNEXT\n  if (has_block_context)\n  {\n    parser_emit_cbc_ext (context_p, CBC_EXT_CLONE_FULL_CONTEXT);\n  }\n#endif\n\n  if (context_p->token.type != LEXER_RIGHT_PAREN)\n  {\n    parser_parse_expression_statement (context_p, PARSE_EXPR);\n\n    if (context_p->token.type != LEXER_RIGHT_PAREN)\n    {\n      parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);\n    }\n  }\n\n  parser_set_branch_to_current_position (context_p, &for_statement.branch);\n\n  scanner_set_location (context_p, &for_statement.condition_location);\n  scanner_seek (context_p);\n  lexer_next_token (context_p);\n\n  if (context_p->token.type != LEXER_SEMICOLON)\n  {\n    parser_parse_expression (context_p, PARSE_EXPR);\n\n    if (context_p->token.type != LEXER_SEMICOLON)\n    {\n      parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);\n    }\n\n    opcode = CBC_BRANCH_IF_TRUE_BACKWARD;\n    if (context_p->last_cbc_opcode == CBC_LOGICAL_NOT)\n    {\n      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n      opcode = CBC_BRANCH_IF_FALSE_BACKWARD;\n    }\n    else if (context_p->last_cbc_opcode == CBC_PUSH_TRUE)\n    {\n      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n      opcode = CBC_JUMP_BACKWARD;\n    }\n  }\n  else\n  {\n    opcode = CBC_JUMP_BACKWARD;\n  }\n\n  parser_stack_pop (context_p, NULL, 1 + sizeof (parser_loop_statement_t) + sizeof (parser_for_statement_t));\n  parser_stack_iterator_init (context_p, &context_p->last_statement);\n\n  parser_emit_cbc_backward_branch (context_p, (uint16_t) opcode, for_statement.start_offset);\n  parser_set_breaks_to_current_position (context_p, loop.branch_list_p);\n\n#if JERRY_ESNEXT\n  if (context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_SCOPE\n      || context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_CONTEXT)\n  {\n    parser_pop_block_context (context_p);\n  }\n#endif\n\n  /* Calling scanner_seek is unnecessary because all\n   * info blocks inside the for statement should be processed. */\n  scanner_set_location (context_p, &location);\n  context_p->token = current_token;\n}",
        "begin_line": 1658,
        "end_line": 1766,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-statm.parser_parse_for_statement_start#1175",
        "src_path": "jerry-core/parser/js/js-parser-statm.c",
        "class_name": "jerry-core.parser.js.js-parser-statm",
        "signature": "jerry-core.parser.js.js-parser-statm.parser_parse_for_statement_start (parser_context_t *context_p) /**< context */",
        "snippet": "static void\nparser_parse_for_statement_start (parser_context_t *context_p) /**< context */\n{\n  parser_loop_statement_t loop;\n\n  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_FOR);\n  lexer_next_token (context_p);\n\n#if JERRY_ESNEXT\n  bool is_for_await = false;\n\n  if (context_p->token.type == LEXER_KEYW_AWAIT)\n  {\n    if (JERRY_UNLIKELY (context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE))\n    {\n      parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);\n    }\n    lexer_next_token (context_p);\n    is_for_await = true;\n  }\n#endif /* JERRY_ESNEXT */\n\n  if (context_p->token.type != LEXER_LEFT_PAREN)\n  {\n#if JERRY_ESNEXT\n    if (context_p->token.type == LEXER_LITERAL\n        && context_p->token.keyword_type == LEXER_KEYW_AWAIT\n        && !(context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE))\n    {\n      parser_raise_error (context_p, PARSER_ERR_FOR_AWAIT_NO_ASYNC);\n    }\n#endif /* JERRY_ESNEXT */\n    parser_raise_error (context_p, PARSER_ERR_LEFT_PAREN_EXPECTED);\n  }\n\n  if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n  {\n    parser_for_in_of_statement_t for_in_of_statement;\n    scanner_location_t start_location, end_location;\n\n#if JERRY_ESNEXT\n    JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FOR_IN\n                  || context_p->next_scanner_info_p->type == SCANNER_TYPE_FOR_OF);\n\n    bool is_for_in = (context_p->next_scanner_info_p->type == SCANNER_TYPE_FOR_IN);\n    end_location = ((scanner_location_info_t *) context_p->next_scanner_info_p)->location;\n\n    scanner_release_next (context_p, sizeof (scanner_location_info_t));\n\n    scanner_get_location (&start_location, context_p);\n    lexer_next_token (context_p);\n\n    uint8_t token_type = LEXER_EOS;\n    bool has_context = false;\n\n    if (context_p->token.type == LEXER_KEYW_VAR\n        || context_p->token.type == LEXER_KEYW_LET\n        || context_p->token.type == LEXER_KEYW_CONST)\n    {\n      token_type = context_p->token.type;\n      has_context = context_p->next_scanner_info_p->source_p == context_p->source_p;\n      JERRY_ASSERT (!has_context || context_p->next_scanner_info_p->type == SCANNER_TYPE_BLOCK);\n      scanner_get_location (&start_location, context_p);\n\n      /* TODO: remove this after the pre-scanner supports strict mode detection. */\n      if (context_p->next_scanner_info_p->source_p == context_p->source_p\n          && context_p->next_scanner_info_p->type == SCANNER_TYPE_LET_EXPRESSION)\n      {\n        scanner_release_next (context_p, sizeof (scanner_info_t));\n      }\n    }\n    else if (context_p->token.type == LEXER_LITERAL && lexer_token_is_let (context_p))\n    {\n      if (context_p->next_scanner_info_p->source_p == context_p->source_p\n          && context_p->next_scanner_info_p->type == SCANNER_TYPE_LET_EXPRESSION)\n      {\n        scanner_release_next (context_p, sizeof (scanner_info_t));\n      }\n      else\n      {\n        token_type = LEXER_KEYW_LET;\n        has_context = (context_p->next_scanner_info_p->source_p == context_p->source_p);\n        scanner_get_location (&start_location, context_p);\n      }\n    }\n\n    if (has_context)\n    {\n      has_context = parser_push_block_context (context_p, true);\n    }\n\n    scanner_set_location (context_p, &end_location);\n#else /* !JERRY_ESNEXT */\n    JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FOR_IN);\n\n    bool is_for_in = true;\n    scanner_get_location (&start_location, context_p);\n\n    scanner_set_location (context_p, &((scanner_location_info_t *) context_p->next_scanner_info_p)->location);\n    scanner_release_next (context_p, sizeof (scanner_location_info_t));\n#endif /* JERRY_ESNEXT */\n\n    /* The length of both 'in' and 'of' is two. */\n    const uint8_t *source_end_p = context_p->source_p - 2;\n\n    scanner_seek (context_p);\n\n#if JERRY_ESNEXT\n    if (is_for_in && is_for_await)\n    {\n      context_p->token.line = context_p->line;\n      context_p->token.column = context_p->column - 2;\n      parser_raise_error (context_p, PARSER_ERR_FOR_AWAIT_NO_OF);\n    }\n#endif /* JERRY_ESNEXT */\n\n    lexer_next_token (context_p);\n    parser_parse_expression (context_p, PARSE_EXPR);\n\n    if (context_p->token.type != LEXER_RIGHT_PAREN)\n    {\n      parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);\n    }\n\n#ifndef JERRY_NDEBUG\n    PARSER_PLUS_EQUAL_U16 (context_p->context_stack_depth,\n                           is_for_in ? PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION\n                                     : PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);\n#endif /* !JERRY_NDEBUG */\n\n    cbc_ext_opcode_t init_opcode = CBC_EXT_FOR_IN_INIT;\n\n#if JERRY_ESNEXT\n    if (!is_for_in)\n    {\n      init_opcode = is_for_await ? CBC_EXT_FOR_AWAIT_OF_INIT : CBC_EXT_FOR_OF_INIT;\n    }\n#endif /* JERRY_ESNEXT */\n\n    parser_emit_cbc_ext_forward_branch (context_p, init_opcode, &for_in_of_statement.branch);\n\n    JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);\n    for_in_of_statement.start_offset = context_p->byte_code_size;\n\n#if JERRY_ESNEXT\n    if (has_context)\n    {\n      parser_emit_cbc_ext (context_p, CBC_EXT_CLONE_CONTEXT);\n    }\n#endif /* JERRY_ESNEXT */\n\n    /* The expression parser must not read the 'in' or 'of' tokens. */\n    scanner_get_location (&end_location, context_p);\n    scanner_set_location (context_p, &start_location);\n\n    const uint8_t *original_source_end_p = context_p->source_end_p;\n    context_p->source_end_p = source_end_p;\n    scanner_seek (context_p);\n\n#if JERRY_ESNEXT\n    if (token_type == LEXER_EOS)\n    {\n      lexer_next_token (context_p);\n\n      if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)\n      {\n        token_type = context_p->token.type;\n      }\n    }\n#else /* !JERRY_ESNEXT */\n    lexer_next_token (context_p);\n\n    uint8_t token_type = context_p->token.type;\n#endif /* JERRY_ESNEXT */\n\n    switch (token_type)\n    {\n#if JERRY_ESNEXT\n      case LEXER_KEYW_LET:\n      case LEXER_KEYW_CONST:\n#endif /* JERRY_ESNEXT */\n      case LEXER_KEYW_VAR:\n      {\n#if JERRY_ESNEXT\n        if (lexer_check_next_characters (context_p, LIT_CHAR_LEFT_SQUARE, LIT_CHAR_LEFT_BRACE))\n        {\n          parser_emit_cbc_ext (context_p, is_for_in ? CBC_EXT_FOR_IN_GET_NEXT\n                                                    : CBC_EXT_FOR_OF_GET_NEXT);\n\n          parser_pattern_flags_t flags = (PARSER_PATTERN_BINDING | PARSER_PATTERN_TARGET_ON_STACK);\n\n          if (context_p->next_scanner_info_p->source_p == (context_p->source_p + 1))\n          {\n            if (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER)\n            {\n              scanner_release_next (context_p, sizeof (scanner_location_info_t));\n            }\n            else\n            {\n              JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS);\n              if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)\n              {\n                flags |= PARSER_PATTERN_HAS_REST_ELEMENT;\n              }\n\n              scanner_release_next (context_p, sizeof (scanner_info_t));\n            }\n          }\n\n          if (token_type == LEXER_KEYW_LET)\n          {\n            flags |= PARSER_PATTERN_LET;\n          }\n          else if (token_type == LEXER_KEYW_CONST)\n          {\n            flags |= PARSER_PATTERN_CONST;\n          }\n\n          parser_parse_initializer_by_next_char (context_p, flags);\n          break;\n        }\n#endif /* JERRY_ESNEXT */\n\n        lexer_expect_identifier (context_p, LEXER_IDENT_LITERAL);\n\n#if JERRY_ESNEXT\n        if (context_p->token.keyword_type == LEXER_KEYW_LET\n            && token_type != LEXER_KEYW_VAR)\n        {\n          parser_raise_error (context_p, PARSER_ERR_LEXICAL_LET_BINDING);\n        }\n#endif /* JERRY_ESNEXT */\n\n        JERRY_ASSERT (context_p->token.type == LEXER_LITERAL\n                      && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);\n\n        uint16_t literal_index = context_p->lit_object.index;\n        lexer_next_token (context_p);\n\n        if (context_p->token.type == LEXER_ASSIGN)\n        {\n#if JERRY_ESNEXT\n          if (context_p->status_flags & PARSER_IS_STRICT)\n          {\n            parser_raise_error (context_p, PARSER_ERR_FOR_IN_OF_DECLARATION);\n          }\n#endif /* JERRY_ESNEXT */\n          parser_branch_t branch;\n\n          /* Initialiser is never executed. */\n          parser_emit_cbc_forward_branch (context_p, CBC_JUMP_FORWARD, &branch);\n          lexer_next_token (context_p);\n          parser_parse_expression_statement (context_p, PARSE_EXPR_NO_COMMA);\n          parser_set_branch_to_current_position (context_p, &branch);\n        }\n\n        parser_emit_cbc_ext (context_p, is_for_in ? CBC_EXT_FOR_IN_GET_NEXT\n                                                  : CBC_EXT_FOR_OF_GET_NEXT);\n#if JERRY_ESNEXT\n#ifndef JERRY_NDEBUG\n        if (literal_index < PARSER_REGISTER_START\n            && has_context\n            && !scanner_literal_is_created (context_p, literal_index))\n        {\n          context_p->global_status_flags |= ECMA_PARSE_INTERNAL_FOR_IN_OFF_CONTEXT_ERROR;\n        }\n#endif /* !JERRY_NDEBUG */\n\n        uint16_t opcode = (has_context ? CBC_ASSIGN_LET_CONST : CBC_ASSIGN_SET_IDENT);\n        parser_emit_cbc_literal (context_p, opcode, literal_index);\n#else /* !JERRY_ESNEXT */\n        parser_emit_cbc_literal (context_p, CBC_ASSIGN_SET_IDENT, literal_index);\n#endif /* JERRY_ESNEXT */\n        break;\n      }\n#if JERRY_ESNEXT\n      case LEXER_LEFT_BRACE:\n      case LEXER_LEFT_SQUARE:\n      {\n        if (context_p->next_scanner_info_p->source_p == context_p->source_p\n            && context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS\n            && (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_DESTRUCTURING_FOR))\n        {\n          parser_emit_cbc_ext (context_p, is_for_in ? CBC_EXT_FOR_IN_GET_NEXT\n                                                    : CBC_EXT_FOR_OF_GET_NEXT);\n\n          uint32_t flags = PARSER_PATTERN_TARGET_ON_STACK;\n\n          if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)\n          {\n            flags |= PARSER_PATTERN_HAS_REST_ELEMENT;\n          }\n\n          scanner_release_next (context_p, sizeof (scanner_info_t));\n          parser_parse_initializer (context_p, flags);\n          /* Pop the value returned by GET_NEXT. */\n          parser_emit_cbc (context_p, CBC_POP);\n          break;\n        }\n        /* FALLTHRU */\n      }\n#endif /* JERRY_ESNEXT */\n      default:\n      {\n        uint16_t opcode;\n\n        parser_parse_expression (context_p, PARSE_EXPR_LEFT_HAND_SIDE);\n\n        opcode = context_p->last_cbc_opcode;\n\n        /* The CBC_EXT_FOR_IN_CREATE_CONTEXT flushed the opcode combiner. */\n        JERRY_ASSERT (opcode != CBC_PUSH_TWO_LITERALS\n                      && opcode != CBC_PUSH_THREE_LITERALS);\n\n        opcode = parser_check_left_hand_side_expression (context_p, opcode);\n\n        parser_emit_cbc_ext (context_p, is_for_in ? CBC_EXT_FOR_IN_GET_NEXT\n                                                  : CBC_EXT_FOR_OF_GET_NEXT);\n        parser_flush_cbc (context_p);\n\n        context_p->last_cbc_opcode = opcode;\n        break;\n      }\n    }\n\n    if (context_p->token.type != LEXER_EOS)\n    {\n#if JERRY_ESNEXT\n      parser_raise_error (context_p, is_for_in ? PARSER_ERR_IN_EXPECTED : PARSER_ERR_OF_EXPECTED);\n#else /* !JERRY_ESNEXT */\n      parser_raise_error (context_p, PARSER_ERR_IN_EXPECTED);\n#endif /* JERRY_ESNEXT */\n    }\n\n    parser_flush_cbc (context_p);\n    scanner_set_location (context_p, &end_location);\n    context_p->source_end_p = original_source_end_p;\n    lexer_next_token (context_p);\n\n    loop.branch_list_p = NULL;\n\n    parser_stack_push (context_p, &for_in_of_statement, sizeof (parser_for_in_of_statement_t));\n    parser_stack_push (context_p, &loop, sizeof (parser_loop_statement_t));\n\n    uint8_t for_type = PARSER_STATEMENT_FOR_IN;\n\n#if JERRY_ESNEXT\n    if (!is_for_in)\n    {\n      for_type = is_for_await ? PARSER_STATEMENT_FOR_AWAIT_OF : PARSER_STATEMENT_FOR_OF;\n    }\n#endif /* JERRY_ESNEXT */\n\n    parser_stack_push_uint8 (context_p, for_type);\n    parser_stack_iterator_init (context_p, &context_p->last_statement);\n    return;\n  }\n\n  lexer_next_token (context_p);\n\n  if (context_p->token.type != LEXER_SEMICOLON)\n  {\n#if JERRY_ESNEXT\n    const uint8_t *source_p = context_p->source_p;\n#endif /* JERRY_ESNEXT */\n\n    switch (context_p->token.type)\n    {\n#if JERRY_ESNEXT\n      case LEXER_LITERAL:\n      {\n        if (!lexer_token_is_let (context_p))\n        {\n          parser_parse_expression_statement (context_p, PARSE_EXPR);\n          break;\n        }\n\n        if (context_p->next_scanner_info_p->source_p == context_p->source_p\n            && context_p->next_scanner_info_p->type != SCANNER_TYPE_BLOCK)\n        {\n          if (context_p->next_scanner_info_p->type == SCANNER_TYPE_LET_EXPRESSION)\n          {\n            scanner_release_next (context_p, sizeof (scanner_info_t));\n          }\n\n          parser_parse_expression_statement (context_p, PARSE_EXPR);\n          break;\n        }\n\n        context_p->token.type = LEXER_KEYW_LET;\n        /* FALLTHRU */\n      }\n      case LEXER_KEYW_LET:\n      case LEXER_KEYW_CONST:\n      {\n        if (context_p->next_scanner_info_p->source_p == source_p)\n        {\n          parser_push_block_context (context_p, true);\n        }\n        /* FALLTHRU */\n      }\n#endif /* JERRY_ESNEXT */\n      case LEXER_KEYW_VAR:\n      {\n        parser_parse_var_statement (context_p);\n        break;\n      }\n      default:\n      {\n        parser_parse_expression_statement (context_p, PARSE_EXPR);\n        break;\n      }\n    }\n\n    if (context_p->token.type != LEXER_SEMICOLON)\n    {\n      parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);\n    }\n  }\n\n#if JERRY_ESNEXT\n  if (is_for_await)\n  {\n    parser_raise_error (context_p, PARSER_ERR_FOR_AWAIT_NO_OF);\n  }\n#endif /* JERRY_ESNEXT */\n\n  JERRY_ASSERT (context_p->next_scanner_info_p->source_p != context_p->source_p\n                || context_p->next_scanner_info_p->type == SCANNER_TYPE_FOR);\n\n  if (context_p->next_scanner_info_p->source_p != context_p->source_p\n      || ((scanner_for_info_t *) context_p->next_scanner_info_p)->end_location.source_p == NULL)\n  {\n    if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n    {\n      /* Even though the scanning is failed, there might be valid statements\n       * inside the for statement which depend on scanner info blocks. */\n      scanner_release_next (context_p, sizeof (scanner_for_info_t));\n    }\n\n    /* The prescanner couldn't find the second semicolon or the closing paranthesis. */\n    lexer_next_token (context_p);\n    parser_parse_expression (context_p, PARSE_EXPR);\n\n    if (context_p->token.type != LEXER_SEMICOLON)\n    {\n      parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);\n    }\n\n    lexer_next_token (context_p);\n    parser_parse_expression_statement (context_p, PARSE_EXPR);\n\n    JERRY_ASSERT (context_p->token.type != LEXER_RIGHT_PAREN);\n    parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);\n  }\n\n  parser_for_statement_t for_statement;\n  scanner_for_info_t *for_info_p = (scanner_for_info_t *) context_p->next_scanner_info_p;\n\n  parser_emit_cbc_forward_branch (context_p, CBC_JUMP_FORWARD, &for_statement.branch);\n\n  JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);\n\n  for_statement.start_offset = context_p->byte_code_size;\n  scanner_get_location (&for_statement.condition_location, context_p);\n  for_statement.expression_location = for_info_p->expression_location;\n\n  scanner_set_location (context_p, &for_info_p->end_location);\n  scanner_release_next (context_p, sizeof (scanner_for_info_t));\n  scanner_seek (context_p);\n  lexer_next_token (context_p);\n\n  loop.branch_list_p = NULL;\n\n  parser_stack_push (context_p, &for_statement, sizeof (parser_for_statement_t));\n  parser_stack_push (context_p, &loop, sizeof (parser_loop_statement_t));\n  parser_stack_push_uint8 (context_p, PARSER_STATEMENT_FOR);\n  parser_stack_iterator_init (context_p, &context_p->last_statement);\n}",
        "begin_line": 1175,
        "end_line": 1653,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-statm.parser_parse_statements#2780",
        "src_path": "jerry-core/parser/js/js-parser-statm.c",
        "class_name": "jerry-core.parser.js.js-parser-statm",
        "signature": "jerry-core.parser.js.js-parser-statm.parser_parse_statements (parser_context_t *context_p) /**< context */",
        "snippet": "void\nparser_parse_statements (parser_context_t *context_p) /**< context */\n{\n  /* Statement parsing cannot be nested. */\n  JERRY_ASSERT (context_p->last_statement.current_p == NULL);\n  parser_stack_push_uint8 (context_p, PARSER_STATEMENT_START);\n  parser_stack_iterator_init (context_p, &context_p->last_statement);\n\n#if JERRY_DEBUGGER\n  /* Set lexical enviroment for the debugger. */\n  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n  {\n    context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;\n    context_p->last_breakpoint_line = 0;\n  }\n#endif /* JERRY_DEBUGGER */\n\n  while (context_p->token.type == LEXER_LITERAL\n         && context_p->token.lit_location.type == LEXER_STRING_LITERAL)\n  {\n    lexer_lit_location_t lit_location;\n    parser_strict_mode_type_t strict_mode = PARSER_USE_STRICT_NOT_FOUND;\n\n    JERRY_ASSERT (context_p->stack_depth <= 1);\n#ifndef JERRY_NDEBUG\n    JERRY_ASSERT (context_p->context_stack_depth == context_p->stack_depth);\n#endif /* !JERRY_NDEBUG */\n\n    if (lexer_string_is_use_strict (context_p))\n    {\n      strict_mode = PARSER_USE_STRICT_FOUND;\n\n      if (!(context_p->status_flags & PARSER_IS_STRICT))\n      {\n        /* The next token should be parsed in strict mode. */\n        context_p->status_flags |= PARSER_IS_STRICT;\n        strict_mode = PARSER_USE_STRICT_SET;\n      }\n    }\n\n    lit_location = context_p->token.lit_location;\n    lexer_next_token (context_p);\n\n    if (!lexer_string_is_directive (context_p))\n    {\n      /* The string is part of an expression statement. */\n      if (strict_mode == PARSER_USE_STRICT_SET)\n      {\n        context_p->status_flags &= (uint32_t) ~PARSER_IS_STRICT;\n      }\n\n#if JERRY_DEBUGGER\n      if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n      {\n        JERRY_ASSERT (context_p->last_breakpoint_line == 0);\n\n        parser_emit_cbc (context_p, CBC_BREAKPOINT_DISABLED);\n        parser_flush_cbc (context_p);\n\n        parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST, context_p->token.line);\n\n        context_p->last_breakpoint_line = context_p->token.line;\n      }\n#endif /* JERRY_DEBUGGER */\n#if JERRY_LINE_INFO\n      parser_line_info_append (context_p, context_p->token.line, context_p->token.column);\n#endif /* JERRY_LINE_INFO */\n\n      lexer_construct_literal_object (context_p, &lit_location, LEXER_STRING_LITERAL);\n      parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);\n      /* The extra_value is used for saving the token. */\n      context_p->token.extra_value = context_p->token.type;\n      context_p->token.type = LEXER_EXPRESSION_START;\n      break;\n    }\n\n#if JERRY_PARSER_DUMP_BYTE_CODE\n    if (strict_mode == PARSER_USE_STRICT_SET && context_p->is_show_opcodes)\n    {\n      JERRY_DEBUG_MSG (\"  Note: switch to strict mode\\n\\n\");\n    }\n#endif /* JERRY_PARSER_DUMP_BYTE_CODE */\n\n#if JERRY_ESNEXT\n    if (strict_mode != PARSER_USE_STRICT_NOT_FOUND\n        && (context_p->status_flags & PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT))\n    {\n      parser_raise_error (context_p, PARSER_ERR_USE_STRICT_NOT_ALLOWED);\n    }\n#endif /* JERRY_ESNEXT */\n\n    if (context_p->token.type == LEXER_SEMICOLON)\n    {\n      lexer_next_token (context_p);\n    }\n\n    /* The last directive prologue can be the result of the script. */\n    if (!(context_p->status_flags & PARSER_IS_FUNCTION)\n        && (context_p->token.type != LEXER_LITERAL\n            || context_p->token.lit_location.type != LEXER_STRING_LITERAL))\n    {\n      lexer_construct_literal_object (context_p, &lit_location, LEXER_STRING_LITERAL);\n      parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);\n      parser_emit_cbc (context_p, CBC_POP_BLOCK);\n      parser_flush_cbc (context_p);\n      break;\n    }\n  }\n\n  if (context_p->status_flags & PARSER_IS_STRICT\n      && context_p->status_flags & PARSER_HAS_NON_STRICT_ARG)\n  {\n    parser_raise_error (context_p, PARSER_ERR_NON_STRICT_ARG_DEFINITION);\n  }\n\n  while (context_p->token.type != LEXER_EOS\n         || context_p->stack_top_uint8 != PARSER_STATEMENT_START)\n  {\n#ifndef JERRY_NDEBUG\n    JERRY_ASSERT (context_p->stack_depth == context_p->context_stack_depth);\n#endif /* !JERRY_NDEBUG */\n\n#if JERRY_ESNEXT\n    JERRY_ASSERT (context_p->stack_top_uint8 != PARSER_STATEMENT_PRIVATE_SCOPE\n                  && context_p->stack_top_uint8 != PARSER_STATEMENT_PRIVATE_CONTEXT);\n#endif /* JERRY_ESNEXT */\n\n#if JERRY_DEBUGGER\n    if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED\n        && context_p->token.line != context_p->last_breakpoint_line\n        && context_p->token.type != LEXER_SEMICOLON\n        && context_p->token.type != LEXER_LEFT_BRACE\n        && context_p->token.type != LEXER_RIGHT_BRACE\n        && context_p->token.type != LEXER_KEYW_VAR\n        && context_p->token.type != LEXER_KEYW_LET\n        && context_p->token.type != LEXER_KEYW_CONST\n        && context_p->token.type != LEXER_KEYW_FUNCTION\n        && context_p->token.type != LEXER_KEYW_CASE\n        && context_p->token.type != LEXER_KEYW_DEFAULT)\n    {\n      parser_emit_cbc (context_p, CBC_BREAKPOINT_DISABLED);\n      parser_flush_cbc (context_p);\n\n      parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST, context_p->token.line);\n\n      context_p->last_breakpoint_line = context_p->token.line;\n    }\n#endif /* JERRY_DEBUGGER */\n\n#if JERRY_LINE_INFO\n    if (context_p->token.type != LEXER_SEMICOLON\n        && context_p->token.type != LEXER_LEFT_BRACE\n        && context_p->token.type != LEXER_RIGHT_BRACE\n        && context_p->token.type != LEXER_KEYW_VAR\n        && context_p->token.type != LEXER_KEYW_LET\n        && context_p->token.type != LEXER_KEYW_CONST\n        && context_p->token.type != LEXER_KEYW_FUNCTION\n        && context_p->token.type != LEXER_KEYW_CASE\n        && context_p->token.type != LEXER_KEYW_DEFAULT)\n    {\n      parser_line_info_append (context_p, context_p->token.line, context_p->token.column);\n    }\n#endif /* JERRY_LINE_INFO */\n\n    switch (context_p->token.type)\n    {\n      case LEXER_SEMICOLON:\n      {\n        break;\n      }\n\n      case LEXER_RIGHT_BRACE:\n      {\n        if (parser_statement_flags[context_p->stack_top_uint8] & PARSER_STATM_SINGLE_STATM)\n        {\n          parser_raise_error (context_p, PARSER_ERR_STATEMENT_EXPECTED);\n        }\n        break;\n      }\n\n      case LEXER_LEFT_BRACE:\n      {\n#if JERRY_ESNEXT\n        if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n        {\n          parser_push_block_context (context_p, false);\n        }\n        else\n        {\n          parser_stack_push_uint8 (context_p, PARSER_STATEMENT_BLOCK);\n        }\n#else /* !JERRY_ESNEXT */\n        parser_stack_push_uint8 (context_p, PARSER_STATEMENT_BLOCK);\n#endif /* JERRY_ESNEXT */\n\n        parser_stack_iterator_init (context_p, &context_p->last_statement);\n        lexer_next_token (context_p);\n        continue;\n      }\n\n      case LEXER_KEYW_VAR:\n#if JERRY_ESNEXT\n      case LEXER_KEYW_LET:\n      case LEXER_KEYW_CONST:\n#endif /* JERRY_ESNEXT */\n      {\n        parser_parse_var_statement (context_p);\n        break;\n      }\n\n#if JERRY_ESNEXT\n      case LEXER_KEYW_CLASS:\n      {\n        parser_validate_lexical_context (context_p);\n        parser_parse_class (context_p, true);\n        goto consume_last_statement;\n      }\n#endif /* JERRY_ESNEXT */\n\n#if JERRY_MODULE_SYSTEM\n      case LEXER_KEYW_IMPORT:\n      {\n        parser_parse_import_statement (context_p);\n        break;\n      }\n\n      case LEXER_KEYW_EXPORT:\n      {\n        if (parser_parse_export_statement (context_p))\n        {\n          goto consume_last_statement;\n        }\n        break;\n      }\n#endif /* JERRY_MODULE_SYSTEM */\n\n      case LEXER_KEYW_FUNCTION:\n      {\n        parser_parse_function_statement (context_p);\n        goto consume_last_statement;\n      }\n\n      case LEXER_KEYW_IF:\n      {\n        parser_parse_if_statement_start (context_p);\n        continue;\n      }\n\n      case LEXER_KEYW_SWITCH:\n      {\n        parser_parse_switch_statement_start (context_p);\n        continue;\n      }\n\n      case LEXER_KEYW_DO:\n      {\n        parser_do_while_statement_t do_while_statement;\n        parser_loop_statement_t loop;\n\n        JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);\n\n        do_while_statement.start_offset = context_p->byte_code_size;\n        loop.branch_list_p = NULL;\n\n        parser_stack_push (context_p, &do_while_statement, sizeof (parser_do_while_statement_t));\n        parser_stack_push (context_p, &loop, sizeof (parser_loop_statement_t));\n        parser_stack_push_uint8 (context_p, PARSER_STATEMENT_DO_WHILE);\n        parser_stack_iterator_init (context_p, &context_p->last_statement);\n        lexer_next_token (context_p);\n        continue;\n      }\n\n      case LEXER_KEYW_WHILE:\n      {\n        parser_parse_while_statement_start (context_p);\n        continue;\n      }\n\n      case LEXER_KEYW_FOR:\n      {\n        parser_parse_for_statement_start (context_p);\n        continue;\n      }\n\n      case LEXER_KEYW_WITH:\n      {\n        parser_parse_with_statement_start (context_p);\n        continue;\n      }\n\n      case LEXER_KEYW_TRY:\n      {\n        parser_try_statement_t try_statement;\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_LEFT_BRACE)\n        {\n          parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_EXPECTED);\n        }\n\n#ifndef JERRY_NDEBUG\n        PARSER_PLUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);\n#endif /* !JERRY_NDEBUG */\n\n        try_statement.type = parser_try_block;\n        parser_emit_cbc_ext_forward_branch (context_p,\n                                            CBC_EXT_TRY_CREATE_CONTEXT,\n                                            &try_statement.branch);\n\n#if JERRY_ESNEXT\n        try_statement.scope_stack_top = context_p->scope_stack_top;\n        try_statement.scope_stack_reg_top = context_p->scope_stack_reg_top;\n\n        if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n        {\n          JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_BLOCK);\n\n          if (scanner_is_context_needed (context_p, PARSER_CHECK_BLOCK_CONTEXT))\n          {\n            parser_emit_cbc_ext (context_p, CBC_EXT_TRY_CREATE_ENV);\n          }\n\n          scanner_create_variables (context_p, SCANNER_CREATE_VARS_NO_OPTS);\n        }\n#endif /* JERRY_ESNEXT */\n\n        parser_stack_push (context_p, &try_statement, sizeof (parser_try_statement_t));\n        parser_stack_push_uint8 (context_p, PARSER_STATEMENT_TRY);\n        parser_stack_iterator_init (context_p, &context_p->last_statement);\n        lexer_next_token (context_p);\n        continue;\n      }\n\n      case LEXER_KEYW_DEFAULT:\n      {\n        parser_parse_default_statement (context_p);\n        continue;\n      }\n\n      case LEXER_KEYW_CASE:\n      {\n        parser_parse_case_statement (context_p);\n        continue;\n      }\n\n      case LEXER_KEYW_BREAK:\n      {\n        parser_parse_break_statement (context_p);\n        break;\n      }\n\n      case LEXER_KEYW_CONTINUE:\n      {\n        parser_parse_continue_statement (context_p);\n        break;\n      }\n\n      case LEXER_KEYW_THROW:\n      {\n        lexer_next_token (context_p);\n        if (context_p->token.flags & LEXER_WAS_NEWLINE)\n        {\n          parser_raise_error (context_p, PARSER_ERR_EXPRESSION_EXPECTED);\n        }\n        parser_parse_expression (context_p, PARSE_EXPR);\n        parser_emit_cbc (context_p, CBC_THROW);\n        break;\n      }\n\n      case LEXER_KEYW_RETURN:\n      {\n        if (!(context_p->status_flags & PARSER_IS_FUNCTION))\n        {\n          parser_raise_error (context_p, PARSER_ERR_INVALID_RETURN);\n        }\n\n        lexer_next_token (context_p);\n\n        if ((context_p->token.flags & LEXER_WAS_NEWLINE)\n            || context_p->token.type == LEXER_SEMICOLON\n            || context_p->token.type == LEXER_EOS\n            || context_p->token.type == LEXER_RIGHT_BRACE)\n        {\n#if JERRY_ESNEXT\n          if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)\n          {\n            parser_emit_cbc_ext (context_p, CBC_EXT_RETURN_UNDEFINED);\n            break;\n          }\n#endif /* JERRY_ESNEXT */\n\n          parser_emit_cbc (context_p, CBC_RETURN_WITH_BLOCK);\n          break;\n        }\n\n        parser_parse_expression (context_p, PARSE_EXPR);\n\n        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)\n        {\n          context_p->last_cbc_opcode = CBC_RETURN_WITH_LITERAL;\n          break;\n        }\n\n        parser_emit_cbc (context_p, CBC_RETURN);\n        break;\n      }\n\n      case LEXER_KEYW_DEBUGGER:\n      {\n#if JERRY_DEBUGGER\n        /* This breakpoint location is not reported to the\n         * debugger, so it is impossible to disable it. */\n        if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n        {\n          parser_emit_cbc (context_p, CBC_BREAKPOINT_ENABLED);\n        }\n#endif /* JERRY_DEBUGGER */\n        lexer_next_token (context_p);\n        break;\n      }\n\n      case LEXER_LITERAL:\n      {\n        if (context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n        {\n          if (JERRY_UNLIKELY (lexer_check_next_character (context_p, LIT_CHAR_COLON)))\n          {\n            parser_parse_label (context_p);\n            lexer_consume_next_character (context_p);\n            lexer_next_token (context_p);\n            continue;\n          }\n#if JERRY_ESNEXT\n          if (JERRY_UNLIKELY (lexer_token_is_let (context_p)))\n          {\n            if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n            {\n              if (context_p->next_scanner_info_p->type == SCANNER_TYPE_LET_EXPRESSION)\n              {\n                scanner_release_next (context_p, sizeof (scanner_info_t));\n              }\n\n              if (context_p->status_flags & PARSER_IS_FUNCTION)\n              {\n                parser_parse_expression_statement (context_p, PARSE_EXPR);\n                break;\n              }\n\n              parser_parse_block_expression (context_p, PARSE_EXPR);\n              break;\n            }\n\n            context_p->token.type = LEXER_KEYW_LET;\n            parser_parse_var_statement (context_p);\n            break;\n          }\n\n          if (JERRY_UNLIKELY (lexer_token_is_async (context_p))\n              && context_p->next_scanner_info_p->source_p == context_p->source_p)\n          {\n            bool is_statement = true;\n\n            if (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION)\n            {\n              is_statement = (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_STATEMENT) != 0;\n\n              JERRY_ASSERT (!is_statement || (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_ASYNC));\n            }\n            else\n            {\n              JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_ASYNC_FUNCTION);\n\n              scanner_release_next (context_p, sizeof (scanner_info_t));\n            }\n\n            if (is_statement)\n            {\n              if (parser_statement_flags[context_p->stack_top_uint8] & PARSER_STATM_SINGLE_STATM)\n              {\n                parser_raise_error (context_p, PARSER_ERR_LEXICAL_SINGLE_STATEMENT);\n              }\n\n#if JERRY_FUNCTION_TO_STRING\n              context_p->function_start_p = context_p->token.lit_location.char_p;\n#endif /* JERRY_FUNCTION_TO_STRING */\n              lexer_next_token (context_p);\n              JERRY_ASSERT (context_p->token.type == LEXER_KEYW_FUNCTION);\n              continue;\n            }\n          }\n#endif /* JERRY_ESNEXT */\n        }\n        /* FALLTHRU */\n      }\n\n      default:\n      {\n        int options = PARSE_EXPR;\n\n        if (context_p->token.type == LEXER_EXPRESSION_START)\n        {\n          /* Restore the token type form the extra_value. */\n          context_p->token.type = context_p->token.extra_value;\n          options |= PARSE_EXPR_HAS_LITERAL;\n        }\n\n        if (context_p->status_flags & PARSER_IS_FUNCTION)\n        {\n          parser_parse_expression_statement (context_p, options);\n        }\n        else\n        {\n          parser_parse_block_expression (context_p, options);\n        }\n\n        break;\n      }\n    }\n\n    parser_flush_cbc (context_p);\n\n    if (context_p->token.type == LEXER_RIGHT_BRACE)\n    {\n      if (context_p->stack_top_uint8 == PARSER_STATEMENT_BLOCK)\n      {\n        parser_stack_pop_uint8 (context_p);\n        parser_stack_iterator_init (context_p, &context_p->last_statement);\n        lexer_next_token (context_p);\n      }\n#if JERRY_ESNEXT\n      else if (context_p->stack_top_uint8 == PARSER_STATEMENT_BLOCK_SCOPE\n               || context_p->stack_top_uint8 == PARSER_STATEMENT_BLOCK_CONTEXT)\n      {\n        parser_pop_block_context (context_p);\n        lexer_next_token (context_p);\n      }\n#endif /* JERRY_ESNEXT */\n      else if (context_p->stack_top_uint8 == PARSER_STATEMENT_SWITCH\n               || context_p->stack_top_uint8 == PARSER_STATEMENT_SWITCH_NO_DEFAULT)\n      {\n        int has_default = (context_p->stack_top_uint8 == PARSER_STATEMENT_SWITCH);\n        parser_loop_statement_t loop;\n        parser_switch_statement_t switch_statement;\n\n        parser_stack_pop_uint8 (context_p);\n        parser_stack_pop (context_p, &loop, sizeof (parser_loop_statement_t));\n        parser_stack_pop (context_p, &switch_statement, sizeof (parser_switch_statement_t));\n        parser_stack_iterator_init (context_p, &context_p->last_statement);\n\n        JERRY_ASSERT (switch_statement.branch_list_p == NULL);\n\n        if (!has_default)\n        {\n          parser_set_branch_to_current_position (context_p, &switch_statement.default_branch);\n        }\n\n        parser_set_breaks_to_current_position (context_p, loop.branch_list_p);\n        lexer_next_token (context_p);\n\n#if JERRY_ESNEXT\n        if (context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_SCOPE\n            || context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_CONTEXT)\n        {\n          parser_pop_block_context (context_p);\n        }\n#endif /* JERRY_ESNEXT */\n      }\n      else if (context_p->stack_top_uint8 == PARSER_STATEMENT_TRY)\n      {\n        parser_parse_try_statement_end (context_p);\n      }\n      else if (context_p->stack_top_uint8 == PARSER_STATEMENT_START)\n      {\n        if (context_p->status_flags & PARSER_IS_CLOSURE)\n        {\n#if JERRY_LINE_INFO\n          if (context_p->line_info_p == NULL)\n          {\n            parser_line_info_append (context_p, context_p->token.line, context_p->token.column);\n          }\n#endif /* JERRY_LINE_INFO */\n\n#if JERRY_FUNCTION_TO_STRING\n          context_p->function_end_p = context_p->source_p;\n#endif /* JERRY_FUNCTION_TO_STRING */\n\n          parser_stack_pop_uint8 (context_p);\n          context_p->last_statement.current_p = NULL;\n          /* There is no lexer_next_token here, since the\n           * next token belongs to the parent context. */\n          return;\n        }\n        parser_raise_error (context_p, PARSER_ERR_INVALID_RIGHT_SQUARE);\n      }\n    }\n    else if (context_p->token.type == LEXER_SEMICOLON)\n    {\n      lexer_next_token (context_p);\n    }\n    else if (context_p->token.type != LEXER_EOS\n             && !(context_p->token.flags & LEXER_WAS_NEWLINE))\n    {\n      parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);\n    }\n\nconsume_last_statement:\n    while (true)\n    {\n      switch (context_p->stack_top_uint8)\n      {\n        case PARSER_STATEMENT_LABEL:\n        {\n          parser_label_statement_t label;\n\n          parser_stack_pop_uint8 (context_p);\n          parser_stack_pop (context_p, &label, sizeof (parser_label_statement_t));\n          parser_stack_iterator_init (context_p, &context_p->last_statement);\n\n          parser_set_breaks_to_current_position (context_p, label.break_list_p);\n          continue;\n        }\n\n        case PARSER_STATEMENT_IF:\n        {\n          if (parser_parse_if_statement_end (context_p))\n          {\n            break;\n          }\n          continue;\n        }\n\n        case PARSER_STATEMENT_ELSE:\n        {\n          parser_if_else_statement_t else_statement;\n\n          parser_stack_pop_uint8 (context_p);\n          parser_stack_pop (context_p, &else_statement, sizeof (parser_if_else_statement_t));\n          parser_stack_iterator_init (context_p, &context_p->last_statement);\n\n          parser_set_branch_to_current_position (context_p, &else_statement.branch);\n          continue;\n        }\n\n        case PARSER_STATEMENT_DO_WHILE:\n        {\n          parser_parse_do_while_statement_end (context_p);\n          if (context_p->token.type == LEXER_SEMICOLON)\n          {\n            lexer_next_token (context_p);\n          }\n          continue;\n        }\n\n        case PARSER_STATEMENT_WHILE:\n        {\n          parser_parse_while_statement_end (context_p);\n          continue;\n        }\n\n        case PARSER_STATEMENT_FOR:\n        {\n          parser_parse_for_statement_end (context_p);\n          continue;\n        }\n\n        case PARSER_STATEMENT_FOR_IN:\n#if JERRY_ESNEXT\n        case PARSER_STATEMENT_FOR_OF:\n        case PARSER_STATEMENT_FOR_AWAIT_OF:\n#endif /* JERRY_ESNEXT */\n        {\n          parser_for_in_of_statement_t for_in_of_statement;\n          parser_loop_statement_t loop;\n\n#if JERRY_ESNEXT\n          uint8_t for_type = context_p->stack_top_uint8;\n#endif /* JERRY_ESNEXT */\n\n          parser_stack_pop_uint8 (context_p);\n          parser_stack_pop (context_p, &loop, sizeof (parser_loop_statement_t));\n          parser_stack_pop (context_p, &for_in_of_statement, sizeof (parser_for_in_of_statement_t));\n          parser_stack_iterator_init (context_p, &context_p->last_statement);\n\n          parser_set_continues_to_current_position (context_p, loop.branch_list_p);\n\n          parser_flush_cbc (context_p);\n\n          uint16_t stack_allocation = PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;\n#if JERRY_ESNEXT\n          if (for_type != PARSER_STATEMENT_FOR_IN)\n          {\n            stack_allocation = (for_type == PARSER_STATEMENT_FOR_OF ? PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION\n                                                                    : PARSER_FOR_AWAIT_OF_CONTEXT_STACK_ALLOCATION);\n          }\n#endif /* JERRY_ESNEXT */\n\n          PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, stack_allocation);\n#ifndef JERRY_NDEBUG\n          PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth, stack_allocation);\n#endif /* !JERRY_NDEBUG */\n\n          cbc_ext_opcode_t opcode = CBC_EXT_BRANCH_IF_FOR_IN_HAS_NEXT;\n\n#if JERRY_ESNEXT\n          if (for_type != PARSER_STATEMENT_FOR_IN)\n          {\n            opcode = (for_type == PARSER_STATEMENT_FOR_OF ? CBC_EXT_BRANCH_IF_FOR_OF_HAS_NEXT\n                                                          : CBC_EXT_BRANCH_IF_FOR_AWAIT_OF_HAS_NEXT);\n          }\n#endif /* JERRY_ESNEXT */\n\n          parser_emit_cbc_ext_backward_branch (context_p, opcode, for_in_of_statement.start_offset);\n\n          parser_set_breaks_to_current_position (context_p, loop.branch_list_p);\n          parser_set_branch_to_current_position (context_p, &for_in_of_statement.branch);\n\n#if JERRY_ESNEXT\n          if (context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_SCOPE\n              || context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_CONTEXT)\n          {\n            parser_pop_block_context (context_p);\n          }\n#endif /* JERRY_ESNEXT */\n          continue;\n        }\n\n        case PARSER_STATEMENT_WITH:\n        {\n          parser_parse_with_statement_end (context_p);\n          continue;\n        }\n\n        default:\n        {\n          break;\n        }\n      }\n      break;\n    }\n  }\n\n  parser_stack_pop_uint8 (context_p);\n  context_p->last_statement.current_p = NULL;\n\n  if (context_p->status_flags & PARSER_IS_CLOSURE)\n  {\n    parser_raise_error (context_p, PARSER_ERR_STATEMENT_EXPECTED);\n  }\n\n#if JERRY_LINE_INFO\n  if (context_p->line_info_p == NULL)\n  {\n    parser_line_info_append (context_p, context_p->token.line, context_p->token.column);\n  }\n#endif /* JERRY_LINE_INFO */\n}",
        "begin_line": 2780,
        "end_line": 3536,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-statm.parser_parse_var_statement#444",
        "src_path": "jerry-core/parser/js/js-parser-statm.c",
        "class_name": "jerry-core.parser.js.js-parser-statm",
        "signature": "jerry-core.parser.js.js-parser-statm.parser_parse_var_statement (parser_context_t *context_p) /**< context */",
        "snippet": "static void\nparser_parse_var_statement (parser_context_t *context_p) /**< context */\n{\n  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_VAR\n                || context_p->token.type == LEXER_KEYW_LET\n                || context_p->token.type == LEXER_KEYW_CONST);\n\n#if JERRY_ESNEXT\n  uint8_t declaration_type = context_p->token.type;\n\n  if (declaration_type != LEXER_KEYW_VAR)\n  {\n    parser_validate_lexical_context (context_p);\n  }\n#endif /* JERRY_ESNEXT */\n\n  while (true)\n  {\n#if JERRY_ESNEXT\n    if (lexer_check_next_characters (context_p, LIT_CHAR_LEFT_SQUARE, LIT_CHAR_LEFT_BRACE))\n    {\n      parser_pattern_flags_t flags = PARSER_PATTERN_BINDING;\n\n      if (declaration_type == LEXER_KEYW_LET)\n      {\n        flags |= PARSER_PATTERN_LET;\n      }\n      else if (declaration_type == LEXER_KEYW_CONST)\n      {\n        flags |= PARSER_PATTERN_CONST;\n      }\n\n      parser_parse_initializer_by_next_char (context_p, flags);\n    }\n    else\n    {\n#endif /* JERRY_ESNEXT */\n      lexer_expect_identifier (context_p, LEXER_IDENT_LITERAL);\n      JERRY_ASSERT (context_p->token.type == LEXER_LITERAL\n                    && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);\n\n#if JERRY_DEBUGGER || JERRY_LINE_INFO\n      parser_line_counter_t ident_line_counter = context_p->token.line;\n#endif /* JERRY_DEBUGGER || JERRY_LINE_INFO */\n#if JERRY_LINE_INFO\n      parser_line_counter_t ident_column_counter = context_p->token.column;\n#endif /* JERRY_LINE_INFO */\n\n#if JERRY_MODULE_SYSTEM\n      parser_module_append_export_name (context_p);\n#endif /* JERRY_MODULE_SYSTEM */\n\n#if JERRY_ESNEXT\n      if (declaration_type != LEXER_KEYW_VAR\n          && context_p->token.keyword_type == LEXER_KEYW_LET)\n      {\n        parser_raise_error (context_p, PARSER_ERR_LEXICAL_LET_BINDING);\n      }\n\n      if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n      {\n        JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED);\n        parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);\n      }\n#endif /* JERRY_ESNEXT */\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type == LEXER_ASSIGN)\n      {\n#if JERRY_DEBUGGER\n        if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n            && ident_line_counter != context_p->last_breakpoint_line)\n        {\n          parser_emit_cbc (context_p, CBC_BREAKPOINT_DISABLED);\n          parser_flush_cbc (context_p);\n\n          parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST, ident_line_counter);\n\n          context_p->last_breakpoint_line = ident_line_counter;\n        }\n#endif /* JERRY_DEBUGGER */\n\n#if JERRY_LINE_INFO\n        parser_line_info_append (context_p, ident_line_counter, ident_column_counter);\n#endif /* JERRY_LINE_INFO */\n\n        uint16_t index = context_p->lit_object.index;\n\n        lexer_next_token (context_p);\n        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);\n\n        cbc_opcode_t opcode = CBC_ASSIGN_SET_IDENT;\n\n#if JERRY_ESNEXT\n        uint16_t function_literal_index = parser_check_anonymous_function_declaration (context_p);\n\n        if (function_literal_index == PARSER_ANONYMOUS_CLASS)\n        {\n          uint16_t name_index = scanner_save_literal (context_p, index);\n          parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_CLASS_NAME, name_index);\n        }\n        else if (function_literal_index < PARSER_NAMED_FUNCTION)\n        {\n          parser_set_function_name (context_p, function_literal_index, index, 0);\n        }\n\n        if (declaration_type != LEXER_KEYW_VAR\n            && (index < PARSER_REGISTER_START))\n        {\n          opcode = CBC_INIT_LET;\n\n          if (scanner_literal_is_created (context_p, index))\n          {\n            opcode = CBC_ASSIGN_LET_CONST;\n          }\n          else if (declaration_type == LEXER_KEYW_CONST)\n          {\n            opcode = CBC_INIT_CONST;\n          }\n        }\n#endif /* JERRY_ESNEXT */\n\n        parser_emit_cbc_literal (context_p, (uint16_t) opcode, index);\n      }\n#if JERRY_ESNEXT\n      else if (declaration_type == LEXER_KEYW_LET)\n      {\n        parser_emit_cbc (context_p, CBC_PUSH_UNDEFINED);\n\n        uint16_t index = context_p->lit_object.index;\n        cbc_opcode_t opcode = CBC_MOV_IDENT;\n\n        if (index < PARSER_REGISTER_START)\n        {\n          opcode = (scanner_literal_is_created (context_p, index) ? CBC_ASSIGN_LET_CONST\n                                                                  : CBC_INIT_LET);\n        }\n\n        parser_emit_cbc_literal (context_p, (uint16_t) opcode, index);\n      }\n      else if (declaration_type == LEXER_KEYW_CONST)\n      {\n        parser_raise_error (context_p, PARSER_ERR_MISSING_ASSIGN_AFTER_CONST);\n      }\n    }\n#endif /* JERRY_ESNEXT */\n\n    if (context_p->token.type != LEXER_COMMA)\n    {\n      break;\n    }\n  }\n\n#if JERRY_MODULE_SYSTEM\n  context_p->status_flags &= (uint32_t) ~(PARSER_MODULE_STORE_IDENT);\n#endif /* JERRY_MODULE_SYSTEM */\n}",
        "begin_line": 444,
        "end_line": 601,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_emit_cbc#289",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_emit_cbc (parser_context_t *context_p, /**< context */                  uint16_t opcode) /**< opcode */",
        "snippet": "void\nparser_emit_cbc (parser_context_t *context_p, /**< context */\n                 uint16_t opcode) /**< opcode */\n{\n  JERRY_ASSERT (PARSER_ARGS_EQ (opcode, 0));\n\n  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)\n  {\n    parser_flush_cbc (context_p);\n  }\n\n  context_p->last_cbc_opcode = opcode;\n}",
        "begin_line": 289,
        "end_line": 301,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_backward_branch#561",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_backward_branch (parser_context_t *context_p, /**< context */                                  uint16_t opcode, /**< opcode */                                  uint32_t offset) /**< destination offset */",
        "snippet": "void\nparser_emit_cbc_backward_branch (parser_context_t *context_p, /**< context */\n                                 uint16_t opcode, /**< opcode */\n                                 uint32_t offset) /**< destination offset */\n{\n  uint8_t flags;\n#if JERRY_PARSER_DUMP_BYTE_CODE\n  const char *name;\n#endif /* JERRY_PARSER_DUMP_BYTE_CODE */\n\n  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)\n  {\n    parser_flush_cbc (context_p);\n  }\n\n  context_p->status_flags |= PARSER_NO_END_LABEL;\n  offset = context_p->byte_code_size - offset;\n\n  if (PARSER_IS_BASIC_OPCODE (opcode))\n  {\n    JERRY_ASSERT (opcode < CBC_END);\n    flags = cbc_flags[opcode];\n\n#if JERRY_PARSER_DUMP_BYTE_CODE\n    name = cbc_names[opcode];\n#endif /* JERRY_PARSER_DUMP_BYTE_CODE */\n  }\n  else\n  {\n    PARSER_APPEND_TO_BYTE_CODE (context_p, CBC_EXT_OPCODE);\n    opcode = (uint16_t) PARSER_GET_EXT_OPCODE (opcode);\n\n    JERRY_ASSERT (opcode < CBC_EXT_END);\n    flags = cbc_ext_flags[opcode];\n    context_p->byte_code_size++;\n\n#if JERRY_PARSER_DUMP_BYTE_CODE\n    name = cbc_ext_names[opcode];\n#endif /* JERRY_PARSER_DUMP_BYTE_CODE */\n  }\n\n  JERRY_ASSERT (flags & CBC_HAS_BRANCH_ARG);\n  JERRY_ASSERT (CBC_BRANCH_IS_BACKWARD (flags));\n  JERRY_ASSERT (CBC_BRANCH_OFFSET_LENGTH (opcode) == 1);\n  JERRY_ASSERT (offset <= context_p->byte_code_size);\n\n  /* Branch opcodes never push anything onto the stack. */\n  JERRY_ASSERT ((flags >> CBC_STACK_ADJUST_SHIFT) >= CBC_STACK_ADJUST_BASE\n                 || (CBC_STACK_ADJUST_BASE - (flags >> CBC_STACK_ADJUST_SHIFT)) <= context_p->stack_depth);\n  PARSER_PLUS_EQUAL_U16 (context_p->stack_depth, CBC_STACK_ADJUST_VALUE (flags));\n\n#if JERRY_PARSER_DUMP_BYTE_CODE\n  if (context_p->is_show_opcodes)\n  {\n    JERRY_DEBUG_MSG (\"  [%3d] %s\\n\", (int) context_p->stack_depth, name);\n  }\n#endif /* JERRY_PARSER_DUMP_BYTE_CODE */\n\n  context_p->byte_code_size += 2;\n#if PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX\n  if (offset > UINT16_MAX)\n  {\n    opcode++;\n    context_p->byte_code_size++;\n  }\n#endif /* PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX */\n\n  if (offset > UINT8_MAX)\n  {\n    opcode++;\n    context_p->byte_code_size++;\n  }\n\n  PARSER_APPEND_TO_BYTE_CODE (context_p, (uint8_t) opcode);\n\n#if PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX\n  if (offset > UINT16_MAX)\n  {\n    PARSER_APPEND_TO_BYTE_CODE (context_p, offset >> 16);\n  }\n#endif /* PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX */\n\n  if (offset > UINT8_MAX)\n  {\n    PARSER_APPEND_TO_BYTE_CODE (context_p, (offset >> 8) & 0xff);\n  }\n\n  PARSER_APPEND_TO_BYTE_CODE (context_p, offset & 0xff);\n}",
        "begin_line": 561,
        "end_line": 649,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_forward_branch#460",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_forward_branch (parser_context_t *context_p, /**< context */                                 uint16_t opcode, /**< opcode */                                 parser_branch_t *branch_p) /**< branch result */",
        "snippet": "void\nparser_emit_cbc_forward_branch (parser_context_t *context_p, /**< context */\n                                uint16_t opcode, /**< opcode */\n                                parser_branch_t *branch_p) /**< branch result */\n{\n  uint8_t flags;\n  uint32_t extra_byte_code_increase;\n\n  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)\n  {\n    parser_flush_cbc (context_p);\n  }\n\n  context_p->status_flags |= PARSER_NO_END_LABEL;\n\n  if (PARSER_IS_BASIC_OPCODE (opcode))\n  {\n    JERRY_ASSERT (opcode < CBC_END);\n    flags = cbc_flags[opcode];\n    extra_byte_code_increase = 0;\n  }\n  else\n  {\n    PARSER_APPEND_TO_BYTE_CODE (context_p, CBC_EXT_OPCODE);\n    opcode = (uint16_t) PARSER_GET_EXT_OPCODE (opcode);\n\n    JERRY_ASSERT (opcode < CBC_EXT_END);\n    flags = cbc_ext_flags[opcode];\n    extra_byte_code_increase = 1;\n  }\n\n  JERRY_ASSERT (flags & CBC_HAS_BRANCH_ARG);\n  JERRY_ASSERT (CBC_BRANCH_IS_FORWARD (flags));\n  JERRY_ASSERT (CBC_BRANCH_OFFSET_LENGTH (opcode) == 1);\n\n  /* Branch opcodes never push anything onto the stack. */\n  JERRY_ASSERT ((flags >> CBC_STACK_ADJUST_SHIFT) >= CBC_STACK_ADJUST_BASE\n                 || (CBC_STACK_ADJUST_BASE - (flags >> CBC_STACK_ADJUST_SHIFT)) <= context_p->stack_depth);\n  PARSER_PLUS_EQUAL_U16 (context_p->stack_depth, CBC_STACK_ADJUST_VALUE (flags));\n\n#if JERRY_PARSER_DUMP_BYTE_CODE\n  if (context_p->is_show_opcodes)\n  {\n    JERRY_DEBUG_MSG (\"  [%3d] %s\\n\",\n                     (int) context_p->stack_depth,\n                     extra_byte_code_increase == 0 ? cbc_names[opcode] : cbc_ext_names[opcode]);\n  }\n#endif /* JERRY_PARSER_DUMP_BYTE_CODE */\n\n  PARSER_PLUS_EQUAL_U16 (opcode, PARSER_MAX_BRANCH_LENGTH - 1);\n\n  parser_emit_two_bytes (context_p, (uint8_t) opcode, 0);\n  branch_p->page_p = context_p->byte_code.last_p;\n  branch_p->offset = (context_p->byte_code.last_position - 1) | (context_p->byte_code_size << 8);\n\n  context_p->byte_code_size += extra_byte_code_increase;\n\n#if PARSER_MAXIMUM_CODE_SIZE <= UINT16_MAX\n  PARSER_APPEND_TO_BYTE_CODE (context_p, 0);\n#else /* PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX */\n  parser_emit_two_bytes (context_p, 0, 0);\n#endif /* PARSER_MAXIMUM_CODE_SIZE <= UINT16_MAX */\n\n  context_p->byte_code_size += PARSER_MAX_BRANCH_LENGTH + 1;\n\n  if (context_p->stack_depth > context_p->stack_limit)\n  {\n    context_p->stack_limit = context_p->stack_depth;\n    if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)\n    {\n      parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);\n    }\n  }\n}",
        "begin_line": 460,
        "end_line": 533,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_literal#306",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_literal (parser_context_t *context_p, /**< context */                          uint16_t opcode, /**< opcode */                          uint16_t literal_index) /**< literal index */",
        "snippet": "void\nparser_emit_cbc_literal (parser_context_t *context_p, /**< context */\n                         uint16_t opcode, /**< opcode */\n                         uint16_t literal_index) /**< literal index */\n{\n  JERRY_ASSERT (PARSER_ARGS_EQ (opcode, CBC_HAS_LITERAL_ARG));\n\n  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)\n  {\n    parser_flush_cbc (context_p);\n  }\n\n  context_p->last_cbc_opcode = opcode;\n  context_p->last_cbc.literal_index = literal_index;\n  context_p->last_cbc.literal_type = LEXER_UNUSED_LITERAL;\n  context_p->last_cbc.literal_keyword_type = LEXER_EOS;\n}",
        "begin_line": 306,
        "end_line": 322,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_literal_from_token#350",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_literal_from_token (parser_context_t *context_p, /**< context */                                     uint16_t opcode) /**< opcode */",
        "snippet": "void\nparser_emit_cbc_literal_from_token (parser_context_t *context_p, /**< context */\n                                    uint16_t opcode) /**< opcode */\n{\n  JERRY_ASSERT (PARSER_ARGS_EQ (opcode, CBC_HAS_LITERAL_ARG));\n\n  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)\n  {\n    parser_flush_cbc (context_p);\n  }\n\n  context_p->last_cbc_opcode = opcode;\n  context_p->last_cbc.literal_index = context_p->lit_object.index;\n  context_p->last_cbc.literal_type = context_p->token.lit_location.type;\n  context_p->last_cbc.literal_keyword_type = context_p->token.keyword_type;\n}",
        "begin_line": 350,
        "end_line": 365,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_push_number#390",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_emit_cbc_push_number (parser_context_t *context_p, /**< context */                              bool is_negative_number) /**< sign is negative */",
        "snippet": "void\nparser_emit_cbc_push_number (parser_context_t *context_p, /**< context */\n                             bool is_negative_number) /**< sign is negative */\n{\n  uint16_t value = context_p->lit_object.index;\n  uint16_t lit_value = PARSER_INVALID_LITERAL_INDEX;\n\n  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)\n  {\n    if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)\n    {\n      lit_value = context_p->last_cbc.literal_index;\n    }\n    else\n    {\n      if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)\n      {\n        context_p->last_cbc_opcode = CBC_PUSH_LITERAL;\n        lit_value = context_p->last_cbc.value;\n      }\n      else if (context_p->last_cbc_opcode == CBC_PUSH_THREE_LITERALS)\n      {\n        context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;\n        lit_value = context_p->last_cbc.third_literal_index;\n      }\n\n      parser_flush_cbc (context_p);\n    }\n  }\n\n  if (value == 0)\n  {\n    if (lit_value == PARSER_INVALID_LITERAL_INDEX)\n    {\n      context_p->last_cbc_opcode = CBC_PUSH_NUMBER_0;\n      return;\n    }\n\n    context_p->last_cbc_opcode = CBC_PUSH_LITERAL_PUSH_NUMBER_0;\n    context_p->last_cbc.literal_index = lit_value;\n    return;\n  }\n\n  uint16_t opcode;\n\n  if (lit_value == PARSER_INVALID_LITERAL_INDEX)\n  {\n    opcode = (is_negative_number ? CBC_PUSH_NUMBER_NEG_BYTE\n                                 : CBC_PUSH_NUMBER_POS_BYTE);\n\n    JERRY_ASSERT (CBC_STACK_ADJUST_VALUE (PARSER_GET_FLAGS (opcode)) == 1);\n  }\n  else\n  {\n    opcode = (is_negative_number ? CBC_PUSH_LITERAL_PUSH_NUMBER_NEG_BYTE\n                                 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE);\n    JERRY_ASSERT (CBC_STACK_ADJUST_VALUE (PARSER_GET_FLAGS (opcode)) == 2);\n\n    context_p->last_cbc.literal_index = lit_value;\n  }\n\n  JERRY_ASSERT (value > 0 && value <= CBC_PUSH_NUMBER_BYTE_RANGE_END);\n\n  context_p->last_cbc_opcode = opcode;\n  context_p->last_cbc.value = (uint16_t) (value - 1);\n}",
        "begin_line": 390,
        "end_line": 455,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_emit_two_bytes#42",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_emit_two_bytes (parser_context_t *context_p, /**< context */                        uint8_t first_byte, /**< first byte */                        uint8_t second_byte) /**< second byte */",
        "snippet": "static void\nparser_emit_two_bytes (parser_context_t *context_p, /**< context */\n                       uint8_t first_byte, /**< first byte */\n                       uint8_t second_byte) /**< second byte */\n{\n  uint32_t last_position = context_p->byte_code.last_position;\n\n  if (last_position + 2 <= PARSER_CBC_STREAM_PAGE_SIZE)\n  {\n    parser_mem_page_t *page_p = context_p->byte_code.last_p;\n\n    page_p->bytes[last_position] = first_byte;\n    page_p->bytes[last_position + 1] = second_byte;\n    context_p->byte_code.last_position = last_position + 2;\n  }\n  else if (last_position >= PARSER_CBC_STREAM_PAGE_SIZE)\n  {\n    parser_mem_page_t *page_p;\n\n    parser_cbc_stream_alloc_page (context_p, &context_p->byte_code);\n    page_p = context_p->byte_code.last_p;\n    page_p->bytes[0] = first_byte;\n    page_p->bytes[1] = second_byte;\n    context_p->byte_code.last_position = 2;\n  }\n  else\n  {\n    context_p->byte_code.last_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] = first_byte;\n    parser_cbc_stream_alloc_page (context_p, &context_p->byte_code);\n    context_p->byte_code.last_p->bytes[0] = second_byte;\n    context_p->byte_code.last_position = 1;\n  }\n}",
        "begin_line": 42,
        "end_line": 74,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_flush_cbc#146",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_flush_cbc (parser_context_t *context_p) /**< context */",
        "snippet": "void\nparser_flush_cbc (parser_context_t *context_p) /**< context */\n{\n  uint8_t flags;\n  uint16_t last_opcode = context_p->last_cbc_opcode;\n\n  if (last_opcode == PARSER_CBC_UNAVAILABLE)\n  {\n    return;\n  }\n\n  context_p->status_flags |= PARSER_NO_END_LABEL;\n\n  if (PARSER_IS_BASIC_OPCODE (last_opcode))\n  {\n    cbc_opcode_t opcode = (cbc_opcode_t) last_opcode;\n\n    JERRY_ASSERT (opcode < CBC_END);\n    flags = cbc_flags[opcode];\n\n    PARSER_APPEND_TO_BYTE_CODE (context_p, opcode);\n    context_p->byte_code_size++;\n  }\n  else\n  {\n    cbc_ext_opcode_t opcode = (cbc_ext_opcode_t) PARSER_GET_EXT_OPCODE (last_opcode);\n\n    JERRY_ASSERT (opcode < CBC_EXT_END);\n    flags = cbc_ext_flags[opcode];\n    parser_emit_two_bytes (context_p, CBC_EXT_OPCODE, (uint8_t) opcode);\n    context_p->byte_code_size += 2;\n  }\n\n  JERRY_ASSERT ((flags >> CBC_STACK_ADJUST_SHIFT) >= CBC_STACK_ADJUST_BASE\n                 || (CBC_STACK_ADJUST_BASE - (flags >> CBC_STACK_ADJUST_SHIFT)) <= context_p->stack_depth);\n  PARSER_PLUS_EQUAL_U16 (context_p->stack_depth, CBC_STACK_ADJUST_VALUE (flags));\n\n  if (flags & (CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2))\n  {\n    uint16_t literal_index = context_p->last_cbc.literal_index;\n\n    parser_emit_two_bytes (context_p,\n                           (uint8_t) (literal_index & 0xff),\n                           (uint8_t) (literal_index >> 8));\n    context_p->byte_code_size += 2;\n  }\n\n  if (flags & CBC_HAS_LITERAL_ARG2)\n  {\n    uint16_t literal_index = context_p->last_cbc.value;\n\n    parser_emit_two_bytes (context_p,\n                           (uint8_t) (literal_index & 0xff),\n                           (uint8_t) (literal_index >> 8));\n    context_p->byte_code_size += 2;\n\n    if (!(flags & CBC_HAS_LITERAL_ARG))\n    {\n      literal_index = context_p->last_cbc.third_literal_index;\n\n      parser_emit_two_bytes (context_p,\n                             (uint8_t) (literal_index & 0xff),\n                             (uint8_t) (literal_index >> 8));\n      context_p->byte_code_size += 2;\n    }\n  }\n\n  if (flags & CBC_HAS_BYTE_ARG)\n  {\n    uint8_t byte_argument = (uint8_t) context_p->last_cbc.value;\n\n    JERRY_ASSERT (context_p->last_cbc.value <= CBC_MAXIMUM_BYTE_VALUE);\n\n    if (flags & CBC_POP_STACK_BYTE_ARG)\n    {\n      JERRY_ASSERT (context_p->stack_depth >= byte_argument);\n      PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, byte_argument);\n    }\n\n    PARSER_APPEND_TO_BYTE_CODE (context_p, byte_argument);\n    context_p->byte_code_size++;\n  }\n\n#if JERRY_PARSER_DUMP_BYTE_CODE\n  if (context_p->is_show_opcodes)\n  {\n    JERRY_DEBUG_MSG (\"  [%3d] %s\",\n                     (int) context_p->stack_depth,\n                     PARSER_IS_BASIC_OPCODE (last_opcode) ? cbc_names[last_opcode]\n                                                          : cbc_ext_names[PARSER_GET_EXT_OPCODE (last_opcode)]);\n\n    if (flags & (CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2))\n    {\n      parser_print_literal (context_p, context_p->last_cbc.literal_index);\n    }\n\n    if (flags & CBC_HAS_LITERAL_ARG2)\n    {\n      parser_print_literal (context_p, context_p->last_cbc.value);\n\n      if (!(flags & CBC_HAS_LITERAL_ARG))\n      {\n        parser_print_literal (context_p, context_p->last_cbc.third_literal_index);\n      }\n    }\n\n    if (flags & CBC_HAS_BYTE_ARG)\n    {\n      if (last_opcode == CBC_PUSH_NUMBER_POS_BYTE\n          || last_opcode == CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE)\n      {\n        JERRY_DEBUG_MSG (\" number:%d\", (int) context_p->last_cbc.value + 1);\n      }\n      else if (last_opcode == CBC_PUSH_NUMBER_NEG_BYTE\n               || last_opcode == CBC_PUSH_LITERAL_PUSH_NUMBER_NEG_BYTE)\n      {\n        JERRY_DEBUG_MSG (\" number:%d\", -((int) context_p->last_cbc.value + 1));\n      }\n      else\n      {\n        JERRY_DEBUG_MSG (\" byte_arg:%d\", (int) context_p->last_cbc.value);\n      }\n    }\n\n    JERRY_DEBUG_MSG (\"\\n\");\n  }\n#endif /* JERRY_PARSER_DUMP_BYTE_CODE */\n\n  if (context_p->stack_depth > context_p->stack_limit)\n  {\n    context_p->stack_limit = context_p->stack_depth;\n    if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)\n    {\n      parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);\n    }\n  }\n\n  context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n}",
        "begin_line": 146,
        "end_line": 284,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_set_branch_to_current_position#681",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_set_branch_to_current_position (parser_context_t *context_p, /**< context */                                        parser_branch_t *branch_p) /**< branch result */",
        "snippet": "void\nparser_set_branch_to_current_position (parser_context_t *context_p, /**< context */\n                                       parser_branch_t *branch_p) /**< branch result */\n{\n  uint32_t delta;\n  size_t offset;\n  parser_mem_page_t *page_p = branch_p->page_p;\n\n  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)\n  {\n    parser_flush_cbc (context_p);\n  }\n\n  context_p->status_flags &= (uint32_t) ~PARSER_NO_END_LABEL;\n\n  JERRY_ASSERT (context_p->byte_code_size > (branch_p->offset >> 8));\n\n  delta = context_p->byte_code_size - (branch_p->offset >> 8);\n  offset = (branch_p->offset & CBC_LOWER_SEVEN_BIT_MASK);\n\n  JERRY_ASSERT (delta <= PARSER_MAXIMUM_CODE_SIZE);\n\n#if PARSER_MAXIMUM_CODE_SIZE <= UINT16_MAX\n  page_p->bytes[offset++] = (uint8_t) (delta >> 8);\n  if (offset >= PARSER_CBC_STREAM_PAGE_SIZE)\n  {\n    page_p = page_p->next_p;\n    offset = 0;\n  }\n#else /* PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX */\n  page_p->bytes[offset++] = (uint8_t) (delta >> 16);\n  if (offset >= PARSER_CBC_STREAM_PAGE_SIZE)\n  {\n    page_p = page_p->next_p;\n    offset = 0;\n  }\n  page_p->bytes[offset++] = (uint8_t) ((delta >> 8) & 0xff);\n  if (offset >= PARSER_CBC_STREAM_PAGE_SIZE)\n  {\n    page_p = page_p->next_p;\n    offset = 0;\n  }\n#endif /* PARSER_MAXIMUM_CODE_SIZE <= UINT16_MAX */\n  page_p->bytes[offset] = delta & 0xff;\n}",
        "begin_line": 681,
        "end_line": 725,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_set_breaks_to_current_position#730",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_set_breaks_to_current_position (parser_context_t *context_p, /**< context */                                        parser_branch_node_t *current_p) /**< branch list */",
        "snippet": "void\nparser_set_breaks_to_current_position (parser_context_t *context_p, /**< context */\n                                       parser_branch_node_t *current_p) /**< branch list */\n{\n  while (current_p != NULL)\n  {\n    parser_branch_node_t *next_p = current_p->next_p;\n\n    if (!(current_p->branch.offset & CBC_HIGHEST_BIT_MASK))\n    {\n      parser_set_branch_to_current_position (context_p, &current_p->branch);\n    }\n    parser_free (current_p, sizeof (parser_branch_node_t));\n    current_p = next_p;\n  }\n}",
        "begin_line": 730,
        "end_line": 745,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser-util.parser_set_continues_to_current_position#750",
        "src_path": "jerry-core/parser/js/js-parser-util.c",
        "class_name": "jerry-core.parser.js.js-parser-util",
        "signature": "jerry-core.parser.js.js-parser-util.parser_set_continues_to_current_position (parser_context_t *context_p, /**< context */                                           parser_branch_node_t *current_p) /**< branch list */",
        "snippet": "void\nparser_set_continues_to_current_position (parser_context_t *context_p, /**< context */\n                                          parser_branch_node_t *current_p) /**< branch list */\n{\n  while (current_p != NULL)\n  {\n    if (current_p->branch.offset & CBC_HIGHEST_BIT_MASK)\n    {\n      parser_set_branch_to_current_position (context_p, &current_p->branch);\n    }\n    current_p = current_p->next_p;\n  }\n}",
        "begin_line": 750,
        "end_line": 762,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parse_update_branches#364",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parse_update_branches (parser_context_t *context_p, /**< context */                        uint8_t *byte_code_p) /**< byte code */",
        "snippet": "static void\nparse_update_branches (parser_context_t *context_p, /**< context */\n                       uint8_t *byte_code_p) /**< byte code */\n{\n  parser_mem_page_t *page_p = context_p->byte_code.first_p;\n  parser_mem_page_t *prev_page_p = NULL;\n  parser_mem_page_t *last_page_p = context_p->byte_code.last_p;\n  size_t last_position = context_p->byte_code.last_position;\n  size_t offset = 0;\n  size_t bytes_copied = 0;\n\n  if (last_position >= PARSER_CBC_STREAM_PAGE_SIZE)\n  {\n    last_page_p = NULL;\n    last_position = 0;\n  }\n\n  while (page_p != last_page_p || offset < last_position)\n  {\n    /* Branch instructions are marked to improve search speed. */\n    if (page_p->bytes[offset] & CBC_HIGHEST_BIT_MASK)\n    {\n      uint8_t *bytes_p = byte_code_p + bytes_copied;\n      uint8_t flags;\n      uint8_t bytes_copied_before_jump = 0;\n      size_t branch_argument_length;\n      size_t target_distance;\n      size_t length;\n\n      if (offset > 0)\n      {\n        bytes_copied_before_jump = page_p->bytes[offset - 1] & CBC_LOWER_SEVEN_BIT_MASK;\n      }\n      bytes_p += bytes_copied_before_jump;\n\n      if (*bytes_p == CBC_EXT_OPCODE)\n      {\n        bytes_p++;\n        flags = cbc_ext_flags[*bytes_p];\n      }\n      else\n      {\n        flags = cbc_flags[*bytes_p];\n      }\n\n      JERRY_ASSERT (flags & CBC_HAS_BRANCH_ARG);\n      branch_argument_length = CBC_BRANCH_OFFSET_LENGTH (*bytes_p);\n      bytes_p++;\n\n      /* Decoding target. */\n      length = branch_argument_length;\n      target_distance = 0;\n      do\n      {\n        target_distance = (target_distance << 8) | *bytes_p;\n        bytes_p++;\n      }\n      while (--length > 0);\n\n      if (CBC_BRANCH_IS_FORWARD (flags))\n      {\n        /* Branch target was not set. */\n        JERRY_ASSERT (target_distance > 0);\n\n        target_distance = parser_update_forward_branch (page_p,\n                                                        offset + target_distance,\n                                                        bytes_copied_before_jump);\n      }\n      else\n      {\n        if (target_distance < offset)\n        {\n          uint8_t bytes_copied_before_target = page_p->bytes[offset - target_distance - 1];\n          bytes_copied_before_target = bytes_copied_before_target & CBC_LOWER_SEVEN_BIT_MASK;\n\n          target_distance = (size_t) (bytes_copied_before_jump - bytes_copied_before_target);\n        }\n        else if (target_distance == offset)\n        {\n          target_distance = bytes_copied_before_jump;\n        }\n        else\n        {\n          target_distance = parser_update_backward_branch (prev_page_p,\n                                                           target_distance - offset,\n                                                           bytes_copied_before_jump);\n        }\n      }\n\n      /* Encoding target again. */\n      do\n      {\n        bytes_p--;\n        *bytes_p = (uint8_t) (target_distance & 0xff);\n        target_distance >>= 8;\n      }\n      while (--branch_argument_length > 0);\n    }\n\n    offset++;\n    if (offset >= PARSER_CBC_STREAM_PAGE_SIZE)\n    {\n      parser_mem_page_t *next_p = page_p->next_p;\n\n      /* We reverse the pages before the current page. */\n      page_p->next_p = prev_page_p;\n      prev_page_p = page_p;\n\n      bytes_copied += page_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] & CBC_LOWER_SEVEN_BIT_MASK;\n      page_p = next_p;\n      offset = 0;\n    }\n  }\n\n  /* After this point the pages of the byte code stream are\n   * not used anymore. However, they needs to be freed during\n   * cleanup, so the first and last pointers of the stream\n   * descriptor are reversed as well. */\n  if (last_page_p != NULL)\n  {\n    JERRY_ASSERT (last_page_p == context_p->byte_code.last_p);\n    last_page_p->next_p = prev_page_p;\n  }\n  else\n  {\n    last_page_p = context_p->byte_code.last_p;\n  }\n\n  context_p->byte_code.last_p = context_p->byte_code.first_p;\n  context_p->byte_code.first_p = last_page_p;\n}",
        "begin_line": 364,
        "end_line": 494,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_check_anonymous_function_declaration#2937",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_check_anonymous_function_declaration (parser_context_t *context_p) /**< context */",
        "snippet": "uint16_t\nparser_check_anonymous_function_declaration (parser_context_t *context_p) /**< context */\n{\n  if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_FINALIZE_ANONYMOUS_CLASS))\n  {\n    return PARSER_ANONYMOUS_CLASS;\n  }\n\n  if (context_p->last_cbc.literal_type != LEXER_FUNCTION_LITERAL)\n  {\n    return PARSER_NOT_FUNCTION_LITERAL;\n  }\n\n  uint16_t literal_index = PARSER_NOT_FUNCTION_LITERAL;\n\n  if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)\n  {\n    literal_index = context_p->last_cbc.literal_index;\n  }\n  else if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)\n  {\n    literal_index = context_p->last_cbc.value;\n  }\n  else if (context_p->last_cbc_opcode == CBC_PUSH_THREE_LITERALS)\n  {\n    literal_index = context_p->last_cbc.third_literal_index;\n  }\n  else\n  {\n    return PARSER_NOT_FUNCTION_LITERAL;\n  }\n\n  const ecma_compiled_code_t *bytecode_p;\n  bytecode_p = (const ecma_compiled_code_t *) (PARSER_GET_LITERAL (literal_index)->u.bytecode_p);\n  bool is_anon = ecma_is_value_magic_string (*ecma_compiled_code_resolve_function_name (bytecode_p),\n                                             LIT_MAGIC_STRING__EMPTY);\n\n  return (is_anon ? literal_index : PARSER_NAMED_FUNCTION);\n}",
        "begin_line": 2937,
        "end_line": 2975,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_compiled_code_set_function_name#2997",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_compiled_code_set_function_name (parser_context_t *context_p, /**< context */                                         ecma_compiled_code_t *bytecode_p, /**< function literal index */                                         uint16_t name_index, /**< function name literal index */                                         uint32_t status_flags) /**< status flags */",
        "snippet": "void\nparser_compiled_code_set_function_name (parser_context_t *context_p, /**< context */\n                                        ecma_compiled_code_t *bytecode_p, /**< function literal index */\n                                        uint16_t name_index, /**< function name literal index */\n                                        uint32_t status_flags) /**< status flags */\n{\n  ecma_value_t *func_name_start_p;\n  func_name_start_p = ecma_compiled_code_resolve_function_name ((const ecma_compiled_code_t *) bytecode_p);\n\n  if (JERRY_UNLIKELY (!ecma_is_value_magic_string (*func_name_start_p, LIT_MAGIC_STRING__EMPTY)))\n  {\n    return;\n  }\n\n  parser_scope_stack_t *scope_stack_start_p = context_p->scope_stack_p;\n  parser_scope_stack_t *scope_stack_p = scope_stack_start_p + context_p->scope_stack_top;\n\n  while (scope_stack_p > scope_stack_start_p)\n  {\n    scope_stack_p--;\n\n    if (scope_stack_p->map_from != PARSER_SCOPE_STACK_FUNC\n        && scanner_decode_map_to (scope_stack_p) == name_index)\n    {\n      name_index = scope_stack_p->map_from;\n      break;\n    }\n  }\n\n  lexer_literal_t *name_lit_p = (lexer_literal_t *) PARSER_GET_LITERAL (name_index);\n\n  if (name_lit_p->type != LEXER_IDENT_LITERAL && name_lit_p->type != LEXER_STRING_LITERAL)\n  {\n    return;\n  }\n\n  uint8_t *name_buffer_p = (uint8_t *) name_lit_p->u.char_p;\n  uint32_t name_length = name_lit_p->prop.length;\n\n  if (status_flags & (PARSER_IS_PROPERTY_GETTER | PARSER_IS_PROPERTY_SETTER))\n  {\n    name_length += 4;\n    name_buffer_p = (uint8_t *) parser_malloc (context_p, name_length * sizeof (uint8_t));\n    char *prefix_p = (status_flags & PARSER_IS_PROPERTY_GETTER) ? \"get \" : \"set \";\n    memcpy (name_buffer_p, prefix_p, 4);\n    memcpy (name_buffer_p + 4, name_lit_p->u.char_p, name_lit_p->prop.length);\n  }\n\n  *func_name_start_p = ecma_find_or_create_literal_string (name_buffer_p,\n                                                           name_length,\n                                                           (status_flags & LEXER_FLAG_ASCII) != 0);\n\n  if (name_buffer_p != name_lit_p->u.char_p)\n  {\n    parser_free (name_buffer_p, name_length);\n  }\n}",
        "begin_line": 2997,
        "end_line": 3053,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_compute_indicies#55",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_compute_indicies (parser_context_t *context_p, /**< context */                          uint16_t *ident_end, /**< end of the identifier group */                          uint16_t *const_literal_end) /**< end of the const literal group */",
        "snippet": "static void\nparser_compute_indicies (parser_context_t *context_p, /**< context */\n                         uint16_t *ident_end, /**< end of the identifier group */\n                         uint16_t *const_literal_end) /**< end of the const literal group */\n{\n  parser_list_iterator_t literal_iterator;\n  lexer_literal_t *literal_p;\n\n  uint16_t ident_count = 0;\n  uint16_t const_literal_count = 0;\n\n  uint16_t ident_index;\n  uint16_t const_literal_index;\n  uint16_t literal_index;\n\n  /* First phase: count the number of items in each group. */\n  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))\n  {\n    switch (literal_p->type)\n    {\n      case LEXER_IDENT_LITERAL:\n      {\n        if (literal_p->status_flags & LEXER_FLAG_USED)\n        {\n          ident_count++;\n          break;\n        }\n        else if (!(literal_p->status_flags & LEXER_FLAG_SOURCE_PTR))\n        {\n          jmem_heap_free_block ((void *) literal_p->u.char_p, literal_p->prop.length);\n          /* This literal should not be freed even if an error is encountered later. */\n          literal_p->status_flags |= LEXER_FLAG_SOURCE_PTR;\n        }\n        continue;\n      }\n      case LEXER_STRING_LITERAL:\n      {\n        const_literal_count++;\n        break;\n      }\n      case LEXER_NUMBER_LITERAL:\n      {\n        const_literal_count++;\n        continue;\n      }\n      case LEXER_FUNCTION_LITERAL:\n      case LEXER_REGEXP_LITERAL:\n      {\n        continue;\n      }\n      default:\n      {\n        JERRY_ASSERT (literal_p->type == LEXER_UNUSED_LITERAL);\n        continue;\n      }\n    }\n\n    const uint8_t *char_p = literal_p->u.char_p;\n    uint32_t status_flags = context_p->status_flags;\n\n    if ((literal_p->status_flags & LEXER_FLAG_SOURCE_PTR)\n        && literal_p->prop.length < 0xfff)\n    {\n      size_t bytes_to_end = (size_t) (context_p->source_end_p - char_p);\n\n      if (bytes_to_end < 0xfffff)\n      {\n        literal_p->u.source_data = ((uint32_t) bytes_to_end) | (((uint32_t) literal_p->prop.length) << 20);\n        literal_p->status_flags |= LEXER_FLAG_LATE_INIT;\n        status_flags |= PARSER_HAS_LATE_LIT_INIT;\n        context_p->status_flags = status_flags;\n        char_p = NULL;\n      }\n    }\n\n    if (char_p != NULL)\n    {\n      literal_p->u.value = ecma_find_or_create_literal_string (char_p,\n                                                               literal_p->prop.length,\n                                                               (literal_p->status_flags & LEXER_FLAG_ASCII) != 0);\n\n      if (!(literal_p->status_flags & LEXER_FLAG_SOURCE_PTR))\n      {\n        jmem_heap_free_block ((void *) char_p, literal_p->prop.length);\n        /* This literal should not be freed even if an error is encountered later. */\n        literal_p->status_flags |= LEXER_FLAG_SOURCE_PTR;\n      }\n    }\n  }\n\n  ident_index = context_p->register_count;\n  const_literal_index = (uint16_t) (ident_index + ident_count);\n  literal_index = (uint16_t) (const_literal_index + const_literal_count);\n\n  /* Second phase: Assign an index to each literal. */\n  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n\n  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))\n  {\n    switch (literal_p->type)\n    {\n      case LEXER_IDENT_LITERAL:\n      {\n        if (literal_p->status_flags & LEXER_FLAG_USED)\n        {\n          literal_p->prop.index = ident_index;\n          ident_index++;\n        }\n        break;\n      }\n      case LEXER_STRING_LITERAL:\n      case LEXER_NUMBER_LITERAL:\n      {\n        JERRY_ASSERT ((literal_p->status_flags & ~(LEXER_FLAG_SOURCE_PTR | LEXER_FLAG_LATE_INIT)) == 0);\n        literal_p->prop.index = const_literal_index;\n        const_literal_index++;\n        break;\n      }\n      case LEXER_FUNCTION_LITERAL:\n      case LEXER_REGEXP_LITERAL:\n      {\n        JERRY_ASSERT (literal_p->status_flags == 0);\n\n        literal_p->prop.index = literal_index;\n        literal_index++;\n        break;\n      }\n      default:\n      {\n        JERRY_ASSERT (literal_p->type == LEXER_UNUSED_LITERAL\n                      && literal_p->status_flags == LEXER_FLAG_FUNCTION_ARGUMENT);\n        break;\n      }\n    }\n  }\n\n  JERRY_ASSERT (ident_index == context_p->register_count + ident_count);\n  JERRY_ASSERT (const_literal_index == ident_index + const_literal_count);\n  JERRY_ASSERT (literal_index <= context_p->register_count + context_p->literal_count);\n\n  context_p->literal_count = literal_index;\n\n  *ident_end = ident_index;\n  *const_literal_end = const_literal_index;\n}",
        "begin_line": 55,
        "end_line": 200,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_init_literal_pool#205",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_init_literal_pool (parser_context_t *context_p, /**< context */                           ecma_value_t *literal_pool_p) /**< start of literal pool */",
        "snippet": "static void\nparser_init_literal_pool (parser_context_t *context_p, /**< context */\n                          ecma_value_t *literal_pool_p) /**< start of literal pool */\n{\n  parser_list_iterator_t literal_iterator;\n  lexer_literal_t *literal_p;\n\n  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n\n  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))\n  {\n    switch (literal_p->type)\n    {\n      case LEXER_IDENT_LITERAL:\n      {\n        if (!(literal_p->status_flags & LEXER_FLAG_USED))\n        {\n          break;\n        }\n        /* FALLTHRU */\n      }\n      case LEXER_STRING_LITERAL:\n      {\n        ecma_value_t lit_value = literal_p->u.value;\n\n        JERRY_ASSERT (literal_p->prop.index >= context_p->register_count);\n        literal_pool_p[literal_p->prop.index] = lit_value;\n        break;\n      }\n      case LEXER_NUMBER_LITERAL:\n      {\n        JERRY_ASSERT (literal_p->prop.index >= context_p->register_count);\n\n        literal_pool_p[literal_p->prop.index] = literal_p->u.value;\n        break;\n      }\n      case LEXER_FUNCTION_LITERAL:\n      case LEXER_REGEXP_LITERAL:\n      {\n        JERRY_ASSERT (literal_p->prop.index >= context_p->register_count);\n\n        ECMA_SET_INTERNAL_VALUE_POINTER (literal_pool_p[literal_p->prop.index],\n                                         literal_p->u.bytecode_p);\n        break;\n      }\n      default:\n      {\n        JERRY_ASSERT (literal_p->type == LEXER_UNUSED_LITERAL);\n        break;\n      }\n    }\n  }\n}",
        "begin_line": 205,
        "end_line": 257,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_parse_function#2559",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_parse_function (parser_context_t *context_p, /**< context */                        uint32_t status_flags) /**< extra status flags */",
        "snippet": "ecma_compiled_code_t *\nparser_parse_function (parser_context_t *context_p, /**< context */\n                       uint32_t status_flags) /**< extra status flags */\n{\n  parser_saved_context_t saved_context;\n  ecma_compiled_code_t *compiled_code_p;\n\n  JERRY_ASSERT (status_flags & PARSER_IS_FUNCTION);\n  parser_save_context (context_p, &saved_context);\n  context_p->status_flags |= status_flags;\n#if JERRY_ESNEXT\n  context_p->status_flags |= PARSER_ALLOW_NEW_TARGET;\n#endif /* JERRY_ESNEXT */\n\n#if JERRY_PARSER_DUMP_BYTE_CODE\n  if (context_p->is_show_opcodes)\n  {\n#if JERRY_ESNEXT\n    JERRY_DEBUG_MSG (\"\\n--- %s parsing start ---\\n\\n\",\n                     (context_p->status_flags & PARSER_CLASS_CONSTRUCTOR) ? \"Class constructor\"\n                                                                          : \"Function\");\n#else /* !JERRY_ESNEXT */\n    JERRY_DEBUG_MSG (\"\\n--- Function parsing start ---\\n\\n\");\n#endif /* JERRY_ESNEXT */\n  }\n#endif /* JERRY_PARSER_DUMP_BYTE_CODE */\n\n#if JERRY_DEBUGGER\n  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n  {\n    jerry_debugger_send_parse_function (context_p->token.line, context_p->token.column);\n  }\n#endif /* JERRY_DEBUGGER */\n\n  lexer_next_token (context_p);\n\n  if (context_p->token.type != LEXER_LEFT_PAREN)\n  {\n    parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIST_EXPECTED);\n  }\n\n  lexer_next_token (context_p);\n\n  parser_parse_function_arguments (context_p, LEXER_RIGHT_PAREN);\n  lexer_next_token (context_p);\n\n  if ((context_p->status_flags & PARSER_IS_PROPERTY_GETTER)\n      && context_p->argument_count != 0)\n  {\n    parser_raise_error (context_p, PARSER_ERR_NO_ARGUMENTS_EXPECTED);\n  }\n\n  if ((context_p->status_flags & PARSER_IS_PROPERTY_SETTER)\n      && context_p->argument_count != 1)\n  {\n    parser_raise_error (context_p, PARSER_ERR_ONE_ARGUMENT_EXPECTED);\n  }\n\n#if JERRY_ESNEXT\n  if ((context_p->status_flags & (PARSER_CLASS_CONSTRUCTOR | PARSER_ALLOW_SUPER_CALL)) == PARSER_CLASS_CONSTRUCTOR)\n  {\n    parser_emit_cbc_ext (context_p, CBC_EXT_RUN_FIELD_INIT);\n    parser_flush_cbc (context_p);\n  }\n#endif /* JERRY_ESNEXT */\n\n#if JERRY_PARSER_DUMP_BYTE_CODE\n  if (context_p->is_show_opcodes\n      && (context_p->status_flags & PARSER_HAS_NON_STRICT_ARG))\n  {\n    JERRY_DEBUG_MSG (\"  Note: legacy (non-strict) argument definition\\n\\n\");\n  }\n#endif /* JERRY_PARSER_DUMP_BYTE_CODE */\n\n  if (context_p->token.type != LEXER_LEFT_BRACE)\n  {\n    parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_EXPECTED);\n  }\n\n  lexer_next_token (context_p);\n  parser_parse_statements (context_p);\n  compiled_code_p = parser_post_processing (context_p);\n\n#if JERRY_PARSER_DUMP_BYTE_CODE\n  if (context_p->is_show_opcodes)\n  {\n#if JERRY_ESNEXT\n    JERRY_DEBUG_MSG (\"\\n--- %s parsing end ---\\n\\n\",\n                     (context_p->status_flags & PARSER_CLASS_CONSTRUCTOR) ? \"Class constructor\"\n                                                                          : \"Function\");\n#else /* !JERRY_ESNEXT */\n    JERRY_DEBUG_MSG (\"\\n--- Function parsing end ---\\n\\n\");\n#endif /* JERRY_ESNEXT */\n  }\n#endif /* JERRY_PARSER_DUMP_BYTE_CODE */\n\n  parser_restore_context (context_p, &saved_context);\n\n  return compiled_code_p;\n}",
        "begin_line": 2559,
        "end_line": 2658,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_parse_function_arguments#1460",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_parse_function_arguments (parser_context_t *context_p, /**< context */                                  lexer_token_type_t end_type) /**< expected end type */",
        "snippet": "static void\nparser_parse_function_arguments (parser_context_t *context_p, /**< context */\n                                 lexer_token_type_t end_type) /**< expected end type */\n{\n  JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);\n\n#if JERRY_ESNEXT\n  JERRY_ASSERT (context_p->status_flags & PARSER_IS_FUNCTION);\n  JERRY_ASSERT (!(context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED));\n\n  bool has_duplicated_arg_names = false;\n\n  if (PARSER_IS_NORMAL_ASYNC_FUNCTION (context_p->status_flags))\n  {\n    parser_branch_t branch;\n    parser_emit_cbc_ext_forward_branch (context_p, CBC_EXT_TRY_CREATE_CONTEXT, &branch);\n    parser_stack_push (context_p, &branch, sizeof (parser_branch_t));\n\n#ifndef JERRY_NDEBUG\n    context_p->context_stack_depth = PARSER_TRY_CONTEXT_STACK_ALLOCATION;\n#endif /* !JERRY_NDEBUG */\n  }\n#endif /* JERRY_ESNEXT */\n\n  if (context_p->token.type == end_type)\n  {\n#if JERRY_ESNEXT\n    context_p->status_flags &= (uint32_t) ~PARSER_DISALLOW_AWAIT_YIELD;\n\n    if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)\n    {\n      scanner_create_variables (context_p, SCANNER_CREATE_VARS_IS_FUNCTION_ARGS);\n      parser_emit_cbc_ext (context_p, CBC_EXT_CREATE_GENERATOR);\n      parser_emit_cbc (context_p, CBC_POP);\n      scanner_create_variables (context_p, SCANNER_CREATE_VARS_IS_FUNCTION_BODY);\n      return;\n    }\n#endif /* JERRY_ESNEXT */\n    scanner_create_variables (context_p, SCANNER_CREATE_VARS_NO_OPTS);\n    return;\n  }\n\n#if JERRY_ESNEXT\n  bool has_complex_argument = (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_HAS_COMPLEX_ARGUMENT) != 0;\n#endif /* JERRY_ESNEXT */\n  bool is_strict = (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_IS_STRICT) != 0;\n\n  scanner_create_variables (context_p, SCANNER_CREATE_VARS_IS_FUNCTION_ARGS);\n  scanner_set_active (context_p);\n\n#if JERRY_ESNEXT\n  context_p->status_flags |= PARSER_FUNCTION_IS_PARSING_ARGS;\n#endif /* JERRY_ESNEXT */\n\n  while (true)\n  {\n#if JERRY_ESNEXT\n    if (context_p->token.type == LEXER_THREE_DOTS)\n    {\n      if (context_p->status_flags & PARSER_IS_PROPERTY_SETTER)\n      {\n        parser_raise_error (context_p, PARSER_ERR_SETTER_REST_PARAMETER);\n      }\n      lexer_next_token (context_p);\n\n      if (has_duplicated_arg_names)\n      {\n        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);\n      }\n\n      context_p->status_flags |= PARSER_FUNCTION_HAS_REST_PARAM | PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT;\n    }\n\n    if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)\n    {\n      if (has_duplicated_arg_names)\n      {\n        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);\n      }\n\n      context_p->status_flags |= PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT;\n\n      if (!(context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM))\n      {\n        parser_emit_cbc_literal (context_p,\n                                 CBC_PUSH_LITERAL,\n                                 (uint16_t) (PARSER_REGISTER_START + context_p->argument_count));\n      }\n      else\n      {\n        parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_REST_OBJECT);\n      }\n\n      uint32_t flags = (PARSER_PATTERN_BINDING\n                        | PARSER_PATTERN_TARGET_ON_STACK\n                        | PARSER_PATTERN_LOCAL\n                        | PARSER_PATTERN_ARGUMENTS);\n\n      if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n      {\n        if (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER)\n        {\n          if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)\n          {\n            flags |= PARSER_PATTERN_HAS_REST_ELEMENT;\n          }\n\n          if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)\n          {\n            parser_raise_error (context_p, PARSER_ERR_REST_PARAMETER_DEFAULT_INITIALIZER);\n          }\n\n          if (context_p->argument_length == UINT16_MAX)\n          {\n            context_p->argument_length = context_p->argument_count;\n          }\n\n          flags |= PARSER_PATTERN_TARGET_DEFAULT;\n        }\n        else if (context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS)\n        {\n          if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)\n          {\n            flags |= PARSER_PATTERN_HAS_REST_ELEMENT;\n          }\n          scanner_release_next (context_p, sizeof (scanner_info_t));\n        }\n        else\n        {\n          parser_raise_error (context_p, PARSER_ERR_INVALID_DESTRUCTURING_PATTERN);\n        }\n      }\n\n      parser_parse_initializer (context_p, flags);\n\n      context_p->argument_count++;\n      if (context_p->argument_count >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)\n      {\n        parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);\n      }\n\n      if (context_p->token.type != LEXER_COMMA)\n      {\n        if (context_p->token.type != end_type)\n        {\n          parser_error_t error = ((end_type == LEXER_RIGHT_PAREN) ? PARSER_ERR_RIGHT_PAREN_EXPECTED\n                                                                  : PARSER_ERR_IDENTIFIER_EXPECTED);\n\n          parser_raise_error (context_p, error);\n        }\n        break;\n      }\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type == end_type)\n      {\n        break;\n      }\n      continue;\n    }\n#endif /* JERRY_ESNEXT */\n\n    if (context_p->token.type != LEXER_LITERAL\n        || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n    {\n      parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);\n    }\n\n    lexer_construct_literal_object (context_p,\n                                    &context_p->token.lit_location,\n                                    LEXER_IDENT_LITERAL);\n\n    if (context_p->token.keyword_type >= LEXER_FIRST_NON_STRICT_ARGUMENTS)\n    {\n      context_p->status_flags |= PARSER_HAS_NON_STRICT_ARG;\n    }\n\n    if (JERRY_UNLIKELY (context_p->lit_object.literal_p->status_flags & LEXER_FLAG_FUNCTION_ARGUMENT))\n    {\n#if JERRY_ESNEXT\n      if ((context_p->status_flags & PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT)\n          || (context_p->status_flags & PARSER_IS_ARROW_FUNCTION))\n      {\n        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);\n      }\n      has_duplicated_arg_names = true;\n#endif /* JERRY_ESNEXT */\n\n      context_p->status_flags |= PARSER_HAS_NON_STRICT_ARG;\n    }\n    else\n    {\n      context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_FUNCTION_ARGUMENT;\n    }\n\n    lexer_next_token (context_p);\n\n#if JERRY_ESNEXT\n    uint16_t literal_index = context_p->lit_object.index;\n\n    if (context_p->token.type == LEXER_ASSIGN)\n    {\n      JERRY_ASSERT (has_complex_argument);\n\n      if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)\n      {\n        parser_raise_error (context_p, PARSER_ERR_REST_PARAMETER_DEFAULT_INITIALIZER);\n      }\n\n      if (context_p->argument_length == UINT16_MAX)\n      {\n        context_p->argument_length = context_p->argument_count;\n      }\n\n      parser_branch_t skip_init;\n\n      if (has_duplicated_arg_names)\n      {\n        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);\n      }\n\n      context_p->status_flags |= PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT;\n\n      /* LEXER_ASSIGN does not overwrite lit_object. */\n      parser_emit_cbc_literal (context_p,\n                               CBC_PUSH_LITERAL,\n                               (uint16_t) (PARSER_REGISTER_START + context_p->argument_count));\n      parser_emit_cbc_ext_forward_branch (context_p, CBC_EXT_DEFAULT_INITIALIZER, &skip_init);\n\n      lexer_next_token (context_p);\n      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);\n\n      parser_set_branch_to_current_position (context_p, &skip_init);\n\n      uint16_t opcode = CBC_ASSIGN_LET_CONST;\n\n      if (literal_index >= PARSER_REGISTER_START)\n      {\n        opcode = CBC_MOV_IDENT;\n      }\n      else if (!scanner_literal_is_created (context_p, literal_index))\n      {\n        opcode = CBC_INIT_ARG_OR_CATCH;\n      }\n\n      parser_emit_cbc_literal (context_p, opcode, literal_index);\n    }\n    else if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)\n    {\n      parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_REST_OBJECT);\n\n      uint16_t opcode = CBC_MOV_IDENT;\n\n      if (literal_index < PARSER_REGISTER_START)\n      {\n        opcode = CBC_INIT_ARG_OR_CATCH;\n\n        if (scanner_literal_is_created (context_p, literal_index))\n        {\n          opcode = CBC_ASSIGN_LET_CONST;\n        }\n      }\n\n      parser_emit_cbc_literal (context_p, opcode, literal_index);\n    }\n    else if (has_complex_argument && literal_index < PARSER_REGISTER_START)\n    {\n      uint16_t opcode = CBC_INIT_ARG_OR_FUNC;\n\n      if (scanner_literal_is_created (context_p, literal_index))\n      {\n        opcode = CBC_ASSIGN_LET_CONST_LITERAL;\n      }\n\n      parser_emit_cbc_literal_value (context_p,\n                                     opcode,\n                                     (uint16_t) (PARSER_REGISTER_START + context_p->argument_count),\n                                     literal_index);\n    }\n#endif /* JERRY_ESNEXT */\n\n    context_p->argument_count++;\n    if (context_p->argument_count >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)\n    {\n      parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);\n    }\n\n    if (context_p->token.type != LEXER_COMMA)\n    {\n      if (context_p->token.type != end_type)\n      {\n        parser_error_t error = ((end_type == LEXER_RIGHT_PAREN) ? PARSER_ERR_RIGHT_PAREN_EXPECTED\n                                                                : PARSER_ERR_IDENTIFIER_EXPECTED);\n\n        parser_raise_error (context_p, error);\n      }\n      break;\n    }\n\n#if JERRY_ESNEXT\n    if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)\n    {\n      parser_raise_error (context_p, PARSER_ERR_FORMAL_PARAM_AFTER_REST_PARAMETER);\n    }\n#endif /* JERRY_ESNEXT */\n\n    lexer_next_token (context_p);\n\n#if JERRY_ESNEXT\n    if (context_p->token.type == end_type)\n    {\n      break;\n    }\n#endif /* JERRY_ESNEXT */\n  }\n\n  scanner_revert_active (context_p);\n\n#if JERRY_ESNEXT\n  JERRY_ASSERT (has_complex_argument || !(context_p->status_flags & PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT));\n\n  if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)\n  {\n    parser_emit_cbc_ext (context_p, CBC_EXT_CREATE_GENERATOR);\n    parser_emit_cbc (context_p, CBC_POP);\n  }\n\n  if (context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED)\n  {\n    if ((context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_LEXICAL_ENV_NEEDED)\n        || scanner_is_context_needed (context_p, PARSER_CHECK_FUNCTION_CONTEXT))\n    {\n      context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;\n\n      parser_branch_t branch;\n      parser_emit_cbc_forward_branch (context_p, CBC_BLOCK_CREATE_CONTEXT, &branch);\n      parser_stack_push (context_p, &branch, sizeof (parser_branch_t));\n\n#ifndef JERRY_NDEBUG\n      PARSER_PLUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);\n#endif /* !JERRY_NDEBUG */\n    }\n    else\n    {\n      context_p->status_flags &= (uint32_t) ~PARSER_LEXICAL_BLOCK_NEEDED;\n    }\n  }\n\n  context_p->status_flags &= (uint32_t) ~(PARSER_DISALLOW_AWAIT_YIELD | PARSER_FUNCTION_IS_PARSING_ARGS);\n#endif /* JERRY_ESNEXT */\n\n  scanner_create_variables (context_p, SCANNER_CREATE_VARS_IS_FUNCTION_BODY);\n\n  if (is_strict)\n  {\n    context_p->status_flags |= PARSER_IS_STRICT;\n  }\n}",
        "begin_line": 1460,
        "end_line": 1818,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_parse_script#3135",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_parse_script (void *source_p, /**< source code */                      uint32_t parse_opts, /**< ecma_parse_opts_t option bits */                      const jerry_parse_options_t *options_p) /**< additional configuration options */",
        "snippet": "ecma_compiled_code_t *\nparser_parse_script (void *source_p, /**< source code */\n                     uint32_t parse_opts, /**< ecma_parse_opts_t option bits */\n                     const jerry_parse_options_t *options_p) /**< additional configuration options */\n{\n#if JERRY_PARSER\n  ecma_compiled_code_t *bytecode_p = parser_parse_source (source_p,\n                                                          parse_opts,\n                                                          options_p);\n\n  if (JERRY_UNLIKELY (bytecode_p == NULL))\n  {\n    /* Exception has already thrown. */\n    return NULL;\n  }\n\n#if JERRY_DEBUGGER\n  if ((JERRY_CONTEXT (debugger_flags) & (JERRY_DEBUGGER_CONNECTED | JERRY_DEBUGGER_PARSER_WAIT))\n      == (JERRY_DEBUGGER_CONNECTED | JERRY_DEBUGGER_PARSER_WAIT))\n  {\n    JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_PARSER_WAIT_MODE);\n    jerry_debugger_send_type (JERRY_DEBUGGER_WAITING_AFTER_PARSE);\n\n    while (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_PARSER_WAIT_MODE)\n    {\n      jerry_debugger_receive (NULL);\n\n      if (!(JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED))\n      {\n        break;\n      }\n\n      jerry_debugger_transport_sleep ();\n    }\n  }\n#endif /* JERRY_DEBUGGER */\n\n  return bytecode_p;\n#else /* !JERRY_PARSER */\n  JERRY_UNUSED (arg_list_p);\n  JERRY_UNUSED (arg_list_size);\n  JERRY_UNUSED (source_p);\n  JERRY_UNUSED (source_size);\n  JERRY_UNUSED (parse_opts);\n  JERRY_UNUSED (resource_name);\n\n  ecma_raise_syntax_error (ECMA_ERR_MSG (\"Source code parsing is disabled\"));\n  return NULL;\n#endif /* JERRY_PARSER */\n}",
        "begin_line": 3135,
        "end_line": 3184,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_parse_source#1832",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_parse_source (void *source_p, /**< source code */                      uint32_t parse_opts, /**< ecma_parse_opts_t option bits */                      const jerry_parse_options_t *options_p) /**< additional configuration options */",
        "snippet": "static ecma_compiled_code_t *\nparser_parse_source (void *source_p, /**< source code */\n                     uint32_t parse_opts, /**< ecma_parse_opts_t option bits */\n                     const jerry_parse_options_t *options_p) /**< additional configuration options */\n{\n  parser_context_t context;\n  ecma_compiled_code_t *compiled_code_p;\n\n  context.error = PARSER_ERR_NO_ERROR;\n  context.status_flags = parse_opts & PARSER_STRICT_MODE_MASK;\n  context.global_status_flags = parse_opts;\n\n#if JERRY_ESNEXT\n  context.status_flags |= PARSER_RESTORE_STATUS_FLAGS (parse_opts);\n  context.tagged_template_literal_cp = JMEM_CP_NULL;\n#endif /* JERRY_ESNEXT */\n\n  context.stack_depth = 0;\n  context.stack_limit = 0;\n  context.options_p = options_p;\n  context.script_p = NULL;\n  context.arguments_start_p = NULL;\n  context.arguments_size = 0;\n#if JERRY_MODULE_SYSTEM\n  if (context.global_status_flags & ECMA_PARSE_MODULE)\n  {\n    context.status_flags |= PARSER_IS_STRICT;\n  }\n\n  context.module_names_p = NULL;\n#endif /* JERRY_MODULE_SYSTEM */\n\n  context.argument_list = ECMA_VALUE_EMPTY;\n\n  if (context.options_p != NULL\n      && (context.options_p->options & JERRY_PARSE_HAS_ARGUMENT_LIST))\n  {\n    context.argument_list = context.options_p->argument_list;\n  }\n  else if (context.global_status_flags & ECMA_PARSE_HAS_ARGUMENT_LIST_VALUE)\n  {\n    JERRY_ASSERT (context.global_status_flags & ECMA_PARSE_HAS_SOURCE_VALUE);\n    context.argument_list = ((ecma_value_t *) source_p)[1];\n  }\n\n  if (context.argument_list != ECMA_VALUE_EMPTY)\n  {\n    JERRY_ASSERT (ecma_is_value_string (context.argument_list));\n\n    context.status_flags |= PARSER_IS_FUNCTION;\n#if JERRY_ESNEXT\n    if (parse_opts & ECMA_PARSE_GENERATOR_FUNCTION)\n    {\n      context.status_flags |= PARSER_IS_GENERATOR_FUNCTION;\n    }\n    if (parse_opts & ECMA_PARSE_ASYNC_FUNCTION)\n    {\n      context.status_flags |= PARSER_IS_ASYNC_FUNCTION;\n    }\n#endif /* JERRY_ESNEXT */\n\n    ecma_string_t *string_p = ecma_get_string_from_value (context.argument_list);\n    uint8_t flags = ECMA_STRING_FLAG_EMPTY;\n\n    context.arguments_start_p = ecma_string_get_chars (string_p, &context.arguments_size, NULL, NULL, &flags);\n\n    if (flags & ECMA_STRING_FLAG_MUST_BE_FREED)\n    {\n      context.global_status_flags |= ECMA_PARSE_INTERNAL_FREE_ARG_LIST;\n    }\n  }\n\n  if (!(context.global_status_flags & ECMA_PARSE_HAS_SOURCE_VALUE))\n  {\n    context.source_start_p = ((parser_source_char_t *) source_p)->source_p;\n    context.source_size = (lit_utf8_size_t) ((parser_source_char_t *) source_p)->source_size;\n  }\n  else\n  {\n    ecma_value_t source = ((ecma_value_t *) source_p)[0];\n\n    JERRY_ASSERT (ecma_is_value_string (source));\n\n    ecma_string_t *string_p = ecma_get_string_from_value (source);\n    uint8_t flags = ECMA_STRING_FLAG_EMPTY;\n\n    context.source_start_p = ecma_string_get_chars (string_p, &context.source_size, NULL, NULL, &flags);\n\n    if (flags & ECMA_STRING_FLAG_MUST_BE_FREED)\n    {\n      context.global_status_flags |= ECMA_PARSE_INTERNAL_FREE_SOURCE;\n    }\n  }\n\n#if JERRY_DEBUGGER\n  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n  {\n    jerry_debugger_send_string (JERRY_DEBUGGER_SOURCE_CODE,\n                                JERRY_DEBUGGER_NO_SUBTYPE,\n                                context.source_start_p,\n                                context.source_size);\n  }\n#endif /* JERRY_DEBUGGER */\n\n  context.user_value = ECMA_VALUE_EMPTY;\n\n  if ((context.global_status_flags & ECMA_PARSE_EVAL)\n      && JERRY_CONTEXT (vm_top_context_p) != NULL)\n  {\n    const ecma_compiled_code_t *bytecode_header_p = JERRY_CONTEXT (vm_top_context_p)->shared_p->bytecode_header_p;\n\n#if JERRY_SNAPSHOT_EXEC\n    if (JERRY_LIKELY (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))\n    {\n#endif /* JERRY_SNAPSHOT_EXEC */\n      ecma_value_t parent_script_value = ((cbc_uint8_arguments_t *) bytecode_header_p)->script_value;;\n      cbc_script_t *parent_script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, parent_script_value);\n\n      if (parent_script_p->refs_and_type & CBC_SCRIPT_HAS_USER_VALUE)\n      {\n        context.user_value = CBC_SCRIPT_GET_USER_VALUE (parent_script_p);\n      }\n#if JERRY_SNAPSHOT_EXEC\n    }\n#endif /* JERRY_SNAPSHOT_EXEC */\n  }\n  else if (context.options_p != NULL\n           && (context.options_p->options & JERRY_PARSE_HAS_USER_VALUE))\n  {\n    context.user_value = context.options_p->user_value;\n  }\n\n#if JERRY_RESOURCE_NAME\n  ecma_value_t resource_name = ecma_make_magic_string_value (LIT_MAGIC_STRING_RESOURCE_ANON);\n\n  if (context.options_p != NULL\n      && (context.options_p->options & JERRY_PARSE_HAS_RESOURCE))\n  {\n    JERRY_ASSERT (ecma_is_value_string (context.options_p->resource_name));\n\n    ecma_ref_ecma_string (ecma_get_string_from_value (context.options_p->resource_name));\n    resource_name = context.options_p->resource_name;\n  }\n  else if (context.global_status_flags & ECMA_PARSE_EVAL)\n  {\n    resource_name = ecma_make_magic_string_value (LIT_MAGIC_STRING_RESOURCE_EVAL);\n  }\n#endif /* JERRY_RESOURCE_NAME */\n\n  context.last_context_p = NULL;\n  context.last_statement.current_p = NULL;\n  context.token.flags = 0;\n  lexer_init_line_info (&context);\n\n  scanner_info_t scanner_info_end;\n  scanner_info_end.next_p = NULL;\n  scanner_info_end.source_p = NULL;\n  scanner_info_end.type = SCANNER_TYPE_END;\n  context.next_scanner_info_p = &scanner_info_end;\n  context.active_scanner_info_p = NULL;\n  context.skipped_scanner_info_p = NULL;\n  context.skipped_scanner_info_end_p = NULL;\n\n  context.last_cbc_opcode = PARSER_CBC_UNAVAILABLE;\n\n  context.argument_count = 0;\n#if JERRY_ESNEXT\n  context.argument_length = UINT16_MAX;\n#endif /* JERRY_ESNEXT */\n  context.register_count = 0;\n  context.literal_count = 0;\n\n  parser_cbc_stream_init (&context.byte_code);\n  context.byte_code_size = 0;\n  parser_list_init (&context.literal_pool,\n                    sizeof (lexer_literal_t),\n                    (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_literal_t)));\n  context.scope_stack_p = NULL;\n  context.scope_stack_size = 0;\n  context.scope_stack_top = 0;\n  context.scope_stack_reg_top = 0;\n#if JERRY_ESNEXT\n  context.scope_stack_global_end = 0;\n  context.tagged_template_literal_cp = JMEM_CP_NULL;\n#endif /* JERRY_ESNEXT */\n\n#ifndef JERRY_NDEBUG\n  context.context_stack_depth = 0;\n#endif /* !JERRY_NDEBUG */\n\n#if JERRY_LINE_INFO\n  context.line_info_p = NULL;\n#endif /* JERRY_LINE_INFO */\n\n#if JERRY_FUNCTION_TO_STRING\n  context.function_start_p = NULL;\n  context.function_end_p = NULL;\n#endif /* JERRY_FUNCTION_TO_STRING */\n\n#if JERRY_PARSER_DUMP_BYTE_CODE\n  context.is_show_opcodes = (JERRY_CONTEXT (jerry_init_flags) & JERRY_INIT_SHOW_OPCODES);\n  context.total_byte_code_size = 0;\n\n  if (context.is_show_opcodes)\n  {\n    JERRY_DEBUG_MSG (\"\\n--- %s parsing start ---\\n\\n\",\n                     (context.arguments_start_p == NULL) ? \"Script\"\n                                                         : \"Function\");\n  }\n#endif /* JERRY_PARSER_DUMP_BYTE_CODE */\n\n  scanner_scan_all (&context);\n\n  if (JERRY_UNLIKELY (context.error != PARSER_ERR_NO_ERROR))\n  {\n    JERRY_ASSERT (context.error == PARSER_ERR_OUT_OF_MEMORY);\n\n    /* It is unlikely that memory can be allocated in an out-of-memory\n     * situation. However, a simple value can still be thrown. */\n    jcontext_raise_exception (ECMA_VALUE_NULL);\n    return NULL;\n  }\n\n  size_t script_size = sizeof (cbc_script_t);\n\n  if (context.user_value != ECMA_VALUE_EMPTY)\n  {\n    script_size += sizeof (ecma_value_t);\n  }\n\n#if JERRY_FUNCTION_TO_STRING\n  if (context.argument_list != ECMA_VALUE_EMPTY)\n  {\n    script_size += sizeof (ecma_value_t);\n  }\n#endif /* JERRY_FUNCTION_TO_STRING */\n\n#if JERRY_MODULE_SYSTEM\n  if (context.global_status_flags & ECMA_PARSE_INTERNAL_HAS_IMPORT_META)\n  {\n    script_size += sizeof (ecma_value_t);\n  }\n#endif /* JERRY_MODULE_SYSTEM */\n\n  if (context.arguments_start_p == NULL)\n  {\n    context.source_p = context.source_start_p;\n    context.source_end_p = context.source_start_p + context.source_size;\n  }\n  else\n  {\n    context.source_p = context.arguments_start_p;\n    context.source_end_p = context.arguments_start_p + context.arguments_size;\n  }\n\n  context.u.allocated_buffer_p = NULL;\n  context.token.flags = 0;\n  lexer_init_line_info (&context);\n\n  parser_stack_init (&context);\n\n#if JERRY_DEBUGGER\n  context.breakpoint_info_count = 0;\n#endif /* JERRY_DEBUGGER */\n\n  JERRY_ASSERT (context.next_scanner_info_p->source_p == context.source_p);\n  JERRY_ASSERT (context.next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);\n\n  if (context.next_scanner_info_p->u8_arg & SCANNER_FUNCTION_IS_STRICT)\n  {\n    context.status_flags |= PARSER_IS_STRICT;\n  }\n\n  PARSER_TRY (context.try_buffer)\n  {\n    context.script_p = parser_malloc (&context, script_size);\n\n    CBC_SCRIPT_SET_TYPE (context.script_p, context.user_value, CBC_SCRIPT_REF_ONE);\n\n    if (context.global_status_flags & (ECMA_PARSE_EVAL | ECMA_PARSE_HAS_ARGUMENT_LIST_VALUE))\n    {\n      context.script_p->refs_and_type |= CBC_SCRIPT_IS_EVAL_CODE;\n    }\n\n#if JERRY_BUILTIN_REALMS\n    context.script_p->realm_p = (ecma_object_t *) JERRY_CONTEXT (global_object_p);\n#endif /* JERRY_BUILTIN_REALMS */\n\n#if JERRY_RESOURCE_NAME\n    context.script_p->resource_name = resource_name;\n#endif /* JERRY_RESOURCE_NAME */\n\n    ECMA_SET_INTERNAL_VALUE_POINTER (context.script_value, context.script_p);\n\n    /* Pushing a dummy value ensures the stack is never empty.\n     * This simplifies the stack management routines. */\n    parser_stack_push_uint8 (&context, CBC_MAXIMUM_BYTE_VALUE);\n    /* The next token must always be present to make decisions\n     * in the parser. Therefore when a token is consumed, the\n     * lexer_next_token() must be immediately called. */\n    lexer_next_token (&context);\n\n    if (context.arguments_start_p != NULL)\n    {\n      parser_parse_function_arguments (&context, LEXER_EOS);\n\n      JERRY_ASSERT (context.next_scanner_info_p->type == SCANNER_TYPE_END_ARGUMENTS);\n      scanner_release_next (&context, sizeof (scanner_info_t));\n\n      context.source_p = context.source_start_p;\n      context.source_end_p = context.source_start_p + context.source_size;\n      lexer_init_line_info (&context);\n\n      lexer_next_token (&context);\n    }\n#if JERRY_MODULE_SYSTEM\n    else if (parse_opts & ECMA_PARSE_MODULE)\n    {\n      parser_branch_t branch;\n      parser_emit_cbc_forward_branch (&context, CBC_JUMP_FORWARD, &branch);\n\n      scanner_create_variables (&context, SCANNER_CREATE_VARS_NO_OPTS);\n      parser_emit_cbc (&context, CBC_RETURN_WITH_BLOCK);\n\n      parser_set_branch_to_current_position (&context, &branch);\n    }\n#endif /* JERRY_MODULE_SYSTEM */\n    else\n    {\n      JERRY_ASSERT (context.next_scanner_info_p->source_p == context.source_start_p\n                    && context.next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);\n\n#if JERRY_ESNEXT\n      if (scanner_is_context_needed (&context, PARSER_CHECK_GLOBAL_CONTEXT))\n      {\n        context.status_flags |= PARSER_LEXICAL_BLOCK_NEEDED;\n      }\n\n      if (!(parse_opts & ECMA_PARSE_EVAL))\n      {\n        scanner_check_variables (&context);\n      }\n#endif /* JERRY_ESNEXT */\n\n      scanner_create_variables (&context, SCANNER_CREATE_VARS_IS_SCRIPT);\n    }\n\n    parser_parse_statements (&context);\n\n    JERRY_ASSERT (context.last_statement.current_p == NULL);\n\n    JERRY_ASSERT (context.last_cbc_opcode == PARSER_CBC_UNAVAILABLE);\n    JERRY_ASSERT (context.u.allocated_buffer_p == NULL);\n\n#ifndef JERRY_NDEBUG\n    JERRY_ASSERT (context.status_flags & PARSER_SCANNING_SUCCESSFUL);\n    JERRY_ASSERT (!(context.global_status_flags & ECMA_PARSE_INTERNAL_FOR_IN_OFF_CONTEXT_ERROR));\n    context.status_flags &= (uint32_t) ~PARSER_SCANNING_SUCCESSFUL;\n#endif /* !JERRY_NDEBUG */\n\n    JERRY_ASSERT (!(context.status_flags & PARSER_HAS_LATE_LIT_INIT));\n\n    compiled_code_p = parser_post_processing (&context);\n    parser_list_free (&context.literal_pool);\n\n    /* When parsing is successful, only the dummy value can be remained on the stack. */\n    JERRY_ASSERT (context.stack_top_uint8 == CBC_MAXIMUM_BYTE_VALUE\n                  && context.stack.last_position == 1\n                  && context.stack.first_p != NULL\n                  && context.stack.first_p->next_p == NULL\n                  && context.stack.last_p == NULL);\n\n    JERRY_ASSERT (context.arguments_start_p != NULL || !(context.status_flags & PARSER_ARGUMENTS_NEEDED));\n\n    context.script_p->refs_and_type -= CBC_SCRIPT_REF_ONE;\n\n    if (context.user_value != ECMA_VALUE_EMPTY)\n    {\n      CBC_SCRIPT_GET_USER_VALUE (context.script_p) = ecma_copy_value_if_not_object (context.user_value);\n    }\n\n#if JERRY_MODULE_SYSTEM\n    if (context.global_status_flags & ECMA_PARSE_INTERNAL_HAS_IMPORT_META)\n    {\n      int idx = (context.user_value != ECMA_VALUE_EMPTY) ? 1 : 0;\n      ecma_value_t module = ecma_make_object_value ((ecma_object_t *) JERRY_CONTEXT (module_current_p));\n\n      CBC_SCRIPT_GET_OPTIONAL_VALUES (context.script_p)[idx] = module;\n      context.script_p->refs_and_type |= CBC_SCRIPT_HAS_IMPORT_META;\n    }\n#endif /* JERRY_MODULE_SYSTEM */\n\n#if JERRY_FUNCTION_TO_STRING\n    if (!(context.global_status_flags & ECMA_PARSE_HAS_SOURCE_VALUE))\n    {\n      ecma_string_t *string_p;\n\n      if (context.global_status_flags & ECMA_PARSE_INTERNAL_HAS_4_BYTE_MARKER)\n      {\n        string_p = ecma_new_ecma_string_from_utf8_converted_to_cesu8 (context.source_start_p, context.source_size);\n      }\n      else\n      {\n        string_p = ecma_new_ecma_string_from_utf8 (context.source_start_p, context.source_size);\n      }\n\n      context.script_p->source_code = ecma_make_string_value (string_p);\n    }\n    else\n    {\n      ecma_value_t source = ((ecma_value_t *) source_p)[0];\n\n      ecma_ref_ecma_string (ecma_get_string_from_value (source));\n      context.script_p->source_code = source;\n    }\n\n    if (context.argument_list != ECMA_VALUE_EMPTY)\n    {\n      int idx = (context.user_value != ECMA_VALUE_EMPTY) ? 1 : 0;\n\n      CBC_SCRIPT_GET_OPTIONAL_VALUES (context.script_p)[idx] = context.argument_list;\n\n      ecma_ref_ecma_string (ecma_get_string_from_value (context.argument_list));\n      context.script_p->refs_and_type |= CBC_SCRIPT_HAS_FUNCTION_ARGUMENTS;\n    }\n#endif /* JERRY_FUNCTION_TO_STRING */\n\n#if JERRY_PARSER_DUMP_BYTE_CODE\n    if (context.is_show_opcodes)\n    {\n      JERRY_DEBUG_MSG (\"\\n%s parsing successfully completed. Total byte code size: %d bytes\\n\",\n                       (context.arguments_start_p == NULL) ? \"Script\"\n                                                           : \"Function\",\n                       (int) context.total_byte_code_size);\n    }\n#endif /* JERRY_PARSER_DUMP_BYTE_CODE */\n  }\n  PARSER_CATCH\n  {\n    if (context.last_statement.current_p != NULL)\n    {\n      parser_free_jumps (context.last_statement);\n    }\n\n    parser_free_allocated_buffer (&context);\n\n    scanner_cleanup (&context);\n\n#if JERRY_MODULE_SYSTEM\n    if (context.module_names_p != NULL)\n    {\n      ecma_module_release_module_names (context.module_names_p);\n    }\n#endif\n\n    compiled_code_p = NULL;\n    parser_free_literals (&context.literal_pool);\n    parser_cbc_stream_free (&context.byte_code);\n\n#if JERRY_RESOURCE_NAME\n    ecma_deref_ecma_string (ecma_get_string_from_value (context.script_p->resource_name));\n#endif /* JERRY_RESOURCE_NAME */\n\n    if (context.script_p != NULL)\n    {\n      JERRY_ASSERT (context.script_p->refs_and_type >= CBC_SCRIPT_REF_ONE);\n      jmem_heap_free_block (context.script_p, script_size);\n    }\n  }\n  PARSER_TRY_END\n\n  if (context.scope_stack_p != NULL)\n  {\n    parser_free (context.scope_stack_p, context.scope_stack_size * sizeof (parser_scope_stack_t));\n  }\n\n#if JERRY_LINE_INFO\n  parser_line_info_free (context.line_info_p);\n#endif /* JERRY_LINE_INFO */\n\n#if JERRY_PARSER_DUMP_BYTE_CODE\n  if (context.is_show_opcodes)\n  {\n    JERRY_DEBUG_MSG (\"\\n--- %s parsing end ---\\n\\n\",\n                     (context.arguments_start_p == NULL) ? \"Script\"\n                                                         : \"Function\");\n  }\n#endif /* JERRY_PARSER_DUMP_BYTE_CODE */\n\n  parser_stack_free (&context);\n\n  if (context.global_status_flags & ECMA_PARSE_INTERNAL_FREE_SOURCE)\n  {\n    jmem_heap_free_block ((void *) context.source_start_p, context.source_size);\n  }\n\n  if (context.global_status_flags & ECMA_PARSE_INTERNAL_FREE_ARG_LIST)\n  {\n    jmem_heap_free_block ((void *) context.arguments_start_p, context.arguments_size);\n  }\n\n  if (compiled_code_p != NULL)\n  {\n    return compiled_code_p;\n  }\n\n#if JERRY_DEBUGGER\n  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n  {\n    jerry_debugger_send_type (JERRY_DEBUGGER_PARSE_ERROR);\n  }\n#endif /* JERRY_DEBUGGER */\n\n  if (context.error == PARSER_ERR_OUT_OF_MEMORY)\n  {\n    /* It is unlikely that memory can be allocated in an out-of-memory\n     * situation. However, a simple value can still be thrown. */\n    jcontext_raise_exception (ECMA_VALUE_NULL);\n    return NULL;\n  }\n\n#if JERRY_ERROR_MESSAGES\n  ecma_string_t *err_str_p;\n\n  if (context.error == PARSER_ERR_INVALID_REGEXP)\n  {\n    ecma_value_t error = jcontext_take_exception ();\n    ecma_property_t *prop_p = ecma_find_named_property (ecma_get_object_from_value (error),\n                                                        ecma_get_magic_string (LIT_MAGIC_STRING_MESSAGE));\n    ecma_free_value (error);\n    JERRY_ASSERT (prop_p);\n    err_str_p = ecma_get_string_from_value (ECMA_PROPERTY_VALUE_PTR (prop_p)->value);\n    ecma_ref_ecma_string (err_str_p);\n  }\n  else\n  {\n    const lit_utf8_byte_t *err_bytes_p = (const lit_utf8_byte_t *) parser_error_to_string (context.error);\n    lit_utf8_size_t err_bytes_size = lit_zt_utf8_string_size (err_bytes_p);\n    err_str_p = ecma_new_ecma_string_from_utf8 (err_bytes_p, err_bytes_size);\n  }\n  ecma_value_t err_str_val = ecma_make_string_value (err_str_p);\n  ecma_value_t line_str_val = ecma_make_uint32_value (context.token.line);\n  ecma_value_t col_str_val = ecma_make_uint32_value (context.token.column);\n\n  ecma_raise_standard_error_with_format (JERRY_ERROR_SYNTAX,\n                                         \"% [%:%:%]\",\n                                         err_str_val,\n                                         resource_name,\n                                         line_str_val,\n                                         col_str_val);\n\n  ecma_free_value (col_str_val);\n  ecma_free_value (line_str_val);\n  ecma_deref_ecma_string (err_str_p);\n#else /* !JERRY_ERROR_MESSAGES */\n  if (context.error == PARSER_ERR_INVALID_REGEXP)\n  {\n    jcontext_release_exception ();\n  }\n\n  ecma_raise_syntax_error (\"\");\n#endif /* JERRY_ERROR_MESSAGES */\n\n  return NULL;\n}",
        "begin_line": 1832,
        "end_line": 2396,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_post_processing#576",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_post_processing (parser_context_t *context_p) /**< context */",
        "snippet": "static ecma_compiled_code_t *\nparser_post_processing (parser_context_t *context_p) /**< context */\n{\n  uint16_t literal_one_byte_limit;\n  uint16_t ident_end;\n  uint16_t const_literal_end;\n  parser_mem_page_t *page_p;\n  parser_mem_page_t *last_page_p;\n  size_t last_position;\n  size_t offset;\n  size_t length;\n  size_t literal_length;\n  size_t total_size;\n  uint8_t real_offset;\n  uint8_t *byte_code_p;\n  bool needs_uint16_arguments;\n  cbc_opcode_t last_opcode = CBC_EXT_OPCODE;\n  ecma_compiled_code_t *compiled_code_p;\n  ecma_value_t *literal_pool_p;\n  uint8_t *dst_p;\n\n#if JERRY_ESNEXT\n  if ((context_p->status_flags & (PARSER_IS_FUNCTION | PARSER_LEXICAL_BLOCK_NEEDED))\n      == (PARSER_IS_FUNCTION | PARSER_LEXICAL_BLOCK_NEEDED))\n  {\n    PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);\n#ifndef JERRY_NDEBUG\n    PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);\n#endif /* !JERRY_NDEBUG */\n\n    context_p->status_flags &= (uint32_t) ~PARSER_LEXICAL_BLOCK_NEEDED;\n\n    parser_emit_cbc (context_p, CBC_CONTEXT_END);\n\n    parser_branch_t branch;\n    parser_stack_pop (context_p, &branch, sizeof (parser_branch_t));\n    parser_set_branch_to_current_position (context_p, &branch);\n\n    JERRY_ASSERT (!(context_p->status_flags & PARSER_NO_END_LABEL));\n  }\n\n  if (PARSER_IS_NORMAL_ASYNC_FUNCTION (context_p->status_flags))\n  {\n    PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);\n#ifndef JERRY_NDEBUG\n    PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);\n#endif /* !JERRY_NDEBUG */\n\n    if (context_p->stack_limit < PARSER_FINALLY_CONTEXT_STACK_ALLOCATION)\n    {\n      context_p->stack_limit = PARSER_FINALLY_CONTEXT_STACK_ALLOCATION;\n    }\n\n    parser_branch_t branch;\n\n    parser_stack_pop (context_p, &branch, sizeof (parser_branch_t));\n    parser_set_branch_to_current_position (context_p, &branch);\n\n    JERRY_ASSERT (!(context_p->status_flags & PARSER_NO_END_LABEL));\n  }\n#endif /* JERRY_ESNEXT */\n\n#if JERRY_LINE_INFO\n  JERRY_ASSERT (context_p->line_info_p != NULL);\n#endif /* JERRY_LINE_INFO */\n\n  JERRY_ASSERT (context_p->stack_depth == 0);\n#ifndef JERRY_NDEBUG\n  JERRY_ASSERT (context_p->context_stack_depth == 0);\n#endif /* !JERRY_NDEBUG */\n\n  if ((size_t) context_p->stack_limit + (size_t) context_p->register_count > PARSER_MAXIMUM_STACK_LIMIT)\n  {\n    parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);\n  }\n\n  if (JERRY_UNLIKELY (context_p->script_p->refs_and_type >= CBC_SCRIPT_REF_MAX))\n  {\n    /* This is probably never happens in practice. */\n    jerry_fatal (ERR_REF_COUNT_LIMIT);\n  }\n\n  context_p->script_p->refs_and_type += CBC_SCRIPT_REF_ONE;\n\n  JERRY_ASSERT (context_p->literal_count <= PARSER_MAXIMUM_NUMBER_OF_LITERALS);\n\n#if JERRY_DEBUGGER\n  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n      && !(context_p->status_flags & PARSER_DEBUGGER_BREAKPOINT_APPENDED))\n  {\n    /* Always provide at least one breakpoint. */\n    parser_emit_cbc (context_p, CBC_BREAKPOINT_DISABLED);\n    parser_flush_cbc (context_p);\n\n    parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST, context_p->token.line);\n\n    context_p->last_breakpoint_line = context_p->token.line;\n  }\n\n  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n      && context_p->breakpoint_info_count > 0)\n  {\n    parser_send_breakpoints (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST);\n    JERRY_ASSERT (context_p->breakpoint_info_count == 0);\n  }\n#endif /* JERRY_DEBUGGER */\n\n  parser_compute_indicies (context_p, &ident_end, &const_literal_end);\n\n  if (context_p->literal_count <= CBC_MAXIMUM_SMALL_VALUE)\n  {\n    literal_one_byte_limit = CBC_MAXIMUM_BYTE_VALUE - 1;\n  }\n  else\n  {\n    literal_one_byte_limit = CBC_LOWER_SEVEN_BIT_MASK;\n  }\n\n  last_page_p = context_p->byte_code.last_p;\n  last_position = context_p->byte_code.last_position;\n\n  if (last_position >= PARSER_CBC_STREAM_PAGE_SIZE)\n  {\n    last_page_p = NULL;\n    last_position = 0;\n  }\n\n  page_p = context_p->byte_code.first_p;\n  offset = 0;\n  length = 0;\n\n  while (page_p != last_page_p || offset < last_position)\n  {\n    uint8_t *opcode_p;\n    uint8_t flags;\n    size_t branch_offset_length;\n\n    opcode_p = page_p->bytes + offset;\n    last_opcode = (cbc_opcode_t) (*opcode_p);\n    PARSER_NEXT_BYTE (page_p, offset);\n    branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (last_opcode);\n    flags = cbc_flags[last_opcode];\n    length++;\n\n    switch (last_opcode)\n    {\n      case CBC_EXT_OPCODE:\n      {\n        cbc_ext_opcode_t ext_opcode;\n\n        ext_opcode = (cbc_ext_opcode_t) page_p->bytes[offset];\n        branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (ext_opcode);\n        flags = cbc_ext_flags[ext_opcode];\n        PARSER_NEXT_BYTE (page_p, offset);\n        length++;\n        break;\n      }\n      case CBC_POST_DECR:\n      {\n        *opcode_p = CBC_PRE_DECR;\n        break;\n      }\n      case CBC_POST_INCR:\n      {\n        *opcode_p = CBC_PRE_INCR;\n        break;\n      }\n      case CBC_POST_DECR_IDENT:\n      {\n        *opcode_p = CBC_PRE_DECR_IDENT;\n        break;\n      }\n      case CBC_POST_INCR_IDENT:\n      {\n        *opcode_p = CBC_PRE_INCR_IDENT;\n        break;\n      }\n      default:\n      {\n        break;\n      }\n    }\n\n    while (flags & (CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2))\n    {\n      uint8_t *first_byte = page_p->bytes + offset;\n      uint32_t literal_index = *first_byte;\n\n      PARSER_NEXT_BYTE (page_p, offset);\n      length++;\n\n      literal_index |= ((uint32_t) page_p->bytes[offset]) << 8;\n\n      if (literal_index >= PARSER_REGISTER_START)\n      {\n        literal_index -= PARSER_REGISTER_START;\n      }\n      else\n      {\n        literal_index = (PARSER_GET_LITERAL (literal_index))->prop.index;\n      }\n\n      if (literal_index <= literal_one_byte_limit)\n      {\n        *first_byte = (uint8_t) literal_index;\n      }\n      else\n      {\n        if (context_p->literal_count <= CBC_MAXIMUM_SMALL_VALUE)\n        {\n          JERRY_ASSERT (literal_index <= CBC_MAXIMUM_SMALL_VALUE);\n          *first_byte = CBC_MAXIMUM_BYTE_VALUE;\n          page_p->bytes[offset] = (uint8_t) (literal_index - CBC_MAXIMUM_BYTE_VALUE);\n          length++;\n        }\n        else\n        {\n          JERRY_ASSERT (literal_index <= CBC_MAXIMUM_FULL_VALUE);\n          *first_byte = (uint8_t) ((literal_index >> 8) | CBC_HIGHEST_BIT_MASK);\n          page_p->bytes[offset] = (uint8_t) (literal_index & 0xff);\n          length++;\n        }\n      }\n      PARSER_NEXT_BYTE (page_p, offset);\n\n      if (flags & CBC_HAS_LITERAL_ARG2)\n      {\n        if (flags & CBC_HAS_LITERAL_ARG)\n        {\n          flags = CBC_HAS_LITERAL_ARG;\n        }\n        else\n        {\n          flags = CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2;\n        }\n      }\n      else\n      {\n        break;\n      }\n    }\n\n    if (flags & CBC_HAS_BYTE_ARG)\n    {\n      /* This argument will be copied without modification. */\n      PARSER_NEXT_BYTE (page_p, offset);\n      length++;\n    }\n\n    if (flags & CBC_HAS_BRANCH_ARG)\n    {\n      bool prefix_zero = true;\n\n      /* The leading zeroes are dropped from the stream.\n       * Although dropping these zeroes for backward\n       * branches are unnecessary, we use the same\n       * code path for simplicity. */\n      JERRY_ASSERT (branch_offset_length > 0 && branch_offset_length <= 3);\n\n      while (--branch_offset_length > 0)\n      {\n        uint8_t byte = page_p->bytes[offset];\n        if (byte > 0 || !prefix_zero)\n        {\n          prefix_zero = false;\n          length++;\n        }\n        else\n        {\n          JERRY_ASSERT (CBC_BRANCH_IS_FORWARD (flags));\n        }\n        PARSER_NEXT_BYTE (page_p, offset);\n      }\n\n      if (last_opcode == (cbc_opcode_t) (CBC_JUMP_FORWARD + PARSER_MAX_BRANCH_LENGTH - 1)\n          && prefix_zero\n          && page_p->bytes[offset] == PARSER_MAX_BRANCH_LENGTH + 1)\n      {\n        /* Uncoditional jumps which jump right after the instruction\n         * are effectively NOPs. These jumps are removed from the\n         * stream. The 1 byte long CBC_JUMP_FORWARD form marks these\n         * instructions, since this form is constructed during post\n         * processing and cannot be emitted directly. */\n        *opcode_p = CBC_JUMP_FORWARD;\n        length--;\n      }\n      else\n      {\n        /* Other last bytes are always copied. */\n        length++;\n      }\n\n      PARSER_NEXT_BYTE (page_p, offset);\n    }\n  }\n\n  if (!(context_p->status_flags & PARSER_NO_END_LABEL)\n      || !(PARSER_OPCODE_IS_RETURN (last_opcode)))\n  {\n    context_p->status_flags &= (uint32_t) ~PARSER_NO_END_LABEL;\n\n#if JERRY_ESNEXT\n    if (PARSER_IS_NORMAL_ASYNC_FUNCTION (context_p->status_flags))\n    {\n      length++;\n    }\n#endif /* JERRY_ESNEXT */\n\n    length++;\n  }\n\n  needs_uint16_arguments = false;\n  total_size = sizeof (cbc_uint8_arguments_t);\n\n  if (context_p->stack_limit > CBC_MAXIMUM_BYTE_VALUE\n      || context_p->register_count > CBC_MAXIMUM_BYTE_VALUE\n      || context_p->literal_count > CBC_MAXIMUM_BYTE_VALUE)\n  {\n    needs_uint16_arguments = true;\n    total_size = sizeof (cbc_uint16_arguments_t);\n  }\n\n  literal_length = (size_t) (context_p->literal_count - context_p->register_count) * sizeof (ecma_value_t);\n\n  total_size += literal_length + length;\n\n  if (PARSER_NEEDS_MAPPED_ARGUMENTS (context_p->status_flags))\n  {\n    total_size += context_p->argument_count * sizeof (ecma_value_t);\n  }\n\n#if JERRY_ESNEXT\n  /* function.name */\n  if (!(context_p->status_flags & PARSER_CLASS_CONSTRUCTOR))\n  {\n    total_size += sizeof (ecma_value_t);\n  }\n\n  if (context_p->tagged_template_literal_cp != JMEM_CP_NULL)\n  {\n    total_size += sizeof (ecma_value_t);\n  }\n#endif /* JERRY_ESNEXT */\n\n#if JERRY_LINE_INFO\n  total_size += sizeof (ecma_value_t);\n#endif /* JERRY_LINE_INFO */\n\n#if JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING\n  uint8_t extended_info = 0;\n#endif /* JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING */\n\n#if JERRY_ESNEXT\n  if (context_p->argument_length != UINT16_MAX)\n  {\n    extended_info |= CBC_EXTENDED_CODE_FLAGS_HAS_ARGUMENT_LENGTH;\n    total_size += ecma_extended_info_get_encoded_length (context_p->argument_length);\n  }\n#endif /* JERRY_ESNEXT */\n\n#if JERRY_FUNCTION_TO_STRING\n  if (context_p->last_context_p != NULL)\n  {\n    extended_info |= CBC_EXTENDED_CODE_FLAGS_HAS_SOURCE_CODE_RANGE;\n\n    const uint8_t *start_p = context_p->source_start_p;\n    const uint8_t *function_start_p = context_p->last_context_p->function_start_p;\n\n    if (function_start_p < start_p || function_start_p >= start_p + context_p->source_size)\n    {\n      JERRY_ASSERT (context_p->arguments_start_p != NULL\n                    && function_start_p >= context_p->arguments_start_p\n                    && function_start_p < context_p->arguments_start_p + context_p->arguments_size);\n\n      start_p = context_p->arguments_start_p;\n      extended_info |= CBC_EXTENDED_CODE_FLAGS_SOURCE_CODE_IN_ARGUMENTS;\n    }\n\n    total_size += ecma_extended_info_get_encoded_length ((uint32_t) (function_start_p - start_p));\n    total_size += ecma_extended_info_get_encoded_length ((uint32_t) (context_p->function_end_p - function_start_p));\n  }\n#endif /* JERRY_FUNCTION_TO_STRING */\n\n#if JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING\n  if (extended_info != 0)\n  {\n    total_size += sizeof (uint8_t);\n  }\n#endif /* JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING */\n\n  total_size = JERRY_ALIGNUP (total_size, JMEM_ALIGNMENT);\n\n  compiled_code_p = (ecma_compiled_code_t *) parser_malloc (context_p, total_size);\n\n#if JERRY_SNAPSHOT_SAVE || JERRY_PARSER_DUMP_BYTE_CODE\n  // Avoid getting junk bytes\n  memset (compiled_code_p, 0, total_size);\n#endif /* JERRY_SNAPSHOT_SAVE || JERRY_PARSER_DUMP_BYTE_CODE */\n\n#if JERRY_MEM_STATS\n  jmem_stats_allocate_byte_code_bytes (total_size);\n#endif /* JERRY_MEM_STATS */\n\n  byte_code_p = (uint8_t *) compiled_code_p;\n  compiled_code_p->size = (uint16_t) (total_size >> JMEM_ALIGNMENT_LOG);\n  compiled_code_p->refs = 1;\n  compiled_code_p->status_flags = 0;\n\n#if JERRY_ESNEXT\n  if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)\n  {\n    JERRY_ASSERT (context_p->argument_count > 0);\n    context_p->argument_count--;\n  }\n#endif /* JERRY_ESNEXT */\n\n  if (needs_uint16_arguments)\n  {\n    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) compiled_code_p;\n\n    args_p->stack_limit = context_p->stack_limit;\n    args_p->script_value = context_p->script_value;\n    args_p->argument_end = context_p->argument_count;\n    args_p->register_end = context_p->register_count;\n    args_p->ident_end = ident_end;\n    args_p->const_literal_end = const_literal_end;\n    args_p->literal_end = context_p->literal_count;\n\n    compiled_code_p->status_flags |= CBC_CODE_FLAGS_UINT16_ARGUMENTS;\n    byte_code_p += sizeof (cbc_uint16_arguments_t);\n  }\n  else\n  {\n    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) compiled_code_p;\n\n    args_p->stack_limit = (uint8_t) context_p->stack_limit;\n    args_p->argument_end = (uint8_t) context_p->argument_count;\n    args_p->script_value = context_p->script_value;\n    args_p->register_end = (uint8_t) context_p->register_count;\n    args_p->ident_end = (uint8_t) ident_end;\n    args_p->const_literal_end = (uint8_t) const_literal_end;\n    args_p->literal_end = (uint8_t) context_p->literal_count;\n\n    byte_code_p += sizeof (cbc_uint8_arguments_t);\n  }\n\n  uint16_t encoding_limit;\n  uint16_t encoding_delta;\n\n  if (context_p->literal_count > CBC_MAXIMUM_SMALL_VALUE)\n  {\n    compiled_code_p->status_flags |= CBC_CODE_FLAGS_FULL_LITERAL_ENCODING;\n    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;\n    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;\n  }\n  else\n  {\n    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;\n    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;\n  }\n\n  if (context_p->status_flags & PARSER_IS_STRICT)\n  {\n    compiled_code_p->status_flags |= CBC_CODE_FLAGS_STRICT_MODE;\n  }\n\n  if ((context_p->status_flags & PARSER_ARGUMENTS_NEEDED)\n      && PARSER_NEEDS_MAPPED_ARGUMENTS (context_p->status_flags))\n  {\n    compiled_code_p->status_flags |= CBC_CODE_FLAGS_MAPPED_ARGUMENTS_NEEDED;\n  }\n\n  if (!(context_p->status_flags & PARSER_LEXICAL_ENV_NEEDED))\n  {\n    compiled_code_p->status_flags |= CBC_CODE_FLAGS_LEXICAL_ENV_NOT_NEEDED;\n  }\n\n  uint16_t function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_NORMAL);\n\n  if (context_p->status_flags & (PARSER_IS_PROPERTY_GETTER | PARSER_IS_PROPERTY_SETTER))\n  {\n    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ACCESSOR);\n  }\n  else if (!(context_p->status_flags & PARSER_IS_FUNCTION))\n  {\n    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_SCRIPT);\n  }\n#if JERRY_ESNEXT\n  else if (context_p->status_flags & PARSER_IS_ARROW_FUNCTION)\n  {\n    if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)\n    {\n      function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ASYNC_ARROW);\n    }\n    else\n    {\n      function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ARROW);\n    }\n  }\n  else if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)\n  {\n    if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)\n    {\n      function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ASYNC_GENERATOR);\n    }\n    else\n    {\n      function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_GENERATOR);\n    }\n  }\n  else if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)\n  {\n    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ASYNC);\n  }\n  else if (context_p->status_flags & PARSER_CLASS_CONSTRUCTOR)\n  {\n    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_CONSTRUCTOR);\n  }\n  else if (context_p->status_flags & PARSER_IS_METHOD)\n  {\n    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_METHOD);\n  }\n\n  if (context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED)\n  {\n    JERRY_ASSERT (!(context_p->status_flags & PARSER_IS_FUNCTION));\n    compiled_code_p->status_flags |= CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED;\n  }\n#endif /* JERRY_ESNEXT */\n\n  compiled_code_p->status_flags |= function_type;\n\n#if JERRY_LINE_INFO\n  compiled_code_p->status_flags |= CBC_CODE_FLAGS_HAS_LINE_INFO;\n#endif /* JERRY_LINE_INFO */\n\n  literal_pool_p = ((ecma_value_t *) byte_code_p) - context_p->register_count;\n  byte_code_p += literal_length;\n  dst_p = byte_code_p;\n\n  parser_init_literal_pool (context_p, literal_pool_p);\n\n  page_p = context_p->byte_code.first_p;\n  offset = 0;\n  real_offset = 0;\n  uint8_t last_register_index = (uint8_t) JERRY_MIN (context_p->register_count,\n                                                     (PARSER_MAXIMUM_NUMBER_OF_REGISTERS - 1));\n\n  while (page_p != last_page_p || offset < last_position)\n  {\n    uint8_t flags;\n    uint8_t *opcode_p;\n    uint8_t *branch_mark_p;\n    cbc_opcode_t opcode;\n    size_t branch_offset_length;\n\n    opcode_p = dst_p;\n    branch_mark_p = page_p->bytes + offset;\n    opcode = (cbc_opcode_t) (*branch_mark_p);\n    branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (opcode);\n\n    if (opcode == CBC_JUMP_FORWARD)\n    {\n      /* These opcodes are deleted from the stream. */\n      size_t counter = PARSER_MAX_BRANCH_LENGTH + 1;\n\n      do\n      {\n        PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);\n      }\n      while (--counter > 0);\n\n      continue;\n    }\n\n    /* Storing the opcode */\n    *dst_p++ = (uint8_t) opcode;\n    real_offset++;\n    PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);\n    flags = cbc_flags[opcode];\n\n#if JERRY_DEBUGGER\n    if (opcode == CBC_BREAKPOINT_DISABLED)\n    {\n      uint32_t bp_offset = (uint32_t) (((uint8_t *) dst_p) - ((uint8_t *) compiled_code_p) - 1);\n      parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_OFFSET_LIST, bp_offset);\n    }\n#endif /* JERRY_DEBUGGER */\n\n    if (opcode == CBC_EXT_OPCODE)\n    {\n      cbc_ext_opcode_t ext_opcode;\n\n      ext_opcode = (cbc_ext_opcode_t) page_p->bytes[offset];\n      flags = cbc_ext_flags[ext_opcode];\n      branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (ext_opcode);\n\n      /* Storing the extended opcode */\n      *dst_p++ = (uint8_t) ext_opcode;\n      opcode_p++;\n      real_offset++;\n      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);\n    }\n\n    /* Only literal and call arguments can be combined. */\n    JERRY_ASSERT (!(flags & CBC_HAS_BRANCH_ARG)\n                   || !(flags & (CBC_HAS_BYTE_ARG | CBC_HAS_LITERAL_ARG)));\n\n    while (flags & (CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2))\n    {\n      uint16_t first_byte = page_p->bytes[offset];\n\n      uint8_t *opcode_pos_p = dst_p - 1;\n      *dst_p++ = (uint8_t) first_byte;\n      real_offset++;\n      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);\n\n      if (first_byte > literal_one_byte_limit)\n      {\n        *dst_p++ = page_p->bytes[offset];\n\n        if (first_byte >= encoding_limit)\n        {\n          first_byte = (uint16_t) (((first_byte << 8) | dst_p[-1]) - encoding_delta);\n        }\n        real_offset++;\n      }\n      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);\n\n      if (flags & CBC_HAS_LITERAL_ARG2)\n      {\n        if (flags & CBC_HAS_LITERAL_ARG)\n        {\n          flags = CBC_HAS_LITERAL_ARG;\n        }\n        else\n        {\n          flags = CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2;\n        }\n      }\n      else\n      {\n        if (opcode == CBC_ASSIGN_SET_IDENT && JERRY_LIKELY (first_byte < last_register_index))\n        {\n          *opcode_pos_p = CBC_MOV_IDENT;\n        }\n\n        break;\n      }\n    }\n\n    if (flags & CBC_HAS_BYTE_ARG)\n    {\n      /* This argument will be copied without modification. */\n      *dst_p++ = page_p->bytes[offset];\n      real_offset++;\n      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);\n      continue;\n    }\n\n    if (flags & CBC_HAS_BRANCH_ARG)\n    {\n      *branch_mark_p |= CBC_HIGHEST_BIT_MASK;\n      bool prefix_zero = true;\n\n      /* The leading zeroes are dropped from the stream. */\n      JERRY_ASSERT (branch_offset_length > 0 && branch_offset_length <= 3);\n\n      while (--branch_offset_length > 0)\n      {\n        uint8_t byte = page_p->bytes[offset];\n        if (byte > 0 || !prefix_zero)\n        {\n          prefix_zero = false;\n          *dst_p++ = page_p->bytes[offset];\n          real_offset++;\n        }\n        else\n        {\n          /* When a leading zero is dropped, the branch\n           * offset length must be decreased as well. */\n          (*opcode_p)--;\n        }\n        PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);\n      }\n\n      *dst_p++ = page_p->bytes[offset];\n      real_offset++;\n      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);\n      continue;\n    }\n  }\n\n#if JERRY_DEBUGGER\n  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n      && context_p->breakpoint_info_count > 0)\n  {\n    parser_send_breakpoints (context_p, JERRY_DEBUGGER_BREAKPOINT_OFFSET_LIST);\n    JERRY_ASSERT (context_p->breakpoint_info_count == 0);\n  }\n#endif /* JERRY_DEBUGGER */\n\n  if (!(context_p->status_flags & PARSER_NO_END_LABEL))\n  {\n    *dst_p++ = CBC_RETURN_WITH_BLOCK;\n\n#if JERRY_ESNEXT\n    if (PARSER_IS_NORMAL_ASYNC_FUNCTION (context_p->status_flags))\n    {\n      dst_p[-1] = CBC_EXT_OPCODE;\n      dst_p[0] = CBC_EXT_ASYNC_EXIT;\n      dst_p++;\n    }\n#endif /* JERRY_ESNEXT */\n  }\n  JERRY_ASSERT (dst_p == byte_code_p + length);\n\n#if JERRY_LINE_INFO\n  uint8_t *line_info_p = parser_line_info_generate (context_p);\n#endif /* JERRY_LINE_INFO */\n\n  parse_update_branches (context_p, byte_code_p);\n\n  parser_cbc_stream_free (&context_p->byte_code);\n\n  if (context_p->status_flags & PARSER_HAS_LATE_LIT_INIT)\n  {\n    parser_list_iterator_t literal_iterator;\n    lexer_literal_t *literal_p;\n    uint16_t register_count = context_p->register_count;\n\n    parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n    while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))\n    {\n      if ((literal_p->status_flags & LEXER_FLAG_LATE_INIT)\n          && literal_p->prop.index >= register_count)\n      {\n        uint32_t source_data = literal_p->u.source_data;\n        const uint8_t *char_p = context_p->source_end_p - (source_data & 0xfffff);\n        ecma_value_t lit_value = ecma_find_or_create_literal_string (char_p,\n                                                                     source_data >> 20,\n                                                                     (literal_p->status_flags & LEXER_FLAG_ASCII) != 0);\n        literal_pool_p[literal_p->prop.index] = lit_value;\n      }\n    }\n  }\n\n  ecma_value_t *base_p = (ecma_value_t *) (((uint8_t *) compiled_code_p) + total_size);\n\n  if (PARSER_NEEDS_MAPPED_ARGUMENTS (context_p->status_flags))\n  {\n    parser_list_iterator_t literal_iterator;\n    uint16_t argument_count = 0;\n    uint16_t register_count = context_p->register_count;\n    base_p -= context_p->argument_count;\n\n    parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n    while (argument_count < context_p->argument_count)\n    {\n      lexer_literal_t *literal_p;\n      literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator);\n\n      JERRY_ASSERT (literal_p != NULL);\n\n      if (!(literal_p->status_flags & LEXER_FLAG_FUNCTION_ARGUMENT))\n      {\n        continue;\n      }\n\n      /* All arguments must be moved to initialized registers. */\n      if (literal_p->type == LEXER_UNUSED_LITERAL)\n      {\n        base_p[argument_count] = ECMA_VALUE_EMPTY;\n        argument_count++;\n        continue;\n      }\n\n      JERRY_ASSERT (literal_p->type == LEXER_IDENT_LITERAL);\n\n      JERRY_ASSERT (literal_p->prop.index >= register_count);\n\n      base_p[argument_count] = literal_pool_p[literal_p->prop.index];\n      argument_count++;\n    }\n  }\n\n#if JERRY_ESNEXT\n  if (!(context_p->status_flags & PARSER_CLASS_CONSTRUCTOR))\n  {\n    *(--base_p) = ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);\n  }\n\n  if (context_p->tagged_template_literal_cp != JMEM_CP_NULL)\n  {\n    compiled_code_p->status_flags |= CBC_CODE_FLAGS_HAS_TAGGED_LITERALS;\n    *(--base_p) = (ecma_value_t) context_p->tagged_template_literal_cp;\n  }\n#endif /* JERRY_ESNEXT */\n\n#if JERRY_LINE_INFO\n  ECMA_SET_INTERNAL_VALUE_POINTER (base_p[-1], line_info_p);\n#endif /* JERRY_LINE_INFO */\n\n#if JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING\n  if (extended_info != 0)\n  {\n#if JERRY_LINE_INFO\n    base_p--;\n#endif /* JERRY_LINE_INFO */\n\n    uint8_t *extended_info_p = ((uint8_t *) base_p) - 1;\n\n    compiled_code_p->status_flags |= CBC_CODE_FLAGS_HAS_EXTENDED_INFO;\n    *extended_info_p = extended_info;\n\n#if JERRY_ESNEXT\n    if (context_p->argument_length != UINT16_MAX)\n    {\n      ecma_extended_info_encode_vlq (&extended_info_p, context_p->argument_length);\n    }\n#endif /* JERRY_ESNEXT */\n\n#if JERRY_FUNCTION_TO_STRING\n    if (context_p->last_context_p != NULL)\n    {\n      const uint8_t *start_p = context_p->source_start_p;\n\n      if (extended_info & CBC_EXTENDED_CODE_FLAGS_SOURCE_CODE_IN_ARGUMENTS)\n      {\n        start_p = context_p->arguments_start_p;\n      }\n\n      const uint8_t *function_start_p = context_p->last_context_p->function_start_p;\n\n      ecma_extended_info_encode_vlq (&extended_info_p, (uint32_t) (function_start_p - start_p));\n      ecma_extended_info_encode_vlq (&extended_info_p, (uint32_t) (context_p->function_end_p - function_start_p));\n    }\n#endif /* JERRY_FUNCTION_TO_STRING */\n  }\n#endif /* JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING */\n\n#if JERRY_PARSER_DUMP_BYTE_CODE\n  if (context_p->is_show_opcodes)\n  {\n    util_print_cbc (compiled_code_p);\n    JERRY_DEBUG_MSG (\"\\nByte code size: %d bytes\\n\", (int) length);\n    context_p->total_byte_code_size += (uint32_t) length;\n  }\n#endif /* JERRY_PARSER_DUMP_BYTE_CODE */\n\n#if JERRY_DEBUGGER\n  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n  {\n    jerry_debugger_send_function_cp (JERRY_DEBUGGER_BYTE_CODE_CP, compiled_code_p);\n  }\n#endif /* JERRY_DEBUGGER */\n\n  return compiled_code_p;\n}",
        "begin_line": 576,
        "end_line": 1434,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_restore_context#2501",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_restore_context (parser_context_t *context_p, /**< context */                         parser_saved_context_t *saved_context_p) /**< target for saving the context */",
        "snippet": "static void\nparser_restore_context (parser_context_t *context_p, /**< context */\n                        parser_saved_context_t *saved_context_p) /**< target for saving the context */\n{\n  parser_list_free (&context_p->literal_pool);\n\n  if (context_p->scope_stack_p != NULL)\n  {\n    parser_free (context_p->scope_stack_p, context_p->scope_stack_size * sizeof (parser_scope_stack_t));\n  }\n\n#if JERRY_LINE_INFO\n  parser_line_info_free (context_p->line_info_p);\n#endif /* JERRY_LINE_INFO */\n\n  /* Restore private part of the context. */\n\n  JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);\n\n  context_p->status_flags = saved_context_p->status_flags;\n  context_p->stack_depth = saved_context_p->stack_depth;\n  context_p->stack_limit = saved_context_p->stack_limit;\n  context_p->last_context_p = saved_context_p->prev_context_p;\n  context_p->last_statement = saved_context_p->last_statement;\n\n  context_p->argument_count = saved_context_p->argument_count;\n#if JERRY_ESNEXT\n  context_p->argument_length = saved_context_p->argument_length;\n#endif /* JERRY_ESNEXT */\n  context_p->register_count = saved_context_p->register_count;\n  context_p->literal_count = saved_context_p->literal_count;\n\n  context_p->byte_code = saved_context_p->byte_code;\n  context_p->byte_code_size = saved_context_p->byte_code_size;\n  context_p->literal_pool.data = saved_context_p->literal_pool_data;\n  context_p->scope_stack_p = saved_context_p->scope_stack_p;\n  context_p->scope_stack_size = saved_context_p->scope_stack_size;\n  context_p->scope_stack_top = saved_context_p->scope_stack_top;\n  context_p->scope_stack_reg_top = saved_context_p->scope_stack_reg_top;\n#if JERRY_ESNEXT\n  context_p->scope_stack_global_end = saved_context_p->scope_stack_global_end;\n  context_p->tagged_template_literal_cp = saved_context_p->tagged_template_literal_cp;\n#endif /* JERRY_ESNEXT */\n\n#ifndef JERRY_NDEBUG\n  context_p->context_stack_depth = saved_context_p->context_stack_depth;\n#endif /* !JERRY_NDEBUG */\n\n#if JERRY_LINE_INFO\n  context_p->line_info_p = saved_context_p->line_info_p;\n#endif /* JERRY_LINE_INFO */\n}",
        "begin_line": 2501,
        "end_line": 2552,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_save_context#2401",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_save_context (parser_context_t *context_p, /**< context */                      parser_saved_context_t *saved_context_p) /**< target for saving the context */",
        "snippet": "static void\nparser_save_context (parser_context_t *context_p, /**< context */\n                     parser_saved_context_t *saved_context_p) /**< target for saving the context */\n{\n  JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);\n\n#if JERRY_DEBUGGER\n  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n      && context_p->breakpoint_info_count > 0)\n  {\n    parser_send_breakpoints (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST);\n    context_p->breakpoint_info_count = 0;\n  }\n#endif /* JERRY_DEBUGGER */\n\n#if JERRY_ESNEXT\n  if (context_p->status_flags & PARSER_FUNCTION_IS_PARSING_ARGS)\n  {\n    context_p->status_flags |= PARSER_LEXICAL_BLOCK_NEEDED;\n  }\n#endif /* JERRY_ESNEXT */\n\n  /* Save private part of the context. */\n\n  saved_context_p->status_flags = context_p->status_flags;\n  saved_context_p->stack_depth = context_p->stack_depth;\n  saved_context_p->stack_limit = context_p->stack_limit;\n  saved_context_p->prev_context_p = context_p->last_context_p;\n  saved_context_p->last_statement = context_p->last_statement;\n\n  saved_context_p->argument_count = context_p->argument_count;\n#if JERRY_ESNEXT\n  saved_context_p->argument_length = context_p->argument_length;\n#endif /* JERRY_ESNEXT */\n  saved_context_p->register_count = context_p->register_count;\n  saved_context_p->literal_count = context_p->literal_count;\n\n  saved_context_p->byte_code = context_p->byte_code;\n  saved_context_p->byte_code_size = context_p->byte_code_size;\n  saved_context_p->literal_pool_data = context_p->literal_pool.data;\n  saved_context_p->scope_stack_p = context_p->scope_stack_p;\n  saved_context_p->scope_stack_size = context_p->scope_stack_size;\n  saved_context_p->scope_stack_top = context_p->scope_stack_top;\n  saved_context_p->scope_stack_reg_top = context_p->scope_stack_reg_top;\n#if JERRY_ESNEXT\n  saved_context_p->scope_stack_global_end = context_p->scope_stack_global_end;\n  saved_context_p->tagged_template_literal_cp = context_p->tagged_template_literal_cp;\n#endif /* JERRY_ESNEXT */\n\n#ifndef JERRY_NDEBUG\n  saved_context_p->context_stack_depth = context_p->context_stack_depth;\n#endif /* !JERRY_NDEBUG */\n\n#if JERRY_LINE_INFO\n  saved_context_p->line_info_p = context_p->line_info_p;\n#endif /* JERRY_LINE_INFO */\n\n#if JERRY_FUNCTION_TO_STRING\n  saved_context_p->function_start_p = context_p->function_start_p;\n#endif /* JERRY_FUNCTION_TO_STRING */\n\n  /* Reset private part of the context. */\n\n  context_p->status_flags &= PARSER_IS_STRICT;\n  context_p->stack_depth = 0;\n  context_p->stack_limit = 0;\n  context_p->last_context_p = saved_context_p;\n  context_p->last_statement.current_p = NULL;\n\n  context_p->argument_count = 0;\n#if JERRY_ESNEXT\n  context_p->argument_length = UINT16_MAX;\n#endif /* JERRY_ESNEXT */\n  context_p->register_count = 0;\n  context_p->literal_count = 0;\n\n  parser_cbc_stream_init (&context_p->byte_code);\n  context_p->byte_code_size = 0;\n  parser_list_reset (&context_p->literal_pool);\n  context_p->scope_stack_p = NULL;\n  context_p->scope_stack_size = 0;\n  context_p->scope_stack_top = 0;\n  context_p->scope_stack_reg_top = 0;\n#if JERRY_ESNEXT\n  context_p->scope_stack_global_end = 0;\n  context_p->tagged_template_literal_cp = JMEM_CP_NULL;\n#endif /* JERRY_ESNEXT */\n\n#ifndef JERRY_NDEBUG\n  context_p->context_stack_depth = 0;\n#endif /* !JERRY_NDEBUG */\n\n#if JERRY_LINE_INFO\n  context_p->line_info_p = NULL;\n#endif /* JERRY_LINE_INFO */\n}",
        "begin_line": 2401,
        "end_line": 2496,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_set_function_name#2981",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_set_function_name (parser_context_t *context_p, /**< context */                           uint16_t function_literal_index, /**< function literal index */                           uint16_t name_index, /**< function name literal index */                           uint32_t status_flags) /**< status flags */",
        "snippet": "void\nparser_set_function_name (parser_context_t *context_p, /**< context */\n                          uint16_t function_literal_index, /**< function literal index */\n                          uint16_t name_index, /**< function name literal index */\n                          uint32_t status_flags) /**< status flags */\n{\n  ecma_compiled_code_t *bytecode_p;\n  bytecode_p = (ecma_compiled_code_t *) (PARSER_GET_LITERAL (function_literal_index)->u.bytecode_p);\n\n  parser_compiled_code_set_function_name (context_p, bytecode_p, name_index, status_flags);\n}",
        "begin_line": 2981,
        "end_line": 2991,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_update_forward_branch#310",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_update_forward_branch (parser_mem_page_t *page_p, /**< current page */                               size_t full_distance, /**< full distance */                               uint8_t bytes_copied_before_jump) /**< bytes copied before jump */",
        "snippet": "static size_t\nparser_update_forward_branch (parser_mem_page_t *page_p, /**< current page */\n                              size_t full_distance, /**< full distance */\n                              uint8_t bytes_copied_before_jump) /**< bytes copied before jump */\n{\n  size_t new_distance = 0;\n\n  while (full_distance > PARSER_CBC_STREAM_PAGE_SIZE)\n  {\n    new_distance += page_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] & CBC_LOWER_SEVEN_BIT_MASK;\n    full_distance -= PARSER_CBC_STREAM_PAGE_SIZE;\n    page_p = page_p->next_p;\n  }\n\n  new_distance += page_p->bytes[full_distance - 1] & CBC_LOWER_SEVEN_BIT_MASK;\n  return new_distance - bytes_copied_before_jump;\n}",
        "begin_line": 310,
        "end_line": 326,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-ops.scanner_check_directives#596",
        "src_path": "jerry-core/parser/js/js-scanner-ops.c",
        "class_name": "jerry-core.parser.js.js-scanner-ops",
        "signature": "jerry-core.parser.js.js-scanner-ops.scanner_check_directives (parser_context_t *context_p, /**< context */                           scanner_context_t *scanner_context_p) /**< scanner context */",
        "snippet": "void\nscanner_check_directives (parser_context_t *context_p, /**< context */\n                          scanner_context_t *scanner_context_p) /**< scanner context */\n{\n  scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n\n  while (context_p->token.type == LEXER_LITERAL\n         && context_p->token.lit_location.type == LEXER_STRING_LITERAL)\n  {\n    bool is_use_strict = false;\n\n    if (lexer_string_is_use_strict (context_p)\n        && !(context_p->status_flags & PARSER_IS_STRICT))\n    {\n      is_use_strict = true;\n      context_p->status_flags |= PARSER_IS_STRICT;\n    }\n\n    lexer_next_token (context_p);\n\n    if (!lexer_string_is_directive (context_p))\n    {\n      if (is_use_strict)\n      {\n        context_p->status_flags &= (uint32_t) ~PARSER_IS_STRICT;\n      }\n\n      /* The string is part of an expression statement. */\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      break;\n    }\n\n    if (is_use_strict)\n    {\n      scanner_context_p->active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_IS_STRICT;\n    }\n\n    if (context_p->token.type == LEXER_SEMICOLON)\n    {\n      lexer_next_token (context_p);\n    }\n  }\n}",
        "begin_line": 596,
        "end_line": 638,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_add_custom_literal#1374",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_add_custom_literal (parser_context_t *context_p, /**< context */                             scanner_literal_pool_t *literal_pool_p, /**< literal pool */                             const lexer_lit_location_t *literal_location_p) /**< literal */",
        "snippet": "lexer_lit_location_t *\nscanner_add_custom_literal (parser_context_t *context_p, /**< context */\n                            scanner_literal_pool_t *literal_pool_p, /**< literal pool */\n                            const lexer_lit_location_t *literal_location_p) /**< literal */\n{\n  while (true)\n  {\n    parser_list_iterator_t literal_iterator;\n    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);\n    lexer_lit_location_t *literal_p;\n\n    const uint8_t *char_p = literal_location_p->char_p;\n    prop_length_t length = literal_location_p->length;\n\n    if (JERRY_LIKELY (!(literal_location_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))\n    {\n      while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n      {\n        if (literal_p->length == length)\n        {\n          if (JERRY_LIKELY (!(literal_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))\n          {\n            if (memcmp (literal_p->char_p, char_p, length) == 0)\n            {\n              return literal_p;\n            }\n          }\n          else if (lexer_compare_identifier_to_string (literal_p, char_p, length))\n          {\n            /* The non-escaped version is preferred. */\n            literal_p->char_p = char_p;\n            literal_p->status_flags = LEXER_LIT_LOCATION_NO_OPTS;\n            return literal_p;\n          }\n        }\n      }\n    }\n    else\n    {\n      while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n      {\n        if (lexer_compare_identifiers (context_p, literal_p, literal_location_p))\n        {\n          return literal_p;\n        }\n      }\n    }\n\n#if JERRY_ESNEXT\n    if (JERRY_UNLIKELY (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CLASS_NAME))\n    {\n      literal_pool_p = literal_pool_p->prev_p;\n      continue;\n    }\n#endif /* JERRY_ESNEXT */\n\n    literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &literal_pool_p->literal_pool);\n    *literal_p = *literal_location_p;\n\n    literal_p->type = 0;\n\n    return literal_p;\n  }\n}",
        "begin_line": 1374,
        "end_line": 1437,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_add_literal#1444",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_add_literal (parser_context_t *context_p, /**< context */                      scanner_context_t *scanner_context_p) /**< scanner context */",
        "snippet": "extern inline lexer_lit_location_t * JERRY_ATTR_ALWAYS_INLINE\nscanner_add_literal (parser_context_t *context_p, /**< context */\n                     scanner_context_t *scanner_context_p) /**< scanner context */\n{\n  return scanner_add_custom_literal (context_p,\n                                     scanner_context_p->active_literal_pool_p,\n                                     &context_p->token.lit_location);\n}",
        "begin_line": 1444,
        "end_line": 1451,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_add_reference#1459",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_add_reference (parser_context_t *context_p, /**< context */                        scanner_context_t *scanner_context_p) /**< scanner context */",
        "snippet": "extern inline void JERRY_ATTR_ALWAYS_INLINE\nscanner_add_reference (parser_context_t *context_p, /**< context */\n                       scanner_context_t *scanner_context_p) /**< scanner context */\n{\n  lexer_lit_location_t *lit_location_p = scanner_add_custom_literal (context_p,\n                                                                     scanner_context_p->active_literal_pool_p,\n                                                                     &context_p->token.lit_location);\n#if JERRY_ESNEXT\n  lit_location_p->type |= SCANNER_LITERAL_IS_USED;\n#endif /* JERRY_ESNEXT */\n\n  if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)\n  {\n    lit_location_p->type |= SCANNER_LITERAL_NO_REG;\n  }\n\n  scanner_detect_eval_call (context_p, scanner_context_p);\n}",
        "begin_line": 1459,
        "end_line": 1476,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_check_variables#2234",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_check_variables (parser_context_t *context_p) /**< context */",
        "snippet": "void\nscanner_check_variables (parser_context_t *context_p) /**< context */\n{\n  scanner_info_t *info_p = context_p->next_scanner_info_p;\n  const uint8_t *next_data_p = (const uint8_t *) (info_p + 1);\n  lexer_lit_location_t literal;\n\n  JERRY_ASSERT (info_p->type == SCANNER_TYPE_FUNCTION);\n\n  literal.char_p = info_p->source_p - 1;\n\n  while (next_data_p[0] != SCANNER_STREAM_TYPE_END)\n  {\n    uint32_t type = next_data_p[0] & SCANNER_STREAM_TYPE_MASK;\n    const uint8_t *data_p = next_data_p;\n\n    JERRY_ASSERT (type != SCANNER_STREAM_TYPE_HOLE\n                  && !SCANNER_STREAM_TYPE_IS_ARG (type)\n                  && !SCANNER_STREAM_TYPE_IS_ARG_FUNC (type));\n    JERRY_ASSERT (data_p[0] & SCANNER_STREAM_NO_REG);\n\n    if (!(data_p[0] & SCANNER_STREAM_UINT16_DIFF))\n    {\n      if (data_p[2] != 0)\n      {\n        literal.char_p += data_p[2];\n        next_data_p += 2 + 1;\n      }\n      else\n      {\n        memcpy (&literal.char_p, data_p + 2 + 1, sizeof (uintptr_t));\n        next_data_p += 2 + 1 + sizeof (uintptr_t);\n      }\n    }\n    else\n    {\n      int32_t diff = ((int32_t) data_p[2]) | ((int32_t) data_p[3]) << 8;\n\n      if (diff <= (intptr_t) UINT8_MAX)\n      {\n        diff = -diff;\n      }\n\n      literal.char_p += diff;\n      next_data_p += 2 + 2;\n    }\n\n    literal.length = data_p[1];\n    literal.type = LEXER_IDENT_LITERAL;\n    literal.status_flags = ((data_p[0] & SCANNER_STREAM_HAS_ESCAPE) ? LEXER_LIT_LOCATION_HAS_ESCAPE\n                                                                    : LEXER_LIT_LOCATION_NO_OPTS);\n\n    lexer_construct_literal_object (context_p, &literal, LEXER_NEW_IDENT_LITERAL);\n    literal.char_p += data_p[1];\n\n#if JERRY_MODULE_SYSTEM\n    if (type == SCANNER_STREAM_TYPE_IMPORT)\n    {\n      continue;\n    }\n#endif /* JERRY_MODULE_SYSTEM */\n\n    context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_USED;\n\n    uint16_t opcode;\n    if (type == SCANNER_STREAM_TYPE_VAR || type == SCANNER_STREAM_TYPE_FUNC)\n    {\n      opcode = CBC_CHECK_VAR;\n    }\n    else\n    {\n      opcode = CBC_CHECK_LET;\n    }\n\n    parser_emit_cbc_literal (context_p, opcode, context_p->lit_object.index);\n  }\n\n  parser_flush_cbc (context_p);\n}",
        "begin_line": 2234,
        "end_line": 2312,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_create_variables#2318",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_create_variables (parser_context_t *context_p, /**< context */                           uint32_t option_flags) /**< combination of scanner_create_variables_flags_t bits */",
        "snippet": "void\nscanner_create_variables (parser_context_t *context_p, /**< context */\n                          uint32_t option_flags) /**< combination of scanner_create_variables_flags_t bits */\n{\n  scanner_info_t *info_p = context_p->next_scanner_info_p;\n  const uint8_t *next_data_p = (const uint8_t *) (info_p + 1);\n  uint8_t info_type = info_p->type;\n  uint8_t info_u8_arg = info_p->u8_arg;\n  lexer_lit_location_t literal;\n  parser_scope_stack_t *scope_stack_p;\n  parser_scope_stack_t *scope_stack_end_p;\n\n  JERRY_ASSERT (info_type == SCANNER_TYPE_FUNCTION || info_type == SCANNER_TYPE_BLOCK);\n  JERRY_ASSERT (!(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_ARGS)\n                || !(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY));\n  JERRY_ASSERT (info_type == SCANNER_TYPE_FUNCTION\n                || !(option_flags & (SCANNER_CREATE_VARS_IS_FUNCTION_ARGS | SCANNER_CREATE_VARS_IS_FUNCTION_BODY)));\n\n  if (info_type == SCANNER_TYPE_FUNCTION && !(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY))\n  {\n    JERRY_ASSERT (context_p->scope_stack_p == NULL);\n\n    size_t stack_size = info_p->u16_arg * sizeof (parser_scope_stack_t);\n    context_p->scope_stack_size = info_p->u16_arg;\n\n    scope_stack_p = NULL;\n\n    if (stack_size > 0)\n    {\n      scope_stack_p = (parser_scope_stack_t *) parser_malloc (context_p, stack_size);\n    }\n\n    context_p->scope_stack_p = scope_stack_p;\n    scope_stack_end_p = scope_stack_p + context_p->scope_stack_size;\n  }\n  else\n  {\n    JERRY_ASSERT (context_p->scope_stack_p != NULL || context_p->scope_stack_size == 0);\n\n    scope_stack_p = context_p->scope_stack_p;\n    scope_stack_end_p = scope_stack_p + context_p->scope_stack_size;\n    scope_stack_p += context_p->scope_stack_top;\n  }\n\n  uint32_t scope_stack_reg_top = context_p->scope_stack_reg_top;\n\n  literal.char_p = info_p->source_p - 1;\n\n  while (next_data_p[0] != SCANNER_STREAM_TYPE_END)\n  {\n    uint32_t type = next_data_p[0] & SCANNER_STREAM_TYPE_MASK;\n    const uint8_t *data_p = next_data_p;\n\n    JERRY_ASSERT ((option_flags & (SCANNER_CREATE_VARS_IS_FUNCTION_BODY | SCANNER_CREATE_VARS_IS_FUNCTION_ARGS))\n                  || (type != SCANNER_STREAM_TYPE_HOLE\n                      && !SCANNER_STREAM_TYPE_IS_ARG (type)\n                      && !SCANNER_STREAM_TYPE_IS_ARG_FUNC (type)));\n\n#if JERRY_MODULE_SYSTEM\n    JERRY_ASSERT (type != SCANNER_STREAM_TYPE_IMPORT || (data_p[0] & SCANNER_STREAM_NO_REG));\n#endif /* JERRY_MODULE_SYSTEM */\n\n    if (JERRY_UNLIKELY (type == SCANNER_STREAM_TYPE_HOLE))\n    {\n      JERRY_ASSERT (info_type == SCANNER_TYPE_FUNCTION);\n      next_data_p++;\n\n      if (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY)\n      {\n        continue;\n      }\n\n      uint8_t mask = SCANNER_FUNCTION_ARGUMENTS_NEEDED | SCANNER_FUNCTION_HAS_COMPLEX_ARGUMENT;\n\n      if (!(context_p->status_flags & PARSER_IS_STRICT)\n          && (info_u8_arg & mask) == SCANNER_FUNCTION_ARGUMENTS_NEEDED)\n      {\n        scanner_create_unused_literal (context_p, LEXER_FLAG_FUNCTION_ARGUMENT);\n      }\n\n      if (scope_stack_reg_top < PARSER_MAXIMUM_NUMBER_OF_REGISTERS)\n      {\n        scope_stack_reg_top++;\n      }\n      continue;\n    }\n\n    if (JERRY_UNLIKELY (SCANNER_STREAM_TYPE_IS_ARGUMENTS (type)))\n    {\n      JERRY_ASSERT (info_type == SCANNER_TYPE_FUNCTION);\n      next_data_p++;\n\n      if (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY)\n      {\n        continue;\n      }\n\n      context_p->status_flags |= PARSER_ARGUMENTS_NEEDED;\n\n      if (JERRY_UNLIKELY (scope_stack_p >= scope_stack_end_p))\n      {\n        JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);\n        parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);\n      }\n\n      lexer_construct_literal_object (context_p, &lexer_arguments_literal, LEXER_NEW_IDENT_LITERAL);\n      scope_stack_p->map_from = context_p->lit_object.index;\n\n      uint16_t map_to;\n\n      if (!(data_p[0] & SCANNER_STREAM_NO_REG)\n          && scope_stack_reg_top < PARSER_MAXIMUM_NUMBER_OF_REGISTERS)\n      {\n        map_to = (uint16_t) (PARSER_REGISTER_START + scope_stack_reg_top);\n\n#if JERRY_ESNEXT\n        scope_stack_p->map_to = (uint16_t) (scope_stack_reg_top + 1);\n#endif /* JERRY_ESNEXT */\n\n        scope_stack_reg_top++;\n      }\n      else\n      {\n        context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_USED;\n        map_to = context_p->lit_object.index;\n\n        context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;\n\n#if JERRY_ESNEXT\n        if (data_p[0] & SCANNER_STREAM_LOCAL_ARGUMENTS)\n        {\n          context_p->status_flags |= PARSER_LEXICAL_BLOCK_NEEDED;\n        }\n\n        scope_stack_p->map_to = 0;\n#endif /* JERRY_ESNEXT */\n      }\n\n#if !JERRY_ESNEXT\n      scope_stack_p->map_to = map_to;\n#endif /* !JERRY_ESNEXT */\n      scope_stack_p++;\n\n#if JERRY_PARSER_DUMP_BYTE_CODE\n      context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);\n#endif /* JERRY_PARSER_DUMP_BYTE_CODE */\n\n      parser_emit_cbc_ext_literal (context_p, CBC_EXT_CREATE_ARGUMENTS, map_to);\n\n#if JERRY_ESNEXT\n      if (type == SCANNER_STREAM_TYPE_ARGUMENTS_FUNC)\n      {\n        if (JERRY_UNLIKELY (scope_stack_p >= scope_stack_end_p))\n        {\n          JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);\n          parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);\n        }\n\n        scope_stack_p->map_from = PARSER_SCOPE_STACK_FUNC;\n        scope_stack_p->map_to = context_p->literal_count;\n        scope_stack_p++;\n\n        scanner_create_unused_literal (context_p, 0);\n      }\n#endif /* JERRY_ESNEXT */\n\n      if (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_ARGS)\n      {\n        break;\n      }\n      continue;\n    }\n\n    JERRY_ASSERT (context_p->scope_stack_size != 0);\n\n    if (!(data_p[0] & SCANNER_STREAM_UINT16_DIFF))\n    {\n      if (data_p[2] != 0)\n      {\n        literal.char_p += data_p[2];\n        next_data_p += 2 + 1;\n      }\n      else\n      {\n        memcpy (&literal.char_p, data_p + 2 + 1, sizeof (uintptr_t));\n        next_data_p += 2 + 1 + sizeof (uintptr_t);\n      }\n    }\n    else\n    {\n      int32_t diff = ((int32_t) data_p[2]) | ((int32_t) data_p[3]) << 8;\n\n      if (diff <= (intptr_t) UINT8_MAX)\n      {\n        diff = -diff;\n      }\n\n      literal.char_p += diff;\n      next_data_p += 2 + 2;\n    }\n\n    if (SCANNER_STREAM_TYPE_IS_ARG (type))\n    {\n      if (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY)\n      {\n#if JERRY_ESNEXT\n        if ((context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED)\n            && (type == SCANNER_STREAM_TYPE_ARG_VAR || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR))\n        {\n          literal.length = data_p[1];\n          literal.type = LEXER_IDENT_LITERAL;\n          literal.status_flags = ((data_p[0] & SCANNER_STREAM_HAS_ESCAPE) ? LEXER_LIT_LOCATION_HAS_ESCAPE\n                                                                          : LEXER_LIT_LOCATION_NO_OPTS);\n\n          /* Literal must be exists. */\n          lexer_construct_literal_object (context_p, &literal, LEXER_IDENT_LITERAL);\n\n          if (context_p->lit_object.index < PARSER_REGISTER_START)\n          {\n            parser_emit_cbc_ext_literal_from_token (context_p, CBC_EXT_COPY_FROM_ARG);\n          }\n        }\n#endif /* JERRY_ESNEXT */\n\n        literal.char_p += data_p[1];\n        continue;\n      }\n    }\n    else if ((option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_ARGS)\n             && !SCANNER_STREAM_TYPE_IS_ARG_FUNC (type))\n    {\n      /* Function arguments must come first. */\n      break;\n    }\n\n    literal.length = data_p[1];\n    literal.type = LEXER_IDENT_LITERAL;\n    literal.status_flags = ((data_p[0] & SCANNER_STREAM_HAS_ESCAPE) ? LEXER_LIT_LOCATION_HAS_ESCAPE\n                                                                    : LEXER_LIT_LOCATION_NO_OPTS);\n\n    lexer_construct_literal_object (context_p, &literal, LEXER_NEW_IDENT_LITERAL);\n    literal.char_p += data_p[1];\n\n    if (SCANNER_STREAM_TYPE_IS_ARG_FUNC (type) && (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY))\n    {\n      JERRY_ASSERT (scope_stack_p >= context_p->scope_stack_p + 2);\n      JERRY_ASSERT (context_p->status_flags & PARSER_IS_FUNCTION);\n#if JERRY_ESNEXT\n      JERRY_ASSERT (!(context_p->status_flags & PARSER_FUNCTION_IS_PARSING_ARGS));\n#endif /* JERRY_ESNEXT */\n\n      parser_scope_stack_t *function_map_p = scope_stack_p - 2;\n      uint16_t literal_index = context_p->lit_object.index;\n\n      while (literal_index != function_map_p->map_from)\n      {\n        function_map_p--;\n\n        JERRY_ASSERT (function_map_p >= context_p->scope_stack_p);\n      }\n\n      JERRY_ASSERT (function_map_p[1].map_from == PARSER_SCOPE_STACK_FUNC);\n\n      cbc_opcode_t opcode = CBC_SET_VAR_FUNC;\n\n#if JERRY_ESNEXT\n      if (JERRY_UNLIKELY (context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED)\n          && (function_map_p[0].map_to & PARSER_SCOPE_STACK_REGISTER_MASK) == 0)\n      {\n        opcode = CBC_INIT_ARG_OR_FUNC;\n      }\n#endif /* JERRY_ESNEXT */\n\n      parser_emit_cbc_literal_value (context_p,\n                                     (uint16_t) opcode,\n                                     function_map_p[1].map_to,\n                                     scanner_decode_map_to (function_map_p));\n      continue;\n    }\n\n    if (JERRY_UNLIKELY (scope_stack_p >= scope_stack_end_p))\n    {\n      JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);\n      parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);\n    }\n\n    scope_stack_p->map_from = context_p->lit_object.index;\n\n#if JERRY_ESNEXT\n    if (info_type == SCANNER_TYPE_FUNCTION)\n    {\n      if (type != SCANNER_STREAM_TYPE_LET\n#if JERRY_MODULE_SYSTEM\n          && type != SCANNER_STREAM_TYPE_IMPORT\n#endif /* JERRY_MODULE_SYSTEM */\n          && type != SCANNER_STREAM_TYPE_CONST)\n      {\n        context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_GLOBAL;\n      }\n    }\n#endif /* JERRY_ESNEXT */\n\n    uint16_t map_to;\n    uint16_t func_init_opcode = CBC_INIT_ARG_OR_FUNC;\n\n    if (!(data_p[0] & SCANNER_STREAM_NO_REG)\n        && scope_stack_reg_top < PARSER_MAXIMUM_NUMBER_OF_REGISTERS)\n    {\n      map_to = (uint16_t) (PARSER_REGISTER_START + scope_stack_reg_top);\n\n#if JERRY_ESNEXT\n      scope_stack_p->map_to = (uint16_t) (scope_stack_reg_top + 1);\n#else /* !JERRY_ESNEXT */\n      scope_stack_p->map_to = map_to;\n#endif /* JERRY_ESNEXT */\n\n      scope_stack_reg_top++;\n#if JERRY_ESNEXT\n      switch (type)\n      {\n        case SCANNER_STREAM_TYPE_CONST:\n        {\n          scope_stack_p->map_to |= PARSER_SCOPE_STACK_IS_CONST_REG;\n          /* FALLTHRU */\n        }\n        case SCANNER_STREAM_TYPE_LET:\n        case SCANNER_STREAM_TYPE_ARG:\n        case SCANNER_STREAM_TYPE_ARG_VAR:\n        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:\n        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR:\n        case SCANNER_STREAM_TYPE_ARG_FUNC:\n        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:\n        {\n          scope_stack_p->map_to |= PARSER_SCOPE_STACK_NO_FUNCTION_COPY;\n          break;\n        }\n      }\n\n      func_init_opcode = CBC_SET_VAR_FUNC;\n#endif /* JERRY_ESNEXT */\n    }\n    else\n    {\n      context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_USED;\n      map_to = context_p->lit_object.index;\n\n#if JERRY_ESNEXT\n      uint16_t scope_stack_map_to = 0;\n#else /* !JERRY_ESNEXT */\n      scope_stack_p->map_to = map_to;\n#endif /* JERRY_ESNEXT */\n\n      if (info_type == SCANNER_TYPE_FUNCTION)\n      {\n        context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;\n      }\n\n      switch (type)\n      {\n#if JERRY_ESNEXT\n        case SCANNER_STREAM_TYPE_LET:\n        case SCANNER_STREAM_TYPE_CONST:\n        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:\n        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR:\n        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:\n        {\n          scope_stack_map_to |= PARSER_SCOPE_STACK_NO_FUNCTION_COPY;\n\n          if (!(data_p[0] & SCANNER_STREAM_EARLY_CREATE))\n          {\n            break;\n          }\n          scope_stack_map_to |= PARSER_SCOPE_STACK_IS_LOCAL_CREATED;\n          /* FALLTHRU */\n        }\n        case SCANNER_STREAM_TYPE_LOCAL:\n#endif /* JERRY_ESNEXT */\n        case SCANNER_STREAM_TYPE_VAR:\n        {\n#if JERRY_PARSER_DUMP_BYTE_CODE\n          context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);\n#endif /* JERRY_PARSER_DUMP_BYTE_CODE */\n\n#if JERRY_ESNEXT\n          uint16_t opcode;\n\n          switch (type)\n          {\n            case SCANNER_STREAM_TYPE_LET:\n            {\n              opcode = CBC_CREATE_LET;\n              break;\n            }\n            case SCANNER_STREAM_TYPE_CONST:\n            {\n              opcode = CBC_CREATE_CONST;\n              break;\n            }\n            case SCANNER_STREAM_TYPE_VAR:\n            {\n              opcode = CBC_CREATE_VAR;\n\n              if (option_flags & SCANNER_CREATE_VARS_IS_SCRIPT)\n              {\n                opcode = CBC_CREATE_VAR_EVAL;\n\n                if ((context_p->global_status_flags & ECMA_PARSE_FUNCTION_CONTEXT)\n                    && !(context_p->status_flags & PARSER_IS_STRICT))\n                {\n                  opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_CREATE_VAR_EVAL);\n                }\n              }\n              break;\n            }\n            default:\n            {\n              JERRY_ASSERT (type == SCANNER_STREAM_TYPE_LOCAL\n                            || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG\n                            || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR\n                            || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC);\n\n              opcode = CBC_CREATE_LOCAL;\n              break;\n            }\n          }\n#else /* !JERRY_ESNEXT */\n          uint16_t opcode = ((option_flags & SCANNER_CREATE_VARS_IS_SCRIPT) ? CBC_CREATE_VAR_EVAL\n                                                                            : CBC_CREATE_VAR);\n#endif /* JERRY_ESNEXT */\n\n          parser_emit_cbc_literal (context_p, opcode, map_to);\n          break;\n        }\n        case SCANNER_STREAM_TYPE_ARG:\n#if JERRY_ESNEXT\n        case SCANNER_STREAM_TYPE_ARG_VAR:\n#endif /* JERRY_ESNEXT */\n        case SCANNER_STREAM_TYPE_ARG_FUNC:\n        {\n#if JERRY_PARSER_DUMP_BYTE_CODE\n          context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);\n#endif /* JERRY_PARSER_DUMP_BYTE_CODE */\n\n#if JERRY_ESNEXT\n          scope_stack_map_to |= PARSER_SCOPE_STACK_NO_FUNCTION_COPY;\n\n          /* Argument initializers of functions with simple arguments (e.g. function f(a,b,a) {}) are\n           * generated here. The other initializers are handled by parser_parse_function_arguments(). */\n          if (!(info_u8_arg & SCANNER_FUNCTION_HAS_COMPLEX_ARGUMENT))\n          {\n#endif /* JERRY_ESNEXT */\n            parser_emit_cbc_literal_value (context_p,\n                                           CBC_INIT_ARG_OR_FUNC,\n                                           (uint16_t) (PARSER_REGISTER_START + scope_stack_reg_top),\n                                           map_to);\n#if JERRY_ESNEXT\n          }\n          else if (data_p[0] & SCANNER_STREAM_EARLY_CREATE)\n          {\n            parser_emit_cbc_literal (context_p, CBC_CREATE_LOCAL, map_to);\n            scope_stack_map_to |= PARSER_SCOPE_STACK_IS_LOCAL_CREATED;\n          }\n#endif /* JERRY_ESNEXT */\n\n          if (scope_stack_reg_top < PARSER_MAXIMUM_NUMBER_OF_REGISTERS)\n          {\n            scope_stack_reg_top++;\n          }\n          break;\n        }\n      }\n\n#if JERRY_ESNEXT\n      scope_stack_p->map_to = scope_stack_map_to;\n#endif /* JERRY_ESNEXT */\n    }\n\n    scope_stack_p++;\n\n    if (!SCANNER_STREAM_TYPE_IS_FUNCTION (type))\n    {\n      continue;\n    }\n\n    if (JERRY_UNLIKELY (scope_stack_p >= scope_stack_end_p))\n    {\n      JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);\n      parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);\n    }\n\n#if JERRY_PARSER_DUMP_BYTE_CODE\n    context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);\n#endif /* JERRY_PARSER_DUMP_BYTE_CODE */\n\n    if (!SCANNER_STREAM_TYPE_IS_ARG_FUNC (type))\n    {\n      if (func_init_opcode == CBC_INIT_ARG_OR_FUNC && (option_flags & SCANNER_CREATE_VARS_IS_SCRIPT))\n      {\n#if JERRY_ESNEXT\n        literal.char_p -= data_p[1];\n\n        if (!scanner_scope_find_lexical_declaration (context_p, &literal))\n        {\n          func_init_opcode = CBC_CREATE_VAR_FUNC_EVAL;\n\n          if (context_p->global_status_flags & ECMA_PARSE_FUNCTION_CONTEXT)\n          {\n            func_init_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_CREATE_VAR_FUNC_EVAL);\n          }\n        }\n        literal.char_p += data_p[1];\n#else /* !JERRY_ESNEXT */\n        func_init_opcode = CBC_CREATE_VAR_FUNC_EVAL;\n#endif /* JERRY_ESNEXT */\n      }\n\n      parser_emit_cbc_literal_value (context_p, func_init_opcode, context_p->literal_count, map_to);\n    }\n\n    scope_stack_p->map_from = PARSER_SCOPE_STACK_FUNC;\n    scope_stack_p->map_to = context_p->literal_count;\n    scope_stack_p++;\n\n    scanner_create_unused_literal (context_p, 0);\n  }\n\n  context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);\n  context_p->scope_stack_reg_top = (uint16_t) scope_stack_reg_top;\n\n#if JERRY_ESNEXT\n  if (info_type == SCANNER_TYPE_FUNCTION)\n  {\n    context_p->scope_stack_global_end = context_p->scope_stack_top;\n  }\n#endif /* JERRY_ESNEXT */\n\n  if (context_p->register_count < scope_stack_reg_top)\n  {\n    context_p->register_count = (uint16_t) scope_stack_reg_top;\n  }\n\n  if (!(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_ARGS))\n  {\n    scanner_release_next (context_p, (size_t) (next_data_p + 1 - ((const uint8_t *) info_p)));\n  }\n  parser_flush_cbc (context_p);\n}",
        "begin_line": 2318,
        "end_line": 2864,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_decode_map_to#2893",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_decode_map_to (parser_scope_stack_t *stack_item_p) /**< scope stack item */",
        "snippet": "extern inline uint16_t JERRY_ATTR_ALWAYS_INLINE\nscanner_decode_map_to (parser_scope_stack_t *stack_item_p) /**< scope stack item */\n{\n  JERRY_ASSERT (stack_item_p->map_from != PARSER_SCOPE_STACK_FUNC);\n\n#if JERRY_ESNEXT\n  uint16_t value = (stack_item_p->map_to & PARSER_SCOPE_STACK_REGISTER_MASK);\n  return (value == 0) ? stack_item_p->map_from : (uint16_t) (value + (PARSER_REGISTER_START - 1));\n#else /* !JERRY_ESNEXT */\n  return stack_item_p->map_to;\n#endif /* JERRY_ESNEXT */\n}",
        "begin_line": 2893,
        "end_line": 2904,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_detect_eval_call#1554",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_detect_eval_call (parser_context_t *context_p, /**< context */                           scanner_context_t *scanner_context_p) /**< scanner context */",
        "snippet": "void\nscanner_detect_eval_call (parser_context_t *context_p, /**< context */\n                          scanner_context_t *scanner_context_p) /**< scanner context */\n{\n  if (context_p->token.keyword_type == LEXER_KEYW_EVAL\n      && lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))\n  {\n#if JERRY_ESNEXT\n    const uint16_t flags = (uint16_t) (SCANNER_LITERAL_POOL_CAN_EVAL | SCANNER_LITERAL_POOL_HAS_SUPER_REFERENCE);\n#else /* !JERRY_ESNEXT */\n    const uint16_t flags = SCANNER_LITERAL_POOL_CAN_EVAL;\n#endif /* JERRY_ESNEXT */\n\n    scanner_context_p->active_literal_pool_p->status_flags |= flags;\n  }\n}",
        "begin_line": 1554,
        "end_line": 1569,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_detect_invalid_var#1576",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_detect_invalid_var (parser_context_t *context_p, /**< context */                             scanner_context_t *scanner_context_p, /**< scanner context */                             lexer_lit_location_t *var_literal_p) /**< var literal */",
        "snippet": "void\nscanner_detect_invalid_var (parser_context_t *context_p, /**< context */\n                            scanner_context_t *scanner_context_p, /**< scanner context */\n                            lexer_lit_location_t *var_literal_p) /**< var literal */\n{\n  if (var_literal_p->type & SCANNER_LITERAL_IS_LOCAL\n      && !(var_literal_p->type & (SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_ARG))\n      && (var_literal_p->type & SCANNER_LITERAL_IS_LOCAL) != SCANNER_LITERAL_IS_LOCAL)\n  {\n    scanner_raise_redeclaration_error (context_p);\n  }\n\n  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;\n\n  if (!(literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION)\n      && ((var_literal_p->type & SCANNER_LITERAL_IS_LOCAL_FUNC) == SCANNER_LITERAL_IS_LOCAL_FUNC))\n  {\n    scanner_raise_redeclaration_error (context_p);\n  }\n\n  const uint8_t *char_p = var_literal_p->char_p;\n  prop_length_t length = var_literal_p->length;\n\n  while (!(literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION))\n  {\n    literal_pool_p = literal_pool_p->prev_p;\n\n    parser_list_iterator_t literal_iterator;\n    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);\n    lexer_lit_location_t *literal_p;\n\n    if (JERRY_LIKELY (!(context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))\n    {\n      while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n      {\n        if ((literal_p->type & SCANNER_LITERAL_IS_LOCAL)\n            && !(literal_p->type & SCANNER_LITERAL_IS_ARG)\n            && !((literal_p->type & SCANNER_LITERAL_IS_FUNC)\n                 && (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION))\n            && (literal_p->type & SCANNER_LITERAL_IS_LOCAL) != SCANNER_LITERAL_IS_LOCAL\n            && literal_p->length == length)\n        {\n          if (JERRY_LIKELY (!(literal_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))\n          {\n            if (memcmp (literal_p->char_p, char_p, length) == 0)\n            {\n              scanner_raise_redeclaration_error (context_p);\n              return;\n            }\n          }\n          else if (lexer_compare_identifier_to_string (literal_p, char_p, length))\n          {\n            scanner_raise_redeclaration_error (context_p);\n            return;\n          }\n        }\n      }\n    }\n    else\n    {\n      while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n      {\n        if ((literal_p->type & SCANNER_LITERAL_IS_LOCAL)\n            && !(literal_p->type & SCANNER_LITERAL_IS_ARG)\n            && !((literal_p->type & SCANNER_LITERAL_IS_FUNC)\n                 && (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION))\n            && (literal_p->type & SCANNER_LITERAL_IS_LOCAL) != SCANNER_LITERAL_IS_LOCAL\n            && lexer_compare_identifiers (context_p, literal_p, var_literal_p))\n        {\n          scanner_raise_redeclaration_error (context_p);\n          return;\n        }\n      }\n    }\n  }\n\n  if (scanner_scope_find_lexical_declaration (context_p, var_literal_p))\n  {\n    scanner_raise_redeclaration_error (context_p);\n  }\n}",
        "begin_line": 1576,
        "end_line": 1656,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_filter_arguments#1220",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_filter_arguments (parser_context_t *context_p, /**< context */                           scanner_context_t *scanner_context_p) /**< scanner context */",
        "snippet": "void\nscanner_filter_arguments (parser_context_t *context_p, /**< context */\n                          scanner_context_t *scanner_context_p) /**< scanner context */\n{\n  /* Fast case: check whether all literals are arguments. */\n  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;\n  scanner_literal_pool_t *prev_literal_pool_p = literal_pool_p->prev_p;\n  parser_list_iterator_t literal_iterator;\n  lexer_lit_location_t *literal_p;\n  bool can_eval = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) != 0;\n  bool has_arguments = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS) == 0;\n\n  JERRY_ASSERT (SCANNER_LITERAL_POOL_MAY_HAVE_ARGUMENTS (literal_pool_p->status_flags));\n\n  if (can_eval)\n  {\n    if (prev_literal_pool_p != NULL)\n    {\n      prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;\n    }\n\n    if (has_arguments)\n    {\n      literal_pool_p->status_flags |= (SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS | SCANNER_LITERAL_POOL_NO_ARGUMENTS);\n    }\n  }\n\n  literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_CAN_EVAL;\n\n  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);\n\n  while (true)\n  {\n    literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator);\n\n    if (literal_p == NULL)\n    {\n      return;\n    }\n\n    if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE))\n    {\n      literal_p->type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE;\n    }\n\n    uint8_t type = literal_p->type;\n    const uint8_t mask = (SCANNER_LITERAL_IS_ARG\n                          | SCANNER_LITERAL_IS_DESTRUCTURED_ARG\n                          | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG);\n\n    if ((type & mask) != SCANNER_LITERAL_IS_ARG)\n    {\n      break;\n    }\n  }\n\n  /* Destructured args are placed after the other arguments because of register assignments. */\n  bool has_destructured_arg = false;\n  scanner_literal_pool_t *new_literal_pool_p;\n\n  new_literal_pool_p = (scanner_literal_pool_t *) scanner_malloc (context_p, sizeof (scanner_literal_pool_t));\n\n  new_literal_pool_p->prev_p = literal_pool_p;\n  scanner_context_p->active_literal_pool_p = new_literal_pool_p;\n\n  *new_literal_pool_p = *literal_pool_p;\n  parser_list_init (&new_literal_pool_p->literal_pool,\n                    sizeof (lexer_lit_location_t),\n                    (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_lit_location_t)));\n\n  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);\n\n  while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n    uint8_t type = literal_p->type;\n\n    if (type & SCANNER_LITERAL_IS_ARG)\n    {\n      if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE))\n      {\n        type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE;\n        literal_p->type = type;\n      }\n\n      if (type & (SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG))\n      {\n        has_destructured_arg = true;\n\n        if (type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG)\n        {\n          continue;\n        }\n\n        type &= (uint8_t) ~SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG;\n        type |= SCANNER_LITERAL_IS_DESTRUCTURED_ARG;\n\n        literal_p->type = type;\n        continue;\n      }\n\n      lexer_lit_location_t *new_literal_p;\n      new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool);\n      *new_literal_p = *literal_p;\n    }\n    else if (has_arguments && scanner_literal_is_arguments (literal_p))\n    {\n      new_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS;\n\n      if (type & SCANNER_LITERAL_NO_REG)\n      {\n        new_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_NO_ARGUMENTS;\n      }\n    }\n    else if (prev_literal_pool_p != NULL)\n    {\n      /* Propagate literal to upper level. */\n      lexer_lit_location_t *literal_location_p = scanner_add_custom_literal (context_p,\n                                                                             prev_literal_pool_p,\n                                                                             literal_p);\n      type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_IS_USED;\n      literal_location_p->type |= type;\n    }\n  }\n\n  if (has_destructured_arg)\n  {\n    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);\n\n    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n    {\n      const uint8_t expected_flags = SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG;\n\n      if ((literal_p->type & expected_flags) == expected_flags)\n      {\n        lexer_lit_location_t *new_literal_p;\n        new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool);\n        *new_literal_p = *literal_p;\n      }\n    }\n  }\n\n  new_literal_pool_p->prev_p = prev_literal_pool_p;\n\n  parser_list_free (&literal_pool_p->literal_pool);\n  scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));\n}",
        "begin_line": 1220,
        "end_line": 1365,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_free#118",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_free (void *ptr, /**< pointer to free */               size_t size) /**< size of the memory block */",
        "snippet": "extern inline void JERRY_ATTR_ALWAYS_INLINE\nscanner_free (void *ptr, /**< pointer to free */\n              size_t size) /**< size of the memory block */\n{\n  jmem_heap_free_block (ptr, size);\n}",
        "begin_line": 118,
        "end_line": 123,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_get_location#2869",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_get_location (scanner_location_t *location_p, /**< location */                       parser_context_t *context_p) /**< context */",
        "snippet": "extern inline void JERRY_ATTR_ALWAYS_INLINE\nscanner_get_location (scanner_location_t *location_p, /**< location */\n                      parser_context_t *context_p) /**< context */\n{\n  location_p->source_p = context_p->source_p;\n  location_p->line = context_p->line;\n  location_p->column = context_p->column;\n}",
        "begin_line": 2869,
        "end_line": 2876,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_insert_info#193",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_insert_info (parser_context_t *context_p, /**< context */                      const uint8_t *source_p, /**< triggering position */                      size_t size) /**< size of the memory block */",
        "snippet": "scanner_info_t *\nscanner_insert_info (parser_context_t *context_p, /**< context */\n                     const uint8_t *source_p, /**< triggering position */\n                     size_t size) /**< size of the memory block */\n{\n  scanner_info_t *new_scanner_info_p = (scanner_info_t *) scanner_malloc (context_p, size);\n  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;\n  scanner_info_t *prev_scanner_info_p = NULL;\n\n  JERRY_ASSERT (scanner_info_p != NULL);\n  JERRY_ASSERT (source_p != NULL);\n\n  new_scanner_info_p->source_p = source_p;\n\n  while (source_p < scanner_info_p->source_p)\n  {\n    prev_scanner_info_p = scanner_info_p;\n    scanner_info_p = scanner_info_p->next_p;\n\n    JERRY_ASSERT (scanner_info_p != NULL);\n  }\n\n  /* Multiple scanner info blocks cannot be assigned to the same position. */\n  JERRY_ASSERT (source_p != scanner_info_p->source_p);\n\n  new_scanner_info_p->next_p = scanner_info_p;\n\n  if (JERRY_LIKELY (prev_scanner_info_p == NULL))\n  {\n    context_p->next_scanner_info_p = new_scanner_info_p;\n  }\n  else\n  {\n    prev_scanner_info_p->next_p = new_scanner_info_p;\n  }\n\n  return new_scanner_info_p;\n}",
        "begin_line": 193,
        "end_line": 230,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_is_context_needed#1990",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_is_context_needed (parser_context_t *context_p, /**< context */                            parser_check_context_type_t check_type) /**< context type */",
        "snippet": "bool\nscanner_is_context_needed (parser_context_t *context_p, /**< context */\n                           parser_check_context_type_t check_type) /**< context type */\n{\n  scanner_info_t *info_p = context_p->next_scanner_info_p;\n  const uint8_t *data_p = (const uint8_t *) (info_p + 1);\n\n  JERRY_UNUSED (check_type);\n\n#if JERRY_ESNEXT\n  JERRY_ASSERT ((check_type == PARSER_CHECK_BLOCK_CONTEXT ? info_p->type == SCANNER_TYPE_BLOCK\n                                                          : info_p->type == SCANNER_TYPE_FUNCTION));\n\n  uint32_t scope_stack_reg_top = (check_type != PARSER_CHECK_GLOBAL_CONTEXT ? context_p->scope_stack_reg_top\n                                                                            : 0);\n#else /* !JERRY_ESNEXT */\n  JERRY_ASSERT (check_type == PARSER_CHECK_BLOCK_CONTEXT);\n  JERRY_ASSERT (info_p->type == SCANNER_TYPE_BLOCK);\n\n  uint32_t scope_stack_reg_top = context_p->scope_stack_reg_top;\n#endif /* !JERRY_NDEBUG */\n\n  while (data_p[0] != SCANNER_STREAM_TYPE_END)\n  {\n    uint8_t data = data_p[0];\n\n#if JERRY_ESNEXT\n    uint32_t type = data & SCANNER_STREAM_TYPE_MASK;\n\n    if (JERRY_UNLIKELY (check_type == PARSER_CHECK_FUNCTION_CONTEXT))\n    {\n      if (JERRY_UNLIKELY (type == SCANNER_STREAM_TYPE_HOLE))\n      {\n        data_p++;\n        continue;\n      }\n\n      if (JERRY_UNLIKELY (SCANNER_STREAM_TYPE_IS_ARGUMENTS (type)))\n      {\n        if ((data & SCANNER_STREAM_NO_REG)\n            || scope_stack_reg_top >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)\n        {\n          return true;\n        }\n\n        scope_stack_reg_top++;\n        data_p++;\n        continue;\n      }\n    }\n\n#ifndef JERRY_NDEBUG\n    if (check_type == PARSER_CHECK_BLOCK_CONTEXT)\n    {\n      JERRY_ASSERT (type == SCANNER_STREAM_TYPE_VAR\n                    || type == SCANNER_STREAM_TYPE_LET\n                    || type == SCANNER_STREAM_TYPE_CONST\n                    || type == SCANNER_STREAM_TYPE_LOCAL\n                    || type == SCANNER_STREAM_TYPE_FUNC);\n    }\n    else if (check_type == PARSER_CHECK_GLOBAL_CONTEXT)\n    {\n#if JERRY_MODULE_SYSTEM\n      const bool is_import = (type == SCANNER_STREAM_TYPE_IMPORT);\n#else\n      const bool is_import = true;\n#endif /* JERRY_MODULE_SYSTEM */\n\n      /* FIXME: a private declarative lexical environment should always be present\n       * for modules. Remove SCANNER_STREAM_TYPE_IMPORT after it is implemented. */\n      JERRY_ASSERT (type == SCANNER_STREAM_TYPE_VAR\n                    || type == SCANNER_STREAM_TYPE_LET\n                    || type == SCANNER_STREAM_TYPE_CONST\n                    || type == SCANNER_STREAM_TYPE_FUNC\n                    || is_import);\n\n      /* Only let/const can be stored in registers */\n      JERRY_ASSERT ((data & SCANNER_STREAM_NO_REG)\n                    || (type == SCANNER_STREAM_TYPE_FUNC && (context_p->global_status_flags & ECMA_PARSE_DIRECT_EVAL))\n                    || type == SCANNER_STREAM_TYPE_LET\n                    || type == SCANNER_STREAM_TYPE_CONST);\n    }\n    else\n    {\n      JERRY_ASSERT (check_type == PARSER_CHECK_FUNCTION_CONTEXT);\n\n      JERRY_ASSERT (type == SCANNER_STREAM_TYPE_VAR\n                    || type == SCANNER_STREAM_TYPE_LET\n                    || type == SCANNER_STREAM_TYPE_CONST\n                    || type == SCANNER_STREAM_TYPE_LOCAL\n                    || type == SCANNER_STREAM_TYPE_ARG\n                    || type == SCANNER_STREAM_TYPE_ARG_VAR\n                    || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG\n                    || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR\n                    || type == SCANNER_STREAM_TYPE_ARG_FUNC\n                    || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC\n                    || type == SCANNER_STREAM_TYPE_FUNC);\n    }\n#endif /* !JERRY_NDEBUG */\n\n#else /* !JERRY_ESNEXT */\n    JERRY_ASSERT ((data & SCANNER_STREAM_TYPE_MASK) == SCANNER_STREAM_TYPE_VAR);\n#endif /* JERRY_ESNEXT */\n\n    if (!(data & SCANNER_STREAM_UINT16_DIFF))\n    {\n      if (data_p[2] != 0)\n      {\n        data_p += 2 + 1;\n      }\n      else\n      {\n        data_p += 2 + 1 + sizeof (const uint8_t *);\n      }\n    }\n    else\n    {\n      data_p += 2 + 2;\n    }\n\n#if JERRY_ESNEXT\n#if JERRY_MODULE_SYSTEM\n    const bool is_import = (type == SCANNER_STREAM_TYPE_IMPORT);\n#else /* !JERRY_MODULE_SYSTEM */\n    const bool is_import = false;\n#endif /* JERRY_MODULE_SYSTEM */\n\n    if (JERRY_UNLIKELY (check_type == PARSER_CHECK_GLOBAL_CONTEXT)\n        && (type == SCANNER_STREAM_TYPE_VAR\n            || (type == SCANNER_STREAM_TYPE_FUNC && !(context_p->global_status_flags & ECMA_PARSE_EVAL))\n            || is_import))\n    {\n      continue;\n    }\n\n    if (JERRY_UNLIKELY (check_type == PARSER_CHECK_FUNCTION_CONTEXT))\n    {\n      if (SCANNER_STREAM_TYPE_IS_ARG_FUNC (type)\n          || type == SCANNER_STREAM_TYPE_ARG_VAR\n          || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR)\n      {\n        /* The return value is true, if the variable is stored in the lexical environment\n         * or all registers have already been used for function arguments. This can be\n         * inprecise in the latter case, but this is a very rare corner case. A more\n         * sophisticated check would require to decode the literal. */\n        if ((data & SCANNER_STREAM_NO_REG)\n            || scope_stack_reg_top >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)\n        {\n          return true;\n        }\n        continue;\n      }\n\n      if (SCANNER_STREAM_TYPE_IS_ARG (type))\n      {\n        continue;\n      }\n    }\n#endif /* JERRY_ESNEXT */\n\n    if ((data & SCANNER_STREAM_NO_REG)\n        || scope_stack_reg_top >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)\n    {\n      return true;\n    }\n\n    scope_stack_reg_top++;\n  }\n\n  return false;\n}",
        "begin_line": 1990,
        "end_line": 2160,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_literal_is_arguments#544",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_literal_is_arguments (lexer_lit_location_t *literal_p) /**< literal */",
        "snippet": "static inline bool JERRY_ATTR_ALWAYS_INLINE\nscanner_literal_is_arguments (lexer_lit_location_t *literal_p) /**< literal */\n{\n  return lexer_compare_identifier_to_string (literal_p, (const uint8_t *) \"arguments\", 9);\n}",
        "begin_line": 544,
        "end_line": 548,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_literal_is_const_reg#2946",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_literal_is_const_reg (parser_context_t *context_p, /**< context */                               uint16_t literal_index) /**< literal index */",
        "snippet": "bool\nscanner_literal_is_const_reg (parser_context_t *context_p, /**< context */\n                              uint16_t literal_index) /**< literal index */\n{\n  if (literal_index < PARSER_REGISTER_START)\n  {\n    /* Re-assignment of non-register const bindings are detected elsewhere. */\n    return false;\n  }\n\n  parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top;\n\n  literal_index = (uint16_t) (literal_index - (PARSER_REGISTER_START - 1));\n\n  do\n  {\n    /* Registers must be found in the scope stack. */\n    JERRY_ASSERT (scope_stack_p > context_p->scope_stack_p);\n    scope_stack_p--;\n  }\n  while (scope_stack_p->map_from == PARSER_SCOPE_STACK_FUNC\n         || literal_index != (scope_stack_p->map_to & PARSER_SCOPE_STACK_REGISTER_MASK));\n\n  return (scope_stack_p->map_to & PARSER_SCOPE_STACK_IS_CONST_REG) != 0;\n}",
        "begin_line": 2946,
        "end_line": 2970,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_malloc#95",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_malloc (parser_context_t *context_p, /**< context */                 size_t size) /**< size of the memory block */",
        "snippet": "void *\nscanner_malloc (parser_context_t *context_p, /**< context */\n                size_t size) /**< size of the memory block */\n{\n  void *result;\n\n  JERRY_ASSERT (size > 0);\n  result = jmem_heap_alloc_block_null_on_error (size);\n\n  if (result == NULL)\n  {\n    scanner_cleanup (context_p);\n\n    /* This is the only error which specify its reason. */\n    context_p->error = PARSER_ERR_OUT_OF_MEMORY;\n    PARSER_THROW (context_p->try_buffer);\n  }\n  return result;\n}",
        "begin_line": 95,
        "end_line": 113,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_pop_literal_pool#565",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_pop_literal_pool (parser_context_t *context_p, /**< context */                           scanner_context_t *scanner_context_p) /**< scanner context */",
        "snippet": "void\nscanner_pop_literal_pool (parser_context_t *context_p, /**< context */\n                          scanner_context_t *scanner_context_p) /**< scanner context */\n{\n  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;\n  scanner_literal_pool_t *prev_literal_pool_p = literal_pool_p->prev_p;\n\n#if JERRY_ESNEXT\n  const uint32_t arrow_super_flags = (SCANNER_LITERAL_POOL_ARROW | SCANNER_LITERAL_POOL_HAS_SUPER_REFERENCE);\n  if ((literal_pool_p->status_flags & arrow_super_flags) == arrow_super_flags)\n  {\n    prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_HAS_SUPER_REFERENCE;\n  }\n#endif /* JERRY_ESNEXT */\n\n  if (JERRY_UNLIKELY (literal_pool_p->source_p == NULL))\n  {\n    JERRY_ASSERT (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION);\n    JERRY_ASSERT (literal_pool_p->literal_pool.data.first_p == NULL\n                  && literal_pool_p->literal_pool.data.last_p == NULL);\n\n    scanner_context_p->active_literal_pool_p = literal_pool_p->prev_p;\n    scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));\n    return;\n  }\n\n  uint16_t status_flags = literal_pool_p->status_flags;\n  scanner_arguments_type_t arguments_type = SCANNER_ARGUMENTS_MAY_PRESENT;\n\n  if (status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS)\n  {\n    arguments_type = SCANNER_ARGUMENTS_NOT_PRESENT;\n  }\n  else if (status_flags & SCANNER_LITERAL_POOL_CAN_EVAL)\n  {\n    arguments_type = SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL;\n  }\n\n#if JERRY_ESNEXT\n  if (status_flags & SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS)\n  {\n    arguments_type = SCANNER_ARGUMENTS_PRESENT;\n\n    if (status_flags & (SCANNER_LITERAL_POOL_NO_ARGUMENTS | SCANNER_LITERAL_POOL_CAN_EVAL))\n    {\n      arguments_type = SCANNER_ARGUMENTS_PRESENT_NO_REG;\n      status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_NO_ARGUMENTS;\n    }\n  }\n#endif /* JERRY_ESNEXT */\n\n  uint8_t can_eval_types = 0;\n#if JERRY_ESNEXT\n  if (prev_literal_pool_p == NULL && !(context_p->global_status_flags & ECMA_PARSE_DIRECT_EVAL))\n  {\n    can_eval_types |= SCANNER_LITERAL_IS_FUNC;\n  }\n#endif /* JERRY_ESNEXT */\n\n  if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) && prev_literal_pool_p != NULL)\n  {\n    prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;\n  }\n\n#if JERRY_DEBUGGER\n  if (scanner_context_p->status_flags & SCANNER_CONTEXT_DEBUGGER_ENABLED)\n  {\n    /* When debugger is enabled, identifiers are not stored in registers. However,\n     * this does not affect 'eval' detection, so 'arguments' object is not created. */\n    status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;\n  }\n#endif /* JERRY_DEBUGGER */\n\n  parser_list_iterator_t literal_iterator;\n  lexer_lit_location_t *literal_p;\n  int32_t no_declarations = literal_pool_p->no_declarations;\n\n  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);\n\n  uint8_t arguments_stream_type = SCANNER_STREAM_TYPE_ARGUMENTS;\n  const uint8_t *prev_source_p = literal_pool_p->source_p - 1;\n  lexer_lit_location_t *last_argument_p = NULL;\n  size_t compressed_size = 1;\n\n  while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n    uint8_t type = literal_p->type;\n\n    if (JERRY_UNLIKELY (no_declarations > PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK))\n    {\n      continue;\n    }\n\n    if (!(status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS) && scanner_literal_is_arguments (literal_p))\n    {\n#if JERRY_ESNEXT\n      JERRY_ASSERT (arguments_type != SCANNER_ARGUMENTS_NOT_PRESENT);\n#else /* !JERRY_ESNEXT */\n      JERRY_ASSERT (arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT\n                    || arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL);\n#endif /* JERRY_ESNEXT */\n\n      status_flags |= SCANNER_LITERAL_POOL_NO_ARGUMENTS;\n\n      if (type & SCANNER_LITERAL_IS_ARG)\n      {\n        JERRY_ASSERT (arguments_type != SCANNER_ARGUMENTS_PRESENT\n                      && arguments_type != SCANNER_ARGUMENTS_PRESENT_NO_REG);\n        arguments_type = SCANNER_ARGUMENTS_NOT_PRESENT;\n        last_argument_p = literal_p;\n      }\n#if JERRY_ESNEXT\n      else if (type & SCANNER_LITERAL_IS_LOCAL)\n      {\n        if (arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT || arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL)\n        {\n          arguments_type = SCANNER_ARGUMENTS_NOT_PRESENT;\n        }\n        else\n        {\n          if (arguments_type == SCANNER_ARGUMENTS_PRESENT_NO_REG)\n          {\n            type |= SCANNER_LITERAL_NO_REG;\n          }\n          else if (type & (SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE))\n          {\n            arguments_type = SCANNER_ARGUMENTS_PRESENT_NO_REG;\n          }\n\n          if ((type & SCANNER_LITERAL_IS_LOCAL_FUNC) == SCANNER_LITERAL_IS_LOCAL_FUNC)\n          {\n            type |= SCANNER_LITERAL_IS_ARG;\n            literal_p->type = type;\n            no_declarations--;\n            arguments_stream_type = SCANNER_STREAM_TYPE_ARGUMENTS_FUNC;\n          }\n          else\n          {\n            arguments_stream_type |= SCANNER_STREAM_LOCAL_ARGUMENTS;\n          }\n        }\n      }\n#else /* !JERRY_ESNEXT */\n      else if (type & SCANNER_LITERAL_IS_FUNC)\n      {\n        arguments_type = SCANNER_ARGUMENTS_NOT_PRESENT;\n      }\n#endif /* JERRY_ESNEXT */\n      else\n      {\n#if JERRY_ESNEXT\n        if ((type & SCANNER_LITERAL_IS_VAR)\n            && (arguments_type == SCANNER_ARGUMENTS_PRESENT || arguments_type == SCANNER_ARGUMENTS_PRESENT_NO_REG))\n        {\n          if (arguments_type == SCANNER_ARGUMENTS_PRESENT_NO_REG)\n          {\n            type |= SCANNER_LITERAL_NO_REG;\n          }\n          else if (type & (SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE))\n          {\n            arguments_type = SCANNER_ARGUMENTS_PRESENT_NO_REG;\n          }\n\n          type |= SCANNER_LITERAL_IS_ARG;\n          literal_p->type = type;\n          no_declarations--;\n        }\n#endif /* JERRY_ESNEXT */\n\n        if ((type & SCANNER_LITERAL_NO_REG) || arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL)\n        {\n          arguments_type = SCANNER_ARGUMENTS_PRESENT_NO_REG;\n        }\n        else if (arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT)\n        {\n          arguments_type = SCANNER_ARGUMENTS_PRESENT;\n        }\n\n#if JERRY_ESNEXT\n        /* The SCANNER_LITERAL_IS_ARG may be set above. */\n        if (!(type & SCANNER_LITERAL_IS_ARG))\n        {\n          literal_p->type = 0;\n          continue;\n        }\n#else /* !JERRY_ESNEXT */\n        literal_p->type = 0;\n        continue;\n#endif /* JERRY_ESNEXT */\n      }\n    }\n    else if (type & SCANNER_LITERAL_IS_ARG)\n    {\n      last_argument_p = literal_p;\n    }\n\n#if JERRY_ESNEXT\n    if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION)\n        && (type & SCANNER_LITERAL_IS_LOCAL_FUNC) == SCANNER_LITERAL_IS_FUNC)\n    {\n      if (prev_literal_pool_p == NULL && scanner_scope_find_lexical_declaration (context_p, literal_p))\n      {\n        literal_p->type = 0;\n        continue;\n      }\n\n      if (!(type & SCANNER_LITERAL_IS_ARG))\n      {\n        type |= SCANNER_LITERAL_IS_VAR;\n      }\n\n      type &= (uint8_t) ~SCANNER_LITERAL_IS_FUNC;\n      literal_p->type = type;\n    }\n#endif /* JERRY_ESNEXT */\n\n    if ((type & SCANNER_LITERAL_IS_LOCAL)\n        || ((type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_ARG))\n            && (status_flags & SCANNER_LITERAL_POOL_FUNCTION)))\n    {\n      JERRY_ASSERT ((status_flags & SCANNER_LITERAL_POOL_FUNCTION)\n                    || !(literal_p->type & SCANNER_LITERAL_IS_ARG));\n\n      if (literal_p->length == 0)\n      {\n        compressed_size += 1;\n        continue;\n      }\n\n      no_declarations++;\n\n      if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) || (type & can_eval_types))\n      {\n        type |= SCANNER_LITERAL_NO_REG;\n        literal_p->type = type;\n      }\n\n      if (type & SCANNER_LITERAL_IS_FUNC)\n      {\n        no_declarations++;\n\n#if JERRY_ESNEXT\n        if ((type & (SCANNER_LITERAL_IS_CONST | SCANNER_LITERAL_IS_ARG)) == SCANNER_LITERAL_IS_CONST)\n        {\n          JERRY_ASSERT (type & SCANNER_LITERAL_IS_LET);\n\n          /* Catch parameters cannot be functions. */\n          literal_p->type = (uint8_t) (type & ~SCANNER_LITERAL_IS_FUNC);\n          no_declarations--;\n        }\n#else /* !JERRY_ESNEXT */\n        if (type & SCANNER_LITERAL_IS_LOCAL)\n        {\n          /* Catch parameters cannot be functions. */\n          literal_p->type = (uint8_t) (type & ~SCANNER_LITERAL_IS_FUNC);\n          no_declarations--;\n        }\n#endif /* JERRY_ESNEXT */\n      }\n\n      intptr_t diff = (intptr_t) (literal_p->char_p - prev_source_p);\n\n      if (diff >= 1 && diff <= (intptr_t) UINT8_MAX)\n      {\n        compressed_size += 2 + 1;\n      }\n      else if (diff >= -(intptr_t) UINT8_MAX && diff <= (intptr_t) UINT16_MAX)\n      {\n        compressed_size += 2 + 2;\n      }\n      else\n      {\n        compressed_size += 2 + 1 + sizeof (const uint8_t *);\n      }\n\n      prev_source_p = literal_p->char_p + literal_p->length;\n\n      if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION)\n#if JERRY_ESNEXT\n          || ((type & SCANNER_LITERAL_IS_FUNC) && (status_flags & SCANNER_LITERAL_POOL_IS_STRICT))\n#endif /* JERRY_ESNEXT */\n          || !(type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC)))\n      {\n        continue;\n      }\n    }\n\n    if (prev_literal_pool_p != NULL && literal_p->length > 0)\n    {\n      /* Propagate literal to upper level. */\n      lexer_lit_location_t *literal_location_p = scanner_add_custom_literal (context_p,\n                                                                             prev_literal_pool_p,\n                                                                             literal_p);\n      uint8_t extended_type = literal_location_p->type;\n\n#if JERRY_ESNEXT\n      const uint16_t no_reg_flags = (SCANNER_LITERAL_POOL_FUNCTION | SCANNER_LITERAL_POOL_CLASS_FIELD);\n#else /* !JERRY_ESNEXT */\n      const uint16_t no_reg_flags = SCANNER_LITERAL_POOL_FUNCTION;\n#endif /* JERRY_ESNEXT */\n\n      if ((status_flags & no_reg_flags) || (type & SCANNER_LITERAL_NO_REG))\n      {\n        extended_type |= SCANNER_LITERAL_NO_REG;\n      }\n\n#if JERRY_ESNEXT\n      extended_type |= SCANNER_LITERAL_IS_USED;\n\n      if (status_flags & SCANNER_LITERAL_POOL_FUNCTION_STATEMENT)\n      {\n        extended_type |= SCANNER_LITERAL_EARLY_CREATE;\n      }\n\n      const uint8_t mask = (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_LOCAL);\n\n      if ((type & SCANNER_LITERAL_IS_ARG)\n          || (literal_location_p->type & mask) == SCANNER_LITERAL_IS_LET\n          || (literal_location_p->type & mask) == SCANNER_LITERAL_IS_CONST)\n      {\n        /* Clears the SCANNER_LITERAL_IS_VAR and SCANNER_LITERAL_IS_FUNC flags\n         * for speculative arrow parameters and local (non-var) functions. */\n        type = 0;\n      }\n#endif /* JERRY_ESNEXT */\n\n      type = (uint8_t) (type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC));\n      JERRY_ASSERT (type == 0 || !(status_flags & SCANNER_LITERAL_POOL_FUNCTION));\n\n      literal_location_p->type = (uint8_t) (extended_type | type);\n    }\n  }\n\n  if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION) || (compressed_size > 1))\n  {\n    if (arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT)\n    {\n      arguments_type = SCANNER_ARGUMENTS_NOT_PRESENT;\n    }\n    else if (arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL)\n    {\n      arguments_type = SCANNER_ARGUMENTS_PRESENT_NO_REG;\n    }\n\n    if (arguments_type != SCANNER_ARGUMENTS_NOT_PRESENT)\n    {\n      compressed_size++;\n    }\n\n    compressed_size += sizeof (scanner_info_t);\n\n    scanner_info_t *info_p;\n\n    if (prev_literal_pool_p != NULL || scanner_context_p->end_arguments_p == NULL)\n    {\n      info_p = scanner_insert_info (context_p, literal_pool_p->source_p, compressed_size);\n    }\n    else\n    {\n      scanner_info_t *start_info_p = scanner_context_p->end_arguments_p;\n      info_p = scanner_insert_info_before (context_p, literal_pool_p->source_p, start_info_p, compressed_size);\n    }\n\n    if (no_declarations > PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK)\n    {\n      no_declarations = PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK;\n    }\n\n    uint8_t *data_p = (uint8_t *) (info_p + 1);\n    bool mapped_arguments = false;\n\n    if (status_flags & SCANNER_LITERAL_POOL_FUNCTION)\n    {\n      info_p->type = SCANNER_TYPE_FUNCTION;\n\n      uint8_t u8_arg = 0;\n\n      if (arguments_type != SCANNER_ARGUMENTS_NOT_PRESENT)\n      {\n        u8_arg |= SCANNER_FUNCTION_ARGUMENTS_NEEDED;\n\n        if (no_declarations < PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK)\n        {\n          no_declarations++;\n        }\n\n#if JERRY_ESNEXT\n        const uint16_t is_unmapped = SCANNER_LITERAL_POOL_IS_STRICT | SCANNER_LITERAL_POOL_HAS_COMPLEX_ARGUMENT;\n#else /* !JERRY_ESNEXT */\n        const uint16_t is_unmapped = SCANNER_LITERAL_POOL_IS_STRICT;\n#endif /* JERRY_ESNEXT */\n\n        if (!(status_flags & is_unmapped))\n        {\n          mapped_arguments = true;\n        }\n\n        if (arguments_type == SCANNER_ARGUMENTS_PRESENT_NO_REG)\n        {\n          arguments_stream_type |= SCANNER_STREAM_NO_REG;\n        }\n\n        if (last_argument_p == NULL)\n        {\n          *data_p++ = arguments_stream_type;\n        }\n      }\n      else\n      {\n        last_argument_p = NULL;\n      }\n\n#if JERRY_ESNEXT\n      if (status_flags & (SCANNER_LITERAL_POOL_HAS_COMPLEX_ARGUMENT | SCANNER_LITERAL_POOL_ARROW))\n      {\n        u8_arg |= SCANNER_FUNCTION_HAS_COMPLEX_ARGUMENT;\n      }\n\n      if (status_flags & SCANNER_LITERAL_POOL_ASYNC)\n      {\n        u8_arg |= SCANNER_FUNCTION_ASYNC;\n\n        if (status_flags & SCANNER_LITERAL_POOL_FUNCTION_STATEMENT)\n        {\n          u8_arg |= SCANNER_FUNCTION_STATEMENT;\n        }\n      }\n\n      if (status_flags & SCANNER_LITERAL_POOL_CAN_EVAL)\n      {\n        u8_arg |= SCANNER_FUNCTION_LEXICAL_ENV_NEEDED;\n      }\n\n      if (status_flags & SCANNER_LITERAL_POOL_IS_STRICT)\n      {\n        u8_arg |= SCANNER_FUNCTION_IS_STRICT;\n      }\n#endif /* JERRY_ESNEXT */\n\n      info_p->u8_arg = u8_arg;\n      info_p->u16_arg = (uint16_t) no_declarations;\n    }\n    else\n    {\n      info_p->type = SCANNER_TYPE_BLOCK;\n\n      JERRY_ASSERT (prev_literal_pool_p != NULL);\n    }\n\n    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);\n    prev_source_p = literal_pool_p->source_p - 1;\n    no_declarations = literal_pool_p->no_declarations;\n\n    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n    {\n      if (JERRY_UNLIKELY (no_declarations > PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK)\n          || (!(literal_p->type & SCANNER_LITERAL_IS_LOCAL)\n              && (!(literal_p->type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_ARG))\n                  || !(status_flags & SCANNER_LITERAL_POOL_FUNCTION))))\n      {\n        continue;\n      }\n\n      if (literal_p->length == 0)\n      {\n        *data_p++ = SCANNER_STREAM_TYPE_HOLE;\n\n        if (literal_p == last_argument_p)\n        {\n          *data_p++ = arguments_stream_type;\n        }\n        continue;\n      }\n\n      no_declarations++;\n\n      uint8_t type = SCANNER_STREAM_TYPE_VAR;\n\n      if (literal_p->type & SCANNER_LITERAL_IS_FUNC)\n      {\n        no_declarations++;\n        type = SCANNER_STREAM_TYPE_FUNC;\n\n        if (literal_p->type & SCANNER_LITERAL_IS_ARG)\n        {\n          type = SCANNER_STREAM_TYPE_ARG_FUNC;\n\n#if JERRY_ESNEXT\n          if (literal_p->type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG)\n          {\n            type = SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC;\n          }\n#endif /* JERRY_ESNEXT */\n        }\n      }\n      else if (literal_p->type & SCANNER_LITERAL_IS_ARG)\n      {\n        type = SCANNER_STREAM_TYPE_ARG;\n\n#if JERRY_ESNEXT\n        if (literal_p->type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG)\n        {\n          type = SCANNER_STREAM_TYPE_DESTRUCTURED_ARG;\n        }\n\n        if (literal_p->type & SCANNER_LITERAL_IS_VAR)\n        {\n          type = (uint8_t) (type + 1);\n\n          JERRY_ASSERT (type == SCANNER_STREAM_TYPE_ARG_VAR\n                        || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR);\n        }\n#endif /* JERRY_ESNEXT */\n      }\n#if JERRY_ESNEXT\n      else if (literal_p->type & SCANNER_LITERAL_IS_LET)\n      {\n        if (!(literal_p->type & SCANNER_LITERAL_IS_CONST))\n        {\n          type = SCANNER_STREAM_TYPE_LET;\n\n          if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) && (literal_p->type & SCANNER_LITERAL_NO_REG))\n          {\n            literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n          }\n        }\n#if JERRY_MODULE_SYSTEM\n        else if (prev_literal_pool_p == NULL)\n        {\n          type = SCANNER_STREAM_TYPE_IMPORT;\n        }\n#endif /* JERRY_MODULE_SYSTEM */\n        else\n        {\n          type = SCANNER_STREAM_TYPE_LOCAL;\n        }\n      }\n      else if (literal_p->type & SCANNER_LITERAL_IS_CONST)\n      {\n        type = SCANNER_STREAM_TYPE_CONST;\n\n        if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) && (literal_p->type & SCANNER_LITERAL_NO_REG))\n        {\n          literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n        }\n      }\n\n      if (literal_p->type & SCANNER_LITERAL_EARLY_CREATE)\n      {\n        type |= SCANNER_STREAM_NO_REG | SCANNER_STREAM_EARLY_CREATE;\n      }\n#endif /* JERRY_ESNEXT */\n\n      if (literal_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)\n      {\n        type |= SCANNER_STREAM_HAS_ESCAPE;\n      }\n\n      if ((literal_p->type & SCANNER_LITERAL_NO_REG)\n          || (mapped_arguments && (literal_p->type & SCANNER_LITERAL_IS_ARG)))\n      {\n        type |= SCANNER_STREAM_NO_REG;\n      }\n\n      data_p[0] = type;\n      data_p[1] = (uint8_t) literal_p->length;\n      data_p += 3;\n\n      intptr_t diff = (intptr_t) (literal_p->char_p - prev_source_p);\n\n      if (diff >= 1 && diff <= (intptr_t) UINT8_MAX)\n      {\n        data_p[-1] = (uint8_t) diff;\n      }\n      else if (diff >= -(intptr_t) UINT8_MAX && diff <= (intptr_t) UINT16_MAX)\n      {\n        if (diff < 0)\n        {\n          diff = -diff;\n        }\n\n        data_p[-3] |= SCANNER_STREAM_UINT16_DIFF;\n        data_p[-1] = (uint8_t) diff;\n        data_p[0] = (uint8_t) (diff >> 8);\n        data_p += 1;\n      }\n      else\n      {\n        data_p[-1] = 0;\n        memcpy (data_p, &literal_p->char_p, sizeof (uintptr_t));\n        data_p += sizeof (uintptr_t);\n      }\n\n      if (literal_p == last_argument_p)\n      {\n        *data_p++ = arguments_stream_type;\n      }\n\n      prev_source_p = literal_p->char_p + literal_p->length;\n    }\n\n    data_p[0] = SCANNER_STREAM_TYPE_END;\n\n    JERRY_ASSERT (((uint8_t *) info_p) + compressed_size == data_p + 1);\n  }\n\n  if (!(status_flags & SCANNER_LITERAL_POOL_FUNCTION)\n      && (int32_t) prev_literal_pool_p->no_declarations < no_declarations)\n  {\n    prev_literal_pool_p->no_declarations = (uint16_t) no_declarations;\n  }\n\n  if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION) && prev_literal_pool_p != NULL)\n  {\n    if (prev_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IS_STRICT)\n    {\n      context_p->status_flags |= PARSER_IS_STRICT;\n    }\n    else\n    {\n      context_p->status_flags &= (uint32_t) ~PARSER_IS_STRICT;\n    }\n\n#if JERRY_ESNEXT\n    if (prev_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_GENERATOR)\n    {\n      context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION;\n    }\n    else\n    {\n      context_p->status_flags &= (uint32_t) ~PARSER_IS_GENERATOR_FUNCTION;\n    }\n\n    if (prev_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_ASYNC)\n    {\n      context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION;\n    }\n    else\n    {\n      context_p->status_flags &= (uint32_t) ~PARSER_IS_ASYNC_FUNCTION;\n    }\n#endif /* JERRY_ESNEXT */\n  }\n\n  scanner_context_p->active_literal_pool_p = literal_pool_p->prev_p;\n\n  parser_list_free (&literal_pool_p->literal_pool);\n  scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));\n}",
        "begin_line": 565,
        "end_line": 1213,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_push_destructuring_pattern#1781",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_push_destructuring_pattern (parser_context_t *context_p, /**< context */                                     scanner_context_t *scanner_context_p, /**< scanner context */                                     uint8_t binding_type, /**< type of destructuring binding pattern */                                     bool is_nested) /**< nested declaration */",
        "snippet": "void\nscanner_push_destructuring_pattern (parser_context_t *context_p, /**< context */\n                                    scanner_context_t *scanner_context_p, /**< scanner context */\n                                    uint8_t binding_type, /**< type of destructuring binding pattern */\n                                    bool is_nested) /**< nested declaration */\n{\n  JERRY_ASSERT (binding_type != SCANNER_BINDING_NONE || !is_nested);\n\n  scanner_source_start_t source_start;\n  source_start.source_p = context_p->source_p;\n\n  parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));\n  parser_stack_push_uint8 (context_p, scanner_context_p->binding_type);\n  scanner_context_p->binding_type = binding_type;\n\n  if (SCANNER_NEEDS_BINDING_LIST (binding_type))\n  {\n    scanner_binding_list_t *binding_list_p;\n    binding_list_p = (scanner_binding_list_t *) scanner_malloc (context_p, sizeof (scanner_binding_list_t));\n\n    binding_list_p->prev_p = scanner_context_p->active_binding_list_p;\n    binding_list_p->items_p = NULL;\n    binding_list_p->is_nested = is_nested;\n\n    scanner_context_p->active_binding_list_p = binding_list_p;\n  }\n}",
        "begin_line": 1781,
        "end_line": 1807,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_push_literal_pool#474",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_push_literal_pool (parser_context_t *context_p, /**< context */                            scanner_context_t *scanner_context_p, /**< scanner context */                            uint16_t status_flags) /**< combination of scanner_literal_pool_flags_t flags */",
        "snippet": "scanner_literal_pool_t *\nscanner_push_literal_pool (parser_context_t *context_p, /**< context */\n                           scanner_context_t *scanner_context_p, /**< scanner context */\n                           uint16_t status_flags) /**< combination of scanner_literal_pool_flags_t flags */\n{\n  scanner_literal_pool_t *prev_literal_pool_p = scanner_context_p->active_literal_pool_p;\n  scanner_literal_pool_t *literal_pool_p;\n\n  literal_pool_p = (scanner_literal_pool_t *) scanner_malloc (context_p, sizeof (scanner_literal_pool_t));\n\n  if (!(status_flags & SCANNER_LITERAL_POOL_FUNCTION))\n  {\n    JERRY_ASSERT (prev_literal_pool_p != NULL);\n    status_flags |= SCANNER_LITERAL_POOL_NO_ARGUMENTS;\n\n#if JERRY_ESNEXT\n    const uint16_t copied_flags = (SCANNER_LITERAL_POOL_IN_WITH\n                                   | SCANNER_LITERAL_POOL_GENERATOR\n                                   | SCANNER_LITERAL_POOL_ASYNC);\n#else /* !JERRY_ESNEXT */\n    const uint16_t copied_flags = SCANNER_LITERAL_POOL_IN_WITH;\n#endif /* JERRY_ESNEXT */\n\n    status_flags |= (uint16_t) (prev_literal_pool_p->status_flags & copied_flags);\n  }\n#if JERRY_ESNEXT\n  else\n  {\n    context_p->status_flags &= (uint32_t) ~(PARSER_IS_GENERATOR_FUNCTION | PARSER_IS_ASYNC_FUNCTION);\n\n    if (status_flags & SCANNER_LITERAL_POOL_GENERATOR)\n    {\n      context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION;\n    }\n\n    if (status_flags & SCANNER_LITERAL_POOL_ASYNC)\n    {\n      context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION;\n    }\n  }\n#endif /* JERRY_ESNEXT */\n\n  if (prev_literal_pool_p != NULL)\n  {\n    const uint16_t copied_flags = SCANNER_LITERAL_POOL_IS_STRICT;\n    status_flags |= (uint16_t) (prev_literal_pool_p->status_flags & copied_flags);\n\n    /* The logical value of these flags must be the same. */\n    JERRY_ASSERT (!(status_flags & SCANNER_LITERAL_POOL_IS_STRICT) == !(context_p->status_flags & PARSER_IS_STRICT));\n  }\n\n  parser_list_init (&literal_pool_p->literal_pool,\n                    sizeof (lexer_lit_location_t),\n                    (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_lit_location_t)));\n  literal_pool_p->source_p = NULL;\n  literal_pool_p->status_flags = status_flags;\n  literal_pool_p->no_declarations = 0;\n\n  literal_pool_p->prev_p = prev_literal_pool_p;\n  scanner_context_p->active_literal_pool_p = literal_pool_p;\n\n  return literal_pool_p;\n}",
        "begin_line": 474,
        "end_line": 536,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_release_next#271",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_release_next (parser_context_t *context_p, /**< context */                       size_t size) /**< size of the memory block */",
        "snippet": "extern inline void JERRY_ATTR_ALWAYS_INLINE\nscanner_release_next (parser_context_t *context_p, /**< context */\n                      size_t size) /**< size of the memory block */\n{\n  scanner_info_t *next_p = context_p->next_scanner_info_p->next_p;\n\n  jmem_heap_free_block (context_p->next_scanner_info_p, size);\n  context_p->next_scanner_info_p = next_p;\n}",
        "begin_line": 271,
        "end_line": 279,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_reverse_info_list#1874",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_reverse_info_list (parser_context_t *context_p) /**< context */",
        "snippet": "void\nscanner_reverse_info_list (parser_context_t *context_p) /**< context */\n{\n  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;\n  scanner_info_t *last_scanner_info_p = NULL;\n\n  if (scanner_info_p->type == SCANNER_TYPE_END)\n  {\n    return;\n  }\n\n  do\n  {\n    scanner_info_t *next_scanner_info_p = scanner_info_p->next_p;\n    scanner_info_p->next_p = last_scanner_info_p;\n\n    last_scanner_info_p = scanner_info_p;\n    scanner_info_p = next_scanner_info_p;\n  }\n  while (scanner_info_p->type != SCANNER_TYPE_END);\n\n  context_p->next_scanner_info_p->next_p = scanner_info_p;\n  context_p->next_scanner_info_p = last_scanner_info_p;\n}",
        "begin_line": 1874,
        "end_line": 1897,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_scope_find_lexical_declaration#396",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_scope_find_lexical_declaration (parser_context_t *context_p, /**< context */                                         lexer_lit_location_t *literal_p) /**< literal */",
        "snippet": "static bool\nscanner_scope_find_lexical_declaration (parser_context_t *context_p, /**< context */\n                                        lexer_lit_location_t *literal_p) /**< literal */\n{\n  ecma_string_t *name_p;\n  uint32_t flags = context_p->global_status_flags;\n\n  if (!(flags & ECMA_PARSE_EVAL)\n      || (!(flags & ECMA_PARSE_DIRECT_EVAL) && (context_p->status_flags & PARSER_IS_STRICT)))\n  {\n    return false;\n  }\n\n  if (JERRY_LIKELY (!(literal_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))\n  {\n    name_p = parser_new_ecma_string_from_literal ((lexer_literal_t *) literal_p);\n  }\n  else\n  {\n    uint8_t *destination_p = (uint8_t *) scanner_malloc (context_p, literal_p->length);\n\n    lexer_convert_ident_to_cesu8 (destination_p, literal_p->char_p, literal_p->length);\n\n    name_p = parser_new_ecma_string_from_literal ((lexer_literal_t *) literal_p);\n\n    scanner_free (destination_p, literal_p->length);\n  }\n\n  ecma_object_t *lex_env_p;\n\n  if (flags & ECMA_PARSE_DIRECT_EVAL)\n  {\n    lex_env_p = JERRY_CONTEXT (vm_top_context_p)->lex_env_p;\n\n    while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)\n    {\n      if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n      {\n        ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n        if (property_p != NULL && ecma_is_property_enumerable (*property_p))\n        {\n          ecma_deref_ecma_string (name_p);\n          return true;\n        }\n      }\n\n      JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);\n      lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);\n    }\n  }\n  else\n  {\n    lex_env_p = ecma_get_global_scope (ecma_builtin_get_global ());\n  }\n\n  if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n  {\n    ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n    if (property_p != NULL && ecma_is_property_enumerable (*property_p))\n    {\n      ecma_deref_ecma_string (name_p);\n      return true;\n    }\n  }\n\n  ecma_deref_ecma_string (name_p);\n  return false;\n}",
        "begin_line": 396,
        "end_line": 465,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_seek#338",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_seek (parser_context_t *context_p) /**< context */",
        "snippet": "void\nscanner_seek (parser_context_t *context_p) /**< context */\n{\n  const uint8_t *source_p = context_p->source_p;\n  scanner_info_t *prev_p;\n\n  if (context_p->skipped_scanner_info_p != NULL)\n  {\n    JERRY_ASSERT (context_p->skipped_scanner_info_p->source_p != NULL);\n\n    context_p->skipped_scanner_info_end_p->next_p = context_p->next_scanner_info_p;\n\n    if (context_p->skipped_scanner_info_end_p->source_p <= source_p)\n    {\n      prev_p = context_p->skipped_scanner_info_end_p;\n    }\n    else\n    {\n      prev_p = context_p->skipped_scanner_info_p;\n\n      if (prev_p->source_p > source_p)\n      {\n        context_p->next_scanner_info_p = prev_p;\n        context_p->skipped_scanner_info_p = NULL;\n        return;\n      }\n\n      context_p->skipped_scanner_info_p = prev_p;\n    }\n  }\n  else\n  {\n    prev_p = context_p->next_scanner_info_p;\n\n    if (prev_p->source_p == NULL || prev_p->source_p > source_p)\n    {\n      return;\n    }\n\n    context_p->skipped_scanner_info_p = prev_p;\n  }\n\n  while (prev_p->next_p->source_p != NULL && prev_p->next_p->source_p <= source_p)\n  {\n    prev_p = prev_p->next_p;\n  }\n\n  context_p->skipped_scanner_info_end_p = prev_p;\n  context_p->next_scanner_info_p = prev_p->next_p;\n}",
        "begin_line": 338,
        "end_line": 387,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner-util.scanner_set_location#2881",
        "src_path": "jerry-core/parser/js/js-scanner-util.c",
        "class_name": "jerry-core.parser.js.js-scanner-util",
        "signature": "jerry-core.parser.js.js-scanner-util.scanner_set_location (parser_context_t *context_p, /**< context */                       scanner_location_t *location_p) /**< location */",
        "snippet": "extern inline void JERRY_ATTR_ALWAYS_INLINE\nscanner_set_location (parser_context_t *context_p, /**< context */\n                      scanner_location_t *location_p) /**< location */\n{\n  context_p->source_p = location_p->source_p;\n  context_p->line = location_p->line;\n  context_p->column = location_p->column;\n}",
        "begin_line": 2881,
        "end_line": 2888,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner.scanner_scan_all#2476",
        "src_path": "jerry-core/parser/js/js-scanner.c",
        "class_name": "jerry-core.parser.js.js-scanner",
        "signature": "jerry-core.parser.js.js-scanner.scanner_scan_all (parser_context_t *context_p) /**< context */",
        "snippet": "void JERRY_ATTR_NOINLINE\nscanner_scan_all (parser_context_t *context_p) /**< context */\n{\n  scanner_context_t scanner_context;\n\n#if JERRY_PARSER_DUMP_BYTE_CODE\n  if (context_p->is_show_opcodes)\n  {\n    JERRY_DEBUG_MSG (\"\\n--- Scanning start ---\\n\\n\");\n  }\n#endif /* JERRY_PARSER_DUMP_BYTE_CODE */\n\n  scanner_context.context_status_flags = context_p->status_flags;\n  scanner_context.status_flags = SCANNER_CONTEXT_NO_FLAGS;\n#if JERRY_DEBUGGER\n  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n  {\n    scanner_context.status_flags |= SCANNER_CONTEXT_DEBUGGER_ENABLED;\n  }\n#endif /* JERRY_DEBUGGER */\n#if JERRY_ESNEXT\n  scanner_context.binding_type = SCANNER_BINDING_NONE;\n  scanner_context.active_binding_list_p = NULL;\n#endif /* JERRY_ESNEXT */\n  scanner_context.active_literal_pool_p = NULL;\n  scanner_context.active_switch_statement.last_case_p = NULL;\n  scanner_context.end_arguments_p = NULL;\n#if JERRY_ESNEXT\n  scanner_context.async_source_p = NULL;\n#endif /* JERRY_ESNEXT */\n\n  /* This assignment must be here because of Apple compilers. */\n  context_p->u.scanner_context_p = &scanner_context;\n#if JERRY_ESNEXT\n  context_p->global_status_flags |= ECMA_PARSE_INTERNAL_PRE_SCANNING;\n#endif /* JERRY_ESNEXT */\n\n  parser_stack_init (context_p);\n\n  PARSER_TRY (context_p->try_buffer)\n  {\n    if (context_p->arguments_start_p == NULL)\n    {\n      context_p->source_p = context_p->source_start_p;\n      context_p->source_end_p = context_p->source_start_p + context_p->source_size;\n\n      uint16_t status_flags = (SCANNER_LITERAL_POOL_FUNCTION\n                               | SCANNER_LITERAL_POOL_NO_ARGUMENTS\n                               | SCANNER_LITERAL_POOL_CAN_EVAL);\n\n      if (context_p->status_flags & PARSER_IS_STRICT)\n      {\n        status_flags |= SCANNER_LITERAL_POOL_IS_STRICT;\n      }\n\n      scanner_literal_pool_t *literal_pool_p = scanner_push_literal_pool (context_p, &scanner_context, status_flags);\n      literal_pool_p->source_p = context_p->source_start_p;\n\n      parser_stack_push_uint8 (context_p, SCAN_STACK_SCRIPT);\n\n      lexer_next_token (context_p);\n      scanner_check_directives (context_p, &scanner_context);\n    }\n    else\n    {\n      context_p->source_p = context_p->arguments_start_p;\n      context_p->source_end_p = context_p->arguments_start_p + context_p->arguments_size;\n\n      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION;\n\n      if (context_p->status_flags & PARSER_IS_STRICT)\n      {\n        status_flags |= SCANNER_LITERAL_POOL_IS_STRICT;\n      }\n\n#if JERRY_ESNEXT\n      if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)\n      {\n        status_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n      }\n      if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)\n      {\n        status_flags |= SCANNER_LITERAL_POOL_ASYNC;\n      }\n#endif /* JERRY_ESNEXT */\n\n      scanner_push_literal_pool (context_p, &scanner_context, status_flags);\n      scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_SCRIPT_FUNCTION);\n\n      /* Faking the first token. */\n      context_p->token.type = LEXER_LEFT_PAREN;\n    }\n\n    while (true)\n    {\n      lexer_token_type_t type = (lexer_token_type_t) context_p->token.type;\n      scan_stack_modes_t stack_top = (scan_stack_modes_t) context_p->stack_top_uint8;\n\n      switch (scanner_context.mode)\n      {\n        case SCAN_MODE_PRIMARY_EXPRESSION:\n        {\n          if (type == LEXER_ADD\n              || type == LEXER_SUBTRACT\n              || LEXER_IS_UNARY_OP_TOKEN (type))\n          {\n            break;\n          }\n          /* FALLTHRU */\n        }\n        case SCAN_MODE_PRIMARY_EXPRESSION_AFTER_NEW:\n        {\n          if (scanner_scan_primary_expression (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)\n          {\n            continue;\n          }\n          break;\n        }\n#if JERRY_ESNEXT\n        case SCAN_MODE_CLASS_DECLARATION:\n        {\n          if (context_p->token.type == LEXER_KEYW_EXTENDS)\n          {\n            parser_stack_push_uint8 (context_p, SCAN_STACK_CLASS_EXTENDS);\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n            break;\n          }\n          else if (context_p->token.type != LEXER_LEFT_BRACE)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          scanner_context.mode = SCAN_MODE_CLASS_BODY;\n          /* FALLTHRU */\n        }\n        case SCAN_MODE_CLASS_BODY:\n        {\n          lexer_skip_empty_statements (context_p);\n          lexer_scan_identifier (context_p);\n          /* FALLTHRU */\n        }\n        case SCAN_MODE_CLASS_BODY_NO_SCAN:\n        {\n          JERRY_ASSERT (stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR\n                        || stack_top == SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR);\n          JERRY_ASSERT (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CLASS_NAME);\n\n          if (context_p->token.type == LEXER_RIGHT_BRACE)\n          {\n            parser_stack_pop_uint8 (context_p);\n            stack_top = context_p->stack_top_uint8;\n\n            scanner_pop_literal_pool (context_p, &scanner_context);\n\n            JERRY_ASSERT (stack_top == SCAN_STACK_CLASS_STATEMENT || stack_top == SCAN_STACK_CLASS_EXPRESSION);\n\n            if (stack_top == SCAN_STACK_CLASS_STATEMENT)\n            {\n              /* The token is kept to disallow consuming a semicolon after it. */\n              scanner_context.mode = SCAN_MODE_STATEMENT_END;\n              continue;\n            }\n\n            scanner_context.mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n            parser_stack_pop_uint8 (context_p);\n\n#if JERRY_MODULE_SYSTEM\n            if (context_p->stack_top_uint8 == SCAN_STACK_EXPORT_DEFAULT)\n            {\n              /* The token is kept to disallow consuming a semicolon after it. */\n              parser_stack_change_last_uint8 (context_p, SCAN_STACK_CLASS_STATEMENT);\n              scanner_context.mode = SCAN_MODE_STATEMENT_END;\n              continue;\n            }\n#endif /* JERRY_MODULE_SYSTEM */\n            break;\n          }\n\n          bool identifier_found = false;\n\n          if (context_p->token.type == LEXER_LITERAL\n              && LEXER_IS_IDENT_OR_STRING (context_p->token.lit_location.type)\n              && lexer_compare_literal_to_string (context_p, \"constructor\", 11))\n          {\n            if (stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)\n            {\n              const uint8_t *class_source_p = scanner_context.active_literal_pool_p->source_p;\n              scanner_info_t *info_p = scanner_insert_info (context_p, class_source_p, sizeof (scanner_info_t));\n\n              info_p->type = SCANNER_TYPE_CLASS_CONSTRUCTOR;\n              parser_stack_change_last_uint8 (context_p, SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR);\n            }\n          }\n          else if (lexer_token_is_identifier (context_p, \"static\", 6))\n          {\n            lexer_scan_identifier (context_p);\n            identifier_found = true;\n          }\n\n          scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n\n          uint16_t literal_pool_flags = SCANNER_LITERAL_POOL_FUNCTION;\n\n          if (lexer_token_is_identifier (context_p, \"get\", 3)\n              || lexer_token_is_identifier (context_p, \"set\", 3))\n          {\n            lexer_scan_identifier (context_p);\n            identifier_found = true;\n\n            if (context_p->token.type == LEXER_LEFT_PAREN)\n            {\n              parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n              scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);\n              continue;\n            }\n          }\n          else if (lexer_token_is_identifier (context_p, \"async\", 5))\n          {\n            lexer_scan_identifier (context_p);\n            identifier_found = true;\n\n            if (!(context_p->token.flags & LEXER_WAS_NEWLINE))\n            {\n              if (context_p->token.type == LEXER_LEFT_PAREN)\n              {\n                parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n                scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);\n                continue;\n              }\n\n              literal_pool_flags |= SCANNER_LITERAL_POOL_ASYNC;\n\n              if (context_p->token.type == LEXER_MULTIPLY)\n              {\n                lexer_scan_identifier (context_p);\n                literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n              }\n            }\n          }\n          else if (context_p->token.type == LEXER_MULTIPLY)\n          {\n            lexer_scan_identifier (context_p);\n            literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n          }\n\n          if (context_p->token.type == LEXER_LEFT_SQUARE)\n          {\n            if (literal_pool_flags != SCANNER_LITERAL_POOL_FUNCTION)\n            {\n              parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n            }\n\n            parser_stack_push_uint8 (context_p, SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (literal_pool_flags));\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n            break;\n          }\n\n          if (context_p->token.type == LEXER_LITERAL)\n          {\n            lexer_scan_identifier (context_p);\n            identifier_found = true;\n          }\n\n          if (!identifier_found)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          if (context_p->token.type == LEXER_LEFT_PAREN)\n          {\n            if (literal_pool_flags & SCANNER_LITERAL_POOL_GENERATOR)\n            {\n              context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION;\n            }\n\n            parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n            scanner_push_literal_pool (context_p, &scanner_context, literal_pool_flags);\n            continue;\n          }\n\n          if (literal_pool_flags != SCANNER_LITERAL_POOL_FUNCTION)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          if (context_p->token.type == LEXER_ASSIGN)\n          {\n            scanner_push_class_field_initializer (context_p, &scanner_context);\n            break;\n          }\n\n          if (context_p->token.type == LEXER_SEMICOLON)\n          {\n            scanner_context.mode = SCAN_MODE_CLASS_BODY;\n            continue;\n          }\n\n          if (context_p->token.type != LEXER_RIGHT_BRACE\n              && !(context_p->token.flags & LEXER_WAS_NEWLINE))\n          {\n            scanner_raise_error (context_p);\n          }\n\n          scanner_context.mode = SCAN_MODE_CLASS_BODY_NO_SCAN;\n          continue;\n        }\n#endif /* JERRY_ESNEXT */\n        case SCAN_MODE_POST_PRIMARY_EXPRESSION:\n        {\n          if (scanner_scan_post_primary_expression (context_p, &scanner_context, type, stack_top))\n          {\n            break;\n          }\n          type = (lexer_token_type_t) context_p->token.type;\n          /* FALLTHRU */\n        }\n        case SCAN_MODE_PRIMARY_EXPRESSION_END:\n        {\n          if (scanner_scan_primary_expression_end (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)\n          {\n            continue;\n          }\n          break;\n        }\n        case SCAN_MODE_STATEMENT_OR_TERMINATOR:\n        {\n          if (type == LEXER_RIGHT_BRACE || type == LEXER_EOS)\n          {\n            scanner_context.mode = SCAN_MODE_STATEMENT_END;\n            continue;\n          }\n          /* FALLTHRU */\n        }\n        case SCAN_MODE_STATEMENT:\n        {\n          if (scanner_scan_statement (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)\n          {\n            continue;\n          }\n          break;\n        }\n        case SCAN_MODE_STATEMENT_END:\n        {\n          if (scanner_scan_statement_end (context_p, &scanner_context, type) != SCAN_NEXT_TOKEN)\n          {\n            continue;\n          }\n\n          if (context_p->token.type == LEXER_EOS)\n          {\n            goto scan_completed;\n          }\n\n          break;\n        }\n        case SCAN_MODE_VAR_STATEMENT:\n        {\n#if JERRY_ESNEXT\n          if (type == LEXER_LEFT_SQUARE || type == LEXER_LEFT_BRACE)\n          {\n            uint8_t binding_type = SCANNER_BINDING_VAR;\n\n            if (stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_FOR_LET_START)\n            {\n              binding_type = SCANNER_BINDING_LET;\n            }\n            else if (stack_top == SCAN_STACK_CONST || stack_top == SCAN_STACK_FOR_CONST_START)\n            {\n              binding_type = SCANNER_BINDING_CONST;\n            }\n\n            scanner_push_destructuring_pattern (context_p, &scanner_context, binding_type, false);\n\n            if (type == LEXER_LEFT_SQUARE)\n            {\n              parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n              scanner_context.mode = SCAN_MODE_BINDING;\n              break;\n            }\n\n            parser_stack_push_uint8 (context_p, 0);\n            parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n            scanner_context.mode = SCAN_MODE_PROPERTY_NAME;\n            continue;\n          }\n#endif /* JERRY_ESNEXT */\n\n          if (type != LEXER_LITERAL\n              || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          lexer_lit_location_t *literal_p = scanner_add_literal (context_p, &scanner_context);\n\n#if JERRY_ESNEXT\n          if (stack_top != SCAN_STACK_VAR && stack_top != SCAN_STACK_FOR_VAR_START)\n          {\n            scanner_detect_invalid_let (context_p, literal_p);\n\n            if (stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_FOR_LET_START)\n            {\n              literal_p->type |= SCANNER_LITERAL_IS_LET;\n            }\n            else\n            {\n              JERRY_ASSERT (stack_top == SCAN_STACK_CONST || stack_top == SCAN_STACK_FOR_CONST_START);\n              literal_p->type |= SCANNER_LITERAL_IS_CONST;\n            }\n\n            lexer_next_token (context_p);\n\n            if (literal_p->type & SCANNER_LITERAL_IS_USED)\n            {\n              literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n            }\n            else if (context_p->token.type == LEXER_ASSIGN)\n            {\n              scanner_binding_literal_t binding_literal;\n              binding_literal.literal_p = literal_p;\n\n              parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));\n              parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);\n            }\n          }\n          else\n          {\n            if (!(literal_p->type & SCANNER_LITERAL_IS_VAR))\n            {\n              scanner_detect_invalid_var (context_p, &scanner_context, literal_p);\n              literal_p->type |= SCANNER_LITERAL_IS_VAR;\n\n              if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)\n              {\n                literal_p->type |= SCANNER_LITERAL_NO_REG;\n              }\n            }\n\n            lexer_next_token (context_p);\n          }\n#else /* !JERRY_ESNEXT */\n          literal_p->type |= SCANNER_LITERAL_IS_VAR;\n\n          if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)\n          {\n            literal_p->type |= SCANNER_LITERAL_NO_REG;\n          }\n\n          lexer_next_token (context_p);\n#endif /* JERRY_ESNEXT */\n\n#if JERRY_MODULE_SYSTEM\n          if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT)\n          {\n            literal_p->type |= SCANNER_LITERAL_NO_REG;\n          }\n#endif /* JERRY_MODULE_SYSTEM */\n\n          switch (context_p->token.type)\n          {\n            case LEXER_ASSIGN:\n            {\n              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n              /* FALLTHRU */\n            }\n            case LEXER_COMMA:\n            {\n              lexer_next_token (context_p);\n              continue;\n            }\n          }\n\n          if (SCANNER_IS_FOR_START (stack_top))\n          {\n#if JERRY_MODULE_SYSTEM\n            JERRY_ASSERT (!(scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT));\n#endif /* JERRY_MODULE_SYSTEM */\n\n            if (context_p->token.type != LEXER_SEMICOLON\n                && context_p->token.type != LEXER_KEYW_IN\n                && !SCANNER_IDENTIFIER_IS_OF ())\n            {\n              scanner_raise_error (context_p);\n            }\n\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n            continue;\n          }\n\n#if JERRY_ESNEXT\n          JERRY_ASSERT (stack_top == SCAN_STACK_VAR || stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_CONST);\n#else /* !JERRY_ESNEXT */\n          JERRY_ASSERT (stack_top == SCAN_STACK_VAR);\n#endif /* JERRY_ESNEXT */\n\n#if JERRY_MODULE_SYSTEM\n          scanner_context.active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;\n#endif /* JERRY_MODULE_SYSTEM */\n\n          scanner_context.mode = SCAN_MODE_STATEMENT_END;\n          parser_stack_pop_uint8 (context_p);\n          continue;\n        }\n        case SCAN_MODE_FUNCTION_ARGUMENTS:\n        {\n          JERRY_ASSERT (stack_top == SCAN_STACK_SCRIPT_FUNCTION\n                        || stack_top == SCAN_STACK_FUNCTION_STATEMENT\n                        || stack_top == SCAN_STACK_FUNCTION_EXPRESSION\n                        || stack_top == SCAN_STACK_FUNCTION_PROPERTY);\n\n          scanner_literal_pool_t *literal_pool_p = scanner_context.active_literal_pool_p;\n\n          JERRY_ASSERT (literal_pool_p != NULL && (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION));\n\n          literal_pool_p->source_p = context_p->source_p;\n\n#if JERRY_ESNEXT\n          if (JERRY_UNLIKELY (scanner_context.async_source_p != NULL))\n          {\n            literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ASYNC;\n            literal_pool_p->source_p = scanner_context.async_source_p;\n            scanner_context.async_source_p = NULL;\n          }\n#endif /* JERRY_ESNEXT */\n\n          if (type != LEXER_LEFT_PAREN)\n          {\n            scanner_raise_error (context_p);\n          }\n          lexer_next_token (context_p);\n\n#if JERRY_ESNEXT\n          /* FALLTHRU */\n        }\n        case SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS:\n        {\n          if (context_p->token.type != LEXER_RIGHT_PAREN && context_p->token.type != LEXER_EOS)\n          {\n            lexer_lit_location_t *argument_literal_p;\n\n            do\n            {\n              if (context_p->token.type == LEXER_THREE_DOTS)\n              {\n                scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_HAS_COMPLEX_ARGUMENT;\n                lexer_next_token (context_p);\n              }\n\n              if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)\n              {\n                argument_literal_p = NULL;\n                break;\n              }\n\n              if (context_p->token.type != LEXER_LITERAL\n                  || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n              {\n                scanner_raise_error (context_p);\n              }\n\n              argument_literal_p = scanner_append_argument (context_p, &scanner_context);\n              lexer_next_token (context_p);\n\n              if (context_p->token.type != LEXER_COMMA)\n              {\n                break;\n              }\n\n              lexer_next_token (context_p);\n            }\n            while (context_p->token.type != LEXER_RIGHT_PAREN && context_p->token.type != LEXER_EOS);\n\n            if (argument_literal_p == NULL)\n            {\n              scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_HAS_COMPLEX_ARGUMENT;\n\n              parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PARAMETERS);\n              scanner_append_hole (context_p, &scanner_context);\n              scanner_push_destructuring_pattern (context_p, &scanner_context, SCANNER_BINDING_ARG, false);\n\n              if (context_p->token.type == LEXER_LEFT_SQUARE)\n              {\n                parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n                scanner_context.mode = SCAN_MODE_BINDING;\n                break;\n              }\n\n              parser_stack_push_uint8 (context_p, 0);\n              parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n              scanner_context.mode = SCAN_MODE_PROPERTY_NAME;\n              continue;\n            }\n\n            if (context_p->token.type == LEXER_ASSIGN)\n            {\n              scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_HAS_COMPLEX_ARGUMENT;\n\n              parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PARAMETERS);\n              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n              if (argument_literal_p->type & SCANNER_LITERAL_IS_USED)\n              {\n                JERRY_ASSERT (argument_literal_p->type & SCANNER_LITERAL_EARLY_CREATE);\n                break;\n              }\n\n              scanner_binding_literal_t binding_literal;\n              binding_literal.literal_p = argument_literal_p;\n\n              parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));\n              parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);\n              break;\n            }\n          }\n#else /* !JERRY_ESNEXT */\n          if (context_p->token.type != LEXER_RIGHT_PAREN && context_p->token.type != LEXER_EOS)\n          {\n            while (true)\n            {\n              if (context_p->token.type != LEXER_LITERAL\n                  || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n              {\n                scanner_raise_error (context_p);\n              }\n\n              scanner_append_argument (context_p, &scanner_context);\n              lexer_next_token (context_p);\n\n              if (context_p->token.type != LEXER_COMMA)\n              {\n                break;\n              }\n\n              lexer_next_token (context_p);\n            }\n          }\n#endif /* JERRY_ESNEXT */\n\n          if (context_p->token.type == LEXER_EOS && stack_top == SCAN_STACK_SCRIPT_FUNCTION)\n          {\n            /* End of argument parsing. */\n            scanner_info_t *scanner_info_p = (scanner_info_t *) scanner_malloc (context_p, sizeof (scanner_info_t));\n            scanner_info_p->next_p = context_p->next_scanner_info_p;\n            scanner_info_p->source_p = NULL;\n            scanner_info_p->type = SCANNER_TYPE_END_ARGUMENTS;\n            scanner_context.end_arguments_p = scanner_info_p;\n\n            context_p->next_scanner_info_p = scanner_info_p;\n            context_p->source_p = context_p->source_start_p;\n            context_p->source_end_p = context_p->source_start_p + context_p->source_size;\n            lexer_init_line_info (context_p);\n\n#if JERRY_ESNEXT\n            scanner_filter_arguments (context_p, &scanner_context);\n#endif /* JERRY_ESNEXT */\n            lexer_next_token (context_p);\n            scanner_check_directives (context_p, &scanner_context);\n            continue;\n          }\n\n          if (context_p->token.type != LEXER_RIGHT_PAREN)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          lexer_next_token (context_p);\n\n          if (context_p->token.type != LEXER_LEFT_BRACE)\n          {\n            scanner_raise_error (context_p);\n          }\n\n#if JERRY_ESNEXT\n          scanner_filter_arguments (context_p, &scanner_context);\n#endif /* JERRY_ESNEXT */\n          lexer_next_token (context_p);\n          scanner_check_directives (context_p, &scanner_context);\n          continue;\n        }\n        case SCAN_MODE_PROPERTY_NAME:\n        {\n          JERRY_ASSERT (stack_top == SCAN_STACK_OBJECT_LITERAL);\n\n          if (lexer_scan_identifier (context_p))\n          {\n            lexer_check_property_modifier (context_p);\n          }\n\n#if JERRY_ESNEXT\n          if (context_p->token.type == LEXER_LEFT_SQUARE)\n          {\n            parser_stack_push_uint8 (context_p, SCAN_STACK_COMPUTED_PROPERTY);\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n            break;\n          }\n\n          if (context_p->token.type == LEXER_THREE_DOTS)\n          {\n            *parser_stack_get_prev_uint8 (context_p) |= SCANNER_LITERAL_OBJECT_HAS_REST;\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n            if (scanner_context.binding_type != SCANNER_BINDING_NONE)\n            {\n              scanner_context.mode = SCAN_MODE_BINDING;\n            }\n            break;\n          }\n#endif /* JERRY_ESNEXT */\n\n          if (context_p->token.type == LEXER_RIGHT_BRACE)\n          {\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n            continue;\n          }\n\n          if (context_p->token.type == LEXER_PROPERTY_GETTER\n#if JERRY_ESNEXT\n              || context_p->token.type == LEXER_KEYW_ASYNC\n              || context_p->token.type == LEXER_MULTIPLY\n#endif /* JERRY_ESNEXT */\n              || context_p->token.type == LEXER_PROPERTY_SETTER)\n          {\n            uint16_t literal_pool_flags = SCANNER_LITERAL_POOL_FUNCTION;\n\n#if JERRY_ESNEXT\n            if (context_p->token.type == LEXER_MULTIPLY)\n            {\n              literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n            }\n            else if (context_p->token.type == LEXER_KEYW_ASYNC)\n            {\n              literal_pool_flags |= SCANNER_LITERAL_POOL_ASYNC;\n\n              if (lexer_consume_generator (context_p))\n              {\n                literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n              }\n            }\n#endif /* JERRY_ESNEXT */\n\n            parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n            lexer_scan_identifier (context_p);\n\n#if JERRY_ESNEXT\n            if (context_p->token.type == LEXER_LEFT_SQUARE)\n            {\n              parser_stack_push_uint8 (context_p, SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (literal_pool_flags));\n              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n              break;\n            }\n#endif /* JERRY_ESNEXT */\n\n            if (context_p->token.type != LEXER_LITERAL)\n            {\n              scanner_raise_error (context_p);\n            }\n\n            scanner_push_literal_pool (context_p, &scanner_context, literal_pool_flags);\n            scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n            break;\n          }\n\n          if (context_p->token.type != LEXER_LITERAL)\n          {\n            scanner_raise_error (context_p);\n          }\n\n#if JERRY_ESNEXT\n          parser_line_counter_t start_line = context_p->token.line;\n          parser_line_counter_t start_column = context_p->token.column;\n          bool is_ident = (context_p->token.lit_location.type == LEXER_IDENT_LITERAL);\n#endif /* JERRY_ESNEXT */\n\n          lexer_next_token (context_p);\n\n#if JERRY_ESNEXT\n          if (context_p->token.type == LEXER_LEFT_PAREN)\n          {\n            scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);\n\n            parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n            scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n            continue;\n          }\n\n          if (is_ident\n              && (context_p->token.type == LEXER_COMMA\n                  || context_p->token.type == LEXER_RIGHT_BRACE\n                  || context_p->token.type == LEXER_ASSIGN))\n          {\n            context_p->source_p = context_p->token.lit_location.char_p;\n            context_p->line = start_line;\n            context_p->column = start_column;\n\n            lexer_next_token (context_p);\n\n            JERRY_ASSERT (context_p->token.type != LEXER_LITERAL\n                          || context_p->token.lit_location.type == LEXER_IDENT_LITERAL);\n\n            if (context_p->token.type != LEXER_LITERAL)\n            {\n              scanner_raise_error (context_p);\n            }\n\n            if (scanner_context.binding_type != SCANNER_BINDING_NONE)\n            {\n              scanner_context.mode = SCAN_MODE_BINDING;\n              continue;\n            }\n\n            scanner_add_reference (context_p, &scanner_context);\n\n            lexer_next_token (context_p);\n\n            if (context_p->token.type == LEXER_ASSIGN)\n            {\n              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n              break;\n            }\n\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n            continue;\n          }\n#endif /* JERRY_ESNEXT */\n\n          if (context_p->token.type != LEXER_COLON)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n#if JERRY_ESNEXT\n          if (scanner_context.binding_type != SCANNER_BINDING_NONE)\n          {\n            scanner_context.mode = SCAN_MODE_BINDING;\n          }\n#endif /* JERRY_ESNEXT */\n          break;\n        }\n#if JERRY_ESNEXT\n        case SCAN_MODE_BINDING:\n        {\n          JERRY_ASSERT (scanner_context.binding_type == SCANNER_BINDING_VAR\n                        || scanner_context.binding_type == SCANNER_BINDING_LET\n                        || scanner_context.binding_type == SCANNER_BINDING_CATCH\n                        || scanner_context.binding_type == SCANNER_BINDING_CONST\n                        || scanner_context.binding_type == SCANNER_BINDING_ARG\n                        || scanner_context.binding_type == SCANNER_BINDING_ARROW_ARG);\n\n          if (type == LEXER_THREE_DOTS)\n          {\n            lexer_next_token (context_p);\n            type = (lexer_token_type_t) context_p->token.type;\n          }\n\n          if (type == LEXER_LEFT_SQUARE || type == LEXER_LEFT_BRACE)\n          {\n            scanner_push_destructuring_pattern (context_p, &scanner_context, scanner_context.binding_type, true);\n\n            if (type == LEXER_LEFT_SQUARE)\n            {\n              parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n              break;\n            }\n\n            parser_stack_push_uint8 (context_p, 0);\n            parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n            scanner_context.mode = SCAN_MODE_PROPERTY_NAME;\n            continue;\n          }\n\n          if (type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n          {\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n            continue;\n          }\n\n          lexer_lit_location_t *literal_p = scanner_add_literal (context_p, &scanner_context);\n\n          scanner_context.mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n\n          if (scanner_context.binding_type == SCANNER_BINDING_VAR)\n          {\n            if (!(literal_p->type & SCANNER_LITERAL_IS_VAR))\n            {\n              scanner_detect_invalid_var (context_p, &scanner_context, literal_p);\n              literal_p->type |= SCANNER_LITERAL_IS_VAR;\n\n              if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)\n              {\n                literal_p->type |= SCANNER_LITERAL_NO_REG;\n              }\n            }\n            break;\n          }\n\n          if (scanner_context.binding_type == SCANNER_BINDING_ARROW_ARG)\n          {\n            literal_p->type |= SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG;\n\n            if (literal_p->type & SCANNER_LITERAL_IS_USED)\n            {\n              literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n              break;\n            }\n          }\n          else\n          {\n            scanner_detect_invalid_let (context_p, literal_p);\n\n            if (scanner_context.binding_type <= SCANNER_BINDING_CATCH)\n            {\n              JERRY_ASSERT ((scanner_context.binding_type == SCANNER_BINDING_LET)\n                            || (scanner_context.binding_type == SCANNER_BINDING_CATCH));\n\n              literal_p->type |= SCANNER_LITERAL_IS_LET;\n            }\n            else\n            {\n              literal_p->type |= SCANNER_LITERAL_IS_CONST;\n\n              if (scanner_context.binding_type == SCANNER_BINDING_ARG)\n              {\n                literal_p->type |= SCANNER_LITERAL_IS_ARG;\n\n                if (literal_p->type & SCANNER_LITERAL_IS_USED)\n                {\n                  literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n                  break;\n                }\n              }\n            }\n\n            if (literal_p->type & SCANNER_LITERAL_IS_USED)\n            {\n              literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n              break;\n            }\n          }\n\n          scanner_binding_item_t *binding_item_p;\n          binding_item_p = (scanner_binding_item_t *) scanner_malloc (context_p, sizeof (scanner_binding_item_t));\n\n          binding_item_p->next_p = scanner_context.active_binding_list_p->items_p;\n          binding_item_p->literal_p = literal_p;\n\n          scanner_context.active_binding_list_p->items_p = binding_item_p;\n\n          lexer_next_token (context_p);\n          if (context_p->token.type != LEXER_ASSIGN)\n          {\n            continue;\n          }\n\n          scanner_binding_literal_t binding_literal;\n          binding_literal.literal_p = literal_p;\n\n          parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));\n          parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);\n\n          scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n          break;\n        }\n#endif /* JERRY_ESNEXT */\n      }\n\n      lexer_next_token (context_p);\n    }\n\nscan_completed:\n    if (context_p->stack_top_uint8 != SCAN_STACK_SCRIPT\n        && context_p->stack_top_uint8 != SCAN_STACK_SCRIPT_FUNCTION)\n    {\n      scanner_raise_error (context_p);\n    }\n\n    scanner_pop_literal_pool (context_p, &scanner_context);\n\n#if JERRY_ESNEXT\n    JERRY_ASSERT (scanner_context.active_binding_list_p == NULL);\n#endif /* JERRY_ESNEXT */\n    JERRY_ASSERT (scanner_context.active_literal_pool_p == NULL);\n\n#ifndef JERRY_NDEBUG\n    scanner_context.context_status_flags |= PARSER_SCANNING_SUCCESSFUL;\n#endif /* !JERRY_NDEBUG */\n  }\n  PARSER_CATCH\n  {\n#if JERRY_ESNEXT\n    while (scanner_context.active_binding_list_p != NULL)\n    {\n      scanner_pop_binding_list (&scanner_context);\n    }\n#endif /* JERRY_ESNEXT */\n\n    if (JERRY_UNLIKELY (context_p->error != PARSER_ERR_OUT_OF_MEMORY))\n    {\n      /* Ignore the errors thrown by the lexer. */\n      context_p->error = PARSER_ERR_NO_ERROR;\n\n      /* The following code may allocate memory, so it is enclosed in a try/catch. */\n      PARSER_TRY (context_p->try_buffer)\n      {\n#if JERRY_ESNEXT\n        if (scanner_context.status_flags & SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION)\n        {\n          JERRY_ASSERT (scanner_context.async_source_p != NULL);\n\n          scanner_info_t *info_p;\n          info_p = scanner_insert_info (context_p, scanner_context.async_source_p, sizeof (scanner_info_t));\n          info_p->type = SCANNER_TYPE_ERR_ASYNC_FUNCTION;\n        }\n#endif /* JERRY_ESNEXT */\n\n        while (scanner_context.active_literal_pool_p != NULL)\n        {\n          scanner_pop_literal_pool (context_p, &scanner_context);\n        }\n      }\n      PARSER_CATCH\n      {\n        JERRY_ASSERT (context_p->error == PARSER_ERR_OUT_OF_MEMORY);\n      }\n      PARSER_TRY_END\n    }\n\n    JERRY_ASSERT (context_p->error == PARSER_ERR_NO_ERROR || context_p->error == PARSER_ERR_OUT_OF_MEMORY);\n\n    if (context_p->error == PARSER_ERR_OUT_OF_MEMORY)\n    {\n      while (scanner_context.active_literal_pool_p != NULL)\n      {\n        scanner_literal_pool_t *literal_pool_p = scanner_context.active_literal_pool_p;\n\n        scanner_context.active_literal_pool_p = literal_pool_p->prev_p;\n\n        parser_list_free (&literal_pool_p->literal_pool);\n        scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));\n      }\n\n      parser_stack_free (context_p);\n      return;\n    }\n  }\n  PARSER_TRY_END\n\n  context_p->status_flags = scanner_context.context_status_flags;\n#if JERRY_ESNEXT\n  context_p->global_status_flags &= (uint32_t) ~ECMA_PARSE_INTERNAL_PRE_SCANNING;\n#endif /* JERRY_ESNEXT */\n  scanner_reverse_info_list (context_p);\n\n#if JERRY_PARSER_DUMP_BYTE_CODE\n  if (context_p->is_show_opcodes)\n  {\n    scanner_info_t *info_p = context_p->next_scanner_info_p;\n    const uint8_t *source_start_p = (context_p->arguments_start_p == NULL ? context_p->source_start_p\n                                                                          : context_p->arguments_start_p);\n\n    while (info_p->type != SCANNER_TYPE_END)\n    {\n      const char *name_p = NULL;\n      bool print_location = false;\n\n      switch (info_p->type)\n      {\n        case SCANNER_TYPE_END_ARGUMENTS:\n        {\n          JERRY_DEBUG_MSG (\"  END_ARGUMENTS\\n\");\n          source_start_p = context_p->source_start_p;\n          break;\n        }\n        case SCANNER_TYPE_FUNCTION:\n        case SCANNER_TYPE_BLOCK:\n        {\n          const uint8_t *prev_source_p = info_p->source_p - 1;\n          const uint8_t *data_p;\n\n          if (info_p->type == SCANNER_TYPE_FUNCTION)\n          {\n            data_p = (const uint8_t *) (info_p + 1);\n\n            JERRY_DEBUG_MSG (\"  FUNCTION: flags: 0x%x declarations: %d\",\n                             (int) info_p->u8_arg,\n                             (int) info_p->u16_arg);\n          }\n          else\n          {\n            data_p = (const uint8_t *) (info_p + 1);\n\n            JERRY_DEBUG_MSG (\"  BLOCK:\");\n          }\n\n          JERRY_DEBUG_MSG (\" source:%d\\n\", (int) (info_p->source_p - source_start_p));\n\n          while (data_p[0] != SCANNER_STREAM_TYPE_END)\n          {\n            switch (data_p[0] & SCANNER_STREAM_TYPE_MASK)\n            {\n              case SCANNER_STREAM_TYPE_HOLE:\n              {\n                JERRY_DEBUG_MSG (\"    HOLE\\n\");\n                data_p++;\n                continue;\n              }\n#if JERRY_ESNEXT\n              case SCANNER_STREAM_TYPE_ARGUMENTS:\n              {\n                JERRY_DEBUG_MSG (\"    ARGUMENTS%s%s\\n\",\n                                 (data_p[0] & SCANNER_STREAM_NO_REG) ? \" *\" : \"\",\n                                 (data_p[0] & SCANNER_STREAM_LOCAL_ARGUMENTS) ? \" L\" : \"\");\n                data_p++;\n                continue;\n              }\n              case SCANNER_STREAM_TYPE_ARGUMENTS_FUNC:\n              {\n                JERRY_DEBUG_MSG (\"    ARGUMENTS_FUNC%s%s\\n\",\n                                 (data_p[0] & SCANNER_STREAM_NO_REG) ? \" *\" : \"\",\n                                 (data_p[0] & SCANNER_STREAM_LOCAL_ARGUMENTS) ? \" L\" : \"\");\n                data_p++;\n                continue;\n              }\n#else /* !JERRY_ESNEXT */\n              case SCANNER_STREAM_TYPE_ARGUMENTS:\n              {\n                JERRY_DEBUG_MSG (\"    ARGUMENTS%s\\n\",\n                                 (data_p[0] & SCANNER_STREAM_NO_REG) ? \" *\" : \"\");\n                data_p++;\n                continue;\n              }\n#endif /* JERRY_ESNEXT */\n              case SCANNER_STREAM_TYPE_VAR:\n              {\n                JERRY_DEBUG_MSG (\"    VAR \");\n                break;\n              }\n#if JERRY_ESNEXT\n              case SCANNER_STREAM_TYPE_LET:\n              {\n                JERRY_DEBUG_MSG (\"    LET \");\n                break;\n              }\n              case SCANNER_STREAM_TYPE_CONST:\n              {\n                JERRY_DEBUG_MSG (\"    CONST \");\n                break;\n              }\n              case SCANNER_STREAM_TYPE_LOCAL:\n              {\n                JERRY_DEBUG_MSG (\"    LOCAL \");\n                break;\n              }\n#endif /* JERRY_ESNEXT */\n#if JERRY_MODULE_SYSTEM\n              case SCANNER_STREAM_TYPE_IMPORT:\n              {\n                JERRY_DEBUG_MSG (\"    IMPORT \");\n                break;\n              }\n#endif /* JERRY_MODULE_SYSTEM */\n              case SCANNER_STREAM_TYPE_ARG:\n              {\n                JERRY_DEBUG_MSG (\"    ARG \");\n                break;\n              }\n#if JERRY_ESNEXT\n              case SCANNER_STREAM_TYPE_ARG_VAR:\n              {\n                JERRY_DEBUG_MSG (\"    ARG_VAR \");\n                break;\n              }\n              case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:\n              {\n                JERRY_DEBUG_MSG (\"    DESTRUCTURED_ARG \");\n                break;\n              }\n              case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR:\n              {\n                JERRY_DEBUG_MSG (\"    DESTRUCTURED_ARG_VAR \");\n                break;\n              }\n#endif /* JERRY_ESNEXT */\n              case SCANNER_STREAM_TYPE_ARG_FUNC:\n              {\n                JERRY_DEBUG_MSG (\"    ARG_FUNC \");\n                break;\n              }\n#if JERRY_ESNEXT\n              case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:\n              {\n                JERRY_DEBUG_MSG (\"    DESTRUCTURED_ARG_FUNC \");\n                break;\n              }\n#endif /* JERRY_ESNEXT */\n              case SCANNER_STREAM_TYPE_FUNC:\n              {\n                JERRY_DEBUG_MSG (\"    FUNC \");\n                break;\n              }\n              default:\n              {\n                JERRY_UNREACHABLE ();\n                data_p++;\n                continue;\n              }\n            }\n\n            size_t length;\n\n            if (!(data_p[0] & SCANNER_STREAM_UINT16_DIFF))\n            {\n              if (data_p[2] != 0)\n              {\n                prev_source_p += data_p[2];\n                length = 2 + 1;\n              }\n              else\n              {\n                memcpy (&prev_source_p, data_p + 2 + 1, sizeof (uintptr_t));\n                length = 2 + 1 + sizeof (uintptr_t);\n              }\n            }\n            else\n            {\n              int32_t diff = ((int32_t) data_p[2]) | ((int32_t) data_p[3]) << 8;\n\n              if (diff <= UINT8_MAX)\n              {\n                diff = -diff;\n              }\n\n              prev_source_p += diff;\n              length = 2 + 2;\n            }\n\n#if JERRY_ESNEXT\n            if (data_p[0] & SCANNER_STREAM_EARLY_CREATE)\n            {\n              JERRY_ASSERT (data_p[0] & SCANNER_STREAM_NO_REG);\n              JERRY_DEBUG_MSG (\"*\");\n            }\n#endif /* JERRY_ESNEXT */\n\n            if (data_p[0] & SCANNER_STREAM_NO_REG)\n            {\n              JERRY_DEBUG_MSG (\"* \");\n            }\n\n            JERRY_DEBUG_MSG (\"'%.*s'\\n\", data_p[1], (char *) prev_source_p);\n            prev_source_p += data_p[1];\n            data_p += length;\n          }\n          break;\n        }\n        case SCANNER_TYPE_WHILE:\n        {\n          name_p = \"WHILE\";\n          print_location = true;\n          break;\n        }\n        case SCANNER_TYPE_FOR:\n        {\n          scanner_for_info_t *for_info_p = (scanner_for_info_t *) info_p;\n          JERRY_DEBUG_MSG (\"  FOR: source:%d expression:%d[%d:%d] end:%d[%d:%d]\\n\",\n                           (int) (for_info_p->info.source_p - source_start_p),\n                           (int) (for_info_p->expression_location.source_p - source_start_p),\n                           (int) for_info_p->expression_location.line,\n                           (int) for_info_p->expression_location.column,\n                           (int) (for_info_p->end_location.source_p - source_start_p),\n                           (int) for_info_p->end_location.line,\n                           (int) for_info_p->end_location.column);\n          break;\n        }\n        case SCANNER_TYPE_FOR_IN:\n        {\n          name_p = \"FOR-IN\";\n          print_location = true;\n          break;\n        }\n#if JERRY_ESNEXT\n        case SCANNER_TYPE_FOR_OF:\n        {\n          name_p = \"FOR-OF\";\n          print_location = true;\n          break;\n        }\n#endif /* JERRY_ESNEXT */\n        case SCANNER_TYPE_SWITCH:\n        {\n          JERRY_DEBUG_MSG (\"  SWITCH: source:%d\\n\",\n                           (int) (info_p->source_p - source_start_p));\n\n          scanner_case_info_t *current_case_p = ((scanner_switch_info_t *) info_p)->case_p;\n\n          while (current_case_p != NULL)\n          {\n            JERRY_DEBUG_MSG (\"    CASE: location:%d[%d:%d]\\n\",\n                             (int) (current_case_p->location.source_p - source_start_p),\n                             (int) current_case_p->location.line,\n                             (int) current_case_p->location.column);\n\n            current_case_p = current_case_p->next_p;\n          }\n          break;\n        }\n        case SCANNER_TYPE_CASE:\n        {\n          name_p = \"CASE\";\n          print_location = true;\n          break;\n        }\n#if JERRY_ESNEXT\n        case SCANNER_TYPE_INITIALIZER:\n        {\n          scanner_location_info_t *location_info_p = (scanner_location_info_t *) info_p;\n          JERRY_DEBUG_MSG (\"  INITIALIZER: flags: 0x%x source:%d location:%d[%d:%d]\\n\",\n                           (int) info_p->u8_arg,\n                           (int) (location_info_p->info.source_p - source_start_p),\n                           (int) (location_info_p->location.source_p - source_start_p),\n                           (int) location_info_p->location.line,\n                           (int) location_info_p->location.column);\n          break;\n        }\n        case SCANNER_TYPE_CLASS_CONSTRUCTOR:\n        {\n          JERRY_DEBUG_MSG (\"  CLASS_CONSTRUCTOR: source:%d\\n\",\n                           (int) (info_p->source_p - source_start_p));\n          print_location = false;\n          break;\n        }\n        case SCANNER_TYPE_CLASS_FIELD_INITIALIZER_END:\n        {\n          name_p = \"SCANNER_TYPE_CLASS_FIELD_INITIALIZER_END\";\n          print_location = true;\n          break;\n        }\n        case SCANNER_TYPE_LET_EXPRESSION:\n        {\n          JERRY_DEBUG_MSG (\"  LET_EXPRESSION: source:%d\\n\",\n                           (int) (info_p->source_p - source_start_p));\n          break;\n        }\n        case SCANNER_TYPE_ERR_REDECLARED:\n        {\n          JERRY_DEBUG_MSG (\"  ERR_REDECLARED: source:%d\\n\",\n                           (int) (info_p->source_p - source_start_p));\n          break;\n        }\n        case SCANNER_TYPE_ERR_ASYNC_FUNCTION:\n        {\n          JERRY_DEBUG_MSG (\"  ERR_ASYNC_FUNCTION: source:%d\\n\",\n                           (int) (info_p->source_p - source_start_p));\n          break;\n        }\n        case SCANNER_TYPE_LITERAL_FLAGS:\n        {\n          JERRY_DEBUG_MSG (\"  SCANNER_TYPE_LITERAL_FLAGS: flags: 0x%x source:%d\\n\",\n                           (int) info_p->u8_arg,\n                           (int) (info_p->source_p - source_start_p));\n          print_location = false;\n          break;\n        }\n        case SCANNER_TYPE_EXPORT_MODULE_SPECIFIER:\n        {\n          JERRY_DEBUG_MSG (\"  EXPORT_WITH_MODULE_SPECIFIER: source:%d\\n\",\n                           (int) (info_p->source_p - source_start_p));\n          print_location = false;\n          break;\n        }\n#endif /* JERRY_ESNEXT */\n      }\n\n      if (print_location)\n      {\n        scanner_location_info_t *location_info_p = (scanner_location_info_t *) info_p;\n        JERRY_DEBUG_MSG (\"  %s: source:%d location:%d[%d:%d]\\n\",\n                         name_p,\n                         (int) (location_info_p->info.source_p - source_start_p),\n                         (int) (location_info_p->location.source_p - source_start_p),\n                         (int) location_info_p->location.line,\n                         (int) location_info_p->location.column);\n      }\n\n      info_p = info_p->next_p;\n    }\n\n    JERRY_DEBUG_MSG (\"\\n--- Scanning end ---\\n\\n\");\n  }\n#endif /* JERRY_PARSER_DUMP_BYTE_CODE */\n\n  parser_stack_free (context_p);\n}",
        "begin_line": 2476,
        "end_line": 3870,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner.scanner_scan_post_primary_expression#363",
        "src_path": "jerry-core/parser/js/js-scanner.c",
        "class_name": "jerry-core.parser.js.js-scanner",
        "signature": "jerry-core.parser.js.js-scanner.scanner_scan_post_primary_expression (parser_context_t *context_p, /**< context */                                       scanner_context_t *scanner_context_p, /**< scanner context */                                       lexer_token_type_t type, /**< current token type */                                       scan_stack_modes_t stack_top) /**< current stack top */",
        "snippet": "static bool\nscanner_scan_post_primary_expression (parser_context_t *context_p, /**< context */\n                                      scanner_context_t *scanner_context_p, /**< scanner context */\n                                      lexer_token_type_t type, /**< current token type */\n                                      scan_stack_modes_t stack_top) /**< current stack top */\n{\n  switch (type)\n  {\n    case LEXER_DOT:\n    {\n      lexer_scan_identifier (context_p);\n\n      if (context_p->token.type != LEXER_LITERAL\n          || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      return true;\n    }\n    case LEXER_LEFT_PAREN:\n    {\n      parser_stack_push_uint8 (context_p, SCAN_STACK_PAREN_EXPRESSION);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      return true;\n    }\n#if JERRY_ESNEXT\n    case LEXER_TEMPLATE_LITERAL:\n    {\n      if (JERRY_UNLIKELY (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT))\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        parser_stack_push_uint8 (context_p, SCAN_STACK_TAGGED_TEMPLATE_LITERAL);\n      }\n      return true;\n    }\n#endif /* JERRY_ESNEXT */\n    case LEXER_LEFT_SQUARE:\n    {\n      parser_stack_push_uint8 (context_p, SCAN_STACK_PROPERTY_ACCESSOR);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      return true;\n    }\n    case LEXER_INCREASE:\n    case LEXER_DECREASE:\n    {\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n\n      if (context_p->token.flags & LEXER_WAS_NEWLINE)\n      {\n        return false;\n      }\n\n      lexer_next_token (context_p);\n      type = (lexer_token_type_t) context_p->token.type;\n\n      if (type != LEXER_QUESTION_MARK)\n      {\n        break;\n      }\n      /* FALLTHRU */\n    }\n    case LEXER_QUESTION_MARK:\n    {\n      parser_stack_push_uint8 (context_p, SCAN_STACK_COLON_EXPRESSION);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      return true;\n    }\n    default:\n    {\n      break;\n    }\n  }\n\n  if (LEXER_IS_BINARY_OP_TOKEN (type)\n      && (type != LEXER_KEYW_IN || !SCANNER_IS_FOR_START (stack_top)))\n  {\n    scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n    return true;\n  }\n\n  return false;\n}",
        "begin_line": 363,
        "end_line": 445,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner.scanner_scan_primary_expression#74",
        "src_path": "jerry-core/parser/js/js-scanner.c",
        "class_name": "jerry-core.parser.js.js-scanner",
        "signature": "jerry-core.parser.js.js-scanner.scanner_scan_primary_expression (parser_context_t *context_p, /**< context */                                  scanner_context_t *scanner_context_p, /* scanner context */                                  lexer_token_type_t type, /**< current token type */                                  scan_stack_modes_t stack_top) /**< current stack top */",
        "snippet": "static scan_return_types_t\nscanner_scan_primary_expression (parser_context_t *context_p, /**< context */\n                                 scanner_context_t *scanner_context_p, /* scanner context */\n                                 lexer_token_type_t type, /**< current token type */\n                                 scan_stack_modes_t stack_top) /**< current stack top */\n{\n  switch (type)\n  {\n    case LEXER_KEYW_NEW:\n    {\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_AFTER_NEW;\n\n#if JERRY_ESNEXT\n      if (scanner_try_scan_new_target (context_p))\n      {\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      }\n#endif /* JERRY_ESNEXT */\n      break;\n    }\n    case LEXER_DIVIDE:\n    case LEXER_ASSIGN_DIVIDE:\n    {\n      lexer_construct_regexp_object (context_p, true);\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      break;\n    }\n    case LEXER_KEYW_FUNCTION:\n    {\n      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION;\n#if JERRY_MODULE_SYSTEM\n      bool is_export_default = stack_top == SCAN_STACK_EXPORT_DEFAULT;\n#endif /* JERRY_MODULE_SYSTEM */\n\n#if JERRY_ESNEXT\n      if (scanner_context_p->async_source_p != NULL)\n      {\n        status_flags |= SCANNER_LITERAL_POOL_ASYNC;\n      }\n\n      if (lexer_consume_generator (context_p))\n      {\n        status_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n      }\n#endif /* JERRY_ESNEXT */\n\n      scanner_push_literal_pool (context_p, scanner_context_p, status_flags);\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type == LEXER_LITERAL\n          && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n      {\n#if JERRY_MODULE_SYSTEM\n        if (is_export_default)\n        {\n          lexer_lit_location_t *location_p;\n          location_p = scanner_add_custom_literal (context_p,\n                                                   scanner_context_p->active_literal_pool_p->prev_p,\n                                                   &context_p->token.lit_location);\n\n          scanner_detect_invalid_let (context_p, location_p);\n          location_p->type |= SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LET;\n        }\n#endif /* JERRY_MODULE_SYSTEM */\n        lexer_next_token (context_p);\n      }\n#if JERRY_MODULE_SYSTEM\n      else if (is_export_default)\n      {\n        lexer_lit_location_t *location_p;\n        location_p = scanner_add_custom_literal (context_p,\n                                                 scanner_context_p->active_literal_pool_p->prev_p,\n                                                 &lexer_default_literal);\n        location_p->type |= SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LET;\n      }\n#endif /* JERRY_MODULE_SYSTEM */\n\n      parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_EXPRESSION);\n      scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n      return SCAN_KEEP_TOKEN;\n    }\n    case LEXER_LEFT_PAREN:\n    {\n      scanner_scan_bracket (context_p, scanner_context_p);\n      return SCAN_KEEP_TOKEN;\n    }\n    case LEXER_LEFT_SQUARE:\n    {\n#if JERRY_ESNEXT\n      scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_NONE, false);\n#endif /* JERRY_ESNEXT */\n\n      parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      break;\n    }\n    case LEXER_LEFT_BRACE:\n    {\n#if JERRY_ESNEXT\n      scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_NONE, false);\n      parser_stack_push_uint8 (context_p, 0);\n#endif /* JERRY_ESNEXT */\n\n      parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n      scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;\n      return SCAN_KEEP_TOKEN;\n    }\n#if JERRY_ESNEXT\n    case LEXER_TEMPLATE_LITERAL:\n    {\n      if (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)\n      {\n        parser_stack_push_uint8 (context_p, SCAN_STACK_TEMPLATE_STRING);\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        break;\n      }\n\n      /* The string is a normal string literal. */\n      /* FALLTHRU */\n    }\n#endif /* JERRY_ESNEXT */\n    case LEXER_LITERAL:\n    {\n#if JERRY_ESNEXT\n      const uint8_t *source_p = context_p->source_p;\n\n      if (context_p->token.lit_location.type == LEXER_IDENT_LITERAL\n          && lexer_check_arrow (context_p))\n      {\n        scanner_scan_simple_arrow (context_p, scanner_context_p, source_p);\n        return SCAN_KEEP_TOKEN;\n      }\n\n      if (JERRY_UNLIKELY (lexer_token_is_async (context_p)))\n      {\n        scanner_context_p->async_source_p = source_p;\n        scanner_check_async_function (context_p, scanner_context_p);\n        return SCAN_KEEP_TOKEN;\n      }\n#endif /* JERRY_ESNEXT */\n\n      if (context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n      {\n#if JERRY_MODULE_SYSTEM\n        if (stack_top == SCAN_STACK_EXPORT_DEFAULT)\n        {\n          lexer_lit_location_t *location_p = scanner_add_literal (context_p, scanner_context_p);\n          location_p->type |= (SCANNER_LITERAL_IS_USED | SCANNER_LITERAL_IS_VAR);\n          scanner_detect_eval_call (context_p, scanner_context_p);\n          scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n          break;\n        }\n#endif /* JERRY_MODULE_SYSTEM */\n\n        scanner_add_reference (context_p, scanner_context_p);\n      }\n      /* FALLTHRU */\n    }\n    case LEXER_KEYW_THIS:\n    case LEXER_LIT_TRUE:\n    case LEXER_LIT_FALSE:\n    case LEXER_LIT_NULL:\n    {\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      break;\n    }\n#if JERRY_ESNEXT\n    case LEXER_KEYW_SUPER:\n    {\n      scanner_context_p->active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_HAS_SUPER_REFERENCE;\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      break;\n    }\n    case LEXER_KEYW_CLASS:\n    {\n      scanner_push_class_declaration (context_p, scanner_context_p, SCAN_STACK_CLASS_EXPRESSION);\n\n      if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n      {\n        return SCAN_KEEP_TOKEN;\n      }\n      break;\n    }\n#endif /* JERRY_ESNEXT */\n    case LEXER_RIGHT_SQUARE:\n    {\n      if (stack_top != SCAN_STACK_ARRAY_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n      return SCAN_KEEP_TOKEN;\n    }\n#if JERRY_ESNEXT\n    case LEXER_THREE_DOTS:\n    {\n      /* Elision or spread arguments */\n      if (stack_top != SCAN_STACK_PAREN_EXPRESSION && stack_top != SCAN_STACK_ARRAY_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      break;\n    }\n#endif /* JERRY_ESNEXT */\n    case LEXER_COMMA:\n    {\n      if (stack_top != SCAN_STACK_ARRAY_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n#if JERRY_ESNEXT\n      if (scanner_context_p->binding_type != SCANNER_BINDING_NONE)\n      {\n        scanner_context_p->mode = SCAN_MODE_BINDING;\n      }\n#endif /* JERRY_ESNEXT */\n      break;\n    }\n#if JERRY_ESNEXT\n    case LEXER_KEYW_YIELD:\n    {\n      lexer_next_token (context_p);\n\n      if (lexer_check_yield_no_arg (context_p))\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n      }\n\n      if (context_p->token.type == LEXER_MULTIPLY)\n      {\n        return SCAN_NEXT_TOKEN;\n      }\n      return SCAN_KEEP_TOKEN;\n    }\n#endif /* JERRY_ESNEXT */\n#if JERRY_MODULE_SYSTEM\n    case LEXER_KEYW_IMPORT:\n    {\n      lexer_next_token (context_p);\n\n      if (context_p->token.type == LEXER_DOT)\n      {\n        scanner_check_import_meta (context_p);\n      }\n      else if (context_p->token.type != LEXER_LEFT_PAREN)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      return SCAN_KEEP_TOKEN;\n    }\n#endif /* JERRY_MODULE_SYSTEM */\n    case LEXER_RIGHT_PAREN:\n    {\n      if (stack_top == SCAN_STACK_PAREN_EXPRESSION)\n      {\n        parser_stack_pop_uint8 (context_p);\n\n#if JERRY_ESNEXT\n        if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)\n        {\n          scanner_add_async_literal (context_p, scanner_context_p);\n        }\n#endif /* JERRY_ESNEXT */\n\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n        break;\n      }\n      /* FALLTHRU */\n    }\n    default:\n    {\n      scanner_raise_error (context_p);\n    }\n  }\n  return SCAN_NEXT_TOKEN;\n}",
        "begin_line": 74,
        "end_line": 356,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner.scanner_scan_primary_expression_end#452",
        "src_path": "jerry-core/parser/js/js-scanner.c",
        "class_name": "jerry-core.parser.js.js-scanner",
        "signature": "jerry-core.parser.js.js-scanner.scanner_scan_primary_expression_end (parser_context_t *context_p, /**< context */                                      scanner_context_t *scanner_context_p, /**< scanner context */                                      lexer_token_type_t type, /**< current token type */                                      scan_stack_modes_t stack_top) /**< current stack top */",
        "snippet": "static scan_return_types_t\nscanner_scan_primary_expression_end (parser_context_t *context_p, /**< context */\n                                     scanner_context_t *scanner_context_p, /**< scanner context */\n                                     lexer_token_type_t type, /**< current token type */\n                                     scan_stack_modes_t stack_top) /**< current stack top */\n{\n  if (type == LEXER_COMMA)\n  {\n    switch (stack_top)\n    {\n      case SCAN_STACK_VAR:\n#if JERRY_ESNEXT\n      case SCAN_STACK_LET:\n      case SCAN_STACK_CONST:\n#endif /* JERRY_ESNEXT */\n      case SCAN_STACK_FOR_VAR_START:\n#if JERRY_ESNEXT\n      case SCAN_STACK_FOR_LET_START:\n      case SCAN_STACK_FOR_CONST_START:\n#endif /* JERRY_ESNEXT */\n      {\n        scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n        return SCAN_NEXT_TOKEN;\n      }\n      case SCAN_STACK_COLON_EXPRESSION:\n      {\n        scanner_raise_error (context_p);\n        break;\n      }\n#if JERRY_ESNEXT\n      case SCAN_STACK_BINDING_INIT:\n      case SCAN_STACK_BINDING_LIST_INIT:\n      {\n        break;\n      }\n      case SCAN_STACK_ARROW_ARGUMENTS:\n      {\n        lexer_next_token (context_p);\n        scanner_check_arrow_arg (context_p, scanner_context_p);\n        return SCAN_KEEP_TOKEN;\n      }\n      case SCAN_STACK_ARROW_EXPRESSION:\n      {\n        break;\n      }\n      case SCAN_STACK_CLASS_FIELD_INITIALIZER:\n      {\n        scanner_raise_error (context_p);\n        break;\n      }\n      case SCAN_STACK_FUNCTION_PARAMETERS:\n      {\n        scanner_context_p->mode = SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS;\n        parser_stack_pop_uint8 (context_p);\n        return SCAN_NEXT_TOKEN;\n      }\n      case SCAN_STACK_ARRAY_LITERAL:\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n        if (scanner_context_p->binding_type != SCANNER_BINDING_NONE)\n        {\n          scanner_context_p->mode = SCAN_MODE_BINDING;\n        }\n\n        return SCAN_NEXT_TOKEN;\n      }\n#endif /* JERRY_ESNEXT */\n      case SCAN_STACK_OBJECT_LITERAL:\n      {\n        scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;\n        return SCAN_KEEP_TOKEN;\n      }\n      default:\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_NEXT_TOKEN;\n      }\n    }\n  }\n\n  switch (stack_top)\n  {\n    case SCAN_STACK_WITH_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      parser_stack_pop_uint8 (context_p);\n\n      uint16_t status_flags = scanner_context_p->active_literal_pool_p->status_flags;\n      parser_stack_push_uint8 (context_p, (status_flags & SCANNER_LITERAL_POOL_IN_WITH) ? 1 : 0);\n      parser_stack_push_uint8 (context_p, SCAN_STACK_WITH_STATEMENT);\n      status_flags |= SCANNER_LITERAL_POOL_IN_WITH;\n      scanner_context_p->active_literal_pool_p->status_flags = status_flags;\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_DO_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_WHILE_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      scanner_source_start_t source_start;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));\n\n      scanner_location_info_t *location_info_p;\n      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,\n                                                                         source_start.source_p,\n                                                                         sizeof (scanner_location_info_t));\n      location_info_p->info.type = SCANNER_TYPE_WHILE;\n\n      scanner_get_location (&location_info_p->location, context_p);\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_PAREN_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      parser_stack_pop_uint8 (context_p);\n\n#if JERRY_ESNEXT\n      if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)\n      {\n        scanner_add_async_literal (context_p, scanner_context_p);\n      }\n#endif /* JERRY_ESNEXT */\n\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_STATEMENT_WITH_EXPR:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      parser_stack_pop_uint8 (context_p);\n\n#if JERRY_ESNEXT\n      if (context_p->stack_top_uint8 == SCAN_STACK_IF_STATEMENT)\n      {\n        scanner_check_function_after_if (context_p, scanner_context_p);\n        return SCAN_KEEP_TOKEN;\n      }\n#endif /* JERRY_ESNEXT */\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_NEXT_TOKEN;\n    }\n#if JERRY_ESNEXT\n    case SCAN_STACK_BINDING_LIST_INIT:\n    {\n      parser_stack_pop_uint8 (context_p);\n\n      JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_ARRAY_LITERAL\n                    || context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL\n                    || context_p->stack_top_uint8 == SCAN_STACK_LET\n                    || context_p->stack_top_uint8 == SCAN_STACK_CONST\n                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_LET_START\n                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_CONST_START\n                    || context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_PARAMETERS\n                    || context_p->stack_top_uint8 == SCAN_STACK_ARROW_ARGUMENTS);\n\n      scanner_binding_item_t *item_p = scanner_context_p->active_binding_list_p->items_p;\n\n      while (item_p != NULL)\n      {\n        if (item_p->literal_p->type & SCANNER_LITERAL_IS_USED)\n        {\n          item_p->literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n        }\n        item_p = item_p->next_p;\n      }\n\n      scanner_pop_binding_list (scanner_context_p);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_BINDING_INIT:\n    {\n      scanner_binding_literal_t binding_literal;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &binding_literal, sizeof (scanner_binding_literal_t));\n\n      JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_ARRAY_LITERAL\n                    || context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL\n                    || context_p->stack_top_uint8 == SCAN_STACK_LET\n                    || context_p->stack_top_uint8 == SCAN_STACK_CONST\n                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_LET_START\n                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_CONST_START\n                    || context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_PARAMETERS\n                    || context_p->stack_top_uint8 == SCAN_STACK_ARROW_ARGUMENTS);\n\n      JERRY_ASSERT (SCANNER_NEEDS_BINDING_LIST (scanner_context_p->binding_type)\n                    || (stack_top != SCAN_STACK_ARRAY_LITERAL && stack_top != SCAN_STACK_OBJECT_LITERAL));\n\n      if (binding_literal.literal_p->type & SCANNER_LITERAL_IS_USED)\n      {\n        binding_literal.literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n      return SCAN_KEEP_TOKEN;\n    }\n#endif /* JERRY_ESNEXT */\n    case SCAN_STACK_VAR:\n#if JERRY_ESNEXT\n    case SCAN_STACK_LET:\n    case SCAN_STACK_CONST:\n#endif /* JERRY_ESNEXT */\n    {\n#if JERRY_MODULE_SYSTEM\n      scanner_context_p->active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;\n#endif /* JERRY_MODULE_SYSTEM */\n\n      parser_stack_pop_uint8 (context_p);\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_FOR_VAR_START:\n#if JERRY_ESNEXT\n    case SCAN_STACK_FOR_LET_START:\n    case SCAN_STACK_FOR_CONST_START:\n#endif /* JERRY_ESNEXT */\n    case SCAN_STACK_FOR_START:\n    {\n      if (type == LEXER_KEYW_IN || SCANNER_IDENTIFIER_IS_OF ())\n      {\n        scanner_for_statement_t for_statement;\n\n        parser_stack_pop_uint8 (context_p);\n        parser_stack_pop (context_p, &for_statement, sizeof (scanner_for_statement_t));\n\n        scanner_location_info_t *location_info;\n        location_info = (scanner_location_info_t *) scanner_insert_info (context_p,\n                                                                         for_statement.u.source_p,\n                                                                         sizeof (scanner_location_info_t));\n#if JERRY_ESNEXT\n        location_info->info.type = (type == LEXER_KEYW_IN) ? SCANNER_TYPE_FOR_IN : SCANNER_TYPE_FOR_OF;\n\n        if (stack_top == SCAN_STACK_FOR_LET_START || stack_top == SCAN_STACK_FOR_CONST_START)\n        {\n          parser_stack_push_uint8 (context_p, SCAN_STACK_PRIVATE_BLOCK_EARLY);\n        }\n#else /* !JERRY_ESNEXT */\n        location_info->info.type = SCANNER_TYPE_FOR_IN;\n#endif /* JERRY_ESNEXT */\n\n        scanner_get_location (&location_info->location, context_p);\n\n        parser_stack_push_uint8 (context_p, SCAN_STACK_STATEMENT_WITH_EXPR);\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_NEXT_TOKEN;\n      }\n\n      if (type != LEXER_SEMICOLON)\n      {\n        break;\n      }\n\n      scanner_for_statement_t for_statement;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, NULL, sizeof (scanner_for_statement_t));\n\n#if JERRY_ESNEXT\n      if (stack_top == SCAN_STACK_FOR_LET_START || stack_top == SCAN_STACK_FOR_CONST_START)\n      {\n        parser_stack_push_uint8 (context_p, SCAN_STACK_PRIVATE_BLOCK);\n      }\n#endif /* JERRY_ESNEXT */\n\n      for_statement.u.source_p = context_p->source_p;\n      parser_stack_push (context_p, &for_statement, sizeof (scanner_for_statement_t));\n      parser_stack_push_uint8 (context_p, SCAN_STACK_FOR_CONDITION);\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_SEMICOLON)\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      type = LEXER_SEMICOLON;\n      /* FALLTHRU */\n    }\n    case SCAN_STACK_FOR_CONDITION:\n    {\n      if (type != LEXER_SEMICOLON)\n      {\n        break;\n      }\n\n      scanner_for_statement_t for_statement;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &for_statement, sizeof (scanner_for_statement_t));\n\n      scanner_for_info_t *for_info_p;\n      for_info_p = (scanner_for_info_t *) scanner_insert_info (context_p,\n                                                               for_statement.u.source_p,\n                                                               sizeof (scanner_for_info_t));\n      for_info_p->info.type = SCANNER_TYPE_FOR;\n\n      scanner_get_location (&for_info_p->expression_location, context_p);\n      for_info_p->end_location.source_p = NULL;\n\n      for_statement.u.for_info_p = for_info_p;\n\n      parser_stack_push (context_p, &for_statement, sizeof (scanner_for_statement_t));\n      parser_stack_push_uint8 (context_p, SCAN_STACK_FOR_EXPRESSION);\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_RIGHT_PAREN)\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      type = LEXER_RIGHT_PAREN;\n      /* FALLTHRU */\n    }\n    case SCAN_STACK_FOR_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      scanner_for_statement_t for_statement;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &for_statement, sizeof (scanner_for_statement_t));\n\n      scanner_get_location (&for_statement.u.for_info_p->end_location, context_p);\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_SWITCH_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_LEFT_BRACE)\n      {\n        break;\n      }\n\n#if JERRY_ESNEXT\n      scanner_literal_pool_t *literal_pool_p;\n      literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);\n      literal_pool_p->source_p = context_p->source_p - 1;\n#endif /* JERRY_ESNEXT */\n\n      parser_stack_pop_uint8 (context_p);\n\n      scanner_switch_statement_t switch_statement = scanner_context_p->active_switch_statement;\n      parser_stack_push (context_p, &switch_statement, sizeof (scanner_switch_statement_t));\n      parser_stack_push_uint8 (context_p, SCAN_STACK_SWITCH_BLOCK);\n\n      scanner_switch_info_t *switch_info_p;\n      switch_info_p = (scanner_switch_info_t *) scanner_insert_info (context_p,\n                                                                     context_p->source_p,\n                                                                     sizeof (scanner_switch_info_t));\n      switch_info_p->info.type = SCANNER_TYPE_SWITCH;\n      switch_info_p->case_p = NULL;\n      scanner_context_p->active_switch_statement.last_case_p = &switch_info_p->case_p;\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_RIGHT_BRACE\n          && context_p->token.type != LEXER_KEYW_CASE\n          && context_p->token.type != LEXER_KEYW_DEFAULT)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_CASE_STATEMENT:\n    {\n      if (type != LEXER_COLON)\n      {\n        break;\n      }\n\n      scanner_source_start_t source_start;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));\n\n      scanner_location_info_t *location_info_p;\n      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,\n                                                                         source_start.source_p,\n                                                                         sizeof (scanner_location_info_t));\n      location_info_p->info.type = SCANNER_TYPE_CASE;\n\n      scanner_get_location (&location_info_p->location, context_p);\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_COLON_EXPRESSION:\n    {\n      if (type != LEXER_COLON)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      parser_stack_pop_uint8 (context_p);\n      return SCAN_NEXT_TOKEN;\n    }\n#if JERRY_ESNEXT\n    case SCAN_STACK_ARRAY_LITERAL:\n    case SCAN_STACK_OBJECT_LITERAL:\n    {\n      if ((stack_top == SCAN_STACK_ARRAY_LITERAL && type != LEXER_RIGHT_SQUARE)\n          || (stack_top == SCAN_STACK_OBJECT_LITERAL && type != LEXER_RIGHT_BRACE))\n      {\n        break;\n      }\n\n      scanner_source_start_t source_start;\n      uint8_t binding_type = scanner_context_p->binding_type;\n      uint8_t object_literal_flags = 0;\n\n      parser_stack_pop_uint8 (context_p);\n\n      if (stack_top == SCAN_STACK_OBJECT_LITERAL)\n      {\n        object_literal_flags = context_p->stack_top_uint8;\n        parser_stack_pop_uint8 (context_p);\n      }\n\n      scanner_context_p->binding_type = context_p->stack_top_uint8;\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));\n\n      lexer_next_token (context_p);\n\n      stack_top = (scan_stack_modes_t) context_p->stack_top_uint8;\n\n      if (binding_type == SCANNER_BINDING_CATCH && stack_top == SCAN_STACK_CATCH_STATEMENT)\n      {\n        scanner_pop_binding_list (scanner_context_p);\n\n#if JERRY_ESNEXT\n        if (object_literal_flags != 0)\n        {\n          scanner_info_t *info_p = scanner_insert_info (context_p, source_start.source_p, sizeof (scanner_info_t));\n          info_p->type = SCANNER_TYPE_LITERAL_FLAGS;\n          info_p->u8_arg = object_literal_flags;\n        }\n#endif /* JERRY_ESNEXT */\n\n        if (context_p->token.type != LEXER_RIGHT_PAREN)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_LEFT_BRACE)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n        return SCAN_NEXT_TOKEN;\n      }\n\n      if (stack_top == SCAN_STACK_FOR_START_PATTERN)\n      {\n        JERRY_ASSERT (binding_type == SCANNER_BINDING_NONE);\n\n        parser_stack_change_last_uint8 (context_p, SCAN_STACK_FOR_START);\n\n        if (context_p->token.type == LEXER_KEYW_IN || SCANNER_IDENTIFIER_IS_OF ())\n        {\n          scanner_info_t *info_p = scanner_insert_info (context_p, source_start.source_p, sizeof (scanner_info_t));\n          info_p->type = SCANNER_TYPE_LITERAL_FLAGS;\n          info_p->u8_arg = object_literal_flags | SCANNER_LITERAL_DESTRUCTURING_FOR;\n          return SCAN_KEEP_TOKEN;\n        }\n      }\n\n      if (context_p->token.type != LEXER_ASSIGN)\n      {\n        if (SCANNER_NEEDS_BINDING_LIST (binding_type))\n        {\n          scanner_pop_binding_list (scanner_context_p);\n        }\n\n#if JERRY_ESNEXT\n        if ((stack_top == SCAN_STACK_ARRAY_LITERAL || stack_top == SCAN_STACK_OBJECT_LITERAL)\n            && (binding_type == SCANNER_BINDING_NONE || binding_type == SCANNER_BINDING_ARROW_ARG)\n            && context_p->token.type != LEXER_EOS\n            && context_p->token.type != LEXER_COMMA\n            && context_p->token.type != LEXER_RIGHT_BRACE\n            && context_p->token.type != LEXER_RIGHT_SQUARE)\n        {\n          object_literal_flags |= SCANNER_LITERAL_NO_DESTRUCTURING;\n        }\n\n        if (object_literal_flags != 0)\n        {\n          scanner_info_t *info_p = scanner_insert_info (context_p, source_start.source_p, sizeof (scanner_info_t));\n          info_p->type = SCANNER_TYPE_LITERAL_FLAGS;\n          info_p->u8_arg = object_literal_flags;\n        }\n#endif /* JERRY_ESNEXT */\n\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      scanner_location_info_t *location_info_p;\n      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,\n                                                                         source_start.source_p,\n                                                                         sizeof (scanner_location_info_t));\n      location_info_p->info.type = SCANNER_TYPE_INITIALIZER;\n      location_info_p->info.u8_arg = object_literal_flags;\n      scanner_get_location (&location_info_p->location, context_p);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n      if (SCANNER_NEEDS_BINDING_LIST (binding_type))\n      {\n        scanner_binding_item_t *item_p = scanner_context_p->active_binding_list_p->items_p;\n\n        while (item_p != NULL)\n        {\n          item_p->literal_p->type &= (uint8_t) ~SCANNER_LITERAL_IS_USED;\n          item_p = item_p->next_p;\n        }\n\n        parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_LIST_INIT);\n      }\n      return SCAN_NEXT_TOKEN;\n    }\n#else /* !JERRY_ESNEXT */\n    case SCAN_STACK_OBJECT_LITERAL:\n    {\n      if (type != LEXER_RIGHT_BRACE)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      parser_stack_pop_uint8 (context_p);\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_ARRAY_LITERAL:\n#endif /* JERRY_ESNEXT */\n    case SCAN_STACK_PROPERTY_ACCESSOR:\n    {\n      if (type != LEXER_RIGHT_SQUARE)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      parser_stack_pop_uint8 (context_p);\n      return SCAN_NEXT_TOKEN;\n    }\n#if JERRY_ESNEXT\n    case SCAN_STACK_COMPUTED_PROPERTY:\n    {\n      if (type != LEXER_RIGHT_SQUARE)\n      {\n        break;\n      }\n\n      lexer_scan_identifier (context_p);\n\n      parser_stack_pop_uint8 (context_p);\n      stack_top = (scan_stack_modes_t) context_p->stack_top_uint8;\n\n      if (stack_top == SCAN_STACK_FUNCTION_PROPERTY)\n      {\n        scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_FUNCTION);\n        scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      if (stack_top == SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR\n          || stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)\n      {\n        JERRY_ASSERT (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CLASS_NAME);\n\n        if (context_p->token.type == LEXER_LEFT_PAREN)\n        {\n          scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_FUNCTION);\n\n          parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n          scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n          return SCAN_KEEP_TOKEN;\n        }\n\n        if (context_p->token.type == LEXER_ASSIGN)\n        {\n          scanner_push_class_field_initializer (context_p, scanner_context_p);\n          return SCAN_NEXT_TOKEN;\n        }\n\n        scanner_context_p->mode = (context_p->token.type != LEXER_SEMICOLON ? SCAN_MODE_CLASS_BODY_NO_SCAN\n                                                                            : SCAN_MODE_CLASS_BODY);\n        return SCAN_KEEP_TOKEN;\n      }\n\n      JERRY_ASSERT (stack_top == SCAN_STACK_OBJECT_LITERAL);\n\n      if (context_p->token.type == LEXER_LEFT_PAREN)\n      {\n        scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_FUNCTION);\n\n        parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n        scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      if (context_p->token.type != LEXER_COLON)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n      if (scanner_context_p->binding_type != SCANNER_BINDING_NONE)\n      {\n        scanner_context_p->mode = SCAN_MODE_BINDING;\n      }\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_COMPUTED_GENERATOR:\n    case SCAN_STACK_COMPUTED_ASYNC:\n    case SCAN_STACK_COMPUTED_ASYNC_GENERATOR:\n    {\n      if (type != LEXER_RIGHT_SQUARE)\n      {\n        break;\n      }\n\n      lexer_next_token (context_p);\n      parser_stack_pop_uint8 (context_p);\n\n      JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL\n                    || context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_PROPERTY);\n\n      uint16_t status_flags = (uint16_t) (SCANNER_LITERAL_POOL_FUNCTION\n                                          | SCANNER_LITERAL_POOL_GENERATOR\n                                          | SCANNER_FROM_COMPUTED_TO_LITERAL_POOL (stack_top));\n\n      scanner_push_literal_pool (context_p, scanner_context_p, status_flags);\n\n      scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_TEMPLATE_STRING:\n    case SCAN_STACK_TAGGED_TEMPLATE_LITERAL:\n    {\n      if (type != LEXER_RIGHT_BRACE)\n      {\n        break;\n      }\n\n      context_p->source_p--;\n      context_p->column--;\n      lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);\n\n      if (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      }\n      else\n      {\n        parser_stack_pop_uint8 (context_p);\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      }\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_ARROW_ARGUMENTS:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      scanner_check_arrow (context_p, scanner_context_p);\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_ARROW_EXPRESSION:\n    {\n      scanner_pop_literal_pool (context_p, scanner_context_p);\n      parser_stack_pop_uint8 (context_p);\n      lexer_update_await_yield (context_p, context_p->status_flags);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_CLASS_EXTENDS:\n    {\n      if (type != LEXER_LEFT_BRACE)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_CLASS_BODY;\n      parser_stack_pop_uint8 (context_p);\n\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_CLASS_FIELD_INITIALIZER:\n    {\n      scanner_source_start_t source_start;\n      const uint8_t *source_p = NULL;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));\n      scanner_pop_literal_pool (context_p, scanner_context_p);\n      scanner_context_p->mode = SCAN_MODE_CLASS_BODY_NO_SCAN;\n\n      switch (type)\n      {\n        case LEXER_SEMICOLON:\n        {\n          source_p = context_p->source_p - 1;\n          scanner_context_p->mode = SCAN_MODE_CLASS_BODY;\n          break;\n        }\n        case LEXER_RIGHT_BRACE:\n        {\n          source_p = context_p->source_p - 1;\n          break;\n        }\n        default:\n        {\n          if (!(context_p->token.flags & LEXER_WAS_NEWLINE))\n          {\n            break;\n          }\n\n          if (type == LEXER_LEFT_SQUARE)\n          {\n            source_p = context_p->source_p - 1;\n            break;\n          }\n\n          if (type == LEXER_LITERAL)\n          {\n            if (context_p->token.lit_location.type == LEXER_IDENT_LITERAL\n                || context_p->token.lit_location.type == LEXER_NUMBER_LITERAL)\n            {\n              source_p = context_p->token.lit_location.char_p;\n            }\n            else if (context_p->token.lit_location.type == LEXER_STRING_LITERAL)\n            {\n              source_p = context_p->token.lit_location.char_p - 1;\n            }\n            break;\n          }\n\n          if (type == context_p->token.keyword_type && type != LEXER_EOS)\n          {\n            /* Convert keyword to literal. */\n            source_p = context_p->token.lit_location.char_p;\n            context_p->token.type = LEXER_LITERAL;\n          }\n          break;\n        }\n      }\n\n      if (JERRY_UNLIKELY (source_p == NULL))\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_location_info_t *location_info_p;\n      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,\n                                                                         source_start.source_p,\n                                                                         sizeof (scanner_location_info_t));\n      location_info_p->info.type = SCANNER_TYPE_CLASS_FIELD_INITIALIZER_END;\n      location_info_p->location.source_p = source_p;\n      location_info_p->location.line = context_p->token.line;\n      location_info_p->location.column = context_p->token.column;\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_FUNCTION_PARAMETERS:\n    {\n      parser_stack_pop_uint8 (context_p);\n\n      if (type != LEXER_RIGHT_PAREN\n          && (type != LEXER_EOS || context_p->stack_top_uint8 != SCAN_STACK_SCRIPT_FUNCTION))\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS;\n      return SCAN_KEEP_TOKEN;\n    }\n#endif /* JERRY_ESNEXT */\n    default:\n    {\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      return SCAN_KEEP_TOKEN;\n    }\n  }\n\n  scanner_raise_error (context_p);\n  return SCAN_NEXT_TOKEN;\n}",
        "begin_line": 452,
        "end_line": 1293,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner.scanner_scan_statement#1300",
        "src_path": "jerry-core/parser/js/js-scanner.c",
        "class_name": "jerry-core.parser.js.js-scanner",
        "signature": "jerry-core.parser.js.js-scanner.scanner_scan_statement (parser_context_t *context_p, /**< context */                         scanner_context_t *scanner_context_p, /**< scanner context */                         lexer_token_type_t type, /**< current token type */                         scan_stack_modes_t stack_top) /**< current stack top */",
        "snippet": "static scan_return_types_t\nscanner_scan_statement (parser_context_t *context_p, /**< context */\n                        scanner_context_t *scanner_context_p, /**< scanner context */\n                        lexer_token_type_t type, /**< current token type */\n                        scan_stack_modes_t stack_top) /**< current stack top */\n{\n  switch (type)\n  {\n    case LEXER_SEMICOLON:\n    {\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      return SCAN_KEEP_TOKEN;\n    }\n    case LEXER_LEFT_BRACE:\n    {\n#if JERRY_ESNEXT\n      scanner_literal_pool_t *literal_pool_p;\n      literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);\n      literal_pool_p->source_p = context_p->source_p;\n#endif /* JERRY_ESNEXT */\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_BLOCK_STATEMENT);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_DO:\n    {\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_DO_STATEMENT);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_TRY:\n    {\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_LEFT_BRACE)\n      {\n        scanner_raise_error (context_p);\n      }\n\n#if JERRY_ESNEXT\n      scanner_literal_pool_t *literal_pool_p;\n      literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);\n      literal_pool_p->source_p = context_p->source_p;\n#endif /* JERRY_ESNEXT */\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_TRY_STATEMENT);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_DEBUGGER:\n    {\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_IF:\n    case LEXER_KEYW_WITH:\n    case LEXER_KEYW_SWITCH:\n    {\n      lexer_next_token (context_p);\n      if (context_p->token.type != LEXER_LEFT_PAREN)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      uint8_t mode = SCAN_STACK_STATEMENT_WITH_EXPR;\n\n      if (type == LEXER_KEYW_IF)\n      {\n        parser_stack_push_uint8 (context_p, SCAN_STACK_IF_STATEMENT);\n      }\n      else if (type == LEXER_KEYW_WITH)\n      {\n        mode = SCAN_STACK_WITH_EXPRESSION;\n      }\n      else if (type == LEXER_KEYW_SWITCH)\n      {\n        mode = SCAN_STACK_SWITCH_EXPRESSION;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      parser_stack_push_uint8 (context_p, mode);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_WHILE:\n    {\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_LEFT_PAREN)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n      scanner_source_start_t source_start;\n      source_start.source_p = context_p->source_p;\n\n      parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));\n      parser_stack_push_uint8 (context_p, SCAN_STACK_WHILE_EXPRESSION);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_FOR:\n    {\n      lexer_next_token (context_p);\n\n#if JERRY_ESNEXT\n      if (context_p->token.type == LEXER_KEYW_AWAIT)\n      {\n        lexer_next_token (context_p);\n      }\n#endif /* JERRY_ESNEXT */\n\n      if (context_p->token.type != LEXER_LEFT_PAREN)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_for_statement_t for_statement;\n      for_statement.u.source_p = context_p->source_p;\n      uint8_t stack_mode = SCAN_STACK_FOR_START;\n      scan_return_types_t return_type = SCAN_KEEP_TOKEN;\n\n      lexer_next_token (context_p);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n#if JERRY_ESNEXT\n      const uint8_t *source_p = context_p->source_p;\n#endif /* JERRY_ESNEXT */\n\n      switch (context_p->token.type)\n      {\n        case LEXER_SEMICOLON:\n        {\n          scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n          break;\n        }\n        case LEXER_KEYW_VAR:\n        {\n          scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n          stack_mode = SCAN_STACK_FOR_VAR_START;\n          return_type = SCAN_NEXT_TOKEN;\n          break;\n        }\n#if JERRY_ESNEXT\n        case LEXER_LEFT_BRACE:\n        case LEXER_LEFT_SQUARE:\n        {\n          stack_mode = SCAN_STACK_FOR_START_PATTERN;\n          break;\n        }\n        case LEXER_LITERAL:\n        {\n          if (!lexer_token_is_let (context_p))\n          {\n            break;\n          }\n\n          parser_line_counter_t line = context_p->line;\n          parser_line_counter_t column = context_p->column;\n\n          if (lexer_check_arrow (context_p))\n          {\n            context_p->source_p = source_p;\n            context_p->line = line;\n            context_p->column = column;\n            context_p->token.flags &= (uint8_t) ~LEXER_NO_SKIP_SPACES;\n            break;\n          }\n\n          lexer_next_token (context_p);\n\n          type = (lexer_token_type_t) context_p->token.type;\n\n          if (type != LEXER_LEFT_SQUARE\n              && type != LEXER_LEFT_BRACE\n              && (type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL))\n          {\n            scanner_info_t *info_p = scanner_insert_info (context_p, source_p, sizeof (scanner_info_t));\n            info_p->type = SCANNER_TYPE_LET_EXPRESSION;\n\n            scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n            break;\n          }\n\n          scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n          /* FALLTHRU */\n        }\n        case LEXER_KEYW_LET:\n        case LEXER_KEYW_CONST:\n        {\n          scanner_literal_pool_t *literal_pool_p;\n          literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);\n          literal_pool_p->source_p = source_p;\n\n          if (scanner_context_p->mode == SCAN_MODE_PRIMARY_EXPRESSION)\n          {\n            scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n            return_type = SCAN_NEXT_TOKEN;\n          }\n\n          stack_mode = ((context_p->token.type == LEXER_KEYW_CONST) ? SCAN_STACK_FOR_CONST_START\n                                                                    : SCAN_STACK_FOR_LET_START);\n          break;\n        }\n#endif /* JERRY_ESNEXT */\n      }\n\n      parser_stack_push (context_p, &for_statement, sizeof (scanner_for_statement_t));\n      parser_stack_push_uint8 (context_p, stack_mode);\n      return return_type;\n    }\n    case LEXER_KEYW_VAR:\n    {\n      scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_VAR);\n      return SCAN_NEXT_TOKEN;\n    }\n#if JERRY_ESNEXT\n    case LEXER_KEYW_LET:\n    {\n      scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_LET);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_CONST:\n    {\n      scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_CONST);\n      return SCAN_NEXT_TOKEN;\n    }\n#endif /* JERRY_ESNEXT */\n    case LEXER_KEYW_THROW:\n    {\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_RETURN:\n    {\n      lexer_next_token (context_p);\n\n      if (!(context_p->token.flags & LEXER_WAS_NEWLINE)\n          && context_p->token.type != LEXER_SEMICOLON\n          && context_p->token.type != LEXER_EOS\n          && context_p->token.type != LEXER_RIGHT_BRACE)\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      return SCAN_KEEP_TOKEN;\n    }\n    case LEXER_KEYW_BREAK:\n    case LEXER_KEYW_CONTINUE:\n    {\n      lexer_next_token (context_p);\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n\n      if (!(context_p->token.flags & LEXER_WAS_NEWLINE)\n          && context_p->token.type == LEXER_LITERAL\n          && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n      {\n        return SCAN_NEXT_TOKEN;\n      }\n      return SCAN_KEEP_TOKEN;\n    }\n    case LEXER_KEYW_CASE:\n    case LEXER_KEYW_DEFAULT:\n    {\n      if (stack_top != SCAN_STACK_SWITCH_BLOCK)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_case_info_t *case_info_p;\n      case_info_p = (scanner_case_info_t *) scanner_malloc (context_p, sizeof (scanner_case_info_t));\n\n      *(scanner_context_p->active_switch_statement.last_case_p) = case_info_p;\n      scanner_context_p->active_switch_statement.last_case_p = &case_info_p->next_p;\n\n      case_info_p->next_p = NULL;\n      scanner_get_location (&case_info_p->location, context_p);\n\n      if (type == LEXER_KEYW_DEFAULT)\n      {\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_COLON)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n        return SCAN_NEXT_TOKEN;\n      }\n\n      scanner_source_start_t source_start;\n      source_start.source_p = context_p->source_p;\n\n      parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));\n      parser_stack_push_uint8 (context_p, SCAN_STACK_CASE_STATEMENT);\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_FUNCTION:\n    {\n#if JERRY_ESNEXT\n      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION | SCANNER_LITERAL_POOL_FUNCTION_STATEMENT;\n\n      if (scanner_context_p->async_source_p != NULL)\n      {\n        scanner_context_p->status_flags |= SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION;\n        status_flags |= SCANNER_LITERAL_POOL_ASYNC;\n      }\n#endif /* JERRY_ESNEXT */\n\n      lexer_next_token (context_p);\n\n#if JERRY_ESNEXT\n      if (context_p->token.type == LEXER_MULTIPLY)\n      {\n        status_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n        lexer_next_token (context_p);\n      }\n#endif /* JERRY_ESNEXT */\n\n      if (context_p->token.type != LEXER_LITERAL\n          || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);\n\n#if JERRY_ESNEXT\n      const uint8_t mask = (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LOCAL);\n\n      if ((literal_p->type & SCANNER_LITERAL_IS_LOCAL)\n          && (literal_p->type & mask) != (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG)\n          && (literal_p->type & mask) != SCANNER_LITERAL_IS_LOCAL_FUNC)\n      {\n        scanner_raise_redeclaration_error (context_p);\n      }\n\n      scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;\n\n      if (!(literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION)\n          && (literal_p->type & (SCANNER_LITERAL_IS_VAR)))\n      {\n        scanner_raise_redeclaration_error (context_p);\n      }\n\n      literal_p->type |= SCANNER_LITERAL_IS_LOCAL_FUNC;\n\n      scanner_context_p->status_flags &= (uint16_t) ~SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION;\n#else\n      literal_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC;\n\n      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION;\n#endif /* JERRY_ESNEXT */\n\n      scanner_push_literal_pool (context_p, scanner_context_p, status_flags);\n\n      scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_STATEMENT);\n      return SCAN_NEXT_TOKEN;\n    }\n#if JERRY_ESNEXT\n    case LEXER_KEYW_CLASS:\n    {\n      lexer_lit_location_t *literal_p;\n      literal_p = scanner_push_class_declaration (context_p, scanner_context_p, SCAN_STACK_CLASS_STATEMENT);\n\n      if (literal_p == NULL)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_detect_invalid_let (context_p, literal_p);\n      literal_p->type |= SCANNER_LITERAL_IS_LET;\n\n      if (literal_p->type & SCANNER_LITERAL_IS_USED)\n      {\n        literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n      }\n\n#if JERRY_MODULE_SYSTEM\n      if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT)\n      {\n        literal_p->type |= SCANNER_LITERAL_NO_REG;\n        scanner_context_p->active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;\n      }\n#endif /* JERRY_MODULE_SYSTEM */\n\n      return SCAN_NEXT_TOKEN;\n    }\n#endif /* JERRY_ESNEXT */\n#if JERRY_MODULE_SYSTEM\n    case LEXER_KEYW_IMPORT:\n    {\n      lexer_next_token (context_p);\n\n      if (context_p->token.type == LEXER_DOT)\n      {\n        scanner_check_import_meta (context_p);\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      if (context_p->token.type == LEXER_LEFT_PAREN)\n      {\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      if (stack_top != SCAN_STACK_SCRIPT)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n\n      if (context_p->token.type == LEXER_LITERAL\n          && context_p->token.lit_location.type == LEXER_STRING_LITERAL)\n      {\n        return SCAN_NEXT_TOKEN;\n      }\n\n      bool parse_imports = true;\n\n      if (context_p->token.type == LEXER_LITERAL\n          && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n      {\n        lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);\n\n        scanner_detect_invalid_let (context_p, literal_p);\n        literal_p->type |= SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_NO_REG;\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type == LEXER_COMMA)\n        {\n          lexer_next_token (context_p);\n        }\n        else\n        {\n          parse_imports = false;\n        }\n      }\n\n      if (parse_imports)\n      {\n        if (context_p->token.type == LEXER_MULTIPLY)\n        {\n          lexer_next_token (context_p);\n          if (!lexer_token_is_identifier (context_p, \"as\", 2))\n          {\n            scanner_raise_error (context_p);\n          }\n\n          lexer_next_token (context_p);\n\n          if (context_p->token.type != LEXER_LITERAL\n              && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);\n\n          scanner_detect_invalid_let (context_p, literal_p);\n          literal_p->type |= SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_NO_REG;\n\n          lexer_next_token (context_p);\n        }\n        else if (context_p->token.type == LEXER_LEFT_BRACE)\n        {\n          lexer_next_token (context_p);\n\n          while (context_p->token.type != LEXER_RIGHT_BRACE)\n          {\n            if (context_p->token.type != LEXER_LITERAL\n                || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n            {\n              scanner_raise_error (context_p);\n            }\n\n            const uint8_t *source_p = context_p->source_p;\n\n            if (lexer_check_next_character (context_p, LIT_CHAR_LOWERCASE_A))\n            {\n              lexer_next_token (context_p);\n\n              if (!lexer_token_is_identifier (context_p, \"as\", 2))\n              {\n                scanner_raise_error (context_p);\n              }\n\n              lexer_next_token (context_p);\n\n              if (context_p->token.type != LEXER_LITERAL\n                  && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n              {\n                scanner_raise_error (context_p);\n              }\n\n              source_p = context_p->source_p;\n            }\n\n            lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);\n\n            if (literal_p->type & (SCANNER_LITERAL_IS_ARG\n                                   | SCANNER_LITERAL_IS_VAR\n                                   | SCANNER_LITERAL_IS_LOCAL))\n            {\n              context_p->source_p = source_p;\n              scanner_raise_redeclaration_error (context_p);\n            }\n\n            if (literal_p->type & SCANNER_LITERAL_IS_FUNC)\n            {\n              literal_p->type &= (uint8_t) ~SCANNER_LITERAL_IS_FUNC;\n            }\n\n            literal_p->type |= SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_NO_REG;\n\n            lexer_next_token (context_p);\n\n            if (context_p->token.type != LEXER_RIGHT_BRACE)\n            {\n              if (context_p->token.type != LEXER_COMMA)\n              {\n                scanner_raise_error (context_p);\n              }\n\n              lexer_next_token (context_p);\n            }\n          }\n\n          lexer_next_token (context_p);\n        }\n        else\n        {\n          scanner_raise_error (context_p);\n        }\n      }\n\n      if (!lexer_token_is_identifier (context_p, \"from\", 4))\n      {\n        scanner_raise_error (context_p);\n      }\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_LITERAL\n          && context_p->token.lit_location.type != LEXER_STRING_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_EXPORT:\n    {\n      if (stack_top != SCAN_STACK_SCRIPT)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type == LEXER_KEYW_DEFAULT)\n      {\n        lexer_next_token (context_p);\n        parser_stack_push_uint8 (context_p, SCAN_STACK_EXPORT_DEFAULT);\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n\n      if (context_p->token.type == LEXER_MULTIPLY)\n      {\n        lexer_next_token (context_p);\n\n        if (lexer_token_is_identifier (context_p, \"as\", 2))\n        {\n          lexer_next_token (context_p);\n\n          if (context_p->token.type != LEXER_LITERAL\n              && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          lexer_next_token (context_p);\n        }\n\n        if (!lexer_token_is_identifier (context_p, \"from\", 4))\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_LITERAL\n            && context_p->token.lit_location.type == LEXER_STRING_LITERAL)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        return SCAN_NEXT_TOKEN;\n      }\n\n      scanner_source_start_t source_start;\n      source_start.source_p = context_p->source_p;\n\n      if (context_p->token.type == LEXER_LEFT_BRACE)\n      {\n        lexer_next_token (context_p);\n\n        while (context_p->token.type != LEXER_RIGHT_BRACE)\n        {\n          if (context_p->token.type != LEXER_LITERAL\n              || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          lexer_next_token (context_p);\n\n          if (lexer_token_is_identifier (context_p, \"as\", 2))\n          {\n            lexer_next_token (context_p);\n\n            if (context_p->token.type != LEXER_LITERAL\n                && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n            {\n              scanner_raise_error (context_p);\n            }\n\n            lexer_next_token (context_p);\n          }\n\n          if (context_p->token.type != LEXER_RIGHT_BRACE)\n          {\n            if (context_p->token.type != LEXER_COMMA)\n            {\n              scanner_raise_error (context_p);\n            }\n\n            lexer_next_token (context_p);\n          }\n        }\n\n        lexer_next_token (context_p);\n\n        if (!lexer_token_is_identifier (context_p, \"from\", 4))\n        {\n          return SCAN_KEEP_TOKEN;\n        }\n\n        scanner_info_t *info_p = scanner_insert_info (context_p, source_start.source_p, sizeof (scanner_info_t));\n        info_p->type = SCANNER_TYPE_EXPORT_MODULE_SPECIFIER;\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_LITERAL\n            && context_p->token.lit_location.type == LEXER_STRING_LITERAL)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        return SCAN_NEXT_TOKEN;\n      }\n\n      switch (context_p->token.type)\n      {\n        case LEXER_KEYW_CLASS:\n        case LEXER_KEYW_LET:\n        case LEXER_KEYW_CONST:\n        case LEXER_KEYW_VAR:\n        {\n          scanner_context_p->active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_IN_EXPORT;\n          break;\n        }\n      }\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_KEEP_TOKEN;\n    }\n#endif /* JERRY_MODULE_SYSTEM */\n    default:\n    {\n      break;\n    }\n  }\n\n  scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n  if (type == LEXER_LITERAL\n      && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n  {\n    if (JERRY_UNLIKELY (lexer_check_next_character (context_p, LIT_CHAR_COLON)))\n    {\n      lexer_consume_next_character (context_p);\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_NEXT_TOKEN;\n    }\n\n    JERRY_ASSERT (context_p->token.flags & LEXER_NO_SKIP_SPACES);\n\n#if JERRY_ESNEXT\n    /* The colon needs to be checked first because the parser also checks\n     * it first, and this check skips the spaces which affects source_p. */\n    if (JERRY_UNLIKELY (lexer_check_arrow (context_p)))\n    {\n      scanner_scan_simple_arrow (context_p, scanner_context_p, context_p->source_p);\n      return SCAN_KEEP_TOKEN;\n    }\n\n    if (JERRY_UNLIKELY (lexer_token_is_let (context_p)))\n    {\n      lexer_lit_location_t let_literal = context_p->token.lit_location;\n      const uint8_t *source_p = context_p->source_p;\n\n      lexer_next_token (context_p);\n\n      type = (lexer_token_type_t) context_p->token.type;\n\n      if (type == LEXER_LEFT_SQUARE\n          || type == LEXER_LEFT_BRACE\n          || (type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL))\n      {\n        scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n        parser_stack_push_uint8 (context_p, SCAN_STACK_LET);\n        return SCAN_KEEP_TOKEN;\n      }\n\n      scanner_info_t *info_p = scanner_insert_info (context_p, source_p, sizeof (scanner_info_t));\n      info_p->type = SCANNER_TYPE_LET_EXPRESSION;\n\n      lexer_lit_location_t *lit_location_p = scanner_add_custom_literal (context_p,\n                                                                         scanner_context_p->active_literal_pool_p,\n                                                                         &let_literal);\n      lit_location_p->type |= SCANNER_LITERAL_IS_USED;\n\n      if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)\n      {\n        lit_location_p->type |= SCANNER_LITERAL_NO_REG;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      return SCAN_KEEP_TOKEN;\n    }\n\n    if (JERRY_UNLIKELY (lexer_token_is_async (context_p)))\n    {\n      scanner_context_p->async_source_p = context_p->source_p;\n\n      if (scanner_check_async_function (context_p, scanner_context_p))\n      {\n        scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      }\n      return SCAN_KEEP_TOKEN;\n    }\n#endif /* JERRY_ESNEXT */\n\n    scanner_add_reference (context_p, scanner_context_p);\n\n    scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n    return SCAN_NEXT_TOKEN;\n  }\n\n  return SCAN_KEEP_TOKEN;\n}",
        "begin_line": 1300,
        "end_line": 2077,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-scanner.scanner_scan_statement_end#2084",
        "src_path": "jerry-core/parser/js/js-scanner.c",
        "class_name": "jerry-core.parser.js.js-scanner",
        "signature": "jerry-core.parser.js.js-scanner.scanner_scan_statement_end (parser_context_t *context_p, /**< context */                             scanner_context_t *scanner_context_p, /**< scanner context */                             lexer_token_type_t type) /**< current token type */",
        "snippet": "static scan_return_types_t\nscanner_scan_statement_end (parser_context_t *context_p, /**< context */\n                            scanner_context_t *scanner_context_p, /**< scanner context */\n                            lexer_token_type_t type) /**< current token type */\n{\n  bool terminator_found = false;\n\n  if (type == LEXER_SEMICOLON)\n  {\n    lexer_next_token (context_p);\n    terminator_found = true;\n  }\n\n  while (true)\n  {\n    type = (lexer_token_type_t) context_p->token.type;\n\n    switch (context_p->stack_top_uint8)\n    {\n      case SCAN_STACK_SCRIPT:\n      case SCAN_STACK_SCRIPT_FUNCTION:\n      {\n        if (type == LEXER_EOS)\n        {\n          return SCAN_NEXT_TOKEN;\n        }\n        break;\n      }\n      case SCAN_STACK_BLOCK_STATEMENT:\n#if JERRY_ESNEXT\n      case SCAN_STACK_CLASS_STATEMENT:\n#endif /* JERRY_ESNEXT */\n      case SCAN_STACK_FUNCTION_STATEMENT:\n      {\n        if (type != LEXER_RIGHT_BRACE)\n        {\n          break;\n        }\n\n#if JERRY_ESNEXT\n        if (context_p->stack_top_uint8 != SCAN_STACK_CLASS_STATEMENT)\n        {\n          scanner_pop_literal_pool (context_p, scanner_context_p);\n        }\n#else /* !JERRY_ESNEXT */\n        if (context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_STATEMENT)\n        {\n          scanner_pop_literal_pool (context_p, scanner_context_p);\n        }\n#endif /* JERRY_ESNEXT */\n\n        terminator_found = true;\n        parser_stack_pop_uint8 (context_p);\n#if JERRY_MODULE_SYSTEM\n        scanner_context_p->active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;\n#endif /* JERRY_MODULE_SYSTEM */\n        lexer_next_token (context_p);\n        continue;\n      }\n      case SCAN_STACK_FUNCTION_EXPRESSION:\n#if JERRY_ESNEXT\n      case SCAN_STACK_FUNCTION_ARROW:\n#endif /* JERRY_ESNEXT */\n      {\n        if (type != LEXER_RIGHT_BRACE)\n        {\n          break;\n        }\n\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n#if JERRY_ESNEXT\n        if (context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_ARROW)\n        {\n          scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n        }\n#endif /* JERRY_ESNEXT */\n\n        scanner_pop_literal_pool (context_p, scanner_context_p);\n        parser_stack_pop_uint8 (context_p);\n\n#if JERRY_MODULE_SYSTEM\n        if (context_p->stack_top_uint8 == SCAN_STACK_EXPORT_DEFAULT)\n        {\n          terminator_found = true;\n          parser_stack_pop_uint8 (context_p);\n          lexer_next_token (context_p);\n          continue;\n        }\n#endif /* JERRY_MODULE_SYSTEM */\n        return SCAN_NEXT_TOKEN;\n      }\n      case SCAN_STACK_FUNCTION_PROPERTY:\n      {\n        if (type != LEXER_RIGHT_BRACE)\n        {\n          break;\n        }\n\n#if JERRY_ESNEXT\n        bool has_super_reference = (scanner_context_p->active_literal_pool_p->status_flags\n                                    & SCANNER_LITERAL_POOL_HAS_SUPER_REFERENCE) != 0;\n#endif /* JERRY_ESNEXT */\n        scanner_pop_literal_pool (context_p, scanner_context_p);\n        parser_stack_pop_uint8 (context_p);\n\n#if JERRY_ESNEXT\n        if (context_p->stack_top_uint8 == SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR\n            || context_p->stack_top_uint8 == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)\n        {\n          scanner_context_p->mode = SCAN_MODE_CLASS_BODY;\n          return SCAN_KEEP_TOKEN;\n        }\n\n        if (has_super_reference && context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL)\n        {\n          *parser_stack_get_prev_uint8 (context_p) |= SCANNER_LITERAL_OBJECT_HAS_SUPER;\n        }\n#else /* JERRY_ESNEXT */\n        JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL);\n#endif /* JERRY_ESNEXT */\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type == LEXER_RIGHT_BRACE)\n        {\n          scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n          return SCAN_KEEP_TOKEN;\n        }\n\n        if (context_p->token.type != LEXER_COMMA)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;\n        return SCAN_KEEP_TOKEN;\n      }\n      case SCAN_STACK_SWITCH_BLOCK:\n      {\n        if (type != LEXER_RIGHT_BRACE)\n        {\n          break;\n        }\n\n        scanner_switch_statement_t switch_statement;\n\n        parser_stack_pop_uint8 (context_p);\n        parser_stack_pop (context_p, &switch_statement, sizeof (scanner_switch_statement_t));\n\n        scanner_context_p->active_switch_statement = switch_statement;\n\n#if JERRY_ESNEXT\n        scanner_pop_literal_pool (context_p, scanner_context_p);\n#endif /* JERRY_ESNEXT */\n\n        terminator_found = true;\n        lexer_next_token (context_p);\n        continue;\n      }\n      case SCAN_STACK_IF_STATEMENT:\n      {\n        parser_stack_pop_uint8 (context_p);\n\n        if (type == LEXER_KEYW_ELSE\n            && (terminator_found || (context_p->token.flags & LEXER_WAS_NEWLINE)))\n        {\n#if JERRY_ESNEXT\n          scanner_check_function_after_if (context_p, scanner_context_p);\n          return SCAN_KEEP_TOKEN;\n#else /* !JERRY_ESNEXT */\n          scanner_context_p->mode = SCAN_MODE_STATEMENT;\n          return SCAN_NEXT_TOKEN;\n#endif /* JERRY_ESNEXT */\n        }\n        continue;\n      }\n      case SCAN_STACK_WITH_STATEMENT:\n      {\n        scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;\n\n        JERRY_ASSERT (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH);\n\n        parser_stack_pop_uint8 (context_p);\n\n        if (context_p->stack_top_uint8 == 0)\n        {\n          literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_WITH;\n        }\n\n        parser_stack_pop_uint8 (context_p);\n        continue;\n      }\n      case SCAN_STACK_DO_STATEMENT:\n      {\n        parser_stack_pop_uint8 (context_p);\n\n        if (type != LEXER_KEYW_WHILE\n            || (!terminator_found && !(context_p->token.flags & LEXER_WAS_NEWLINE)))\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_next_token (context_p);\n        if (context_p->token.type != LEXER_LEFT_PAREN)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        parser_stack_push_uint8 (context_p, SCAN_STACK_DO_EXPRESSION);\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_NEXT_TOKEN;\n      }\n      case SCAN_STACK_DO_EXPRESSION:\n      {\n        parser_stack_pop_uint8 (context_p);\n        terminator_found = true;\n        continue;\n      }\n#if JERRY_ESNEXT\n      case SCAN_STACK_PRIVATE_BLOCK_EARLY:\n      {\n        parser_list_iterator_t literal_iterator;\n        lexer_lit_location_t *literal_p;\n\n        parser_list_iterator_init (&scanner_context_p->active_literal_pool_p->literal_pool, &literal_iterator);\n\n        while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n        {\n          if ((literal_p->type & (SCANNER_LITERAL_IS_LET | SCANNER_LITERAL_IS_CONST))\n              && (literal_p->type & SCANNER_LITERAL_IS_USED))\n          {\n            literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n          }\n        }\n        /* FALLTHRU */\n      }\n      case SCAN_STACK_PRIVATE_BLOCK:\n      {\n        parser_stack_pop_uint8 (context_p);\n        scanner_pop_literal_pool (context_p, scanner_context_p);\n        continue;\n      }\n#endif /* JERRY_ESNEXT */\n#if JERRY_MODULE_SYSTEM\n      case SCAN_STACK_EXPORT_DEFAULT:\n      {\n        parser_stack_pop_uint8 (context_p);\n        lexer_lit_location_t *location_p = scanner_add_custom_literal (context_p,\n                                                                       scanner_context_p->active_literal_pool_p,\n                                                                       &lexer_default_literal);\n        location_p->type |= SCANNER_LITERAL_IS_VAR;\n        continue;\n      }\n#endif /* JERRY_MODULE_SYSTEM */\n      default:\n      {\n        JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_TRY_STATEMENT\n                      || context_p->stack_top_uint8 == SCAN_STACK_CATCH_STATEMENT);\n\n        if (type != LEXER_RIGHT_BRACE)\n        {\n          break;\n        }\n\n        uint8_t stack_top = context_p->stack_top_uint8;\n        parser_stack_pop_uint8 (context_p);\n        lexer_next_token (context_p);\n\n#if JERRY_ESNEXT\n        scanner_pop_literal_pool (context_p, scanner_context_p);\n#else /* !JERRY_ESNEXT */\n        if (stack_top == SCAN_STACK_CATCH_STATEMENT)\n        {\n          scanner_pop_literal_pool (context_p, scanner_context_p);\n        }\n#endif /* JERRY_ESNEXT */\n\n        /* A finally statement is optional after a try or catch statement. */\n        if (context_p->token.type == LEXER_KEYW_FINALLY)\n        {\n          lexer_next_token (context_p);\n\n          if (context_p->token.type != LEXER_LEFT_BRACE)\n          {\n            scanner_raise_error (context_p);\n          }\n\n#if JERRY_ESNEXT\n          scanner_literal_pool_t *literal_pool_p;\n          literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);\n          literal_pool_p->source_p = context_p->source_p;\n#endif /* JERRY_ESNEXT */\n\n          parser_stack_push_uint8 (context_p, SCAN_STACK_BLOCK_STATEMENT);\n          scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n          return SCAN_NEXT_TOKEN;\n        }\n\n        if (stack_top == SCAN_STACK_CATCH_STATEMENT)\n        {\n          terminator_found = true;\n          continue;\n        }\n\n        /* A catch statement must be present after a try statement unless a finally is provided. */\n        if (context_p->token.type != LEXER_KEYW_CATCH)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_next_token (context_p);\n\n        scanner_literal_pool_t *literal_pool_p;\n        literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);\n        literal_pool_p->source_p = context_p->source_p;\n        parser_stack_push_uint8 (context_p, SCAN_STACK_CATCH_STATEMENT);\n\n#if JERRY_ESNEXT\n        if (context_p->token.type == LEXER_LEFT_BRACE)\n        {\n          scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n          return SCAN_NEXT_TOKEN;\n        }\n#endif /* JERRY_ESNEXT */\n\n        if (context_p->token.type != LEXER_LEFT_PAREN)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_next_token (context_p);\n\n#if JERRY_ESNEXT\n        if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)\n        {\n          scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_CATCH, false);\n\n          if (context_p->token.type == LEXER_LEFT_SQUARE)\n          {\n            parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n            scanner_context_p->mode = SCAN_MODE_BINDING;\n            return SCAN_NEXT_TOKEN;\n          }\n\n          parser_stack_push_uint8 (context_p, 0);\n          parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n          scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;\n          return SCAN_KEEP_TOKEN;\n        }\n#endif /* JERRY_ESNEXT */\n\n        if (context_p->token.type != LEXER_LITERAL\n            || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_lit_location_t *lit_location_p = scanner_add_literal (context_p, scanner_context_p);\n        lit_location_p->type |= SCANNER_LITERAL_IS_LOCAL;\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_RIGHT_PAREN)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_LEFT_BRACE)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n        return SCAN_NEXT_TOKEN;\n      }\n    }\n\n    if (!terminator_found && !(context_p->token.flags & LEXER_WAS_NEWLINE))\n    {\n      scanner_raise_error (context_p);\n    }\n\n    scanner_context_p->mode = SCAN_MODE_STATEMENT;\n    return SCAN_KEEP_TOKEN;\n  }\n}",
        "begin_line": 2084,
        "end_line": 2471,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.opcodes.opfunc_set_data_property#60",
        "src_path": "jerry-core/vm/opcodes.c",
        "class_name": "jerry-core.vm.opcodes",
        "signature": "jerry-core.vm.opcodes.opfunc_set_data_property (ecma_object_t *object_p, /**< object */                           ecma_string_t *prop_name_p, /**< data property name */                           ecma_value_t value) /**< new value */",
        "snippet": "void\nopfunc_set_data_property (ecma_object_t *object_p, /**< object */\n                          ecma_string_t *prop_name_p, /**< data property name */\n                          ecma_value_t value) /**< new value */\n{\n  JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));\n\n  ecma_property_t *property_p = ecma_find_named_property (object_p, prop_name_p);\n  ecma_property_value_t *prop_value_p;\n\n  if (property_p == NULL)\n  {\n    prop_value_p = ecma_create_named_data_property (object_p,\n                                                    prop_name_p,\n                                                    ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,\n                                                    NULL);\n  }\n  else\n  {\n    JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));\n\n    prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n    if (!(*property_p & ECMA_PROPERTY_FLAG_DATA))\n    {\n#if JERRY_CPOINTER_32_BIT\n      ecma_getter_setter_pointers_t *getter_setter_pair_p;\n      getter_setter_pair_p = ECMA_GET_NON_NULL_POINTER (ecma_getter_setter_pointers_t,\n                                                        ECMA_PROPERTY_VALUE_PTR (property_p)->getter_setter_pair_cp);\n      jmem_pools_free (getter_setter_pair_p, sizeof (ecma_getter_setter_pointers_t));\n#endif /* JERRY_CPOINTER_32_BIT */\n\n      *property_p |= ECMA_PROPERTY_FLAG_DATA | ECMA_PROPERTY_FLAG_WRITABLE;\n      prop_value_p->value = ecma_copy_value_if_not_object (value);\n      return;\n    }\n  }\n\n  ecma_named_data_property_assign_value (object_p, prop_value_p, value);\n}",
        "begin_line": 60,
        "end_line": 99,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.opfunc_call#767",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.opfunc_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */",
        "snippet": "static void\nopfunc_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */\n{\n  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;\n  uint8_t opcode = byte_code_p[-1];\n  uint32_t arguments_list_len;\n\n  if (opcode >= CBC_CALL0)\n  {\n    arguments_list_len = (unsigned int) ((opcode - CBC_CALL0) / 6);\n  }\n  else\n  {\n    arguments_list_len = *byte_code_p++;\n  }\n\n  bool is_call_prop = ((opcode - CBC_CALL) % 6) >= 3;\n\n  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;\n  ecma_value_t this_value = is_call_prop ? stack_top_p[-3] : ECMA_VALUE_UNDEFINED;\n  ecma_value_t func_value = stack_top_p[-1];\n  ecma_value_t completion_value;\n\n  if (!ecma_is_value_object (func_value)\n      || !ecma_op_object_is_callable (ecma_get_object_from_value (func_value)))\n  {\n    completion_value = ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_expected_a_function));\n  }\n  else\n  {\n    ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);\n\n    completion_value = ecma_op_function_call (func_obj_p,\n                                              this_value,\n                                              stack_top_p,\n                                              arguments_list_len);\n  }\n\n  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_DIRECT_EVAL;\n\n  /* Free registers. */\n  for (uint32_t i = 0; i < arguments_list_len; i++)\n  {\n    ecma_fast_free_value (stack_top_p[i]);\n  }\n\n  if (is_call_prop)\n  {\n    ecma_free_value (*(--stack_top_p));\n    ecma_free_value (*(--stack_top_p));\n  }\n\n  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))\n  {\n#if JERRY_DEBUGGER\n    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;\n#endif /* JERRY_DEBUGGER */\n    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;\n  }\n  else\n  {\n    frame_ctx_p->byte_code_p = byte_code_p;\n    ecma_free_value (*(--stack_top_p));\n    uint32_t opcode_data = vm_decode_table[opcode];\n\n    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))\n    {\n      ecma_fast_free_value (completion_value);\n    }\n    else if (opcode_data & VM_OC_PUT_STACK)\n    {\n      *stack_top_p++ = completion_value;\n    }\n    else\n    {\n      ecma_fast_free_value (frame_ctx_p->block_result);\n      frame_ctx_p->block_result = completion_value;\n    }\n  }\n\n  frame_ctx_p->stack_top_p = stack_top_p;\n}",
        "begin_line": 767,
        "end_line": 848,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_construct_literal_object#446",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_construct_literal_object (vm_frame_ctx_t *frame_ctx_p, /**< frame context */                              ecma_value_t lit_value) /**< literal */",
        "snippet": "static ecma_value_t\nvm_construct_literal_object (vm_frame_ctx_t *frame_ctx_p, /**< frame context */\n                             ecma_value_t lit_value) /**< literal */\n{\n  ecma_compiled_code_t *bytecode_p;\n\n#if JERRY_SNAPSHOT_EXEC\n  if (JERRY_LIKELY (!(frame_ctx_p->shared_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))\n  {\n#endif /* JERRY_SNAPSHOT_EXEC */\n    bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,\n                                                  lit_value);\n#if JERRY_SNAPSHOT_EXEC\n  }\n  else\n  {\n    uint8_t *byte_p = ((uint8_t *) frame_ctx_p->shared_p->bytecode_header_p) + lit_value;\n    bytecode_p = (ecma_compiled_code_t *) byte_p;\n  }\n#endif /* JERRY_SNAPSHOT_EXEC */\n\n#if JERRY_BUILTIN_REGEXP\n  if (JERRY_UNLIKELY (!CBC_IS_FUNCTION (bytecode_p->status_flags)))\n  {\n    ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);\n\n    if (JERRY_UNLIKELY (regexp_obj_p == NULL))\n    {\n      return ECMA_VALUE_ERROR;\n    }\n\n    return ecma_op_create_regexp_from_bytecode (regexp_obj_p, (re_compiled_code_t *) bytecode_p);\n  }\n#else /* !JERRY_BUILTIN_REGEXP */\n  JERRY_ASSERT (CBC_IS_FUNCTION (bytecode_p->status_flags));\n#endif /* JERRY_BUILTIN_REGEXP */\n\n  ecma_object_t *func_obj_p;\n\n#if JERRY_ESNEXT\n  if (JERRY_UNLIKELY (CBC_FUNCTION_IS_ARROW (bytecode_p->status_flags)))\n  {\n    func_obj_p = ecma_op_create_arrow_function_object (frame_ctx_p->lex_env_p,\n                                                       bytecode_p,\n                                                       frame_ctx_p->this_binding);\n  }\n  else\n  {\n    func_obj_p = ecma_op_create_any_function_object (frame_ctx_p->lex_env_p, bytecode_p);\n  }\n#else /* !JERRY_ESNEXT */\n  func_obj_p = ecma_op_create_simple_function_object (frame_ctx_p->lex_env_p, bytecode_p);\n#endif /* JERRY_ESNEXT */\n\n  return ecma_make_object_value (func_obj_p);\n}",
        "begin_line": 446,
        "end_line": 501,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_execute#5260",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_execute (vm_frame_ctx_t *frame_ctx_p) /**< frame context */",
        "snippet": "ecma_value_t JERRY_ATTR_NOINLINE\nvm_execute (vm_frame_ctx_t *frame_ctx_p) /**< frame context */\n{\n  while (true)\n  {\n    ecma_value_t completion_value = vm_loop (frame_ctx_p);\n\n    switch (frame_ctx_p->call_operation)\n    {\n      case VM_EXEC_CALL:\n      {\n        opfunc_call (frame_ctx_p);\n        break;\n      }\n#if JERRY_ESNEXT\n      case VM_EXEC_SUPER_CALL:\n      {\n        vm_super_call (frame_ctx_p);\n        break;\n      }\n      case VM_EXEC_SPREAD_OP:\n      {\n        vm_spread_operation (frame_ctx_p);\n        break;\n      }\n      case VM_EXEC_RETURN:\n      {\n        return completion_value;\n      }\n#endif /* JERRY_ESNEXT */\n      case VM_EXEC_CONSTRUCT:\n      {\n        opfunc_construct (frame_ctx_p);\n        break;\n      }\n      default:\n      {\n        JERRY_ASSERT (frame_ctx_p->call_operation == VM_NO_EXEC_OP);\n\n        const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->shared_p->bytecode_header_p;\n        uint32_t register_end;\n\n        if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n        {\n          register_end = ((cbc_uint16_arguments_t *) bytecode_header_p)->register_end;\n        }\n        else\n        {\n          register_end = ((cbc_uint8_arguments_t *) bytecode_header_p)->register_end;\n        }\n\n        /* Free arguments and registers */\n        ecma_value_t *registers_p = VM_GET_REGISTERS (frame_ctx_p);\n        for (uint32_t i = 0; i < register_end; i++)\n        {\n          ecma_fast_free_value (registers_p[i]);\n        }\n\n#if JERRY_DEBUGGER\n        if (JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p))\n        {\n          /* The engine will stop when the next breakpoint is reached. */\n          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP);\n          JERRY_CONTEXT (debugger_stop_context) = NULL;\n        }\n#endif /* JERRY_DEBUGGER */\n\n        JERRY_CONTEXT (vm_top_context_p) = frame_ctx_p->prev_context_p;\n        return completion_value;\n      }\n    }\n  }\n}",
        "begin_line": 5260,
        "end_line": 5332,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_init_exec#5175",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_init_exec (vm_frame_ctx_t *frame_ctx_p) /**< frame context */",
        "snippet": "static void JERRY_ATTR_NOINLINE\nvm_init_exec (vm_frame_ctx_t *frame_ctx_p) /**< frame context */\n{\n  vm_frame_ctx_shared_t *shared_p = frame_ctx_p->shared_p;\n  const ecma_compiled_code_t *bytecode_header_p = shared_p->bytecode_header_p;\n\n  frame_ctx_p->prev_context_p = JERRY_CONTEXT (vm_top_context_p);\n  frame_ctx_p->block_result = ECMA_VALUE_UNDEFINED;\n  frame_ctx_p->context_depth = 0;\n  frame_ctx_p->status_flags = (uint8_t) ((shared_p->status_flags & VM_FRAME_CTX_DIRECT_EVAL)\n                                         | (bytecode_header_p->status_flags & VM_FRAME_CTX_IS_STRICT));\n\n  uint16_t argument_end, register_end;\n  ecma_value_t *literal_p;\n\n  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n  {\n    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;\n\n    argument_end = args_p->argument_end;\n    register_end = args_p->register_end;\n\n    literal_p = (ecma_value_t *) (args_p + 1);\n    literal_p -= register_end;\n    frame_ctx_p->literal_start_p = literal_p;\n    literal_p += args_p->literal_end;\n  }\n  else\n  {\n    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;\n\n    argument_end = args_p->argument_end;\n    register_end = args_p->register_end;\n\n    literal_p = (ecma_value_t *) (args_p + 1);\n    literal_p -= register_end;\n    frame_ctx_p->literal_start_p = literal_p;\n    literal_p += args_p->literal_end;\n  }\n\n  frame_ctx_p->byte_code_p = (uint8_t *) literal_p;\n  frame_ctx_p->byte_code_start_p = (uint8_t *) literal_p;\n  frame_ctx_p->stack_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end;\n\n  uint32_t arg_list_len = 0;\n\n  if (argument_end > 0)\n  {\n    JERRY_ASSERT (shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_ARG_LIST);\n\n    const ecma_value_t *arg_list_p = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_p;\n    arg_list_len = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_len;\n\n    if (arg_list_len > argument_end)\n    {\n      arg_list_len = argument_end;\n    }\n\n    for (uint32_t i = 0; i < arg_list_len; i++)\n    {\n      VM_GET_REGISTER (frame_ctx_p, i) = ecma_fast_copy_value (arg_list_p[i]);\n    }\n  }\n\n  /* The arg_list_len contains the end of the copied arguments.\n   * Fill everything else with undefined. */\n  if (register_end > arg_list_len)\n  {\n    ecma_value_t *stack_p = VM_GET_REGISTERS (frame_ctx_p) + arg_list_len;\n\n    for (uint32_t i = arg_list_len; i < register_end; i++)\n    {\n      *stack_p++ = ECMA_VALUE_UNDEFINED;\n    }\n  }\n\n  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_DIRECT_EVAL;\n  JERRY_CONTEXT (vm_top_context_p) = frame_ctx_p;\n}",
        "begin_line": 5175,
        "end_line": 5253,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_loop#1022",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_loop (vm_frame_ctx_t *frame_ctx_p) /**< frame context */",
        "snippet": "static ecma_value_t JERRY_ATTR_NOINLINE\nvm_loop (vm_frame_ctx_t *frame_ctx_p) /**< frame context */\n{\n  const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->shared_p->bytecode_header_p;\n  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p;\n  ecma_value_t *literal_start_p = frame_ctx_p->literal_start_p;\n\n  ecma_value_t *stack_top_p;\n  uint16_t encoding_limit;\n  uint16_t encoding_delta;\n  uint16_t register_end;\n  uint16_t ident_end;\n  uint16_t const_literal_end;\n  int32_t branch_offset = 0;\n  uint8_t branch_offset_length = 0;\n  ecma_value_t left_value;\n  ecma_value_t right_value;\n  ecma_value_t result = ECMA_VALUE_EMPTY;\n  bool is_strict = ((bytecode_header_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE) != 0);\n\n  /* Prepare for byte code execution. */\n  if (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_FULL_LITERAL_ENCODING))\n  {\n    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;\n    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;\n  }\n  else\n  {\n    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;\n    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;\n  }\n\n  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n  {\n    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) (bytecode_header_p);\n    register_end = args_p->register_end;\n    ident_end = args_p->ident_end;\n    const_literal_end = args_p->const_literal_end;\n  }\n  else\n  {\n    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) (bytecode_header_p);\n    register_end = args_p->register_end;\n    ident_end = args_p->ident_end;\n    const_literal_end = args_p->const_literal_end;\n  }\n\n  stack_top_p = frame_ctx_p->stack_top_p;\n\n  /* Outer loop for exception handling. */\n  while (true)\n  {\n    /* Internal loop for byte code execution. */\n    while (true)\n    {\n      const uint8_t *byte_code_start_p = byte_code_p;\n      uint8_t opcode = *byte_code_p++;\n      uint32_t opcode_data = opcode;\n\n      if (opcode == CBC_EXT_OPCODE)\n      {\n        opcode = *byte_code_p++;\n        opcode_data = (uint32_t) ((CBC_END + 1) + opcode);\n      }\n\n      opcode_data = vm_decode_table[opcode_data];\n\n      left_value = ECMA_VALUE_UNDEFINED;\n      right_value = ECMA_VALUE_UNDEFINED;\n\n      uint32_t operands = VM_OC_GET_ARGS_INDEX (opcode_data);\n\n      if (operands >= VM_OC_GET_LITERAL)\n      {\n        uint16_t literal_index;\n        READ_LITERAL_INDEX (literal_index);\n        READ_LITERAL (literal_index, left_value);\n\n        if (operands != VM_OC_GET_LITERAL)\n        {\n          switch (operands)\n          {\n            case VM_OC_GET_LITERAL_LITERAL:\n            {\n              uint16_t second_literal_index;\n              READ_LITERAL_INDEX (second_literal_index);\n              READ_LITERAL (second_literal_index, right_value);\n              break;\n            }\n            case VM_OC_GET_STACK_LITERAL:\n            {\n              JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);\n              right_value = left_value;\n              left_value = *(--stack_top_p);\n              break;\n            }\n            default:\n            {\n              JERRY_ASSERT (operands == VM_OC_GET_THIS_LITERAL);\n\n              right_value = left_value;\n              left_value = ecma_copy_value (frame_ctx_p->this_binding);\n              break;\n            }\n          }\n        }\n      }\n      else if (operands >= VM_OC_GET_STACK)\n      {\n        JERRY_ASSERT (operands == VM_OC_GET_STACK\n                      || operands == VM_OC_GET_STACK_STACK);\n\n        JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);\n        left_value = *(--stack_top_p);\n\n        if (operands == VM_OC_GET_STACK_STACK)\n        {\n          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);\n          right_value = left_value;\n          left_value = *(--stack_top_p);\n        }\n      }\n      else if (operands == VM_OC_GET_BRANCH)\n      {\n        branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (opcode);\n        JERRY_ASSERT (branch_offset_length >= 1 && branch_offset_length <= 3);\n\n        branch_offset = *(byte_code_p++);\n\n        if (JERRY_UNLIKELY (branch_offset_length != 1))\n        {\n          branch_offset <<= 8;\n          branch_offset |= *(byte_code_p++);\n\n          if (JERRY_UNLIKELY (branch_offset_length == 3))\n          {\n            branch_offset <<= 8;\n            branch_offset |= *(byte_code_p++);\n          }\n        }\n\n        if (opcode_data & VM_OC_BACKWARD_BRANCH)\n        {\n#if JERRY_VM_EXEC_STOP\n          if (JERRY_CONTEXT (vm_exec_stop_cb) != NULL\n              && --JERRY_CONTEXT (vm_exec_stop_counter) == 0)\n          {\n            result = JERRY_CONTEXT (vm_exec_stop_cb) (JERRY_CONTEXT (vm_exec_stop_user_p));\n\n            if (ecma_is_value_undefined (result))\n            {\n              JERRY_CONTEXT (vm_exec_stop_counter) = JERRY_CONTEXT (vm_exec_stop_frequency);\n            }\n            else\n            {\n              JERRY_CONTEXT (vm_exec_stop_counter) = 1;\n\n              if (ecma_is_value_error_reference (result))\n              {\n                ecma_raise_error_from_error_reference (result);\n              }\n              else\n              {\n                jcontext_raise_exception (result);\n              }\n\n              JERRY_ASSERT (jcontext_has_pending_exception ());\n              jcontext_set_abort_flag (true);\n              result = ECMA_VALUE_ERROR;\n              goto error;\n            }\n          }\n#endif /* JERRY_VM_EXEC_STOP */\n\n          branch_offset = -branch_offset;\n        }\n      }\n\n      switch (VM_OC_GROUP_GET_INDEX (opcode_data))\n      {\n        case VM_OC_POP:\n        {\n          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);\n          ecma_free_value (*(--stack_top_p));\n          continue;\n        }\n        case VM_OC_POP_BLOCK:\n        {\n          ecma_fast_free_value (frame_ctx_p->block_result);\n          frame_ctx_p->block_result = *(--stack_top_p);\n          continue;\n        }\n        case VM_OC_PUSH:\n        {\n          *stack_top_p++ = left_value;\n          continue;\n        }\n        case VM_OC_PUSH_TWO:\n        {\n          *stack_top_p++ = left_value;\n          *stack_top_p++ = right_value;\n          continue;\n        }\n        case VM_OC_PUSH_THREE:\n        {\n          uint16_t literal_index;\n\n          *stack_top_p++ = left_value;\n          left_value = ECMA_VALUE_UNDEFINED;\n\n          READ_LITERAL_INDEX (literal_index);\n          READ_LITERAL (literal_index, left_value);\n\n          *stack_top_p++ = right_value;\n          *stack_top_p++ = left_value;\n          continue;\n        }\n        case VM_OC_PUSH_UNDEFINED:\n        {\n          *stack_top_p++ = ECMA_VALUE_UNDEFINED;\n          continue;\n        }\n        case VM_OC_PUSH_TRUE:\n        {\n          *stack_top_p++ = ECMA_VALUE_TRUE;\n          continue;\n        }\n        case VM_OC_PUSH_FALSE:\n        {\n          *stack_top_p++ = ECMA_VALUE_FALSE;\n          continue;\n        }\n        case VM_OC_PUSH_NULL:\n        {\n          *stack_top_p++ = ECMA_VALUE_NULL;\n          continue;\n        }\n        case VM_OC_PUSH_THIS:\n        {\n          *stack_top_p++ = ecma_copy_value (frame_ctx_p->this_binding);\n          continue;\n        }\n        case VM_OC_PUSH_0:\n        {\n          *stack_top_p++ = ecma_make_integer_value (0);\n          continue;\n        }\n        case VM_OC_PUSH_POS_BYTE:\n        {\n          ecma_integer_value_t number = *byte_code_p++;\n          *stack_top_p++ = ecma_make_integer_value (number + 1);\n          continue;\n        }\n        case VM_OC_PUSH_NEG_BYTE:\n        {\n          ecma_integer_value_t number = *byte_code_p++;\n          *stack_top_p++ = ecma_make_integer_value (-(number + 1));\n          continue;\n        }\n        case VM_OC_PUSH_LIT_0:\n        {\n          stack_top_p[0] = left_value;\n          stack_top_p[1] = ecma_make_integer_value (0);\n          stack_top_p += 2;\n          continue;\n        }\n        case VM_OC_PUSH_LIT_POS_BYTE:\n        {\n          ecma_integer_value_t number = *byte_code_p++;\n          stack_top_p[0] = left_value;\n          stack_top_p[1] = ecma_make_integer_value (number + 1);\n          stack_top_p += 2;\n          continue;\n        }\n        case VM_OC_PUSH_LIT_NEG_BYTE:\n        {\n          ecma_integer_value_t number = *byte_code_p++;\n          stack_top_p[0] = left_value;\n          stack_top_p[1] = ecma_make_integer_value (-(number + 1));\n          stack_top_p += 2;\n          continue;\n        }\n        case VM_OC_PUSH_OBJECT:\n        {\n          ecma_object_t *obj_p = ecma_create_object (ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE),\n                                                     0,\n                                                     ECMA_OBJECT_TYPE_GENERAL);\n\n          *stack_top_p++ = ecma_make_object_value (obj_p);\n          continue;\n        }\n        case VM_OC_PUSH_NAMED_FUNC_EXPR:\n        {\n          ecma_object_t *func_p = ecma_get_object_from_value (left_value);\n\n          JERRY_ASSERT (ecma_get_object_type (func_p) == ECMA_OBJECT_TYPE_FUNCTION);\n\n          ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_p;\n\n          JERRY_ASSERT (frame_ctx_p->lex_env_p ==\n                        ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t, ext_func_p->u.function.scope_cp));\n\n          ecma_object_t *name_lex_env = ecma_create_decl_lex_env (frame_ctx_p->lex_env_p);\n\n          ecma_op_create_immutable_binding (name_lex_env, ecma_get_string_from_value (right_value), left_value);\n\n          ECMA_SET_NON_NULL_POINTER_TAG (ext_func_p->u.function.scope_cp, name_lex_env, 0);\n\n          ecma_free_value (right_value);\n          ecma_deref_object (name_lex_env);\n          *stack_top_p++ = left_value;\n          continue;\n        }\n        case VM_OC_CREATE_BINDING:\n        {\n#if !JERRY_ESNEXT\n          JERRY_ASSERT (opcode == CBC_CREATE_VAR);\n#endif /* !JERRY_ESNEXT */\n\n          uint32_t literal_index;\n\n          READ_LITERAL_INDEX (literal_index);\n\n          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n\n          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);\n          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);\n\n          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;\n\n#if JERRY_ESNEXT\n          if (opcode == CBC_CREATE_LET)\n          {\n            prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;\n          }\n          else if (opcode == CBC_CREATE_CONST)\n          {\n            prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;\n          }\n\n          ecma_property_value_t *property_value_p;\n          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);\n\n          if (opcode != CBC_CREATE_VAR)\n          {\n            property_value_p->value = ECMA_VALUE_UNINITIALIZED;\n          }\n#else /* !JERRY_ESNEXT */\n          ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);\n#endif /* JERRY_ESNEXT */\n\n          continue;\n        }\n        case VM_OC_VAR_EVAL:\n        {\n          uint32_t literal_index;\n          ecma_value_t lit_value = ECMA_VALUE_UNDEFINED;\n\n          if (opcode == CBC_CREATE_VAR_FUNC_EVAL)\n          {\n            uint32_t value_index;\n            READ_LITERAL_INDEX (value_index);\n            JERRY_ASSERT (value_index >= const_literal_end);\n\n            lit_value = vm_construct_literal_object (frame_ctx_p,\n                                                     literal_start_p[value_index]);\n          }\n\n          READ_LITERAL_INDEX (literal_index);\n          JERRY_ASSERT (literal_index >= register_end);\n\n          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;\n\n          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)\n          {\n#if JERRY_ESNEXT && !(defined JERRY_NDEBUG)\n            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n            {\n              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));\n            }\n#endif /* JERRY_ESNEXT && !JERRY_NDEBUG */\n\n            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);\n            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);\n          }\n\n#if JERRY_ESNEXT && !(defined JERRY_NDEBUG)\n          if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n          {\n            ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n            JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));\n          }\n#endif /* JERRY_ESNEXT && !JERRY_NDEBUG */\n\n          /* 'Variable declaration' */\n          result = ecma_op_has_binding (lex_env_p, name_p);\n\n#if JERRY_BUILTIN_PROXY\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n#endif /* JERRY_BUILTIN_PROXY */\n\n          ecma_property_t *prop_p = NULL;\n\n          if (ecma_is_value_false (result))\n          {\n            bool is_configurable = (frame_ctx_p->status_flags & VM_FRAME_CTX_DIRECT_EVAL) != 0;\n            prop_p = ecma_op_create_mutable_binding (lex_env_p, name_p, is_configurable);\n\n            if (JERRY_UNLIKELY (prop_p == ECMA_PROPERTY_POINTER_ERROR))\n            {\n              result = ECMA_VALUE_ERROR;\n              goto error;\n            }\n          }\n\n          if (lit_value != ECMA_VALUE_UNDEFINED)\n          {\n            JERRY_ASSERT (ecma_is_value_object (lit_value));\n\n            if (prop_p != NULL)\n            {\n              JERRY_ASSERT (ecma_is_value_undefined (ECMA_PROPERTY_VALUE_PTR (prop_p)->value));\n              JERRY_ASSERT (ecma_is_property_writable (*prop_p));\n              ECMA_PROPERTY_VALUE_PTR (prop_p)->value = lit_value;\n              ecma_free_object (lit_value);\n            }\n            else\n            {\n              result = ecma_op_put_value_lex_env_base (lex_env_p, name_p, is_strict, lit_value);\n              ecma_free_object (lit_value);\n\n              if (ECMA_IS_VALUE_ERROR (result))\n              {\n                goto error;\n              }\n            }\n          }\n          continue;\n        }\n#if JERRY_ESNEXT\n        case VM_OC_EXT_VAR_EVAL:\n        {\n          uint32_t literal_index;\n          ecma_value_t lit_value = ECMA_VALUE_UNDEFINED;\n\n          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE);\n\n          if (opcode == CBC_EXT_CREATE_VAR_FUNC_EVAL)\n          {\n            uint32_t value_index;\n            READ_LITERAL_INDEX (value_index);\n            JERRY_ASSERT (value_index >= const_literal_end);\n\n            lit_value = vm_construct_literal_object (frame_ctx_p,\n                                                     literal_start_p[value_index]);\n          }\n\n          READ_LITERAL_INDEX (literal_index);\n          JERRY_ASSERT (literal_index >= register_end);\n\n          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;\n          ecma_object_t *prev_lex_env_p = NULL;\n\n          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)\n          {\n#if !(defined JERRY_NDEBUG)\n            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n            {\n              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));\n            }\n#endif /* !JERRY_NDEBUG */\n\n            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);\n            prev_lex_env_p = lex_env_p;\n            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);\n          }\n\n          JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);\n          JERRY_ASSERT (prev_lex_env_p != NULL\n                        && ecma_get_lex_env_type (prev_lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);\n\n          ecma_property_t *property_p = ecma_find_named_property (prev_lex_env_p, name_p);\n          ecma_property_value_t *property_value_p;\n\n          if (property_p == NULL)\n          {\n            property_value_p = ecma_create_named_data_property (prev_lex_env_p,\n                                                                name_p,\n                                                                ECMA_PROPERTY_CONFIGURABLE_WRITABLE,\n                                                                NULL);\n\n            if (lit_value == ECMA_VALUE_UNDEFINED)\n            {\n              continue;\n            }\n          }\n          else\n          {\n            if (lit_value == ECMA_VALUE_UNDEFINED)\n            {\n              continue;\n            }\n\n            property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n            ecma_free_value_if_not_object (property_value_p->value);\n          }\n\n          property_value_p->value = lit_value;\n          ecma_deref_object (ecma_get_object_from_value (lit_value));\n          continue;\n        }\n#endif /* JERRY_ESNEXT */\n        case VM_OC_CREATE_ARGUMENTS:\n        {\n          uint32_t literal_index;\n          READ_LITERAL_INDEX (literal_index);\n\n          JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_ARG_LIST);\n\n          result = ecma_op_create_arguments_object ((vm_frame_ctx_shared_args_t *) (frame_ctx_p->shared_p),\n                                                    frame_ctx_p->lex_env_p);\n\n          if (literal_index < register_end)\n          {\n            JERRY_ASSERT (VM_GET_REGISTER (frame_ctx_p, literal_index) == ECMA_VALUE_UNDEFINED);\n            VM_GET_REGISTER (frame_ctx_p, literal_index) = result;\n            continue;\n          }\n\n          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n\n          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);\n\n          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;\n          ecma_property_value_t *property_value_p;\n\n          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);\n          property_value_p->value = result;\n\n          ecma_deref_object (ecma_get_object_from_value (result));\n          continue;\n        }\n#if JERRY_SNAPSHOT_EXEC\n        case VM_OC_SET_BYTECODE_PTR:\n        {\n          memcpy (&byte_code_p, byte_code_p++, sizeof (uintptr_t));\n          frame_ctx_p->byte_code_start_p = byte_code_p;\n          continue;\n        }\n#endif /* JERRY_SNAPSHOT_EXEC */\n        case VM_OC_INIT_ARG_OR_FUNC:\n        {\n          uint32_t literal_index, value_index;\n          ecma_value_t lit_value;\n          bool release = false;\n\n          READ_LITERAL_INDEX (value_index);\n\n          if (value_index < register_end)\n          {\n            /* Take (not copy) the reference. */\n            lit_value = ecma_copy_value_if_not_object (VM_GET_REGISTER (frame_ctx_p, value_index));\n          }\n          else\n          {\n            lit_value = vm_construct_literal_object (frame_ctx_p,\n                                                     literal_start_p[value_index]);\n            release = true;\n          }\n\n          READ_LITERAL_INDEX (literal_index);\n\n          JERRY_ASSERT (value_index != literal_index);\n          JERRY_ASSERT (value_index >= register_end || literal_index >= register_end);\n\n          if (literal_index < register_end)\n          {\n            ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));\n            JERRY_ASSERT (release);\n            VM_GET_REGISTER (frame_ctx_p, literal_index) = lit_value;\n            continue;\n          }\n\n          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n\n          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);\n          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);\n\n          ecma_property_value_t *property_value_p;\n          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p,\n                                                              name_p,\n                                                              ECMA_PROPERTY_FLAG_WRITABLE,\n                                                              NULL);\n\n          JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);\n          property_value_p->value = lit_value;\n\n          if (release)\n          {\n            ecma_deref_object (ecma_get_object_from_value (lit_value));\n          }\n          continue;\n        }\n#if JERRY_ESNEXT\n        case VM_OC_CHECK_VAR:\n        {\n          JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags)\n                        == CBC_FUNCTION_SCRIPT);\n\n          uint32_t literal_index;\n          READ_LITERAL_INDEX (literal_index);\n\n          if ((frame_ctx_p->lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK) == 0)\n          {\n            continue;\n          }\n\n          ecma_string_t *const literal_name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n          ecma_property_t *const binding_p = ecma_find_named_property (frame_ctx_p->lex_env_p, literal_name_p);\n\n          if (binding_p != NULL)\n          {\n            result = ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_local_variable_is_redeclared));\n            goto error;\n          }\n\n          continue;\n        }\n        case VM_OC_CHECK_LET:\n        {\n          JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags)\n                        == CBC_FUNCTION_SCRIPT);\n\n          uint32_t literal_index;\n          READ_LITERAL_INDEX (literal_index);\n\n          ecma_string_t *literal_name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;\n\n          if (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)\n          {\n            result = opfunc_lexical_scope_has_restricted_binding (frame_ctx_p, literal_name_p);\n\n            if (!ecma_is_value_false (result))\n            {\n              if (ecma_is_value_true (result))\n              {\n                result = ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_local_variable_is_redeclared));\n              }\n\n              JERRY_ASSERT (ECMA_IS_VALUE_ERROR (result));\n              goto error;\n            }\n\n            continue;\n          }\n\n          result = ecma_op_has_binding (lex_env_p, literal_name_p);\n\n#if JERRY_BUILTIN_PROXY\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n#endif /* JERRY_BUILTIN_PROXY */\n\n          if (ecma_is_value_true (result))\n          {\n            result = ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_local_variable_is_redeclared));\n            goto error;\n          }\n\n          continue;\n        }\n        case VM_OC_ASSIGN_LET_CONST:\n        {\n          uint32_t literal_index;\n          READ_LITERAL_INDEX (literal_index);\n\n          JERRY_ASSERT (literal_index >= register_end);\n          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE\n                        || (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_CLASS\n                            && (frame_ctx_p->lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA)));\n\n          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n          ecma_property_t *property_p = ecma_find_named_property (frame_ctx_p->lex_env_p, name_p);\n\n          JERRY_ASSERT (property_p != NULL\n                        && ECMA_PROPERTY_IS_RAW_DATA (*property_p)\n                        && (*property_p & ECMA_PROPERTY_FLAG_DATA));\n          JERRY_ASSERT (ECMA_PROPERTY_VALUE_PTR (property_p)->value == ECMA_VALUE_UNINITIALIZED);\n\n          ECMA_PROPERTY_VALUE_PTR (property_p)->value = left_value;\n\n          if (ecma_is_value_object (left_value))\n          {\n            ecma_deref_object (ecma_get_object_from_value (left_value));\n          }\n          continue;\n        }\n        case VM_OC_INIT_BINDING:\n        {\n          uint32_t literal_index;\n\n          READ_LITERAL_INDEX (literal_index);\n\n          JERRY_ASSERT (literal_index >= register_end);\n\n          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n\n          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);\n          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);\n\n          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;\n\n          if (opcode == CBC_INIT_LET)\n          {\n            prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;\n          }\n          else if (opcode == CBC_INIT_CONST)\n          {\n            prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;\n          }\n\n          ecma_property_value_t *property_value_p;\n          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p,\n                                                              name_p,\n                                                              prop_attributes,\n                                                              NULL);\n\n          JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);\n\n          ecma_value_t value = *(--stack_top_p);\n\n          property_value_p->value = value;\n          ecma_deref_if_object (value);\n          continue;\n        }\n        case VM_OC_THROW_CONST_ERROR:\n        {\n          result = ecma_raise_type_error (ECMA_ERR_MSG (\"Constant bindings cannot be reassigned\"));\n          goto error;\n        }\n        case VM_OC_COPY_TO_GLOBAL:\n        {\n          uint32_t literal_index;\n          READ_LITERAL_INDEX (literal_index);\n\n          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;\n\n          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)\n          {\n#ifndef JERRY_NDEBUG\n            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n            {\n              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));\n            }\n#endif /* !JERRY_NDEBUG */\n\n            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);\n            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);\n          }\n\n          if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n          {\n            ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n            ecma_property_value_t *prop_value_p;\n\n            if (property_p == NULL)\n            {\n              prop_value_p = ecma_create_named_data_property (lex_env_p,\n                                                              name_p,\n                                                              ECMA_PROPERTY_FLAG_WRITABLE,\n                                                              NULL);\n            }\n            else\n            {\n#ifndef JERRY_NDEBUG\n              JERRY_ASSERT (!(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));\n#endif /* !JERRY_NDEBUG */\n              prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n            }\n\n            ecma_named_data_property_assign_value (lex_env_p, prop_value_p, left_value);\n          }\n          else\n          {\n            result = ecma_op_set_mutable_binding (lex_env_p, name_p, left_value, is_strict);\n\n            if (ECMA_IS_VALUE_ERROR (result))\n            {\n              goto error;\n            }\n          }\n\n          goto free_left_value;\n        }\n        case VM_OC_COPY_FROM_ARG:\n        {\n          uint32_t literal_index;\n          READ_LITERAL_INDEX (literal_index);\n          JERRY_ASSERT (literal_index >= register_end);\n\n          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;\n          ecma_object_t *arg_lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);\n\n          JERRY_ASSERT ((lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)\n                        && ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);\n          JERRY_ASSERT (arg_lex_env_p != NULL\n                        && !(arg_lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)\n                        && ecma_get_lex_env_type (arg_lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);\n\n          ecma_property_value_t *property_value_p;\n          property_value_p = ecma_create_named_data_property (lex_env_p,\n                                                              name_p,\n                                                              ECMA_PROPERTY_FLAG_WRITABLE,\n                                                              NULL);\n\n          ecma_property_t *property_p = ecma_find_named_property (arg_lex_env_p, name_p);\n          JERRY_ASSERT (property_p != NULL);\n\n          ecma_property_value_t *arg_prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n          property_value_p->value = ecma_copy_value_if_not_object (arg_prop_value_p->value);\n          continue;\n        }\n        case VM_OC_CLONE_CONTEXT:\n        {\n          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE);\n\n          bool copy_values = (byte_code_start_p[1] == CBC_EXT_CLONE_FULL_CONTEXT);\n          frame_ctx_p->lex_env_p = ecma_clone_decl_lexical_environment (frame_ctx_p->lex_env_p, copy_values);\n          continue;\n        }\n        case VM_OC_SET__PROTO__:\n        {\n          result = ecma_builtin_object_object_set_proto (stack_top_p[-1], left_value);\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n          goto free_left_value;\n        }\n        case VM_OC_PUSH_STATIC_FIELD_FUNC:\n        {\n          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE\n                        && (byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_FIELD_FUNC\n                            || byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC));\n\n          bool push_computed = (byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC);\n          ecma_value_t value = stack_top_p[-1];\n\n          if (!push_computed)\n          {\n            stack_top_p++;\n          }\n\n          memmove (stack_top_p - 3, stack_top_p - 4, 3 * sizeof (ecma_value_t));\n          stack_top_p[-4] = left_value;\n\n          if (!push_computed)\n          {\n            continue;\n          }\n\n          left_value = value;\n          /* FALLTHRU */\n        }\n        case VM_OC_ADD_COMPUTED_FIELD:\n        {\n          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE\n                        && (byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC\n                            || byte_code_start_p[1] == CBC_EXT_ADD_COMPUTED_FIELD\n                            || byte_code_start_p[1] == CBC_EXT_ADD_STATIC_COMPUTED_FIELD));\n\n          int index = (byte_code_start_p[1] == CBC_EXT_ADD_COMPUTED_FIELD) ? -2 : -4;\n          result = opfunc_add_computed_field (stack_top_p[index], left_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n          goto free_left_value;\n        }\n        case VM_OC_COPY_DATA_PROPERTIES:\n        {\n          left_value = *(--stack_top_p);\n\n          if (ecma_is_value_undefined (left_value) || ecma_is_value_null (left_value))\n          {\n            continue;\n          }\n\n          result = opfunc_copy_data_properties (stack_top_p[-1], left_value, ECMA_VALUE_UNDEFINED);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          goto free_left_value;\n        }\n        case VM_OC_SET_COMPUTED_PROPERTY:\n        {\n          /* Swap values. */\n          left_value ^= right_value;\n          right_value ^= left_value;\n          left_value ^= right_value;\n          /* FALLTHRU */\n        }\n#endif /* JERRY_ESNEXT */\n        case VM_OC_SET_PROPERTY:\n        {\n          JERRY_STATIC_ASSERT (VM_OC_NON_STATIC_FLAG == VM_OC_BACKWARD_BRANCH,\n                               vm_oc_non_static_flag_must_be_equal_to_vm_oc_backward_branch);\n\n          JERRY_ASSERT ((opcode_data >> VM_OC_NON_STATIC_SHIFT) <= 0x1);\n\n          ecma_string_t *prop_name_p = ecma_op_to_property_key (right_value);\n\n          if (JERRY_UNLIKELY (prop_name_p == NULL))\n          {\n            result = ECMA_VALUE_ERROR;\n            goto error;\n          }\n\n#if JERRY_ESNEXT\n          if (JERRY_UNLIKELY (ecma_compare_ecma_string_to_magic_id (prop_name_p, LIT_MAGIC_STRING_PROTOTYPE))\n              && !(opcode_data & VM_OC_NON_STATIC_FLAG))\n          {\n            result = ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_class_is_non_configurable));\n            goto error;\n          }\n\n          const int index = (int) (opcode_data >> VM_OC_NON_STATIC_SHIFT) - 2;\n#else /* !JERRY_ESNEXT */\n          const int index = -1;\n#endif /* JERRY_ESNEXT */\n\n          ecma_object_t *object_p = ecma_get_object_from_value (stack_top_p[index]);\n\n          opfunc_set_data_property (object_p, prop_name_p, left_value);\n          ecma_deref_ecma_string (prop_name_p);\n\n          goto free_both_values;\n        }\n        case VM_OC_SET_GETTER:\n        case VM_OC_SET_SETTER:\n        {\n          JERRY_ASSERT ((opcode_data >> VM_OC_NON_STATIC_SHIFT) <= 0x1);\n\n          ecma_string_t *prop_name_p = ecma_op_to_property_key (left_value);\n\n          if (JERRY_UNLIKELY (prop_name_p == NULL))\n          {\n            result = ECMA_VALUE_ERROR;\n            goto error;\n          }\n\n#if JERRY_ESNEXT\n          if (JERRY_UNLIKELY (ecma_compare_ecma_string_to_magic_id (prop_name_p, LIT_MAGIC_STRING_PROTOTYPE))\n              && !(opcode_data & VM_OC_NON_STATIC_FLAG))\n          {\n            result = ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_class_is_non_configurable));\n            goto error;\n          }\n\n          const int index = (int) (opcode_data >> VM_OC_NON_STATIC_SHIFT) - 2;\n#else /* !JERRY_ESNEXT */\n          const int index = -1;\n#endif /* JERRY_ESNEXT */\n\n          opfunc_set_accessor (VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_SET_GETTER,\n                               stack_top_p[index],\n                               prop_name_p,\n                               right_value);\n\n          ecma_deref_ecma_string (prop_name_p);\n\n          goto free_both_values;\n        }\n        case VM_OC_PUSH_ARRAY:\n        {\n          /* Note: this operation cannot throw an exception */\n          *stack_top_p++ = ecma_make_object_value (ecma_op_new_array_object (0));\n          continue;\n        }\n#if JERRY_ESNEXT\n        case VM_OC_LOCAL_EVAL:\n        {\n          ECMA_CLEAR_LOCAL_PARSE_OPTS ();\n          uint8_t parse_opts = *byte_code_p++;\n          ECMA_SET_LOCAL_PARSE_OPTS (parse_opts);\n          continue;\n        }\n        case VM_OC_SUPER_CALL:\n        {\n          uint8_t arguments_list_len = *byte_code_p++;\n\n          if (opcode >= CBC_EXT_SPREAD_SUPER_CALL)\n          {\n            stack_top_p -= arguments_list_len;\n            ecma_collection_t *arguments_p = opfunc_spread_arguments (stack_top_p, arguments_list_len);\n\n            if (JERRY_UNLIKELY (arguments_p == NULL))\n            {\n              result = ECMA_VALUE_ERROR;\n              goto error;\n            }\n\n            stack_top_p++;\n            ECMA_SET_INTERNAL_VALUE_POINTER (stack_top_p[-1], arguments_p);\n          }\n          else\n          {\n            stack_top_p -= arguments_list_len;\n          }\n\n          frame_ctx_p->call_operation = VM_EXEC_SUPER_CALL;\n          frame_ctx_p->byte_code_p = byte_code_start_p;\n          frame_ctx_p->stack_top_p = stack_top_p;\n          return ECMA_VALUE_UNDEFINED;\n        }\n        case VM_OC_PUSH_CLASS_ENVIRONMENT:\n        {\n          uint16_t literal_index;\n\n          READ_LITERAL_INDEX (literal_index);\n          opfunc_push_class_environment (frame_ctx_p, &stack_top_p, literal_start_p[literal_index]);\n          continue;\n        }\n        case VM_OC_PUSH_IMPLICIT_CTOR:\n        {\n          *stack_top_p++ = opfunc_create_implicit_class_constructor (opcode,\n                                                                     frame_ctx_p->shared_p->bytecode_header_p);\n          continue;\n        }\n        case VM_OC_INIT_CLASS:\n        {\n          result = opfunc_init_class (frame_ctx_p, stack_top_p);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n          continue;\n        }\n        case VM_OC_FINALIZE_CLASS:\n        {\n          JERRY_ASSERT (opcode == CBC_EXT_FINALIZE_NAMED_CLASS || opcode == CBC_EXT_FINALIZE_ANONYMOUS_CLASS);\n\n          if (opcode == CBC_EXT_FINALIZE_NAMED_CLASS)\n          {\n            uint16_t literal_index;\n            READ_LITERAL_INDEX (literal_index);\n            left_value = literal_start_p[literal_index];\n          }\n\n          opfunc_finalize_class (frame_ctx_p, &stack_top_p, left_value);\n          continue;\n        }\n        case VM_OC_SET_FIELD_INIT:\n        {\n          ecma_string_t *property_name_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_INIT);\n          ecma_object_t *object_p = ecma_get_object_from_value (stack_top_p[-2]);\n\n          ecma_property_value_t *property_value_p = ecma_create_named_data_property (object_p,\n                                                                                     property_name_p,\n                                                                                     ECMA_PROPERTY_FIXED,\n                                                                                     NULL);\n          property_value_p->value = left_value;\n\n          property_name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_COMPUTED);\n          ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);\n\n          if (property_p != NULL)\n          {\n            property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n            ecma_value_t *compact_collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t,\n                                                                                  property_value_p->value);\n            compact_collection_p = ecma_compact_collection_shrink (compact_collection_p);\n            ECMA_SET_INTERNAL_VALUE_POINTER (property_value_p->value, compact_collection_p);\n          }\n\n          goto free_left_value;\n        }\n        case VM_OC_RUN_FIELD_INIT:\n        {\n          JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_NON_ARROW_FUNC);\n          result = opfunc_init_class_fields (frame_ctx_p->shared_p->function_object_p, frame_ctx_p->this_binding);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n          continue;\n        }\n        case VM_OC_RUN_STATIC_FIELD_INIT:\n        {\n          left_value = stack_top_p[-2];\n          stack_top_p[-2] = stack_top_p[-1];\n          stack_top_p--;\n\n          result = opfunc_init_static_class_fields (left_value, stack_top_p[-1]);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n          goto free_left_value;\n        }\n        case VM_OC_SET_NEXT_COMPUTED_FIELD:\n        {\n          ecma_integer_value_t next_index = ecma_get_integer_from_value (stack_top_p[-2]) + 1;\n          stack_top_p[-2] = ecma_make_integer_value (next_index);\n          stack_top_p++;\n\n          JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_CLASS_FIELDS);\n\n          ecma_value_t *computed_class_fields_p = VM_GET_COMPUTED_CLASS_FIELDS (frame_ctx_p);\n          JERRY_ASSERT ((ecma_value_t) next_index < ECMA_COMPACT_COLLECTION_GET_SIZE (computed_class_fields_p));\n\n          result = stack_top_p[-2];\n          stack_top_p[-1] = ecma_copy_value (computed_class_fields_p[next_index]);\n          stack_top_p[-2] = ecma_copy_value (frame_ctx_p->this_binding);\n          break;\n        }\n        case VM_OC_PUSH_SUPER_CONSTRUCTOR:\n        {\n          result = ecma_op_function_get_super_constructor (vm_get_class_function (frame_ctx_p));\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          continue;\n        }\n        case VM_OC_RESOLVE_LEXICAL_THIS:\n        {\n          result = ecma_op_get_this_binding (frame_ctx_p->lex_env_p);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          continue;\n        }\n        case VM_OC_OBJECT_LITERAL_HOME_ENV:\n        {\n          if (opcode == CBC_EXT_PUSH_OBJECT_SUPER_ENVIRONMENT)\n          {\n            ecma_value_t obj_value = stack_top_p[-1];\n            ecma_object_t *obj_env_p = ecma_create_lex_env_class (frame_ctx_p->lex_env_p, 0);\n\n            ECMA_SET_NON_NULL_POINTER (obj_env_p->u1.bound_object_cp, ecma_get_object_from_value (obj_value));\n            stack_top_p[-1] = ecma_make_object_value (obj_env_p);\n            *stack_top_p++ = obj_value;\n          }\n          else\n          {\n            JERRY_ASSERT (opcode == CBC_EXT_POP_OBJECT_SUPER_ENVIRONMENT);\n            ecma_deref_object (ecma_get_object_from_value (stack_top_p[-2]));\n            stack_top_p[-2] = stack_top_p[-1];\n            stack_top_p--;\n          }\n          continue;\n        }\n        case VM_OC_SET_HOME_OBJECT:\n        {\n          int offset = opcode == CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED ? -1 : 0;\n          opfunc_set_home_object (ecma_get_object_from_value (stack_top_p[-1]),\n                                  ecma_get_object_from_value (stack_top_p[-3 + offset]));\n          continue;\n        }\n        case VM_OC_SUPER_REFERENCE:\n        {\n          result = opfunc_form_super_reference (&stack_top_p, frame_ctx_p, left_value, opcode);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          goto free_left_value;\n        }\n        case VM_OC_SET_FUNCTION_NAME:\n        {\n          char *prefix_p = NULL;\n          lit_utf8_size_t prefix_size = 0;\n\n          if (opcode != CBC_EXT_SET_FUNCTION_NAME)\n          {\n            ecma_value_t prop_name_value;\n\n            if (opcode == CBC_EXT_SET_CLASS_NAME)\n            {\n              uint16_t literal_index;\n              READ_LITERAL_INDEX (literal_index);\n              prop_name_value = literal_start_p[literal_index];\n            }\n            else\n            {\n              prop_name_value = stack_top_p[-2];\n            }\n\n            ecma_string_t *prop_name_p = ecma_op_to_property_key (prop_name_value);\n\n            if (JERRY_UNLIKELY (prop_name_p == NULL))\n            {\n              result = ECMA_VALUE_ERROR;\n              goto error;\n            }\n\n            left_value = ecma_make_prop_name_value (prop_name_p);\n\n            if (opcode != CBC_EXT_SET_CLASS_NAME)\n            {\n              ecma_ref_ecma_string (prop_name_p);\n              ecma_free_value (stack_top_p[-2]);\n              stack_top_p[-2] = left_value;\n            }\n\n            if (opcode == CBC_EXT_SET_COMPUTED_GETTER_NAME || opcode == CBC_EXT_SET_COMPUTED_SETTER_NAME)\n            {\n              prefix_p = (opcode == CBC_EXT_SET_COMPUTED_GETTER_NAME) ? \"get \" : \"set \";\n              prefix_size = 4;\n            }\n          }\n\n          ecma_object_t *func_obj_p = ecma_get_object_from_value (stack_top_p[-1]);\n\n          if (ecma_find_named_property (func_obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_NAME)) != NULL)\n          {\n            ecma_free_value (left_value);\n            continue;\n          }\n\n          ecma_property_value_t *value_p;\n          value_p = ecma_create_named_data_property (func_obj_p,\n                                                     ecma_get_magic_string (LIT_MAGIC_STRING_NAME),\n                                                     ECMA_PROPERTY_FLAG_CONFIGURABLE,\n                                                     NULL);\n\n          if (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_FUNCTION)\n          {\n            ECMA_SET_SECOND_BIT_TO_POINTER_TAG (((ecma_extended_object_t *) func_obj_p)->u.function.scope_cp);\n          }\n\n          value_p->value = ecma_op_function_form_name (ecma_get_prop_name_from_value (left_value),\n                                                       prefix_p,\n                                                       prefix_size);\n          ecma_free_value (left_value);\n          continue;\n        }\n        case VM_OC_PUSH_SPREAD_ELEMENT:\n        {\n          *stack_top_p++ = ECMA_VALUE_SPREAD_ELEMENT;\n          continue;\n        }\n        case VM_OC_PUSH_REST_OBJECT:\n        {\n          vm_frame_ctx_shared_t *shared_p = frame_ctx_p->shared_p;\n\n          JERRY_ASSERT (shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_ARG_LIST);\n\n          const ecma_value_t *arg_list_p = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_p;\n          uint32_t arg_list_len = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_len;\n          uint16_t argument_end;\n\n          if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n          {\n            argument_end = ((cbc_uint16_arguments_t *) bytecode_header_p)->argument_end;\n          }\n          else\n          {\n            argument_end = ((cbc_uint8_arguments_t *) bytecode_header_p)->argument_end;\n          }\n\n          if (arg_list_len < argument_end)\n          {\n            arg_list_len = argument_end;\n          }\n\n          result = ecma_op_new_array_object_from_buffer (arg_list_p + argument_end,\n                                                         arg_list_len - argument_end);\n\n          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (result));\n          *stack_top_p++ = result;\n          continue;\n        }\n        case VM_OC_ITERATOR_CONTEXT_CREATE:\n        {\n          result = ecma_op_get_iterator (stack_top_p[-1], ECMA_VALUE_SYNC_ITERATOR, &left_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          uint32_t context_size = (uint32_t) (stack_top_p\n                                              + PARSER_ITERATOR_CONTEXT_STACK_ALLOCATION\n                                              - VM_LAST_CONTEXT_END ());\n          stack_top_p += PARSER_ITERATOR_CONTEXT_STACK_ALLOCATION;\n          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, context_size);\n\n          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_ITERATOR, context_size) | VM_CONTEXT_CLOSE_ITERATOR;\n          stack_top_p[-2] = result;\n          stack_top_p[-3] = left_value;\n\n          continue;\n        }\n        case VM_OC_ITERATOR_STEP:\n        {\n          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();\n\n          ecma_value_t iterator = last_context_end_p[-2];\n          ecma_value_t next_method = last_context_end_p[-3];\n\n          result = ecma_op_iterator_step (iterator, next_method);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;\n            goto error;\n          }\n\n          ecma_value_t value = ECMA_VALUE_UNDEFINED;\n\n          if (!ecma_is_value_false (result))\n          {\n            value = ecma_op_iterator_value (result);\n            ecma_free_value (result);\n\n            if (ECMA_IS_VALUE_ERROR (value))\n            {\n              last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;\n              result = value;\n              goto error;\n            }\n          }\n          else\n          {\n            last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;\n          }\n\n          *stack_top_p++ = value;\n          continue;\n        }\n        case VM_OC_ITERATOR_CONTEXT_END:\n        {\n          JERRY_ASSERT (VM_LAST_CONTEXT_END () == stack_top_p);\n\n          if (stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR)\n          {\n            stack_top_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;\n            result = ecma_op_iterator_close (stack_top_p[-2]);\n\n            if (ECMA_IS_VALUE_ERROR (result))\n            {\n              goto error;\n            }\n          }\n\n          stack_top_p = vm_stack_context_abort_variable_length (frame_ctx_p,\n                                                                stack_top_p,\n                                                                PARSER_ITERATOR_CONTEXT_STACK_ALLOCATION);\n          continue;\n        }\n        case VM_OC_DEFAULT_INITIALIZER:\n        {\n          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);\n\n          if (stack_top_p[-1] != ECMA_VALUE_UNDEFINED)\n          {\n            byte_code_p = byte_code_start_p + branch_offset;\n            continue;\n          }\n\n          stack_top_p--;\n          continue;\n        }\n        case VM_OC_REST_INITIALIZER:\n        {\n          ecma_object_t *array_p = ecma_op_new_array_object (0);\n          JERRY_ASSERT (ecma_op_object_is_fast_array (array_p));\n\n          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();\n          ecma_value_t iterator = last_context_end_p[-2];\n          ecma_value_t next_method = last_context_end_p[-3];\n          uint32_t index = 0;\n\n          while (true)\n          {\n            result = ecma_op_iterator_step (iterator, next_method);\n\n            if (ECMA_IS_VALUE_ERROR (result))\n            {\n              last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;\n              ecma_deref_object (array_p);\n              goto error;\n            }\n\n            if (ecma_is_value_false (result))\n            {\n              last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;\n              break;\n            }\n\n            ecma_value_t value = ecma_op_iterator_value (result);\n            ecma_free_value (result);\n\n            if (ECMA_IS_VALUE_ERROR (value))\n            {\n              ecma_deref_object (array_p);\n              result = value;\n              goto error;\n            }\n\n            bool set_result = ecma_fast_array_set_property (array_p, index++, value);\n            JERRY_ASSERT (set_result);\n            ecma_free_value (value);\n          }\n\n          *stack_top_p++ = ecma_make_object_value (array_p);\n          continue;\n        }\n        case VM_OC_OBJ_INIT_CONTEXT_CREATE:\n        {\n          left_value = stack_top_p[-1];\n          vm_stack_context_type_t context_type = VM_CONTEXT_OBJ_INIT;\n          uint32_t context_stack_allocation = PARSER_OBJ_INIT_CONTEXT_STACK_ALLOCATION;\n\n          if (opcode == CBC_EXT_OBJ_INIT_REST_CONTEXT_CREATE)\n          {\n            context_type = VM_CONTEXT_OBJ_INIT_REST;\n            context_stack_allocation = PARSER_OBJ_INIT_REST_CONTEXT_STACK_ALLOCATION;\n          }\n\n          uint32_t context_size = (uint32_t) (stack_top_p + context_stack_allocation - VM_LAST_CONTEXT_END ());\n          stack_top_p += context_stack_allocation;\n          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, context_size);\n\n          stack_top_p[-1] = VM_CREATE_CONTEXT (context_type, context_size);\n          stack_top_p[-2] = left_value;\n\n          if (context_type == VM_CONTEXT_OBJ_INIT_REST)\n          {\n            stack_top_p[-3] = ecma_make_object_value (ecma_op_new_array_object (0));\n          }\n          continue;\n        }\n        case VM_OC_OBJ_INIT_CONTEXT_END:\n        {\n          JERRY_ASSERT (stack_top_p == VM_LAST_CONTEXT_END ());\n\n          uint32_t context_stack_allocation = PARSER_OBJ_INIT_CONTEXT_STACK_ALLOCATION;\n\n          if (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_OBJ_INIT_REST)\n          {\n            context_stack_allocation = PARSER_OBJ_INIT_REST_CONTEXT_STACK_ALLOCATION;\n          }\n\n          stack_top_p = vm_stack_context_abort_variable_length (frame_ctx_p,\n                                                                stack_top_p,\n                                                                context_stack_allocation);\n          continue;\n        }\n        case VM_OC_OBJ_INIT_PUSH_REST:\n        {\n          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();\n          if (!ecma_op_require_object_coercible (last_context_end_p[-2]))\n          {\n            result = ECMA_VALUE_ERROR;\n            goto error;\n          }\n\n          ecma_object_t *prototype_p = ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);\n          ecma_object_t *result_object_p = ecma_create_object (prototype_p, 0, ECMA_OBJECT_TYPE_GENERAL);\n\n          left_value = ecma_make_object_value (result_object_p);\n          result = opfunc_copy_data_properties (left_value, last_context_end_p[-2], last_context_end_p[-3]);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          ecma_free_value (last_context_end_p[-3]);\n          last_context_end_p[-3] = last_context_end_p[-2];\n          last_context_end_p[-2] = ECMA_VALUE_UNDEFINED;\n\n          *stack_top_p++ = left_value;\n          continue;\n        }\n        case VM_OC_INITIALIZER_PUSH_NAME:\n        {\n          if (JERRY_UNLIKELY (!ecma_is_value_prop_name (left_value)))\n          {\n            ecma_string_t *property_key = ecma_op_to_property_key (left_value);\n\n            if (property_key == NULL)\n            {\n              result = ECMA_VALUE_ERROR;\n              goto error;\n            }\n\n            ecma_free_value (left_value);\n            left_value = ecma_make_string_value (property_key);\n          }\n\n          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();\n          ecma_object_t *array_obj_p = ecma_get_object_from_value (last_context_end_p[-3]);\n          JERRY_ASSERT (ecma_get_object_type (array_obj_p) == ECMA_OBJECT_TYPE_ARRAY);\n\n          ecma_extended_object_t *ext_array_obj_p = (ecma_extended_object_t *) array_obj_p;\n          ecma_fast_array_set_property (array_obj_p, ext_array_obj_p->u.array.length, left_value);\n          /* FALLTHRU */\n        }\n        case VM_OC_INITIALIZER_PUSH_PROP:\n        {\n          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();\n          ecma_value_t base = last_context_end_p[-2];\n\n          if (opcode == CBC_EXT_INITIALIZER_PUSH_PROP)\n          {\n            left_value = *last_context_end_p++;\n            while (last_context_end_p < stack_top_p)\n            {\n              last_context_end_p[-1] = *last_context_end_p;\n              last_context_end_p++;\n            }\n            stack_top_p--;\n          }\n\n          result = vm_op_get_value (base, left_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_left_value;\n        }\n        case VM_OC_SPREAD_ARGUMENTS:\n        {\n          uint8_t arguments_list_len = *byte_code_p++;\n          stack_top_p -= arguments_list_len;\n\n          ecma_collection_t *arguments_p = opfunc_spread_arguments (stack_top_p, arguments_list_len);\n\n          if (JERRY_UNLIKELY (arguments_p == NULL))\n          {\n            result = ECMA_VALUE_ERROR;\n            goto error;\n          }\n\n          stack_top_p++;\n          ECMA_SET_INTERNAL_VALUE_POINTER (stack_top_p[-1], arguments_p);\n\n          frame_ctx_p->call_operation = VM_EXEC_SPREAD_OP;\n          frame_ctx_p->byte_code_p = byte_code_start_p;\n          frame_ctx_p->stack_top_p = stack_top_p;\n          return ECMA_VALUE_UNDEFINED;\n        }\n        case VM_OC_CREATE_GENERATOR:\n        {\n          frame_ctx_p->call_operation = VM_EXEC_RETURN;\n          frame_ctx_p->byte_code_p = byte_code_p;\n          frame_ctx_p->stack_top_p = stack_top_p;\n\n          vm_executable_object_t *executable_object_p;\n          executable_object_p = opfunc_create_executable_object (frame_ctx_p, VM_CREATE_EXECUTABLE_OBJECT_GENERATOR);\n\n          return ecma_make_object_value ((ecma_object_t *) executable_object_p);\n        }\n        case VM_OC_YIELD:\n        {\n          frame_ctx_p->call_operation = VM_EXEC_RETURN;\n          frame_ctx_p->byte_code_p = byte_code_p;\n          frame_ctx_p->stack_top_p = --stack_top_p;\n          return *stack_top_p;\n        }\n        case VM_OC_ASYNC_YIELD:\n        {\n          ecma_extended_object_t *async_generator_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);\n\n          opfunc_async_generator_yield (async_generator_object_p, stack_top_p[-1]);\n\n          frame_ctx_p->call_operation = VM_EXEC_RETURN;\n          frame_ctx_p->byte_code_p = byte_code_p;\n          frame_ctx_p->stack_top_p = --stack_top_p;\n          return ECMA_VALUE_UNDEFINED;\n        }\n        case VM_OC_ASYNC_YIELD_ITERATOR:\n        {\n          ecma_extended_object_t *async_generator_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);\n\n          JERRY_ASSERT (!(async_generator_object_p->u.cls.u2.executable_obj_flags\n                          & ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD));\n\n          /* Byte code is executed at the first time. */\n          left_value = stack_top_p[-1];\n          result = ecma_op_get_iterator (left_value, ECMA_VALUE_ASYNC_ITERATOR, stack_top_p - 1);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          ecma_free_value (left_value);\n          left_value = result;\n          result = ecma_op_iterator_next (left_value, stack_top_p[-1], ECMA_VALUE_UNDEFINED);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          result = ecma_promise_async_await (async_generator_object_p, result);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          async_generator_object_p->u.cls.u2.executable_obj_flags |= ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD;\n          frame_ctx_p->block_result = left_value;\n\n          frame_ctx_p->call_operation = VM_EXEC_RETURN;\n          frame_ctx_p->byte_code_p = byte_code_p;\n          frame_ctx_p->stack_top_p = stack_top_p;\n          return ECMA_VALUE_UNDEFINED;\n        }\n        case VM_OC_AWAIT:\n        {\n          if (JERRY_UNLIKELY (frame_ctx_p->block_result == ECMA_VALUE_UNDEFINED))\n          {\n            frame_ctx_p->call_operation = VM_EXEC_RETURN;\n            frame_ctx_p->byte_code_p = byte_code_p;\n            frame_ctx_p->stack_top_p = --stack_top_p;\n\n            result = opfunc_async_create_and_await (frame_ctx_p, *stack_top_p, 0);\n\n            if (ECMA_IS_VALUE_ERROR (result))\n            {\n              goto error;\n            }\n            return result;\n          }\n          /* FALLTHRU */\n        }\n        case VM_OC_GENERATOR_AWAIT:\n        {\n          ecma_extended_object_t *async_generator_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);\n\n          result = ecma_promise_async_await (async_generator_object_p, *(--stack_top_p));\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          frame_ctx_p->call_operation = VM_EXEC_RETURN;\n          frame_ctx_p->byte_code_p = byte_code_p;\n          frame_ctx_p->stack_top_p = stack_top_p;\n          return ECMA_VALUE_UNDEFINED;\n        }\n        case VM_OC_EXT_RETURN:\n        {\n          result = left_value;\n          left_value = ECMA_VALUE_UNDEFINED;\n\n          ecma_value_t *stack_bottom_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;\n\n          while (stack_top_p > stack_bottom_p)\n          {\n            ecma_fast_free_value (*(--stack_top_p));\n          }\n\n          goto error;\n        }\n        case VM_OC_ASYNC_EXIT:\n        {\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n\n          result = frame_ctx_p->block_result;\n          frame_ctx_p->block_result = ECMA_VALUE_UNDEFINED;\n\n          if (result == ECMA_VALUE_UNDEFINED)\n          {\n            result = ecma_op_create_promise_object (ECMA_VALUE_EMPTY, ECMA_VALUE_UNDEFINED, NULL);\n          }\n\n          vm_stack_context_type_t context_type = VM_GET_CONTEXT_TYPE (stack_top_p[-1]);\n\n          if (context_type == VM_CONTEXT_TRY)\n          {\n            JERRY_ASSERT (frame_ctx_p->context_depth == PARSER_TRY_CONTEXT_STACK_ALLOCATION);\n            left_value = ECMA_VALUE_UNDEFINED;\n          }\n          else\n          {\n            JERRY_ASSERT (frame_ctx_p->context_depth == PARSER_FINALLY_CONTEXT_STACK_ALLOCATION);\n            left_value = stack_top_p[-2];\n          }\n\n          if (context_type == VM_CONTEXT_FINALLY_THROW)\n          {\n            ecma_reject_promise (result, left_value);\n          }\n          else\n          {\n            JERRY_ASSERT (context_type == VM_CONTEXT_TRY || context_type == VM_CONTEXT_FINALLY_RETURN);\n            ecma_fulfill_promise (result, left_value);\n          }\n\n          ecma_free_value (left_value);\n\n          frame_ctx_p->context_depth = 0;\n          frame_ctx_p->call_operation = VM_NO_EXEC_OP;\n          return result;\n        }\n        case VM_OC_STRING_CONCAT:\n        {\n          ecma_string_t *left_str_p = ecma_op_to_string (left_value);\n\n          if (JERRY_UNLIKELY (left_str_p == NULL))\n          {\n            result = ECMA_VALUE_ERROR;\n            goto error;\n          }\n          ecma_string_t *right_str_p = ecma_op_to_string (right_value);\n\n          if (JERRY_UNLIKELY (right_str_p == NULL))\n          {\n            ecma_deref_ecma_string (left_str_p);\n            result = ECMA_VALUE_ERROR;\n            goto error;\n          }\n\n          ecma_string_t *result_str_p = ecma_concat_ecma_strings (left_str_p, right_str_p);\n          ecma_deref_ecma_string (right_str_p);\n\n          *stack_top_p++ = ecma_make_string_value (result_str_p);\n          goto free_both_values;\n        }\n        case VM_OC_GET_TEMPLATE_OBJECT:\n        {\n          uint8_t tagged_idx = *byte_code_p++;\n          ecma_collection_t *collection_p = ecma_compiled_code_get_tagged_template_collection (bytecode_header_p);\n          JERRY_ASSERT (tagged_idx < collection_p->item_count);\n\n          *stack_top_p++ = ecma_copy_value (collection_p->buffer_p[tagged_idx]);\n          continue;\n        }\n        case VM_OC_PUSH_NEW_TARGET:\n        {\n          ecma_object_t *new_target_object_p = JERRY_CONTEXT (current_new_target_p);\n          if (new_target_object_p == NULL)\n          {\n            *stack_top_p++ = ECMA_VALUE_UNDEFINED;\n          }\n          else\n          {\n            ecma_ref_object (new_target_object_p);\n            *stack_top_p++ = ecma_make_object_value (new_target_object_p);\n          }\n          continue;\n        }\n        case VM_OC_REQUIRE_OBJECT_COERCIBLE:\n        {\n          if (!ecma_op_require_object_coercible (stack_top_p[-1]))\n          {\n            result = ECMA_VALUE_ERROR;\n            goto error;\n          }\n          continue;\n        }\n        case VM_OC_ASSIGN_SUPER:\n        {\n          result = opfunc_assign_super_reference (&stack_top_p, frame_ctx_p, opcode_data);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n          continue;\n        }\n#endif /* JERRY_ESNEXT */\n        case VM_OC_PUSH_ELISON:\n        {\n          *stack_top_p++ = ECMA_VALUE_ARRAY_HOLE;\n          continue;\n        }\n        case VM_OC_APPEND_ARRAY:\n        {\n          uint16_t values_length = *byte_code_p++;\n          stack_top_p -= values_length;\n\n#if JERRY_ESNEXT\n          if (*byte_code_start_p == CBC_EXT_OPCODE)\n          {\n            values_length = (uint16_t) (values_length | OPFUNC_HAS_SPREAD_ELEMENT);\n          }\n#endif /* JERRY_ESNEXT */\n          result = opfunc_append_array (stack_top_p, values_length);\n\n#if JERRY_ESNEXT\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n#else /* !JERRY_ESNEXT */\n          JERRY_ASSERT (ecma_is_value_empty (result));\n#endif /* JERRY_ESNEXT */\n          continue;\n        }\n        case VM_OC_IDENT_REFERENCE:\n        {\n          uint16_t literal_index;\n\n          READ_LITERAL_INDEX (literal_index);\n\n          JERRY_ASSERT (literal_index < ident_end);\n\n          if (literal_index < register_end)\n          {\n            *stack_top_p++ = ECMA_VALUE_REGISTER_REF;\n            *stack_top_p++ = ecma_make_integer_value (literal_index);\n            *stack_top_p++ = ecma_fast_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index));\n          }\n          else\n          {\n            ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n\n            ecma_object_t *ref_base_lex_env_p;\n\n            result = ecma_op_get_value_lex_env_base (frame_ctx_p->lex_env_p,\n                                                     &ref_base_lex_env_p,\n                                                     name_p);\n\n            if (ECMA_IS_VALUE_ERROR (result))\n            {\n              goto error;\n            }\n\n            ecma_ref_object (ref_base_lex_env_p);\n            ecma_ref_ecma_string (name_p);\n            *stack_top_p++ = ecma_make_object_value (ref_base_lex_env_p);\n            *stack_top_p++ = ecma_make_string_value (name_p);\n            *stack_top_p++ = result;\n          }\n          continue;\n        }\n        case VM_OC_PROP_GET:\n        {\n          result = vm_op_get_value (left_value, right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_PROP_REFERENCE:\n        {\n          /* Forms with reference requires preserving the base and offset. */\n\n          if (opcode == CBC_PUSH_PROP_REFERENCE)\n          {\n            left_value = stack_top_p[-2];\n            right_value = stack_top_p[-1];\n          }\n          else if (opcode == CBC_PUSH_PROP_LITERAL_REFERENCE)\n          {\n            *stack_top_p++ = left_value;\n            right_value = left_value;\n            left_value = stack_top_p[-2];\n          }\n          else\n          {\n            JERRY_ASSERT (opcode == CBC_PUSH_PROP_LITERAL_LITERAL_REFERENCE\n                          || opcode == CBC_PUSH_PROP_THIS_LITERAL_REFERENCE);\n            *stack_top_p++ = left_value;\n            *stack_top_p++ = right_value;\n          }\n          /* FALLTHRU */\n        }\n        case VM_OC_PROP_PRE_INCR:\n        case VM_OC_PROP_PRE_DECR:\n        case VM_OC_PROP_POST_INCR:\n        case VM_OC_PROP_POST_DECR:\n        {\n          result = vm_op_get_value (left_value,\n                                    right_value);\n\n          if (opcode < CBC_PRE_INCR)\n          {\n            left_value = ECMA_VALUE_UNDEFINED;\n            right_value = ECMA_VALUE_UNDEFINED;\n          }\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          if (opcode < CBC_PRE_INCR)\n          {\n            break;\n          }\n\n          stack_top_p += 2;\n          left_value = result;\n          right_value = ECMA_VALUE_UNDEFINED;\n          /* FALLTHRU */\n        }\n        case VM_OC_PRE_INCR:\n        case VM_OC_PRE_DECR:\n        case VM_OC_POST_INCR:\n        case VM_OC_POST_DECR:\n        {\n          uint32_t opcode_flags = VM_OC_GROUP_GET_INDEX (opcode_data) - VM_OC_PROP_PRE_INCR;\n          ecma_number_t result_number;\n\n          byte_code_p = byte_code_start_p + 1;\n\n          if (ecma_is_value_integer_number (left_value))\n          {\n            result = left_value;\n            left_value = ECMA_VALUE_UNDEFINED;\n\n            ecma_integer_value_t int_value = (ecma_integer_value_t) result;\n            ecma_integer_value_t int_increase = 0;\n\n            if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)\n            {\n              if (int_value > ECMA_INTEGER_NUMBER_MIN_SHIFTED)\n              {\n                int_increase = -(1 << ECMA_DIRECT_SHIFT);\n              }\n            }\n            else if (int_value < ECMA_INTEGER_NUMBER_MAX_SHIFTED)\n            {\n              int_increase = 1 << ECMA_DIRECT_SHIFT;\n            }\n\n            if (JERRY_LIKELY (int_increase != 0))\n            {\n              /* Postfix operators require the unmodifed number value. */\n              if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)\n              {\n                POST_INCREASE_DECREASE_PUT_RESULT (result);\n              }\n\n              result = (ecma_value_t) (int_value + int_increase);\n              break;\n            }\n            result_number = (ecma_number_t) ecma_get_integer_from_value (result);\n          }\n          else if (ecma_is_value_float_number (left_value))\n          {\n            result = left_value;\n            left_value = ECMA_VALUE_UNDEFINED;\n            result_number = ecma_get_number_from_value (result);\n          }\n          else\n          {\n            result = ecma_op_to_numeric (left_value, &result_number, ECMA_TO_NUMERIC_ALLOW_BIGINT);\n\n            if (ECMA_IS_VALUE_ERROR (result))\n            {\n              goto error;\n            }\n\n            ecma_free_value (left_value);\n            left_value = ECMA_VALUE_UNDEFINED;\n\n#if JERRY_BUILTIN_BIGINT\n            if (JERRY_UNLIKELY (ecma_is_value_bigint (result)))\n            {\n              ecma_bigint_unary_operation_type operation_type = ECMA_BIGINT_UNARY_INCREASE;\n\n              if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)\n              {\n                operation_type = ECMA_BIGINT_UNARY_DECREASE;\n              }\n\n              /* Postfix operators require the unmodifed number value. */\n              if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)\n              {\n                POST_INCREASE_DECREASE_PUT_RESULT (result);\n\n                result = ecma_bigint_unary (result, operation_type);\n              }\n              else\n              {\n                ecma_value_t original_value = result;\n                result = ecma_bigint_unary (original_value, operation_type);\n                ecma_free_value (original_value);\n              }\n\n              if (ECMA_IS_VALUE_ERROR (result))\n              {\n                goto error;\n              }\n              break;\n            }\n#endif /* JERRY_BUILTIN_BIGINT */\n\n            result = ecma_make_number_value (result_number);\n          }\n\n          ecma_number_t increase = ECMA_NUMBER_ONE;\n\n          if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)\n          {\n            /* For decrement operators */\n            increase = ECMA_NUMBER_MINUS_ONE;\n          }\n\n          /* Postfix operators require the unmodifed number value. */\n          if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)\n          {\n            POST_INCREASE_DECREASE_PUT_RESULT (result);\n\n            result = ecma_make_number_value (result_number + increase);\n            break;\n          }\n\n          if (ecma_is_value_integer_number (result))\n          {\n            result = ecma_make_number_value (result_number + increase);\n          }\n          else\n          {\n            result = ecma_update_float_number (result, result_number + increase);\n          }\n          break;\n        }\n        case VM_OC_ASSIGN:\n        {\n          result = left_value;\n          left_value = ECMA_VALUE_UNDEFINED;\n          break;\n        }\n        case VM_OC_MOV_IDENT:\n        {\n          uint32_t literal_index;\n\n          READ_LITERAL_INDEX (literal_index);\n\n          JERRY_ASSERT (literal_index < register_end);\n          JERRY_ASSERT (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)));\n\n          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));\n          VM_GET_REGISTER (frame_ctx_p, literal_index) = left_value;\n          continue;\n        }\n        case VM_OC_ASSIGN_PROP:\n        {\n          result = stack_top_p[-1];\n          stack_top_p[-1] = left_value;\n          left_value = ECMA_VALUE_UNDEFINED;\n          break;\n        }\n        case VM_OC_ASSIGN_PROP_THIS:\n        {\n          result = stack_top_p[-1];\n          stack_top_p[-1] = ecma_copy_value (frame_ctx_p->this_binding);\n          *stack_top_p++ = left_value;\n          left_value = ECMA_VALUE_UNDEFINED;\n          break;\n        }\n        case VM_OC_RETURN:\n        {\n          JERRY_ASSERT (opcode == CBC_RETURN\n                        || opcode == CBC_RETURN_WITH_BLOCK\n                        || opcode == CBC_RETURN_WITH_LITERAL);\n\n          if (opcode == CBC_RETURN_WITH_BLOCK)\n          {\n            left_value = frame_ctx_p->block_result;\n            frame_ctx_p->block_result = ECMA_VALUE_UNDEFINED;\n          }\n\n          result = left_value;\n          left_value = ECMA_VALUE_UNDEFINED;\n          goto error;\n        }\n        case VM_OC_THROW:\n        {\n          jcontext_raise_exception (left_value);\n\n          result = ECMA_VALUE_ERROR;\n          left_value = ECMA_VALUE_UNDEFINED;\n          goto error;\n        }\n        case VM_OC_THROW_REFERENCE_ERROR:\n        {\n          result = ecma_raise_reference_error (ECMA_ERR_MSG (\"Undefined reference\"));\n          goto error;\n        }\n        case VM_OC_EVAL:\n        {\n          JERRY_CONTEXT (status_flags) |= ECMA_STATUS_DIRECT_EVAL;\n          JERRY_ASSERT ((*byte_code_p >= CBC_CALL && *byte_code_p <= CBC_CALL2_PROP_BLOCK)\n                        || (*byte_code_p == CBC_EXT_OPCODE\n                            && byte_code_p[1] >= CBC_EXT_SPREAD_CALL\n                            && byte_code_p[1] <= CBC_EXT_SPREAD_CALL_PROP_BLOCK));\n          continue;\n        }\n        case VM_OC_CALL:\n        {\n          frame_ctx_p->call_operation = VM_EXEC_CALL;\n          frame_ctx_p->byte_code_p = byte_code_start_p;\n          frame_ctx_p->stack_top_p = stack_top_p;\n          return ECMA_VALUE_UNDEFINED;\n        }\n        case VM_OC_NEW:\n        {\n          frame_ctx_p->call_operation = VM_EXEC_CONSTRUCT;\n          frame_ctx_p->byte_code_p = byte_code_start_p;\n          frame_ctx_p->stack_top_p = stack_top_p;\n          return ECMA_VALUE_UNDEFINED;\n        }\n        case VM_OC_ERROR:\n        {\n          JERRY_ASSERT (frame_ctx_p->byte_code_p[1] == CBC_EXT_ERROR);\n#if JERRY_DEBUGGER\n          frame_ctx_p->byte_code_p = JERRY_CONTEXT (debugger_exception_byte_code_p);\n#endif /* JERRY_DEBUGGER */\n\n          result = ECMA_VALUE_ERROR;\n          goto error;\n        }\n        case VM_OC_RESOLVE_BASE_FOR_CALL:\n        {\n          ecma_value_t this_value = stack_top_p[-3];\n\n          if (this_value == ECMA_VALUE_REGISTER_REF)\n          {\n            /* Lexical environment cannot be 'this' value. */\n            stack_top_p[-2] = ECMA_VALUE_UNDEFINED;\n            stack_top_p[-3] = ECMA_VALUE_UNDEFINED;\n          }\n          else if (vm_get_implicit_this_value (&this_value))\n          {\n            ecma_free_value (stack_top_p[-3]);\n            stack_top_p[-3] = this_value;\n          }\n\n          continue;\n        }\n        case VM_OC_PROP_DELETE:\n        {\n          result = vm_op_delete_prop (left_value, right_value, is_strict);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          JERRY_ASSERT (ecma_is_value_boolean (result));\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_DELETE:\n        {\n          uint16_t literal_index;\n\n          READ_LITERAL_INDEX (literal_index);\n\n          if (literal_index < register_end)\n          {\n            *stack_top_p++ = ECMA_VALUE_FALSE;\n            continue;\n          }\n\n          result = vm_op_delete_var (literal_start_p[literal_index],\n                                     frame_ctx_p->lex_env_p);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          JERRY_ASSERT (ecma_is_value_boolean (result));\n\n          *stack_top_p++ = result;\n          continue;\n        }\n        case VM_OC_JUMP:\n        {\n          byte_code_p = byte_code_start_p + branch_offset;\n          continue;\n        }\n        case VM_OC_BRANCH_IF_STRICT_EQUAL:\n        {\n          ecma_value_t value = *(--stack_top_p);\n\n          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);\n\n          if (ecma_op_strict_equality_compare (value, stack_top_p[-1]))\n          {\n            byte_code_p = byte_code_start_p + branch_offset;\n            ecma_free_value (*--stack_top_p);\n          }\n          ecma_free_value (value);\n          continue;\n        }\n        case VM_OC_BRANCH_IF_TRUE:\n        case VM_OC_BRANCH_IF_FALSE:\n        case VM_OC_BRANCH_IF_LOGICAL_TRUE:\n        case VM_OC_BRANCH_IF_LOGICAL_FALSE:\n        {\n          uint32_t opcode_flags = VM_OC_GROUP_GET_INDEX (opcode_data) - VM_OC_BRANCH_IF_TRUE;\n          ecma_value_t value = *(--stack_top_p);\n\n          bool boolean_value = ecma_op_to_boolean (value);\n\n          if (opcode_flags & VM_OC_BRANCH_IF_FALSE_FLAG)\n          {\n            boolean_value = !boolean_value;\n          }\n\n          if (boolean_value)\n          {\n            byte_code_p = byte_code_start_p + branch_offset;\n            if (opcode_flags & VM_OC_LOGICAL_BRANCH_FLAG)\n            {\n              /* \"Push\" the value back to the stack. */\n              ++stack_top_p;\n              continue;\n            }\n          }\n\n          ecma_fast_free_value (value);\n          continue;\n        }\n#if JERRY_ESNEXT\n        case VM_OC_BRANCH_IF_NULLISH:\n        {\n          left_value = stack_top_p[-1];\n\n          if (!ecma_is_value_null (left_value) && !ecma_is_value_undefined (left_value))\n          {\n            byte_code_p = byte_code_start_p + branch_offset;\n            continue;\n          }\n          --stack_top_p;\n          continue;\n        }\n#endif /* JERRY_ESNEXT */\n        case VM_OC_PLUS:\n        case VM_OC_MINUS:\n        {\n          result = opfunc_unary_operation (left_value, VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_PLUS);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_left_value;\n        }\n        case VM_OC_NOT:\n        {\n          *stack_top_p++ = ecma_make_boolean_value (!ecma_op_to_boolean (left_value));\n          JERRY_ASSERT (ecma_is_value_boolean (stack_top_p[-1]));\n          goto free_left_value;\n        }\n        case VM_OC_BIT_NOT:\n        {\n          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),\n                               direct_type_mask_must_fill_all_bits_before_the_value_starts);\n\n          if (ecma_is_value_integer_number (left_value))\n          {\n            *stack_top_p++ = (~ECMA_DIRECT_TYPE_MASK) ^ left_value;\n            goto free_left_value;\n          }\n\n          result = do_number_bitwise_not (left_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_left_value;\n        }\n        case VM_OC_VOID:\n        {\n          *stack_top_p++ = ECMA_VALUE_UNDEFINED;\n          goto free_left_value;\n        }\n        case VM_OC_TYPEOF_IDENT:\n        {\n          uint16_t literal_index;\n\n          READ_LITERAL_INDEX (literal_index);\n\n          JERRY_ASSERT (literal_index < ident_end);\n\n          if (literal_index < register_end)\n          {\n            left_value = ecma_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index));\n          }\n          else\n          {\n            ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n\n            ecma_object_t *ref_base_lex_env_p;\n\n            result = ecma_op_get_value_lex_env_base (frame_ctx_p->lex_env_p,\n                                                     &ref_base_lex_env_p,\n                                                     name_p);\n\n            if (ref_base_lex_env_p == NULL)\n            {\n              jcontext_release_exception ();\n              result = ECMA_VALUE_UNDEFINED;\n            }\n            else if (ECMA_IS_VALUE_ERROR (result))\n            {\n              goto error;\n            }\n\n            left_value = result;\n          }\n          /* FALLTHRU */\n        }\n        case VM_OC_TYPEOF:\n        {\n          result = opfunc_typeof (left_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_left_value;\n        }\n        case VM_OC_ADD:\n        {\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);\n            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);\n            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer + right_integer));\n            continue;\n          }\n\n          if (ecma_is_value_float_number (left_value)\n              && ecma_is_value_number (right_value))\n          {\n            ecma_number_t new_value = (ecma_get_float_from_value (left_value) +\n                                       ecma_get_number_from_value (right_value));\n\n            *stack_top_p++ = ecma_update_float_number (left_value, new_value);\n            ecma_free_number (right_value);\n            continue;\n          }\n\n          if (ecma_is_value_float_number (right_value)\n              && ecma_is_value_integer_number (left_value))\n          {\n            ecma_number_t new_value = ((ecma_number_t) ecma_get_integer_from_value (left_value) +\n                                       ecma_get_float_from_value (right_value));\n\n            *stack_top_p++ = ecma_update_float_number (right_value, new_value);\n            continue;\n          }\n\n          result = opfunc_addition (left_value, right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_SUB:\n        {\n          JERRY_STATIC_ASSERT (ECMA_INTEGER_NUMBER_MAX * 2 <= INT32_MAX\n                               && ECMA_INTEGER_NUMBER_MIN * 2 >= INT32_MIN,\n                               doubled_ecma_numbers_must_fit_into_int32_range);\n\n          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)\n                        && !ECMA_IS_VALUE_ERROR (right_value));\n\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);\n            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);\n            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer - right_integer));\n            continue;\n          }\n\n          if (ecma_is_value_float_number (left_value)\n              && ecma_is_value_number (right_value))\n          {\n            ecma_number_t new_value = (ecma_get_float_from_value (left_value) -\n                                       ecma_get_number_from_value (right_value));\n\n            *stack_top_p++ = ecma_update_float_number (left_value, new_value);\n            ecma_free_number (right_value);\n            continue;\n          }\n\n          if (ecma_is_value_float_number (right_value)\n              && ecma_is_value_integer_number (left_value))\n          {\n            ecma_number_t new_value = ((ecma_number_t) ecma_get_integer_from_value (left_value) -\n                                       ecma_get_float_from_value (right_value));\n\n            *stack_top_p++ = ecma_update_float_number (right_value, new_value);\n            continue;\n          }\n\n          result = do_number_arithmetic (NUMBER_ARITHMETIC_SUBTRACTION,\n                                         left_value,\n                                         right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_MUL:\n        {\n          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)\n                        && !ECMA_IS_VALUE_ERROR (right_value));\n\n          JERRY_STATIC_ASSERT (ECMA_INTEGER_MULTIPLY_MAX * ECMA_INTEGER_MULTIPLY_MAX <= ECMA_INTEGER_NUMBER_MAX\n                               && -(ECMA_INTEGER_MULTIPLY_MAX * ECMA_INTEGER_MULTIPLY_MAX) >= ECMA_INTEGER_NUMBER_MIN,\n                               square_of_integer_multiply_max_must_fit_into_integer_value_range);\n\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);\n            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);\n\n            if (-ECMA_INTEGER_MULTIPLY_MAX <= left_integer\n                && left_integer <= ECMA_INTEGER_MULTIPLY_MAX\n                && -ECMA_INTEGER_MULTIPLY_MAX <= right_integer\n                && right_integer <= ECMA_INTEGER_MULTIPLY_MAX\n                && left_integer != 0\n                && right_integer != 0)\n            {\n              *stack_top_p++ = ecma_integer_multiply (left_integer, right_integer);\n              continue;\n            }\n\n            ecma_number_t multiply = (ecma_number_t) left_integer * (ecma_number_t) right_integer;\n            *stack_top_p++ = ecma_make_number_value (multiply);\n            continue;\n          }\n\n          if (ecma_is_value_float_number (left_value)\n              && ecma_is_value_number (right_value))\n          {\n            ecma_number_t new_value = (ecma_get_float_from_value (left_value) *\n                                       ecma_get_number_from_value (right_value));\n\n            *stack_top_p++ = ecma_update_float_number (left_value, new_value);\n            ecma_free_number (right_value);\n            continue;\n          }\n\n          if (ecma_is_value_float_number (right_value)\n              && ecma_is_value_integer_number (left_value))\n          {\n            ecma_number_t new_value = ((ecma_number_t) ecma_get_integer_from_value (left_value) *\n                                       ecma_get_float_from_value (right_value));\n\n            *stack_top_p++ = ecma_update_float_number (right_value, new_value);\n            continue;\n          }\n\n          result = do_number_arithmetic (NUMBER_ARITHMETIC_MULTIPLICATION,\n                                         left_value,\n                                         right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_DIV:\n        {\n          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)\n                        && !ECMA_IS_VALUE_ERROR (right_value));\n\n          result = do_number_arithmetic (NUMBER_ARITHMETIC_DIVISION,\n                                         left_value,\n                                         right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_MOD:\n        {\n          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)\n                        && !ECMA_IS_VALUE_ERROR (right_value));\n\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);\n            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);\n\n            if (right_integer != 0)\n            {\n              ecma_integer_value_t mod_result = left_integer % right_integer;\n\n              if (mod_result != 0 || left_integer >= 0)\n              {\n                *stack_top_p++ = ecma_make_integer_value (mod_result);\n                continue;\n              }\n            }\n          }\n\n          result = do_number_arithmetic (NUMBER_ARITHMETIC_REMAINDER,\n                                         left_value,\n                                         right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n#if JERRY_ESNEXT\n        case VM_OC_EXP:\n        {\n          result = do_number_arithmetic (NUMBER_ARITHMETIC_EXPONENTIATION,\n                                         left_value,\n                                         right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n#endif /* JERRY_ESNEXT */\n        case VM_OC_EQUAL:\n        {\n          result = opfunc_equality (left_value, right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_NOT_EQUAL:\n        {\n          result = opfunc_equality (left_value, right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = ecma_invert_boolean_value (result);\n          goto free_both_values;\n        }\n        case VM_OC_STRICT_EQUAL:\n        {\n          bool is_equal = ecma_op_strict_equality_compare (left_value, right_value);\n\n          result = ecma_make_boolean_value (is_equal);\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_STRICT_NOT_EQUAL:\n        {\n          bool is_equal = ecma_op_strict_equality_compare (left_value, right_value);\n\n          result = ecma_make_boolean_value (!is_equal);\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_BIT_OR:\n        {\n          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),\n                               direct_type_mask_must_fill_all_bits_before_the_value_starts);\n\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            *stack_top_p++ = left_value | right_value;\n            continue;\n          }\n\n          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_OR,\n                                            left_value,\n                                            right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_BIT_XOR:\n        {\n          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),\n                               direct_type_mask_must_fill_all_bits_before_the_value_starts);\n\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            *stack_top_p++ = left_value ^ right_value;\n            continue;\n          }\n\n          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_XOR,\n                                            left_value,\n                                            right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_BIT_AND:\n        {\n          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),\n                               direct_type_mask_must_fill_all_bits_before_the_value_starts);\n\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            *stack_top_p++ = left_value & right_value;\n            continue;\n          }\n\n          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_AND,\n                                            left_value,\n                                            right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_LEFT_SHIFT:\n        {\n          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),\n                               direct_type_mask_must_fill_all_bits_before_the_value_starts);\n\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);\n            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);\n            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer << (right_integer & 0x1f)));\n            continue;\n          }\n\n          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_LEFT,\n                                            left_value,\n                                            right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_RIGHT_SHIFT:\n        {\n          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),\n                               direct_type_mask_must_fill_all_bits_before_the_value_starts);\n\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);\n            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);\n            *stack_top_p++ = ecma_make_integer_value (left_integer >> (right_integer & 0x1f));\n            continue;\n          }\n\n          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_RIGHT,\n                                            left_value,\n                                            right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_UNS_RIGHT_SHIFT:\n        {\n          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),\n                               direct_type_mask_must_fill_all_bits_before_the_value_starts);\n\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            uint32_t left_uint32 = (uint32_t) ecma_get_integer_from_value (left_value);\n            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);\n            *stack_top_p++ = ecma_make_uint32_value (left_uint32 >> (right_integer & 0x1f));\n            continue;\n          }\n\n          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_URIGHT,\n                                            left_value,\n                                            right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_LESS:\n        {\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            bool is_less = (ecma_integer_value_t) left_value < (ecma_integer_value_t) right_value;\n#if !JERRY_VM_EXEC_STOP\n            /* This is a lookahead to the next opcode to improve performance.\n             * If it is CBC_BRANCH_IF_TRUE_BACKWARD, execute it. */\n            if (*byte_code_p <= CBC_BRANCH_IF_TRUE_BACKWARD_3 && *byte_code_p >= CBC_BRANCH_IF_TRUE_BACKWARD)\n            {\n              byte_code_start_p = byte_code_p++;\n              branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (*byte_code_start_p);\n              JERRY_ASSERT (branch_offset_length >= 1 && branch_offset_length <= 3);\n\n              if (is_less)\n              {\n                branch_offset = *(byte_code_p++);\n\n                if (JERRY_UNLIKELY (branch_offset_length != 1))\n                {\n                  branch_offset <<= 8;\n                  branch_offset |= *(byte_code_p++);\n                  if (JERRY_UNLIKELY (branch_offset_length == 3))\n                  {\n                    branch_offset <<= 8;\n                    branch_offset |= *(byte_code_p++);\n                  }\n                }\n\n                /* Note: The opcode is a backward branch. */\n                byte_code_p = byte_code_start_p - branch_offset;\n              }\n              else\n              {\n                byte_code_p += branch_offset_length;\n              }\n\n              continue;\n            }\n#endif /* !JERRY_VM_EXEC_STOP */\n            *stack_top_p++ = ecma_make_boolean_value (is_less);\n            continue;\n          }\n\n          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))\n          {\n            ecma_number_t left_number = ecma_get_number_from_value (left_value);\n            ecma_number_t right_number = ecma_get_number_from_value (right_value);\n\n            *stack_top_p++ = ecma_make_boolean_value (left_number < right_number);\n            goto free_both_values;\n          }\n\n          result = opfunc_relation (left_value, right_value, true, false);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_GREATER:\n        {\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;\n            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;\n\n            *stack_top_p++ = ecma_make_boolean_value (left_integer > right_integer);\n            continue;\n          }\n\n          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))\n          {\n            ecma_number_t left_number = ecma_get_number_from_value (left_value);\n            ecma_number_t right_number = ecma_get_number_from_value (right_value);\n\n            *stack_top_p++ = ecma_make_boolean_value (left_number > right_number);\n            goto free_both_values;\n          }\n\n          result = opfunc_relation (left_value, right_value, false, false);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_LESS_EQUAL:\n        {\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;\n            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;\n\n            *stack_top_p++ = ecma_make_boolean_value (left_integer <= right_integer);\n            continue;\n          }\n\n          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))\n          {\n            ecma_number_t left_number = ecma_get_number_from_value (left_value);\n            ecma_number_t right_number = ecma_get_number_from_value (right_value);\n\n            *stack_top_p++ = ecma_make_boolean_value (left_number <= right_number);\n            goto free_both_values;\n          }\n\n          result = opfunc_relation (left_value, right_value, false, true);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_GREATER_EQUAL:\n        {\n          if (ecma_are_values_integer_numbers (left_value, right_value))\n          {\n            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;\n            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;\n\n            *stack_top_p++ = ecma_make_boolean_value (left_integer >= right_integer);\n            continue;\n          }\n\n          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))\n          {\n            ecma_number_t left_number = ecma_get_number_from_value (left_value);\n            ecma_number_t right_number = ecma_get_number_from_value (right_value);\n\n            *stack_top_p++ = ecma_make_boolean_value (left_number >= right_number);\n            goto free_both_values;\n          }\n\n          result = opfunc_relation (left_value, right_value, true, true);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_IN:\n        {\n          result = opfunc_in (left_value, right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_INSTANCEOF:\n        {\n          result = opfunc_instanceof (left_value, right_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          goto free_both_values;\n        }\n        case VM_OC_BLOCK_CREATE_CONTEXT:\n        {\n#if JERRY_ESNEXT\n          ecma_value_t *stack_context_top_p;\n          stack_context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;\n\n          JERRY_ASSERT (stack_context_top_p == stack_top_p || stack_context_top_p == stack_top_p - 1);\n\n          if (byte_code_start_p[0] != CBC_EXT_OPCODE)\n          {\n            branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);\n\n            if (stack_context_top_p != stack_top_p)\n            {\n               /* Preserve the value of switch statement. */\n              stack_context_top_p[1] = stack_context_top_p[0];\n            }\n\n            stack_context_top_p[0] = VM_CREATE_CONTEXT_WITH_ENV (VM_CONTEXT_BLOCK, branch_offset);\n\n            VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);\n            stack_top_p += PARSER_BLOCK_CONTEXT_STACK_ALLOCATION;\n          }\n          else\n          {\n            JERRY_ASSERT (byte_code_start_p[1] == CBC_EXT_TRY_CREATE_ENV);\n\n            JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_TRY\n                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_CATCH\n                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP\n                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_THROW\n                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);\n\n            JERRY_ASSERT (!(stack_context_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV));\n\n            stack_context_top_p[-1] |= VM_CONTEXT_HAS_LEX_ENV;\n          }\n#else /* !JERRY_ESNEXT */\n          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-2]) == VM_CONTEXT_CATCH\n                        && !(stack_top_p[-2] & VM_CONTEXT_HAS_LEX_ENV));\n\n          stack_top_p[-2] |= VM_CONTEXT_HAS_LEX_ENV;\n#endif /* JERRY_ESNEXT */\n\n          frame_ctx_p->lex_env_p = ecma_create_decl_lex_env (frame_ctx_p->lex_env_p);\n          frame_ctx_p->lex_env_p->type_flags_refs |= ECMA_OBJECT_FLAG_BLOCK;\n\n          continue;\n        }\n        case VM_OC_WITH:\n        {\n          ecma_value_t value = *(--stack_top_p);\n          ecma_object_t *object_p;\n          ecma_object_t *with_env_p;\n\n          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);\n\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n\n          result = ecma_op_to_object (value);\n          ecma_free_value (value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          object_p = ecma_get_object_from_value (result);\n\n          with_env_p = ecma_create_object_lex_env (frame_ctx_p->lex_env_p, object_p);\n          ecma_deref_object (object_p);\n\n          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_WITH_CONTEXT_STACK_ALLOCATION);\n          stack_top_p += PARSER_WITH_CONTEXT_STACK_ALLOCATION;\n\n          stack_top_p[-1] = VM_CREATE_CONTEXT_WITH_ENV (VM_CONTEXT_WITH, branch_offset);\n\n          with_env_p->type_flags_refs |= ECMA_OBJECT_FLAG_BLOCK;\n          frame_ctx_p->lex_env_p = with_env_p;\n          continue;\n        }\n        case VM_OC_FOR_IN_INIT:\n        {\n          ecma_value_t value = *(--stack_top_p);\n\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n\n          ecma_value_t expr_obj_value = ECMA_VALUE_UNDEFINED;\n          ecma_collection_t *prop_names_p = opfunc_for_in (value, &expr_obj_value);\n          ecma_free_value (value);\n\n          if (prop_names_p == NULL)\n          {\n#if JERRY_ESNEXT\n            if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (expr_obj_value)))\n            {\n              result = expr_obj_value;\n              goto error;\n            }\n#endif /* JERRY_ESNEXT */\n\n            /* The collection is already released */\n            byte_code_p = byte_code_start_p + branch_offset;\n            continue;\n          }\n\n          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);\n\n          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION);\n          stack_top_p += PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;\n          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_IN, branch_offset);\n          ECMA_SET_INTERNAL_VALUE_ANY_POINTER (stack_top_p[-2], prop_names_p);\n          stack_top_p[-3] = 0;\n          stack_top_p[-4] = expr_obj_value;\n\n#if JERRY_ESNEXT\n          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)\n          {\n            /* No need to duplicate the first context. */\n            byte_code_p += 2;\n          }\n#endif /* JERRY_ESNEXT */\n          continue;\n        }\n        case VM_OC_FOR_IN_GET_NEXT:\n        {\n          ecma_value_t *context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;\n\n          ecma_collection_t *collection_p;\n          collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, context_top_p[-2]);\n\n          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_IN);\n\n          uint32_t index = context_top_p[-3];\n          ecma_value_t *buffer_p = collection_p->buffer_p;\n\n          *stack_top_p++ = buffer_p[index];\n          context_top_p[-3]++;\n          continue;\n        }\n        case VM_OC_FOR_IN_HAS_NEXT:\n        {\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n\n          ecma_collection_t *collection_p;\n          collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, stack_top_p[-2]);\n\n          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_IN);\n\n          ecma_value_t *buffer_p = collection_p->buffer_p;\n          ecma_object_t *object_p = ecma_get_object_from_value (stack_top_p[-4]);\n          uint32_t index = stack_top_p[-3];\n\n          while (index < collection_p->item_count)\n          {\n            ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (buffer_p[index]);\n\n            result = ecma_op_object_has_property (object_p, prop_name_p);\n\n            if (ECMA_IS_VALUE_ERROR (result))\n            {\n              goto error;\n            }\n\n            if (JERRY_LIKELY (ecma_is_value_true (result)))\n            {\n              byte_code_p = byte_code_start_p + branch_offset;\n              break;\n            }\n\n            ecma_deref_ecma_string (prop_name_p);\n            index++;\n          }\n\n          if (index == collection_p->item_count)\n          {\n            ecma_deref_object (object_p);\n            ecma_collection_destroy (collection_p);\n            VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION);\n            stack_top_p -= PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;\n          }\n          else\n          {\n            stack_top_p[-3] = index;\n          }\n          continue;\n        }\n#if JERRY_ESNEXT\n        case VM_OC_FOR_OF_INIT:\n        {\n          ecma_value_t value = *(--stack_top_p);\n\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n\n          ecma_value_t next_method;\n          ecma_value_t iterator = ecma_op_get_iterator (value, ECMA_VALUE_SYNC_ITERATOR, &next_method);\n\n          ecma_free_value (value);\n\n          if (ECMA_IS_VALUE_ERROR (iterator))\n          {\n            result = iterator;\n            goto error;\n          }\n\n          result = ecma_op_iterator_step (iterator, next_method);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            ecma_free_value (iterator);\n            ecma_free_value (next_method);\n            goto error;\n          }\n\n          if (ecma_is_value_false (result))\n          {\n            ecma_free_value (iterator);\n            ecma_free_value (next_method);\n            byte_code_p = byte_code_start_p + branch_offset;\n            continue;\n          }\n\n          ecma_value_t next_value = ecma_op_iterator_value (result);\n          ecma_free_value (result);\n\n          if (ECMA_IS_VALUE_ERROR (next_value))\n          {\n            result = next_value;\n            ecma_free_value (iterator);\n            ecma_free_value (next_method);\n            goto error;\n          }\n\n          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);\n\n          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);\n          stack_top_p += PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION;\n          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_OF, branch_offset) | VM_CONTEXT_CLOSE_ITERATOR;\n          stack_top_p[-2] = next_value;\n          stack_top_p[-3] = iterator;\n          stack_top_p[-4] = next_method;\n\n          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)\n          {\n            /* No need to duplicate the first context. */\n            byte_code_p += 2;\n          }\n          continue;\n        }\n        case VM_OC_FOR_OF_GET_NEXT:\n        {\n          ecma_value_t *context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;\n          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_OF\n                        || VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_AWAIT_OF);\n          JERRY_ASSERT (context_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR);\n\n          *stack_top_p++ = context_top_p[-2];\n          context_top_p[-2] = ECMA_VALUE_UNDEFINED;\n          continue;\n        }\n        case VM_OC_FOR_OF_HAS_NEXT:\n        {\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_OF);\n          JERRY_ASSERT (stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR);\n\n          stack_top_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;\n          result = ecma_op_iterator_step (stack_top_p[-3], stack_top_p[-4]);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          if (ecma_is_value_false (result))\n          {\n            ecma_free_value (stack_top_p[-2]);\n            ecma_free_value (stack_top_p[-3]);\n            ecma_free_value (stack_top_p[-4]);\n            VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);\n            stack_top_p -= PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION;\n            continue;\n          }\n\n          ecma_value_t next_value = ecma_op_iterator_value (result);\n          ecma_free_value (result);\n\n          if (ECMA_IS_VALUE_ERROR (next_value))\n          {\n            result = next_value;\n            goto error;\n          }\n\n          JERRY_ASSERT (stack_top_p[-2] == ECMA_VALUE_UNDEFINED);\n          stack_top_p[-1] |= VM_CONTEXT_CLOSE_ITERATOR;\n          stack_top_p[-2] = next_value;\n          byte_code_p = byte_code_start_p + branch_offset;\n          continue;\n        }\n        case VM_OC_FOR_AWAIT_OF_INIT:\n        {\n          ecma_value_t value = *(--stack_top_p);\n\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n\n          ecma_value_t next_method;\n          result = ecma_op_get_iterator (value, ECMA_VALUE_ASYNC_ITERATOR, &next_method);\n\n          ecma_free_value (value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          ecma_value_t iterator = result;\n          result = ecma_op_iterator_next (result, next_method, ECMA_VALUE_EMPTY);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            ecma_free_value (iterator);\n            ecma_free_value (next_method);\n            goto error;\n          }\n\n          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);\n\n          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_AWAIT_OF_CONTEXT_STACK_ALLOCATION);\n          stack_top_p += PARSER_FOR_AWAIT_OF_CONTEXT_STACK_ALLOCATION;\n          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_AWAIT_OF, branch_offset);\n          stack_top_p[-2] = ECMA_VALUE_UNDEFINED;\n          stack_top_p[-3] = iterator;\n          stack_top_p[-4] = next_method;\n\n          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)\n          {\n            /* No need to duplicate the first context. */\n            byte_code_p += 2;\n          }\n\n          frame_ctx_p->call_operation = VM_EXEC_RETURN;\n          frame_ctx_p->byte_code_p = byte_code_p;\n          frame_ctx_p->stack_top_p = stack_top_p;\n\n          uint16_t extra_flags = (ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD\n                                  | (ECMA_AWAIT_FOR_NEXT << ECMA_AWAIT_STATE_SHIFT));\n\n          if (CBC_FUNCTION_GET_TYPE (bytecode_header_p->status_flags) == CBC_FUNCTION_ASYNC_GENERATOR\n              || frame_ctx_p->block_result != ECMA_VALUE_UNDEFINED)\n          {\n            ecma_extended_object_t *executable_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);\n            result = ecma_promise_async_await (executable_object_p, result);\n\n            if (ECMA_IS_VALUE_ERROR (result))\n            {\n              goto error;\n            }\n\n            executable_object_p->u.cls.u2.executable_obj_flags |= extra_flags;\n            return ECMA_VALUE_UNDEFINED;\n          }\n\n          result = opfunc_async_create_and_await (frame_ctx_p, result, extra_flags);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n          return result;\n        }\n        case VM_OC_FOR_AWAIT_OF_HAS_NEXT:\n        {\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_AWAIT_OF);\n          JERRY_ASSERT (stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR);\n\n          stack_top_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;\n          result = ecma_op_iterator_next (stack_top_p[-3], stack_top_p[-4], ECMA_VALUE_EMPTY);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          ecma_extended_object_t *executable_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);\n          result = ecma_promise_async_await (executable_object_p, result);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          uint16_t extra_flags = (ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD\n                                 | (ECMA_AWAIT_FOR_NEXT << ECMA_AWAIT_STATE_SHIFT));\n          executable_object_p->u.cls.u2.executable_obj_flags |= extra_flags;\n\n          frame_ctx_p->call_operation = VM_EXEC_RETURN;\n          frame_ctx_p->byte_code_p = byte_code_start_p + branch_offset;\n          frame_ctx_p->stack_top_p = stack_top_p;\n          return ECMA_VALUE_UNDEFINED;\n        }\n#endif /* JERRY_ESNEXT */\n        case VM_OC_TRY:\n        {\n          /* Try opcode simply creates the try context. */\n          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);\n\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n\n          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);\n          stack_top_p += PARSER_TRY_CONTEXT_STACK_ALLOCATION;\n\n          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_TRY, branch_offset);\n          continue;\n        }\n        case VM_OC_CATCH:\n        {\n          /* Catches are ignored and turned to jumps. */\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_TRY);\n\n          byte_code_p = byte_code_start_p + branch_offset;\n          continue;\n        }\n        case VM_OC_FINALLY:\n        {\n          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);\n\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n\n          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_TRY\n                        || VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_CATCH);\n\n          if (stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV)\n          {\n            ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;\n            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);\n            frame_ctx_p->lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);\n            ecma_deref_object (lex_env_p);\n          }\n\n          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FINALLY_CONTEXT_EXTRA_STACK_ALLOCATION);\n          stack_top_p += PARSER_FINALLY_CONTEXT_EXTRA_STACK_ALLOCATION;\n\n          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FINALLY_JUMP, branch_offset);\n          stack_top_p[-2] = (ecma_value_t) branch_offset;\n          continue;\n        }\n        case VM_OC_CONTEXT_END:\n        {\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n          JERRY_ASSERT (!(stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR));\n\n          ecma_value_t context_type = VM_GET_CONTEXT_TYPE (stack_top_p[-1]);\n\n          if (!VM_CONTEXT_IS_FINALLY (context_type))\n          {\n            stack_top_p = vm_stack_context_abort (frame_ctx_p, stack_top_p);\n\n            JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n            continue;\n          }\n\n#if JERRY_ESNEXT\n          if (stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV)\n          {\n            ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;\n            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);\n            frame_ctx_p->lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);\n            ecma_deref_object (lex_env_p);\n          }\n#endif /* JERRY_ESNEXT */\n\n          VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth,\n                              PARSER_FINALLY_CONTEXT_STACK_ALLOCATION);\n          stack_top_p -= PARSER_FINALLY_CONTEXT_STACK_ALLOCATION;\n\n          if (context_type == VM_CONTEXT_FINALLY_RETURN)\n          {\n            result = *stack_top_p;\n            goto error;\n          }\n\n          if (context_type == VM_CONTEXT_FINALLY_THROW)\n          {\n            jcontext_raise_exception (*stack_top_p);\n#if JERRY_VM_THROW\n            JERRY_CONTEXT (status_flags) |= ECMA_STATUS_ERROR_THROWN;\n#endif /* JERRY_VM_THROW */\n            result = ECMA_VALUE_ERROR;\n\n#if JERRY_DEBUGGER\n            JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);\n#endif /* JERRY_DEBUGGER */\n            goto error;\n          }\n\n          JERRY_ASSERT (context_type == VM_CONTEXT_FINALLY_JUMP);\n\n          uint32_t jump_target = *stack_top_p;\n\n          vm_stack_found_type type = vm_stack_find_finally (frame_ctx_p,\n                                                            stack_top_p,\n                                                            VM_CONTEXT_FINALLY_JUMP,\n                                                            jump_target);\n          stack_top_p = frame_ctx_p->stack_top_p;\n          switch (type)\n          {\n            case VM_CONTEXT_FOUND_FINALLY:\n            {\n              byte_code_p = frame_ctx_p->byte_code_p;\n\n              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);\n              stack_top_p[-2] = jump_target;\n              break;\n            }\n#if JERRY_ESNEXT\n            case VM_CONTEXT_FOUND_ERROR:\n            {\n              JERRY_ASSERT (jcontext_has_pending_exception ());\n              result = ECMA_VALUE_ERROR;\n              goto error;\n            }\n            case VM_CONTEXT_FOUND_AWAIT:\n            {\n              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);\n              stack_top_p[-2] = jump_target;\n              return ECMA_VALUE_UNDEFINED;\n            }\n#endif /* JERRY_ESNEXT */\n            default:\n            {\n              byte_code_p = frame_ctx_p->byte_code_start_p + jump_target;\n              break;\n            }\n          }\n\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n          continue;\n        }\n        case VM_OC_JUMP_AND_EXIT_CONTEXT:\n        {\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n          JERRY_ASSERT (!jcontext_has_pending_exception ());\n\n          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);\n\n          vm_stack_found_type type = vm_stack_find_finally (frame_ctx_p,\n                                                            stack_top_p,\n                                                            VM_CONTEXT_FINALLY_JUMP,\n                                                            (uint32_t) branch_offset);\n          stack_top_p = frame_ctx_p->stack_top_p;\n          switch (type)\n          {\n            case VM_CONTEXT_FOUND_FINALLY:\n            {\n              byte_code_p = frame_ctx_p->byte_code_p;\n\n              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);\n              stack_top_p[-2] = (uint32_t) branch_offset;\n              break;\n            }\n#if JERRY_ESNEXT\n            case VM_CONTEXT_FOUND_ERROR:\n            {\n              JERRY_ASSERT (jcontext_has_pending_exception ());\n              result = ECMA_VALUE_ERROR;\n              goto error;\n            }\n            case VM_CONTEXT_FOUND_AWAIT:\n            {\n              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);\n              stack_top_p[-2] = (uint32_t) branch_offset;\n              return ECMA_VALUE_UNDEFINED;\n            }\n#endif /* JERRY_ESNEXT */\n            default:\n            {\n              byte_code_p = frame_ctx_p->byte_code_start_p + branch_offset;\n              break;\n            }\n          }\n\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n          continue;\n        }\n#if JERRY_MODULE_SYSTEM\n        case VM_OC_MODULE_IMPORT:\n        {\n          left_value = *(--stack_top_p);\n\n          ecma_value_t user_value = ECMA_VALUE_UNDEFINED;\n          ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_header_p)->script_value;\n\n#if JERRY_SNAPSHOT_EXEC\n          if (JERRY_UNLIKELY (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))\n          {\n#endif /* JERRY_SNAPSHOT_EXEC */\n            cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);\n\n            if (script_p->refs_and_type & CBC_SCRIPT_HAS_USER_VALUE)\n            {\n              user_value = CBC_SCRIPT_GET_USER_VALUE (script_p);\n            }\n#if JERRY_SNAPSHOT_EXEC\n          }\n#endif /* JERRY_SNAPSHOT_EXEC */\n\n          result = ecma_module_import (left_value, user_value);\n          ecma_free_value (left_value);\n\n          if (ECMA_IS_VALUE_ERROR (result))\n          {\n            goto error;\n          }\n\n          *stack_top_p++ = result;\n          continue;\n        }\n        case VM_OC_MODULE_IMPORT_META:\n        {\n          ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_header_p)->script_value;\n          cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);\n\n          JERRY_ASSERT (script_p->refs_and_type & CBC_SCRIPT_HAS_IMPORT_META);\n\n          ecma_value_t import_meta = CBC_SCRIPT_GET_IMPORT_META (script_p, script_p->refs_and_type);\n          ecma_object_t *import_meta_object_p = ecma_get_object_from_value (import_meta);\n\n          if (ecma_get_object_type (import_meta_object_p) != ECMA_OBJECT_TYPE_GENERAL)\n          {\n            JERRY_ASSERT (ecma_object_class_is (import_meta_object_p, ECMA_OBJECT_CLASS_MODULE));\n\n            ecma_value_t module = import_meta;\n            import_meta_object_p = ecma_create_object (NULL, 0, ECMA_OBJECT_TYPE_GENERAL);\n            import_meta = ecma_make_object_value (import_meta_object_p);\n\n            if (JERRY_CONTEXT (module_import_meta_callback_p) != NULL)\n            {\n              void *user_p = JERRY_CONTEXT (module_import_meta_callback_user_p);\n              JERRY_CONTEXT (module_import_meta_callback_p) (module, import_meta, user_p);\n            }\n\n            CBC_SCRIPT_GET_IMPORT_META (script_p, script_p->refs_and_type) = import_meta;\n          }\n          else\n          {\n            ecma_ref_object (import_meta_object_p);\n          }\n\n          *stack_top_p++ = import_meta;\n          continue;\n        }\n#endif /* JERRY_MODULE_SYSTEM */\n#if JERRY_DEBUGGER\n        case VM_OC_BREAKPOINT_ENABLED:\n        {\n          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_IGNORE)\n          {\n            continue;\n          }\n\n          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);\n\n          JERRY_ASSERT (!(frame_ctx_p->shared_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_DEBUGGER_IGNORE));\n\n          frame_ctx_p->byte_code_p = byte_code_start_p;\n\n          jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);\n          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)\n          {\n            result = ECMA_VALUE_ERROR;\n            goto error;\n          }\n          continue;\n        }\n        case VM_OC_BREAKPOINT_DISABLED:\n        {\n          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_IGNORE)\n          {\n            continue;\n          }\n\n          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);\n\n          JERRY_ASSERT (!(frame_ctx_p->shared_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_DEBUGGER_IGNORE));\n\n          frame_ctx_p->byte_code_p = byte_code_start_p;\n\n          if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP)\n              && (JERRY_CONTEXT (debugger_stop_context) == NULL\n                  || JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p)))\n          {\n            jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);\n            if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)\n            {\n              result = ECMA_VALUE_ERROR;\n              goto error;\n            }\n            continue;\n          }\n\n          if (JERRY_CONTEXT (debugger_message_delay) > 0)\n          {\n            JERRY_CONTEXT (debugger_message_delay)--;\n            continue;\n          }\n\n          JERRY_CONTEXT (debugger_message_delay) = JERRY_DEBUGGER_MESSAGE_FREQUENCY;\n\n          if (jerry_debugger_receive (NULL))\n          {\n            continue;\n          }\n\n          if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP)\n              && (JERRY_CONTEXT (debugger_stop_context) == NULL\n                  || JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p)))\n          {\n            jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);\n            if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)\n            {\n              result = ECMA_VALUE_ERROR;\n              goto error;\n            }\n          }\n          continue;\n        }\n#endif /* JERRY_DEBUGGER */\n        case VM_OC_NONE:\n        default:\n        {\n          JERRY_ASSERT (VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_NONE);\n\n          jerry_fatal (ERR_DISABLED_BYTE_CODE);\n        }\n      }\n\n      JERRY_ASSERT (VM_OC_HAS_PUT_RESULT (opcode_data));\n\n      if (opcode_data & VM_OC_PUT_IDENT)\n      {\n        uint16_t literal_index;\n\n        READ_LITERAL_INDEX (literal_index);\n\n        if (literal_index < register_end)\n        {\n          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));\n          VM_GET_REGISTER (frame_ctx_p, literal_index) = result;\n\n          if (opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK))\n          {\n            result = ecma_fast_copy_value (result);\n          }\n        }\n        else\n        {\n          ecma_string_t *var_name_str_p = ecma_get_string_from_value (literal_start_p[literal_index]);\n\n          ecma_value_t put_value_result = ecma_op_put_value_lex_env_base (frame_ctx_p->lex_env_p,\n                                                                          var_name_str_p,\n                                                                          is_strict,\n                                                                          result);\n\n          if (ECMA_IS_VALUE_ERROR (put_value_result))\n          {\n            ecma_free_value (result);\n            result = put_value_result;\n            goto error;\n          }\n\n          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))\n          {\n            ecma_fast_free_value (result);\n          }\n        }\n      }\n      else if (opcode_data & VM_OC_PUT_REFERENCE)\n      {\n        ecma_value_t property = *(--stack_top_p);\n        ecma_value_t base = *(--stack_top_p);\n\n        if (base == ECMA_VALUE_REGISTER_REF)\n        {\n          property = (ecma_value_t) ecma_get_integer_from_value (property);\n          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, property));\n          VM_GET_REGISTER (frame_ctx_p, property) = result;\n\n          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))\n          {\n            goto free_both_values;\n          }\n          result = ecma_fast_copy_value (result);\n        }\n        else\n        {\n          ecma_value_t set_value_result = vm_op_set_value (base,\n                                                           property,\n                                                           result,\n                                                           is_strict);\n\n          if (ECMA_IS_VALUE_ERROR (set_value_result))\n          {\n            ecma_free_value (result);\n            result = set_value_result;\n            goto error;\n          }\n\n          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))\n          {\n            ecma_fast_free_value (result);\n            goto free_both_values;\n          }\n        }\n      }\n\n      if (opcode_data & VM_OC_PUT_STACK)\n      {\n        *stack_top_p++ = result;\n      }\n      else if (opcode_data & VM_OC_PUT_BLOCK)\n      {\n        ecma_fast_free_value (frame_ctx_p->block_result);\n        frame_ctx_p->block_result = result;\n      }\n\nfree_both_values:\n      ecma_fast_free_value (right_value);\nfree_left_value:\n      ecma_fast_free_value (left_value);\n    }\n\nerror:\n    ecma_fast_free_value (left_value);\n    ecma_fast_free_value (right_value);\n\n    if (ECMA_IS_VALUE_ERROR (result))\n    {\n      JERRY_ASSERT (jcontext_has_pending_exception ());\n      ecma_value_t *stack_bottom_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;\n\n      while (stack_top_p > stack_bottom_p)\n      {\n        ecma_value_t stack_item = *(--stack_top_p);\n#if JERRY_ESNEXT\n        if (stack_item == ECMA_VALUE_RELEASE_LEX_ENV)\n        {\n          opfunc_pop_lexical_environment (frame_ctx_p);\n          continue;\n        }\n#endif /* JERRY_ESNEXT */\n        ecma_fast_free_value (stack_item);\n      }\n\n#if JERRY_VM_THROW\n      if (!(JERRY_CONTEXT (status_flags) & ECMA_STATUS_ERROR_THROWN))\n      {\n        JERRY_CONTEXT (status_flags) |= ECMA_STATUS_ERROR_THROWN;\n\n        jerry_vm_throw_callback_t vm_throw_callback_p = JERRY_CONTEXT (vm_throw_callback_p);\n\n        if (vm_throw_callback_p != NULL)\n        {\n          vm_throw_callback_p (JERRY_CONTEXT (error_value), JERRY_CONTEXT (vm_throw_callback_user_p));\n        }\n      }\n#endif /* JERRY_VM_THROW */\n\n#if JERRY_DEBUGGER\n      const uint32_t dont_stop = (JERRY_DEBUGGER_VM_IGNORE_EXCEPTION\n                                  | JERRY_DEBUGGER_VM_IGNORE\n                                  | JERRY_DEBUGGER_VM_EXCEPTION_THROWN);\n\n      if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n          && !(frame_ctx_p->shared_p->bytecode_header_p->status_flags\n               & (CBC_CODE_FLAGS_DEBUGGER_IGNORE | CBC_CODE_FLAGS_STATIC_FUNCTION))\n          && !(JERRY_CONTEXT (debugger_flags) & dont_stop))\n      {\n        /* Save the error to a local value, because the engine enters breakpoint mode after,\n           therefore an evaluation error, or user-created error throw would overwrite it. */\n        ecma_value_t current_error_value = JERRY_CONTEXT (error_value);\n\n        if (jerry_debugger_send_exception_string (current_error_value))\n        {\n          jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_EXCEPTION_HIT);\n\n          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)\n          {\n            ecma_free_value (current_error_value);\n          }\n          else\n          {\n            JERRY_CONTEXT (error_value) = current_error_value;\n          }\n\n          JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);\n        }\n      }\n#endif /* JERRY_DEBUGGER */\n    }\n\n    JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n\n    if (frame_ctx_p->context_depth == 0)\n    {\n      /* In most cases there is no context. */\n      ecma_fast_free_value (frame_ctx_p->block_result);\n      frame_ctx_p->call_operation = VM_NO_EXEC_OP;\n      return result;\n    }\n\n    if (!ECMA_IS_VALUE_ERROR (result))\n    {\n      switch (vm_stack_find_finally (frame_ctx_p,\n                                     stack_top_p,\n                                     VM_CONTEXT_FINALLY_RETURN,\n                                     0))\n      {\n        case VM_CONTEXT_FOUND_FINALLY:\n        {\n          stack_top_p = frame_ctx_p->stack_top_p;\n          byte_code_p = frame_ctx_p->byte_code_p;\n\n          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n          stack_top_p[-2] = result;\n          continue;\n        }\n#if JERRY_ESNEXT\n        case VM_CONTEXT_FOUND_ERROR:\n        {\n          JERRY_ASSERT (jcontext_has_pending_exception ());\n\n          ecma_free_value (result);\n          stack_top_p = frame_ctx_p->stack_top_p;\n          result = ECMA_VALUE_ERROR;\n          break;\n        }\n        case VM_CONTEXT_FOUND_AWAIT:\n        {\n          stack_top_p = frame_ctx_p->stack_top_p;\n\n          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);\n          stack_top_p[-2] = result;\n          return ECMA_VALUE_UNDEFINED;\n        }\n#endif /* JERRY_ESNEXT */\n        default:\n        {\n          goto finish;\n        }\n      }\n    }\n\n    JERRY_ASSERT (jcontext_has_pending_exception ());\n\n    if (!jcontext_has_pending_abort ())\n    {\n      switch (vm_stack_find_finally (frame_ctx_p,\n                                     stack_top_p,\n                                     VM_CONTEXT_FINALLY_THROW,\n                                     0))\n      {\n        case VM_CONTEXT_FOUND_FINALLY:\n        {\n          stack_top_p = frame_ctx_p->stack_top_p;\n          byte_code_p = frame_ctx_p->byte_code_p;\n\n          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n          JERRY_ASSERT (!(stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV));\n\n#if JERRY_DEBUGGER\n          JERRY_DEBUGGER_CLEAR_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);\n#endif /* JERRY_DEBUGGER */\n\n          result = jcontext_take_exception ();\n\n          if (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_THROW)\n          {\n            stack_top_p[-2] = result;\n            continue;\n          }\n\n          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_CATCH);\n\n          *stack_top_p++ = result;\n          continue;\n        }\n#if JERRY_ESNEXT\n        case VM_CONTEXT_FOUND_AWAIT:\n        {\n          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (frame_ctx_p->stack_top_p[-1]) == VM_CONTEXT_FINALLY_THROW);\n          return ECMA_VALUE_UNDEFINED;\n        }\n#endif /* JERRY_ESNEXT */\n        default:\n        {\n          break;\n        }\n      }\n    }\n    else\n    {\n      do\n      {\n        JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);\n\n        stack_top_p = vm_stack_context_abort (frame_ctx_p, stack_top_p);\n      }\n      while (frame_ctx_p->context_depth > 0);\n    }\n\nfinish:\n    ecma_free_value (frame_ctx_p->block_result);\n    frame_ctx_p->call_operation = VM_NO_EXEC_OP;\n    return result;\n  }\n}",
        "begin_line": 1022,
        "end_line": 4992,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_op_get_value#54",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_op_get_value (ecma_value_t object, /**< base object */                  ecma_value_t property) /**< property name */",
        "snippet": "static ecma_value_t\nvm_op_get_value (ecma_value_t object, /**< base object */\n                 ecma_value_t property) /**< property name */\n{\n  if (ecma_is_value_object (object))\n  {\n    ecma_object_t *object_p = ecma_get_object_from_value (object);\n    ecma_string_t *property_name_p = NULL;\n\n    if (ecma_is_value_integer_number (property))\n    {\n      ecma_integer_value_t int_value = ecma_get_integer_from_value (property);\n\n      if (int_value >= 0 && int_value <= ECMA_DIRECT_STRING_MAX_IMM)\n      {\n        if (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_ARRAY)\n        {\n          ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n          if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)\n                            && (uint32_t) int_value < ext_object_p->u.array.length))\n          {\n            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);\n\n            if (JERRY_LIKELY (!ecma_is_value_array_hole (values_p[int_value])))\n            {\n              return ecma_fast_copy_value (values_p[int_value]);\n            }\n          }\n        }\n\n        property_name_p = (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_UINT,\n                                                                       (uintptr_t) int_value);\n      }\n    }\n    else if (ecma_is_value_string (property))\n    {\n      property_name_p = ecma_get_string_from_value (property);\n    }\n\n#if JERRY_ESNEXT\n    if (ecma_is_value_symbol (property))\n    {\n      property_name_p = ecma_get_symbol_from_value (property);\n    }\n#endif /* JERRY_ESNEXT */\n\n    if (property_name_p != NULL)\n    {\n#if JERRY_LCACHE\n      ecma_property_t *property_p = ecma_lcache_lookup (object_p, property_name_p);\n\n      if (property_p != NULL && (*property_p & ECMA_PROPERTY_FLAG_DATA))\n      {\n        JERRY_ASSERT (!ECMA_PROPERTY_IS_INTERNAL (*property_p));\n        return ecma_fast_copy_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);\n      }\n#endif /* JERRY_LCACHE */\n\n      /* There is no need to free the name. */\n      return ecma_op_object_get (object_p, property_name_p);\n    }\n  }\n\n  if (JERRY_UNLIKELY (ecma_is_value_undefined (object) || ecma_is_value_null (object)))\n  {\n#if JERRY_ERROR_MESSAGES\n    ecma_value_t error_value = ecma_raise_standard_error_with_format (JERRY_ERROR_TYPE,\n                                                                      \"Cannot read property '%' of %\",\n                                                                      property,\n                                                                      object);\n#else /* !JERRY_ERROR_MESSAGES */\n    ecma_value_t error_value = ecma_raise_type_error (NULL);\n#endif /* JERRY_ERROR_MESSAGES */\n    return error_value;\n  }\n\n  ecma_string_t *property_name_p = ecma_op_to_property_key (property);\n\n  if (property_name_p == NULL)\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_value_t get_value_result = ecma_op_get_value_object_base (object, property_name_p);\n\n  ecma_deref_ecma_string (property_name_p);\n  return get_value_result;\n}",
        "begin_line": 54,
        "end_line": 142,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_op_set_value#153",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_op_set_value (ecma_value_t base, /**< base object */                  ecma_value_t property, /**< property name */                  ecma_value_t value, /**< ecma value */                  bool is_strict) /**< strict mode */",
        "snippet": "static ecma_value_t\nvm_op_set_value (ecma_value_t base, /**< base object */\n                 ecma_value_t property, /**< property name */\n                 ecma_value_t value, /**< ecma value */\n                 bool is_strict) /**< strict mode */\n{\n  ecma_value_t result = ECMA_VALUE_EMPTY;\n  ecma_object_t *object_p;\n  ecma_string_t *property_p;\n\n  if (JERRY_UNLIKELY (!ecma_is_value_object (base)))\n  {\n    if (JERRY_UNLIKELY (ecma_is_value_null (base) || ecma_is_value_undefined (base)))\n    {\n#if JERRY_ERROR_MESSAGES\n      result = ecma_raise_standard_error_with_format (JERRY_ERROR_TYPE,\n                                                      \"Cannot set property '%' of %\",\n                                                      property,\n                                                      base);\n#else /* !JERRY_ERROR_MESSAGES */\n      result = ecma_raise_type_error (NULL);\n#endif /* JERRY_ERROR_MESSAGES */\n      ecma_free_value (property);\n      return result;\n    }\n\n    if (JERRY_UNLIKELY (!ecma_is_value_prop_name (property)))\n    {\n      property_p = ecma_op_to_string (property);\n      ecma_fast_free_value (property);\n\n      if (JERRY_UNLIKELY (property_p == NULL))\n      {\n        ecma_free_value (base);\n        return ECMA_VALUE_ERROR;\n      }\n    }\n    else\n    {\n      property_p = ecma_get_prop_name_from_value (property);\n    }\n\n    ecma_value_t object = ecma_op_to_object (base);\n    JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (object));\n\n    object_p = ecma_get_object_from_value (object);\n    ecma_op_ordinary_object_prevent_extensions (object_p);\n\n    result = ecma_op_object_put_with_receiver (object_p,\n                                               property_p,\n                                               value,\n                                               base,\n                                               is_strict);\n\n    ecma_free_value (base);\n  }\n  else\n  {\n    object_p = ecma_get_object_from_value (base);\n\n    if (JERRY_UNLIKELY (!ecma_is_value_prop_name (property)))\n    {\n      property_p = ecma_op_to_string (property);\n      ecma_fast_free_value (property);\n\n      if (JERRY_UNLIKELY (property_p == NULL))\n      {\n        ecma_deref_object (object_p);\n        return ECMA_VALUE_ERROR;\n      }\n    }\n    else\n    {\n      property_p = ecma_get_prop_name_from_value (property);\n    }\n\n    if (!ecma_is_lexical_environment (object_p))\n    {\n      result = ecma_op_object_put_with_receiver (object_p,\n                                                 property_p,\n                                                 value,\n                                                 base,\n                                                 is_strict);\n    }\n    else\n    {\n      result = ecma_op_set_mutable_binding (object_p,\n                                            property_p,\n                                            value,\n                                            is_strict);\n    }\n  }\n\n  ecma_deref_object (object_p);\n  ecma_deref_ecma_string (property_p);\n  return result;\n}",
        "begin_line": 153,
        "end_line": 249,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_run#5339",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_run (vm_frame_ctx_shared_t *shared_p, /**< shared data */         ecma_value_t this_binding_value, /**< value of 'ThisBinding' */         ecma_object_t *lex_env_p) /**< lexical environment to use */",
        "snippet": "ecma_value_t\nvm_run (vm_frame_ctx_shared_t *shared_p, /**< shared data */\n        ecma_value_t this_binding_value, /**< value of 'ThisBinding' */\n        ecma_object_t *lex_env_p) /**< lexical environment to use */\n{\n  const ecma_compiled_code_t *bytecode_header_p = shared_p->bytecode_header_p;\n  vm_frame_ctx_t *frame_ctx_p;\n  size_t frame_size;\n\n  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n  {\n    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;\n    frame_size = (size_t) (args_p->register_end + args_p->stack_limit);\n  }\n  else\n  {\n    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;\n    frame_size = (size_t) (args_p->register_end + args_p->stack_limit);\n  }\n\n  frame_size = frame_size * sizeof (ecma_value_t) + sizeof (vm_frame_ctx_t);\n  frame_size = (frame_size + sizeof (uintptr_t) - 1) / sizeof (uintptr_t);\n\n  /* Use JERRY_MAX() to avoid array declaration with size 0. */\n  JERRY_VLA (uintptr_t, stack, frame_size);\n\n  frame_ctx_p = (vm_frame_ctx_t *) stack;\n\n  frame_ctx_p->shared_p = shared_p;\n  frame_ctx_p->lex_env_p = lex_env_p;\n  frame_ctx_p->this_binding = this_binding_value;\n\n  vm_init_exec (frame_ctx_p);\n  return vm_execute (frame_ctx_p);\n}",
        "begin_line": 5339,
        "end_line": 5373,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_run_global#273",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_run_global (const ecma_compiled_code_t *bytecode_p, /**< pointer to bytecode to run */                ecma_object_t *function_object_p) /**< function object if available */",
        "snippet": "ecma_value_t\nvm_run_global (const ecma_compiled_code_t *bytecode_p, /**< pointer to bytecode to run */\n               ecma_object_t *function_object_p) /**< function object if available */\n{\n#if JERRY_BUILTIN_REALMS\n  ecma_object_t *global_obj_p = (ecma_object_t *) ecma_op_function_get_realm (bytecode_p);\n#else /* !JERRY_BUILTIN_REALMS */\n  ecma_object_t *global_obj_p = ecma_builtin_get_global ();\n#endif /* JERRY_BUILTIN_REALMS */\n\n#if JERRY_ESNEXT\n  if (bytecode_p->status_flags & CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED)\n  {\n    ecma_create_global_lexical_block (global_obj_p);\n  }\n#endif /* JERRY_ESNEXT */\n\n  ecma_object_t *const global_scope_p = ecma_get_global_scope (global_obj_p);\n\n  vm_frame_ctx_shared_t shared;\n  shared.bytecode_header_p = bytecode_p;\n  shared.function_object_p = function_object_p;\n  shared.status_flags = 0;\n\n#if JERRY_BUILTIN_REALMS\n  ecma_value_t this_binding = ((ecma_global_object_t *) global_obj_p)->this_binding;\n\n  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);\n  JERRY_CONTEXT (global_object_p) = (ecma_global_object_t *) global_obj_p;\n#else /* !JERRY_BUILTIN_REALMS */\n  ecma_value_t this_binding = ecma_make_object_value (global_obj_p);\n#endif /* JERRY_BUILTIN_REALMS */\n\n  ecma_value_t result = vm_run (&shared, this_binding, global_scope_p);\n\n#if JERRY_BUILTIN_REALMS\n  JERRY_CONTEXT (global_object_p) = saved_global_object_p;\n#endif /* JERRY_BUILTIN_REALMS */\n\n  return result;\n}",
        "begin_line": 273,
        "end_line": 313,
        "is_bug": false
    }
]