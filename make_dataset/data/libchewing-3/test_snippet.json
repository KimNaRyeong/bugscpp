[
    {
        "name": "test.genkeystroke.drawline#69",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.drawline( int x, int y )",
        "snippet": "void drawline( int x, int y )\n{\n\tmove( x, y );\n\taddstr( FILL_LINE );\n}",
        "begin_line": 69,
        "end_line": 73,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.main#266",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.main( int argc, char *argv[] )",
        "snippet": "int main( int argc, char *argv[] )\n{\n\tChewingContext *ctx;\n\tFILE *fout;\n\tint ch;\n\tint add_phrase_length;\n\n\tif ( argc < 2 ) {\n\t\tfprintf( stderr, \"usage: genkeystroke filename\\n\" );\n\t\texit( 1 );\n\t}\n\telse {\n\t\tfout = fopen( argv[ 1 ], \"w\" );\n\t\tif ( ! fout ) {\n\t\t\tfprintf( stderr, \"Error: failed to open %s\\n\", argv[ 1 ] );\n\t\t\texit( 1 );\n\t\t}\n\t}\n\n\t/* Initialize curses library */\n\tsetlocale(LC_CTYPE, \"\");\n\tinitscr();\n\tif ( has_colors() == TRUE ) {\n\t\tstart_color();\n\t\tinit_pair( 1, COLOR_WHITE, COLOR_BLUE );\n\t\tinit_pair( 2, COLOR_RED, COLOR_YELLOW );\n\t\tinit_pair( 3, COLOR_WHITE, COLOR_RED );\n\t\thasColor = 1;\n\t}\n\tcbreak();\n\tnoecho();\n\tkeypad( stdscr, 1 );\n\tstart_color();\n\tclear();\n\trefresh();\n\n\t/* Initialize libchewing */\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\t/* for the sake of testing, we should not change existing hash data */\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\t/* Request handle to ChewingContext */\n\tctx = chewing_new();\n\n\t/* Set keyboard type */\n\tchewing_set_KBType( ctx, chewing_KBStr2Num( \"KB_DEFAULT\" ) );\n\n\t/* Fill configuration values */\n\tchewing_set_candPerPage( ctx, 9 );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_addPhraseDirection( ctx, 1 );\n\tchewing_set_selKey( ctx, selKey_define, 10 );\n\tchewing_set_spaceAsSelection( ctx, 1 );\n\tchewing_set_autoShiftCur( ctx, 1 );\n\tchewing_set_phraseChoiceRearward( ctx, 1 );\n\n\tclear();\n\tmvaddstr( 0, 0, \"Any key to start testing...\" );\n\n\twhile ( TRUE ) {\n\t\tch = getch();\n\t\tswitch ( ch ) {\n\t\t\tcase KEY_LEFT:\n\t\t\t\tchewing_handle_Left( ctx );\n\t\t\t\tfprintf( fout, \"<L>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_SLEFT:\n\t\t\t\tchewing_handle_ShiftLeft( ctx );\n\t\t\t\tfprintf( fout, \"<SL>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_RIGHT:\n\t\t\t\tchewing_handle_Right( ctx );\n\t\t\t\tfprintf( fout, \"<R>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_SRIGHT:\n\t\t\t\tchewing_handle_ShiftRight( ctx );\n\t\t\t\tfprintf( fout, \"<SR>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_UP:\n\t\t\t\tchewing_handle_Up( ctx );\n\t\t\t\tfprintf( fout, \"<U>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_DOWN:\n\t\t\t\tchewing_handle_Down( ctx );\n\t\t\t\tfprintf( fout, \"<D>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_SPACE:\n\t\t\t\tchewing_handle_Space( ctx );\n\t\t\t\tfprintf( fout, \" \" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_ENTER:\n\t\t\t\tchewing_handle_Enter( ctx );\n\t\t\t\tfprintf( fout, \"<E>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_BACKSPACE:\n\t\t\t\tchewing_handle_Backspace( ctx );\n\t\t\t\tfprintf( fout, \"<B>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_ESC:\n\t\t\t\tchewing_handle_Esc( ctx );\n\t\t\t\tfprintf( fout, \"<EE>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_DC:\n\t\t\t\tchewing_handle_Del( ctx );\n\t\t\t\tfprintf( fout, \"<DC>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_HOME:\n\t\t\t\tchewing_handle_Home( ctx );\n\t\t\t\tfprintf( fout, \"<H>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_END:\n\t\t\t\tchewing_handle_End( ctx );\n\t\t\t\tfprintf( fout, \"<EN>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_TAB:\n\t\t\t\tchewing_handle_Tab( ctx );\n\t\t\t\tfprintf( fout, \"<T>\" );\n\t\t\t\tbreak;\n\t\t\tcase CTRL_0:\n\t\t\tcase CTRL_1:\n\t\t\tcase CTRL_2:\n\t\t\tcase CTRL_3:\n\t\t\tcase CTRL_4:\n\t\t\tcase CTRL_5:\n\t\t\tcase CTRL_6:\n\t\t\tcase CTRL_7:\n\t\t\tcase CTRL_8:\n\t\t\tcase CTRL_9:\n\t\t\t\tadd_phrase_length = ( ch - CTRL_0 + '0' );\n\t\t\t\tchewing_handle_CtrlNum( ctx, add_phrase_length );\n\t\t\t\tfprintf( fout, \"<C%c>\", add_phrase_length );\n\t\t\t\tbreak;\n\t\t\tcase KEY_CTRL_('B'): /* emulate CapsLock */\n\t\t\t\tchewing_handle_Capslock( ctx );\n\t\t\t\tfprintf( fout, \"<CB>\");\n\t\t\t\tbreak;\n\t\t\tcase KEY_CTRL_('D'):\n\t\t\t\tgoto end;\n\t\t\tcase KEY_CTRL_('H'): /* emulate Shift */\n\t\t\t\tif ( chewing_get_ShapeMode( ctx ) == FULLSHAPE_MODE )\n\t\t\t\t\tchewing_set_ShapeMode( ctx, HALFSHAPE_MODE );\n\t\t\t\telse\n\t\t\t\t\tchewing_set_ShapeMode( ctx, FULLSHAPE_MODE );\n\t\t\t\tbreak;\n\t\t\tcase KEY_NPAGE:\n\t\t\t\tchewing_handle_PageDown( ctx );\n\t\t\t\tfprintf( fout, \"<PD>\");\n\t\t\t\tbreak;\n\t\t\tcase KEY_PPAGE:\n\t\t\t\tchewing_handle_PageUp( ctx );\n\t\t\t\tfprintf( fout, \"<PU>\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tchewing_handle_Default( ctx, (char) ch );\n\t\t\t\tif ( ch != '<' && ch != '>' )\n\t\t\t\t\tfprintf( fout, \"%c\", (char) ch );\n\t\t\t\telse\n\t\t\t\t\tfprintf( fout, \"<%c>\", (char) ch );\n\t\t\t\tbreak;\n\t\t}\n\t\tdrawline( 0, 0 );\n\t\tdrawline( 2, 0 );\n\t\tshow_interval_buffer( 3, 0, ctx );\n\t\tdrawline( 4, 0 );\n\t\tshow_choose_buffer( 5, 0, ctx );\n\t\tdrawline( 6, 0 );\n\t\tshow_zuin_buffer( 7, 0, ctx );\n\t\tshow_full_shape( 7, 5, ctx );\n\t\tdrawline( 8, 0 );\n\t\tmvaddstr( 9, 0, \"Ctrl + d : leave\" );\n\t\tmvaddstr( 9, 20, \"Ctrl + b : toggle Eng/Chi mode\" );\n\t\tmvaddstr( 10, 0, \"F1, F2, F3, ..., F9 : Add user defined phrase\");\n\t\tmvaddstr( 11, 0, \"Ctrl + h : toggle Full/Half shape mode\" );\n\t\tshow_commit_string( 12, 0, ctx );\n\t\tshow_userphrase( 7, 12, ctx );\n\t\tshow_edit_buffer( 1, 0, ctx );\n\t}\nend:\n\tendwin();\n\n\t/* Release Chewing context */\n\tchewing_delete( ctx );\n\n\t/* Termate Chewing services */\n\n\tfprintf( fout, \"\\n\" );\n\tfclose( fout );\n\treturn 0;\n}",
        "begin_line": 266,
        "end_line": 454,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.showZuin#145",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.showZuin( ChewingContext *ctx )",
        "snippet": "void showZuin( ChewingContext *ctx )\n{\n\tint zuin_count;\n\tchar *zuin_string;\n\tif ( chewing_get_ChiEngMode( ctx ) )\n\t\taddstr( \"[\u4e2d]\" );\n\telse\n\t\taddstr( \"[\u82f1]\" );\n\taddstr( \"        \" );\n\tzuin_string = chewing_zuin_String( ctx, &zuin_count );\n\taddstr( zuin_string );\n\tfree( zuin_string );\n}\n\nvo",
        "begin_line": 145,
        "end_line": 157,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.show_choose_buffer#204",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.show_choose_buffer( int x, int y, ChewingContext *ctx )",
        "snippet": "void show_choose_buffer( int x, int y, ChewingContext *ctx )\n{\n\tint i = 1;\n\tint currentPageNo;\n\tchar str[ 20 ];\n\tchar *cand_string;\n\tmove( x, y );\n\taddstr( FILL_BLANK );\n\tmove( x, y );\n\n\tif ( chewing_cand_TotalPage( ctx ) == 0 )\n\t\treturn;\n\n\tchewing_cand_Enumerate( ctx );\n\twhile ( chewing_cand_hasNext( ctx ) ) {\n\t\tif ( i > chewing_cand_ChoicePerPage( ctx ) )\n\t\t\tbreak;\n\t\tsprintf( str, \"%d.\", i );\n\t\tif ( hasColor )\n\t\t\tattron( COLOR_PAIR( 3 ) );\n\t\taddstr( str );\n\t\tif ( hasColor )\n\t\t\tattroff( COLOR_PAIR( 3 ) );\n\t\tcand_string = chewing_cand_String( ctx );\n\t\tsprintf( str, \" %s \", cand_string );\n\t\taddstr( str );\n\t\tfree( cand_string );\n\t\ti++;\n\t}\n\tcurrentPageNo = chewing_cand_CurrentPage( ctx );\n\tif ( chewing_cand_TotalPage( ctx ) != 1 ) {\n\t\tif ( currentPageNo == 0 )\n\t\t\taddstr( \"  >\" );\n\t\telse if ( currentPageNo == ( chewing_cand_TotalPage( ctx ) - 1 ) )\n\t\t\taddstr( \"<  \" );\n\t\telse\n\t\t\taddstr( \"< >\" );\n\t}\n}",
        "begin_line": 204,
        "end_line": 242,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.show_commit_string#244",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.show_commit_string( int x, int y, ChewingContext *ctx )",
        "snippet": "void show_commit_string( int x, int y, ChewingContext *ctx )\n{\n\tchar *commit_string;\n#if 0\n\tif ( pgo->keystrokeRtn & KEYSTROKE_COMMIT ) {\n\t\tfor ( i = 0; i < pgo->CommitBufLen; i++ ) {\n\t\t\tmvaddstr( x, y, (const char *) pgo->commitStr[ i ].s );\n\t\t\ty = ( y >= 54 ) ?\n\t\t\t\t0 :\n\t\t\t\t( y + strlen( (const char *) pgo->commitStr[ i ].s ) - 3 < 0 ? y + 1 : y + 2 );\n\t\t\tx = ( y == 0 ) ? ( x + 1 ) : x;\n\t\t}\n\t}\n#endif\n\tif ( chewing_commit_Check( ctx ) ) {\n\t\tcommit_string = chewing_commit_String( ctx );\n\t\tmvaddstr( x, y, FILL_BLANK);\n\t\tmvaddstr( x, y, commit_string );\n\t\tfree( commit_string );\n\t}\n}",
        "begin_line": 244,
        "end_line": 264,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.show_edit_buffer#75",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.show_edit_buffer( int x, int y, ChewingContext *ctx )",
        "snippet": "void show_edit_buffer( int x, int y, ChewingContext *ctx )\n{\n\tint i, cursor, count;\n\tchar *buffer_string;\n\tchar *p;\n\tmove( x, y );\n\taddstr( FILL_BLANK );\n\tif ( ! chewing_buffer_Check( ctx ) ) {\n\t\tmove( x, y );\n\t\treturn;\n\t}\n\tbuffer_string = chewing_buffer_String( ctx );\n\tmvaddstr( x, y, buffer_string );\n\tcursor = chewing_cursor_Current( ctx );\n\tp = buffer_string;\n\tcount = 0;\n\tfor ( i = 0 ;i < cursor; i++ ) {\n\t\tcount += ueBytesFromChar(*p) <= 1 ? 1 : 2;\n\t\tp += ueBytesFromChar(*p);\n\t}\n\tmove( x, count );\n\tfree( buffer_string );\n}",
        "begin_line": 75,
        "end_line": 97,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.show_full_shape#171",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.show_full_shape( int x, int y, ChewingContext *ctx )",
        "snippet": "void show_full_shape( int x, int y, ChewingContext *ctx )\n{\n\tmove( x, y );\n\taddstr( \"[\" );\n\tif ( hasColor )\n\t\tattron( COLOR_PAIR( 2 ) );\n\tif ( chewing_get_ShapeMode( ctx ) == FULLSHAPE_MODE )\n\t\taddstr( \"\u5168\u5f62\" );\n\telse\n\t\taddstr( \"\u534a\u5f62\" );\n\tif ( hasColor )\n\t\tattroff( COLOR_PAIR( 2 ) );\n\taddstr( \"]\" );\n}\n\nvoid s",
        "begin_line": 171,
        "end_line": 184,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.show_interval_buffer#99",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.show_interval_buffer( int x, int y, ChewingContext *ctx )",
        "snippet": "void show_interval_buffer( int x, int y, ChewingContext *ctx )\n{\n\tchar *buf;\n\tchar *p;\n\tint buf_len;\n\tchar out_buf[ 100 ];\n\tint i, count;\n\tint arrPos[ 50 ];\n\tIntervalType it;\n\n\tmove( x, y );\n\taddstr( FILL_BLANK );\n\tmove( x, y );\n\n\t/* Check if buffer is available. */\n\tif ( ! chewing_buffer_Check( ctx ) ) {\n\t\treturn;\n\t}\n\n\tbuf = chewing_buffer_String( ctx );\n\tbuf_len = chewing_buffer_Len( ctx );\n\n\tp = buf;\n\tcount = 0;\n\tfor ( i = 0 ;i < buf_len; i++ ) {\n\t\tarrPos[ i ] = count;\n\t\tcount += ueBytesFromChar(*p) <= 1 ? 1 : 2;\n\t\tp += ueBytesFromChar(*p);\n\t}\n\tarrPos[ i ] = count;\n\n\tmemset( out_buf, ' ', count * ( sizeof( char ) ) );\n\tout_buf[ count ] = '\\0';\n\n\tchewing_interval_Enumerate( ctx );\n\twhile ( chewing_interval_hasNext( ctx ) ) {\n\t\tchewing_interval_Get( ctx, &it );\n\t\tout_buf[ arrPos[ it.from ] ] = '[';\n\t\tout_buf[ arrPos[ it.to ] - 1 ] =  ']';\n\t\tmemset(\n\t\t\t&out_buf[ arrPos[ it.from ] + 1 ], '-',\n\t\t\tarrPos[ it.to ] - arrPos[ it.from ] - 2 );\n\t}\n\taddstr( out_buf );\n}",
        "begin_line": 99,
        "end_line": 143,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.show_userphrase#186",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.show_userphrase( int x, int y, ChewingContext *ctx )",
        "snippet": "void show_userphrase( int x, int y, ChewingContext *ctx )\n{\n\tchar *aux_string;\n\tif ( chewing_aux_Length( ctx ) == 0 )\n\t\treturn;\n\n\tmove( x, y );\n\taddstr( FILL_BLANK );\n\tmove( x, y );\n\tif ( hasColor )\n\t\tattron( COLOR_PAIR( 2 ) );\n\taux_string = chewing_aux_String( ctx );\n\taddstr( aux_string );\n\tfree( aux_string );\n\tif ( hasColor )\n\t\tattroff( COLOR_PAIR( 2 ) );\n}",
        "begin_line": 186,
        "end_line": 202,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.show_zuin_buffer#159",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.show_zuin_buffer( int x, int y, ChewingContext *ctx )",
        "snippet": "void show_zuin_buffer( int x, int y, ChewingContext *ctx )\n{\n\tmove( x, y );\n\taddstr( FILL_BLANK );\n\tmove( x, y );\n\tif ( hasColor )\n\t\tattron( COLOR_PAIR( 1 ) );\n\tshowZuin( ctx );\n\tif ( hasColor )\n\t\tattroff( COLOR_PAIR( 1 ) );\n}",
        "begin_line": 159,
        "end_line": 169,
        "is_bug": false
    },
    {
        "name": "test.performance.main#15",
        "src_path": "test/performance.c",
        "class_name": "test.performance",
        "signature": "test.performance.main()",
        "snippet": "int main()\n{\n\tChewingContext *ctx;\n\tint ch;\n\n\t/* Initialize libchewing */\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\t/* for the sake of testing, we should not change existing hash data */\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\tctx = chewing_new();\n\n\twhile ( ( ch = getchar() ) != EOF ) {\n\t\tchewing_handle_Default( ctx, ch );\n\t}\n\n\tchewing_delete( ctx );\n\treturn 0;\n}",
        "begin_line": 15,
        "end_line": 33,
        "is_bug": false
    },
    {
        "name": "test.randkeystroke.main#51",
        "src_path": "test/randkeystroke.c",
        "class_name": "test.randkeystroke",
        "signature": "test.randkeystroke.main( int argc, char *argv[] )",
        "snippet": "int main( int argc, char *argv[] )\n{\n\tint nk = 100;\n\tint total_random = 0;\n\tint i, n;\n\tint n_tab1 = strlen(zhuin_tab[0]);\n\tint n_tab2 = strlen(zhuin_tab[1]);\n\tint n_tab3 = strlen(zhuin_tab[2]);\n\tint n_tab4 = strlen(zhuin_tab[3]);\n\n\tsrand( time( NULL ) );\n\n\tfor ( i = 1; i < argc; i++ ) {\n\t\tif ( ! strcmp( argv[i], \"-n\" ) ) {\n\t\t\tif ( ++i < argc )\n\t\t\t\tnk = atoi( argv[i] );\n\t\t} else if ( ! strcmp( argv[i], \"-r\" ) ) {\n\t\t\ttotal_random = 1;\n\t\t} else if ( ! strcmp( argv[i], \"-s\" ) ) {\n\t\t    \tif ( ++i < argc )\n\t\t\t    \tsrand( atoi( argv[i] ) );\n\t\t} else if ( ! strcmp( argv[i], \"-h\" ) ) {\n\t\t\tusage();\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (total_random) {\n\t\tfor ( i = 0; i < nk; i++ ) {\n\t\t\tn = rand() % (n_nkeys + n_okeys);\n\t\t\tif ( n >= n_nkeys )\n\t\t\t\tprintf( \"%s\", other_keys[n - n_nkeys] );\n\t\t\telse\n\t\t\t\tprintf( \"%c\", normal_keys[n] );\n\t\t}\n\t} else {\n\t\tfor ( i = 0; i < nk; i++ ) {\n\t\t\tif ( rand() % 2 )\n\t\t\t\tprintf( \"%c\", zhuin_tab[0][ rand() % n_tab1 ] );\n\t\t\tif ( rand() % 2 )\n\t\t\t\tprintf( \"%c\", zhuin_tab[1][ rand() % n_tab2 ] );\n\t\t\tif ( rand() % 2 )\n\t\t\t\tprintf( \"%c\", zhuin_tab[2][ rand() % n_tab3 ] );\n\t\t\tif ( rand() % 2 )\n\t\t\t\tprintf( \"%c\", zhuin_tab[3][ rand() % n_tab4 ] );\n\t\t\telse\n\t\t\t\tprintf( \" \" );\n\t\t\tif ( rand() % 2 )\n\t\t\t\tprintf( \"<E>\" );\n\t\t}\n\t}\n\tprintf( \"\\n\" );\n\n\treturn 0;\n}",
        "begin_line": 51,
        "end_line": 104,
        "is_bug": false
    },
    {
        "name": "test.randkeystroke.usage#42",
        "src_path": "test/randkeystroke.c",
        "class_name": "test.randkeystroke",
        "signature": "test.randkeystroke.usage()",
        "snippet": "void usage()\n{\n\tprintf( \"usage: randkeystroke [-r] [-n num] [-h]\\n\" \\\n\t\t\"\\t -r     - total random\\n\" \\\n\t\t\"\\t -n num - generate num keystrokes\\n\"\n\t\t\"\\t -s seed - random seed\\n\"\n\t\t\"\\t -h     - help\\n\" );\n}",
        "begin_line": 42,
        "end_line": 49,
        "is_bug": false
    },
    {
        "name": "test.simulate.chewing_test_Main#83",
        "src_path": "test/simulate.c",
        "class_name": "test.simulate",
        "signature": "test.simulate.chewing_test_Main() #else int main() #endif",
        "snippet": "int chewing_test_Main()\n#else\nint main()\n#endif\n{\n\tChewingContext *ctx;\n\tint i;\n\n\t/* Initialize libchewing */\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\t/* for the sake of testing, we should not change existing hash data */\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\t/* Request handle to ChewingContext */\n\tctx = chewing_new();\n\n\t/* Set keyboard type */\n\tchewing_set_KBType( ctx, chewing_KBStr2Num( \"KB_DEFAULT\" ) );\n\n\tchewing_set_candPerPage( ctx, 9 );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_addPhraseDirection( ctx, 1 );\n\tchewing_set_selKey( ctx, selKey_define, 10 );\n\tchewing_set_spaceAsSelection( ctx, 1 );\n\n\twhile ( 1 ) {\n\t\ti = get_keystroke( get_char, NULL );\n\t\tif ( i == END )\n\t\t\tgoto end;\n                type_single_keystroke( ctx, i );\n\t\tcommit_string( ctx );\n#ifdef USED_IN_SIMULATION\n\t\tif ( i == KEY_ENTER )\n\t\t\tcompare_per_run();\n#endif\n\t}\nend:\n\t/* Free Chewing IM handle */\n\tchewing_delete( ctx );\n\n\t/* Termate Chewing services */\n#ifndef USED_IN_SIMULATION\n\tprintf( \"\\n\" );\n#endif\n\treturn 0;\n}",
        "begin_line": 83,
        "end_line": 128,
        "is_bug": false
    },
    {
        "name": "test.simulate.commit_string#39",
        "src_path": "test/simulate.c",
        "class_name": "test.simulate",
        "signature": "test.simulate.commit_string( ChewingContext *ctx )",
        "snippet": "void commit_string( ChewingContext *ctx )\n{\n\tchar *s;\n\tif ( chewing_commit_Check( ctx ) ) {\n\t\ts = chewing_commit_String( ctx );\n#ifdef USED_IN_SIMULATION\n\t\tstrcat( commit_string_buf, s );\n#else\n\t\tprintf( \"%s\", s );\n#endif\n\t\tfree( s );\n\t}\n}",
        "begin_line": 39,
        "end_line": 51,
        "is_bug": false
    },
    {
        "name": "test.simulate.compare_per_run#54",
        "src_path": "test/simulate.c",
        "class_name": "test.simulate",
        "signature": "test.simulate.compare_per_run()",
        "snippet": "void compare_per_run()\n{\n\tint i, len;\n\tchar utf8buf_expect[16];\n\tchar utf8buf_commit[16];\n\tprintf( \"Expected:  %s\", expect_string_buf );\n\tprintf( \"Committed: \");\n\n\ttested_word_count += (len = ueStrLen( expect_string_buf ) - 1);\n\t\t/* omit the suffix character */\n\tfor ( i = 0; i < len; i++ ) {\n\t\tueStrNCpy( utf8buf_expect,\n\t\t           ueStrSeek( expect_string_buf, i ),\n\t\t\t   1, STRNCPY_CLOSE );\n\t\tueStrNCpy( utf8buf_commit,\n\t\t           ueStrSeek( commit_string_buf, i ),\n\t\t\t   1, STRNCPY_CLOSE );\n\t\tif ( ! strcmp( utf8buf_expect, utf8buf_commit ) )\n\t\t\tprintf( \"%s\", utf8buf_commit );\n\t\telse {\n\t\t\tprintf( \"\\033[44;37m%s\\033[m\", utf8buf_commit );\n\t\t\tfailed_word_count++;\n\t\t}\n\t}\n\tmemset( commit_string_buf, 0, MAXLEN );\n\tprintf( \"\\n\\n\" );\n}",
        "begin_line": 54,
        "end_line": 80,
        "is_bug": false
    },
    {
        "name": "test.simulate.fake_getchar#41",
        "src_path": "test/simulate.c",
        "class_name": "test.simulate",
        "signature": "test.simulate.fake_getchar()",
        "snippet": "int fake_getchar()\n{\n\tstatic int remainder = 0;\n\tstatic int idx = 0;\n\tchar *pos;\n\n\tif ( feof( fp ) )\n\t\treturn EOF;\n\n\tif ( remainder == 0 ) {\nstart:\n\t\tif ( fgets( linebuf, MAXLEN, fp ) == NULL )\n\t\t\treturn EOF;\n\t\tif ( linebuf[ 0 ] == '#' || linebuf[ 0 ] == ' ' )\n\t\t\tgoto start;\n\n\t\tpos = strstr( linebuf, \"<E>\" );\n\t\tif ( ! pos )\n\t\t\treturn EOF;\n\t\t*(pos + 3) = '\\0';\n\t\tremainder = pos - linebuf + 3;\n\t\tidx = 0;\n\n\t\tpos += 4;\n\t\twhile ( *pos == '\\t' || *pos == ' ' )\n\t\t\tpos++;\n\t\tstrcpy( expect_string_buf, pos );\n\t}\n\tremainder--;\n\treturn linebuf[ idx++ ];\n}",
        "begin_line": 41,
        "end_line": 71,
        "is_bug": false
    },
    {
        "name": "test.simulate.fini_sim#32",
        "src_path": "test/simulate.c",
        "class_name": "test.simulate",
        "signature": "test.simulate.fini_sim()",
        "snippet": "int fini_sim()\n{\n\tif ( fp )\n\t\tfclose( fp );\n\tfflush( stdout );\n\treturn 0;\n}",
        "begin_line": 32,
        "end_line": 38,
        "is_bug": false
    },
    {
        "name": "test.simulate.get_char#31",
        "src_path": "test/simulate.c",
        "class_name": "test.simulate",
        "signature": "test.simulate.get_char( void *param UNUSED )",
        "snippet": "static int get_char( void *param UNUSED )\n{\n\tint ch = getchar();\n\tif ( ch == EOF )\n\t\treturn END;\n\treturn ch;\n}",
        "begin_line": 31,
        "end_line": 37,
        "is_bug": false
    },
    {
        "name": "test.simulate.init_sim#23",
        "src_path": "test/simulate.c",
        "class_name": "test.simulate",
        "signature": "test.simulate.init_sim()",
        "snippet": "int init_sim()\n{\n\tif ( 0 == access( FN_MATERIALS \"-random\", R_OK ))\n\t\tfp = fopen( FN_MATERIALS \"-random\", \"r\" );\n\telse\n\t\tfp = fopen( FN_MATERIALS, \"r\" );\n\treturn (fp != NULL);\n}",
        "begin_line": 23,
        "end_line": 30,
        "is_bug": false
    },
    {
        "name": "test.simulate.main#73",
        "src_path": "test/simulate.c",
        "class_name": "test.simulate",
        "signature": "test.simulate.main()",
        "snippet": "int main()\n{\n\tif ( ! init_sim() )\n\t\treturn 1;\n\n\tchewing_test_Main();\n\n\t{\n\t\tprintf(\n\"_________________________________________________________________________\\n\"\n\t\t        \"[ Report ]\\n\");\n\t\tprintf( \"Checks: %d words,  Failures: %d words\\n\",\n\t\t        tested_word_count, failed_word_count );\n\t\tprintf( \"Ratio: %.2f%%\\n\",\n\t\t        (float) (tested_word_count - failed_word_count ) /\n\t\t\t        tested_word_count * 100 );\n\t}\n\n\tfini_sim();\n\treturn 0;\n}",
        "begin_line": 73,
        "end_line": 93,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.main#1051",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n\tchar *logname;\n\tint ret;\n\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\tret = asprintf( &logname, \"%s.log\", argv[0] );\n\tif ( ret == -1 ) return -1;\n\tfd = fopen( logname, \"w\" );\n\tassert( fd );\n\tfree( logname );\n\n\n\ttest_select_candidate();\n\ttest_Esc();\n\ttest_Del();\n\ttest_Backspace();\n\ttest_Up();\n\ttest_Down();\n\ttest_Tab();\n\ttest_DblTab();\n\ttest_Capslock();\n\ttest_Home();\n\ttest_End();\n\ttest_PageUp();\n\ttest_PageDown();\n\ttest_ShiftSpace();\n\ttest_Numlock();\n\ttest_Space();\n\n\ttest_get_phoneSeq();\n\ttest_zuin_buffer();\n\n\ttest_longest_phrase();\n\ttest_auto_commit();\n\n\tfclose( fd );\n\n\treturn exit_status();\n}",
        "begin_line": 1051,
        "end_line": 1092,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Backspace#521",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Backspace()",
        "snippet": "void test_Backspace()\n{\n\ttest_Backspace_not_entering_chewing();\n\ttest_Backspace_in_select();\n\ttest_Backspace_remove_bopomofo();\n\ttest_Backspace_word();\n}",
        "begin_line": 521,
        "end_line": 527,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Backspace_in_select#483",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Backspace_in_select()",
        "snippet": "void test_Backspace_in_select()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\ttype_keystroke_by_string( ctx, \"`<B>\" );\n\tok_keystroke_rtn( ctx, KEYSTROKE_ABSORB ); /* XXX: shall be ignore? */\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 483,
        "end_line": 493,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Backspace_not_entering_chewing#471",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Backspace_not_entering_chewing()",
        "snippet": "void test_Backspace_not_entering_chewing()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\ttype_keystroke_by_string( ctx, \"<B>\" );\n\tok_keystroke_rtn( ctx, KEYSTROKE_IGNORE );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 471,
        "end_line": 481,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Backspace_remove_bopomofo#495",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Backspace_remove_bopomofo()",
        "snippet": "void test_Backspace_remove_bopomofo()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\ttype_keystroke_by_string( ctx, \"hk<B>\" );\n\tok_zuin_buffer( ctx, \"\\xE3\\x84\\x98\" /* \u3118 */ );\n\n\tchewing_delete( ctx );\n}\n\n",
        "begin_line": 495,
        "end_line": 505,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Backspace_word#507",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Backspace_word()",
        "snippet": "void test_Backspace_word()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\ttype_keystroke_by_string( ctx, \"hk4u g4<L><B><E>\" );\n\tok_commit_buffer( ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ );\n\n\tchewing_delete( ctx );\n}\n\nvo",
        "begin_line": 507,
        "end_line": 519,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Capslock#719",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Capslock()",
        "snippet": "void test_Capslock()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"<CB>\" );\n\tok( chewing_get_ChiEngMode( ctx ) == SYMBOL_MODE,\n\t\t\"mode shall change to SYMBOL_MODE\" );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 719,
        "end_line": 731,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_DblTab#714",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_DblTab()",
        "snippet": "void test_DblTab()\n{\n\t/* FIXME: Implement this. */\n}",
        "begin_line": 714,
        "end_line": 717,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Del#464",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Del()",
        "snippet": "void test_Del()\n{\n\ttest_Del_not_entering_chewing();\n\ttest_Del_in_select();\n\ttest_Del_word();\n}",
        "begin_line": 464,
        "end_line": 469,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Del_in_select#438",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Del_in_select()",
        "snippet": "void test_Del_in_select()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\ttype_keystroke_by_string( ctx, \"`<DC>\" );\n\tok_keystroke_rtn( ctx, KEYSTROKE_ABSORB ); /* XXX: shall be ignore? */\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 438,
        "end_line": 448,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Del_not_entering_chewing#426",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Del_not_entering_chewing()",
        "snippet": "void test_Del_not_entering_chewing()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\ttype_keystroke_by_string( ctx, \"<DC>\" );\n\tok_keystroke_rtn( ctx, KEYSTROKE_IGNORE );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 426,
        "end_line": 436,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Del_word#450",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Del_word()",
        "snippet": "void test_Del_word()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\ttype_keystroke_by_string( ctx, \"hk4u g4<L><L><DC><E>\" );\n\tok_commit_buffer( ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ );\n\n\tchewing_delete( ctx );\n}\n\nvo",
        "begin_line": 450,
        "end_line": 462,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Down#606",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Down()",
        "snippet": "void test_Down()\n{\n\ttest_Down_open_candidate_window();\n\ttest_Down_not_entering_chewing();\n}",
        "begin_line": 606,
        "end_line": 610,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Down_not_entering_chewing#594",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Down_not_entering_chewing()",
        "snippet": "void test_Down_not_entering_chewing()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\ttype_keystroke_by_string( ctx, \"<D>\" );\n\tok_keystroke_rtn( ctx, KEYSTROKE_IGNORE );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 594,
        "end_line": 604,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Down_open_candidate_window#570",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Down_open_candidate_window()",
        "snippet": "void test_Down_open_candidate_window()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"hk4\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be `%d'\", ret, 0 );\n\n\ttype_keystroke_by_string( ctx, \"<D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0 );\n\n\ttype_keystroke_by_string( ctx, \"3\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be `%d'\", ret, 0 );\n\tok_preedit_buffer( ctx, \"\\xE6\\xB8\\xAC\" /* \u6e2c */ );\n\n\tchewing_delete( ctx );\n}\n\n",
        "begin_line": 570,
        "end_line": 592,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_End#753",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_End()",
        "snippet": "void test_End()\n{\n\tChewingContext *ctx;\n\tint cursor;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4<L><L>\" );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 0, \"cursor `%d' shall be 0\", cursor );\n\n\ttype_keystroke_by_string( ctx, \"<EN>\" );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 2, \"cursor `%d' shall be 2\", cursor );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 753,
        "end_line": 771,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Esc#418",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Esc()",
        "snippet": "void test_Esc()\n{\n\ttest_Esc_not_entering_chewing();\n\ttest_Esc_in_select();\n\ttest_Esc_entering_zuin();\n\t/* XXX: Test escCleanAllBuf here */\n}",
        "begin_line": 418,
        "end_line": 424,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Esc_entering_zuin#406",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Esc_entering_zuin()",
        "snippet": "void test_Esc_entering_zuin()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\ttype_keystroke_by_string( ctx, \"hk<EE>\" );\n\tok_zuin_buffer( ctx, \"\" );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 406,
        "end_line": 416,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Esc_in_select#394",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Esc_in_select()",
        "snippet": "void test_Esc_in_select()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\ttype_keystroke_by_string( ctx, \"`<EE>\" );\n\tok_candidate( ctx, NULL, 0 );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 394,
        "end_line": 404,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Esc_not_entering_chewing#382",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Esc_not_entering_chewing()",
        "snippet": "void test_Esc_not_entering_chewing()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\ttype_keystroke_by_string( ctx, \"<EE>\" );\n\tok_keystroke_rtn( ctx, KEYSTROKE_IGNORE );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 382,
        "end_line": 392,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Home#733",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Home()",
        "snippet": "void test_Home()\n{\n\tChewingContext *ctx;\n\tint cursor;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4\" );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 2, \"cursor `%d' shall be 2\", cursor );\n\n\ttype_keystroke_by_string( ctx, \"<H>\" );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 0, \"cursor `%d' shall be 0\", cursor );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 733,
        "end_line": 751,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Numlock#881",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Numlock()",
        "snippet": "void test_Numlock()\n{\n\ttest_Numlock_numeric_input();\n\ttest_Numlock_select_candidate();\n}",
        "begin_line": 881,
        "end_line": 885,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Numlock_numeric_input#818",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Numlock_numeric_input()",
        "snippet": "void test_Numlock_numeric_input()\n{\n\tconst TestData NUMLOCK_INPUT[] = {\n\t\t{ \"<N0>\", \"0\" },\n\t\t{ \"<N1>\", \"1\" },\n\t\t{ \"<N2>\", \"2\" },\n\t\t{ \"<N3>\", \"3\" },\n\t\t{ \"<N4>\", \"4\" },\n\t\t{ \"<N5>\", \"5\" },\n\t\t{ \"<N6>\", \"6\" },\n\t\t{ \"<N7>\", \"7\" },\n\t\t{ \"<N8>\", \"8\" },\n\t\t{ \"<N9>\", \"9\" },\n\t\t{ \"<N+>\", \"+\" },\n\t\t{ \"<N->\", \"-\" },\n\t\t{ \"<N*>\", \"*\" },\n\t\t{ \"<N/>\", \"/\" },\n\t\t{ \"<N.>\", \".\" },\n\t};\n\tsize_t i;\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\tfor ( i = 0; i < ARRAY_SIZE( NUMLOCK_INPUT ); ++i ) {\n\t\ttype_keystroke_by_string( ctx, NUMLOCK_INPUT[i].token );\n\t\tok_commit_buffer( ctx, NUMLOCK_INPUT[i].expected );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 818,
        "end_line": 850,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Numlock_select_candidate#852",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Numlock_select_candidate()",
        "snippet": "void test_Numlock_select_candidate()\n{\n\tconst TestData NUMLOCK_SELECT[] = {\n\t\t{ \"hk4<D><N1><E>\", \"\\xE5\\x86\\x8A\" /* \u518a */ },\n\t\t{ \"hk4<D><N2><E>\", \"\\xE7\\xAD\\x96\" /* \u7b56 */ },\n\t\t{ \"hk4<D><N3><E>\", \"\\xE6\\xB8\\xAC\" /* \u6e2c */ },\n\t\t{ \"hk4<D><N4><E>\", \"\\xE5\\x81\\xB4\" /* \u5074 */ },\n\t\t{ \"hk4<D><N5><E>\", \"\\xE5\\xBB\\x81\" /* \u5ec1 */ },\n\t\t{ \"hk4<D><N6><E>\", \"\\xE6\\x83\\xBB\" /* \u60fb */ },\n\t\t{ \"hk4<D><N7><E>\", \"\\xE7\\xAD\\xB4\" /* \u7b74 */ },\n\t\t{ \"hk4<D><N8><E>\", \"\\xE7\\x95\\x9F\" /* \u755f */ },\n\t\t{ \"hk4<D><N9><E>\", \"\\xE8\\x8C\\xA6\" /* \u8326 */ },\n\t\t{ \"hk4<D><N0><E>\", \"\\xE7\\xB2\\xA3\" /* \u7ca3 */ },\n\t};\n\tsize_t i;\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\tfor ( i = 0; i < ARRAY_SIZE( NUMLOCK_SELECT ); ++i ) {\n\t\ttype_keystroke_by_string( ctx, NUMLOCK_SELECT[ i ].token );\n\t\tok_commit_buffer( ctx, NUMLOCK_SELECT[i].expected );\n\t}\n\n\tchewing_delete( ctx );\n}\n\nvoid test_Numlock(",
        "begin_line": 852,
        "end_line": 879,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_PageDown#793",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_PageDown()",
        "snippet": "void test_PageDown()\n{\n\tChewingContext *ctx;\n\tint cursor;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4<L><L>\" );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 0, \"cursor `%d' shall be 0\", cursor );\n\n\ttype_keystroke_by_string( ctx, \"<PD>\" );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 2, \"cursor `%d' shall be 2\", cursor );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 793,
        "end_line": 811,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_PageUp#773",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_PageUp()",
        "snippet": "void test_PageUp()\n{\n\tChewingContext *ctx;\n\tint cursor;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4<L><L>\" );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 0, \"cursor `%d' shall be 0\", cursor );\n\n\ttype_keystroke_by_string( ctx, \"<PU>\" );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 2, \"cursor `%d' shall be 2\", cursor );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 773,
        "end_line": 791,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_ShiftSpace#813",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_ShiftSpace()",
        "snippet": "void test_ShiftSpace()\n{\n\t/* FIXME: Implement this. */\n}",
        "begin_line": 813,
        "end_line": 816,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Space#920",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Space()",
        "snippet": "void test_Space()\n{\n\ttest_Space_selection();\n}",
        "begin_line": 920,
        "end_line": 923,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Space_selection#887",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Space_selection()",
        "snippet": "void test_Space_selection()\n{\n\tChewingContext *ctx;\n\tchar *buf;\n\tint len;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_spaceAsSelection( ctx, 1 );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4<H>\" /* \u6e2c\u8a66 */ );\n\n\ttype_keystroke_by_string( ctx, \" \" );\n\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen(buf);\n\tok( len == 2, \"candidate `%s' length `%d' shall be `%d'\", buf, len, 2 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \" \" );\n\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen(buf);\n\tok( len == 1, \"candidate `%s' length `%d' shall be `%d'\", buf, len, 1 );\n\tchewing_free( buf );\n\n\tchewing_delete( ctx );\n}\n\nvo",
        "begin_line": 887,
        "end_line": 918,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Tab#707",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Tab()",
        "snippet": "void test_Tab()\n{\n\ttest_Tab_insert_breakpoint_between_word();\n\ttest_Tab_connect_word();\n\ttest_Tab_at_the_end();\n}",
        "begin_line": 707,
        "end_line": 712,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Tab_at_the_end#688",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Tab_at_the_end()",
        "snippet": "void test_Tab_at_the_end()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4u6vu84\" );\n\tok_preedit_buffer( ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE4\\xB8\\x80\\xE4\\xB8\\x8B\" /* \u6e2c\u8a66\u4e00\u4e0b */ );\n\n\ttype_keystroke_by_string( ctx, \"<T>\" );\n\tok_preedit_buffer( ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE5\\x84\\x80\\xE4\\xB8\\x8B\" /* \u6e2c\u8a66\u5100\u4e0b */ );\n\n\ttype_keystroke_by_string( ctx, \"<T>\" );\n\tok_preedit_buffer( ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE4\\xB8\\x80\\xE4\\xB8\\x8B\" /* \u6e2c\u8a66\u4e00\u4e0b */ );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_Tab()\n{\n\ttes",
        "begin_line": 688,
        "end_line": 705,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Tab_connect_word#650",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Tab_connect_word()",
        "snippet": "void test_Tab_connect_word()\n{\n\tChewingContext *ctx;\n\tIntervalType it;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\ttype_keystroke_by_string( ctx, \"u -4<L>\" );\n\tchewing_interval_Enumerate( ctx );\n\n\tok( chewing_interval_hasNext( ctx ) == 1, \"shall have next interval\" );\n\tchewing_interval_Get( ctx, &it );\n\tok( it.from == 0 && it.to == 1, \"interval (%d, %d) shall be (0, 1)\",\n\t\tit.from, it.to );\n\n\tok( chewing_interval_hasNext( ctx ) == 1, \"shall have next interval\" );\n\tchewing_interval_Get( ctx, &it );\n\tok( it.from == 1 && it.to == 2, \"interval (%d, %d) shall be (1, 2)\",\n\t\tit.from, it.to );\n\n\tok( chewing_interval_hasNext( ctx ) == 0, \"shall not have next interval\" );\n\n\t/* connect \u4e00 and \u4e8c */\n\ttype_keystroke_by_string( ctx, \"<T>\" );\n\tchewing_interval_Enumerate( ctx );\n\n\tok( chewing_interval_hasNext( ctx ) == 1, \"shall have next interval\" );\n\tchewing_interval_Get( ctx, &it );\n\tok( it.from == 0 && it.to == 2, \"interval (%d, %d) shall be (0, 2)\",\n\t\tit.from, it.to );\n\n\tok( chewing_interval_hasNext( ctx ) == 0, \"shall not have next interval\" );\n\n\tchewing_delete( ctx );\n}\n\nvo",
        "begin_line": 650,
        "end_line": 686,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Tab_insert_breakpoint_between_word#612",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Tab_insert_breakpoint_between_word()",
        "snippet": "void test_Tab_insert_breakpoint_between_word()\n{\n\tChewingContext *ctx;\n\tIntervalType it;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4<L>\" );\n\tchewing_interval_Enumerate( ctx );\n\n\tok( chewing_interval_hasNext( ctx ) == 1, \"shall have next interval\" );\n\tchewing_interval_Get( ctx, &it );\n\tok( it.from == 0 && it.to == 2, \"interval (%d, %d) shall be (0, 2)\",\n\t\tit.from, it.to );\n\n\tok( chewing_interval_hasNext( ctx ) == 0, \"shall not have next interval\" );\n\n\t/* inserts a breakpoint between \u6e2c and \u8a66 */\n\ttype_keystroke_by_string( ctx, \"<T>\" );\n\tchewing_interval_Enumerate( ctx );\n\n\tok( chewing_interval_hasNext( ctx ) == 1, \"shall have next interval\" );\n\tchewing_interval_Get( ctx, &it );\n\tok( it.from == 0 && it.to == 1, \"interval (%d, %d) shall be (0, 1)\",\n\t\tit.from, it.to );\n\n\tok( chewing_interval_hasNext( ctx ) == 1, \"shall have next interval\" );\n\tchewing_interval_Get( ctx, &it );\n\tok( it.from == 1 && it.to == 2, \"interval (%d, %d) shall be (1, 2)\",\n\t\tit.from, it.to );\n\n\tok( chewing_interval_hasNext( ctx ) == 0, \"shall not have next interval\" );\n\n\tchewing_delete( ctx );\n}\n\nvo",
        "begin_line": 612,
        "end_line": 648,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Up#564",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Up()",
        "snippet": "void test_Up()\n{\n\ttest_Up_close_candidate_window();\n\ttest_Up_not_entering_chewing();\n}",
        "begin_line": 564,
        "end_line": 568,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Up_close_candidate_window#529",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Up_close_candidate_window()",
        "snippet": "void test_Up_close_candidate_window()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"hk4\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be `%d'\", ret, 0 );\n\n\ttype_keystroke_by_string( ctx, \"<D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0 );\n\n\ttype_keystroke_by_string( ctx, \"<U>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be `%d'\", ret, 0 );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 529,
        "end_line": 550,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Up_not_entering_chewing#552",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Up_not_entering_chewing()",
        "snippet": "void test_Up_not_entering_chewing()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\ttype_keystroke_by_string( ctx, \"<U>\" );\n\tok_keystroke_rtn( ctx, KEYSTROKE_IGNORE );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 552,
        "end_line": 562,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_auto_commit#1044",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_auto_commit()",
        "snippet": "void test_auto_commit()\n{\n\ttest_auto_commit_phrase();\n\t// FIXME: Auto commit for symbol seem to be incorrect.\n\t//test_auto_commit_symbol();\n}",
        "begin_line": 1044,
        "end_line": 1049,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_auto_commit_phrase#1014",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_auto_commit_phrase()",
        "snippet": "void test_auto_commit_phrase()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 3 );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4hk4g4\" /* \u6e2c\u8a66\u6e2c\u8a66 */ );\n\tok_preedit_buffer( ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ );\n\tok_commit_buffer( ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_auto",
        "begin_line": 1014,
        "end_line": 1027,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_auto_commit_symbol#1029",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_auto_commit_symbol()",
        "snippet": "void test_auto_commit_symbol()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 2 );\n\n\ttype_keystroke_by_string( ctx, \"`31hk4g4hk4g4\" /* \uff0c\u6e2c\u8a66 */ );\n\tok_preedit_buffer( ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ );\n\tok_commit_buffer( ctx, \"\\xEF\\xBC\\x8C\" /* \uff0c */ );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_",
        "begin_line": 1029,
        "end_line": 1042,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_del_bopomofo_as_mode_switch#326",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_del_bopomofo_as_mode_switch()",
        "snippet": "void test_del_bopomofo_as_mode_switch()\n{\n\tChewingContext *ctx;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"2k\" ); /* \u3109\u311c */\n\tok_zuin_buffer( ctx, \"\\xe3\\x84\\x89\\xe3\\x84\\x9c\" /* \u3109\u311c */ );\n\n\tchewing_set_ChiEngMode( ctx, SYMBOL_MODE );\n\tok_zuin_buffer( ctx, \"\" );\n\n\tchewing_delete( ctx );\n}\n\nvoid t",
        "begin_line": 326,
        "end_line": 342,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_get_phoneSeq#925",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_get_phoneSeq()",
        "snippet": "void test_get_phoneSeq()\n{\n\tstatic const struct {\n\t\tchar *token;\n\t\tunsigned short phone[5];\n\t} DATA[] = {\n\t\t{ \"hk4g4\", { 10268, 8708, 0 } },\n\t\t{ \"hk4g4`31hk4g4\", { 10268, 8708, 10268, 8708, 0 } },\n\t\t{ \"`31`31\", { 0 } },\n\t};\n\tChewingContext *ctx;\n\tsize_t i;\n\tint expected_len;\n\tint len;\n\tunsigned short *phone;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\tfor ( i = 0; i < ARRAY_SIZE( DATA ); ++i ) {\n\t\tchewing_Reset( ctx );\n\t\ttype_keystroke_by_string( ctx, DATA[i].token );\n\n\t\texpected_len = 0;\n\t\twhile ( DATA[i].phone[expected_len] != 0 )\n\t\t\t++expected_len;\n\t\tlen = chewing_get_phoneSeqLen( ctx );\n\t\tok( len == expected_len, \"phoneSeqLen `%d' shall be `%d'\", len, expected_len );\n\n\t\tphone = chewing_get_phoneSeq( ctx );\n\t\tok ( memcmp( phone, DATA[i].phone, sizeof( phone[0] ) * expected_len ) == 0, \"phoneSeq shall be expected value\" );\n\t\tchewing_free( phone );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 925,
        "end_line": 961,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_longest_phrase#991",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_longest_phrase()",
        "snippet": "void test_longest_phrase()\n{\n\tChewingContext *ctx;\n\tIntervalType it;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"rup ji up6ji 1j4bj6y4ru32k7e.3ji \"\n\t\t/* \u3110\u3127\u3123 \u3128\u311b \u3127\u3123\u02ca \u3128\u311b \u3105\u3128\u02cb \u3116\u3128\u02ca \u3117\u02cb \u3110\u3127\u02c7 \u3109\u311c\u02d9 \u310d\u3121\u02c7 \u3128\u311b */ );\n\tok_preedit_buffer( ctx, \"\\xE9\\x87\\x91\\xE7\\xAA\\xA9\\xE9\\x8A\\x80\\xE7\\xAA\\xA9\\xE4\\xB8\\x8D\\xE5\\xA6\\x82\\xE8\\x87\\xAA\\xE5\\xB7\\xB1\\xE7\\x9A\\x84\\xE7\\x8B\\x97\\xE7\\xAA\\xA9\"\n\t\t/* \u91d1\u7aa9\u9280\u7aa9\u4e0d\u5982\u81ea\u5df1\u7684\u72d7\u7aa9 */ );\n\n\tchewing_interval_Enumerate( ctx );\n\n\tok( chewing_interval_hasNext( ctx ) == 1, \"shall have next interval\" );\n\tchewing_interval_Get( ctx, &it );\n\tok( it.from == 0 && it.to == 11, \"interval (%d, %d) shall be (0, 11)\",\n\t\tit.from, it.to );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_auto_commit_phrase()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_",
        "begin_line": 991,
        "end_line": 1012,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate#371",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate()",
        "snippet": "void test_select_candidate() {\n\ttest_select_candidate_no_rearward();\n\ttest_select_candidate_rearward();\n\ttest_select_candidate_no_rearward_with_symbol();\n\ttest_select_candidate_rearward_with_symbol();\n\ttest_select_candidate_no_rearward_start_with_symbol();\n\ttest_select_candidate_rearward_start_with_symbol();\n\ttest_select_candidate_4_bytes_utf8();\n\ttest_del_bopomofo_as_mode_switch();\n}",
        "begin_line": 371,
        "end_line": 380,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_4_bytes_utf8#344",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_4_bytes_utf8()",
        "snippet": "void test_select_candidate_4_bytes_utf8()\n{\n\tChewingContext *ctx;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_phraseChoiceRearward( ctx, 1 );\n\tchewing_set_autoShiftCur( ctx, 1 );\n\n\ttype_keystroke_by_string( ctx, \"2k62k6\" ); /* \u3109\u311c\u02ca \u3109\u311c\u02ca */\n\tok_preedit_buffer( ctx, \"\\xE5\\xBE\\x97\\xE5\\xBE\\x97\" /* \u5f97\u5f97 */ );\n\n\ttype_keystroke_by_string( ctx, \"<H>\" );\n\n\ttype_keystroke_by_string( ctx, \"<D>8\" );\n\tok_preedit_buffer( ctx, \"\\xF0\\xA2\\x94\\xA8\\xE5\\xBE\\x97\" /* \ud849\udd28\u5f97 */ );\n\n\ttype_keystroke_by_string( ctx, \"<D>8\" );\n\n\tok_preedit_buffer( ctx, \"\\xF0\\xA2\\x94\\xA8\\xF0\\xA2\\x94\\xA8\" /* \ud849\udd28\ud849\udd28 */ );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_select_candid",
        "begin_line": 344,
        "end_line": 369,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_no_rearward#27",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_no_rearward()",
        "snippet": "void test_select_candidate_no_rearward()\n{\n\t/*\n\t * The following phrases are in dict\n\t * \u4e00\u4e0a\u4f86\n\t * \u4e0a\u4f86\n\t * \u79fb\u4e0a\u4f86\n\t * \u79fb\u4e0a\n\t */\n\n\tstatic const char *CAND_1[] = {\n\t\t\"\\xE4\\xB8\\x80\\xE4\\xB8\\x8A\\xE4\\xBE\\x86\" /* \u4e00\u4e0a\u4f86 */,\n\t\t\"\\xE7\\xA7\\xBB\\xE4\\xB8\\x8A\\xE4\\xBE\\x86\" /* \u79fb\u4e0a\u4f86 */,\n\t};\n\n\tstatic const char *CAND_2[] = {\n\t\t\"\\xE7\\xA7\\xBB\\xE4\\xB8\\x8A\" /* \u79fb\u4e0a */,\n\t};\n\n\tChewingContext *ctx;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\ttype_keystroke_by_string( ctx, \"u6g;4x96<L><L><L>\" ); /* \u3127\u02ca\u3115\u3124\u02cb\u310c\u311e\u02ca */\n\n\ttype_keystroke_by_string( ctx, \"<D>\" ); /* \u3127\u02ca\u3115\u3124\u02cb\u310c\u311e\u02ca */\n\tok_candidate( ctx, CAND_1, ARRAY_SIZE( CAND_1 ) );\n\n\ttype_keystroke_by_string( ctx, \"<D>\" ); /* \u3115\u3124\u02cb\u310c\u311e\u02ca */\n\tok_candidate( ctx, CAND_2, ARRAY_SIZE( CAND_2 ) );\n\n\ttype_keystroke_by_string( ctx, \"<D><D>2<E>\" ); /* select \u79fb\u4e0a\u4f86 */\n\tok_commit_buffer( ctx, CAND_1[1] );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_select_candidate_rearward()\n{\n\t/*\n\t * The following phrases are in",
        "begin_line": 27,
        "end_line": 67,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_no_rearward_start_with_symbol#237",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_no_rearward_start_with_symbol()",
        "snippet": "void test_select_candidate_no_rearward_start_with_symbol()\n{\n\tChewingContext *ctx;\n\tint ret;\n\tchar *buf;\n\tint len;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"`31hk4g4\" /* \uff0c\u6e2c\u8a66 */);\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 0 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 0 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 1 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 2, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 2, 1 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 2 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 2 );\n\tchewing_free( buf );\n\n\tchewing_delete( ctx );\n}\n\nvoid",
        "begin_line": 237,
        "end_line": 279,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_no_rearward_with_symbol#112",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_no_rearward_with_symbol()",
        "snippet": "void test_select_candidate_no_rearward_with_symbol()\n{\n\tChewingContext *ctx;\n\tint ret;\n\tchar *buf;\n\tint len;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4`31u6vu84\" /* \u6e2c\u8a66\uff0c\u4e00\u4e0b */);\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 0 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 2, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 2, 0 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 1 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 1 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 2 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 2 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><R><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 3 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 2, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 2, 3 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><R><R><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 4 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 4 );\n\tchewing_free( buf );\n\n\tchewing_delete( ctx );\n}\n\nvoid tes",
        "begin_line": 112,
        "end_line": 172,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_rearward#69",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_rearward()",
        "snippet": "void test_select_candidate_rearward()\n{\n\t/*\n\t * The following phrases are in dict\n\t * \u4e00\u4e0a\u4f86\n\t * \u4e0a\u4f86\n\t * \u79fb\u4e0a\u4f86\n\t * \u79fb\u4e0a\n\t */\n\n\tstatic const char *CAND_1[] = {\n\t\t\"\\xE4\\xB8\\x80\\xE4\\xB8\\x8A\\xE4\\xBE\\x86\" /* \u4e00\u4e0a\u4f86 */,\n\t\t\"\\xE7\\xA7\\xBB\\xE4\\xB8\\x8A\\xE4\\xBE\\x86\" /* \u79fb\u4e0a\u4f86 */,\n\t};\n\n\tstatic const char *CAND_2[] = {\n\t\t\"\\xE4\\xB8\\x8A\\xE4\\xBE\\x86\" /* \u4e0a\u4f86 */,\n\t};\n\tChewingContext *ctx;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_phraseChoiceRearward( ctx, 1 );\n\n\ttype_keystroke_by_string( ctx, \"u6g;4x96\" ); /* \u3127\u02ca\u3115\u3124\u02cb\u310c\u311e\u02ca */\n\tok_preedit_buffer( ctx, CAND_1[0] );\n\n\ttype_keystroke_by_string( ctx, \"<D>\" ); /* \u3127\u02ca\u3115\u3124\u02cb\u310c\u311e\u02ca */\n\tok_candidate( ctx, CAND_1, ARRAY_SIZE( CAND_1 ) );\n\n\ttype_keystroke_by_string( ctx, \"<D>\" ); /* \u3115\u3124\u02cb\u310c\u311e\u02ca */\n\tok_candidate( ctx, CAND_2, ARRAY_SIZE( CAND_2 ) );\n\n\ttype_keystroke_by_string( ctx, \"<D><D>2<E>\" ); /* select \u79fb\u4e0a\u4f86 */\n\tok_commit_buffer( ctx, CAND_1[1] );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_select_candidate_no_rearward_with_symbol()\n{\n\tChewingContext *ctx;",
        "begin_line": 69,
        "end_line": 110,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_rearward_start_with_symbol#281",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_rearward_start_with_symbol()",
        "snippet": "void test_select_candidate_rearward_start_with_symbol()\n{\n\tChewingContext *ctx;\n\tint ret;\n\tchar *buf;\n\tint len;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_phraseChoiceRearward( ctx, 1 );\n\n\ttype_keystroke_by_string( ctx, \"`31hk4g4\" /* \uff0c\u6e2c\u8a66 */);\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 0 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 0 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 1 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 1 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 2 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 2, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 2, 2 );\n\tchewing_free( buf );\n\n\tchewing_delete( ctx );\n}\n\nvoid",
        "begin_line": 281,
        "end_line": 324,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_rearward_with_symbol#174",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_rearward_with_symbol()",
        "snippet": "void test_select_candidate_rearward_with_symbol()\n{\n\tChewingContext *ctx;\n\tint ret;\n\tchar *buf;\n\tint len;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_phraseChoiceRearward( ctx, 1 );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4`31u6vu84\" /* \u6e2c\u8a66\uff0c\u4e00\u4e0b */);\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 0 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 0 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 1 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 2, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 2, 1 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 2 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 2 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><R><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 3 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 3 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><R><R><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 4 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 2, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 2, 4 );\n\tchewing_free( buf );\n\n\tchewing_delete( ctx );\n}\n\nvoid tes",
        "begin_line": 174,
        "end_line": 235,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_zuin_buffer#963",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_zuin_buffer()",
        "snippet": "void test_zuin_buffer()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"1ul\" );\n\tok_zuin_buffer( ctx, \"\\xE3\\x84\\x85\\xE3\\x84\\xA7\\xE3\\x84\\xA0\" /* \u3105\u3127\u3120 */ );\n\n\ttype_keystroke_by_string( ctx, \" \" );\n\tok_zuin_buffer( ctx, \"\" );\n\n\ttype_keystroke_by_string( ctx, \"ul\" );\n\tok_zuin_buffer( ctx, \"\\xE3\\x84\\xA7\\xE3\\x84\\xA0\" /* \u3127\u3120 */ );\n\n\ttype_keystroke_by_string( ctx, \" \" );\n\tok_zuin_buffer( ctx, \"\" );\n\n\ttype_keystroke_by_string( ctx, \"3\");\n\tok_zuin_buffer( ctx, \"\\xCB\\x87\" /* \u02c7 */);\n\n\ttype_keystroke_by_string( ctx, \" \" );\n\tok_zuin_buffer( ctx, \"\" );\n\n\tchewing_delete( ctx );\n}\n\nvoid test",
        "begin_line": 963,
        "end_line": 989,
        "is_bug": false
    },
    {
        "name": "test.test-config.main#477",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n\tchar *logname;\n\tint ret;\n\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\tret = asprintf( &logname, \"%s.log\", argv[0] );\n\tif ( ret == -1 ) return -1;\n\tfd = fopen( logname, \"w\" );\n\tassert( fd );\n\tfree( logname );\n\n\n\ttest_default_value();\n\n\ttest_set_candPerPage();\n\ttest_set_maxChiSymbolLen();\n\ttest_maxChiSymbolLen();\n\ttest_set_selKey();\n\ttest_set_addPhraseDirection();\n\ttest_set_spaceAsSelection();\n\ttest_set_escCleanAllBuf();\n\ttest_set_autoShiftCur();\n\ttest_set_easySymbolInput();\n\ttest_set_phraseChoiceRearward();\n\ttest_set_ChiEngMode();\n\ttest_set_ShapeMode();\n\n\ttest_deprecated();\n\n\tfclose( fd );\n\n\treturn exit_status();\n}",
        "begin_line": 477,
        "end_line": 512,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_default_value#38",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_default_value()",
        "snippet": "void test_default_value()\n{\n\tint *select_key;\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tselect_key = chewing_get_selKey( ctx );\n\tok( select_key, \"chewing_get_selKey shall not return NULL\" );\n\tok( !memcmp( select_key, DEFAULT_SELECT_KEY,\n\t\tsizeof( DEFAULT_SELECT_KEY )),\n\t\t\"default select key shall be default value\" );\n\tchewing_free( select_key );\n\n\tok( chewing_get_candPerPage( ctx ) == DEFAULT_CAND_PER_PAGE,\n\t\t\"default candPerPage shall be %d\", DEFAULT_CAND_PER_PAGE );\n\n\tok( chewing_get_maxChiSymbolLen( ctx ) == MAX_CHI_SYMBOL_LEN,\n\t\t\"default maxChiSymbolLen shall be %d\", MAX_CHI_SYMBOL_LEN );\n\n\tok( chewing_get_addPhraseDirection( ctx ) == 0,\n\t\t\"default addPhraseDirection shall be 0\" );\n\n\tok( chewing_get_spaceAsSelection( ctx ) == 0,\n\t\t\"default spaceAsSelection shall be 0\" );\n\n\tok( chewing_get_escCleanAllBuf( ctx ) == 0,\n\t\t\"default escCleanAllBuf shall be 0\" );\n\n\tok( chewing_get_hsuSelKeyType( ctx ) == 0,\n\t\t\"default hsuSelKeyType shall be 0\" );\n\n\tok( chewing_get_autoShiftCur( ctx ) == 0,\n\t\t\"default autoShiftCur shall be 0\" );\n\n\tok( chewing_get_easySymbolInput( ctx ) == 0,\n\t\t\"default easySymbolInput shall be 0\" );\n\n\tok( chewing_get_phraseChoiceRearward( ctx ) == 0,\n\t\t\"default phraseChoiceRearward shall be 0\" );\n\n\tok( chewing_get_ChiEngMode( ctx ) == CHINESE_MODE,\n\t\t\"default ChiEngMode shall be CHINESE_MODE\" );\n\n\tok( chewing_get_ShapeMode( ctx ) == HALFSHAPE_MODE,\n\t\t\"default ShapeMode shall be HALFSHAPE_MODE\" );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 38,
        "end_line": 87,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_deprecated#458",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_deprecated()",
        "snippet": "void test_deprecated()\n{\n\tChewingContext *ctx;\n\tint type;\n\tChewingConfigData configure;\n\tmemset( &configure, 0, sizeof( ChewingConfigData ) );\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tchewing_set_hsuSelKeyType( ctx, HSU_SELKEY_TYPE1 );\n\ttype = chewing_get_hsuSelKeyType( ctx );\n\tok( type == HSU_SELKEY_TYPE1, \"`%d' shall be `%d'\", type, HSU_SELKEY_TYPE1 );\n\n\tchewing_Configure( ctx, &configure );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 458,
        "end_line": 475,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_maxChiSymbolLen#166",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_maxChiSymbolLen()",
        "snippet": "void test_maxChiSymbolLen()\n{\n\tChewingContext *ctx;\n\tint i;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tchewing_set_maxChiSymbolLen( ctx, MAX_CHI_SYMBOL_LEN );\n\n\tfor ( i = 0; i < MAX_CHI_SYMBOL_LEN; ++i ) {\n\t\ttype_keystroke_by_string( ctx, \"hk4\" );\n\t}\n\n\t// Use easy symbol 'Orz' as last input for worst case scenario.\n\tchewing_set_easySymbolInput( ctx, 1 );\n\ttype_keystroke_by_string( ctx, \"L\" );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 166,
        "end_line": 185,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_ChiEngMode#388",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_ChiEngMode()",
        "snippet": "void test_set_ChiEngMode()\n{\n\tconst int VALUE[] = {\n\t\tCHINESE_MODE,\n\t\tSYMBOL_MODE,\n\t};\n\n\tconst int INVALID_VALUE[] = {\n\t\t-1,\n\t\t2,\n\t};\n\n\tChewingContext *ctx;\n\tsize_t i;\n\tsize_t j;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tfor ( i = 0; i < ARRAY_SIZE( VALUE ); ++i ) {\n\t\tchewing_set_ChiEngMode( ctx, VALUE[i] );\n\t\tok( chewing_get_ChiEngMode( ctx ) == VALUE[i],\n\t\t\t\"ChiEngMode shall be `%d'\", VALUE[i] );\n\n\t\tfor ( j = 0; j < ARRAY_SIZE( INVALID_VALUE ); ++j ) {\n\t\t\t// mode shall not change when set mode has invalid value.\n\t\t\tchewing_set_ChiEngMode( ctx, INVALID_VALUE[j] );\n\t\t\tok( chewing_get_ChiEngMode( ctx ) == VALUE[i],\n\t\t\t\t\"ChiEngMode shall be `%d'\", VALUE[i] );\n\t\t}\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 388,
        "end_line": 421,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_ShapeMode#423",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_ShapeMode()",
        "snippet": "void test_set_ShapeMode()\n{\n\tconst int VALUE[] = {\n\t\tHALFSHAPE_MODE,\n\t\tFULLSHAPE_MODE,\n\t};\n\n\tconst int INVALID_VALUE[] = {\n\t\t-1,\n\t\t2,\n\t};\n\n\tChewingContext *ctx;\n\tsize_t i;\n\tsize_t j;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tfor ( i = 0; i < ARRAY_SIZE( VALUE ); ++i ) {\n\t\tchewing_set_ShapeMode( ctx, VALUE[i] );\n\t\tok( chewing_get_ShapeMode( ctx ) == VALUE[i],\n\t\t\t\"ShapeMode shall be `%d'\", VALUE[i] );\n\n\t\tfor ( j = 0; j < ARRAY_SIZE( INVALID_VALUE ); ++j ) {\n\t\t\t// mode shall not change when set mode has invalid value.\n\t\t\tchewing_set_ShapeMode( ctx, INVALID_VALUE[j] );\n\t\t\tok( chewing_get_ShapeMode( ctx ) == VALUE[i],\n\t\t\t\t\"ShapeMode shall be `%d'\", VALUE[i] );\n\t\t}\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 423,
        "end_line": 456,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_addPhraseDirection#214",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_addPhraseDirection()",
        "snippet": "void test_set_addPhraseDirection()\n{\n\tChewingContext *ctx;\n\tint value;\n\tint mode;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tfor ( value = 0; value < 2; ++value ) {\n\t\tchewing_set_addPhraseDirection( ctx, value );\n\t\tmode = chewing_get_addPhraseDirection( ctx );\n\t\tok( mode == value,\n\t\t\t\"addPhraseDirection `%d' shall be `%d'\", mode, value );\n\n\t\tchewing_set_addPhraseDirection( ctx, -1 );\n\t\tmode = chewing_get_addPhraseDirection( ctx );\n\t\tok( mode == value,\n\t\t\t\"addPhraseDirection `%d' shall be `%d'\", mode, value );\n\n\t\tchewing_set_addPhraseDirection( ctx, 2 );\n\t\tmode = chewing_get_addPhraseDirection( ctx );\n\t\tok( mode == value,\n\t\t\t\"addPhraseDirection `%d' shall be `%d'\", mode, value );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 214,
        "end_line": 241,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_autoShiftCur#301",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_autoShiftCur()",
        "snippet": "void test_set_autoShiftCur()\n{\n\tChewingContext *ctx;\n\tint value;\n\tint mode;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tfor ( value = 0; value < 2; ++value ) {\n\t\tchewing_set_autoShiftCur( ctx, value );\n\t\tmode = chewing_get_autoShiftCur( ctx );\n\t\tok( mode = chewing_get_autoShiftCur( ctx ) == value,\n\t\t\t\"autoShiftCur shall be `%d'\", value );\n\n\t\tchewing_set_autoShiftCur( ctx, -1 );\n\t\tmode = chewing_get_autoShiftCur( ctx );\n\t\tok( mode = chewing_get_autoShiftCur( ctx ) == value,\n\t\t\t\"autoShiftCur shall be `%d'\", value );\n\n\t\tchewing_set_autoShiftCur( ctx, 2 );\n\t\tmode = chewing_get_autoShiftCur( ctx );\n\t\tok( mode = chewing_get_autoShiftCur( ctx ) == value,\n\t\t\t\"autoShiftCur shall be `%d'\", value );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 301,
        "end_line": 328,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_candPerPage#89",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_candPerPage()",
        "snippet": "void test_set_candPerPage()\n{\n\tconst int VALUE[] = {\n\t\tMIN_CAND_PER_PAGE,\n\t\tMAX_CAND_PER_PAGE,\n\t};\n\n\tconst int INVALID_VALUE[] = {\n\t\tMIN_CAND_PER_PAGE - 1,\n\t\tMAX_CAND_PER_PAGE + 1,\n\t};\n\n\tChewingContext *ctx;\n\tsize_t i;\n\tsize_t j;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tfor ( i = 0; i < ARRAY_SIZE( VALUE ); ++i ) {\n\t\tchewing_set_candPerPage( ctx, VALUE[i] );\n\t\tok( chewing_get_candPerPage( ctx ) == VALUE[i],\n\t\t\t\"candPerPage shall be `%d'\", VALUE[i] );\n\n\t\tfor ( j = 0; j < ARRAY_SIZE( INVALID_VALUE ); ++j ) {\n\t\t\t// mode shall not change when set mode has invalid value.\n\t\t\tchewing_set_candPerPage( ctx, INVALID_VALUE[j] );\n\t\t\tok( chewing_get_candPerPage( ctx ) == VALUE[i],\n\t\t\t\t\"candPerPage shall be `%d'\", VALUE[i] );\n\t\t}\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 89,
        "end_line": 122,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_easySymbolInput#330",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_easySymbolInput()",
        "snippet": "void test_set_easySymbolInput()\n{\n\tChewingContext *ctx;\n\tint value;\n\tint mode;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tfor ( value = 0; value < 2; ++value ) {\n\t\tchewing_set_easySymbolInput( ctx, value );\n\t\tmode = chewing_get_easySymbolInput( ctx );\n\t\tok( mode == value,\n\t\t\t\"easySymbolInput `%d', shall be `%d'\", mode, value );\n\n\t\tchewing_set_easySymbolInput( ctx, -1 );\n\t\tmode = chewing_get_easySymbolInput( ctx );\n\t\tok( mode == value,\n\t\t\t\"easySymbolInput `%d', shall be `%d'\", mode, value );\n\n\t\tchewing_set_easySymbolInput( ctx, 2 );\n\t\tmode = chewing_get_easySymbolInput( ctx );\n\t\tok( mode == value,\n\t\t\t\"easySymbolInput `%d', shall be `%d'\", mode, value );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 330,
        "end_line": 357,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_escCleanAllBuf#272",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_escCleanAllBuf()",
        "snippet": "void test_set_escCleanAllBuf()\n{\n\tChewingContext *ctx;\n\tint value;\n\tint mode;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tfor ( value = 0; value < 2; ++value ) {\n\t\tchewing_set_escCleanAllBuf( ctx, value );\n\t\tmode = chewing_get_escCleanAllBuf( ctx );\n\t\tok( mode == value,\n\t\t\t\"escCleanAllBuf shall be `%d'\", value );\n\n\t\tchewing_set_escCleanAllBuf( ctx, -1 );\n\t\tmode = chewing_get_escCleanAllBuf( ctx );\n\t\tok( mode == value,\n\t\t\t\"escCleanAllBuf shall be `%d'\", value );\n\n\t\tchewing_set_escCleanAllBuf( ctx, 2 );\n\t\tmode = chewing_get_escCleanAllBuf( ctx );\n\t\tok( mode == value,\n\t\t\t\"escCleanAllBuf shall be `%d'\", value );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 272,
        "end_line": 299,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_maxChiSymbolLen#124",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_maxChiSymbolLen()",
        "snippet": "void test_set_maxChiSymbolLen()\n{\n\tChewingContext *ctx;\n\tint i;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tok( chewing_get_maxChiSymbolLen( ctx ) == 16,\n\t\t\"maxChiSymbolLen shall be 16\" );\n\n\tchewing_set_maxChiSymbolLen( ctx, MIN_CHI_SYMBOL_LEN - 1 );\n\tok( chewing_get_maxChiSymbolLen( ctx ) == 16,\n\t\t\"maxChiSymbolLen shall not change when set to %d\",\n\t\tMIN_CHI_SYMBOL_LEN - 1 );\n\n\tchewing_set_maxChiSymbolLen( ctx, MAX_CHI_SYMBOL_LEN + 1 );\n\tok( chewing_get_maxChiSymbolLen( ctx ) == 16,\n\t\t\"maxChiSymbolLen shall not change when set to %d\",\n\t\tMAX_CHI_SYMBOL_LEN + 1 );\n\n\n\t// Test auto commit\n\tchewing_set_maxChiSymbolLen( ctx, MAX_CHI_SYMBOL_LEN );\n\n\t// In boundary\n\tfor ( i = 0; i < MAX_CHI_SYMBOL_LEN; ++i )\n\t\ttype_keystroke_by_string( ctx, \"hk4\" );\n\tok( chewing_commit_Check( ctx ) == 0,\n\t\t\"auto commit shall not be triggered when entering %d symbols\",\n\t\tMAX_CHI_SYMBOL_LEN );\n\n\t// Out of boundary\n\ttype_keystroke_by_string( ctx, \"hk4\" );\n\tok( chewing_commit_Check( ctx ) == 1,\n\t\t\"auto commit shall be triggered when entering %d symbols\",\n\t\tMAX_CHI_SYMBOL_LEN + 1);\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 124,
        "end_line": 164,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_phraseChoiceRearward#359",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_phraseChoiceRearward()",
        "snippet": "void test_set_phraseChoiceRearward()\n{\n\tChewingContext *ctx;\n\tint value;\n\tint mode;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tfor ( value = 0; value < 2; ++value ) {\n\t\tchewing_set_phraseChoiceRearward( ctx, value );\n\t\tmode = chewing_get_phraseChoiceRearward( ctx );\n\t\tok(  mode == value,\n\t\t\t\"phraseChoiceRearward `%d' shall be `%d'\", mode, value );\n\n\t\tchewing_set_phraseChoiceRearward( ctx, -1 );\n\t\tmode = chewing_get_phraseChoiceRearward( ctx );\n\t\tok(  mode == value,\n\t\t\t\"phraseChoiceRearward `%d' shall be `%d'\", mode, value );\n\n\t\tchewing_set_phraseChoiceRearward( ctx, 2 );\n\t\tmode = chewing_get_phraseChoiceRearward( ctx );\n\t\tok(  mode == value,\n\t\t\t\"phraseChoiceRearward `%d' shall be `%d'\", mode, value );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 359,
        "end_line": 386,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_selKey#187",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_selKey()",
        "snippet": "void test_set_selKey()\n{\n\tChewingContext *ctx;\n\tint *select_key;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\t// XXX: chewing_set_selKey shall accept const char *.\n\tchewing_set_selKey( ctx,\n\t\tALTERNATE_SELECT_KEY, ARRAY_SIZE( ALTERNATE_SELECT_KEY ));\n\tselect_key = chewing_get_selKey( ctx );\n\tok( select_key, \"chewing_get_selKey shall not return NULL\" );\n\tok( !memcmp( select_key, ALTERNATE_SELECT_KEY,\n\t\tsizeof( ALTERNATE_SELECT_KEY )),\n\t\t\"select key shall be ALTERNATE_SELECT_KEY\");\n\n\ttype_keystroke_by_string( ctx, DATA.token );\n\tok_preedit_buffer( ctx, DATA.expected );\n\n\tchewing_free( select_key );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 187,
        "end_line": 212,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_spaceAsSelection#243",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_spaceAsSelection()",
        "snippet": "void test_set_spaceAsSelection()\n{\n\tChewingContext *ctx;\n\tint value;\n\tint mode;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tfor ( value = 0; value < 2; ++value ) {\n\t\tchewing_set_spaceAsSelection( ctx, value );\n\t\tmode = chewing_get_spaceAsSelection( ctx );\n\t\tok( mode == value,\n\t\t\t\"spaceAsSelection `%d' shall be `%d'\", mode, value );\n\n\t\tchewing_set_spaceAsSelection( ctx, -1 );\n\t\tmode = chewing_get_spaceAsSelection( ctx );\n\t\tok( mode == value,\n\t\t\t\"spaceAsSelection `%d' shall be `%d'\", mode, value );\n\n\t\tchewing_set_spaceAsSelection( ctx, 2 );\n\t\tmode = chewing_get_spaceAsSelection( ctx );\n\t\tok( mode == value,\n\t\t\t\"spaceAsSelection `%d' shall be `%d'\", mode, value );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 243,
        "end_line": 270,
        "is_bug": false
    },
    {
        "name": "test.test-easy-symbol.main#100",
        "src_path": "test/test-easy-symbol.c",
        "class_name": "test.test-easy-symbol",
        "signature": "test.test-easy-symbol.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n\tchar *logname;\n\tint ret;\n\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\tret = asprintf( &logname, \"%s.log\", argv[0] );\n\tif ( ret == -1 ) return -1;\n\tfd = fopen( logname, \"w\" );\n\tassert( fd );\n\tfree( logname );\n\n\n\ttest_type_easy_symbol();\n\ttest_mode_change();\n\n\tfclose( fd );\n\n\treturn exit_status();\n}",
        "begin_line": 100,
        "end_line": 121,
        "is_bug": false
    },
    {
        "name": "test.test-easy-symbol.test_mode_change#76",
        "src_path": "test/test-easy-symbol.c",
        "class_name": "test.test-easy-symbol",
        "signature": "test.test-easy-symbol.test_mode_change()",
        "snippet": "void test_mode_change()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\ttype_keystroke_by_string( ctx, CHINESE.token );\n\tok_commit_buffer( ctx, CHINESE.expected );\n\n\tchewing_set_easySymbolInput( ctx, 1 );\n\ttype_keystroke_by_string( ctx, EASY_SYMBOL[0].token );\n\ttype_keystroke_by_string( ctx, \"<E>\" );\n\tok_commit_buffer( ctx, EASY_SYMBOL[0].expected );\n\n\tchewing_set_easySymbolInput( ctx, 0 );\n\ttype_keystroke_by_string( ctx, CHINESE.token );\n\tok_commit_buffer( ctx, CHINESE.expected );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 76,
        "end_line": 98,
        "is_bug": false
    },
    {
        "name": "test.test-easy-symbol.test_type_easy_symbol#55",
        "src_path": "test/test-easy-symbol.c",
        "class_name": "test.test-easy-symbol",
        "signature": "test.test-easy-symbol.test_type_easy_symbol()",
        "snippet": "void test_type_easy_symbol()\n{\n\tChewingContext *ctx;\n\tsize_t i;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_easySymbolInput( ctx, 1 );\n\n\tfor ( i = 0; i < ARRAY_SIZE( EASY_SYMBOL ); ++i ) {\n\t\ttype_keystroke_by_string( ctx, EASY_SYMBOL[i].token );\n\t\tok_preedit_buffer( ctx, EASY_SYMBOL[i].expected );\n\t\ttype_keystroke_by_string( ctx, \"<E>\" );\n\t\tok_commit_buffer( ctx, EASY_SYMBOL[i].expected );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 55,
        "end_line": 74,
        "is_bug": false
    },
    {
        "name": "test.test-error-handling.main#78",
        "src_path": "test/test-error-handling.c",
        "class_name": "test.test-error-handling",
        "signature": "test.test-error-handling.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n\tchar *logname;\n\tint ret;\n\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\tret = asprintf( &logname, \"%s.log\", argv[0] );\n\tif ( ret == -1 ) return -1;\n\tfd = fopen( logname, \"w\" );\n\tassert( fd );\n\tfree( logname );\n\n\n\ttest_null();\n\n\tfclose( fd );\n\n\treturn exit_status();\n}",
        "begin_line": 78,
        "end_line": 98,
        "is_bug": false
    },
    {
        "name": "test.test-error-handling.test_null#18",
        "src_path": "test/test-error-handling.c",
        "class_name": "test.test-error-handling",
        "signature": "test.test-error-handling.test_null()",
        "snippet": "void test_null()\n{\n\tint ret;\n\n\tstart_testcase( NULL, fd );\n\n\tchewing_set_logger( NULL, NULL, NULL );\n\n\tret = chewing_userphrase_enumerate( NULL );\n\tok( ret == -1, \"chewing_userphrase_enumerate() returns `%d' shall be `%d'\", ret, -1 );\n\n\tret = chewing_userphrase_has_next( NULL, NULL, NULL );\n\tok( ret == 0, \"chewing_userphrase_has_next() returns `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_userphrase_get( NULL, NULL, 0, NULL, 0 );\n\tok( ret == -1, \"chewing_userphrase_get() returns `%d' shall be `%d'\", ret, -1 );\n\n\tret = chewing_userphrase_add( NULL, NULL, NULL );\n\tok( ret == -1, \"chewing_userphrase_add() returns `%d' shall be `%d'\", ret, -1 );\n\n\tret = chewing_userphrase_remove( NULL, NULL, NULL );\n\tok( ret == -1, \"chewing_userphrase_remove() returns `%d' shall be `%d'\", ret, -1 );\n\n\tret = chewing_userphrase_lookup( NULL, NULL, NULL );\n\tok( ret == 0, \"chewing_userphrase_lookup() returns `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_cand_open( NULL );\n\tok ( ret == -1, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, -1 );\n\n\tret = chewing_cand_close( NULL );\n\tok ( ret == -1, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, -1 );\n\n\tret = chewing_cand_choose_by_index( NULL, 0 );\n\tok ( ret == -1, \"chewing_cand_choose_by_index() returns `%d' shall be `%d'\", ret, -1 );\n\n\tret = chewing_cand_list_first( NULL );\n\tok ( ret == -1, \"chewing_cand_list_first() returns `%d' shall be `%d'\", ret, -1 );\n\n\tret = chewing_cand_list_last( NULL );\n\tok ( ret == -1, \"chewing_cand_list_last() returns `%d' shall be `%d'\", ret, -1 );\n\n\tret = chewing_cand_list_has_next( NULL );\n\tok ( ret == 0, \"chewing_cand_list_has_next() returns `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_cand_list_has_prev( NULL );\n\tok ( ret == 0, \"chewing_cand_list_has_prev() returns `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_cand_list_next( NULL );\n\tok ( ret == -1, \"chewing_cand_list_next() returns `%d' shall be `%d'\", ret, -1 );\n\n\tret = chewing_cand_list_prev( NULL );\n\tok ( ret == -1, \"chewing_cand_list_prev() returns `%d' shall be `%d'\", ret, -1 );\n\n\tret = chewing_commit_preedit_buf( NULL );\n\tok ( ret == -1, \"chewing_commit_preedit_buf() returns `%d' shall be `%d'\", ret, -1 );\n\n\tret = chewing_clean_preedit_buf( NULL );\n\tok ( ret == -1, \"chewing_clean_preedit_buf() returns `%d' shall be `%d'\", ret, -1 );\n}",
        "begin_line": 18,
        "end_line": 76,
        "is_bug": false
    },
    {
        "name": "test.test-fullshape.main#152",
        "src_path": "test/test-fullshape.c",
        "class_name": "test.test-fullshape",
        "signature": "test.test-fullshape.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n\tchar *logname;\n\tint ret;\n\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\tret = asprintf( &logname, \"%s.log\", argv[0] );\n\tif ( ret == -1 ) return -1;\n\tfd = fopen( logname, \"w\" );\n\tassert( fd );\n\tfree( logname );\n\n\n\ttest_set_fullshape();\n\ttest_fullshape_input();\n\n\tfclose( fd );\n\n\treturn exit_status();\n}",
        "begin_line": 152,
        "end_line": 173,
        "is_bug": false
    },
    {
        "name": "test.test-fullshape.test_fullshape_input#101",
        "src_path": "test/test-fullshape.c",
        "class_name": "test.test-fullshape",
        "signature": "test.test-fullshape.test_fullshape_input()",
        "snippet": "void test_fullshape_input()\n{\n\tChewingContext *ctx;\n\tsize_t i;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tchewing_set_ChiEngMode( ctx, SYMBOL_MODE );\n\tchewing_set_ShapeMode( ctx, FULLSHAPE_MODE );\n\n\tfor ( i = 0; i < ARRAY_SIZE( FULLSHAPE_DATA ); ++i ) {\n\t\ttype_keystroke_by_string( ctx, FULLSHAPE_DATA[i].token );\n\t\t// fullshape symbol does not present in preedit buffer.\n\t\tok_preedit_buffer( ctx, \"\" );\n\t\tok_commit_buffer( ctx, FULLSHAPE_DATA[i].expected );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 101,
        "end_line": 120,
        "is_bug": false
    },
    {
        "name": "test.test-fullshape.test_set_fullshape#122",
        "src_path": "test/test-fullshape.c",
        "class_name": "test.test-fullshape",
        "signature": "test.test-fullshape.test_set_fullshape()",
        "snippet": "void test_set_fullshape()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tok( chewing_get_ShapeMode( ctx ) == HALFSHAPE_MODE,\n\t\t\"default is HALFSHAPE_MODE\" );\n\n\tchewing_set_ShapeMode( ctx, FULLSHAPE_MODE );\n\tok( chewing_get_ShapeMode( ctx ) == FULLSHAPE_MODE,\n\t\t\"mode shall change to FULLSHAPE_MODE\" );\n\n\tchewing_set_ShapeMode( ctx, -1 );\n\tok( chewing_get_ShapeMode( ctx ) == FULLSHAPE_MODE,\n\t\t\"mode shall not change when parameter is invalid\" );\n\n\tchewing_set_ShapeMode( ctx, HALFSHAPE_MODE );\n\tok( chewing_get_ShapeMode( ctx ) == HALFSHAPE_MODE,\n\t\t\"mode shall change to HALFSHAPE_MODE\" );\n\n\tchewing_set_ShapeMode( ctx, -1 );\n\tok( chewing_get_ShapeMode( ctx ) == HALFSHAPE_MODE,\n\t\t\"mode shall not change when parameter is invalid\" );\n\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 122,
        "end_line": 150,
        "is_bug": false
    },
    {
        "name": "test.test-key2pho.main#120",
        "src_path": "test/test-key2pho.c",
        "class_name": "test.test-key2pho",
        "signature": "test.test-key2pho.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n\tchar *logname;\n\tint ret;\n\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\tret = asprintf( &logname, \"%s.log\", argv[0] );\n\tif ( ret == -1 ) return -1;\n\tfd = fopen( logname, \"w\" );\n\tassert( fd );\n\tfree( logname );\n\n\n\ttest_uint_and_phone();\n\ttest_uint_and_phone_error();\n\ttest_key_and_phone();\n\n\tfclose( fd );\n\n\treturn exit_status();\n}",
        "begin_line": 120,
        "end_line": 142,
        "is_bug": false
    },
    {
        "name": "test.test-key2pho.test_key_and_phone#98",
        "src_path": "test/test-key2pho.c",
        "class_name": "test.test-key2pho",
        "signature": "test.test-key2pho.test_key_and_phone()",
        "snippet": "void test_key_and_phone()\n{\n\tchar rt[ MAX_UTF8_SIZE * ZUIN_SIZE + 1 ];\n\n\tstart_testcase( NULL, fd );\n\n\tPhoneFromKey( rt, \"dj\", 0, 1 );\n\tok (!strcmp(rt, \"\\xE3\\x84\\x8E\\xE3\\x84\\xA8\" /* \u310e\u3128 */ ), \"dj\");\n\n\tPhoneFromKey( rt, \"dj6\", 0, 1 );\n\tok (!strcmp(rt, \"\\xE3\\x84\\x8E\\xE3\\x84\\xA8\\xCB\\x8A\" /* \u310e\u3128\u02ca */ ), \"dj6\");\n\n\tPhoneFromKey( rt, \"dj3\", 0, 1 );\n\tok (!strcmp(rt, \"\\xE3\\x84\\x8E\\xE3\\x84\\xA8\\xCB\\x87\" /* \u310e\u3128\u02c7 */ ), \"dj3\");\n\n\tPhoneFromKey( rt, \"dj4\", 0, 1 );\n\tok (!strcmp(rt, \"\\xE3\\x84\\x8E\\xE3\\x84\\xA8\\xCB\\x8B\" /* \u310e\u3128\u02cb */ ), \"dj4\");\n\n\tPhoneFromKey( rt, \"dj7\", 0, 1 );\n\tok (!strcmp(rt, \"\\xE3\\x84\\x8E\\xE3\\x84\\xA8\\xCB\\x99\" /* \u310e\u3128\u02d9 */ ), \"dj7\");\n}\n\nint main(int argc, cha",
        "begin_line": 98,
        "end_line": 118,
        "is_bug": false
    },
    {
        "name": "test.test-key2pho.test_uint_and_phone#23",
        "src_path": "test/test-key2pho.c",
        "class_name": "test.test-key2pho",
        "signature": "test.test-key2pho.test_uint_and_phone()",
        "snippet": "void test_uint_and_phone()\n{\n\tchar *u8phone;\n\tchar rt[ MAX_UTF8_SIZE * ZUIN_SIZE + 1 ];\n\tuint16_t phone;\n\tuint16_t expect;\n\n\tstart_testcase( NULL, fd );\n\n\tu8phone = \"\\xE3\\x84\\x86\\xE3\\x84\\xA3\" /* \u3106\u3123 */;\n\tphone = UintFromPhone(u8phone);\n\texpect = 1104;\n\tok (phone == expect, \"UintFromPhone `%s' shall be `%d', got `%d'\",\n\t\tu8phone, expect, phone);\n\n\tPhoneFromUint( rt, sizeof( rt ), expect );\n\tok (strcmp( rt, u8phone ) == 0, \"PhoneFromUint d%d' shall be `%s', got `%s'\",\n\t\texpect, u8phone, rt);\n\n\n\tu8phone = \"\\xE3\\x84\\x8A\\xE3\\x84\\xA7\\xE3\\x84\\xA2\" /* \u310a\u3127\u3122 */;\n\tphone = UintFromPhone(u8phone);\n\texpect = 3272;\n\tok (phone == expect, \"UintFromPhone `%s' shall be `%d', got `%d'\",\n\t\tu8phone, expect, phone);\n\n\tPhoneFromUint( rt, sizeof( rt ), expect );\n\tok (strcmp( rt, u8phone ) == 0, \"PhoneFromUint d%d' shall be `%s', got `%s'\",\n\t\texpect, u8phone, rt);\n\n\n\tu8phone = \"\\xE3\\x84\\x92\\xE3\\x84\\xA7\\xE3\\x84\\x9A\\xCB\\x8B\" /* \u3112\u3127\u311a\u02cb */;\n\tphone = UintFromPhone(u8phone);\n\texpect = 7308;\n\tok (phone == expect, \"UintFromPhone `%s' shall be `%d', got `%d'\",\n\t\tu8phone, expect, phone);\n\n\tPhoneFromUint( rt, sizeof( rt ), expect );\n\tok (strcmp( rt, u8phone ) == 0, \"PhoneFromUint `%d' shall be `%s', got `%s'\",\n\t\texpect, u8phone, rt);\n}\n\nvoid test_uint_",
        "begin_line": 23,
        "end_line": 63,
        "is_bug": false
    },
    {
        "name": "test.test-key2pho.test_uint_and_phone_error#65",
        "src_path": "test/test-key2pho.c",
        "class_name": "test.test-key2pho",
        "signature": "test.test-key2pho.test_uint_and_phone_error()",
        "snippet": "void test_uint_and_phone_error()\n{\n\tchar *u8phone;\n\tchar rt[ MAX_UTF8_SIZE * ZUIN_SIZE + 1 ];\n\tuint16_t phone;\n\tuint16_t expect;\n\n\tstart_testcase( NULL, fd );\n\n\tu8phone = \"\\xE3\\x84\\x8A\\xE3\\x84\\xA7\\xE6\\xB8\\xAC\" /* \u310a\u3127\u6e2c */;\n\tphone = UintFromPhone(u8phone);\n\texpect = 0;\n\tok (phone == expect, \"UintFromPhone `%s' shall be `%d', got `%d'\",\n\t\tu8phone, expect, phone);\n\n\tu8phone = \"\\xE3\\x84\\x8E\\xE3\\x84\\x8E\" /* \u310e\u310e */;\n\tphone = UintFromPhone(u8phone);\n\texpect = 0;\n\tok (phone == expect, \"UintFromPhone `%s' shall be `%d', got `%d'\",\n\t\tu8phone, expect, phone);\n\n\tu8phone = \"\\xE3\\x84\\xA8\\xE3\\x84\\x8E\" /* \u3128\u310e */;\n\tphone = UintFromPhone(u8phone);\n\texpect = 0;\n\tok (phone == expect, \"UintFromPhone `%s' shall be `%d', got `%d'\",\n\t\tu8phone, expect, phone);\n\n\tPhoneFromUint( rt, sizeof( rt ), 0 );\n\tok (strcmp( rt, \"\" ) == 0, \"PhoneFromUint `%d' shall be `%s', got `%s'\",\n\t\t0, \"\", rt);\n\n}\n\nvoid test_ke",
        "begin_line": 65,
        "end_line": 96,
        "is_bug": false
    },
    {
        "name": "test.test-keyboard.main#131",
        "src_path": "test/test-keyboard.c",
        "class_name": "test.test-keyboard",
        "signature": "test.test-keyboard.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n\tchar *logname;\n\tint ret;\n\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\tret = asprintf( &logname, \"%s.log\", argv[0] );\n\tif ( ret == -1 ) return -1;\n\tfd = fopen( logname, \"w\" );\n\tassert( fd );\n\tfree( logname );\n\n\ttest_set_keyboard_type();\n\ttest_KBStr2Num();\n\ttest_enumerate_keyboard_type();\n\n\tfclose( fd );\n\n\treturn exit_status();\n}",
        "begin_line": 131,
        "end_line": 152,
        "is_bug": false
    },
    {
        "name": "test.test-keyboard.test_KBStr2Num#86",
        "src_path": "test/test-keyboard.c",
        "class_name": "test.test-keyboard",
        "signature": "test.test-keyboard.test_KBStr2Num()",
        "snippet": "void test_KBStr2Num()\n{\n\tint i;\n\tint ret;\n\n\tstart_testcase( NULL, fd );\n\n\tfor ( i = 0; i < (int)ARRAY_SIZE( KEYBOARD_STRING ); ++i ) {\n\t\t// XXX: chewing_KBStr2Num shall accept const char *.\n\t\tret = chewing_KBStr2Num( KEYBOARD_STRING[i] );\n\t\tok( ret == i, \"%d shall be %d\", ret, i );\n\t}\n}",
        "begin_line": 86,
        "end_line": 98,
        "is_bug": false
    },
    {
        "name": "test.test-keyboard.test_enumerate_keyboard_type#100",
        "src_path": "test/test-keyboard.c",
        "class_name": "test.test-keyboard",
        "signature": "test.test-keyboard.test_enumerate_keyboard_type()",
        "snippet": "void test_enumerate_keyboard_type()\n{\n\tChewingContext *ctx;\n\tsize_t i;\n\tchar *keyboard_string;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tok( chewing_kbtype_Total( ctx ) == ARRAY_SIZE( KEYBOARD_STRING ),\n\t\t\"total keyboard_string type shall be %d\", ARRAY_SIZE( KEYBOARD_STRING ) );\n\n\tchewing_kbtype_Enumerate( ctx );\n\tfor ( i = 0; i < ARRAY_SIZE( KEYBOARD_STRING ); ++i ) {\n\t\tok( chewing_kbtype_hasNext( ctx ) == 1 ,\n\t\t\t\"shall have next keyboard_string type\" );\n\t\tkeyboard_string = chewing_kbtype_String( ctx );\n\t\tok( strcmp( keyboard_string, KEYBOARD_STRING[i] ) == 0,\n\t\t\t\"`%s' shall be `%s'\", keyboard_string, KEYBOARD_STRING[i] );\n\t\tchewing_free( keyboard_string );\n\t}\n\tok( chewing_kbtype_hasNext( ctx ) == 0 ,\n\t\t\"shall not have next keyboard_string type\" );\n\tkeyboard_string = chewing_kbtype_String( ctx );\n\tok( strcmp( keyboard_string, \"\" ) == 0,\n\t\t\"`%s' shall be `%s'\", keyboard_string, \"\" );\n\tchewing_free( keyboard_string );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 100,
        "end_line": 129,
        "is_bug": false
    },
    {
        "name": "test.test-keyboard.test_set_keyboard_type#41",
        "src_path": "test/test-keyboard.c",
        "class_name": "test.test-keyboard",
        "signature": "test.test-keyboard.test_set_keyboard_type()",
        "snippet": "void test_set_keyboard_type()\n{\n\tChewingContext *ctx;\n\tsize_t i;\n\tchar *keyboard_string;\n\tint keyboard_type;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tkeyboard_string = chewing_get_KBString( ctx );\n\tok( strcmp( keyboard_string, KEYBOARD_STRING[KEYBOARD_DEFAULT_TYPE] ) == 0,\n\t\t\"`%s' shall be `%s'\", keyboard_string, KEYBOARD_STRING[KEYBOARD_DEFAULT_TYPE] );\n\tchewing_free( keyboard_string );\n\tkeyboard_type = chewing_get_KBType( ctx );\n\tok( keyboard_type == KEYBOARD_DEFAULT_TYPE ,\n\t\t\"`%d' shall be `%d'\", keyboard_type, KEYBOARD_DEFAULT_TYPE );\n\n\tfor ( i = 0; i < ARRAY_SIZE( KEYBOARD_STRING ); ++i ) {\n\t\tok ( chewing_set_KBType( ctx, i ) == 0, \"return shall be 0\" );\n\n\t\tkeyboard_string = chewing_get_KBString( ctx );\n\t\tok( strcmp( keyboard_string, KEYBOARD_STRING[i] ) == 0,\n\t\t\t\"`%s' shall be `%s'\", keyboard_string, KEYBOARD_STRING[i] );\n\t\tchewing_free( keyboard_string );\n\t\tkeyboard_type = chewing_get_KBType( ctx );\n\t\tok( keyboard_type == (int)i ,\n\t\t\t\"`%d' shall be `%d'\", keyboard_type, (int)i );\n\t}\n\n\t// The invalid KBType will reset KBType to default value.\n\tok( chewing_set_KBType( ctx, -1 ) == -1, \"return shall be -1\" );\n\tkeyboard_type = chewing_get_KBType( ctx );\n\tok( keyboard_type == KEYBOARD_DEFAULT_TYPE ,\n\t\t\"`%d' shall be `%d'\", keyboard_type, KEYBOARD_DEFAULT_TYPE );\n\n\tok( chewing_set_KBType( ctx, ARRAY_SIZE( KEYBOARD_STRING ) + 1 ),\n\t\t\"return shall be -1\" );\n\tkeyboard_type = chewing_get_KBType( ctx );\n\tok( keyboard_type == KEYBOARD_DEFAULT_TYPE ,\n\t\t\"`%d' shall be `%d'\", keyboard_type, KEYBOARD_DEFAULT_TYPE );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 41,
        "end_line": 84,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.main#669",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n\tchar *logname;\n\tint ret;\n\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\tret = asprintf( &logname, \"%s.log\", argv[0] );\n\tif ( ret == -1 ) return -1;\n\tfd = fopen( logname, \"w\" );\n\tassert( fd );\n\tfree( logname );\n\n\n\ttest_cand_open();\n\ttest_cand_close();\n\ttest_cand_choose();\n\ttest_cand_list();\n\n\ttest_commit_preedit();\n\ttest_clean_preedit();\n\n\tfclose( fd );\n\n\treturn exit_status();\n}",
        "begin_line": 669,
        "end_line": 695,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_choose#359",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_choose()",
        "snippet": "void test_cand_choose() {\n\ttest_cand_choose_word();\n\ttest_cand_choose_symbol();\n\ttest_cand_choose_second_layer();\n\ttest_cand_choose_out_of_range();\n\ttest_cand_choose_not_in_select();\n}",
        "begin_line": 359,
        "end_line": 365,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_choose_not_in_select#336",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_choose_not_in_select()",
        "snippet": "void test_cand_choose_not_in_select()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"hk4\" /* \u3118\u311c\u02cb */ );\n\n\tret = chewing_cand_TotalChoice( ctx );\n\tok ( ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_cand_choose_by_index( ctx, 2 );\n\tok ( ret == -1, \"chewing_cand_choose_by_index() returns `%d' shall be `%d'\", ret, -1 );\n\n\tok_preedit_buffer( ctx, \"\\xE5\\x86\\x8A\" /* \u518a */ );\n\n\tchewing_delete( ctx );\n}\n\nvoid ",
        "begin_line": 336,
        "end_line": 357,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_choose_out_of_range#284",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_choose_out_of_range()",
        "snippet": "void test_cand_choose_out_of_range()\n{\n\tChewingContext *ctx;\n\tint ret;\n\tint total_choice;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"hk4\" /* \u3118\u311c\u02cb */ );\n\n\tret = chewing_cand_open( ctx );\n\tok( ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0 );\n\n\ttotal_choice = chewing_cand_TotalChoice( ctx );\n\tok ( total_choice > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", total_choice, 0 );\n\n\tret = chewing_cand_choose_by_index( ctx, total_choice );\n\tok ( ret == -1, \"chewing_cand_choose_by_index() returns `%d' shall be `%d'\", ret, -1 );\n\n\tret = chewing_cand_choose_by_index( ctx, -1 );\n\tok ( ret == -1, \"chewing_cand_choose_by_index() returns `%d' shall be `%d'\", ret, -1 );\n\n\tok_preedit_buffer( ctx, \"\\xE5\\x86\\x8A\" /* \u518a */ );\n\n\tchewing_delete( ctx );\n}\n\nvoid ",
        "begin_line": 284,
        "end_line": 312,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_choose_second_layer#314",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_choose_second_layer()",
        "snippet": "void test_cand_choose_second_layer()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"`\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok ( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0 );\n\tret = chewing_cand_choose_by_index( ctx, 2 );\n\tok ( ret == 0, \"chewing_cand_choose_by_index() returns `%d' shall be `%d'\", ret, 0 );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok ( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0 );\n\tret = chewing_cand_choose_by_index( ctx, 0 );\n\tok ( ret == 0, \"chewing_cand_choose_by_index() returns `%d' shall be `%d'\", ret, 0 );\n\tok_preedit_buffer( ctx, \"\\xEF\\xBC\\x8C\" /* \uff0c */ );\n\n\tchewing_delete( ctx );\n}\n\n",
        "begin_line": 314,
        "end_line": 334,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_choose_symbol#263",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_choose_symbol()",
        "snippet": "void test_cand_choose_symbol()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"`\" /* \uff0c */ );\n\n\tret = chewing_cand_choose_by_index( ctx, 2 );\n\tok ( ret == 0, \"chewing_cand_choose_by_index() returns `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_cand_choose_by_index( ctx, 0 );\n\tok ( ret == 0, \"chewing_cand_choose_by_index() returns `%d' shall be `%d'\", ret, 0 );\n\n\tok_preedit_buffer( ctx, \"\\xEF\\xBC\\x8C\" /* \uff0c */ );\n\n\tchewing_delete( ctx );\n}\n\nvo",
        "begin_line": 263,
        "end_line": 282,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_choose_word#237",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_choose_word()",
        "snippet": "void test_cand_choose_word()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"hk4\" /* \u3118\u311c\u02cb */ );\n\n\tret = chewing_cand_open( ctx );\n\tok( ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_cand_TotalChoice( ctx );\n\tok ( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0 );\n\n\tret = chewing_cand_choose_by_index( ctx, 2 );\n\tok ( ret == 0, \"chewing_cand_choose_by_index() returns `%d' shall be `%d'\", ret, 0 );\n\n\tok_preedit_buffer( ctx, \"\\xE6\\xB8\\xAC\" /* \u6e2c */ );\n\n\tchewing_delete( ctx );\n}\n\nvoid ",
        "begin_line": 237,
        "end_line": 261,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_close#229",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_close()",
        "snippet": "void test_cand_close()\n{\n\ttest_cand_close_word();\n\ttest_cand_close_symbol();\n\ttest_cand_close_already_closed();\n\ttest_cand_close_nothing_in_preedit();\n}",
        "begin_line": 229,
        "end_line": 235,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_close_already_closed#193",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_close_already_closed()",
        "snippet": "void test_cand_close_already_closed()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"hk4\" /* \u3118\u311c\u02cb */ );\n\n\tret = chewing_cand_close( ctx );\n\tok( ret == 0, \"chewing_cand_close() returns `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_cand_TotalChoice( ctx );\n\tok ( ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be 0 than `%d'\", ret, 0 );\n\n\tchewing_delete( ctx );\n}\n\nvoi",
        "begin_line": 193,
        "end_line": 210,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_close_nothing_in_preedit#212",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_close_nothing_in_preedit()",
        "snippet": "void test_cand_close_nothing_in_preedit()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tret = chewing_cand_close( ctx );\n\tok( ret == 0, \"chewing_cand_close() returns `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_cand_TotalChoice( ctx );\n\tok ( ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be 0 than `%d'\", ret, 0 );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 212,
        "end_line": 227,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_close_symbol#166",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_close_symbol()",
        "snippet": "void test_cand_close_symbol()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"`31\" /* \uff0c */ );\n\n\tret = chewing_cand_open( ctx );\n\tok( ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_cand_TotalChoice( ctx );\n\tok ( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0 );\n\n\tret = chewing_cand_close( ctx );\n\tok( ret == 0, \"chewing_cand_close() returns `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_cand_TotalChoice( ctx );\n\tok ( ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be 0 than `%d'\", ret, 0 );\n\n\tok_commit_buffer( ctx, \"\" );\n\n\tchewing_delete( ctx );\n}\n\n",
        "begin_line": 166,
        "end_line": 191,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_close_word#138",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_close_word()",
        "snippet": "void test_cand_close_word()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"hk4\" /* \u3118\u311c\u02cb */ );\n\n\tret = chewing_cand_open( ctx );\n\tok( ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_cand_TotalChoice( ctx );\n\tok ( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0 );\n\n\tret = chewing_cand_close( ctx );\n\tok( ret == 0, \"chewing_cand_close() returns `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_cand_TotalChoice( ctx );\n\tok ( ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be 0 than `%d'\", ret, 0 );\n\n\tok_commit_buffer( ctx, \"\" );\n\n\tchewing_delete( ctx );\n}\n\n\nvo",
        "begin_line": 138,
        "end_line": 163,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_list#530",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_list()",
        "snippet": "void test_cand_list()\n{\n\ttest_cand_list_word_no_rearward();\n\ttest_cand_list_word_rearward();\n\ttest_cand_list_symbol();\n\ttest_cand_list_no_cand_windows();\n}",
        "begin_line": 530,
        "end_line": 536,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_list_no_cand_windows#501",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_list_no_cand_windows()",
        "snippet": "void test_cand_list_no_cand_windows()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4\" /* \u6e2c\u8a66 */ );\n\n\tret = chewing_cand_list_has_next( ctx );\n\tok ( ret == 0, \"chewing_cand_list_has_next() returns `%d' shall be `%d'\", ret, 0 );\n\tret = chewing_cand_list_next( ctx );\n\tok ( ret == -1, \"chewing_cand_list_next() returns `%d' shall be `%d'\", ret, -1 );\n\n\tret = chewing_cand_list_has_prev( ctx );\n\tok ( ret == 0, \"chewing_cand_list_has_prev() returns `%d' shall be `%d'\", ret, 0 );\n\tret = chewing_cand_list_prev( ctx );\n\tok ( ret == -1, \"chewing_cand_list_prev() returns `%d' shall be `%d'\", ret, -1 );\n\n\tret = chewing_cand_list_first( ctx );\n\tok ( ret == -1, \"chewing_cand_list_first() returns `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_cand_list_last( ctx );\n\tok ( ret == -1, \"chewing_cand_list_last() returns `%d' shall be `%d'\", ret, 0 );\n\n\tchewing_delete( ctx );\n}\n\nvo",
        "begin_line": 501,
        "end_line": 528,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_list_symbol#465",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_list_symbol()",
        "snippet": "void test_cand_list_symbol()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\ttype_keystroke_by_string( ctx, \"`31\" /* \uff0c */ );\n\n\tret = chewing_cand_open( ctx );\n\tok ( ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0 );\n\tok_candidate_len( ctx, 1 );\n\n\tret = chewing_cand_list_has_next( ctx );\n\tok ( ret == 0, \"chewing_cand_list_has_next() returns `%d' shall be `%d'\", ret, 0 );\n\tret = chewing_cand_list_next( ctx );\n\tok ( ret == -1, \"chewing_cand_list_has_next() returns `%d' shall be `%d'\", ret, -1 );\n\tok_candidate_len( ctx, 1 );\n\n\tret = chewing_cand_list_has_prev( ctx );\n\tok ( ret == 0, \"chewing_cand_list_has_prev() returns `%d' shall be `%d'\", ret, 0 );\n\tret = chewing_cand_list_prev( ctx );\n\tok ( ret == -1, \"chewing_cand_list_prev() returns `%d' shall be `%d'\", ret, -1 );\n\tok_candidate_len( ctx, 1 );\n\n\tret = chewing_cand_list_first( ctx );\n\tok ( ret == 0, \"chewing_cand_list_first() returns `%d' shall be `%d'\", ret, 0 );\n\tok_candidate_len( ctx, 1 );\n\n\tret = chewing_cand_list_last( ctx );\n\tok ( ret == 0, \"chewing_cand_list_last() returns `%d' shall be `%d'\", ret, 0 );\n\tok_candidate_len( ctx, 1 );\n\n\tchewing_delete( ctx );\n}\n\n",
        "begin_line": 465,
        "end_line": 499,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_list_word_no_rearward#367",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_list_word_no_rearward()",
        "snippet": "void test_cand_list_word_no_rearward()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_phraseChoiceRearward( ctx, 0 );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4<H>\" /* \u6e2c\u8a66 */ );\n\n\tret = chewing_cand_open( ctx );\n\tok ( ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0 );\n\tok_candidate_len( ctx, 2 );\n\n\tret = chewing_cand_list_has_next( ctx );\n\tok ( ret == 1, \"chewing_cand_list_has_next() returns `%d' shall be `%d'\", ret, 1 );\n\tret = chewing_cand_list_next( ctx );\n\tok ( ret == 0, \"chewing_cand_list_next() returns `%d' shall be `%d'\", ret, 0 );\n\tok_candidate_len( ctx, 1 );\n\n\tret = chewing_cand_list_has_next( ctx );\n\tok ( ret == 0, \"chewing_cand_list_has_next() returns `%d' shall be `%d'\", ret, 0 );\n\tret = chewing_cand_list_next( ctx );\n\tok_candidate_len( ctx, 1 );\n\n\tret = chewing_cand_list_has_prev( ctx );\n\tok ( ret == 1, \"chewing_cand_list_has_prev() returns `%d' shall be `%d'\", ret, 1 );\n\tret = chewing_cand_list_prev( ctx );\n\tok ( ret == 0, \"chewing_cand_list_prev() returns `%d' shall be `%d'\", ret, 0 );\n\tok_candidate_len( ctx, 2 );\n\n\tret = chewing_cand_list_has_prev( ctx );\n\tok ( ret == 0, \"chewing_cand_list_has_prev() returns `%d' shall be `%d'\", ret, 0 );\n\tret = chewing_cand_list_prev( ctx );\n\tok ( ret == -1, \"chewing_cand_list_prev() returns `%d' shall be `%d'\", ret, -1 );\n\tok_candidate_len( ctx, 2 );\n\n\tret = chewing_cand_list_last( ctx );\n\tok ( ret == 0, \"chewing_cand_list_last() returns `%d' shall be `%d'\", ret, 0 );\n\tok_candidate_len( ctx, 1 );\n\n\tret = chewing_cand_list_first( ctx );\n\tok ( ret == 0, \"chewing_cand_list_first() returns `%d' shall be `%d'\", ret, 0 );\n\tok_candidate_len( ctx, 2 );\n\n\tchewing_delete( ctx );\n}\n\nvo",
        "begin_line": 367,
        "end_line": 414,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_list_word_rearward#416",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_list_word_rearward()",
        "snippet": "void test_cand_list_word_rearward()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_phraseChoiceRearward( ctx, 1 );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4\" /* \u6e2c\u8a66 */ );\n\n\tret = chewing_cand_open( ctx );\n\tok ( ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0 );\n\tok_candidate_len( ctx, 2 );\n\n\tret = chewing_cand_list_has_next( ctx );\n\tok ( ret == 1, \"chewing_cand_list_has_next() returns `%d' shall be `%d'\", ret, 1 );\n\tret = chewing_cand_list_next( ctx );\n\tok ( ret == 0, \"chewing_cand_list_next() returns `%d' shall be `%d'\", ret, 0 );\n\tok_candidate_len( ctx, 1 );\n\n\tret = chewing_cand_list_has_next( ctx );\n\tok ( ret == 0, \"chewing_cand_list_has_next() returns `%d' shall be `%d'\", ret, 0 );\n\tret = chewing_cand_list_next( ctx );\n\tok_candidate_len( ctx, 1 );\n\n\tret = chewing_cand_list_has_prev( ctx );\n\tok ( ret == 1, \"chewing_cand_list_has_prev() returns `%d' shall be `%d'\", ret, 1 );\n\tret = chewing_cand_list_prev( ctx );\n\tok ( ret == 0, \"chewing_cand_list_prev() returns `%d' shall be `%d'\", ret, 0 );\n\tok_candidate_len( ctx, 2 );\n\n\tret = chewing_cand_list_has_prev( ctx );\n\tok ( ret == 0, \"chewing_cand_list_has_prev() returns `%d' shall be `%d'\", ret, 0 );\n\tret = chewing_cand_list_prev( ctx );\n\tok ( ret == -1, \"chewing_cand_list_prev() returns `%d' shall be `%d'\", ret, -1 );\n\tok_candidate_len( ctx, 2 );\n\n\tret = chewing_cand_list_last( ctx );\n\tok ( ret == 0, \"chewing_cand_list_last() returns `%d' shall be `%d'\", ret, 0 );\n\tok_candidate_len( ctx, 1 );\n\n\tret = chewing_cand_list_first( ctx );\n\tok ( ret == 0, \"chewing_cand_list_first() returns `%d' shall be `%d'\", ret, 0 );\n\tok_candidate_len( ctx, 2 );\n\n\tchewing_delete( ctx );\n}\n\nvo",
        "begin_line": 416,
        "end_line": 463,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_open#129",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_open()",
        "snippet": "void test_cand_open()\n{\n\ttest_cand_open_word();\n\ttest_cand_open_symbol();\n\ttest_cand_open_already_opened();\n\ttest_cand_open_nothing_in_preedit();\n\ttest_cand_open_during_bopomofo();\n}",
        "begin_line": 129,
        "end_line": 136,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_open_already_opened#56",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_open_already_opened()",
        "snippet": "void test_cand_open_already_opened()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"hk4\" /* \u3118\u311c\u02cb */ );\n\n\tret = chewing_cand_open( ctx );\n\tok( ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_cand_TotalChoice( ctx );\n\tok ( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0 );\n\n\t/* FIXME: Need to ensure the candidate windows does not change */\n\tret = chewing_cand_open( ctx );\n\tok( ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_cand_TotalChoice( ctx );\n\tok ( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0 );\n\n\tchewing_delete( ctx );\n}\n\nvoi",
        "begin_line": 56,
        "end_line": 80,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_open_during_bopomofo#99",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_open_during_bopomofo()",
        "snippet": "void test_cand_open_during_bopomofo()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\t/* FIXME: shall we clean bopomofo when chewing_cand_open is called? */\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"hk\" /* \u3118\u311c */ );\n\n\tret = chewing_cand_open( ctx );\n\tok( ret == -1, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, -1 );\n\n\tret = chewing_cand_TotalChoice( ctx );\n\tok ( ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be `%d'\", ret, 0 );\n\n\tchewing_Reset( ctx );\n\n\ttype_keystroke_by_string( ctx, \"hk4g\" /* \u3118\u311c\u02cb \u3115 */ );\n\tret = chewing_cand_open( ctx );\n\tok( ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_cand_TotalChoice( ctx );\n\tok ( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0 );\n\n\tchewing_delete( ctx );\n}\n\nvoid test",
        "begin_line": 99,
        "end_line": 127,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_open_nothing_in_preedit#82",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_open_nothing_in_preedit()",
        "snippet": "void test_cand_open_nothing_in_preedit()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tret = chewing_cand_open( ctx );\n\tok( ret == -1, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, -1 );\n\n\tret = chewing_cand_TotalChoice( ctx );\n\tok ( ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be `%d'\", ret, 0 );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 82,
        "end_line": 97,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_open_symbol#37",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_open_symbol()",
        "snippet": "void test_cand_open_symbol()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"`31\" /* \uff0c */ );\n\n\tret = chewing_cand_open( ctx );\n\tok( ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_cand_TotalChoice( ctx );\n\tok ( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0 );\n\n\tchewing_delete( ctx );\n}\n\n",
        "begin_line": 37,
        "end_line": 54,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_open_word#18",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_open_word()",
        "snippet": "void test_cand_open_word()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"hk4\" /* \u3118\u311c\u02cb */ );\n\n\tret = chewing_cand_open( ctx );\n\tok( ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_cand_TotalChoice( ctx );\n\tok ( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0 );\n\n\tchewing_delete( ctx );\n}\n\nvoi",
        "begin_line": 18,
        "end_line": 35,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_clean_preedit#662",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_clean_preedit()",
        "snippet": "void test_clean_preedit()\n{\n\ttest_clean_preedit_normal();\n\ttest_clean_preedit_empty();\n\ttest_clean_preedit_during_cand_selecting();\n}",
        "begin_line": 662,
        "end_line": 667,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_clean_preedit_during_cand_selecting#639",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_clean_preedit_during_cand_selecting()",
        "snippet": "void test_clean_preedit_during_cand_selecting()\n{\n\tstatic const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */;\n\tChewingContext *ctx;\n\tint ret;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4\" /* \u6e2c\u8a66 */ );\n\n\tret = chewing_cand_open( ctx );\n\tok( ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_clean_preedit_buf( ctx );\n\tok( ret == -1, \"chewing_commit_preedit_buf() returns `%d' shall be `%d'\", ret, -1 );\n\n\tok_preedit_buffer( ctx, phrase );\n\tok_commit_buffer( ctx, \"\" );\n\n\tchewing_delete( ctx );\n}\n\nvoid t",
        "begin_line": 639,
        "end_line": 660,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_clean_preedit_empty#622",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_clean_preedit_empty()",
        "snippet": "void test_clean_preedit_empty()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tret = chewing_clean_preedit_buf( ctx );\n\tok( ret == 0, \"chewing_clean_preedit_buf() returns `%d' shall be `%d'\", ret, 0 );\n\n\tok_preedit_buffer( ctx, \"\" );\n\tok_commit_buffer( ctx, \"\" );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 622,
        "end_line": 637,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_clean_preedit_normal#604",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_clean_preedit_normal()",
        "snippet": "void test_clean_preedit_normal()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4\" /* \u6e2c\u8a66 */ );\n\tret = chewing_clean_preedit_buf( ctx );\n\tok( ret == 0, \"chewing_clean_preedit_buf() returns `%d' shall be `%d'\", ret, 0 );\n\n\tok_preedit_buffer( ctx, \"\" );\n\tok_commit_buffer( ctx, \"\" );\n\n\tchewing_delete( ctx );\n}\n\nvo",
        "begin_line": 604,
        "end_line": 620,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_commit_preedit#597",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_commit_preedit()",
        "snippet": "void test_commit_preedit()\n{\n\ttest_commit_preedit_normal();\n\ttest_commit_preedit_empty();\n\ttest_commit_preedit_during_cand_selecting();\n}",
        "begin_line": 597,
        "end_line": 602,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_commit_preedit_during_cand_selecting#574",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_commit_preedit_during_cand_selecting()",
        "snippet": "void test_commit_preedit_during_cand_selecting()\n{\n\tstatic const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */;\n\tChewingContext *ctx;\n\tint ret;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4\" /* \u6e2c\u8a66 */ );\n\n\tret = chewing_cand_open( ctx );\n\tok( ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_commit_preedit_buf( ctx );\n\tok( ret == -1, \"chewing_commit_preedit_buf() returns `%d' shall be `%d'\", ret, -1 );\n\n\tok_preedit_buffer( ctx, phrase );\n\tok_commit_buffer( ctx, \"\" );\n\n\tchewing_delete( ctx );\n}\n\nvoid t",
        "begin_line": 574,
        "end_line": 595,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_commit_preedit_empty#557",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_commit_preedit_empty()",
        "snippet": "void test_commit_preedit_empty()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tret = chewing_commit_preedit_buf( ctx );\n\tok( ret == -1, \"chewing_commit_preedit_buf() returns `%d' shall be `%d'\", ret, -1 );\n\n\tok_preedit_buffer( ctx, \"\" );\n\tok_commit_buffer( ctx, \"\" );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 557,
        "end_line": 572,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_commit_preedit_normal#538",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_commit_preedit_normal()",
        "snippet": "void test_commit_preedit_normal()\n{\n\tstatic const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */;\n\tChewingContext *ctx;\n\tint ret;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4\" /* \u6e2c\u8a66 */ );\n\tret = chewing_commit_preedit_buf( ctx );\n\tok( ret == 0, \"chewing_commit_preedit_buf() returns `%d' shall be `%d'\", ret, 0 );\n\n\tok_preedit_buffer( ctx, \"\" );\n\tok_commit_buffer( ctx, phrase );\n\n\tchewing_delete( ctx );\n}\n\nvoid t",
        "begin_line": 538,
        "end_line": 555,
        "is_bug": false
    },
    {
        "name": "test.test-logger.main#38",
        "src_path": "test/test-logger.c",
        "class_name": "test.test-logger",
        "signature": "test.test-logger.main( int argc, char *argv[] )",
        "snippet": "int main( int argc, char *argv[] )\n{\n\tchar *logname;\n\tint ret;\n\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\tret = asprintf( &logname, \"%s.log\", argv[0] );\n\tif ( ret == -1 ) return -1;\n\tfd = fopen( logname, \"w\" );\n\tassert( fd );\n\tfree( logname );\n\n\n\ttest_set_null_logger();\n\n\tfclose( fd );\n\n\treturn exit_status();\n}",
        "begin_line": 38,
        "end_line": 58,
        "is_bug": false
    },
    {
        "name": "test.test-logger.test_set_null_logger#25",
        "src_path": "test/test-logger.c",
        "class_name": "test.test-logger",
        "signature": "test.test-logger.test_set_null_logger()",
        "snippet": "void test_set_null_logger()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tchewing_set_logger( ctx, NULL, 0 );\n\ttype_keystroke_by_string( ctx, \"hk4g4\" );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 25,
        "end_line": 36,
        "is_bug": false
    },
    {
        "name": "test.test-mmap.main#51",
        "src_path": "test/test-mmap.c",
        "class_name": "test.test-mmap",
        "signature": "test.test-mmap.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n\tchar *logname;\n\tint ret;\n\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\tret = asprintf( &logname, \"%s.log\", argv[0] );\n\tif ( ret == -1 ) return -1;\n\tfd = fopen( logname, \"w\" );\n\tassert( fd );\n\tfree( logname );\n\n\n\ttest_UnitFromPlatMmap();\n\n\tfclose( fd );\n\n\treturn exit_status();\n}",
        "begin_line": 51,
        "end_line": 71,
        "is_bug": false
    },
    {
        "name": "test.test-mmap.test_UnitFromPlatMmap#25",
        "src_path": "test/test-mmap.c",
        "class_name": "test.test-mmap",
        "signature": "test.test-mmap.test_UnitFromPlatMmap()",
        "snippet": "void test_UnitFromPlatMmap()\n{\n\tunsigned int idx;\n\tplat_mmap m_mmap;\n\tsize_t offset = 0;\n\tsize_t csize;\n\tchar *data_buf;\n\tchar hard_copy[] = \"ji3cp3vu3cj0 vup dj4up <E>\";\n\tint i;\n\n\tstart_testcase( NULL, fd );\n\n\tidx = plat_mmap_create(&m_mmap, TESTDATA, FLAG_ATTRIBUTE_READ);\n\tok (idx == 28, \"plat_mmap_create\");\n\tif (idx > 0) {\n\t\tcsize = idx;\n\t\tdata_buf = (char *) plat_mmap_set_view(&m_mmap, &offset, &csize);\n\t\tfor (i = 0; i < 26; i++) {\n\t\t\tif (data_buf[i] != hard_copy[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tok (i == 26, \"plat_mmap_set_view\");\n\t}\n\tplat_mmap_close( &m_mmap );\n}",
        "begin_line": 25,
        "end_line": 49,
        "is_bug": false
    },
    {
        "name": "test.test-path.main#89",
        "src_path": "test/test-path.c",
        "class_name": "test.test-path",
        "signature": "test.test-path.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n\tchar *logname;\n\tint ret;\n\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\tret = asprintf( &logname, \"%s.log\", argv[0] );\n\tif ( ret == -1 ) return -1;\n\tfd = fopen( logname, \"w\" );\n\tassert( fd );\n\tfree( logname );\n\n\n\ttest_plat_get_search_path();\n\ttest_plat_path_found();\n\ttest_plat_path_cannot_find();\n\n\tfclose( fd);\n\n\treturn exit_status();\n}",
        "begin_line": 89,
        "end_line": 111,
        "is_bug": false
    },
    {
        "name": "test.test-path.test_plat_get_search_path#43",
        "src_path": "test/test-path.c",
        "class_name": "test.test-path",
        "signature": "test.test-path.test_plat_get_search_path()",
        "snippet": "void test_plat_get_search_path()\n{\n\tint ret;\n\tchar output[PATH_MAX];\n\n\tstart_testcase( NULL, fd );\n\n\tputenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n\tret = get_search_path( output, sizeof(output) );\n\tok (ret == 0, \"get_search_path return 0\");\n\tok (!strcmp(output, CHEWING_DATA_PREFIX), \"get_search_path succes\");\n\t// TODO plat specific test\n}",
        "begin_line": 43,
        "end_line": 55,
        "is_bug": false
    },
    {
        "name": "test.test-path.test_plat_path_cannot_find#74",
        "src_path": "test/test-path.c",
        "class_name": "test.test-path",
        "signature": "test.test-path.test_plat_path_cannot_find()",
        "snippet": "void test_plat_path_cannot_find()\n{\n\tint ret;\n\tchar output[ PATH_MAX ];\n\n\tstart_testcase( NULL, fd );\n\n\tret = find_path_by_files(\n\t\t\tCHEWING_DATA_PREFIX \"_no_such_path_1\" SEARCH_PATH_SEP\n\t\t\tCHEWING_DATA_PREFIX \"_no_such_path_2\",\n\t\t\tFILES, output, sizeof( output ) );\n\n\tok( ret != 0, \"find_path_by_files shall not return 0\" );\n}",
        "begin_line": 74,
        "end_line": 87,
        "is_bug": false
    },
    {
        "name": "test.test-path.test_plat_path_found#57",
        "src_path": "test/test-path.c",
        "class_name": "test.test-path",
        "signature": "test.test-path.test_plat_path_found()",
        "snippet": "void test_plat_path_found()\n{\n\tint ret;\n\tchar output[ PATH_MAX ];\n\n\tstart_testcase( NULL, fd );\n\n\tret = find_path_by_files(\n\t\tCHEWING_DATA_PREFIX \"_no_such_path\" SEARCH_PATH_SEP\n\t\tCHEWING_DATA_PREFIX,\n\t\tFILES, output, sizeof( output ) );\n\n\tok( ret == 0, \"find_path_by_files shall return 0\" );\n\tok( strcmp( output, CHEWING_DATA_PREFIX ) == 0,\n\t\t\"output shall be \" CHEWING_DATA_PREFIX );\n}",
        "begin_line": 57,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "test.test-regression.dpp_sighandler#29",
        "src_path": "test/test-regression.c",
        "class_name": "test.test-regression",
        "signature": "test.test-regression.dpp_sighandler(int signum)",
        "snippet": "void dpp_sighandler(int signum) {\n#ifdef DPP_ENABLE_GCOV\n  __gcov_flush();\n#endif\n  sigaction(SIGABRT, &dpp_orig_sigaction, NULL);\n  raise(SIGABRT);\n}",
        "begin_line": 29,
        "end_line": 35,
        "is_bug": false
    },
    {
        "name": "test.test-regression.main#141",
        "src_path": "test/test-regression.c",
        "class_name": "test.test-regression",
        "signature": "test.test-regression.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n\t{\n\t\tdpp_gcov_sigaction.sa_handler = dpp_sighandler;\n\t\tsigemptyset(&dpp_gcov_sigaction.sa_mask);\n\t\tdpp_gcov_sigaction.sa_flags = 0;\n\t\tsigaction(SIGABRT, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n\t}\n\tchar *logname;\n\tint ret;\n\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\tret = asprintf( &logname, \"%s.log\", argv[0] );\n\tif ( ret == -1 ) return -1;\n\tfd = fopen( logname, \"w\" );\n\tassert( fd );\n\tfree( logname );\n\n\n\ttest_libchewing_data_issue_1();\n\ttest_libchewing_issue_30();\n\ttest_libchewing_issue_108();\n\ttest_libchewing_googlecode_issue_472();\n\ttest_libchewing_googlecode_issue_473();\n\n\tfclose( fd );\n\n\treturn exit_status();\n}",
        "begin_line": 141,
        "end_line": 171,
        "is_bug": false
    },
    {
        "name": "test.test-regression.test_libchewing_data_issue_1#125",
        "src_path": "test/test-regression.c",
        "class_name": "test.test-regression",
        "signature": "test.test-regression.test_libchewing_data_issue_1()",
        "snippet": "void test_libchewing_data_issue_1()\n{\n\tconst TestData DATA = { \"e03y.3\", \"\\xE8\\xB6\\x95\\xE8\\xB5\\xB0\" /* \u8d95\u8d70*/ };\n\tChewingContext *ctx;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\ttype_keystroke_by_string( ctx, DATA.token );\n\tok_preedit_buffer( ctx, DATA.expected );\n\n\tchewing_delete( ctx );\n}\n\nin",
        "begin_line": 125,
        "end_line": 139,
        "is_bug": false
    },
    {
        "name": "test.test-regression.test_libchewing_googlecode_issue_472#37",
        "src_path": "test/test-regression.c",
        "class_name": "test.test-regression",
        "signature": "test.test-regression.test_libchewing_googlecode_issue_472()",
        "snippet": "void test_libchewing_googlecode_issue_472()\n{\n\t/* FIXME: Add const cause gcc warning */\n\tstatic char *INPUT[] = {\n\t\t\"<T>|&Wt<H>mrJY)G<C2>OqJ<H><H>Yl<R>p0<EE>QE[^<C1>k\",\n\t\t\"+F<C9>hQ$UIICMr!X8/9<C3>(N<T>yU2!-LUI<D>`CS<D>jShm9SF}<EN>[`QYu<C8>k\",\n\t\t\"hk4`2<D>jk\",\n\t\t\"hk4`j 0\",\n\t\t\"hk4<C0>j 0\",\n\t};\n\tsize_t i;\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_autoShiftCur( ctx, 1 );\n\n\tfor (i = 0; i < ARRAY_SIZE(INPUT); ++i) {\n\t\tchewing_Reset( ctx );\n\t\ttype_keystroke_by_string( ctx, INPUT[i] );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 37,
        "end_line": 61,
        "is_bug": false
    },
    {
        "name": "test.test-regression.test_libchewing_googlecode_issue_473#63",
        "src_path": "test/test-regression.c",
        "class_name": "test.test-regression",
        "signature": "test.test-regression.test_libchewing_googlecode_issue_473()",
        "snippet": "void test_libchewing_googlecode_issue_473()\n{\n\t/* FIXME: Add const cause gcc warning */\n\tstatic char *INPUT[] = {\n\t\t\"t<N->_ M1<N+>H[Ls3<L><N1>PL+Z]4<C1>&(^H*H<TT>Sc<N->P]!|<CB>-<C6>S<H><N1><C0>U<B>d}P!f<EN><N.><C7>V!U!w|4-=S<C1>b<N2>Q\",\n\t\t\"wv<C0><C5><N9>$FIF<D><N4>B *<C2>E4*<C2>q)Kf)<SS><TT>4=<N5>%<R>mN4<EN>H<N9><N.>8s{XTD<N6>jZV(y3G`9<C6>JTy<B>J<C1>SNc<E>hC<SL><N/><R><C6>@an<C3><N7>wzF<C3>P*<N*><B>l<C3><N6>W<N*> $<SR><N.><N1><E><E><N0><N6>Y\",\n\t};\n\tsize_t i;\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_autoShiftCur( ctx, 1 );\n\tchewing_set_candPerPage( ctx, 9 );\n\tchewing_set_addPhraseDirection( ctx, 1 );\n\tchewing_set_spaceAsSelection( ctx, 1 );\n\n\tfor (i = 0; i < ARRAY_SIZE(INPUT); ++i) {\n\t\tchewing_Reset( ctx );\n\t\ttype_keystroke_by_string( ctx, INPUT[i] );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 63,
        "end_line": 87,
        "is_bug": false
    },
    {
        "name": "test.test-regression.test_libchewing_issue_108#110",
        "src_path": "test/test-regression.c",
        "class_name": "test.test-regression",
        "signature": "test.test-regression.test_libchewing_issue_108()",
        "snippet": "void test_libchewing_issue_108()\n{\n\tChewingContext *ctx;\n\tint cursor;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\ttype_keystroke_by_string( ctx, \"yjo4cl3183<E>\");\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 110,
        "end_line": 123,
        "is_bug": false
    },
    {
        "name": "test.test-regression.test_libchewing_issue_30#89",
        "src_path": "test/test-regression.c",
        "class_name": "test.test-regression",
        "signature": "test.test-regression.test_libchewing_issue_30()",
        "snippet": "void test_libchewing_issue_30()\n{\n\tChewingContext *ctx;\n\tint cursor;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_autoShiftCur( ctx, 1 );\n\tchewing_set_spaceAsSelection( ctx, 1 );\n\tchewing_set_phraseChoiceRearward( ctx, 1 );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4<H> 3 1\" );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 2, \"cursor position `%d' shall be `2'\", cursor);\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 89,
        "end_line": 108,
        "is_bug": false
    },
    {
        "name": "test.test-reset.main#44",
        "src_path": "test/test-reset.c",
        "class_name": "test.test-reset",
        "signature": "test.test-reset.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n\tchar *logname;\n\tint ret;\n\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\tret = asprintf( &logname, \"%s.log\", argv[0] );\n\tif ( ret == -1 ) return -1;\n\tfd = fopen( logname, \"w\" );\n\tassert( fd );\n\tfree( logname );\n\n\ttest_reset_shall_not_clean_static_data();\n\n\tfclose( fd );\n\n\treturn exit_status();\n}",
        "begin_line": 44,
        "end_line": 63,
        "is_bug": false
    },
    {
        "name": "test.test-reset.test_reset_shall_not_clean_static_data#24",
        "src_path": "test/test-reset.c",
        "class_name": "test.test-reset",
        "signature": "test.test-reset.test_reset_shall_not_clean_static_data()",
        "snippet": "void test_reset_shall_not_clean_static_data()\n{\n\tconst TestData DATA = { \"hk4g4<E>\", \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ };\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tchewing_set_KBType( ctx, chewing_KBStr2Num( \"KB_DEFAULT\" ) );\n\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\tchewing_Reset( ctx );\n\n\ttype_keystroke_by_string( ctx, DATA.token );\n\tok_commit_buffer( ctx, DATA.expected );\n\n\tchewing_delete( ctx );\n}\n\nin",
        "begin_line": 24,
        "end_line": 42,
        "is_bug": false
    },
    {
        "name": "test.test-special-symbol.is_bopomofo_collision_key#56",
        "src_path": "test/test-special-symbol.c",
        "class_name": "test.test-special-symbol",
        "signature": "test.test-special-symbol.is_bopomofo_collision_key( const char *key )",
        "snippet": "int is_bopomofo_collision_key( const char *key )\n{\n\tstatic const char *COLLISION_KEY[] = {\n\t\t\"<<>\",\n\t\t\">\",\n\t\t\";\",\n\t\t\",\",\n\t\t\".\",\n\t};\n\tsize_t i;\n\n\tfor ( i = 0; i < ARRAY_SIZE( COLLISION_KEY ); ++i ) {\n\t\tif ( strcmp( key, COLLISION_KEY[i] ) == 0 ) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
        "begin_line": 56,
        "end_line": 73,
        "is_bug": false
    },
    {
        "name": "test.test-special-symbol.is_fullshape_collision_key#121",
        "src_path": "test/test-special-symbol.c",
        "class_name": "test.test-special-symbol",
        "signature": "test.test-special-symbol.is_fullshape_collision_key( const char *key )",
        "snippet": "int is_fullshape_collision_key( const char *key )\n{\n\tstatic const char *COLLISION_KEY[] = {\n\t\t\"\\\"\",\n\t\t\"'\",\n\t\t\"/\",\n\t\t\"<<>\",\n\t\t\">\",\n\t\t\"`\",\n\t\t\"[\",\n\t\t\"]\",\n\t\t\"{\",\n\t\t\"}\",\n\t\t\"+\",\n\t\t\"-\",\n\t};\n\tsize_t i;\n\n\tfor ( i = 0; i < ARRAY_SIZE( COLLISION_KEY ); ++i ) {\n\t\tif ( strcmp( key, COLLISION_KEY[i] ) == 0 ) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
        "begin_line": 121,
        "end_line": 145,
        "is_bug": false
    },
    {
        "name": "test.test-special-symbol.main#173",
        "src_path": "test/test-special-symbol.c",
        "class_name": "test.test-special-symbol",
        "signature": "test.test-special-symbol.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n\tchar *logname;\n\tint ret;\n\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\tret = asprintf( &logname, \"%s.log\", argv[0] );\n\tif ( ret == -1 ) return -1;\n\tfd = fopen( logname, \"w\" );\n\tassert( fd );\n\tfree( logname );\n\n\n\ttest_in_chinese_mode();\n\ttest_in_easy_symbol_mode();\n\ttest_in_fullshape_mode();\n\n\tfclose( fd );\n\n\treturn exit_status();\n}",
        "begin_line": 173,
        "end_line": 195,
        "is_bug": false
    },
    {
        "name": "test.test-special-symbol.test_in_chinese_mode#75",
        "src_path": "test/test-special-symbol.c",
        "class_name": "test.test-special-symbol",
        "signature": "test.test-special-symbol.test_in_chinese_mode()",
        "snippet": "void test_in_chinese_mode()\n{\n\tChewingContext *ctx;\n\tsize_t i;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\tfor ( i = 0; i < ARRAY_SIZE( SPECIAL_SYMBOL_TABLE ); ++i ) {\n\t\t// If bopomofo symbol is collided with special symbol, use\n\t\t// bopomofo symbol\n\t\tif ( is_bopomofo_collision_key( SPECIAL_SYMBOL_TABLE[i].token ) )\n\t\t\tcontinue;\n\n\t\ttype_keystroke_by_string( ctx, SPECIAL_SYMBOL_TABLE[i].token );\n\t\tok_preedit_buffer( ctx, SPECIAL_SYMBOL_TABLE[i].expected );\n\t\ttype_keystroke_by_string( ctx, \"<E>\" );\n\t\tok_commit_buffer( ctx, SPECIAL_SYMBOL_TABLE[i].expected );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 75,
        "end_line": 98,
        "is_bug": false
    },
    {
        "name": "test.test-special-symbol.test_in_easy_symbol_mode#100",
        "src_path": "test/test-special-symbol.c",
        "class_name": "test.test-special-symbol",
        "signature": "test.test-special-symbol.test_in_easy_symbol_mode()",
        "snippet": "void test_in_easy_symbol_mode()\n{\n\tChewingContext *ctx;\n\tsize_t i;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_easySymbolInput( ctx, 1 );\n\n\tfor ( i = 0; i < ARRAY_SIZE( SPECIAL_SYMBOL_TABLE ); ++i ) {\n\t\ttype_keystroke_by_string( ctx, SPECIAL_SYMBOL_TABLE[i].token );\n\t\tok_preedit_buffer( ctx, SPECIAL_SYMBOL_TABLE[i].expected );\n\t\ttype_keystroke_by_string( ctx, \"<E>\" );\n\t\tok_commit_buffer( ctx, SPECIAL_SYMBOL_TABLE[i].expected );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 100,
        "end_line": 119,
        "is_bug": false
    },
    {
        "name": "test.test-special-symbol.test_in_fullshape_mode#147",
        "src_path": "test/test-special-symbol.c",
        "class_name": "test.test-special-symbol",
        "signature": "test.test-special-symbol.test_in_fullshape_mode()",
        "snippet": "void test_in_fullshape_mode()\n{\n\tChewingContext *ctx;\n\tsize_t i;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_ChiEngMode( ctx, SYMBOL_MODE );\n\tchewing_set_ShapeMode( ctx, FULLSHAPE_MODE );\n\n\tfor ( i = 0; i < ARRAY_SIZE( SPECIAL_SYMBOL_TABLE ); ++i ) {\n\t\t// If fullshape symbol is collided with special symbol, use\n\t\t// fullshape symbol\n\t\tif ( is_fullshape_collision_key( SPECIAL_SYMBOL_TABLE[i].token ) )\n\t\t\tcontinue;\n\n\t\ttype_keystroke_by_string( ctx, SPECIAL_SYMBOL_TABLE[i].token );\n\t\tok_preedit_buffer( ctx, \"\" );\n\t\tok_commit_buffer( ctx, SPECIAL_SYMBOL_TABLE[i].expected );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 147,
        "end_line": 171,
        "is_bug": false
    },
    {
        "name": "test.test-symbol.main#377",
        "src_path": "test/test-symbol.c",
        "class_name": "test.test-symbol",
        "signature": "test.test-symbol.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n\tchar *logname;\n\tint ret;\n\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\tret = asprintf( &logname, \"%s.log\", argv[0] );\n\tif ( ret == -1 ) return -1;\n\tfd = fopen( logname, \"w\" );\n\tassert( fd );\n\tfree( logname );\n\n\ttest_type_symbol();\n\ttest_symbol_cand_page();\n\n\tfclose( fd );\n\n\treturn exit_status();\n}",
        "begin_line": 377,
        "end_line": 397,
        "is_bug": false
    },
    {
        "name": "test.test-symbol.test_symbol_cand_page#358",
        "src_path": "test/test-symbol.c",
        "class_name": "test.test-symbol",
        "signature": "test.test-symbol.test_symbol_cand_page()",
        "snippet": "void test_symbol_cand_page()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tchewing_set_candPerPage( ctx, 10 );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\tchewing_handle_Default( ctx, '`' );\n\tok( chewing_cand_CurrentPage( ctx ) == 0, \"current page shall be 0\" );\n\tok( chewing_cand_TotalPage( ctx ) == 2, \"total page shall be 2\" );\n\n\tok_candidate( ctx, CAND, ARRAY_SIZE( CAND ) );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 358,
        "end_line": 375,
        "is_bug": false
    },
    {
        "name": "test.test-symbol.test_type_symbol#338",
        "src_path": "test/test-symbol.c",
        "class_name": "test.test-symbol",
        "signature": "test.test-symbol.test_type_symbol()",
        "snippet": "void test_type_symbol()\n{\n\tChewingContext *ctx;\n\tsize_t i;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tchewing_set_candPerPage( ctx, 10 );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\tfor (i = 0; i < ARRAY_SIZE(SYMBOL); ++i ) {\n\t\ttype_keystroke_by_string( ctx, SYMBOL[i].token );\n\t\tok_preedit_buffer( ctx, \"\" );\n\t\tok_commit_buffer( ctx, SYMBOL[i].expected );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 338,
        "end_line": 356,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.main#641",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n\tchar *logname;\n\tint ret;\n\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\tret = asprintf( &logname, \"%s.log\", argv[0] );\n\tif ( ret == -1 ) return -1;\n\tfd = fopen( logname, \"w\" );\n\tassert( fd );\n\tfree( logname );\n\n\ttest_ShiftLeft();\n\ttest_ShiftRight();\n\ttest_CtrlNum();\n\ttest_userphrase();\n\ttest_userphrase_enumerate();\n\ttest_userphrase_manipulate();\n\ttest_userphrase_lookup();\n\n\tfclose( fd );\n\n\treturn exit_status();\n}",
        "begin_line": 641,
        "end_line": 666,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_CtrlNum#233",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_CtrlNum()",
        "snippet": "void test_CtrlNum()\n{\n\ttest_CtrlNum_add_phrase_right();\n\ttest_CtrlNum_add_phrase_left();\n\ttest_CtrlNum_add_phrase_right_symbol_in_between();\n\ttest_CtrlNum_add_phrase_left_symbol_in_between();\n}",
        "begin_line": 233,
        "end_line": 239,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_CtrlNum_add_phrase_left#148",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_CtrlNum_add_phrase_left()",
        "snippet": "void test_CtrlNum_add_phrase_left()\n{\n\tstatic const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */;\n\tstatic const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\" /* \u3118\u311c\u02cb \u3115\u02cb */;\n\tstatic const char msg_add[] = \"\\xE5\\x8A\\xA0\\xE5\\x85\\xA5\\xEF\\xBC\\x9A\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u52a0\u5165\uff1a\u6e2c\u8a66 */;\n\tstatic const char msg_already_have[] = \"\\xE5\\xB7\\xB2\\xE6\\x9C\\x89\\xEF\\xBC\\x9A\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u5df2\u6709\uff1a\u6e2c\u8a66 */;\n\tint cursor;\n\tChewingContext *ctx;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_addPhraseDirection( ctx, 1 );\n\n\tok( has_userphrase( ctx, bopomofo, phrase ) == 0,\n\t\t\"`%s' shall not be in userphrase\", phrase );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4<C2>\" );\n\tok_aux_buffer( ctx, msg_add );\n\tok_preedit_buffer( ctx, phrase );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 2, \"cursor position `%d' shall be 2\", cursor );\n\tok( has_userphrase( ctx, bopomofo, phrase ) == 1,\n\t\t\"`%s' shall be in userphrase\", phrase );\n\n\ttype_keystroke_by_string( ctx, \"<C2>\" );\n\tok_aux_buffer( ctx, msg_already_have );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_CtrlNum_add_phrase_r",
        "begin_line": 148,
        "end_line": 179,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_CtrlNum_add_phrase_left_symbol_in_between#207",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_CtrlNum_add_phrase_left_symbol_in_between()",
        "snippet": "void test_CtrlNum_add_phrase_left_symbol_in_between()\n{\n\tstatic const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\" /* \u3118\u311c\u02cb \u3115\u02cb */;\n\tint cursor;\n\tChewingContext *ctx;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_addPhraseDirection( ctx, 1 );\n\n\tok( has_userphrase( ctx, bopomofo, NULL ) == 0,\n\t\t\"`%s' shall not be in userphrase\", bopomofo );\n\n\ttype_keystroke_by_string( ctx, \"hk4`1g4<C2>\" );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 3, \"cursor position `%d' shall be 3\", cursor );\n\n\tok( has_userphrase( ctx, bopomofo, NULL ) == 0,\n\t\t\"`%s' shall not be in userphrase\", bopomofo );\n\n\tchewing_delete( ctx );\n}\n\nvoid t",
        "begin_line": 207,
        "end_line": 231,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_CtrlNum_add_phrase_right#115",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_CtrlNum_add_phrase_right()",
        "snippet": "void test_CtrlNum_add_phrase_right()\n{\n\tstatic const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */;\n\tstatic const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\" /* \u3118\u311c\u02cb \u3115\u02cb */;\n\tstatic const char msg[] = \"\\xE5\\x8A\\xA0\\xE5\\x85\\xA5\\xEF\\xBC\\x9A\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u52a0\u5165\uff1a\u6e2c\u8a66 */;\n\tstatic const char msg_already_have[] = \"\\xE5\\xB7\\xB2\\xE6\\x9C\\x89\\xEF\\xBC\\x9A\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u5df2\u6709\uff1a\u6e2c\u8a66 */;\n\tint cursor;\n\tChewingContext *ctx;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_addPhraseDirection( ctx, 0 );\n\n\tok( has_userphrase( ctx, bopomofo, phrase ) == 0,\n\t\t\"`%s' shall not be in userphrase\", phrase );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4<H><C2>\" );\n\tok_aux_buffer( ctx, msg );\n\tok_preedit_buffer( ctx, phrase );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 0, \"cursor position `%d' shall be 0\", cursor );\n\tok( has_userphrase( ctx, bopomofo, phrase ) == 1,\n\t\t\"`%s' shall be in userphrase\", phrase );\n\n\ttype_keystroke_by_string( ctx, \"<C2>\" );\n\tok_aux_buffer( ctx, msg_already_have );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_CtrlNum_add_phrase_l",
        "begin_line": 115,
        "end_line": 146,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_CtrlNum_add_phrase_right_symbol_in_between#181",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_CtrlNum_add_phrase_right_symbol_in_between()",
        "snippet": "void test_CtrlNum_add_phrase_right_symbol_in_between()\n{\n\tstatic const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\" /* \u3118\u311c\u02cb \u3115\u02cb */;\n\tint cursor;\n\tChewingContext *ctx;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_addPhraseDirection( ctx, 0 );\n\n\tok( has_userphrase( ctx, bopomofo, NULL ) == 0,\n\t\t\"`%s' shall not be in userphrase\", bopomofo );\n\n\ttype_keystroke_by_string( ctx, \"hk4`1g4<H><C2>\" );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 0, \"cursor position `%d' shall be 0\", cursor );\n\n\tok( has_userphrase( ctx, bopomofo, NULL ) == 0,\n\t\t\"`%s' shall not be in userphrase\", bopomofo );\n\n\tchewing_delete( ctx );\n}\n\nvoid t",
        "begin_line": 181,
        "end_line": 205,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_ShiftLeft#65",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_ShiftLeft()",
        "snippet": "void test_ShiftLeft()\n{\n\ttest_ShiftLeft_not_entering_chewing();\n\ttest_ShiftLeft_add_userphrase();\n}",
        "begin_line": 65,
        "end_line": 69,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_ShiftLeft_add_userphrase#39",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_ShiftLeft_add_userphrase()",
        "snippet": "void test_ShiftLeft_add_userphrase()\n{\n\tstatic const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */;\n\tstatic const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\" /* \u3118\u311c\u02cb \u3115\u02cb */;\n\tint cursor;\n\tChewingContext *ctx;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\tok( has_userphrase( ctx, bopomofo, phrase ) == 0,\n\t\t\"`%s' shall not be in userphrase\", phrase );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4<SL><SL><E>\" );\n\tok_preedit_buffer( ctx, phrase );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 0, \"cursor position `%d' shall be 0\", cursor );\n\tok( has_userphrase( ctx, bopomofo, phrase ) == 1,\n\t\t\"`%s' shall be in userphrase\", phrase );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_",
        "begin_line": 39,
        "end_line": 63,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_ShiftLeft_not_entering_chewing#27",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_ShiftLeft_not_entering_chewing()",
        "snippet": "void test_ShiftLeft_not_entering_chewing()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\ttype_keystroke_by_string( ctx, \"<SL>\" );\n\tok_keystroke_rtn( ctx, KEYSTROKE_IGNORE );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 27,
        "end_line": 37,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_ShiftRight#109",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_ShiftRight()",
        "snippet": "void test_ShiftRight()\n{\n\ttest_ShiftRight_not_entering_chewing();\n\ttest_ShiftRight_add_userphrase();\n}",
        "begin_line": 109,
        "end_line": 113,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_ShiftRight_add_userphrase#83",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_ShiftRight_add_userphrase()",
        "snippet": "void test_ShiftRight_add_userphrase()\n{\n\tstatic const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */;\n\tstatic const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\" /* \u3118\u311c\u02cb \u3115\u02cb */;\n\tint cursor;\n\tChewingContext *ctx;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\tok( has_userphrase( ctx, bopomofo, phrase ) == 0,\n\t\t\"`%s' shall not be in userphrase\", phrase );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4<L><L><SR><SR><E>\" );\n\tok_preedit_buffer( ctx, phrase );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 2, \"cursor position `%d' shall be 2\", cursor );\n\tok( has_userphrase( ctx, bopomofo, phrase ) == 1,\n\t\t\"`%s' shall be in userphrase\", phrase );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_",
        "begin_line": 83,
        "end_line": 107,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_ShiftRight_not_entering_chewing#71",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_ShiftRight_not_entering_chewing()",
        "snippet": "void test_ShiftRight_not_entering_chewing()\n{\n\tChewingContext *ctx;\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\ttype_keystroke_by_string( ctx, \"<SR>\" );\n\tok_keystroke_rtn( ctx, KEYSTROKE_IGNORE );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 71,
        "end_line": 81,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase#287",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase()",
        "snippet": "void test_userphrase()\n{\n\ttest_userphrase_auto_learn();\n\ttest_userphrase_auto_learn_hardcode_break();\n}",
        "begin_line": 287,
        "end_line": 291,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_auto_learn#241",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_auto_learn()",
        "snippet": "void test_userphrase_auto_learn()\n{\n\tstatic const char bopomofo[] = \"\\xE3\\x84\\x8E\\xE3\\x84\\x9C \\xE3\\x84\\x8E\\xE3\\x84\\x9C\" /* \u310e\u311c \u310e\u311c */;\n\tChewingContext *ctx;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_addPhraseDirection( ctx, 1 );\n\n\tok( has_userphrase( ctx, bopomofo, NULL ) == 0,\n\t\t\"`%s' shall not be in userphrase\", bopomofo );\n\n\ttype_keystroke_by_string( ctx, \"dk dk <E>\" );\n\tok( has_userphrase( ctx, bopomofo, NULL ) == 1,\n\t\t\"`%s' shall be in userphrase\", bopomofo );\n\n\tchewing_delete( ctx );\n}\n\nvoid t",
        "begin_line": 241,
        "end_line": 261,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_auto_learn_hardcode_break#263",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_auto_learn_hardcode_break()",
        "snippet": "void test_userphrase_auto_learn_hardcode_break()\n{\n\t/* \u7684 is a hardcode break point, see ChewingIsBreakPoint */\n\tstatic const char phrase[] = \"\\xE7\\x9A\\x84\\xE7\\x9A\\x84\" /* \u7684\u7684 */;\n\tstatic const char bopomofo[] = \"\\xE3\\x84\\x89\\xE3\\x84\\x9C\\xCB\\x99 \\xE3\\x84\\x89\\xE3\\x84\\x9C\\xCB\\x99\" /* \u3109\u311c\u02d9 \u3109\u311c\u02d9 */;\n\tChewingContext *ctx;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_addPhraseDirection( ctx, 1 );\n\n\tok( has_userphrase( ctx, bopomofo, phrase ) == 0,\n\t\t\"`%s' shall not be in userphrase\", phrase );\n\n\ttype_keystroke_by_string( ctx, \"2k72k7<E>\" );\n\tok( has_userphrase( ctx, bopomofo, phrase ) == 0,\n\t\t\"`%s' shall not be in userphrase\", phrase );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_user",
        "begin_line": 263,
        "end_line": 285,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_enumerate#418",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_enumerate()",
        "snippet": "void test_userphrase_enumerate()\n{\n\ttest_userphrase_enumerate_normal();\n\ttest_userphrase_enumerate_empty();\n\ttest_userphrase_enumerate_rewind();\n}",
        "begin_line": 418,
        "end_line": 423,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_enumerate_empty#337",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_enumerate_empty()",
        "snippet": "void test_userphrase_enumerate_empty()\n{\n\tChewingContext *ctx;\n\tint ret;\n\tconst char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */;\n\tunsigned int phrase_len;\n\tconst char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\"; /* \u3118\u311c\u02cb \u3115\u02cb */\n\tunsigned int bopomofo_len;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tret = chewing_userphrase_lookup( ctx, phrase, bopomofo );\n\tok( ret == 0, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_userphrase_enumerate( ctx );\n\tok( ret == 0, \"chewing_userphrase_enumerate() return value `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_userphrase_has_next( ctx, &phrase_len, &bopomofo_len );\n\tok( ret == 0, \"chewing_userphrase_has_next() return value `%d' shall be `%d'\", ret, 0 );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_",
        "begin_line": 337,
        "end_line": 361,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_enumerate_normal#293",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_enumerate_normal()",
        "snippet": "void test_userphrase_enumerate_normal()\n{\n\tChewingContext *ctx;\n\tint ret;\n\tunsigned int expect_len;\n\n\tconst char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */;\n\tchar phrase_buf[50];\n\tunsigned int phrase_len;\n\n\tconst char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\"; /* \u3118\u311c\u02cb \u3115\u02cb */\n\tchar bopomofo_buf[50];\n\tunsigned int bopomofo_len;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tret = chewing_userphrase_add( ctx, phrase, bopomofo );\n\tok( ret == 0, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 0 );\n\tret = chewing_userphrase_lookup( ctx, phrase, bopomofo );\n\tok( ret == 1, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 1 );\n\n\tret = chewing_userphrase_enumerate( ctx );\n\tok( ret == 0, \"chewing_userphrase_enumerate() return value `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_userphrase_has_next( ctx, &phrase_len, &bopomofo_len );\n\tok( ret == 1, \"chewing_userphrase_has_next() return value `%d' shall be `%d'\", ret, 1 );\n\texpect_len = strlen(phrase) + 1;\n\tok( phrase_len >= expect_len, \"chewing_userphrase_has_next() shall set phrase_len `%d' >= `%d'\", phrase_len, expect_len );\n\texpect_len = strlen(bopomofo) + 1;\n\tok( bopomofo_len >= expect_len, \"chewing_userphrase_has_next() shall set bopomofo_len `%d' >= `%d'\", bopomofo_len, expect_len );\n\tret = chewing_userphrase_get( ctx, phrase_buf, sizeof( phrase_buf ), bopomofo_buf, sizeof( bopomofo_buf ) );\n\tok( ret == 0, \"chewing_userphrase_get() return value `%d' shall be `%d'\", ret, 0 );\n\tok( strcmp( phrase_buf, phrase ) == 0, \"chewing_userphrase_get() shall set phrase_buf `%s' to `%s'\", phrase_buf, phrase );\n\tok( strcmp( bopomofo_buf, bopomofo ) == 0, \"chewing_userphrase_get() shall set bopomofo_buf `%s' to `%s'\", bopomofo_buf, bopomofo );\n\n\tret = chewing_userphrase_has_next( ctx, &phrase_len, &bopomofo_len );\n\tok( ret == 0, \"chewing_userphrase_has_next() return value `%d' shall be `%d'\", ret, 0 );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_",
        "begin_line": 293,
        "end_line": 335,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_enumerate_rewind#363",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_enumerate_rewind()",
        "snippet": "void test_userphrase_enumerate_rewind()\n{\n\tChewingContext *ctx;\n\tint ret;\n\tunsigned int expect_len;\n\n\tconst char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */;\n\tchar phrase_buf[50];\n\tunsigned int phrase_len;\n\n\tconst char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\"; /* \u3118\u311c\u02cb \u3115\u02cb */\n\tchar bopomofo_buf[50];\n\tunsigned int bopomofo_len;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tret = chewing_userphrase_add( ctx, phrase, bopomofo );\n\tok( ret == 0, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 0 );\n\tret = chewing_userphrase_lookup( ctx, phrase, bopomofo );\n\tok( ret == 1, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 1 );\n\n\tret = chewing_userphrase_enumerate( ctx );\n\tok( ret == 0, \"chewing_userphrase_enumerate() return value `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_userphrase_has_next( ctx, &phrase_len, &bopomofo_len );\n\tok( ret == 1, \"chewing_userphrase_has_next() return value `%d' shall be `%d'\", ret, 1 );\n\texpect_len = strlen(phrase) + 1;\n\tok( phrase_len >= expect_len, \"chewing_userphrase_has_next() shall set phrase_len `%d' >= `%d'\", phrase_len, expect_len );\n\texpect_len = strlen(bopomofo) + 1;\n\tok( bopomofo_len >= expect_len, \"chewing_userphrase_has_next() shall set bopomofo_len `%d' >= `%d'\", bopomofo_len, expect_len );\n\tret = chewing_userphrase_get( ctx, phrase_buf, sizeof( phrase_buf ), bopomofo_buf, sizeof( bopomofo_buf ) );\n\tok( ret == 0, \"chewing_userphrase_get() return value `%d' shall be `%d'\", ret, 0 );\n\tok( strcmp( phrase_buf, phrase ) == 0, \"chewing_userphrase_get() shall set phrase_buf `%s' to `%s'\", phrase_buf, phrase );\n\tok( strcmp( bopomofo_buf, bopomofo ) == 0, \"chewing_userphrase_get() shall set bopomofo_buf `%s' to `%s'\", bopomofo_buf, bopomofo );\n\n\tret = chewing_userphrase_enumerate( ctx );\n\tok( ret == 0, \"chewing_userphrase_enumerate() return value `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_userphrase_has_next( ctx, &phrase_len, &bopomofo_len );\n\tok( ret == 1, \"chewing_userphrase_has_next() return value `%d' shall be `%d'\", ret, 1 );\n\texpect_len = strlen(phrase) + 1;\n\tok( phrase_len >= expect_len, \"chewing_userphrase_has_next() shall set phrase_len `%d' >= `%d'\", phrase_len, expect_len );\n\texpect_len = strlen(bopomofo) + 1;\n\tok( bopomofo_len >= expect_len, \"chewing_userphrase_has_next() shall set bopomofo_len `%d' >= `%d'\", bopomofo_len, expect_len );\n\tret = chewing_userphrase_get( ctx, phrase_buf, sizeof( phrase_buf ), bopomofo_buf, sizeof( bopomofo_buf ) );\n\tok( ret == 0, \"chewing_userphrase_get() return value `%d' shall be `%d'\", ret, 0 );\n\tok( strcmp( phrase_buf, phrase ) == 0, \"chewing_userphrase_get() shall set phrase_buf `%s' to `%s'\", phrase_buf, phrase );\n\tok( strcmp( bopomofo_buf, bopomofo ) == 0, \"chewing_userphrase_get() shall set bopomofo_buf `%s' to `%s'\", bopomofo_buf, bopomofo );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_",
        "begin_line": 363,
        "end_line": 416,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_lookup#618",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_lookup()",
        "snippet": "void test_userphrase_lookup()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tret = chewing_userphrase_lookup( ctx,\n\t\t\"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */,\n\t\t\"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B\" /* \u3118\u311c\u02cb */ );\n\tok( ret == 0, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_userphrase_lookup( ctx,\n\t\t\"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */,\n\t\t\"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xCB\\x8B\\xE3\\x84\\x95\" /* \u3118\u311c\u02cb \u02cb\u3115 */ );\n\tok( ret == 0, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 0 );\n\n\tchewing_delete( ctx );\n}\n\nint main(int argc, ",
        "begin_line": 618,
        "end_line": 639,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_manipulate#609",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_manipulate()",
        "snippet": "void test_userphrase_manipulate()\n{\n\ttest_userphrase_manipulate_normal();\n\ttest_userphrase_manipulate_hash_collision();\n\ttest_userphrase_manipulate_error_handling();\n\ttest_userphrase_manipulate_remove_same_phone();\n\ttest_userphrase_manipulate_remove_same_phrase();\n}",
        "begin_line": 609,
        "end_line": 616,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_manipulate_error_handling#511",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_manipulate_error_handling()",
        "snippet": "void test_userphrase_manipulate_error_handling()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tret = chewing_userphrase_add( ctx,\n\t\t\"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */,\n\t\t\"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B\" /* \u3118\u311c\u02cb */ );\n\tok( ret == -1, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, -1 );\n\n\tret = chewing_userphrase_add( ctx,\n\t\t\"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */,\n\t\t\"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xCB\\x8B\\xE3\\x84\\x95\" /* \u3118\u311c\u02cb \u02cb\u3115 */ );\n\tok( ret == -1, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, -1 );\n\n\tret = chewing_userphrase_remove( ctx,\n\t\t\"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */,\n\t\t\"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xCB\\x8B\\xE3\\x84\\x95\" /* \u3118\u311c\u02cb \u02cb\u3115 */ );\n\tok( ret == -1, \"chewing_userphrase_remove() return value `%d' shall be `%d'\", ret, -1 );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_userphrase_manipulate",
        "begin_line": 511,
        "end_line": 537,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_manipulate_hash_collision#460",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_manipulate_hash_collision()",
        "snippet": "void test_userphrase_manipulate_hash_collision()\n{\n\tChewingContext *ctx;\n\t/* \u6e2c\u8a66 */\n\tconst char phrase_1[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\";\n\n\t/* \u3118\u311c\u02cb \u3115\u02cb */\n\tconst char bopomofo_1[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\";\n\n\t/* \u6e2c\u8a66\u6e2c\u8a66\u6e2c\u8a66 */\n\tconst char phrase_2[] =\n\t\t\"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\"\n\t\t\"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\"\n\t\t\"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\";\n\n\t/* \u3118\u311c\u02cb \u3115\u02cb \u3118\u311c\u02cb \u3115\u02cb \u3118\u311c\u02cb \u3115\u02cb */\n\tconst char bopomofo_2[] =\n\t\t\"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B \"\n\t\t\"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B \"\n\t\t\"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\";\n\n\tint ret;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tret = chewing_userphrase_add( ctx, phrase_1, bopomofo_1 );\n\tok( ret == 0, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 0 );\n\tret = chewing_userphrase_add( ctx, phrase_2, bopomofo_2 );\n\tok( ret == 0, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_userphrase_lookup( ctx, phrase_1, bopomofo_1 );\n\tok( ret == 1, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 1 );\n\tret = chewing_userphrase_lookup( ctx, phrase_2, bopomofo_2 );\n\tok( ret == 1, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 1 );\n\n\tret = chewing_userphrase_remove( ctx, phrase_1, bopomofo_1 );\n\tok( ret == 0, \"chewing_userphrase_remove() return value `%d' shall be `%d'\", ret, 0 );\n\tret = chewing_userphrase_remove( ctx, phrase_2, bopomofo_2 );\n\tok( ret == 0, \"chewing_userphrase_remove() return value `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_userphrase_lookup( ctx, phrase_1, bopomofo_1 );\n\tok( ret == 0, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 0 );\n\tret = chewing_userphrase_lookup( ctx, phrase_2, bopomofo_2 );\n\tok( ret == 0, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 0 );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_userphrase_manipulate_error_handling",
        "begin_line": 460,
        "end_line": 509,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_manipulate_normal#425",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_manipulate_normal()",
        "snippet": "void test_userphrase_manipulate_normal()\n{\n\tChewingContext *ctx;\n\tconst char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */;\n\tconst char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\"; /* \u3118\u311c\u02cb \u3115\u02cb */\n\tint ret;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\tret = chewing_userphrase_lookup( ctx, phrase, bopomofo );\n\tok( ret == 0, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_userphrase_add( ctx, phrase, bopomofo );\n\tok( ret == 0, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 0 );\n\tret = chewing_userphrase_lookup( ctx, phrase, bopomofo );\n\tok( ret == 1, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 1 );\n\n\tret = chewing_userphrase_remove( ctx, phrase, bopomofo );\n\tok( ret == 0, \"chewing_userphrase_remove() return value `%d' shall be `%d'\", ret, 0 );\n\tret = chewing_userphrase_lookup( ctx, phrase, bopomofo );\n\tok( ret == 0, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 0 );\n\n\tchewing_delete( ctx );\n\n\t/* New chewing instance shall not have remove userphrase. */\n\tctx = chewing_new();\n\n\tret = chewing_userphrase_lookup( ctx, phrase, bopomofo );\n\tok( ret == 0, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 0 );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_",
        "begin_line": 425,
        "end_line": 458,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_manipulate_remove_same_phone#539",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_manipulate_remove_same_phone()",
        "snippet": "void test_userphrase_manipulate_remove_same_phone()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tconst char phrase_1[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */;\n\tconst char phrase_2[] = \"\\xE5\\x81\\xB4\\xE5\\xAE\\xA4\" /* \u5074\u5ba4 */;\n\tconst char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\" /* \u3118\u311c\u02cb \u3115\u02cb */;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tret = chewing_userphrase_add( ctx, phrase_1, bopomofo );\n\tok( ret == 0, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 0 );\n\tret = chewing_userphrase_add( ctx, phrase_2, bopomofo );\n\tok( ret == 0, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_userphrase_lookup( ctx, phrase_1, bopomofo );\n\tok( ret == 1, \"chewing_lookup() return value `%d' shall be `%d'\", ret, 1 );\n\tret = chewing_userphrase_lookup( ctx, phrase_2, bopomofo );\n\tok( ret == 1, \"chewing_lookup() return value `%d' shall be `%d'\", ret, 1 );\n\n\tret = chewing_userphrase_remove( ctx, phrase_1, bopomofo );\n\tok( ret == 0, \"chewing_userphrase_remove() return value `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_userphrase_lookup( ctx, phrase_1, bopomofo );\n\tok( ret == 0, \"chewing_lookup() return value `%d' shall be `%d'\", ret, 0 );\n\tret = chewing_userphrase_lookup( ctx, phrase_2, bopomofo );\n\tok( ret == 1, \"chewing_lookup() return value `%d' shall be `%d'\", ret, 1 );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_user",
        "begin_line": 539,
        "end_line": 572,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_manipulate_remove_same_phrase#574",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_manipulate_remove_same_phrase()",
        "snippet": "void test_userphrase_manipulate_remove_same_phrase()\n{\n\tChewingContext *ctx;\n\tint ret;\n\n\tconst char phrase[] = \"\\xE4\\xBB\\x80\\xE9\\xBA\\xBC\" /* \u4ec0\u9ebc */;\n\tconst char bopomofo_1[] = \"\\xE3\\x84\\x95\\xE3\\x84\\xA3\\xCB\\x8A \\xE3\\x84\\x87\\xE3\\x84\\x9C\\xCB\\x99\" /* \u3115\u3123\u02ca \u3107\u311c\u02d9 */;\n\tconst char bopomofo_2[] = \"\\xE3\\x84\\x95\\xE3\\x84\\x9C\\xCB\\x8A \\xE3\\x84\\x87\\xE3\\x84\\x9C\\xCB\\x99\" /* \u3115\u311c\u02ca \u3107\u311c\u02d9 */;\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tstart_testcase( ctx, fd );\n\n\tret = chewing_userphrase_add( ctx, phrase, bopomofo_1 );\n\tok( ret == 0, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 0 );\n\tret = chewing_userphrase_add( ctx, phrase, bopomofo_2 );\n\tok( ret == 0, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_userphrase_lookup( ctx, phrase, bopomofo_1 );\n\tok( ret == 1, \"chewing_lookup() return value `%d' shall be `%d'\", ret, 1 );\n\tret = chewing_userphrase_lookup( ctx, phrase, bopomofo_2 );\n\tok( ret == 1, \"chewing_lookup() return value `%d' shall be `%d'\", ret, 1 );\n\n\tret = chewing_userphrase_remove( ctx, phrase, bopomofo_1 );\n\tok( ret == 0, \"chewing_userphrase_remove() return value `%d' shall be `%d'\", ret, 0 );\n\n\tret = chewing_userphrase_lookup( ctx, phrase, bopomofo_1 );\n\tok( ret == 0, \"chewing_lookup() return value `%d' shall be `%d'\", ret, 0 );\n\tret = chewing_userphrase_lookup( ctx, phrase, bopomofo_2 );\n\tok( ret == 1, \"chewing_lookup() return value `%d' shall be `%d'\", ret, 1 );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_userphrase_m",
        "begin_line": 574,
        "end_line": 607,
        "is_bug": false
    },
    {
        "name": "test.test-utf8.main#52",
        "src_path": "test/test-utf8.c",
        "class_name": "test.test-utf8",
        "signature": "test.test-utf8.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n\tchar *logname;\n\tint ret;\n\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\tret = asprintf( &logname, \"%s.log\", argv[0] );\n\tif ( ret == -1 ) return -1;\n\tfd = fopen( logname, \"w\" );\n\tassert( fd );\n\tfree( logname );\n\n\ttest_utf8();\n\n\tfclose( fd );\n\n\treturn exit_status();\n}",
        "begin_line": 52,
        "end_line": 71,
        "is_bug": false
    },
    {
        "name": "test.test-utf8.test_utf8#20",
        "src_path": "test/test-utf8.c",
        "class_name": "test.test-utf8",
        "signature": "test.test-utf8.test_utf8()",
        "snippet": "void test_utf8()\n{\n\tchar *u8string;\n\tint u8len;\n\tint len;\n\tchar u8string2[16];\n\n\tstart_testcase( NULL, fd );\n\n\tu8string = \"HelloWorld\";\n\tu8len = ueStrLen(u8string);\n\tlen = strlen(u8string);\n\tok (u8len == len, \"ueStrLen\");\n\n\tu8string = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE8\\xA8\\x88\\xE7\\xAE\\x97\\xE9\\x95\\xB7\\xE5\\xBA\\xA6\"; /* \u6e2c\u8a66\u8a08\u7b97\u9577\u5ea6 */\n\tu8len = ueStrLen(u8string);\n\tok (u8len == 6, \"ueStrLen\");\n\n\tu8string = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE8\\xA8\\x88\\xE7\\xAE\\x97\\xE9\\x95\\xB7\\xE5\\xBA\\xA6\"; /* \u6e2c\u8a66\u8a08\u7b97\u9577\u5ea6 */\n\tueStrNCpy(u8string2, u8string, 3, STRNCPY_CLOSE);\n\tok (!strcmp(u8string2, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE8\\xA8\\x88\" /* \u6e2c\u8a66\u8a08 */ ), \"ueStrNCpy\");\n\n\tu8string = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE8\\xA8\\x88\\xE7\\xAE\\x97\\xE9\\x95\\xB7\\xE5\\xBA\\xA6\"; /* \u6e2c\u8a66\u8a08\u7b97\u9577\u5ea6 */\n\tu8string = ueStrSeek(u8string, 3);\n\tok (!strcmp(u8string, \"\\xE7\\xAE\\x97\\xE9\\x95\\xB7\\xE5\\xBA\\xA6\" /* \u7b97\u9577\u5ea6 */ ), \"ueStrSeek\");\n\n\tu8string = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE8\\xA8\\x88\\xE7\\xAE\\x97\\xE9\\x95\\xB7\\xE5\\xBA\\xA6\"; /* \u6e2c\u8a66\u8a08\u7b97\u9577\u5ea6 */\n\tu8string = ueStrSeek(u8string, 0);\n\tok (!strcmp(u8string, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE8\\xA8\\x88\\xE7\\xAE\\x97\\xE9\\x95\\xB7\\xE5\\xBA\\xA6\" /* \u6e2c\u8a66\u8a08\u7b97\u9577\u5ea6 */ ), \"ueStrSeek\");\n\n}\n\nint main(int argc, char *argv[])\n{\n\tchar *logname;\n\tint ret;\n\n\tputenv(",
        "begin_line": 20,
        "end_line": 50,
        "is_bug": false
    },
    {
        "name": "test.testchewing.commit_string#39",
        "src_path": "test/testchewing.c",
        "class_name": "test.testchewing",
        "signature": "test.testchewing.commit_string( ChewingContext *ctx )",
        "snippet": "void commit_string( ChewingContext *ctx )\n{\n\tchar *s;\n\tif ( chewing_commit_Check( ctx ) ) {\n\t\ts = chewing_commit_String( ctx );\n#ifdef USED_IN_SIMULATION\n\t\tstrcat( commit_string_buf, s );\n#else\n\t\tprintf( \"%s\", s );\n#endif\n\t\tfree( s );\n\t}\n}",
        "begin_line": 39,
        "end_line": 51,
        "is_bug": false
    },
    {
        "name": "test.testchewing.get_char#31",
        "src_path": "test/testchewing.c",
        "class_name": "test.testchewing",
        "signature": "test.testchewing.get_char( void *param UNUSED )",
        "snippet": "static int get_char( void *param UNUSED )\n{\n\tint ch = getchar();\n\tif ( ch == EOF )\n\t\treturn END;\n\treturn ch;\n}",
        "begin_line": 31,
        "end_line": 37,
        "is_bug": false
    },
    {
        "name": "test.testchewing.main#85",
        "src_path": "test/testchewing.c",
        "class_name": "test.testchewing",
        "signature": "test.testchewing.main() #endif",
        "snippet": "int main()\n#endif\n{\n\tChewingContext *ctx;\n\tint i;\n\n\t/* Initialize libchewing */\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\t/* for the sake of testing, we should not change existing hash data */\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\t/* Request handle to ChewingContext */\n\tctx = chewing_new();\n\n\t/* Set keyboard type */\n\tchewing_set_KBType( ctx, chewing_KBStr2Num( \"KB_DEFAULT\" ) );\n\n\tchewing_set_candPerPage( ctx, 9 );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_addPhraseDirection( ctx, 1 );\n\tchewing_set_selKey( ctx, selKey_define, 10 );\n\tchewing_set_spaceAsSelection( ctx, 1 );\n\n\twhile ( 1 ) {\n\t\ti = get_keystroke( get_char, NULL );\n\t\tif ( i == END )\n\t\t\tgoto end;\n                type_single_keystroke( ctx, i );\n\t\tcommit_string( ctx );\n#ifdef USED_IN_SIMULATION\n\t\tif ( i == KEY_ENTER )\n\t\t\tcompare_per_run();\n#endif\n\t}\nend:\n\t/* Free Chewing IM handle */\n\tchewing_delete( ctx );\n\n\t/* Termate Chewing services */\n#ifndef USED_IN_SIMULATION\n\tprintf( \"\\n\" );\n#endif\n\treturn 0;\n}",
        "begin_line": 85,
        "end_line": 128,
        "is_bug": false
    },
    {
        "name": "test.testhelper.clean_userphrase#483",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.clean_userphrase()",
        "snippet": "void clean_userphrase()\n{\n\tremove( TEST_HASH_DIR PLAT_SEPARATOR HASH_FILE );\n}",
        "begin_line": 483,
        "end_line": 486,
        "is_bug": false
    },
    {
        "name": "test.testhelper.exit_status#478",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.exit_status()",
        "snippet": "int exit_status()\n{\n\treturn test_run == test_ok ? 0 : -1;\n}",
        "begin_line": 478,
        "end_line": 481,
        "is_bug": false
    },
    {
        "name": "test.testhelper.get_char_by_string#236",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.get_char_by_string( void * param )",
        "snippet": "static int get_char_by_string( void * param )\n{\n\tchar **ptr = param;\n\tchar ch;\n\n\tassert( param );\n\n\tif ( **ptr == 0 ) {\n\t\treturn END;\n\t}\n\n\tch = **ptr;\n\t++*ptr;\n\treturn ch;\n}",
        "begin_line": 236,
        "end_line": 250,
        "is_bug": false
    },
    {
        "name": "test.testhelper.get_keystroke#64",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.get_keystroke( get_char_func get_char, void * param )",
        "snippet": "int get_keystroke( get_char_func get_char, void * param )\n{\n\tint ch;\n\tint result = END;\n\tint flag = 0;\n\n\tassert( get_char );\n\n\twhile ( ( ch = get_char( param ) ) != END ) {\n\t\tif ( ( ch != '<' ) && ( flag != 1 ) )\n\t\t\treturn (int) ch;\n\t\telse if ( ch == '>' ) {\n\t\t\tflag = 0;\n\t\t\treturn result;\n\t\t}\n\t\telse {\n\t\t\tflag = 1;\n\t\t\tch = get_char( param );\n\t\t\tswitch ( ch ) {\n\t\t\t\tcase '<':\n\t\t\t\tcase '>':\n\t\t\t\t\tif ( get_char( param ) == '>' )\n\t\t\t\t\t\treturn result = ch;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tresult = KEY_LEFT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tresult = KEY_RIGHT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'U':\n\t\t\t\t\tresult = KEY_UP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tif ( ( ch = get_char( param ) ) == '>' )\n\t\t\t\t\t\treturn result = KEY_DOWN;\n\t\t\t\t\telse {\n\t\t\t\t\t\tget_char( param );\n\t\t\t\t\t\treturn result = KEY_DELETE;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\n\t\t\t\t\tif ( ( ch = get_char( param ) ) == '>' )\n\t\t\t\t\t\treturn result = KEY_ENTER;\n\t\t\t\t\telse if ( ch == 'E' )\n\t\t\t\t\t\tresult = KEY_ESC;\n\t\t\t\t\telse\n\t\t\t\t\t\tresult = KEY_END;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'C':\n\t\t\t\t\tif ( ( ch = get_char( param ) ) != '>' ) {\n\t\t\t\t\t\tif ( ch == 'B' )\n\t\t\t\t\t\t\tresult = ( KEY_CAPSLOCK );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tresult = ( KEY_CTRL_BASE + ch );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B':\n\t\t\t\t\tresult = KEY_BACKSPACE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'H':\n\t\t\t\t\tresult = KEY_HOME;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tif ( ( ch = get_char( param ) ) == 'L' )\n\t\t\t\t\t\tresult = KEY_SLEFT;\n\t\t\t\t\telse if ( ch == 'R' )\n\t\t\t\t\t\tresult = KEY_SRIGHT;\n\t\t\t\t\telse\n\t\t\t\t\t\tresult = KEY_SSPACE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'T':\n\t\t\t\t\tif ( ( ch = get_char( param ) ) == '>' )\n\t\t\t\t\t\treturn result = KEY_TAB;\n\t\t\t\t\telse\n\t\t\t\t\t\tresult = KEY_DBLTAB;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'P':\n\t\t\t\t\tif ( ( ch = get_char( param ) ) == 'D' )\n\t\t\t\t\t\tresult = KEY_NPAGE;\n\t\t\t\t\telse\n\t\t\t\t\t\tresult = KEY_PPAGE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'N':\n\t\t\t\t\tch = get_char( param );\n\t\t\t\t\tresult = KEY_NUMPAD_BASE + ch;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result = END;\n}",
        "begin_line": 64,
        "end_line": 155,
        "is_bug": false
    },
    {
        "name": "test.testhelper.internal_has_userphrase#416",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.internal_has_userphrase( const char *file UNUSED, int line UNUSED, ChewingContext *ctx, const char *bopomofo, const char *phrase )",
        "snippet": "int internal_has_userphrase( const char *file UNUSED, int line UNUSED,\n\tChewingContext *ctx, const char *bopomofo, const char *phrase )\n{\n\tuint16_t *phone = NULL;\n\tchar *bopomofo_buf = NULL;\n\tint i;\n\tchar *p;\n\tchar *save_ptr = NULL;\n\tHASH_ITEM *item = NULL;\n\tint ret = 0;\n\n\tphone = calloc( MAX_PHONE_SEQ_LEN, sizeof (*phone) );\n\tif ( !phone ) {\n\t\tfprintf( stderr, \"calloc fails at %s:%d\", __FILE__, __LINE__ );\n\t\tgoto end;\n\t}\n\n\tbopomofo_buf = strdup( bopomofo );\n\tif ( !bopomofo_buf ) {\n\t\tfprintf( stderr, \"strdup fails at %s:%d\", __FILE__, __LINE__ );\n\t\tgoto end;\n\t}\n\n\tfor ( i = 0, p = strtok_r( bopomofo_buf, \" \", &save_ptr );\n\t\ti < MAX_PHONE_SEQ_LEN && p;\n\t\t++i, p = strtok_r( NULL, \" \", &save_ptr) ) {\n\t\tphone[i] = UintFromPhone( p );\n\t}\n\n\twhile ( ( item = HashFindPhonePhrase( ctx->data, phone, item ) ) != NULL ) {\n\t\tif ( phrase == NULL || strcmp( item->data.wordSeq, phrase ) == 0 ) {\n\t\t\tret = 1;\n\t\t\tgoto end;\n\t\t}\n\t}\n\nend:\n\tfree( bopomofo_buf );\n\tfree( phone );\n\n\treturn ret;\n}",
        "begin_line": 416,
        "end_line": 457,
        "is_bug": false
    },
    {
        "name": "test.testhelper.internal_ok#252",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.internal_ok( const char *file, int line, int test, const char * test_txt, const char *fmt, ...)",
        "snippet": "void internal_ok( const char *file, int line, int test, const char * test_txt,\n\tconst char *fmt, ...)\n{\n\tva_list ap;\n\n\t++test_run;\n\tif ( test ) {\n\t\t++test_ok;\n\t\tprintf( \"ok %d \", test_run);\n\n\t\tva_start( ap, fmt );\n\t\tvprintf( fmt, ap );\n\t\tva_end( ap );\n\n\t\tprintf(\"\\n\");\n\t} else {\n\t\tprintf( \"not ok %d \", test_run);\n\n\t\tva_start( ap, fmt );\n\t\tvprintf( fmt, ap );\n\t\tva_end( ap );\n\n\t\tprintf( \"\\n# %s failed in %s:%d\\n\", test_txt, file, line );\n\t}\n}",
        "begin_line": 252,
        "end_line": 276,
        "is_bug": false
    },
    {
        "name": "test.testhelper.internal_ok_buffer#283",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.internal_ok_buffer( const char *file, int line, ChewingContext *ctx, const char *expected, const BufferType *buffer )",
        "snippet": "void internal_ok_buffer( const char *file, int line, ChewingContext *ctx,\n\tconst char *expected, const BufferType *buffer )\n{\n\tchar *buf;\n\tint actual_ret;\n\tint expected_ret;\n\tint expected_len;\n\n\tassert( ctx );\n\tassert( expected );\n\tassert( buffer );\n\n\texpected_len = ueStrLen( expected );\n\n\tif ( buffer->check ) {\n\t\tactual_ret = buffer->check( ctx );\n\t\texpected_ret = !!expected_len;\n\t\tinternal_ok( file, line, actual_ret == expected_ret,\n\t\t\t\"actual_ret == expected_ret\",\n\t\t\t\"%s check function returned `%d' shall be `%d'\", buffer->name, actual_ret, expected_ret );\n\t}\n\n\tif ( buffer->check_alt ) {\n\t\tactual_ret = buffer->check_alt( ctx );\n\t\texpected_ret = !expected_len;\n\t\tinternal_ok( file, line, actual_ret == expected_ret,\n\t\t\t\"actual_ret == expected_ret\",\n\t\t\t\"%s check function returned `%d' shall be `%d'\", buffer->name, actual_ret, expected_ret );\n\t}\n\n\tif ( buffer->get_length ) {\n\t\tactual_ret = buffer->get_length( ctx );\n\t\texpected_ret = expected_len;\n\t\tinternal_ok( file, line, actual_ret == expected_ret,\n\t\t\t\"actual_ret == expected_ret\",\n\t\t\t\"%s get length function returned `%d' shall be `%d'\", buffer->name, actual_ret, expected_ret );\n\t}\n\n\tif ( buffer->get_string ) {\n\t\tbuf = buffer->get_string( ctx );\n\t\tinternal_ok( file, line, !strcmp( buf, expected ), \"!strcmp( buf, expected )\",\n\t\t\t\"%s string function returned `%s' shall be `%s'\", buffer->name, buf, expected );\n\t\tchewing_free( buf );\n\t}\n\n\tif ( buffer->get_string_alt ) {\n\t\tbuf = buffer->get_string_alt( ctx, &actual_ret );\n\t\texpected_ret = expected_len;\n\t\tinternal_ok( file, line, actual_ret == expected_ret,\n\t\t\t\"actual_ret == expected_ret\",\n\t\t\t\"%s string function returned parameter `%d' shall be `%d'\", buffer->name, actual_ret, expected_ret );\n\t\tinternal_ok( file, line, !strcmp( buf, expected ), \"!strcmp( buf, expected )\",\n\t\t\t\"%s string function returned `%s' shall be `%s'\", buffer->name, buf, expected );\n\t\tchewing_free( buf );\n\t}\n}",
        "begin_line": 283,
        "end_line": 338,
        "is_bug": false
    },
    {
        "name": "test.testhelper.internal_ok_candidate#340",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.internal_ok_candidate( const char *file, int line, ChewingContext *ctx, const char *cand[], size_t cand_len )",
        "snippet": "void internal_ok_candidate( const char *file, int line,\n\tChewingContext *ctx, const char *cand[], size_t cand_len )\n{\n\tsize_t i;\n\tchar *buf;\n\n\tassert( ctx );\n\n\tchewing_cand_Enumerate( ctx );\n\tfor ( i = 0; i < cand_len; ++i ) {\n\t\tinternal_ok( file, line, chewing_cand_hasNext( ctx ), __func__,\n\t\t\t\"shall has next candidate\" );\n\n\t\tbuf = chewing_cand_String( ctx );\n\t\tinternal_ok( file, line, strcmp( buf, cand[i] ) == 0, __func__,\n\t\t\t\"candidate `%s' shall be `%s'\", buf, cand[i] );\n\t\tchewing_free( buf );\n\n\t\tbuf = chewing_cand_string_by_index( ctx, i );\n\t\tinternal_ok( file, line, strcmp( buf, cand[i] ) == 0, __func__,\n\t\t\t\"candndate `%s' shall be `%s'\", buf, cand[i] );\n\t\tchewing_free( buf );\n\t}\n\n\tinternal_ok( file, line , !chewing_cand_hasNext( ctx ), __func__,\n\t\t\t\"shall not have next candidate\" );\n\tbuf = chewing_cand_String( ctx );\n\n\tinternal_ok( file, line, strcmp( buf, \"\" ) == 0, __func__,\n\t\t\"candndate `%s' shall be `%s'\", buf, \"\" );\n\n\tchewing_free( buf );\n}",
        "begin_line": 340,
        "end_line": 372,
        "is_bug": false
    },
    {
        "name": "test.testhelper.internal_ok_candidate_len#374",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.internal_ok_candidate_len( const char *file, int line, ChewingContext *ctx, size_t expected_len )",
        "snippet": "void internal_ok_candidate_len( const char *file, int line,\n\tChewingContext *ctx, size_t expected_len )\n{\n\tchar *buf;\n\tint actual_len;\n\n\tassert( ctx );\n\n\tbuf = chewing_cand_string_by_index( ctx, 0 );\n\tactual_len = ueStrLen( buf );\n\tinternal_ok( file, line, actual_len == expected_len, __func__,\n\t\t\t\"candidate length `%d' shall be `%d'\", actual_len, expected_len );\n\tchewing_free( buf );\n}",
        "begin_line": 374,
        "end_line": 387,
        "is_bug": false
    },
    {
        "name": "test.testhelper.internal_ok_keystroke_rtn#389",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.internal_ok_keystroke_rtn( const char *file, int line, ChewingContext *ctx, int rtn )",
        "snippet": "void internal_ok_keystroke_rtn( const char *file, int line,\n\tChewingContext *ctx, int rtn )\n{\n\tconst struct {\n\t\tint rtn;\n\t\tint (*func)(ChewingContext* ctx);\n\t} TABLE[] = {\n\t\t{ KEYSTROKE_IGNORE, chewing_keystroke_CheckIgnore },\n\t\t{ KEYSTROKE_COMMIT, chewing_commit_Check },\n\t\t// No function to check KEYSTROKE_BELL\n\t\t{ KEYSTROKE_ABSORB, chewing_keystroke_CheckAbsorb },\n\t};\n\tsize_t i;\n\tint actual;\n\tint expected;\n\n\tassert( ctx );\n\n\tfor ( i = 0; i < ARRAY_SIZE( TABLE ); ++i ) {\n\t\tactual = TABLE[i].func( ctx );\n\t\texpected = !!( rtn & TABLE[i].rtn );\n\n\t\tinternal_ok( file, line, actual == expected,\n\t\t\t__func__, \"keystroke rtn `%d' shall be `%d'\", actual, expected );\n\t}\n}",
        "begin_line": 389,
        "end_line": 414,
        "is_bug": false
    },
    {
        "name": "test.testhelper.internal_start_testcase#469",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.internal_start_testcase( const char *func, ChewingContext *ctx, FILE *file )",
        "snippet": "void internal_start_testcase( const char *func, ChewingContext *ctx, FILE *file )\n{\n\tassert( func );\n\n\tprintf(\"#\\n# %s\\n#\\n\", func);\n\tfprintf( file, \"#\\n# %s\\n#\\n\", func );\n\tchewing_set_logger( ctx, logger, file );\n}",
        "begin_line": 469,
        "end_line": 476,
        "is_bug": false
    },
    {
        "name": "test.testhelper.logger#459",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.logger( void *data, int level, const char *fmt, ... )",
        "snippet": "static void logger( void *data, int level, const char *fmt, ... )\n{\n\tva_list ap;\n\tFILE *fd = (FILE *) data;\n\n\tva_start( ap, fmt );\n\tvfprintf( fd, fmt, ap );\n\tva_end( ap );\n}",
        "begin_line": 459,
        "end_line": 467,
        "is_bug": false
    },
    {
        "name": "test.testhelper.type_keystroke#228",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.type_keystroke( ChewingContext *ctx, get_char_func get_char, void *param )",
        "snippet": "static void type_keystroke( ChewingContext *ctx, get_char_func get_char, void *param )\n{\n\tint ch;\n\n\twhile ( ( ch = get_keystroke( get_char, param ) ) != END )\n\t\ttype_single_keystroke( ctx, ch );\n}",
        "begin_line": 228,
        "end_line": 234,
        "is_bug": false
    },
    {
        "name": "test.testhelper.type_keystroke_by_string#278",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.type_keystroke_by_string( ChewingContext *ctx, char* keystroke )",
        "snippet": "void type_keystroke_by_string( ChewingContext *ctx, char* keystroke )\n{\n\ttype_keystroke( ctx, get_char_by_string, &keystroke );\n}",
        "begin_line": 278,
        "end_line": 281,
        "is_bug": false
    },
    {
        "name": "test.testhelper.type_single_keystroke#157",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.type_single_keystroke( ChewingContext *ctx, int ch )",
        "snippet": "void type_single_keystroke( ChewingContext *ctx, int ch )\n{\n\tswitch ( ch ) {\n\t\tcase KEY_LEFT:\n\t\t\tchewing_handle_Left( ctx );\n\t\t\tbreak;\n\t\tcase KEY_SLEFT:\n\t\t\tchewing_handle_ShiftLeft( ctx );\n\t\t\tbreak;\n\t\tcase KEY_RIGHT:\n\t\t\tchewing_handle_Right( ctx );\n\t\t\tbreak;\n\t\tcase KEY_SRIGHT:\n\t\t\tchewing_handle_ShiftRight( ctx );\n\t\t\tbreak;\n\t\tcase KEY_UP:\n\t\t\tchewing_handle_Up( ctx );\n\t\t\tbreak;\n\t\tcase KEY_DOWN:\n\t\t\tchewing_handle_Down( ctx );\n\t\t\tbreak;\n\t\tcase KEY_SPACE:\n\t\t\tchewing_handle_Space( ctx );\n\t\t\tbreak;\n\t\tcase KEY_ENTER:\n\t\t\tchewing_handle_Enter( ctx );\n\t\t\tbreak;\n\t\tcase KEY_BACKSPACE:\n\t\t\tchewing_handle_Backspace( ctx );\n\t\t\tbreak;\n\t\tcase KEY_ESC:\n\t\t\tchewing_handle_Esc( ctx );\n\t\t\tbreak;\n\t\tcase KEY_DELETE:\n\t\t\tchewing_handle_Del( ctx );\n\t\t\tbreak;\n\t\tcase KEY_HOME:\n\t\t\tchewing_handle_Home( ctx );\n\t\t\tbreak;\n\t\tcase KEY_END:\n\t\t\tchewing_handle_End( ctx );\n\t\t\tbreak;\n\t\tcase KEY_TAB:\n\t\t\tchewing_handle_Tab( ctx );\n\t\t\tbreak;\n\t\tcase KEY_CAPSLOCK:\n\t\t\tchewing_handle_Capslock( ctx );\n\t\t\tbreak;\n\t\tcase KEY_NPAGE:\n\t\t\tchewing_handle_PageDown( ctx );\n\t\t\tbreak;\n\t\tcase KEY_PPAGE:\n\t\t\tchewing_handle_PageUp( ctx );\n\t\t\tbreak;\n\t\tcase KEY_SSPACE:\n\t\t\tchewing_handle_ShiftSpace( ctx );\n\t\t\tbreak;\n\t\tcase KEY_DBLTAB:\n\t\t\tchewing_handle_DblTab( ctx );\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ( KEY_CTRL_BASE <= ch && ch < KEY_NUMPAD_BASE)\n\t\t\t\tchewing_handle_CtrlNum( ctx, ch - KEY_CTRL_BASE );\n\t\t\telse if ( KEY_NUMPAD_BASE <= ch )\n\t\t\t\tchewing_handle_Numlock( ctx, ch - KEY_NUMPAD_BASE );\n\t\t\telse\n\t\t\t\tchewing_handle_Default( ctx, (char) ch );\n\t\t\tbreak;\n\t}\n}",
        "begin_line": 157,
        "end_line": 226,
        "is_bug": false
    }
]