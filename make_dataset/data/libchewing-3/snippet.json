[
    {
        "name": "chewingio.allocate_ChewingData#128",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.allocate_ChewingData()",
        "snippet": "static ChewingData * allocate_ChewingData()\n{\n\tstatic const int DEFAULT_SELKEY[] = { '1', '2', '3', '4', '5', '6', '7', '8', '9', '0' };\n\n\tChewingData *data = ALC( ChewingData, 1 );\n\tif ( data ) {\n\t\tdata->config.candPerPage = MAX_SELKEY;\n\t\tdata->config.maxChiSymbolLen = MAX_CHI_SYMBOL_LEN;\n\t\tdata->logger = NullLogger;\n\t\tmemcpy( data->config.selKey, DEFAULT_SELKEY, sizeof( data->config.selKey ) );\n\t}\n\n\treturn data;\n}",
        "begin_line": 128,
        "end_line": 141,
        "is_bug": false
    },
    {
        "name": "chewingio.chooseCandidate#92",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chooseCandidate( ChewingContext *ctx, int toSelect, int key_buf_cursor )",
        "snippet": "static void chooseCandidate( ChewingContext *ctx, int toSelect, int key_buf_cursor )\n{\n\tChewingData *pgdata = ctx->data;\n\n\tif ( toSelect ) {\n\t\tif ( ! pgdata->bSelect ) {\n\t\t\tChoiceInitAvail( pgdata );\n\t\t} else {\n\t\t\tif ( pgdata->config.bPhraseChoiceRearward ) {\n\t\t\t\tint avail_willbe = (pgdata->availInfo.currentAvail > 0) ?\n\t\t\t\t\tpgdata->availInfo.currentAvail - 1 :\n\t\t\t\t\tpgdata->availInfo.nAvail - 1;\n\t\t\t\tpgdata->chiSymbolCursor = pgdata->choiceInfo.oldChiSymbolCursor -\n\t\t\t\t\tpgdata->availInfo.avail[ avail_willbe ].len;\n\t\t\t\tif ( chewing_buffer_Len( ctx ) >\n\t\t\t\t\t\tpgdata->choiceInfo.oldChiSymbolCursor ) {\n\t\t\t\t\tpgdata->chiSymbolCursor++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( ChoiceHasNextAvail( pgdata ) )\n\t\t\t\tChoiceNextAvail( pgdata );\n\t\t\telse /* rollover */\n\t\t\t\tChoiceFirstAvail( pgdata );\n\t\t}\n\t} else if ( pgdata->symbolKeyBuf[ key_buf_cursor ] ) {\n\t\t/* Open Symbol Choice List */\n\t\tif ( pgdata->choiceInfo.isSymbol == WORD_CHOICE )\n\t\t\tOpenSymbolChoice( pgdata );\n\t}\n}",
        "begin_line": 92,
        "end_line": 122,
        "is_bug": false
    },
    {
        "name": "chewingutil.AddChi#631",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.AddChi( uint16_t phone, uint16_t phoneAlt, ChewingData *pgdata )",
        "snippet": "int AddChi( uint16_t phone, uint16_t phoneAlt, ChewingData *pgdata )\n{\n\tint i;\n\tint cursor = PhoneSeqCursor( pgdata );\n\n\t/* shift the selectInterval */\n\tfor ( i = 0; i < pgdata->nSelect; i++ ) {\n\t\tif ( pgdata->selectInterval[ i ].from >= cursor ) {\n\t\t\tpgdata->selectInterval[ i ].from++;\n\t\t\tpgdata->selectInterval[ i ].to++;\n\t\t}\n\t}\n\n\t/* shift the Brkpt */\n\tassert( pgdata->nPhoneSeq >= cursor );\n\tmemmove(\n\t\t&( pgdata->bUserArrBrkpt[ cursor + 2 ] ),\n\t\t&( pgdata->bUserArrBrkpt[ cursor + 1 ] ),\n\t\tsizeof( int ) * ( pgdata->nPhoneSeq - cursor ) );\n\tmemmove(\n\t\t&( pgdata->bUserArrCnnct[ cursor + 2 ] ),\n\t\t&( pgdata->bUserArrCnnct[ cursor + 1 ] ),\n\t\tsizeof( int ) * ( pgdata->nPhoneSeq - cursor ) );\n\n\t/* add to phoneSeq */\n\tmemmove(\n\t\t&( pgdata->phoneSeq[ cursor + 1 ] ),\n\t\t&( pgdata->phoneSeq[ cursor ] ) ,\n\t\tsizeof( uint16_t ) * ( pgdata->nPhoneSeq - cursor ) );\n\tpgdata->phoneSeq[ cursor ] = phone;\n\tmemmove(\n\t\t&( pgdata->phoneSeqAlt[ cursor + 1 ] ),\n\t\t&( pgdata->phoneSeqAlt[ cursor ] ) ,\n\t\tsizeof( uint16_t ) * ( pgdata->nPhoneSeq - cursor ) );\n\tpgdata->phoneSeqAlt[ cursor ] = phoneAlt;\n\tpgdata->nPhoneSeq ++;\n\n\t/* add to chiSymbolBuf */\n\tassert( pgdata->chiSymbolBufLen >= pgdata->chiSymbolCursor );\n\tmemmove(\n\t\t&( pgdata->preeditBuf[ pgdata->chiSymbolCursor + 1 ] ),\n\t\t&( pgdata->preeditBuf[ pgdata->chiSymbolCursor ] ) ,\n\t\tsizeof( pgdata->preeditBuf[0] ) * ( pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor ) );\n\t/* \"0\" means Chinese word */\n\tpgdata->preeditBuf[ pgdata->chiSymbolCursor ].category = CHEWING_CHINESE;\n\tpgdata->chiSymbolBufLen++;\n\tpgdata->chiSymbolCursor++;\n\n\treturn 0;\n}",
        "begin_line": 631,
        "end_line": 680,
        "is_bug": false
    },
    {
        "name": "chewingutil.AddSelect#913",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.AddSelect( ChewingData *pgdata, int sel_i )",
        "snippet": "int AddSelect( ChewingData *pgdata, int sel_i )\n{\n\tint length, nSelect, cursor;\n\n\t/* save the typing time */\n\tlength = pgdata->availInfo.avail[ pgdata->availInfo.currentAvail ].len;\n\tnSelect = pgdata->nSelect;\n\n\t/* change \"selectStr\" , \"selectInterval\" , and \"nSelect\" of ChewingData */\n\tueStrNCpy( pgdata->selectStr[ nSelect ],\n\t\t\tpgdata->choiceInfo.totalChoiceStr[ sel_i ],\n\t\t\tlength, 1 );\n\tcursor = PhoneSeqCursor( pgdata );\n\tpgdata->selectInterval[ nSelect ].from = cursor;\n\tpgdata->selectInterval[ nSelect ].to = cursor + length;\n\tpgdata->nSelect++;\n\treturn 0;\n}",
        "begin_line": 913,
        "end_line": 930,
        "is_bug": false
    },
    {
        "name": "chewingutil.AutoLearnPhrase#590",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.AutoLearnPhrase( ChewingData *pgdata )",
        "snippet": "void AutoLearnPhrase( ChewingData *pgdata )\n{\n\tuint16_t bufPhoneSeq[ MAX_PHONE_SEQ_LEN + 1 ];\n\tchar bufWordSeq[ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ] = { 0 };\n\tint i, from, len;\n\tint bufWordLen;\n\tint prev_pos = 0;\n\tint pending = 0;\n\n\tfor ( i = 0; i < pgdata->nPrefer; i++ ) {\n\t\tfrom = pgdata->preferInterval[ i ].from;\n\t\tlen = pgdata->preferInterval[i].to - from;\n\t\tif ( len == 1 && ! ChewingIsBreakPoint( from, pgdata ) ) {\n\t\t\tmemcpy( bufPhoneSeq + prev_pos, &pgdata->phoneSeq[ from ], sizeof( uint16_t ) * len );\n\t\t\tbufPhoneSeq[ prev_pos + len ] = (uint16_t) 0;\n\n\t\t\tbufWordLen = strlen( bufWordSeq );\n\t\t\tcopyStringFromPreeditBuf( pgdata, from, len,\n\t\t\t\tbufWordSeq + bufWordLen, sizeof( bufWordSeq ) - bufWordLen );\n\t\t\tprev_pos += len;\n\t\t\tpending = 1;\n\t\t}\n\t\telse {\n\t\t\tif ( pending ) {\n\t\t\t\tUserUpdatePhrase( pgdata, bufPhoneSeq, bufWordSeq );\n\t\t\t\tprev_pos = 0;\n\t\t\t\tpending = 0;\n\t\t\t}\n\t\t\tmemcpy( bufPhoneSeq, &pgdata->phoneSeq[ from ], sizeof( uint16_t ) * len );\n\t\t\tbufPhoneSeq[ len ] = (uint16_t) 0;\n\t\t\tcopyStringFromPreeditBuf( pgdata, from, len, bufWordSeq, sizeof( bufWordSeq ) );\n\t\t\tUserUpdatePhrase( pgdata, bufPhoneSeq, bufWordSeq );\n\t\t}\n\t}\n\tif ( pending ) {\n\t\tUserUpdatePhrase( pgdata, bufPhoneSeq, bufWordSeq );\n\t\tprev_pos = 0;\n\t\tpending = 0;\n\t}\n}",
        "begin_line": 590,
        "end_line": 629,
        "is_bug": true
    },
    {
        "name": "chewingutil.CallPhrasing#727",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.CallPhrasing( ChewingData *pgdata, int all_phrasing )",
        "snippet": "int CallPhrasing( ChewingData *pgdata, int all_phrasing )\n{\n\t/* set \"bSymbolArrBrkpt\" && \"bArrBrkpt\" */\n\tint i, ch_count = 0;\n\n\tmemcpy(\n\t\tpgdata->bArrBrkpt,\n\t\tpgdata->bUserArrBrkpt,\n\t\t(MAX_PHONE_SEQ_LEN + 1) * sizeof( int ) );\n\tmemset(\n\t\tpgdata->bSymbolArrBrkpt, 0,\n\t\t(MAX_PHONE_SEQ_LEN + 1) * sizeof( int ) );\n\n\tfor ( i = 0; i < pgdata->chiSymbolBufLen; i++ ) {\n\t\tif ( ChewingIsChiAt( i, pgdata ) )\n\t\t\tch_count++;\n\t\telse {\n\t\t\tpgdata->bArrBrkpt[ ch_count ] = 1;\n\t\t\tpgdata->bSymbolArrBrkpt[ ch_count ] = 1;\n\t\t}\n\t}\n\n\t/* kill select interval */\n\tfor ( i = 0; i < pgdata->nPhoneSeq; i++ ) {\n\t\tif ( pgdata->bArrBrkpt[ i ] ) {\n\t\t\tChewingKillSelectIntervalAcross( i, pgdata );\n\t\t}\n\t}\n\n\tShowChewingData(pgdata);\n\n\t/* then phrasing */\n\tPhrasing( pgdata, all_phrasing );\n\n\t/* and then make prefer interval */\n\tMakePreferInterval( pgdata );\n\n\treturn 0;\n}",
        "begin_line": 727,
        "end_line": 765,
        "is_bug": false
    },
    {
        "name": "chewingutil.ChewingIsBreakPoint#552",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ChewingIsBreakPoint( int cursor, ChewingData *pgdata )",
        "snippet": "static int ChewingIsBreakPoint( int cursor, ChewingData *pgdata )\n{\n\tstatic const char * const BREAK_WORD[] = {\n\t\t\"\\xE6\\x98\\xAF\", \"\\xE7\\x9A\\x84\", \"\\xE4\\xBA\\x86\", \"\\xE4\\xB8\\x8D\",\n\t\t/* \u662f              \u7684              \u4e86              \u4e0d */\n\t\t\"\\xE4\\xB9\\x9F\", \"\\xE8\\x80\\x8C\", \"\\xE4\\xBD\\xA0\", \"\\xE6\\x88\\x91\",\n\t\t/* \u4e5f              \u800c              \u4f60              \u6211 */\n\t\t\"\\xE4\\xBB\\x96\", \"\\xE8\\x88\\x87\", \"\\xE5\\xAE\\x83\", \"\\xE5\\xA5\\xB9\",\n\t\t/* \u4ed6              \u8207              \u5b83              \u5979 */\n\t\t\"\\xE5\\x85\\xB6\", \"\\xE5\\xB0\\xB1\", \"\\xE5\\x92\\x8C\", \"\\xE6\\x88\\x96\",\n\t\t/* \u5176              \u5c31              \u548c              \u6216 */\n\t\t\"\\xE5\\x80\\x91\", \"\\xE6\\x80\\xA7\", \"\\xE5\\x93\\xA1\", \"\\xE5\\xAD\\x90\",\n\t\t/* \u5011              \u6027              \u54e1              \u5b50 */\n\t\t\"\\xE4\\xB8\\x8A\", \"\\xE4\\xB8\\x8B\", \"\\xE4\\xB8\\xAD\", \"\\xE5\\x85\\xA7\",\n\t\t/* \u4e0a              \u4e0b              \u4e2d              \u5167 */\n\t\t\"\\xE5\\xA4\\x96\", \"\\xE5\\x8C\\x96\", \"\\xE8\\x80\\x85\", \"\\xE5\\xAE\\xB6\",\n\t\t/* \u5916              \u5316              \u8005              \u5bb6 */\n\t\t\"\\xE5\\x85\\x92\", \"\\xE5\\xB9\\xB4\", \"\\xE6\\x9C\\x88\", \"\\xE6\\x97\\xA5\",\n\t\t/* \u5152              \u5e74              \u6708              \u65e5 */\n\t\t\"\\xE6\\x99\\x82\", \"\\xE5\\x88\\x86\", \"\\xE7\\xA7\\x92\", \"\\xE8\\xA1\\x97\",\n\t\t/* \u6642              \u5206              \u79d2              \u8857 */\n\t\t\"\\xE8\\xB7\\xAF\", \"\\xE6\\x9D\\x91\",\n\t\t/* \u8def              \u6751 */\n\t\t\"\\xE5\\x9C\\xA8\",\n\t\t/* \u5728 */\n\t};\n\tint i;\n\n\tif ( ! ChewingIsChiAt( cursor, pgdata ) )\n\t\treturn 1;\n\n\tfor ( i = 0; i < ARRAY_SIZE( BREAK_WORD ); ++i )\n\t\tif ( ! strcmp( pgdata->preeditBuf[ cursor ].char_, BREAK_WORD[ i ]) )\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nvoid AutoLearnPhrase( ChewingData *pgdata )\n{\n\tuint16_t bufPhoneSeq[ MAX_PHO",
        "begin_line": 552,
        "end_line": 588,
        "is_bug": false
    },
    {
        "name": "chewingutil.ChewingIsChiAt#960",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ChewingIsChiAt( int chiSymbolCursor, ChewingData *pgdata )",
        "snippet": "int ChewingIsChiAt( int chiSymbolCursor, ChewingData *pgdata )\n{\n\treturn pgdata->preeditBuf[ chiSymbolCursor ].category == CHEWING_CHINESE;\n}",
        "begin_line": 960,
        "end_line": 963,
        "is_bug": false
    },
    {
        "name": "chewingutil.ChewingIsEntering#109",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ChewingIsEntering( ChewingData *pgdata )",
        "snippet": "int ChewingIsEntering( ChewingData *pgdata )\n{\n\tif ( pgdata->choiceInfo.isSymbol != WORD_CHOICE )\n\t\treturn 1;\n\treturn (\n\t\tpgdata->chiSymbolBufLen != 0 ||\n\t\tZuinIsEntering( &( pgdata->zuinData ) ) );\n}",
        "begin_line": 109,
        "end_line": 116,
        "is_bug": false
    },
    {
        "name": "chewingutil.CountReleaseNum#467",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.CountReleaseNum( ChewingData *pgdata )",
        "snippet": "static int CountReleaseNum( ChewingData *pgdata )\n{\n\tint remain, i;\n\n\tremain = pgdata->config.maxChiSymbolLen - pgdata->chiSymbolBufLen;\n\tif ( remain >= 0 )\n\t\treturn 0;\n\n\tqsort(\n\t\tpgdata->preferInterval,\n\t\tpgdata->nPrefer,\n\t\tsizeof( IntervalType ),\n\t\t(CompFuncType) CompInterval );\n\n\tif ( ! ChewingIsChiAt( 0, pgdata ) ) {\n\t\tfor ( i = 0; i < pgdata->chiSymbolCursor; ++i ) {\n\t\t\tif ( ChewingIsChiAt( i, pgdata ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn i;\n\t}\n\n\ti = FindIntervalFrom( 0, pgdata->preferInterval, pgdata->nPrefer );\n\tif ( i >= 0 ) {\n\t\treturn ( pgdata->preferInterval[ i ].to - pgdata->preferInterval[ i ].from );\n\t}\n\n\treturn 1;\n}",
        "begin_line": 467,
        "end_line": 496,
        "is_bug": false
    },
    {
        "name": "chewingutil.CountSelKeyNum#932",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.CountSelKeyNum( int key, ChewingData *pgdata ) \t/* return value starts from 0.  If less than zero : error key */",
        "snippet": "int CountSelKeyNum( int key, ChewingData *pgdata )\n\t/* return value starts from 0.  If less than zero : error key */\n{\n\tint i;\n\n\tfor ( i = 0; i < MAX_SELKEY; i++ )\n\t\tif ( pgdata->config.selKey[ i ] == key )\n\t\t\treturn i;\n\treturn -1;\n}",
        "begin_line": 932,
        "end_line": 941,
        "is_bug": false
    },
    {
        "name": "chewingutil.CountSymbols#943",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.CountSymbols( ChewingData *pgdata, int to )",
        "snippet": "int CountSymbols( ChewingData *pgdata, int to )\n{\n\tint chi;\n\tint i;\n\tfor ( chi = i = 0; i < to; i++ ) {\n\t\tif ( ChewingIsChiAt( i, pgdata ) )\n\t\t\tchi++;\n\t}\n\treturn to - chi;\n}",
        "begin_line": 943,
        "end_line": 952,
        "is_bug": false
    },
    {
        "name": "chewingutil.FindEasySymbolIndex#65",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.FindEasySymbolIndex( char ch )",
        "snippet": "static int FindEasySymbolIndex( char ch )\n{\n\t/**\n\t * '0' => 0, ..., '9' => 9\n\t * 'A' => 10, 'B' => 11, ... 'Z' => 35\n\t */\n\tif ( isdigit( ch ) ) {\n\t\treturn ch - '0';\n\t}\n\telse if ( isupper( ch ) ) {\n\t\treturn ch - 'A' + 10;\n\t}\n\telse {\n\t\treturn -1;\n\t}\n}",
        "begin_line": 65,
        "end_line": 80,
        "is_bug": false
    },
    {
        "name": "chewingutil.InitEasySymbolInput#1392",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.InitEasySymbolInput( ChewingData *pgdata, const char *prefix )",
        "snippet": "int InitEasySymbolInput( ChewingData *pgdata, const char *prefix )\n{\n\tstatic const size_t LINE_LEN = 512; // shall be long enough?\n\n\tFILE *file = NULL;\n\tchar *filename = NULL;\n\tchar *line = NULL;\n\tint len;\n\tint _index;\n\tchar *symbol;\n\tint ret = -1;\n\n\tret = asprintf( &filename, \"%s\" PLAT_SEPARATOR \"%s\",\n\t\t\tprefix, SOFTKBD_TABLE_FILE );\n\tif ( ret == -1 )\n\t\tgoto end;\n\n\tfile = fopen( filename, \"r\" );\n\tif ( !file )\n\t\tgoto end;\n\n\tline = ALC( char, LINE_LEN );\n\tif ( !line )\n\t\tgoto end;\n\n\twhile ( fgets( line, LINE_LEN, file ) ) {\n\t\tif ( ' ' != line[ 1 ] )\n\t\t\tcontinue;\n\n\t\t// Remove tailing \\n\n\t\tlen = strcspn( line, \"\\r\\n\" );\n\n\t\tline[ len ] = '\\0';\n\n\t\t_index = FindEasySymbolIndex( line[ 0 ] );\n\t\tif ( -1 == _index )\n\t\t\tcontinue;\n\n\t\tlen = ueStrLen( &line[ 2 ] );\n\t\tif ( 0 == len || len > MAX_PHRASE_LEN )\n\t\t\tcontinue;\n\n\t\tsymbol = ALC( char, strlen( &line[2] ) + 1 );\n\t\tif ( !symbol )\n\t\t\tgoto end;\n\n\t\tueStrNCpy( symbol, &line[ 2 ], len, 1 );\n\n\t\tfree( pgdata->static_data.g_easy_symbol_value[ _index ] );\n\t\tpgdata->static_data.g_easy_symbol_value[ _index ] = symbol;\n\t\tpgdata->static_data.g_easy_symbol_num[ _index ] = len;\n\t}\n\tret = 0;\nend:\n\tfree( line );\n\tfclose( file );\n\tfree ( filename );\n\treturn ret;\n}",
        "begin_line": 1392,
        "end_line": 1450,
        "is_bug": false
    },
    {
        "name": "chewingutil.InitSymbolTable#1271",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.InitSymbolTable( ChewingData *pgdata, const char *prefix )",
        "snippet": "int InitSymbolTable( ChewingData *pgdata, const char *prefix )\n{\n\tstatic const unsigned int MAX_SYMBOL_ENTRY = 100;\n\tstatic const size_t LINE_LEN = 512; // shall be long enough?\n\n\tchar *filename = NULL;\n\tFILE *file = NULL;\n\tchar *line = NULL;\n\tSymbolEntry **entry = NULL;\n\tchar *category_end;\n\tconst char *symbols;\n\tconst char *symbols_end;\n\tconst char *symbol;\n\tsize_t i;\n\tsize_t len;\n\tsize_t size;\n\tint ret = -1;\n\n\tpgdata->static_data.n_symbol_entry = 0;\n\tpgdata->static_data.symbol_table = NULL;\n\n\tret = asprintf( &filename, \"%s\" PLAT_SEPARATOR \"%s\",\n\t\tprefix, SYMBOL_TABLE_FILE );\n\tif ( ret == -1 )\n\t\tgoto error;\n\n\tfile = fopen( filename, \"r\" );\n\tif ( !file )\n\t\tgoto error;\n\n\tline = ALC( char, LINE_LEN );\n\tif ( !line )\n\t\tgoto error;\n\n\tentry = ALC( SymbolEntry* , MAX_SYMBOL_ENTRY );\n\tif ( !entry )\n\t\tgoto error;\n\n\twhile ( fgets( line, LINE_LEN, file ) &&\n\t\tpgdata->static_data.n_symbol_entry < MAX_SYMBOL_ENTRY ) {\n\n\t\tcategory_end = strpbrk( line, \"=\\r\\n\" );\n\t\tif ( !category_end )\n\t\t\tgoto error;\n\n\t\tsymbols = category_end + 1;\n\t\tsymbols_end = strpbrk( symbols, \"\\r\\n\" );\n\t\tif ( symbols_end ) {\n\t\t\tlen = ueStrLen( symbols );\n\n\t\t\tentry[ pgdata->static_data.n_symbol_entry ] =\n\t\t\t\t( SymbolEntry* ) malloc( sizeof ( entry[0][0] ) +\n\t\t\t\t\tsizeof( entry[0][0].symbols[0] ) * len);\n\t\t\tif ( !entry[ pgdata->static_data.n_symbol_entry ] )\n\t\t\t\tgoto error;\n\t\t\tentry[ pgdata->static_data.n_symbol_entry ]\n\t\t\t\t->nSymbols = len;\n\n\t\t\tsymbol = symbols;\n\n\t\t\tfor ( i = 0; i < len; ++i ) {\n\t\t\t\tueStrNCpy(\n\t\t\t\t\tentry[ pgdata->static_data.n_symbol_entry ]->symbols[ i ],\n\t\t\t\t\tsymbol, 1, 1 );\n\t\t\t\t// FIXME: What if symbol is combining sequences.\n\t\t\t\tsymbol += ueBytesFromChar( symbol[0] );\n\t\t\t}\n\n\n\t\t} else {\n\t\t\tentry[ pgdata->static_data.n_symbol_entry ] =\n\t\t\t\t( SymbolEntry* ) malloc( sizeof ( entry[0][0] ) );\n\t\t\tif ( !entry[ pgdata->static_data.n_symbol_entry ] )\n\t\t\t\tgoto error;\n\n\t\t\tentry[ pgdata->static_data.n_symbol_entry ]\n\t\t\t\t->nSymbols = 0;\n\t\t}\n\n\t\t*category_end = 0;\n\t\tueStrNCpy(\n\t\t\tentry[pgdata->static_data.n_symbol_entry]->category,\n\t\t\tline, MAX_PHRASE_LEN, 1);\n\n\t\t++pgdata->static_data.n_symbol_entry;\n\t}\n\n\tsize = sizeof( *pgdata->static_data.symbol_table ) *\n\t\tpgdata->static_data.n_symbol_entry;\n\tpgdata->static_data.symbol_table = ( SymbolEntry ** ) malloc( size );\n\tif ( !pgdata->static_data.symbol_table )\n\t\tgoto error;\n\tmemcpy( pgdata->static_data.symbol_table, entry, size );\n\n\tret = 0;\nend:\n\tfree( entry );\n\tfree( line );\n\tfclose( file );\n\tfree ( filename );\n\treturn ret;\n\nerror:\n\tfor ( i = 0; i < pgdata->static_data.n_symbol_entry; ++i ) {\n\t\tfree( entry[ i ] );\n\t}\n\tgoto end;\n}",
        "begin_line": 1271,
        "end_line": 1378,
        "is_bug": false
    },
    {
        "name": "chewingutil.MakeOutput#852",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.MakeOutput( ChewingOutput *pgo, ChewingData *pgdata )",
        "snippet": "int MakeOutput( ChewingOutput *pgo, ChewingData *pgdata )\n{\n\tint i;\n\tchar *pos;\n\n\t/* fill zero to chiSymbolBuf first */\n\tpgo->preeditBuf[0] = 0;\n\tpgo->bopomofoBuf[0] = 0;\n\n\tpos = pgo->preeditBuf;\n\tfor ( i = 0; i < pgdata->chiSymbolBufLen &&\n\t\tpos < pgo->preeditBuf + sizeof( pgo->preeditBuf ) + MAX_UTF8_SIZE + 1; ++i ) {\n\t\tstrncpy( pos, pgdata->preeditBuf[ i ].char_, MAX_UTF8_SIZE + 1 );\n\t\tpos += strlen( pgdata->preeditBuf[ i ].char_ );\n\t}\n\n\t/* fill point */\n\tpgo->PointStart = pgdata->PointStart;\n\tpgo->PointEnd = pgdata->PointEnd;\n\n\t/* fill other fields */\n\tpgo->chiSymbolBufLen = pgdata->chiSymbolBufLen;\n\tpgo->chiSymbolCursor = pgdata->chiSymbolCursor;\n\n\t/* fill zuinBuf */\n\tif ( pgdata->zuinData.kbtype >= KB_HANYU_PINYIN ) {\n\t\tstrcpy( pgo->bopomofoBuf, pgdata->zuinData.pinYinData.keySeq );\n\t} else {\n\t\tfor ( i = 0; i < ZUIN_SIZE; i++ ) {\n\t\t\tif ( pgdata->zuinData.pho_inx[ i ] != 0 ) {\n\t\t\t\tueStrNCpy( pgo->bopomofoBuf + strlen( pgo->bopomofoBuf ),\n\t\t\t\t\tueConstStrSeek( (zhuin_tab[ i ] + 2),\n\t\t\t\t\t\tpgdata->zuinData.pho_inx[ i ] - 1 ),\n\t\t\t\t\t1, STRNCPY_CLOSE );\n\t\t\t}\n\t\t}\n\t}\n\n\tShiftInterval( pgo, pgdata );\n\tmemcpy(\n\t\tpgo->dispBrkpt, pgdata->bUserArrBrkpt,\n\t\tsizeof( pgo->dispBrkpt[ 0 ] ) * ( MAX_PHONE_SEQ_LEN + 1 ) );\n\tpgo->pci = &( pgdata->choiceInfo );\n\tpgo->bChiSym = pgdata->bChiSym;\n\tmemcpy( pgo->selKey, pgdata->config.selKey, sizeof( pgdata->config.selKey ) );\n\tpgdata->bShowMsg = 0;\n\treturn 0;\n}",
        "begin_line": 852,
        "end_line": 899,
        "is_bug": false
    },
    {
        "name": "chewingutil.MakeOutputWithRtn#901",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.MakeOutputWithRtn( ChewingOutput *pgo, ChewingData *pgdata, int keystrokeRtn )",
        "snippet": "int MakeOutputWithRtn( ChewingOutput *pgo, ChewingData *pgdata, int keystrokeRtn )\n{\n\tpgo->keystrokeRtn = keystrokeRtn;\n\treturn MakeOutput( pgo, pgdata );\n}",
        "begin_line": 901,
        "end_line": 905,
        "is_bug": false
    },
    {
        "name": "chewingutil.MakePreferInterval#786",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.MakePreferInterval( ChewingData *pgdata )",
        "snippet": "static void MakePreferInterval( ChewingData *pgdata )\n{\n\tint i, j, set_no;\n\tint belong_set[ MAX_PHONE_SEQ_LEN + 1 ];\n\tint parent[ MAX_PHONE_SEQ_LEN + 1 ];\n\n\tmemset( belong_set, 0 , sizeof( int ) * ( MAX_PHONE_SEQ_LEN + 1 ) );\n\tmemset( parent, 0, sizeof( int ) * ( MAX_PHONE_SEQ_LEN + 1 ) );\n\n\t/* for each interval */\n\tfor ( i = 0; i < pgdata->phrOut.nDispInterval; i++ ) {\n\t\tfor (\n\t\t\tj = pgdata->phrOut.dispInterval[ i ].from;\n\t\t\tj < pgdata->phrOut.dispInterval[ i ].to;\n\t\t\tj++ ) {\n\t\t\tbelong_set[ j ] = i + 1;\n\t\t}\n\t}\n\tset_no = i + 1;\n\tfor ( i = 0; i < pgdata->nPhoneSeq; i++ )\n\t\tif ( belong_set[i] == 0 )\n\t\t\tbelong_set[ i ] = set_no++;\n\n\t/* for each connect point */\n\tfor ( i = 1; i < pgdata->nPhoneSeq; i++ ) {\n\t\tif ( pgdata->bUserArrCnnct[ i ] ) {\n\t\t\tUnion( belong_set[ i - 1 ], belong_set[ i ], parent );\n\t\t}\n\t}\n\n\t/* generate new intervals */\n\tpgdata->nPrefer = 0;\n\ti = 0;\n\twhile ( i < pgdata->nPhoneSeq ) {\n\t\tfor ( j = i + 1; j < pgdata->nPhoneSeq; j++ )\n\t\t\tif ( ! SameSet( belong_set[ i ], belong_set[ j ], parent ) )\n\t\t\t\tbreak;\n\n\t\tpgdata->preferInterval[ pgdata->nPrefer ].from = i;\n\t\tpgdata->preferInterval[ pgdata->nPrefer ].to = j;\n\t\tpgdata->nPrefer++;\n\t\ti = j;\n\t}\n}",
        "begin_line": 786,
        "end_line": 829,
        "is_bug": false
    },
    {
        "name": "chewingutil.PhoneSeqCursor#954",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.PhoneSeqCursor( ChewingData *pgdata )",
        "snippet": "int PhoneSeqCursor( ChewingData *pgdata )\n{\n\tint cursor = pgdata->chiSymbolCursor - CountSymbols( pgdata, pgdata->chiSymbolCursor );\n\treturn cursor > 0 ? cursor : 0;\n}",
        "begin_line": 954,
        "end_line": 958,
        "is_bug": false
    },
    {
        "name": "chewingutil.ReleaseChiSymbolBuf#530",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ReleaseChiSymbolBuf( ChewingData *pgdata, ChewingOutput *pgo )",
        "snippet": "int ReleaseChiSymbolBuf( ChewingData *pgdata, ChewingOutput *pgo )\n{\n\tint throwEnd;\n\n\tthrowEnd = CountReleaseNum( pgdata );\n\n\t/*\n\t* When current buffer size exceeds maxChiSymbolLen,\n\t* we need to throw some of the characters at the head of the buffer and\n\t* commit them.\n\t*/\n\tif ( throwEnd ) {\n\t\t/*\n\t\t * count how many chinese words in \"chiSymbolBuf[ 0 .. (throwEnd - 1)]\"\n\t\t * And release from \"chiSymbolBuf\" && \"phoneSeq\"\n\t\t */\n\t\tWriteChiSymbolToCommitBuf( pgdata, pgo, throwEnd );\n\t\tKillFromLeft( pgdata, throwEnd );\n\t}\n\treturn throwEnd;\n}",
        "begin_line": 530,
        "end_line": 550,
        "is_bug": false
    },
    {
        "name": "chewingutil.RemoveSelectElement#965",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.RemoveSelectElement( int i, ChewingData *pgdata )",
        "snippet": "void RemoveSelectElement( int i, ChewingData *pgdata )\n{\n\tif ( --pgdata->nSelect == i )\n\t\treturn;\n\tpgdata->selectInterval[ i ] = pgdata->selectInterval[ pgdata->nSelect ];\n\tstrcpy( pgdata->selectStr[ i ], pgdata->selectStr[ pgdata->nSelect ] );\n}",
        "begin_line": 965,
        "end_line": 971,
        "is_bug": false
    },
    {
        "name": "chewingutil.SameSet#774",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.SameSet( int set1, int set2, int parent[] )",
        "snippet": "static int SameSet( int set1,int set2, int parent[] )\n{\n\twhile ( parent[ set1 ] != 0 ) {\n\t\tset1 = parent[ set1 ];\n\t}\n\twhile ( parent[ set2 ] != 0 ) {\n\t\tset2 = parent[ set2 ];\n\t}\n\treturn ( set1 == set2 );\n}",
        "begin_line": 774,
        "end_line": 783,
        "is_bug": false
    },
    {
        "name": "chewingutil.ShiftInterval#832",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ShiftInterval( ChewingOutput *pgo, ChewingData *pgdata )",
        "snippet": "static void ShiftInterval( ChewingOutput *pgo, ChewingData *pgdata )\n{\n\tint i, arrPos[ MAX_PHONE_SEQ_LEN ], k = 0, from, len;\n\n\tfor ( i = 0; i < pgdata->chiSymbolBufLen; i++ ) {\n\t\tif ( ChewingIsChiAt( i, pgdata ) ) {\n\t\t\tarrPos[ k++ ] = i;\n\t\t}\n\t}\n\tarrPos[ k ] = i;\n\n\tpgo->nDispInterval = pgdata->nPrefer;\n\tfor ( i = 0; i < pgdata->nPrefer; i++ ) {\n\t\tfrom = pgdata->preferInterval[ i ].from;\n\t\tlen = pgdata->preferInterval[ i ].to - from;\n\t\tpgo->dispInterval[ i ].from = arrPos[ from ];\n\t\tpgo->dispInterval[ i ].to = arrPos[ from ] + len;\n\t}\n}",
        "begin_line": 832,
        "end_line": 850,
        "is_bug": false
    },
    {
        "name": "chewingutil.ShowChewingData#682",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ShowChewingData( ChewingData *pgdata )",
        "snippet": "static void ShowChewingData( ChewingData *pgdata )\n{\n\tint i ;\n\n\tDEBUG_OUT(\n\t\t\"nPhoneSeq : %d\\n\"\n\t\t\"phoneSeq  : \",\n\t\tpgdata->nPhoneSeq );\n\tfor ( i = 0; i < pgdata->nPhoneSeq; i++ )\n\t\tDEBUG_OUT( \"%hu \", pgdata->phoneSeq[ i ] );\n\tDEBUG_OUT(\n\t\t\"[cursor : %d]\\n\"\n\t\t\"nSelect : %d\\n\"\n\t\t\"selectStr       selectInterval\\n\",\n\t\tPhoneSeqCursor( pgdata ),\n\t\tpgdata->nSelect );\n\tfor ( i = 0; i < pgdata->nSelect; i++ ) {\n\t\tDEBUG_OUT(\n\t\t\t\"  %14s%4d%4d\\n\",\n\t\t\tpgdata->selectStr[ i ],\n\t\t\tpgdata->selectInterval[ i ].from,\n\t\t\tpgdata->selectInterval[ i ].to );\n\t}\n\n\tDEBUG_OUT( \"bUserArrCnnct : \" );\n\tfor ( i = 0; i <= pgdata->nPhoneSeq; i++ )\n\t\tDEBUG_OUT( \"%d \", pgdata->bUserArrCnnct[ i ] );\n\tDEBUG_OUT( \"\\n\" );\n\n\tDEBUG_OUT( \"bUserArrBrkpt : \" );\n\tfor ( i = 0; i <= pgdata->nPhoneSeq; i++ )\n\t\tDEBUG_OUT( \"%d \", pgdata->bUserArrBrkpt[ i ] );\n\tDEBUG_OUT( \"\\n\" );\n\n\tDEBUG_OUT( \"bArrBrkpt     : \" );\n\tfor ( i = 0; i <= pgdata->nPhoneSeq; i++ )\n\t\tDEBUG_OUT( \"%d \", pgdata->bArrBrkpt[ i ] );\n\tDEBUG_OUT( \"\\n\" );\n\n\tDEBUG_OUT(\n\t\t\"bChiSym : %d , bSelect : %d\\n\",\n\t\tpgdata->bChiSym,\n\t\tpgdata->bSelect );\n}",
        "begin_line": 682,
        "end_line": 725,
        "is_bug": false
    },
    {
        "name": "chewingutil.TerminateEasySymbolTable#1452",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.TerminateEasySymbolTable( ChewingData *pgdata )",
        "snippet": "void TerminateEasySymbolTable( ChewingData *pgdata )\n{\n\tunsigned int i;\n\tfor ( i = 0; i < EASY_SYMBOL_KEY_TAB_LEN ; ++i ) {\n\t\tif ( NULL != pgdata->static_data.g_easy_symbol_value[ i ] ) {\n\t\t\tfree( pgdata->static_data.g_easy_symbol_value[ i ] );\n\t\t\tpgdata->static_data.g_easy_symbol_value[ i ] = NULL;\n\t\t}\n\t\tpgdata->static_data.g_easy_symbol_num[ i ] = 0;\n\t}\n}",
        "begin_line": 1452,
        "end_line": 1462,
        "is_bug": false
    },
    {
        "name": "chewingutil.TerminateSymbolTable#1380",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.TerminateSymbolTable( ChewingData *pgdata )",
        "snippet": "void TerminateSymbolTable( ChewingData *pgdata )\n{\n\tunsigned int i;\n\tif ( pgdata->static_data.symbol_table ) {\n\t\tfor ( i = 0; i < pgdata->static_data.n_symbol_entry; ++i )\n\t\t\tfree( pgdata->static_data.symbol_table[ i ] );\n\t\tfree( pgdata->static_data.symbol_table );\n\t\tpgdata->static_data.n_symbol_entry = 0;\n\t\tpgdata->static_data.symbol_table = NULL;\n\t}\n}",
        "begin_line": 1380,
        "end_line": 1390,
        "is_bug": false
    },
    {
        "name": "chewingutil.WriteChiSymbolToCommitBuf#448",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.WriteChiSymbolToCommitBuf( ChewingData *pgdata, ChewingOutput *pgo, int len )",
        "snippet": "void WriteChiSymbolToCommitBuf( ChewingData *pgdata, ChewingOutput *pgo, int len )\n{\n\tint i;\n\tchar *pos;\n\n\tassert( pgdata );\n\tassert( pgo );\n\n\tpgo->commitBufLen = len;\n\n\tpos = pgo->commitBuf;\n\tfor ( i = 0; i < pgo->commitBufLen; ++i ) {\n\t\tassert( pos + MAX_UTF8_SIZE + 1 < pgo->commitBuf + sizeof( pgo->commitBuf ) );\n\t\tstrcpy( pos, pgdata->preeditBuf[ i ].char_ );\n\t\tpos += strlen( pgdata->preeditBuf[ i ].char_ );\n\t}\n\t*pos = 0;\n}",
        "begin_line": 448,
        "end_line": 465,
        "is_bug": false
    },
    {
        "name": "chewingutil.copyStringFromPreeditBuf#1464",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.copyStringFromPreeditBuf( \tChewingData *pgdata, int pos, int len, char *output, int output_len )",
        "snippet": "void copyStringFromPreeditBuf(\n\tChewingData *pgdata, int pos, int len,\n\tchar *output, int output_len )\n{\n\tint i;\n\tint x;\n\n\tassert( pgdata );\n\tassert( 0 <= pos && pos + len < ARRAY_SIZE( pgdata->preeditBuf ) );\n\tassert( output );\n\tassert( output_len );\n\n\tfor ( i = pos; i < pos + len; ++i ) {\n\t\tx = strlen( pgdata->preeditBuf[ i ].char_ );\n\t\tif ( x >= output_len ) // overflow\n\t\t\treturn;\n\t\tmemcpy( output, pgdata->preeditBuf[ i ].char_, x );\n\t\toutput += x;\n\t\toutput_len -= x;\n\t}\n\toutput[0] = 0;\n}",
        "begin_line": 1464,
        "end_line": 1485,
        "is_bug": false
    },
    {
        "name": "choice.ChangeSelectIntervalAndBreakpoint#33",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChangeSelectIntervalAndBreakpoint( \t\tChewingData *pgdata, int from, int to, const char *str )",
        "snippet": "static void ChangeSelectIntervalAndBreakpoint(\n\t\tChewingData *pgdata,\n\t\tint from,\n\t\tint to,\n\t\tconst char *str )\n{\n\tint i;\n\tint user_alloc;\n\n\tIntervalType inte;\n\n\tinte.from = from;\n\tinte.to = to;\n\tfor ( i = 0; i < pgdata->nSelect; i++ ) {\n\t\tif ( IsIntersect( inte, pgdata->selectInterval[ i ] ) ) {\n\t\t\tRemoveSelectElement( i, pgdata );\n\t\t\ti--;\n\t\t}\n\t}\n\n\tpgdata->selectInterval[ pgdata->nSelect ].from = from;\n\tpgdata->selectInterval[ pgdata->nSelect ].to = to;\n\n\t/* No available selection */\n\tif ( ( user_alloc = ( to - from ) ) == 0 )\n\t\treturn;\n\n\tueStrNCpy( pgdata->selectStr[ pgdata->nSelect ],\n\t\t\tstr,\n\t\t\tuser_alloc, 1);\n\tpgdata->nSelect++;\n\n\tif ( user_alloc > 1 ) {\n\t\tmemset( &pgdata->bUserArrBrkpt[ from + 1 ], 0, sizeof( int ) * ( user_alloc - 1 ) );\n\t\tmemset( &pgdata->bUserArrCnnct[ from + 1 ], 0, sizeof( int ) * ( user_alloc - 1 ) );\n\t}\n}",
        "begin_line": 33,
        "end_line": 69,
        "is_bug": false
    },
    {
        "name": "choice.ChangeUserData#491",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChangeUserData( ChewingData *pgdata, int selectNo )",
        "snippet": "static void ChangeUserData( ChewingData *pgdata, int selectNo )\n{\n\tuint16_t userPhoneSeq[ MAX_PHONE_SEQ_LEN ];\n\tint len;\n\n\tlen = ueStrLen( pgdata->choiceInfo.totalChoiceStr[ selectNo ] );\n\tmemcpy(\n\t\tuserPhoneSeq,\n\t\t&( pgdata->phoneSeq[ PhoneSeqCursor( pgdata ) ] ),\n\t\tlen * sizeof( uint16_t ) );\n\tuserPhoneSeq[ len ] = 0;\n\tUserUpdatePhrase( pgdata, userPhoneSeq, pgdata->choiceInfo.totalChoiceStr[ selectNo ] );\n}",
        "begin_line": 491,
        "end_line": 503,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceEndChoice#476",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceEndChoice( ChewingData *pgdata )",
        "snippet": "int ChoiceEndChoice( ChewingData *pgdata )\n{\n\tpgdata->bSelect = 0;\n\tpgdata->choiceInfo.nTotalChoice = 0;\n\tpgdata->choiceInfo.nPage = 0;\n\n\tif ( pgdata->choiceInfo.isSymbol != WORD_CHOICE || pgdata->choiceInfo.isSymbol != SYMBOL_CHOICE_INSERT ) {\n\t\t/* return to the old chiSymbolCursor position */\n\t\tpgdata->chiSymbolCursor = pgdata->choiceInfo.oldChiSymbolCursor;\n\t\tassert ( pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen );\n\t}\n\tpgdata->choiceInfo.isSymbol = WORD_CHOICE;\n\treturn 0;\n}",
        "begin_line": 476,
        "end_line": 489,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceInfoAppendChi#179",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceInfoAppendChi( ChewingData *pgdata, ChoiceInfo *pci, uint16_t phone )",
        "snippet": "static void ChoiceInfoAppendChi( ChewingData *pgdata,  ChoiceInfo *pci, uint16_t phone )\n{\n\tPhrase tempWord;\n\tint len;\n\tif ( GetCharFirst( pgdata, &tempWord, phone ) ) {\n\t\tdo {\n\t\t\tlen = ueBytesFromChar( tempWord.phrase[ 0 ] );\n\t\t\tif ( ChoiceTheSame( pci, tempWord.phrase,\n\t\t\t\t\t    len) )\n\t\t\t\tcontinue;\n\t\t\tassert( pci->nTotalChoice < MAX_CHOICE );\n\t\t\tmemcpy(\n\t\t\t\tpci->totalChoiceStr[ pci->nTotalChoice ],\n\t\t\t\ttempWord.phrase, len );\n\t\t\tpci->totalChoiceStr[ pci->nTotalChoice ]\n\t\t\t\t\t   [ len ] = '\\0';\n\t\t\tpci->nTotalChoice++;\n\t\t} while ( GetVocabNext( pgdata, &tempWord ) );\n\t}\n}",
        "begin_line": 179,
        "end_line": 198,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceInitAvail#369",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceInitAvail( ChewingData *pgdata )",
        "snippet": "int ChoiceInitAvail( ChewingData *pgdata )\n{\n\tint end, begin;\n\n\t/* save old cursor position */\n\tpgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;\n\n\t/* see if there is some word in the cursor position */\n\tif ( pgdata->chiSymbolBufLen == pgdata->chiSymbolCursor ) {\n\t\tpgdata->chiSymbolCursor--;\n\t}\n\n\tend = PhoneSeqCursor( pgdata );\n\n\tif ( pgdata->config.bPhraseChoiceRearward ) {\n\t\tpgdata->chiSymbolCursor = SeekPhraseHead( pgdata ) +\n\t\t\tCountSymbols( pgdata, pgdata->chiSymbolCursor );\n\t}\n\tbegin = PhoneSeqCursor( pgdata );\n\n\tpgdata->bSelect = 1;\n\n\tSetAvailInfo( pgdata, begin, end );\n\n\tif ( ! pgdata->availInfo.nAvail )\n\t\treturn ChoiceEndChoice( pgdata );\n\n\tpgdata->availInfo.currentAvail = pgdata->availInfo.nAvail - 1;\n\tSetChoiceInfo( pgdata );\n\treturn 0;\n}",
        "begin_line": 369,
        "end_line": 399,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceSelect#506",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceSelect( ChewingData *pgdata, int selectNo )",
        "snippet": "int ChoiceSelect( ChewingData *pgdata, int selectNo )\n{\n\tChoiceInfo *pci = &( pgdata->choiceInfo );\n\tAvailInfo *pai = &( pgdata->availInfo );\n\n\tChangeUserData( pgdata, selectNo );\n\tChangeSelectIntervalAndBreakpoint(\n\t\t\tpgdata,\n\t\t\tPhoneSeqCursor( pgdata ),\n\t\t\tPhoneSeqCursor( pgdata ) + pai->avail[ pai->currentAvail ].len,\n\t\t\tpci->totalChoiceStr[ selectNo ] );\n\tChoiceEndChoice( pgdata );\n\treturn 0;\n}",
        "begin_line": 506,
        "end_line": 519,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceTheSame#169",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceTheSame( ChoiceInfo *pci, const char *str, int len )",
        "snippet": "static int ChoiceTheSame( ChoiceInfo *pci, const char *str, int len )\n{\n\tint i;\n\n\tfor ( i = 0; i < pci->nTotalChoice; i++ )\n\t\tif ( ! memcmp( pci->totalChoiceStr[ i ], str, len ) )\n\t\t\treturn 1;\n\treturn 0;\n}",
        "begin_line": 169,
        "end_line": 177,
        "is_bug": false
    },
    {
        "name": "choice.SeekPhraseHead#355",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.SeekPhraseHead( ChewingData *pgdata )",
        "snippet": "static int SeekPhraseHead( ChewingData *pgdata )\n{\n\tint i;\n\tint phoneSeq = PhoneSeqCursor( pgdata );\n\tfor ( i = pgdata->nPrefer - 1; i >= 0; i-- ) {\n\t\tif ( pgdata->preferInterval[ i ].from > phoneSeq\n\t\t\t\t|| pgdata->preferInterval[ i ].to < phoneSeq )\n\t\t\tcontinue;\n\t\treturn pgdata->preferInterval[ i ].from;\n\t}\n\treturn 0;\n}",
        "begin_line": 355,
        "end_line": 366,
        "is_bug": false
    },
    {
        "name": "choice.SetAvailInfo#72",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.SetAvailInfo( ChewingData *pgdata, int begin, int end)",
        "snippet": "static void SetAvailInfo( ChewingData *pgdata, int begin, int end)\n{\n\tAvailInfo *pai = &( pgdata->availInfo );\n\tconst uint16_t *phoneSeq = pgdata->phoneSeq;\n\tint nPhoneSeq = pgdata->nPhoneSeq;\n\tconst int *bSymbolArrBrkpt = pgdata->bSymbolArrBrkpt;\n\tint symbolArrBrkpt[ ARRAY_SIZE(pgdata->bSymbolArrBrkpt) ] = { 0 };\n\n\tconst TreeType *tree_pos;\n\tint diff;\n\tuint16_t userPhoneSeq[ MAX_PHONE_SEQ_LEN ];\n\n\tint i, head, head_tmp;\n\tint tail, tail_tmp;\n\tint pos;\n\n\thead = tail = 0;\n\n\tpai->nAvail = 0;\n\n\t/*\n\t * XXX: The phoneSeq, nPhoneSeq skip any symbol in preedit buffer,\n\t * while bSymbolArrBrkpt, does not skip any symbol in preedit\n\t * buffer. So we need to do some translate here.\n\t */\n\tfor ( i = 0; i < pgdata->chiSymbolBufLen; ++i ) {\n\t\tif ( bSymbolArrBrkpt[i] ) {\n\t\t\t/*\n\t\t\t * XXX: If preedit buffer starts with symbol, the pos\n\t\t\t * will become negative. In this case, we just ignore\n\t\t\t * this symbol because it does not create any break\n\t\t\t * point.\n\t\t\t */\n\t\t\tpos = i - CountSymbols( pgdata, i + 1 );\n\t\t\tif (pos >= 0)\n\t\t\t\tsymbolArrBrkpt[ pos ] = 1;\n\t\t}\n\t}\n\n\tif ( pgdata->config.bPhraseChoiceRearward ) {\n\t\tfor ( i = end; i >= begin; i--){\n\t\t\tif ( symbolArrBrkpt[ i ] )\n\t\t\t\tbreak;\n\t\t\thead = i;\n\t\t}\n\t\thead_tmp = end;\n\t} else {\n\t\thead_tmp = head = begin;\n\t}\n\n\tif ( pgdata->config.bPhraseChoiceRearward ) {\n\t\ttail_tmp = tail = end;\n\t} else {\n\t\tfor ( i = begin; i < nPhoneSeq; i++ ) {\n\t\t\ttail = i;\n\t\t\tif ( symbolArrBrkpt[ i ] )\n\t\t\t\tbreak;\n\t\t}\n\t\ttail_tmp = begin;\n\t}\n\n\twhile ( head <= head_tmp && tail_tmp <= tail ) {\n\t\tdiff = tail_tmp - head_tmp;\n\t\ttree_pos = TreeFindPhrase( pgdata, head_tmp, tail_tmp, phoneSeq );\n\n\t\tif ( tree_pos ) {\n\t\t\t/* save it! */\n\t\t\tpai->avail[ pai->nAvail ].len = diff + 1;\n\t\t\tpai->avail[ pai->nAvail ].id = tree_pos;\n\t\t\tpai->nAvail++;\n\t\t}\n\t\telse {\n\t\t\tmemcpy(\n\t\t\t\tuserPhoneSeq,\n\t\t\t\t&phoneSeq[ head_tmp ],\n\t\t\t\tsizeof( uint16_t ) * ( diff + 1 ) ) ;\n\t\t\tuserPhoneSeq[ diff + 1 ] = 0;\n\t\t\tif ( UserGetPhraseFirst( pgdata, userPhoneSeq ) ) {\n\t\t\t\t/* save it! */\n\t\t\t\tpai->avail[ pai->nAvail ].len = diff + 1;\n\t\t\t\tpai->avail[ pai->nAvail ].id = NULL;\n\t\t\t\tpai->nAvail++;\n\t\t\t} else {\n\t\t\t\tpai->avail[ pai->nAvail ].len = 0;\n\t\t\t\tpai->avail[ pai->nAvail ].id = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif ( pgdata->config.bPhraseChoiceRearward ) {\n\t\t\thead_tmp--;\n\t\t} else {\n\t\t\ttail_tmp++;\n\t\t}\n\t}\n}",
        "begin_line": 72,
        "end_line": 166,
        "is_bug": false
    },
    {
        "name": "choice.SetChoiceInfo#206",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.SetChoiceInfo( ChewingData *pgdata )",
        "snippet": "static void SetChoiceInfo( ChewingData *pgdata )\n{\n\tPhrase tempPhrase;\n\tint len;\n\tUserPhraseData *pUserPhraseData;\n\tuint16_t userPhoneSeq[ MAX_PHONE_SEQ_LEN ];\n\n\tChoiceInfo *pci = &( pgdata->choiceInfo );\n\tAvailInfo *pai = &( pgdata->availInfo );\n\tuint16_t *phoneSeq = pgdata->phoneSeq;\n\tuint16_t *phoneSeqAlt = pgdata->phoneSeqAlt;\n\tint cursor = PhoneSeqCursor( pgdata );\n\tint candPerPage = pgdata->config.candPerPage;\n\n\t/* Clears previous candidates. */\n\tmemset( pci->totalChoiceStr, '\\0',\n\t\tMAX_CHOICE * MAX_PHRASE_LEN * MAX_UTF8_SIZE + 1);\n\n\tpci->nTotalChoice = 0;\n\tlen = pai->avail[ pai->currentAvail ].len;\n\tassert(len);\n\n\t/* secondly, read tree phrase */\n\tif ( len == 1 ) { /* single character */\n\t\tChoiceInfoAppendChi( pgdata, pci, phoneSeq[ cursor ] );\n\n\t\tif ( phoneSeq[ cursor ] != phoneSeqAlt[ cursor ] ) {\n\t\t\tChoiceInfoAppendChi( pgdata, pci, phoneSeqAlt[ cursor ] );\n\t\t}\n\n\t\tif ( pgdata->zuinData.kbtype == KB_HSU ||\n\t\t     pgdata->zuinData.kbtype == KB_DVORAK_HSU ) {\n\t\t\tswitch ( phoneSeq[ cursor ] ) {\n\t\t\t\tcase 0x2800:\t/* '\u3118' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x30 );\t\t/* '\u311f' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x80:\t/* '\u3127' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x20 );\t\t/* '\u311d' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x2A00:\t/* '\u3119' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1 );\t\t/* '\u02d9' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xA00:\t/* '\u3109' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x2 );\t\t/* '\u02ca' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x800:\t/* '\u3108' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x3 ); \t\t/* '\u02c7' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x18:\t/* '\u311c' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1200 );\t/* '\u310d' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x10:\t/* '\u311b' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1600 );\t/* '\u310f' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x1E00:\t/* '\u3113' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1800 );\t/* '\u3110' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x4 );\t\t/* '\u02cb' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x58:\t/* '\u3124' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1400 );\t/* '\u310e' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x68:\t/* '\u3126' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1000 );\t/* '\u310c' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x60 );\t\t/* '\u3125' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x2200:\t/* '\u3115' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1C00 );\t/* '\u3112' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x2000:\t/* '\u3114' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1A00 );\t/* '\u3111' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x50:\t/* '\u3123' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0xE00 );\t/* '\u310b' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x48:\t/* '\u3122' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x600 );\t/* '\u3107' */\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* phrase */\n\telse {\n\t\tif ( pai->avail[ pai->currentAvail ].id ) {\n\t\t\tGetPhraseFirst( pgdata, &tempPhrase, pai->avail[ pai->currentAvail ].id );\n\t\t\tdo {\n\t\t\t\tif ( ChoiceTheSame(\n\t\t\t\t\tpci,\n\t\t\t\t\ttempPhrase.phrase,\n\t\t\t\t\tlen * ueBytesFromChar( tempPhrase.phrase[0] ) ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tueStrNCpy( pci->totalChoiceStr[ pci->nTotalChoice ],\n\t\t\t\t\t\ttempPhrase.phrase, len, 1);\n\t\t\t\tpci->nTotalChoice++;\n\t\t\t} while( GetVocabNext( pgdata, &tempPhrase ) );\n\t\t}\n\n\t\tmemcpy( userPhoneSeq, &phoneSeq[ cursor ], sizeof( uint16_t ) * len );\n\t\tuserPhoneSeq[ len ] = 0;\n\t\tpUserPhraseData = UserGetPhraseFirst( pgdata, userPhoneSeq );\n\t\tif ( pUserPhraseData ) {\n\t\t\tdo {\n\t\t\t\t/* check if the phrase is already in the choice list */\n\t\t\t\tif ( ChoiceTheSame(\n\t\t\t\t\tpci,\n\t\t\t\t\tpUserPhraseData->wordSeq,\n\t\t\t\t\tlen * ueBytesFromChar( pUserPhraseData->wordSeq[0] ) ) )\n\t\t\t\t\tcontinue;\n\t\t\t\t/* otherwise store it */\n\t\t\t\tueStrNCpy(\n\t\t\t\t\t\tpci->totalChoiceStr[ pci->nTotalChoice ],\n\t\t\t\t\t\tpUserPhraseData->wordSeq,\n\t\t\t\t\t\tlen, 1);\n\t\t\t\tpci->nTotalChoice++;\n\t\t\t} while ( ( pUserPhraseData =\n\t\t\t\t    UserGetPhraseNext( pgdata, userPhoneSeq ) ) != NULL );\n\t\t}\n\n\t}\n\n\t/* magic number */\n\tpci->nChoicePerPage = candPerPage;\n\tassert( pci->nTotalChoice > 0 );\n\tpci->nPage = CEIL_DIV( pci->nTotalChoice, pci->nChoicePerPage );\n\tpci->pageNo = 0;\n\tpci->isSymbol = WORD_CHOICE;\n}\n\n/*\n * Seek the start of the phrase (English characters",
        "begin_line": 206,
        "end_line": 350,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueBytesFromChar#42",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueBytesFromChar( unsigned char b )",
        "snippet": "int ueBytesFromChar( unsigned char b )\n{\n\treturn utf8len_tab[ b ];\n}",
        "begin_line": 42,
        "end_line": 45,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueConstStrSeek#69",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueConstStrSeek( const char *src, size_t n )",
        "snippet": "const char *ueConstStrSeek( const char *src, size_t n )\n{\n\tsize_t i = 0;\n\tconst char *iter = src;\n\tfor ( i = 0; i < n; i++ ) {\n\t\titer += ueBytesFromChar( iter[0] );\n\t}\n\treturn iter;\n}",
        "begin_line": 69,
        "end_line": 77,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueStrLen#29",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueStrLen( const char *str )",
        "snippet": "int ueStrLen( const char *str )\n{\n\tint length = 0;\n\tconst char *strptr = str;\n\n\twhile ( strptr[ 0 ] != '\\0' ) {\n\t\tstrptr += ueBytesFromChar( strptr[0] );\n\t\t++length;\n\t}\n\treturn length;\n}",
        "begin_line": 29,
        "end_line": 39,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueStrNBytes#48",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueStrNBytes( const char *str, int n )",
        "snippet": "int ueStrNBytes( const char *str, int n )\n{\n\tint i = 0, len = 0;\n\tconst char *iter = str;\n\tfor ( i = 0; i < n; i++ ) {\n\t\tlen += ueBytesFromChar( iter[ len ] );\n\t}\n\treturn len;\n}",
        "begin_line": 48,
        "end_line": 56,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueStrNCpy#59",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueStrNCpy( char dest[], const char *src, size_t n, int end )",
        "snippet": "int ueStrNCpy( char dest[], const char *src, size_t n, int end )\n{\n\tint len = 0;\n\tlen = ueStrNBytes( src, n );\n\tmemcpy( dest, src, len );\n\tif ( end == STRNCPY_CLOSE )\n\t\tdest[ len ] = '\\0';\n\treturn len;\n}",
        "begin_line": 59,
        "end_line": 67,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueStrSeek#79",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueStrSeek( char *src, size_t n )",
        "snippet": "char *ueStrSeek( char *src, size_t n )\n{\n\tsize_t i = 0;\n\tchar *iter = src;\n\tfor ( i = 0; i < n; i++ ) {\n\t\titer += ueBytesFromChar( iter[0] );\n\t}\n\treturn iter;\n}",
        "begin_line": 79,
        "end_line": 87,
        "is_bug": false
    },
    {
        "name": "common.key2pho.PhoneFromKey#127",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.PhoneFromKey( char *pho, const char *inputkey, int kbtype, int searchTimes )",
        "snippet": "int PhoneFromKey( char *pho, const char *inputkey, int kbtype, int searchTimes )\n{\n\tint len = strlen( inputkey ), i, s;\n\tconst char *pTarget;\n\n\tpho[ 0 ] = '\\0';\n\tfor ( i = 0; i < len; i++ ) {\n\t\tchar *findptr = NULL;\n\t\tint _index;\n\n\t\tfor (\n\t\t\t\ts = 0, pTarget = key_str[ kbtype ];\n\t\t\t\ts < searchTimes;\n\t\t\t\ts++, pTarget = findptr + 1 ) {\n\t\t\tfindptr = strchr( pTarget, inputkey[ i ] );\n\t\t\tif ( ! findptr ) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t_index = findptr - key_str[ kbtype ];\n\t\tueStrNCpy( ueStrSeek( pho, i ),\n\t\t           ueConstStrSeek( ph_str, _index ),\n\t\t\t   1, 0);\n\t}\n\tpho = ueStrSeek( pho, len );\n\tpho[0] = '\\0';\n\treturn 1;\n}",
        "begin_line": 127,
        "end_line": 154,
        "is_bug": false
    },
    {
        "name": "common.key2pho.PhoneInxFromKey#179",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.PhoneInxFromKey( int key, int type, int kbtype, int searchTimes )",
        "snippet": "int PhoneInxFromKey( int key, int type, int kbtype, int searchTimes )\n{\n\tchar keyStr[ 2 ], rtStr[ 10 ], *p;\n\n\tkeyStr[ 0 ] = key;\n\tkeyStr[ 1 ] = '\\0';\n\tif ( ! PhoneFromKey( rtStr, keyStr, kbtype, searchTimes ) )\n\t\treturn 0;\n\tp = strstr( zhuin_tab[ type ], rtStr );\n\tif ( ! p )\n\t\treturn 0;\n\treturn zhuin_tab_num[type] - ueStrLen(p);\n}",
        "begin_line": 179,
        "end_line": 191,
        "is_bug": false
    },
    {
        "name": "common.key2pho.UintFromPhone#96",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.UintFromPhone( const char *zhuin )",
        "snippet": "uint16_t UintFromPhone( const char *zhuin )\n{\n\tconst char *iter;\n\tchar *pos;\n\tchar buf[ MAX_UTF8_SIZE + 1 ];\n\tint len, result = 0;\n\tint zhuin_index = 0;\n\n\titer = zhuin;\n\n\twhile ( *iter && *iter != 0x20 ) {\n\t\tlen = ueStrNCpy( buf, iter, 1, STRNCPY_CLOSE );\n\n\t\tfor (; zhuin_index < ZUIN_SIZE; ++zhuin_index ) {\n\t\t\tpos = strstr( zhuin_tab[ zhuin_index ], buf );\n\t\t\tif ( pos ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ( zhuin_index >= ZUIN_SIZE ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tresult |= (zhuin_tab_num[ zhuin_index ] - ueStrLen( pos )) << shift[ zhuin_index ];\n\t\t++zhuin_index;\n\t\titer += len;\n\t}\n\treturn result;\n}",
        "begin_line": 96,
        "end_line": 125,
        "is_bug": false
    },
    {
        "name": "common.key2pho.UintFromPhoneInx#193",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.UintFromPhoneInx( const int ph_inx[] )",
        "snippet": "uint16_t UintFromPhoneInx( const int ph_inx[] )\n{\n\tint i;\n\tuint16_t result = 0;\n\n\tfor ( i = 0; i < ZUIN_SIZE; i++ )\n\t\tresult |= ph_inx[ i ] << shift[ i ];\n\treturn result;\n}",
        "begin_line": 193,
        "end_line": 201,
        "is_bug": false
    },
    {
        "name": "dict.GetCharFirst#72",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.GetCharFirst( ChewingData *pgdata, Phrase *wrd_ptr, uint16_t key )",
        "snippet": "int GetCharFirst( ChewingData *pgdata, Phrase *wrd_ptr, uint16_t key )\n{\n\t/* &key serves as an array whose begin and end are both 0. */\n\tconst TreeType *pinx = TreeFindPhrase( pgdata, 0, 0, &key );\n\n\tif ( ! pinx )\n\t\treturn 0;\n\tTreeChildRange( pgdata, pinx );\n\tGetVocabFromDict( pgdata, wrd_ptr );\n\treturn 1;\n}",
        "begin_line": 72,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "dict.GetPhraseFirst#89",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.GetPhraseFirst( ChewingData *pgdata, Phrase *phr_ptr, const TreeType *phrase_parent )",
        "snippet": "int GetPhraseFirst( ChewingData *pgdata, Phrase *phr_ptr, const TreeType *phrase_parent )\n{\n\tassert( phrase_parent );\n\n\tTreeChildRange( pgdata, phrase_parent );\n\tGetVocabFromDict( pgdata, phr_ptr );\n\treturn 1;\n}",
        "begin_line": 89,
        "end_line": 96,
        "is_bug": false
    },
    {
        "name": "dict.GetVocabFromDict#65",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.GetVocabFromDict( ChewingData *pgdata, Phrase *phr_ptr )",
        "snippet": "static void GetVocabFromDict( ChewingData *pgdata, Phrase *phr_ptr )\n{\n\tstrcpy(phr_ptr->phrase, pgdata->static_data.dict + GetUint24(pgdata->static_data.tree_cur_pos->phrase.pos));\n\tphr_ptr->freq = GetUint24(pgdata->static_data.tree_cur_pos->phrase.freq);\n\tpgdata->static_data.tree_cur_pos++;\n}",
        "begin_line": 65,
        "end_line": 70,
        "is_bug": false
    },
    {
        "name": "dict.GetVocabNext#98",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.GetVocabNext( ChewingData *pgdata, Phrase *phr_ptr )",
        "snippet": "int GetVocabNext( ChewingData *pgdata, Phrase *phr_ptr )\n{\n\tif ( pgdata->static_data.tree_cur_pos >= pgdata->static_data.tree_end_pos\n\t\t|| GetUint16(pgdata->static_data.tree_cur_pos->key) != 0)\n\t\treturn 0;\n\tGetVocabFromDict( pgdata, phr_ptr );\n\treturn 1;\n}",
        "begin_line": 98,
        "end_line": 105,
        "is_bug": false
    },
    {
        "name": "dict.InitDict#35",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.InitDict( ChewingData *pgdata, const char *prefix )",
        "snippet": "int InitDict( ChewingData *pgdata, const char *prefix )\n{\n\tchar filename[ PATH_MAX ];\n\tsize_t len;\n\tsize_t offset;\n\tsize_t file_size;\n\tsize_t csize;\n\n\tlen = snprintf( filename, sizeof( filename ), \"%s\" PLAT_SEPARATOR \"%s\", prefix, DICT_FILE );\n\tif ( len + 1 > sizeof( filename ) )\n\t\treturn -1;\n\n\tplat_mmap_set_invalid( &pgdata->static_data.dict_mmap );\n\tfile_size = plat_mmap_create( &pgdata->static_data.dict_mmap, filename, FLAG_ATTRIBUTE_READ );\n\tif ( file_size <= 0 )\n\t\treturn -1;\n\n\toffset = 0;\n\tcsize = file_size;\n\tpgdata->static_data.dict = (const char*)plat_mmap_set_view( &pgdata->static_data.dict_mmap, &offset, &csize );\n\tif ( !pgdata->static_data.dict )\n\t\treturn -1;\n\n\treturn 0;\n}",
        "begin_line": 35,
        "end_line": 59,
        "is_bug": false
    },
    {
        "name": "dict.TerminateDict#30",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.TerminateDict( ChewingData *pgdata )",
        "snippet": "void TerminateDict( ChewingData *pgdata )\n{\n\tplat_mmap_close( &pgdata->static_data.dict_mmap );\n}",
        "begin_line": 30,
        "end_line": 33,
        "is_bug": false
    },
    {
        "name": "hash.AlcUserPhraseSeq#28",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.AlcUserPhraseSeq( UserPhraseData *pData, int phonelen, int wordlen )",
        "snippet": "int AlcUserPhraseSeq( UserPhraseData *pData, int phonelen, int wordlen )\n{\n\tpData->phoneSeq = ALC( uint16_t, phonelen + 1 );\n\tif ( !pData->phoneSeq )\n\t\tgoto error;\n\tpData->wordSeq = ALC( char, wordlen + 1 );\n\tif ( !pData->wordSeq )\n\t\tgoto error;\n\n\treturn 1;\n\nerror:\n\tfree( pData->phoneSeq );\n\tfree( pData->wordSeq );\n\treturn 0;\n}",
        "begin_line": 28,
        "end_line": 43,
        "is_bug": false
    },
    {
        "name": "hash.FreeHashItem#485",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.FreeHashItem( HASH_ITEM *pItem )",
        "snippet": "void FreeHashItem( HASH_ITEM *pItem )\n{\n\twhile ( pItem ) {\n\t\tHASH_ITEM *next = pItem->next;\n\t\tfree( pItem->data.phoneSeq );\n\t\tfree( pItem->data.wordSeq );\n\t\tfree( pItem );\n\t\tpItem = next;\n\t}\n}",
        "begin_line": 485,
        "end_line": 494,
        "is_bug": false
    },
    {
        "name": "hash.HashFindEntry#89",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.HashFindEntry( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[] )",
        "snippet": "HASH_ITEM *HashFindEntry( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[] )\n{\n\tHASH_ITEM *pItem;\n\tint hashvalue;\n\n\thashvalue = HashFunc( phoneSeq );\n\n\tfor ( pItem = pgdata->static_data.hashtable[ hashvalue ]; pItem ; pItem = pItem->next ) {\n\t\tif (\n\t\t\t! strcmp( pItem->data.wordSeq, wordSeq ) &&\n\t\t\tPhoneSeqTheSame( pItem->data.phoneSeq, phoneSeq ) ) {\n\t\t\treturn pItem;\n\t\t}\n\t}\n\treturn NULL;\n}",
        "begin_line": 89,
        "end_line": 104,
        "is_bug": false
    },
    {
        "name": "hash.HashFindPhonePhrase#69",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.HashFindPhonePhrase( ChewingData *pgdata, const uint16_t phoneSeq[], HASH_ITEM *pItemLast )",
        "snippet": "HASH_ITEM *HashFindPhonePhrase( ChewingData *pgdata, const uint16_t phoneSeq[], HASH_ITEM *pItemLast )\n{\n\tHASH_ITEM *pNow = pItemLast ?\n\t\t\tpItemLast->next :\n\t\t\tpgdata->static_data.hashtable[ HashFunc( phoneSeq ) ];\n\n\tfor ( ; pNow; pNow = pNow->next )\n\t\tif ( PhoneSeqTheSame( pNow->data.phoneSeq, phoneSeq ) )\n\t\t\treturn pNow;\n\treturn NULL;\n}",
        "begin_line": 69,
        "end_line": 79,
        "is_bug": false
    },
    {
        "name": "hash.HashFunc#60",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.HashFunc( const uint16_t phoneSeq[] )",
        "snippet": "static unsigned int HashFunc( const uint16_t phoneSeq[] )\n{\n\tint i, value = 0;\n\n\tfor ( i = 0; phoneSeq[ i ] != 0; i++ )\n\t\tvalue ^= phoneSeq[ i ];\n\treturn ( value & ( HASH_TABLE_SIZE - 1 ) );\n}",
        "begin_line": 60,
        "end_line": 67,
        "is_bug": false
    },
    {
        "name": "hash.HashInsert#106",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.HashInsert( ChewingData *pgdata, UserPhraseData *pData )",
        "snippet": "HASH_ITEM *HashInsert( ChewingData *pgdata, UserPhraseData *pData )\n{\n\tint hashvalue;\n\tHASH_ITEM *pItem;\n\n\tpItem = HashFindEntry( pgdata, pData->phoneSeq, pData->wordSeq );\n\tif ( pItem != NULL )\n\t\treturn pItem;\n\n\tpItem = ALC( HASH_ITEM, 1 );\n\tif ( ! pItem )\n\t\treturn NULL;  /* Error occurs */\n\n\thashvalue = HashFunc( pData->phoneSeq );\n\t/* set the new element */\n\tpItem->next = pgdata->static_data.hashtable[ hashvalue ];\n\n\tmemcpy( &( pItem->data ), pData, sizeof( pItem->data ) );\n\tpItem->item_index = -1;\n\n\t/* set link to the new element */\n\tpgdata->static_data.hashtable[ hashvalue ] = pItem;\n\n\treturn pItem;\n}",
        "begin_line": 106,
        "end_line": 130,
        "is_bug": false
    },
    {
        "name": "hash.HashItem2Binary#172",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.HashItem2Binary( char *str, HASH_ITEM *pItem )",
        "snippet": "static void HashItem2Binary( char *str, HASH_ITEM *pItem )\n{\n\tint i, phraselen;\n\tchar *pc;\n\n\tmemset( str, 0, FIELD_SIZE );\n\tif ( sizeof(int) * 4 + ueStrLen( pItem->data.wordSeq ) * 2 +\n\t     strlen( pItem->data.wordSeq ) >= FIELD_SIZE ) {\n\t\t/* exceed buffer size */\n\t\treturn;\n\t}\n\n\t/* freq info */\n\tPutInt32PreservedEndian( pItem->data.userfreq, &str[ 0 ] );\n\tPutInt32PreservedEndian( pItem->data.recentTime, &str[ 4 ] );\n\tPutInt32PreservedEndian( pItem->data.maxfreq, &str[ 8 ] );\n\tPutInt32PreservedEndian( pItem->data.origfreq, &str[ 12 ] );\n\n\t/* phone seq*/\n\tphraselen = ueStrLen( pItem->data.wordSeq );\n\tstr[ 16 ] = phraselen;\n\tpc = &str[ 17 ];\n\tfor ( i = 0; i < phraselen; i++ ) {\n\t\tPutUint16PreservedEndian( pItem->data.phoneSeq[ i ], pc );\n\t\tpc += 2;\n\t}\n\n\t/* phrase */\n\t*pc = strlen( pItem->data.wordSeq );\n\tstrcpy( (pc + 1), pItem->data.wordSeq );\n\tpItem->data.wordSeq[ (unsigned char) *pc ] = '\\0';\n}",
        "begin_line": 172,
        "end_line": 203,
        "is_bug": false
    },
    {
        "name": "hash.HashItem2String#151",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.HashItem2String( char *str, HASH_ITEM *pItem )",
        "snippet": "static void HashItem2String( char *str, HASH_ITEM *pItem )\n{\n\tint i, len;\n\tchar buf[ FIELD_SIZE ];\n\n\tsprintf( str, \"%s \", pItem->data.wordSeq );\n\tlen = ueStrLen( pItem->data.wordSeq );\n\tfor ( i = 0; i < len; i++ ) {\n\t\tsprintf( buf, \"%hu \", pItem->data.phoneSeq[ i ] );\n\t\tstrcat( str, buf );\n\t}\n\tsprintf(\n\t\tbuf, \"%d %d %d %d\",\n\t\tpItem->data.userfreq, pItem->data.recentTime,\n\t\tpItem->data.maxfreq, pItem->data.origfreq );\n\tstrcat( str, buf );\n}",
        "begin_line": 151,
        "end_line": 167,
        "is_bug": false
    },
    {
        "name": "hash.HashModify#205",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.HashModify( ChewingData *pgdata, HASH_ITEM *pItem )",
        "snippet": "void HashModify( ChewingData *pgdata, HASH_ITEM *pItem )\n{\n\tFILE *outfile;\n\tchar str[ FIELD_SIZE + 1 ];\n\n\toutfile = fopen( pgdata->static_data.hashfilename, \"r+b\" );\n\tif ( !outfile )\n\t\treturn;\n\n\t/* update \"lifetime\" */\n\tfseek( outfile, strlen( BIN_HASH_SIG ), SEEK_SET );\n\tfwrite( &pgdata->static_data.chewing_lifetime, 1, 4, outfile );\n\tsprintf( str, \"%d\", pgdata->static_data.chewing_lifetime );\n\tDEBUG_OUT( \"HashModify-1: '%-75s'\\n\", str );\n\n\t/* update record */\n\tif ( pItem->item_index < 0 ) {\n\t\tfseek( outfile, 0, SEEK_END );\n\t\tpItem->item_index =\n\t\t\t( ftell( outfile ) - 4 - strlen( BIN_HASH_SIG ) ) / FIELD_SIZE;\n\t}\n\telse {\n\t\tfseek( outfile,\n\t\t\tpItem->item_index * FIELD_SIZE + 4 + strlen( BIN_HASH_SIG ),\n\t\t\tSEEK_SET );\n\t}\n\n\tHashItem2String( str, pItem );\n\tDEBUG_OUT( \"HashModify-2: '%-75s'\\n\", str );\n\n\tHashItem2Binary( str, pItem );\n\tfwrite( str, 1, FIELD_SIZE, outfile );\n\tfflush( outfile );\n\tfclose( outfile );\n}",
        "begin_line": 205,
        "end_line": 239,
        "is_bug": false
    },
    {
        "name": "hash.InitHash#532",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.InitHash( ChewingData *pgdata )",
        "snippet": "int InitHash( ChewingData *pgdata )\n{\n\tHASH_ITEM item, *pItem, *pPool = NULL;\n\tint item_index, hashvalue, iret, fsize, hdrlen, oldest = INT_MAX;\n\tchar *dump, *seekdump;\n\n\tsetHashFileName( pgdata );\n\tmemset( pgdata->static_data.hashtable, 0, sizeof( pgdata->static_data.hashtable ) );\n\nopen_hash_file:\n\tdump = _load_hash_file( pgdata->static_data.hashfilename, &fsize );\n\thdrlen = strlen( BIN_HASH_SIG ) + sizeof(pgdata->static_data.chewing_lifetime);\n\titem_index = 0;\n\tif ( dump == NULL || fsize < hdrlen ) {\n\t\tFILE *outfile;\n\t\toutfile = fopen( pgdata->static_data.hashfilename, \"w+b\" );\n\t\tif ( ! outfile ) {\n\t\t\tif ( dump ) {\n\t\t\t\tfree( dump );\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tpgdata->static_data.chewing_lifetime = 0;\n\t\tfwrite( BIN_HASH_SIG, 1, strlen( BIN_HASH_SIG ), outfile );\n\t\tfwrite( &pgdata->static_data.chewing_lifetime, 1,\n\t\t                sizeof(pgdata->static_data.chewing_lifetime), outfile );\n\t\tfclose( outfile );\n\t}\n\telse {\n\t\tif ( memcmp(dump, BIN_HASH_SIG, strlen(BIN_HASH_SIG)) != 0 ) {\n\t\t\t/* perform migrate from text-based to binary form */\n\t\t\tfree( dump );\n\t\t\tif ( ! migrate_hash_to_bin( pgdata ) ) {\n\t\t\t\treturn  0;\n\t\t\t}\n\t\t\tgoto open_hash_file;\n\t\t}\n\n\t\tpgdata->static_data.chewing_lifetime = *(int *) (dump + strlen( BIN_HASH_SIG ));\n\t\tseekdump = dump + hdrlen;\n\t\tfsize -= hdrlen;\n\n\t\twhile ( fsize >= FIELD_SIZE ) {\n\t\t\tiret = ReadHashItem_bin( seekdump, &item, item_index++ );\n\t\t\t/* Ignore illegal data */\n\t\t\tif ( iret == -1 ) {\n\t\t\t\tseekdump += FIELD_SIZE;\n\t\t\t\tfsize -= FIELD_SIZE;\n\t\t\t\t--item_index;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if ( iret == 0 )\n\t\t\t\tbreak;\n\n\t\t\tpItem = ALC( HASH_ITEM, 1 );\n\t\t\tmemcpy( pItem, &item, sizeof( HASH_ITEM ) );\n\t\t\tpItem->next = pPool;\n\t\t\tpPool = pItem;\n\n\t\t\tif ( oldest > pItem->data.recentTime ) {\n\t\t\t\toldest = pItem->data.recentTime;\n\t\t\t}\n\n\t\t\tseekdump += FIELD_SIZE;\n\t\t\tfsize -= FIELD_SIZE;\n\t\t}\n\t\tfree( dump );\n\n\t\twhile ( pPool ) {\n\t\t\tpItem = pPool;\n\t\t\tpPool = pItem->next;\n\n\t\t\thashvalue = HashFunc( pItem->data.phoneSeq );\n\t\t\tpItem->next = pgdata->static_data.hashtable[ hashvalue ];\n\t\t\tpgdata->static_data.hashtable[ hashvalue ] = pItem;\n\t\t\tpItem->data.recentTime -= oldest;\n\t\t}\n\t\tpgdata->static_data.chewing_lifetime -= oldest;\n\t}\n\treturn 1;\n}",
        "begin_line": 532,
        "end_line": 612,
        "is_bug": false
    },
    {
        "name": "hash.PhoneSeqTheSame#45",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.PhoneSeqTheSame( const uint16_t p1[], const uint16_t p2[] )",
        "snippet": "static int PhoneSeqTheSame( const uint16_t p1[], const uint16_t p2[] )\n{\n\tint i;\n\tif ( ! p1 || ! p2 )\t/* FIXME: should not happend. */\n\t\treturn 0;\n\n\tfor ( i = 0; ( p1[ i ] != 0 && p2[ i ] != 0 ); i++ ) {\n\t\tif ( p1[ i ] != p2[ i ] )\n\t\t\treturn 0;\n\t}\n\tif ( p1[ i ] != p2[ i ] )\n\t\treturn 0;\n\treturn 1;\n}",
        "begin_line": 45,
        "end_line": 58,
        "is_bug": false
    },
    {
        "name": "hash.TerminateHash#496",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.TerminateHash( ChewingData *pgdata )",
        "snippet": "void TerminateHash( ChewingData *pgdata )\n{\n\tHASH_ITEM *pItem;\n\tint i;\n\tfor ( i = 0; i < HASH_TABLE_SIZE; ++i ) {\n\t\tpItem = pgdata->static_data.hashtable[ i ];\n\t\tDEBUG_CHECKPOINT();\n\t\tFreeHashItem( pItem );\n\t}\n}",
        "begin_line": 496,
        "end_line": 505,
        "is_bug": false
    },
    {
        "name": "hash._load_hash_file#387",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash._load_hash_file( const char *filename, int *size )",
        "snippet": "static char *_load_hash_file( const char *filename, int *size )\n{\n\tint flen;\n\tchar *pd = NULL;\n\tFILE *tf;\n\n\ttf = open_file_get_length( filename, \"rb\", &flen );\n\tif ( tf == NULL ) {\n\t\tgoto err_load_file;\n\t}\n\tpd = ALC( char, flen );\n\tif ( pd == NULL ) {\n\t\tgoto err_load_file;\n\t}\n\tif ( fread( pd, flen, 1, tf ) != 1 ) {\n\t\tgoto err_load_file;\n\t}\n\tfclose( tf );\n\tif ( size != NULL )\n\t\t*size = flen;\n\treturn pd;\n\nerr_load_file:\n\tif ( pd != NULL )\n\t\tfree( pd );\n\tif ( tf != NULL )\n\t\tfclose( tf );\n\treturn NULL;\n}",
        "begin_line": 387,
        "end_line": 415,
        "is_bug": false
    },
    {
        "name": "hash.open_file_get_length#371",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.open_file_get_length( \t\tconst char *filename, const char *otype, int *size)",
        "snippet": "static FILE *open_file_get_length(\n\t\tconst char *filename,\n\t\tconst char *otype, int *size)\n{\n\tFILE *tf = fopen( filename, otype );\n\tif ( tf == NULL ) {\n\t\treturn NULL;\n\t}\n\tif ( size != NULL ) {\n\t\tfseek( tf, 0, SEEK_END );\n\t\t*size = ftell( tf );\n\t\tfseek( tf, 0, SEEK_SET );\n\t}\n\treturn tf;\n}",
        "begin_line": 371,
        "end_line": 385,
        "is_bug": false
    },
    {
        "name": "hash.setHashFileName#507",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.setHashFileName( ChewingData *pgdata )",
        "snippet": "void setHashFileName( ChewingData *pgdata )\n{\n\tchar *path;\n\n\tpath = getenv( \"CHEWING_USER_PATH\" );\n\n\t/* make sure of write permission */\n\tif ( path && access( path, W_OK ) == 0 ) {\n\t\tsnprintf( pgdata->static_data.hashfilename, sizeof( pgdata->static_data.hashfilename ),\n\t\t\t\"%s\" PLAT_SEPARATOR \"%s\", path, HASH_FILE );\n\t\treturn;\n\t}\n\n\tpath = getenv( \"HOME\" );\n\tif ( !path ) {\n\t\tpath = PLAT_TMPDIR;\n\t}\n\n\tsnprintf( pgdata->static_data.hashfilename, sizeof( pgdata->static_data.hashfilename ),\n\t\t\"%s%s\", path, CHEWING_HASH_PATH);\n\tPLAT_MKDIR( pgdata->static_data.hashfilename );\n\tstrcat( pgdata->static_data.hashfilename, PLAT_SEPARATOR );\n\tstrcat( pgdata->static_data.hashfilename, HASH_FILE );\n}",
        "begin_line": 507,
        "end_line": 530,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_buffer_Check#45",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_buffer_Check( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_buffer_Check( ChewingContext *ctx )\n{\n\treturn (ctx->output->chiSymbolBufLen != 0);\n}",
        "begin_line": 45,
        "end_line": 48,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_buffer_Len#50",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_buffer_Len( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_buffer_Len( ChewingContext *ctx )\n{\n\treturn ctx->output->chiSymbolBufLen;\n}",
        "begin_line": 50,
        "end_line": 53,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_buffer_String#55",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_buffer_String( ChewingContext *ctx )",
        "snippet": "CHEWING_API char *chewing_buffer_String( ChewingContext *ctx )\n{\n\treturn strdup( ctx->output->preeditBuf );\n}",
        "begin_line": 55,
        "end_line": 58,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_cursor_Current#97",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_cursor_Current( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_cursor_Current( ChewingContext *ctx )\n{\n\treturn (ctx->output->chiSymbolCursor);\n}",
        "begin_line": 97,
        "end_line": 100,
        "is_bug": false
    },
    {
        "name": "pinyin.InitPinyin#29",
        "src_path": "src/pinyin.c",
        "class_name": "pinyin",
        "signature": "pinyin.InitPinyin( ChewingData *pgdata, const char *prefix )",
        "snippet": "int InitPinyin( ChewingData *pgdata, const char *prefix )\n{\n\tchar filename[ PATH_MAX ];\n\tint i;\n\tFILE *fd;\n\tint ret;\n\n\tsprintf( filename,\n\t\t\"%s\" PLAT_SEPARATOR \"%s\",\n\t\tprefix, PINYIN_TAB_NAME );\n\n\tfd = fopen(filename, \"r\");\n\n\tif ( ! fd )\n\t\treturn 0;\n\n\tret = fscanf( fd, \"%d\", &pgdata->static_data.HANYU_INITIALS );\n\tif ( ret != 1 ) {\n\t\treturn 0;\n\t}\n\t++pgdata->static_data.HANYU_INITIALS;\n\tpgdata->static_data.hanyuInitialsMap = ALC( keymap, pgdata->static_data.HANYU_INITIALS );\n\tfor ( i = 0; i < pgdata->static_data.HANYU_INITIALS - 1; i++ ) {\n\t\tret = fscanf( fd, \"%s %s\",\n\t\t\tpgdata->static_data.hanyuInitialsMap[ i ].pinyin,\n\t\t\tpgdata->static_data.hanyuInitialsMap[ i ].zuin );\n\t\tif ( ret != 2 ) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tret = fscanf( fd, \"%d\", &pgdata->static_data.HANYU_FINALS );\n\tif ( ret != 1 ) {\n\t\treturn 0;\n\t}\n\t++pgdata->static_data.HANYU_FINALS;\n\tpgdata->static_data.hanyuFinalsMap = ALC( keymap, pgdata->static_data.HANYU_FINALS );\n\tfor ( i = 0; i < pgdata->static_data.HANYU_FINALS - 1; i++ ) {\n\t\tret = fscanf( fd, \"%s %s\",\n\t\t\tpgdata->static_data.hanyuFinalsMap[ i ].pinyin,\n\t\t\tpgdata->static_data.hanyuFinalsMap[ i ].zuin );\n\t\tif ( ret != 2 ) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfclose( fd );\n\n\treturn 1;\n}",
        "begin_line": 29,
        "end_line": 78,
        "is_bug": false
    },
    {
        "name": "pinyin.TerminatePinyin#23",
        "src_path": "src/pinyin.c",
        "class_name": "pinyin",
        "signature": "pinyin.TerminatePinyin( ChewingData *pgdata )",
        "snippet": "void TerminatePinyin( ChewingData *pgdata )\n{\n\tfree( pgdata->static_data.hanyuInitialsMap );\n\tfree( pgdata->static_data.hanyuFinalsMap );\n}",
        "begin_line": 23,
        "end_line": 27,
        "is_bug": false
    },
    {
        "name": "porting_layer.plat_path.are_all_files_readable#130",
        "src_path": "src/porting_layer/src/plat_path.c",
        "class_name": "porting_layer.plat_path",
        "signature": "porting_layer.plat_path.are_all_files_readable( \tconst char *path, const char * const *files, char *output, size_t output_len )",
        "snippet": "static int are_all_files_readable(\n\tconst char *path,\n\tconst char * const *files,\n\tchar *output,\n\tsize_t output_len )\n{\n\tint i;\n\n\tassert( path );\n\tassert( files );\n\n\tfor ( i = 0; files[i] != NULL; ++i ) {\n\t\tsnprintf( output, output_len, \"%s\" PLAT_SEPARATOR \"%s\", path,\n\t\t\t\tfiles[i] );\n\t\tif ( access( output, R_OK ) != 0 ) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}",
        "begin_line": 130,
        "end_line": 150,
        "is_bug": false
    },
    {
        "name": "porting_layer.plat_path.find_path_by_files#152",
        "src_path": "src/porting_layer/src/plat_path.c",
        "class_name": "porting_layer.plat_path",
        "signature": "porting_layer.plat_path.find_path_by_files( \tconst char *search_path, const char * const *files, char *output, size_t output_len )",
        "snippet": "int find_path_by_files(\n\tconst char *search_path,\n\tconst char * const *files,\n\tchar *output,\n\tsize_t output_len )\n{\n\tchar buffer[PATH_MAX];\n\tchar *path;\n\tchar *saveptr;\n\tint ret;\n\n\tassert( search_path );\n\tassert( files );\n\tassert( output );\n\tassert( output_len );\n\n\t// strtok_r will modify its first parameter.\n\tstrncpy( buffer, search_path, sizeof( buffer ) );\n\n\tfor ( path = strtok_r( buffer, SEARCH_PATH_SEP, &saveptr );\n\t\tpath; path = strtok_r( NULL, SEARCH_PATH_SEP, &saveptr ) ) {\n\n\t\tret = are_all_files_readable( path, files, output, output_len );\n\t\tif ( ret ) {\n\t\t\tsnprintf( output, output_len, \"%s\", path );\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}",
        "begin_line": 152,
        "end_line": 181,
        "is_bug": false
    },
    {
        "name": "tree.AddInterval#286",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.AddInterval( \t\tTreeDataType *ptd, int begin, int end, Phrase *p_phrase, int dict_or_user )",
        "snippet": "static void AddInterval(\n\t\tTreeDataType *ptd, int begin , int end,\n\t\tPhrase *p_phrase, int dict_or_user )\n{\n\tptd->interval[ ptd->nInterval ].from = begin;\n\tptd->interval[ ptd->nInterval ].to = end + 1;\n\tptd->interval[ ptd->nInterval ].p_phr = p_phrase;\n\tptd->interval[ ptd->nInterval ].source = dict_or_user;\n\tptd->nInterval++;\n}",
        "begin_line": 286,
        "end_line": 295,
        "is_bug": false
    },
    {
        "name": "tree.CheckBreakpoint#108",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CheckBreakpoint( int from, int to, int bArrBrkpt[] )",
        "snippet": "static int CheckBreakpoint( int from, int to, int bArrBrkpt[] )\n{\n\tint i;\n\tfor ( i = from + 1; i < to; i++ )\n\t\tif ( bArrBrkpt[ i ] )\n\t\t\treturn 0;\n\treturn 1;\n}",
        "begin_line": 108,
        "end_line": 115,
        "is_bug": false
    },
    {
        "name": "tree.CheckChoose#195",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CheckChoose( \t\tChewingData *pgdata, const TreeType *phrase_parent, int from, int to, Phrase **pp_phr, char selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ], IntervalType selectInterval[], int nSelect )",
        "snippet": "static int CheckChoose(\n\t\tChewingData *pgdata,\n\t\tconst TreeType *phrase_parent, int from, int to, Phrase **pp_phr,\n\t\tchar selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ],\n\t\tIntervalType selectInterval[], int nSelect )\n{\n\tIntervalType inte, c;\n\tint chno, len;\n\tPhrase *phrase = ALC( Phrase, 1 );\n\n\tassert( phrase );\n\tinte.from = from;\n\tinte.to = to;\n\t*pp_phr = NULL;\n\n\t/* if there exist one phrase satisfied all selectStr then return 1, else return 0. */\n\tGetPhraseFirst( pgdata, phrase, phrase_parent );\n\tdo {\n\t\tfor ( chno = 0; chno < nSelect; chno++ ) {\n\t\t\tc = selectInterval[ chno ];\n\n\t\t\tif ( IsContain( inte, c ) ) {\n\t\t\t\t/* find a phrase under phrase_parent where the text contains\n\t\t\t\t * 'selectStr[chno]' test if not ok then return 0, if ok\n\t\t\t\t * then continue to test\n\t\t\t\t */\n\t\t\t\tlen = c.to - c.from;\n\t\t\t\tif ( memcmp(\n\t\t\t\t\tueStrSeek( phrase->phrase, c.from - from ),\n\t\t\t\t\tselectStr[ chno ],\n\t\t\t\t\tueStrNBytes( selectStr[ chno ], len ) ) )\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ( IsIntersect( inte, selectInterval[ chno ] ) ) {\n\t\t\t\tfree( phrase );\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif ( chno == nSelect ) {\n\t\t\t*pp_phr = phrase;\n\t\t\treturn 1;\n\t\t}\n\t} while ( GetVocabNext( pgdata, phrase ) );\n\tfree( phrase );\n\treturn 0;\n}",
        "begin_line": 195,
        "end_line": 240,
        "is_bug": false
    },
    {
        "name": "tree.CheckUserChoose#117",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CheckUserChoose( \t\tChewingData *pgdata, uint16_t *new_phoneSeq, int from, int to, Phrase **pp_phr, char selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ], IntervalType selectInterval[], int nSelect )",
        "snippet": "static int CheckUserChoose(\n\t\tChewingData *pgdata,\n\t\tuint16_t *new_phoneSeq, int from , int to,\n\t\tPhrase **pp_phr,\n\t\tchar selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ],\n\t\tIntervalType selectInterval[], int nSelect )\n{\n\tIntervalType inte, c;\n\tint chno, len;\n\tint user_alloc;\n\tUserPhraseData *pUserPhraseData;\n\tPhrase *p_phr = ALC( Phrase, 1 );\n\n\tassert( p_phr );\n\tinte.from = from;\n\tinte.to = to;\n\t*pp_phr = NULL;\n\n\t/* pass 1\n\t * if these exist one selected interval which is not contained by inte\n\t * but has intersection with inte, then inte is an unacceptable interval\n\t */\n\tfor ( chno = 0; chno < nSelect; chno++ ) {\n\t\tc = selectInterval[ chno ];\n\t\tif ( IsIntersect( inte, c ) && ! IsContain( inte, c ) ) {\n\t\t\tfree( p_phr );\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* pass 2\n\t * if there exist one phrase satisfied all selectStr then return 1, else return 0.\n\t * also store the phrase with highest freq\n\t */\n\tpUserPhraseData = UserGetPhraseFirst( pgdata, new_phoneSeq );\n\tp_phr->freq = -1;\n\tdo {\n\t\tfor ( chno = 0; chno < nSelect; chno++ ) {\n\t\t\tc = selectInterval[ chno ];\n\n\t\t\tif ( IsContain( inte, c ) ) {\n\t\t\t\t/*\n\t\t\t\t * find a phrase of ph_id where the text contains\n\t\t\t\t * 'selectStr[chno]' test if not ok then return 0,\n\t\t\t\t * if ok then continue to test. */\n\t\t\t\tlen = c.to - c.from;\n\t\t\t\tif ( memcmp(\n\t\t\t\t\tueStrSeek( pUserPhraseData->wordSeq, c.from - from ),\n\t\t\t\t\tselectStr[ chno ],\n\t\t\t\t\tueStrNBytes( selectStr[ chno ], len ) ) )\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tif ( chno == nSelect ) {\n\t\t\t/* save phrase data to \"pp_phr\" */\n\t\t\tif ( pUserPhraseData->userfreq > p_phr->freq ) {\n\t\t\t\tif ( ( user_alloc = ( to - from ) ) > 0 ) {\n\t\t\t\t\tueStrNCpy( p_phr->phrase,\n\t\t\t\t\t\t\tpUserPhraseData->wordSeq,\n\t\t\t\t\t\t\tuser_alloc, 1);\n\t\t\t\t}\n\t\t\t\tp_phr->freq = pUserPhraseData->userfreq;\n\t\t\t\t*pp_phr = p_phr;\n\t\t\t}\n\t\t}\n\t} while ( ( pUserPhraseData = UserGetPhraseNext( pgdata, new_phoneSeq ) ) != NULL );\n\n\tif ( p_phr->freq != -1 )\n\t\treturn 1;\n\n\tfree( p_phr );\n\treturn 0;\n}",
        "begin_line": 117,
        "end_line": 190,
        "is_bug": false
    },
    {
        "name": "tree.CleanUpMem#801",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CleanUpMem( TreeDataType *ptd )",
        "snippet": "static void CleanUpMem( TreeDataType *ptd )\n{\n\tint i;\n\tRecordNode *pNode;\n\n\tfor ( i = 0; i < ptd->nInterval; i++ ) {\n\t\tif ( ptd->interval[ i ].p_phr ) {\n\t\t\tfree( ptd->interval[ i ].p_phr );\n\t\t\tptd->interval[ i ].p_phr = NULL;\n\t\t}\n\t}\n\twhile ( ptd->phList != NULL ) {\n\t\tpNode = ptd->phList;\n\t\tptd->phList = pNode->next;\n\t\tfree( pNode->arrIndex );\n\t\tfree( pNode );\n\t}\n}",
        "begin_line": 801,
        "end_line": 818,
        "is_bug": false
    },
    {
        "name": "tree.CompTreeType#242",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CompTreeType( const void *a, const void *b )",
        "snippet": "static int CompTreeType( const void *a, const void *b )\n{\n\treturn GetUint16(((TreeType*)a)->key) - GetUint16(((TreeType*)b)->key);\n}",
        "begin_line": 242,
        "end_line": 245,
        "is_bug": false
    },
    {
        "name": "tree.CreateNullIntervalRecord#965",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CreateNullIntervalRecord()",
        "snippet": "static RecordNode * CreateNullIntervalRecord()\n{\n\tRecordNode *ret = NULL;\n\tret = ALC( RecordNode, 1 );\n\tif ( !ret )\n\t\treturn NULL;\n\n\tret->arrIndex = ALC( int, 1 );\n\tif ( !ret->arrIndex ) {\n\t\tfree( ret );\n\t\treturn NULL;\n\t}\n\n\tret->nInter = 0;\n\tret->score = 0;\n\n\treturn ret;\n}",
        "begin_line": 965,
        "end_line": 982,
        "is_bug": false
    },
    {
        "name": "tree.CreateSingleIntervalRecord#941",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CreateSingleIntervalRecord( TreeDataType *pdt, const int interval_id )",
        "snippet": "static RecordNode * CreateSingleIntervalRecord( TreeDataType *pdt, const int interval_id )\n{\n\tRecordNode *ret = NULL;\n\n\tassert( pdt );\n\n\tret = ALC( RecordNode, 1 );\n\tif ( !ret )\n\t\treturn NULL;\n\n\tret->arrIndex = ALC( int, 1 );\n\tif ( !ret->arrIndex ) {\n\t\tfree( ret );\n\t\treturn NULL;\n\t}\n\n\tret->nInter = 1;\n\tret->arrIndex[0] = interval_id;\n\n\tret->score = LoadPhraseAndCountScore( ret->arrIndex, ret->nInter, pdt );\n\n\treturn ret;\n}",
        "begin_line": 941,
        "end_line": 963,
        "is_bug": false
    },
    {
        "name": "tree.Discard1#453",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.Discard1( TreeDataType *ptd )",
        "snippet": "static void Discard1( TreeDataType *ptd )\n{\n\tint a, b;\n\tchar failflag[ INTERVAL_SIZE ];\n\tint nInterval2;\n\n\tmemset( failflag, 0, sizeof( failflag ) );\n\tfor ( a = 0; a < ptd->nInterval; a++ ) {\n\t\tif ( failflag[ a ] )\n\t\t\tcontinue;\n\t\tfor ( b = 0; b < ptd->nInterval; b++ ) {\n\t\t\tif ( a == b || failflag[ b ] )\n\t\t\t\tcontinue ;\n\n\t\t\t/* interval b is in interval a */\n\t\t\tif ( PhraseIntervalContain( ptd->interval[ a ], ptd->interval[ b ] ) )\n\t\t\t\tcontinue;\n\n\t\t\t/* interval b is in front of interval a */\n\t\t\tif ( ptd->interval[ b ].to <= ptd->interval[ a ].from )\n\t\t\t\tcontinue;\n\n\t\t\t/* interval b is in back of interval a */\n\t\t\tif ( ptd->interval[ a ].to <= ptd->interval[ b ].from )\n\t\t\t\tcontinue;\n\n\t\t\tbreak;\n\t\t}\n\t\t/* if any other interval b is inside or leftside or rightside the\n\t\t * interval a */\n\t\tif ( b >= ptd->nInterval ) {\n\t\t\t/* then kill all the intervals inside the interval a */\n\t\t\tint i;\n\t\t\tfor ( i = 0; i < ptd->nInterval; i++ ) {\n\t\t\t\tif (! failflag[ i ] && i != a &&\n\t\t\t\t\tPhraseIntervalContain( ptd->interval[ a ], ptd->interval[ i ] ) ) {\n\t\t\t\t\tfailflag[ i ] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/* discard all the intervals whose failflag[a] = 1 */\n\tnInterval2 = 0;\n\tfor ( a = 0; a < ptd->nInterval; a++ ) {\n\t\tif ( ! failflag[ a ] ) {\n\t\t\tptd->interval[ nInterval2++ ] = ptd->interval[ a ];\n\t\t}\n\t\telse {\n\t\t\tif ( ptd->interval[ a ].p_phr != NULL ) {\n\t\t\t\tfree( ptd->interval[ a ].p_phr );\n\t\t\t}\n\t\t}\n\t}\n\tptd->nInterval = nInterval2;\n}",
        "begin_line": 453,
        "end_line": 507,
        "is_bug": false
    },
    {
        "name": "tree.Discard2#520",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.Discard2( TreeDataType *ptd )",
        "snippet": "static void Discard2( TreeDataType *ptd )\n{\n\tint i, j;\n\tchar overwrite[ MAX_PHONE_SEQ_LEN ];\n\tchar failflag[ INTERVAL_SIZE ];\n\tint nInterval2;\n\n\tmemset( failflag, 0, sizeof( failflag ) );\n\tfor ( i = 0; i < ptd->nInterval; i++ ) {\n\t\tif ( ptd->leftmost[ ptd->interval[ i ].from ] == 0 )\n\t\t\tcontinue;\n\t\t/* test if interval i is overwrited by other intervals */\n\t\tmemset( overwrite, 0, sizeof( overwrite ) );\n\t\tfor ( j = 0; j < ptd->nInterval; j++ ) {\n\t\t\tif ( j == i )\n\t\t\t\tcontinue;\n\t\t\tmemset(\n\t\t\t\t&overwrite[ ptd->interval[ j ].from ],\n\t\t\t\t1,\n\t\t\t\tptd->interval[ j ].to - ptd->interval[ j ].from );\n\t\t}\n\t\tif ( memchr(\n\t\t\t&overwrite[ ptd->interval[ i ].from ],\n\t\t\t1,\n\t\t\tptd->interval[ i ].to - ptd->interval[ i ].from ) )\n\t\t\tfailflag[ i ] = 1;\n\t}\n\t/* discard all the intervals whose failflag[a] = 1 */\n\tnInterval2 = 0;\n\tfor ( i = 0; i < ptd->nInterval; i++ )\n\t\tif ( ! failflag[ i ] )\n\t\t\tptd->interval[ nInterval2++ ] = ptd->interval[ i ];\n\tptd->nInterval = nInterval2;\n}",
        "begin_line": 520,
        "end_line": 553,
        "is_bug": false
    },
    {
        "name": "tree.DoDpPhrasing#992",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.DoDpPhrasing( ChewingData *pgdata, TreeDataType *pdt )",
        "snippet": "static void DoDpPhrasing( ChewingData *pgdata, TreeDataType *pdt )\n{\n\tRecordNode *highest_score[ MAX_PHONE_SEQ_LEN ] = { 0 };\n\tRecordNode *tmp;\n\tint prev_end;\n\tint end;\n\tint interval_id;\n\n\tassert( pgdata );\n\tassert( pdt );\n\n\t/*\n\t * Assume P(x,y) is the highest score phrasing result from x to y. The\n\t * following is formula for P(x,y):\n\t *\n\t * P(x,y) = MAX( P(x,y-1)+P(y-1,y), P(x,y-2)+P(y-2,y), ... )\n\t *\n\t * While P(x,y-1) is stored in highest_score array, and P(y-1,y) is\n\t * interval end at y. In this formula, x is always 0.\n\t *\n\t * The format of highest_score array is described as following:\n\t *\n\t * highest_score[0] = P(0,0)\n\t * highest_score[1] = P(0,1)\n\t * ...\n\t * highest_score[y-1] = P(0,y-1)\n\t */\n\n\t/* The interval shall be sorted by the increase order of end. */\n\tqsort( pdt->interval, pdt->nInterval, sizeof( pdt->interval[0] ), SortByIncreaseEnd );\n\n\tfor ( interval_id = 0; interval_id < pdt->nInterval; ++interval_id ) {\n\t\t/*\n\t\t * XXX: pdt->interval.to is excluding, while end is\n\t\t * including, so we need to minus one here.\n\t\t */\n\t\tend = pdt->interval[interval_id].to - 1;\n\n\t\tprev_end = pdt->interval[interval_id].from - 1;\n\n\t\tif ( prev_end >= 0 )\n\t\t\ttmp = DuplicateRecordAndInsertInterval(\n\t\t\t\thighest_score[ prev_end ],\n\t\t\t\tpdt,\n\t\t\t\tinterval_id );\n\t\telse\n\t\t\ttmp = CreateSingleIntervalRecord( pdt, interval_id );\n\n\t\t/* FIXME: shall exit immediately? */\n\t\tif (!tmp)\n\t\t\tcontinue;\n\n\t\tif ( highest_score[end] == NULL || highest_score[end]->score < tmp->score ) {\n\t\t\tFreeRecord( highest_score[end] );\n\t\t\thighest_score[end] = tmp;\n\t\t} else\n\t\t\tFreeRecord( tmp );\n\t}\n\n\tif ( pgdata->nPhoneSeq - 1 < 0 || highest_score[ pgdata->nPhoneSeq - 1 ] == NULL ) {\n\t\tpdt->phList = CreateNullIntervalRecord();\n\t} else {\n\t\tpdt->phList = highest_score[ pgdata->nPhoneSeq - 1 ];\n\t}\n\tpdt->nPhListLen = 1;\n\n\tfor ( end = 0; end < pgdata->nPhoneSeq - 1; ++end )\n\t\tFreeRecord( highest_score[end] );\n}",
        "begin_line": 992,
        "end_line": 1060,
        "is_bug": false
    },
    {
        "name": "tree.DuplicateRecordAndInsertInterval#912",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.DuplicateRecordAndInsertInterval( \tconst RecordNode *record, TreeDataType *pdt, const int interval_id )",
        "snippet": "static RecordNode * DuplicateRecordAndInsertInterval(\n\tconst RecordNode *record,\n\tTreeDataType *pdt,\n\tconst int interval_id )\n{\n\tRecordNode *ret = NULL;\n\n\tassert( record );\n\tassert( pdt );\n\n\tret = ALC( RecordNode, 1 );\n\tif ( !ret )\n\t\treturn NULL;\n\n\tret->arrIndex = ALC( int, record->nInter + 1 );\n\tif ( !ret->arrIndex ) {\n\t\tfree( ret );\n\t\treturn NULL;\n\t}\n\tret->nInter = record->nInter + 1;\n\tmemcpy( ret->arrIndex, record->arrIndex, sizeof(record->arrIndex[0]) * record->nInter );\n\n\tret->arrIndex[ ret->nInter - 1 ] = interval_id;\n\n\tret->score = LoadPhraseAndCountScore( ret->arrIndex, ret->nInter, pdt );\n\n\treturn ret;\n}",
        "begin_line": 912,
        "end_line": 939,
        "is_bug": false
    },
    {
        "name": "tree.FindInterval#325",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.FindInterval( ChewingData *pgdata, TreeDataType *ptd )",
        "snippet": "static void FindInterval( ChewingData *pgdata, TreeDataType *ptd )\n{\n\tint end, begin;\n\tconst TreeType *phrase_parent;\n\tPhrase *p_phrase, *puserphrase, *pdictphrase;\n\tUsedPhraseMode i_used_phrase;\n\tuint16_t new_phoneSeq[ MAX_PHONE_SEQ_LEN ];\n\n\tfor ( begin = 0; begin < pgdata->nPhoneSeq; begin++ ) {\n\t\tfor ( end = begin; end < min( pgdata->nPhoneSeq, begin + MAX_PHRASE_LEN ); end++ ) {\n\t\t\tif ( ! CheckBreakpoint( begin, end + 1, pgdata->bArrBrkpt ) )\n\t\t\t\tbreak;\n\n\t\t\t/* set new_phoneSeq */\n\t\t\tmemcpy(\n\t\t\t\tnew_phoneSeq,\n\t\t\t\t&pgdata->phoneSeq[ begin ],\n\t\t\t\tsizeof( uint16_t ) * ( end - begin + 1 ) );\n\t\t\tnew_phoneSeq[ end - begin + 1 ] = 0;\n\t\t\tpuserphrase = pdictphrase = NULL;\n\t\t\ti_used_phrase = USED_PHRASE_NONE;\n\n\t\t\t/* check user phrase */\n\t\t\tif ( UserGetPhraseFirst( pgdata, new_phoneSeq ) &&\n\t\t\t\t\tCheckUserChoose( pgdata, new_phoneSeq, begin, end + 1,\n\t\t\t\t\t&p_phrase, pgdata->selectStr, pgdata->selectInterval, pgdata->nSelect ) ) {\n\t\t\t\tpuserphrase = p_phrase;\n\t\t\t}\n\n\t\t\t/* check dict phrase */\n\t\t\tphrase_parent = TreeFindPhrase( pgdata, begin, end, pgdata->phoneSeq );\n\t\t\tif (\n\t\t\t\tphrase_parent &&\n\t\t\t\tCheckChoose(\n\t\t\t\t\tpgdata,\n\t\t\t\t\tphrase_parent, begin, end + 1,\n\t\t\t\t\t&p_phrase, pgdata->selectStr,\n\t\t\t\t\tpgdata->selectInterval, pgdata->nSelect ) ) {\n\t\t\t\tpdictphrase = p_phrase;\n\t\t\t}\n\n\t\t\t/* add only one interval, which has the largest freqency\n\t\t\t * but when the phrase is the same, the user phrase overrides\n\t\t\t * static dict\n\t\t\t */\n\t\t\tif ( puserphrase != NULL && pdictphrase == NULL ) {\n\t\t\t\ti_used_phrase = USED_PHRASE_USER;\n\t\t\t}\n\t\t\telse if ( puserphrase == NULL && pdictphrase != NULL ) {\n\t\t\t\ti_used_phrase = USED_PHRASE_DICT;\n\t\t\t}\n\t\t\telse if ( puserphrase != NULL && pdictphrase != NULL ) {\n\t\t\t\t/* the same phrase, userphrase overrides */\n\t\t\t\tif ( ! strcmp(\n\t\t\t\t\tpuserphrase->phrase,\n\t\t\t\t\tpdictphrase->phrase ) ) {\n\t\t\t\t\ti_used_phrase = USED_PHRASE_USER;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( puserphrase->freq > pdictphrase->freq ) {\n\t\t\t\t\t\ti_used_phrase = USED_PHRASE_USER;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ti_used_phrase = USED_PHRASE_DICT;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch ( i_used_phrase ) {\n\t\t\t\tcase USED_PHRASE_USER:\n\t\t\t\t\tAddInterval( ptd, begin, end, puserphrase, IS_USER_PHRASE );\n\t\t\t\t\tbreak;\n\t\t\t\tcase USED_PHRASE_DICT:\n\t\t\t\t\tAddInterval( ptd, begin, end, pdictphrase, IS_DICT_PHRASE );\n\t\t\t\t\tbreak;\n\t\t\t\tcase USED_PHRASE_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinternal_release_Phrase(\n\t\t\t\ti_used_phrase,\n\t\t\t\tpuserphrase,\n\t\t\t\tpdictphrase );\n\t\t}\n\t}\n}",
        "begin_line": 325,
        "end_line": 409,
        "is_bug": false
    },
    {
        "name": "tree.FreeRecord#984",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.FreeRecord( RecordNode *node )",
        "snippet": "static void FreeRecord( RecordNode *node )\n{\n\tif ( node ) {\n\t\tfree( node->arrIndex );\n\t\tfree( node );\n\t}\n}",
        "begin_line": 984,
        "end_line": 990,
        "is_bug": false
    },
    {
        "name": "tree.InitPhrasing#783",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.InitPhrasing( TreeDataType *ptd )",
        "snippet": "static void InitPhrasing( TreeDataType *ptd )\n{\n\tmemset( ptd, 0, sizeof( TreeDataType ) );\n}",
        "begin_line": 783,
        "end_line": 786,
        "is_bug": false
    },
    {
        "name": "tree.InitTree#85",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.InitTree( ChewingData *pgdata, const char * prefix )",
        "snippet": "int InitTree( ChewingData *pgdata, const char * prefix )\n{\n\tchar filename[ PATH_MAX ];\n\tsize_t len;\n\tsize_t offset;\n\n\tlen = snprintf( filename, sizeof( filename ), \"%s\" PLAT_SEPARATOR \"%s\", prefix, PHONE_TREE_FILE );\n\tif ( len + 1 > sizeof( filename ) )\n\t\treturn -1;\n\n\tplat_mmap_set_invalid( &pgdata->static_data.tree_mmap );\n\tpgdata->static_data.tree_size = plat_mmap_create( &pgdata->static_data.tree_mmap, filename, FLAG_ATTRIBUTE_READ );\n\tif ( pgdata->static_data.tree_size <= 0 )\n\t\treturn -1;\n\n\toffset = 0;\n\tpgdata->static_data.tree = (const TreeType *) plat_mmap_set_view( &pgdata->static_data.tree_mmap, &offset, &pgdata->static_data.tree_size );\n\tif ( !pgdata->static_data.tree )\n\t\treturn -1;\n\n\treturn 0;\n}",
        "begin_line": 85,
        "end_line": 106,
        "is_bug": false
    },
    {
        "name": "tree.IsContain#58",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.IsContain( IntervalType in1, IntervalType in2 )",
        "snippet": "static int IsContain( IntervalType in1, IntervalType in2 )\n{\n\treturn ( in1.from <= in2.from && in1.to >= in2.to );\n}",
        "begin_line": 58,
        "end_line": 61,
        "is_bug": false
    },
    {
        "name": "tree.IsIntersect#63",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.IsIntersect( IntervalType in1, IntervalType in2 )",
        "snippet": "int IsIntersect( IntervalType in1, IntervalType in2 )\n{\n\treturn ( max( in1.from, in2.from ) < min( in1.to, in2.to ) );\n}",
        "begin_line": 63,
        "end_line": 66,
        "is_bug": false
    },
    {
        "name": "tree.LoadPhraseAndCountScore#637",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.LoadPhraseAndCountScore( const int *record, int nRecord, const TreeDataType *ptd )",
        "snippet": "static int LoadPhraseAndCountScore( const int *record, int nRecord, const TreeDataType *ptd )\n{\n\tint total_score = 0;\n\t/* NOTE: the balance factor is tuneable */\n\tif (nRecord) {\n\t\ttotal_score += 1000*rule_largest_sum( record, nRecord, ptd );\n\t\ttotal_score += 1000*rule_largest_avgwordlen( record, nRecord, ptd );\n\t\ttotal_score += 100*rule_smallest_lenvariance( record, nRecord, ptd );\n\t\ttotal_score += rule_largest_freqsum( record, nRecord, ptd );\n\t}\n\treturn total_score;\n}",
        "begin_line": 637,
        "end_line": 648,
        "is_bug": false
    },
    {
        "name": "tree.OutputRecordStr#556",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.OutputRecordStr( ChewingData *pgdata, const TreeDataType *ptd )",
        "snippet": "static void OutputRecordStr( ChewingData *pgdata, const TreeDataType *ptd )\n{\n\tPhraseIntervalType inter;\n\tint i;\n\tint j;\n\n\tfor ( i = 0; i < ptd->phList->nInter; i++ ) {\n\t\tinter = ptd->interval[ ptd->phList->arrIndex[ i ] ];\n\n\t\tfor ( j = inter.from; j < inter.to; ++j ) {\n\t\t\tueStrNCpy( pgdata->preeditBuf[ j ].char_,\n\t\t\t\tueStrSeek( inter.p_phr->phrase, j - inter.from ),\n\t\t\t\t1, STRNCPY_CLOSE );\n\t\t}\n\t}\n\n\tfor ( i = 0; i < pgdata->nSelect; i++ ) {\n\t\tinter.from = pgdata->selectInterval[ i ].from;\n\t\tinter.to = pgdata->selectInterval[ i ].to ;\n\n\t\tfor ( j = inter.from; j < inter.to; ++j ) {\n\t\t\tueStrNCpy( pgdata->preeditBuf[ j ].char_,\n\t\t\t\tueStrSeek( pgdata->selectStr[ i ], j - inter.from ),\n\t\t\t\t1, STRNCPY_CLOSE );\n\t\t}\n\t}\n}",
        "begin_line": 556,
        "end_line": 582,
        "is_bug": false
    },
    {
        "name": "tree.PhraseIntervalContain#68",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.PhraseIntervalContain(PhraseIntervalType in1, PhraseIntervalType in2)",
        "snippet": "static int PhraseIntervalContain(PhraseIntervalType in1, PhraseIntervalType in2)\n{\n\treturn ( in1.from <= in2.from && in1.to >= in2.to );\n}",
        "begin_line": 68,
        "end_line": 71,
        "is_bug": false
    },
    {
        "name": "tree.Phrasing#1062",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.Phrasing( ChewingData *pgdata, int all_phrasing )",
        "snippet": "int Phrasing( ChewingData *pgdata, int all_phrasing )\n{\n\tTreeDataType treeData;\n\n\tInitPhrasing( &treeData );\n\n\tFindInterval( pgdata, &treeData );\n\tSetInfo( pgdata->nPhoneSeq, &treeData );\n\tDiscard1( &treeData );\n\tDiscard2( &treeData );\n\tif ( all_phrasing ) {\n\t\tSaveList( &treeData );\n\t\tCountMatchCnnct( &treeData, pgdata->bUserArrCnnct, pgdata->nPhoneSeq );\n\t\tSortListByScore( &treeData );\n\t\tNextCut( &treeData, &pgdata->phrOut );\n\t} else {\n\t\tDoDpPhrasing( pgdata, &treeData );\n\t}\n\n\tShowList( pgdata, &treeData );\n\n\t/* set phrasing output */\n\tOutputRecordStr( pgdata, &treeData );\n\tSaveDispInterval( &pgdata->phrOut, &treeData );\n\n\t/* free \"phrase\" */\n\tCleanUpMem( &treeData );\n\treturn 0;\n}",
        "begin_line": 1062,
        "end_line": 1090,
        "is_bug": false
    },
    {
        "name": "tree.SaveDispInterval#788",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.SaveDispInterval( PhrasingOutput *ppo, TreeDataType *ptd )",
        "snippet": "static void SaveDispInterval( PhrasingOutput *ppo, TreeDataType *ptd )\n{\n\tint i;\n\n\tfor ( i = 0; i < ptd->phList->nInter; i++ ) {\n\t\tppo->dispInterval[ i ].from =\n\t\t\tptd->interval[ ptd->phList->arrIndex[ i ] ].from;\n\t\tppo->dispInterval[ i ].to =\n\t\t\tptd->interval[ ptd->phList->arrIndex[ i ] ].to;\n\t}\n\tppo->nDispInterval = ptd->phList->nInter;\n}",
        "begin_line": 788,
        "end_line": 799,
        "is_bug": false
    },
    {
        "name": "tree.SetInfo#411",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.SetInfo( int len, TreeDataType *ptd )",
        "snippet": "static void SetInfo( int len, TreeDataType *ptd )\n{\n\tint i, a;\n\n\tfor ( i = 0; i <= len; i++ )\n\t\tptd->leftmost[ i ] = i;\n\tfor ( i = 0; i < ptd->nInterval; i++ ) {\n\t\tptd->graph[ ptd->interval[ i ].from ][ ptd->interval[ i ].to ] = 1;\n\t\tptd->graph[ ptd->interval[ i ].to ][ ptd->interval[ i ].from ] = 1;\n\t}\n\n\t/* set leftmost */\n\tfor ( a = 0; a <= len; a++ ) {\n\t\tfor ( i = 0; i <= len; i++ ) {\n\t\t\tif ( ! ( ptd->graph[ a ][ i ] ) )\n\t\t\t\tcontinue;\n\t\t\tif ( ptd->leftmost[ i ] < ptd->leftmost[ a ] )\n\t\t\t\tptd->leftmost[ a ] = ptd->leftmost[ i ];\n\t\t}\n\t}\n}",
        "begin_line": 411,
        "end_line": 431,
        "is_bug": false
    },
    {
        "name": "tree.ShowList#844",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.ShowList( ChewingData *pgdata, const TreeDataType *ptd )",
        "snippet": "static void ShowList( ChewingData *pgdata, const TreeDataType *ptd )\n{\n\tconst RecordNode *p;\n\tint i;\n\n\tDEBUG_OUT( \"After SaveList :\\n\" );\n\tfor ( p = ptd->phList; p; p = p->next ) {\n\t\tDEBUG_OUT( \"  interval : \" );\n\t\tfor ( i = 0; i < p->nInter; i++ ) {\n\t\t\tDEBUG_OUT(\n\t\t\t\t\"[%d %d] \",\n\t\t\t\tptd->interval[ p->arrIndex[ i ] ].from,\n\t\t\t\tptd->interval[ p->arrIndex[ i ] ].to );\n\t\t}\n\t\tDEBUG_OUT(\n\t\t\t\"\\n\"\n\t\t\t   \"      score : %d , nMatchCnnct : %d\\n\",\n\t\t\tp->score,\n\t\t\tp->nMatchCnnct );\n\t}\n\tDEBUG_OUT( \"\\n\" );\n}",
        "begin_line": 844,
        "end_line": 865,
        "is_bug": false
    },
    {
        "name": "tree.SortByIncreaseEnd#898",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.SortByIncreaseEnd( const void *x, const void *y)",
        "snippet": "static int SortByIncreaseEnd( const void *x, const void *y)\n{\n\tconst PhraseIntervalType *interval_x = (const PhraseIntervalType *) x;\n\tconst PhraseIntervalType *interval_y = (const PhraseIntervalType *) y;\n\n\tif ( interval_x->to < interval_y->to )\n\t\treturn -1;\n\n\tif ( interval_x->to > interval_y->to )\n\t\treturn 1;\n\n\treturn 0;\n}",
        "begin_line": 898,
        "end_line": 910,
        "is_bug": false
    },
    {
        "name": "tree.TerminateTree#78",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.TerminateTree( ChewingData *pgdata )",
        "snippet": "void TerminateTree( ChewingData *pgdata )\n{\n\t\tpgdata->static_data.tree = NULL;\n\t\tplat_mmap_close( &pgdata->static_data.tree_mmap );\n}",
        "begin_line": 78,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "tree.TreeChildRange#280",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.TreeChildRange( ChewingData *pgdata, const TreeType *parent )",
        "snippet": "void TreeChildRange( ChewingData *pgdata, const TreeType *parent )\n{\n\tpgdata->static_data.tree_cur_pos = pgdata->static_data.tree + GetUint24(parent->child.begin);\n\tpgdata->static_data.tree_end_pos = pgdata->static_data.tree + GetUint24(parent->child.end);\n}",
        "begin_line": 280,
        "end_line": 284,
        "is_bug": false
    },
    {
        "name": "tree.TreeFindPhrase#251",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.TreeFindPhrase( ChewingData *pgdata, int begin, int end, const uint16_t *phoneSeq )",
        "snippet": "const TreeType *TreeFindPhrase( ChewingData *pgdata, int begin, int end, const uint16_t *phoneSeq )\n{\n\tTreeType target;\n\tconst TreeType *tree_p = pgdata->static_data.tree;\n\tuint32_t range[2];\n\tint i;\n\n\tfor ( i = begin; i <= end; i++ ) {\n\t\tPutUint16(phoneSeq[i], target.key);\n\t\trange[0] = GetUint24(tree_p->child.begin);\n\t\trange[1] = GetUint24(tree_p->child.end);\n\t\tassert(range[1] >= range[0]);\n\t\ttree_p = (const TreeType*)bsearch(&target, pgdata->static_data.tree + range[0],\n\t\t\t\t\t\t  range[1] - range[0], sizeof(TreeType), CompTreeType);\n\n\t\t/* if not found any word then fail. */\n\t\tif( !tree_p )\n\t\t\treturn NULL;\n\t}\n\n\t/* If its child has no key value of 0, then it is only a \"half\" phrase. */\n\tif( GetUint16(pgdata->static_data.tree[ GetUint24(tree_p->child.begin) ].key) != 0)\n\t\treturn NULL;\n\treturn tree_p;\n}",
        "begin_line": 251,
        "end_line": 275,
        "is_bug": false
    },
    {
        "name": "tree.internal_release_Phrase#304",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.internal_release_Phrase( UsedPhraseMode mode, Phrase *pUser, Phrase *pDict )",
        "snippet": "static void internal_release_Phrase( UsedPhraseMode mode, Phrase *pUser, Phrase *pDict )\n{\n\t/* we must free unused phrase entry to avoid memory leak. */\n\tswitch ( mode ) {\n\t\tcase USED_PHRASE_USER:\n\t\t\tif ( pDict != NULL )\n\t\t\t\tfree( pDict );\n\t\t\tbreak;\n\t\tcase USED_PHRASE_DICT:\n\t\t\tif ( pUser != NULL )\n\t\t\t\tfree( pUser );\n\t\t\tbreak;\n\t\tdefault: /* In fact, it is alwyas 0 */\n\t\t\tif ( pDict != NULL )\n\t\t\t\tfree( pDict );\n\t\t\tif ( pUser != NULL )\n\t\t\t\tfree( pUser );\n\t\t\tbreak;\n\t}\n}",
        "begin_line": 304,
        "end_line": 323,
        "is_bug": false
    },
    {
        "name": "tree.rule_largest_avgwordlen#597",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.rule_largest_avgwordlen( const int *record, int nRecord, const TreeDataType *ptd )",
        "snippet": "static int rule_largest_avgwordlen( const int *record, int nRecord, const TreeDataType *ptd )\n{\n\t/* constant factor 6=1*2*3, to keep value as integer */\n\treturn 6 * rule_largest_sum( record, nRecord, ptd ) / nRecord;\n}",
        "begin_line": 597,
        "end_line": 601,
        "is_bug": false
    },
    {
        "name": "tree.rule_largest_freqsum#620",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.rule_largest_freqsum( const int *record, int nRecord, const TreeDataType *ptd )",
        "snippet": "static int rule_largest_freqsum( const int *record, int nRecord, const TreeDataType *ptd )\n{\n\tint i, score = 0;\n\tPhraseIntervalType inter;\n\n\tfor ( i = 0; i < nRecord; i++ ) {\n\t\tinter = ptd->interval[ record[ i ] ];\n\t\tassert( inter.p_phr );\n\n\t\t/* We adjust the 'freq' of One-word Phrase */\n\t\tscore += ( inter.to - inter.from == 1 ) ?\n\t\t\t( inter.p_phr->freq / 512 ) :\n\t\t\tinter.p_phr->freq;\n\t}\n\treturn score;\n}",
        "begin_line": 620,
        "end_line": 635,
        "is_bug": false
    },
    {
        "name": "tree.rule_largest_sum#584",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.rule_largest_sum( const int *record, int nRecord, const TreeDataType *ptd )",
        "snippet": "static int rule_largest_sum( const int *record, int nRecord, const TreeDataType *ptd )\n{\n\tint i, score = 0;\n\tPhraseIntervalType inter;\n\n\tfor ( i = 0; i < nRecord; i++ ) {\n\t\tinter = ptd->interval[ record[ i ] ];\n\t\tassert( inter.p_phr );\n\t\tscore += inter.to - inter.from;\n\t}\n\treturn score;\n}",
        "begin_line": 584,
        "end_line": 595,
        "is_bug": false
    },
    {
        "name": "tree.rule_smallest_lenvariance#603",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.rule_smallest_lenvariance( const int *record, int nRecord, const TreeDataType *ptd )",
        "snippet": "static int rule_smallest_lenvariance( const int *record, int nRecord, const TreeDataType *ptd )\n{\n\tint i, j, score = 0;\n\tPhraseIntervalType inter1, inter2;\n\n\t/* kcwu: heuristic? why variance no square function? */\n\tfor ( i = 0; i < nRecord; i++ ) {\n\t\tfor ( j = i + 1; j < nRecord; j++ ) {\n\t\t\tinter1 = ptd->interval[ record[ i ] ];\n\t\t\tinter2 = ptd->interval[ record[ j ] ];\n\t\t\tassert( inter1.p_phr && inter2.p_phr );\n\t\t\tscore += abs((inter1.to - inter1.from) - (inter2.to - inter2.from));\n\t\t}\n\t}\n\treturn -score;\n}",
        "begin_line": 603,
        "end_line": 618,
        "is_bug": false
    },
    {
        "name": "userphrase.LoadMaxFreq#54",
        "src_path": "src/userphrase.c",
        "class_name": "userphrase",
        "signature": "userphrase.LoadMaxFreq( ChewingData *pgdata, const uint16_t phoneSeq[], int len )",
        "snippet": "static int LoadMaxFreq( ChewingData *pgdata, const uint16_t phoneSeq[], int len )\n{\n\tconst TreeType *tree_pos;\n\tPhrase *phrase = ALC( Phrase, 1 );\n\tint maxFreq = FREQ_INIT_VALUE;\n\tUserPhraseData *uphrase;\n\n\ttree_pos = TreeFindPhrase( pgdata, 0, len - 1, phoneSeq );\n\tif ( tree_pos ) {\n\t\tGetPhraseFirst( pgdata, phrase, tree_pos );\n\t\tdo {\n\t\t\tif ( phrase->freq > maxFreq )\n\t\t\t\tmaxFreq = phrase->freq;\n\t\t} while( GetVocabNext( pgdata, phrase ) );\n\t}\n\tfree( phrase );\n\n\tuphrase = UserGetPhraseFirst( pgdata, phoneSeq );\n\twhile ( uphrase ) {\n\t\tif ( uphrase->userfreq > maxFreq )\n\t\t\tmaxFreq = uphrase->userfreq;\n\t\tuphrase = UserGetPhraseNext( pgdata, phoneSeq );\n\t}\n\n\treturn maxFreq;\n}",
        "begin_line": 54,
        "end_line": 79,
        "is_bug": false
    },
    {
        "name": "userphrase.LoadOriginalFreq#28",
        "src_path": "src/userphrase.c",
        "class_name": "userphrase",
        "signature": "userphrase.LoadOriginalFreq( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int len )",
        "snippet": "static int LoadOriginalFreq( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int len )\n{\n\tconst TreeType *tree_pos;\n\tint retval;\n\tPhrase *phrase = ALC( Phrase, 1 );\n\n\ttree_pos = TreeFindPhrase( pgdata, 0, len - 1, phoneSeq );\n\tif ( tree_pos ) {\n\t\tGetPhraseFirst( pgdata, phrase, tree_pos );\n\t\tdo {\n\t\t\t/* find the same phrase */\n\t\t\tif ( ! strcmp(\n\t\t\t\tphrase->phrase,\n\t\t\t\twordSeq ) ) {\n\t\t\t\tretval = phrase->freq;\n\t\t\t\tfree( phrase );\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t} while ( GetVocabNext( pgdata, phrase ) );\n\t}\n\n\tfree( phrase );\n\treturn FREQ_INIT_VALUE;\n}",
        "begin_line": 28,
        "end_line": 51,
        "is_bug": false
    },
    {
        "name": "userphrase.LogUserPhrase#115",
        "src_path": "src/userphrase.c",
        "class_name": "userphrase",
        "signature": "userphrase.LogUserPhrase( \tChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int orig_freq, int max_freq, int user_freq, int recent_time)",
        "snippet": "static void LogUserPhrase(\n\tChewingData *pgdata,\n\tconst uint16_t phoneSeq[],\n\tconst char wordSeq[],\n\tint orig_freq,\n\tint max_freq,\n\tint user_freq,\n\tint recent_time)\n{\n\t/* Size of each phone is len(\"0x1234 \") = 7 */\n\tchar buf[7 * MAX_PHRASE_LEN + 1] = { 0 };\n\tint i;\n\n\tfor ( i = 0; i < MAX_PHRASE_LEN; ++i ) {\n\t\tif ( phoneSeq[i] == 0 )\n\t\t\tbreak;\n\t\tsnprintf( buf + 7 * i, 7 + 1, \"%#06x \", phoneSeq[i] );\n\t}\n\n\tLOG_INFO( \"userphrase %s, phone = %s, orig_freq = %d, max_freq = %d, user_freq = %d, recent_time = %d\\n\",\n\t\twordSeq, buf, orig_freq, max_freq, user_freq, recent_time );\n}",
        "begin_line": 115,
        "end_line": 136,
        "is_bug": false
    },
    {
        "name": "userphrase.UserGetPhraseFirst#209",
        "src_path": "src/userphrase.c",
        "class_name": "userphrase",
        "signature": "userphrase.UserGetPhraseFirst( ChewingData *pgdata, const uint16_t phoneSeq[] )",
        "snippet": "UserPhraseData *UserGetPhraseFirst( ChewingData *pgdata, const uint16_t phoneSeq[] )\n{\n\tpgdata->prev_userphrase = HashFindPhonePhrase( pgdata, phoneSeq, NULL );\n\tif ( ! pgdata->prev_userphrase )\n\t\treturn NULL;\n\treturn &( pgdata->prev_userphrase->data );\n}",
        "begin_line": 209,
        "end_line": 215,
        "is_bug": false
    },
    {
        "name": "userphrase.UserGetPhraseNext#217",
        "src_path": "src/userphrase.c",
        "class_name": "userphrase",
        "signature": "userphrase.UserGetPhraseNext( ChewingData *pgdata, const uint16_t phoneSeq[] )",
        "snippet": "UserPhraseData *UserGetPhraseNext( ChewingData *pgdata, const uint16_t phoneSeq[] )\n{\n\tpgdata->prev_userphrase = HashFindPhonePhrase( pgdata, phoneSeq, pgdata->prev_userphrase );\n\tif ( ! pgdata->prev_userphrase )\n\t\treturn NULL;\n\treturn &( pgdata->prev_userphrase->data );\n}",
        "begin_line": 217,
        "end_line": 223,
        "is_bug": false
    },
    {
        "name": "userphrase.UserUpdatePhrase#138",
        "src_path": "src/userphrase.c",
        "class_name": "userphrase",
        "signature": "userphrase.UserUpdatePhrase( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[] )",
        "snippet": "int UserUpdatePhrase( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[] )\n{\n\tHASH_ITEM *pItem;\n\tUserPhraseData data;\n\tint len;\n\n\tlen = ueStrLen( wordSeq );\n\tpItem = HashFindEntry( pgdata, phoneSeq, wordSeq );\n\tif ( ! pItem ) {\n\t\tif ( ! AlcUserPhraseSeq( &data, len, strlen( wordSeq ) ) ) {\n\t\t\treturn USER_UPDATE_FAIL;\n\t\t}\n\n\t\tmemcpy( data.phoneSeq, phoneSeq, len * sizeof( phoneSeq[ 0 ] ) );\n\t\tdata.phoneSeq[ len ] = 0;\n\t\tstrcpy( data.wordSeq, wordSeq );\n\n\t\t/* load initial freq */\n\t\tdata.origfreq = LoadOriginalFreq( pgdata, phoneSeq, wordSeq, len );\n\t\tdata.maxfreq = LoadMaxFreq( pgdata, phoneSeq, len );\n\n\t\tdata.userfreq = data.origfreq;\n\t\tdata.recentTime = pgdata->static_data.chewing_lifetime;\n\t\tpItem = HashInsert( pgdata, &data );\n\t\tLogUserPhrase( pgdata, phoneSeq, wordSeq, pItem->data.origfreq, pItem->data.maxfreq, pItem->data.userfreq, pItem->data.recentTime );\n\t\tHashModify( pgdata, pItem );\n\t\treturn USER_UPDATE_INSERT;\n\t}\n\telse {\n\t\tpItem->data.maxfreq = LoadMaxFreq( pgdata, phoneSeq, len );\n\t\tpItem->data.userfreq = UpdateFreq(\n\t\t\tpItem->data.userfreq,\n\t\t\tpItem->data.maxfreq,\n\t\t\tpItem->data.origfreq,\n\t\t\tpgdata->static_data.chewing_lifetime - pItem->data.recentTime );\n\t\tpItem->data.recentTime = pgdata->static_data.chewing_lifetime;\n\t\tLogUserPhrase( pgdata, phoneSeq, wordSeq, pItem->data.origfreq, pItem->data.maxfreq, pItem->data.userfreq, pItem->data.recentTime );\n\t\tHashModify( pgdata, pItem );\n\t\treturn USER_UPDATE_MODIFY;\n\t}\n}",
        "begin_line": 138,
        "end_line": 178,
        "is_bug": false
    },
    {
        "name": "zuin.DefPhoInput#149",
        "src_path": "src/zuin.c",
        "class_name": "zuin",
        "signature": "zuin.DefPhoInput( ChewingData *pgdata, int key )",
        "snippet": "static int DefPhoInput( ChewingData *pgdata, int key )\n{\n\tZuinData *pZuin = &(pgdata->zuinData);\n\tint type = 0, inx = 0;\n\tint i;\n\n\tif ( IsDefPhoEndKey( key, pZuin->kbtype ) ) {\n\t\tfor ( i = 0; i < ZUIN_SIZE; ++i )\n\t\t\tif ( pZuin->pho_inx[ i ] != 0 )\n\t\t\t\tbreak;\n\t\tif ( i < ZUIN_SIZE )\n\t\t\treturn EndKeyProcess( pgdata, key, 1 );\n\t}\n\telse {\n\t\tpZuin->pho_inx[ 3 ] = 0;\n\t}\n\n\t/* decide if the key is a phone */\n\tfor ( type = 0; type <= 3; type++ ) {\n\t\tinx = PhoneInxFromKey( key, type, pZuin->kbtype, 1 );\n\t\tif ( inx )\n\t\t\tbreak;\n\t}\n\n\t/* the key is NOT a phone */\n\tif ( type > 3 ) {\n\t\treturn ZUIN_KEY_ERROR;\n\t}\n\n\t/* fill the key into the phone buffer */\n\tpZuin->pho_inx[ type ] = inx;\n\treturn ZUIN_ABSORB;\n}",
        "begin_line": 149,
        "end_line": 181,
        "is_bug": false
    },
    {
        "name": "zuin.EndKeyProcess#93",
        "src_path": "src/zuin.c",
        "class_name": "zuin",
        "signature": "zuin.EndKeyProcess( ChewingData *pgdata, int key, int searchTimes )",
        "snippet": "static int EndKeyProcess( ChewingData *pgdata, int key, int searchTimes )\n{\n\tZuinData *pZuin = &(pgdata->zuinData);\n\tuint16_t u16Pho, u16PhoAlt;\n\tPhrase tempword;\n\tint pho_inx;\n\n\tif (\n\t\tpZuin->pho_inx[ 0 ] == 0 &&\n\t\tpZuin->pho_inx[ 1 ] == 0 &&\n\t\tpZuin->pho_inx[ 2 ] == 0 &&\n\t\tpZuin->pho_inx[ 3 ] == 0 ) {\n\t\t/*\n\t\t * Special handle for space key (Indeed very special one).\n\t\t * Un-break the situation that OnKeySpace() is not called,\n\t\t * hence the Candidate window doesn't show up, because\n\t\t * ZUIN_NO_WORD is returned.\n\t\t */\n\t\treturn (key == ' ') ? ZUIN_KEY_ERROR : ZUIN_NO_WORD;\n\t}\n\n\tpho_inx = PhoneInxFromKey( key, 3, pZuin->kbtype, searchTimes );\n\tif ( pZuin->pho_inx[ 3 ] == 0 ) {\n\t\tpZuin->pho_inx[ 3 ] = pho_inx;\n\t\tpZuin->pho_inx_alt[ 3 ] = pho_inx;\n\t}\n\telse if ( key != ' ' ) {\n\t\tpZuin->pho_inx[ 3 ] = pho_inx;\n\t\tpZuin->pho_inx_alt[ 3 ] = pho_inx;\n\t\treturn ZUIN_NO_WORD;\n\t}\n\n\tu16Pho = UintFromPhoneInx( pZuin->pho_inx );\n\tif ( GetCharFirst( pgdata, &tempword, u16Pho ) == 0 ) {\n\t\tZuinRemoveAll( pZuin );\n\t\treturn ZUIN_NO_WORD;\n\t}\n\n\tpZuin->phone = u16Pho;\n\n\tif ( pZuin->pho_inx_alt[ 0 ] == 0 &&\n\t     pZuin->pho_inx_alt[ 1 ] == 0 &&\n\t     pZuin->pho_inx_alt[ 2 ] == 0 ) {\n\t\t/* no alternative phone, copy from default as alt */\n\t\tpZuin->phoneAlt = u16Pho;\n\t}\n\telse {\n\t\tu16PhoAlt = UintFromPhoneInx( pZuin->pho_inx_alt );\n\t\tpZuin->phoneAlt = u16PhoAlt;\n\t}\n\n\tmemset( pZuin->pho_inx, 0, sizeof( pZuin->pho_inx ) );\n\tmemset( pZuin->pho_inx_alt, 0, sizeof( pZuin->pho_inx_alt ) );\n\treturn ZUIN_COMMIT;\n}",
        "begin_line": 93,
        "end_line": 147,
        "is_bug": false
    },
    {
        "name": "zuin.IsDefPhoEndKey#83",
        "src_path": "src/zuin.c",
        "class_name": "zuin",
        "signature": "zuin.IsDefPhoEndKey( int key, int kbtype )",
        "snippet": "static int IsDefPhoEndKey( int key, int kbtype )\n{\n\tif ( PhoneInxFromKey( key, 3, kbtype, 1 )  )\n\t\treturn 1;\n\n\tif ( key == ' ' )\n\t\treturn 1;\n\treturn 0;\n}",
        "begin_line": 83,
        "end_line": 91,
        "is_bug": false
    },
    {
        "name": "zuin.ZuinIsEntering#693",
        "src_path": "src/zuin.c",
        "class_name": "zuin",
        "signature": "zuin.ZuinIsEntering( ZuinData *pZuin )",
        "snippet": "int ZuinIsEntering( ZuinData *pZuin )\n{\n\tint i;\n\tif ( pZuin->kbtype >= KB_HANYU_PINYIN ) {\n\t\tif ( pZuin->pinYinData.keySeq[0] )\n\t\t\treturn 1;\n\t} else {\n\t\tfor ( i = 0; i < ZUIN_SIZE; i++ )\n\t\t\tif ( pZuin->pho_inx[ i ] )\n\t\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "begin_line": 693,
        "end_line": 705,
        "is_bug": false
    },
    {
        "name": "zuin.ZuinPhoInput#642",
        "src_path": "src/zuin.c",
        "class_name": "zuin",
        "signature": "zuin.ZuinPhoInput( ChewingData *pgdata, int key )",
        "snippet": "int ZuinPhoInput( ChewingData *pgdata, int key )\n{\n\tZuinData *pZuin = &(pgdata->zuinData);\n\tswitch ( pZuin->kbtype ) {\n\t\tcase KB_HSU:\n\t\tcase KB_DVORAK_HSU:\n\t\t\treturn HsuPhoInput( pgdata, key );\n\t\t\tbreak;\n\t\tcase KB_ET26:\n\t\t\treturn ET26PhoInput( pgdata, key );\n\t\t\tbreak;\n\t\tcase KB_DACHEN_CP26:\n\t\t\treturn DACHENCP26PhoInput( pgdata, key );\n\t\t\tbreak;\n\t\tcase KB_HANYU_PINYIN:\n\t\tcase KB_THL_PINYIN:\n\t\tcase KB_MPS2_PINYIN:\n\t\t\treturn PinYinInput( pgdata, key );\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn DefPhoInput( pgdata, key );\n\t}\n\treturn ZUIN_ERROR;\n}",
        "begin_line": 642,
        "end_line": 665,
        "is_bug": false
    }
]