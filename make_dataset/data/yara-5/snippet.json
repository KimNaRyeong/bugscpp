[
    {
        "name": "libyara.ahocorasick._yr_ac_next_state#168",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick._yr_ac_next_state(     YR_AC_STATE* state, uint8_t input)",
        "snippet": "static YR_AC_STATE* _yr_ac_next_state(\n    YR_AC_STATE* state,\n    uint8_t input)\n{\n  YR_AC_STATE* next_state = state->first_child;\n\n  while (next_state != NULL)\n  {\n    if (next_state->input == input)\n      return next_state;\n\n    next_state = next_state->siblings;\n  }\n\n  return NULL;\n}",
        "begin_line": 168,
        "end_line": 183,
        "is_bug": false
    },
    {
        "name": "libyara.ahocorasick._yr_ac_state_create#200",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick._yr_ac_state_create(     YR_AC_STATE* state, uint8_t input)",
        "snippet": "static YR_AC_STATE* _yr_ac_state_create(\n    YR_AC_STATE* state,\n    uint8_t input)\n{\n  YR_AC_STATE* new_state = (YR_AC_STATE*) yr_malloc(sizeof(YR_AC_STATE));\n\n  if (new_state == NULL)\n    return NULL;\n\n  new_state->input = input;\n  new_state->depth = state->depth + 1;\n  new_state->matches_ref = YR_ARENA_NULL_REF;\n  new_state->failure = NULL;\n  new_state->t_table_slot = 0;\n  new_state->first_child = NULL;\n  new_state->siblings = state->first_child;\n  state->first_child = new_state;\n\n  return new_state;\n}",
        "begin_line": 200,
        "end_line": 219,
        "is_bug": false
    },
    {
        "name": "libyara.ahocorasick._yr_ac_state_destroy#226",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick._yr_ac_state_destroy(     YR_AC_STATE* state)",
        "snippet": "static int _yr_ac_state_destroy(\n    YR_AC_STATE* state)\n{\n  YR_AC_STATE* child_state = state->first_child;\n\n  while (child_state != NULL)\n  {\n    YR_AC_STATE* next_child_state = child_state->siblings;\n    _yr_ac_state_destroy(child_state);\n    child_state = next_child_state;\n  }\n\n  yr_free(state);\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 226,
        "end_line": 241,
        "is_bug": false
    },
    {
        "name": "libyara.ahocorasick.yr_ac_add_string#861",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick.yr_ac_add_string(     YR_AC_AUTOMATON* automaton, YR_STRING* string, uint32_t string_idx, YR_ATOM_LIST_ITEM* atom, YR_ARENA* arena)",
        "snippet": "int yr_ac_add_string(\n    YR_AC_AUTOMATON* automaton,\n    YR_STRING* string,\n    uint32_t string_idx,\n    YR_ATOM_LIST_ITEM* atom,\n    YR_ARENA* arena)\n{\n  while (atom != NULL)\n  {\n    YR_AC_STATE* state = automaton->root;\n\n    for (int i = 0; i < atom->atom.length; i++)\n    {\n      YR_AC_STATE* next_state = _yr_ac_next_state(state, atom->atom.bytes[i]);\n\n      if (next_state == NULL)\n      {\n        next_state = _yr_ac_state_create(state, atom->atom.bytes[i]);\n\n        if (next_state == NULL)\n          return ERROR_INSUFFICIENT_MEMORY;\n      }\n\n      state = next_state;\n    }\n\n    YR_ARENA_REF new_match_ref;\n\n    FAIL_ON_ERROR(yr_arena_allocate_struct(\n        arena,\n        YR_AC_STATE_MATCHES_POOL,\n        sizeof(YR_AC_MATCH),\n        &new_match_ref,\n        offsetof(YR_AC_MATCH, string),\n        offsetof(YR_AC_MATCH, forward_code),\n        offsetof(YR_AC_MATCH, backward_code),\n        offsetof(YR_AC_MATCH, next),\n        EOL));\n\n    YR_AC_MATCH* new_match = yr_arena_ref_to_ptr(arena, &new_match_ref);\n\n    new_match->backtrack = state->depth + atom->backtrack;\n    new_match->string = yr_arena_get_ptr(\n        arena, YR_STRINGS_TABLE, string_idx * sizeof(struct YR_STRING));\n\n    new_match->forward_code = yr_arena_ref_to_ptr(\n        arena, &atom->forward_code_ref);\n\n    new_match->backward_code = yr_arena_ref_to_ptr(\n        arena, &atom->backward_code_ref);\n\n    // Add newly created match to the list of matches for the state.\n    new_match->next = yr_arena_ref_to_ptr(arena, &state->matches_ref);\n    state->matches_ref = new_match_ref;\n\n    atom = atom->next;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 861,
        "end_line": 920,
        "is_bug": false
    },
    {
        "name": "libyara.ahocorasick.yr_ac_automaton_create#800",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick.yr_ac_automaton_create(     YR_ARENA* arena, YR_AC_AUTOMATON** automaton)",
        "snippet": "int yr_ac_automaton_create(\n    YR_ARENA* arena,\n    YR_AC_AUTOMATON** automaton)\n{\n  YR_AC_AUTOMATON* new_automaton;\n  YR_AC_STATE* root_state;\n\n  new_automaton = (YR_AC_AUTOMATON*) yr_malloc(sizeof(YR_AC_AUTOMATON));\n  root_state = (YR_AC_STATE*) yr_malloc(sizeof(YR_AC_STATE));\n\n  if (new_automaton == NULL || root_state == NULL)\n  {\n    yr_free(new_automaton);\n    yr_free(root_state);\n\n    return ERROR_INSUFFICIENT_MEMORY;\n  }\n\n  root_state->depth = 0;\n  root_state->matches_ref = YR_ARENA_NULL_REF;\n  root_state->failure = NULL;\n  root_state->first_child = NULL;\n  root_state->siblings = NULL;\n  root_state->t_table_slot = 0;\n\n  new_automaton->arena = arena;\n  new_automaton->root = root_state;\n  new_automaton->bitmask = NULL;\n  new_automaton->tables_size = 0;\n\n  *automaton = new_automaton;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 800,
        "end_line": 833,
        "is_bug": false
    },
    {
        "name": "libyara.ahocorasick.yr_ac_automaton_destroy#842",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick.yr_ac_automaton_destroy(     YR_AC_AUTOMATON* automaton)",
        "snippet": "int yr_ac_automaton_destroy(\n    YR_AC_AUTOMATON* automaton)\n{\n  _yr_ac_state_destroy(automaton->root);\n\n  yr_free(automaton->bitmask);\n  yr_free(automaton);\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 842,
        "end_line": 851,
        "is_bug": false
    },
    {
        "name": "libyara.arena._yr_arena_allocate_memory#136",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena._yr_arena_allocate_memory(     YR_ARENA* arena, int flags, uint32_t buffer_id, size_t size, YR_ARENA_REF* ref)",
        "snippet": "static int _yr_arena_allocate_memory(\n    YR_ARENA* arena,\n    int flags,\n    uint32_t buffer_id,\n    size_t size,\n    YR_ARENA_REF* ref)\n{\n  if (buffer_id > arena->num_buffers)\n    return ERROR_INVALID_ARGUMENT;\n\n  YR_ARENA_BUFFER* b = &arena->buffers[buffer_id];\n\n  // If the new data doesn't fit in the remaining space the buffer must be\n  // re-sized. This implies moving the buffer to a different memory location\n  // and adjusting the pointers listed in the relocation list.\n\n  if (b->size - b->used < size)\n  {\n    size_t new_size = (b->size == 0) ? arena->initial_buffer_size : b->size * 2;\n\n    while (new_size < b->used + size)\n      new_size *= 2;\n\n    uint8_t* new_data = yr_realloc(b->data, new_size);\n\n    if (new_data == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    // When yr_realloc uses the Windows API (HeapAlloc, HeapReAlloc) under the\n    // hood this is not necessary because HeapReAlloc already sets the new\n    // memory to zero.\n    #if !defined(_WIN32) && !defined(__CYGWIN__)\n    if (flags & YR_ARENA_ZERO_MEMORY)\n      memset(new_data + b->used, 0, new_size - b->used);\n    #endif\n\n    YR_RELOC* reloc = arena->reloc_list_head;\n\n    while (reloc != NULL)\n    {\n      // If the reloc entry is for the same buffer that is being relocated,\n      // the base pointer that we use to access the buffer must be new_data,\n      // as arena->buffers[reloc->buffer_id].data which is the same than\n      // b->data can't be accessed anymore after the call to yr_realloc.\n      uint8_t* base = buffer_id == reloc->buffer_id ?\n                      new_data : arena->buffers[reloc->buffer_id].data;\n\n      // reloc_address holds the address inside the buffer where the pointer\n      // to be relocated resides.\n      void** reloc_address = (void**) (base + reloc->offset);\n\n      // reloc_target is the value of the relocatable pointer.\n      void* reloc_target = *reloc_address;\n\n      if ((uint8_t*) reloc_target >= b->data &&\n          (uint8_t*) reloc_target < b->data + b->used)\n      {\n        // reloc_target points to some data inside the buffer being moved, so\n        // the pointer needs to be adjusted.\n        *reloc_address = (uint8_t*) reloc_target - b->data + new_data;\n      }\n\n      reloc = reloc->next;\n    }\n\n    b->size = new_size;\n    b->data = new_data;\n  }\n\n  if (ref != NULL)\n  {\n    ref->buffer_id = buffer_id;\n    ref->offset = b->used;\n  }\n\n  b->used += size;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 136,
        "end_line": 214,
        "is_bug": false
    },
    {
        "name": "libyara.arena._yr_arena_make_ptr_relocatable#79",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena._yr_arena_make_ptr_relocatable(     YR_ARENA* arena, uint32_t buffer_id, yr_arena_off_t base_offset, va_list offsets)",
        "snippet": "static int _yr_arena_make_ptr_relocatable(\n    YR_ARENA* arena,\n    uint32_t buffer_id,\n    yr_arena_off_t base_offset,\n    va_list offsets)\n{\n  yr_arena_off_t offset;\n\n  int result = ERROR_SUCCESS;\n\n  offset = va_arg(offsets, yr_arena_off_t);\n\n  while (offset != EOL)\n  {\n    YR_RELOC* reloc = (YR_RELOC*) yr_malloc(sizeof(YR_RELOC));\n\n    if (reloc == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    reloc->buffer_id = buffer_id;\n    reloc->offset = base_offset + offset;\n    reloc->next = NULL;\n\n    if (arena->reloc_list_head == NULL)\n      arena->reloc_list_head = reloc;\n\n    if (arena->reloc_list_tail != NULL)\n      arena->reloc_list_tail->next = reloc;\n\n    arena->reloc_list_tail = reloc;\n    offset = va_arg(offsets, size_t);\n  }\n\n  return result;\n}",
        "begin_line": 79,
        "end_line": 113,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_allocate_memory#294",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_allocate_memory(     YR_ARENA* arena, uint32_t buffer_id, size_t size, YR_ARENA_REF* ref)",
        "snippet": "int yr_arena_allocate_memory(\n    YR_ARENA* arena,\n    uint32_t buffer_id,\n    size_t size,\n    YR_ARENA_REF* ref)\n{\n  return _yr_arena_allocate_memory(\n      arena, 0, buffer_id, size, ref);\n}",
        "begin_line": 294,
        "end_line": 302,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_allocate_struct#352",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_allocate_struct(     YR_ARENA* arena, uint32_t buffer_id, size_t size, YR_ARENA_REF* ref, ...)",
        "snippet": "int yr_arena_allocate_struct(\n    YR_ARENA* arena,\n    uint32_t buffer_id,\n    size_t size,\n    YR_ARENA_REF* ref,\n    ...)\n{\n  YR_ARENA_REF r;\n\n  int result = _yr_arena_allocate_memory(\n      arena, YR_ARENA_ZERO_MEMORY, buffer_id, size, &r);\n\n  if (result != ERROR_SUCCESS)\n    return result;\n\n  va_list field_offsets;\n  va_start(field_offsets, ref);\n\n  result = _yr_arena_make_ptr_relocatable(\n      arena, buffer_id, r.offset, field_offsets);\n\n  va_end(field_offsets);\n\n  if (result == ERROR_SUCCESS && ref != NULL)\n  {\n    ref->buffer_id = r.buffer_id;\n    ref->offset = r.offset;\n  }\n\n  return result;\n}",
        "begin_line": 352,
        "end_line": 382,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_create#230",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_create(     int number_of_buffers, size_t initial_buffer_size, YR_ARENA** arena)",
        "snippet": "int yr_arena_create(\n    int number_of_buffers,\n    size_t initial_buffer_size,\n    YR_ARENA** arena)\n{\n  YR_ARENA* new_arena = (YR_ARENA*) yr_calloc(1, sizeof(YR_ARENA));\n\n  if (new_arena == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  new_arena->xrefs = 1;\n  new_arena->num_buffers = number_of_buffers;\n  new_arena->initial_buffer_size = initial_buffer_size;\n\n  *arena = new_arena;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 230,
        "end_line": 247,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_get_current_offset#397",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_get_current_offset(     YR_ARENA* arena, uint32_t buffer_id)",
        "snippet": "yr_arena_off_t yr_arena_get_current_offset(\n    YR_ARENA* arena,\n    uint32_t buffer_id)\n{\n  assert(buffer_id < arena->num_buffers);\n\n  return arena->buffers[buffer_id].used;\n}",
        "begin_line": 397,
        "end_line": 404,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_get_ptr#385",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_get_ptr(     YR_ARENA* arena, uint32_t buffer_id, yr_arena_off_t offset)",
        "snippet": "void* yr_arena_get_ptr(\n    YR_ARENA* arena,\n    uint32_t buffer_id,\n    yr_arena_off_t offset)\n{\n  assert(buffer_id < arena->num_buffers);\n  assert(offset <= arena->buffers[buffer_id].used);\n\n  return arena->buffers[buffer_id].data + offset;\n}",
        "begin_line": 385,
        "end_line": 394,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_ref_to_ptr#431",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_ref_to_ptr(     YR_ARENA* arena, YR_ARENA_REF* ref)",
        "snippet": "void* yr_arena_ref_to_ptr(\n    YR_ARENA* arena,\n    YR_ARENA_REF* ref)\n{\n  if (YR_ARENA_IS_NULL_REF(*ref))\n    return NULL;\n\n  #if defined(__arm__)\n  YR_ARENA_REF tmp_ref;\n  memcpy(&tmp_ref, ref, sizeof(YR_ARENA_REF));\n  ref = &tmp_ref;\n  #endif\n\n  return yr_arena_get_ptr(arena, ref->buffer_id, ref->offset);\n}",
        "begin_line": 431,
        "end_line": 445,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_release#265",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_release(     YR_ARENA* arena)",
        "snippet": "int yr_arena_release(\n    YR_ARENA* arena)\n{\n  arena->xrefs--;\n\n  if (arena->xrefs > 0)\n    return ERROR_SUCCESS;\n\n  for (int i = 0; i < arena->num_buffers; i++)\n  {\n    if (arena->buffers[i].data != NULL)\n      yr_free(arena->buffers[i].data);\n  }\n\n  YR_RELOC* reloc = arena->reloc_list_head;\n\n  while (reloc != NULL)\n  {\n    YR_RELOC* next = reloc->next;\n    yr_free(reloc);\n    reloc = next;\n  }\n\n  yr_free(arena);\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 265,
        "end_line": 291,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_write_data#483",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_write_data(     YR_ARENA* arena, uint32_t buffer_id, const void* data, size_t size, YR_ARENA_REF* ref)",
        "snippet": "int yr_arena_write_data(\n    YR_ARENA* arena,\n    uint32_t buffer_id,\n    const void* data,\n    size_t size,\n    YR_ARENA_REF* ref)\n{\n  YR_ARENA_REF r;\n\n  // Allocate space in the buffer.\n  FAIL_ON_ERROR(yr_arena_allocate_memory(arena, buffer_id, size, &r));\n\n  // Copy the data into the allocated space.\n  memcpy(arena->buffers[buffer_id].data + r.offset, data, size);\n\n  if (ref != NULL)\n  {\n    ref->buffer_id = r.buffer_id;\n    ref->offset = r.offset;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 483,
        "end_line": 505,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_write_string#508",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_write_string(     YR_ARENA* arena, uint32_t buffer_id, const char* string, YR_ARENA_REF* ref)",
        "snippet": "int yr_arena_write_string(\n    YR_ARENA* arena,\n    uint32_t buffer_id,\n    const char* string,\n    YR_ARENA_REF* ref)\n{\n  return yr_arena_write_data(\n      arena, buffer_id, string, strlen(string) + 1, ref);\n}",
        "begin_line": 508,
        "end_line": 516,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_choose#556",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_choose(     YR_ATOMS_CONFIG* config, YR_ATOM_TREE_NODE* node, YR_ATOM_LIST_ITEM** chosen_atoms, int* atoms_quality)",
        "snippet": "static int _yr_atoms_choose(\n    YR_ATOMS_CONFIG* config,\n    YR_ATOM_TREE_NODE* node,\n    YR_ATOM_LIST_ITEM** chosen_atoms,\n    int* atoms_quality)\n{\n  YR_ATOM_TREE_NODE* child;\n  YR_ATOM_LIST_ITEM* item;\n  YR_ATOM_LIST_ITEM* tail;\n\n  int shift, quality;\n\n  int max_quality = YR_MIN_ATOM_QUALITY;\n  int min_quality = YR_MAX_ATOM_QUALITY;\n\n  *chosen_atoms = NULL;\n  *atoms_quality = YR_MIN_ATOM_QUALITY;\n\n  switch (node->type)\n  {\n  case ATOM_TREE_LEAF:\n\n    item = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));\n\n    if (item == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    memcpy(&item->atom, &node->atom, sizeof(YR_ATOM));\n\n    shift = _yr_atoms_trim(&item->atom);\n\n    if (item->atom.length > 0)\n    {\n      item->forward_code_ref = node->re_nodes[shift]->forward_code_ref;\n      item->backward_code_ref = node->re_nodes[shift]->backward_code_ref;\n      item->backtrack = 0;\n      item->next = NULL;\n\n      *chosen_atoms = item;\n      *atoms_quality = config->get_atom_quality(config, &item->atom);\n    }\n    else\n    {\n      yr_free(item);\n    }\n\n    break;\n\n  case ATOM_TREE_OR:\n\n    // The choosen nodes are those coming from the highest quality child.\n\n    child = node->children_head;\n\n    while (child != NULL)\n    {\n      FAIL_ON_ERROR(_yr_atoms_choose(config, child, &item, &quality));\n\n      if (quality > max_quality)\n      {\n        max_quality = quality;\n        yr_atoms_list_destroy(*chosen_atoms);\n        *chosen_atoms = item;\n      }\n      else\n      {\n        yr_atoms_list_destroy(item);\n      }\n\n      if (max_quality == YR_MAX_ATOM_QUALITY)\n        break;\n\n      child = child->next_sibling;\n    }\n\n    *atoms_quality = max_quality;\n    break;\n\n  case ATOM_TREE_AND:\n\n    // The choosen nodes are the concatenation of the the nodes choosen from\n    // all the children.\n\n    child = node->children_head;\n\n    while (child != NULL)\n    {\n      FAIL_ON_ERROR(_yr_atoms_choose(config, child, &item, &quality));\n\n      if (quality < min_quality)\n        min_quality = quality;\n\n      if (item != NULL)\n      {\n        tail = item;\n        while (tail->next != NULL)\n          tail = tail->next;\n\n        tail->next = *chosen_atoms;\n        *chosen_atoms = item;\n      }\n\n      child = child->next_sibling;\n    }\n\n    *atoms_quality = min_quality;\n    break;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 556,
        "end_line": 666,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_clone_list_item#1255",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_clone_list_item(     YR_ATOM_LIST_ITEM* item)",
        "snippet": "static YR_ATOM_LIST_ITEM* _yr_atoms_clone_list_item(\n    YR_ATOM_LIST_ITEM* item)\n{\n  YR_ATOM_LIST_ITEM* clone = (YR_ATOM_LIST_ITEM*) yr_malloc(\n      sizeof(YR_ATOM_LIST_ITEM));\n\n  if (clone == NULL)\n    return NULL;\n\n  memcpy(clone, item, sizeof(YR_ATOM_LIST_ITEM));\n\n  return clone;\n}",
        "begin_line": 1255,
        "end_line": 1267,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_expand_wildcards#1286",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_expand_wildcards(     YR_ATOM_LIST_ITEM* atoms)",
        "snippet": "static int _yr_atoms_expand_wildcards(\n    YR_ATOM_LIST_ITEM* atoms)\n{\n  int i;\n\n  YR_ATOM_LIST_ITEM* atom = atoms;\n  YR_ATOM_LIST_ITEM* new_atom;\n  YR_ATOM_LIST_ITEM* prev_atom;\n  YR_ATOM_LIST_ITEM* next_atom;\n\n  while (atom != NULL)\n  {\n    bool expanded = false;\n\n    for (i = 0; i < atom->atom.length; i++)\n    {\n      uint16_t a, s, e, incr = 1;\n\n      switch(atom->atom.mask[i])\n      {\n        case 0x00:\n          expanded = true;\n          s = 0x00;\n          e = 0xFF;\n          break;\n\n        case 0x0F:\n          expanded = true;\n          s = atom->atom.bytes[i];\n          e = atom->atom.bytes[i] | 0xF0;\n          incr = 0x10;\n          break;\n\n        case 0xF0:\n          expanded = true;\n          s = atom->atom.bytes[i];\n          e = atom->atom.bytes[i] | 0x0F;\n          break;\n\n        default:\n          s = 0;\n          e = 0;\n      }\n\n      if (s != e)\n      {\n        atom->atom.bytes[i] = (uint8_t) s;\n        atom->atom.mask[i] = 0xFF;\n      }\n\n      prev_atom = atom;\n      next_atom = atom->next;\n\n      for (a = s + incr; a <= e; a += incr)\n      {\n        new_atom = _yr_atoms_clone_list_item(atom);\n\n        if (new_atom == NULL)\n          return ERROR_INSUFFICIENT_MEMORY;\n\n        new_atom->atom.bytes[i] = (uint8_t) a;\n        new_atom->atom.mask[i] = 0xFF;\n        new_atom->next = next_atom;\n        prev_atom->next = new_atom;\n        prev_atom = new_atom;\n      }\n    }\n\n    if (!expanded)\n      atom = atom->next;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 1286,
        "end_line": 1359,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_extract_from_re#945",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_extract_from_re(     YR_ATOMS_CONFIG* config, RE_AST* re_ast, YR_ATOM_TREE_NODE* appending_node)",
        "snippet": "static int _yr_atoms_extract_from_re(\n    YR_ATOMS_CONFIG* config,\n    RE_AST* re_ast,\n    YR_ATOM_TREE_NODE* appending_node)\n{\n  YR_STACK* stack;\n  RE_NODE* re_node;\n\n  YR_ATOM atom;\n  YR_ATOM best_atom;\n\n  struct STACK_ITEM si;\n\n  int i, shift;\n  int quality;\n  int best_quality = -1;\n  int n = 0;\n\n  YR_ATOM_TREE_NODE* and_node;\n  YR_ATOM_TREE_NODE* left_node;\n  YR_ATOM_TREE_NODE* right_node;\n\n  // The RE_NODEs most recently visited that can conform an atom (ie:\n  // RE_NODE_LITERAL, RE_NODE_MASKED_LITERAL and RE_NODE_ANY). The number of\n  // items in this array is n.\n  RE_NODE* recent_re_nodes[YR_MAX_ATOM_LENGTH];\n\n  // The RE_NODEs corresponding to the best atom found so far for the current\n  // appending node.\n  RE_NODE* best_atom_re_nodes[YR_MAX_ATOM_LENGTH];\n\n  // This holds the ATOM_TREE_OR node where leaves (ATOM_TREE_LEAF) are\n  // currently being appended.\n  YR_ATOM_TREE_NODE* current_appending_node = NULL;\n\n  // This holds the ATOM_TREE_LEAF node whose atom is currently being updated.\n  YR_ATOM_TREE_NODE* leaf = NULL;\n\n  FAIL_ON_ERROR(yr_stack_create(1024, sizeof(si), &stack));\n\n  // This first item pushed in the stack is the last one to be poped out, the\n  // sole purpose of this item is forcing that any pending leaf is appended to\n  // current_appending_node during the last iteration of the loop.\n  si.re_node = NULL;\n  si.new_appending_node = appending_node;\n\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      yr_stack_push(stack, (void*) &si),\n      yr_stack_destroy(stack));\n\n  // Start processing the root node.\n  si.re_node = re_ast->root_node;\n\n  // Leaf nodes are initially appended to the node passed in the appending_node,\n  // argument which is the root ATOM_TREE_OR node that is empty at this point.\n  si.new_appending_node = appending_node;\n\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      yr_stack_push(stack, (void*) &si),\n      yr_stack_destroy(stack));\n\n  while (yr_stack_pop(stack, (void*) &si))\n  {\n    // Change the appending node if the item poped from the stack says so.\n    if (si.new_appending_node != NULL)\n    {\n      // Before changing the appending node let's append any pending leaf to\n      // the current appending node.\n      if (n > 0)\n      {\n        make_atom_from_re_nodes(atom, n, recent_re_nodes);\n        shift = _yr_atoms_trim(&atom);\n        quality = config->get_atom_quality(config, &atom);\n\n        FAIL_ON_NULL_WITH_CLEANUP(\n            leaf = _yr_atoms_tree_node_create(ATOM_TREE_LEAF),\n            yr_stack_destroy(stack));\n\n        if (quality > best_quality)\n        {\n          memcpy(&leaf->atom, &atom, sizeof(atom));\n          memcpy(\n              &leaf->re_nodes,\n              &recent_re_nodes[shift],\n              sizeof(recent_re_nodes) - shift * sizeof(recent_re_nodes[0]));\n        }\n        else\n        {\n          memcpy(&leaf->atom, &best_atom, sizeof(best_atom));\n          memcpy(\n              &leaf->re_nodes,\n              &best_atom_re_nodes,\n              sizeof(best_atom_re_nodes));\n        }\n\n        _yr_atoms_tree_node_append(current_appending_node, leaf);\n        n = 0;\n      }\n\n      current_appending_node = si.new_appending_node;\n    }\n\n    if (si.re_node != NULL)\n    {\n      switch(si.re_node->type)\n      {\n        case RE_NODE_LITERAL:\n        case RE_NODE_MASKED_LITERAL:\n        case RE_NODE_ANY:\n\n          if (n < YR_MAX_ATOM_LENGTH)\n          {\n            recent_re_nodes[n] = si.re_node;\n            best_atom_re_nodes[n] = si.re_node;\n            best_atom.bytes[n] = (uint8_t) si.re_node->value;\n            best_atom.mask[n] = (uint8_t) si.re_node->mask;\n            best_atom.length = ++n;\n          }\n          else if (best_quality < YR_MAX_ATOM_QUALITY)\n          {\n            make_atom_from_re_nodes(atom, n, recent_re_nodes);\n            shift = _yr_atoms_trim(&atom);\n            quality = config->get_atom_quality(config, &atom);\n\n            if (quality > best_quality)\n            {\n              for (i = 0; i < atom.length; i++)\n              {\n                best_atom.bytes[i] = atom.bytes[i];\n                best_atom.mask[i] = atom.mask[i];\n                best_atom_re_nodes[i] = recent_re_nodes[i + shift];\n              }\n\n              best_atom.length = atom.length;\n              best_quality = quality;\n            }\n\n            for (i = 1; i < YR_MAX_ATOM_LENGTH; i++)\n              recent_re_nodes[i - 1] = recent_re_nodes[i];\n\n            recent_re_nodes[YR_MAX_ATOM_LENGTH - 1] = si.re_node;\n          }\n\n          break;\n\n        case RE_NODE_CONCAT:\n\n          re_node = si.re_node->children_tail;\n\n          // Push children right to left, they are poped left to right.\n          while (re_node != NULL)\n          {\n            si.new_appending_node = NULL;\n            si.re_node = re_node;\n\n            FAIL_ON_ERROR_WITH_CLEANUP(\n                yr_stack_push(stack, &si),\n                yr_stack_destroy(stack));\n\n            re_node = re_node->prev_sibling;\n          }\n\n          break;\n\n        case RE_NODE_ALT:\n\n          // Create ATOM_TREE_AND node with two ATOM_TREE_OR children nodes.\n          and_node = _yr_atoms_tree_node_create(ATOM_TREE_AND);\n          left_node = _yr_atoms_tree_node_create(ATOM_TREE_OR);\n          right_node = _yr_atoms_tree_node_create(ATOM_TREE_OR);\n\n          if (and_node == NULL || left_node == NULL || right_node == NULL)\n          {\n            _yr_atoms_tree_node_destroy(and_node);\n            _yr_atoms_tree_node_destroy(left_node);\n            _yr_atoms_tree_node_destroy(right_node);\n\n            yr_stack_destroy(stack);\n\n            return ERROR_INSUFFICIENT_MEMORY;\n          }\n\n          and_node->children_head = left_node;\n          and_node->children_tail = right_node;\n          left_node->next_sibling = right_node;\n\n          // Add the ATOM_TREE_AND as children of the current node.\n          _yr_atoms_tree_node_append(current_appending_node, and_node);\n\n          re_node = si.re_node;\n\n          si.new_appending_node = current_appending_node;\n          si.re_node = NULL;\n\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              yr_stack_push(stack, &si),\n              yr_stack_destroy(stack));\n\n          // RE_NODE_ALT nodes has only two children, so children_head is the\n          // left one, and children_tail is right one.\n          si.new_appending_node = right_node;\n          si.re_node = re_node->children_tail;\n\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              yr_stack_push(stack, &si),\n              yr_stack_destroy(stack));\n\n          si.new_appending_node = left_node;\n          si.re_node = re_node->children_head;\n\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              yr_stack_push(stack, &si),\n              yr_stack_destroy(stack));\n\n          break;\n\n        case RE_NODE_PLUS:\n\n          re_node = si.re_node;\n\n          si.new_appending_node = current_appending_node;\n          si.re_node = NULL;\n\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              yr_stack_push(stack, &si),\n              yr_stack_destroy(stack));\n\n          si.new_appending_node = NULL;\n          // RE_NODE_PLUS nodes has a single child, which is children_head.\n          si.re_node = re_node->children_head;\n\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              yr_stack_push(stack, &si),\n              yr_stack_destroy(stack));\n\n          break;\n\n        case RE_NODE_RANGE:\n\n          re_node = si.re_node;\n\n          si.new_appending_node = current_appending_node;\n          si.re_node = NULL;\n\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              yr_stack_push(stack, &si),\n              yr_stack_destroy(stack));\n\n          si.new_appending_node = NULL;\n          // RE_NODE_RANGE nodes has a single child, which is children_head.\n          si.re_node = re_node->children_head;\n\n          // In a regexp like /a{10,20}/ the optimal atom is 'aaaa' (assuming\n          // that YR_MAX_ATOM_LENGTH = 4) because the 'a' character must appear\n          // at least 10 times in the matching string. Each call in the loop\n          // will append one 'a' to the atom, so YR_MAX_ATOM_LENGTH iterations\n          // are enough.\n\n          for (i = 0; i < yr_min(re_node->start, YR_MAX_ATOM_LENGTH); i++)\n          {\n            FAIL_ON_ERROR_WITH_CLEANUP(\n                yr_stack_push(stack, &si),\n                yr_stack_destroy(stack));\n          }\n\n          break;\n\n        case RE_NODE_RANGE_ANY:\n        case RE_NODE_STAR:\n        case RE_NODE_CLASS:\n        case RE_NODE_WORD_CHAR:\n        case RE_NODE_NON_WORD_CHAR:\n        case RE_NODE_SPACE:\n        case RE_NODE_NON_SPACE:\n        case RE_NODE_DIGIT:\n        case RE_NODE_NON_DIGIT:\n        case RE_NODE_EMPTY:\n        case RE_NODE_ANCHOR_START:\n        case RE_NODE_ANCHOR_END:\n        case RE_NODE_WORD_BOUNDARY:\n        case RE_NODE_NON_WORD_BOUNDARY:\n\n          si.new_appending_node = current_appending_node;\n          si.re_node = NULL;\n\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              yr_stack_push(stack, &si),\n              yr_stack_destroy(stack));\n\n          break;\n\n        default:\n          assert(false);\n      }\n    }\n  }\n\n  yr_stack_destroy(stack);\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 945,
        "end_line": 1245,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_tree_destroy#419",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_tree_destroy(     YR_ATOM_TREE* atom_tree)",
        "snippet": "static void _yr_atoms_tree_destroy(\n    YR_ATOM_TREE* atom_tree)\n{\n  _yr_atoms_tree_node_destroy(atom_tree->root_node);\n  yr_free(atom_tree);\n}",
        "begin_line": 419,
        "end_line": 424,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_tree_node_append#399",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_tree_node_append(     YR_ATOM_TREE_NODE* dest, YR_ATOM_TREE_NODE* node)",
        "snippet": "static void _yr_atoms_tree_node_append(\n    YR_ATOM_TREE_NODE* dest,\n    YR_ATOM_TREE_NODE* node)\n{\n  if (dest->children_head == NULL)\n    dest->children_head = node;\n\n  if (dest->children_tail != NULL)\n    dest->children_tail->next_sibling = node;\n\n  dest->children_tail = node;\n}",
        "begin_line": 399,
        "end_line": 410,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_tree_node_create#343",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_tree_node_create(     uint8_t type)",
        "snippet": "static YR_ATOM_TREE_NODE* _yr_atoms_tree_node_create(\n    uint8_t type)\n{\n  YR_ATOM_TREE_NODE* new_node = (YR_ATOM_TREE_NODE*) \\\n      yr_malloc(sizeof(YR_ATOM_TREE_NODE));\n\n  if (new_node != NULL)\n  {\n    new_node->type = type;\n    new_node->atom.length = 0;\n    new_node->next_sibling = NULL;\n    new_node->children_head = NULL;\n    new_node->children_tail = NULL;\n  }\n\n  return new_node;\n}",
        "begin_line": 343,
        "end_line": 359,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_tree_node_destroy#368",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_tree_node_destroy(     YR_ATOM_TREE_NODE* node)",
        "snippet": "static void _yr_atoms_tree_node_destroy(\n    YR_ATOM_TREE_NODE* node)\n{\n  YR_ATOM_TREE_NODE* child;\n  YR_ATOM_TREE_NODE* next_child;\n\n  if (node == NULL)\n    return;\n\n  if (node->type == ATOM_TREE_OR || node->type == ATOM_TREE_AND)\n  {\n    child = node->children_head;\n\n    while (child != NULL)\n    {\n      next_child = child->next_sibling;\n      _yr_atoms_tree_node_destroy(child);\n      child = next_child;\n    }\n  }\n\n  yr_free(node);\n}",
        "begin_line": 368,
        "end_line": 390,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_trim#490",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_trim(     YR_ATOM* atom)",
        "snippet": "int _yr_atoms_trim(\n    YR_ATOM* atom)\n{\n  int mask_00 = 0;\n  int mask_ff = 0;\n\n  int i, trim_left = 0;\n\n  while (trim_left < atom->length && atom->mask[trim_left] == 0)\n    trim_left++;\n\n  while (atom->length > trim_left && atom->mask[atom->length - 1] == 0)\n    atom->length--;\n\n  atom->length -= trim_left;\n\n  if (atom->length == 0)\n    return 0;\n\n  // The trimmed atom goes from trim_left to trim_left + atom->length and the\n  // first and last byte in the atom are known (mask == 0xFF). Now count the\n  // number of known and unknown bytes in the atom (mask == 0xFF and\n  // mask == 0x00 respectively).\n\n  for (i = 0; i < atom->length; i++)\n  {\n    if (atom->mask[trim_left + i] == 0xFF)\n      mask_ff++;\n    else if (atom->mask[trim_left + i] == 0x00)\n      mask_00++;\n  }\n\n  // If the number of unknown bytes is >= than the number of known bytes\n  // it doesn't make sense the to use this atom, so we use a single byte atpm\n  // containing the first known byte. If YR_MAX_ATOM_LENGTH == 4 this happens\n  // only when the atom is like { XX ?? ?? YY }, so using the first known\n  // byte is good enough. For larger values of YR_MAX_ATOM_LENGTH this is not\n  // the most efficient solution, as better atoms could be choosen. For\n  // example, in { XX ?? ?? ?? YY ZZ } the best atom is { YY ZZ } not { XX }.\n  // But let's keep it like this for simplicity.\n\n  if (mask_00 >= mask_ff)\n    atom->length = 1;\n\n  if (trim_left == 0)\n    return 0;\n\n  // Shift bytes and mask trim_left positions to the left.\n\n  for (i = 0; i < YR_MAX_ATOM_LENGTH - trim_left; i++)\n  {\n    atom->bytes[i] = atom->bytes[trim_left + i];\n    atom->mask[i] = atom->mask[trim_left + i];\n  }\n\n  return trim_left;\n}",
        "begin_line": 490,
        "end_line": 546,
        "is_bug": false
    },
    {
        "name": "libyara.atoms.yr_atoms_extract_from_re#1370",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms.yr_atoms_extract_from_re(     YR_ATOMS_CONFIG* config, RE_AST* re_ast, YR_MODIFIER modifier, YR_ATOM_LIST_ITEM** atoms, int* min_atom_quality)",
        "snippet": "int yr_atoms_extract_from_re(\n    YR_ATOMS_CONFIG* config,\n    RE_AST* re_ast,\n    YR_MODIFIER modifier,\n    YR_ATOM_LIST_ITEM** atoms,\n    int* min_atom_quality)\n{\n  YR_ATOM_TREE* atom_tree = (YR_ATOM_TREE*) yr_malloc(sizeof(YR_ATOM_TREE));\n\n  YR_ATOM_LIST_ITEM* wide_atoms;\n  YR_ATOM_LIST_ITEM* case_insensitive_atoms;\n\n  if (atom_tree == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  atom_tree->root_node = _yr_atoms_tree_node_create(ATOM_TREE_OR);\n\n  if (atom_tree->root_node == NULL)\n  {\n    _yr_atoms_tree_destroy(atom_tree);\n    return ERROR_INSUFFICIENT_MEMORY;\n  }\n\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      _yr_atoms_extract_from_re(config, re_ast, atom_tree->root_node),\n      _yr_atoms_tree_destroy(atom_tree));\n\n  // Initialize atom list\n  *atoms = NULL;\n\n  // Choose the atoms that will be used.\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      _yr_atoms_choose(config, atom_tree->root_node, atoms, min_atom_quality),\n      _yr_atoms_tree_destroy(atom_tree));\n\n  _yr_atoms_tree_destroy(atom_tree);\n\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      _yr_atoms_expand_wildcards(*atoms),\n      {\n        yr_atoms_list_destroy(*atoms);\n        *atoms = NULL;\n      });\n\n  // Don't do convert atoms to wide here if either base64 modifier is used.\n  // This is to avoid the situation where we have \"base64 wide\" because\n  // the wide has already been applied BEFORE the base64 encoding.\n  if (modifier.flags & STRING_FLAGS_WIDE &&\n      !(modifier.flags & STRING_FLAGS_BASE64 ||\n        modifier.flags & STRING_FLAGS_BASE64_WIDE))\n  {\n    FAIL_ON_ERROR_WITH_CLEANUP(\n        _yr_atoms_wide(*atoms, &wide_atoms),\n        {\n          yr_atoms_list_destroy(*atoms);\n          yr_atoms_list_destroy(wide_atoms);\n          *atoms = NULL;\n        });\n\n    if (modifier.flags & STRING_FLAGS_ASCII)\n    {\n      *atoms = _yr_atoms_list_concat(*atoms, wide_atoms);\n    }\n    else\n    {\n      yr_atoms_list_destroy(*atoms);\n      *atoms = wide_atoms;\n    }\n  }\n\n  if (modifier.flags & STRING_FLAGS_NO_CASE)\n  {\n    FAIL_ON_ERROR_WITH_CLEANUP(\n        _yr_atoms_case_insensitive(*atoms, &case_insensitive_atoms),\n        {\n          yr_atoms_list_destroy(*atoms);\n          yr_atoms_list_destroy(case_insensitive_atoms);\n          *atoms = NULL;\n        });\n\n    *atoms = _yr_atoms_list_concat(*atoms, case_insensitive_atoms);\n  }\n\n  // No atoms has been extracted, let's add a zero-length atom.\n\n  if (*atoms == NULL)\n  {\n    *atoms = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));\n\n    if (*atoms == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    (*atoms)->atom.length = 0;\n    (*atoms)->backtrack = 0;\n    (*atoms)->forward_code_ref = re_ast->root_node->forward_code_ref;\n    (*atoms)->backward_code_ref = YR_ARENA_NULL_REF;\n    (*atoms)->next = NULL;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 1370,
        "end_line": 1470,
        "is_bug": false
    },
    {
        "name": "libyara.atoms.yr_atoms_extract_from_string#1479",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms.yr_atoms_extract_from_string(     YR_ATOMS_CONFIG* config, uint8_t* string, int32_t string_length, YR_MODIFIER modifier, YR_ATOM_LIST_ITEM** atoms, int* min_atom_quality)",
        "snippet": "int yr_atoms_extract_from_string(\n    YR_ATOMS_CONFIG* config,\n    uint8_t* string,\n    int32_t string_length,\n    YR_MODIFIER modifier,\n    YR_ATOM_LIST_ITEM** atoms,\n    int* min_atom_quality)\n{\n  YR_ATOM_LIST_ITEM* item;\n  YR_ATOM_LIST_ITEM* case_insensitive_atoms;\n  YR_ATOM_LIST_ITEM* xor_atoms;\n  YR_ATOM_LIST_ITEM* wide_atoms;\n\n  YR_ATOM atom;\n\n  int quality, max_quality;\n  int i;\n\n  item = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));\n\n  if (item == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  item->forward_code_ref = YR_ARENA_NULL_REF;\n  item->backward_code_ref = YR_ARENA_NULL_REF;\n  item->next = NULL;\n  item->backtrack = 0;\n\n  item->atom.length = yr_min(string_length, YR_MAX_ATOM_LENGTH);\n\n  for (i = 0; i < item->atom.length; i++)\n  {\n    item->atom.bytes[i] = string[i];\n    item->atom.mask[i] = 0xFF;\n  }\n\n  max_quality = config->get_atom_quality(config, &item->atom);\n\n  atom.length = YR_MAX_ATOM_LENGTH;\n  memset(atom.mask, 0xFF, atom.length);\n\n  for (i = YR_MAX_ATOM_LENGTH;\n       i < string_length && max_quality < YR_MAX_ATOM_QUALITY;\n       i++)\n  {\n    atom.length = YR_MAX_ATOM_LENGTH;\n    memcpy(atom.bytes, string + i - YR_MAX_ATOM_LENGTH + 1, atom.length);\n\n    quality = config->get_atom_quality(config, &atom);\n\n    if (quality > max_quality)\n    {\n      memcpy(&item->atom, &atom, sizeof(atom));\n      item->backtrack = i - YR_MAX_ATOM_LENGTH + 1;\n      max_quality = quality;\n    }\n  }\n\n  *atoms = item;\n  *min_atom_quality = max_quality;\n\n  if (modifier.flags & STRING_FLAGS_WIDE)\n  {\n    FAIL_ON_ERROR_WITH_CLEANUP(\n        _yr_atoms_wide(*atoms, &wide_atoms),\n        {\n          yr_atoms_list_destroy(*atoms);\n          yr_atoms_list_destroy(wide_atoms);\n          *atoms = NULL;\n        });\n\n    if (modifier.flags & STRING_FLAGS_ASCII)\n    {\n      *atoms = _yr_atoms_list_concat(*atoms, wide_atoms);\n    }\n    else\n    {\n      yr_atoms_list_destroy(*atoms);\n      *atoms = wide_atoms;\n    }\n  }\n\n  if (modifier.flags & STRING_FLAGS_NO_CASE)\n  {\n    FAIL_ON_ERROR_WITH_CLEANUP(\n        _yr_atoms_case_insensitive(*atoms, &case_insensitive_atoms),\n        {\n          yr_atoms_list_destroy(*atoms);\n          yr_atoms_list_destroy(case_insensitive_atoms);\n          *atoms = NULL;\n        });\n\n    *atoms = _yr_atoms_list_concat(*atoms, case_insensitive_atoms);\n  }\n\n  if (modifier.flags & STRING_FLAGS_XOR)\n  {\n    FAIL_ON_ERROR_WITH_CLEANUP(\n      _yr_atoms_xor(*atoms, modifier.xor_min, modifier.xor_max, &xor_atoms),\n      {\n        yr_atoms_list_destroy(*atoms);\n        yr_atoms_list_destroy(xor_atoms);\n        *atoms = NULL;\n      });\n\n    yr_atoms_list_destroy(*atoms);\n    *atoms = xor_atoms;\n\n  }\n\n  // Recheck the atom quality, in case we have just generated some poor atoms.\n  // https://github.com/VirusTotal/yara/issues/1172\n  for (item = *atoms; item != NULL; item = item->next)\n  {\n    quality = config->get_atom_quality(config, &item->atom);\n    if (quality < *min_atom_quality)\n      *min_atom_quality = quality;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 1479,
        "end_line": 1599,
        "is_bug": false
    },
    {
        "name": "libyara.atoms.yr_atoms_heuristic_quality#112",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms.yr_atoms_heuristic_quality(     YR_ATOMS_CONFIG* config, YR_ATOM* atom)",
        "snippet": "int yr_atoms_heuristic_quality(\n    YR_ATOMS_CONFIG* config,\n    YR_ATOM* atom)\n{\n  YR_BITMASK seen_bytes[YR_BITMASK_SIZE(256)];\n\n  int quality = 0;\n  int unique_bytes = 0;\n  int masked_nibbles = 0;\n  int i;\n\n  assert(atom->length <= YR_MAX_ATOM_LENGTH);\n\n  yr_bitmask_clear_all(seen_bytes);\n\n  for (i = 0; i < atom->length; i++)\n  {\n    switch (atom->mask[i])\n    {\n      case 0x00:\n        masked_nibbles += 2;\n        break;\n      case 0x0F:\n        masked_nibbles += 1;\n        quality += 4;\n        break;\n      case 0xF0:\n        masked_nibbles += 1;\n        quality += 4;\n        break;\n      case 0xFF:\n        switch (atom->bytes[i])\n        {\n          case 0x00:\n          case 0x20:\n          case 0xCC:\n          case 0xFF:\n            // Common bytes contribute less to the quality than the rest.\n            quality += 15;\n            break;\n          default:\n            // Bytes in the a-z and A-Z ranges have a slightly lower quality\n            // than the rest. We want to favor atoms that contain bytes outside\n            // those ranges because they generate less additional atoms during\n            // calls to _yr_atoms_case_combinations.\n            if ( yr_lowercase[atom->bytes[i]] >= 'a' &&\n                 yr_lowercase[atom->bytes[i]] <= 'z')\n              quality += 19;\n            else\n              quality += 20;\n        };\n        if (!yr_bitmask_is_set(seen_bytes, atom->bytes[i]))\n        {\n          yr_bitmask_set(seen_bytes, atom->bytes[i]);\n          unique_bytes++;\n        }\n    }\n  }\n\n  // If all the bytes in the atom are equal and very common, let's penalize\n  // it heavily.\n\n  if (unique_bytes == 1 &&\n      (yr_bitmask_is_set(seen_bytes, 0x00) ||\n       yr_bitmask_is_set(seen_bytes, 0x20) ||\n       yr_bitmask_is_set(seen_bytes, 0xCC) ||\n       yr_bitmask_is_set(seen_bytes, 0xFF)))\n  {\n    quality -= 10 * atom->length;\n  }\n\n  quality -= masked_nibbles * 3;\n\n  return YR_MAX_ATOM_QUALITY - 20 * YR_MAX_ATOM_LENGTH + quality;\n}",
        "begin_line": 112,
        "end_line": 186,
        "is_bug": false
    },
    {
        "name": "libyara.atoms.yr_atoms_list_destroy#433",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms.yr_atoms_list_destroy(     YR_ATOM_LIST_ITEM* list_head)",
        "snippet": "void yr_atoms_list_destroy(\n    YR_ATOM_LIST_ITEM* list_head)\n{\n  YR_ATOM_LIST_ITEM* item = list_head;\n  YR_ATOM_LIST_ITEM* next;\n\n  while (item != NULL)\n  {\n    next = item->next;\n    yr_free(item);\n    item = next;\n  }\n}",
        "begin_line": 433,
        "end_line": 445,
        "is_bug": false
    },
    {
        "name": "libyara.compiler._yr_compiler_get_rule_by_idx#161",
        "src_path": "libyara/compiler.c",
        "class_name": "libyara.compiler",
        "signature": "libyara.compiler._yr_compiler_get_rule_by_idx(     YR_COMPILER* compiler, uint32_t rule_idx)",
        "snippet": "YR_RULE* _yr_compiler_get_rule_by_idx(\n    YR_COMPILER* compiler, uint32_t rule_idx)\n{\n  return (YR_RULE*) yr_arena_get_ptr(\n      compiler->arena, YR_RULES_TABLE, rule_idx * sizeof(YR_RULE));\n}",
        "begin_line": 161,
        "end_line": 166,
        "is_bug": false
    },
    {
        "name": "libyara.compiler._yr_compiler_set_namespace#479",
        "src_path": "libyara/compiler.c",
        "class_name": "libyara.compiler",
        "signature": "libyara.compiler._yr_compiler_set_namespace(     YR_COMPILER* compiler, const char* namespace_)",
        "snippet": "static int _yr_compiler_set_namespace(\n    YR_COMPILER* compiler,\n    const char* namespace_)\n{\n  YR_NAMESPACE* ns = (YR_NAMESPACE*) yr_arena_get_ptr(\n      compiler->arena, YR_NAMESPACES_TABLE, 0);\n\n  bool found = false;\n\n  for (int i = 0; i < compiler->num_namespaces; i++, ns++)\n  {\n    if (strcmp(ns->name, namespace_) == 0)\n    {\n      found = true;\n      compiler->current_namespace_idx = i;\n      break;\n    }\n  }\n\n  if (!found)\n  {\n    YR_ARENA_REF ref;\n\n    FAIL_ON_ERROR(yr_arena_allocate_struct(\n        compiler->arena,\n        YR_NAMESPACES_TABLE,\n        sizeof(YR_NAMESPACE),\n        &ref,\n        offsetof(YR_NAMESPACE, name),\n        EOL));\n\n    ns = (YR_NAMESPACE*) yr_arena_ref_to_ptr(compiler->arena, &ref);\n\n    FAIL_ON_ERROR(yr_arena_write_string(\n        compiler->arena,\n        YR_SZ_POOL,\n        namespace_,\n        &ref));\n\n    ns->name = (const char*) yr_arena_ref_to_ptr(compiler->arena, &ref);\n    ns->idx = compiler->num_namespaces;\n\n    compiler->current_namespace_idx = compiler->num_namespaces;\n    compiler->num_namespaces++;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 479,
        "end_line": 526,
        "is_bug": false
    },
    {
        "name": "libyara.compiler.yr_compiler_add_string#605",
        "src_path": "libyara/compiler.c",
        "class_name": "libyara.compiler",
        "signature": "libyara.compiler.yr_compiler_add_string(     YR_COMPILER* compiler, const char* rules_string, const char* namespace_)",
        "snippet": "YR_API int yr_compiler_add_string(\n    YR_COMPILER* compiler,\n    const char* rules_string,\n    const char* namespace_)\n{\n  // Don't allow calls to yr_compiler_add_string() after\n  // yr_compiler_get_rules() has been called.\n\n  assert(compiler->rules == NULL);\n\n  // Don't allow calls to yr_compiler_add_string() if a previous call to\n  // yr_compiler_add_XXXX failed.\n\n  assert(compiler->errors == 0);\n\n  if (namespace_ != NULL)\n    compiler->last_error = _yr_compiler_set_namespace(compiler, namespace_);\n  else\n    compiler->last_error = _yr_compiler_set_namespace(compiler, \"default\");\n\n  if (compiler->last_error != ERROR_SUCCESS)\n    return ++compiler->errors;\n\n  return yr_lex_parse_rules_string(rules_string, compiler);\n}",
        "begin_line": 605,
        "end_line": 629,
        "is_bug": false
    },
    {
        "name": "libyara.compiler.yr_compiler_create#169",
        "src_path": "libyara/compiler.c",
        "class_name": "libyara.compiler",
        "signature": "libyara.compiler.yr_compiler_create(     YR_COMPILER** compiler)",
        "snippet": "YR_API int yr_compiler_create(\n    YR_COMPILER** compiler)\n{\n  int result;\n  YR_COMPILER* new_compiler;\n\n  new_compiler = (YR_COMPILER*) yr_calloc(1, sizeof(YR_COMPILER));\n\n  if (new_compiler == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  new_compiler->current_rule_idx = UINT32_MAX;\n  new_compiler->next_rule_idx = 0;\n  new_compiler->current_string_idx = 0;\n  new_compiler->current_namespace_idx = 0;\n  new_compiler->current_meta_idx = 0;\n  new_compiler->num_namespaces = 0;\n  new_compiler->errors = 0;\n  new_compiler->callback = NULL;\n  new_compiler->rules = NULL;\n  new_compiler->include_callback = _yr_compiler_default_include_callback;\n  new_compiler->incl_clbk_user_data = NULL;\n  new_compiler->include_free = _yr_compiler_default_include_free;\n  new_compiler->re_ast_callback = NULL;\n  new_compiler->re_ast_clbk_user_data = NULL;\n  new_compiler->last_error = ERROR_SUCCESS;\n  new_compiler->last_error_line = 0;\n  new_compiler->current_line = 0;\n  new_compiler->file_name_stack_ptr = 0;\n  new_compiler->fixup_stack_head = NULL;\n  new_compiler->loop_index = -1;\n  new_compiler->loop_for_of_var_index = -1;\n\n  new_compiler->atoms_config.get_atom_quality = yr_atoms_heuristic_quality;\n  new_compiler->atoms_config.quality_warning_threshold = \\\n      YR_ATOM_QUALITY_WARNING_THRESHOLD;\n\n  result = yr_hash_table_create(10007, &new_compiler->rules_table);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_hash_table_create(10007, &new_compiler->objects_table);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_hash_table_create(101, &new_compiler->strings_table);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_create(\n        YR_NUM_SECTIONS, 1048576, &new_compiler->arena);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_ac_automaton_create(\n        new_compiler->arena,\n        &new_compiler->automaton);\n\n  if (result == ERROR_SUCCESS)\n  {\n    *compiler = new_compiler;\n  }\n  else  // if error, do cleanup\n  {\n    yr_compiler_destroy(new_compiler);\n  }\n\n  return result;\n}",
        "begin_line": 169,
        "end_line": 233,
        "is_bug": false
    },
    {
        "name": "libyara.compiler.yr_compiler_destroy#236",
        "src_path": "libyara/compiler.c",
        "class_name": "libyara.compiler",
        "signature": "libyara.compiler.yr_compiler_destroy(     YR_COMPILER* compiler)",
        "snippet": "YR_API void yr_compiler_destroy(\n    YR_COMPILER* compiler)\n{\n  yr_arena_release(compiler->arena);\n\n  if (compiler->automaton != NULL)\n    yr_ac_automaton_destroy(compiler->automaton);\n\n  yr_hash_table_destroy(\n      compiler->rules_table,\n      NULL);\n\n  yr_hash_table_destroy(\n      compiler->strings_table,\n      NULL);\n\n  yr_hash_table_destroy(\n      compiler->objects_table,\n      (YR_HASH_TABLE_FREE_VALUE_FUNC) yr_object_destroy);\n\n  if (compiler->  atoms_config.free_quality_table)\n    yr_free(compiler->atoms_config.quality_table);\n\n  for (int i = 0; i < compiler->file_name_stack_ptr; i++)\n    yr_free(compiler->file_name_stack[i]);\n\n  YR_FIXUP* fixup = compiler->fixup_stack_head;\n\n  while (fixup != NULL)\n  {\n    YR_FIXUP* next_fixup = fixup->next;\n    yr_free(fixup);\n    fixup = next_fixup;\n  }\n\n  yr_free(compiler);\n}",
        "begin_line": 236,
        "end_line": 272,
        "is_bug": false
    },
    {
        "name": "libyara.compiler.yr_compiler_get_error_message#866",
        "src_path": "libyara/compiler.c",
        "class_name": "libyara.compiler",
        "signature": "libyara.compiler.yr_compiler_get_error_message(     YR_COMPILER* compiler, char* buffer, int buffer_size)",
        "snippet": "YR_API char* yr_compiler_get_error_message(\n    YR_COMPILER* compiler,\n    char* buffer,\n    int buffer_size)\n{\n  uint32_t max_strings_per_rule;\n\n  switch(compiler->last_error)\n  {\n    case ERROR_INSUFFICIENT_MEMORY:\n      snprintf(buffer, buffer_size, \"not enough memory\");\n      break;\n    case ERROR_DUPLICATED_IDENTIFIER:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"duplicated identifier \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_DUPLICATED_STRING_IDENTIFIER:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"duplicated string identifier \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_DUPLICATED_TAG_IDENTIFIER:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"duplicated tag identifier \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_DUPLICATED_META_IDENTIFIER:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"duplicated metadata identifier \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_DUPLICATED_LOOP_IDENTIFIER:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"duplicated loop identifier \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_UNDEFINED_STRING:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"undefined string \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_UNDEFINED_IDENTIFIER:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"undefined identifier \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_UNREFERENCED_STRING:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"unreferenced string \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_EMPTY_STRING:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"empty string \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_NOT_A_STRUCTURE:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"\\\"%s\\\" is not a structure\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_NOT_INDEXABLE:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"\\\"%s\\\" is not an array or dictionary\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_NOT_A_FUNCTION:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"\\\"%s\\\" is not a function\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_INVALID_FIELD_NAME:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"invalid field name \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_MISPLACED_ANONYMOUS_STRING:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"wrong use of anonymous string\");\n      break;\n    case ERROR_INCLUDES_CIRCULAR_REFERENCE:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"include circular reference\");\n      break;\n    case ERROR_INCLUDE_DEPTH_EXCEEDED:\n      snprintf(buffer,\n          buffer_size,\n          \"too many levels of included rules\");\n      break;\n    case ERROR_LOOP_NESTING_LIMIT_EXCEEDED:\n      snprintf(buffer,\n          buffer_size,\n          \"loop nesting limit exceeded\");\n      break;\n    case ERROR_NESTED_FOR_OF_LOOP:\n      snprintf(buffer,\n          buffer_size,\n          \"'for <quantifier> of <string set>' loops can't be nested\");\n      break;\n    case ERROR_UNKNOWN_MODULE:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"unknown module \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_INVALID_MODULE_NAME:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"invalid module name \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_DUPLICATED_STRUCTURE_MEMBER:\n      snprintf(buffer,\n          buffer_size,\n          \"duplicated structure member\");\n      break;\n    case ERROR_WRONG_ARGUMENTS:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"wrong arguments for function \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_WRONG_RETURN_TYPE:\n      snprintf(buffer,\n          buffer_size,\n          \"wrong return type for overloaded function\");\n      break;\n    case ERROR_INVALID_HEX_STRING:\n    case ERROR_INVALID_REGULAR_EXPRESSION:\n    case ERROR_SYNTAX_ERROR:\n    case ERROR_WRONG_TYPE:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"%s\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_INTERNAL_FATAL_ERROR:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"internal fatal error\");\n      break;\n    case ERROR_DIVISION_BY_ZERO:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"division by zero\");\n      break;\n    case ERROR_REGULAR_EXPRESSION_TOO_LARGE:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"regular expression is too large\");\n      break;\n    case ERROR_REGULAR_EXPRESSION_TOO_COMPLEX:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"regular expression is too complex\");\n      break;\n    case ERROR_TOO_MANY_STRINGS:\n       yr_get_configuration(\n          YR_CONFIG_MAX_STRINGS_PER_RULE,\n          &max_strings_per_rule);\n       snprintf(\n          buffer,\n          buffer_size,\n          \"too many strings in rule \\\"%s\\\" (limit: %d)\",\n          compiler->last_error_extra_info,\n          max_strings_per_rule);\n      break;\n    case ERROR_INTEGER_OVERFLOW:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"integer overflow in \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_COULD_NOT_READ_FILE:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"could not read file\");\n      break;\n    case ERROR_INVALID_MODIFIER:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"invalid modifier combination \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_DUPLICATED_MODIFIER:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"duplicated modifier\");\n      break;\n  }\n\n  return buffer;\n}",
        "begin_line": 866,
        "end_line": 1101,
        "is_bug": false
    },
    {
        "name": "libyara.compiler.yr_compiler_set_callback#275",
        "src_path": "libyara/compiler.c",
        "class_name": "libyara.compiler",
        "signature": "libyara.compiler.yr_compiler_set_callback(     YR_COMPILER* compiler, YR_COMPILER_CALLBACK_FUNC callback, void* user_data)",
        "snippet": "YR_API void yr_compiler_set_callback(\n    YR_COMPILER* compiler,\n    YR_COMPILER_CALLBACK_FUNC callback,\n    void* user_data)\n{\n  compiler->callback = callback;\n  compiler->user_data = user_data;\n}",
        "begin_line": 275,
        "end_line": 282,
        "is_bug": false
    },
    {
        "name": "libyara.grammar.yara_yyparse#1603",
        "src_path": "libyara/grammar.c",
        "class_name": "libyara.grammar",
        "signature": "libyara.grammar.)",
        "snippet": "int\nyyparse (void *yyscanner, YR_COMPILER* compiler)\n{\n/* The lookahead symbol.  */\nint yychar;\n\n\n/* The semantic value of the lookahead symbol.  */\n/* Default value used for initialization, for pacifying older GCCs\n   or non-GCC compilers.  */\nYY_INITIAL_VALUE (static YYSTYPE yyval_default;)\nYYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n\n    /* Number of syntax errors so far.  */\n    int yynerrs;\n\n    yy_state_fast_t yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yy_state_t yyssa[YYINITDEPTH];\n    yy_state_t *yyss;\n    yy_state_t *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYPTRDIFF_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYPTRDIFF_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n  goto yysetstate;\n\n\n/*------------------------------------------------------------.\n| yynewstate -- push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\nyynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n\n/*--------------------------------------------------------------------.\n| yysetstate -- set current state (the top of the stack) to yystate.  |\n`--------------------------------------------------------------------*/\nyysetstate:\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);\n  YY_IGNORE_USELESS_CAST_BEGIN\n  *yyssp = YY_CAST (yy_state_t, yystate);\n  YY_IGNORE_USELESS_CAST_END\n\n  if (yyss + yystacksize - 1 <= yyssp)\n#if !defined yyoverflow && !defined YYSTACK_RELOCATE\n    goto yyexhaustedlab;\n#else\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYPTRDIFF_T yysize = yyssp - yyss + 1;\n\n# if defined yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        yy_state_t *yyss1 = yyss;\n        YYSTYPE *yyvs1 = yyvs;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * YYSIZEOF (*yyssp),\n                    &yyvs1, yysize * YYSIZEOF (*yyvsp),\n                    &yystacksize);\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n# else /* defined YYSTACK_RELOCATE */\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yy_state_t *yyss1 = yyss;\n        union yyalloc *yyptr =\n          YY_CAST (union yyalloc *,\n                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n# undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YY_IGNORE_USELESS_CAST_BEGIN\n      YYDPRINTF ((stderr, \"Stack size increased to %ld\\n\",\n                  YY_CAST (long, yystacksize)));\n      YY_IGNORE_USELESS_CAST_END\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex (&yylval, yyscanner, compiler);\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n  case 8:\n#line 322 \"grammar.y\"\n      {\n        _yr_compiler_pop_file_name(compiler);\n      }\n#line 1864 \"grammar.c\"\n    break;\n\n  case 9:\n#line 330 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));\n\n        yr_free((yyvsp[0].sized_string));\n\n        fail_if_error(result);\n      }\n#line 1876 \"grammar.c\"\n    break;\n\n  case 10:\n#line 342 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_reduce_rule_declaration_phase_1(\n            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string), &(yyval.rule)));\n      }\n#line 1885 \"grammar.c\"\n    break;\n\n  case 11:\n#line 347 \"grammar.y\"\n      {\n        YR_RULE* rule = (YR_RULE*) yr_arena_ref_to_ptr(\n            compiler->arena, &(yyvsp[-4].rule));\n\n        rule->tags = (char*) yr_arena_ref_to_ptr(\n            compiler->arena, &(yyvsp[-3].tag));\n\n        rule->metas = (YR_META*) yr_arena_ref_to_ptr(\n            compiler->arena, &(yyvsp[-1].meta));\n\n        rule->strings = (YR_STRING*) yr_arena_ref_to_ptr(\n            compiler->arena, &(yyvsp[0].string));\n      }\n#line 1903 \"grammar.c\"\n    break;\n\n  case 12:\n#line 361 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_rule_declaration_phase_2(\n            yyscanner, &(yyvsp[-7].rule)); // rule created in phase 1\n\n        yr_free((yyvsp[-8].c_string));\n\n        fail_if_error(result);\n      }\n#line 1916 \"grammar.c\"\n    break;\n\n  case 13:\n#line 374 \"grammar.y\"\n      {\n        (yyval.meta) = YR_ARENA_NULL_REF;\n      }\n#line 1924 \"grammar.c\"\n    break;\n\n  case 14:\n#line 378 \"grammar.y\"\n      {\n        YR_META* meta = yr_arena_get_ptr(\n            compiler->arena,\n            YR_METAS_TABLE,\n            (compiler->current_meta_idx - 1) * sizeof(YR_META));\n\n        meta->flags |= META_FLAGS_LAST_IN_RULE;\n\n        (yyval.meta) = (yyvsp[0].meta);\n      }\n#line 1939 \"grammar.c\"\n    break;\n\n  case 15:\n#line 393 \"grammar.y\"\n      {\n        (yyval.string) = YR_ARENA_NULL_REF;\n      }\n#line 1947 \"grammar.c\"\n    break;\n\n  case 16:\n#line 397 \"grammar.y\"\n      {\n        YR_STRING* string = (YR_STRING*) yr_arena_get_ptr(\n            compiler->arena,\n            YR_STRINGS_TABLE,\n            (compiler->current_string_idx - 1) * sizeof(YR_STRING));\n\n        string->flags |= STRING_FLAGS_LAST_IN_RULE;\n\n        (yyval.string) = (yyvsp[0].string);\n      }\n#line 1962 \"grammar.c\"\n    break;\n\n  case 18:\n#line 416 \"grammar.y\"\n                                       { (yyval.integer) = 0;  }\n#line 1968 \"grammar.c\"\n    break;\n\n  case 19:\n#line 417 \"grammar.y\"\n                                       { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }\n#line 1974 \"grammar.c\"\n    break;\n\n  case 20:\n#line 422 \"grammar.y\"\n                     { (yyval.integer) = RULE_FLAGS_PRIVATE; }\n#line 1980 \"grammar.c\"\n    break;\n\n  case 21:\n#line 423 \"grammar.y\"\n                     { (yyval.integer) = RULE_FLAGS_GLOBAL; }\n#line 1986 \"grammar.c\"\n    break;\n\n  case 22:\n#line 429 \"grammar.y\"\n      {\n        (yyval.tag) = YR_ARENA_NULL_REF;\n      }\n#line 1994 \"grammar.c\"\n    break;\n\n  case 23:\n#line 433 \"grammar.y\"\n      {\n        // Tags list is represented in the arena as a sequence\n        // of null-terminated strings, the sequence ends with an\n        // additional null character. Here we write the ending null\n        //character. Example: tag1\\0tag2\\0tag3\\0\\0\n\n        fail_if_error(yr_arena_write_string(\n            yyget_extra(yyscanner)->arena, YR_SZ_POOL, \"\", NULL));\n\n        (yyval.tag) = (yyvsp[0].tag);\n      }\n#line 2010 \"grammar.c\"\n    break;\n\n  case 24:\n#line 449 \"grammar.y\"\n      {\n        int result = yr_arena_write_string(\n            yyget_extra(yyscanner)->arena, YR_SZ_POOL, (yyvsp[0].c_string), &(yyval.tag));\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n      }\n#line 2023 \"grammar.c\"\n    break;\n\n  case 25:\n#line 458 \"grammar.y\"\n      {\n        YR_ARENA_REF ref;\n\n        // Write the new tag identifier.\n        int result = yr_arena_write_string(\n            yyget_extra(yyscanner)->arena, YR_SZ_POOL, (yyvsp[0].c_string), &ref);\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n\n        // Get the address for the tag identifier just written.\n        char* new_tag = (char*) yr_arena_ref_to_ptr(\n            compiler->arena, &ref);\n\n        // Take the address of first tag's identifier in the list.\n        char* tag = (char*) yr_arena_ref_to_ptr(\n            compiler->arena, &(yyval.tag));\n\n\t// Search for duplicated tags. Tags are written one after\n\t// the other, with zeroes in between (i.e: tag1/0tag2/0tag3)\n\t// that's why can use tag < new_tag as the condition for the\n\t// loop.\n        while (tag < new_tag)\n        {\n          if (strcmp(tag, new_tag) == 0)\n          {\n            yr_compiler_set_error_extra_info(compiler, tag);\n            fail_with_error(ERROR_DUPLICATED_TAG_IDENTIFIER);\n          }\n\n          tag += strlen(tag) + 1;\n        }\n\n        (yyval.tag) = (yyvsp[-1].tag);\n      }\n#line 2064 \"grammar.c\"\n    break;\n\n  case 26:\n#line 499 \"grammar.y\"\n                                          {  (yyval.meta) = (yyvsp[0].meta); }\n#line 2070 \"grammar.c\"\n    break;\n\n  case 27:\n#line 500 \"grammar.y\"\n                                          {  (yyval.meta) = (yyvsp[-1].meta); }\n#line 2076 \"grammar.c\"\n    break;\n\n  case 28:\n#line 506 \"grammar.y\"\n      {\n        SIZED_STRING* sized_string = (yyvsp[0].sized_string);\n\n        int result = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_STRING,\n            (yyvsp[-2].c_string),\n            sized_string->c_string,\n            0,\n            &(yyval.meta));\n\n        yr_free((yyvsp[-2].c_string));\n        yr_free((yyvsp[0].sized_string));\n\n        fail_if_error(result);\n      }\n#line 2097 \"grammar.c\"\n    break;\n\n  case 29:\n#line 523 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_INTEGER,\n            (yyvsp[-2].c_string),\n            NULL,\n            (yyvsp[0].integer),\n            &(yyval.meta));\n\n        yr_free((yyvsp[-2].c_string));\n\n        fail_if_error(result);\n      }\n#line 2115 \"grammar.c\"\n    break;\n\n  case 30:\n#line 537 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_INTEGER,\n            (yyvsp[-3].c_string),\n            NULL,\n            -(yyvsp[0].integer),\n            &(yyval.meta));\n\n        yr_free((yyvsp[-3].c_string));\n\n        fail_if_error(result);\n      }\n#line 2133 \"grammar.c\"\n    break;\n\n  case 31:\n#line 551 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_BOOLEAN,\n            (yyvsp[-2].c_string),\n            NULL,\n            true,\n            &(yyval.meta));\n\n        yr_free((yyvsp[-2].c_string));\n\n        fail_if_error(result);\n      }\n#line 2151 \"grammar.c\"\n    break;\n\n  case 32:\n#line 565 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_BOOLEAN,\n            (yyvsp[-2].c_string),\n            NULL,\n            false,\n            &(yyval.meta));\n\n        yr_free((yyvsp[-2].c_string));\n\n        fail_if_error(result);\n      }\n#line 2169 \"grammar.c\"\n    break;\n\n  case 33:\n#line 582 \"grammar.y\"\n                                              { (yyval.string) = (yyvsp[0].string); }\n#line 2175 \"grammar.c\"\n    break;\n\n  case 34:\n#line 583 \"grammar.y\"\n                                              { (yyval.string) = (yyvsp[-1].string); }\n#line 2181 \"grammar.c\"\n    break;\n\n  case 35:\n#line 589 \"grammar.y\"\n      {\n        compiler->current_line = yyget_lineno(yyscanner);\n      }\n#line 2189 \"grammar.c\"\n    break;\n\n  case 36:\n#line 593 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_string_declaration(\n            yyscanner, (yyvsp[0].modifier), (yyvsp[-4].c_string), (yyvsp[-1].sized_string), &(yyval.string));\n\n        yr_free((yyvsp[-4].c_string));\n        yr_free((yyvsp[-1].sized_string));\n        yr_free((yyvsp[0].modifier).alphabet);\n\n        fail_if_error(result);\n        compiler->current_line = 0;\n      }\n#line 2205 \"grammar.c\"\n    break;\n\n  case 37:\n#line 605 \"grammar.y\"\n      {\n        compiler->current_line = yyget_lineno(yyscanner);\n      }\n#line 2213 \"grammar.c\"\n    break;\n\n  case 38:\n#line 609 \"grammar.y\"\n      {\n        int result;\n\n        (yyvsp[0].modifier).flags |= STRING_FLAGS_REGEXP;\n\n        result = yr_parser_reduce_string_declaration(\n            yyscanner, (yyvsp[0].modifier), (yyvsp[-4].c_string), (yyvsp[-1].sized_string), &(yyval.string));\n\n        yr_free((yyvsp[-4].c_string));\n        yr_free((yyvsp[-1].sized_string));\n\n        fail_if_error(result);\n\n        compiler->current_line = 0;\n      }\n#line 2233 \"grammar.c\"\n    break;\n\n  case 39:\n#line 625 \"grammar.y\"\n      {\n        compiler->current_line = yyget_lineno(yyscanner);\n      }\n#line 2241 \"grammar.c\"\n    break;\n\n  case 40:\n#line 629 \"grammar.y\"\n      {\n        int result;\n\n        (yyvsp[0].modifier).flags |= STRING_FLAGS_HEXADECIMAL;\n\n        result = yr_parser_reduce_string_declaration(\n            yyscanner, (yyvsp[0].modifier), (yyvsp[-4].c_string), (yyvsp[-1].sized_string), &(yyval.string));\n\n        yr_free((yyvsp[-4].c_string));\n        yr_free((yyvsp[-1].sized_string));\n\n        fail_if_error(result);\n\n        compiler->current_line = 0;\n      }\n#line 2261 \"grammar.c\"\n    break;\n\n  case 41:\n#line 649 \"grammar.y\"\n      {\n        (yyval.modifier).flags = 0;\n        (yyval.modifier).xor_min = 0;\n        (yyval.modifier).xor_max = 0;\n        (yyval.modifier).alphabet = NULL;\n      }\n#line 2272 \"grammar.c\"\n    break;\n\n  case 42:\n#line 656 \"grammar.y\"\n      {\n        (yyval.modifier) = (yyvsp[-1].modifier);\n\n        // Only set the xor minimum and maximum if we are dealing with the\n        // xor modifier. If we don't check for this then we can end up with\n        // \"xor wide\" resulting in whatever is on the stack for \"wide\"\n        // overwriting the values for xor.\n        if ((yyvsp[0].modifier).flags & STRING_FLAGS_XOR)\n        {\n          (yyval.modifier).xor_min = (yyvsp[0].modifier).xor_min;\n          (yyval.modifier).xor_max = (yyvsp[0].modifier).xor_max;\n        }\n\n        // Only set the base64 alphabet if we are dealing with the base64\n        // modifier. If we don't check for this then we can end up with\n        // \"base64 ascii\" resulting in whatever is on the stack for \"ascii\"\n        // overwriting the values for base64.\n        if (((yyvsp[0].modifier).flags & STRING_FLAGS_BASE64) ||\n            ((yyvsp[0].modifier).flags & STRING_FLAGS_BASE64_WIDE))\n        {\n          if ((yyval.modifier).alphabet != NULL)\n          {\n            if (sized_string_cmp((yyval.modifier).alphabet, (yyvsp[0].modifier).alphabet) != 0)\n            {\n              yr_compiler_set_error_extra_info(\n                  compiler, \"can not specify multiple alphabets\");\n\n              yr_free((yyvsp[0].modifier).alphabet);\n              yr_free((yyval.modifier).alphabet);\n\n              fail_with_error(ERROR_INVALID_MODIFIER);\n            }\n            else\n            {\n              yr_free((yyvsp[0].modifier).alphabet);\n            }\n          }\n          else\n          {\n            (yyval.modifier).alphabet = (yyvsp[0].modifier).alphabet;\n          }\n        }\n\n        if ((yyval.modifier).flags & (yyvsp[0].modifier).flags)\n        {\n          if ((yyval.modifier).alphabet != NULL)\n            yr_free((yyval.modifier).alphabet);\n\n          fail_with_error(ERROR_DUPLICATED_MODIFIER);\n        }\n        else\n        {\n          (yyval.modifier).flags = (yyval.modifier).flags | (yyvsp[0].modifier).flags;\n        }\n      }\n#line 2332 \"grammar.c\"\n    break;\n\n  case 43:\n#line 715 \"grammar.y\"\n                    { (yyval.modifier).flags = STRING_FLAGS_WIDE; }\n#line 2338 \"grammar.c\"\n    break;\n\n  case 44:\n#line 716 \"grammar.y\"\n                    { (yyval.modifier).flags = STRING_FLAGS_ASCII; }\n#line 2344 \"grammar.c\"\n    break;\n\n  case 45:\n#line 717 \"grammar.y\"\n                    { (yyval.modifier).flags = STRING_FLAGS_NO_CASE; }\n#line 2350 \"grammar.c\"\n    break;\n\n  case 46:\n#line 718 \"grammar.y\"\n                    { (yyval.modifier).flags = STRING_FLAGS_FULL_WORD; }\n#line 2356 \"grammar.c\"\n    break;\n\n  case 47:\n#line 719 \"grammar.y\"\n                    { (yyval.modifier).flags = STRING_FLAGS_PRIVATE; }\n#line 2362 \"grammar.c\"\n    break;\n\n  case 48:\n#line 721 \"grammar.y\"\n      {\n        (yyval.modifier).flags = STRING_FLAGS_XOR;\n        (yyval.modifier).xor_min = 0;\n        (yyval.modifier).xor_max = 255;\n      }\n#line 2372 \"grammar.c\"\n    break;\n\n  case 49:\n#line 727 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        if ((yyvsp[-1].integer) < 0 || (yyvsp[-1].integer) > 255)\n        {\n          yr_compiler_set_error_extra_info(compiler, \"invalid xor range\");\n          result = ERROR_INVALID_MODIFIER;\n        }\n\n        fail_if_error(result);\n\n        (yyval.modifier).flags = STRING_FLAGS_XOR;\n        (yyval.modifier).xor_min = (yyvsp[-1].integer);\n        (yyval.modifier).xor_max = (yyvsp[-1].integer);\n      }\n#line 2392 \"grammar.c\"\n    break;\n\n  case 50:\n#line 748 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        if ((yyvsp[-3].integer) < 0)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"lower bound for xor range exceeded (min: 0)\");\n          result = ERROR_INVALID_MODIFIER;\n        }\n\n        if ((yyvsp[-1].integer) > 255)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"upper bound for xor range exceeded (max: 255)\");\n          result = ERROR_INVALID_MODIFIER;\n        }\n\n        if ((yyvsp[-3].integer) > (yyvsp[-1].integer))\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"xor lower bound exceeds upper bound\");\n          result = ERROR_INVALID_MODIFIER;\n        }\n\n        fail_if_error(result);\n\n        (yyval.modifier).flags = STRING_FLAGS_XOR;\n        (yyval.modifier).xor_min = (yyvsp[-3].integer);\n        (yyval.modifier).xor_max = (yyvsp[-1].integer);\n      }\n#line 2427 \"grammar.c\"\n    break;\n\n  case 51:\n#line 779 \"grammar.y\"\n      {\n        (yyval.modifier).flags = STRING_FLAGS_BASE64;\n        (yyval.modifier).alphabet = sized_string_new(DEFAULT_BASE64_ALPHABET);\n      }\n#line 2436 \"grammar.c\"\n    break;\n\n  case 52:\n#line 784 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        if ((yyvsp[-1].sized_string)->length != 64)\n        {\n          yr_free((yyvsp[-1].sized_string));\n          result = yr_compiler_set_error_extra_info(\n              compiler, \"length of base64 alphabet must be 64\");\n          result = ERROR_INVALID_MODIFIER;\n        }\n\n        fail_if_error(result);\n\n        (yyval.modifier).flags = STRING_FLAGS_BASE64;\n        (yyval.modifier).alphabet = (yyvsp[-1].sized_string);\n      }\n#line 2457 \"grammar.c\"\n    break;\n\n  case 53:\n#line 801 \"grammar.y\"\n      {\n        (yyval.modifier).flags = STRING_FLAGS_BASE64_WIDE;\n        (yyval.modifier).alphabet = sized_string_new(DEFAULT_BASE64_ALPHABET);\n      }\n#line 2466 \"grammar.c\"\n    break;\n\n  case 54:\n#line 806 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        if ((yyvsp[-1].sized_string)->length != 64)\n        {\n          yr_free((yyvsp[-1].sized_string));\n          result = yr_compiler_set_error_extra_info(\n              compiler, \"length of base64 alphabet must be 64\");\n          result = ERROR_INVALID_MODIFIER;\n        }\n\n        fail_if_error(result);\n\n        (yyval.modifier).flags = STRING_FLAGS_BASE64_WIDE;\n        (yyval.modifier).alphabet = (yyvsp[-1].sized_string);\n      }\n#line 2487 \"grammar.c\"\n    break;\n\n  case 55:\n#line 825 \"grammar.y\"\n                                          { (yyval.modifier).flags = 0; }\n#line 2493 \"grammar.c\"\n    break;\n\n  case 56:\n#line 827 \"grammar.y\"\n      {\n        if ((yyvsp[-1].modifier).flags & (yyvsp[0].modifier).flags)\n        {\n          fail_with_error(ERROR_DUPLICATED_MODIFIER);\n        }\n        else\n        {\n          (yyval.modifier).flags = (yyvsp[-1].modifier).flags | (yyvsp[0].modifier).flags;\n        }\n      }\n#line 2508 \"grammar.c\"\n    break;\n\n  case 57:\n#line 840 \"grammar.y\"\n                    { (yyval.modifier).flags = STRING_FLAGS_WIDE; }\n#line 2514 \"grammar.c\"\n    break;\n\n  case 58:\n#line 841 \"grammar.y\"\n                    { (yyval.modifier).flags = STRING_FLAGS_ASCII; }\n#line 2520 \"grammar.c\"\n    break;\n\n  case 59:\n#line 842 \"grammar.y\"\n                    { (yyval.modifier).flags = STRING_FLAGS_NO_CASE; }\n#line 2526 \"grammar.c\"\n    break;\n\n  case 60:\n#line 843 \"grammar.y\"\n                    { (yyval.modifier).flags = STRING_FLAGS_FULL_WORD; }\n#line 2532 \"grammar.c\"\n    break;\n\n  case 61:\n#line 844 \"grammar.y\"\n                    { (yyval.modifier).flags = STRING_FLAGS_PRIVATE; }\n#line 2538 \"grammar.c\"\n    break;\n\n  case 62:\n#line 848 \"grammar.y\"\n                                          { (yyval.modifier).flags = 0; }\n#line 2544 \"grammar.c\"\n    break;\n\n  case 63:\n#line 850 \"grammar.y\"\n      {\n        if ((yyvsp[-1].modifier).flags & (yyvsp[0].modifier).flags)\n        {\n          fail_with_error(ERROR_DUPLICATED_MODIFIER);\n        }\n        else\n        {\n          (yyval.modifier).flags = (yyvsp[-1].modifier).flags | (yyvsp[0].modifier).flags;\n        }\n      }\n#line 2559 \"grammar.c\"\n    break;\n\n  case 64:\n#line 863 \"grammar.y\"\n                    { (yyval.modifier).flags = STRING_FLAGS_PRIVATE; }\n#line 2565 \"grammar.c\"\n    break;\n\n  case 65:\n#line 868 \"grammar.y\"\n      {\n        YR_EXPRESSION expr;\n\n        int result = ERROR_SUCCESS;\n        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string), &expr);\n\n        if (var_index >= 0)\n        {\n          // The identifier corresponds to a loop variable.\n          result = yr_parser_emit_with_arg(\n              yyscanner,\n              OP_PUSH_M,\n              var_index,\n              NULL,\n              NULL);\n\n          // The expression associated to this identifier is the same one\n          // associated to the loop variable.\n          (yyval.expression) = expr;\n        }\n        else\n        {\n          // Search for identifier within the global namespace, where the\n          // externals variables reside.\n\n          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(\n              compiler->objects_table, (yyvsp[0].c_string), NULL);\n\n          YR_NAMESPACE* ns = (YR_NAMESPACE*) yr_arena_get_ptr(\n              compiler->arena,\n              YR_NAMESPACES_TABLE,\n              compiler->current_namespace_idx * sizeof(struct YR_NAMESPACE));\n\n          if (object == NULL)\n          {\n            // If not found, search within the current namespace.\n            object = (YR_OBJECT*) yr_hash_table_lookup(\n                compiler->objects_table, (yyvsp[0].c_string), ns->name);\n          }\n\n          if (object != NULL)\n          {\n            YR_ARENA_REF ref;\n\n            result = yr_arena_write_string(\n                compiler->arena, YR_SZ_POOL, (yyvsp[0].c_string), &ref);\n\n            if (result == ERROR_SUCCESS)\n              result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_OBJ_LOAD,\n                  yr_arena_ref_to_ptr(compiler->arena, &ref),\n                  NULL,\n                  NULL);\n\n            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n            (yyval.expression).value.object = object;\n            (yyval.expression).identifier.ptr = NULL;\n            (yyval.expression).identifier.ref = ref;\n          }\n          else\n          {\n            uint32_t rule_idx = yr_hash_table_lookup_uint32(\n                compiler->rules_table, (yyvsp[0].c_string), ns->name);\n\n            if (rule_idx != UINT32_MAX)\n            {\n              result = yr_parser_emit_with_arg(\n                  yyscanner,\n                  OP_PUSH_RULE,\n                  rule_idx,\n                  NULL,\n                  NULL);\n\n              YR_RULE* rule = _yr_compiler_get_rule_by_idx(compiler, rule_idx);\n\n              yr_arena_ptr_to_ref(compiler->arena, rule->identifier, &(yyval.expression).identifier.ref);\n\n              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n              (yyval.expression).value.integer = YR_UNDEFINED;\n              (yyval.expression).identifier.ptr = NULL;\n            }\n            else\n            {\n              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\n              result = ERROR_UNDEFINED_IDENTIFIER;\n            }\n          }\n        }\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n      }\n#line 2664 \"grammar.c\"\n    break;\n\n  case 66:\n#line 963 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n        YR_OBJECT* field = NULL;\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)\n        {\n          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));\n\n          if (field != NULL)\n          {\n            YR_ARENA_REF ref;\n\n            result = yr_arena_write_string(\n                compiler->arena, YR_SZ_POOL, (yyvsp[0].c_string), &ref);\n\n            if (result == ERROR_SUCCESS)\n              result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_OBJ_FIELD,\n                  yr_arena_ref_to_ptr(compiler->arena, &ref),\n                  NULL,\n                  NULL);\n\n            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n            (yyval.expression).value.object = field;\n            (yyval.expression).identifier.ref = ref;\n            (yyval.expression).identifier.ptr = NULL;\n          }\n          else\n          {\n            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\n            result = ERROR_INVALID_FIELD_NAME;\n          }\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n             compiler, expression_identifier((yyvsp[-2].expression)));\n\n          result = ERROR_NOT_A_STRUCTURE;\n        }\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n      }\n#line 2716 \"grammar.c\"\n    break;\n\n  case 67:\n#line 1011 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n        YR_OBJECT_ARRAY* array;\n        YR_OBJECT_DICTIONARY* dict;\n\n        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)\n        {\n          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)\n          {\n            yr_compiler_set_error_extra_info(\n                compiler, \"array indexes must be of integer type\");\n            result = ERROR_WRONG_TYPE;\n          }\n\n          fail_if_error(result);\n\n          result = yr_parser_emit(\n              yyscanner, OP_INDEX_ARRAY, NULL);\n\n          array = object_as_array((yyvsp[-3].expression).value.object);\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = array->prototype_item;\n          (yyval.expression).identifier.ptr = array->identifier;\n          (yyval.expression).identifier.ref = YR_ARENA_NULL_REF;\n        }\n        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)\n        {\n          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)\n          {\n            yr_compiler_set_error_extra_info(\n                compiler, \"dictionary keys must be of string type\");\n            result = ERROR_WRONG_TYPE;\n          }\n\n          fail_if_error(result);\n\n          result = yr_parser_emit(\n              yyscanner, OP_LOOKUP_DICT, NULL);\n\n          dict = object_as_dictionary((yyvsp[-3].expression).value.object);\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = dict->prototype_item;\n          (yyval.expression).identifier.ptr = dict->identifier;\n          (yyval.expression).identifier.ref = YR_ARENA_NULL_REF;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, expression_identifier((yyvsp[-3].expression)));\n\n          result = ERROR_NOT_INDEXABLE;\n        }\n\n        fail_if_error(result);\n      }\n#line 2780 \"grammar.c\"\n    break;\n\n  case 68:\n#line 1072 \"grammar.y\"\n      {\n        YR_ARENA_REF ref;\n        int result = ERROR_SUCCESS;\n        YR_OBJECT_FUNCTION* function;\n\n        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)\n        {\n          result = yr_parser_check_types(\n              compiler, object_as_function((yyvsp[-3].expression).value.object), (yyvsp[-1].c_string));\n\n          if (result == ERROR_SUCCESS)\n            result = yr_arena_write_string(\n                compiler->arena, YR_SZ_POOL, (yyvsp[-1].c_string), &ref);\n\n          if (result == ERROR_SUCCESS)\n            result = yr_parser_emit_with_arg_reloc(\n                yyscanner,\n                OP_CALL,\n                yr_arena_ref_to_ptr(compiler->arena, &ref),\n                NULL,\n                NULL);\n\n          function = object_as_function((yyvsp[-3].expression).value.object);\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = function->return_obj;\n          (yyval.expression).identifier.ref = ref;\n          (yyval.expression).identifier.ptr = NULL;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, expression_identifier((yyvsp[-3].expression)));\n\n          result = ERROR_NOT_A_FUNCTION;\n        }\n\n        yr_free((yyvsp[-1].c_string));\n\n        fail_if_error(result);\n      }\n#line 2827 \"grammar.c\"\n    break;\n\n  case 69:\n#line 1118 \"grammar.y\"\n                      { (yyval.c_string) = yr_strdup(\"\"); }\n#line 2833 \"grammar.c\"\n    break;\n\n  case 70:\n#line 1119 \"grammar.y\"\n                      { (yyval.c_string) = (yyvsp[0].c_string); }\n#line 2839 \"grammar.c\"\n    break;\n\n  case 71:\n#line 1124 \"grammar.y\"\n      {\n        (yyval.c_string) = (char*) yr_malloc(YR_MAX_FUNCTION_ARGS + 1);\n\n        if ((yyval.c_string) == NULL)\n          fail_with_error(ERROR_INSUFFICIENT_MEMORY);\n\n        switch((yyvsp[0].expression).type)\n        {\n          case EXPRESSION_TYPE_INTEGER:\n            strlcpy((yyval.c_string), \"i\", YR_MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_FLOAT:\n            strlcpy((yyval.c_string), \"f\", YR_MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_BOOLEAN:\n            strlcpy((yyval.c_string), \"b\", YR_MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_STRING:\n            strlcpy((yyval.c_string), \"s\", YR_MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_REGEXP:\n            strlcpy((yyval.c_string), \"r\", YR_MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_UNKNOWN:\n            yr_free((yyval.c_string));\n            yr_compiler_set_error_extra_info(\n                compiler, \"unknown type for argument 1 in function call\");\n            fail_with_error(ERROR_WRONG_TYPE);\n            break;\n          default:\n            // An unknown expression type is OK iff an error ocurred.\n            assert(compiler->last_error != ERROR_SUCCESS);\n        }\n      }\n#line 2878 \"grammar.c\"\n    break;\n\n  case 72:\n#line 1159 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        if (strlen((yyvsp[-2].c_string)) == YR_MAX_FUNCTION_ARGS)\n        {\n          result = ERROR_TOO_MANY_ARGUMENTS;\n        }\n        else\n        {\n          switch((yyvsp[0].expression).type)\n          {\n            case EXPRESSION_TYPE_INTEGER:\n              strlcat((yyvsp[-2].c_string), \"i\", YR_MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_FLOAT:\n              strlcat((yyvsp[-2].c_string), \"f\", YR_MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_BOOLEAN:\n              strlcat((yyvsp[-2].c_string), \"b\", YR_MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_STRING:\n              strlcat((yyvsp[-2].c_string), \"s\", YR_MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_REGEXP:\n              strlcat((yyvsp[-2].c_string), \"r\", YR_MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_UNKNOWN:\n              result = ERROR_WRONG_TYPE;\n              yr_compiler_set_error_extra_info_fmt(\n                  compiler, \"unknown type for argument %zu in function call\",\n                  // As we add one character per argument, the length of $1 is\n                  // the number of arguments parsed so far, and the argument\n                  // represented by <expression> is length of $1 plus one.\n                  strlen((yyvsp[-2].c_string)) + 1);\n              break;\n            default:\n              // An unknown expression type is OK iff an error ocurred.\n              assert(compiler->last_error != ERROR_SUCCESS);\n          }\n        }\n\n        if (result != ERROR_SUCCESS)\n          yr_free((yyvsp[-2].c_string));\n\n        fail_if_error(result);\n\n        (yyval.c_string) = (yyvsp[-2].c_string);\n      }\n#line 2931 \"grammar.c\"\n    break;\n\n  case 73:\n#line 1212 \"grammar.y\"\n      {\n        SIZED_STRING* sized_string = (yyvsp[0].sized_string);\n        YR_ARENA_REF re_ref;\n        RE_ERROR error;\n\n        int result = ERROR_SUCCESS;\n        int re_flags = 0;\n\n        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)\n          re_flags |= RE_FLAGS_NO_CASE;\n\n        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)\n          re_flags |= RE_FLAGS_DOT_ALL;\n\n        result = yr_re_compile(\n            sized_string->c_string,\n            re_flags,\n            compiler->arena,\n            &re_ref,\n            &error);\n\n        yr_free((yyvsp[0].sized_string));\n\n        if (result == ERROR_INVALID_REGULAR_EXPRESSION)\n          yr_compiler_set_error_extra_info(compiler, error.message);\n\n        if (result == ERROR_SUCCESS)\n          result = yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_PUSH,\n              yr_arena_ref_to_ptr(compiler->arena, &re_ref),\n              NULL,\n              NULL);\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;\n      }\n#line 2974 \"grammar.c\"\n    break;\n\n  case 74:\n#line 1255 \"grammar.y\"\n      {\n        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)\n        {\n          if (!YR_ARENA_IS_NULL_REF((yyvsp[0].expression).value.sized_string_ref))\n          {\n            SIZED_STRING* sized_string = yr_arena_ref_to_ptr(\n                compiler->arena, &(yyvsp[0].expression).value.sized_string_ref);\n\n            yywarning(yyscanner,\n                \"Using literal string \\\"%s\\\" in a boolean operation.\",\n                sized_string->c_string);\n          }\n\n          fail_if_error(yr_parser_emit(\n              yyscanner, OP_STR_TO_BOOL, NULL));\n        }\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2998 \"grammar.c\"\n    break;\n\n  case 75:\n#line 1278 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 1, NULL, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3009 \"grammar.c\"\n    break;\n\n  case 76:\n#line 1285 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 0, NULL, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3020 \"grammar.c\"\n    break;\n\n  case 77:\n#line 1292 \"grammar.y\"\n      {\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"matches\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, \"matches\");\n\n        fail_if_error(yr_parser_emit(\n            yyscanner,\n            OP_MATCHES,\n            NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3036 \"grammar.c\"\n    break;\n\n  case 78:\n#line 1304 \"grammar.y\"\n      {\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"contains\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_STRING, \"contains\");\n\n        fail_if_error(yr_parser_emit(\n            yyscanner, OP_CONTAINS, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3050 \"grammar.c\"\n    break;\n\n  case 79:\n#line 1314 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_string_identifier(\n            yyscanner,\n            (yyvsp[0].c_string),\n            OP_FOUND,\n            YR_UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3068 \"grammar.c\"\n    break;\n\n  case 80:\n#line 1328 \"grammar.y\"\n      {\n        int result;\n\n        check_type_with_cleanup((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"at\", yr_free((yyvsp[-2].c_string)));\n\n        result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);\n\n        yr_free((yyvsp[-2].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3087 \"grammar.c\"\n    break;\n\n  case 81:\n#line 1343 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, YR_UNDEFINED);\n\n        yr_free((yyvsp[-2].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3102 \"grammar.c\"\n    break;\n\n  case 82:\n#line 1354 \"grammar.y\"\n      {\n        int i;\n\n        // Free all the loop variable identifiers, including the variables for\n        // the current loop (represented by loop_index), and set loop_index to\n        // -1. This is OK even if we have nested loops. If an error occurs while\n        // parsing the inner loop, it will be propagated to the outer loop\n        // anyways, so it's safe to do this cleanup while processing the error\n        // for the inner loop.\n\n        for (i = 0; i <= compiler->loop_index; i++)\n        {\n          loop_vars_cleanup(i);\n        }\n\n        compiler->loop_index = -1;\n        YYERROR;\n      }\n#line 3125 \"grammar.c\"\n    break;\n\n  case 83:\n#line 1432 \"grammar.y\"\n      {\n        // var_frame is used for accessing local variables used in this loop.\n        // All local variables are accessed using var_frame as a reference,\n        // like var_frame + 0, var_frame + 1, etc. Here we initialize var_frame\n        // with the correct value, which depends on the number of variables\n        // defined by any outer loops.\n\n        int var_frame;\n        int result = ERROR_SUCCESS;\n\n        if (compiler->loop_index + 1 == YR_MAX_LOOP_NESTING)\n          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;\n\n        fail_if_error(result);\n\n        compiler->loop_index++;\n\n        // This loop uses internal variables besides the ones explicitly\n        // defined by the user.\n        compiler->loop[compiler->loop_index].vars_internal_count = \\\n       \t\tYR_INTERNAL_LOOP_VARS;\n\n        // Initialize the number of variables, this number will be incremented\n        // as variable declaration are processed by for_variables.\n        compiler->loop[compiler->loop_index].vars_count = 0;\n\n        var_frame = _yr_compiler_get_var_frame(compiler);\n\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, var_frame + 0, NULL, NULL));\n\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, var_frame + 1, NULL, NULL));\n\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_POP_M, var_frame + 2, NULL, NULL));\n      }\n#line 3167 \"grammar.c\"\n    break;\n\n  case 84:\n#line 1470 \"grammar.y\"\n      {\n        YR_LOOP_CONTEXT* loop_ctx = &compiler->loop[compiler->loop_index];\n        YR_FIXUP* fixup;\n\n        YR_ARENA_REF loop_start_ref;\n        YR_ARENA_REF jmp_offset_ref;\n\n        int var_frame = _yr_compiler_get_var_frame(compiler);\n        int i;\n\n        fail_if_error(yr_parser_emit(\n            yyscanner, OP_ITER_NEXT, &loop_start_ref));\n\n        // For each variable generate an instruction that pops the value from\n        // the stack and store it into one memory slot starting at var_frame +\n        // YR_INTERNAL_LOOP_VARS because the first YR_INTERNAL_LOOP_VARS slots\n        // in the frame are for the internal variables.\n\n        for (i = 0; i < loop_ctx->vars_count; i++)\n        {\n          fail_if_error(yr_parser_emit_with_arg(\n              yyscanner,\n              OP_POP_M,\n              var_frame + YR_INTERNAL_LOOP_VARS + i,\n              NULL,\n              NULL));\n        }\n\n        fail_if_error(yr_parser_emit_with_arg_int32(\n            yyscanner,\n            OP_JTRUE_P,\n            0,              // still don't know the jump offset, use 0 for now.\n            NULL,\n            &jmp_offset_ref));\n\n        // We still don't know the jump's target, so we push a fixup entry\n        // in the stack, so that the jump's offset can be set once we know it.\n\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          fail_with_error(ERROR_INSUFFICIENT_MEMORY);\n\n        fixup->ref = jmp_offset_ref;\n        fixup->next = compiler->fixup_stack_head;\n        compiler->fixup_stack_head = fixup;\n\n        loop_ctx->start_ref = loop_start_ref;\n      }\n#line 3221 \"grammar.c\"\n    break;\n\n  case 85:\n#line 1520 \"grammar.y\"\n      {\n        int32_t jmp_offset;\n        YR_FIXUP* fixup;\n        YR_ARENA_REF pop_ref;\n        YR_ARENA_REF jmp_offset_ref;\n\n        int var_frame = _yr_compiler_get_var_frame(compiler);\n\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_ADD_M, var_frame + 0, NULL, NULL));\n\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_INCR_M, var_frame + 1, NULL, NULL));\n\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, var_frame + 2, NULL, NULL));\n\n        jmp_offset = \\\n            compiler->loop[compiler->loop_index].start_ref.offset -\n            yr_arena_get_current_offset(compiler->arena, YR_CODE_SECTION);\n\n        fail_if_error(yr_parser_emit_with_arg_int32(\n            yyscanner,\n            OP_JUNDEF_P,\n            jmp_offset,\n            NULL,\n            NULL));\n\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, var_frame + 0, NULL, NULL));\n\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, var_frame + 2, NULL, NULL));\n\n        jmp_offset = \\\n            compiler->loop[compiler->loop_index].start_ref.offset -\n            yr_arena_get_current_offset(compiler->arena, YR_CODE_SECTION);\n\n        fail_if_error(yr_parser_emit_with_arg_int32(\n            yyscanner,\n            OP_JL_P,\n            jmp_offset,\n            NULL,\n            NULL));\n\n        fail_if_error(yr_parser_emit(\n            yyscanner, OP_POP, &pop_ref));\n\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, var_frame + 1, NULL, NULL));\n\n        fail_if_error(yr_parser_emit_with_arg_int32(\n            yyscanner,\n            OP_JZ,\n            0,      // still don't know the jump offset, use 0 for now.\n            NULL,\n            &jmp_offset_ref));\n\n        fail_if_error(yr_parser_emit(\n            yyscanner, OP_POP, NULL));\n\n        // Pop from the stack the fixup entry containing the reference to\n        // the jump offset that needs to be fixed.\n\n        fixup = compiler->fixup_stack_head;\n        compiler->fixup_stack_head = fixup->next;\n\n        // The fixup entry has a reference to the jump offset that need\n        // to be fixed, convert the address into a pointer.\n        int32_t* jmp_offset_addr = (int32_t*) yr_arena_ref_to_ptr(\n            compiler->arena, &fixup->ref);\n\n        // The reference in the fixup entry points to the jump's offset\n        // but the jump instruction is one byte before, that's why we add\n        // one to the offset.\n        jmp_offset = pop_ref.offset - fixup->ref.offset + 1;\n\n        // Fix the jump's offset.\n        *jmp_offset_addr = jmp_offset;\n\n        yr_free(fixup);\n\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, var_frame + 0, NULL, NULL));\n\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, var_frame + 2, NULL, NULL));\n\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_SWAPUNDEF, var_frame + 1, NULL, NULL));\n\n        fail_if_error(yr_parser_emit(\n            yyscanner, OP_INT_GE, NULL));\n\n        jmp_offset = \\\n            yr_arena_get_current_offset(compiler->arena, YR_CODE_SECTION) -\n            jmp_offset_ref.offset + 1;\n\n        jmp_offset_addr = (int32_t*) yr_arena_ref_to_ptr(\n            compiler->arena, &jmp_offset_ref);\n\n        *jmp_offset_addr = jmp_offset;\n\n        loop_vars_cleanup(compiler->loop_index);\n\n        compiler->loop_index--;\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3335 \"grammar.c\"\n    break;\n\n  case 86:\n#line 1630 \"grammar.y\"\n      {\n        YR_ARENA_REF ref;\n\n        int result = ERROR_SUCCESS;\n        int var_frame;\n\n        if (compiler->loop_index + 1 == YR_MAX_LOOP_NESTING)\n          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;\n\n        if (compiler->loop_for_of_var_index != -1)\n          result = ERROR_NESTED_FOR_OF_LOOP;\n\n        fail_if_error(result);\n\n        compiler->loop_index++;\n\n        var_frame = _yr_compiler_get_var_frame(compiler);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, var_frame + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, var_frame + 2, NULL, NULL);\n\n        // Pop the first string.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_POP_M, var_frame, &ref, NULL);\n\n        compiler->loop_for_of_var_index = var_frame;\n        compiler->loop[compiler->loop_index].start_ref = ref;\n        compiler->loop[compiler->loop_index].vars_count = 0;\n        compiler->loop[compiler->loop_index].vars_internal_count = \\\n            YR_INTERNAL_LOOP_VARS;\n      }\n#line 3374 \"grammar.c\"\n    break;\n\n  case 87:\n#line 1665 \"grammar.y\"\n      {\n        int var_frame = 0;\n\n        compiler->loop_for_of_var_index = -1;\n\n        var_frame = _yr_compiler_get_var_frame(compiler);\n\n        // Increment counter by the value returned by the\n        // boolean expression (0 or 1). If the boolean expression\n        // returned YR_UNDEFINED the OP_ADD_M won't do anything.\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_ADD_M, var_frame + 1, NULL, NULL);\n\n        // Increment iterations counter.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_INCR_M, var_frame + 2, NULL, NULL);\n\n        int32_t jmp_offset = \\\n            compiler->loop[compiler->loop_index].start_ref.offset -\n            yr_arena_get_current_offset(compiler->arena, YR_CODE_SECTION);\n\n        // If next string is not undefined, go back to the\n        // beginning of the loop.\n        yr_parser_emit_with_arg_int32(\n            yyscanner,\n            OP_JNUNDEF,\n            jmp_offset,\n            NULL,\n            NULL);\n\n        // Pop end-of-list marker.\n        yr_parser_emit(yyscanner, OP_POP, NULL);\n\n        // At this point the loop quantifier (any, all, 1, 2,..)\n        // is at top of the stack. Check if the quantifier is\n        // undefined (meaning \"all\") and replace it with the\n        // iterations counter in that case.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_SWAPUNDEF, var_frame + 2, NULL, NULL);\n\n        // Compare the loop quantifier with the number of\n        // expressions evaluating to true.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, var_frame + 1, NULL, NULL);\n\n        yr_parser_emit(yyscanner, OP_INT_LE, NULL);\n\n        loop_vars_cleanup(compiler->loop_index);\n\n        compiler->loop_index--;\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3433 \"grammar.c\"\n    break;\n\n  case 88:\n#line 1720 \"grammar.y\"\n      {\n        yr_parser_emit(yyscanner, OP_OF, NULL);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3443 \"grammar.c\"\n    break;\n\n  case 89:\n#line 1726 \"grammar.y\"\n      {\n        yr_parser_emit(yyscanner, OP_NOT, NULL);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3453 \"grammar.c\"\n    break;\n\n  case 90:\n#line 1732 \"grammar.y\"\n      {\n        YR_FIXUP* fixup;\n        YR_ARENA_REF jmp_offset_ref;\n\n        fail_if_error(yr_parser_emit_with_arg_int32(\n            yyscanner,\n            OP_JFALSE,\n            0,          // still don't know the jump offset, use 0 for now.\n            NULL,\n            &jmp_offset_ref));\n\n        // Create a fixup entry for the jump and push it in the stack.\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          fail_with_error(ERROR_INSUFFICIENT_MEMORY);\n\n        fixup->ref = jmp_offset_ref;\n        fixup->next = compiler->fixup_stack_head;\n        compiler->fixup_stack_head = fixup;\n      }\n#line 3479 \"grammar.c\"\n    break;\n\n  case 91:\n#line 1754 \"grammar.y\"\n      {\n        YR_FIXUP* fixup;\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_AND, NULL));\n\n        fixup = compiler->fixup_stack_head;\n\n        int32_t* jmp_offset_addr = (int32_t*) yr_arena_ref_to_ptr(\n            compiler->arena, &fixup->ref);\n\n        int32_t jmp_offset = \\\n            yr_arena_get_current_offset(compiler->arena, YR_CODE_SECTION) -\n            fixup->ref.offset + 1;\n\n        *jmp_offset_addr = jmp_offset;\n\n        // Remove fixup from the stack.\n        compiler->fixup_stack_head = fixup->next;\n        yr_free(fixup);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3506 \"grammar.c\"\n    break;\n\n  case 92:\n#line 1777 \"grammar.y\"\n      {\n        YR_FIXUP* fixup;\n        YR_ARENA_REF jmp_offset_ref;\n\n        fail_if_error(yr_parser_emit_with_arg_int32(\n            yyscanner,\n            OP_JTRUE,\n            0,         // still don't know the jump destination, use 0 for now.\n            NULL,\n            &jmp_offset_ref));\n\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          fail_with_error(ERROR_INSUFFICIENT_MEMORY);\n\n        fixup->ref = jmp_offset_ref;\n        fixup->next = compiler->fixup_stack_head;\n        compiler->fixup_stack_head = fixup;\n      }\n#line 3531 \"grammar.c\"\n    break;\n\n  case 93:\n#line 1798 \"grammar.y\"\n      {\n        YR_FIXUP* fixup;\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_OR, NULL));\n\n        fixup = compiler->fixup_stack_head;\n\n        int32_t jmp_offset = \\\n            yr_arena_get_current_offset(compiler->arena, YR_CODE_SECTION) -\n            fixup->ref.offset + 1;\n\n        int32_t* jmp_offset_addr = (int32_t*) yr_arena_ref_to_ptr(\n            compiler->arena, &fixup->ref);\n\n        *jmp_offset_addr = jmp_offset;\n\n        // Remove fixup from the stack.\n        compiler->fixup_stack_head = fixup->next;\n        yr_free(fixup);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3558 \"grammar.c\"\n    break;\n\n  case 94:\n#line 1821 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_reduce_operation(\n            yyscanner, \"<\", (yyvsp[-2].expression), (yyvsp[0].expression)));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3569 \"grammar.c\"\n    break;\n\n  case 95:\n#line 1828 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_reduce_operation(\n            yyscanner, \">\", (yyvsp[-2].expression), (yyvsp[0].expression)));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3580 \"grammar.c\"\n    break;\n\n  case 96:\n#line 1835 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_reduce_operation(\n            yyscanner, \"<=\", (yyvsp[-2].expression), (yyvsp[0].expression)));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3591 \"grammar.c\"\n    break;\n\n  case 97:\n#line 1842 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_reduce_operation(\n            yyscanner, \">=\", (yyvsp[-2].expression), (yyvsp[0].expression)));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3602 \"grammar.c\"\n    break;\n\n  case 98:\n#line 1849 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_reduce_operation(\n            yyscanner, \"==\", (yyvsp[-2].expression), (yyvsp[0].expression)));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3613 \"grammar.c\"\n    break;\n\n  case 99:\n#line 1856 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_reduce_operation(\n            yyscanner, \"!=\", (yyvsp[-2].expression), (yyvsp[0].expression)));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3624 \"grammar.c\"\n    break;\n\n  case 100:\n#line 1863 \"grammar.y\"\n      {\n        (yyval.expression) = (yyvsp[0].expression);\n      }\n#line 3632 \"grammar.c\"\n    break;\n\n  case 101:\n#line 1867 \"grammar.y\"\n      {\n        (yyval.expression) = (yyvsp[-1].expression);\n      }\n#line 3640 \"grammar.c\"\n    break;\n\n  case 102:\n#line 1875 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        YR_LOOP_CONTEXT* loop_ctx = &compiler->loop[compiler->loop_index];\n\n        if (yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string), NULL) >= 0)\n        {\n          yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\n          yr_free((yyvsp[0].c_string));\n\n          result = ERROR_DUPLICATED_LOOP_IDENTIFIER;\n        }\n\n        fail_if_error(result);\n\n        loop_ctx->vars[loop_ctx->vars_count++].identifier.ptr = (yyvsp[0].c_string);\n\n        assert(loop_ctx->vars_count <= YR_MAX_LOOP_VARS);\n      }\n#line 3664 \"grammar.c\"\n    break;\n\n  case 103:\n#line 1895 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        YR_LOOP_CONTEXT* loop_ctx = &compiler->loop[compiler->loop_index];\n\n        if (loop_ctx->vars_count == YR_MAX_LOOP_VARS)\n        {\n          yr_compiler_set_error_extra_info(compiler, \"too many loop variables\");\n          yr_free((yyvsp[0].c_string));\n\n          result = ERROR_SYNTAX_ERROR;\n        }\n        else if (yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string), NULL) >= 0)\n        {\n          yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\n          yr_free((yyvsp[0].c_string));\n\n          result = ERROR_DUPLICATED_LOOP_IDENTIFIER;\n        }\n\n        fail_if_error(result);\n\n        loop_ctx->vars[loop_ctx->vars_count++].identifier.ptr = (yyvsp[0].c_string);\n      }\n#line 3693 \"grammar.c\"\n    break;\n\n  case 104:\n#line 1923 \"grammar.y\"\n      {\n        YR_LOOP_CONTEXT* loop_ctx = &compiler->loop[compiler->loop_index];\n\n        // Initially we assume that the identifier is from a non-iterable type,\n        // this will change later if it's iterable.\n        int result = ERROR_WRONG_TYPE;\n\n        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)\n        {\n          switch((yyvsp[0].expression).value.object->type)\n          {\n            case OBJECT_TYPE_ARRAY:\n              // If iterating an array the loop must define a single variable\n              // that will hold the current item. If a different number of\n              // variables were defined that's an error.\n              if (loop_ctx->vars_count == 1)\n              {\n                loop_ctx->vars[0].type = EXPRESSION_TYPE_OBJECT;\n                loop_ctx->vars[0].value.object = \\\n                    object_as_array((yyvsp[0].expression).value.object)->prototype_item;\n\n                result = yr_parser_emit(yyscanner, OP_ITER_START_ARRAY, NULL);\n              }\n              else\n              {\n                yr_compiler_set_error_extra_info_fmt(\n                    compiler,\n                    \"iterator for \\\"%s\\\" yields a single item on each iteration\"\n                    \", but the loop expects %d\",\n                    expression_identifier((yyvsp[0].expression)),\n                    loop_ctx->vars_count);\n\n                result = ERROR_SYNTAX_ERROR;\n              }\n              break;\n\n            case OBJECT_TYPE_DICTIONARY:\n              // If iterating a dictionary the loop must define exactly two\n              // variables, one for the key and another for the value . If a\n              // different number of variables were defined that's an error.\n              if (loop_ctx->vars_count == 2)\n              {\n                loop_ctx->vars[0].type = EXPRESSION_TYPE_STRING;\n                loop_ctx->vars[0].value.sized_string_ref = YR_ARENA_NULL_REF;\n                loop_ctx->vars[1].type = EXPRESSION_TYPE_OBJECT;\n                loop_ctx->vars[1].value.object = \\\n                    object_as_array((yyvsp[0].expression).value.object)->prototype_item;\n\n                result = yr_parser_emit(yyscanner, OP_ITER_START_DICT, NULL);\n              }\n              else\n              {\n                yr_compiler_set_error_extra_info_fmt(\n                    compiler,\n                    \"iterator for \\\"%s\\\" yields a key,value pair item on each iteration\",\n                    expression_identifier((yyvsp[0].expression)));\n\n                result = ERROR_SYNTAX_ERROR;\n              }\n              break;\n          }\n        }\n\n        if (result == ERROR_WRONG_TYPE)\n        {\n          yr_compiler_set_error_extra_info_fmt(\n              compiler,\n              \"identifier \\\"%s\\\" is not iterable\",\n              expression_identifier((yyvsp[0].expression)));\n        }\n\n        fail_if_error(result);\n      }\n#line 3771 \"grammar.c\"\n    break;\n\n  case 105:\n#line 1997 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        YR_LOOP_CONTEXT* loop_ctx = &compiler->loop[compiler->loop_index];\n\n        if (loop_ctx->vars_count == 1)\n        {\n          loop_ctx->vars[0].type = EXPRESSION_TYPE_INTEGER;\n          loop_ctx->vars[0].value.integer = YR_UNDEFINED;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info_fmt(\n              compiler,\n              \"iterator yields an integer on each iteration \"\n              \", but the loop expects %d\",\n              loop_ctx->vars_count);\n\n          result = ERROR_SYNTAX_ERROR;\n        }\n\n        fail_if_error(result);\n      }\n#line 3799 \"grammar.c\"\n    break;\n\n  case 106:\n#line 2025 \"grammar.y\"\n      {\n        // $2 contains the number of integers in the enumeration\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, (yyvsp[-1].integer), NULL, NULL));\n\n        fail_if_error(yr_parser_emit(\n            yyscanner, OP_ITER_START_INT_ENUM, NULL));\n      }\n#line 3812 \"grammar.c\"\n    break;\n\n  case 107:\n#line 2034 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_emit(\n            yyscanner, OP_ITER_START_INT_RANGE, NULL));\n      }\n#line 3821 \"grammar.c\"\n    break;\n\n  case 108:\n#line 2043 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for range's lower bound\");\n          result = ERROR_WRONG_TYPE;\n        }\n\n        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for range's upper bound\");\n          result = ERROR_WRONG_TYPE;\n        }\n\n        fail_if_error(result);\n      }\n#line 3845 \"grammar.c\"\n    break;\n\n  case 109:\n#line 2067 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for enumeration item\");\n          result = ERROR_WRONG_TYPE;\n        }\n\n        fail_if_error(result);\n\n        (yyval.integer) = 1;\n      }\n#line 3864 \"grammar.c\"\n    break;\n\n  case 110:\n#line 2082 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for enumeration item\");\n          result = ERROR_WRONG_TYPE;\n        }\n\n        fail_if_error(result);\n\n        (yyval.integer) = (yyvsp[-2].integer) + 1;\n      }\n#line 3883 \"grammar.c\"\n    break;\n\n  case 111:\n#line 2101 \"grammar.y\"\n      {\n        // Push end-of-list marker\n        yr_parser_emit_with_arg(yyscanner, OP_PUSH, YR_UNDEFINED, NULL, NULL);\n      }\n#line 3892 \"grammar.c\"\n    break;\n\n  case 113:\n#line 2107 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, YR_UNDEFINED, NULL, NULL));\n\n        fail_if_error(yr_parser_emit_pushes_for_strings(\n            yyscanner, \"$*\"));\n      }\n#line 3904 \"grammar.c\"\n    break;\n\n  case 116:\n#line 2125 \"grammar.y\"\n      {\n        int result = yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n      }\n#line 3915 \"grammar.c\"\n    break;\n\n  case 117:\n#line 2132 \"grammar.y\"\n      {\n        int result = yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n      }\n#line 3926 \"grammar.c\"\n    break;\n\n  case 118:\n#line 2143 \"grammar.y\"\n      {\n        (yyval.integer) = FOR_EXPRESSION_ANY;\n      }\n#line 3934 \"grammar.c\"\n    break;\n\n  case 119:\n#line 2147 \"grammar.y\"\n      {\n        yr_parser_emit_with_arg(yyscanner, OP_PUSH, YR_UNDEFINED, NULL, NULL);\n        (yyval.integer) = FOR_EXPRESSION_ALL;\n      }\n#line 3943 \"grammar.c\"\n    break;\n\n  case 120:\n#line 2152 \"grammar.y\"\n      {\n        yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);\n        (yyval.integer) = FOR_EXPRESSION_ANY;\n      }\n#line 3952 \"grammar.c\"\n    break;\n\n  case 121:\n#line 2161 \"grammar.y\"\n      {\n        (yyval.expression) = (yyvsp[-1].expression);\n      }\n#line 3960 \"grammar.c\"\n    break;\n\n  case 122:\n#line 2165 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_emit(\n            yyscanner, OP_FILESIZE, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = YR_UNDEFINED;\n      }\n#line 3972 \"grammar.c\"\n    break;\n\n  case 123:\n#line 2173 \"grammar.y\"\n      {\n        yywarning(yyscanner,\n            \"Using deprecated \\\"entrypoint\\\" keyword. Use the \\\"entry_point\\\" \"\n            \"function from PE module instead.\");\n\n        fail_if_error(yr_parser_emit(\n            yyscanner, OP_ENTRYPOINT, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = YR_UNDEFINED;\n      }\n#line 3988 \"grammar.c\"\n    break;\n\n  case 124:\n#line 2185 \"grammar.y\"\n      {\n        check_type((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, \"intXXXX or uintXXXX\");\n\n        // _INTEGER_FUNCTION_ could be any of int8, int16, int32, uint8,\n        // uint32, etc. $1 contains an index that added to OP_READ_INT results\n        // in the proper OP_INTXX opcode.\n\n        fail_if_error(yr_parser_emit(\n            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = YR_UNDEFINED;\n      }\n#line 4006 \"grammar.c\"\n    break;\n\n  case 125:\n#line 2199 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = (yyvsp[0].integer);\n      }\n#line 4018 \"grammar.c\"\n    break;\n\n  case 126:\n#line 2207 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_emit_with_arg_double(\n            yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n      }\n#line 4029 \"grammar.c\"\n    break;\n\n  case 127:\n#line 2214 \"grammar.y\"\n      {\n        YR_ARENA_REF ref;\n\n        int result = yr_arena_write_data(\n            compiler->arena,\n            YR_SZ_POOL,\n            (yyvsp[0].sized_string),\n            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),\n            &ref);\n\n        yr_free((yyvsp[0].sized_string));\n\n        if (result == ERROR_SUCCESS)\n          result = yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_PUSH,\n              yr_arena_ref_to_ptr(compiler->arena, &ref),\n              NULL,\n              NULL);\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_STRING;\n        (yyval.expression).value.sized_string_ref = ref;\n      }\n#line 4059 \"grammar.c\"\n    break;\n\n  case 128:\n#line 2240 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[0].c_string), OP_COUNT, YR_UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = YR_UNDEFINED;\n      }\n#line 4075 \"grammar.c\"\n    break;\n\n  case 129:\n#line 2252 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[-3].c_string), OP_OFFSET, YR_UNDEFINED);\n\n        yr_free((yyvsp[-3].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = YR_UNDEFINED;\n      }\n#line 4091 \"grammar.c\"\n    break;\n\n  case 130:\n#line 2264 \"grammar.y\"\n      {\n        int result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        if (result == ERROR_SUCCESS)\n          result = yr_parser_reduce_string_identifier(\n              yyscanner, (yyvsp[0].c_string), OP_OFFSET, YR_UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = YR_UNDEFINED;\n      }\n#line 4111 \"grammar.c\"\n    break;\n\n  case 131:\n#line 2280 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[-3].c_string), OP_LENGTH, YR_UNDEFINED);\n\n        yr_free((yyvsp[-3].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = YR_UNDEFINED;\n      }\n#line 4127 \"grammar.c\"\n    break;\n\n  case 132:\n#line 2292 \"grammar.y\"\n      {\n        int result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        if (result == ERROR_SUCCESS)\n          result = yr_parser_reduce_string_identifier(\n              yyscanner, (yyvsp[0].c_string), OP_LENGTH, YR_UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = YR_UNDEFINED;\n      }\n#line 4147 \"grammar.c\"\n    break;\n\n  case 133:\n#line 2308 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)\n        {\n          result = yr_parser_emit(\n              yyscanner, OP_OBJ_VALUE, NULL);\n\n          switch((yyvsp[0].expression).value.object->type)\n          {\n            case OBJECT_TYPE_INTEGER:\n              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n              (yyval.expression).value.integer = YR_UNDEFINED;\n              break;\n            case OBJECT_TYPE_FLOAT:\n              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n              break;\n            case OBJECT_TYPE_STRING:\n              (yyval.expression).type = EXPRESSION_TYPE_STRING;\n              (yyval.expression).value.sized_string_ref = YR_ARENA_NULL_REF;\n              break;\n            default:\n              // In a primary expression any identifier that corresponds to an\n              // object must be of type integer, float or string. If \"foobar\" is\n              // either a function, structure, dictionary or array you can not\n              // use it as:\n              //   condition: foobar\n              yr_compiler_set_error_extra_info_fmt(\n                  compiler,\n                  \"wrong usage of identifier \\\"%s\\\"\",\n                  expression_identifier((yyvsp[0].expression)));\n\n              result = ERROR_WRONG_TYPE;\n          }\n        }\n        else\n        {\n          (yyval.expression) = (yyvsp[0].expression);\n        }\n\n        fail_if_error(result);\n      }\n#line 4194 \"grammar.c\"\n    break;\n\n  case 134:\n#line 2351 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, \"-\");\n\n        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == YR_UNDEFINED) ?\n              YR_UNDEFINED : -((yyvsp[0].expression).value.integer);\n          result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n          result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);\n        }\n\n        fail_if_error(result);\n      }\n#line 4219 \"grammar.c\"\n    break;\n\n  case 135:\n#line 2372 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_operation(\n            yyscanner, \"+\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          int64_t i1 = (yyvsp[-2].expression).value.integer;\n          int64_t i2 = (yyvsp[0].expression).value.integer;\n\n          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&\n              (\n                (i2 > 0 && i1 > INT64_MAX - i2) ||\n                (i2 < 0 && i1 < INT64_MIN - i2)\n              ))\n          {\n            yr_compiler_set_error_extra_info_fmt(\n                compiler, \"%\" PRId64 \" + %\" PRId64, i1, i2);\n\n            result = ERROR_INTEGER_OVERFLOW;\n          }\n          else\n          {\n            (yyval.expression).value.integer = OPERATION(+, i1, i2);\n            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          }\n        }\n        else\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n        }\n\n        fail_if_error(result);\n      }\n#line 4258 \"grammar.c\"\n    break;\n\n  case 136:\n#line 2407 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_operation(\n            yyscanner, \"-\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          int64_t i1 = (yyvsp[-2].expression).value.integer;\n          int64_t i2 = (yyvsp[0].expression).value.integer;\n\n          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&\n              (\n                (i2 < 0 && i1 > INT64_MAX + i2) ||\n                (i2 > 0 && i1 < INT64_MIN + i2)\n              ))\n          {\n            yr_compiler_set_error_extra_info_fmt(\n                compiler, \"%\" PRId64 \" - %\" PRId64, i1, i2);\n\n            result = ERROR_INTEGER_OVERFLOW;\n          }\n          else\n          {\n            (yyval.expression).value.integer = OPERATION(-, i1, i2);\n            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          }\n        }\n        else\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n        }\n\n        fail_if_error(result);\n      }\n#line 4297 \"grammar.c\"\n    break;\n\n  case 137:\n#line 2442 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_operation(\n            yyscanner, \"*\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          int64_t i1 = (yyvsp[-2].expression).value.integer;\n          int64_t i2 = (yyvsp[0].expression).value.integer;\n\n          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&\n              (\n                i2 != 0 && llabs(i1) > INT64_MAX / llabs(i2)\n              ))\n          {\n            yr_compiler_set_error_extra_info_fmt(\n                compiler, \"%\" PRId64 \" * %\" PRId64, i1, i2);\n\n            result = ERROR_INTEGER_OVERFLOW;\n          }\n          else\n          {\n            (yyval.expression).value.integer = OPERATION(*, i1, i2);\n            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          }\n        }\n        else\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n        }\n\n        fail_if_error(result);\n      }\n#line 4335 \"grammar.c\"\n    break;\n\n  case 138:\n#line 2476 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_operation(\n            yyscanner, \"\\\\\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          if ((yyvsp[0].expression).value.integer != 0)\n          {\n            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          }\n          else\n          {\n            result = ERROR_DIVISION_BY_ZERO;\n          }\n        }\n        else\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n        }\n\n        fail_if_error(result);\n      }\n#line 4364 \"grammar.c\"\n    break;\n\n  case 139:\n#line 2501 \"grammar.y\"\n      {\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"%\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"%\");\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_MOD, NULL));\n\n        if ((yyvsp[0].expression).value.integer != 0)\n        {\n          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n          fail_if_error(ERROR_DIVISION_BY_ZERO);\n        }\n      }\n#line 4385 \"grammar.c\"\n    break;\n\n  case 140:\n#line 2518 \"grammar.y\"\n      {\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n      }\n#line 4399 \"grammar.c\"\n    break;\n\n  case 141:\n#line 2528 \"grammar.y\"\n      {\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n      }\n#line 4413 \"grammar.c\"\n    break;\n\n  case 142:\n#line 2538 \"grammar.y\"\n      {\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"|\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"|\");\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n      }\n#line 4427 \"grammar.c\"\n    break;\n\n  case 143:\n#line 2548 \"grammar.y\"\n      {\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"~\");\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == YR_UNDEFINED) ?\n            YR_UNDEFINED : ~((yyvsp[0].expression).value.integer);\n      }\n#line 4441 \"grammar.c\"\n    break;\n\n  case 144:\n#line 2558 \"grammar.y\"\n      {\n        int result;\n\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\n\n        result = yr_parser_emit(yyscanner, OP_SHL, NULL);\n\n        if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer < 0)\n          result = ERROR_INVALID_OPERAND;\n        else if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer >= 64)\n          (yyval.expression).value.integer = 0;\n        else\n          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n\n        fail_if_error(result);\n      }\n#line 4465 \"grammar.c\"\n    break;\n\n  case 145:\n#line 2578 \"grammar.y\"\n      {\n        int result;\n\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \">>\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \">>\");\n\n        result = yr_parser_emit(yyscanner, OP_SHR, NULL);\n\n        if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer < 0)\n          result = ERROR_INVALID_OPERAND;\n        else if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer >= 64)\n          (yyval.expression).value.integer = 0;\n        else\n          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n\n        fail_if_error(result);\n      }\n#line 4489 \"grammar.c\"\n    break;\n\n  case 146:\n#line 2598 \"grammar.y\"\n      {\n        (yyval.expression) = (yyvsp[0].expression);\n      }\n#line 4497 \"grammar.c\"\n    break;\n\n\n#line 4501 \"grammar.c\"\n\n      default: break;\n    }\n  /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n  {\n    const int yylhs = yyr1[yyn] - YYNTOKENS;\n    const int yyi = yypgoto[yylhs] + *yyssp;\n    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp\n               ? yytable[yyi]\n               : yydefgoto[yylhs]);\n  }\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (yyscanner, compiler, YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        int yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = YY_CAST (char *, YYSTACK_ALLOC (YY_CAST (YYSIZE_T, yymsg_alloc)));\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (yyscanner, compiler, yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n         error, discard it.  */\n\n      if (yychar <= YYEOF)\n        {\n          /* Return failure if at end of input.  */\n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval, yyscanner, compiler);\n          yychar = YYEMPTY;\n        }\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n  /* Pacify compilers when the user code never invokes YYERROR and the\n     label yyerrorlab therefore never appears in user code.  */\n  if (0)\n    YYERROR;\n\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYTERROR;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n        YYABORT;\n\n\n      yydestruct (\"Error: popping\",\n                  yystos[yystate], yyvsp, yyscanner, compiler);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (yyscanner, compiler, YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\n\n/*-----------------------------------------------------.\n| yyreturn -- parsing is finished, return the result.  |\n`-----------------------------------------------------*/\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval, yyscanner, compiler);\n    }\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  yystos[+*yyssp], yyvsp, yyscanner, compiler);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n#endif\n  return yyresult;\n}",
        "begin_line": 1603,
        "end_line": 4731,
        "is_bug": false
    },
    {
        "name": "libyara.grammar.yydestruct#1487",
        "src_path": "libyara/grammar.c",
        "class_name": "libyara.grammar",
        "signature": "libyara.grammar.yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, YR_COMPILER* compiler)",
        "snippet": "static void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, YR_COMPILER* compiler)\n{\n  YYUSE (yyvaluep);\n  YYUSE (yyscanner);\n  YYUSE (compiler);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  switch (yytype)\n    {\n    case 11: /* \"identifier\"  */\n#line 267 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1504 \"grammar.c\"\n        break;\n\n    case 12: /* \"string identifier\"  */\n#line 271 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1510 \"grammar.c\"\n        break;\n\n    case 13: /* \"string count\"  */\n#line 268 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1516 \"grammar.c\"\n        break;\n\n    case 14: /* \"string offset\"  */\n#line 269 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1522 \"grammar.c\"\n        break;\n\n    case 15: /* \"string length\"  */\n#line 270 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1528 \"grammar.c\"\n        break;\n\n    case 16: /* \"string identifier with wildcard\"  */\n#line 272 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1534 \"grammar.c\"\n        break;\n\n    case 20: /* \"text string\"  */\n#line 273 \"grammar.y\"\n            { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }\n#line 1540 \"grammar.c\"\n        break;\n\n    case 21: /* \"hex string\"  */\n#line 274 \"grammar.y\"\n            { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }\n#line 1546 \"grammar.c\"\n        break;\n\n    case 22: /* \"regular expression\"  */\n#line 275 \"grammar.y\"\n            { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }\n#line 1552 \"grammar.c\"\n        break;\n\n    case 96: /* string_modifiers  */\n#line 288 \"grammar.y\"\n            {\n  if (((*yyvaluep).modifier).alphabet != NULL)\n  {\n    yr_free(((*yyvaluep).modifier).alphabet);\n    ((*yyvaluep).modifier).alphabet = NULL;\n  }\n}\n#line 1564 \"grammar.c\"\n        break;\n\n    case 97: /* string_modifier  */\n#line 280 \"grammar.y\"\n            {\n  if (((*yyvaluep).modifier).alphabet != NULL)\n  {\n    yr_free(((*yyvaluep).modifier).alphabet);\n    ((*yyvaluep).modifier).alphabet = NULL;\n  }\n}\n#line 1576 \"grammar.c\"\n        break;\n\n    case 103: /* arguments  */\n#line 277 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1582 \"grammar.c\"\n        break;\n\n    case 104: /* arguments_list  */\n#line 278 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1588 \"grammar.c\"\n        break;\n\n      default:\n        break;\n    }\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}",
        "begin_line": 1487,
        "end_line": 1594,
        "is_bug": false
    },
    {
        "name": "libyara.grammar.yysyntax_error#1348",
        "src_path": "libyara/grammar.c",
        "class_name": "libyara.grammar",
        "signature": "libyara.grammar.yysyntax_error (YYPTRDIFF_T *yymsg_alloc, char **yymsg, yy_state_t *yyssp, int yytoken)",
        "snippet": "static int\nyysyntax_error (YYPTRDIFF_T *yymsg_alloc, char **yymsg,\n                yy_state_t *yyssp, int yytoken)\n{\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *yyformat = YY_NULLPTR;\n  /* Arguments of yyformat: reported tokens (one for the \"unexpected\",\n     one per \"expected\"). */\n  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Actual size of YYARG. */\n  int yycount = 0;\n  /* Cumulated lengths of YYARG.  */\n  YYPTRDIFF_T yysize = 0;\n\n  /* There are many possibilities here to consider:\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in yychar) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated yychar.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (yytoken != YYEMPTY)\n    {\n      int yyn = yypact[+*yyssp];\n      YYPTRDIFF_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);\n      yysize = yysize0;\n      yyarg[yycount++] = yytname[yytoken];\n      if (!yypact_value_is_default (yyn))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int yyxbegin = yyn < 0 ? -yyn : 0;\n          /* Stay within bounds of both yycheck and yytname.  */\n          int yychecklim = YYLAST - yyn + 1;\n          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n          int yyx;\n\n          for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR\n                && !yytable_value_is_error (yytable[yyx + yyn]))\n              {\n                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    yycount = 1;\n                    yysize = yysize0;\n                    break;\n                  }\n                yyarg[yycount++] = yytname[yyx];\n                {\n                  YYPTRDIFF_T yysize1\n                    = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);\n                  if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)\n                    yysize = yysize1;\n                  else\n                    return 2;\n                }\n              }\n        }\n    }\n\n  switch (yycount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        yyformat = S;                       \\\n      break\n    default: /* Avoid compiler warnings. */\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  {\n    /* Don't count the \"%s\"s in the final size, but reserve room for\n       the terminator.  */\n    YYPTRDIFF_T yysize1 = yysize + (yystrlen (yyformat) - 2 * yycount) + 1;\n    if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)\n      yysize = yysize1;\n    else\n      return 2;\n  }\n\n  if (*yymsg_alloc < yysize)\n    {\n      *yymsg_alloc = 2 * yysize;\n      if (! (yysize <= *yymsg_alloc\n             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *yyp = *yymsg;\n    int yyi = 0;\n    while ((*yyp = *yyformat) != '\\0')\n      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)\n        {\n          yyp += yytnamerr (yyp, yyarg[yyi++]);\n          yyformat += 2;\n        }\n      else\n        {\n          ++yyp;\n          ++yyformat;\n        }\n  }\n  return 0;\n}",
        "begin_line": 1348,
        "end_line": 1480,
        "is_bug": false
    },
    {
        "name": "libyara.grammar.yytnamerr#1297",
        "src_path": "libyara/grammar.c",
        "class_name": "libyara.grammar",
        "signature": "libyara.grammar.yytnamerr (char *yyres, const char *yystr)",
        "snippet": "static YYPTRDIFF_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYPTRDIFF_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n        switch (*++yyp)\n          {\n          case '\\'':\n          case ',':\n            goto do_not_strip_quotes;\n\n          case '\\\\':\n            if (*++yyp != '\\\\')\n              goto do_not_strip_quotes;\n            else\n              goto append;\n\n          append:\n          default:\n            if (yyres)\n              yyres[yyn] = *yyp;\n            yyn++;\n            break;\n\n          case '\"':\n            if (yyres)\n              yyres[yyn] = '\\0';\n            return yyn;\n          }\n    do_not_strip_quotes: ;\n    }\n\n  if (yyres)\n    return yystpcpy (yyres, yystr) - yyres;\n  else\n    return yystrlen (yystr);\n}",
        "begin_line": 1297,
        "end_line": 1337,
        "is_bug": false
    },
    {
        "name": "libyara.hex_grammar.hex_yyparse#1162",
        "src_path": "libyara/hex_grammar.c",
        "class_name": "libyara.hex_grammar",
        "signature": "libyara.hex_grammar.)",
        "snippet": "int\nyyparse (void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)\n{\n/* The lookahead symbol.  */\nint yychar;\n\n\n/* The semantic value of the lookahead symbol.  */\n/* Default value used for initialization, for pacifying older GCCs\n   or non-GCC compilers.  */\nYY_INITIAL_VALUE (static YYSTYPE yyval_default;)\nYYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n\n    /* Number of syntax errors so far.  */\n    int yynerrs;\n\n    yy_state_fast_t yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yy_state_t yyssa[YYINITDEPTH];\n    yy_state_t *yyss;\n    yy_state_t *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYPTRDIFF_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYPTRDIFF_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n  goto yysetstate;\n\n\n/*------------------------------------------------------------.\n| yynewstate -- push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\nyynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n\n/*--------------------------------------------------------------------.\n| yysetstate -- set current state (the top of the stack) to yystate.  |\n`--------------------------------------------------------------------*/\nyysetstate:\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);\n  YY_IGNORE_USELESS_CAST_BEGIN\n  *yyssp = YY_CAST (yy_state_t, yystate);\n  YY_IGNORE_USELESS_CAST_END\n\n  if (yyss + yystacksize - 1 <= yyssp)\n#if !defined yyoverflow && !defined YYSTACK_RELOCATE\n    goto yyexhaustedlab;\n#else\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYPTRDIFF_T yysize = yyssp - yyss + 1;\n\n# if defined yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        yy_state_t *yyss1 = yyss;\n        YYSTYPE *yyvs1 = yyvs;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * YYSIZEOF (*yyssp),\n                    &yyvs1, yysize * YYSIZEOF (*yyvsp),\n                    &yystacksize);\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n# else /* defined YYSTACK_RELOCATE */\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yy_state_t *yyss1 = yyss;\n        union yyalloc *yyptr =\n          YY_CAST (union yyalloc *,\n                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n# undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YY_IGNORE_USELESS_CAST_BEGIN\n      YYDPRINTF ((stderr, \"Stack size increased to %ld\\n\",\n                  YY_CAST (long, yystacksize)));\n      YY_IGNORE_USELESS_CAST_END\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex (&yylval, yyscanner, lex_env);\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n  case 2:\n#line 106 \"hex_grammar.y\"\n      {\n        RE_AST* re_ast = yyget_extra(yyscanner);\n        re_ast->root_node = (yyvsp[-1].re_node);\n      }\n#line 1424 \"hex_grammar.c\"\n    break;\n\n  case 3:\n#line 115 \"hex_grammar.y\"\n      {\n        (yyval.re_node) = (yyvsp[0].re_node);\n      }\n#line 1432 \"hex_grammar.c\"\n    break;\n\n  case 4:\n#line 119 \"hex_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT);\n\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[0].re_node));\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        yr_re_node_append_child((yyval.re_node), (yyvsp[-1].re_node));\n        yr_re_node_append_child((yyval.re_node), (yyvsp[0].re_node));\n      }\n#line 1448 \"hex_grammar.c\"\n    break;\n\n  case 5:\n#line 131 \"hex_grammar.y\"\n      {\n        yr_re_node_append_child((yyvsp[-1].re_node), (yyvsp[0].re_node));\n        yr_re_node_prepend_child((yyvsp[-1].re_node), (yyvsp[-2].re_node));\n\n        (yyval.re_node) = (yyvsp[-1].re_node);\n      }\n#line 1459 \"hex_grammar.c\"\n    break;\n\n  case 6:\n#line 142 \"hex_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT);\n\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[0].re_node));\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        yr_re_node_append_child((yyval.re_node), (yyvsp[0].re_node));\n      }\n#line 1472 \"hex_grammar.c\"\n    break;\n\n  case 7:\n#line 151 \"hex_grammar.y\"\n      {\n        yr_re_node_append_child((yyvsp[-1].re_node), (yyvsp[0].re_node));\n        (yyval.re_node) = (yyvsp[-1].re_node);\n      }\n#line 1481 \"hex_grammar.c\"\n    break;\n\n  case 8:\n#line 160 \"hex_grammar.y\"\n      {\n        (yyval.re_node) = (yyvsp[0].re_node);\n      }\n#line 1489 \"hex_grammar.c\"\n    break;\n\n  case 9:\n#line 164 \"hex_grammar.y\"\n      {\n        (yyval.re_node) = (yyvsp[0].re_node);\n        (yyval.re_node)->greedy = false;\n      }\n#line 1498 \"hex_grammar.c\"\n    break;\n\n  case 10:\n#line 173 \"hex_grammar.y\"\n      {\n        (yyval.re_node) = (yyvsp[0].re_node);\n      }\n#line 1506 \"hex_grammar.c\"\n    break;\n\n  case 11:\n#line 177 \"hex_grammar.y\"\n      {\n        lex_env->inside_or++;\n      }\n#line 1514 \"hex_grammar.c\"\n    break;\n\n  case 12:\n#line 181 \"hex_grammar.y\"\n      {\n        (yyval.re_node) = (yyvsp[-1].re_node);\n        lex_env->inside_or--;\n      }\n#line 1523 \"hex_grammar.c\"\n    break;\n\n  case 13:\n#line 190 \"hex_grammar.y\"\n      {\n        if ((yyvsp[-1].integer) <= 0)\n        {\n          yyerror(yyscanner, lex_env, \"invalid jump length\");\n          YYABORT;\n        }\n\n        if (lex_env->inside_or && (yyvsp[-1].integer) > YR_STRING_CHAINING_THRESHOLD)\n        {\n          yyerror(yyscanner, lex_env, \"jumps over \"\n              STR(YR_STRING_CHAINING_THRESHOLD)\n              \" not allowed inside alternation (|)\");\n          YYABORT;\n        }\n\n        // A jump of one is equivalent to ??\n        if ((yyvsp[-1].integer) == 1)\n        {\n          (yyval.re_node) = yr_re_node_create(RE_NODE_MASKED_LITERAL);\n\n          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n          (yyval.re_node)->value = 0x00;\n          (yyval.re_node)->mask = 0x00;\n        }\n        else\n        {\n          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);\n\n          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n          (yyval.re_node)->start = (int) (yyvsp[-1].integer);\n          (yyval.re_node)->end = (int) (yyvsp[-1].integer);\n        }\n      }\n#line 1563 \"hex_grammar.c\"\n    break;\n\n  case 14:\n#line 226 \"hex_grammar.y\"\n      {\n        if (lex_env->inside_or &&\n            ((yyvsp[-3].integer) > YR_STRING_CHAINING_THRESHOLD ||\n             (yyvsp[-1].integer) > YR_STRING_CHAINING_THRESHOLD) )\n        {\n          yyerror(yyscanner, lex_env, \"jumps over \"\n              STR(YR_STRING_CHAINING_THRESHOLD)\n              \" not allowed inside alternation (|)\");\n\n          YYABORT;\n        }\n\n        if ((yyvsp[-3].integer) < 0 || (yyvsp[-1].integer) < 0)\n        {\n          yyerror(yyscanner, lex_env, \"invalid negative jump length\");\n          YYABORT;\n        }\n\n        if ((yyvsp[-3].integer) > (yyvsp[-1].integer))\n        {\n          yyerror(yyscanner, lex_env, \"invalid jump range\");\n          YYABORT;\n        }\n\n        (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        (yyval.re_node)->start = (int) (yyvsp[-3].integer);\n        (yyval.re_node)->end = (int) (yyvsp[-1].integer);\n      }\n#line 1599 \"hex_grammar.c\"\n    break;\n\n  case 15:\n#line 258 \"hex_grammar.y\"\n      {\n        if (lex_env->inside_or)\n        {\n          yyerror(yyscanner, lex_env,\n              \"unbounded jumps not allowed inside alternation (|)\");\n          YYABORT;\n        }\n\n        if ((yyvsp[-2].integer) < 0)\n        {\n          yyerror(yyscanner, lex_env, \"invalid negative jump length\");\n          YYABORT;\n        }\n\n        (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        (yyval.re_node)->start = (int) (yyvsp[-2].integer);\n        (yyval.re_node)->end = INT_MAX;\n      }\n#line 1625 \"hex_grammar.c\"\n    break;\n\n  case 16:\n#line 280 \"hex_grammar.y\"\n      {\n        if (lex_env->inside_or)\n        {\n          yyerror(yyscanner, lex_env,\n              \"unbounded jumps not allowed inside alternation (|)\");\n          YYABORT;\n        }\n\n        (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        (yyval.re_node)->start = 0;\n        (yyval.re_node)->end = INT_MAX;\n      }\n#line 1645 \"hex_grammar.c\"\n    break;\n\n  case 17:\n#line 300 \"hex_grammar.y\"\n      {\n          (yyval.re_node) = (yyvsp[0].re_node);\n      }\n#line 1653 \"hex_grammar.c\"\n    break;\n\n  case 18:\n#line 304 \"hex_grammar.y\"\n      {\n        mark_as_not_fast_regexp();\n\n        (yyval.re_node) = yr_re_node_create(RE_NODE_ALT);\n\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[0].re_node));\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        yr_re_node_append_child((yyval.re_node), (yyvsp[-2].re_node));\n        yr_re_node_append_child((yyval.re_node), (yyvsp[0].re_node));\n      }\n#line 1671 \"hex_grammar.c\"\n    break;\n\n  case 19:\n#line 321 \"hex_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_LITERAL);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        (yyval.re_node)->value = (int) (yyvsp[0].integer);\n        (yyval.re_node)->mask = 0xFF;\n      }\n#line 1684 \"hex_grammar.c\"\n    break;\n\n  case 20:\n#line 330 \"hex_grammar.y\"\n      {\n        uint8_t mask = (uint8_t) ((yyvsp[0].integer) >> 8);\n\n        if (mask == 0x00)\n        {\n          (yyval.re_node) = yr_re_node_create(RE_NODE_ANY);\n\n          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n          (yyval.re_node)->value = 0x00;\n          (yyval.re_node)->mask = 0x00;\n        }\n        else\n        {\n          (yyval.re_node) = yr_re_node_create(RE_NODE_MASKED_LITERAL);\n\n          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n          (yyval.re_node)->value = (yyvsp[0].integer) & 0xFF;\n          (yyval.re_node)->mask = mask;\n        }\n      }\n#line 1711 \"hex_grammar.c\"\n    break;\n\n\n#line 1715 \"hex_grammar.c\"\n\n      default: break;\n    }\n  /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n  {\n    const int yylhs = yyr1[yyn] - YYNTOKENS;\n    const int yyi = yypgoto[yylhs] + *yyssp;\n    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp\n               ? yytable[yyi]\n               : yydefgoto[yylhs]);\n  }\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (yyscanner, lex_env, YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        int yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = YY_CAST (char *, YYSTACK_ALLOC (YY_CAST (YYSIZE_T, yymsg_alloc)));\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (yyscanner, lex_env, yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n         error, discard it.  */\n\n      if (yychar <= YYEOF)\n        {\n          /* Return failure if at end of input.  */\n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval, yyscanner, lex_env);\n          yychar = YYEMPTY;\n        }\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n  /* Pacify compilers when the user code never invokes YYERROR and the\n     label yyerrorlab therefore never appears in user code.  */\n  if (0)\n    YYERROR;\n\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYTERROR;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n        YYABORT;\n\n\n      yydestruct (\"Error: popping\",\n                  yystos[yystate], yyvsp, yyscanner, lex_env);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (yyscanner, lex_env, YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\n\n/*-----------------------------------------------------.\n| yyreturn -- parsing is finished, return the result.  |\n`-----------------------------------------------------*/\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval, yyscanner, lex_env);\n    }\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  yystos[+*yyssp], yyvsp, yyscanner, lex_env);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n#endif\n  return yyresult;\n}",
        "begin_line": 1162,
        "end_line": 1945,
        "is_bug": false
    },
    {
        "name": "libyara.hex_grammar.yydestruct#1094",
        "src_path": "libyara/hex_grammar.c",
        "class_name": "libyara.hex_grammar",
        "signature": "libyara.hex_grammar.yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)",
        "snippet": "static void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)\n{\n  YYUSE (yyvaluep);\n  YYUSE (yyscanner);\n  YYUSE (lex_env);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  switch (yytype)\n    {\n    case 16: /* tokens  */\n#line 94 \"hex_grammar.y\"\n            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }\n#line 1111 \"hex_grammar.c\"\n        break;\n\n    case 17: /* token_sequence  */\n#line 95 \"hex_grammar.y\"\n            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }\n#line 1117 \"hex_grammar.c\"\n        break;\n\n    case 18: /* token_or_range  */\n#line 96 \"hex_grammar.y\"\n            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }\n#line 1123 \"hex_grammar.c\"\n        break;\n\n    case 19: /* token  */\n#line 97 \"hex_grammar.y\"\n            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }\n#line 1129 \"hex_grammar.c\"\n        break;\n\n    case 21: /* range  */\n#line 100 \"hex_grammar.y\"\n            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }\n#line 1135 \"hex_grammar.c\"\n        break;\n\n    case 22: /* alternatives  */\n#line 99 \"hex_grammar.y\"\n            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }\n#line 1141 \"hex_grammar.c\"\n        break;\n\n    case 23: /* byte  */\n#line 98 \"hex_grammar.y\"\n            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }\n#line 1147 \"hex_grammar.c\"\n        break;\n\n      default:\n        break;\n    }\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}",
        "begin_line": 1094,
        "end_line": 1153,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yy_delete_buffer#1771",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "void yy_delete_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tyyfree( (void *) b->yy_ch_buf , yyscanner );\n\n\tyyfree( (void *) b , yyscanner );\n}",
        "begin_line": 1771,
        "end_line": 1785,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yy_load_buffer_state#1728",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "static void yy_load_buffer_state  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\tyyg->yytext_ptr = yyg->yy_c_buf_p = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;\n\tyyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;\n\tyyg->yy_hold_char = *yyg->yy_c_buf_p;\n}",
        "begin_line": 1728,
        "end_line": 1735,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yy_scan_buffer#1951",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn NULL;\n\n\tb = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n\n\tb->yy_buf_size = (int) (size - 2);\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = NULL;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tyy_switch_to_buffer( b , yyscanner );\n\n\treturn b;\n}",
        "begin_line": 1951,
        "end_line": 1978,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yy_scan_bytes#2001",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len , yyscan_t yyscanner)\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = (yy_size_t) (_yybytes_len + 2);\n\tbuf = (char *) yyalloc( n , yyscanner );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = yy_scan_buffer( buf, n , yyscanner);\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}",
        "begin_line": 2001,
        "end_line": 2029,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yy_scan_string#1988",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "YY_BUFFER_STATE yy_scan_string (const char * yystr , yyscan_t yyscanner)\n{\n    \n\treturn yy_scan_bytes( yystr, (int) strlen(yystr) , yyscanner);\n}",
        "begin_line": 1988,
        "end_line": 1992,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yy_switch_to_buffer#1696",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tyypop_buffer_state();\n\t *\t\tyypush_buffer_state(new_buffer);\n     */\n\tyyensure_buffer_stack (yyscanner);\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*yyg->yy_c_buf_p = yyg->yy_hold_char;\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tyy_load_buffer_state( yyscanner );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (yywrap()) processing, but the only time this flag\n\t * is looked at is after yywrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\tyyg->yy_did_buffer_switch_on_eof = 1;\n}",
        "begin_line": 1696,
        "end_line": 1726,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yyalloc#2368",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "void *yyalloc (yy_size_t  size , yyscan_t yyscanner)\n{\n\tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\t(void)yyg;\n\treturn malloc(size);\n}",
        "begin_line": 2368,
        "end_line": 2373,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yyensure_buffer_stack#1901",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "static void yyensure_buffer_stack (yyscan_t yyscanner)\n{\n\tyy_size_t num_to_alloc;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tif (!yyg->yy_buffer_stack) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\n\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t\tyyg->yy_buffer_stack_top = 0;\n\t\treturn;\n\t}\n\n\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)yyrealloc\n\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t}\n}",
        "begin_line": 1901,
        "end_line": 1943,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yyfree#2390",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "void yyfree (void * ptr , yyscan_t yyscanner)\n{\n\tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\t(void)yyg;\n\tfree( (char *) ptr );\t/* see yyrealloc() for (char *) cast */\n}",
        "begin_line": 2390,
        "end_line": 2395,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yyget_extra#2065",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "YY_EXTRA_TYPE yyget_extra  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    return yyextra;\n}",
        "begin_line": 2065,
        "end_line": 2069,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yylex#998",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.L",
        "snippet": "YY_DECL\n{\n\tyy_state_type yy_current_state;\n\tchar *yy_cp, *yy_bp;\n\tint yy_act;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n    yylval = yylval_param;\n\n\tif ( !yyg->yy_init )\n\t\t{\n\t\tyyg->yy_init = 1;\n\n#ifdef YY_USER_INIT\n\t\tYY_USER_INIT;\n#endif\n\n\t\tif ( ! yyg->yy_start )\n\t\t\tyyg->yy_start = 1;\t/* first start state */\n\n\t\tif ( ! yyin )\n\t\t\tyyin = stdin;\n\n\t\tif ( ! yyout )\n\t\t\tyyout = stdout;\n\n\t\tif ( ! YY_CURRENT_BUFFER ) {\n\t\t\tyyensure_buffer_stack (yyscanner);\n\t\t\tYY_CURRENT_BUFFER_LVALUE =\n\t\t\t\tyy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);\n\t\t}\n\n\t\tyy_load_buffer_state( yyscanner );\n\t\t}\n\n\t{\n#line 95 \"hex_lexer.l\"\n\n\n\n#line 1039 \"hex_lexer.c\"\n\n\twhile ( /*CONSTCOND*/1 )\t\t/* loops until end-of-file is reached */\n\t\t{\n\t\tyy_cp = yyg->yy_c_buf_p;\n\n\t\t/* Support of yytext. */\n\t\t*yy_cp = yyg->yy_hold_char;\n\n\t\t/* yy_bp points to the position in yy_ch_buf of the start of\n\t\t * the current run.\n\t\t */\n\t\tyy_bp = yy_cp;\n\n\t\tyy_current_state = yyg->yy_start;\nyy_match:\n\t\tdo\n\t\t\t{\n\t\t\tYY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;\n\t\t\tif ( yy_accept[yy_current_state] )\n\t\t\t\t{\n\t\t\t\tyyg->yy_last_accepting_state = yy_current_state;\n\t\t\t\tyyg->yy_last_accepting_cpos = yy_cp;\n\t\t\t\t}\n\t\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t\t{\n\t\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\t\tif ( yy_current_state >= 34 )\n\t\t\t\t\tyy_c = yy_meta[yy_c];\n\t\t\t\t}\n\t\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];\n\t\t\t++yy_cp;\n\t\t\t}\n\t\twhile ( yy_current_state != 33 );\n\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\tyy_current_state = yyg->yy_last_accepting_state;\n\nyy_find_action:\n\t\tyy_act = yy_accept[yy_current_state];\n\n\t\tYY_DO_BEFORE_ACTION;\n\n\t\tif ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )\n\t\t\t{\n\t\t\tint yyl;\n\t\t\tfor ( yyl = 0; yyl < yyleng; ++yyl )\n\t\t\t\tif ( yytext[yyl] == '\\n' )\n\t\t\t\t\t\n    do{ yylineno++;\n        yycolumn=0;\n    }while(0)\n;\n\t\t\t}\n\ndo_action:\t/* This label is used only to access EOF actions. */\n\n\t\tswitch ( yy_act )\n\t{ /* beginning of action switch */\n\t\t\tcase 0: /* must back up */\n\t\t\t/* undo the effects of YY_DO_BEFORE_ACTION */\n\t\t\t*yy_cp = yyg->yy_hold_char;\n\t\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\t\tyy_current_state = yyg->yy_last_accepting_state;\n\t\t\tgoto yy_find_action;\n\ncase 1:\nYY_RULE_SETUP\n#line 98 \"hex_lexer.l\"\n{\n\n  yylval->integer = xtoi(yytext);\n  return _BYTE_;\n}\n\tYY_BREAK\ncase 2:\nYY_RULE_SETUP\n#line 104 \"hex_lexer.l\"\n{\n\n  yytext[1] = '0'; // replace ? by 0\n  yylval->integer = xtoi(yytext) | 0xF000 ;\n  return _MASKED_BYTE_;\n}\n\tYY_BREAK\ncase 3:\nYY_RULE_SETUP\n#line 111 \"hex_lexer.l\"\n{\n\n  yytext[0] = '0'; // replace ? by 0\n  yylval->integer = xtoi(yytext) | 0x0F00 ;\n  return _MASKED_BYTE_;\n}\n\tYY_BREAK\ncase 4:\nYY_RULE_SETUP\n#line 118 \"hex_lexer.l\"\n{\n\n  yylval->integer = 0x0000;\n  return _MASKED_BYTE_;\n}\n\tYY_BREAK\ncase 5:\nYY_RULE_SETUP\n#line 124 \"hex_lexer.l\"\n{\n\n  BEGIN(range);\n  return yytext[0];\n}\n\tYY_BREAK\ncase 6:\nYY_RULE_SETUP\n#line 130 \"hex_lexer.l\"\n{\n\n  BEGIN(comment);\n}\n\tYY_BREAK\ncase 7:\nYY_RULE_SETUP\n#line 135 \"hex_lexer.l\"\n{\n\n  BEGIN(INITIAL);\n}\n\tYY_BREAK\ncase 8:\n/* rule 8 can match eol */\nYY_RULE_SETUP\n#line 140 \"hex_lexer.l\"\n// skip comments\n\tYY_BREAK\ncase 9:\nYY_RULE_SETUP\n#line 142 \"hex_lexer.l\"\n// skip single-line comments\n\tYY_BREAK\ncase 10:\nYY_RULE_SETUP\n#line 144 \"hex_lexer.l\"\n{\n\n  return yytext[0];\n}\n\tYY_BREAK\ncase 11:\nYY_RULE_SETUP\n#line 149 \"hex_lexer.l\"\n{\n\n  yylval->integer = atoi(yytext);\n  return _NUMBER_;\n}\n\tYY_BREAK\ncase 12:\nYY_RULE_SETUP\n#line 155 \"hex_lexer.l\"\n{\n\n  BEGIN(INITIAL);\n  return yytext[0];\n}\n\tYY_BREAK\ncase 13:\n/* rule 13 can match eol */\nYY_RULE_SETUP\n#line 161 \"hex_lexer.l\"\n// skip whitespaces\n\tYY_BREAK\ncase 14:\nYY_RULE_SETUP\n#line 163 \"hex_lexer.l\"\n{\n\n  yyerror(yyscanner, lex_env, \"invalid character in hex string jump\");\n  yyterminate();\n}\n\tYY_BREAK\ncase 15:\n/* rule 15 can match eol */\nYY_RULE_SETUP\n#line 169 \"hex_lexer.l\"\n// skip whitespaces\n\tYY_BREAK\ncase 16:\nYY_RULE_SETUP\n#line 171 \"hex_lexer.l\"\n{        // pass valid characters to the parser\n\n  return yytext[0];\n}\n\tYY_BREAK\ncase 17:\nYY_RULE_SETUP\n#line 176 \"hex_lexer.l\"\n{               // reject all other characters\n\n  yyerror(yyscanner, lex_env, \"invalid character in hex string\");\n  yyterminate();\n}\n\tYY_BREAK\ncase 18:\nYY_RULE_SETUP\n#line 182 \"hex_lexer.l\"\nECHO;\n\tYY_BREAK\n#line 1247 \"hex_lexer.c\"\ncase YY_STATE_EOF(INITIAL):\ncase YY_STATE_EOF(comment):\ncase YY_STATE_EOF(range):\n\tyyterminate();\n\n\tcase YY_END_OF_BUFFER:\n\t\t{\n\t\t/* Amount of text matched not including the EOB char. */\n\t\tint yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;\n\n\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */\n\t\t*yy_cp = yyg->yy_hold_char;\n\t\tYY_RESTORE_YY_MORE_OFFSET\n\n\t\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )\n\t\t\t{\n\t\t\t/* We're scanning a new file or input source.  It's\n\t\t\t * possible that this happened because the user\n\t\t\t * just pointed yyin at a new source and called\n\t\t\t * yylex().  If so, then we have to assure\n\t\t\t * consistency between YY_CURRENT_BUFFER and our\n\t\t\t * globals.  Here is the right place to do so, because\n\t\t\t * this is the first action (other than possibly a\n\t\t\t * back-up) that will match for the new input source.\n\t\t\t */\n\t\t\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;\n\t\t\t}\n\n\t\t/* Note that here we test for yy_c_buf_p \"<=\" to the position\n\t\t * of the first EOB in the buffer, since yy_c_buf_p will\n\t\t * already have been incremented past the NUL character\n\t\t * (since all states make transitions on EOB to the\n\t\t * end-of-buffer state).  Contrast this with the test\n\t\t * in input().\n\t\t */\n\t\tif ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )\n\t\t\t{ /* This was really a NUL. */\n\t\t\tyy_state_type yy_next_state;\n\n\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;\n\n\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t/* Okay, we're now positioned to make the NUL\n\t\t\t * transition.  We couldn't have\n\t\t\t * yy_get_previous_state() go ahead and do it\n\t\t\t * for us because it doesn't know how to deal\n\t\t\t * with the possibility of jamming (and we don't\n\t\t\t * want to build jamming into it because then it\n\t\t\t * will run more slowly).\n\t\t\t */\n\n\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);\n\n\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\n\t\t\tif ( yy_next_state )\n\t\t\t\t{\n\t\t\t\t/* Consume the NUL. */\n\t\t\t\tyy_cp = ++yyg->yy_c_buf_p;\n\t\t\t\tyy_current_state = yy_next_state;\n\t\t\t\tgoto yy_match;\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\t\t\tyy_current_state = yyg->yy_last_accepting_state;\n\t\t\t\tgoto yy_find_action;\n\t\t\t\t}\n\t\t\t}\n\n\t\telse switch ( yy_get_next_buffer( yyscanner ) )\n\t\t\t{\n\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t{\n\t\t\t\tyyg->yy_did_buffer_switch_on_eof = 0;\n\n\t\t\t\tif ( yywrap( yyscanner ) )\n\t\t\t\t\t{\n\t\t\t\t\t/* Note: because we've taken care in\n\t\t\t\t\t * yy_get_next_buffer() to have set up\n\t\t\t\t\t * yytext, we can now set up\n\t\t\t\t\t * yy_c_buf_p so that if some total\n\t\t\t\t\t * hoser (like flex itself) wants to\n\t\t\t\t\t * call the scanner after we return the\n\t\t\t\t\t * YY_NULL, it'll still work - another\n\t\t\t\t\t * YY_NULL will get returned.\n\t\t\t\t\t */\n\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;\n\n\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);\n\t\t\t\t\tgoto do_action;\n\t\t\t\t\t}\n\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\tyyg->yy_c_buf_p =\n\t\t\t\t\tyyg->yytext_ptr + yy_amount_of_matched_text;\n\n\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t\tyy_cp = yyg->yy_c_buf_p;\n\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_match;\n\n\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\tyyg->yy_c_buf_p =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];\n\n\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t\tyy_cp = yyg->yy_c_buf_p;\n\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_find_action;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\tYY_FATAL_ERROR(\n\t\t\t\"fatal flex scanner internal error--no action found\" );\n\t} /* end of action switch */\n\t\t} /* end of scanning one token */\n\t} /* end of user's declarations */\n}",
        "begin_line": 998,
        "end_line": 1381,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yylex_destroy#2312",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "int yylex_destroy  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tyy_delete_buffer( YY_CURRENT_BUFFER , yyscanner );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tyypop_buffer_state(yyscanner);\n\t}\n\n\t/* Destroy the stack itself. */\n\tyyfree(yyg->yy_buffer_stack , yyscanner);\n\tyyg->yy_buffer_stack = NULL;\n\n    /* Destroy the start condition stack. */\n        yyfree( yyg->yy_start_stack , yyscanner );\n        yyg->yy_start_stack = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * yylex() is called, initialization will occur. */\n    yy_init_globals( yyscanner);\n\n    /* Destroy the main struct (reentrant only). */\n    yyfree ( yyscanner , yyscanner );\n    yyscanner = NULL;\n    return 0;\n}",
        "begin_line": 2312,
        "end_line": 2339,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yylex_init#2224",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "int yylex_init(yyscan_t* ptr_yy_globals)\n{\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n\n    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), NULL );\n\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n\n    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n\n    return yy_init_globals ( *ptr_yy_globals );\n}",
        "begin_line": 2224,
        "end_line": 2242,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yypop_buffer_state#1881",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "void yypop_buffer_state (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tyy_delete_buffer(YY_CURRENT_BUFFER , yyscanner);\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif (yyg->yy_buffer_stack_top > 0)\n\t\t--yyg->yy_buffer_stack_top;\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tyy_load_buffer_state( yyscanner );\n\t\tyyg->yy_did_buffer_switch_on_eof = 1;\n\t}\n}",
        "begin_line": 1881,
        "end_line": 1896,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yyset_extra#2138",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "void yyset_extra (YY_EXTRA_TYPE  user_defined , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    yyextra = user_defined ;\n}",
        "begin_line": 2138,
        "end_line": 2142,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.yy_get_next_buffer#1390",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.yy_get_next_buffer (yyscan_t yyscanner)",
        "snippet": "static int yy_get_next_buffer (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tchar *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tchar *source = yyg->yytext_ptr;\n\tint number_to_move, i;\n\tint ret_val;\n\n\tif ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr - 1);\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) (yyg->yy_c_buf_p - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tyyrealloc( (void *) b->yy_ch_buf,\n\t\t\t\t\t\t\t (yy_size_t) (b->yy_buf_size + 2) , yyscanner );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = NULL;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\tyyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\tyyg->yy_n_chars, num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;\n\t\t}\n\n\tif ( yyg->yy_n_chars == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tyyrestart( yyin  , yyscanner);\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tint new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(\n\t\t\t(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size , yyscanner );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n\t\t/* \"- 2\" to take care of EOB's */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);\n\t}\n\n\tyyg->yy_n_chars += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;\n\n\tyyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}",
        "begin_line": 1390,
        "end_line": 1525,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.yy_get_previous_state#1529",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.yy_get_previous_state (yyscan_t yyscanner)",
        "snippet": "static yy_state_type yy_get_previous_state (yyscan_t yyscanner)\n{\n\tyy_state_type yy_current_state;\n\tchar *yy_cp;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tyy_current_state = yyg->yy_start;\n\n\tfor ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )\n\t\t{\n\t\tYY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\tyyg->yy_last_accepting_state = yy_current_state;\n\t\t\tyyg->yy_last_accepting_cpos = yy_cp;\n\t\t\t}\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 34 )\n\t\t\t\tyy_c = yy_meta[yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];\n\t\t}\n\n\treturn yy_current_state;\n}",
        "begin_line": 1529,
        "end_line": 1555,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.yy_init_globals#2278",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.yy_init_globals (yyscan_t yyscanner)",
        "snippet": "static int yy_init_globals (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from yylex_destroy(), so don't allocate here.\n     */\n\n    yyg->yy_buffer_stack = NULL;\n    yyg->yy_buffer_stack_top = 0;\n    yyg->yy_buffer_stack_max = 0;\n    yyg->yy_c_buf_p = NULL;\n    yyg->yy_init = 0;\n    yyg->yy_start = 0;\n\n    yyg->yy_start_stack_ptr = 0;\n    yyg->yy_start_stack_depth = 0;\n    yyg->yy_start_stack =  NULL;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    yyin = stdin;\n    yyout = stdout;\n#else\n    yyin = NULL;\n    yyout = NULL;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * yylex_init()\n     */\n    return 0;\n}",
        "begin_line": 2278,
        "end_line": 2309,
        "is_bug": false
    },
    {
        "name": "libyara.lexer.is_absolute_path#1023",
        "src_path": "libyara/lexer.c",
        "class_name": "libyara.lexer",
        "signature": "libyara.lexer.is_absolute_path(     char* path)",
        "snippet": "static bool is_absolute_path(\n    char* path)\n{\n  if (path == NULL)\n    return false;\n\n  #if defined(_WIN32) || defined(__CYGWIN__)\n  return strlen(path) > 2 &&\n      path[1] == ':' && (path[2] == '/' || path[2] == '\\\\');\n  #else\n  return strlen(path) > 0 && path[0] == '/';\n  #endif\n}",
        "begin_line": 1023,
        "end_line": 1035,
        "is_bug": false
    },
    {
        "name": "libyara.lexer.yara_yylex#1281",
        "src_path": "libyara/lexer.c",
        "class_name": "libyara.lexer",
        "signature": "libyara.lexer.L",
        "snippet": "YY_DECL\n{\n\tyy_state_type yy_current_state;\n\tchar *yy_cp, *yy_bp;\n\tint yy_act;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n    yylval = yylval_param;\n\n\tif ( !yyg->yy_init )\n\t\t{\n\t\tyyg->yy_init = 1;\n\n#ifdef YY_USER_INIT\n\t\tYY_USER_INIT;\n#endif\n\n\t\tif ( ! yyg->yy_start )\n\t\t\tyyg->yy_start = 1;\t/* first start state */\n\n\t\tif ( ! yyin )\n\t\t\tyyin = stdin;\n\n\t\tif ( ! yyout )\n\t\t\tyyout = stdout;\n\n\t\tif ( ! YY_CURRENT_BUFFER ) {\n\t\t\tyyensure_buffer_stack (yyscanner);\n\t\t\tYY_CURRENT_BUFFER_LVALUE =\n\t\t\t\tyy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);\n\t\t}\n\n\t\tyy_load_buffer_state( yyscanner );\n\t\t}\n\n\t{\n#line 163 \"lexer.l\"\n\n\n#line 1321 \"lexer.c\"\n\n\twhile ( /*CONSTCOND*/1 )\t\t/* loops until end-of-file is reached */\n\t\t{\n\t\tyy_cp = yyg->yy_c_buf_p;\n\n\t\t/* Support of yytext. */\n\t\t*yy_cp = yyg->yy_hold_char;\n\n\t\t/* yy_bp points to the position in yy_ch_buf of the start of\n\t\t * the current run.\n\t\t */\n\t\tyy_bp = yy_cp;\n\n\t\tyy_current_state = yyg->yy_start;\nyy_match:\n\t\tdo\n\t\t\t{\n\t\t\tYY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;\n\t\t\tif ( yy_accept[yy_current_state] )\n\t\t\t\t{\n\t\t\t\tyyg->yy_last_accepting_state = yy_current_state;\n\t\t\t\tyyg->yy_last_accepting_cpos = yy_cp;\n\t\t\t\t}\n\t\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t\t{\n\t\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\t\tif ( yy_current_state >= 258 )\n\t\t\t\t\tyy_c = yy_meta[yy_c];\n\t\t\t\t}\n\t\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];\n\t\t\t++yy_cp;\n\t\t\t}\n\t\twhile ( yy_current_state != 257 );\n\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\tyy_current_state = yyg->yy_last_accepting_state;\n\nyy_find_action:\n\t\tyy_act = yy_accept[yy_current_state];\n\n\t\tYY_DO_BEFORE_ACTION;\n\n\t\tif ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )\n\t\t\t{\n\t\t\tint yyl;\n\t\t\tfor ( yyl = 0; yyl < yyleng; ++yyl )\n\t\t\t\tif ( yytext[yyl] == '\\n' )\n\t\t\t\t\t\n    do{ yylineno++;\n        yycolumn=0;\n    }while(0)\n;\n\t\t\t}\n\ndo_action:\t/* This label is used only to access EOF actions. */\n\n\t\tswitch ( yy_act )\n\t{ /* beginning of action switch */\n\t\t\tcase 0: /* must back up */\n\t\t\t/* undo the effects of YY_DO_BEFORE_ACTION */\n\t\t\t*yy_cp = yyg->yy_hold_char;\n\t\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\t\tyy_current_state = yyg->yy_last_accepting_state;\n\t\t\tgoto yy_find_action;\n\ncase 1:\nYY_RULE_SETUP\n#line 165 \"lexer.l\"\n{ return _DOT_DOT_;     }\n\tYY_BREAK\ncase 2:\nYY_RULE_SETUP\n#line 166 \"lexer.l\"\n{ return _LT_;          }\n\tYY_BREAK\ncase 3:\nYY_RULE_SETUP\n#line 167 \"lexer.l\"\n{ return _GT_;          }\n\tYY_BREAK\ncase 4:\nYY_RULE_SETUP\n#line 168 \"lexer.l\"\n{ return _LE_;          }\n\tYY_BREAK\ncase 5:\nYY_RULE_SETUP\n#line 169 \"lexer.l\"\n{ return _GE_;          }\n\tYY_BREAK\ncase 6:\nYY_RULE_SETUP\n#line 170 \"lexer.l\"\n{ return _EQ_;          }\n\tYY_BREAK\ncase 7:\nYY_RULE_SETUP\n#line 171 \"lexer.l\"\n{ return _NEQ_;         }\n\tYY_BREAK\ncase 8:\nYY_RULE_SETUP\n#line 172 \"lexer.l\"\n{ return _SHIFT_LEFT_;  }\n\tYY_BREAK\ncase 9:\nYY_RULE_SETUP\n#line 173 \"lexer.l\"\n{ return _SHIFT_RIGHT_; }\n\tYY_BREAK\ncase 10:\nYY_RULE_SETUP\n#line 174 \"lexer.l\"\n{ return _PRIVATE_;     }\n\tYY_BREAK\ncase 11:\nYY_RULE_SETUP\n#line 175 \"lexer.l\"\n{ return _GLOBAL_;      }\n\tYY_BREAK\ncase 12:\nYY_RULE_SETUP\n#line 176 \"lexer.l\"\n{ return _RULE_;        }\n\tYY_BREAK\ncase 13:\nYY_RULE_SETUP\n#line 177 \"lexer.l\"\n{ return _META_;        }\n\tYY_BREAK\ncase 14:\nYY_RULE_SETUP\n#line 178 \"lexer.l\"\n{ return _STRINGS_;     }\n\tYY_BREAK\ncase 15:\nYY_RULE_SETUP\n#line 179 \"lexer.l\"\n{ return _ASCII_;       }\n\tYY_BREAK\ncase 16:\nYY_RULE_SETUP\n#line 180 \"lexer.l\"\n{ return _WIDE_;        }\n\tYY_BREAK\ncase 17:\nYY_RULE_SETUP\n#line 181 \"lexer.l\"\n{ return _XOR_;         }\n\tYY_BREAK\ncase 18:\nYY_RULE_SETUP\n#line 182 \"lexer.l\"\n{ return _BASE64_;      }\n\tYY_BREAK\ncase 19:\nYY_RULE_SETUP\n#line 183 \"lexer.l\"\n{ return _BASE64_WIDE_; }\n\tYY_BREAK\ncase 20:\nYY_RULE_SETUP\n#line 184 \"lexer.l\"\n{ return _FULLWORD_;    }\n\tYY_BREAK\ncase 21:\nYY_RULE_SETUP\n#line 185 \"lexer.l\"\n{ return _NOCASE_;      }\n\tYY_BREAK\ncase 22:\nYY_RULE_SETUP\n#line 186 \"lexer.l\"\n{ return _CONDITION_;   }\n\tYY_BREAK\ncase 23:\nYY_RULE_SETUP\n#line 187 \"lexer.l\"\n{ return _TRUE_;        }\n\tYY_BREAK\ncase 24:\nYY_RULE_SETUP\n#line 188 \"lexer.l\"\n{ return _FALSE_;       }\n\tYY_BREAK\ncase 25:\nYY_RULE_SETUP\n#line 189 \"lexer.l\"\n{ return _NOT_;         }\n\tYY_BREAK\ncase 26:\nYY_RULE_SETUP\n#line 190 \"lexer.l\"\n{ return _AND_;         }\n\tYY_BREAK\ncase 27:\nYY_RULE_SETUP\n#line 191 \"lexer.l\"\n{ return _OR_;          }\n\tYY_BREAK\ncase 28:\nYY_RULE_SETUP\n#line 192 \"lexer.l\"\n{ return _AT_;          }\n\tYY_BREAK\ncase 29:\nYY_RULE_SETUP\n#line 193 \"lexer.l\"\n{ return _IN_;          }\n\tYY_BREAK\ncase 30:\nYY_RULE_SETUP\n#line 194 \"lexer.l\"\n{ return _OF_;          }\n\tYY_BREAK\ncase 31:\nYY_RULE_SETUP\n#line 195 \"lexer.l\"\n{ return _THEM_;        }\n\tYY_BREAK\ncase 32:\nYY_RULE_SETUP\n#line 196 \"lexer.l\"\n{ return _FOR_;         }\n\tYY_BREAK\ncase 33:\nYY_RULE_SETUP\n#line 197 \"lexer.l\"\n{ return _ALL_;         }\n\tYY_BREAK\ncase 34:\nYY_RULE_SETUP\n#line 198 \"lexer.l\"\n{ return _ANY_;         }\n\tYY_BREAK\ncase 35:\nYY_RULE_SETUP\n#line 199 \"lexer.l\"\n{ return _ENTRYPOINT_;  }\n\tYY_BREAK\ncase 36:\nYY_RULE_SETUP\n#line 200 \"lexer.l\"\n{ return _FILESIZE_;    }\n\tYY_BREAK\ncase 37:\nYY_RULE_SETUP\n#line 201 \"lexer.l\"\n{ return _MATCHES_;     }\n\tYY_BREAK\ncase 38:\nYY_RULE_SETUP\n#line 202 \"lexer.l\"\n{ return _CONTAINS_;    }\n\tYY_BREAK\ncase 39:\nYY_RULE_SETUP\n#line 203 \"lexer.l\"\n{ return _IMPORT_;      }\n\tYY_BREAK\ncase 40:\nYY_RULE_SETUP\n#line 206 \"lexer.l\"\n{ BEGIN(comment);       }\n\tYY_BREAK\ncase 41:\nYY_RULE_SETUP\n#line 207 \"lexer.l\"\n{ BEGIN(INITIAL);       }\n\tYY_BREAK\ncase 42:\n/* rule 42 can match eol */\nYY_RULE_SETUP\n#line 208 \"lexer.l\"\n{ /* skip comments */   }\n\tYY_BREAK\ncase 43:\nYY_RULE_SETUP\n#line 211 \"lexer.l\"\n{ /* skip single-line comments */ }\n\tYY_BREAK\ncase 44:\nYY_RULE_SETUP\n#line 214 \"lexer.l\"\n{\n                          yyextra->lex_buf_ptr = yyextra->lex_buf;\n                          yyextra->lex_buf_len = 0;\n                          BEGIN(include);\n                        }\n\tYY_BREAK\ncase 45:\n/* rule 45 can match eol */\nYY_RULE_SETUP\n#line 221 \"lexer.l\"\n{ yytext_to_buffer; }\n\tYY_BREAK\ncase 46:\nYY_RULE_SETUP\n#line 224 \"lexer.l\"\n{\n\n  if (compiler->include_callback != NULL)\n  {\n    #ifdef _MSC_VER\n    char* b = NULL;\n    #endif\n    char* s = NULL;\n    char* f;\n\n    char buffer[1024];\n    const char* included_rules;\n    char* current_file_name;\n    char* include_path;\n\n    *yyextra->lex_buf_ptr = '\\0'; // null-terminate included file path\n\n    current_file_name = yr_compiler_get_current_file_name(compiler);\n\n    if (current_file_name == NULL ||\n        compiler->include_callback != _yr_compiler_default_include_callback ||\n        is_absolute_path(yyextra->lex_buf))\n    {\n      include_path = yyextra->lex_buf;\n    }\n    else\n    {\n      strlcpy(buffer, current_file_name, sizeof(buffer));\n      s = strrchr(buffer, '/');\n\n      #ifdef _MSC_VER\n      b = strrchr(buffer, '\\\\'); // in Windows both path delimiters are accepted\n      #endif\n\n      #ifdef _MSC_VER\n      if (s != NULL || b != NULL)\n      #else\n      if (s != NULL)\n      #endif\n      {\n        #ifdef _MSC_VER\n        f = (b > s) ? (b + 1) : (s + 1);\n        #else\n        f = s + 1;\n        #endif\n\n        strlcpy(f, yyextra->lex_buf, sizeof(buffer) - (f - buffer));\n        include_path = buffer;\n      }\n      else\n      {\n        include_path = yyextra->lex_buf;\n      }\n    }\n\n    YR_NAMESPACE* ns = (YR_NAMESPACE*) yr_arena_get_ptr(\n        compiler->arena,\n        YR_NAMESPACES_TABLE,\n        compiler->current_namespace_idx * sizeof(struct YR_NAMESPACE));\n\n    included_rules = compiler->include_callback(\n        include_path,\n        current_file_name,\n        ns->name,\n        compiler->incl_clbk_user_data);\n\n    if (included_rules != NULL)\n    {\n      int error_code = _yr_compiler_push_file_name(compiler, include_path);\n\n      if (error_code != ERROR_SUCCESS)\n      {\n        if (error_code == ERROR_INCLUDES_CIRCULAR_REFERENCE)\n        {\n          yyerror(yyscanner, compiler, \"includes circular reference\");\n        }\n        else if (error_code == ERROR_INCLUDE_DEPTH_EXCEEDED)\n        {\n          yyerror(yyscanner, compiler, \"includes depth exceeded\");\n        }\n\n        if (compiler->include_free != NULL)\n        {\n          compiler->include_free(included_rules, compiler->incl_clbk_user_data);\n        }\n\n        yyterminate();\n      }\n\n      // Workaround for flex issue: https://github.com/westes/flex/issues/58\n      yypush_buffer_state(YY_CURRENT_BUFFER, yyscanner);\n      yy_scan_string(included_rules, yyscanner);\n      yyset_lineno(1, yyscanner);\n\n      if (compiler->include_free != NULL)\n      {\n        compiler->include_free(included_rules, compiler->incl_clbk_user_data);\n      }\n    }\n    else\n    {\n      char* err_msg_fmt;\n      char err_msg[512];\n\n      if (compiler->include_callback == _yr_compiler_default_include_callback)\n      {\n        err_msg_fmt = \"can't open include file: %s\";\n      }\n      else\n      {\n        err_msg_fmt = \"callback failed to provide include resource: %s\";\n      }\n\n      snprintf(\n          err_msg,\n          sizeof(err_msg),\n          err_msg_fmt,\n          yyextra->lex_buf);\n\n      yyerror(yyscanner, compiler, err_msg);\n    }\n\n  }\n  else // not allowing includes\n  {\n    yyerror(yyscanner, compiler, \"includes are disabled\");\n  }\n\n  BEGIN(INITIAL);\n}\n\tYY_BREAK\ncase YY_STATE_EOF(INITIAL):\ncase YY_STATE_EOF(str):\ncase YY_STATE_EOF(regexp):\ncase YY_STATE_EOF(include):\ncase YY_STATE_EOF(comment):\n#line 356 \"lexer.l\"\n{\n\n  yypop_buffer_state(yyscanner);\n\n  if (!YY_CURRENT_BUFFER)\n    yyterminate();\n\n  return _END_OF_INCLUDED_FILE_;\n}\n\tYY_BREAK\ncase 47:\nYY_RULE_SETUP\n#line 367 \"lexer.l\"\n{\n\n  yylval->c_string = yr_strdup(yytext);\n\n  if (yylval->c_string == NULL)\n    error(ERROR_INSUFFICIENT_MEMORY);\n\n  return _STRING_IDENTIFIER_WITH_WILDCARD_;\n}\n\tYY_BREAK\ncase 48:\nYY_RULE_SETUP\n#line 378 \"lexer.l\"\n{\n\n  yylval->c_string = yr_strdup(yytext);\n\n  if (yylval->c_string == NULL)\n    error(ERROR_INSUFFICIENT_MEMORY);\n\n  return _STRING_IDENTIFIER_;\n}\n\tYY_BREAK\ncase 49:\nYY_RULE_SETUP\n#line 389 \"lexer.l\"\n{\n\n  yylval->c_string = yr_strdup(yytext);\n\n  if (yylval->c_string == NULL)\n  {\n    error(ERROR_INSUFFICIENT_MEMORY);\n  }\n  else\n  {\n    yylval->c_string[0] = '$'; /* replace # by $*/\n  }\n\n  return _STRING_COUNT_;\n}\n\tYY_BREAK\ncase 50:\nYY_RULE_SETUP\n#line 406 \"lexer.l\"\n{\n\n  yylval->c_string = yr_strdup(yytext);\n\n  if (yylval->c_string == NULL)\n  {\n    error(ERROR_INSUFFICIENT_MEMORY);\n  }\n  else\n  {\n    yylval->c_string[0] = '$'; /* replace @ by $*/\n  }\n\n  return _STRING_OFFSET_;\n}\n\tYY_BREAK\ncase 51:\nYY_RULE_SETUP\n#line 423 \"lexer.l\"\n{\n\n  yylval->c_string = yr_strdup(yytext);\n\n  if (yylval->c_string == NULL)\n  {\n    error(ERROR_INSUFFICIENT_MEMORY);\n  }\n  else\n  {\n    yylval->c_string[0] = '$'; /* replace ! by $*/\n  }\n\n  return _STRING_LENGTH_;\n}\n\tYY_BREAK\ncase 52:\nYY_RULE_SETUP\n#line 440 \"lexer.l\"\n{\n\n  char* text = yytext;\n\n  if (*text == 'u')\n  {\n    yylval->integer = 3;\n    text++;\n  }\n  else\n  {\n    yylval->integer = 0;\n  }\n\n  if (strstr(text, \"int8\") == text)\n  {\n    yylval->integer += 0;\n    text += 4;\n  }\n  else if (strstr(text, \"int16\") == text)\n  {\n    yylval->integer += 1;\n    text += 5;\n  }\n  else if (strstr(text, \"int32\") == text)\n  {\n    yylval->integer += 2;\n    text += 5;\n  }\n\n  if (strcmp(text, \"be\") == 0)\n  {\n    yylval->integer += 6;\n  }\n\n  return _INTEGER_FUNCTION_;\n}\n\tYY_BREAK\ncase 53:\nYY_RULE_SETUP\n#line 479 \"lexer.l\"\n{\n\n  if (strlen(yytext) > 128)\n    syntax_error(\"identifier too long\");\n\n  yylval->c_string = yr_strdup(yytext);\n\n  if (yylval->c_string == NULL)\n    error(ERROR_INSUFFICIENT_MEMORY);\n\n  return _IDENTIFIER_;\n}\n\tYY_BREAK\ncase 54:\nYY_RULE_SETUP\n#line 493 \"lexer.l\"\n{\n\n  char *endptr;\n\n  errno = 0;\n  yylval->integer = strtoll(yytext, &endptr, 10);\n\n  if (yylval->integer == LLONG_MAX && errno == ERANGE)\n  {\n    yr_compiler_set_error_extra_info(compiler, yytext);\n    error(ERROR_INTEGER_OVERFLOW);\n  }\n  else if (strstr(yytext, \"KB\") != NULL)\n  {\n    if (yylval->integer > LLONG_MAX / 1024)\n    {\n      yr_compiler_set_error_extra_info(compiler, yytext);\n      error(ERROR_INTEGER_OVERFLOW);\n    }\n    else\n    {\n      yylval->integer *= 1024;\n    }\n  }\n  else if (strstr(yytext, \"MB\") != NULL)\n  {\n    if (yylval->integer > LLONG_MAX / 1048576)\n    {\n      yr_compiler_set_error_extra_info(compiler, yytext);\n      error(ERROR_INTEGER_OVERFLOW);\n    }\n    else\n    {\n      yylval->integer *= 1048576;\n    }\n  }\n\n  return _NUMBER_;\n}\n\tYY_BREAK\ncase 55:\nYY_RULE_SETUP\n#line 533 \"lexer.l\"\n{\n  yylval->double_ = atof(yytext);\n  return _DOUBLE_;\n}\n\tYY_BREAK\ncase 56:\nYY_RULE_SETUP\n#line 538 \"lexer.l\"\n{\n\n  char *endptr;\n\n  errno = 0;\n  yylval->integer = strtoll(yytext, &endptr, 16);\n\n  if (yylval->integer == LLONG_MAX && errno == ERANGE)\n  {\n    yr_compiler_set_error_extra_info(compiler, yytext);\n    error(ERROR_INTEGER_OVERFLOW);\n  }\n\n  return _NUMBER_;\n}\n\tYY_BREAK\ncase 57:\nYY_RULE_SETUP\n#line 554 \"lexer.l\"\n{\n\n  char *endptr;\n\n  errno = 0;\n  yylval->integer = strtoll(yytext + 2, &endptr, 8);\n\n  if (yylval->integer == LLONG_MAX && errno == ERANGE)\n  {\n    yr_compiler_set_error_extra_info(compiler, yytext);\n    error(ERROR_INTEGER_OVERFLOW);\n  }\n\n  return _NUMBER_;\n}\n\tYY_BREAK\ncase 58:\nYY_RULE_SETUP\n#line 571 \"lexer.l\"\n{     /* saw closing quote - all done */\n\n  alloc_sized_string(s, yyextra->lex_buf_len);\n\n  *yyextra->lex_buf_ptr = '\\0';\n  memcpy(s->c_string, yyextra->lex_buf, yyextra->lex_buf_len + 1);\n  yylval->sized_string = s;\n\n  BEGIN(INITIAL);\n\n  return _TEXT_STRING_;\n}\n\tYY_BREAK\ncase 59:\nYY_RULE_SETUP\n#line 585 \"lexer.l\"\n{\n\n  lex_check_space_ok(\"\\t\", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);\n  *yyextra->lex_buf_ptr++ = '\\t';\n  yyextra->lex_buf_len++;\n}\n\tYY_BREAK\ncase 60:\nYY_RULE_SETUP\n#line 593 \"lexer.l\"\n{\n\n  lex_check_space_ok(\"\\n\", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);\n  *yyextra->lex_buf_ptr++ = '\\n';\n  yyextra->lex_buf_len++;\n}\n\tYY_BREAK\ncase 61:\nYY_RULE_SETUP\n#line 601 \"lexer.l\"\n{\n\n  lex_check_space_ok(\"\\\"\", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);\n  *yyextra->lex_buf_ptr++ = '\\\"';\n  yyextra->lex_buf_len++;\n}\n\tYY_BREAK\ncase 62:\nYY_RULE_SETUP\n#line 609 \"lexer.l\"\n{\n\n  lex_check_space_ok(\"\\\\\", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);\n  *yyextra->lex_buf_ptr++ = '\\\\';\n  yyextra->lex_buf_len++;\n}\n\tYY_BREAK\ncase 63:\nYY_RULE_SETUP\n#line 617 \"lexer.l\"\n{\n\n   int result;\n\n   sscanf( yytext + 2, \"%x\", &result );\n   lex_check_space_ok(\"X\", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);\n   *yyextra->lex_buf_ptr++ = result;\n   yyextra->lex_buf_len++;\n}\n\tYY_BREAK\ncase 64:\nYY_RULE_SETUP\n#line 628 \"lexer.l\"\n{ yytext_to_buffer; }\n\tYY_BREAK\ncase 65:\n/* rule 65 can match eol */\nYY_RULE_SETUP\n#line 631 \"lexer.l\"\n{\n  syntax_error(\"unterminated string\");\n}\n\tYY_BREAK\ncase 66:\n/* rule 66 can match eol */\nYY_RULE_SETUP\n#line 636 \"lexer.l\"\n{\n  syntax_error(\"illegal escape sequence\");\n}\n\tYY_BREAK\ncase 67:\nYY_RULE_SETUP\n#line 641 \"lexer.l\"\n{\n\n  if (yyextra->lex_buf_len > 0)\n  {\n    alloc_sized_string(s, yyextra->lex_buf_len);\n\n    if (yytext[1] == 'i')\n      s->flags |= SIZED_STRING_FLAGS_NO_CASE;\n\n    if (yytext[1] == 's' || yytext[2] == 's')\n      s->flags |= SIZED_STRING_FLAGS_DOT_ALL;\n\n    *yyextra->lex_buf_ptr = '\\0';\n    strlcpy(s->c_string, yyextra->lex_buf, s->length + 1);\n    yylval->sized_string = s;\n  }\n  else\n  {\n    syntax_error(\"empty regular expression\");\n  }\n\n  BEGIN(INITIAL);\n  return _REGEXP_;\n}\n\tYY_BREAK\ncase 68:\nYY_RULE_SETUP\n#line 667 \"lexer.l\"\n{\n\n  lex_check_space_ok(\"/\", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);\n  *yyextra->lex_buf_ptr++ = '/';\n  yyextra->lex_buf_len++ ;\n}\n\tYY_BREAK\ncase 69:\nYY_RULE_SETUP\n#line 675 \"lexer.l\"\n{\n\n  lex_check_space_ok(\"\\\\.\", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);\n\n  if (yytext[1] == 0)\n    syntax_error(\"malformed regular expression\");\n\n  *yyextra->lex_buf_ptr++ = yytext[0];\n  *yyextra->lex_buf_ptr++ = yytext[1];\n  yyextra->lex_buf_len += 2;\n}\n\tYY_BREAK\ncase 70:\nYY_RULE_SETUP\n#line 688 \"lexer.l\"\n{ yytext_to_buffer; }\n\tYY_BREAK\ncase 71:\n/* rule 71 can match eol */\nYY_RULE_SETUP\n#line 691 \"lexer.l\"\n{\n  syntax_error(\"unterminated regular expression\");\n}\n\tYY_BREAK\ncase 72:\nYY_RULE_SETUP\n#line 696 \"lexer.l\"\n{\n\n  yylval->sized_string = NULL;\n  yyextra->lex_buf_ptr = yyextra->lex_buf;\n  yyextra->lex_buf_len = 0;\n  BEGIN(str);\n}\n\tYY_BREAK\ncase 73:\nYY_RULE_SETUP\n#line 705 \"lexer.l\"\n{\n\n  yylval->sized_string = NULL;\n  yyextra->lex_buf_ptr = yyextra->lex_buf;\n  yyextra->lex_buf_len = 0;\n  BEGIN(regexp);\n}\n\tYY_BREAK\ncase 74:\n/* rule 74 can match eol */\nYY_RULE_SETUP\n#line 714 \"lexer.l\"\n{\n  // Match hex-digits with whitespace or comments. The latter are stripped\n  // out by hex_lexer.l\n  // TODO(vmalvarez): Integrate the hex string lexer and parser into this one,\n  // by having a single lexer/parser instead of two different ones we can avoid\n  // complex regular expressions like the one above, which is actually trying to\n  // do some parsing in the lexer.\n\n  alloc_sized_string(s, strlen(yytext));\n\n  strlcpy(s->c_string, yytext, s->length + 1);\n  yylval->sized_string = s;\n\n  return _HEX_STRING_;\n}\n\tYY_BREAK\ncase 75:\n/* rule 75 can match eol */\nYY_RULE_SETUP\n#line 731 \"lexer.l\"\n/* skip whitespace */\n\tYY_BREAK\ncase 76:\nYY_RULE_SETUP\n#line 733 \"lexer.l\"\n{\n\n  if (yytext[0] >= 32 && yytext[0] < 127)\n  {\n    return yytext[0];\n  }\n  else\n  {\n    syntax_error(\"non-ascii character\");\n  }\n}\n\tYY_BREAK\ncase 77:\nYY_RULE_SETUP\n#line 745 \"lexer.l\"\nECHO;\n\tYY_BREAK\n#line 2220 \"lexer.c\"\n\n\tcase YY_END_OF_BUFFER:\n\t\t{\n\t\t/* Amount of text matched not including the EOB char. */\n\t\tint yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;\n\n\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */\n\t\t*yy_cp = yyg->yy_hold_char;\n\t\tYY_RESTORE_YY_MORE_OFFSET\n\n\t\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )\n\t\t\t{\n\t\t\t/* We're scanning a new file or input source.  It's\n\t\t\t * possible that this happened because the user\n\t\t\t * just pointed yyin at a new source and called\n\t\t\t * yylex().  If so, then we have to assure\n\t\t\t * consistency between YY_CURRENT_BUFFER and our\n\t\t\t * globals.  Here is the right place to do so, because\n\t\t\t * this is the first action (other than possibly a\n\t\t\t * back-up) that will match for the new input source.\n\t\t\t */\n\t\t\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;\n\t\t\t}\n\n\t\t/* Note that here we test for yy_c_buf_p \"<=\" to the position\n\t\t * of the first EOB in the buffer, since yy_c_buf_p will\n\t\t * already have been incremented past the NUL character\n\t\t * (since all states make transitions on EOB to the\n\t\t * end-of-buffer state).  Contrast this with the test\n\t\t * in input().\n\t\t */\n\t\tif ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )\n\t\t\t{ /* This was really a NUL. */\n\t\t\tyy_state_type yy_next_state;\n\n\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;\n\n\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t/* Okay, we're now positioned to make the NUL\n\t\t\t * transition.  We couldn't have\n\t\t\t * yy_get_previous_state() go ahead and do it\n\t\t\t * for us because it doesn't know how to deal\n\t\t\t * with the possibility of jamming (and we don't\n\t\t\t * want to build jamming into it because then it\n\t\t\t * will run more slowly).\n\t\t\t */\n\n\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);\n\n\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\n\t\t\tif ( yy_next_state )\n\t\t\t\t{\n\t\t\t\t/* Consume the NUL. */\n\t\t\t\tyy_cp = ++yyg->yy_c_buf_p;\n\t\t\t\tyy_current_state = yy_next_state;\n\t\t\t\tgoto yy_match;\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\t\t\tyy_current_state = yyg->yy_last_accepting_state;\n\t\t\t\tgoto yy_find_action;\n\t\t\t\t}\n\t\t\t}\n\n\t\telse switch ( yy_get_next_buffer( yyscanner ) )\n\t\t\t{\n\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t{\n\t\t\t\tyyg->yy_did_buffer_switch_on_eof = 0;\n\n\t\t\t\tif ( yywrap( yyscanner ) )\n\t\t\t\t\t{\n\t\t\t\t\t/* Note: because we've taken care in\n\t\t\t\t\t * yy_get_next_buffer() to have set up\n\t\t\t\t\t * yytext, we can now set up\n\t\t\t\t\t * yy_c_buf_p so that if some total\n\t\t\t\t\t * hoser (like flex itself) wants to\n\t\t\t\t\t * call the scanner after we return the\n\t\t\t\t\t * YY_NULL, it'll still work - another\n\t\t\t\t\t * YY_NULL will get returned.\n\t\t\t\t\t */\n\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;\n\n\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);\n\t\t\t\t\tgoto do_action;\n\t\t\t\t\t}\n\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\tyyg->yy_c_buf_p =\n\t\t\t\t\tyyg->yytext_ptr + yy_amount_of_matched_text;\n\n\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t\tyy_cp = yyg->yy_c_buf_p;\n\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_match;\n\n\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\tyyg->yy_c_buf_p =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];\n\n\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t\tyy_cp = yyg->yy_c_buf_p;\n\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_find_action;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\tYY_FATAL_ERROR(\n\t\t\t\"fatal flex scanner internal error--no action found\" );\n\t} /* end of action switch */\n\t\t} /* end of scanning one token */\n\t} /* end of user's declarations */\n}",
        "begin_line": 1281,
        "end_line": 2350,
        "is_bug": false
    },
    {
        "name": "libyara.lexer.yy_get_next_buffer#2359",
        "src_path": "libyara/lexer.c",
        "class_name": "libyara.lexer",
        "signature": "libyara.lexer.yy_get_next_buffer (yyscan_t yyscanner)",
        "snippet": "static int yy_get_next_buffer (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tchar *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tchar *source = yyg->yytext_ptr;\n\tint number_to_move, i;\n\tint ret_val;\n\n\tif ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr - 1);\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) (yyg->yy_c_buf_p - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tyyrealloc( (void *) b->yy_ch_buf,\n\t\t\t\t\t\t\t (yy_size_t) (b->yy_buf_size + 2) , yyscanner );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = NULL;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\tyyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\tyyg->yy_n_chars, num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;\n\t\t}\n\n\tif ( yyg->yy_n_chars == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tyyrestart( yyin  , yyscanner);\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tint new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(\n\t\t\t(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size , yyscanner );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n\t\t/* \"- 2\" to take care of EOB's */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);\n\t}\n\n\tyyg->yy_n_chars += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;\n\n\tyyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}",
        "begin_line": 2359,
        "end_line": 2494,
        "is_bug": false
    },
    {
        "name": "libyara.libyara.yr_finalize#191",
        "src_path": "libyara/libyara.c",
        "class_name": "libyara.libyara",
        "signature": "libyara.libyara.yr_finalize(void)",
        "snippet": "YR_API int yr_finalize(void)\n{\n  #if defined HAVE_LIBCRYPTO && OPENSSL_VERSION_NUMBER < 0x10100000L\n  int i;\n  #endif\n\n  // yr_finalize shouldn't be called without calling yr_initialize first\n\n  if (init_count == 0)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  init_count--;\n\n  if (init_count > 0)\n    return ERROR_SUCCESS;\n\n  #if defined HAVE_LIBCRYPTO && OPENSSL_VERSION_NUMBER < 0x10100000L\n\n  for (i = 0; i < CRYPTO_num_locks(); i ++)\n    yr_mutex_destroy(&openssl_locks[i]);\n\n  OPENSSL_free(openssl_locks);\n  CRYPTO_THREADID_set_callback(NULL);\n  CRYPTO_set_locking_callback(NULL);\n\n  #elif defined(HAVE_WINCRYPT_H)\n\n  CryptReleaseContext(yr_cryptprov, 0);\n\n  #endif\n\n  FAIL_ON_ERROR(yr_thread_storage_destroy(&yr_yyfatal_trampoline_tls));\n  FAIL_ON_ERROR(yr_thread_storage_destroy(&yr_trycatch_trampoline_tls));\n  FAIL_ON_ERROR(yr_modules_finalize());\n  FAIL_ON_ERROR(yr_heap_free());\n\n  #if defined(JEMALLOC)\n  malloc_stats_print(NULL, NULL, NULL);\n  mallctl(\"prof.dump\", NULL, NULL, NULL, 0);\n  #endif\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 191,
        "end_line": 233,
        "is_bug": false
    },
    {
        "name": "libyara.libyara.yr_initialize#113",
        "src_path": "libyara/libyara.c",
        "class_name": "libyara.libyara",
        "signature": "libyara.libyara.yr_initialize(void)",
        "snippet": "YR_API int yr_initialize(void)\n{\n  uint32_t def_stack_size = DEFAULT_STACK_SIZE;\n  uint32_t def_max_strings_per_rule = DEFAULT_MAX_STRINGS_PER_RULE;\n  uint32_t def_max_match_data = DEFAULT_MAX_MATCH_DATA;\n\n  int i;\n\n  init_count++;\n\n  if (init_count > 1)\n    return ERROR_SUCCESS;\n\n  // Initialize random number generator, as it is used for generating object\n  // canaries.\n  srand((unsigned) time(NULL));\n\n  for (i = 0; i < 256; i++)\n  {\n    if (i >= 'a' && i <= 'z')\n      yr_altercase[i] = i - 32;\n    else if (i >= 'A' && i <= 'Z')\n      yr_altercase[i] = i + 32;\n    else\n      yr_altercase[i] = i;\n\n    yr_lowercase[i] = tolower(i);\n  }\n\n  FAIL_ON_ERROR(yr_heap_alloc());\n  FAIL_ON_ERROR(yr_thread_storage_create(&yr_yyfatal_trampoline_tls));\n  FAIL_ON_ERROR(yr_thread_storage_create(&yr_trycatch_trampoline_tls));\n\n  #if defined HAVE_LIBCRYPTO && OPENSSL_VERSION_NUMBER < 0x10100000L\n\n  openssl_locks = (YR_MUTEX*) OPENSSL_malloc(\n      CRYPTO_num_locks() * sizeof(YR_MUTEX));\n\n  for (i = 0; i < CRYPTO_num_locks(); i++)\n    yr_mutex_create(&openssl_locks[i]);\n\n  CRYPTO_THREADID_set_callback(_thread_id);\n  CRYPTO_set_locking_callback(_locking_function);\n\n  #elif defined(HAVE_WINCRYPT_H)\n\n  if (!CryptAcquireContext(&yr_cryptprov, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {\n    return ERROR_INTERNAL_FATAL_ERROR;\n  }\n\n  #elif defined(HAVE_COMMON_CRYPTO)\n\n  ...\n\n  #endif\n\n  FAIL_ON_ERROR(yr_modules_initialize());\n\n  // Initialize default configuration options\n  FAIL_ON_ERROR(yr_set_configuration(\n      YR_CONFIG_STACK_SIZE, &def_stack_size));\n\n  FAIL_ON_ERROR(yr_set_configuration(\n      YR_CONFIG_MAX_STRINGS_PER_RULE, &def_max_strings_per_rule));\n\n  FAIL_ON_ERROR(yr_set_configuration(\n      YR_CONFIG_MAX_MATCH_DATA, &def_max_match_data));\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 113,
        "end_line": 182,
        "is_bug": false
    },
    {
        "name": "libyara.libyara.yr_set_configuration#257",
        "src_path": "libyara/libyara.c",
        "class_name": "libyara.libyara",
        "signature": "libyara.libyara.yr_set_configuration(     YR_CONFIG_NAME name, void *src)",
        "snippet": "YR_API int yr_set_configuration(\n    YR_CONFIG_NAME name,\n    void *src)\n{\n  if (src == NULL)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  switch (name)\n  { // lump all the cases using same types together in one cascade\n    case YR_CONFIG_STACK_SIZE:\n    case YR_CONFIG_MAX_STRINGS_PER_RULE:\n    case YR_CONFIG_MAX_MATCH_DATA:\n      yr_cfgs[name].ui32 = *(uint32_t*) src;\n      break;\n\n    default:\n      return ERROR_INTERNAL_FATAL_ERROR;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 257,
        "end_line": 277,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_calloc#134",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_calloc(size_t count, size_t size)",
        "snippet": "void* yr_calloc(size_t count, size_t size)\n{\n  return calloc(count, size);\n}",
        "begin_line": 134,
        "end_line": 137,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_free#152",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_free(void *ptr)",
        "snippet": "void yr_free(void *ptr)\n{\n  free(ptr);\n}",
        "begin_line": 152,
        "end_line": 155,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_heap_alloc#122",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_heap_alloc(void)",
        "snippet": "int yr_heap_alloc(void)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 122,
        "end_line": 125,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_heap_free#128",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_heap_free(void)",
        "snippet": "int yr_heap_free(void)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 128,
        "end_line": 131,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_malloc#140",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_malloc(size_t size)",
        "snippet": "void* yr_malloc(size_t size)\n{\n  return malloc(size);\n}",
        "begin_line": 140,
        "end_line": 143,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_realloc#146",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_realloc(void* ptr, size_t size)",
        "snippet": "void* yr_realloc(void* ptr, size_t size)\n{\n  return realloc(ptr, size);\n}",
        "begin_line": 146,
        "end_line": 149,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_strdup#158",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_strdup(const char *str)",
        "snippet": "char* yr_strdup(const char *str)\n{\n  return strdup(str);\n}",
        "begin_line": 158,
        "end_line": 161,
        "is_bug": false
    },
    {
        "name": "libyara.modules.elf.elf.module_finalize#577",
        "src_path": "libyara/modules/elf/elf.c",
        "class_name": "libyara.modules.elf.elf",
        "signature": "libyara.modules.elf.elf.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 577,
        "end_line": 581,
        "is_bug": false
    },
    {
        "name": "libyara.modules.elf.elf.module_initialize#570",
        "src_path": "libyara/modules/elf/elf.c",
        "class_name": "libyara.modules.elf.elf",
        "signature": "libyara.modules.elf.elf.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 570,
        "end_line": 574,
        "is_bug": false
    },
    {
        "name": "libyara.modules.hash.hash.module_finalize#629",
        "src_path": "libyara/modules/hash/hash.c",
        "class_name": "libyara.modules.hash.hash",
        "signature": "libyara.modules.hash.hash.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 629,
        "end_line": 633,
        "is_bug": false
    },
    {
        "name": "libyara.modules.hash.hash.module_initialize#622",
        "src_path": "libyara/modules/hash/hash.c",
        "class_name": "libyara.modules.hash.hash",
        "signature": "libyara.modules.hash.hash.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 622,
        "end_line": 626,
        "is_bug": false
    },
    {
        "name": "libyara.modules.math.math.module_finalize#645",
        "src_path": "libyara/modules/math/math.c",
        "class_name": "libyara.modules.math.math",
        "signature": "libyara.modules.math.math.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 645,
        "end_line": 649,
        "is_bug": false
    },
    {
        "name": "libyara.modules.math.math.module_initialize#638",
        "src_path": "libyara/modules/math/math.c",
        "class_name": "libyara.modules.math.math",
        "signature": "libyara.modules.math.math.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 638,
        "end_line": 642,
        "is_bug": false
    },
    {
        "name": "libyara.modules.pe.pe.module_finalize#2986",
        "src_path": "libyara/modules/pe/pe.c",
        "class_name": "libyara.modules.pe.pe",
        "signature": "libyara.modules.pe.pe.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 2986,
        "end_line": 2990,
        "is_bug": false
    },
    {
        "name": "libyara.modules.pe.pe.module_initialize#2974",
        "src_path": "libyara/modules/pe/pe.c",
        "class_name": "libyara.modules.pe.pe",
        "signature": "libyara.modules.pe.pe.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n#if defined(HAVE_LIBCRYPTO)\n  // Not checking return value here because if it fails we will not parse the\n  // nested signature silently.\n  OBJ_create(SPC_NESTED_SIGNATURE_OBJID, NULL, NULL);\n#endif\n  return ERROR_SUCCESS;\n}",
        "begin_line": 2974,
        "end_line": 2983,
        "is_bug": false
    },
    {
        "name": "libyara.modules.tests.tests.module_finalize#167",
        "src_path": "libyara/modules/tests/tests.c",
        "class_name": "libyara.modules.tests.tests",
        "signature": "libyara.modules.tests.tests.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 167,
        "end_line": 171,
        "is_bug": false
    },
    {
        "name": "libyara.modules.tests.tests.module_initialize#160",
        "src_path": "libyara/modules/tests/tests.c",
        "class_name": "libyara.modules.tests.tests",
        "signature": "libyara.modules.tests.tests.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 160,
        "end_line": 164,
        "is_bug": false
    },
    {
        "name": "libyara.modules.time.time.module_finalize#60",
        "src_path": "libyara/modules/time/time.c",
        "class_name": "libyara.modules.time.time",
        "signature": "libyara.modules.time.time.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 60,
        "end_line": 64,
        "is_bug": false
    },
    {
        "name": "libyara.modules.time.time.module_initialize#53",
        "src_path": "libyara/modules/time/time.c",
        "class_name": "libyara.modules.time.time",
        "signature": "libyara.modules.time.time.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 53,
        "end_line": 57,
        "is_bug": false
    },
    {
        "name": "libyara.modules.yr_modules_finalize#85",
        "src_path": "libyara/modules.c",
        "class_name": "libyara.modules",
        "signature": "libyara.modules.yr_modules_finalize()",
        "snippet": "int yr_modules_finalize()\n{\n  int i;\n\n  for (i = 0; i < sizeof(yr_modules_table) / sizeof(YR_MODULE); i++)\n  {\n    int result = yr_modules_table[i].finalize(&yr_modules_table[i]);\n\n    if (result != ERROR_SUCCESS)\n      return result;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 85,
        "end_line": 98,
        "is_bug": false
    },
    {
        "name": "libyara.modules.yr_modules_initialize#69",
        "src_path": "libyara/modules.c",
        "class_name": "libyara.modules",
        "signature": "libyara.modules.yr_modules_initialize()",
        "snippet": "int yr_modules_initialize()\n{\n  int i;\n\n  for (i = 0; i < sizeof(yr_modules_table) / sizeof(YR_MODULE); i++)\n  {\n    int result = yr_modules_table[i].initialize(&yr_modules_table[i]);\n\n    if (result != ERROR_SUCCESS)\n      return result;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 69,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "libyara.parser._yr_parser_write_string#353",
        "src_path": "libyara/parser.c",
        "class_name": "libyara.parser",
        "signature": "libyara.parser._yr_parser_write_string(     const char* identifier, YR_MODIFIER modifier, YR_COMPILER* compiler, SIZED_STRING* str, RE_AST* re_ast, YR_ARENA_REF* string_ref, int* min_atom_quality, int* num_atom)",
        "snippet": "static int _yr_parser_write_string(\n    const char* identifier,\n    YR_MODIFIER modifier,\n    YR_COMPILER* compiler,\n    SIZED_STRING* str,\n    RE_AST* re_ast,\n    YR_ARENA_REF* string_ref,\n    int* min_atom_quality,\n    int* num_atom)\n{\n  SIZED_STRING* literal_string;\n  YR_ATOM_LIST_ITEM* atom;\n  YR_ATOM_LIST_ITEM* atom_list = NULL;\n\n  int c, result;\n  int max_string_len;\n  bool free_literal = false;\n\n  FAIL_ON_ERROR(yr_arena_allocate_struct(\n      compiler->arena,\n      YR_STRINGS_TABLE,\n      sizeof(YR_STRING),\n      string_ref,\n      offsetof(YR_STRING, identifier),\n      offsetof(YR_STRING, string),\n      offsetof(YR_STRING, chained_to),\n      EOL));\n\n  YR_STRING* string = (YR_STRING*) yr_arena_ref_to_ptr(\n      compiler->arena, string_ref);\n\n  YR_ARENA_REF ref;\n\n  FAIL_ON_ERROR(yr_arena_write_string(\n      compiler->arena,\n      YR_SZ_POOL,\n      identifier,\n      &ref));\n\n  string->identifier = (const char*) yr_arena_ref_to_ptr(\n      compiler->arena, &ref);\n\n  if (modifier.flags & STRING_FLAGS_HEXADECIMAL ||\n      modifier.flags & STRING_FLAGS_REGEXP ||\n      modifier.flags & STRING_FLAGS_BASE64 ||\n      modifier.flags & STRING_FLAGS_BASE64_WIDE)\n  {\n    literal_string = yr_re_ast_extract_literal(re_ast);\n\n    if (literal_string != NULL)\n    {\n      modifier.flags |= STRING_FLAGS_LITERAL;\n      free_literal = true;\n    }\n    else\n    {\n      // Non-literal strings can't be marked as fixed offset because once we\n      // find a string atom in the scanned data we don't know the offset where\n      // the string should start, as the non-literal strings can contain\n      // variable-length portions.\n\n      modifier.flags &= ~STRING_FLAGS_FIXED_OFFSET;\n    }\n  }\n  else\n  {\n    literal_string = str;\n    modifier.flags |= STRING_FLAGS_LITERAL;\n  }\n\n  string->flags = modifier.flags;\n  string->rule_idx = compiler->current_rule_idx;\n  string->idx = compiler->current_string_idx;\n  string->fixed_offset = YR_UNDEFINED;\n  string->chained_to = NULL;\n  string->string = NULL;\n\n  if (modifier.flags & STRING_FLAGS_LITERAL)\n  {\n    result = yr_arena_write_data(\n        compiler->arena,\n        YR_SZ_POOL,\n        literal_string->c_string,\n        literal_string->length + 1,   // +1 to include terminating NULL\n        &ref);\n\n    string->length = (uint32_t) literal_string->length;\n    string->string = (uint8_t*) yr_arena_ref_to_ptr(compiler->arena, &ref);\n\n    if (result == ERROR_SUCCESS)\n    {\n      result = yr_atoms_extract_from_string(\n          &compiler->atoms_config,\n          (uint8_t*) literal_string->c_string,\n          (int32_t) literal_string->length,\n          modifier,\n          &atom_list,\n          min_atom_quality);\n    }\n  }\n  else\n  {\n    // Emit forwards code\n    result = yr_re_ast_emit_code(\n        re_ast, compiler->arena, false);\n\n    // Emit backwards code\n    if (result == ERROR_SUCCESS)\n      result = yr_re_ast_emit_code(\n          re_ast, compiler->arena, true);\n\n    if (result == ERROR_SUCCESS)\n      result = yr_atoms_extract_from_re(\n          &compiler->atoms_config,\n          re_ast,\n          modifier,\n          &atom_list,\n          min_atom_quality);\n  }\n\n  if (result == ERROR_SUCCESS)\n  {\n    // Add the string to Aho-Corasick automaton.\n    result = yr_ac_add_string(\n        compiler->automaton,\n        string,\n        compiler->current_string_idx,\n        atom_list,\n        compiler->arena);\n  }\n\n  if (modifier.flags & STRING_FLAGS_LITERAL)\n  {\n    if (modifier.flags & STRING_FLAGS_WIDE)\n      max_string_len = string->length * 2;\n    else\n      max_string_len = string->length;\n\n    if (max_string_len <= YR_MAX_ATOM_LENGTH)\n      string->flags |= STRING_FLAGS_FITS_IN_ATOM;\n  }\n\n  atom = atom_list;\n  c = 0;\n\n  while (atom != NULL)\n  {\n    atom = atom->next;\n    c++;\n  }\n\n  (*num_atom) += c;\n\n  compiler->current_string_idx++;\n\n  if (free_literal)\n    yr_free(literal_string);\n\n  if (atom_list != NULL)\n    yr_atoms_list_destroy(atom_list);\n\n  return result;\n}",
        "begin_line": 353,
        "end_line": 515,
        "is_bug": false
    },
    {
        "name": "libyara.parser.yr_parser_emit_with_arg_int32#94",
        "src_path": "libyara/parser.c",
        "class_name": "libyara.parser",
        "signature": "libyara.parser.yr_parser_emit_with_arg_int32(     yyscan_t yyscanner, uint8_t instruction, int32_t argument, YR_ARENA_REF* instruction_ref, YR_ARENA_REF* argument_ref)",
        "snippet": "int yr_parser_emit_with_arg_int32(\n    yyscan_t yyscanner,\n    uint8_t instruction,\n    int32_t argument,\n    YR_ARENA_REF* instruction_ref,\n    YR_ARENA_REF* argument_ref)\n{\n  int result = yr_arena_write_data(\n      yyget_extra(yyscanner)->arena,\n      YR_CODE_SECTION,\n      &instruction,\n      sizeof(uint8_t),\n      instruction_ref);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_write_data(\n        yyget_extra(yyscanner)->arena,\n        YR_CODE_SECTION,\n        &argument,\n        sizeof(int32_t),\n        argument_ref);\n\n  return result;\n}",
        "begin_line": 94,
        "end_line": 117,
        "is_bug": false
    },
    {
        "name": "libyara.parser.yr_parser_reduce_rule_declaration_phase_1#847",
        "src_path": "libyara/parser.c",
        "class_name": "libyara.parser",
        "signature": "libyara.parser.yr_parser_reduce_rule_declaration_phase_1(     yyscan_t yyscanner, int32_t flags, const char* identifier, YR_ARENA_REF* rule_ref)",
        "snippet": "int yr_parser_reduce_rule_declaration_phase_1(\n    yyscan_t yyscanner,\n    int32_t flags,\n    const char* identifier,\n    YR_ARENA_REF* rule_ref)\n{\n  YR_FIXUP *fixup;\n  YR_COMPILER* compiler = yyget_extra(yyscanner);\n  compiler->current_rule_idx = compiler->next_rule_idx;\n  compiler->next_rule_idx++;\n\n  YR_NAMESPACE* ns = (YR_NAMESPACE*) yr_arena_get_ptr(\n      compiler->arena,\n      YR_NAMESPACES_TABLE,\n      compiler->current_namespace_idx * sizeof(struct YR_NAMESPACE));\n\n  if (yr_hash_table_lookup_uint32(\n          compiler->rules_table,\n          identifier,\n          ns->name) != UINT32_MAX ||\n      yr_hash_table_lookup(\n          compiler->objects_table,\n          identifier,\n          NULL) != NULL)\n  {\n    // A rule or variable with the same identifier already exists, return the\n    // appropriate error.\n\n    yr_compiler_set_error_extra_info(compiler, identifier)\n    return ERROR_DUPLICATED_IDENTIFIER;\n  }\n\n  FAIL_ON_ERROR(yr_arena_allocate_struct(\n      compiler->arena,\n      YR_RULES_TABLE,\n      sizeof(YR_RULE),\n      rule_ref,\n      offsetof(YR_RULE, identifier),\n      offsetof(YR_RULE, tags),\n      offsetof(YR_RULE, strings),\n      offsetof(YR_RULE, metas),\n      offsetof(YR_RULE, ns),\n      EOL));\n\n  YR_RULE* rule = (YR_RULE*) yr_arena_ref_to_ptr(compiler->arena, rule_ref);\n\n  YR_ARENA_REF ref;\n\n  FAIL_ON_ERROR(yr_arena_write_string(\n      compiler->arena,\n      YR_SZ_POOL,\n      identifier,\n      &ref));\n\n  rule->identifier = (const char*) yr_arena_ref_to_ptr(compiler->arena, &ref);\n  rule->flags = flags;\n  rule->ns = ns;\n  rule->num_atoms = 0;\n\n  YR_ARENA_REF jmp_offset_ref;\n\n  // We are starting to parse a new rule, set current_rule_idx accordingly.\n\n  // The OP_INIT_RULE instruction behaves like a jump. When the rule is disabled\n  // it skips over the rule's code and go straight to the next rule's code. The\n  // jmp_offset_ref variable points to the jump's offset. The offset is set to 0\n  // as we don't know the jump target yet. When we finish generating the rule's\n  // code in yr_parser_reduce_rule_declaration_phase_2 the jump offset is set to\n  // its final value.\n\n  FAIL_ON_ERROR(yr_parser_emit_with_arg_int32(\n      yyscanner,\n      OP_INIT_RULE,\n      0,\n      NULL,\n      &jmp_offset_ref));\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      compiler->arena,\n      YR_CODE_SECTION,\n      &compiler->current_rule_idx,\n      sizeof(compiler->current_rule_idx),\n      NULL));\n\n  // Create a fixup entry for the jump and push it in the stack\n  fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n  if (fixup == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  fixup->ref = jmp_offset_ref;\n  fixup->next = compiler->fixup_stack_head;\n  compiler->fixup_stack_head = fixup;\n\n  // Clean strings_table as we are starting to parse a new rule.\n  yr_hash_table_clean(compiler->strings_table, NULL);\n\n  FAIL_ON_ERROR(yr_hash_table_add_uint32(\n      compiler->rules_table,\n      identifier,\n      ns->name,\n      compiler->current_rule_idx));\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 847,
        "end_line": 951,
        "is_bug": true
    },
    {
        "name": "libyara.parser.yr_parser_reduce_string_declaration#517",
        "src_path": "libyara/parser.c",
        "class_name": "libyara.parser",
        "signature": "libyara.parser.yr_parser_reduce_string_declaration(     yyscan_t yyscanner, YR_MODIFIER modifier, const char* identifier, SIZED_STRING* str, YR_ARENA_REF* string_ref)",
        "snippet": "int yr_parser_reduce_string_declaration(\n    yyscan_t yyscanner,\n    YR_MODIFIER modifier,\n    const char* identifier,\n    SIZED_STRING* str,\n    YR_ARENA_REF* string_ref)\n{\n  int result = ERROR_SUCCESS;\n  int min_atom_quality = YR_MAX_ATOM_QUALITY;\n  int atom_quality;\n\n  char message[512];\n\n  int32_t min_gap = 0;\n  int32_t max_gap = 0;\n\n  YR_COMPILER* compiler = yyget_extra(yyscanner);\n\n  RE_AST* re_ast = NULL;\n  RE_AST* remainder_re_ast = NULL;\n  RE_ERROR re_error;\n\n  YR_RULE* current_rule = _yr_compiler_get_rule_by_idx(\n      compiler, compiler->current_rule_idx);\n\n  // Determine if a string with the same identifier was already defined\n  // by searching for the identifier in strings_table.\n  uint32_t string_idx = yr_hash_table_lookup_uint32(\n      compiler->strings_table,\n      identifier,\n      NULL);\n\n  // The string was already defined, return an error.\n  if (string_idx != UINT32_MAX)\n  {\n    result = ERROR_DUPLICATED_STRING_IDENTIFIER;\n    yr_compiler_set_error_extra_info(compiler, identifier)\n    goto _exit;\n  }\n\n  // Empty strings are not allowed\n  if (str->length == 0)\n  {\n    result = ERROR_EMPTY_STRING;\n    yr_compiler_set_error_extra_info(compiler, identifier)\n    goto _exit;\n  }\n\n  // If string identifier is $ this is an anonymous string, if not add the\n  // identifier to strings_table.\n  if (strcmp(identifier, \"$\") == 0)\n  {\n    modifier.flags |= STRING_FLAGS_ANONYMOUS;\n  }\n  else\n  {\n    result = yr_hash_table_add_uint32(\n        compiler->strings_table,\n        identifier,\n        NULL,\n        compiler->current_string_idx);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n  }\n\n  if (str->flags & SIZED_STRING_FLAGS_NO_CASE)\n    modifier.flags |= STRING_FLAGS_NO_CASE;\n\n  if (str->flags & SIZED_STRING_FLAGS_DOT_ALL)\n    modifier.flags |= STRING_FLAGS_DOT_ALL;\n\n  // Hex strings are always handled as DOT_ALL regexps.\n  if (modifier.flags & STRING_FLAGS_HEXADECIMAL)\n    modifier.flags |= STRING_FLAGS_DOT_ALL;\n\n  // xor and nocase together is not implemented.\n  if (modifier.flags & STRING_FLAGS_XOR &&\n      modifier.flags & STRING_FLAGS_NO_CASE)\n  {\n      result = ERROR_INVALID_MODIFIER;\n      yr_compiler_set_error_extra_info(compiler, \"xor nocase\")\n      goto _exit;\n  }\n\n  // base64 and nocase together is not implemented.\n  if (modifier.flags & STRING_FLAGS_NO_CASE &&\n      (modifier.flags & STRING_FLAGS_BASE64 ||\n       modifier.flags & STRING_FLAGS_BASE64_WIDE))\n  {\n      result = ERROR_INVALID_MODIFIER;\n      yr_compiler_set_error_extra_info(\n          compiler,\n          modifier.flags & STRING_FLAGS_BASE64 ?\n             \"base64 nocase\" :\n             \"base64wide nocase\")\n      goto _exit;\n  }\n\n  // base64 and fullword together is not implemented.\n  if (modifier.flags & STRING_FLAGS_FULL_WORD &&\n      (modifier.flags & STRING_FLAGS_BASE64 ||\n       modifier.flags & STRING_FLAGS_BASE64_WIDE))\n  {\n      result = ERROR_INVALID_MODIFIER;\n      yr_compiler_set_error_extra_info(\n          compiler,\n          modifier.flags & STRING_FLAGS_BASE64 ?\n             \"base64 fullword\" :\n             \"base64wide fullword\")\n      goto _exit;\n  }\n\n  // base64 and xor together is not implemented.\n  if (modifier.flags & STRING_FLAGS_XOR &&\n      (modifier.flags & STRING_FLAGS_BASE64 ||\n       modifier.flags & STRING_FLAGS_BASE64_WIDE))\n  {\n      result = ERROR_INVALID_MODIFIER;\n      yr_compiler_set_error_extra_info(\n          compiler,\n          modifier.flags & STRING_FLAGS_BASE64 ?\n             \"base64 xor\" :\n             \"base64wide xor\")\n      goto _exit;\n  }\n\n  if (!(modifier.flags & STRING_FLAGS_WIDE) &&\n      !(modifier.flags & STRING_FLAGS_XOR) &&\n      !(modifier.flags & STRING_FLAGS_BASE64 ||\n        modifier.flags & STRING_FLAGS_BASE64_WIDE))\n  {\n    modifier.flags |= STRING_FLAGS_ASCII;\n  }\n\n  // The STRING_FLAGS_SINGLE_MATCH flag indicates that finding\n  // a single match for the string is enough. This is true in\n  // most cases, except when the string count (#) and string offset (@)\n  // operators are used. All strings are marked STRING_FLAGS_SINGLE_MATCH\n  // initially, and unmarked later if required.\n  modifier.flags |= STRING_FLAGS_SINGLE_MATCH;\n\n  // The STRING_FLAGS_FIXED_OFFSET indicates that the string doesn't\n  // need to be searched all over the file because the user is using the\n  // \"at\" operator. The string must be searched at a fixed offset in the\n  // file. All strings are marked STRING_FLAGS_FIXED_OFFSET initially,\n  // and unmarked later if required.\n  modifier.flags |= STRING_FLAGS_FIXED_OFFSET;\n\n\n  if (modifier.flags & STRING_FLAGS_HEXADECIMAL ||\n      modifier.flags & STRING_FLAGS_REGEXP ||\n      modifier.flags & STRING_FLAGS_BASE64 ||\n      modifier.flags & STRING_FLAGS_BASE64_WIDE)\n  {\n    if (modifier.flags & STRING_FLAGS_HEXADECIMAL)\n      result = yr_re_parse_hex(str->c_string, &re_ast, &re_error);\n    else if (modifier.flags & STRING_FLAGS_REGEXP)\n      result = yr_re_parse(str->c_string, &re_ast, &re_error);\n    else\n      result = yr_base64_ast_from_string(str, modifier, &re_ast, &re_error);\n\n    if (result != ERROR_SUCCESS)\n    {\n      snprintf(\n          message,\n          sizeof(message),\n          \"invalid %s \\\"%s\\\": %s\",\n          (modifier.flags & STRING_FLAGS_HEXADECIMAL) ?\n              \"hex string\" : \"regular expression\",\n          identifier,\n          re_error.message);\n\n      yr_compiler_set_error_extra_info(\n          compiler, message)\n\n      goto _exit;\n    }\n\n    if (re_ast->flags & RE_FLAGS_FAST_REGEXP)\n      modifier.flags |= STRING_FLAGS_FAST_REGEXP;\n\n    if (re_ast->flags & RE_FLAGS_GREEDY)\n      modifier.flags |= STRING_FLAGS_GREEDY_REGEXP;\n\n    // Regular expressions in the strings section can't mix greedy and ungreedy\n    // quantifiers like .* and .*?. That's because these regular expressions can\n    // be matched forwards and/or backwards depending on the atom found, and we\n    // need the regexp to be all-greedy or all-ungreedy to be able to properly\n    // calculate the length of the match.\n\n    if ((re_ast->flags & RE_FLAGS_GREEDY) &&\n        (re_ast->flags & RE_FLAGS_UNGREEDY))\n    {\n      result = ERROR_INVALID_REGULAR_EXPRESSION;\n\n      yr_compiler_set_error_extra_info(compiler,\n          \"greedy and ungreedy quantifiers can't be mixed in a regular \"\n          \"expression\")\n\n      goto _exit;\n    }\n\n    if (yr_re_ast_contains_dot_star(re_ast))\n    {\n      yywarning(\n          yyscanner,\n          \"%s contains .* or .+, consider using .{,N} or .{1,N} with a reasonable value for N\",\n          identifier);\n    }\n\n    if (compiler->re_ast_callback != NULL)\n    {\n      compiler->re_ast_callback(\n          current_rule,\n          identifier,\n          re_ast,\n          compiler->re_ast_clbk_user_data);\n    }\n\n    *string_ref = YR_ARENA_NULL_REF;\n\n    while (re_ast != NULL)\n    {\n      YR_ARENA_REF ref;\n\n      uint32_t prev_string_idx = compiler->current_string_idx - 1;\n\n      int32_t prev_min_gap = min_gap;\n      int32_t prev_max_gap = max_gap;\n\n      result = yr_re_ast_split_at_chaining_point(\n          re_ast, &remainder_re_ast, &min_gap, &max_gap);\n\n      if (result != ERROR_SUCCESS)\n        goto _exit;\n\n      result = _yr_parser_write_string(\n          identifier,\n          modifier,\n          compiler,\n          NULL,\n          re_ast,\n          &ref,\n          &atom_quality,\n          &current_rule->num_atoms);\n\n      if (result != ERROR_SUCCESS)\n        goto _exit;\n\n      if (atom_quality < min_atom_quality)\n        min_atom_quality = atom_quality;\n\n      if (YR_ARENA_IS_NULL_REF(*string_ref))\n      {\n        // This is the first string in the chain, the string reference returned\n        // by this function must point to this string.\n        *string_ref = ref;\n      }\n      else\n      {\n        // This is not the first string in the chain, set the appropriate flags\n        // and fill the chained_to, chain_gap_min and chain_gap_max fields.\n        YR_STRING* prev_string = (YR_STRING*) yr_arena_get_ptr(\n            compiler->arena,\n            YR_STRINGS_TABLE,\n            prev_string_idx * sizeof(YR_STRING));\n\n        YR_STRING* new_string = (YR_STRING*) yr_arena_ref_to_ptr(\n            compiler->arena, &ref);\n\n        new_string->chained_to = prev_string;\n        new_string->chain_gap_min = prev_min_gap;\n        new_string->chain_gap_max = prev_max_gap;\n\n        // A string chained to another one can't have a fixed offset, only the\n        // head of the string chain can have a fixed offset.\n        new_string->flags &= ~STRING_FLAGS_FIXED_OFFSET;\n\n        // There is a previous string, but that string wasn't marked as part of\n        // a chain because we can't do that until knowing there will be another\n        // string, let's flag it now the we know.\n        prev_string->flags |= STRING_FLAGS_CHAIN_PART;\n\n        // There is a previous string, so this string is part of a chain, but\n        // there will be no more strings because there are no more AST to split,\n        // which means that this is the chain's tail.\n        if (remainder_re_ast == NULL)\n          new_string->flags |= STRING_FLAGS_CHAIN_PART |\n                               STRING_FLAGS_CHAIN_TAIL;\n      }\n\n      yr_re_ast_destroy(re_ast);\n      re_ast = remainder_re_ast;\n    }\n  }\n  else  // not a STRING_FLAGS_HEXADECIMAL or STRING_FLAGS_REGEXP or\n        // STRING_FLAGS_BASE64 or STRING_FLAGS_BASE64_WIDE\n  {\n    result = _yr_parser_write_string(\n        identifier,\n        modifier,\n        compiler,\n        str,\n        NULL,\n        string_ref,\n        &min_atom_quality,\n        &current_rule->num_atoms);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n  }\n\n  if (min_atom_quality < compiler->atoms_config.quality_warning_threshold)\n  {\n    yywarning(yyscanner, \"%s is slowing down scanning\", identifier);\n  }\n\n_exit:\n\n  if (re_ast != NULL)\n    yr_re_ast_destroy(re_ast);\n\n  if (remainder_re_ast != NULL)\n    yr_re_ast_destroy(remainder_re_ast);\n\n  return result;\n}",
        "begin_line": 517,
        "end_line": 844,
        "is_bug": false
    },
    {
        "name": "libyara.re._yr_emit_inst#568",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re._yr_emit_inst(     RE_EMIT_CONTEXT* emit_context, uint8_t opcode, YR_ARENA_REF* instruction_ref)",
        "snippet": "int _yr_emit_inst(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    YR_ARENA_REF* instruction_ref)\n{\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      YR_RE_CODE_SECTION,\n      &opcode,\n      sizeof(uint8_t),\n      instruction_ref));\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 568,
        "end_line": 581,
        "is_bug": false
    },
    {
        "name": "libyara.re._yr_emit_inst_arg_uint16#609",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re._yr_emit_inst_arg_uint16(     RE_EMIT_CONTEXT* emit_context, uint8_t opcode, uint16_t argument, YR_ARENA_REF* instruction_ref, YR_ARENA_REF* argument_ref)",
        "snippet": "int _yr_emit_inst_arg_uint16(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    uint16_t argument,\n    YR_ARENA_REF* instruction_ref,\n    YR_ARENA_REF* argument_ref)\n{\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      YR_RE_CODE_SECTION,\n      &opcode,\n      sizeof(uint8_t),\n      instruction_ref));\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      YR_RE_CODE_SECTION,\n      &argument,\n      sizeof(uint16_t),\n      argument_ref));\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 609,
        "end_line": 631,
        "is_bug": false
    },
    {
        "name": "libyara.re._yr_emit_inst_arg_uint8#584",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re._yr_emit_inst_arg_uint8(     RE_EMIT_CONTEXT* emit_context, uint8_t opcode, uint8_t argument, YR_ARENA_REF* instruction_ref, YR_ARENA_REF* argument_ref)",
        "snippet": "int _yr_emit_inst_arg_uint8(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    uint8_t argument,\n    YR_ARENA_REF* instruction_ref,\n    YR_ARENA_REF* argument_ref)\n{\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      YR_RE_CODE_SECTION,\n      &opcode,\n      sizeof(uint8_t),\n      instruction_ref));\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      YR_RE_CODE_SECTION,\n      &argument,\n      sizeof(uint8_t),\n      argument_ref));\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 584,
        "end_line": 606,
        "is_bug": false
    },
    {
        "name": "libyara.re._yr_re_emit#752",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re._yr_re_emit(     RE_EMIT_CONTEXT* emit_context, RE_NODE* re_node, int flags, YR_ARENA_REF* code_ref)",
        "snippet": "static int _yr_re_emit(\n    RE_EMIT_CONTEXT* emit_context,\n    RE_NODE* re_node,\n    int flags,\n    YR_ARENA_REF* code_ref)\n{\n  yr_arena_off_t jmp_offset;\n\n  yr_arena_off_t bookmark_1 = 0;\n  yr_arena_off_t bookmark_2 = 0;\n  yr_arena_off_t bookmark_3 = 0;\n  yr_arena_off_t bookmark_4 = 0;\n\n  bool emit_split;\n  bool emit_repeat;\n  bool emit_prolog;\n  bool emit_epilog;\n\n  RE_REPEAT_ARGS repeat_args;\n  RE_REPEAT_ARGS* repeat_start_args_addr;\n  RE_REPEAT_ANY_ARGS repeat_any_args;\n\n  RE_NODE* child;\n\n  int16_t* split_offset_addr = NULL;\n  int16_t* jmp_offset_addr = NULL;\n\n  YR_ARENA_REF instruction_ref = YR_ARENA_NULL_REF;\n  YR_ARENA_REF split_offset_ref;\n  YR_ARENA_REF jmp_instruction_ref;\n  YR_ARENA_REF jmp_offset_ref;\n  YR_ARENA_REF repeat_start_args_ref;\n\n  switch(re_node->type)\n  {\n  case RE_NODE_LITERAL:\n    FAIL_ON_ERROR(_yr_emit_inst_arg_uint8(\n        emit_context,\n        RE_OPCODE_LITERAL,\n        re_node->value,\n        &instruction_ref,\n        NULL));\n    break;\n\n  case RE_NODE_MASKED_LITERAL:\n    FAIL_ON_ERROR(_yr_emit_inst_arg_uint16(\n        emit_context,\n        RE_OPCODE_MASKED_LITERAL,\n        re_node->mask << 8 | re_node->value,\n        &instruction_ref,\n        NULL));\n    break;\n\n  case RE_NODE_WORD_CHAR:\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_WORD_CHAR,\n        &instruction_ref));\n    break;\n\n  case RE_NODE_NON_WORD_CHAR:\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_NON_WORD_CHAR,\n        &instruction_ref));\n    break;\n\n  case RE_NODE_WORD_BOUNDARY:\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_WORD_BOUNDARY,\n        &instruction_ref));\n    break;\n\n  case RE_NODE_NON_WORD_BOUNDARY:\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_NON_WORD_BOUNDARY,\n        &instruction_ref));\n    break;\n\n  case RE_NODE_SPACE:\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_SPACE,\n        &instruction_ref));\n    break;\n\n  case RE_NODE_NON_SPACE:\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_NON_SPACE,\n        &instruction_ref));\n    break;\n\n  case RE_NODE_DIGIT:\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_DIGIT,\n        &instruction_ref));\n    break;\n\n  case RE_NODE_NON_DIGIT:\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_NON_DIGIT,\n        &instruction_ref));\n    break;\n\n  case RE_NODE_ANY:\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_ANY,\n        &instruction_ref));\n    break;\n\n  case RE_NODE_CLASS:\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_CLASS,\n        &instruction_ref));\n\n    FAIL_ON_ERROR(yr_arena_write_data(\n        emit_context->arena,\n        YR_RE_CODE_SECTION,\n        re_node->re_class,\n        sizeof(*re_node->re_class),\n        NULL));\n    break;\n\n  case RE_NODE_ANCHOR_START:\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_MATCH_AT_START,\n        &instruction_ref));\n    break;\n\n  case RE_NODE_ANCHOR_END:\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_MATCH_AT_END,\n        &instruction_ref));\n    break;\n\n  case RE_NODE_CONCAT:\n    FAIL_ON_ERROR(_yr_re_emit(\n        emit_context,\n        (flags & EMIT_BACKWARDS)?\n            re_node->children_tail:\n            re_node->children_head,\n        flags,\n        &instruction_ref));\n\n    if (flags & EMIT_BACKWARDS)\n      child = re_node->children_tail->prev_sibling;\n    else\n      child = re_node->children_head->next_sibling;\n\n    while (child != NULL)\n    {\n      FAIL_ON_ERROR(_yr_re_emit(\n          emit_context,\n          child,\n          flags,\n          NULL));\n\n      child = (flags & EMIT_BACKWARDS) ?\n          child->prev_sibling:\n          child->next_sibling;\n    }\n    break;\n\n  case RE_NODE_PLUS:\n    // Code for e+ looks like:\n    //\n    //          L1: code for e\n    //              split L1, L2\n    //          L2:\n    //\n    FAIL_ON_ERROR(_yr_re_emit(\n        emit_context,\n        re_node->children_head,\n        flags,\n        &instruction_ref));\n\n    jmp_offset = instruction_ref.offset - current_re_code_offset();\n\n    if (jmp_offset < INT16_MIN)\n      return ERROR_REGULAR_EXPRESSION_TOO_LARGE;\n\n    FAIL_ON_ERROR(_yr_emit_split(\n        emit_context,\n        re_node->greedy ? RE_OPCODE_SPLIT_B : RE_OPCODE_SPLIT_A,\n        (int16_t) jmp_offset,\n        NULL,\n        NULL));\n\n    break;\n\n  case RE_NODE_STAR:\n    // Code for e* looks like:\n    //\n    //          L1: split L1, L2\n    //              code for e\n    //              jmp L1\n    //          L2:\n    FAIL_ON_ERROR(_yr_emit_split(\n        emit_context,\n        re_node->greedy ? RE_OPCODE_SPLIT_A : RE_OPCODE_SPLIT_B,\n        0,\n        &instruction_ref,\n        &split_offset_ref));\n\n    FAIL_ON_ERROR(_yr_re_emit(\n        emit_context,\n        re_node->children_head,\n        flags,\n        NULL));\n\n    jmp_offset = instruction_ref.offset - current_re_code_offset();\n\n    if (jmp_offset < INT16_MIN)\n      return ERROR_REGULAR_EXPRESSION_TOO_LARGE;\n\n    // Emit jump with offset set to 0.\n\n    FAIL_ON_ERROR(_yr_emit_inst_arg_int16(\n        emit_context,\n        RE_OPCODE_JUMP,\n        (int16_t) jmp_offset,\n        NULL,\n        NULL));\n\n    jmp_offset = current_re_code_offset() - instruction_ref.offset;\n\n    if (jmp_offset > INT16_MAX)\n      return ERROR_REGULAR_EXPRESSION_TOO_LARGE;\n\n    // Update split offset.\n    split_offset_addr = (int16_t*) yr_arena_ref_to_ptr(\n        emit_context->arena, &split_offset_ref);\n\n    *split_offset_addr = (int16_t) jmp_offset;\n    break;\n\n  case RE_NODE_ALT:\n    // Code for e1|e2 looks like:\n    //\n    //              split L1, L2\n    //          L1: code for e1\n    //              jmp L3\n    //          L2: code for e2\n    //          L3:\n\n    // Emit a split instruction with offset set to 0 temporarily. Offset\n    // will be updated after we know the size of the code generated for\n    // the left node (e1).\n\n    FAIL_ON_ERROR(_yr_emit_split(\n        emit_context,\n        RE_OPCODE_SPLIT_A,\n        0,\n        &instruction_ref,\n        &split_offset_ref));\n\n    FAIL_ON_ERROR(_yr_re_emit(\n        emit_context,\n        re_node->children_head,\n        flags,\n        NULL));\n\n    // Emit jump with offset set to 0.\n\n    FAIL_ON_ERROR(_yr_emit_inst_arg_int16(\n        emit_context,\n        RE_OPCODE_JUMP,\n        0,\n        &jmp_instruction_ref,\n        &jmp_offset_ref));\n\n    jmp_offset = current_re_code_offset() - instruction_ref.offset;\n\n    if (jmp_offset > INT16_MAX)\n      return ERROR_REGULAR_EXPRESSION_TOO_LARGE;\n\n    // Update split offset.\n    split_offset_addr = (int16_t*) yr_arena_ref_to_ptr(\n          emit_context->arena, &split_offset_ref);\n\n    *split_offset_addr = (int16_t) jmp_offset;\n\n    FAIL_ON_ERROR(_yr_re_emit(\n        emit_context,\n        re_node->children_tail,\n        flags,\n        NULL));\n\n    jmp_offset = current_re_code_offset() - jmp_instruction_ref.offset;\n\n    if (jmp_offset > INT16_MAX)\n      return ERROR_REGULAR_EXPRESSION_TOO_LARGE;\n\n    // Update offset for jmp instruction.\n    jmp_offset_addr = (int16_t*) yr_arena_ref_to_ptr(\n          emit_context->arena, &jmp_offset_ref);\n\n    *jmp_offset_addr = (int16_t) jmp_offset;\n    break;\n\n  case RE_NODE_RANGE_ANY:\n    repeat_any_args.min = re_node->start;\n    repeat_any_args.max = re_node->end;\n\n    FAIL_ON_ERROR(_yr_emit_inst_arg_struct(\n        emit_context,\n        re_node->greedy ?\n            RE_OPCODE_REPEAT_ANY_GREEDY :\n            RE_OPCODE_REPEAT_ANY_UNGREEDY,\n        &repeat_any_args,\n        sizeof(repeat_any_args),\n        &instruction_ref,\n        NULL));\n\n    break;\n\n  case RE_NODE_RANGE:\n    // Code for e{n,m} looks like:\n    //\n    //            code for e              ---   prolog\n    //            repeat_start n, m, L1   --+\n    //        L0: code for e                |   repeat\n    //            repeat_end n, m, L0     --+\n    //        L1: split L2, L3            ---   split\n    //        L2: code for e              ---   epilog\n    //        L3:\n    //\n    // Not all sections (prolog, repeat, split and epilog) are generated in all\n    // cases, it depends on the values of n and m. The following table shows\n    // which sections are generated for the first few values of n and m.\n    //\n    //        n,m   prolog  repeat      split  epilog\n    //                      (min,max)\n    //        ---------------------------------------\n    //        0,0     -       -           -      -\n    //        0,1     -       -           X      X\n    //        0,2     -       0,1         X      X\n    //        0,3     -       0,2         X      X\n    //        0,M     -       0,M-1       X      X\n    //\n    //        1,1     X       -           -      -\n    //        1,2     X       -           X      X\n    //        1,3     X       0,1         X      X\n    //        1,4     X       1,2         X      X\n    //        1,M     X       1,M-2       X      X\n    //\n    //        2,2     X       -           -      X\n    //        2,3     X       1,1         X      X\n    //        2,4     X       1,2         X      X\n    //        2,M     X       1,M-2       X      X\n    //\n    //        3,3     X       1,1         -      X\n    //        3,4     X       2,2         X      X\n    //        3,M     X       2,M-2       X      X\n    //\n    //        4,4     X       2,2         -      X\n    //        4,5     X       3,3         X      X\n    //        4,M     X       3,M-2       X      X\n    //\n    // The code can't consists simply in the repeat section, the prolog and\n    // epilog are required because we can't have atoms pointing to code inside\n    // the repeat loop. Atoms' forwards_code will point to code in the prolog\n    // and backwards_code will point to code in the epilog (or in prolog if\n    // epilog wasn't generated, like in n=1,m=1)\n\n    emit_prolog = re_node->start > 0;\n    emit_repeat = re_node->end > re_node->start + 1 || re_node->end > 2;\n    emit_split = re_node->end > re_node->start;\n    emit_epilog = re_node->end > re_node->start || re_node->end > 1;\n\n    if (emit_prolog)\n    {\n      FAIL_ON_ERROR(_yr_re_emit(\n          emit_context,\n          re_node->children_head,\n          flags,\n          &instruction_ref));\n    }\n\n    if (emit_repeat)\n    {\n      repeat_args.min = re_node->start;\n      repeat_args.max = re_node->end;\n\n      if (emit_prolog)\n      {\n        repeat_args.max--;\n        repeat_args.min--;\n      }\n\n      if (emit_split)\n      {\n        repeat_args.max--;\n      }\n      else\n      {\n        repeat_args.min--;\n        repeat_args.max--;\n      }\n\n      repeat_args.offset = 0;\n\n      bookmark_1 = current_re_code_offset();\n\n      FAIL_ON_ERROR(_yr_emit_inst_arg_struct(\n          emit_context,\n          re_node->greedy ?\n              RE_OPCODE_REPEAT_START_GREEDY :\n              RE_OPCODE_REPEAT_START_UNGREEDY,\n          &repeat_args,\n          sizeof(repeat_args),\n          emit_prolog ? NULL : &instruction_ref,\n          &repeat_start_args_ref));\n\n      bookmark_2 = current_re_code_offset();\n\n      FAIL_ON_ERROR(_yr_re_emit(\n          emit_context,\n          re_node->children_head,\n          flags | EMIT_DONT_SET_FORWARDS_CODE | EMIT_DONT_SET_BACKWARDS_CODE,\n          NULL));\n\n      bookmark_3 = current_re_code_offset();\n\n      if (bookmark_2 - bookmark_3 < INT32_MIN)\n        return ERROR_REGULAR_EXPRESSION_TOO_LARGE;\n\n      repeat_args.offset = (int32_t)(bookmark_2 - bookmark_3);\n\n      FAIL_ON_ERROR(_yr_emit_inst_arg_struct(\n          emit_context,\n          re_node->greedy ?\n              RE_OPCODE_REPEAT_END_GREEDY :\n              RE_OPCODE_REPEAT_END_UNGREEDY,\n          &repeat_args,\n          sizeof(repeat_args),\n          NULL,\n          NULL));\n\n      bookmark_4 = current_re_code_offset();\n\n      repeat_start_args_addr = (RE_REPEAT_ARGS*) yr_arena_ref_to_ptr(\n          emit_context->arena, &repeat_start_args_ref);\n\n      if (bookmark_4 - bookmark_1 > INT32_MAX)\n        return ERROR_REGULAR_EXPRESSION_TOO_LARGE;\n\n      repeat_start_args_addr->offset = (int32_t)(bookmark_4 - bookmark_1);\n    }\n\n    if (emit_split)\n    {\n      bookmark_1 = current_re_code_offset();\n\n      FAIL_ON_ERROR(_yr_emit_split(\n          emit_context,\n          re_node->greedy ?\n              RE_OPCODE_SPLIT_A :\n              RE_OPCODE_SPLIT_B,\n          0,\n          NULL,\n          &split_offset_ref));\n    }\n\n    if (emit_epilog)\n    {\n      FAIL_ON_ERROR(_yr_re_emit(\n          emit_context,\n          re_node->children_head,\n          emit_prolog ? flags | EMIT_DONT_SET_FORWARDS_CODE : flags,\n          emit_prolog || emit_repeat ? NULL : &instruction_ref));\n    }\n\n    if (emit_split)\n    {\n      bookmark_2 = current_re_code_offset();\n\n      if (bookmark_2 - bookmark_1 > INT16_MAX)\n        return ERROR_REGULAR_EXPRESSION_TOO_LARGE;\n\n      split_offset_addr = (int16_t*) yr_arena_ref_to_ptr(\n          emit_context->arena, &split_offset_ref);\n\n      *split_offset_addr = (int16_t) (bookmark_2 - bookmark_1);\n    }\n\n    break;\n  }\n\n  if (flags & EMIT_BACKWARDS)\n  {\n    if (!(flags & EMIT_DONT_SET_BACKWARDS_CODE))\n    {\n      re_node->backward_code_ref.buffer_id = YR_RE_CODE_SECTION;\n      re_node->backward_code_ref.offset = yr_arena_get_current_offset(\n          emit_context->arena, YR_RE_CODE_SECTION);\n    }\n  }\n  else\n  {\n    if (!(flags & EMIT_DONT_SET_FORWARDS_CODE))\n    {\n      re_node->forward_code_ref = instruction_ref;\n    }\n  }\n\n  if (code_ref != NULL)\n    *code_ref = instruction_ref;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 752,
        "end_line": 1271,
        "is_bug": false
    },
    {
        "name": "libyara.re._yr_re_node_contains_dot_star#409",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re._yr_re_node_contains_dot_star(     RE_NODE* re_node)",
        "snippet": "int _yr_re_node_contains_dot_star(\n    RE_NODE* re_node)\n{\n  RE_NODE* child;\n\n  if ((re_node->type == RE_NODE_STAR || re_node->type == RE_NODE_PLUS) &&\n      re_node->children_head->type == RE_NODE_ANY)\n    return true;\n\n  if (re_node->type == RE_NODE_CONCAT)\n  {\n    child = re_node->children_tail;\n\n    while (child != NULL)\n    {\n      if (_yr_re_node_contains_dot_star(child))\n        return true;\n\n      child = child->prev_sibling;\n    }\n  }\n\n  return false;\n}",
        "begin_line": 409,
        "end_line": 432,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_ast_contains_dot_star#435",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_ast_contains_dot_star(     RE_AST* re_ast)",
        "snippet": "int yr_re_ast_contains_dot_star(\n    RE_AST* re_ast)\n{\n  return _yr_re_node_contains_dot_star(re_ast->root_node);\n}",
        "begin_line": 435,
        "end_line": 439,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_ast_create#209",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_ast_create(     RE_AST** re_ast)",
        "snippet": "int yr_re_ast_create(\n    RE_AST** re_ast)\n{\n  *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));\n\n  if (*re_ast == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  (*re_ast)->flags = 0;\n  (*re_ast)->root_node = NULL;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 209,
        "end_line": 221,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_ast_destroy#224",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_ast_destroy(     RE_AST* re_ast)",
        "snippet": "void yr_re_ast_destroy(\n    RE_AST* re_ast)\n{\n  if (re_ast->root_node != NULL)\n    yr_re_node_destroy(re_ast->root_node);\n\n  yr_free(re_ast);\n}",
        "begin_line": 224,
        "end_line": 231,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_ast_emit_code#1274",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_ast_emit_code(     RE_AST* re_ast, YR_ARENA* arena, int backwards_code)",
        "snippet": "int yr_re_ast_emit_code(\n    RE_AST* re_ast,\n    YR_ARENA* arena,\n    int backwards_code)\n{\n  RE_EMIT_CONTEXT emit_context;\n\n  // Emit code for matching the regular expressions forwards.\n  emit_context.arena = arena;\n  emit_context.next_split_id = 0;\n\n  FAIL_ON_ERROR(_yr_re_emit(\n      &emit_context,\n      re_ast->root_node,\n      backwards_code ? EMIT_BACKWARDS : 0,\n      NULL));\n\n  FAIL_ON_ERROR(_yr_emit_inst(\n      &emit_context,\n      RE_OPCODE_MATCH,\n      NULL));\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 1274,
        "end_line": 1297,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_ast_extract_literal#353",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_ast_extract_literal(     RE_AST* re_ast)",
        "snippet": "SIZED_STRING* yr_re_ast_extract_literal(\n    RE_AST* re_ast)\n{\n  SIZED_STRING* string;\n  RE_NODE* child;\n\n  int length = 0;\n\n  if (re_ast->root_node->type == RE_NODE_LITERAL)\n  {\n    length = 1;\n  }\n  else if (re_ast->root_node->type == RE_NODE_CONCAT)\n  {\n    child = re_ast->root_node->children_tail;\n\n    while (child != NULL && child->type == RE_NODE_LITERAL)\n    {\n      length++;\n      child = child->prev_sibling;\n    }\n\n    if (child != NULL)\n      return NULL;\n  }\n  else\n  {\n    return NULL;\n  }\n\n  string = (SIZED_STRING*) yr_malloc(sizeof(SIZED_STRING) + length);\n\n  if (string == NULL)\n    return NULL;\n\n  string->length = length;\n  string->flags = 0;\n\n  if (re_ast->root_node->type == RE_NODE_LITERAL)\n  {\n    string->c_string[0] = re_ast->root_node->value;\n  }\n  else\n  {\n    child = re_ast->root_node->children_tail;\n    while (child != NULL)\n    {\n      string->c_string[--length] = child->value;\n      child = child->prev_sibling;\n    }\n  }\n\n  return string;\n}",
        "begin_line": 353,
        "end_line": 406,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_ast_split_at_chaining_point#503",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_ast_split_at_chaining_point(     RE_AST* re_ast, RE_AST** remainder_re_ast, int32_t* min_gap, int32_t* max_gap)",
        "snippet": "int yr_re_ast_split_at_chaining_point(\n    RE_AST* re_ast,\n    RE_AST** remainder_re_ast,\n    int32_t* min_gap,\n    int32_t* max_gap)\n{\n  RE_NODE* child;\n  RE_NODE* concat;\n\n  int result;\n\n  *remainder_re_ast = NULL;\n  *min_gap = 0;\n  *max_gap = 0;\n\n  if (re_ast->root_node->type != RE_NODE_CONCAT)\n    return ERROR_SUCCESS;\n\n  child = re_ast->root_node->children_head;\n\n  while (child != NULL)\n  {\n    if (!child->greedy &&\n         child->type == RE_NODE_RANGE_ANY &&\n         child->prev_sibling != NULL &&\n         child->next_sibling != NULL &&\n        (child->start > YR_STRING_CHAINING_THRESHOLD ||\n         child->end > YR_STRING_CHAINING_THRESHOLD))\n    {\n      result = yr_re_ast_create(remainder_re_ast);\n\n      if (result != ERROR_SUCCESS)\n        return result;\n\n      concat = yr_re_node_create(RE_NODE_CONCAT);\n\n      if (concat == NULL)\n        return ERROR_INSUFFICIENT_MEMORY;\n\n      concat->children_head = child->next_sibling;\n      concat->children_tail = re_ast->root_node->children_tail;\n\n      re_ast->root_node->children_tail = child->prev_sibling;\n\n      child->prev_sibling->next_sibling = NULL;\n      child->next_sibling->prev_sibling = NULL;\n\n      *min_gap = child->start;\n      *max_gap = child->end;\n\n      (*remainder_re_ast)->root_node = concat;\n      (*remainder_re_ast)->flags = re_ast->flags;\n\n      yr_re_node_destroy(child);\n\n      return ERROR_SUCCESS;\n    }\n\n    child = child->next_sibling;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 503,
        "end_line": 565,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_node_append_child#173",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_node_append_child(     RE_NODE* node, RE_NODE* child)",
        "snippet": "void yr_re_node_append_child(\n    RE_NODE* node,\n    RE_NODE* child)\n{\n  if (node->children_head == NULL)\n    node->children_head = child;\n\n  if (node->children_tail != NULL)\n    node->children_tail->next_sibling = child;\n\n  child->prev_sibling = node->children_tail;\n  node->children_tail = child;\n}",
        "begin_line": 173,
        "end_line": 185,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_node_create#127",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_node_create(     int type)",
        "snippet": "RE_NODE* yr_re_node_create(\n    int type)\n{\n  RE_NODE* result = (RE_NODE*) yr_malloc(sizeof(RE_NODE));\n\n  if (result != NULL)\n  {\n    result->type = type;\n    result->children_head = NULL;\n    result->children_tail = NULL;\n    result->prev_sibling = NULL;\n    result->next_sibling = NULL;\n    result->greedy = true;\n    result->forward_code_ref = YR_ARENA_NULL_REF;\n    result->backward_code_ref = YR_ARENA_NULL_REF;\n  }\n\n  return result;\n}",
        "begin_line": 127,
        "end_line": 145,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_node_destroy#148",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_node_destroy(     RE_NODE* node)",
        "snippet": "void yr_re_node_destroy(\n    RE_NODE* node)\n{\n  RE_NODE* child = node->children_head;\n  RE_NODE* next_child;\n\n  while (child != NULL)\n  {\n    next_child = child->next_sibling;\n    yr_re_node_destroy(child);\n    child = next_child;\n  }\n\n  if (node->type == RE_NODE_CLASS)\n    yr_free(node->re_class);\n\n  yr_free(node);\n}",
        "begin_line": 148,
        "end_line": 165,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_node_prepend_child#193",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_node_prepend_child(     RE_NODE* node, RE_NODE* child)",
        "snippet": "void yr_re_node_prepend_child(\n    RE_NODE* node,\n    RE_NODE* child)\n{\n  child->next_sibling = node->children_head;\n\n  if (node->children_head != NULL)\n    node->children_head->prev_sibling = child;\n\n  node->children_head = child;\n\n  if (node->children_tail == NULL)\n    node->children_tail = child;\n}",
        "begin_line": 193,
        "end_line": 206,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_parse#241",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_parse(     const char* re_string, RE_AST** re_ast, RE_ERROR* error)",
        "snippet": "int yr_re_parse(\n    const char* re_string,\n    RE_AST** re_ast,\n    RE_ERROR* error)\n{\n  return yr_parse_re_string(re_string, re_ast, error);\n}",
        "begin_line": 241,
        "end_line": 247,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_parse_hex#257",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_parse_hex(     const char* hex_string, RE_AST** re_ast, RE_ERROR* error)",
        "snippet": "int yr_re_parse_hex(\n    const char* hex_string,\n    RE_AST** re_ast,\n    RE_ERROR* error)\n{\n  return yr_parse_hex_string(hex_string, re_ast, error);\n}",
        "begin_line": 257,
        "end_line": 263,
        "is_bug": false
    },
    {
        "name": "libyara.re_grammar.re_yyparse#1172",
        "src_path": "libyara/re_grammar.c",
        "class_name": "libyara.re_grammar",
        "signature": "libyara.re_grammar.)",
        "snippet": "int\nyyparse (void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)\n{\n/* The lookahead symbol.  */\nint yychar;\n\n\n/* The semantic value of the lookahead symbol.  */\n/* Default value used for initialization, for pacifying older GCCs\n   or non-GCC compilers.  */\nYY_INITIAL_VALUE (static YYSTYPE yyval_default;)\nYYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n\n    /* Number of syntax errors so far.  */\n    int yynerrs;\n\n    yy_state_fast_t yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yy_state_t yyssa[YYINITDEPTH];\n    yy_state_t *yyss;\n    yy_state_t *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYPTRDIFF_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYPTRDIFF_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n  goto yysetstate;\n\n\n/*------------------------------------------------------------.\n| yynewstate -- push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\nyynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n\n/*--------------------------------------------------------------------.\n| yysetstate -- set current state (the top of the stack) to yystate.  |\n`--------------------------------------------------------------------*/\nyysetstate:\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);\n  YY_IGNORE_USELESS_CAST_BEGIN\n  *yyssp = YY_CAST (yy_state_t, yystate);\n  YY_IGNORE_USELESS_CAST_END\n\n  if (yyss + yystacksize - 1 <= yyssp)\n#if !defined yyoverflow && !defined YYSTACK_RELOCATE\n    goto yyexhaustedlab;\n#else\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYPTRDIFF_T yysize = yyssp - yyss + 1;\n\n# if defined yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        yy_state_t *yyss1 = yyss;\n        YYSTYPE *yyvs1 = yyvs;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * YYSIZEOF (*yyssp),\n                    &yyvs1, yysize * YYSIZEOF (*yyvsp),\n                    &yystacksize);\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n# else /* defined YYSTACK_RELOCATE */\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yy_state_t *yyss1 = yyss;\n        union yyalloc *yyptr =\n          YY_CAST (union yyalloc *,\n                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n# undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YY_IGNORE_USELESS_CAST_BEGIN\n      YYDPRINTF ((stderr, \"Stack size increased to %ld\\n\",\n                  YY_CAST (long, yystacksize)));\n      YY_IGNORE_USELESS_CAST_END\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex (&yylval, yyscanner, lex_env);\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n  case 2:\n#line 105 \"re_grammar.y\"\n      {\n        RE_AST* re_ast = yyget_extra(yyscanner);\n        re_ast->root_node = (yyvsp[0].re_node);\n      }\n#line 1434 \"re_grammar.c\"\n    break;\n\n  case 4:\n#line 114 \"re_grammar.y\"\n      {\n        (yyval.re_node) = (yyvsp[0].re_node);\n      }\n#line 1442 \"re_grammar.c\"\n    break;\n\n  case 5:\n#line 118 \"re_grammar.y\"\n      {\n        mark_as_not_fast_regexp();\n\n        (yyval.re_node) = yr_re_node_create(RE_NODE_ALT);\n\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[0].re_node));\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        yr_re_node_append_child((yyval.re_node), (yyvsp[-2].re_node));\n        yr_re_node_append_child((yyval.re_node), (yyvsp[0].re_node));\n      }\n#line 1460 \"re_grammar.c\"\n    break;\n\n  case 6:\n#line 132 \"re_grammar.y\"\n      {\n        RE_NODE* node;\n\n        mark_as_not_fast_regexp();\n\n        node = yr_re_node_create(RE_NODE_EMPTY);\n\n        destroy_node_if(node == NULL, (yyvsp[-1].re_node));\n        fail_if(node == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        (yyval.re_node) = yr_re_node_create(RE_NODE_ALT);\n\n        destroy_node_if((yyval.re_node) == NULL, node);\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        yr_re_node_append_child((yyval.re_node), (yyvsp[-1].re_node));\n        yr_re_node_append_child((yyval.re_node), node);\n      }\n#line 1485 \"re_grammar.c\"\n    break;\n\n  case 7:\n#line 156 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT);\n\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[0].re_node));\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        yr_re_node_append_child((yyval.re_node), (yyvsp[0].re_node));\n      }\n#line 1498 \"re_grammar.c\"\n    break;\n\n  case 8:\n#line 165 \"re_grammar.y\"\n      {\n        yr_re_node_append_child((yyvsp[-1].re_node), (yyvsp[0].re_node));\n        (yyval.re_node) = (yyvsp[-1].re_node);\n      }\n#line 1507 \"re_grammar.c\"\n    break;\n\n  case 9:\n#line 173 \"re_grammar.y\"\n      {\n        RE_AST* re_ast;\n\n        mark_as_not_fast_regexp();\n\n        re_ast = yyget_extra(yyscanner);\n        re_ast->flags |= RE_FLAGS_GREEDY;\n\n        (yyval.re_node) = yr_re_node_create(RE_NODE_STAR);\n\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        yr_re_node_append_child((yyval.re_node), (yyvsp[-1].re_node));\n      }\n#line 1527 \"re_grammar.c\"\n    break;\n\n  case 10:\n#line 189 \"re_grammar.y\"\n      {\n        RE_AST* re_ast;\n\n        mark_as_not_fast_regexp();\n\n        re_ast = yyget_extra(yyscanner);\n        re_ast->flags |= RE_FLAGS_UNGREEDY;\n\n        (yyval.re_node) = yr_re_node_create(RE_NODE_STAR);\n\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        yr_re_node_append_child((yyval.re_node), (yyvsp[-2].re_node));\n\n        (yyval.re_node)->greedy = false;\n      }\n#line 1549 \"re_grammar.c\"\n    break;\n\n  case 11:\n#line 207 \"re_grammar.y\"\n      {\n        RE_AST* re_ast;\n\n        mark_as_not_fast_regexp();\n\n        re_ast = yyget_extra(yyscanner);\n        re_ast->flags |= RE_FLAGS_GREEDY;\n\n        (yyval.re_node) = yr_re_node_create(RE_NODE_PLUS);\n\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        yr_re_node_append_child((yyval.re_node), (yyvsp[-1].re_node));\n      }\n#line 1569 \"re_grammar.c\"\n    break;\n\n  case 12:\n#line 223 \"re_grammar.y\"\n      {\n        RE_AST* re_ast;\n\n        mark_as_not_fast_regexp();\n\n        re_ast = yyget_extra(yyscanner);\n        re_ast->flags |= RE_FLAGS_UNGREEDY;\n\n        (yyval.re_node) = yr_re_node_create(RE_NODE_PLUS);\n\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        yr_re_node_append_child((yyval.re_node), (yyvsp[-2].re_node));\n        (yyval.re_node)->greedy = false;\n      }\n#line 1590 \"re_grammar.c\"\n    break;\n\n  case 13:\n#line 240 \"re_grammar.y\"\n      {\n        RE_AST* re_ast = yyget_extra(yyscanner);\n        re_ast->flags |= RE_FLAGS_GREEDY;\n\n        if ((yyvsp[-1].re_node)->type == RE_NODE_ANY)\n        {\n          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);\n          destroy_node_if(true, (yyvsp[-1].re_node));\n          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n        }\n        else\n        {\n          mark_as_not_fast_regexp();\n          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE);\n          destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));\n          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n          yr_re_node_append_child((yyval.re_node), (yyvsp[-1].re_node));\n        }\n\n        (yyval.re_node)->start = 0;\n        (yyval.re_node)->end = 1;\n      }\n#line 1617 \"re_grammar.c\"\n    break;\n\n  case 14:\n#line 263 \"re_grammar.y\"\n      {\n        RE_AST* re_ast = yyget_extra(yyscanner);\n        re_ast->flags |= RE_FLAGS_UNGREEDY;\n\n        if ((yyvsp[-2].re_node)->type == RE_NODE_ANY)\n        {\n          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);\n          destroy_node_if(true, (yyvsp[-2].re_node));\n          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n        }\n        else\n        {\n          mark_as_not_fast_regexp();\n          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE);\n          destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));\n          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n          yr_re_node_append_child((yyval.re_node), (yyvsp[-2].re_node));\n        }\n\n        (yyval.re_node)->start = 0;\n        (yyval.re_node)->end = 1;\n        (yyval.re_node)->greedy = false;\n      }\n#line 1645 \"re_grammar.c\"\n    break;\n\n  case 15:\n#line 287 \"re_grammar.y\"\n      {\n        RE_AST* re_ast = yyget_extra(yyscanner);\n        re_ast->flags |= RE_FLAGS_GREEDY;\n\n        if ((yyvsp[-1].re_node)->type == RE_NODE_ANY)\n        {\n          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);\n          destroy_node_if(true, (yyvsp[-1].re_node));\n          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n        }\n        else\n        {\n          mark_as_not_fast_regexp();\n          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE);\n          destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));\n          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n          yr_re_node_append_child((yyval.re_node), (yyvsp[-1].re_node));\n        }\n\n        (yyval.re_node)->start = (yyvsp[0].range) & 0xFFFF;;\n        (yyval.re_node)->end = (yyvsp[0].range) >> 16;;\n      }\n#line 1672 \"re_grammar.c\"\n    break;\n\n  case 16:\n#line 310 \"re_grammar.y\"\n      {\n        RE_AST* re_ast = yyget_extra(yyscanner);\n        re_ast->flags |= RE_FLAGS_UNGREEDY;\n\n        if ((yyvsp[-2].re_node)->type == RE_NODE_ANY)\n        {\n          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);\n          destroy_node_if(true, (yyvsp[-2].re_node));\n          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n        }\n        else\n        {\n          mark_as_not_fast_regexp();\n          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE);\n          destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));\n          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n          yr_re_node_append_child((yyval.re_node), (yyvsp[-2].re_node));\n        }\n\n        (yyval.re_node)->start = (yyvsp[-1].range) & 0xFFFF;;\n        (yyval.re_node)->end = (yyvsp[-1].range) >> 16;;\n        (yyval.re_node)->greedy = false;\n      }\n#line 1700 \"re_grammar.c\"\n    break;\n\n  case 17:\n#line 334 \"re_grammar.y\"\n      {\n        (yyval.re_node) = (yyvsp[0].re_node);\n      }\n#line 1708 \"re_grammar.c\"\n    break;\n\n  case 18:\n#line 338 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_WORD_BOUNDARY);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n      }\n#line 1718 \"re_grammar.c\"\n    break;\n\n  case 19:\n#line 344 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_NON_WORD_BOUNDARY);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n      }\n#line 1728 \"re_grammar.c\"\n    break;\n\n  case 20:\n#line 350 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_ANCHOR_START);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n      }\n#line 1738 \"re_grammar.c\"\n    break;\n\n  case 21:\n#line 356 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_ANCHOR_END);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n      }\n#line 1748 \"re_grammar.c\"\n    break;\n\n  case 22:\n#line 365 \"re_grammar.y\"\n      {\n        (yyval.re_node) = (yyvsp[-1].re_node);\n      }\n#line 1756 \"re_grammar.c\"\n    break;\n\n  case 23:\n#line 369 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_ANY);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        (yyval.re_node)->value = 0x00;\n        (yyval.re_node)->mask = 0x00;\n      }\n#line 1769 \"re_grammar.c\"\n    break;\n\n  case 24:\n#line 378 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_LITERAL);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        (yyval.re_node)->value = (yyvsp[0].integer);\n        (yyval.re_node)->mask = 0xFF;\n      }\n#line 1782 \"re_grammar.c\"\n    break;\n\n  case 25:\n#line 387 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_WORD_CHAR);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n      }\n#line 1792 \"re_grammar.c\"\n    break;\n\n  case 26:\n#line 393 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_NON_WORD_CHAR);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n      }\n#line 1802 \"re_grammar.c\"\n    break;\n\n  case 27:\n#line 399 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_SPACE);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n      }\n#line 1812 \"re_grammar.c\"\n    break;\n\n  case 28:\n#line 405 \"re_grammar.y\"\n      {\n         (yyval.re_node) = yr_re_node_create(RE_NODE_NON_SPACE);\n\n         fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n      }\n#line 1822 \"re_grammar.c\"\n    break;\n\n  case 29:\n#line 411 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_DIGIT);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n      }\n#line 1832 \"re_grammar.c\"\n    break;\n\n  case 30:\n#line 417 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_NON_DIGIT);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n      }\n#line 1842 \"re_grammar.c\"\n    break;\n\n  case 31:\n#line 423 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_CLASS);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        (yyval.re_node)->re_class = (yyvsp[0].re_class);\n      }\n#line 1854 \"re_grammar.c\"\n    break;\n\n\n#line 1858 \"re_grammar.c\"\n\n      default: break;\n    }\n  /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n  {\n    const int yylhs = yyr1[yyn] - YYNTOKENS;\n    const int yyi = yypgoto[yylhs] + *yyssp;\n    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp\n               ? yytable[yyi]\n               : yydefgoto[yylhs]);\n  }\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (yyscanner, lex_env, YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        int yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = YY_CAST (char *, YYSTACK_ALLOC (YY_CAST (YYSIZE_T, yymsg_alloc)));\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (yyscanner, lex_env, yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n         error, discard it.  */\n\n      if (yychar <= YYEOF)\n        {\n          /* Return failure if at end of input.  */\n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval, yyscanner, lex_env);\n          yychar = YYEMPTY;\n        }\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n  /* Pacify compilers when the user code never invokes YYERROR and the\n     label yyerrorlab therefore never appears in user code.  */\n  if (0)\n    YYERROR;\n\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYTERROR;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n        YYABORT;\n\n\n      yydestruct (\"Error: popping\",\n                  yystos[yystate], yyvsp, yyscanner, lex_env);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (yyscanner, lex_env, YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\n\n/*-----------------------------------------------------.\n| yyreturn -- parsing is finished, return the result.  |\n`-----------------------------------------------------*/\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval, yyscanner, lex_env);\n    }\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  yystos[+*yyssp], yyvsp, yyscanner, lex_env);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n#endif\n  return yyresult;\n}",
        "begin_line": 1172,
        "end_line": 2088,
        "is_bug": false
    },
    {
        "name": "libyara.re_grammar.yydestruct#1116",
        "src_path": "libyara/re_grammar.c",
        "class_name": "libyara.re_grammar",
        "signature": "libyara.re_grammar.yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)",
        "snippet": "static void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)\n{\n  YYUSE (yyvaluep);\n  YYUSE (yyscanner);\n  YYUSE (lex_env);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  switch (yytype)\n    {\n    case 6: /* _CLASS_  */\n#line 96 \"re_grammar.y\"\n            { yr_free(((*yyvaluep).re_class)); ((*yyvaluep).re_class) = NULL; }\n#line 1133 \"re_grammar.c\"\n        break;\n\n    case 26: /* alternative  */\n#line 97 \"re_grammar.y\"\n            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }\n#line 1139 \"re_grammar.c\"\n        break;\n\n    case 27: /* concatenation  */\n#line 98 \"re_grammar.y\"\n            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }\n#line 1145 \"re_grammar.c\"\n        break;\n\n    case 28: /* repeat  */\n#line 99 \"re_grammar.y\"\n            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }\n#line 1151 \"re_grammar.c\"\n        break;\n\n    case 29: /* single  */\n#line 100 \"re_grammar.y\"\n            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }\n#line 1157 \"re_grammar.c\"\n        break;\n\n      default:\n        break;\n    }\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}",
        "begin_line": 1116,
        "end_line": 1163,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yy_delete_buffer#2096",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "void yy_delete_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tyyfree( (void *) b->yy_ch_buf , yyscanner );\n\n\tyyfree( (void *) b , yyscanner );\n}",
        "begin_line": 2096,
        "end_line": 2110,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yy_load_buffer_state#2053",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "static void yy_load_buffer_state  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\tyyg->yytext_ptr = yyg->yy_c_buf_p = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;\n\tyyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;\n\tyyg->yy_hold_char = *yyg->yy_c_buf_p;\n}",
        "begin_line": 2053,
        "end_line": 2060,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yy_scan_buffer#2276",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn NULL;\n\n\tb = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n\n\tb->yy_buf_size = (int) (size - 2);\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = NULL;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tyy_switch_to_buffer( b , yyscanner );\n\n\treturn b;\n}",
        "begin_line": 2276,
        "end_line": 2303,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yy_scan_bytes#2326",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len , yyscan_t yyscanner)\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = (yy_size_t) (_yybytes_len + 2);\n\tbuf = (char *) yyalloc( n , yyscanner );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = yy_scan_buffer( buf, n , yyscanner);\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}",
        "begin_line": 2326,
        "end_line": 2354,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yy_scan_string#2313",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "YY_BUFFER_STATE yy_scan_string (const char * yystr , yyscan_t yyscanner)\n{\n    \n\treturn yy_scan_bytes( yystr, (int) strlen(yystr) , yyscanner);\n}",
        "begin_line": 2313,
        "end_line": 2317,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yy_switch_to_buffer#2021",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tyypop_buffer_state();\n\t *\t\tyypush_buffer_state(new_buffer);\n     */\n\tyyensure_buffer_stack (yyscanner);\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*yyg->yy_c_buf_p = yyg->yy_hold_char;\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tyy_load_buffer_state( yyscanner );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (yywrap()) processing, but the only time this flag\n\t * is looked at is after yywrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\tyyg->yy_did_buffer_switch_on_eof = 1;\n}",
        "begin_line": 2021,
        "end_line": 2051,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yyalloc#2693",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "void *yyalloc (yy_size_t  size , yyscan_t yyscanner)\n{\n\tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\t(void)yyg;\n\treturn malloc(size);\n}",
        "begin_line": 2693,
        "end_line": 2698,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yyensure_buffer_stack#2226",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "static void yyensure_buffer_stack (yyscan_t yyscanner)\n{\n\tyy_size_t num_to_alloc;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tif (!yyg->yy_buffer_stack) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\n\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t\tyyg->yy_buffer_stack_top = 0;\n\t\treturn;\n\t}\n\n\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)yyrealloc\n\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t}\n}",
        "begin_line": 2226,
        "end_line": 2268,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yyfree#2715",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "void yyfree (void * ptr , yyscan_t yyscanner)\n{\n\tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\t(void)yyg;\n\tfree( (char *) ptr );\t/* see yyrealloc() for (char *) cast */\n}",
        "begin_line": 2715,
        "end_line": 2720,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yyget_extra#2390",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "YY_EXTRA_TYPE yyget_extra  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    return yyextra;\n}",
        "begin_line": 2390,
        "end_line": 2394,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yylex#1034",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.L",
        "snippet": "YY_DECL\n{\n\tyy_state_type yy_current_state;\n\tchar *yy_cp, *yy_bp;\n\tint yy_act;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n    yylval = yylval_param;\n\n\tif ( !yyg->yy_init )\n\t\t{\n\t\tyyg->yy_init = 1;\n\n#ifdef YY_USER_INIT\n\t\tYY_USER_INIT;\n#endif\n\n\t\tif ( ! yyg->yy_start )\n\t\t\tyyg->yy_start = 1;\t/* first start state */\n\n\t\tif ( ! yyin )\n\t\t\tyyin = stdin;\n\n\t\tif ( ! yyout )\n\t\t\tyyout = stdout;\n\n\t\tif ( ! YY_CURRENT_BUFFER ) {\n\t\t\tyyensure_buffer_stack (yyscanner);\n\t\t\tYY_CURRENT_BUFFER_LVALUE =\n\t\t\t\tyy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);\n\t\t}\n\n\t\tyy_load_buffer_state( yyscanner );\n\t\t}\n\n\t{\n#line 111 \"re_lexer.l\"\n\n\n#line 1074 \"re_lexer.c\"\n\n\twhile ( /*CONSTCOND*/1 )\t\t/* loops until end-of-file is reached */\n\t\t{\n\t\tyy_cp = yyg->yy_c_buf_p;\n\n\t\t/* Support of yytext. */\n\t\t*yy_cp = yyg->yy_hold_char;\n\n\t\t/* yy_bp points to the position in yy_ch_buf of the start of\n\t\t * the current run.\n\t\t */\n\t\tyy_bp = yy_cp;\n\n\t\tyy_current_state = yyg->yy_start;\nyy_match:\n\t\tdo\n\t\t\t{\n\t\t\tYY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;\n\t\t\tif ( yy_accept[yy_current_state] )\n\t\t\t\t{\n\t\t\t\tyyg->yy_last_accepting_state = yy_current_state;\n\t\t\t\tyyg->yy_last_accepting_cpos = yy_cp;\n\t\t\t\t}\n\t\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t\t{\n\t\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\t\tif ( yy_current_state >= 45 )\n\t\t\t\t\tyy_c = yy_meta[yy_c];\n\t\t\t\t}\n\t\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];\n\t\t\t++yy_cp;\n\t\t\t}\n\t\twhile ( yy_current_state != 44 );\n\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\tyy_current_state = yyg->yy_last_accepting_state;\n\nyy_find_action:\n\t\tyy_act = yy_accept[yy_current_state];\n\n\t\tYY_DO_BEFORE_ACTION;\n\n\t\tif ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )\n\t\t\t{\n\t\t\tint yyl;\n\t\t\tfor ( yyl = 0; yyl < yyleng; ++yyl )\n\t\t\t\tif ( yytext[yyl] == '\\n' )\n\t\t\t\t\t\n    do{ yylineno++;\n        yycolumn=0;\n    }while(0)\n;\n\t\t\t}\n\ndo_action:\t/* This label is used only to access EOF actions. */\n\n\t\tswitch ( yy_act )\n\t{ /* beginning of action switch */\n\t\t\tcase 0: /* must back up */\n\t\t\t/* undo the effects of YY_DO_BEFORE_ACTION */\n\t\t\t*yy_cp = yyg->yy_hold_char;\n\t\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\t\tyy_current_state = yyg->yy_last_accepting_state;\n\t\t\tgoto yy_find_action;\n\ncase 1:\nYY_RULE_SETUP\n#line 113 \"re_lexer.l\"\n{\n\n  // Examples: {3,8} {0,5} {,5} {7,}\n\n  int hi_bound;\n  int lo_bound = atoi(yytext + 1);\n\n  char* comma = strchr(yytext, ',');\n\n  if (comma - yytext == strlen(yytext) - 2)\n    // if comma is followed by the closing curly bracket\n    // (example: {2,}) set high bound value to maximum.\n    hi_bound = INT16_MAX;\n  else\n    hi_bound = atoi(comma + 1);\n\n  if (hi_bound > INT16_MAX)\n  {\n    yyerror(yyscanner, lex_env, \"repeat interval too large\");\n    yyterminate();\n  }\n\n  if (hi_bound < lo_bound || hi_bound < 0 || lo_bound < 0)\n  {\n    yyerror(yyscanner, lex_env, \"bad repeat interval\");\n    yyterminate();\n  }\n\n  if (hi_bound == 0 && lo_bound == 0)\n  {\n    yyerror(yyscanner, lex_env, \"bad repeat interval\");\n    yyterminate();\n  }\n\n  yylval->range = (hi_bound << 16) | lo_bound;\n\n  return _RANGE_;\n}\n\tYY_BREAK\ncase 2:\nYY_RULE_SETUP\n#line 153 \"re_lexer.l\"\n{\n\n  // Example: {10}\n\n  int value = atoi(yytext + 1);\n\n  // atoi can return a negative value if the input string represents a number\n  // too large to fit in an integer.\n\n  if (value > INT16_MAX || value < 0)\n  {\n    yyerror(yyscanner, lex_env, \"repeat interval too large\");\n    yyterminate();\n  }\n\n  if (value == 0)\n  {\n    yyerror(yyscanner, lex_env, \"bad repeat interval\");\n    yyterminate();\n  }\n\n  yylval->range = (value << 16) | value;\n\n  return _RANGE_;\n}\n\tYY_BREAK\ncase 3:\nYY_RULE_SETUP\n#line 180 \"re_lexer.l\"\n{\n\n  // Start of a negated character class. Example: [^abcd]\n\n  BEGIN(char_class);\n  memset(LEX_ENV->re_class.bitmap, 0, 32);\n  LEX_ENV->re_class.negated = true;\n}\n\tYY_BREAK\ncase 4:\nYY_RULE_SETUP\n#line 189 \"re_lexer.l\"\n{\n\n  // Start of character negated class containing a ].\n  // Example: [^]abc] this must be interpreted as a class\n  // not matching ], a, b, nor c\n\n  BEGIN(char_class);\n  memset(LEX_ENV->re_class.bitmap, 0, 32);\n  LEX_ENV->re_class.negated = true;\n  LEX_ENV->re_class.bitmap[']' / 8] |= 1 << ']' % 8;\n}\n\tYY_BREAK\ncase 5:\nYY_RULE_SETUP\n#line 202 \"re_lexer.l\"\n{\n\n  // Start of character class containing a ].\n  // Example: []abc] this must be interpreted as a class\n  // matching ], a, b, or c.\n\n  BEGIN(char_class);\n  memset(LEX_ENV->re_class.bitmap, 0, 32);\n  LEX_ENV->re_class.negated = false;\n  LEX_ENV->re_class.bitmap[']' / 8] |= 1 << ']' % 8;\n}\n\tYY_BREAK\ncase 6:\nYY_RULE_SETUP\n#line 215 \"re_lexer.l\"\n{\n\n  // Start of character class. Example: [abcd]\n\n  BEGIN(char_class);\n  memset(LEX_ENV->re_class.bitmap, 0, 32);\n  LEX_ENV->re_class.negated = false;\n}\n\tYY_BREAK\ncase 7:\n/* rule 7 can match eol */\nYY_RULE_SETUP\n#line 225 \"re_lexer.l\"\n{\n\n  // Any non-special character is passed as a CHAR token to the scanner.\n\n  yylval->integer = yytext[0];\n  return _CHAR_;\n}\n\tYY_BREAK\ncase 8:\nYY_RULE_SETUP\n#line 234 \"re_lexer.l\"\n{\n  return _WORD_CHAR_;\n}\n\tYY_BREAK\ncase 9:\nYY_RULE_SETUP\n#line 239 \"re_lexer.l\"\n{\n  return _NON_WORD_CHAR_;\n}\n\tYY_BREAK\ncase 10:\nYY_RULE_SETUP\n#line 244 \"re_lexer.l\"\n{\n  return _SPACE_;\n}\n\tYY_BREAK\ncase 11:\nYY_RULE_SETUP\n#line 249 \"re_lexer.l\"\n{\n  return _NON_SPACE_;\n}\n\tYY_BREAK\ncase 12:\nYY_RULE_SETUP\n#line 254 \"re_lexer.l\"\n{\n  return _DIGIT_;\n}\n\tYY_BREAK\ncase 13:\nYY_RULE_SETUP\n#line 259 \"re_lexer.l\"\n{\n  return _NON_DIGIT_;\n}\n\tYY_BREAK\ncase 14:\nYY_RULE_SETUP\n#line 264 \"re_lexer.l\"\n{\n  return _WORD_BOUNDARY_;\n}\n\tYY_BREAK\ncase 15:\nYY_RULE_SETUP\n#line 268 \"re_lexer.l\"\n{\n  return _NON_WORD_BOUNDARY_;\n}\n\tYY_BREAK\ncase 16:\nYY_RULE_SETUP\n#line 273 \"re_lexer.l\"\n{\n\n  yyerror(yyscanner, lex_env, \"backreferences are not allowed\");\n  yyterminate();\n}\n\tYY_BREAK\ncase 17:\nYY_RULE_SETUP\n#line 280 \"re_lexer.l\"\n{\n\n  uint8_t c;\n\n  if (read_escaped_char(yyscanner, &c))\n  {\n    yylval->integer = c;\n    return _CHAR_;\n  }\n  else\n  {\n    yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n    yyterminate();\n  }\n}\n\tYY_BREAK\ncase 18:\nYY_RULE_SETUP\n#line 297 \"re_lexer.l\"\n{\n\n  // End of character class.\n  yylval->re_class = (RE_CLASS*) yr_malloc(sizeof(RE_CLASS));\n  memcpy(yylval->re_class->bitmap, LEX_ENV->re_class.bitmap, 32);\n\n  yylval->re_class->negated = LEX_ENV->re_class.negated;\n\n  BEGIN(INITIAL);\n  return _CLASS_;\n}\n\tYY_BREAK\ncase 19:\n/* rule 19 can match eol */\nYY_RULE_SETUP\n#line 311 \"re_lexer.l\"\n{\n\n  // A range inside a character class.\n  //  [abc0-9]\n  //      ^- matching here\n\n  uint16_t c;\n  uint8_t start = yytext[0];\n  uint8_t end = yytext[2];\n\n  if (start == '\\\\')\n  {\n    if (!escaped_char_value(yytext, &start))\n    {\n      yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n      yyterminate();\n    }\n\n    if (yytext[1] == 'x')\n      end = yytext[5];\n    else\n      end = yytext[3];\n  }\n\n  if (end == '\\\\')\n  {\n    if (!read_escaped_char(yyscanner, &end))\n    {\n      yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n      yyterminate();\n    }\n  }\n\n  if (end < start)\n  {\n    yyerror(yyscanner, lex_env, \"bad character range\");\n    yyterminate();\n  }\n\n  for (c = start; c <= end; c++)\n  {\n    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;\n  }\n}\n\tYY_BREAK\ncase 20:\nYY_RULE_SETUP\n#line 357 \"re_lexer.l\"\n{\n\n  int i;\n\n  for (i = 0; i < 32; i++)\n    LEX_ENV->re_class.bitmap[i] |= word_chars[i];\n}\n\tYY_BREAK\ncase 21:\nYY_RULE_SETUP\n#line 366 \"re_lexer.l\"\n{\n\n  int i;\n\n  for (i = 0; i < 32; i++)\n    LEX_ENV->re_class.bitmap[i] |= ~word_chars[i];\n}\n\tYY_BREAK\ncase 22:\nYY_RULE_SETUP\n#line 375 \"re_lexer.l\"\n{\n\n  int i;\n\n  for (i = 0; i < 32; i++)\n    LEX_ENV->re_class.bitmap[i] |= space_chars[i];\n}\n\tYY_BREAK\ncase 23:\nYY_RULE_SETUP\n#line 384 \"re_lexer.l\"\n{\n\n  int i;\n\n  for (i = 0; i < 32; i++)\n    LEX_ENV->re_class.bitmap[i] |= ~space_chars[i];\n}\n\tYY_BREAK\ncase 24:\nYY_RULE_SETUP\n#line 393 \"re_lexer.l\"\n{\n\n  char c;\n\n  for (c = '0'; c <= '9'; c++)\n    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;\n}\n\tYY_BREAK\ncase 25:\nYY_RULE_SETUP\n#line 402 \"re_lexer.l\"\n{\n\n  int i;\n\n  for (i = 0; i < 32; i++)\n  {\n    // digits 0-7 are in the sixth byte of the vector, let that byte alone\n    if (i == 6)\n      continue;\n\n    // digits 8 and 9 are the lowest two bits in the seventh byte of the\n    // vector, let those bits alone.\n    if (i == 7)\n      LEX_ENV->re_class.bitmap[i] |= 0xFC;\n    else\n      LEX_ENV->re_class.bitmap[i] = 0xFF;\n  }\n}\n\tYY_BREAK\ncase 26:\nYY_RULE_SETUP\n#line 422 \"re_lexer.l\"\n{\n\n  uint8_t c;\n\n  if (read_escaped_char(yyscanner, &c))\n  {\n    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;\n  }\n  else\n  {\n    yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n    yyterminate();\n  }\n}\n\tYY_BREAK\ncase 27:\nYY_RULE_SETUP\n#line 438 \"re_lexer.l\"\n{\n\n  if (yytext[0] >= 32 && yytext[0] < 127)\n  {\n    // A character class (i.e: [0-9a-f]) is represented by a 256-bits vector,\n    // here we set to 1 the vector's bit corresponding to the input character.\n\n    LEX_ENV->re_class.bitmap[yytext[0] / 8] |= 1 << yytext[0] % 8;\n  }\n  else\n  {\n    yyerror(yyscanner, lex_env, \"non-ascii character\");\n    yyterminate();\n  }\n}\n\tYY_BREAK\ncase YY_STATE_EOF(char_class):\n#line 455 \"re_lexer.l\"\n{\n\n  // End of regexp reached while scanning a character class.\n\n  yyerror(yyscanner, lex_env, \"missing terminating ] for character class\");\n  yyterminate();\n}\n\tYY_BREAK\ncase 28:\nYY_RULE_SETUP\n#line 464 \"re_lexer.l\"\n{\n\n  if (yytext[0] >= 32 && yytext[0] < 127)\n  {\n    return yytext[0];\n  }\n  else\n  {\n    yyerror(yyscanner, lex_env, \"non-ascii character\");\n    yyterminate();\n  }\n}\n\tYY_BREAK\ncase YY_STATE_EOF(INITIAL):\n#line 478 \"re_lexer.l\"\n{\n\n  yyterminate();\n}\n\tYY_BREAK\ncase 29:\nYY_RULE_SETUP\n#line 483 \"re_lexer.l\"\nECHO;\n\tYY_BREAK\n#line 1576 \"re_lexer.c\"\n\n\tcase YY_END_OF_BUFFER:\n\t\t{\n\t\t/* Amount of text matched not including the EOB char. */\n\t\tint yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;\n\n\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */\n\t\t*yy_cp = yyg->yy_hold_char;\n\t\tYY_RESTORE_YY_MORE_OFFSET\n\n\t\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )\n\t\t\t{\n\t\t\t/* We're scanning a new file or input source.  It's\n\t\t\t * possible that this happened because the user\n\t\t\t * just pointed yyin at a new source and called\n\t\t\t * yylex().  If so, then we have to assure\n\t\t\t * consistency between YY_CURRENT_BUFFER and our\n\t\t\t * globals.  Here is the right place to do so, because\n\t\t\t * this is the first action (other than possibly a\n\t\t\t * back-up) that will match for the new input source.\n\t\t\t */\n\t\t\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;\n\t\t\t}\n\n\t\t/* Note that here we test for yy_c_buf_p \"<=\" to the position\n\t\t * of the first EOB in the buffer, since yy_c_buf_p will\n\t\t * already have been incremented past the NUL character\n\t\t * (since all states make transitions on EOB to the\n\t\t * end-of-buffer state).  Contrast this with the test\n\t\t * in input().\n\t\t */\n\t\tif ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )\n\t\t\t{ /* This was really a NUL. */\n\t\t\tyy_state_type yy_next_state;\n\n\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;\n\n\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t/* Okay, we're now positioned to make the NUL\n\t\t\t * transition.  We couldn't have\n\t\t\t * yy_get_previous_state() go ahead and do it\n\t\t\t * for us because it doesn't know how to deal\n\t\t\t * with the possibility of jamming (and we don't\n\t\t\t * want to build jamming into it because then it\n\t\t\t * will run more slowly).\n\t\t\t */\n\n\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);\n\n\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\n\t\t\tif ( yy_next_state )\n\t\t\t\t{\n\t\t\t\t/* Consume the NUL. */\n\t\t\t\tyy_cp = ++yyg->yy_c_buf_p;\n\t\t\t\tyy_current_state = yy_next_state;\n\t\t\t\tgoto yy_match;\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\t\t\tyy_current_state = yyg->yy_last_accepting_state;\n\t\t\t\tgoto yy_find_action;\n\t\t\t\t}\n\t\t\t}\n\n\t\telse switch ( yy_get_next_buffer( yyscanner ) )\n\t\t\t{\n\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t{\n\t\t\t\tyyg->yy_did_buffer_switch_on_eof = 0;\n\n\t\t\t\tif ( yywrap( yyscanner ) )\n\t\t\t\t\t{\n\t\t\t\t\t/* Note: because we've taken care in\n\t\t\t\t\t * yy_get_next_buffer() to have set up\n\t\t\t\t\t * yytext, we can now set up\n\t\t\t\t\t * yy_c_buf_p so that if some total\n\t\t\t\t\t * hoser (like flex itself) wants to\n\t\t\t\t\t * call the scanner after we return the\n\t\t\t\t\t * YY_NULL, it'll still work - another\n\t\t\t\t\t * YY_NULL will get returned.\n\t\t\t\t\t */\n\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;\n\n\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);\n\t\t\t\t\tgoto do_action;\n\t\t\t\t\t}\n\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\tyyg->yy_c_buf_p =\n\t\t\t\t\tyyg->yytext_ptr + yy_amount_of_matched_text;\n\n\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t\tyy_cp = yyg->yy_c_buf_p;\n\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_match;\n\n\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\tyyg->yy_c_buf_p =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];\n\n\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t\tyy_cp = yyg->yy_c_buf_p;\n\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_find_action;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\tYY_FATAL_ERROR(\n\t\t\t\"fatal flex scanner internal error--no action found\" );\n\t} /* end of action switch */\n\t\t} /* end of scanning one token */\n\t} /* end of user's declarations */\n}",
        "begin_line": 1034,
        "end_line": 1706,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yylex_destroy#2637",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "int yylex_destroy  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tyy_delete_buffer( YY_CURRENT_BUFFER , yyscanner );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tyypop_buffer_state(yyscanner);\n\t}\n\n\t/* Destroy the stack itself. */\n\tyyfree(yyg->yy_buffer_stack , yyscanner);\n\tyyg->yy_buffer_stack = NULL;\n\n    /* Destroy the start condition stack. */\n        yyfree( yyg->yy_start_stack , yyscanner );\n        yyg->yy_start_stack = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * yylex() is called, initialization will occur. */\n    yy_init_globals( yyscanner);\n\n    /* Destroy the main struct (reentrant only). */\n    yyfree ( yyscanner , yyscanner );\n    yyscanner = NULL;\n    return 0;\n}",
        "begin_line": 2637,
        "end_line": 2664,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yylex_init#2549",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "int yylex_init(yyscan_t* ptr_yy_globals)\n{\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n\n    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), NULL );\n\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n\n    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n\n    return yy_init_globals ( *ptr_yy_globals );\n}",
        "begin_line": 2549,
        "end_line": 2567,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yypop_buffer_state#2206",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "void yypop_buffer_state (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tyy_delete_buffer(YY_CURRENT_BUFFER , yyscanner);\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif (yyg->yy_buffer_stack_top > 0)\n\t\t--yyg->yy_buffer_stack_top;\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tyy_load_buffer_state( yyscanner );\n\t\tyyg->yy_did_buffer_switch_on_eof = 1;\n\t}\n}",
        "begin_line": 2206,
        "end_line": 2221,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yyset_extra#2463",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "void yyset_extra (YY_EXTRA_TYPE  user_defined , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    yyextra = user_defined ;\n}",
        "begin_line": 2463,
        "end_line": 2467,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.yy_get_next_buffer#1715",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.yy_get_next_buffer (yyscan_t yyscanner)",
        "snippet": "static int yy_get_next_buffer (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tchar *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tchar *source = yyg->yytext_ptr;\n\tint number_to_move, i;\n\tint ret_val;\n\n\tif ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr - 1);\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) (yyg->yy_c_buf_p - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tyyrealloc( (void *) b->yy_ch_buf,\n\t\t\t\t\t\t\t (yy_size_t) (b->yy_buf_size + 2) , yyscanner );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = NULL;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\tyyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\tyyg->yy_n_chars, num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;\n\t\t}\n\n\tif ( yyg->yy_n_chars == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tyyrestart( yyin  , yyscanner);\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tint new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(\n\t\t\t(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size , yyscanner );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n\t\t/* \"- 2\" to take care of EOB's */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);\n\t}\n\n\tyyg->yy_n_chars += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;\n\n\tyyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}",
        "begin_line": 1715,
        "end_line": 1850,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.yy_get_previous_state#1854",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.yy_get_previous_state (yyscan_t yyscanner)",
        "snippet": "static yy_state_type yy_get_previous_state (yyscan_t yyscanner)\n{\n\tyy_state_type yy_current_state;\n\tchar *yy_cp;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tyy_current_state = yyg->yy_start;\n\n\tfor ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )\n\t\t{\n\t\tYY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\tyyg->yy_last_accepting_state = yy_current_state;\n\t\t\tyyg->yy_last_accepting_cpos = yy_cp;\n\t\t\t}\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 45 )\n\t\t\t\tyy_c = yy_meta[yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];\n\t\t}\n\n\treturn yy_current_state;\n}",
        "begin_line": 1854,
        "end_line": 1880,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.yy_init_globals#2603",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.yy_init_globals (yyscan_t yyscanner)",
        "snippet": "static int yy_init_globals (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from yylex_destroy(), so don't allocate here.\n     */\n\n    yyg->yy_buffer_stack = NULL;\n    yyg->yy_buffer_stack_top = 0;\n    yyg->yy_buffer_stack_max = 0;\n    yyg->yy_c_buf_p = NULL;\n    yyg->yy_init = 0;\n    yyg->yy_start = 0;\n\n    yyg->yy_start_stack_ptr = 0;\n    yyg->yy_start_stack_depth = 0;\n    yyg->yy_start_stack =  NULL;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    yyin = stdin;\n    yyout = stdout;\n#else\n    yyin = NULL;\n    yyout = NULL;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * yylex_init()\n     */\n    return 0;\n}",
        "begin_line": 2603,
        "end_line": 2634,
        "is_bug": false
    },
    {
        "name": "libyara.stack.yr_stack_create#46",
        "src_path": "libyara/stack.c",
        "class_name": "libyara.stack",
        "signature": "libyara.stack.yr_stack_create(     int initial_capacity, int item_size, YR_STACK** stack)",
        "snippet": "int yr_stack_create(\n    int initial_capacity,\n    int item_size,\n    YR_STACK** stack)\n{\n  *stack = (YR_STACK*) yr_malloc(sizeof(YR_STACK));\n\n  if (*stack == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  (*stack)->items = yr_malloc(initial_capacity * item_size);\n\n  if ((*stack)->items == NULL)\n  {\n    yr_free(*stack);\n    *stack = NULL;\n    return ERROR_INSUFFICIENT_MEMORY;\n  }\n\n  (*stack)->capacity = initial_capacity;\n  (*stack)->item_size = item_size;\n  (*stack)->top = 0;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 46,
        "end_line": 70,
        "is_bug": false
    },
    {
        "name": "libyara.stack.yr_stack_destroy#78",
        "src_path": "libyara/stack.c",
        "class_name": "libyara.stack",
        "signature": "libyara.stack.yr_stack_destroy(     YR_STACK* stack)",
        "snippet": "void yr_stack_destroy(\n    YR_STACK* stack)\n{\n  yr_free(stack->items);\n  yr_free(stack);\n}",
        "begin_line": 78,
        "end_line": 83,
        "is_bug": false
    },
    {
        "name": "libyara.stack.yr_stack_pop#130",
        "src_path": "libyara/stack.c",
        "class_name": "libyara.stack",
        "signature": "libyara.stack.yr_stack_pop(     YR_STACK* stack, void* item)",
        "snippet": "int yr_stack_pop(\n    YR_STACK* stack,\n    void* item)\n{\n  if (stack->top == 0)  // Return 0 if stack is empty.\n    return 0;\n\n  stack->top--;\n\n  memcpy(\n      item,\n      (uint8_t*) stack->items + stack->top * stack->item_size,\n      stack->item_size);\n\n  return 1;\n}",
        "begin_line": 130,
        "end_line": 145,
        "is_bug": false
    },
    {
        "name": "libyara.stack.yr_stack_push#94",
        "src_path": "libyara/stack.c",
        "class_name": "libyara.stack",
        "signature": "libyara.stack.yr_stack_push(     YR_STACK* stack, void* item)",
        "snippet": "int yr_stack_push(\n    YR_STACK* stack,\n    void* item)\n{\n  if (stack->top == stack->capacity)\n  {\n    void* items = yr_realloc(\n        stack->items, 2 * stack->capacity * stack->item_size);\n\n    if (items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    stack->items = items;\n    stack->capacity *= 2;\n  }\n\n  memcpy(\n      (uint8_t*) stack->items + stack->top * stack->item_size,\n      item,\n      stack->item_size);\n\n  stack->top++;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 94,
        "end_line": 118,
        "is_bug": false
    },
    {
        "name": "libyara.strutils.strlcpy#92",
        "src_path": "libyara/strutils.c",
        "class_name": "libyara.strutils",
        "signature": "libyara.strutils.strlcpy(     char* dst, const char* src, size_t size)",
        "snippet": "size_t strlcpy(\n    char* dst,\n    const char* src,\n    size_t size)\n{\n  register char* d = dst;\n  register const char* s = src;\n  register size_t n = size;\n\n  // Copy as many bytes as will fit\n\n  if (n != 0 && --n != 0)\n  {\n    do\n    {\n      if ((*d++ = *s++) == 0)\n        break;\n\n    } while (--n != 0);\n  }\n\n  // Not enough room in dst, add NUL and traverse rest of src\n\n  if (n == 0)\n  {\n    if (size != 0)\n      *d = '\\0';    // NULL-terminate dst\n\n    while (*s++);\n  }\n\n  return (s - src - 1);  // count does not include NULL\n}",
        "begin_line": 92,
        "end_line": 124,
        "is_bug": false
    },
    {
        "name": "libyara.strutils.xtoi#35",
        "src_path": "libyara/strutils.c",
        "class_name": "libyara.strutils",
        "signature": "libyara.strutils.xtoi(     const char* hexstr)",
        "snippet": "uint64_t xtoi(\n    const char* hexstr)\n{\n  size_t i;\n  size_t l = strlen(hexstr);\n\n  uint64_t r = 0;\n\n  for (i = 0; i < l; i++)\n  {\n    switch (hexstr[i])\n    {\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        r |= ((uint64_t)(hexstr[i] - '0')) << ((l - i - 1) * 4);\n        break;\n      case 'a':\n      case 'b':\n      case 'c':\n      case 'd':\n      case 'e':\n      case 'f':\n        r |= ((uint64_t)(hexstr[i] - 'a' + 10)) << ((l - i - 1) * 4);\n        break;\n      case 'A':\n      case 'B':\n      case 'C':\n      case 'D':\n      case 'E':\n      case 'F':\n        r |= ((uint64_t)(hexstr[i] - 'A' + 10)) << ((l - i - 1) * 4);\n        break;\n      default:\n        i = l;  // force loop exit\n    }\n  }\n\n  return r;\n}",
        "begin_line": 35,
        "end_line": 81,
        "is_bug": false
    },
    {
        "name": "libyara.threading.yr_thread_storage_create#172",
        "src_path": "libyara/threading.c",
        "class_name": "libyara.threading",
        "signature": "libyara.threading.yr_thread_storage_create(     YR_THREAD_STORAGE_KEY* storage)",
        "snippet": "int yr_thread_storage_create(\n    YR_THREAD_STORAGE_KEY* storage)\n{\n  if (pthread_key_create(storage, NULL) != 0)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 172,
        "end_line": 179,
        "is_bug": false
    },
    {
        "name": "libyara.threading.yr_thread_storage_destroy#182",
        "src_path": "libyara/threading.c",
        "class_name": "libyara.threading",
        "signature": "libyara.threading.yr_thread_storage_destroy(     YR_THREAD_STORAGE_KEY* storage)",
        "snippet": "int yr_thread_storage_destroy(\n    YR_THREAD_STORAGE_KEY* storage)\n{\n  if (pthread_key_delete(*storage) != 0)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 182,
        "end_line": 189,
        "is_bug": false
    },
    {
        "name": "libyara.threading.yr_thread_storage_set_value#192",
        "src_path": "libyara/threading.c",
        "class_name": "libyara.threading",
        "signature": "libyara.threading.yr_thread_storage_set_value(     YR_THREAD_STORAGE_KEY* storage, void* value)",
        "snippet": "int yr_thread_storage_set_value(\n    YR_THREAD_STORAGE_KEY* storage,\n    void* value)\n{\n  if (pthread_setspecific(*storage, value) != 0)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 192,
        "end_line": 200,
        "is_bug": false
    }
]