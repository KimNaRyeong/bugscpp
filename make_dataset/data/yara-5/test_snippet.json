[
    {
        "name": "tests.test-alignment.defects4cpp_test_index#4",
        "src_path": "tests/test-alignment.c",
        "class_name": "tests.test-alignment",
        "signature": "tests.test-alignment.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-alignment.main#70",
        "src_path": "tests/test-alignment.c",
        "class_name": "tests.test-alignment",
        "signature": "tests.test-alignment.main (int argc, char **argv)",
        "snippet": "int main (int argc, char **argv)\n{\n  int index = defects4cpp_test_index();\n  switch (index) {\n    case 1:\n  CHECK_SIZE(YR_NAMESPACE, 16);\n      break;\n    case 2:\n  CHECK_OFFSET(YR_NAMESPACE, 0, name);\n      break;\n    case 3:\n  CHECK_OFFSET(YR_NAMESPACE, 8, idx);\n      break;\n    case 4:\n  CHECK_SIZE(YR_META, 32);\n      break;\n    case 5:\n  CHECK_OFFSET(YR_META, 0, identifier);\n      break;\n    case 6:\n  CHECK_OFFSET(YR_META, 8, string);\n      break;\n    case 7:\n  CHECK_OFFSET(YR_META, 16,  integer);\n      break;\n    case 8:\n  CHECK_OFFSET(YR_META, 24,  type);\n      break;\n    case 9:\n  CHECK_OFFSET(YR_META, 28,  flags);\n      break;\n    case 10:\n  CHECK_SIZE(YR_STRING, 56);\n      break;\n    case 11:\n  CHECK_OFFSET(YR_STRING, 0, flags);\n      break;\n    case 12:\n  CHECK_OFFSET(YR_STRING, 4, idx);\n      break;\n    case 13:\n  CHECK_OFFSET(YR_STRING, 8, fixed_offset);\n      break;\n    case 14:\n  CHECK_OFFSET(YR_STRING, 16, rule_idx);\n      break;\n    case 15:\n  CHECK_OFFSET(YR_STRING, 20, length);\n      break;\n    case 16:\n  CHECK_OFFSET(YR_STRING, 24, string);\n      break;\n    case 17:\n  CHECK_OFFSET(YR_STRING, 32, chained_to);\n      break;\n    case 18:\n  CHECK_OFFSET(YR_STRING, 40, chain_gap_min);\n      break;\n    case 19:\n  CHECK_OFFSET(YR_STRING, 44, chain_gap_max);\n      break;\n    case 20:\n  CHECK_OFFSET(YR_STRING, 48, identifier);\n      break;\n    case 21:\n  CHECK_SIZE(YR_RULE, 48);\n      break;\n    case 22:\n  CHECK_OFFSET(YR_RULE, 8,  identifier);\n      break;\n    case 23:\n  CHECK_OFFSET(YR_RULE, 16, tags);\n      break;\n    case 24:\n  CHECK_OFFSET(YR_RULE, 24, metas);\n      break;\n    case 25:\n  CHECK_OFFSET(YR_RULE, 32, strings);\n      break;\n    case 26:\n  CHECK_OFFSET(YR_RULE, 40, ns);\n      break;\n    case 27:\n  CHECK_SIZE(YR_SUMMARY, 12);\n      break;\n    case 28:\n  CHECK_OFFSET(YR_SUMMARY, 0,  num_rules);\n      break;\n    case 29:\n  CHECK_OFFSET(YR_SUMMARY, 4,  num_strings);\n      break;\n    case 30:\n  CHECK_OFFSET(YR_SUMMARY, 8,  num_namespaces);\n      break;\n    case 31:\n  CHECK_SIZE(YR_EXTERNAL_VARIABLE, 24);\n      break;\n    case 32:\n  CHECK_OFFSET(YR_EXTERNAL_VARIABLE, 8,  value.i);\n      break;\n    case 33:\n  CHECK_OFFSET(YR_EXTERNAL_VARIABLE, 8,  value.f);\n      break;\n    case 34:\n  CHECK_OFFSET(YR_EXTERNAL_VARIABLE, 8,  value.s);\n      break;\n    case 35:\n  CHECK_OFFSET(YR_EXTERNAL_VARIABLE, 16, identifier);\n      break;\n    case 36:\n  CHECK_SIZE(YR_AC_MATCH, 40);\n      break;\n    case 37:\n  CHECK_OFFSET(YR_AC_MATCH, 0, string);\n      break;\n    case 38:\n  CHECK_OFFSET(YR_AC_MATCH, 8, forward_code);\n      break;\n    case 39:\n  CHECK_OFFSET(YR_AC_MATCH, 16, backward_code);\n      break;\n    case 40:\n  CHECK_OFFSET(YR_AC_MATCH, 24, next);\n      break;\n    case 41:\n  CHECK_OFFSET(YR_AC_MATCH, 32, backtrack);\n      break;\n    case 42:\n  CHECK_SIZE(SIZED_STRING, 12);\n      break;\n    case 43:\n  CHECK_OFFSET(SIZED_STRING, 4, flags);\n      break;\n    case 44:\n  CHECK_OFFSET(SIZED_STRING, 8, c_string);\n      break;\n  }\n  return err;\n}",
        "begin_line": 70,
        "end_line": 208,
        "is_bug": false
    },
    {
        "name": "tests.test-api._include_callback#62",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api._include_callback(   const char* include_name, const char* calling_rule_filename, const char* calling_rule_namespace, void* user_data)",
        "snippet": "const char* _include_callback(\n  const char* include_name,\n  const char* calling_rule_filename,\n  const char* calling_rule_namespace,\n  void* user_data)\n{\nif (strcmp(include_name, \"ok\") == 0)\n  return \"rule test {condition: true}\";\nelse\n  return NULL;\n}",
        "begin_line": 62,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "tests.test-api.ast_callback#591",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.ast_callback(     const YR_RULE* rule, const char* string_identifier, const RE_AST* re_ast, void* user_data)",
        "snippet": "void ast_callback(\n    const YR_RULE* rule,\n    const char* string_identifier,\n    const RE_AST* re_ast,\n    void* user_data)\n{\n  if (strcmp(rule->identifier, \"test\") == 0 &&\n      strcmp(string_identifier, \"$foo\") == 0)\n  {\n    *((int*) user_data) = 1;\n  }\n}",
        "begin_line": 591,
        "end_line": 602,
        "is_bug": false
    },
    {
        "name": "tests.test-api.defects4cpp_test_index#4",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-api.main#802",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  char *top_srcdir = getenv(\"TOP_SRCDIR\");\n  if (top_srcdir)\n    chdir(top_srcdir);\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 45:\n  test_disabled_rules();\n          break;\n      case 46:\n  test_file_descriptor();\n          break;\n      case 47:\n  test_max_string_per_rules();\n          break;\n      case 48:\n  test_max_match_data();\n          break;\n      case 49:\n  test_include_callback();\n          break;\n      case 50:\n  test_save_load_rules();\n          break;\n      case 51:\n  test_scanner();\n// test_ast_callback();\n// //TODO(vmalvarez): Enable these tests.\n// //test_rules_stats();\n//\n// test_issue_834();\n// test_issue_920();\n          break;\n  }\n  return 0;\n}",
        "begin_line": 802,
        "end_line": 838,
        "is_bug": false
    },
    {
        "name": "tests.test-api.stats_for_rules#647",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.stats_for_rules(     const char* rules_str, YR_RULES_STATS* stats)",
        "snippet": "void stats_for_rules(\n    const char* rules_str,\n    YR_RULES_STATS* stats)\n{\n  YR_COMPILER* compiler = NULL;\n  YR_RULES* rules = NULL;\n\n  yr_initialize();\n\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (yr_compiler_add_string(compiler, rules_str, NULL) != 0)\n  {\n    yr_compiler_destroy(compiler);\n    perror(\"yr_compiler_add_string\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (yr_compiler_get_rules(compiler, &rules) != ERROR_SUCCESS)\n  {\n    yr_compiler_destroy(compiler);\n    perror(\"yr_compiler_get_rules\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_rules_get_stats(rules, stats);\n\n  yr_compiler_destroy(compiler);\n  yr_rules_destroy(rules);\n  yr_finalize();\n}",
        "begin_line": 647,
        "end_line": 681,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_ast_callback#604",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_ast_callback()",
        "snippet": "void test_ast_callback()\n{\n  const char* rules_str = \"\\\n      rule test { \\\n      strings: $foo = /a.*b/ \\\n      condition: $foo }\";\n\n  YR_COMPILER* compiler = NULL;\n\n  yr_initialize();\n\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  int ok = 0;\n\n  yr_compiler_set_re_ast_callback(\n      compiler,\n      ast_callback,\n      &ok);\n\n  // Compile a rule that use the variables in the condition.\n  if (yr_compiler_add_string(compiler, rules_str, NULL) != 0)\n  {\n    yr_compiler_destroy(compiler);\n    perror(\"yr_compiler_add_string\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (!ok)\n  {\n    printf(\"ast callback failed\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_compiler_destroy(compiler);\n  yr_finalize();\n}",
        "begin_line": 604,
        "end_line": 644,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_disabled_rules#15",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_disabled_rules()",
        "snippet": "void test_disabled_rules()\n{\n  YR_RULES* rules;\n  YR_RULE* rule;\n\n  char* buf = \"foo bar\";\n  char* rules_str = \" \\\n    rule disabled_rule {condition: true} \\\n    rule false_rule {condition: true and disabled_rule} \\\n    rule true_rule {condition: true or disabled_rule}\";\n\n  struct COUNTERS counters;\n\n  counters.rules_not_matching = 0;\n  counters.rules_matching = 0;\n\n  yr_initialize();\n\n  if (compile_rule(rules_str, &rules) != ERROR_SUCCESS)\n  {\n    perror(\"compile_rule\");\n    exit(EXIT_FAILURE);\n  }\n\n  // diable any rule containing disable in its identifier\n  yr_rules_foreach(rules, rule)\n  {\n    if (strstr(rule->identifier, \"disabled\"))\n      yr_rule_disable(rule);\n  }\n\n  yr_rules_scan_mem(\n      rules, (uint8_t *) buf, strlen(buf), 0, count, &counters, 0);\n\n  yr_rules_destroy(rules);\n\n  // matches should be exactly one.\n  if (counters.rules_matching != 1)\n  {\n    fprintf(stderr, \"test_disabled_rules failed\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_finalize();\n}",
        "begin_line": 15,
        "end_line": 59,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_file_descriptor#108",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_file_descriptor()",
        "snippet": "void test_file_descriptor()\n{\n  YR_COMPILER* compiler = NULL;\n  YR_RULES* rules = NULL;\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n  HANDLE fd = CreateFile(\"tests/data/baz.yar\", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);\n  if (fd == INVALID_HANDLE_VALUE)\n  {\n    fputs(\"CreateFile failed\", stderr);\n    exit(1);\n  }\n#else\n  int fd = open(\"tests/data/baz.yar\", O_RDONLY);\n  if (fd < 0)\n  {\n    perror(\"open\");\n    exit(EXIT_FAILURE);\n  }\n#endif\n\n  yr_initialize();\n\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (yr_compiler_add_fd(compiler, fd, NULL, NULL) != 0)\n  {\n    perror(\"yr_compiler_add_fd\");\n    exit(EXIT_FAILURE);\n  }\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n  CloseHandle(fd);\n#else\n  close(fd);\n#endif\n\n  if (yr_compiler_get_rules(compiler, &rules) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_add_fd\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (compiler)\n    yr_compiler_destroy(compiler);\n\n  if (rules)\n    yr_rules_destroy(rules);\n\n  yr_finalize();\n\n  return;\n}",
        "begin_line": 108,
        "end_line": 164,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_include_callback#75",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_include_callback()",
        "snippet": "void test_include_callback()\n{\n  YR_COMPILER* compiler = NULL;\n\n  yr_initialize();\n\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_compiler_set_include_callback(compiler, _include_callback, NULL, NULL);\n\n  // This include produces no error.\n  if (yr_compiler_add_string(compiler, \"include \\\"ok\\\"\", NULL) != 0)\n  {\n    yr_compiler_destroy(compiler);\n    exit(EXIT_FAILURE);\n  }\n\n  // This include one error.\n  if (yr_compiler_add_string(compiler, \"include \\\"fail\\\"\", NULL) != 1)\n  {\n    yr_compiler_destroy(compiler);\n    exit(EXIT_FAILURE);\n  }\n\n  yr_compiler_destroy(compiler);\n  yr_finalize();\n}",
        "begin_line": 75,
        "end_line": 105,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_issue_834#539",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_issue_834()",
        "snippet": "void test_issue_834()\n{\n  const char* buf = \"dummy\";\n  const char* rules_str = \"import \\\"tests\\\" rule test { condition: true }\";\n\n  YR_COMPILER* compiler = NULL;\n  YR_RULES* rules = NULL;\n  YR_SCANNER* scanner = NULL;\n\n  yr_initialize();\n\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (yr_compiler_add_string(compiler, rules_str, NULL) != 0)\n  {\n    yr_compiler_destroy(compiler);\n    perror(\"yr_compiler_add_string\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (yr_compiler_get_rules(compiler, &rules) != ERROR_SUCCESS)\n  {\n    yr_compiler_destroy(compiler);\n    perror(\"yr_compiler_get_rules\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_compiler_destroy(compiler);\n\n  if (yr_scanner_create(rules, &scanner)!= ERROR_SUCCESS)\n  {\n    yr_rules_destroy(rules);\n    perror(\"yr_scanner_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_scanner_set_callback(scanner, do_nothing, NULL);\n\n  // Call yr_scanner_scan_mem twice.\n  yr_scanner_scan_mem(scanner, (uint8_t *) buf, strlen(buf));\n  yr_scanner_scan_mem(scanner, (uint8_t *) buf, strlen(buf));\n\n  yr_scanner_destroy(scanner);\n  yr_rules_destroy(rules);\n  yr_finalize();\n}",
        "begin_line": 539,
        "end_line": 588,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_issue_920#766",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_issue_920()",
        "snippet": "void test_issue_920()\n{\n  const char* rules_str = \"\\\n      rule test { \\\n        condition: true \\\n      }\";\n\n  YR_COMPILER* compiler = NULL;\n\n  yr_initialize();\n\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  // Define a variable named \"test\"\n  yr_compiler_define_boolean_variable(compiler, \"test\", 1);\n\n  // The compilation should not succeed, as the rule is named \"test\" and a\n  // a variable with the same name already exists.\n  yr_compiler_add_string(compiler, rules_str, NULL);\n\n  if (compiler->last_error != ERROR_DUPLICATED_IDENTIFIER)\n  {\n    yr_compiler_destroy(compiler);\n    printf(\"expecting ERROR_CALLBACK_REQUIRED (%d), got: %d\\n\",\n           ERROR_DUPLICATED_IDENTIFIER, compiler->last_error);\n    exit(EXIT_FAILURE);\n  }\n\n  yr_compiler_destroy(compiler);\n  yr_finalize();\n}",
        "begin_line": 766,
        "end_line": 800,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_max_match_data#239",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_max_match_data()",
        "snippet": "void test_max_match_data()\n{\n  YR_RULES* rules;\n\n  uint32_t new_max_match_data = 0;\n  uint32_t old_max_match_data;\n\n  char* rules_str = \"rule t { strings: $a = \\\"foobar\\\" condition: $a }\";\n\n  yr_initialize();\n\n  yr_get_configuration(\n      YR_CONFIG_MAX_MATCH_DATA,\n      (void*) &old_max_match_data);\n\n  yr_set_configuration(\n      YR_CONFIG_MAX_MATCH_DATA,\n      (void*) &new_max_match_data);\n\n  if (compile_rule(rules_str, &rules) != ERROR_SUCCESS)\n  {\n    perror(\"compile_rule\");\n    exit(EXIT_FAILURE);\n  }\n\n  int err = yr_rules_scan_mem(\n      rules,\n      (const uint8_t *) \"foobar\",\n      6,\n      0,\n      test_max_match_data_callback,\n      NULL,\n      0);\n\n  if (err != ERROR_SUCCESS)\n  {\n    fprintf(stderr, \"test_max_match_data failed\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_rules_destroy(rules);\n  yr_finalize();\n}",
        "begin_line": 239,
        "end_line": 281,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_max_match_data_callback#213",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_max_match_data_callback(     YR_SCAN_CONTEXT* context, int message, void* message_data, void* user_data)",
        "snippet": "int test_max_match_data_callback(\n    YR_SCAN_CONTEXT* context,\n    int message,\n    void* message_data,\n    void* user_data)\n{\n  if (message == CALLBACK_MSG_RULE_MATCHING)\n  {\n    YR_RULE* r = (YR_RULE*) message_data;\n    YR_STRING* s;\n\n    yr_rule_strings_foreach(r, s)\n    {\n      YR_MATCH* m;\n\n      yr_string_matches_foreach(context, s, m)\n      {\n        if (m->data_length > 0)\n          return CALLBACK_ERROR;\n      }\n    }\n  }\n\n  return CALLBACK_CONTINUE;\n}",
        "begin_line": 213,
        "end_line": 237,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_max_string_per_rules#166",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_max_string_per_rules()",
        "snippet": "void test_max_string_per_rules()\n{\n  uint32_t new_max_strings_per_rule = 1;\n  uint32_t old_max_strings_per_rule;\n\n  yr_initialize();\n\n  yr_get_configuration(\n      YR_CONFIG_MAX_STRINGS_PER_RULE,\n      (void*) &old_max_strings_per_rule);\n\n  yr_set_configuration(\n      YR_CONFIG_MAX_STRINGS_PER_RULE,\n      (void*) &new_max_strings_per_rule);\n\n  assert_error(\n      \"rule test { \\\n         strings: \\\n           $ = \\\"uno\\\" \\\n           $ = \\\"dos\\\" \\\n         condition: \\\n           all of them }\",\n      ERROR_TOO_MANY_STRINGS);\n\n  new_max_strings_per_rule = 2;\n\n  yr_set_configuration(\n      YR_CONFIG_MAX_STRINGS_PER_RULE,\n      (void*) &new_max_strings_per_rule);\n\n  assert_error(\n      \"rule test { \\\n         strings: \\\n           $ = \\\"uno\\\" \\\n           $ = \\\"dos\\\" \\\n         condition: \\\n           all of them }\",\n      ERROR_SUCCESS);\n\n  yr_set_configuration(\n      YR_CONFIG_MAX_STRINGS_PER_RULE,\n      (void*) &old_max_strings_per_rule);\n\n  yr_finalize();\n}",
        "begin_line": 166,
        "end_line": 210,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_rules_stats#684",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_rules_stats()",
        "snippet": "void test_rules_stats()\n{\n  YR_RULES_STATS stats;\n\n  stats_for_rules(\"\\\n      rule test { \\\n      strings: $ = /.*/ \\\n      condition: all of them }\",\n      &stats);\n\n  assert_true_expr(stats.num_rules == 1);\n  assert_true_expr(stats.num_strings == 1);\n  assert_true_expr(stats.ac_root_match_list_length == 1);\n\n  stats_for_rules(\"\\\n      rule test { \\\n      strings: $ = \\\"abc\\\" \\\n      condition: all of them }\",\n      &stats);\n\n  assert_true_expr(stats.num_rules == 1);\n  assert_true_expr(stats.num_strings == 1);\n  assert_true_expr(stats.ac_matches == 1);\n  assert_true_expr(stats.ac_root_match_list_length == 0);\n  assert_true_expr(stats.top_ac_match_list_lengths[0] == 1);\n  assert_true_expr(stats.ac_match_list_length_pctls[1] == 1);\n  assert_true_expr(stats.ac_match_list_length_pctls[100] == 1);\n\n  stats_for_rules(\"\\\n      rule test { \\\n      strings: \\\n        $ = \\\"00000\\\" \\\n        $ = \\\"00001\\\" \\\n        $ = \\\"00002\\\" \\\n        $ = \\\"11110\\\" \\\n        $ = \\\"11111\\\" \\\n        $ = \\\"11112\\\" \\\n      condition: all of them }\",\n      &stats);\n\n  assert_true_expr(stats.num_rules == 1);\n  assert_true_expr(stats.num_strings == 6);\n  assert_true_expr(stats.ac_matches == 6);\n  assert_true_expr(stats.ac_root_match_list_length == 0);\n  assert_true_expr(stats.top_ac_match_list_lengths[0] == 3);\n  assert_true_expr(stats.ac_match_list_length_pctls[1] == 3);\n  assert_true_expr(stats.ac_match_list_length_pctls[100] == 3);\n\n  stats_for_rules(\"\\\n      rule test { \\\n      strings: \\\n        $ = \\\"00000\\\" \\\n        $ = \\\"00001\\\" \\\n        $ = \\\"00002\\\" \\\n        $ = \\\"11110\\\" \\\n        $ = \\\"22220\\\" \\\n        $ = \\\"33330\\\" \\\n        $ = \\\"33331\\\" \\\n        $ = \\\"44440\\\" \\\n      condition: all of them }\",\n      &stats);\n\n  assert_true_expr(stats.num_rules == 1);\n  assert_true_expr(stats.num_strings == 8);\n  assert_true_expr(stats.ac_matches == 8);\n  assert_true_expr(stats.ac_root_match_list_length == 0);\n  assert_true_expr(stats.top_ac_match_list_lengths[0] == 3);\n  assert_true_expr(stats.ac_match_list_length_pctls[1] == 1);\n  assert_true_expr(stats.ac_match_list_length_pctls[100] == 3);\n\n  stats_for_rules(\"\\\n      rule test { \\\n      condition: true }\",\n      &stats);\n\n  assert_true_expr(stats.num_rules == 1);\n  assert_true_expr(stats.num_strings== 0);\n  assert_true_expr(stats.ac_matches == 0);\n  assert_true_expr(stats.ac_root_match_list_length == 0);\n}",
        "begin_line": 684,
        "end_line": 763,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_save_load_rules#284",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_save_load_rules()",
        "snippet": "void test_save_load_rules()\n{\n  YR_COMPILER* compiler = NULL;\n  YR_RULES* rules = NULL;\n\n  struct COUNTERS counters;\n\n  counters.rules_not_matching = 0;\n  counters.rules_matching = 0;\n\n  char* rules_str = \"rule t {condition: bool_var and str_var == \\\"foobar\\\"}\";\n\n  yr_initialize();\n\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_compiler_define_boolean_variable(compiler, \"bool_var\", 1);\n  yr_compiler_define_string_variable(compiler, \"str_var\", \"foobar\");\n\n  if (yr_compiler_add_string(compiler, rules_str, NULL) != 0)\n  {\n    yr_compiler_destroy(compiler);\n    perror(\"yr_compiler_add_string\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (yr_compiler_get_rules(compiler, &rules) != ERROR_SUCCESS)\n  {\n    yr_compiler_destroy(compiler);\n    perror(\"yr_compiler_add_fd\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_compiler_destroy(compiler);\n\n  if (yr_rules_save(rules, \"test-rules.yarc\") != ERROR_SUCCESS)\n  {\n    yr_rules_destroy(rules);\n    perror(\"yr_rules_save\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_rules_destroy(rules);\n\n  if (yr_rules_load(\"test-rules.yarc\", &rules) != ERROR_SUCCESS)\n  {\n    perror(\"yr_rules_load\");\n    exit(EXIT_FAILURE);\n  }\n\n  int err = yr_rules_scan_mem(\n      rules,\n      (uint8_t *) \"\",\n       0,\n       0,\n       count,\n       &counters,\n       0);\n\n  if (err != ERROR_SUCCESS)\n  {\n    fprintf(stderr, \"test_save_load_rules: error: %d\\n\", err);\n    exit(EXIT_FAILURE);\n  }\n\n  if (counters.rules_matching != 1)\n  {\n    fprintf(\n        stderr,\n        \"test_save_load_rules: expecting 1 match, got: %d\\n\",\n        counters.rules_matching);\n\n    exit(EXIT_FAILURE);\n  }\n\n  yr_rules_destroy(rules);\n  yr_finalize();\n}",
        "begin_line": 284,
        "end_line": 365,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_scanner#368",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_scanner()",
        "snippet": "void test_scanner()\n{\n  const char* buf = \"dummy\";\n  const char* rules_str = \"\\\n    rule true_rule { \\\n       condition: true \\\n    } \\\n    rule false_rule { \\\n       condition: false \\\n    } \\\n    rule test { \\\n       condition: bool_var and int_var == 1 and str_var == \\\"foo\\\" \\\n    }\";\n\n  YR_COMPILER* compiler = NULL;\n  YR_RULES* rules = NULL;\n  YR_SCANNER* scanner1 = NULL;\n  YR_SCANNER* scanner2 = NULL;\n\n  int result;\n\n  yr_initialize();\n\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  // Define a few variables\n  yr_compiler_define_integer_variable(compiler, \"int_var\", 0);\n  yr_compiler_define_boolean_variable(compiler, \"bool_var\", 0);\n  yr_compiler_define_string_variable(compiler, \"str_var\", \"\");\n\n\n  if (yr_compiler_define_string_variable(\n      compiler, \"str_var\", \"\") != ERROR_DUPLICATED_EXTERNAL_VARIABLE)\n  {\n    yr_compiler_destroy(compiler);\n    perror(\"expecting ERROR_DUPLICATED_EXTERNAL_VARIABLE\");\n    exit(EXIT_FAILURE);\n  }\n\n  // Compile a rule that use the variables in the condition.\n  if (yr_compiler_add_string(compiler, rules_str, NULL) != 0)\n  {\n    yr_compiler_destroy(compiler);\n    perror(\"yr_compiler_add_string\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (yr_compiler_get_rules(compiler, &rules) != ERROR_SUCCESS)\n  {\n    yr_compiler_destroy(compiler);\n    perror(\"yr_compiler_get_rules\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_compiler_destroy(compiler);\n\n  // Create an scanner\n  if (yr_scanner_create(rules, &scanner1)!= ERROR_SUCCESS)\n  {\n    yr_rules_destroy(rules);\n    perror(\"yr_scanner_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  // Create another scanner\n  if (yr_scanner_create(rules, &scanner2)!= ERROR_SUCCESS)\n  {\n    yr_scanner_destroy(scanner1);\n    yr_rules_destroy(rules);\n    perror(\"yr_scanner_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  // Let's check the yr_scanner_scan_mem returns the appropriate error when\n  // called without specifying a callback.\n  result = yr_scanner_scan_mem(scanner1, (uint8_t *) buf, strlen(buf));\n\n  if (result != ERROR_CALLBACK_REQUIRED)\n  {\n    yr_scanner_destroy(scanner1);\n    yr_scanner_destroy(scanner2);\n    yr_rules_destroy(rules);\n    printf(\"expecting ERROR_CALLBACK_REQUIRED (%d), got: %d\\n\",\n           ERROR_CALLBACK_REQUIRED, result);\n    exit(EXIT_FAILURE);\n  }\n\n  struct COUNTERS counters;\n\n  counters.rules_not_matching = 0;\n  counters.rules_matching = 0;\n\n  // Set the callback and the correct variable values for the rule to match.\n  yr_scanner_set_callback(scanner1, count, &counters);\n  yr_scanner_define_integer_variable(scanner1, \"int_var\", 1);\n  yr_scanner_define_boolean_variable(scanner1, \"bool_var\", 1);\n  yr_scanner_define_string_variable(scanner1, \"str_var\", \"foo\");\n\n  // Set some other values for the second scanner to make sure it doesn't\n  // interfere with the first one.\n  yr_scanner_define_integer_variable(scanner2, \"int_var\", 2);\n  yr_scanner_define_boolean_variable(scanner2, \"bool_var\", 0);\n  yr_scanner_define_string_variable(scanner2, \"str_var\", \"bar\");\n\n  result = yr_scanner_scan_mem(scanner1, (uint8_t *) buf, strlen(buf));\n\n  if (result != ERROR_SUCCESS)\n  {\n    yr_scanner_destroy(scanner1);\n    yr_scanner_destroy(scanner2);\n    yr_rules_destroy(rules);\n    printf(\"expecting ERROR_SUCCESS (%d), got: %d\\n\",\n           ERROR_SUCCESS, result);\n    exit(EXIT_FAILURE);\n  }\n\n  if (counters.rules_matching != 2 ||\n      counters.rules_not_matching != 1)\n  {\n    yr_scanner_destroy(scanner1);\n    yr_scanner_destroy(scanner2);\n    yr_rules_destroy(rules);\n    exit(EXIT_FAILURE);\n  }\n\n  counters.rules_matching = 0;\n  counters.rules_not_matching = 0;\n\n  yr_scanner_set_flags(scanner1, SCAN_FLAGS_REPORT_RULES_MATCHING);\n  yr_scanner_set_callback(scanner1, count, &counters);\n  yr_scanner_scan_mem(scanner1, (uint8_t *) buf, strlen(buf));\n\n  if (counters.rules_matching != 2 ||\n      counters.rules_not_matching != 0)\n  {\n    yr_scanner_destroy(scanner1);\n    yr_scanner_destroy(scanner2);\n    yr_rules_destroy(rules);\n    exit(EXIT_FAILURE);\n  }\n\n  counters.rules_matching = 0;\n  counters.rules_not_matching = 0;\n\n  yr_scanner_set_flags(scanner2, SCAN_FLAGS_REPORT_RULES_NOT_MATCHING);\n  yr_scanner_set_callback(scanner2, count, &counters);\n  yr_scanner_scan_mem(scanner2, (uint8_t *) buf, strlen(buf));\n\n  if (counters.rules_not_matching != 2 ||\n      counters.rules_matching != 0)\n  {\n    yr_scanner_destroy(scanner1);\n    yr_scanner_destroy(scanner2);\n    yr_rules_destroy(rules);\n    exit(EXIT_FAILURE);\n  }\n\n  yr_scanner_destroy(scanner1);\n  yr_scanner_destroy(scanner2);\n  yr_rules_destroy(rules);\n  yr_finalize();\n}",
        "begin_line": 368,
        "end_line": 533,
        "is_bug": false
    },
    {
        "name": "tests.test-arena.advanced_tests#82",
        "src_path": "tests/test-arena.c",
        "class_name": "tests.test-arena",
        "signature": "tests.test-arena.advanced_tests()",
        "snippet": "static void advanced_tests()\n{\n  YR_ARENA* arena;\n\n  yr_initialize();\n\n  // Create arena with 3 buffers of 10 bytes of initial size. Only the first\n  // two are used, the third one is left empty on purpose.\n  int result = yr_arena_create(3, 10, &arena);\n  assert_true_expr(result == ERROR_SUCCESS);\n\n  YR_ARENA_REF ref;\n\n  // Allocate a struct in buffer 0 indicating that the field \"str\" is a\n  // relocatable pointer.\n  result = yr_arena_allocate_struct(\n      arena,\n      0,\n      sizeof(TEST_STRUCT),\n      &ref,\n      offsetof(TEST_STRUCT, str1),\n      offsetof(TEST_STRUCT, str2),\n      EOL);\n\n  assert_true_expr(result == ERROR_SUCCESS);\n\n  // Get the struct address, this pointer is valid as longs as we don't call\n  // any other function that allocates memory in buffer 0.\n  TEST_STRUCT* s = (TEST_STRUCT*) yr_arena_ref_to_ptr(arena, &ref);\n\n  // Write a string in buffer 1.\n  yr_arena_write_string(arena, 1, \"foo\", &ref);\n\n  // Get the string's address and store it in the struct's \"str\" field.\n  s->str1 = (char *) yr_arena_ref_to_ptr(arena, &ref);\n\n  // Write another string in buffer 1.\n  yr_arena_write_string(arena, 1, \"bar\", &ref);\n\n  // Get the string's address and store it in the struct's \"str\" field.\n  s->str2 = (char *) yr_arena_ref_to_ptr(arena, &ref);\n\n  // The arena should have two reloc entries for the \"str1\" and \"str2\" fields.\n  assert_true_expr(arena->reloc_list_head != NULL);\n  assert_true_expr(arena->reloc_list_tail != NULL);\n  assert_true_expr(arena->reloc_list_head->buffer_id == 0);\n  assert_true_expr(arena->reloc_list_tail->buffer_id == 0);\n  assert_true_expr(arena->reloc_list_head->offset == offsetof(TEST_STRUCT, str1));\n  assert_true_expr(arena->reloc_list_tail->offset == offsetof(TEST_STRUCT, str2));\n\n  // Write another string in buffer 1 that causes a buffer reallocation.\n  yr_arena_write_string(arena, 1, \"aaaaaaaaaaa\", NULL);\n\n  assert_true_expr(strcmp(s->str1, \"foo\") == 0);\n  assert_true_expr(strcmp(s->str2, \"bar\") == 0);\n\n  YR_STREAM stream;\n  FILE* fh = fopen(\"test-arena-stream\", \"w+\");\n\n  assert_true_expr(fh != NULL);\n\n  stream.user_data = fh;\n  stream.write = (YR_STREAM_WRITE_FUNC) fwrite;\n  stream.read = (YR_STREAM_READ_FUNC) fread;\n\n  if (yr_arena_save_stream(arena, &stream) != ERROR_SUCCESS)\n    exit(EXIT_FAILURE);\n\n  fflush(fh);\n  fseek(fh, 0, SEEK_SET);\n\n  assert_true_expr(strcmp(s->str1, \"foo\") == 0);\n  assert_true_expr(strcmp(s->str2, \"bar\") == 0);\n\n  yr_arena_release(arena);\n\n  result = yr_arena_load_stream(&stream, &arena);\n  assert_true_expr(result == ERROR_SUCCESS);\n\n  ref.buffer_id = 0;\n  ref.offset = 0;\n\n  s = (TEST_STRUCT*) yr_arena_ref_to_ptr(arena, &ref);\n\n  assert_true_expr(strcmp(s->str1, \"foo\") == 0);\n  assert_true_expr(strcmp(s->str2, \"bar\") == 0);\n\n  fclose(fh);\n  yr_arena_release(arena);\n  yr_finalize();\n}",
        "begin_line": 82,
        "end_line": 172,
        "is_bug": false
    },
    {
        "name": "tests.test-arena.basic_tests#36",
        "src_path": "tests/test-arena.c",
        "class_name": "tests.test-arena",
        "signature": "tests.test-arena.basic_tests()",
        "snippet": "static void basic_tests()\n{\n  YR_ARENA* arena;\n\n  yr_initialize();\n\n  // Create arena with 1 buffers of 10 bytes of initial size\n  assert_true_expr(yr_arena_create(2, 10, &arena) == ERROR_SUCCESS);\n\n  YR_ARENA_REF ref;\n\n  // Allocate 5 bytes.\n  assert_true_expr(\n      yr_arena_allocate_memory(arena, 0, 5, &ref) == ERROR_SUCCESS);\n\n  // Offset should be 0 as this is the first write.\n  assert_true_expr(ref.offset == 0);\n\n  // Write 16 bytes, \"123456789ABCDEF\" + null terminator. This forces a\n  // reallocation.\n  assert_true_expr(\n      yr_arena_write_string(arena, 0, \"123456789ABCDEF\", &ref) == ERROR_SUCCESS);\n\n  // Offset should be 5 as this was written after the first 5-bytes write.\n  assert_true_expr(ref.offset == 5);\n\n  // Write 4 bytes, \"bar\" + null terminator.\n  assert_true_expr(\n      yr_arena_write_string(arena, 0, \"123456789ABCDEF\", &ref) == ERROR_SUCCESS);\n\n  // Offset should be 21.\n  assert_true_expr(ref.offset == 21);\n\n  yr_arena_release(arena);\n  yr_finalize();\n}",
        "begin_line": 36,
        "end_line": 71,
        "is_bug": false
    },
    {
        "name": "tests.test-arena.defects4cpp_test_index#4",
        "src_path": "tests/test-arena.c",
        "class_name": "tests.test-arena",
        "signature": "tests.test-arena.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-arena.main#174",
        "src_path": "tests/test-arena.c",
        "class_name": "tests.test-arena",
        "signature": "tests.test-arena.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 52:\n  basic_tests();\n          break;\n      case 53:\n  advanced_tests();\n          break;\n  }\n\n  return 0;\n}",
        "begin_line": 174,
        "end_line": 187,
        "is_bug": false
    },
    {
        "name": "tests.test-atoms.defects4cpp_test_index#4",
        "src_path": "tests/test-atoms.c",
        "class_name": "tests.test-atoms",
        "signature": "tests.test-atoms.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-atoms.main#666",
        "src_path": "tests/test-atoms.c",
        "class_name": "tests.test-atoms",
        "signature": "tests.test-atoms.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  yr_initialize();\n\n  test_table_quality();\n  test_heuristic_quality();\n  test_atom_choose();\n\n  yr_finalize();\n  return 0;\n}",
        "begin_line": 666,
        "end_line": 676,
        "is_bug": false
    },
    {
        "name": "tests.test-atoms.test_atom_choose#277",
        "src_path": "tests/test-atoms.c",
        "class_name": "tests.test-atoms",
        "signature": "tests.test-atoms.test_atom_choose()",
        "snippet": "void test_atom_choose()\n{\n\n  struct atom atoms_61_XX_63_64[] = {\n      {4, {0x61, 0x00, 0x63, 0x64}},\n      {4, {0x61, 0x01, 0x63, 0x64}},\n      {4, {0x61, 0x02, 0x63, 0x64}},\n      {4, {0x61, 0x03, 0x63, 0x64}},\n      {4, {0x61, 0x04, 0x63, 0x64}},\n      {4, {0x61, 0x05, 0x63, 0x64}},\n      {4, {0x61, 0x06, 0x63, 0x64}},\n      {4, {0x61, 0x07, 0x63, 0x64}},\n      {4, {0x61, 0x08, 0x63, 0x64}},\n      {4, {0x61, 0x09, 0x63, 0x64}},\n      {4, {0x61, 0x0A, 0x63, 0x64}},\n      {4, {0x61, 0x0B, 0x63, 0x64}},\n      {4, {0x61, 0x0C, 0x63, 0x64}},\n      {4, {0x61, 0x0D, 0x63, 0x64}},\n      {4, {0x61, 0x0E, 0x63, 0x64}},\n      {4, {0x61, 0x0F, 0x63, 0x64}},\n      {4, {0x61, 0x10, 0x63, 0x64}},\n      {4, {0x61, 0x11, 0x63, 0x64}},\n      {4, {0x61, 0x12, 0x63, 0x64}},\n      {4, {0x61, 0x13, 0x63, 0x64}},\n      {4, {0x61, 0x14, 0x63, 0x64}},\n      {4, {0x61, 0x15, 0x63, 0x64}},\n      {4, {0x61, 0x16, 0x63, 0x64}},\n      {4, {0x61, 0x17, 0x63, 0x64}},\n      {4, {0x61, 0x18, 0x63, 0x64}},\n      {4, {0x61, 0x19, 0x63, 0x64}},\n      {4, {0x61, 0x1A, 0x63, 0x64}},\n      {4, {0x61, 0x1B, 0x63, 0x64}},\n      {4, {0x61, 0x1C, 0x63, 0x64}},\n      {4, {0x61, 0x1D, 0x63, 0x64}},\n      {4, {0x61, 0x1E, 0x63, 0x64}},\n      {4, {0x61, 0x1F, 0x63, 0x64}},\n      {4, {0x61, 0x20, 0x63, 0x64}},\n      {4, {0x61, 0x21, 0x63, 0x64}},\n      {4, {0x61, 0x22, 0x63, 0x64}},\n      {4, {0x61, 0x23, 0x63, 0x64}},\n      {4, {0x61, 0x24, 0x63, 0x64}},\n      {4, {0x61, 0x25, 0x63, 0x64}},\n      {4, {0x61, 0x26, 0x63, 0x64}},\n      {4, {0x61, 0x27, 0x63, 0x64}},\n      {4, {0x61, 0x28, 0x63, 0x64}},\n      {4, {0x61, 0x29, 0x63, 0x64}},\n      {4, {0x61, 0x2A, 0x63, 0x64}},\n      {4, {0x61, 0x2B, 0x63, 0x64}},\n      {4, {0x61, 0x2C, 0x63, 0x64}},\n      {4, {0x61, 0x2D, 0x63, 0x64}},\n      {4, {0x61, 0x2E, 0x63, 0x64}},\n      {4, {0x61, 0x2F, 0x63, 0x64}},\n      {4, {0x61, 0x30, 0x63, 0x64}},\n      {4, {0x61, 0x31, 0x63, 0x64}},\n      {4, {0x61, 0x32, 0x63, 0x64}},\n      {4, {0x61, 0x33, 0x63, 0x64}},\n      {4, {0x61, 0x34, 0x63, 0x64}},\n      {4, {0x61, 0x35, 0x63, 0x64}},\n      {4, {0x61, 0x36, 0x63, 0x64}},\n      {4, {0x61, 0x37, 0x63, 0x64}},\n      {4, {0x61, 0x38, 0x63, 0x64}},\n      {4, {0x61, 0x39, 0x63, 0x64}},\n      {4, {0x61, 0x3A, 0x63, 0x64}},\n      {4, {0x61, 0x3B, 0x63, 0x64}},\n      {4, {0x61, 0x3C, 0x63, 0x64}},\n      {4, {0x61, 0x3D, 0x63, 0x64}},\n      {4, {0x61, 0x3E, 0x63, 0x64}},\n      {4, {0x61, 0x3F, 0x63, 0x64}},\n      {4, {0x61, 0x40, 0x63, 0x64}},\n      {4, {0x61, 0x41, 0x63, 0x64}},\n      {4, {0x61, 0x42, 0x63, 0x64}},\n      {4, {0x61, 0x43, 0x63, 0x64}},\n      {4, {0x61, 0x44, 0x63, 0x64}},\n      {4, {0x61, 0x45, 0x63, 0x64}},\n      {4, {0x61, 0x46, 0x63, 0x64}},\n      {4, {0x61, 0x47, 0x63, 0x64}},\n      {4, {0x61, 0x48, 0x63, 0x64}},\n      {4, {0x61, 0x49, 0x63, 0x64}},\n      {4, {0x61, 0x4A, 0x63, 0x64}},\n      {4, {0x61, 0x4B, 0x63, 0x64}},\n      {4, {0x61, 0x4C, 0x63, 0x64}},\n      {4, {0x61, 0x4D, 0x63, 0x64}},\n      {4, {0x61, 0x4E, 0x63, 0x64}},\n      {4, {0x61, 0x4F, 0x63, 0x64}},\n      {4, {0x61, 0x50, 0x63, 0x64}},\n      {4, {0x61, 0x51, 0x63, 0x64}},\n      {4, {0x61, 0x52, 0x63, 0x64}},\n      {4, {0x61, 0x53, 0x63, 0x64}},\n      {4, {0x61, 0x54, 0x63, 0x64}},\n      {4, {0x61, 0x55, 0x63, 0x64}},\n      {4, {0x61, 0x56, 0x63, 0x64}},\n      {4, {0x61, 0x57, 0x63, 0x64}},\n      {4, {0x61, 0x58, 0x63, 0x64}},\n      {4, {0x61, 0x59, 0x63, 0x64}},\n      {4, {0x61, 0x5A, 0x63, 0x64}},\n      {4, {0x61, 0x5B, 0x63, 0x64}},\n      {4, {0x61, 0x5C, 0x63, 0x64}},\n      {4, {0x61, 0x5D, 0x63, 0x64}},\n      {4, {0x61, 0x5E, 0x63, 0x64}},\n      {4, {0x61, 0x5F, 0x63, 0x64}},\n      {4, {0x61, 0x60, 0x63, 0x64}},\n      {4, {0x61, 0x61, 0x63, 0x64}},\n      {4, {0x61, 0x62, 0x63, 0x64}},\n      {4, {0x61, 0x63, 0x63, 0x64}},\n      {4, {0x61, 0x64, 0x63, 0x64}},\n      {4, {0x61, 0x65, 0x63, 0x64}},\n      {4, {0x61, 0x66, 0x63, 0x64}},\n      {4, {0x61, 0x67, 0x63, 0x64}},\n      {4, {0x61, 0x68, 0x63, 0x64}},\n      {4, {0x61, 0x69, 0x63, 0x64}},\n      {4, {0x61, 0x6A, 0x63, 0x64}},\n      {4, {0x61, 0x6B, 0x63, 0x64}},\n      {4, {0x61, 0x6C, 0x63, 0x64}},\n      {4, {0x61, 0x6D, 0x63, 0x64}},\n      {4, {0x61, 0x6E, 0x63, 0x64}},\n      {4, {0x61, 0x6F, 0x63, 0x64}},\n      {4, {0x61, 0x70, 0x63, 0x64}},\n      {4, {0x61, 0x71, 0x63, 0x64}},\n      {4, {0x61, 0x72, 0x63, 0x64}},\n      {4, {0x61, 0x73, 0x63, 0x64}},\n      {4, {0x61, 0x74, 0x63, 0x64}},\n      {4, {0x61, 0x75, 0x63, 0x64}},\n      {4, {0x61, 0x76, 0x63, 0x64}},\n      {4, {0x61, 0x77, 0x63, 0x64}},\n      {4, {0x61, 0x78, 0x63, 0x64}},\n      {4, {0x61, 0x79, 0x63, 0x64}},\n      {4, {0x61, 0x7A, 0x63, 0x64}},\n      {4, {0x61, 0x7B, 0x63, 0x64}},\n      {4, {0x61, 0x7C, 0x63, 0x64}},\n      {4, {0x61, 0x7D, 0x63, 0x64}},\n      {4, {0x61, 0x7E, 0x63, 0x64}},\n      {4, {0x61, 0x7F, 0x63, 0x64}},\n      {4, {0x61, 0x80, 0x63, 0x64}},\n      {4, {0x61, 0x81, 0x63, 0x64}},\n      {4, {0x61, 0x82, 0x63, 0x64}},\n      {4, {0x61, 0x83, 0x63, 0x64}},\n      {4, {0x61, 0x84, 0x63, 0x64}},\n      {4, {0x61, 0x85, 0x63, 0x64}},\n      {4, {0x61, 0x86, 0x63, 0x64}},\n      {4, {0x61, 0x87, 0x63, 0x64}},\n      {4, {0x61, 0x88, 0x63, 0x64}},\n      {4, {0x61, 0x89, 0x63, 0x64}},\n      {4, {0x61, 0x8A, 0x63, 0x64}},\n      {4, {0x61, 0x8B, 0x63, 0x64}},\n      {4, {0x61, 0x8C, 0x63, 0x64}},\n      {4, {0x61, 0x8D, 0x63, 0x64}},\n      {4, {0x61, 0x8E, 0x63, 0x64}},\n      {4, {0x61, 0x8F, 0x63, 0x64}},\n      {4, {0x61, 0x90, 0x63, 0x64}},\n      {4, {0x61, 0x91, 0x63, 0x64}},\n      {4, {0x61, 0x92, 0x63, 0x64}},\n      {4, {0x61, 0x93, 0x63, 0x64}},\n      {4, {0x61, 0x94, 0x63, 0x64}},\n      {4, {0x61, 0x95, 0x63, 0x64}},\n      {4, {0x61, 0x96, 0x63, 0x64}},\n      {4, {0x61, 0x97, 0x63, 0x64}},\n      {4, {0x61, 0x98, 0x63, 0x64}},\n      {4, {0x61, 0x99, 0x63, 0x64}},\n      {4, {0x61, 0x9A, 0x63, 0x64}},\n      {4, {0x61, 0x9B, 0x63, 0x64}},\n      {4, {0x61, 0x9C, 0x63, 0x64}},\n      {4, {0x61, 0x9D, 0x63, 0x64}},\n      {4, {0x61, 0x9E, 0x63, 0x64}},\n      {4, {0x61, 0x9F, 0x63, 0x64}},\n      {4, {0x61, 0xA0, 0x63, 0x64}},\n      {4, {0x61, 0xA1, 0x63, 0x64}},\n      {4, {0x61, 0xA2, 0x63, 0x64}},\n      {4, {0x61, 0xA3, 0x63, 0x64}},\n      {4, {0x61, 0xA4, 0x63, 0x64}},\n      {4, {0x61, 0xA5, 0x63, 0x64}},\n      {4, {0x61, 0xA6, 0x63, 0x64}},\n      {4, {0x61, 0xA7, 0x63, 0x64}},\n      {4, {0x61, 0xA8, 0x63, 0x64}},\n      {4, {0x61, 0xA9, 0x63, 0x64}},\n      {4, {0x61, 0xAA, 0x63, 0x64}},\n      {4, {0x61, 0xAB, 0x63, 0x64}},\n      {4, {0x61, 0xAC, 0x63, 0x64}},\n      {4, {0x61, 0xAD, 0x63, 0x64}},\n      {4, {0x61, 0xAE, 0x63, 0x64}},\n      {4, {0x61, 0xAF, 0x63, 0x64}},\n      {4, {0x61, 0xB0, 0x63, 0x64}},\n      {4, {0x61, 0xB1, 0x63, 0x64}},\n      {4, {0x61, 0xB2, 0x63, 0x64}},\n      {4, {0x61, 0xB3, 0x63, 0x64}},\n      {4, {0x61, 0xB4, 0x63, 0x64}},\n      {4, {0x61, 0xB5, 0x63, 0x64}},\n      {4, {0x61, 0xB6, 0x63, 0x64}},\n      {4, {0x61, 0xB7, 0x63, 0x64}},\n      {4, {0x61, 0xB8, 0x63, 0x64}},\n      {4, {0x61, 0xB9, 0x63, 0x64}},\n      {4, {0x61, 0xBA, 0x63, 0x64}},\n      {4, {0x61, 0xBB, 0x63, 0x64}},\n      {4, {0x61, 0xBC, 0x63, 0x64}},\n      {4, {0x61, 0xBD, 0x63, 0x64}},\n      {4, {0x61, 0xBE, 0x63, 0x64}},\n      {4, {0x61, 0xBF, 0x63, 0x64}},\n      {4, {0x61, 0xC0, 0x63, 0x64}},\n      {4, {0x61, 0xC1, 0x63, 0x64}},\n      {4, {0x61, 0xC2, 0x63, 0x64}},\n      {4, {0x61, 0xC3, 0x63, 0x64}},\n      {4, {0x61, 0xC4, 0x63, 0x64}},\n      {4, {0x61, 0xC5, 0x63, 0x64}},\n      {4, {0x61, 0xC6, 0x63, 0x64}},\n      {4, {0x61, 0xC7, 0x63, 0x64}},\n      {4, {0x61, 0xC8, 0x63, 0x64}},\n      {4, {0x61, 0xC9, 0x63, 0x64}},\n      {4, {0x61, 0xCA, 0x63, 0x64}},\n      {4, {0x61, 0xCB, 0x63, 0x64}},\n      {4, {0x61, 0xCC, 0x63, 0x64}},\n      {4, {0x61, 0xCD, 0x63, 0x64}},\n      {4, {0x61, 0xCE, 0x63, 0x64}},\n      {4, {0x61, 0xCF, 0x63, 0x64}},\n      {4, {0x61, 0xD0, 0x63, 0x64}},\n      {4, {0x61, 0xD1, 0x63, 0x64}},\n      {4, {0x61, 0xD2, 0x63, 0x64}},\n      {4, {0x61, 0xD3, 0x63, 0x64}},\n      {4, {0x61, 0xD4, 0x63, 0x64}},\n      {4, {0x61, 0xD5, 0x63, 0x64}},\n      {4, {0x61, 0xD6, 0x63, 0x64}},\n      {4, {0x61, 0xD7, 0x63, 0x64}},\n      {4, {0x61, 0xD8, 0x63, 0x64}},\n      {4, {0x61, 0xD9, 0x63, 0x64}},\n      {4, {0x61, 0xDA, 0x63, 0x64}},\n      {4, {0x61, 0xDB, 0x63, 0x64}},\n      {4, {0x61, 0xDC, 0x63, 0x64}},\n      {4, {0x61, 0xDD, 0x63, 0x64}},\n      {4, {0x61, 0xDE, 0x63, 0x64}},\n      {4, {0x61, 0xDF, 0x63, 0x64}},\n      {4, {0x61, 0xE0, 0x63, 0x64}},\n      {4, {0x61, 0xE1, 0x63, 0x64}},\n      {4, {0x61, 0xE2, 0x63, 0x64}},\n      {4, {0x61, 0xE3, 0x63, 0x64}},\n      {4, {0x61, 0xE4, 0x63, 0x64}},\n      {4, {0x61, 0xE5, 0x63, 0x64}},\n      {4, {0x61, 0xE6, 0x63, 0x64}},\n      {4, {0x61, 0xE7, 0x63, 0x64}},\n      {4, {0x61, 0xE8, 0x63, 0x64}},\n      {4, {0x61, 0xE9, 0x63, 0x64}},\n      {4, {0x61, 0xEA, 0x63, 0x64}},\n      {4, {0x61, 0xEB, 0x63, 0x64}},\n      {4, {0x61, 0xEC, 0x63, 0x64}},\n      {4, {0x61, 0xED, 0x63, 0x64}},\n      {4, {0x61, 0xEE, 0x63, 0x64}},\n      {4, {0x61, 0xEF, 0x63, 0x64}},\n      {4, {0x61, 0xF0, 0x63, 0x64}},\n      {4, {0x61, 0xF1, 0x63, 0x64}},\n      {4, {0x61, 0xF2, 0x63, 0x64}},\n      {4, {0x61, 0xF3, 0x63, 0x64}},\n      {4, {0x61, 0xF4, 0x63, 0x64}},\n      {4, {0x61, 0xF5, 0x63, 0x64}},\n      {4, {0x61, 0xF6, 0x63, 0x64}},\n      {4, {0x61, 0xF7, 0x63, 0x64}},\n      {4, {0x61, 0xF8, 0x63, 0x64}},\n      {4, {0x61, 0xF9, 0x63, 0x64}},\n      {4, {0x61, 0xFA, 0x63, 0x64}},\n      {4, {0x61, 0xFB, 0x63, 0x64}},\n      {4, {0x61, 0xFC, 0x63, 0x64}},\n      {4, {0x61, 0xFD, 0x63, 0x64}},\n      {4, {0x61, 0xFE, 0x63, 0x64}},\n      {4, {0x61, 0xFF, 0x63, 0x64}},\n    };\n\n    struct atom atoms_61_62_0X_64[] = {\n      {4, {0x61, 0x62, 0x00, 0x64}},\n      {4, {0x61, 0x62, 0x01, 0x64}},\n      {4, {0x61, 0x62, 0x02, 0x64}},\n      {4, {0x61, 0x62, 0x03, 0x64}},\n      {4, {0x61, 0x62, 0x04, 0x64}},\n      {4, {0x61, 0x62, 0x05, 0x64}},\n      {4, {0x61, 0x62, 0x06, 0x64}},\n      {4, {0x61, 0x62, 0x07, 0x64}},\n      {4, {0x61, 0x62, 0x08, 0x64}},\n      {4, {0x61, 0x62, 0x09, 0x64}},\n      {4, {0x61, 0x62, 0x0A, 0x64}},\n      {4, {0x61, 0x62, 0x0B, 0x64}},\n      {4, {0x61, 0x62, 0x0C, 0x64}},\n      {4, {0x61, 0x62, 0x0D, 0x64}},\n      {4, {0x61, 0x62, 0x0E, 0x64}},\n      {4, {0x61, 0x62, 0x0F, 0x64}},\n    };\n\n    struct atom atoms_61_6X_63[] = {\n      {3, {0x61, 0x60, 0x63}},\n      {3, {0x61, 0x61, 0x63}},\n      {3, {0x61, 0x62, 0x63}},\n      {3, {0x61, 0x63, 0x63}},\n      {3, {0x61, 0x64, 0x63}},\n      {3, {0x61, 0x65, 0x63}},\n      {3, {0x61, 0x66, 0x63}},\n      {3, {0x61, 0x67, 0x63}},\n      {3, {0x61, 0x68, 0x63}},\n      {3, {0x61, 0x69, 0x63}},\n      {3, {0x61, 0x6A, 0x63}},\n      {3, {0x61, 0x6B, 0x63}},\n      {3, {0x61, 0x6C, 0x63}},\n      {3, {0x61, 0x6D, 0x63}},\n      {3, {0x61, 0x6E, 0x63}},\n      {3, {0x61, 0x6F, 0x63}},\n    };\n\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 84:\n    assert_re_atoms(\"abcd\", 1, (struct atom[]) {\n      {4, {0x61, 0x62, 0x63, 0x64}},\n    });\n          break;\n      case 85:\n    assert_re_atoms(\"abcd1234\", 1, (struct atom[]) {\n      {4, {0x31, 0x32, 0x33, 0x34}},\n    });\n          break;\n      case 86:\n    assert_re_atoms(\"a..d\", 1, (struct atom[]) {\n      {1, {0x61}},\n    });\n          break;\n      case 87:\n    assert_re_atoms(\"a..de\", 1, (struct atom[]) {\n      {2, {0x64, 0x65}},\n    });\n          break;\n      case 88:\n    assert_re_atoms(\"abcd.efgh\", 1, (struct atom[]) {\n      {4, {0x61, 0x62, 0x63, 0x64}},\n    });\n          break;\n      case 89:\n    assert_re_atoms(\"(abcd|efgh)\", 2, (struct atom[]) {\n      {4, {0x65, 0x66, 0x67, 0x68}},\n      {4, {0x61, 0x62, 0x63, 0x64}},\n    });\n          break;\n      case 90:\n    assert_re_atoms(\"(abcd|efgh|ij)\", 3, (struct atom[]) {\n      {2, {0x69, 0x6A}},\n      {4, {0x65, 0x66, 0x67, 0x68}},\n      {4, {0x61, 0x62, 0x63, 0x64}},\n    });\n          break;\n      case 91:\n    assert_re_atoms(\"a.cd\", 256, atoms_61_XX_63_64);\n          break;\n      case 92:\n    assert_hex_atoms(\"{61 62 63 64}\", 1, (struct atom[]) {\n      {4, {0x61, 0x62, 0x63, 0x64}},\n    });\n          break;\n      case 93:\n    assert_hex_atoms(\"{61 62 63 64 [1-5] 65 66 67 68}\", 1, (struct atom[]) {\n      {4, {0x61, 0x62, 0x63, 0x64}},\n    });\n          break;\n      case 94:\n    assert_hex_atoms(\"{61 62 63 [1-5] 65 66 67 68}\", 1, (struct atom[]) {\n      {4, {0x65, 0x66, 0x67, 0x68}},\n    });\n          break;\n      case 95:\n    assert_hex_atoms(\"{61 62 63 [1-5] 65 66 }\", 1, (struct atom[]) {\n      {3, {0x61, 0x62, 0x63}},\n    });\n          break;\n      case 96:\n    assert_hex_atoms(\"{61 6? 63 [1-5] 65 66 }\", 16, atoms_61_6X_63);\n          break;\n      case 97:\n    assert_hex_atoms(\"{(61 62 63 | 65 66 67 68)}\", 2, (struct atom[]) {\n      {4, {0x65, 0x66, 0x67, 0x68}},\n      {3, {0x61, 0x62, 0x63}},\n    });\n          break;\n      case 98:\n    assert_hex_atoms(\"{61 62 0? 64}\", 16, atoms_61_62_0X_64);\n          break;\n      case 99:\n    assert_hex_atoms(\"{11 ?? 11 ?? 22 33 44 55 66 }\", 1, (struct atom[]) {\n      {4, {0x22, 0x33, 0x44, 0x55}},\n    });\n        break;\n      case 100:\n    // Test case for issue #1025\n    assert_hex_atoms(\"{?? 11 22 33 ?? 55 66 }\", 1, (struct atom[]) {\n      {3, {0x11, 0x22, 0x33}},\n    });\n  }\n}",
        "begin_line": 277,
        "end_line": 663,
        "is_bug": false
    },
    {
        "name": "tests.test-atoms.test_heuristic_quality#105",
        "src_path": "tests/test-atoms.c",
        "class_name": "tests.test-atoms",
        "signature": "tests.test-atoms.test_heuristic_quality()",
        "snippet": "void test_heuristic_quality()\n{\n  YR_ATOMS_CONFIG c;\n\n  YR_ATOM a00000000 = {\n    .length = 4,\n    .bytes = {0x00, 0x00, 0x00, 0x00},\n    .mask = {0xFF, 0xFF, 0xFF, 0xFF}};\n\n  YR_ATOM a00000001 = {\n    .length = 4,\n    .bytes = {0x00, 0x00, 0x00, 0x01},\n    .mask = {0xFF, 0xFF, 0xFF, 0xFF}};\n\n  YR_ATOM a00000102 = {\n    .length = 4,\n    .bytes = {0x00, 0x00, 0x01, 0x02},\n    .mask = {0xFF, 0xFF, 0xFF, 0xFF}};\n\n  YR_ATOM a00010203 = {\n    .length = 4,\n    .bytes = {0x00, 0x01, 0x02, 0x03},\n    .mask = {0xFF, 0xFF, 0xFF, 0xFF}};\n\n  YR_ATOM a01020304 = {\n    .length = 4,\n    .bytes = {0x01, 0x02, 0x03, 0x04},\n    .mask = {0xFF, 0xFF, 0xFF, 0xFF}};\n\n  YR_ATOM a01 = {\n    .length = 1,\n    .bytes = {0x01},\n    .mask = {0xFF}};\n\n  YR_ATOM a0001 = {\n    .length = 2,\n    .bytes = {0x00, 0x01},\n    .mask = {0xFF, 0xFF}};\n\n  YR_ATOM a000001 = {\n    .length = 3,\n    .bytes = {0x00, 0x00, 0x01},\n    .mask = {0xFF, 0xFF, 0xFF}};\n\n  YR_ATOM a000102 = {\n    .length = 3,\n    .bytes = {0x00, 0x01, 0x02},\n    .mask = {0xFF, 0xFF, 0xFF}};\n\n  YR_ATOM a010203 = {\n    .length = 3,\n    .bytes = {0x01, 0x02, 0x03},\n    .mask = {0xFF, 0xFF, 0xFF}};\n\n  YR_ATOM a0102 = {\n    .length = 2,\n    .bytes = {0x01, 0x02},\n    .mask = {0xFF, 0xFF}};\n\n  YR_ATOM a01020000 = {\n    .length = 4,\n    .bytes = {0x01, 0x02, 0x00, 0x00},\n    .mask = {0xFF, 0xFF, 0xFF, 0xFF}};\n\n  YR_ATOM a0102XX04 = {\n    .length = 4,\n    .bytes = {0x01, 0x02, 0x03, 0x04},\n    .mask = {0xFF, 0xFF, 0x00, 0xFF}};\n\n  c.get_atom_quality = yr_atoms_heuristic_quality;\n\n  int q00000000 = yr_atoms_heuristic_quality(&c, &a00000000);\n  int q00000001 = yr_atoms_heuristic_quality(&c, &a00000001);\n  int q00000102 = yr_atoms_heuristic_quality(&c, &a00000102);\n  int q00010203 = yr_atoms_heuristic_quality(&c, &a00010203);\n  int q01020304 = yr_atoms_heuristic_quality(&c, &a01020304);\n  int q010203   = yr_atoms_heuristic_quality(&c, &a010203);\n  int q0102     = yr_atoms_heuristic_quality(&c, &a0102);\n  int q01       = yr_atoms_heuristic_quality(&c, &a01);\n  int q0001     = yr_atoms_heuristic_quality(&c, &a0001);\n  int q000001   = yr_atoms_heuristic_quality(&c, &a000001);\n  int q000102   = yr_atoms_heuristic_quality(&c, &a000102);\n  int q01020000 = yr_atoms_heuristic_quality(&c, &a01020000);\n  int q0102XX04 = yr_atoms_heuristic_quality(&c, &a0102XX04);\n\n\n  a010203.mask[1] = 0x00;\n\n  int q01XX03   = yr_atoms_heuristic_quality(&c, &a010203);\n\n  a010203.mask[1] = 0x0F;\n\n  int q01X203   = yr_atoms_heuristic_quality(&c, &a010203);\n\n  a010203.mask[1] = 0x0F;\n\n  int q010X03   = yr_atoms_heuristic_quality(&c, &a010203);\n\n  a010203.mask[2] = 0x0F;\n\n  int q010X0X   = yr_atoms_heuristic_quality(&c, &a010203);\n\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 63:\n  assert_true_expr(q00000001 > q00000000);\n          break;\n      case 64:\n  assert_true_expr(q00000001 > q000001);\n          break;\n      case 65:\n  assert_true_expr(q000001   > q0001);\n          break;\n      case 66:\n  assert_true_expr(q00000102 > q00000001);\n          break;\n      case 67:\n  assert_true_expr(q00010203 > q00000102);\n          break;\n      case 68:\n  assert_true_expr(q01020304 > q00010203);\n          break;\n      case 69:\n  assert_true_expr(q000102   > q000001);\n          break;\n      case 70:\n  assert_true_expr(q00010203 > q010203);\n          break;\n      case 71:\n  assert_true_expr(q010203   > q0102);\n          break;\n      case 72:\n  assert_true_expr(q0102     > q01);\n          break;\n      case 73:\n  assert_true_expr(q01X203   > q0102);\n          break;\n      case 74:\n  assert_true_expr(q01X203   > q0001);\n          break;\n      case 75:\n  assert_true_expr(q01X203   < q010203);\n          break;\n      case 76:\n  assert_true_expr(q01X203   == q010X03);\n          break;\n      case 77:\n  assert_true_expr(q01XX03   <= q0102);\n          break;\n      case 78:\n  assert_true_expr(q01XX03   < q010X03);\n          break;\n      case 79:\n  assert_true_expr(q01XX03   < q010203);\n          break;\n      case 80:\n  assert_true_expr(q010X0X   > q01);\n          break;\n      case 81:\n  assert_true_expr(q010X0X   < q010203);\n          break;\n      case 82:\n  assert_true_expr(q01020000 > q0102XX04);\n          break;\n      case 83:\n  assert_true_expr(q01020304 == YR_MAX_ATOM_QUALITY);\n          break;\n  }\n}",
        "begin_line": 105,
        "end_line": 273,
        "is_bug": false
    },
    {
        "name": "tests.test-atoms.test_table_quality#35",
        "src_path": "tests/test-atoms.c",
        "class_name": "tests.test-atoms",
        "signature": "tests.test-atoms.test_table_quality()",
        "snippet": "void test_table_quality()\n{\n  YR_ATOM_QUALITY_TABLE_ENTRY l1[] = {\n    {{0x00, 0x00, 0x00, 0x00}, 1},\n    {{0x00, 0x00, 0x00, 0x01}, 2},\n    {{0x00, 0x00, 0x00, 0x02}, 3},\n  };\n\n  YR_ATOM_QUALITY_TABLE_ENTRY l2[] = {\n    {{0x00, 0x00, 0x00, 0x00}, 1},\n    {{0x00, 0x00, 0x00, 0x01}, 2},\n    {{0x00, 0x00, 0x00, 0x02}, 3},\n    {{0x00, 0x00, 0x00, 0x03}, 4},\n  };\n\n  YR_ATOM a0 = {\n    .length = 4,\n    .bytes = {0x00, 0x00, 0x00, 0x00},\n    .mask = {0xFF, 0xFF, 0xFF, 0xFF}};\n\n  YR_ATOM a1 = {4, {0x00, 0x00, 0x00, 0x01}, {0xFF, 0xFF, 0xFF, 0xFF}};\n  YR_ATOM a2 = {4, {0x00, 0x00, 0x00, 0x02}, {0xFF, 0xFF, 0xFF, 0xFF}};\n  YR_ATOM a3 = {4, {0x00, 0x00, 0x00, 0x03}, {0xFF, 0xFF, 0xFF, 0xFF}};\n  YR_ATOM a4 = {4, {0x00, 0x00, 0x00, 0x00}, {0xFF, 0xFF, 0xFF, 0x00}};\n\n  YR_ATOMS_CONFIG c;\n\n  c.get_atom_quality = yr_atoms_table_quality;\n  c.quality_table = l1;\n  c.quality_table_entries = 3;\n\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 54:\n  assert_true_expr(yr_atoms_table_quality(&c, &a0) == 1);\n          break;\n      case 55:\n  assert_true_expr(yr_atoms_table_quality(&c, &a1) == 2);\n          break;\n      case 56:\n  assert_true_expr(yr_atoms_table_quality(&c, &a2) == 3);\n          break;\n      case 57:\n  assert_true_expr(yr_atoms_table_quality(&c, &a3) == YR_MAX_ATOM_QUALITY);\n          break;\n  }\n\n  c.quality_table = l2;\n  c.quality_table_entries = 4;\n\n  switch (index) {\n      case 58:\n  assert_true_expr(yr_atoms_table_quality(&c, &a0) == 1);\n          break;\n      case 59:\n  assert_true_expr(yr_atoms_table_quality(&c, &a1) == 2);\n          break;\n      case 60:\n  assert_true_expr(yr_atoms_table_quality(&c, &a2) == 3);\n          break;\n      case 61:\n  assert_true_expr(yr_atoms_table_quality(&c, &a3) == 4);\n          break;\n      case 62:\n  assert_true_expr(yr_atoms_table_quality(&c, &a4) == 1);\n          break;\n  }\n}",
        "begin_line": 35,
        "end_line": 102,
        "is_bug": false
    },
    {
        "name": "tests.test-bitmask.assert_clear_all#39",
        "src_path": "tests/test-bitmask.c",
        "class_name": "tests.test-bitmask",
        "signature": "tests.test-bitmask.assert_clear_all(YR_BITMASK* bitmask)",
        "snippet": "void assert_clear_all(YR_BITMASK* bitmask)\n{\n  for (int i = 0; i < BITMAP_SIZE; i++)\n  {\n    if (yr_bitmask_is_set(bitmask, i))\n    {\n      fprintf(stderr, \"bit %d is set and should not\\n\", i);\n      exit(EXIT_FAILURE);\n    }\n  }\n}",
        "begin_line": 39,
        "end_line": 49,
        "is_bug": false
    },
    {
        "name": "tests.test-bitmask.defects4cpp_test_index#4",
        "src_path": "tests/test-bitmask.c",
        "class_name": "tests.test-bitmask",
        "signature": "tests.test-bitmask.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-bitmask.main#233",
        "src_path": "tests/test-bitmask.c",
        "class_name": "tests.test-bitmask",
        "signature": "tests.test-bitmask.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 101:\n  test_set_clear();\n          break;\n      case 102:\n  test_find_non_colliding_offsets_1();\n          break;\n      case 103:\n  test_find_non_colliding_offsets_2();\n          break;\n  }\n  return 0;\n}",
        "begin_line": 233,
        "end_line": 248,
        "is_bug": false
    },
    {
        "name": "tests.test-bitmask.test_find_non_colliding_offsets_1#115",
        "src_path": "tests/test-bitmask.c",
        "class_name": "tests.test-bitmask",
        "signature": "tests.test-bitmask.test_find_non_colliding_offsets_1()",
        "snippet": "void test_find_non_colliding_offsets_1()\n{\n  uint32_t o = 0;\n\n  YR_BITMASK a[YR_BITMASK_SIZE(18)];\n  YR_BITMASK b[YR_BITMASK_SIZE(13)];\n\n  yr_bitmask_clear_all(a);\n  yr_bitmask_clear_all(b);\n\n  // Set odd bits in B and odd bits in A.\n  for (int i = 0; i < 13; i++)\n  {\n    if (i % 2 == 0)\n      yr_bitmask_set(b, i);\n    else\n      yr_bitmask_set(a, i);\n  }\n\n  // Bitmask A can accommodate B at offset 0.\n  if (yr_bitmask_find_non_colliding_offset(a, b, 18, 13, &o) != 0)\n    exit(EXIT_FAILURE);\n\n  yr_bitmask_clear_all(a);\n  yr_bitmask_clear_all(b);\n\n  // Set the following pattern in A:\n  // 1 0 1 0   0 0 0 1   0 0 0 0   0 0 1 1   0 0\n  yr_bitmask_set(a, 0);\n  yr_bitmask_set(a, 2);\n  yr_bitmask_set(a, 7);\n  yr_bitmask_set(a, 14);\n  yr_bitmask_set(a, 15);\n\n  // Set B to:\n  // 1 1 0 0   0 0 0 1   0 1 0 0  1\n  yr_bitmask_set(b, 0);\n  yr_bitmask_set(b, 1);\n  yr_bitmask_set(b, 7);\n  yr_bitmask_set(b, 9);\n  yr_bitmask_set(b, 12);\n\n  // Bitmask A can accommodate B at offset 4.\n  if (yr_bitmask_find_non_colliding_offset(a, b, 18, 13, &o) != 4)\n    exit(EXIT_FAILURE);\n\n\n  // Set the A to:\n  // 1 0 1 0   0 0 0 1   0 0 0 0   0 0 1 1   1 0\n  yr_bitmask_set(a, 16);\n\n  // Bitmask A can accommodate B at offset 10.\n  if (yr_bitmask_find_non_colliding_offset(a, b, 18, 13, &o) != 10)\n    exit(EXIT_FAILURE);\n\n\n  yr_bitmask_clear_all(a);\n  yr_bitmask_clear_all(b);\n\n  yr_bitmask_set(a, 0);\n  yr_bitmask_set(a, 3);\n\n  yr_bitmask_set(b, 0);\n  yr_bitmask_set(b, 1);\n  yr_bitmask_set(b, 3);\n\n  // Bitmask 1001 can accommodate 1101 at offset 2.\n  if (yr_bitmask_find_non_colliding_offset(a, b, 4, 4, &o) != 1)\n    exit(EXIT_FAILURE);\n\n  // Bitmask 1001 can accommodate 1001 at offset 1.\n  if (yr_bitmask_find_non_colliding_offset(a, a, 4, 4, &o) != 1)\n    exit(EXIT_FAILURE);\n\n  yr_bitmask_clear(a, 0);\n\n  // Bitmask 0001 can accommodate 1101 at offset 0.\n  if (yr_bitmask_find_non_colliding_offset(a, b, 4, 4, &o) != 1)\n    exit(EXIT_FAILURE);\n}",
        "begin_line": 115,
        "end_line": 194,
        "is_bug": false
    },
    {
        "name": "tests.test-bitmask.test_find_non_colliding_offsets_2#197",
        "src_path": "tests/test-bitmask.c",
        "class_name": "tests.test-bitmask",
        "signature": "tests.test-bitmask.test_find_non_colliding_offsets_2()",
        "snippet": "void test_find_non_colliding_offsets_2()\n{\n  uint32_t o = 0;\n\n  YR_BITMASK a[YR_BITMASK_SIZE(140)];\n  YR_BITMASK b[YR_BITMASK_SIZE(200)];\n\n  yr_bitmask_clear_all(a);\n  yr_bitmask_clear_all(b);\n\n  // Set odds bits in A and even bits in B.\n  for (int i = 0; i < 13; i++)\n  {\n    if (i % 2 == 0)\n      yr_bitmask_set(b, i);\n    else\n      yr_bitmask_set(a, i);\n  }\n\n  // Bitmask A can accommodate B at offset 0.\n  if (yr_bitmask_find_non_colliding_offset(a, b, 200, 140, &o) != 0)\n    exit(EXIT_FAILURE);\n\n  yr_bitmask_clear_all(a);\n  yr_bitmask_clear_all(b);\n\n  yr_bitmask_set(a, 130);\n\n  yr_bitmask_set(b, 0);\n  yr_bitmask_set(b, 130);\n\n  if (yr_bitmask_find_non_colliding_offset(a, b, 200, 140, &o) != 1)\n    exit(EXIT_FAILURE);\n}",
        "begin_line": 197,
        "end_line": 230,
        "is_bug": false
    },
    {
        "name": "tests.test-bitmask.test_set_clear#51",
        "src_path": "tests/test-bitmask.c",
        "class_name": "tests.test-bitmask",
        "signature": "tests.test-bitmask.test_set_clear()",
        "snippet": "void test_set_clear()\n{\n  YR_BITMASK bitmask[YR_BITMASK_SIZE(BITMAP_SIZE)];\n\n  yr_bitmask_clear_all(bitmask);\n\n  assert_clear_all(bitmask);\n\n  yr_bitmask_set(bitmask, 0);\n\n  if (yr_bitmask_is_not_set(bitmask, 0))\n    exit(EXIT_FAILURE);\n\n  yr_bitmask_clear(bitmask, 0);\n\n  if (yr_bitmask_is_set(bitmask, 0))\n    exit(EXIT_FAILURE);\n\n  yr_bitmask_set(bitmask, BITMAP_SIZE-1);\n\n  if (yr_bitmask_is_not_set(bitmask, BITMAP_SIZE - 1))\n    exit(EXIT_FAILURE);\n\n  yr_bitmask_clear(bitmask, BITMAP_SIZE-1);\n\n  if (yr_bitmask_is_set(bitmask, BITMAP_SIZE - 1))\n    exit(EXIT_FAILURE);\n\n  yr_bitmask_set(bitmask, 31);\n  yr_bitmask_set(bitmask, 32);\n  yr_bitmask_set(bitmask, 33);\n  yr_bitmask_set(bitmask, 63);\n  yr_bitmask_set(bitmask, 64);\n  yr_bitmask_set(bitmask, 65);\n\n  if (yr_bitmask_is_not_set(bitmask, 31))\n    exit(EXIT_FAILURE);\n\n  if (yr_bitmask_is_not_set(bitmask, 32))\n    exit(EXIT_FAILURE);\n\n  if (yr_bitmask_is_not_set(bitmask, 33))\n    exit(EXIT_FAILURE);\n\n  if (yr_bitmask_is_not_set(bitmask, 63))\n    exit(EXIT_FAILURE);\n\n  if (yr_bitmask_is_not_set(bitmask, 64))\n    exit(EXIT_FAILURE);\n\n  if (yr_bitmask_is_not_set(bitmask, 65))\n    exit(EXIT_FAILURE);\n\n  yr_bitmask_clear(bitmask, 31);\n  yr_bitmask_clear(bitmask, 32);\n  yr_bitmask_clear(bitmask, 33);\n  yr_bitmask_clear(bitmask, 63);\n  yr_bitmask_clear(bitmask, 64);\n  yr_bitmask_clear(bitmask, 65);\n\n  assert_clear_all(bitmask);\n}",
        "begin_line": 51,
        "end_line": 112,
        "is_bug": false
    },
    {
        "name": "tests.test-dex.defects4cpp_test_index#4",
        "src_path": "tests/test-dex.c",
        "class_name": "tests.test-dex",
        "signature": "tests.test-dex.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-dex.main#6",
        "src_path": "tests/test-dex.c",
        "class_name": "tests.test-dex",
        "signature": "tests.test-dex.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  yr_initialize();\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 104:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.header.magic == \\\n        dex.DEX_FILE_MAGIC_035 }\",\n      DEX_FILE);\n          break;\n      case 105:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.header.checksum == \\\n        0x3F9C602F }\",\n      DEX_FILE);\n          break;\n      case 106:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.header.data_size == \\\n        0x18C }\",\n      DEX_FILE);\n          break;\n      case 107:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.string_ids[0].value ==\\\n      \\\"<clinit>\\\" }\",\n      DEX_FILE);\n          break;\n      case 108:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.string_ids[8].value == \\\n        \\\"com.google.helloyara\\\" }\",\n      DEX_FILE);\n          break;\n      case 109:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.type_ids[0].descriptor_idx == \\\n        0x2 }\",\n      DEX_FILE);\n          break;\n      case 110:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.proto_ids[0].shorty_idx == \\\n        0x6 }\",\n      DEX_FILE);\n          break;\n      case 111:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.field_ids[0].class_idx == \\\n        0x1 }\",\n      DEX_FILE);\n          break;\n      case 112:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.method_ids[0].class_idx == \\\n        0x1 }\",\n      DEX_FILE);\n          break;\n      case 113:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.class_defs[0].class_idx == \\\n        0x1 }\",\n      DEX_FILE);\n          break;\n      case 114:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.number_of_fields == 2 }\",\n      DEX_FILE);\n          break;\n      case 115:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.field[0].class_name == \\\n        \\\"Lcom/android/tools/ir/server/AppInfo;\\\" }\",\n      DEX_FILE);\n          break;\n      case 116:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.field[0].name == \\\n        \\\"applicationId\\\" }\",\n      DEX_FILE);\n          break;\n      case 117:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.number_of_methods == 2 }\",\n      DEX_FILE);\n          break;\n      case 118:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.method[0].class_name == \\\n        \\\"Lcom/android/tools/ir/server/AppInfo;\\\" }\",\n      DEX_FILE);\n          break;\n      case 119:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.method[0].proto == \\\"V\\\" }\",\n      DEX_FILE);\n          break;\n      case 120:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.method[0].name == \\\n        \\\"<clinit>\\\" }\",\n      DEX_FILE);\n          break;\n      case 121:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.method[1].name == \\\n        \\\"<init>\\\" }\",\n      DEX_FILE);\n          break;\n      case 122:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.map_list.size == 12 }\",\n      DEX_FILE);\n          break;\n      case 123:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: \\\n          dex.map_list.map_item[0].type == dex.TYPE_HEADER_ITEM \\\n        }\",\n      DEX_FILE);\n          break;\n  }\n\n  yr_finalize();\n  return 0;\n}",
        "begin_line": 6,
        "end_line": 132,
        "is_bug": false
    },
    {
        "name": "tests.test-dotnet.defects4cpp_test_index#4",
        "src_path": "tests/test-dotnet.c",
        "class_name": "tests.test-dotnet",
        "signature": "tests.test-dotnet.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-dotnet.main#8",
        "src_path": "tests/test-dotnet.c",
        "class_name": "tests.test-dotnet",
        "signature": "tests.test-dotnet.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  char *top_srcdir = getenv(\"TOP_SRCDIR\");\n  if (top_srcdir)\n    chdir(top_srcdir);\n\n  yr_initialize();\n\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 124:\n  assert_true_rule_file(\n      \"import \\\"dotnet\\\" \\\n      rule test { \\\n        condition: \\\n          dotnet.assembly.name == \\\"hpjsoaputility.Sv.resources\\\" \\\n      }\",\n      \"tests/data/0ca09bde7602769120fadc4f7a4147347a7a97271370583586c9e587fd396171\");\n          break;\n      case 125:\n  assert_true_rule_file(\n      \"import \\\"dotnet\\\" \\\n      rule test { \\\n        condition: \\\n          dotnet.number_of_resources == 1 and \\\n          dotnet.resources[0].offset == 724 and \\\n          dotnet.resources[0].length == 180 and \\\n          dotnet.resources[0].name == \\\"hpjsoaputility.XmlStreamSoapExtension.pt.resources\\\" \\\n      }\",\n      \"tests/data/0ca09bde7602769120fadc4f7a4147347a7a97271370583586c9e587fd396171\");\n          break;\n      case 126:\n  assert_true_rule_file(\n      \"import \\\"dotnet\\\" \\\n      rule test { \\\n        condition: \\\n          dotnet.number_of_guids == 1 and \\\n          dotnet.guids[0] == \\\"3764d539-e21a-4366-bc7c-b56fa67efbb0\\\" \\\n      }\",\n      \"tests/data/0ca09bde7602769120fadc4f7a4147347a7a97271370583586c9e587fd396171\");\n          break;\n      case 127:\n  assert_true_rule_file(\n      \"import \\\"dotnet\\\" \\\n      rule test { \\\n        condition: \\\n          dotnet.number_of_streams == 5 and \\\n          dotnet.streams[0].name == \\\"#~\\\" and \\\n          dotnet.streams[1].name == \\\"#Strings\\\" and \\\n          dotnet.streams[2].name == \\\"#US\\\" and \\\n          dotnet.streams[3].name == \\\"#GUID\\\" and \\\n          dotnet.streams[4].name == \\\"#Blob\\\" \\\n      }\",\n      \"tests/data/0ca09bde7602769120fadc4f7a4147347a7a97271370583586c9e587fd396171\");\n          break;\n      case 128:\n  assert_true_rule_file(\n      \"import \\\"dotnet\\\" \\\n      rule test { \\\n        condition: \\\n          dotnet.module_name == \\\"hpjsoaputility.Sv.resources.dll\\\" and \\\n          dotnet.version == \\\"v2.0.50727\\\" \\\n      }\",\n      \"tests/data/0ca09bde7602769120fadc4f7a4147347a7a97271370583586c9e587fd396171\");\n          break;\n      case 129:\n  assert_true_rule_file(\n      \"import \\\"dotnet\\\" \\\n      rule test { \\\n        condition: \\\n          dotnet.number_of_guids == 2 and \\\n          dotnet.guids[0] == \\\"cb9aa69f-4951-49d2-98a1-18984dcfdb91\\\" and \\\n          dotnet.guids[1] == \\\"00000000-0000-0000-0000-000000000000\\\" \\\n      }\",\n      \"tests/data/33fc70f99be6d2833ae48852d611c8048d0c053ed0b2c626db4dbe902832a08b\");\n          break;\n      case 130:\n  assert_true_rule_file(\n      \"import \\\"dotnet\\\" \\\n      rule test { \\\n        condition: \\\n          dotnet.user_strings[0] == \\\"F\\\\x00r\\\\x00e\\\\x00e\\\\x00D\\\\x00i\\\\x00s\\\\x00c\\\\x00B\\\\x00u\\\\x00r\\\\x00n\\\\x00e\\\\x00r\\\\x00.\\\\x00S\\\\x00t\\\\x00r\\\\x00i\\\\x00n\\\\x00g\\\\x00R\\\\x00e\\\\x00s\\\\x00o\\\\x00u\\\\x00r\\\\x00c\\\\x00e\\\\x00s\\\\x00\\\" \\\n      }\",\n      \"tests/data/33fc70f99be6d2833ae48852d611c8048d0c053ed0b2c626db4dbe902832a08b\");\n          break;\n  }\n  yr_finalize();\n  return 0;\n}",
        "begin_line": 8,
        "end_line": 96,
        "is_bug": false
    },
    {
        "name": "tests.test-elf.defects4cpp_test_index#4",
        "src_path": "tests/test-elf.c",
        "class_name": "tests.test-elf",
        "signature": "tests.test-elf.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-elf.main#6",
        "src_path": "tests/test-elf.c",
        "class_name": "tests.test-elf",
        "signature": "tests.test-elf.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  yr_initialize();\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 131:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" rule test { condition: elf.type }\",\n      ELF32_FILE);\n          break;\n      case 132:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" rule test { condition: elf.type }\",\n      ELF64_FILE);\n          break;\n      case 133:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" rule test { condition: elf.machine == elf.EM_386 }\",\n      ELF32_FILE)\n          break;\n      case 134:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" rule test { condition: elf.machine == elf.EM_X86_64 }\",\n      ELF64_FILE)\n          break;\n      case 135:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        strings: $a = { b8 01 00 00 00 bb 2a } \\\n        condition: $a at elf.entry_point \\\n      }\",\n      ELF32_FILE);\n          break;\n      case 136:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        strings: $a = { b8 01 00 00 00 bb 2a } \\\n        condition: $a at elf.entry_point \\\n      }\",\n      ELF64_FILE);\n          break;\n      case 137:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" rule test { condition: elf.entry_point == 0xa0 }\",\n      ELF32_NOSECTIONS);\n          break;\n      case 138:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" rule test { condition: elf.entry_point == 0x1a0 }\",\n      ELF32_SHAREDOBJ);\n        break;\n      case 139:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: elf.sections[2].name == \\\".comment\\\" \\\n      }\",\n      ELF64_FILE);\n          break;\n      case 140:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: elf.machine == elf.EM_MIPS \\\n      }\",\n      ELF32_MIPS_FILE);\n          break;\n      case 141:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          elf.number_of_sections == 35 and elf.number_of_segments == 10 \\\n      }\",\n      ELF32_MIPS_FILE);\n          break;\n      case 142:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          for any i in (0..elf.number_of_sections): ( \\\n            elf.sections[i].type == elf.SHT_PROGBITS and  \\\n            elf.sections[i].address == 0x400600 and \\\n            elf.sections[i].name == \\\".text\\\") \\\n      }\",\n      ELF32_MIPS_FILE);\n          break;\n      case 143:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n        rule test { \\\n          condition: \\\n            for any i in (0..elf.number_of_segments): ( \\\n            elf.segments[i].type == elf.PT_LOAD and \\\n            elf.segments[i].virtual_address == 0x00400000 and \\\n            elf.segments[i].file_size == 0x95c)\\\n      }\",\n      ELF32_MIPS_FILE);\n          break;\n      case 144:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          elf.dynamic_section_entries == 19 and \\\n          elf.symtab_entries == 80 \\\n      }\",\n      ELF32_MIPS_FILE);\n          break;\n      case 145:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          for any i in (0..elf.symtab_entries): ( \\\n            elf.symtab[i].shndx == 9 and \\\n            elf.symtab[i].value == 0x400650 and \\\n            elf.symtab[i].name == \\\"_start_c\\\") \\\n      }\",\n      ELF32_MIPS_FILE);\n          break;\n      case 146:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          elf.symtab[68].name == \\\"_start_c\\\" and \\\n          elf.symtab[68].type == elf.STT_FUNC and \\\n          elf.symtab[68].bind == elf.STB_GLOBAL and \\\n          elf.symtab[68].value == 0x400650 and \\\n          elf.symtab[68].size == 56 \\\n      }\",\n      ELF32_MIPS_FILE);\n          break;\n      case 147:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          elf.dynamic[4].type == elf.DT_STRTAB and \\\n          elf.dynamic[4].val == 0x400484\\\n      }\",\n      ELF32_MIPS_FILE);\n          break;\n      case 148:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          for any i in (0..elf.dynamic_section_entries): ( \\\n            elf.dynamic[i].type == 0x70000006 and \\\n            elf.dynamic[i].val == 0x400000)\\\n      }\",\n      ELF32_MIPS_FILE);\n          break;\n      case 149:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: elf.machine == elf.EM_X86_64 \\\n      }\",\n      ELF_x64_FILE);\n          break;\n      case 150:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          elf.number_of_sections == 22 and \\\n          elf.number_of_segments == 7 \\\n      }\",\n      ELF_x64_FILE);\n          break;\n      case 151:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          for any i in (0..elf.number_of_sections): ( \\\n            elf.sections[i].type == elf.SHT_PROGBITS and \\\n            elf.sections[i].address == 0x601000 and \\\n            elf.sections[i].name == \\\".got.plt\\\") \\\n      }\",\n      ELF_x64_FILE);\n          break;\n      case 152:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n         condition: \\\n            for any i in (0..elf.number_of_segments): ( \\\n              elf.segments[i].type == elf.PT_LOAD and \\\n              elf.segments[i].virtual_address == 0x600e78 and \\\n              elf.segments[i].file_size == 0x1b0) \\\n      }\",\n      ELF_x64_FILE);\n          break;\n      case 153:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n         condition: \\\n            elf.dynamic_section_entries == 18 and \\\n            elf.symtab_entries == 48  \\\n      }\",\n      ELF_x64_FILE);\n          break;\n      case 154:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          for any i in (0..elf.symtab_entries): ( \\\n            elf.symtab[i].shndx == 8 and \\\n            elf.symtab[i].value == 0x400400 and \\\n            elf.symtab[i].name == \\\"main\\\") \\\n     }\",\n     ELF_x64_FILE);\n          break;\n      case 155:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          elf.symtab[20].name == \\\"__JCR_LIST__\\\" and \\\n          elf.symtab[20].type == elf.STT_OBJECT and \\\n          elf.symtab[20].bind == elf.STB_LOCAL and \\\n          elf.symtab[20].value == 0x600e88 and \\\n          elf.symtab[20].size == 0 \\\n      }\",\n      ELF_x64_FILE);\n          break;\n      case 156:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          elf.dynamic[13].type == elf.DT_PLTGOT and \\\n          elf.dynamic[13].val == 0x601000 \\\n     }\",\n     ELF_x64_FILE);\n          break;\n      case 157:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          for any i in (0..elf.dynamic_section_entries): ( \\\n            elf.dynamic[i].type == elf.DT_JMPREL and \\\n            elf.dynamic[i].val == 0x4003c0) \\\n      }\",\n      ELF_x64_FILE);\n          break;\n  }\n  yr_finalize();\n  return 0;\n}",
        "begin_line": 6,
        "end_line": 265,
        "is_bug": false
    },
    {
        "name": "tests.test-exception.crasher_func#99",
        "src_path": "tests/test-exception.c",
        "class_name": "tests.test-exception",
        "signature": "tests.test-exception.crasher_func (void* x)",
        "snippet": "void* crasher_func (void* x)\n{\n  sleep(1);\n  int *i = 0;\n  puts(\"crashing process...\");\n  *i = 0;\n  return NULL;\n}",
        "begin_line": 99,
        "end_line": 106,
        "is_bug": false
    },
    {
        "name": "tests.test-exception.defects4cpp_test_index#4",
        "src_path": "tests/test-exception.c",
        "class_name": "tests.test-exception",
        "signature": "tests.test-exception.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-exception.delay_callback#118",
        "src_path": "tests/test-exception.c",
        "class_name": "tests.test-exception",
        "signature": "tests.test-exception.delay_callback(     YR_SCAN_CONTEXT* context, int message, void* message_data, void* user_data)",
        "snippet": "int delay_callback(\n    YR_SCAN_CONTEXT* context,\n    int message,\n    void* message_data,\n    void* user_data)\n{\n  if (message == CALLBACK_MSG_RULE_MATCHING)\n  {\n    (*(int*) user_data)++;\n  }\n  puts(\"callback: delaying execution...\");\n  sleep(2);\n  return CALLBACK_CONTINUE;\n}",
        "begin_line": 118,
        "end_line": 131,
        "is_bug": false
    },
    {
        "name": "tests.test-exception.main#237",
        "src_path": "tests/test-exception.c",
        "class_name": "tests.test-exception",
        "signature": "tests.test-exception.main(int argc, char **argv)",
        "snippet": "int main(int argc, char **argv)\n{\n  char *op = getenv(\"TEST_OP\");\n  if (op == NULL)\n  {\n    int status;\n    int index = defects4cpp_test_index();\n    switch (index) {\n        case 158:\n    puts(\"Test: crash\");\n    setenv(\"TEST_OP\", \"CRASH\", 1);\n    status = reexec(argv[0]);\n    if (status != 0)\n      return 1;\n            break;\n        case 159:\n    puts(\"Test: crash-no-handle\");\n    setenv(\"TEST_OP\", \"CRASH-NO-HANDLE\", 1);\n    status = reexec(argv[0]);\n    if (!WIFSIGNALED(status))\n    {\n      fputs(\"Expected subprocess to be terminated by signal\\n\", stderr);\n      return 1;\n    }\n            break;\n        case 160:\n    puts(\"Test: blocked-signal\");\n    setenv(\"TEST_OP\", \"BLOCKED-SIGNAL\", 1);\n    status = reexec(argv[0]);\n    if (status != 0)\n      return 1;\n            break;\n        case 161:\n    puts(\"Test: crash-other-thread\");\n    setenv(\"TEST_OP\", \"CRASH-OTHER-THREAD\", 1);\n    status = reexec(argv[0]);\n    if (!WIFSIGNALED(status))\n    {\n      fputs(\"Expected subprocess to be terminated by signal\\n\", stderr);\n      return 1;\n    }\n            break;\n    }\n    puts(\"Done.\");\n  }\n  else if (!strcmp(op, \"CRASH\"))\n    return test_crash(1);\n  else if (!strcmp(op, \"CRASH-NO-HANDLE\"))\n    return test_crash(0);\n  else if (!strcmp(op, \"BLOCKED-SIGNAL\"))\n    return test_blocked_signal();\n  else if (!strcmp(op, \"CRASH-OTHER-THREAD\"))\n    return test_crash_other_thread();\n  else\n  {\n    fprintf(stderr, \"wrong op '%s'\\n\", op);\n    return 77;\n  }\n  return 0;\n}",
        "begin_line": 237,
        "end_line": 296,
        "is_bug": false
    },
    {
        "name": "tests.test-exception.reexec#221",
        "src_path": "tests/test-exception.c",
        "class_name": "tests.test-exception",
        "signature": "tests.test-exception.reexec(char *program)",
        "snippet": "int reexec(char *program)\n{\n  char *argv[] = { program, NULL };\n  int status;\n  int pid = fork();\n  switch(pid)\n  {\n  case 0:\n    return execve(program, argv, environ);\n  case -1:\n    return -1;\n  }\n  waitpid(pid, &status, 0);\n  return status;\n}",
        "begin_line": 221,
        "end_line": 235,
        "is_bug": false
    },
    {
        "name": "tests.test-exception.setup_crasher#109",
        "src_path": "tests/test-exception.c",
        "class_name": "tests.test-exception",
        "signature": "tests.test-exception.setup_crasher()",
        "snippet": "void setup_crasher()\n{\n  pthread_t t;\n  pthread_attr_t attr;\n  pthread_attr_init(&attr);\n  pthread_create(&t, &attr, &crasher_func, NULL);\n}",
        "begin_line": 109,
        "end_line": 115,
        "is_bug": false
    },
    {
        "name": "tests.test-exception.setup_mmap#58",
        "src_path": "tests/test-exception.c",
        "class_name": "tests.test-exception",
        "signature": "tests.test-exception.setup_mmap()",
        "snippet": "void setup_mmap()\n{\n  char* filename = strdup(\"yara-testblob.XXXXXX\");\n  fd = mkstemp(filename);\n\n  if (fd <= 0)\n  {\n    perror(\"Create temp file\");\n    exit(77);\n  }\n\n  unlink(filename);\n\n  memset(wbuf, 'a', sizeof(wbuf));\n\n  for (int i = 0; i < COUNT; i++)\n  {\n    if (write(fd, wbuf, sizeof(wbuf)) != sizeof(wbuf))\n      exit(EXIT_FAILURE);\n  }\n\n  mapped_region = mmap(\n      NULL, COUNT * sizeof(wbuf), PROT_READ, MAP_SHARED, fd, 0);\n\n  if (ftruncate(fd, COUNT * sizeof(wbuf) / 2) != 0)\n    exit(EXIT_FAILURE);\n}",
        "begin_line": 58,
        "end_line": 84,
        "is_bug": false
    },
    {
        "name": "tests.test-exception.setup_rules#86",
        "src_path": "tests/test-exception.c",
        "class_name": "tests.test-exception",
        "signature": "tests.test-exception.setup_rules()",
        "snippet": "void setup_rules()\n{\n  yr_initialize();\n\n  compile_rule(\n      \"rule test { strings: $a = \\\"aaaa\\\" condition: all of them }\",\n      &rules_a);\n\n  compile_rule(\n      \"rule test { strings: $a = { 00 00 00 00 } condition: all of them }\",\n      &rules_0);\n}",
        "begin_line": 86,
        "end_line": 97,
        "is_bug": false
    },
    {
        "name": "tests.test-exception.test_blocked_signal#191",
        "src_path": "tests/test-exception.c",
        "class_name": "tests.test-exception",
        "signature": "tests.test-exception.test_blocked_signal()",
        "snippet": "int test_blocked_signal() {\n  setup_mmap();\n  setup_rules();\n\n  puts(\"Sending blocked SIGUSR1 to ourselves...\");\n\n  sigset_t set;\n  sigemptyset(&set);\n  sigaddset(&set, SIGUSR1);\n  sigprocmask(SIG_BLOCK, &set, NULL);\n  kill(getpid(), SIGUSR1);\n\n  puts(\"Scanning for {00 00 00 00}...\");\n\n  struct COUNTERS counters;\n\n  counters.rules_not_matching = 0;\n  counters.rules_matching = 0;\n\n  int rc = yr_rules_scan_mem(\n      rules_0, mapped_region, COUNT * sizeof(wbuf), 0, count, &counters, 0);\n\n  printf(\"err = %d, matches = %d\\n\", rc, counters.rules_matching);\n\n  if (rc == ERROR_SUCCESS || counters.rules_matching != 0)\n    return 1;\n\n  return 0;\n}",
        "begin_line": 191,
        "end_line": 219,
        "is_bug": false
    },
    {
        "name": "tests.test-exception.test_crash#134",
        "src_path": "tests/test-exception.c",
        "class_name": "tests.test-exception",
        "signature": "tests.test-exception.test_crash(int handle_exceptions)",
        "snippet": "int test_crash(int handle_exceptions)\n{\n  setup_mmap();\n  setup_rules();\n\n  puts(\"Scanning for \\\"aaaa\\\"...\");\n\n  struct COUNTERS counters;\n\n  counters.rules_not_matching = 0;\n  counters.rules_matching = 0;\n\n  int flags = (handle_exceptions ? 0 : SCAN_FLAGS_NO_TRYCATCH);\n\n  int rc = yr_rules_scan_mem(\n      rules_a, mapped_region, COUNT * sizeof(wbuf), flags, count, &counters, 0);\n\n  printf(\"err = %d, matches = %d\\n\", rc, counters.rules_matching);\n\n  if (rc == ERROR_SUCCESS || counters.rules_matching != 0)\n    return 1;\n\n  return 0;\n}",
        "begin_line": 134,
        "end_line": 157,
        "is_bug": false
    },
    {
        "name": "tests.test-exception.test_crash_other_thread#164",
        "src_path": "tests/test-exception.c",
        "class_name": "tests.test-exception",
        "signature": "tests.test-exception.test_crash_other_thread()",
        "snippet": "int test_crash_other_thread()\n{\n  setup_mmap();\n  setup_rules();\n  setup_crasher();\n\n  uint8_t mem[4096];\n  memset(mem, 'a', sizeof(mem));\n\n  puts(\"Scanning for \\\"aaaa\\\"...\");\n  int matches = 0;\n\n  int rc = yr_rules_scan_mem(\n      rules_a, mem, sizeof(mem), 0, delay_callback, &matches, 0);\n\n  printf(\"err = %d, matches = %d\\n\", rc, matches);\n\n  if (rc == ERROR_SUCCESS || matches != 0)\n    return 1;\n\n  return 0;\n}",
        "begin_line": 164,
        "end_line": 185,
        "is_bug": false
    },
    {
        "name": "tests.test-macho.defects4cpp_test_index#4",
        "src_path": "tests/test-macho.c",
        "class_name": "tests.test-macho",
        "signature": "tests.test-macho.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-macho.main#8",
        "src_path": "tests/test-macho.c",
        "class_name": "tests.test-macho",
        "signature": "tests.test-macho.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  char *top_srcdir = getenv(\"TOP_SRCDIR\");\n  if (top_srcdir)\n    chdir(top_srcdir);\n\n  yr_initialize();\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 162:\n  //  Tests for executable files\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.cputype == macho.CPU_TYPE_X86 }\", MACHO_X86_FILE);\n          break;\n      case 163:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.filetype == macho.MH_EXECUTE }\", MACHO_X86_FILE);\n          break;\n      case 164:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.flags & macho.MH_PIE }\", MACHO_X86_FILE);\n          break;\n      case 165:\n  // Segments\n\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.number_of_segments == 4 }\", MACHO_X86_FILE);\n          break;\n      case 166:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.segments[0].segname == \\\"__PAGEZERO\\\" and \\\n    macho.segments[1].segname == \\\"__TEXT\\\" and \\\n    macho.segments[2].segname == \\\"__DATA\\\" and \\\n    macho.segments[3].segname == \\\"__LINKEDIT\\\" }\", MACHO_X86_FILE);\n          break;\n      case 167:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.segments[0].vmaddr == 0 and \\\n    macho.segments[0].vmsize == 0x1000 and \\\n    macho.segments[2].nsects == 2 and \\\n    macho.segments[3].fsize == 0x118 }\", MACHO_X86_FILE);\n      case 168:\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { condition: \\\n    macho.number_of_segments == 1 }\", \"tests/data/tiny-macho\");\n          break;\n      case 169:\n  // Sections\n\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.segments[1].sections[0].addr == 0x1e90 and \\\n    macho.segments[1].sections[0].size == 0xa6 and \\\n    macho.segments[1].sections[0].offset == 0x0e90 }\", MACHO_X86_FILE);\n          break;\n      case 170:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.segments[1].sections[0].sectname == \\\"__text\\\" and \\\n    macho.segments[1].sections[0].segname == \\\"__TEXT\\\" }\", MACHO_X86_FILE);\n          break;\n      case 171:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.segments[1].sections[1].sectname == \\\"__symbol_stub\\\" and \\\n    macho.segments[1].sections[2].sectname == \\\"__stub_helper\\\" and \\\n    macho.segments[1].sections[3].sectname == \\\"__cstring\\\" and \\\n    macho.segments[1].sections[4].sectname == \\\"__unwind_info\\\" and \\\n    macho.segments[2].sections[0].sectname == \\\"__nl_symbol_ptr\\\" and \\\n    macho.segments[2].sections[1].sectname == \\\"__la_symbol_ptr\\\" }\",\n    MACHO_X86_FILE);\n          break;\n      case 172:\n  // Entry point (LC_MAIN)\n\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.entry_point == 0xe90 }\", MACHO_X86_FILE);\n          break;\n      case 173:\n  // Tests for object files\n\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.cputype == macho.CPU_TYPE_X86 }\", MACHO_X86_OBJECT_FILE);\n          break;\n      case 174:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.filetype == macho.MH_OBJECT }\", MACHO_X86_OBJECT_FILE);\n          break;\n      case 175:\n  // Segments and sections\n\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.number_of_segments == 1 and macho.segments[0].segname == \\\"\\\" and \\\n    macho.segments[0].sections[0].sectname == \\\"__text\\\" and \\\n    macho.segments[0].sections[0].segname == \\\"__TEXT\\\" }\",\n    MACHO_X86_OBJECT_FILE);\n          break;\n      case 176:\n  // Tests for big-endian byte order\n\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.cputype == macho.CPU_TYPE_POWERPC }\", MACHO_PPC_FILE);\n          break;\n      case 177:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.filetype == macho.MH_EXECUTE }\", MACHO_PPC_FILE);\n          break;\n      case 178:\n  // Segments\n\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.number_of_segments == 4 and \\\n    macho.segments[0].segname == \\\"__PAGEZERO\\\" and \\\n    macho.segments[2].segname == \\\"__DATA\\\" and \\\n    macho.segments[2].nsects == 6 and \\\n    macho.segments[0].vmaddr == 0 and \\\n    macho.segments[0].vmsize == 0x1000 and \\\n    macho.segments[3].fileoff == 65536 and \\\n    macho.segments[3].fsize == 46032 }\", MACHO_PPC_FILE);\n          break;\n      case 179:\n  // Entry point (LC_UNIXTHREAD)\n\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.entry_point == 0xeb8 }\", MACHO_PPC_FILE);\n          break;\n      case 180:\n  // Tests for 64-bit and shared library files\n\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.cputype == macho.CPU_TYPE_X86_64 }\", MACHO_X86_64_DYLIB_FILE);\n          break;\n      case 181:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.filetype == macho.MH_DYLIB }\", MACHO_X86_64_DYLIB_FILE);\n          break;\n      case 182:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.flags & macho.MH_DYLDLINK and \\\n    macho.flags & macho.MH_NOUNDEFS and \\\n    macho.flags & macho.MH_NO_REEXPORTED_DYLIBS and \\\n    macho.flags & macho.MH_TWOLEVEL }\", MACHO_X86_64_DYLIB_FILE);\n          break;\n      case 183:\n  // Segments and sections\n\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.number_of_segments == 2 }\", MACHO_X86_64_DYLIB_FILE);\n          break;\n      case 184:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.segments[0].segname == \\\"__TEXT\\\" and \\\n    macho.segments[1].segname == \\\"__LINKEDIT\\\" }\", MACHO_X86_64_DYLIB_FILE);\n          break;\n      case 185:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.segments[1].vmaddr == 0x0000000000001000 and \\\n    macho.segments[1].vmsize == 0x0000000000001000 and \\\n    macho.segments[1].nsects == 0 and \\\n    macho.segments[1].fsize == 128 }\", MACHO_X86_64_DYLIB_FILE);\n          break;\n      case 186:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.segments[0].sections[0].sectname == \\\"__text\\\" and \\\n    macho.segments[0].sections[0].segname == \\\"__TEXT\\\" }\",\n    MACHO_X86_64_DYLIB_FILE);\n          break;\n      case 187:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.segments[0].sections[1].addr == 0x0000000000000f98 and \\\n    macho.segments[0].sections[1].size == 0x0000000000000048 and \\\n    macho.segments[0].sections[1].offset == 3992 }\", MACHO_X86_64_DYLIB_FILE);\n          break;\n      case 188:\n  // Mach-O Universal Binaries tests\n\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { condition: \\\n    macho.fat_magic == macho.FAT_MAGIC and macho.nfat_arch == 2 }\",\n    \"tests/data/tiny-universal\");\n          break;\n      case 189:\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { condition: \\\n    macho.fat_arch[0].cputype == macho.CPU_TYPE_I386 and \\\n    macho.fat_arch[0].cpusubtype == macho.CPU_SUBTYPE_I386_ALL and \\\n    macho.fat_arch[0].offset == 4096 and \\\n    macho.fat_arch[1].cputype == macho.CPU_TYPE_X86_64 and \\\n    macho.fat_arch[1].cpusubtype == macho.CPU_SUBTYPE_X86_64_ALL | \\\n    macho.CPU_SUBTYPE_LIB64 and macho.fat_arch[1].align == 12 }\",\n    \"tests/data/tiny-universal\");\n          break;\n      case 190:\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { condition: \\\n    macho.file[0].cputype == macho.fat_arch[0].cputype and \\\n    macho.file[1].cputype == macho.fat_arch[1].cputype }\",\n    \"tests/data/tiny-universal\");\n          break;\n      case 191:\n  // Entry points for files (LC_MAIN)\n\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { \\\n    strings: $1 = { 55 89 e5 56 83 ec 34 } \\\n    condition: $1 at macho.file[0].entry_point + macho.fat_arch[0].offset }\",\n    \"tests/data/tiny-universal\");\n          break;\n      case 192:\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { \\\n    strings: $1 = { 55 48 89 e5 48 83 ec 20 } \\\n    condition: $1 at macho.file[1].entry_point + macho.fat_arch[1].offset }\",\n    \"tests/data/tiny-universal\");\n          break;\n      case 193:\n  // Helper functions\n\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { condition: \\\n    macho.file[macho.file_index_for_arch(macho.CPU_TYPE_I386)].entry_point == \\\n    macho.file[0].entry_point }\", \"tests/data/tiny-universal\");\n          break;\n      case 194:\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { condition: \\\n    macho.file[macho.file_index_for_arch(macho.CPU_TYPE_X86_64)].entry_point == \\\n    macho.file[1].entry_point }\", \"tests/data/tiny-universal\");\n          break;\n      case 195:\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { condition: \\\n    macho.file[macho.file_index_for_arch(macho.CPU_TYPE_I386, \\\n               macho.CPU_SUBTYPE_I386_ALL)].entry_point == \\\n    macho.file[0].entry_point }\", \"tests/data/tiny-universal\");\n          break;\n      case 196:\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { condition: \\\n    macho.file[macho.file_index_for_arch(macho.CPU_TYPE_X86_64, \\\n               macho.CPU_SUBTYPE_X86_64_ALL | \\\n               macho.CPU_SUBTYPE_LIB64)].entry_point == \\\n    macho.file[1].entry_point }\", \"tests/data/tiny-universal\");\n          break;\n      case 197:\n  // Entry point for specific architecture\n\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { \\\n    strings: $1 = { 55 89 e5 56 83 ec 34 } \\\n    condition: $1 at macho.entry_point_for_arch(macho.CPU_TYPE_I386, \\\n                                       macho.CPU_SUBTYPE_I386_ALL) }\",\n    \"tests/data/tiny-universal\");\n          break;\n      case 198:\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { \\\n    strings: $1 = { 55 48 89 e5 48 83 ec 20 } \\\n    condition: $1 at macho.entry_point_for_arch(macho.CPU_TYPE_X86_64) }\",\n    \"tests/data/tiny-universal\");\n          break;\n  }\n  yr_finalize();\n  return 0;\n}",
        "begin_line": 8,
        "end_line": 257,
        "is_bug": false
    },
    {
        "name": "tests.test-math.defects4cpp_test_index#4",
        "src_path": "tests/test-math.c",
        "class_name": "tests.test-math",
        "signature": "tests.test-math.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-math.main#6",
        "src_path": "tests/test-math.c",
        "class_name": "tests.test-math",
        "signature": "tests.test-math.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  yr_initialize();\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 199:\n  assert_true_rule_blob(\n      \"import \\\"math\\\" \\\n      rule test { \\\n        condition: \\\n          math.min(0, 1) == 0 \\\n      }\",\n      \"A\");\n          break;\n      case 200:\n  assert_true_rule_blob(\n      \"import \\\"math\\\" \\\n      rule test { \\\n        condition: \\\n          math.max(0, 1) == 1 \\\n      }\",\n      \"A\");\n          break;\n  }\n  yr_finalize();\n  return 0;\n}",
        "begin_line": 6,
        "end_line": 32,
        "is_bug": false
    },
    {
        "name": "tests.test-pb.defects4cpp_test_index#4",
        "src_path": "tests/test-pb.c",
        "class_name": "tests.test-pb",
        "signature": "tests.test-pb.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-pb.main#35",
        "src_path": "tests/test-pb.c",
        "class_name": "tests.test-pb",
        "signature": "tests.test-pb.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  yr_initialize();\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 201:\n  assert_true_rule_module_data_file(\n      \"import \\\"pb_tests\\\" \\\n      rule test { \\\n        condition: \\\n          pb_tests.f_int32 == 1111 and \\\n          pb_tests.f_int64 == 2222 and \\\n          pb_tests.f_string == \\\"foo\\\" and \\\n          pb_tests.f_struct_array[0].f_enum == pb_tests.struct.enum.SECOND \\\n      }\",\n      \"tests/data/test-pb.data.bin\");\n          break;\n      case 202:\n  assert_true_rule_module_data_file(\n      \"import \\\"pb_tests\\\" \\\n      rule test { \\\n        condition: \\\n          for any s in pb_tests.f_struct_array : ( \\\n            s.f_nested_struct.f_int32 == 3333 \\\n          ) \\\n      }\",\n      \"tests/data/test-pb.data.bin\");\n          break;\n  }\n  yr_finalize();\n  return 0;\n}",
        "begin_line": 35,
        "end_line": 66,
        "is_bug": false
    },
    {
        "name": "tests.test-pe.defects4cpp_test_index#4",
        "src_path": "tests/test-pe.c",
        "class_name": "tests.test-pe",
        "signature": "tests.test-pe.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-pe.main#8",
        "src_path": "tests/test-pe.c",
        "class_name": "tests.test-pe",
        "signature": "tests.test-pe.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  char *top_srcdir = getenv(\"TOP_SRCDIR\");\n  if (top_srcdir)\n    chdir(top_srcdir);\n\n  yr_initialize();\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 203:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.imports(\\\"KERNEL32.dll\\\", \\\"DeleteCriticalSection\\\") \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 204:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.imports(\\\"KERNEL32.dll\\\", \\\"DeleteCriticalSection\\\") \\\n      }\",\n      \"tests/data/tiny-idata-51ff\");\n          break;\n      case 205:\n  assert_false_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.imports(\\\"KERNEL32.dll\\\", \\\"DeleteCriticalSection\\\") \\\n      }\",\n      \"tests/data/tiny-idata-5200\");\n          break;\n      case 206:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.imports(/.*/, /.*CriticalSection/) == 4 \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 207:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.imports(/kernel32\\\\.dll/i, /.*/) == 21 \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 208:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.imports(/.*/, /.*/) \\\n      }\",\n      \"tests/data/tiny-idata-5200\");\n          break;\n      case 209:\n  assert_false_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.imports(/.*/, /.*CriticalSection/) \\\n      }\",\n      \"tests/data/tiny-idata-5200\");\n          break;\n      case 210:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.number_of_imports == 2 \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 211:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.number_of_sections == 7 \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 212:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.entry_point == 0x14E0 \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 213:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.linker_version.major == 2 and \\\n          pe.linker_version.minor == 26 \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 214:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.sections[0].name == \\\".text\\\" and \\\n          pe.sections[1].name == \\\".data\\\" and \\\n          pe.sections[2].name == \\\".rdata\\\" and \\\n          pe.sections[3].name == \\\".bss\\\" and \\\n          pe.sections[4].name == \\\".idata\\\" and \\\n          pe.sections[5].name == \\\".CRT\\\" and \\\n          pe.sections[6].name == \\\".tls\\\" \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 215:\n  #if defined(HAVE_LIBCRYPTO) || \\\n      defined(HAVE_WINCRYPT_H) || \\\n      defined(HAVE_COMMONCRYPTO_COMMONCRYPTO_H)\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.imphash() == \\\"1720bf764274b7a4052bbef0a71adc0d\\\" \\\n      }\",\n      \"tests/data/tiny\");\n  #endif\n  #if defined(HAVE_LIBCRYPTO)\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.number_of_signatures == 1 and \\\n          pe.signatures[0].thumbprint == \\\"c1bf1b8f751bf97626ed77f755f0a393106f2454\\\" and \\\n          pe.signatures[0].subject == \\\"/C=US/ST=California/L=Menlo Park/O=Quicken, Inc./OU=Operations/CN=Quicken, Inc.\\\" \\\n      }\",\n      \"tests/data/079a472d22290a94ebb212aa8015cdc8dd28a968c6b4d3b88acdd58ce2d3b885\");\n  #endif\n      break;\n      case 216:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.section_index(\\\".text\\\") == 0 \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 217:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.section_index(pe.entry_point) == 0 \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 218:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.is_32bit() and not pe.is_64bit() \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 219:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.checksum == 0xA8DC \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 220:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.checksum == pe.calculate_checksum() \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 221:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.overlay.offset == 0x8000 and pe.overlay.size == 7 \\\n      }\",\n      \"tests/data/tiny-overlay\");\n          break;\n      case 222:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n         pe.overlay.size == 0 \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 223:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.pdb_path == \\\"D:\\\\\\\\workspace\\\\\\\\2018_R9_RelBld\\\\\\\\target\\\\\\\\checkout\\\\\\\\custprof\\\\\\\\Release\\\\\\\\custprof.pdb\\\" \\\n      }\",\n       \"tests/data/079a472d22290a94ebb212aa8015cdc8dd28a968c6b4d3b88acdd58ce2d3b885\");\n          break;\n      case 224:\n  assert_false_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.checksum == pe.calculate_checksum() \\\n      }\",\n      \"tests/data/tiny-idata-51ff\");\n          break;\n      case 225:\n  /*\n   * mtxex.dll is 23e72ce7e9cdbc80c0095484ebeb02f56b21e48fd67044e69e7a2ae76db631e5,\n   * which was taken from a Windows 10 install. The details of which are:\n   *         export_timestamp = 1827812126\n   *         dll_name = \"mtxex.dll\"\n   *         number_of_exports = 4\n   *         export_details\n   *            [0]\n   *                    offset = 1072\n   *                    name = \"DllGetClassObject\"\n   *                    forward_name = YR_UNDEFINED\n   *                    ordinal = 1\n   *            [1]\n   *                    offset = YR_UNDEFINED\n   *                    name = \"GetObjectContext\"\n   *                    forward_name = \"COMSVCS.GetObjectContext\"\n   *                    ordinal = 2\n   *            [2]\n   *                    offset = YR_UNDEFINED\n   *                    name = \"MTSCreateActivity\"\n   *                    forward_name = \"COMSVCS.MTSCreateActivity\"\n   *                    ordinal = 3\n   *            [3]\n   *                    offset = YR_UNDEFINED\n   *                    name = \"SafeRef\"\n   *                    forward_name = \"COMSVCS.SafeRef\"\n   *                    ordinal = 4\n   */\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.number_of_exports == 4 and \\\n          pe.dll_name == \\\"mtxex.dll\\\" and \\\n          pe.export_timestamp == 1827812126 and \\\n          pe.export_details[0].offset == 1072 and \\\n          pe.export_details[0].name == \\\"DllGetClassObject\\\" and \\\n          pe.export_details[0].ordinal == 1 and \\\n          pe.export_details[1].forward_name == \\\"COMSVCS.GetObjectContext\\\" \\\n      }\",\n      \"tests/data/mtxex.dll\");\n          break;\n      case 226:\n  // Make sure exports function is case insensitive (historically this has been\n  // the case) and supports ordinals...\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.exports(\\\"saferef\\\") and \\\n          pe.exports(4) and \\\n          pe.exports(/mtscreateactivity/i) \\\n      }\",\n      \"tests/data/mtxex.dll\");\n          break;\n      case 227:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.exports_index(\\\"MTSCreateActivity\\\") == 2 and \\\n          pe.exports_index(3) == 2 and \\\n          pe.exports_index(/mtscreateactivity/i) == 2 \\\n      }\",\n      \"tests/data/mtxex.dll\");\n          break;\n      case 228:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.export_details[0].name == \\\"CP_PutItem\\\" \\\n      }\",\n      \"tests/data/079a472d22290a94ebb212aa8015cdc8dd28a968c6b4d3b88acdd58ce2d3b885.upx\");\n          break;\n      case 229:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.rich_signature.toolid(157, 40219) == 1 and \\\n          pe.rich_signature.toolid(1, 0) > 40 and pe.rich_signature.toolid(1, 0) < 45 and \\\n          pe.rich_signature.version(30319) and \\\n          pe.rich_signature.version(40219, 170) == 11 \\\n      }\",\n      \"tests/data/079a472d22290a94ebb212aa8015cdc8dd28a968c6b4d3b88acdd58ce2d3b885\");\n          break;\n  // This is the first 840 bytes (just enough to make sure the rich header is\n  // parsed) of 3593d3d08761d8ddc269dde945c0cb07e5cef5dd46ad9eefc22d17901f542093.\n      case 230:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.rich_signature.offset == 0x200 and \\\n          pe.rich_signature.length == 64 and \\\n          pe.rich_signature.key == 0x9f1d8511 and \\\n          pe.rich_signature.clear_data == \\\"DanS\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x01\\\\x00\\\\x11\\\\x00\\\\x00\\\\x00\\\\xc3\\\\x0f]\\\\x00\\\\x03\\\\x00\\\\x00\\\\x00\\\\x09x\\\\x95\\\\x00\\\\x01\\\\x00\\\\x00\\\\x00\\\\x09x\\\\x83\\\\x00\\\\x05\\\\x00\\\\x00\\\\x00\\\\x09x\\\\x94\\\\x00\\\\x01\\\\x00\\\\x00\\\\x00\\\\x09x\\\\x91\\\\x00\\\\x01\\\\x00\\\\x00\\\\x00\\\" \\\n      }\",\n      \"tests/data/weird_rich\");\n          break;\n      case 231:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.language(0x09) and pe.locale(0x0409) \\\n      }\",\n      \"tests/data/mtxex.dll\");\n          break;\n  }\n  yr_finalize();\n  return 0;\n}",
        "begin_line": 8,
        "end_line": 351,
        "is_bug": false
    },
    {
        "name": "tests.test-re-split.defects4cpp_test_index#4",
        "src_path": "tests/test-re-split.c",
        "class_name": "tests.test-re-split",
        "signature": "tests.test-re-split.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-re-split.main#36",
        "src_path": "tests/test-re-split.c",
        "class_name": "tests.test-re-split",
        "signature": "tests.test-re-split.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  RE_AST* re_ast;\n  RE_AST* re_ast_remain;\n\n  RE_ERROR re_error;\n\n  int32_t min_gap;\n  int32_t max_gap;\n\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 232:\n  yr_initialize();\n  yr_re_parse_hex(\n      \"{ 01 02 03 04 [0-300] 05 06 07 08 [1-400] 09 0A 0B 0C }\",\n      &re_ast, &re_error);\n\n  assert(re_ast != NULL);\n\n  yr_re_ast_split_at_chaining_point(\n      re_ast, &re_ast_remain, &min_gap, &max_gap);\n\n  assert(re_ast != NULL);\n  assert(re_ast_remain != NULL);\n  assert(min_gap == 0);\n  assert(max_gap == 300);\n\n  yr_re_ast_destroy(re_ast);\n  re_ast = re_ast_remain;\n\n  yr_re_ast_split_at_chaining_point(\n      re_ast, &re_ast_remain, &min_gap, &max_gap);\n\n  assert(re_ast != NULL);\n  assert(re_ast_remain != NULL);\n  assert(min_gap == 1);\n  assert(max_gap == 400);\n\n  yr_re_ast_destroy(re_ast);\n  re_ast = re_ast_remain;\n\n  yr_re_ast_split_at_chaining_point(\n      re_ast, &re_ast_remain, &min_gap, &max_gap);\n\n  assert(re_ast != NULL);\n  assert(re_ast_remain == NULL);\n  yr_re_ast_destroy(re_ast);\n  yr_finalize();\n          break;\n  }\n  return 0;\n}",
        "begin_line": 36,
        "end_line": 88,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.defects4cpp_test_index#4",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.dpp_sighandler#2805",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.dpp_sighandler(int signum)",
        "snippet": "void dpp_sighandler(int signum) {\n#ifdef DPP_ENABLE_GCOV\n  __gcov_flush();\n#endif\n  sigaction(SIGABRT, &dpp_orig_sigaction, NULL);\n  raise(SIGABRT);\n}",
        "begin_line": 2805,
        "end_line": 2811,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.main#2813",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  {\n  dpp_gcov_sigaction.sa_handler = dpp_sighandler;\n  sigemptyset(&dpp_gcov_sigaction.sa_mask);\n  dpp_gcov_sigaction.sa_flags = 0;\n  sigaction(SIGABRT, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n  }\n  char *top_srcdir = getenv(\"TOP_SRCDIR\");\n  if (top_srcdir)\n    chdir(top_srcdir);\n\n  yr_initialize();\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 233:\n  test_boolean_operators();\n          break;\n      case 234:\n  test_comparison_operators();\n          break;\n      case 235:\n  test_arithmetic_operators();\n          break;\n      case 236:\n  test_bitwise_operators();\n          break;\n      case 237:\n  test_matches_operator();\n          break;\n      case 238:\n  test_syntax();\n          break;\n      case 239:\n  test_anonymous_strings();\n          break;\n      case 240:\n  test_strings();\n          break;\n      case 241:\n  test_wildcard_strings();\n          break;\n      case 242:\n  test_hex_strings();\n          break;\n      case 243:\n  test_count();\n          break;\n      case 244:\n  test_at();\n          break;\n      case 245:\n  test_in();\n          break;\n      case 246:\n  test_offset();\n          break;\n      case 247:\n  test_length();\n          break;\n      case 248:\n  test_of();\n          break;\n      case 249:\n  test_for();\n          break;\n      case 250:\n  test_re();\n          break;\n      case 251:\n  test_filesize();\n          break;\n      case 252:\n  test_include_files();\n          break;\n      case 253:\n  // test_compile_file();\n  // test_compile_files();\n\n  // test_externals();\n  // test_callback();\n  // test_compare();\n  test_comments();\n          break;\n      case 254:\n  test_modules();\n          break;\n      case 255:\n  test_integer_functions();\n          break;\n      case 256:\n  // test_string_io();\n  test_entrypoint();\n          break;\n      case 257:\n  test_global_rules();\n      case 258:\n          break;\n  test_tags();\n          break;\n      case 259:\n  #if !defined(USE_WINDOWS_PROC) && !defined(USE_NO_PROC)\n  test_process_scan();\n  #endif\n          break;\n      case 260:\n  #if defined(HASH_MODULE)\n  test_hash_module();\n  #endif\n          break;\n      case 261:\n  test_time_module();\n          break;\n      case 262:\n  test_performance_warnings();\n          break;\n  }\n  yr_finalize();\n  return 0;\n}",
        "begin_line": 2813,
        "end_line": 2932,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_anonymous_strings#387",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_anonymous_strings()",
        "snippet": "static void test_anonymous_strings()\n{\n  assert_true_rule(\n      \"rule test { strings: $ = \\\"a\\\" $ = \\\"b\\\" condition: all of them }\",\n      \"ab\");\n}",
        "begin_line": 387,
        "end_line": 392,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_arithmetic_operators#174",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_arithmetic_operators()",
        "snippet": "static void test_arithmetic_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: (1 + 1) * 2 == (9 - 1) \\\\ 2 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 5 % 2 == 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 + 1.5 == 3}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 3 \\\\ 2 == 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 3.0 \\\\ 2 == 1.5}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 + -1 == 0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -1 + -1 == -2}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 4 --2 * 2 == 8}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -1.0 * 1 == -1.0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1-1 == 0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -2.0-3.0 == -5}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: --1 == 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1--1 == 2}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 2 * -2 == -4}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -4 * 2 == -8}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -4 * -4 == 16}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -0x01 == -1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0o10 == 8 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0o100 == 64 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0o755 == 493 }\", NULL);\n\n  // TODO: This should return ERROR_INTEGER_OVERFLOW, but right now it returns\n  // ERROR_SYNTAX_ERROR because after the lexer aborts with ERROR_INTEGER_OVERFLOW\n  // the parser finds an unexpected end fails with error: unexpected $end.\n  assert_error(\n      \"rule test { condition: 9223372036854775808 > 0 }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(\n      \"rule test { condition: 9007199254740992KB > 0 }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(  // integer too long\n      \"rule test { condition: 8796093022208MB > 0 }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(  // integer too long\n     \"rule test { condition: 0x8000000000000000 > 0 }\",\n     ERROR_SYNTAX_ERROR);\n\n  assert_error(  // integer too long\n     \"rule test { condition: 0o1000000000000000000000 > 0 }\",\n     ERROR_SYNTAX_ERROR);\n\n  assert_error(\n     \"rule test { condition: 0x7FFFFFFFFFFFFFFF + 1 > 0 }\",\n     ERROR_INTEGER_OVERFLOW);\n\n  assert_error(\n     \"rule test { condition: 9223372036854775807 + 1 > 0 }\",\n     ERROR_INTEGER_OVERFLOW);\n\n  assert_error(\n     \"rule test { condition: -9223372036854775807 - 2 > 0 }\",\n     ERROR_INTEGER_OVERFLOW);\n\n  assert_error(\n     \"rule test { condition: -2 + -9223372036854775807 > 0 }\",\n     ERROR_INTEGER_OVERFLOW);\n\n  assert_error(\n     \"rule test { condition: 1 - -9223372036854775807 > 0 }\",\n     ERROR_INTEGER_OVERFLOW);\n\n  assert_error(\n     \"rule test { condition: 0x4000000000000000 * 2 }\",\n     ERROR_INTEGER_OVERFLOW);\n\n  assert_error(\n     \"rule test { condition: 4611686018427387904 * 2 }\",\n     ERROR_INTEGER_OVERFLOW);\n\n  assert_error(\n     \"rule test { condition: 4611686018427387904 * -2 }\",\n     ERROR_INTEGER_OVERFLOW);\n\n  assert_error(\n     \"rule test { condition: -4611686018427387904 * 2 }\",\n     ERROR_INTEGER_OVERFLOW);\n\n  assert_error(\n     \"rule test { condition: -4611686018427387904 * -2 }\",\n     ERROR_INTEGER_OVERFLOW);\n}",
        "begin_line": 174,
        "end_line": 298,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_at#1241",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_at()",
        "snippet": "static void test_at()\n{\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = \\\"ssi\\\" \\\n        condition: $a at 2 and $a at 5 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = \\\"ssi\\\" private \\\n        condition: $a at 2 and $a at 5 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = \\\"mis\\\" \\\n        condition: $a at ~0xFF & 0xFF }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 00 00 00 00 ?? 74 65 78 74 } \\\n        condition: $a at 308}\",\n      PE32_FILE);\n}",
        "begin_line": 1241,
        "end_line": 1266,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_bitwise_operators#301",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_bitwise_operators()",
        "snippet": "static void test_bitwise_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: 0x55 | 0xAA == 0xFF }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: ~0xAA ^ 0x5A & 0xFF == (~0xAA) ^ (0x5A & 0xFF) }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: ~0x55 & 0xFF == 0xAA }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 8 >> 2 == 2 }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 << 3 == 8 }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 << 64 == 0 }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 >> 64 == 0 }\",\n      NULL);\n\n  assert_error(\n      \"rule test { condition: 1 << -1 == 0 }\",\n      ERROR_INVALID_OPERAND);\n\n  assert_error(\n      \"rule test { condition: 1 >> -1 == 0 }\",\n      ERROR_INVALID_OPERAND);\n\n  assert_true_rule(\n      \"rule test { condition: 1 | 3 ^ 3 == 1 | (3 ^ 3) }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: ~0xAA ^ 0x5A & 0xFF == 0x0F }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 1 | 3 ^ 3 == (1 | 3) ^ 3}\",\n      NULL);\n\n}",
        "begin_line": 301,
        "end_line": 351,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_boolean_operators#43",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_boolean_operators()",
        "snippet": "static void test_boolean_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: true }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: true or false }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: true and true }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0x1 and 0x2}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: false }\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: true and false }\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: false or false }\", NULL);\n}",
        "begin_line": 43,
        "end_line": 65,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_comments#2159",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_comments()",
        "snippet": "static void test_comments()\n{\n  assert_true_rule(\n      \"rule test {\\n\\\n         condition:\\n\\\n             //  this is a comment\\n\\\n             /*** this is a comment ***/\\n\\\n             /* /* /*\\n\\\n                 this is a comment\\n\\\n             */\\n\\\n             true\\n\\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] // Inline comment\\n\\r \\\n          38 39 } \\\n        condition: !a == 9 }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 /* Inline comment */ [-] 38 39 } \\\n        condition: !a == 9 }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 /* Inline comment */ [-] 38 39 } \\\n                 $b = { 31 32 /* Inline comment */ [-] 35 36 } \\\n        condition: (!a == 9) and (!b == 6) }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 /* Inline comment with *asterisks* */ [-] 38 39 } \\\n        condition: !a == 9}\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 /* Inline multi-line\\n\\r \\\n                                 comment */ [-] 38 39 } \\\n        condition: !a == 9 }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { /*Some*/ 31 /*interleaved*/ [-] /*comments*/ 38 39 } \\\n        condition: !a == 9 }\",\n      \"1234567890\");\n}",
        "begin_line": 2159,
        "end_line": 2211,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_comparison_operators#68",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_comparison_operators()",
        "snippet": "static void test_comparison_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: 2 > 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 < 2 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 2 >= 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 <= 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 == 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 == 1.5}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.0 == 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 >= 1.0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.0 != 1.000000000000001 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.0 < 1.000000000000001 }\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 1.0 >= 1.000000000000001 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.000000000000001 > 1 }\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 1.000000000000001 <= 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.0 == 1.0000000000000001 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.0 >= 1.0000000000000001 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 >= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.0 >= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0.5 < 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0.5 <= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.0 <= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"abc\\\" == \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"abc\\\" <= \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"abc\\\" >= \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"ab\\\" < \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"abc\\\" > \\\"ab\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"abc\\\" < \\\"abd\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"abd\\\" > \\\"abc\\\"}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 1 != 1}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 1 != 1.0}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 2 > 3}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 2.1 < 2}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"abc\\\" != \\\"abc\\\"}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"abc\\\" > \\\"abc\\\"}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"abc\\\" < \\\"abc\\\"}\", NULL);\n\n}",
        "begin_line": 68,
        "end_line": 172,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_count#1229",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_count()",
        "snippet": "static void test_count()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: #a == 2 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" private condition: #a == 2 }\",\n      \"mississippi\");\n}",
        "begin_line": 1229,
        "end_line": 1238,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_entrypoint#2117",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_entrypoint()",
        "snippet": "static void test_entrypoint()\n{\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 6a 2a 58 c3 } \\\n        condition: $a at entrypoint }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { b8 01 00 00 00 bb 2a } \\\n        condition: $a at entrypoint }\",\n      ELF32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { b8 01 00 00 00 bb 2a } \\\n        condition: $a at entrypoint }\",\n      ELF64_FILE);\n\n  assert_false_rule(\n      \"rule test { condition: entrypoint >= 0 }\",\n      NULL);\n}",
        "begin_line": 2117,
        "end_line": 2140,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_filesize#2143",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_filesize()",
        "snippet": "static void test_filesize()\n{\n  char rule[80];\n\n  snprintf(\n      rule,\n      sizeof(rule),\n      \"rule test { condition: filesize == %zd }\",\n      sizeof(PE32_FILE));\n\n  assert_true_rule_blob(\n      rule,\n      PE32_FILE);\n}",
        "begin_line": 2143,
        "end_line": 2156,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_for#1407",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_for()",
        "snippet": "void test_for()\n{\n  assert_true_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n        condition: \\\n          for all i in (1..#a) : (@a[i] >= 2 and @a[i] <= 5) \\\n      }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n          $b = \\\"mi\\\" \\\n        condition: \\\n          for all i in (1..#a) : ( for all j in (1..#b) : (@a[i] >= @b[j])) \\\n      }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n        condition: \\\n          for all i in (1..#a) : (@a[i] == 5) \\\n      }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { \\\n        condition: \\\n          for any i in (1, 2, 3) : (i <= 1) \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { \\\n        condition: \\\n          for all i in (1, 2, 3) : (i >= 1) \\\n      }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { \\\n        condition: \\\n          for all i in (1, 0) : (i != 1) \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { \\\n        condition: \\\n          for any item in tests.struct_array : ( \\\n            item.i == 1 \\\n          ) \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { \\\n        condition: \\\n          for 0 item in tests.struct_array : ( \\\n            item.i == 100 \\\n          ) \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { \\\n        condition: \\\n          for any item in tests.integer_array : ( \\\n            item == 2 \\\n          ) \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { \\\n        condition: \\\n          for any item in tests.string_array : ( \\\n            item == \\\"bar\\\" \\\n          ) \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { \\\n        condition: \\\n          for all i in (3,5,4) : ( \\\n            i >= 3 and i <= 5 \\\n          ) \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { \\\n        condition: \\\n          for all i in (3..5) : ( \\\n            i >= 3 and i <= 5 \\\n          ) \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { \\\n        condition: \\\n          for 2 i in (5..10) : ( \\\n            i == 6 or i == 7 \\\n          ) \\\n      }\",\n      NULL);\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { \\\n        condition: \\\n          for any k,v in tests.empty_struct_dict : ( \\\n            true \\\n          ) \\\n      }\",\n    NULL);\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { \\\n        condition: \\\n          for all i in (1..tests.undefined.i) : ( \\\n            true \\\n          ) \\\n      }\",\n    NULL);\n\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { \\\n        condition: \\\n          for all i in (tests.undefined.i..10) : ( \\\n            true \\\n          ) \\\n      }\",\n    NULL);\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { \\\n        condition: \\\n          for all i in (1..tests.undefined.i) : ( \\\n            false \\\n          ) \\\n      }\",\n    NULL);\n\n  // Test case for issue #1180.\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { \\\n        condition: \\\n          not tests.string_array[4] contains \\\"foo\\\" \\\n      }\",\n    NULL);\n\n  // Test case for issue #1180.\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { \\\n        condition: \\\n          not tests.string_dict[\\\"undefined\\\"] matches /foo/ \\\n      }\",\n    NULL);\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { \\\n        condition: \\\n          not tests.undefined.i \\\n      }\",\n    NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { \\\n        condition: \\\n          for any k,v in tests.struct_dict : ( \\\n            k == \\\"foo\\\" and v.s == \\\"foo\\\" and v.i == 1 \\\n          ) \\\n      }\",\n      NULL);\n\n  assert_error(\n      \"import \\\"tests\\\" \\\n      rule test { \\\n        condition: \\\n          for any k,v in tests.integer_array : ( false ) \\\n      }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(\n      \"import \\\"tests\\\" \\\n      rule test { \\\n        condition: \\\n          for any a,b,c in tests.struct_dict : ( false ) \\\n      }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(\n      \"import \\\"tests\\\" \\\n      rule test { \\\n        condition: \\\n          for any i in tests.struct_dict : ( false ) \\\n      }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(\n      \"import \\\"tests\\\" \\\n      rule test { \\\n        condition: \\\n          for any i in tests.integer_array : ( undefined_ident ) \\\n      }\",\n      ERROR_UNDEFINED_IDENTIFIER);\n\n  assert_error(\n      \"import \\\"tests\\\" \\\n      rule test { \\\n        condition: \\\n          for any i in tests.integer_array : ( i == \\\"foo\\\" ) \\\n      }\",\n      ERROR_WRONG_TYPE);\n\n\n  assert_false_rule(\n      \"rule test { \\\n        condition: \\\n          for any i in (0,1): ( \\\n            for any j in (0,1): ( \\\n              for any k in (0,1): ( \\\n                for any l in (0,1): (\\\n                  false \\\n                ) \\\n              ) \\\n            ) \\\n        ) \\\n      }\",\n      NULL);\n}",
        "begin_line": 1407,
        "end_line": 1657,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_global_rules#2253",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_global_rules()",
        "snippet": "static void test_global_rules()\n{\n  assert_true_rule(\n      \"global private rule global_rule { \\\n        condition: \\\n          true \\\n      } \\\n      rule test { \\\n        condition: true \\\n      }\",\n      NULL);\n\n  assert_false_rule(\n      \"global private rule global_rule { \\\n        condition: \\\n          false \\\n      } \\\n      rule test { \\\n        condition: true \\\n      }\",\n      NULL);\n}",
        "begin_line": 2253,
        "end_line": 2274,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_hex_strings#1000",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_hex_strings()",
        "snippet": "static void test_hex_strings()\n{\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 01 00 00 60 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 0? 00 00 ?0 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\\\n\n      \"rule test { \\\n        strings: $a = { 6? 01 00 00 60 0? } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 01 [1-3] 60 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 01 [1-3] (60|61) 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [-] 6A 2A [-] 58 C3} \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [300-] 6A 2A [-] 58 C3} \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 2e 7? (65 | ?? ) 78 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_false_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [0-300] 6A 2A } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_false_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [0-128] 45 [0-128] 01 [0-128]  C3 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = {\\n 31 32 [-] 38 39 \\n\\r} \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 33 34 [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 33 34 [-] 38 39 } private \\\n        condition: $a }\",\n      \"1234567890\");\n\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [1] 34 35 [2] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test {\\\n         strings: $a = { 31 32 [1-] 34 35 [1-] 38 39 } \\\n         condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-3] 34 35 [1-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-2] 35 [1-] 37 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 33 } \\\n        condition: !a == 3}\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 34 } \\\n        condition: !a == 4}\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-2] 34 } \\\n        condition: !a == 4 }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 38 39 } \\\n        condition: all of them }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 32 33 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 35 36 [-] 31 32 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [2-] 34 35 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 33 34 [0-2] 36 37 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 34 35 [0-2] 36 37 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-3] 37 38 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [1] 33 34 } \\\n        condition: $a }\",\n      \"12\\n34\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = {31 32 [3-6] 32} \\\n        condition: !a == 6 }\",\n      \"12111222\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = {31 [0-3] (32|33)} \\\n        condition: !a == 2 }\",\n      \"122222222\");\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 [0] 02 } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { [-] 01 02 } condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 [-] } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 ([-] 03 | 04) } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 (03 [-] | 04) } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 (03 | 04 [-]) } \\\n        condition: $a \",\n      ERROR_INVALID_HEX_STRING);\n\n  /* TODO: tests.py:551 ff. */\n}",
        "begin_line": 1000,
        "end_line": 1226,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_in#1269",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_in()",
        "snippet": "static void test_in()\n{\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 6a 2a 58 c3 } \\\n        condition: $a in (entrypoint .. entrypoint + 1) }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 6a 2a 58 c3 } private \\\n        condition: $a in (entrypoint .. entrypoint + 1) }\",\n      PE32_FILE);\n}",
        "begin_line": 1269,
        "end_line": 1282,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_include_files#2565",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_include_files()",
        "snippet": "void test_include_files()\n{\n  assert_true_rule(\n      \"include \\\"tests/data/baz.yar\\\" rule t { condition: baz }\",\n      NULL);\n\n  assert_true_rule(\n      \"include \\\"tests/data/foo.yar\\\" rule t { condition: foo }\",\n      NULL);\n}",
        "begin_line": 2565,
        "end_line": 2574,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_integer_functions#2537",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_integer_functions()",
        "snippet": "void test_integer_functions()\n{\n  assert_true_rule(\n      \"rule test { condition: uint8(0) == 0xAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint16(0) == 0xBBAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint32(0) == 0xDDCCBBAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint8be(0) == 0xAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint16be(0) == 0xAABB}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint32be(0) == 0xAABBCCDD}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n}",
        "begin_line": 2537,
        "end_line": 2562,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_length#1305",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_length()",
        "snippet": "static void test_length()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*?ssi/ condition: !a == 5 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*?ssi/ private condition: !a == 5 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*?ssi/ condition: !a[1] == 5 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*ssi/ condition: !a == 8 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*ssi/ condition: !a[1] == 8 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi.*ppi/ condition: !a[1] == 9 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi.*ppi/ condition: !a[2] == 6 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D [1-3] 73 73 69 } condition: !a == 5}\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D [-] 73 73 69 } condition: !a == 5}\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D [-] 70 70 69 } condition: !a == 11}\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D 69 73 73 [-] 70 69 } condition: !a == 11}\",\n      \"mississippi\");\n}",
        "begin_line": 1305,
        "end_line": 1350,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_matches_operator#2213",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_matches_operator()",
        "snippet": "static void test_matches_operator()\n{\n  assert_true_rule(\n      \"rule test { condition: \\\"foo\\\" matches /foo/ }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"foo\\\" matches /bar/ }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"FoO\\\" matches /fOo/i }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"xxFoOxx\\\" matches /fOo/i }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"xxFoOxx\\\" matches /^fOo/i }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"xxFoOxx\\\" matches /fOo$/i }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"foo\\\" matches /^foo$/i }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"foo\\\\nbar\\\" matches /foo.*bar/s }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"foo\\\\nbar\\\" matches /foo.*bar/ }\",\n      NULL);\n}",
        "begin_line": 2213,
        "end_line": 2250,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_modules#2277",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_modules()",
        "snippet": "static void test_modules()\n{\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.one + 1 == tests.constants.two \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.foo == \\\"foo\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.empty == \\\"\\\"  \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.empty() == \\\"\\\"  \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.struct_array[1].i == 1  \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.struct_array[0].i == 1 or true \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.integer_array[0] == 0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.integer_array[1] == 1 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.integer_array[256] == 256 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_array[0] == \\\"foo\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_array[2] == \\\"baz\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_dict[\\\"foo\\\"] == \\\"foo\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_dict[\\\"bar\\\"] == \\\"bar\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.isum(1,2) == 3 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.isum(1,2,3) == 6 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.fsum(1.0,2.0) == 3.0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.fsum(1.0,2.0,3.0) == 6.0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.foobar(1) == tests.foobar(1) \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.foobar(1) != tests.foobar(2) \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.length(\\\"dummy\\\") == 5 \\\n      }\",\n      NULL);\n\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.struct_array[0].i == 1  \\\n      }\",\n      NULL);\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.isum(1,1) == 3 \\\n      }\",\n      NULL);\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.fsum(1.0,1.0) == 3.0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo/,\\\"foo\\\") == 3 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo/,\\\"bar\\\") == -1\\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo.bar/i,\\\"FOO\\\\nBAR\\\") == -1\\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo.bar/is,\\\"FOO\\\\nBAR\\\") == 7\\\n      }\",\n      NULL);\n\n  assert_error(\n      \"import \\\"\\\\x00\\\"\",\n      ERROR_INVALID_MODULE_NAME);\n\n  assert_error(\n      \"import \\\"\\\"\",\n      ERROR_INVALID_MODULE_NAME);\n}",
        "begin_line": 2277,
        "end_line": 2469,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_of#1353",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_of()",
        "snippet": "static void test_of()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" $b = \\\"mis\\\" $c = \\\"oops\\\" \"\n      \"condition: any of them }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" $b = \\\"mis\\\" private $c = \\\"oops\\\" \"\n      \"condition: 1 of them }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" $b = \\\"mis\\\" $c = \\\"oops\\\" \"\n      \"condition: 2 of them }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a1 = \\\"dummy1\\\" $b1 = \\\"dummy1\\\" $b2 = \\\"ssi\\\"\"\n      \"condition: any of ($a*, $b*) }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { \\\n         strings: \\\n           $ = /abc/ \\\n           $ = /def/ \\\n           $ = /ghi/ \\\n         condition: \\\n           for any of ($*) : ( for any i in (1..#): (uint8(@[i] - 1) == 0x00) )\\\n       }\",\n       \"abc\\000def\\000ghi\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n          $b = \\\"mis\\\" \\\n          $c = \\\"oops\\\" \\\n        condition: \\\n          all of them \\\n      }\",\n      \"mississippi\");\n\n  assert_error(\n      \"rule test { condition: all of ($a*) }\",\n      ERROR_UNDEFINED_STRING);\n\n  assert_error(\n      \"rule test { condition: all of them }\",\n      ERROR_UNDEFINED_STRING);\n}",
        "begin_line": 1353,
        "end_line": 1404,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_offset#1285",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_offset()",
        "snippet": "static void test_offset()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: @a == 2 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" private condition: @a == 2 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: @a == @a[1] }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: @a[2] == 5 }\",\n      \"mississippi\");\n}",
        "begin_line": 1285,
        "end_line": 1302,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_performance_warnings#2664",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_performance_warnings()",
        "snippet": "void test_performance_warnings()\n{\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 01 } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 01 ?? } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 01 ?? ?? } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 01 ?? ?? 02 } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 01 ?? ?2 03 } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 01 ?? 02 1? } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 1? 2? 3? } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 1? 2? 3? 04 } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 1? ?? 03 } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 00 01 } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 01 00 } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 00 00 } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 00 00 00 } \\\n        condition: $a }\")\n\n  assert_no_warnings(\n      \"rule test { \\\n        strings: $a = { 00 00 01 } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 00 00 00 00 } \\\n        condition: $a }\")\n\n  assert_no_warnings(\n      \"rule test { \\\n        strings: $a = { 00 00 00 01 } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { FF FF FF FF } \\\n        condition: $a }\")\n\n  assert_no_warnings(\n      \"rule test { \\\n        strings: $a = { 00 00 01 02 } \\\n        condition: $a }\")\n\n  assert_no_warnings(\n       \"rule test { \\\n        strings: $a = { 00 01 02 03 } \\\n        condition: $a }\")\n\n  assert_no_warnings(\n       \"rule test { \\\n        strings: $a = { 01 02 03 04 } \\\n        condition: $a }\")\n\n  assert_no_warnings(\n       \"rule test { \\\n        strings: $a = { 01 02 03 } \\\n        condition: $a }\")\n\n  assert_no_warnings(\n       \"rule test { \\\n        strings: $a = { 20 01 02 } \\\n        condition: $a }\")\n\n  assert_no_warnings(\n       \"rule test { \\\n        strings: $a = { 01 02 } \\\n        condition: $a }\")\n\n  assert_no_warnings(\n       \"rule test { \\\n        strings: $a = \\\"foo\\\" wide \\\n        condition: $a }\")\n\n  assert_no_warnings(\n       \"rule test { \\\n        strings: $a = \\\"MZ\\\" \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = \\\"                    \\\" xor(0x20) \\\n        condition: $a }\")\n\n  // This will eventually xor with 0x41 and should cause a warning.\n  assert_warning(\n      \"rule test { \\\n        strings: $a = \\\"AAAAAAAAAAAAAAAAAAAA\\\" xor \\\n        condition: $a }\")\n\n}",
        "begin_line": 2664,
        "end_line": 2802,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_process_scan#2593",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_process_scan()",
        "snippet": "void test_process_scan()\n{\n  int pid = fork();\n  int status = 0;\n  YR_RULES* rules;\n  int rc1, rc2;\n\n  struct COUNTERS counters;\n\n  counters.rules_not_matching = 0;\n  counters.rules_matching = 0;\n\n  if (pid == 0)\n  {\n    /* The string should appear somewhere in the shell's process space. */\n    if (execl(\"/bin/sh\", \"/bin/sh\", \"-c\", \"VAR='Hello, world!'; sleep 5; true\", NULL) == -1)\n      exit(1);\n  }\n  assert(pid > 0);\n\n  /* Give child process time to initialize */\n  sleep(1);\n\n  status = compile_rule(\"\\\n    rule test {\\\n      strings:\\\n        $a = { 48 65 6c 6c 6f 2c 20 77 6f 72 6c 64 21 }\\\n      condition:\\\n        all of them\\\n    }\", &rules);\n\n  if (status != ERROR_SUCCESS)\n  {\n    perror(\"compile_rule\");\n    exit(EXIT_FAILURE);\n  }\n\n  rc1 = yr_rules_scan_proc(rules, pid, 0, count, &counters, 0);\n  yr_rules_destroy(rules);\n  kill(pid, SIGALRM);\n\n  rc2 = waitpid(pid, &status, 0);\n  if (rc2 == -1)\n  {\n    perror(\"waitpid\");\n    exit(EXIT_FAILURE);\n  }\n  if (status != SIGALRM)\n  {\n    fprintf(stderr, \"Scanned process exited with unexpected status %d\\n\", status);\n    exit(EXIT_FAILURE);\n  }\n\n  switch (rc1) {\n  case ERROR_SUCCESS:\n    if (counters.rules_matching == 0)\n    {\n      fputs(\"Found no matches\\n\", stderr);\n      exit(EXIT_FAILURE);\n    }\n    break;\n  case ERROR_COULD_NOT_ATTACH_TO_PROCESS:\n    fputs(\"Could not attach to process, ignoring this error\\n\", stderr);\n    break;\n  default:\n    fprintf(stderr, \"yr_rules_scan_proc: Got unexpected error %d\\n\", rc1);\n    exit(EXIT_FAILURE);\n  }\n}",
        "begin_line": 2593,
        "end_line": 2661,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_re#1660",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_re()",
        "snippet": "void test_re()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi(s|p)/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssim*/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssa?/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /Miss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /(M|N)iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /[M-N]iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /(Mi|ssi)ssippi/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\tmi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\.mi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /^mississippi/ fullword condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /mississippi.*mississippi$/s condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /^ssi/ condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /ssi$/ condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /ssissi/ fullword condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /^[isp]+/ condition: $a }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 6 }\",\n      \"a\\0x\\0b\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 8 }\",\n      \"a\\0x\\0x\\0b\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"\\ta\\0b\\0c\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"x\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"x\\ta\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\\t\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0x\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0b\\t\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /\\\\b/ wide condition: $a }\",\n      \"abc\");\n\n  assert_regexp_syntax_error(\")\");\n  assert_true_regexp(\"abc\", \"abc\", \"abc\");\n  assert_false_regexp(\"abc\", \"xbc\");\n  assert_false_regexp(\"abc\", \"axc\");\n  assert_false_regexp(\"abc\", \"abx\");\n  assert_true_regexp(\"abc\", \"xabcx\", \"abc\");\n  assert_true_regexp(\"abc\", \"ababc\", \"abc\");\n  assert_true_regexp(\"a.c\", \"abc\", \"abc\");\n  assert_false_regexp(\"a.b\", \"a\\nb\");\n  assert_false_regexp(\"a.*b\", \"acc\\nccb\");\n  assert_false_regexp(\"a.{4,5}b\", \"acc\\nccb\");\n  assert_true_regexp(\"a.b\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"ab*c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab*bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*bc\", \"abbc\", \"abbc\");\n  assert_true_regexp(\"a.*bb\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"a.*?bbb\", \"abbbbbb\", \"abbb\");\n  assert_true_regexp(\"a.*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a.*c\", \"axyzc\", \"axyzc\");\n  assert_true_regexp(\"ab+c\", \"abbc\", \"abbc\");\n  assert_false_regexp(\"ab+c\", \"ac\");\n  assert_true_regexp(\"ab+\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"ab+?\", \"abbbb\", \"ab\");\n  assert_false_regexp(\"ab+bc\", \"abc\");\n  assert_false_regexp(\"ab+bc\", \"abq\");\n  assert_true_regexp(\"a+b+c\", \"aabbabc\", \"abc\");\n  assert_false_regexp(\"ab?bc\", \"abbbbc\");\n  assert_true_regexp(\"ab?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*?\", \"abbb\", \"a\");\n  assert_true_regexp(\"ab?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab??\", \"ab\", \"a\");\n  assert_true_regexp(\"a(b|x)c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a(b|x)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|.)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|x|y)c\", \"ayc\", \"ayc\");\n  assert_true_regexp(\"(a+|b)*\", \"ab\", \"ab\");\n  assert_true_regexp(\"a|b|c|d|e\", \"e\", \"e\");\n  assert_true_regexp(\"(a|b|c|d|e)f\", \"ef\", \"ef\");\n  assert_true_regexp(\"a|b\", \"a\", \"a\");\n  assert_true_regexp(\".b{2}\", \"abb\", \"abb\");\n  assert_true_regexp(\".b{2,3}\", \"abbb\", \"abbb\");\n  assert_true_regexp(\".b{2,3}?\", \"abbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\".b{2,3}cccc\", \"abbbcccc\", \"abbbcccc\");\n  assert_true_regexp(\".b{2,3}?cccc\", \"abbbcccc\", \"bbbcccc\");\n  assert_true_regexp(\"a.b{2,3}cccc\", \"aabbbcccc\", \"aabbbcccc\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{0,1}?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}bc\", \"bbc\", \"bc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"bc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1,2}c\", \"abbc\", \"abbc\");\n  assert_false_regexp(\"ab{1,2}c\", \"abbbc\");\n  assert_true_regexp(\"ab{1,}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{1,}b\", \"ab\");\n  assert_false_regexp(\"ab{1}c\", \"abbc\");\n  assert_false_regexp(\"ab{1}c\", \"ac\");\n  assert_true_regexp(\"ab{0,}c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab{1,1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{0,}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{,3}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{,2}c\", \"abbbc\");\n  assert_false_regexp(\"ab{4,5}bc\", \"abbbbc\");\n  assert_false_regexp(\"ab{3}c\", \"abbbbc\");  // Issue #817\n  assert_false_regexp(\"ab{4}c\", \"abbbbbc\");\n  assert_false_regexp(\"ab{5}c\", \"abbbbbbc\");\n  assert_true_regexp(\"ab{0,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{0,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{0,4}\", \"abbbbb\", \"abbbb\");\n  assert_true_regexp(\"ab{1,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{1,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{2,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{2,4}\", \"abbbbc\", \"abbbb\");\n  assert_true_regexp(\"ab{3,4}\", \"abbb\", \"abbb\");\n  assert_true_regexp(\"ab{3,5}\", \"abbbbb\", \"abbbbb\");\n  assert_false_regexp(\"ab{3,4}c\", \"abbbbbc\");\n  assert_false_regexp(\"ab{3,4}c\", \"abbc\");\n  assert_false_regexp(\"ab{3,5}c\", \"abbbbbbc\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,1}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,2}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,3}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,4}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{1,1}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{2,2}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"(a{2,3}b){2,3}\", \"aabaaabaab\", \"aabaaabaab\");\n  assert_true_regexp(\"(a{2,3}?b){2,3}?\", \"aabaaabaab\", \"aabaaab\");\n  assert_false_regexp(\"(a{4,5}b){4,5}\", \"aaaabaaaabaaaaab\");\n  assert_true_regexp(\"(a{4,5}b){4,5}\", \"aaaabaaaabaaaaabaaaaab\", \"aaaabaaaabaaaaabaaaaab\");\n  assert_true_regexp(\".(abc){0,1}\", \"xabcabcabcabc\", \"xabc\");\n  assert_true_regexp(\".(abc){0,2}\", \"xabcabcabcabc\", \"xabcabc\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"ab{.*}\", \"ab{c}\", \"ab{c}\");\n  assert_true_regexp(\".(aa){1,2}\", \"aaaaaaaaaa\", \"aaaaa\");\n  assert_true_regexp(\"a.(bc.){2}\", \"aabcabca\", \"aabcabca\");\n  assert_true_regexp(\"(ab{1,2}c){1,3}\", \"abbcabc\", \"abbcabc\");\n  assert_true_regexp(\"ab(c|cc){1,3}d\", \"abccccccd\", \"abccccccd\");\n  assert_true_regexp(\"a[bx]c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a[bx]c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a[0-9]*b\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[0-9]*b\", \"a0123456789b\", \"a0123456789b\");\n  assert_true_regexp(\"[0-9a-f]+\", \"0123456789abcdef\", \"0123456789abcdef\");\n  assert_true_regexp(\"[0-9a-f]+\", \"xyz0123456789xyz\", \"0123456789\");\n  assert_true_regexp(\"a[\\\\s\\\\S]b\", \"a b\", \"a b\");\n  assert_true_regexp(\"a[\\\\d\\\\D]b\", \"a1b\", \"a1b\");\n  assert_false_regexp(\"[x-z]+\", \"abc\");\n  assert_true_regexp(\"a[-]?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a[-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[b-]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[b-]\", \"ab\", \"ab\");\n  assert_true_regexp(\"[a-c-e]\", \"b\", \"b\");\n  assert_true_regexp(\"[a-c-e]\", \"-\", \"-\");\n  assert_false_regexp(\"[a-c-e]\", \"d\");\n  assert_regexp_syntax_error(\"[b-a]\");\n  assert_regexp_syntax_error(\"(abc\");\n  assert_regexp_syntax_error(\"abc)\");\n  assert_regexp_syntax_error(\"a[]b\");\n  assert_true_regexp(\"a[\\\\-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[\\\\-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a]\", \"a]\", \"a]\");\n  assert_true_regexp(\"a[]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[\\\\]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[^bc]d\", \"aed\", \"aed\");\n  assert_false_regexp(\"a[^bc]d\", \"abd\");\n  assert_true_regexp(\"a[^-b]c\", \"adc\", \"adc\");\n  assert_false_regexp(\"a[^-b]c\", \"a-c\");\n  assert_false_regexp(\"a[^]b]c\", \"a]c\");\n  assert_true_regexp(\"a[^]b]c\", \"adc\", \"adc\");\n  assert_true_regexp(\"[^ab]*\", \"cde\", \"cde\");\n  assert_regexp_syntax_error(\")(\");\n  assert_true_regexp(\"a\\\\sb\", \"a b\", \"a b\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\tb\", \"a\\tb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\nb\", \"a\\nb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\vb\", \"a\\vb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\fb\", \"a\\fb\");\n  assert_true_regexp(\"a[\\\\s]*b\", \"a \\t\\r\\n\\v\\fb\", \"a \\t\\r\\n\\v\\fb\");\n  assert_true_regexp(\"a[^\\\\S]*b\", \"a \\t\\r\\n\\v\\fb\", \"a \\t\\r\\n\\v\\fb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a b\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\tb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\rb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\nb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\vb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\fb\");\n  assert_true_regexp(\"foo([^\\\\s]*)\", \"foobar\\n\", \"foobar\");\n  assert_true_regexp(\"foo([^\\\\s]*)\", \"foobar\\r\\n\", \"foobar\");\n  assert_true_regexp(\"\\\\n\\\\r\\\\t\\\\f\\\\a\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"[\\\\n][\\\\r][\\\\t][\\\\f][\\\\a]\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"\\\\x01\\\\x02\\\\x03\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_true_regexp(\"[\\\\x01-\\\\x03]+\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_false_regexp(\"[\\\\x00-\\\\x02]+\", \"\\x03\\x04\\x05\");\n  assert_true_regexp(\"[\\\\x5D]\", \"]\", \"]\");\n  assert_true_regexp(\"[\\\\0x5A-\\\\x5D]\", \"\\x5B\", \"\\x5B\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5C-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"a\\\\wc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a\\\\wc\", \"a_c\", \"a_c\");\n  assert_true_regexp(\"a\\\\wc\", \"a0c\", \"a0c\");\n  assert_false_regexp(\"a\\\\wc\", \"a*c\");\n  assert_true_regexp(\"\\\\w+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"[\\\\w]+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"\\\\D+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\d]+\", \"0123456789\", \"0123456789\");\n  assert_true_regexp(\"[\\\\D]+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\da-fA-F]+\", \"123abc\", \"123abc\");\n  assert_false_regexp(\"^(ab|cd)e\", \"abcde\");\n  assert_true_regexp(\"(abc|)ef\", \"abcdef\", \"ef\");\n  assert_true_regexp(\"(abc|)ef\", \"abcef\", \"abcef\");\n  assert_true_regexp(\"\\\\babc\", \"abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\b\", \"abc\", \"abc\");\n  assert_false_regexp(\"\\\\babc\", \"1abc\");\n  assert_false_regexp(\"abc\\\\b\", \"abc1\");\n  assert_true_regexp(\"abc\\\\s\\\\b\", \"abc x\", \"abc \");\n  assert_false_regexp(\"abc\\\\s\\\\b\", \"abc  \");\n  assert_true_regexp(\"\\\\babc\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\b\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\", \"abcd\", \"abc\");\n  assert_false_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \"abcd\");\n  assert_false_regexp(\"\\\\Babc\", \"abc\");\n  assert_false_regexp(\"abc\\\\B\", \"abc\");\n  assert_true_regexp(\"\\\\Babc\", \"1abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\B\", \"abc1\", \"abc\");\n  assert_false_regexp(\"abc\\\\s\\\\B\", \"abc x\");\n  assert_true_regexp(\"abc\\\\s\\\\B\", \"abc  \", \"abc \");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\B\", \"abcd\", \"abc\");\n  assert_true_regexp(\"\\\\B\\\\w\\\\w\\\\w\", \"abcd\", \"bcd\");\n  assert_false_regexp(\"\\\\B\\\\w\\\\w\\\\w\\\\B\", \"abcd\");\n\n  // This is allowed in most regexp engines but in order to keep the\n  // grammar free of shift/reduce conflicts I've decided not supporting\n  // it. Users can use the (abc|) form instead.\n  assert_regexp_syntax_error(\"(|abc)ef\");\n\n  assert_true_regexp(\"((a)(b)c)(d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"(a|b)c*d\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"(ab|ab*)bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"ac\", \"ac\");\n  assert_true_regexp(\"a([bc]*)c*\", \"a\", \"a\");\n  assert_true_regexp(\"a([bc]*)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]+)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]*)(c+d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a[bcd]*dcdcde\", \"adcdcde\", \"adcdcde\");\n  assert_false_regexp(\"a[bcd]+dcdcde\", \"adcdcde\");\n  assert_true_regexp(\"\\\\((.*), (.*)\\\\)\", \"(a, b)\", \"(a, b)\");\n  assert_true_regexp(\"abc|123$\", \"abcx\", \"abc\");\n  assert_false_regexp(\"abc|123$\", \"123x\");\n  assert_true_regexp(\"abc|^123\", \"123\", \"123\");\n  assert_false_regexp(\"abc|^123\", \"x123\");\n  assert_true_regexp(\"^abc$\", \"abc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"abcc\");\n  assert_true_regexp(\"^abc\", \"abcc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"aabc\");\n  assert_false_regexp(\"abc^\", \"abc\");\n  assert_false_regexp(\"ab^c\", \"abc\");\n  assert_false_regexp(\"a^bcdef\", \"abcdef\")\n  assert_true_regexp(\"abc$\", \"aabc\", \"abc\");\n  assert_false_regexp(\"$abc\", \"abc\");\n  assert_true_regexp(\"(a|a$)bcd\", \"abcd\", \"abcd\");\n  assert_false_regexp(\"(a$|a$)bcd\", \"abcd\");\n  assert_false_regexp(\"(abc$|ab$)\", \"abcd\");\n  assert_true_regexp(\"^a(bc+|b[eh])g|.h$\", \"abhg\", \"abhg\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effgz\", \"effgz\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"ij\", \"ij\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effg\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"bcdd\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"reffgz\", \"effgz\");\n\n  // Test case for issue #324\n  assert_true_regexp(\"whatever|   x.   x\", \"   xy   x\", \"   xy   x\");\n\n  // Test case for issue #503, \\x without two following hex-digits\n  assert_regexp_syntax_error(\"\\\\x0\");\n  assert_regexp_syntax_error(\"\\\\x\");\n\n  assert_regexp_syntax_error(\"x{0,0}\");\n  assert_regexp_syntax_error(\"x{0}\");\n\n  assert_regexp_syntax_error(\"\\\\xxy\");\n\n  // Test case for issue #682\n  assert_true_regexp(\"(a|\\\\b)[a]{1,}\", \"aaaa\", \"aaaa\");\n\n  // Test cases for issue #1018\n  assert_true_regexp(\"(ba{4}){4,10}\", \"baaaabaaaabaaaabaaaabaaaa\", \"baaaabaaaabaaaabaaaabaaaa\");\n  assert_true_regexp(\"(ba{2}a{2}){5,10}\", \"baaaabaaaabaaaabaaaabaaaa\", \"baaaabaaaabaaaabaaaabaaaa\");\n  assert_true_regexp(\"(ba{3}){4,10}\", \"baaabaaabaaabaaabaaa\", \"baaabaaabaaabaaabaaa\");\n  assert_true_regexp(\"(ba{4}){5,10}\", \"baaaabaaaabaaaabaaaabaaaa\", \"baaaabaaaabaaaabaaaabaaaa\");\n  assert_false_regexp(\"(ba{4}){4,10}\", \"baaaabaaaabaaaa\");\n\n  // Test for integer overflow in repeat interval\n  assert_regexp_syntax_error(\"a{2977952116}\");\n\n  assert_error(\n      \"rule test { strings: $a = /a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(\n      \"rule test { strings: $a = /[a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  // Test case for issue #996\n  assert_error(\n      \"rule test {strings:$=/.{,}? /\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}t/ \\\n        condition: !a == 317 }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}?t/ \\\n        condition: !a == 314 }\",\n      PE32_FILE);\n\n  assert_false_rule(\n      \"rule test { strings: $a = /abc[^d]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /abc[^d]/ condition: $a }\",\n      \"abcd\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /abc[^D]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^D]/ condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^f]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^f]/ condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^F]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n       \"rule test { strings: $a = /abc[^F]/ condition: $a }\",\n       \"abcd\");\n\n  // Test case for issue #1006\n  assert_false_rule_blob(\n       \"rule test { strings: $a = \\\" cmd.exe \\\" nocase wide condition: $a }\",\n       ISSUE_1006);\n\n  // Test case for issue #1117\n  assert_true_rule_blob(\n       \"rule test { strings: $a =/abc([^\\\"\\\\\\\\])*\\\"/ nocase condition: $a }\",\n       \"abc\\xE0\\x22\");\n}",
        "begin_line": 1660,
        "end_line": 2114,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_strings#395",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_strings()",
        "snippet": "static void test_strings()\n{\n  char* str = \"---- abc ---- xyz\";\n  uint8_t blob[] = \"---- a\\0b\\0c\\0 -\\0-\\0-\\0-\\0x\\0y\\0z\\0\";\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"a\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ab\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"xyz\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" nocase fullword condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"aBc\\\" nocase  condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      str);\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"a\\\" fullword condition: $a }\",\n      str);\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"ab\\\" fullword condition: $a }\",\n      str);\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      str);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"a\\\" wide condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"a\\\" wide ascii condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"ab\\\" wide condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"ab\\\" wide ascii condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide nocase fullword condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"aBc\\\" wide nocase condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"aBc\\\" wide ascii nocase condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"---xyz\\\" wide nocase condition: $a }\",\n      blob);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"abc\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"xabcx\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"xabc\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"abcx\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide condition: $a }\",\n      \"a\\1b\\0c\\0d\\0e\\0f\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"abcdef\\\" wide condition: $a }\",\n      \"a\\0b\\0c\\0d\\0e\\0f\\1\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" ascii wide fullword condition: $a }\",\n      \"abcx\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" ascii wide fullword condition: $a }\",\n      \"a\\0abc\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"x\\0a\\0b\\0c\\0x\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"ab\\\" wide fullword condition: $a }\",\n      \"x\\0a\\0b\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"x\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"x\\001a\\0b\\0c\\0\");\n\n  assert_true_rule(\n      \"rule test {\\n\\\n         strings:\\n\\\n             $a = \\\"abcdef\\\"\\n\\\n             $b = \\\"cdef\\\"\\n\\\n             $c = \\\"ef\\\"\\n\\\n         condition:\\n\\\n             all of them\\n\\\n       }\", \"abcdef\");\n\n  // xor by itself will match the plaintext version of the string too.\n  assert_true_rule_file(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"This program cannot\\\" xor\\n\\\n      condition:\\n\\\n        #a == 256\\n\\\n    }\", \"tests/data/xor.out\");\n\n  // Make sure the combination of xor and ascii behaves the same as just xor.\n  assert_true_rule_file(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"This program cannot\\\" xor ascii\\n\\\n      condition:\\n\\\n        #a == 256\\n\\\n    }\", \"tests/data/xor.out\");\n\n  assert_true_rule_file(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"This program cannot\\\" xor(1-0x10)\\n\\\n      condition:\\n\\\n        #a == 16\\n\\\n    }\", \"tests/data/xor.out\");\n\n  // We should have no matches here because we are not generating the ascii\n  // string, just the wide one, and the test data contains no wide strings.\n  assert_true_rule_file(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"This program cannot\\\" xor wide\\n\\\n      condition:\\n\\\n        #a == 0\\n\\\n    }\", \"tests/data/xor.out\");\n\n  // xor by itself is equivalent to xor(0-255).\n  assert_true_rule_file(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"This program cannot\\\" xor wide\\n\\\n      condition:\\n\\\n        #a == 256\\n\\\n    }\", \"tests/data/xorwide.out\");\n\n  // This DOES NOT look for the plaintext wide version by itself.\n  assert_true_rule_file(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"This program cannot\\\" xor(1-16) wide\\n\\\n      condition:\\n\\\n        #a == 16\\n\\\n    }\", \"tests/data/xorwide.out\");\n\n  // Check the location of the match to make sure we match on the correct one.\n  assert_true_rule_file(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"This program cannot\\\" xor(1) wide\\n\\\n      condition:\\n\\\n        #a == 1 and @a == 0x2f\\n\\\n    }\", \"tests/data/xorwide.out\");\n\n  assert_error(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"This program cannot\\\" xor(300)\\n\\\n      condition:\\n\\\n        $a\\n\\\n    }\", ERROR_INVALID_MODIFIER);\n\n  assert_error(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"This program cannot\\\" xor(200-10)\\n\\\n      condition:\\n\\\n        $a\\n\\\n    }\", ERROR_INVALID_MODIFIER);\n\n  assert_error(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = {00 11 22 33} xor\\n\\\n      condition:\\n\\\n        $a\\n\\\n    }\", ERROR_SYNTAX_ERROR);\n\n  assert_error(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = /foo(bar|baz)/ xor\\n\\\n      condition:\\n\\\n        $a\\n\\\n    }\", ERROR_SYNTAX_ERROR);\n\n  assert_error(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"ab\\\" xor xor\\n\\\n      condition:\\n\\\n        $a\\n\\\n    }\", ERROR_DUPLICATED_MODIFIER);\n\n  // We should have no matches here because we are not generating the wide\n  // string, just the ascii one, and the test data contains no ascii strings.\n  assert_true_rule_file(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"This program cannot\\\" xor ascii\\n\\\n      condition:\\n\\\n        #a == 0\\n\\\n    }\", \"tests/data/xorwide.out\");\n\n  // This should match 512 times because we are looking for the wide and ascii\n  // versions in plaintext and doing xor(0-255) (implicitly)\n  assert_true_rule_file(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"This program cannot\\\" xor wide ascii\\n\\\n      condition:\\n\\\n        #a == 512\\n\\\n    }\", \"tests/data/xorwideandascii.out\");\n\n  assert_true_rule_file(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"This program cannot\\\" wide ascii\\n\\\n      condition:\\n\\\n        #a == 2\\n\\\n    }\", \"tests/data/xorwideandascii.out\");\n\n  assert_error(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"ab\\\" xor nocase\\n\\\n      condition:\\n\\\n        true\\n\\\n    }\", ERROR_INVALID_MODIFIER);\n\n  assert_true_rule(\n      \"rule test { \\\n        strings:\\\n          $a = \\\"AXS\\\" private\\\n      condition:\\\n        all of them\\\n      }\",\n      \"AXS\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings:\\\n          $a = { 45 52 53 } private\\\n      condition:\\\n        all of them\\\n      }\",\n      \"ERS\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings:\\\n          $a = /AXS[0-9]{4}ERS[0-9]{4}/ private\\\n      condition:\\\n        all of them\\\n      }\",\n      \"AXS1111ERS2222\");\n\n  assert_error(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"ab\\\" base64 nocase\\n\\\n      condition:\\n\\\n        true\\n\\\n    }\", ERROR_INVALID_MODIFIER);\n\n  assert_error(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"ab\\\" base64 xor\\n\\\n      condition:\\n\\\n        true\\n\\\n    }\", ERROR_INVALID_MODIFIER);\n\n  assert_error(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"ab\\\" base64 fullword\\n\\\n      condition:\\n\\\n        true\\n\\\n    }\", ERROR_INVALID_MODIFIER);\n\n  assert_error(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"ab\\\" base64(\\\"AXS\\\")\\n\\\n      condition:\\n\\\n        true\\n\\\n    }\", ERROR_INVALID_MODIFIER);\n\n  assert_error(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"ab\\\" base64wide(\\\"ERS\\\")\\n\\\n      condition:\\n\\\n        true\\n\\\n    }\", ERROR_INVALID_MODIFIER);\n\n  // Specifying different alphabets is an error.\n  assert_error(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"ab\\\" base64 base64wide(\\\"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ,.\\\")\\n\\\n      condition:\\n\\\n        true\\n\\\n    }\", ERROR_INVALID_MODIFIER);\n\n  // Be specific about the offsets in these tests to make sure we are matching\n  // the correct strings. Also be specific about the length because we want to\n  // make sure the match is not the entire base64 string, but just the\n  // substrings which are not dependent upon leading or trailing bytes.\n  assert_true_rule_file(\n      \"rule test {\\n\\\n        strings:\\n\\\n          $a = \\\"This program cannot\\\" base64\\n\\\n        condition:\\n\\\n          #a == 6 and\\n\\\n          @a[1] == 0x53 and\\n\\\n          !a[1] == 25 and\\n\\\n          @a[2] == 0x70 and\\n\\\n          !a[2] == 25 and\\n\\\n          @a[3] == 0xa2 and\\n\\\n          !a[3] == 24 and\\n\\\n          @a[4] == 0xbd and\\n\\\n          !a[4] == 24 and\\n\\\n          @a[5] == 0xef and\\n\\\n          !a[5] == 25 and\\n\\\n          @a[6] == 0x109 and\\n\\\n          !a[6] == 25\\n\\\n      }\", \"tests/data/base64\");\n\n  // This is identical to \"base64\" alone, but test it to make sure we don't\n  // accidentally include the plaintext in the base64 search.\n  assert_true_rule_file(\n      \"rule test {\\n\\\n        strings:\\n\\\n          $a = \\\"This program cannot\\\" base64 ascii\\n\\\n        condition:\\n\\\n          #a == 6 and\\n\\\n          @a[1] == 0x53 and\\n\\\n          !a[1] == 25 and\\n\\\n          @a[2] == 0x70 and\\n\\\n          !a[2] == 25 and\\n\\\n          @a[3] == 0xa2 and\\n\\\n          !a[3] == 24 and\\n\\\n          @a[4] == 0xbd and\\n\\\n          !a[4] == 24 and\\n\\\n          @a[5] == 0xef and\\n\\\n          !a[5] == 25 and\\n\\\n          @a[6] == 0x109 and\\n\\\n          !a[6] == 25\\n\\\n      }\", \"tests/data/base64\");\n\n  // Make sure the wide modifier is applied BEFORE the base64 and we do NOT\n  // include the wide plaintext string.\n  assert_true_rule_file(\n      \"rule test {\\n\\\n        strings:\\n\\\n          $a = \\\"This program cannot\\\" base64 wide\\n\\\n        condition:\\n\\\n          #a == 6 and\\n\\\n          @a[1] == 0x1b5 and\\n\\\n          !a[1] == 50 and\\n\\\n          @a[2] == 0x1ea and\\n\\\n          !a[2] == 50 and\\n\\\n          @a[3] == 0x248 and\\n\\\n          !a[3] == 50 and\\n\\\n          @a[4] == 0x27b and\\n\\\n          !a[4] == 50 and\\n\\\n          @a[5] == 0x2db and\\n\\\n          !a[5] == 50 and\\n\\\n          @a[6] == 0x311 and\\n\\\n          !a[6] == 50\\n\\\n      }\", \"tests/data/base64\");\n\n  // Make sure that both wide and ascii are base64 encoded. We can skip the\n  // verbose length and offset checks, since the previous tests cover that.\n  assert_true_rule_file(\n      \"rule test {\\n\\\n        strings:\\n\\\n          $a = \\\"This program cannot\\\" base64 wide ascii\\n\\\n        condition:\\n\\\n          #a == 12\\n\\\n      }\", \"tests/data/base64\");\n\n  // Make sure that the two strings are generated when one ascii byte is\n  // base64 encoded. When stripped, third base64 encoded is null.\n  assert_true_rule_file(\n      \"rule test {\\n\\\n        strings:\\n\\\n          $a = \\\"a\\\" base64\\n\\\n          $b = \\\"a\\\" base64wide\\n\\\n        condition:\\n\\\n          @a[58] == 0x6ac and\\n\\\n          @a[59] == 0x6b9 and\\n\\\n          @b[15] == 0x6f7 and\\n\\\n          @b[16] == 0x711\\n\\\n      }\", \"tests/data/base64\");\n\n  // In the future, assert false if character classes are generated instead\n  // of stripping the leading and trailing characters\n  assert_true_rule_file(\n      \"rule test {\\n\\\n        strings:\\n\\\n          $a = \\\"Dhis program cannow\\\" base64\\n\\\n        condition:\\n\\\n          #a == 2 and\\n\\\n          @a[1] == 0xa2 and\\n\\\n          @a[2] == 0xbd\\n\\\n      }\", \"tests/data/base64\");\n\n  // This checks for the ascii string in base64 form then widened.\n  assert_true_rule_file(\n      \"rule test {\\n\\\n        strings:\\n\\\n          $a = \\\"This program cannot\\\" base64wide\\n\\\n        condition:\\n\\\n          #a == 3 and\\n\\\n          @a[1] == 0x379 and\\n\\\n          !a[1] == 50 and\\n\\\n          @a[2] == 0x3b6 and\\n\\\n          !a[2] == 48 and\\n\\\n          @a[3] == 0x3f1 and\\n\\\n          !a[3] == 50\\n\\\n      }\", \"tests/data/base64\");\n\n  // Logically identical to the test above but include it to make sure we don't\n  // accidentally include the plaintext in the future.\n  assert_true_rule_file(\n      \"rule test {\\n\\\n        strings:\\n\\\n          $a = \\\"This program cannot\\\" base64wide ascii\\n\\\n        condition:\\n\\\n          #a == 3 and\\n\\\n          @a[1] == 0x379 and\\n\\\n          !a[1] == 50 and\\n\\\n          @a[2] == 0x3b6 and\\n\\\n          !a[2] == 48 and\\n\\\n          @a[3] == 0x3f1 and\\n\\\n          !a[3] == 50\\n\\\n      }\", \"tests/data/base64\");\n\n  // Make sure the wide string is base64wide encoded.\n  assert_true_rule_file(\n      \"rule test {\\n\\\n        strings:\\n\\\n          $a = \\\"This program cannot\\\" base64wide wide\\n\\\n        condition:\\n\\\n          #a == 3 and\\n\\\n          @a[1] == 0x458 and\\n\\\n          !a[1] == 100 and\\n\\\n          @a[2] == 0x4c5 and\\n\\\n          !a[2] == 100 and\\n\\\n          @a[3] == 0x530 and\\n\\\n          !a[3] == 100\\n\\\n      }\", \"tests/data/base64\");\n\n  // Make sure both ascii and wide strings are base64wide encoded properly.\n  assert_true_rule_file(\n      \"rule test {\\n\\\n        strings:\\n\\\n          $a = \\\"This program cannot\\\" base64wide wide ascii\\n\\\n        condition:\\n\\\n          #a == 6 and\\n\\\n          @a[1] == 0x379 and\\n\\\n          !a[1] == 50 and\\n\\\n          @a[2] == 0x3b6 and\\n\\\n          !a[2] == 48 and\\n\\\n          @a[3] == 0x3f1 and\\n\\\n          !a[3] == 50 and\\n\\\n          @a[4] == 0x458 and\\n\\\n          !a[4] == 100 and\\n\\\n          @a[5] == 0x4c5 and\\n\\\n          !a[5] == 100 and\\n\\\n          @a[6] == 0x530 and\\n\\\n          !a[6] == 100\\n\\\n      }\", \"tests/data/base64\");\n\n  // Make sure base64 and base64wide together work.\n  assert_true_rule_file(\n      \"rule test {\\n\\\n        strings:\\n\\\n          $a = \\\"This program cannot\\\" base64 base64wide\\n\\\n        condition:\\n\\\n          #a == 9 and\\n\\\n          @a[1] == 0x53 and\\n\\\n          !a[1] == 25 and\\n\\\n          @a[2] == 0x70 and\\n\\\n          !a[2] == 25 and\\n\\\n          @a[3] == 0xa2 and\\n\\\n          !a[3] == 24 and\\n\\\n          @a[4] == 0xbd and\\n\\\n          !a[4] == 24 and\\n\\\n          @a[5] == 0xef and\\n\\\n          !a[5] == 25 and\\n\\\n          @a[6] == 0x109 and\\n\\\n          !a[6] == 25 and\\n\\\n          @a[7] == 0x379 and\\n\\\n          !a[7] == 50 and\\n\\\n          @a[8] == 0x3b6 and\\n\\\n          !a[8] == 48 and\\n\\\n          @a[9] == 0x3f1 and\\n\\\n          !a[9] == 50\\n\\\n      }\", \"tests/data/base64\");\n\n  // Identical to the test above but useful to make sure we don't accidentally\n  // include the ascii plaintext in the future.\n  assert_true_rule_file(\n      \"rule test {\\n\\\n        strings:\\n\\\n          $a = \\\"This program cannot\\\" base64 base64wide ascii\\n\\\n        condition:\\n\\\n          #a == 9\\n\\\n      }\", \"tests/data/base64\");\n\n  // Making sure we don't accidentally include the wide plaintext in the future.\n  assert_true_rule_file(\n      \"rule test {\\n\\\n        strings:\\n\\\n          $a = \\\"This program cannot\\\" base64 base64wide wide\\n\\\n        condition:\\n\\\n          #a == 9\\n\\\n      }\", \"tests/data/base64\");\n\n  assert_true_rule_file(\n      \"rule test {\\n\\\n        strings:\\n\\\n          $a = \\\"This program cannot\\\" base64(\\\"!@#$\\%^&*(){}[].,|ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstu\\\")\\n\\\n        condition:\\n\\\n          #a == 3 and\\n\\\n          @a[1] == 0x619 and\\n\\\n          !a[1] == 25 and\\n\\\n          @a[2] == 0x638 and\\n\\\n          !a[2] == 24 and\\n\\\n          @a[3] == 0x656 and\\n\\\n          !a[3] == 25\\n\\\n      }\", \"tests/data/base64\");\n}",
        "begin_line": 395,
        "end_line": 983,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_syntax#354",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_syntax()",
        "snippet": "static void test_syntax()\n{\n  assert_error(\n      \"rule test { strings: $a = \\\"a\\\" $a = \\\"a\\\" condition: all of them }\",\n      ERROR_DUPLICATED_STRING_IDENTIFIER);\n\n  assert_error(\n      \"rule test { strings: $a = /a.c/ xor condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(\n      \"rule test { strings: $a = /abc/ xor condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(\n      \"rule test { strings: $a = {01 02 ?? 03 04} xor condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(\n      \"rule test { strings: $a = {01 02 0? 03 04} xor condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(\n      \"rule test { strings: $a = {01 02 03 04} xor condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  // Test case for issue #1295\n  assert_error(\n      \"rule test rule test\",\n      ERROR_DUPLICATED_IDENTIFIER);\n}",
        "begin_line": 354,
        "end_line": 384,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_tags#2577",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_tags()",
        "snippet": "void test_tags()\n{\n  assert_true_rule(\n      \"rule test : tag1 { condition: true}\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test : tag1 tag2 { condition: true}\",\n      NULL);\n\n  assert_error(\n      \"rule test : tag1 tag1 { condition: true}\",\n      ERROR_DUPLICATED_TAG_IDENTIFIER);\n}",
        "begin_line": 2577,
        "end_line": 2590,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_time_module#2472",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_time_module()",
        "snippet": "static void test_time_module()\n{\n    assert_true_rule(\n        \"import \\\"time\\\" \\\n        rule test { condition: time.now() > 0 }\",\n        NULL);\n}",
        "begin_line": 2472,
        "end_line": 2478,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_wildcard_strings#986",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_wildcard_strings()",
        "snippet": "static void test_wildcard_strings()\n{\n  assert_true_rule_blob(\n      \"rule test {\\n\\\n         strings:\\n\\\n             $s1 = \\\"abc\\\"\\n\\\n             $s2 = \\\"xyz\\\"\\n\\\n         condition:\\n\\\n             for all of ($*) : ($)\\n\\\n      }\",\n      \"---- abc ---- A\\x00\"\"B\\x00\"\"C\\x00 ---- xyz\");\n}",
        "begin_line": 986,
        "end_line": 997,
        "is_bug": false
    },
    {
        "name": "tests.test-stack.defects4cpp_test_index#4",
        "src_path": "tests/test-stack.c",
        "class_name": "tests.test-stack",
        "signature": "tests.test-stack.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-stack.main#37",
        "src_path": "tests/test-stack.c",
        "class_name": "tests.test-stack",
        "signature": "tests.test-stack.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  YR_STACK* stack;\n\n  int item;\n\n  yr_initialize();\n  yr_stack_create(1, sizeof(item),  &stack);\n\n  int index = defects4cpp_test_index();\n  switch (index) {\n    case 263:\n  item = 1;\n\n  if (yr_stack_push(stack, &item) != ERROR_SUCCESS)\n    exit(EXIT_FAILURE);\n\n  item = 2;\n\n  if (yr_stack_push(stack, &item) != ERROR_SUCCESS)\n    exit(EXIT_FAILURE);\n\n  item = 3;\n\n  if (yr_stack_push(stack, &item) != ERROR_SUCCESS)\n    exit(EXIT_FAILURE);\n\n  item = 4;\n\n  if (yr_stack_push(stack, &item) != ERROR_SUCCESS)\n    exit(EXIT_FAILURE);\n\n  if (!yr_stack_pop(stack, &item) || item != 4)\n    exit(EXIT_FAILURE);\n\n  if (!yr_stack_pop(stack, &item) || item != 3)\n    exit(EXIT_FAILURE);\n\n  if (!yr_stack_pop(stack, &item) || item != 2)\n    exit(EXIT_FAILURE);\n\n  if (!yr_stack_pop(stack, &item) || item != 1)\n    exit(EXIT_FAILURE);\n\n  if (yr_stack_pop(stack, &item) || item != 1)\n    exit(EXIT_FAILURE);\n\n        break;\n  }\n  yr_stack_destroy(stack);\n  yr_finalize();\n  return 0;\n}",
        "begin_line": 37,
        "end_line": 89,
        "is_bug": false
    },
    {
        "name": "tests.test-version.main#33",
        "src_path": "tests/test-version.c",
        "class_name": "tests.test-version",
        "signature": "tests.test-version.main (int argc, char **argv)",
        "snippet": "int main (int argc, char **argv)\n{\n  // make sure that versions defined in configure.ac and in\n  // libyara/include/yara/libyara.h are in sync.\n\n  return strcmp(PACKAGE_VERSION, YR_VERSION);\n}",
        "begin_line": 33,
        "end_line": 39,
        "is_bug": false
    },
    {
        "name": "tests.util._assert_atoms#345",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util._assert_atoms(     RE_AST* re_ast, int expected_atom_count, atom* expected_atoms)",
        "snippet": "int _assert_atoms(\n    RE_AST* re_ast,\n    int expected_atom_count,\n    atom* expected_atoms)\n{\n  YR_ATOMS_CONFIG c;\n  YR_ATOM_LIST_ITEM* atoms;\n  YR_ATOM_LIST_ITEM* atom;\n  YR_ATOM_LIST_ITEM* next_atom;\n\n  int min_atom_quality;\n  int exit_code;\n  YR_MODIFIER modifier;\n  modifier.flags = 0;\n\n  c.get_atom_quality = yr_atoms_heuristic_quality;\n\n  yr_atoms_extract_from_re(&c, re_ast, modifier, &atoms, &min_atom_quality);\n\n  atom = atoms;\n\n  exit_code = EXIT_SUCCESS;\n  while (atom != NULL)\n  {\n    if (expected_atom_count == 0)\n    {\n      exit_code = EXIT_FAILURE;\n      break;\n    }\n\n    if (atom->atom.length != expected_atoms->length ||\n       memcmp(atom->atom.bytes, expected_atoms->data, atom->atom.length) != 0)\n    {\n      exit_code = EXIT_FAILURE;\n      break;\n    }\n\n    expected_atoms++;\n    expected_atom_count--;\n    atom = atom->next;\n  }\n\n  atom = atoms;\n  while (atom != NULL)\n  {\n    next_atom = atom->next;\n    yr_free(atom);\n    atom = next_atom;\n  }\n\n  return exit_code;\n}",
        "begin_line": 345,
        "end_line": 396,
        "is_bug": false
    },
    {
        "name": "tests.util._compiler_callback#102",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util._compiler_callback(     int error_level, const char* file_name, int line_number, const YR_RULE* rule, const char* message, void* user_data)",
        "snippet": "static void _compiler_callback(\n    int error_level,\n    const char* file_name,\n    int line_number,\n    const YR_RULE* rule,\n    const char* message,\n    void* user_data)\n{\n  if (error_level == YARA_ERROR_LEVEL_WARNING)\n    (*((int*) user_data))++;\n\n  snprintf(\n      compile_error,\n      sizeof(compile_error),\n      \"line %d: %s\",\n      line_number,\n      message);\n}",
        "begin_line": 102,
        "end_line": 119,
        "is_bug": false
    },
    {
        "name": "tests.util._scan_callback#162",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util._scan_callback(     YR_SCAN_CONTEXT* context, int message, void* message_data, void* user_data)",
        "snippet": "static int _scan_callback(\n    YR_SCAN_CONTEXT* context,\n    int message,\n    void* message_data,\n    void* user_data)\n{\n  SCAN_CALLBACK_CTX* ctx =  (SCAN_CALLBACK_CTX*) user_data;\n  YR_MODULE_IMPORT* mi;\n\n  switch (message)\n  {\n  case CALLBACK_MSG_RULE_MATCHING:\n    ctx->matches++;\n    break;\n  case CALLBACK_MSG_IMPORT_MODULE:\n    mi = (YR_MODULE_IMPORT*) message_data;\n    mi->module_data = ctx->module_data;\n    mi->module_data_size = ctx->module_data_size;\n    break;\n  }\n\n  return CALLBACK_CONTINUE;\n}",
        "begin_line": 162,
        "end_line": 184,
        "is_bug": false
    },
    {
        "name": "tests.util.assert_hex_atoms#420",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util.assert_hex_atoms(     char* hex, int expected_atom_count, atom* expected_atoms)",
        "snippet": "void assert_hex_atoms(\n    char* hex,\n    int expected_atom_count,\n    atom* expected_atoms)\n{\n  RE_AST* re_ast;\n  RE_ERROR re_error;\n\n  int exit_code;\n\n  yr_re_parse_hex(hex, &re_ast, &re_error);\n  exit_code = _assert_atoms(re_ast, expected_atom_count, expected_atoms);\n\n  if (re_ast != NULL)\n    yr_re_ast_destroy(re_ast);\n\n  if (exit_code != EXIT_SUCCESS)\n    exit(exit_code);\n}",
        "begin_line": 420,
        "end_line": 438,
        "is_bug": false
    },
    {
        "name": "tests.util.assert_re_atoms#399",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util.assert_re_atoms(     char* re, int expected_atom_count, atom* expected_atoms)",
        "snippet": "void assert_re_atoms(\n    char* re,\n    int expected_atom_count,\n    atom* expected_atoms)\n{\n  RE_AST* re_ast;\n  RE_ERROR re_error;\n\n  int exit_code;\n\n  yr_re_parse(re, &re_ast, &re_error);\n  exit_code = _assert_atoms(re_ast, expected_atom_count, expected_atoms);\n\n  if (re_ast != NULL)\n    yr_re_ast_destroy(re_ast);\n\n  if (exit_code != EXIT_SUCCESS)\n    exit(exit_code);\n}",
        "begin_line": 399,
        "end_line": 417,
        "is_bug": false
    },
    {
        "name": "tests.util.capture_matches#249",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util.capture_matches(     YR_SCAN_CONTEXT* context, int message, void* message_data, void* user_data)",
        "snippet": "static int capture_matches(\n    YR_SCAN_CONTEXT* context,\n    int message,\n    void* message_data,\n    void* user_data)\n{\n  if (message == CALLBACK_MSG_RULE_MATCHING)\n  {\n    find_string_t* f = (find_string_t*) user_data;\n\n    YR_RULE* rule = (YR_RULE*) message_data;\n    YR_STRING* string;\n\n    yr_rule_strings_foreach(rule, string)\n    {\n      YR_MATCH* match;\n\n      yr_string_matches_foreach(context, string, match)\n      {\n        if (strlen(f->expected) == match->data_length &&\n            strncmp(f->expected, (char*)(match->data), match->data_length) == 0)\n        {\n          f->found++;\n        }\n      }\n    }\n  }\n\n  return CALLBACK_CONTINUE;\n}",
        "begin_line": 249,
        "end_line": 278,
        "is_bug": false
    },
    {
        "name": "tests.util.capture_string#281",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util.capture_string(     char* rule, char* string, char* expected_string)",
        "snippet": "int capture_string(\n    char* rule,\n    char* string,\n    char* expected_string)\n{\n  YR_RULES* rules;\n\n  if (compile_rule(rule, &rules) != ERROR_SUCCESS)\n  {\n    fprintf(stderr, \"failed to compile rule << %s >>: %s\\n\", rule, compile_error);\n    exit(EXIT_FAILURE);\n  }\n\n  find_string_t f;\n\n  f.found = 0;\n  f.expected = expected_string;\n\n  if (yr_rules_scan_mem(rules, (uint8_t*)string, strlen(string), 0,\n                        capture_matches, &f, 0) != ERROR_SUCCESS)\n  {\n    fprintf(stderr, \"yr_rules_scan_mem: error\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_rules_destroy(rules);\n\n  return f.found;\n}",
        "begin_line": 281,
        "end_line": 309,
        "is_bug": false
    },
    {
        "name": "tests.util.compile_rule#122",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util.compile_rule(     char* string, YR_RULES** rules)",
        "snippet": "int compile_rule(\n    char* string,\n    YR_RULES** rules)\n{\n  YR_COMPILER* compiler = NULL;\n  int result = ERROR_SUCCESS;\n\n  compile_error[0] = '\\0';\n  warnings = 0;\n\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    goto _exit;\n  }\n\n  yr_compiler_set_callback(compiler, _compiler_callback, &warnings);\n\n  if (yr_compiler_add_string(compiler, string, NULL) != 0)\n  {\n    result = compiler->last_error;\n    goto _exit;\n  }\n\n  result = yr_compiler_get_rules(compiler, rules);\n\n_exit:\n  yr_compiler_destroy(compiler);\n  return result;\n}",
        "begin_line": 122,
        "end_line": 151,
        "is_bug": false
    },
    {
        "name": "tests.util.count#55",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util.count(     YR_SCAN_CONTEXT* context, int message, void* message_data, void* user_data)",
        "snippet": "int count(\n    YR_SCAN_CONTEXT* context,\n    int message,\n    void* message_data,\n    void* user_data)\n{\n  switch (message)\n  {\n    case CALLBACK_MSG_RULE_MATCHING:\n      (*(struct COUNTERS*) user_data).rules_matching++;\n      break;\n\n    case CALLBACK_MSG_RULE_NOT_MATCHING:\n      (*(struct COUNTERS*) user_data).rules_not_matching++;\n\n  }\n  return CALLBACK_CONTINUE;\n}",
        "begin_line": 55,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "tests.util.count_non_matches#75",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util.count_non_matches(     YR_SCAN_CONTEXT* context, int message, void* message_data, void* user_data)",
        "snippet": "int count_non_matches(\n    YR_SCAN_CONTEXT* context,\n    int message,\n    void* message_data,\n    void* user_data)\n{\n  if (message == CALLBACK_MSG_RULE_NOT_MATCHING)\n  {\n    (*(int*) user_data)++;\n  }\n\n  return CALLBACK_CONTINUE;\n}",
        "begin_line": 75,
        "end_line": 87,
        "is_bug": false
    },
    {
        "name": "tests.util.do_nothing#92",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util.do_nothing(     YR_SCAN_CONTEXT* context, int message, void* message_data, void* user_data)",
        "snippet": "int do_nothing(\n    YR_SCAN_CONTEXT* context,\n    int message,\n    void* message_data,\n    void* user_data)\n{\n  return CALLBACK_CONTINUE;\n}",
        "begin_line": 92,
        "end_line": 99,
        "is_bug": false
    },
    {
        "name": "tests.util.matches_blob#187",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util.matches_blob(     char* rule, uint8_t* blob, size_t blob_size, uint8_t* module_data, size_t module_data_size)",
        "snippet": "int matches_blob(\n    char* rule,\n    uint8_t* blob,\n    size_t blob_size,\n    uint8_t* module_data,\n    size_t module_data_size)\n{\n  YR_RULES* rules;\n\n  if (blob == NULL)\n  {\n    blob = (uint8_t*) \"dummy\";\n    blob_size = 5;\n  }\n\n  if (compile_rule(rule, &rules) != ERROR_SUCCESS)\n  {\n    fprintf(stderr, \"failed to compile rule << %s >>: %s\\n\", rule, compile_error);\n    exit(EXIT_FAILURE);\n  }\n\n  SCAN_CALLBACK_CTX ctx = {\n    .matches = 0,\n    .module_data = module_data,\n    .module_data_size = module_data_size,\n  };\n\n  int scan_result = yr_rules_scan_mem(\n      rules, blob, blob_size, SCAN_FLAGS_NO_TRYCATCH, _scan_callback, &ctx, 0);\n\n  if (scan_result != ERROR_SUCCESS)\n  {\n    fprintf(stderr, \"yr_rules_scan_mem: error: %d\\n\", scan_result);\n    exit(EXIT_FAILURE);\n  }\n\n  yr_rules_destroy(rules);\n\n  return ctx.matches;\n}",
        "begin_line": 187,
        "end_line": 226,
        "is_bug": false
    },
    {
        "name": "tests.util.matches_string#229",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util.matches_string(     char* rule, char* string)",
        "snippet": "int matches_string(\n    char* rule,\n    char* string)\n{\n  size_t len = 0;\n\n  if (string != NULL)\n    len = strlen(string);\n\n  return matches_blob(rule, (uint8_t*) string, len, NULL, 0);\n}",
        "begin_line": 229,
        "end_line": 239,
        "is_bug": false
    },
    {
        "name": "tests.util.read_file#312",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util.read_file(     char* filename, char** buf)",
        "snippet": "int read_file(\n    char* filename,\n    char** buf)\n{\n  int fd;\n\n  if ((fd = open(filename, O_RDONLY)) < 0)\n    return -1;\n\n  size_t sz = lseek(fd, 0, SEEK_END);\n  int rc = -1;\n\n  if (sz == -1)\n    goto _exit;\n\n  if (lseek(fd, 0, SEEK_SET) != 0)\n    goto _exit;\n\n  if ((*buf = malloc(sz)) == NULL)\n    goto _exit;\n\n  if ((rc = read(fd, *buf, sz)) != sz)\n  {\n    rc = -1;\n    free(*buf);\n  }\n\n_exit:\n  close(fd);\n  return rc;\n}",
        "begin_line": 312,
        "end_line": 342,
        "is_bug": false
    }
]