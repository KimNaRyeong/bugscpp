[
    {
        "name": "libtiff.tif_aux._TIFFCheckMalloc#85",
        "src_path": "libtiff/tif_aux.c",
        "class_name": "libtiff.tif_aux",
        "signature": "libtiff.tif_aux._TIFFCheckMalloc(TIFF* tif, tmsize_t nmemb, tmsize_t elem_size, const char* what)",
        "snippet": "void*\n_TIFFCheckMalloc(TIFF* tif, tmsize_t nmemb, tmsize_t elem_size, const char* what)\n{\n\treturn _TIFFCheckRealloc(tif, NULL, nmemb, elem_size, what);  \n}",
        "begin_line": 85,
        "end_line": 89,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_aux._TIFFCheckRealloc#62",
        "src_path": "libtiff/tif_aux.c",
        "class_name": "libtiff.tif_aux",
        "signature": "libtiff.tif_aux._TIFFCheckRealloc(TIFF* tif, void* buffer, tmsize_t nmemb, tmsize_t elem_size, const char* what)",
        "snippet": "void*\n_TIFFCheckRealloc(TIFF* tif, void* buffer,\n\t\t  tmsize_t nmemb, tmsize_t elem_size, const char* what)\n{\n\tvoid* cp = NULL;\n\ttmsize_t bytes = nmemb * elem_size;\n\n\t/*\n\t * XXX: Check for integer overflow.\n\t */\n\tif (nmemb && elem_size && bytes / elem_size == nmemb)\n\t\tcp = _TIFFrealloc(buffer, bytes);\n\n\tif (cp == NULL) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t     \"Failed to allocate memory for %s \"\n\t\t\t     \"(%ld elements of %ld bytes each)\",\n\t\t\t     what,(long) nmemb, (long) elem_size);\n\t}\n\n\treturn cp;\n}",
        "begin_line": 62,
        "end_line": 83,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_aux._TIFFMultiply64#49",
        "src_path": "libtiff/tif_aux.c",
        "class_name": "libtiff.tif_aux",
        "signature": "libtiff.tif_aux._TIFFMultiply64(TIFF* tif, uint64 first, uint64 second, const char* where)",
        "snippet": "uint64\n_TIFFMultiply64(TIFF* tif, uint64 first, uint64 second, const char* where)\n{\n\tuint64 bytes = first * second;\n\n\tif (second && bytes / second != first) {\n\t\tTIFFErrorExt(tif->tif_clientdata, where, \"Integer overflow in %s\", where);\n\t\tbytes = 0;\n\t}\n\n\treturn bytes;\n}",
        "begin_line": 49,
        "end_line": 60,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_compress.TIFFFindCODEC#186",
        "src_path": "libtiff/tif_compress.c",
        "class_name": "libtiff.tif_compress",
        "signature": "libtiff.tif_compress.TIFFFindCODEC(uint16 scheme)",
        "snippet": "const TIFFCodec*\nTIFFFindCODEC(uint16 scheme)\n{\n\tconst TIFFCodec* c;\n\tcodec_t* cd;\n\n\tfor (cd = registeredCODECS; cd; cd = cd->next)\n\t\tif (cd->info->scheme == scheme)\n\t\t\treturn ((const TIFFCodec*) cd->info);\n\tfor (c = _TIFFBuiltinCODECS; c->name; c++)\n\t\tif (c->scheme == scheme)\n\t\t\treturn (c);\n\treturn ((const TIFFCodec*) 0);\n}",
        "begin_line": 186,
        "end_line": 199,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_compress.TIFFSetCompressionScheme#160",
        "src_path": "libtiff/tif_compress.c",
        "class_name": "libtiff.tif_compress",
        "signature": "libtiff.tif_compress.TIFFSetCompressionScheme(TIFF* tif, int scheme)",
        "snippet": "int\nTIFFSetCompressionScheme(TIFF* tif, int scheme)\n{\n\tconst TIFFCodec *c = TIFFFindCODEC((uint16) scheme);\n\n\t_TIFFSetDefaultCompressionState(tif);\n\t/*\n\t * Don't treat an unknown compression scheme as an error.\n\t * This permits applications to open files with data that\n\t * the library does not have builtin support for, but which\n\t * may still be meaningful.\n\t */\n\treturn (c ? (*c->init)(tif, scheme) : 1);\n}",
        "begin_line": 160,
        "end_line": 173,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_compress._TIFFSetDefaultCompressionState#135",
        "src_path": "libtiff/tif_compress.c",
        "class_name": "libtiff.tif_compress",
        "signature": "libtiff.tif_compress._TIFFSetDefaultCompressionState(TIFF* tif)",
        "snippet": "void\n_TIFFSetDefaultCompressionState(TIFF* tif)\n{\n\ttif->tif_fixuptags = _TIFFNoFixupTags; \n\ttif->tif_decodestatus = TRUE;\n\ttif->tif_setupdecode = _TIFFtrue;\n\ttif->tif_predecode = _TIFFNoPreCode;\n\ttif->tif_decoderow = _TIFFNoRowDecode;  \n\ttif->tif_decodestrip = _TIFFNoStripDecode;\n\ttif->tif_decodetile = _TIFFNoTileDecode;  \n\ttif->tif_encodestatus = TRUE;\n\ttif->tif_setupencode = _TIFFtrue;\n\ttif->tif_preencode = _TIFFNoPreCode;\n\ttif->tif_postencode = _TIFFtrue;\n\ttif->tif_encoderow = _TIFFNoRowEncode;\n\ttif->tif_encodestrip = _TIFFNoStripEncode;  \n\ttif->tif_encodetile = _TIFFNoTileEncode;  \n\ttif->tif_close = _TIFFvoid;\n\ttif->tif_seek = _TIFFNoSeek;\n\ttif->tif_cleanup = _TIFFvoid;\n\ttif->tif_defstripsize = _TIFFDefaultStripSize;\n\ttif->tif_deftilesize = _TIFFDefaultTileSize;\n\ttif->tif_flags &= ~(TIFF_NOBITREV|TIFF_NOREADRAW);\n}",
        "begin_line": 135,
        "end_line": 158,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_compress._TIFFvoid#133",
        "src_path": "libtiff/tif_compress.c",
        "class_name": "libtiff.tif_compress",
        "signature": "libtiff.tif_compress._TIFFvoid(TIFF* tif)",
        "snippet": "static void _TIFFvoid(TIFF* tif) { (void) tif; }",
        "begin_line": 133,
        "end_line": 133,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.OkToChangeTag#749",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.OkToChangeTag(TIFF* tif, uint32 tag)",
        "snippet": "static int\nOkToChangeTag(TIFF* tif, uint32 tag)\n{\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\tif (!fip) {\t\t\t/* unknown tag */\n\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFSetField\", \"%s: Unknown %stag %u\",\n\t\t    tif->tif_name, isPseudoTag(tag) ? \"pseudo-\" : \"\", tag);\n\t\treturn (0);\n\t}\n\tif (tag != TIFFTAG_IMAGELENGTH && (tif->tif_flags & TIFF_BEENWRITING) &&\n\t    !fip->field_oktochange) {\n\t\t/*\n\t\t * Consult info table to see if tag can be changed\n\t\t * after we've started writing.  We only allow changes\n\t\t * to those tags that don't/shouldn't affect the\n\t\t * compression and/or format of the data.\n\t\t */\n\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFSetField\",\n\t\t    \"%s: Cannot modify tag \\\"%s\\\" while writing\",\n\t\t    tif->tif_name, fip->field_name);\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
        "begin_line": 749,
        "end_line": 772,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFDefaultDirectory#1316",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFDefaultDirectory(TIFF* tif)",
        "snippet": "int\nTIFFDefaultDirectory(TIFF* tif)\n{\n\tregister TIFFDirectory* td = &tif->tif_dir;\n\tconst TIFFFieldArray* tiffFieldArray;\n\n\ttiffFieldArray = _TIFFGetFields();\n\t_TIFFSetupFields(tif, tiffFieldArray);   \n\n\t_TIFFmemset(td, 0, sizeof (*td));\n\ttd->td_fillorder = FILLORDER_MSB2LSB;\n\ttd->td_bitspersample = 1;\n\ttd->td_threshholding = THRESHHOLD_BILEVEL;\n\ttd->td_orientation = ORIENTATION_TOPLEFT;\n\ttd->td_samplesperpixel = 1;\n\ttd->td_rowsperstrip = (uint32) -1;\n\ttd->td_tilewidth = 0;\n\ttd->td_tilelength = 0;\n\ttd->td_tiledepth = 1;\n\ttd->td_stripbytecountsorted = 1; /* Our own arrays always sorted. */  \n\ttd->td_resolutionunit = RESUNIT_INCH;\n\ttd->td_sampleformat = SAMPLEFORMAT_UINT;\n\ttd->td_imagedepth = 1;\n\ttd->td_ycbcrsubsampling[0] = 2;\n\ttd->td_ycbcrsubsampling[1] = 2;\n\ttd->td_ycbcrpositioning = YCBCRPOSITION_CENTERED;\n\ttif->tif_postdecode = _TIFFNoPostDecode;  \n\ttif->tif_foundfield = NULL;\n\ttif->tif_tagmethods.vsetfield = _TIFFVSetField;  \n\ttif->tif_tagmethods.vgetfield = _TIFFVGetField;\n\ttif->tif_tagmethods.printdir = NULL;\n\t/*\n\t *  Give client code a chance to install their own\n\t *  tag extensions & methods, prior to compression overloads,\n\t *  but do some prior cleanup first. (http://trac.osgeo.org/gdal/ticket/5054)\n\t */\n\tif (tif->tif_nfieldscompat > 0) {\n\t\tuint32 i;\n\n\t\tfor (i = 0; i < tif->tif_nfieldscompat; i++) {\n\t\t\t\tif (tif->tif_fieldscompat[i].allocated_size)\n\t\t\t\t\t\t_TIFFfree(tif->tif_fieldscompat[i].fields);\n\t\t}\n\t\t_TIFFfree(tif->tif_fieldscompat);\n\t\ttif->tif_nfieldscompat = 0;\n\t\ttif->tif_fieldscompat = NULL;\n\t}\n\tif (_TIFFextender)\n\t\t(*_TIFFextender)(tif);\n\t(void) TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t/*\n\t * NB: The directory is marked dirty as a result of setting\n\t * up the default compression scheme.  However, this really\n\t * isn't correct -- we want TIFF_DIRTYDIRECT to be set only\n\t * if the user does something.  We could just do the setup\n\t * by hand, but it seems better to use the normal mechanism\n\t * (i.e. TIFFSetField).\n\t */\n\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\n\n\t/*\n\t * As per http://bugzilla.remotesensing.org/show_bug.cgi?id=19\n\t * we clear the ISTILED flag when setting up a new directory.\n\t * Should we also be clearing stuff like INSUBIFD?\n\t */\n\ttif->tif_flags &= ~TIFF_ISTILED;\n\n\treturn (1);\n}",
        "begin_line": 1316,
        "end_line": 1384,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFFreeDirectory#1211",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFFreeDirectory(TIFF* tif)",
        "snippet": "void\nTIFFFreeDirectory(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tint            i;\n\n\t_TIFFmemset(td->td_fieldsset, 0, FIELD_SETLONGS);\n\tCleanupField(td_sminsamplevalue);\n\tCleanupField(td_smaxsamplevalue);\n\tCleanupField(td_colormap[0]);\n\tCleanupField(td_colormap[1]);\n\tCleanupField(td_colormap[2]);\n\tCleanupField(td_sampleinfo);\n\tCleanupField(td_subifd);\n\tCleanupField(td_inknames);\n\tCleanupField(td_refblackwhite);\n\tCleanupField(td_transferfunction[0]);\n\tCleanupField(td_transferfunction[1]);\n\tCleanupField(td_transferfunction[2]);\n\tCleanupField(td_stripoffset);\n\tCleanupField(td_stripbytecount);\n\tTIFFClrFieldBit(tif, FIELD_YCBCRSUBSAMPLING);\n\tTIFFClrFieldBit(tif, FIELD_YCBCRPOSITIONING);\n\n\t/* Cleanup custom tag values */\n\tfor( i = 0; i < td->td_customValueCount; i++ ) {\n\t\tif (td->td_customValues[i].value)\n\t\t\t_TIFFfree(td->td_customValues[i].value);\n\t}\n\n\ttd->td_customValueCount = 0;\n\tCleanupField(td_customValues);\n\n#if defined(DEFER_STRILE_LOAD)\n        _TIFFmemset( &(td->td_stripoffset_entry), 0, sizeof(TIFFDirEntry));\n        _TIFFmemset( &(td->td_stripbytecount_entry), 0, sizeof(TIFFDirEntry));\n#endif        \n}",
        "begin_line": 1211,
        "end_line": 1248,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFGetField#1175",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFGetField(TIFF* tif, uint32 tag, ...)",
        "snippet": "int\nTIFFGetField(TIFF* tif, uint32 tag, ...)\n{\n\tint status;\n\tva_list ap;\n\n\tva_start(ap, tag);\n\tstatus = TIFFVGetField(tif, tag, ap);\n\tva_end(ap);\n\treturn (status);\n}",
        "begin_line": 1175,
        "end_line": 1185,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFSetField#781",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFSetField(TIFF* tif, uint32 tag, ...)",
        "snippet": "int\nTIFFSetField(TIFF* tif, uint32 tag, ...)\n{\n\tva_list ap;\n\tint status;\n\n\tva_start(ap, tag);\n\tstatus = TIFFVSetField(tif, tag, ap);\n\tva_end(ap);\n\treturn (status);\n}",
        "begin_line": 781,
        "end_line": 791,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFVGetField#1193",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "int\nTIFFVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\treturn (fip && (isPseudoTag(tag) || TIFFFieldSet(tif, fip->field_bit)) ?\n\t    (*tif->tif_tagmethods.vgetfield)(tif, tag, ap) : 0);\n}",
        "begin_line": 1193,
        "end_line": 1199,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFVSetField#840",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "int\nTIFFVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\treturn OkToChangeTag(tif, tag) ?\n\t    (*tif->tif_tagmethods.vsetfield)(tif, tag, ap) : 0;\n}",
        "begin_line": 840,
        "end_line": 845,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir._TIFFVGetField#847",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir._TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "static int\n_TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tTIFFDirectory* td = &tif->tif_dir;\n\tint ret_val = 1;\n\tuint32 standard_tag = tag;\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\tif( fip == NULL ) /* cannot happen since TIFFGetField() already checks it */\n\t    return 0;\n\t\n\t/*\n\t * We want to force the custom code to be used for custom\n\t * fields even if the tag happens to match a well known \n\t * one - important for reinterpreted handling of standard\n\t * tag values in custom directories (i.e. EXIF) \n\t */\n\tif (fip->field_bit == FIELD_CUSTOM) {\n\t\tstandard_tag = 0;\n\t}\n\n\tswitch (standard_tag) {\n\t\tcase TIFFTAG_SUBFILETYPE:\n\t\t\t*va_arg(ap, uint32*) = td->td_subfiletype;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGEWIDTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagewidth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGELENGTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagelength;\n\t\t\tbreak;\n\t\tcase TIFFTAG_BITSPERSAMPLE:\n\t\t\t*va_arg(ap, uint16*) = td->td_bitspersample;\n\t\t\tbreak;\n\t\tcase TIFFTAG_COMPRESSION:\n\t\t\t*va_arg(ap, uint16*) = td->td_compression;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PHOTOMETRIC:\n\t\t\t*va_arg(ap, uint16*) = td->td_photometric;\n\t\t\tbreak;\n\t\tcase TIFFTAG_THRESHHOLDING:\n\t\t\t*va_arg(ap, uint16*) = td->td_threshholding;\n\t\t\tbreak;\n\t\tcase TIFFTAG_FILLORDER:\n\t\t\t*va_arg(ap, uint16*) = td->td_fillorder;\n\t\t\tbreak;\n\t\tcase TIFFTAG_ORIENTATION:\n\t\t\t*va_arg(ap, uint16*) = td->td_orientation;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SAMPLESPERPIXEL:\n\t\t\t*va_arg(ap, uint16*) = td->td_samplesperpixel;\n\t\t\tbreak;\n\t\tcase TIFFTAG_ROWSPERSTRIP:\n\t\t\t*va_arg(ap, uint32*) = td->td_rowsperstrip;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\t\t*va_arg(ap, uint16*) = td->td_minsamplevalue;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\t\t*va_arg(ap, uint16*) = td->td_maxsamplevalue;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t\t*va_arg(ap, double**) = td->td_sminsamplevalue;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* libtiff historically treats this as a single value. */\n\t\t\t\tuint16 i;\n\t\t\t\tdouble v = td->td_sminsamplevalue[0];\n\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\n\t\t\t\t\tif( td->td_sminsamplevalue[i] < v )\n\t\t\t\t\t\tv = td->td_sminsamplevalue[i];\n\t\t\t\t*va_arg(ap, double*) = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t\t*va_arg(ap, double**) = td->td_smaxsamplevalue;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* libtiff historically treats this as a single value. */\n\t\t\t\tuint16 i;\n\t\t\t\tdouble v = td->td_smaxsamplevalue[0];\n\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\n\t\t\t\t\tif( td->td_smaxsamplevalue[i] > v )\n\t\t\t\t\t\tv = td->td_smaxsamplevalue[i];\n\t\t\t\t*va_arg(ap, double*) = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_XRESOLUTION:\n\t\t\t*va_arg(ap, float*) = td->td_xresolution;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YRESOLUTION:\n\t\t\t*va_arg(ap, float*) = td->td_yresolution;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PLANARCONFIG:\n\t\t\t*va_arg(ap, uint16*) = td->td_planarconfig;\n\t\t\tbreak;\n\t\tcase TIFFTAG_XPOSITION:\n\t\t\t*va_arg(ap, float*) = td->td_xposition;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YPOSITION:\n\t\t\t*va_arg(ap, float*) = td->td_yposition;\n\t\t\tbreak;\n\t\tcase TIFFTAG_RESOLUTIONUNIT:\n\t\t\t*va_arg(ap, uint16*) = td->td_resolutionunit;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PAGENUMBER:\n\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_HALFTONEHINTS:\n\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_COLORMAP:\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[0];\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[1];\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[2];\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\tcase TIFFTAG_TILEOFFSETS:\n\t\t\t_TIFFFillStriles( tif );\n\t\t\t*va_arg(ap, uint64**) = td->td_stripoffset;\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\t\t_TIFFFillStriles( tif );\n\t\t\t*va_arg(ap, uint64**) = td->td_stripbytecount;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MATTEING:\n\t\t\t*va_arg(ap, uint16*) =\n\t\t\t    (td->td_extrasamples == 1 &&\n\t\t\t    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);\n\t\t\tbreak;\n\t\tcase TIFFTAG_EXTRASAMPLES:\n\t\t\t*va_arg(ap, uint16*) = td->td_extrasamples;\n\t\t\t*va_arg(ap, uint16**) = td->td_sampleinfo;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILEWIDTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tilewidth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILELENGTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tilelength;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILEDEPTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tiledepth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_DATATYPE:\n\t\t\tswitch (td->td_sampleformat) {\n\t\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_UINT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_INT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_IEEEFP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_VOID:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_VOID;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_SAMPLEFORMAT:\n\t\t\t*va_arg(ap, uint16*) = td->td_sampleformat;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGEDEPTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagedepth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SUBIFD:\n\t\t\t*va_arg(ap, uint16*) = td->td_nsubifd;\n\t\t\t*va_arg(ap, uint64**) = td->td_subifd;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRPOSITIONING:\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrpositioning;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[0];\n\t\t\tif (td->td_samplesperpixel - td->td_extrasamples > 1) {\n\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[1];\n\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[2];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_REFERENCEBLACKWHITE:\n\t\t\t*va_arg(ap, float**) = td->td_refblackwhite;\n\t\t\tbreak;\n\t\tcase TIFFTAG_INKNAMES:\n\t\t\t*va_arg(ap, char**) = td->td_inknames;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\t/*\n\t\t\t\t * This can happen if multiple images are open\n\t\t\t\t * with different codecs which have private\n\t\t\t\t * tags.  The global tag information table may\n\t\t\t\t * then have tags that are valid for one file\n\t\t\t\t * but not the other. If the client tries to\n\t\t\t\t * get a tag that is not valid for the image's\n\t\t\t\t * codec then we'll arrive here.\n\t\t\t\t */\n\t\t\t\tif( fip->field_bit != FIELD_CUSTOM )\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, \"_TIFFVGetField\",\n\t\t\t\t\t    \"%s: Invalid %stag \\\"%s\\\" \"\n\t\t\t\t\t    \"(not supported by codec)\",\n\t\t\t\t\t    tif->tif_name,\n\t\t\t\t\t    isPseudoTag(tag) ? \"pseudo-\" : \"\",\n\t\t\t\t\t    fip->field_name);\n\t\t\t\t\tret_val = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Do we have a custom value?\n\t\t\t\t */\n\t\t\t\tret_val = 0;\n\t\t\t\tfor (i = 0; i < td->td_customValueCount; i++) {\n\t\t\t\t\tTIFFTagValue *tv = td->td_customValues + i;\n\n\t\t\t\t\tif (tv->info->field_tag != tag)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (fip->field_passcount) {\n\t\t\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE2)\n\t\t\t\t\t\t\t*va_arg(ap, uint32*) = (uint32)tv->count;\n\t\t\t\t\t\telse  /* Assume TIFF_VARIABLE */\n\t\t\t\t\t\t\t*va_arg(ap, uint16*) = (uint16)tv->count;\n\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\n\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t} else if (fip->field_tag == TIFFTAG_DOTRANGE\n\t\t\t\t\t\t   && strcmp(fip->field_name,\"DotRange\") == 0) {\n\t\t\t\t\t\t/* TODO: This is an evil exception and should not have been\n\t\t\t\t\t\t   handled this way ... likely best if we move it into\n\t\t\t\t\t\t   the directory structure with an explicit field in \n\t\t\t\t\t\t   libtiff 4.1 and assign it a FIELD_ value */\n\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];\n\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];\n\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (fip->field_type == TIFF_ASCII\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE2\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_SPP\n\t\t\t\t\t\t    || tv->count > 1) {\n\t\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\n\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchar *val = (char *)tv->value;\n\t\t\t\t\t\t\tassert( tv->count == 1 );\n\t\t\t\t\t\t\tswitch (fip->field_type) {\n\t\t\t\t\t\t\tcase TIFF_BYTE:\n\t\t\t\t\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint8*) =\n\t\t\t\t\t\t\t\t\t*(uint8 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SBYTE:\n\t\t\t\t\t\t\t\t*va_arg(ap, int8*) =\n\t\t\t\t\t\t\t\t\t*(int8 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SHORT:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint16*) =\n\t\t\t\t\t\t\t\t\t*(uint16 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SSHORT:\n\t\t\t\t\t\t\t\t*va_arg(ap, int16*) =\n\t\t\t\t\t\t\t\t\t*(int16 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_LONG:\n\t\t\t\t\t\t\tcase TIFF_IFD:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint32*) =\n\t\t\t\t\t\t\t\t\t*(uint32 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SLONG:\n\t\t\t\t\t\t\t\t*va_arg(ap, int32*) =\n\t\t\t\t\t\t\t\t\t*(int32 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_LONG8:\n\t\t\t\t\t\t\tcase TIFF_IFD8:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint64*) =\n\t\t\t\t\t\t\t\t\t*(uint64 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SLONG8:\n\t\t\t\t\t\t\t\t*va_arg(ap, int64*) =\n\t\t\t\t\t\t\t\t\t*(int64 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_RATIONAL:\n\t\t\t\t\t\t\tcase TIFF_SRATIONAL:\n\t\t\t\t\t\t\tcase TIFF_FLOAT:\n\t\t\t\t\t\t\t\t*va_arg(ap, float*) =\n\t\t\t\t\t\t\t\t\t*(float *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_DOUBLE:\n\t\t\t\t\t\t\t\t*va_arg(ap, double*) =\n\t\t\t\t\t\t\t\t\t*(double *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tret_val = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn(ret_val);\n}",
        "begin_line": 847,
        "end_line": 1169,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir._TIFFVSetField#157",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir._TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "static int\n_TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tstatic const char module[] = \"_TIFFVSetField\";\n\n\tTIFFDirectory* td = &tif->tif_dir;\n\tint status = 1;\n\tuint32 v32, i, v;\n    double dblval;\n\tchar* s;\n\tconst TIFFField *fip = TIFFFindField(tif, tag, TIFF_ANY);\n\tuint32 standard_tag = tag;\n\tif( fip == NULL ) /* cannot happen since OkToChangeTag() already checks it */\n\t    return 0;\n\t/*\n\t * We want to force the custom code to be used for custom\n\t * fields even if the tag happens to match a well known \n\t * one - important for reinterpreted handling of standard\n\t * tag values in custom directories (i.e. EXIF) \n\t */\n\tif (fip->field_bit == FIELD_CUSTOM) {\n\t\tstandard_tag = 0;\n\t}\n\n\tswitch (standard_tag) {\n\tcase TIFFTAG_SUBFILETYPE:\n\t\ttd->td_subfiletype = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_IMAGEWIDTH:\n\t\ttd->td_imagewidth = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_IMAGELENGTH:\n\t\ttd->td_imagelength = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_BITSPERSAMPLE:\n\t\ttd->td_bitspersample = (uint16) va_arg(ap, uint16_vap);\n\t\t/*\n\t\t * If the data require post-decoding processing to byte-swap\n\t\t * samples, set it up here.  Note that since tags are required\n\t\t * to be ordered, compression code can override this behaviour\n\t\t * in the setup method if it wants to roll the post decoding\n\t\t * work in with its normal work.\n\t\t */\n\t\tif (tif->tif_flags & TIFF_SWAB) {\n\t\t\tif (td->td_bitspersample == 8)\n\t\t\t\ttif->tif_postdecode = _TIFFNoPostDecode;\n\t\t\telse if (td->td_bitspersample == 16)\n\t\t\t\ttif->tif_postdecode = _TIFFSwab16BitData;\n\t\t\telse if (td->td_bitspersample == 24)\n\t\t\t\ttif->tif_postdecode = _TIFFSwab24BitData;\n\t\t\telse if (td->td_bitspersample == 32)\n\t\t\t\ttif->tif_postdecode = _TIFFSwab32BitData;\n\t\t\telse if (td->td_bitspersample == 64)\n\t\t\t\ttif->tif_postdecode = _TIFFSwab64BitData;\n\t\t\telse if (td->td_bitspersample == 128) /* two 64's */\n\t\t\t\ttif->tif_postdecode = _TIFFSwab64BitData;\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_COMPRESSION:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\t/*\n\t\t * If we're changing the compression scheme, the notify the\n\t\t * previous module so that it can cleanup any state it's\n\t\t * setup.\n\t\t */\n\t\tif (TIFFFieldSet(tif, FIELD_COMPRESSION)) {\n\t\t\tif ((uint32)td->td_compression == v)\n\t\t\t\tbreak;\n\t\t\t(*tif->tif_cleanup)(tif);\n\t\t\ttif->tif_flags &= ~TIFF_CODERSETUP;\n\t\t}\n\t\t/*\n\t\t * Setup new compression routine state.\n\t\t */\n\t\tif( (status = TIFFSetCompressionScheme(tif, v)) != 0 )\n\t\t    td->td_compression = (uint16) v;\n\t\telse\n\t\t    status = 0;\n\t\tbreak;\n\tcase TIFFTAG_PHOTOMETRIC:\n\t\ttd->td_photometric = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_THRESHHOLDING:\n\t\ttd->td_threshholding = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_FILLORDER:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v != FILLORDER_LSB2MSB && v != FILLORDER_MSB2LSB)\n\t\t\tgoto badvalue;\n\t\ttd->td_fillorder = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_ORIENTATION:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v < ORIENTATION_TOPLEFT || ORIENTATION_LEFTBOT < v)\n\t\t\tgoto badvalue;\n\t\telse\n\t\t\ttd->td_orientation = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_SAMPLESPERPIXEL:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v == 0)\n\t\t\tgoto badvalue;\n        if( v != td->td_samplesperpixel )\n        {\n            /* See http://bugzilla.maptools.org/show_bug.cgi?id=2500 */\n            if( td->td_sminsamplevalue != NULL )\n            {\n                TIFFWarningExt(tif->tif_clientdata,module,\n                    \"SamplesPerPixel tag value is changing, \"\n                    \"but SMinSampleValue tag was read with a different value. Cancelling it\");\n                TIFFClrFieldBit(tif,FIELD_SMINSAMPLEVALUE);\n                _TIFFfree(td->td_sminsamplevalue);\n                td->td_sminsamplevalue = NULL;\n            }\n            if( td->td_smaxsamplevalue != NULL )\n            {\n                TIFFWarningExt(tif->tif_clientdata,module,\n                    \"SamplesPerPixel tag value is changing, \"\n                    \"but SMaxSampleValue tag was read with a different value. Cancelling it\");\n                TIFFClrFieldBit(tif,FIELD_SMAXSAMPLEVALUE);\n                _TIFFfree(td->td_smaxsamplevalue);\n                td->td_smaxsamplevalue = NULL;\n            }\n        }\n\t\ttd->td_samplesperpixel = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_ROWSPERSTRIP:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 == 0)\n\t\t\tgoto badvalue32;\n\t\ttd->td_rowsperstrip = v32;\n\t\tif (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {\n\t\t\ttd->td_tilelength = v32;\n\t\t\ttd->td_tilewidth = td->td_imagewidth;\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\ttd->td_minsamplevalue = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\ttd->td_maxsamplevalue = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t_TIFFsetDoubleArray(&td->td_sminsamplevalue, va_arg(ap, double*), td->td_samplesperpixel);\n\t\telse\n\t\t\tsetDoubleArrayOneValue(&td->td_sminsamplevalue, va_arg(ap, double), td->td_samplesperpixel);\n\t\tbreak;\n\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t_TIFFsetDoubleArray(&td->td_smaxsamplevalue, va_arg(ap, double*), td->td_samplesperpixel);\n\t\telse\n\t\t\tsetDoubleArrayOneValue(&td->td_smaxsamplevalue, va_arg(ap, double), td->td_samplesperpixel);\n\t\tbreak;\n\tcase TIFFTAG_XRESOLUTION:\n        dblval = va_arg(ap, double);\n        if( dblval < 0 )\n            goto badvaluedouble;\n\t\ttd->td_xresolution = (float) dblval;\n\t\tbreak;\n\tcase TIFFTAG_YRESOLUTION:\n        dblval = va_arg(ap, double);\n        if( dblval < 0 )\n            goto badvaluedouble;\n\t\ttd->td_yresolution = (float) dblval;\n\t\tbreak;\n\tcase TIFFTAG_PLANARCONFIG:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v != PLANARCONFIG_CONTIG && v != PLANARCONFIG_SEPARATE)\n\t\t\tgoto badvalue;\n\t\ttd->td_planarconfig = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_XPOSITION:\n\t\ttd->td_xposition = (float) va_arg(ap, double);\n\t\tbreak;\n\tcase TIFFTAG_YPOSITION:\n\t\ttd->td_yposition = (float) va_arg(ap, double);\n\t\tbreak;\n\tcase TIFFTAG_RESOLUTIONUNIT:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v < RESUNIT_NONE || RESUNIT_CENTIMETER < v)\n\t\t\tgoto badvalue;\n\t\ttd->td_resolutionunit = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_PAGENUMBER:\n\t\ttd->td_pagenumber[0] = (uint16) va_arg(ap, uint16_vap);\n\t\ttd->td_pagenumber[1] = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_HALFTONEHINTS:\n\t\ttd->td_halftonehints[0] = (uint16) va_arg(ap, uint16_vap);\n\t\ttd->td_halftonehints[1] = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_COLORMAP:\n\t\tv32 = (uint32)(1L<<td->td_bitspersample);\n\t\t_TIFFsetShortArray(&td->td_colormap[0], va_arg(ap, uint16*), v32);\n\t\t_TIFFsetShortArray(&td->td_colormap[1], va_arg(ap, uint16*), v32);\n\t\t_TIFFsetShortArray(&td->td_colormap[2], va_arg(ap, uint16*), v32);\n\t\tbreak;\n\tcase TIFFTAG_EXTRASAMPLES:\n\t\tif (!setExtraSamples(td, ap, &v))\n\t\t\tgoto badvalue;\n\t\tbreak;\n\tcase TIFFTAG_MATTEING:\n\t\ttd->td_extrasamples =  (((uint16) va_arg(ap, uint16_vap)) != 0);\n\t\tif (td->td_extrasamples) {\n\t\t\tuint16 sv = EXTRASAMPLE_ASSOCALPHA;\n\t\t\t_TIFFsetShortArray(&td->td_sampleinfo, &sv, 1);\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_TILEWIDTH:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 % 16) {\n\t\t\tif (tif->tif_mode != O_RDONLY)\n\t\t\t\tgoto badvalue32;\n\t\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t\t\"Nonstandard tile width %d, convert file\", v32);\n\t\t}\n\t\ttd->td_tilewidth = v32;\n\t\ttif->tif_flags |= TIFF_ISTILED;\n\t\tbreak;\n\tcase TIFFTAG_TILELENGTH:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 % 16) {\n\t\t\tif (tif->tif_mode != O_RDONLY)\n\t\t\t\tgoto badvalue32;\n\t\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t    \"Nonstandard tile length %d, convert file\", v32);\n\t\t}\n\t\ttd->td_tilelength = v32;\n\t\ttif->tif_flags |= TIFF_ISTILED;\n\t\tbreak;\n\tcase TIFFTAG_TILEDEPTH:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 == 0)\n\t\t\tgoto badvalue32;\n\t\ttd->td_tiledepth = v32;\n\t\tbreak;\n\tcase TIFFTAG_DATATYPE:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tswitch (v) {\n\t\tcase DATATYPE_VOID:\tv = SAMPLEFORMAT_VOID;\tbreak;\n\t\tcase DATATYPE_INT:\tv = SAMPLEFORMAT_INT;\tbreak;\n\t\tcase DATATYPE_UINT:\tv = SAMPLEFORMAT_UINT;\tbreak;\n\t\tcase DATATYPE_IEEEFP:\tv = SAMPLEFORMAT_IEEEFP;break;\n\t\tdefault:\t\tgoto badvalue;\n\t\t}\n\t\ttd->td_sampleformat = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_SAMPLEFORMAT:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v < SAMPLEFORMAT_UINT || SAMPLEFORMAT_COMPLEXIEEEFP < v)\n\t\t\tgoto badvalue;\n\t\ttd->td_sampleformat = (uint16) v;\n\n\t\t/*  Try to fix up the SWAB function for complex data. */\n\t\tif( td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT\n\t\t    && td->td_bitspersample == 32\n\t\t    && tif->tif_postdecode == _TIFFSwab32BitData )\n\t\t    tif->tif_postdecode = _TIFFSwab16BitData;\n\t\telse if( (td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT\n\t\t\t  || td->td_sampleformat == SAMPLEFORMAT_COMPLEXIEEEFP)\n\t\t\t && td->td_bitspersample == 64\n\t\t\t && tif->tif_postdecode == _TIFFSwab64BitData )\n\t\t    tif->tif_postdecode = _TIFFSwab32BitData;\n\t\tbreak;\n\tcase TIFFTAG_IMAGEDEPTH:\n\t\ttd->td_imagedepth = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_SUBIFD:\n\t\tif ((tif->tif_flags & TIFF_INSUBIFD) == 0) {\n\t\t\ttd->td_nsubifd = (uint16) va_arg(ap, uint16_vap);\n\t\t\t_TIFFsetLong8Array(&td->td_subifd, (uint64*) va_arg(ap, uint64*),\n\t\t\t    (uint32) td->td_nsubifd);\n\t\t} else {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"%s: Sorry, cannot nest SubIFDs\",\n\t\t\t\t     tif->tif_name);\n\t\t\tstatus = 0;\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_YCBCRPOSITIONING:\n\t\ttd->td_ycbcrpositioning = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\ttd->td_ycbcrsubsampling[0] = (uint16) va_arg(ap, uint16_vap);\n\t\ttd->td_ycbcrsubsampling[1] = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\tv = (td->td_samplesperpixel - td->td_extrasamples) > 1 ? 3 : 1;\n\t\tfor (i = 0; i < v; i++)\n\t\t\t_TIFFsetShortArray(&td->td_transferfunction[i],\n\t\t\t    va_arg(ap, uint16*), 1U<<td->td_bitspersample);\n\t\tbreak;\n\tcase TIFFTAG_REFERENCEBLACKWHITE:\n\t\t/* XXX should check for null range */\n\t\t_TIFFsetFloatArray(&td->td_refblackwhite, va_arg(ap, float*), 6);\n\t\tbreak;\n\tcase TIFFTAG_INKNAMES:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\ts = va_arg(ap, char*);\n\t\tv = checkInkNamesString(tif, v, s);\n\t\tstatus = v > 0;\n\t\tif( v > 0 ) {\n\t\t\t_TIFFsetNString(&td->td_inknames, s, v);\n\t\t\ttd->td_inknameslen = v;\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_PERSAMPLE:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif( v == PERSAMPLE_MULTI )\n\t\t\ttif->tif_flags |= TIFF_PERSAMPLE;\n\t\telse\n\t\t\ttif->tif_flags &= ~TIFF_PERSAMPLE;\n\t\tbreak;\n\tdefault: {\n\t\tTIFFTagValue *tv;\n\t\tint tv_size, iCustom;\n\n\t\t/*\n\t\t * This can happen if multiple images are open with different\n\t\t * codecs which have private tags.  The global tag information\n\t\t * table may then have tags that are valid for one file but not\n\t\t * the other. If the client tries to set a tag that is not valid\n\t\t * for the image's codec then we'll arrive here.  This\n\t\t * happens, for example, when tiffcp is used to convert between\n\t\t * compression schemes and codec-specific tags are blindly copied.\n\t\t */\n\t\tif(fip->field_bit != FIELD_CUSTOM) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"%s: Invalid %stag \\\"%s\\\" (not supported by codec)\",\n\t\t\t    tif->tif_name, isPseudoTag(tag) ? \"pseudo-\" : \"\",\n\t\t\t    fip->field_name);\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Find the existing entry for this custom value.\n\t\t */\n\t\ttv = NULL;\n\t\tfor (iCustom = 0; iCustom < td->td_customValueCount; iCustom++) {\n\t\t\tif (td->td_customValues[iCustom].info->field_tag == tag) {\n\t\t\t\ttv = td->td_customValues + iCustom;\n\t\t\t\tif (tv->value != NULL) {\n\t\t\t\t\t_TIFFfree(tv->value);\n\t\t\t\t\ttv->value = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Grow the custom list if the entry was not found.\n\t\t */\n\t\tif(tv == NULL) {\n\t\t\tTIFFTagValue *new_customValues;\n\n\t\t\ttd->td_customValueCount++;\n\t\t\tnew_customValues = (TIFFTagValue *)\n\t\t\t    _TIFFrealloc(td->td_customValues,\n\t\t\t    sizeof(TIFFTagValue) * td->td_customValueCount);\n\t\t\tif (!new_customValues) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"%s: Failed to allocate space for list of custom values\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\ttd->td_customValues = new_customValues;\n\n\t\t\ttv = td->td_customValues + (td->td_customValueCount - 1);\n\t\t\ttv->info = fip;\n\t\t\ttv->value = NULL;\n\t\t\ttv->count = 0;\n\t\t}\n\n\t\t/*\n\t\t * Set custom value ... save a copy of the custom tag value.\n\t\t */\n\t\ttv_size = _TIFFDataSize(fip->field_type);\n\t\tif (tv_size == 0) {\n\t\t\tstatus = 0;\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"%s: Bad field type %d for \\\"%s\\\"\",\n\t\t\t    tif->tif_name, fip->field_type,\n\t\t\t    fip->field_name);\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (fip->field_type == TIFF_ASCII)\n\t\t{\n\t\t\tuint32 ma;\n\t\t\tchar* mb;\n\t\t\tif (fip->field_passcount)\n\t\t\t{\n\t\t\t\tassert(fip->field_writecount==TIFF_VARIABLE2);\n\t\t\t\tma=(uint32)va_arg(ap,uint32);\n\t\t\t\tmb=(char*)va_arg(ap,char*);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmb=(char*)va_arg(ap,char*);\n\t\t\t\tma=(uint32)(strlen(mb)+1);\n\t\t\t}\n\t\t\ttv->count=ma;\n\t\t\tsetByteArray(&tv->value,mb,ma,1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (fip->field_passcount) {\n\t\t\t\tif (fip->field_writecount == TIFF_VARIABLE2)\n\t\t\t\t\ttv->count = (uint32) va_arg(ap, uint32);\n\t\t\t\telse\n\t\t\t\t\ttv->count = (int) va_arg(ap, int);\n\t\t\t} else if (fip->field_writecount == TIFF_VARIABLE\n\t\t\t   || fip->field_writecount == TIFF_VARIABLE2)\n\t\t\t\ttv->count = 1;\n\t\t\telse if (fip->field_writecount == TIFF_SPP)\n\t\t\t\ttv->count = td->td_samplesperpixel;\n\t\t\telse\n\t\t\t\ttv->count = fip->field_writecount;\n\n\t\t\tif (tv->count == 0) {\n\t\t\t\tstatus = 0;\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"%s: Null count for \\\"%s\\\" (type \"\n\t\t\t\t\t     \"%d, writecount %d, passcount %d)\",\n\t\t\t\t\t     tif->tif_name,\n\t\t\t\t\t     fip->field_name,\n\t\t\t\t\t     fip->field_type,\n\t\t\t\t\t     fip->field_writecount,\n\t\t\t\t\t     fip->field_passcount);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\ttv->value = _TIFFCheckMalloc(tif, tv->count, tv_size,\n\t\t\t    \"custom tag binary object\");\n\t\t\tif (!tv->value) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tif (fip->field_tag == TIFFTAG_DOTRANGE \n\t\t\t    && strcmp(fip->field_name,\"DotRange\") == 0) {\n\t\t\t\t/* TODO: This is an evil exception and should not have been\n\t\t\t\t   handled this way ... likely best if we move it into\n\t\t\t\t   the directory structure with an explicit field in \n\t\t\t\t   libtiff 4.1 and assign it a FIELD_ value */\n\t\t\t\tuint16 v2[2];\n\t\t\t\tv2[0] = (uint16)va_arg(ap, int);\n\t\t\t\tv2[1] = (uint16)va_arg(ap, int);\n\t\t\t\t_TIFFmemcpy(tv->value, &v2, 4);\n\t\t\t}\n\n\t\t\telse if (fip->field_passcount\n\t\t\t\t  || fip->field_writecount == TIFF_VARIABLE\n\t\t\t\t  || fip->field_writecount == TIFF_VARIABLE2\n\t\t\t\t  || fip->field_writecount == TIFF_SPP\n\t\t\t\t  || tv->count > 1) {\n\t\t\t\t_TIFFmemcpy(tv->value, va_arg(ap, void *),\n\t\t\t\t    tv->count * tv_size);\n\t\t\t} else {\n\t\t\t\tchar *val = (char *)tv->value;\n\t\t\t\tassert( tv->count == 1 );\n\n\t\t\t\tswitch (fip->field_type) {\n\t\t\t\tcase TIFF_BYTE:\n\t\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8 v2 = (uint8)va_arg(ap, int);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SBYTE:\n\t\t\t\t\t{\n\t\t\t\t\t\tint8 v2 = (int8)va_arg(ap, int);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SHORT:\n\t\t\t\t\t{\n\t\t\t\t\t\tuint16 v2 = (uint16)va_arg(ap, int);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SSHORT:\n\t\t\t\t\t{\n\t\t\t\t\t\tint16 v2 = (int16)va_arg(ap, int);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_LONG:\n\t\t\t\tcase TIFF_IFD:\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32 v2 = va_arg(ap, uint32);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SLONG:\n\t\t\t\t\t{\n\t\t\t\t\t\tint32 v2 = va_arg(ap, int32);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_LONG8:\n\t\t\t\tcase TIFF_IFD8:\n\t\t\t\t\t{\n\t\t\t\t\t\tuint64 v2 = va_arg(ap, uint64);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SLONG8:\n\t\t\t\t\t{\n\t\t\t\t\t\tint64 v2 = va_arg(ap, int64);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_RATIONAL:\n\t\t\t\tcase TIFF_SRATIONAL:\n\t\t\t\tcase TIFF_FLOAT:\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat v2 = (float)va_arg(ap, double);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_DOUBLE:\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble v2 = va_arg(ap, double);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t_TIFFmemset(val, 0, tv_size);\n\t\t\t\t\tstatus = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t}\n\tif (status) {\n\t\tconst TIFFField* fip2=TIFFFieldWithTag(tif,tag);\n\t\tif (fip2)                \n\t\t\tTIFFSetFieldBit(tif, fip2->field_bit);\n\t\ttif->tif_flags |= TIFF_DIRTYDIRECT;\n\t}\n\nend:\n\tva_end(ap);\n\treturn (status);\nbadvalue:\n        {\n\t\tconst TIFFField* fip2=TIFFFieldWithTag(tif,tag);\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t     \"%s: Bad value %u for \\\"%s\\\" tag\",\n\t\t     tif->tif_name, v,\n\t\t     fip2 ? fip2->field_name : \"Unknown\");\n\t\tva_end(ap);\n        }\n\treturn (0);\nbadvalue32:\n        {\n\t\tconst TIFFField* fip2=TIFFFieldWithTag(tif,tag);\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t     \"%s: Bad value %u for \\\"%s\\\" tag\",\n\t\t     tif->tif_name, v32,\n\t\t     fip2 ? fip2->field_name : \"Unknown\");\n\t\tva_end(ap);\n        }\n\treturn (0);\nbadvaluedouble:\n        {\n        const TIFFField* fip2=TIFFFieldWithTag(tif,tag);\n        TIFFErrorExt(tif->tif_clientdata, module,\n             \"%s: Bad value %f for \\\"%s\\\" tag\",\n             tif->tif_name, dblval,\n             fip2 ? fip2->field_name : \"Unknown\");\n        va_end(ap);\n        }\n    return (0);\n}",
        "begin_line": 157,
        "end_line": 738,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.setByteArray#43",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.setByteArray(void** vpp, void* vp, size_t nmemb, size_t elem_size)",
        "snippet": "static void\nsetByteArray(void** vpp, void* vp, size_t nmemb, size_t elem_size)\n{\n\tif (*vpp) {\n\t\t_TIFFfree(*vpp);\n\t\t*vpp = 0;\n\t}\n\tif (vp) {\n\t\ttmsize_t bytes = (tmsize_t)(nmemb * elem_size);\n\t\tif (elem_size && bytes / elem_size == nmemb)\n\t\t\t*vpp = (void*) _TIFFmalloc(bytes);\n\t\tif (*vpp)\n\t\t\t_TIFFmemcpy(*vpp, vp, bytes);\n\t}\n}",
        "begin_line": 43,
        "end_line": 57,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo.TIFFDataWidth#439",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo.TIFFDataWidth(TIFFDataType type)",
        "snippet": "int\nTIFFDataWidth(TIFFDataType type)\n{\n\tswitch(type)\n\t{\n\t\tcase 0:  /* nothing */\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_UNDEFINED:\n\t\t\treturn 1;\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t\treturn 2;\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_FLOAT:\n\t\tcase TIFF_IFD:\n\t\t\treturn 4;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\tcase TIFF_DOUBLE:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\tcase TIFF_IFD8:\n\t\t\treturn 8;\n\t\tdefault:\n\t\t\treturn 0; /* will return 0 for unknown types */\n\t}\n}",
        "begin_line": 439,
        "end_line": 468,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo.TIFFFieldWithTag#559",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo.TIFFFieldWithTag(TIFF* tif, uint32 tag)",
        "snippet": "const TIFFField*\nTIFFFieldWithTag(TIFF* tif, uint32 tag)\n{\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\tif (!fip) {\n\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFFieldWithTag\",\n\t\t\t     \"Internal error, unknown tag 0x%x\",\n\t\t\t     (unsigned int) tag);\n\t}\n\treturn (fip);\n}",
        "begin_line": 559,
        "end_line": 569,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo.TIFFFindField#507",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo.TIFFFindField(TIFF* tif, uint32 tag, TIFFDataType dt)",
        "snippet": "const TIFFField*\nTIFFFindField(TIFF* tif, uint32 tag, TIFFDataType dt)\n{\n\tTIFFField key = {0, 0, 0, TIFF_NOTYPE, 0, 0, 0, 0, 0, 0, NULL, NULL};\n\tTIFFField* pkey = &key;\n\tconst TIFFField **ret;\n\tif (tif->tif_foundfield && tif->tif_foundfield->field_tag == tag &&\n\t    (dt == TIFF_ANY || dt == tif->tif_foundfield->field_type))\n\t\treturn tif->tif_foundfield;\n\n\t/* If we are invoked with no field information, then just return. */\n\tif (!tif->tif_fields)\n\t\treturn NULL;\n\n\t/* NB: use sorted search (e.g. binary search) */\n\n\tkey.field_tag = tag;\n\tkey.field_type = dt;\n\n\tret = (const TIFFField **) bsearch(&pkey, tif->tif_fields,\n\t\t\t\t\t   tif->tif_nfields,\n\t\t\t\t\t   sizeof(TIFFField *), tagCompare);\n\treturn tif->tif_foundfield = (ret ? *ret : NULL);\n}",
        "begin_line": 507,
        "end_line": 530,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo._TIFFCreateAnonField#635",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo._TIFFCreateAnonField(TIFF *tif, uint32 tag, TIFFDataType field_type)",
        "snippet": "TIFFField*\n_TIFFCreateAnonField(TIFF *tif, uint32 tag, TIFFDataType field_type)\n{\n\tTIFFField *fld;\n\t(void) tif;\n\n\tfld = (TIFFField *) _TIFFmalloc(sizeof (TIFFField));\n\tif (fld == NULL)\n\t    return NULL;\n\t_TIFFmemset(fld, 0, sizeof(TIFFField));\n\n\tfld->field_tag = tag;\n\tfld->field_readcount = TIFF_VARIABLE2;\n\tfld->field_writecount = TIFF_VARIABLE2;\n\tfld->field_type = field_type;\n\tfld->reserved = 0;\n\tswitch (field_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_UNDEFINED:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_UINT8;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_UINT8;\n\t\t\tbreak;\n\t\tcase TIFF_ASCII:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_ASCII;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_ASCII;\n\t\t\tbreak;\n\t\tcase TIFF_SHORT:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_UINT16;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_UINT16;\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_UINT32;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_UINT32;\n\t\t\tbreak;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\tcase TIFF_FLOAT:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_FLOAT;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_FLOAT;\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_SINT8;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_SINT8;\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_SINT16;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_SINT16;\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_SINT32;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_SINT32;\n\t\t\tbreak;\n\t\tcase TIFF_DOUBLE:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_DOUBLE;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_DOUBLE;\n\t\t\tbreak;\n\t\tcase TIFF_IFD:\n\t\tcase TIFF_IFD8:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_IFD8;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_IFD8;\n\t\t\tbreak;\n\t\tcase TIFF_LONG8:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_UINT64;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_UINT64;\n\t\t\tbreak;\n\t\tcase TIFF_SLONG8:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_SINT64;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_SINT64;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfld->set_field_type = TIFF_SETGET_UNDEFINED;\n\t\t\tfld->get_field_type = TIFF_SETGET_UNDEFINED;\n\t\t\tbreak;\n\t}\n\tfld->field_bit = FIELD_CUSTOM;\n\tfld->field_oktochange = TRUE;\n\tfld->field_passcount = TRUE;\n\tfld->field_name = (char *) _TIFFmalloc(32);\n\tif (fld->field_name == NULL) {\n\t    _TIFFfree(fld);\n\t    return NULL;\n\t}\n\tfld->field_subfields = NULL;\n\n\t/* \n\t * note that this name is a special sign to TIFFClose() and\n\t * _TIFFSetupFields() to free the field\n\t */\n\t(void) snprintf(fld->field_name, 32, \"Tag %d\", (int) tag);\n\n\treturn fld;    \n}",
        "begin_line": 635,
        "end_line": 727,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo._TIFFDataSize#477",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo._TIFFDataSize(TIFFDataType type)",
        "snippet": "int\n_TIFFDataSize(TIFFDataType type)\n{\n\tswitch (type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_UNDEFINED:\n\t\t    return 1;\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t    return 2;\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_FLOAT:\n\t\tcase TIFF_IFD:\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\t    return 4;\n\t\tcase TIFF_DOUBLE:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\tcase TIFF_IFD8:\n\t\t    return 8;\n\t\tdefault:\n\t\t    return 0;\n\t}\n}",
        "begin_line": 477,
        "end_line": 505,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo._TIFFGetFields#306",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo._TIFFGetFields(void)",
        "snippet": "const TIFFFieldArray*\n_TIFFGetFields(void)\n{\n\treturn(&tiffFieldArray);\n}",
        "begin_line": 306,
        "end_line": 310,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo._TIFFMergeFields#370",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo._TIFFMergeFields(TIFF* tif, const TIFFField info[], uint32 n)",
        "snippet": "int\n_TIFFMergeFields(TIFF* tif, const TIFFField info[], uint32 n)\n{\n\tstatic const char module[] = \"_TIFFMergeFields\";\n\tstatic const char reason[] = \"for fields array\";\n\t/* TIFFField** tp; */\n\tuint32 i;\n\n        tif->tif_foundfield = NULL;\n\n\tif (tif->tif_fields && tif->tif_nfields > 0) {\n\t\ttif->tif_fields = (TIFFField**)\n\t\t\t_TIFFCheckRealloc(tif, tif->tif_fields,\n\t\t\t\t\t  (tif->tif_nfields + n),\n\t\t\t\t\t  sizeof(TIFFField *), reason);\n\t} else {\n\t\ttif->tif_fields = (TIFFField **)\n\t\t\t_TIFFCheckMalloc(tif, n, sizeof(TIFFField *),\n\t\t\t\t\t reason);\n\t}\n\tif (!tif->tif_fields) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Failed to allocate fields array\");\n\t\treturn 0;\n\t}\n\n\t/* tp = tif->tif_fields + tif->tif_nfields; */\n\tfor (i = 0; i < n; i++) {\n\t\tconst TIFFField *fip =\n\t\t\tTIFFFindField(tif, info[i].field_tag, TIFF_ANY);\n\n                /* only add definitions that aren't already present */\n\t\tif (!fip) {\n                        tif->tif_fields[tif->tif_nfields] = (TIFFField *) (info+i);\n                        tif->tif_nfields++;\n                }\n\t}\n\n        /* Sort the field info by tag number */\n\tqsort(tif->tif_fields, tif->tif_nfields,\n\t      sizeof(TIFFField *), tagCompare);\n\n\treturn n;\n}",
        "begin_line": 370,
        "end_line": 413,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo._TIFFSetupFields#318",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo._TIFFSetupFields(TIFF* tif, const TIFFFieldArray* fieldarray)",
        "snippet": "void\n_TIFFSetupFields(TIFF* tif, const TIFFFieldArray* fieldarray)\n{\n\tif (tif->tif_fields && tif->tif_nfields > 0) {\n\t\tuint32 i;\n\n\t\tfor (i = 0; i < tif->tif_nfields; i++) {\n\t\t\tTIFFField *fld = tif->tif_fields[i];\n\t\t\tif (fld->field_bit == FIELD_CUSTOM &&\n\t\t\t\tstrncmp(\"Tag \", fld->field_name, 4) == 0) {\n\t\t\t\t\t_TIFFfree(fld->field_name);\n\t\t\t\t\t_TIFFfree(fld);\n\t\t\t\t}\n\t\t}\n\n\t\t_TIFFfree(tif->tif_fields);\n\t\ttif->tif_fields = NULL;\n\t\ttif->tif_nfields = 0;\n\t}\n\tif (!_TIFFMergeFields(tif, fieldarray->fields, fieldarray->count)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, \"_TIFFSetupFields\",\n\t\t\t     \"Setting up field info failed\");\n\t}\n}",
        "begin_line": 318,
        "end_line": 341,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo.tagCompare#343",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo.tagCompare(const void* a, const void* b)",
        "snippet": "static int\ntagCompare(const void* a, const void* b)\n{\n\tconst TIFFField* ta = *(const TIFFField**) a;\n\tconst TIFFField* tb = *(const TIFFField**) b;\n\t/* NB: be careful of return values for 16-bit platforms */\n\tif (ta->field_tag != tb->field_tag)\n\t\treturn (int)ta->field_tag - (int)tb->field_tag;\n\telse\n\t\treturn (ta->field_type == TIFF_ANY) ?\n\t\t\t0 : ((int)tb->field_type - (int)ta->field_type);\n}",
        "begin_line": 343,
        "end_line": 354,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFCheckDirOffset#4383",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFCheckDirOffset(TIFF* tif, uint64 diroff)",
        "snippet": "static int\nTIFFCheckDirOffset(TIFF* tif, uint64 diroff)\n{\n\tuint16 n;\n\n\tif (diroff == 0)\t\t\t/* no more directories */\n\t\treturn 0;\n\tif (tif->tif_dirnumber == 65535) {\n\t    TIFFErrorExt(tif->tif_clientdata, \"TIFFCheckDirOffset\",\n\t\t\t \"Cannot handle more than 65535 TIFF directories\");\n\t    return 0;\n\t}\n\n\tfor (n = 0; n < tif->tif_dirnumber && tif->tif_dirlist; n++) {\n\t\tif (tif->tif_dirlist[n] == diroff)\n\t\t\treturn 0;\n\t}\n\n\ttif->tif_dirnumber++;\n\n\tif (tif->tif_dirlist == NULL || tif->tif_dirnumber > tif->tif_dirlistsize) {\n\t\tuint64* new_dirlist;\n\n\t\t/*\n\t\t * XXX: Reduce memory allocation granularity of the dirlist\n\t\t * array.\n\t\t */\n\t\tnew_dirlist = (uint64*)_TIFFCheckRealloc(tif, tif->tif_dirlist,\n\t\t    tif->tif_dirnumber, 2 * sizeof(uint64), \"for IFD list\");\n\t\tif (!new_dirlist)\n\t\t\treturn 0;\n\t\tif( tif->tif_dirnumber >= 32768 )\n\t\t    tif->tif_dirlistsize = 65535;\n\t\telse\n\t\t    tif->tif_dirlistsize = 2 * tif->tif_dirnumber;\n\t\ttif->tif_dirlist = new_dirlist;\n\t}\n\n\ttif->tif_dirlist[tif->tif_dirnumber - 1] = diroff;\n\n\treturn 1;\n}",
        "begin_line": 4383,
        "end_line": 4424,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFFetchDirectory#4457",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir, uint64 *nextdiroff)",
        "snippet": "static uint16\nTIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir,\n                   uint64 *nextdiroff)\n{\n\tstatic const char module[] = \"TIFFFetchDirectory\";\n\n\tvoid* origdir;\n\tuint16 dircount16;\n\tuint32 dirsize;\n\tTIFFDirEntry* dir;\n\tuint8* ma;\n\tTIFFDirEntry* mb;\n\tuint16 n;\n\n\tassert(pdir);\n\n\ttif->tif_diroff = diroff;\n\tif (nextdiroff)\n\t\t*nextdiroff = 0;\n\tif (!isMapped(tif)) {\n\t\tif (!SeekOK(tif, tif->tif_diroff)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%s: Seek error accessing TIFF directory\",\n\t\t\t\ttif->tif_name);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tif (!ReadOK(tif, &dircount16, sizeof (uint16))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"%s: Can not read TIFF directory count\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&dircount16);\n\t\t\tif (dircount16>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdirsize = 12;\n\t\t} else {\n\t\t\tuint64 dircount64;\n\t\t\tif (!ReadOK(tif, &dircount64, sizeof (uint64))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\"%s: Can not read TIFF directory count\",\n\t\t\t\t\ttif->tif_name);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\tif (dircount64>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdircount16 = (uint16)dircount64;\n\t\t\tdirsize = 20;\n\t\t}\n\t\torigdir = _TIFFCheckMalloc(tif, dircount16,\n\t\t    dirsize, \"to read TIFF directory\");\n\t\tif (origdir == NULL)\n\t\t\treturn 0;\n\t\tif (!ReadOK(tif, origdir, (tmsize_t)(dircount16*dirsize))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%.100s: Can not read TIFF directory\",\n\t\t\t\ttif->tif_name);\n\t\t\t_TIFFfree(origdir);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Read offset to next directory for sequential scans if\n\t\t * needed.\n\t\t */\n\t\tif (nextdiroff)\n\t\t{\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t{\n\t\t\t\tuint32 nextdiroff32;\n\t\t\t\tif (!ReadOK(tif, &nextdiroff32, sizeof(uint32)))\n\t\t\t\t\tnextdiroff32 = 0;\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong(&nextdiroff32);\n\t\t\t\t*nextdiroff=nextdiroff32;\n\t\t\t} else {\n\t\t\t\tif (!ReadOK(tif, nextdiroff, sizeof(uint64)))\n\t\t\t\t\t*nextdiroff = 0;\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong8(nextdiroff);\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttmsize_t m;\n\t\ttmsize_t off = (tmsize_t) tif->tif_diroff;\n\t\tif ((uint64)off!=tif->tif_diroff)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Can not read TIFF directory count\");\n\t\t\treturn(0);\n\t\t}\n\n\t\t/*\n\t\t * Check for integer overflow when validating the dir_off,\n\t\t * otherwise a very high offset may cause an OOB read and\n\t\t * crash the client. Make two comparisons instead of\n\t\t *\n\t\t *  off + sizeof(uint16) > tif->tif_size\n\t\t *\n\t\t * to avoid overflow.\n\t\t */\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tm=off+sizeof(uint16);\n\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint16))||(m>tif->tif_size)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\"Can not read TIFF directory count\");\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t_TIFFmemcpy(&dircount16, tif->tif_base + off,\n\t\t\t\t\t    sizeof(uint16));\n\t\t\t}\n\t\t\toff += sizeof (uint16);\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&dircount16);\n\t\t\tif (dircount16>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdirsize = 12;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint64 dircount64;\n\t\t\tm=off+sizeof(uint64);\n\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint64))||(m>tif->tif_size)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\"Can not read TIFF directory count\");\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t_TIFFmemcpy(&dircount64, tif->tif_base + off,\n\t\t\t\t\t    sizeof(uint64));\n\t\t\t}\n\t\t\toff += sizeof (uint64);\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\tif (dircount64>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdircount16 = (uint16)dircount64;\n\t\t\tdirsize = 20;\n\t\t}\n\t\tif (dircount16 == 0 )\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t             \"Sanity check on directory count failed, zero tag directories not supported\");\n\t\t\treturn 0;\n\t\t}\n\t\torigdir = _TIFFCheckMalloc(tif, dircount16,\n\t\t\t\t\t\tdirsize,\n\t\t\t\t\t\t\"to read TIFF directory\");\n\t\tif (origdir == NULL)\n\t\t\treturn 0;\n\t\tm=off+dircount16*dirsize;\n\t\tif ((m<off)||(m<(tmsize_t)(dircount16*dirsize))||(m>tif->tif_size)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"Can not read TIFF directory\");\n\t\t\t_TIFFfree(origdir);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t_TIFFmemcpy(origdir, tif->tif_base + off,\n\t\t\t\t    dircount16 * dirsize);\n\t\t}\n\t\tif (nextdiroff) {\n\t\t\toff += dircount16 * dirsize;\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t{\n\t\t\t\tuint32 nextdiroff32;\n\t\t\t\tm=off+sizeof(uint32);\n\t\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint32))||(m>tif->tif_size))\n\t\t\t\t\tnextdiroff32 = 0;\n\t\t\t\telse\n\t\t\t\t\t_TIFFmemcpy(&nextdiroff32, tif->tif_base + off,\n\t\t\t\t\t\t    sizeof (uint32));\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong(&nextdiroff32);\n\t\t\t\t*nextdiroff = nextdiroff32;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm=off+sizeof(uint64);\n\t\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint64))||(m>tif->tif_size))\n\t\t\t\t\t*nextdiroff = 0;\n\t\t\t\telse\n\t\t\t\t\t_TIFFmemcpy(nextdiroff, tif->tif_base + off,\n\t\t\t\t\t\t    sizeof (uint64));\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong8(nextdiroff);\n\t\t\t}\n\t\t}\n\t}\n\tdir = (TIFFDirEntry*)_TIFFCheckMalloc(tif, dircount16,\n\t\t\t\t\t\tsizeof(TIFFDirEntry),\n\t\t\t\t\t\t\"to read TIFF directory\");\n\tif (dir==0)\n\t{\n\t\t_TIFFfree(origdir);\n\t\treturn 0;\n\t}\n\tma=(uint8*)origdir;\n\tmb=dir;\n\tfor (n=0; n<dircount16; n++)\n\t{\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabShort((uint16*)ma);\n\t\tmb->tdir_tag=*(uint16*)ma;\n\t\tma+=sizeof(uint16);\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabShort((uint16*)ma);\n\t\tmb->tdir_type=*(uint16*)ma;\n\t\tma+=sizeof(uint16);\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\tmb->tdir_count=(uint64)(*(uint32*)ma);\n\t\t\tma+=sizeof(uint32);\n\t\t\t*(uint32*)(&mb->tdir_offset)=*(uint32*)ma;\n\t\t\tma+=sizeof(uint32);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8((uint64*)ma);\n                        mb->tdir_count=TIFFReadUInt64(ma);\n\t\t\tma+=sizeof(uint64);\n\t\t\tmb->tdir_offset.toff_long8=TIFFReadUInt64(ma);\n\t\t\tma+=sizeof(uint64);\n\t\t}\n\t\tmb++;\n\t}\n\t_TIFFfree(origdir);\n\t*pdir = dir;\n\treturn dircount16;\n}",
        "begin_line": 4457,
        "end_line": 4707,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFFetchNormalTag#4712",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)",
        "snippet": "static int\nTIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)\n{\n\tstatic const char module[] = \"TIFFFetchNormalTag\";\n\tenum TIFFReadDirEntryErr err;\n\tuint32 fii;\n\tconst TIFFField* fip = NULL;\n\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n        if( fii == FAILED_FII )\n        {\n            TIFFErrorExt(tif->tif_clientdata, \"TIFFFetchNormalTag\",\n                         \"No definition found for tag %d\",\n                         dp->tdir_tag);\n            return 0;\n        }\n\tfip=tif->tif_fields[fii];\n\tassert(fip != NULL); /* should not happen */\n\tassert(fip->set_field_type!=TIFF_SETGET_OTHER);  /* if so, we shouldn't arrive here but deal with this in specialized code */\n\tassert(fip->set_field_type!=TIFF_SETGET_INT);    /* if so, we shouldn't arrive here as this is only the case for pseudo-tags */\n\terr=TIFFReadDirEntryErrOk;\n\tswitch (fip->set_field_type)\n\t{\n\t\tcase TIFF_SETGET_UNDEFINED:\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_ASCII:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tuint8* ma;\n\t\t\t\t\tuint32 mb;\n\t\t\t\t\tint n;\n\t\t\t\t\tma=data;\n\t\t\t\t\tmb=0;\n\t\t\t\t\twhile (mb<(uint32)dp->tdir_count)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (*ma==0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tma++;\n\t\t\t\t\t\tmb++;\n\t\t\t\t\t}\n\t\t\t\t\tif (mb+1<(uint32)dp->tdir_count)\n\t\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" contains null byte in value; value incorrectly truncated during reading due to implementation limitations\",fip->field_name);\n\t\t\t\t\telse if (mb+1>(uint32)dp->tdir_count)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8* o;\n\t\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" does not end in null byte\",fip->field_name);\n\t\t\t\t\t\tif ((uint32)dp->tdir_count+1!=dp->tdir_count+1)\n\t\t\t\t\t\t\to=NULL;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\to=_TIFFmalloc((uint32)dp->tdir_count+1);\n\t\t\t\t\t\tif (o==NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (data!=NULL)\n\t\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_TIFFmemcpy(o,data,(uint32)dp->tdir_count);\n\t\t\t\t\t\to[(uint32)dp->tdir_count]=0;\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tdata=o;\n\t\t\t\t\t}\n\t\t\t\t\tn=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!n)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT8:\n\t\t\t{\n\t\t\t\tuint8 data=0;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryByte(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT16:\n\t\t\t{\n\t\t\t\tuint16 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryShort(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT32:\n\t\t\t{\n\t\t\t\tuint32 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryLong(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT64:\n\t\t\t{\n\t\t\t\tuint64 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryLong8(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_FLOAT:\n\t\t\t{\n\t\t\t\tfloat data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryFloat(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_DOUBLE:\n\t\t\t{\n\t\t\t\tdouble data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryDouble(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_IFD8:\n\t\t\t{\n\t\t\t\tuint64 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryIfd8(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT16_PAIR:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount==2);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=2) {\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t\t\t       \"incorrect count for field \\\"%s\\\", expected 2, got %d\",\n\t\t\t\t\t\t       fip->field_name,(int)dp->tdir_count);\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data[0],data[1]);\n\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_UINT8:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount) {\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t\t\t       \"incorrect count for field \\\"%s\\\", expected %d, got %d\",\n\t\t\t\t\t\t       fip->field_name,(int) fip->field_readcount, (int)dp->tdir_count);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_UINT16:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)\n                                    /* corrupt file */;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_UINT32:\n\t\t\t{\n\t\t\t\tuint32* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)\n                                    /* corrupt file */;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_FLOAT:\n\t\t\t{\n\t\t\t\tfloat* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)\n                                    /* corrupt file */;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_ASCII:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n                        if( dp->tdir_count > 0 && data[dp->tdir_count-1] != '\\0' )\n                        {\n                            TIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" does not end in null byte. Forcing it to be null\",fip->field_name);\n                            data[dp->tdir_count-1] = '\\0';\n                        }\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT8:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT16:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT32:\n\t\t\t{\n\t\t\t\tuint32* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT64:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryLong8Array(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_FLOAT:\n\t\t\t{\n\t\t\t\tfloat* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_DOUBLE:\n\t\t\t{\n\t\t\t\tdouble* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryDoubleArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_IFD8:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryIfd8Array(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_ASCII:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n                    if( dp->tdir_count > 0 && data[dp->tdir_count-1] != '\\0' )\n                    {\n                        TIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" does not end in null byte. Forcing it to be null\",fip->field_name);\n                        data[dp->tdir_count-1] = '\\0';\n                    }\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT8:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT8:\n\t\t\t{\n\t\t\t\tint8* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySbyteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT16:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT16:\n\t\t\t{\n\t\t\t\tint16* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySshortArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT32:\n\t\t\t{\n\t\t\t\tuint32* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT32:\n\t\t\t{\n\t\t\t\tint32* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySlongArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT64:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryLong8Array(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT64:\n\t\t\t{\n\t\t\t\tint64* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySlong8Array(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_FLOAT:\n\t\t\t{\n\t\t\t\tfloat* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_DOUBLE:\n\t\t\t{\n\t\t\t\tdouble* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryDoubleArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_IFD8:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryIfd8Array(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);    /* we should never get here */\n\t\t\tbreak;\n\t}\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip->field_name,recover);\n\t\treturn(0);\n\t}\n\treturn(1);\n}",
        "begin_line": 4712,
        "end_line": 5390,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFFetchStripThing#5396",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32 nstrips, uint64** lpp)",
        "snippet": "static int\nTIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32 nstrips, uint64** lpp)\n{\n\tstatic const char module[] = \"TIFFFetchStripThing\";\n\tenum TIFFReadDirEntryErr err;\n\tuint64* data;\n\terr=TIFFReadDirEntryLong8Array(tif,dir,&data);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\tconst TIFFField* fip = TIFFFieldWithTag(tif,dir->tdir_tag); \n\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",0);\n\t\treturn(0);\n\t}\n\tif (dir->tdir_count!=(uint64)nstrips)\n\t{\n\t\tuint64* resizeddata;\n\t\tresizeddata=(uint64*)_TIFFCheckMalloc(tif,nstrips,sizeof(uint64),\"for strip array\");\n\t\tif (resizeddata==0) {\n\t\t\t_TIFFfree(data);\n\t\t\treturn(0);\n\t\t}\n\t\tif (dir->tdir_count<(uint64)nstrips)\n\t\t{\n\t\t\t_TIFFmemcpy(resizeddata,data,(uint32)dir->tdir_count*sizeof(uint64));\n\t\t\t_TIFFmemset(resizeddata+(uint32)dir->tdir_count,0,(nstrips-(uint32)dir->tdir_count)*sizeof(uint64));\n\t\t}\n\t\telse\n\t\t\t_TIFFmemcpy(resizeddata,data,nstrips*sizeof(uint64));\n\t\t_TIFFfree(data);\n\t\tdata=resizeddata;\n\t}\n\t*lpp=data;\n\treturn(1);\n}",
        "begin_line": 5396,
        "end_line": 5429,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryArray#767",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryArray(TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize, void** value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryArray(TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize, void** value)\n{\n\tint typesize;\n\tuint32 datasize;\n\tvoid* data;\n\ttypesize=TIFFDataWidth(direntry->tdir_type);\n\tif ((direntry->tdir_count==0)||(typesize==0))\n\t{\n\t\t*value=0;\n\t\treturn(TIFFReadDirEntryErrOk);\n\t}\n        (void) desttypesize;\n\n        /* \n         * As a sanity check, make sure we have no more than a 2GB tag array \n         * in either the current data type or the dest data type.  This also\n         * avoids problems with overflow of tmsize_t on 32bit systems.\n         */\n\tif ((uint64)(2147483647/typesize)<direntry->tdir_count)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\tif ((uint64)(2147483647/desttypesize)<direntry->tdir_count)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\n\t*count=(uint32)direntry->tdir_count;\n\tdatasize=(*count)*typesize;\n\tassert((tmsize_t)datasize>0);\n\tdata=_TIFFCheckMalloc(tif, *count, typesize, \"ReadDirEntryArray\");\n\tif (data==0)\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tif (datasize<=4)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint32 offset = direntry->tdir_offset.toff_long;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&offset);\n\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (datasize<=8)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint64 offset = direntry->tdir_offset.toff_long8;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&offset);\n\t\t\terr=TIFFReadDirEntryData(tif,offset,(tmsize_t)datasize,data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 767,
        "end_line": 834,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryByteArray#836",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntry* direntry, uint8** value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntry* direntry, uint8** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tuint8* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_UNDEFINED:\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,1,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_UNDEFINED:\n\t\tcase TIFF_BYTE:\n\t\t\t*value=(uint8*)origdata;\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8* m;\n\t\t\t\tuint32 n;\n\t\t\t\tm=(int8*)origdata;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSbyte(*m);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\t_TIFFfree(origdata);\n\t\t\t\t\t\treturn(err);\n\t\t\t\t\t}\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t\t*value=(uint8*)origdata;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t}\n\tdata=(uint8*)_TIFFmalloc(count);\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteShort(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort((uint16*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSshort(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteLong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSlong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteLong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8((uint64*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSlong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\t_TIFFfree(data);\n\t\treturn(err);\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 836,
        "end_line": 1015,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryCheckedShort#2787",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryCheckedShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)",
        "snippet": "static void TIFFReadDirEntryCheckedShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)\n{\n\t*value = direntry->tdir_offset.toff_short;\n\t/* *value=*(uint16*)(&direntry->tdir_offset); */\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabShort(value);\n}",
        "begin_line": 2787,
        "end_line": 2793,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryData#3282",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryData(TIFF* tif, uint64 offset, tmsize_t size, void* dest)",
        "snippet": "static enum TIFFReadDirEntryErr\nTIFFReadDirEntryData(TIFF* tif, uint64 offset, tmsize_t size, void* dest)\n{\n\tassert(size>0);\n\tif (!isMapped(tif)) {\n\t\tif (!SeekOK(tif,offset))\n\t\t\treturn(TIFFReadDirEntryErrIo);\n\t\tif (!ReadOK(tif,dest,size))\n\t\t\treturn(TIFFReadDirEntryErrIo);\n\t} else {\n\t\tsize_t ma,mb;\n\t\tma=(size_t)offset;\n\t\tmb=ma+size;\n\t\tif (((uint64)ma!=offset)\n\t\t    || (mb < ma)\n\t\t    || (mb - ma != (size_t) size)\n\t\t    || (mb < (size_t)size)\n\t\t    || (mb > (size_t)tif->tif_size)\n\t\t    )\n\t\t\treturn(TIFFReadDirEntryErrIo);\n\t\t_TIFFmemcpy(dest,tif->tif_base+ma,size);\n\t}\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 3282,
        "end_line": 3305,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryLong#374",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryLong(TIFF* tif, TIFFDirEntry* direntry, uint32* value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryLong(TIFF* tif, TIFFDirEntry* direntry, uint32* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tif (direntry->tdir_count!=1)\n\t\treturn(TIFFReadDirEntryErrCount);\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedByte(tif,direntry,&m);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedSbyte(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSbyte(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedShort(tif,direntry,&m);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedSshort(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSshort(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG:\n\t\t\tTIFFReadDirEntryCheckedLong(tif,direntry,value);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedSlong(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSlong(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongLong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSlong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n}",
        "begin_line": 374,
        "end_line": 455,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryLong8Array#1865",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tuint64* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,8,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_LONG8:\n\t\t\t*value=(uint64*)origdata;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabArrayOfLong8(*value,count);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64* m;\n\t\t\t\tuint32 n;\n\t\t\t\tm=(int64*)origdata;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8((uint64*)m);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Slong8(*m);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\t_TIFFfree(origdata);\n\t\t\t\t\t\treturn(err);\n\t\t\t\t\t}\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t\t*value=(uint64*)origdata;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t}\n\tdata=(uint64*)_TIFFmalloc(count*8);\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Sbyte(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort(ma);\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort((uint16*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Sshort(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Slong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\t_TIFFfree(data);\n\t\treturn(err);\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 1865,
        "end_line": 2029,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryPersampleShort#2717",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryPersampleShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryPersampleShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint16* m;\n\tuint16* na;\n\tuint16 nb;\n\tif (direntry->tdir_count<(uint64)tif->tif_dir.td_samplesperpixel)\n\t\treturn(TIFFReadDirEntryErrCount);\n\terr=TIFFReadDirEntryShortArray(tif,direntry,&m);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t\treturn(err);\n\tna=m;\n\tnb=tif->tif_dir.td_samplesperpixel;\n\t*value=*na++;\n\tnb--;\n\twhile (nb>0)\n\t{\n\t\tif (*na++!=*value)\n\t\t{\n\t\t\terr=TIFFReadDirEntryErrPsdif;\n\t\t\tbreak;\n\t\t}\n\t\tnb--;\n\t}\n\t_TIFFfree(m);\n\treturn(err);\n}",
        "begin_line": 2717,
        "end_line": 2743,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryShort#288",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tif (direntry->tdir_count!=1)\n\t\treturn(TIFFReadDirEntryErrCount);\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedByte(tif,direntry,&m);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedSbyte(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSbyte(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SHORT:\n\t\t\tTIFFReadDirEntryCheckedShort(tif,direntry,value);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedSshort(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSshort(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedLong(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortLong(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedSlong(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSlong(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortLong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSlong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n}",
        "begin_line": 288,
        "end_line": 372,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryShortArray#1196",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryShortArray(TIFF* tif, TIFFDirEntry* direntry, uint16** value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryShortArray(TIFF* tif, TIFFDirEntry* direntry, uint16** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tuint16* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,2,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_SHORT:\n\t\t\t*value=(uint16*)origdata;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabArrayOfShort(*value,count);  \n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16* m;\n\t\t\t\tuint32 n;\n\t\t\t\tm=(int16*)origdata;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort((uint16*)m);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSshort(*m);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\t_TIFFfree(origdata);\n\t\t\t\t\t\treturn(err);\n\t\t\t\t\t}\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t\t*value=(uint16*)origdata;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t}\n\tdata=(uint16*)_TIFFmalloc(count*2);\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSbyte(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortLong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSlong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortLong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8((uint64*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSlong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\t_TIFFfree(data);\n\t\treturn(err);\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 1196,
        "end_line": 1366,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirectory#3398",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirectory(TIFF* tif)",
        "snippet": "int\nTIFFReadDirectory(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFReadDirectory\";\n\tTIFFDirEntry* dir;\n\tuint16 dircount;\n\tTIFFDirEntry* dp;\n\tuint16 di;\n\tconst TIFFField* fip;\n\tuint32 fii=FAILED_FII;\n        toff_t nextdiroff;\n    int bitspersample_read = FALSE;\n\n\ttif->tif_diroff=tif->tif_nextdiroff;\n\tif (!TIFFCheckDirOffset(tif,tif->tif_nextdiroff))\n\t\treturn 0;           /* last offset or bad offset (IFD looping) */\n\t(*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */\n\ttif->tif_curdir++;\n        nextdiroff = tif->tif_nextdiroff;\n\tdircount=TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff);\n\tif (!dircount)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"Failed to read directory at offset \" TIFF_UINT64_FORMAT,nextdiroff);\n\t\treturn 0;\n\t}\n\tTIFFReadDirectoryCheckOrder(tif,dir,dircount);\n\n        /*\n         * Mark duplicates of any tag to be ignored (bugzilla 1994)\n         * to avoid certain pathological problems.\n         */\n\t{\n\t\tTIFFDirEntry* ma;\n\t\tuint16 mb;\n\t\tfor (ma=dir, mb=0; mb<dircount; ma++, mb++)\n\t\t{\n\t\t\tTIFFDirEntry* na;\n\t\t\tuint16 nb;\n\t\t\tfor (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)\n\t\t\t{\n\t\t\t\tif (ma->tdir_tag==na->tdir_tag)\n\t\t\t\t\tna->tdir_tag=IGNORE;\n\t\t\t}\n\t\t}\n\t}\n        \n\ttif->tif_flags &= ~TIFF_BEENWRITING;    /* reset before new dir */\n\ttif->tif_flags &= ~TIFF_BUF4WRITE;      /* reset before new dir */\n\t/* free any old stuff and reinit */\n\tTIFFFreeDirectory(tif);\n\tTIFFDefaultDirectory(tif);\n\t/*\n\t * Electronic Arts writes gray-scale TIFF files\n\t * without a PlanarConfiguration directory entry.\n\t * Thus we setup a default value here, even though\n\t * the TIFF spec says there is no default value.\n\t */\n\tTIFFSetField(tif,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n\t/*\n\t * Setup default value and then make a pass over\n\t * the fields to check type and tag information,\n\t * and to extract info required to size data\n\t * structures.  A second pass is made afterwards\n\t * to read in everything not taken in the first pass.\n\t * But we must process the Compression tag first\n\t * in order to merge in codec-private tag definitions (otherwise\n\t * we may get complaints about unknown tags).  However, the\n\t * Compression tag may be dependent on the SamplesPerPixel\n\t * tag value because older TIFF specs permitted Compression\n\t * to be written as a SamplesPerPixel-count tag entry.\n\t * Thus if we don't first figure out the correct SamplesPerPixel\n\t * tag value then we may end up ignoring the Compression tag\n\t * value because it has an incorrect count value (if the\n\t * true value of SamplesPerPixel is not 1).\n\t */\n\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_SAMPLESPERPIXEL);\n\tif (dp)\n\t{\n\t\tif (!TIFFFetchNormalTag(tif,dp,0))\n\t\t\tgoto bad;\n\t\tdp->tdir_tag=IGNORE;\n\t}\n\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_COMPRESSION);\n\tif (dp)\n\t{\n\t\t/*\n\t\t * The 5.0 spec says the Compression tag has one value, while\n\t\t * earlier specs say it has one value per sample.  Because of\n\t\t * this, we accept the tag if one value is supplied with either\n\t\t * count.\n\t\t */\n\t\tuint16 value;\n\t\tenum TIFFReadDirEntryErr err;\n\t\terr=TIFFReadDirEntryShort(tif,dp,&value);\n\t\tif (err==TIFFReadDirEntryErrCount)\n\t\t\terr=TIFFReadDirEntryPersampleShort(tif,dp,&value);\n\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t{\n\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,\"Compression\",0);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (!TIFFSetField(tif,TIFFTAG_COMPRESSION,value))\n\t\t\tgoto bad;\n\t\tdp->tdir_tag=IGNORE;\n\t}\n\telse\n\t{\n\t\tif (!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE))\n\t\t\tgoto bad;\n\t}\n\t/*\n\t * First real pass over the directory.\n\t */\n\tfor (di=0, dp=dir; di<dircount; di++, dp++)\n\t{\n\t\tif (dp->tdir_tag!=IGNORE)\n\t\t{\n\t\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\t\tif (fii == FAILED_FII)\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Unknown field with tag %d (0x%x) encountered\",\n\t\t\t\t    dp->tdir_tag,dp->tdir_tag);\n                                /* the following knowingly leaks the \n                                   anonymous field structure */\n\t\t\t\tif (!_TIFFMergeFields(tif,\n\t\t\t\t\t_TIFFCreateAnonField(tif,\n\t\t\t\t\t\tdp->tdir_tag,\n\t\t\t\t\t\t(TIFFDataType) dp->tdir_type),\n\t\t\t\t\t1)) {\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t    module,\n\t\t\t\t\t    \"Registering anonymous field with tag %d (0x%x) failed\",\n\t\t\t\t\t    dp->tdir_tag,\n\t\t\t\t\t    dp->tdir_tag);\n\t\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\t\t} else {\n\t\t\t\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\t\t\t\tassert(fii != FAILED_FII);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dp->tdir_tag!=IGNORE)\n\t\t{\n\t\t\tfip=tif->tif_fields[fii];\n\t\t\tif (fip->field_bit==FIELD_IGNORE)\n\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tswitch (dp->tdir_tag)\n\t\t\t\t{\n\t\t\t\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\t\t\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\t\t\t\tcase TIFFTAG_TILEOFFSETS:\n\t\t\t\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\t\t\t\t\tTIFFSetFieldBit(tif,fip->field_bit);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TIFFTAG_IMAGEWIDTH:\n\t\t\t\t\tcase TIFFTAG_IMAGELENGTH:\n\t\t\t\t\tcase TIFFTAG_IMAGEDEPTH:\n\t\t\t\t\tcase TIFFTAG_TILELENGTH:\n\t\t\t\t\tcase TIFFTAG_TILEWIDTH:\n\t\t\t\t\tcase TIFFTAG_TILEDEPTH:\n\t\t\t\t\tcase TIFFTAG_PLANARCONFIG:\n\t\t\t\t\tcase TIFFTAG_ROWSPERSTRIP:\n\t\t\t\t\tcase TIFFTAG_EXTRASAMPLES:\n\t\t\t\t\t\tif (!TIFFFetchNormalTag(tif,dp,0))\n\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * XXX: OJPEG hack.\n\t * If a) compression is OJPEG, b) planarconfig tag says it's separate,\n\t * c) strip offsets/bytecounts tag are both present and\n\t * d) both contain exactly one value, then we consistently find\n\t * that the buggy implementation of the buggy compression scheme\n\t * matches contig planarconfig best. So we 'fix-up' the tag here\n\t */\n\tif ((tif->tif_dir.td_compression==COMPRESSION_OJPEG)&&\n\t    (tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE))\n\t{\n        if (!_TIFFFillStriles(tif))\n            goto bad;\n\t\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS);\n\t\tif ((dp!=0)&&(dp->tdir_count==1))\n\t\t{\n\t\t\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,\n\t\t\t    TIFFTAG_STRIPBYTECOUNTS);\n\t\t\tif ((dp!=0)&&(dp->tdir_count==1))\n\t\t\t{\n\t\t\t\ttif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t    \"Planarconfig tag value assumed incorrect, \"\n\t\t\t\t    \"assuming data is contig instead of chunky\");\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Allocate directory structure and setup defaults.\n\t */\n\tif (!TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))\n\t{\n\t\tMissingRequired(tif,\"ImageLength\");\n\t\tgoto bad;\n\t}\n\t/*\n\t * Setup appropriate structures (by strip or by tile)\n\t */\n\tif (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {\n\t\ttif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif);  \n\t\ttif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;\n\t\ttif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;\n\t\ttif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;\n\t\ttif->tif_flags &= ~TIFF_ISTILED;\n\t} else {\n\t\ttif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);\n\t\ttif->tif_flags |= TIFF_ISTILED;\n\t}\n\tif (!tif->tif_dir.td_nstrips) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Cannot handle zero number of %s\",\n\t\t    isTiled(tif) ? \"tiles\" : \"strips\");\n\t\tgoto bad;\n\t}\n\ttif->tif_dir.td_stripsperimage = tif->tif_dir.td_nstrips;\n\tif (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\ttif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel;\n\tif (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {\n#ifdef OJPEG_SUPPORT\n\t\tif ((tif->tif_dir.td_compression==COMPRESSION_OJPEG) &&\n\t\t    (isTiled(tif)==0) &&\n\t\t    (tif->tif_dir.td_nstrips==1)) {\n\t\t\t/*\n\t\t\t * XXX: OJPEG hack.\n\t\t\t * If a) compression is OJPEG, b) it's not a tiled TIFF,\n\t\t\t * and c) the number of strips is 1,\n\t\t\t * then we tolerate the absence of stripoffsets tag,\n\t\t\t * because, presumably, all required data is in the\n\t\t\t * JpegInterchangeFormat stream.\n\t\t\t */\n\t\t\tTIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);\n\t\t} else\n#endif\n        {\n\t\t\tMissingRequired(tif,\n\t\t\t\tisTiled(tif) ? \"TileOffsets\" : \"StripOffsets\");\n\t\t\tgoto bad;\n\t\t}\n\t}\n\t/*\n\t * Second pass: extract other information.\n\t */\n\tfor (di=0, dp=dir; di<dircount; di++, dp++)\n\t{\n\t\tswitch (dp->tdir_tag)\n\t\t{\n\t\t\tcase IGNORE:\n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\t\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\t\tcase TIFFTAG_BITSPERSAMPLE:\n\t\t\tcase TIFFTAG_DATATYPE:\n\t\t\tcase TIFFTAG_SAMPLEFORMAT:\n\t\t\t\t/*\n\t\t\t\t * The MinSampleValue, MaxSampleValue, BitsPerSample\n\t\t\t\t * DataType and SampleFormat tags are supposed to be\n\t\t\t\t * written as one value/sample, but some vendors\n\t\t\t\t * incorrectly write one value only -- so we accept\n\t\t\t\t * that as well (yuck). Other vendors write correct\n\t\t\t\t * value for NumberOfSamples, but incorrect one for\n\t\t\t\t * BitsPerSample and friends, and we will read this\n\t\t\t\t * too.\n\t\t\t\t */\n\t\t\t\t{\n\t\t\t\t\tuint16 value;\n\t\t\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\t\t\terr=TIFFReadDirEntryShort(tif,dp,&value);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrCount)\n\t\t\t\t\t\terr=TIFFReadDirEntryPersampleShort(tif,dp,&value);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tfip = TIFFFieldWithTag(tif,dp->tdir_tag);\n\t\t\t\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",0);\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t}\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,value))\n\t\t\t\t\t\tgoto bad;\n                    if( dp->tdir_tag == TIFFTAG_BITSPERSAMPLE )\n                        bitspersample_read = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\t\t\t{\n\n\t\t\t\t\tdouble *data = NULL;\n\t\t\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\t\t\tuint32 saved_flags;\n\t\t\t\t\tint m;\n\t\t\t\t\tif (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)\n\t\t\t\t\t\terr = TIFFReadDirEntryErrCount;\n\t\t\t\t\telse\n\t\t\t\t\t\terr = TIFFReadDirEntryDoubleArray(tif, dp, &data);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tfip = TIFFFieldWithTag(tif,dp->tdir_tag);\n\t\t\t\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",0);\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t}\n\t\t\t\t\tsaved_flags = tif->tif_flags;\n\t\t\t\t\ttif->tif_flags |= TIFF_PERSAMPLE;\n\t\t\t\t\tm = TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\ttif->tif_flags = saved_flags;\n\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\t\tcase TIFFTAG_TILEOFFSETS:\n#if defined(DEFER_STRILE_LOAD)\n                                _TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),\n                                             dp, sizeof(TIFFDirEntry) );\n#else                          \n\t\t\t\tif (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset))  \n\t\t\t\t\tgoto bad;\n#endif                                \n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\t\tcase TIFFTAG_TILEBYTECOUNTS:\n#if defined(DEFER_STRILE_LOAD)\n                                _TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),\n                                             dp, sizeof(TIFFDirEntry) );\n#else                          \n\t\t\t\tif (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount))  \n\t\t\t\t\tgoto bad;\n#endif                                \n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_COLORMAP:\n\t\t\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\t\t\t{\n\t\t\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\t\t\tuint32 countpersample;\n\t\t\t\t\tuint32 countrequired;\n\t\t\t\t\tuint32 incrementpersample;\n\t\t\t\t\tuint16* value=NULL;\n                    /* It would be dangerous to instantiate those tag values */\n                    /* since if td_bitspersample has not yet been read (due to */\n                    /* unordered tags), it could be read afterwards with a */\n                    /* values greater than the default one (1), which may cause */\n                    /* crashes in user code */\n                    if( !bitspersample_read )\n                    {\n                        fip = TIFFFieldWithTag(tif,dp->tdir_tag);\n                        TIFFWarningExt(tif->tif_clientdata,module,\n                                       \"Ignoring %s since BitsPerSample tag not found\",\n                                       fip ? fip->field_name : \"unknown tagname\");\n                        continue;\n                    }\n\t\t\t\t\t/* ColorMap or TransferFunction for high bit */\n\t\t\t\t\t/* depths do not make much sense and could be */\n\t\t\t\t\t/* used as a denial of service vector */\n\t\t\t\t\tif (tif->tif_dir.td_bitspersample > 24)\n\t\t\t\t\t{\n\t\t\t\t\t    fip = TIFFFieldWithTag(tif,dp->tdir_tag);\n\t\t\t\t\t    TIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t\t\t\"Ignoring %s because BitsPerSample=%d>24\",\n\t\t\t\t\t\tfip ? fip->field_name : \"unknown tagname\",\n\t\t\t\t\t\ttif->tif_dir.td_bitspersample);\n\t\t\t\t\t    continue;\n\t\t\t\t\t}\n\t\t\t\t\tcountpersample=(1U<<tif->tif_dir.td_bitspersample);\n\t\t\t\t\tif ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))\n\t\t\t\t\t{\n\t\t\t\t\t\tcountrequired=countpersample;\n\t\t\t\t\t\tincrementpersample=0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcountrequired=3*countpersample;\n\t\t\t\t\t\tincrementpersample=countpersample;\n\t\t\t\t\t}\n\t\t\t\t\tif (dp->tdir_count!=(uint64)countrequired)\n\t\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\t\telse\n\t\t\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&value);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n                    {\n\t\t\t\t\t\tfip = TIFFFieldWithTag(tif,dp->tdir_tag);\n\t\t\t\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",1);\n                    }\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tTIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);\n\t\t\t\t\t\t_TIFFfree(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n/* BEGIN REV 4.0 COMPATIBILITY */\n\t\t\tcase TIFFTAG_OSUBFILETYPE:\n\t\t\t\t{\n\t\t\t\t\tuint16 valueo;\n\t\t\t\t\tuint32 value;\n\t\t\t\t\tif (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (valueo)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;\n\t\t\t\t\t\t\tcase OFILETYPE_PAGE: value=FILETYPE_PAGE; break;\n\t\t\t\t\t\t\tdefault: value=0; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value!=0)\n\t\t\t\t\t\t\tTIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n/* END REV 4.0 COMPATIBILITY */\n\t\t\tdefault:\n\t\t\t\t(void) TIFFFetchNormalTag(tif, dp, TRUE);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * OJPEG hack:\n\t * - If a) compression is OJPEG, and b) photometric tag is missing,\n\t * then we consistently find that photometric should be YCbCr\n\t * - If a) compression is OJPEG, and b) photometric tag says it's RGB,\n\t * then we consistently find that the buggy implementation of the\n\t * buggy compression scheme matches photometric YCbCr instead.\n\t * - If a) compression is OJPEG, and b) bitspersample tag is missing,\n\t * then we consistently find bitspersample should be 8.\n\t * - If a) compression is OJPEG, b) samplesperpixel tag is missing,\n\t * and c) photometric is RGB or YCbCr, then we consistently find\n\t * samplesperpixel should be 3\n\t * - If a) compression is OJPEG, b) samplesperpixel tag is missing,\n\t * and c) photometric is MINISWHITE or MINISBLACK, then we consistently\n\t * find samplesperpixel should be 3\n\t */\n\tif (tif->tif_dir.td_compression==COMPRESSION_OJPEG)\n\t{\n\t\tif (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Photometric tag is missing, assuming data is YCbCr\");\n\t\t\tif (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))\n\t\t\t\tgoto bad;\n\t\t}\n\t\telse if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)\n\t\t{\n\t\t\ttif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Photometric tag value assumed incorrect, \"\n\t\t\t    \"assuming data is YCbCr instead of RGB\");\n\t\t}\n\t\tif (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t    \"BitsPerSample tag is missing, assuming 8 bits per sample\");\n\t\t\tif (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))\n\t\t\t\tgoto bad;\n\t\t}\n\t\tif (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\n\t\t{\n\t\t\tif (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t    \"SamplesPerPixel tag is missing, \"\n\t\t\t\t    \"assuming correct SamplesPerPixel value is 3\");\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t    \"SamplesPerPixel tag is missing, \"\n\t\t\t\t    \"applying correct SamplesPerPixel value of 3\");\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\telse if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)\n\t\t\t\t || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * SamplesPerPixel tag is missing, but is not required\n\t\t\t\t * by spec.  Assume correct SamplesPerPixel value of 1.\n\t\t\t\t */\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Verify Palette image has a Colormap.\n\t */\n\tif (tif->tif_dir.td_photometric == PHOTOMETRIC_PALETTE &&\n\t    !TIFFFieldSet(tif, FIELD_COLORMAP)) {\n\t\tif ( tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3)\n\t\t\ttif->tif_dir.td_photometric = PHOTOMETRIC_RGB;\n\t\telse if (tif->tif_dir.td_bitspersample>=8)\n\t\t\ttif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;\n\t\telse {\n\t\t\tMissingRequired(tif, \"Colormap\");\n\t\t\tgoto bad;\n\t\t}\n\t}\n\t/*\n\t * OJPEG hack:\n\t * We do no further messing with strip/tile offsets/bytecounts in OJPEG\n\t * TIFFs\n\t */\n\tif (tif->tif_dir.td_compression!=COMPRESSION_OJPEG)\n\t{\n\t\t/*\n\t\t * Attempt to deal with a missing StripByteCounts tag.\n\t\t */\n\t\tif (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {\n\t\t\t/*\n\t\t\t * Some manufacturers violate the spec by not giving\n\t\t\t * the size of the strips.  In this case, assume there\n\t\t\t * is one uncompressed strip of data.\n\t\t\t */\n\t\t\tif ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&\n\t\t\t    tif->tif_dir.td_nstrips > 1) ||\n\t\t\t    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&\n\t\t\t     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {\n\t\t\t    MissingRequired(tif, \"StripByteCounts\");\n\t\t\t    goto bad;\n\t\t\t}\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"TIFF directory is missing required \"\n\t\t\t\t\"\\\"StripByteCounts\\\" field, calculating from imagelength\");\n\t\t\tif (EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n\t\t/*\n\t\t * Assume we have wrong StripByteCount value (in case\n\t\t * of single strip) in following cases:\n\t\t *   - it is equal to zero along with StripOffset;\n\t\t *   - it is larger than file itself (in case of uncompressed\n\t\t *     image);\n\t\t *   - it is smaller than the size of the bytes per row\n\t\t *     multiplied on the number of rows.  The last case should\n\t\t *     not be checked in the case of writing new image,\n\t\t *     because we may do not know the exact strip size\n\t\t *     until the whole image will be written and directory\n\t\t *     dumped out.\n\t\t */\n\t\t#define\tBYTECOUNTLOOKSBAD \\\n\t\t    ( (tif->tif_dir.td_stripbytecount[0] == 0 && tif->tif_dir.td_stripoffset[0] != 0) || \\\n\t\t      (tif->tif_dir.td_compression == COMPRESSION_NONE && \\\n\t\t       tif->tif_dir.td_stripbytecount[0] > TIFFGetFileSize(tif) - tif->tif_dir.td_stripoffset[0]) || \\\n\t\t      (tif->tif_mode == O_RDONLY && \\\n\t\t       tif->tif_dir.td_compression == COMPRESSION_NONE && \\\n\t\t       tif->tif_dir.td_stripbytecount[0] < TIFFScanlineSize64(tif) * tif->tif_dir.td_imagelength) )\n\n\t\t} else if (tif->tif_dir.td_nstrips == 1\n                           && _TIFFFillStriles(tif)\n\t\t\t   && tif->tif_dir.td_stripoffset[0] != 0\n\t\t\t   && BYTECOUNTLOOKSBAD) {\n\t\t\t/*\n\t\t\t * XXX: Plexus (and others) sometimes give a value of\n\t\t\t * zero for a tag when they don't know what the\n\t\t\t * correct value is!  Try and handle the simple case\n\t\t\t * of estimating the size of a one strip image.\n\t\t\t */\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Bogus \\\"StripByteCounts\\\" field, ignoring and calculating from imagelength\");\n\t\t\tif(EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n\n#if !defined(DEFER_STRILE_LOAD)\n\t\t} else if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG\n\t\t\t   && tif->tif_dir.td_nstrips > 2\n\t\t\t   && tif->tif_dir.td_compression == COMPRESSION_NONE\n\t\t\t   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]\n\t\t\t   && tif->tif_dir.td_stripbytecount[0] != 0\n\t\t\t   && tif->tif_dir.td_stripbytecount[1] != 0 ) {\n\t\t\t/*\n\t\t\t * XXX: Some vendors fill StripByteCount array with\n\t\t\t * absolutely wrong values (it can be equal to\n\t\t\t * StripOffset array, for example). Catch this case\n\t\t\t * here.\n                         *\n                         * We avoid this check if deferring strile loading\n                         * as it would always force us to load the strip/tile\n                         * information.\n\t\t\t */\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Wrong \\\"StripByteCounts\\\" field, ignoring and calculating from imagelength\");\n\t\t\tif (EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n#endif /* !defined(DEFER_STRILE_LOAD) */                        \n\t\t}\n\t}\n\tif (dir)\n\t{\n\t\t_TIFFfree(dir);\n\t\tdir=NULL;\n\t}\n\tif (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))\n\t{\n\t\tif (tif->tif_dir.td_bitspersample>=16)\n\t\t\ttif->tif_dir.td_maxsamplevalue=0xFFFF;\n\t\telse\n\t\t\ttif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1);\n\t}\n\t/*\n\t * XXX: We can optimize checking for the strip bounds using the sorted\n\t * bytecounts array. See also comments for TIFFAppendToStrip()\n\t * function in tif_write.c.\n\t */\n#if !defined(DEFER_STRILE_LOAD)        \n\tif (tif->tif_dir.td_nstrips > 1) {\n\t\tuint32 strip;\n\n\t\ttif->tif_dir.td_stripbytecountsorted = 1;\n\t\tfor (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {\n\t\t\tif (tif->tif_dir.td_stripoffset[strip - 1] >\n\t\t\t    tif->tif_dir.td_stripoffset[strip]) {\n\t\t\t\ttif->tif_dir.td_stripbytecountsorted = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif /* !defined(DEFER_STRILE_LOAD) */\n        \n\t/*\n\t * An opportunity for compression mode dependent tag fixup\n\t */\n\t(*tif->tif_fixuptags)(tif);\n\n\t/*\n\t * Some manufacturers make life difficult by writing\n\t * large amounts of uncompressed data as a single strip.\n\t * This is contrary to the recommendations of the spec.\n\t * The following makes an attempt at breaking such images\n\t * into strips closer to the recommended 8k bytes.  A\n\t * side effect, however, is that the RowsPerStrip tag\n\t * value may be changed.\n\t */\n\tif ((tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&\n\t    (tif->tif_dir.td_nstrips==1)&&\n\t    (tif->tif_dir.td_compression==COMPRESSION_NONE)&&  \n\t    ((tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP))\n    {\n        if ( !_TIFFFillStriles(tif) || !tif->tif_dir.td_stripbytecount )\n            return 0;\n\t\tChopUpSingleUncompressedStrip(tif);\n    }\n\n        /*\n         * Clear the dirty directory flag. \n         */\n\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\n\ttif->tif_flags &= ~TIFF_DIRTYSTRIP;\n\n\t/*\n\t * Reinitialize i/o since we are starting on a new directory.\n\t */\n\ttif->tif_row = (uint32) -1;\n\ttif->tif_curstrip = (uint32) -1;\n\ttif->tif_col = (uint32) -1;\n\ttif->tif_curtile = (uint32) -1;\n\ttif->tif_tilesize = (tmsize_t) -1;\n\n\ttif->tif_scanlinesize = TIFFScanlineSize(tif);\n\tif (!tif->tif_scanlinesize) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Cannot handle zero scanline size\");\n\t\treturn (0);\n\t}\n\n\tif (isTiled(tif)) {\n\t\ttif->tif_tilesize = TIFFTileSize(tif);\n\t\tif (!tif->tif_tilesize) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Cannot handle zero tile size\");\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\tif (!TIFFStripSize(tif)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Cannot handle zero strip size\");\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (1);\nbad:\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn (0);\n}",
        "begin_line": 3398,
        "end_line": 4093,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirectoryCheckOrder#4095",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirectoryCheckOrder(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)",
        "snippet": "static void\nTIFFReadDirectoryCheckOrder(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)\n{\n\tstatic const char module[] = \"TIFFReadDirectoryCheckOrder\";\n\tuint16 m;\n\tuint16 n;\n\tTIFFDirEntry* o;\n\tm=0;\n\tfor (n=0, o=dir; n<dircount; n++, o++)\n\t{\n\t\tif (o->tdir_tag<m)\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t    \"Invalid TIFF directory; tags are not sorted in ascending order\");\n\t\t\tbreak;\n\t\t}\n\t\tm=o->tdir_tag+1;\n\t}\n}",
        "begin_line": 4095,
        "end_line": 4113,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirectoryFindEntry#4115",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirectoryFindEntry(TIFF* tif, TIFFDirEntry* dir, uint16 dircount, uint16 tagid)",
        "snippet": "static TIFFDirEntry*\nTIFFReadDirectoryFindEntry(TIFF* tif, TIFFDirEntry* dir, uint16 dircount, uint16 tagid)\n{\n\tTIFFDirEntry* m;\n\tuint16 n;\n\t(void) tif;\n\tfor (m=dir, n=0; n<dircount; m++, n++)\n\t{\n\t\tif (m->tdir_tag==tagid)\n\t\t\treturn(m);\n\t}\n\treturn(0);\n}",
        "begin_line": 4115,
        "end_line": 4127,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirectoryFindFieldInfo#4129",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirectoryFindFieldInfo(TIFF* tif, uint16 tagid, uint32* fii)",
        "snippet": "static void\nTIFFReadDirectoryFindFieldInfo(TIFF* tif, uint16 tagid, uint32* fii)\n{\n\tint32 ma,mb,mc;\n\tma=-1;\n\tmc=(int32)tif->tif_nfields;\n\twhile (1)\n\t{\n\t\tif (ma+1==mc)\n\t\t{\n\t\t\t*fii = FAILED_FII;\n\t\t\treturn;\n\t\t}\n\t\tmb=(ma+mc)/2;\n\t\tif (tif->tif_fields[mb]->field_tag==(uint32)tagid)\n\t\t\tbreak;\n\t\tif (tif->tif_fields[mb]->field_tag<(uint32)tagid)\n\t\t\tma=mb;\n\t\telse\n\t\t\tmc=mb;\n\t}\n\twhile (1)\n\t{\n\t\tif (mb==0)\n\t\t\tbreak;\n\t\tif (tif->tif_fields[mb-1]->field_tag!=(uint32)tagid)\n\t\t\tbreak;\n\t\tmb--;\n\t}\n\t*fii=mb;\n}",
        "begin_line": 4129,
        "end_line": 4159,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadUInt64#183",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadUInt64(const uint8 *value)",
        "snippet": "static uint64 TIFFReadUInt64(const uint8 *value)\n{\n\tUInt64Aligned_t result;\n\n\tresult.c[0]=value[0];\n\tresult.c[1]=value[1];\n\tresult.c[2]=value[2];\n\tresult.c[3]=value[3];\n\tresult.c[4]=value[4];\n\tresult.c[5]=value[5];\n\tresult.c[6]=value[6];\n\tresult.c[7]=value[7];\n\n\treturn result.l;\n}",
        "begin_line": 183,
        "end_line": 197,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread._TIFFFillStriles#5584",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread._TIFFFillStriles( TIFF *tif )",
        "snippet": "int _TIFFFillStriles( TIFF *tif )\n{\n    return _TIFFFillStrilesInternal( tif, 1 );\n}",
        "begin_line": 5584,
        "end_line": 5587,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread._TIFFFillStrilesInternal#5589",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread._TIFFFillStrilesInternal( TIFF *tif, int loadStripByteCount )",
        "snippet": "static int _TIFFFillStrilesInternal( TIFF *tif, int loadStripByteCount )\n{\n#if defined(DEFER_STRILE_LOAD)\n        register TIFFDirectory *td = &tif->tif_dir;\n        int return_value = 1;\n\n        if( td->td_stripoffset != NULL )\n                return 1;\n\n        if( td->td_stripoffset_entry.tdir_count == 0 )\n                return 0;\n\n        if (!TIFFFetchStripThing(tif,&(td->td_stripoffset_entry),\n                                 td->td_nstrips,&td->td_stripoffset))\n        {\n                return_value = 0;\n        }\n\n        if (loadStripByteCount &&\n            !TIFFFetchStripThing(tif,&(td->td_stripbytecount_entry),\n                                 td->td_nstrips,&td->td_stripbytecount))\n        {\n                return_value = 0;\n        }\n\n        _TIFFmemset( &(td->td_stripoffset_entry), 0, sizeof(TIFFDirEntry));\n        _TIFFmemset( &(td->td_stripbytecount_entry), 0, sizeof(TIFFDirEntry));\n\n\tif (tif->tif_dir.td_nstrips > 1 && return_value == 1 ) {\n\t\tuint32 strip;\n\n\t\ttif->tif_dir.td_stripbytecountsorted = 1;\n\t\tfor (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {\n\t\t\tif (tif->tif_dir.td_stripoffset[strip - 1] >\n\t\t\t    tif->tif_dir.td_stripoffset[strip]) {\n\t\t\t\ttif->tif_dir.td_stripbytecountsorted = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n        return return_value;\n#else /* !defined(DEFER_STRILE_LOAD) */\n        (void) tif;\n        (void) loadStripByteCount;\n        return 1;\n#endif \n}",
        "begin_line": 5589,
        "end_line": 5636,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dumpmode.TIFFInitDumpMode#123",
        "src_path": "libtiff/tif_dumpmode.c",
        "class_name": "libtiff.tif_dumpmode",
        "signature": "libtiff.tif_dumpmode.TIFFInitDumpMode(TIFF* tif, int scheme)",
        "snippet": "int\nTIFFInitDumpMode(TIFF* tif, int scheme)\n{\n\t(void) scheme;\n\ttif->tif_fixuptags = DumpFixupTags;  \n\ttif->tif_decoderow = DumpModeDecode;\n\ttif->tif_decodestrip = DumpModeDecode;\n\ttif->tif_decodetile = DumpModeDecode;\n\ttif->tif_encoderow = DumpModeEncode;\n\ttif->tif_encodestrip = DumpModeEncode;\n\ttif->tif_encodetile = DumpModeEncode; \n\ttif->tif_seek = DumpModeSeek;\n\treturn (1);\n}",
        "begin_line": 123,
        "end_line": 136,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_ojpeg.OJPEGDecode#784",
        "src_path": "libtiff/tif_ojpeg.c",
        "class_name": "libtiff.tif_ojpeg",
        "signature": "libtiff.tif_ojpeg.OJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)",
        "snippet": "static int\nOJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\t(void)s;\n\tif (sp->libjpeg_jpeg_query_style==0)\n\t{\n\t\tif (OJPEGDecodeRaw(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\telse\n\t{\n\t\tif (OJPEGDecodeScanlines(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\treturn(1);\n}",
        "begin_line": 784,
        "end_line": 800,
        "is_bug": true
    },
    {
        "name": "libtiff.tif_ojpeg.OJPEGDecodeRaw#802",
        "src_path": "libtiff/tif_ojpeg.c",
        "class_name": "libtiff.tif_ojpeg",
        "signature": "libtiff.tif_ojpeg.OJPEGDecodeRaw(TIFF* tif, uint8* buf, tmsize_t cc)",
        "snippet": "static int\nOJPEGDecodeRaw(TIFF* tif, uint8* buf, tmsize_t cc)\n{\n\tstatic const char module[]=\"OJPEGDecodeRaw\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8* m;\n\ttmsize_t n;\n\tuint8* oy;\n\tuint8* ocb;\n\tuint8* ocr;\n\tuint8* p;\n\tuint32 q;\n\tuint8* r;\n\tuint8 sx,sy;\n\tif (cc%sp->bytes_per_line!=0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Fractional scanline not read\");\n\t\treturn(0);\n\t}\n\tassert(cc>0);\n\tm=buf;\n\tn=cc;\n\tdo\n\t{\n\t\tif (sp->subsampling_convert_state==0)\n\t\t{\n\t\t\tif (jpeg_read_raw_data_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),sp->subsampling_convert_ycbcrimage,sp->subsampling_ver*8)==0)\n\t\t\t\treturn(0);\n\t\t}\n\t\toy=sp->subsampling_convert_ybuf+sp->subsampling_convert_state*sp->subsampling_ver*sp->subsampling_convert_ylinelen;\n\t\tocb=sp->subsampling_convert_cbbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen;\n\t\tocr=sp->subsampling_convert_crbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen;\n\t\tp=m;\n\t\tfor (q=0; q<sp->subsampling_convert_clinelenout; q++)\n\t\t{\n\t\t\tr=oy;\n\t\t\tfor (sy=0; sy<sp->subsampling_ver; sy++)\n\t\t\t{\n\t\t\t\tfor (sx=0; sx<sp->subsampling_hor; sx++)\n\t\t\t\t\t*p++=*r++;\n\t\t\t\tr+=sp->subsampling_convert_ylinelen-sp->subsampling_hor;\n\t\t\t}\n\t\t\toy+=sp->subsampling_hor;\n\t\t\t*p++=*ocb++;\n\t\t\t*p++=*ocr++;\n\t\t}\n\t\tsp->subsampling_convert_state++;\n\t\tif (sp->subsampling_convert_state==sp->subsampling_convert_clines)\n\t\t\tsp->subsampling_convert_state=0;\n\t\tm+=sp->bytes_per_line;\n\t\tn-=sp->bytes_per_line;\n\t} while(n>0);\n\treturn(1);\n}",
        "begin_line": 802,
        "end_line": 855,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_ojpeg.OJPEGFixupTags#650",
        "src_path": "libtiff/tif_ojpeg.c",
        "class_name": "libtiff.tif_ojpeg",
        "signature": "libtiff.tif_ojpeg.OJPEGFixupTags(TIFF* tif)",
        "snippet": "static int\nOJPEGFixupTags(TIFF* tif)\n{\n\t(void) tif;\n\treturn(1);\n}",
        "begin_line": 650,
        "end_line": 655,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_ojpeg.OJPEGPreDecode#665",
        "src_path": "libtiff/tif_ojpeg.c",
        "class_name": "libtiff.tif_ojpeg",
        "signature": "libtiff.tif_ojpeg.OJPEGPreDecode(TIFF* tif, uint16 s)",
        "snippet": "static int\nOJPEGPreDecode(TIFF* tif, uint16 s)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint32 m;\n\tif (sp->subsamplingcorrect_done==0)\n\t\tOJPEGSubsamplingCorrect(tif);\n\tif (sp->readheader_done==0)\n\t{\n\t\tif (OJPEGReadHeaderInfo(tif)==0)\n\t\t\treturn(0);\n\t}\n\tif (sp->sos_end[s].log==0)\n\t{\n\t\tif (OJPEGReadSecondarySos(tif,s)==0)\n\t\t\treturn(0);\n\t}\n\tif isTiled(tif)\n\t\tm=tif->tif_curtile;\n\telse\n\t\tm=tif->tif_curstrip;\n\tif ((sp->writeheader_done!=0) && ((sp->write_cursample!=s) || (sp->write_curstrile>m)))\n\t{\n\t\tif (sp->libjpeg_session_active!=0)\n\t\t\tOJPEGLibjpegSessionAbort(tif);\n\t\tsp->writeheader_done=0;\n\t}\n\tif (sp->writeheader_done==0)\n\t{\n\t\tsp->plane_sample_offset=(uint8)s;\n\t\tsp->write_cursample=s;\n\t\tsp->write_curstrile=s*tif->tif_dir.td_stripsperimage;\n\t\tif ((sp->in_buffer_file_pos_log==0) ||\n\t\t    (sp->in_buffer_file_pos-sp->in_buffer_togo!=sp->sos_end[s].in_buffer_file_pos))\n\t\t{\n\t\t\tsp->in_buffer_source=sp->sos_end[s].in_buffer_source;\n\t\t\tsp->in_buffer_next_strile=sp->sos_end[s].in_buffer_next_strile;\n\t\t\tsp->in_buffer_file_pos=sp->sos_end[s].in_buffer_file_pos;\n\t\t\tsp->in_buffer_file_pos_log=0;\n\t\t\tsp->in_buffer_file_togo=sp->sos_end[s].in_buffer_file_togo;\n\t\t\tsp->in_buffer_togo=0;\n\t\t\tsp->in_buffer_cur=0;\n\t\t}\n\t\tif (OJPEGWriteHeaderInfo(tif)==0)\n\t\t\treturn(0);\n\t}\n\twhile (sp->write_curstrile<m)          \n\t{\n\t\tif (sp->libjpeg_jpeg_query_style==0)\n\t\t{\n\t\t\tif (OJPEGPreDecodeSkipRaw(tif)==0)\n\t\t\t\treturn(0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (OJPEGPreDecodeSkipScanlines(tif)==0)\n\t\t\t\treturn(0);\n\t\t}\n\t\tsp->write_curstrile++;\n\t}\n\treturn(1);\n}",
        "begin_line": 665,
        "end_line": 726,
        "is_bug": true
    },
    {
        "name": "libtiff.tif_ojpeg.OJPEGReadBufferFill#1923",
        "src_path": "libtiff/tif_ojpeg.c",
        "class_name": "libtiff.tif_ojpeg",
        "signature": "libtiff.tif_ojpeg.OJPEGReadBufferFill(OJPEGState* sp)",
        "snippet": "static int\nOJPEGReadBufferFill(OJPEGState* sp)\n{\n\tuint16 m;\n\ttmsize_t n;\n\t/* TODO: double-check: when subsamplingcorrect is set, no call to TIFFErrorExt or TIFFWarningExt should be made\n\t * in any other case, seek or read errors should be passed through */\n\tdo\n\t{\n\t\tif (sp->in_buffer_file_togo!=0)\n\t\t{\n\t\t\tif (sp->in_buffer_file_pos_log==0)\n\t\t\t{\n\t\t\t\tTIFFSeekFile(sp->tif,sp->in_buffer_file_pos,SEEK_SET);\n\t\t\t\tsp->in_buffer_file_pos_log=1;\n\t\t\t}\n\t\t\tm=OJPEG_BUFFER;\n\t\t\tif ((uint64)m>sp->in_buffer_file_togo)\n\t\t\t\tm=(uint16)sp->in_buffer_file_togo;\n\t\t\tn=TIFFReadFile(sp->tif,sp->in_buffer,(tmsize_t)m);\n\t\t\tif (n==0)\n\t\t\t\treturn(0);\n\t\t\tassert(n>0);\n\t\t\tassert(n<=OJPEG_BUFFER);\n\t\t\tassert(n<65536);\n\t\t\tassert((uint64)n<=sp->in_buffer_file_togo);\n\t\t\tm=(uint16)n;\n\t\t\tsp->in_buffer_togo=m;\n\t\t\tsp->in_buffer_cur=sp->in_buffer;\n\t\t\tsp->in_buffer_file_togo-=m;\n\t\t\tsp->in_buffer_file_pos+=m;\n\t\t\tbreak;\n\t\t}\n\t\tsp->in_buffer_file_pos_log=0;\n\t\tswitch(sp->in_buffer_source)\n\t\t{\n\t\t\tcase osibsNotSetYet:\n\t\t\t\tif (sp->jpeg_interchange_format!=0)\n\t\t\t\t{\n\t\t\t\t\tsp->in_buffer_file_pos=sp->jpeg_interchange_format;\n\t\t\t\t\tsp->in_buffer_file_togo=sp->jpeg_interchange_format_length;\n\t\t\t\t}\n\t\t\t\tsp->in_buffer_source=osibsJpegInterchangeFormat;\n\t\t\t\tbreak;\n\t\t\tcase osibsJpegInterchangeFormat:\n\t\t\t\tsp->in_buffer_source=osibsStrile;\n                                break;\n\t\t\tcase osibsStrile:\n\t\t\t\tif (!_TIFFFillStriles( sp->tif ) \n\t\t\t\t    || sp->tif->tif_dir.td_stripoffset == NULL\n\t\t\t\t    || sp->tif->tif_dir.td_stripbytecount == NULL)\n\t\t\t\t\treturn 0;\n\n\t\t\t\tif (sp->in_buffer_next_strile==sp->in_buffer_strile_count)\n\t\t\t\t\tsp->in_buffer_source=osibsEof;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsp->in_buffer_file_pos=sp->tif->tif_dir.td_stripoffset[sp->in_buffer_next_strile];\n\t\t\t\t\tif (sp->in_buffer_file_pos!=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (sp->in_buffer_file_pos>=sp->file_size)\n\t\t\t\t\t\t\tsp->in_buffer_file_pos=0;\n\t\t\t\t\t\telse if (sp->tif->tif_dir.td_stripbytecount==NULL)\n\t\t\t\t\t\t\tsp->in_buffer_file_togo=sp->file_size-sp->in_buffer_file_pos;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (sp->tif->tif_dir.td_stripbytecount == 0) {\n\t\t\t\t\t\t\t\tTIFFErrorExt(sp->tif->tif_clientdata,sp->tif->tif_name,\"Strip byte counts are missing\");\n\t\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsp->in_buffer_file_togo=sp->tif->tif_dir.td_stripbytecount[sp->in_buffer_next_strile];\n\t\t\t\t\t\t\tif (sp->in_buffer_file_togo==0)\n\t\t\t\t\t\t\t\tsp->in_buffer_file_pos=0;\n\t\t\t\t\t\t\telse if (sp->in_buffer_file_pos+sp->in_buffer_file_togo>sp->file_size)\n\t\t\t\t\t\t\t\tsp->in_buffer_file_togo=sp->file_size-sp->in_buffer_file_pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsp->in_buffer_next_strile++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn(0);\n\t\t}\n\t} while (1);\n\treturn(1);\n}",
        "begin_line": 1923,
        "end_line": 2008,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_ojpeg.OJPEGReadBytePeek#2025",
        "src_path": "libtiff/tif_ojpeg.c",
        "class_name": "libtiff.tif_ojpeg",
        "signature": "libtiff.tif_ojpeg.OJPEGReadBytePeek(OJPEGState* sp, uint8* byte)",
        "snippet": "static int\nOJPEGReadBytePeek(OJPEGState* sp, uint8* byte)\n{\n\tif (sp->in_buffer_togo==0)\n\t{\n\t\tif (OJPEGReadBufferFill(sp)==0)\n\t\t\treturn(0);\n\t\tassert(sp->in_buffer_togo>0);\n\t}\n\t*byte=*(sp->in_buffer_cur);\n\treturn(1);\n}",
        "begin_line": 2025,
        "end_line": 2036,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_ojpeg.OJPEGReadHeaderInfo#1035",
        "src_path": "libtiff/tif_ojpeg.c",
        "class_name": "libtiff.tif_ojpeg",
        "signature": "libtiff.tif_ojpeg.OJPEGReadHeaderInfo(TIFF* tif)",
        "snippet": "static int\nOJPEGReadHeaderInfo(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGReadHeaderInfo\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tassert(sp->readheader_done==0);\n\tsp->image_width=tif->tif_dir.td_imagewidth;\n\tsp->image_length=tif->tif_dir.td_imagelength;\n\tif isTiled(tif)\n\t{\n\t\tsp->strile_width=tif->tif_dir.td_tilewidth;\n\t\tsp->strile_length=tif->tif_dir.td_tilelength;\n\t\tsp->strile_length_total=((sp->image_length+sp->strile_length-1)/sp->strile_length)*sp->strile_length;\n\t}\n\telse\n\t{\n\t\tsp->strile_width=sp->image_width;\n\t\tsp->strile_length=tif->tif_dir.td_rowsperstrip;\n\t\tsp->strile_length_total=sp->image_length;\n\t}\n\tif (tif->tif_dir.td_samplesperpixel==1)\n\t{\n\t\tsp->samples_per_pixel=1;\n\t\tsp->plane_sample_offset=0;\n\t\tsp->samples_per_pixel_per_plane=sp->samples_per_pixel;\n\t\tsp->subsampling_hor=1;\n\t\tsp->subsampling_ver=1;\n\t}\n\telse\n\t{\n\t\tif (tif->tif_dir.td_samplesperpixel!=3)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"SamplesPerPixel %d not supported for this compression scheme\",sp->samples_per_pixel);\n\t\t\treturn(0);\n\t\t}\n\t\tsp->samples_per_pixel=3;\n\t\tsp->plane_sample_offset=0;\n\t\tif (tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)\n\t\t\tsp->samples_per_pixel_per_plane=3;\n\t\telse\n\t\t\tsp->samples_per_pixel_per_plane=1;\n\t}\n\tif (sp->strile_length<sp->image_length)\n\t{\n\t\tif (sp->strile_length%(sp->subsampling_ver*8)!=0)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Incompatible vertical subsampling and image strip/tile length\");\n\t\t\treturn(0);\n\t\t}\n\t\tsp->restart_interval=(uint16)(((sp->strile_width+sp->subsampling_hor*8-1)/(sp->subsampling_hor*8))*(sp->strile_length/(sp->subsampling_ver*8)));\n\t}\n\tif (OJPEGReadHeaderInfoSec(tif)==0)\n\t\treturn(0);\n\tsp->sos_end[0].log=1;\n\tsp->sos_end[0].in_buffer_source=sp->in_buffer_source;\n\tsp->sos_end[0].in_buffer_next_strile=sp->in_buffer_next_strile;\n\tsp->sos_end[0].in_buffer_file_pos=sp->in_buffer_file_pos-sp->in_buffer_togo;\n\tsp->sos_end[0].in_buffer_file_togo=sp->in_buffer_file_togo+sp->in_buffer_togo; \n\tsp->readheader_done=1;\n\treturn(1);\n}",
        "begin_line": 1035,
        "end_line": 1095,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_ojpeg.OJPEGReadHeaderInfoSec#1250",
        "src_path": "libtiff/tif_ojpeg.c",
        "class_name": "libtiff.tif_ojpeg",
        "signature": "libtiff.tif_ojpeg.OJPEGReadHeaderInfoSec(TIFF* tif)",
        "snippet": "static int\nOJPEGReadHeaderInfoSec(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSec\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tuint16 n;\n\tuint8 o;\n\tif (sp->file_size==0)\n\t\tsp->file_size=TIFFGetFileSize(tif);\n\tif (sp->jpeg_interchange_format!=0)\n\t{\n\t\tif (sp->jpeg_interchange_format>=sp->file_size)\n\t\t{\n\t\t\tsp->jpeg_interchange_format=0;\n\t\t\tsp->jpeg_interchange_format_length=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((sp->jpeg_interchange_format_length==0) || (sp->jpeg_interchange_format+sp->jpeg_interchange_format_length>sp->file_size))\n\t\t\t\tsp->jpeg_interchange_format_length=sp->file_size-sp->jpeg_interchange_format;\n\t\t}\n\t}\n\tsp->in_buffer_source=osibsNotSetYet;\n\tsp->in_buffer_next_strile=0;\n\tsp->in_buffer_strile_count=tif->tif_dir.td_nstrips;\n\tsp->in_buffer_file_togo=0;\n\tsp->in_buffer_togo=0;\n\tdo\n\t{\n\t\tif (OJPEGReadBytePeek(sp,&m)==0)\n\t\t\treturn(0);\n\t\tif (m!=255)\n\t\t\tbreak;\n\t\tOJPEGReadByteAdvance(sp);\n\t\tdo\n\t\t{\n\t\t\tif (OJPEGReadByte(sp,&m)==0)\n\t\t\t\treturn(0);\n\t\t} while(m==255);\n\t\tswitch(m)\n\t\t{\n\t\t\tcase JPEG_MARKER_SOI:\n\t\t\t\t/* this type of marker has no data, and should be skipped */\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_COM:\n\t\t\tcase JPEG_MARKER_APP0:\n\t\t\tcase JPEG_MARKER_APP0+1:\n\t\t\tcase JPEG_MARKER_APP0+2:\n\t\t\tcase JPEG_MARKER_APP0+3:\n\t\t\tcase JPEG_MARKER_APP0+4:\n\t\t\tcase JPEG_MARKER_APP0+5:\n\t\t\tcase JPEG_MARKER_APP0+6:\n\t\t\tcase JPEG_MARKER_APP0+7:\n\t\t\tcase JPEG_MARKER_APP0+8:\n\t\t\tcase JPEG_MARKER_APP0+9:\n\t\t\tcase JPEG_MARKER_APP0+10:\n\t\t\tcase JPEG_MARKER_APP0+11:\n\t\t\tcase JPEG_MARKER_APP0+12:\n\t\t\tcase JPEG_MARKER_APP0+13:\n\t\t\tcase JPEG_MARKER_APP0+14:\n\t\t\tcase JPEG_MARKER_APP0+15:\n\t\t\t\t/* this type of marker has data, but it has no use to us (and no place here) and should be skipped */\n\t\t\t\tif (OJPEGReadWord(sp,&n)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tif (n<2)\n\t\t\t\t{\n\t\t\t\t\tif (sp->subsamplingcorrect==0)\n\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt JPEG data\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tif (n>2)\n\t\t\t\t\tOJPEGReadSkip(sp,n-2);\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_DRI:\n\t\t\t\tif (OJPEGReadHeaderInfoSecStreamDri(tif)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_DQT:\n\t\t\t\tif (OJPEGReadHeaderInfoSecStreamDqt(tif)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_DHT:\n\t\t\t\tif (OJPEGReadHeaderInfoSecStreamDht(tif)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_SOF0:\n\t\t\tcase JPEG_MARKER_SOF1:\n\t\t\tcase JPEG_MARKER_SOF3:\n\t\t\t\tif (OJPEGReadHeaderInfoSecStreamSof(tif,m)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tif (sp->subsamplingcorrect!=0)\n\t\t\t\t\treturn(1);\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_SOS:\n\t\t\t\tif (sp->subsamplingcorrect!=0)\n\t\t\t\t\treturn(1);\n\t\t\t\tassert(sp->plane_sample_offset==0);\n\t\t\t\tif (OJPEGReadHeaderInfoSecStreamSos(tif)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Unknown marker type %d in JPEG data\",m);\n\t\t\t\treturn(0);\n\t\t}\n\t} while(m!=JPEG_MARKER_SOS);\n\tif (sp->subsamplingcorrect)\n\t\treturn(1);\n\tif (sp->sof_log==0)\n\t{\n\t\tif (OJPEGReadHeaderInfoSecTablesQTable(tif)==0)\n\t\t\treturn(0);\n\t\tsp->sof_marker_id=JPEG_MARKER_SOF0;\n\t\tfor (o=0; o<sp->samples_per_pixel; o++)\n\t\t\tsp->sof_c[o]=o;\n\t\tsp->sof_hv[0]=((sp->subsampling_hor<<4)|sp->subsampling_ver);\n\t\tfor (o=1; o<sp->samples_per_pixel; o++)\n\t\t\tsp->sof_hv[o]=17;\n\t\tsp->sof_x=sp->strile_width;\n\t\tsp->sof_y=sp->strile_length_total;\n\t\tsp->sof_log=1;\n\t\tif (OJPEGReadHeaderInfoSecTablesDcTable(tif)==0)\n\t\t\treturn(0);\n\t\tif (OJPEGReadHeaderInfoSecTablesAcTable(tif)==0)\n\t\t\treturn(0);\n\t\tfor (o=1; o<sp->samples_per_pixel; o++)\n\t\t\tsp->sos_cs[o]=o;\n\t}\n\treturn(1);\n}",
        "begin_line": 1250,
        "end_line": 1379,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_ojpeg.OJPEGSetupDecode#657",
        "src_path": "libtiff/tif_ojpeg.c",
        "class_name": "libtiff.tif_ojpeg",
        "signature": "libtiff.tif_ojpeg.OJPEGSetupDecode(TIFF* tif)",
        "snippet": "static int\nOJPEGSetupDecode(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGSetupDecode\";\n\tTIFFWarningExt(tif->tif_clientdata,module,\"Depreciated and troublesome old-style JPEG compression mode, please convert to new-style JPEG compression and notify vendor of writing software\");\n\treturn(1);\n}",
        "begin_line": 657,
        "end_line": 663,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_ojpeg.OJPEGSubsamplingCorrect#980",
        "src_path": "libtiff/tif_ojpeg.c",
        "class_name": "libtiff.tif_ojpeg",
        "signature": "libtiff.tif_ojpeg.OJPEGSubsamplingCorrect(TIFF* tif)",
        "snippet": "static void\nOJPEGSubsamplingCorrect(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGSubsamplingCorrect\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 mh;\n\tuint8 mv;\n        _TIFFFillStriles( tif );\n        \n\tassert(sp->subsamplingcorrect_done==0);\n\tif ((tif->tif_dir.td_samplesperpixel!=3) || ((tif->tif_dir.td_photometric!=PHOTOMETRIC_YCBCR) &&\n\t    (tif->tif_dir.td_photometric!=PHOTOMETRIC_ITULAB)))\n\t{\n\t\tif (sp->subsampling_tag!=0)\n\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling tag not appropriate for this Photometric and/or SamplesPerPixel\");\n\t\tsp->subsampling_hor=1;\n\t\tsp->subsampling_ver=1;\n\t\tsp->subsampling_force_desubsampling_inside_decompression=0;\n\t}\n\telse\n\t{\n\t\tsp->subsamplingcorrect_done=1;\n\t\tmh=sp->subsampling_hor;\n\t\tmv=sp->subsampling_ver;\n\t\tsp->subsamplingcorrect=1;\n\t\tOJPEGReadHeaderInfoSec(tif);\n\t\tif (sp->subsampling_force_desubsampling_inside_decompression!=0)\n\t\t{\n\t\t\tsp->subsampling_hor=1;\n\t\t\tsp->subsampling_ver=1;\n\t\t}\n\t\tsp->subsamplingcorrect=0;\n\t\tif (((sp->subsampling_hor!=mh) || (sp->subsampling_ver!=mv)) && (sp->subsampling_force_desubsampling_inside_decompression==0))\n\t\t{\n\t\t\tif (sp->subsampling_tag==0)\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling tag is not set, yet subsampling inside JPEG data [%d,%d] does not match default values [2,2]; assuming subsampling inside JPEG data is correct\",sp->subsampling_hor,sp->subsampling_ver);\n\t\t\telse\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling inside JPEG data [%d,%d] does not match subsampling tag values [%d,%d]; assuming subsampling inside JPEG data is correct\",sp->subsampling_hor,sp->subsampling_ver,mh,mv);\n\t\t}\n\t\tif (sp->subsampling_force_desubsampling_inside_decompression!=0)\n\t\t{\n\t\t\tif (sp->subsampling_tag==0)\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling tag is not set, yet subsampling inside JPEG data does not match default values [2,2] (nor any other values allowed in TIFF); assuming subsampling inside JPEG data is correct and desubsampling inside JPEG decompression\");\n\t\t\telse\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling inside JPEG data does not match subsampling tag values [%d,%d] (nor any other values allowed in TIFF); assuming subsampling inside JPEG data is correct and desubsampling inside JPEG decompression\",mh,mv);\n\t\t}\n\t\tif (sp->subsampling_force_desubsampling_inside_decompression==0)\n\t\t{\n\t\t\tif (sp->subsampling_hor<sp->subsampling_ver)\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling values [%d,%d] are not allowed in TIFF\",sp->subsampling_hor,sp->subsampling_ver);\n\t\t}\n\t}\n\tsp->subsamplingcorrect_done=1;\n}",
        "begin_line": 980,
        "end_line": 1033,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_ojpeg.OJPEGVGetField#481",
        "src_path": "libtiff/tif_ojpeg.c",
        "class_name": "libtiff.tif_ojpeg",
        "signature": "libtiff.tif_ojpeg.OJPEGVGetField(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "static int\nOJPEGVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tswitch(tag)\n\t{\n\t\tcase TIFFTAG_JPEGIFOFFSET:\n\t\t\t*va_arg(ap,uint64*)=(uint64)sp->jpeg_interchange_format;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGIFBYTECOUNT:\n\t\t\t*va_arg(ap,uint64*)=(uint64)sp->jpeg_interchange_format_length;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t\tif (sp->subsamplingcorrect_done==0)\n\t\t\t\tOJPEGSubsamplingCorrect(tif);\n\t\t\t*va_arg(ap,uint16*)=(uint16)sp->subsampling_hor;\n\t\t\t*va_arg(ap,uint16*)=(uint16)sp->subsampling_ver;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGQTABLES:\n\t\t\t*va_arg(ap,uint32*)=(uint32)sp->qtable_offset_count;\n\t\t\t*va_arg(ap,void**)=(void*)sp->qtable_offset; \n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGDCTABLES:\n\t\t\t*va_arg(ap,uint32*)=(uint32)sp->dctable_offset_count;\n\t\t\t*va_arg(ap,void**)=(void*)sp->dctable_offset;  \n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGACTABLES:\n\t\t\t*va_arg(ap,uint32*)=(uint32)sp->actable_offset_count;\n\t\t\t*va_arg(ap,void**)=(void*)sp->actable_offset;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGPROC:\n\t\t\t*va_arg(ap,uint16*)=(uint16)sp->jpeg_proc;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGRESTARTINTERVAL:\n\t\t\t*va_arg(ap,uint16*)=sp->restart_interval;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (*sp->vgetparent)(tif,tag,ap);\n\t}\n\treturn (1);\n}",
        "begin_line": 481,
        "end_line": 521,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_ojpeg.OJPEGVSetField#523",
        "src_path": "libtiff/tif_ojpeg.c",
        "class_name": "libtiff.tif_ojpeg",
        "signature": "libtiff.tif_ojpeg.OJPEGVSetField(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "static int\nOJPEGVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tstatic const char module[]=\"OJPEGVSetField\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint32 ma;\n\tuint64* mb;\n\tuint32 n;\n\tconst TIFFField* fip;\n\n\tswitch(tag)\n\t{\n\t\tcase TIFFTAG_JPEGIFOFFSET:\n\t\t\tsp->jpeg_interchange_format=(uint64)va_arg(ap,uint64);\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGIFBYTECOUNT:\n\t\t\tsp->jpeg_interchange_format_length=(uint64)va_arg(ap,uint64);\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t\tsp->subsampling_tag=1;\n\t\t\tsp->subsampling_hor=(uint8)va_arg(ap,uint16_vap);\n\t\t\tsp->subsampling_ver=(uint8)va_arg(ap,uint16_vap);\n\t\t\ttif->tif_dir.td_ycbcrsubsampling[0]=sp->subsampling_hor;\n\t\t\ttif->tif_dir.td_ycbcrsubsampling[1]=sp->subsampling_ver;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGQTABLES:\n\t\t\tma=(uint32)va_arg(ap,uint32);\n\t\t\tif (ma!=0)\n\t\t\t{\n\t\t\t\tif (ma>3)\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JpegQTables tag has incorrect count\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsp->qtable_offset_count=(uint8)ma;\n\t\t\t\tmb=(uint64*)va_arg(ap,uint64*);\n\t\t\t\tfor (n=0; n<ma; n++)\n\t\t\t\t\tsp->qtable_offset[n]=mb[n];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGDCTABLES:\n\t\t\tma=(uint32)va_arg(ap,uint32);\n\t\t\tif (ma!=0)\n\t\t\t{\n\t\t\t\tif (ma>3)\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JpegDcTables tag has incorrect count\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsp->dctable_offset_count=(uint8)ma;\n\t\t\t\tmb=(uint64*)va_arg(ap,uint64*);\n\t\t\t\tfor (n=0; n<ma; n++)\n\t\t\t\t\tsp->dctable_offset[n]=mb[n];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGACTABLES:\n\t\t\tma=(uint32)va_arg(ap,uint32);\n\t\t\tif (ma!=0)\n\t\t\t{\n\t\t\t\tif (ma>3)\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JpegAcTables tag has incorrect count\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsp->actable_offset_count=(uint8)ma;\n\t\t\t\tmb=(uint64*)va_arg(ap,uint64*);\n\t\t\t\tfor (n=0; n<ma; n++)\n\t\t\t\t\tsp->actable_offset[n]=mb[n];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGPROC:\n\t\t\tsp->jpeg_proc=(uint8)va_arg(ap,uint16_vap);\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGRESTARTINTERVAL:\n\t\t\tsp->restart_interval=(uint16)va_arg(ap,uint16_vap);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (*sp->vsetparent)(tif,tag,ap);\n\t}\n\tfip = TIFFFieldWithTag(tif,tag);\n\tif( fip == NULL ) /* shouldn't happen */\n\t    return(0);\n\tTIFFSetFieldBit(tif,fip->field_bit);\n\ttif->tif_flags|=TIFF_DIRTYDIRECT;\n\treturn(1);\n}",
        "begin_line": 523,
        "end_line": 608,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_ojpeg.TIFFInitOJPEG#418",
        "src_path": "libtiff/tif_ojpeg.c",
        "class_name": "libtiff.tif_ojpeg",
        "signature": "libtiff.tif_ojpeg.TIFFInitOJPEG(TIFF* tif, int scheme)",
        "snippet": "int\nTIFFInitOJPEG(TIFF* tif, int scheme)\n{\n\tstatic const char module[]=\"TIFFInitOJPEG\";\n\tOJPEGState* sp;\n\n\tassert(scheme==COMPRESSION_OJPEG);\n\n        /*\n\t * Merge codec-specific tag information.\n\t */\n\tif (!_TIFFMergeFields(tif, ojpegFields, TIFFArrayCount(ojpegFields))) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Merging Old JPEG codec-specific tags failed\");\n\t\treturn 0;\n\t}\n\n\t/* state block */\n\tsp=_TIFFmalloc(sizeof(OJPEGState));\n\tif (sp==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"No space for OJPEG state block\");\n\t\treturn(0);\n\t}\n\t_TIFFmemset(sp,0,sizeof(OJPEGState));\n\tsp->tif=tif;\n\tsp->jpeg_proc=1;\n\tsp->subsampling_hor=2;\n\tsp->subsampling_ver=2;\n\tTIFFSetField(tif,TIFFTAG_YCBCRSUBSAMPLING,2,2);\n\t/* tif codec methods */\n\ttif->tif_fixuptags=OJPEGFixupTags;  \n\ttif->tif_setupdecode=OJPEGSetupDecode;\n\ttif->tif_predecode=OJPEGPreDecode;\n\ttif->tif_postdecode=OJPEGPostDecode;  \n\ttif->tif_decoderow=OJPEGDecode;  \n\ttif->tif_decodestrip=OJPEGDecode;  \n\ttif->tif_decodetile=OJPEGDecode;  \n\ttif->tif_setupencode=OJPEGSetupEncode;\n\ttif->tif_preencode=OJPEGPreEncode;\n\ttif->tif_postencode=OJPEGPostEncode;\n\ttif->tif_encoderow=OJPEGEncode;  \n\ttif->tif_encodestrip=OJPEGEncode;  \n\ttif->tif_encodetile=OJPEGEncode;  \n\ttif->tif_cleanup=OJPEGCleanup;\n\ttif->tif_data=(uint8*)sp;\n\t/* tif tag methods */\n\tsp->vgetparent=tif->tif_tagmethods.vgetfield;\n\ttif->tif_tagmethods.vgetfield=OJPEGVGetField;\n\tsp->vsetparent=tif->tif_tagmethods.vsetfield;\n\ttif->tif_tagmethods.vsetfield=OJPEGVSetField;\n\tsp->printdir=tif->tif_tagmethods.printdir;\n\ttif->tif_tagmethods.printdir=OJPEGPrintDir;\n\t/* Some OJPEG files don't have strip or tile offsets or bytecounts tags.\n\t   Some others do, but have totally meaningless or corrupt values\n\t   in these tags. In these cases, the JpegInterchangeFormat stream is\n\t   reliable. In any case, this decoder reads the compressed data itself,\n\t   from the most reliable locations, and we need to notify encapsulating\n\t   LibTiff not to read raw strips or tiles for us. */\n\ttif->tif_flags|=TIFF_NOREADRAW;\n\treturn(1);\n}",
        "begin_line": 418,
        "end_line": 479,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_open.TIFFClientOpen#72",
        "src_path": "libtiff/tif_open.c",
        "class_name": "libtiff.tif_open",
        "signature": "libtiff.tif_open.TIFFClientOpen( \tconst char* name, const char* mode, thandle_t clientdata, TIFFReadWriteProc readproc, TIFFReadWriteProc writeproc, TIFFSeekProc seekproc, TIFFCloseProc closeproc, TIFFSizeProc sizeproc, TIFFMapFileProc mapproc, TIFFUnmapFileProc unmapproc )",
        "snippet": "TIFF*\nTIFFClientOpen(\n\tconst char* name, const char* mode,\n\tthandle_t clientdata,\n\tTIFFReadWriteProc readproc,\n\tTIFFReadWriteProc writeproc,\n\tTIFFSeekProc seekproc,\n\tTIFFCloseProc closeproc,\n\tTIFFSizeProc sizeproc,\n\tTIFFMapFileProc mapproc,\n\tTIFFUnmapFileProc unmapproc\n)\n{\n\tstatic const char module[] = \"TIFFClientOpen\";\n\tTIFF *tif;\n\tint m;\n\tconst char* cp;\n\n\t/* The following are configuration checks. They should be redundant, but should not\n\t * compile to any actual code in an optimised release build anyway. If any of them\n\t * fail, (makefile-based or other) configuration is not correct */\n\tassert(sizeof(uint8)==1);\n\tassert(sizeof(int8)==1);\n\tassert(sizeof(uint16)==2);\n\tassert(sizeof(int16)==2);\n\tassert(sizeof(uint32)==4);\n\tassert(sizeof(int32)==4);\n\tassert(sizeof(uint64)==8);\n\tassert(sizeof(int64)==8);\n\tassert(sizeof(tmsize_t)==sizeof(void*));\n\t{\n\t\tunion{\n\t\t\tuint8 a8[2];\n\t\t\tuint16 a16;\n\t\t} n;\n\t\tn.a8[0]=1;\n\t\tn.a8[1]=0;\n\t\t#ifdef WORDS_BIGENDIAN\n\t\tassert(n.a16==256);\n\t\t#else\n\t\tassert(n.a16==1);\n\t\t#endif\n\t}\n\n\tm = _TIFFgetMode(mode, module);\n\tif (m == -1)\n\t\tgoto bad2;\n\ttif = (TIFF *)_TIFFmalloc((tmsize_t)(sizeof (TIFF) + strlen(name) + 1));\n\tif (tif == NULL) {\n\t\tTIFFErrorExt(clientdata, module, \"%s: Out of memory (TIFF structure)\", name);\n\t\tgoto bad2;\n\t}\n\t_TIFFmemset(tif, 0, sizeof (*tif));\n\ttif->tif_name = (char *)tif + sizeof (TIFF);\n\tstrcpy(tif->tif_name, name);\n\ttif->tif_mode = m &~ (O_CREAT|O_TRUNC);\n\ttif->tif_curdir = (uint16) -1;\t\t/* non-existent directory */\n\ttif->tif_curoff = 0;\n\ttif->tif_curstrip = (uint32) -1;\t/* invalid strip */\n\ttif->tif_row = (uint32) -1;\t\t/* read/write pre-increment */\n\ttif->tif_clientdata = clientdata;\n\tif (!readproc || !writeproc || !seekproc || !closeproc || !sizeproc) {\n\t\tTIFFErrorExt(clientdata, module,\n\t\t    \"One of the client procedures is NULL pointer.\");\n\t\tgoto bad2;\n\t}\n\ttif->tif_readproc = readproc;\n\ttif->tif_writeproc = writeproc;\n\ttif->tif_seekproc = seekproc;\n\ttif->tif_closeproc = closeproc;\n\ttif->tif_sizeproc = sizeproc;\n\tif (mapproc)\n\t\ttif->tif_mapproc = mapproc;\n\telse\n\t\ttif->tif_mapproc = _tiffDummyMapProc;\n\tif (unmapproc)\n\t\ttif->tif_unmapproc = unmapproc;\n\telse\n\t\ttif->tif_unmapproc = _tiffDummyUnmapProc;\n\t_TIFFSetDefaultCompressionState(tif);    /* setup default state */\n\t/*\n\t * Default is to return data MSB2LSB and enable the\n\t * use of memory-mapped files and strip chopping when\n\t * a file is opened read-only.\n\t */\n\ttif->tif_flags = FILLORDER_MSB2LSB;\n\tif (m == O_RDONLY )\n\t\ttif->tif_flags |= TIFF_MAPPED;\n\n\t#ifdef STRIPCHOP_DEFAULT\n\tif (m == O_RDONLY || m == O_RDWR)\n\t\ttif->tif_flags |= STRIPCHOP_DEFAULT;\n\t#endif\n\n\t/*\n\t * Process library-specific flags in the open mode string.\n\t * The following flags may be used to control intrinsic library\n\t * behaviour that may or may not be desirable (usually for\n\t * compatibility with some application that claims to support\n\t * TIFF but only supports some brain dead idea of what the\n\t * vendor thinks TIFF is):\n\t *\n\t * 'l' use little-endian byte order for creating a file\n\t * 'b' use big-endian byte order for creating a file\n\t * 'L' read/write information using LSB2MSB bit order\n\t * 'B' read/write information using MSB2LSB bit order\n\t * 'H' read/write information using host bit order\n\t * 'M' enable use of memory-mapped files when supported\n\t * 'm' disable use of memory-mapped files\n\t * 'C' enable strip chopping support when reading\n\t * 'c' disable strip chopping support\n\t * 'h' read TIFF header only, do not load the first IFD\n\t * '4' ClassicTIFF for creating a file (default)\n\t * '8' BigTIFF for creating a file\n\t *\n\t * The use of the 'l' and 'b' flags is strongly discouraged.\n\t * These flags are provided solely because numerous vendors,\n\t * typically on the PC, do not correctly support TIFF; they\n\t * only support the Intel little-endian byte order.  This\n\t * support is not configured by default because it supports\n\t * the violation of the TIFF spec that says that readers *MUST*\n\t * support both byte orders.  It is strongly recommended that\n\t * you not use this feature except to deal with busted apps\n\t * that write invalid TIFF.  And even in those cases you should\n\t * bang on the vendors to fix their software.\n\t *\n\t * The 'L', 'B', and 'H' flags are intended for applications\n\t * that can optimize operations on data by using a particular\n\t * bit order.  By default the library returns data in MSB2LSB\n\t * bit order for compatibility with older versions of this\n\t * library.  Returning data in the bit order of the native CPU\n\t * makes the most sense but also requires applications to check\n\t * the value of the FillOrder tag; something they probably do\n\t * not do right now.\n\t *\n\t * The 'M' and 'm' flags are provided because some virtual memory\n\t * systems exhibit poor behaviour when large images are mapped.\n\t * These options permit clients to control the use of memory-mapped\n\t * files on a per-file basis.\n\t *\n\t * The 'C' and 'c' flags are provided because the library support\n\t * for chopping up large strips into multiple smaller strips is not\n\t * application-transparent and as such can cause problems.  The 'c'\n\t * option permits applications that only want to look at the tags,\n\t * for example, to get the unadulterated TIFF tag information.\n\t */\n\tfor (cp = mode; *cp; cp++)\n\t\tswitch (*cp) {\n\t\t\tcase 'b':\n\t\t\t\t#ifndef WORDS_BIGENDIAN\n\t\t\t\tif (m&O_CREAT)\n\t\t\t\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t\t\t#endif\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\t#ifdef WORDS_BIGENDIAN\n\t\t\t\tif ((m&O_CREAT))\n\t\t\t\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t\t\t#endif\n\t\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\t\ttif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |\n\t\t\t\t    FILLORDER_MSB2LSB;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\ttif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |\n\t\t\t\t    FILLORDER_LSB2MSB;\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\ttif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |\n\t\t\t\t    HOST_FILLORDER;\n\t\t\t\tbreak;\n\t\t\tcase 'M':\n\t\t\t\tif (m == O_RDONLY)\n\t\t\t\t\ttif->tif_flags |= TIFF_MAPPED;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tif (m == O_RDONLY)\n\t\t\t\t\ttif->tif_flags &= ~TIFF_MAPPED;\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tif (m == O_RDONLY)\n\t\t\t\t\ttif->tif_flags |= TIFF_STRIPCHOP;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tif (m == O_RDONLY)\n\t\t\t\t\ttif->tif_flags &= ~TIFF_STRIPCHOP;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\t\ttif->tif_flags |= TIFF_HEADERONLY;\n\t\t\t\tbreak;\n\t\t\tcase '8':\n\t\t\t\tif (m&O_CREAT)\n\t\t\t\t\ttif->tif_flags |= TIFF_BIGTIFF;\n\t\t\t\tbreak;\n\t\t}\n\t/*\n\t * Read in TIFF header.\n\t */\n\tif ((m & O_TRUNC) ||\n\t    !ReadOK(tif, &tif->tif_header, sizeof (TIFFHeaderClassic))) {\n\t\tif (tif->tif_mode == O_RDONLY) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t\t    \"Cannot read TIFF header\");\n\t\t\tgoto bad;\n\t\t}\n\t\t/*\n\t\t * Setup header and write.\n\t\t */\n\t\t#ifdef WORDS_BIGENDIAN\n\t\ttif->tif_header.common.tiff_magic = (tif->tif_flags & TIFF_SWAB)\n\t\t    ? TIFF_LITTLEENDIAN : TIFF_BIGENDIAN;\n\t\t#else\n\t\ttif->tif_header.common.tiff_magic = (tif->tif_flags & TIFF_SWAB)\n\t\t    ? TIFF_BIGENDIAN : TIFF_LITTLEENDIAN;\n\t\t#endif\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\ttif->tif_header.common.tiff_version = TIFF_VERSION_CLASSIC;\n\t\t\ttif->tif_header.classic.tiff_diroff = 0;\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&tif->tif_header.common.tiff_version);\n\t\t\ttif->tif_header_size = sizeof(TIFFHeaderClassic);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttif->tif_header.common.tiff_version = TIFF_VERSION_BIG;\n\t\t\ttif->tif_header.big.tiff_offsetsize = 8;\n\t\t\ttif->tif_header.big.tiff_unused = 0;\n\t\t\ttif->tif_header.big.tiff_diroff = 0;\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t{\n\t\t\t\tTIFFSwabShort(&tif->tif_header.common.tiff_version);\n\t\t\t\tTIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);\n\t\t\t}\n\t\t\ttif->tif_header_size = sizeof (TIFFHeaderBig);\n\t\t}\n\t\t/*\n\t\t * The doc for \"fopen\" for some STD_C_LIBs says that if you\n\t\t * open a file for modify (\"+\"), then you must fseek (or\n\t\t * fflush?) between any freads and fwrites.  This is not\n\t\t * necessary on most systems, but has been shown to be needed\n\t\t * on Solaris.\n\t\t */\n\t\tTIFFSeekFile( tif, 0, SEEK_SET );\n\t\tif (!WriteOK(tif, &tif->tif_header, (tmsize_t)(tif->tif_header_size))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t\t    \"Error writing TIFF header\");\n\t\t\tgoto bad;\n\t\t}\n\t\t/*\n\t\t * Setup the byte order handling.\n\t\t */\n\t\tif (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN) {\n\t\t\t#ifndef WORDS_BIGENDIAN\n\t\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t\t#endif\n\t\t} else {\n\t\t\t#ifdef WORDS_BIGENDIAN\n\t\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t\t#endif\n\t\t}\n\t\t/*\n\t\t * Setup default directory.\n\t\t */\n\t\tif (!TIFFDefaultDirectory(tif))\n\t\t\tgoto bad;\n\t\ttif->tif_diroff = 0;\n\t\ttif->tif_dirlist = NULL;\n\t\ttif->tif_dirlistsize = 0;\n\t\ttif->tif_dirnumber = 0;\n\t\treturn (tif);\n\t}\n\t/*\n\t * Setup the byte order handling.\n\t */\n\tif (tif->tif_header.common.tiff_magic != TIFF_BIGENDIAN &&\n\t    tif->tif_header.common.tiff_magic != TIFF_LITTLEENDIAN\n\t    #if MDI_SUPPORT\n\t    &&\n\t    #if HOST_BIGENDIAN\n\t    tif->tif_header.common.tiff_magic != MDI_BIGENDIAN\n\t    #else\n\t    tif->tif_header.common.tiff_magic != MDI_LITTLEENDIAN\n\t    #endif\n\t    ) {\n\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t    \"Not a TIFF or MDI file, bad magic number %d (0x%x)\",\n\t    #else\n\t    ) {\n\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t    \"Not a TIFF file, bad magic number %d (0x%x)\",\n\t    #endif\n\t\t    tif->tif_header.common.tiff_magic,\n\t\t    tif->tif_header.common.tiff_magic);\n\t\tgoto bad;\n\t}\n\tif (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN) {\n\t\t#ifndef WORDS_BIGENDIAN\n\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t#endif\n\t} else {\n\t\t#ifdef WORDS_BIGENDIAN\n\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t#endif\n\t}\n\tif (tif->tif_flags & TIFF_SWAB) \n\t\tTIFFSwabShort(&tif->tif_header.common.tiff_version);\n\tif ((tif->tif_header.common.tiff_version != TIFF_VERSION_CLASSIC)&&\n\t    (tif->tif_header.common.tiff_version != TIFF_VERSION_BIG)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t    \"Not a TIFF file, bad version number %d (0x%x)\",\n\t\t    tif->tif_header.common.tiff_version,\n\t\t    tif->tif_header.common.tiff_version);\n\t\tgoto bad;\n\t}\n\tif (tif->tif_header.common.tiff_version == TIFF_VERSION_CLASSIC)\n\t{\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabLong(&tif->tif_header.classic.tiff_diroff);\n\t\ttif->tif_header_size = sizeof(TIFFHeaderClassic);\n\t}\n\telse\n\t{\n\t\tif (!ReadOK(tif, ((uint8*)(&tif->tif_header) + sizeof(TIFFHeaderClassic)), (sizeof(TIFFHeaderBig)-sizeof(TIFFHeaderClassic))))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t\t    \"Cannot read TIFF header\");\n\t\t\tgoto bad;\n\t\t}\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t{\n\t\t\tTIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);\n\t\t\tTIFFSwabLong8(&tif->tif_header.big.tiff_diroff);\n\t\t}\n\t\tif (tif->tif_header.big.tiff_offsetsize != 8)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t\t    \"Not a TIFF file, bad BigTIFF offsetsize %d (0x%x)\",\n\t\t\t    tif->tif_header.big.tiff_offsetsize,\n\t\t\t    tif->tif_header.big.tiff_offsetsize);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (tif->tif_header.big.tiff_unused != 0)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t\t    \"Not a TIFF file, bad BigTIFF unused %d (0x%x)\",\n\t\t\t    tif->tif_header.big.tiff_unused,\n\t\t\t    tif->tif_header.big.tiff_unused);\n\t\t\tgoto bad;\n\t\t}\n\t\ttif->tif_header_size = sizeof(TIFFHeaderBig);\n\t\ttif->tif_flags |= TIFF_BIGTIFF;\n\t}\n\ttif->tif_flags |= TIFF_MYBUFFER;\n\ttif->tif_rawcp = tif->tif_rawdata = 0;\n\ttif->tif_rawdatasize = 0;\n        tif->tif_rawdataoff = 0;\n        tif->tif_rawdataloaded = 0;\n\n\tswitch (mode[0]) {\n\t\tcase 'r':\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t\ttif->tif_nextdiroff = tif->tif_header.classic.tiff_diroff;\n\t\t\telse\n\t\t\t\ttif->tif_nextdiroff = tif->tif_header.big.tiff_diroff;\n\t\t\t/*\n\t\t\t * Try to use a memory-mapped file if the client\n\t\t\t * has not explicitly suppressed usage with the\n\t\t\t * 'm' flag in the open mode (see above).\n\t\t\t */\n\t\t\tif (tif->tif_flags & TIFF_MAPPED)\n\t\t\t{\n\t\t\t\ttoff_t n;\n\t\t\t\tif (TIFFMapFileContents(tif,(void**)(&tif->tif_base),&n))\n\t\t\t\t{\n\t\t\t\t\ttif->tif_size=(tmsize_t)n;\n\t\t\t\t\tassert((toff_t)tif->tif_size==n);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\ttif->tif_flags &= ~TIFF_MAPPED;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Sometimes we do not want to read the first directory (for example,\n\t\t\t * it may be broken) and want to proceed to other directories. I this\n\t\t\t * case we use the TIFF_HEADERONLY flag to open file and return\n\t\t\t * immediately after reading TIFF header.\n\t\t\t */\n\t\t\tif (tif->tif_flags & TIFF_HEADERONLY)\n\t\t\t\treturn (tif);\n\n\t\t\t/*\n\t\t\t * Setup initial directory.\n\t\t\t */\n\t\t\tif (TIFFReadDirectory(tif)) {\n\t\t\t\ttif->tif_rawcc = (tmsize_t)-1;\n\t\t\t\ttif->tif_flags |= TIFF_BUFFERSETUP;\n\t\t\t\treturn (tif);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\t/*\n\t\t\t * New directories are automatically append\n\t\t\t * to the end of the directory chain when they\n\t\t\t * are written out (see TIFFWriteDirectory).\n\t\t\t */\n\t\t\tif (!TIFFDefaultDirectory(tif))\n\t\t\t\tgoto bad;\n\t\t\treturn (tif);\n\t}\nbad:\n\ttif->tif_mode = O_RDONLY;\t/* XXX avoid flush */\n        TIFFCleanup(tif);\nbad2:\n\treturn ((TIFF*)0);\n}",
        "begin_line": 72,
        "end_line": 487,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_open._TIFFgetMode#48",
        "src_path": "libtiff/tif_open.c",
        "class_name": "libtiff.tif_open",
        "signature": "libtiff.tif_open._TIFFgetMode(const char* mode, const char* module)",
        "snippet": "int\n_TIFFgetMode(const char* mode, const char* module)\n{\n\tint m = -1;\n\n\tswitch (mode[0]) {\n\tcase 'r':\n\t\tm = O_RDONLY;\n\t\tif (mode[1] == '+')\n\t\t\tm = O_RDWR;\n\t\tbreak;\n\tcase 'w':\n\tcase 'a':\n\t\tm = O_RDWR|O_CREAT;\n\t\tif (mode[0] == 'w')\n\t\t\tm |= O_TRUNC;\n\t\tbreak;\n\tdefault:\n\t\tTIFFErrorExt(0, module, \"\\\"%s\\\": Bad mode\", mode);\n\t\tbreak;\n\t}\n\treturn (m);\n}",
        "begin_line": 48,
        "end_line": 70,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_read.TIFFCheckRead#1074",
        "src_path": "libtiff/tif_read.c",
        "class_name": "libtiff.tif_read",
        "signature": "libtiff.tif_read.TIFFCheckRead(TIFF* tif, int tiles)",
        "snippet": "static int\nTIFFCheckRead(TIFF* tif, int tiles)\n{\n\tif (tif->tif_mode == O_WRONLY) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"File not open for reading\");\n\t\treturn (0);\n\t}\n\tif (tiles ^ isTiled(tif)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, tiles ?\n\t\t    \"Can not read tiles from a stripped image\" :\n\t\t    \"Can not read scanlines from a tiled image\");\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
        "begin_line": 1074,
        "end_line": 1088,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_read.TIFFFillStrip#512",
        "src_path": "libtiff/tif_read.c",
        "class_name": "libtiff.tif_read",
        "signature": "libtiff.tif_read.TIFFFillStrip(TIFF* tif, uint32 strip)",
        "snippet": "int\nTIFFFillStrip(TIFF* tif, uint32 strip)\n{\n\tstatic const char module[] = \"TIFFFillStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\n        if (!_TIFFFillStriles( tif ) || !tif->tif_dir.td_stripbytecount)\n            return 0;\n\n\tif ((tif->tif_flags&TIFF_NOREADRAW)==0)\n\t{\n\t\tuint64 bytecount = td->td_stripbytecount[strip];\n\t\tif ((int64)bytecount <= 0) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"Invalid strip byte count %I64u, strip %lu\",\n\t\t\t\t     (unsigned __int64) bytecount,\n\t\t\t\t     (unsigned long) strip);\n#else\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"Invalid strip byte count %llu, strip %lu\",\n\t\t\t\t     (unsigned long long) bytecount,\n\t\t\t\t     (unsigned long) strip);\n#endif\n\t\t\treturn (0);\n\t\t}\n\t\tif (isMapped(tif) &&\n\t\t    (isFillOrder(tif, td->td_fillorder)\n\t\t    || (tif->tif_flags & TIFF_NOBITREV))) {\n\t\t\t/*\n\t\t\t * The image is mapped into memory and we either don't\n\t\t\t * need to flip bits or the compression routine is\n\t\t\t * going to handle this operation itself.  In this\n\t\t\t * case, avoid copying the raw data and instead just\n\t\t\t * reference the data from the memory mapped file\n\t\t\t * image.  This assumes that the decompression\n\t\t\t * routines do not modify the contents of the raw data\n\t\t\t * buffer (if they try to, the application will get a\n\t\t\t * fault since the file is mapped read-only).\n\t\t\t */\n\t\t\tif ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) {\n\t\t\t\t_TIFFfree(tif->tif_rawdata);\n\t\t\t\ttif->tif_rawdata = NULL;\n\t\t\t\ttif->tif_rawdatasize = 0;\n\t\t\t}\n\t\t\ttif->tif_flags &= ~TIFF_MYBUFFER;\n\t\t\t/*\n\t\t\t * We must check for overflow, potentially causing\n\t\t\t * an OOB read. Instead of simple\n\t\t\t *\n\t\t\t *  td->td_stripoffset[strip]+bytecount > tif->tif_size\n\t\t\t *\n\t\t\t * comparison (which can overflow) we do the following\n\t\t\t * two comparisons:\n\t\t\t */\n\t\t\tif (bytecount > (uint64)tif->tif_size ||\n\t\t\t    td->td_stripoffset[strip] > (uint64)tif->tif_size - bytecount) {\n\t\t\t\t/*\n\t\t\t\t * This error message might seem strange, but\n\t\t\t\t * it's what would happen if a read were done\n\t\t\t\t * instead.\n\t\t\t\t */\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\n\t\t\t\t\t\"Read error on strip %lu; \"\n\t\t\t\t\t\"got %I64u bytes, expected %I64u\",\n\t\t\t\t\t(unsigned long) strip,\n\t\t\t\t\t(unsigned __int64) tif->tif_size - td->td_stripoffset[strip],\n\t\t\t\t\t(unsigned __int64) bytecount);\n#else\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\n\t\t\t\t\t\"Read error on strip %lu; \"\n\t\t\t\t\t\"got %llu bytes, expected %llu\",\n\t\t\t\t\t(unsigned long) strip,\n\t\t\t\t\t(unsigned long long) tif->tif_size - td->td_stripoffset[strip],\n\t\t\t\t\t(unsigned long long) bytecount);\n#endif\n\t\t\t\ttif->tif_curstrip = NOSTRIP;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\ttif->tif_rawdatasize = (tmsize_t)bytecount;\n\t\t\ttif->tif_rawdata = tif->tif_base + (tmsize_t)td->td_stripoffset[strip];\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = (tmsize_t) bytecount;\n\n\t\t\t/* \n\t\t\t * When we have tif_rawdata reference directly into the memory mapped file\n\t\t\t * we need to be pretty careful about how we use the rawdata.  It is not\n\t\t\t * a general purpose working buffer as it normally otherwise is.  So we\n\t\t\t * keep track of this fact to avoid using it improperly.\n\t\t\t */\n\t\t\ttif->tif_flags |= TIFF_BUFFERMMAP;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Expand raw data buffer, if needed, to hold data\n\t\t\t * strip coming from file (perhaps should set upper\n\t\t\t * bound on the size of a buffer we'll use?).\n\t\t\t */\n\t\t\ttmsize_t bytecountm;\n\t\t\tbytecountm=(tmsize_t)bytecount;\n\t\t\tif ((uint64)bytecountm!=bytecount)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (bytecountm > tif->tif_rawdatasize) {\n\t\t\t\ttif->tif_curstrip = NOSTRIP;\n\t\t\t\tif ((tif->tif_flags & TIFF_MYBUFFER) == 0) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t    \"Data buffer too small to hold strip %lu\",\n\t\t\t\t\t    (unsigned long) strip);\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tif (!TIFFReadBufferSetup(tif, 0, bytecountm))\n\t\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags&TIFF_BUFFERMMAP) {\n\t\t\t\ttif->tif_curstrip = NOSTRIP;\n\t\t\t\tif (!TIFFReadBufferSetup(tif, 0, bytecountm))\n\t\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (TIFFReadRawStrip1(tif, strip, tif->tif_rawdata,\n\t\t\t\tbytecountm, module) != bytecountm)\n\t\t\t\treturn (0);\n\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = bytecountm;\n                        \n\t\t\tif (!isFillOrder(tif, td->td_fillorder) &&\n\t\t\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\t\t\tTIFFReverseBits(tif->tif_rawdata, bytecountm);\n                }\n\t}\n\treturn (TIFFStartStrip(tif, strip));\n}",
        "begin_line": 512,
        "end_line": 648,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_read.TIFFReadScanline#293",
        "src_path": "libtiff/tif_read.c",
        "class_name": "libtiff.tif_read",
        "signature": "libtiff.tif_read.TIFFReadScanline(TIFF* tif, void* buf, uint32 row, uint16 sample)",
        "snippet": "int\nTIFFReadScanline(TIFF* tif, void* buf, uint32 row, uint16 sample)\n{\n\tint e;\n\n\tif (!TIFFCheckRead(tif, 0))\n\t\treturn (-1);\n\tif( (e = TIFFSeek(tif, row, sample)) != 0) {\n\t\t/*\n\t\t * Decompress desired row into user buffer.\n\t\t */\n\t\te = (*tif->tif_decoderow)\n\t\t    (tif, (uint8*) buf, tif->tif_scanlinesize, sample);  \n\n\t\t/* we are now poised at the beginning of the next row */\n\t\ttif->tif_row = row + 1;\n\n\t\tif (e)\n\t\t\t(*tif->tif_postdecode)(tif, (uint8*) buf,\n\t\t\t    tif->tif_scanlinesize);  \n\t}\n\treturn (e > 0 ? 1 : -1);\n}",
        "begin_line": 293,
        "end_line": 315,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_read.TIFFSeek#178",
        "src_path": "libtiff/tif_read.c",
        "class_name": "libtiff.tif_read",
        "signature": "libtiff.tif_read.TIFFSeek(TIFF* tif, uint32 row, uint16 sample )",
        "snippet": "static int\nTIFFSeek(TIFF* tif, uint32 row, uint16 sample )\n{\n\tregister TIFFDirectory *td = &tif->tif_dir;\n\tuint32 strip;\n        int    whole_strip;\n\ttmsize_t read_ahead = 0;\n\n        /*\n        ** Establish what strip we are working from.\n        */\n\tif (row >= td->td_imagelength) {\t/* out of range */\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t    \"%lu: Row out of range, max %lu\",\n\t\t    (unsigned long) row,\n\t\t    (unsigned long) td->td_imagelength);\n\t\treturn (0);\n\t}\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE) {\n\t\tif (sample >= td->td_samplesperpixel) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t    \"%lu: Sample out of range, max %lu\",\n\t\t\t    (unsigned long) sample, (unsigned long) td->td_samplesperpixel);\n\t\t\treturn (0);\n\t\t}\n\t\tstrip = (uint32)sample*td->td_stripsperimage + row/td->td_rowsperstrip;\n\t} else\n\t\tstrip = row / td->td_rowsperstrip;\n\n        /*\n         * Do we want to treat this strip as one whole chunk or\n         * read it a few lines at a time?\n         */\n#if defined(CHUNKY_STRIP_READ_SUPPORT)\n        if (!_TIFFFillStriles( tif ) || !tif->tif_dir.td_stripbytecount)\n            return 0;\n        whole_strip = tif->tif_dir.td_stripbytecount[strip] < 10\n                || isMapped(tif);\n#else\n        whole_strip = 1;\n#endif\n        \n        if( !whole_strip )\n        {\n                read_ahead = tif->tif_scanlinesize * 16 + 5000;\n        }\n\n        /*\n         * If we haven't loaded this strip, do so now, possibly\n         * only reading the first part.\n         */\n\tif (strip != tif->tif_curstrip) {\t/* different strip, refill */\n                \n                if( whole_strip )\n                {\n                        if (!TIFFFillStrip(tif, strip))\n                                return (0);\n                }\n                else\n                {\n                        if( !TIFFFillStripPartial(tif,strip,read_ahead,1) )\n                                return 0;\n                }\n\t}\n\n        /*\n        ** If we already have some data loaded, do we need to read some more?\n        */\n        else if( !whole_strip )\n        {\n                if( ((tif->tif_rawdata + tif->tif_rawdataloaded) - tif->tif_rawcp) < read_ahead \n                    && (uint64) tif->tif_rawdataoff+tif->tif_rawdataloaded < td->td_stripbytecount[strip] )\n                {\n                        if( !TIFFFillStripPartial(tif,strip,read_ahead,0) )\n                                return 0;\n                }\n        }\n\n        if (row < tif->tif_row) {\n\t\t/*\n\t\t * Moving backwards within the same strip: backup\n\t\t * to the start and then decode forward (below).\n\t\t *\n\t\t * NB: If you're planning on lots of random access within a\n\t\t * strip, it's better to just read and decode the entire\n\t\t * strip, and then access the decoded data in a random fashion.\n\t\t */\n\n                if( tif->tif_rawdataoff != 0 )\n                {\n                        if( !TIFFFillStripPartial(tif,strip,read_ahead,1) )\n                                return 0;\n                }\n                else\n                {\n                        if (!TIFFStartStrip(tif, strip))\n                                return (0);\n                }\n\t}\n        \n\tif (row != tif->tif_row) {\n\t\t/*\n\t\t * Seek forward to the desired row.\n\t\t */\n\n                /* TODO: Will this really work with partial buffers? */\n                \n\t\tif (!(*tif->tif_seek)(tif, row - tif->tif_row))\n\t\t\treturn (0);\n\t\ttif->tif_row = row;\n\t}\n\n\treturn (1);\n}",
        "begin_line": 178,
        "end_line": 291,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_read.TIFFStartStrip#996",
        "src_path": "libtiff/tif_read.c",
        "class_name": "libtiff.tif_read",
        "signature": "libtiff.tif_read.TIFFStartStrip(TIFF* tif, uint32 strip)",
        "snippet": "static int\nTIFFStartStrip(TIFF* tif, uint32 strip)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\n        if (!_TIFFFillStriles( tif ) || !tif->tif_dir.td_stripbytecount)\n            return 0;\n\n\tif ((tif->tif_flags & TIFF_CODERSETUP) == 0) {\n\t\tif (!(*tif->tif_setupdecode)(tif))\n\t\t\treturn (0);\n\t\ttif->tif_flags |= TIFF_CODERSETUP;\n\t}\n\ttif->tif_curstrip = strip;\n\ttif->tif_row = (strip % td->td_stripsperimage) * td->td_rowsperstrip;\n        tif->tif_flags &= ~TIFF_BUF4WRITE;\n\n\tif (tif->tif_flags&TIFF_NOREADRAW)\n\t{\n\t\ttif->tif_rawcp = NULL;\n\t\ttif->tif_rawcc = 0;  \n\t}\n\telse\n\t{\n\t\ttif->tif_rawcp = tif->tif_rawdata;\n\t\ttif->tif_rawcc = (tmsize_t)td->td_stripbytecount[strip];\n\t}\n\treturn ((*tif->tif_predecode)(tif,\n\t\t\t(uint16)(strip / td->td_stripsperimage)));\n}",
        "begin_line": 996,
        "end_line": 1025,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip.TIFFDefaultStripSize#233",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip.TIFFDefaultStripSize(TIFF* tif, uint32 request)",
        "snippet": "uint32\nTIFFDefaultStripSize(TIFF* tif, uint32 request)\n{\n\treturn (*tif->tif_defstripsize)(tif, request);\n}",
        "begin_line": 233,
        "end_line": 237,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip.TIFFNumberOfStrips#60",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip.TIFFNumberOfStrips(TIFF* tif)",
        "snippet": "uint32\nTIFFNumberOfStrips(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 nstrips;\n\n\tnstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :\n\t     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\tnstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel,\n\t\t    \"TIFFNumberOfStrips\");\n\treturn (nstrips);\n}",
        "begin_line": 60,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip.TIFFScanlineSize#330",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip.TIFFScanlineSize(TIFF* tif)",
        "snippet": "tmsize_t\nTIFFScanlineSize(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFScanlineSize\";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFScanlineSize64(tif);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m) {\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer arithmetic overflow\");\n\t\tn=0;\n\t}\n\treturn(n);\n}",
        "begin_line": 330,
        "end_line": 343,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip.TIFFScanlineSize64#273",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip.TIFFScanlineSize64(TIFF* tif)",
        "snippet": "uint64\nTIFFScanlineSize64(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFScanlineSize64\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint64 scanline_size;\n\tif (td->td_planarconfig==PLANARCONFIG_CONTIG)\n\t{\n\t\tif ((td->td_photometric==PHOTOMETRIC_YCBCR)&&\n\t\t    (td->td_samplesperpixel==3)&&\n\t\t    (!isUpSampled(tif)))\n\t\t{\n\t\t\tuint16 ycbcrsubsampling[2];\n\t\t\tuint16 samplingblock_samples;\n\t\t\tuint32 samplingblocks_hor;\n\t\t\tuint64 samplingrow_samples;\n\t\t\tuint64 samplingrow_size;\n\t\t\tif(td->td_samplesperpixel!=3)\n\t\t\t{\n                            TIFFErrorExt(tif->tif_clientdata,module,\n                                         \"Invalid td_samplesperpixel value\");\n                            return 0;\n\t\t\t}\n\t\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_YCBCRSUBSAMPLING,\n                                              ycbcrsubsampling+0,\n                                              ycbcrsubsampling+1);\n\t\t\tif (((ycbcrsubsampling[0]!=1)&&(ycbcrsubsampling[0]!=2)&&(ycbcrsubsampling[0]!=4)) ||\n\t\t\t    ((ycbcrsubsampling[1]!=1)&&(ycbcrsubsampling[1]!=2)&&(ycbcrsubsampling[1]!=4)))\n\t\t\t{\n                            TIFFErrorExt(tif->tif_clientdata,module,\n                                         \"Invalid YCbCr subsampling\");\n                            return 0;\n\t\t\t}\n\t\t\tsamplingblock_samples = ycbcrsubsampling[0]*ycbcrsubsampling[1]+2;\n\t\t\tsamplingblocks_hor = TIFFhowmany_32(td->td_imagewidth,ycbcrsubsampling[0]);\n\t\t\tsamplingrow_samples = _TIFFMultiply64(tif,samplingblocks_hor,samplingblock_samples,module);\n\t\t\tsamplingrow_size = TIFFhowmany_64(_TIFFMultiply64(tif,samplingrow_samples,td->td_bitspersample,module),8);\n\t\t\tscanline_size = (samplingrow_size/ycbcrsubsampling[1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint64 scanline_samples;\n\t\t\tscanline_samples=_TIFFMultiply64(tif,td->td_imagewidth,td->td_samplesperpixel,module);\n\t\t\tscanline_size=TIFFhowmany_64(_TIFFMultiply64(tif,scanline_samples,td->td_bitspersample,module),8);\n\t\t}\n\t}\n\telse\n        {\n\t\tscanline_size=TIFFhowmany_64(_TIFFMultiply64(tif,td->td_imagewidth,td->td_bitspersample,module),8);\n        }\n        if (scanline_size == 0)\n        {\n                TIFFErrorExt(tif->tif_clientdata,module,\"Computed scanline size is zero\");\n                return 0;\n        }\n\treturn(scanline_size);\n}",
        "begin_line": 273,
        "end_line": 329,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip.TIFFStripSize#211",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip.TIFFStripSize(TIFF* tif)",
        "snippet": "tmsize_t\nTIFFStripSize(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFStripSize\";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFStripSize64(tif);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\n\t\tn=0;\n\t}\n\treturn(n);\n}",
        "begin_line": 211,
        "end_line": 225,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip.TIFFStripSize64#202",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip.TIFFStripSize64(TIFF* tif)",
        "snippet": "uint64\nTIFFStripSize64(TIFF* tif)\n{\n\tTIFFDirectory* td = &tif->tif_dir;\n\tuint32 rps = td->td_rowsperstrip;\n\tif (rps > td->td_imagelength)\n\t\trps = td->td_imagelength;\n\treturn (TIFFVStripSize64(tif, rps));\n}",
        "begin_line": 202,
        "end_line": 210,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip.TIFFVStripSize64#77",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip.TIFFVStripSize64(TIFF* tif, uint32 nrows)",
        "snippet": "uint64\nTIFFVStripSize64(TIFF* tif, uint32 nrows)\n{\n\tstatic const char module[] = \"TIFFVStripSize64\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tif (nrows==(uint32)(-1))\n\t\tnrows=td->td_imagelength;\n\tif ((td->td_planarconfig==PLANARCONFIG_CONTIG)&&\n\t    (td->td_photometric == PHOTOMETRIC_YCBCR)&&\n\t    (!isUpSampled(tif)))\n\t{\n\t\t/*\n\t\t * Packed YCbCr data contain one Cb+Cr for every\n\t\t * HorizontalSampling*VerticalSampling Y values.\n\t\t * Must also roundup width and height when calculating\n\t\t * since images that are not a multiple of the\n\t\t * horizontal/vertical subsampling area include\n\t\t * YCbCr data for the extended image.\n\t\t */\n\t\tuint16 ycbcrsubsampling[2];\n\t\tuint16 samplingblock_samples;\n\t\tuint32 samplingblocks_hor;\n\t\tuint32 samplingblocks_ver;\n\t\tuint64 samplingrow_samples;\n\t\tuint64 samplingrow_size;\n\t\tif(td->td_samplesperpixel!=3)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t\t    \"Invalid td_samplesperpixel value\");\n\t\t\treturn 0;\n\t\t}\n\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_YCBCRSUBSAMPLING,ycbcrsubsampling+0,\n\t\t    ycbcrsubsampling+1);\n\t\tif ((ycbcrsubsampling[0] != 1 && ycbcrsubsampling[0] != 2 && ycbcrsubsampling[0] != 4)\n\t\t    ||(ycbcrsubsampling[1] != 1 && ycbcrsubsampling[1] != 2 && ycbcrsubsampling[1] != 4))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t\t\t     \"Invalid YCbCr subsampling (%dx%d)\", \n\t\t\t\t     ycbcrsubsampling[0], \n\t\t\t\t     ycbcrsubsampling[1] );\n\t\t\treturn 0;\n\t\t}\n\t\tsamplingblock_samples=ycbcrsubsampling[0]*ycbcrsubsampling[1]+2;\n\t\tsamplingblocks_hor=TIFFhowmany_32(td->td_imagewidth,ycbcrsubsampling[0]);\n\t\tsamplingblocks_ver=TIFFhowmany_32(nrows,ycbcrsubsampling[1]);\n\t\tsamplingrow_samples=_TIFFMultiply64(tif,samplingblocks_hor,samplingblock_samples,module);\n\t\tsamplingrow_size=TIFFhowmany8_64(_TIFFMultiply64(tif,samplingrow_samples,td->td_bitspersample,module));\n\t\treturn(_TIFFMultiply64(tif,samplingrow_size,samplingblocks_ver,module));\n\t}\n\telse\n\t\treturn(_TIFFMultiply64(tif,nrows,TIFFScanlineSize64(tif),module));\n}",
        "begin_line": 77,
        "end_line": 128,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip._TIFFDefaultStripSize#239",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip._TIFFDefaultStripSize(TIFF* tif, uint32 s)",
        "snippet": "uint32\n_TIFFDefaultStripSize(TIFF* tif, uint32 s)\n{\n\tif ((int32) s < 1) {\n\t\t/*\n\t\t * If RowsPerStrip is unspecified, try to break the\n\t\t * image up into strips that are approximately\n\t\t * STRIP_SIZE_DEFAULT bytes long.\n\t\t */\n\t\tuint64 scanlinesize;\n\t\tuint64 rows;\n\t\tscanlinesize=TIFFScanlineSize64(tif);\n\t\tif (scanlinesize==0)\n\t\t\tscanlinesize=1;\n\t\trows=(uint64)STRIP_SIZE_DEFAULT/scanlinesize;\n\t\tif (rows==0)\n\t\t\trows=1;\n\t\telse if (rows>0xFFFFFFFF)\n\t\t\trows=0xFFFFFFFF;\n\t\ts=(uint32)rows;\n\t}\n\treturn (s);\n}",
        "begin_line": 239,
        "end_line": 261,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix.TIFFFdOpen#204",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix.TIFFFdOpen(int fd, const char* name, const char* mode)",
        "snippet": "TIFF*\nTIFFFdOpen(int fd, const char* name, const char* mode)\n{\n\tTIFF* tif;\n\n\tfd_as_handle_union_t fdh;\n\tfdh.fd = fd;\n\ttif = TIFFClientOpen(name, mode,\n\t    fdh.h,\n\t    _tiffReadProc, _tiffWriteProc,\n\t    _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,\n\t    _tiffMapProc, _tiffUnmapProc);\n\tif (tif)\n\t\ttif->tif_fd = fd;\n\treturn (tif);\n}",
        "begin_line": 204,
        "end_line": 219,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix.TIFFOpen#224",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix.TIFFOpen(const char* name, const char* mode)",
        "snippet": "TIFF*\nTIFFOpen(const char* name, const char* mode)\n{\n\tstatic const char module[] = \"TIFFOpen\";\n\tint m, fd;\n\tTIFF* tif;\n\n\tm = _TIFFgetMode(mode, module);\n\tif (m == -1)\n\t\treturn ((TIFF*)0);\n\n/* for cygwin and mingw */\n#ifdef O_BINARY\n\tm |= O_BINARY;\n#endif\n\n\tfd = open(name, m, 0666);\n\tif (fd < 0) {\n\t\tif (errno > 0 && strerror(errno) != NULL ) {\n\t\t\tTIFFErrorExt(0, module, \"%s: %s\", name, strerror(errno) );\n\t\t} else {\n\t\t\tTIFFErrorExt(0, module, \"%s: Cannot open\", name);\n\t\t}\n\t\treturn ((TIFF *)0);\n\t}\n\n\ttif = TIFFFdOpen((int)fd, name, mode);\n\tif(!tif)\n\t\tclose(fd);\n\treturn tif;\n}",
        "begin_line": 224,
        "end_line": 254,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._TIFFfree#319",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._TIFFfree(void* p)",
        "snippet": "void\n_TIFFfree(void* p)\n{\n\tfree(p);\n}",
        "begin_line": 319,
        "end_line": 323,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._TIFFmalloc#310",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._TIFFmalloc(tmsize_t s)",
        "snippet": "void*\n_TIFFmalloc(tmsize_t s)\n{\n        if (s == 0)\n                return ((void *) NULL);\n\n\treturn (malloc((size_t) s));\n}",
        "begin_line": 310,
        "end_line": 317,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._TIFFmemcpy#337",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._TIFFmemcpy(void* d, const void* s, tmsize_t c)",
        "snippet": "void\n_TIFFmemcpy(void* d, const void* s, tmsize_t c)\n{\n\tmemcpy(d, s, (size_t) c);\n}",
        "begin_line": 337,
        "end_line": 341,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._TIFFmemset#331",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._TIFFmemset(void* p, int v, tmsize_t c)",
        "snippet": "void\n_TIFFmemset(void* p, int v, tmsize_t c)\n{\n\tmemset(p, v, (size_t) c);\n}",
        "begin_line": 331,
        "end_line": 335,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._TIFFrealloc#325",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._TIFFrealloc(void* p, tmsize_t s)",
        "snippet": "void*\n_TIFFrealloc(void* p, tmsize_t s)\n{\n\treturn (realloc(p, (size_t) s));\n}",
        "begin_line": 325,
        "end_line": 329,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._tiffMapProc#162",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._tiffMapProc(thandle_t fd, void** pbase, toff_t* psize)",
        "snippet": "static int\n_tiffMapProc(thandle_t fd, void** pbase, toff_t* psize)\n{\n\tuint64 size64 = _tiffSizeProc(fd);\n\ttmsize_t sizem = (tmsize_t)size64;\n\tif ((uint64)sizem==size64) {\n\t\tfd_as_handle_union_t fdh;\n\t\tfdh.h = fd;\n\t\t*pbase = (void*)\n\t\t    mmap(0, (size_t)sizem, PROT_READ, MAP_SHARED, fdh.fd, 0);\n\t\tif (*pbase != (void*) -1) {\n\t\t\t*psize = (tmsize_t)sizem;\n\t\t\treturn (1);\n\t\t}\n\t}\n\treturn (0);\n}",
        "begin_line": 162,
        "end_line": 178,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._tiffReadProc#68",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._tiffReadProc(thandle_t fd, void* buf, tmsize_t size)",
        "snippet": "static tmsize_t\n_tiffReadProc(thandle_t fd, void* buf, tmsize_t size)\n{\n\tfd_as_handle_union_t fdh;\n        const size_t bytes_total = (size_t) size;\n        size_t bytes_read;\n        tmsize_t count = -1;\n\tif ((tmsize_t) bytes_total != size)\n\t{\n\t\terrno=EINVAL;\n\t\treturn (tmsize_t) -1;\n\t}\n\tfdh.h = fd;\n        for (bytes_read=0; bytes_read < bytes_total; bytes_read+=count)\n        {\n                char *buf_offset = (char *) buf+bytes_read;\n                size_t io_size = bytes_total-bytes_read;\n                if (io_size > TIFF_IO_MAX)\n                        io_size = TIFF_IO_MAX;\n                count=read(fdh.fd, buf_offset, (TIFFIOSize_t) io_size);\n                if (count <= 0)\n                        break;\n        }\n        if (count < 0)\n                return (tmsize_t)-1;\n        return (tmsize_t) bytes_read;\n}",
        "begin_line": 68,
        "end_line": 94,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._tiffSeekProc#125",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._tiffSeekProc(thandle_t fd, uint64 off, int whence)",
        "snippet": "static uint64\n_tiffSeekProc(thandle_t fd, uint64 off, int whence)\n{\n\tfd_as_handle_union_t fdh;\n\t_TIFF_off_t off_io = (_TIFF_off_t) off;\n\tif ((uint64) off_io != off)\n\t{\n\t\terrno=EINVAL;\n\t\treturn (uint64) -1; /* this is really gross */\n\t}\n\tfdh.h = fd;\n\treturn((uint64)_TIFF_lseek_f(fdh.fd,off_io,whence));\n}",
        "begin_line": 125,
        "end_line": 137,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._tiffSizeProc#147",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._tiffSizeProc(thandle_t fd)",
        "snippet": "static uint64\n_tiffSizeProc(thandle_t fd)\n{\n\t_TIFF_stat_s sb;\n\tfd_as_handle_union_t fdh;\n\tfdh.h = fd;\n\tif (_TIFF_fstat_f(fdh.fd,&sb)<0)\n\t\treturn(0);\n\telse\n\t\treturn((uint64)sb.st_size);\n}",
        "begin_line": 147,
        "end_line": 157,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._tiffWriteProc#96",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._tiffWriteProc(thandle_t fd, void* buf, tmsize_t size)",
        "snippet": "static tmsize_t\n_tiffWriteProc(thandle_t fd, void* buf, tmsize_t size)\n{\n\tfd_as_handle_union_t fdh;\n\tconst size_t bytes_total = (size_t) size;\n        size_t bytes_written;\n        tmsize_t count = -1;\n\tif ((tmsize_t) bytes_total != size)\n\t{\n\t\terrno=EINVAL;\n\t\treturn (tmsize_t) -1;\n\t}\n\tfdh.h = fd;\n        for (bytes_written=0; bytes_written < bytes_total; bytes_written+=count)\n        {\n                const char *buf_offset = (char *) buf+bytes_written;\n                size_t io_size = bytes_total-bytes_written;\n                if (io_size > TIFF_IO_MAX)\n                        io_size = TIFF_IO_MAX;\n                count=write(fdh.fd, buf_offset, (TIFFIOSize_t) io_size);\n                if (count <= 0)\n                        break;\n        }\n        if (count < 0)\n                return (tmsize_t)-1;\n        return (tmsize_t) bytes_written;\n\t/* return ((tmsize_t) write(fdh.fd, buf, bytes_total)); */\n}",
        "begin_line": 96,
        "end_line": 123,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix.unixWarningHandler#349",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix.unixWarningHandler(const char* module, const char* fmt, va_list ap)",
        "snippet": "static void\nunixWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n\tif (module != NULL)\n\t\tfprintf(stderr, \"%s: \", module);\n\tfprintf(stderr, \"Warning, \");\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \".\\n\");\n}",
        "begin_line": 349,
        "end_line": 357,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_warning.TIFFWarningExt#62",
        "src_path": "libtiff/tif_warning.c",
        "class_name": "libtiff.tif_warning",
        "signature": "libtiff.tif_warning.TIFFWarningExt(thandle_t fd, const char* module, const char* fmt, ...)",
        "snippet": "void\nTIFFWarningExt(thandle_t fd, const char* module, const char* fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tif (_TIFFwarningHandler)\n\t\t(*_TIFFwarningHandler)(module, fmt, ap);\n\tif (_TIFFwarningHandlerExt)\n\t\t(*_TIFFwarningHandlerExt)(fd, module, fmt, ap);\n\tva_end(ap);\n}",
        "begin_line": 62,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "tools.tiffmedian.get_histogram#371",
        "src_path": "tools/tiffmedian.c",
        "class_name": "tools.tiffmedian",
        "signature": "tools.tiffmedian.get_histogram(TIFF* in, Colorbox* box)",
        "snippet": "static void\nget_histogram(TIFF* in, Colorbox* box)\n{\n\tregister unsigned char *inptr;\n\tregister int red, green, blue;\n\tregister uint32 j, i;\n\tunsigned char *inputline;\n\n\tinputline = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\n\tif (inputline == NULL) {\n\t\tfprintf(stderr, \"No space for scanline buffer\\n\");\n\t\texit(-1);\n\t}\n\tbox->rmin = box->gmin = box->bmin = 999;\n\tbox->rmax = box->gmax = box->bmax = -1;\n\tbox->total = imagewidth * imagelength;\n\n\t{ register uint32 *ptr = &histogram[0][0][0];\n\t  for (i = B_LEN*B_LEN*B_LEN; i-- > 0;)\n\t\t*ptr++ = 0;\n\t}\n\tfor (i = 0; i < imagelength; i++) {\n\t\tif (TIFFReadScanline(in, inputline, i, 0) <= 0)\n\t\t\tbreak;\n\t\tinptr = inputline;\n\t\tfor (j = imagewidth; j-- > 0;) {\n\t\t\tred = (*inptr++) & 0xff >> COLOR_SHIFT;\n\t\t\tgreen = (*inptr++) & 0xff >> COLOR_SHIFT;\n\t\t\tblue = (*inptr++) & 0xff >> COLOR_SHIFT;\n                        if ((red | green | blue) >= B_LEN) {\n                                fprintf(stderr,\n                                        \"Logic error. \"\n                                        \"Histogram array overflow!\\n\");\n                                exit(-6);\n                        }\n\t\t\tif (red < box->rmin)\n\t\t\t\tbox->rmin = red;\n\t\t        if (red > box->rmax)\n\t\t\t\tbox->rmax = red;\n\t\t        if (green < box->gmin)\n\t\t\t\tbox->gmin = green;\n\t\t        if (green > box->gmax)\n\t\t\t\tbox->gmax = green;\n\t\t        if (blue < box->bmin)\n\t\t\t\tbox->bmin = blue;\n\t\t        if (blue > box->bmax)\n\t\t\t\tbox->bmax = blue;\n\t\t        histogram[red][green][blue]++;\n\t\t}\n\t}\n\t_TIFFfree(inputline);\n}",
        "begin_line": 371,
        "end_line": 422,
        "is_bug": false
    },
    {
        "name": "tools.tiffmedian.largest_box#424",
        "src_path": "tools/tiffmedian.c",
        "class_name": "tools.tiffmedian",
        "signature": "tools.tiffmedian.largest_box(void)",
        "snippet": "static Colorbox *\nlargest_box(void)\n{\n\tregister Colorbox *p, *b;\n\tregister uint32 size;\n\n\tb = NULL;\n\tsize = 0;\n\tfor (p = usedboxes; p != NULL; p = p->next)\n\t\tif ((p->rmax > p->rmin || p->gmax > p->gmin ||\n\t\t    p->bmax > p->bmin) &&  p->total > size)\n\t\t        size = (b = p)->total;\n\treturn (b);\n}",
        "begin_line": 424,
        "end_line": 437,
        "is_bug": false
    },
    {
        "name": "tools.tiffmedian.main#128",
        "src_path": "tools/tiffmedian.c",
        "class_name": "tools.tiffmedian",
        "signature": "tools.tiffmedian.main(int argc, char* argv[])",
        "snippet": "int\nmain(int argc, char* argv[])\n{\n#ifdef DPP_ENABLE_GCOV\n\t  {\n\t\t  dpp_gcov_sigaction.sa_handler = dpp_sighandler;\n\t\t  sigemptyset(&dpp_gcov_sigaction.sa_mask);\n\t\t  dpp_gcov_sigaction.sa_flags = 0;\n\t\t  sigaction(SIGSEGV, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n\t\t  sigaction(SIGFPE, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n\t\t  sigaction(SIGABRT, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n\t  }\n#endif\n\tint i, dither = 0;\n\tuint16 shortv, config, photometric;\n\tColorbox *box_list, *ptr;\n\tfloat floatv;\n\tuint32 longv;\n\tint c;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char* optarg;\n#endif\n\n\tnum_colors = MAX_CMAP_SIZE;\n\twhile ((c = getopt(argc, argv, \"c:C:r:f\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'c':\t\t/* compression scheme */\n\t\t\tif (!processCompressOptions(optarg))\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'C':\t\t/* set colormap size */\n\t\t\tnum_colors = atoi(optarg);\n\t\t\tif (num_colors > MAX_CMAP_SIZE) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t   \"-c: colormap too big, max %d\\n\",\n\t\t\t\t   MAX_CMAP_SIZE);\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'f':\t\t/* dither */\n\t\t\tdither = 1;\n\t\t\tbreak;\n\t\tcase 'r':\t\t/* rows/strip */\n\t\t\trowsperstrip = atoi(optarg);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage();\n\t\t\t/*NOTREACHED*/\n\t\t}\n\tif (argc - optind != 2)\n\t\tusage();\n\tin = TIFFOpen(argv[optind], \"r\");\n\tif (in == NULL)\n\t\treturn (-1);\n\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &imagewidth);\n\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &imagelength);\n\tTIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\tTIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\tif (bitspersample != 8 && bitspersample != 16) {\n\t\tfprintf(stderr, \"%s: Image must have at least 8-bits/sample\\n\",\n\t\t    argv[optind]);\n\t\treturn (-3);\n\t}\n\tif (!TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &photometric) ||\n\t    photometric != PHOTOMETRIC_RGB || samplesperpixel < 3) {\n\t\tfprintf(stderr, \"%s: Image must have RGB data\\n\", argv[optind]);\n\t\treturn (-4);\n\t}\n\tTIFFGetField(in, TIFFTAG_PLANARCONFIG, &config);\n\tif (config != PLANARCONFIG_CONTIG) {\n\t\tfprintf(stderr, \"%s: Can only handle contiguous data packing\\n\",\n\t\t    argv[optind]);\n\t\treturn (-5);\n\t}\n\n\t/*\n\t * STEP 1:  create empty boxes\n\t */\n\tusedboxes = NULL;\n\tbox_list = freeboxes = (Colorbox *)_TIFFmalloc(num_colors*sizeof (Colorbox));\n\tfreeboxes[0].next = &freeboxes[1];\n\tfreeboxes[0].prev = NULL;\n\tfor (i = 1; i < num_colors-1; ++i) {\n\t\tfreeboxes[i].next = &freeboxes[i+1];\n\t\tfreeboxes[i].prev = &freeboxes[i-1];\n\t}\n\tfreeboxes[num_colors-1].next = NULL;\n\tfreeboxes[num_colors-1].prev = &freeboxes[num_colors-2];\n\n\t/*\n\t * STEP 2: get histogram, initialize first box\n\t */\n\tptr = freeboxes;\n\tfreeboxes = ptr->next;\n\tif (freeboxes)\n\t\tfreeboxes->prev = NULL;\n\tptr->next = usedboxes;\n\tusedboxes = ptr;\n\tif (ptr->next)\n\t\tptr->next->prev = ptr;\n\tget_histogram(in, ptr);\n\n\t/*\n\t * STEP 3: continually subdivide boxes until no more free\n\t * boxes remain or until all colors assigned.\n\t */\n\twhile (freeboxes != NULL) {\n\t\tptr = largest_box();\n\t\tif (ptr != NULL)\n\t\t\tsplitbox(ptr);\n\t\telse\n\t\t\tfreeboxes = NULL;\n\t}\n\n\t/*\n\t * STEP 4: assign colors to all boxes\n\t */\n\tfor (i = 0, ptr = usedboxes; ptr != NULL; ++i, ptr = ptr->next) {\n\t\trm[i] = ((ptr->rmin + ptr->rmax) << COLOR_SHIFT) / 2;\n\t\tgm[i] = ((ptr->gmin + ptr->gmax) << COLOR_SHIFT) / 2;\n\t\tbm[i] = ((ptr->bmin + ptr->bmax) << COLOR_SHIFT) / 2;\n\t}\n\n\t/* We're done with the boxes now */\n\t_TIFFfree(box_list);\n\tfreeboxes = usedboxes = NULL;\n\n\t/*\n\t * STEP 5: scan histogram and map all values to closest color\n\t */\n\t/* 5a: create cell list as described in Heckbert[2] */\n\tColorCells = (C_cell **)_TIFFmalloc(C_LEN*C_LEN*C_LEN*sizeof (C_cell*));\n\t_TIFFmemset(ColorCells, 0, C_LEN*C_LEN*C_LEN*sizeof (C_cell*));\n\t/* 5b: create mapping from truncated pixel space to color\n\t   table entries */\n\tmap_colortable();\n\n\t/*\n\t * STEP 6: scan image, match input values to table entries\n\t */\n\tout = TIFFOpen(argv[optind+1], \"w\");\n\tif (out == NULL)\n\t\treturn (-2);\n\n\tCopyField(TIFFTAG_SUBFILETYPE, longv);\n\tCopyField(TIFFTAG_IMAGEWIDTH, longv);\n\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, (short)COLOR_DEPTH);\n\tif (compression != (uint16)-1) {\n\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n\t\tswitch (compression) {\n\t\tcase COMPRESSION_LZW:\n\t\tcase COMPRESSION_DEFLATE:\n\t\t\tif (predictor != 0)\n\t\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tCopyField(TIFFTAG_COMPRESSION, compression);\n\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, (short)PHOTOMETRIC_PALETTE);\n\tCopyField(TIFFTAG_ORIENTATION, shortv);\n\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, (short)1);\n\tCopyField(TIFFTAG_PLANARCONFIG, shortv);\n\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\n\t    TIFFDefaultStripSize(out, rowsperstrip));\n\tCopyField(TIFFTAG_MINSAMPLEVALUE, shortv);\n\tCopyField(TIFFTAG_MAXSAMPLEVALUE, shortv);\n\tCopyField(TIFFTAG_RESOLUTIONUNIT, shortv);\n\tCopyField(TIFFTAG_XRESOLUTION, floatv);\n\tCopyField(TIFFTAG_YRESOLUTION, floatv);\n\tCopyField(TIFFTAG_XPOSITION, floatv);\n\tCopyField(TIFFTAG_YPOSITION, floatv);\n\n\tif (dither)\n\t\tquant_fsdither(in, out);\n\telse\n\t\tquant(in, out);\n\t/*\n\t * Scale colormap to TIFF-required 16-bit values.\n\t */\n#define\tSCALE(x)\t(((x)*((1L<<16)-1))/255)\n\tfor (i = 0; i < MAX_CMAP_SIZE; ++i) {\n\t\trm[i] = SCALE(rm[i]);\n\t\tgm[i] = SCALE(gm[i]);\n\t\tbm[i] = SCALE(bm[i]);\n\t}\n\tTIFFSetField(out, TIFFTAG_COLORMAP, rm, gm, bm);\n\t(void) TIFFClose(out);\n\treturn (0);\n}",
        "begin_line": 128,
        "end_line": 317,
        "is_bug": false
    },
    {
        "name": "tools.tiffmedian.map_colortable#734",
        "src_path": "tools/tiffmedian.c",
        "class_name": "tools.tiffmedian",
        "signature": "tools.tiffmedian.map_colortable(void)",
        "snippet": "static void\nmap_colortable(void)\n{\n\tregister uint32 *histp = &histogram[0][0][0];\n\tregister C_cell *cell;\n\tregister int j, tmp, d2, dist;\n\tint ir, ig, ib, i;\n\n\tfor (ir = 0; ir < B_LEN; ++ir)\n\t\tfor (ig = 0; ig < B_LEN; ++ig)\n\t\t\tfor (ib = 0; ib < B_LEN; ++ib, histp++) {\n\t\t\t\tif (*histp == 0) {\n\t\t\t\t\t*histp = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcell = *(ColorCells +\n\t\t\t\t    (((ir>>(B_DEPTH-C_DEPTH)) << C_DEPTH*2) +\n\t\t\t\t    ((ig>>(B_DEPTH-C_DEPTH)) << C_DEPTH) +\n\t\t\t\t    (ib>>(B_DEPTH-C_DEPTH))));\n\t\t\t\tif (cell == NULL )\n\t\t\t\t\tcell = create_colorcell(\n\t\t\t\t\t    ir << COLOR_SHIFT,\n\t\t\t\t\t    ig << COLOR_SHIFT,\n\t\t\t\t\t    ib << COLOR_SHIFT);\n\t\t\t\tdist = 9999999;\n\t\t\t\tfor (i = 0; i < cell->num_ents &&\n\t\t\t\t    dist > cell->entries[i][1]; ++i) {\n\t\t\t\t\tj = cell->entries[i][0];\n\t\t\t\t\td2 = rm[j] - (ir << COLOR_SHIFT);\n\t\t\t\t\td2 *= d2;\n\t\t\t\t\ttmp = gm[j] - (ig << COLOR_SHIFT);\n\t\t\t\t\td2 += tmp*tmp;\n\t\t\t\t\ttmp = bm[j] - (ib << COLOR_SHIFT);\n\t\t\t\t\td2 += tmp*tmp;\n\t\t\t\t\tif (d2 < dist) {\n\t\t\t\t\t\tdist = d2;\n\t\t\t\t\t\t*histp = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n}",
        "begin_line": 734,
        "end_line": 774,
        "is_bug": false
    },
    {
        "name": "tools.tiffmedian.quant#781",
        "src_path": "tools/tiffmedian.c",
        "class_name": "tools.tiffmedian",
        "signature": "tools.tiffmedian.quant(TIFF* in, TIFF* out)",
        "snippet": "static void\nquant(TIFF* in, TIFF* out)\n{\n\tunsigned char\t*outline, *inputline;\n\tregister unsigned char\t*outptr, *inptr;\n\tregister uint32 i, j;\n\tregister int red, green, blue;\n\n\tinputline = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\n\toutline = (unsigned char *)_TIFFmalloc(imagewidth);\n\tfor (i = 0; i < imagelength; i++) {\n\t\tif (TIFFReadScanline(in, inputline, i, 0) <= 0)\n\t\t\tbreak;\n\t\tinptr = inputline;\n\t\toutptr = outline;\n\t\tfor (j = 0; j < imagewidth; j++) {\n\t\t\tred = *inptr++ >> COLOR_SHIFT;\n\t\t\tgreen = *inptr++ >> COLOR_SHIFT;\n\t\t\tblue = *inptr++ >> COLOR_SHIFT;\n\t\t\t*outptr++ = (unsigned char)histogram[red][green][blue];\n\t\t}\n\t\tif (TIFFWriteScanline(out, outline, i, 0) < 0)\n\t\t\tbreak;\n\t}\n\t_TIFFfree(inputline);\n\t_TIFFfree(outline);\n}",
        "begin_line": 781,
        "end_line": 807,
        "is_bug": false
    }
]