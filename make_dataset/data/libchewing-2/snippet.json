[
    {
        "name": "bopomofo.BopomofoIsEntering#689",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.BopomofoIsEntering(BopomofoData *pBopomofo)",
        "snippet": "int BopomofoIsEntering(BopomofoData *pBopomofo)\n{\n    int i;\n\n    if (pBopomofo->kbtype >= KB_HANYU_PINYIN) {\n        if (pBopomofo->pinYinData.keySeq[0])\n            return 1;\n    } else {\n        for (i = 0; i < BOPOMOFO_SIZE; i++)\n            if (pBopomofo->pho_inx[i])\n                return 1;\n    }\n    return 0;\n}",
        "begin_line": 689,
        "end_line": 702,
        "is_bug": false
    },
    {
        "name": "bopomofo.BopomofoPhoInput#629",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.BopomofoPhoInput(ChewingData *pgdata, int key)",
        "snippet": "int BopomofoPhoInput(ChewingData *pgdata, int key)\n{\n    BopomofoData *pBopomofo = &(pgdata->bopomofoData);\n\n    /* open symbol table */\n    if (key == '`') {\n        pgdata->bSelect = 1;\n        pgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;\n        HaninSymbolInput(pgdata);\n        return BOPOMOFO_OPEN_SYMBOL_TABLE;\n    }\n    switch (pBopomofo->kbtype) {\n    case KB_HSU:\n    case KB_DVORAK_HSU:\n        return HsuPhoInput(pgdata, key);\n        break;\n    case KB_ET26:\n        return ET26PhoInput(pgdata, key);\n        break;\n    case KB_DACHEN_CP26:\n        return DACHENCP26PhoInput(pgdata, key);\n        break;\n    case KB_HANYU_PINYIN:\n    case KB_THL_PINYIN:\n    case KB_MPS2_PINYIN:\n        return PinYinInput(pgdata, key);\n        break;\n    default:\n        return DefPhoInput(pgdata, key);\n    }\n    return BOPOMOFO_ERROR;\n}",
        "begin_line": 629,
        "end_line": 660,
        "is_bug": false
    },
    {
        "name": "bopomofo.BopomofoRemoveAll#682",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.BopomofoRemoveAll(BopomofoData *pBopomofo)",
        "snippet": "int BopomofoRemoveAll(BopomofoData *pBopomofo)\n{\n    memset(pBopomofo->pho_inx, 0, sizeof(pBopomofo->pho_inx));\n    memset(pBopomofo->pinYinData.keySeq, 0, sizeof(pBopomofo->pinYinData.keySeq));\n    return 0;\n}",
        "begin_line": 682,
        "end_line": 687,
        "is_bug": false
    },
    {
        "name": "bopomofo.BopomofoRemoveLast#663",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.BopomofoRemoveLast(BopomofoData *pBopomofo)",
        "snippet": "int BopomofoRemoveLast(BopomofoData *pBopomofo)\n{\n    int i;\n\n    if (pBopomofo->kbtype >= KB_HANYU_PINYIN) {\n        i = strlen(pBopomofo->pinYinData.keySeq);\n        pBopomofo->pinYinData.keySeq[i - 1] = '\\0';\n    } else {\n        for (i = 3; i >= 0; i--) {\n            if (pBopomofo->pho_inx[i]) {\n                pBopomofo->pho_inx[i] = 0;\n                return 0;\n            }\n        }\n    }\n    return 0;\n}",
        "begin_line": 663,
        "end_line": 679,
        "is_bug": false
    },
    {
        "name": "bopomofo.DefPhoInput#142",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.DefPhoInput(ChewingData *pgdata, int key)",
        "snippet": "static int DefPhoInput(ChewingData *pgdata, int key)\n{\n    BopomofoData *pBopomofo = &(pgdata->bopomofoData);\n    int type = 0, inx = 0;\n    int i;\n\n    if (IsDefPhoEndKey(key, pBopomofo->kbtype)) {\n        for (i = 0; i < BOPOMOFO_SIZE; ++i)\n            if (pBopomofo->pho_inx[i] != 0)\n                break;\n        if (i < BOPOMOFO_SIZE)\n            return EndKeyProcess(pgdata, key, 1);\n    } else {\n        pBopomofo->pho_inx[3] = 0;\n    }\n\n    /* decide if the key is a phone */\n    for (type = 0; type <= 3; type++) {\n        inx = PhoneInxFromKey(key, type, pBopomofo->kbtype, 1);\n        if (inx)\n            break;\n    }\n\n    /* the key is NOT a phone */\n    if (type > 3) {\n        return BOPOMOFO_KEY_ERROR;\n    }\n\n    /* fill the key into the phone buffer */\n    pBopomofo->pho_inx[type] = inx;\n    return BOPOMOFO_ABSORB;\n}",
        "begin_line": 142,
        "end_line": 173,
        "is_bug": false
    },
    {
        "name": "bopomofo.EndKeyProcess#94",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.EndKeyProcess(ChewingData *pgdata, int key, int searchTimes)",
        "snippet": "static int EndKeyProcess(ChewingData *pgdata, int key, int searchTimes)\n{\n    BopomofoData *pBopomofo = &(pgdata->bopomofoData);\n    uint16_t u16Pho, u16PhoAlt;\n    Phrase tempword;\n    int pho_inx;\n\n    if (pBopomofo->pho_inx[0] == 0 && pBopomofo->pho_inx[1] == 0 && pBopomofo->pho_inx[2] == 0 && pBopomofo->pho_inx[3] == 0) {\n        /*\n         * Special handle for space key (Indeed very special one).\n         * Un-break the situation that OnKeySpace() is not called,\n         * hence the Candidate window doesn't show up, because\n         * BOPOMOFO_NO_WORD is returned.\n         */\n        return (key == ' ') ? BOPOMOFO_KEY_ERROR : BOPOMOFO_NO_WORD;\n    }\n\n    pho_inx = PhoneInxFromKey(key, 3, pBopomofo->kbtype, searchTimes);\n    if (pBopomofo->pho_inx[3] == 0) {\n        pBopomofo->pho_inx[3] = pho_inx;\n        pBopomofo->pho_inx_alt[3] = pho_inx;\n    } else if (key != ' ') {\n        pBopomofo->pho_inx[3] = pho_inx;\n        pBopomofo->pho_inx_alt[3] = pho_inx;\n        return BOPOMOFO_NO_WORD;\n    }\n\n    u16Pho = UintFromPhoneInx(pBopomofo->pho_inx);\n    if (GetCharFirst(pgdata, &tempword, u16Pho) == 0) {\n        BopomofoRemoveAll(pBopomofo);\n        return BOPOMOFO_NO_WORD;\n    }\n\n    pBopomofo->phone = u16Pho;\n\n    if (pBopomofo->pho_inx_alt[0] == 0 && pBopomofo->pho_inx_alt[1] == 0 && pBopomofo->pho_inx_alt[2] == 0) {\n        /* no alternative phone, copy from default as alt */\n        pBopomofo->phoneAlt = u16Pho;\n    } else {\n        u16PhoAlt = UintFromPhoneInx(pBopomofo->pho_inx_alt);\n        pBopomofo->phoneAlt = u16PhoAlt;\n    }\n\n    memset(pBopomofo->pho_inx, 0, sizeof(pBopomofo->pho_inx));\n    memset(pBopomofo->pho_inx_alt, 0, sizeof(pBopomofo->pho_inx_alt));\n    return BOPOMOFO_COMMIT;\n}",
        "begin_line": 94,
        "end_line": 140,
        "is_bug": false
    },
    {
        "name": "bopomofo.IsDefPhoEndKey#84",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.IsDefPhoEndKey(int key, int kbtype)",
        "snippet": "static int IsDefPhoEndKey(int key, int kbtype)\n{\n    if (PhoneInxFromKey(key, 3, kbtype, 1))\n        return 1;\n\n    if (key == ' ')\n        return 1;\n    return 0;\n}",
        "begin_line": 84,
        "end_line": 92,
        "is_bug": false
    },
    {
        "name": "chewing-sql.ConfigDatabase#284",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.ConfigDatabase(ChewingData *pgdata)",
        "snippet": "static int ConfigDatabase(ChewingData *pgdata)\n{\n    int ret;\n\n    assert(pgdata);\n    assert(pgdata->static_data.db);\n\n    ret = sqlite3_exec(pgdata->static_data.db, \"PRAGMA synchronous=OFF\", NULL, NULL, NULL);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot set synchronous=OFF, error = %d\", ret);\n        return -1;\n    }\n\n    return 0;\n}",
        "begin_line": 284,
        "end_line": 298,
        "is_bug": false
    },
    {
        "name": "chewing-sql.CreateStmt#300",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.CreateStmt(ChewingData *pgdata)",
        "snippet": "static int CreateStmt(ChewingData *pgdata)\n{\n    size_t i;\n    int ret;\n\n    assert(pgdata);\n\n    STATIC_ASSERT(ARRAY_SIZE(SQL_STMT_CONFIG) == ARRAY_SIZE(pgdata->static_data.stmt_config));\n    STATIC_ASSERT(ARRAY_SIZE(SQL_STMT_USERPHRASE) == ARRAY_SIZE(pgdata->static_data.stmt_userphrase));\n\n    for (i = 0; i < ARRAY_SIZE(SQL_STMT_CONFIG); ++i) {\n        ret = sqlite3_prepare_v2(pgdata->static_data.db,\n                                 SQL_STMT_CONFIG[i].stmt, -1, &pgdata->static_data.stmt_config[i], NULL);\n        if (ret != SQLITE_OK) {\n            LOG_ERROR(\"Cannot create stmt %s\", SQL_STMT_CONFIG[i].stmt);\n            return -1;\n        }\n    }\n\n    for (i = 0; i < ARRAY_SIZE(SQL_STMT_USERPHRASE); ++i) {\n        ret = sqlite3_prepare_v2(pgdata->static_data.db,\n                                 SQL_STMT_USERPHRASE[i].stmt, -1, &pgdata->static_data.stmt_userphrase[i], NULL);\n        if (ret != SQLITE_OK) {\n            LOG_ERROR(\"Cannot create stmt %s\", SQL_STMT_USERPHRASE[i].stmt);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
        "begin_line": 300,
        "end_line": 329,
        "is_bug": false
    },
    {
        "name": "chewing-sql.CreateTable#113",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.CreateTable(ChewingData *pgdata)",
        "snippet": "static int CreateTable(ChewingData *pgdata)\n{\n    int ret;\n\n    STATIC_ASSERT(MAX_PHRASE_LEN == 11);\n\n    ret = sqlite3_exec(pgdata->static_data.db,\n                       \"CREATE TABLE IF NOT EXISTS userphrase_v1 (\"\n                       \"time INTEGER,\"\n                       \"user_freq INTEGER,\"\n                       \"max_freq INTEGER,\"\n                       \"orig_freq INTEGER,\"\n                       \"length INTEGER,\"\n                       \"phone_0 INTEGER,\"\n                       \"phone_1 INTEGER,\"\n                       \"phone_2 INTEGER,\"\n                       \"phone_3 INTEGER,\"\n                       \"phone_4 INTEGER,\"\n                       \"phone_5 INTEGER,\"\n                       \"phone_6 INTEGER,\"\n                       \"phone_7 INTEGER,\"\n                       \"phone_8 INTEGER,\"\n                       \"phone_9 INTEGER,\"\n                       \"phone_10 INTEGER,\"\n                       \"phrase TEXT,\"\n                       \"PRIMARY KEY (\"\n                       \"phone_0,\"\n                       \"phone_1,\"\n                       \"phone_2,\"\n                       \"phone_3,\"\n                       \"phone_4,\"\n                       \"phone_5,\"\n                       \"phone_6,\"\n                       \"phone_7,\"\n                       \"phone_8,\"\n                       \"phone_9,\"\n                       \"phone_10,\"\n                       \"phrase)\" \")\", NULL, NULL, NULL);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot create table userphrase_v1, error = %d\", ret);\n        return -1;\n    }\n\n    ret = sqlite3_exec(pgdata->static_data.db,\n                       \"CREATE TABLE IF NOT EXISTS config_v1 (\"\n                       \"id INTEGER,\"\n                       \"value INTEGER,\"\n                       \"PRIMARY KEY (id)\" \")\", NULL, NULL, NULL);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot create table config_v1, error = %d\", ret);\n        return -1;\n    }\n\n    return 0;\n}",
        "begin_line": 113,
        "end_line": 167,
        "is_bug": false
    },
    {
        "name": "chewing-sql.GetSQLiteInstance#94",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.GetSQLiteInstance(ChewingData *pgdata, const char *path)",
        "snippet": "static sqlite3 *GetSQLiteInstance(ChewingData *pgdata, const char *path)\n{\n    int ret;\n    sqlite3 *db = NULL;\n\n    assert(pgdata);\n    assert(path);\n\n    ret = sqlite3_open(path, &db);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_open returns %d\", ret);\n        goto end;\n    }\n\n  end:\n    return db;\n}",
        "begin_line": 94,
        "end_line": 110,
        "is_bug": false
    },
    {
        "name": "chewing-sql.InitUserphrase#431",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.InitUserphrase(ChewingData *pgdata, const char *path)",
        "snippet": "int InitUserphrase(ChewingData *pgdata, const char *path)\n{\n    int ret;\n\n    assert(!pgdata->static_data.db);\n    assert(path);\n\n    pgdata->static_data.db = GetSQLiteInstance(pgdata, path);\n    if (!pgdata->static_data.db) {\n        LOG_ERROR(\"GetSQLiteInstance fails\");\n        goto error;\n    }\n\n    ret = ConfigDatabase(pgdata);\n    if (ret) {\n        LOG_ERROR(\"ConfigDatabase returns %d\", ret);\n        goto error;\n    }\n\n    ret = CreateTable(pgdata);\n    if (ret) {\n        LOG_ERROR(\"CreateTable returns %d\", ret);\n        goto error;\n    }\n\n    ret = CreateStmt(pgdata);\n    if (ret) {\n        LOG_ERROR(\"CreateStmt returns %d\", ret);\n        goto error;\n    }\n\n    ret = SetupUserphraseLifeTime(pgdata);\n    if (ret) {\n        LOG_ERROR(\"SetupUserphraseLiftTime returns %d\", ret);\n        goto error;\n    }\n\n    /* FIXME: Normalize lifttime when necessary. */\n\n    MigrateOldFormat(pgdata, path);\n\n    return 0;\n\n  error:\n    TerminateUserphrase(pgdata);\n    return -1;\n}",
        "begin_line": 431,
        "end_line": 477,
        "is_bug": false
    },
    {
        "name": "chewing-sql.MigrateOldFormat#331",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.MigrateOldFormat(ChewingData *pgdata, const char *path)",
        "snippet": "static void MigrateOldFormat(ChewingData *pgdata, const char *path)\n{\n    char *uhash;\n    char *old_uhash;\n    FILE *fd = NULL;\n    char buf[HASH_FIELD_SIZE];\n    uint16_t phoneSeq[MAX_PHRASE_LEN + 1];\n    char *pos;\n    int len;\n    int i;\n    int ret;\n\n    assert(pgdata);\n    assert(path);\n\n    len = strlen(path) + 1 + strlen(HASH_NAME) + 1;\n    uhash = calloc(sizeof(*uhash), len);\n    if (!uhash) {\n        LOG_ERROR(\"calloc returns %#p\", uhash);\n        exit(-1);\n    }\n    snprintf(uhash, len, \"%s\" PLAT_SEPARATOR \"%s\", path, HASH_NAME);\n\n    len = strlen(path) + 1 + strlen(HASH_OLD_NAME) + 1;\n    old_uhash = calloc(sizeof(*old_uhash), len);\n    if (!old_uhash) {\n        LOG_ERROR(\"calloc returns %#p\", old_uhash);\n        exit(-1);\n    }\n    snprintf(old_uhash, len, \"%s\" PLAT_SEPARATOR \"%s\", path, HASH_OLD_NAME);\n\n    /*\n     * The binary format is described as following:\n     *\n     * 0 ~ 3                signature (CBiH)\n     * 4 ~ 7                lifttime, platform endianness\n     * 8 ~ 8 + 125 * n      array of hash item, 125 bytes each\n     *\n     * 0 ~ 3                user frequency, platform endianness\n     * 4 ~ 7                recent time, platform endianness\n     * 8 ~ 11               max frequency, platform endianness\n     * 12 ~ 15              original frequency, platform endianness\n     * 16                   phone length\n     * 17 ~ 17 + 2 * n      phone sequence, uint16_t, platform endianness\n     * 17 + 2 * n + 1       phrase length in bytes\n     * 17 + 2 * n + 2 ~ y   phrase in UTF-8\n     *\n     */\n\n    fd = fopen(uhash, \"r\");\n    if (!fd)\n        goto end;\n\n    LOG_INFO(\"Migrate old format from %s\", uhash);\n    ret = fread(buf, 4, 1, fd);\n    if (ret != 1) {\n        LOG_WARN(\"fread returns %d\", ret);\n        goto end_remove_hash;\n    }\n\n    if (memcmp(buf, HASH_SIGS, 4) != 0) {\n        LOG_WARN(\"signature is not %d\", HASH_SIGS);\n        goto end_remove_hash;\n    }\n\n    ret = fseek(fd, 8, SEEK_SET);\n    if (ret) {\n        LOG_WARN(\"fseek returns %d\", ret);\n        goto end_remove_hash;\n    }\n\n    while (fread(buf, HASH_FIELD_SIZE, 1, fd) == 1) {\n        pos = &buf[HASH_LENGTH_OFFSET];\n        len = *pos;\n        ++pos;\n\n        if (len > MAX_PHRASE_LEN || len < 1) {\n            LOG_WARN(\"skip field due to len = %d\", len);\n            continue;\n        }\n\n        for (i = 0; i < len; ++i) {\n            phoneSeq[i] = GetUint16PreservedEndian(pos);\n            pos += 2;\n        }\n        phoneSeq[len] = 0;\n\n        ++pos;\n        UserUpdatePhrase(pgdata, phoneSeq, pos);\n    }\n\n  end_remove_hash:\n    if (fd)\n        fclose(fd);\n    PLAT_RENAME(uhash, old_uhash);\n  end:\n    free(old_uhash);\n    free(uhash);\n}",
        "begin_line": 331,
        "end_line": 429,
        "is_bug": false
    },
    {
        "name": "chewing-sql.SetupUserphraseLifeTime#169",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.SetupUserphraseLifeTime(ChewingData *pgdata)",
        "snippet": "static int SetupUserphraseLifeTime(ChewingData *pgdata)\n{\n    int ret;\n\n    assert(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT]);\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT], BIND_CONFIG_ID, CONFIG_ID_LIFETIME);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot bind ?%d to %d in stmt %s, error = %d\",\n                  BIND_CONFIG_ID, CONFIG_ID_LIFETIME, SQL_STMT_CONFIG[STMT_CONFIG_INSERT].stmt, ret);\n        return -1;\n    }\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT], BIND_CONFIG_VALUE, 0);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot bind ?%d to %d in stmt %s, error = %d\",\n                  BIND_CONFIG_VALUE, 0, SQL_STMT_CONFIG[STMT_CONFIG_INSERT].stmt, ret);\n        return -1;\n    }\n\n    ret = sqlite3_step(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT]);\n    if (ret != SQLITE_DONE) {\n        LOG_ERROR(\"sqlite3_step returns %d\", ret);\n        return -1;\n    }\n\n    ret = sqlite3_reset(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n        return -1;\n    }\n\n    assert(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT]);\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT], BIND_CONFIG_ID, CONFIG_ID_LIFETIME);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot bind ?%d to %d in stmt %s, error = %d\",\n                  BIND_CONFIG_ID, CONFIG_ID_LIFETIME, SQL_STMT_CONFIG[STMT_CONFIG_SELECT].stmt, ret);\n        return -1;\n    }\n\n    ret = sqlite3_step(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT]);\n    if (ret != SQLITE_ROW) {\n        LOG_ERROR(\"sqlite3_step returns %d\", ret);\n        return -1;\n    }\n\n    pgdata->static_data.original_lifetime = sqlite3_column_int(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT],\n                                                               SQL_STMT_CONFIG[STMT_CONFIG_SELECT].column\n                                                               [COLUMN_CONFIG_VALUE]);\n    pgdata->static_data.new_lifetime = pgdata->static_data.original_lifetime;\n\n    ret = sqlite3_reset(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n        return -1;\n    }\n\n    return 0;\n}",
        "begin_line": 169,
        "end_line": 228,
        "is_bug": false
    },
    {
        "name": "chewing-sql.TerminateUserphrase#479",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.TerminateUserphrase(ChewingData *pgdata)",
        "snippet": "void TerminateUserphrase(ChewingData *pgdata)\n{\n    size_t i;\n    int ret;\n\n    UpdateLifeTime(pgdata);\n\n    for (i = 0; i < ARRAY_SIZE(pgdata->static_data.stmt_config); ++i) {\n        sqlite3_finalize(pgdata->static_data.stmt_config[i]);\n        pgdata->static_data.stmt_config[i] = NULL;\n    }\n\n    for (i = 0; i < ARRAY_SIZE(pgdata->static_data.stmt_userphrase); ++i) {\n        sqlite3_finalize(pgdata->static_data.stmt_userphrase[i]);\n        pgdata->static_data.stmt_userphrase[i] = NULL;\n    }\n\n    ret = sqlite3_close(pgdata->static_data.db);\n    assert(SQLITE_OK == ret);\n    pgdata->static_data.db = NULL;\n}",
        "begin_line": 479,
        "end_line": 499,
        "is_bug": false
    },
    {
        "name": "chewing-sql.UpdateLifeTime#230",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.UpdateLifeTime(ChewingData *pgdata)",
        "snippet": "static int UpdateLifeTime(ChewingData *pgdata)\n{\n    int ret;\n    int result = 0;\n\n    if (!pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE]) {\n        LOG_ERROR(\"pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE] is NULL\");\n        result = -1;\n        goto end;\n    }\n\n    ret = sqlite3_clear_bindings(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_clear_bindings returns %d\", ret);\n        result = -1;\n        goto end;\n    }\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE], BIND_CONFIG_ID, CONFIG_ID_LIFETIME);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot bind ?%d to %d in stmt %s, error = %d\",\n                  BIND_CONFIG_ID, CONFIG_ID_LIFETIME, SQL_STMT_CONFIG[STMT_CONFIG_INCREASE].stmt, ret);\n        result = -1;\n        goto end;\n    }\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE],\n                           BIND_CONFIG_VALUE, pgdata->static_data.new_lifetime - pgdata->static_data.original_lifetime);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot bind ?%d to %d in stmt %s, error = %d\",\n                  BIND_CONFIG_VALUE,\n                  pgdata->static_data.new_lifetime - pgdata->static_data.original_lifetime,\n                  SQL_STMT_CONFIG[STMT_CONFIG_INCREASE].stmt, ret);\n        result = -1;\n        goto end;\n    }\n\n    ret = sqlite3_step(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE]);\n    if (ret != SQLITE_DONE) {\n        LOG_ERROR(\"sqlite3_step returns %d\", ret);\n        result = -1;\n        goto end;\n    }\n\n  end:\n    ret = sqlite3_reset(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n        result = -1;\n    }\n\n    return result;\n}",
        "begin_line": 230,
        "end_line": 282,
        "is_bug": false
    },
    {
        "name": "chewingio.CheckAndResetRange#775",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.CheckAndResetRange(ChewingData *pgdata)",
        "snippet": "static void CheckAndResetRange(ChewingData *pgdata)\n{\n    if (pgdata->PointStart > -1) {\n        pgdata->PointStart = -1;\n        pgdata->PointEnd = 0;\n    }\n}",
        "begin_line": 775,
        "end_line": 781,
        "is_bug": false
    },
    {
        "name": "chewingio.DoSelect#813",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.DoSelect(ChewingData *pgdata, int num)",
        "snippet": "static void DoSelect(ChewingData *pgdata, int num)\n{\n    assert(pgdata->choiceInfo.pageNo >= 0);\n    if (num >= 0 && num < pgdata->choiceInfo.nChoicePerPage) {\n        num += pgdata->choiceInfo.pageNo * pgdata->choiceInfo.nChoicePerPage;\n        SelectCandidate(pgdata, num);\n    }\n}",
        "begin_line": 813,
        "end_line": 820,
        "is_bug": false
    },
    {
        "name": "chewingio.NullLogger#141",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.NullLogger(void *data UNUSED, int level UNUSED, const char *fmt UNUSED, ...)",
        "snippet": "static void NullLogger(void *data UNUSED, int level UNUSED, const char *fmt UNUSED, ...)\n{\n}",
        "begin_line": 141,
        "end_line": 143,
        "is_bug": false
    },
    {
        "name": "chewingio.SelectCandidate#783",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.SelectCandidate(ChewingData *pgdata, int num)",
        "snippet": "static int SelectCandidate(ChewingData *pgdata, int num)\n{\n    assert(pgdata);\n    assert(pgdata->choiceInfo.pageNo >= 0);\n\n    if (0 <= num && num < pgdata->choiceInfo.nTotalChoice) {\n        if (pgdata->choiceInfo.isSymbol != WORD_CHOICE) {\n            SymbolChoice(pgdata, num);\n        } else {\n            /* change the select interval & selectStr & nSelect */\n            AddSelect(pgdata, num);\n            /* second, call choice module */\n            ChoiceSelect(pgdata, num);\n            /* automatically shift the cursor to next phrase */\n            if (pgdata->config.bAutoShiftCur != 0 &&\n                /* if cursor at end of string, do not shift the cursor. */\n                pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen) {\n                if (pgdata->config.bPhraseChoiceRearward) {\n                    ++pgdata->chiSymbolCursor;\n                } else {\n                    pgdata->chiSymbolCursor += pgdata->availInfo.avail[pgdata->availInfo.currentAvail].len;\n                }\n            }\n        }\n        return 0;\n    }\n\n    return -1;\n}",
        "begin_line": 783,
        "end_line": 811,
        "is_bug": false
    },
    {
        "name": "chewingio.allocate_ChewingData#145",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.allocate_ChewingData(void (*logger) (void *data, int level, const char *fmt, ...), void *loggerdata)",
        "snippet": "static ChewingData *allocate_ChewingData(void (*logger) (void *data, int level, const char *fmt, ...), void *loggerdata)\n{\n    static const int DEFAULT_SELKEY[] = { '1', '2', '3', '4', '5', '6', '7', '8', '9', '0' };\n\n    ChewingData *data = ALC(ChewingData, 1);\n\n    if (data) {\n        data->config.candPerPage = MAX_SELKEY;\n        data->config.maxChiSymbolLen = MAX_CHI_SYMBOL_LEN;\n        data->logger = logger;\n        data->loggerData = loggerdata;\n        memcpy(data->config.selKey, DEFAULT_SELKEY, sizeof(data->config.selKey));\n    }\n\n    return data;\n}",
        "begin_line": 145,
        "end_line": 160,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_Reset#292",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_Reset(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_Reset(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingStaticData static_data;\n    ChewingConfigData old_config;\n    void (*logger) (void *data, int level, const char *fmt, ...);\n    void *loggerData;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    /* Backup old config and restore it after clearing pgdata structure. */\n    old_config = pgdata->config;\n    static_data = pgdata->static_data;\n    logger = pgdata->logger;\n    loggerData = pgdata->loggerData;\n    memset(pgdata, 0, sizeof(ChewingData));\n    pgdata->config = old_config;\n    pgdata->static_data = static_data;\n    pgdata->logger = logger;\n    pgdata->loggerData = loggerData;\n\n    /* bopomofoData */\n    memset(&(pgdata->bopomofoData), 0, sizeof(BopomofoData));\n\n    /* choiceInfo */\n    memset(&(pgdata->choiceInfo), 0, sizeof(ChoiceInfo));\n\n    pgdata->chiSymbolCursor = 0;\n    pgdata->chiSymbolBufLen = 0;\n    pgdata->nPhoneSeq = 0;\n    memset(pgdata->bUserArrCnnct, 0, sizeof(int) * (MAX_PHONE_SEQ_LEN + 1));\n    memset(pgdata->bUserArrBrkpt, 0, sizeof(int) * (MAX_PHONE_SEQ_LEN + 1));\n    pgdata->bChiSym = CHINESE_MODE;\n    pgdata->bFullShape = HALFSHAPE_MODE;\n    pgdata->bSelect = 0;\n    pgdata->nSelect = 0;\n    pgdata->PointStart = -1;\n    pgdata->PointEnd = 0;\n    pgdata->phrOut.nNumCut = 0;\n    return 0;\n}",
        "begin_line": 292,
        "end_line": 337,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_cand_close#2189",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_cand_close(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_cand_close(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    if (ctx->data->bSelect) {\n        ChoiceEndChoice(ctx->data);\n    }\n\n    return 0;\n\n}",
        "begin_line": 2189,
        "end_line": 2206,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_delete#387",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_delete(ChewingContext *ctx)",
        "snippet": "CHEWING_API void chewing_delete(ChewingContext *ctx)\n{\n    if (ctx) {\n        if (ctx->data) {\n            TerminatePinyin(ctx->data);\n            TerminateEasySymbolTable(ctx->data);\n            TerminateSymbolTable(ctx->data);\n            TerminateUserphrase(ctx->data);\n            TerminateTree(ctx->data);\n            TerminateDict(ctx->data);\n            free(ctx->data);\n        }\n\n        if (ctx->output)\n            free(ctx->output);\n        free(ctx);\n    }\n    return;\n}",
        "begin_line": 387,
        "end_line": 405,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_free#407",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_free(void *p)",
        "snippet": "CHEWING_API void chewing_free(void *p)\n{\n    free(p);\n}",
        "begin_line": 407,
        "end_line": 410,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_get_ChiEngMode#703",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_get_ChiEngMode(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_get_ChiEngMode(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"bChiSym = %d\", ctx->data->bChiSym);\n\n    return ctx->data->bChiSym;\n}",
        "begin_line": 703,
        "end_line": 715,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_get_ShapeMode#732",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_get_ShapeMode(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_get_ShapeMode(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"ctx->data->bFullShape = %d\", ctx->data->bFullShape);\n\n    return ctx->data->bFullShape;\n}",
        "begin_line": 732,
        "end_line": 744,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Backspace#976",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Backspace(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_Backspace(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    CheckAndResetRange(pgdata);\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    }\n\n    if (!pgdata->bSelect) {\n        if (BopomofoIsEntering(&(pgdata->bopomofoData))) {\n            BopomofoRemoveLast(&(pgdata->bopomofoData));\n        } else if (pgdata->chiSymbolCursor > 0) {\n            ChewingKillChar(pgdata, pgdata->chiSymbolCursor - 1, DECREASE_CURSOR);\n        }\n        CallPhrasing(pgdata, 0);\n    } else if (pgdata->bSelect) {\n        chewing_cand_close(ctx);\n    }\n\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 976,
        "end_line": 1009,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Capslock#1301",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Capslock(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_Capslock(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    chewing_set_ChiEngMode(ctx, 1 - chewing_get_ChiEngMode(ctx));\n    MakeOutputWithRtn(pgo, pgdata, KEYSTROKE_ABSORB);\n    return 0;\n}",
        "begin_line": 1301,
        "end_line": 1317,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_CtrlNum#1659",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_CtrlNum(ChewingContext *ctx, int key)",
        "snippet": "CHEWING_API int chewing_handle_CtrlNum(ChewingContext *ctx, int key)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n    int newPhraseLen;\n    int i;\n    uint16_t addPhoneSeq[MAX_PHONE_SEQ_LEN];\n    char addWordSeq[MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1];\n    int phraseState;\n    int cursor;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    CheckAndResetRange(pgdata);\n\n    if (pgdata->bSelect)\n        return 0;\n\n    CallPhrasing(pgdata, 0);\n    newPhraseLen = key - '0';\n\n    if (key == '0' || key == '1') {\n        pgdata->bSelect = 1;\n        pgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;\n\n        HaninSymbolInput(pgdata);\n        CallPhrasing(pgdata, 0);\n        MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n        return 0;\n    }\n\n    cursor = PhoneSeqCursor(pgdata);\n    if (!pgdata->config.bAddPhraseForward) {\n        if (newPhraseLen >= 1 && cursor + newPhraseLen - 1 <= pgdata->nPhoneSeq) {\n            if (NoSymbolBetween(pgdata, cursor, cursor + newPhraseLen)) {\n                /* Manually add phrase to the user phrase database. */\n                memcpy(addPhoneSeq, &pgdata->phoneSeq[cursor], sizeof(uint16_t) * newPhraseLen);\n                addPhoneSeq[newPhraseLen] = 0;\n\n                copyStringFromPreeditBuf(pgdata, cursor, newPhraseLen, addWordSeq, sizeof(addWordSeq));\n\n                phraseState = UserUpdatePhrase(pgdata, addPhoneSeq, addWordSeq);\n                SetUpdatePhraseMsg(pgdata, addWordSeq, newPhraseLen, phraseState);\n\n                /* Clear the breakpoint between the New Phrase */\n                for (i = 1; i < newPhraseLen; i++)\n                    pgdata->bUserArrBrkpt[cursor + i] = 0;\n            }\n        }\n    } else {\n        if (newPhraseLen >= 1 && cursor - newPhraseLen >= 0) {\n            if (NoSymbolBetween(pgdata, cursor - newPhraseLen, cursor)) {\n                /* Manually add phrase to the user phrase database. */\n                memcpy(addPhoneSeq, &pgdata->phoneSeq[cursor - newPhraseLen], sizeof(uint16_t) * newPhraseLen);\n                addPhoneSeq[newPhraseLen] = 0;\n\n                copyStringFromPreeditBuf(pgdata, cursor - newPhraseLen, newPhraseLen, addWordSeq, sizeof(addWordSeq));\n\n                phraseState = UserUpdatePhrase(pgdata, addPhoneSeq, addWordSeq);\n                SetUpdatePhraseMsg(pgdata, addWordSeq, newPhraseLen, phraseState);\n\n                /* Clear the breakpoint between the New Phrase */\n                for (i = 1; i < newPhraseLen; i++)\n                    pgdata->bUserArrBrkpt[cursor - newPhraseLen + i] = 0;\n            }\n        }\n    }\n    CallPhrasing(pgdata, 0);\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    MakeOutputAddMsgAndCleanInterval(pgo, pgdata);\n    return 0;\n}",
        "begin_line": 1659,
        "end_line": 1737,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_DblTab#1268",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_DblTab(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_DblTab(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n    int cursor;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    CheckAndResetRange(pgdata);\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    }\n\n    if (!pgdata->bSelect) {\n        cursor = PhoneSeqCursor(pgdata);\n        pgdata->bUserArrBrkpt[cursor] = 0;\n        pgdata->bUserArrCnnct[cursor] = 0;\n    }\n    CallPhrasing(pgdata, 0);\n\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1268,
        "end_line": 1298,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Default#1462",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Default(ChewingContext *ctx, int key)",
        "snippet": "CHEWING_API int chewing_handle_Default(ChewingContext *ctx, int key)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n    int rtn;\n    int num;\n    int bQuickCommit = 0;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"key = %d\", key);\n\n    /* Update lifetime */\n    IncreaseLifeTime(ctx->data);\n\n    /* Skip the special key */\n    if (key & 0xFF00) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n        goto End_KeyDefault;\n    }\n\n    /* We ignore non-printable input */\n    if (!isprint(key))\n        goto End_KeyDefault;\n\n    CheckAndResetRange(pgdata);\n\n    DEBUG_CHECKPOINT();\n    DEBUG_OUT(\"   key=%d\", key);\n\n    /* Dvorak Hsu */\n    if (pgdata->bopomofoData.kbtype == KB_DVORAK_HSU) {\n        key = dvorak_convert(key);\n    }\n\n    /* selecting */\n    if (pgdata->bSelect) {\n        if (key == ' ')\n            return chewing_handle_Right(ctx);\n        /* num starts from 0 */\n        num = CountSelKeyNum(key, pgdata);\n        if (num >= 0) {\n            DoSelect(pgdata, num);\n            goto End_keyproc;\n        }\n\n        /* Otherwise, use 'j' and 'k' for paging in selection mode */\n        DEBUG_OUT(\"\\t\\tchecking paging key, got '%c'\\n\", key);\n        switch (key) {\n        case 'j':\n        case 'J':\n            if (pgdata->chiSymbolCursor > 0) {\n                if (!ChewingIsEntering(pgdata)) {\n                    keystrokeRtn = KEYSTROKE_IGNORE;\n                }\n                CheckAndResetRange(pgdata);\n                pgdata->chiSymbolCursor--;\n                if (ChewingIsChiAt(pgdata->chiSymbolCursor, pgdata))\n                    ChoiceInitAvail(pgdata);\n                else\n                    OpenSymbolChoice(pgdata);\n\n            }\n            goto End_Paging;\n        case 'k':\n        case 'K':\n            if (pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen) {\n                if (!ChewingIsEntering(pgdata)) {\n                    keystrokeRtn = KEYSTROKE_IGNORE;\n                }\n                CheckAndResetRange(pgdata);\n                pgdata->chiSymbolCursor++;\n                if (ChewingIsChiAt(pgdata->chiSymbolCursor, pgdata))\n                    ChoiceInitAvail(pgdata);\n                else\n                    OpenSymbolChoice(pgdata);\n            }\n            goto End_Paging;\n        default:\n            break;\n        }\n    }\n    /* editing */\n    else {\n        if (pgdata->bChiSym == CHINESE_MODE) {\n            if (pgdata->config.bEasySymbolInput != 0) {\n                EasySymbolInput(key, pgdata);\n                goto End_keyproc;\n            }\n\n            rtn = BopomofoPhoInput(pgdata, key);\n            DEBUG_OUT(\"\\t\\tChinese mode key, \" \"BopomofoPhoInput return value = %d\\n\", rtn);\n\n            if (rtn == BOPOMOFO_KEY_ERROR)\n                rtn = SpecialSymbolInput(key, pgdata);\n            switch (rtn) {\n            case BOPOMOFO_ABSORB:\n                keystrokeRtn = KEYSTROKE_ABSORB;\n                break;\n            case BOPOMOFO_COMMIT:\n                AddChi(pgdata->bopomofoData.phone, pgdata->bopomofoData.phoneAlt, pgdata);\n                break;\n            case BOPOMOFO_NO_WORD:\n                keystrokeRtn = KEYSTROKE_BELL | KEYSTROKE_ABSORB;\n                break;\n            case BOPOMOFO_KEY_ERROR:\n            case BOPOMOFO_IGNORE:\n                DEBUG_OUT(\"\\t\\tbefore isupper(key),key=%d\\n\", key);\n                /* change upper case into lower case */\n                if (isupper(key))\n                    key = tolower(key);\n\n                DEBUG_OUT(\"\\t\\tafter isupper(key),key=%d\\n\", key);\n\n                /* see if buffer contains nothing */\n                if (pgdata->chiSymbolBufLen == 0) {\n                    bQuickCommit = 1;\n                }\n\n                if (pgdata->config.bEasySymbolInput == 0) {\n                    if (pgdata->bFullShape)\n                        rtn = FullShapeSymbolInput(key, pgdata);\n                    else\n                        rtn = SymbolInput(key, pgdata);\n                }\n\n                if (rtn == SYMBOL_KEY_ERROR) {\n                    keystrokeRtn = KEYSTROKE_IGNORE;\n                    /*\n                     * If the key is not a printable symbol,\n                     * then it's wrong to commit it.\n                     */\n                    bQuickCommit = 0;\n                } else\n                    keystrokeRtn = KEYSTROKE_ABSORB;\n\n                break;\n            default:\n                goto End_KeyDefault;\n            }\n        }\n        /* English mode */\n        else {\n            /* see if buffer contains nothing */\n            if (pgdata->chiSymbolBufLen == 0) {\n                bQuickCommit = 1;\n            }\n            if (pgdata->bFullShape) {\n                rtn = FullShapeSymbolInput(key, pgdata);\n            } else {\n                rtn = SymbolInput(key, pgdata);\n            }\n\n            if (rtn == SYMBOL_KEY_ERROR) {\n                keystrokeRtn = KEYSTROKE_IGNORE;\n                bQuickCommit = 0;\n            }\n        }\n    }\n\n  End_keyproc:\n    if (!bQuickCommit) {\n        CallPhrasing(pgdata, 0);\n        if (ReleaseChiSymbolBuf(pgdata, pgo) != 0)\n            keystrokeRtn = KEYSTROKE_COMMIT;\n    }\n    /* Quick commit */\n    else {\n        DEBUG_OUT(\"\\t\\tQuick commit buf[0]=%c\\n\", pgdata->preeditBuf[0].char_);\n        WriteChiSymbolToCommitBuf(pgdata, pgo, 1);\n        pgdata->chiSymbolBufLen = 0;\n        pgdata->chiSymbolCursor = 0;\n        keystrokeRtn = KEYSTROKE_COMMIT;\n    }\n\n    if (pgdata->phrOut.nNumCut > 0) {\n        int i;\n\n        for (i = 0; i < pgdata->phrOut.nDispInterval; i++) {\n            pgdata->bUserArrBrkpt[pgdata->phrOut.dispInterval[i].from] = 1;\n            pgdata->bUserArrBrkpt[pgdata->phrOut.dispInterval[i].to] = 1;\n        }\n        pgdata->phrOut.nNumCut = 0;\n    }\n\n  End_KeyDefault:\n    CallPhrasing(pgdata, 0);\n  End_Paging:\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1462,
        "end_line": 1657,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Down#1046",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Down(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_Down(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int toSelect = 0;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n    int key_buf_cursor;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    CheckAndResetRange(pgdata);\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    }\n\n    key_buf_cursor = pgdata->chiSymbolCursor;\n    if (pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen && key_buf_cursor > 0)\n        key_buf_cursor--;\n\n    /* see if to select */\n    if (ChewingIsChiAt(key_buf_cursor, pgdata))\n        toSelect = 1;\n\n    chooseCandidate(ctx, toSelect, key_buf_cursor);\n\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1046,
        "end_line": 1080,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_End#1344",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_End(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_End(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    CheckAndResetRange(pgdata);\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    } else if (!pgdata->bSelect) {\n        pgdata->chiSymbolCursor = pgdata->chiSymbolBufLen;\n    }\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1344,
        "end_line": 1367,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Enter#891",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Enter(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_Enter(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int nCommitStr;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    nCommitStr = pgdata->chiSymbolBufLen;\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    } else if (pgdata->bSelect) {\n        keystrokeRtn = KEYSTROKE_ABSORB | KEYSTROKE_BELL;\n    } else if (pgdata->PointStart > -1) {\n        int buf = pgdata->chiSymbolCursor;\n        int key = '0';\n\n        if (pgdata->PointEnd > 1) {\n            if (!pgdata->config.bAddPhraseForward) {\n                pgdata->chiSymbolCursor = pgdata->PointStart;\n            } else {\n                pgdata->chiSymbolCursor = pgdata->PointStart + pgdata->PointEnd;\n            }\n            key = '0' + pgdata->PointEnd;\n        } else if (pgdata->PointEnd < 1) {\n            if (pgdata->config.bAddPhraseForward)\n                pgdata->chiSymbolCursor = buf - pgdata->PointEnd;\n            key = '0' - pgdata->PointEnd;\n        }\n        chewing_handle_CtrlNum(ctx, key);\n        pgdata->chiSymbolCursor = buf;\n        pgdata->PointStart = -1;\n        pgdata->PointEnd = 0;\n    } else {\n        keystrokeRtn = KEYSTROKE_COMMIT;\n        WriteChiSymbolToCommitBuf(pgdata, pgo, nCommitStr);\n        if (!pgdata->config.bAutoLearn) {\n            AutoLearnPhrase(pgdata);\n        }\n        CleanAllBuf(pgdata);\n        pgo->commitBufLen = nCommitStr;\n    }\n\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 891,
        "end_line": 944,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Esc#860",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Esc(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_Esc(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    CheckAndResetRange(pgdata);\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    } else if (pgdata->bSelect) {\n        ChoiceEndChoice(pgdata);\n    } else if (BopomofoIsEntering(&(pgdata->bopomofoData))) {\n        BopomofoRemoveAll(&(pgdata->bopomofoData));\n    } else if (pgdata->config.bEscCleanAllBuf) {\n        CleanAllBuf(pgdata);\n        pgo->commitBufLen = pgdata->chiSymbolBufLen;\n    }\n\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 860,
        "end_line": 889,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Home#1319",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Home(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_Home(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    CheckAndResetRange(pgdata);\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    } else if (!pgdata->bSelect) {\n        pgdata->chiSymbolCursor = 0;\n    }\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1319,
        "end_line": 1342,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Left#1118",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Left(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_Left(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    }\n\n    if (pgdata->bSelect) {\n        assert(pgdata->choiceInfo.nPage > 0);\n        if (pgdata->choiceInfo.pageNo > 0)\n            pgdata->choiceInfo.pageNo--;\n        else\n            pgdata->choiceInfo.pageNo = pgdata->choiceInfo.nPage - 1;\n    } else {\n        if (!BopomofoIsEntering(&(pgdata->bopomofoData)) && pgdata->chiSymbolCursor > 0) {\n            CheckAndResetRange(pgdata);\n            pgdata->chiSymbolCursor--;\n        }\n    }\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1118,
        "end_line": 1150,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Numlock#1764",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Numlock(ChewingContext *ctx, int key)",
        "snippet": "CHEWING_API int chewing_handle_Numlock(ChewingContext *ctx, int key)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n    int rtn;\n    int QuickCommit = 0;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    if (!pgdata->bSelect) {\n        /* If we're not selecting words, we should send out numeric\n         * characters at once.\n         */\n        if (pgdata->chiSymbolBufLen == 0) {\n            QuickCommit = 1;\n        }\n        rtn = SymbolInput(key, pgdata);\n        /* copied from chewing_handle_Default */\n        if (rtn == SYMBOL_KEY_ERROR) {\n            keystrokeRtn = KEYSTROKE_IGNORE;\n        } else if (QuickCommit) {\n            WriteChiSymbolToCommitBuf(pgdata, pgo, 1);\n            pgdata->chiSymbolBufLen = 0;\n            pgdata->chiSymbolCursor = 0;\n            keystrokeRtn = KEYSTROKE_COMMIT;\n        } else {                /* Not quick commit */\n            CallPhrasing(pgdata, 0);\n            if (ReleaseChiSymbolBuf(pgdata, pgo) != 0)\n                keystrokeRtn = KEYSTROKE_COMMIT;\n        }\n    } else {\n        /* Otherwise, if we are selecting words, we use numeric keys\n         * as selkey\n         * and submit the words.\n         */\n        int num = -1;\n\n        if (key > '0' && key <= '9')\n            num = key - '1';\n        else if (key == '0')\n            num = 9;\n        DoSelect(pgdata, num);\n    }\n    CallPhrasing(pgdata, 0);\n    if (ReleaseChiSymbolBuf(pgdata, pgo) != 0)\n        keystrokeRtn = KEYSTROKE_COMMIT;\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1764,
        "end_line": 1819,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Right#1190",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Right(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_Right(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    }\n\n    if (pgdata->bSelect) {\n        if (pgdata->choiceInfo.pageNo < pgdata->choiceInfo.nPage - 1)\n            pgdata->choiceInfo.pageNo++;\n        else\n            pgdata->choiceInfo.pageNo = 0;\n    } else {\n        if (!BopomofoIsEntering(&(pgdata->bopomofoData)) && pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen) {\n            CheckAndResetRange(pgdata);\n            pgdata->chiSymbolCursor++;\n        }\n    }\n\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1190,
        "end_line": 1222,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_ShiftLeft#1083",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_ShiftLeft(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_ShiftLeft(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    }\n    if (!pgdata->bSelect) {\n        /*  PointEnd locates (-9, +9) */\n        if (!BopomofoIsEntering(&(pgdata->bopomofoData)) && pgdata->chiSymbolCursor > 0 && pgdata->PointEnd > -9) {\n            if (pgdata->PointStart == -1)\n                pgdata->PointStart = pgdata->chiSymbolCursor;\n            pgdata->chiSymbolCursor--;\n            if (ChewingIsChiAt(pgdata->chiSymbolCursor, pgdata)) {\n                pgdata->PointEnd--;\n            }\n            if (pgdata->PointEnd == 0)\n                pgdata->PointStart = -1;\n        }\n    }\n\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1083,
        "end_line": 1116,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_ShiftRight#1153",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_ShiftRight(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_ShiftRight(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    }\n\n    if (!pgdata->bSelect) {\n        /* PointEnd locates (-9, +9) */\n        if (!BopomofoIsEntering(&(pgdata->bopomofoData)) &&\n            pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen && pgdata->PointEnd < 9) {\n            if (pgdata->PointStart == -1)\n                pgdata->PointStart = pgdata->chiSymbolCursor;\n            if (ChewingIsChiAt(pgdata->chiSymbolCursor, pgdata)) {\n                pgdata->PointEnd++;\n            }\n            pgdata->chiSymbolCursor++;\n            if (pgdata->PointEnd == 0)\n                pgdata->PointStart = -1;\n        }\n    }\n\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1153,
        "end_line": 1188,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_ShiftSpace#1739",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_ShiftSpace(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_ShiftSpace(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    if (!pgdata->bSelect) {\n        CheckAndResetRange(pgdata);\n    }\n\n    chewing_set_ShapeMode(ctx, 1 - chewing_get_ShapeMode(ctx));\n\n    CallPhrasing(pgdata, 0);\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1739,
        "end_line": 1762,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Space#822",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Space(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_Space(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    /*\n     * Use chewing_handle_Default( ctx, ' ' ) to handle space when:\n     * - \"space as selection\" mode is disable\n     * - mode is not CHINESE_MODE\n     * - has incompleted bopomofo (space is needed to complete it)\n     */\n    if (!pgdata->config.bSpaceAsSelection || pgdata->bChiSym != CHINESE_MODE || BopomofoIsEntering(&ctx->data->bopomofoData)) {\n        return chewing_handle_Default(ctx, ' ');\n    }\n\n    CheckAndResetRange(pgdata);\n\n    /*\n     * space = right when the follogin conditions are true\n     * 1. In select mode\n     * 2. The candidate page is not last page\n     *\n     * Otherwise, space = down\n     */\n    if (pgdata->bSelect && ctx->output->pci->pageNo < ctx->output->pci->nPage - 1) {\n        return chewing_handle_Right(ctx);\n    } else {\n        return chewing_handle_Down(ctx);\n    }\n    return 0;\n}",
        "begin_line": 822,
        "end_line": 858,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Tab#1224",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Tab(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_Tab(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n    int all_phrasing = 0;\n    int cursor;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    CheckAndResetRange(pgdata);\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    }\n\n\n    if (!pgdata->bSelect) {\n        if (pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen) {\n            pgdata->phrOut.nNumCut++;\n            all_phrasing = 1;\n        } else if (pgdata->chiSymbolCursor > 0 &&\n                   ChewingIsChiAt(pgdata->chiSymbolCursor - 1, pgdata)) {\n            cursor = PhoneSeqCursor(pgdata);\n            if (IsPreferIntervalConnted(cursor, pgdata)) {\n                pgdata->bUserArrBrkpt[cursor] = 1;\n                pgdata->bUserArrCnnct[cursor] = 0;\n            } else {\n                pgdata->bUserArrBrkpt[cursor] = 0;\n                pgdata->bUserArrCnnct[cursor] = 1;\n            }\n        }\n        CallPhrasing(pgdata, all_phrasing);\n    }\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1224,
        "end_line": 1266,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_ChiEngMode#684",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_ChiEngMode(ChewingContext *ctx, int mode)",
        "snippet": "CHEWING_API void chewing_set_ChiEngMode(ChewingContext *ctx, int mode)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"mode = %d\", mode);\n\n    if (mode == CHINESE_MODE || mode == SYMBOL_MODE) {\n        // remove all data inside buffer as switching mode.\n        BopomofoRemoveAll(&(ctx->data->bopomofoData));\n        MakeOutputWithRtn(ctx->output, ctx->data, KEYSTROKE_ABSORB);\n        ctx->data->bChiSym = mode;\n    }\n}",
        "begin_line": 684,
        "end_line": 701,
        "is_bug": true
    },
    {
        "name": "chewingio.chewing_set_ShapeMode#717",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_ShapeMode(ChewingContext *ctx, int mode)",
        "snippet": "CHEWING_API void chewing_set_ShapeMode(ChewingContext *ctx, int mode)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"mode = %d\", mode);\n\n    if (mode == HALFSHAPE_MODE || mode == FULLSHAPE_MODE)\n        ctx->data->bFullShape = mode;\n}",
        "begin_line": 717,
        "end_line": 730,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_addPhraseDirection#510",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_addPhraseDirection(ChewingContext *ctx, int direction)",
        "snippet": "CHEWING_API void chewing_set_addPhraseDirection(ChewingContext *ctx, int direction)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"direction = %d\", direction);\n\n    if (direction == 0 || direction == 1)\n        ctx->data->config.bAddPhraseForward = direction;\n}",
        "begin_line": 510,
        "end_line": 523,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_autoShiftCur#597",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_autoShiftCur(ChewingContext *ctx, int mode)",
        "snippet": "CHEWING_API void chewing_set_autoShiftCur(ChewingContext *ctx, int mode)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"mode = %d\", mode);\n\n    if (mode == 0 || mode == 1)\n        ctx->data->config.bAutoShiftCur = mode;\n}",
        "begin_line": 597,
        "end_line": 610,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_candPerPage#412",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_candPerPage(ChewingContext *ctx, int n)",
        "snippet": "CHEWING_API void chewing_set_candPerPage(ChewingContext *ctx, int n)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"n = %d\", n);\n\n    if (MIN_SELKEY <= n && n <= MAX_SELKEY && ctx->data->config.selKey[n - 1])\n        ctx->data->config.candPerPage = n;\n}",
        "begin_line": 412,
        "end_line": 425,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_logger#1853",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_logger(ChewingContext *ctx, void (*logger) (void *data, int level, const char *fmt, ...), void *data)",
        "snippet": "CHEWING_API void chewing_set_logger(ChewingContext *ctx,\n                                    void (*logger) (void *data, int level, const char *fmt, ...), void *data)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    if (!logger) {\n        logger = NullLogger;\n        data = 0;\n    }\n    ctx->data->logger = logger;\n    ctx->data->loggerData = data;\n}",
        "begin_line": 1853,
        "end_line": 1871,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_maxChiSymbolLen#441",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_maxChiSymbolLen(ChewingContext *ctx, int n)",
        "snippet": "CHEWING_API void chewing_set_maxChiSymbolLen(ChewingContext *ctx, int n)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"n = %d\", n);\n\n    if (MIN_CHI_SYMBOL_LEN <= n && n <= MAX_CHI_SYMBOL_LEN)\n        ctx->data->config.maxChiSymbolLen = n;\n}",
        "begin_line": 441,
        "end_line": 454,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_phraseChoiceRearward#655",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_phraseChoiceRearward(ChewingContext *ctx, int mode)",
        "snippet": "CHEWING_API void chewing_set_phraseChoiceRearward(ChewingContext *ctx, int mode)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"mode = %d\", mode);\n\n    if (mode == 0 || mode == 1)\n        ctx->data->config.bPhraseChoiceRearward = mode;\n}",
        "begin_line": 655,
        "end_line": 668,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_spaceAsSelection#539",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_spaceAsSelection(ChewingContext *ctx, int mode)",
        "snippet": "CHEWING_API void chewing_set_spaceAsSelection(ChewingContext *ctx, int mode)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"mode = %d\", mode);\n\n    if (mode == 0 || mode == 1)\n        ctx->data->config.bSpaceAsSelection = mode;\n}",
        "begin_line": 539,
        "end_line": 552,
        "is_bug": false
    },
    {
        "name": "chewingio.chooseCandidate#101",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chooseCandidate(ChewingContext *ctx, int toSelect, int key_buf_cursor)",
        "snippet": "static void chooseCandidate(ChewingContext *ctx, int toSelect, int key_buf_cursor)\n{\n    ChewingData *pgdata = ctx->data;\n\n    if (toSelect) {\n        if (!pgdata->bSelect) {\n            ChoiceInitAvail(pgdata);\n        } else {\n            if (ChoiceHasNextAvail(pgdata))\n                ChoiceNextAvail(pgdata);\n            else                /* rollover */\n                ChoiceFirstAvail(pgdata);\n        }\n    } else if (pgdata->symbolKeyBuf[key_buf_cursor]) {\n        /* Open Symbol Choice List */\n        if (pgdata->choiceInfo.isSymbol == WORD_CHOICE) {\n            OpenSymbolChoice(pgdata);\n        }\n        /**\n         * If these's only one candidate list available, ChoiceFirstAvail\n         * will re-open the list, namely turn back to the firt page.\n         * However, it doesn't work for symbols, therefore we\n         * set the page number to 0 directly.\n         */\n        else if (pgdata->bSelect) {\n            pgdata->choiceInfo.pageNo = 0;\n        }\n    } else {\n        /*\n         * The cursor position is not word, nor symbol. The only\n         * possible case is that user just uses ` to open symbol\n         * selection. In this case, when chooseCandidate is called,\n         * libchewing needs to reset pageNo to 0 to do rollover.\n         */\n        if (pgdata->bSelect) {\n            pgdata->choiceInfo.pageNo = 0;\n        }\n    }\n}",
        "begin_line": 101,
        "end_line": 139,
        "is_bug": false
    },
    {
        "name": "chewingutil.AddChi#646",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.AddChi(uint16_t phone, uint16_t phoneAlt, ChewingData *pgdata)",
        "snippet": "int AddChi(uint16_t phone, uint16_t phoneAlt, ChewingData *pgdata)\n{\n    int i;\n    int cursor = PhoneSeqCursor(pgdata);\n\n    /* shift the selectInterval */\n    for (i = 0; i < pgdata->nSelect; i++) {\n        if (pgdata->selectInterval[i].from >= cursor) {\n            pgdata->selectInterval[i].from++;\n            pgdata->selectInterval[i].to++;\n        }\n    }\n\n    /* shift the Brkpt */\n    assert(pgdata->nPhoneSeq >= cursor);\n    memmove(&(pgdata->bUserArrBrkpt[cursor + 2]),\n            &(pgdata->bUserArrBrkpt[cursor + 1]), sizeof(int) * (pgdata->nPhoneSeq - cursor));\n    memmove(&(pgdata->bUserArrCnnct[cursor + 2]),\n            &(pgdata->bUserArrCnnct[cursor + 1]), sizeof(int) * (pgdata->nPhoneSeq - cursor));\n\n    /* add to phoneSeq */\n    memmove(&(pgdata->phoneSeq[cursor + 1]),\n            &(pgdata->phoneSeq[cursor]), sizeof(uint16_t) * (pgdata->nPhoneSeq - cursor));\n    pgdata->phoneSeq[cursor] = phone;\n    memmove(&(pgdata->phoneSeqAlt[cursor + 1]),\n            &(pgdata->phoneSeqAlt[cursor]), sizeof(uint16_t) * (pgdata->nPhoneSeq - cursor));\n    pgdata->phoneSeqAlt[cursor] = phoneAlt;\n    pgdata->nPhoneSeq++;\n\n    /* add to chiSymbolBuf */\n    assert(pgdata->chiSymbolBufLen >= pgdata->chiSymbolCursor);\n    memmove(&(pgdata->preeditBuf[pgdata->chiSymbolCursor + 1]),\n            &(pgdata->preeditBuf[pgdata->chiSymbolCursor]),\n            sizeof(pgdata->preeditBuf[0]) * (pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));\n    /* \"0\" means Chinese word */\n    pgdata->preeditBuf[pgdata->chiSymbolCursor].category = CHEWING_CHINESE;\n    pgdata->chiSymbolBufLen++;\n    pgdata->chiSymbolCursor++;\n\n    return 0;\n}",
        "begin_line": 646,
        "end_line": 686,
        "is_bug": false
    },
    {
        "name": "chewingutil.AddSelect#895",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.AddSelect(ChewingData *pgdata, int sel_i)",
        "snippet": "int AddSelect(ChewingData *pgdata, int sel_i)\n{\n    int length, nSelect, cursor;\n\n    /* save the typing time */\n    length = pgdata->availInfo.avail[pgdata->availInfo.currentAvail].len;\n    nSelect = pgdata->nSelect;\n\n    /* change \"selectStr\" , \"selectInterval\" , and \"nSelect\" of ChewingData */\n    ueStrNCpy(pgdata->selectStr[nSelect], pgdata->choiceInfo.totalChoiceStr[sel_i], length, 1);\n    cursor = PhoneSeqCursor(pgdata);\n    pgdata->selectInterval[nSelect].from = cursor;\n    pgdata->selectInterval[nSelect].to = cursor + length;\n    pgdata->nSelect++;\n    return 0;\n}",
        "begin_line": 895,
        "end_line": 910,
        "is_bug": false
    },
    {
        "name": "chewingutil.AutoLearnPhrase#570",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.AutoLearnPhrase(ChewingData *pgdata)",
        "snippet": "void AutoLearnPhrase(ChewingData *pgdata)\n{\n    uint16_t bufPhoneSeq[MAX_PHONE_SEQ_LEN + 1];\n    char bufWordSeq[MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1] = { 0 };\n    char *pos;\n    int i;\n    int from;\n    int fromPreeditBuf;\n    int len;\n    int prev_pos = 0;\n    int pending_pos = 0;\n\n    /*\n     * FIXME: pgdata->preferInterval does not consider symbol, so we need to\n     * do translate when using APIs that considering symbol.\n     */\n\n    UserUpdatePhraseBegin(pgdata);\n\n    for (i = 0; i < pgdata->nPrefer; i++) {\n        from = pgdata->preferInterval[i].from;\n        len = pgdata->preferInterval[i].to - from;\n        fromPreeditBuf = toPreeditBufIndex(pgdata, from);\n\n        LOG_VERBOSE(\"interval from = %d, fromPreeditBuf = %d, len = %d, pending_pos = %d\", from, fromPreeditBuf, len,\n                    pending_pos);\n\n        if (pending_pos != 0 && pending_pos < fromPreeditBuf) {\n            /*\n             * There is a pending phrase in buffer and it is not\n             * connected to current phrase. We store it as\n             * userphrase here.\n             */\n            UserUpdatePhrase(pgdata, bufPhoneSeq, bufWordSeq);\n            prev_pos = 0;\n            pending_pos = 0;\n        }\n\n        if (len == 1 && !ChewingIsBreakPoint(fromPreeditBuf, pgdata)) {\n            /*\n             * There is a length one phrase and it is not a break\n             * point. We store it and try to connect to other length\n             * one phrase if possible.\n             */\n            memcpy(bufPhoneSeq + prev_pos, &pgdata->phoneSeq[from], sizeof(uint16_t) * len);\n            bufPhoneSeq[prev_pos + len] = (uint16_t) 0;\n\n            pos = ueStrSeek(bufWordSeq, prev_pos);\n            copyStringFromPreeditBuf(pgdata, fromPreeditBuf, len, pos, bufWordSeq + sizeof(bufWordSeq) - pos);\n            prev_pos += len;\n            pending_pos = fromPreeditBuf + len;\n\n        } else {\n            if (pending_pos) {\n                /*\n                 * Clean pending phrase because we cannot join\n                 * it with current phrase.\n                 */\n                UserUpdatePhrase(pgdata, bufPhoneSeq, bufWordSeq);\n                prev_pos = 0;\n                pending_pos = 0;\n            }\n            memcpy(bufPhoneSeq, &pgdata->phoneSeq[from], sizeof(uint16_t) * len);\n            bufPhoneSeq[len] = (uint16_t) 0;\n            copyStringFromPreeditBuf(pgdata, fromPreeditBuf, len, bufWordSeq, sizeof(bufWordSeq));\n            UserUpdatePhrase(pgdata, bufPhoneSeq, bufWordSeq);\n        }\n    }\n\n    if (pending_pos) {\n        UserUpdatePhrase(pgdata, bufPhoneSeq, bufWordSeq);\n    }\n\n    UserUpdatePhraseEnd(pgdata);\n}",
        "begin_line": 570,
        "end_line": 644,
        "is_bug": false
    },
    {
        "name": "chewingutil.CallPhrasing#719",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.CallPhrasing(ChewingData *pgdata, int all_phrasing)",
        "snippet": "int CallPhrasing(ChewingData *pgdata, int all_phrasing)\n{\n    /* set \"bSymbolArrBrkpt\" && \"bArrBrkpt\" */\n    int i, ch_count = 0;\n\n    memcpy(pgdata->bArrBrkpt, pgdata->bUserArrBrkpt, (MAX_PHONE_SEQ_LEN + 1) * sizeof(int));\n    memset(pgdata->bSymbolArrBrkpt, 0, (MAX_PHONE_SEQ_LEN + 1) * sizeof(int));\n\n    for (i = 0; i < pgdata->chiSymbolBufLen; i++) {\n        if (ChewingIsChiAt(i, pgdata))\n            ch_count++;\n        else {\n            pgdata->bArrBrkpt[ch_count] = 1;\n            pgdata->bSymbolArrBrkpt[i] = 1;\n        }\n    }\n\n    /* kill select interval */\n    for (i = 0; i < pgdata->nPhoneSeq; i++) {\n        if (pgdata->bArrBrkpt[i]) {\n            ChewingKillSelectIntervalAcross(i, pgdata);\n        }\n    }\n\n    ShowChewingData(pgdata);\n\n    /* then phrasing */\n    Phrasing(pgdata, all_phrasing);\n\n    /* and then make prefer interval */\n    MakePreferInterval(pgdata);\n\n    return 0;\n}",
        "begin_line": 719,
        "end_line": 752,
        "is_bug": false
    },
    {
        "name": "chewingutil.ChewingIsBreakPoint#532",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ChewingIsBreakPoint(int cursor, ChewingData *pgdata)",
        "snippet": "static int ChewingIsBreakPoint(int cursor, ChewingData *pgdata)\n{\n    static const char *const BREAK_WORD[] = {\n        \"\\xE6\\x98\\xAF\", \"\\xE7\\x9A\\x84\", \"\\xE4\\xBA\\x86\", \"\\xE4\\xB8\\x8D\",\n        /* \u662f              \u7684              \u4e86              \u4e0d */\n        \"\\xE4\\xB9\\x9F\", \"\\xE8\\x80\\x8C\", \"\\xE4\\xBD\\xA0\", \"\\xE6\\x88\\x91\",\n        /* \u4e5f              \u800c              \u4f60              \u6211 */\n        \"\\xE4\\xBB\\x96\", \"\\xE8\\x88\\x87\", \"\\xE5\\xAE\\x83\", \"\\xE5\\xA5\\xB9\",\n        /* \u4ed6              \u8207              \u5b83              \u5979 */\n        \"\\xE5\\x85\\xB6\", \"\\xE5\\xB0\\xB1\", \"\\xE5\\x92\\x8C\", \"\\xE6\\x88\\x96\",\n        /* \u5176              \u5c31              \u548c              \u6216 */\n        \"\\xE5\\x80\\x91\", \"\\xE6\\x80\\xA7\", \"\\xE5\\x93\\xA1\", \"\\xE5\\xAD\\x90\",\n        /* \u5011              \u6027              \u54e1              \u5b50 */\n        \"\\xE4\\xB8\\x8A\", \"\\xE4\\xB8\\x8B\", \"\\xE4\\xB8\\xAD\", \"\\xE5\\x85\\xA7\",\n        /* \u4e0a              \u4e0b              \u4e2d              \u5167 */\n        \"\\xE5\\xA4\\x96\", \"\\xE5\\x8C\\x96\", \"\\xE8\\x80\\x85\", \"\\xE5\\xAE\\xB6\",\n        /* \u5916              \u5316              \u8005              \u5bb6 */\n        \"\\xE5\\x85\\x92\", \"\\xE5\\xB9\\xB4\", \"\\xE6\\x9C\\x88\", \"\\xE6\\x97\\xA5\",\n        /* \u5152              \u5e74              \u6708              \u65e5 */\n        \"\\xE6\\x99\\x82\", \"\\xE5\\x88\\x86\", \"\\xE7\\xA7\\x92\", \"\\xE8\\xA1\\x97\",\n        /* \u6642              \u5206              \u79d2              \u8857 */\n        \"\\xE8\\xB7\\xAF\", \"\\xE6\\x9D\\x91\",\n        /* \u8def              \u6751 */\n        \"\\xE5\\x9C\\xA8\",\n        /* \u5728 */\n    };\n    size_t i;\n\n    if (!ChewingIsChiAt(cursor, pgdata))\n        return 1;\n\n    for (i = 0; i < ARRAY_SIZE(BREAK_WORD); ++i)\n        if (!strcmp(pgdata->preeditBuf[cursor].char_, BREAK_WORD[i]))\n            return 1;\n\n    return 0;\n}\n\nvoid AutoLearnPhrase(ChewingData *pgdata)\n{\n    uint16_t bufPhoneSeq[MAX_PHO",
        "begin_line": 532,
        "end_line": 568,
        "is_bug": false
    },
    {
        "name": "chewingutil.ChewingIsChiAt#942",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ChewingIsChiAt(int chiSymbolCursor, ChewingData *pgdata)",
        "snippet": "int ChewingIsChiAt(int chiSymbolCursor, ChewingData *pgdata)\n{\n    assert(0 <= chiSymbolCursor);\n    assert(chiSymbolCursor < ARRAY_SIZE(pgdata->preeditBuf));\n    return pgdata->preeditBuf[chiSymbolCursor].category == CHEWING_CHINESE;\n}",
        "begin_line": 942,
        "end_line": 947,
        "is_bug": false
    },
    {
        "name": "chewingutil.ChewingIsEntering#106",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ChewingIsEntering(ChewingData *pgdata)",
        "snippet": "int ChewingIsEntering(ChewingData *pgdata)\n{\n    if (pgdata->choiceInfo.isSymbol != WORD_CHOICE)\n        return 1;\n    return (pgdata->chiSymbolBufLen != 0 || BopomofoIsEntering(&(pgdata->bopomofoData)));\n}",
        "begin_line": 106,
        "end_line": 111,
        "is_bug": false
    },
    {
        "name": "chewingutil.ChewingKillChar#992",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ChewingKillChar(ChewingData *pgdata, int chiSymbolCursorToKill, int minus)",
        "snippet": "int ChewingKillChar(ChewingData *pgdata, int chiSymbolCursorToKill, int minus)\n{\n    int tmp, cursorToKill;\n\n    tmp = pgdata->chiSymbolCursor;\n    pgdata->chiSymbolCursor = chiSymbolCursorToKill;\n    cursorToKill = PhoneSeqCursor(pgdata);\n    pgdata->chiSymbolCursor = tmp;\n    if (ChewingIsChiAt(chiSymbolCursorToKill, pgdata)) {\n        KillCharInSelectIntervalAndBrkpt(pgdata, cursorToKill);\n        assert(pgdata->nPhoneSeq - cursorToKill - 1 >= 0);\n        memmove(&(pgdata->phoneSeq[cursorToKill]),\n                &(pgdata->phoneSeq[cursorToKill + 1]), (pgdata->nPhoneSeq - cursorToKill - 1) * sizeof(uint16_t));\n        pgdata->nPhoneSeq--;\n    }\n    pgdata->symbolKeyBuf[chiSymbolCursorToKill] = 0;\n    assert(pgdata->chiSymbolBufLen - chiSymbolCursorToKill);\n    memmove(&pgdata->symbolKeyBuf[chiSymbolCursorToKill],\n            &pgdata->symbolKeyBuf[chiSymbolCursorToKill + 1],\n            sizeof(pgdata->symbolKeyBuf[0]) * (pgdata->chiSymbolBufLen - chiSymbolCursorToKill));\n    memmove(&pgdata->preeditBuf[chiSymbolCursorToKill],\n            &pgdata->preeditBuf[chiSymbolCursorToKill + 1],\n            sizeof(pgdata->preeditBuf[0]) * (pgdata->chiSymbolBufLen - chiSymbolCursorToKill));\n    pgdata->chiSymbolBufLen--;\n    pgdata->chiSymbolCursor -= minus;\n    if (pgdata->chiSymbolCursor < 0)\n        pgdata->chiSymbolCursor = 0;\n    return 0;\n}",
        "begin_line": 992,
        "end_line": 1020,
        "is_bug": false
    },
    {
        "name": "chewingutil.CleanAllBuf#486",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.CleanAllBuf(ChewingData *pgdata)",
        "snippet": "void CleanAllBuf(ChewingData *pgdata)\n{\n    /* 1 */\n    pgdata->nPhoneSeq = 0;\n    memset(pgdata->phoneSeq, 0, sizeof(pgdata->phoneSeq));\n    /* 2 */\n    pgdata->chiSymbolBufLen = 0;\n    memset(pgdata->preeditBuf, 0, sizeof(pgdata->preeditBuf));\n    /* 3 */\n    memset(pgdata->bUserArrBrkpt, 0, sizeof(pgdata->bUserArrBrkpt));\n    /* 4 */\n    pgdata->nSelect = 0;\n    /* 5 */\n    pgdata->chiSymbolCursor = 0;\n    /* 6 */\n    memset(pgdata->bUserArrCnnct, 0, sizeof(pgdata->bUserArrCnnct));\n\n    pgdata->phrOut.nNumCut = 0;\n\n    memset(pgdata->symbolKeyBuf, 0, sizeof(pgdata->symbolKeyBuf));\n\n    pgdata->nPrefer = 0;\n}",
        "begin_line": 486,
        "end_line": 508,
        "is_bug": false
    },
    {
        "name": "chewingutil.CountReleaseNum#451",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.CountReleaseNum(ChewingData *pgdata)",
        "snippet": "static int CountReleaseNum(ChewingData *pgdata)\n{\n    int remain, i;\n\n    remain = pgdata->config.maxChiSymbolLen - pgdata->chiSymbolBufLen;\n    if (remain >= 0)\n        return 0;\n\n    qsort(pgdata->preferInterval, pgdata->nPrefer, sizeof(IntervalType), (CompFuncType) CompInterval);\n\n    if (!ChewingIsChiAt(0, pgdata)) {\n        for (i = 0; i < pgdata->chiSymbolCursor; ++i) {\n            if (ChewingIsChiAt(i, pgdata)) {\n                break;\n            }\n        }\n        return i;\n    }\n\n    i = FindIntervalFrom(0, pgdata->preferInterval, pgdata->nPrefer);\n    if (i >= 0) {\n        return (pgdata->preferInterval[i].to - pgdata->preferInterval[i].from);\n    }\n\n    return 1;\n}",
        "begin_line": 451,
        "end_line": 476,
        "is_bug": false
    },
    {
        "name": "chewingutil.CountSelKeyNum#912",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.CountSelKeyNum(int key, const ChewingData *pgdata)         /* return value starts from 0.  If less than zero : error key */",
        "snippet": "int CountSelKeyNum(int key, const ChewingData *pgdata)\n        /* return value starts from 0.  If less than zero : error key */\n{\n    int i;\n\n    for (i = 0; i < MAX_SELKEY; i++)\n        if (pgdata->config.selKey[i] == key)\n            return i;\n    return -1;\n}",
        "begin_line": 912,
        "end_line": 921,
        "is_bug": false
    },
    {
        "name": "chewingutil.CountSymbols#923",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.CountSymbols(ChewingData *pgdata, int to)",
        "snippet": "int CountSymbols(ChewingData *pgdata, int to)\n{\n    int chi;\n    int i;\n\n    for (chi = i = 0; i < to; i++) {\n        if (ChewingIsChiAt(i, pgdata))\n            chi++;\n    }\n    return to - chi;\n}",
        "begin_line": 923,
        "end_line": 933,
        "is_bug": false
    },
    {
        "name": "chewingutil.FindEasySymbolIndex#66",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.FindEasySymbolIndex(char ch)",
        "snippet": "static int FindEasySymbolIndex(char ch)\n{\n        /**\n         * '0' => 0, ..., '9' => 9\n         * 'A' => 10, 'B' => 11, ... 'Z' => 35\n         */\n    if (isdigit(ch)) {\n        return ch - '0';\n    } else if (isupper(ch)) {\n        return ch - 'A' + 10;\n    } else {\n        return -1;\n    }\n}",
        "begin_line": 66,
        "end_line": 79,
        "is_bug": false
    },
    {
        "name": "chewingutil.FindSymbolKey#1191",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.FindSymbolKey(const char *symbol)",
        "snippet": "static int FindSymbolKey(const char *symbol)\n{\n    unsigned int i;\n    const char *const *buf;\n\n    for (i = 0; i < ARRAY_SIZE(symbol_buf); ++i) {\n        for (buf = symbol_buf[i]; *buf; ++buf) {\n            if (0 == strcmp(*buf, symbol))\n                return *symbol_buf[i][0];\n        }\n    }\n    return 0;\n}",
        "begin_line": 1191,
        "end_line": 1203,
        "is_bug": false
    },
    {
        "name": "chewingutil.FullShapeSymbolInput#222",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.FullShapeSymbolInput(int key, ChewingData *pgdata)",
        "snippet": "int FullShapeSymbolInput(int key, ChewingData *pgdata)\n{\n    int rtn;\n\n    static char keybuf[] = {\n        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n        'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n        'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D',\n        'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\n        'Y', 'Z', ' ', '\\\"', '\\'', '/', '<', '>', '`', '[',\n        ']', '{', '}', '+', '-'\n    };\n    static const char *chibuf[] = {\n        \"\\xEF\\xBC\\x90\", \"\\xEF\\xBC\\x91\", \"\\xEF\\xBC\\x92\", \"\\xEF\\xBC\\x93\",\n        /* \"\uff10\",\"\uff11\",\"\uff12\",\"\uff13\" */\n        \"\\xEF\\xBC\\x94\", \"\\xEF\\xBC\\x95\", \"\\xEF\\xBC\\x96\", \"\\xEF\\xBC\\x97\",\n        /* \"\uff14\",\"\uff15\",\"\uff16\",\"\uff17\" */\n        \"\\xEF\\xBC\\x98\", \"\\xEF\\xBC\\x99\", \"\\xEF\\xBD\\x81\", \"\\xEF\\xBD\\x82\",\n        /* \"\uff18\",\"\uff19\",\"\uff41\",\"\uff42\" */\n        \"\\xEF\\xBD\\x83\", \"\\xEF\\xBD\\x84\", \"\\xEF\\xBD\\x85\", \"\\xEF\\xBD\\x86\",\n        /* \"\uff43\",\"\uff44\",\"\uff45\",\"\uff46\" */\n        \"\\xEF\\xBD\\x87\", \"\\xEF\\xBD\\x88\", \"\\xEF\\xBD\\x89\", \"\\xEF\\xBD\\x8A\",\n        /* \"\uff47\",\"\uff48\",\"\uff49\",\"\uff4a\" */\n        \"\\xEF\\xBD\\x8B\", \"\\xEF\\xBD\\x8C\", \"\\xEF\\xBD\\x8D\", \"\\xEF\\xBD\\x8E\",\n        /* \"\uff4b\",\"\uff4c\",\"\uff4d\",\"\uff4e\" */\n        \"\\xEF\\xBD\\x8F\", \"\\xEF\\xBD\\x90\", \"\\xEF\\xBD\\x91\", \"\\xEF\\xBD\\x92\",\n        /* \"\uff4f\",\"\uff50\",\"\uff51\",\"\uff52\" */\n        \"\\xEF\\xBD\\x93\", \"\\xEF\\xBD\\x94\", \"\\xEF\\xBD\\x95\", \"\\xEF\\xBD\\x96\",\n        /* \"\uff53\",\"\uff54\",\"\uff55\",\"\uff56\" */\n        \"\\xEF\\xBD\\x97\", \"\\xEF\\xBD\\x98\", \"\\xEF\\xBD\\x99\", \"\\xEF\\xBD\\x9A\",\n        /* \"\uff57\",\"\uff58\",\"\uff59\",\"\uff5a\" */\n        \"\\xEF\\xBC\\xA1\", \"\\xEF\\xBC\\xA2\", \"\\xEF\\xBC\\xA3\", \"\\xEF\\xBC\\xA4\",\n        /* \"\uff21\",\"\uff22\",\"\uff23\",\"\uff24\" */\n        \"\\xEF\\xBC\\xA5\", \"\\xEF\\xBC\\xA6\", \"\\xEF\\xBC\\xA7\", \"\\xEF\\xBC\\xA8\",\n        /* \"\uff25\",\"\uff26\",\"\uff27\",\"\uff28\" */\n        \"\\xEF\\xBC\\xA9\", \"\\xEF\\xBC\\xAA\", \"\\xEF\\xBC\\xAB\", \"\\xEF\\xBC\\xAC\",\n        /* \"\uff29\",\"\uff2a\",\"\uff2b\",\"\uff2c\" */\n        \"\\xEF\\xBC\\xAD\", \"\\xEF\\xBC\\xAE\", \"\\xEF\\xBC\\xAF\", \"\\xEF\\xBC\\xB0\",\n        /* \"\uff2d\",\"\uff2e\",\"\uff2f\",\"\uff30\" */\n        \"\\xEF\\xBC\\xB1\", \"\\xEF\\xBC\\xB2\", \"\\xEF\\xBC\\xB3\", \"\\xEF\\xBC\\xB4\",\n        /* \"\uff31\",\"\uff32\",\"\uff33\",\"\uff34\" */\n        \"\\xEF\\xBC\\xB5\", \"\\xEF\\xBC\\xB6\", \"\\xEF\\xBC\\xB7\", \"\\xEF\\xBC\\xB8\",\n        /* \"\uff35\",\"\uff36\",\"\uff37\",\"\uff38\" */\n        \"\\xEF\\xBC\\xB9\", \"\\xEF\\xBC\\xBA\", \"\\xE3\\x80\\x80\", \"\\xE2\\x80\\x9D\",\n        /* \"\uff39\",\"\uff3a\",\"\u3000\",\"\u201d\" */\n        \"\\xE2\\x80\\x99\", \"\\xEF\\xBC\\x8F\", \"\\xEF\\xBC\\x9C\", \"\\xEF\\xBC\\x9E\",\n        /* \"\u2019\",\"\uff0f\",\"\uff1c\",\"\uff1e\" */\n        \"\\xE2\\x80\\xB5\", \"\\xE3\\x80\\x94\", \"\\xE3\\x80\\x95\", \"\\xEF\\xBD\\x9B\",\n        /* \"\u2035\",\"\u3014\"\"\u3015\",\"\uff5b\" */\n        \"\\xEF\\xBD\\x9D\", \"\\xEF\\xBC\\x8B\", \"\\xEF\\xBC\\x8D\"\n            /* \"\uff5d\",\"\uff0b\",\"\uff0d\" */\n    };\n    STATIC_ASSERT(ARRAY_SIZE(keybuf) == ARRAY_SIZE(chibuf));\n\n    rtn = InternalSpecialSymbol(key, pgdata, ARRAY_SIZE(keybuf), keybuf, chibuf);\n    if (rtn == BOPOMOFO_IGNORE)\n        rtn = SpecialSymbolInput(key, pgdata);\n    return (rtn == BOPOMOFO_IGNORE ? SYMBOL_KEY_ERROR : SYMBOL_KEY_OK);\n}\n\nint EasySymbolInput(int key, ChewingData *pgdata)\n{\n    int rtn, loop, _index;\n    char wordbuf[8];\n\n    int nSpecial = EASY_SYMBOL_KEY_TAB_LEN;\n\n  ",
        "begin_line": 222,
        "end_line": 282,
        "is_bug": false
    },
    {
        "name": "chewingutil.HaninSymbolInput#113",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.HaninSymbolInput(ChewingData *pgdata)",
        "snippet": "int HaninSymbolInput(ChewingData *pgdata)\n{\n    unsigned int i;\n\n    ChoiceInfo *pci = &(pgdata->choiceInfo);\n    AvailInfo *pai = &(pgdata->availInfo);\n\n    /* No available symbol table */\n    if (!pgdata->static_data.symbol_table)\n        return BOPOMOFO_ABSORB;\n\n    pci->nTotalChoice = 0;\n    for (i = 0; i < pgdata->static_data.n_symbol_entry; i++) {\n        strcpy(pci->totalChoiceStr[pci->nTotalChoice], pgdata->static_data.symbol_table[i]->category);\n        pci->nTotalChoice++;\n    }\n    pai->avail[0].len = 1;\n    pai->avail[0].id = NULL;\n    pai->nAvail = 1;\n    pai->currentAvail = 0;\n    pci->nChoicePerPage = pgdata->config.candPerPage;\n    assert(pci->nTotalChoice > 0);\n    pci->nPage = CEIL_DIV(pci->nTotalChoice, pci->nChoicePerPage);\n    pci->pageNo = 0;\n    pci->isSymbol = SYMBOL_CATEGORY_CHOICE;\n    return BOPOMOFO_ABSORB;\n}",
        "begin_line": 113,
        "end_line": 139,
        "is_bug": false
    },
    {
        "name": "chewingutil.InitEasySymbolInput#1369",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.InitEasySymbolInput(ChewingData *pgdata, const char *prefix)",
        "snippet": "int InitEasySymbolInput(ChewingData *pgdata, const char *prefix)\n{\n    static const size_t LINE_LEN = 512; // shall be long enough?\n\n    FILE *file = NULL;\n    char *filename = NULL;\n    char *line = NULL;\n    int len;\n    int _index;\n    char *symbol;\n    int ret = -1;\n\n    ret = asprintf(&filename, \"%s\" PLAT_SEPARATOR \"%s\", prefix, SOFTKBD_TABLE_FILE);\n    if (ret == -1)\n        goto filenamefail;\n\n    file = fopen(filename, \"r\");\n    if (!file)\n        goto fileopenfail;\n\n    line = ALC(char, LINE_LEN);\n    if (!line)\n        goto linefail;\n\n    while (fgets(line, LINE_LEN, file)) {\n        if (' ' != line[1])\n            continue;\n\n        // Remove tailing \\n\n        len = strcspn(line, \"\\r\\n\");\n\n        line[len] = '\\0';\n\n        _index = FindEasySymbolIndex(line[0]);\n        if (-1 == _index)\n            continue;\n\n        len = ueStrLen(&line[2]);\n        if (0 == len || len > MAX_PHRASE_LEN)\n            continue;\n\n        symbol = ALC(char, strlen(&line[2]) + 1);\n\n        if (!symbol)\n            goto end;\n\n        ueStrNCpy(symbol, &line[2], len, 1);\n\n        free(pgdata->static_data.g_easy_symbol_value[_index]);\n        pgdata->static_data.g_easy_symbol_value[_index] = symbol;\n        pgdata->static_data.g_easy_symbol_num[_index] = len;\n    }\n    ret = 0;\n\nend:\n    free(line);\n\nlinefail:\n    fclose(file);\n\nfileopenfail:\n    free(filename);\n\nfilenamefail:\n    return ret;\n}",
        "begin_line": 1369,
        "end_line": 1434,
        "is_bug": false
    },
    {
        "name": "chewingutil.InitSymbolTable#1251",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.InitSymbolTable(ChewingData *pgdata, const char *prefix)",
        "snippet": "int InitSymbolTable(ChewingData *pgdata, const char *prefix)\n{\n    static const unsigned int MAX_SYMBOL_ENTRY = 100;\n    static const size_t LINE_LEN = 512; // shall be long enough?\n\n    char *filename = NULL;\n    FILE *file = NULL;\n    char *line = NULL;\n    SymbolEntry **entry = NULL;\n    char *category_end;\n    const char *symbols;\n    char *symbols_end;\n    const char *symbol;\n    size_t i;\n    size_t len;\n    size_t size;\n    int ret = -1;\n\n    pgdata->static_data.n_symbol_entry = 0;\n    pgdata->static_data.symbol_table = NULL;\n\n    ret = asprintf(&filename, \"%s\" PLAT_SEPARATOR \"%s\", prefix, SYMBOL_TABLE_FILE);\n    if (ret == -1)\n        goto error;\n\n    file = fopen(filename, \"r\");\n    if (!file)\n        goto error;\n\n    line = ALC(char, LINE_LEN);\n\n    if (!line)\n        goto error;\n\n    entry = ALC(SymbolEntry *, MAX_SYMBOL_ENTRY);\n\n    if (!entry)\n        goto error;\n\n    while (fgets(line, LINE_LEN, file) && pgdata->static_data.n_symbol_entry < MAX_SYMBOL_ENTRY) {\n\n        category_end = strpbrk(line, \"=\\r\\n\");\n        if (!category_end)\n            goto error;\n\n        symbols = category_end + 1;\n        symbols_end = strpbrk(symbols, \"\\r\\n\");\n        if (symbols_end) {\n            *symbols_end = 0;\n            len = ueStrLen(symbols);\n\n            entry[pgdata->static_data.n_symbol_entry] =\n                (SymbolEntry *) malloc(sizeof(entry[0][0]) + sizeof(entry[0][0].symbols[0]) * len);\n            if (!entry[pgdata->static_data.n_symbol_entry])\n                goto error;\n            entry[pgdata->static_data.n_symbol_entry]\n                ->nSymbols = len;\n\n            symbol = symbols;\n\n            for (i = 0; i < len; ++i) {\n                ueStrNCpy(entry[pgdata->static_data.n_symbol_entry]->symbols[i], symbol, 1, 1);\n                // FIXME: What if symbol is combining sequences.\n                symbol += ueBytesFromChar(symbol[0]);\n            }\n\n\n        } else {\n            entry[pgdata->static_data.n_symbol_entry] = (SymbolEntry *) malloc(sizeof(entry[0][0]));\n            if (!entry[pgdata->static_data.n_symbol_entry])\n                goto error;\n\n            entry[pgdata->static_data.n_symbol_entry]\n                ->nSymbols = 0;\n        }\n\n        *category_end = 0;\n        ueStrNCpy(entry[pgdata->static_data.n_symbol_entry]->category, line, MAX_PHRASE_LEN, 1);\n\n        ++pgdata->static_data.n_symbol_entry;\n    }\n\n    size = sizeof(*pgdata->static_data.symbol_table) * pgdata->static_data.n_symbol_entry;\n    if (!size)\n        goto end;\n    pgdata->static_data.symbol_table = (SymbolEntry **) malloc(size);\n    if (!pgdata->static_data.symbol_table)\n        goto error;\n    memcpy(pgdata->static_data.symbol_table, entry, size);\n\n    ret = 0;\n  end:\n    free(entry);\n    free(line);\n    fclose(file);\n    free(filename);\n    return ret;\n\n  error:\n    for (i = 0; i < pgdata->static_data.n_symbol_entry; ++i) {\n        free(entry[i]);\n    }\n    goto end;\n}",
        "begin_line": 1251,
        "end_line": 1354,
        "is_bug": false
    },
    {
        "name": "chewingutil.InternalSpecialSymbol#176",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.InternalSpecialSymbol(int key, ChewingData *pgdata, int nSpecial, const char keybuf[], const char *const chibuf[])",
        "snippet": "static int InternalSpecialSymbol(int key, ChewingData *pgdata,\n                                 int nSpecial, const char keybuf[], const char *const chibuf[])\n{\n    int i, rtn = BOPOMOFO_IGNORE;   /* very strange and difficult to understand */\n\n    for (i = 0; i < nSpecial; i++) {\n        if (1 == _Inner_InternalSpecialSymbol(key, pgdata, keybuf[i], chibuf[i])) {\n            rtn = BOPOMOFO_ABSORB;\n            break;\n        }\n    }\n    return rtn;\n}",
        "begin_line": 176,
        "end_line": 188,
        "is_bug": false
    },
    {
        "name": "chewingutil.KillFromLeft#478",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.KillFromLeft(ChewingData *pgdata, int nKill)",
        "snippet": "static void KillFromLeft(ChewingData *pgdata, int nKill)\n{\n    int i;\n\n    for (i = 0; i < nKill; i++)\n        ChewingKillChar(pgdata, 0, DECREASE_CURSOR);\n}",
        "begin_line": 478,
        "end_line": 484,
        "is_bug": false
    },
    {
        "name": "chewingutil.MakeOutput#836",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.MakeOutput(ChewingOutput *pgo, ChewingData *pgdata)",
        "snippet": "int MakeOutput(ChewingOutput *pgo, ChewingData *pgdata)\n{\n    int i;\n    int inx;\n    char *pos;\n\n    /* fill zero to chiSymbolBuf first */\n    pgo->preeditBuf[0] = 0;\n    pgo->bopomofoBuf[0] = 0;\n\n    pos = pgo->preeditBuf;\n    for (i = 0; i < pgdata->chiSymbolBufLen && pos < pgo->preeditBuf + sizeof(pgo->preeditBuf) + MAX_UTF8_SIZE + 1; ++i) {\n        strncpy(pos, pgdata->preeditBuf[i].char_, MAX_UTF8_SIZE + 1);\n        pos += strlen(pgdata->preeditBuf[i].char_);\n    }\n\n    /* fill point */\n    pgo->PointStart = pgdata->PointStart;\n    pgo->PointEnd = pgdata->PointEnd;\n\n    /* fill other fields */\n    pgo->chiSymbolBufLen = pgdata->chiSymbolBufLen;\n    pgo->chiSymbolCursor = pgdata->chiSymbolCursor;\n\n    /* fill bopomofoBuf */\n    if (pgdata->bopomofoData.kbtype >= KB_HANYU_PINYIN) {\n        strcpy(pgo->bopomofoBuf, pgdata->bopomofoData.pinYinData.keySeq);\n    } else {\n        for (i = 0; i < BOPOMOFO_SIZE; i++) {\n            inx = pgdata->bopomofoData.pho_inx[i];\n            if (inx != 0) {\n                ueStrNCpy(pgo->bopomofoBuf + strlen(pgo->bopomofoBuf),\n                          ueConstStrSeek(zhuin_tab[i], inx - 1),\n                          1, STRNCPY_CLOSE);\n            }\n        }\n    }\n\n    ShiftInterval(pgo, pgdata);\n    memcpy(pgo->dispBrkpt, pgdata->bUserArrBrkpt, sizeof(pgo->dispBrkpt[0]) * (MAX_PHONE_SEQ_LEN + 1));\n    pgo->pci = &(pgdata->choiceInfo);\n    pgo->bChiSym = pgdata->bChiSym;\n    memcpy(pgo->selKey, pgdata->config.selKey, sizeof(pgdata->config.selKey));\n    pgdata->bShowMsg = 0;\n    return 0;\n}",
        "begin_line": 836,
        "end_line": 881,
        "is_bug": false
    },
    {
        "name": "chewingutil.MakeOutputAddMsgAndCleanInterval#889",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.MakeOutputAddMsgAndCleanInterval(ChewingOutput *pgo, ChewingData *pgdata)",
        "snippet": "void MakeOutputAddMsgAndCleanInterval(ChewingOutput *pgo, ChewingData *pgdata)\n{\n    pgdata->bShowMsg = 1;\n    pgo->nDispInterval = 0;\n}",
        "begin_line": 889,
        "end_line": 893,
        "is_bug": false
    },
    {
        "name": "chewingutil.MakeOutputWithRtn#883",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.MakeOutputWithRtn(ChewingOutput *pgo, ChewingData *pgdata, int keystrokeRtn)",
        "snippet": "int MakeOutputWithRtn(ChewingOutput *pgo, ChewingData *pgdata, int keystrokeRtn)\n{\n    pgo->keystrokeRtn = keystrokeRtn;\n    return MakeOutput(pgo, pgdata);\n}",
        "begin_line": 883,
        "end_line": 887,
        "is_bug": false
    },
    {
        "name": "chewingutil.MakePreferInterval#773",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.MakePreferInterval(ChewingData *pgdata)",
        "snippet": "static void MakePreferInterval(ChewingData *pgdata)\n{\n    int i, j, set_no;\n    int belong_set[MAX_PHONE_SEQ_LEN + 1];\n    int parent[MAX_PHONE_SEQ_LEN + 1];\n\n    memset(belong_set, 0, sizeof(int) * (MAX_PHONE_SEQ_LEN + 1));\n    memset(parent, 0, sizeof(int) * (MAX_PHONE_SEQ_LEN + 1));\n\n    /* for each interval */\n    for (i = 0; i < pgdata->phrOut.nDispInterval; i++) {\n        for (j = pgdata->phrOut.dispInterval[i].from; j < pgdata->phrOut.dispInterval[i].to; j++) {\n            belong_set[j] = i + 1;\n        }\n    }\n    set_no = i + 1;\n    for (i = 0; i < pgdata->nPhoneSeq; i++)\n        if (belong_set[i] == 0)\n            belong_set[i] = set_no++;\n\n    /* for each connect point */\n    for (i = 1; i < pgdata->nPhoneSeq; i++) {\n        if (pgdata->bUserArrCnnct[i]) {\n            Union(belong_set[i - 1], belong_set[i], parent);\n        }\n    }\n\n    /* generate new intervals */\n    pgdata->nPrefer = 0;\n    i = 0;\n    while (i < pgdata->nPhoneSeq) {\n        for (j = i + 1; j < pgdata->nPhoneSeq; j++)\n            if (!SameSet(belong_set[i], belong_set[j], parent))\n                break;\n\n        pgdata->preferInterval[pgdata->nPrefer].from = i;\n        pgdata->preferInterval[pgdata->nPrefer].to = j;\n        pgdata->nPrefer++;\n        i = j;\n    }\n}",
        "begin_line": 773,
        "end_line": 813,
        "is_bug": false
    },
    {
        "name": "chewingutil.OpenSymbolChoice#1205",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.OpenSymbolChoice(ChewingData *pgdata)",
        "snippet": "int OpenSymbolChoice(ChewingData *pgdata)\n{\n    int i, symbol_buf_len = ARRAY_SIZE(symbol_buf);\n    const char *const *pBuf;\n    ChoiceInfo *pci = &(pgdata->choiceInfo);\n\n    pci->oldChiSymbolCursor = pgdata->chiSymbolCursor;\n\n    /* see if there is some word in the cursor position */\n    if (pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen && pgdata->chiSymbolCursor > 0)\n        pgdata->chiSymbolCursor--;\n    if (pgdata->symbolKeyBuf[pgdata->chiSymbolCursor] == NO_SYM_KEY) {\n        pgdata->bSelect = 1;\n        HaninSymbolInput(pgdata);\n        return 0;\n    }\n    for (i = 0; i < symbol_buf_len; i++) {\n        if (symbol_buf[i][0][0] == pgdata->symbolKeyBuf[pgdata->chiSymbolCursor]) {\n            pBuf = symbol_buf[i];\n            break;\n        }\n    }\n    if (i == symbol_buf_len) {\n        ChoiceEndChoice(pgdata);\n        return 0;\n    }\n    pci->nTotalChoice = 0;\n    for (i = 1; pBuf[i]; i++) {\n        ueStrNCpy(pci->totalChoiceStr[pci->nTotalChoice], pBuf[i], ueStrLen(pBuf[i]), 1);\n        pci->nTotalChoice++;\n    }\n\n    pci->nChoicePerPage = pgdata->config.candPerPage;\n    assert(pci->nTotalChoice > 0);\n    pci->nPage = CEIL_DIV(pci->nTotalChoice, pci->nChoicePerPage);\n    pci->pageNo = 0;\n    pci->isSymbol = SYMBOL_CHOICE_UPDATE;\n\n    pgdata->bSelect = 1;\n    pgdata->availInfo.nAvail = 1;\n    pgdata->availInfo.currentAvail = 0;\n    pgdata->availInfo.avail[0].id = NULL;\n    pgdata->availInfo.avail[0].len = 1;\n    return 0;\n}",
        "begin_line": 1205,
        "end_line": 1249,
        "is_bug": false
    },
    {
        "name": "chewingutil.PhoneSeqCursor#935",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.PhoneSeqCursor(ChewingData *pgdata)",
        "snippet": "int PhoneSeqCursor(ChewingData *pgdata)\n{\n    int cursor = pgdata->chiSymbolCursor - CountSymbols(pgdata, pgdata->chiSymbolCursor);\n\n    return cursor > 0 ? cursor : 0;\n}",
        "begin_line": 935,
        "end_line": 940,
        "is_bug": false
    },
    {
        "name": "chewingutil.ReleaseChiSymbolBuf#510",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ReleaseChiSymbolBuf(ChewingData *pgdata, ChewingOutput *pgo)",
        "snippet": "int ReleaseChiSymbolBuf(ChewingData *pgdata, ChewingOutput *pgo)\n{\n    int throwEnd;\n\n    throwEnd = CountReleaseNum(pgdata);\n\n    /*\n     * When current buffer size exceeds maxChiSymbolLen,\n     * we need to throw some of the characters at the head of the buffer and\n     * commit them.\n     */\n    if (throwEnd) {\n        /*\n         * count how many chinese words in \"chiSymbolBuf[ 0 .. (throwEnd - 1)]\"\n         * And release from \"chiSymbolBuf\" && \"phoneSeq\"\n         */\n        WriteChiSymbolToCommitBuf(pgdata, pgo, throwEnd);\n        KillFromLeft(pgdata, throwEnd);\n    }\n    return throwEnd;\n}",
        "begin_line": 510,
        "end_line": 530,
        "is_bug": false
    },
    {
        "name": "chewingutil.RemoveSelectElement#949",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.RemoveSelectElement(int i, ChewingData *pgdata)",
        "snippet": "void RemoveSelectElement(int i, ChewingData *pgdata)\n{\n    if (--pgdata->nSelect == i)\n        return;\n    pgdata->selectInterval[i] = pgdata->selectInterval[pgdata->nSelect];\n    strcpy(pgdata->selectStr[i], pgdata->selectStr[pgdata->nSelect]);\n}",
        "begin_line": 949,
        "end_line": 955,
        "is_bug": false
    },
    {
        "name": "chewingutil.SameSet#761",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.SameSet(int set1, int set2, int parent[])",
        "snippet": "static int SameSet(int set1, int set2, int parent[])\n{\n    while (parent[set1] != 0) {\n        set1 = parent[set1];\n    }\n    while (parent[set2] != 0) {\n        set2 = parent[set2];\n    }\n    return (set1 == set2);\n}",
        "begin_line": 761,
        "end_line": 770,
        "is_bug": false
    },
    {
        "name": "chewingutil.ShiftInterval#816",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ShiftInterval(ChewingOutput *pgo, ChewingData *pgdata)",
        "snippet": "static void ShiftInterval(ChewingOutput *pgo, ChewingData *pgdata)\n{\n    int i, arrPos[MAX_PHONE_SEQ_LEN], k = 0, from, len;\n\n    for (i = 0; i < pgdata->chiSymbolBufLen; i++) {\n        if (ChewingIsChiAt(i, pgdata)) {\n            arrPos[k++] = i;\n        }\n    }\n    arrPos[k] = i;\n\n    pgo->nDispInterval = pgdata->nPrefer;\n    for (i = 0; i < pgdata->nPrefer; i++) {\n        from = pgdata->preferInterval[i].from;\n        len = pgdata->preferInterval[i].to - from;\n        pgo->dispInterval[i].from = arrPos[from];\n        pgo->dispInterval[i].to = arrPos[from] + len;\n    }\n}",
        "begin_line": 816,
        "end_line": 834,
        "is_bug": false
    },
    {
        "name": "chewingutil.ShowChewingData#688",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ShowChewingData(ChewingData *pgdata)",
        "snippet": "static void ShowChewingData(ChewingData *pgdata)\n{\n    int i;\n\n    DEBUG_OUT(\"nPhoneSeq : %d\\n\" \"phoneSeq  : \", pgdata->nPhoneSeq);\n    for (i = 0; i < pgdata->nPhoneSeq; i++)\n        DEBUG_OUT(\"%hu \", pgdata->phoneSeq[i]);\n    DEBUG_OUT(\"[cursor : %d]\\n\"\n              \"nSelect : %d\\n\" \"selectStr       selectInterval\\n\", PhoneSeqCursor(pgdata), pgdata->nSelect);\n    for (i = 0; i < pgdata->nSelect; i++) {\n        DEBUG_OUT(\"  %14s%4d%4d\\n\", pgdata->selectStr[i], pgdata->selectInterval[i].from, pgdata->selectInterval[i].to);\n    }\n\n    DEBUG_OUT(\"bUserArrCnnct : \");\n    for (i = 0; i <= pgdata->nPhoneSeq; i++)\n        DEBUG_OUT(\"%d \", pgdata->bUserArrCnnct[i]);\n    DEBUG_OUT(\"\\n\");\n\n    DEBUG_OUT(\"bUserArrBrkpt : \");\n    for (i = 0; i <= pgdata->nPhoneSeq; i++)\n        DEBUG_OUT(\"%d \", pgdata->bUserArrBrkpt[i]);\n    DEBUG_OUT(\"\\n\");\n\n    DEBUG_OUT(\"bArrBrkpt     : \");\n    for (i = 0; i <= pgdata->nPhoneSeq; i++)\n        DEBUG_OUT(\"%d \", pgdata->bArrBrkpt[i]);\n    DEBUG_OUT(\"\\n\");\n\n    DEBUG_OUT(\"bChiSym : %d , bSelect : %d\\n\", pgdata->bChiSym, pgdata->bSelect);\n}",
        "begin_line": 688,
        "end_line": 717,
        "is_bug": false
    },
    {
        "name": "chewingutil.SpecialSymbolInput#190",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.SpecialSymbolInput(int key, ChewingData *pgdata)",
        "snippet": "int SpecialSymbolInput(int key, ChewingData *pgdata)\n{\n    static const char keybuf[] = {\n        '[', ']', '{', '}', '\\'', '<', ':', '\\\"', '>',\n        '~', '!', '@', '#', '$', '%', '^', '&', '*',\n        '(', ')', '_', '+', '=', '\\\\', '|', '?',\n        ',', '.', ';'\n    };\n\n    static const char *const chibuf[] = {\n        \"\\xE3\\x80\\x8C\", \"\\xE3\\x80\\x8D\", \"\\xE3\\x80\\x8E\", \"\\xE3\\x80\\x8F\",\n        /* \"\u300c\", \"\u300d\", \"\u300e\", \"\u300f\" */\n        \"\\xE3\\x80\\x81\", \"\\xEF\\xBC\\x8C\", \"\\xEF\\xBC\\x9A\", \"\\xEF\\xBC\\x9B\",\n        /* \"\u3001\", \"\uff0c\", \"\uff1a\", \"\uff1b\" */\n        \"\\xE3\\x80\\x82\", \"\\xEF\\xBD\\x9E\", \"\\xEF\\xBC\\x81\", \"\\xEF\\xBC\\xA0\",\n        /* \"\u3002\", \"\uff5e\", \"\uff01\", \"\uff20\" */\n        \"\\xEF\\xBC\\x83\", \"\\xEF\\xBC\\x84\", \"\\xEF\\xBC\\x85\", \"\\xEF\\xB8\\xBF\",\n        /* \"\uff03\", \"\uff04\", \"\uff05\", \"\ufe3f\" */\n        \"\\xEF\\xBC\\x86\", \"\\xEF\\xBC\\x8A\", \"\\xEF\\xBC\\x88\", \"\\xEF\\xBC\\x89\",\n        /* \"\uff06\", \"\uff0a\", \"\uff08\", \"\uff09\" */\n        \"\\xE2\\x80\\x94\", \"\\xEF\\xBC\\x8B\", \"\\xEF\\xBC\\x9D\", \"\\xEF\\xBC\\xBC\",\n        /* \"\u2014\", \"\uff0b\", \"\uff1d\", \"\uff3c\" */\n        \"\\xEF\\xBD\\x9C\", \"\\xEF\\xBC\\x9F\", \"\\xEF\\xBC\\x8C\", \"\\xE3\\x80\\x82\",\n        /* \"\uff5c\", \"\uff1f\", \"\uff0c\", \"\u3002\" */\n        \"\\xEF\\xBC\\x9B\"\n            /* \"\uff1b\" */\n    };\n    STATIC_ASSERT(ARRAY_SIZE(keybuf) == ARRAY_SIZE(chibuf));\n\n    return InternalSpecialSymbol(key, pgdata, ARRAY_SIZE(keybuf), keybuf, chibuf);\n}\n\nint FullShapeSymbolInput(int key, ChewingData *pgdata)\n{",
        "begin_line": 190,
        "end_line": 220,
        "is_bug": false
    },
    {
        "name": "chewingutil.SymbolChoice#307",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.SymbolChoice(ChewingData *pgdata, int sel_i)",
        "snippet": "int SymbolChoice(ChewingData *pgdata, int sel_i)\n{\n    int kbtype;\n    int i;\n    int symbol_type;\n    int key;\n\n    if (!pgdata->static_data.symbol_table && pgdata->choiceInfo.isSymbol != SYMBOL_CHOICE_UPDATE)\n        return BOPOMOFO_ABSORB;\n\n    if (pgdata->choiceInfo.isSymbol == SYMBOL_CATEGORY_CHOICE && 0 == pgdata->static_data.symbol_table[sel_i]->nSymbols)\n        symbol_type = SYMBOL_CHOICE_INSERT;\n    else\n        symbol_type = pgdata->choiceInfo.isSymbol;\n\n    /* level one, symbol category */\n    if (symbol_type == SYMBOL_CATEGORY_CHOICE) {\n        ChoiceInfo *pci = &pgdata->choiceInfo;\n        AvailInfo *pai = &pgdata->availInfo;\n\n        /* Display all symbols in this category */\n        pci->nTotalChoice = 0;\n        for (i = 0; i < pgdata->static_data.symbol_table[sel_i]->nSymbols; i++) {\n            ueStrNCpy(pci->totalChoiceStr[pci->nTotalChoice],\n                      pgdata->static_data.symbol_table[sel_i]->symbols[i], 1, 1);\n            pci->nTotalChoice++;\n        }\n        pai->avail[0].len = 1;\n        pai->avail[0].id = NULL;\n        pai->nAvail = 1;\n        pai->currentAvail = 0;\n        pci->nChoicePerPage = pgdata->config.candPerPage;\n        assert(pci->nTotalChoice > 0);\n        pci->nPage = CEIL_DIV(pci->nTotalChoice, pci->nChoicePerPage);\n        pci->pageNo = 0;\n        pci->isSymbol = SYMBOL_CHOICE_INSERT;\n    } else {                    /* level 2 symbol or OpenSymbolChoice */\n        /* TODO: FIXME, this part is buggy! */\n        PreeditBuf *buf = &pgdata->preeditBuf[pgdata->chiSymbolCursor];\n\n        if (symbol_type == SYMBOL_CHOICE_INSERT) {\n            assert(pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen);\n\n            if (pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen ||\n                    pgdata->symbolKeyBuf[pgdata->chiSymbolCursor] != NO_SYM_KEY) {\n                memmove(&pgdata->preeditBuf[pgdata->chiSymbolCursor + 1],\n                        &pgdata->preeditBuf[pgdata->chiSymbolCursor],\n                        sizeof(pgdata->preeditBuf[0]) * (pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));\n            } else {\n                symbol_type = SYMBOL_CHOICE_UPDATE;\n            }\n        }\n        strncpy(buf->char_, pgdata->choiceInfo.totalChoiceStr[sel_i], sizeof(buf->char_) - 1);\n        buf->category = CHEWING_SYMBOL;\n\n        /* This is very strange */\n        key = FindSymbolKey(pgdata->choiceInfo.totalChoiceStr[sel_i]);\n        pgdata->symbolKeyBuf[pgdata->chiSymbolCursor] = key ? key : NO_SYM_KEY;\n\n        pgdata->bUserArrCnnct[PhoneSeqCursor(pgdata)] = 0;\n        ChoiceEndChoice(pgdata);\n        /* Don't forget the kbtype */\n        kbtype = pgdata->bopomofoData.kbtype;\n        memset(&(pgdata->bopomofoData), 0, sizeof(BopomofoData));\n        pgdata->bopomofoData.kbtype = kbtype;\n\n        if (symbol_type == SYMBOL_CHOICE_INSERT) {\n            pgdata->chiSymbolBufLen++;\n            pgdata->chiSymbolCursor++;\n        }\n\n        pgdata->choiceInfo.isSymbol = WORD_CHOICE;\n    }\n    return BOPOMOFO_ABSORB;\n}",
        "begin_line": 307,
        "end_line": 381,
        "is_bug": false
    },
    {
        "name": "chewingutil.SymbolInput#383",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.SymbolInput(int key, ChewingData *pgdata)",
        "snippet": "int SymbolInput(int key, ChewingData *pgdata)\n{\n    if (isprint((char) key) &&  /* other character was ignored */\n        (pgdata->chiSymbolBufLen < MAX_PHONE_SEQ_LEN)) {        /* protect the buffer */\n        PreeditBuf *buf = &pgdata->preeditBuf[pgdata->chiSymbolCursor];\n\n        assert(pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen);\n\n        memmove(&pgdata->preeditBuf[pgdata->chiSymbolCursor + 1],\n                &pgdata->preeditBuf[pgdata->chiSymbolCursor],\n                sizeof(pgdata->preeditBuf[0]) * (pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));\n\n        buf->char_[0] = (char) key;\n        buf->char_[1] = 0;\n        buf->category = CHEWING_SYMBOL;\n\n        /* Save Symbol Key */\n        memmove(&(pgdata->symbolKeyBuf[pgdata->chiSymbolCursor + 1]),\n                &(pgdata->symbolKeyBuf[pgdata->chiSymbolCursor]),\n                sizeof(pgdata->symbolKeyBuf[0]) * (pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));\n        pgdata->symbolKeyBuf[pgdata->chiSymbolCursor] = toupper(key);\n\n        pgdata->bUserArrCnnct[PhoneSeqCursor(pgdata)] = 0;\n        pgdata->chiSymbolCursor++;\n        pgdata->chiSymbolBufLen++;\n        return SYMBOL_KEY_OK;\n    }\n    return SYMBOL_KEY_ERROR;\n}",
        "begin_line": 383,
        "end_line": 411,
        "is_bug": false
    },
    {
        "name": "chewingutil.TerminateEasySymbolTable#1436",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.TerminateEasySymbolTable(ChewingData *pgdata)",
        "snippet": "void TerminateEasySymbolTable(ChewingData *pgdata)\n{\n    unsigned int i;\n\n    for (i = 0; i < EASY_SYMBOL_KEY_TAB_LEN; ++i) {\n        if (NULL != pgdata->static_data.g_easy_symbol_value[i]) {\n            free(pgdata->static_data.g_easy_symbol_value[i]);\n            pgdata->static_data.g_easy_symbol_value[i] = NULL;\n        }\n        pgdata->static_data.g_easy_symbol_num[i] = 0;\n    }\n}",
        "begin_line": 1436,
        "end_line": 1447,
        "is_bug": false
    },
    {
        "name": "chewingutil.TerminateSymbolTable#1356",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.TerminateSymbolTable(ChewingData *pgdata)",
        "snippet": "void TerminateSymbolTable(ChewingData *pgdata)\n{\n    unsigned int i;\n\n    if (pgdata->static_data.symbol_table) {\n        for (i = 0; i < pgdata->static_data.n_symbol_entry; ++i)\n            free(pgdata->static_data.symbol_table[i]);\n        free(pgdata->static_data.symbol_table);\n        pgdata->static_data.n_symbol_entry = 0;\n        pgdata->static_data.symbol_table = NULL;\n    }\n}",
        "begin_line": 1356,
        "end_line": 1367,
        "is_bug": false
    },
    {
        "name": "chewingutil.WriteChiSymbolToCommitBuf#432",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.WriteChiSymbolToCommitBuf(ChewingData *pgdata, ChewingOutput *pgo, int len)",
        "snippet": "void WriteChiSymbolToCommitBuf(ChewingData *pgdata, ChewingOutput *pgo, int len)\n{\n    int i;\n    char *pos;\n\n    assert(pgdata);\n    assert(pgo);\n\n    pgo->commitBufLen = len;\n\n    pos = pgo->commitBuf;\n    for (i = 0; i < pgo->commitBufLen; ++i) {\n        assert(pos + MAX_UTF8_SIZE + 1 < pgo->commitBuf + sizeof(pgo->commitBuf));\n        strcpy(pos, pgdata->preeditBuf[i].char_);\n        pos += strlen(pgdata->preeditBuf[i].char_);\n    }\n    *pos = 0;\n}",
        "begin_line": 432,
        "end_line": 449,
        "is_bug": false
    },
    {
        "name": "chewingutil._Inner_InternalSpecialSymbol#141",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil._Inner_InternalSpecialSymbol(int key, ChewingData *pgdata, char symkey, const char *const chibuf)",
        "snippet": "static int _Inner_InternalSpecialSymbol(int key, ChewingData *pgdata, char symkey, const char *const chibuf)\n{\n    int kbtype;\n    PreeditBuf *buf;\n\n    if (key == symkey && NULL != chibuf) {\n        assert(pgdata->chiSymbolBufLen >= pgdata->chiSymbolCursor);\n\n        buf = &pgdata->preeditBuf[pgdata->chiSymbolCursor];\n\n        memmove(&pgdata->preeditBuf[pgdata->chiSymbolCursor + 1],\n                &pgdata->preeditBuf[pgdata->chiSymbolCursor],\n                sizeof(pgdata->preeditBuf[0]) * (pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));\n\n        strncpy(buf->char_, chibuf, sizeof(buf->char_) - 1);\n        buf->category = CHEWING_SYMBOL;\n\n        /* Save Symbol Key */\n        memmove(&(pgdata->symbolKeyBuf[pgdata->chiSymbolCursor + 1]),\n                &(pgdata->symbolKeyBuf[pgdata->chiSymbolCursor]),\n                sizeof(pgdata->symbolKeyBuf[0]) * (pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));\n        pgdata->symbolKeyBuf[pgdata->chiSymbolCursor] = key;\n        pgdata->bUserArrCnnct[PhoneSeqCursor(pgdata)] = 0;\n        pgdata->chiSymbolCursor++;\n        pgdata->chiSymbolBufLen++;\n        /* reset Bopomofo data */\n        /* Don't forget the kbtype */\n        kbtype = pgdata->bopomofoData.kbtype;\n        memset(&(pgdata->bopomofoData), 0, sizeof(BopomofoData));\n        pgdata->bopomofoData.kbtype = kbtype;\n        return 1;\n    }\n    return 0;\n}",
        "begin_line": 141,
        "end_line": 174,
        "is_bug": false
    },
    {
        "name": "chewingutil.copyStringFromPreeditBuf#1449",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.copyStringFromPreeditBuf(ChewingData *pgdata, int pos, int len, char *output, int output_len)",
        "snippet": "void copyStringFromPreeditBuf(ChewingData *pgdata, int pos, int len, char *output, int output_len)\n{\n    int i;\n    int x;\n\n    assert(pgdata);\n    assert(0 <= pos && (size_t) (pos + len) < ARRAY_SIZE(pgdata->preeditBuf));\n    assert(output);\n    assert(output_len);\n\n    LOG_VERBOSE(\"Copy pos %d, len %d from preeditBuf\", pos, len);\n\n    for (i = pos; i < pos + len; ++i) {\n        x = strlen(pgdata->preeditBuf[i].char_);\n        if (x >= output_len)    // overflow\n            return;\n        memcpy(output, pgdata->preeditBuf[i].char_, x);\n        output += x;\n        output_len -= x;\n    }\n    output[0] = 0;\n}",
        "begin_line": 1449,
        "end_line": 1470,
        "is_bug": false
    },
    {
        "name": "chewingutil.toPreeditBufIndex#1476",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.toPreeditBufIndex(ChewingData *pgdata, int pos)",
        "snippet": "int toPreeditBufIndex(ChewingData *pgdata, int pos)\n{\n    int word_count;\n    int i;\n\n    assert(pgdata);\n    assert(0 <= pos && pos <= MAX_CHI_SYMBOL_LEN);\n\n    for (i = 0, word_count = 0; i < MAX_CHI_SYMBOL_LEN; ++i) {\n        if (ChewingIsChiAt(i, pgdata))\n            ++word_count;\n\n        /*\n         * pos = 0 means finding the first word, so we need to add one\n         * here.\n         */\n        if (word_count == pos + 1)\n            break;\n    }\n\n    LOG_VERBOSE(\"translate phoneSeq index %d to preeditBuf index %d\", pos, i);\n\n    return i;\n}",
        "begin_line": 1476,
        "end_line": 1499,
        "is_bug": false
    },
    {
        "name": "choice.ChangeSelectIntervalAndBreakpoint#33",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChangeSelectIntervalAndBreakpoint(ChewingData *pgdata, int from, int to, const char *str)",
        "snippet": "static void ChangeSelectIntervalAndBreakpoint(ChewingData *pgdata, int from, int to, const char *str)\n{\n    int i;\n    int user_alloc;\n\n    IntervalType inte;\n\n    inte.from = from;\n    inte.to = to;\n    for (i = 0; i < pgdata->nSelect; i++) {\n        if (IsIntersect(inte, pgdata->selectInterval[i])) {\n            RemoveSelectElement(i, pgdata);\n            i--;\n        }\n    }\n\n    pgdata->selectInterval[pgdata->nSelect].from = from;\n    pgdata->selectInterval[pgdata->nSelect].to = to;\n\n    /* No available selection */\n    if ((user_alloc = (to - from)) == 0)\n        return;\n\n    ueStrNCpy(pgdata->selectStr[pgdata->nSelect], str, user_alloc, 1);\n    pgdata->nSelect++;\n\n    if (user_alloc > 1) {\n        memset(&pgdata->bUserArrBrkpt[from + 1], 0, sizeof(int) * (user_alloc - 1));\n        memset(&pgdata->bUserArrCnnct[from + 1], 0, sizeof(int) * (user_alloc - 1));\n    }\n}",
        "begin_line": 33,
        "end_line": 63,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceEndChoice#520",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceEndChoice(ChewingData *pgdata)",
        "snippet": "int ChoiceEndChoice(ChewingData *pgdata)\n{\n    pgdata->bSelect = 0;\n    pgdata->choiceInfo.nTotalChoice = 0;\n    pgdata->choiceInfo.nPage = 0;\n\n    pgdata->chiSymbolCursor = pgdata->choiceInfo.oldChiSymbolCursor;\n    assert(pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen);\n\n    pgdata->choiceInfo.isSymbol = WORD_CHOICE;\n    return 0;\n}",
        "begin_line": 520,
        "end_line": 531,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceInfoAppendChi#170",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceInfoAppendChi(ChewingData *pgdata, ChoiceInfo *pci, uint16_t phone)",
        "snippet": "static void ChoiceInfoAppendChi(ChewingData *pgdata, ChoiceInfo *pci, uint16_t phone)\n{\n    Phrase tempWord;\n    int len;\n\n    if (GetCharFirst(pgdata, &tempWord, phone)) {\n        do {\n            len = ueBytesFromChar(tempWord.phrase[0]);\n            if (ChoiceTheSame(pci, tempWord.phrase, len))\n                continue;\n            assert(pci->nTotalChoice < MAX_CHOICE);\n            memcpy(pci->totalChoiceStr[pci->nTotalChoice], tempWord.phrase, len);\n            pci->totalChoiceStr[pci->nTotalChoice]\n                [len] = '\\0';\n            pci->nTotalChoice++;\n        } while (GetVocabNext(pgdata, &tempWord));\n    }\n}",
        "begin_line": 170,
        "end_line": 187,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceInitAvail#382",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceInitAvail(ChewingData *pgdata)",
        "snippet": "int ChoiceInitAvail(ChewingData *pgdata)\n{\n    int end, begin;\n\n    /* save old cursor position */\n    pgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;\n\n    /* see if there is some word in the cursor position */\n    if (pgdata->chiSymbolBufLen == pgdata->chiSymbolCursor) {\n        pgdata->chiSymbolCursor--;\n    }\n\n    end = PhoneSeqCursor(pgdata);\n\n    if (pgdata->config.bPhraseChoiceRearward) {\n        pgdata->chiSymbolCursor = SeekPhraseHead(pgdata) + CountSymbols(pgdata, pgdata->chiSymbolCursor);\n    }\n    begin = PhoneSeqCursor(pgdata);\n\n    pgdata->bSelect = 1;\n\n    SetAvailInfo(pgdata, begin, end);\n\n    if (!pgdata->availInfo.nAvail)\n        return ChoiceEndChoice(pgdata);\n\n    pgdata->availInfo.currentAvail = pgdata->availInfo.nAvail - 1;\n    SetChoiceInfo(pgdata);\n    return 0;\n}",
        "begin_line": 382,
        "end_line": 411,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceSelect#534",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceSelect(ChewingData *pgdata, int selectNo)",
        "snippet": "int ChoiceSelect(ChewingData *pgdata, int selectNo)\n{\n    ChoiceInfo *pci = &(pgdata->choiceInfo);\n    AvailInfo *pai = &(pgdata->availInfo);\n\n    ChangeSelectIntervalAndBreakpoint(pgdata,\n                                      PhoneSeqCursor(pgdata),\n                                      PhoneSeqCursor(pgdata) + pai->avail[pai->currentAvail].len,\n                                      pci->totalChoiceStr[selectNo]);\n    ChoiceEndChoice(pgdata);\n    return 0;\n}",
        "begin_line": 534,
        "end_line": 545,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceTheSame#160",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceTheSame(ChoiceInfo *pci, const char *str, int len)",
        "snippet": "static int ChoiceTheSame(ChoiceInfo *pci, const char *str, int len)\n{\n    int i;\n\n    for (i = 0; i < pci->nTotalChoice; i++)\n        if (!strncmp(pci->totalChoiceStr[i], str, len))\n            return 1;\n    return 0;\n}",
        "begin_line": 160,
        "end_line": 168,
        "is_bug": false
    },
    {
        "name": "choice.SeekPhraseHead#368",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.SeekPhraseHead(ChewingData *pgdata)",
        "snippet": "static int SeekPhraseHead(ChewingData *pgdata)\n{\n    int i;\n    int phoneSeq = PhoneSeqCursor(pgdata);\n\n    for (i = pgdata->nPrefer - 1; i >= 0; i--) {\n        if (pgdata->preferInterval[i].from > phoneSeq || pgdata->preferInterval[i].to < phoneSeq)\n            continue;\n        return pgdata->preferInterval[i].from;\n    }\n    return 0;\n}",
        "begin_line": 368,
        "end_line": 379,
        "is_bug": false
    },
    {
        "name": "choice.SetAvailInfo#66",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.SetAvailInfo(ChewingData *pgdata, int begin, int end)",
        "snippet": "static void SetAvailInfo(ChewingData *pgdata, int begin, int end)\n{\n    AvailInfo *pai = &(pgdata->availInfo);\n    const uint16_t *phoneSeq = pgdata->phoneSeq;\n    int nPhoneSeq = pgdata->nPhoneSeq;\n    const int *bSymbolArrBrkpt = pgdata->bSymbolArrBrkpt;\n    int symbolArrBrkpt[ARRAY_SIZE(pgdata->bSymbolArrBrkpt)] = { 0 };\n\n    const TreeType *tree_pos;\n    int diff;\n    uint16_t userPhoneSeq[MAX_PHONE_SEQ_LEN];\n\n    int i, head, head_tmp;\n    int tail, tail_tmp;\n    int pos;\n\n    head = tail = 0;\n\n    pai->nAvail = 0;\n\n    /*\n     * XXX: The phoneSeq, nPhoneSeq skip any symbol in preedit buffer,\n     * while bSymbolArrBrkpt, does not skip any symbol in preedit\n     * buffer. So we need to do some translate here.\n     */\n    for (i = 0; i < pgdata->chiSymbolBufLen; ++i) {\n        if (bSymbolArrBrkpt[i]) {\n            /*\n             * XXX: If preedit buffer starts with symbol, the pos\n             * will become negative. In this case, we just ignore\n             * this symbol because it does not create any break\n             * point.\n             */\n            pos = i - CountSymbols(pgdata, i + 1);\n            if (pos >= 0)\n                symbolArrBrkpt[pos] = 1;\n        }\n    }\n\n    if (pgdata->config.bPhraseChoiceRearward) {\n        for (i = end; i >= begin; i--) {\n            if (symbolArrBrkpt[i])\n                break;\n            head = i;\n        }\n        head_tmp = end;\n    } else {\n        head_tmp = head = begin;\n    }\n\n    if (pgdata->config.bPhraseChoiceRearward) {\n        tail_tmp = tail = end;\n    } else {\n        for (i = begin; i < nPhoneSeq; i++) {\n            tail = i;\n            if (symbolArrBrkpt[i])\n                break;\n        }\n        tail_tmp = begin;\n    }\n\n    while (head <= head_tmp && tail_tmp <= tail) {\n        diff = tail_tmp - head_tmp;\n        tree_pos = TreeFindPhrase(pgdata, head_tmp, tail_tmp, phoneSeq);\n\n        if (tree_pos) {\n            /* save it! */\n            pai->avail[pai->nAvail].len = diff + 1;\n            pai->avail[pai->nAvail].id = tree_pos;\n            pai->nAvail++;\n        } else {\n            memcpy(userPhoneSeq, &phoneSeq[head_tmp], sizeof(uint16_t) * (diff + 1));\n            userPhoneSeq[diff + 1] = 0;\n            if (UserGetPhraseFirst(pgdata, userPhoneSeq)) {\n                /* save it! */\n                pai->avail[pai->nAvail].len = diff + 1;\n                pai->avail[pai->nAvail].id = NULL;\n                pai->nAvail++;\n            } else {\n                pai->avail[pai->nAvail].len = 0;\n                pai->avail[pai->nAvail].id = NULL;\n            }\n            UserGetPhraseEnd(pgdata, userPhoneSeq);\n        }\n\n        if (pgdata->config.bPhraseChoiceRearward) {\n            head_tmp--;\n        } else {\n            tail_tmp++;\n        }\n    }\n}",
        "begin_line": 66,
        "end_line": 157,
        "is_bug": false
    },
    {
        "name": "choice.SetChoiceInfo#195",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.SetChoiceInfo(ChewingData *pgdata)",
        "snippet": "static void SetChoiceInfo(ChewingData *pgdata)\n{\n    Phrase tempPhrase;\n    int len;\n    UserPhraseData *pUserPhraseData;\n    uint16_t userPhoneSeq[MAX_PHONE_SEQ_LEN];\n\n    ChoiceInfo *pci = &(pgdata->choiceInfo);\n    AvailInfo *pai = &(pgdata->availInfo);\n    uint16_t *phoneSeq = pgdata->phoneSeq;\n    uint16_t *phoneSeqAlt = pgdata->phoneSeqAlt;\n    int cursor = PhoneSeqCursor(pgdata);\n    int candPerPage = pgdata->config.candPerPage;\n\n    /* Clears previous candidates. */\n    memset(pci->totalChoiceStr, '\\0', MAX_CHOICE * MAX_PHRASE_LEN * MAX_UTF8_SIZE + 1);\n\n    pci->nTotalChoice = 0;\n    len = pai->avail[pai->currentAvail].len;\n    assert(len);\n\n    /* secondly, read tree phrase */\n    if (len == 1) {             /* single character */\n        ChoiceInfoAppendChi(pgdata, pci, phoneSeq[cursor]);\n\n        if (phoneSeq[cursor] != phoneSeqAlt[cursor]) {\n            ChoiceInfoAppendChi(pgdata, pci, phoneSeqAlt[cursor]);\n        }\n\n        if (pgdata->bopomofoData.kbtype == KB_HSU || pgdata->bopomofoData.kbtype == KB_DVORAK_HSU) {\n            switch (phoneSeq[cursor]) {\n            case 0x2800:       /* '\u3118' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x30);     /* '\u311f' */\n                break;\n            case 0x80:         /* '\u3127' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x20);     /* '\u311d' */\n                break;\n            case 0x2A00:       /* '\u3119' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1);      /* '\u02d9' */\n                break;\n            case 0xA00:        /* '\u3109' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x2);      /* '\u02ca' */\n                break;\n            case 0x800:        /* '\u3108' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x3);      /* '\u02c7' */\n                break;\n            case 0x18:         /* '\u311c' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1200);   /* '\u310d' */\n                break;\n            case 0x10:         /* '\u311b' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1600);   /* '\u310f' */\n                break;\n            case 0x1E00:       /* '\u3113' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1800);   /* '\u3110' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x4);      /* '\u02cb' */\n                break;\n            case 0x58:         /* '\u3124' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1400);   /* '\u310e' */\n                break;\n            case 0x68:         /* '\u3126' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1000);   /* '\u310c' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x60);     /* '\u3125' */\n                break;\n            case 0x2200:       /* '\u3115' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1C00);   /* '\u3112' */\n                break;\n            case 0x2000:       /* '\u3114' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1A00);   /* '\u3111' */\n                break;\n            case 0x50:         /* '\u3123' */\n                ChoiceInfoAppendChi(pgdata, pci, 0xE00);    /* '\u310b' */\n                break;\n            case 0x48:         /* '\u3122' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x600);    /* '\u3107' */\n                break;\n            default:\n                break;\n            }\n        }\n\n        if (pgdata->bopomofoData.kbtype == KB_ET26) {\n            switch (phoneSeq[cursor]) {\n            case 0x40:      /* '\u3121' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x400);    /* '\u3106' */\n                break;\n            case 0x58:      /* '\u3124' */\n                ChoiceInfoAppendChi(pgdata, pci, 0xC00);    /* '\u310a' */\n                break;\n            case 0x2800:    /* '\u3118' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x20);     /* '\u311d' */\n                break;\n            case 0x2600:    /* '\u3117' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x30);     /* '\u311f' */\n                break;\n            case 0x1E00:    /* '\u3113' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1800);   /* '\u3110' */\n                break;\n            case 0x68:      /* '\u3126' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1600);   /* '\u310f' */\n                break;\n            case 0x60:      /* '\u3125' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1000);   /* '\u310c' */\n                break;\n            case 0x2200:    /* '\u3115' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1C00);   /* '\u3112' */\n                break;\n            case 0x1200:    /* '\u310d' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1A00);   /* '\u3111' */\n                break;\n            case 0x50:      /* '\u3123' */\n                ChoiceInfoAppendChi(pgdata, pci, 0xE00);    /* '\u310b' */\n                break;\n            case 0x48:      /* '\u3122' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x600);    /* '\u3107' */\n                break;\n            case 0xA00:     /* '\u3109' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1);      /* '\u02d9' */\n                break;\n            case 0x800:     /* '\u3108' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x2);      /* '\u02ca' */\n                break;\n            case 0x2400:    /* '\u3116' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x3);      /* '\u02c7' */\n                break;\n            case 0x1400:    /* '\u310e' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x4);      /* '\u02cb' */\n                break;\n            default:\n                break;\n            }\n        }\n    }\n    /* phrase */\n    else {\n        if (pai->avail[pai->currentAvail].id) {\n            GetPhraseFirst(pgdata, &tempPhrase, pai->avail[pai->currentAvail].id);\n            do {\n                if (ChoiceTheSame(pci, tempPhrase.phrase, len * ueBytesFromChar(tempPhrase.phrase[0]))) {\n                    continue;\n                }\n                ueStrNCpy(pci->totalChoiceStr[pci->nTotalChoice], tempPhrase.phrase, len, 1);\n                pci->nTotalChoice++;\n            } while (GetVocabNext(pgdata, &tempPhrase));\n        }\n\n        memcpy(userPhoneSeq, &phoneSeq[cursor], sizeof(uint16_t) * len);\n        userPhoneSeq[len] = 0;\n        pUserPhraseData = UserGetPhraseFirst(pgdata, userPhoneSeq);\n        if (pUserPhraseData) {\n            do {\n                /* check if the phrase is already in the choice list */\n                if (ChoiceTheSame(pci, pUserPhraseData->wordSeq, len * ueBytesFromChar(pUserPhraseData->wordSeq[0])))\n                    continue;\n                /* otherwise store it */\n                ueStrNCpy(pci->totalChoiceStr[pci->nTotalChoice], pUserPhraseData->wordSeq, len, 1);\n                pci->nTotalChoice++;\n            } while ((pUserPhraseData = UserGetPhraseNext(pgdata, userPhoneSeq)) != NULL);\n        }\n        UserGetPhraseEnd(pgdata, userPhoneSeq);\n\n    }\n\n    /* magic number */\n    pci->nChoicePerPage = candPerPage;\n    assert(pci->nTotalChoice > 0);\n    pci->nPage = CEIL_DIV(pci->nTotalChoice, pci->nChoicePerPage);\n    pci->pageNo = 0;\n    pci->isSymbol = WORD_CHOICE;\n}\n\n/*\n * Seek the start of the phrase (English characters are skipped.)\n */\nstatic int SeekPhraseHead(ChewingData",
        "begin_line": 195,
        "end_line": 363,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueBytesFromChar#41",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueBytesFromChar(unsigned char b)",
        "snippet": "int ueBytesFromChar(unsigned char b)\n{\n    return utf8len_tab[b];\n}",
        "begin_line": 41,
        "end_line": 44,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueConstStrSeek#70",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueConstStrSeek(const char *src, size_t n)",
        "snippet": "const char *ueConstStrSeek(const char *src, size_t n)\n{\n    size_t i = 0;\n    const char *iter = src;\n\n    for (i = 0; i < n; i++) {\n        iter += ueBytesFromChar(iter[0]);\n    }\n    return iter;\n}",
        "begin_line": 70,
        "end_line": 79,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueStrLen#28",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueStrLen(const char *str)",
        "snippet": "int ueStrLen(const char *str)\n{\n    int length = 0;\n    const char *strptr = str;\n\n    while (strptr[0] != '\\0') {\n        strptr += ueBytesFromChar(strptr[0]);\n        ++length;\n    }\n    return length;\n}",
        "begin_line": 28,
        "end_line": 38,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueStrNBytes#47",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueStrNBytes(const char *str, int n)",
        "snippet": "int ueStrNBytes(const char *str, int n)\n{\n    int i = 0, len = 0;\n    const char *iter = str;\n\n    for (i = 0; i < n; i++) {\n        len += ueBytesFromChar(iter[len]);\n    }\n    return len;\n}",
        "begin_line": 47,
        "end_line": 56,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueStrNCpy#59",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueStrNCpy(char dest[], const char *src, size_t n, int end)",
        "snippet": "int ueStrNCpy(char dest[], const char *src, size_t n, int end)\n{\n    int len = 0;\n\n    len = ueStrNBytes(src, n);\n    memcpy(dest, src, len);\n    if (end == STRNCPY_CLOSE)\n        dest[len] = '\\0';\n    return len;\n}",
        "begin_line": 59,
        "end_line": 68,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueStrSeek#81",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueStrSeek(char *src, size_t n)",
        "snippet": "char *ueStrSeek(char *src, size_t n)\n{\n    size_t i = 0;\n    char *iter = src;\n\n    for (i = 0; i < n; i++) {\n        iter += ueBytesFromChar(iter[0]);\n    }\n    return iter;\n}",
        "begin_line": 81,
        "end_line": 90,
        "is_bug": false
    },
    {
        "name": "common.key2pho.GetPhoneLen#218",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.GetPhoneLen(const uint16_t *phoneSeq)",
        "snippet": "size_t GetPhoneLen(const uint16_t *phoneSeq)\n{\n    size_t len = 0;\n\n    assert(phoneSeq);\n\n    while (phoneSeq[len])\n        ++len;\n    return len;\n}",
        "begin_line": 218,
        "end_line": 227,
        "is_bug": false
    },
    {
        "name": "common.key2pho.PhoneFromKey#125",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.PhoneFromKey(char *pho, const char *inputkey, KBTYPE kbtype, int searchTimes)",
        "snippet": "int PhoneFromKey(char *pho, const char *inputkey, KBTYPE kbtype, int searchTimes)\n{\n    int len;\n    int i;\n    int s;\n    const char *pTarget;\n\n    len = strlen(inputkey);\n\n    pho[0] = '\\0';\n    for (i = 0; i < len; i++) {\n        char *findptr = NULL;\n        int _index;\n\n        pTarget = key_str[kbtype];\n        for (s = 0; s < searchTimes; s++) {\n            findptr = strchr(pTarget, inputkey[i]);\n            if (!findptr) {\n                return 0;\n            }\n            pTarget = findptr + 1;\n        }\n        _index = findptr - key_str[kbtype];\n        ueStrNCpy(ueStrSeek(pho, i), ueConstStrSeek(ph_str, _index), 1, STRNCPY_NOT_CLOSE);\n    }\n    pho = ueStrSeek(pho, len);\n    pho[0] = '\\0';\n    return 1;\n}",
        "begin_line": 125,
        "end_line": 153,
        "is_bug": false
    },
    {
        "name": "common.key2pho.PhoneInxFromKey#184",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.PhoneInxFromKey(int key, int type, KBTYPE kbtype, int searchTimes)",
        "snippet": "int PhoneInxFromKey(int key, int type, KBTYPE kbtype, int searchTimes)\n{\n    char keyStr[2];\n    char rtStr[10];\n    char *p;\n\n    keyStr[0] = key;\n    keyStr[1] = '\\0';\n\n    if (!PhoneFromKey(rtStr, keyStr, kbtype, searchTimes))\n        return 0;\n\n    p = strstr(zhuin_tab[type], rtStr);\n    if (!p)\n        return 0;\n\n    return zhuin_tab_num[type] - ueStrLen(p);\n}",
        "begin_line": 184,
        "end_line": 201,
        "is_bug": false
    },
    {
        "name": "common.key2pho.UintFromPhoneInx#203",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.UintFromPhoneInx(const int ph_inx[])",
        "snippet": "uint16_t UintFromPhoneInx(const int ph_inx[])\n{\n    int i;\n    uint16_t result = 0;\n\n    for (i = 0; i < BOPOMOFO_SIZE; i++) {\n        if (ph_inx[i] < 0 || ph_inx[i] >= zhuin_tab_num[i])\n            return 0;\n\n        result |= ph_inx[i] << shift[i];\n    }\n\n    return result;\n}",
        "begin_line": 203,
        "end_line": 216,
        "is_bug": false
    },
    {
        "name": "dict.GetCharFirst#72",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.GetCharFirst(ChewingData *pgdata, Phrase *wrd_ptr, uint16_t key)",
        "snippet": "int GetCharFirst(ChewingData *pgdata, Phrase *wrd_ptr, uint16_t key)\n{\n    /* &key serves as an array whose begin and end are both 0. */\n    const TreeType *pinx = TreeFindPhrase(pgdata, 0, 0, &key);\n\n    if (!pinx)\n        return 0;\n    TreeChildRange(pgdata, pinx);\n    GetVocabFromDict(pgdata, wrd_ptr);\n    return 1;\n}",
        "begin_line": 72,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "dict.GetPhraseFirst#89",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.GetPhraseFirst(ChewingData *pgdata, Phrase *phr_ptr, const TreeType *phrase_parent)",
        "snippet": "int GetPhraseFirst(ChewingData *pgdata, Phrase *phr_ptr, const TreeType *phrase_parent)\n{\n    assert(phrase_parent);\n\n    TreeChildRange(pgdata, phrase_parent);\n    GetVocabFromDict(pgdata, phr_ptr);\n    return 1;\n}",
        "begin_line": 89,
        "end_line": 96,
        "is_bug": false
    },
    {
        "name": "dict.GetVocabFromDict#65",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.GetVocabFromDict(ChewingData *pgdata, Phrase *phr_ptr)",
        "snippet": "static void GetVocabFromDict(ChewingData *pgdata, Phrase *phr_ptr)\n{\n    snprintf(phr_ptr->phrase, sizeof(phr_ptr->phrase), \"%s\", pgdata->static_data.dict + GetUint24(pgdata->static_data.tree_cur_pos->phrase.pos));\n    phr_ptr->freq = GetUint24(pgdata->static_data.tree_cur_pos->phrase.freq);\n    pgdata->static_data.tree_cur_pos++;\n}",
        "begin_line": 65,
        "end_line": 70,
        "is_bug": false
    },
    {
        "name": "dict.GetVocabNext#98",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.GetVocabNext(ChewingData *pgdata, Phrase *phr_ptr)",
        "snippet": "int GetVocabNext(ChewingData *pgdata, Phrase *phr_ptr)\n{\n    if (pgdata->static_data.tree_cur_pos >= pgdata->static_data.tree_end_pos\n        || GetUint16(pgdata->static_data.tree_cur_pos->key) != 0)\n        return 0;\n    GetVocabFromDict(pgdata, phr_ptr);\n    return 1;\n}",
        "begin_line": 98,
        "end_line": 105,
        "is_bug": false
    },
    {
        "name": "dict.InitDict#35",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.InitDict(ChewingData *pgdata, const char *prefix)",
        "snippet": "int InitDict(ChewingData *pgdata, const char *prefix)\n{\n    char filename[PATH_MAX];\n    size_t len;\n    size_t offset;\n    size_t file_size;\n    size_t csize;\n\n    len = snprintf(filename, sizeof(filename), \"%s\" PLAT_SEPARATOR \"%s\", prefix, DICT_FILE);\n    if (len + 1 > sizeof(filename))\n        return -1;\n\n    plat_mmap_set_invalid(&pgdata->static_data.dict_mmap);\n    file_size = plat_mmap_create(&pgdata->static_data.dict_mmap, filename, FLAG_ATTRIBUTE_READ);\n    if (file_size <= 0)\n        return -1;\n\n    offset = 0;\n    csize = file_size;\n    pgdata->static_data.dict = (const char *) plat_mmap_set_view(&pgdata->static_data.dict_mmap, &offset, &csize);\n    if (!pgdata->static_data.dict)\n        return -1;\n\n    return 0;\n}",
        "begin_line": 35,
        "end_line": 59,
        "is_bug": false
    },
    {
        "name": "dict.TerminateDict#30",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.TerminateDict(ChewingData *pgdata)",
        "snippet": "void TerminateDict(ChewingData *pgdata)\n{\n    plat_mmap_close(&pgdata->static_data.dict_mmap);\n}",
        "begin_line": 30,
        "end_line": 33,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_buffer_Check#84",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_buffer_Check(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_buffer_Check(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return (ctx->output->chiSymbolBufLen != 0);\n}",
        "begin_line": 84,
        "end_line": 96,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_buffer_Len#98",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_buffer_Len(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_buffer_Len(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return ctx->output->chiSymbolBufLen;\n}",
        "begin_line": 98,
        "end_line": 110,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_buffer_String#112",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_buffer_String(const ChewingContext *ctx)",
        "snippet": "CHEWING_API char *chewing_buffer_String(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return strdup(\"\");\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return strdup(ctx->output->preeditBuf);\n}",
        "begin_line": 112,
        "end_line": 124,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_buffer_String_static#126",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_buffer_String_static(const ChewingContext *ctx)",
        "snippet": "CHEWING_API const char *chewing_buffer_String_static(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return \"\";\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return ctx->output->preeditBuf;\n}",
        "begin_line": 126,
        "end_line": 138,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_commit_Check#30",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_commit_Check(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_commit_Check(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return ! !(ctx->output->keystrokeRtn & KEYSTROKE_COMMIT);\n}",
        "begin_line": 30,
        "end_line": 42,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_commit_String#50",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_commit_String(const ChewingContext *ctx)",
        "snippet": "CHEWING_API char *chewing_commit_String(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return strdup(\"\");\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return strdup(ctx->output->commitBuf);\n}",
        "begin_line": 50,
        "end_line": 62,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_commit_String_static#70",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_commit_String_static(const ChewingContext *ctx)",
        "snippet": "CHEWING_API const char *chewing_commit_String_static(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return \"\";\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return ctx->output->commitBuf;\n}",
        "begin_line": 70,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_cursor_Current#174",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_cursor_Current(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_cursor_Current(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return (ctx->output->chiSymbolCursor);\n}",
        "begin_line": 174,
        "end_line": 186,
        "is_bug": false
    },
    {
        "name": "pinyin.InitPinyin#29",
        "src_path": "src/pinyin.c",
        "class_name": "pinyin",
        "signature": "pinyin.InitPinyin(ChewingData *pgdata, const char *prefix)",
        "snippet": "int InitPinyin(ChewingData *pgdata, const char *prefix)\n{\n    char filename[PATH_MAX];\n    int i;\n    FILE *fd;\n    int ret;\n\n    sprintf(filename, \"%s\" PLAT_SEPARATOR \"%s\", prefix, PINYIN_TAB_NAME);\n\n    fd = fopen(filename, \"r\");\n\n    if (!fd)\n        return 0;\n\n    ret = fscanf(fd, \"%d\", &pgdata->static_data.HANYU_INITIALS);\n    if (ret != 1) {\n        goto fail;\n    }\n    ++pgdata->static_data.HANYU_INITIALS;\n    pgdata->static_data.hanyuInitialsMap = ALC(keymap, pgdata->static_data.HANYU_INITIALS);\n    for (i = 0; i < pgdata->static_data.HANYU_INITIALS - 1; i++) {\n        ret = fscanf(fd, \"%s %s\",\n                     pgdata->static_data.hanyuInitialsMap[i].pinyin, pgdata->static_data.hanyuInitialsMap[i].bopomofo);\n        if (ret != 2) {\n            goto fail;\n        }\n    }\n\n    ret = fscanf(fd, \"%d\", &pgdata->static_data.HANYU_FINALS);\n    if (ret != 1) {\n        goto fail;\n    }\n    ++pgdata->static_data.HANYU_FINALS;\n    pgdata->static_data.hanyuFinalsMap = ALC(keymap, pgdata->static_data.HANYU_FINALS);\n    for (i = 0; i < pgdata->static_data.HANYU_FINALS - 1; i++) {\n        ret = fscanf(fd, \"%s %s\",\n                     pgdata->static_data.hanyuFinalsMap[i].pinyin, pgdata->static_data.hanyuFinalsMap[i].bopomofo);\n        if (ret != 2) {\n            goto fail;\n        }\n    }\n\n    fclose(fd);\n    return 1;\n\nfail:\n    fclose(fd);\n    return 0;\n}",
        "begin_line": 29,
        "end_line": 77,
        "is_bug": false
    },
    {
        "name": "pinyin.TerminatePinyin#23",
        "src_path": "src/pinyin.c",
        "class_name": "pinyin",
        "signature": "pinyin.TerminatePinyin(ChewingData *pgdata)",
        "snippet": "void TerminatePinyin(ChewingData *pgdata)\n{\n    free(pgdata->static_data.hanyuInitialsMap);\n    free(pgdata->static_data.hanyuFinalsMap);\n}",
        "begin_line": 23,
        "end_line": 27,
        "is_bug": false
    },
    {
        "name": "porting_layer.plat_path.are_all_files_readable#153",
        "src_path": "src/porting_layer/src/plat_path.c",
        "class_name": "porting_layer.plat_path",
        "signature": "porting_layer.plat_path.are_all_files_readable(const char *path, const char *const *files, char *output, size_t output_len)",
        "snippet": "static int are_all_files_readable(const char *path,\n                                  const char *const *files,\n                                  char *output, size_t output_len)\n{\n    int i;\n\n    assert(path);\n    assert(files);\n\n    for (i = 0; files[i] != NULL; ++i) {\n        snprintf(output, output_len,\n                 \"%s\" PLAT_SEPARATOR \"%s\", path, files[i]);\n        if (access(output, R_OK) != 0)\n            return 0;\n    }\n\n    return 1;\n}",
        "begin_line": 153,
        "end_line": 170,
        "is_bug": false
    },
    {
        "name": "porting_layer.plat_path.find_path_by_files#172",
        "src_path": "src/porting_layer/src/plat_path.c",
        "class_name": "porting_layer.plat_path",
        "signature": "porting_layer.plat_path.find_path_by_files(const char *search_path, const char *const *files, char *output, size_t output_len)",
        "snippet": "int find_path_by_files(const char *search_path,\n                       const char *const *files,\n                       char *output, size_t output_len)\n{\n    char buffer[PATH_MAX + 1] = {0};\n    char *path;\n    char *saveptr;\n    int ret;\n\n    assert(search_path);\n    assert(files);\n    assert(output);\n    assert(output_len);\n\n    /* strtok_r will modify its first parameter. */\n    strncpy(buffer, search_path, sizeof(buffer) - 1);\n\n    for (path = strtok_r(buffer, SEARCH_PATH_SEP, &saveptr); path;\n         path = strtok_r(NULL, SEARCH_PATH_SEP, &saveptr)) {\n        ret = are_all_files_readable(path, files, output, output_len);\n        if (ret) {\n            snprintf(output, output_len, \"%s\", path);\n            return 0;\n        }\n    }\n    return -1;\n}",
        "begin_line": 172,
        "end_line": 198,
        "is_bug": false
    },
    {
        "name": "tree.AddInterval#285",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.AddInterval(TreeDataType *ptd, int begin, int end, Phrase *p_phrase, int dict_or_user)",
        "snippet": "static void AddInterval(TreeDataType *ptd, int begin, int end, Phrase *p_phrase, int dict_or_user)\n{\n    ptd->interval[ptd->nInterval].from = begin;\n    ptd->interval[ptd->nInterval].to = end + 1;\n    ptd->interval[ptd->nInterval].p_phr = p_phrase;\n    ptd->interval[ptd->nInterval].source = dict_or_user;\n    ptd->nInterval++;\n}",
        "begin_line": 285,
        "end_line": 292,
        "is_bug": false
    },
    {
        "name": "tree.CheckBreakpoint#110",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CheckBreakpoint(int from, int to, int bArrBrkpt[])",
        "snippet": "static int CheckBreakpoint(int from, int to, int bArrBrkpt[])\n{\n    int i;\n\n    for (i = from + 1; i < to; i++)\n        if (bArrBrkpt[i])\n            return 0;\n    return 1;\n}",
        "begin_line": 110,
        "end_line": 118,
        "is_bug": false
    },
    {
        "name": "tree.CheckChoose#198",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CheckChoose(ChewingData *pgdata, const TreeType *phrase_parent, int from, int to, Phrase **pp_phr, char selectStr[][MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1], IntervalType selectInterval[], int nSelect)",
        "snippet": "static int CheckChoose(ChewingData *pgdata,\n                       const TreeType *phrase_parent, int from, int to, Phrase **pp_phr,\n                       char selectStr[][MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1],\n                       IntervalType selectInterval[], int nSelect)\n{\n    IntervalType inte, c;\n    int chno, len;\n    Phrase *phrase = ALC(Phrase, 1);\n\n    assert(phrase);\n    inte.from = from;\n    inte.to = to;\n    *pp_phr = NULL;\n\n    /* if there exist one phrase satisfied all selectStr then return 1, else return 0. */\n    GetPhraseFirst(pgdata, phrase, phrase_parent);\n    do {\n        for (chno = 0; chno < nSelect; chno++) {\n            c = selectInterval[chno];\n\n            if (IsContain(inte, c)) {\n                /* find a phrase under phrase_parent where the text contains\n                 * 'selectStr[chno]' test if not ok then return 0, if ok\n                 * then continue to test\n                 */\n                len = c.to - c.from;\n                if (memcmp(ueStrSeek(phrase->phrase, c.from - from),\n                           selectStr[chno], ueStrNBytes(selectStr[chno], len)))\n                    break;\n            } else if (IsIntersect(inte, selectInterval[chno])) {\n                free(phrase);\n                return 0;\n            }\n        }\n        if (chno == nSelect) {\n            *pp_phr = phrase;\n            return 1;\n        }\n    } while (GetVocabNext(pgdata, phrase));\n    free(phrase);\n    return 0;\n}",
        "begin_line": 198,
        "end_line": 239,
        "is_bug": false
    },
    {
        "name": "tree.CleanUpMem#758",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CleanUpMem(TreeDataType *ptd)",
        "snippet": "static void CleanUpMem(TreeDataType *ptd)\n{\n    int i;\n    RecordNode *pNode;\n\n    for (i = 0; i < ptd->nInterval; i++) {\n        if (ptd->interval[i].p_phr) {\n            free(ptd->interval[i].p_phr);\n            ptd->interval[i].p_phr = NULL;\n        }\n    }\n    while (ptd->phList != NULL) {\n        pNode = ptd->phList;\n        ptd->phList = pNode->next;\n        free(pNode->arrIndex);\n        free(pNode);\n    }\n}",
        "begin_line": 758,
        "end_line": 775,
        "is_bug": false
    },
    {
        "name": "tree.CompTreeType#241",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CompTreeType(const void *a, const void *b)",
        "snippet": "static int CompTreeType(const void *a, const void *b)\n{\n    return GetUint16(((TreeType *) a)->key) - GetUint16(((TreeType *) b)->key);\n}",
        "begin_line": 241,
        "end_line": 244,
        "is_bug": false
    },
    {
        "name": "tree.CountMatchCnnct#777",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CountMatchCnnct(TreeDataType *ptd, const int *bUserArrCnnct, int nPhoneSeq)",
        "snippet": "static void CountMatchCnnct(TreeDataType *ptd, const int *bUserArrCnnct, int nPhoneSeq)\n{\n    RecordNode *p;\n    int i, k, sum;\n\n    for (p = ptd->phList; p; p = p->next) {\n        /* for each record, count its 'nMatchCnnct' */\n        for (sum = 0, i = 1; i < nPhoneSeq; i++) {\n            if (!bUserArrCnnct[i])\n                continue;\n            /* check if matching 'cnnct' */\n            for (k = 0; k < p->nInter; k++) {\n                if (ptd->interval[p->arrIndex[k]].from < i && ptd->interval[p->arrIndex[k]].to > i) {\n                    sum++;\n                    break;\n                }\n            }\n        }\n        p->nMatchCnnct = sum;\n    }\n}",
        "begin_line": 777,
        "end_line": 797,
        "is_bug": false
    },
    {
        "name": "tree.CreateNullIntervalRecord#913",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CreateNullIntervalRecord()",
        "snippet": "static RecordNode *CreateNullIntervalRecord()\n{\n    RecordNode *ret = NULL;\n    ret = ALC(RecordNode, 1);\n\n    if (!ret)\n        return NULL;\n\n    ret->arrIndex = ALC(int, 1);\n    if (!ret->arrIndex) {\n        free(ret);\n        return NULL;\n    }\n\n    ret->nInter = 0;\n    ret->score = 0;\n\n    return ret;\n}",
        "begin_line": 913,
        "end_line": 931,
        "is_bug": false
    },
    {
        "name": "tree.CreateSingleIntervalRecord#888",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CreateSingleIntervalRecord(TreeDataType *pdt, const int interval_id)",
        "snippet": "static RecordNode *CreateSingleIntervalRecord(TreeDataType *pdt, const int interval_id)\n{\n    RecordNode *ret = NULL;\n\n    assert(pdt);\n\n    ret = ALC(RecordNode, 1);\n\n    if (!ret)\n        return NULL;\n\n    ret->arrIndex = ALC(int, 1);\n    if (!ret->arrIndex) {\n        free(ret);\n        return NULL;\n    }\n\n    ret->nInter = 1;\n    ret->arrIndex[0] = interval_id;\n\n    ret->score = LoadPhraseAndCountScore(ret->arrIndex, ret->nInter, pdt);\n\n    return ret;\n}",
        "begin_line": 888,
        "end_line": 911,
        "is_bug": false
    },
    {
        "name": "tree.Discard1#437",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.Discard1(TreeDataType *ptd)",
        "snippet": "static void Discard1(TreeDataType *ptd)\n{\n    int a, b;\n    char failflag[INTERVAL_SIZE];\n    int nInterval2;\n\n    memset(failflag, 0, sizeof(failflag));\n    for (a = 0; a < ptd->nInterval; a++) {\n        if (failflag[a])\n            continue;\n        for (b = 0; b < ptd->nInterval; b++) {\n            if (a == b || failflag[b])\n                continue;\n\n            /* interval b is in interval a */\n            if (PhraseIntervalContain(ptd->interval[a], ptd->interval[b]))\n                continue;\n\n            /* interval b is in front of interval a */\n            if (ptd->interval[b].to <= ptd->interval[a].from)\n                continue;\n\n            /* interval b is in back of interval a */\n            if (ptd->interval[a].to <= ptd->interval[b].from)\n                continue;\n\n            break;\n        }\n        /* if any other interval b is inside or leftside or rightside the\n         * interval a */\n        if (b >= ptd->nInterval) {\n            /* then kill all the intervals inside the interval a */\n            int i;\n\n            for (i = 0; i < ptd->nInterval; i++) {\n                if (!failflag[i] && i != a && PhraseIntervalContain(ptd->interval[a], ptd->interval[i])) {\n                    failflag[i] = 1;\n                }\n            }\n        }\n    }\n    /* discard all the intervals whose failflag[a] = 1 */\n    nInterval2 = 0;\n    for (a = 0; a < ptd->nInterval; a++) {\n        if (!failflag[a]) {\n            ptd->interval[nInterval2++] = ptd->interval[a];\n        } else {\n            if (ptd->interval[a].p_phr != NULL) {\n                free(ptd->interval[a].p_phr);\n            }\n        }\n    }\n    ptd->nInterval = nInterval2;\n}",
        "begin_line": 437,
        "end_line": 490,
        "is_bug": false
    },
    {
        "name": "tree.Discard2#503",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.Discard2(TreeDataType *ptd)",
        "snippet": "static void Discard2(TreeDataType *ptd)\n{\n    int i, j;\n    char overwrite[MAX_PHONE_SEQ_LEN];\n    char failflag[INTERVAL_SIZE];\n    int nInterval2;\n\n    memset(failflag, 0, sizeof(failflag));\n    for (i = 0; i < ptd->nInterval; i++) {\n        if (ptd->leftmost[ptd->interval[i].from] == 0)\n            continue;\n        /* test if interval i is overwrited by other intervals */\n        memset(overwrite, 0, sizeof(overwrite));\n        for (j = 0; j < ptd->nInterval; j++) {\n            if (j == i)\n                continue;\n            memset(&overwrite[ptd->interval[j].from], 1, ptd->interval[j].to - ptd->interval[j].from);\n        }\n        if (memchr(&overwrite[ptd->interval[i].from], 1, ptd->interval[i].to - ptd->interval[i].from))\n            failflag[i] = 1;\n    }\n    /* discard all the intervals whose failflag[a] = 1 */\n    nInterval2 = 0;\n    for (i = 0; i < ptd->nInterval; i++)\n        if (!failflag[i])\n            ptd->interval[nInterval2++] = ptd->interval[i];\n        else if (ptd->interval[i].p_phr != NULL)\n            free(ptd->interval[i].p_phr);\n    ptd->nInterval = nInterval2;\n}",
        "begin_line": 503,
        "end_line": 532,
        "is_bug": false
    },
    {
        "name": "tree.DoDpPhrasing#941",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.DoDpPhrasing(ChewingData *pgdata, TreeDataType *pdt)",
        "snippet": "static void DoDpPhrasing(ChewingData *pgdata, TreeDataType *pdt)\n{\n    RecordNode *highest_score[MAX_PHONE_SEQ_LEN] = { 0 };\n    RecordNode *tmp;\n    int prev_end;\n    int end;\n    int interval_id;\n\n    assert(pgdata);\n    assert(pdt);\n\n    /*\n     * Assume P(x,y) is the highest score phrasing result from x to y. The\n     * following is formula for P(x,y):\n     *\n     * P(x,y) = MAX( P(x,y-1)+P(y-1,y), P(x,y-2)+P(y-2,y), ... )\n     *\n     * While P(x,y-1) is stored in highest_score array, and P(y-1,y) is\n     * interval end at y. In this formula, x is always 0.\n     *\n     * The format of highest_score array is described as following:\n     *\n     * highest_score[0] = P(0,0)\n     * highest_score[1] = P(0,1)\n     * ...\n     * highest_score[y-1] = P(0,y-1)\n     */\n\n    /* The interval shall be sorted by the increase order of end. */\n    qsort(pdt->interval, pdt->nInterval, sizeof(pdt->interval[0]), SortByIncreaseEnd);\n\n    for (interval_id = 0; interval_id < pdt->nInterval; ++interval_id) {\n        /*\n         * XXX: pdt->interval.to is excluding, while end is\n         * including, so we need to minus one here.\n         */\n        end = pdt->interval[interval_id].to - 1;\n\n        prev_end = pdt->interval[interval_id].from - 1;\n\n        if (prev_end >= 0)\n            tmp = DuplicateRecordAndInsertInterval(highest_score[prev_end], pdt, interval_id);\n        else\n            tmp = CreateSingleIntervalRecord(pdt, interval_id);\n\n        /* FIXME: shall exit immediately? */\n        if (!tmp)\n            continue;\n\n        if (highest_score[end] == NULL || highest_score[end]->score < tmp->score) {\n            FreeRecord(highest_score[end]);\n            highest_score[end] = tmp;\n        } else\n            FreeRecord(tmp);\n    }\n\n    if (pgdata->nPhoneSeq - 1 < 0 || highest_score[pgdata->nPhoneSeq - 1] == NULL) {\n        pdt->phList = CreateNullIntervalRecord();\n    } else {\n        pdt->phList = highest_score[pgdata->nPhoneSeq - 1];\n    }\n    pdt->nPhListLen = 1;\n\n    for (end = 0; end < pgdata->nPhoneSeq - 1; ++end)\n        FreeRecord(highest_score[end]);\n}",
        "begin_line": 941,
        "end_line": 1006,
        "is_bug": false
    },
    {
        "name": "tree.DuplicateRecordAndInsertInterval#860",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.DuplicateRecordAndInsertInterval(const RecordNode *record, TreeDataType *pdt, const int interval_id)",
        "snippet": "static RecordNode *DuplicateRecordAndInsertInterval(const RecordNode *record, TreeDataType *pdt, const int interval_id)\n{\n    RecordNode *ret = NULL;\n\n    assert(record);\n    assert(pdt);\n\n    ret = ALC(RecordNode, 1);\n\n    if (!ret)\n        return NULL;\n\n    assert(record->nInter + 1);\n    ret->arrIndex = ALC(int, record->nInter + 1);\n    if (!ret->arrIndex) {\n        free(ret);\n        return NULL;\n    }\n    ret->nInter = record->nInter + 1;\n    memcpy(ret->arrIndex, record->arrIndex, sizeof(record->arrIndex[0]) * record->nInter);\n\n    ret->arrIndex[ret->nInter - 1] = interval_id;\n\n    ret->score = LoadPhraseAndCountScore(ret->arrIndex, ret->nInter, pdt);\n\n    return ret;\n}",
        "begin_line": 860,
        "end_line": 886,
        "is_bug": false
    },
    {
        "name": "tree.FillPreeditBuf#534",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.FillPreeditBuf(ChewingData *pgdata, char *phrase, int from, int to)",
        "snippet": "static void FillPreeditBuf(ChewingData *pgdata, char *phrase, int from, int to)\n{\n    int i;\n    int start = 0;\n\n    assert(pgdata);\n    assert(phrase);\n    assert(from < to);\n\n    start = toPreeditBufIndex(pgdata, from);\n\n    LOG_VERBOSE(\"Fill preeditBuf start %d, from = %d, to = %d\", start, from, to);\n\n    for (i = start; i < start - from + to; ++i) {\n        ueStrNCpy(pgdata->preeditBuf[i].char_, ueStrSeek(phrase, i - start), 1, STRNCPY_CLOSE);\n    }\n}",
        "begin_line": 534,
        "end_line": 550,
        "is_bug": false
    },
    {
        "name": "tree.FindInterval#322",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.FindInterval(ChewingData *pgdata, TreeDataType *ptd)",
        "snippet": "static void FindInterval(ChewingData *pgdata, TreeDataType *ptd)\n{\n    int end, begin;\n    const TreeType *phrase_parent;\n    Phrase *p_phrase, *puserphrase, *pdictphrase;\n    UsedPhraseMode i_used_phrase;\n    uint16_t new_phoneSeq[MAX_PHONE_SEQ_LEN];\n    UserPhraseData *userphrase;\n\n    for (begin = 0; begin < pgdata->nPhoneSeq; begin++) {\n        for (end = begin; end < min(pgdata->nPhoneSeq, begin + MAX_PHRASE_LEN); end++) {\n            if (!CheckBreakpoint(begin, end + 1, pgdata->bArrBrkpt))\n                break;\n\n            /* set new_phoneSeq */\n            memcpy(new_phoneSeq, &pgdata->phoneSeq[begin], sizeof(uint16_t) * (end - begin + 1));\n            new_phoneSeq[end - begin + 1] = 0;\n            puserphrase = pdictphrase = NULL;\n            i_used_phrase = USED_PHRASE_NONE;\n\n            userphrase = UserGetPhraseFirst(pgdata, new_phoneSeq);\n            UserGetPhraseEnd(pgdata, new_phoneSeq);\n\n            if (userphrase && CheckUserChoose(pgdata, new_phoneSeq, begin, end + 1,\n                                              &p_phrase, pgdata->selectStr, pgdata->selectInterval, pgdata->nSelect)) {\n                puserphrase = p_phrase;\n            }\n\n            /* check dict phrase */\n            phrase_parent = TreeFindPhrase(pgdata, begin, end, pgdata->phoneSeq);\n            if (phrase_parent &&\n                CheckChoose(pgdata,\n                            phrase_parent, begin, end + 1,\n                            &p_phrase, pgdata->selectStr, pgdata->selectInterval, pgdata->nSelect)) {\n                pdictphrase = p_phrase;\n            }\n\n            /* add only one interval, which has the largest freqency\n             * but when the phrase is the same, the user phrase overrides\n             * static dict\n             */\n            if (puserphrase != NULL && pdictphrase == NULL) {\n                i_used_phrase = USED_PHRASE_USER;\n            } else if (puserphrase == NULL && pdictphrase != NULL) {\n                i_used_phrase = USED_PHRASE_DICT;\n            } else if (puserphrase != NULL && pdictphrase != NULL) {\n                /* the same phrase, userphrase overrides */\n                if (!strcmp(puserphrase->phrase, pdictphrase->phrase)) {\n                    i_used_phrase = USED_PHRASE_USER;\n                } else {\n                    if (puserphrase->freq > pdictphrase->freq) {\n                        i_used_phrase = USED_PHRASE_USER;\n                    } else {\n                        i_used_phrase = USED_PHRASE_DICT;\n                    }\n                }\n            }\n            switch (i_used_phrase) {\n            case USED_PHRASE_USER:\n                AddInterval(ptd, begin, end, puserphrase, IS_USER_PHRASE);\n                break;\n            case USED_PHRASE_DICT:\n                AddInterval(ptd, begin, end, pdictphrase, IS_DICT_PHRASE);\n                break;\n            case USED_PHRASE_NONE:\n            default:\n                break;\n            }\n            internal_release_Phrase(i_used_phrase, puserphrase, pdictphrase);\n        }\n    }\n}",
        "begin_line": 322,
        "end_line": 393,
        "is_bug": false
    },
    {
        "name": "tree.FreeRecord#933",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.FreeRecord(RecordNode *node)",
        "snippet": "static void FreeRecord(RecordNode *node)\n{\n    if (node) {\n        free(node->arrIndex);\n        free(node);\n    }\n}",
        "begin_line": 933,
        "end_line": 939,
        "is_bug": false
    },
    {
        "name": "tree.InitPhrasing#742",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.InitPhrasing(TreeDataType *ptd)",
        "snippet": "static void InitPhrasing(TreeDataType *ptd)\n{\n    memset(ptd, 0, sizeof(TreeDataType));\n}",
        "begin_line": 742,
        "end_line": 745,
        "is_bug": false
    },
    {
        "name": "tree.InitTree#86",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.InitTree(ChewingData *pgdata, const char *prefix)",
        "snippet": "int InitTree(ChewingData *pgdata, const char *prefix)\n{\n    char filename[PATH_MAX];\n    size_t len;\n    size_t offset;\n\n    len = snprintf(filename, sizeof(filename), \"%s\" PLAT_SEPARATOR \"%s\", prefix, PHONE_TREE_FILE);\n    if (len + 1 > sizeof(filename))\n        return -1;\n\n    plat_mmap_set_invalid(&pgdata->static_data.tree_mmap);\n    pgdata->static_data.tree_size = plat_mmap_create(&pgdata->static_data.tree_mmap, filename, FLAG_ATTRIBUTE_READ);\n    if (pgdata->static_data.tree_size <= 0)\n        return -1;\n\n    offset = 0;\n    pgdata->static_data.tree =\n        (const TreeType *) plat_mmap_set_view(&pgdata->static_data.tree_mmap, &offset, &pgdata->static_data.tree_size);\n    if (!pgdata->static_data.tree)\n        return -1;\n\n    return 0;\n}",
        "begin_line": 86,
        "end_line": 108,
        "is_bug": false
    },
    {
        "name": "tree.IsContain#59",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.IsContain(IntervalType in1, IntervalType in2)",
        "snippet": "static int IsContain(IntervalType in1, IntervalType in2)\n{\n    return (in1.from <= in2.from && in1.to >= in2.to);\n}",
        "begin_line": 59,
        "end_line": 62,
        "is_bug": false
    },
    {
        "name": "tree.IsIntersect#64",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.IsIntersect(IntervalType in1, IntervalType in2)",
        "snippet": "int IsIntersect(IntervalType in1, IntervalType in2)\n{\n    return (max(in1.from, in2.from) < min(in1.to, in2.to));\n}",
        "begin_line": 64,
        "end_line": 67,
        "is_bug": false
    },
    {
        "name": "tree.LoadPhraseAndCountScore#619",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.LoadPhraseAndCountScore(const int *record, int nRecord, const TreeDataType *ptd)",
        "snippet": "static int LoadPhraseAndCountScore(const int *record, int nRecord, const TreeDataType *ptd)\n{\n    int total_score = 0;\n\n    /* NOTE: the balance factor is tuneable */\n    if (nRecord) {\n        total_score += 1000 * rule_largest_sum(record, nRecord, ptd);\n        total_score += 1000 * rule_largest_avgwordlen(record, nRecord, ptd);\n        total_score += 100 * rule_smallest_lenvariance(record, nRecord, ptd);\n        total_score += rule_largest_freqsum(record, nRecord, ptd);\n    }\n    return total_score;\n}",
        "begin_line": 619,
        "end_line": 631,
        "is_bug": false
    },
    {
        "name": "tree.NextCut#815",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.NextCut(TreeDataType *tdt, PhrasingOutput *ppo)",
        "snippet": "static RecordNode *NextCut(TreeDataType *tdt, PhrasingOutput *ppo)\n{\n    /* pop nNumCut-th candidate to first */\n    int i;\n    RecordNode *former;\n    RecordNode *want;\n\n    if (ppo->nNumCut >= tdt->nPhListLen)\n        ppo->nNumCut = 0;\n    if (ppo->nNumCut == 0)\n        return tdt->phList;\n\n    /* find the former of our candidate */\n    former = tdt->phList;\n    for (i = 0; i < ppo->nNumCut - 1; i++) {\n        former = former->next;\n        assert(former);\n    }\n\n    /* take the candidate out of the listed list */\n    want = former->next;\n    assert(want);\n    former->next = former->next->next;\n\n    /* prepend to front of list */\n    want->next = tdt->phList;\n    tdt->phList = want;\n\n    return tdt->phList;\n}",
        "begin_line": 815,
        "end_line": 844,
        "is_bug": false
    },
    {
        "name": "tree.OutputRecordStr#553",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.OutputRecordStr(ChewingData *pgdata, const TreeDataType *ptd)",
        "snippet": "static void OutputRecordStr(ChewingData *pgdata, const TreeDataType *ptd)\n{\n    PhraseIntervalType inter;\n    int i;\n\n    for (i = 0; i < ptd->phList->nInter; i++) {\n        inter = ptd->interval[ptd->phList->arrIndex[i]];\n        FillPreeditBuf(pgdata, inter.p_phr->phrase, inter.from, inter.to);\n    }\n\n    for (i = 0; i < pgdata->nSelect; i++) {\n        FillPreeditBuf(pgdata, pgdata->selectStr[i], pgdata->selectInterval[i].from, pgdata->selectInterval[i].to);\n    }\n}",
        "begin_line": 553,
        "end_line": 566,
        "is_bug": false
    },
    {
        "name": "tree.PhraseIntervalContain#69",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.PhraseIntervalContain(PhraseIntervalType in1, PhraseIntervalType in2)",
        "snippet": "static int PhraseIntervalContain(PhraseIntervalType in1, PhraseIntervalType in2)\n{\n    return (in1.from <= in2.from && in1.to >= in2.to);\n}",
        "begin_line": 69,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "tree.Phrasing#1008",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.Phrasing(ChewingData *pgdata, int all_phrasing)",
        "snippet": "int Phrasing(ChewingData *pgdata, int all_phrasing)\n{\n    TreeDataType treeData;\n\n    InitPhrasing(&treeData);\n\n    FindInterval(pgdata, &treeData);\n    SetInfo(pgdata->nPhoneSeq, &treeData);\n    Discard1(&treeData);\n    Discard2(&treeData);\n    if (all_phrasing) {\n        SaveList(&treeData);\n        CountMatchCnnct(&treeData, pgdata->bUserArrCnnct, pgdata->nPhoneSeq);\n        SortListByScore(&treeData);\n        NextCut(&treeData, &pgdata->phrOut);\n    } else {\n        DoDpPhrasing(pgdata, &treeData);\n    }\n\n    ShowList(pgdata, &treeData);\n\n    /* set phrasing output */\n    OutputRecordStr(pgdata, &treeData);\n    SaveDispInterval(&pgdata->phrOut, &treeData);\n\n    /* free \"phrase\" */\n    CleanUpMem(&treeData);\n    return 0;\n}",
        "begin_line": 1008,
        "end_line": 1036,
        "is_bug": false
    },
    {
        "name": "tree.RecursiveSave#715",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.RecursiveSave(int depth, int to, int *record, TreeDataType *ptd)",
        "snippet": "static void RecursiveSave(int depth, int to, int *record, TreeDataType *ptd)\n{\n    int first, i;\n\n    /* to find first interval */\n    for (first = record[depth - 1] + 1; ptd->interval[first].from < to && first < ptd->nInterval; first++);\n\n    if (first == ptd->nInterval) {\n        SaveRecord(record + 1, depth - 1, ptd);\n        return;\n    }\n    record[depth] = first;\n    RecursiveSave(depth + 1, ptd->interval[first].to, record, ptd);\n    /* for each interval which intersects first */\n    for (i = first + 1; PhraseIntervalIntersect(ptd->interval[first], ptd->interval[i]) && i < ptd->nInterval; i++) {\n        record[depth] = i;\n        RecursiveSave(depth + 1, ptd->interval[i].to, record, ptd);\n    }\n}",
        "begin_line": 715,
        "end_line": 733,
        "is_bug": false
    },
    {
        "name": "tree.SaveDispInterval#747",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.SaveDispInterval(PhrasingOutput *ppo, TreeDataType *ptd)",
        "snippet": "static void SaveDispInterval(PhrasingOutput *ppo, TreeDataType *ptd)\n{\n    int i;\n\n    for (i = 0; i < ptd->phList->nInter; i++) {\n        ppo->dispInterval[i].from = ptd->interval[ptd->phList->arrIndex[i]].from;\n        ppo->dispInterval[i].to = ptd->interval[ptd->phList->arrIndex[i]].to;\n    }\n    ppo->nDispInterval = ptd->phList->nInter;\n}",
        "begin_line": 747,
        "end_line": 756,
        "is_bug": false
    },
    {
        "name": "tree.SaveList#735",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.SaveList(TreeDataType *ptd)",
        "snippet": "static void SaveList(TreeDataType *ptd)\n{\n    int record[MAX_PHONE_SEQ_LEN + 1] = { -1 };\n\n    RecursiveSave(1, 0, record, ptd);\n}",
        "begin_line": 735,
        "end_line": 740,
        "is_bug": false
    },
    {
        "name": "tree.SaveRecord#678",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.SaveRecord(const int *record, int nInter, TreeDataType *ptd)",
        "snippet": "static void SaveRecord(const int *record, int nInter, TreeDataType *ptd)\n{\n    RecordNode *now, *p, *pre;\n\n    pre = NULL;\n    for (p = ptd->phList; p;) {\n        /* if  'p' contains 'record', then discard 'record'. */\n        if (IsRecContain(p->arrIndex, p->nInter, record, nInter, ptd))\n            return;\n\n        /* if 'record' contains 'p', then discard 'p'\n         * -- We must deal with the linked list. */\n        if (IsRecContain(record, nInter, p->arrIndex, p->nInter, ptd)) {\n            RecordNode *tp = p;\n\n            if (pre)\n                pre->next = p->next;\n            else\n                ptd->phList = ptd->phList->next;\n            p = p->next;\n            free(tp->arrIndex);\n            free(tp);\n        } else\n            pre = p, p = p->next;\n    }\n    now = ALC(RecordNode, 1);\n\n    assert(now);\n    now->next = ptd->phList;\n    now->arrIndex = ALC(int, nInter);\n\n    assert(now->arrIndex);\n    now->nInter = nInter;\n    memcpy(now->arrIndex, record, nInter * sizeof(int));\n    ptd->phList = now;\n}",
        "begin_line": 678,
        "end_line": 713,
        "is_bug": false
    },
    {
        "name": "tree.SetInfo#395",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.SetInfo(int len, TreeDataType *ptd)",
        "snippet": "static void SetInfo(int len, TreeDataType *ptd)\n{\n    int i, a;\n\n    for (i = 0; i <= len; i++)\n        ptd->leftmost[i] = i;\n    for (i = 0; i < ptd->nInterval; i++) {\n        ptd->graph[ptd->interval[i].from][ptd->interval[i].to] = 1;\n        ptd->graph[ptd->interval[i].to][ptd->interval[i].from] = 1;\n    }\n\n    /* set leftmost */\n    for (a = 0; a <= len; a++) {\n        for (i = 0; i <= len; i++) {\n            if (!(ptd->graph[a][i]))\n                continue;\n            if (ptd->leftmost[i] < ptd->leftmost[a])\n                ptd->leftmost[a] = ptd->leftmost[i];\n        }\n    }\n}",
        "begin_line": 395,
        "end_line": 415,
        "is_bug": false
    },
    {
        "name": "tree.ShowList#799",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.ShowList(ChewingData *pgdata, const TreeDataType *ptd)",
        "snippet": "static void ShowList(ChewingData *pgdata, const TreeDataType *ptd)\n{\n    const RecordNode *p;\n    int i;\n\n    DEBUG_OUT(\"After SaveList :\\n\");\n    for (p = ptd->phList; p; p = p->next) {\n        DEBUG_OUT(\"  interval : \");\n        for (i = 0; i < p->nInter; i++) {\n            DEBUG_OUT(\"[%d %d] \", ptd->interval[p->arrIndex[i]].from, ptd->interval[p->arrIndex[i]].to);\n        }\n        DEBUG_OUT(\"\\n\" \"      score : %d , nMatchCnnct : %d\\n\", p->score, p->nMatchCnnct);\n    }\n    DEBUG_OUT(\"\\n\");\n}",
        "begin_line": 799,
        "end_line": 813,
        "is_bug": false
    },
    {
        "name": "tree.SortByIncreaseEnd#846",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.SortByIncreaseEnd(const void *x, const void *y)",
        "snippet": "static int SortByIncreaseEnd(const void *x, const void *y)\n{\n    const PhraseIntervalType *interval_x = (const PhraseIntervalType *) x;\n    const PhraseIntervalType *interval_y = (const PhraseIntervalType *) y;\n\n    if (interval_x->to < interval_y->to)\n        return -1;\n\n    if (interval_x->to > interval_y->to)\n        return 1;\n\n    return 0;\n}",
        "begin_line": 846,
        "end_line": 858,
        "is_bug": false
    },
    {
        "name": "tree.SortListByScore#649",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.SortListByScore(TreeDataType *ptd)",
        "snippet": "static void SortListByScore(TreeDataType *ptd)\n{\n    int i, listLen;\n    RecordNode *p, **arr;\n\n    for (listLen = 0, p = ptd->phList; p; listLen++, p = p->next);\n    ptd->nPhListLen = listLen;\n\n    assert(listLen);\n    arr = ALC(RecordNode *, listLen);\n    assert(arr);\n\n    for (i = 0, p = ptd->phList; i < listLen; p = p->next, i++) {\n        arr[i] = p;\n        p->score = LoadPhraseAndCountScore(p->arrIndex, p->nInter, ptd);\n    }\n\n    qsort(arr, listLen, sizeof(RecordNode *), (CompFuncType) CompRecord);\n\n    ptd->phList = arr[0];\n    for (i = 1; i < listLen; i++) {\n        arr[i - 1]->next = arr[i];\n    }\n    arr[listLen - 1]->next = NULL;\n\n    free(arr);\n}",
        "begin_line": 649,
        "end_line": 675,
        "is_bug": false
    },
    {
        "name": "tree.TerminateTree#79",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.TerminateTree(ChewingData *pgdata)",
        "snippet": "void TerminateTree(ChewingData *pgdata)\n{\n    pgdata->static_data.tree = NULL;\n    plat_mmap_close(&pgdata->static_data.tree_mmap);\n}",
        "begin_line": 79,
        "end_line": 83,
        "is_bug": false
    },
    {
        "name": "tree.TreeChildRange#279",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.TreeChildRange(ChewingData *pgdata, const TreeType *parent)",
        "snippet": "void TreeChildRange(ChewingData *pgdata, const TreeType *parent)\n{\n    pgdata->static_data.tree_cur_pos = pgdata->static_data.tree + GetUint24(parent->child.begin);\n    pgdata->static_data.tree_end_pos = pgdata->static_data.tree + GetUint24(parent->child.end);\n}",
        "begin_line": 279,
        "end_line": 283,
        "is_bug": false
    },
    {
        "name": "tree.TreeFindPhrase#250",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.TreeFindPhrase(ChewingData *pgdata, int begin, int end, const uint16_t *phoneSeq)",
        "snippet": "const TreeType *TreeFindPhrase(ChewingData *pgdata, int begin, int end, const uint16_t *phoneSeq)\n{\n    TreeType target;\n    const TreeType *tree_p = pgdata->static_data.tree;\n    uint32_t range[2];\n    int i;\n\n    for (i = begin; i <= end; i++) {\n        PutUint16(phoneSeq[i], target.key);\n        range[0] = GetUint24(tree_p->child.begin);\n        range[1] = GetUint24(tree_p->child.end);\n        assert(range[1] >= range[0]);\n        tree_p = (const TreeType *) bsearch(&target, pgdata->static_data.tree + range[0],\n                                            range[1] - range[0], sizeof(TreeType), CompTreeType);\n\n        /* if not found any word then fail. */\n        if (!tree_p)\n            return NULL;\n    }\n\n    /* If its child has no key value of 0, then it is only a \"half\" phrase. */\n    if (GetUint16(pgdata->static_data.tree[GetUint24(tree_p->child.begin)].key) != 0)\n        return NULL;\n    return tree_p;\n}",
        "begin_line": 250,
        "end_line": 274,
        "is_bug": false
    },
    {
        "name": "tree.internal_release_Phrase#301",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.internal_release_Phrase(UsedPhraseMode mode, Phrase *pUser, Phrase *pDict)",
        "snippet": "static void internal_release_Phrase(UsedPhraseMode mode, Phrase *pUser, Phrase *pDict)\n{\n    /* we must free unused phrase entry to avoid memory leak. */\n    switch (mode) {\n    case USED_PHRASE_USER:\n        if (pDict != NULL)\n            free(pDict);\n        break;\n    case USED_PHRASE_DICT:\n        if (pUser != NULL)\n            free(pUser);\n        break;\n    default:                   /* In fact, it is always 0 */\n        if (pDict != NULL)\n            free(pDict);\n        if (pUser != NULL)\n            free(pUser);\n        break;\n    }\n}",
        "begin_line": 301,
        "end_line": 320,
        "is_bug": false
    },
    {
        "name": "tree.rule_largest_avgwordlen#581",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.rule_largest_avgwordlen(const int *record, int nRecord, const TreeDataType *ptd)",
        "snippet": "static int rule_largest_avgwordlen(const int *record, int nRecord, const TreeDataType *ptd)\n{\n    /* constant factor 6=1*2*3, to keep value as integer */\n    return 6 * rule_largest_sum(record, nRecord, ptd) / nRecord;\n}",
        "begin_line": 581,
        "end_line": 585,
        "is_bug": false
    },
    {
        "name": "tree.rule_largest_freqsum#604",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.rule_largest_freqsum(const int *record, int nRecord, const TreeDataType *ptd)",
        "snippet": "static int rule_largest_freqsum(const int *record, int nRecord, const TreeDataType *ptd)\n{\n    int i, score = 0;\n    PhraseIntervalType inter;\n\n    for (i = 0; i < nRecord; i++) {\n        inter = ptd->interval[record[i]];\n        assert(inter.p_phr);\n\n        /* We adjust the 'freq' of One-word Phrase */\n        score += (inter.to - inter.from == 1) ? (inter.p_phr->freq / 512) : inter.p_phr->freq;\n    }\n    return score;\n}",
        "begin_line": 604,
        "end_line": 617,
        "is_bug": false
    },
    {
        "name": "tree.rule_largest_sum#568",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.rule_largest_sum(const int *record, int nRecord, const TreeDataType *ptd)",
        "snippet": "static int rule_largest_sum(const int *record, int nRecord, const TreeDataType *ptd)\n{\n    int i, score = 0;\n    PhraseIntervalType inter;\n\n    for (i = 0; i < nRecord; i++) {\n        inter = ptd->interval[record[i]];\n        assert(inter.p_phr);\n        score += inter.to - inter.from;\n    }\n    return score;\n}",
        "begin_line": 568,
        "end_line": 579,
        "is_bug": false
    },
    {
        "name": "tree.rule_smallest_lenvariance#587",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.rule_smallest_lenvariance(const int *record, int nRecord, const TreeDataType *ptd)",
        "snippet": "static int rule_smallest_lenvariance(const int *record, int nRecord, const TreeDataType *ptd)\n{\n    int i, j, score = 0;\n    PhraseIntervalType inter1, inter2;\n\n    /* kcwu: heuristic? why variance no square function? */\n    for (i = 0; i < nRecord; i++) {\n        for (j = i + 1; j < nRecord; j++) {\n            inter1 = ptd->interval[record[i]];\n            inter2 = ptd->interval[record[j]];\n            assert(inter1.p_phr && inter2.p_phr);\n            score += abs((inter1.to - inter1.from) - (inter2.to - inter2.from));\n        }\n    }\n    return -score;\n}",
        "begin_line": 587,
        "end_line": 602,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.GetCurrentLifeTime#159",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.GetCurrentLifeTime(ChewingData *pgdata)",
        "snippet": "static int GetCurrentLifeTime(ChewingData *pgdata)\n{\n    return pgdata->static_data.new_lifetime;\n}",
        "begin_line": 159,
        "end_line": 162,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.IncreaseLifeTime#449",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.IncreaseLifeTime(ChewingData *pgdata)",
        "snippet": "void IncreaseLifeTime(ChewingData *pgdata)\n{\n    ++pgdata->static_data.new_lifetime;\n}",
        "begin_line": 449,
        "end_line": 452,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.LoadMaxFreq#87",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.LoadMaxFreq(ChewingData *pgdata, const uint16_t phoneSeq[], int len)",
        "snippet": "static int LoadMaxFreq(ChewingData *pgdata, const uint16_t phoneSeq[], int len)\n{\n    const TreeType *tree_pos;\n    Phrase *phrase = ALC(Phrase, 1);\n    int maxFreq = FREQ_INIT_VALUE;\n    int max_userphrase_freq;\n    int ret;\n\n    tree_pos = TreeFindPhrase(pgdata, 0, len - 1, phoneSeq);\n    if (tree_pos) {\n        GetPhraseFirst(pgdata, phrase, tree_pos);\n        do {\n            if (phrase->freq > maxFreq)\n                maxFreq = phrase->freq;\n        } while (GetVocabNext(pgdata, phrase));\n    }\n    free(phrase);\n\n    assert(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_GET_MAX_FREQ]);\n\n    ret = UserBindPhone(pgdata, STMT_USERPHRASE_GET_MAX_FREQ, phoneSeq, len);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"UserBindPhone returns %d\", ret);\n        return maxFreq;\n    }\n\n    ret = sqlite3_step(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_GET_MAX_FREQ]);\n    if (ret != SQLITE_ROW)\n        return maxFreq;\n\n    ret = sqlite3_reset(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_GET_MAX_FREQ]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n        return maxFreq;\n    }\n\n    max_userphrase_freq = sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_GET_MAX_FREQ],\n                                             SQL_STMT_USERPHRASE[STMT_USERPHRASE_GET_MAX_FREQ].column\n                                             [COLUMN_USERPHRASE_USER_FREQ]);\n\n    if (max_userphrase_freq > maxFreq)\n        maxFreq = max_userphrase_freq;\n\n    return maxFreq;\n}",
        "begin_line": 87,
        "end_line": 131,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.LoadOriginalFreq#63",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.LoadOriginalFreq(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int len)",
        "snippet": "static int LoadOriginalFreq(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int len)\n{\n    const TreeType *tree_pos;\n    int retval;\n    Phrase *phrase = ALC(Phrase, 1);\n\n    tree_pos = TreeFindPhrase(pgdata, 0, len - 1, phoneSeq);\n    if (tree_pos) {\n        GetPhraseFirst(pgdata, phrase, tree_pos);\n        do {\n            /* find the same phrase */\n            if (!strcmp(phrase->phrase, wordSeq)) {\n                retval = phrase->freq;\n                free(phrase);\n                return retval;\n            }\n        } while (GetVocabNext(pgdata, phrase));\n    }\n\n    free(phrase);\n    return FREQ_INIT_VALUE;\n}",
        "begin_line": 63,
        "end_line": 84,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.LogUserPhrase#164",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.LogUserPhrase(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int orig_freq, int max_freq, int user_freq, int recent_time)",
        "snippet": "static void LogUserPhrase(ChewingData *pgdata,\n                          const uint16_t phoneSeq[],\n                          const char wordSeq[], int orig_freq, int max_freq, int user_freq, int recent_time)\n{\n    /* Size of each phone is len(\"0x1234 \") = 7 */\n    char buf[7 * MAX_PHRASE_LEN + 1] = { 0 };\n    int i;\n\n    for (i = 0; i < MAX_PHRASE_LEN; ++i) {\n        if (phoneSeq[i] == 0)\n            break;\n        snprintf(buf + 7 * i, 7 + 1, \"%#06x \", phoneSeq[i]);\n    }\n\n    LOG_INFO(\"userphrase %s, phone = %s, orig_freq = %d, max_freq = %d, user_freq = %d, recent_time = %d\",\n             wordSeq, buf, orig_freq, max_freq, user_freq, recent_time);\n}",
        "begin_line": 164,
        "end_line": 180,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UserBindPhone#23",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UserBindPhone(ChewingData *pgdata, int index, const uint16_t phoneSeq[], int len)",
        "snippet": "static int UserBindPhone(ChewingData *pgdata, int index, const uint16_t phoneSeq[], int len)\n{\n    int i;\n    int ret;\n\n    assert(pgdata);\n    assert(phoneSeq);\n\n    if (len > MAX_PHRASE_LEN) {\n        LOG_WARN(\"phoneSeq length %d > MAX_PHRASE_LEN(%d)\", len, MAX_PHRASE_LEN);\n        return -1;\n    }\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_userphrase[index], BIND_USERPHRASE_LENGTH, len);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n        return ret;\n    }\n\n    for (i = 0; i < len; ++i) {\n        ret = sqlite3_bind_int(pgdata->static_data.stmt_userphrase[index], BIND_USERPHRASE_PHONE_0 + i, phoneSeq[i]);\n        if (ret != SQLITE_OK) {\n            LOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n            return ret;\n        }\n    }\n\n    for (i = len; i < MAX_PHRASE_LEN; ++i) {\n        ret = sqlite3_bind_int(pgdata->static_data.stmt_userphrase[index], BIND_USERPHRASE_PHONE_0 + i, 0);\n        if (ret != SQLITE_OK) {\n            LOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n            return ret;\n        }\n    }\n\n    return SQLITE_OK;\n}",
        "begin_line": 23,
        "end_line": 59,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UserGetPhraseEnd#444",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UserGetPhraseEnd(ChewingData *pgdata UNUSED, const uint16_t phoneSeq[] UNUSED)",
        "snippet": "void UserGetPhraseEnd(ChewingData *pgdata UNUSED, const uint16_t phoneSeq[] UNUSED)\n{\n    /* FIXME: Remove this */\n}",
        "begin_line": 444,
        "end_line": 447,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UserGetPhraseFirst#382",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UserGetPhraseFirst(ChewingData *pgdata, const uint16_t phoneSeq[])",
        "snippet": "UserPhraseData *UserGetPhraseFirst(ChewingData *pgdata, const uint16_t phoneSeq[])\n{\n    int ret;\n    int len;\n\n    assert(pgdata);\n    assert(phoneSeq);\n\n    assert(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE]);\n    ret = sqlite3_reset(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n        return NULL;\n    }\n\n    len = GetPhoneLen(phoneSeq);\n    ret = UserBindPhone(pgdata, STMT_USERPHRASE_SELECT_BY_PHONE, phoneSeq, len);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"UserBindPhone returns %d\", ret);\n        return NULL;\n    }\n\n    return UserGetPhraseNext(pgdata, phoneSeq);\n}",
        "begin_line": 382,
        "end_line": 405,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UserGetPhraseNext#407",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UserGetPhraseNext(ChewingData *pgdata, const uint16_t phoneSeq[])",
        "snippet": "UserPhraseData *UserGetPhraseNext(ChewingData *pgdata, const uint16_t phoneSeq[])\n{\n    int ret;\n\n    assert(pgdata);\n    assert(phoneSeq);\n\n    ret = sqlite3_step(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE]);\n    if (ret != SQLITE_ROW)\n        return NULL;\n\n    /* FIXME: shall not remove const here. */\n    pgdata->userphrase_data.wordSeq =\n        (char *) sqlite3_column_text(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE],\n                                     SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE].column\n                                     [COLUMN_USERPHRASE_PHRASE]);\n    pgdata->userphrase_data.phoneSeq = (uint16_t *) phoneSeq;\n\n    pgdata->userphrase_data.recentTime =\n        sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE],\n                           SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE].column[COLUMN_USERPHRASE_TIME]);\n\n    pgdata->userphrase_data.userfreq =\n        sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE],\n                           SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE].column[COLUMN_USERPHRASE_USER_FREQ]);\n\n    pgdata->userphrase_data.maxfreq =\n        sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE],\n                           SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE].column[COLUMN_USERPHRASE_MAX_FREQ]);\n\n    pgdata->userphrase_data.origfreq =\n        sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE],\n                           SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE].column[COLUMN_USERPHRASE_ORIG_FREQ]);\n\n    return &pgdata->userphrase_data;\n}",
        "begin_line": 407,
        "end_line": 442,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UserUpdatePhrase#187",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UserUpdatePhrase(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[])",
        "snippet": "int UserUpdatePhrase(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[])\n{\n    int ret;\n    int action;\n    int phone_len;\n    int word_len;\n\n    int orig_freq;\n    int max_freq;\n    int user_freq;\n    int recent_time;\n    int orig_time;\n\n    assert(pgdata);\n    assert(phoneSeq);\n    assert(wordSeq);\n\n    phone_len = GetPhoneLen(phoneSeq);\n    word_len = ueStrLen(wordSeq);\n\n    if (phone_len != word_len) {\n        LOG_WARN(\"Do not update userphrase because phoneSeq length %d != wordSeq length %d\", phone_len, word_len);\n        return USER_UPDATE_FAIL;\n    }\n\n    if (word_len > MAX_PHRASE_LEN) {\n        LOG_WARN(\"wordSeq length %d > MAX_PHRASE_LEN (%d)\", word_len, MAX_PHRASE_LEN);\n        return USER_UPDATE_FAIL;\n    }\n\n    ret = UserBindPhone(pgdata, STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE, phoneSeq, phone_len);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"UserBindPhone returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    ret = sqlite3_bind_text(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE],\n                            BIND_USERPHRASE_PHRASE, wordSeq, -1, SQLITE_STATIC);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_bind_text returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    recent_time = GetCurrentLifeTime(pgdata);\n\n    ret = sqlite3_step(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE]);\n    if (ret == SQLITE_ROW) {\n        action = USER_UPDATE_MODIFY;\n\n        orig_freq = sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE],\n                                       SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE].column\n                                       [COLUMN_USERPHRASE_ORIG_FREQ]);\n\n        max_freq = LoadMaxFreq(pgdata, phoneSeq, phone_len);\n\n        user_freq = sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE],\n                                       SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE].column\n                                       [COLUMN_USERPHRASE_USER_FREQ]);\n\n        orig_time = sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE],\n                                       SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE].column\n                                       [COLUMN_USERPHRASE_TIME]);\n\n        user_freq = UpdateFreq(user_freq, max_freq, orig_freq, recent_time - orig_time);\n    } else {\n        action = USER_UPDATE_INSERT;\n\n        orig_freq = LoadOriginalFreq(pgdata, phoneSeq, wordSeq, word_len);\n        max_freq = LoadMaxFreq(pgdata, phoneSeq, phone_len);\n        user_freq = orig_freq;\n    }\n\n    assert(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT]);\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT],\n                           BIND_USERPHRASE_TIME, recent_time);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT],\n                           BIND_USERPHRASE_USER_FREQ, user_freq);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT],\n                           BIND_USERPHRASE_MAX_FREQ, max_freq);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT],\n                           BIND_USERPHRASE_ORIG_FREQ, orig_freq);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    ret = UserBindPhone(pgdata, STMT_USERPHRASE_UPSERT, phoneSeq, phone_len);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"UserBindPhone returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    ret = sqlite3_bind_text(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT],\n                            BIND_USERPHRASE_PHRASE, wordSeq, -1, SQLITE_STATIC);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_bind_text returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    ret = sqlite3_step(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT]);\n    if (ret != SQLITE_DONE) {\n        LOG_ERROR(\"sqlite3_step returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    LogUserPhrase(pgdata, phoneSeq, wordSeq, orig_freq, max_freq, user_freq, recent_time);\n\n  end:\n    ret = sqlite3_reset(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n    }\n\n    ret = sqlite3_reset(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n    }\n\n    return action;\n}",
        "begin_line": 187,
        "end_line": 331,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UserUpdatePhraseBegin#182",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UserUpdatePhraseBegin(ChewingData *pgdata)",
        "snippet": "void UserUpdatePhraseBegin(ChewingData *pgdata)\n{\n    sqlite3_exec(pgdata->static_data.db, \"BEGIN\", 0, 0, 0);\n}",
        "begin_line": 182,
        "end_line": 185,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UserUpdatePhraseEnd#333",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UserUpdatePhraseEnd(ChewingData *pgdata)",
        "snippet": "void UserUpdatePhraseEnd(ChewingData *pgdata)\n{\n    sqlite3_exec(pgdata->static_data.db, \"END\", 0, 0, 0);\n}",
        "begin_line": 333,
        "end_line": 336,
        "is_bug": false
    },
    {
        "name": "userphrase.GetDefaultChewingUserPath#130",
        "src_path": "src/userphrase.c",
        "class_name": "userphrase",
        "signature": "userphrase.GetDefaultChewingUserPath(ChewingData *pgdata)",
        "snippet": "char *GetDefaultChewingUserPath(ChewingData *pgdata)\n{\n    char *tmp;\n    char *path;\n    int ret;\n\n    assert(pgdata);\n\n    tmp = getenv(\"CHEWING_USER_PATH\");\n    if (tmp) {\n        ret = asprintf(&path, \"%s\", tmp);\n        if (ret == -1) {\n            LOG_ERROR(\"asprintf returns %d\", ret);\n            exit(-1);\n        }\n        return path;\n    }\n\n    tmp = getenv(\"HOME\");\n    if (!tmp) {\n        tmp = PLAT_TMPDIR;\n    }\n\n    ret = asprintf(&path, \"%s/%s\", tmp, USERPHRASE_DIR);\n    if (ret == -1) {\n        LOG_ERROR(\"asprintf returns %d\", ret);\n        exit(-1);\n    }\n\n    PLAT_MKDIR(path);\n\n    return path;\n}",
        "begin_line": 130,
        "end_line": 162,
        "is_bug": false
    },
    {
        "name": "userphrase.GetDefaultUserPhrasePath#164",
        "src_path": "src/userphrase.c",
        "class_name": "userphrase",
        "signature": "userphrase.GetDefaultUserPhrasePath(ChewingData *pgdata)",
        "snippet": "char *GetDefaultUserPhrasePath(ChewingData *pgdata)\n{\n    char *tmp;\n    char *path;\n    int ret;\n\n    assert(pgdata);\n\n    tmp = GetDefaultChewingUserPath(pgdata);\n    if (tmp && access(tmp, W_OK) == 0) {\n        ret = asprintf(&path, \"%s/%s\", tmp, DB_NAME);\n        if (ret == -1) {\n            free(tmp);\n            LOG_ERROR(\"asprintf returns %d\", ret);\n            exit(-1);\n        }\n        free(tmp);\n        return path;\n    }\n    free(tmp);\n\n    return NULL;\n}",
        "begin_line": 164,
        "end_line": 186,
        "is_bug": false
    }
]