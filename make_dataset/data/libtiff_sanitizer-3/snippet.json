[
    {
        "name": "libtiff.tif_aux.TIFFGetFieldDefaulted#309",
        "src_path": "libtiff/tif_aux.c",
        "class_name": "libtiff.tif_aux",
        "signature": "libtiff.tif_aux.TIFFGetFieldDefaulted(TIFF* tif, uint32 tag, ...)",
        "snippet": "int\nTIFFGetFieldDefaulted(TIFF* tif, uint32 tag, ...)\n{\n\tint ok;\n\tva_list ap;\n\n\tva_start(ap, tag);\n\tok =  TIFFVGetFieldDefaulted(tif, tag, ap);\n\tva_end(ap);\n\treturn (ok);\n}",
        "begin_line": 309,
        "end_line": 319,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_aux.TIFFVGetFieldDefaulted#173",
        "src_path": "libtiff/tif_aux.c",
        "class_name": "libtiff.tif_aux",
        "signature": "libtiff.tif_aux.TIFFVGetFieldDefaulted(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "int\nTIFFVGetFieldDefaulted(TIFF* tif, uint32 tag, va_list ap)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\n\tif (TIFFVGetField(tif, tag, ap))\n\t\treturn (1);\n\tswitch (tag) {\n\tcase TIFFTAG_SUBFILETYPE:\n\t\t*va_arg(ap, uint32 *) = td->td_subfiletype;\n\t\treturn (1);\n\tcase TIFFTAG_BITSPERSAMPLE:\n\t\t*va_arg(ap, uint16 *) = td->td_bitspersample;\n\t\treturn (1);\n\tcase TIFFTAG_THRESHHOLDING:\n\t\t*va_arg(ap, uint16 *) = td->td_threshholding;\n\t\treturn (1);\n\tcase TIFFTAG_FILLORDER:\n\t\t*va_arg(ap, uint16 *) = td->td_fillorder;\n\t\treturn (1);\n\tcase TIFFTAG_ORIENTATION:\n\t\t*va_arg(ap, uint16 *) = td->td_orientation;\n\t\treturn (1);\n\tcase TIFFTAG_SAMPLESPERPIXEL:\n\t\t*va_arg(ap, uint16 *) = td->td_samplesperpixel;\n\t\treturn (1);\n\tcase TIFFTAG_ROWSPERSTRIP:\n\t\t*va_arg(ap, uint32 *) = td->td_rowsperstrip;\n\t\treturn (1);\n\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\t*va_arg(ap, uint16 *) = td->td_minsamplevalue;\n\t\treturn (1);\n\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\t*va_arg(ap, uint16 *) = td->td_maxsamplevalue;\n\t\treturn (1);\n\tcase TIFFTAG_PLANARCONFIG:\n\t\t*va_arg(ap, uint16 *) = td->td_planarconfig;\n\t\treturn (1);\n\tcase TIFFTAG_RESOLUTIONUNIT:\n\t\t*va_arg(ap, uint16 *) = td->td_resolutionunit;\n\t\treturn (1);\n\tcase TIFFTAG_PREDICTOR:\n    {\n        TIFFPredictorState* sp = (TIFFPredictorState*) tif->tif_data;\n        if( sp == NULL )\n        {\n            TIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n                         \"Cannot get \\\"Predictor\\\" tag as plugin is not configured\");\n            *va_arg(ap, uint16*) = 0;\n            return 0;\n        }\n        *va_arg(ap, uint16*) = (uint16) sp->predictor;\n        return 1;\n    }\n\tcase TIFFTAG_DOTRANGE:\n\t\t*va_arg(ap, uint16 *) = 0;\n\t\t*va_arg(ap, uint16 *) = (1<<td->td_bitspersample)-1;\n\t\treturn (1);\n\tcase TIFFTAG_INKSET:\n\t\t*va_arg(ap, uint16 *) = INKSET_CMYK;\n\t\treturn 1;\n\tcase TIFFTAG_NUMBEROFINKS:\n\t\t*va_arg(ap, uint16 *) = 4;\n\t\treturn (1);\n\tcase TIFFTAG_EXTRASAMPLES:\n\t\t*va_arg(ap, uint16 *) = td->td_extrasamples;\n\t\t*va_arg(ap, uint16 **) = td->td_sampleinfo;\n\t\treturn (1);\n\tcase TIFFTAG_MATTEING:\n\t\t*va_arg(ap, uint16 *) =\n\t\t    (td->td_extrasamples == 1 &&\n\t\t     td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);\n\t\treturn (1);\n\tcase TIFFTAG_TILEDEPTH:\n\t\t*va_arg(ap, uint32 *) = td->td_tiledepth;\n\t\treturn (1);\n\tcase TIFFTAG_DATATYPE:\n\t\t*va_arg(ap, uint16 *) = td->td_sampleformat-1;\n\t\treturn (1);\n\tcase TIFFTAG_SAMPLEFORMAT:\n\t\t*va_arg(ap, uint16 *) = td->td_sampleformat;\n                return(1);\n\tcase TIFFTAG_IMAGEDEPTH:\n\t\t*va_arg(ap, uint32 *) = td->td_imagedepth;\n\t\treturn (1);\n\tcase TIFFTAG_YCBCRCOEFFICIENTS:\n\t\t{\n\t\t\t/* defaults are from CCIR Recommendation 601-1 */\n\t\t\tstatic float ycbcrcoeffs[] = { 0.299f, 0.587f, 0.114f };\n\t\t\t*va_arg(ap, float **) = ycbcrcoeffs;\n\t\t\treturn 1;\n\t\t}\n\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t*va_arg(ap, uint16 *) = td->td_ycbcrsubsampling[0];\n\t\t*va_arg(ap, uint16 *) = td->td_ycbcrsubsampling[1];\n\t\treturn (1);\n\tcase TIFFTAG_YCBCRPOSITIONING:\n\t\t*va_arg(ap, uint16 *) = td->td_ycbcrpositioning;\n\t\treturn (1);\n\tcase TIFFTAG_WHITEPOINT:\n\t\t{\n\t\t\tstatic float whitepoint[2];\n\n\t\t\t/* TIFF 6.0 specification tells that it is no default\n\t\t\t   value for the WhitePoint, but AdobePhotoshop TIFF\n\t\t\t   Technical Note tells that it should be CIE D50. */\n\t\t\twhitepoint[0] =\tD50_X0 / (D50_X0 + D50_Y0 + D50_Z0);\n\t\t\twhitepoint[1] =\tD50_Y0 / (D50_X0 + D50_Y0 + D50_Z0);\n\t\t\t*va_arg(ap, float **) = whitepoint;\n\t\t\treturn 1;\n\t\t}\n\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\tif (!td->td_transferfunction[0] &&\n\t\t    !TIFFDefaultTransferFunction(td)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"No space for \\\"TransferFunction\\\" tag\");\n\t\t\treturn (0);\n\t\t}\n\t\t*va_arg(ap, uint16 **) = td->td_transferfunction[0];\n\t\tif (td->td_samplesperpixel - td->td_extrasamples > 1) {\n\t\t\t*va_arg(ap, uint16 **) = td->td_transferfunction[1];\n\t\t\t*va_arg(ap, uint16 **) = td->td_transferfunction[2];\n\t\t}\n\t\treturn (1);\n\tcase TIFFTAG_REFERENCEBLACKWHITE:\n\t\tif (!td->td_refblackwhite && !TIFFDefaultRefBlackWhite(td))\n\t\t\treturn (0);\n\t\t*va_arg(ap, float **) = td->td_refblackwhite;\n\t\treturn (1);\n\t}\n\treturn 0;\n}",
        "begin_line": 173,
        "end_line": 303,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_aux._TIFFCheckMalloc#85",
        "src_path": "libtiff/tif_aux.c",
        "class_name": "libtiff.tif_aux",
        "signature": "libtiff.tif_aux._TIFFCheckMalloc(TIFF* tif, tmsize_t nmemb, tmsize_t elem_size, const char* what)",
        "snippet": "void*\n_TIFFCheckMalloc(TIFF* tif, tmsize_t nmemb, tmsize_t elem_size, const char* what)\n{\n\treturn _TIFFCheckRealloc(tif, NULL, nmemb, elem_size, what);  \n}",
        "begin_line": 85,
        "end_line": 89,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_aux._TIFFCheckRealloc#62",
        "src_path": "libtiff/tif_aux.c",
        "class_name": "libtiff.tif_aux",
        "signature": "libtiff.tif_aux._TIFFCheckRealloc(TIFF* tif, void* buffer, tmsize_t nmemb, tmsize_t elem_size, const char* what)",
        "snippet": "void*\n_TIFFCheckRealloc(TIFF* tif, void* buffer,\n\t\t  tmsize_t nmemb, tmsize_t elem_size, const char* what)\n{\n\tvoid* cp = NULL;\n\ttmsize_t bytes = nmemb * elem_size;\n\n\t/*\n\t * XXX: Check for integer overflow.\n\t */\n\tif (nmemb && elem_size && bytes / elem_size == nmemb)\n\t\tcp = _TIFFrealloc(buffer, bytes);\n\n\tif (cp == NULL) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t     \"Failed to allocate memory for %s \"\n\t\t\t     \"(%ld elements of %ld bytes each)\",\n\t\t\t     what,(long) nmemb, (long) elem_size);\n\t}\n\n\treturn cp;\n}",
        "begin_line": 62,
        "end_line": 83,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_aux._TIFFMultiply64#49",
        "src_path": "libtiff/tif_aux.c",
        "class_name": "libtiff.tif_aux",
        "signature": "libtiff.tif_aux._TIFFMultiply64(TIFF* tif, uint64 first, uint64 second, const char* where)",
        "snippet": "uint64\n_TIFFMultiply64(TIFF* tif, uint64 first, uint64 second, const char* where)\n{\n\tuint64 bytes = first * second;\n\n\tif (second && bytes / second != first) {\n\t\tTIFFErrorExt(tif->tif_clientdata, where, \"Integer overflow in %s\", where);\n\t\tbytes = 0;\n\t}\n\n\treturn bytes;\n}",
        "begin_line": 49,
        "end_line": 60,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_close.TIFFCleanup#46",
        "src_path": "libtiff/tif_close.c",
        "class_name": "libtiff.tif_close",
        "signature": "libtiff.tif_close.TIFFCleanup(TIFF* tif)",
        "snippet": "void\nTIFFCleanup(TIFF* tif)\n{\n\t/*\n         * Flush buffered data and directory (if dirty).\n         */\n\tif (tif->tif_mode != O_RDONLY)\n\t\tTIFFFlush(tif);\n\t(*tif->tif_cleanup)(tif);\n\tTIFFFreeDirectory(tif);\n\n\tif (tif->tif_dirlist)\n\t\t_TIFFfree(tif->tif_dirlist);\n\n\t/*\n         * Clean up client info links.\n         */\n\twhile( tif->tif_clientinfo )\n\t{\n\t\tTIFFClientInfoLink *psLink = tif->tif_clientinfo;\n\n\t\ttif->tif_clientinfo = psLink->next;\n\t\t_TIFFfree( psLink->name );\n\t\t_TIFFfree( psLink );\n\t}\n\n\tif (tif->tif_rawdata && (tif->tif_flags&TIFF_MYBUFFER))\n\t\t_TIFFfree(tif->tif_rawdata);\n\tif (isMapped(tif))\n\t\tTIFFUnmapFileContents(tif, tif->tif_base, (toff_t)tif->tif_size);\n\n\t/*\n         * Clean up custom fields.\n         */\n\tif (tif->tif_fields && tif->tif_nfields > 0) {\n\t\tuint32 i;\n\n\t\tfor (i = 0; i < tif->tif_nfields; i++) {\n\t\t\tTIFFField *fld = tif->tif_fields[i];\n\t\t\tif (fld->field_bit == FIELD_CUSTOM &&\n\t\t\t    strncmp(\"Tag \", fld->field_name, 4) == 0) {\n\t\t\t\t_TIFFfree(fld->field_name);\n\t\t\t\t_TIFFfree(fld);\n\t\t\t}\n\t\t}\n\n\t\t_TIFFfree(tif->tif_fields);\n\t}\n\n        if (tif->tif_nfieldscompat > 0) {\n                uint32 i;\n\n                for (i = 0; i < tif->tif_nfieldscompat; i++) {\n                        if (tif->tif_fieldscompat[i].allocated_size)\n                                _TIFFfree(tif->tif_fieldscompat[i].fields);\n                }\n                _TIFFfree(tif->tif_fieldscompat);\n        }\n\n\t_TIFFfree(tif);\n}",
        "begin_line": 46,
        "end_line": 106,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_close.TIFFClose#122",
        "src_path": "libtiff/tif_close.c",
        "class_name": "libtiff.tif_close",
        "signature": "libtiff.tif_close.TIFFClose(TIFF* tif)",
        "snippet": "void\nTIFFClose(TIFF* tif)\n{\n\tTIFFCloseProc closeproc = tif->tif_closeproc;\n\tthandle_t fd = tif->tif_clientdata;\n\n\tTIFFCleanup(tif);\n\t(void) (*closeproc)(fd);\n}",
        "begin_line": 122,
        "end_line": 130,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_compress.TIFFFindCODEC#186",
        "src_path": "libtiff/tif_compress.c",
        "class_name": "libtiff.tif_compress",
        "signature": "libtiff.tif_compress.TIFFFindCODEC(uint16 scheme)",
        "snippet": "const TIFFCodec*\nTIFFFindCODEC(uint16 scheme)\n{\n\tconst TIFFCodec* c;\n\tcodec_t* cd;\n\n\tfor (cd = registeredCODECS; cd; cd = cd->next)\n\t\tif (cd->info->scheme == scheme)\n\t\t\treturn ((const TIFFCodec*) cd->info);\n\tfor (c = _TIFFBuiltinCODECS; c->name; c++)\n\t\tif (c->scheme == scheme)\n\t\t\treturn (c);\n\treturn ((const TIFFCodec*) 0);\n}",
        "begin_line": 186,
        "end_line": 199,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_compress.TIFFSetCompressionScheme#160",
        "src_path": "libtiff/tif_compress.c",
        "class_name": "libtiff.tif_compress",
        "signature": "libtiff.tif_compress.TIFFSetCompressionScheme(TIFF* tif, int scheme)",
        "snippet": "int\nTIFFSetCompressionScheme(TIFF* tif, int scheme)\n{\n\tconst TIFFCodec *c = TIFFFindCODEC((uint16) scheme);\n\n\t_TIFFSetDefaultCompressionState(tif);\n\t/*\n\t * Don't treat an unknown compression scheme as an error.\n\t * This permits applications to open files with data that\n\t * the library does not have builtin support for, but which\n\t * may still be meaningful.\n\t */\n\treturn (c ? (*c->init)(tif, scheme) : 1);\n}",
        "begin_line": 160,
        "end_line": 173,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_compress._TIFFSetDefaultCompressionState#135",
        "src_path": "libtiff/tif_compress.c",
        "class_name": "libtiff.tif_compress",
        "signature": "libtiff.tif_compress._TIFFSetDefaultCompressionState(TIFF* tif)",
        "snippet": "void\n_TIFFSetDefaultCompressionState(TIFF* tif)\n{\n\ttif->tif_fixuptags = _TIFFNoFixupTags; \n\ttif->tif_decodestatus = TRUE;\n\ttif->tif_setupdecode = _TIFFtrue;\n\ttif->tif_predecode = _TIFFNoPreCode;\n\ttif->tif_decoderow = _TIFFNoRowDecode;  \n\ttif->tif_decodestrip = _TIFFNoStripDecode;\n\ttif->tif_decodetile = _TIFFNoTileDecode;  \n\ttif->tif_encodestatus = TRUE;\n\ttif->tif_setupencode = _TIFFtrue;\n\ttif->tif_preencode = _TIFFNoPreCode;\n\ttif->tif_postencode = _TIFFtrue;\n\ttif->tif_encoderow = _TIFFNoRowEncode;\n\ttif->tif_encodestrip = _TIFFNoStripEncode;  \n\ttif->tif_encodetile = _TIFFNoTileEncode;  \n\ttif->tif_close = _TIFFvoid;\n\ttif->tif_seek = _TIFFNoSeek;\n\ttif->tif_cleanup = _TIFFvoid;\n\ttif->tif_defstripsize = _TIFFDefaultStripSize;\n\ttif->tif_deftilesize = _TIFFDefaultTileSize;\n\ttif->tif_flags &= ~(TIFF_NOBITREV|TIFF_NOREADRAW);\n}",
        "begin_line": 135,
        "end_line": 158,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_compress._TIFFvoid#133",
        "src_path": "libtiff/tif_compress.c",
        "class_name": "libtiff.tif_compress",
        "signature": "libtiff.tif_compress._TIFFvoid(TIFF* tif)",
        "snippet": "static void _TIFFvoid(TIFF* tif) { (void) tif; }",
        "begin_line": 133,
        "end_line": 133,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.OkToChangeTag#759",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.OkToChangeTag(TIFF* tif, uint32 tag)",
        "snippet": "static int\nOkToChangeTag(TIFF* tif, uint32 tag)\n{\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\tif (!fip) {\t\t\t/* unknown tag */\n\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFSetField\", \"%s: Unknown %stag %u\",\n\t\t    tif->tif_name, isPseudoTag(tag) ? \"pseudo-\" : \"\", tag);\n\t\treturn (0);\n\t}\n\tif (tag != TIFFTAG_IMAGELENGTH && (tif->tif_flags & TIFF_BEENWRITING) &&\n\t    !fip->field_oktochange) {\n\t\t/*\n\t\t * Consult info table to see if tag can be changed\n\t\t * after we've started writing.  We only allow changes\n\t\t * to those tags that don't/shouldn't affect the\n\t\t * compression and/or format of the data.\n\t\t */\n\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFSetField\",\n\t\t    \"%s: Cannot modify tag \\\"%s\\\" while writing\",\n\t\t    tif->tif_name, fip->field_name);\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
        "begin_line": 759,
        "end_line": 782,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFClampDoubleToFloat#158",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFClampDoubleToFloat( double val )",
        "snippet": "static float TIFFClampDoubleToFloat( double val )\n{\n    if( val > FLT_MAX )\n        return FLT_MAX;\n    if( val < -FLT_MAX )\n        return -FLT_MAX;\n    return (float)val;\n}",
        "begin_line": 158,
        "end_line": 165,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFDefaultDirectory#1352",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFDefaultDirectory(TIFF* tif)",
        "snippet": "int\nTIFFDefaultDirectory(TIFF* tif)\n{\n\tregister TIFFDirectory* td = &tif->tif_dir;\n\tconst TIFFFieldArray* tiffFieldArray;\n\n\ttiffFieldArray = _TIFFGetFields();\n\t_TIFFSetupFields(tif, tiffFieldArray);   \n\n\t_TIFFmemset(td, 0, sizeof (*td));\n\ttd->td_fillorder = FILLORDER_MSB2LSB;\n\ttd->td_bitspersample = 1;\n\ttd->td_threshholding = THRESHHOLD_BILEVEL;\n\ttd->td_orientation = ORIENTATION_TOPLEFT;\n\ttd->td_samplesperpixel = 1;\n\ttd->td_rowsperstrip = (uint32) -1;\n\ttd->td_tilewidth = 0;\n\ttd->td_tilelength = 0;\n\ttd->td_tiledepth = 1;\n\ttd->td_stripbytecountsorted = 1; /* Our own arrays always sorted. */  \n\ttd->td_resolutionunit = RESUNIT_INCH;\n\ttd->td_sampleformat = SAMPLEFORMAT_UINT;\n\ttd->td_imagedepth = 1;\n\ttd->td_ycbcrsubsampling[0] = 2;\n\ttd->td_ycbcrsubsampling[1] = 2;\n\ttd->td_ycbcrpositioning = YCBCRPOSITION_CENTERED;\n\ttif->tif_postdecode = _TIFFNoPostDecode;  \n\ttif->tif_foundfield = NULL;\n\ttif->tif_tagmethods.vsetfield = _TIFFVSetField;  \n\ttif->tif_tagmethods.vgetfield = _TIFFVGetField;\n\ttif->tif_tagmethods.printdir = NULL;\n\t/*\n\t *  Give client code a chance to install their own\n\t *  tag extensions & methods, prior to compression overloads,\n\t *  but do some prior cleanup first. (http://trac.osgeo.org/gdal/ticket/5054)\n\t */\n\tif (tif->tif_nfieldscompat > 0) {\n\t\tuint32 i;\n\n\t\tfor (i = 0; i < tif->tif_nfieldscompat; i++) {\n\t\t\t\tif (tif->tif_fieldscompat[i].allocated_size)\n\t\t\t\t\t\t_TIFFfree(tif->tif_fieldscompat[i].fields);\n\t\t}\n\t\t_TIFFfree(tif->tif_fieldscompat);\n\t\ttif->tif_nfieldscompat = 0;\n\t\ttif->tif_fieldscompat = NULL;\n\t}\n\tif (_TIFFextender)\n\t\t(*_TIFFextender)(tif);\n\t(void) TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t/*\n\t * NB: The directory is marked dirty as a result of setting\n\t * up the default compression scheme.  However, this really\n\t * isn't correct -- we want TIFF_DIRTYDIRECT to be set only\n\t * if the user does something.  We could just do the setup\n\t * by hand, but it seems better to use the normal mechanism\n\t * (i.e. TIFFSetField).\n\t */\n\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\n\n\t/*\n\t * As per http://bugzilla.remotesensing.org/show_bug.cgi?id=19\n\t * we clear the ISTILED flag when setting up a new directory.\n\t * Should we also be clearing stuff like INSUBIFD?\n\t */\n\ttif->tif_flags &= ~TIFF_ISTILED;\n\n\treturn (1);\n}",
        "begin_line": 1352,
        "end_line": 1420,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFFreeDirectory#1247",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFFreeDirectory(TIFF* tif)",
        "snippet": "void\nTIFFFreeDirectory(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tint            i;\n\n\t_TIFFmemset(td->td_fieldsset, 0, FIELD_SETLONGS);\n\tCleanupField(td_sminsamplevalue);\n\tCleanupField(td_smaxsamplevalue);\n\tCleanupField(td_colormap[0]);\n\tCleanupField(td_colormap[1]);\n\tCleanupField(td_colormap[2]);\n\tCleanupField(td_sampleinfo);\n\tCleanupField(td_subifd);\n\tCleanupField(td_inknames);\n\tCleanupField(td_refblackwhite);\n\tCleanupField(td_transferfunction[0]);\n\tCleanupField(td_transferfunction[1]);\n\tCleanupField(td_transferfunction[2]);\n\tCleanupField(td_stripoffset);\n\tCleanupField(td_stripbytecount);\n\tTIFFClrFieldBit(tif, FIELD_YCBCRSUBSAMPLING);\n\tTIFFClrFieldBit(tif, FIELD_YCBCRPOSITIONING);\n\n\t/* Cleanup custom tag values */\n\tfor( i = 0; i < td->td_customValueCount; i++ ) {\n\t\tif (td->td_customValues[i].value)\n\t\t\t_TIFFfree(td->td_customValues[i].value);\n\t}\n\n\ttd->td_customValueCount = 0;\n\tCleanupField(td_customValues);\n\n#if defined(DEFER_STRILE_LOAD)\n        _TIFFmemset( &(td->td_stripoffset_entry), 0, sizeof(TIFFDirEntry));\n        _TIFFmemset( &(td->td_stripbytecount_entry), 0, sizeof(TIFFDirEntry));\n#endif        \n}",
        "begin_line": 1247,
        "end_line": 1284,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFGetField#1211",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFGetField(TIFF* tif, uint32 tag, ...)",
        "snippet": "int\nTIFFGetField(TIFF* tif, uint32 tag, ...)\n{\n\tint status;\n\tva_list ap;\n\n\tva_start(ap, tag);\n\tstatus = TIFFVGetField(tif, tag, ap);\n\tva_end(ap);\n\treturn (status);\n}",
        "begin_line": 1211,
        "end_line": 1221,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFSetField#791",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFSetField(TIFF* tif, uint32 tag, ...)",
        "snippet": "int\nTIFFSetField(TIFF* tif, uint32 tag, ...)\n{\n\tva_list ap;\n\tint status;\n\n\tva_start(ap, tag);\n\tstatus = TIFFVSetField(tif, tag, ap);\n\tva_end(ap);\n\treturn (status);\n}",
        "begin_line": 791,
        "end_line": 801,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFVGetField#1229",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "int\nTIFFVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\treturn (fip && (isPseudoTag(tag) || TIFFFieldSet(tif, fip->field_bit)) ?\n\t    (*tif->tif_tagmethods.vgetfield)(tif, tag, ap) : 0);\n}",
        "begin_line": 1229,
        "end_line": 1235,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFVSetField#850",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "int\nTIFFVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\treturn OkToChangeTag(tif, tag) ?\n\t    (*tif->tif_tagmethods.vsetfield)(tif, tag, ap) : 0;\n}",
        "begin_line": 850,
        "end_line": 855,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir._TIFFVGetField#857",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir._TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "static int\n_TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tTIFFDirectory* td = &tif->tif_dir;\n\tint ret_val = 1;\n\tuint32 standard_tag = tag;\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\tif( fip == NULL ) /* cannot happen since TIFFGetField() already checks it */\n\t    return 0;\n\t\n        if( tag == TIFFTAG_NUMBEROFINKS )\n        {\n            int i;\n            for (i = 0; i < td->td_customValueCount; i++) {\n                uint16 val;\n                TIFFTagValue *tv = td->td_customValues + i;\n                if (tv->info->field_tag != tag)\n                    continue;\n                val = *(uint16 *)tv->value;\n                /* Truncate to SamplesPerPixel, since the */\n                /* setting code for INKNAMES assume that there are SamplesPerPixel */\n                /* inknames. */\n                /* Fixes http://bugzilla.maptools.org/show_bug.cgi?id=2599 */\n                if( val > td->td_samplesperpixel )\n                {\n                    TIFFWarningExt(tif->tif_clientdata,\"_TIFFVGetField\",\n                                   \"Truncating NumberOfInks from %u to %u\",\n                                   val, td->td_samplesperpixel);\n                    val = td->td_samplesperpixel;\n                }\n                *va_arg(ap, uint16*) = val;\n                return 1;\n            }\n            return 0;\n        }\n\n\t/*\n\t * We want to force the custom code to be used for custom\n\t * fields even if the tag happens to match a well known \n\t * one - important for reinterpreted handling of standard\n\t * tag values in custom directories (i.e. EXIF) \n\t */\n\tif (fip->field_bit == FIELD_CUSTOM) {\n\t\tstandard_tag = 0;\n\t}\n\n\tswitch (standard_tag) {\n\t\tcase TIFFTAG_SUBFILETYPE:\n\t\t\t*va_arg(ap, uint32*) = td->td_subfiletype;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGEWIDTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagewidth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGELENGTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagelength;\n\t\t\tbreak;\n\t\tcase TIFFTAG_BITSPERSAMPLE:\n\t\t\t*va_arg(ap, uint16*) = td->td_bitspersample;\n\t\t\tbreak;\n\t\tcase TIFFTAG_COMPRESSION:\n\t\t\t*va_arg(ap, uint16*) = td->td_compression;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PHOTOMETRIC:\n\t\t\t*va_arg(ap, uint16*) = td->td_photometric;\n\t\t\tbreak;\n\t\tcase TIFFTAG_THRESHHOLDING:\n\t\t\t*va_arg(ap, uint16*) = td->td_threshholding;\n\t\t\tbreak;\n\t\tcase TIFFTAG_FILLORDER:\n\t\t\t*va_arg(ap, uint16*) = td->td_fillorder;\n\t\t\tbreak;\n\t\tcase TIFFTAG_ORIENTATION:\n\t\t\t*va_arg(ap, uint16*) = td->td_orientation;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SAMPLESPERPIXEL:\n\t\t\t*va_arg(ap, uint16*) = td->td_samplesperpixel;\n\t\t\tbreak;\n\t\tcase TIFFTAG_ROWSPERSTRIP:\n\t\t\t*va_arg(ap, uint32*) = td->td_rowsperstrip;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\t\t*va_arg(ap, uint16*) = td->td_minsamplevalue;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\t\t*va_arg(ap, uint16*) = td->td_maxsamplevalue;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t\t*va_arg(ap, double**) = td->td_sminsamplevalue;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* libtiff historically treats this as a single value. */\n\t\t\t\tuint16 i;\n\t\t\t\tdouble v = td->td_sminsamplevalue[0];\n\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\n\t\t\t\t\tif( td->td_sminsamplevalue[i] < v )\n\t\t\t\t\t\tv = td->td_sminsamplevalue[i];\n\t\t\t\t*va_arg(ap, double*) = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t\t*va_arg(ap, double**) = td->td_smaxsamplevalue;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* libtiff historically treats this as a single value. */\n\t\t\t\tuint16 i;\n\t\t\t\tdouble v = td->td_smaxsamplevalue[0];\n\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\n\t\t\t\t\tif( td->td_smaxsamplevalue[i] > v )\n\t\t\t\t\t\tv = td->td_smaxsamplevalue[i];\n\t\t\t\t*va_arg(ap, double*) = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_XRESOLUTION:\n\t\t\t*va_arg(ap, float*) = td->td_xresolution;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YRESOLUTION:\n\t\t\t*va_arg(ap, float*) = td->td_yresolution;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PLANARCONFIG:\n\t\t\t*va_arg(ap, uint16*) = td->td_planarconfig;\n\t\t\tbreak;\n\t\tcase TIFFTAG_XPOSITION:\n\t\t\t*va_arg(ap, float*) = td->td_xposition;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YPOSITION:\n\t\t\t*va_arg(ap, float*) = td->td_yposition;\n\t\t\tbreak;\n\t\tcase TIFFTAG_RESOLUTIONUNIT:\n\t\t\t*va_arg(ap, uint16*) = td->td_resolutionunit;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PAGENUMBER:\n\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_HALFTONEHINTS:\n\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_COLORMAP:\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[0];\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[1];\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[2];\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\tcase TIFFTAG_TILEOFFSETS:\n\t\t\t_TIFFFillStriles( tif );\n\t\t\t*va_arg(ap, uint64**) = td->td_stripoffset;\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\t\t_TIFFFillStriles( tif );\n\t\t\t*va_arg(ap, uint64**) = td->td_stripbytecount;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MATTEING:\n\t\t\t*va_arg(ap, uint16*) =\n\t\t\t    (td->td_extrasamples == 1 &&\n\t\t\t    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);\n\t\t\tbreak;\n\t\tcase TIFFTAG_EXTRASAMPLES:\n\t\t\t*va_arg(ap, uint16*) = td->td_extrasamples;\n\t\t\t*va_arg(ap, uint16**) = td->td_sampleinfo;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILEWIDTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tilewidth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILELENGTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tilelength;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILEDEPTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tiledepth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_DATATYPE:\n\t\t\tswitch (td->td_sampleformat) {\n\t\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_UINT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_INT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_IEEEFP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_VOID:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_VOID;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_SAMPLEFORMAT:\n\t\t\t*va_arg(ap, uint16*) = td->td_sampleformat;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGEDEPTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagedepth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SUBIFD:\n\t\t\t*va_arg(ap, uint16*) = td->td_nsubifd;\n\t\t\t*va_arg(ap, uint64**) = td->td_subifd;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRPOSITIONING:\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrpositioning;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[0];\n\t\t\tif (td->td_samplesperpixel - td->td_extrasamples > 1) {\n\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[1];\n\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[2];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_REFERENCEBLACKWHITE:\n\t\t\t*va_arg(ap, float**) = td->td_refblackwhite;\n\t\t\tbreak;\n\t\tcase TIFFTAG_INKNAMES:\n\t\t\t*va_arg(ap, char**) = td->td_inknames;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\t/*\n\t\t\t\t * This can happen if multiple images are open\n\t\t\t\t * with different codecs which have private\n\t\t\t\t * tags.  The global tag information table may\n\t\t\t\t * then have tags that are valid for one file\n\t\t\t\t * but not the other. If the client tries to\n\t\t\t\t * get a tag that is not valid for the image's\n\t\t\t\t * codec then we'll arrive here.\n\t\t\t\t */\n\t\t\t\tif( fip->field_bit != FIELD_CUSTOM )\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, \"_TIFFVGetField\",\n\t\t\t\t\t    \"%s: Invalid %stag \\\"%s\\\" \"\n\t\t\t\t\t    \"(not supported by codec)\",\n\t\t\t\t\t    tif->tif_name,\n\t\t\t\t\t    isPseudoTag(tag) ? \"pseudo-\" : \"\",\n\t\t\t\t\t    fip->field_name);\n\t\t\t\t\tret_val = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Do we have a custom value?\n\t\t\t\t */\n\t\t\t\tret_val = 0;\n\t\t\t\tfor (i = 0; i < td->td_customValueCount; i++) {\n\t\t\t\t\tTIFFTagValue *tv = td->td_customValues + i;\n\n\t\t\t\t\tif (tv->info->field_tag != tag)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (fip->field_passcount) {\n\t\t\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE2)\n\t\t\t\t\t\t\t*va_arg(ap, uint32*) = (uint32)tv->count;\n\t\t\t\t\t\telse  /* Assume TIFF_VARIABLE */\n\t\t\t\t\t\t\t*va_arg(ap, uint16*) = (uint16)tv->count;\n\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\n\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t} else if (fip->field_tag == TIFFTAG_DOTRANGE\n\t\t\t\t\t\t   && strcmp(fip->field_name,\"DotRange\") == 0) {\n\t\t\t\t\t\t/* TODO: This is an evil exception and should not have been\n\t\t\t\t\t\t   handled this way ... likely best if we move it into\n\t\t\t\t\t\t   the directory structure with an explicit field in \n\t\t\t\t\t\t   libtiff 4.1 and assign it a FIELD_ value */\n\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];\n\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];\n\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (fip->field_type == TIFF_ASCII\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE2\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_SPP\n\t\t\t\t\t\t    || tv->count > 1) {\n\t\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\n\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchar *val = (char *)tv->value;\n\t\t\t\t\t\t\tassert( tv->count == 1 );\n\t\t\t\t\t\t\tswitch (fip->field_type) {\n\t\t\t\t\t\t\tcase TIFF_BYTE:\n\t\t\t\t\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint8*) =\n\t\t\t\t\t\t\t\t\t*(uint8 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SBYTE:\n\t\t\t\t\t\t\t\t*va_arg(ap, int8*) =\n\t\t\t\t\t\t\t\t\t*(int8 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SHORT:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint16*) =\n\t\t\t\t\t\t\t\t\t*(uint16 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SSHORT:\n\t\t\t\t\t\t\t\t*va_arg(ap, int16*) =\n\t\t\t\t\t\t\t\t\t*(int16 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_LONG:\n\t\t\t\t\t\t\tcase TIFF_IFD:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint32*) =\n\t\t\t\t\t\t\t\t\t*(uint32 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SLONG:\n\t\t\t\t\t\t\t\t*va_arg(ap, int32*) =\n\t\t\t\t\t\t\t\t\t*(int32 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_LONG8:\n\t\t\t\t\t\t\tcase TIFF_IFD8:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint64*) =\n\t\t\t\t\t\t\t\t\t*(uint64 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SLONG8:\n\t\t\t\t\t\t\t\t*va_arg(ap, int64*) =\n\t\t\t\t\t\t\t\t\t*(int64 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_RATIONAL:\n\t\t\t\t\t\t\tcase TIFF_SRATIONAL:\n\t\t\t\t\t\t\tcase TIFF_FLOAT:\n\t\t\t\t\t\t\t\t*va_arg(ap, float*) =\n\t\t\t\t\t\t\t\t\t*(float *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_DOUBLE:\n\t\t\t\t\t\t\t\t*va_arg(ap, double*) =\n\t\t\t\t\t\t\t\t\t*(double *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tret_val = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn(ret_val);\n}",
        "begin_line": 857,
        "end_line": 1205,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir._TIFFVSetField#167",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir._TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "static int\n_TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tstatic const char module[] = \"_TIFFVSetField\";\n\n\tTIFFDirectory* td = &tif->tif_dir;\n\tint status = 1;\n\tuint32 v32, i, v;\n    double dblval;\n\tchar* s;\n\tconst TIFFField *fip = TIFFFindField(tif, tag, TIFF_ANY);\n\tuint32 standard_tag = tag;\n\tif( fip == NULL ) /* cannot happen since OkToChangeTag() already checks it */\n\t    return 0;\n\t/*\n\t * We want to force the custom code to be used for custom\n\t * fields even if the tag happens to match a well known \n\t * one - important for reinterpreted handling of standard\n\t * tag values in custom directories (i.e. EXIF) \n\t */\n\tif (fip->field_bit == FIELD_CUSTOM) {\n\t\tstandard_tag = 0;\n\t}\n\n\tswitch (standard_tag) {\n\tcase TIFFTAG_SUBFILETYPE:\n\t\ttd->td_subfiletype = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_IMAGEWIDTH:\n\t\ttd->td_imagewidth = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_IMAGELENGTH:\n\t\ttd->td_imagelength = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_BITSPERSAMPLE:\n\t\ttd->td_bitspersample = (uint16) va_arg(ap, uint16_vap);\n\t\t/*\n\t\t * If the data require post-decoding processing to byte-swap\n\t\t * samples, set it up here.  Note that since tags are required\n\t\t * to be ordered, compression code can override this behaviour\n\t\t * in the setup method if it wants to roll the post decoding\n\t\t * work in with its normal work.\n\t\t */\n\t\tif (tif->tif_flags & TIFF_SWAB) {\n\t\t\tif (td->td_bitspersample == 8)\n\t\t\t\ttif->tif_postdecode = _TIFFNoPostDecode;\n\t\t\telse if (td->td_bitspersample == 16)\n\t\t\t\ttif->tif_postdecode = _TIFFSwab16BitData;\n\t\t\telse if (td->td_bitspersample == 24)\n\t\t\t\ttif->tif_postdecode = _TIFFSwab24BitData;\n\t\t\telse if (td->td_bitspersample == 32)\n\t\t\t\ttif->tif_postdecode = _TIFFSwab32BitData;\n\t\t\telse if (td->td_bitspersample == 64)\n\t\t\t\ttif->tif_postdecode = _TIFFSwab64BitData;\n\t\t\telse if (td->td_bitspersample == 128) /* two 64's */\n\t\t\t\ttif->tif_postdecode = _TIFFSwab64BitData;\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_COMPRESSION:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\t/*\n\t\t * If we're changing the compression scheme, the notify the\n\t\t * previous module so that it can cleanup any state it's\n\t\t * setup.\n\t\t */\n\t\tif (TIFFFieldSet(tif, FIELD_COMPRESSION)) {\n\t\t\tif ((uint32)td->td_compression == v)\n\t\t\t\tbreak;\n\t\t\t(*tif->tif_cleanup)(tif);\n\t\t\ttif->tif_flags &= ~TIFF_CODERSETUP;\n\t\t}\n\t\t/*\n\t\t * Setup new compression routine state.\n\t\t */\n\t\tif( (status = TIFFSetCompressionScheme(tif, v)) != 0 )\n\t\t    td->td_compression = (uint16) v;\n\t\telse\n\t\t    status = 0;\n\t\tbreak;\n\tcase TIFFTAG_PHOTOMETRIC:\n\t\ttd->td_photometric = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_THRESHHOLDING:\n\t\ttd->td_threshholding = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_FILLORDER:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v != FILLORDER_LSB2MSB && v != FILLORDER_MSB2LSB)\n\t\t\tgoto badvalue;\n\t\ttd->td_fillorder = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_ORIENTATION:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v < ORIENTATION_TOPLEFT || ORIENTATION_LEFTBOT < v)\n\t\t\tgoto badvalue;\n\t\telse\n\t\t\ttd->td_orientation = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_SAMPLESPERPIXEL:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v == 0)\n\t\t\tgoto badvalue;\n        if( v != td->td_samplesperpixel )\n        {\n            /* See http://bugzilla.maptools.org/show_bug.cgi?id=2500 */\n            if( td->td_sminsamplevalue != NULL )\n            {\n                TIFFWarningExt(tif->tif_clientdata,module,\n                    \"SamplesPerPixel tag value is changing, \"\n                    \"but SMinSampleValue tag was read with a different value. Cancelling it\");\n                TIFFClrFieldBit(tif,FIELD_SMINSAMPLEVALUE);\n                _TIFFfree(td->td_sminsamplevalue);\n                td->td_sminsamplevalue = NULL;\n            }\n            if( td->td_smaxsamplevalue != NULL )\n            {\n                TIFFWarningExt(tif->tif_clientdata,module,\n                    \"SamplesPerPixel tag value is changing, \"\n                    \"but SMaxSampleValue tag was read with a different value. Cancelling it\");\n                TIFFClrFieldBit(tif,FIELD_SMAXSAMPLEVALUE);\n                _TIFFfree(td->td_smaxsamplevalue);\n                td->td_smaxsamplevalue = NULL;\n            }\n        }\n\t\ttd->td_samplesperpixel = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_ROWSPERSTRIP:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 == 0)\n\t\t\tgoto badvalue32;\n\t\ttd->td_rowsperstrip = v32;\n\t\tif (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {\n\t\t\ttd->td_tilelength = v32;\n\t\t\ttd->td_tilewidth = td->td_imagewidth;\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\ttd->td_minsamplevalue = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\ttd->td_maxsamplevalue = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t_TIFFsetDoubleArray(&td->td_sminsamplevalue, va_arg(ap, double*), td->td_samplesperpixel);\n\t\telse\n\t\t\tsetDoubleArrayOneValue(&td->td_sminsamplevalue, va_arg(ap, double), td->td_samplesperpixel);\n\t\tbreak;\n\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t_TIFFsetDoubleArray(&td->td_smaxsamplevalue, va_arg(ap, double*), td->td_samplesperpixel);\n\t\telse\n\t\t\tsetDoubleArrayOneValue(&td->td_smaxsamplevalue, va_arg(ap, double), td->td_samplesperpixel);\n\t\tbreak;\n\tcase TIFFTAG_XRESOLUTION:\n        dblval = va_arg(ap, double);\n        if( dblval < 0 )\n            goto badvaluedouble;\n\t\ttd->td_xresolution = TIFFClampDoubleToFloat( dblval );\n\t\tbreak;\n\tcase TIFFTAG_YRESOLUTION:\n        dblval = va_arg(ap, double);\n        if( dblval < 0 )\n            goto badvaluedouble;\n\t\ttd->td_yresolution = TIFFClampDoubleToFloat( dblval );\n\t\tbreak;\n\tcase TIFFTAG_PLANARCONFIG:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v != PLANARCONFIG_CONTIG && v != PLANARCONFIG_SEPARATE)\n\t\t\tgoto badvalue;\n\t\ttd->td_planarconfig = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_XPOSITION:\n\t\ttd->td_xposition = TIFFClampDoubleToFloat( va_arg(ap, double) );\n\t\tbreak;\n\tcase TIFFTAG_YPOSITION:\n\t\ttd->td_yposition = TIFFClampDoubleToFloat( va_arg(ap, double) );\n\t\tbreak;\n\tcase TIFFTAG_RESOLUTIONUNIT:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v < RESUNIT_NONE || RESUNIT_CENTIMETER < v)\n\t\t\tgoto badvalue;\n\t\ttd->td_resolutionunit = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_PAGENUMBER:\n\t\ttd->td_pagenumber[0] = (uint16) va_arg(ap, uint16_vap);\n\t\ttd->td_pagenumber[1] = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_HALFTONEHINTS:\n\t\ttd->td_halftonehints[0] = (uint16) va_arg(ap, uint16_vap);\n\t\ttd->td_halftonehints[1] = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_COLORMAP:\n\t\tv32 = (uint32)(1L<<td->td_bitspersample);\n\t\t_TIFFsetShortArray(&td->td_colormap[0], va_arg(ap, uint16*), v32);\n\t\t_TIFFsetShortArray(&td->td_colormap[1], va_arg(ap, uint16*), v32);\n\t\t_TIFFsetShortArray(&td->td_colormap[2], va_arg(ap, uint16*), v32);\n\t\tbreak;\n\tcase TIFFTAG_EXTRASAMPLES:\n\t\tif (!setExtraSamples(td, ap, &v))\n\t\t\tgoto badvalue;\n\t\tbreak;\n\tcase TIFFTAG_MATTEING:\n\t\ttd->td_extrasamples =  (((uint16) va_arg(ap, uint16_vap)) != 0);\n\t\tif (td->td_extrasamples) {\n\t\t\tuint16 sv = EXTRASAMPLE_ASSOCALPHA;\n\t\t\t_TIFFsetShortArray(&td->td_sampleinfo, &sv, 1);\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_TILEWIDTH:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 % 16) {\n\t\t\tif (tif->tif_mode != O_RDONLY)\n\t\t\t\tgoto badvalue32;\n\t\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t\t\"Nonstandard tile width %d, convert file\", v32);\n\t\t}\n\t\ttd->td_tilewidth = v32;\n\t\ttif->tif_flags |= TIFF_ISTILED;\n\t\tbreak;\n\tcase TIFFTAG_TILELENGTH:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 % 16) {\n\t\t\tif (tif->tif_mode != O_RDONLY)\n\t\t\t\tgoto badvalue32;\n\t\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t    \"Nonstandard tile length %d, convert file\", v32);\n\t\t}\n\t\ttd->td_tilelength = v32;\n\t\ttif->tif_flags |= TIFF_ISTILED;\n\t\tbreak;\n\tcase TIFFTAG_TILEDEPTH:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 == 0)\n\t\t\tgoto badvalue32;\n\t\ttd->td_tiledepth = v32;\n\t\tbreak;\n\tcase TIFFTAG_DATATYPE:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tswitch (v) {\n\t\tcase DATATYPE_VOID:\tv = SAMPLEFORMAT_VOID;\tbreak;\n\t\tcase DATATYPE_INT:\tv = SAMPLEFORMAT_INT;\tbreak;\n\t\tcase DATATYPE_UINT:\tv = SAMPLEFORMAT_UINT;\tbreak;\n\t\tcase DATATYPE_IEEEFP:\tv = SAMPLEFORMAT_IEEEFP;break;\n\t\tdefault:\t\tgoto badvalue;\n\t\t}\n\t\ttd->td_sampleformat = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_SAMPLEFORMAT:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v < SAMPLEFORMAT_UINT || SAMPLEFORMAT_COMPLEXIEEEFP < v)\n\t\t\tgoto badvalue;\n\t\ttd->td_sampleformat = (uint16) v;\n\n\t\t/*  Try to fix up the SWAB function for complex data. */\n\t\tif( td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT\n\t\t    && td->td_bitspersample == 32\n\t\t    && tif->tif_postdecode == _TIFFSwab32BitData )\n\t\t    tif->tif_postdecode = _TIFFSwab16BitData;\n\t\telse if( (td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT\n\t\t\t  || td->td_sampleformat == SAMPLEFORMAT_COMPLEXIEEEFP)\n\t\t\t && td->td_bitspersample == 64\n\t\t\t && tif->tif_postdecode == _TIFFSwab64BitData )\n\t\t    tif->tif_postdecode = _TIFFSwab32BitData;\n\t\tbreak;\n\tcase TIFFTAG_IMAGEDEPTH:\n\t\ttd->td_imagedepth = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_SUBIFD:\n\t\tif ((tif->tif_flags & TIFF_INSUBIFD) == 0) {\n\t\t\ttd->td_nsubifd = (uint16) va_arg(ap, uint16_vap);\n\t\t\t_TIFFsetLong8Array(&td->td_subifd, (uint64*) va_arg(ap, uint64*),\n\t\t\t    (uint32) td->td_nsubifd);\n\t\t} else {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"%s: Sorry, cannot nest SubIFDs\",\n\t\t\t\t     tif->tif_name);\n\t\t\tstatus = 0;\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_YCBCRPOSITIONING:\n\t\ttd->td_ycbcrpositioning = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\ttd->td_ycbcrsubsampling[0] = (uint16) va_arg(ap, uint16_vap);\n\t\ttd->td_ycbcrsubsampling[1] = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\tv = (td->td_samplesperpixel - td->td_extrasamples) > 1 ? 3 : 1;\n\t\tfor (i = 0; i < v; i++)\n\t\t\t_TIFFsetShortArray(&td->td_transferfunction[i],\n\t\t\t    va_arg(ap, uint16*), 1U<<td->td_bitspersample);\n\t\tbreak;\n\tcase TIFFTAG_REFERENCEBLACKWHITE:\n\t\t/* XXX should check for null range */\n\t\t_TIFFsetFloatArray(&td->td_refblackwhite, va_arg(ap, float*), 6);\n\t\tbreak;\n\tcase TIFFTAG_INKNAMES:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\ts = va_arg(ap, char*);\n\t\tv = checkInkNamesString(tif, v, s);\n\t\tstatus = v > 0;\n\t\tif( v > 0 ) {\n\t\t\t_TIFFsetNString(&td->td_inknames, s, v);\n\t\t\ttd->td_inknameslen = v;\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_PERSAMPLE:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif( v == PERSAMPLE_MULTI )\n\t\t\ttif->tif_flags |= TIFF_PERSAMPLE;\n\t\telse\n\t\t\ttif->tif_flags &= ~TIFF_PERSAMPLE;\n\t\tbreak;\n\tdefault: {\n\t\tTIFFTagValue *tv;\n\t\tint tv_size, iCustom;\n\n\t\t/*\n\t\t * This can happen if multiple images are open with different\n\t\t * codecs which have private tags.  The global tag information\n\t\t * table may then have tags that are valid for one file but not\n\t\t * the other. If the client tries to set a tag that is not valid\n\t\t * for the image's codec then we'll arrive here.  This\n\t\t * happens, for example, when tiffcp is used to convert between\n\t\t * compression schemes and codec-specific tags are blindly copied.\n\t\t */\n\t\tif(fip->field_bit != FIELD_CUSTOM) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"%s: Invalid %stag \\\"%s\\\" (not supported by codec)\",\n\t\t\t    tif->tif_name, isPseudoTag(tag) ? \"pseudo-\" : \"\",\n\t\t\t    fip->field_name);\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Find the existing entry for this custom value.\n\t\t */\n\t\ttv = NULL;\n\t\tfor (iCustom = 0; iCustom < td->td_customValueCount; iCustom++) {\n\t\t\tif (td->td_customValues[iCustom].info->field_tag == tag) {\n\t\t\t\ttv = td->td_customValues + iCustom;\n\t\t\t\tif (tv->value != NULL) {\n\t\t\t\t\t_TIFFfree(tv->value);\n\t\t\t\t\ttv->value = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Grow the custom list if the entry was not found.\n\t\t */\n\t\tif(tv == NULL) {\n\t\t\tTIFFTagValue *new_customValues;\n\n\t\t\ttd->td_customValueCount++;\n\t\t\tnew_customValues = (TIFFTagValue *)\n\t\t\t    _TIFFrealloc(td->td_customValues,\n\t\t\t    sizeof(TIFFTagValue) * td->td_customValueCount);\n\t\t\tif (!new_customValues) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"%s: Failed to allocate space for list of custom values\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\ttd->td_customValues = new_customValues;\n\n\t\t\ttv = td->td_customValues + (td->td_customValueCount - 1);\n\t\t\ttv->info = fip;\n\t\t\ttv->value = NULL;\n\t\t\ttv->count = 0;\n\t\t}\n\n\t\t/*\n\t\t * Set custom value ... save a copy of the custom tag value.\n\t\t */\n\t\ttv_size = _TIFFDataSize(fip->field_type);\n\t\tif (tv_size == 0) {\n\t\t\tstatus = 0;\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"%s: Bad field type %d for \\\"%s\\\"\",\n\t\t\t    tif->tif_name, fip->field_type,\n\t\t\t    fip->field_name);\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (fip->field_type == TIFF_ASCII)\n\t\t{\n\t\t\tuint32 ma;\n\t\t\tchar* mb;\n\t\t\tif (fip->field_passcount)\n\t\t\t{\n\t\t\t\tassert(fip->field_writecount==TIFF_VARIABLE2);\n\t\t\t\tma=(uint32)va_arg(ap,uint32);\n\t\t\t\tmb=(char*)va_arg(ap,char*);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmb=(char*)va_arg(ap,char*);\n\t\t\t\tma=(uint32)(strlen(mb)+1);\n\t\t\t}\n\t\t\ttv->count=ma;\n\t\t\tsetByteArray(&tv->value,mb,ma,1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (fip->field_passcount) {\n\t\t\t\tif (fip->field_writecount == TIFF_VARIABLE2)\n\t\t\t\t\ttv->count = (uint32) va_arg(ap, uint32);\n\t\t\t\telse\n\t\t\t\t\ttv->count = (int) va_arg(ap, int);\n\t\t\t} else if (fip->field_writecount == TIFF_VARIABLE\n\t\t\t   || fip->field_writecount == TIFF_VARIABLE2)\n\t\t\t\ttv->count = 1;\n\t\t\telse if (fip->field_writecount == TIFF_SPP)\n\t\t\t\ttv->count = td->td_samplesperpixel;\n\t\t\telse\n\t\t\t\ttv->count = fip->field_writecount;\n\n\t\t\tif (tv->count == 0) {\n\t\t\t\tstatus = 0;\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"%s: Null count for \\\"%s\\\" (type \"\n\t\t\t\t\t     \"%d, writecount %d, passcount %d)\",\n\t\t\t\t\t     tif->tif_name,\n\t\t\t\t\t     fip->field_name,\n\t\t\t\t\t     fip->field_type,\n\t\t\t\t\t     fip->field_writecount,\n\t\t\t\t\t     fip->field_passcount);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\ttv->value = _TIFFCheckMalloc(tif, tv->count, tv_size,\n\t\t\t    \"custom tag binary object\");\n\t\t\tif (!tv->value) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tif (fip->field_tag == TIFFTAG_DOTRANGE \n\t\t\t    && strcmp(fip->field_name,\"DotRange\") == 0) {\n\t\t\t\t/* TODO: This is an evil exception and should not have been\n\t\t\t\t   handled this way ... likely best if we move it into\n\t\t\t\t   the directory structure with an explicit field in \n\t\t\t\t   libtiff 4.1 and assign it a FIELD_ value */\n\t\t\t\tuint16 v2[2];\n\t\t\t\tv2[0] = (uint16)va_arg(ap, int);\n\t\t\t\tv2[1] = (uint16)va_arg(ap, int);\n\t\t\t\t_TIFFmemcpy(tv->value, &v2, 4);\n\t\t\t}\n\n\t\t\telse if (fip->field_passcount\n\t\t\t\t  || fip->field_writecount == TIFF_VARIABLE\n\t\t\t\t  || fip->field_writecount == TIFF_VARIABLE2\n\t\t\t\t  || fip->field_writecount == TIFF_SPP\n\t\t\t\t  || tv->count > 1) {\n\t\t\t\t_TIFFmemcpy(tv->value, va_arg(ap, void *),\n\t\t\t\t    tv->count * tv_size);\n\t\t\t} else {\n\t\t\t\tchar *val = (char *)tv->value;\n\t\t\t\tassert( tv->count == 1 );\n\n\t\t\t\tswitch (fip->field_type) {\n\t\t\t\tcase TIFF_BYTE:\n\t\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8 v2 = (uint8)va_arg(ap, int);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SBYTE:\n\t\t\t\t\t{\n\t\t\t\t\t\tint8 v2 = (int8)va_arg(ap, int);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SHORT:\n\t\t\t\t\t{\n\t\t\t\t\t\tuint16 v2 = (uint16)va_arg(ap, int);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SSHORT:\n\t\t\t\t\t{\n\t\t\t\t\t\tint16 v2 = (int16)va_arg(ap, int);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_LONG:\n\t\t\t\tcase TIFF_IFD:\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32 v2 = va_arg(ap, uint32);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SLONG:\n\t\t\t\t\t{\n\t\t\t\t\t\tint32 v2 = va_arg(ap, int32);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_LONG8:\n\t\t\t\tcase TIFF_IFD8:\n\t\t\t\t\t{\n\t\t\t\t\t\tuint64 v2 = va_arg(ap, uint64);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SLONG8:\n\t\t\t\t\t{\n\t\t\t\t\t\tint64 v2 = va_arg(ap, int64);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_RATIONAL:\n\t\t\t\tcase TIFF_SRATIONAL:\n\t\t\t\tcase TIFF_FLOAT:\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat v2 = (float)va_arg(ap, double);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_DOUBLE:\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble v2 = va_arg(ap, double);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t_TIFFmemset(val, 0, tv_size);\n\t\t\t\t\tstatus = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t}\n\tif (status) {\n\t\tconst TIFFField* fip2=TIFFFieldWithTag(tif,tag);\n\t\tif (fip2)                \n\t\t\tTIFFSetFieldBit(tif, fip2->field_bit);\n\t\ttif->tif_flags |= TIFF_DIRTYDIRECT;\n\t}\n\nend:\n\tva_end(ap);\n\treturn (status);\nbadvalue:\n        {\n\t\tconst TIFFField* fip2=TIFFFieldWithTag(tif,tag);\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t     \"%s: Bad value %u for \\\"%s\\\" tag\",\n\t\t     tif->tif_name, v,\n\t\t     fip2 ? fip2->field_name : \"Unknown\");\n\t\tva_end(ap);\n        }\n\treturn (0);\nbadvalue32:\n        {\n\t\tconst TIFFField* fip2=TIFFFieldWithTag(tif,tag);\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t     \"%s: Bad value %u for \\\"%s\\\" tag\",\n\t\t     tif->tif_name, v32,\n\t\t     fip2 ? fip2->field_name : \"Unknown\");\n\t\tva_end(ap);\n        }\n\treturn (0);\nbadvaluedouble:\n        {\n        const TIFFField* fip2=TIFFFieldWithTag(tif,tag);\n        TIFFErrorExt(tif->tif_clientdata, module,\n             \"%s: Bad value %f for \\\"%s\\\" tag\",\n             tif->tif_name, dblval,\n             fip2 ? fip2->field_name : \"Unknown\");\n        va_end(ap);\n        }\n    return (0);\n}",
        "begin_line": 167,
        "end_line": 748,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir._TIFFsetByteArray#59",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir._TIFFsetByteArray(void** vpp, void* vp, uint32 n)",
        "snippet": "void _TIFFsetByteArray(void** vpp, void* vp, uint32 n)\n    { setByteArray(vpp, vp, n, 1); }",
        "begin_line": 59,
        "end_line": 60,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir._TIFFsetFloatArray#71",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir._TIFFsetFloatArray(float** fpp, float* fp, uint32 n)",
        "snippet": "void _TIFFsetFloatArray(float** fpp, float* fp, uint32 n)\n    { setByteArray((void**) fpp, (void*) fp, n, sizeof (float)); }",
        "begin_line": 71,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir._TIFFsetShortArray#65",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir._TIFFsetShortArray(uint16** wpp, uint16* wp, uint32 n)",
        "snippet": "void _TIFFsetShortArray(uint16** wpp, uint16* wp, uint32 n)\n    { setByteArray((void**) wpp, (void*) wp, n, sizeof (uint16)); }",
        "begin_line": 65,
        "end_line": 66,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.setByteArray#44",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.setByteArray(void** vpp, void* vp, size_t nmemb, size_t elem_size)",
        "snippet": "static void\nsetByteArray(void** vpp, void* vp, size_t nmemb, size_t elem_size)\n{\n\tif (*vpp) {\n\t\t_TIFFfree(*vpp);\n\t\t*vpp = 0;\n\t}\n\tif (vp) {\n\t\ttmsize_t bytes = (tmsize_t)(nmemb * elem_size);\n\t\tif (elem_size && bytes / elem_size == nmemb)\n\t\t\t*vpp = (void*) _TIFFmalloc(bytes);\n\t\tif (*vpp)\n\t\t\t_TIFFmemcpy(*vpp, vp, bytes);\n\t}\n}",
        "begin_line": 44,
        "end_line": 58,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.setExtraSamples#92",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.setExtraSamples(TIFFDirectory* td, va_list ap, uint32* v)",
        "snippet": "static int\nsetExtraSamples(TIFFDirectory* td, va_list ap, uint32* v)\n{\n/* XXX: Unassociated alpha data == 999 is a known Corel Draw bug, see below */\n#define EXTRASAMPLE_COREL_UNASSALPHA 999 \n\n\tuint16* va;\n\tuint32 i;\n\n\t*v = (uint16) va_arg(ap, uint16_vap);\n\tif ((uint16) *v > td->td_samplesperpixel)\n\t\treturn 0;\n\tva = va_arg(ap, uint16*);\n\tif (*v > 0 && va == NULL)\t\t/* typically missing param */\n\t\treturn 0;\n\tfor (i = 0; i < *v; i++) {\n\t\tif (va[i] > EXTRASAMPLE_UNASSALPHA) {\n\t\t\t/*\n\t\t\t * XXX: Corel Draw is known to produce incorrect\n\t\t\t * ExtraSamples tags which must be patched here if we\n\t\t\t * want to be able to open some of the damaged TIFF\n\t\t\t * files: \n\t\t\t */\n\t\t\tif (va[i] == EXTRASAMPLE_COREL_UNASSALPHA)\n\t\t\t\tva[i] = EXTRASAMPLE_UNASSALPHA;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\ttd->td_extrasamples = (uint16) *v;\n\t_TIFFsetShortArray(&td->td_sampleinfo, va, td->td_extrasamples);\n\treturn 1;\n\n#undef EXTRASAMPLE_COREL_UNASSALPHA\n}",
        "begin_line": 92,
        "end_line": 126,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo.TIFFDataWidth#439",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo.TIFFDataWidth(TIFFDataType type)",
        "snippet": "int\nTIFFDataWidth(TIFFDataType type)\n{\n\tswitch(type)\n\t{\n\t\tcase 0:  /* nothing */\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_UNDEFINED:\n\t\t\treturn 1;\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t\treturn 2;\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_FLOAT:\n\t\tcase TIFF_IFD:\n\t\t\treturn 4;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\tcase TIFF_DOUBLE:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\tcase TIFF_IFD8:\n\t\t\treturn 8;\n\t\tdefault:\n\t\t\treturn 0; /* will return 0 for unknown types */\n\t}\n}",
        "begin_line": 439,
        "end_line": 468,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo.TIFFFieldWithTag#559",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo.TIFFFieldWithTag(TIFF* tif, uint32 tag)",
        "snippet": "const TIFFField*\nTIFFFieldWithTag(TIFF* tif, uint32 tag)\n{\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\tif (!fip) {\n\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFFieldWithTag\",\n\t\t\t     \"Internal error, unknown tag 0x%x\",\n\t\t\t     (unsigned int) tag);\n\t}\n\treturn (fip);\n}",
        "begin_line": 559,
        "end_line": 569,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo.TIFFFindField#507",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo.TIFFFindField(TIFF* tif, uint32 tag, TIFFDataType dt)",
        "snippet": "const TIFFField*\nTIFFFindField(TIFF* tif, uint32 tag, TIFFDataType dt)\n{\n\tTIFFField key = {0, 0, 0, TIFF_NOTYPE, 0, 0, 0, 0, 0, 0, NULL, NULL};\n\tTIFFField* pkey = &key;\n\tconst TIFFField **ret;\n\tif (tif->tif_foundfield && tif->tif_foundfield->field_tag == tag &&\n\t    (dt == TIFF_ANY || dt == tif->tif_foundfield->field_type))\n\t\treturn tif->tif_foundfield;\n\n\t/* If we are invoked with no field information, then just return. */\n\tif (!tif->tif_fields)\n\t\treturn NULL;\n\n\t/* NB: use sorted search (e.g. binary search) */\n\n\tkey.field_tag = tag;\n\tkey.field_type = dt;\n\n\tret = (const TIFFField **) bsearch(&pkey, tif->tif_fields,\n\t\t\t\t\t   tif->tif_nfields,\n\t\t\t\t\t   sizeof(TIFFField *), tagCompare);\n\treturn tif->tif_foundfield = (ret ? *ret : NULL);\n}",
        "begin_line": 507,
        "end_line": 530,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo._TIFFDataSize#477",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo._TIFFDataSize(TIFFDataType type)",
        "snippet": "int\n_TIFFDataSize(TIFFDataType type)\n{\n\tswitch (type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_UNDEFINED:\n\t\t    return 1;\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t    return 2;\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_FLOAT:\n\t\tcase TIFF_IFD:\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\t    return 4;\n\t\tcase TIFF_DOUBLE:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\tcase TIFF_IFD8:\n\t\t    return 8;\n\t\tdefault:\n\t\t    return 0;\n\t}\n}",
        "begin_line": 477,
        "end_line": 505,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo._TIFFGetFields#306",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo._TIFFGetFields(void)",
        "snippet": "const TIFFFieldArray*\n_TIFFGetFields(void)\n{\n\treturn(&tiffFieldArray);\n}",
        "begin_line": 306,
        "end_line": 310,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo._TIFFMergeFields#370",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo._TIFFMergeFields(TIFF* tif, const TIFFField info[], uint32 n)",
        "snippet": "int\n_TIFFMergeFields(TIFF* tif, const TIFFField info[], uint32 n)\n{\n\tstatic const char module[] = \"_TIFFMergeFields\";\n\tstatic const char reason[] = \"for fields array\";\n\t/* TIFFField** tp; */\n\tuint32 i;\n\n        tif->tif_foundfield = NULL;\n\n\tif (tif->tif_fields && tif->tif_nfields > 0) {\n\t\ttif->tif_fields = (TIFFField**)\n\t\t\t_TIFFCheckRealloc(tif, tif->tif_fields,\n\t\t\t\t\t  (tif->tif_nfields + n),\n\t\t\t\t\t  sizeof(TIFFField *), reason);\n\t} else {\n\t\ttif->tif_fields = (TIFFField **)\n\t\t\t_TIFFCheckMalloc(tif, n, sizeof(TIFFField *),\n\t\t\t\t\t reason);\n\t}\n\tif (!tif->tif_fields) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Failed to allocate fields array\");\n\t\treturn 0;\n\t}\n\n\t/* tp = tif->tif_fields + tif->tif_nfields; */\n\tfor (i = 0; i < n; i++) {\n\t\tconst TIFFField *fip =\n\t\t\tTIFFFindField(tif, info[i].field_tag, TIFF_ANY);\n\n                /* only add definitions that aren't already present */\n\t\tif (!fip) {\n                        tif->tif_fields[tif->tif_nfields] = (TIFFField *) (info+i);\n                        tif->tif_nfields++;\n                }\n\t}\n\n        /* Sort the field info by tag number */\n\tqsort(tif->tif_fields, tif->tif_nfields,\n\t      sizeof(TIFFField *), tagCompare);\n\n\treturn n;\n}",
        "begin_line": 370,
        "end_line": 413,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo._TIFFSetupFields#318",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo._TIFFSetupFields(TIFF* tif, const TIFFFieldArray* fieldarray)",
        "snippet": "void\n_TIFFSetupFields(TIFF* tif, const TIFFFieldArray* fieldarray)\n{\n\tif (tif->tif_fields && tif->tif_nfields > 0) {\n\t\tuint32 i;\n\n\t\tfor (i = 0; i < tif->tif_nfields; i++) {\n\t\t\tTIFFField *fld = tif->tif_fields[i];\n\t\t\tif (fld->field_bit == FIELD_CUSTOM &&\n\t\t\t\tstrncmp(\"Tag \", fld->field_name, 4) == 0) {\n\t\t\t\t\t_TIFFfree(fld->field_name);\n\t\t\t\t\t_TIFFfree(fld);\n\t\t\t\t}\n\t\t}\n\n\t\t_TIFFfree(tif->tif_fields);\n\t\ttif->tif_fields = NULL;\n\t\ttif->tif_nfields = 0;\n\t}\n\tif (!_TIFFMergeFields(tif, fieldarray->fields, fieldarray->count)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, \"_TIFFSetupFields\",\n\t\t\t     \"Setting up field info failed\");\n\t}\n}",
        "begin_line": 318,
        "end_line": 341,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo.tagCompare#343",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo.tagCompare(const void* a, const void* b)",
        "snippet": "static int\ntagCompare(const void* a, const void* b)\n{\n\tconst TIFFField* ta = *(const TIFFField**) a;\n\tconst TIFFField* tb = *(const TIFFField**) b;\n\t/* NB: be careful of return values for 16-bit platforms */\n\tif (ta->field_tag != tb->field_tag)\n\t\treturn (int)ta->field_tag - (int)tb->field_tag;\n\telse\n\t\treturn (ta->field_type == TIFF_ANY) ?\n\t\t\t0 : ((int)tb->field_type - (int)ta->field_type);\n}",
        "begin_line": 343,
        "end_line": 354,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFCheckDirOffset#4397",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFCheckDirOffset(TIFF* tif, uint64 diroff)",
        "snippet": "static int\nTIFFCheckDirOffset(TIFF* tif, uint64 diroff)\n{\n\tuint16 n;\n\n\tif (diroff == 0)\t\t\t/* no more directories */\n\t\treturn 0;\n\tif (tif->tif_dirnumber == 65535) {\n\t    TIFFErrorExt(tif->tif_clientdata, \"TIFFCheckDirOffset\",\n\t\t\t \"Cannot handle more than 65535 TIFF directories\");\n\t    return 0;\n\t}\n\n\tfor (n = 0; n < tif->tif_dirnumber && tif->tif_dirlist; n++) {\n\t\tif (tif->tif_dirlist[n] == diroff)\n\t\t\treturn 0;\n\t}\n\n\ttif->tif_dirnumber++;\n\n\tif (tif->tif_dirlist == NULL || tif->tif_dirnumber > tif->tif_dirlistsize) {\n\t\tuint64* new_dirlist;\n\n\t\t/*\n\t\t * XXX: Reduce memory allocation granularity of the dirlist\n\t\t * array.\n\t\t */\n\t\tnew_dirlist = (uint64*)_TIFFCheckRealloc(tif, tif->tif_dirlist,\n\t\t    tif->tif_dirnumber, 2 * sizeof(uint64), \"for IFD list\");\n\t\tif (!new_dirlist)\n\t\t\treturn 0;\n\t\tif( tif->tif_dirnumber >= 32768 )\n\t\t    tif->tif_dirlistsize = 65535;\n\t\telse\n\t\t    tif->tif_dirlistsize = 2 * tif->tif_dirnumber;\n\t\ttif->tif_dirlist = new_dirlist;\n\t}\n\n\ttif->tif_dirlist[tif->tif_dirnumber - 1] = diroff;\n\n\treturn 1;\n}",
        "begin_line": 4397,
        "end_line": 4438,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFFetchDirectory#4471",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir, uint64 *nextdiroff)",
        "snippet": "static uint16\nTIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir,\n                   uint64 *nextdiroff)\n{\n\tstatic const char module[] = \"TIFFFetchDirectory\";\n\n\tvoid* origdir;\n\tuint16 dircount16;\n\tuint32 dirsize;\n\tTIFFDirEntry* dir;\n\tuint8* ma;\n\tTIFFDirEntry* mb;\n\tuint16 n;\n\n\tassert(pdir);\n\n\ttif->tif_diroff = diroff;\n\tif (nextdiroff)\n\t\t*nextdiroff = 0;\n\tif (!isMapped(tif)) {\n\t\tif (!SeekOK(tif, tif->tif_diroff)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%s: Seek error accessing TIFF directory\",\n\t\t\t\ttif->tif_name);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tif (!ReadOK(tif, &dircount16, sizeof (uint16))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"%s: Can not read TIFF directory count\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&dircount16);\n\t\t\tif (dircount16>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdirsize = 12;\n\t\t} else {\n\t\t\tuint64 dircount64;\n\t\t\tif (!ReadOK(tif, &dircount64, sizeof (uint64))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\"%s: Can not read TIFF directory count\",\n\t\t\t\t\ttif->tif_name);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\tif (dircount64>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdircount16 = (uint16)dircount64;\n\t\t\tdirsize = 20;\n\t\t}\n\t\torigdir = _TIFFCheckMalloc(tif, dircount16,\n\t\t    dirsize, \"to read TIFF directory\");\n\t\tif (origdir == NULL)\n\t\t\treturn 0;\n\t\tif (!ReadOK(tif, origdir, (tmsize_t)(dircount16*dirsize))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%.100s: Can not read TIFF directory\",\n\t\t\t\ttif->tif_name);\n\t\t\t_TIFFfree(origdir);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Read offset to next directory for sequential scans if\n\t\t * needed.\n\t\t */\n\t\tif (nextdiroff)\n\t\t{\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t{\n\t\t\t\tuint32 nextdiroff32;\n\t\t\t\tif (!ReadOK(tif, &nextdiroff32, sizeof(uint32)))\n\t\t\t\t\tnextdiroff32 = 0;\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong(&nextdiroff32);\n\t\t\t\t*nextdiroff=nextdiroff32;\n\t\t\t} else {\n\t\t\t\tif (!ReadOK(tif, nextdiroff, sizeof(uint64)))\n\t\t\t\t\t*nextdiroff = 0;\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong8(nextdiroff);\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttmsize_t m;\n\t\ttmsize_t off = (tmsize_t) tif->tif_diroff;\n\t\tif ((uint64)off!=tif->tif_diroff)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Can not read TIFF directory count\");\n\t\t\treturn(0);\n\t\t}\n\n\t\t/*\n\t\t * Check for integer overflow when validating the dir_off,\n\t\t * otherwise a very high offset may cause an OOB read and\n\t\t * crash the client. Make two comparisons instead of\n\t\t *\n\t\t *  off + sizeof(uint16) > tif->tif_size\n\t\t *\n\t\t * to avoid overflow.\n\t\t */\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tm=off+sizeof(uint16);\n\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint16))||(m>tif->tif_size)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\"Can not read TIFF directory count\");\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t_TIFFmemcpy(&dircount16, tif->tif_base + off,\n\t\t\t\t\t    sizeof(uint16));\n\t\t\t}\n\t\t\toff += sizeof (uint16);\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&dircount16);\n\t\t\tif (dircount16>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdirsize = 12;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint64 dircount64;\n\t\t\tm=off+sizeof(uint64);\n\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint64))||(m>tif->tif_size)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\"Can not read TIFF directory count\");\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t_TIFFmemcpy(&dircount64, tif->tif_base + off,\n\t\t\t\t\t    sizeof(uint64));\n\t\t\t}\n\t\t\toff += sizeof (uint64);\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\tif (dircount64>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdircount16 = (uint16)dircount64;\n\t\t\tdirsize = 20;\n\t\t}\n\t\tif (dircount16 == 0 )\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t             \"Sanity check on directory count failed, zero tag directories not supported\");\n\t\t\treturn 0;\n\t\t}\n\t\torigdir = _TIFFCheckMalloc(tif, dircount16,\n\t\t\t\t\t\tdirsize,\n\t\t\t\t\t\t\"to read TIFF directory\");\n\t\tif (origdir == NULL)\n\t\t\treturn 0;\n\t\tm=off+dircount16*dirsize;\n\t\tif ((m<off)||(m<(tmsize_t)(dircount16*dirsize))||(m>tif->tif_size)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"Can not read TIFF directory\");\n\t\t\t_TIFFfree(origdir);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t_TIFFmemcpy(origdir, tif->tif_base + off,\n\t\t\t\t    dircount16 * dirsize);\n\t\t}\n\t\tif (nextdiroff) {\n\t\t\toff += dircount16 * dirsize;\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t{\n\t\t\t\tuint32 nextdiroff32;\n\t\t\t\tm=off+sizeof(uint32);\n\t\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint32))||(m>tif->tif_size))\n\t\t\t\t\tnextdiroff32 = 0;\n\t\t\t\telse\n\t\t\t\t\t_TIFFmemcpy(&nextdiroff32, tif->tif_base + off,\n\t\t\t\t\t\t    sizeof (uint32));\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong(&nextdiroff32);\n\t\t\t\t*nextdiroff = nextdiroff32;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm=off+sizeof(uint64);\n\t\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint64))||(m>tif->tif_size))\n\t\t\t\t\t*nextdiroff = 0;\n\t\t\t\telse\n\t\t\t\t\t_TIFFmemcpy(nextdiroff, tif->tif_base + off,\n\t\t\t\t\t\t    sizeof (uint64));\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong8(nextdiroff);\n\t\t\t}\n\t\t}\n\t}\n\tdir = (TIFFDirEntry*)_TIFFCheckMalloc(tif, dircount16,\n\t\t\t\t\t\tsizeof(TIFFDirEntry),\n\t\t\t\t\t\t\"to read TIFF directory\");\n\tif (dir==0)\n\t{\n\t\t_TIFFfree(origdir);\n\t\treturn 0;\n\t}\n\tma=(uint8*)origdir;\n\tmb=dir;\n\tfor (n=0; n<dircount16; n++)\n\t{\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabShort((uint16*)ma);\n\t\tmb->tdir_tag=*(uint16*)ma;\n\t\tma+=sizeof(uint16);\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabShort((uint16*)ma);\n\t\tmb->tdir_type=*(uint16*)ma;\n\t\tma+=sizeof(uint16);\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\tmb->tdir_count=(uint64)(*(uint32*)ma);\n\t\t\tma+=sizeof(uint32);\n\t\t\t*(uint32*)(&mb->tdir_offset)=*(uint32*)ma;\n\t\t\tma+=sizeof(uint32);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8((uint64*)ma);\n                        mb->tdir_count=TIFFReadUInt64(ma);\n\t\t\tma+=sizeof(uint64);\n\t\t\tmb->tdir_offset.toff_long8=TIFFReadUInt64(ma);\n\t\t\tma+=sizeof(uint64);\n\t\t}\n\t\tmb++;\n\t}\n\t_TIFFfree(origdir);\n\t*pdir = dir;\n\treturn dircount16;\n}",
        "begin_line": 4471,
        "end_line": 4721,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFFetchNormalTag#4726",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)",
        "snippet": "static int\nTIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)\n{\n\tstatic const char module[] = \"TIFFFetchNormalTag\";\n\tenum TIFFReadDirEntryErr err;\n\tuint32 fii;\n\tconst TIFFField* fip = NULL;\n\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n        if( fii == FAILED_FII )\n        {\n            TIFFErrorExt(tif->tif_clientdata, \"TIFFFetchNormalTag\",\n                         \"No definition found for tag %d\",\n                         dp->tdir_tag);\n            return 0;\n        }\n\tfip=tif->tif_fields[fii];\n\tassert(fip != NULL); /* should not happen */\n\tassert(fip->set_field_type!=TIFF_SETGET_OTHER);  /* if so, we shouldn't arrive here but deal with this in specialized code */\n\tassert(fip->set_field_type!=TIFF_SETGET_INT);    /* if so, we shouldn't arrive here as this is only the case for pseudo-tags */\n\terr=TIFFReadDirEntryErrOk;\n\tswitch (fip->set_field_type)\n\t{\n\t\tcase TIFF_SETGET_UNDEFINED:\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_ASCII:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tuint8* ma;\n\t\t\t\t\tuint32 mb;\n\t\t\t\t\tint n;\n\t\t\t\t\tma=data;\n\t\t\t\t\tmb=0;\n\t\t\t\t\twhile (mb<(uint32)dp->tdir_count)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (*ma==0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tma++;\n\t\t\t\t\t\tmb++;\n\t\t\t\t\t}\n\t\t\t\t\tif (mb+1<(uint32)dp->tdir_count)\n\t\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" contains null byte in value; value incorrectly truncated during reading due to implementation limitations\",fip->field_name);\n\t\t\t\t\telse if (mb+1>(uint32)dp->tdir_count)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8* o;\n\t\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" does not end in null byte\",fip->field_name);\n\t\t\t\t\t\tif ((uint32)dp->tdir_count+1!=dp->tdir_count+1)\n\t\t\t\t\t\t\to=NULL;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\to=_TIFFmalloc((uint32)dp->tdir_count+1);\n\t\t\t\t\t\tif (o==NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (data!=NULL)\n\t\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_TIFFmemcpy(o,data,(uint32)dp->tdir_count);\n\t\t\t\t\t\to[(uint32)dp->tdir_count]=0;\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tdata=o;\n\t\t\t\t\t}\n\t\t\t\t\tn=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!n)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT8:\n\t\t\t{\n\t\t\t\tuint8 data=0;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryByte(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT16:\n\t\t\t{\n\t\t\t\tuint16 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryShort(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT32:\n\t\t\t{\n\t\t\t\tuint32 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryLong(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT64:\n\t\t\t{\n\t\t\t\tuint64 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryLong8(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_FLOAT:\n\t\t\t{\n\t\t\t\tfloat data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryFloat(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_DOUBLE:\n\t\t\t{\n\t\t\t\tdouble data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryDouble(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_IFD8:\n\t\t\t{\n\t\t\t\tuint64 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryIfd8(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT16_PAIR:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount==2);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=2) {\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t\t\t       \"incorrect count for field \\\"%s\\\", expected 2, got %d\",\n\t\t\t\t\t\t       fip->field_name,(int)dp->tdir_count);\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data[0],data[1]);\n\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_UINT8:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount) {\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t\t\t       \"incorrect count for field \\\"%s\\\", expected %d, got %d\",\n\t\t\t\t\t\t       fip->field_name,(int) fip->field_readcount, (int)dp->tdir_count);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_UINT16:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)\n                                    /* corrupt file */;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_UINT32:\n\t\t\t{\n\t\t\t\tuint32* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)\n                                    /* corrupt file */;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_FLOAT:\n\t\t\t{\n\t\t\t\tfloat* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)\n                                    /* corrupt file */;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_ASCII:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n                        if( dp->tdir_count > 0 && data[dp->tdir_count-1] != '\\0' )\n                        {\n                            TIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" does not end in null byte. Forcing it to be null\",fip->field_name);\n                            data[dp->tdir_count-1] = '\\0';\n                        }\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT8:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT16:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT32:\n\t\t\t{\n\t\t\t\tuint32* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT64:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryLong8Array(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_FLOAT:\n\t\t\t{\n\t\t\t\tfloat* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_DOUBLE:\n\t\t\t{\n\t\t\t\tdouble* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryDoubleArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_IFD8:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryIfd8Array(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_ASCII:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n                    if( dp->tdir_count > 0 && data[dp->tdir_count-1] != '\\0' )\n                    {\n                        TIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" does not end in null byte. Forcing it to be null\",fip->field_name);\n                        data[dp->tdir_count-1] = '\\0';\n                    }\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT8:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT8:\n\t\t\t{\n\t\t\t\tint8* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySbyteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT16:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT16:\n\t\t\t{\n\t\t\t\tint16* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySshortArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT32:\n\t\t\t{\n\t\t\t\tuint32* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT32:\n\t\t\t{\n\t\t\t\tint32* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySlongArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT64:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryLong8Array(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT64:\n\t\t\t{\n\t\t\t\tint64* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySlong8Array(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_FLOAT:\n\t\t\t{\n\t\t\t\tfloat* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_DOUBLE:\n\t\t\t{\n\t\t\t\tdouble* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryDoubleArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_IFD8:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryIfd8Array(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);    /* we should never get here */\n\t\t\tbreak;\n\t}\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip->field_name,recover);\n\t\treturn(0);\n\t}\n\treturn(1);\n}",
        "begin_line": 4726,
        "end_line": 5404,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFFetchStripThing#5410",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32 nstrips, uint64** lpp)",
        "snippet": "static int\nTIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32 nstrips, uint64** lpp)\n{\n\tstatic const char module[] = \"TIFFFetchStripThing\";\n\tenum TIFFReadDirEntryErr err;\n\tuint64* data;\n\terr=TIFFReadDirEntryLong8Array(tif,dir,&data);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\tconst TIFFField* fip = TIFFFieldWithTag(tif,dir->tdir_tag); \n\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",0);\n\t\treturn(0);\n\t}\n\tif (dir->tdir_count!=(uint64)nstrips)\n\t{\n\t\tuint64* resizeddata;\n\t\tresizeddata=(uint64*)_TIFFCheckMalloc(tif,nstrips,sizeof(uint64),\"for strip array\");\n\t\tif (resizeddata==0) {\n\t\t\t_TIFFfree(data);\n\t\t\treturn(0);\n\t\t}\n\t\tif (dir->tdir_count<(uint64)nstrips)\n\t\t{\n\t\t\t_TIFFmemcpy(resizeddata,data,(uint32)dir->tdir_count*sizeof(uint64));\n\t\t\t_TIFFmemset(resizeddata+(uint32)dir->tdir_count,0,(nstrips-(uint32)dir->tdir_count)*sizeof(uint64));\n\t\t}\n\t\telse\n\t\t\t_TIFFmemcpy(resizeddata,data,nstrips*sizeof(uint64));\n\t\t_TIFFfree(data);\n\t\tdata=resizeddata;\n\t}\n\t*lpp=data;\n\treturn(1);\n}",
        "begin_line": 5410,
        "end_line": 5443,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryArray#768",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryArray(TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize, void** value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryArray(TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize, void** value)\n{\n\tint typesize;\n\tuint32 datasize;\n\tvoid* data;\n\ttypesize=TIFFDataWidth(direntry->tdir_type);\n\tif ((direntry->tdir_count==0)||(typesize==0))\n\t{\n\t\t*value=0;\n\t\treturn(TIFFReadDirEntryErrOk);\n\t}\n        (void) desttypesize;\n\n        /* \n         * As a sanity check, make sure we have no more than a 2GB tag array \n         * in either the current data type or the dest data type.  This also\n         * avoids problems with overflow of tmsize_t on 32bit systems.\n         */\n\tif ((uint64)(2147483647/typesize)<direntry->tdir_count)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\tif ((uint64)(2147483647/desttypesize)<direntry->tdir_count)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\n\t*count=(uint32)direntry->tdir_count;\n\tdatasize=(*count)*typesize;\n\tassert((tmsize_t)datasize>0);\n\tdata=_TIFFCheckMalloc(tif, *count, typesize, \"ReadDirEntryArray\");\n\tif (data==0)\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tif (datasize<=4)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint32 offset = direntry->tdir_offset.toff_long;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&offset);\n\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (datasize<=8)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint64 offset = direntry->tdir_offset.toff_long8;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&offset);\n\t\t\terr=TIFFReadDirEntryData(tif,offset,(tmsize_t)datasize,data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 768,
        "end_line": 835,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryByte#200",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryByte(TIFF* tif, TIFFDirEntry* direntry, uint8* value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryByte(TIFF* tif, TIFFDirEntry* direntry, uint8* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tif (direntry->tdir_count!=1)\n\t\treturn(TIFFReadDirEntryErrCount);\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\tTIFFReadDirEntryCheckedByte(tif,direntry,value);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedSbyte(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSbyte(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint8)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedShort(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeByteShort(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint8)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedSshort(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSshort(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint8)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedLong(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeByteLong(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint8)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedSlong(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSlong(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint8)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeByteLong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint8)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSlong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint8)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n}",
        "begin_line": 200,
        "end_line": 287,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryByteArray#837",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntry* direntry, uint8** value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntry* direntry, uint8** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tuint8* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_UNDEFINED:\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,1,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_UNDEFINED:\n\t\tcase TIFF_BYTE:\n\t\t\t*value=(uint8*)origdata;\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8* m;\n\t\t\t\tuint32 n;\n\t\t\t\tm=(int8*)origdata;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSbyte(*m);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\t_TIFFfree(origdata);\n\t\t\t\t\t\treturn(err);\n\t\t\t\t\t}\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t\t*value=(uint8*)origdata;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t}\n\tdata=(uint8*)_TIFFmalloc(count);\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteShort(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort((uint16*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSshort(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteLong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSlong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteLong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8((uint64*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSlong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\t_TIFFfree(data);\n\t\treturn(err);\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 837,
        "end_line": 1016,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryCheckRangeByteShort#2974",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryCheckRangeByteShort(uint16 value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteShort(uint16 value)\n{\n\tif (value>0xFF)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 2974,
        "end_line": 2980,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryCheckedFloat#2924",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryCheckedFloat(TIFF* tif, TIFFDirEntry* direntry, float* value)",
        "snippet": "static void TIFFReadDirEntryCheckedFloat(TIFF* tif, TIFFDirEntry* direntry, float* value)\n{\n         union\n\t {\n\t   float  f;\n\t   uint32 i;\n\t } float_union;\n\tassert(sizeof(float)==4);\n\tassert(sizeof(uint32)==4);\n\tassert(sizeof(float_union)==4);\n\tfloat_union.i=*(uint32*)(&direntry->tdir_offset);\n\t*value=float_union.f;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabLong((uint32*)value);\n}",
        "begin_line": 2924,
        "end_line": 2938,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryCheckedRational#2862",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryCheckedRational(TIFF* tif, TIFFDirEntry* direntry, double* value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedRational(TIFF* tif, TIFFDirEntry* direntry, double* value)\n{\n\tUInt64Aligned_t m;\n\n\tassert(sizeof(double)==8);\n\tassert(sizeof(uint64)==8);\n\tassert(sizeof(uint32)==4);\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tenum TIFFReadDirEntryErr err;\n\t\tuint32 offset = direntry->tdir_offset.toff_long;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong(&offset);\n\t\terr=TIFFReadDirEntryData(tif,offset,8,m.i);\n\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\treturn(err);\n\t}\n\telse\n\t\tm.l = direntry->tdir_offset.toff_long8;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfLong(m.i,2);\n        /* Not completely sure what we should do when m.i[1]==0, but some */\n        /* sanitizers do not like division by 0.0: */\n        /* http://bugzilla.maptools.org/show_bug.cgi?id=2644 */\n\tif (m.i[0]==0 || m.i[1]==0)\n\t\t*value=0.0;\n\telse\n\t\t*value=(double)m.i[0]/(double)m.i[1];\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 2862,
        "end_line": 2891,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryCheckedShort#2795",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryCheckedShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)",
        "snippet": "static void TIFFReadDirEntryCheckedShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)\n{\n\t*value = direntry->tdir_offset.toff_short;\n\t/* *value=*(uint16*)(&direntry->tdir_offset); */\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabShort(value);\n}",
        "begin_line": 2795,
        "end_line": 2801,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryData#3296",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryData(TIFF* tif, uint64 offset, tmsize_t size, void* dest)",
        "snippet": "static enum TIFFReadDirEntryErr\nTIFFReadDirEntryData(TIFF* tif, uint64 offset, tmsize_t size, void* dest)\n{\n\tassert(size>0);\n\tif (!isMapped(tif)) {\n\t\tif (!SeekOK(tif,offset))\n\t\t\treturn(TIFFReadDirEntryErrIo);\n\t\tif (!ReadOK(tif,dest,size))\n\t\t\treturn(TIFFReadDirEntryErrIo);\n\t} else {\n\t\tsize_t ma,mb;\n\t\tma=(size_t)offset;\n\t\tmb=ma+size;\n\t\tif (((uint64)ma!=offset)\n\t\t    || (mb < ma)\n\t\t    || (mb - ma != (size_t) size)\n\t\t    || (mb < (size_t)size)\n\t\t    || (mb > (size_t)tif->tif_size)\n\t\t    )\n\t\t\treturn(TIFFReadDirEntryErrIo);\n\t\t_TIFFmemcpy(dest,tif->tif_base+ma,size);\n\t}\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 3296,
        "end_line": 3319,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryDouble#647",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryDouble(TIFF* tif, TIFFDirEntry* direntry, double* value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryDouble(TIFF* tif, TIFFDirEntry* direntry, double* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tif (direntry->tdir_count!=1)\n\t\treturn(TIFFReadDirEntryErrCount);\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedByte(tif,direntry,&m);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedSbyte(tif,direntry,&m);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedShort(tif,direntry,&m);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedSshort(tif,direntry,&m);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedLong(tif,direntry,&m);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedSlong(tif,direntry,&m);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n#if defined(__WIN32__) && (_MSC_VER < 1500)\n\t\t\t\t/*\n\t\t\t\t * XXX: MSVC 6.0 does not support conversion\n\t\t\t\t * of 64-bit integers into floating point\n\t\t\t\t * values.\n\t\t\t\t */\n\t\t\t\t*value = _TIFFUInt64ToDouble(m);\n#else\n\t\t\t\t*value = (double)m;\n#endif\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_RATIONAL:\n\t\t\terr=TIFFReadDirEntryCheckedRational(tif,direntry,value);\n\t\t\treturn(err);\n\t\tcase TIFF_SRATIONAL:\n\t\t\terr=TIFFReadDirEntryCheckedSrational(tif,direntry,value);\n\t\t\treturn(err);\n\t\tcase TIFF_FLOAT:\n\t\t\t{\n\t\t\t\tfloat m;\n\t\t\t\tTIFFReadDirEntryCheckedFloat(tif,direntry,&m);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_DOUBLE:\n\t\t\terr=TIFFReadDirEntryCheckedDouble(tif,direntry,value);\n\t\t\treturn(err);\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n}",
        "begin_line": 647,
        "end_line": 742,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryLong#375",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryLong(TIFF* tif, TIFFDirEntry* direntry, uint32* value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryLong(TIFF* tif, TIFFDirEntry* direntry, uint32* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tif (direntry->tdir_count!=1)\n\t\treturn(TIFFReadDirEntryErrCount);\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedByte(tif,direntry,&m);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedSbyte(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSbyte(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedShort(tif,direntry,&m);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedSshort(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSshort(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG:\n\t\t\tTIFFReadDirEntryCheckedLong(tif,direntry,value);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedSlong(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSlong(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongLong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSlong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n}",
        "begin_line": 375,
        "end_line": 456,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryLong8Array#1866",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tuint64* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,8,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_LONG8:\n\t\t\t*value=(uint64*)origdata;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabArrayOfLong8(*value,count);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64* m;\n\t\t\t\tuint32 n;\n\t\t\t\tm=(int64*)origdata;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8((uint64*)m);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Slong8(*m);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\t_TIFFfree(origdata);\n\t\t\t\t\t\treturn(err);\n\t\t\t\t\t}\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t\t*value=(uint64*)origdata;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t}\n\tdata=(uint64*)_TIFFmalloc(count*8);\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Sbyte(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort(ma);\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort((uint16*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Sshort(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Slong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\t_TIFFfree(data);\n\t\treturn(err);\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 1866,
        "end_line": 2030,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryOutputErr#3321",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryOutputErr(TIFF* tif, enum TIFFReadDirEntryErr err, const char* module, const char* tagname, int recover)",
        "snippet": "static void TIFFReadDirEntryOutputErr(TIFF* tif, enum TIFFReadDirEntryErr err, const char* module, const char* tagname, int recover)\n{\n\tif (!recover) {\n\t\tswitch (err) {\n\t\t\tcase TIFFReadDirEntryErrCount:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Incorrect count for \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrType:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Incompatible type for \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrIo:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"IO error during reading of \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrRange:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Incorrect value for \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrPsdif:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"Cannot handle different values per sample for \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrSizesan:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"Sanity check on size of \\\"%s\\\" value failed\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrAlloc:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Out of memory reading of \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);   /* we should never get here */\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (err) {\n\t\t\tcase TIFFReadDirEntryErrCount:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"Incorrect count for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrType:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"Incompatible type for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrIo:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\"IO error during reading of \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrRange:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"Incorrect value for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrPsdif:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\"Cannot handle different values per sample for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrSizesan:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\"Sanity check on size of \\\"%s\\\" value failed; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrAlloc:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"Out of memory reading of \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);   /* we should never get here */\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
        "begin_line": 3321,
        "end_line": 3406,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryPersampleShort#2725",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryPersampleShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryPersampleShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint16* m;\n\tuint16* na;\n\tuint16 nb;\n\tif (direntry->tdir_count<(uint64)tif->tif_dir.td_samplesperpixel)\n\t\treturn(TIFFReadDirEntryErrCount);\n\terr=TIFFReadDirEntryShortArray(tif,direntry,&m);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t\treturn(err);\n\tna=m;\n\tnb=tif->tif_dir.td_samplesperpixel;\n\t*value=*na++;\n\tnb--;\n\twhile (nb>0)\n\t{\n\t\tif (*na++!=*value)\n\t\t{\n\t\t\terr=TIFFReadDirEntryErrPsdif;\n\t\t\tbreak;\n\t\t}\n\t\tnb--;\n\t}\n\t_TIFFfree(m);\n\treturn(err);\n}",
        "begin_line": 2725,
        "end_line": 2751,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryShort#289",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tif (direntry->tdir_count!=1)\n\t\treturn(TIFFReadDirEntryErrCount);\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedByte(tif,direntry,&m);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedSbyte(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSbyte(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SHORT:\n\t\t\tTIFFReadDirEntryCheckedShort(tif,direntry,value);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedSshort(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSshort(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedLong(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortLong(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedSlong(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSlong(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortLong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSlong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n}",
        "begin_line": 289,
        "end_line": 373,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryShortArray#1197",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryShortArray(TIFF* tif, TIFFDirEntry* direntry, uint16** value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryShortArray(TIFF* tif, TIFFDirEntry* direntry, uint16** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tuint16* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,2,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_SHORT:\n\t\t\t*value=(uint16*)origdata;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabArrayOfShort(*value,count);  \n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16* m;\n\t\t\t\tuint32 n;\n\t\t\t\tm=(int16*)origdata;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort((uint16*)m);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSshort(*m);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\t_TIFFfree(origdata);\n\t\t\t\t\t\treturn(err);\n\t\t\t\t\t}\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t\t*value=(uint16*)origdata;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t}\n\tdata=(uint16*)_TIFFmalloc(count*2);\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSbyte(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortLong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSlong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortLong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8((uint64*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSlong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\t_TIFFfree(data);\n\t\treturn(err);\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 1197,
        "end_line": 1367,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirectory#3412",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirectory(TIFF* tif)",
        "snippet": "int\nTIFFReadDirectory(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFReadDirectory\";\n\tTIFFDirEntry* dir;\n\tuint16 dircount;\n\tTIFFDirEntry* dp;\n\tuint16 di;\n\tconst TIFFField* fip;\n\tuint32 fii=FAILED_FII;\n        toff_t nextdiroff;\n    int bitspersample_read = FALSE;\n\n\ttif->tif_diroff=tif->tif_nextdiroff;\n\tif (!TIFFCheckDirOffset(tif,tif->tif_nextdiroff))\n\t\treturn 0;           /* last offset or bad offset (IFD looping) */\n\t(*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */\n\ttif->tif_curdir++;\n        nextdiroff = tif->tif_nextdiroff;\n\tdircount=TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff);\n\tif (!dircount)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"Failed to read directory at offset \" TIFF_UINT64_FORMAT,nextdiroff);\n\t\treturn 0;\n\t}\n\tTIFFReadDirectoryCheckOrder(tif,dir,dircount);\n\n        /*\n         * Mark duplicates of any tag to be ignored (bugzilla 1994)\n         * to avoid certain pathological problems.\n         */\n\t{\n\t\tTIFFDirEntry* ma;\n\t\tuint16 mb;\n\t\tfor (ma=dir, mb=0; mb<dircount; ma++, mb++)\n\t\t{\n\t\t\tTIFFDirEntry* na;\n\t\t\tuint16 nb;\n\t\t\tfor (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)\n\t\t\t{\n\t\t\t\tif (ma->tdir_tag==na->tdir_tag)\n\t\t\t\t\tna->tdir_tag=IGNORE;\n\t\t\t}\n\t\t}\n\t}\n        \n\ttif->tif_flags &= ~TIFF_BEENWRITING;    /* reset before new dir */\n\ttif->tif_flags &= ~TIFF_BUF4WRITE;      /* reset before new dir */\n\t/* free any old stuff and reinit */\n\tTIFFFreeDirectory(tif);\n\tTIFFDefaultDirectory(tif);\n\t/*\n\t * Electronic Arts writes gray-scale TIFF files\n\t * without a PlanarConfiguration directory entry.\n\t * Thus we setup a default value here, even though\n\t * the TIFF spec says there is no default value.\n\t */\n\tTIFFSetField(tif,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n\t/*\n\t * Setup default value and then make a pass over\n\t * the fields to check type and tag information,\n\t * and to extract info required to size data\n\t * structures.  A second pass is made afterwards\n\t * to read in everything not taken in the first pass.\n\t * But we must process the Compression tag first\n\t * in order to merge in codec-private tag definitions (otherwise\n\t * we may get complaints about unknown tags).  However, the\n\t * Compression tag may be dependent on the SamplesPerPixel\n\t * tag value because older TIFF specs permitted Compression\n\t * to be written as a SamplesPerPixel-count tag entry.\n\t * Thus if we don't first figure out the correct SamplesPerPixel\n\t * tag value then we may end up ignoring the Compression tag\n\t * value because it has an incorrect count value (if the\n\t * true value of SamplesPerPixel is not 1).\n\t */\n\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_SAMPLESPERPIXEL);\n\tif (dp)\n\t{\n\t\tif (!TIFFFetchNormalTag(tif,dp,0))\n\t\t\tgoto bad;\n\t\tdp->tdir_tag=IGNORE;\n\t}\n\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_COMPRESSION);\n\tif (dp)\n\t{\n\t\t/*\n\t\t * The 5.0 spec says the Compression tag has one value, while\n\t\t * earlier specs say it has one value per sample.  Because of\n\t\t * this, we accept the tag if one value is supplied with either\n\t\t * count.\n\t\t */\n\t\tuint16 value;\n\t\tenum TIFFReadDirEntryErr err;\n\t\terr=TIFFReadDirEntryShort(tif,dp,&value);\n\t\tif (err==TIFFReadDirEntryErrCount)\n\t\t\terr=TIFFReadDirEntryPersampleShort(tif,dp,&value);\n\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t{\n\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,\"Compression\",0);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (!TIFFSetField(tif,TIFFTAG_COMPRESSION,value))\n\t\t\tgoto bad;\n\t\tdp->tdir_tag=IGNORE;\n\t}\n\telse\n\t{\n\t\tif (!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE))\n\t\t\tgoto bad;\n\t}\n\t/*\n\t * First real pass over the directory.\n\t */\n\tfor (di=0, dp=dir; di<dircount; di++, dp++)\n\t{\n\t\tif (dp->tdir_tag!=IGNORE)\n\t\t{\n\t\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\t\tif (fii == FAILED_FII)\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Unknown field with tag %d (0x%x) encountered\",\n\t\t\t\t    dp->tdir_tag,dp->tdir_tag);\n                                /* the following knowingly leaks the \n                                   anonymous field structure */\n\t\t\t\tif (!_TIFFMergeFields(tif,\n\t\t\t\t\t_TIFFCreateAnonField(tif,\n\t\t\t\t\t\tdp->tdir_tag,\n\t\t\t\t\t\t(TIFFDataType) dp->tdir_type),\n\t\t\t\t\t1)) {\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t    module,\n\t\t\t\t\t    \"Registering anonymous field with tag %d (0x%x) failed\",\n\t\t\t\t\t    dp->tdir_tag,\n\t\t\t\t\t    dp->tdir_tag);\n\t\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\t\t} else {\n\t\t\t\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\t\t\t\tassert(fii != FAILED_FII);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dp->tdir_tag!=IGNORE)\n\t\t{\n\t\t\tfip=tif->tif_fields[fii];\n\t\t\tif (fip->field_bit==FIELD_IGNORE)\n\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tswitch (dp->tdir_tag)\n\t\t\t\t{\n\t\t\t\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\t\t\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\t\t\t\tcase TIFFTAG_TILEOFFSETS:\n\t\t\t\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\t\t\t\t\tTIFFSetFieldBit(tif,fip->field_bit);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TIFFTAG_IMAGEWIDTH:\n\t\t\t\t\tcase TIFFTAG_IMAGELENGTH:\n\t\t\t\t\tcase TIFFTAG_IMAGEDEPTH:\n\t\t\t\t\tcase TIFFTAG_TILELENGTH:\n\t\t\t\t\tcase TIFFTAG_TILEWIDTH:\n\t\t\t\t\tcase TIFFTAG_TILEDEPTH:\n\t\t\t\t\tcase TIFFTAG_PLANARCONFIG:\n\t\t\t\t\tcase TIFFTAG_ROWSPERSTRIP:\n\t\t\t\t\tcase TIFFTAG_EXTRASAMPLES:\n\t\t\t\t\t\tif (!TIFFFetchNormalTag(tif,dp,0))\n\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * XXX: OJPEG hack.\n\t * If a) compression is OJPEG, b) planarconfig tag says it's separate,\n\t * c) strip offsets/bytecounts tag are both present and\n\t * d) both contain exactly one value, then we consistently find\n\t * that the buggy implementation of the buggy compression scheme\n\t * matches contig planarconfig best. So we 'fix-up' the tag here\n\t */\n\tif ((tif->tif_dir.td_compression==COMPRESSION_OJPEG)&&\n\t    (tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE))\n\t{\n        if (!_TIFFFillStriles(tif))\n            goto bad;\n\t\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS);\n\t\tif ((dp!=0)&&(dp->tdir_count==1))\n\t\t{\n\t\t\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,\n\t\t\t    TIFFTAG_STRIPBYTECOUNTS);\n\t\t\tif ((dp!=0)&&(dp->tdir_count==1))\n\t\t\t{\n\t\t\t\ttif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t    \"Planarconfig tag value assumed incorrect, \"\n\t\t\t\t    \"assuming data is contig instead of chunky\");\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Allocate directory structure and setup defaults.\n\t */\n\tif (!TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))\n\t{\n\t\tMissingRequired(tif,\"ImageLength\");\n\t\tgoto bad;\n\t}\n\t/*\n\t * Setup appropriate structures (by strip or by tile)\n\t */\n\tif (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {\n\t\ttif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif);  \n\t\ttif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;\n\t\ttif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;\n\t\ttif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;\n\t\ttif->tif_flags &= ~TIFF_ISTILED;\n\t} else {\n\t\ttif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);\n\t\ttif->tif_flags |= TIFF_ISTILED;\n\t}\n\tif (!tif->tif_dir.td_nstrips) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Cannot handle zero number of %s\",\n\t\t    isTiled(tif) ? \"tiles\" : \"strips\");\n\t\tgoto bad;\n\t}\n\ttif->tif_dir.td_stripsperimage = tif->tif_dir.td_nstrips;\n\tif (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\ttif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel;\n\tif (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {\n#ifdef OJPEG_SUPPORT\n\t\tif ((tif->tif_dir.td_compression==COMPRESSION_OJPEG) &&\n\t\t    (isTiled(tif)==0) &&\n\t\t    (tif->tif_dir.td_nstrips==1)) {\n\t\t\t/*\n\t\t\t * XXX: OJPEG hack.\n\t\t\t * If a) compression is OJPEG, b) it's not a tiled TIFF,\n\t\t\t * and c) the number of strips is 1,\n\t\t\t * then we tolerate the absence of stripoffsets tag,\n\t\t\t * because, presumably, all required data is in the\n\t\t\t * JpegInterchangeFormat stream.\n\t\t\t */\n\t\t\tTIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);\n\t\t} else\n#endif\n        {\n\t\t\tMissingRequired(tif,\n\t\t\t\tisTiled(tif) ? \"TileOffsets\" : \"StripOffsets\");\n\t\t\tgoto bad;\n\t\t}\n\t}\n\t/*\n\t * Second pass: extract other information.\n\t */\n\tfor (di=0, dp=dir; di<dircount; di++, dp++)\n\t{\n\t\tswitch (dp->tdir_tag)\n\t\t{\n\t\t\tcase IGNORE:\n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\t\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\t\tcase TIFFTAG_BITSPERSAMPLE:\n\t\t\tcase TIFFTAG_DATATYPE:\n\t\t\tcase TIFFTAG_SAMPLEFORMAT:\n\t\t\t\t/*\n\t\t\t\t * The MinSampleValue, MaxSampleValue, BitsPerSample\n\t\t\t\t * DataType and SampleFormat tags are supposed to be\n\t\t\t\t * written as one value/sample, but some vendors\n\t\t\t\t * incorrectly write one value only -- so we accept\n\t\t\t\t * that as well (yuck). Other vendors write correct\n\t\t\t\t * value for NumberOfSamples, but incorrect one for\n\t\t\t\t * BitsPerSample and friends, and we will read this\n\t\t\t\t * too.\n\t\t\t\t */\n\t\t\t\t{\n\t\t\t\t\tuint16 value;\n\t\t\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\t\t\terr=TIFFReadDirEntryShort(tif,dp,&value);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrCount)\n\t\t\t\t\t\terr=TIFFReadDirEntryPersampleShort(tif,dp,&value);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tfip = TIFFFieldWithTag(tif,dp->tdir_tag);\n\t\t\t\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",0);\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t}\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,value))\n\t\t\t\t\t\tgoto bad;\n                    if( dp->tdir_tag == TIFFTAG_BITSPERSAMPLE )\n                        bitspersample_read = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\t\t\t{\n\n\t\t\t\t\tdouble *data = NULL;\n\t\t\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\t\t\tuint32 saved_flags;\n\t\t\t\t\tint m;\n\t\t\t\t\tif (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)\n\t\t\t\t\t\terr = TIFFReadDirEntryErrCount;\n\t\t\t\t\telse\n\t\t\t\t\t\terr = TIFFReadDirEntryDoubleArray(tif, dp, &data);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tfip = TIFFFieldWithTag(tif,dp->tdir_tag);\n\t\t\t\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",0);\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t}\n\t\t\t\t\tsaved_flags = tif->tif_flags;\n\t\t\t\t\ttif->tif_flags |= TIFF_PERSAMPLE;\n\t\t\t\t\tm = TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\ttif->tif_flags = saved_flags;\n\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\t\tcase TIFFTAG_TILEOFFSETS:\n#if defined(DEFER_STRILE_LOAD)\n                                _TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),\n                                             dp, sizeof(TIFFDirEntry) );\n#else                          \n\t\t\t\tif (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset))  \n\t\t\t\t\tgoto bad;\n#endif                                \n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\t\tcase TIFFTAG_TILEBYTECOUNTS:\n#if defined(DEFER_STRILE_LOAD)\n                                _TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),\n                                             dp, sizeof(TIFFDirEntry) );\n#else                          \n\t\t\t\tif (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount))  \n\t\t\t\t\tgoto bad;\n#endif                                \n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_COLORMAP:\n\t\t\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\t\t\t{\n\t\t\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\t\t\tuint32 countpersample;\n\t\t\t\t\tuint32 countrequired;\n\t\t\t\t\tuint32 incrementpersample;\n\t\t\t\t\tuint16* value=NULL;\n                    /* It would be dangerous to instantiate those tag values */\n                    /* since if td_bitspersample has not yet been read (due to */\n                    /* unordered tags), it could be read afterwards with a */\n                    /* values greater than the default one (1), which may cause */\n                    /* crashes in user code */\n                    if( !bitspersample_read )\n                    {\n                        fip = TIFFFieldWithTag(tif,dp->tdir_tag);\n                        TIFFWarningExt(tif->tif_clientdata,module,\n                                       \"Ignoring %s since BitsPerSample tag not found\",\n                                       fip ? fip->field_name : \"unknown tagname\");\n                        continue;\n                    }\n\t\t\t\t\t/* ColorMap or TransferFunction for high bit */\n\t\t\t\t\t/* depths do not make much sense and could be */\n\t\t\t\t\t/* used as a denial of service vector */\n\t\t\t\t\tif (tif->tif_dir.td_bitspersample > 24)\n\t\t\t\t\t{\n\t\t\t\t\t    fip = TIFFFieldWithTag(tif,dp->tdir_tag);\n\t\t\t\t\t    TIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t\t\t\"Ignoring %s because BitsPerSample=%d>24\",\n\t\t\t\t\t\tfip ? fip->field_name : \"unknown tagname\",\n\t\t\t\t\t\ttif->tif_dir.td_bitspersample);\n\t\t\t\t\t    continue;\n\t\t\t\t\t}\n\t\t\t\t\tcountpersample=(1U<<tif->tif_dir.td_bitspersample);\n\t\t\t\t\tif ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))\n\t\t\t\t\t{\n\t\t\t\t\t\tcountrequired=countpersample;\n\t\t\t\t\t\tincrementpersample=0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcountrequired=3*countpersample;\n\t\t\t\t\t\tincrementpersample=countpersample;\n\t\t\t\t\t}\n\t\t\t\t\tif (dp->tdir_count!=(uint64)countrequired)\n\t\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\t\telse\n\t\t\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&value);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n                    {\n\t\t\t\t\t\tfip = TIFFFieldWithTag(tif,dp->tdir_tag);\n\t\t\t\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",1);\n                    }\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tTIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);\n\t\t\t\t\t\t_TIFFfree(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n/* BEGIN REV 4.0 COMPATIBILITY */\n\t\t\tcase TIFFTAG_OSUBFILETYPE:\n\t\t\t\t{\n\t\t\t\t\tuint16 valueo;\n\t\t\t\t\tuint32 value;\n\t\t\t\t\tif (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (valueo)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;\n\t\t\t\t\t\t\tcase OFILETYPE_PAGE: value=FILETYPE_PAGE; break;\n\t\t\t\t\t\t\tdefault: value=0; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value!=0)\n\t\t\t\t\t\t\tTIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n/* END REV 4.0 COMPATIBILITY */\n\t\t\tdefault:\n\t\t\t\t(void) TIFFFetchNormalTag(tif, dp, TRUE);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * OJPEG hack:\n\t * - If a) compression is OJPEG, and b) photometric tag is missing,\n\t * then we consistently find that photometric should be YCbCr\n\t * - If a) compression is OJPEG, and b) photometric tag says it's RGB,\n\t * then we consistently find that the buggy implementation of the\n\t * buggy compression scheme matches photometric YCbCr instead.\n\t * - If a) compression is OJPEG, and b) bitspersample tag is missing,\n\t * then we consistently find bitspersample should be 8.\n\t * - If a) compression is OJPEG, b) samplesperpixel tag is missing,\n\t * and c) photometric is RGB or YCbCr, then we consistently find\n\t * samplesperpixel should be 3\n\t * - If a) compression is OJPEG, b) samplesperpixel tag is missing,\n\t * and c) photometric is MINISWHITE or MINISBLACK, then we consistently\n\t * find samplesperpixel should be 3\n\t */\n\tif (tif->tif_dir.td_compression==COMPRESSION_OJPEG)\n\t{\n\t\tif (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Photometric tag is missing, assuming data is YCbCr\");\n\t\t\tif (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))\n\t\t\t\tgoto bad;\n\t\t}\n\t\telse if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)\n\t\t{\n\t\t\ttif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Photometric tag value assumed incorrect, \"\n\t\t\t    \"assuming data is YCbCr instead of RGB\");\n\t\t}\n\t\tif (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t    \"BitsPerSample tag is missing, assuming 8 bits per sample\");\n\t\t\tif (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))\n\t\t\t\tgoto bad;\n\t\t}\n\t\tif (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\n\t\t{\n\t\t\tif (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t    \"SamplesPerPixel tag is missing, \"\n\t\t\t\t    \"assuming correct SamplesPerPixel value is 3\");\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t    \"SamplesPerPixel tag is missing, \"\n\t\t\t\t    \"applying correct SamplesPerPixel value of 3\");\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\telse if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)\n\t\t\t\t || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * SamplesPerPixel tag is missing, but is not required\n\t\t\t\t * by spec.  Assume correct SamplesPerPixel value of 1.\n\t\t\t\t */\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Verify Palette image has a Colormap.\n\t */\n\tif (tif->tif_dir.td_photometric == PHOTOMETRIC_PALETTE &&\n\t    !TIFFFieldSet(tif, FIELD_COLORMAP)) {\n\t\tif ( tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3)\n\t\t\ttif->tif_dir.td_photometric = PHOTOMETRIC_RGB;\n\t\telse if (tif->tif_dir.td_bitspersample>=8)\n\t\t\ttif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;\n\t\telse {\n\t\t\tMissingRequired(tif, \"Colormap\");\n\t\t\tgoto bad;\n\t\t}\n\t}\n\t/*\n\t * OJPEG hack:\n\t * We do no further messing with strip/tile offsets/bytecounts in OJPEG\n\t * TIFFs\n\t */\n\tif (tif->tif_dir.td_compression!=COMPRESSION_OJPEG)\n\t{\n\t\t/*\n\t\t * Attempt to deal with a missing StripByteCounts tag.\n\t\t */\n\t\tif (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {\n\t\t\t/*\n\t\t\t * Some manufacturers violate the spec by not giving\n\t\t\t * the size of the strips.  In this case, assume there\n\t\t\t * is one uncompressed strip of data.\n\t\t\t */\n\t\t\tif ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&\n\t\t\t    tif->tif_dir.td_nstrips > 1) ||\n\t\t\t    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&\n\t\t\t     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {\n\t\t\t    MissingRequired(tif, \"StripByteCounts\");\n\t\t\t    goto bad;\n\t\t\t}\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"TIFF directory is missing required \"\n\t\t\t\t\"\\\"StripByteCounts\\\" field, calculating from imagelength\");\n\t\t\tif (EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n\t\t/*\n\t\t * Assume we have wrong StripByteCount value (in case\n\t\t * of single strip) in following cases:\n\t\t *   - it is equal to zero along with StripOffset;\n\t\t *   - it is larger than file itself (in case of uncompressed\n\t\t *     image);\n\t\t *   - it is smaller than the size of the bytes per row\n\t\t *     multiplied on the number of rows.  The last case should\n\t\t *     not be checked in the case of writing new image,\n\t\t *     because we may do not know the exact strip size\n\t\t *     until the whole image will be written and directory\n\t\t *     dumped out.\n\t\t */\n\t\t#define\tBYTECOUNTLOOKSBAD \\\n\t\t    ( (tif->tif_dir.td_stripbytecount[0] == 0 && tif->tif_dir.td_stripoffset[0] != 0) || \\\n\t\t      (tif->tif_dir.td_compression == COMPRESSION_NONE && \\\n\t\t       tif->tif_dir.td_stripbytecount[0] > TIFFGetFileSize(tif) - tif->tif_dir.td_stripoffset[0]) || \\\n\t\t      (tif->tif_mode == O_RDONLY && \\\n\t\t       tif->tif_dir.td_compression == COMPRESSION_NONE && \\\n\t\t       tif->tif_dir.td_stripbytecount[0] < TIFFScanlineSize64(tif) * tif->tif_dir.td_imagelength) )\n\n\t\t} else if (tif->tif_dir.td_nstrips == 1\n                           && _TIFFFillStriles(tif)\n\t\t\t   && tif->tif_dir.td_stripoffset[0] != 0\n\t\t\t   && BYTECOUNTLOOKSBAD) {\n\t\t\t/*\n\t\t\t * XXX: Plexus (and others) sometimes give a value of\n\t\t\t * zero for a tag when they don't know what the\n\t\t\t * correct value is!  Try and handle the simple case\n\t\t\t * of estimating the size of a one strip image.\n\t\t\t */\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Bogus \\\"StripByteCounts\\\" field, ignoring and calculating from imagelength\");\n\t\t\tif(EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n\n#if !defined(DEFER_STRILE_LOAD)\n\t\t} else if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG\n\t\t\t   && tif->tif_dir.td_nstrips > 2\n\t\t\t   && tif->tif_dir.td_compression == COMPRESSION_NONE\n\t\t\t   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]\n\t\t\t   && tif->tif_dir.td_stripbytecount[0] != 0\n\t\t\t   && tif->tif_dir.td_stripbytecount[1] != 0 ) {\n\t\t\t/*\n\t\t\t * XXX: Some vendors fill StripByteCount array with\n\t\t\t * absolutely wrong values (it can be equal to\n\t\t\t * StripOffset array, for example). Catch this case\n\t\t\t * here.\n                         *\n                         * We avoid this check if deferring strile loading\n                         * as it would always force us to load the strip/tile\n                         * information.\n\t\t\t */\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Wrong \\\"StripByteCounts\\\" field, ignoring and calculating from imagelength\");\n\t\t\tif (EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n#endif /* !defined(DEFER_STRILE_LOAD) */                        \n\t\t}\n\t}\n\tif (dir)\n\t{\n\t\t_TIFFfree(dir);\n\t\tdir=NULL;\n\t}\n\tif (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))\n\t{\n\t\tif (tif->tif_dir.td_bitspersample>=16)\n\t\t\ttif->tif_dir.td_maxsamplevalue=0xFFFF;\n\t\telse\n\t\t\ttif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1);\n\t}\n\t/*\n\t * XXX: We can optimize checking for the strip bounds using the sorted\n\t * bytecounts array. See also comments for TIFFAppendToStrip()\n\t * function in tif_write.c.\n\t */\n#if !defined(DEFER_STRILE_LOAD)        \n\tif (tif->tif_dir.td_nstrips > 1) {\n\t\tuint32 strip;\n\n\t\ttif->tif_dir.td_stripbytecountsorted = 1;\n\t\tfor (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {\n\t\t\tif (tif->tif_dir.td_stripoffset[strip - 1] >\n\t\t\t    tif->tif_dir.td_stripoffset[strip]) {\n\t\t\t\ttif->tif_dir.td_stripbytecountsorted = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif /* !defined(DEFER_STRILE_LOAD) */\n        \n\t/*\n\t * An opportunity for compression mode dependent tag fixup\n\t */\n\t(*tif->tif_fixuptags)(tif);\n\n\t/*\n\t * Some manufacturers make life difficult by writing\n\t * large amounts of uncompressed data as a single strip.\n\t * This is contrary to the recommendations of the spec.\n\t * The following makes an attempt at breaking such images\n\t * into strips closer to the recommended 8k bytes.  A\n\t * side effect, however, is that the RowsPerStrip tag\n\t * value may be changed.\n\t */\n\tif ((tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&\n\t    (tif->tif_dir.td_nstrips==1)&&\n\t    (tif->tif_dir.td_compression==COMPRESSION_NONE)&&  \n\t    ((tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP))\n    {\n        if ( !_TIFFFillStriles(tif) || !tif->tif_dir.td_stripbytecount )\n            return 0;\n\t\tChopUpSingleUncompressedStrip(tif);\n    }\n\n        /*\n         * Clear the dirty directory flag. \n         */\n\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\n\ttif->tif_flags &= ~TIFF_DIRTYSTRIP;\n\n\t/*\n\t * Reinitialize i/o since we are starting on a new directory.\n\t */\n\ttif->tif_row = (uint32) -1;\n\ttif->tif_curstrip = (uint32) -1;\n\ttif->tif_col = (uint32) -1;\n\ttif->tif_curtile = (uint32) -1;\n\ttif->tif_tilesize = (tmsize_t) -1;\n\n\ttif->tif_scanlinesize = TIFFScanlineSize(tif);\n\tif (!tif->tif_scanlinesize) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Cannot handle zero scanline size\");\n\t\treturn (0);\n\t}\n\n\tif (isTiled(tif)) {\n\t\ttif->tif_tilesize = TIFFTileSize(tif);\n\t\tif (!tif->tif_tilesize) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Cannot handle zero tile size\");\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\tif (!TIFFStripSize(tif)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Cannot handle zero strip size\");\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (1);\nbad:\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn (0);\n}",
        "begin_line": 3412,
        "end_line": 4107,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirectoryCheckOrder#4109",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirectoryCheckOrder(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)",
        "snippet": "static void\nTIFFReadDirectoryCheckOrder(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)\n{\n\tstatic const char module[] = \"TIFFReadDirectoryCheckOrder\";\n\tuint16 m;\n\tuint16 n;\n\tTIFFDirEntry* o;\n\tm=0;\n\tfor (n=0, o=dir; n<dircount; n++, o++)\n\t{\n\t\tif (o->tdir_tag<m)\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t    \"Invalid TIFF directory; tags are not sorted in ascending order\");\n\t\t\tbreak;\n\t\t}\n\t\tm=o->tdir_tag+1;\n\t}\n}",
        "begin_line": 4109,
        "end_line": 4127,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirectoryFindEntry#4129",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirectoryFindEntry(TIFF* tif, TIFFDirEntry* dir, uint16 dircount, uint16 tagid)",
        "snippet": "static TIFFDirEntry*\nTIFFReadDirectoryFindEntry(TIFF* tif, TIFFDirEntry* dir, uint16 dircount, uint16 tagid)\n{\n\tTIFFDirEntry* m;\n\tuint16 n;\n\t(void) tif;\n\tfor (m=dir, n=0; n<dircount; m++, n++)\n\t{\n\t\tif (m->tdir_tag==tagid)\n\t\t\treturn(m);\n\t}\n\treturn(0);\n}",
        "begin_line": 4129,
        "end_line": 4141,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirectoryFindFieldInfo#4143",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirectoryFindFieldInfo(TIFF* tif, uint16 tagid, uint32* fii)",
        "snippet": "static void\nTIFFReadDirectoryFindFieldInfo(TIFF* tif, uint16 tagid, uint32* fii)\n{\n\tint32 ma,mb,mc;\n\tma=-1;\n\tmc=(int32)tif->tif_nfields;\n\twhile (1)\n\t{\n\t\tif (ma+1==mc)\n\t\t{\n\t\t\t*fii = FAILED_FII;\n\t\t\treturn;\n\t\t}\n\t\tmb=(ma+mc)/2;\n\t\tif (tif->tif_fields[mb]->field_tag==(uint32)tagid)\n\t\t\tbreak;\n\t\tif (tif->tif_fields[mb]->field_tag<(uint32)tagid)\n\t\t\tma=mb;\n\t\telse\n\t\t\tmc=mb;\n\t}\n\twhile (1)\n\t{\n\t\tif (mb==0)\n\t\t\tbreak;\n\t\tif (tif->tif_fields[mb-1]->field_tag!=(uint32)tagid)\n\t\t\tbreak;\n\t\tmb--;\n\t}\n\t*fii=mb;\n}",
        "begin_line": 4143,
        "end_line": 4173,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadUInt64#184",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadUInt64(const uint8 *value)",
        "snippet": "static uint64 TIFFReadUInt64(const uint8 *value)\n{\n\tUInt64Aligned_t result;\n\n\tresult.c[0]=value[0];\n\tresult.c[1]=value[1];\n\tresult.c[2]=value[2];\n\tresult.c[3]=value[3];\n\tresult.c[4]=value[4];\n\tresult.c[5]=value[5];\n\tresult.c[6]=value[6];\n\tresult.c[7]=value[7];\n\n\treturn result.l;\n}",
        "begin_line": 184,
        "end_line": 198,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread._TIFFFillStriles#5598",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread._TIFFFillStriles( TIFF *tif )",
        "snippet": "int _TIFFFillStriles( TIFF *tif )\n{\n    return _TIFFFillStrilesInternal( tif, 1 );\n}",
        "begin_line": 5598,
        "end_line": 5601,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread._TIFFFillStrilesInternal#5603",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread._TIFFFillStrilesInternal( TIFF *tif, int loadStripByteCount )",
        "snippet": "static int _TIFFFillStrilesInternal( TIFF *tif, int loadStripByteCount )\n{\n#if defined(DEFER_STRILE_LOAD)\n        register TIFFDirectory *td = &tif->tif_dir;\n        int return_value = 1;\n\n        if( td->td_stripoffset != NULL )\n                return 1;\n\n        if( td->td_stripoffset_entry.tdir_count == 0 )\n                return 0;\n\n        if (!TIFFFetchStripThing(tif,&(td->td_stripoffset_entry),\n                                 td->td_nstrips,&td->td_stripoffset))\n        {\n                return_value = 0;\n        }\n\n        if (loadStripByteCount &&\n            !TIFFFetchStripThing(tif,&(td->td_stripbytecount_entry),\n                                 td->td_nstrips,&td->td_stripbytecount))\n        {\n                return_value = 0;\n        }\n\n        _TIFFmemset( &(td->td_stripoffset_entry), 0, sizeof(TIFFDirEntry));\n        _TIFFmemset( &(td->td_stripbytecount_entry), 0, sizeof(TIFFDirEntry));\n\n\tif (tif->tif_dir.td_nstrips > 1 && return_value == 1 ) {\n\t\tuint32 strip;\n\n\t\ttif->tif_dir.td_stripbytecountsorted = 1;\n\t\tfor (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {\n\t\t\tif (tif->tif_dir.td_stripoffset[strip - 1] >\n\t\t\t    tif->tif_dir.td_stripoffset[strip]) {\n\t\t\t\ttif->tif_dir.td_stripbytecountsorted = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n        return return_value;\n#else /* !defined(DEFER_STRILE_LOAD) */\n        (void) tif;\n        (void) loadStripByteCount;\n        return 1;\n#endif \n}",
        "begin_line": 5603,
        "end_line": 5650,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirwrite.TIFFLinkDirectory#2455",
        "src_path": "libtiff/tif_dirwrite.c",
        "class_name": "libtiff.tif_dirwrite",
        "signature": "libtiff.tif_dirwrite.TIFFLinkDirectory(TIFF* tif)",
        "snippet": "static int\nTIFFLinkDirectory(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFLinkDirectory\";\n\n\ttif->tif_diroff = (TIFFSeekFile(tif,0,SEEK_END)+1) & (~((toff_t)1));\n\n\t/*\n\t * Handle SubIFDs\n\t */\n\tif (tif->tif_flags & TIFF_INSUBIFD)\n\t{\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tuint32 m;\n\t\t\tm = (uint32)tif->tif_diroff;\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&m);\n\t\t\t(void) TIFFSeekFile(tif, tif->tif_subifdoff, SEEK_SET);\n\t\t\tif (!WriteOK(tif, &m, 4)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"Error writing SubIFD directory link\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Advance to the next SubIFD or, if this is\n\t\t\t * the last one configured, revert back to the\n\t\t\t * normal directory linkage.\n\t\t\t */\n\t\t\tif (--tif->tif_nsubifd)\n\t\t\t\ttif->tif_subifdoff += 4;\n\t\t\telse\n\t\t\t\ttif->tif_flags &= ~TIFF_INSUBIFD;\n\t\t\treturn (1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint64 m;\n\t\t\tm = tif->tif_diroff;\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&m);\n\t\t\t(void) TIFFSeekFile(tif, tif->tif_subifdoff, SEEK_SET);\n\t\t\tif (!WriteOK(tif, &m, 8)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"Error writing SubIFD directory link\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Advance to the next SubIFD or, if this is\n\t\t\t * the last one configured, revert back to the\n\t\t\t * normal directory linkage.\n\t\t\t */\n\t\t\tif (--tif->tif_nsubifd)\n\t\t\t\ttif->tif_subifdoff += 8;\n\t\t\telse\n\t\t\t\ttif->tif_flags &= ~TIFF_INSUBIFD;\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tuint32 m;\n\t\tuint32 nextdir;\n\t\tm = (uint32)(tif->tif_diroff);\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabLong(&m);\n\t\tif (tif->tif_header.classic.tiff_diroff == 0) {\n\t\t\t/*\n\t\t\t * First directory, overwrite offset in header.\n\t\t\t */\n\t\t\ttif->tif_header.classic.tiff_diroff = (uint32) tif->tif_diroff;\n\t\t\t(void) TIFFSeekFile(tif,4, SEEK_SET);\n\t\t\tif (!WriteOK(tif, &m, 4)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t\t\t     \"Error writing TIFF header\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\treturn (1);\n\t\t}\n\t\t/*\n\t\t * Not the first directory, search to the last and append.\n\t\t */\n\t\tnextdir = tif->tif_header.classic.tiff_diroff;\n\t\twhile(1) {\n\t\t\tuint16 dircount;\n\t\t\tuint32 nextnextdir;\n\n\t\t\tif (!SeekOK(tif, nextdir) ||\n\t\t\t    !ReadOK(tif, &dircount, 2)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error fetching directory count\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&dircount);\n\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t    nextdir+2+dircount*12, SEEK_SET);\n\t\t\tif (!ReadOK(tif, &nextnextdir, 4)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error fetching directory link\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&nextnextdir);\n\t\t\tif (nextnextdir==0)\n\t\t\t{\n\t\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t\t    nextdir+2+dircount*12, SEEK_SET);\n\t\t\t\tif (!WriteOK(tif, &m, 4)) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error writing directory link\");\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextdir=nextnextdir;\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint64 m;\n\t\tuint64 nextdir;\n\t\tm = tif->tif_diroff;\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabLong8(&m);\n\t\tif (tif->tif_header.big.tiff_diroff == 0) {\n\t\t\t/*\n\t\t\t * First directory, overwrite offset in header.\n\t\t\t */\n\t\t\ttif->tif_header.big.tiff_diroff = tif->tif_diroff;\n\t\t\t(void) TIFFSeekFile(tif,8, SEEK_SET);\n\t\t\tif (!WriteOK(tif, &m, 8)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t\t\t     \"Error writing TIFF header\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\treturn (1);\n\t\t}\n\t\t/*\n\t\t * Not the first directory, search to the last and append.\n\t\t */\n\t\tnextdir = tif->tif_header.big.tiff_diroff;\n\t\twhile(1) {\n\t\t\tuint64 dircount64;\n\t\t\tuint16 dircount;\n\t\t\tuint64 nextnextdir;\n\n\t\t\tif (!SeekOK(tif, nextdir) ||\n\t\t\t    !ReadOK(tif, &dircount64, 8)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error fetching directory count\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\tif (dircount64>0xFFFF)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Sanity check on tag count failed, likely corrupt TIFF\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdircount=(uint16)dircount64;\n\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t    nextdir+8+dircount*20, SEEK_SET);\n\t\t\tif (!ReadOK(tif, &nextnextdir, 8)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error fetching directory link\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&nextnextdir);\n\t\t\tif (nextnextdir==0)\n\t\t\t{\n\t\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t\t    nextdir+8+dircount*20, SEEK_SET);\n\t\t\t\tif (!WriteOK(tif, &m, 8)) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error writing directory link\");\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextdir=nextnextdir;\n\t\t}\n\t}\n\treturn (1);\n}",
        "begin_line": 2455,
        "end_line": 2642,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirwrite.TIFFRewriteDirectory#217",
        "src_path": "libtiff/tif_dirwrite.c",
        "class_name": "libtiff.tif_dirwrite",
        "signature": "libtiff.tif_dirwrite.TIFFRewriteDirectory( TIFF *tif )",
        "snippet": "int\nTIFFRewriteDirectory( TIFF *tif )\n{\n\tstatic const char module[] = \"TIFFRewriteDirectory\";\n\n\t/* We don't need to do anything special if it hasn't been written. */\n\tif( tif->tif_diroff == 0 )\n\t\treturn TIFFWriteDirectory( tif );\n\n\t/*\n\t * Find and zero the pointer to this directory, so that TIFFLinkDirectory\n\t * will cause it to be added after this directories current pre-link.\n\t */\n\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tif (tif->tif_header.classic.tiff_diroff == tif->tif_diroff)\n\t\t{\n\t\t\ttif->tif_header.classic.tiff_diroff = 0;\n\t\t\ttif->tif_diroff = 0;\n\n\t\t\tTIFFSeekFile(tif,4,SEEK_SET);\n\t\t\tif (!WriteOK(tif, &(tif->tif_header.classic.tiff_diroff),4))\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t\t    \"Error updating TIFF header\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint32 nextdir;\n\t\t\tnextdir = tif->tif_header.classic.tiff_diroff;\n\t\t\twhile(1) {\n\t\t\t\tuint16 dircount;\n\t\t\t\tuint32 nextnextdir;\n\n\t\t\t\tif (!SeekOK(tif, nextdir) ||\n\t\t\t\t    !ReadOK(tif, &dircount, 2)) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error fetching directory count\");\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\t\tTIFFSwabShort(&dircount);\n\t\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t\t    nextdir+2+dircount*12, SEEK_SET);\n\t\t\t\tif (!ReadOK(tif, &nextnextdir, 4)) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error fetching directory link\");\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong(&nextnextdir);\n\t\t\t\tif (nextnextdir==tif->tif_diroff)\n\t\t\t\t{\n\t\t\t\t\tuint32 m;\n\t\t\t\t\tm=0;\n\t\t\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t\t\t    nextdir+2+dircount*12, SEEK_SET);\n\t\t\t\t\tif (!WriteOK(tif, &m, 4)) {\n\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\t     \"Error writing directory link\");\n\t\t\t\t\t\treturn (0);\n\t\t\t\t\t}\n\t\t\t\t\ttif->tif_diroff=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnextdir=nextnextdir;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (tif->tif_header.big.tiff_diroff == tif->tif_diroff)\n\t\t{\n\t\t\ttif->tif_header.big.tiff_diroff = 0;\n\t\t\ttif->tif_diroff = 0;\n\n\t\t\tTIFFSeekFile(tif,8,SEEK_SET);\n\t\t\tif (!WriteOK(tif, &(tif->tif_header.big.tiff_diroff),8))\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t\t    \"Error updating TIFF header\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint64 nextdir;\n\t\t\tnextdir = tif->tif_header.big.tiff_diroff;\n\t\t\twhile(1) {\n\t\t\t\tuint64 dircount64;\n\t\t\t\tuint16 dircount;\n\t\t\t\tuint64 nextnextdir;\n\n\t\t\t\tif (!SeekOK(tif, nextdir) ||\n\t\t\t\t    !ReadOK(tif, &dircount64, 8)) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error fetching directory count\");\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\t\tif (dircount64>0xFFFF)\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Sanity check on tag count failed, likely corrupt TIFF\");\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tdircount=(uint16)dircount64;\n\t\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t\t    nextdir+8+dircount*20, SEEK_SET);\n\t\t\t\tif (!ReadOK(tif, &nextnextdir, 8)) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error fetching directory link\");\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong8(&nextnextdir);\n\t\t\t\tif (nextnextdir==tif->tif_diroff)\n\t\t\t\t{\n\t\t\t\t\tuint64 m;\n\t\t\t\t\tm=0;\n\t\t\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t\t\t    nextdir+8+dircount*20, SEEK_SET);\n\t\t\t\t\tif (!WriteOK(tif, &m, 8)) {\n\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\t     \"Error writing directory link\");\n\t\t\t\t\t\treturn (0);\n\t\t\t\t\t}\n\t\t\t\t\ttif->tif_diroff=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnextdir=nextnextdir;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now use TIFFWriteDirectory() normally.\n\t */\n\n\treturn TIFFWriteDirectory( tif );\n}",
        "begin_line": 217,
        "end_line": 361,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirwrite.TIFFWriteDirectory#181",
        "src_path": "libtiff/tif_dirwrite.c",
        "class_name": "libtiff.tif_dirwrite",
        "signature": "libtiff.tif_dirwrite.TIFFWriteDirectory(TIFF* tif)",
        "snippet": "int\nTIFFWriteDirectory(TIFF* tif)\n{\n\treturn TIFFWriteDirectorySec(tif,TRUE,TRUE,NULL);\n}",
        "begin_line": 181,
        "end_line": 185,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirwrite.TIFFWriteDirectorySec#363",
        "src_path": "libtiff/tif_dirwrite.c",
        "class_name": "libtiff.tif_dirwrite",
        "signature": "libtiff.tif_dirwrite.TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff)",
        "snippet": "static int\nTIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff)\n{\n\tstatic const char module[] = \"TIFFWriteDirectorySec\";\n\tuint32 ndir;\n\tTIFFDirEntry* dir;\n\tuint32 dirsize;\n\tvoid* dirmem;\n\tuint32 m;\n\tif (tif->tif_mode == O_RDONLY)\n\t\treturn (1);\n\n        _TIFFFillStriles( tif );\n        \n\t/*\n\t * Clear write state so that subsequent images with\n\t * different characteristics get the right buffers\n\t * setup for them.\n\t */\n\tif (imagedone)\n\t{\n\t\tif (tif->tif_flags & TIFF_POSTENCODE)\n\t\t{\n\t\t\ttif->tif_flags &= ~TIFF_POSTENCODE;\n\t\t\tif (!(*tif->tif_postencode)(tif))\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t\t\t    \"Error post-encoding before directory write\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t\t(*tif->tif_close)(tif);       /* shutdown encoder */\n\t\t/*\n\t\t * Flush any data that might have been written\n\t\t * by the compression close+cleanup routines.  But\n                 * be careful not to write stuff if we didn't add data\n                 * in the previous steps as the \"rawcc\" data may well be\n                 * a previously read tile/strip in mixed read/write mode.\n\t\t */\n\t\tif (tif->tif_rawcc > 0 \n\t\t    && (tif->tif_flags & TIFF_BEENWRITING) != 0 )\n\t\t{\n\t\t    if( !TIFFFlushData1(tif) )\n                    {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Error flushing data before directory write\");\n\t\t\treturn (0);\n                    }\n\t\t}\n\t\tif ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata)\n\t\t{\n\t\t\t_TIFFfree(tif->tif_rawdata);\n\t\t\ttif->tif_rawdata = NULL;\n\t\t\ttif->tif_rawcc = 0;\n\t\t\ttif->tif_rawdatasize = 0;\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = 0;\n\t\t}\n\t\ttif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP);\n\t}\n\tdir=NULL;\n\tdirmem=NULL;\n\tdirsize=0;\n\twhile (1)\n\t{\n\t\tndir=0;\n\t\tif (isimage)\n\t\t{\n\t\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGEWIDTH,tif->tif_dir.td_imagewidth))\n\t\t\t\t\tgoto bad;\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGELENGTH,tif->tif_dir.td_imagelength))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILEWIDTH,tif->tif_dir.td_tilewidth))\n\t\t\t\t\tgoto bad;\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILELENGTH,tif->tif_dir.td_tilelength))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XRESOLUTION,tif->tif_dir.td_xresolution))\n\t\t\t\t\tgoto bad;\n\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YRESOLUTION,tif->tif_dir.td_yresolution))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_POSITION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XPOSITION,tif->tif_dir.td_xposition))\n\t\t\t\t\tgoto bad;\n\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YPOSITION,tif->tif_dir.td_yposition))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SUBFILETYPE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_SUBFILETYPE,tif->tif_dir.td_subfiletype))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_BITSPERSAMPLE,tif->tif_dir.td_bitspersample))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_COMPRESSION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_COMPRESSION,tif->tif_dir.td_compression))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_PHOTOMETRIC))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PHOTOMETRIC,tif->tif_dir.td_photometric))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_THRESHHOLDING))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_THRESHHOLDING,tif->tif_dir.td_threshholding))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_FILLORDER))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_FILLORDER,tif->tif_dir.td_fillorder))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_ORIENTATION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_ORIENTATION,tif->tif_dir.td_orientation))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_SAMPLESPERPIXEL,tif->tif_dir.td_samplesperpixel))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_ROWSPERSTRIP,tif->tif_dir.td_rowsperstrip))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MINSAMPLEVALUE,tif->tif_dir.td_minsamplevalue))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MAXSAMPLEVALUE,tif->tif_dir.td_maxsamplevalue))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_PLANARCONFIG))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PLANARCONFIG,tif->tif_dir.td_planarconfig))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_RESOLUTIONUNIT,tif->tif_dir.td_resolutionunit))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_PAGENUMBER))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_PAGENUMBER,2,&tif->tif_dir.td_pagenumber[0]))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPBYTECOUNTS))\n\t\t\t{\n\t\t\t\tif (!isTiled(tif))\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPOFFSETS))\n\t\t\t{\n\t\t\t\tif (!isTiled(tif))\n\t\t\t\t{\n                    /* td_stripoffset might be NULL in an odd OJPEG case. See\n                     *  tif_dirread.c around line 3634.\n                     * XXX: OJPEG hack.\n                     * If a) compression is OJPEG, b) it's not a tiled TIFF,\n                     * and c) the number of strips is 1,\n                     * then we tolerate the absence of stripoffsets tag,\n                     * because, presumably, all required data is in the\n                     * JpegInterchangeFormat stream.\n                     * We can get here when using tiffset on such a file.\n                     * See http://bugzilla.maptools.org/show_bug.cgi?id=2500\n                    */\n                    if (tif->tif_dir.td_stripoffset != NULL &&\n                        !TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\n                        goto bad;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_COLORMAP))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagColormap(tif,&ndir,dir))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_EXTRASAMPLES))\n\t\t\t{\n\t\t\t\tif (tif->tif_dir.td_extrasamples)\n\t\t\t\t{\n\t\t\t\t\tuint16 na;\n\t\t\t\t\tuint16* nb;\n\t\t\t\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_EXTRASAMPLES,&na,&nb);\n\t\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_EXTRASAMPLES,na,nb))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_SAMPLEFORMAT,tif->tif_dir.td_sampleformat))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMINSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_sminsamplevalue))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMAXSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_smaxsamplevalue))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDEPTH))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_IMAGEDEPTH,tif->tif_dir.td_imagedepth))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_TILEDEPTH))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_TILEDEPTH,tif->tif_dir.td_tiledepth))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_HALFTONEHINTS))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_HALFTONEHINTS,2,&tif->tif_dir.td_halftonehints[0]))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_YCBCRSUBSAMPLING,2,&tif->tif_dir.td_ycbcrsubsampling[0]))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_YCBCRPOSITIONING,tif->tif_dir.td_ycbcrpositioning))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_REFBLACKWHITE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,TIFFTAG_REFERENCEBLACKWHITE,6,tif->tif_dir.td_refblackwhite))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagTransferfunction(tif,&ndir,dir))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_INKNAMES))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,TIFFTAG_INKNAMES,tif->tif_dir.td_inknameslen,tif->tif_dir.td_inknames))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SUBIFD))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagSubifd(tif,&ndir,dir))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\t{\n\t\t\t\tuint32 n;\n\t\t\t\tfor (n=0; n<tif->tif_nfields; n++) {\n\t\t\t\t\tconst TIFFField* o;\n\t\t\t\t\to = tif->tif_fields[n];\n\t\t\t\t\tif ((o->field_bit>=FIELD_CODEC)&&(TIFFFieldSet(tif,o->field_bit)))\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (o->get_field_type)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase TIFF_SETGET_ASCII:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint32 pa;\n\t\t\t\t\t\t\t\t\tchar* pb;\n\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_ASCII);\n\t\t\t\t\t\t\t\t\tassert(o->field_readcount==TIFF_VARIABLE);\n\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\n\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&pb);\n\t\t\t\t\t\t\t\t\tpa=(uint32)(strlen(pb));\n\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,(uint16)o->field_tag,pa,pb))\n\t\t\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SETGET_UINT16:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint16 p;\n\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_SHORT);\n\t\t\t\t\t\t\t\t\tassert(o->field_readcount==1);\n\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\n\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&p);\n\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,(uint16)o->field_tag,p))\n\t\t\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SETGET_UINT32:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint32 p;\n\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_LONG);\n\t\t\t\t\t\t\t\t\tassert(o->field_readcount==1);\n\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\n\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&p);\n\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,(uint16)o->field_tag,p))\n\t\t\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SETGET_C32_UINT8:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint32 pa;\n\t\t\t\t\t\t\t\t\tvoid* pb;\n\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_UNDEFINED);\n\t\t\t\t\t\t\t\t\tassert(o->field_readcount==TIFF_VARIABLE2);\n\t\t\t\t\t\t\t\t\tassert(o->field_passcount==1);\n\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&pa,&pb);\n\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,(uint16)o->field_tag,pa,pb))\n\t\t\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tassert(0);   /* we should never get here */\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (m=0; m<(uint32)(tif->tif_dir.td_customValueCount); m++)\n\t\t{\n                        uint16 tag = (uint16)tif->tif_dir.td_customValues[m].info->field_tag;\n                        uint32 count = tif->tif_dir.td_customValues[m].count;\n\t\t\tswitch (tif->tif_dir.td_customValues[m].info->field_type)\n\t\t\t{\n\t\t\t\tcase TIFF_ASCII:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_BYTE:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagByteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SBYTE:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSbyteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SHORT:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SSHORT:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSshortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_LONG:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SLONG:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSlongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_LONG8:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SLONG8:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSlong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_RATIONAL:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SRATIONAL:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSrationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_FLOAT:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagFloatArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_DOUBLE:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagDoubleArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_IFD:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagIfdArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_IFD8:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagIfdIfd8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert(0);   /* we should never get here */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (dir!=NULL)\n\t\t\tbreak;\n\t\tdir=_TIFFmalloc(ndir*sizeof(TIFFDirEntry));\n\t\tif (dir==NULL)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\tgoto bad;\n\t\t}\n\t\tif (isimage)\n\t\t{\n\t\t\tif ((tif->tif_diroff==0)&&(!TIFFLinkDirectory(tif)))\n\t\t\t\tgoto bad;\n\t\t}\n\t\telse\n\t\t\ttif->tif_diroff=(TIFFSeekFile(tif,0,SEEK_END)+1)&(~((toff_t)1));\n\t\tif (pdiroff!=NULL)\n\t\t\t*pdiroff=tif->tif_diroff;\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\tdirsize=2+ndir*12+4;\n\t\telse\n\t\t\tdirsize=8+ndir*20+8;\n\t\ttif->tif_dataoff=tif->tif_diroff+dirsize;\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\ttif->tif_dataoff=(uint32)tif->tif_dataoff;\n\t\tif ((tif->tif_dataoff<tif->tif_diroff)||(tif->tif_dataoff<(uint64)dirsize))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Maximum TIFF file size exceeded\");\n\t\t\tgoto bad;\n\t\t}\n\t\tif (tif->tif_dataoff&1)\n\t\t\ttif->tif_dataoff++;\n\t\tif (isimage)\n\t\t\ttif->tif_curdir++;\n\t}\n\tif (isimage)\n\t{\n\t\tif (TIFFFieldSet(tif,FIELD_SUBIFD)&&(tif->tif_subifdoff==0))\n\t\t{\n\t\t\tuint32 na;\n\t\t\tTIFFDirEntry* nb;\n\t\t\tfor (na=0, nb=dir; ; na++, nb++)\n\t\t\t{\n\t\t\t\tassert(na<ndir);\n\t\t\t\tif (nb->tdir_tag==TIFFTAG_SUBIFD)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t\ttif->tif_subifdoff=tif->tif_diroff+2+na*12+8;\n\t\t\telse\n\t\t\t\ttif->tif_subifdoff=tif->tif_diroff+8+na*20+12;\n\t\t}\n\t}\n\tdirmem=_TIFFmalloc(dirsize);\n\tif (dirmem==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\tgoto bad;\n\t}\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tuint8* n;\n\t\tuint32 nTmp;\n\t\tTIFFDirEntry* o;\n\t\tn=dirmem;\n\t\t*(uint16*)n=(uint16)ndir;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabShort((uint16*)n);\n\t\tn+=2;\n\t\to=dir;\n\t\tfor (m=0; m<ndir; m++)\n\t\t{\n\t\t\t*(uint16*)n=o->tdir_tag;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort((uint16*)n);\n\t\t\tn+=2;\n\t\t\t*(uint16*)n=o->tdir_type;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort((uint16*)n);\n\t\t\tn+=2;\n\t\t\tnTmp = (uint32)o->tdir_count;\n\t\t\t_TIFFmemcpy(n,&nTmp,4);\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong((uint32*)n);\n\t\t\tn+=4;\n\t\t\t/* This is correct. The data has been */\n\t\t\t/* swabbed previously in TIFFWriteDirectoryTagData */\n\t\t\t_TIFFmemcpy(n,&o->tdir_offset,4);\n\t\t\tn+=4;\n\t\t\to++;\n\t\t}\n\t\tnTmp = (uint32)tif->tif_nextdiroff;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong(&nTmp);\n\t\t_TIFFmemcpy(n,&nTmp,4);\n\t}\n\telse\n\t{\n\t\tuint8* n;\n\t\tTIFFDirEntry* o;\n\t\tn=dirmem;\n\t\t*(uint64*)n=ndir;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong8((uint64*)n);\n\t\tn+=8;\n\t\to=dir;\n\t\tfor (m=0; m<ndir; m++)\n\t\t{\n\t\t\t*(uint16*)n=o->tdir_tag;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort((uint16*)n);\n\t\t\tn+=2;\n\t\t\t*(uint16*)n=o->tdir_type;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort((uint16*)n);\n\t\t\tn+=2;\n\t\t\t_TIFFmemcpy(n,&o->tdir_count,8);\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8((uint64*)n);\n\t\t\tn+=8;\n\t\t\t_TIFFmemcpy(n,&o->tdir_offset,8);\n\t\t\tn+=8;\n\t\t\to++;\n\t\t}\n\t\t_TIFFmemcpy(n,&tif->tif_nextdiroff,8);\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong8((uint64*)n);\n\t}\n\t_TIFFfree(dir);\n\tdir=NULL;\n\tif (!SeekOK(tif,tif->tif_diroff))\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\");\n\t\tgoto bad;\n\t}\n\tif (!WriteOK(tif,dirmem,(tmsize_t)dirsize))\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\");\n\t\tgoto bad;\n\t}\n\t_TIFFfree(dirmem);\n\tif (imagedone)\n\t{\n\t\tTIFFFreeDirectory(tif);\n\t\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\n\t\ttif->tif_flags &= ~TIFF_DIRTYSTRIP;\n\t\t(*tif->tif_cleanup)(tif);\n\t\t/*\n\t\t* Reset directory-related state for subsequent\n\t\t* directories.\n\t\t*/\n\t\tTIFFCreateDirectory(tif);\n\t}\n\treturn(1);\nbad:\n\tif (dir!=NULL)\n\t\t_TIFFfree(dir);\n\tif (dirmem!=NULL)\n\t\t_TIFFfree(dirmem);\n\treturn(0);\n}",
        "begin_line": 363,
        "end_line": 941,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirwrite.TIFFWriteDirectoryTagAscii#1113",
        "src_path": "libtiff/tif_dirwrite.c",
        "class_name": "libtiff.tif_dirwrite",
        "signature": "libtiff.tif_dirwrite.TIFFWriteDirectoryTagAscii(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, char* value)",
        "snippet": "static int\nTIFFWriteDirectoryTagAscii(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, char* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedAscii(tif,ndir,dir,tag,count,value));\n}",
        "begin_line": 1113,
        "end_line": 1122,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirwrite.TIFFWriteDirectoryTagCheckedRational#2158",
        "src_path": "libtiff/tif_dirwrite.c",
        "class_name": "libtiff.tif_dirwrite",
        "signature": "libtiff.tif_dirwrite.TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)",
        "snippet": "static int\nTIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)\n{\n        static const char module[] = \"TIFFWriteDirectoryTagCheckedRational\";\n\tuint32 m[2];\n\tassert(sizeof(uint32)==4);\n        if( value < 0 )\n        {\n            TIFFErrorExt(tif->tif_clientdata,module,\"Negative value is illegal\");\n            return 0;\n        }\n        else if( value != value )\n        {\n            TIFFErrorExt(tif->tif_clientdata,module,\"Not-a-number value is illegal\");\n            return 0;\n        }\n\telse if (value==0.0)\n\t{\n\t\tm[0]=0;\n\t\tm[1]=1;\n\t}\n\telse if (value <= 0xFFFFFFFFU && value==(double)(uint32)value)\n\t{\n\t\tm[0]=(uint32)value;\n\t\tm[1]=1;\n\t}\n\telse if (value<1.0)\n\t{\n\t\tm[0]=(uint32)(value*0xFFFFFFFF);\n\t\tm[1]=0xFFFFFFFF;\n\t}\n\telse\n\t{\n\t\tm[0]=0xFFFFFFFF;\n\t\tm[1]=(uint32)(0xFFFFFFFF/value);\n\t}\n\tif (tif->tif_flags&TIFF_SWAB)\n\t{\n\t\tTIFFSwabLong(&m[0]);\n\t\tTIFFSwabLong(&m[1]);\n\t}\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_RATIONAL,1,8,&m[0]));\n}",
        "begin_line": 2158,
        "end_line": 2200,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirwrite.TIFFWriteDirectoryTagCheckedShort#2020",
        "src_path": "libtiff/tif_dirwrite.c",
        "class_name": "libtiff.tif_dirwrite",
        "signature": "libtiff.tif_dirwrite.TIFFWriteDirectoryTagCheckedShort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 value)",
        "snippet": "static int\nTIFFWriteDirectoryTagCheckedShort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 value)\n{\n\tuint16 m;\n\tassert(sizeof(uint16)==2);\n\tm=value;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabShort(&m);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SHORT,1,2,&m));\n}",
        "begin_line": 2020,
        "end_line": 2029,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirwrite.TIFFWriteDirectoryTagData#2382",
        "src_path": "libtiff/tif_dirwrite.c",
        "class_name": "libtiff.tif_dirwrite",
        "signature": "libtiff.tif_dirwrite.TIFFWriteDirectoryTagData(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 datatype, uint32 count, uint32 datalength, void* data)",
        "snippet": "static int\nTIFFWriteDirectoryTagData(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 datatype, uint32 count, uint32 datalength, void* data)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagData\";\n\tuint32 m;\n\tm=0;\n\twhile (m<(*ndir))\n\t{\n\t\tassert(dir[m].tdir_tag!=tag);\n\t\tif (dir[m].tdir_tag>tag)\n\t\t\tbreak;\n\t\tm++;\n\t}\n\tif (m<(*ndir))\n\t{\n\t\tuint32 n;\n\t\tfor (n=*ndir; n>m; n--)\n\t\t\tdir[n]=dir[n-1];\n\t}\n\tdir[m].tdir_tag=tag;\n\tdir[m].tdir_type=datatype;\n\tdir[m].tdir_count=count;\n\tdir[m].tdir_offset.toff_long8 = 0;\n\tif (datalength<=((tif->tif_flags&TIFF_BIGTIFF)?0x8U:0x4U))\n\t\t_TIFFmemcpy(&dir[m].tdir_offset,data,datalength);\n\telse\n\t{\n\t\tuint64 na,nb;\n\t\tna=tif->tif_dataoff;\n\t\tnb=na+datalength;\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\tnb=(uint32)nb;\n\t\tif ((nb<na)||(nb<datalength))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Maximum TIFF file size exceeded\");\n\t\t\treturn(0);\n\t\t}\n\t\tif (!SeekOK(tif,na))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing tag data\");\n\t\t\treturn(0);\n\t\t}\n\t\tassert(datalength<0x80000000UL);\n\t\tif (!WriteOK(tif,data,(tmsize_t)datalength))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing tag data\");\n\t\t\treturn(0);\n\t\t}\n\t\ttif->tif_dataoff=nb;\n\t\tif (tif->tif_dataoff&1)\n\t\t\ttif->tif_dataoff++;\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tuint32 o;\n\t\t\to=(uint32)na;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&o);\n\t\t\t_TIFFmemcpy(&dir[m].tdir_offset,&o,4);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdir[m].tdir_offset.toff_long8 = na;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dir[m].tdir_offset.toff_long8);\n\t\t}\n\t}\n\t(*ndir)++;\n\treturn(1);\n}",
        "begin_line": 2382,
        "end_line": 2450,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirwrite.TIFFWriteDirectoryTagLongLong8Array#1665",
        "src_path": "libtiff/tif_dirwrite.c",
        "class_name": "libtiff.tif_dirwrite",
        "signature": "libtiff.tif_dirwrite.TIFFWriteDirectoryTagLongLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)",
        "snippet": "static int\nTIFFWriteDirectoryTagLongLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)\n{\n    static const char module[] = \"TIFFWriteDirectoryTagLongLong8Array\";\n    uint64* ma;\n    uint32 mb;\n    uint32* p;\n    uint32* q;\n    int o;\n\n    /* is this just a counting pass? */\n    if (dir==NULL)\n    {\n        (*ndir)++;\n        return(1);\n    }\n\n    /* We always write LONG8 for BigTIFF, no checking needed. */\n    if( tif->tif_flags&TIFF_BIGTIFF )\n        return TIFFWriteDirectoryTagCheckedLong8Array(tif,ndir,dir,\n                                                      tag,count,value);\n\n    /*\n    ** For classic tiff we want to verify everything is in range for LONG\n    ** and convert to long format.\n    */\n\n    p = _TIFFmalloc(count*sizeof(uint32));\n    if (p==NULL)\n    {\n        TIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n        return(0);\n    }\n\n    for (q=p, ma=value, mb=0; mb<count; ma++, mb++, q++)\n    {\n        if (*ma>0xFFFFFFFF)\n        {\n            TIFFErrorExt(tif->tif_clientdata,module,\n                         \"Attempt to write value larger than 0xFFFFFFFF in Classic TIFF file.\");\n            _TIFFfree(p);\n            return(0);\n        }\n        *q= (uint32)(*ma);\n    }\n\n    o=TIFFWriteDirectoryTagCheckedLongArray(tif,ndir,dir,tag,count,p);\n    _TIFFfree(p);\n\n    return(o);\n}",
        "begin_line": 1665,
        "end_line": 1715,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirwrite.TIFFWriteDirectoryTagRational#1489",
        "src_path": "libtiff/tif_dirwrite.c",
        "class_name": "libtiff.tif_dirwrite",
        "signature": "libtiff.tif_dirwrite.TIFFWriteDirectoryTagRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)",
        "snippet": "static int\nTIFFWriteDirectoryTagRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedRational(tif,ndir,dir,tag,value));\n}",
        "begin_line": 1489,
        "end_line": 1498,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirwrite.TIFFWriteDirectoryTagRationalArray#1500",
        "src_path": "libtiff/tif_dirwrite.c",
        "class_name": "libtiff.tif_dirwrite",
        "signature": "libtiff.tif_dirwrite.TIFFWriteDirectoryTagRationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)",
        "snippet": "static int\nTIFFWriteDirectoryTagRationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedRationalArray(tif,ndir,dir,tag,count,value));\n}",
        "begin_line": 1500,
        "end_line": 1509,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirwrite.TIFFWriteDirectoryTagShort#1239",
        "src_path": "libtiff/tif_dirwrite.c",
        "class_name": "libtiff.tif_dirwrite",
        "signature": "libtiff.tif_dirwrite.TIFFWriteDirectoryTagShort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 value)",
        "snippet": "static int\nTIFFWriteDirectoryTagShort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedShort(tif,ndir,dir,tag,value));\n}",
        "begin_line": 1239,
        "end_line": 1248,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirwrite.TIFFWriteDirectoryTagShortArray#1250",
        "src_path": "libtiff/tif_dirwrite.c",
        "class_name": "libtiff.tif_dirwrite",
        "signature": "libtiff.tif_dirwrite.TIFFWriteDirectoryTagShortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint16* value)",
        "snippet": "static int\nTIFFWriteDirectoryTagShortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint16* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedShortArray(tif,ndir,dir,tag,count,value));\n}",
        "begin_line": 1250,
        "end_line": 1259,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirwrite.TIFFWriteDirectoryTagShortLong#1644",
        "src_path": "libtiff/tif_dirwrite.c",
        "class_name": "libtiff.tif_dirwrite",
        "signature": "libtiff.tif_dirwrite.TIFFWriteDirectoryTagShortLong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 value)",
        "snippet": "static int\nTIFFWriteDirectoryTagShortLong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tif (value<=0xFFFF)\n\t\treturn(TIFFWriteDirectoryTagCheckedShort(tif,ndir,dir,tag,(uint16)value));\n\telse\n\t\treturn(TIFFWriteDirectoryTagCheckedLong(tif,ndir,dir,tag,value));\n}",
        "begin_line": 1644,
        "end_line": 1656,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirwrite.TIFFWriteDirectoryTagShortPerSample#1261",
        "src_path": "libtiff/tif_dirwrite.c",
        "class_name": "libtiff.tif_dirwrite",
        "signature": "libtiff.tif_dirwrite.TIFFWriteDirectoryTagShortPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 value)",
        "snippet": "static int\nTIFFWriteDirectoryTagShortPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagShortPerSample\";\n\tuint16* m;\n\tuint16* na;\n\tuint16 nb;\n\tint o;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(uint16));\n\tif (m==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tfor (na=m, nb=0; nb<tif->tif_dir.td_samplesperpixel; na++, nb++)\n\t\t*na=value;\n\to=TIFFWriteDirectoryTagCheckedShortArray(tif,ndir,dir,tag,tif->tif_dir.td_samplesperpixel,m);\n\t_TIFFfree(m);\n\treturn(o);\n}",
        "begin_line": 1261,
        "end_line": 1285,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dumpmode.TIFFInitDumpMode#123",
        "src_path": "libtiff/tif_dumpmode.c",
        "class_name": "libtiff.tif_dumpmode",
        "signature": "libtiff.tif_dumpmode.TIFFInitDumpMode(TIFF* tif, int scheme)",
        "snippet": "int\nTIFFInitDumpMode(TIFF* tif, int scheme)\n{\n\t(void) scheme;\n\ttif->tif_fixuptags = DumpFixupTags;  \n\ttif->tif_decoderow = DumpModeDecode;\n\ttif->tif_decodestrip = DumpModeDecode;\n\ttif->tif_decodetile = DumpModeDecode;\n\ttif->tif_encoderow = DumpModeEncode;\n\ttif->tif_encodestrip = DumpModeEncode;\n\ttif->tif_encodetile = DumpModeEncode; \n\ttif->tif_seek = DumpModeSeek;\n\treturn (1);\n}",
        "begin_line": 123,
        "end_line": 136,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_error.TIFFError#50",
        "src_path": "libtiff/tif_error.c",
        "class_name": "libtiff.tif_error",
        "signature": "libtiff.tif_error.TIFFError(const char* module, const char* fmt, ...)",
        "snippet": "void\nTIFFError(const char* module, const char* fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tif (_TIFFerrorHandler)\n\t\t(*_TIFFerrorHandler)(module, fmt, ap);\n\tif (_TIFFerrorHandlerExt)\n\t\t(*_TIFFerrorHandlerExt)(0, module, fmt, ap);\n\tva_end(ap);\n}",
        "begin_line": 50,
        "end_line": 60,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_error.TIFFErrorExt#62",
        "src_path": "libtiff/tif_error.c",
        "class_name": "libtiff.tif_error",
        "signature": "libtiff.tif_error.TIFFErrorExt(thandle_t fd, const char* module, const char* fmt, ...)",
        "snippet": "void\nTIFFErrorExt(thandle_t fd, const char* module, const char* fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tif (_TIFFerrorHandler)\n\t\t(*_TIFFerrorHandler)(module, fmt, ap);\n\tif (_TIFFerrorHandlerExt)\n\t\t(*_TIFFerrorHandlerExt)(fd, module, fmt, ap);\n\tva_end(ap);\n}",
        "begin_line": 62,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_flush.TIFFFlush#32",
        "src_path": "libtiff/tif_flush.c",
        "class_name": "libtiff.tif_flush",
        "signature": "libtiff.tif_flush.TIFFFlush(TIFF* tif)",
        "snippet": "int\nTIFFFlush(TIFF* tif)\n{\n    if( tif->tif_mode == O_RDONLY )\n        return 1;\n\n    if (!TIFFFlushData(tif))\n        return (0);\n                \n    /* In update (r+) mode we try to detect the case where \n       only the strip/tile map has been altered, and we try to \n       rewrite only that portion of the directory without \n       making any other changes */\n                \n    if( (tif->tif_flags & TIFF_DIRTYSTRIP)\n        && !(tif->tif_flags & TIFF_DIRTYDIRECT) \n        && tif->tif_mode == O_RDWR )\n    {\n        uint64  *offsets=NULL, *sizes=NULL;\n\n        if( TIFFIsTiled(tif) )\n        {\n            if( TIFFGetField( tif, TIFFTAG_TILEOFFSETS, &offsets ) \n                && TIFFGetField( tif, TIFFTAG_TILEBYTECOUNTS, &sizes ) \n                && _TIFFRewriteField( tif, TIFFTAG_TILEOFFSETS, TIFF_LONG8, \n                                      tif->tif_dir.td_nstrips, offsets )\n                && _TIFFRewriteField( tif, TIFFTAG_TILEBYTECOUNTS, TIFF_LONG8, \n                                      tif->tif_dir.td_nstrips, sizes ) )\n            {\n                tif->tif_flags &= ~TIFF_DIRTYSTRIP;\n                tif->tif_flags &= ~TIFF_BEENWRITING;\n                return 1;\n            }\n        }\n        else\n        {\n            if( TIFFGetField( tif, TIFFTAG_STRIPOFFSETS, &offsets ) \n                && TIFFGetField( tif, TIFFTAG_STRIPBYTECOUNTS, &sizes ) \n                && _TIFFRewriteField( tif, TIFFTAG_STRIPOFFSETS, TIFF_LONG8, \n                                      tif->tif_dir.td_nstrips, offsets )\n                && _TIFFRewriteField( tif, TIFFTAG_STRIPBYTECOUNTS, TIFF_LONG8, \n                                      tif->tif_dir.td_nstrips, sizes ) )\n            {\n                tif->tif_flags &= ~TIFF_DIRTYSTRIP;\n                tif->tif_flags &= ~TIFF_BEENWRITING;\n                return 1;\n            }\n        }\n    }\n\n    if ((tif->tif_flags & (TIFF_DIRTYDIRECT|TIFF_DIRTYSTRIP)) \n        && !TIFFRewriteDirectory(tif))\n        return (0);\n\n    return (1);\n}",
        "begin_line": 32,
        "end_line": 87,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_flush.TIFFFlushData#98",
        "src_path": "libtiff/tif_flush.c",
        "class_name": "libtiff.tif_flush",
        "signature": "libtiff.tif_flush.TIFFFlushData(TIFF* tif)",
        "snippet": "int\nTIFFFlushData(TIFF* tif)\n{\n\tif ((tif->tif_flags & TIFF_BEENWRITING) == 0)\n\t\treturn (1);\n\tif (tif->tif_flags & TIFF_POSTENCODE) {\n\t\ttif->tif_flags &= ~TIFF_POSTENCODE;\n\t\tif (!(*tif->tif_postencode)(tif))\n\t\t\treturn (0);\n\t}\n\treturn (TIFFFlushData1(tif));\n}",
        "begin_line": 98,
        "end_line": 109,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.JPEGCleanup#2077",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.JPEGCleanup(TIFF* tif)",
        "snippet": "static void\nJPEGCleanup(TIFF* tif)\n{\n\tJPEGState *sp = JState(tif);\n\t\n\tassert(sp != 0);\n\n\ttif->tif_tagmethods.vgetfield = sp->vgetparent;\n\ttif->tif_tagmethods.vsetfield = sp->vsetparent;\n\ttif->tif_tagmethods.printdir = sp->printdir;\n        if( sp->cinfo_initialized )\n                TIFFjpeg_destroy(sp);\t/* release libjpeg resources */\n        if (sp->jpegtables)\t\t/* tag value */\n                _TIFFfree(sp->jpegtables);\n\t_TIFFfree(tif->tif_data);\t/* release local state */\n\ttif->tif_data = NULL;\n\n\t_TIFFSetDefaultCompressionState(tif);\n}",
        "begin_line": 2077,
        "end_line": 2095,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.JPEGFixupTags#696",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.JPEGFixupTags(TIFF* tif)",
        "snippet": "static int\nJPEGFixupTags(TIFF* tif)\n{\n#ifdef CHECK_JPEG_YCBCR_SUBSAMPLING\n\tif ((tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)&&\n\t    (tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&\n\t    (tif->tif_dir.td_samplesperpixel==3))\n\t\tJPEGFixupTagsSubsampling(tif);\n#endif\n        \n\treturn(1);\n}",
        "begin_line": 696,
        "end_line": 707,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.JPEGInitializeLibJPEG#2276",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.JPEGInitializeLibJPEG( TIFF * tif, int decompress )",
        "snippet": "static int JPEGInitializeLibJPEG( TIFF * tif, int decompress )\n{\n    JPEGState* sp = JState(tif);\n\n    if(sp->cinfo_initialized)\n    {\n        if( !decompress && sp->cinfo.comm.is_decompressor )\n            TIFFjpeg_destroy( sp );\n        else if( decompress && !sp->cinfo.comm.is_decompressor )\n            TIFFjpeg_destroy( sp );\n        else\n            return 1;\n\n        sp->cinfo_initialized = 0;\n    }\n\n    /*\n     * Initialize libjpeg.\n     */\n    if ( decompress ) {\n        if (!TIFFjpeg_create_decompress(sp))\n            return (0);\n    } else {\n        if (!TIFFjpeg_create_compress(sp))\n            return (0);\n#ifndef TIFF_JPEG_MAX_MEMORY_TO_USE\n#define TIFF_JPEG_MAX_MEMORY_TO_USE (10 * 1024 * 1024)\n#endif\n        /* Increase the max memory usable. This helps when creating files */\n        /* with \"big\" tile, without using libjpeg temporary files. */\n        /* For example a 512x512 tile with 3 bands */\n        /* requires 1.5 MB which is above libjpeg 1MB default */\n        if( sp->cinfo.c.mem->max_memory_to_use < TIFF_JPEG_MAX_MEMORY_TO_USE )\n            sp->cinfo.c.mem->max_memory_to_use = TIFF_JPEG_MAX_MEMORY_TO_USE;\n    }\n\n    sp->cinfo_initialized = TRUE;\n\n    return 1;\n}",
        "begin_line": 2276,
        "end_line": 2315,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.JPEGResetUpsampled#2097",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.JPEGResetUpsampled( TIFF* tif )",
        "snippet": "static void \nJPEGResetUpsampled( TIFF* tif )\n{\n\tJPEGState* sp = JState(tif);\n\tTIFFDirectory* td = &tif->tif_dir;\n\n\t/*\n\t * Mark whether returned data is up-sampled or not so TIFFStripSize\n\t * and TIFFTileSize return values that reflect the true amount of\n\t * data.\n\t */\n\ttif->tif_flags &= ~TIFF_UPSAMPLED;\n\tif (td->td_planarconfig == PLANARCONFIG_CONTIG) {\n\t\tif (td->td_photometric == PHOTOMETRIC_YCBCR &&\n\t\t    sp->jpegcolormode == JPEGCOLORMODE_RGB) {\n\t\t\ttif->tif_flags |= TIFF_UPSAMPLED;\n\t\t} else {\n#ifdef notdef\n\t\t\tif (td->td_ycbcrsubsampling[0] != 1 ||\n\t\t\t    td->td_ycbcrsubsampling[1] != 1)\n\t\t\t\t; /* XXX what about up-sampling? */\n#endif\n\t\t}\n\t}\n\n\t/*\n\t * Must recalculate cached tile size in case sampling state changed.\n\t * Should we really be doing this now if image size isn't set? \n\t */\n        if( tif->tif_tilesize > 0 )\n            tif->tif_tilesize = isTiled(tif) ? TIFFTileSize(tif) : (tmsize_t)(-1);   \n        if( tif->tif_scanlinesize > 0 )\n            tif->tif_scanlinesize = TIFFScanlineSize(tif); \n}",
        "begin_line": 2097,
        "end_line": 2130,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.JPEGSetupDecode#959",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.JPEGSetupDecode(TIFF* tif)",
        "snippet": "static int\nJPEGSetupDecode(TIFF* tif)\n{\n\tJPEGState* sp = JState(tif);\n\tTIFFDirectory *td = &tif->tif_dir;\n\n#if defined(JPEG_DUAL_MODE_8_12) && !defined(TIFFInitJPEG)\n        if( tif->tif_dir.td_bitspersample == 12 )\n            return TIFFReInitJPEG_12( tif, COMPRESSION_JPEG, 0 );\n#endif\n\n\tJPEGInitializeLibJPEG( tif, TRUE );\n\n\tassert(sp != NULL);\n\tassert(sp->cinfo.comm.is_decompressor);\n\n\t/* Read JPEGTables if it is present */\n\tif (TIFFFieldSet(tif,FIELD_JPEGTABLES)) {\n\t\tTIFFjpeg_tables_src(sp, tif);\n\t\tif(TIFFjpeg_read_header(sp,FALSE) != JPEG_HEADER_TABLES_ONLY) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, \"JPEGSetupDecode\", \"Bogus JPEGTables field\");\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/* Grab parameters that are same for all strips/tiles */\n\tsp->photometric = td->td_photometric;\n\tswitch (sp->photometric) {\n\tcase PHOTOMETRIC_YCBCR:\n\t\tsp->h_sampling = td->td_ycbcrsubsampling[0];\n\t\tsp->v_sampling = td->td_ycbcrsubsampling[1];\n\t\tbreak;\n\tdefault:\n\t\t/* TIFF 6.0 forbids subsampling of all other color spaces */\n\t\tsp->h_sampling = 1;\n\t\tsp->v_sampling = 1;\n\t\tbreak;\n\t}\n\n\t/* Set up for reading normal data */\n\tTIFFjpeg_data_src(sp, tif);\n\ttif->tif_postdecode = _TIFFNoPostDecode; /* override byte swapping */\n\treturn (1);\n}",
        "begin_line": 959,
        "end_line": 1002,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.JPEGSetupEncode#1576",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.JPEGSetupEncode(TIFF* tif)",
        "snippet": "static int\nJPEGSetupEncode(TIFF* tif)\n{\n\tJPEGState* sp = JState(tif);\n\tTIFFDirectory *td = &tif->tif_dir;\n\tstatic const char module[] = \"JPEGSetupEncode\";\n\n#if defined(JPEG_DUAL_MODE_8_12) && !defined(TIFFInitJPEG)\n        if( tif->tif_dir.td_bitspersample == 12 )\n            return TIFFReInitJPEG_12( tif, COMPRESSION_JPEG, 1 );\n#endif\n\n        JPEGInitializeLibJPEG( tif, FALSE );\n\n\tassert(sp != NULL);\n\tassert(!sp->cinfo.comm.is_decompressor);\n\n\tsp->photometric = td->td_photometric;\n\n\t/*\n\t * Initialize all JPEG parameters to default values.\n\t * Note that jpeg_set_defaults needs legal values for\n\t * in_color_space and input_components.\n\t */\n\tif (td->td_planarconfig == PLANARCONFIG_CONTIG) {\n\t\tsp->cinfo.c.input_components = td->td_samplesperpixel;\n\t\tif (sp->photometric == PHOTOMETRIC_YCBCR) {\n\t\t\tif (sp->jpegcolormode == JPEGCOLORMODE_RGB) {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\t} else {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_YCbCr;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((td->td_photometric == PHOTOMETRIC_MINISWHITE || td->td_photometric == PHOTOMETRIC_MINISBLACK) && td->td_samplesperpixel == 1)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_GRAYSCALE;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_RGB && td->td_samplesperpixel == 3)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_SEPARATED && td->td_samplesperpixel == 4)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_CMYK;\n\t\t\telse\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t\t}\n\t} else {\n\t\tsp->cinfo.c.input_components = 1;\n\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t}\n\tif (!TIFFjpeg_set_defaults(sp))\n\t\treturn (0);\n\t/* Set per-file parameters */\n\tswitch (sp->photometric) {\n\tcase PHOTOMETRIC_YCBCR:\n\t\tsp->h_sampling = td->td_ycbcrsubsampling[0];\n\t\tsp->v_sampling = td->td_ycbcrsubsampling[1];\n                if( sp->h_sampling == 0 || sp->v_sampling == 0 )\n                {\n                    TIFFErrorExt(tif->tif_clientdata, module,\n                            \"Invalig horizontal/vertical sampling value\");\n                    return (0);\n                }\n\n\t\t/*\n\t\t * A ReferenceBlackWhite field *must* be present since the\n\t\t * default value is inappropriate for YCbCr.  Fill in the\n\t\t * proper value if application didn't set it.\n\t\t */\n\t\t{\n\t\t\tfloat *ref;\n\t\t\tif (!TIFFGetField(tif, TIFFTAG_REFERENCEBLACKWHITE,\n\t\t\t\t\t  &ref)) {\n\t\t\t\tfloat refbw[6];\n\t\t\t\tlong top = 1L << td->td_bitspersample;\n\t\t\t\trefbw[0] = 0;\n\t\t\t\trefbw[1] = (float)(top-1L);\n\t\t\t\trefbw[2] = (float)(top>>1);\n\t\t\t\trefbw[3] = refbw[1];\n\t\t\t\trefbw[4] = refbw[2];\n\t\t\t\trefbw[5] = refbw[1];\n\t\t\t\tTIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE,\n\t\t\t\t\t     refbw);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PHOTOMETRIC_PALETTE:\t\t/* disallowed by Tech Note */\n\tcase PHOTOMETRIC_MASK:\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t  \"PhotometricInterpretation %d not allowed for JPEG\",\n\t\t\t  (int) sp->photometric);\n\t\treturn (0);\n\tdefault:\n\t\t/* TIFF 6.0 forbids subsampling of all other color spaces */\n\t\tsp->h_sampling = 1;\n\t\tsp->v_sampling = 1;\n\t\tbreak;\n\t}\n\n\t/* Verify miscellaneous parameters */\n\n\t/*\n\t * This would need work if libtiff ever supports different\n\t * depths for different components, or if libjpeg ever supports\n\t * run-time selection of depth.  Neither is imminent.\n\t */\n#ifdef JPEG_LIB_MK1\n        /* BITS_IN_JSAMPLE now permits 8 and 12 --- dgilbert */\n\tif (td->td_bitspersample != 8 && td->td_bitspersample != 12) \n#else\n\tif (td->td_bitspersample != BITS_IN_JSAMPLE )\n#endif\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"BitsPerSample %d not allowed for JPEG\",\n\t\t\t  (int) td->td_bitspersample);\n\t\treturn (0);\n\t}\n\tsp->cinfo.c.data_precision = td->td_bitspersample;\n#ifdef JPEG_LIB_MK1\n        sp->cinfo.c.bits_in_jsample = td->td_bitspersample;\n#endif\n\tif (isTiled(tif)) {\n\t\tif ((td->td_tilelength % (sp->v_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"JPEG tile height must be multiple of %d\",\n\t\t\t\t  sp->v_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t\tif ((td->td_tilewidth % (sp->h_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"JPEG tile width must be multiple of %d\",\n\t\t\t\t  sp->h_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\tif (td->td_rowsperstrip < td->td_imagelength &&\n\t\t    (td->td_rowsperstrip % (sp->v_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"RowsPerStrip must be multiple of %d for JPEG\",\n\t\t\t\t  sp->v_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/* Create a JPEGTables field if appropriate */\n\tif (sp->jpegtablesmode & (JPEGTABLESMODE_QUANT|JPEGTABLESMODE_HUFF)) {\n                if( sp->jpegtables == NULL\n                    || memcmp(sp->jpegtables,\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\",8) == 0 )\n                {\n                        if (!prepare_JPEGTables(tif))\n                                return (0);\n                        /* Mark the field present */\n                        /* Can't use TIFFSetField since BEENWRITING is already set! */\n                        tif->tif_flags |= TIFF_DIRTYDIRECT;\n                        TIFFSetFieldBit(tif, FIELD_JPEGTABLES);\n                }\n\t} else {\n\t\t/* We do not support application-supplied JPEGTables, */\n\t\t/* so mark the field not present */\n\t\tTIFFClrFieldBit(tif, FIELD_JPEGTABLES);\n\t}\n\n\t/* Direct libjpeg output to libtiff's output buffer */\n\tTIFFjpeg_data_dest(sp, tif);\n\n\treturn (1);\n}",
        "begin_line": 1576,
        "end_line": 1738,
        "is_bug": true
    },
    {
        "name": "libtiff.tif_jpeg.JPEGVGetField#2187",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.JPEGVGetField(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "static int\nJPEGVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tJPEGState* sp = JState(tif);\n\n\tassert(sp != NULL);\n\n\tswitch (tag) {\n\t\tcase TIFFTAG_JPEGTABLES:\n\t\t\t*va_arg(ap, uint32*) = sp->jpegtables_length;\n\t\t\t*va_arg(ap, void**) = sp->jpegtables;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGQUALITY:\n\t\t\t*va_arg(ap, int*) = sp->jpegquality;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGCOLORMODE:\n\t\t\t*va_arg(ap, int*) = sp->jpegcolormode;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGTABLESMODE:\n\t\t\t*va_arg(ap, int*) = sp->jpegtablesmode;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (*sp->vgetparent)(tif, tag, ap);\n\t}\n\treturn (1);\n}",
        "begin_line": 2187,
        "end_line": 2212,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.JPEGVSetField#2132",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.JPEGVSetField(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "static int\nJPEGVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tJPEGState* sp = JState(tif);\n\tconst TIFFField* fip;\n\tuint32 v32;\n\n\tassert(sp != NULL);\n\n\tswitch (tag) {\n\tcase TIFFTAG_JPEGTABLES:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 == 0) {\n\t\t\t/* XXX */\n\t\t\treturn (0);\n\t\t}\n\t\t_TIFFsetByteArray(&sp->jpegtables, va_arg(ap, void*), v32);\n\t\tsp->jpegtables_length = v32;\n\t\tTIFFSetFieldBit(tif, FIELD_JPEGTABLES);\n\t\tbreak;\n\tcase TIFFTAG_JPEGQUALITY:\n\t\tsp->jpegquality = (int) va_arg(ap, int);\n\t\treturn (1);\t\t\t/* pseudo tag */\n\tcase TIFFTAG_JPEGCOLORMODE:\n\t\tsp->jpegcolormode = (int) va_arg(ap, int);\n\t\tJPEGResetUpsampled( tif );\n\t\treturn (1);\t\t\t/* pseudo tag */\n\tcase TIFFTAG_PHOTOMETRIC:\n\t{\n\t\tint ret_value = (*sp->vsetparent)(tif, tag, ap);\n\t\tJPEGResetUpsampled( tif );\n\t\treturn ret_value;\n\t}\n\tcase TIFFTAG_JPEGTABLESMODE:\n\t\tsp->jpegtablesmode = (int) va_arg(ap, int);\n\t\treturn (1);\t\t\t/* pseudo tag */\n\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t/* mark the fact that we have a real ycbcrsubsampling! */\n\t\tsp->ycbcrsampling_fetched = 1;\n\t\t/* should we be recomputing upsampling info here? */\n\t\treturn (*sp->vsetparent)(tif, tag, ap);\n\tdefault:\n\t\treturn (*sp->vsetparent)(tif, tag, ap);\n\t}\n\n\tif ((fip = TIFFFieldWithTag(tif, tag)) != NULL) {\n\t\tTIFFSetFieldBit(tif, fip->field_bit);\n\t} else {\n\t\treturn (0);\n\t}\n\n\ttif->tif_flags |= TIFF_DIRTYDIRECT;\n\treturn (1);\n}",
        "begin_line": 2132,
        "end_line": 2185,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.TIFFInitJPEG#2317",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.TIFFInitJPEG(TIFF* tif, int scheme)",
        "snippet": "int\nTIFFInitJPEG(TIFF* tif, int scheme)\n{\n\tJPEGState* sp;\n\n\tassert(scheme == COMPRESSION_JPEG);\n\n\t/*\n\t * Merge codec-specific tag information.\n\t */\n\tif (!_TIFFMergeFields(tif, jpegFields, TIFFArrayCount(jpegFields))) {\n\t\tTIFFErrorExt(tif->tif_clientdata,\n\t\t\t     \"TIFFInitJPEG\",\n\t\t\t     \"Merging JPEG codec-specific tags failed\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Allocate state block so tag methods have storage to record values.\n\t */\n\ttif->tif_data = (uint8*) _TIFFmalloc(sizeof (JPEGState));\n\n\tif (tif->tif_data == NULL) {\n\t\tTIFFErrorExt(tif->tif_clientdata,\n\t\t\t     \"TIFFInitJPEG\", \"No space for JPEG state block\");\n\t\treturn 0;\n\t}\n        _TIFFmemset(tif->tif_data, 0, sizeof(JPEGState));\n\n\tsp = JState(tif);\n\tsp->tif = tif;\t\t\t\t/* back link */\n\n\t/*\n\t * Override parent get/set field methods.\n\t */\n\tsp->vgetparent = tif->tif_tagmethods.vgetfield;\n\ttif->tif_tagmethods.vgetfield = JPEGVGetField; /* hook for codec tags */\n\tsp->vsetparent = tif->tif_tagmethods.vsetfield;\n\ttif->tif_tagmethods.vsetfield = JPEGVSetField; /* hook for codec tags */\n\tsp->printdir = tif->tif_tagmethods.printdir;\n\ttif->tif_tagmethods.printdir = JPEGPrintDir;   /* hook for codec tags */\n\n\t/* Default values for codec-specific fields */\n\tsp->jpegtables = NULL;\n\tsp->jpegtables_length = 0;\n\tsp->jpegquality = 75;\t\t\t/* Default IJG quality */\n\tsp->jpegcolormode = JPEGCOLORMODE_RAW;\n\tsp->jpegtablesmode = JPEGTABLESMODE_QUANT | JPEGTABLESMODE_HUFF;\n        sp->ycbcrsampling_fetched = 0;\n\n\t/*\n\t * Install codec methods.\n\t */\n\ttif->tif_fixuptags = JPEGFixupTags;\n\ttif->tif_setupdecode = JPEGSetupDecode;\n\ttif->tif_predecode = JPEGPreDecode;\n\ttif->tif_decoderow = JPEGDecode;\n\ttif->tif_decodestrip = JPEGDecode;\n\ttif->tif_decodetile = JPEGDecode;\n\ttif->tif_setupencode = JPEGSetupEncode;\n\ttif->tif_preencode = JPEGPreEncode;\n\ttif->tif_postencode = JPEGPostEncode;\n\ttif->tif_encoderow = JPEGEncode;\n\ttif->tif_encodestrip = JPEGEncode;\n\ttif->tif_encodetile = JPEGEncode;  \n\ttif->tif_cleanup = JPEGCleanup;\n\tsp->defsparent = tif->tif_defstripsize;\n\ttif->tif_defstripsize = JPEGDefaultStripSize;\n\tsp->deftparent = tif->tif_deftilesize;\n\ttif->tif_deftilesize = JPEGDefaultTileSize;\n\ttif->tif_flags |= TIFF_NOBITREV;\t/* no bit reversal, please */\n\n        sp->cinfo_initialized = FALSE;\n\n\t/*\n        ** Create a JPEGTables field if no directory has yet been created. \n        ** We do this just to ensure that sufficient space is reserved for\n        ** the JPEGTables field.  It will be properly created the right\n        ** size later. \n        */\n        if( tif->tif_diroff == 0 )\n        {\n#define SIZE_OF_JPEGTABLES 2000\n/*\nThe following line assumes incorrectly that all JPEG-in-TIFF files will have\na JPEGTABLES tag generated and causes null-filled JPEGTABLES tags to be written\nwhen the JPEG data is placed with TIFFWriteRawStrip.  The field bit should be \nset, anyway, later when actual JPEGTABLES header is generated, so removing it \nhere hopefully is harmless.\n            TIFFSetFieldBit(tif, FIELD_JPEGTABLES);\n*/\n            sp->jpegtables_length = SIZE_OF_JPEGTABLES;\n            sp->jpegtables = (void *) _TIFFmalloc(sp->jpegtables_length);\n            if (sp->jpegtables)\n            {\n                _TIFFmemset(sp->jpegtables, 0, SIZE_OF_JPEGTABLES);\n            }\n            else\n            {\n                TIFFErrorExt(tif->tif_clientdata,\n\t\t\t     \"TIFFInitJPEG\",\n                             \"Failed to allocate memory for JPEG tables\");\n                return 0;\n            }\n#undef SIZE_OF_JPEGTABLES\n        }\n\n\treturn 1;\n}",
        "begin_line": 2317,
        "end_line": 2425,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.TIFFjpeg_create_compress#247",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.TIFFjpeg_create_compress(JPEGState* sp)",
        "snippet": "static int\nTIFFjpeg_create_compress(JPEGState* sp)\n{\n\t/* initialize JPEG error handling */\n\tsp->cinfo.c.err = jpeg_std_error(&sp->err);\n\tsp->err.error_exit = TIFFjpeg_error_exit;\n\tsp->err.output_message = TIFFjpeg_output_message;\n\n\t/* set client_data to avoid UMR warning from tools like Purify */\n\tsp->cinfo.c.client_data = NULL;\n\n\treturn CALLVJPEG(sp, jpeg_create_compress(&sp->cinfo.c));\n}",
        "begin_line": 247,
        "end_line": 259,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.TIFFjpeg_create_decompress#261",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.TIFFjpeg_create_decompress(JPEGState* sp)",
        "snippet": "static int\nTIFFjpeg_create_decompress(JPEGState* sp)\n{\n\t/* initialize JPEG error handling */\n\tsp->cinfo.d.err = jpeg_std_error(&sp->err);\n\tsp->err.error_exit = TIFFjpeg_error_exit;\n\tsp->err.output_message = TIFFjpeg_output_message;\n\n\t/* set client_data to avoid UMR warning from tools like Purify */\n\tsp->cinfo.d.client_data = NULL;\n\n\treturn CALLVJPEG(sp, jpeg_create_decompress(&sp->cinfo.d));\n}",
        "begin_line": 261,
        "end_line": 273,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.TIFFjpeg_data_src#591",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.TIFFjpeg_data_src(JPEGState* sp, TIFF* tif)",
        "snippet": "static void\nTIFFjpeg_data_src(JPEGState* sp, TIFF* tif)\n{\n\t(void) tif;\n\tsp->cinfo.d.src = &sp->src;\n\tsp->src.init_source = std_init_source;\n\tsp->src.fill_input_buffer = std_fill_input_buffer;\n\tsp->src.skip_input_data = std_skip_input_data;\n\tsp->src.resync_to_restart = jpeg_resync_to_restart;\n\tsp->src.term_source = std_term_source;\n\tsp->src.bytes_in_buffer = 0;\t\t/* for safety */\n\tsp->src.next_input_byte = NULL;\n}",
        "begin_line": 591,
        "end_line": 603,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.TIFFjpeg_destroy#371",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.TIFFjpeg_destroy(JPEGState* sp)",
        "snippet": "static int\nTIFFjpeg_destroy(JPEGState* sp)\n{\n\treturn CALLVJPEG(sp, jpeg_destroy(&sp->cinfo.comm));\n}",
        "begin_line": 371,
        "end_line": 375,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.TIFFjpeg_error_exit#212",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.TIFFjpeg_error_exit(j_common_ptr cinfo)",
        "snippet": "static void\nTIFFjpeg_error_exit(j_common_ptr cinfo)\n{\n\tJPEGState *sp = (JPEGState *) cinfo;\t/* NB: cinfo assumed first */\n\tchar buffer[JMSG_LENGTH_MAX];\n\n\t(*cinfo->err->format_message) (cinfo, buffer);\n\tTIFFErrorExt(sp->tif->tif_clientdata, \"JPEGLib\", \"%s\", buffer);\t\t/* display the error message */\n\tjpeg_abort(cinfo);\t\t\t/* clean up libjpeg state */\n\tLONGJMP(sp->exit_jmpbuf, 1);\t\t/* return to libtiff caller */\n}",
        "begin_line": 212,
        "end_line": 222,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.TIFFjpeg_read_header#333",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.TIFFjpeg_read_header(JPEGState* sp, boolean require_image)",
        "snippet": "static int\nTIFFjpeg_read_header(JPEGState* sp, boolean require_image)\n{\n\treturn CALLJPEG(sp, -1, jpeg_read_header(&sp->cinfo.d, require_image));\n}",
        "begin_line": 333,
        "end_line": 337,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.TIFFjpeg_set_defaults#275",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.TIFFjpeg_set_defaults(JPEGState* sp)",
        "snippet": "static int\nTIFFjpeg_set_defaults(JPEGState* sp)\n{\n\treturn CALLVJPEG(sp, jpeg_set_defaults(&sp->cinfo.c));\n}",
        "begin_line": 275,
        "end_line": 279,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.TIFFjpeg_tables_src#619",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.TIFFjpeg_tables_src(JPEGState* sp, TIFF* tif)",
        "snippet": "static void\nTIFFjpeg_tables_src(JPEGState* sp, TIFF* tif)\n{\n\tTIFFjpeg_data_src(sp, tif);\n\tsp->src.init_source = tables_init_source;\n}",
        "begin_line": 619,
        "end_line": 624,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.tables_init_source#610",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.tables_init_source(j_decompress_ptr cinfo)",
        "snippet": "static void\ntables_init_source(j_decompress_ptr cinfo)\n{\n\tJPEGState* sp = (JPEGState*) cinfo;\n\n\tsp->src.next_input_byte = (const JOCTET*) sp->jpegtables;\n\tsp->src.bytes_in_buffer = (size_t) sp->jpegtables_length;\n}",
        "begin_line": 610,
        "end_line": 617,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_open.TIFFClientOpen#72",
        "src_path": "libtiff/tif_open.c",
        "class_name": "libtiff.tif_open",
        "signature": "libtiff.tif_open.TIFFClientOpen( \tconst char* name, const char* mode, thandle_t clientdata, TIFFReadWriteProc readproc, TIFFReadWriteProc writeproc, TIFFSeekProc seekproc, TIFFCloseProc closeproc, TIFFSizeProc sizeproc, TIFFMapFileProc mapproc, TIFFUnmapFileProc unmapproc )",
        "snippet": "TIFF*\nTIFFClientOpen(\n\tconst char* name, const char* mode,\n\tthandle_t clientdata,\n\tTIFFReadWriteProc readproc,\n\tTIFFReadWriteProc writeproc,\n\tTIFFSeekProc seekproc,\n\tTIFFCloseProc closeproc,\n\tTIFFSizeProc sizeproc,\n\tTIFFMapFileProc mapproc,\n\tTIFFUnmapFileProc unmapproc\n)\n{\n\tstatic const char module[] = \"TIFFClientOpen\";\n\tTIFF *tif;\n\tint m;\n\tconst char* cp;\n\n\t/* The following are configuration checks. They should be redundant, but should not\n\t * compile to any actual code in an optimised release build anyway. If any of them\n\t * fail, (makefile-based or other) configuration is not correct */\n\tassert(sizeof(uint8)==1);\n\tassert(sizeof(int8)==1);\n\tassert(sizeof(uint16)==2);\n\tassert(sizeof(int16)==2);\n\tassert(sizeof(uint32)==4);\n\tassert(sizeof(int32)==4);\n\tassert(sizeof(uint64)==8);\n\tassert(sizeof(int64)==8);\n\tassert(sizeof(tmsize_t)==sizeof(void*));\n\t{\n\t\tunion{\n\t\t\tuint8 a8[2];\n\t\t\tuint16 a16;\n\t\t} n;\n\t\tn.a8[0]=1;\n\t\tn.a8[1]=0;\n\t\t#ifdef WORDS_BIGENDIAN\n\t\tassert(n.a16==256);\n\t\t#else\n\t\tassert(n.a16==1);\n\t\t#endif\n\t}\n\n\tm = _TIFFgetMode(mode, module);\n\tif (m == -1)\n\t\tgoto bad2;\n\ttif = (TIFF *)_TIFFmalloc((tmsize_t)(sizeof (TIFF) + strlen(name) + 1));\n\tif (tif == NULL) {\n\t\tTIFFErrorExt(clientdata, module, \"%s: Out of memory (TIFF structure)\", name);\n\t\tgoto bad2;\n\t}\n\t_TIFFmemset(tif, 0, sizeof (*tif));\n\ttif->tif_name = (char *)tif + sizeof (TIFF);\n\tstrcpy(tif->tif_name, name);\n\ttif->tif_mode = m &~ (O_CREAT|O_TRUNC);\n\ttif->tif_curdir = (uint16) -1;\t\t/* non-existent directory */\n\ttif->tif_curoff = 0;\n\ttif->tif_curstrip = (uint32) -1;\t/* invalid strip */\n\ttif->tif_row = (uint32) -1;\t\t/* read/write pre-increment */\n\ttif->tif_clientdata = clientdata;\n\tif (!readproc || !writeproc || !seekproc || !closeproc || !sizeproc) {\n\t\tTIFFErrorExt(clientdata, module,\n\t\t    \"One of the client procedures is NULL pointer.\");\n\t\tgoto bad2;\n\t}\n\ttif->tif_readproc = readproc;\n\ttif->tif_writeproc = writeproc;\n\ttif->tif_seekproc = seekproc;\n\ttif->tif_closeproc = closeproc;\n\ttif->tif_sizeproc = sizeproc;\n\tif (mapproc)\n\t\ttif->tif_mapproc = mapproc;\n\telse\n\t\ttif->tif_mapproc = _tiffDummyMapProc;\n\tif (unmapproc)\n\t\ttif->tif_unmapproc = unmapproc;\n\telse\n\t\ttif->tif_unmapproc = _tiffDummyUnmapProc;\n\t_TIFFSetDefaultCompressionState(tif);    /* setup default state */\n\t/*\n\t * Default is to return data MSB2LSB and enable the\n\t * use of memory-mapped files and strip chopping when\n\t * a file is opened read-only.\n\t */\n\ttif->tif_flags = FILLORDER_MSB2LSB;\n\tif (m == O_RDONLY )\n\t\ttif->tif_flags |= TIFF_MAPPED;\n\n\t#ifdef STRIPCHOP_DEFAULT\n\tif (m == O_RDONLY || m == O_RDWR)\n\t\ttif->tif_flags |= STRIPCHOP_DEFAULT;\n\t#endif\n\n\t/*\n\t * Process library-specific flags in the open mode string.\n\t * The following flags may be used to control intrinsic library\n\t * behaviour that may or may not be desirable (usually for\n\t * compatibility with some application that claims to support\n\t * TIFF but only supports some brain dead idea of what the\n\t * vendor thinks TIFF is):\n\t *\n\t * 'l' use little-endian byte order for creating a file\n\t * 'b' use big-endian byte order for creating a file\n\t * 'L' read/write information using LSB2MSB bit order\n\t * 'B' read/write information using MSB2LSB bit order\n\t * 'H' read/write information using host bit order\n\t * 'M' enable use of memory-mapped files when supported\n\t * 'm' disable use of memory-mapped files\n\t * 'C' enable strip chopping support when reading\n\t * 'c' disable strip chopping support\n\t * 'h' read TIFF header only, do not load the first IFD\n\t * '4' ClassicTIFF for creating a file (default)\n\t * '8' BigTIFF for creating a file\n\t *\n\t * The use of the 'l' and 'b' flags is strongly discouraged.\n\t * These flags are provided solely because numerous vendors,\n\t * typically on the PC, do not correctly support TIFF; they\n\t * only support the Intel little-endian byte order.  This\n\t * support is not configured by default because it supports\n\t * the violation of the TIFF spec that says that readers *MUST*\n\t * support both byte orders.  It is strongly recommended that\n\t * you not use this feature except to deal with busted apps\n\t * that write invalid TIFF.  And even in those cases you should\n\t * bang on the vendors to fix their software.\n\t *\n\t * The 'L', 'B', and 'H' flags are intended for applications\n\t * that can optimize operations on data by using a particular\n\t * bit order.  By default the library returns data in MSB2LSB\n\t * bit order for compatibility with older versions of this\n\t * library.  Returning data in the bit order of the native CPU\n\t * makes the most sense but also requires applications to check\n\t * the value of the FillOrder tag; something they probably do\n\t * not do right now.\n\t *\n\t * The 'M' and 'm' flags are provided because some virtual memory\n\t * systems exhibit poor behaviour when large images are mapped.\n\t * These options permit clients to control the use of memory-mapped\n\t * files on a per-file basis.\n\t *\n\t * The 'C' and 'c' flags are provided because the library support\n\t * for chopping up large strips into multiple smaller strips is not\n\t * application-transparent and as such can cause problems.  The 'c'\n\t * option permits applications that only want to look at the tags,\n\t * for example, to get the unadulterated TIFF tag information.\n\t */\n\tfor (cp = mode; *cp; cp++)\n\t\tswitch (*cp) {\n\t\t\tcase 'b':\n\t\t\t\t#ifndef WORDS_BIGENDIAN\n\t\t\t\tif (m&O_CREAT)\n\t\t\t\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t\t\t#endif\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\t#ifdef WORDS_BIGENDIAN\n\t\t\t\tif ((m&O_CREAT))\n\t\t\t\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t\t\t#endif\n\t\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\t\ttif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |\n\t\t\t\t    FILLORDER_MSB2LSB;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\ttif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |\n\t\t\t\t    FILLORDER_LSB2MSB;\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\ttif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |\n\t\t\t\t    HOST_FILLORDER;\n\t\t\t\tbreak;\n\t\t\tcase 'M':\n\t\t\t\tif (m == O_RDONLY)\n\t\t\t\t\ttif->tif_flags |= TIFF_MAPPED;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tif (m == O_RDONLY)\n\t\t\t\t\ttif->tif_flags &= ~TIFF_MAPPED;\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tif (m == O_RDONLY)\n\t\t\t\t\ttif->tif_flags |= TIFF_STRIPCHOP;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tif (m == O_RDONLY)\n\t\t\t\t\ttif->tif_flags &= ~TIFF_STRIPCHOP;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\t\ttif->tif_flags |= TIFF_HEADERONLY;\n\t\t\t\tbreak;\n\t\t\tcase '8':\n\t\t\t\tif (m&O_CREAT)\n\t\t\t\t\ttif->tif_flags |= TIFF_BIGTIFF;\n\t\t\t\tbreak;\n\t\t}\n\t/*\n\t * Read in TIFF header.\n\t */\n\tif ((m & O_TRUNC) ||\n\t    !ReadOK(tif, &tif->tif_header, sizeof (TIFFHeaderClassic))) {\n\t\tif (tif->tif_mode == O_RDONLY) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t\t    \"Cannot read TIFF header\");\n\t\t\tgoto bad;\n\t\t}\n\t\t/*\n\t\t * Setup header and write.\n\t\t */\n\t\t#ifdef WORDS_BIGENDIAN\n\t\ttif->tif_header.common.tiff_magic = (tif->tif_flags & TIFF_SWAB)\n\t\t    ? TIFF_LITTLEENDIAN : TIFF_BIGENDIAN;\n\t\t#else\n\t\ttif->tif_header.common.tiff_magic = (tif->tif_flags & TIFF_SWAB)\n\t\t    ? TIFF_BIGENDIAN : TIFF_LITTLEENDIAN;\n\t\t#endif\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\ttif->tif_header.common.tiff_version = TIFF_VERSION_CLASSIC;\n\t\t\ttif->tif_header.classic.tiff_diroff = 0;\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&tif->tif_header.common.tiff_version);\n\t\t\ttif->tif_header_size = sizeof(TIFFHeaderClassic);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttif->tif_header.common.tiff_version = TIFF_VERSION_BIG;\n\t\t\ttif->tif_header.big.tiff_offsetsize = 8;\n\t\t\ttif->tif_header.big.tiff_unused = 0;\n\t\t\ttif->tif_header.big.tiff_diroff = 0;\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t{\n\t\t\t\tTIFFSwabShort(&tif->tif_header.common.tiff_version);\n\t\t\t\tTIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);\n\t\t\t}\n\t\t\ttif->tif_header_size = sizeof (TIFFHeaderBig);\n\t\t}\n\t\t/*\n\t\t * The doc for \"fopen\" for some STD_C_LIBs says that if you\n\t\t * open a file for modify (\"+\"), then you must fseek (or\n\t\t * fflush?) between any freads and fwrites.  This is not\n\t\t * necessary on most systems, but has been shown to be needed\n\t\t * on Solaris.\n\t\t */\n\t\tTIFFSeekFile( tif, 0, SEEK_SET );\n\t\tif (!WriteOK(tif, &tif->tif_header, (tmsize_t)(tif->tif_header_size))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t\t    \"Error writing TIFF header\");\n\t\t\tgoto bad;\n\t\t}\n\t\t/*\n\t\t * Setup the byte order handling.\n\t\t */\n\t\tif (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN) {\n\t\t\t#ifndef WORDS_BIGENDIAN\n\t\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t\t#endif\n\t\t} else {\n\t\t\t#ifdef WORDS_BIGENDIAN\n\t\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t\t#endif\n\t\t}\n\t\t/*\n\t\t * Setup default directory.\n\t\t */\n\t\tif (!TIFFDefaultDirectory(tif))\n\t\t\tgoto bad;\n\t\ttif->tif_diroff = 0;\n\t\ttif->tif_dirlist = NULL;\n\t\ttif->tif_dirlistsize = 0;\n\t\ttif->tif_dirnumber = 0;\n\t\treturn (tif);\n\t}\n\t/*\n\t * Setup the byte order handling.\n\t */\n\tif (tif->tif_header.common.tiff_magic != TIFF_BIGENDIAN &&\n\t    tif->tif_header.common.tiff_magic != TIFF_LITTLEENDIAN\n\t    #if MDI_SUPPORT\n\t    &&\n\t    #if HOST_BIGENDIAN\n\t    tif->tif_header.common.tiff_magic != MDI_BIGENDIAN\n\t    #else\n\t    tif->tif_header.common.tiff_magic != MDI_LITTLEENDIAN\n\t    #endif\n\t    ) {\n\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t    \"Not a TIFF or MDI file, bad magic number %d (0x%x)\",\n\t    #else\n\t    ) {\n\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t    \"Not a TIFF file, bad magic number %d (0x%x)\",\n\t    #endif\n\t\t    tif->tif_header.common.tiff_magic,\n\t\t    tif->tif_header.common.tiff_magic);\n\t\tgoto bad;\n\t}\n\tif (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN) {\n\t\t#ifndef WORDS_BIGENDIAN\n\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t#endif\n\t} else {\n\t\t#ifdef WORDS_BIGENDIAN\n\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t#endif\n\t}\n\tif (tif->tif_flags & TIFF_SWAB) \n\t\tTIFFSwabShort(&tif->tif_header.common.tiff_version);\n\tif ((tif->tif_header.common.tiff_version != TIFF_VERSION_CLASSIC)&&\n\t    (tif->tif_header.common.tiff_version != TIFF_VERSION_BIG)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t    \"Not a TIFF file, bad version number %d (0x%x)\",\n\t\t    tif->tif_header.common.tiff_version,\n\t\t    tif->tif_header.common.tiff_version);\n\t\tgoto bad;\n\t}\n\tif (tif->tif_header.common.tiff_version == TIFF_VERSION_CLASSIC)\n\t{\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabLong(&tif->tif_header.classic.tiff_diroff);\n\t\ttif->tif_header_size = sizeof(TIFFHeaderClassic);\n\t}\n\telse\n\t{\n\t\tif (!ReadOK(tif, ((uint8*)(&tif->tif_header) + sizeof(TIFFHeaderClassic)), (sizeof(TIFFHeaderBig)-sizeof(TIFFHeaderClassic))))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t\t    \"Cannot read TIFF header\");\n\t\t\tgoto bad;\n\t\t}\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t{\n\t\t\tTIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);\n\t\t\tTIFFSwabLong8(&tif->tif_header.big.tiff_diroff);\n\t\t}\n\t\tif (tif->tif_header.big.tiff_offsetsize != 8)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t\t    \"Not a TIFF file, bad BigTIFF offsetsize %d (0x%x)\",\n\t\t\t    tif->tif_header.big.tiff_offsetsize,\n\t\t\t    tif->tif_header.big.tiff_offsetsize);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (tif->tif_header.big.tiff_unused != 0)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t\t    \"Not a TIFF file, bad BigTIFF unused %d (0x%x)\",\n\t\t\t    tif->tif_header.big.tiff_unused,\n\t\t\t    tif->tif_header.big.tiff_unused);\n\t\t\tgoto bad;\n\t\t}\n\t\ttif->tif_header_size = sizeof(TIFFHeaderBig);\n\t\ttif->tif_flags |= TIFF_BIGTIFF;\n\t}\n\ttif->tif_flags |= TIFF_MYBUFFER;\n\ttif->tif_rawcp = tif->tif_rawdata = 0;\n\ttif->tif_rawdatasize = 0;\n        tif->tif_rawdataoff = 0;\n        tif->tif_rawdataloaded = 0;\n\n\tswitch (mode[0]) {\n\t\tcase 'r':\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t\ttif->tif_nextdiroff = tif->tif_header.classic.tiff_diroff;\n\t\t\telse\n\t\t\t\ttif->tif_nextdiroff = tif->tif_header.big.tiff_diroff;\n\t\t\t/*\n\t\t\t * Try to use a memory-mapped file if the client\n\t\t\t * has not explicitly suppressed usage with the\n\t\t\t * 'm' flag in the open mode (see above).\n\t\t\t */\n\t\t\tif (tif->tif_flags & TIFF_MAPPED)\n\t\t\t{\n\t\t\t\ttoff_t n;\n\t\t\t\tif (TIFFMapFileContents(tif,(void**)(&tif->tif_base),&n))\n\t\t\t\t{\n\t\t\t\t\ttif->tif_size=(tmsize_t)n;\n\t\t\t\t\tassert((toff_t)tif->tif_size==n);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\ttif->tif_flags &= ~TIFF_MAPPED;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Sometimes we do not want to read the first directory (for example,\n\t\t\t * it may be broken) and want to proceed to other directories. I this\n\t\t\t * case we use the TIFF_HEADERONLY flag to open file and return\n\t\t\t * immediately after reading TIFF header.\n\t\t\t */\n\t\t\tif (tif->tif_flags & TIFF_HEADERONLY)\n\t\t\t\treturn (tif);\n\n\t\t\t/*\n\t\t\t * Setup initial directory.\n\t\t\t */\n\t\t\tif (TIFFReadDirectory(tif)) {\n\t\t\t\ttif->tif_rawcc = (tmsize_t)-1;\n\t\t\t\ttif->tif_flags |= TIFF_BUFFERSETUP;\n\t\t\t\treturn (tif);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\t/*\n\t\t\t * New directories are automatically append\n\t\t\t * to the end of the directory chain when they\n\t\t\t * are written out (see TIFFWriteDirectory).\n\t\t\t */\n\t\t\tif (!TIFFDefaultDirectory(tif))\n\t\t\t\tgoto bad;\n\t\t\treturn (tif);\n\t}\nbad:\n\ttif->tif_mode = O_RDONLY;\t/* XXX avoid flush */\n        TIFFCleanup(tif);\nbad2:\n\treturn ((TIFF*)0);\n}",
        "begin_line": 72,
        "end_line": 487,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_open.TIFFFileName#496",
        "src_path": "libtiff/tif_open.c",
        "class_name": "libtiff.tif_open",
        "signature": "libtiff.tif_open.TIFFFileName(TIFF* tif)",
        "snippet": "const char *\nTIFFFileName(TIFF* tif)\n{\n\treturn (tif->tif_name);\n}",
        "begin_line": 496,
        "end_line": 500,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_open.TIFFIsTiled#577",
        "src_path": "libtiff/tif_open.c",
        "class_name": "libtiff.tif_open",
        "signature": "libtiff.tif_open.TIFFIsTiled(TIFF* tif)",
        "snippet": "int\nTIFFIsTiled(TIFF* tif)\n{\n\treturn (isTiled(tif));\n}",
        "begin_line": 577,
        "end_line": 581,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_open._TIFFgetMode#48",
        "src_path": "libtiff/tif_open.c",
        "class_name": "libtiff.tif_open",
        "signature": "libtiff.tif_open._TIFFgetMode(const char* mode, const char* module)",
        "snippet": "int\n_TIFFgetMode(const char* mode, const char* module)\n{\n\tint m = -1;\n\n\tswitch (mode[0]) {\n\tcase 'r':\n\t\tm = O_RDONLY;\n\t\tif (mode[1] == '+')\n\t\t\tm = O_RDWR;\n\t\tbreak;\n\tcase 'w':\n\tcase 'a':\n\t\tm = O_RDWR|O_CREAT;\n\t\tif (mode[0] == 'w')\n\t\t\tm |= O_TRUNC;\n\t\tbreak;\n\tdefault:\n\t\tTIFFErrorExt(0, module, \"\\\"%s\\\": Bad mode\", mode);\n\t\tbreak;\n\t}\n\treturn (m);\n}",
        "begin_line": 48,
        "end_line": 70,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_read.TIFFCheckRead#1074",
        "src_path": "libtiff/tif_read.c",
        "class_name": "libtiff.tif_read",
        "signature": "libtiff.tif_read.TIFFCheckRead(TIFF* tif, int tiles)",
        "snippet": "static int\nTIFFCheckRead(TIFF* tif, int tiles)\n{\n\tif (tif->tif_mode == O_WRONLY) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"File not open for reading\");\n\t\treturn (0);\n\t}\n\tif (tiles ^ isTiled(tif)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, tiles ?\n\t\t    \"Can not read tiles from a stripped image\" :\n\t\t    \"Can not read scanlines from a tiled image\");\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
        "begin_line": 1074,
        "end_line": 1088,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_read.TIFFFillStrip#512",
        "src_path": "libtiff/tif_read.c",
        "class_name": "libtiff.tif_read",
        "signature": "libtiff.tif_read.TIFFFillStrip(TIFF* tif, uint32 strip)",
        "snippet": "int\nTIFFFillStrip(TIFF* tif, uint32 strip)\n{\n\tstatic const char module[] = \"TIFFFillStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\n        if (!_TIFFFillStriles( tif ) || !tif->tif_dir.td_stripbytecount)\n            return 0;\n\n\tif ((tif->tif_flags&TIFF_NOREADRAW)==0)\n\t{\n\t\tuint64 bytecount = td->td_stripbytecount[strip];\n\t\tif ((int64)bytecount <= 0) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"Invalid strip byte count %I64u, strip %lu\",\n\t\t\t\t     (unsigned __int64) bytecount,\n\t\t\t\t     (unsigned long) strip);\n#else\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"Invalid strip byte count %llu, strip %lu\",\n\t\t\t\t     (unsigned long long) bytecount,\n\t\t\t\t     (unsigned long) strip);\n#endif\n\t\t\treturn (0);\n\t\t}\n\t\tif (isMapped(tif) &&\n\t\t    (isFillOrder(tif, td->td_fillorder)\n\t\t    || (tif->tif_flags & TIFF_NOBITREV))) {\n\t\t\t/*\n\t\t\t * The image is mapped into memory and we either don't\n\t\t\t * need to flip bits or the compression routine is\n\t\t\t * going to handle this operation itself.  In this\n\t\t\t * case, avoid copying the raw data and instead just\n\t\t\t * reference the data from the memory mapped file\n\t\t\t * image.  This assumes that the decompression\n\t\t\t * routines do not modify the contents of the raw data\n\t\t\t * buffer (if they try to, the application will get a\n\t\t\t * fault since the file is mapped read-only).\n\t\t\t */\n\t\t\tif ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) {\n\t\t\t\t_TIFFfree(tif->tif_rawdata);\n\t\t\t\ttif->tif_rawdata = NULL;\n\t\t\t\ttif->tif_rawdatasize = 0;\n\t\t\t}\n\t\t\ttif->tif_flags &= ~TIFF_MYBUFFER;\n\t\t\t/*\n\t\t\t * We must check for overflow, potentially causing\n\t\t\t * an OOB read. Instead of simple\n\t\t\t *\n\t\t\t *  td->td_stripoffset[strip]+bytecount > tif->tif_size\n\t\t\t *\n\t\t\t * comparison (which can overflow) we do the following\n\t\t\t * two comparisons:\n\t\t\t */\n\t\t\tif (bytecount > (uint64)tif->tif_size ||\n\t\t\t    td->td_stripoffset[strip] > (uint64)tif->tif_size - bytecount) {\n\t\t\t\t/*\n\t\t\t\t * This error message might seem strange, but\n\t\t\t\t * it's what would happen if a read were done\n\t\t\t\t * instead.\n\t\t\t\t */\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\n\t\t\t\t\t\"Read error on strip %lu; \"\n\t\t\t\t\t\"got %I64u bytes, expected %I64u\",\n\t\t\t\t\t(unsigned long) strip,\n\t\t\t\t\t(unsigned __int64) tif->tif_size - td->td_stripoffset[strip],\n\t\t\t\t\t(unsigned __int64) bytecount);\n#else\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\n\t\t\t\t\t\"Read error on strip %lu; \"\n\t\t\t\t\t\"got %llu bytes, expected %llu\",\n\t\t\t\t\t(unsigned long) strip,\n\t\t\t\t\t(unsigned long long) tif->tif_size - td->td_stripoffset[strip],\n\t\t\t\t\t(unsigned long long) bytecount);\n#endif\n\t\t\t\ttif->tif_curstrip = NOSTRIP;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\ttif->tif_rawdatasize = (tmsize_t)bytecount;\n\t\t\ttif->tif_rawdata = tif->tif_base + (tmsize_t)td->td_stripoffset[strip];\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = (tmsize_t) bytecount;\n\n\t\t\t/* \n\t\t\t * When we have tif_rawdata reference directly into the memory mapped file\n\t\t\t * we need to be pretty careful about how we use the rawdata.  It is not\n\t\t\t * a general purpose working buffer as it normally otherwise is.  So we\n\t\t\t * keep track of this fact to avoid using it improperly.\n\t\t\t */\n\t\t\ttif->tif_flags |= TIFF_BUFFERMMAP;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Expand raw data buffer, if needed, to hold data\n\t\t\t * strip coming from file (perhaps should set upper\n\t\t\t * bound on the size of a buffer we'll use?).\n\t\t\t */\n\t\t\ttmsize_t bytecountm;\n\t\t\tbytecountm=(tmsize_t)bytecount;\n\t\t\tif ((uint64)bytecountm!=bytecount)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (bytecountm > tif->tif_rawdatasize) {\n\t\t\t\ttif->tif_curstrip = NOSTRIP;\n\t\t\t\tif ((tif->tif_flags & TIFF_MYBUFFER) == 0) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t    \"Data buffer too small to hold strip %lu\",\n\t\t\t\t\t    (unsigned long) strip);\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tif (!TIFFReadBufferSetup(tif, 0, bytecountm))\n\t\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags&TIFF_BUFFERMMAP) {\n\t\t\t\ttif->tif_curstrip = NOSTRIP;\n\t\t\t\tif (!TIFFReadBufferSetup(tif, 0, bytecountm))\n\t\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (TIFFReadRawStrip1(tif, strip, tif->tif_rawdata,\n\t\t\t\tbytecountm, module) != bytecountm)\n\t\t\t\treturn (0);\n\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = bytecountm;\n                        \n\t\t\tif (!isFillOrder(tif, td->td_fillorder) &&\n\t\t\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\t\t\tTIFFReverseBits(tif->tif_rawdata, bytecountm);\n                }\n\t}\n\treturn (TIFFStartStrip(tif, strip));\n}",
        "begin_line": 512,
        "end_line": 648,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_read.TIFFReadEncodedStrip#321",
        "src_path": "libtiff/tif_read.c",
        "class_name": "libtiff.tif_read",
        "signature": "libtiff.tif_read.TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)",
        "snippet": "tmsize_t\nTIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)\n{\n\tstatic const char module[] = \"TIFFReadEncodedStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 rowsperstrip;\n\tuint32 stripsperplane;\n\tuint32 stripinplane;\n\tuint16 plane;\n\tuint32 rows;\n\ttmsize_t stripsize;\n\tif (!TIFFCheckRead(tif,0))\n\t\treturn((tmsize_t)(-1));\n\tif (strip>=td->td_nstrips)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"%lu: Strip out of range, max %lu\",(unsigned long)strip,\n\t\t    (unsigned long)td->td_nstrips);\n\t\treturn((tmsize_t)(-1));\n\t}\n\t/*\n\t * Calculate the strip size according to the number of\n\t * rows in the strip (check for truncated last strip on any\n\t * of the separations).\n\t */\n\trowsperstrip=td->td_rowsperstrip;\n\tif (rowsperstrip>td->td_imagelength)\n\t\trowsperstrip=td->td_imagelength;\n\tstripsperplane= TIFFhowmany_32_maxuint_compat(td->td_imagelength, rowsperstrip);\n\tstripinplane=(strip%stripsperplane);\n\tplane=(uint16)(strip/stripsperplane);\n\trows=td->td_imagelength-stripinplane*rowsperstrip;\n\tif (rows>rowsperstrip)\n\t\trows=rowsperstrip;\n\tstripsize=TIFFVStripSize(tif,rows);\n\tif (stripsize==0)\n\t\treturn((tmsize_t)(-1));\n\n    /* shortcut to avoid an extra memcpy() */\n    if( td->td_compression == COMPRESSION_NONE &&\n        size!=(tmsize_t)(-1) && size >= stripsize &&\n        !isMapped(tif) &&\n        ((tif->tif_flags&TIFF_NOREADRAW)==0) )\n    {\n        if (TIFFReadRawStrip1(tif, strip, buf, stripsize, module) != stripsize)\n            return ((tmsize_t)(-1));\n\n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0)\n            TIFFReverseBits(buf,stripsize);\n\n        (*tif->tif_postdecode)(tif,buf,stripsize);\n        return (stripsize);\n    }\n\n\tif ((size!=(tmsize_t)(-1))&&(size<stripsize))\n\t\tstripsize=size;\n\tif (!TIFFFillStrip(tif,strip))\n\t\treturn((tmsize_t)(-1));\n\tif ((*tif->tif_decodestrip)(tif,buf,stripsize,plane)<=0)\n\t\treturn((tmsize_t)(-1));\n\t(*tif->tif_postdecode)(tif,buf,stripsize);\n\treturn(stripsize);\n}",
        "begin_line": 321,
        "end_line": 384,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_read.TIFFStartStrip#996",
        "src_path": "libtiff/tif_read.c",
        "class_name": "libtiff.tif_read",
        "signature": "libtiff.tif_read.TIFFStartStrip(TIFF* tif, uint32 strip)",
        "snippet": "static int\nTIFFStartStrip(TIFF* tif, uint32 strip)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\n        if (!_TIFFFillStriles( tif ) || !tif->tif_dir.td_stripbytecount)\n            return 0;\n\n\tif ((tif->tif_flags & TIFF_CODERSETUP) == 0) {\n\t\tif (!(*tif->tif_setupdecode)(tif))\n\t\t\treturn (0);\n\t\ttif->tif_flags |= TIFF_CODERSETUP;\n\t}\n\ttif->tif_curstrip = strip;\n\ttif->tif_row = (strip % td->td_stripsperimage) * td->td_rowsperstrip;\n        tif->tif_flags &= ~TIFF_BUF4WRITE;\n\n\tif (tif->tif_flags&TIFF_NOREADRAW)\n\t{\n\t\ttif->tif_rawcp = NULL;\n\t\ttif->tif_rawcc = 0;  \n\t}\n\telse\n\t{\n\t\ttif->tif_rawcp = tif->tif_rawdata;\n\t\ttif->tif_rawcc = (tmsize_t)td->td_stripbytecount[strip];\n\t}\n\treturn ((*tif->tif_predecode)(tif,\n\t\t\t(uint16)(strip / td->td_stripsperimage)));\n}",
        "begin_line": 996,
        "end_line": 1025,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip.TIFFNumberOfStrips#60",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip.TIFFNumberOfStrips(TIFF* tif)",
        "snippet": "uint32\nTIFFNumberOfStrips(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 nstrips;\n\n\tnstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :\n\t     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\tnstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel,\n\t\t    \"TIFFNumberOfStrips\");\n\treturn (nstrips);\n}",
        "begin_line": 60,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip.TIFFScanlineSize#330",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip.TIFFScanlineSize(TIFF* tif)",
        "snippet": "tmsize_t\nTIFFScanlineSize(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFScanlineSize\";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFScanlineSize64(tif);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m) {\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer arithmetic overflow\");\n\t\tn=0;\n\t}\n\treturn(n);\n}",
        "begin_line": 330,
        "end_line": 343,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip.TIFFScanlineSize64#273",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip.TIFFScanlineSize64(TIFF* tif)",
        "snippet": "uint64\nTIFFScanlineSize64(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFScanlineSize64\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint64 scanline_size;\n\tif (td->td_planarconfig==PLANARCONFIG_CONTIG)\n\t{\n\t\tif ((td->td_photometric==PHOTOMETRIC_YCBCR)&&\n\t\t    (td->td_samplesperpixel==3)&&\n\t\t    (!isUpSampled(tif)))\n\t\t{\n\t\t\tuint16 ycbcrsubsampling[2];\n\t\t\tuint16 samplingblock_samples;\n\t\t\tuint32 samplingblocks_hor;\n\t\t\tuint64 samplingrow_samples;\n\t\t\tuint64 samplingrow_size;\n\t\t\tif(td->td_samplesperpixel!=3)\n\t\t\t{\n                            TIFFErrorExt(tif->tif_clientdata,module,\n                                         \"Invalid td_samplesperpixel value\");\n                            return 0;\n\t\t\t}\n\t\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_YCBCRSUBSAMPLING,\n                                              ycbcrsubsampling+0,\n                                              ycbcrsubsampling+1);\n\t\t\tif (((ycbcrsubsampling[0]!=1)&&(ycbcrsubsampling[0]!=2)&&(ycbcrsubsampling[0]!=4)) ||\n\t\t\t    ((ycbcrsubsampling[1]!=1)&&(ycbcrsubsampling[1]!=2)&&(ycbcrsubsampling[1]!=4)))\n\t\t\t{\n                            TIFFErrorExt(tif->tif_clientdata,module,\n                                         \"Invalid YCbCr subsampling\");\n                            return 0;\n\t\t\t}\n\t\t\tsamplingblock_samples = ycbcrsubsampling[0]*ycbcrsubsampling[1]+2;\n\t\t\tsamplingblocks_hor = TIFFhowmany_32(td->td_imagewidth,ycbcrsubsampling[0]);\n\t\t\tsamplingrow_samples = _TIFFMultiply64(tif,samplingblocks_hor,samplingblock_samples,module);\n\t\t\tsamplingrow_size = TIFFhowmany_64(_TIFFMultiply64(tif,samplingrow_samples,td->td_bitspersample,module),8);\n\t\t\tscanline_size = (samplingrow_size/ycbcrsubsampling[1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint64 scanline_samples;\n\t\t\tscanline_samples=_TIFFMultiply64(tif,td->td_imagewidth,td->td_samplesperpixel,module);\n\t\t\tscanline_size=TIFFhowmany_64(_TIFFMultiply64(tif,scanline_samples,td->td_bitspersample,module),8);\n\t\t}\n\t}\n\telse\n        {\n\t\tscanline_size=TIFFhowmany_64(_TIFFMultiply64(tif,td->td_imagewidth,td->td_bitspersample,module),8);\n        }\n        if (scanline_size == 0)\n        {\n                TIFFErrorExt(tif->tif_clientdata,module,\"Computed scanline size is zero\");\n                return 0;\n        }\n\treturn(scanline_size);\n}",
        "begin_line": 273,
        "end_line": 329,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip.TIFFStripSize#211",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip.TIFFStripSize(TIFF* tif)",
        "snippet": "tmsize_t\nTIFFStripSize(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFStripSize\";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFStripSize64(tif);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\n\t\tn=0;\n\t}\n\treturn(n);\n}",
        "begin_line": 211,
        "end_line": 225,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip.TIFFStripSize64#202",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip.TIFFStripSize64(TIFF* tif)",
        "snippet": "uint64\nTIFFStripSize64(TIFF* tif)\n{\n\tTIFFDirectory* td = &tif->tif_dir;\n\tuint32 rps = td->td_rowsperstrip;\n\tif (rps > td->td_imagelength)\n\t\trps = td->td_imagelength;\n\treturn (TIFFVStripSize64(tif, rps));\n}",
        "begin_line": 202,
        "end_line": 210,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip.TIFFVStripSize#129",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip.TIFFVStripSize(TIFF* tif, uint32 nrows)",
        "snippet": "tmsize_t\nTIFFVStripSize(TIFF* tif, uint32 nrows)\n{\n\tstatic const char module[] = \"TIFFVStripSize\";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFVStripSize64(tif,nrows);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\n\t\tn=0;\n\t}\n\treturn(n);\n}",
        "begin_line": 129,
        "end_line": 143,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip.TIFFVStripSize64#77",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip.TIFFVStripSize64(TIFF* tif, uint32 nrows)",
        "snippet": "uint64\nTIFFVStripSize64(TIFF* tif, uint32 nrows)\n{\n\tstatic const char module[] = \"TIFFVStripSize64\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tif (nrows==(uint32)(-1))\n\t\tnrows=td->td_imagelength;\n\tif ((td->td_planarconfig==PLANARCONFIG_CONTIG)&&\n\t    (td->td_photometric == PHOTOMETRIC_YCBCR)&&\n\t    (!isUpSampled(tif)))\n\t{\n\t\t/*\n\t\t * Packed YCbCr data contain one Cb+Cr for every\n\t\t * HorizontalSampling*VerticalSampling Y values.\n\t\t * Must also roundup width and height when calculating\n\t\t * since images that are not a multiple of the\n\t\t * horizontal/vertical subsampling area include\n\t\t * YCbCr data for the extended image.\n\t\t */\n\t\tuint16 ycbcrsubsampling[2];\n\t\tuint16 samplingblock_samples;\n\t\tuint32 samplingblocks_hor;\n\t\tuint32 samplingblocks_ver;\n\t\tuint64 samplingrow_samples;\n\t\tuint64 samplingrow_size;\n\t\tif(td->td_samplesperpixel!=3)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t\t    \"Invalid td_samplesperpixel value\");\n\t\t\treturn 0;\n\t\t}\n\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_YCBCRSUBSAMPLING,ycbcrsubsampling+0,\n\t\t    ycbcrsubsampling+1);\n\t\tif ((ycbcrsubsampling[0] != 1 && ycbcrsubsampling[0] != 2 && ycbcrsubsampling[0] != 4)\n\t\t    ||(ycbcrsubsampling[1] != 1 && ycbcrsubsampling[1] != 2 && ycbcrsubsampling[1] != 4))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t\t\t     \"Invalid YCbCr subsampling (%dx%d)\", \n\t\t\t\t     ycbcrsubsampling[0], \n\t\t\t\t     ycbcrsubsampling[1] );\n\t\t\treturn 0;\n\t\t}\n\t\tsamplingblock_samples=ycbcrsubsampling[0]*ycbcrsubsampling[1]+2;\n\t\tsamplingblocks_hor=TIFFhowmany_32(td->td_imagewidth,ycbcrsubsampling[0]);\n\t\tsamplingblocks_ver=TIFFhowmany_32(nrows,ycbcrsubsampling[1]);\n\t\tsamplingrow_samples=_TIFFMultiply64(tif,samplingblocks_hor,samplingblock_samples,module);\n\t\tsamplingrow_size=TIFFhowmany8_64(_TIFFMultiply64(tif,samplingrow_samples,td->td_bitspersample,module));\n\t\treturn(_TIFFMultiply64(tif,samplingrow_size,samplingblocks_ver,module));\n\t}\n\telse\n\t\treturn(_TIFFMultiply64(tif,nrows,TIFFScanlineSize64(tif),module));\n}",
        "begin_line": 77,
        "end_line": 128,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix.TIFFFdOpen#204",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix.TIFFFdOpen(int fd, const char* name, const char* mode)",
        "snippet": "TIFF*\nTIFFFdOpen(int fd, const char* name, const char* mode)\n{\n\tTIFF* tif;\n\n\tfd_as_handle_union_t fdh;\n\tfdh.fd = fd;\n\ttif = TIFFClientOpen(name, mode,\n\t    fdh.h,\n\t    _tiffReadProc, _tiffWriteProc,\n\t    _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,\n\t    _tiffMapProc, _tiffUnmapProc);\n\tif (tif)\n\t\ttif->tif_fd = fd;\n\treturn (tif);\n}",
        "begin_line": 204,
        "end_line": 219,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix.TIFFOpen#224",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix.TIFFOpen(const char* name, const char* mode)",
        "snippet": "TIFF*\nTIFFOpen(const char* name, const char* mode)\n{\n\tstatic const char module[] = \"TIFFOpen\";\n\tint m, fd;\n\tTIFF* tif;\n\n\tm = _TIFFgetMode(mode, module);\n\tif (m == -1)\n\t\treturn ((TIFF*)0);\n\n/* for cygwin and mingw */\n#ifdef O_BINARY\n\tm |= O_BINARY;\n#endif\n\n\tfd = open(name, m, 0666);\n\tif (fd < 0) {\n\t\tif (errno > 0 && strerror(errno) != NULL ) {\n\t\t\tTIFFErrorExt(0, module, \"%s: %s\", name, strerror(errno) );\n\t\t} else {\n\t\t\tTIFFErrorExt(0, module, \"%s: Cannot open\", name);\n\t\t}\n\t\treturn ((TIFF *)0);\n\t}\n\n\ttif = TIFFFdOpen((int)fd, name, mode);\n\tif(!tif)\n\t\tclose(fd);\n\treturn tif;\n}",
        "begin_line": 224,
        "end_line": 254,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._TIFFfree#319",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._TIFFfree(void* p)",
        "snippet": "void\n_TIFFfree(void* p)\n{\n\tfree(p);\n}",
        "begin_line": 319,
        "end_line": 323,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._TIFFmalloc#310",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._TIFFmalloc(tmsize_t s)",
        "snippet": "void*\n_TIFFmalloc(tmsize_t s)\n{\n        if (s == 0)\n                return ((void *) NULL);\n\n\treturn (malloc((size_t) s));\n}",
        "begin_line": 310,
        "end_line": 317,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._TIFFmemcpy#337",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._TIFFmemcpy(void* d, const void* s, tmsize_t c)",
        "snippet": "void\n_TIFFmemcpy(void* d, const void* s, tmsize_t c)\n{\n\tmemcpy(d, s, (size_t) c);\n}",
        "begin_line": 337,
        "end_line": 341,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._TIFFmemset#331",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._TIFFmemset(void* p, int v, tmsize_t c)",
        "snippet": "void\n_TIFFmemset(void* p, int v, tmsize_t c)\n{\n\tmemset(p, v, (size_t) c);\n}",
        "begin_line": 331,
        "end_line": 335,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._TIFFrealloc#325",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._TIFFrealloc(void* p, tmsize_t s)",
        "snippet": "void*\n_TIFFrealloc(void* p, tmsize_t s)\n{\n\treturn (realloc(p, (size_t) s));\n}",
        "begin_line": 325,
        "end_line": 329,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._tiffCloseProc#139",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._tiffCloseProc(thandle_t fd)",
        "snippet": "static int\n_tiffCloseProc(thandle_t fd)\n{\n\tfd_as_handle_union_t fdh;\n\tfdh.h = fd;\n\treturn(close(fdh.fd));\n}",
        "begin_line": 139,
        "end_line": 145,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._tiffMapProc#162",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._tiffMapProc(thandle_t fd, void** pbase, toff_t* psize)",
        "snippet": "static int\n_tiffMapProc(thandle_t fd, void** pbase, toff_t* psize)\n{\n\tuint64 size64 = _tiffSizeProc(fd);\n\ttmsize_t sizem = (tmsize_t)size64;\n\tif ((uint64)sizem==size64) {\n\t\tfd_as_handle_union_t fdh;\n\t\tfdh.h = fd;\n\t\t*pbase = (void*)\n\t\t    mmap(0, (size_t)sizem, PROT_READ, MAP_SHARED, fdh.fd, 0);\n\t\tif (*pbase != (void*) -1) {\n\t\t\t*psize = (tmsize_t)sizem;\n\t\t\treturn (1);\n\t\t}\n\t}\n\treturn (0);\n}",
        "begin_line": 162,
        "end_line": 178,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._tiffReadProc#68",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._tiffReadProc(thandle_t fd, void* buf, tmsize_t size)",
        "snippet": "static tmsize_t\n_tiffReadProc(thandle_t fd, void* buf, tmsize_t size)\n{\n\tfd_as_handle_union_t fdh;\n        const size_t bytes_total = (size_t) size;\n        size_t bytes_read;\n        tmsize_t count = -1;\n\tif ((tmsize_t) bytes_total != size)\n\t{\n\t\terrno=EINVAL;\n\t\treturn (tmsize_t) -1;\n\t}\n\tfdh.h = fd;\n        for (bytes_read=0; bytes_read < bytes_total; bytes_read+=count)\n        {\n                char *buf_offset = (char *) buf+bytes_read;\n                size_t io_size = bytes_total-bytes_read;\n                if (io_size > TIFF_IO_MAX)\n                        io_size = TIFF_IO_MAX;\n                count=read(fdh.fd, buf_offset, (TIFFIOSize_t) io_size);\n                if (count <= 0)\n                        break;\n        }\n        if (count < 0)\n                return (tmsize_t)-1;\n        return (tmsize_t) bytes_read;\n}",
        "begin_line": 68,
        "end_line": 94,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._tiffSeekProc#125",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._tiffSeekProc(thandle_t fd, uint64 off, int whence)",
        "snippet": "static uint64\n_tiffSeekProc(thandle_t fd, uint64 off, int whence)\n{\n\tfd_as_handle_union_t fdh;\n\t_TIFF_off_t off_io = (_TIFF_off_t) off;\n\tif ((uint64) off_io != off)\n\t{\n\t\terrno=EINVAL;\n\t\treturn (uint64) -1; /* this is really gross */\n\t}\n\tfdh.h = fd;\n\treturn((uint64)_TIFF_lseek_f(fdh.fd,off_io,whence));\n}",
        "begin_line": 125,
        "end_line": 137,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._tiffSizeProc#147",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._tiffSizeProc(thandle_t fd)",
        "snippet": "static uint64\n_tiffSizeProc(thandle_t fd)\n{\n\t_TIFF_stat_s sb;\n\tfd_as_handle_union_t fdh;\n\tfdh.h = fd;\n\tif (_TIFF_fstat_f(fdh.fd,&sb)<0)\n\t\treturn(0);\n\telse\n\t\treturn((uint64)sb.st_size);\n}",
        "begin_line": 147,
        "end_line": 157,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._tiffUnmapProc#180",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._tiffUnmapProc(thandle_t fd, void* base, toff_t size)",
        "snippet": "static void\n_tiffUnmapProc(thandle_t fd, void* base, toff_t size)\n{\n\t(void) fd;\n\t(void) munmap(base, (off_t) size);\n}",
        "begin_line": 180,
        "end_line": 185,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._tiffWriteProc#96",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._tiffWriteProc(thandle_t fd, void* buf, tmsize_t size)",
        "snippet": "static tmsize_t\n_tiffWriteProc(thandle_t fd, void* buf, tmsize_t size)\n{\n\tfd_as_handle_union_t fdh;\n\tconst size_t bytes_total = (size_t) size;\n        size_t bytes_written;\n        tmsize_t count = -1;\n\tif ((tmsize_t) bytes_total != size)\n\t{\n\t\terrno=EINVAL;\n\t\treturn (tmsize_t) -1;\n\t}\n\tfdh.h = fd;\n        for (bytes_written=0; bytes_written < bytes_total; bytes_written+=count)\n        {\n                const char *buf_offset = (char *) buf+bytes_written;\n                size_t io_size = bytes_total-bytes_written;\n                if (io_size > TIFF_IO_MAX)\n                        io_size = TIFF_IO_MAX;\n                count=write(fdh.fd, buf_offset, (TIFFIOSize_t) io_size);\n                if (count <= 0)\n                        break;\n        }\n        if (count < 0)\n                return (tmsize_t)-1;\n        return (tmsize_t) bytes_written;\n\t/* return ((tmsize_t) write(fdh.fd, buf, bytes_total)); */\n}",
        "begin_line": 96,
        "end_line": 123,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix.unixErrorHandler#360",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix.unixErrorHandler(const char* module, const char* fmt, va_list ap)",
        "snippet": "static void\nunixErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n\tif (module != NULL)\n\t\tfprintf(stderr, \"%s: \", module);\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \".\\n\");\n}",
        "begin_line": 360,
        "end_line": 367,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix.unixWarningHandler#349",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix.unixWarningHandler(const char* module, const char* fmt, va_list ap)",
        "snippet": "static void\nunixWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n\tif (module != NULL)\n\t\tfprintf(stderr, \"%s: \", module);\n\tfprintf(stderr, \"Warning, \");\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \".\\n\");\n}",
        "begin_line": 349,
        "end_line": 357,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_warning.TIFFWarningExt#62",
        "src_path": "libtiff/tif_warning.c",
        "class_name": "libtiff.tif_warning",
        "signature": "libtiff.tif_warning.TIFFWarningExt(thandle_t fd, const char* module, const char* fmt, ...)",
        "snippet": "void\nTIFFWarningExt(thandle_t fd, const char* module, const char* fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tif (_TIFFwarningHandler)\n\t\t(*_TIFFwarningHandler)(module, fmt, ap);\n\tif (_TIFFwarningHandlerExt)\n\t\t(*_TIFFwarningHandlerExt)(fd, module, fmt, ap);\n\tva_end(ap);\n}",
        "begin_line": 62,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_write.TIFFFlushData1#790",
        "src_path": "libtiff/tif_write.c",
        "class_name": "libtiff.tif_write",
        "signature": "libtiff.tif_write.TIFFFlushData1(TIFF* tif)",
        "snippet": "int\nTIFFFlushData1(TIFF* tif)\n{\n\tif (tif->tif_rawcc > 0 && tif->tif_flags & TIFF_BUF4WRITE ) {\n\t\tif (!isFillOrder(tif, tif->tif_dir.td_fillorder) &&\n\t\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\t\tTIFFReverseBits((uint8*)tif->tif_rawdata,\n\t\t\t    tif->tif_rawcc);\n\t\tif (!TIFFAppendToStrip(tif,\n\t\t    isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip,\n\t\t    tif->tif_rawdata, tif->tif_rawcc))\n        {\n            /* We update those variables even in case of error since there's */\n            /* code that doesn't really check the return code of this */\n            /* function */\n            tif->tif_rawcc = 0;\n            tif->tif_rawcp = tif->tif_rawdata;\n\t\t\treturn (0);\n        }\n\t\ttif->tif_rawcc = 0;\n\t\ttif->tif_rawcp = tif->tif_rawdata;\n\t}\n\treturn (1);\n}",
        "begin_line": 790,
        "end_line": 813,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_write.TIFFSetupStrips#526",
        "src_path": "libtiff/tif_write.c",
        "class_name": "libtiff.tif_write",
        "signature": "libtiff.tif_write.TIFFSetupStrips(TIFF* tif)",
        "snippet": "int\nTIFFSetupStrips(TIFF* tif)\n{\n\tTIFFDirectory* td = &tif->tif_dir;\n\n\tif (isTiled(tif))\n\t\ttd->td_stripsperimage =\n\t\t    isUnspecified(tif, FIELD_TILEDIMENSIONS) ?\n\t\t\ttd->td_samplesperpixel : TIFFNumberOfTiles(tif);\n\telse\n\t\ttd->td_stripsperimage =\n\t\t    isUnspecified(tif, FIELD_ROWSPERSTRIP) ?\n\t\t\ttd->td_samplesperpixel : TIFFNumberOfStrips(tif);\n\ttd->td_nstrips = td->td_stripsperimage;\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\ttd->td_stripsperimage /= td->td_samplesperpixel;\n\ttd->td_stripoffset = (uint64 *)\n\t    _TIFFmalloc(td->td_nstrips * sizeof (uint64));\n\ttd->td_stripbytecount = (uint64 *)\n\t    _TIFFmalloc(td->td_nstrips * sizeof (uint64));\n\tif (td->td_stripoffset == NULL || td->td_stripbytecount == NULL)\n\t\treturn (0);\n\t/*\n\t * Place data at the end-of-file\n\t * (by setting offsets to zero).\n\t */\n\t_TIFFmemset(td->td_stripoffset, 0, td->td_nstrips*sizeof (uint64));\n\t_TIFFmemset(td->td_stripbytecount, 0, td->td_nstrips*sizeof (uint64));\n\tTIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);\n\tTIFFSetFieldBit(tif, FIELD_STRIPBYTECOUNTS);\n\treturn (1);\n}",
        "begin_line": 526,
        "end_line": 557,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_write.TIFFWriteBufferSetup#637",
        "src_path": "libtiff/tif_write.c",
        "class_name": "libtiff.tif_write",
        "signature": "libtiff.tif_write.TIFFWriteBufferSetup(TIFF* tif, void* bp, tmsize_t size)",
        "snippet": "int\nTIFFWriteBufferSetup(TIFF* tif, void* bp, tmsize_t size)\n{\n\tstatic const char module[] = \"TIFFWriteBufferSetup\";\n\n\tif (tif->tif_rawdata) {\n\t\tif (tif->tif_flags & TIFF_MYBUFFER) {\n\t\t\t_TIFFfree(tif->tif_rawdata);\n\t\t\ttif->tif_flags &= ~TIFF_MYBUFFER;\n\t\t}\n\t\ttif->tif_rawdata = NULL;\n\t}\n\tif (size == (tmsize_t)(-1)) {\n\t\tsize = (isTiled(tif) ?\n\t\t    tif->tif_tilesize : TIFFStripSize(tif));\n\t\t/*\n\t\t * Make raw data buffer at least 8K\n\t\t */\n\t\tif (size < 8*1024)\n\t\t\tsize = 8*1024;\n\t\tbp = NULL;\t\t\t/* NB: force malloc */\n\t}\n\tif (bp == NULL) {\n\t\tbp = _TIFFmalloc(size);\n\t\tif (bp == NULL) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"No space for output buffer\");\n\t\t\treturn (0);\n\t\t}\n\t\ttif->tif_flags |= TIFF_MYBUFFER;\n\t} else\n\t\ttif->tif_flags &= ~TIFF_MYBUFFER;\n\ttif->tif_rawdata = (uint8*) bp;\n\ttif->tif_rawdatasize = size;\n\ttif->tif_rawcc = 0;\n\ttif->tif_rawcp = tif->tif_rawdata;\n\ttif->tif_flags |= TIFF_BUFFERSETUP;\n\treturn (1);\n}",
        "begin_line": 637,
        "end_line": 674,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_write.TIFFWriteCheck#566",
        "src_path": "libtiff/tif_write.c",
        "class_name": "libtiff.tif_write",
        "signature": "libtiff.tif_write.TIFFWriteCheck(TIFF* tif, int tiles, const char* module)",
        "snippet": "int\nTIFFWriteCheck(TIFF* tif, int tiles, const char* module)\n{\n\tif (tif->tif_mode == O_RDONLY) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"File not open for writing\");\n\t\treturn (0);\n\t}\n\tif (tiles ^ isTiled(tif)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, tiles ?\n\t\t    \"Can not write tiles to a stripped image\" :\n\t\t    \"Can not write scanlines to a tiled image\");\n\t\treturn (0);\n\t}\n\n        _TIFFFillStriles( tif );\n        \n\t/*\n\t * On the first write verify all the required information\n\t * has been setup and initialize any data structures that\n\t * had to wait until directory information was set.\n\t * Note that a lot of our work is assumed to remain valid\n\t * because we disallow any of the important parameters\n\t * from changing after we start writing (i.e. once\n\t * TIFF_BEENWRITING is set, TIFFSetField will only allow\n\t * the image's length to be changed).\n\t */\n\tif (!TIFFFieldSet(tif, FIELD_IMAGEDIMENSIONS)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Must set \\\"ImageWidth\\\" before writing data\");\n\t\treturn (0);\n\t}\n\tif (tif->tif_dir.td_samplesperpixel == 1) {\n\t\t/* \n\t\t * Planarconfiguration is irrelevant in case of single band\n\t\t * images and need not be included. We will set it anyway,\n\t\t * because this field is used in other parts of library even\n\t\t * in the single band case.\n\t\t */\n\t\tif (!TIFFFieldSet(tif, FIELD_PLANARCONFIG))\n                    tif->tif_dir.td_planarconfig = PLANARCONFIG_CONTIG;\n\t} else {\n\t\tif (!TIFFFieldSet(tif, FIELD_PLANARCONFIG)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Must set \\\"PlanarConfiguration\\\" before writing data\");\n\t\t\treturn (0);\n\t\t}\n\t}\n\tif (tif->tif_dir.td_stripoffset == NULL && !TIFFSetupStrips(tif)) {\n\t\ttif->tif_dir.td_nstrips = 0;\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"No space for %s arrays\",\n\t\t    isTiled(tif) ? \"tile\" : \"strip\");\n\t\treturn (0);\n\t}\n\tif (isTiled(tif))\n\t{\n\t\ttif->tif_tilesize = TIFFTileSize(tif);\n\t\tif (tif->tif_tilesize == 0)\n\t\t\treturn (0);\n\t}\n\telse\n\t\ttif->tif_tilesize = (tmsize_t)(-1);\n\ttif->tif_scanlinesize = TIFFScanlineSize(tif);\n\tif (tif->tif_scanlinesize == 0)\n\t\treturn (0);\n\ttif->tif_flags |= TIFF_BEENWRITING;\n\treturn (1);\n}",
        "begin_line": 566,
        "end_line": 632,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_write.TIFFWriteEncodedStrip#187",
        "src_path": "libtiff/tif_write.c",
        "class_name": "libtiff.tif_write",
        "signature": "libtiff.tif_write.TIFFWriteEncodedStrip(TIFF* tif, uint32 strip, void* data, tmsize_t cc)",
        "snippet": "tmsize_t\nTIFFWriteEncodedStrip(TIFF* tif, uint32 strip, void* data, tmsize_t cc)\n{\n\tstatic const char module[] = \"TIFFWriteEncodedStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint16 sample;\n\n\tif (!WRITECHECKSTRIPS(tif, module))\n\t\treturn ((tmsize_t) -1);\n\t/*\n\t * Check strip array to make sure there's space.\n\t * We don't support dynamically growing files that\n\t * have data organized in separate bitplanes because\n\t * it's too painful.  In that case we require that\n\t * the imagelength be set properly before the first\n\t * write (so that the strips array will be fully\n\t * allocated above).\n\t */\n\tif (strip >= td->td_nstrips) {\n\t\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Can not grow image by strips when using separate planes\");\n\t\t\treturn ((tmsize_t) -1);\n\t\t}\n\t\tif (!TIFFGrowStrips(tif, 1, module))\n\t\t\treturn ((tmsize_t) -1);\n\t\ttd->td_stripsperimage =\n\t\t    TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);  \n\t}\n\t/*\n\t * Handle delayed allocation of data buffer.  This\n\t * permits it to be sized according to the directory\n\t * info.\n\t */\n\tif (!BUFFERCHECK(tif))\n\t\treturn ((tmsize_t) -1);\n\n        tif->tif_flags |= TIFF_BUF4WRITE;\n\ttif->tif_curstrip = strip;\n\n        if (td->td_stripsperimage == 0) {\n                TIFFErrorExt(tif->tif_clientdata, module, \"Zero strips per image\");\n                return ((tmsize_t) -1);\n        }\n\n\ttif->tif_row = (strip % td->td_stripsperimage) * td->td_rowsperstrip;\n\tif ((tif->tif_flags & TIFF_CODERSETUP) == 0) {\n\t\tif (!(*tif->tif_setupencode)(tif))\n\t\t\treturn ((tmsize_t) -1);\n\t\ttif->tif_flags |= TIFF_CODERSETUP;\n\t}\n\n\tif( td->td_stripbytecount[strip] > 0 )\n        {\n            /* Make sure that at the first attempt of rewriting the tile, we will have */\n            /* more bytes available in the output buffer than the previous byte count, */\n            /* so that TIFFAppendToStrip() will detect the overflow when it is called the first */\n            /* time if the new compressed tile is bigger than the older one. (GDAL #4771) */\n            if( tif->tif_rawdatasize <= (tmsize_t)td->td_stripbytecount[strip] )\n            {\n                if( !(TIFFWriteBufferSetup(tif, NULL,\n                    (tmsize_t)TIFFroundup_64((uint64)(td->td_stripbytecount[strip] + 1), 1024))) )\n                    return ((tmsize_t)(-1));\n            }\n\n\t    /* Force TIFFAppendToStrip() to consider placing data at end\n               of file. */\n            tif->tif_curoff = 0;\n        }\n\n    tif->tif_rawcc = 0;\n    tif->tif_rawcp = tif->tif_rawdata;\n\n\ttif->tif_flags &= ~TIFF_POSTENCODE;\n\n    /* shortcut to avoid an extra memcpy() */\n    if( td->td_compression == COMPRESSION_NONE )\n    {\n        /* swab if needed - note that source buffer will be altered */\n        tif->tif_postdecode( tif, (uint8*) data, cc );\n\n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0)\n            TIFFReverseBits((uint8*) data, cc);\n\n        if (cc > 0 &&\n            !TIFFAppendToStrip(tif, strip, (uint8*) data, cc))\n            return ((tmsize_t) -1);\n        return (cc);\n    }\n\n\tsample = (uint16)(strip / td->td_stripsperimage);\n\tif (!(*tif->tif_preencode)(tif, sample))\n\t\treturn ((tmsize_t) -1);\n\n        /* swab if needed - note that source buffer will be altered */\n\ttif->tif_postdecode( tif, (uint8*) data, cc );\n\n\tif (!(*tif->tif_encodestrip)(tif, (uint8*) data, cc, sample))\n\t\treturn ((tmsize_t) -1);\n\tif (!(*tif->tif_postencode)(tif))\n\t\treturn ((tmsize_t) -1);\n\tif (!isFillOrder(tif, td->td_fillorder) &&\n\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\tTIFFReverseBits(tif->tif_rawdata, tif->tif_rawcc);\n\tif (tif->tif_rawcc > 0 &&\n\t    !TIFFAppendToStrip(tif, strip, tif->tif_rawdata, tif->tif_rawcc))\n\t\treturn ((tmsize_t) -1);\n\ttif->tif_rawcc = 0;\n\ttif->tif_rawcp = tif->tif_rawdata;\n\treturn (cc);\n}",
        "begin_line": 187,
        "end_line": 298,
        "is_bug": false
    },
    {
        "name": "tools.tiffcp.cpDecodedStrips#1003",
        "src_path": "tools/tiffcp.c",
        "class_name": "tools.tiffcp",
        "signature": "tools.tiffcp.cpDecodedStrips)",
        "snippet": "DECLAREcpFunc(cpDecodedStrips)\n{\n\ttsize_t stripsize  = TIFFStripSize(in);\n\ttdata_t buf = _TIFFmalloc(stripsize);\n\n\t(void) imagewidth; (void) spp;\n\tif (buf) {\n\t\ttstrip_t s, ns = TIFFNumberOfStrips(in);\n\t\tuint32 row = 0;\n\t\t_TIFFmemset(buf, 0, stripsize);\n\t\tfor (s = 0; s < ns && row < imagelength; s++) {\n\t\t\ttsize_t cc = (row + rowsperstrip > imagelength) ?\n\t\t\t    TIFFVStripSize(in, imagelength - row) : stripsize;\n\t\t\tif (TIFFReadEncodedStrip(in, s, buf, cc) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFWriteEncodedStrip(out, s, buf, cc) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\trow += rowsperstrip;\n\t\t}\n\t\t_TIFFfree(buf);\n\t\treturn 1;\n\t} else {\n\t\tTIFFError(TIFFFileName(in),\n\t\t    \"Error, can't allocate memory buffer of size %lu \"\n\t\t    \"to read strips\", (unsigned long) stripsize);\n\t\treturn 0;\n\t}\n\nbad:\n\t_TIFFfree(buf);\n\treturn 0;\n}",
        "begin_line": 1003,
        "end_line": 1043,
        "is_bug": false
    },
    {
        "name": "tools.tiffcp.cpTag#513",
        "src_path": "tools/tiffcp.c",
        "class_name": "tools.tiffcp",
        "signature": "tools.tiffcp.cpTag(TIFF* in, TIFF* out, uint16 tag, uint16 count, TIFFDataType type)",
        "snippet": "static void\ncpTag(TIFF* in, TIFF* out, uint16 tag, uint16 count, TIFFDataType type)\n{\n\tswitch (type) {\n\tcase TIFF_SHORT:\n\t\tif (count == 1) {\n\t\t\tuint16 shortv;\n\t\t\tCopyField(tag, shortv);\n\t\t} else if (count == 2) {\n\t\t\tuint16 shortv1, shortv2;\n\t\t\tCopyField2(tag, shortv1, shortv2);\n\t\t} else if (count == 4) {\n\t\t\tuint16 *tr, *tg, *tb, *ta;\n\t\t\tCopyField4(tag, tr, tg, tb, ta);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tuint16 shortv1;\n\t\t\tuint16* shortav;\n\t\t\tCopyField2(tag, shortv1, shortav);\n\t\t}\n\t\tbreak;\n\tcase TIFF_LONG:\n\t\t{ uint32 longv;\n\t\t  CopyField(tag, longv);\n\t\t}\n\t\tbreak;\n\tcase TIFF_RATIONAL:\n\t\tif (count == 1) {\n\t\t\tfloat floatv;\n\t\t\tCopyField(tag, floatv);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tfloat* floatav;\n\t\t\tCopyField(tag, floatav);\n\t\t}\n\t\tbreak;\n\tcase TIFF_ASCII:\n\t\t{ char* stringv;\n\t\t  CopyField(tag, stringv);\n\t\t}\n\t\tbreak;\n\tcase TIFF_DOUBLE:\n\t\tif (count == 1) {\n\t\t\tdouble doublev;\n\t\t\tCopyField(tag, doublev);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tdouble* doubleav;\n\t\t\tCopyField(tag, doubleav);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tTIFFError(TIFFFileName(in),\n\t\t    \"Data type %d is not supported, tag %d skipped.\",\n\t\t    tag, type);\n\t}\n}",
        "begin_line": 513,
        "end_line": 566,
        "is_bug": false
    },
    {
        "name": "tools.tiffcp.main#172",
        "src_path": "tools/tiffcp.c",
        "class_name": "tools.tiffcp",
        "signature": "tools.tiffcp.main(int argc, char* argv[])",
        "snippet": "int\nmain(int argc, char* argv[])\n{\n#ifdef DPP_ENABLE_GCOV\n\t  {\n\t\t  dpp_gcov_sigaction.sa_handler = dpp_sighandler;\n\t\t  sigemptyset(&dpp_gcov_sigaction.sa_mask);\n\t\t  dpp_gcov_sigaction.sa_flags = 0;\n\t\t  sigaction(SIGSEGV, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n\t\t  sigaction(SIGFPE, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n\t\t  sigaction(SIGABRT, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n\t  }\n#endif\n\tuint16 defconfig = (uint16) -1;\n\tuint16 deffillorder = 0;\n\tuint32 deftilewidth = (uint32) -1;\n\tuint32 deftilelength = (uint32) -1;\n\tuint32 defrowsperstrip = (uint32) 0;\n\tuint64 diroff = 0;\n\tTIFF* in;\n\tTIFF* out;\n\tchar mode[10];\n\tchar* mp = mode;\n\tint c;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char* optarg;\n#endif\n\n\t*mp++ = 'w';\n\t*mp = '\\0';\n\twhile ((c = getopt(argc, argv, \",:b:c:f:l:o:p:r:w:aistBLMC8x\")) != -1)\n\t\tswitch (c) {\n\t\tcase ',':\n\t\t\tif (optarg[0] != '=') usage();\n\t\t\tcomma = optarg[1];\n\t\t\tbreak;\n\t\tcase 'b':   /* this file is bias image subtracted from others */\n\t\t\tif (bias) {\n\t\t\t\tfputs (\"Only 1 bias image may be specified\\n\", stderr);\n\t\t\t\texit (-2);\n\t\t\t}\n\t\t\t{\n\t\t\t\tuint16 samples = (uint16) -1;\n\t\t\t\tchar **biasFn = &optarg;\n\t\t\t\tbias = openSrcImage (biasFn);\n\t\t\t\tif (!bias) exit (-5);\n\t\t\t\tif (TIFFIsTiled (bias)) {\n\t\t\t\t\tfputs (\"Bias image must be organized in strips\\n\", stderr);\n\t\t\t\t\texit (-7);\n\t\t\t\t}\n\t\t\t\tTIFFGetField(bias, TIFFTAG_SAMPLESPERPIXEL, &samples);\n\t\t\t\tif (samples != 1) {\n\t\t\t\t\tfputs (\"Bias image must be monochrome\\n\", stderr);\n\t\t\t\t\texit (-7);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a':   /* append to output */\n\t\t\tmode[0] = 'a';\n\t\t\tbreak;\n\t\tcase 'c':   /* compression scheme */\n\t\t\tif (!processCompressOptions(optarg))\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'f':   /* fill order */\n\t\t\tif (streq(optarg, \"lsb2msb\"))\n\t\t\t\tdeffillorder = FILLORDER_LSB2MSB;\n\t\t\telse if (streq(optarg, \"msb2lsb\"))\n\t\t\t\tdeffillorder = FILLORDER_MSB2LSB;\n\t\t\telse\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'i':   /* ignore errors */\n\t\t\tignore = TRUE;\n\t\t\tbreak;\n\t\tcase 'l':   /* tile length */\n\t\t\touttiled = TRUE;\n\t\t\tdeftilelength = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'o':   /* initial directory offset */\n\t\t\tdiroff = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'p':   /* planar configuration */\n\t\t\tif (streq(optarg, \"separate\"))\n\t\t\t\tdefconfig = PLANARCONFIG_SEPARATE;\n\t\t\telse if (streq(optarg, \"contig\"))\n\t\t\t\tdefconfig = PLANARCONFIG_CONTIG;\n\t\t\telse\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'r':   /* rows/strip */\n\t\t\tdefrowsperstrip = atol(optarg);\n\t\t\tbreak;\n\t\tcase 's':   /* generate stripped output */\n\t\t\touttiled = FALSE;\n\t\t\tbreak;\n\t\tcase 't':   /* generate tiled output */\n\t\t\touttiled = TRUE;\n\t\t\tbreak;\n\t\tcase 'w':   /* tile width */\n\t\t\touttiled = TRUE;\n\t\t\tdeftilewidth = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\t*mp++ = 'b'; *mp = '\\0';\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\t*mp++ = 'l'; *mp = '\\0';\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\t*mp++ = 'm'; *mp = '\\0';\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\t*mp++ = 'c'; *mp = '\\0';\n\t\t\tbreak;\n\t\tcase '8':\n\t\t\t*mp++ = '8'; *mp = '\\0';\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tpageInSeq = 1;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage();\n\t\t\t/*NOTREACHED*/\n\t\t}\n\tif (argc - optind < 2)\n\t\tusage();\n\tout = TIFFOpen(argv[argc-1], mode);\n\tif (out == NULL)\n\t\treturn (-2);\n\tif ((argc - optind) == 2)\n\t\tpageNum = -1;\n\tfor (; optind < argc-1 ; optind++) {\n\t\tchar *imageCursor = argv[optind];\n\t\tin = openSrcImage (&imageCursor);\n\t\tif (in == NULL) {\n\t\t\t(void) TIFFClose(out);\n\t\t\treturn (-3);\n\t\t}\n\t\tif (diroff != 0 && !TIFFSetSubDirectory(in, diroff)) {\n\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t    \"Error, setting subdirectory at \" TIFF_UINT64_FORMAT, diroff);\n\t\t\t(void) TIFFClose(in);\n\t\t\t(void) TIFFClose(out);\n\t\t\treturn (1);\n\t\t}\n\t\tfor (;;) {\n\t\t\tconfig = defconfig;\n\t\t\tcompression = defcompression;\n\t\t\tpredictor = defpredictor;\n                        preset = defpreset;\n\t\t\tfillorder = deffillorder;\n\t\t\trowsperstrip = defrowsperstrip;\n\t\t\ttilewidth = deftilewidth;\n\t\t\ttilelength = deftilelength;\n\t\t\tg3opts = defg3opts;\n\t\t\tif (!tiffcp(in, out) || !TIFFWriteDirectory(out)) {\n\t\t\t\t(void) TIFFClose(in);\n\t\t\t\t(void) TIFFClose(out);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tif (imageCursor) { /* seek next image directory */\n\t\t\t\tif (!nextSrcImage(in, &imageCursor)) break;\n\t\t\t}else\n\t\t\t\tif (!TIFFReadDirectory(in)) break;\n\t\t}\n\t\t(void) TIFFClose(in);\n\t}\n\n\t(void) TIFFClose(out);\n\treturn (0);\n}",
        "begin_line": 172,
        "end_line": 344,
        "is_bug": false
    },
    {
        "name": "tools.tiffcp.openSrcImage#129",
        "src_path": "tools/tiffcp.c",
        "class_name": "tools.tiffcp",
        "signature": "tools.tiffcp.openSrcImage (char **imageSpec) /*   imageSpec points to a pointer to a filename followed by optional, image#'s   Open the TIFF file and assign *imageSpec to either NULL if there are   no images specified, or a pointer to the next image number text */",
        "snippet": "static TIFF* openSrcImage (char **imageSpec)\n/*\n  imageSpec points to a pointer to a filename followed by optional ,image#'s\n  Open the TIFF file and assign *imageSpec to either NULL if there are\n  no images specified, or a pointer to the next image number text\n*/\n{\n\tTIFF *tif;\n\tchar *fn = *imageSpec;\n\t*imageSpec = strchr (fn, comma);\n\tif (*imageSpec) {  /* there is at least one image number specifier */\n\t\t**imageSpec = '\\0';\n\t\ttif = TIFFOpen (fn, \"r\");\n\t\t/* but, ignore any single trailing comma */\n\t\tif (!(*imageSpec)[1]) {*imageSpec = NULL; return tif;}\n\t\tif (tif) {\n\t\t\t**imageSpec = comma;  /* replace the comma */\n\t\t\tif (!nextSrcImage(tif, imageSpec)) {\n\t\t\t\tTIFFClose (tif);\n\t\t\t\ttif = NULL;\n\t\t\t}\n\t\t}\n\t}else\n\t\ttif = TIFFOpen (fn, \"r\");\n\treturn tif;\n}",
        "begin_line": 129,
        "end_line": 154,
        "is_bug": false
    },
    {
        "name": "tools.tiffcp.pickCopyFunc#1806",
        "src_path": "tools/tiffcp.c",
        "class_name": "tools.tiffcp",
        "signature": "tools.tiffcp.pickCopyFunc(TIFF* in, TIFF* out, uint16 bitspersample, uint16 samplesperpixel)",
        "snippet": "static copyFunc\npickCopyFunc(TIFF* in, TIFF* out, uint16 bitspersample, uint16 samplesperpixel)\n{\n\tuint16 shortv;\n\tuint32 w, l, tw, tl;\n\tint bychunk;\n\n\t(void) TIFFGetField(in, TIFFTAG_PLANARCONFIG, &shortv);\n\tif (shortv != config && bitspersample != 8 && samplesperpixel > 1) {\n\t\tfprintf(stderr,\n\t\t    \"%s: Cannot handle different planar configuration w/ bits/sample != 8\\n\",\n\t\t    TIFFFileName(in));\n\t\treturn (NULL);\n\t}\n\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w);\n\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &l);\n\tif (!(TIFFIsTiled(out) || TIFFIsTiled(in))) {\n\t\tuint32 irps = (uint32) -1L;\n\t\tTIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &irps);\n\t\t/* if biased, force decoded copying to allow image subtraction */\n\t\tbychunk = !bias && (rowsperstrip == irps);\n\t}else{  /* either in or out is tiled */\n\t\tif (bias) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: Cannot handle tiled configuration w/bias image\\n\",\n\t\t\tTIFFFileName(in));\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (TIFFIsTiled(out)) {\n\t\t\tif (!TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw))\n\t\t\t\ttw = w;\n\t\t\tif (!TIFFGetField(in, TIFFTAG_TILELENGTH, &tl))\n\t\t\t\ttl = l;\n\t\t\tbychunk = (tw == tilewidth && tl == tilelength);\n\t\t} else {  /* out's not, so in must be tiled */\n\t\t\tTIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t\t\tTIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\t\t\tbychunk = (tw == w && tl == rowsperstrip);\n\t\t}\n\t}\n#define\tT 1\n#define\tF 0\n#define pack(a,b,c,d,e)\t((long)(((a)<<11)|((b)<<3)|((c)<<2)|((d)<<1)|(e)))\n\tswitch(pack(shortv,config,TIFFIsTiled(in),TIFFIsTiled(out),bychunk)) {\n\t\t/* Strips -> Tiles */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,T,T):\n\t\t\treturn cpContigStrips2ContigTiles;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, F,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, F,T,T):\n\t\t\treturn cpContigStrips2SeparateTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,T,T):\n\t\t\treturn cpSeparateStrips2ContigTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,T,T):\n\t\t\treturn cpSeparateStrips2SeparateTiles;\n\t\t/* Tiles -> Tiles */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,T,T):\n\t\t\treturn cpContigTiles2ContigTiles;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,T,T):\n\t\t\treturn cpContigTiles2SeparateTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,T,T):\n\t\t\treturn cpSeparateTiles2ContigTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,T,T):\n\t\t\treturn cpSeparateTiles2SeparateTiles;\n\t\t/* Tiles -> Strips */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,F,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,F,T):\n\t\t\treturn cpContigTiles2ContigStrips;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,F,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,F,T):\n\t\t\treturn cpContigTiles2SeparateStrips;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,F,T):\n\t\t\treturn cpSeparateTiles2ContigStrips;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,F,T):\n\t\t\treturn cpSeparateTiles2SeparateStrips;\n\t\t/* Strips -> Strips */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,F,F):\n\t\t\treturn bias ? cpBiasedContig2Contig : cpContig2ContigByRow;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,F,T):\n\t\t\treturn cpDecodedStrips;\n\t\tcase pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE,   F,F,F):\n\t\tcase pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE,   F,F,T):\n\t\t\treturn cpContig2SeparateByRow;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,F,T):\n\t\t\treturn cpSeparate2ContigByRow;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,F,T):\n\t\t\treturn cpSeparate2SeparateByRow;\n\t}\n#undef pack\n#undef F\n#undef T\n\tfprintf(stderr, \"tiffcp: %s: Don't know how to copy/convert image.\\n\",\n\t    TIFFFileName(in));\n\treturn (NULL);\n}",
        "begin_line": 1806,
        "end_line": 1910,
        "is_bug": false
    },
    {
        "name": "tools.tiffcp.tiffcp#617",
        "src_path": "tools/tiffcp.c",
        "class_name": "tools.tiffcp",
        "signature": "tools.tiffcp.tiffcp(TIFF* in, TIFF* out)",
        "snippet": "static int\ntiffcp(TIFF* in, TIFF* out)\n{\n\tuint16 bitspersample, samplesperpixel = 1;\n\tuint16 input_compression, input_photometric = PHOTOMETRIC_MINISBLACK;\n\tcopyFunc cf;\n\tuint32 width, length;\n\tstruct cpTag* p;\n\n\tCopyField(TIFFTAG_IMAGEWIDTH, width);\n\tCopyField(TIFFTAG_IMAGELENGTH, length);\n\tCopyField(TIFFTAG_BITSPERSAMPLE, bitspersample);\n\tCopyField(TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);\n\tif (compression != (uint16)-1)\n\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n\telse\n\t\tCopyField(TIFFTAG_COMPRESSION, compression);\n\tTIFFGetFieldDefaulted(in, TIFFTAG_COMPRESSION, &input_compression);\n\tTIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric);\n\tif (input_compression == COMPRESSION_JPEG) {\n\t\t/* Force conversion to RGB */\n\t\tTIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t} else if (input_photometric == PHOTOMETRIC_YCBCR) {\n\t\t/* Otherwise, can't handle subsampled input */\n\t\tuint16 subsamplinghor,subsamplingver;\n\n\t\tTIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,\n\t\t\t\t      &subsamplinghor, &subsamplingver);\n\t\tif (subsamplinghor!=1 || subsamplingver!=1) {\n\t\t\tfprintf(stderr, \"tiffcp: %s: Can't copy/convert subsampled image.\\n\",\n\t\t\t\tTIFFFileName(in));\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\tif (compression == COMPRESSION_JPEG) {\n\t\tif (input_photometric == PHOTOMETRIC_RGB &&\n\t\t    jpegcolormode == JPEGCOLORMODE_RGB)\n\t\t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n\t\telse\n\t\t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);\n\t}\n\telse if (compression == COMPRESSION_SGILOG\n\t    || compression == COMPRESSION_SGILOG24)\n\t\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC,\n\t\t    samplesperpixel == 1 ?\n\t\t    PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);\n\telse if (input_compression == COMPRESSION_JPEG &&\n\t\t\t samplesperpixel == 3 ) {\n\t\t/* RGB conversion was forced above\n\t\thence the output will be of the same type */\n\t\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\t}\n\telse\n\t\tCopyTag(TIFFTAG_PHOTOMETRIC, 1, TIFF_SHORT);\n\tif (fillorder != 0)\n\t\tTIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\n\telse\n\t\tCopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);\n\t/*\n\t * Will copy `Orientation' tag from input image\n\t */\n\tTIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);\n\tswitch (orientation) {\n\t\tcase ORIENTATION_BOTRIGHT:\n\t\tcase ORIENTATION_RIGHTBOT:\t/* XXX */\n\t\t\tTIFFWarning(TIFFFileName(in), \"using bottom-left orientation\");\n\t\t\torientation = ORIENTATION_BOTLEFT;\n\t\t/* fall thru... */\n\t\tcase ORIENTATION_LEFTBOT:\t/* XXX */\n\t\tcase ORIENTATION_BOTLEFT:\n\t\t\tbreak;\n\t\tcase ORIENTATION_TOPRIGHT:\n\t\tcase ORIENTATION_RIGHTTOP:\t/* XXX */\n\t\tdefault:\n\t\t\tTIFFWarning(TIFFFileName(in), \"using top-left orientation\");\n\t\t\torientation = ORIENTATION_TOPLEFT;\n\t\t/* fall thru... */\n\t\tcase ORIENTATION_LEFTTOP:\t/* XXX */\n\t\tcase ORIENTATION_TOPLEFT:\n\t\t\tbreak;\n\t}\n\tTIFFSetField(out, TIFFTAG_ORIENTATION, orientation);\n\t/*\n\t * Choose tiles/strip for the output image according to\n\t * the command line arguments (-tiles, -strips) and the\n\t * structure of the input image.\n\t */\n\tif (outtiled == -1)\n\t\touttiled = TIFFIsTiled(in);\n\tif (outtiled) {\n\t\t/*\n\t\t * Setup output file's tile width&height.  If either\n\t\t * is not specified, use either the value from the\n\t\t * input image or, if nothing is defined, use the\n\t\t * library default.\n\t\t */\n\t\tif (tilewidth == (uint32) -1)\n\t\t\tTIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);\n\t\tif (tilelength == (uint32) -1)\n\t\t\tTIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);\n\t\tTIFFDefaultTileSize(out, &tilewidth, &tilelength);\n\t\tTIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);\n\t\tTIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);\n\t} else {\n\t\t/*\n\t\t * RowsPerStrip is left unspecified: use either the\n\t\t * value from the input image or, if nothing is defined,\n\t\t * use the library default.\n\t\t */\n\t\tif (rowsperstrip == (uint32) 0) {\n\t\t\tif (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP,\n\t\t\t    &rowsperstrip)) {\n\t\t\t\trowsperstrip =\n\t\t\t\t    TIFFDefaultStripSize(out, rowsperstrip);\n\t\t\t}\n\t\t\tif (rowsperstrip > length && rowsperstrip != (uint32)-1)\n\t\t\t\trowsperstrip = length;\n\t\t}\n\t\telse if (rowsperstrip == (uint32) -1)\n\t\t\trowsperstrip = length;\n\t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\t}\n\tif (config != (uint16) -1)\n\t\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\n\telse\n\t\tCopyField(TIFFTAG_PLANARCONFIG, config);\n\tif (samplesperpixel <= 4)\n\t\tCopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);\n\tCopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);\n/* SMinSampleValue & SMaxSampleValue */\n\tswitch (compression) {\n\t\tcase COMPRESSION_JPEG:\n\t\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n\t\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n\t\t\tbreak;\n\t\tcase COMPRESSION_JBIG:\n\t\t\tCopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\n\t\t\tCopyTag(TIFFTAG_FAXDCS, 1, TIFF_ASCII);\n\t\t\tbreak;\n\t\tcase COMPRESSION_LZW:\n\t\tcase COMPRESSION_ADOBE_DEFLATE:\n\t\tcase COMPRESSION_DEFLATE:\n                case COMPRESSION_LZMA:\n\t\t\tif (predictor != (uint16)-1)\n\t\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\t\t\telse\n\t\t\t\tCopyField(TIFFTAG_PREDICTOR, predictor);\n\t\t\tif (preset != -1) {\n                                if (compression == COMPRESSION_ADOBE_DEFLATE\n                                         || compression == COMPRESSION_DEFLATE)\n                                        TIFFSetField(out, TIFFTAG_ZIPQUALITY, preset);\n\t\t\t\telse if (compression == COMPRESSION_LZMA)\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_LZMAPRESET, preset);\n                        }\n\t\t\tbreak;\n\t\tcase COMPRESSION_CCITTFAX3:\n\t\tcase COMPRESSION_CCITTFAX4:\n\t\t\tif (compression == COMPRESSION_CCITTFAX3) {\n\t\t\t\tif (g3opts != (uint32) -1)\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_GROUP3OPTIONS,\n\t\t\t\t\t    g3opts);\n\t\t\t\telse\n\t\t\t\t\tCopyField(TIFFTAG_GROUP3OPTIONS, g3opts);\n\t\t\t} else\n\t\t\t\tCopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\n\t\t\tbreak;\n\t}\n\t{\n\t\tuint32 len32;\n\t\tvoid** data;\n\t\tif (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))\n\t\t\tTIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);\n\t}\n\t{\n\t\tuint16 ninks;\n\t\tconst char* inknames;\n\t\tif (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {\n\t\t\tTIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);\n\t\t\tif (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {\n\t\t\t\tint inknameslen = strlen(inknames) + 1;\n\t\t\t\tconst char* cp = inknames;\n\t\t\t\twhile (ninks > 1) {\n\t\t\t\t\tcp = strchr(cp, '\\0');\n                                        cp++;\n                                        inknameslen += (strlen(cp) + 1);\n\t\t\t\t\tninks--;\n\t\t\t\t}\n\t\t\t\tTIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tunsigned short pg0, pg1;\n\n\t\tif (pageInSeq == 1) {\n\t\t\tif (pageNum < 0) /* only one input file */ {\n\t\t\t\tif (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1))\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);\n\t\t\t} else\n\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);\n\n\t\t} else {\n\t\t\tif (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {\n\t\t\t\tif (pageNum < 0) /* only one input file */\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);\n\t\t\t\telse\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (p = tags; p < &tags[NTAGS]; p++)\n\t\tCopyTag(p->tag, p->count, p->type);\n\n\tcf = pickCopyFunc(in, out, bitspersample, samplesperpixel);\n\treturn (cf ? (*cf)(in, out, length, width, samplesperpixel) : FALSE);\n}",
        "begin_line": 617,
        "end_line": 841,
        "is_bug": false
    }
]