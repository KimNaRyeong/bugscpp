[
    {
        "name": "libyara.atoms._yr_atoms_choose#556",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_choose(     YR_ATOMS_CONFIG* config, YR_ATOM_TREE_NODE* node, YR_ATOM_LIST_ITEM** chosen_atoms, int* atoms_quality)",
        "snippet": "static int _yr_atoms_choose(\n    YR_ATOMS_CONFIG* config,\n    YR_ATOM_TREE_NODE* node,\n    YR_ATOM_LIST_ITEM** chosen_atoms,\n    int* atoms_quality)\n{\n  YR_ATOM_TREE_NODE* child;\n  YR_ATOM_LIST_ITEM* item;\n  YR_ATOM_LIST_ITEM* tail;\n\n  int shift, quality;\n\n  int max_quality = YR_MIN_ATOM_QUALITY;\n  int min_quality = YR_MAX_ATOM_QUALITY;\n\n  *chosen_atoms = NULL;\n  *atoms_quality = YR_MIN_ATOM_QUALITY;\n\n  switch (node->type)\n  {\n  case ATOM_TREE_LEAF:\n\n    item = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));\n\n    if (item == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    memcpy(&item->atom, &node->atom, sizeof(YR_ATOM));\n\n    shift = _yr_atoms_trim(&item->atom);\n\n    if (item->atom.length > 0)\n    {\n      item->forward_code = node->re_nodes[shift]->forward_code;\n      item->backward_code = node->re_nodes[shift]->backward_code;\n      item->backtrack = 0;\n      item->next = NULL;\n\n      *chosen_atoms = item;\n      *atoms_quality = config->get_atom_quality(config, &item->atom);\n    }\n    else\n    {\n      yr_free(item);\n    }\n\n    break;\n\n  case ATOM_TREE_OR:\n\n    // The choosen nodes are those coming from the highest quality child.\n\n    child = node->children_head;\n\n    while (child != NULL)\n    {\n      FAIL_ON_ERROR(_yr_atoms_choose(config, child, &item, &quality));\n\n      if (quality > max_quality)\n      {\n        max_quality = quality;\n        yr_atoms_list_destroy(*chosen_atoms);\n        *chosen_atoms = item;\n      }\n      else\n      {\n        yr_atoms_list_destroy(item);\n      }\n\n      if (max_quality == YR_MAX_ATOM_QUALITY)\n        break;\n\n      child = child->next_sibling;\n    }\n\n    *atoms_quality = max_quality;\n    break;\n\n  case ATOM_TREE_AND:\n\n    // The choosen nodes are the concatenation of the the nodes choosen from\n    // all the children.\n\n    child = node->children_head;\n\n    while (child != NULL)\n    {\n      FAIL_ON_ERROR(_yr_atoms_choose(config, child, &item, &quality));\n\n      if (quality < min_quality)\n        min_quality = quality;\n\n      if (item != NULL)\n      {\n        tail = item;\n        while (tail->next != NULL)\n          tail = tail->next;\n\n        tail->next = *chosen_atoms;\n        *chosen_atoms = item;\n      }\n\n      child = child->next_sibling;\n    }\n\n    *atoms_quality = min_quality;\n    break;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 556,
        "end_line": 666,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_expand_wildcards#1282",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_expand_wildcards(     YR_ATOM_LIST_ITEM* atoms)",
        "snippet": "static int _yr_atoms_expand_wildcards(\n    YR_ATOM_LIST_ITEM* atoms)\n{\n  int i;\n\n  YR_ATOM_LIST_ITEM* atom = atoms;\n  YR_ATOM_LIST_ITEM* new_atom;\n  YR_ATOM_LIST_ITEM* prev_atom;\n  YR_ATOM_LIST_ITEM* next_atom;\n\n  while (atom != NULL)\n  {\n    bool expanded = false;\n\n    for (i = 0; i < atom->atom.length; i++)\n    {\n      uint16_t a, s, e, incr = 1;\n\n      switch(atom->atom.mask[i])\n      {\n        case 0x00:\n          expanded = true;\n          s = 0x00;\n          e = 0xFF;\n          break;\n\n        case 0x0F:\n          expanded = true;\n          s = atom->atom.bytes[i];\n          e = atom->atom.bytes[i] | 0xF0;\n          incr = 0x10;\n          break;\n\n        case 0xF0:\n          expanded = true;\n          s = atom->atom.bytes[i];\n          e = atom->atom.bytes[i] | 0x0F;\n          break;\n\n        default:\n          s = 0;\n          e = 0;\n      }\n\n      if (s != e)\n      {\n        atom->atom.bytes[i] = (uint8_t) s;\n        atom->atom.mask[i] = 0xFF;\n      }\n\n      prev_atom = atom;\n      next_atom = atom->next;\n\n      for (a = s + incr; a <= e; a += incr)\n      {\n        new_atom = _yr_atoms_clone_list_item(atom);\n\n        if (new_atom == NULL)\n          return ERROR_INSUFFICIENT_MEMORY;\n\n        new_atom->atom.bytes[i] = (uint8_t) a;\n        new_atom->atom.mask[i] = 0xFF;\n        new_atom->next = next_atom;\n        prev_atom->next = new_atom;\n        prev_atom = new_atom;\n      }\n    }\n\n    if (!expanded)\n      atom = atom->next;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 1282,
        "end_line": 1355,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_extract_from_re#943",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_extract_from_re(     YR_ATOMS_CONFIG* config, RE_AST* re_ast, YR_ATOM_TREE_NODE* appending_node)",
        "snippet": "static int _yr_atoms_extract_from_re(\n    YR_ATOMS_CONFIG* config,\n    RE_AST* re_ast,\n    YR_ATOM_TREE_NODE* appending_node)\n{\n  YR_STACK* stack;\n  RE_NODE* re_node;\n\n  YR_ATOM atom;\n  YR_ATOM best_atom;\n\n  struct STACK_ITEM si;\n\n  int i, shift;\n  int quality;\n  int best_quality = -1;\n  int n = 0;\n\n  YR_ATOM_TREE_NODE* and_node;\n  YR_ATOM_TREE_NODE* left_node;\n  YR_ATOM_TREE_NODE* right_node;\n\n  // The RE_NODEs most recently visited that can conform an atom (ie:\n  // RE_NODE_LITERAL, RE_NODE_MASKED_LITERAL and RE_NODE_ANY). The number of\n  // items in this array is n.\n  RE_NODE* recent_re_nodes[YR_MAX_ATOM_LENGTH];\n\n  // The RE_NODEs corresponding to the best atom found so far for the current\n  // appending node.\n  RE_NODE* best_atom_re_nodes[YR_MAX_ATOM_LENGTH];\n\n  // This holds the ATOM_TREE_OR node where leaves (ATOM_TREE_LEAF) are\n  // currently being appended.\n  YR_ATOM_TREE_NODE* current_appending_node = NULL;\n\n  // This holds the ATOM_TREE_LEAF node whose atom is currently being updated.\n  YR_ATOM_TREE_NODE* leaf = NULL;\n\n  FAIL_ON_ERROR(yr_stack_create(1024, sizeof(si), &stack));\n\n  // This first item pushed in the stack is the last one to be poped out, its\n  // sole purpose is forcing that any pending\n  si.re_node = NULL;\n  si.new_appending_node = appending_node;\n\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      yr_stack_push(stack, (void*) &si),\n      yr_stack_destroy(stack));\n\n  // Start processing the root node.\n  si.re_node = re_ast->root_node;\n\n  // Leaf nodes are initially appended to the node passed in the appending_node,\n  // argument which is the root ATOM_TREE_OR node that is empty at this point.\n  si.new_appending_node = appending_node;\n\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      yr_stack_push(stack, (void*) &si),\n      yr_stack_destroy(stack));\n\n  while (yr_stack_pop(stack, (void*) &si))\n  {\n    // Change the appending node if the item poped from the stack says so.\n    if (si.new_appending_node != NULL)\n    {\n      // Before changing the appending node let's append any pending leaf to\n      // the current appending node.\n      if (n > 0)\n      {\n        make_atom_from_re_nodes(atom, n, recent_re_nodes);\n        shift = _yr_atoms_trim(&atom);\n        quality = config->get_atom_quality(config, &atom);\n\n        FAIL_ON_NULL_WITH_CLEANUP(\n            leaf = _yr_atoms_tree_node_create(ATOM_TREE_LEAF),\n            yr_stack_destroy(stack));\n\n        if (quality > best_quality)\n        {\n          memcpy(&leaf->atom, &atom, sizeof(atom));\n          memcpy(\n              &leaf->re_nodes,\n              &recent_re_nodes[shift],\n              sizeof(recent_re_nodes) - shift * sizeof(recent_re_nodes[0]));\n        }\n        else\n        {\n          memcpy(&leaf->atom, &best_atom, sizeof(best_atom));\n          memcpy(\n              &leaf->re_nodes,\n              &best_atom_re_nodes,\n              sizeof(best_atom_re_nodes));\n        }\n\n        _yr_atoms_tree_node_append(current_appending_node, leaf);\n        n = 0;\n      }\n\n      current_appending_node = si.new_appending_node;\n    }\n\n    if (si.re_node != NULL)\n    {\n      switch(si.re_node->type)\n      {\n        case RE_NODE_LITERAL:\n        case RE_NODE_MASKED_LITERAL:\n        case RE_NODE_ANY:\n\n          if (n < YR_MAX_ATOM_LENGTH)\n          {\n            recent_re_nodes[n] = si.re_node;\n            best_atom_re_nodes[n] = si.re_node;\n            best_atom.bytes[n] = (uint8_t) si.re_node->value;\n            best_atom.mask[n] = (uint8_t) si.re_node->mask;\n            best_atom.length = ++n;\n          }\n          else if (best_quality < YR_MAX_ATOM_QUALITY)\n          {\n            make_atom_from_re_nodes(atom, n, recent_re_nodes);\n            shift = _yr_atoms_trim(&atom);\n            quality = config->get_atom_quality(config, &atom);\n\n            if (quality > best_quality)\n            {\n              for (i = 0; i < atom.length; i++)\n              {\n                best_atom.bytes[i] = atom.bytes[i];\n                best_atom.mask[i] = atom.mask[i];\n                best_atom_re_nodes[i] = recent_re_nodes[i + shift];\n              }\n\n              best_quality = quality;\n            }\n\n            for (i = 1; i < YR_MAX_ATOM_LENGTH; i++)\n              recent_re_nodes[i - 1] = recent_re_nodes[i];\n\n            recent_re_nodes[YR_MAX_ATOM_LENGTH - 1] = si.re_node;\n          }\n\n          break;\n\n        case RE_NODE_CONCAT:\n\n          re_node = si.re_node->children_tail;\n\n          // Push children right to left, they are poped left to right.\n          while (re_node != NULL)\n          {\n            si.new_appending_node = NULL;\n            si.re_node = re_node;\n\n            FAIL_ON_ERROR_WITH_CLEANUP(\n                yr_stack_push(stack, &si),\n                yr_stack_destroy(stack));\n\n            re_node = re_node->prev_sibling;\n          }\n\n          break;\n\n        case RE_NODE_ALT:\n\n          // Create ATOM_TREE_AND node with two ATOM_TREE_OR children nodes.\n          and_node = _yr_atoms_tree_node_create(ATOM_TREE_AND);\n          left_node = _yr_atoms_tree_node_create(ATOM_TREE_OR);\n          right_node = _yr_atoms_tree_node_create(ATOM_TREE_OR);\n\n          if (and_node == NULL || left_node == NULL || right_node == NULL)\n          {\n            _yr_atoms_tree_node_destroy(and_node);\n            _yr_atoms_tree_node_destroy(left_node);\n            _yr_atoms_tree_node_destroy(right_node);\n\n            yr_stack_destroy(stack);\n\n            return ERROR_INSUFFICIENT_MEMORY;\n          }\n\n          and_node->children_head = left_node;\n          and_node->children_tail = right_node;\n          left_node->next_sibling = right_node;\n\n          // Add the ATOM_TREE_AND as children of the current node.\n          _yr_atoms_tree_node_append(current_appending_node, and_node);\n\n          re_node = si.re_node;\n\n          si.new_appending_node = current_appending_node;\n          si.re_node = NULL;\n\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              yr_stack_push(stack, &si),\n              yr_stack_destroy(stack));\n\n          // RE_NODE_ALT nodes has only two children, so children_head is the\n          // left one, and children_tail is right one.\n          si.new_appending_node = right_node;\n          si.re_node = re_node->children_tail;\n\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              yr_stack_push(stack, &si),\n              yr_stack_destroy(stack));\n\n          si.new_appending_node = left_node;\n          si.re_node = re_node->children_head;\n\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              yr_stack_push(stack, &si),\n              yr_stack_destroy(stack));\n\n          break;\n\n        case RE_NODE_PLUS:\n\n          re_node = si.re_node;\n\n          si.new_appending_node = current_appending_node;\n          si.re_node = NULL;\n\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              yr_stack_push(stack, &si),\n              yr_stack_destroy(stack));\n\n          si.new_appending_node = NULL;\n          // RE_NODE_PLUS nodes has a single child, which is children_head.\n          si.re_node = re_node->children_head;\n\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              yr_stack_push(stack, &si),\n              yr_stack_destroy(stack));\n\n          break;\n\n        case RE_NODE_RANGE:\n\n          re_node = si.re_node;\n\n          si.new_appending_node = current_appending_node;\n          si.re_node = NULL;\n\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              yr_stack_push(stack, &si),\n              yr_stack_destroy(stack));\n\n          si.new_appending_node = NULL;\n          // RE_NODE_RANGE nodes has a single child, which is children_head.\n          si.re_node = re_node->children_head;\n\n          // In a regexp like /a{10,20}/ the optimal atom is 'aaaa' (assuming\n          // that YR_MAX_ATOM_LENGTH = 4) because the 'a' character must appear\n          // at least 10 times in the matching string. Each call in the loop\n          // will append one 'a' to the atom, so YR_MAX_ATOM_LENGTH iterations\n          // are enough.\n\n          for (i = 0; i < yr_min(re_node->start, YR_MAX_ATOM_LENGTH); i++)\n          {\n            FAIL_ON_ERROR_WITH_CLEANUP(\n                yr_stack_push(stack, &si),\n                yr_stack_destroy(stack));\n          }\n\n          break;\n\n        case RE_NODE_RANGE_ANY:\n        case RE_NODE_STAR:\n        case RE_NODE_CLASS:\n        case RE_NODE_WORD_CHAR:\n        case RE_NODE_NON_WORD_CHAR:\n        case RE_NODE_SPACE:\n        case RE_NODE_NON_SPACE:\n        case RE_NODE_DIGIT:\n        case RE_NODE_NON_DIGIT:\n        case RE_NODE_EMPTY:\n        case RE_NODE_ANCHOR_START:\n        case RE_NODE_ANCHOR_END:\n        case RE_NODE_WORD_BOUNDARY:\n        case RE_NODE_NON_WORD_BOUNDARY:\n\n          si.new_appending_node = current_appending_node;\n          si.re_node = NULL;\n\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              yr_stack_push(stack, &si),\n              yr_stack_destroy(stack));\n\n          break;\n\n        default:\n          assert(false);\n      }\n    }\n  }\n\n  yr_stack_destroy(stack);\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 943,
        "end_line": 1241,
        "is_bug": true
    },
    {
        "name": "libyara.atoms._yr_atoms_tree_destroy#419",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_tree_destroy(     YR_ATOM_TREE* atom_tree)",
        "snippet": "static void _yr_atoms_tree_destroy(\n    YR_ATOM_TREE* atom_tree)\n{\n  _yr_atoms_tree_node_destroy(atom_tree->root_node);\n  yr_free(atom_tree);\n}",
        "begin_line": 419,
        "end_line": 424,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_tree_node_append#399",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_tree_node_append(     YR_ATOM_TREE_NODE* dest, YR_ATOM_TREE_NODE* node)",
        "snippet": "static void _yr_atoms_tree_node_append(\n    YR_ATOM_TREE_NODE* dest,\n    YR_ATOM_TREE_NODE* node)\n{\n  if (dest->children_head == NULL)\n    dest->children_head = node;\n\n  if (dest->children_tail != NULL)\n    dest->children_tail->next_sibling = node;\n\n  dest->children_tail = node;\n}",
        "begin_line": 399,
        "end_line": 410,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_tree_node_create#343",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_tree_node_create(     uint8_t type)",
        "snippet": "static YR_ATOM_TREE_NODE* _yr_atoms_tree_node_create(\n    uint8_t type)\n{\n  YR_ATOM_TREE_NODE* new_node = (YR_ATOM_TREE_NODE*) \\\n      yr_malloc(sizeof(YR_ATOM_TREE_NODE));\n\n  if (new_node != NULL)\n  {\n    new_node->type = type;\n    new_node->atom.length = 0;\n    new_node->next_sibling = NULL;\n    new_node->children_head = NULL;\n    new_node->children_tail = NULL;\n  }\n\n  return new_node;\n}",
        "begin_line": 343,
        "end_line": 359,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_tree_node_destroy#368",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_tree_node_destroy(     YR_ATOM_TREE_NODE* node)",
        "snippet": "static void _yr_atoms_tree_node_destroy(\n    YR_ATOM_TREE_NODE* node)\n{\n  YR_ATOM_TREE_NODE* child;\n  YR_ATOM_TREE_NODE* next_child;\n\n  if (node == NULL)\n    return;\n\n  if (node->type == ATOM_TREE_OR || node->type == ATOM_TREE_AND)\n  {\n    child = node->children_head;\n\n    while (child != NULL)\n    {\n      next_child = child->next_sibling;\n      _yr_atoms_tree_node_destroy(child);\n      child = next_child;\n    }\n  }\n\n  yr_free(node);\n}",
        "begin_line": 368,
        "end_line": 390,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_trim#490",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_trim(     YR_ATOM* atom)",
        "snippet": "int _yr_atoms_trim(\n    YR_ATOM* atom)\n{\n  int mask_00 = 0;\n  int mask_ff = 0;\n\n  int i, trim_left = 0;\n\n  while (trim_left < atom->length && atom->mask[trim_left] == 0)\n    trim_left++;\n\n  while (atom->length > trim_left && atom->mask[atom->length - 1] == 0)\n    atom->length--;\n\n  atom->length -= trim_left;\n\n  if (atom->length == 0)\n    return 0;\n\n  // At this point the actual atom goes from i to i + atom->length and the\n  // first and last byte in the atom are known (mask == 0xFF). Now count the\n  // number of known and unknown bytes in the atom (mask == 0xFF and\n  // mask == 0x00 respectively).\n\n  for (i = 0; i < atom->length; i++)\n  {\n    if (atom->mask[trim_left + i] == 0xFF)\n      mask_ff++;\n    else if (atom->mask[trim_left + i] == 0x00)\n      mask_00++;\n  }\n\n  // If the number of unknown bytes is >= than the number of known bytes\n  // it doesn't make sense the to use this atom, so we use the a single byte\n  // atom with the first known byte. If YR_MAX_ATOM_LENGTH == 4 this happens\n  // only when the atom is like { XX ?? ?? YY }, so using the first known\n  // atom is good enough. For larger values of YR_MAX_ATOM_LENGTH this is not\n  // the most efficient solution, as better atoms could be choosen. For\n  // example, in { XX ?? ?? ?? YY ZZ } the best atom is { YY ZZ } not { XX }.\n  // But let's keep it like this for simplicity.\n\n  if (mask_00 >= mask_ff)\n    atom->length = 1;\n\n  if (trim_left == 0)\n    return 0;\n\n  // Shift bytes and mask trim_left positions to the left.\n\n  for (i = 0; i < YR_MAX_ATOM_LENGTH - trim_left; i++)\n  {\n    atom->bytes[i] = atom->bytes[trim_left + i];\n    atom->mask[i] = atom->mask[trim_left + i];\n  }\n\n  return trim_left;\n}",
        "begin_line": 490,
        "end_line": 546,
        "is_bug": false
    },
    {
        "name": "libyara.atoms.yr_atoms_extract_from_re#1366",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms.yr_atoms_extract_from_re(     YR_ATOMS_CONFIG* config, RE_AST* re_ast, int flags, YR_ATOM_LIST_ITEM** atoms, int* min_atom_quality)",
        "snippet": "int yr_atoms_extract_from_re(\n    YR_ATOMS_CONFIG* config,\n    RE_AST* re_ast,\n    int flags,\n    YR_ATOM_LIST_ITEM** atoms,\n    int* min_atom_quality)\n{\n  YR_ATOM_TREE* atom_tree = (YR_ATOM_TREE*) yr_malloc(sizeof(YR_ATOM_TREE));\n\n  YR_ATOM_LIST_ITEM* wide_atoms;\n  YR_ATOM_LIST_ITEM* case_insensitive_atoms;\n\n  if (atom_tree == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  atom_tree->root_node = _yr_atoms_tree_node_create(ATOM_TREE_OR);\n\n  if (atom_tree->root_node == NULL)\n  {\n    _yr_atoms_tree_destroy(atom_tree);\n    return ERROR_INSUFFICIENT_MEMORY;\n  }\n\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      _yr_atoms_extract_from_re(config, re_ast, atom_tree->root_node),\n      _yr_atoms_tree_destroy(atom_tree));\n\n  // Initialize atom list\n  *atoms = NULL;\n\n  // Choose the atoms that will be used.\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      _yr_atoms_choose(config, atom_tree->root_node, atoms, min_atom_quality),\n      _yr_atoms_tree_destroy(atom_tree));\n\n  _yr_atoms_tree_destroy(atom_tree);\n\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      _yr_atoms_expand_wildcards(*atoms),\n      {\n        yr_atoms_list_destroy(*atoms);\n        *atoms = NULL;\n      });\n\n  if (flags & STRING_GFLAGS_WIDE)\n  {\n    FAIL_ON_ERROR_WITH_CLEANUP(\n        _yr_atoms_wide(*atoms, &wide_atoms),\n        {\n          yr_atoms_list_destroy(*atoms);\n          yr_atoms_list_destroy(wide_atoms);\n          *atoms = NULL;\n        });\n\n    if (flags & STRING_GFLAGS_ASCII)\n    {\n      *atoms = _yr_atoms_list_concat(*atoms, wide_atoms);\n    }\n    else\n    {\n      yr_atoms_list_destroy(*atoms);\n      *atoms = wide_atoms;\n    }\n  }\n\n  if (flags & STRING_GFLAGS_NO_CASE)\n  {\n    FAIL_ON_ERROR_WITH_CLEANUP(\n        _yr_atoms_case_insensitive(*atoms, &case_insensitive_atoms),\n        {\n          yr_atoms_list_destroy(*atoms);\n          yr_atoms_list_destroy(case_insensitive_atoms);\n          *atoms = NULL;\n        });\n\n    *atoms = _yr_atoms_list_concat(*atoms, case_insensitive_atoms);\n  }\n\n  // No atoms has been extracted, let's add a zero-length atom.\n\n  if (*atoms == NULL)\n  {\n    *atoms = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));\n\n    if (*atoms == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    (*atoms)->atom.length = 0;\n    (*atoms)->backtrack = 0;\n    (*atoms)->forward_code = re_ast->root_node->forward_code;\n    (*atoms)->backward_code = NULL;\n    (*atoms)->next = NULL;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 1366,
        "end_line": 1461,
        "is_bug": false
    },
    {
        "name": "libyara.atoms.yr_atoms_heuristic_quality#112",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms.yr_atoms_heuristic_quality(     YR_ATOMS_CONFIG* config, YR_ATOM* atom)",
        "snippet": "int yr_atoms_heuristic_quality(\n    YR_ATOMS_CONFIG* config,\n    YR_ATOM* atom)\n{\n  YR_BITMASK seen_bytes[YR_BITMASK_SIZE(256)];\n\n  int quality = 0;\n  int unique_bytes = 0;\n  int masked_nibbles = 0;\n  int i;\n\n  assert(atom->length <= YR_MAX_ATOM_LENGTH);\n\n  yr_bitmask_clear_all(seen_bytes);\n\n  for (i = 0; i < atom->length; i++)\n  {\n    switch (atom->mask[i])\n    {\n      case 0x00:\n        masked_nibbles += 2;\n        break;\n      case 0x0F:\n        masked_nibbles += 1;\n        quality += 4;\n        break;\n      case 0xF0:\n        masked_nibbles += 1;\n        quality += 4;\n        break;\n      case 0xFF:\n        switch (atom->bytes[i])\n        {\n          case 0x00:\n          case 0x20:\n          case 0xCC:\n          case 0xFF:\n            // Common bytes contribute less to the quality than the rest.\n            quality += 15;\n            break;\n          default:\n            // Bytes in the a-z and A-Z ranges have a slightly lower quality\n            // than the rest. We want to favor atoms that contain bytes outside\n            // those ranges because they generate less additional atoms during\n            // calls to _yr_atoms_case_combinations.\n            if ( yr_lowercase[atom->bytes[i]] >= 'a' &&\n                 yr_lowercase[atom->bytes[i]] <= 'z')\n              quality += 19;\n            else\n              quality += 20;\n        };\n        if (!yr_bitmask_isset(seen_bytes, atom->bytes[i]))\n        {\n          yr_bitmask_set(seen_bytes, atom->bytes[i]);\n          unique_bytes++;\n        }\n    }\n  }\n\n  // If all the bytes in the atom are equal and very common, let's penalize\n  // it heavily.\n\n  if (unique_bytes == 1 &&\n      (yr_bitmask_isset(seen_bytes, 0x00) ||\n       yr_bitmask_isset(seen_bytes, 0x20) ||\n       yr_bitmask_isset(seen_bytes, 0xCC) ||\n       yr_bitmask_isset(seen_bytes, 0xFF)))\n  {\n    quality -= 10 * atom->length;\n  }\n\n  quality -= masked_nibbles * 3;\n\n  return YR_MAX_ATOM_QUALITY - 20 * YR_MAX_ATOM_LENGTH + quality;\n}",
        "begin_line": 112,
        "end_line": 186,
        "is_bug": false
    },
    {
        "name": "libyara.atoms.yr_atoms_list_destroy#433",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms.yr_atoms_list_destroy(     YR_ATOM_LIST_ITEM* list_head)",
        "snippet": "void yr_atoms_list_destroy(\n    YR_ATOM_LIST_ITEM* list_head)\n{\n  YR_ATOM_LIST_ITEM* item = list_head;\n  YR_ATOM_LIST_ITEM* next;\n\n  while (item != NULL)\n  {\n    next = item->next;\n    yr_free(item);\n    item = next;\n  }\n}",
        "begin_line": 433,
        "end_line": 445,
        "is_bug": false
    },
    {
        "name": "libyara.hex_grammar.hex_yyparse#1162",
        "src_path": "libyara/hex_grammar.c",
        "class_name": "libyara.hex_grammar",
        "signature": "libyara.hex_grammar.)",
        "snippet": "int\nyyparse (void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)\n{\n/* The lookahead symbol.  */\nint yychar;\n\n\n/* The semantic value of the lookahead symbol.  */\n/* Default value used for initialization, for pacifying older GCCs\n   or non-GCC compilers.  */\nYY_INITIAL_VALUE (static YYSTYPE yyval_default;)\nYYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n\n    /* Number of syntax errors so far.  */\n    int yynerrs;\n\n    yy_state_fast_t yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yy_state_t yyssa[YYINITDEPTH];\n    yy_state_t *yyss;\n    yy_state_t *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYPTRDIFF_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYPTRDIFF_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n  goto yysetstate;\n\n\n/*------------------------------------------------------------.\n| yynewstate -- push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\nyynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n\n/*--------------------------------------------------------------------.\n| yysetstate -- set current state (the top of the stack) to yystate.  |\n`--------------------------------------------------------------------*/\nyysetstate:\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);\n  YY_IGNORE_USELESS_CAST_BEGIN\n  *yyssp = YY_CAST (yy_state_t, yystate);\n  YY_IGNORE_USELESS_CAST_END\n\n  if (yyss + yystacksize - 1 <= yyssp)\n#if !defined yyoverflow && !defined YYSTACK_RELOCATE\n    goto yyexhaustedlab;\n#else\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYPTRDIFF_T yysize = yyssp - yyss + 1;\n\n# if defined yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        yy_state_t *yyss1 = yyss;\n        YYSTYPE *yyvs1 = yyvs;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * YYSIZEOF (*yyssp),\n                    &yyvs1, yysize * YYSIZEOF (*yyvsp),\n                    &yystacksize);\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n# else /* defined YYSTACK_RELOCATE */\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yy_state_t *yyss1 = yyss;\n        union yyalloc *yyptr =\n          YY_CAST (union yyalloc *,\n                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n# undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YY_IGNORE_USELESS_CAST_BEGIN\n      YYDPRINTF ((stderr, \"Stack size increased to %ld\\n\",\n                  YY_CAST (long, yystacksize)));\n      YY_IGNORE_USELESS_CAST_END\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex (&yylval, yyscanner, lex_env);\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n  case 2:\n#line 106 \"hex_grammar.y\"\n      {\n        RE_AST* re_ast = yyget_extra(yyscanner);\n        re_ast->root_node = (yyvsp[-1].re_node);\n      }\n#line 1424 \"hex_grammar.c\"\n    break;\n\n  case 3:\n#line 115 \"hex_grammar.y\"\n      {\n        (yyval.re_node) = (yyvsp[0].re_node);\n      }\n#line 1432 \"hex_grammar.c\"\n    break;\n\n  case 4:\n#line 119 \"hex_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT);\n\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[0].re_node));\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        yr_re_node_append_child((yyval.re_node), (yyvsp[-1].re_node));\n        yr_re_node_append_child((yyval.re_node), (yyvsp[0].re_node));\n      }\n#line 1448 \"hex_grammar.c\"\n    break;\n\n  case 5:\n#line 131 \"hex_grammar.y\"\n      {\n        yr_re_node_append_child((yyvsp[-1].re_node), (yyvsp[0].re_node));\n        yr_re_node_prepend_child((yyvsp[-1].re_node), (yyvsp[-2].re_node));\n\n        (yyval.re_node) = (yyvsp[-1].re_node);\n      }\n#line 1459 \"hex_grammar.c\"\n    break;\n\n  case 6:\n#line 142 \"hex_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT);\n\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[0].re_node));\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        yr_re_node_append_child((yyval.re_node), (yyvsp[0].re_node));\n      }\n#line 1472 \"hex_grammar.c\"\n    break;\n\n  case 7:\n#line 151 \"hex_grammar.y\"\n      {\n        yr_re_node_append_child((yyvsp[-1].re_node), (yyvsp[0].re_node));\n        (yyval.re_node) = (yyvsp[-1].re_node);\n      }\n#line 1481 \"hex_grammar.c\"\n    break;\n\n  case 8:\n#line 160 \"hex_grammar.y\"\n      {\n        (yyval.re_node) = (yyvsp[0].re_node);\n      }\n#line 1489 \"hex_grammar.c\"\n    break;\n\n  case 9:\n#line 164 \"hex_grammar.y\"\n      {\n        (yyval.re_node) = (yyvsp[0].re_node);\n        (yyval.re_node)->greedy = false;\n      }\n#line 1498 \"hex_grammar.c\"\n    break;\n\n  case 10:\n#line 173 \"hex_grammar.y\"\n      {\n        (yyval.re_node) = (yyvsp[0].re_node);\n      }\n#line 1506 \"hex_grammar.c\"\n    break;\n\n  case 11:\n#line 177 \"hex_grammar.y\"\n      {\n        lex_env->inside_or++;\n      }\n#line 1514 \"hex_grammar.c\"\n    break;\n\n  case 12:\n#line 181 \"hex_grammar.y\"\n      {\n        (yyval.re_node) = (yyvsp[-1].re_node);\n        lex_env->inside_or--;\n      }\n#line 1523 \"hex_grammar.c\"\n    break;\n\n  case 13:\n#line 190 \"hex_grammar.y\"\n      {\n        if ((yyvsp[-1].integer) <= 0)\n        {\n          yyerror(yyscanner, lex_env, \"invalid jump length\");\n          YYABORT;\n        }\n\n        if (lex_env->inside_or && (yyvsp[-1].integer) > YR_STRING_CHAINING_THRESHOLD)\n        {\n          yyerror(yyscanner, lex_env, \"jumps over \"\n              STR(YR_STRING_CHAINING_THRESHOLD)\n              \" now allowed inside alternation (|)\");\n          YYABORT;\n        }\n\n        (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        (yyval.re_node)->start = (int) (yyvsp[-1].integer);\n        (yyval.re_node)->end = (int) (yyvsp[-1].integer);\n      }\n#line 1550 \"hex_grammar.c\"\n    break;\n\n  case 14:\n#line 213 \"hex_grammar.y\"\n      {\n        if (lex_env->inside_or &&\n            ((yyvsp[-3].integer) > YR_STRING_CHAINING_THRESHOLD ||\n             (yyvsp[-1].integer) > YR_STRING_CHAINING_THRESHOLD) )\n        {\n          yyerror(yyscanner, lex_env, \"jumps over \"\n              STR(YR_STRING_CHAINING_THRESHOLD)\n              \" now allowed inside alternation (|)\");\n\n          YYABORT;\n        }\n\n        if ((yyvsp[-3].integer) < 0 || (yyvsp[-1].integer) < 0)\n        {\n          yyerror(yyscanner, lex_env, \"invalid negative jump length\");\n          YYABORT;\n        }\n\n        if ((yyvsp[-3].integer) > (yyvsp[-1].integer))\n        {\n          yyerror(yyscanner, lex_env, \"invalid jump range\");\n          YYABORT;\n        }\n\n        (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        (yyval.re_node)->start = (int) (yyvsp[-3].integer);\n        (yyval.re_node)->end = (int) (yyvsp[-1].integer);\n      }\n#line 1586 \"hex_grammar.c\"\n    break;\n\n  case 15:\n#line 245 \"hex_grammar.y\"\n      {\n        if (lex_env->inside_or)\n        {\n          yyerror(yyscanner, lex_env,\n              \"unbounded jumps not allowed inside alternation (|)\");\n          YYABORT;\n        }\n\n        if ((yyvsp[-2].integer) < 0)\n        {\n          yyerror(yyscanner, lex_env, \"invalid negative jump length\");\n          YYABORT;\n        }\n\n        (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        (yyval.re_node)->start = (int) (yyvsp[-2].integer);\n        (yyval.re_node)->end = INT_MAX;\n      }\n#line 1612 \"hex_grammar.c\"\n    break;\n\n  case 16:\n#line 267 \"hex_grammar.y\"\n      {\n        if (lex_env->inside_or)\n        {\n          yyerror(yyscanner, lex_env,\n              \"unbounded jumps not allowed inside alternation (|)\");\n          YYABORT;\n        }\n\n        (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        (yyval.re_node)->start = 0;\n        (yyval.re_node)->end = INT_MAX;\n      }\n#line 1632 \"hex_grammar.c\"\n    break;\n\n  case 17:\n#line 287 \"hex_grammar.y\"\n      {\n          (yyval.re_node) = (yyvsp[0].re_node);\n      }\n#line 1640 \"hex_grammar.c\"\n    break;\n\n  case 18:\n#line 291 \"hex_grammar.y\"\n      {\n        mark_as_not_fast_regexp();\n\n        (yyval.re_node) = yr_re_node_create(RE_NODE_ALT);\n\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[0].re_node));\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        yr_re_node_append_child((yyval.re_node), (yyvsp[-2].re_node));\n        yr_re_node_append_child((yyval.re_node), (yyvsp[0].re_node));\n      }\n#line 1658 \"hex_grammar.c\"\n    break;\n\n  case 19:\n#line 308 \"hex_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_LITERAL);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        (yyval.re_node)->value = (int) (yyvsp[0].integer);\n        (yyval.re_node)->mask = 0xFF;\n      }\n#line 1671 \"hex_grammar.c\"\n    break;\n\n  case 20:\n#line 317 \"hex_grammar.y\"\n      {\n        uint8_t mask = (uint8_t) ((yyvsp[0].integer) >> 8);\n\n        if (mask == 0x00)\n        {\n          (yyval.re_node) = yr_re_node_create(RE_NODE_ANY);\n\n          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n          (yyval.re_node)->value = 0x00;\n          (yyval.re_node)->mask = 0x00;\n        }\n        else\n        {\n          (yyval.re_node) = yr_re_node_create(RE_NODE_MASKED_LITERAL);\n\n          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n          (yyval.re_node)->value = (yyvsp[0].integer) & 0xFF;\n          (yyval.re_node)->mask = mask;\n        }\n      }\n#line 1698 \"hex_grammar.c\"\n    break;\n\n\n#line 1702 \"hex_grammar.c\"\n\n      default: break;\n    }\n  /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n  {\n    const int yylhs = yyr1[yyn] - YYNTOKENS;\n    const int yyi = yypgoto[yylhs] + *yyssp;\n    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp\n               ? yytable[yyi]\n               : yydefgoto[yylhs]);\n  }\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (yyscanner, lex_env, YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        int yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = YY_CAST (char *, YYSTACK_ALLOC (YY_CAST (YYSIZE_T, yymsg_alloc)));\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (yyscanner, lex_env, yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n         error, discard it.  */\n\n      if (yychar <= YYEOF)\n        {\n          /* Return failure if at end of input.  */\n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval, yyscanner, lex_env);\n          yychar = YYEMPTY;\n        }\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n  /* Pacify compilers when the user code never invokes YYERROR and the\n     label yyerrorlab therefore never appears in user code.  */\n  if (0)\n    YYERROR;\n\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYTERROR;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n        YYABORT;\n\n\n      yydestruct (\"Error: popping\",\n                  yystos[yystate], yyvsp, yyscanner, lex_env);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (yyscanner, lex_env, YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\n\n/*-----------------------------------------------------.\n| yyreturn -- parsing is finished, return the result.  |\n`-----------------------------------------------------*/\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval, yyscanner, lex_env);\n    }\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  yystos[+*yyssp], yyvsp, yyscanner, lex_env);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n#endif\n  return yyresult;\n}",
        "begin_line": 1162,
        "end_line": 1932,
        "is_bug": false
    },
    {
        "name": "libyara.hex_grammar.yydestruct#1094",
        "src_path": "libyara/hex_grammar.c",
        "class_name": "libyara.hex_grammar",
        "signature": "libyara.hex_grammar.yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)",
        "snippet": "static void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)\n{\n  YYUSE (yyvaluep);\n  YYUSE (yyscanner);\n  YYUSE (lex_env);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  switch (yytype)\n    {\n    case 16: /* tokens  */\n#line 94 \"hex_grammar.y\"\n            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }\n#line 1111 \"hex_grammar.c\"\n        break;\n\n    case 17: /* token_sequence  */\n#line 95 \"hex_grammar.y\"\n            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }\n#line 1117 \"hex_grammar.c\"\n        break;\n\n    case 18: /* token_or_range  */\n#line 96 \"hex_grammar.y\"\n            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }\n#line 1123 \"hex_grammar.c\"\n        break;\n\n    case 19: /* token  */\n#line 97 \"hex_grammar.y\"\n            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }\n#line 1129 \"hex_grammar.c\"\n        break;\n\n    case 21: /* range  */\n#line 100 \"hex_grammar.y\"\n            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }\n#line 1135 \"hex_grammar.c\"\n        break;\n\n    case 22: /* alternatives  */\n#line 99 \"hex_grammar.y\"\n            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }\n#line 1141 \"hex_grammar.c\"\n        break;\n\n    case 23: /* byte  */\n#line 98 \"hex_grammar.y\"\n            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }\n#line 1147 \"hex_grammar.c\"\n        break;\n\n      default:\n        break;\n    }\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}",
        "begin_line": 1094,
        "end_line": 1153,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yy_delete_buffer#1771",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "void yy_delete_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tyyfree( (void *) b->yy_ch_buf , yyscanner );\n\n\tyyfree( (void *) b , yyscanner );\n}",
        "begin_line": 1771,
        "end_line": 1785,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yy_load_buffer_state#1728",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "static void yy_load_buffer_state  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\tyyg->yytext_ptr = yyg->yy_c_buf_p = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;\n\tyyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;\n\tyyg->yy_hold_char = *yyg->yy_c_buf_p;\n}",
        "begin_line": 1728,
        "end_line": 1735,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yy_scan_buffer#1951",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn NULL;\n\n\tb = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n\n\tb->yy_buf_size = (int) (size - 2);\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = NULL;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tyy_switch_to_buffer( b , yyscanner );\n\n\treturn b;\n}",
        "begin_line": 1951,
        "end_line": 1978,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yy_scan_bytes#2001",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len , yyscan_t yyscanner)\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = (yy_size_t) (_yybytes_len + 2);\n\tbuf = (char *) yyalloc( n , yyscanner );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = yy_scan_buffer( buf, n , yyscanner);\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}",
        "begin_line": 2001,
        "end_line": 2029,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yy_scan_string#1988",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "YY_BUFFER_STATE yy_scan_string (const char * yystr , yyscan_t yyscanner)\n{\n    \n\treturn yy_scan_bytes( yystr, (int) strlen(yystr) , yyscanner);\n}",
        "begin_line": 1988,
        "end_line": 1992,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yy_switch_to_buffer#1696",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tyypop_buffer_state();\n\t *\t\tyypush_buffer_state(new_buffer);\n     */\n\tyyensure_buffer_stack (yyscanner);\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*yyg->yy_c_buf_p = yyg->yy_hold_char;\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tyy_load_buffer_state( yyscanner );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (yywrap()) processing, but the only time this flag\n\t * is looked at is after yywrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\tyyg->yy_did_buffer_switch_on_eof = 1;\n}",
        "begin_line": 1696,
        "end_line": 1726,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yyalloc#2368",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "void *yyalloc (yy_size_t  size , yyscan_t yyscanner)\n{\n\tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\t(void)yyg;\n\treturn malloc(size);\n}",
        "begin_line": 2368,
        "end_line": 2373,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yyensure_buffer_stack#1901",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "static void yyensure_buffer_stack (yyscan_t yyscanner)\n{\n\tyy_size_t num_to_alloc;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tif (!yyg->yy_buffer_stack) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\n\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t\tyyg->yy_buffer_stack_top = 0;\n\t\treturn;\n\t}\n\n\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)yyrealloc\n\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t}\n}",
        "begin_line": 1901,
        "end_line": 1943,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yyfree#2390",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "void yyfree (void * ptr , yyscan_t yyscanner)\n{\n\tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\t(void)yyg;\n\tfree( (char *) ptr );\t/* see yyrealloc() for (char *) cast */\n}",
        "begin_line": 2390,
        "end_line": 2395,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yyget_extra#2065",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "YY_EXTRA_TYPE yyget_extra  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    return yyextra;\n}",
        "begin_line": 2065,
        "end_line": 2069,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yylex#998",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.L",
        "snippet": "YY_DECL\n{\n\tyy_state_type yy_current_state;\n\tchar *yy_cp, *yy_bp;\n\tint yy_act;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n    yylval = yylval_param;\n\n\tif ( !yyg->yy_init )\n\t\t{\n\t\tyyg->yy_init = 1;\n\n#ifdef YY_USER_INIT\n\t\tYY_USER_INIT;\n#endif\n\n\t\tif ( ! yyg->yy_start )\n\t\t\tyyg->yy_start = 1;\t/* first start state */\n\n\t\tif ( ! yyin )\n\t\t\tyyin = stdin;\n\n\t\tif ( ! yyout )\n\t\t\tyyout = stdout;\n\n\t\tif ( ! YY_CURRENT_BUFFER ) {\n\t\t\tyyensure_buffer_stack (yyscanner);\n\t\t\tYY_CURRENT_BUFFER_LVALUE =\n\t\t\t\tyy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);\n\t\t}\n\n\t\tyy_load_buffer_state( yyscanner );\n\t\t}\n\n\t{\n#line 95 \"hex_lexer.l\"\n\n\n\n#line 1039 \"hex_lexer.c\"\n\n\twhile ( /*CONSTCOND*/1 )\t\t/* loops until end-of-file is reached */\n\t\t{\n\t\tyy_cp = yyg->yy_c_buf_p;\n\n\t\t/* Support of yytext. */\n\t\t*yy_cp = yyg->yy_hold_char;\n\n\t\t/* yy_bp points to the position in yy_ch_buf of the start of\n\t\t * the current run.\n\t\t */\n\t\tyy_bp = yy_cp;\n\n\t\tyy_current_state = yyg->yy_start;\nyy_match:\n\t\tdo\n\t\t\t{\n\t\t\tYY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;\n\t\t\tif ( yy_accept[yy_current_state] )\n\t\t\t\t{\n\t\t\t\tyyg->yy_last_accepting_state = yy_current_state;\n\t\t\t\tyyg->yy_last_accepting_cpos = yy_cp;\n\t\t\t\t}\n\t\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t\t{\n\t\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\t\tif ( yy_current_state >= 34 )\n\t\t\t\t\tyy_c = yy_meta[yy_c];\n\t\t\t\t}\n\t\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];\n\t\t\t++yy_cp;\n\t\t\t}\n\t\twhile ( yy_current_state != 33 );\n\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\tyy_current_state = yyg->yy_last_accepting_state;\n\nyy_find_action:\n\t\tyy_act = yy_accept[yy_current_state];\n\n\t\tYY_DO_BEFORE_ACTION;\n\n\t\tif ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )\n\t\t\t{\n\t\t\tint yyl;\n\t\t\tfor ( yyl = 0; yyl < yyleng; ++yyl )\n\t\t\t\tif ( yytext[yyl] == '\\n' )\n\t\t\t\t\t\n    do{ yylineno++;\n        yycolumn=0;\n    }while(0)\n;\n\t\t\t}\n\ndo_action:\t/* This label is used only to access EOF actions. */\n\n\t\tswitch ( yy_act )\n\t{ /* beginning of action switch */\n\t\t\tcase 0: /* must back up */\n\t\t\t/* undo the effects of YY_DO_BEFORE_ACTION */\n\t\t\t*yy_cp = yyg->yy_hold_char;\n\t\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\t\tyy_current_state = yyg->yy_last_accepting_state;\n\t\t\tgoto yy_find_action;\n\ncase 1:\nYY_RULE_SETUP\n#line 98 \"hex_lexer.l\"\n{\n\n  yylval->integer = xtoi(yytext);\n  return _BYTE_;\n}\n\tYY_BREAK\ncase 2:\nYY_RULE_SETUP\n#line 104 \"hex_lexer.l\"\n{\n\n  yytext[1] = '0'; // replace ? by 0\n  yylval->integer = xtoi(yytext) | 0xF000 ;\n  return _MASKED_BYTE_;\n}\n\tYY_BREAK\ncase 3:\nYY_RULE_SETUP\n#line 111 \"hex_lexer.l\"\n{\n\n  yytext[0] = '0'; // replace ? by 0\n  yylval->integer = xtoi(yytext) | 0x0F00 ;\n  return _MASKED_BYTE_;\n}\n\tYY_BREAK\ncase 4:\nYY_RULE_SETUP\n#line 118 \"hex_lexer.l\"\n{\n\n  yylval->integer = 0x0000;\n  return _MASKED_BYTE_;\n}\n\tYY_BREAK\ncase 5:\nYY_RULE_SETUP\n#line 124 \"hex_lexer.l\"\n{\n\n  BEGIN(range);\n  return yytext[0];\n}\n\tYY_BREAK\ncase 6:\nYY_RULE_SETUP\n#line 130 \"hex_lexer.l\"\n{\n\n  BEGIN(comment);\n}\n\tYY_BREAK\ncase 7:\nYY_RULE_SETUP\n#line 135 \"hex_lexer.l\"\n{\n\n  BEGIN(INITIAL);\n}\n\tYY_BREAK\ncase 8:\n/* rule 8 can match eol */\nYY_RULE_SETUP\n#line 140 \"hex_lexer.l\"\n// skip comments\n\tYY_BREAK\ncase 9:\nYY_RULE_SETUP\n#line 142 \"hex_lexer.l\"\n// skip single-line comments\n\tYY_BREAK\ncase 10:\nYY_RULE_SETUP\n#line 144 \"hex_lexer.l\"\n{\n\n  return yytext[0];\n}\n\tYY_BREAK\ncase 11:\nYY_RULE_SETUP\n#line 149 \"hex_lexer.l\"\n{\n\n  yylval->integer = atoi(yytext);\n  return _NUMBER_;\n}\n\tYY_BREAK\ncase 12:\nYY_RULE_SETUP\n#line 155 \"hex_lexer.l\"\n{\n\n  BEGIN(INITIAL);\n  return yytext[0];\n}\n\tYY_BREAK\ncase 13:\n/* rule 13 can match eol */\nYY_RULE_SETUP\n#line 161 \"hex_lexer.l\"\n// skip whitespaces\n\tYY_BREAK\ncase 14:\nYY_RULE_SETUP\n#line 163 \"hex_lexer.l\"\n{\n\n  yyerror(yyscanner, lex_env, \"invalid character in hex string jump\");\n  yyterminate();\n}\n\tYY_BREAK\ncase 15:\n/* rule 15 can match eol */\nYY_RULE_SETUP\n#line 169 \"hex_lexer.l\"\n// skip whitespaces\n\tYY_BREAK\ncase 16:\nYY_RULE_SETUP\n#line 171 \"hex_lexer.l\"\n{        // pass valid characters to the parser\n\n  return yytext[0];\n}\n\tYY_BREAK\ncase 17:\nYY_RULE_SETUP\n#line 176 \"hex_lexer.l\"\n{               // reject all other characters\n\n  yyerror(yyscanner, lex_env, \"invalid character in hex string\");\n  yyterminate();\n}\n\tYY_BREAK\ncase 18:\nYY_RULE_SETUP\n#line 182 \"hex_lexer.l\"\nECHO;\n\tYY_BREAK\n#line 1247 \"hex_lexer.c\"\ncase YY_STATE_EOF(INITIAL):\ncase YY_STATE_EOF(comment):\ncase YY_STATE_EOF(range):\n\tyyterminate();\n\n\tcase YY_END_OF_BUFFER:\n\t\t{\n\t\t/* Amount of text matched not including the EOB char. */\n\t\tint yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;\n\n\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */\n\t\t*yy_cp = yyg->yy_hold_char;\n\t\tYY_RESTORE_YY_MORE_OFFSET\n\n\t\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )\n\t\t\t{\n\t\t\t/* We're scanning a new file or input source.  It's\n\t\t\t * possible that this happened because the user\n\t\t\t * just pointed yyin at a new source and called\n\t\t\t * yylex().  If so, then we have to assure\n\t\t\t * consistency between YY_CURRENT_BUFFER and our\n\t\t\t * globals.  Here is the right place to do so, because\n\t\t\t * this is the first action (other than possibly a\n\t\t\t * back-up) that will match for the new input source.\n\t\t\t */\n\t\t\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;\n\t\t\t}\n\n\t\t/* Note that here we test for yy_c_buf_p \"<=\" to the position\n\t\t * of the first EOB in the buffer, since yy_c_buf_p will\n\t\t * already have been incremented past the NUL character\n\t\t * (since all states make transitions on EOB to the\n\t\t * end-of-buffer state).  Contrast this with the test\n\t\t * in input().\n\t\t */\n\t\tif ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )\n\t\t\t{ /* This was really a NUL. */\n\t\t\tyy_state_type yy_next_state;\n\n\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;\n\n\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t/* Okay, we're now positioned to make the NUL\n\t\t\t * transition.  We couldn't have\n\t\t\t * yy_get_previous_state() go ahead and do it\n\t\t\t * for us because it doesn't know how to deal\n\t\t\t * with the possibility of jamming (and we don't\n\t\t\t * want to build jamming into it because then it\n\t\t\t * will run more slowly).\n\t\t\t */\n\n\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);\n\n\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\n\t\t\tif ( yy_next_state )\n\t\t\t\t{\n\t\t\t\t/* Consume the NUL. */\n\t\t\t\tyy_cp = ++yyg->yy_c_buf_p;\n\t\t\t\tyy_current_state = yy_next_state;\n\t\t\t\tgoto yy_match;\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\t\t\tyy_current_state = yyg->yy_last_accepting_state;\n\t\t\t\tgoto yy_find_action;\n\t\t\t\t}\n\t\t\t}\n\n\t\telse switch ( yy_get_next_buffer( yyscanner ) )\n\t\t\t{\n\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t{\n\t\t\t\tyyg->yy_did_buffer_switch_on_eof = 0;\n\n\t\t\t\tif ( yywrap( yyscanner ) )\n\t\t\t\t\t{\n\t\t\t\t\t/* Note: because we've taken care in\n\t\t\t\t\t * yy_get_next_buffer() to have set up\n\t\t\t\t\t * yytext, we can now set up\n\t\t\t\t\t * yy_c_buf_p so that if some total\n\t\t\t\t\t * hoser (like flex itself) wants to\n\t\t\t\t\t * call the scanner after we return the\n\t\t\t\t\t * YY_NULL, it'll still work - another\n\t\t\t\t\t * YY_NULL will get returned.\n\t\t\t\t\t */\n\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;\n\n\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);\n\t\t\t\t\tgoto do_action;\n\t\t\t\t\t}\n\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\tyyg->yy_c_buf_p =\n\t\t\t\t\tyyg->yytext_ptr + yy_amount_of_matched_text;\n\n\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t\tyy_cp = yyg->yy_c_buf_p;\n\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_match;\n\n\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\tyyg->yy_c_buf_p =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];\n\n\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t\tyy_cp = yyg->yy_c_buf_p;\n\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_find_action;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\tYY_FATAL_ERROR(\n\t\t\t\"fatal flex scanner internal error--no action found\" );\n\t} /* end of action switch */\n\t\t} /* end of scanning one token */\n\t} /* end of user's declarations */\n}",
        "begin_line": 998,
        "end_line": 1381,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yylex_destroy#2312",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "int yylex_destroy  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tyy_delete_buffer( YY_CURRENT_BUFFER , yyscanner );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tyypop_buffer_state(yyscanner);\n\t}\n\n\t/* Destroy the stack itself. */\n\tyyfree(yyg->yy_buffer_stack , yyscanner);\n\tyyg->yy_buffer_stack = NULL;\n\n    /* Destroy the start condition stack. */\n        yyfree( yyg->yy_start_stack , yyscanner );\n        yyg->yy_start_stack = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * yylex() is called, initialization will occur. */\n    yy_init_globals( yyscanner);\n\n    /* Destroy the main struct (reentrant only). */\n    yyfree ( yyscanner , yyscanner );\n    yyscanner = NULL;\n    return 0;\n}",
        "begin_line": 2312,
        "end_line": 2339,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yylex_init#2224",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "int yylex_init(yyscan_t* ptr_yy_globals)\n{\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n\n    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), NULL );\n\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n\n    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n\n    return yy_init_globals ( *ptr_yy_globals );\n}",
        "begin_line": 2224,
        "end_line": 2242,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yypop_buffer_state#1881",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "void yypop_buffer_state (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tyy_delete_buffer(YY_CURRENT_BUFFER , yyscanner);\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif (yyg->yy_buffer_stack_top > 0)\n\t\t--yyg->yy_buffer_stack_top;\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tyy_load_buffer_state( yyscanner );\n\t\tyyg->yy_did_buffer_switch_on_eof = 1;\n\t}\n}",
        "begin_line": 1881,
        "end_line": 1896,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.hex_yyset_extra#2138",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.)",
        "snippet": "void yyset_extra (YY_EXTRA_TYPE  user_defined , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    yyextra = user_defined ;\n}",
        "begin_line": 2138,
        "end_line": 2142,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.yy_get_next_buffer#1390",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.yy_get_next_buffer (yyscan_t yyscanner)",
        "snippet": "static int yy_get_next_buffer (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tchar *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tchar *source = yyg->yytext_ptr;\n\tint number_to_move, i;\n\tint ret_val;\n\n\tif ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr - 1);\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) (yyg->yy_c_buf_p - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tyyrealloc( (void *) b->yy_ch_buf,\n\t\t\t\t\t\t\t (yy_size_t) (b->yy_buf_size + 2) , yyscanner );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = NULL;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\tyyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\tyyg->yy_n_chars, num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;\n\t\t}\n\n\tif ( yyg->yy_n_chars == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tyyrestart( yyin  , yyscanner);\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tint new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(\n\t\t\t(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size , yyscanner );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n\t\t/* \"- 2\" to take care of EOB's */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);\n\t}\n\n\tyyg->yy_n_chars += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;\n\n\tyyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}",
        "begin_line": 1390,
        "end_line": 1525,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.yy_get_previous_state#1529",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.yy_get_previous_state (yyscan_t yyscanner)",
        "snippet": "static yy_state_type yy_get_previous_state (yyscan_t yyscanner)\n{\n\tyy_state_type yy_current_state;\n\tchar *yy_cp;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tyy_current_state = yyg->yy_start;\n\n\tfor ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )\n\t\t{\n\t\tYY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\tyyg->yy_last_accepting_state = yy_current_state;\n\t\t\tyyg->yy_last_accepting_cpos = yy_cp;\n\t\t\t}\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 34 )\n\t\t\t\tyy_c = yy_meta[yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];\n\t\t}\n\n\treturn yy_current_state;\n}",
        "begin_line": 1529,
        "end_line": 1555,
        "is_bug": false
    },
    {
        "name": "libyara.hex_lexer.yy_init_globals#2278",
        "src_path": "libyara/hex_lexer.c",
        "class_name": "libyara.hex_lexer",
        "signature": "libyara.hex_lexer.yy_init_globals (yyscan_t yyscanner)",
        "snippet": "static int yy_init_globals (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from yylex_destroy(), so don't allocate here.\n     */\n\n    yyg->yy_buffer_stack = NULL;\n    yyg->yy_buffer_stack_top = 0;\n    yyg->yy_buffer_stack_max = 0;\n    yyg->yy_c_buf_p = NULL;\n    yyg->yy_init = 0;\n    yyg->yy_start = 0;\n\n    yyg->yy_start_stack_ptr = 0;\n    yyg->yy_start_stack_depth = 0;\n    yyg->yy_start_stack =  NULL;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    yyin = stdin;\n    yyout = stdout;\n#else\n    yyin = NULL;\n    yyout = NULL;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * yylex_init()\n     */\n    return 0;\n}",
        "begin_line": 2278,
        "end_line": 2309,
        "is_bug": false
    },
    {
        "name": "libyara.lexer.yara_yylex#1384",
        "src_path": "libyara/lexer.c",
        "class_name": "libyara.lexer",
        "signature": "libyara.lexer.L",
        "snippet": "YY_DECL\n{\n\tyy_state_type yy_current_state;\n\tchar *yy_cp, *yy_bp;\n\tint yy_act;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n    yylval = yylval_param;\n\n\tif ( !yyg->yy_init )\n\t\t{\n\t\tyyg->yy_init = 1;\n\n#ifdef YY_USER_INIT\n\t\tYY_USER_INIT;\n#endif\n\n\t\tif ( ! yyg->yy_start )\n\t\t\tyyg->yy_start = 1;\t/* first start state */\n\n\t\tif ( ! yyin )\n\t\t\tyyin = stdin;\n\n\t\tif ( ! yyout )\n\t\t\tyyout = stdout;\n\n\t\tif ( ! YY_CURRENT_BUFFER ) {\n\t\t\tyyensure_buffer_stack (yyscanner);\n\t\t\tYY_CURRENT_BUFFER_LVALUE =\n\t\t\t\tyy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);\n\t\t}\n\n\t\tyy_load_buffer_state( yyscanner );\n\t\t}\n\n\t{\n#line 163 \"lexer.l\"\n\n\n#line 1424 \"lexer.c\"\n\n\twhile ( /*CONSTCOND*/1 )\t\t/* loops until end-of-file is reached */\n\t\t{\n\t\tyy_cp = yyg->yy_c_buf_p;\n\n\t\t/* Support of yytext. */\n\t\t*yy_cp = yyg->yy_hold_char;\n\n\t\t/* yy_bp points to the position in yy_ch_buf of the start of\n\t\t * the current run.\n\t\t */\n\t\tyy_bp = yy_cp;\n\n\t\tyy_current_state = yyg->yy_start;\nyy_match:\n\t\tdo\n\t\t\t{\n\t\t\tYY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;\n\t\t\tif ( yy_accept[yy_current_state] )\n\t\t\t\t{\n\t\t\t\tyyg->yy_last_accepting_state = yy_current_state;\n\t\t\t\tyyg->yy_last_accepting_cpos = yy_cp;\n\t\t\t\t}\n\t\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t\t{\n\t\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\t\tif ( yy_current_state >= 286 )\n\t\t\t\t\tyy_c = yy_meta[yy_c];\n\t\t\t\t}\n\t\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];\n\t\t\t++yy_cp;\n\t\t\t}\n\t\twhile ( yy_current_state != 285 );\n\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\tyy_current_state = yyg->yy_last_accepting_state;\n\nyy_find_action:\n\t\tyy_act = yy_accept[yy_current_state];\n\n\t\tYY_DO_BEFORE_ACTION;\n\n\t\tif ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )\n\t\t\t{\n\t\t\tint yyl;\n\t\t\tfor ( yyl = 0; yyl < yyleng; ++yyl )\n\t\t\t\tif ( yytext[yyl] == '\\n' )\n\t\t\t\t\t\n    do{ yylineno++;\n        yycolumn=0;\n    }while(0)\n;\n\t\t\t}\n\ndo_action:\t/* This label is used only to access EOF actions. */\n\n\t\tswitch ( yy_act )\n\t{ /* beginning of action switch */\n\t\t\tcase 0: /* must back up */\n\t\t\t/* undo the effects of YY_DO_BEFORE_ACTION */\n\t\t\t*yy_cp = yyg->yy_hold_char;\n\t\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\t\tyy_current_state = yyg->yy_last_accepting_state;\n\t\t\tgoto yy_find_action;\n\ncase 1:\nYY_RULE_SETUP\n#line 165 \"lexer.l\"\n{ return _DOT_DOT_;     }\n\tYY_BREAK\ncase 2:\nYY_RULE_SETUP\n#line 166 \"lexer.l\"\n{ return _LT_;          }\n\tYY_BREAK\ncase 3:\nYY_RULE_SETUP\n#line 167 \"lexer.l\"\n{ return _GT_;          }\n\tYY_BREAK\ncase 4:\nYY_RULE_SETUP\n#line 168 \"lexer.l\"\n{ return _LE_;          }\n\tYY_BREAK\ncase 5:\nYY_RULE_SETUP\n#line 169 \"lexer.l\"\n{ return _GE_;          }\n\tYY_BREAK\ncase 6:\nYY_RULE_SETUP\n#line 170 \"lexer.l\"\n{ return _EQ_;          }\n\tYY_BREAK\ncase 7:\nYY_RULE_SETUP\n#line 171 \"lexer.l\"\n{ return _NEQ_;         }\n\tYY_BREAK\ncase 8:\nYY_RULE_SETUP\n#line 172 \"lexer.l\"\n{ return _SHIFT_LEFT_;  }\n\tYY_BREAK\ncase 9:\nYY_RULE_SETUP\n#line 173 \"lexer.l\"\n{ return _SHIFT_RIGHT_; }\n\tYY_BREAK\ncase 10:\nYY_RULE_SETUP\n#line 174 \"lexer.l\"\n{ return _PRIVATE_;     }\n\tYY_BREAK\ncase 11:\nYY_RULE_SETUP\n#line 175 \"lexer.l\"\n{ return _GLOBAL_;      }\n\tYY_BREAK\ncase 12:\nYY_RULE_SETUP\n#line 176 \"lexer.l\"\n{ return _RULE_;        }\n\tYY_BREAK\ncase 13:\nYY_RULE_SETUP\n#line 177 \"lexer.l\"\n{ return _META_;        }\n\tYY_BREAK\ncase 14:\nYY_RULE_SETUP\n#line 178 \"lexer.l\"\n{ return _STRINGS_;     }\n\tYY_BREAK\ncase 15:\nYY_RULE_SETUP\n#line 179 \"lexer.l\"\n{ return _ASCII_;       }\n\tYY_BREAK\ncase 16:\nYY_RULE_SETUP\n#line 180 \"lexer.l\"\n{ return _WIDE_;        }\n\tYY_BREAK\ncase 17:\nYY_RULE_SETUP\n#line 181 \"lexer.l\"\n{ return _XOR_;         }\n\tYY_BREAK\ncase 18:\nYY_RULE_SETUP\n#line 182 \"lexer.l\"\n{ return _FULLWORD_;    }\n\tYY_BREAK\ncase 19:\nYY_RULE_SETUP\n#line 183 \"lexer.l\"\n{ return _NOCASE_;      }\n\tYY_BREAK\ncase 20:\nYY_RULE_SETUP\n#line 184 \"lexer.l\"\n{ return _CONDITION_;   }\n\tYY_BREAK\ncase 21:\nYY_RULE_SETUP\n#line 185 \"lexer.l\"\n{ return _TRUE_;        }\n\tYY_BREAK\ncase 22:\nYY_RULE_SETUP\n#line 186 \"lexer.l\"\n{ return _FALSE_;       }\n\tYY_BREAK\ncase 23:\nYY_RULE_SETUP\n#line 187 \"lexer.l\"\n{ return _NOT_;         }\n\tYY_BREAK\ncase 24:\nYY_RULE_SETUP\n#line 188 \"lexer.l\"\n{ return _AND_;         }\n\tYY_BREAK\ncase 25:\nYY_RULE_SETUP\n#line 189 \"lexer.l\"\n{ return _OR_;          }\n\tYY_BREAK\ncase 26:\nYY_RULE_SETUP\n#line 190 \"lexer.l\"\n{ return _AT_;          }\n\tYY_BREAK\ncase 27:\nYY_RULE_SETUP\n#line 191 \"lexer.l\"\n{ return _IN_;          }\n\tYY_BREAK\ncase 28:\nYY_RULE_SETUP\n#line 192 \"lexer.l\"\n{ return _OF_;          }\n\tYY_BREAK\ncase 29:\nYY_RULE_SETUP\n#line 193 \"lexer.l\"\n{ return _THEM_;        }\n\tYY_BREAK\ncase 30:\nYY_RULE_SETUP\n#line 194 \"lexer.l\"\n{ return _FOR_;         }\n\tYY_BREAK\ncase 31:\nYY_RULE_SETUP\n#line 195 \"lexer.l\"\n{ return _ALL_;         }\n\tYY_BREAK\ncase 32:\nYY_RULE_SETUP\n#line 196 \"lexer.l\"\n{ return _ANY_;         }\n\tYY_BREAK\ncase 33:\nYY_RULE_SETUP\n#line 197 \"lexer.l\"\n{ return _ENTRYPOINT_;  }\n\tYY_BREAK\ncase 34:\nYY_RULE_SETUP\n#line 198 \"lexer.l\"\n{ return _FILESIZE_;    }\n\tYY_BREAK\ncase 35:\nYY_RULE_SETUP\n#line 199 \"lexer.l\"\n{ return _MATCHES_;     }\n\tYY_BREAK\ncase 36:\nYY_RULE_SETUP\n#line 200 \"lexer.l\"\n{ return _CONTAINS_;    }\n\tYY_BREAK\ncase 37:\nYY_RULE_SETUP\n#line 201 \"lexer.l\"\n{ return _IMPORT_;      }\n\tYY_BREAK\ncase 38:\nYY_RULE_SETUP\n#line 204 \"lexer.l\"\n{ BEGIN(comment);       }\n\tYY_BREAK\ncase 39:\nYY_RULE_SETUP\n#line 205 \"lexer.l\"\n{ BEGIN(INITIAL);       }\n\tYY_BREAK\ncase 40:\n/* rule 40 can match eol */\nYY_RULE_SETUP\n#line 206 \"lexer.l\"\n{ /* skip comments */   }\n\tYY_BREAK\ncase 41:\nYY_RULE_SETUP\n#line 209 \"lexer.l\"\n{ /* skip single-line comments */ }\n\tYY_BREAK\ncase 42:\nYY_RULE_SETUP\n#line 212 \"lexer.l\"\n{\n                          yyextra->lex_buf_ptr = yyextra->lex_buf;\n                          yyextra->lex_buf_len = 0;\n                          BEGIN(include);\n                        }\n\tYY_BREAK\ncase 43:\n/* rule 43 can match eol */\nYY_RULE_SETUP\n#line 219 \"lexer.l\"\n{ yytext_to_buffer; }\n\tYY_BREAK\ncase 44:\nYY_RULE_SETUP\n#line 222 \"lexer.l\"\n{\n\n  if (compiler->include_callback != NULL)\n  {\n    #ifdef _MSC_VER\n    char* b = NULL;\n    #endif\n    char* s = NULL;\n    char* f;\n\n    char buffer[1024];\n    const char* included_rules;\n    char* current_file_name;\n    char* include_path;\n\n    *yyextra->lex_buf_ptr = '\\0'; // null-terminate included file path\n\n    current_file_name = yr_compiler_get_current_file_name(compiler);\n\n    if (current_file_name == NULL ||\n        compiler->include_callback != _yr_compiler_default_include_callback ||\n        is_absolute_path(yyextra->lex_buf))\n    {\n      include_path = yyextra->lex_buf;\n    }\n    else\n    {\n      strlcpy(buffer, current_file_name, sizeof(buffer));\n      s = strrchr(buffer, '/');\n\n      #ifdef _MSC_VER\n      b = strrchr(buffer, '\\\\'); // in Windows both path delimiters are accepted\n      #endif\n\n      #ifdef _MSC_VER\n      if (s != NULL || b != NULL)\n      #else\n      if (s != NULL)\n      #endif\n      {\n        #ifdef _MSC_VER\n        f = (b > s) ? (b + 1) : (s + 1);\n        #else\n        f = s + 1;\n        #endif\n\n        strlcpy(f, yyextra->lex_buf, sizeof(buffer) - (f - buffer));\n        include_path = buffer;\n      }\n      else\n      {\n        include_path = yyextra->lex_buf;\n      }\n    }\n\n    included_rules = compiler->include_callback(\n        include_path,\n        current_file_name,\n        compiler->current_namespace->name,\n        compiler->incl_clbk_user_data);\n\n    if (included_rules != NULL)\n    {\n      int error_code = _yr_compiler_push_file_name(compiler, include_path);\n\n      if (error_code != ERROR_SUCCESS)\n      {\n        if (error_code == ERROR_INCLUDES_CIRCULAR_REFERENCE)\n        {\n          yyerror(yyscanner, compiler, \"includes circular reference\");\n        }\n        else if (error_code == ERROR_INCLUDE_DEPTH_EXCEEDED)\n        {\n          yyerror(yyscanner, compiler, \"includes depth exceeded\");\n        }\n\n        if (compiler->include_free != NULL)\n        {\n          compiler->include_free(included_rules, compiler->incl_clbk_user_data);\n        }\n\n        yyterminate();\n      }\n\n      // Workaround for flex issue: https://github.com/westes/flex/issues/58\n      yypush_buffer_state(YY_CURRENT_BUFFER, yyscanner);\n      yy_scan_string(included_rules, yyscanner);\n      yyset_lineno(1, yyscanner);\n\n      if (compiler->include_free != NULL)\n      {\n        compiler->include_free(included_rules, compiler->incl_clbk_user_data);\n      }\n    }\n    else\n    {\n      char* err_msg_fmt;\n      char err_msg[512];\n\n      if (compiler->include_callback == _yr_compiler_default_include_callback)\n      {\n        err_msg_fmt = \"can't open include file: %s\";\n      }\n      else\n      {\n        err_msg_fmt = \"callback failed to provide include resource: %s\";\n      }\n\n      snprintf(\n          err_msg,\n          sizeof(err_msg),\n          err_msg_fmt,\n          yyextra->lex_buf);\n\n      yyerror(yyscanner, compiler, err_msg);\n    }\n\n  }\n  else // not allowing includes\n  {\n    yyerror(yyscanner, compiler, \"includes are disabled\");\n  }\n\n  BEGIN(INITIAL);\n}\n\tYY_BREAK\ncase YY_STATE_EOF(INITIAL):\ncase YY_STATE_EOF(str):\ncase YY_STATE_EOF(regexp):\ncase YY_STATE_EOF(include):\ncase YY_STATE_EOF(comment):\n#line 349 \"lexer.l\"\n{\n\n  yypop_buffer_state(yyscanner);\n\n  if (!YY_CURRENT_BUFFER)\n    yyterminate();\n\n  return _END_OF_INCLUDED_FILE_;\n}\n\tYY_BREAK\ncase 45:\nYY_RULE_SETUP\n#line 360 \"lexer.l\"\n{\n\n  yylval->c_string = yr_strdup(yytext);\n\n  if (yylval->c_string == NULL)\n    error(ERROR_INSUFFICIENT_MEMORY);\n\n  return _STRING_IDENTIFIER_WITH_WILDCARD_;\n}\n\tYY_BREAK\ncase 46:\nYY_RULE_SETUP\n#line 371 \"lexer.l\"\n{\n\n  yylval->c_string = yr_strdup(yytext);\n\n  if (yylval->c_string == NULL)\n    error(ERROR_INSUFFICIENT_MEMORY);\n\n  return _STRING_IDENTIFIER_;\n}\n\tYY_BREAK\ncase 47:\nYY_RULE_SETUP\n#line 382 \"lexer.l\"\n{\n\n  yylval->c_string = yr_strdup(yytext);\n\n  if (yylval->c_string == NULL)\n  {\n    error(ERROR_INSUFFICIENT_MEMORY);\n  }\n  else\n  {\n    yylval->c_string[0] = '$'; /* replace # by $*/\n  }\n\n  return _STRING_COUNT_;\n}\n\tYY_BREAK\ncase 48:\nYY_RULE_SETUP\n#line 399 \"lexer.l\"\n{\n\n  yylval->c_string = yr_strdup(yytext);\n\n  if (yylval->c_string == NULL)\n  {\n    error(ERROR_INSUFFICIENT_MEMORY);\n  }\n  else\n  {\n    yylval->c_string[0] = '$'; /* replace @ by $*/\n  }\n\n  return _STRING_OFFSET_;\n}\n\tYY_BREAK\ncase 49:\nYY_RULE_SETUP\n#line 416 \"lexer.l\"\n{\n\n  yylval->c_string = yr_strdup(yytext);\n\n  if (yylval->c_string == NULL)\n  {\n    error(ERROR_INSUFFICIENT_MEMORY);\n  }\n  else\n  {\n    yylval->c_string[0] = '$'; /* replace ! by $*/\n  }\n\n  return _STRING_LENGTH_;\n}\n\tYY_BREAK\ncase 50:\nYY_RULE_SETUP\n#line 433 \"lexer.l\"\n{\n\n  char* text = yytext;\n\n  if (*text == 'u')\n  {\n    yylval->integer = 3;\n    text++;\n  }\n  else\n  {\n    yylval->integer = 0;\n  }\n\n  if (strstr(text, \"int8\") == text)\n  {\n    yylval->integer += 0;\n    text += 4;\n  }\n  else if (strstr(text, \"int16\") == text)\n  {\n    yylval->integer += 1;\n    text += 5;\n  }\n  else if (strstr(text, \"int32\") == text)\n  {\n    yylval->integer += 2;\n    text += 5;\n  }\n\n  if (strcmp(text, \"be\") == 0)\n  {\n    yylval->integer += 6;\n  }\n\n  return _INTEGER_FUNCTION_;\n}\n\tYY_BREAK\ncase 51:\nYY_RULE_SETUP\n#line 472 \"lexer.l\"\n{\n\n  if (strlen(yytext) > 128)\n    syntax_error(\"identifier too long\");\n\n  yylval->c_string = yr_strdup(yytext);\n\n  if (yylval->c_string == NULL)\n    error(ERROR_INSUFFICIENT_MEMORY);\n\n  return _IDENTIFIER_;\n}\n\tYY_BREAK\ncase 52:\nYY_RULE_SETUP\n#line 486 \"lexer.l\"\n{\n\n  char *endptr;\n\n  errno = 0;\n  yylval->integer = strtoll(yytext, &endptr, 10);\n\n  if (yylval->integer == LLONG_MAX && errno == ERANGE)\n  {\n    yr_compiler_set_error_extra_info(compiler, yytext);\n    error(ERROR_INTEGER_OVERFLOW);\n  }\n  else if (strstr(yytext, \"KB\") != NULL)\n  {\n    if (yylval->integer > LLONG_MAX / 1024)\n    {\n      yr_compiler_set_error_extra_info(compiler, yytext);\n      error(ERROR_INTEGER_OVERFLOW);\n    }\n    else\n    {\n      yylval->integer *= 1024;\n    }\n  }\n  else if (strstr(yytext, \"MB\") != NULL)\n  {\n    if (yylval->integer > LLONG_MAX / 1048576)\n    {\n      yr_compiler_set_error_extra_info(compiler, yytext);\n      error(ERROR_INTEGER_OVERFLOW);\n    }\n    else\n    {\n      yylval->integer *= 1048576;\n    }\n  }\n\n  return _NUMBER_;\n}\n\tYY_BREAK\ncase 53:\nYY_RULE_SETUP\n#line 526 \"lexer.l\"\n{\n  yylval->double_ = atof(yytext);\n  return _DOUBLE_;\n}\n\tYY_BREAK\ncase 54:\nYY_RULE_SETUP\n#line 531 \"lexer.l\"\n{\n\n  char *endptr;\n\n  errno = 0;\n  yylval->integer = strtoll(yytext, &endptr, 16);\n\n  if (yylval->integer == LLONG_MAX && errno == ERANGE)\n  {\n    yr_compiler_set_error_extra_info(compiler, yytext);\n    error(ERROR_INTEGER_OVERFLOW);\n  }\n\n  return _NUMBER_;\n}\n\tYY_BREAK\ncase 55:\nYY_RULE_SETUP\n#line 547 \"lexer.l\"\n{\n\n  char *endptr;\n\n  errno = 0;\n  yylval->integer = strtoll(yytext + 2, &endptr, 8);\n\n  if (yylval->integer == LLONG_MAX && errno == ERANGE)\n  {\n    yr_compiler_set_error_extra_info(compiler, yytext);\n    error(ERROR_INTEGER_OVERFLOW);\n  }\n\n  return _NUMBER_;\n}\n\tYY_BREAK\ncase 56:\nYY_RULE_SETUP\n#line 564 \"lexer.l\"\n{     /* saw closing quote - all done */\n\n  alloc_sized_string(s, yyextra->lex_buf_len);\n\n  *yyextra->lex_buf_ptr = '\\0';\n  memcpy(s->c_string, yyextra->lex_buf, yyextra->lex_buf_len + 1);\n  yylval->sized_string = s;\n\n  BEGIN(INITIAL);\n\n  return _TEXT_STRING_;\n}\n\tYY_BREAK\ncase 57:\nYY_RULE_SETUP\n#line 578 \"lexer.l\"\n{\n\n  lex_check_space_ok(\"\\t\", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);\n  *yyextra->lex_buf_ptr++ = '\\t';\n  yyextra->lex_buf_len++;\n}\n\tYY_BREAK\ncase 58:\nYY_RULE_SETUP\n#line 586 \"lexer.l\"\n{\n\n  lex_check_space_ok(\"\\n\", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);\n  *yyextra->lex_buf_ptr++ = '\\n';\n  yyextra->lex_buf_len++;\n}\n\tYY_BREAK\ncase 59:\nYY_RULE_SETUP\n#line 594 \"lexer.l\"\n{\n\n  lex_check_space_ok(\"\\\"\", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);\n  *yyextra->lex_buf_ptr++ = '\\\"';\n  yyextra->lex_buf_len++;\n}\n\tYY_BREAK\ncase 60:\nYY_RULE_SETUP\n#line 602 \"lexer.l\"\n{\n\n  lex_check_space_ok(\"\\\\\", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);\n  *yyextra->lex_buf_ptr++ = '\\\\';\n  yyextra->lex_buf_len++;\n}\n\tYY_BREAK\ncase 61:\nYY_RULE_SETUP\n#line 610 \"lexer.l\"\n{\n\n   int result;\n\n   sscanf( yytext + 2, \"%x\", &result );\n   lex_check_space_ok(\"X\", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);\n   *yyextra->lex_buf_ptr++ = result;\n   yyextra->lex_buf_len++;\n}\n\tYY_BREAK\ncase 62:\nYY_RULE_SETUP\n#line 621 \"lexer.l\"\n{ yytext_to_buffer; }\n\tYY_BREAK\ncase 63:\n/* rule 63 can match eol */\nYY_RULE_SETUP\n#line 624 \"lexer.l\"\n{\n  syntax_error(\"unterminated string\");\n}\n\tYY_BREAK\ncase 64:\n/* rule 64 can match eol */\nYY_RULE_SETUP\n#line 629 \"lexer.l\"\n{\n  syntax_error(\"illegal escape sequence\");\n}\n\tYY_BREAK\ncase 65:\nYY_RULE_SETUP\n#line 634 \"lexer.l\"\n{\n\n  if (yyextra->lex_buf_len > 0)\n  {\n    alloc_sized_string(s, yyextra->lex_buf_len);\n\n    if (yytext[1] == 'i')\n      s->flags |= SIZED_STRING_FLAGS_NO_CASE;\n\n    if (yytext[1] == 's' || yytext[2] == 's')\n      s->flags |= SIZED_STRING_FLAGS_DOT_ALL;\n\n    *yyextra->lex_buf_ptr = '\\0';\n    strlcpy(s->c_string, yyextra->lex_buf, s->length + 1);\n    yylval->sized_string = s;\n  }\n  else\n  {\n    syntax_error(\"empty regular expression\");\n  }\n\n  BEGIN(INITIAL);\n  return _REGEXP_;\n}\n\tYY_BREAK\ncase 66:\nYY_RULE_SETUP\n#line 660 \"lexer.l\"\n{\n\n  lex_check_space_ok(\"/\", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);\n  *yyextra->lex_buf_ptr++ = '/';\n  yyextra->lex_buf_len++ ;\n}\n\tYY_BREAK\ncase 67:\nYY_RULE_SETUP\n#line 668 \"lexer.l\"\n{\n\n  lex_check_space_ok(\"\\\\.\", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);\n\n  if (yytext[1] == 0)\n    syntax_error(\"malformed regular expression\");\n\n  *yyextra->lex_buf_ptr++ = yytext[0];\n  *yyextra->lex_buf_ptr++ = yytext[1];\n  yyextra->lex_buf_len += 2;\n}\n\tYY_BREAK\ncase 68:\nYY_RULE_SETUP\n#line 681 \"lexer.l\"\n{ yytext_to_buffer; }\n\tYY_BREAK\ncase 69:\n/* rule 69 can match eol */\nYY_RULE_SETUP\n#line 684 \"lexer.l\"\n{\n  syntax_error(\"unterminated regular expression\");\n}\n\tYY_BREAK\ncase 70:\nYY_RULE_SETUP\n#line 689 \"lexer.l\"\n{\n\n  yylval->sized_string = NULL;\n  yyextra->lex_buf_ptr = yyextra->lex_buf;\n  yyextra->lex_buf_len = 0;\n  BEGIN(str);\n}\n\tYY_BREAK\ncase 71:\nYY_RULE_SETUP\n#line 698 \"lexer.l\"\n{\n\n  yylval->sized_string = NULL;\n  yyextra->lex_buf_ptr = yyextra->lex_buf;\n  yyextra->lex_buf_len = 0;\n  BEGIN(regexp);\n}\n\tYY_BREAK\ncase 72:\n/* rule 72 can match eol */\nYY_RULE_SETUP\n#line 707 \"lexer.l\"\n{\n  // Match hex-digits with whitespace or comments. The latter are stripped\n  // out by hex_lexer.l\n  // TODO(vmalvarez): Integrate the hex string lexer and parser into this one,\n  // by having a single lexer/parser instead of two different ones we can avoid\n  // complex regular expressions like the one above, which is actually trying to\n  // do some parsing in the lexer.\n\n  alloc_sized_string(s, strlen(yytext));\n\n  strlcpy(s->c_string, yytext, s->length + 1);\n  yylval->sized_string = s;\n\n  return _HEX_STRING_;\n}\n\tYY_BREAK\ncase 73:\n/* rule 73 can match eol */\nYY_RULE_SETUP\n#line 724 \"lexer.l\"\n/* skip whitespace */\n\tYY_BREAK\ncase 74:\nYY_RULE_SETUP\n#line 726 \"lexer.l\"\n{\n\n  if (yytext[0] >= 32 && yytext[0] < 127)\n  {\n    return yytext[0];\n  }\n  else\n  {\n    syntax_error(\"non-ascii character\");\n  }\n}\n\tYY_BREAK\ncase 75:\nYY_RULE_SETUP\n#line 738 \"lexer.l\"\nECHO;\n\tYY_BREAK\n#line 2308 \"lexer.c\"\n\n\tcase YY_END_OF_BUFFER:\n\t\t{\n\t\t/* Amount of text matched not including the EOB char. */\n\t\tint yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;\n\n\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */\n\t\t*yy_cp = yyg->yy_hold_char;\n\t\tYY_RESTORE_YY_MORE_OFFSET\n\n\t\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )\n\t\t\t{\n\t\t\t/* We're scanning a new file or input source.  It's\n\t\t\t * possible that this happened because the user\n\t\t\t * just pointed yyin at a new source and called\n\t\t\t * yylex().  If so, then we have to assure\n\t\t\t * consistency between YY_CURRENT_BUFFER and our\n\t\t\t * globals.  Here is the right place to do so, because\n\t\t\t * this is the first action (other than possibly a\n\t\t\t * back-up) that will match for the new input source.\n\t\t\t */\n\t\t\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;\n\t\t\t}\n\n\t\t/* Note that here we test for yy_c_buf_p \"<=\" to the position\n\t\t * of the first EOB in the buffer, since yy_c_buf_p will\n\t\t * already have been incremented past the NUL character\n\t\t * (since all states make transitions on EOB to the\n\t\t * end-of-buffer state).  Contrast this with the test\n\t\t * in input().\n\t\t */\n\t\tif ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )\n\t\t\t{ /* This was really a NUL. */\n\t\t\tyy_state_type yy_next_state;\n\n\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;\n\n\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t/* Okay, we're now positioned to make the NUL\n\t\t\t * transition.  We couldn't have\n\t\t\t * yy_get_previous_state() go ahead and do it\n\t\t\t * for us because it doesn't know how to deal\n\t\t\t * with the possibility of jamming (and we don't\n\t\t\t * want to build jamming into it because then it\n\t\t\t * will run more slowly).\n\t\t\t */\n\n\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);\n\n\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\n\t\t\tif ( yy_next_state )\n\t\t\t\t{\n\t\t\t\t/* Consume the NUL. */\n\t\t\t\tyy_cp = ++yyg->yy_c_buf_p;\n\t\t\t\tyy_current_state = yy_next_state;\n\t\t\t\tgoto yy_match;\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\t\t\tyy_current_state = yyg->yy_last_accepting_state;\n\t\t\t\tgoto yy_find_action;\n\t\t\t\t}\n\t\t\t}\n\n\t\telse switch ( yy_get_next_buffer( yyscanner ) )\n\t\t\t{\n\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t{\n\t\t\t\tyyg->yy_did_buffer_switch_on_eof = 0;\n\n\t\t\t\tif ( yywrap( yyscanner ) )\n\t\t\t\t\t{\n\t\t\t\t\t/* Note: because we've taken care in\n\t\t\t\t\t * yy_get_next_buffer() to have set up\n\t\t\t\t\t * yytext, we can now set up\n\t\t\t\t\t * yy_c_buf_p so that if some total\n\t\t\t\t\t * hoser (like flex itself) wants to\n\t\t\t\t\t * call the scanner after we return the\n\t\t\t\t\t * YY_NULL, it'll still work - another\n\t\t\t\t\t * YY_NULL will get returned.\n\t\t\t\t\t */\n\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;\n\n\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);\n\t\t\t\t\tgoto do_action;\n\t\t\t\t\t}\n\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\tyyg->yy_c_buf_p =\n\t\t\t\t\tyyg->yytext_ptr + yy_amount_of_matched_text;\n\n\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t\tyy_cp = yyg->yy_c_buf_p;\n\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_match;\n\n\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\tyyg->yy_c_buf_p =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];\n\n\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t\tyy_cp = yyg->yy_c_buf_p;\n\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_find_action;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\tYY_FATAL_ERROR(\n\t\t\t\"fatal flex scanner internal error--no action found\" );\n\t} /* end of action switch */\n\t\t} /* end of scanning one token */\n\t} /* end of user's declarations */\n}",
        "begin_line": 1384,
        "end_line": 2438,
        "is_bug": false
    },
    {
        "name": "libyara.libyara.yr_finalize#207",
        "src_path": "libyara/libyara.c",
        "class_name": "libyara.libyara",
        "signature": "libyara.libyara.yr_finalize(void)",
        "snippet": "YR_API int yr_finalize(void)\n{\n  #if defined HAVE_LIBCRYPTO && OPENSSL_VERSION_NUMBER < 0x10100000L\n  int i;\n  #endif\n\n  // yr_finalize shouldn't be called without calling yr_initialize first\n\n  if (init_count == 0)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  init_count--;\n\n  if (init_count > 0)\n    return ERROR_SUCCESS;\n\n  #if defined HAVE_LIBCRYPTO && OPENSSL_VERSION_NUMBER < 0x10100000L\n\n  for (i = 0; i < CRYPTO_num_locks(); i ++)\n    yr_mutex_destroy(&openssl_locks[i]);\n\n  OPENSSL_free(openssl_locks);\n  CRYPTO_THREADID_set_callback(NULL);\n  CRYPTO_set_locking_callback(NULL);\n\n  #elif defined(HAVE_WINCRYPT_H)\n\n  CryptReleaseContext(yr_cryptprov, 0);\n\n  #endif\n\n  FAIL_ON_ERROR(yr_thread_storage_destroy(&yr_tidx_key));\n  FAIL_ON_ERROR(yr_thread_storage_destroy(&yr_recovery_state_key));\n  FAIL_ON_ERROR(yr_modules_finalize());\n  FAIL_ON_ERROR(yr_heap_free());\n\n  #if defined(JEMALLOC)\n  malloc_stats_print(NULL, NULL, NULL);\n  mallctl(\"prof.dump\", NULL, NULL, NULL, 0);\n  #endif\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 207,
        "end_line": 249,
        "is_bug": false
    },
    {
        "name": "libyara.libyara.yr_initialize#117",
        "src_path": "libyara/libyara.c",
        "class_name": "libyara.libyara",
        "signature": "libyara.libyara.yr_initialize(void)",
        "snippet": "YR_API int yr_initialize(void)\n{\n  uint32_t def_stack_size = DEFAULT_STACK_SIZE;\n  uint32_t def_max_strings_per_rule = DEFAULT_MAX_STRINGS_PER_RULE;\n  uint32_t def_max_match_data = DEFAULT_MAX_MATCH_DATA;\n\n  int i;\n\n  init_count++;\n\n  if (init_count > 1)\n    return ERROR_SUCCESS;\n\n  srand((unsigned) time(NULL));\n\n  yr_canary = rand();\n\n  for (i = 0; i < 256; i++)\n  {\n    if (i >= 'a' && i <= 'z')\n      yr_altercase[i] = i - 32;\n    else if (i >= 'A' && i <= 'Z')\n      yr_altercase[i] = i + 32;\n    else\n      yr_altercase[i] = i;\n\n    yr_lowercase[i] = tolower(i);\n  }\n\n  FAIL_ON_ERROR(yr_heap_alloc());\n  FAIL_ON_ERROR(yr_thread_storage_create(&yr_tidx_key));\n  FAIL_ON_ERROR(yr_thread_storage_create(&yr_recovery_state_key));\n\n  #if defined HAVE_LIBCRYPTO && OPENSSL_VERSION_NUMBER < 0x10100000L\n\n  openssl_locks = (YR_MUTEX*) OPENSSL_malloc(\n      CRYPTO_num_locks() * sizeof(YR_MUTEX));\n\n  for (i = 0; i < CRYPTO_num_locks(); i++)\n    yr_mutex_create(&openssl_locks[i]);\n\n  CRYPTO_THREADID_set_callback(_thread_id);\n  CRYPTO_set_locking_callback(_locking_function);\n\n  #elif defined(HAVE_WINCRYPT_H)\n\n  if (!CryptAcquireContext(&yr_cryptprov, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {\n    return ERROR_INTERNAL_FATAL_ERROR;\n  }\n\n  #elif defined(HAVE_COMMON_CRYPTO)\n\n  ...\n\n  #endif\n\n  FAIL_ON_ERROR(yr_modules_initialize());\n\n  // Initialize default configuration options\n  FAIL_ON_ERROR(yr_set_configuration(\n      YR_CONFIG_STACK_SIZE, &def_stack_size));\n\n  FAIL_ON_ERROR(yr_set_configuration(\n      YR_CONFIG_MAX_STRINGS_PER_RULE, &def_max_strings_per_rule));\n\n  FAIL_ON_ERROR(yr_set_configuration(\n      YR_CONFIG_MAX_MATCH_DATA, &def_max_match_data));\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 117,
        "end_line": 186,
        "is_bug": false
    },
    {
        "name": "libyara.libyara.yr_set_configuration#305",
        "src_path": "libyara/libyara.c",
        "class_name": "libyara.libyara",
        "signature": "libyara.libyara.yr_set_configuration(     YR_CONFIG_NAME name, void *src)",
        "snippet": "YR_API int yr_set_configuration(\n    YR_CONFIG_NAME name,\n    void *src)\n{\n  if (src == NULL)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  switch (name)\n  { // lump all the cases using same types together in one cascade\n    case YR_CONFIG_STACK_SIZE:\n    case YR_CONFIG_MAX_STRINGS_PER_RULE:\n    case YR_CONFIG_MAX_MATCH_DATA:\n      yr_cfgs[name].ui32 = *(uint32_t*) src;\n      break;\n\n    default:\n      return ERROR_INTERNAL_FATAL_ERROR;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 305,
        "end_line": 325,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_free#151",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_free(void *ptr)",
        "snippet": "void yr_free(void *ptr)\n{\n  free(ptr);\n}",
        "begin_line": 151,
        "end_line": 154,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_heap_alloc#121",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_heap_alloc(void)",
        "snippet": "int yr_heap_alloc(void)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 121,
        "end_line": 124,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_heap_free#127",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_heap_free(void)",
        "snippet": "int yr_heap_free(void)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 127,
        "end_line": 130,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_malloc#139",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_malloc(size_t size)",
        "snippet": "void* yr_malloc(size_t size)\n{\n  return malloc(size);\n}",
        "begin_line": 139,
        "end_line": 142,
        "is_bug": false
    },
    {
        "name": "libyara.modules.elf.module_finalize#582",
        "src_path": "libyara/modules/elf.c",
        "class_name": "libyara.modules.elf",
        "signature": "libyara.modules.elf.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 582,
        "end_line": 586,
        "is_bug": false
    },
    {
        "name": "libyara.modules.elf.module_initialize#575",
        "src_path": "libyara/modules/elf.c",
        "class_name": "libyara.modules.elf",
        "signature": "libyara.modules.elf.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 575,
        "end_line": 579,
        "is_bug": false
    },
    {
        "name": "libyara.modules.hash.module_finalize#506",
        "src_path": "libyara/modules/hash.c",
        "class_name": "libyara.modules.hash",
        "signature": "libyara.modules.hash.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 506,
        "end_line": 510,
        "is_bug": false
    },
    {
        "name": "libyara.modules.hash.module_initialize#499",
        "src_path": "libyara/modules/hash.c",
        "class_name": "libyara.modules.hash",
        "signature": "libyara.modules.hash.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 499,
        "end_line": 503,
        "is_bug": false
    },
    {
        "name": "libyara.modules.math.module_finalize#645",
        "src_path": "libyara/modules/math.c",
        "class_name": "libyara.modules.math",
        "signature": "libyara.modules.math.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 645,
        "end_line": 649,
        "is_bug": false
    },
    {
        "name": "libyara.modules.math.module_initialize#638",
        "src_path": "libyara/modules/math.c",
        "class_name": "libyara.modules.math",
        "signature": "libyara.modules.math.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 638,
        "end_line": 642,
        "is_bug": false
    },
    {
        "name": "libyara.modules.pe.module_finalize#2629",
        "src_path": "libyara/modules/pe.c",
        "class_name": "libyara.modules.pe",
        "signature": "libyara.modules.pe.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 2629,
        "end_line": 2633,
        "is_bug": false
    },
    {
        "name": "libyara.modules.pe.module_initialize#2622",
        "src_path": "libyara/modules/pe.c",
        "class_name": "libyara.modules.pe",
        "signature": "libyara.modules.pe.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 2622,
        "end_line": 2626,
        "is_bug": false
    },
    {
        "name": "libyara.modules.tests.module_finalize#163",
        "src_path": "libyara/modules/tests.c",
        "class_name": "libyara.modules.tests",
        "signature": "libyara.modules.tests.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 163,
        "end_line": 167,
        "is_bug": false
    },
    {
        "name": "libyara.modules.tests.module_initialize#156",
        "src_path": "libyara/modules/tests.c",
        "class_name": "libyara.modules.tests",
        "signature": "libyara.modules.tests.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 156,
        "end_line": 160,
        "is_bug": false
    },
    {
        "name": "libyara.modules.time.module_finalize#59",
        "src_path": "libyara/modules/time.c",
        "class_name": "libyara.modules.time",
        "signature": "libyara.modules.time.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 59,
        "end_line": 63,
        "is_bug": false
    },
    {
        "name": "libyara.modules.time.module_initialize#52",
        "src_path": "libyara/modules/time.c",
        "class_name": "libyara.modules.time",
        "signature": "libyara.modules.time.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 52,
        "end_line": 56,
        "is_bug": false
    },
    {
        "name": "libyara.modules.yr_modules_finalize#85",
        "src_path": "libyara/modules.c",
        "class_name": "libyara.modules",
        "signature": "libyara.modules.yr_modules_finalize()",
        "snippet": "int yr_modules_finalize()\n{\n  int i;\n\n  for (i = 0; i < sizeof(yr_modules_table) / sizeof(YR_MODULE); i++)\n  {\n    int result = yr_modules_table[i].finalize(&yr_modules_table[i]);\n\n    if (result != ERROR_SUCCESS)\n      return result;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 85,
        "end_line": 98,
        "is_bug": false
    },
    {
        "name": "libyara.modules.yr_modules_initialize#69",
        "src_path": "libyara/modules.c",
        "class_name": "libyara.modules",
        "signature": "libyara.modules.yr_modules_initialize()",
        "snippet": "int yr_modules_initialize()\n{\n  int i;\n\n  for (i = 0; i < sizeof(yr_modules_table) / sizeof(YR_MODULE); i++)\n  {\n    int result = yr_modules_table[i].initialize(&yr_modules_table[i]);\n\n    if (result != ERROR_SUCCESS)\n      return result;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 69,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_ast_create#208",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_ast_create(     RE_AST** re_ast)",
        "snippet": "int yr_re_ast_create(\n    RE_AST** re_ast)\n{\n  *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));\n\n  if (*re_ast == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  (*re_ast)->flags = 0;\n  (*re_ast)->root_node = NULL;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 208,
        "end_line": 220,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_ast_destroy#223",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_ast_destroy(     RE_AST* re_ast)",
        "snippet": "void yr_re_ast_destroy(\n    RE_AST* re_ast)\n{\n  if (re_ast->root_node != NULL)\n    yr_re_node_destroy(re_ast->root_node);\n\n  yr_free(re_ast);\n}",
        "begin_line": 223,
        "end_line": 230,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_node_append_child#172",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_node_append_child(     RE_NODE* node, RE_NODE* child)",
        "snippet": "void yr_re_node_append_child(\n    RE_NODE* node,\n    RE_NODE* child)\n{\n  if (node->children_head == NULL)\n    node->children_head = child;\n\n  if (node->children_tail != NULL)\n    node->children_tail->next_sibling = child;\n\n  child->prev_sibling = node->children_tail;\n  node->children_tail = child;\n}",
        "begin_line": 172,
        "end_line": 184,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_node_create#126",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_node_create(     int type)",
        "snippet": "RE_NODE* yr_re_node_create(\n    int type)\n{\n  RE_NODE* result = (RE_NODE*) yr_malloc(sizeof(RE_NODE));\n\n  if (result != NULL)\n  {\n    result->type = type;\n    result->children_head = NULL;\n    result->children_tail = NULL;\n    result->prev_sibling = NULL;\n    result->next_sibling = NULL;\n    result->greedy = true;\n    result->forward_code = NULL;\n    result->backward_code = NULL;\n  }\n\n  return result;\n}",
        "begin_line": 126,
        "end_line": 144,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_node_destroy#147",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_node_destroy(     RE_NODE* node)",
        "snippet": "void yr_re_node_destroy(\n    RE_NODE* node)\n{\n  RE_NODE* child = node->children_head;\n  RE_NODE* next_child;\n\n  while (child != NULL)\n  {\n    next_child = child->next_sibling;\n    yr_re_node_destroy(child);\n    child = next_child;\n  }\n\n  if (node->type == RE_NODE_CLASS)\n    yr_free(node->re_class);\n\n  yr_free(node);\n}",
        "begin_line": 147,
        "end_line": 164,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_node_prepend_child#192",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_node_prepend_child(     RE_NODE* node, RE_NODE* child)",
        "snippet": "void yr_re_node_prepend_child(\n    RE_NODE* node,\n    RE_NODE* child)\n{\n  child->next_sibling = node->children_head;\n\n  if (node->children_head != NULL)\n    node->children_head->prev_sibling = child;\n\n  node->children_head = child;\n\n  if (node->children_tail == NULL)\n    node->children_tail = child;\n}",
        "begin_line": 192,
        "end_line": 205,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_parse_hex#256",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_parse_hex(     const char* hex_string, RE_AST** re_ast, RE_ERROR* error)",
        "snippet": "int yr_re_parse_hex(\n    const char* hex_string,\n    RE_AST** re_ast,\n    RE_ERROR* error)\n{\n  return yr_parse_hex_string(hex_string, re_ast, error);\n}",
        "begin_line": 256,
        "end_line": 262,
        "is_bug": false
    },
    {
        "name": "libyara.stack.yr_stack_create#46",
        "src_path": "libyara/stack.c",
        "class_name": "libyara.stack",
        "signature": "libyara.stack.yr_stack_create(     int initial_capacity, int item_size, YR_STACK** stack)",
        "snippet": "int yr_stack_create(\n    int initial_capacity,\n    int item_size,\n    YR_STACK** stack)\n{\n  *stack = (YR_STACK*) yr_malloc(sizeof(YR_STACK));\n\n  if (*stack == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  (*stack)->items = yr_malloc(initial_capacity * item_size);\n\n  if ((*stack)->items == NULL)\n  {\n    yr_free(*stack);\n    *stack = NULL;\n    return ERROR_INSUFFICIENT_MEMORY;\n  }\n\n  (*stack)->capacity = initial_capacity;\n  (*stack)->item_size = item_size;\n  (*stack)->top = 0;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 46,
        "end_line": 70,
        "is_bug": false
    },
    {
        "name": "libyara.stack.yr_stack_destroy#78",
        "src_path": "libyara/stack.c",
        "class_name": "libyara.stack",
        "signature": "libyara.stack.yr_stack_destroy(     YR_STACK* stack)",
        "snippet": "void yr_stack_destroy(\n    YR_STACK* stack)\n{\n  yr_free(stack->items);\n  yr_free(stack);\n}",
        "begin_line": 78,
        "end_line": 83,
        "is_bug": false
    },
    {
        "name": "libyara.stack.yr_stack_pop#130",
        "src_path": "libyara/stack.c",
        "class_name": "libyara.stack",
        "signature": "libyara.stack.yr_stack_pop(     YR_STACK* stack, void* item)",
        "snippet": "int yr_stack_pop(\n    YR_STACK* stack,\n    void* item)\n{\n  if (stack->top == 0)  // Return 0 if stack is empty.\n    return 0;\n\n  stack->top--;\n\n  memcpy(\n      item,\n      (uint8_t*) stack->items + stack->top * stack->item_size,\n      stack->item_size);\n\n  return 1;\n}",
        "begin_line": 130,
        "end_line": 145,
        "is_bug": false
    },
    {
        "name": "libyara.stack.yr_stack_push#94",
        "src_path": "libyara/stack.c",
        "class_name": "libyara.stack",
        "signature": "libyara.stack.yr_stack_push(     YR_STACK* stack, void* item)",
        "snippet": "int yr_stack_push(\n    YR_STACK* stack,\n    void* item)\n{\n  if (stack->top == stack->capacity)\n  {\n    void* items = yr_realloc(\n        stack->items, 2 * stack->capacity * stack->item_size);\n\n    if (items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    stack->items = items;\n    stack->capacity *= 2;\n  }\n\n  memcpy(\n      (uint8_t*) stack->items + stack->top * stack->item_size,\n      item,\n      stack->item_size);\n\n  stack->top++;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 94,
        "end_line": 118,
        "is_bug": false
    },
    {
        "name": "libyara.strutils.xtoi#35",
        "src_path": "libyara/strutils.c",
        "class_name": "libyara.strutils",
        "signature": "libyara.strutils.xtoi(     const char* hexstr)",
        "snippet": "uint64_t xtoi(\n    const char* hexstr)\n{\n  size_t i;\n  size_t l = strlen(hexstr);\n\n  uint64_t r = 0;\n\n  for (i = 0; i < l; i++)\n  {\n    switch (hexstr[i])\n    {\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        r |= ((uint64_t)(hexstr[i] - '0')) << ((l - i - 1) * 4);\n        break;\n      case 'a':\n      case 'b':\n      case 'c':\n      case 'd':\n      case 'e':\n      case 'f':\n        r |= ((uint64_t)(hexstr[i] - 'a' + 10)) << ((l - i - 1) * 4);\n        break;\n      case 'A':\n      case 'B':\n      case 'C':\n      case 'D':\n      case 'E':\n      case 'F':\n        r |= ((uint64_t)(hexstr[i] - 'A' + 10)) << ((l - i - 1) * 4);\n        break;\n      default:\n        i = l;  // force loop exit\n    }\n  }\n\n  return r;\n}",
        "begin_line": 35,
        "end_line": 81,
        "is_bug": false
    },
    {
        "name": "libyara.threading.yr_thread_storage_create#172",
        "src_path": "libyara/threading.c",
        "class_name": "libyara.threading",
        "signature": "libyara.threading.yr_thread_storage_create(     YR_THREAD_STORAGE_KEY* storage)",
        "snippet": "int yr_thread_storage_create(\n    YR_THREAD_STORAGE_KEY* storage)\n{\n  if (pthread_key_create(storage, NULL) != 0)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 172,
        "end_line": 179,
        "is_bug": false
    },
    {
        "name": "libyara.threading.yr_thread_storage_destroy#182",
        "src_path": "libyara/threading.c",
        "class_name": "libyara.threading",
        "signature": "libyara.threading.yr_thread_storage_destroy(     YR_THREAD_STORAGE_KEY* storage)",
        "snippet": "int yr_thread_storage_destroy(\n    YR_THREAD_STORAGE_KEY* storage)\n{\n  if (pthread_key_delete(*storage) != 0)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 182,
        "end_line": 189,
        "is_bug": false
    },
    {
        "name": "libyara.threading.yr_thread_storage_set_value#192",
        "src_path": "libyara/threading.c",
        "class_name": "libyara.threading",
        "signature": "libyara.threading.yr_thread_storage_set_value(     YR_THREAD_STORAGE_KEY* storage, void* value)",
        "snippet": "int yr_thread_storage_set_value(\n    YR_THREAD_STORAGE_KEY* storage,\n    void* value)\n{\n  if (pthread_setspecific(*storage, value) != 0)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 192,
        "end_line": 200,
        "is_bug": false
    }
]