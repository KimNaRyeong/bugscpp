[
    {
        "name": "libtiff.tif_aux.TIFFGetFieldDefaulted#309",
        "src_path": "libtiff/tif_aux.c",
        "class_name": "libtiff.tif_aux",
        "signature": "libtiff.tif_aux.TIFFGetFieldDefaulted(TIFF* tif, uint32 tag, ...)",
        "snippet": "int\nTIFFGetFieldDefaulted(TIFF* tif, uint32 tag, ...)\n{\n\tint ok;\n\tva_list ap;\n\n\tva_start(ap, tag);\n\tok =  TIFFVGetFieldDefaulted(tif, tag, ap);\n\tva_end(ap);\n\treturn (ok);\n}",
        "begin_line": 309,
        "end_line": 319,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_aux.TIFFVGetFieldDefaulted#173",
        "src_path": "libtiff/tif_aux.c",
        "class_name": "libtiff.tif_aux",
        "signature": "libtiff.tif_aux.TIFFVGetFieldDefaulted(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "int\nTIFFVGetFieldDefaulted(TIFF* tif, uint32 tag, va_list ap)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\n\tif (TIFFVGetField(tif, tag, ap))\n\t\treturn (1);\n\tswitch (tag) {\n\tcase TIFFTAG_SUBFILETYPE:\n\t\t*va_arg(ap, uint32 *) = td->td_subfiletype;\n\t\treturn (1);\n\tcase TIFFTAG_BITSPERSAMPLE:\n\t\t*va_arg(ap, uint16 *) = td->td_bitspersample;\n\t\treturn (1);\n\tcase TIFFTAG_THRESHHOLDING:\n\t\t*va_arg(ap, uint16 *) = td->td_threshholding;\n\t\treturn (1);\n\tcase TIFFTAG_FILLORDER:\n\t\t*va_arg(ap, uint16 *) = td->td_fillorder;\n\t\treturn (1);\n\tcase TIFFTAG_ORIENTATION:\n\t\t*va_arg(ap, uint16 *) = td->td_orientation;\n\t\treturn (1);\n\tcase TIFFTAG_SAMPLESPERPIXEL:\n\t\t*va_arg(ap, uint16 *) = td->td_samplesperpixel;\n\t\treturn (1);\n\tcase TIFFTAG_ROWSPERSTRIP:\n\t\t*va_arg(ap, uint32 *) = td->td_rowsperstrip;\n\t\treturn (1);\n\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\t*va_arg(ap, uint16 *) = td->td_minsamplevalue;\n\t\treturn (1);\n\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\t*va_arg(ap, uint16 *) = td->td_maxsamplevalue;\n\t\treturn (1);\n\tcase TIFFTAG_PLANARCONFIG:\n\t\t*va_arg(ap, uint16 *) = td->td_planarconfig;\n\t\treturn (1);\n\tcase TIFFTAG_RESOLUTIONUNIT:\n\t\t*va_arg(ap, uint16 *) = td->td_resolutionunit;\n\t\treturn (1);\n\tcase TIFFTAG_PREDICTOR:\n    {\n        TIFFPredictorState* sp = (TIFFPredictorState*) tif->tif_data;\n        if( sp == NULL )\n        {\n            TIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n                         \"Cannot get \\\"Predictor\\\" tag as plugin is not configured\");\n            *va_arg(ap, uint16*) = 0;\n            return 0;\n        }\n        *va_arg(ap, uint16*) = (uint16) sp->predictor;\n        return 1;\n    }\n\tcase TIFFTAG_DOTRANGE:\n\t\t*va_arg(ap, uint16 *) = 0;\n\t\t*va_arg(ap, uint16 *) = (1<<td->td_bitspersample)-1;\n\t\treturn (1);\n\tcase TIFFTAG_INKSET:\n\t\t*va_arg(ap, uint16 *) = INKSET_CMYK;\n\t\treturn 1;\n\tcase TIFFTAG_NUMBEROFINKS:\n\t\t*va_arg(ap, uint16 *) = 4;\n\t\treturn (1);\n\tcase TIFFTAG_EXTRASAMPLES:\n\t\t*va_arg(ap, uint16 *) = td->td_extrasamples;\n\t\t*va_arg(ap, uint16 **) = td->td_sampleinfo;\n\t\treturn (1);\n\tcase TIFFTAG_MATTEING:\n\t\t*va_arg(ap, uint16 *) =\n\t\t    (td->td_extrasamples == 1 &&\n\t\t     td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);\n\t\treturn (1);\n\tcase TIFFTAG_TILEDEPTH:\n\t\t*va_arg(ap, uint32 *) = td->td_tiledepth;\n\t\treturn (1);\n\tcase TIFFTAG_DATATYPE:\n\t\t*va_arg(ap, uint16 *) = td->td_sampleformat-1;\n\t\treturn (1);\n\tcase TIFFTAG_SAMPLEFORMAT:\n\t\t*va_arg(ap, uint16 *) = td->td_sampleformat;\n                return(1);\n\tcase TIFFTAG_IMAGEDEPTH:\n\t\t*va_arg(ap, uint32 *) = td->td_imagedepth;\n\t\treturn (1);\n\tcase TIFFTAG_YCBCRCOEFFICIENTS:\n\t\t{\n\t\t\t/* defaults are from CCIR Recommendation 601-1 */\n\t\t\tstatic float ycbcrcoeffs[] = { 0.299f, 0.587f, 0.114f };\n\t\t\t*va_arg(ap, float **) = ycbcrcoeffs;\n\t\t\treturn 1;\n\t\t}\n\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t*va_arg(ap, uint16 *) = td->td_ycbcrsubsampling[0];\n\t\t*va_arg(ap, uint16 *) = td->td_ycbcrsubsampling[1];\n\t\treturn (1);\n\tcase TIFFTAG_YCBCRPOSITIONING:\n\t\t*va_arg(ap, uint16 *) = td->td_ycbcrpositioning;\n\t\treturn (1);\n\tcase TIFFTAG_WHITEPOINT:\n\t\t{\n\t\t\tstatic float whitepoint[2];\n\n\t\t\t/* TIFF 6.0 specification tells that it is no default\n\t\t\t   value for the WhitePoint, but AdobePhotoshop TIFF\n\t\t\t   Technical Note tells that it should be CIE D50. */\n\t\t\twhitepoint[0] =\tD50_X0 / (D50_X0 + D50_Y0 + D50_Z0);\n\t\t\twhitepoint[1] =\tD50_Y0 / (D50_X0 + D50_Y0 + D50_Z0);\n\t\t\t*va_arg(ap, float **) = whitepoint;\n\t\t\treturn 1;\n\t\t}\n\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\tif (!td->td_transferfunction[0] &&\n\t\t    !TIFFDefaultTransferFunction(td)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"No space for \\\"TransferFunction\\\" tag\");\n\t\t\treturn (0);\n\t\t}\n\t\t*va_arg(ap, uint16 **) = td->td_transferfunction[0];\n\t\tif (td->td_samplesperpixel - td->td_extrasamples > 1) {\n\t\t\t*va_arg(ap, uint16 **) = td->td_transferfunction[1];\n\t\t\t*va_arg(ap, uint16 **) = td->td_transferfunction[2];\n\t\t}\n\t\treturn (1);\n\tcase TIFFTAG_REFERENCEBLACKWHITE:\n\t\tif (!td->td_refblackwhite && !TIFFDefaultRefBlackWhite(td))\n\t\t\treturn (0);\n\t\t*va_arg(ap, float **) = td->td_refblackwhite;\n\t\treturn (1);\n\t}\n\treturn 0;\n}",
        "begin_line": 173,
        "end_line": 303,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_aux._TIFFCheckMalloc#85",
        "src_path": "libtiff/tif_aux.c",
        "class_name": "libtiff.tif_aux",
        "signature": "libtiff.tif_aux._TIFFCheckMalloc(TIFF* tif, tmsize_t nmemb, tmsize_t elem_size, const char* what)",
        "snippet": "void*\n_TIFFCheckMalloc(TIFF* tif, tmsize_t nmemb, tmsize_t elem_size, const char* what)\n{\n\treturn _TIFFCheckRealloc(tif, NULL, nmemb, elem_size, what);  \n}",
        "begin_line": 85,
        "end_line": 89,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_aux._TIFFCheckRealloc#62",
        "src_path": "libtiff/tif_aux.c",
        "class_name": "libtiff.tif_aux",
        "signature": "libtiff.tif_aux._TIFFCheckRealloc(TIFF* tif, void* buffer, tmsize_t nmemb, tmsize_t elem_size, const char* what)",
        "snippet": "void*\n_TIFFCheckRealloc(TIFF* tif, void* buffer,\n\t\t  tmsize_t nmemb, tmsize_t elem_size, const char* what)\n{\n\tvoid* cp = NULL;\n\ttmsize_t bytes = nmemb * elem_size;\n\n\t/*\n\t * XXX: Check for integer overflow.\n\t */\n\tif (nmemb && elem_size && bytes / elem_size == nmemb)\n\t\tcp = _TIFFrealloc(buffer, bytes);\n\n\tif (cp == NULL) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t     \"Failed to allocate memory for %s \"\n\t\t\t     \"(%ld elements of %ld bytes each)\",\n\t\t\t     what,(long) nmemb, (long) elem_size);\n\t}\n\n\treturn cp;\n}",
        "begin_line": 62,
        "end_line": 83,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_aux._TIFFMultiply32#36",
        "src_path": "libtiff/tif_aux.c",
        "class_name": "libtiff.tif_aux",
        "signature": "libtiff.tif_aux._TIFFMultiply32(TIFF* tif, uint32 first, uint32 second, const char* where)",
        "snippet": "uint32\n_TIFFMultiply32(TIFF* tif, uint32 first, uint32 second, const char* where)\n{\n\tuint32 bytes = first * second;\n\n\tif (second && bytes / second != first) {\n\t\tTIFFErrorExt(tif->tif_clientdata, where, \"Integer overflow in %s\", where);\n\t\tbytes = 0;\n\t}\n\n\treturn bytes;\n}",
        "begin_line": 36,
        "end_line": 47,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_aux._TIFFMultiply64#49",
        "src_path": "libtiff/tif_aux.c",
        "class_name": "libtiff.tif_aux",
        "signature": "libtiff.tif_aux._TIFFMultiply64(TIFF* tif, uint64 first, uint64 second, const char* where)",
        "snippet": "uint64\n_TIFFMultiply64(TIFF* tif, uint64 first, uint64 second, const char* where)\n{\n\tuint64 bytes = first * second;\n\n\tif (second && bytes / second != first) {\n\t\tTIFFErrorExt(tif->tif_clientdata, where, \"Integer overflow in %s\", where);\n\t\tbytes = 0;\n\t}\n\n\treturn bytes;\n}",
        "begin_line": 49,
        "end_line": 60,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_codec.TIFFIsCODECConfigured#142",
        "src_path": "libtiff/tif_codec.c",
        "class_name": "libtiff.tif_codec",
        "signature": "libtiff.tif_codec.TIFFIsCODECConfigured(uint16 scheme)",
        "snippet": "int\nTIFFIsCODECConfigured(uint16 scheme)\n{\n\tconst TIFFCodec* codec = TIFFFindCODEC(scheme);\n\n\tif(codec == NULL) {\n\t\treturn 0;\n\t}\n\tif(codec->init == NULL) {\n\t\treturn 0;\n\t}\n\tif(codec->init != NotConfigured){\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "begin_line": 142,
        "end_line": 157,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_compress.TIFFFindCODEC#186",
        "src_path": "libtiff/tif_compress.c",
        "class_name": "libtiff.tif_compress",
        "signature": "libtiff.tif_compress.TIFFFindCODEC(uint16 scheme)",
        "snippet": "const TIFFCodec*\nTIFFFindCODEC(uint16 scheme)\n{\n\tconst TIFFCodec* c;\n\tcodec_t* cd;\n\n\tfor (cd = registeredCODECS; cd; cd = cd->next)\n\t\tif (cd->info->scheme == scheme)\n\t\t\treturn ((const TIFFCodec*) cd->info);\n\tfor (c = _TIFFBuiltinCODECS; c->name; c++)\n\t\tif (c->scheme == scheme)\n\t\t\treturn (c);\n\treturn ((const TIFFCodec*) 0);\n}",
        "begin_line": 186,
        "end_line": 199,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_compress.TIFFSetCompressionScheme#160",
        "src_path": "libtiff/tif_compress.c",
        "class_name": "libtiff.tif_compress",
        "signature": "libtiff.tif_compress.TIFFSetCompressionScheme(TIFF* tif, int scheme)",
        "snippet": "int\nTIFFSetCompressionScheme(TIFF* tif, int scheme)\n{\n\tconst TIFFCodec *c = TIFFFindCODEC((uint16) scheme);\n\n\t_TIFFSetDefaultCompressionState(tif);\n\t/*\n\t * Don't treat an unknown compression scheme as an error.\n\t * This permits applications to open files with data that\n\t * the library does not have builtin support for, but which\n\t * may still be meaningful.\n\t */\n\treturn (c ? (*c->init)(tif, scheme) : 1);\n}",
        "begin_line": 160,
        "end_line": 173,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_compress._TIFFSetDefaultCompressionState#135",
        "src_path": "libtiff/tif_compress.c",
        "class_name": "libtiff.tif_compress",
        "signature": "libtiff.tif_compress._TIFFSetDefaultCompressionState(TIFF* tif)",
        "snippet": "void\n_TIFFSetDefaultCompressionState(TIFF* tif)\n{\n\ttif->tif_fixuptags = _TIFFNoFixupTags; \n\ttif->tif_decodestatus = TRUE;\n\ttif->tif_setupdecode = _TIFFtrue;\n\ttif->tif_predecode = _TIFFNoPreCode;\n\ttif->tif_decoderow = _TIFFNoRowDecode;  \n\ttif->tif_decodestrip = _TIFFNoStripDecode;\n\ttif->tif_decodetile = _TIFFNoTileDecode;  \n\ttif->tif_encodestatus = TRUE;\n\ttif->tif_setupencode = _TIFFtrue;\n\ttif->tif_preencode = _TIFFNoPreCode;\n\ttif->tif_postencode = _TIFFtrue;\n\ttif->tif_encoderow = _TIFFNoRowEncode;\n\ttif->tif_encodestrip = _TIFFNoStripEncode;  \n\ttif->tif_encodetile = _TIFFNoTileEncode;  \n\ttif->tif_close = _TIFFvoid;\n\ttif->tif_seek = _TIFFNoSeek;\n\ttif->tif_cleanup = _TIFFvoid;\n\ttif->tif_defstripsize = _TIFFDefaultStripSize;\n\ttif->tif_deftilesize = _TIFFDefaultTileSize;\n\ttif->tif_flags &= ~(TIFF_NOBITREV|TIFF_NOREADRAW);\n}",
        "begin_line": 135,
        "end_line": 158,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_compress._TIFFvoid#133",
        "src_path": "libtiff/tif_compress.c",
        "class_name": "libtiff.tif_compress",
        "signature": "libtiff.tif_compress._TIFFvoid(TIFF* tif)",
        "snippet": "static void _TIFFvoid(TIFF* tif) { (void) tif; }",
        "begin_line": 133,
        "end_line": 133,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.OkToChangeTag#749",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.OkToChangeTag(TIFF* tif, uint32 tag)",
        "snippet": "static int\nOkToChangeTag(TIFF* tif, uint32 tag)\n{\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\tif (!fip) {\t\t\t/* unknown tag */\n\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFSetField\", \"%s: Unknown %stag %u\",\n\t\t    tif->tif_name, isPseudoTag(tag) ? \"pseudo-\" : \"\", tag);\n\t\treturn (0);\n\t}\n\tif (tag != TIFFTAG_IMAGELENGTH && (tif->tif_flags & TIFF_BEENWRITING) &&\n\t    !fip->field_oktochange) {\n\t\t/*\n\t\t * Consult info table to see if tag can be changed\n\t\t * after we've started writing.  We only allow changes\n\t\t * to those tags that don't/shouldn't affect the\n\t\t * compression and/or format of the data.\n\t\t */\n\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFSetField\",\n\t\t    \"%s: Cannot modify tag \\\"%s\\\" while writing\",\n\t\t    tif->tif_name, fip->field_name);\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
        "begin_line": 749,
        "end_line": 772,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFAdvanceDirectory#1412",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFAdvanceDirectory(TIFF* tif, uint64* nextdir, uint64* off)",
        "snippet": "static int\nTIFFAdvanceDirectory(TIFF* tif, uint64* nextdir, uint64* off)\n{\n\tstatic const char module[] = \"TIFFAdvanceDirectory\";\n\tif (isMapped(tif))\n\t{\n\t\tuint64 poff=*nextdir;\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\ttmsize_t poffa,poffb,poffc,poffd;\n\t\t\tuint16 dircount;\n\t\t\tuint32 nextdir32;\n\t\t\tpoffa=(tmsize_t)poff;\n\t\t\tpoffb=poffa+sizeof(uint16);\n\t\t\tif (((uint64)poffa!=poff)||(poffb<poffa)||(poffb<(tmsize_t)sizeof(uint16))||(poffb>tif->tif_size))\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Error fetching directory count\");\n                                  *nextdir=0;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t_TIFFmemcpy(&dircount,tif->tif_base+poffa,sizeof(uint16));\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&dircount);\n\t\t\tpoffc=poffb+dircount*12;\n\t\t\tpoffd=poffc+sizeof(uint32);\n\t\t\tif ((poffc<poffb)||(poffc<dircount*12)||(poffd<poffc)||(poffd<(tmsize_t)sizeof(uint32))||(poffd>tif->tif_size))\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Error fetching directory link\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (off!=NULL)\n\t\t\t\t*off=(uint64)poffc;\n\t\t\t_TIFFmemcpy(&nextdir32,tif->tif_base+poffc,sizeof(uint32));\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&nextdir32);\n\t\t\t*nextdir=nextdir32;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmsize_t poffa,poffb,poffc,poffd;\n\t\t\tuint64 dircount64;\n\t\t\tuint16 dircount16;\n\t\t\tpoffa=(tmsize_t)poff;\n\t\t\tpoffb=poffa+sizeof(uint64);\n\t\t\tif (((uint64)poffa!=poff)||(poffb<poffa)||(poffb<(tmsize_t)sizeof(uint64))||(poffb>tif->tif_size))\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Error fetching directory count\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t_TIFFmemcpy(&dircount64,tif->tif_base+poffa,sizeof(uint64));\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\tif (dircount64>0xFFFF)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Sanity check on directory count failed\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tdircount16=(uint16)dircount64;\n\t\t\tpoffc=poffb+dircount16*20;\n\t\t\tpoffd=poffc+sizeof(uint64);\n\t\t\tif ((poffc<poffb)||(poffc<dircount16*20)||(poffd<poffc)||(poffd<(tmsize_t)sizeof(uint64))||(poffd>tif->tif_size))\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Error fetching directory link\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (off!=NULL)\n\t\t\t\t*off=(uint64)poffc;\n\t\t\t_TIFFmemcpy(nextdir,tif->tif_base+poffc,sizeof(uint64));\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(nextdir);\n\t\t}\n\t\treturn(1);\n\t}\n\telse\n\t{\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tuint16 dircount;\n\t\t\tuint32 nextdir32;\n\t\t\tif (!SeekOK(tif, *nextdir) ||\n\t\t\t    !ReadOK(tif, &dircount, sizeof (uint16))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s: Error fetching directory count\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&dircount);\n\t\t\tif (off != NULL)\n\t\t\t\t*off = TIFFSeekFile(tif,\n\t\t\t\t    dircount*12, SEEK_CUR);\n\t\t\telse\n\t\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t\t    dircount*12, SEEK_CUR);\n\t\t\tif (!ReadOK(tif, &nextdir32, sizeof (uint32))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s: Error fetching directory link\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&nextdir32);\n\t\t\t*nextdir=nextdir32;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint64 dircount64;\n\t\t\tuint16 dircount16;\n\t\t\tif (!SeekOK(tif, *nextdir) ||\n\t\t\t    !ReadOK(tif, &dircount64, sizeof (uint64))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s: Error fetching directory count\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\tif (dircount64>0xFFFF)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Error fetching directory count\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tdircount16 = (uint16)dircount64;\n\t\t\tif (off != NULL)\n\t\t\t\t*off = TIFFSeekFile(tif,\n\t\t\t\t    dircount16*20, SEEK_CUR);\n\t\t\telse\n\t\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t\t    dircount16*20, SEEK_CUR);\n\t\t\tif (!ReadOK(tif, nextdir, sizeof (uint64))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n                                             \"%s: Error fetching directory link\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(nextdir);\n\t\t}\n\t\treturn (1);\n\t}\n}",
        "begin_line": 1412,
        "end_line": 1549,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFDefaultDirectory#1342",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFDefaultDirectory(TIFF* tif)",
        "snippet": "int\nTIFFDefaultDirectory(TIFF* tif)\n{\n\tregister TIFFDirectory* td = &tif->tif_dir;\n\tconst TIFFFieldArray* tiffFieldArray;\n\n\ttiffFieldArray = _TIFFGetFields();\n\t_TIFFSetupFields(tif, tiffFieldArray);   \n\n\t_TIFFmemset(td, 0, sizeof (*td));\n\ttd->td_fillorder = FILLORDER_MSB2LSB;\n\ttd->td_bitspersample = 1;\n\ttd->td_threshholding = THRESHHOLD_BILEVEL;\n\ttd->td_orientation = ORIENTATION_TOPLEFT;\n\ttd->td_samplesperpixel = 1;\n\ttd->td_rowsperstrip = (uint32) -1;\n\ttd->td_tilewidth = 0;\n\ttd->td_tilelength = 0;\n\ttd->td_tiledepth = 1;\n\ttd->td_stripbytecountsorted = 1; /* Our own arrays always sorted. */  \n\ttd->td_resolutionunit = RESUNIT_INCH;\n\ttd->td_sampleformat = SAMPLEFORMAT_UINT;\n\ttd->td_imagedepth = 1;\n\ttd->td_ycbcrsubsampling[0] = 2;\n\ttd->td_ycbcrsubsampling[1] = 2;\n\ttd->td_ycbcrpositioning = YCBCRPOSITION_CENTERED;\n\ttif->tif_postdecode = _TIFFNoPostDecode;  \n\ttif->tif_foundfield = NULL;\n\ttif->tif_tagmethods.vsetfield = _TIFFVSetField;  \n\ttif->tif_tagmethods.vgetfield = _TIFFVGetField;\n\ttif->tif_tagmethods.printdir = NULL;\n\t/*\n\t *  Give client code a chance to install their own\n\t *  tag extensions & methods, prior to compression overloads,\n\t *  but do some prior cleanup first. (http://trac.osgeo.org/gdal/ticket/5054)\n\t */\n\tif (tif->tif_nfieldscompat > 0) {\n\t\tuint32 i;\n\n\t\tfor (i = 0; i < tif->tif_nfieldscompat; i++) {\n\t\t\t\tif (tif->tif_fieldscompat[i].allocated_size)\n\t\t\t\t\t\t_TIFFfree(tif->tif_fieldscompat[i].fields);\n\t\t}\n\t\t_TIFFfree(tif->tif_fieldscompat);\n\t\ttif->tif_nfieldscompat = 0;\n\t\ttif->tif_fieldscompat = NULL;\n\t}\n\tif (_TIFFextender)\n\t\t(*_TIFFextender)(tif);\n\t(void) TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t/*\n\t * NB: The directory is marked dirty as a result of setting\n\t * up the default compression scheme.  However, this really\n\t * isn't correct -- we want TIFF_DIRTYDIRECT to be set only\n\t * if the user does something.  We could just do the setup\n\t * by hand, but it seems better to use the normal mechanism\n\t * (i.e. TIFFSetField).\n\t */\n\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\n\n\t/*\n\t * As per http://bugzilla.remotesensing.org/show_bug.cgi?id=19\n\t * we clear the ISTILED flag when setting up a new directory.\n\t * Should we also be clearing stuff like INSUBIFD?\n\t */\n\ttif->tif_flags &= ~TIFF_ISTILED;\n\n\treturn (1);\n}",
        "begin_line": 1342,
        "end_line": 1410,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFFreeDirectory#1237",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFFreeDirectory(TIFF* tif)",
        "snippet": "void\nTIFFFreeDirectory(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tint            i;\n\n\t_TIFFmemset(td->td_fieldsset, 0, FIELD_SETLONGS);\n\tCleanupField(td_sminsamplevalue);\n\tCleanupField(td_smaxsamplevalue);\n\tCleanupField(td_colormap[0]);\n\tCleanupField(td_colormap[1]);\n\tCleanupField(td_colormap[2]);\n\tCleanupField(td_sampleinfo);\n\tCleanupField(td_subifd);\n\tCleanupField(td_inknames);\n\tCleanupField(td_refblackwhite);\n\tCleanupField(td_transferfunction[0]);\n\tCleanupField(td_transferfunction[1]);\n\tCleanupField(td_transferfunction[2]);\n\tCleanupField(td_stripoffset);\n\tCleanupField(td_stripbytecount);\n\tTIFFClrFieldBit(tif, FIELD_YCBCRSUBSAMPLING);\n\tTIFFClrFieldBit(tif, FIELD_YCBCRPOSITIONING);\n\n\t/* Cleanup custom tag values */\n\tfor( i = 0; i < td->td_customValueCount; i++ ) {\n\t\tif (td->td_customValues[i].value)\n\t\t\t_TIFFfree(td->td_customValues[i].value);\n\t}\n\n\ttd->td_customValueCount = 0;\n\tCleanupField(td_customValues);\n\n#if defined(DEFER_STRILE_LOAD)\n        _TIFFmemset( &(td->td_stripoffset_entry), 0, sizeof(TIFFDirEntry));\n        _TIFFmemset( &(td->td_stripbytecount_entry), 0, sizeof(TIFFDirEntry));\n#endif        \n}",
        "begin_line": 1237,
        "end_line": 1274,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFGetField#1201",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFGetField(TIFF* tif, uint32 tag, ...)",
        "snippet": "int\nTIFFGetField(TIFF* tif, uint32 tag, ...)\n{\n\tint status;\n\tva_list ap;\n\n\tva_start(ap, tag);\n\tstatus = TIFFVGetField(tif, tag, ap);\n\tva_end(ap);\n\treturn (status);\n}",
        "begin_line": 1201,
        "end_line": 1211,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFNumberOfDirectories#1554",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFNumberOfDirectories(TIFF* tif)",
        "snippet": "uint16\nTIFFNumberOfDirectories(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFNumberOfDirectories\";\n\tuint64 nextdir;\n\tuint16 n;\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\tnextdir = tif->tif_header.classic.tiff_diroff;\n\telse\n\t\tnextdir = tif->tif_header.big.tiff_diroff;\n\tn = 0;\n\twhile (nextdir != 0 && TIFFAdvanceDirectory(tif, &nextdir, NULL))\n        {\n                if (n != 65535) {\n                        ++n;\n                }\n\t\telse\n                {\n                        TIFFErrorExt(tif->tif_clientdata, module,\n                                     \"Directory count exceeded 65535 limit,\"\n                                     \" giving up on counting.\");\n                        return (65535);\n                }\n        }\n\treturn (n);\n}",
        "begin_line": 1554,
        "end_line": 1579,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFSetDirectory#1585",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFSetDirectory(TIFF* tif, uint16 dirn)",
        "snippet": "int\nTIFFSetDirectory(TIFF* tif, uint16 dirn)\n{\n\tuint64 nextdir;\n\tuint16 n;\n\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\tnextdir = tif->tif_header.classic.tiff_diroff;\n\telse\n\t\tnextdir = tif->tif_header.big.tiff_diroff;\n\tfor (n = dirn; n > 0 && nextdir != 0; n--)\n\t\tif (!TIFFAdvanceDirectory(tif, &nextdir, NULL))\n\t\t\treturn (0);\n\ttif->tif_nextdiroff = nextdir;\n\t/*\n\t * Set curdir to the actual directory index.  The\n\t * -1 is because TIFFReadDirectory will increment\n\t * tif_curdir after successfully reading the directory.\n\t */\n\ttif->tif_curdir = (dirn - n) - 1;\n\t/*\n\t * Reset tif_dirnumber counter and start new list of seen directories.\n\t * We need this to prevent IFD loops.\n\t */\n\ttif->tif_dirnumber = 0;\n\treturn (TIFFReadDirectory(tif));\n}",
        "begin_line": 1585,
        "end_line": 1611,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFSetField#781",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFSetField(TIFF* tif, uint32 tag, ...)",
        "snippet": "int\nTIFFSetField(TIFF* tif, uint32 tag, ...)\n{\n\tva_list ap;\n\tint status;\n\n\tva_start(ap, tag);\n\tstatus = TIFFVSetField(tif, tag, ap);\n\tva_end(ap);\n\treturn (status);\n}",
        "begin_line": 781,
        "end_line": 791,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFVGetField#1219",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "int\nTIFFVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\treturn (fip && (isPseudoTag(tag) || TIFFFieldSet(tif, fip->field_bit)) ?\n\t    (*tif->tif_tagmethods.vgetfield)(tif, tag, ap) : 0);\n}",
        "begin_line": 1219,
        "end_line": 1225,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFVSetField#840",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "int\nTIFFVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\treturn OkToChangeTag(tif, tag) ?\n\t    (*tif->tif_tagmethods.vsetfield)(tif, tag, ap) : 0;\n}",
        "begin_line": 840,
        "end_line": 845,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir._TIFFVGetField#847",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir._TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "static int\n_TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tTIFFDirectory* td = &tif->tif_dir;\n\tint ret_val = 1;\n\tuint32 standard_tag = tag;\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\tif( fip == NULL ) /* cannot happen since TIFFGetField() already checks it */\n\t    return 0;\n\t\n        if( tag == TIFFTAG_NUMBEROFINKS )\n        {\n            int i;\n            for (i = 0; i < td->td_customValueCount; i++) {\n                uint16 val;\n                TIFFTagValue *tv = td->td_customValues + i;\n                if (tv->info->field_tag != tag)\n                    continue;\n                val = *(uint16 *)tv->value;\n                /* Truncate to SamplesPerPixel, since the */\n                /* setting code for INKNAMES assume that there are SamplesPerPixel */\n                /* inknames. */\n                /* Fixes http://bugzilla.maptools.org/show_bug.cgi?id=2599 */\n                if( val > td->td_samplesperpixel )\n                {\n                    TIFFWarningExt(tif->tif_clientdata,\"_TIFFVGetField\",\n                                   \"Truncating NumberOfInks from %u to %u\",\n                                   val, td->td_samplesperpixel);\n                    val = td->td_samplesperpixel;\n                }\n                *va_arg(ap, uint16*) = val;\n                return 1;\n            }\n            return 0;\n        }\n\n\t/*\n\t * We want to force the custom code to be used for custom\n\t * fields even if the tag happens to match a well known \n\t * one - important for reinterpreted handling of standard\n\t * tag values in custom directories (i.e. EXIF) \n\t */\n\tif (fip->field_bit == FIELD_CUSTOM) {\n\t\tstandard_tag = 0;\n\t}\n\n\tswitch (standard_tag) {\n\t\tcase TIFFTAG_SUBFILETYPE:\n\t\t\t*va_arg(ap, uint32*) = td->td_subfiletype;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGEWIDTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagewidth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGELENGTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagelength;\n\t\t\tbreak;\n\t\tcase TIFFTAG_BITSPERSAMPLE:\n\t\t\t*va_arg(ap, uint16*) = td->td_bitspersample;\n\t\t\tbreak;\n\t\tcase TIFFTAG_COMPRESSION:\n\t\t\t*va_arg(ap, uint16*) = td->td_compression;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PHOTOMETRIC:\n\t\t\t*va_arg(ap, uint16*) = td->td_photometric;\n\t\t\tbreak;\n\t\tcase TIFFTAG_THRESHHOLDING:\n\t\t\t*va_arg(ap, uint16*) = td->td_threshholding;\n\t\t\tbreak;\n\t\tcase TIFFTAG_FILLORDER:\n\t\t\t*va_arg(ap, uint16*) = td->td_fillorder;\n\t\t\tbreak;\n\t\tcase TIFFTAG_ORIENTATION:\n\t\t\t*va_arg(ap, uint16*) = td->td_orientation;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SAMPLESPERPIXEL:\n\t\t\t*va_arg(ap, uint16*) = td->td_samplesperpixel;\n\t\t\tbreak;\n\t\tcase TIFFTAG_ROWSPERSTRIP:\n\t\t\t*va_arg(ap, uint32*) = td->td_rowsperstrip;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\t\t*va_arg(ap, uint16*) = td->td_minsamplevalue;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\t\t*va_arg(ap, uint16*) = td->td_maxsamplevalue;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t\t*va_arg(ap, double**) = td->td_sminsamplevalue;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* libtiff historically treats this as a single value. */\n\t\t\t\tuint16 i;\n\t\t\t\tdouble v = td->td_sminsamplevalue[0];\n\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\n\t\t\t\t\tif( td->td_sminsamplevalue[i] < v )\n\t\t\t\t\t\tv = td->td_sminsamplevalue[i];\n\t\t\t\t*va_arg(ap, double*) = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t\t*va_arg(ap, double**) = td->td_smaxsamplevalue;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* libtiff historically treats this as a single value. */\n\t\t\t\tuint16 i;\n\t\t\t\tdouble v = td->td_smaxsamplevalue[0];\n\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\n\t\t\t\t\tif( td->td_smaxsamplevalue[i] > v )\n\t\t\t\t\t\tv = td->td_smaxsamplevalue[i];\n\t\t\t\t*va_arg(ap, double*) = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_XRESOLUTION:\n\t\t\t*va_arg(ap, float*) = td->td_xresolution;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YRESOLUTION:\n\t\t\t*va_arg(ap, float*) = td->td_yresolution;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PLANARCONFIG:\n\t\t\t*va_arg(ap, uint16*) = td->td_planarconfig;\n\t\t\tbreak;\n\t\tcase TIFFTAG_XPOSITION:\n\t\t\t*va_arg(ap, float*) = td->td_xposition;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YPOSITION:\n\t\t\t*va_arg(ap, float*) = td->td_yposition;\n\t\t\tbreak;\n\t\tcase TIFFTAG_RESOLUTIONUNIT:\n\t\t\t*va_arg(ap, uint16*) = td->td_resolutionunit;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PAGENUMBER:\n\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_HALFTONEHINTS:\n\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_COLORMAP:\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[0];\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[1];\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[2];\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\tcase TIFFTAG_TILEOFFSETS:\n\t\t\t_TIFFFillStriles( tif );\n\t\t\t*va_arg(ap, uint64**) = td->td_stripoffset;\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\t\t_TIFFFillStriles( tif );\n\t\t\t*va_arg(ap, uint64**) = td->td_stripbytecount;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MATTEING:\n\t\t\t*va_arg(ap, uint16*) =\n\t\t\t    (td->td_extrasamples == 1 &&\n\t\t\t    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);\n\t\t\tbreak;\n\t\tcase TIFFTAG_EXTRASAMPLES:\n\t\t\t*va_arg(ap, uint16*) = td->td_extrasamples;\n\t\t\t*va_arg(ap, uint16**) = td->td_sampleinfo;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILEWIDTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tilewidth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILELENGTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tilelength;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILEDEPTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tiledepth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_DATATYPE:\n\t\t\tswitch (td->td_sampleformat) {\n\t\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_UINT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_INT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_IEEEFP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_VOID:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_VOID;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_SAMPLEFORMAT:\n\t\t\t*va_arg(ap, uint16*) = td->td_sampleformat;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGEDEPTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagedepth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SUBIFD:\n\t\t\t*va_arg(ap, uint16*) = td->td_nsubifd;\n\t\t\t*va_arg(ap, uint64**) = td->td_subifd;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRPOSITIONING:\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrpositioning;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[0];\n\t\t\tif (td->td_samplesperpixel - td->td_extrasamples > 1) {\n\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[1];\n\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[2];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_REFERENCEBLACKWHITE:\n\t\t\t*va_arg(ap, float**) = td->td_refblackwhite;\n\t\t\tbreak;\n\t\tcase TIFFTAG_INKNAMES:\n\t\t\t*va_arg(ap, char**) = td->td_inknames;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\t/*\n\t\t\t\t * This can happen if multiple images are open\n\t\t\t\t * with different codecs which have private\n\t\t\t\t * tags.  The global tag information table may\n\t\t\t\t * then have tags that are valid for one file\n\t\t\t\t * but not the other. If the client tries to\n\t\t\t\t * get a tag that is not valid for the image's\n\t\t\t\t * codec then we'll arrive here.\n\t\t\t\t */\n\t\t\t\tif( fip->field_bit != FIELD_CUSTOM )\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, \"_TIFFVGetField\",\n\t\t\t\t\t    \"%s: Invalid %stag \\\"%s\\\" \"\n\t\t\t\t\t    \"(not supported by codec)\",\n\t\t\t\t\t    tif->tif_name,\n\t\t\t\t\t    isPseudoTag(tag) ? \"pseudo-\" : \"\",\n\t\t\t\t\t    fip->field_name);\n\t\t\t\t\tret_val = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Do we have a custom value?\n\t\t\t\t */\n\t\t\t\tret_val = 0;\n\t\t\t\tfor (i = 0; i < td->td_customValueCount; i++) {\n\t\t\t\t\tTIFFTagValue *tv = td->td_customValues + i;\n\n\t\t\t\t\tif (tv->info->field_tag != tag)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (fip->field_passcount) {\n\t\t\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE2)\n\t\t\t\t\t\t\t*va_arg(ap, uint32*) = (uint32)tv->count;\n\t\t\t\t\t\telse  /* Assume TIFF_VARIABLE */\n\t\t\t\t\t\t\t*va_arg(ap, uint16*) = (uint16)tv->count;\n\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\n\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t} else if (fip->field_tag == TIFFTAG_DOTRANGE\n\t\t\t\t\t\t   && strcmp(fip->field_name,\"DotRange\") == 0) {\n\t\t\t\t\t\t/* TODO: This is an evil exception and should not have been\n\t\t\t\t\t\t   handled this way ... likely best if we move it into\n\t\t\t\t\t\t   the directory structure with an explicit field in \n\t\t\t\t\t\t   libtiff 4.1 and assign it a FIELD_ value */\n\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];\n\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];\n\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (fip->field_type == TIFF_ASCII\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE2\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_SPP\n\t\t\t\t\t\t    || tv->count > 1) {\n\t\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\n\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchar *val = (char *)tv->value;\n\t\t\t\t\t\t\tassert( tv->count == 1 );\n\t\t\t\t\t\t\tswitch (fip->field_type) {\n\t\t\t\t\t\t\tcase TIFF_BYTE:\n\t\t\t\t\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint8*) =\n\t\t\t\t\t\t\t\t\t*(uint8 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SBYTE:\n\t\t\t\t\t\t\t\t*va_arg(ap, int8*) =\n\t\t\t\t\t\t\t\t\t*(int8 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SHORT:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint16*) =\n\t\t\t\t\t\t\t\t\t*(uint16 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SSHORT:\n\t\t\t\t\t\t\t\t*va_arg(ap, int16*) =\n\t\t\t\t\t\t\t\t\t*(int16 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_LONG:\n\t\t\t\t\t\t\tcase TIFF_IFD:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint32*) =\n\t\t\t\t\t\t\t\t\t*(uint32 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SLONG:\n\t\t\t\t\t\t\t\t*va_arg(ap, int32*) =\n\t\t\t\t\t\t\t\t\t*(int32 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_LONG8:\n\t\t\t\t\t\t\tcase TIFF_IFD8:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint64*) =\n\t\t\t\t\t\t\t\t\t*(uint64 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SLONG8:\n\t\t\t\t\t\t\t\t*va_arg(ap, int64*) =\n\t\t\t\t\t\t\t\t\t*(int64 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_RATIONAL:\n\t\t\t\t\t\t\tcase TIFF_SRATIONAL:\n\t\t\t\t\t\t\tcase TIFF_FLOAT:\n\t\t\t\t\t\t\t\t*va_arg(ap, float*) =\n\t\t\t\t\t\t\t\t\t*(float *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_DOUBLE:\n\t\t\t\t\t\t\t\t*va_arg(ap, double*) =\n\t\t\t\t\t\t\t\t\t*(double *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tret_val = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn(ret_val);\n}",
        "begin_line": 847,
        "end_line": 1195,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir._TIFFVSetField#157",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir._TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "static int\n_TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tstatic const char module[] = \"_TIFFVSetField\";\n\n\tTIFFDirectory* td = &tif->tif_dir;\n\tint status = 1;\n\tuint32 v32, i, v;\n    double dblval;\n\tchar* s;\n\tconst TIFFField *fip = TIFFFindField(tif, tag, TIFF_ANY);\n\tuint32 standard_tag = tag;\n\tif( fip == NULL ) /* cannot happen since OkToChangeTag() already checks it */\n\t    return 0;\n\t/*\n\t * We want to force the custom code to be used for custom\n\t * fields even if the tag happens to match a well known \n\t * one - important for reinterpreted handling of standard\n\t * tag values in custom directories (i.e. EXIF) \n\t */\n\tif (fip->field_bit == FIELD_CUSTOM) {\n\t\tstandard_tag = 0;\n\t}\n\n\tswitch (standard_tag) {\n\tcase TIFFTAG_SUBFILETYPE:\n\t\ttd->td_subfiletype = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_IMAGEWIDTH:\n\t\ttd->td_imagewidth = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_IMAGELENGTH:\n\t\ttd->td_imagelength = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_BITSPERSAMPLE:\n\t\ttd->td_bitspersample = (uint16) va_arg(ap, uint16_vap);\n\t\t/*\n\t\t * If the data require post-decoding processing to byte-swap\n\t\t * samples, set it up here.  Note that since tags are required\n\t\t * to be ordered, compression code can override this behaviour\n\t\t * in the setup method if it wants to roll the post decoding\n\t\t * work in with its normal work.\n\t\t */\n\t\tif (tif->tif_flags & TIFF_SWAB) {\n\t\t\tif (td->td_bitspersample == 8)\n\t\t\t\ttif->tif_postdecode = _TIFFNoPostDecode;\n\t\t\telse if (td->td_bitspersample == 16)\n\t\t\t\ttif->tif_postdecode = _TIFFSwab16BitData;\n\t\t\telse if (td->td_bitspersample == 24)\n\t\t\t\ttif->tif_postdecode = _TIFFSwab24BitData;\n\t\t\telse if (td->td_bitspersample == 32)\n\t\t\t\ttif->tif_postdecode = _TIFFSwab32BitData;\n\t\t\telse if (td->td_bitspersample == 64)\n\t\t\t\ttif->tif_postdecode = _TIFFSwab64BitData;\n\t\t\telse if (td->td_bitspersample == 128) /* two 64's */\n\t\t\t\ttif->tif_postdecode = _TIFFSwab64BitData;\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_COMPRESSION:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\t/*\n\t\t * If we're changing the compression scheme, the notify the\n\t\t * previous module so that it can cleanup any state it's\n\t\t * setup.\n\t\t */\n\t\tif (TIFFFieldSet(tif, FIELD_COMPRESSION)) {\n\t\t\tif ((uint32)td->td_compression == v)\n\t\t\t\tbreak;\n\t\t\t(*tif->tif_cleanup)(tif);\n\t\t\ttif->tif_flags &= ~TIFF_CODERSETUP;\n\t\t}\n\t\t/*\n\t\t * Setup new compression routine state.\n\t\t */\n\t\tif( (status = TIFFSetCompressionScheme(tif, v)) != 0 )\n\t\t    td->td_compression = (uint16) v;\n\t\telse\n\t\t    status = 0;\n\t\tbreak;\n\tcase TIFFTAG_PHOTOMETRIC:\n\t\ttd->td_photometric = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_THRESHHOLDING:\n\t\ttd->td_threshholding = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_FILLORDER:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v != FILLORDER_LSB2MSB && v != FILLORDER_MSB2LSB)\n\t\t\tgoto badvalue;\n\t\ttd->td_fillorder = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_ORIENTATION:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v < ORIENTATION_TOPLEFT || ORIENTATION_LEFTBOT < v)\n\t\t\tgoto badvalue;\n\t\telse\n\t\t\ttd->td_orientation = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_SAMPLESPERPIXEL:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v == 0)\n\t\t\tgoto badvalue;\n        if( v != td->td_samplesperpixel )\n        {\n            /* See http://bugzilla.maptools.org/show_bug.cgi?id=2500 */\n            if( td->td_sminsamplevalue != NULL )\n            {\n                TIFFWarningExt(tif->tif_clientdata,module,\n                    \"SamplesPerPixel tag value is changing, \"\n                    \"but SMinSampleValue tag was read with a different value. Cancelling it\");\n                TIFFClrFieldBit(tif,FIELD_SMINSAMPLEVALUE);\n                _TIFFfree(td->td_sminsamplevalue);\n                td->td_sminsamplevalue = NULL;\n            }\n            if( td->td_smaxsamplevalue != NULL )\n            {\n                TIFFWarningExt(tif->tif_clientdata,module,\n                    \"SamplesPerPixel tag value is changing, \"\n                    \"but SMaxSampleValue tag was read with a different value. Cancelling it\");\n                TIFFClrFieldBit(tif,FIELD_SMAXSAMPLEVALUE);\n                _TIFFfree(td->td_smaxsamplevalue);\n                td->td_smaxsamplevalue = NULL;\n            }\n        }\n\t\ttd->td_samplesperpixel = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_ROWSPERSTRIP:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 == 0)\n\t\t\tgoto badvalue32;\n\t\ttd->td_rowsperstrip = v32;\n\t\tif (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {\n\t\t\ttd->td_tilelength = v32;\n\t\t\ttd->td_tilewidth = td->td_imagewidth;\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\ttd->td_minsamplevalue = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\ttd->td_maxsamplevalue = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t_TIFFsetDoubleArray(&td->td_sminsamplevalue, va_arg(ap, double*), td->td_samplesperpixel);\n\t\telse\n\t\t\tsetDoubleArrayOneValue(&td->td_sminsamplevalue, va_arg(ap, double), td->td_samplesperpixel);\n\t\tbreak;\n\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t_TIFFsetDoubleArray(&td->td_smaxsamplevalue, va_arg(ap, double*), td->td_samplesperpixel);\n\t\telse\n\t\t\tsetDoubleArrayOneValue(&td->td_smaxsamplevalue, va_arg(ap, double), td->td_samplesperpixel);\n\t\tbreak;\n\tcase TIFFTAG_XRESOLUTION:\n        dblval = va_arg(ap, double);\n        if( dblval < 0 )\n            goto badvaluedouble;\n\t\ttd->td_xresolution = (float) dblval;\n\t\tbreak;\n\tcase TIFFTAG_YRESOLUTION:\n        dblval = va_arg(ap, double);\n        if( dblval < 0 )\n            goto badvaluedouble;\n\t\ttd->td_yresolution = (float) dblval;\n\t\tbreak;\n\tcase TIFFTAG_PLANARCONFIG:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v != PLANARCONFIG_CONTIG && v != PLANARCONFIG_SEPARATE)\n\t\t\tgoto badvalue;\n\t\ttd->td_planarconfig = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_XPOSITION:\n\t\ttd->td_xposition = (float) va_arg(ap, double);\n\t\tbreak;\n\tcase TIFFTAG_YPOSITION:\n\t\ttd->td_yposition = (float) va_arg(ap, double);\n\t\tbreak;\n\tcase TIFFTAG_RESOLUTIONUNIT:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v < RESUNIT_NONE || RESUNIT_CENTIMETER < v)\n\t\t\tgoto badvalue;\n\t\ttd->td_resolutionunit = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_PAGENUMBER:\n\t\ttd->td_pagenumber[0] = (uint16) va_arg(ap, uint16_vap);\n\t\ttd->td_pagenumber[1] = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_HALFTONEHINTS:\n\t\ttd->td_halftonehints[0] = (uint16) va_arg(ap, uint16_vap);\n\t\ttd->td_halftonehints[1] = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_COLORMAP:\n\t\tv32 = (uint32)(1L<<td->td_bitspersample);\n\t\t_TIFFsetShortArray(&td->td_colormap[0], va_arg(ap, uint16*), v32);\n\t\t_TIFFsetShortArray(&td->td_colormap[1], va_arg(ap, uint16*), v32);\n\t\t_TIFFsetShortArray(&td->td_colormap[2], va_arg(ap, uint16*), v32);\n\t\tbreak;\n\tcase TIFFTAG_EXTRASAMPLES:\n\t\tif (!setExtraSamples(td, ap, &v))\n\t\t\tgoto badvalue;\n\t\tbreak;\n\tcase TIFFTAG_MATTEING:\n\t\ttd->td_extrasamples =  (((uint16) va_arg(ap, uint16_vap)) != 0);\n\t\tif (td->td_extrasamples) {\n\t\t\tuint16 sv = EXTRASAMPLE_ASSOCALPHA;\n\t\t\t_TIFFsetShortArray(&td->td_sampleinfo, &sv, 1);\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_TILEWIDTH:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 % 16) {\n\t\t\tif (tif->tif_mode != O_RDONLY)\n\t\t\t\tgoto badvalue32;\n\t\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t\t\"Nonstandard tile width %d, convert file\", v32);\n\t\t}\n\t\ttd->td_tilewidth = v32;\n\t\ttif->tif_flags |= TIFF_ISTILED;\n\t\tbreak;\n\tcase TIFFTAG_TILELENGTH:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 % 16) {\n\t\t\tif (tif->tif_mode != O_RDONLY)\n\t\t\t\tgoto badvalue32;\n\t\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t    \"Nonstandard tile length %d, convert file\", v32);\n\t\t}\n\t\ttd->td_tilelength = v32;\n\t\ttif->tif_flags |= TIFF_ISTILED;\n\t\tbreak;\n\tcase TIFFTAG_TILEDEPTH:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 == 0)\n\t\t\tgoto badvalue32;\n\t\ttd->td_tiledepth = v32;\n\t\tbreak;\n\tcase TIFFTAG_DATATYPE:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tswitch (v) {\n\t\tcase DATATYPE_VOID:\tv = SAMPLEFORMAT_VOID;\tbreak;\n\t\tcase DATATYPE_INT:\tv = SAMPLEFORMAT_INT;\tbreak;\n\t\tcase DATATYPE_UINT:\tv = SAMPLEFORMAT_UINT;\tbreak;\n\t\tcase DATATYPE_IEEEFP:\tv = SAMPLEFORMAT_IEEEFP;break;\n\t\tdefault:\t\tgoto badvalue;\n\t\t}\n\t\ttd->td_sampleformat = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_SAMPLEFORMAT:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v < SAMPLEFORMAT_UINT || SAMPLEFORMAT_COMPLEXIEEEFP < v)\n\t\t\tgoto badvalue;\n\t\ttd->td_sampleformat = (uint16) v;\n\n\t\t/*  Try to fix up the SWAB function for complex data. */\n\t\tif( td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT\n\t\t    && td->td_bitspersample == 32\n\t\t    && tif->tif_postdecode == _TIFFSwab32BitData )\n\t\t    tif->tif_postdecode = _TIFFSwab16BitData;\n\t\telse if( (td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT\n\t\t\t  || td->td_sampleformat == SAMPLEFORMAT_COMPLEXIEEEFP)\n\t\t\t && td->td_bitspersample == 64\n\t\t\t && tif->tif_postdecode == _TIFFSwab64BitData )\n\t\t    tif->tif_postdecode = _TIFFSwab32BitData;\n\t\tbreak;\n\tcase TIFFTAG_IMAGEDEPTH:\n\t\ttd->td_imagedepth = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_SUBIFD:\n\t\tif ((tif->tif_flags & TIFF_INSUBIFD) == 0) {\n\t\t\ttd->td_nsubifd = (uint16) va_arg(ap, uint16_vap);\n\t\t\t_TIFFsetLong8Array(&td->td_subifd, (uint64*) va_arg(ap, uint64*),\n\t\t\t    (uint32) td->td_nsubifd);\n\t\t} else {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"%s: Sorry, cannot nest SubIFDs\",\n\t\t\t\t     tif->tif_name);\n\t\t\tstatus = 0;\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_YCBCRPOSITIONING:\n\t\ttd->td_ycbcrpositioning = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\ttd->td_ycbcrsubsampling[0] = (uint16) va_arg(ap, uint16_vap);\n\t\ttd->td_ycbcrsubsampling[1] = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\tv = (td->td_samplesperpixel - td->td_extrasamples) > 1 ? 3 : 1;\n\t\tfor (i = 0; i < v; i++)\n\t\t\t_TIFFsetShortArray(&td->td_transferfunction[i],\n\t\t\t    va_arg(ap, uint16*), 1U<<td->td_bitspersample);\n\t\tbreak;\n\tcase TIFFTAG_REFERENCEBLACKWHITE:\n\t\t/* XXX should check for null range */\n\t\t_TIFFsetFloatArray(&td->td_refblackwhite, va_arg(ap, float*), 6);\n\t\tbreak;\n\tcase TIFFTAG_INKNAMES:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\ts = va_arg(ap, char*);\n\t\tv = checkInkNamesString(tif, v, s);\n\t\tstatus = v > 0;\n\t\tif( v > 0 ) {\n\t\t\t_TIFFsetNString(&td->td_inknames, s, v);\n\t\t\ttd->td_inknameslen = v;\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_PERSAMPLE:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif( v == PERSAMPLE_MULTI )\n\t\t\ttif->tif_flags |= TIFF_PERSAMPLE;\n\t\telse\n\t\t\ttif->tif_flags &= ~TIFF_PERSAMPLE;\n\t\tbreak;\n\tdefault: {\n\t\tTIFFTagValue *tv;\n\t\tint tv_size, iCustom;\n\n\t\t/*\n\t\t * This can happen if multiple images are open with different\n\t\t * codecs which have private tags.  The global tag information\n\t\t * table may then have tags that are valid for one file but not\n\t\t * the other. If the client tries to set a tag that is not valid\n\t\t * for the image's codec then we'll arrive here.  This\n\t\t * happens, for example, when tiffcp is used to convert between\n\t\t * compression schemes and codec-specific tags are blindly copied.\n\t\t */\n\t\tif(fip->field_bit != FIELD_CUSTOM) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"%s: Invalid %stag \\\"%s\\\" (not supported by codec)\",\n\t\t\t    tif->tif_name, isPseudoTag(tag) ? \"pseudo-\" : \"\",\n\t\t\t    fip->field_name);\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Find the existing entry for this custom value.\n\t\t */\n\t\ttv = NULL;\n\t\tfor (iCustom = 0; iCustom < td->td_customValueCount; iCustom++) {\n\t\t\tif (td->td_customValues[iCustom].info->field_tag == tag) {\n\t\t\t\ttv = td->td_customValues + iCustom;\n\t\t\t\tif (tv->value != NULL) {\n\t\t\t\t\t_TIFFfree(tv->value);\n\t\t\t\t\ttv->value = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Grow the custom list if the entry was not found.\n\t\t */\n\t\tif(tv == NULL) {\n\t\t\tTIFFTagValue *new_customValues;\n\n\t\t\ttd->td_customValueCount++;\n\t\t\tnew_customValues = (TIFFTagValue *)\n\t\t\t    _TIFFrealloc(td->td_customValues,\n\t\t\t    sizeof(TIFFTagValue) * td->td_customValueCount);\n\t\t\tif (!new_customValues) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"%s: Failed to allocate space for list of custom values\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\ttd->td_customValues = new_customValues;\n\n\t\t\ttv = td->td_customValues + (td->td_customValueCount - 1);\n\t\t\ttv->info = fip;\n\t\t\ttv->value = NULL;\n\t\t\ttv->count = 0;\n\t\t}\n\n\t\t/*\n\t\t * Set custom value ... save a copy of the custom tag value.\n\t\t */\n\t\ttv_size = _TIFFDataSize(fip->field_type);\n\t\tif (tv_size == 0) {\n\t\t\tstatus = 0;\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"%s: Bad field type %d for \\\"%s\\\"\",\n\t\t\t    tif->tif_name, fip->field_type,\n\t\t\t    fip->field_name);\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (fip->field_type == TIFF_ASCII)\n\t\t{\n\t\t\tuint32 ma;\n\t\t\tchar* mb;\n\t\t\tif (fip->field_passcount)\n\t\t\t{\n\t\t\t\tassert(fip->field_writecount==TIFF_VARIABLE2);\n\t\t\t\tma=(uint32)va_arg(ap,uint32);\n\t\t\t\tmb=(char*)va_arg(ap,char*);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmb=(char*)va_arg(ap,char*);\n\t\t\t\tma=(uint32)(strlen(mb)+1);\n\t\t\t}\n\t\t\ttv->count=ma;\n\t\t\tsetByteArray(&tv->value,mb,ma,1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (fip->field_passcount) {\n\t\t\t\tif (fip->field_writecount == TIFF_VARIABLE2)\n\t\t\t\t\ttv->count = (uint32) va_arg(ap, uint32);\n\t\t\t\telse\n\t\t\t\t\ttv->count = (int) va_arg(ap, int);\n\t\t\t} else if (fip->field_writecount == TIFF_VARIABLE\n\t\t\t   || fip->field_writecount == TIFF_VARIABLE2)\n\t\t\t\ttv->count = 1;\n\t\t\telse if (fip->field_writecount == TIFF_SPP)\n\t\t\t\ttv->count = td->td_samplesperpixel;\n\t\t\telse\n\t\t\t\ttv->count = fip->field_writecount;\n\n\t\t\tif (tv->count == 0) {\n\t\t\t\tstatus = 0;\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"%s: Null count for \\\"%s\\\" (type \"\n\t\t\t\t\t     \"%d, writecount %d, passcount %d)\",\n\t\t\t\t\t     tif->tif_name,\n\t\t\t\t\t     fip->field_name,\n\t\t\t\t\t     fip->field_type,\n\t\t\t\t\t     fip->field_writecount,\n\t\t\t\t\t     fip->field_passcount);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\ttv->value = _TIFFCheckMalloc(tif, tv->count, tv_size,\n\t\t\t    \"custom tag binary object\");\n\t\t\tif (!tv->value) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tif (fip->field_tag == TIFFTAG_DOTRANGE \n\t\t\t    && strcmp(fip->field_name,\"DotRange\") == 0) {\n\t\t\t\t/* TODO: This is an evil exception and should not have been\n\t\t\t\t   handled this way ... likely best if we move it into\n\t\t\t\t   the directory structure with an explicit field in \n\t\t\t\t   libtiff 4.1 and assign it a FIELD_ value */\n\t\t\t\tuint16 v2[2];\n\t\t\t\tv2[0] = (uint16)va_arg(ap, int);\n\t\t\t\tv2[1] = (uint16)va_arg(ap, int);\n\t\t\t\t_TIFFmemcpy(tv->value, &v2, 4);\n\t\t\t}\n\n\t\t\telse if (fip->field_passcount\n\t\t\t\t  || fip->field_writecount == TIFF_VARIABLE\n\t\t\t\t  || fip->field_writecount == TIFF_VARIABLE2\n\t\t\t\t  || fip->field_writecount == TIFF_SPP\n\t\t\t\t  || tv->count > 1) {\n\t\t\t\t_TIFFmemcpy(tv->value, va_arg(ap, void *),\n\t\t\t\t    tv->count * tv_size);\n\t\t\t} else {\n\t\t\t\tchar *val = (char *)tv->value;\n\t\t\t\tassert( tv->count == 1 );\n\n\t\t\t\tswitch (fip->field_type) {\n\t\t\t\tcase TIFF_BYTE:\n\t\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8 v2 = (uint8)va_arg(ap, int);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SBYTE:\n\t\t\t\t\t{\n\t\t\t\t\t\tint8 v2 = (int8)va_arg(ap, int);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SHORT:\n\t\t\t\t\t{\n\t\t\t\t\t\tuint16 v2 = (uint16)va_arg(ap, int);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SSHORT:\n\t\t\t\t\t{\n\t\t\t\t\t\tint16 v2 = (int16)va_arg(ap, int);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_LONG:\n\t\t\t\tcase TIFF_IFD:\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32 v2 = va_arg(ap, uint32);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SLONG:\n\t\t\t\t\t{\n\t\t\t\t\t\tint32 v2 = va_arg(ap, int32);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_LONG8:\n\t\t\t\tcase TIFF_IFD8:\n\t\t\t\t\t{\n\t\t\t\t\t\tuint64 v2 = va_arg(ap, uint64);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SLONG8:\n\t\t\t\t\t{\n\t\t\t\t\t\tint64 v2 = va_arg(ap, int64);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_RATIONAL:\n\t\t\t\tcase TIFF_SRATIONAL:\n\t\t\t\tcase TIFF_FLOAT:\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat v2 = (float)va_arg(ap, double);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_DOUBLE:\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble v2 = va_arg(ap, double);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t_TIFFmemset(val, 0, tv_size);\n\t\t\t\t\tstatus = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t}\n\tif (status) {\n\t\tconst TIFFField* fip2=TIFFFieldWithTag(tif,tag);\n\t\tif (fip2)                \n\t\t\tTIFFSetFieldBit(tif, fip2->field_bit);\n\t\ttif->tif_flags |= TIFF_DIRTYDIRECT;\n\t}\n\nend:\n\tva_end(ap);\n\treturn (status);\nbadvalue:\n        {\n\t\tconst TIFFField* fip2=TIFFFieldWithTag(tif,tag);\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t     \"%s: Bad value %u for \\\"%s\\\" tag\",\n\t\t     tif->tif_name, v,\n\t\t     fip2 ? fip2->field_name : \"Unknown\");\n\t\tva_end(ap);\n        }\n\treturn (0);\nbadvalue32:\n        {\n\t\tconst TIFFField* fip2=TIFFFieldWithTag(tif,tag);\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t     \"%s: Bad value %u for \\\"%s\\\" tag\",\n\t\t     tif->tif_name, v32,\n\t\t     fip2 ? fip2->field_name : \"Unknown\");\n\t\tva_end(ap);\n        }\n\treturn (0);\nbadvaluedouble:\n        {\n        const TIFFField* fip2=TIFFFieldWithTag(tif,tag);\n        TIFFErrorExt(tif->tif_clientdata, module,\n             \"%s: Bad value %f for \\\"%s\\\" tag\",\n             tif->tif_name, dblval,\n             fip2 ? fip2->field_name : \"Unknown\");\n        va_end(ap);\n        }\n    return (0);\n}",
        "begin_line": 157,
        "end_line": 738,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir._TIFFsetByteArray#58",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir._TIFFsetByteArray(void** vpp, void* vp, uint32 n)",
        "snippet": "void _TIFFsetByteArray(void** vpp, void* vp, uint32 n)\n    { setByteArray(vpp, vp, n, 1); }",
        "begin_line": 58,
        "end_line": 59,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir._TIFFsetShortArray#64",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir._TIFFsetShortArray(uint16** wpp, uint16* wp, uint32 n)",
        "snippet": "void _TIFFsetShortArray(uint16** wpp, uint16* wp, uint32 n)\n    { setByteArray((void**) wpp, (void*) wp, n, sizeof (uint16)); }",
        "begin_line": 64,
        "end_line": 65,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.setByteArray#43",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.setByteArray(void** vpp, void* vp, size_t nmemb, size_t elem_size)",
        "snippet": "static void\nsetByteArray(void** vpp, void* vp, size_t nmemb, size_t elem_size)\n{\n\tif (*vpp) {\n\t\t_TIFFfree(*vpp);\n\t\t*vpp = 0;\n\t}\n\tif (vp) {\n\t\ttmsize_t bytes = (tmsize_t)(nmemb * elem_size);\n\t\tif (elem_size && bytes / elem_size == nmemb)\n\t\t\t*vpp = (void*) _TIFFmalloc(bytes);\n\t\tif (*vpp)\n\t\t\t_TIFFmemcpy(*vpp, vp, bytes);\n\t}\n}",
        "begin_line": 43,
        "end_line": 57,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.setExtraSamples#91",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.setExtraSamples(TIFFDirectory* td, va_list ap, uint32* v)",
        "snippet": "static int\nsetExtraSamples(TIFFDirectory* td, va_list ap, uint32* v)\n{\n/* XXX: Unassociated alpha data == 999 is a known Corel Draw bug, see below */\n#define EXTRASAMPLE_COREL_UNASSALPHA 999 \n\n\tuint16* va;\n\tuint32 i;\n\n\t*v = (uint16) va_arg(ap, uint16_vap);\n\tif ((uint16) *v > td->td_samplesperpixel)\n\t\treturn 0;\n\tva = va_arg(ap, uint16*);\n\tif (*v > 0 && va == NULL)\t\t/* typically missing param */\n\t\treturn 0;\n\tfor (i = 0; i < *v; i++) {\n\t\tif (va[i] > EXTRASAMPLE_UNASSALPHA) {\n\t\t\t/*\n\t\t\t * XXX: Corel Draw is known to produce incorrect\n\t\t\t * ExtraSamples tags which must be patched here if we\n\t\t\t * want to be able to open some of the damaged TIFF\n\t\t\t * files: \n\t\t\t */\n\t\t\tif (va[i] == EXTRASAMPLE_COREL_UNASSALPHA)\n\t\t\t\tva[i] = EXTRASAMPLE_UNASSALPHA;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\ttd->td_extrasamples = (uint16) *v;\n\t_TIFFsetShortArray(&td->td_sampleinfo, va, td->td_extrasamples);\n\treturn 1;\n\n#undef EXTRASAMPLE_COREL_UNASSALPHA\n}",
        "begin_line": 91,
        "end_line": 125,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo.TIFFDataWidth#439",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo.TIFFDataWidth(TIFFDataType type)",
        "snippet": "int\nTIFFDataWidth(TIFFDataType type)\n{\n\tswitch(type)\n\t{\n\t\tcase 0:  /* nothing */\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_UNDEFINED:\n\t\t\treturn 1;\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t\treturn 2;\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_FLOAT:\n\t\tcase TIFF_IFD:\n\t\t\treturn 4;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\tcase TIFF_DOUBLE:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\tcase TIFF_IFD8:\n\t\t\treturn 8;\n\t\tdefault:\n\t\t\treturn 0; /* will return 0 for unknown types */\n\t}\n}",
        "begin_line": 439,
        "end_line": 468,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo.TIFFFieldWithTag#559",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo.TIFFFieldWithTag(TIFF* tif, uint32 tag)",
        "snippet": "const TIFFField*\nTIFFFieldWithTag(TIFF* tif, uint32 tag)\n{\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\tif (!fip) {\n\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFFieldWithTag\",\n\t\t\t     \"Internal error, unknown tag 0x%x\",\n\t\t\t     (unsigned int) tag);\n\t}\n\treturn (fip);\n}",
        "begin_line": 559,
        "end_line": 569,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo.TIFFFindField#507",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo.TIFFFindField(TIFF* tif, uint32 tag, TIFFDataType dt)",
        "snippet": "const TIFFField*\nTIFFFindField(TIFF* tif, uint32 tag, TIFFDataType dt)\n{\n\tTIFFField key = {0, 0, 0, TIFF_NOTYPE, 0, 0, 0, 0, 0, 0, NULL, NULL};\n\tTIFFField* pkey = &key;\n\tconst TIFFField **ret;\n\tif (tif->tif_foundfield && tif->tif_foundfield->field_tag == tag &&\n\t    (dt == TIFF_ANY || dt == tif->tif_foundfield->field_type))\n\t\treturn tif->tif_foundfield;\n\n\t/* If we are invoked with no field information, then just return. */\n\tif (!tif->tif_fields)\n\t\treturn NULL;\n\n\t/* NB: use sorted search (e.g. binary search) */\n\n\tkey.field_tag = tag;\n\tkey.field_type = dt;\n\n\tret = (const TIFFField **) bsearch(&pkey, tif->tif_fields,\n\t\t\t\t\t   tif->tif_nfields,\n\t\t\t\t\t   sizeof(TIFFField *), tagCompare);\n\treturn tif->tif_foundfield = (ret ? *ret : NULL);\n}",
        "begin_line": 507,
        "end_line": 530,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo._TIFFCreateAnonField#635",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo._TIFFCreateAnonField(TIFF *tif, uint32 tag, TIFFDataType field_type)",
        "snippet": "TIFFField*\n_TIFFCreateAnonField(TIFF *tif, uint32 tag, TIFFDataType field_type)\n{\n\tTIFFField *fld;\n\t(void) tif;\n\n\tfld = (TIFFField *) _TIFFmalloc(sizeof (TIFFField));\n\tif (fld == NULL)\n\t    return NULL;\n\t_TIFFmemset(fld, 0, sizeof(TIFFField));\n\n\tfld->field_tag = tag;\n\tfld->field_readcount = TIFF_VARIABLE2;\n\tfld->field_writecount = TIFF_VARIABLE2;\n\tfld->field_type = field_type;\n\tfld->reserved = 0;\n\tswitch (field_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_UNDEFINED:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_UINT8;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_UINT8;\n\t\t\tbreak;\n\t\tcase TIFF_ASCII:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_ASCII;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_ASCII;\n\t\t\tbreak;\n\t\tcase TIFF_SHORT:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_UINT16;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_UINT16;\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_UINT32;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_UINT32;\n\t\t\tbreak;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\tcase TIFF_FLOAT:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_FLOAT;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_FLOAT;\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_SINT8;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_SINT8;\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_SINT16;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_SINT16;\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_SINT32;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_SINT32;\n\t\t\tbreak;\n\t\tcase TIFF_DOUBLE:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_DOUBLE;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_DOUBLE;\n\t\t\tbreak;\n\t\tcase TIFF_IFD:\n\t\tcase TIFF_IFD8:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_IFD8;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_IFD8;\n\t\t\tbreak;\n\t\tcase TIFF_LONG8:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_UINT64;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_UINT64;\n\t\t\tbreak;\n\t\tcase TIFF_SLONG8:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_SINT64;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_SINT64;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfld->set_field_type = TIFF_SETGET_UNDEFINED;\n\t\t\tfld->get_field_type = TIFF_SETGET_UNDEFINED;\n\t\t\tbreak;\n\t}\n\tfld->field_bit = FIELD_CUSTOM;\n\tfld->field_oktochange = TRUE;\n\tfld->field_passcount = TRUE;\n\tfld->field_name = (char *) _TIFFmalloc(32);\n\tif (fld->field_name == NULL) {\n\t    _TIFFfree(fld);\n\t    return NULL;\n\t}\n\tfld->field_subfields = NULL;\n\n\t/* \n\t * note that this name is a special sign to TIFFClose() and\n\t * _TIFFSetupFields() to free the field\n\t */\n\t(void) snprintf(fld->field_name, 32, \"Tag %d\", (int) tag);\n\n\treturn fld;    \n}",
        "begin_line": 635,
        "end_line": 727,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo._TIFFDataSize#477",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo._TIFFDataSize(TIFFDataType type)",
        "snippet": "int\n_TIFFDataSize(TIFFDataType type)\n{\n\tswitch (type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_UNDEFINED:\n\t\t    return 1;\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t    return 2;\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_FLOAT:\n\t\tcase TIFF_IFD:\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\t    return 4;\n\t\tcase TIFF_DOUBLE:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\tcase TIFF_IFD8:\n\t\t    return 8;\n\t\tdefault:\n\t\t    return 0;\n\t}\n}",
        "begin_line": 477,
        "end_line": 505,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo._TIFFGetFields#306",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo._TIFFGetFields(void)",
        "snippet": "const TIFFFieldArray*\n_TIFFGetFields(void)\n{\n\treturn(&tiffFieldArray);\n}",
        "begin_line": 306,
        "end_line": 310,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo._TIFFMergeFields#370",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo._TIFFMergeFields(TIFF* tif, const TIFFField info[], uint32 n)",
        "snippet": "int\n_TIFFMergeFields(TIFF* tif, const TIFFField info[], uint32 n)\n{\n\tstatic const char module[] = \"_TIFFMergeFields\";\n\tstatic const char reason[] = \"for fields array\";\n\t/* TIFFField** tp; */\n\tuint32 i;\n\n        tif->tif_foundfield = NULL;\n\n\tif (tif->tif_fields && tif->tif_nfields > 0) {\n\t\ttif->tif_fields = (TIFFField**)\n\t\t\t_TIFFCheckRealloc(tif, tif->tif_fields,\n\t\t\t\t\t  (tif->tif_nfields + n),\n\t\t\t\t\t  sizeof(TIFFField *), reason);\n\t} else {\n\t\ttif->tif_fields = (TIFFField **)\n\t\t\t_TIFFCheckMalloc(tif, n, sizeof(TIFFField *),\n\t\t\t\t\t reason);\n\t}\n\tif (!tif->tif_fields) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Failed to allocate fields array\");\n\t\treturn 0;\n\t}\n\n\t/* tp = tif->tif_fields + tif->tif_nfields; */\n\tfor (i = 0; i < n; i++) {\n\t\tconst TIFFField *fip =\n\t\t\tTIFFFindField(tif, info[i].field_tag, TIFF_ANY);\n\n                /* only add definitions that aren't already present */\n\t\tif (!fip) {\n                        tif->tif_fields[tif->tif_nfields] = (TIFFField *) (info+i);\n                        tif->tif_nfields++;\n                }\n\t}\n\n        /* Sort the field info by tag number */\n\tqsort(tif->tif_fields, tif->tif_nfields,\n\t      sizeof(TIFFField *), tagCompare);\n\n\treturn n;\n}",
        "begin_line": 370,
        "end_line": 413,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo._TIFFSetupFields#318",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo._TIFFSetupFields(TIFF* tif, const TIFFFieldArray* fieldarray)",
        "snippet": "void\n_TIFFSetupFields(TIFF* tif, const TIFFFieldArray* fieldarray)\n{\n\tif (tif->tif_fields && tif->tif_nfields > 0) {\n\t\tuint32 i;\n\n\t\tfor (i = 0; i < tif->tif_nfields; i++) {\n\t\t\tTIFFField *fld = tif->tif_fields[i];\n\t\t\tif (fld->field_bit == FIELD_CUSTOM &&\n\t\t\t\tstrncmp(\"Tag \", fld->field_name, 4) == 0) {\n\t\t\t\t\t_TIFFfree(fld->field_name);\n\t\t\t\t\t_TIFFfree(fld);\n\t\t\t\t}\n\t\t}\n\n\t\t_TIFFfree(tif->tif_fields);\n\t\ttif->tif_fields = NULL;\n\t\ttif->tif_nfields = 0;\n\t}\n\tif (!_TIFFMergeFields(tif, fieldarray->fields, fieldarray->count)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, \"_TIFFSetupFields\",\n\t\t\t     \"Setting up field info failed\");\n\t}\n}",
        "begin_line": 318,
        "end_line": 341,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo.tagCompare#343",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo.tagCompare(const void* a, const void* b)",
        "snippet": "static int\ntagCompare(const void* a, const void* b)\n{\n\tconst TIFFField* ta = *(const TIFFField**) a;\n\tconst TIFFField* tb = *(const TIFFField**) b;\n\t/* NB: be careful of return values for 16-bit platforms */\n\tif (ta->field_tag != tb->field_tag)\n\t\treturn (int)ta->field_tag - (int)tb->field_tag;\n\telse\n\t\treturn (ta->field_type == TIFF_ANY) ?\n\t\t\t0 : ((int)tb->field_type - (int)ta->field_type);\n}",
        "begin_line": 343,
        "end_line": 354,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFCheckDirOffset#4383",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFCheckDirOffset(TIFF* tif, uint64 diroff)",
        "snippet": "static int\nTIFFCheckDirOffset(TIFF* tif, uint64 diroff)\n{\n\tuint16 n;\n\n\tif (diroff == 0)\t\t\t/* no more directories */\n\t\treturn 0;\n\tif (tif->tif_dirnumber == 65535) {\n\t    TIFFErrorExt(tif->tif_clientdata, \"TIFFCheckDirOffset\",\n\t\t\t \"Cannot handle more than 65535 TIFF directories\");\n\t    return 0;\n\t}\n\n\tfor (n = 0; n < tif->tif_dirnumber && tif->tif_dirlist; n++) {\n\t\tif (tif->tif_dirlist[n] == diroff)\n\t\t\treturn 0;\n\t}\n\n\ttif->tif_dirnumber++;\n\n\tif (tif->tif_dirlist == NULL || tif->tif_dirnumber > tif->tif_dirlistsize) {\n\t\tuint64* new_dirlist;\n\n\t\t/*\n\t\t * XXX: Reduce memory allocation granularity of the dirlist\n\t\t * array.\n\t\t */\n\t\tnew_dirlist = (uint64*)_TIFFCheckRealloc(tif, tif->tif_dirlist,\n\t\t    tif->tif_dirnumber, 2 * sizeof(uint64), \"for IFD list\");\n\t\tif (!new_dirlist)\n\t\t\treturn 0;\n\t\tif( tif->tif_dirnumber >= 32768 )\n\t\t    tif->tif_dirlistsize = 65535;\n\t\telse\n\t\t    tif->tif_dirlistsize = 2 * tif->tif_dirnumber;\n\t\ttif->tif_dirlist = new_dirlist;\n\t}\n\n\ttif->tif_dirlist[tif->tif_dirnumber - 1] = diroff;\n\n\treturn 1;\n}",
        "begin_line": 4383,
        "end_line": 4424,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFFetchDirectory#4457",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir, uint64 *nextdiroff)",
        "snippet": "static uint16\nTIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir,\n                   uint64 *nextdiroff)\n{\n\tstatic const char module[] = \"TIFFFetchDirectory\";\n\n\tvoid* origdir;\n\tuint16 dircount16;\n\tuint32 dirsize;\n\tTIFFDirEntry* dir;\n\tuint8* ma;\n\tTIFFDirEntry* mb;\n\tuint16 n;\n\n\tassert(pdir);\n\n\ttif->tif_diroff = diroff;\n\tif (nextdiroff)\n\t\t*nextdiroff = 0;\n\tif (!isMapped(tif)) {\n\t\tif (!SeekOK(tif, tif->tif_diroff)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%s: Seek error accessing TIFF directory\",\n\t\t\t\ttif->tif_name);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tif (!ReadOK(tif, &dircount16, sizeof (uint16))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"%s: Can not read TIFF directory count\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&dircount16);\n\t\t\tif (dircount16>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdirsize = 12;\n\t\t} else {\n\t\t\tuint64 dircount64;\n\t\t\tif (!ReadOK(tif, &dircount64, sizeof (uint64))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\"%s: Can not read TIFF directory count\",\n\t\t\t\t\ttif->tif_name);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\tif (dircount64>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdircount16 = (uint16)dircount64;\n\t\t\tdirsize = 20;\n\t\t}\n\t\torigdir = _TIFFCheckMalloc(tif, dircount16,\n\t\t    dirsize, \"to read TIFF directory\");\n\t\tif (origdir == NULL)\n\t\t\treturn 0;\n\t\tif (!ReadOK(tif, origdir, (tmsize_t)(dircount16*dirsize))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%.100s: Can not read TIFF directory\",\n\t\t\t\ttif->tif_name);\n\t\t\t_TIFFfree(origdir);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Read offset to next directory for sequential scans if\n\t\t * needed.\n\t\t */\n\t\tif (nextdiroff)\n\t\t{\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t{\n\t\t\t\tuint32 nextdiroff32;\n\t\t\t\tif (!ReadOK(tif, &nextdiroff32, sizeof(uint32)))\n\t\t\t\t\tnextdiroff32 = 0;\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong(&nextdiroff32);\n\t\t\t\t*nextdiroff=nextdiroff32;\n\t\t\t} else {\n\t\t\t\tif (!ReadOK(tif, nextdiroff, sizeof(uint64)))\n\t\t\t\t\t*nextdiroff = 0;\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong8(nextdiroff);\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttmsize_t m;\n\t\ttmsize_t off = (tmsize_t) tif->tif_diroff;\n\t\tif ((uint64)off!=tif->tif_diroff)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Can not read TIFF directory count\");\n\t\t\treturn(0);\n\t\t}\n\n\t\t/*\n\t\t * Check for integer overflow when validating the dir_off,\n\t\t * otherwise a very high offset may cause an OOB read and\n\t\t * crash the client. Make two comparisons instead of\n\t\t *\n\t\t *  off + sizeof(uint16) > tif->tif_size\n\t\t *\n\t\t * to avoid overflow.\n\t\t */\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tm=off+sizeof(uint16);\n\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint16))||(m>tif->tif_size)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\"Can not read TIFF directory count\");\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t_TIFFmemcpy(&dircount16, tif->tif_base + off,\n\t\t\t\t\t    sizeof(uint16));\n\t\t\t}\n\t\t\toff += sizeof (uint16);\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&dircount16);\n\t\t\tif (dircount16>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdirsize = 12;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint64 dircount64;\n\t\t\tm=off+sizeof(uint64);\n\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint64))||(m>tif->tif_size)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\"Can not read TIFF directory count\");\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t_TIFFmemcpy(&dircount64, tif->tif_base + off,\n\t\t\t\t\t    sizeof(uint64));\n\t\t\t}\n\t\t\toff += sizeof (uint64);\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\tif (dircount64>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdircount16 = (uint16)dircount64;\n\t\t\tdirsize = 20;\n\t\t}\n\t\tif (dircount16 == 0 )\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t             \"Sanity check on directory count failed, zero tag directories not supported\");\n\t\t\treturn 0;\n\t\t}\n\t\torigdir = _TIFFCheckMalloc(tif, dircount16,\n\t\t\t\t\t\tdirsize,\n\t\t\t\t\t\t\"to read TIFF directory\");\n\t\tif (origdir == NULL)\n\t\t\treturn 0;\n\t\tm=off+dircount16*dirsize;\n\t\tif ((m<off)||(m<(tmsize_t)(dircount16*dirsize))||(m>tif->tif_size)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"Can not read TIFF directory\");\n\t\t\t_TIFFfree(origdir);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t_TIFFmemcpy(origdir, tif->tif_base + off,\n\t\t\t\t    dircount16 * dirsize);\n\t\t}\n\t\tif (nextdiroff) {\n\t\t\toff += dircount16 * dirsize;\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t{\n\t\t\t\tuint32 nextdiroff32;\n\t\t\t\tm=off+sizeof(uint32);\n\t\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint32))||(m>tif->tif_size))\n\t\t\t\t\tnextdiroff32 = 0;\n\t\t\t\telse\n\t\t\t\t\t_TIFFmemcpy(&nextdiroff32, tif->tif_base + off,\n\t\t\t\t\t\t    sizeof (uint32));\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong(&nextdiroff32);\n\t\t\t\t*nextdiroff = nextdiroff32;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm=off+sizeof(uint64);\n\t\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint64))||(m>tif->tif_size))\n\t\t\t\t\t*nextdiroff = 0;\n\t\t\t\telse\n\t\t\t\t\t_TIFFmemcpy(nextdiroff, tif->tif_base + off,\n\t\t\t\t\t\t    sizeof (uint64));\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong8(nextdiroff);\n\t\t\t}\n\t\t}\n\t}\n\tdir = (TIFFDirEntry*)_TIFFCheckMalloc(tif, dircount16,\n\t\t\t\t\t\tsizeof(TIFFDirEntry),\n\t\t\t\t\t\t\"to read TIFF directory\");\n\tif (dir==0)\n\t{\n\t\t_TIFFfree(origdir);\n\t\treturn 0;\n\t}\n\tma=(uint8*)origdir;\n\tmb=dir;\n\tfor (n=0; n<dircount16; n++)\n\t{\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabShort((uint16*)ma);\n\t\tmb->tdir_tag=*(uint16*)ma;\n\t\tma+=sizeof(uint16);\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabShort((uint16*)ma);\n\t\tmb->tdir_type=*(uint16*)ma;\n\t\tma+=sizeof(uint16);\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\tmb->tdir_count=(uint64)(*(uint32*)ma);\n\t\t\tma+=sizeof(uint32);\n\t\t\t*(uint32*)(&mb->tdir_offset)=*(uint32*)ma;\n\t\t\tma+=sizeof(uint32);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8((uint64*)ma);\n                        mb->tdir_count=TIFFReadUInt64(ma);\n\t\t\tma+=sizeof(uint64);\n\t\t\tmb->tdir_offset.toff_long8=TIFFReadUInt64(ma);\n\t\t\tma+=sizeof(uint64);\n\t\t}\n\t\tmb++;\n\t}\n\t_TIFFfree(origdir);\n\t*pdir = dir;\n\treturn dircount16;\n}",
        "begin_line": 4457,
        "end_line": 4707,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFFetchNormalTag#4712",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)",
        "snippet": "static int\nTIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)\n{\n\tstatic const char module[] = \"TIFFFetchNormalTag\";\n\tenum TIFFReadDirEntryErr err;\n\tuint32 fii;\n\tconst TIFFField* fip = NULL;\n\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n        if( fii == FAILED_FII )\n        {\n            TIFFErrorExt(tif->tif_clientdata, \"TIFFFetchNormalTag\",\n                         \"No definition found for tag %d\",\n                         dp->tdir_tag);\n            return 0;\n        }\n\tfip=tif->tif_fields[fii];\n\tassert(fip != NULL); /* should not happen */\n\tassert(fip->set_field_type!=TIFF_SETGET_OTHER);  /* if so, we shouldn't arrive here but deal with this in specialized code */\n\tassert(fip->set_field_type!=TIFF_SETGET_INT);    /* if so, we shouldn't arrive here as this is only the case for pseudo-tags */\n\terr=TIFFReadDirEntryErrOk;\n\tswitch (fip->set_field_type)\n\t{\n\t\tcase TIFF_SETGET_UNDEFINED:\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_ASCII:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tuint8* ma;\n\t\t\t\t\tuint32 mb;\n\t\t\t\t\tint n;\n\t\t\t\t\tma=data;\n\t\t\t\t\tmb=0;\n\t\t\t\t\twhile (mb<(uint32)dp->tdir_count)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (*ma==0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tma++;\n\t\t\t\t\t\tmb++;\n\t\t\t\t\t}\n\t\t\t\t\tif (mb+1<(uint32)dp->tdir_count)\n\t\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" contains null byte in value; value incorrectly truncated during reading due to implementation limitations\",fip->field_name);\n\t\t\t\t\telse if (mb+1>(uint32)dp->tdir_count)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8* o;\n\t\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" does not end in null byte\",fip->field_name);\n\t\t\t\t\t\tif ((uint32)dp->tdir_count+1!=dp->tdir_count+1)\n\t\t\t\t\t\t\to=NULL;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\to=_TIFFmalloc((uint32)dp->tdir_count+1);\n\t\t\t\t\t\tif (o==NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (data!=NULL)\n\t\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_TIFFmemcpy(o,data,(uint32)dp->tdir_count);\n\t\t\t\t\t\to[(uint32)dp->tdir_count]=0;\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tdata=o;\n\t\t\t\t\t}\n\t\t\t\t\tn=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!n)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT8:\n\t\t\t{\n\t\t\t\tuint8 data=0;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryByte(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT16:\n\t\t\t{\n\t\t\t\tuint16 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryShort(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT32:\n\t\t\t{\n\t\t\t\tuint32 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryLong(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT64:\n\t\t\t{\n\t\t\t\tuint64 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryLong8(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_FLOAT:\n\t\t\t{\n\t\t\t\tfloat data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryFloat(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_DOUBLE:\n\t\t\t{\n\t\t\t\tdouble data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryDouble(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_IFD8:\n\t\t\t{\n\t\t\t\tuint64 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryIfd8(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT16_PAIR:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount==2);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=2) {\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t\t\t       \"incorrect count for field \\\"%s\\\", expected 2, got %d\",\n\t\t\t\t\t\t       fip->field_name,(int)dp->tdir_count);\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data[0],data[1]);\n\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_UINT8:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount) {\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t\t\t       \"incorrect count for field \\\"%s\\\", expected %d, got %d\",\n\t\t\t\t\t\t       fip->field_name,(int) fip->field_readcount, (int)dp->tdir_count);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_UINT16:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)\n                                    /* corrupt file */;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_UINT32:\n\t\t\t{\n\t\t\t\tuint32* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)\n                                    /* corrupt file */;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_FLOAT:\n\t\t\t{\n\t\t\t\tfloat* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)\n                                    /* corrupt file */;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_ASCII:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n                        if( dp->tdir_count > 0 && data[dp->tdir_count-1] != '\\0' )\n                        {\n                            TIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" does not end in null byte. Forcing it to be null\",fip->field_name);\n                            data[dp->tdir_count-1] = '\\0';\n                        }\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT8:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT16:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT32:\n\t\t\t{\n\t\t\t\tuint32* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT64:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryLong8Array(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_FLOAT:\n\t\t\t{\n\t\t\t\tfloat* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_DOUBLE:\n\t\t\t{\n\t\t\t\tdouble* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryDoubleArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_IFD8:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryIfd8Array(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_ASCII:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n                    if( dp->tdir_count > 0 && data[dp->tdir_count-1] != '\\0' )\n                    {\n                        TIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" does not end in null byte. Forcing it to be null\",fip->field_name);\n                        data[dp->tdir_count-1] = '\\0';\n                    }\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT8:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT8:\n\t\t\t{\n\t\t\t\tint8* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySbyteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT16:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT16:\n\t\t\t{\n\t\t\t\tint16* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySshortArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT32:\n\t\t\t{\n\t\t\t\tuint32* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT32:\n\t\t\t{\n\t\t\t\tint32* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySlongArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT64:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryLong8Array(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT64:\n\t\t\t{\n\t\t\t\tint64* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySlong8Array(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_FLOAT:\n\t\t\t{\n\t\t\t\tfloat* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_DOUBLE:\n\t\t\t{\n\t\t\t\tdouble* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryDoubleArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_IFD8:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryIfd8Array(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);    /* we should never get here */\n\t\t\tbreak;\n\t}\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip->field_name,recover);\n\t\treturn(0);\n\t}\n\treturn(1);\n}",
        "begin_line": 4712,
        "end_line": 5390,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFFetchStripThing#5396",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32 nstrips, uint64** lpp)",
        "snippet": "static int\nTIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32 nstrips, uint64** lpp)\n{\n\tstatic const char module[] = \"TIFFFetchStripThing\";\n\tenum TIFFReadDirEntryErr err;\n\tuint64* data;\n\terr=TIFFReadDirEntryLong8Array(tif,dir,&data);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\tconst TIFFField* fip = TIFFFieldWithTag(tif,dir->tdir_tag); \n\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",0);\n\t\treturn(0);\n\t}\n\tif (dir->tdir_count!=(uint64)nstrips)\n\t{\n\t\tuint64* resizeddata;\n\t\tresizeddata=(uint64*)_TIFFCheckMalloc(tif,nstrips,sizeof(uint64),\"for strip array\");\n\t\tif (resizeddata==0) {\n\t\t\t_TIFFfree(data);\n\t\t\treturn(0);\n\t\t}\n\t\tif (dir->tdir_count<(uint64)nstrips)\n\t\t{\n\t\t\t_TIFFmemcpy(resizeddata,data,(uint32)dir->tdir_count*sizeof(uint64));\n\t\t\t_TIFFmemset(resizeddata+(uint32)dir->tdir_count,0,(nstrips-(uint32)dir->tdir_count)*sizeof(uint64));\n\t\t}\n\t\telse\n\t\t\t_TIFFmemcpy(resizeddata,data,nstrips*sizeof(uint64));\n\t\t_TIFFfree(data);\n\t\tdata=resizeddata;\n\t}\n\t*lpp=data;\n\treturn(1);\n}",
        "begin_line": 5396,
        "end_line": 5429,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryArray#767",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryArray(TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize, void** value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryArray(TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize, void** value)\n{\n\tint typesize;\n\tuint32 datasize;\n\tvoid* data;\n\ttypesize=TIFFDataWidth(direntry->tdir_type);\n\tif ((direntry->tdir_count==0)||(typesize==0))\n\t{\n\t\t*value=0;\n\t\treturn(TIFFReadDirEntryErrOk);\n\t}\n        (void) desttypesize;\n\n        /* \n         * As a sanity check, make sure we have no more than a 2GB tag array \n         * in either the current data type or the dest data type.  This also\n         * avoids problems with overflow of tmsize_t on 32bit systems.\n         */\n\tif ((uint64)(2147483647/typesize)<direntry->tdir_count)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\tif ((uint64)(2147483647/desttypesize)<direntry->tdir_count)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\n\t*count=(uint32)direntry->tdir_count;\n\tdatasize=(*count)*typesize;\n\tassert((tmsize_t)datasize>0);\n\tdata=_TIFFCheckMalloc(tif, *count, typesize, \"ReadDirEntryArray\");\n\tif (data==0)\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tif (datasize<=4)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint32 offset = direntry->tdir_offset.toff_long;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&offset);\n\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (datasize<=8)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint64 offset = direntry->tdir_offset.toff_long8;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&offset);\n\t\t\terr=TIFFReadDirEntryData(tif,offset,(tmsize_t)datasize,data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 767,
        "end_line": 834,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryByteArray#836",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntry* direntry, uint8** value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntry* direntry, uint8** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tuint8* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_UNDEFINED:\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,1,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_UNDEFINED:\n\t\tcase TIFF_BYTE:\n\t\t\t*value=(uint8*)origdata;\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8* m;\n\t\t\t\tuint32 n;\n\t\t\t\tm=(int8*)origdata;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSbyte(*m);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\t_TIFFfree(origdata);\n\t\t\t\t\t\treturn(err);\n\t\t\t\t\t}\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t\t*value=(uint8*)origdata;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t}\n\tdata=(uint8*)_TIFFmalloc(count);\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteShort(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort((uint16*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSshort(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteLong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSlong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteLong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8((uint64*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSlong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\t_TIFFfree(data);\n\t\treturn(err);\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 836,
        "end_line": 1015,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryCheckRangeByteShort#2960",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryCheckRangeByteShort(uint16 value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteShort(uint16 value)\n{\n\tif (value>0xFF)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 2960,
        "end_line": 2966,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryCheckedShort#2787",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryCheckedShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)",
        "snippet": "static void TIFFReadDirEntryCheckedShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)\n{\n\t*value = direntry->tdir_offset.toff_short;\n\t/* *value=*(uint16*)(&direntry->tdir_offset); */\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabShort(value);\n}",
        "begin_line": 2787,
        "end_line": 2793,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryData#3282",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryData(TIFF* tif, uint64 offset, tmsize_t size, void* dest)",
        "snippet": "static enum TIFFReadDirEntryErr\nTIFFReadDirEntryData(TIFF* tif, uint64 offset, tmsize_t size, void* dest)\n{\n\tassert(size>0);\n\tif (!isMapped(tif)) {\n\t\tif (!SeekOK(tif,offset))\n\t\t\treturn(TIFFReadDirEntryErrIo);\n\t\tif (!ReadOK(tif,dest,size))\n\t\t\treturn(TIFFReadDirEntryErrIo);\n\t} else {\n\t\tsize_t ma,mb;\n\t\tma=(size_t)offset;\n\t\tmb=ma+size;\n\t\tif (((uint64)ma!=offset)\n\t\t    || (mb < ma)\n\t\t    || (mb - ma != (size_t) size)\n\t\t    || (mb < (size_t)size)\n\t\t    || (mb > (size_t)tif->tif_size)\n\t\t    )\n\t\t\treturn(TIFFReadDirEntryErrIo);\n\t\t_TIFFmemcpy(dest,tif->tif_base+ma,size);\n\t}\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 3282,
        "end_line": 3305,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryFloatArray#2181",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryFloatArray(TIFF* tif, TIFFDirEntry* direntry, float** value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryFloatArray(TIFF* tif, TIFFDirEntry* direntry, float** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tfloat* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\tcase TIFF_FLOAT:\n\t\tcase TIFF_DOUBLE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,4,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_FLOAT:\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabArrayOfLong((uint32*)origdata,count);  \n\t\t\tTIFFCvtIEEEDoubleToNative(tif,count,(float*)origdata);\n\t\t\t*value=(float*)origdata;\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t}\n\tdata=(float*)_TIFFmalloc(count*sizeof(float));\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8* ma;\n\t\t\t\tfloat* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(float)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8* ma;\n\t\t\t\tfloat* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(float)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16* ma;\n\t\t\t\tfloat* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort(ma);\n\t\t\t\t\t*mb++=(float)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16* ma;\n\t\t\t\tfloat* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort((uint16*)ma);\n\t\t\t\t\t*mb++=(float)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tfloat* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\t*mb++=(float)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32* ma;\n\t\t\t\tfloat* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\t\t\t*mb++=(float)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64* ma;\n\t\t\t\tfloat* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8(ma);\n#if defined(__WIN32__) && (_MSC_VER < 1500)\n\t\t\t\t\t/*\n\t\t\t\t\t * XXX: MSVC 6.0 does not support\n\t\t\t\t\t * conversion of 64-bit integers into\n\t\t\t\t\t * floating point values.\n\t\t\t\t\t */\n\t\t\t\t\t*mb++ = _TIFFUInt64ToFloat(*ma++);\n#else\n\t\t\t\t\t*mb++ = (float)(*ma++);\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64* ma;\n\t\t\t\tfloat* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8((uint64*)ma);\n\t\t\t\t\t*mb++=(float)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_RATIONAL:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tuint32 maa;\n\t\t\t\tuint32 mab;\n\t\t\t\tfloat* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\tmaa=*ma++;\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\tmab=*ma++;\n\t\t\t\t\tif (mab==0)\n\t\t\t\t\t\t*mb++=0.0;\n\t\t\t\t\telse\n\t\t\t\t\t\t*mb++=(float)maa/(float)mab;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SRATIONAL:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tint32 maa;\n\t\t\t\tuint32 mab;\n\t\t\t\tfloat* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\tmaa=*(int32*)ma;\n\t\t\t\t\tma++;\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\tmab=*ma++;\n\t\t\t\t\tif (mab==0)\n\t\t\t\t\t\t*mb++=0.0;\n\t\t\t\t\telse\n\t\t\t\t\t\t*mb++=(float)maa/(float)mab;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_DOUBLE:\n\t\t\t{\n\t\t\t\tdouble* ma;\n\t\t\t\tfloat* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabArrayOfLong8((uint64*)origdata,count);\n\t\t\t\tTIFFCvtIEEEDoubleToNative(tif,count,(double*)origdata);\n\t\t\t\tma=(double*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(float)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 2181,
        "end_line": 2416,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryLong#374",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryLong(TIFF* tif, TIFFDirEntry* direntry, uint32* value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryLong(TIFF* tif, TIFFDirEntry* direntry, uint32* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tif (direntry->tdir_count!=1)\n\t\treturn(TIFFReadDirEntryErrCount);\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedByte(tif,direntry,&m);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedSbyte(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSbyte(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedShort(tif,direntry,&m);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedSshort(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSshort(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG:\n\t\t\tTIFFReadDirEntryCheckedLong(tif,direntry,value);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedSlong(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSlong(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongLong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSlong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n}",
        "begin_line": 374,
        "end_line": 455,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryLong8Array#1865",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tuint64* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,8,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_LONG8:\n\t\t\t*value=(uint64*)origdata;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabArrayOfLong8(*value,count);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64* m;\n\t\t\t\tuint32 n;\n\t\t\t\tm=(int64*)origdata;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8((uint64*)m);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Slong8(*m);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\t_TIFFfree(origdata);\n\t\t\t\t\t\treturn(err);\n\t\t\t\t\t}\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t\t*value=(uint64*)origdata;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t}\n\tdata=(uint64*)_TIFFmalloc(count*8);\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Sbyte(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort(ma);\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort((uint16*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Sshort(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Slong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\t_TIFFfree(data);\n\t\treturn(err);\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 1865,
        "end_line": 2029,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryOutputErr#3307",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryOutputErr(TIFF* tif, enum TIFFReadDirEntryErr err, const char* module, const char* tagname, int recover)",
        "snippet": "static void TIFFReadDirEntryOutputErr(TIFF* tif, enum TIFFReadDirEntryErr err, const char* module, const char* tagname, int recover)\n{\n\tif (!recover) {\n\t\tswitch (err) {\n\t\t\tcase TIFFReadDirEntryErrCount:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Incorrect count for \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrType:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Incompatible type for \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrIo:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"IO error during reading of \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrRange:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Incorrect value for \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrPsdif:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"Cannot handle different values per sample for \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrSizesan:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"Sanity check on size of \\\"%s\\\" value failed\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrAlloc:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Out of memory reading of \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);   /* we should never get here */\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (err) {\n\t\t\tcase TIFFReadDirEntryErrCount:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"Incorrect count for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrType:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"Incompatible type for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrIo:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\"IO error during reading of \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrRange:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"Incorrect value for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrPsdif:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\"Cannot handle different values per sample for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrSizesan:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\"Sanity check on size of \\\"%s\\\" value failed; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrAlloc:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"Out of memory reading of \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);   /* we should never get here */\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
        "begin_line": 3307,
        "end_line": 3392,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryPersampleShort#2717",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryPersampleShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryPersampleShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint16* m;\n\tuint16* na;\n\tuint16 nb;\n\tif (direntry->tdir_count<(uint64)tif->tif_dir.td_samplesperpixel)\n\t\treturn(TIFFReadDirEntryErrCount);\n\terr=TIFFReadDirEntryShortArray(tif,direntry,&m);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t\treturn(err);\n\tna=m;\n\tnb=tif->tif_dir.td_samplesperpixel;\n\t*value=*na++;\n\tnb--;\n\twhile (nb>0)\n\t{\n\t\tif (*na++!=*value)\n\t\t{\n\t\t\terr=TIFFReadDirEntryErrPsdif;\n\t\t\tbreak;\n\t\t}\n\t\tnb--;\n\t}\n\t_TIFFfree(m);\n\treturn(err);\n}",
        "begin_line": 2717,
        "end_line": 2743,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryShort#288",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tif (direntry->tdir_count!=1)\n\t\treturn(TIFFReadDirEntryErrCount);\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedByte(tif,direntry,&m);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedSbyte(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSbyte(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SHORT:\n\t\t\tTIFFReadDirEntryCheckedShort(tif,direntry,value);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedSshort(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSshort(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedLong(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortLong(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedSlong(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSlong(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortLong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSlong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n}",
        "begin_line": 288,
        "end_line": 372,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryShortArray#1196",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryShortArray(TIFF* tif, TIFFDirEntry* direntry, uint16** value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryShortArray(TIFF* tif, TIFFDirEntry* direntry, uint16** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tuint16* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,2,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_SHORT:\n\t\t\t*value=(uint16*)origdata;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabArrayOfShort(*value,count);  \n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16* m;\n\t\t\t\tuint32 n;\n\t\t\t\tm=(int16*)origdata;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort((uint16*)m);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSshort(*m);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\t_TIFFfree(origdata);\n\t\t\t\t\t\treturn(err);\n\t\t\t\t\t}\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t\t*value=(uint16*)origdata;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t}\n\tdata=(uint16*)_TIFFmalloc(count*2);\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSbyte(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortLong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSlong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortLong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8((uint64*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSlong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\t_TIFFfree(data);\n\t\treturn(err);\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 1196,
        "end_line": 1366,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirectory#3398",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirectory(TIFF* tif)",
        "snippet": "int\nTIFFReadDirectory(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFReadDirectory\";\n\tTIFFDirEntry* dir;\n\tuint16 dircount;\n\tTIFFDirEntry* dp;\n\tuint16 di;\n\tconst TIFFField* fip;\n\tuint32 fii=FAILED_FII;\n        toff_t nextdiroff;\n    int bitspersample_read = FALSE;\n\n\ttif->tif_diroff=tif->tif_nextdiroff;\n\tif (!TIFFCheckDirOffset(tif,tif->tif_nextdiroff))\n\t\treturn 0;           /* last offset or bad offset (IFD looping) */\n\t(*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */\n\ttif->tif_curdir++;\n        nextdiroff = tif->tif_nextdiroff;\n\tdircount=TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff);\n\tif (!dircount)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"Failed to read directory at offset \" TIFF_UINT64_FORMAT,nextdiroff);\n\t\treturn 0;\n\t}\n\tTIFFReadDirectoryCheckOrder(tif,dir,dircount);\n\n        /*\n         * Mark duplicates of any tag to be ignored (bugzilla 1994)\n         * to avoid certain pathological problems.\n         */\n\t{\n\t\tTIFFDirEntry* ma;\n\t\tuint16 mb;\n\t\tfor (ma=dir, mb=0; mb<dircount; ma++, mb++)\n\t\t{\n\t\t\tTIFFDirEntry* na;\n\t\t\tuint16 nb;\n\t\t\tfor (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)\n\t\t\t{\n\t\t\t\tif (ma->tdir_tag==na->tdir_tag)\n\t\t\t\t\tna->tdir_tag=IGNORE;\n\t\t\t}\n\t\t}\n\t}\n        \n\ttif->tif_flags &= ~TIFF_BEENWRITING;    /* reset before new dir */\n\ttif->tif_flags &= ~TIFF_BUF4WRITE;      /* reset before new dir */\n\t/* free any old stuff and reinit */\n\tTIFFFreeDirectory(tif);\n\tTIFFDefaultDirectory(tif);\n\t/*\n\t * Electronic Arts writes gray-scale TIFF files\n\t * without a PlanarConfiguration directory entry.\n\t * Thus we setup a default value here, even though\n\t * the TIFF spec says there is no default value.\n\t */\n\tTIFFSetField(tif,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n\t/*\n\t * Setup default value and then make a pass over\n\t * the fields to check type and tag information,\n\t * and to extract info required to size data\n\t * structures.  A second pass is made afterwards\n\t * to read in everything not taken in the first pass.\n\t * But we must process the Compression tag first\n\t * in order to merge in codec-private tag definitions (otherwise\n\t * we may get complaints about unknown tags).  However, the\n\t * Compression tag may be dependent on the SamplesPerPixel\n\t * tag value because older TIFF specs permitted Compression\n\t * to be written as a SamplesPerPixel-count tag entry.\n\t * Thus if we don't first figure out the correct SamplesPerPixel\n\t * tag value then we may end up ignoring the Compression tag\n\t * value because it has an incorrect count value (if the\n\t * true value of SamplesPerPixel is not 1).\n\t */\n\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_SAMPLESPERPIXEL);\n\tif (dp)\n\t{\n\t\tif (!TIFFFetchNormalTag(tif,dp,0))\n\t\t\tgoto bad;\n\t\tdp->tdir_tag=IGNORE;\n\t}\n\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_COMPRESSION);\n\tif (dp)\n\t{\n\t\t/*\n\t\t * The 5.0 spec says the Compression tag has one value, while\n\t\t * earlier specs say it has one value per sample.  Because of\n\t\t * this, we accept the tag if one value is supplied with either\n\t\t * count.\n\t\t */\n\t\tuint16 value;\n\t\tenum TIFFReadDirEntryErr err;\n\t\terr=TIFFReadDirEntryShort(tif,dp,&value);\n\t\tif (err==TIFFReadDirEntryErrCount)\n\t\t\terr=TIFFReadDirEntryPersampleShort(tif,dp,&value);\n\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t{\n\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,\"Compression\",0);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (!TIFFSetField(tif,TIFFTAG_COMPRESSION,value))\n\t\t\tgoto bad;\n\t\tdp->tdir_tag=IGNORE;\n\t}\n\telse\n\t{\n\t\tif (!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE))\n\t\t\tgoto bad;\n\t}\n\t/*\n\t * First real pass over the directory.\n\t */\n\tfor (di=0, dp=dir; di<dircount; di++, dp++)\n\t{\n\t\tif (dp->tdir_tag!=IGNORE)\n\t\t{\n\t\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\t\tif (fii == FAILED_FII)\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Unknown field with tag %d (0x%x) encountered\",\n\t\t\t\t    dp->tdir_tag,dp->tdir_tag);\n                                /* the following knowingly leaks the \n                                   anonymous field structure */\n\t\t\t\tif (!_TIFFMergeFields(tif,\n\t\t\t\t\t_TIFFCreateAnonField(tif,\n\t\t\t\t\t\tdp->tdir_tag,\n\t\t\t\t\t\t(TIFFDataType) dp->tdir_type),\n\t\t\t\t\t1)) {\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t    module,\n\t\t\t\t\t    \"Registering anonymous field with tag %d (0x%x) failed\",\n\t\t\t\t\t    dp->tdir_tag,\n\t\t\t\t\t    dp->tdir_tag);\n\t\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\t\t} else {\n\t\t\t\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\t\t\t\tassert(fii != FAILED_FII);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dp->tdir_tag!=IGNORE)\n\t\t{\n\t\t\tfip=tif->tif_fields[fii];\n\t\t\tif (fip->field_bit==FIELD_IGNORE)\n\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tswitch (dp->tdir_tag)\n\t\t\t\t{\n\t\t\t\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\t\t\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\t\t\t\tcase TIFFTAG_TILEOFFSETS:\n\t\t\t\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\t\t\t\t\tTIFFSetFieldBit(tif,fip->field_bit);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TIFFTAG_IMAGEWIDTH:\n\t\t\t\t\tcase TIFFTAG_IMAGELENGTH:\n\t\t\t\t\tcase TIFFTAG_IMAGEDEPTH:\n\t\t\t\t\tcase TIFFTAG_TILELENGTH:\n\t\t\t\t\tcase TIFFTAG_TILEWIDTH:\n\t\t\t\t\tcase TIFFTAG_TILEDEPTH:\n\t\t\t\t\tcase TIFFTAG_PLANARCONFIG:\n\t\t\t\t\tcase TIFFTAG_ROWSPERSTRIP:\n\t\t\t\t\tcase TIFFTAG_EXTRASAMPLES:\n\t\t\t\t\t\tif (!TIFFFetchNormalTag(tif,dp,0))\n\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * XXX: OJPEG hack.\n\t * If a) compression is OJPEG, b) planarconfig tag says it's separate,\n\t * c) strip offsets/bytecounts tag are both present and\n\t * d) both contain exactly one value, then we consistently find\n\t * that the buggy implementation of the buggy compression scheme\n\t * matches contig planarconfig best. So we 'fix-up' the tag here\n\t */\n\tif ((tif->tif_dir.td_compression==COMPRESSION_OJPEG)&&\n\t    (tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE))\n\t{\n        if (!_TIFFFillStriles(tif))\n            goto bad;\n\t\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS);\n\t\tif ((dp!=0)&&(dp->tdir_count==1))\n\t\t{\n\t\t\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,\n\t\t\t    TIFFTAG_STRIPBYTECOUNTS);\n\t\t\tif ((dp!=0)&&(dp->tdir_count==1))\n\t\t\t{\n\t\t\t\ttif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t    \"Planarconfig tag value assumed incorrect, \"\n\t\t\t\t    \"assuming data is contig instead of chunky\");\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Allocate directory structure and setup defaults.\n\t */\n\tif (!TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))\n\t{\n\t\tMissingRequired(tif,\"ImageLength\");\n\t\tgoto bad;\n\t}\n\t/*\n\t * Setup appropriate structures (by strip or by tile)\n\t */\n\tif (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {\n\t\ttif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif);  \n\t\ttif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;\n\t\ttif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;\n\t\ttif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;\n\t\ttif->tif_flags &= ~TIFF_ISTILED;\n\t} else {\n\t\ttif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);\n\t\ttif->tif_flags |= TIFF_ISTILED;\n\t}\n\tif (!tif->tif_dir.td_nstrips) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Cannot handle zero number of %s\",\n\t\t    isTiled(tif) ? \"tiles\" : \"strips\");\n\t\tgoto bad;\n\t}\n\ttif->tif_dir.td_stripsperimage = tif->tif_dir.td_nstrips;\n\tif (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\ttif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel;\n\tif (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {\n#ifdef OJPEG_SUPPORT\n\t\tif ((tif->tif_dir.td_compression==COMPRESSION_OJPEG) &&\n\t\t    (isTiled(tif)==0) &&\n\t\t    (tif->tif_dir.td_nstrips==1)) {\n\t\t\t/*\n\t\t\t * XXX: OJPEG hack.\n\t\t\t * If a) compression is OJPEG, b) it's not a tiled TIFF,\n\t\t\t * and c) the number of strips is 1,\n\t\t\t * then we tolerate the absence of stripoffsets tag,\n\t\t\t * because, presumably, all required data is in the\n\t\t\t * JpegInterchangeFormat stream.\n\t\t\t */\n\t\t\tTIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);\n\t\t} else\n#endif\n        {\n\t\t\tMissingRequired(tif,\n\t\t\t\tisTiled(tif) ? \"TileOffsets\" : \"StripOffsets\");\n\t\t\tgoto bad;\n\t\t}\n\t}\n\t/*\n\t * Second pass: extract other information.\n\t */\n\tfor (di=0, dp=dir; di<dircount; di++, dp++)\n\t{\n\t\tswitch (dp->tdir_tag)\n\t\t{\n\t\t\tcase IGNORE:\n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\t\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\t\tcase TIFFTAG_BITSPERSAMPLE:\n\t\t\tcase TIFFTAG_DATATYPE:\n\t\t\tcase TIFFTAG_SAMPLEFORMAT:\n\t\t\t\t/*\n\t\t\t\t * The MinSampleValue, MaxSampleValue, BitsPerSample\n\t\t\t\t * DataType and SampleFormat tags are supposed to be\n\t\t\t\t * written as one value/sample, but some vendors\n\t\t\t\t * incorrectly write one value only -- so we accept\n\t\t\t\t * that as well (yuck). Other vendors write correct\n\t\t\t\t * value for NumberOfSamples, but incorrect one for\n\t\t\t\t * BitsPerSample and friends, and we will read this\n\t\t\t\t * too.\n\t\t\t\t */\n\t\t\t\t{\n\t\t\t\t\tuint16 value;\n\t\t\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\t\t\terr=TIFFReadDirEntryShort(tif,dp,&value);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrCount)\n\t\t\t\t\t\terr=TIFFReadDirEntryPersampleShort(tif,dp,&value);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tfip = TIFFFieldWithTag(tif,dp->tdir_tag);\n\t\t\t\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",0);\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t}\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,value))\n\t\t\t\t\t\tgoto bad;\n                    if( dp->tdir_tag == TIFFTAG_BITSPERSAMPLE )\n                        bitspersample_read = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\t\t\t{\n\n\t\t\t\t\tdouble *data = NULL;\n\t\t\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\t\t\tuint32 saved_flags;\n\t\t\t\t\tint m;\n\t\t\t\t\tif (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)\n\t\t\t\t\t\terr = TIFFReadDirEntryErrCount;\n\t\t\t\t\telse\n\t\t\t\t\t\terr = TIFFReadDirEntryDoubleArray(tif, dp, &data);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tfip = TIFFFieldWithTag(tif,dp->tdir_tag);\n\t\t\t\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",0);\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t}\n\t\t\t\t\tsaved_flags = tif->tif_flags;\n\t\t\t\t\ttif->tif_flags |= TIFF_PERSAMPLE;\n\t\t\t\t\tm = TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\ttif->tif_flags = saved_flags;\n\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\t\tcase TIFFTAG_TILEOFFSETS:\n#if defined(DEFER_STRILE_LOAD)\n                                _TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),\n                                             dp, sizeof(TIFFDirEntry) );\n#else                          \n\t\t\t\tif (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset))  \n\t\t\t\t\tgoto bad;\n#endif                                \n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\t\tcase TIFFTAG_TILEBYTECOUNTS:\n#if defined(DEFER_STRILE_LOAD)\n                                _TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),\n                                             dp, sizeof(TIFFDirEntry) );\n#else                          \n\t\t\t\tif (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount))  \n\t\t\t\t\tgoto bad;\n#endif                                \n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_COLORMAP:\n\t\t\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\t\t\t{\n\t\t\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\t\t\tuint32 countpersample;\n\t\t\t\t\tuint32 countrequired;\n\t\t\t\t\tuint32 incrementpersample;\n\t\t\t\t\tuint16* value=NULL;\n                    /* It would be dangerous to instantiate those tag values */\n                    /* since if td_bitspersample has not yet been read (due to */\n                    /* unordered tags), it could be read afterwards with a */\n                    /* values greater than the default one (1), which may cause */\n                    /* crashes in user code */\n                    if( !bitspersample_read )\n                    {\n                        fip = TIFFFieldWithTag(tif,dp->tdir_tag);\n                        TIFFWarningExt(tif->tif_clientdata,module,\n                                       \"Ignoring %s since BitsPerSample tag not found\",\n                                       fip ? fip->field_name : \"unknown tagname\");\n                        continue;\n                    }\n\t\t\t\t\t/* ColorMap or TransferFunction for high bit */\n\t\t\t\t\t/* depths do not make much sense and could be */\n\t\t\t\t\t/* used as a denial of service vector */\n\t\t\t\t\tif (tif->tif_dir.td_bitspersample > 24)\n\t\t\t\t\t{\n\t\t\t\t\t    fip = TIFFFieldWithTag(tif,dp->tdir_tag);\n\t\t\t\t\t    TIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t\t\t\"Ignoring %s because BitsPerSample=%d>24\",\n\t\t\t\t\t\tfip ? fip->field_name : \"unknown tagname\",\n\t\t\t\t\t\ttif->tif_dir.td_bitspersample);\n\t\t\t\t\t    continue;\n\t\t\t\t\t}\n\t\t\t\t\tcountpersample=(1U<<tif->tif_dir.td_bitspersample);\n\t\t\t\t\tif ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))\n\t\t\t\t\t{\n\t\t\t\t\t\tcountrequired=countpersample;\n\t\t\t\t\t\tincrementpersample=0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcountrequired=3*countpersample;\n\t\t\t\t\t\tincrementpersample=countpersample;\n\t\t\t\t\t}\n\t\t\t\t\tif (dp->tdir_count!=(uint64)countrequired)\n\t\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\t\telse\n\t\t\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&value);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n                    {\n\t\t\t\t\t\tfip = TIFFFieldWithTag(tif,dp->tdir_tag);\n\t\t\t\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",1);\n                    }\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tTIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);\n\t\t\t\t\t\t_TIFFfree(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n/* BEGIN REV 4.0 COMPATIBILITY */\n\t\t\tcase TIFFTAG_OSUBFILETYPE:\n\t\t\t\t{\n\t\t\t\t\tuint16 valueo;\n\t\t\t\t\tuint32 value;\n\t\t\t\t\tif (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (valueo)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;\n\t\t\t\t\t\t\tcase OFILETYPE_PAGE: value=FILETYPE_PAGE; break;\n\t\t\t\t\t\t\tdefault: value=0; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value!=0)\n\t\t\t\t\t\t\tTIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n/* END REV 4.0 COMPATIBILITY */\n\t\t\tdefault:\n\t\t\t\t(void) TIFFFetchNormalTag(tif, dp, TRUE);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * OJPEG hack:\n\t * - If a) compression is OJPEG, and b) photometric tag is missing,\n\t * then we consistently find that photometric should be YCbCr\n\t * - If a) compression is OJPEG, and b) photometric tag says it's RGB,\n\t * then we consistently find that the buggy implementation of the\n\t * buggy compression scheme matches photometric YCbCr instead.\n\t * - If a) compression is OJPEG, and b) bitspersample tag is missing,\n\t * then we consistently find bitspersample should be 8.\n\t * - If a) compression is OJPEG, b) samplesperpixel tag is missing,\n\t * and c) photometric is RGB or YCbCr, then we consistently find\n\t * samplesperpixel should be 3\n\t * - If a) compression is OJPEG, b) samplesperpixel tag is missing,\n\t * and c) photometric is MINISWHITE or MINISBLACK, then we consistently\n\t * find samplesperpixel should be 3\n\t */\n\tif (tif->tif_dir.td_compression==COMPRESSION_OJPEG)\n\t{\n\t\tif (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Photometric tag is missing, assuming data is YCbCr\");\n\t\t\tif (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))\n\t\t\t\tgoto bad;\n\t\t}\n\t\telse if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)\n\t\t{\n\t\t\ttif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Photometric tag value assumed incorrect, \"\n\t\t\t    \"assuming data is YCbCr instead of RGB\");\n\t\t}\n\t\tif (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t    \"BitsPerSample tag is missing, assuming 8 bits per sample\");\n\t\t\tif (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))\n\t\t\t\tgoto bad;\n\t\t}\n\t\tif (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\n\t\t{\n\t\t\tif (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t    \"SamplesPerPixel tag is missing, \"\n\t\t\t\t    \"assuming correct SamplesPerPixel value is 3\");\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t    \"SamplesPerPixel tag is missing, \"\n\t\t\t\t    \"applying correct SamplesPerPixel value of 3\");\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\telse if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)\n\t\t\t\t || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * SamplesPerPixel tag is missing, but is not required\n\t\t\t\t * by spec.  Assume correct SamplesPerPixel value of 1.\n\t\t\t\t */\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Verify Palette image has a Colormap.\n\t */\n\tif (tif->tif_dir.td_photometric == PHOTOMETRIC_PALETTE &&\n\t    !TIFFFieldSet(tif, FIELD_COLORMAP)) {\n\t\tif ( tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3)\n\t\t\ttif->tif_dir.td_photometric = PHOTOMETRIC_RGB;\n\t\telse if (tif->tif_dir.td_bitspersample>=8)\n\t\t\ttif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;\n\t\telse {\n\t\t\tMissingRequired(tif, \"Colormap\");\n\t\t\tgoto bad;\n\t\t}\n\t}\n\t/*\n\t * OJPEG hack:\n\t * We do no further messing with strip/tile offsets/bytecounts in OJPEG\n\t * TIFFs\n\t */\n\tif (tif->tif_dir.td_compression!=COMPRESSION_OJPEG)\n\t{\n\t\t/*\n\t\t * Attempt to deal with a missing StripByteCounts tag.\n\t\t */\n\t\tif (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {\n\t\t\t/*\n\t\t\t * Some manufacturers violate the spec by not giving\n\t\t\t * the size of the strips.  In this case, assume there\n\t\t\t * is one uncompressed strip of data.\n\t\t\t */\n\t\t\tif ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&\n\t\t\t    tif->tif_dir.td_nstrips > 1) ||\n\t\t\t    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&\n\t\t\t     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {\n\t\t\t    MissingRequired(tif, \"StripByteCounts\");\n\t\t\t    goto bad;\n\t\t\t}\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"TIFF directory is missing required \"\n\t\t\t\t\"\\\"StripByteCounts\\\" field, calculating from imagelength\");\n\t\t\tif (EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n\t\t/*\n\t\t * Assume we have wrong StripByteCount value (in case\n\t\t * of single strip) in following cases:\n\t\t *   - it is equal to zero along with StripOffset;\n\t\t *   - it is larger than file itself (in case of uncompressed\n\t\t *     image);\n\t\t *   - it is smaller than the size of the bytes per row\n\t\t *     multiplied on the number of rows.  The last case should\n\t\t *     not be checked in the case of writing new image,\n\t\t *     because we may do not know the exact strip size\n\t\t *     until the whole image will be written and directory\n\t\t *     dumped out.\n\t\t */\n\t\t#define\tBYTECOUNTLOOKSBAD \\\n\t\t    ( (tif->tif_dir.td_stripbytecount[0] == 0 && tif->tif_dir.td_stripoffset[0] != 0) || \\\n\t\t      (tif->tif_dir.td_compression == COMPRESSION_NONE && \\\n\t\t       tif->tif_dir.td_stripbytecount[0] > TIFFGetFileSize(tif) - tif->tif_dir.td_stripoffset[0]) || \\\n\t\t      (tif->tif_mode == O_RDONLY && \\\n\t\t       tif->tif_dir.td_compression == COMPRESSION_NONE && \\\n\t\t       tif->tif_dir.td_stripbytecount[0] < TIFFScanlineSize64(tif) * tif->tif_dir.td_imagelength) )\n\n\t\t} else if (tif->tif_dir.td_nstrips == 1\n                           && _TIFFFillStriles(tif)\n\t\t\t   && tif->tif_dir.td_stripoffset[0] != 0\n\t\t\t   && BYTECOUNTLOOKSBAD) {\n\t\t\t/*\n\t\t\t * XXX: Plexus (and others) sometimes give a value of\n\t\t\t * zero for a tag when they don't know what the\n\t\t\t * correct value is!  Try and handle the simple case\n\t\t\t * of estimating the size of a one strip image.\n\t\t\t */\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Bogus \\\"StripByteCounts\\\" field, ignoring and calculating from imagelength\");\n\t\t\tif(EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n\n#if !defined(DEFER_STRILE_LOAD)\n\t\t} else if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG\n\t\t\t   && tif->tif_dir.td_nstrips > 2\n\t\t\t   && tif->tif_dir.td_compression == COMPRESSION_NONE\n\t\t\t   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]\n\t\t\t   && tif->tif_dir.td_stripbytecount[0] != 0\n\t\t\t   && tif->tif_dir.td_stripbytecount[1] != 0 ) {\n\t\t\t/*\n\t\t\t * XXX: Some vendors fill StripByteCount array with\n\t\t\t * absolutely wrong values (it can be equal to\n\t\t\t * StripOffset array, for example). Catch this case\n\t\t\t * here.\n                         *\n                         * We avoid this check if deferring strile loading\n                         * as it would always force us to load the strip/tile\n                         * information.\n\t\t\t */\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Wrong \\\"StripByteCounts\\\" field, ignoring and calculating from imagelength\");\n\t\t\tif (EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n#endif /* !defined(DEFER_STRILE_LOAD) */                        \n\t\t}\n\t}\n\tif (dir)\n\t{\n\t\t_TIFFfree(dir);\n\t\tdir=NULL;\n\t}\n\tif (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))\n\t{\n\t\tif (tif->tif_dir.td_bitspersample>=16)\n\t\t\ttif->tif_dir.td_maxsamplevalue=0xFFFF;\n\t\telse\n\t\t\ttif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1);\n\t}\n\t/*\n\t * XXX: We can optimize checking for the strip bounds using the sorted\n\t * bytecounts array. See also comments for TIFFAppendToStrip()\n\t * function in tif_write.c.\n\t */\n#if !defined(DEFER_STRILE_LOAD)        \n\tif (tif->tif_dir.td_nstrips > 1) {\n\t\tuint32 strip;\n\n\t\ttif->tif_dir.td_stripbytecountsorted = 1;\n\t\tfor (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {\n\t\t\tif (tif->tif_dir.td_stripoffset[strip - 1] >\n\t\t\t    tif->tif_dir.td_stripoffset[strip]) {\n\t\t\t\ttif->tif_dir.td_stripbytecountsorted = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif /* !defined(DEFER_STRILE_LOAD) */\n        \n\t/*\n\t * An opportunity for compression mode dependent tag fixup\n\t */\n\t(*tif->tif_fixuptags)(tif);\n\n\t/*\n\t * Some manufacturers make life difficult by writing\n\t * large amounts of uncompressed data as a single strip.\n\t * This is contrary to the recommendations of the spec.\n\t * The following makes an attempt at breaking such images\n\t * into strips closer to the recommended 8k bytes.  A\n\t * side effect, however, is that the RowsPerStrip tag\n\t * value may be changed.\n\t */\n\tif ((tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&\n\t    (tif->tif_dir.td_nstrips==1)&&\n\t    (tif->tif_dir.td_compression==COMPRESSION_NONE)&&  \n\t    ((tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP))\n    {\n        if ( !_TIFFFillStriles(tif) || !tif->tif_dir.td_stripbytecount )\n            return 0;\n\t\tChopUpSingleUncompressedStrip(tif);\n    }\n\n        /*\n         * Clear the dirty directory flag. \n         */\n\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\n\ttif->tif_flags &= ~TIFF_DIRTYSTRIP;\n\n\t/*\n\t * Reinitialize i/o since we are starting on a new directory.\n\t */\n\ttif->tif_row = (uint32) -1;\n\ttif->tif_curstrip = (uint32) -1;\n\ttif->tif_col = (uint32) -1;\n\ttif->tif_curtile = (uint32) -1;\n\ttif->tif_tilesize = (tmsize_t) -1;\n\n\ttif->tif_scanlinesize = TIFFScanlineSize(tif);\n\tif (!tif->tif_scanlinesize) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Cannot handle zero scanline size\");\n\t\treturn (0);\n\t}\n\n\tif (isTiled(tif)) {\n\t\ttif->tif_tilesize = TIFFTileSize(tif);\n\t\tif (!tif->tif_tilesize) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Cannot handle zero tile size\");\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\tif (!TIFFStripSize(tif)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Cannot handle zero strip size\");\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (1);\nbad:\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn (0);\n}",
        "begin_line": 3398,
        "end_line": 4093,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirectoryCheckOrder#4095",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirectoryCheckOrder(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)",
        "snippet": "static void\nTIFFReadDirectoryCheckOrder(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)\n{\n\tstatic const char module[] = \"TIFFReadDirectoryCheckOrder\";\n\tuint16 m;\n\tuint16 n;\n\tTIFFDirEntry* o;\n\tm=0;\n\tfor (n=0, o=dir; n<dircount; n++, o++)\n\t{\n\t\tif (o->tdir_tag<m)\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t    \"Invalid TIFF directory; tags are not sorted in ascending order\");\n\t\t\tbreak;\n\t\t}\n\t\tm=o->tdir_tag+1;\n\t}\n}",
        "begin_line": 4095,
        "end_line": 4113,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirectoryFindEntry#4115",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirectoryFindEntry(TIFF* tif, TIFFDirEntry* dir, uint16 dircount, uint16 tagid)",
        "snippet": "static TIFFDirEntry*\nTIFFReadDirectoryFindEntry(TIFF* tif, TIFFDirEntry* dir, uint16 dircount, uint16 tagid)\n{\n\tTIFFDirEntry* m;\n\tuint16 n;\n\t(void) tif;\n\tfor (m=dir, n=0; n<dircount; m++, n++)\n\t{\n\t\tif (m->tdir_tag==tagid)\n\t\t\treturn(m);\n\t}\n\treturn(0);\n}",
        "begin_line": 4115,
        "end_line": 4127,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirectoryFindFieldInfo#4129",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirectoryFindFieldInfo(TIFF* tif, uint16 tagid, uint32* fii)",
        "snippet": "static void\nTIFFReadDirectoryFindFieldInfo(TIFF* tif, uint16 tagid, uint32* fii)\n{\n\tint32 ma,mb,mc;\n\tma=-1;\n\tmc=(int32)tif->tif_nfields;\n\twhile (1)\n\t{\n\t\tif (ma+1==mc)\n\t\t{\n\t\t\t*fii = FAILED_FII;\n\t\t\treturn;\n\t\t}\n\t\tmb=(ma+mc)/2;\n\t\tif (tif->tif_fields[mb]->field_tag==(uint32)tagid)\n\t\t\tbreak;\n\t\tif (tif->tif_fields[mb]->field_tag<(uint32)tagid)\n\t\t\tma=mb;\n\t\telse\n\t\t\tmc=mb;\n\t}\n\twhile (1)\n\t{\n\t\tif (mb==0)\n\t\t\tbreak;\n\t\tif (tif->tif_fields[mb-1]->field_tag!=(uint32)tagid)\n\t\t\tbreak;\n\t\tmb--;\n\t}\n\t*fii=mb;\n}",
        "begin_line": 4129,
        "end_line": 4159,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadUInt64#183",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadUInt64(const uint8 *value)",
        "snippet": "static uint64 TIFFReadUInt64(const uint8 *value)\n{\n\tUInt64Aligned_t result;\n\n\tresult.c[0]=value[0];\n\tresult.c[1]=value[1];\n\tresult.c[2]=value[2];\n\tresult.c[3]=value[3];\n\tresult.c[4]=value[4];\n\tresult.c[5]=value[5];\n\tresult.c[6]=value[6];\n\tresult.c[7]=value[7];\n\n\treturn result.l;\n}",
        "begin_line": 183,
        "end_line": 197,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread._TIFFFillStriles#5584",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread._TIFFFillStriles( TIFF *tif )",
        "snippet": "int _TIFFFillStriles( TIFF *tif )\n{\n    return _TIFFFillStrilesInternal( tif, 1 );\n}",
        "begin_line": 5584,
        "end_line": 5587,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread._TIFFFillStrilesInternal#5589",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread._TIFFFillStrilesInternal( TIFF *tif, int loadStripByteCount )",
        "snippet": "static int _TIFFFillStrilesInternal( TIFF *tif, int loadStripByteCount )\n{\n#if defined(DEFER_STRILE_LOAD)\n        register TIFFDirectory *td = &tif->tif_dir;\n        int return_value = 1;\n\n        if( td->td_stripoffset != NULL )\n                return 1;\n\n        if( td->td_stripoffset_entry.tdir_count == 0 )\n                return 0;\n\n        if (!TIFFFetchStripThing(tif,&(td->td_stripoffset_entry),\n                                 td->td_nstrips,&td->td_stripoffset))\n        {\n                return_value = 0;\n        }\n\n        if (loadStripByteCount &&\n            !TIFFFetchStripThing(tif,&(td->td_stripbytecount_entry),\n                                 td->td_nstrips,&td->td_stripbytecount))\n        {\n                return_value = 0;\n        }\n\n        _TIFFmemset( &(td->td_stripoffset_entry), 0, sizeof(TIFFDirEntry));\n        _TIFFmemset( &(td->td_stripbytecount_entry), 0, sizeof(TIFFDirEntry));\n\n\tif (tif->tif_dir.td_nstrips > 1 && return_value == 1 ) {\n\t\tuint32 strip;\n\n\t\ttif->tif_dir.td_stripbytecountsorted = 1;\n\t\tfor (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {\n\t\t\tif (tif->tif_dir.td_stripoffset[strip - 1] >\n\t\t\t    tif->tif_dir.td_stripoffset[strip]) {\n\t\t\t\ttif->tif_dir.td_stripbytecountsorted = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n        return return_value;\n#else /* !defined(DEFER_STRILE_LOAD) */\n        (void) tif;\n        (void) loadStripByteCount;\n        return 1;\n#endif \n}",
        "begin_line": 5589,
        "end_line": 5636,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dumpmode.TIFFInitDumpMode#123",
        "src_path": "libtiff/tif_dumpmode.c",
        "class_name": "libtiff.tif_dumpmode",
        "signature": "libtiff.tif_dumpmode.TIFFInitDumpMode(TIFF* tif, int scheme)",
        "snippet": "int\nTIFFInitDumpMode(TIFF* tif, int scheme)\n{\n\t(void) scheme;\n\ttif->tif_fixuptags = DumpFixupTags;  \n\ttif->tif_decoderow = DumpModeDecode;\n\ttif->tif_decodestrip = DumpModeDecode;\n\ttif->tif_decodetile = DumpModeDecode;\n\ttif->tif_encoderow = DumpModeEncode;\n\ttif->tif_encodestrip = DumpModeEncode;\n\ttif->tif_encodetile = DumpModeEncode; \n\ttif->tif_seek = DumpModeSeek;\n\treturn (1);\n}",
        "begin_line": 123,
        "end_line": 136,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_error.TIFFErrorExt#62",
        "src_path": "libtiff/tif_error.c",
        "class_name": "libtiff.tif_error",
        "signature": "libtiff.tif_error.TIFFErrorExt(thandle_t fd, const char* module, const char* fmt, ...)",
        "snippet": "void\nTIFFErrorExt(thandle_t fd, const char* module, const char* fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tif (_TIFFerrorHandler)\n\t\t(*_TIFFerrorHandler)(module, fmt, ap);\n\tif (_TIFFerrorHandlerExt)\n\t\t(*_TIFFerrorHandlerExt)(fd, module, fmt, ap);\n\tva_end(ap);\n}",
        "begin_line": 62,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.JPEGCleanup#2070",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.JPEGCleanup(TIFF* tif)",
        "snippet": "static void\nJPEGCleanup(TIFF* tif)\n{\n\tJPEGState *sp = JState(tif);\n\t\n\tassert(sp != 0);\n\n\ttif->tif_tagmethods.vgetfield = sp->vgetparent;\n\ttif->tif_tagmethods.vsetfield = sp->vsetparent;\n\ttif->tif_tagmethods.printdir = sp->printdir;\n        if( sp->cinfo_initialized )\n                TIFFjpeg_destroy(sp);\t/* release libjpeg resources */\n        if (sp->jpegtables)\t\t/* tag value */\n                _TIFFfree(sp->jpegtables);\n\t_TIFFfree(tif->tif_data);\t/* release local state */\n\ttif->tif_data = NULL;\n\n\t_TIFFSetDefaultCompressionState(tif);\n}",
        "begin_line": 2070,
        "end_line": 2088,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.JPEGFixupTags#696",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.JPEGFixupTags(TIFF* tif)",
        "snippet": "static int\nJPEGFixupTags(TIFF* tif)\n{\n#ifdef CHECK_JPEG_YCBCR_SUBSAMPLING\n\tif ((tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)&&\n\t    (tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&\n\t    (tif->tif_dir.td_samplesperpixel==3))\n\t\tJPEGFixupTagsSubsampling(tif);\n#endif\n        \n\treturn(1);\n}",
        "begin_line": 696,
        "end_line": 707,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.JPEGResetUpsampled#2090",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.JPEGResetUpsampled( TIFF* tif )",
        "snippet": "static void \nJPEGResetUpsampled( TIFF* tif )\n{\n\tJPEGState* sp = JState(tif);\n\tTIFFDirectory* td = &tif->tif_dir;\n\n\t/*\n\t * Mark whether returned data is up-sampled or not so TIFFStripSize\n\t * and TIFFTileSize return values that reflect the true amount of\n\t * data.\n\t */\n\ttif->tif_flags &= ~TIFF_UPSAMPLED;\n\tif (td->td_planarconfig == PLANARCONFIG_CONTIG) {\n\t\tif (td->td_photometric == PHOTOMETRIC_YCBCR &&\n\t\t    sp->jpegcolormode == JPEGCOLORMODE_RGB) {\n\t\t\ttif->tif_flags |= TIFF_UPSAMPLED;\n\t\t} else {\n#ifdef notdef\n\t\t\tif (td->td_ycbcrsubsampling[0] != 1 ||\n\t\t\t    td->td_ycbcrsubsampling[1] != 1)\n\t\t\t\t; /* XXX what about up-sampling? */\n#endif\n\t\t}\n\t}\n\n\t/*\n\t * Must recalculate cached tile size in case sampling state changed.\n\t * Should we really be doing this now if image size isn't set? \n\t */\n        if( tif->tif_tilesize > 0 )\n            tif->tif_tilesize = isTiled(tif) ? TIFFTileSize(tif) : (tmsize_t)(-1);   \n        if( tif->tif_scanlinesize > 0 )\n            tif->tif_scanlinesize = TIFFScanlineSize(tif); \n}",
        "begin_line": 2090,
        "end_line": 2123,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.JPEGVGetField#2180",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.JPEGVGetField(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "static int\nJPEGVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tJPEGState* sp = JState(tif);\n\n\tassert(sp != NULL);\n\n\tswitch (tag) {\n\t\tcase TIFFTAG_JPEGTABLES:\n\t\t\t*va_arg(ap, uint32*) = sp->jpegtables_length;\n\t\t\t*va_arg(ap, void**) = sp->jpegtables;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGQUALITY:\n\t\t\t*va_arg(ap, int*) = sp->jpegquality;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGCOLORMODE:\n\t\t\t*va_arg(ap, int*) = sp->jpegcolormode;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGTABLESMODE:\n\t\t\t*va_arg(ap, int*) = sp->jpegtablesmode;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (*sp->vgetparent)(tif, tag, ap);\n\t}\n\treturn (1);\n}",
        "begin_line": 2180,
        "end_line": 2205,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.JPEGVSetField#2125",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.JPEGVSetField(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "static int\nJPEGVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tJPEGState* sp = JState(tif);\n\tconst TIFFField* fip;\n\tuint32 v32;\n\n\tassert(sp != NULL);\n\n\tswitch (tag) {\n\tcase TIFFTAG_JPEGTABLES:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 == 0) {\n\t\t\t/* XXX */\n\t\t\treturn (0);\n\t\t}\n\t\t_TIFFsetByteArray(&sp->jpegtables, va_arg(ap, void*), v32);\n\t\tsp->jpegtables_length = v32;\n\t\tTIFFSetFieldBit(tif, FIELD_JPEGTABLES);\n\t\tbreak;\n\tcase TIFFTAG_JPEGQUALITY:\n\t\tsp->jpegquality = (int) va_arg(ap, int);\n\t\treturn (1);\t\t\t/* pseudo tag */\n\tcase TIFFTAG_JPEGCOLORMODE:\n\t\tsp->jpegcolormode = (int) va_arg(ap, int);\n\t\tJPEGResetUpsampled( tif );\n\t\treturn (1);\t\t\t/* pseudo tag */\n\tcase TIFFTAG_PHOTOMETRIC:\n\t{\n\t\tint ret_value = (*sp->vsetparent)(tif, tag, ap);\n\t\tJPEGResetUpsampled( tif );\n\t\treturn ret_value;\n\t}\n\tcase TIFFTAG_JPEGTABLESMODE:\n\t\tsp->jpegtablesmode = (int) va_arg(ap, int);\n\t\treturn (1);\t\t\t/* pseudo tag */\n\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t/* mark the fact that we have a real ycbcrsubsampling! */\n\t\tsp->ycbcrsampling_fetched = 1;\n\t\t/* should we be recomputing upsampling info here? */\n\t\treturn (*sp->vsetparent)(tif, tag, ap);\n\tdefault:\n\t\treturn (*sp->vsetparent)(tif, tag, ap);\n\t}\n\n\tif ((fip = TIFFFieldWithTag(tif, tag)) != NULL) {\n\t\tTIFFSetFieldBit(tif, fip->field_bit);\n\t} else {\n\t\treturn (0);\n\t}\n\n\ttif->tif_flags |= TIFF_DIRTYDIRECT;\n\treturn (1);\n}",
        "begin_line": 2125,
        "end_line": 2178,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_jpeg.TIFFInitJPEG#2301",
        "src_path": "libtiff/tif_jpeg.c",
        "class_name": "libtiff.tif_jpeg",
        "signature": "libtiff.tif_jpeg.TIFFInitJPEG(TIFF* tif, int scheme)",
        "snippet": "int\nTIFFInitJPEG(TIFF* tif, int scheme)\n{\n\tJPEGState* sp;\n\n\tassert(scheme == COMPRESSION_JPEG);\n\n\t/*\n\t * Merge codec-specific tag information.\n\t */\n\tif (!_TIFFMergeFields(tif, jpegFields, TIFFArrayCount(jpegFields))) {\n\t\tTIFFErrorExt(tif->tif_clientdata,\n\t\t\t     \"TIFFInitJPEG\",\n\t\t\t     \"Merging JPEG codec-specific tags failed\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Allocate state block so tag methods have storage to record values.\n\t */\n\ttif->tif_data = (uint8*) _TIFFmalloc(sizeof (JPEGState));\n\n\tif (tif->tif_data == NULL) {\n\t\tTIFFErrorExt(tif->tif_clientdata,\n\t\t\t     \"TIFFInitJPEG\", \"No space for JPEG state block\");\n\t\treturn 0;\n\t}\n        _TIFFmemset(tif->tif_data, 0, sizeof(JPEGState));\n\n\tsp = JState(tif);\n\tsp->tif = tif;\t\t\t\t/* back link */\n\n\t/*\n\t * Override parent get/set field methods.\n\t */\n\tsp->vgetparent = tif->tif_tagmethods.vgetfield;\n\ttif->tif_tagmethods.vgetfield = JPEGVGetField; /* hook for codec tags */\n\tsp->vsetparent = tif->tif_tagmethods.vsetfield;\n\ttif->tif_tagmethods.vsetfield = JPEGVSetField; /* hook for codec tags */\n\tsp->printdir = tif->tif_tagmethods.printdir;\n\ttif->tif_tagmethods.printdir = JPEGPrintDir;   /* hook for codec tags */\n\n\t/* Default values for codec-specific fields */\n\tsp->jpegtables = NULL;\n\tsp->jpegtables_length = 0;\n\tsp->jpegquality = 75;\t\t\t/* Default IJG quality */\n\tsp->jpegcolormode = JPEGCOLORMODE_RAW;\n\tsp->jpegtablesmode = JPEGTABLESMODE_QUANT | JPEGTABLESMODE_HUFF;\n        sp->ycbcrsampling_fetched = 0;\n\n\t/*\n\t * Install codec methods.\n\t */\n\ttif->tif_fixuptags = JPEGFixupTags;\n\ttif->tif_setupdecode = JPEGSetupDecode;\n\ttif->tif_predecode = JPEGPreDecode;\n\ttif->tif_decoderow = JPEGDecode;\n\ttif->tif_decodestrip = JPEGDecode;\n\ttif->tif_decodetile = JPEGDecode;\n\ttif->tif_setupencode = JPEGSetupEncode;\n\ttif->tif_preencode = JPEGPreEncode;\n\ttif->tif_postencode = JPEGPostEncode;\n\ttif->tif_encoderow = JPEGEncode;\n\ttif->tif_encodestrip = JPEGEncode;\n\ttif->tif_encodetile = JPEGEncode;  \n\ttif->tif_cleanup = JPEGCleanup;\n\tsp->defsparent = tif->tif_defstripsize;\n\ttif->tif_defstripsize = JPEGDefaultStripSize;\n\tsp->deftparent = tif->tif_deftilesize;\n\ttif->tif_deftilesize = JPEGDefaultTileSize;\n\ttif->tif_flags |= TIFF_NOBITREV;\t/* no bit reversal, please */\n\n        sp->cinfo_initialized = FALSE;\n\n\t/*\n        ** Create a JPEGTables field if no directory has yet been created. \n        ** We do this just to ensure that sufficient space is reserved for\n        ** the JPEGTables field.  It will be properly created the right\n        ** size later. \n        */\n        if( tif->tif_diroff == 0 )\n        {\n#define SIZE_OF_JPEGTABLES 2000\n/*\nThe following line assumes incorrectly that all JPEG-in-TIFF files will have\na JPEGTABLES tag generated and causes null-filled JPEGTABLES tags to be written\nwhen the JPEG data is placed with TIFFWriteRawStrip.  The field bit should be \nset, anyway, later when actual JPEGTABLES header is generated, so removing it \nhere hopefully is harmless.\n            TIFFSetFieldBit(tif, FIELD_JPEGTABLES);\n*/\n            sp->jpegtables_length = SIZE_OF_JPEGTABLES;\n            sp->jpegtables = (void *) _TIFFmalloc(sp->jpegtables_length);\n            if (sp->jpegtables)\n            {\n                _TIFFmemset(sp->jpegtables, 0, SIZE_OF_JPEGTABLES);\n            }\n            else\n            {\n                TIFFErrorExt(tif->tif_clientdata,\n\t\t\t     \"TIFFInitJPEG\",\n                             \"Failed to allocate memory for JPEG tables\");\n                return 0;\n            }\n#undef SIZE_OF_JPEGTABLES\n        }\n\n\treturn 1;\n}",
        "begin_line": 2301,
        "end_line": 2409,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_open.TIFFClientOpen#72",
        "src_path": "libtiff/tif_open.c",
        "class_name": "libtiff.tif_open",
        "signature": "libtiff.tif_open.TIFFClientOpen( \tconst char* name, const char* mode, thandle_t clientdata, TIFFReadWriteProc readproc, TIFFReadWriteProc writeproc, TIFFSeekProc seekproc, TIFFCloseProc closeproc, TIFFSizeProc sizeproc, TIFFMapFileProc mapproc, TIFFUnmapFileProc unmapproc )",
        "snippet": "TIFF*\nTIFFClientOpen(\n\tconst char* name, const char* mode,\n\tthandle_t clientdata,\n\tTIFFReadWriteProc readproc,\n\tTIFFReadWriteProc writeproc,\n\tTIFFSeekProc seekproc,\n\tTIFFCloseProc closeproc,\n\tTIFFSizeProc sizeproc,\n\tTIFFMapFileProc mapproc,\n\tTIFFUnmapFileProc unmapproc\n)\n{\n\tstatic const char module[] = \"TIFFClientOpen\";\n\tTIFF *tif;\n\tint m;\n\tconst char* cp;\n\n\t/* The following are configuration checks. They should be redundant, but should not\n\t * compile to any actual code in an optimised release build anyway. If any of them\n\t * fail, (makefile-based or other) configuration is not correct */\n\tassert(sizeof(uint8)==1);\n\tassert(sizeof(int8)==1);\n\tassert(sizeof(uint16)==2);\n\tassert(sizeof(int16)==2);\n\tassert(sizeof(uint32)==4);\n\tassert(sizeof(int32)==4);\n\tassert(sizeof(uint64)==8);\n\tassert(sizeof(int64)==8);\n\tassert(sizeof(tmsize_t)==sizeof(void*));\n\t{\n\t\tunion{\n\t\t\tuint8 a8[2];\n\t\t\tuint16 a16;\n\t\t} n;\n\t\tn.a8[0]=1;\n\t\tn.a8[1]=0;\n\t\t#ifdef WORDS_BIGENDIAN\n\t\tassert(n.a16==256);\n\t\t#else\n\t\tassert(n.a16==1);\n\t\t#endif\n\t}\n\n\tm = _TIFFgetMode(mode, module);\n\tif (m == -1)\n\t\tgoto bad2;\n\ttif = (TIFF *)_TIFFmalloc((tmsize_t)(sizeof (TIFF) + strlen(name) + 1));\n\tif (tif == NULL) {\n\t\tTIFFErrorExt(clientdata, module, \"%s: Out of memory (TIFF structure)\", name);\n\t\tgoto bad2;\n\t}\n\t_TIFFmemset(tif, 0, sizeof (*tif));\n\ttif->tif_name = (char *)tif + sizeof (TIFF);\n\tstrcpy(tif->tif_name, name);\n\ttif->tif_mode = m &~ (O_CREAT|O_TRUNC);\n\ttif->tif_curdir = (uint16) -1;\t\t/* non-existent directory */\n\ttif->tif_curoff = 0;\n\ttif->tif_curstrip = (uint32) -1;\t/* invalid strip */\n\ttif->tif_row = (uint32) -1;\t\t/* read/write pre-increment */\n\ttif->tif_clientdata = clientdata;\n\tif (!readproc || !writeproc || !seekproc || !closeproc || !sizeproc) {\n\t\tTIFFErrorExt(clientdata, module,\n\t\t    \"One of the client procedures is NULL pointer.\");\n\t\tgoto bad2;\n\t}\n\ttif->tif_readproc = readproc;\n\ttif->tif_writeproc = writeproc;\n\ttif->tif_seekproc = seekproc;\n\ttif->tif_closeproc = closeproc;\n\ttif->tif_sizeproc = sizeproc;\n\tif (mapproc)\n\t\ttif->tif_mapproc = mapproc;\n\telse\n\t\ttif->tif_mapproc = _tiffDummyMapProc;\n\tif (unmapproc)\n\t\ttif->tif_unmapproc = unmapproc;\n\telse\n\t\ttif->tif_unmapproc = _tiffDummyUnmapProc;\n\t_TIFFSetDefaultCompressionState(tif);    /* setup default state */\n\t/*\n\t * Default is to return data MSB2LSB and enable the\n\t * use of memory-mapped files and strip chopping when\n\t * a file is opened read-only.\n\t */\n\ttif->tif_flags = FILLORDER_MSB2LSB;\n\tif (m == O_RDONLY )\n\t\ttif->tif_flags |= TIFF_MAPPED;\n\n\t#ifdef STRIPCHOP_DEFAULT\n\tif (m == O_RDONLY || m == O_RDWR)\n\t\ttif->tif_flags |= STRIPCHOP_DEFAULT;\n\t#endif\n\n\t/*\n\t * Process library-specific flags in the open mode string.\n\t * The following flags may be used to control intrinsic library\n\t * behaviour that may or may not be desirable (usually for\n\t * compatibility with some application that claims to support\n\t * TIFF but only supports some brain dead idea of what the\n\t * vendor thinks TIFF is):\n\t *\n\t * 'l' use little-endian byte order for creating a file\n\t * 'b' use big-endian byte order for creating a file\n\t * 'L' read/write information using LSB2MSB bit order\n\t * 'B' read/write information using MSB2LSB bit order\n\t * 'H' read/write information using host bit order\n\t * 'M' enable use of memory-mapped files when supported\n\t * 'm' disable use of memory-mapped files\n\t * 'C' enable strip chopping support when reading\n\t * 'c' disable strip chopping support\n\t * 'h' read TIFF header only, do not load the first IFD\n\t * '4' ClassicTIFF for creating a file (default)\n\t * '8' BigTIFF for creating a file\n\t *\n\t * The use of the 'l' and 'b' flags is strongly discouraged.\n\t * These flags are provided solely because numerous vendors,\n\t * typically on the PC, do not correctly support TIFF; they\n\t * only support the Intel little-endian byte order.  This\n\t * support is not configured by default because it supports\n\t * the violation of the TIFF spec that says that readers *MUST*\n\t * support both byte orders.  It is strongly recommended that\n\t * you not use this feature except to deal with busted apps\n\t * that write invalid TIFF.  And even in those cases you should\n\t * bang on the vendors to fix their software.\n\t *\n\t * The 'L', 'B', and 'H' flags are intended for applications\n\t * that can optimize operations on data by using a particular\n\t * bit order.  By default the library returns data in MSB2LSB\n\t * bit order for compatibility with older versions of this\n\t * library.  Returning data in the bit order of the native CPU\n\t * makes the most sense but also requires applications to check\n\t * the value of the FillOrder tag; something they probably do\n\t * not do right now.\n\t *\n\t * The 'M' and 'm' flags are provided because some virtual memory\n\t * systems exhibit poor behaviour when large images are mapped.\n\t * These options permit clients to control the use of memory-mapped\n\t * files on a per-file basis.\n\t *\n\t * The 'C' and 'c' flags are provided because the library support\n\t * for chopping up large strips into multiple smaller strips is not\n\t * application-transparent and as such can cause problems.  The 'c'\n\t * option permits applications that only want to look at the tags,\n\t * for example, to get the unadulterated TIFF tag information.\n\t */\n\tfor (cp = mode; *cp; cp++)\n\t\tswitch (*cp) {\n\t\t\tcase 'b':\n\t\t\t\t#ifndef WORDS_BIGENDIAN\n\t\t\t\tif (m&O_CREAT)\n\t\t\t\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t\t\t#endif\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\t#ifdef WORDS_BIGENDIAN\n\t\t\t\tif ((m&O_CREAT))\n\t\t\t\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t\t\t#endif\n\t\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\t\ttif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |\n\t\t\t\t    FILLORDER_MSB2LSB;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\ttif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |\n\t\t\t\t    FILLORDER_LSB2MSB;\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\ttif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |\n\t\t\t\t    HOST_FILLORDER;\n\t\t\t\tbreak;\n\t\t\tcase 'M':\n\t\t\t\tif (m == O_RDONLY)\n\t\t\t\t\ttif->tif_flags |= TIFF_MAPPED;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tif (m == O_RDONLY)\n\t\t\t\t\ttif->tif_flags &= ~TIFF_MAPPED;\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tif (m == O_RDONLY)\n\t\t\t\t\ttif->tif_flags |= TIFF_STRIPCHOP;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tif (m == O_RDONLY)\n\t\t\t\t\ttif->tif_flags &= ~TIFF_STRIPCHOP;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\t\ttif->tif_flags |= TIFF_HEADERONLY;\n\t\t\t\tbreak;\n\t\t\tcase '8':\n\t\t\t\tif (m&O_CREAT)\n\t\t\t\t\ttif->tif_flags |= TIFF_BIGTIFF;\n\t\t\t\tbreak;\n\t\t}\n\t/*\n\t * Read in TIFF header.\n\t */\n\tif ((m & O_TRUNC) ||\n\t    !ReadOK(tif, &tif->tif_header, sizeof (TIFFHeaderClassic))) {\n\t\tif (tif->tif_mode == O_RDONLY) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t\t    \"Cannot read TIFF header\");\n\t\t\tgoto bad;\n\t\t}\n\t\t/*\n\t\t * Setup header and write.\n\t\t */\n\t\t#ifdef WORDS_BIGENDIAN\n\t\ttif->tif_header.common.tiff_magic = (tif->tif_flags & TIFF_SWAB)\n\t\t    ? TIFF_LITTLEENDIAN : TIFF_BIGENDIAN;\n\t\t#else\n\t\ttif->tif_header.common.tiff_magic = (tif->tif_flags & TIFF_SWAB)\n\t\t    ? TIFF_BIGENDIAN : TIFF_LITTLEENDIAN;\n\t\t#endif\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\ttif->tif_header.common.tiff_version = TIFF_VERSION_CLASSIC;\n\t\t\ttif->tif_header.classic.tiff_diroff = 0;\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&tif->tif_header.common.tiff_version);\n\t\t\ttif->tif_header_size = sizeof(TIFFHeaderClassic);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttif->tif_header.common.tiff_version = TIFF_VERSION_BIG;\n\t\t\ttif->tif_header.big.tiff_offsetsize = 8;\n\t\t\ttif->tif_header.big.tiff_unused = 0;\n\t\t\ttif->tif_header.big.tiff_diroff = 0;\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t{\n\t\t\t\tTIFFSwabShort(&tif->tif_header.common.tiff_version);\n\t\t\t\tTIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);\n\t\t\t}\n\t\t\ttif->tif_header_size = sizeof (TIFFHeaderBig);\n\t\t}\n\t\t/*\n\t\t * The doc for \"fopen\" for some STD_C_LIBs says that if you\n\t\t * open a file for modify (\"+\"), then you must fseek (or\n\t\t * fflush?) between any freads and fwrites.  This is not\n\t\t * necessary on most systems, but has been shown to be needed\n\t\t * on Solaris.\n\t\t */\n\t\tTIFFSeekFile( tif, 0, SEEK_SET );\n\t\tif (!WriteOK(tif, &tif->tif_header, (tmsize_t)(tif->tif_header_size))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t\t    \"Error writing TIFF header\");\n\t\t\tgoto bad;\n\t\t}\n\t\t/*\n\t\t * Setup the byte order handling.\n\t\t */\n\t\tif (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN) {\n\t\t\t#ifndef WORDS_BIGENDIAN\n\t\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t\t#endif\n\t\t} else {\n\t\t\t#ifdef WORDS_BIGENDIAN\n\t\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t\t#endif\n\t\t}\n\t\t/*\n\t\t * Setup default directory.\n\t\t */\n\t\tif (!TIFFDefaultDirectory(tif))\n\t\t\tgoto bad;\n\t\ttif->tif_diroff = 0;\n\t\ttif->tif_dirlist = NULL;\n\t\ttif->tif_dirlistsize = 0;\n\t\ttif->tif_dirnumber = 0;\n\t\treturn (tif);\n\t}\n\t/*\n\t * Setup the byte order handling.\n\t */\n\tif (tif->tif_header.common.tiff_magic != TIFF_BIGENDIAN &&\n\t    tif->tif_header.common.tiff_magic != TIFF_LITTLEENDIAN\n\t    #if MDI_SUPPORT\n\t    &&\n\t    #if HOST_BIGENDIAN\n\t    tif->tif_header.common.tiff_magic != MDI_BIGENDIAN\n\t    #else\n\t    tif->tif_header.common.tiff_magic != MDI_LITTLEENDIAN\n\t    #endif\n\t    ) {\n\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t    \"Not a TIFF or MDI file, bad magic number %d (0x%x)\",\n\t    #else\n\t    ) {\n\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t    \"Not a TIFF file, bad magic number %d (0x%x)\",\n\t    #endif\n\t\t    tif->tif_header.common.tiff_magic,\n\t\t    tif->tif_header.common.tiff_magic);\n\t\tgoto bad;\n\t}\n\tif (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN) {\n\t\t#ifndef WORDS_BIGENDIAN\n\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t#endif\n\t} else {\n\t\t#ifdef WORDS_BIGENDIAN\n\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t#endif\n\t}\n\tif (tif->tif_flags & TIFF_SWAB) \n\t\tTIFFSwabShort(&tif->tif_header.common.tiff_version);\n\tif ((tif->tif_header.common.tiff_version != TIFF_VERSION_CLASSIC)&&\n\t    (tif->tif_header.common.tiff_version != TIFF_VERSION_BIG)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t    \"Not a TIFF file, bad version number %d (0x%x)\",\n\t\t    tif->tif_header.common.tiff_version,\n\t\t    tif->tif_header.common.tiff_version);\n\t\tgoto bad;\n\t}\n\tif (tif->tif_header.common.tiff_version == TIFF_VERSION_CLASSIC)\n\t{\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabLong(&tif->tif_header.classic.tiff_diroff);\n\t\ttif->tif_header_size = sizeof(TIFFHeaderClassic);\n\t}\n\telse\n\t{\n\t\tif (!ReadOK(tif, ((uint8*)(&tif->tif_header) + sizeof(TIFFHeaderClassic)), (sizeof(TIFFHeaderBig)-sizeof(TIFFHeaderClassic))))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t\t    \"Cannot read TIFF header\");\n\t\t\tgoto bad;\n\t\t}\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t{\n\t\t\tTIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);\n\t\t\tTIFFSwabLong8(&tif->tif_header.big.tiff_diroff);\n\t\t}\n\t\tif (tif->tif_header.big.tiff_offsetsize != 8)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t\t    \"Not a TIFF file, bad BigTIFF offsetsize %d (0x%x)\",\n\t\t\t    tif->tif_header.big.tiff_offsetsize,\n\t\t\t    tif->tif_header.big.tiff_offsetsize);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (tif->tif_header.big.tiff_unused != 0)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t\t    \"Not a TIFF file, bad BigTIFF unused %d (0x%x)\",\n\t\t\t    tif->tif_header.big.tiff_unused,\n\t\t\t    tif->tif_header.big.tiff_unused);\n\t\t\tgoto bad;\n\t\t}\n\t\ttif->tif_header_size = sizeof(TIFFHeaderBig);\n\t\ttif->tif_flags |= TIFF_BIGTIFF;\n\t}\n\ttif->tif_flags |= TIFF_MYBUFFER;\n\ttif->tif_rawcp = tif->tif_rawdata = 0;\n\ttif->tif_rawdatasize = 0;\n        tif->tif_rawdataoff = 0;\n        tif->tif_rawdataloaded = 0;\n\n\tswitch (mode[0]) {\n\t\tcase 'r':\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t\ttif->tif_nextdiroff = tif->tif_header.classic.tiff_diroff;\n\t\t\telse\n\t\t\t\ttif->tif_nextdiroff = tif->tif_header.big.tiff_diroff;\n\t\t\t/*\n\t\t\t * Try to use a memory-mapped file if the client\n\t\t\t * has not explicitly suppressed usage with the\n\t\t\t * 'm' flag in the open mode (see above).\n\t\t\t */\n\t\t\tif (tif->tif_flags & TIFF_MAPPED)\n\t\t\t{\n\t\t\t\ttoff_t n;\n\t\t\t\tif (TIFFMapFileContents(tif,(void**)(&tif->tif_base),&n))\n\t\t\t\t{\n\t\t\t\t\ttif->tif_size=(tmsize_t)n;\n\t\t\t\t\tassert((toff_t)tif->tif_size==n);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\ttif->tif_flags &= ~TIFF_MAPPED;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Sometimes we do not want to read the first directory (for example,\n\t\t\t * it may be broken) and want to proceed to other directories. I this\n\t\t\t * case we use the TIFF_HEADERONLY flag to open file and return\n\t\t\t * immediately after reading TIFF header.\n\t\t\t */\n\t\t\tif (tif->tif_flags & TIFF_HEADERONLY)\n\t\t\t\treturn (tif);\n\n\t\t\t/*\n\t\t\t * Setup initial directory.\n\t\t\t */\n\t\t\tif (TIFFReadDirectory(tif)) {\n\t\t\t\ttif->tif_rawcc = (tmsize_t)-1;\n\t\t\t\ttif->tif_flags |= TIFF_BUFFERSETUP;\n\t\t\t\treturn (tif);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\t/*\n\t\t\t * New directories are automatically append\n\t\t\t * to the end of the directory chain when they\n\t\t\t * are written out (see TIFFWriteDirectory).\n\t\t\t */\n\t\t\tif (!TIFFDefaultDirectory(tif))\n\t\t\t\tgoto bad;\n\t\t\treturn (tif);\n\t}\nbad:\n\ttif->tif_mode = O_RDONLY;\t/* XXX avoid flush */\n        TIFFCleanup(tif);\nbad2:\n\treturn ((TIFF*)0);\n}",
        "begin_line": 72,
        "end_line": 487,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_open.TIFFClientdata#536",
        "src_path": "libtiff/tif_open.c",
        "class_name": "libtiff.tif_open",
        "signature": "libtiff.tif_open.TIFFClientdata(TIFF* tif)",
        "snippet": "thandle_t\nTIFFClientdata(TIFF* tif)\n{\n\treturn (tif->tif_clientdata);\n}",
        "begin_line": 536,
        "end_line": 540,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_open.TIFFGetSeekProc#676",
        "src_path": "libtiff/tif_open.c",
        "class_name": "libtiff.tif_open",
        "signature": "libtiff.tif_open.TIFFGetSeekProc(TIFF* tif)",
        "snippet": "TIFFSeekProc\nTIFFGetSeekProc(TIFF* tif)\n{\n\treturn (tif->tif_seekproc);\n}",
        "begin_line": 676,
        "end_line": 680,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_open.TIFFGetWriteProc#667",
        "src_path": "libtiff/tif_open.c",
        "class_name": "libtiff.tif_open",
        "signature": "libtiff.tif_open.TIFFGetWriteProc(TIFF* tif)",
        "snippet": "TIFFReadWriteProc\nTIFFGetWriteProc(TIFF* tif)\n{\n\treturn (tif->tif_writeproc);\n}",
        "begin_line": 667,
        "end_line": 671,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_open.TIFFIsTiled#577",
        "src_path": "libtiff/tif_open.c",
        "class_name": "libtiff.tif_open",
        "signature": "libtiff.tif_open.TIFFIsTiled(TIFF* tif)",
        "snippet": "int\nTIFFIsTiled(TIFF* tif)\n{\n\treturn (isTiled(tif));\n}",
        "begin_line": 577,
        "end_line": 581,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_open._TIFFgetMode#48",
        "src_path": "libtiff/tif_open.c",
        "class_name": "libtiff.tif_open",
        "signature": "libtiff.tif_open._TIFFgetMode(const char* mode, const char* module)",
        "snippet": "int\n_TIFFgetMode(const char* mode, const char* module)\n{\n\tint m = -1;\n\n\tswitch (mode[0]) {\n\tcase 'r':\n\t\tm = O_RDONLY;\n\t\tif (mode[1] == '+')\n\t\t\tm = O_RDWR;\n\t\tbreak;\n\tcase 'w':\n\tcase 'a':\n\t\tm = O_RDWR|O_CREAT;\n\t\tif (mode[0] == 'w')\n\t\t\tm |= O_TRUNC;\n\t\tbreak;\n\tdefault:\n\t\tTIFFErrorExt(0, module, \"\\\"%s\\\": Bad mode\", mode);\n\t\tbreak;\n\t}\n\treturn (m);\n}",
        "begin_line": 48,
        "end_line": 70,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip.TIFFScanlineSize#330",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip.TIFFScanlineSize(TIFF* tif)",
        "snippet": "tmsize_t\nTIFFScanlineSize(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFScanlineSize\";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFScanlineSize64(tif);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m) {\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer arithmetic overflow\");\n\t\tn=0;\n\t}\n\treturn(n);\n}",
        "begin_line": 330,
        "end_line": 343,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip.TIFFScanlineSize64#273",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip.TIFFScanlineSize64(TIFF* tif)",
        "snippet": "uint64\nTIFFScanlineSize64(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFScanlineSize64\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint64 scanline_size;\n\tif (td->td_planarconfig==PLANARCONFIG_CONTIG)\n\t{\n\t\tif ((td->td_photometric==PHOTOMETRIC_YCBCR)&&\n\t\t    (td->td_samplesperpixel==3)&&\n\t\t    (!isUpSampled(tif)))\n\t\t{\n\t\t\tuint16 ycbcrsubsampling[2];\n\t\t\tuint16 samplingblock_samples;\n\t\t\tuint32 samplingblocks_hor;\n\t\t\tuint64 samplingrow_samples;\n\t\t\tuint64 samplingrow_size;\n\t\t\tif(td->td_samplesperpixel!=3)\n\t\t\t{\n                            TIFFErrorExt(tif->tif_clientdata,module,\n                                         \"Invalid td_samplesperpixel value\");\n                            return 0;\n\t\t\t}\n\t\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_YCBCRSUBSAMPLING,\n                                              ycbcrsubsampling+0,\n                                              ycbcrsubsampling+1);\n\t\t\tif (((ycbcrsubsampling[0]!=1)&&(ycbcrsubsampling[0]!=2)&&(ycbcrsubsampling[0]!=4)) ||\n\t\t\t    ((ycbcrsubsampling[1]!=1)&&(ycbcrsubsampling[1]!=2)&&(ycbcrsubsampling[1]!=4)))\n\t\t\t{\n                            TIFFErrorExt(tif->tif_clientdata,module,\n                                         \"Invalid YCbCr subsampling\");\n                            return 0;\n\t\t\t}\n\t\t\tsamplingblock_samples = ycbcrsubsampling[0]*ycbcrsubsampling[1]+2;\n\t\t\tsamplingblocks_hor = TIFFhowmany_32(td->td_imagewidth,ycbcrsubsampling[0]);\n\t\t\tsamplingrow_samples = _TIFFMultiply64(tif,samplingblocks_hor,samplingblock_samples,module);\n\t\t\tsamplingrow_size = TIFFhowmany_64(_TIFFMultiply64(tif,samplingrow_samples,td->td_bitspersample,module),8);\n\t\t\tscanline_size = (samplingrow_size/ycbcrsubsampling[1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint64 scanline_samples;\n\t\t\tscanline_samples=_TIFFMultiply64(tif,td->td_imagewidth,td->td_samplesperpixel,module);\n\t\t\tscanline_size=TIFFhowmany_64(_TIFFMultiply64(tif,scanline_samples,td->td_bitspersample,module),8);\n\t\t}\n\t}\n\telse\n        {\n\t\tscanline_size=TIFFhowmany_64(_TIFFMultiply64(tif,td->td_imagewidth,td->td_bitspersample,module),8);\n        }\n        if (scanline_size == 0)\n        {\n                TIFFErrorExt(tif->tif_clientdata,module,\"Computed scanline size is zero\");\n                return 0;\n        }\n\treturn(scanline_size);\n}",
        "begin_line": 273,
        "end_line": 329,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_tile.TIFFNumberOfTiles#114",
        "src_path": "libtiff/tif_tile.c",
        "class_name": "libtiff.tif_tile",
        "signature": "libtiff.tif_tile.TIFFNumberOfTiles(TIFF* tif)",
        "snippet": "uint32\nTIFFNumberOfTiles(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 dx = td->td_tilewidth;\n\tuint32 dy = td->td_tilelength;\n\tuint32 dz = td->td_tiledepth;\n\tuint32 ntiles;\n\n\tif (dx == (uint32) -1)\n\t\tdx = td->td_imagewidth;\n\tif (dy == (uint32) -1)\n\t\tdy = td->td_imagelength;\n\tif (dz == (uint32) -1)\n\t\tdz = td->td_imagedepth;\n\tntiles = (dx == 0 || dy == 0 || dz == 0) ? 0 :\n\t    _TIFFMultiply32(tif, _TIFFMultiply32(tif, TIFFhowmany_32(td->td_imagewidth, dx),\n\t    TIFFhowmany_32(td->td_imagelength, dy),\n\t    \"TIFFNumberOfTiles\"),\n\t    TIFFhowmany_32(td->td_imagedepth, dz), \"TIFFNumberOfTiles\");\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\tntiles = _TIFFMultiply32(tif, ntiles, td->td_samplesperpixel,\n\t\t    \"TIFFNumberOfTiles\");\n\treturn (ntiles);\n}",
        "begin_line": 114,
        "end_line": 138,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_tile.TIFFTileRowSize64#143",
        "src_path": "libtiff/tif_tile.c",
        "class_name": "libtiff.tif_tile",
        "signature": "libtiff.tif_tile.TIFFTileRowSize64(TIFF* tif)",
        "snippet": "uint64\nTIFFTileRowSize64(TIFF* tif)\n{\n        static const char module[] = \"TIFFTileRowSize64\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint64 rowsize;\n\tuint64 tilerowsize;\n\n\tif (td->td_tilelength == 0)\n        {\n                TIFFErrorExt(tif->tif_clientdata,module,\"Tile length is zero\");\n                return 0;\n        }\n        if (td->td_tilewidth == 0)\n        {\n                TIFFErrorExt(tif->tif_clientdata,module,\"Tile width is zero\");\n\t\treturn (0);\n        }\n\trowsize = _TIFFMultiply64(tif, td->td_bitspersample, td->td_tilewidth,\n\t    \"TIFFTileRowSize\");\n\tif (td->td_planarconfig == PLANARCONFIG_CONTIG)\n        {\n                if (td->td_samplesperpixel == 0)\n                {\n                        TIFFErrorExt(tif->tif_clientdata,module,\"Samples per pixel is zero\");\n                        return 0;\n                }\n\t\trowsize = _TIFFMultiply64(tif, rowsize, td->td_samplesperpixel,\n\t\t    \"TIFFTileRowSize\");\n        }\n        tilerowsize=TIFFhowmany8_64(rowsize);\n        if (tilerowsize == 0)\n        {\n                TIFFErrorExt(tif->tif_clientdata,module,\"Computed tile row size is zero\");\n                return 0;\n        }\n\treturn (tilerowsize);\n}",
        "begin_line": 143,
        "end_line": 180,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_tile.TIFFTileSize#272",
        "src_path": "libtiff/tif_tile.c",
        "class_name": "libtiff.tif_tile",
        "signature": "libtiff.tif_tile.TIFFTileSize(TIFF* tif)",
        "snippet": "tmsize_t\nTIFFTileSize(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFTileSize\";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFTileSize64(tif);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\n\t\tn=0;\n\t}\n\treturn(n);\n}",
        "begin_line": 272,
        "end_line": 286,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_tile.TIFFTileSize64#267",
        "src_path": "libtiff/tif_tile.c",
        "class_name": "libtiff.tif_tile",
        "signature": "libtiff.tif_tile.TIFFTileSize64(TIFF* tif)",
        "snippet": "uint64\nTIFFTileSize64(TIFF* tif)\n{\n\treturn (TIFFVTileSize64(tif, tif->tif_dir.td_tilelength));\n}",
        "begin_line": 267,
        "end_line": 271,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_tile.TIFFVTileSize64#200",
        "src_path": "libtiff/tif_tile.c",
        "class_name": "libtiff.tif_tile",
        "signature": "libtiff.tif_tile.TIFFVTileSize64(TIFF* tif, uint32 nrows)",
        "snippet": "uint64\nTIFFVTileSize64(TIFF* tif, uint32 nrows)\n{\n\tstatic const char module[] = \"TIFFVTileSize64\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tif (td->td_tilelength == 0 || td->td_tilewidth == 0 ||\n\t    td->td_tiledepth == 0)\n\t\treturn (0);\n\tif ((td->td_planarconfig==PLANARCONFIG_CONTIG)&&\n\t    (td->td_photometric==PHOTOMETRIC_YCBCR)&&\n\t    (td->td_samplesperpixel==3)&&\n\t    (!isUpSampled(tif)))\n\t{\n\t\t/*\n\t\t * Packed YCbCr data contain one Cb+Cr for every\n\t\t * HorizontalSampling*VerticalSampling Y values.\n\t\t * Must also roundup width and height when calculating\n\t\t * since images that are not a multiple of the\n\t\t * horizontal/vertical subsampling area include\n\t\t * YCbCr data for the extended image.\n\t\t */\n\t\tuint16 ycbcrsubsampling[2];\n\t\tuint16 samplingblock_samples;\n\t\tuint32 samplingblocks_hor;\n\t\tuint32 samplingblocks_ver;\n\t\tuint64 samplingrow_samples;\n\t\tuint64 samplingrow_size;\n\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_YCBCRSUBSAMPLING,ycbcrsubsampling+0,\n\t\t    ycbcrsubsampling+1);\n\t\tif ((ycbcrsubsampling[0] != 1 && ycbcrsubsampling[0] != 2 && ycbcrsubsampling[0] != 4)\n\t\t    ||(ycbcrsubsampling[1] != 1 && ycbcrsubsampling[1] != 2 && ycbcrsubsampling[1] != 4))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t\t\t     \"Invalid YCbCr subsampling (%dx%d)\", \n\t\t\t\t     ycbcrsubsampling[0], \n\t\t\t\t     ycbcrsubsampling[1] );\n\t\t\treturn 0;\n\t\t}\n\t\tsamplingblock_samples=ycbcrsubsampling[0]*ycbcrsubsampling[1]+2;\n\t\tsamplingblocks_hor=TIFFhowmany_32(td->td_tilewidth,ycbcrsubsampling[0]);\n\t\tsamplingblocks_ver=TIFFhowmany_32(nrows,ycbcrsubsampling[1]);\n\t\tsamplingrow_samples=_TIFFMultiply64(tif,samplingblocks_hor,samplingblock_samples,module);\n\t\tsamplingrow_size=TIFFhowmany8_64(_TIFFMultiply64(tif,samplingrow_samples,td->td_bitspersample,module));\n\t\treturn(_TIFFMultiply64(tif,samplingrow_size,samplingblocks_ver,module));\n\t}\n\telse\n\t\treturn(_TIFFMultiply64(tif,nrows,TIFFTileRowSize64(tif),module));\n}",
        "begin_line": 200,
        "end_line": 247,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix.TIFFFdOpen#204",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix.TIFFFdOpen(int fd, const char* name, const char* mode)",
        "snippet": "TIFF*\nTIFFFdOpen(int fd, const char* name, const char* mode)\n{\n\tTIFF* tif;\n\n\tfd_as_handle_union_t fdh;\n\tfdh.fd = fd;\n\ttif = TIFFClientOpen(name, mode,\n\t    fdh.h,\n\t    _tiffReadProc, _tiffWriteProc,\n\t    _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,\n\t    _tiffMapProc, _tiffUnmapProc);\n\tif (tif)\n\t\ttif->tif_fd = fd;\n\treturn (tif);\n}",
        "begin_line": 204,
        "end_line": 219,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix.TIFFOpen#224",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix.TIFFOpen(const char* name, const char* mode)",
        "snippet": "TIFF*\nTIFFOpen(const char* name, const char* mode)\n{\n\tstatic const char module[] = \"TIFFOpen\";\n\tint m, fd;\n\tTIFF* tif;\n\n\tm = _TIFFgetMode(mode, module);\n\tif (m == -1)\n\t\treturn ((TIFF*)0);\n\n/* for cygwin and mingw */\n#ifdef O_BINARY\n\tm |= O_BINARY;\n#endif\n\n\tfd = open(name, m, 0666);\n\tif (fd < 0) {\n\t\tif (errno > 0 && strerror(errno) != NULL ) {\n\t\t\tTIFFErrorExt(0, module, \"%s: %s\", name, strerror(errno) );\n\t\t} else {\n\t\t\tTIFFErrorExt(0, module, \"%s: Cannot open\", name);\n\t\t}\n\t\treturn ((TIFF *)0);\n\t}\n\n\ttif = TIFFFdOpen((int)fd, name, mode);\n\tif(!tif)\n\t\tclose(fd);\n\treturn tif;\n}",
        "begin_line": 224,
        "end_line": 254,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._TIFFfree#319",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._TIFFfree(void* p)",
        "snippet": "void\n_TIFFfree(void* p)\n{\n\tfree(p);\n}",
        "begin_line": 319,
        "end_line": 323,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._TIFFmalloc#310",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._TIFFmalloc(tmsize_t s)",
        "snippet": "void*\n_TIFFmalloc(tmsize_t s)\n{\n        if (s == 0)\n                return ((void *) NULL);\n\n\treturn (malloc((size_t) s));\n}",
        "begin_line": 310,
        "end_line": 317,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._TIFFmemcpy#337",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._TIFFmemcpy(void* d, const void* s, tmsize_t c)",
        "snippet": "void\n_TIFFmemcpy(void* d, const void* s, tmsize_t c)\n{\n\tmemcpy(d, s, (size_t) c);\n}",
        "begin_line": 337,
        "end_line": 341,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._TIFFmemset#331",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._TIFFmemset(void* p, int v, tmsize_t c)",
        "snippet": "void\n_TIFFmemset(void* p, int v, tmsize_t c)\n{\n\tmemset(p, v, (size_t) c);\n}",
        "begin_line": 331,
        "end_line": 335,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._TIFFrealloc#325",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._TIFFrealloc(void* p, tmsize_t s)",
        "snippet": "void*\n_TIFFrealloc(void* p, tmsize_t s)\n{\n\treturn (realloc(p, (size_t) s));\n}",
        "begin_line": 325,
        "end_line": 329,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._tiffMapProc#162",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._tiffMapProc(thandle_t fd, void** pbase, toff_t* psize)",
        "snippet": "static int\n_tiffMapProc(thandle_t fd, void** pbase, toff_t* psize)\n{\n\tuint64 size64 = _tiffSizeProc(fd);\n\ttmsize_t sizem = (tmsize_t)size64;\n\tif ((uint64)sizem==size64) {\n\t\tfd_as_handle_union_t fdh;\n\t\tfdh.h = fd;\n\t\t*pbase = (void*)\n\t\t    mmap(0, (size_t)sizem, PROT_READ, MAP_SHARED, fdh.fd, 0);\n\t\tif (*pbase != (void*) -1) {\n\t\t\t*psize = (tmsize_t)sizem;\n\t\t\treturn (1);\n\t\t}\n\t}\n\treturn (0);\n}",
        "begin_line": 162,
        "end_line": 178,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._tiffReadProc#68",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._tiffReadProc(thandle_t fd, void* buf, tmsize_t size)",
        "snippet": "static tmsize_t\n_tiffReadProc(thandle_t fd, void* buf, tmsize_t size)\n{\n\tfd_as_handle_union_t fdh;\n        const size_t bytes_total = (size_t) size;\n        size_t bytes_read;\n        tmsize_t count = -1;\n\tif ((tmsize_t) bytes_total != size)\n\t{\n\t\terrno=EINVAL;\n\t\treturn (tmsize_t) -1;\n\t}\n\tfdh.h = fd;\n        for (bytes_read=0; bytes_read < bytes_total; bytes_read+=count)\n        {\n                char *buf_offset = (char *) buf+bytes_read;\n                size_t io_size = bytes_total-bytes_read;\n                if (io_size > TIFF_IO_MAX)\n                        io_size = TIFF_IO_MAX;\n                count=read(fdh.fd, buf_offset, (TIFFIOSize_t) io_size);\n                if (count <= 0)\n                        break;\n        }\n        if (count < 0)\n                return (tmsize_t)-1;\n        return (tmsize_t) bytes_read;\n}",
        "begin_line": 68,
        "end_line": 94,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._tiffSizeProc#147",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._tiffSizeProc(thandle_t fd)",
        "snippet": "static uint64\n_tiffSizeProc(thandle_t fd)\n{\n\t_TIFF_stat_s sb;\n\tfd_as_handle_union_t fdh;\n\tfdh.h = fd;\n\tif (_TIFF_fstat_f(fdh.fd,&sb)<0)\n\t\treturn(0);\n\telse\n\t\treturn((uint64)sb.st_size);\n}",
        "begin_line": 147,
        "end_line": 157,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix.unixErrorHandler#360",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix.unixErrorHandler(const char* module, const char* fmt, va_list ap)",
        "snippet": "static void\nunixErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n\tif (module != NULL)\n\t\tfprintf(stderr, \"%s: \", module);\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \".\\n\");\n}",
        "begin_line": 360,
        "end_line": 367,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix.unixWarningHandler#349",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix.unixWarningHandler(const char* module, const char* fmt, va_list ap)",
        "snippet": "static void\nunixWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n\tif (module != NULL)\n\t\tfprintf(stderr, \"%s: \", module);\n\tfprintf(stderr, \"Warning, \");\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \".\\n\");\n}",
        "begin_line": 349,
        "end_line": 357,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_warning.TIFFWarningExt#62",
        "src_path": "libtiff/tif_warning.c",
        "class_name": "libtiff.tif_warning",
        "signature": "libtiff.tif_warning.TIFFWarningExt(thandle_t fd, const char* module, const char* fmt, ...)",
        "snippet": "void\nTIFFWarningExt(thandle_t fd, const char* module, const char* fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tif (_TIFFwarningHandler)\n\t\t(*_TIFFwarningHandler)(module, fmt, ap);\n\tif (_TIFFwarningHandlerExt)\n\t\t(*_TIFFwarningHandlerExt)(fd, module, fmt, ap);\n\tva_end(ap);\n}",
        "begin_line": 62,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.__asan_on_error#610",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.__asan_on_error(void)",
        "snippet": "void __asan_on_error(void) {\n#ifdef DPP_ENABLE_GCOV\n    __gcov_flush();\n#endif\n}",
        "begin_line": 610,
        "end_line": 614,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.main#615",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.main(int argc, char* argv[])",
        "snippet": "int\nmain(int argc, char* argv[])\n{\n#ifdef DPP_ENABLE_GCOV\n\t  {\n\t\t  dpp_gcov_sigaction.sa_handler = dpp_sighandler;\n\t\t  sigemptyset(&dpp_gcov_sigaction.sa_mask);\n\t\t  dpp_gcov_sigaction.sa_flags = 0;\n\t\t  sigaction(SIGSEGV, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n\t\t  sigaction(SIGFPE, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n\t\t  sigaction(SIGABRT, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n\t  }\n#endif\n#if !HAVE_DECL_OPTARG\n\textern char *optarg;\n\textern int optind;\n#endif\n\tconst char *outfilename = NULL;\n\tT2P *t2p = NULL;\n\tTIFF *input = NULL, *output = NULL;\n\tint c, ret = EXIT_SUCCESS;\n\n\tt2p = t2p_init();\n\n\tif (t2p == NULL){\n\t\tTIFFError(TIFF2PDF_MODULE, \"Can't initialize context\");\n\t\tgoto fail;\n\t}\n\n\twhile (argv &&\n\t       (c = getopt(argc, argv,\n\t\t\t   \"o:q:u:x:y:w:l:r:p:e:c:a:t:s:k:jzndifbhF\")) != -1){\n\t\tswitch (c) {\n\t\t\tcase 'o':\n\t\t\t\toutfilename = optarg;\n\t\t\t\tbreak;\n#ifdef JPEG_SUPPORT\n\t\t\tcase 'j':  \n\t\t\t\tt2p->pdf_defaultcompression=T2P_COMPRESS_JPEG;\n\t\t\t\tbreak;\n#endif\n#ifndef JPEG_SUPPORT\n\t\t\tcase 'j':  \n\t\t\t\tTIFFWarning(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"JPEG support in libtiff required for JPEG compression, ignoring option\");\n\t\t\t\tbreak;\n#endif\n#ifdef ZIP_SUPPORT\n\t\t\tcase 'z':  \n\t\t\t\tt2p->pdf_defaultcompression=T2P_COMPRESS_ZIP;\n\t\t\t\tbreak;\n#endif\n#ifndef ZIP_SUPPORT\n\t\t\tcase 'z':  \n\t\t\t\tTIFFWarning(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"Zip support in libtiff required for Zip compression, ignoring option\");\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'q': \n\t\t\t\tt2p->pdf_defaultcompressionquality=atoi(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'n': \n\t\t\t\tt2p->pdf_nopassthrough=1;\n\t\t\t\tbreak;\n\t\t\tcase 'd': \n\t\t\t\tt2p->pdf_defaultcompression=T2P_COMPRESS_NONE;\n\t\t\t\tbreak;\n\t\t\tcase 'u': \n\t\t\t\tif(optarg[0]=='m'){\n\t\t\t\t\tt2p->pdf_centimeters=1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'x': \n\t\t\t\tt2p->pdf_defaultxres = \n\t\t\t\t\t(float)atof(optarg) / (t2p->pdf_centimeters?2.54F:1.0F);\n\t\t\t\tbreak;\n\t\t\tcase 'y': \n\t\t\t\tt2p->pdf_defaultyres = \n\t\t\t\t\t(float)atof(optarg) / (t2p->pdf_centimeters?2.54F:1.0F);\n\t\t\t\tbreak;\n\t\t\tcase 'w': \n\t\t\t\tt2p->pdf_overridepagesize=1;\n\t\t\t\tt2p->pdf_defaultpagewidth = \n\t\t\t\t\t((float)atof(optarg) * PS_UNIT_SIZE) / (t2p->pdf_centimeters?2.54F:1.0F);\n\t\t\t\tbreak;\n\t\t\tcase 'l': \n\t\t\t\tt2p->pdf_overridepagesize=1;\n\t\t\t\tt2p->pdf_defaultpagelength = \n\t\t\t\t\t((float)atof(optarg) * PS_UNIT_SIZE) / (t2p->pdf_centimeters?2.54F:1.0F);\n\t\t\t\tbreak;\n\t\t\tcase 'r': \n\t\t\t\tif(optarg[0]=='o'){\n\t\t\t\t\tt2p->pdf_overrideres=1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'p': \n\t\t\t\tif(tiff2pdf_match_paper_size(\n\t\t\t\t\t&(t2p->pdf_defaultpagewidth), \n\t\t\t\t\t&(t2p->pdf_defaultpagelength), \n\t\t\t\t\toptarg)){\n\t\t\t\t\tt2p->pdf_overridepagesize=1;\n\t\t\t\t} else {\n\t\t\t\t\tTIFFWarning(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Unknown paper size %s, ignoring option\",\n\t\t\t\t\t\toptarg);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tt2p->pdf_colorspace_invert=1;\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\tt2p->pdf_image_fillpage = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'f': \n\t\t\t\tt2p->pdf_fitwindow=1;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tif (strlen(optarg) == 0) {\n\t\t\t\t\tt2p->pdf_datetime[0] = '\\0';\n\t\t\t\t} else {\n\t\t\t\t\tt2p->pdf_datetime[0] = 'D';\n\t\t\t\t\tt2p->pdf_datetime[1] = ':';\n\t\t\t\t\tstrncpy(t2p->pdf_datetime + 2, optarg,\n\t\t\t\t\t\tsizeof(t2p->pdf_datetime) - 3);\n\t\t\t\t\tt2p->pdf_datetime[sizeof(t2p->pdf_datetime) - 1] = '\\0';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'c': \n\t\t\t\tstrncpy(t2p->pdf_creator, optarg, sizeof(t2p->pdf_creator) - 1);\n\t\t\t\tt2p->pdf_creator[sizeof(t2p->pdf_creator) - 1] = '\\0';\n\t\t\t\tbreak;\n\t\t\tcase 'a': \n\t\t\t\tstrncpy(t2p->pdf_author, optarg, sizeof(t2p->pdf_author) - 1);\n\t\t\t\tt2p->pdf_author[sizeof(t2p->pdf_author) - 1] = '\\0';\n\t\t\t\tbreak;\n\t\t\tcase 't': \n\t\t\t\tstrncpy(t2p->pdf_title, optarg, sizeof(t2p->pdf_title) - 1);\n\t\t\t\tt2p->pdf_title[sizeof(t2p->pdf_title) - 1] = '\\0';\n\t\t\t\tbreak;\n\t\t\tcase 's': \n\t\t\t\tstrncpy(t2p->pdf_subject, optarg, sizeof(t2p->pdf_subject) - 1);\n\t\t\t\tt2p->pdf_subject[sizeof(t2p->pdf_subject) - 1] = '\\0';\n\t\t\t\tbreak;\n\t\t\tcase 'k': \n\t\t\t\tstrncpy(t2p->pdf_keywords, optarg, sizeof(t2p->pdf_keywords) - 1);\n\t\t\t\tt2p->pdf_keywords[sizeof(t2p->pdf_keywords) - 1] = '\\0';\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tt2p->pdf_image_interpolate = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'h': \n\t\t\tcase '?': \n\t\t\t\ttiff2pdf_usage();\n\t\t\t\tgoto success;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Input\n\t */\n\tif(argc > optind) {\n\t\tinput = TIFFOpen(argv[optind++], \"r\");\n\t\tif (input==NULL) {\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t  \"Can't open input file %s for reading\", \n\t\t\t\t  argv[optind-1]);\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\tTIFFError(TIFF2PDF_MODULE, \"No input file specified\"); \n\t\ttiff2pdf_usage();\n\t\tgoto fail;\n\t}\n\n\tif(argc > optind) {\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t  \"No support for multiple input files\"); \n\t\ttiff2pdf_usage();\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * Output\n\t */\n\tt2p->outputdisable = 1;\n\tif (outfilename) {\n\t\tt2p->outputfile = fopen(outfilename, \"wb\");\n\t\tif (t2p->outputfile == NULL) {\n\t\t\tTIFFError(TIFF2PDF_MODULE,\n\t\t\t\t  \"Can't open output file %s for writing\",\n\t\t\t\t  outfilename);\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\toutfilename = \"-\";\n\t\tt2p->outputfile = stdout;\n\t}\n\n\toutput = TIFFClientOpen(outfilename, \"w\", (thandle_t) t2p,\n\t\t\t\tt2p_readproc, t2p_writeproc, t2p_seekproc, \n\t\t\t\tt2p_closeproc, t2p_sizeproc, \n\t\t\t\tt2p_mapproc, t2p_unmapproc);\n\tt2p->outputdisable = 0;\n\tif (output == NULL) {\n\t\tTIFFError(TIFF2PDF_MODULE,\n\t\t\t  \"Can't initialize output descriptor\");\n\t\tgoto fail;\n\t}\n\t\n\t/*\n\t * Validate\n\t */\n\tt2p_validate(t2p);\n\tt2pSeekFile(output, (toff_t) 0, SEEK_SET);\n\n\t/*\n\t * Write\n\t */\n\tt2p_write_pdf(t2p, input, output);\n\tif (t2p->t2p_error != 0) {\n\t\tTIFFError(TIFF2PDF_MODULE,\n\t\t\t  \"An error occurred creating output PDF file\");\n\t\tgoto fail;\n\t}\n\n\tgoto success;\nfail:\n\tret = EXIT_FAILURE;\nsuccess:\n\tif(input != NULL)\n\t\tTIFFClose(input);\n\tif (output != NULL)\n\t\tTIFFClose(output);\n\tif (t2p != NULL)\n\t\tt2p_free(t2p);\n\treturn ret;\n  \n}",
        "begin_line": 615,
        "end_line": 855,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2pSeekFile#383",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2pSeekFile(TIFF *tif, toff_t offset, int whence)",
        "snippet": "static uint64\nt2pSeekFile(TIFF *tif, toff_t offset, int whence)\n{\n\tthandle_t client = TIFFClientdata(tif);\n\tTIFFSeekProc proc = TIFFGetSeekProc(tif);\n\tif (proc)\n\t\treturn proc(client, offset, whence);\n\treturn -1;\n}",
        "begin_line": 383,
        "end_line": 391,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2pWriteFile#373",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2pWriteFile(TIFF *tif, tdata_t data, tmsize_t size)",
        "snippet": "static tmsize_t \nt2pWriteFile(TIFF *tif, tdata_t data, tmsize_t size)\n{\n\tthandle_t client = TIFFClientdata(tif);\n\tTIFFReadWriteProc proc = TIFFGetWriteProc(tif);\n\tif (proc)\n\t\treturn proc(client, data, size);\n\treturn -1;\n}",
        "begin_line": 373,
        "end_line": 381,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_compose_pdf_page#4430",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_compose_pdf_page(T2P* t2p)",
        "snippet": "void t2p_compose_pdf_page(T2P* t2p){\n\n\tuint32 i=0;\n\tuint32 i2=0;\n\tT2P_TILE* tiles=NULL;\n\tT2P_BOX* boxp=NULL;\n\tuint32 tilecountx=0;\n\tuint32 tilecounty=0;\n\tuint32 tilewidth=0;\n\tuint32 tilelength=0;\n\tint istiled=0;\n\tfloat f=0;\n\tfloat width_ratio=0;\n\tfloat length_ratio=0;\n\t\n\tt2p->pdf_xres = t2p->tiff_xres;\n\tt2p->pdf_yres = t2p->tiff_yres;\n\tif(t2p->pdf_overrideres) {\n\t\tt2p->pdf_xres = t2p->pdf_defaultxres;\n\t\tt2p->pdf_yres = t2p->pdf_defaultyres;\n\t}\n\tif(t2p->pdf_xres == 0.0)\n\t\tt2p->pdf_xres = t2p->pdf_defaultxres;\n\tif(t2p->pdf_yres == 0.0)\n\t\tt2p->pdf_yres = t2p->pdf_defaultyres;\n\tif (t2p->pdf_image_fillpage) {\n\t\twidth_ratio = t2p->pdf_defaultpagewidth/t2p->tiff_width;\n\t\tlength_ratio = t2p->pdf_defaultpagelength/t2p->tiff_length;\n\t\tif (width_ratio < length_ratio ) {\n\t\t\tt2p->pdf_imagewidth = t2p->pdf_defaultpagewidth;\n\t\t\tt2p->pdf_imagelength = t2p->tiff_length * width_ratio;\n\t\t} else {\n\t\t\tt2p->pdf_imagewidth = t2p->tiff_width * length_ratio;\n\t\t\tt2p->pdf_imagelength = t2p->pdf_defaultpagelength;\n\t\t}\n\t} else if (t2p->tiff_resunit != RESUNIT_CENTIMETER\t/* RESUNIT_NONE and */\n\t\t&& t2p->tiff_resunit != RESUNIT_INCH) {\t/* other cases */\n\t\tt2p->pdf_imagewidth = ((float)(t2p->tiff_width))/t2p->pdf_xres;\n\t\tt2p->pdf_imagelength = ((float)(t2p->tiff_length))/t2p->pdf_yres;\n\t} else {\n\t\tt2p->pdf_imagewidth = \n\t\t\t((float)(t2p->tiff_width))*PS_UNIT_SIZE/t2p->pdf_xres;\n\t\tt2p->pdf_imagelength = \n\t\t\t((float)(t2p->tiff_length))*PS_UNIT_SIZE/t2p->pdf_yres;\n\t}\n\tif(t2p->pdf_overridepagesize != 0) {\n\t\tt2p->pdf_pagewidth = t2p->pdf_defaultpagewidth;\n\t\tt2p->pdf_pagelength = t2p->pdf_defaultpagelength;\n\t} else {\n\t\tt2p->pdf_pagewidth = t2p->pdf_imagewidth;\n\t\tt2p->pdf_pagelength = t2p->pdf_imagelength;\n\t}\n\tt2p->pdf_mediabox.x1=0.0;\n\tt2p->pdf_mediabox.y1=0.0;\n\tt2p->pdf_mediabox.x2=t2p->pdf_pagewidth;\n\tt2p->pdf_mediabox.y2=t2p->pdf_pagelength;\n\tt2p->pdf_imagebox.x1=0.0;\n\tt2p->pdf_imagebox.y1=0.0;\n\tt2p->pdf_imagebox.x2=t2p->pdf_imagewidth;\n\tt2p->pdf_imagebox.y2=t2p->pdf_imagelength;\n\tif(t2p->pdf_overridepagesize!=0){\n\t\tt2p->pdf_imagebox.x1+=((t2p->pdf_pagewidth-t2p->pdf_imagewidth)/2.0F);\n\t\tt2p->pdf_imagebox.y1+=((t2p->pdf_pagelength-t2p->pdf_imagelength)/2.0F);\n\t\tt2p->pdf_imagebox.x2+=((t2p->pdf_pagewidth-t2p->pdf_imagewidth)/2.0F);\n\t\tt2p->pdf_imagebox.y2+=((t2p->pdf_pagelength-t2p->pdf_imagelength)/2.0F);\n\t}\n\tif(t2p->tiff_orientation > 4){\n\t\tf=t2p->pdf_mediabox.x2;\n\t\tt2p->pdf_mediabox.x2=t2p->pdf_mediabox.y2;\n\t\tt2p->pdf_mediabox.y2=f;\n\t}\n\tistiled=((t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecount==0) ? 0 : 1;\n\tif(istiled==0){\n\t\tt2p_compose_pdf_page_orient(&(t2p->pdf_imagebox), t2p->tiff_orientation);\n\t\treturn;\n\t} else {\n\t\ttilewidth=(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilewidth;\n\t\ttilelength=(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilelength;\n\t\tif( tilewidth > INT_MAX ||\n\t\t    tilelength > INT_MAX ||\n\t\t    t2p->tiff_width > INT_MAX - tilewidth ||\n\t\t    t2p->tiff_length > INT_MAX - tilelength )\n\t\t{\n\t\t    TIFFError(TIFF2PDF_MODULE, \"Integer overflow\");\n\t\t    t2p->t2p_error = T2P_ERR_ERROR;\n\t\t    return;\n\t\t}\n\t\ttilecountx=(t2p->tiff_width + \n\t\t\ttilewidth -1)/ \n\t\t\ttilewidth;\n\t\t(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecountx=tilecountx;\n\t\ttilecounty=(t2p->tiff_length + \n\t\t\ttilelength -1)/ \n\t\t\ttilelength;\n\t\t(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecounty=tilecounty;\n\t\t(t2p->tiff_tiles[t2p->pdf_page]).tiles_edgetilewidth=\n\t\t\tt2p->tiff_width % tilewidth;\n\t\t(t2p->tiff_tiles[t2p->pdf_page]).tiles_edgetilelength=\n\t\t\tt2p->tiff_length % tilelength;\n\t\ttiles=(t2p->tiff_tiles[t2p->pdf_page]).tiles_tiles;\n\t\tfor(i2=0;i2<tilecounty-1;i2++){\n\t\t\tfor(i=0;i<tilecountx-1;i++){\n\t\t\t\tboxp=&(tiles[i2*tilecountx+i].tile_box);\n\t\t\t\tboxp->x1 = \n\t\t\t\t\tt2p->pdf_imagebox.x1 \n\t\t\t\t\t+ ((float)(t2p->pdf_imagewidth * i * tilewidth)\n\t\t\t\t\t/ (float)t2p->tiff_width);\n\t\t\t\tboxp->x2 = \n\t\t\t\t\tt2p->pdf_imagebox.x1 \n\t\t\t\t\t+ ((float)(t2p->pdf_imagewidth * (i+1) * tilewidth)\n\t\t\t\t\t/ (float)t2p->tiff_width);\n\t\t\t\tboxp->y1 = \n\t\t\t\t\tt2p->pdf_imagebox.y2 \n\t\t\t\t\t- ((float)(t2p->pdf_imagelength * (i2+1) * tilelength)\n\t\t\t\t\t/ (float)t2p->tiff_length);\n\t\t\t\tboxp->y2 = \n\t\t\t\t\tt2p->pdf_imagebox.y2 \n\t\t\t\t\t- ((float)(t2p->pdf_imagelength * i2 * tilelength)\n\t\t\t\t\t/ (float)t2p->tiff_length);\n\t\t\t}\n\t\t\tboxp=&(tiles[i2*tilecountx+i].tile_box);\n\t\t\tboxp->x1 = \n\t\t\t\tt2p->pdf_imagebox.x1 \n\t\t\t\t+ ((float)(t2p->pdf_imagewidth * i * tilewidth)\n\t\t\t\t/ (float)t2p->tiff_width);\n\t\t\tboxp->x2 = t2p->pdf_imagebox.x2;\n\t\t\tboxp->y1 = \n\t\t\t\tt2p->pdf_imagebox.y2 \n\t\t\t\t- ((float)(t2p->pdf_imagelength * (i2+1) * tilelength)\n\t\t\t\t/ (float)t2p->tiff_length);\n\t\t\tboxp->y2 = \n\t\t\t\tt2p->pdf_imagebox.y2 \n\t\t\t\t- ((float)(t2p->pdf_imagelength * i2 * tilelength)\n\t\t\t\t/ (float)t2p->tiff_length);\n\t\t}\n\t\tfor(i=0;i<tilecountx-1;i++){\n\t\t\tboxp=&(tiles[i2*tilecountx+i].tile_box);\n\t\t\tboxp->x1 = \n\t\t\t\tt2p->pdf_imagebox.x1 \n\t\t\t\t+ ((float)(t2p->pdf_imagewidth * i * tilewidth)\n\t\t\t\t/ (float)t2p->tiff_width);\n\t\t\tboxp->x2 = \n\t\t\t\tt2p->pdf_imagebox.x1 \n\t\t\t\t+ ((float)(t2p->pdf_imagewidth * (i+1) * tilewidth)\n\t\t\t\t/ (float)t2p->tiff_width);\n\t\t\tboxp->y1 = t2p->pdf_imagebox.y1;\n\t\t\tboxp->y2 = \n\t\t\t\tt2p->pdf_imagebox.y2 \n\t\t\t\t- ((float)(t2p->pdf_imagelength * i2 * tilelength)\n\t\t\t\t/ (float)t2p->tiff_length);\n\t\t}\n\t\tboxp=&(tiles[i2*tilecountx+i].tile_box);\n\t\tboxp->x1 = \n\t\t\tt2p->pdf_imagebox.x1 \n\t\t\t+ ((float)(t2p->pdf_imagewidth * i * tilewidth)\n\t\t\t/ (float)t2p->tiff_width);\n\t\tboxp->x2 = t2p->pdf_imagebox.x2;\n\t\tboxp->y1 = t2p->pdf_imagebox.y1;\n\t\tboxp->y2 = \n\t\t\tt2p->pdf_imagebox.y2 \n\t\t\t- ((float)(t2p->pdf_imagelength * i2 * tilelength)\n\t\t\t/ (float)t2p->tiff_length);\n\t}\n\tif(t2p->tiff_orientation==0 || t2p->tiff_orientation==1){\n\t\tfor(i=0;i<(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecount;i++){\n\t\t\tt2p_compose_pdf_page_orient( &(tiles[i].tile_box) , 0);\n\t\t}\n\t\treturn;\n\t}\n\tfor(i=0;i<(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecount;i++){\n\t\tboxp=&(tiles[i].tile_box);\n\t\tboxp->x1 -= t2p->pdf_imagebox.x1;\n\t\tboxp->x2 -= t2p->pdf_imagebox.x1;\n\t\tboxp->y1 -= t2p->pdf_imagebox.y1;\n\t\tboxp->y2 -= t2p->pdf_imagebox.y1;\n\t\tif(t2p->tiff_orientation==2 || t2p->tiff_orientation==3){\n\t\t\tboxp->x1 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x1;\n\t\t\tboxp->x2 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x2;\n\t\t}\n\t\tif(t2p->tiff_orientation==3 || t2p->tiff_orientation==4){\n\t\t\tboxp->y1 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y1;\n\t\t\tboxp->y2 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y2;\n\t\t}\n\t\tif(t2p->tiff_orientation==8 || t2p->tiff_orientation==5){\n\t\t\tboxp->y1 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y1;\n\t\t\tboxp->y2 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y2;\n\t\t}\n\t\tif(t2p->tiff_orientation==5 || t2p->tiff_orientation==6){\n\t\t\tboxp->x1 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x1;\n\t\t\tboxp->x2 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x2;\n\t\t}\n\t\tif(t2p->tiff_orientation > 4){\n\t\t\tf=boxp->x1;\n\t\t\tboxp->x1 = boxp->y1;\n\t\t\tboxp->y1 = f;\n\t\t\tf=boxp->x2;\n\t\t\tboxp->x2 = boxp->y2;\n\t\t\tboxp->y2 = f; \n\t\t\tt2p_compose_pdf_page_orient_flip(boxp, t2p->tiff_orientation);\n\t\t} else {\n\t\t\tt2p_compose_pdf_page_orient(boxp, t2p->tiff_orientation);\n\t\t}\n\t\t\n\t}\n\n\treturn;\n}",
        "begin_line": 4430,
        "end_line": 4636,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_compose_pdf_page_orient#4638",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_compose_pdf_page_orient(T2P_BOX* boxp, uint16 orientation)",
        "snippet": "void t2p_compose_pdf_page_orient(T2P_BOX* boxp, uint16 orientation){\n\n\tfloat m1[9];\n\tfloat f=0.0;\n\t\n\tif( boxp->x1 > boxp->x2){\n\t\tf=boxp->x1;\n\t\tboxp->x1=boxp->x2;\n\t\tboxp->x2 = f;\n\t}\n\tif( boxp->y1 > boxp->y2){\n\t\tf=boxp->y1;\n\t\tboxp->y1=boxp->y2;\n\t\tboxp->y2 = f;\n\t}\n\tboxp->mat[0]=m1[0]=boxp->x2-boxp->x1;\n\tboxp->mat[1]=m1[1]=0.0;\n\tboxp->mat[2]=m1[2]=0.0;\n\tboxp->mat[3]=m1[3]=0.0;\n\tboxp->mat[4]=m1[4]=boxp->y2-boxp->y1;\n\tboxp->mat[5]=m1[5]=0.0;\n\tboxp->mat[6]=m1[6]=boxp->x1;\n\tboxp->mat[7]=m1[7]=boxp->y1;\n\tboxp->mat[8]=m1[8]=1.0;\n\tswitch(orientation){\n\t\tcase 0:\n\t\tcase 1:\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tboxp->mat[0]=0.0F-m1[0];\n\t\t\tboxp->mat[6]+=m1[0];\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tboxp->mat[0]=0.0F-m1[0];\n\t\t\tboxp->mat[4]=0.0F-m1[4];\n\t\t\tboxp->mat[6]+=m1[0];\n\t\t\tboxp->mat[7]+=m1[4];\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tboxp->mat[4]=0.0F-m1[4];\n\t\t\tboxp->mat[7]+=m1[4];\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tboxp->mat[0]=0.0F;\n\t\t\tboxp->mat[1]=0.0F-m1[0];\n\t\t\tboxp->mat[3]=0.0F-m1[4];\n\t\t\tboxp->mat[4]=0.0F;\n\t\t\tboxp->mat[6]+=m1[4];\n\t\t\tboxp->mat[7]+=m1[0];\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tboxp->mat[0]=0.0F;\n\t\t\tboxp->mat[1]=0.0F-m1[0];\n\t\t\tboxp->mat[3]=m1[4];\n\t\t\tboxp->mat[4]=0.0F;\n\t\t\tboxp->mat[7]+=m1[0];\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tboxp->mat[0]=0.0F;\n\t\t\tboxp->mat[1]=m1[0];\n\t\t\tboxp->mat[3]=m1[4];\n\t\t\tboxp->mat[4]=0.0F;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tboxp->mat[0]=0.0F;\n\t\t\tboxp->mat[1]=m1[0];\n\t\t\tboxp->mat[3]=0.0F-m1[4];\n\t\t\tboxp->mat[4]=0.0F;\n\t\t\tboxp->mat[6]+=m1[4];\n\t\t\tbreak;\n\t}\n\n\treturn;\n}",
        "begin_line": 4638,
        "end_line": 4711,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_init#965",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_init()",
        "snippet": "T2P* t2p_init()\n{\n\tT2P* t2p = (T2P*) _TIFFmalloc(sizeof(T2P));\n\tif(t2p==NULL){\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"Can't allocate %lu bytes of memory for t2p_init\", \n\t\t\t(unsigned long) sizeof(T2P));\n\t\treturn( (T2P*) NULL );\n\t}\n\t_TIFFmemset(t2p, 0x00, sizeof(T2P));\n\tt2p->pdf_majorversion=1;\n\tt2p->pdf_minorversion=1;\n\tt2p->pdf_defaultxres=300.0;\n\tt2p->pdf_defaultyres=300.0;\n\tt2p->pdf_defaultpagewidth=612.0;\n\tt2p->pdf_defaultpagelength=792.0;\n\tt2p->pdf_xrefcount=3; /* Catalog, Info, Pages */\n\t\n\treturn(t2p);\n}",
        "begin_line": 965,
        "end_line": 985,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_pdf_currenttime#4226",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_pdf_currenttime(T2P* t2p)",
        "snippet": "void t2p_pdf_currenttime(T2P* t2p)\n{\n\tstruct tm* currenttime;\n\ttime_t timenow;\n\n\tif (time(&timenow) == (time_t) -1) {\n\t\tTIFFError(TIFF2PDF_MODULE,\n\t\t\t  \"Can't get the current time: %s\", strerror(errno));\n\t\ttimenow = (time_t) 0;\n\t}\n\n\tcurrenttime = localtime(&timenow);\n\tsnprintf(t2p->pdf_datetime, sizeof(t2p->pdf_datetime),\n\t\t \"D:%.4d%.2d%.2d%.2d%.2d%.2d\",\n\t\t (currenttime->tm_year + 1900) % 65536,\n\t\t (currenttime->tm_mon + 1) % 256,\n\t\t (currenttime->tm_mday) % 256,\n\t\t (currenttime->tm_hour) % 256,\n\t\t (currenttime->tm_min) % 256,\n\t\t (currenttime->tm_sec) % 256);\n\n\treturn;\n}",
        "begin_line": 4226,
        "end_line": 4248,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_pdf_tifftime#4255",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_pdf_tifftime(T2P* t2p, TIFF* input)",
        "snippet": "void t2p_pdf_tifftime(T2P* t2p, TIFF* input)\n{\n\tchar* datetime;\n\n\tif (TIFFGetField(input, TIFFTAG_DATETIME, &datetime) != 0\n\t    && (strlen(datetime) >= 19) ){\n\t\tt2p->pdf_datetime[0]='D';\n\t\tt2p->pdf_datetime[1]=':';\n\t\tt2p->pdf_datetime[2]=datetime[0];\n\t\tt2p->pdf_datetime[3]=datetime[1];\n\t\tt2p->pdf_datetime[4]=datetime[2];\n\t\tt2p->pdf_datetime[5]=datetime[3];\n\t\tt2p->pdf_datetime[6]=datetime[5];\n\t\tt2p->pdf_datetime[7]=datetime[6];\n\t\tt2p->pdf_datetime[8]=datetime[8];\n\t\tt2p->pdf_datetime[9]=datetime[9];\n\t\tt2p->pdf_datetime[10]=datetime[11];\n\t\tt2p->pdf_datetime[11]=datetime[12];\n\t\tt2p->pdf_datetime[12]=datetime[14];\n\t\tt2p->pdf_datetime[13]=datetime[15];\n\t\tt2p->pdf_datetime[14]=datetime[17];\n\t\tt2p->pdf_datetime[15]=datetime[18];\n\t\tt2p->pdf_datetime[16] = '\\0';\n\t} else {\n\t\tt2p_pdf_currenttime(t2p);\n\t}\n\n\treturn;\n}",
        "begin_line": 4255,
        "end_line": 4283,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_read_tiff_data#1286",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_read_tiff_data(T2P* t2p, TIFF* input)",
        "snippet": "void t2p_read_tiff_data(T2P* t2p, TIFF* input){\n\n\tint i=0;\n\tuint16* r;\n\tuint16* g;\n\tuint16* b;\n\tuint16* a;\n\tuint16 xuint16;\n\tuint16* xuint16p;\n\tfloat* xfloatp;\n\n\tt2p->pdf_transcode = T2P_TRANSCODE_ENCODE;\n\tt2p->pdf_sample = T2P_SAMPLE_NOTHING;\n        t2p->pdf_switchdecode = t2p->pdf_colorspace_invert;\n        \n\t\n\tTIFFSetDirectory(input, t2p->tiff_pages[t2p->pdf_page].page_directory);\n\n\tTIFFGetField(input, TIFFTAG_IMAGEWIDTH, &(t2p->tiff_width));\n\tif(t2p->tiff_width == 0){\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"No support for %s with zero width\", \n\t\t\tTIFFFileName(input)\t);\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn;\n\t}\n\n\tTIFFGetField(input, TIFFTAG_IMAGELENGTH, &(t2p->tiff_length));\n\tif(t2p->tiff_length == 0){\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"No support for %s with zero length\", \n\t\t\tTIFFFileName(input)\t);\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn;\n\t}\n\n        if(TIFFGetField(input, TIFFTAG_COMPRESSION, &(t2p->tiff_compression)) == 0){\n                TIFFError(\n                        TIFF2PDF_MODULE, \n                        \"No support for %s with no compression tag\", \n                        TIFFFileName(input)     );\n                t2p->t2p_error = T2P_ERR_ERROR;\n                return;\n\n        }\n        if( TIFFIsCODECConfigured(t2p->tiff_compression) == 0){\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"No support for %s with compression type %u:  not configured\", \n\t\t\tTIFFFileName(input), \n\t\t\tt2p->tiff_compression\t\n\t\t\t);\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn;\n\t\n\t}\n\n\tTIFFGetFieldDefaulted(input, TIFFTAG_BITSPERSAMPLE, &(t2p->tiff_bitspersample));\n\tswitch(t2p->tiff_bitspersample){\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 4:\n\t\tcase 8:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tTIFFWarning(\n\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\"Image %s has 0 bits per sample, assuming 1\",\n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->tiff_bitspersample=1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tTIFFError(\n\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\"No support for %s with %u bits per sample\",\n\t\t\t\tTIFFFileName(input),\n\t\t\t\tt2p->tiff_bitspersample);\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn;\n\t}\n\n\tTIFFGetFieldDefaulted(input, TIFFTAG_SAMPLESPERPIXEL, &(t2p->tiff_samplesperpixel));\n\tif(t2p->tiff_samplesperpixel>4){\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"No support for %s with %u samples per pixel\",\n\t\t\tTIFFFileName(input),\n\t\t\tt2p->tiff_samplesperpixel);\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn;\n\t}\n\tif(t2p->tiff_samplesperpixel==0){\n\t\tTIFFWarning(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"Image %s has 0 samples per pixel, assuming 1\",\n\t\t\tTIFFFileName(input));\n\t\tt2p->tiff_samplesperpixel=1;\n\t}\n\t\n\tif(TIFFGetField(input, TIFFTAG_SAMPLEFORMAT, &xuint16) != 0 ){\n\t\tswitch(xuint16){\n\t\t\tcase 0:\n\t\t\tcase 1:\n\t\t\tcase 4:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for %s with sample format %u\",\n\t\t\t\t\tTIFFFileName(input),\n\t\t\t\t\txuint16);\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tTIFFGetFieldDefaulted(input, TIFFTAG_FILLORDER, &(t2p->tiff_fillorder));\n\t\n        if(TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &(t2p->tiff_photometric)) == 0){\n                TIFFError(\n                        TIFF2PDF_MODULE, \n                        \"No support for %s with no photometric interpretation tag\", \n                        TIFFFileName(input)     );\n                t2p->t2p_error = T2P_ERR_ERROR;\n                return;\n\n        }\n        \n\tswitch(t2p->tiff_photometric){\n\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\tcase PHOTOMETRIC_MINISBLACK: \n\t\t\tif (t2p->tiff_bitspersample==1){\n\t\t\t\tt2p->pdf_colorspace=T2P_CS_BILEVEL;\n\t\t\t\tif(t2p->tiff_photometric==PHOTOMETRIC_MINISWHITE){\n\t\t\t\t\tt2p->pdf_switchdecode ^= 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tt2p->pdf_colorspace=T2P_CS_GRAY;\n\t\t\t\tif(t2p->tiff_photometric==PHOTOMETRIC_MINISWHITE){\n\t\t\t\t\tt2p->pdf_switchdecode ^= 1;\n\t\t\t\t} \n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_RGB: \n\t\t\tt2p->pdf_colorspace=T2P_CS_RGB;\n\t\t\tif(t2p->tiff_samplesperpixel == 3){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_INDEXED, &xuint16)){\n\t\t\t\tif(xuint16==1)\n\t\t\t\t\tgoto photometric_palette;\n\t\t\t}\n\t\t\tif(t2p->tiff_samplesperpixel > 3) {\n\t\t\t\tif(t2p->tiff_samplesperpixel == 4) {\n\t\t\t\t\tt2p->pdf_colorspace = T2P_CS_RGB;\n\t\t\t\t\tif(TIFFGetField(input,\n\t\t\t\t\t\t\tTIFFTAG_EXTRASAMPLES,\n\t\t\t\t\t\t\t&xuint16, &xuint16p)\n\t\t\t\t\t   && xuint16 == 1) {\n\t\t\t\t\t\tif(xuint16p[0] == EXTRASAMPLE_ASSOCALPHA){\n\t\t\t\t\t\t\tif( t2p->tiff_bitspersample != 8 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t    TIFFError(\n\t\t\t\t\t\t\t\t    TIFF2PDF_MODULE, \n\t\t\t\t\t\t\t\t    \"No support for BitsPerSample=%d for RGBA\",\n\t\t\t\t\t\t\t\t    t2p->tiff_bitspersample);\n\t\t\t\t\t\t\t    t2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\t\t\t    return;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tt2p->pdf_sample=T2P_SAMPLE_RGBAA_TO_RGB;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xuint16p[0] == EXTRASAMPLE_UNASSALPHA){\n\t\t\t\t\t\t\tif( t2p->tiff_bitspersample != 8 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t    TIFFError(\n\t\t\t\t\t\t\t\t    TIFF2PDF_MODULE, \n\t\t\t\t\t\t\t\t    \"No support for BitsPerSample=%d for RGBA\",\n\t\t\t\t\t\t\t\t    t2p->tiff_bitspersample);\n\t\t\t\t\t\t\t    t2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\t\t\t    return;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tt2p->pdf_sample=T2P_SAMPLE_RGBA_TO_RGB;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTIFFWarning(\n\t\t\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\t\t\"RGB image %s has 4 samples per pixel, assuming RGBA\",\n\t\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tt2p->pdf_colorspace=T2P_CS_CMYK;\n\t\t\t\t\tt2p->pdf_switchdecode ^= 1;\n\t\t\t\t\tTIFFWarning(\n\t\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\t\"RGB image %s has 4 samples per pixel, assuming inverse CMYK\",\n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tTIFFError(\n\t\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\t\"No support for RGB image %s with %u samples per pixel\", \n\t\t\t\t\t\tTIFFFileName(input), \n\t\t\t\t\t\tt2p->tiff_samplesperpixel);\n\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for RGB image %s with %u samples per pixel\", \n\t\t\t\t\tTIFFFileName(input), \n\t\t\t\t\tt2p->tiff_samplesperpixel);\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase PHOTOMETRIC_PALETTE: \n\t\t\tphotometric_palette:\n\t\t\tif(t2p->tiff_samplesperpixel!=1){\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for palettized image %s with not one sample per pixel\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tt2p->pdf_colorspace=T2P_CS_RGB | T2P_CS_PALETTE;\n\t\t\tt2p->pdf_palettesize=0x0001<<t2p->tiff_bitspersample;\n\t\t\tif(!TIFFGetField(input, TIFFTAG_COLORMAP, &r, &g, &b)){\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"Palettized image %s has no color map\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t} \n\t\t\tif(t2p->pdf_palette != NULL){\n\t\t\t\t_TIFFfree(t2p->pdf_palette);\n\t\t\t\tt2p->pdf_palette=NULL;\n\t\t\t}\n\t\t\tt2p->pdf_palette = (unsigned char*)\n\t\t\t\t_TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_palettesize,3));\n\t\t\tif(t2p->pdf_palette==NULL){\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %u bytes of memory for t2p_read_tiff_image, %s\", \n\t\t\t\t\tt2p->pdf_palettesize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(i=0;i<t2p->pdf_palettesize;i++){\n\t\t\t\tt2p->pdf_palette[(i*3)]  = (unsigned char) (r[i]>>8);\n\t\t\t\tt2p->pdf_palette[(i*3)+1]= (unsigned char) (g[i]>>8);\n\t\t\t\tt2p->pdf_palette[(i*3)+2]= (unsigned char) (b[i]>>8);\n\t\t\t}\n\t\t\tt2p->pdf_palettesize *= 3;\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_SEPARATED:\n\t\t\tif(TIFFGetField(input, TIFFTAG_INDEXED, &xuint16)){\n\t\t\t\tif(xuint16==1){\n\t\t\t\t\t\tgoto photometric_palette_cmyk;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( TIFFGetField(input, TIFFTAG_INKSET, &xuint16) ){\n\t\t\t\tif(xuint16 != INKSET_CMYK){\n\t\t\t\t\tTIFFError(\n\t\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\t\"No support for %s because its inkset is not CMYK\",\n\t\t\t\t\t\tTIFFFileName(input) );\n\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t2p->tiff_samplesperpixel==4){\n\t\t\t\tt2p->pdf_colorspace=T2P_CS_CMYK;\n\t\t\t} else {\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for %s because it has %u samples per pixel\",\n\t\t\t\t\tTIFFFileName(input), \n\t\t\t\t\tt2p->tiff_samplesperpixel);\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tphotometric_palette_cmyk:\n\t\t\tif(t2p->tiff_samplesperpixel!=1){\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for palettized CMYK image %s with not one sample per pixel\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tt2p->pdf_colorspace=T2P_CS_CMYK | T2P_CS_PALETTE;\n\t\t\tt2p->pdf_palettesize=0x0001<<t2p->tiff_bitspersample;\n\t\t\tif(!TIFFGetField(input, TIFFTAG_COLORMAP, &r, &g, &b, &a)){\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"Palettized image %s has no color map\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t} \n\t\t\tif(t2p->pdf_palette != NULL){\n\t\t\t\t_TIFFfree(t2p->pdf_palette);\n\t\t\t\tt2p->pdf_palette=NULL;\n\t\t\t}\n\t\t\tt2p->pdf_palette = (unsigned char*) \n\t\t\t\t_TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_palettesize,4));\n\t\t\tif(t2p->pdf_palette==NULL){\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %u bytes of memory for t2p_read_tiff_image, %s\", \n\t\t\t\t\tt2p->pdf_palettesize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(i=0;i<t2p->pdf_palettesize;i++){\n\t\t\t\tt2p->pdf_palette[(i*4)]  = (unsigned char) (r[i]>>8);\n\t\t\t\tt2p->pdf_palette[(i*4)+1]= (unsigned char) (g[i]>>8);\n\t\t\t\tt2p->pdf_palette[(i*4)+2]= (unsigned char) (b[i]>>8);\n\t\t\t\tt2p->pdf_palette[(i*4)+3]= (unsigned char) (a[i]>>8);\n\t\t\t}\n\t\t\tt2p->pdf_palettesize *= 4;\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_YCBCR:\n\t\t\tt2p->pdf_colorspace=T2P_CS_RGB;\n\t\t\tif(t2p->tiff_samplesperpixel==1){\n\t\t\t\tt2p->pdf_colorspace=T2P_CS_GRAY;\n\t\t\t\tt2p->tiff_photometric=PHOTOMETRIC_MINISBLACK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt2p->pdf_sample=T2P_SAMPLE_YCBCR_TO_RGB;\n#ifdef JPEG_SUPPORT\n\t\t\tif(t2p->pdf_defaultcompression==T2P_COMPRESS_JPEG){\n\t\t\t\tt2p->pdf_sample=T2P_SAMPLE_NOTHING;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_CIELAB:\n            if( t2p->tiff_samplesperpixel != 3){\n                TIFFError(\n                    TIFF2PDF_MODULE, \n                    \"Unsupported samplesperpixel = %d for CIELAB\", \n                    t2p->tiff_samplesperpixel);\n                t2p->t2p_error = T2P_ERR_ERROR;\n                return;\n            }\n            if( t2p->tiff_bitspersample != 8){\n                TIFFError(\n                    TIFF2PDF_MODULE, \n                    \"Invalid bitspersample = %d for CIELAB\", \n                    t2p->tiff_bitspersample);\n                t2p->t2p_error = T2P_ERR_ERROR;\n                return;\n            }\n\t\t\tt2p->pdf_labrange[0]= -127;\n\t\t\tt2p->pdf_labrange[1]= 127;\n\t\t\tt2p->pdf_labrange[2]= -127;\n\t\t\tt2p->pdf_labrange[3]= 127;\n\t\t\tt2p->pdf_sample=T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;\n\t\t\tt2p->pdf_colorspace=T2P_CS_LAB;\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_ICCLAB:\n\t\t\tt2p->pdf_labrange[0]= 0;\n\t\t\tt2p->pdf_labrange[1]= 255;\n\t\t\tt2p->pdf_labrange[2]= 0;\n\t\t\tt2p->pdf_labrange[3]= 255;\n\t\t\tt2p->pdf_colorspace=T2P_CS_LAB;\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_ITULAB:\n            if( t2p->tiff_samplesperpixel != 3){\n                TIFFError(\n                    TIFF2PDF_MODULE, \n                    \"Unsupported samplesperpixel = %d for ITULAB\", \n                    t2p->tiff_samplesperpixel);\n                t2p->t2p_error = T2P_ERR_ERROR;\n                return;\n            }\n            if( t2p->tiff_bitspersample != 8){\n                TIFFError(\n                    TIFF2PDF_MODULE, \n                    \"Invalid bitspersample = %d for ITULAB\", \n                    t2p->tiff_bitspersample);\n                t2p->t2p_error = T2P_ERR_ERROR;\n                return;\n            }\n\t\t\tt2p->pdf_labrange[0]=-85;\n\t\t\tt2p->pdf_labrange[1]=85;\n\t\t\tt2p->pdf_labrange[2]=-75;\n\t\t\tt2p->pdf_labrange[3]=124;\n\t\t\tt2p->pdf_sample=T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;\n\t\t\tt2p->pdf_colorspace=T2P_CS_LAB;\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_LOGL:\n\t\tcase PHOTOMETRIC_LOGLUV:\n\t\t\tTIFFError(\n\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\"No support for %s with photometric interpretation LogL/LogLuv\", \n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn;\n\t\tdefault:\n\t\t\tTIFFError(\n\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\"No support for %s with photometric interpretation %u\", \n\t\t\t\tTIFFFileName(input),\n\t\t\t\tt2p->tiff_photometric);\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn;\n\t}\n\n\tif(TIFFGetField(input, TIFFTAG_PLANARCONFIG, &(t2p->tiff_planar))){\n\t\tswitch(t2p->tiff_planar){\n\t\t\tcase 0:\n\t\t\t\tTIFFWarning(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"Image %s has planar configuration 0, assuming 1\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->tiff_planar=PLANARCONFIG_CONTIG;\n\t\t\tcase PLANARCONFIG_CONTIG:\n\t\t\t\tbreak;\n\t\t\tcase PLANARCONFIG_SEPARATE:\n\t\t\t\tt2p->pdf_sample=T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG;\n\t\t\t\tif(t2p->tiff_bitspersample!=8){\n\t\t\t\t\tTIFFError(\n\t\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\t\"No support for %s with separated planar configuration and %u bits per sample\", \n\t\t\t\t\t\tTIFFFileName(input),\n\t\t\t\t\t\tt2p->tiff_bitspersample);\n\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for %s with planar configuration %u\", \n\t\t\t\t\tTIFFFileName(input),\n\t\t\t\t\tt2p->tiff_planar);\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t}\n\t}\n\n        TIFFGetFieldDefaulted(input, TIFFTAG_ORIENTATION,\n                              &(t2p->tiff_orientation));\n        if(t2p->tiff_orientation>8){\n                TIFFWarning(TIFF2PDF_MODULE,\n                            \"Image %s has orientation %u, assuming 0\",\n                            TIFFFileName(input), t2p->tiff_orientation);\n                t2p->tiff_orientation=0;\n        }\n\n        if(TIFFGetField(input, TIFFTAG_XRESOLUTION, &(t2p->tiff_xres) ) == 0){\n                t2p->tiff_xres=0.0;\n        }\n        if(TIFFGetField(input, TIFFTAG_YRESOLUTION, &(t2p->tiff_yres) ) == 0){\n                t2p->tiff_yres=0.0;\n        }\n\tTIFFGetFieldDefaulted(input, TIFFTAG_RESOLUTIONUNIT,\n\t\t\t      &(t2p->tiff_resunit));\n\tif(t2p->tiff_resunit == RESUNIT_CENTIMETER) {\n\t\tt2p->tiff_xres *= 2.54F;\n\t\tt2p->tiff_yres *= 2.54F;\n\t} else if (t2p->tiff_resunit != RESUNIT_INCH\n\t\t   && t2p->pdf_centimeters != 0) {\n\t\tt2p->tiff_xres *= 2.54F;\n\t\tt2p->tiff_yres *= 2.54F;\n\t}\n\n\tt2p_compose_pdf_page(t2p);\n        if( t2p->t2p_error == T2P_ERR_ERROR )\n\t    return;\n\n\tt2p->pdf_transcode = T2P_TRANSCODE_ENCODE;\n\tif(t2p->pdf_nopassthrough==0){\n#ifdef CCITT_SUPPORT\n\t\tif(t2p->tiff_compression==COMPRESSION_CCITTFAX4  \n\t\t\t){\n\t\t\tif(TIFFIsTiled(input) || (TIFFNumberOfStrips(input)==1) ){\n\t\t\t\tt2p->pdf_transcode = T2P_TRANSCODE_RAW;\n\t\t\t\tt2p->pdf_compression=T2P_COMPRESS_G4;\n\t\t\t}\n\t\t}\n#endif\n#ifdef ZIP_SUPPORT\n\t\tif(t2p->tiff_compression== COMPRESSION_ADOBE_DEFLATE \n\t\t\t|| t2p->tiff_compression==COMPRESSION_DEFLATE){\n\t\t\tif(TIFFIsTiled(input) || (TIFFNumberOfStrips(input)==1) ){\n\t\t\t\tt2p->pdf_transcode = T2P_TRANSCODE_RAW;\n\t\t\t\tt2p->pdf_compression=T2P_COMPRESS_ZIP;\n\t\t\t}\n\t\t}\n#endif\n#ifdef OJPEG_SUPPORT\n\t\tif(t2p->tiff_compression==COMPRESSION_OJPEG){\n\t\t\tt2p->pdf_transcode = T2P_TRANSCODE_RAW;\n\t\t\tt2p->pdf_compression=T2P_COMPRESS_JPEG;\n\t\t\tt2p_process_ojpeg_tables(t2p, input);\n\t\t}\n#endif\n#ifdef JPEG_SUPPORT\n\t\tif(t2p->tiff_compression==COMPRESSION_JPEG){\n\t\t\tt2p->pdf_transcode = T2P_TRANSCODE_RAW;\n\t\t\tt2p->pdf_compression=T2P_COMPRESS_JPEG;\n\t\t}\n#endif\n\t\t(void)0;\n\t}\n\n\tif(t2p->pdf_transcode!=T2P_TRANSCODE_RAW){\n\t\tt2p->pdf_compression = t2p->pdf_defaultcompression;\n\t}\n\n#ifdef JPEG_SUPPORT\n\tif(t2p->pdf_defaultcompression==T2P_COMPRESS_JPEG){\n\t\tif(t2p->pdf_colorspace & T2P_CS_PALETTE){\n\t\t\tt2p->pdf_sample|=T2P_SAMPLE_REALIZE_PALETTE;\n\t\t\tt2p->pdf_colorspace ^= T2P_CS_PALETTE;\n\t\t\tt2p->tiff_pages[t2p->pdf_page].page_extra--;\n\t\t}\n\t}\n\tif(t2p->tiff_compression==COMPRESSION_JPEG){\n\t\tif(t2p->tiff_planar==PLANARCONFIG_SEPARATE){\n\t\t\tTIFFError(\n\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\"No support for %s with JPEG compression and separated planar configuration\", \n\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n#ifdef OJPEG_SUPPORT\n\tif(t2p->tiff_compression==COMPRESSION_OJPEG){\n\t\tif(t2p->tiff_planar==PLANARCONFIG_SEPARATE){\n\t\t\tTIFFError(\n\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\"No support for %s with OJPEG compression and separated planar configuration\", \n\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\tif(t2p->pdf_sample & T2P_SAMPLE_REALIZE_PALETTE){\n\t\tif(t2p->pdf_colorspace & T2P_CS_CMYK){\n\t\t\tt2p->tiff_samplesperpixel=4;\n\t\t\tt2p->tiff_photometric=PHOTOMETRIC_SEPARATED;\n\t\t} else {\n\t\t\tt2p->tiff_samplesperpixel=3;\n\t\t\tt2p->tiff_photometric=PHOTOMETRIC_RGB;\n\t\t}\n\t}\n\n\tif (TIFFGetField(input, TIFFTAG_TRANSFERFUNCTION,\n\t\t\t &(t2p->tiff_transferfunction[0]),\n\t\t\t &(t2p->tiff_transferfunction[1]),\n\t\t\t &(t2p->tiff_transferfunction[2]))) {\n\t\tif((t2p->tiff_transferfunction[1] != (float*) NULL) &&\n                   (t2p->tiff_transferfunction[2] != (float*) NULL) &&\n                   (t2p->tiff_transferfunction[1] !=\n                    t2p->tiff_transferfunction[0])) {\n\t\t\tt2p->tiff_transferfunctioncount=3;\n\t\t} else {\n\t\t\tt2p->tiff_transferfunctioncount=1;\n\t\t}\n\t} else {\n\t\tt2p->tiff_transferfunctioncount=0;\n\t}\n\tif(TIFFGetField(input, TIFFTAG_WHITEPOINT, &xfloatp)!=0){\n\t\tt2p->tiff_whitechromaticities[0]=xfloatp[0];\n\t\tt2p->tiff_whitechromaticities[1]=xfloatp[1];\n\t\tif(t2p->pdf_colorspace & T2P_CS_GRAY){\n\t\t\tt2p->pdf_colorspace |= T2P_CS_CALGRAY;\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_RGB){\n\t\t\tt2p->pdf_colorspace |= T2P_CS_CALRGB;\n\t\t}\n\t}\n\tif(TIFFGetField(input, TIFFTAG_PRIMARYCHROMATICITIES, &xfloatp)!=0){\n\t\tt2p->tiff_primarychromaticities[0]=xfloatp[0];\n\t\tt2p->tiff_primarychromaticities[1]=xfloatp[1];\n\t\tt2p->tiff_primarychromaticities[2]=xfloatp[2];\n\t\tt2p->tiff_primarychromaticities[3]=xfloatp[3];\n\t\tt2p->tiff_primarychromaticities[4]=xfloatp[4];\n\t\tt2p->tiff_primarychromaticities[5]=xfloatp[5];\n\t\tif(t2p->pdf_colorspace & T2P_CS_RGB){\n\t\t\tt2p->pdf_colorspace |= T2P_CS_CALRGB;\n\t\t}\n\t}\n\tif(t2p->pdf_colorspace & T2P_CS_LAB){\n\t\tif(TIFFGetField(input, TIFFTAG_WHITEPOINT, &xfloatp) != 0){\n\t\t\tt2p->tiff_whitechromaticities[0]=xfloatp[0];\n\t\t\tt2p->tiff_whitechromaticities[1]=xfloatp[1];\n\t\t} else {\n\t\t\tt2p->tiff_whitechromaticities[0]=0.3457F; /* 0.3127F; */\n\t\t\tt2p->tiff_whitechromaticities[1]=0.3585F; /* 0.3290F; */\n\t\t}\n\t}\n\tif(TIFFGetField(input, \n\t\tTIFFTAG_ICCPROFILE, \n\t\t&(t2p->tiff_iccprofilelength), \n\t\t&(t2p->tiff_iccprofile))!=0){\n\t\tt2p->pdf_colorspace |= T2P_CS_ICCBASED;\n\t} else {\n\t\tt2p->tiff_iccprofilelength=0;\n\t\tt2p->tiff_iccprofile=NULL;\n\t}\n\t\n#ifdef CCITT_SUPPORT\n\tif( t2p->tiff_bitspersample==1 &&\n\t\tt2p->tiff_samplesperpixel==1){\n\t\tt2p->pdf_compression = T2P_COMPRESS_G4;\n\t}\n#endif\n\n\n\treturn;\n}",
        "begin_line": 1286,
        "end_line": 1913,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_read_tiff_init#1071",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_read_tiff_init(T2P* t2p, TIFF* input)",
        "snippet": "void t2p_read_tiff_init(T2P* t2p, TIFF* input){\n\n\ttdir_t directorycount=0;\n\ttdir_t i=0;\n\tuint16 pagen=0;\n\tuint16 paged=0;\n\tuint16 xuint16=0;\n\n\tdirectorycount=TIFFNumberOfDirectories(input);\n\tt2p->tiff_pages = (T2P_PAGE*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,directorycount,sizeof(T2P_PAGE)));\n\tif(t2p->tiff_pages==NULL){\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory for tiff_pages array, %s\", \n\t\t\t(TIFF_SIZE_T) directorycount * sizeof(T2P_PAGE), \n\t\t\tTIFFFileName(input));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn;\n\t}\n\t_TIFFmemset( t2p->tiff_pages, 0x00, directorycount * sizeof(T2P_PAGE));\n\tt2p->tiff_tiles = (T2P_TILES*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,directorycount,sizeof(T2P_TILES)));\n\tif(t2p->tiff_tiles==NULL){\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory for tiff_tiles array, %s\", \n\t\t\t(TIFF_SIZE_T) directorycount * sizeof(T2P_TILES), \n\t\t\tTIFFFileName(input));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn;\n\t}\n\t_TIFFmemset( t2p->tiff_tiles, 0x00, directorycount * sizeof(T2P_TILES));\n\tfor(i=0;i<directorycount;i++){\n\t\tuint32 subfiletype = 0;\n\t\t\n\t\tif(!TIFFSetDirectory(input, i)){\n\t\t\tTIFFError(\n\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\"Can't set directory %u of input file %s\", \n\t\t\t\ti,\n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn;\n\t\t}\n\t\tif(TIFFGetField(input, TIFFTAG_PAGENUMBER, &pagen, &paged)){\n\t\t\tif((pagen>paged) && (paged != 0)){\n\t\t\t\tt2p->tiff_pages[t2p->tiff_pagecount].page_number = \n\t\t\t\t\tpaged;\n\t\t\t} else {\n\t\t\t\tt2p->tiff_pages[t2p->tiff_pagecount].page_number = \n\t\t\t\t\tpagen;\n\t\t\t}\n\t\t\tgoto ispage2;\n\t\t}\n\t\tif(TIFFGetField(input, TIFFTAG_SUBFILETYPE, &subfiletype)){\n\t\t\tif ( ((subfiletype & FILETYPE_PAGE) != 0)\n                             || (subfiletype == 0)){\n\t\t\t\tgoto ispage;\n\t\t\t} else {\n\t\t\t\tgoto isnotpage;\n\t\t\t}\n\t\t}\n\t\tif(TIFFGetField(input, TIFFTAG_OSUBFILETYPE, &subfiletype)){\n\t\t\tif ((subfiletype == OFILETYPE_IMAGE) \n\t\t\t\t|| (subfiletype == OFILETYPE_PAGE)\n\t\t\t\t|| (subfiletype == 0) ){\n\t\t\t\tgoto ispage;\n\t\t\t} else {\n\t\t\t\tgoto isnotpage;\n\t\t\t}\n\t\t}\n\t\tispage:\n\t\tt2p->tiff_pages[t2p->tiff_pagecount].page_number=t2p->tiff_pagecount;\n\t\tispage2:\n\t\tt2p->tiff_pages[t2p->tiff_pagecount].page_directory=i;\n\t\tif(TIFFIsTiled(input)){\n\t\t\tt2p->tiff_pages[t2p->tiff_pagecount].page_tilecount = \n\t\t\t\tTIFFNumberOfTiles(input);\n\t\t}\n\t\tt2p->tiff_pagecount++;\n\t\tisnotpage:\n\t\t(void)0;\n\t}\n\t\n\tqsort((void*) t2p->tiff_pages, t2p->tiff_pagecount,\n              sizeof(T2P_PAGE), t2p_cmp_t2p_page);\n\n\tfor(i=0;i<t2p->tiff_pagecount;i++){\n\t\tt2p->pdf_xrefcount += 5;\n\t\tTIFFSetDirectory(input, t2p->tiff_pages[i].page_directory );\n\t\tif((TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &xuint16)\n                    && (xuint16==PHOTOMETRIC_PALETTE))\n\t\t   || TIFFGetField(input, TIFFTAG_INDEXED, &xuint16)) {\n\t\t\tt2p->tiff_pages[i].page_extra++;\n\t\t\tt2p->pdf_xrefcount++;\n\t\t}\n#ifdef ZIP_SUPPORT\n\t\tif (TIFFGetField(input, TIFFTAG_COMPRESSION, &xuint16)) {\n                        if( (xuint16== COMPRESSION_DEFLATE ||\n                             xuint16== COMPRESSION_ADOBE_DEFLATE) && \n                            ((t2p->tiff_pages[i].page_tilecount != 0) \n                             || TIFFNumberOfStrips(input)==1) &&\n                            (t2p->pdf_nopassthrough==0)\t){\n                                if(t2p->pdf_minorversion<2){t2p->pdf_minorversion=2;}\n                        }\n                }\n#endif\n\t\tif (TIFFGetField(input, TIFFTAG_TRANSFERFUNCTION,\n                                 &(t2p->tiff_transferfunction[0]),\n                                 &(t2p->tiff_transferfunction[1]),\n                                 &(t2p->tiff_transferfunction[2]))) {\n\t\t\tif((t2p->tiff_transferfunction[1] != (float*) NULL) &&\n                           (t2p->tiff_transferfunction[2] != (float*) NULL) &&\n                           (t2p->tiff_transferfunction[1] !=\n                            t2p->tiff_transferfunction[0])) {\n\t\t\t\tt2p->tiff_transferfunctioncount = 3;\n\t\t\t\tt2p->tiff_pages[i].page_extra += 4;\n\t\t\t\tt2p->pdf_xrefcount += 4;\n\t\t\t} else {\n\t\t\t\tt2p->tiff_transferfunctioncount = 1;\n\t\t\t\tt2p->tiff_pages[i].page_extra += 2;\n\t\t\t\tt2p->pdf_xrefcount += 2;\n\t\t\t}\n\t\t\tif(t2p->pdf_minorversion < 2)\n\t\t\t\tt2p->pdf_minorversion = 2;\n                } else {\n\t\t\tt2p->tiff_transferfunctioncount=0;\n\t\t}\n\t\tif( TIFFGetField(\n\t\t\tinput, \n\t\t\tTIFFTAG_ICCPROFILE, \n\t\t\t&(t2p->tiff_iccprofilelength), \n\t\t\t&(t2p->tiff_iccprofile)) != 0){\n\t\t\tt2p->tiff_pages[i].page_extra++;\n\t\t\tt2p->pdf_xrefcount++;\n\t\t\tif(t2p->pdf_minorversion<3){t2p->pdf_minorversion=3;}\n\t\t}\n\t\tt2p->tiff_tiles[i].tiles_tilecount=\n\t\t\tt2p->tiff_pages[i].page_tilecount;\n\t\tif( (TIFFGetField(input, TIFFTAG_PLANARCONFIG, &xuint16) != 0)\n\t\t\t&& (xuint16 == PLANARCONFIG_SEPARATE ) ){\n\t\t\t\tif( !TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &xuint16) )\n\t\t\t\t{\n\t\t\t\t\tTIFFError(\n                        TIFF2PDF_MODULE, \n                        \"Missing SamplesPerPixel, %s\", \n                        TIFFFileName(input));\n                    t2p->t2p_error = T2P_ERR_ERROR;\n                    return;\n\t\t\t\t}\n                if( (t2p->tiff_tiles[i].tiles_tilecount % xuint16) != 0 )\n                {\n                    TIFFError(\n                        TIFF2PDF_MODULE, \n                        \"Invalid tile count, %s\", \n                        TIFFFileName(input));\n                    t2p->t2p_error = T2P_ERR_ERROR;\n                    return;\n                }\n\t\t\t\tt2p->tiff_tiles[i].tiles_tilecount/= xuint16;\n\t\t}\n\t\tif( t2p->tiff_tiles[i].tiles_tilecount > 0){\n\t\t\tt2p->pdf_xrefcount += \n\t\t\t\t(t2p->tiff_tiles[i].tiles_tilecount -1)*2;\n\t\t\tTIFFGetField(input, \n\t\t\t\tTIFFTAG_TILEWIDTH, \n\t\t\t\t&( t2p->tiff_tiles[i].tiles_tilewidth) );\n\t\t\tTIFFGetField(input, \n\t\t\t\tTIFFTAG_TILELENGTH, \n\t\t\t\t&( t2p->tiff_tiles[i].tiles_tilelength) );\n\t\t\tt2p->tiff_tiles[i].tiles_tiles = \n\t\t\t(T2P_TILE*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->tiff_tiles[i].tiles_tilecount,\n                                                                 sizeof(T2P_TILE)) );\n\t\t\tif( t2p->tiff_tiles[i].tiles_tiles == NULL){\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory for t2p_read_tiff_init, %s\", \n\t\t\t\t\t(TIFF_SIZE_T) t2p->tiff_tiles[i].tiles_tilecount * sizeof(T2P_TILE), \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n}",
        "begin_line": 1071,
        "end_line": 1256,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_read_tiff_size_tile#2065",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_read_tiff_size_tile(T2P* t2p, TIFF* input, ttile_t tile)",
        "snippet": "void t2p_read_tiff_size_tile(T2P* t2p, TIFF* input, ttile_t tile){\n\n\tuint64* tbc = NULL;\n\tuint16 edge=0;\n#ifdef JPEG_SUPPORT\n\tunsigned char* jpt;\n#endif\n        uint64 k;\n\n\tedge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\tedge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\t\n\tif(t2p->pdf_transcode==T2P_TRANSCODE_RAW){\n\t\tif(edge\n#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)\n\t\t&& !(t2p->pdf_compression==T2P_COMPRESS_JPEG)\n#endif\n\t\t){\n\t\t\tt2p->tiff_datasize=TIFFTileSize(input);\n\t\t\tif (t2p->tiff_datasize == 0) {\n\t\t\t\t/* Assume we had overflow inside TIFFTileSize */\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t}\n\t\t\treturn;\n\t\t} else {\n\t\t\tTIFFGetField(input, TIFFTAG_TILEBYTECOUNTS, &tbc);\n\t\t\tk=tbc[tile];\n#ifdef OJPEG_SUPPORT\n\t\t\tif(t2p->tiff_compression==COMPRESSION_OJPEG){\n\t\t\t  \tk = checkAdd64(k, 2048, t2p);\n\t\t\t}\n#endif\n#ifdef JPEG_SUPPORT\n\t\t\tif(t2p->tiff_compression==COMPRESSION_JPEG) {\n\t\t\t\tuint32 count = 0;\n\t\t\t\tif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt)!=0){\n\t\t\t\t\tif(count > 4){\n\t\t\t\t\t\tk = checkAdd64(k, count, t2p);\n\t\t\t\t\t\tk -= 2; /* don't use EOI of header or SOI of tile */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tt2p->tiff_datasize = (tsize_t) k;\n\t\t\tif ((uint64) t2p->tiff_datasize != k) {\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \"Integer overflow\");\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\tk = TIFFTileSize(input);\n\tif(t2p->tiff_planar==PLANARCONFIG_SEPARATE){\n\t\tk = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);\n\t}\n\tif (k == 0) {\n\t\t/* Assume we had overflow inside TIFFTileSize */\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t}\n\n\tt2p->tiff_datasize = (tsize_t) k;\n\tif ((uint64) t2p->tiff_datasize != k) {\n\t\tTIFFError(TIFF2PDF_MODULE, \"Integer overflow\");\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t}\n\n\treturn;\n}",
        "begin_line": 2065,
        "end_line": 2132,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_readwrite_pdf_image_tile#2789",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile)",
        "snippet": "tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){\n\n\tuint16 edge=0;\n\ttsize_t written=0;\n\tunsigned char* buffer=NULL;\n\ttsize_t bufferoffset=0;\n\tunsigned char* samplebuffer=NULL;\n\ttsize_t samplebufferoffset=0;\n\ttsize_t read=0;\n\tuint16 i=0;\n\tttile_t tilecount=0;\n\t/* tsize_t tilesize=0; */\n\tttile_t septilecount=0;\n\ttsize_t septilesize=0;\n#ifdef JPEG_SUPPORT\n\tunsigned char* jpt;\n\tfloat* xfloatp;\n\tuint32 xuint32=0;\n#endif\n\n\t/* Fail if prior error (in particular, can't trust tiff_datasize) */\n\tif (t2p->t2p_error != T2P_ERR_OK)\n\t\treturn(0);\n\n\tedge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\tedge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\n\tif( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0)\n#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)\n\t\t|| (t2p->pdf_compression == T2P_COMPRESS_JPEG)\n#endif\n\t)\n\t){\n#ifdef CCITT_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_G4){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef ZIP_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_ZIP){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef OJPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_OJPEG){\n\t\t\tif(! t2p->pdf_ojpegdata){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for OJPEG image %s with \"\n                                        \"bad tables\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbuffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);\n\t\t\tif(edge!=0){\n\t\t\t\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[7]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff;\n\t\t\t\t\tbuffer[8]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff;\n\t\t\t\t}\n\t\t\t\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[9]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff;\n\t\t\t\t\tbuffer[10]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbufferoffset=t2p->pdf_ojpegdatalength;\n\t\t\tbufferoffset+=TIFFReadRawTile(input, \n\t\t\t\t\ttile, \n\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t-1);\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xff;\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xd9;\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif\n#ifdef JPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_JPEG){\n\t\t\tunsigned char table_end[2];\n\t\t\tuint32 count = 0;\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n                                          (TIFF_SIZE_T) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\n\t\t\t\tif (count >= 4) {\n                                        int retTIFFReadRawTile;\n                    /* Ignore EOI marker of JpegTables */\n\t\t\t\t\t_TIFFmemcpy(buffer, jpt, count - 2);\n\t\t\t\t\tbufferoffset += count - 2;\n                    /* Store last 2 bytes of the JpegTables */\n\t\t\t\t\ttable_end[0] = buffer[bufferoffset-2];\n\t\t\t\t\ttable_end[1] = buffer[bufferoffset-1];\n\t\t\t\t\txuint32 = bufferoffset;\n                                        bufferoffset -= 2;\n                                        retTIFFReadRawTile= TIFFReadRawTile(\n\t\t\t\t\t\tinput, \n\t\t\t\t\t\ttile, \n\t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t\t-1);\n                                        if( retTIFFReadRawTile < 0 )\n                                        {\n                                            _TIFFfree(buffer);\n                                            t2p->t2p_error = T2P_ERR_ERROR;\n                                            return(0);\n                                        }\n\t\t\t\t\tbufferoffset += retTIFFReadRawTile;\n                    /* Overwrite SOI marker of image scan with previously */\n                    /* saved end of JpegTables */\n\t\t\t\t\tbuffer[xuint32-2]=table_end[0];\n\t\t\t\t\tbuffer[xuint32-1]=table_end[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif\n\t\t(void)0;\n\t}\n\n\tif(t2p->pdf_sample==T2P_SAMPLE_NOTHING){\n\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\tif(buffer==NULL){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Can't allocate %lu bytes of memory for \"\n                                \"t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t\tread = TIFFReadEncodedTile(\n\t\t\tinput, \n\t\t\ttile, \n\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\tt2p->tiff_datasize);\n\t\tif(read==-1){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\ttile, \n\t\t\t\tTIFFFileName(input));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t} else {\n\n\t\tif(t2p->pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){\n\t\t\tseptilesize=TIFFTileSize(input);\n\t\t\tseptilecount=TIFFNumberOfTiles(input);\n\t\t\t/* tilesize=septilesize*t2p->tiff_samplesperpixel; */\n\t\t\ttilecount=septilecount/t2p->tiff_samplesperpixel;\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsamplebuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(samplebuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsamplebufferoffset=0;\n\t\t\tfor(i=0;i<t2p->tiff_samplesperpixel;i++){\n\t\t\t\tread = \n\t\t\t\t\tTIFFReadEncodedTile(input, \n\t\t\t\t\t\ttile + i*tilecount, \n\t\t\t\t\t\t(tdata_t) &(samplebuffer[samplebufferoffset]), \n\t\t\t\t\t\tseptilesize);\n\t\t\t\tif(read==-1){\n\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\t\t\ttile + i*tilecount, \n\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\t\t_TIFFfree(samplebuffer);\n\t\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsamplebufferoffset+=read;\n\t\t\t}\n\t\t\tt2p_sample_planar_separate_to_contig(\n\t\t\t\tt2p,\n\t\t\t\t&(buffer[bufferoffset]),\n\t\t\t\tsamplebuffer, \n\t\t\t\tsamplebufferoffset); \n\t\t\tbufferoffset+=samplebufferoffset;\n\t\t\t_TIFFfree(samplebuffer);\n\t\t}\n\n\t\tif(buffer==NULL){\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tread = TIFFReadEncodedTile(\n\t\t\t\tinput, \n\t\t\t\ttile, \n\t\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\t\tt2p->tiff_datasize);\n\t\t\tif(read==-1){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\t\ttile, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgba_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"No support for YCbCr to RGB in tile for %s\", \n\t\t\t\tTIFFFileName(input));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){\n\t\t\tt2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\t}\n\n\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) != 0){\n\t\tt2p_tile_collapse_left(\n\t\t\tbuffer, \n\t\t\tTIFFTileRowSize(input),\n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth,\n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t}\n\n\n\tt2p_disable(output);\n\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);\n\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);\n\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);\n\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGEWIDTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);\n\t} else {\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGEWIDTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);\n\t}\n\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGELENGTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_ROWSPERSTRIP, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t} else {\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGELENGTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_ROWSPERSTRIP, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t}\n\tTIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\n\tswitch(t2p->pdf_compression){\n\tcase T2P_COMPRESS_NONE:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t\tbreak;\n#ifdef CCITT_SUPPORT\n\tcase T2P_COMPRESS_G4:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\n\t\tbreak;\n#endif\n#ifdef JPEG_SUPPORT\n\tcase T2P_COMPRESS_JPEG:\n\t\tif (t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {\n\t\t\tuint16 hor = 0, ver = 0;\n\t\t\tif (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver)!=0) {\n\t\t\t\tif (hor != 0 && ver != 0) {\n\t\t\t\t\tTIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){\n\t\t\t\tTIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);\n\t\t\t}\n\t\t}\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n\t\tTIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0); /* JPEGTABLESMODE_NONE */\n\t\tif(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){\n\t\t\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n\t\t\tif(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t\t\t} else {\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n\t\t\t}\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_GRAY){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_CMYK){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_JPEGQUALITY, \n\t\t\t\tt2p->pdf_defaultcompressionquality);\n\t\t}\n\t\tbreak;\n#endif\n#ifdef ZIP_SUPPORT\n\tcase T2P_COMPRESS_ZIP:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n\t\tif(t2p->pdf_defaultcompressionquality%100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_PREDICTOR, \n\t\t\t\tt2p->pdf_defaultcompressionquality % 100);\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality/100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_ZIPQUALITY, \n\t\t\t\t(t2p->pdf_defaultcompressionquality / 100));\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tt2p_enable(output);\n\tt2p->outputwritten = 0;\n\tbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t) 0, buffer,\n\t\t\t\t\t     TIFFStripSize(output)); \n\tif (buffer != NULL) {\n\t\t_TIFFfree(buffer);\n\t\tbuffer = NULL;\n\t}\n\tif (bufferoffset == -1) {\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t  \"Error writing encoded tile to output PDF %s\", \n\t\t\t  TIFFFileName(output));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn(0);\n\t}\n\t\n\twritten = t2p->outputwritten;\n\t\n\treturn(written);\n}",
        "begin_line": 2789,
        "end_line": 3232,
        "is_bug": true
    },
    {
        "name": "tools.tiff2pdf.t2p_seekproc#412",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_seekproc(thandle_t handle, uint64 offset, int whence)",
        "snippet": "static uint64 \nt2p_seekproc(thandle_t handle, uint64 offset, int whence) \n{ \n\tT2P *t2p = (T2P*) handle;\n\tif (t2p->outputdisable <= 0 && t2p->outputfile)\n\t\treturn _TIFF_fseek_f(t2p->outputfile, (_TIFF_off_t) offset, whence);\n\treturn offset;\n}",
        "begin_line": 412,
        "end_line": 419,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_tile_is_bottom_edge#2154",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_tile_is_bottom_edge(T2P_TILES tiles, ttile_t tile)",
        "snippet": "int t2p_tile_is_bottom_edge(T2P_TILES tiles, ttile_t tile){\n\n\tif( ((tile+1) > (tiles.tiles_tilecount-tiles.tiles_tilecountx) )\n\t\t&& (tiles.tiles_edgetilelength != 0) ){\n\t\treturn(1);\n\t} else {\n\t\treturn(0);\n\t}\n}",
        "begin_line": 2154,
        "end_line": 2162,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_tile_is_right_edge#2139",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_tile_is_right_edge(T2P_TILES tiles, ttile_t tile)",
        "snippet": "int t2p_tile_is_right_edge(T2P_TILES tiles, ttile_t tile){\n\n\tif( ((tile+1) % tiles.tiles_tilecountx == 0) \n\t\t&& (tiles.tiles_edgetilewidth != 0) ){\n\t\treturn(1);\n\t} else {\n\t\treturn(0);\n\t}\n}",
        "begin_line": 2139,
        "end_line": 2147,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_validate#1029",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_validate(T2P* t2p)",
        "snippet": "void t2p_validate(T2P* t2p){\n\n#ifdef JPEG_SUPPORT\n\tif(t2p->pdf_defaultcompression==T2P_COMPRESS_JPEG){\n\t\tif(t2p->pdf_defaultcompressionquality>100 ||\n\t\t\tt2p->pdf_defaultcompressionquality<1){\n\t\t\tt2p->pdf_defaultcompressionquality=0;\n\t\t}\n\t}\n#endif\n#ifdef ZIP_SUPPORT\n\tif(t2p->pdf_defaultcompression==T2P_COMPRESS_ZIP){\n \t\tuint16 m=t2p->pdf_defaultcompressionquality%100;\n \t\tif(t2p->pdf_defaultcompressionquality/100 > 9 ||\n \t\t\t(m>1 && m<10) || m>15){\n \t\t\tt2p->pdf_defaultcompressionquality=0;\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality%100 !=0){\n \t\t\tt2p->pdf_defaultcompressionquality/=100;\n \t\t\tt2p->pdf_defaultcompressionquality*=100;\n\t\t\tTIFFError(\n\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\"PNG Group predictor differencing not implemented, assuming compression quality %u\", \n\t\t\t\tt2p->pdf_defaultcompressionquality);\n\t\t}\n\t\tt2p->pdf_defaultcompressionquality%=100;\n\t\tif(t2p->pdf_minorversion<2){t2p->pdf_minorversion=2;}\n\t}\n#endif\n\t(void)0;\n\n\treturn;\n}",
        "begin_line": 1029,
        "end_line": 1061,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_write_pdf#5443",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_write_pdf(T2P* t2p, TIFF* input, TIFF* output)",
        "snippet": "tsize_t t2p_write_pdf(T2P* t2p, TIFF* input, TIFF* output){\n\n\ttsize_t written=0;\n\tttile_t i2=0;\n\ttsize_t streamlen=0;\n\tuint16 i=0;\n\n\tt2p_read_tiff_init(t2p, input);\n\tif(t2p->t2p_error!=T2P_ERR_OK){return(0);}\n\tt2p->pdf_xrefoffsets= (uint32*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_xrefcount,sizeof(uint32)) );\n\tif(t2p->pdf_xrefoffsets==NULL){\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"Can't allocate %u bytes of memory for t2p_write_pdf\", \n\t\t\t(unsigned int) (t2p->pdf_xrefcount * sizeof(uint32)) );\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn(written);\n\t}\n\tt2p->pdf_xrefcount=0;\n\tt2p->pdf_catalog=1;\n\tt2p->pdf_info=2;\n\tt2p->pdf_pages=3;\n\twritten += t2p_write_pdf_header(t2p, output);\n\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\tt2p->pdf_catalog=t2p->pdf_xrefcount;\n\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\twritten += t2p_write_pdf_catalog(t2p, output);\n\twritten += t2p_write_pdf_obj_end(output);\n\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\tt2p->pdf_info=t2p->pdf_xrefcount;\n\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\twritten += t2p_write_pdf_info(t2p, input, output);\n\twritten += t2p_write_pdf_obj_end(output);\n\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\tt2p->pdf_pages=t2p->pdf_xrefcount;\n\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\twritten += t2p_write_pdf_pages(t2p, output);\n\twritten += t2p_write_pdf_obj_end(output);\n\tfor(t2p->pdf_page=0;t2p->pdf_page<t2p->tiff_pagecount;t2p->pdf_page++){\n\t\tt2p_read_tiff_data(t2p, input);\n\t\tif(t2p->t2p_error!=T2P_ERR_OK){return(0);}\n\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\t\twritten += t2p_write_pdf_page(t2p->pdf_xrefcount, t2p, output);\n\t\twritten += t2p_write_pdf_obj_end(output);\n\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\t\twritten += t2p_write_pdf_stream_dict_start(output);\n\t\twritten += t2p_write_pdf_stream_dict(0, t2p->pdf_xrefcount+1, output);\n\t\twritten += t2p_write_pdf_stream_dict_end(output);\n\t\twritten += t2p_write_pdf_stream_start(output);\n\t\tstreamlen=written;\n\t\twritten += t2p_write_pdf_page_content_stream(t2p, output);\n\t\tstreamlen=written-streamlen;\n\t\twritten += t2p_write_pdf_stream_end(output);\n\t\twritten += t2p_write_pdf_obj_end(output);\n\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\t\twritten += t2p_write_pdf_stream_length(streamlen, output);\n\t\twritten += t2p_write_pdf_obj_end(output);\n\t\tif(t2p->tiff_transferfunctioncount != 0){\n\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\t\t\twritten += t2p_write_pdf_transfer(t2p, output);\n\t\t\twritten += t2p_write_pdf_obj_end(output);\n\t\t\tfor(i=0; i < t2p->tiff_transferfunctioncount; i++){\n\t\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\t\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\t\t\t\twritten += t2p_write_pdf_stream_dict_start(output);\n\t\t\t\twritten += t2p_write_pdf_transfer_dict(t2p, output, i);\n\t\t\t\twritten += t2p_write_pdf_stream_dict_end(output);\n\t\t\t\twritten += t2p_write_pdf_stream_start(output);\n\t\t\t\t/* streamlen=written; */ /* value not used */\n\t\t\t\twritten += t2p_write_pdf_transfer_stream(t2p, output, i);\n\t\t\t\t/* streamlen=written-streamlen; */ /* value not used */\n\t\t\t\twritten += t2p_write_pdf_stream_end(output);\n\t\t\t\twritten += t2p_write_pdf_obj_end(output);\n\t\t\t}\n\t\t}\n\t\tif( (t2p->pdf_colorspace & T2P_CS_PALETTE) != 0){\n\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\t\t\tt2p->pdf_palettecs=t2p->pdf_xrefcount;\n\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\t\t\twritten += t2p_write_pdf_stream_dict_start(output);\n\t\t\twritten += t2p_write_pdf_stream_dict(t2p->pdf_palettesize, 0, output);\n\t\t\twritten += t2p_write_pdf_stream_dict_end(output);\n\t\t\twritten += t2p_write_pdf_stream_start(output);\n\t\t\t/* streamlen=written; */ /* value not used */\n\t\t\twritten += t2p_write_pdf_xobject_palettecs_stream(t2p, output);\n\t\t\t/* streamlen=written-streamlen; */ /* value not used */\n\t\t\twritten += t2p_write_pdf_stream_end(output);\n\t\t\twritten += t2p_write_pdf_obj_end(output);\n\t\t}\n\t\tif( (t2p->pdf_colorspace & T2P_CS_ICCBASED) != 0){\n\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\t\t\tt2p->pdf_icccs=t2p->pdf_xrefcount;\n\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\t\t\twritten += t2p_write_pdf_stream_dict_start(output);\n\t\t\twritten += t2p_write_pdf_xobject_icccs_dict(t2p, output);\n\t\t\twritten += t2p_write_pdf_stream_dict_end(output);\n\t\t\twritten += t2p_write_pdf_stream_start(output);\n\t\t\t/* streamlen=written; */ /* value not used */\n\t\t\twritten += t2p_write_pdf_xobject_icccs_stream(t2p, output);\n\t\t\t/* streamlen=written-streamlen; */ /* value not used */\n\t\t\twritten += t2p_write_pdf_stream_end(output);\n\t\t\twritten += t2p_write_pdf_obj_end(output);\n\t\t}\n\t\tif(t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount !=0){\n\t\t\tfor(i2=0;i2<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount;i2++){\n\t\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\t\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\t\t\t\twritten += t2p_write_pdf_stream_dict_start(output);\n\t\t\t\twritten += t2p_write_pdf_xobject_stream_dict(\n\t\t\t\t\ti2+1, \n\t\t\t\t\tt2p, \n\t\t\t\t\toutput);\n\t\t\t\twritten += t2p_write_pdf_stream_dict_end(output);\n\t\t\t\twritten += t2p_write_pdf_stream_start(output);\n\t\t\t\tstreamlen=written;\n\t\t\t\tt2p_read_tiff_size_tile(t2p, input, i2);\n\t\t\t\twritten += t2p_readwrite_pdf_image_tile(t2p, input, output, i2);\n\t\t\t\tt2p_write_advance_directory(t2p, output);\n\t\t\t\tif(t2p->t2p_error!=T2P_ERR_OK){return(0);}\n\t\t\t\tstreamlen=written-streamlen;\n\t\t\t\twritten += t2p_write_pdf_stream_end(output);\n\t\t\t\twritten += t2p_write_pdf_obj_end(output);\n\t\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\t\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\t\t\t\twritten += t2p_write_pdf_stream_length(streamlen, output);\n\t\t\t\twritten += t2p_write_pdf_obj_end(output);\n\t\t\t}\n\t\t} else {\n\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\t\t\twritten += t2p_write_pdf_stream_dict_start(output);\n\t\t\twritten += t2p_write_pdf_xobject_stream_dict(\n\t\t\t\t0, \n\t\t\t\tt2p, \n\t\t\t\toutput);\n\t\t\twritten += t2p_write_pdf_stream_dict_end(output);\n\t\t\twritten += t2p_write_pdf_stream_start(output);\n\t\t\tstreamlen=written;\n\t\t\tt2p_read_tiff_size(t2p, input);\n\t\t\twritten += t2p_readwrite_pdf_image(t2p, input, output);\n\t\t\tt2p_write_advance_directory(t2p, output);\n\t\t\tif(t2p->t2p_error!=T2P_ERR_OK){return(0);}\n\t\t\tstreamlen=written-streamlen;\n\t\t\twritten += t2p_write_pdf_stream_end(output);\n\t\t\twritten += t2p_write_pdf_obj_end(output);\n\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\t\t\twritten += t2p_write_pdf_stream_length(streamlen, output);\n\t\t\twritten += t2p_write_pdf_obj_end(output);\n\t\t}\n\t}\n\tt2p->pdf_startxref = written;\n\twritten += t2p_write_pdf_xreftable(t2p, output);\n\twritten += t2p_write_pdf_trailer(t2p, output);\n\tt2p_disable(output);\n\n\treturn(written);\n}",
        "begin_line": 5443,
        "end_line": 5604,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_write_pdf_catalog#4110",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_write_pdf_catalog(T2P* t2p, TIFF* output)",
        "snippet": "tsize_t t2p_write_pdf_catalog(T2P* t2p, TIFF* output)\n{\n\ttsize_t written = 0;\n\tchar buffer[32];\n\tint buflen = 0;\n\n\twritten += t2pWriteFile(output, \n\t\t(tdata_t)\"<< \\n/Type /Catalog \\n/Pages \", \n\t\t27);\n\tbuflen = snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)t2p->pdf_pages);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer,\n\t\t\t\tTIFFmin((size_t)buflen, sizeof(buffer) - 1));\n\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \\n\", 6);\n\tif(t2p->pdf_fitwindow){\n\t\twritten += t2pWriteFile(output, \n\t\t\t(tdata_t) \"/ViewerPreferences <</FitWindow true>>\\n\", \n\t\t\t39);\n\t}\n\twritten += t2pWriteFile(output, (tdata_t)\">>\\n\", 3);\n\n\treturn(written);\n}",
        "begin_line": 4110,
        "end_line": 4132,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_write_pdf_header#3801",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_write_pdf_header(T2P* t2p, TIFF* output)",
        "snippet": "tsize_t t2p_write_pdf_header(T2P* t2p, TIFF* output){\n\n\ttsize_t written=0;\n\tchar buffer[16];\n\tint buflen=0;\n\t\n\tbuflen = snprintf(buffer, sizeof(buffer), \"%%PDF-%u.%u \",\n\t\t\t  t2p->pdf_majorversion&0xff,\n\t\t\t  t2p->pdf_minorversion&0xff);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t)\"\\n%\\342\\343\\317\\323\\n\", 7);\n\n\treturn(written);\n}",
        "begin_line": 3801,
        "end_line": 3815,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_write_pdf_info#4138",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_write_pdf_info(T2P* t2p, TIFF* input, TIFF* output)",
        "snippet": "tsize_t t2p_write_pdf_info(T2P* t2p, TIFF* input, TIFF* output)\n{\n\ttsize_t written = 0;\n\tchar* info;\n\tchar buffer[512];\n\n\tif(t2p->pdf_datetime[0] == '\\0')\n\t\tt2p_pdf_tifftime(t2p, input);\n\tif (strlen(t2p->pdf_datetime) > 0) {\n\t\twritten += t2pWriteFile(output, (tdata_t) \"<< \\n/CreationDate \", 18);\n\t\twritten += t2p_write_pdf_string(t2p->pdf_datetime, output);\n\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n/ModDate \", 10);\n\t\twritten += t2p_write_pdf_string(t2p->pdf_datetime, output);\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \"\\n/Producer \", 11);\n\tsnprintf(buffer, sizeof(buffer), \"libtiff / tiff2pdf - %d\", TIFFLIB_VERSION);\n\twritten += t2p_write_pdf_string(buffer, output);\n\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\tif (t2p->pdf_creator[0] != '\\0') {\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/Creator \", 9);\n\t\twritten += t2p_write_pdf_string(t2p->pdf_creator, output);\n\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\t} else {\n\t\tif (TIFFGetField(input, TIFFTAG_SOFTWARE, &info) != 0 && info) {\n\t\t\tif(strlen(info) >= sizeof(t2p->pdf_creator))\n\t\t\t\tinfo[sizeof(t2p->pdf_creator) - 1] = '\\0';\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/Creator \", 9);\n\t\t\twritten += t2p_write_pdf_string(info, output);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\t\t}\n\t}\n\tif (t2p->pdf_author[0] != '\\0') {\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/Author \", 8);\n\t\twritten += t2p_write_pdf_string(t2p->pdf_author, output);\n\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\t} else {\n\t\tif ((TIFFGetField(input, TIFFTAG_ARTIST, &info) != 0\n\t\t     || TIFFGetField(input, TIFFTAG_COPYRIGHT, &info) != 0)\n\t\t    && info) {\n\t\t\tif (strlen(info) >= sizeof(t2p->pdf_author))\n\t\t\t\tinfo[sizeof(t2p->pdf_author) - 1] = '\\0';\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/Author \", 8);\n\t\t\twritten += t2p_write_pdf_string(info, output);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\t\t}\n\t}\n\tif (t2p->pdf_title[0] != '\\0') {\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/Title \", 7);\n\t\twritten += t2p_write_pdf_string(t2p->pdf_title, output);\n\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\t} else {\n\t\tif (TIFFGetField(input, TIFFTAG_DOCUMENTNAME, &info) != 0){\n\t\t\tif(strlen(info) > 511) {\n\t\t\t\tinfo[512] = '\\0';\n\t\t\t}\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/Title \", 7);\n\t\t\twritten += t2p_write_pdf_string(info, output);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\t\t}\n\t}\n\tif (t2p->pdf_subject[0] != '\\0') {\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/Subject \", 9);\n\t\twritten += t2p_write_pdf_string(t2p->pdf_subject, output);\n\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\t} else {\n\t\tif (TIFFGetField(input, TIFFTAG_IMAGEDESCRIPTION, &info) != 0 && info) {\n\t\t\tif (strlen(info) >= sizeof(t2p->pdf_subject))\n\t\t\t\tinfo[sizeof(t2p->pdf_subject) - 1] = '\\0';\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/Subject \", 9);\n\t\t\twritten += t2p_write_pdf_string(info, output);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\t\t}\n\t}\n\tif (t2p->pdf_keywords[0] != '\\0') {\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/Keywords \", 10);\n\t\twritten += t2p_write_pdf_string(t2p->pdf_keywords, output);\n\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \">> \\n\", 4);\n\n\treturn(written);\n}",
        "begin_line": 4138,
        "end_line": 4219,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_write_pdf_obj_end#3839",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_write_pdf_obj_end(TIFF* output)",
        "snippet": "tsize_t t2p_write_pdf_obj_end(TIFF* output){\n\n\ttsize_t written=0;\n\n\twritten += t2pWriteFile(output, (tdata_t) \"endobj\\n\", 7);\n\n\treturn(written);\n}",
        "begin_line": 3839,
        "end_line": 3846,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_write_pdf_obj_start#3821",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_write_pdf_obj_start(uint32 number, TIFF* output)",
        "snippet": "tsize_t t2p_write_pdf_obj_start(uint32 number, TIFF* output){\n\n\ttsize_t written=0;\n\tchar buffer[32];\n\tint buflen=0;\n\n\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)number);\n\tcheck_snprintf_ret((T2P*)NULL, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen );\n\twritten += t2pWriteFile(output, (tdata_t) \" 0 obj\\n\", 7);\n\n\treturn(written);\n}",
        "begin_line": 3821,
        "end_line": 3833,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_write_pdf_page#4329",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_write_pdf_page(uint32 object, T2P* t2p, TIFF* output)",
        "snippet": "tsize_t t2p_write_pdf_page(uint32 object, T2P* t2p, TIFF* output){\n\n\tunsigned int i=0;\n\ttsize_t written=0;\n\tchar buffer[256];\n\tint buflen=0;\n\n\twritten += t2pWriteFile(output, (tdata_t) \"<<\\n/Type /Page \\n/Parent \", 24);\n\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)t2p->pdf_pages);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \\n\", 6);\n\twritten += t2pWriteFile(output, (tdata_t) \"/MediaBox [\", 11); \n\tbuflen=snprintf(buffer, sizeof(buffer), \"%.4f\",t2p->pdf_mediabox.x1);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \" \", 1); \n\tbuflen=snprintf(buffer, sizeof(buffer), \"%.4f\",t2p->pdf_mediabox.y1);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \" \", 1); \n\tbuflen=snprintf(buffer, sizeof(buffer), \"%.4f\",t2p->pdf_mediabox.x2);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \" \", 1); \n\tbuflen=snprintf(buffer, sizeof(buffer), \"%.4f\",t2p->pdf_mediabox.y2);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \"] \\n\", 3); \n\twritten += t2pWriteFile(output, (tdata_t) \"/Contents \", 10);\n\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)(object + 1));\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \\n\", 6);\n\twritten += t2pWriteFile(output, (tdata_t) \"/Resources << \\n\", 15);\n\tif( t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount != 0 ){\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/XObject <<\\n\", 12);\n\t\tfor(i=0;i<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount;i++){\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/Im\", 3);\n\t\t\tbuflen = snprintf(buffer, sizeof(buffer), \"%u\", t2p->pdf_page+1);\n\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"_\", 1);\n\t\t\tbuflen = snprintf(buffer, sizeof(buffer), \"%u\", i+1);\n\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \" \", 1);\n\t\t\tbuflen = snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t(unsigned long)(object+3+(2*i)+t2p->tiff_pages[t2p->pdf_page].page_extra)); \n\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \", 5);\n\t\t\tif(i%4==3){\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\t\t\t}\n\t\t}\n\t\twritten += t2pWriteFile(output, (tdata_t) \">>\\n\", 3);\n\t} else {\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/XObject <<\\n\", 12);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/Im\", 3);\n\t\t\tbuflen = snprintf(buffer, sizeof(buffer), \"%u\", t2p->pdf_page+1);\n\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \" \", 1);\n\t\t\tbuflen = snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t(unsigned long)(object+3+(2*i)+t2p->tiff_pages[t2p->pdf_page].page_extra)); \n\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \", 5);\n\t\twritten += t2pWriteFile(output, (tdata_t) \">>\\n\", 3);\n\t}\n\tif(t2p->tiff_transferfunctioncount != 0) {\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/ExtGState <<\", 13);\n\t\tt2pWriteFile(output, (tdata_t) \"/GS1 \", 5);\n\t\tbuflen = snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t(unsigned long)(object + 3)); \n\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \", 5);\n\t\twritten += t2pWriteFile(output, (tdata_t) \">> \\n\", 4);\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \"/ProcSet [ \", 11);\n\tif(t2p->pdf_colorspace & T2P_CS_BILEVEL \n\t\t|| t2p->pdf_colorspace & T2P_CS_GRAY\n\t\t){\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/ImageB \", 8);\n\t} else {\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/ImageC \", 8);\n\t\tif(t2p->pdf_colorspace & T2P_CS_PALETTE){\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/ImageI \", 8);\n\t\t}\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \"]\\n>>\\n>>\\n\", 8);\n\n\treturn(written);\n}",
        "begin_line": 4329,
        "end_line": 4424,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_write_pdf_page_content_stream#4775",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_write_pdf_page_content_stream(T2P* t2p, TIFF* output)",
        "snippet": "tsize_t t2p_write_pdf_page_content_stream(T2P* t2p, TIFF* output){\n\n\ttsize_t written=0;\n\tttile_t i=0;\n\tchar buffer[512];\n\tint buflen=0;\n\tT2P_BOX box;\n\t\n\tif(t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount>0){ \n\t\tfor(i=0;i<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount; i++){\n\t\t\tbox=t2p->tiff_tiles[t2p->pdf_page].tiles_tiles[i].tile_box;\n\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \n\t\t\t\t\"q %s %.4f %.4f %.4f %.4f %.4f %.4f cm /Im%d_%ld Do Q\\n\", \n\t\t\t\tt2p->tiff_transferfunctioncount?\"/GS1 gs \":\"\",\n\t\t\t\tbox.mat[0],\n\t\t\t\tbox.mat[1],\n\t\t\t\tbox.mat[3],\n\t\t\t\tbox.mat[4],\n\t\t\t\tbox.mat[6],\n\t\t\t\tbox.mat[7],\n\t\t\t\tt2p->pdf_page + 1, \n\t\t\t\t(long)(i + 1));\n\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\twritten += t2p_write_pdf_stream(buffer, buflen, output);\n\t\t}\n\t} else {\n\t\tbox=t2p->pdf_imagebox;\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \n\t\t\t\"q %s %.4f %.4f %.4f %.4f %.4f %.4f cm /Im%d Do Q\\n\", \n\t\t\tt2p->tiff_transferfunctioncount?\"/GS1 gs \":\"\",\n\t\t\tbox.mat[0],\n\t\t\tbox.mat[1],\n\t\t\tbox.mat[3],\n\t\t\tbox.mat[4],\n\t\t\tbox.mat[6],\n\t\t\tbox.mat[7],\n\t\t\tt2p->pdf_page+1);\n\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\twritten += t2p_write_pdf_stream(buffer, buflen, output);\n\t}\n\n\treturn(written);\n}",
        "begin_line": 4775,
        "end_line": 4817,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_write_pdf_pages#4289",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_write_pdf_pages(T2P* t2p, TIFF* output)",
        "snippet": "tsize_t t2p_write_pdf_pages(T2P* t2p, TIFF* output)\n{\n\ttsize_t written=0;\n\ttdir_t i=0;\n\tchar buffer[32];\n\tint buflen=0;\n\n\tint page=0;\n\twritten += t2pWriteFile(output,\n\t\t(tdata_t) \"<< \\n/Type /Pages \\n/Kids [ \", 26);\n\tpage = t2p->pdf_pages+1;\n\tfor (i=0;i<t2p->tiff_pagecount;i++){\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%d\", page);\n\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \", 5);\n\t\tif ( ((i+1)%8)==0 ) {\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\t\t}\n\t\tpage +=3;\n\t\tpage += t2p->tiff_pages[i].page_extra;\n\t\tif(t2p->tiff_pages[i].page_tilecount>0){\n\t\t\tpage += (2 * t2p->tiff_pages[i].page_tilecount);\n\t\t} else {\n\t\t\tpage +=2;\n\t\t}\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \"] \\n/Count \", 10);\n\tbuflen=snprintf(buffer, sizeof(buffer), \"%d\", t2p->tiff_pagecount);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \" \\n>> \\n\", 6);\n\n\treturn(written);\n}",
        "begin_line": 4289,
        "end_line": 4323,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_write_pdf_stream#4004",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_write_pdf_stream(tdata_t buffer, tsize_t len, TIFF* output)",
        "snippet": "tsize_t t2p_write_pdf_stream(tdata_t buffer, tsize_t len, TIFF* output){\n\n\ttsize_t written=0;\n\n\twritten += t2pWriteFile(output, (tdata_t) buffer, len);\n\n\treturn(written);\n}",
        "begin_line": 4004,
        "end_line": 4011,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_write_pdf_stream_dict#4043",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_write_pdf_stream_dict(tsize_t len, uint32 number, TIFF* output)",
        "snippet": "tsize_t t2p_write_pdf_stream_dict(tsize_t len, uint32 number, TIFF* output){\n\t\n\ttsize_t written=0;\n\tchar buffer[32];\n\tint buflen=0;\n\t\n\twritten += t2pWriteFile(output, (tdata_t) \"/Length \", 8);\n\tif(len!=0){\n\t\twritten += t2p_write_pdf_stream_length(len, output);\n\t} else {\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)number);\n\t\tcheck_snprintf_ret((T2P*)NULL, buflen, buffer);\n\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \\n\", 6);\n\t}\n\t\n\treturn(written);\n}",
        "begin_line": 4043,
        "end_line": 4060,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_write_pdf_stream_dict_end#4079",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_write_pdf_stream_dict_end(TIFF* output)",
        "snippet": "tsize_t t2p_write_pdf_stream_dict_end(TIFF* output){\n\n\ttsize_t written=0;\n\n\twritten += t2pWriteFile(output, (tdata_t) \" >>\\n\", 4);\n\n\treturn(written);\n}",
        "begin_line": 4079,
        "end_line": 4086,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_write_pdf_stream_dict_start#4066",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_write_pdf_stream_dict_start(TIFF* output)",
        "snippet": "tsize_t t2p_write_pdf_stream_dict_start(TIFF* output){\n\n\ttsize_t written=0;\n\n\twritten += t2pWriteFile(output, (tdata_t) \"<< \\n\", 4);\n\n\treturn(written);\n}",
        "begin_line": 4066,
        "end_line": 4073,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_write_pdf_stream_end#4030",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_write_pdf_stream_end(TIFF* output)",
        "snippet": "tsize_t t2p_write_pdf_stream_end(TIFF* output){\n\n\ttsize_t written=0;\n\n\twritten += t2pWriteFile(output, (tdata_t) \"\\nendstream\\n\", 11);\n\n\treturn(written);\n}",
        "begin_line": 4030,
        "end_line": 4037,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_write_pdf_stream_length#4092",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_write_pdf_stream_length(tsize_t len, TIFF* output)",
        "snippet": "tsize_t t2p_write_pdf_stream_length(tsize_t len, TIFF* output){\n\n\ttsize_t written=0;\n\tchar buffer[32];\n\tint buflen=0;\n\n\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)len);\n\tcheck_snprintf_ret((T2P*)NULL, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\n\treturn(written);\n}",
        "begin_line": 4092,
        "end_line": 4104,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_write_pdf_stream_start#4017",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_write_pdf_stream_start(TIFF* output)",
        "snippet": "tsize_t t2p_write_pdf_stream_start(TIFF* output){\n\n\ttsize_t written=0;\n\n\twritten += t2pWriteFile(output, (tdata_t) \"stream\\n\", 7);\n\n\treturn(written);\n}",
        "begin_line": 4017,
        "end_line": 4024,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_write_pdf_string#3950",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_write_pdf_string(char* pdfstr, TIFF* output)",
        "snippet": "tsize_t t2p_write_pdf_string(char* pdfstr, TIFF* output)\n{\n\ttsize_t written = 0;\n\tuint32 i = 0;\n\tchar buffer[64];\n\tsize_t len = 0;\n\t\n\tlen = strlen(pdfstr);\n\twritten += t2pWriteFile(output, (tdata_t) \"(\", 1);\n\tfor (i=0; i<len; i++) {\n\t\tif((pdfstr[i]&0x80) || (pdfstr[i]==127) || (pdfstr[i]<32)){\n\t\t\tsnprintf(buffer, sizeof(buffer), \"\\\\%.3o\", ((unsigned char)pdfstr[i]));\n\t\t\twritten += t2pWriteFile(output, (tdata_t)buffer, 4);\n\t\t} else {\n\t\t\tswitch (pdfstr[i]){\n\t\t\t\tcase 0x08:\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\\\b\", 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x09:\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\\\t\", 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x0A:\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\\\n\", 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x0C:\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\\\f\", 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x0D:\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\\\r\", 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x28:\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\\\(\", 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x29:\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\\\)\", 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x5C:\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\\\\\\\\", 2);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) &pdfstr[i], 1);\n\t\t\t}\n\t\t}\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \") \", 1);\n\n\treturn(written);\n}",
        "begin_line": 3950,
        "end_line": 3997,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_write_pdf_xobject_cs#4899",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_write_pdf_xobject_cs(T2P* t2p, TIFF* output)",
        "snippet": "tsize_t t2p_write_pdf_xobject_cs(T2P* t2p, TIFF* output){\n\n\ttsize_t written=0;\n\tchar buffer[128];\n\tint buflen=0;\n\n\tfloat X_W=1.0;\n\tfloat Y_W=1.0;\n\tfloat Z_W=1.0;\n\t\n\tif( (t2p->pdf_colorspace & T2P_CS_ICCBASED) != 0){\n\t\twritten += t2p_write_pdf_xobject_icccs(t2p, output);\n\t\treturn(written);\n\t}\n\tif( (t2p->pdf_colorspace & T2P_CS_PALETTE) != 0){\n\t\twritten += t2pWriteFile(output, (tdata_t) \"[ /Indexed \", 11);\n\t\tt2p->pdf_colorspace ^= T2P_CS_PALETTE;\n\t\twritten += t2p_write_pdf_xobject_cs(t2p, output);\n\t\tt2p->pdf_colorspace |= T2P_CS_PALETTE;\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%u\", (0x0001 << t2p->tiff_bitspersample)-1 );\n\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\twritten += t2pWriteFile(output, (tdata_t) \" \", 1);\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)t2p->pdf_palettecs ); \n\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\twritten += t2pWriteFile(output, (tdata_t) \" 0 R ]\\n\", 7);\n\t\treturn(written);\n\t}\n\tif(t2p->pdf_colorspace & T2P_CS_BILEVEL){\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/DeviceGray \\n\", 13);\n\t}\n\tif(t2p->pdf_colorspace & T2P_CS_GRAY){\n\t\t\tif(t2p->pdf_colorspace & T2P_CS_CALGRAY){\n\t\t\t\twritten += t2p_write_pdf_xobject_calcs(t2p, output);\n\t\t\t} else {\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/DeviceGray \\n\", 13);\n\t\t\t}\n\t}\n\tif(t2p->pdf_colorspace & T2P_CS_RGB){\n\t\t\tif(t2p->pdf_colorspace & T2P_CS_CALRGB){\n\t\t\t\twritten += t2p_write_pdf_xobject_calcs(t2p, output);\n\t\t\t} else {\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/DeviceRGB \\n\", 12);\n\t\t\t}\n\t}\n\tif(t2p->pdf_colorspace & T2P_CS_CMYK){\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/DeviceCMYK \\n\", 13);\n\t}\n\tif(t2p->pdf_colorspace & T2P_CS_LAB){\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"[/Lab << \\n\", 10);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/WhitePoint \", 12);\n\t\t\tX_W = t2p->tiff_whitechromaticities[0];\n\t\t\tY_W = t2p->tiff_whitechromaticities[1];\n\t\t\tZ_W = 1.0F - (X_W + Y_W);\n\t\t\tX_W /= Y_W;\n\t\t\tZ_W /= Y_W;\n\t\t\tY_W = 1.0F;\n\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"[%.4f %.4f %.4f] \\n\", X_W, Y_W, Z_W);\n\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/Range \", 7);\n\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"[%d %d %d %d] \\n\", \n\t\t\t\tt2p->pdf_labrange[0], \n\t\t\t\tt2p->pdf_labrange[1], \n\t\t\t\tt2p->pdf_labrange[2], \n\t\t\t\tt2p->pdf_labrange[3]);\n\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \">>] \\n\", 5);\n\t\t\t\n\t}\n\t\n\treturn(written);\n}",
        "begin_line": 4899,
        "end_line": 4973,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_write_pdf_xobject_stream_dict#4823",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_write_pdf_xobject_stream_dict(ttile_t tile, T2P* t2p, TIFF* output)",
        "snippet": "tsize_t t2p_write_pdf_xobject_stream_dict(ttile_t tile, \n\t\t\t\t\t\t\t\t\t\t\t\tT2P* t2p, \n\t\t\t\t\t\t\t\t\t\t\t\tTIFF* output){\n\n\ttsize_t written=0;\n\tchar buffer[32];\n\tint buflen=0;\n\n\twritten += t2p_write_pdf_stream_dict(0, t2p->pdf_xrefcount+1, output); \n\twritten += t2pWriteFile(output, \n\t\t(tdata_t) \"/Type /XObject \\n/Subtype /Image \\n/Name /Im\", \n\t\t42);\n\tbuflen=snprintf(buffer, sizeof(buffer), \"%u\", t2p->pdf_page+1);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\tif(tile != 0){\n\t\twritten += t2pWriteFile(output, (tdata_t) \"_\", 1);\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)tile);\n\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \"\\n/Width \", 8);\n\tif(tile==0){\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)t2p->tiff_width);\n\t} else {\n\t\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile-1)!=0){\n\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);\n\t\t} else {\n\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);\n\t\t}\n\t}\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \"\\n/Height \", 9);\n\tif(tile==0){\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)t2p->tiff_length);\n\t} else {\n\t\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile-1)!=0){\n\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t\t} else {\n\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\t}\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \"\\n/BitsPerComponent \", 19);\n\tbuflen=snprintf(buffer, sizeof(buffer), \"%u\", t2p->tiff_bitspersample);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \"\\n/ColorSpace \", 13);\n\twritten += t2p_write_pdf_xobject_cs(t2p, output);\n\tif (t2p->pdf_image_interpolate)\n\t\twritten += t2pWriteFile(output,\n\t\t\t\t\t (tdata_t) \"\\n/Interpolate true\", 18);\n\tif( (t2p->pdf_switchdecode != 0)\n#ifdef CCITT_SUPPORT\n\t\t&& ! (t2p->pdf_colorspace & T2P_CS_BILEVEL \n\t\t&& t2p->pdf_compression == T2P_COMPRESS_G4)\n#endif\n\t\t){\n\t\twritten += t2p_write_pdf_xobject_decode(t2p, output);\n\t}\n\twritten += t2p_write_pdf_xobject_stream_filter(tile, t2p, output);\n\t\n\treturn(written);\n}",
        "begin_line": 4823,
        "end_line": 4892,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_write_pdf_xobject_stream_filter#5232",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_write_pdf_xobject_stream_filter(ttile_t tile, T2P* t2p, TIFF* output)",
        "snippet": "tsize_t t2p_write_pdf_xobject_stream_filter(ttile_t tile, T2P* t2p, TIFF* output){\n\n\ttsize_t written=0;\n\tchar buffer[32];\n\tint buflen=0;\n\n\tif(t2p->pdf_compression==T2P_COMPRESS_NONE){\n\t\treturn(written);\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \"/Filter \", 8);\n\tswitch(t2p->pdf_compression){\n#ifdef CCITT_SUPPORT\n\t\tcase T2P_COMPRESS_G4:\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/CCITTFaxDecode \", 16);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/DecodeParms \", 13);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"<< /K -1 \", 9);\n\t\t\tif(tile==0){\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/Columns \", 9);\n\t\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t\t       (unsigned long)t2p->tiff_width);\n\t\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \" /Rows \", 7);\n\t\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t\t       (unsigned long)t2p->tiff_length);\n\t\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\t} else {\n\t\t\t\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile-1)==0){\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/Columns \", 9);\n\t\t\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t\t\t(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);\n\t\t\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\t\t} else {\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/Columns \", 9);\n\t\t\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t\t\t(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);\n\t\t\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\t\t}\n\t\t\t\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile-1)==0){\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \" /Rows \", 7);\n\t\t\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t\t\t(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\t\t} else {\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \" /Rows \", 7);\n\t\t\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t\t\t(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t\t\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t2p->pdf_switchdecode == 0){\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \" /BlackIs1 true \", 16);\n\t\t\t}\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \">>\\n\", 3);\n\t\t\tbreak;\n#endif\n#ifdef JPEG_SUPPORT\n\t\tcase T2P_COMPRESS_JPEG:\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/DCTDecode \", 11);\n\n\t\t\tif(t2p->tiff_photometric != PHOTOMETRIC_YCBCR) {\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/DecodeParms \", 13);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"<< /ColorTransform 1 >>\\n\", 24);\n\t\t\t}\n\t\t\tbreak;\n#endif\n#ifdef ZIP_SUPPORT\n\t\tcase T2P_COMPRESS_ZIP:\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/FlateDecode \", 13);\n\t\t\tif(t2p->pdf_compressionquality%100){\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/DecodeParms \", 13);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"<< /Predictor \", 14);\n\t\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%u\", t2p->pdf_compressionquality%100);\n\t\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \" /Columns \", 10);\n\t\t\t\tbuflen = snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t\t\t (unsigned long)t2p->tiff_width);\n\t\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \" /Colors \", 9);\n\t\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%u\", t2p->tiff_samplesperpixel);\n\t\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \" /BitsPerComponent \", 19);\n\t\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%u\", t2p->tiff_bitspersample);\n\t\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \">>\\n\", 3);\n\t\t\t}\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn(written);\n}",
        "begin_line": 5232,
        "end_line": 5334,
        "is_bug": false
    },
    {
        "name": "tools.tiff2pdf.t2p_writeproc#400",
        "src_path": "tools/tiff2pdf.c",
        "class_name": "tools.tiff2pdf",
        "signature": "tools.tiff2pdf.t2p_writeproc(thandle_t handle, tdata_t data, tmsize_t size)",
        "snippet": "static tmsize_t \nt2p_writeproc(thandle_t handle, tdata_t data, tmsize_t size) \n{\n\tT2P *t2p = (T2P*) handle;\n\tif (t2p->outputdisable <= 0 && t2p->outputfile) {\n\t\ttsize_t written = fwrite(data, 1, size, t2p->outputfile);\n\t\tt2p->outputwritten += written;\n\t\treturn written;\n\t}\n\treturn size; \n}",
        "begin_line": 400,
        "end_line": 410,
        "is_bug": false
    }
]