[
    {
        "name": "src.bopomofo.BopomofoIsEntering#677",
        "src_path": "src/bopomofo.c",
        "class_name": "src.bopomofo",
        "signature": "src.bopomofo.BopomofoIsEntering(BopomofoData *pBopomofo)",
        "snippet": "int BopomofoIsEntering(BopomofoData *pBopomofo)\n{\n    int i;\n\n    if (pBopomofo->kbtype >= KB_HANYU_PINYIN) {\n        if (pBopomofo->pinYinData.keySeq[0])\n            return 1;\n    } else {\n        for (i = 0; i < BOPOMOFO_SIZE; i++)\n            if (pBopomofo->pho_inx[i])\n                return 1;\n    }\n    return 0;\n}",
        "begin_line": 677,
        "end_line": 690,
        "is_bug": false
    },
    {
        "name": "src.bopomofo.BopomofoPhoInput#617",
        "src_path": "src/bopomofo.c",
        "class_name": "src.bopomofo",
        "signature": "src.bopomofo.BopomofoPhoInput(ChewingData *pgdata, int key)",
        "snippet": "int BopomofoPhoInput(ChewingData *pgdata, int key)\n{\n    BopomofoData *pBopomofo = &(pgdata->bopomofoData);\n\n    /* open symbol table */\n    if (key == '`') {\n        pgdata->bSelect = 1;\n        pgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;\n        HaninSymbolInput(pgdata);\n        return BOPOMOFO_OPEN_SYMBOL_TABLE;\n    }\n    switch (pBopomofo->kbtype) {\n    case KB_HSU:\n    case KB_DVORAK_HSU:\n        return HsuPhoInput(pgdata, key);\n        break;\n    case KB_ET26:\n        return ET26PhoInput(pgdata, key);\n        break;\n    case KB_DACHEN_CP26:\n        return DACHENCP26PhoInput(pgdata, key);\n        break;\n    case KB_HANYU_PINYIN:\n    case KB_THL_PINYIN:\n    case KB_MPS2_PINYIN:\n        return PinYinInput(pgdata, key);\n        break;\n    default:\n        return DefPhoInput(pgdata, key);\n    }\n    return BOPOMOFO_ERROR;\n}",
        "begin_line": 617,
        "end_line": 648,
        "is_bug": false
    },
    {
        "name": "src.bopomofo.BopomofoRemoveAll#670",
        "src_path": "src/bopomofo.c",
        "class_name": "src.bopomofo",
        "signature": "src.bopomofo.BopomofoRemoveAll(BopomofoData *pBopomofo)",
        "snippet": "int BopomofoRemoveAll(BopomofoData *pBopomofo)\n{\n    memset(pBopomofo->pho_inx, 0, sizeof(pBopomofo->pho_inx));\n    memset(pBopomofo->pinYinData.keySeq, 0, sizeof(pBopomofo->pinYinData.keySeq));\n    return 0;\n}",
        "begin_line": 670,
        "end_line": 675,
        "is_bug": false
    },
    {
        "name": "src.bopomofo.BopomofoRemoveLast#651",
        "src_path": "src/bopomofo.c",
        "class_name": "src.bopomofo",
        "signature": "src.bopomofo.BopomofoRemoveLast(BopomofoData *pBopomofo)",
        "snippet": "int BopomofoRemoveLast(BopomofoData *pBopomofo)\n{\n    int i;\n\n    if (pBopomofo->kbtype >= KB_HANYU_PINYIN) {\n        i = strlen(pBopomofo->pinYinData.keySeq);\n        pBopomofo->pinYinData.keySeq[i - 1] = '\\0';\n    } else {\n        for (i = 3; i >= 0; i--) {\n            if (pBopomofo->pho_inx[i]) {\n                pBopomofo->pho_inx[i] = 0;\n                return 0;\n            }\n        }\n    }\n    return 0;\n}",
        "begin_line": 651,
        "end_line": 667,
        "is_bug": false
    },
    {
        "name": "src.bopomofo.DACHENCP26PhoInput#391",
        "src_path": "src/bopomofo.c",
        "class_name": "src.bopomofo",
        "signature": "src.bopomofo.DACHENCP26PhoInput(ChewingData *pgdata, int key)",
        "snippet": "static int DACHENCP26PhoInput(ChewingData *pgdata, int key)\n{\n    BopomofoData *pBopomofo = &(pgdata->bopomofoData);\n    int type = 0, searchTimes = 0, inx = 0;\n\n    if (IsDACHENCP26PhoEndKey(pBopomofo->pho_inx, key)) {\n        searchTimes = 2;\n        return EndKeyProcess(pgdata, key, searchTimes);\n    } else {\n        /* decide if the key is a phone */\n        for (type = 0, searchTimes = 1; type < 3; type++) {\n            inx = PhoneInxFromKey(key, type, pBopomofo->kbtype, searchTimes);\n            if (!inx)\n                continue;       /* if inx == 0, next type */\n            else if (type == 0) {\n                break;\n                if (pBopomofo->pho_inx[0] || pBopomofo->pho_inx[1]) {\n                    /* if inx !=0 */\n                    searchTimes = 2;    /* possible infinite loop here */\n                } else\n                    break;\n            } else\n                break;\n        }\n        /* switching between \"\u3105\" and \"\u3106\" */\n        if (key == 'q') {\n            if (SwitchingBetween(&pBopomofo->pho_inx[0], 1, 2)) {\n                return BOPOMOFO_ABSORB;\n            }\n        }\n        /* switching between \"\u3109\" and \"\u310a\" */\n        else if (key == 'w') {\n            if (SwitchingBetween(&pBopomofo->pho_inx[0], 5, 6)) {\n                return BOPOMOFO_ABSORB;\n            }\n        }\n        /* switching between \"\u3113\" and \"\u3114\" */\n        else if (key == 't') {\n            if (SwitchingBetween(&pBopomofo->pho_inx[0], 15, 16)) {\n                return BOPOMOFO_ABSORB;\n            }\n        }\n        /* converting \"\u3116\" to \"\u311d\" */\n        else if (key == 'b') {\n            if (pBopomofo->pho_inx[0] != 0 || pBopomofo->pho_inx[1] != 0) {\n                pBopomofo->pho_inx[2] = 4;\n                return BOPOMOFO_ABSORB;\n            }\n        }\n        /* converting \"\u3119\" to \"\u3125\" */\n        else if (key == 'n') {\n            if (pBopomofo->pho_inx[0] != 0 || pBopomofo->pho_inx[1] != 0) {\n                pBopomofo->pho_inx[2] = 12;\n                return BOPOMOFO_ABSORB;\n            }\n        }\n        /* switching between \"\u3127\", \"\u311a\", and \"\u3127\u311a\" */\n        else if (key == 'u') {\n            if (pBopomofo->pho_inx[1] == 1 && pBopomofo->pho_inx[2] != 1) {\n                pBopomofo->pho_inx[1] = 0;\n                pBopomofo->pho_inx[2] = 1;\n                return BOPOMOFO_ABSORB;\n            } else if (pBopomofo->pho_inx[1] != 1 && pBopomofo->pho_inx[2] == 1) {\n                pBopomofo->pho_inx[1] = 1;\n                return BOPOMOFO_ABSORB;\n            } else if (pBopomofo->pho_inx[1] == 1 && pBopomofo->pho_inx[2] == 1) {\n                pBopomofo->pho_inx[1] = 0;\n                pBopomofo->pho_inx[2] = 0;\n                return BOPOMOFO_ABSORB;\n            } else if (pBopomofo->pho_inx[1] != 0) {\n                pBopomofo->pho_inx[2] = 1;\n                return BOPOMOFO_ABSORB;\n            }\n        }\n        /* switching between \"\u3129\" and \"\u3121\" */\n        else if (key == 'm') {\n            if (pBopomofo->pho_inx[1] == 3 && pBopomofo->pho_inx[2] != 8) {\n                pBopomofo->pho_inx[1] = 0;\n                pBopomofo->pho_inx[2] = 8;\n                return BOPOMOFO_ABSORB;\n            } else if (pBopomofo->pho_inx[1] != 3 && pBopomofo->pho_inx[2] == 8) {\n                pBopomofo->pho_inx[1] = 3;\n                pBopomofo->pho_inx[2] = 0;\n                return BOPOMOFO_ABSORB;\n            } else if (pBopomofo->pho_inx[1] != 0) {\n                pBopomofo->pho_inx[2] = 8;\n                return BOPOMOFO_ABSORB;\n            }\n        }\n        /* switching between \"\u311b\" and \"\u311e\" */\n        else if (key == 'i') {\n            if (SwitchingBetween(&pBopomofo->pho_inx[2], 2, 5)) {\n                return BOPOMOFO_ABSORB;\n            }\n        }\n        /* switching between \"\u311f\" and \"\u3122\" */\n        else if (key == 'o') {\n            if (SwitchingBetween(&pBopomofo->pho_inx[2], 6, 9)) {\n                return BOPOMOFO_ABSORB;\n            }\n        }\n        /* switching between \"\u3120\" and \"\u3124\" */\n        else if (key == 'l') {\n            if (SwitchingBetween(&pBopomofo->pho_inx[2], 7, 11)) {\n                return BOPOMOFO_ABSORB;\n            }\n        }\n        /* switching between \"\u3123\" and \"\u3126\" */\n        else if (key == 'p') {\n            if (SwitchingBetween(&pBopomofo->pho_inx[2], 10, 13)) {\n                return BOPOMOFO_ABSORB;\n            }\n        }\n        if (type == 3) {        /* the key is NOT a phone */\n            if (isalpha(key))\n                return BOPOMOFO_NO_WORD;\n            return BOPOMOFO_KEY_ERROR;\n        }\n        /* fill the key into the phone buffer */\n        pBopomofo->pho_inx[type] = inx;\n        return BOPOMOFO_ABSORB;\n    }\n}\n\nstatic int IsPinYinEndKey(int key)\n{\n    if ((",
        "begin_line": 391,
        "end_line": 513,
        "is_bug": false
    },
    {
        "name": "src.bopomofo.DefPhoInput#142",
        "src_path": "src/bopomofo.c",
        "class_name": "src.bopomofo",
        "signature": "src.bopomofo.DefPhoInput(ChewingData *pgdata, int key)",
        "snippet": "static int DefPhoInput(ChewingData *pgdata, int key)\n{\n    BopomofoData *pBopomofo = &(pgdata->bopomofoData);\n    int type = 0, inx = 0;\n    int i;\n\n    if (IsDefPhoEndKey(key, pBopomofo->kbtype)) {\n        for (i = 0; i < BOPOMOFO_SIZE; ++i)\n            if (pBopomofo->pho_inx[i] != 0)\n                break;\n        if (i < BOPOMOFO_SIZE)\n            return EndKeyProcess(pgdata, key, 1);\n    } else {\n        pBopomofo->pho_inx[3] = 0;\n    }\n\n    /* decide if the key is a phone */\n    for (type = 0; type <= 3; type++) {\n        inx = PhoneInxFromKey(key, type, pBopomofo->kbtype, 1);\n        if (inx)\n            break;\n    }\n\n    /* the key is NOT a phone */\n    if (type > 3) {\n        return BOPOMOFO_KEY_ERROR;\n    }\n\n    /* fill the key into the phone buffer */\n    pBopomofo->pho_inx[type] = inx;\n    return BOPOMOFO_ABSORB;\n}",
        "begin_line": 142,
        "end_line": 173,
        "is_bug": false
    },
    {
        "name": "src.bopomofo.ET26PhoInput#284",
        "src_path": "src/bopomofo.c",
        "class_name": "src.bopomofo",
        "signature": "src.bopomofo.ET26PhoInput(ChewingData *pgdata, int key)",
        "snippet": "static int ET26PhoInput(ChewingData *pgdata, int key)\n{\n    BopomofoData *pBopomofo = &(pgdata->bopomofoData);\n    int type = 0, searchTimes = 0, inx = 0;\n\n    if (IsET26PhoEndKey(pBopomofo->pho_inx, key)) {\n        if (pBopomofo->pho_inx[1] == 0 && pBopomofo->pho_inx[2] == 0) {\n            /* convert \"\u3110\u3112\" to \"\u3113\u3115\" */\n            if (pBopomofo->pho_inx[0] == 12 || pBopomofo->pho_inx[0] == 14) {\n                pBopomofo->pho_inx[0] += 3;\n            }\n            /* convert \"\u3106\" to \"\u3121\" */\n            else if (pBopomofo->pho_inx[0] == 2) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 8;\n            }\n            /* convert \"\u3107\" to \"\u3122\" */\n            else if (pBopomofo->pho_inx[0] == 3) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 9;\n            }\n            /* convert \"\u310b\" to \"\u3123\" */\n            else if (pBopomofo->pho_inx[0] == 7) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 10;\n            }\n            /* convert \"\u310a\" to \"\u3124\" */\n            else if (pBopomofo->pho_inx[0] == 6) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 11;\n            }\n            /* convert \"\u310c\" to \"\u3125\" */\n            else if (pBopomofo->pho_inx[0] == 8) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 12;\n            }\n            /* convert \"\u310f\" to \"\u3126\" */\n            else if (pBopomofo->pho_inx[0] == 11) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 13;\n            }\n        }\n        searchTimes = 2;\n        return EndKeyProcess(pgdata, key, searchTimes);\n    } else {\n        /* decide if the key is a phone */\n        for (type = 0, searchTimes = 1; type < 3; type++) {\n            inx = PhoneInxFromKey(key, type, pBopomofo->kbtype, searchTimes);\n            if (!inx)\n                continue;       /* if inx == 0, next type */\n            else if (type == 0) {\n                 /**\n                  * Same as Hsu: If a consonant or a medial already exists\n                  * in buffer, and the user presses a key with consonant\n                  * and rhyme, libchewing should consider that the user\n                  * wants to input the rhyme.\n                  */\n                if ((inx == 2 || inx == 3 || inx == 11 || inx == 19 || inx == 20 ||\n                    (6 <= inx && inx <= 8)) && (pBopomofo->pho_inx[0] || pBopomofo->pho_inx[1])) {\n                    /* if inx !=0 */\n                    searchTimes = 2;    /* possible infinite loop here */\n                } else\n                    break;\n            } else\n                break;\n        }\n        /* convert \"\u3110\u3112\" to \"\u3113\u3115\" */\n        if (type == 1) {\n            if (inx == 2) {\n                if (pBopomofo->pho_inx[0] == 12 || pBopomofo->pho_inx[0] == 14) {\n                    pBopomofo->pho_inx[0] += 3;\n                }\n            } else {\n                /* convert \"\u310d\" to \"\u3111\" */\n                if (pBopomofo->pho_inx[0] == 9) {\n                    pBopomofo->pho_inx[0] = 13;\n                }\n            }\n        }\n\n        if (type == 2 && pBopomofo->pho_inx[1] == 0 && (pBopomofo->pho_inx[0] == 12 || pBopomofo->pho_inx[0] == 14)) {\n            pBopomofo->pho_inx[0] += 3;\n        }\n\n        if (type == 3) {        /* the key is NOT a phone */\n            if (isalpha(key))\n                return BOPOMOFO_NO_WORD;\n            return BOPOMOFO_KEY_ERROR;\n        }\n        /* fill the key into the phone buffer */\n        pBopomofo->pho_inx[type] = inx;\n        return BOPOMOFO_ABSORB;\n    }\n}\n\nstatic int SwitchingBetween(int *pho_idx, ",
        "begin_line": 284,
        "end_line": 377,
        "is_bug": false
    },
    {
        "name": "src.bopomofo.EndKeyProcess#94",
        "src_path": "src/bopomofo.c",
        "class_name": "src.bopomofo",
        "signature": "src.bopomofo.EndKeyProcess(ChewingData *pgdata, int key, int searchTimes)",
        "snippet": "static int EndKeyProcess(ChewingData *pgdata, int key, int searchTimes)\n{\n    BopomofoData *pBopomofo = &(pgdata->bopomofoData);\n    uint16_t u16Pho, u16PhoAlt;\n    Phrase tempword;\n    int pho_inx;\n\n    if (pBopomofo->pho_inx[0] == 0 && pBopomofo->pho_inx[1] == 0 && pBopomofo->pho_inx[2] == 0 && pBopomofo->pho_inx[3] == 0) {\n        /*\n         * Special handle for space key (Indeed very special one).\n         * Un-break the situation that OnKeySpace() is not called,\n         * hence the Candidate window doesn't show up, because\n         * BOPOMOFO_NO_WORD is returned.\n         */\n        return (key == ' ') ? BOPOMOFO_KEY_ERROR : BOPOMOFO_NO_WORD;\n    }\n\n    pho_inx = PhoneInxFromKey(key, 3, pBopomofo->kbtype, searchTimes);\n    if (pBopomofo->pho_inx[3] == 0) {\n        pBopomofo->pho_inx[3] = pho_inx;\n        pBopomofo->pho_inx_alt[3] = pho_inx;\n    } else if (key != ' ') {\n        pBopomofo->pho_inx[3] = pho_inx;\n        pBopomofo->pho_inx_alt[3] = pho_inx;\n        return BOPOMOFO_NO_WORD;\n    }\n\n    u16Pho = UintFromPhoneInx(pBopomofo->pho_inx);\n    if (GetCharFirst(pgdata, &tempword, u16Pho) == 0) {\n        BopomofoRemoveAll(pBopomofo);\n        return BOPOMOFO_NO_WORD;\n    }\n\n    pBopomofo->phone = u16Pho;\n\n    if (pBopomofo->pho_inx_alt[0] == 0 && pBopomofo->pho_inx_alt[1] == 0 && pBopomofo->pho_inx_alt[2] == 0) {\n        /* no alternative phone, copy from default as alt */\n        pBopomofo->phoneAlt = u16Pho;\n    } else {\n        u16PhoAlt = UintFromPhoneInx(pBopomofo->pho_inx_alt);\n        pBopomofo->phoneAlt = u16PhoAlt;\n    }\n\n    memset(pBopomofo->pho_inx, 0, sizeof(pBopomofo->pho_inx));\n    memset(pBopomofo->pho_inx_alt, 0, sizeof(pBopomofo->pho_inx_alt));\n    return BOPOMOFO_COMMIT;\n}",
        "begin_line": 94,
        "end_line": 140,
        "is_bug": false
    },
    {
        "name": "src.bopomofo.HsuPhoInput#175",
        "src_path": "src/bopomofo.c",
        "class_name": "src.bopomofo",
        "signature": "src.bopomofo.HsuPhoInput(ChewingData *pgdata, int key)",
        "snippet": "static int HsuPhoInput(ChewingData *pgdata, int key)\n{\n    BopomofoData *pBopomofo = &(pgdata->bopomofoData);\n    int type = 0, searchTimes = 0, inx = 0;\n\n    /* Dvorak Hsu key has already converted to Hsu */\n    if (IsHsuPhoEndKey(pBopomofo->pho_inx, key)) {\n        if (pBopomofo->pho_inx[1] == 0 && pBopomofo->pho_inx[2] == 0) {\n            /* convert \"\u3110\u3111\u3112\" to \"\u3113\u3114\u3115\" */\n            if (12 <= pBopomofo->pho_inx[0] && pBopomofo->pho_inx[0] <= 14) {\n                pBopomofo->pho_inx[0] += 3;\n            }\n            /* convert \"\u310f\" to \"\u311b\" */\n            else if (pBopomofo->pho_inx[0] == 11) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 2;\n            }\n            /* convert \"\u310d\" to \"\u311c\" */\n            else if (pBopomofo->pho_inx[0] == 9) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 3;\n            }\n            /* convert \"\u3107\" to \"\u3122\" */\n            else if (pBopomofo->pho_inx[0] == 3) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 9;\n            }\n            /* convert \"\u310b\" to \"\u3123\" */\n            else if (pBopomofo->pho_inx[0] == 7) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 10;\n            }\n            /* convert \"\u310e\" to \"\u3124\" */\n            else if (pBopomofo->pho_inx[0] == 10) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 11;\n            }\n            /* convert \"\u310c\" to \"\u3126\" */\n            else if (pBopomofo->pho_inx[0] == 8) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 13;\n            }\n        }\n\n        /* fuzzy \u310d\u3127 to \u3110\u3127 and \u310d\u3129 to \u3110\u3129 */\n        if ((pBopomofo->pho_inx[0] == 9) && ((pBopomofo->pho_inx[1] == 1) || (pBopomofo->pho_inx[1] == 3))) {\n            pBopomofo->pho_inx[0] = 12;\n        }\n\n        searchTimes = (key == 'j') ? 3 : 2;\n\n        return EndKeyProcess(pgdata, key, searchTimes);\n    } else {\n        /* decide if the key is a phone */\n        for (type = 0, searchTimes = 1; type < 3; type++) {\n            inx = PhoneInxFromKey(key, type, pBopomofo->kbtype, searchTimes);\n            if (!inx)\n                continue;       /* if inx == 0, next type */\n            else if (type == 0) {\n                /**\n                 * Hsu maps multiple bopomofo into one single key.\n                 * Therefore, if a consonant or a medial already exists\n                 * in buffer, and the user presses a key with consonant\n                 * and rhyme, libchewing should consider that the user\n                 * wants to input the rhyme.\n                 */\n                if ((inx == 3 || (7 <= inx && inx <= 11) || inx == 20)\n                    && (pBopomofo->pho_inx[0] || pBopomofo->pho_inx[1])) {\n                    /* if inx !=0 */\n                    searchTimes = 2;    /* possible infinite loop here */\n                } else\n                    break;\n            } else if (type == 1 && inx == 1) { /* handle i and e */\n                if (pBopomofo->pho_inx[1]) {\n                    searchTimes = 2;\n                } else\n                    break;\n            } else\n                break;\n        }\n\n        /* fuzzy \u310d\u3127 to \u3110\u3127 and \u310d\u3129 to \u3110\u3129 */\n        if ((pBopomofo->pho_inx[0] == 9) && ((pBopomofo->pho_inx[1] == 1) || (pBopomofo->pho_inx[1] == 3))) {\n            pBopomofo->pho_inx[0] = 12;\n        }\n\n        /* \u3110\u3111\u3112 must be followed by \u3127\u3129, if not, convert them to \u3113\u3114\u3115 */\n        if (type == 1 && inx == 2 && 12 <= pBopomofo->pho_inx[0] && pBopomofo->pho_inx[0] <= 14) {\n            /* followed by \u3128 */\n            pBopomofo->pho_inx[0] += 3;\n        }\n\n        if (type == 2 && pBopomofo->pho_inx[1] == 0 && 12 <= pBopomofo->pho_inx[0] && pBopomofo->pho_inx[0] <= 14) {\n            /* followed by other phones */\n            pBopomofo->pho_inx[0] += 3;\n        }\n\n        if (type == 3) {        /* the key is NOT a phone */\n            if (isalpha(key))\n                return BOPOMOFO_NO_WORD;\n            return BOPOMOFO_KEY_ERROR;\n        }\n        /* fill the key into the phone buffer */\n        pBopomofo->pho_inx[type] = inx;\n        return BOPOMOFO_ABSORB;\n    }\n}\n\n/* copy the idea from hsu */\nstatic int ET26PhoInput(ChewingData *pgdata, int key)\n{",
        "begin_line": 175,
        "end_line": 281,
        "is_bug": false
    },
    {
        "name": "src.bopomofo.IsDACHENCP26PhoEndKey#70",
        "src_path": "src/bopomofo.c",
        "class_name": "src.bopomofo",
        "signature": "src.bopomofo.IsDACHENCP26PhoEndKey(const int pho_inx[], int key)",
        "snippet": "static int IsDACHENCP26PhoEndKey(const int pho_inx[], int key)\n{\n    switch (key) {\n    case 'e':\n    case 'r':\n    case 'd':\n    case 'y':\n    case ' ':\n        return (pho_inx[0] || pho_inx[1] || pho_inx[2]);\n    default:\n        return 0;\n    }\n}",
        "begin_line": 70,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "src.bopomofo.IsDefPhoEndKey#84",
        "src_path": "src/bopomofo.c",
        "class_name": "src.bopomofo",
        "signature": "src.bopomofo.IsDefPhoEndKey(int key, int kbtype)",
        "snippet": "static int IsDefPhoEndKey(int key, int kbtype)\n{\n    if (PhoneInxFromKey(key, 3, kbtype, 1))\n        return 1;\n\n    if (key == ' ')\n        return 1;\n    return 0;\n}",
        "begin_line": 84,
        "end_line": 92,
        "is_bug": false
    },
    {
        "name": "src.bopomofo.IsET26PhoEndKey#55",
        "src_path": "src/bopomofo.c",
        "class_name": "src.bopomofo",
        "signature": "src.bopomofo.IsET26PhoEndKey(const int pho_inx[], int key)",
        "snippet": "static int IsET26PhoEndKey(const int pho_inx[], int key)\n{\n    switch (key) {\n    case 'd':\n    case 'f':\n    case 'j':\n    case 'k':\n    case ' ':\n        return (pho_inx[0] || pho_inx[1] || pho_inx[2]);\n    default:\n        return 0;\n    }\n}",
        "begin_line": 55,
        "end_line": 67,
        "is_bug": false
    },
    {
        "name": "src.bopomofo.IsHsuPhoEndKey#40",
        "src_path": "src/bopomofo.c",
        "class_name": "src.bopomofo",
        "signature": "src.bopomofo.IsHsuPhoEndKey(const int pho_inx[], int key)",
        "snippet": "static int IsHsuPhoEndKey(const int pho_inx[], int key)\n{\n    switch (key) {\n    case 's':\n    case 'd':\n    case 'f':\n    case 'j':\n    case ' ':\n        return (pho_inx[0] || pho_inx[1] || pho_inx[2]);\n    default:\n        return 0;\n    }\n}",
        "begin_line": 40,
        "end_line": 52,
        "is_bug": false
    },
    {
        "name": "src.bopomofo.IsPinYinEndKey#515",
        "src_path": "src/bopomofo.c",
        "class_name": "src.bopomofo",
        "signature": "src.bopomofo.IsPinYinEndKey(int key)",
        "snippet": "static int IsPinYinEndKey(int key)\n{\n    if ((key == ' ') || (key == '1') || (key == '2') || (key == '3') || (key == '4') || (key == '5')) {\n        return 1;\n    }\n    return 0;\n}",
        "begin_line": 515,
        "end_line": 521,
        "is_bug": false
    },
    {
        "name": "src.bopomofo.IsSymbolKey#523",
        "src_path": "src/bopomofo.c",
        "class_name": "src.bopomofo",
        "signature": "src.bopomofo.IsSymbolKey(int key)",
        "snippet": "static int IsSymbolKey(int key)\n{\n    if ((key < 97) || (key > 122)) {\n        return 1;\n    }\n\n    return 0;\n}",
        "begin_line": 523,
        "end_line": 530,
        "is_bug": false
    },
    {
        "name": "src.bopomofo.PinYinInput#532",
        "src_path": "src/bopomofo.c",
        "class_name": "src.bopomofo",
        "signature": "src.bopomofo.PinYinInput(ChewingData *pgdata, int key)",
        "snippet": "static int PinYinInput(ChewingData *pgdata, int key)\n{\n    BopomofoData *pBopomofo = &(pgdata->bopomofoData);\n    int err = 0;\n    unsigned int i;\n    char bopomofoKeySeq[5], bopomofoKeySeqAlt[5], buf[2];\n    size_t len;\n\n    DEBUG_CHECKPOINT();\n\n    if (pBopomofo->pinYinData.keySeq[0] == 0 && IsSymbolKey(key)) {\n        return BOPOMOFO_KEY_ERROR;\n    }\n\n    if (IsPinYinEndKey(key)) {\n        err = PinyinToBopomofo(pgdata, pBopomofo->pinYinData.keySeq, bopomofoKeySeq, bopomofoKeySeqAlt);\n        if (err) {\n            pBopomofo->pinYinData.keySeq[0] = '\\0';\n            return BOPOMOFO_ABSORB;\n        }\n\n        DEBUG_OUT(\"bopomofoKeySeq: %s\\n\", bopomofoKeySeq);\n        DEBUG_OUT(\"bopomofoKeySeqAlt: %s\\n\", bopomofoKeySeqAlt);\n\n        len = strlen(bopomofoKeySeq);\n        for (i = 0; i < len; i++) {\n            int type = 0, inx = 0;\n\n            for (type = 0; type <= 3; type++) {\n                inx = PhoneInxFromKey(bopomofoKeySeq[i], type, pBopomofo->kbtype, 1);\n                if (inx)\n                    break;\n            }\n\n            /* the key is NOT a phone */\n            if (type > 3) {\n                return BOPOMOFO_KEY_ERROR;\n            }\n\n            pBopomofo->pho_inx[type] = inx;\n\n        }\n\n        len = strlen(bopomofoKeySeqAlt);\n        for (i = 0; i < len; i++) {\n            int type = 0, inx = 0;\n\n            for (type = 0; type <= 3; type++) {\n                inx = PhoneInxFromKey(bopomofoKeySeqAlt[i], type, pBopomofo->kbtype, 1);\n                if (inx)\n                    break;\n            }\n\n            /* the key is NOT a phone */\n            if (type > 3) {\n                return BOPOMOFO_KEY_ERROR;\n            }\n\n            pBopomofo->pho_inx_alt[type] = inx;\n\n        }\n\n        switch (key) {\n        case '1':\n            key = ' ';\n            break;\n        case '2':\n            key = '6';\n            break;\n        case '5':\n            key = '7';\n        }\n        pBopomofo->pinYinData.keySeq[0] = '\\0';\n        return EndKeyProcess(pgdata, key, 1);\n    }\n    buf[0] = key;\n    buf[1] = '\\0';\n    strcat(pBopomofo->pinYinData.keySeq, buf);\n\n    DEBUG_OUT(\"PinYin Seq: %s\\n\", pBopomofo->pinYinData.keySeq);\n\n    return BOPOMOFO_ABSORB;\n}",
        "begin_line": 532,
        "end_line": 614,
        "is_bug": false
    },
    {
        "name": "src.bopomofo.SwitchingBetween#379",
        "src_path": "src/bopomofo.c",
        "class_name": "src.bopomofo",
        "signature": "src.bopomofo.SwitchingBetween(int *pho_idx, int a, int b)",
        "snippet": "static int SwitchingBetween(int *pho_idx, int a, int b)\n{\n    if (*pho_idx == a) {\n        *pho_idx = b;\n        return 1;\n    } else if (*pho_idx == b) {\n        *pho_idx = a;\n        return 1;\n    }\n    return 0;\n}",
        "begin_line": 379,
        "end_line": 389,
        "is_bug": false
    },
    {
        "name": "src.chewing-sql.ConfigDatabase#284",
        "src_path": "src/chewing-sql.c",
        "class_name": "src.chewing-sql",
        "signature": "src.chewing-sql.ConfigDatabase(ChewingData *pgdata)",
        "snippet": "static int ConfigDatabase(ChewingData *pgdata)\n{\n    int ret;\n\n    assert(pgdata);\n    assert(pgdata->static_data.db);\n\n    ret = sqlite3_exec(pgdata->static_data.db, \"PRAGMA synchronous=OFF\", NULL, NULL, NULL);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot set synchronous=OFF, error = %d\", ret);\n        return -1;\n    }\n\n    return 0;\n}",
        "begin_line": 284,
        "end_line": 298,
        "is_bug": false
    },
    {
        "name": "src.chewing-sql.CreateStmt#300",
        "src_path": "src/chewing-sql.c",
        "class_name": "src.chewing-sql",
        "signature": "src.chewing-sql.CreateStmt(ChewingData *pgdata)",
        "snippet": "static int CreateStmt(ChewingData *pgdata)\n{\n    size_t i;\n    int ret;\n\n    assert(pgdata);\n\n    STATIC_ASSERT(ARRAY_SIZE(SQL_STMT_CONFIG) == ARRAY_SIZE(pgdata->static_data.stmt_config));\n    STATIC_ASSERT(ARRAY_SIZE(SQL_STMT_USERPHRASE) == ARRAY_SIZE(pgdata->static_data.stmt_userphrase));\n\n    for (i = 0; i < ARRAY_SIZE(SQL_STMT_CONFIG); ++i) {\n        ret = sqlite3_prepare_v2(pgdata->static_data.db,\n                                 SQL_STMT_CONFIG[i].stmt, -1, &pgdata->static_data.stmt_config[i], NULL);\n        if (ret != SQLITE_OK) {\n            LOG_ERROR(\"Cannot create stmt %s\", SQL_STMT_CONFIG[i].stmt);\n            return -1;\n        }\n    }\n\n    for (i = 0; i < ARRAY_SIZE(SQL_STMT_USERPHRASE); ++i) {\n        ret = sqlite3_prepare_v2(pgdata->static_data.db,\n                                 SQL_STMT_USERPHRASE[i].stmt, -1, &pgdata->static_data.stmt_userphrase[i], NULL);\n        if (ret != SQLITE_OK) {\n            LOG_ERROR(\"Cannot create stmt %s\", SQL_STMT_USERPHRASE[i].stmt);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
        "begin_line": 300,
        "end_line": 329,
        "is_bug": false
    },
    {
        "name": "src.chewing-sql.CreateTable#113",
        "src_path": "src/chewing-sql.c",
        "class_name": "src.chewing-sql",
        "signature": "src.chewing-sql.CreateTable(ChewingData *pgdata)",
        "snippet": "static int CreateTable(ChewingData *pgdata)\n{\n    int ret;\n\n    STATIC_ASSERT(MAX_PHRASE_LEN == 11);\n\n    ret = sqlite3_exec(pgdata->static_data.db,\n                       \"CREATE TABLE IF NOT EXISTS userphrase_v1 (\"\n                       \"time INTEGER,\"\n                       \"user_freq INTEGER,\"\n                       \"max_freq INTEGER,\"\n                       \"orig_freq INTEGER,\"\n                       \"length INTEGER,\"\n                       \"phone_0 INTEGER,\"\n                       \"phone_1 INTEGER,\"\n                       \"phone_2 INTEGER,\"\n                       \"phone_3 INTEGER,\"\n                       \"phone_4 INTEGER,\"\n                       \"phone_5 INTEGER,\"\n                       \"phone_6 INTEGER,\"\n                       \"phone_7 INTEGER,\"\n                       \"phone_8 INTEGER,\"\n                       \"phone_9 INTEGER,\"\n                       \"phone_10 INTEGER,\"\n                       \"phrase TEXT,\"\n                       \"PRIMARY KEY (\"\n                       \"phone_0,\"\n                       \"phone_1,\"\n                       \"phone_2,\"\n                       \"phone_3,\"\n                       \"phone_4,\"\n                       \"phone_5,\"\n                       \"phone_6,\"\n                       \"phone_7,\"\n                       \"phone_8,\"\n                       \"phone_9,\"\n                       \"phone_10,\"\n                       \"phrase)\" \")\", NULL, NULL, NULL);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot create table userphrase_v1, error = %d\", ret);\n        return -1;\n    }\n\n    ret = sqlite3_exec(pgdata->static_data.db,\n                       \"CREATE TABLE IF NOT EXISTS config_v1 (\"\n                       \"id INTEGER,\"\n                       \"value INTEGER,\"\n                       \"PRIMARY KEY (id)\" \")\", NULL, NULL, NULL);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot create table config_v1, error = %d\", ret);\n        return -1;\n    }\n\n    return 0;\n}",
        "begin_line": 113,
        "end_line": 167,
        "is_bug": false
    },
    {
        "name": "src.chewing-sql.GetSQLiteInstance#94",
        "src_path": "src/chewing-sql.c",
        "class_name": "src.chewing-sql",
        "signature": "src.chewing-sql.GetSQLiteInstance(ChewingData *pgdata, const char *path)",
        "snippet": "static sqlite3 *GetSQLiteInstance(ChewingData *pgdata, const char *path)\n{\n    int ret;\n    sqlite3 *db = NULL;\n\n    assert(pgdata);\n    assert(path);\n\n    ret = sqlite3_open(path, &db);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_open returns %d\", ret);\n        goto end;\n    }\n\n  end:\n    return db;\n}",
        "begin_line": 94,
        "end_line": 110,
        "is_bug": false
    },
    {
        "name": "src.chewing-sql.InitUserphrase#431",
        "src_path": "src/chewing-sql.c",
        "class_name": "src.chewing-sql",
        "signature": "src.chewing-sql.InitUserphrase(ChewingData *pgdata, const char *path)",
        "snippet": "int InitUserphrase(ChewingData *pgdata, const char *path)\n{\n    int ret;\n\n    assert(!pgdata->static_data.db);\n    assert(path);\n\n    pgdata->static_data.db = GetSQLiteInstance(pgdata, path);\n    if (!pgdata->static_data.db) {\n        LOG_ERROR(\"GetSQLiteInstance fails\");\n        goto error;\n    }\n\n    ret = ConfigDatabase(pgdata);\n    if (ret) {\n        LOG_ERROR(\"ConfigDatabase returns %d\", ret);\n        goto error;\n    }\n\n    ret = CreateTable(pgdata);\n    if (ret) {\n        LOG_ERROR(\"CreateTable returns %d\", ret);\n        goto error;\n    }\n\n    ret = CreateStmt(pgdata);\n    if (ret) {\n        LOG_ERROR(\"CreateStmt returns %d\", ret);\n        goto error;\n    }\n\n    ret = SetupUserphraseLifeTime(pgdata);\n    if (ret) {\n        LOG_ERROR(\"SetupUserphraseLiftTime returns %d\", ret);\n        goto error;\n    }\n\n    /* FIXME: Normalize lifttime when necessary. */\n\n    MigrateOldFormat(pgdata, path);\n\n    return 0;\n\n  error:\n    TerminateUserphrase(pgdata);\n    return -1;\n}",
        "begin_line": 431,
        "end_line": 477,
        "is_bug": false
    },
    {
        "name": "src.chewing-sql.MigrateOldFormat#331",
        "src_path": "src/chewing-sql.c",
        "class_name": "src.chewing-sql",
        "signature": "src.chewing-sql.MigrateOldFormat(ChewingData *pgdata, const char *path)",
        "snippet": "static void MigrateOldFormat(ChewingData *pgdata, const char *path)\n{\n    char *uhash;\n    char *old_uhash;\n    FILE *fd = NULL;\n    char buf[HASH_FIELD_SIZE];\n    uint16_t phoneSeq[MAX_PHRASE_LEN + 1];\n    char *pos;\n    int len;\n    int i;\n    int ret;\n\n    assert(pgdata);\n    assert(path);\n\n    len = strlen(path) + 1 + strlen(HASH_NAME) + 1;\n    uhash = calloc(sizeof(*uhash), len);\n    if (!uhash) {\n        LOG_ERROR(\"calloc returns %#p\", uhash);\n        exit(-1);\n    }\n    snprintf(uhash, len, \"%s\" PLAT_SEPARATOR \"%s\", path, HASH_NAME);\n\n    len = strlen(path) + 1 + strlen(HASH_OLD_NAME) + 1;\n    old_uhash = calloc(sizeof(*old_uhash), len);\n    if (!old_uhash) {\n        LOG_ERROR(\"calloc returns %#p\", old_uhash);\n        exit(-1);\n    }\n    snprintf(old_uhash, len, \"%s\" PLAT_SEPARATOR \"%s\", path, HASH_OLD_NAME);\n\n    /*\n     * The binary format is described as following:\n     *\n     * 0 ~ 3                signature (CBiH)\n     * 4 ~ 7                lifttime, platform endianness\n     * 8 ~ 8 + 125 * n      array of hash item, 125 bytes each\n     *\n     * 0 ~ 3                user frequency, platform endianness\n     * 4 ~ 7                recent time, platform endianness\n     * 8 ~ 11               max frequency, platform endianness\n     * 12 ~ 15              original frequency, platform endianness\n     * 16                   phone length\n     * 17 ~ 17 + 2 * n      phone sequence, uint16_t, platform endianness\n     * 17 + 2 * n + 1       phrase length in bytes\n     * 17 + 2 * n + 2 ~ y   phrase in UTF-8\n     *\n     */\n\n    fd = fopen(uhash, \"r\");\n    if (!fd)\n        goto end;\n\n    LOG_INFO(\"Migrate old format from %s\", uhash);\n    ret = fread(buf, 4, 1, fd);\n    if (ret != 1) {\n        LOG_WARN(\"fread returns %d\", ret);\n        goto end_remove_hash;\n    }\n\n    if (memcmp(buf, HASH_SIGS, 4) != 0) {\n        LOG_WARN(\"signature is not %d\", HASH_SIGS);\n        goto end_remove_hash;\n    }\n\n    ret = fseek(fd, 8, SEEK_SET);\n    if (ret) {\n        LOG_WARN(\"fseek returns %d\", ret);\n        goto end_remove_hash;\n    }\n\n    while (fread(buf, HASH_FIELD_SIZE, 1, fd) == 1) {\n        pos = &buf[HASH_LENGTH_OFFSET];\n        len = *pos;\n        ++pos;\n\n        if (len > MAX_PHRASE_LEN || len < 1) {\n            LOG_WARN(\"skip field due to len = %d\", len);\n            continue;\n        }\n\n        for (i = 0; i < len; ++i) {\n            phoneSeq[i] = GetUint16PreservedEndian(pos);\n            pos += 2;\n        }\n        phoneSeq[len] = 0;\n\n        ++pos;\n        UserUpdatePhrase(pgdata, phoneSeq, pos);\n    }\n\n  end_remove_hash:\n    if (fd)\n        fclose(fd);\n    PLAT_RENAME(uhash, old_uhash);\n  end:\n    free(old_uhash);\n    free(uhash);\n}",
        "begin_line": 331,
        "end_line": 429,
        "is_bug": false
    },
    {
        "name": "src.chewing-sql.SetupUserphraseLifeTime#169",
        "src_path": "src/chewing-sql.c",
        "class_name": "src.chewing-sql",
        "signature": "src.chewing-sql.SetupUserphraseLifeTime(ChewingData *pgdata)",
        "snippet": "static int SetupUserphraseLifeTime(ChewingData *pgdata)\n{\n    int ret;\n\n    assert(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT]);\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT], BIND_CONFIG_ID, CONFIG_ID_LIFETIME);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot bind ?%d to %d in stmt %s, error = %d\",\n                  BIND_CONFIG_ID, CONFIG_ID_LIFETIME, SQL_STMT_CONFIG[STMT_CONFIG_INSERT].stmt, ret);\n        return -1;\n    }\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT], BIND_CONFIG_VALUE, 0);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot bind ?%d to %d in stmt %s, error = %d\",\n                  BIND_CONFIG_VALUE, 0, SQL_STMT_CONFIG[STMT_CONFIG_INSERT].stmt, ret);\n        return -1;\n    }\n\n    ret = sqlite3_step(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT]);\n    if (ret != SQLITE_DONE) {\n        LOG_ERROR(\"sqlite3_step returns %d\", ret);\n        return -1;\n    }\n\n    ret = sqlite3_reset(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n        return -1;\n    }\n\n    assert(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT]);\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT], BIND_CONFIG_ID, CONFIG_ID_LIFETIME);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot bind ?%d to %d in stmt %s, error = %d\",\n                  BIND_CONFIG_ID, CONFIG_ID_LIFETIME, SQL_STMT_CONFIG[STMT_CONFIG_SELECT].stmt, ret);\n        return -1;\n    }\n\n    ret = sqlite3_step(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT]);\n    if (ret != SQLITE_ROW) {\n        LOG_ERROR(\"sqlite3_step returns %d\", ret);\n        return -1;\n    }\n\n    pgdata->static_data.original_lifetime = sqlite3_column_int(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT],\n                                                               SQL_STMT_CONFIG[STMT_CONFIG_SELECT].column\n                                                               [COLUMN_CONFIG_VALUE]);\n    pgdata->static_data.new_lifetime = pgdata->static_data.original_lifetime;\n\n    ret = sqlite3_reset(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n        return -1;\n    }\n\n    return 0;\n}",
        "begin_line": 169,
        "end_line": 228,
        "is_bug": false
    },
    {
        "name": "src.chewing-sql.TerminateUserphrase#479",
        "src_path": "src/chewing-sql.c",
        "class_name": "src.chewing-sql",
        "signature": "src.chewing-sql.TerminateUserphrase(ChewingData *pgdata)",
        "snippet": "void TerminateUserphrase(ChewingData *pgdata)\n{\n    size_t i;\n    int ret;\n\n    UpdateLifeTime(pgdata);\n\n    for (i = 0; i < ARRAY_SIZE(pgdata->static_data.stmt_config); ++i) {\n        sqlite3_finalize(pgdata->static_data.stmt_config[i]);\n        pgdata->static_data.stmt_config[i] = NULL;\n    }\n\n    for (i = 0; i < ARRAY_SIZE(pgdata->static_data.stmt_userphrase); ++i) {\n        sqlite3_finalize(pgdata->static_data.stmt_userphrase[i]);\n        pgdata->static_data.stmt_userphrase[i] = NULL;\n    }\n\n    ret = sqlite3_close(pgdata->static_data.db);\n    assert(SQLITE_OK == ret);\n    pgdata->static_data.db = NULL;\n}",
        "begin_line": 479,
        "end_line": 499,
        "is_bug": false
    },
    {
        "name": "src.chewing-sql.UpdateLifeTime#230",
        "src_path": "src/chewing-sql.c",
        "class_name": "src.chewing-sql",
        "signature": "src.chewing-sql.UpdateLifeTime(ChewingData *pgdata)",
        "snippet": "static int UpdateLifeTime(ChewingData *pgdata)\n{\n    int ret;\n    int result = 0;\n\n    if (!pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE]) {\n        LOG_ERROR(\"pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE] is NULL\");\n        result = -1;\n        goto end;\n    }\n\n    ret = sqlite3_clear_bindings(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_clear_bindings returns %d\", ret);\n        result = -1;\n        goto end;\n    }\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE], BIND_CONFIG_ID, CONFIG_ID_LIFETIME);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot bind ?%d to %d in stmt %s, error = %d\",\n                  BIND_CONFIG_ID, CONFIG_ID_LIFETIME, SQL_STMT_CONFIG[STMT_CONFIG_INCREASE].stmt, ret);\n        result = -1;\n        goto end;\n    }\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE],\n                           BIND_CONFIG_VALUE, pgdata->static_data.new_lifetime - pgdata->static_data.original_lifetime);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot bind ?%d to %d in stmt %s, error = %d\",\n                  BIND_CONFIG_VALUE,\n                  pgdata->static_data.new_lifetime - pgdata->static_data.original_lifetime,\n                  SQL_STMT_CONFIG[STMT_CONFIG_INCREASE].stmt, ret);\n        result = -1;\n        goto end;\n    }\n\n    ret = sqlite3_step(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE]);\n    if (ret != SQLITE_DONE) {\n        LOG_ERROR(\"sqlite3_step returns %d\", ret);\n        result = -1;\n        goto end;\n    }\n\n  end:\n    ret = sqlite3_reset(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n        result = -1;\n    }\n\n    return result;\n}",
        "begin_line": 230,
        "end_line": 282,
        "is_bug": false
    },
    {
        "name": "src.chewingio.NullLogger#141",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.NullLogger(void *data UNUSED, int level UNUSED, const char *fmt UNUSED, ...)",
        "snippet": "static void NullLogger(void *data UNUSED, int level UNUSED, const char *fmt UNUSED, ...)\n{\n}",
        "begin_line": 141,
        "end_line": 143,
        "is_bug": false
    },
    {
        "name": "src.chewingio.allocate_ChewingData#145",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.allocate_ChewingData(void (*logger) (void *data, int level, const char *fmt, ...), void *loggerdata)",
        "snippet": "static ChewingData *allocate_ChewingData(void (*logger) (void *data, int level, const char *fmt, ...), void *loggerdata)\n{\n    static const int DEFAULT_SELKEY[] = { '1', '2', '3', '4', '5', '6', '7', '8', '9', '0' };\n\n    ChewingData *data = ALC(ChewingData, 1);\n\n    if (data) {\n        data->config.candPerPage = MAX_SELKEY;\n        data->config.maxChiSymbolLen = MAX_CHI_SYMBOL_LEN;\n        data->logger = logger;\n        data->loggerData = loggerdata;\n        memcpy(data->config.selKey, DEFAULT_SELKEY, sizeof(data->config.selKey));\n    }\n\n    return data;\n}",
        "begin_line": 145,
        "end_line": 160,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chooseCandidate#101",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chooseCandidate(ChewingContext *ctx, int toSelect, int key_buf_cursor)",
        "snippet": "static void chooseCandidate(ChewingContext *ctx, int toSelect, int key_buf_cursor)\n{\n    ChewingData *pgdata = ctx->data;\n\n    if (toSelect) {\n        if (!pgdata->bSelect) {\n            ChoiceInitAvail(pgdata);\n        } else {\n            if (ChoiceHasNextAvail(pgdata))\n                ChoiceNextAvail(pgdata);\n            else                /* rollover */\n                ChoiceFirstAvail(pgdata);\n        }\n    } else if (pgdata->symbolKeyBuf[key_buf_cursor]) {\n        /* Open Symbol Choice List */\n        if (pgdata->choiceInfo.isSymbol == WORD_CHOICE) {\n            OpenSymbolChoice(pgdata);\n        }\n        /**\n         * If these's only one candidate list available, ChoiceFirstAvail\n         * will re-open the list, namely turn back to the firt page.\n         * However, it doesn't work for symbols, therefore we\n         * set the page number to 0 directly.\n         */\n        else if (pgdata->bSelect) {\n            pgdata->choiceInfo.pageNo = 0;\n        }\n    } else {\n        /*\n         * The cursor position is not word, nor symbol. The only\n         * possible case is that user just uses ` to open symbol\n         * selection. In this case, when chooseCandidate is called,\n         * libchewing needs to reset pageNo to 0 to do rollover.\n         */\n        if (pgdata->bSelect) {\n            pgdata->choiceInfo.pageNo = 0;\n        }\n    }\n}",
        "begin_line": 101,
        "end_line": 139,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.AddChi#646",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.AddChi(uint16_t phone, uint16_t phoneAlt, ChewingData *pgdata)",
        "snippet": "int AddChi(uint16_t phone, uint16_t phoneAlt, ChewingData *pgdata)\n{\n    int i;\n    int cursor = PhoneSeqCursor(pgdata);\n\n    /* shift the selectInterval */\n    for (i = 0; i < pgdata->nSelect; i++) {\n        if (pgdata->selectInterval[i].from >= cursor) {\n            pgdata->selectInterval[i].from++;\n            pgdata->selectInterval[i].to++;\n        }\n    }\n\n    /* shift the Brkpt */\n    assert(pgdata->nPhoneSeq >= cursor);\n    memmove(&(pgdata->bUserArrBrkpt[cursor + 2]),\n            &(pgdata->bUserArrBrkpt[cursor + 1]), sizeof(int) * (pgdata->nPhoneSeq - cursor));\n    memmove(&(pgdata->bUserArrCnnct[cursor + 2]),\n            &(pgdata->bUserArrCnnct[cursor + 1]), sizeof(int) * (pgdata->nPhoneSeq - cursor));\n\n    /* add to phoneSeq */\n    memmove(&(pgdata->phoneSeq[cursor + 1]),\n            &(pgdata->phoneSeq[cursor]), sizeof(uint16_t) * (pgdata->nPhoneSeq - cursor));\n    pgdata->phoneSeq[cursor] = phone;\n    memmove(&(pgdata->phoneSeqAlt[cursor + 1]),\n            &(pgdata->phoneSeqAlt[cursor]), sizeof(uint16_t) * (pgdata->nPhoneSeq - cursor));\n    pgdata->phoneSeqAlt[cursor] = phoneAlt;\n    pgdata->nPhoneSeq++;\n\n    /* add to chiSymbolBuf */\n    assert(pgdata->chiSymbolBufLen >= pgdata->chiSymbolCursor);\n    memmove(&(pgdata->preeditBuf[pgdata->chiSymbolCursor + 1]),\n            &(pgdata->preeditBuf[pgdata->chiSymbolCursor]),\n            sizeof(pgdata->preeditBuf[0]) * (pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));\n    /* \"0\" means Chinese word */\n    pgdata->preeditBuf[pgdata->chiSymbolCursor].category = CHEWING_CHINESE;\n    pgdata->chiSymbolBufLen++;\n    pgdata->chiSymbolCursor++;\n\n    return 0;\n}",
        "begin_line": 646,
        "end_line": 686,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.AddSelect#895",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.AddSelect(ChewingData *pgdata, int sel_i)",
        "snippet": "int AddSelect(ChewingData *pgdata, int sel_i)\n{\n    int length, nSelect, cursor;\n\n    /* save the typing time */\n    length = pgdata->availInfo.avail[pgdata->availInfo.currentAvail].len;\n    nSelect = pgdata->nSelect;\n\n    /* change \"selectStr\" , \"selectInterval\" , and \"nSelect\" of ChewingData */\n    ueStrNCpy(pgdata->selectStr[nSelect], pgdata->choiceInfo.totalChoiceStr[sel_i], length, 1);\n    cursor = PhoneSeqCursor(pgdata);\n    pgdata->selectInterval[nSelect].from = cursor;\n    pgdata->selectInterval[nSelect].to = cursor + length;\n    pgdata->nSelect++;\n    return 0;\n}",
        "begin_line": 895,
        "end_line": 910,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.AutoLearnPhrase#570",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.AutoLearnPhrase(ChewingData *pgdata)",
        "snippet": "void AutoLearnPhrase(ChewingData *pgdata)\n{\n    uint16_t bufPhoneSeq[MAX_PHONE_SEQ_LEN + 1];\n    char bufWordSeq[MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1] = { 0 };\n    char *pos;\n    int i;\n    int from;\n    int fromPreeditBuf;\n    int len;\n    int prev_pos = 0;\n    int pending_pos = 0;\n\n    /*\n     * FIXME: pgdata->preferInterval does not consider symbol, so we need to\n     * do translate when using APIs that considering symbol.\n     */\n\n    UserUpdatePhraseBegin(pgdata);\n\n    for (i = 0; i < pgdata->nPrefer; i++) {\n        from = pgdata->preferInterval[i].from;\n        len = pgdata->preferInterval[i].to - from;\n        fromPreeditBuf = toPreeditBufIndex(pgdata, from);\n\n        LOG_VERBOSE(\"interval from = %d, fromPreeditBuf = %d, len = %d, pending_pos = %d\", from, fromPreeditBuf, len,\n                    pending_pos);\n\n        if (pending_pos != 0 && pending_pos < fromPreeditBuf) {\n            /*\n             * There is a pending phrase in buffer and it is not\n             * connected to current phrase. We store it as\n             * userphrase here.\n             */\n            UserUpdatePhrase(pgdata, bufPhoneSeq, bufWordSeq);\n            prev_pos = 0;\n            pending_pos = 0;\n        }\n\n        if (len == 1 && !ChewingIsBreakPoint(fromPreeditBuf, pgdata)) {\n            /*\n             * There is a length one phrase and it is not a break\n             * point. We store it and try to connect to other length\n             * one phrase if possible.\n             */\n            memcpy(bufPhoneSeq + prev_pos, &pgdata->phoneSeq[from], sizeof(uint16_t) * len);\n            bufPhoneSeq[prev_pos + len] = (uint16_t) 0;\n\n            pos = ueStrSeek(bufWordSeq, prev_pos);\n            copyStringFromPreeditBuf(pgdata, fromPreeditBuf, len, pos, bufWordSeq + sizeof(bufWordSeq) - pos);\n            prev_pos += len;\n            pending_pos = fromPreeditBuf + len;\n\n        } else {\n            if (pending_pos) {\n                /*\n                 * Clean pending phrase because we cannot join\n                 * it with current phrase.\n                 */\n                UserUpdatePhrase(pgdata, bufPhoneSeq, bufWordSeq);\n                prev_pos = 0;\n                pending_pos = 0;\n            }\n            memcpy(bufPhoneSeq, &pgdata->phoneSeq[from], sizeof(uint16_t) * len);\n            bufPhoneSeq[len] = (uint16_t) 0;\n            copyStringFromPreeditBuf(pgdata, fromPreeditBuf, len, bufWordSeq, sizeof(bufWordSeq));\n            UserUpdatePhrase(pgdata, bufPhoneSeq, bufWordSeq);\n        }\n    }\n\n    if (pending_pos) {\n        UserUpdatePhrase(pgdata, bufPhoneSeq, bufWordSeq);\n    }\n\n    UserUpdatePhraseEnd(pgdata);\n}",
        "begin_line": 570,
        "end_line": 644,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.CallPhrasing#719",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.CallPhrasing(ChewingData *pgdata, int all_phrasing)",
        "snippet": "int CallPhrasing(ChewingData *pgdata, int all_phrasing)\n{\n    /* set \"bSymbolArrBrkpt\" && \"bArrBrkpt\" */\n    int i, ch_count = 0;\n\n    memcpy(pgdata->bArrBrkpt, pgdata->bUserArrBrkpt, (MAX_PHONE_SEQ_LEN + 1) * sizeof(int));\n    memset(pgdata->bSymbolArrBrkpt, 0, (MAX_PHONE_SEQ_LEN + 1) * sizeof(int));\n\n    for (i = 0; i < pgdata->chiSymbolBufLen; i++) {\n        if (ChewingIsChiAt(i, pgdata))\n            ch_count++;\n        else {\n            pgdata->bArrBrkpt[ch_count] = 1;\n            pgdata->bSymbolArrBrkpt[ch_count] = 1;\n        }\n    }\n\n    /* kill select interval */\n    for (i = 0; i < pgdata->nPhoneSeq; i++) {\n        if (pgdata->bArrBrkpt[i]) {\n            ChewingKillSelectIntervalAcross(i, pgdata);\n        }\n    }\n\n    ShowChewingData(pgdata);\n\n    /* then phrasing */\n    Phrasing(pgdata, all_phrasing);\n\n    /* and then make prefer interval */\n    MakePreferInterval(pgdata);\n\n    return 0;\n}",
        "begin_line": 719,
        "end_line": 752,
        "is_bug": true
    },
    {
        "name": "src.chewingutil.ChewingIsBreakPoint#532",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ChewingIsBreakPoint(int cursor, ChewingData *pgdata)",
        "snippet": "static int ChewingIsBreakPoint(int cursor, ChewingData *pgdata)\n{\n    static const char *const BREAK_WORD[] = {\n        \"\\xE6\\x98\\xAF\", \"\\xE7\\x9A\\x84\", \"\\xE4\\xBA\\x86\", \"\\xE4\\xB8\\x8D\",\n        /* \u662f              \u7684              \u4e86              \u4e0d */\n        \"\\xE4\\xB9\\x9F\", \"\\xE8\\x80\\x8C\", \"\\xE4\\xBD\\xA0\", \"\\xE6\\x88\\x91\",\n        /* \u4e5f              \u800c              \u4f60              \u6211 */\n        \"\\xE4\\xBB\\x96\", \"\\xE8\\x88\\x87\", \"\\xE5\\xAE\\x83\", \"\\xE5\\xA5\\xB9\",\n        /* \u4ed6              \u8207              \u5b83              \u5979 */\n        \"\\xE5\\x85\\xB6\", \"\\xE5\\xB0\\xB1\", \"\\xE5\\x92\\x8C\", \"\\xE6\\x88\\x96\",\n        /* \u5176              \u5c31              \u548c              \u6216 */\n        \"\\xE5\\x80\\x91\", \"\\xE6\\x80\\xA7\", \"\\xE5\\x93\\xA1\", \"\\xE5\\xAD\\x90\",\n        /* \u5011              \u6027              \u54e1              \u5b50 */\n        \"\\xE4\\xB8\\x8A\", \"\\xE4\\xB8\\x8B\", \"\\xE4\\xB8\\xAD\", \"\\xE5\\x85\\xA7\",\n        /* \u4e0a              \u4e0b              \u4e2d              \u5167 */\n        \"\\xE5\\xA4\\x96\", \"\\xE5\\x8C\\x96\", \"\\xE8\\x80\\x85\", \"\\xE5\\xAE\\xB6\",\n        /* \u5916              \u5316              \u8005              \u5bb6 */\n        \"\\xE5\\x85\\x92\", \"\\xE5\\xB9\\xB4\", \"\\xE6\\x9C\\x88\", \"\\xE6\\x97\\xA5\",\n        /* \u5152              \u5e74              \u6708              \u65e5 */\n        \"\\xE6\\x99\\x82\", \"\\xE5\\x88\\x86\", \"\\xE7\\xA7\\x92\", \"\\xE8\\xA1\\x97\",\n        /* \u6642              \u5206              \u79d2              \u8857 */\n        \"\\xE8\\xB7\\xAF\", \"\\xE6\\x9D\\x91\",\n        /* \u8def              \u6751 */\n        \"\\xE5\\x9C\\xA8\",\n        /* \u5728 */\n    };\n    size_t i;\n\n    if (!ChewingIsChiAt(cursor, pgdata))\n        return 1;\n\n    for (i = 0; i < ARRAY_SIZE(BREAK_WORD); ++i)\n        if (!strcmp(pgdata->preeditBuf[cursor].char_, BREAK_WORD[i]))\n            return 1;\n\n    return 0;\n}\n\nvoid AutoLearnPhrase(ChewingData *pgdata)\n{\n    uint16_t bufPhoneSeq[MAX_PHO",
        "begin_line": 532,
        "end_line": 568,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ChewingIsChiAt#942",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ChewingIsChiAt(int chiSymbolCursor, ChewingData *pgdata)",
        "snippet": "int ChewingIsChiAt(int chiSymbolCursor, ChewingData *pgdata)\n{\n    return pgdata->preeditBuf[chiSymbolCursor].category == CHEWING_CHINESE;\n}",
        "begin_line": 942,
        "end_line": 945,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ChewingIsEntering#106",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ChewingIsEntering(ChewingData *pgdata)",
        "snippet": "int ChewingIsEntering(ChewingData *pgdata)\n{\n    if (pgdata->choiceInfo.isSymbol != WORD_CHOICE)\n        return 1;\n    return (pgdata->chiSymbolBufLen != 0 || BopomofoIsEntering(&(pgdata->bopomofoData)));\n}",
        "begin_line": 106,
        "end_line": 111,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ChewingKillChar#990",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ChewingKillChar(ChewingData *pgdata, int chiSymbolCursorToKill, int minus)",
        "snippet": "int ChewingKillChar(ChewingData *pgdata, int chiSymbolCursorToKill, int minus)\n{\n    int tmp, cursorToKill;\n\n    tmp = pgdata->chiSymbolCursor;\n    pgdata->chiSymbolCursor = chiSymbolCursorToKill;\n    cursorToKill = PhoneSeqCursor(pgdata);\n    pgdata->chiSymbolCursor = tmp;\n    if (ChewingIsChiAt(chiSymbolCursorToKill, pgdata)) {\n        KillCharInSelectIntervalAndBrkpt(pgdata, cursorToKill);\n        assert(pgdata->nPhoneSeq - cursorToKill - 1 >= 0);\n        memmove(&(pgdata->phoneSeq[cursorToKill]),\n                &(pgdata->phoneSeq[cursorToKill + 1]), (pgdata->nPhoneSeq - cursorToKill - 1) * sizeof(uint16_t));\n        pgdata->nPhoneSeq--;\n    }\n    pgdata->symbolKeyBuf[chiSymbolCursorToKill] = 0;\n    assert(pgdata->chiSymbolBufLen - chiSymbolCursorToKill);\n    memmove(&pgdata->symbolKeyBuf[chiSymbolCursorToKill],\n            &pgdata->symbolKeyBuf[chiSymbolCursorToKill + 1],\n            sizeof(pgdata->symbolKeyBuf[0]) * (pgdata->chiSymbolBufLen - chiSymbolCursorToKill));\n    memmove(&pgdata->preeditBuf[chiSymbolCursorToKill],\n            &pgdata->preeditBuf[chiSymbolCursorToKill + 1],\n            sizeof(pgdata->preeditBuf[0]) * (pgdata->chiSymbolBufLen - chiSymbolCursorToKill));\n    pgdata->chiSymbolBufLen--;\n    pgdata->chiSymbolCursor -= minus;\n    if (pgdata->chiSymbolCursor < 0)\n        pgdata->chiSymbolCursor = 0;\n    return 0;\n}",
        "begin_line": 990,
        "end_line": 1018,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ChewingKillSelectIntervalAcross#955",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ChewingKillSelectIntervalAcross(int cursor, ChewingData *pgdata)",
        "snippet": "static int ChewingKillSelectIntervalAcross(int cursor, ChewingData *pgdata)\n{\n    int i;\n\n    for (i = 0; i < pgdata->nSelect; i++) {\n        if (pgdata->selectInterval[i].from < cursor && pgdata->selectInterval[i].to > cursor) {\n            RemoveSelectElement(i, pgdata);\n            i--;\n        }\n    }\n    return 0;\n}",
        "begin_line": 955,
        "end_line": 966,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.CleanAllBuf#486",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.CleanAllBuf(ChewingData *pgdata)",
        "snippet": "void CleanAllBuf(ChewingData *pgdata)\n{\n    /* 1 */\n    pgdata->nPhoneSeq = 0;\n    memset(pgdata->phoneSeq, 0, sizeof(pgdata->phoneSeq));\n    /* 2 */\n    pgdata->chiSymbolBufLen = 0;\n    memset(pgdata->preeditBuf, 0, sizeof(pgdata->preeditBuf));\n    /* 3 */\n    memset(pgdata->bUserArrBrkpt, 0, sizeof(pgdata->bUserArrBrkpt));\n    /* 4 */\n    pgdata->nSelect = 0;\n    /* 5 */\n    pgdata->chiSymbolCursor = 0;\n    /* 6 */\n    memset(pgdata->bUserArrCnnct, 0, sizeof(pgdata->bUserArrCnnct));\n\n    pgdata->phrOut.nNumCut = 0;\n\n    memset(pgdata->symbolKeyBuf, 0, sizeof(pgdata->symbolKeyBuf));\n\n    pgdata->nPrefer = 0;\n}",
        "begin_line": 486,
        "end_line": 508,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.CompInterval#413",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.CompInterval(const IntervalType * a, const IntervalType * b)",
        "snippet": "static int CompInterval(const IntervalType * a, const IntervalType * b)\n{\n    int cmp = a->from - b->from;\n\n    if (cmp)\n        return cmp;\n    return (a->to - b->to);\n}",
        "begin_line": 413,
        "end_line": 420,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.CountReleaseNum#451",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.CountReleaseNum(ChewingData *pgdata)",
        "snippet": "static int CountReleaseNum(ChewingData *pgdata)\n{\n    int remain, i;\n\n    remain = pgdata->config.maxChiSymbolLen - pgdata->chiSymbolBufLen;\n    if (remain >= 0)\n        return 0;\n\n    qsort(pgdata->preferInterval, pgdata->nPrefer, sizeof(IntervalType), (CompFuncType) CompInterval);\n\n    if (!ChewingIsChiAt(0, pgdata)) {\n        for (i = 0; i < pgdata->chiSymbolCursor; ++i) {\n            if (ChewingIsChiAt(i, pgdata)) {\n                break;\n            }\n        }\n        return i;\n    }\n\n    i = FindIntervalFrom(0, pgdata->preferInterval, pgdata->nPrefer);\n    if (i >= 0) {\n        return (pgdata->preferInterval[i].to - pgdata->preferInterval[i].from);\n    }\n\n    return 1;\n}",
        "begin_line": 451,
        "end_line": 476,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.CountSelKeyNum#912",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.CountSelKeyNum(int key, const ChewingData *pgdata)         /* return value starts from 0.  If less than zero : error key */",
        "snippet": "int CountSelKeyNum(int key, const ChewingData *pgdata)\n        /* return value starts from 0.  If less than zero : error key */\n{\n    int i;\n\n    for (i = 0; i < MAX_SELKEY; i++)\n        if (pgdata->config.selKey[i] == key)\n            return i;\n    return -1;\n}",
        "begin_line": 912,
        "end_line": 921,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.CountSymbols#923",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.CountSymbols(ChewingData *pgdata, int to)",
        "snippet": "int CountSymbols(ChewingData *pgdata, int to)\n{\n    int chi;\n    int i;\n\n    for (chi = i = 0; i < to; i++) {\n        if (ChewingIsChiAt(i, pgdata))\n            chi++;\n    }\n    return to - chi;\n}",
        "begin_line": 923,
        "end_line": 933,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.FindEasySymbolIndex#66",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.FindEasySymbolIndex(char ch)",
        "snippet": "static int FindEasySymbolIndex(char ch)\n{\n        /**\n         * '0' => 0, ..., '9' => 9\n         * 'A' => 10, 'B' => 11, ... 'Z' => 35\n         */\n    if (isdigit(ch)) {\n        return ch - '0';\n    } else if (isupper(ch)) {\n        return ch - 'A' + 10;\n    } else {\n        return -1;\n    }\n}",
        "begin_line": 66,
        "end_line": 79,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.FindIntervalFrom#422",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.FindIntervalFrom(int from, IntervalType inte[], int nInte)",
        "snippet": "static int FindIntervalFrom(int from, IntervalType inte[], int nInte)\n{\n    int i;\n\n    for (i = 0; i < nInte; i++)\n        if (inte[i].from == from)\n            return i;\n    return -1;\n}",
        "begin_line": 422,
        "end_line": 430,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.FindSymbolKey#1189",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.FindSymbolKey(const char *symbol)",
        "snippet": "static int FindSymbolKey(const char *symbol)\n{\n    unsigned int i;\n    const char *const *buf;\n\n    for (i = 0; i < ARRAY_SIZE(symbol_buf); ++i) {\n        for (buf = symbol_buf[i]; *buf; ++buf) {\n            if (0 == strcmp(*buf, symbol))\n                return *symbol_buf[i][0];\n        }\n    }\n    return 0;\n}",
        "begin_line": 1189,
        "end_line": 1201,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.FullShapeSymbolInput#222",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.FullShapeSymbolInput(int key, ChewingData *pgdata)",
        "snippet": "int FullShapeSymbolInput(int key, ChewingData *pgdata)\n{\n    int rtn;\n\n    static char keybuf[] = {\n        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n        'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n        'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D',\n        'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\n        'Y', 'Z', ' ', '\\\"', '\\'', '/', '<', '>', '`', '[',\n        ']', '{', '}', '+', '-'\n    };\n    static const char *chibuf[] = {\n        \"\\xEF\\xBC\\x90\", \"\\xEF\\xBC\\x91\", \"\\xEF\\xBC\\x92\", \"\\xEF\\xBC\\x93\",\n        /* \"\uff10\",\"\uff11\",\"\uff12\",\"\uff13\" */\n        \"\\xEF\\xBC\\x94\", \"\\xEF\\xBC\\x95\", \"\\xEF\\xBC\\x96\", \"\\xEF\\xBC\\x97\",\n        /* \"\uff14\",\"\uff15\",\"\uff16\",\"\uff17\" */\n        \"\\xEF\\xBC\\x98\", \"\\xEF\\xBC\\x99\", \"\\xEF\\xBD\\x81\", \"\\xEF\\xBD\\x82\",\n        /* \"\uff18\",\"\uff19\",\"\uff41\",\"\uff42\" */\n        \"\\xEF\\xBD\\x83\", \"\\xEF\\xBD\\x84\", \"\\xEF\\xBD\\x85\", \"\\xEF\\xBD\\x86\",\n        /* \"\uff43\",\"\uff44\",\"\uff45\",\"\uff46\" */\n        \"\\xEF\\xBD\\x87\", \"\\xEF\\xBD\\x88\", \"\\xEF\\xBD\\x89\", \"\\xEF\\xBD\\x8A\",\n        /* \"\uff47\",\"\uff48\",\"\uff49\",\"\uff4a\" */\n        \"\\xEF\\xBD\\x8B\", \"\\xEF\\xBD\\x8C\", \"\\xEF\\xBD\\x8D\", \"\\xEF\\xBD\\x8E\",\n        /* \"\uff4b\",\"\uff4c\",\"\uff4d\",\"\uff4e\" */\n        \"\\xEF\\xBD\\x8F\", \"\\xEF\\xBD\\x90\", \"\\xEF\\xBD\\x91\", \"\\xEF\\xBD\\x92\",\n        /* \"\uff4f\",\"\uff50\",\"\uff51\",\"\uff52\" */\n        \"\\xEF\\xBD\\x93\", \"\\xEF\\xBD\\x94\", \"\\xEF\\xBD\\x95\", \"\\xEF\\xBD\\x96\",\n        /* \"\uff53\",\"\uff54\",\"\uff55\",\"\uff56\" */\n        \"\\xEF\\xBD\\x97\", \"\\xEF\\xBD\\x98\", \"\\xEF\\xBD\\x99\", \"\\xEF\\xBD\\x9A\",\n        /* \"\uff57\",\"\uff58\",\"\uff59\",\"\uff5a\" */\n        \"\\xEF\\xBC\\xA1\", \"\\xEF\\xBC\\xA2\", \"\\xEF\\xBC\\xA3\", \"\\xEF\\xBC\\xA4\",\n        /* \"\uff21\",\"\uff22\",\"\uff23\",\"\uff24\" */\n        \"\\xEF\\xBC\\xA5\", \"\\xEF\\xBC\\xA6\", \"\\xEF\\xBC\\xA7\", \"\\xEF\\xBC\\xA8\",\n        /* \"\uff25\",\"\uff26\",\"\uff27\",\"\uff28\" */\n        \"\\xEF\\xBC\\xA9\", \"\\xEF\\xBC\\xAA\", \"\\xEF\\xBC\\xAB\", \"\\xEF\\xBC\\xAC\",\n        /* \"\uff29\",\"\uff2a\",\"\uff2b\",\"\uff2c\" */\n        \"\\xEF\\xBC\\xAD\", \"\\xEF\\xBC\\xAE\", \"\\xEF\\xBC\\xAF\", \"\\xEF\\xBC\\xB0\",\n        /* \"\uff2d\",\"\uff2e\",\"\uff2f\",\"\uff30\" */\n        \"\\xEF\\xBC\\xB1\", \"\\xEF\\xBC\\xB2\", \"\\xEF\\xBC\\xB3\", \"\\xEF\\xBC\\xB4\",\n        /* \"\uff31\",\"\uff32\",\"\uff33\",\"\uff34\" */\n        \"\\xEF\\xBC\\xB5\", \"\\xEF\\xBC\\xB6\", \"\\xEF\\xBC\\xB7\", \"\\xEF\\xBC\\xB8\",\n        /* \"\uff35\",\"\uff36\",\"\uff37\",\"\uff38\" */\n        \"\\xEF\\xBC\\xB9\", \"\\xEF\\xBC\\xBA\", \"\\xE3\\x80\\x80\", \"\\xE2\\x80\\x9D\",\n        /* \"\uff39\",\"\uff3a\",\"\u3000\",\"\u201d\" */\n        \"\\xE2\\x80\\x99\", \"\\xEF\\xBC\\x8F\", \"\\xEF\\xBC\\x9C\", \"\\xEF\\xBC\\x9E\",\n        /* \"\u2019\",\"\uff0f\",\"\uff1c\",\"\uff1e\" */\n        \"\\xE2\\x80\\xB5\", \"\\xE3\\x80\\x94\", \"\\xE3\\x80\\x95\", \"\\xEF\\xBD\\x9B\",\n        /* \"\u2035\",\"\u3014\"\"\u3015\",\"\uff5b\" */\n        \"\\xEF\\xBD\\x9D\", \"\\xEF\\xBC\\x8B\", \"\\xEF\\xBC\\x8D\"\n            /* \"\uff5d\",\"\uff0b\",\"\uff0d\" */\n    };\n    STATIC_ASSERT(ARRAY_SIZE(keybuf) == ARRAY_SIZE(chibuf));\n\n    rtn = InternalSpecialSymbol(key, pgdata, ARRAY_SIZE(keybuf), keybuf, chibuf);\n    if (rtn == BOPOMOFO_IGNORE)\n        rtn = SpecialSymbolInput(key, pgdata);\n    return (rtn == BOPOMOFO_IGNORE ? SYMBOL_KEY_ERROR : SYMBOL_KEY_OK);\n}\n\nint EasySymbolInput(int key, ChewingData *pgdata)\n{\n    int rtn, loop, _index;\n    char wordbuf[8];\n\n    int nSpecial = EASY_SYMBOL_KEY_TAB_LEN;\n\n  ",
        "begin_line": 222,
        "end_line": 282,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.HaninSymbolInput#113",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.HaninSymbolInput(ChewingData *pgdata)",
        "snippet": "int HaninSymbolInput(ChewingData *pgdata)\n{\n    unsigned int i;\n\n    ChoiceInfo *pci = &(pgdata->choiceInfo);\n    AvailInfo *pai = &(pgdata->availInfo);\n\n    /* No available symbol table */\n    if (!pgdata->static_data.symbol_table)\n        return BOPOMOFO_ABSORB;\n\n    pci->nTotalChoice = 0;\n    for (i = 0; i < pgdata->static_data.n_symbol_entry; i++) {\n        strcpy(pci->totalChoiceStr[pci->nTotalChoice], pgdata->static_data.symbol_table[i]->category);\n        pci->nTotalChoice++;\n    }\n    pai->avail[0].len = 1;\n    pai->avail[0].id = NULL;\n    pai->nAvail = 1;\n    pai->currentAvail = 0;\n    pci->nChoicePerPage = pgdata->config.candPerPage;\n    assert(pci->nTotalChoice > 0);\n    pci->nPage = CEIL_DIV(pci->nTotalChoice, pci->nChoicePerPage);\n    pci->pageNo = 0;\n    pci->isSymbol = SYMBOL_CATEGORY_CHOICE;\n    return BOPOMOFO_ABSORB;\n}",
        "begin_line": 113,
        "end_line": 139,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.InitEasySymbolInput#1367",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.InitEasySymbolInput(ChewingData *pgdata, const char *prefix)",
        "snippet": "int InitEasySymbolInput(ChewingData *pgdata, const char *prefix)\n{\n    static const size_t LINE_LEN = 512; // shall be long enough?\n\n    FILE *file = NULL;\n    char *filename = NULL;\n    char *line = NULL;\n    int len;\n    int _index;\n    char *symbol;\n    int ret = -1;\n\n    ret = asprintf(&filename, \"%s\" PLAT_SEPARATOR \"%s\", prefix, SOFTKBD_TABLE_FILE);\n    if (ret == -1)\n        goto filenamefail;\n\n    file = fopen(filename, \"r\");\n    if (!file)\n        goto fileopenfail;\n\n    line = ALC(char, LINE_LEN);\n    if (!line)\n        goto linefail;\n\n    while (fgets(line, LINE_LEN, file)) {\n        if (' ' != line[1])\n            continue;\n\n        // Remove tailing \\n\n        len = strcspn(line, \"\\r\\n\");\n\n        line[len] = '\\0';\n\n        _index = FindEasySymbolIndex(line[0]);\n        if (-1 == _index)\n            continue;\n\n        len = ueStrLen(&line[2]);\n        if (0 == len || len > MAX_PHRASE_LEN)\n            continue;\n\n        symbol = ALC(char, strlen(&line[2]) + 1);\n\n        if (!symbol)\n            goto end;\n\n        ueStrNCpy(symbol, &line[2], len, 1);\n\n        free(pgdata->static_data.g_easy_symbol_value[_index]);\n        pgdata->static_data.g_easy_symbol_value[_index] = symbol;\n        pgdata->static_data.g_easy_symbol_num[_index] = len;\n    }\n    ret = 0;\n\nend:\n    free(line);\n\nlinefail:\n    fclose(file);\n\nfileopenfail:\n    free(filename);\n\nfilenamefail:\n    return ret;\n}",
        "begin_line": 1367,
        "end_line": 1432,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.InitSymbolTable#1249",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.InitSymbolTable(ChewingData *pgdata, const char *prefix)",
        "snippet": "int InitSymbolTable(ChewingData *pgdata, const char *prefix)\n{\n    static const unsigned int MAX_SYMBOL_ENTRY = 100;\n    static const size_t LINE_LEN = 512; // shall be long enough?\n\n    char *filename = NULL;\n    FILE *file = NULL;\n    char *line = NULL;\n    SymbolEntry **entry = NULL;\n    char *category_end;\n    const char *symbols;\n    char *symbols_end;\n    const char *symbol;\n    size_t i;\n    size_t len;\n    size_t size;\n    int ret = -1;\n\n    pgdata->static_data.n_symbol_entry = 0;\n    pgdata->static_data.symbol_table = NULL;\n\n    ret = asprintf(&filename, \"%s\" PLAT_SEPARATOR \"%s\", prefix, SYMBOL_TABLE_FILE);\n    if (ret == -1)\n        goto error;\n\n    file = fopen(filename, \"r\");\n    if (!file)\n        goto error;\n\n    line = ALC(char, LINE_LEN);\n\n    if (!line)\n        goto error;\n\n    entry = ALC(SymbolEntry *, MAX_SYMBOL_ENTRY);\n\n    if (!entry)\n        goto error;\n\n    while (fgets(line, LINE_LEN, file) && pgdata->static_data.n_symbol_entry < MAX_SYMBOL_ENTRY) {\n\n        category_end = strpbrk(line, \"=\\r\\n\");\n        if (!category_end)\n            goto error;\n\n        symbols = category_end + 1;\n        symbols_end = strpbrk(symbols, \"\\r\\n\");\n        if (symbols_end) {\n            *symbols_end = 0;\n            len = ueStrLen(symbols);\n\n            entry[pgdata->static_data.n_symbol_entry] =\n                (SymbolEntry *) malloc(sizeof(entry[0][0]) + sizeof(entry[0][0].symbols[0]) * len);\n            if (!entry[pgdata->static_data.n_symbol_entry])\n                goto error;\n            entry[pgdata->static_data.n_symbol_entry]\n                ->nSymbols = len;\n\n            symbol = symbols;\n\n            for (i = 0; i < len; ++i) {\n                ueStrNCpy(entry[pgdata->static_data.n_symbol_entry]->symbols[i], symbol, 1, 1);\n                // FIXME: What if symbol is combining sequences.\n                symbol += ueBytesFromChar(symbol[0]);\n            }\n\n\n        } else {\n            entry[pgdata->static_data.n_symbol_entry] = (SymbolEntry *) malloc(sizeof(entry[0][0]));\n            if (!entry[pgdata->static_data.n_symbol_entry])\n                goto error;\n\n            entry[pgdata->static_data.n_symbol_entry]\n                ->nSymbols = 0;\n        }\n\n        *category_end = 0;\n        ueStrNCpy(entry[pgdata->static_data.n_symbol_entry]->category, line, MAX_PHRASE_LEN, 1);\n\n        ++pgdata->static_data.n_symbol_entry;\n    }\n\n    size = sizeof(*pgdata->static_data.symbol_table) * pgdata->static_data.n_symbol_entry;\n    if (!size)\n        goto end;\n    pgdata->static_data.symbol_table = (SymbolEntry **) malloc(size);\n    if (!pgdata->static_data.symbol_table)\n        goto error;\n    memcpy(pgdata->static_data.symbol_table, entry, size);\n\n    ret = 0;\n  end:\n    free(entry);\n    free(line);\n    fclose(file);\n    free(filename);\n    return ret;\n\n  error:\n    for (i = 0; i < pgdata->static_data.n_symbol_entry; ++i) {\n        free(entry[i]);\n    }\n    goto end;\n}",
        "begin_line": 1249,
        "end_line": 1352,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.InternalSpecialSymbol#176",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.InternalSpecialSymbol(int key, ChewingData *pgdata, int nSpecial, const char keybuf[], const char *const chibuf[])",
        "snippet": "static int InternalSpecialSymbol(int key, ChewingData *pgdata,\n                                 int nSpecial, const char keybuf[], const char *const chibuf[])\n{\n    int i, rtn = BOPOMOFO_IGNORE;   /* very strange and difficult to understand */\n\n    for (i = 0; i < nSpecial; i++) {\n        if (1 == _Inner_InternalSpecialSymbol(key, pgdata, keybuf[i], chibuf[i])) {\n            rtn = BOPOMOFO_ABSORB;\n            break;\n        }\n    }\n    return rtn;\n}",
        "begin_line": 176,
        "end_line": 188,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.IsPreferIntervalConnted#1020",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.IsPreferIntervalConnted(int cursor, ChewingData *pgdata)",
        "snippet": "int IsPreferIntervalConnted(int cursor, ChewingData *pgdata)\n{\n    int i;\n\n    for (i = 0; i < pgdata->nPrefer; i++) {\n        if (pgdata->preferInterval[i].from < cursor && pgdata->preferInterval[i].to > cursor)\n            return 1;\n    }\n    return 0;\n}",
        "begin_line": 1020,
        "end_line": 1029,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.KillCharInSelectIntervalAndBrkpt#968",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.KillCharInSelectIntervalAndBrkpt(ChewingData *pgdata, int cursorToKill)",
        "snippet": "static int KillCharInSelectIntervalAndBrkpt(ChewingData *pgdata, int cursorToKill)\n{\n    int i;\n\n    for (i = 0; i < pgdata->nSelect; i++) {\n        if (pgdata->selectInterval[i].from <= cursorToKill && pgdata->selectInterval[i].to > cursorToKill) {\n            RemoveSelectElement(i, pgdata);\n            i--;                /* the last one was swap to i, we need to recheck i */\n        } else if (pgdata->selectInterval[i].from > cursorToKill) {\n            pgdata->selectInterval[i].from--;\n            pgdata->selectInterval[i].to--;\n        }\n    }\n    assert(pgdata->nPhoneSeq >= cursorToKill);\n    memmove(&(pgdata->bUserArrBrkpt[cursorToKill]),\n            &(pgdata->bUserArrBrkpt[cursorToKill + 1]), sizeof(int) * (pgdata->nPhoneSeq - cursorToKill));\n    memmove(&(pgdata->bUserArrCnnct[cursorToKill]),\n            &(pgdata->bUserArrCnnct[cursorToKill + 1]), sizeof(int) * (pgdata->nPhoneSeq - cursorToKill));\n\n    return 0;\n}",
        "begin_line": 968,
        "end_line": 988,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.KillFromLeft#478",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.KillFromLeft(ChewingData *pgdata, int nKill)",
        "snippet": "static void KillFromLeft(ChewingData *pgdata, int nKill)\n{\n    int i;\n\n    for (i = 0; i < nKill; i++)\n        ChewingKillChar(pgdata, 0, DECREASE_CURSOR);\n}",
        "begin_line": 478,
        "end_line": 484,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.MakeOutput#836",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.MakeOutput(ChewingOutput *pgo, ChewingData *pgdata)",
        "snippet": "int MakeOutput(ChewingOutput *pgo, ChewingData *pgdata)\n{\n    int i;\n    int inx;\n    char *pos;\n\n    /* fill zero to chiSymbolBuf first */\n    pgo->preeditBuf[0] = 0;\n    pgo->bopomofoBuf[0] = 0;\n\n    pos = pgo->preeditBuf;\n    for (i = 0; i < pgdata->chiSymbolBufLen && pos < pgo->preeditBuf + sizeof(pgo->preeditBuf) + MAX_UTF8_SIZE + 1; ++i) {\n        strncpy(pos, pgdata->preeditBuf[i].char_, MAX_UTF8_SIZE + 1);\n        pos += strlen(pgdata->preeditBuf[i].char_);\n    }\n\n    /* fill point */\n    pgo->PointStart = pgdata->PointStart;\n    pgo->PointEnd = pgdata->PointEnd;\n\n    /* fill other fields */\n    pgo->chiSymbolBufLen = pgdata->chiSymbolBufLen;\n    pgo->chiSymbolCursor = pgdata->chiSymbolCursor;\n\n    /* fill bopomofoBuf */\n    if (pgdata->bopomofoData.kbtype >= KB_HANYU_PINYIN) {\n        strcpy(pgo->bopomofoBuf, pgdata->bopomofoData.pinYinData.keySeq);\n    } else {\n        for (i = 0; i < BOPOMOFO_SIZE; i++) {\n            inx = pgdata->bopomofoData.pho_inx[i];\n            if (inx != 0) {\n                ueStrNCpy(pgo->bopomofoBuf + strlen(pgo->bopomofoBuf),\n                          ueConstStrSeek(zhuin_tab[i], inx - 1),\n                          1, STRNCPY_CLOSE);\n            }\n        }\n    }\n\n    ShiftInterval(pgo, pgdata);\n    memcpy(pgo->dispBrkpt, pgdata->bUserArrBrkpt, sizeof(pgo->dispBrkpt[0]) * (MAX_PHONE_SEQ_LEN + 1));\n    pgo->pci = &(pgdata->choiceInfo);\n    pgo->bChiSym = pgdata->bChiSym;\n    memcpy(pgo->selKey, pgdata->config.selKey, sizeof(pgdata->config.selKey));\n    pgdata->bShowMsg = 0;\n    return 0;\n}",
        "begin_line": 836,
        "end_line": 881,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.MakeOutputWithRtn#883",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.MakeOutputWithRtn(ChewingOutput *pgo, ChewingData *pgdata, int keystrokeRtn)",
        "snippet": "int MakeOutputWithRtn(ChewingOutput *pgo, ChewingData *pgdata, int keystrokeRtn)\n{\n    pgo->keystrokeRtn = keystrokeRtn;\n    return MakeOutput(pgo, pgdata);\n}",
        "begin_line": 883,
        "end_line": 887,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.MakePreferInterval#773",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.MakePreferInterval(ChewingData *pgdata)",
        "snippet": "static void MakePreferInterval(ChewingData *pgdata)\n{\n    int i, j, set_no;\n    int belong_set[MAX_PHONE_SEQ_LEN + 1];\n    int parent[MAX_PHONE_SEQ_LEN + 1];\n\n    memset(belong_set, 0, sizeof(int) * (MAX_PHONE_SEQ_LEN + 1));\n    memset(parent, 0, sizeof(int) * (MAX_PHONE_SEQ_LEN + 1));\n\n    /* for each interval */\n    for (i = 0; i < pgdata->phrOut.nDispInterval; i++) {\n        for (j = pgdata->phrOut.dispInterval[i].from; j < pgdata->phrOut.dispInterval[i].to; j++) {\n            belong_set[j] = i + 1;\n        }\n    }\n    set_no = i + 1;\n    for (i = 0; i < pgdata->nPhoneSeq; i++)\n        if (belong_set[i] == 0)\n            belong_set[i] = set_no++;\n\n    /* for each connect point */\n    for (i = 1; i < pgdata->nPhoneSeq; i++) {\n        if (pgdata->bUserArrCnnct[i]) {\n            Union(belong_set[i - 1], belong_set[i], parent);\n        }\n    }\n\n    /* generate new intervals */\n    pgdata->nPrefer = 0;\n    i = 0;\n    while (i < pgdata->nPhoneSeq) {\n        for (j = i + 1; j < pgdata->nPhoneSeq; j++)\n            if (!SameSet(belong_set[i], belong_set[j], parent))\n                break;\n\n        pgdata->preferInterval[pgdata->nPrefer].from = i;\n        pgdata->preferInterval[pgdata->nPrefer].to = j;\n        pgdata->nPrefer++;\n        i = j;\n    }\n}",
        "begin_line": 773,
        "end_line": 813,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.OpenSymbolChoice#1203",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.OpenSymbolChoice(ChewingData *pgdata)",
        "snippet": "int OpenSymbolChoice(ChewingData *pgdata)\n{\n    int i, symbol_buf_len = ARRAY_SIZE(symbol_buf);\n    const char *const *pBuf;\n    ChoiceInfo *pci = &(pgdata->choiceInfo);\n\n    pci->oldChiSymbolCursor = pgdata->chiSymbolCursor;\n\n    /* see if there is some word in the cursor position */\n    if (pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen)\n        pgdata->chiSymbolCursor--;\n    if (pgdata->symbolKeyBuf[pgdata->chiSymbolCursor] == NO_SYM_KEY) {\n        pgdata->bSelect = 1;\n        HaninSymbolInput(pgdata);\n        return 0;\n    }\n    for (i = 0; i < symbol_buf_len; i++) {\n        if (symbol_buf[i][0][0] == pgdata->symbolKeyBuf[pgdata->chiSymbolCursor]) {\n            pBuf = symbol_buf[i];\n            break;\n        }\n    }\n    if (i == symbol_buf_len) {\n        ChoiceEndChoice(pgdata);\n        return 0;\n    }\n    pci->nTotalChoice = 0;\n    for (i = 1; pBuf[i]; i++) {\n        ueStrNCpy(pci->totalChoiceStr[pci->nTotalChoice], pBuf[i], ueStrLen(pBuf[i]), 1);\n        pci->nTotalChoice++;\n    }\n\n    pci->nChoicePerPage = pgdata->config.candPerPage;\n    assert(pci->nTotalChoice > 0);\n    pci->nPage = CEIL_DIV(pci->nTotalChoice, pci->nChoicePerPage);\n    pci->pageNo = 0;\n    pci->isSymbol = SYMBOL_CHOICE_UPDATE;\n\n    pgdata->bSelect = 1;\n    pgdata->availInfo.nAvail = 1;\n    pgdata->availInfo.currentAvail = 0;\n    pgdata->availInfo.avail[0].id = NULL;\n    pgdata->availInfo.avail[0].len = 1;\n    return 0;\n}",
        "begin_line": 1203,
        "end_line": 1247,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.PhoneSeqCursor#935",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.PhoneSeqCursor(ChewingData *pgdata)",
        "snippet": "int PhoneSeqCursor(ChewingData *pgdata)\n{\n    int cursor = pgdata->chiSymbolCursor - CountSymbols(pgdata, pgdata->chiSymbolCursor);\n\n    return cursor > 0 ? cursor : 0;\n}",
        "begin_line": 935,
        "end_line": 940,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ReleaseChiSymbolBuf#510",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ReleaseChiSymbolBuf(ChewingData *pgdata, ChewingOutput *pgo)",
        "snippet": "int ReleaseChiSymbolBuf(ChewingData *pgdata, ChewingOutput *pgo)\n{\n    int throwEnd;\n\n    throwEnd = CountReleaseNum(pgdata);\n\n    /*\n     * When current buffer size exceeds maxChiSymbolLen,\n     * we need to throw some of the characters at the head of the buffer and\n     * commit them.\n     */\n    if (throwEnd) {\n        /*\n         * count how many chinese words in \"chiSymbolBuf[ 0 .. (throwEnd - 1)]\"\n         * And release from \"chiSymbolBuf\" && \"phoneSeq\"\n         */\n        WriteChiSymbolToCommitBuf(pgdata, pgo, throwEnd);\n        KillFromLeft(pgdata, throwEnd);\n    }\n    return throwEnd;\n}",
        "begin_line": 510,
        "end_line": 530,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.RemoveSelectElement#947",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.RemoveSelectElement(int i, ChewingData *pgdata)",
        "snippet": "void RemoveSelectElement(int i, ChewingData *pgdata)\n{\n    if (--pgdata->nSelect == i)\n        return;\n    pgdata->selectInterval[i] = pgdata->selectInterval[pgdata->nSelect];\n    strcpy(pgdata->selectStr[i], pgdata->selectStr[pgdata->nSelect]);\n}",
        "begin_line": 947,
        "end_line": 953,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.SameSet#761",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.SameSet(int set1, int set2, int parent[])",
        "snippet": "static int SameSet(int set1, int set2, int parent[])\n{\n    while (parent[set1] != 0) {\n        set1 = parent[set1];\n    }\n    while (parent[set2] != 0) {\n        set2 = parent[set2];\n    }\n    return (set1 == set2);\n}",
        "begin_line": 761,
        "end_line": 770,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ShiftInterval#816",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ShiftInterval(ChewingOutput *pgo, ChewingData *pgdata)",
        "snippet": "static void ShiftInterval(ChewingOutput *pgo, ChewingData *pgdata)\n{\n    int i, arrPos[MAX_PHONE_SEQ_LEN], k = 0, from, len;\n\n    for (i = 0; i < pgdata->chiSymbolBufLen; i++) {\n        if (ChewingIsChiAt(i, pgdata)) {\n            arrPos[k++] = i;\n        }\n    }\n    arrPos[k] = i;\n\n    pgo->nDispInterval = pgdata->nPrefer;\n    for (i = 0; i < pgdata->nPrefer; i++) {\n        from = pgdata->preferInterval[i].from;\n        len = pgdata->preferInterval[i].to - from;\n        pgo->dispInterval[i].from = arrPos[from];\n        pgo->dispInterval[i].to = arrPos[from] + len;\n    }\n}",
        "begin_line": 816,
        "end_line": 834,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ShowChewingData#688",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ShowChewingData(ChewingData *pgdata)",
        "snippet": "static void ShowChewingData(ChewingData *pgdata)\n{\n    int i;\n\n    DEBUG_OUT(\"nPhoneSeq : %d\\n\" \"phoneSeq  : \", pgdata->nPhoneSeq);\n    for (i = 0; i < pgdata->nPhoneSeq; i++)\n        DEBUG_OUT(\"%hu \", pgdata->phoneSeq[i]);\n    DEBUG_OUT(\"[cursor : %d]\\n\"\n              \"nSelect : %d\\n\" \"selectStr       selectInterval\\n\", PhoneSeqCursor(pgdata), pgdata->nSelect);\n    for (i = 0; i < pgdata->nSelect; i++) {\n        DEBUG_OUT(\"  %14s%4d%4d\\n\", pgdata->selectStr[i], pgdata->selectInterval[i].from, pgdata->selectInterval[i].to);\n    }\n\n    DEBUG_OUT(\"bUserArrCnnct : \");\n    for (i = 0; i <= pgdata->nPhoneSeq; i++)\n        DEBUG_OUT(\"%d \", pgdata->bUserArrCnnct[i]);\n    DEBUG_OUT(\"\\n\");\n\n    DEBUG_OUT(\"bUserArrBrkpt : \");\n    for (i = 0; i <= pgdata->nPhoneSeq; i++)\n        DEBUG_OUT(\"%d \", pgdata->bUserArrBrkpt[i]);\n    DEBUG_OUT(\"\\n\");\n\n    DEBUG_OUT(\"bArrBrkpt     : \");\n    for (i = 0; i <= pgdata->nPhoneSeq; i++)\n        DEBUG_OUT(\"%d \", pgdata->bArrBrkpt[i]);\n    DEBUG_OUT(\"\\n\");\n\n    DEBUG_OUT(\"bChiSym : %d , bSelect : %d\\n\", pgdata->bChiSym, pgdata->bSelect);\n}",
        "begin_line": 688,
        "end_line": 717,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.SpecialSymbolInput#190",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.SpecialSymbolInput(int key, ChewingData *pgdata)",
        "snippet": "int SpecialSymbolInput(int key, ChewingData *pgdata)\n{\n    static const char keybuf[] = {\n        '[', ']', '{', '}', '\\'', '<', ':', '\\\"', '>',\n        '~', '!', '@', '#', '$', '%', '^', '&', '*',\n        '(', ')', '_', '+', '=', '\\\\', '|', '?',\n        ',', '.', ';'\n    };\n\n    static const char *const chibuf[] = {\n        \"\\xE3\\x80\\x8C\", \"\\xE3\\x80\\x8D\", \"\\xE3\\x80\\x8E\", \"\\xE3\\x80\\x8F\",\n        /* \"\u300c\", \"\u300d\", \"\u300e\", \"\u300f\" */\n        \"\\xE3\\x80\\x81\", \"\\xEF\\xBC\\x8C\", \"\\xEF\\xBC\\x9A\", \"\\xEF\\xBC\\x9B\",\n        /* \"\u3001\", \"\uff0c\", \"\uff1a\", \"\uff1b\" */\n        \"\\xE3\\x80\\x82\", \"\\xEF\\xBD\\x9E\", \"\\xEF\\xBC\\x81\", \"\\xEF\\xBC\\xA0\",\n        /* \"\u3002\", \"\uff5e\", \"\uff01\", \"\uff20\" */\n        \"\\xEF\\xBC\\x83\", \"\\xEF\\xBC\\x84\", \"\\xEF\\xBC\\x85\", \"\\xEF\\xB8\\xBF\",\n        /* \"\uff03\", \"\uff04\", \"\uff05\", \"\ufe3f\" */\n        \"\\xEF\\xBC\\x86\", \"\\xEF\\xBC\\x8A\", \"\\xEF\\xBC\\x88\", \"\\xEF\\xBC\\x89\",\n        /* \"\uff06\", \"\uff0a\", \"\uff08\", \"\uff09\" */\n        \"\\xE2\\x80\\x94\", \"\\xEF\\xBC\\x8B\", \"\\xEF\\xBC\\x9D\", \"\\xEF\\xBC\\xBC\",\n        /* \"\u2014\", \"\uff0b\", \"\uff1d\", \"\uff3c\" */\n        \"\\xEF\\xBD\\x9C\", \"\\xEF\\xBC\\x9F\", \"\\xEF\\xBC\\x8C\", \"\\xE3\\x80\\x82\",\n        /* \"\uff5c\", \"\uff1f\", \"\uff0c\", \"\u3002\" */\n        \"\\xEF\\xBC\\x9B\"\n            /* \"\uff1b\" */\n    };\n    STATIC_ASSERT(ARRAY_SIZE(keybuf) == ARRAY_SIZE(chibuf));\n\n    return InternalSpecialSymbol(key, pgdata, ARRAY_SIZE(keybuf), keybuf, chibuf);\n}\n\nint FullShapeSymbolInput(int key, ChewingData *pgdata)\n{",
        "begin_line": 190,
        "end_line": 220,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.SymbolChoice#307",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.SymbolChoice(ChewingData *pgdata, int sel_i)",
        "snippet": "int SymbolChoice(ChewingData *pgdata, int sel_i)\n{\n    int kbtype;\n    int i;\n    int symbol_type;\n    int key;\n\n    if (!pgdata->static_data.symbol_table && pgdata->choiceInfo.isSymbol != SYMBOL_CHOICE_UPDATE)\n        return BOPOMOFO_ABSORB;\n\n    if (pgdata->choiceInfo.isSymbol == SYMBOL_CATEGORY_CHOICE && 0 == pgdata->static_data.symbol_table[sel_i]->nSymbols)\n        symbol_type = SYMBOL_CHOICE_INSERT;\n    else\n        symbol_type = pgdata->choiceInfo.isSymbol;\n\n    /* level one, symbol category */\n    if (symbol_type == SYMBOL_CATEGORY_CHOICE) {\n        ChoiceInfo *pci = &pgdata->choiceInfo;\n        AvailInfo *pai = &pgdata->availInfo;\n\n        /* Display all symbols in this category */\n        pci->nTotalChoice = 0;\n        for (i = 0; i < pgdata->static_data.symbol_table[sel_i]->nSymbols; i++) {\n            ueStrNCpy(pci->totalChoiceStr[pci->nTotalChoice],\n                      pgdata->static_data.symbol_table[sel_i]->symbols[i], 1, 1);\n            pci->nTotalChoice++;\n        }\n        pai->avail[0].len = 1;\n        pai->avail[0].id = NULL;\n        pai->nAvail = 1;\n        pai->currentAvail = 0;\n        pci->nChoicePerPage = pgdata->config.candPerPage;\n        assert(pci->nTotalChoice > 0);\n        pci->nPage = CEIL_DIV(pci->nTotalChoice, pci->nChoicePerPage);\n        pci->pageNo = 0;\n        pci->isSymbol = SYMBOL_CHOICE_INSERT;\n    } else {                    /* level 2 symbol or OpenSymbolChoice */\n        /* TODO: FIXME, this part is buggy! */\n        PreeditBuf *buf = &pgdata->preeditBuf[pgdata->chiSymbolCursor];\n\n        if (symbol_type == SYMBOL_CHOICE_INSERT) {\n            assert(pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen);\n\n            if (pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen ||\n                    pgdata->symbolKeyBuf[pgdata->chiSymbolCursor] != NO_SYM_KEY) {\n                memmove(&pgdata->preeditBuf[pgdata->chiSymbolCursor + 1],\n                        &pgdata->preeditBuf[pgdata->chiSymbolCursor],\n                        sizeof(pgdata->preeditBuf[0]) * (pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));\n            } else {\n                symbol_type = SYMBOL_CHOICE_UPDATE;\n            }\n        }\n        strncpy(buf->char_, pgdata->choiceInfo.totalChoiceStr[sel_i], sizeof(buf->char_) - 1);\n        buf->category = CHEWING_SYMBOL;\n\n        /* This is very strange */\n        key = FindSymbolKey(pgdata->choiceInfo.totalChoiceStr[sel_i]);\n        pgdata->symbolKeyBuf[pgdata->chiSymbolCursor] = key ? key : NO_SYM_KEY;\n\n        pgdata->bUserArrCnnct[PhoneSeqCursor(pgdata)] = 0;\n        ChoiceEndChoice(pgdata);\n        /* Don't forget the kbtype */\n        kbtype = pgdata->bopomofoData.kbtype;\n        memset(&(pgdata->bopomofoData), 0, sizeof(BopomofoData));\n        pgdata->bopomofoData.kbtype = kbtype;\n\n        if (symbol_type == SYMBOL_CHOICE_INSERT) {\n            pgdata->chiSymbolBufLen++;\n            pgdata->chiSymbolCursor++;\n        }\n\n        pgdata->choiceInfo.isSymbol = WORD_CHOICE;\n    }\n    return BOPOMOFO_ABSORB;\n}",
        "begin_line": 307,
        "end_line": 381,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.SymbolInput#383",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.SymbolInput(int key, ChewingData *pgdata)",
        "snippet": "int SymbolInput(int key, ChewingData *pgdata)\n{\n    if (isprint((char) key) &&  /* other character was ignored */\n        (pgdata->chiSymbolBufLen < MAX_PHONE_SEQ_LEN)) {        /* protect the buffer */\n        PreeditBuf *buf = &pgdata->preeditBuf[pgdata->chiSymbolCursor];\n\n        assert(pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen);\n\n        memmove(&pgdata->preeditBuf[pgdata->chiSymbolCursor + 1],\n                &pgdata->preeditBuf[pgdata->chiSymbolCursor],\n                sizeof(pgdata->preeditBuf[0]) * (pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));\n\n        buf->char_[0] = (char) key;\n        buf->char_[1] = 0;\n        buf->category = CHEWING_SYMBOL;\n\n        /* Save Symbol Key */\n        memmove(&(pgdata->symbolKeyBuf[pgdata->chiSymbolCursor + 1]),\n                &(pgdata->symbolKeyBuf[pgdata->chiSymbolCursor]),\n                sizeof(pgdata->symbolKeyBuf[0]) * (pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));\n        pgdata->symbolKeyBuf[pgdata->chiSymbolCursor] = toupper(key);\n\n        pgdata->bUserArrCnnct[PhoneSeqCursor(pgdata)] = 0;\n        pgdata->chiSymbolCursor++;\n        pgdata->chiSymbolBufLen++;\n        return SYMBOL_KEY_OK;\n    }\n    return SYMBOL_KEY_ERROR;\n}",
        "begin_line": 383,
        "end_line": 411,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.TerminateEasySymbolTable#1434",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.TerminateEasySymbolTable(ChewingData *pgdata)",
        "snippet": "void TerminateEasySymbolTable(ChewingData *pgdata)\n{\n    unsigned int i;\n\n    for (i = 0; i < EASY_SYMBOL_KEY_TAB_LEN; ++i) {\n        if (NULL != pgdata->static_data.g_easy_symbol_value[i]) {\n            free(pgdata->static_data.g_easy_symbol_value[i]);\n            pgdata->static_data.g_easy_symbol_value[i] = NULL;\n        }\n        pgdata->static_data.g_easy_symbol_num[i] = 0;\n    }\n}",
        "begin_line": 1434,
        "end_line": 1445,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.TerminateSymbolTable#1354",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.TerminateSymbolTable(ChewingData *pgdata)",
        "snippet": "void TerminateSymbolTable(ChewingData *pgdata)\n{\n    unsigned int i;\n\n    if (pgdata->static_data.symbol_table) {\n        for (i = 0; i < pgdata->static_data.n_symbol_entry; ++i)\n            free(pgdata->static_data.symbol_table[i]);\n        free(pgdata->static_data.symbol_table);\n        pgdata->static_data.n_symbol_entry = 0;\n        pgdata->static_data.symbol_table = NULL;\n    }\n}",
        "begin_line": 1354,
        "end_line": 1365,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.Union#755",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.Union(int set1, int set2, int parent[])",
        "snippet": "static void Union(int set1, int set2, int parent[])\n{\n    if (set1 != set2)\n        parent[max(set1, set2)] = min(set1, set2);\n}",
        "begin_line": 755,
        "end_line": 759,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.WriteChiSymbolToCommitBuf#432",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.WriteChiSymbolToCommitBuf(ChewingData *pgdata, ChewingOutput *pgo, int len)",
        "snippet": "void WriteChiSymbolToCommitBuf(ChewingData *pgdata, ChewingOutput *pgo, int len)\n{\n    int i;\n    char *pos;\n\n    assert(pgdata);\n    assert(pgo);\n\n    pgo->commitBufLen = len;\n\n    pos = pgo->commitBuf;\n    for (i = 0; i < pgo->commitBufLen; ++i) {\n        assert(pos + MAX_UTF8_SIZE + 1 < pgo->commitBuf + sizeof(pgo->commitBuf));\n        strcpy(pos, pgdata->preeditBuf[i].char_);\n        pos += strlen(pgdata->preeditBuf[i].char_);\n    }\n    *pos = 0;\n}",
        "begin_line": 432,
        "end_line": 449,
        "is_bug": false
    },
    {
        "name": "src.chewingutil._Inner_InternalSpecialSymbol#141",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil._Inner_InternalSpecialSymbol(int key, ChewingData *pgdata, char symkey, const char *const chibuf)",
        "snippet": "static int _Inner_InternalSpecialSymbol(int key, ChewingData *pgdata, char symkey, const char *const chibuf)\n{\n    int kbtype;\n    PreeditBuf *buf;\n\n    if (key == symkey && NULL != chibuf) {\n        assert(pgdata->chiSymbolBufLen >= pgdata->chiSymbolCursor);\n\n        buf = &pgdata->preeditBuf[pgdata->chiSymbolCursor];\n\n        memmove(&pgdata->preeditBuf[pgdata->chiSymbolCursor + 1],\n                &pgdata->preeditBuf[pgdata->chiSymbolCursor],\n                sizeof(pgdata->preeditBuf[0]) * (pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));\n\n        strncpy(buf->char_, chibuf, sizeof(buf->char_) - 1);\n        buf->category = CHEWING_SYMBOL;\n\n        /* Save Symbol Key */\n        memmove(&(pgdata->symbolKeyBuf[pgdata->chiSymbolCursor + 1]),\n                &(pgdata->symbolKeyBuf[pgdata->chiSymbolCursor]),\n                sizeof(pgdata->symbolKeyBuf[0]) * (pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));\n        pgdata->symbolKeyBuf[pgdata->chiSymbolCursor] = key;\n        pgdata->bUserArrCnnct[PhoneSeqCursor(pgdata)] = 0;\n        pgdata->chiSymbolCursor++;\n        pgdata->chiSymbolBufLen++;\n        /* reset Bopomofo data */\n        /* Don't forget the kbtype */\n        kbtype = pgdata->bopomofoData.kbtype;\n        memset(&(pgdata->bopomofoData), 0, sizeof(BopomofoData));\n        pgdata->bopomofoData.kbtype = kbtype;\n        return 1;\n    }\n    return 0;\n}",
        "begin_line": 141,
        "end_line": 174,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.copyStringFromPreeditBuf#1447",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.copyStringFromPreeditBuf(ChewingData *pgdata, int pos, int len, char *output, int output_len)",
        "snippet": "void copyStringFromPreeditBuf(ChewingData *pgdata, int pos, int len, char *output, int output_len)\n{\n    int i;\n    int x;\n\n    assert(pgdata);\n    assert(0 <= pos && (size_t) (pos + len) < ARRAY_SIZE(pgdata->preeditBuf));\n    assert(output);\n    assert(output_len);\n\n    LOG_VERBOSE(\"Copy pos %d, len %d from preeditBuf\", pos, len);\n\n    for (i = pos; i < pos + len; ++i) {\n        x = strlen(pgdata->preeditBuf[i].char_);\n        if (x >= output_len)    // overflow\n            return;\n        memcpy(output, pgdata->preeditBuf[i].char_, x);\n        output += x;\n        output_len -= x;\n    }\n    output[0] = 0;\n}",
        "begin_line": 1447,
        "end_line": 1468,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.toPreeditBufIndex#1474",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.toPreeditBufIndex(ChewingData *pgdata, int pos)",
        "snippet": "int toPreeditBufIndex(ChewingData *pgdata, int pos)\n{\n    int word_count;\n    int i;\n\n    assert(pgdata);\n    assert(0 <= pos && pos <= MAX_CHI_SYMBOL_LEN);\n\n    for (i = 0, word_count = 0; i < MAX_CHI_SYMBOL_LEN; ++i) {\n        if (ChewingIsChiAt(i, pgdata))\n            ++word_count;\n\n        /*\n         * pos = 0 means finding the first word, so we need to add one\n         * here.\n         */\n        if (word_count == pos + 1)\n            break;\n    }\n\n    LOG_VERBOSE(\"translate phoneSeq index %d to preeditBuf index %d\", pos, i);\n\n    return i;\n}",
        "begin_line": 1474,
        "end_line": 1497,
        "is_bug": false
    },
    {
        "name": "src.choice.ChangeCurrentAvailInfo#361",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChangeCurrentAvailInfo(ChewingData *pgdata, int current)",
        "snippet": "static void ChangeCurrentAvailInfo(ChewingData *pgdata, int current)\n{\n    assert(pgdata);\n\n    if (pgdata->config.bPhraseChoiceRearward) {\n        pgdata->chiSymbolCursor = pgdata->choiceInfo.oldChiSymbolCursor - pgdata->availInfo.avail[current].len + 1;\n\n        /*\n         * When oldChiSymbolCursor == chiSymbolBufLen, the old cursor is at the\n         * end of buffer. This mean the end of phrase is in (oldChiSymbolCursor\n         * - 1) instead of oldChiSymbolCursor. In this case, we need to adjust\n         * chiSymbolCursor.\n         */\n        assert(pgdata->choiceInfo.oldChiSymbolCursor <= pgdata->chiSymbolBufLen);\n        if (pgdata->choiceInfo.oldChiSymbolCursor == pgdata->chiSymbolBufLen) {\n            --pgdata->chiSymbolCursor;\n        }\n    }\n\n    pgdata->availInfo.currentAvail = current;\n}",
        "begin_line": 361,
        "end_line": 381,
        "is_bug": false
    },
    {
        "name": "src.choice.ChangeSelectIntervalAndBreakpoint#33",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChangeSelectIntervalAndBreakpoint(ChewingData *pgdata, int from, int to, const char *str)",
        "snippet": "static void ChangeSelectIntervalAndBreakpoint(ChewingData *pgdata, int from, int to, const char *str)\n{\n    int i;\n    int user_alloc;\n\n    IntervalType inte;\n\n    inte.from = from;\n    inte.to = to;\n    for (i = 0; i < pgdata->nSelect; i++) {\n        if (IsIntersect(inte, pgdata->selectInterval[i])) {\n            RemoveSelectElement(i, pgdata);\n            i--;\n        }\n    }\n\n    pgdata->selectInterval[pgdata->nSelect].from = from;\n    pgdata->selectInterval[pgdata->nSelect].to = to;\n\n    /* No available selection */\n    if ((user_alloc = (to - from)) == 0)\n        return;\n\n    ueStrNCpy(pgdata->selectStr[pgdata->nSelect], str, user_alloc, 1);\n    pgdata->nSelect++;\n\n    if (user_alloc > 1) {\n        memset(&pgdata->bUserArrBrkpt[from + 1], 0, sizeof(int) * (user_alloc - 1));\n        memset(&pgdata->bUserArrCnnct[from + 1], 0, sizeof(int) * (user_alloc - 1));\n    }\n}",
        "begin_line": 33,
        "end_line": 63,
        "is_bug": false
    },
    {
        "name": "src.choice.ChangeUserData#483",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChangeUserData(ChewingData *pgdata, int selectNo)",
        "snippet": "static void ChangeUserData(ChewingData *pgdata, int selectNo)\n{\n    uint16_t userPhoneSeq[MAX_PHONE_SEQ_LEN];\n    int len;\n\n    len = ueStrLen(pgdata->choiceInfo.totalChoiceStr[selectNo]);\n    memcpy(userPhoneSeq, &(pgdata->phoneSeq[PhoneSeqCursor(pgdata)]), len * sizeof(uint16_t));\n    userPhoneSeq[len] = 0;\n    UserUpdatePhrase(pgdata, userPhoneSeq, pgdata->choiceInfo.totalChoiceStr[selectNo]);\n}",
        "begin_line": 483,
        "end_line": 492,
        "is_bug": false
    },
    {
        "name": "src.choice.ChoiceEndChoice#468",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChoiceEndChoice(ChewingData *pgdata)",
        "snippet": "int ChoiceEndChoice(ChewingData *pgdata)\n{\n    pgdata->bSelect = 0;\n    pgdata->choiceInfo.nTotalChoice = 0;\n    pgdata->choiceInfo.nPage = 0;\n\n    if (pgdata->choiceInfo.isSymbol != WORD_CHOICE || pgdata->choiceInfo.isSymbol != SYMBOL_CHOICE_INSERT) {\n        /* return to the old chiSymbolCursor position */\n        pgdata->chiSymbolCursor = pgdata->choiceInfo.oldChiSymbolCursor;\n        assert(pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen);\n    }\n    pgdata->choiceInfo.isSymbol = WORD_CHOICE;\n    return 0;\n}",
        "begin_line": 468,
        "end_line": 481,
        "is_bug": false
    },
    {
        "name": "src.choice.ChoiceFirstAvail#383",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChoiceFirstAvail(ChewingData *pgdata)",
        "snippet": "int ChoiceFirstAvail(ChewingData *pgdata)\n{\n    assert(pgdata);\n    assert(pgdata->bSelect);\n\n    if (pgdata->choiceInfo.isSymbol != WORD_CHOICE)\n        return 0;\n\n    ChangeCurrentAvailInfo(pgdata, pgdata->availInfo.nAvail - 1);\n\n    SetChoiceInfo(pgdata);\n\n    return 0;\n}",
        "begin_line": 383,
        "end_line": 396,
        "is_bug": false
    },
    {
        "name": "src.choice.ChoiceHasNextAvail#413",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChoiceHasNextAvail(ChewingData *pgdata)",
        "snippet": "int ChoiceHasNextAvail(ChewingData *pgdata)\n{\n    assert(pgdata);\n    assert(pgdata->bSelect);\n\n    if (pgdata->choiceInfo.isSymbol != WORD_CHOICE)\n        return 0;\n\n    return pgdata->availInfo.currentAvail > 0;\n}",
        "begin_line": 413,
        "end_line": 422,
        "is_bug": false
    },
    {
        "name": "src.choice.ChoiceInfoAppendChi#170",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChoiceInfoAppendChi(ChewingData *pgdata, ChoiceInfo *pci, uint16_t phone)",
        "snippet": "static void ChoiceInfoAppendChi(ChewingData *pgdata, ChoiceInfo *pci, uint16_t phone)\n{\n    Phrase tempWord;\n    int len;\n\n    if (GetCharFirst(pgdata, &tempWord, phone)) {\n        do {\n            len = ueBytesFromChar(tempWord.phrase[0]);\n            if (ChoiceTheSame(pci, tempWord.phrase, len))\n                continue;\n            assert(pci->nTotalChoice < MAX_CHOICE);\n            memcpy(pci->totalChoiceStr[pci->nTotalChoice], tempWord.phrase, len);\n            pci->totalChoiceStr[pci->nTotalChoice]\n                [len] = '\\0';\n            pci->nTotalChoice++;\n        } while (GetVocabNext(pgdata, &tempWord));\n    }\n}",
        "begin_line": 170,
        "end_line": 187,
        "is_bug": false
    },
    {
        "name": "src.choice.ChoiceInitAvail#330",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChoiceInitAvail(ChewingData *pgdata)",
        "snippet": "int ChoiceInitAvail(ChewingData *pgdata)\n{\n    int end, begin;\n\n    /* save old cursor position */\n    pgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;\n\n    /* see if there is some word in the cursor position */\n    if (pgdata->chiSymbolBufLen == pgdata->chiSymbolCursor) {\n        pgdata->chiSymbolCursor--;\n    }\n\n    end = PhoneSeqCursor(pgdata);\n\n    if (pgdata->config.bPhraseChoiceRearward) {\n        pgdata->chiSymbolCursor = SeekPhraseHead(pgdata) + CountSymbols(pgdata, pgdata->chiSymbolCursor);\n    }\n    begin = PhoneSeqCursor(pgdata);\n\n    pgdata->bSelect = 1;\n\n    SetAvailInfo(pgdata, begin, end);\n\n    if (!pgdata->availInfo.nAvail)\n        return ChoiceEndChoice(pgdata);\n\n    pgdata->availInfo.currentAvail = pgdata->availInfo.nAvail - 1;\n    SetChoiceInfo(pgdata);\n    return 0;\n}",
        "begin_line": 330,
        "end_line": 359,
        "is_bug": false
    },
    {
        "name": "src.choice.ChoiceNextAvail#452",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChoiceNextAvail(ChewingData *pgdata)",
        "snippet": "int ChoiceNextAvail(ChewingData *pgdata)\n{\n    assert(pgdata);\n    assert(pgdata->bSelect);\n\n    if (!ChoiceHasNextAvail(pgdata)) {\n        return -1;\n    }\n\n    ChangeCurrentAvailInfo(pgdata, pgdata->availInfo.currentAvail - 1);\n\n    SetChoiceInfo(pgdata);\n\n    return 0;\n}",
        "begin_line": 452,
        "end_line": 466,
        "is_bug": false
    },
    {
        "name": "src.choice.ChoiceSelect#495",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChoiceSelect(ChewingData *pgdata, int selectNo)",
        "snippet": "int ChoiceSelect(ChewingData *pgdata, int selectNo)\n{\n    ChoiceInfo *pci = &(pgdata->choiceInfo);\n    AvailInfo *pai = &(pgdata->availInfo);\n\n    ChangeUserData(pgdata, selectNo);\n    ChangeSelectIntervalAndBreakpoint(pgdata,\n                                      PhoneSeqCursor(pgdata),\n                                      PhoneSeqCursor(pgdata) + pai->avail[pai->currentAvail].len,\n                                      pci->totalChoiceStr[selectNo]);\n    ChoiceEndChoice(pgdata);\n    return 0;\n}",
        "begin_line": 495,
        "end_line": 507,
        "is_bug": false
    },
    {
        "name": "src.choice.ChoiceTheSame#160",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChoiceTheSame(ChoiceInfo *pci, const char *str, int len)",
        "snippet": "static int ChoiceTheSame(ChoiceInfo *pci, const char *str, int len)\n{\n    int i;\n\n    for (i = 0; i < pci->nTotalChoice; i++)\n        if (!memcmp(pci->totalChoiceStr[i], str, len))\n            return 1;\n    return 0;\n}",
        "begin_line": 160,
        "end_line": 168,
        "is_bug": false
    },
    {
        "name": "src.choice.SeekPhraseHead#316",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.SeekPhraseHead(ChewingData *pgdata)",
        "snippet": "static int SeekPhraseHead(ChewingData *pgdata)\n{\n    int i;\n    int phoneSeq = PhoneSeqCursor(pgdata);\n\n    for (i = pgdata->nPrefer - 1; i >= 0; i--) {\n        if (pgdata->preferInterval[i].from > phoneSeq || pgdata->preferInterval[i].to < phoneSeq)\n            continue;\n        return pgdata->preferInterval[i].from;\n    }\n    return 0;\n}",
        "begin_line": 316,
        "end_line": 327,
        "is_bug": false
    },
    {
        "name": "src.choice.SetAvailInfo#66",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.SetAvailInfo(ChewingData *pgdata, int begin, int end)",
        "snippet": "static void SetAvailInfo(ChewingData *pgdata, int begin, int end)\n{\n    AvailInfo *pai = &(pgdata->availInfo);\n    const uint16_t *phoneSeq = pgdata->phoneSeq;\n    int nPhoneSeq = pgdata->nPhoneSeq;\n    const int *bSymbolArrBrkpt = pgdata->bSymbolArrBrkpt;\n    int symbolArrBrkpt[ARRAY_SIZE(pgdata->bSymbolArrBrkpt)] = { 0 };\n\n    const TreeType *tree_pos;\n    int diff;\n    uint16_t userPhoneSeq[MAX_PHONE_SEQ_LEN];\n\n    int i, head, head_tmp;\n    int tail, tail_tmp;\n    int pos;\n\n    head = tail = 0;\n\n    pai->nAvail = 0;\n\n    /*\n     * XXX: The phoneSeq, nPhoneSeq skip any symbol in preedit buffer,\n     * while bSymbolArrBrkpt, does not skip any symbol in preedit\n     * buffer. So we need to do some translate here.\n     */\n    for (i = 0; i < pgdata->chiSymbolBufLen; ++i) {\n        if (bSymbolArrBrkpt[i]) {\n            /*\n             * XXX: If preedit buffer starts with symbol, the pos\n             * will become negative. In this case, we just ignore\n             * this symbol because it does not create any break\n             * point.\n             */\n            pos = i - CountSymbols(pgdata, i + 1);\n            if (pos >= 0)\n                symbolArrBrkpt[pos] = 1;\n        }\n    }\n\n    if (pgdata->config.bPhraseChoiceRearward) {\n        for (i = end; i >= begin; i--) {\n            if (symbolArrBrkpt[i])\n                break;\n            head = i;\n        }\n        head_tmp = end;\n    } else {\n        head_tmp = head = begin;\n    }\n\n    if (pgdata->config.bPhraseChoiceRearward) {\n        tail_tmp = tail = end;\n    } else {\n        for (i = begin; i < nPhoneSeq; i++) {\n            tail = i;\n            if (symbolArrBrkpt[i])\n                break;\n        }\n        tail_tmp = begin;\n    }\n\n    while (head <= head_tmp && tail_tmp <= tail) {\n        diff = tail_tmp - head_tmp;\n        tree_pos = TreeFindPhrase(pgdata, head_tmp, tail_tmp, phoneSeq);\n\n        if (tree_pos) {\n            /* save it! */\n            pai->avail[pai->nAvail].len = diff + 1;\n            pai->avail[pai->nAvail].id = tree_pos;\n            pai->nAvail++;\n        } else {\n            memcpy(userPhoneSeq, &phoneSeq[head_tmp], sizeof(uint16_t) * (diff + 1));\n            userPhoneSeq[diff + 1] = 0;\n            if (UserGetPhraseFirst(pgdata, userPhoneSeq)) {\n                /* save it! */\n                pai->avail[pai->nAvail].len = diff + 1;\n                pai->avail[pai->nAvail].id = NULL;\n                pai->nAvail++;\n            } else {\n                pai->avail[pai->nAvail].len = 0;\n                pai->avail[pai->nAvail].id = NULL;\n            }\n            UserGetPhraseEnd(pgdata, userPhoneSeq);\n        }\n\n        if (pgdata->config.bPhraseChoiceRearward) {\n            head_tmp--;\n        } else {\n            tail_tmp++;\n        }\n    }\n}",
        "begin_line": 66,
        "end_line": 157,
        "is_bug": false
    },
    {
        "name": "src.choice.SetChoiceInfo#195",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.SetChoiceInfo(ChewingData *pgdata)",
        "snippet": "static void SetChoiceInfo(ChewingData *pgdata)\n{\n    Phrase tempPhrase;\n    int len;\n    UserPhraseData *pUserPhraseData;\n    uint16_t userPhoneSeq[MAX_PHONE_SEQ_LEN];\n\n    ChoiceInfo *pci = &(pgdata->choiceInfo);\n    AvailInfo *pai = &(pgdata->availInfo);\n    uint16_t *phoneSeq = pgdata->phoneSeq;\n    uint16_t *phoneSeqAlt = pgdata->phoneSeqAlt;\n    int cursor = PhoneSeqCursor(pgdata);\n    int candPerPage = pgdata->config.candPerPage;\n\n    /* Clears previous candidates. */\n    memset(pci->totalChoiceStr, '\\0', MAX_CHOICE * MAX_PHRASE_LEN * MAX_UTF8_SIZE + 1);\n\n    pci->nTotalChoice = 0;\n    len = pai->avail[pai->currentAvail].len;\n    assert(len);\n\n    /* secondly, read tree phrase */\n    if (len == 1) {             /* single character */\n        ChoiceInfoAppendChi(pgdata, pci, phoneSeq[cursor]);\n\n        if (phoneSeq[cursor] != phoneSeqAlt[cursor]) {\n            ChoiceInfoAppendChi(pgdata, pci, phoneSeqAlt[cursor]);\n        }\n\n        if (pgdata->bopomofoData.kbtype == KB_HSU || pgdata->bopomofoData.kbtype == KB_DVORAK_HSU) {\n            switch (phoneSeq[cursor]) {\n            case 0x2800:       /* '\u3118' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x30); /* '\u311f' */\n                break;\n            case 0x80:         /* '\u3127' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x20); /* '\u311d' */\n                break;\n            case 0x2A00:       /* '\u3119' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1);  /* '\u02d9' */\n                break;\n            case 0xA00:        /* '\u3109' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x2);  /* '\u02ca' */\n                break;\n            case 0x800:        /* '\u3108' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x3);  /* '\u02c7' */\n                break;\n            case 0x18:         /* '\u311c' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1200);       /* '\u310d' */\n                break;\n            case 0x10:         /* '\u311b' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1600);       /* '\u310f' */\n                break;\n            case 0x1E00:       /* '\u3113' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1800);       /* '\u3110' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x4);  /* '\u02cb' */\n                break;\n            case 0x58:         /* '\u3124' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1400);       /* '\u310e' */\n                break;\n            case 0x68:         /* '\u3126' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1000);       /* '\u310c' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x60); /* '\u3125' */\n                break;\n            case 0x2200:       /* '\u3115' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1C00);       /* '\u3112' */\n                break;\n            case 0x2000:       /* '\u3114' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1A00);       /* '\u3111' */\n                break;\n            case 0x50:         /* '\u3123' */\n                ChoiceInfoAppendChi(pgdata, pci, 0xE00);        /* '\u310b' */\n                break;\n            case 0x48:         /* '\u3122' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x600);        /* '\u3107' */\n                break;\n            default:\n                break;\n            }\n        }\n    }\n    /* phrase */\n    else {\n        if (pai->avail[pai->currentAvail].id) {\n            GetPhraseFirst(pgdata, &tempPhrase, pai->avail[pai->currentAvail].id);\n            do {\n                if (ChoiceTheSame(pci, tempPhrase.phrase, len * ueBytesFromChar(tempPhrase.phrase[0]))) {\n                    continue;\n                }\n                ueStrNCpy(pci->totalChoiceStr[pci->nTotalChoice], tempPhrase.phrase, len, 1);\n                pci->nTotalChoice++;\n            } while (GetVocabNext(pgdata, &tempPhrase));\n        }\n\n        memcpy(userPhoneSeq, &phoneSeq[cursor], sizeof(uint16_t) * len);\n        userPhoneSeq[len] = 0;\n        pUserPhraseData = UserGetPhraseFirst(pgdata, userPhoneSeq);\n        if (pUserPhraseData) {\n            do {\n                /* check if the phrase is already in the choice list */\n                if (ChoiceTheSame(pci, pUserPhraseData->wordSeq, len * ueBytesFromChar(pUserPhraseData->wordSeq[0])))\n                    continue;\n                /* otherwise store it */\n                ueStrNCpy(pci->totalChoiceStr[pci->nTotalChoice], pUserPhraseData->wordSeq, len, 1);\n                pci->nTotalChoice++;\n            } while ((pUserPhraseData = UserGetPhraseNext(pgdata, userPhoneSeq)) != NULL);\n        }\n        UserGetPhraseEnd(pgdata, userPhoneSeq);\n\n    }\n\n    /* magic number */\n    pci->nChoicePerPage = candPerPage;\n    assert(pci->nTotalChoice > 0);\n    pci->nPage = CEIL_DIV(pci->nTotalChoice, pci->nChoicePerPage);\n    pci->pageNo = 0;\n    pci->isSymbol = WORD_CHOICE;\n}\n\n/*\n * Seek the start of the phrase (English characters",
        "begin_line": 195,
        "end_line": 311,
        "is_bug": false
    },
    {
        "name": "src.common.chewing-utf8-util.ueBytesFromChar#41",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "src.common.chewing-utf8-util",
        "signature": "src.common.chewing-utf8-util.ueBytesFromChar(unsigned char b)",
        "snippet": "int ueBytesFromChar(unsigned char b)\n{\n    return utf8len_tab[b];\n}",
        "begin_line": 41,
        "end_line": 44,
        "is_bug": false
    },
    {
        "name": "src.common.chewing-utf8-util.ueConstStrSeek#70",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "src.common.chewing-utf8-util",
        "signature": "src.common.chewing-utf8-util.ueConstStrSeek(const char *src, size_t n)",
        "snippet": "const char *ueConstStrSeek(const char *src, size_t n)\n{\n    size_t i = 0;\n    const char *iter = src;\n\n    for (i = 0; i < n; i++) {\n        iter += ueBytesFromChar(iter[0]);\n    }\n    return iter;\n}",
        "begin_line": 70,
        "end_line": 79,
        "is_bug": false
    },
    {
        "name": "src.common.chewing-utf8-util.ueStrLen#28",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "src.common.chewing-utf8-util",
        "signature": "src.common.chewing-utf8-util.ueStrLen(const char *str)",
        "snippet": "int ueStrLen(const char *str)\n{\n    int length = 0;\n    const char *strptr = str;\n\n    while (strptr[0] != '\\0') {\n        strptr += ueBytesFromChar(strptr[0]);\n        ++length;\n    }\n    return length;\n}",
        "begin_line": 28,
        "end_line": 38,
        "is_bug": false
    },
    {
        "name": "src.common.chewing-utf8-util.ueStrNBytes#47",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "src.common.chewing-utf8-util",
        "signature": "src.common.chewing-utf8-util.ueStrNBytes(const char *str, int n)",
        "snippet": "int ueStrNBytes(const char *str, int n)\n{\n    int i = 0, len = 0;\n    const char *iter = str;\n\n    for (i = 0; i < n; i++) {\n        len += ueBytesFromChar(iter[len]);\n    }\n    return len;\n}",
        "begin_line": 47,
        "end_line": 56,
        "is_bug": false
    },
    {
        "name": "src.common.chewing-utf8-util.ueStrNCpy#59",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "src.common.chewing-utf8-util",
        "signature": "src.common.chewing-utf8-util.ueStrNCpy(char dest[], const char *src, size_t n, int end)",
        "snippet": "int ueStrNCpy(char dest[], const char *src, size_t n, int end)\n{\n    int len = 0;\n\n    len = ueStrNBytes(src, n);\n    memcpy(dest, src, len);\n    if (end == STRNCPY_CLOSE)\n        dest[len] = '\\0';\n    return len;\n}",
        "begin_line": 59,
        "end_line": 68,
        "is_bug": false
    },
    {
        "name": "src.common.chewing-utf8-util.ueStrSeek#81",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "src.common.chewing-utf8-util",
        "signature": "src.common.chewing-utf8-util.ueStrSeek(char *src, size_t n)",
        "snippet": "char *ueStrSeek(char *src, size_t n)\n{\n    size_t i = 0;\n    char *iter = src;\n\n    for (i = 0; i < n; i++) {\n        iter += ueBytesFromChar(iter[0]);\n    }\n    return iter;\n}",
        "begin_line": 81,
        "end_line": 90,
        "is_bug": false
    },
    {
        "name": "src.common.key2pho.GetPhoneLen#212",
        "src_path": "src/common/key2pho.c",
        "class_name": "src.common.key2pho",
        "signature": "src.common.key2pho.GetPhoneLen(const uint16_t *phoneSeq)",
        "snippet": "size_t GetPhoneLen(const uint16_t *phoneSeq)\n{\n    size_t len = 0;\n\n    assert(phoneSeq);\n\n    while (phoneSeq[len])\n        ++len;\n    return len;\n}",
        "begin_line": 212,
        "end_line": 221,
        "is_bug": false
    },
    {
        "name": "src.common.key2pho.PhoneFromKey#125",
        "src_path": "src/common/key2pho.c",
        "class_name": "src.common.key2pho",
        "signature": "src.common.key2pho.PhoneFromKey(char *pho, const char *inputkey, KBTYPE kbtype, int searchTimes)",
        "snippet": "int PhoneFromKey(char *pho, const char *inputkey, KBTYPE kbtype, int searchTimes)\n{\n    int len;\n    int i;\n    int s;\n    const char *pTarget;\n\n    len = strlen(inputkey);\n\n    pho[0] = '\\0';\n    for (i = 0; i < len; i++) {\n        char *findptr = NULL;\n        int _index;\n\n        pTarget = key_str[kbtype];\n        for (s = 0; s < searchTimes; s++) {\n            findptr = strchr(pTarget, inputkey[i]);\n            if (!findptr) {\n                return 0;\n            }\n            pTarget = findptr + 1;\n        }\n        _index = findptr - key_str[kbtype];\n        ueStrNCpy(ueStrSeek(pho, i), ueConstStrSeek(ph_str, _index), 1, STRNCPY_NOT_CLOSE);\n    }\n    pho = ueStrSeek(pho, len);\n    pho[0] = '\\0';\n    return 1;\n}",
        "begin_line": 125,
        "end_line": 153,
        "is_bug": false
    },
    {
        "name": "src.common.key2pho.PhoneInxFromKey#178",
        "src_path": "src/common/key2pho.c",
        "class_name": "src.common.key2pho",
        "signature": "src.common.key2pho.PhoneInxFromKey(int key, int type, KBTYPE kbtype, int searchTimes)",
        "snippet": "int PhoneInxFromKey(int key, int type, KBTYPE kbtype, int searchTimes)\n{\n    char keyStr[2];\n    char rtStr[10];\n    char *p;\n\n    keyStr[0] = key;\n    keyStr[1] = '\\0';\n\n    if (!PhoneFromKey(rtStr, keyStr, kbtype, searchTimes))\n        return 0;\n\n    p = strstr(zhuin_tab[type], rtStr);\n    if (!p)\n        return 0;\n\n    return zhuin_tab_num[type] - ueStrLen(p);\n}",
        "begin_line": 178,
        "end_line": 195,
        "is_bug": false
    },
    {
        "name": "src.common.key2pho.UintFromPhone#93",
        "src_path": "src/common/key2pho.c",
        "class_name": "src.common.key2pho",
        "signature": "src.common.key2pho.UintFromPhone(const char *zhuin)",
        "snippet": "uint16_t UintFromPhone(const char *zhuin)\n{\n    const char *iter;\n    char *pos;\n    char buf[MAX_UTF8_SIZE + 1];\n    int len, result = 0;\n    int zhuin_index = 0;\n\n    iter = zhuin;\n\n    /* 0x20: space character */\n    while (*iter && *iter != 0x20) {\n        len = ueStrNCpy(buf, iter, 1, STRNCPY_CLOSE);\n\n        for (; zhuin_index < BOPOMOFO_SIZE; ++zhuin_index) {\n            pos = strstr(zhuin_tab[zhuin_index], buf);\n            if (pos) {\n                break;\n            }\n        }\n\n        if (zhuin_index >= BOPOMOFO_SIZE) {\n            return 0;\n        }\n\n        result |= (zhuin_tab_num[zhuin_index] - ueStrLen(pos)) << shift[zhuin_index];\n        ++zhuin_index;\n        iter += len;\n    }\n    return result;\n}",
        "begin_line": 93,
        "end_line": 123,
        "is_bug": false
    },
    {
        "name": "src.common.key2pho.UintFromPhoneInx#197",
        "src_path": "src/common/key2pho.c",
        "class_name": "src.common.key2pho",
        "signature": "src.common.key2pho.UintFromPhoneInx(const int ph_inx[])",
        "snippet": "uint16_t UintFromPhoneInx(const int ph_inx[])\n{\n    int i;\n    uint16_t result = 0;\n\n    for (i = 0; i < BOPOMOFO_SIZE; i++) {\n        if (ph_inx[i] < 0 || ph_inx[i] >= zhuin_tab_num[i])\n            return 0;\n\n        result |= ph_inx[i] << shift[i];\n    }\n\n    return result;\n}",
        "begin_line": 197,
        "end_line": 210,
        "is_bug": false
    },
    {
        "name": "src.compat.chewing_zuin_Check#23",
        "src_path": "src/compat.c",
        "class_name": "src.compat",
        "signature": "src.compat.chewing_zuin_Check(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_zuin_Check(const ChewingContext *ctx)\n{\n    return !chewing_bopomofo_Check(ctx);\n}",
        "begin_line": 23,
        "end_line": 26,
        "is_bug": false
    },
    {
        "name": "src.compat.chewing_zuin_String#28",
        "src_path": "src/compat.c",
        "class_name": "src.compat",
        "signature": "src.compat.chewing_zuin_String(const ChewingContext *ctx, int *bopomofo_count)",
        "snippet": "CHEWING_API char *chewing_zuin_String(const ChewingContext *ctx, int *bopomofo_count)\n{\n    char *s = strdup(chewing_bopomofo_String_static(ctx));\n\n    if (bopomofo_count) {\n        *bopomofo_count = ueStrLen(s);\n    }\n\n    return s;\n}",
        "begin_line": 28,
        "end_line": 37,
        "is_bug": false
    },
    {
        "name": "src.dict.GetCharFirst#72",
        "src_path": "src/dict.c",
        "class_name": "src.dict",
        "signature": "src.dict.GetCharFirst(ChewingData *pgdata, Phrase *wrd_ptr, uint16_t key)",
        "snippet": "int GetCharFirst(ChewingData *pgdata, Phrase *wrd_ptr, uint16_t key)\n{\n    /* &key serves as an array whose begin and end are both 0. */\n    const TreeType *pinx = TreeFindPhrase(pgdata, 0, 0, &key);\n\n    if (!pinx)\n        return 0;\n    TreeChildRange(pgdata, pinx);\n    GetVocabFromDict(pgdata, wrd_ptr);\n    return 1;\n}",
        "begin_line": 72,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "src.dict.GetPhraseFirst#89",
        "src_path": "src/dict.c",
        "class_name": "src.dict",
        "signature": "src.dict.GetPhraseFirst(ChewingData *pgdata, Phrase *phr_ptr, const TreeType *phrase_parent)",
        "snippet": "int GetPhraseFirst(ChewingData *pgdata, Phrase *phr_ptr, const TreeType *phrase_parent)\n{\n    assert(phrase_parent);\n\n    TreeChildRange(pgdata, phrase_parent);\n    GetVocabFromDict(pgdata, phr_ptr);\n    return 1;\n}",
        "begin_line": 89,
        "end_line": 96,
        "is_bug": false
    },
    {
        "name": "src.dict.GetVocabFromDict#65",
        "src_path": "src/dict.c",
        "class_name": "src.dict",
        "signature": "src.dict.GetVocabFromDict(ChewingData *pgdata, Phrase *phr_ptr)",
        "snippet": "static void GetVocabFromDict(ChewingData *pgdata, Phrase *phr_ptr)\n{\n    snprintf(phr_ptr->phrase, sizeof(phr_ptr->phrase), \"%s\", pgdata->static_data.dict + GetUint24(pgdata->static_data.tree_cur_pos->phrase.pos));\n    phr_ptr->freq = GetUint24(pgdata->static_data.tree_cur_pos->phrase.freq);\n    pgdata->static_data.tree_cur_pos++;\n}",
        "begin_line": 65,
        "end_line": 70,
        "is_bug": false
    },
    {
        "name": "src.dict.GetVocabNext#98",
        "src_path": "src/dict.c",
        "class_name": "src.dict",
        "signature": "src.dict.GetVocabNext(ChewingData *pgdata, Phrase *phr_ptr)",
        "snippet": "int GetVocabNext(ChewingData *pgdata, Phrase *phr_ptr)\n{\n    if (pgdata->static_data.tree_cur_pos >= pgdata->static_data.tree_end_pos\n        || GetUint16(pgdata->static_data.tree_cur_pos->key) != 0)\n        return 0;\n    GetVocabFromDict(pgdata, phr_ptr);\n    return 1;\n}",
        "begin_line": 98,
        "end_line": 105,
        "is_bug": false
    },
    {
        "name": "src.dict.InitDict#35",
        "src_path": "src/dict.c",
        "class_name": "src.dict",
        "signature": "src.dict.InitDict(ChewingData *pgdata, const char *prefix)",
        "snippet": "int InitDict(ChewingData *pgdata, const char *prefix)\n{\n    char filename[PATH_MAX];\n    size_t len;\n    size_t offset;\n    size_t file_size;\n    size_t csize;\n\n    len = snprintf(filename, sizeof(filename), \"%s\" PLAT_SEPARATOR \"%s\", prefix, DICT_FILE);\n    if (len + 1 > sizeof(filename))\n        return -1;\n\n    plat_mmap_set_invalid(&pgdata->static_data.dict_mmap);\n    file_size = plat_mmap_create(&pgdata->static_data.dict_mmap, filename, FLAG_ATTRIBUTE_READ);\n    if (file_size <= 0)\n        return -1;\n\n    offset = 0;\n    csize = file_size;\n    pgdata->static_data.dict = (const char *) plat_mmap_set_view(&pgdata->static_data.dict_mmap, &offset, &csize);\n    if (!pgdata->static_data.dict)\n        return -1;\n\n    return 0;\n}",
        "begin_line": 35,
        "end_line": 59,
        "is_bug": false
    },
    {
        "name": "src.dict.TerminateDict#30",
        "src_path": "src/dict.c",
        "class_name": "src.dict",
        "signature": "src.dict.TerminateDict(ChewingData *pgdata)",
        "snippet": "void TerminateDict(ChewingData *pgdata)\n{\n    plat_mmap_close(&pgdata->static_data.dict_mmap);\n}",
        "begin_line": 30,
        "end_line": 33,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_bopomofo_Check#160",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_bopomofo_Check(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_bopomofo_Check(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return ctx->output->bopomofoBuf[0] != 0;\n}",
        "begin_line": 160,
        "end_line": 172,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_bopomofo_String_static#146",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_bopomofo_String_static(const ChewingContext *ctx)",
        "snippet": "CHEWING_API const char *chewing_bopomofo_String_static(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return \"\";\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return ctx->output->bopomofoBuf;\n}",
        "begin_line": 146,
        "end_line": 158,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_buffer_Check#84",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_buffer_Check(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_buffer_Check(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return (ctx->output->chiSymbolBufLen != 0);\n}",
        "begin_line": 84,
        "end_line": 96,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_buffer_Len#98",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_buffer_Len(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_buffer_Len(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return ctx->output->chiSymbolBufLen;\n}",
        "begin_line": 98,
        "end_line": 110,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_buffer_String#112",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_buffer_String(const ChewingContext *ctx)",
        "snippet": "CHEWING_API char *chewing_buffer_String(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return strdup(\"\");\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return strdup(ctx->output->preeditBuf);\n}",
        "begin_line": 112,
        "end_line": 124,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_buffer_String_static#126",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_buffer_String_static(const ChewingContext *ctx)",
        "snippet": "CHEWING_API const char *chewing_buffer_String_static(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return \"\";\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return ctx->output->preeditBuf;\n}",
        "begin_line": 126,
        "end_line": 138,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_cand_CurrentPage#244",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_cand_CurrentPage(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_cand_CurrentPage(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return (ctx->output->pci ? ctx->output->pci->pageNo : -1);\n}",
        "begin_line": 244,
        "end_line": 256,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_cand_Enumerate#258",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_cand_Enumerate(ChewingContext *ctx)",
        "snippet": "CHEWING_API void chewing_cand_Enumerate(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    ctx->cand_no = ctx->output->pci->pageNo * ctx->output->pci->nChoicePerPage;\n}",
        "begin_line": 258,
        "end_line": 270,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_cand_String#306",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_cand_String(ChewingContext *ctx)",
        "snippet": "CHEWING_API char *chewing_cand_String(ChewingContext *ctx)\n{\n    return strdup(chewing_cand_String_static(ctx));\n}",
        "begin_line": 306,
        "end_line": 309,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_cand_String_static#286",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_cand_String_static(ChewingContext *ctx)",
        "snippet": "CHEWING_API const char *chewing_cand_String_static(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    const char *s = \"\";\n\n    if (!ctx) {\n        return s;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    if (chewing_cand_hasNext(ctx)) {\n        s = ctx->output->pci->totalChoiceStr[ctx->cand_no];\n        ctx->cand_no++;\n    }\n\n    return s;\n}",
        "begin_line": 286,
        "end_line": 304,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_cand_TotalChoice#230",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_cand_TotalChoice(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_cand_TotalChoice(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return (ctx->output->pci ? ctx->output->pci->nTotalChoice : 0);\n}",
        "begin_line": 230,
        "end_line": 242,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_cand_TotalPage#202",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_cand_TotalPage(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_cand_TotalPage(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return (ctx->output->pci ? ctx->output->pci->nPage : 0);\n}",
        "begin_line": 202,
        "end_line": 214,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_cand_hasNext#272",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_cand_hasNext(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_cand_hasNext(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return (ctx->cand_no < ctx->output->pci->nTotalChoice);\n}",
        "begin_line": 272,
        "end_line": 284,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_commit_Check#30",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_commit_Check(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_commit_Check(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return ! !(ctx->output->keystrokeRtn & KEYSTROKE_COMMIT);\n}",
        "begin_line": 30,
        "end_line": 42,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_commit_String#50",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_commit_String(const ChewingContext *ctx)",
        "snippet": "CHEWING_API char *chewing_commit_String(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return strdup(\"\");\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return strdup(ctx->output->commitBuf);\n}",
        "begin_line": 50,
        "end_line": 62,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_commit_String_static#70",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_commit_String_static(const ChewingContext *ctx)",
        "snippet": "CHEWING_API const char *chewing_commit_String_static(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return \"\";\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return ctx->output->commitBuf;\n}",
        "begin_line": 70,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_cursor_Current#174",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_cursor_Current(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_cursor_Current(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return (ctx->output->chiSymbolCursor);\n}",
        "begin_line": 174,
        "end_line": 186,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_interval_Enumerate#311",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_interval_Enumerate(ChewingContext *ctx)",
        "snippet": "CHEWING_API void chewing_interval_Enumerate(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    ctx->it_no = 0;\n}",
        "begin_line": 311,
        "end_line": 323,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_interval_Get#339",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_interval_Get(ChewingContext *ctx, IntervalType * it)",
        "snippet": "CHEWING_API void chewing_interval_Get(ChewingContext *ctx, IntervalType * it)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    if (chewing_interval_hasNext(ctx)) {\n        if (it) {\n            it->from = ctx->output->dispInterval[ctx->it_no].from;\n            it->to = ctx->output->dispInterval[ctx->it_no].to;\n        }\n        ctx->it_no++;\n    }\n}",
        "begin_line": 339,
        "end_line": 357,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_interval_hasNext#325",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_interval_hasNext(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_interval_hasNext(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return (ctx->it_no < ctx->output->nDispInterval);\n}",
        "begin_line": 325,
        "end_line": 337,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_keystroke_CheckAbsorb#429",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_keystroke_CheckAbsorb(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_keystroke_CheckAbsorb(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return ! !(ctx->output->keystrokeRtn & KEYSTROKE_ABSORB);\n}",
        "begin_line": 429,
        "end_line": 441,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_keystroke_CheckIgnore#415",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_keystroke_CheckIgnore(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_keystroke_CheckIgnore(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return ! !(ctx->output->keystrokeRtn & KEYSTROKE_IGNORE);\n}",
        "begin_line": 415,
        "end_line": 427,
        "is_bug": false
    },
    {
        "name": "src.pinyin.InitPinyin#29",
        "src_path": "src/pinyin.c",
        "class_name": "src.pinyin",
        "signature": "src.pinyin.InitPinyin(ChewingData *pgdata, const char *prefix)",
        "snippet": "int InitPinyin(ChewingData *pgdata, const char *prefix)\n{\n    char filename[PATH_MAX];\n    int i;\n    FILE *fd;\n    int ret;\n\n    sprintf(filename, \"%s\" PLAT_SEPARATOR \"%s\", prefix, PINYIN_TAB_NAME);\n\n    fd = fopen(filename, \"r\");\n\n    if (!fd)\n        return 0;\n\n    ret = fscanf(fd, \"%d\", &pgdata->static_data.HANYU_INITIALS);\n    if (ret != 1) {\n        goto fail;\n    }\n    ++pgdata->static_data.HANYU_INITIALS;\n    pgdata->static_data.hanyuInitialsMap = ALC(keymap, pgdata->static_data.HANYU_INITIALS);\n    for (i = 0; i < pgdata->static_data.HANYU_INITIALS - 1; i++) {\n        ret = fscanf(fd, \"%s %s\",\n                     pgdata->static_data.hanyuInitialsMap[i].pinyin, pgdata->static_data.hanyuInitialsMap[i].bopomofo);\n        if (ret != 2) {\n            goto fail;\n        }\n    }\n\n    ret = fscanf(fd, \"%d\", &pgdata->static_data.HANYU_FINALS);\n    if (ret != 1) {\n        goto fail;\n    }\n    ++pgdata->static_data.HANYU_FINALS;\n    pgdata->static_data.hanyuFinalsMap = ALC(keymap, pgdata->static_data.HANYU_FINALS);\n    for (i = 0; i < pgdata->static_data.HANYU_FINALS - 1; i++) {\n        ret = fscanf(fd, \"%s %s\",\n                     pgdata->static_data.hanyuFinalsMap[i].pinyin, pgdata->static_data.hanyuFinalsMap[i].bopomofo);\n        if (ret != 2) {\n            goto fail;\n        }\n    }\n\n    fclose(fd);\n    return 1;\n\nfail:\n    fclose(fd);\n    return 0;\n}",
        "begin_line": 29,
        "end_line": 77,
        "is_bug": false
    },
    {
        "name": "src.pinyin.PinyinToBopomofo#87",
        "src_path": "src/pinyin.c",
        "class_name": "src.pinyin",
        "signature": "src.pinyin.PinyinToBopomofo(ChewingData *pgdata, const char *pinyinKeySeq, char *bopomofoKeySeq, char *bopomofoKeySeqAlt)",
        "snippet": "int PinyinToBopomofo(ChewingData *pgdata, const char *pinyinKeySeq, char *bopomofoKeySeq, char *bopomofoKeySeqAlt)\n{\n    const char *p, *cursor = NULL;\n    const char *initial = 0;\n    const char *final = 0;\n    const char *seq = 0;\n    int i;\n\n    /* special cases for WG */\n    if (!strcmp(pinyinKeySeq, \"tzu\")) {\n        seq = \"y yj\";           /* \u3117|\u3117\u3128 */\n    } else if (!strcmp(pinyinKeySeq, \"ssu\") || !strcmp(pinyinKeySeq, \"szu\")) {\n        seq = \"n n\";            /* \u3119|\u3119\u3128 */\n    }\n\n    /* common multiple mapping */\n    if (!strcmp(pinyinKeySeq, \"e\")) {\n        seq = \"k ,\";            /* \u311c|\u311d */\n    } else if (!strcmp(pinyinKeySeq, \"ch\")) {\n        seq = \"t f\";            /* \u3114|\u3111 */\n    } else if (!strcmp(pinyinKeySeq, \"sh\")) {\n        seq = \"g v\";            /* \u3115|\u3112 */\n    } else if (!strcmp(pinyinKeySeq, \"c\")) {\n        seq = \"h f\";            /* \u3118|\u3111 */\n    } else if (!strcmp(pinyinKeySeq, \"s\")) {\n        seq = \"n v\";            /* \u3119|\u3112 */\n    } else if (!strcmp(pinyinKeySeq, \"nu\")) {\n        seq = \"sj sm\";          /* \u310b\u3128|\u310b\u3129 */\n    } else if (!strcmp(pinyinKeySeq, \"lu\")) {\n        seq = \"xj xm\";          /* \u310c\u3128|\u310c\u3129 */\n    } else if (!strcmp(pinyinKeySeq, \"luan\")) {\n        seq = \"xj0 xm0\";        /* \u310c\u3128\u3122|\u310c\u3129\u3122 */\n    } else if (!strcmp(pinyinKeySeq, \"niu\")) {\n        seq = \"su. sm\";         /* \u310b\u3127\u3121|\u310b\u3129 */\n    } else if (!strcmp(pinyinKeySeq, \"liu\")) {\n        seq = \"xu. xm\";         /* \u310c\u3127\u3121|\u310c\u3129 */\n    } else if (!strcmp(pinyinKeySeq, \"jiu\")) {\n        seq = \"ru. rm\";         /* \u3110\u3127\u3121|\u3110\u3129 */\n    } else if (!strcmp(pinyinKeySeq, \"chiu\")) {\n        seq = \"fu. fm\";         /* \u3111\u3127\u3121|\u3111\u3129 */\n    } else if (!strcmp(pinyinKeySeq, \"shiu\")) {\n        seq = \"vu. vm\";         /* \u3112\u3127\u3121|\u3112\u3129 */\n    } else if (!strcmp(pinyinKeySeq, \"ju\")) {\n        seq = \"rm 5j\";          /* \u3110\u3129|\u3113\u3128 */\n    } else if (!strcmp(pinyinKeySeq, \"juan\")) {\n        seq = \"rm0 5j0\";        /* \u3110\u3129\u3122|\u3113\u3128\u3122 */\n    }\n\n    /* multiple mapping for each kbtype */\n    switch (pgdata->bopomofoData.kbtype) {\n    case KB_HANYU_PINYIN:\n        if (!strcmp(pinyinKeySeq, \"chi\")) {\n            seq = \"t fu\";       /* \u3114|\u3111\u3127 */\n        } else if (!strcmp(pinyinKeySeq, \"shi\")) {\n            seq = \"g vu\";       /* \u3115|\u3112\u3127 */\n        } else if (!strcmp(pinyinKeySeq, \"ci\")) {\n            seq = \"h fu\";       /* \u3118|\u3111\u3127 */\n        } else if (!strcmp(pinyinKeySeq, \"si\")) {\n            seq = \"n vu\";       /* \u3119|\u3112\u3127 */\n        }\n        break;\n    case KB_THL_PINYIN:\n        if (!strcmp(pinyinKeySeq, \"chi\")) {\n            seq = \"fu t\";       /* \u3111\u3127|\u3114 */\n        } else if (!strcmp(pinyinKeySeq, \"shi\")) {\n            seq = \"vu g\";       /* \u3112\u3127|\u3115 */\n        } else if (!strcmp(pinyinKeySeq, \"ci\")) {\n            seq = \"fu h\";       /* \u3111\u3127|\u3118 */\n        } else if (!strcmp(pinyinKeySeq, \"si\")) {\n            seq = \"vu n\";       /* \u3112\u3127|\u3119 */\n        }\n        break;\n    case KB_MPS2_PINYIN:\n        if (!strcmp(pinyinKeySeq, \"chi\")) {\n            seq = \"fu t\";       /* \u3111\u3127|\u3114 */\n        } else if (!strcmp(pinyinKeySeq, \"shi\")) {\n            seq = \"vu g\";       /* \u3112\u3127|\u3115 */\n        } else if (!strcmp(pinyinKeySeq, \"ci\")) {\n            seq = \"fu h\";       /* \u3111\u3127|\u3118 */\n        } else if (!strcmp(pinyinKeySeq, \"si\")) {\n            seq = \"vu n\";       /* \u3112\u3127|\u3119 */\n        } else if (!strcmp(pinyinKeySeq, \"niu\")) {\n            seq = \"sm su.\";     /* \u310b\u3129|\u310b\u3127\u3121 */\n        } else if (!strcmp(pinyinKeySeq, \"liu\")) {\n            seq = \"xm xu.\";     /* \u310c\u3129|\u310c\u3127\u3121 */\n        } else if (!strcmp(pinyinKeySeq, \"jiu\")) {\n            seq = \"rm ru.\";     /* \u3110\u3129|\u3110\u3127\u3121 */\n        } else if (!strcmp(pinyinKeySeq, \"chiu\")) {\n            seq = \"fm fu.\";     /* \u3111\u3129|\u3111\u3127\u3121 */\n        } else if (!strcmp(pinyinKeySeq, \"shiu\")) {\n            seq = \"vm vu.\";     /* \u3112\u3129|\u3112\u3127\u3121 */\n        } else if (!strcmp(pinyinKeySeq, \"ju\")) {\n            seq = \"5j rm\";      /* \u3113\u3128|\u3110\u3129 */\n        } else if (!strcmp(pinyinKeySeq, \"juan\")) {\n            seq = \"5j0 rm0\";    /* \u3113\u3128\u3122|\u3110\u3129\u3122 */\n        } else if (!strcmp(pinyinKeySeq, \"juen\")) {\n            seq = \"5jp 5jp\";    /* \u3113\u3128\u3123|\u3113\u3128\u3123 */\n        } else if (!strcmp(pinyinKeySeq, \"tzu\")) {\n            seq = \"yj y\";       /* \u3117\u3128|\u3117 */\n        }\n        break;\n    }\n    if (seq != NULL) {\n        char s[BOPOMOFO_SIZE * 2 + 1];\n\n        strcpy(s, seq);\n        initial = strtok(s, \" \");\n        strcpy(bopomofoKeySeq, initial);\n        initial = strtok(NULL, \" \");\n        strcpy(bopomofoKeySeqAlt, initial);\n        return 0;\n    }\n\n\n    for (i = 0; i < pgdata->static_data.HANYU_INITIALS; i++) {\n        p = strstr(pinyinKeySeq, pgdata->static_data.hanyuInitialsMap[i].pinyin);\n        if (p == pinyinKeySeq) {\n            initial = pgdata->static_data.hanyuInitialsMap[i].bopomofo;\n            cursor = pinyinKeySeq + strlen(pgdata->static_data.hanyuInitialsMap[i].pinyin);\n            break;\n        }\n    }\n    if (i == pgdata->static_data.HANYU_INITIALS) {\n        /* No initials. might be \u3127\u3128\u3129 */\n        /* XXX: I NEED Implementation\n           if(finalsKeySeq[0] != ) {\n           }\n         */\n        return 1;\n    }\n\n    if (cursor) {\n        for (i = 0; i < pgdata->static_data.HANYU_FINALS; i++) {\n            if (strcmp(cursor, pgdata->static_data.hanyuFinalsMap[i].pinyin) == 0) {\n                final = pgdata->static_data.hanyuFinalsMap[i].bopomofo;\n                break;\n            }\n        }\n        if (i == pgdata->static_data.HANYU_FINALS) {\n            return 2;\n        }\n    }\n\n\n    /* THL empty rime\n     * we use '=' in pinyin.tab as empty rime, restore it to ''\n     */\n    if (!strcmp(final, \"=\")) {\n        final = \"\";\n    }\n\n    /* Hanyu empty rime\n     * \u3113/\u3114/\u3115/\u3116/\u3117/\u3118/\u3119 + -i, -i is empty rime, not \u3127\n     * */\n    if (!strcmp(final, \"u\")) {\n        if (!strcmp(initial, \"5\") ||\n            !strcmp(initial, \"t\") ||\n            !strcmp(initial, \"g\") ||\n            !strcmp(initial, \"b\") || !strcmp(initial, \"y\") || !strcmp(initial, \"h\") || !strcmp(initial, \"n\")) {\n            final = \"\";\n        }\n    }\n\n    /* Hanyu uan/un/u :\n     * \u3110/\u3111/\u3112 + -uan, -uan is \u3129\u3122, not \u3128\u3122\n     * \u3110/\u3111/\u3112 + -un,  -un is \u3129\u3123, not \u3128\u3123\n     * \u3110/\u3111/\u3112 + -u,   -u is \u3127, not \u3128\n     */\n    if (!strcmp(initial, \"f\") || !strcmp(initial, \"r\") || !strcmp(initial, \"v\")) {\n        if (!strcmp(final, \"j0\")) {\n            final = \"m0\";\n        } else if (!strcmp(final, \"jp\")) {\n            final = \"mp\";\n        } else if (!strcmp(final, \"j\")) {\n            final = \"m\";\n        }\n\n    }\n\n    /* THL/MPS2 s/sh/c/ch/j :\n     * s-  + \u30fc/\u3129, s-  is \u3112, not \u3119 (THL/Tongyong)\n     * sh- + \u30fc/\u3129, sh- is \u3112, not \u3115 (MPS2)\n     * c-  + \u30fc/\u3129, c-  is \u3111, not \u3118 (Tongyong)\n     * ch- + \u3127/\u3129, ch- is \u3111, not \u3114 (THL)\n     * j-  + other than \u30fc/\u3129, j-  is \u3113, not \u3110 (MPS2)\n     */\n\n    if (final == strstr(final, \"u\") || final == strstr(final, \"m\")) {\n        if (!strcmp(initial, \"n\")) {\n            initial = \"v\";\n        } else if (!strcmp(initial, \"g\")) {\n            initial = \"v\";\n        } else if (!strcmp(initial, \"h\")) {\n            initial = \"f\";\n        } else if (!strcmp(initial, \"t\")) {\n            initial = \"f\";\n        }\n    } else {\n        if (!strcmp(initial, \"r\")) {\n            initial = \"5\";\n        }\n    }\n\n    /* THL supplemental set\n     * \u3105/\u3106/\u3107/\u3108 + -\u3128\u3125, -\u3128\u3125 is another reading of -\u3125\n     * \u3105/\u3106/\u3107/\u3108 + -\u3128\u311b, -\u3128\u311b is another reading of -\u311b\n     */\n    if (!strcmp(initial, \"1\") || !strcmp(initial, \"q\") || !strcmp(initial, \"a\") || !strcmp(initial, \"z\")) {\n\n        if (!strcmp(final, \"ji\")) {\n            final = \"i\";\n        } else if (!strcmp(final, \"j/\")) {\n            final = \"/\";\n        }\n\n    }\n\n    sprintf(bopomofoKeySeq, \"%s%s\", initial, final);\n    strcpy(bopomofoKeySeqAlt, bopomofoKeySeq);\n    return 0;\n}\n",
        "begin_line": 87,
        "end_line": 307,
        "is_bug": false
    },
    {
        "name": "src.pinyin.TerminatePinyin#23",
        "src_path": "src/pinyin.c",
        "class_name": "src.pinyin",
        "signature": "src.pinyin.TerminatePinyin(ChewingData *pgdata)",
        "snippet": "void TerminatePinyin(ChewingData *pgdata)\n{\n    free(pgdata->static_data.hanyuInitialsMap);\n    free(pgdata->static_data.hanyuFinalsMap);\n}",
        "begin_line": 23,
        "end_line": 27,
        "is_bug": false
    },
    {
        "name": "src.porting_layer.src.plat_path.are_all_files_readable#153",
        "src_path": "src/porting_layer/src/plat_path.c",
        "class_name": "src.porting_layer.src.plat_path",
        "signature": "src.porting_layer.src.plat_path.are_all_files_readable(const char *path, const char *const *files, char *output, size_t output_len)",
        "snippet": "static int are_all_files_readable(const char *path,\n                                  const char *const *files,\n                                  char *output, size_t output_len)\n{\n    int i;\n\n    assert(path);\n    assert(files);\n\n    for (i = 0; files[i] != NULL; ++i) {\n        snprintf(output, output_len,\n                 \"%s\" PLAT_SEPARATOR \"%s\", path, files[i]);\n        if (access(output, R_OK) != 0)\n            return 0;\n    }\n\n    return 1;\n}",
        "begin_line": 153,
        "end_line": 170,
        "is_bug": false
    },
    {
        "name": "src.porting_layer.src.plat_path.find_path_by_files#172",
        "src_path": "src/porting_layer/src/plat_path.c",
        "class_name": "src.porting_layer.src.plat_path",
        "signature": "src.porting_layer.src.plat_path.find_path_by_files(const char *search_path, const char *const *files, char *output, size_t output_len)",
        "snippet": "int find_path_by_files(const char *search_path,\n                       const char *const *files,\n                       char *output, size_t output_len)\n{\n    char buffer[PATH_MAX + 1] = {0};\n    char *path;\n    char *saveptr;\n    int ret;\n\n    assert(search_path);\n    assert(files);\n    assert(output);\n    assert(output_len);\n\n    /* strtok_r will modify its first parameter. */\n    strncpy(buffer, search_path, sizeof(buffer) - 1);\n\n    for (path = strtok_r(buffer, SEARCH_PATH_SEP, &saveptr); path;\n         path = strtok_r(NULL, SEARCH_PATH_SEP, &saveptr)) {\n        ret = are_all_files_readable(path, files, output, output_len);\n        if (ret) {\n            snprintf(output, output_len, \"%s\", path);\n            return 0;\n        }\n    }\n    return -1;\n}",
        "begin_line": 172,
        "end_line": 198,
        "is_bug": false
    },
    {
        "name": "src.tree.AddInterval#283",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.AddInterval(TreeDataType *ptd, int begin, int end, Phrase *p_phrase, int dict_or_user)",
        "snippet": "static void AddInterval(TreeDataType *ptd, int begin, int end, Phrase *p_phrase, int dict_or_user)\n{\n    ptd->interval[ptd->nInterval].from = begin;\n    ptd->interval[ptd->nInterval].to = end + 1;\n    ptd->interval[ptd->nInterval].p_phr = p_phrase;\n    ptd->interval[ptd->nInterval].source = dict_or_user;\n    ptd->nInterval++;\n}",
        "begin_line": 283,
        "end_line": 290,
        "is_bug": false
    },
    {
        "name": "src.tree.CheckBreakpoint#110",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CheckBreakpoint(int from, int to, int bArrBrkpt[])",
        "snippet": "static int CheckBreakpoint(int from, int to, int bArrBrkpt[])\n{\n    int i;\n\n    for (i = from + 1; i < to; i++)\n        if (bArrBrkpt[i])\n            return 0;\n    return 1;\n}",
        "begin_line": 110,
        "end_line": 118,
        "is_bug": false
    },
    {
        "name": "src.tree.CheckChoose#196",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CheckChoose(ChewingData *pgdata, const TreeType *phrase_parent, int from, int to, Phrase **pp_phr, char selectStr[][MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1], IntervalType selectInterval[], int nSelect)",
        "snippet": "static int CheckChoose(ChewingData *pgdata,\n                       const TreeType *phrase_parent, int from, int to, Phrase **pp_phr,\n                       char selectStr[][MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1],\n                       IntervalType selectInterval[], int nSelect)\n{\n    IntervalType inte, c;\n    int chno, len;\n    Phrase *phrase = ALC(Phrase, 1);\n\n    assert(phrase);\n    inte.from = from;\n    inte.to = to;\n    *pp_phr = NULL;\n\n    /* if there exist one phrase satisfied all selectStr then return 1, else return 0. */\n    GetPhraseFirst(pgdata, phrase, phrase_parent);\n    do {\n        for (chno = 0; chno < nSelect; chno++) {\n            c = selectInterval[chno];\n\n            if (IsContain(inte, c)) {\n                /* find a phrase under phrase_parent where the text contains\n                 * 'selectStr[chno]' test if not ok then return 0, if ok\n                 * then continue to test\n                 */\n                len = c.to - c.from;\n                if (memcmp(ueStrSeek(phrase->phrase, c.from - from),\n                           selectStr[chno], ueStrNBytes(selectStr[chno], len)))\n                    break;\n            } else if (IsIntersect(inte, selectInterval[chno])) {\n                free(phrase);\n                return 0;\n            }\n        }\n        if (chno == nSelect) {\n            *pp_phr = phrase;\n            return 1;\n        }\n    } while (GetVocabNext(pgdata, phrase));\n    free(phrase);\n    return 0;\n}",
        "begin_line": 196,
        "end_line": 237,
        "is_bug": false
    },
    {
        "name": "src.tree.CheckUserChoose#120",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CheckUserChoose(ChewingData *pgdata, uint16_t *new_phoneSeq, int from, int to, Phrase **pp_phr, char selectStr[][MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1], IntervalType selectInterval[], int nSelect)",
        "snippet": "static int CheckUserChoose(ChewingData *pgdata,\n                           uint16_t *new_phoneSeq, int from, int to,\n                           Phrase **pp_phr,\n                           char selectStr[][MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1],\n                           IntervalType selectInterval[], int nSelect)\n{\n    IntervalType inte, c;\n    int chno, len;\n    int user_alloc;\n    UserPhraseData *pUserPhraseData;\n    Phrase *p_phr = ALC(Phrase, 1);\n\n    assert(p_phr);\n    inte.from = from;\n    inte.to = to;\n    *pp_phr = NULL;\n\n    /* pass 1\n     * if these exist one selected interval which is not contained by inte\n     * but has intersection with inte, then inte is an unacceptable interval\n     */\n    for (chno = 0; chno < nSelect; chno++) {\n        c = selectInterval[chno];\n        if (IsIntersect(inte, c) && !IsContain(inte, c)) {\n            free(p_phr);\n            return 0;\n        }\n    }\n\n    /* pass 2\n     * if there exist one phrase satisfied all selectStr then return 1, else return 0.\n     * also store the phrase with highest freq\n     */\n    pUserPhraseData = UserGetPhraseFirst(pgdata, new_phoneSeq);\n    if (pUserPhraseData == NULL)\n      goto end;\n    p_phr->freq = -1;\n    do {\n        for (chno = 0; chno < nSelect; chno++) {\n            c = selectInterval[chno];\n\n            if (IsContain(inte, c)) {\n                /*\n                 * find a phrase of ph_id where the text contains\n                 * 'selectStr[chno]' test if not ok then return 0,\n                 * if ok then continue to test. */\n                len = c.to - c.from;\n                if (memcmp(ueStrSeek(pUserPhraseData->wordSeq, c.from - from),\n                           selectStr[chno], ueStrNBytes(selectStr[chno], len)))\n                    break;\n            }\n\n        }\n        if (chno == nSelect) {\n            /* save phrase data to \"pp_phr\" */\n            if (pUserPhraseData->userfreq > p_phr->freq) {\n                if ((user_alloc = (to - from)) > 0) {\n                    ueStrNCpy(p_phr->phrase, pUserPhraseData->wordSeq, user_alloc, 1);\n                }\n                p_phr->freq = pUserPhraseData->userfreq;\n                *pp_phr = p_phr;\n            }\n        }\n    } while ((pUserPhraseData = UserGetPhraseNext(pgdata, new_phoneSeq)) != NULL);\n    UserGetPhraseEnd(pgdata, new_phoneSeq);\n\n    if (p_phr->freq != -1)\n        return 1;\n  end:\n    free(p_phr);\n    return 0;\n}",
        "begin_line": 120,
        "end_line": 191,
        "is_bug": false
    },
    {
        "name": "src.tree.CleanUpMem#754",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CleanUpMem(TreeDataType *ptd)",
        "snippet": "static void CleanUpMem(TreeDataType *ptd)\n{\n    int i;\n    RecordNode *pNode;\n\n    for (i = 0; i < ptd->nInterval; i++) {\n        if (ptd->interval[i].p_phr) {\n            free(ptd->interval[i].p_phr);\n            ptd->interval[i].p_phr = NULL;\n        }\n    }\n    while (ptd->phList != NULL) {\n        pNode = ptd->phList;\n        ptd->phList = pNode->next;\n        free(pNode->arrIndex);\n        free(pNode);\n    }\n}",
        "begin_line": 754,
        "end_line": 771,
        "is_bug": false
    },
    {
        "name": "src.tree.CompRecord#419",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CompRecord(const RecordNode **pa, const RecordNode **pb)",
        "snippet": "static int CompRecord(const RecordNode **pa, const RecordNode **pb)\n{\n    int diff = (*pb)->nMatchCnnct - (*pa)->nMatchCnnct;\n\n    if (diff)\n        return diff;\n    return ((*pb)->score - (*pa)->score);\n}",
        "begin_line": 419,
        "end_line": 426,
        "is_bug": false
    },
    {
        "name": "src.tree.CompTreeType#239",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CompTreeType(const void *a, const void *b)",
        "snippet": "static int CompTreeType(const void *a, const void *b)\n{\n    return GetUint16(((TreeType *) a)->key) - GetUint16(((TreeType *) b)->key);\n}",
        "begin_line": 239,
        "end_line": 242,
        "is_bug": false
    },
    {
        "name": "src.tree.CountMatchCnnct#773",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CountMatchCnnct(TreeDataType *ptd, const int *bUserArrCnnct, int nPhoneSeq)",
        "snippet": "static void CountMatchCnnct(TreeDataType *ptd, const int *bUserArrCnnct, int nPhoneSeq)\n{\n    RecordNode *p;\n    int i, k, sum;\n\n    for (p = ptd->phList; p; p = p->next) {\n        /* for each record, count its 'nMatchCnnct' */\n        for (sum = 0, i = 1; i < nPhoneSeq; i++) {\n            if (!bUserArrCnnct[i])\n                continue;\n            /* check if matching 'cnnct' */\n            for (k = 0; k < p->nInter; k++) {\n                if (ptd->interval[p->arrIndex[k]].from < i && ptd->interval[p->arrIndex[k]].to > i) {\n                    sum++;\n                    break;\n                }\n            }\n        }\n        p->nMatchCnnct = sum;\n    }\n}",
        "begin_line": 773,
        "end_line": 793,
        "is_bug": false
    },
    {
        "name": "src.tree.CreateNullIntervalRecord#908",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CreateNullIntervalRecord()",
        "snippet": "static RecordNode *CreateNullIntervalRecord()\n{\n    RecordNode *ret = NULL;\n    ret = ALC(RecordNode, 1);\n\n    if (!ret)\n        return NULL;\n\n    ret->arrIndex = ALC(int, 1);\n    if (!ret->arrIndex) {\n        free(ret);\n        return NULL;\n    }\n\n    ret->nInter = 0;\n    ret->score = 0;\n\n    return ret;\n}",
        "begin_line": 908,
        "end_line": 926,
        "is_bug": false
    },
    {
        "name": "src.tree.CreateSingleIntervalRecord#883",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CreateSingleIntervalRecord(TreeDataType *pdt, const int interval_id)",
        "snippet": "static RecordNode *CreateSingleIntervalRecord(TreeDataType *pdt, const int interval_id)\n{\n    RecordNode *ret = NULL;\n\n    assert(pdt);\n\n    ret = ALC(RecordNode, 1);\n\n    if (!ret)\n        return NULL;\n\n    ret->arrIndex = ALC(int, 1);\n    if (!ret->arrIndex) {\n        free(ret);\n        return NULL;\n    }\n\n    ret->nInter = 1;\n    ret->arrIndex[0] = interval_id;\n\n    ret->score = LoadPhraseAndCountScore(ret->arrIndex, ret->nInter, pdt);\n\n    return ret;\n}",
        "begin_line": 883,
        "end_line": 906,
        "is_bug": false
    },
    {
        "name": "src.tree.Discard1#435",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.Discard1(TreeDataType *ptd)",
        "snippet": "static void Discard1(TreeDataType *ptd)\n{\n    int a, b;\n    char failflag[INTERVAL_SIZE];\n    int nInterval2;\n\n    memset(failflag, 0, sizeof(failflag));\n    for (a = 0; a < ptd->nInterval; a++) {\n        if (failflag[a])\n            continue;\n        for (b = 0; b < ptd->nInterval; b++) {\n            if (a == b || failflag[b])\n                continue;\n\n            /* interval b is in interval a */\n            if (PhraseIntervalContain(ptd->interval[a], ptd->interval[b]))\n                continue;\n\n            /* interval b is in front of interval a */\n            if (ptd->interval[b].to <= ptd->interval[a].from)\n                continue;\n\n            /* interval b is in back of interval a */\n            if (ptd->interval[a].to <= ptd->interval[b].from)\n                continue;\n\n            break;\n        }\n        /* if any other interval b is inside or leftside or rightside the\n         * interval a */\n        if (b >= ptd->nInterval) {\n            /* then kill all the intervals inside the interval a */\n            int i;\n\n            for (i = 0; i < ptd->nInterval; i++) {\n                if (!failflag[i] && i != a && PhraseIntervalContain(ptd->interval[a], ptd->interval[i])) {\n                    failflag[i] = 1;\n                }\n            }\n        }\n    }\n    /* discard all the intervals whose failflag[a] = 1 */\n    nInterval2 = 0;\n    for (a = 0; a < ptd->nInterval; a++) {\n        if (!failflag[a]) {\n            ptd->interval[nInterval2++] = ptd->interval[a];\n        } else {\n            if (ptd->interval[a].p_phr != NULL) {\n                free(ptd->interval[a].p_phr);\n            }\n        }\n    }\n    ptd->nInterval = nInterval2;\n}",
        "begin_line": 435,
        "end_line": 488,
        "is_bug": false
    },
    {
        "name": "src.tree.Discard2#501",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.Discard2(TreeDataType *ptd)",
        "snippet": "static void Discard2(TreeDataType *ptd)\n{\n    int i, j;\n    char overwrite[MAX_PHONE_SEQ_LEN];\n    char failflag[INTERVAL_SIZE];\n    int nInterval2;\n\n    memset(failflag, 0, sizeof(failflag));\n    for (i = 0; i < ptd->nInterval; i++) {\n        if (ptd->leftmost[ptd->interval[i].from] == 0)\n            continue;\n        /* test if interval i is overwrited by other intervals */\n        memset(overwrite, 0, sizeof(overwrite));\n        for (j = 0; j < ptd->nInterval; j++) {\n            if (j == i)\n                continue;\n            memset(&overwrite[ptd->interval[j].from], 1, ptd->interval[j].to - ptd->interval[j].from);\n        }\n        if (memchr(&overwrite[ptd->interval[i].from], 1, ptd->interval[i].to - ptd->interval[i].from))\n            failflag[i] = 1;\n    }\n    /* discard all the intervals whose failflag[a] = 1 */\n    nInterval2 = 0;\n    for (i = 0; i < ptd->nInterval; i++)\n        if (!failflag[i])\n            ptd->interval[nInterval2++] = ptd->interval[i];\n    ptd->nInterval = nInterval2;\n}",
        "begin_line": 501,
        "end_line": 528,
        "is_bug": false
    },
    {
        "name": "src.tree.DoDpPhrasing#936",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.DoDpPhrasing(ChewingData *pgdata, TreeDataType *pdt)",
        "snippet": "static void DoDpPhrasing(ChewingData *pgdata, TreeDataType *pdt)\n{\n    RecordNode *highest_score[MAX_PHONE_SEQ_LEN] = { 0 };\n    RecordNode *tmp;\n    int prev_end;\n    int end;\n    int interval_id;\n\n    assert(pgdata);\n    assert(pdt);\n\n    /*\n     * Assume P(x,y) is the highest score phrasing result from x to y. The\n     * following is formula for P(x,y):\n     *\n     * P(x,y) = MAX( P(x,y-1)+P(y-1,y), P(x,y-2)+P(y-2,y), ... )\n     *\n     * While P(x,y-1) is stored in highest_score array, and P(y-1,y) is\n     * interval end at y. In this formula, x is always 0.\n     *\n     * The format of highest_score array is described as following:\n     *\n     * highest_score[0] = P(0,0)\n     * highest_score[1] = P(0,1)\n     * ...\n     * highest_score[y-1] = P(0,y-1)\n     */\n\n    /* The interval shall be sorted by the increase order of end. */\n    qsort(pdt->interval, pdt->nInterval, sizeof(pdt->interval[0]), SortByIncreaseEnd);\n\n    for (interval_id = 0; interval_id < pdt->nInterval; ++interval_id) {\n        /*\n         * XXX: pdt->interval.to is excluding, while end is\n         * including, so we need to minus one here.\n         */\n        end = pdt->interval[interval_id].to - 1;\n\n        prev_end = pdt->interval[interval_id].from - 1;\n\n        if (prev_end >= 0)\n            tmp = DuplicateRecordAndInsertInterval(highest_score[prev_end], pdt, interval_id);\n        else\n            tmp = CreateSingleIntervalRecord(pdt, interval_id);\n\n        /* FIXME: shall exit immediately? */\n        if (!tmp)\n            continue;\n\n        if (highest_score[end] == NULL || highest_score[end]->score < tmp->score) {\n            FreeRecord(highest_score[end]);\n            highest_score[end] = tmp;\n        } else\n            FreeRecord(tmp);\n    }\n\n    if (pgdata->nPhoneSeq - 1 < 0 || highest_score[pgdata->nPhoneSeq - 1] == NULL) {\n        pdt->phList = CreateNullIntervalRecord();\n    } else {\n        pdt->phList = highest_score[pgdata->nPhoneSeq - 1];\n    }\n    pdt->nPhListLen = 1;\n\n    for (end = 0; end < pgdata->nPhoneSeq - 1; ++end)\n        FreeRecord(highest_score[end]);\n}",
        "begin_line": 936,
        "end_line": 1001,
        "is_bug": false
    },
    {
        "name": "src.tree.DuplicateRecordAndInsertInterval#856",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.DuplicateRecordAndInsertInterval(const RecordNode *record, TreeDataType *pdt, const int interval_id)",
        "snippet": "static RecordNode *DuplicateRecordAndInsertInterval(const RecordNode *record, TreeDataType *pdt, const int interval_id)\n{\n    RecordNode *ret = NULL;\n\n    assert(record);\n    assert(pdt);\n\n    ret = ALC(RecordNode, 1);\n\n    if (!ret)\n        return NULL;\n\n    ret->arrIndex = ALC(int, record->nInter + 1);\n    if (!ret->arrIndex) {\n        free(ret);\n        return NULL;\n    }\n    ret->nInter = record->nInter + 1;\n    memcpy(ret->arrIndex, record->arrIndex, sizeof(record->arrIndex[0]) * record->nInter);\n\n    ret->arrIndex[ret->nInter - 1] = interval_id;\n\n    ret->score = LoadPhraseAndCountScore(ret->arrIndex, ret->nInter, pdt);\n\n    return ret;\n}",
        "begin_line": 856,
        "end_line": 881,
        "is_bug": false
    },
    {
        "name": "src.tree.FillPreeditBuf#530",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.FillPreeditBuf(ChewingData *pgdata, char *phrase, int from, int to)",
        "snippet": "static void FillPreeditBuf(ChewingData *pgdata, char *phrase, int from, int to)\n{\n    int i;\n    int start = 0;\n\n    assert(pgdata);\n    assert(phrase);\n    assert(from < to);\n\n    start = toPreeditBufIndex(pgdata, from);\n\n    LOG_VERBOSE(\"Fill preeditBuf start %d, from = %d, to = %d\", start, from, to);\n\n    for (i = start; i < start - from + to; ++i) {\n        ueStrNCpy(pgdata->preeditBuf[i].char_, ueStrSeek(phrase, i - start), 1, STRNCPY_CLOSE);\n    }\n}",
        "begin_line": 530,
        "end_line": 546,
        "is_bug": false
    },
    {
        "name": "src.tree.FindInterval#320",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.FindInterval(ChewingData *pgdata, TreeDataType *ptd)",
        "snippet": "static void FindInterval(ChewingData *pgdata, TreeDataType *ptd)\n{\n    int end, begin;\n    const TreeType *phrase_parent;\n    Phrase *p_phrase, *puserphrase, *pdictphrase;\n    UsedPhraseMode i_used_phrase;\n    uint16_t new_phoneSeq[MAX_PHONE_SEQ_LEN];\n    UserPhraseData *userphrase;\n\n    for (begin = 0; begin < pgdata->nPhoneSeq; begin++) {\n        for (end = begin; end < min(pgdata->nPhoneSeq, begin + MAX_PHRASE_LEN); end++) {\n            if (!CheckBreakpoint(begin, end + 1, pgdata->bArrBrkpt))\n                break;\n\n            /* set new_phoneSeq */\n            memcpy(new_phoneSeq, &pgdata->phoneSeq[begin], sizeof(uint16_t) * (end - begin + 1));\n            new_phoneSeq[end - begin + 1] = 0;\n            puserphrase = pdictphrase = NULL;\n            i_used_phrase = USED_PHRASE_NONE;\n\n            userphrase = UserGetPhraseFirst(pgdata, new_phoneSeq);\n            UserGetPhraseEnd(pgdata, new_phoneSeq);\n\n            if (userphrase && CheckUserChoose(pgdata, new_phoneSeq, begin, end + 1,\n                                              &p_phrase, pgdata->selectStr, pgdata->selectInterval, pgdata->nSelect)) {\n                puserphrase = p_phrase;\n            }\n\n            /* check dict phrase */\n            phrase_parent = TreeFindPhrase(pgdata, begin, end, pgdata->phoneSeq);\n            if (phrase_parent &&\n                CheckChoose(pgdata,\n                            phrase_parent, begin, end + 1,\n                            &p_phrase, pgdata->selectStr, pgdata->selectInterval, pgdata->nSelect)) {\n                pdictphrase = p_phrase;\n            }\n\n            /* add only one interval, which has the largest freqency\n             * but when the phrase is the same, the user phrase overrides\n             * static dict\n             */\n            if (puserphrase != NULL && pdictphrase == NULL) {\n                i_used_phrase = USED_PHRASE_USER;\n            } else if (puserphrase == NULL && pdictphrase != NULL) {\n                i_used_phrase = USED_PHRASE_DICT;\n            } else if (puserphrase != NULL && pdictphrase != NULL) {\n                /* the same phrase, userphrase overrides */\n                if (!strcmp(puserphrase->phrase, pdictphrase->phrase)) {\n                    i_used_phrase = USED_PHRASE_USER;\n                } else {\n                    if (puserphrase->freq > pdictphrase->freq) {\n                        i_used_phrase = USED_PHRASE_USER;\n                    } else {\n                        i_used_phrase = USED_PHRASE_DICT;\n                    }\n                }\n            }\n            switch (i_used_phrase) {\n            case USED_PHRASE_USER:\n                AddInterval(ptd, begin, end, puserphrase, IS_USER_PHRASE);\n                break;\n            case USED_PHRASE_DICT:\n                AddInterval(ptd, begin, end, pdictphrase, IS_DICT_PHRASE);\n                break;\n            case USED_PHRASE_NONE:\n            default:\n                break;\n            }\n            internal_release_Phrase(i_used_phrase, puserphrase, pdictphrase);\n        }\n    }\n}",
        "begin_line": 320,
        "end_line": 391,
        "is_bug": false
    },
    {
        "name": "src.tree.FreeRecord#928",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.FreeRecord(RecordNode *node)",
        "snippet": "static void FreeRecord(RecordNode *node)\n{\n    if (node) {\n        free(node->arrIndex);\n        free(node);\n    }\n}",
        "begin_line": 928,
        "end_line": 934,
        "is_bug": false
    },
    {
        "name": "src.tree.InitPhrasing#738",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.InitPhrasing(TreeDataType *ptd)",
        "snippet": "static void InitPhrasing(TreeDataType *ptd)\n{\n    memset(ptd, 0, sizeof(TreeDataType));\n}",
        "begin_line": 738,
        "end_line": 741,
        "is_bug": false
    },
    {
        "name": "src.tree.InitTree#86",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.InitTree(ChewingData *pgdata, const char *prefix)",
        "snippet": "int InitTree(ChewingData *pgdata, const char *prefix)\n{\n    char filename[PATH_MAX];\n    size_t len;\n    size_t offset;\n\n    len = snprintf(filename, sizeof(filename), \"%s\" PLAT_SEPARATOR \"%s\", prefix, PHONE_TREE_FILE);\n    if (len + 1 > sizeof(filename))\n        return -1;\n\n    plat_mmap_set_invalid(&pgdata->static_data.tree_mmap);\n    pgdata->static_data.tree_size = plat_mmap_create(&pgdata->static_data.tree_mmap, filename, FLAG_ATTRIBUTE_READ);\n    if (pgdata->static_data.tree_size <= 0)\n        return -1;\n\n    offset = 0;\n    pgdata->static_data.tree =\n        (const TreeType *) plat_mmap_set_view(&pgdata->static_data.tree_mmap, &offset, &pgdata->static_data.tree_size);\n    if (!pgdata->static_data.tree)\n        return -1;\n\n    return 0;\n}",
        "begin_line": 86,
        "end_line": 108,
        "is_bug": false
    },
    {
        "name": "src.tree.IsContain#59",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.IsContain(IntervalType in1, IntervalType in2)",
        "snippet": "static int IsContain(IntervalType in1, IntervalType in2)\n{\n    return (in1.from <= in2.from && in1.to >= in2.to);\n}",
        "begin_line": 59,
        "end_line": 62,
        "is_bug": false
    },
    {
        "name": "src.tree.IsIntersect#64",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.IsIntersect(IntervalType in1, IntervalType in2)",
        "snippet": "int IsIntersect(IntervalType in1, IntervalType in2)\n{\n    return (max(in1.from, in2.from) < min(in1.to, in2.to));\n}",
        "begin_line": 64,
        "end_line": 67,
        "is_bug": false
    },
    {
        "name": "src.tree.IsRecContain#629",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.IsRecContain(const int *intA, int nA, const int *intB, int nB, const TreeDataType *ptd)",
        "snippet": "static int IsRecContain(const int *intA, int nA, const int *intB, int nB, const TreeDataType *ptd)\n{\n    int big, sml;\n\n    for (big = 0, sml = 0; sml < nB; sml++) {\n        while ((big < nA) && ptd->interval[intA[big]].from < ptd->interval[intB[sml]].to) {\n            if (PhraseIntervalContain(ptd->interval[intA[big]], ptd->interval[intB[sml]]))\n                break;\n            big++;\n        }\n        if ((big >= nA) || ptd->interval[intA[big]].from >= ptd->interval[intB[sml]].to)\n            return 0;\n    }\n    return 1;\n}",
        "begin_line": 629,
        "end_line": 643,
        "is_bug": false
    },
    {
        "name": "src.tree.LoadPhraseAndCountScore#615",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.LoadPhraseAndCountScore(const int *record, int nRecord, const TreeDataType *ptd)",
        "snippet": "static int LoadPhraseAndCountScore(const int *record, int nRecord, const TreeDataType *ptd)\n{\n    int total_score = 0;\n\n    /* NOTE: the balance factor is tuneable */\n    if (nRecord) {\n        total_score += 1000 * rule_largest_sum(record, nRecord, ptd);\n        total_score += 1000 * rule_largest_avgwordlen(record, nRecord, ptd);\n        total_score += 100 * rule_smallest_lenvariance(record, nRecord, ptd);\n        total_score += rule_largest_freqsum(record, nRecord, ptd);\n    }\n    return total_score;\n}",
        "begin_line": 615,
        "end_line": 627,
        "is_bug": false
    },
    {
        "name": "src.tree.NextCut#811",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.NextCut(TreeDataType *tdt, PhrasingOutput *ppo)",
        "snippet": "static RecordNode *NextCut(TreeDataType *tdt, PhrasingOutput *ppo)\n{\n    /* pop nNumCut-th candidate to first */\n    int i;\n    RecordNode *former;\n    RecordNode *want;\n\n    if (ppo->nNumCut >= tdt->nPhListLen)\n        ppo->nNumCut = 0;\n    if (ppo->nNumCut == 0)\n        return tdt->phList;\n\n    /* find the former of our candidate */\n    former = tdt->phList;\n    for (i = 0; i < ppo->nNumCut - 1; i++) {\n        former = former->next;\n        assert(former);\n    }\n\n    /* take the candidate out of the listed list */\n    want = former->next;\n    assert(want);\n    former->next = former->next->next;\n\n    /* prepend to front of list */\n    want->next = tdt->phList;\n    tdt->phList = want;\n\n    return tdt->phList;\n}",
        "begin_line": 811,
        "end_line": 840,
        "is_bug": false
    },
    {
        "name": "src.tree.OutputRecordStr#549",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.OutputRecordStr(ChewingData *pgdata, const TreeDataType *ptd)",
        "snippet": "static void OutputRecordStr(ChewingData *pgdata, const TreeDataType *ptd)\n{\n    PhraseIntervalType inter;\n    int i;\n\n    for (i = 0; i < ptd->phList->nInter; i++) {\n        inter = ptd->interval[ptd->phList->arrIndex[i]];\n        FillPreeditBuf(pgdata, inter.p_phr->phrase, inter.from, inter.to);\n    }\n\n    for (i = 0; i < pgdata->nSelect; i++) {\n        FillPreeditBuf(pgdata, pgdata->selectStr[i], pgdata->selectInterval[i].from, pgdata->selectInterval[i].to);\n    }\n}",
        "begin_line": 549,
        "end_line": 562,
        "is_bug": false
    },
    {
        "name": "src.tree.PhraseIntervalContain#69",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.PhraseIntervalContain(PhraseIntervalType in1, PhraseIntervalType in2)",
        "snippet": "static int PhraseIntervalContain(PhraseIntervalType in1, PhraseIntervalType in2)\n{\n    return (in1.from <= in2.from && in1.to >= in2.to);\n}",
        "begin_line": 69,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "src.tree.PhraseIntervalIntersect#74",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.PhraseIntervalIntersect(PhraseIntervalType in1, PhraseIntervalType in2)",
        "snippet": "static int PhraseIntervalIntersect(PhraseIntervalType in1, PhraseIntervalType in2)\n{\n    return (max(in1.from, in2.from) < min(in1.to, in2.to));\n}",
        "begin_line": 74,
        "end_line": 77,
        "is_bug": false
    },
    {
        "name": "src.tree.Phrasing#1003",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.Phrasing(ChewingData *pgdata, int all_phrasing)",
        "snippet": "int Phrasing(ChewingData *pgdata, int all_phrasing)\n{\n    TreeDataType treeData;\n\n    InitPhrasing(&treeData);\n\n    FindInterval(pgdata, &treeData);\n    SetInfo(pgdata->nPhoneSeq, &treeData);\n    Discard1(&treeData);\n    Discard2(&treeData);\n    if (all_phrasing) {\n        SaveList(&treeData);\n        CountMatchCnnct(&treeData, pgdata->bUserArrCnnct, pgdata->nPhoneSeq);\n        SortListByScore(&treeData);\n        NextCut(&treeData, &pgdata->phrOut);\n    } else {\n        DoDpPhrasing(pgdata, &treeData);\n    }\n\n    ShowList(pgdata, &treeData);\n\n    /* set phrasing output */\n    OutputRecordStr(pgdata, &treeData);\n    SaveDispInterval(&pgdata->phrOut, &treeData);\n\n    /* free \"phrase\" */\n    CleanUpMem(&treeData);\n    return 0;\n}",
        "begin_line": 1003,
        "end_line": 1031,
        "is_bug": false
    },
    {
        "name": "src.tree.RecursiveSave#711",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.RecursiveSave(int depth, int to, int *record, TreeDataType *ptd)",
        "snippet": "static void RecursiveSave(int depth, int to, int *record, TreeDataType *ptd)\n{\n    int first, i;\n\n    /* to find first interval */\n    for (first = record[depth - 1] + 1; ptd->interval[first].from < to && first < ptd->nInterval; first++);\n\n    if (first == ptd->nInterval) {\n        SaveRecord(record + 1, depth - 1, ptd);\n        return;\n    }\n    record[depth] = first;\n    RecursiveSave(depth + 1, ptd->interval[first].to, record, ptd);\n    /* for each interval which intersects first */\n    for (i = first + 1; PhraseIntervalIntersect(ptd->interval[first], ptd->interval[i]) && i < ptd->nInterval; i++) {\n        record[depth] = i;\n        RecursiveSave(depth + 1, ptd->interval[i].to, record, ptd);\n    }\n}",
        "begin_line": 711,
        "end_line": 729,
        "is_bug": false
    },
    {
        "name": "src.tree.SaveDispInterval#743",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.SaveDispInterval(PhrasingOutput *ppo, TreeDataType *ptd)",
        "snippet": "static void SaveDispInterval(PhrasingOutput *ppo, TreeDataType *ptd)\n{\n    int i;\n\n    for (i = 0; i < ptd->phList->nInter; i++) {\n        ppo->dispInterval[i].from = ptd->interval[ptd->phList->arrIndex[i]].from;\n        ppo->dispInterval[i].to = ptd->interval[ptd->phList->arrIndex[i]].to;\n    }\n    ppo->nDispInterval = ptd->phList->nInter;\n}",
        "begin_line": 743,
        "end_line": 752,
        "is_bug": false
    },
    {
        "name": "src.tree.SaveList#731",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.SaveList(TreeDataType *ptd)",
        "snippet": "static void SaveList(TreeDataType *ptd)\n{\n    int record[MAX_PHONE_SEQ_LEN + 1] = { -1 };\n\n    RecursiveSave(1, 0, record, ptd);\n}",
        "begin_line": 731,
        "end_line": 736,
        "is_bug": false
    },
    {
        "name": "src.tree.SaveRecord#674",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.SaveRecord(const int *record, int nInter, TreeDataType *ptd)",
        "snippet": "static void SaveRecord(const int *record, int nInter, TreeDataType *ptd)\n{\n    RecordNode *now, *p, *pre;\n\n    pre = NULL;\n    for (p = ptd->phList; p;) {\n        /* if  'p' contains 'record', then discard 'record'. */\n        if (IsRecContain(p->arrIndex, p->nInter, record, nInter, ptd))\n            return;\n\n        /* if 'record' contains 'p', then discard 'p'\n         * -- We must deal with the linked list. */\n        if (IsRecContain(record, nInter, p->arrIndex, p->nInter, ptd)) {\n            RecordNode *tp = p;\n\n            if (pre)\n                pre->next = p->next;\n            else\n                ptd->phList = ptd->phList->next;\n            p = p->next;\n            free(tp->arrIndex);\n            free(tp);\n        } else\n            pre = p, p = p->next;\n    }\n    now = ALC(RecordNode, 1);\n\n    assert(now);\n    now->next = ptd->phList;\n    now->arrIndex = ALC(int, nInter);\n\n    assert(now->arrIndex);\n    now->nInter = nInter;\n    memcpy(now->arrIndex, record, nInter * sizeof(int));\n    ptd->phList = now;\n}",
        "begin_line": 674,
        "end_line": 709,
        "is_bug": false
    },
    {
        "name": "src.tree.SetInfo#393",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.SetInfo(int len, TreeDataType *ptd)",
        "snippet": "static void SetInfo(int len, TreeDataType *ptd)\n{\n    int i, a;\n\n    for (i = 0; i <= len; i++)\n        ptd->leftmost[i] = i;\n    for (i = 0; i < ptd->nInterval; i++) {\n        ptd->graph[ptd->interval[i].from][ptd->interval[i].to] = 1;\n        ptd->graph[ptd->interval[i].to][ptd->interval[i].from] = 1;\n    }\n\n    /* set leftmost */\n    for (a = 0; a <= len; a++) {\n        for (i = 0; i <= len; i++) {\n            if (!(ptd->graph[a][i]))\n                continue;\n            if (ptd->leftmost[i] < ptd->leftmost[a])\n                ptd->leftmost[a] = ptd->leftmost[i];\n        }\n    }\n}",
        "begin_line": 393,
        "end_line": 413,
        "is_bug": false
    },
    {
        "name": "src.tree.ShowList#795",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.ShowList(ChewingData *pgdata, const TreeDataType *ptd)",
        "snippet": "static void ShowList(ChewingData *pgdata, const TreeDataType *ptd)\n{\n    const RecordNode *p;\n    int i;\n\n    DEBUG_OUT(\"After SaveList :\\n\");\n    for (p = ptd->phList; p; p = p->next) {\n        DEBUG_OUT(\"  interval : \");\n        for (i = 0; i < p->nInter; i++) {\n            DEBUG_OUT(\"[%d %d] \", ptd->interval[p->arrIndex[i]].from, ptd->interval[p->arrIndex[i]].to);\n        }\n        DEBUG_OUT(\"\\n\" \"      score : %d , nMatchCnnct : %d\\n\", p->score, p->nMatchCnnct);\n    }\n    DEBUG_OUT(\"\\n\");\n}",
        "begin_line": 795,
        "end_line": 809,
        "is_bug": false
    },
    {
        "name": "src.tree.SortByIncreaseEnd#842",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.SortByIncreaseEnd(const void *x, const void *y)",
        "snippet": "static int SortByIncreaseEnd(const void *x, const void *y)\n{\n    const PhraseIntervalType *interval_x = (const PhraseIntervalType *) x;\n    const PhraseIntervalType *interval_y = (const PhraseIntervalType *) y;\n\n    if (interval_x->to < interval_y->to)\n        return -1;\n\n    if (interval_x->to > interval_y->to)\n        return 1;\n\n    return 0;\n}",
        "begin_line": 842,
        "end_line": 854,
        "is_bug": false
    },
    {
        "name": "src.tree.SortListByScore#645",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.SortListByScore(TreeDataType *ptd)",
        "snippet": "static void SortListByScore(TreeDataType *ptd)\n{\n    int i, listLen;\n    RecordNode *p, **arr;\n\n    for (listLen = 0, p = ptd->phList; p; listLen++, p = p->next);\n    ptd->nPhListLen = listLen;\n\n    arr = ALC(RecordNode *, listLen);\n\n    assert(arr);\n\n    for (i = 0, p = ptd->phList; i < listLen; p = p->next, i++) {\n        arr[i] = p;\n        p->score = LoadPhraseAndCountScore(p->arrIndex, p->nInter, ptd);\n    }\n\n    qsort(arr, listLen, sizeof(RecordNode *), (CompFuncType) CompRecord);\n\n    ptd->phList = arr[0];\n    for (i = 1; i < listLen; i++) {\n        arr[i - 1]->next = arr[i];\n    }\n    arr[listLen - 1]->next = NULL;\n\n    free(arr);\n}",
        "begin_line": 645,
        "end_line": 671,
        "is_bug": false
    },
    {
        "name": "src.tree.TerminateTree#79",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.TerminateTree(ChewingData *pgdata)",
        "snippet": "void TerminateTree(ChewingData *pgdata)\n{\n    pgdata->static_data.tree = NULL;\n    plat_mmap_close(&pgdata->static_data.tree_mmap);\n}",
        "begin_line": 79,
        "end_line": 83,
        "is_bug": false
    },
    {
        "name": "src.tree.TreeChildRange#277",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.TreeChildRange(ChewingData *pgdata, const TreeType *parent)",
        "snippet": "void TreeChildRange(ChewingData *pgdata, const TreeType *parent)\n{\n    pgdata->static_data.tree_cur_pos = pgdata->static_data.tree + GetUint24(parent->child.begin);\n    pgdata->static_data.tree_end_pos = pgdata->static_data.tree + GetUint24(parent->child.end);\n}",
        "begin_line": 277,
        "end_line": 281,
        "is_bug": false
    },
    {
        "name": "src.tree.TreeFindPhrase#248",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.TreeFindPhrase(ChewingData *pgdata, int begin, int end, const uint16_t *phoneSeq)",
        "snippet": "const TreeType *TreeFindPhrase(ChewingData *pgdata, int begin, int end, const uint16_t *phoneSeq)\n{\n    TreeType target;\n    const TreeType *tree_p = pgdata->static_data.tree;\n    uint32_t range[2];\n    int i;\n\n    for (i = begin; i <= end; i++) {\n        PutUint16(phoneSeq[i], target.key);\n        range[0] = GetUint24(tree_p->child.begin);\n        range[1] = GetUint24(tree_p->child.end);\n        assert(range[1] >= range[0]);\n        tree_p = (const TreeType *) bsearch(&target, pgdata->static_data.tree + range[0],\n                                            range[1] - range[0], sizeof(TreeType), CompTreeType);\n\n        /* if not found any word then fail. */\n        if (!tree_p)\n            return NULL;\n    }\n\n    /* If its child has no key value of 0, then it is only a \"half\" phrase. */\n    if (GetUint16(pgdata->static_data.tree[GetUint24(tree_p->child.begin)].key) != 0)\n        return NULL;\n    return tree_p;\n}",
        "begin_line": 248,
        "end_line": 272,
        "is_bug": false
    },
    {
        "name": "src.tree.internal_release_Phrase#299",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.internal_release_Phrase(UsedPhraseMode mode, Phrase *pUser, Phrase *pDict)",
        "snippet": "static void internal_release_Phrase(UsedPhraseMode mode, Phrase *pUser, Phrase *pDict)\n{\n    /* we must free unused phrase entry to avoid memory leak. */\n    switch (mode) {\n    case USED_PHRASE_USER:\n        if (pDict != NULL)\n            free(pDict);\n        break;\n    case USED_PHRASE_DICT:\n        if (pUser != NULL)\n            free(pUser);\n        break;\n    default:                   /* In fact, it is always 0 */\n        if (pDict != NULL)\n            free(pDict);\n        if (pUser != NULL)\n            free(pUser);\n        break;\n    }\n}",
        "begin_line": 299,
        "end_line": 318,
        "is_bug": false
    },
    {
        "name": "src.tree.rule_largest_avgwordlen#577",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.rule_largest_avgwordlen(const int *record, int nRecord, const TreeDataType *ptd)",
        "snippet": "static int rule_largest_avgwordlen(const int *record, int nRecord, const TreeDataType *ptd)\n{\n    /* constant factor 6=1*2*3, to keep value as integer */\n    return 6 * rule_largest_sum(record, nRecord, ptd) / nRecord;\n}",
        "begin_line": 577,
        "end_line": 581,
        "is_bug": false
    },
    {
        "name": "src.tree.rule_largest_freqsum#600",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.rule_largest_freqsum(const int *record, int nRecord, const TreeDataType *ptd)",
        "snippet": "static int rule_largest_freqsum(const int *record, int nRecord, const TreeDataType *ptd)\n{\n    int i, score = 0;\n    PhraseIntervalType inter;\n\n    for (i = 0; i < nRecord; i++) {\n        inter = ptd->interval[record[i]];\n        assert(inter.p_phr);\n\n        /* We adjust the 'freq' of One-word Phrase */\n        score += (inter.to - inter.from == 1) ? (inter.p_phr->freq / 512) : inter.p_phr->freq;\n    }\n    return score;\n}",
        "begin_line": 600,
        "end_line": 613,
        "is_bug": false
    },
    {
        "name": "src.tree.rule_largest_sum#564",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.rule_largest_sum(const int *record, int nRecord, const TreeDataType *ptd)",
        "snippet": "static int rule_largest_sum(const int *record, int nRecord, const TreeDataType *ptd)\n{\n    int i, score = 0;\n    PhraseIntervalType inter;\n\n    for (i = 0; i < nRecord; i++) {\n        inter = ptd->interval[record[i]];\n        assert(inter.p_phr);\n        score += inter.to - inter.from;\n    }\n    return score;\n}",
        "begin_line": 564,
        "end_line": 575,
        "is_bug": false
    },
    {
        "name": "src.tree.rule_smallest_lenvariance#583",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.rule_smallest_lenvariance(const int *record, int nRecord, const TreeDataType *ptd)",
        "snippet": "static int rule_smallest_lenvariance(const int *record, int nRecord, const TreeDataType *ptd)\n{\n    int i, j, score = 0;\n    PhraseIntervalType inter1, inter2;\n\n    /* kcwu: heuristic? why variance no square function? */\n    for (i = 0; i < nRecord; i++) {\n        for (j = i + 1; j < nRecord; j++) {\n            inter1 = ptd->interval[record[i]];\n            inter2 = ptd->interval[record[j]];\n            assert(inter1.p_phr && inter2.p_phr);\n            score += abs((inter1.to - inter1.from) - (inter2.to - inter2.from));\n        }\n    }\n    return -score;\n}",
        "begin_line": 583,
        "end_line": 598,
        "is_bug": false
    },
    {
        "name": "src.userphrase-sql.GetCurrentLifeTime#159",
        "src_path": "src/userphrase-sql.c",
        "class_name": "src.userphrase-sql",
        "signature": "src.userphrase-sql.GetCurrentLifeTime(ChewingData *pgdata)",
        "snippet": "static int GetCurrentLifeTime(ChewingData *pgdata)\n{\n    return pgdata->static_data.new_lifetime;\n}",
        "begin_line": 159,
        "end_line": 162,
        "is_bug": false
    },
    {
        "name": "src.userphrase-sql.IncreaseLifeTime#449",
        "src_path": "src/userphrase-sql.c",
        "class_name": "src.userphrase-sql",
        "signature": "src.userphrase-sql.IncreaseLifeTime(ChewingData *pgdata)",
        "snippet": "void IncreaseLifeTime(ChewingData *pgdata)\n{\n    ++pgdata->static_data.new_lifetime;\n}",
        "begin_line": 449,
        "end_line": 452,
        "is_bug": false
    },
    {
        "name": "src.userphrase-sql.LoadMaxFreq#87",
        "src_path": "src/userphrase-sql.c",
        "class_name": "src.userphrase-sql",
        "signature": "src.userphrase-sql.LoadMaxFreq(ChewingData *pgdata, const uint16_t phoneSeq[], int len)",
        "snippet": "static int LoadMaxFreq(ChewingData *pgdata, const uint16_t phoneSeq[], int len)\n{\n    const TreeType *tree_pos;\n    Phrase *phrase = ALC(Phrase, 1);\n    int maxFreq = FREQ_INIT_VALUE;\n    int max_userphrase_freq;\n    int ret;\n\n    tree_pos = TreeFindPhrase(pgdata, 0, len - 1, phoneSeq);\n    if (tree_pos) {\n        GetPhraseFirst(pgdata, phrase, tree_pos);\n        do {\n            if (phrase->freq > maxFreq)\n                maxFreq = phrase->freq;\n        } while (GetVocabNext(pgdata, phrase));\n    }\n    free(phrase);\n\n    assert(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_GET_MAX_FREQ]);\n\n    ret = UserBindPhone(pgdata, STMT_USERPHRASE_GET_MAX_FREQ, phoneSeq, len);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"UserBindPhone returns %d\", ret);\n        return maxFreq;\n    }\n\n    ret = sqlite3_step(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_GET_MAX_FREQ]);\n    if (ret != SQLITE_ROW)\n        return maxFreq;\n\n    ret = sqlite3_reset(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_GET_MAX_FREQ]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n        return maxFreq;\n    }\n\n    max_userphrase_freq = sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_GET_MAX_FREQ],\n                                             SQL_STMT_USERPHRASE[STMT_USERPHRASE_GET_MAX_FREQ].column\n                                             [COLUMN_USERPHRASE_USER_FREQ]);\n\n    if (max_userphrase_freq > maxFreq)\n        maxFreq = max_userphrase_freq;\n\n    return maxFreq;\n}",
        "begin_line": 87,
        "end_line": 131,
        "is_bug": false
    },
    {
        "name": "src.userphrase-sql.LoadOriginalFreq#63",
        "src_path": "src/userphrase-sql.c",
        "class_name": "src.userphrase-sql",
        "signature": "src.userphrase-sql.LoadOriginalFreq(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int len)",
        "snippet": "static int LoadOriginalFreq(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int len)\n{\n    const TreeType *tree_pos;\n    int retval;\n    Phrase *phrase = ALC(Phrase, 1);\n\n    tree_pos = TreeFindPhrase(pgdata, 0, len - 1, phoneSeq);\n    if (tree_pos) {\n        GetPhraseFirst(pgdata, phrase, tree_pos);\n        do {\n            /* find the same phrase */\n            if (!strcmp(phrase->phrase, wordSeq)) {\n                retval = phrase->freq;\n                free(phrase);\n                return retval;\n            }\n        } while (GetVocabNext(pgdata, phrase));\n    }\n\n    free(phrase);\n    return FREQ_INIT_VALUE;\n}",
        "begin_line": 63,
        "end_line": 84,
        "is_bug": false
    },
    {
        "name": "src.userphrase-sql.LogUserPhrase#164",
        "src_path": "src/userphrase-sql.c",
        "class_name": "src.userphrase-sql",
        "signature": "src.userphrase-sql.LogUserPhrase(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int orig_freq, int max_freq, int user_freq, int recent_time)",
        "snippet": "static void LogUserPhrase(ChewingData *pgdata,\n                          const uint16_t phoneSeq[],\n                          const char wordSeq[], int orig_freq, int max_freq, int user_freq, int recent_time)\n{\n    /* Size of each phone is len(\"0x1234 \") = 7 */\n    char buf[7 * MAX_PHRASE_LEN + 1] = { 0 };\n    int i;\n\n    for (i = 0; i < MAX_PHRASE_LEN; ++i) {\n        if (phoneSeq[i] == 0)\n            break;\n        snprintf(buf + 7 * i, 7 + 1, \"%#06x \", phoneSeq[i]);\n    }\n\n    LOG_INFO(\"userphrase %s, phone = %s, orig_freq = %d, max_freq = %d, user_freq = %d, recent_time = %d\",\n             wordSeq, buf, orig_freq, max_freq, user_freq, recent_time);\n}",
        "begin_line": 164,
        "end_line": 180,
        "is_bug": false
    },
    {
        "name": "src.userphrase-sql.UpdateFreq#134",
        "src_path": "src/userphrase-sql.c",
        "class_name": "src.userphrase-sql",
        "signature": "src.userphrase-sql.UpdateFreq(int freq, int maxfreq, int origfreq, int deltatime)",
        "snippet": "static int UpdateFreq(int freq, int maxfreq, int origfreq, int deltatime)\n{\n    int delta;\n\n    /* Short interval */\n    if (deltatime < 4000) {\n        delta = (freq >= maxfreq) ?\n            min((maxfreq - origfreq) / 5 + 1,\n                SHORT_INCREASE_FREQ) : max((maxfreq - origfreq) / 5 + 1, SHORT_INCREASE_FREQ);\n        return min(freq + delta, MAX_ALLOW_FREQ);\n    }\n    /* Medium interval */\n    else if (deltatime < 50000) {\n        delta = (freq >= maxfreq) ?\n            min((maxfreq - origfreq) / 10 + 1,\n                MEDIUM_INCREASE_FREQ) : max((maxfreq - origfreq) / 10 + 1, MEDIUM_INCREASE_FREQ);\n        return min(freq + delta, MAX_ALLOW_FREQ);\n    }\n    /* long interval */\n    else {\n        delta = max((freq - origfreq) / 5, LONG_DECREASE_FREQ);\n        return max(freq - delta, origfreq);\n    }\n}",
        "begin_line": 134,
        "end_line": 157,
        "is_bug": false
    },
    {
        "name": "src.userphrase-sql.UserBindPhone#23",
        "src_path": "src/userphrase-sql.c",
        "class_name": "src.userphrase-sql",
        "signature": "src.userphrase-sql.UserBindPhone(ChewingData *pgdata, int index, const uint16_t phoneSeq[], int len)",
        "snippet": "static int UserBindPhone(ChewingData *pgdata, int index, const uint16_t phoneSeq[], int len)\n{\n    int i;\n    int ret;\n\n    assert(pgdata);\n    assert(phoneSeq);\n\n    if (len > MAX_PHRASE_LEN) {\n        LOG_WARN(\"phoneSeq length %d > MAX_PHRASE_LEN(%d)\", len, MAX_PHRASE_LEN);\n        return -1;\n    }\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_userphrase[index], BIND_USERPHRASE_LENGTH, len);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n        return ret;\n    }\n\n    for (i = 0; i < len; ++i) {\n        ret = sqlite3_bind_int(pgdata->static_data.stmt_userphrase[index], BIND_USERPHRASE_PHONE_0 + i, phoneSeq[i]);\n        if (ret != SQLITE_OK) {\n            LOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n            return ret;\n        }\n    }\n\n    for (i = len; i < MAX_PHRASE_LEN; ++i) {\n        ret = sqlite3_bind_int(pgdata->static_data.stmt_userphrase[index], BIND_USERPHRASE_PHONE_0 + i, 0);\n        if (ret != SQLITE_OK) {\n            LOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n            return ret;\n        }\n    }\n\n    return SQLITE_OK;\n}",
        "begin_line": 23,
        "end_line": 59,
        "is_bug": false
    },
    {
        "name": "src.userphrase-sql.UserGetPhraseEnd#444",
        "src_path": "src/userphrase-sql.c",
        "class_name": "src.userphrase-sql",
        "signature": "src.userphrase-sql.UserGetPhraseEnd(ChewingData *pgdata UNUSED, const uint16_t phoneSeq[] UNUSED)",
        "snippet": "void UserGetPhraseEnd(ChewingData *pgdata UNUSED, const uint16_t phoneSeq[] UNUSED)\n{\n    /* FIXME: Remove this */\n}",
        "begin_line": 444,
        "end_line": 447,
        "is_bug": false
    },
    {
        "name": "src.userphrase-sql.UserGetPhraseFirst#382",
        "src_path": "src/userphrase-sql.c",
        "class_name": "src.userphrase-sql",
        "signature": "src.userphrase-sql.UserGetPhraseFirst(ChewingData *pgdata, const uint16_t phoneSeq[])",
        "snippet": "UserPhraseData *UserGetPhraseFirst(ChewingData *pgdata, const uint16_t phoneSeq[])\n{\n    int ret;\n    int len;\n\n    assert(pgdata);\n    assert(phoneSeq);\n\n    assert(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE]);\n    ret = sqlite3_reset(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n        return NULL;\n    }\n\n    len = GetPhoneLen(phoneSeq);\n    ret = UserBindPhone(pgdata, STMT_USERPHRASE_SELECT_BY_PHONE, phoneSeq, len);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"UserBindPhone returns %d\", ret);\n        return NULL;\n    }\n\n    return UserGetPhraseNext(pgdata, phoneSeq);\n}",
        "begin_line": 382,
        "end_line": 405,
        "is_bug": false
    },
    {
        "name": "src.userphrase-sql.UserGetPhraseNext#407",
        "src_path": "src/userphrase-sql.c",
        "class_name": "src.userphrase-sql",
        "signature": "src.userphrase-sql.UserGetPhraseNext(ChewingData *pgdata, const uint16_t phoneSeq[])",
        "snippet": "UserPhraseData *UserGetPhraseNext(ChewingData *pgdata, const uint16_t phoneSeq[])\n{\n    int ret;\n\n    assert(pgdata);\n    assert(phoneSeq);\n\n    ret = sqlite3_step(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE]);\n    if (ret != SQLITE_ROW)\n        return NULL;\n\n    /* FIXME: shall not remove const here. */\n    pgdata->userphrase_data.wordSeq =\n        (char *) sqlite3_column_text(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE],\n                                     SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE].column\n                                     [COLUMN_USERPHRASE_PHRASE]);\n    pgdata->userphrase_data.phoneSeq = (uint16_t *) phoneSeq;\n\n    pgdata->userphrase_data.recentTime =\n        sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE],\n                           SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE].column[COLUMN_USERPHRASE_TIME]);\n\n    pgdata->userphrase_data.userfreq =\n        sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE],\n                           SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE].column[COLUMN_USERPHRASE_USER_FREQ]);\n\n    pgdata->userphrase_data.maxfreq =\n        sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE],\n                           SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE].column[COLUMN_USERPHRASE_MAX_FREQ]);\n\n    pgdata->userphrase_data.origfreq =\n        sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE],\n                           SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE].column[COLUMN_USERPHRASE_ORIG_FREQ]);\n\n    return &pgdata->userphrase_data;\n}",
        "begin_line": 407,
        "end_line": 442,
        "is_bug": false
    },
    {
        "name": "src.userphrase-sql.UserUpdatePhrase#187",
        "src_path": "src/userphrase-sql.c",
        "class_name": "src.userphrase-sql",
        "signature": "src.userphrase-sql.UserUpdatePhrase(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[])",
        "snippet": "int UserUpdatePhrase(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[])\n{\n    int ret;\n    int action;\n    int phone_len;\n    int word_len;\n\n    int orig_freq;\n    int max_freq;\n    int user_freq;\n    int recent_time;\n    int orig_time;\n\n    assert(pgdata);\n    assert(phoneSeq);\n    assert(wordSeq);\n\n    phone_len = GetPhoneLen(phoneSeq);\n    word_len = ueStrLen(wordSeq);\n\n    if (phone_len != word_len) {\n        LOG_WARN(\"Do not update userphrase because phoneSeq length %d != wordSeq length %d\", phone_len, word_len);\n        return USER_UPDATE_FAIL;\n    }\n\n    if (word_len > MAX_PHRASE_LEN) {\n        LOG_WARN(\"wordSeq length %d > MAX_PHRASE_LEN (%d)\", word_len, MAX_PHRASE_LEN);\n        return USER_UPDATE_FAIL;\n    }\n\n    ret = UserBindPhone(pgdata, STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE, phoneSeq, phone_len);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"UserBindPhone returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    ret = sqlite3_bind_text(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE],\n                            BIND_USERPHRASE_PHRASE, wordSeq, -1, SQLITE_STATIC);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_bind_text returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    recent_time = GetCurrentLifeTime(pgdata);\n\n    ret = sqlite3_step(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE]);\n    if (ret == SQLITE_ROW) {\n        action = USER_UPDATE_MODIFY;\n\n        orig_freq = sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE],\n                                       SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE].column\n                                       [COLUMN_USERPHRASE_ORIG_FREQ]);\n\n        max_freq = LoadMaxFreq(pgdata, phoneSeq, phone_len);\n\n        user_freq = sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE],\n                                       SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE].column\n                                       [COLUMN_USERPHRASE_USER_FREQ]);\n\n        orig_time = sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE],\n                                       SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE].column\n                                       [COLUMN_USERPHRASE_TIME]);\n\n        user_freq = UpdateFreq(user_freq, max_freq, orig_freq, recent_time - orig_time);\n    } else {\n        action = USER_UPDATE_INSERT;\n\n        orig_freq = LoadOriginalFreq(pgdata, phoneSeq, wordSeq, word_len);\n        max_freq = LoadMaxFreq(pgdata, phoneSeq, phone_len);\n        user_freq = orig_freq;\n    }\n\n    assert(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT]);\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT],\n                           BIND_USERPHRASE_TIME, recent_time);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT],\n                           BIND_USERPHRASE_USER_FREQ, user_freq);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT],\n                           BIND_USERPHRASE_MAX_FREQ, max_freq);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT],\n                           BIND_USERPHRASE_ORIG_FREQ, orig_freq);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    ret = UserBindPhone(pgdata, STMT_USERPHRASE_UPSERT, phoneSeq, phone_len);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"UserBindPhone returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    ret = sqlite3_bind_text(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT],\n                            BIND_USERPHRASE_PHRASE, wordSeq, -1, SQLITE_STATIC);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_bind_text returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    ret = sqlite3_step(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT]);\n    if (ret != SQLITE_DONE) {\n        LOG_ERROR(\"sqlite3_step returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    LogUserPhrase(pgdata, phoneSeq, wordSeq, orig_freq, max_freq, user_freq, recent_time);\n\n  end:\n    ret = sqlite3_reset(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n    }\n\n    ret = sqlite3_reset(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n    }\n\n    return action;\n}",
        "begin_line": 187,
        "end_line": 331,
        "is_bug": false
    },
    {
        "name": "src.userphrase-sql.UserUpdatePhraseBegin#182",
        "src_path": "src/userphrase-sql.c",
        "class_name": "src.userphrase-sql",
        "signature": "src.userphrase-sql.UserUpdatePhraseBegin(ChewingData *pgdata)",
        "snippet": "void UserUpdatePhraseBegin(ChewingData *pgdata)\n{\n    sqlite3_exec(pgdata->static_data.db, \"BEGIN\", 0, 0, 0);\n}",
        "begin_line": 182,
        "end_line": 185,
        "is_bug": false
    },
    {
        "name": "src.userphrase-sql.UserUpdatePhraseEnd#333",
        "src_path": "src/userphrase-sql.c",
        "class_name": "src.userphrase-sql",
        "signature": "src.userphrase-sql.UserUpdatePhraseEnd(ChewingData *pgdata)",
        "snippet": "void UserUpdatePhraseEnd(ChewingData *pgdata)\n{\n    sqlite3_exec(pgdata->static_data.db, \"END\", 0, 0, 0);\n}",
        "begin_line": 333,
        "end_line": 336,
        "is_bug": false
    },
    {
        "name": "src.userphrase.GetDefaultChewingUserPath#130",
        "src_path": "src/userphrase.c",
        "class_name": "src.userphrase",
        "signature": "src.userphrase.GetDefaultChewingUserPath(ChewingData *pgdata)",
        "snippet": "char *GetDefaultChewingUserPath(ChewingData *pgdata)\n{\n    char *tmp;\n    char *path;\n    int ret;\n\n    assert(pgdata);\n\n    tmp = getenv(\"CHEWING_USER_PATH\");\n    if (tmp) {\n        ret = asprintf(&path, \"%s\", tmp);\n        if (ret == -1) {\n            LOG_ERROR(\"asprintf returns %d\", ret);\n            exit(-1);\n        }\n        return path;\n    }\n\n    tmp = getenv(\"HOME\");\n    if (!tmp) {\n        tmp = PLAT_TMPDIR;\n    }\n\n    ret = asprintf(&path, \"%s/%s\", tmp, USERPHRASE_DIR);\n    if (ret == -1) {\n        LOG_ERROR(\"asprintf returns %d\", ret);\n        exit(-1);\n    }\n\n    PLAT_MKDIR(path);\n\n    return path;\n}",
        "begin_line": 130,
        "end_line": 162,
        "is_bug": false
    },
    {
        "name": "src.userphrase.GetDefaultUserPhrasePath#164",
        "src_path": "src/userphrase.c",
        "class_name": "src.userphrase",
        "signature": "src.userphrase.GetDefaultUserPhrasePath(ChewingData *pgdata)",
        "snippet": "char *GetDefaultUserPhrasePath(ChewingData *pgdata)\n{\n    char *tmp;\n    char *path;\n    int ret;\n\n    assert(pgdata);\n\n    tmp = GetDefaultChewingUserPath(pgdata);\n    if (tmp && access(tmp, W_OK) == 0) {\n        ret = asprintf(&path, \"%s/%s\", tmp, DB_NAME);\n        if (ret == -1) {\n            free(tmp);\n            LOG_ERROR(\"asprintf returns %d\", ret);\n            exit(-1);\n        }\n        free(tmp);\n        return path;\n    }\n\n    return NULL;\n}",
        "begin_line": 164,
        "end_line": 185,
        "is_bug": false
    }
]