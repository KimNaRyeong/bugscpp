[
    {
        "name": "md2html.cmdline.readoptions#16",
        "src_path": "md2html/cmdline.c",
        "class_name": "md2html.cmdline",
        "signature": "md2html.cmdline.readoptions(option const* list, int argc, char **argv, int (*callback)(int, char const*, void*), void *data)",
        "snippet": "int readoptions(option const* list, int argc, char **argv,\n\t\tint (*callback)(int, char const*, void*), void *data)\n{\n    char\t\targstring[] = \"--\";\n    option const       *opt;\n    char const\t       *val;\n    char const\t       *p;\n    int\t\t\tstop = 0;\n    int\t\t\targi, len, r;\n\n    if (!list || !callback)\n\treturn -1;\n\n    for (argi = 1 ; argi < argc ; ++argi)\n    {\n\t/* First, check for \"--\", which forces all remaining arguments\n\t * to be treated as non-options.\n\t */\n\tif (!stop && argv[argi][0] == '-' && argv[argi][1] == '-'\n\t\t\t\t\t  && argv[argi][2] == '\\0') {\n\t    stop = 1;\n\t    continue;\n\t}\n\n\t/* Arguments that do not begin with '-' (or are only \"-\") are\n\t * not options.\n\t */\n\tif (stop || argv[argi][0] != '-' || argv[argi][1] == '\\0') {\n\t    docallback(0, argv[argi]);\n\t    continue;\n\t}\n\n\tif (argv[argi][1] == '-')\n\t{\n\t    /* Arguments that begin with a double-dash are long\n\t     * options.\n\t     */\n\t    p = argv[argi] + 2;\n\t    val = strchr(p, '=');\n\t    if (val)\n\t\tlen = val++ - p;\n\t    else\n\t\tlen = strlen(p);\n\n\t    /* Is it on the list of valid options? If so, does it\n\t     * expect a parameter?\n\t     */\n\t    for (opt = list ; opt->optval ; ++opt)\n\t\tif (opt->name && !strncmp(p, opt->name, len)\n\t\t\t      && !opt->name[len])\n\t\t    break;\n\t    if (!opt->optval) {\n\t\tdocallback('?', argv[argi]);\n\t    } else if (!val && opt->arg == 1) {\n\t\tdocallback(':', argv[argi]);\n\t    } else if (val && opt->arg == 0) {\n\t\tdocallback('=', argv[argi]);\n\t    } else {\n\t\tdocallback(opt->optval, val);\n\t    }\n\t}\n\telse\n\t{\n\t    /* Arguments that begin with a single dash contain one or\n\t     * more short options. Each character in the argument is\n\t     * examined in turn, unless a parameter consumes the rest\n\t     * of the argument (or possibly even the following\n\t     * argument).\n\t     */\n\t    for (p = argv[argi] + 1 ; *p ; ++p) {\n\t\tfor (opt = list ; opt->optval ; ++opt)\n\t\t    if (opt->chname == *p)\n\t\t\tbreak;\n\t\tif (!opt->optval) {\n\t\t    argstring[1] = *p;\n\t\t    docallback('?', argstring);\n\t\t    continue;\n\t\t} else if (opt->arg == 0) {\n\t\t    docallback(opt->optval, NULL);\n\t\t    continue;\n\t\t} else if (p[1]) {\n\t\t    docallback(opt->optval, p + 1);\n\t\t    break;\n\t\t} else if (argi + 1 < argc && strcmp(argv[argi + 1], \"--\")) {\n\t\t    ++argi;\n\t\t    docallback(opt->optval, argv[argi]);\n\t\t    break;\n\t\t} else if (opt->arg == 2) {\n\t\t    docallback(opt->optval, NULL);\n\t\t    continue;\n\t\t} else {\n\t\t    argstring[1] = *p;\n\t\t    docallback(':', argstring);\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n    return 0;\n}",
        "begin_line": 16,
        "end_line": 115,
        "is_bug": false
    },
    {
        "name": "md2html.md2html.main#327",
        "src_path": "md2html/md2html.c",
        "class_name": "md2html.md2html",
        "signature": "md2html.md2html.main(int argc, char** argv)",
        "snippet": "int\nmain(int argc, char** argv)\n{\n    FILE* in = stdin;\n    FILE* out = stdout;\n    int ret = 0;\n\n    if(readoptions(cmdline_options, argc, argv, cmdline_callback, NULL) < 0) {\n        usage();\n        exit(1);\n    }\n\n    if(input_path != NULL && strcmp(input_path, \"-\") != 0) {\n        in = fopen(input_path, \"rb\");\n        if(in == NULL) {\n            fprintf(stderr, \"Cannot open %s.\\n\", input_path);\n            exit(1);\n        }\n    }\n    if(output_path != NULL && strcmp(output_path, \"-\") != 0) {\n        out = fopen(output_path, \"wt\");\n        if(out == NULL) {\n            fprintf(stderr, \"Cannot open %s.\\n\", input_path);\n            exit(1);\n        }\n    }\n\n    ret = process_file(in, out);\n    if(in != stdin)\n        fclose(in);\n    if(out != stdout)\n        fclose(out);\n\n    return ret;\n}",
        "begin_line": 327,
        "end_line": 361,
        "is_bug": false
    },
    {
        "name": "md2html.md2html.membuf_init#59",
        "src_path": "md2html/md2html.c",
        "class_name": "md2html.md2html",
        "signature": "md2html.md2html.membuf_init(struct membuffer* buf, MD_SIZE new_asize)",
        "snippet": "static void\nmembuf_init(struct membuffer* buf, MD_SIZE new_asize)\n{\n    buf->size = 0;\n    buf->asize = new_asize;\n    buf->data = malloc(buf->asize);\n    if(buf->data == NULL) {\n        fprintf(stderr, \"membuf_init: malloc() failed.\\n\");\n        exit(1);\n    }\n}",
        "begin_line": 59,
        "end_line": 69,
        "is_bug": false
    },
    {
        "name": "md2html.md2html.process_file#109",
        "src_path": "md2html/md2html.c",
        "class_name": "md2html.md2html",
        "signature": "md2html.md2html.process_file(FILE* in, FILE* out)",
        "snippet": "static int\nprocess_file(FILE* in, FILE* out)\n{\n    MD_SIZE n;\n    struct membuffer buf_in = {0};\n    struct membuffer buf_out = {0};\n    int ret = -1;\n    clock_t t0, t1;\n\n    membuf_init(&buf_in, 32 * 1024);\n\n    /* Read the input file into a buffer. */\n    while(1) {\n        if(buf_in.size >= buf_in.asize)\n            membuf_grow(&buf_in, 2 * buf_in.asize);\n\n        n = fread(buf_in.data + buf_in.size, 1, buf_in.asize - buf_in.size, in);\n        if(n == 0)\n            break;\n        buf_in.size += n;\n    }\n\n    /* Input size is good estimation of output size. Add some more reserve to\n     * deal with the HTML header/footer and tags. */\n    membuf_init(&buf_out, buf_in.size + buf_in.size/8 + 64);\n\n    /* Parse the document. This shall call our callbacks provided via the\n     * md_renderer_t structure. */\n    t0 = clock();\n\n    ret = md_render_html(buf_in.data, buf_in.size, process_output,\n                (void*) &buf_out, parser_flags, renderer_flags);\n\n    t1 = clock();\n    if(ret != 0) {\n        fprintf(stderr, \"Parsing failed.\\n\");\n        goto out;\n    }\n\n    /* Write down the document in the HTML format. */\n    if(want_fullhtml) {\n        fprintf(out, \"<html>\\n\");\n        fprintf(out, \"<head>\\n\");\n        fprintf(out, \"<title></title>\\n\");\n        fprintf(out, \"<meta name=\\\"generator\\\" content=\\\"md2html\\\">\\n\");\n        fprintf(out, \"</head>\\n\");\n        fprintf(out, \"<body>\\n\");\n    }\n\n    fwrite(buf_out.data, 1, buf_out.size, out);\n\n    if(want_fullhtml) {\n        fprintf(out, \"</body>\\n\");\n        fprintf(out, \"</html>\\n\");\n    }\n\n    if(want_stat) {\n        if(t0 != (clock_t)-1  &&  t1 != (clock_t)-1) {\n            double elapsed = (double)(t1 - t0) / CLOCKS_PER_SEC;\n            if (elapsed < 1)\n                fprintf(stderr, \"Time spent on parsing: %7.2f ms.\\n\", elapsed*1e3);\n            else\n                fprintf(stderr, \"Time spent on parsing: %6.3f s.\\n\", elapsed);\n        }\n    }\n\n    /* Success if we have reached here. */\n    ret = 0;\n\nout:\n    membuf_fini(&buf_in);\n    membuf_fini(&buf_out);\n\n    return ret;\n}",
        "begin_line": 109,
        "end_line": 183,
        "is_bug": false
    },
    {
        "name": "md2html.render_html.enter_block_callback#356",
        "src_path": "md2html/render_html.c",
        "class_name": "md2html.render_html",
        "signature": "md2html.render_html.enter_block_callback(MD_BLOCKTYPE type, void* detail, void* userdata)",
        "snippet": "static int\nenter_block_callback(MD_BLOCKTYPE type, void* detail, void* userdata)\n{\n    static const MD_CHAR* head[6] = { \"<h1>\", \"<h2>\", \"<h3>\", \"<h4>\", \"<h5>\", \"<h6>\" };\n    MD_RENDER_HTML* r = (MD_RENDER_HTML*) userdata;\n\n    switch(type) {\n        case MD_BLOCK_DOC:      /* noop */ break;\n        case MD_BLOCK_QUOTE:    RENDER_LITERAL(r, \"<blockquote>\\n\"); break;\n        case MD_BLOCK_UL:       RENDER_LITERAL(r, \"<ul>\\n\"); break;\n        case MD_BLOCK_OL:       render_open_ol_block(r, (const MD_BLOCK_OL_DETAIL*)detail); break;\n        case MD_BLOCK_LI:       render_open_li_block(r, (const MD_BLOCK_LI_DETAIL*)detail); break;\n        case MD_BLOCK_HR:       RENDER_LITERAL(r, \"<hr>\\n\"); break;\n        case MD_BLOCK_H:        RENDER_LITERAL(r, head[((MD_BLOCK_H_DETAIL*)detail)->level - 1]); break;\n        case MD_BLOCK_CODE:     render_open_code_block(r, (const MD_BLOCK_CODE_DETAIL*) detail); break;\n        case MD_BLOCK_HTML:     /* noop */ break;\n        case MD_BLOCK_P:        RENDER_LITERAL(r, \"<p>\"); break;\n        case MD_BLOCK_TABLE:    RENDER_LITERAL(r, \"<table>\\n\"); break;\n        case MD_BLOCK_THEAD:    RENDER_LITERAL(r, \"<thead>\\n\"); break;\n        case MD_BLOCK_TBODY:    RENDER_LITERAL(r, \"<tbody>\\n\"); break;\n        case MD_BLOCK_TR:       RENDER_LITERAL(r, \"<tr>\\n\"); break;\n        case MD_BLOCK_TH:       render_open_td_block(r, \"th\", (MD_BLOCK_TD_DETAIL*)detail); break;\n        case MD_BLOCK_TD:       render_open_td_block(r, \"td\", (MD_BLOCK_TD_DETAIL*)detail); break;\n    }\n\n    return 0;\n}",
        "begin_line": 356,
        "end_line": 382,
        "is_bug": false
    },
    {
        "name": "md2html.render_html.md_render_html#485",
        "src_path": "md2html/render_html.c",
        "class_name": "md2html.render_html",
        "signature": "md2html.render_html.md_render_html(const MD_CHAR* input, MD_SIZE input_size, void (*process_output)(const MD_CHAR*, MD_SIZE, void*), void* userdata, unsigned parser_flags, unsigned renderer_flags)",
        "snippet": "int\nmd_render_html(const MD_CHAR* input, MD_SIZE input_size,\n               void (*process_output)(const MD_CHAR*, MD_SIZE, void*),\n               void* userdata, unsigned parser_flags, unsigned renderer_flags)\n{\n    MD_RENDER_HTML render = { process_output, userdata, renderer_flags, 0 };\n\n    MD_PARSER parser = {\n        0,\n        parser_flags,\n        enter_block_callback,\n        leave_block_callback,\n        enter_span_callback,\n        leave_span_callback,\n        text_callback,\n        debug_log_callback,\n        NULL\n    };\n\n    return md_parse(input, input_size, &parser, (void*) &render);\n}",
        "begin_line": 485,
        "end_line": 505,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_add_line_into_current_block#4797",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_add_line_into_current_block(MD_CTX* ctx, const MD_LINE_ANALYSIS* analysis)",
        "snippet": "static int\nmd_add_line_into_current_block(MD_CTX* ctx, const MD_LINE_ANALYSIS* analysis)\n{\n    MD_ASSERT(ctx->current_block != NULL);\n\n    if(ctx->current_block->type == MD_BLOCK_CODE || ctx->current_block->type == MD_BLOCK_HTML) {\n        MD_VERBATIMLINE* line;\n\n        line = (MD_VERBATIMLINE*) md_push_block_bytes(ctx, sizeof(MD_VERBATIMLINE));\n        if(line == NULL)\n            return -1;\n\n        line->indent = analysis->indent;\n        line->beg = analysis->beg;\n        line->end = analysis->end;\n    } else {\n        MD_LINE* line;\n\n        line = (MD_LINE*) md_push_block_bytes(ctx, sizeof(MD_LINE));\n        if(line == NULL)\n            return -1;\n\n        line->beg = analysis->beg;\n        line->end = analysis->end;\n    }\n    ctx->current_block->n_lines++;\n\n    return 0;\n}",
        "begin_line": 4797,
        "end_line": 4825,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_analyze_line#5448",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_analyze_line(MD_CTX* ctx, OFF beg, OFF* p_end, const MD_LINE_ANALYSIS* pivot_line, MD_LINE_ANALYSIS* line)",
        "snippet": "static int\nmd_analyze_line(MD_CTX* ctx, OFF beg, OFF* p_end,\n                const MD_LINE_ANALYSIS* pivot_line, MD_LINE_ANALYSIS* line)\n{\n    unsigned total_indent = 0;\n    int n_parents = 0;\n    int n_brothers = 0;\n    int n_children = 0;\n    MD_CONTAINER container = { 0 };\n    int prev_line_has_list_loosening_effect = ctx->last_line_has_list_loosening_effect;\n    OFF off = beg;\n    OFF hr_killer = 0;\n    int ret = 0;\n\n    line->indent = md_line_indentation(ctx, total_indent, off, &off);\n    total_indent += line->indent;\n    line->beg = off;\n\n    /* Given the indentation and block quote marks '>', determine how many of\n     * the current containers are our parents. */\n    while(n_parents < ctx->n_containers) {\n        MD_CONTAINER* c = &ctx->containers[n_parents];\n\n        if(c->ch == _T('>')  &&  line->indent < ctx->code_indent_offset  &&\n            off < ctx->size  &&  CH(off) == _T('>'))\n        {\n            /* Block quote mark. */\n            off++;\n            total_indent++;\n            line->indent = md_line_indentation(ctx, total_indent, off, &off);\n            total_indent += line->indent;\n\n            /* The optional 1st space after '>' is part of the block quote mark. */\n            if(line->indent > 0)\n                line->indent--;\n\n            line->beg = off;\n        } else if(c->ch != _T('>')  &&  line->indent >= c->contents_indent) {\n            /* List. */\n            line->indent -= c->contents_indent;\n        } else {\n            break;\n        }\n\n        n_parents++;\n    }\n\nredo:\n    /* Check whether we are fenced code continuation. */\n    if(pivot_line->type == MD_LINE_FENCEDCODE) {\n        line->beg = off;\n\n        /* We are another MD_LINE_FENCEDCODE unless we are closing fence\n         * which we transform into MD_LINE_BLANK. */\n        if(line->indent < ctx->code_indent_offset) {\n            if(md_is_closing_code_fence(ctx, CH(pivot_line->beg), off, &off)) {\n                line->type = MD_LINE_BLANK;\n                ctx->last_line_has_list_loosening_effect = FALSE;\n                goto done;\n            }\n        }\n\n        if(off >= ctx->size  ||  ISNEWLINE(off)) {\n            /* Blank line does not need any real indentation to be nested inside\n             * a list. */\n            if(n_brothers + n_children == 0) {\n                while(n_parents < ctx->n_containers  &&  ctx->containers[n_parents].ch != _T('>'))\n                    n_parents++;\n            }\n        }\n\n        /* Change indentation accordingly to the initial code fence. */\n        if(n_parents == ctx->n_containers) {\n            if(line->indent > pivot_line->indent)\n                line->indent -= pivot_line->indent;\n            else\n                line->indent = 0;\n\n            line->type = MD_LINE_FENCEDCODE;\n            goto done;\n        }\n    }\n\n    /* Check whether we are HTML block continuation. */\n    if(pivot_line->type == MD_LINE_HTML  &&  ctx->html_block_type > 0) {\n        int html_block_type;\n\n        html_block_type = md_is_html_block_end_condition(ctx, off, &off);\n        if(html_block_type > 0) {\n            MD_ASSERT(html_block_type == ctx->html_block_type);\n\n            /* Make sure this is the last line of the block. */\n            ctx->html_block_type = 0;\n\n            /* Some end conditions serve as blank lines at the same time. */\n            if(html_block_type == 6 || html_block_type == 7) {\n                line->type = MD_LINE_BLANK;\n                line->indent = 0;\n                goto done;\n            }\n        }\n\n        if(n_parents == ctx->n_containers) {\n            line->type = MD_LINE_HTML;\n            goto done;\n        }\n    }\n\n    /* Check for blank line. */\n    if(off >= ctx->size  ||  ISNEWLINE(off)) {\n        /* Blank line does not need any real indentation to be nested inside\n         * a list. */\n        if(n_brothers + n_children == 0) {\n            while(n_parents < ctx->n_containers  &&  ctx->containers[n_parents].ch != _T('>'))\n                n_parents++;\n        }\n\n        if(pivot_line->type == MD_LINE_INDENTEDCODE  &&  n_parents == ctx->n_containers) {\n            line->type = MD_LINE_INDENTEDCODE;\n            if(line->indent > ctx->code_indent_offset)\n                line->indent -= ctx->code_indent_offset;\n            else\n                line->indent = 0;\n            ctx->last_line_has_list_loosening_effect = FALSE;\n        } else {\n            line->type = MD_LINE_BLANK;\n            ctx->last_line_has_list_loosening_effect = (n_parents > 0  &&\n                    n_brothers + n_children == 0  &&\n                    ctx->containers[n_parents-1].ch != _T('>'));\n\n#if 1\n            /* See https://github.com/mity/md4c/issues/6\n             *\n             * This ugly checking tests we are in (yet empty) list item but not\n             * its very first line (with the list item mark).\n             *\n             * If we are such blank line, then any following non-blank line\n             * which would be part of this list item actually ends the list\n             * because \"a list item can begin with at most one blank line.\"\n             */\n            if(n_parents > 0  &&  ctx->containers[n_parents-1].ch != _T('>')  &&\n               n_brothers + n_children == 0  &&  ctx->current_block == NULL  &&\n               ctx->n_block_bytes > sizeof(MD_BLOCK))\n            {\n                MD_BLOCK* top_block = (MD_BLOCK*) ((char*)ctx->block_bytes + ctx->n_block_bytes - sizeof(MD_BLOCK));\n                if(top_block->type == MD_BLOCK_LI)\n                    ctx->last_list_item_starts_with_two_blank_lines = TRUE;\n            }\n#endif\n        }\n        goto done_on_eol;\n    } else {\n#if 1\n        /* This is 2nd half of the hack. If the flag is set (that is there\n         * were 2nd blank line at the start of the list item) and we would also\n         * belonging to such list item, then interrupt the list. */\n        ctx->last_line_has_list_loosening_effect = FALSE;\n        if(ctx->last_list_item_starts_with_two_blank_lines) {\n            if(n_parents > 0  &&  ctx->containers[n_parents-1].ch != _T('>')  &&\n               n_brothers + n_children == 0  &&  ctx->current_block == NULL  &&\n               ctx->n_block_bytes > sizeof(MD_BLOCK))\n            {\n                MD_BLOCK* top_block = (MD_BLOCK*) ((char*)ctx->block_bytes + ctx->n_block_bytes - sizeof(MD_BLOCK));\n                if(top_block->type == MD_BLOCK_LI)\n                    n_parents--;\n            }\n\n            ctx->last_list_item_starts_with_two_blank_lines = FALSE;\n        }\n#endif\n    }\n\n    /* Check whether we are Setext underline. */\n    if(line->indent < ctx->code_indent_offset  &&  pivot_line->type == MD_LINE_TEXT\n        &&  (CH(off) == _T('=') || CH(off) == _T('-'))\n        &&  (n_parents == ctx->n_containers))\n    {\n        unsigned level;\n\n        if(md_is_setext_underline(ctx, off, &off, &level)) {\n            line->type = MD_LINE_SETEXTUNDERLINE;\n            line->data = level;\n            goto done;\n        }\n    }\n\n    /* Check for thematic break line. */\n    if(line->indent < ctx->code_indent_offset  &&  ISANYOF(off, _T(\"-_*\"))  &&  off >= hr_killer) {\n        if(md_is_hr_line(ctx, off, &off, &hr_killer)) {\n            line->type = MD_LINE_HR;\n            goto done;\n        }\n    }\n\n    /* Check for \"brother\" container. I.e. whether we are another list item\n     * in already started list. */\n    if(n_parents < ctx->n_containers  &&  n_brothers + n_children == 0) {\n        OFF tmp;\n\n        if(md_is_container_mark(ctx, line->indent, off, &tmp, &container)  &&\n           md_is_container_compatible(&ctx->containers[n_parents], &container))\n        {\n            pivot_line = &md_dummy_blank_line;\n\n            off = tmp;\n\n            total_indent += container.contents_indent - container.mark_indent;\n            line->indent = md_line_indentation(ctx, total_indent, off, &off);\n            total_indent += line->indent;\n            line->beg = off;\n\n            /* Some of the following whitespace actually still belongs to the mark. */\n            if(off >= ctx->size || ISNEWLINE(off)) {\n                container.contents_indent++;\n            } else if(line->indent <= ctx->code_indent_offset) {\n                container.contents_indent += line->indent;\n                line->indent = 0;\n            } else {\n                container.contents_indent += 1;\n                line->indent--;\n            }\n\n            ctx->containers[n_parents].mark_indent = container.mark_indent;\n            ctx->containers[n_parents].contents_indent = container.contents_indent;\n\n            n_brothers++;\n            goto redo;\n        }\n    }\n\n    /* Check for indented code.\n     * Note indented code block cannot interrupt a paragraph. */\n    if(line->indent >= ctx->code_indent_offset  &&\n        (pivot_line->type == MD_LINE_BLANK || pivot_line->type == MD_LINE_INDENTEDCODE))\n    {\n        line->type = MD_LINE_INDENTEDCODE;\n        MD_ASSERT(line->indent >= ctx->code_indent_offset);\n        line->indent -= ctx->code_indent_offset;\n        line->data = 0;\n        goto done;\n    }\n\n    /* Check for start of a new container block. */\n    if(line->indent < ctx->code_indent_offset  &&\n       md_is_container_mark(ctx, line->indent, off, &off, &container))\n    {\n        if(pivot_line->type == MD_LINE_TEXT  &&  n_parents == ctx->n_containers  &&\n                    (off >= ctx->size || ISNEWLINE(off)))\n        {\n            /* Noop. List mark followed by a blank line cannot interrupt a paragraph. */\n        } else if(pivot_line->type == MD_LINE_TEXT  &&  n_parents == ctx->n_containers  &&\n                    (container.ch == _T('.') || container.ch == _T(')'))  &&  container.start != 1)\n        {\n            /* Noop. Ordered list cannot interrupt a paragraph unless the start index is 1. */\n        } else {\n            total_indent += container.contents_indent - container.mark_indent;\n            line->indent = md_line_indentation(ctx, total_indent, off, &off);\n            total_indent += line->indent;\n\n            line->beg = off;\n            line->data = container.ch;\n\n            /* Some of the following whitespace actually still belongs to the mark. */\n            if(off >= ctx->size || ISNEWLINE(off)) {\n                container.contents_indent++;\n            } else if(line->indent <= ctx->code_indent_offset) {\n                container.contents_indent += line->indent;\n                line->indent = 0;\n            } else {\n                container.contents_indent += 1;\n                line->indent--;\n            }\n\n            if(n_brothers + n_children == 0)\n                pivot_line = &md_dummy_blank_line;\n\n            if(n_children == 0)\n                MD_CHECK(md_leave_child_containers(ctx, n_parents + n_brothers));\n\n            n_children++;\n            MD_CHECK(md_push_container(ctx, &container));\n            goto redo;\n        }\n    }\n\n    /* Check whether we are table continuation. */\n    if(pivot_line->type == MD_LINE_TABLE  &&  md_is_table_row(ctx, off, &off)  &&\n       n_parents == ctx->n_containers)\n    {\n        line->type = MD_LINE_TABLE;\n        goto done;\n    }\n\n    /* Check for ATX header. */\n    if(line->indent < ctx->code_indent_offset  &&  CH(off) == _T('#')) {\n        unsigned level;\n\n        if(md_is_atxheader_line(ctx, off, &line->beg, &off, &level)) {\n            line->type = MD_LINE_ATXHEADER;\n            line->data = level;\n            goto done;\n        }\n    }\n\n    /* Check whether we are starting code fence. */\n    if(CH(off) == _T('`') || CH(off) == _T('~')) {\n        if(md_is_opening_code_fence(ctx, off, &off)) {\n            line->type = MD_LINE_FENCEDCODE;\n            line->data = 1;\n            goto done;\n        }\n    }\n\n    /* Check for start of raw HTML block. */\n    if(CH(off) == _T('<')  &&  !(ctx->parser.flags & MD_FLAG_NOHTMLBLOCKS))\n    {\n        ctx->html_block_type = md_is_html_block_start_condition(ctx, off);\n\n        /* HTML block type 7 cannot interrupt paragraph. */\n        if(ctx->html_block_type == 7  &&  pivot_line->type == MD_LINE_TEXT)\n            ctx->html_block_type = 0;\n\n        if(ctx->html_block_type > 0) {\n            /* The line itself also may immediately close the block. */\n            if(md_is_html_block_end_condition(ctx, off, &off) == ctx->html_block_type) {\n                /* Make sure this is the last line of the block. */\n                ctx->html_block_type = 0;\n            }\n\n            line->type = MD_LINE_HTML;\n            goto done;\n        }\n    }\n\n    /* Check for table underline. */\n    if((ctx->parser.flags & MD_FLAG_TABLES)  &&  pivot_line->type == MD_LINE_TEXT  &&\n       (CH(off) == _T('|') || CH(off) == _T('-') || CH(off) == _T(':'))  &&\n       n_parents == ctx->n_containers)\n    {\n        unsigned col_count;\n\n        if(ctx->current_block != NULL  &&  ctx->current_block->n_lines == 1  &&\n            md_is_table_underline(ctx, off, &off, &col_count)  &&\n            md_is_table_row(ctx, pivot_line->beg, NULL))\n        {\n            line->data = col_count;\n            line->type = MD_LINE_TABLEUNDERLINE;\n            goto done;\n        }\n    }\n\n    /* By default, we are normal text line. */\n    line->type = MD_LINE_TEXT;\n    if(pivot_line->type == MD_LINE_TEXT  &&  n_brothers + n_children == 0) {\n        /* Lazy continuation. */\n        n_parents = ctx->n_containers;\n    }\n\n    /* Check for task mark. */\n    if((ctx->parser.flags & MD_FLAG_TASKLISTS)  &&  n_brothers + n_children > 0  &&\n       ISANYOF_(ctx->containers[ctx->n_containers-1].ch, _T(\"-+*.)\")))\n    {\n        OFF tmp = off;\n\n        while(tmp < ctx->size  &&  tmp < off + 3  &&  ISBLANK(tmp))\n            tmp++;\n        if(tmp + 2 < ctx->size  &&  CH(tmp) == _T('[')  &&\n           ISANYOF(tmp+1, _T(\"xX \"))  &&  CH(tmp+2) == _T(']')  &&\n           (tmp + 3 == ctx->size  ||  ISBLANK(tmp+3)  ||  ISNEWLINE(tmp+3)))\n        {\n            MD_CONTAINER* task_container = (n_children > 0 ? &ctx->containers[ctx->n_containers-1] : &container);\n            task_container->is_task = TRUE;\n            task_container->task_mark_off = tmp + 1;\n            off = tmp + 3;\n            while(ISWHITESPACE(off))\n                off++;\n            line->beg = off;\n        }\n    }\n\ndone:\n    /* Scan for end of the line.\n     *\n     * Note this is bottleneck of this function as we itereate over (almost)\n     * all line contents after some initial line indentation. To optimize, we\n     * try to eat multiple chars in every loop iteration.\n     *\n     * (Measured ~6% performance boost of md2html with this optimization for\n     * normal kind of input.)\n     */\n    while(off + 4 < ctx->size  &&  !ISNEWLINE(off+0)  &&  !ISNEWLINE(off+1)\n                               &&  !ISNEWLINE(off+2)  &&  !ISNEWLINE(off+3))\n        off += 4;\n    while(off < ctx->size  &&  !ISNEWLINE(off))\n        off++;\n\ndone_on_eol:\n    /* Set end of the line. */\n    line->end = off;\n\n    /* But for ATX header, we should exclude the optional trailing mark. */\n    if(line->type == MD_LINE_ATXHEADER) {\n        OFF tmp = line->end;\n        while(tmp > line->beg && CH(tmp-1) == _T(' '))\n            tmp--;\n        while(tmp > line->beg && CH(tmp-1) == _T('#'))\n            tmp--;\n        if(tmp == line->beg || CH(tmp-1) == _T(' ') || (ctx->parser.flags & MD_FLAG_PERMISSIVEATXHEADERS))\n            line->end = tmp;\n    }\n\n    /* Trim trailing spaces. */\n    if(line->type != MD_LINE_INDENTEDCODE  &&  line->type != MD_LINE_FENCEDCODE) {\n        while(line->end > line->beg && CH(line->end-1) == _T(' '))\n            line->end--;\n    }\n\n    /* Eat also the new line. */\n    if(off < ctx->size && CH(off) == _T('\\r'))\n        off++;\n    if(off < ctx->size && CH(off) == _T('\\n'))\n        off++;\n\n    *p_end = off;\n\n    /* If we belong to a list after seeing a blank line, the list is loose. */\n    if(prev_line_has_list_loosening_effect  &&  line->type != MD_LINE_BLANK  &&  n_parents + n_brothers > 0) {\n        MD_CONTAINER* c = &ctx->containers[n_parents + n_brothers - 1];\n        if(c->ch != _T('>')) {\n            MD_BLOCK* block = (MD_BLOCK*) (((char*)ctx->block_bytes) + c->block_byte_off);\n            block->flags |= MD_BLOCK_LOOSE_LIST;\n        }\n    }\n\n    /* Leave any containers we are not part of anymore. */\n    if(n_children == 0  &&  n_parents + n_brothers < ctx->n_containers)\n        MD_CHECK(md_leave_child_containers(ctx, n_parents + n_brothers));\n\n    /* Enter any container we found a mark for. */\n    if(n_brothers > 0) {\n        MD_ASSERT(n_brothers == 1);\n        MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI,\n                    ctx->containers[n_parents].task_mark_off,\n                    (ctx->containers[n_parents].is_task ? CH(ctx->containers[n_parents].task_mark_off) : 0),\n                    MD_BLOCK_CONTAINER_CLOSER));\n        MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI,\n                    container.task_mark_off,\n                    (container.is_task ? CH(container.task_mark_off) : 0),\n                    MD_BLOCK_CONTAINER_OPENER));\n        ctx->containers[n_parents].is_task = container.is_task;\n        ctx->containers[n_parents].task_mark_off = container.task_mark_off;\n    }\n\n    if(n_children > 0)\n        MD_CHECK(md_enter_child_containers(ctx, n_children, line->data));\n\nabort:\n    return ret;\n}",
        "begin_line": 5448,
        "end_line": 5906,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_build_mark_char_map#2655",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_build_mark_char_map(MD_CTX* ctx)",
        "snippet": "static void\nmd_build_mark_char_map(MD_CTX* ctx)\n{\n    memset(ctx->mark_char_map, 0, sizeof(ctx->mark_char_map));\n\n    ctx->mark_char_map['\\\\'] = 1;\n    ctx->mark_char_map['*'] = 1;\n    ctx->mark_char_map['_'] = 1;\n    ctx->mark_char_map['`'] = 1;\n    ctx->mark_char_map['&'] = 1;\n    ctx->mark_char_map[';'] = 1;\n    ctx->mark_char_map['<'] = 1;\n    ctx->mark_char_map['>'] = 1;\n    ctx->mark_char_map['['] = 1;\n    ctx->mark_char_map['!'] = 1;\n    ctx->mark_char_map[']'] = 1;\n    ctx->mark_char_map['\\0'] = 1;\n\n    if(ctx->parser.flags & MD_FLAG_STRIKETHROUGH)\n        ctx->mark_char_map['~'] = 1;\n\n    if(ctx->parser.flags & MD_FLAG_PERMISSIVEEMAILAUTOLINKS)\n        ctx->mark_char_map['@'] = 1;\n\n    if(ctx->parser.flags & MD_FLAG_PERMISSIVEURLAUTOLINKS)\n        ctx->mark_char_map[':'] = 1;\n\n    if(ctx->parser.flags & MD_FLAG_PERMISSIVEWWWAUTOLINKS)\n        ctx->mark_char_map['.'] = 1;\n\n    if(ctx->parser.flags & MD_FLAG_TABLES)\n        ctx->mark_char_map['|'] = 1;\n\n    if(ctx->parser.flags & MD_FLAG_COLLAPSEWHITESPACE) {\n        int i;\n\n        for(i = 0; i < sizeof(ctx->mark_char_map); i++) {\n            if(ISWHITESPACE_(i))\n                ctx->mark_char_map[i] = 1;\n        }\n    }\n}",
        "begin_line": 2655,
        "end_line": 2696,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_consume_link_reference_definitions#4709",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_consume_link_reference_definitions(MD_CTX* ctx)",
        "snippet": "static int\nmd_consume_link_reference_definitions(MD_CTX* ctx)\n{\n    MD_LINE* lines = (MD_LINE*) (ctx->current_block + 1);\n    int n_lines = ctx->current_block->n_lines;\n    int n = 0;\n\n    /* Compute how many lines at the start of the block form one or more\n     * reference definitions. */\n    while(n < n_lines) {\n        int n_link_ref_lines;\n\n        n_link_ref_lines = md_is_link_reference_definition(ctx,\n                                    lines + n, n_lines - n);\n        /* Not a reference definition? */\n        if(n_link_ref_lines == 0)\n            break;\n\n        /* We fail if it is the ref. def. but it could not be stored due\n         * a memory allocation error. */\n        if(n_link_ref_lines < 0)\n            return -1;\n\n        n += n_link_ref_lines;\n    }\n\n    /* If there was at least one reference definition, we need to remove\n     * its lines from the block, or perhaps even the whole block. */\n    if(n > 0) {\n        if(n == n_lines) {\n            /* Remove complete block. */\n            ctx->n_block_bytes -= n * sizeof(MD_LINE);\n            ctx->n_block_bytes -= sizeof(MD_BLOCK);\n        } else {\n            /* Remove just some initial lines from the block. */\n            memmove(lines, lines + n, (n_lines - n) * sizeof(MD_LINE));\n            ctx->current_block->n_lines -= n;\n            ctx->n_block_bytes -= n * sizeof(MD_LINE);\n        }\n    }\n\n    return 0;\n}",
        "begin_line": 4709,
        "end_line": 4751,
        "is_bug": true
    },
    {
        "name": "md4c.md4c.md_end_current_block#4753",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_end_current_block(MD_CTX* ctx)",
        "snippet": "static int\nmd_end_current_block(MD_CTX* ctx)\n{\n    int ret = 0;\n\n    if(ctx->current_block == NULL)\n        return ret;\n\n    /* Check whether there is a reference definition. (We do this here instead\n     * of in md_analyze_line() because reference definition can take multiple\n     * lines.) */\n    if(ctx->current_block->type == MD_BLOCK_P  ||\n       (ctx->current_block->type == MD_BLOCK_H  &&  (ctx->current_block->flags & MD_BLOCK_SETEXT_HEADER)))\n    {\n        MD_LINE* lines = (MD_LINE*) (ctx->current_block + 1);\n        if(CH(lines[0].beg) == _T('[')) {\n            MD_CHECK(md_consume_link_reference_definitions(ctx));\n            if(ctx->current_block == NULL)\n                return ret;\n        }\n    }\n\n    if(ctx->current_block->type == MD_BLOCK_H  &&  (ctx->current_block->flags & MD_BLOCK_SETEXT_HEADER)) {\n        int n_lines = ctx->current_block->n_lines;\n\n        if(n_lines > 1) {\n            /* Get rid of the underline. */\n            ctx->current_block->n_lines--;\n            ctx->n_block_bytes -= sizeof(MD_LINE);\n        } else {\n            /* Only the underline has left after eating the ref. defs.\n             * Keep the line as beginning of a new ordinary paragraph. */\n            ctx->current_block->type = MD_BLOCK_P;\n            return 0;\n        }\n    }\n\n    /* Mark we are not building any block anymore. */\n    ctx->current_block = NULL;\n\nabort:\n    return ret;\n}",
        "begin_line": 4753,
        "end_line": 4795,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_is_container_mark#5372",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_is_container_mark(MD_CTX* ctx, unsigned indent, OFF beg, OFF* p_end, MD_CONTAINER* p_container)",
        "snippet": "static int\nmd_is_container_mark(MD_CTX* ctx, unsigned indent, OFF beg, OFF* p_end, MD_CONTAINER* p_container)\n{\n    OFF off = beg;\n    OFF max_end;\n\n    if(indent >= ctx->code_indent_offset)\n        return FALSE;\n\n    /* Check for block quote mark. */\n    if(off < ctx->size  &&  CH(off) == _T('>')) {\n        off++;\n        p_container->ch = _T('>');\n        p_container->is_loose = FALSE;\n        p_container->is_task = FALSE;\n        p_container->mark_indent = indent;\n        p_container->contents_indent = indent + 1;\n        *p_end = off;\n        return TRUE;\n    }\n\n    /* Check for list item bullet mark. */\n    if(off+1 < ctx->size  &&  ISANYOF(off, _T(\"-+*\"))  &&  (ISBLANK(off+1) || ISNEWLINE(off+1))) {\n        p_container->ch = CH(off);\n        p_container->is_loose = FALSE;\n        p_container->is_task = FALSE;\n        p_container->mark_indent = indent;\n        p_container->contents_indent = indent + 1;\n        *p_end = off + 1;\n        return TRUE;\n    }\n\n    /* Check for ordered list item marks. */\n    max_end = off + 9;\n    if(max_end > ctx->size)\n        max_end = ctx->size;\n    p_container->start = 0;\n    while(off < max_end  &&  ISDIGIT(off)) {\n        p_container->start = p_container->start * 10 + CH(off) - _T('0');\n        off++;\n    }\n    if(off+1 < ctx->size  &&  (CH(off) == _T('.') || CH(off) == _T(')'))   &&  (ISBLANK(off+1) || ISNEWLINE(off+1))) {\n        p_container->ch = CH(off);\n        p_container->is_loose = FALSE;\n        p_container->is_task = FALSE;\n        p_container->mark_indent = indent;\n        p_container->contents_indent = indent + off - beg + 1;\n        *p_end = off + 1;\n        return TRUE;\n    }\n\n    return FALSE;\n}",
        "begin_line": 5372,
        "end_line": 5424,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_is_link_destination#1962",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_is_link_destination(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end, OFF* p_contents_beg, OFF* p_contents_end)",
        "snippet": "static inline int\nmd_is_link_destination(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end,\n                       OFF* p_contents_beg, OFF* p_contents_end)\n{\n    if(CH(beg) == _T('<'))\n        return md_is_link_destination_A(ctx, beg, max_end, p_end, p_contents_beg, p_contents_end);\n    else\n        return md_is_link_destination_B(ctx, beg, max_end, p_end, p_contents_beg, p_contents_end);\n}",
        "begin_line": 1962,
        "end_line": 1970,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_is_link_destination_B#1920",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_is_link_destination_B(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end, OFF* p_contents_beg, OFF* p_contents_end)",
        "snippet": "static int\nmd_is_link_destination_B(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end,\n                         OFF* p_contents_beg, OFF* p_contents_end)\n{\n    OFF off = beg;\n    int parenthesis_level = 0;\n\n    while(off < max_end) {\n        if(CH(off) == _T('\\\\')  &&  off+1 < max_end  &&  ISPUNCT(off+1)) {\n            off += 2;\n            continue;\n        }\n\n        if(ISWHITESPACE(off) || ISCNTRL(off))\n            break;\n\n        /* Link destination may include balanced pairs of unescaped '(' ')'.\n         * Note we limit the maximal nesting level by 32 to protect us from\n         * https://github.com/jgm/cmark/issues/214 */\n        if(CH(off) == _T('(')) {\n            parenthesis_level++;\n            if(parenthesis_level > 32)\n                return FALSE;\n        } else if(CH(off) == _T(')')) {\n            if(parenthesis_level == 0)\n                break;\n            parenthesis_level--;\n        }\n\n        off++;\n    }\n\n    if(parenthesis_level != 0  ||  off == beg)\n        return FALSE;\n\n    /* Success. */\n    *p_contents_beg = beg;\n    *p_contents_end = off;\n    *p_end = off;\n    return TRUE;\n}",
        "begin_line": 1920,
        "end_line": 1960,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_is_link_label#1815",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_is_link_label(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF* p_end, int* p_beg_line_index, int* p_end_line_index, OFF* p_contents_beg, OFF* p_contents_end)",
        "snippet": "static int\nmd_is_link_label(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg,\n                 OFF* p_end, int* p_beg_line_index, int* p_end_line_index,\n                 OFF* p_contents_beg, OFF* p_contents_end)\n{\n    OFF off = beg;\n    OFF contents_beg = 0;\n    OFF contents_end = 0;\n    int line_index = 0;\n    int len = 0;\n\n    if(CH(off) != _T('['))\n        return FALSE;\n    off++;\n\n    while(1) {\n        OFF line_end = lines[line_index].end;\n\n        while(off < line_end) {\n            if(CH(off) == _T('\\\\')  &&  off+1 < ctx->size  &&  (ISPUNCT(off+1) || ISNEWLINE(off+1))) {\n                if(contents_end == 0) {\n                    contents_beg = off;\n                    *p_beg_line_index = line_index;\n                }\n                contents_end = off + 2;\n                off += 2;\n            } else if(CH(off) == _T('[')) {\n                return FALSE;\n            } else if(CH(off) == _T(']')) {\n                if(contents_beg < contents_end) {\n                    /* Success. */\n                    *p_contents_beg = contents_beg;\n                    *p_contents_end = contents_end;\n                    *p_end = off+1;\n                    *p_end_line_index = line_index;\n                    return TRUE;\n                } else {\n                    /* Link label must have some non-whitespace contents. */\n                    return FALSE;\n                }\n            } else {\n                int codepoint;\n                SZ char_size;\n\n                codepoint = md_decode_unicode(ctx->text, off, ctx->size, &char_size);\n                if(!ISUNICODEWHITESPACE_(codepoint)) {\n                    if(contents_end == 0) {\n                        contents_beg = off;\n                        *p_beg_line_index = line_index;\n                    }\n                    contents_end = off + char_size;\n                }\n\n                off += char_size;\n            }\n\n            len++;\n            if(len > 999)\n                return FALSE;\n        }\n\n        line_index++;\n        len++;\n        if(line_index < n_lines)\n            off = lines[line_index].beg;\n        else\n            break;\n    }\n\n    return FALSE;\n}",
        "begin_line": 1815,
        "end_line": 1885,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_is_link_reference_definition#2040",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_is_link_reference_definition(MD_CTX* ctx, const MD_LINE* lines, int n_lines)",
        "snippet": "static int\nmd_is_link_reference_definition(MD_CTX* ctx, const MD_LINE* lines, int n_lines)\n{\n    OFF label_contents_beg;\n    OFF label_contents_end;\n    int label_contents_line_index = -1;\n    int label_is_multiline;\n    CHAR* label;\n    SZ label_size;\n    int label_needs_free = FALSE;\n    OFF dest_contents_beg;\n    OFF dest_contents_end;\n    OFF title_contents_beg;\n    OFF title_contents_end;\n    int title_contents_line_index;\n    int title_is_multiline;\n    OFF off;\n    int line_index = 0;\n    int tmp_line_index;\n    MD_REF_DEF* def;\n    int ret;\n\n    /* Link label. */\n    if(!md_is_link_label(ctx, lines, n_lines, lines[0].beg,\n                &off, &label_contents_line_index, &line_index,\n                &label_contents_beg, &label_contents_end))\n        return FALSE;\n    label_is_multiline = (label_contents_line_index != line_index);\n\n    /* Colon. */\n    if(off >= lines[line_index].end  ||  CH(off) != _T(':'))\n        return FALSE;\n    off++;\n\n    /* Optional white space with up to one line break. */\n    while(off < lines[line_index].end  &&  ISWHITESPACE(off))\n        off++;\n    if(off >= lines[line_index].end) {\n        line_index++;\n        if(line_index >= n_lines)\n            return FALSE;\n        off = lines[line_index].beg;\n    }\n\n    /* Link destination. */\n    if(!md_is_link_destination(ctx, off, lines[line_index].end,\n                &off, &dest_contents_beg, &dest_contents_end))\n        return FALSE;\n\n    /* (Optional) title. Note we interpret it as an title only if nothing\n     * more follows on its last line. */\n    if(md_is_link_title(ctx, lines + line_index, n_lines - line_index, off,\n                &off, &title_contents_line_index, &tmp_line_index,\n                &title_contents_beg, &title_contents_end)\n        &&  off >= lines[line_index + tmp_line_index].end)\n    {\n        title_is_multiline = (tmp_line_index != title_contents_line_index);\n        title_contents_line_index += line_index;\n        line_index += tmp_line_index;\n    } else {\n        /* Not a title. */\n        title_is_multiline = FALSE;\n        title_contents_beg = off;\n        title_contents_end = off;\n        title_contents_line_index = 0;\n    }\n\n    /* Nothing more can follow on the last line. */\n    if(off < lines[line_index].end)\n        return FALSE;\n\n    /* Construct label. */\n    if(!label_is_multiline) {\n        label = (CHAR*) STR(label_contents_beg);\n        label_size = label_contents_end - label_contents_beg;\n        label_needs_free = FALSE;\n    } else {\n        MD_CHECK(md_merge_lines_alloc(ctx, label_contents_beg, label_contents_end,\n                    lines + label_contents_line_index, n_lines - label_contents_line_index,\n                    _T(' '), &label, &label_size));\n        label_needs_free = TRUE;\n    }\n\n    /* Store the reference definition. */\n    if(ctx->n_ref_defs >= ctx->alloc_ref_defs) {\n        MD_REF_DEF* new_defs;\n\n        ctx->alloc_ref_defs = (ctx->alloc_ref_defs > 0 ? ctx->alloc_ref_defs * 2 : 16);\n        new_defs = (MD_REF_DEF*) realloc(ctx->ref_defs, ctx->alloc_ref_defs * sizeof(MD_REF_DEF));\n        if(new_defs == NULL) {\n            MD_LOG(\"realloc() failed.\");\n            ret = -1;\n            goto abort;\n        }\n\n        ctx->ref_defs = new_defs;\n    }\n\n    def = &ctx->ref_defs[ctx->n_ref_defs];\n    memset(def, 0, sizeof(MD_REF_DEF));\n\n    def->label = label;\n    def->label_size = label_size;\n    def->label_needs_free = label_needs_free;\n\n    def->dest_beg = dest_contents_beg;\n    def->dest_end = dest_contents_end;\n\n    if(title_contents_beg >= title_contents_end) {\n        def->title = NULL;\n        def->title_size = 0;\n    } else if(!title_is_multiline) {\n        def->title = (CHAR*) STR(title_contents_beg);\n        def->title_size = title_contents_end - title_contents_beg;\n    } else {\n        MD_CHECK(md_merge_lines_alloc(ctx, title_contents_beg, title_contents_end,\n                    lines + title_contents_line_index, n_lines - title_contents_line_index,\n                    _T('\\n'), &def->title, &def->title_size));\n        def->title_needs_free = TRUE;\n    }\n\n    /* Success. */\n    ctx->n_ref_defs++;\n    return line_index + 1;\n\nabort:\n    /* Failure. */\n    if(label_needs_free)\n        free(label);\n    return -1;\n}",
        "begin_line": 2040,
        "end_line": 2170,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_is_link_title#1972",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_is_link_title(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF* p_end, int* p_beg_line_index, int* p_end_line_index, OFF* p_contents_beg, OFF* p_contents_end)",
        "snippet": "static int\nmd_is_link_title(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg,\n                 OFF* p_end, int* p_beg_line_index, int* p_end_line_index,\n                 OFF* p_contents_beg, OFF* p_contents_end)\n{\n    OFF off = beg;\n    CHAR closer_char;\n    int line_index = 0;\n\n    /* White space with up to one line break. */\n    while(off < lines[line_index].end  &&  ISWHITESPACE(off))\n        off++;\n    if(off >= lines[line_index].end) {\n        line_index++;\n        if(line_index >= n_lines)\n            return FALSE;\n        off = lines[line_index].beg;\n    }\n    if(off == beg)\n        return FALSE;\n\n    *p_beg_line_index = line_index;\n\n    /* First char determines how to detect end of it. */\n    switch(CH(off)) {\n        case _T('\"'):   closer_char = _T('\"'); break;\n        case _T('\\''):  closer_char = _T('\\''); break;\n        case _T('('):   closer_char = _T(')'); break;\n        default:        return FALSE;\n    }\n    off++;\n\n    *p_contents_beg = off;\n\n    while(line_index < n_lines) {\n        OFF line_end = lines[line_index].end;\n\n        while(off < line_end) {\n            if(CH(off) == _T('\\\\')  &&  off+1 < ctx->size  &&  (ISPUNCT(off+1) || ISNEWLINE(off+1))) {\n                off++;\n            } else if(CH(off) == closer_char) {\n                /* Success. */\n                *p_contents_end = off;\n                *p_end = off+1;\n                *p_end_line_index = line_index;\n                return TRUE;\n            } else if(closer_char == _T(')')  &&  CH(off) == _T('(')) {\n                /* ()-style title cannot contain (unescaped '(')) */\n                return FALSE;\n            }\n\n            off++;\n        }\n\n        line_index++;\n    }\n\n    return FALSE;\n}",
        "begin_line": 1972,
        "end_line": 2030,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_is_setext_underline#4907",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_is_setext_underline(MD_CTX* ctx, OFF beg, OFF* p_end, unsigned* p_level)",
        "snippet": "static int\nmd_is_setext_underline(MD_CTX* ctx, OFF beg, OFF* p_end, unsigned* p_level)\n{\n    OFF off = beg + 1;\n\n    while(off < ctx->size  &&  CH(off) == CH(beg))\n        off++;\n\n    /* Optionally, space(s) can follow. */\n    while(off < ctx->size  &&  CH(off) == _T(' '))\n        off++;\n\n    /* But nothing more is allowed on the line. */\n    if(off < ctx->size  &&  !ISNEWLINE(off))\n        return FALSE;\n\n    *p_level = (CH(beg) == _T('=') ? 1 : 2);\n    *p_end = off;\n    return TRUE;\n}",
        "begin_line": 4907,
        "end_line": 4926,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_line_indentation#5426",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_line_indentation(MD_CTX* ctx, unsigned total_indent, OFF beg, OFF* p_end)",
        "snippet": "static unsigned\nmd_line_indentation(MD_CTX* ctx, unsigned total_indent, OFF beg, OFF* p_end)\n{\n    OFF off = beg;\n    unsigned indent = total_indent;\n\n    while(off < ctx->size  &&  ISBLANK(off)) {\n        if(CH(off) == _T('\\t'))\n            indent = (indent + 4) & ~3;\n        else\n            indent++;\n        off++;\n    }\n\n    *p_end = off;\n    return indent - total_indent;\n}",
        "begin_line": 5426,
        "end_line": 5442,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_parse#6042",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_parse(const MD_CHAR* text, MD_SIZE size, const MD_PARSER* parser, void* userdata)",
        "snippet": "int\nmd_parse(const MD_CHAR* text, MD_SIZE size, const MD_PARSER* parser, void* userdata)\n{\n    MD_CTX ctx;\n    int i;\n    int ret;\n\n    if(parser->abi_version != 0) {\n        if(parser->debug_log != NULL)\n            parser->debug_log(\"Unsupported abi_version.\", userdata);\n        return -1;\n    }\n\n    /* Setup context structure. */\n    memset(&ctx, 0, sizeof(MD_CTX));\n    ctx.text = text;\n    ctx.size = size;\n    memcpy(&ctx.parser, parser, sizeof(MD_PARSER));\n    ctx.userdata = userdata;\n    ctx.code_indent_offset = (ctx.parser.flags & MD_FLAG_NOINDENTEDCODEBLOCKS) ? (OFF)(-1) : 4;\n    md_build_mark_char_map(&ctx);\n\n    /* Reset all unresolved opener mark chains. */\n    for(i = 0; i < SIZEOF_ARRAY(ctx.mark_chains); i++) {\n        ctx.mark_chains[i].head = -1;\n        ctx.mark_chains[i].tail = -1;\n    }\n    ctx.unresolved_link_head = -1;\n    ctx.unresolved_link_tail = -1;\n\n    /* All the work. */\n    ret = md_process_doc(&ctx);\n\n    /* Clean-up. */\n    md_free_ref_defs(&ctx);\n    md_free_ref_def_hashtable(&ctx);\n    free(ctx.buffer);\n    free(ctx.marks);\n    free(ctx.block_bytes);\n    free(ctx.containers);\n\n    return ret;\n}",
        "begin_line": 6042,
        "end_line": 6084,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_process_doc#5981",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_process_doc(MD_CTX *ctx)",
        "snippet": "static int\nmd_process_doc(MD_CTX *ctx)\n{\n    const MD_LINE_ANALYSIS* pivot_line = &md_dummy_blank_line;\n    MD_LINE_ANALYSIS line_buf[2];\n    MD_LINE_ANALYSIS* line = &line_buf[0];\n    OFF off = 0;\n    int ret = 0;\n\n    MD_ENTER_BLOCK(MD_BLOCK_DOC, NULL);\n\n    while(off < ctx->size) {\n        if(line == pivot_line)\n            line = (line == &line_buf[0] ? &line_buf[1] : &line_buf[0]);\n\n        MD_CHECK(md_analyze_line(ctx, off, &off, pivot_line, line));\n        MD_CHECK(md_process_line(ctx, &pivot_line, line));\n    }\n\n    md_end_current_block(ctx);\n\n    MD_CHECK(md_build_ref_def_hashtable(ctx));\n\n    /* Process all blocks. */\n    MD_CHECK(md_leave_child_containers(ctx, 0));\n    MD_CHECK(md_process_all_blocks(ctx));\n\n    MD_LEAVE_BLOCK(MD_BLOCK_DOC, NULL);\n\nabort:\n\n#if 0\n    /* Output some memory consumption statistics. */\n    {\n        char buffer[256];\n        sprintf(buffer, \"Alloced %u bytes for block buffer.\",\n                    (unsigned)(ctx->alloc_block_bytes));\n        MD_LOG(buffer);\n\n        sprintf(buffer, \"Alloced %u bytes for containers buffer.\",\n                    (unsigned)(ctx->alloc_containers * sizeof(MD_CONTAINER)));\n        MD_LOG(buffer);\n\n        sprintf(buffer, \"Alloced %u bytes for marks buffer.\",\n                    (unsigned)(ctx->alloc_marks * sizeof(MD_MARK)));\n        MD_LOG(buffer);\n\n        sprintf(buffer, \"Alloced %u bytes for aux. buffer.\",\n                    (unsigned)(ctx->alloc_buffer * sizeof(MD_CHAR)));\n        MD_LOG(buffer);\n    }\n#endif\n\n    return ret;\n}",
        "begin_line": 5981,
        "end_line": 6035,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_process_line#5908",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_process_line(MD_CTX* ctx, const MD_LINE_ANALYSIS** p_pivot_line, MD_LINE_ANALYSIS* line)",
        "snippet": "static int\nmd_process_line(MD_CTX* ctx, const MD_LINE_ANALYSIS** p_pivot_line, MD_LINE_ANALYSIS* line)\n{\n    const MD_LINE_ANALYSIS* pivot_line = *p_pivot_line;\n    int ret = 0;\n\n    /* Blank line ends current leaf block. */\n    if(line->type == MD_LINE_BLANK) {\n        MD_CHECK(md_end_current_block(ctx));\n        *p_pivot_line = &md_dummy_blank_line;\n        return 0;\n    }\n\n    /* Some line types form block on their own. */\n    if(line->type == MD_LINE_HR || line->type == MD_LINE_ATXHEADER) {\n        MD_CHECK(md_end_current_block(ctx));\n\n        /* Add our single-line block. */\n        MD_CHECK(md_start_new_block(ctx, line));\n        MD_CHECK(md_add_line_into_current_block(ctx, line));\n        MD_CHECK(md_end_current_block(ctx));\n        *p_pivot_line = &md_dummy_blank_line;\n        return 0;\n    }\n\n    /* MD_LINE_SETEXTUNDERLINE changes meaning of the current block and ends it. */\n    if(line->type == MD_LINE_SETEXTUNDERLINE) {\n        MD_ASSERT(ctx->current_block != NULL);\n        ctx->current_block->type = MD_BLOCK_H;\n        ctx->current_block->data = line->data;\n        ctx->current_block->flags |= MD_BLOCK_SETEXT_HEADER;\n        MD_CHECK(md_add_line_into_current_block(ctx, line));\n        MD_CHECK(md_end_current_block(ctx));\n        if(ctx->current_block == NULL) {\n            *p_pivot_line = &md_dummy_blank_line;\n        } else {\n            /* This happens if we have consumed all the body as link ref. defs.\n             * and downgraded the underline into start of a new paragraph block. */\n            line->type = MD_LINE_TEXT;\n            *p_pivot_line = line;\n        }\n        return 0;\n    }\n\n    /* MD_LINE_TABLEUNDERLINE changes meaning of the current block. */\n    if(line->type == MD_LINE_TABLEUNDERLINE) {\n        MD_ASSERT(ctx->current_block != NULL);\n        MD_ASSERT(ctx->current_block->n_lines == 1);\n        ctx->current_block->type = MD_BLOCK_TABLE;\n        ctx->current_block->data = line->data;\n        MD_ASSERT(pivot_line != &md_dummy_blank_line);\n        ((MD_LINE_ANALYSIS*)pivot_line)->type = MD_LINE_TABLE;\n        MD_CHECK(md_add_line_into_current_block(ctx, line));\n        return 0;\n    }\n\n    /* The current block also ends if the line has different type. */\n    if(line->type != pivot_line->type)\n        MD_CHECK(md_end_current_block(ctx));\n\n    /* The current line may start a new block. */\n    if(ctx->current_block == NULL) {\n        MD_CHECK(md_start_new_block(ctx, line));\n        *p_pivot_line = line;\n    }\n\n    /* In all other cases the line is just a continuation of the current block. */\n    MD_CHECK(md_add_line_into_current_block(ctx, line));\n\nabort:\n    return ret;\n}",
        "begin_line": 5908,
        "end_line": 5979,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_push_block_bytes#4624",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_push_block_bytes(MD_CTX* ctx, int n_bytes)",
        "snippet": "static void*\nmd_push_block_bytes(MD_CTX* ctx, int n_bytes)\n{\n    void* ptr;\n\n    if(ctx->n_block_bytes + n_bytes > ctx->alloc_block_bytes) {\n        void* new_block_bytes;\n\n        ctx->alloc_block_bytes = (ctx->alloc_block_bytes > 0 ? ctx->alloc_block_bytes * 2 : 512);\n        new_block_bytes = realloc(ctx->block_bytes, ctx->alloc_block_bytes);\n        if(new_block_bytes == NULL) {\n            MD_LOG(\"realloc() failed.\");\n            return NULL;\n        }\n\n        /* Fix the ->current_block after the reallocation. */\n        if(ctx->current_block != NULL) {\n            OFF off_current_block = (char*) ctx->current_block - (char*) ctx->block_bytes;\n            ctx->current_block = (MD_BLOCK*) ((char*) new_block_bytes + off_current_block);\n        }\n\n        ctx->block_bytes = new_block_bytes;\n    }\n\n    ptr = (char*)ctx->block_bytes + ctx->n_block_bytes;\n    ctx->n_block_bytes += n_bytes;\n    return ptr;\n}",
        "begin_line": 4624,
        "end_line": 4651,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_start_new_block#4653",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_start_new_block(MD_CTX* ctx, const MD_LINE_ANALYSIS* line)",
        "snippet": "static int\nmd_start_new_block(MD_CTX* ctx, const MD_LINE_ANALYSIS* line)\n{\n    MD_BLOCK* block;\n\n    MD_ASSERT(ctx->current_block == NULL);\n\n    block = (MD_BLOCK*) md_push_block_bytes(ctx, sizeof(MD_BLOCK));\n    if(block == NULL)\n        return -1;\n\n    switch(line->type) {\n        case MD_LINE_HR:\n            block->type = MD_BLOCK_HR;\n            break;\n\n        case MD_LINE_ATXHEADER:\n        case MD_LINE_SETEXTHEADER:\n            block->type = MD_BLOCK_H;\n            break;\n\n        case MD_LINE_FENCEDCODE:\n        case MD_LINE_INDENTEDCODE:\n            block->type = MD_BLOCK_CODE;\n            break;\n\n        case MD_LINE_TEXT:\n            block->type = MD_BLOCK_P;\n            break;\n\n        case MD_LINE_HTML:\n            block->type = MD_BLOCK_HTML;\n            break;\n\n        case MD_LINE_BLANK:\n        case MD_LINE_SETEXTUNDERLINE:\n        case MD_LINE_TABLEUNDERLINE:\n        default:\n            MD_UNREACHABLE();\n            break;\n    }\n\n    block->flags = 0;\n    block->data = line->data;\n    block->n_lines = 0;\n\n    ctx->current_block = block;\n    return 0;\n}",
        "begin_line": 4653,
        "end_line": 4701,
        "is_bug": false
    },
    {
        "name": "md4c.md4c.md_strchr#296",
        "src_path": "md4c/md4c.c",
        "class_name": "md4c.md4c",
        "signature": "md4c.md4c.md_strchr(const CHAR* str, CHAR ch)",
        "snippet": "static inline const CHAR*\nmd_strchr(const CHAR* str, CHAR ch)\n{\n    OFF i;\n    for(i = 0; str[i] != _T('\\0'); i++) {\n        if(ch == str[i])\n            return (str + i);\n    }\n    return NULL;\n}",
        "begin_line": 296,
        "end_line": 305,
        "is_bug": false
    }
]