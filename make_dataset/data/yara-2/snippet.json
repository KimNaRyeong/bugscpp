[
    {
        "name": "libyara.ahocorasick._yr_ac_build_transition_table#583",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick._yr_ac_build_transition_table(     YR_AC_AUTOMATON* automaton)",
        "snippet": "static int _yr_ac_build_transition_table(\n    YR_AC_AUTOMATON* automaton)\n{\n  YR_AC_STATE* state;\n  YR_AC_STATE* child_state;\n  YR_AC_STATE* root_state = automaton->root;\n\n  uint32_t slot;\n\n  QUEUE queue = { NULL, NULL};\n\n  automaton->tables_size = 1024;\n\n  automaton->t_table = (YR_AC_TRANSITION_TABLE) yr_calloc(\n      automaton->tables_size, sizeof(YR_AC_TRANSITION));\n\n  automaton->m_table = (YR_AC_MATCH_TABLE) yr_calloc(\n      automaton->tables_size, sizeof(YR_AC_MATCH_TABLE_ENTRY));\n\n  automaton->bitmask = (YR_BITMASK*) yr_calloc(\n      YR_BITMASK_SIZE(automaton->tables_size), sizeof(YR_BITMASK));\n\n  if (automaton->t_table == NULL ||\n      automaton->m_table == NULL ||\n      automaton->bitmask == NULL)\n  {\n    yr_free(automaton->t_table);\n    yr_free(automaton->m_table);\n    yr_free(automaton->bitmask);\n\n    return ERROR_INSUFFICIENT_MEMORY;\n  }\n\n  automaton->t_table[0] = YR_AC_MAKE_TRANSITION(0, 0);\n  automaton->m_table[0].match = root_state->matches;\n\n  yr_bitmask_set(automaton->bitmask, 0);\n\n  // Index 0 is for root node. Unused indexes start at 1.\n  automaton->t_table_unused_candidate = 1;\n\n  child_state = root_state->first_child;\n\n  while (child_state != NULL)\n  {\n    child_state->t_table_slot = child_state->input + 1;\n    automaton->t_table[child_state->input + 1] = YR_AC_MAKE_TRANSITION(\n        0, child_state->input + 1);\n\n    yr_bitmask_set(automaton->bitmask, child_state->input + 1);\n\n    FAIL_ON_ERROR(_yr_ac_queue_push(&queue, child_state));\n    child_state = child_state->siblings;\n  }\n\n  while (!_yr_ac_queue_is_empty(&queue))\n  {\n    state = _yr_ac_queue_pop(&queue);\n\n    FAIL_ON_ERROR(_yr_ac_find_suitable_transition_table_slot(\n        automaton, state, &slot));\n\n    automaton->t_table[state->t_table_slot] |= (slot << YR_AC_SLOT_OFFSET_BITS);\n\n    state->t_table_slot = slot;\n\n    automaton->t_table[slot] = YR_AC_MAKE_TRANSITION(\n        state->failure->t_table_slot, 0);\n\n    yr_bitmask_set(automaton->bitmask, slot);\n\n    automaton->m_table[slot].match = state->matches;\n\n    // Push childrens of current_state\n\n    child_state = state->first_child;\n\n    while (child_state != NULL)\n    {\n      child_state->t_table_slot = slot + child_state->input + 1;\n      automaton->t_table[child_state->t_table_slot] = YR_AC_MAKE_TRANSITION(\n          0, child_state->input + 1);\n\n      yr_bitmask_set(automaton->bitmask, child_state->t_table_slot);\n\n      FAIL_ON_ERROR(_yr_ac_queue_push(&queue, child_state));\n\n      child_state = child_state->siblings;\n    }\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 583,
        "end_line": 675,
        "is_bug": false
    },
    {
        "name": "libyara.ahocorasick._yr_ac_create_failure_links#251",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick._yr_ac_create_failure_links(     YR_AC_AUTOMATON* automaton)",
        "snippet": "static int _yr_ac_create_failure_links(\n    YR_AC_AUTOMATON* automaton)\n{\n  YR_AC_STATE* current_state;\n  YR_AC_STATE* failure_state;\n  YR_AC_STATE* temp_state;\n  YR_AC_STATE* state;\n  YR_AC_STATE* transition_state;\n  YR_AC_STATE* root_state;\n  YR_AC_MATCH* match;\n\n  QUEUE queue;\n\n  queue.head = NULL;\n  queue.tail = NULL;\n\n  root_state = automaton->root;\n\n  // Set the failure link of root state to itself.\n  root_state->failure = root_state;\n\n  // Push root's children and set their failure link to root.\n  state = root_state->first_child;\n\n  while (state != NULL)\n  {\n    FAIL_ON_ERROR(_yr_ac_queue_push(&queue, state));\n    state->failure = root_state;\n    state = state->siblings;\n  }\n\n  // Traverse the trie in BFS order calculating the failure link\n  // for each state.\n\n  while (!_yr_ac_queue_is_empty(&queue))\n  {\n    current_state = _yr_ac_queue_pop(&queue);\n\n    match = current_state->matches;\n\n    if (match != NULL)\n    {\n      while (match->next != NULL)\n        match = match->next;\n\n      if (match->backtrack > 0)\n        match->next = root_state->matches;\n    }\n    else\n    {\n      current_state->matches = root_state->matches;\n    }\n\n    transition_state = current_state->first_child;\n\n    while (transition_state != NULL)\n    {\n      FAIL_ON_ERROR(_yr_ac_queue_push(&queue, transition_state));\n      failure_state = current_state->failure;\n\n      while (1)\n      {\n        temp_state = _yr_ac_next_state(\n            failure_state, transition_state->input);\n\n        if (temp_state != NULL)\n        {\n          transition_state->failure = temp_state;\n\n          if (transition_state->matches == NULL)\n          {\n            transition_state->matches = temp_state->matches;\n          }\n          else\n          {\n            match = transition_state->matches;\n\n            while (match != NULL && match->next != NULL)\n              match = match->next;\n\n            match->next = temp_state->matches;\n          }\n\n          break;\n        }\n        else\n        {\n          if (failure_state == root_state)\n          {\n            transition_state->failure = root_state;\n            break;\n          }\n          else\n          {\n            failure_state = failure_state->failure;\n          }\n        }\n      } // while(1)\n\n      transition_state = transition_state->siblings;\n    }\n\n  } // while(!__yr_ac_queue_is_empty(&queue))\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 251,
        "end_line": 356,
        "is_bug": false
    },
    {
        "name": "libyara.ahocorasick._yr_ac_find_suitable_transition_table_slot#451",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick._yr_ac_find_suitable_transition_table_slot(     YR_AC_AUTOMATON* automaton, YR_AC_STATE* state, uint32_t* slot)",
        "snippet": "static int _yr_ac_find_suitable_transition_table_slot(\n    YR_AC_AUTOMATON* automaton,\n    YR_AC_STATE* state,\n    uint32_t* slot)\n{\n  // The state's transition table has 257 entries, 1 for the failure link and\n  // 256 for each possible input byte, so the state's bitmask has 257 bits.\n  YR_BITMASK state_bitmask[YR_BITMASK_SIZE(257)];\n\n  YR_AC_STATE* child_state = state->first_child;\n\n  // Start with all bits set to zero.\n  yr_bitmask_clear_all(state_bitmask);\n\n  // The first slot in the transition table is for the state's failure link,\n  // so the first bit in the bitmask must be set to one.\n  yr_bitmask_set(state_bitmask, 0);\n\n  while (child_state != NULL)\n  {\n    yr_bitmask_set(state_bitmask, child_state->input + 1);\n    child_state = child_state->siblings;\n  }\n\n  *slot = yr_bitmask_find_non_colliding_offset(\n      automaton->bitmask,\n      state_bitmask,\n      automaton->tables_size,\n      257,\n      &automaton->t_table_unused_candidate);\n\n  // Make sure that we are not going beyond the maximum size of the transition\n  // table, starting at the slot found there must be at least 257 other slots\n  // for accommodating the state's transition table.\n  assert(*slot + 257 < YR_AC_MAX_TRANSITION_TABLE_SIZE);\n\n  if (*slot > automaton->tables_size - 257)\n  {\n      size_t t_bytes_size = automaton->tables_size *\n          sizeof(YR_AC_TRANSITION);\n\n      size_t m_bytes_size = automaton->tables_size *\n          sizeof(YR_AC_MATCH_TABLE_ENTRY);\n\n      size_t b_bytes_size = YR_BITMASK_SIZE(automaton->tables_size) *\n           sizeof(YR_BITMASK);\n\n      automaton->t_table = (YR_AC_TRANSITION_TABLE) yr_realloc(\n          automaton->t_table, t_bytes_size * 2);\n\n      automaton->m_table = (YR_AC_MATCH_TABLE) yr_realloc(\n          automaton->m_table, m_bytes_size * 2);\n\n      automaton->bitmask = (YR_BITMASK*) yr_realloc(\n          automaton->bitmask, b_bytes_size * 2);\n\n      if (automaton->t_table == NULL ||\n          automaton->m_table == NULL ||\n          automaton->bitmask == NULL)\n      {\n        return ERROR_INSUFFICIENT_MEMORY;\n      }\n\n      memset((uint8_t*) automaton->t_table + t_bytes_size, 0, t_bytes_size);\n      memset((uint8_t*) automaton->m_table + m_bytes_size, 0, m_bytes_size);\n      memset((uint8_t*) automaton->bitmask + b_bytes_size, 0, b_bytes_size);\n\n      automaton->tables_size *= 2;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 451,
        "end_line": 522,
        "is_bug": false
    },
    {
        "name": "libyara.ahocorasick._yr_ac_next_state#168",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick._yr_ac_next_state(     YR_AC_STATE* state, uint8_t input)",
        "snippet": "static YR_AC_STATE* _yr_ac_next_state(\n    YR_AC_STATE* state,\n    uint8_t input)\n{\n  YR_AC_STATE* next_state = state->first_child;\n\n  while (next_state != NULL)\n  {\n    if (next_state->input == input)\n      return next_state;\n\n    next_state = next_state->siblings;\n  }\n\n  return NULL;\n}",
        "begin_line": 168,
        "end_line": 183,
        "is_bug": false
    },
    {
        "name": "libyara.ahocorasick._yr_ac_optimize_failure_links#403",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick._yr_ac_optimize_failure_links(     YR_AC_AUTOMATON* automaton)",
        "snippet": "static int _yr_ac_optimize_failure_links(\n    YR_AC_AUTOMATON* automaton)\n{\n  QUEUE queue = { NULL, NULL};\n\n  // Push root's children.\n  YR_AC_STATE* root_state = automaton->root;\n  YR_AC_STATE* state = root_state->first_child;\n\n  while (state != NULL)\n  {\n    FAIL_ON_ERROR(_yr_ac_queue_push(&queue, state));\n    state = state->siblings;\n  }\n\n  while (!_yr_ac_queue_is_empty(&queue))\n  {\n    YR_AC_STATE* current_state = _yr_ac_queue_pop(&queue);\n\n    if (current_state->failure != root_state)\n    {\n      if (_yr_ac_transitions_subset(current_state, current_state->failure))\n        current_state->failure = current_state->failure->failure;\n    }\n\n    // Push childrens of current_state\n    state = current_state->first_child;\n\n    while (state != NULL)\n    {\n      FAIL_ON_ERROR(_yr_ac_queue_push(&queue, state));\n      state = state->siblings;\n    }\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 403,
        "end_line": 439,
        "is_bug": false
    },
    {
        "name": "libyara.ahocorasick._yr_ac_queue_is_empty#147",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick._yr_ac_queue_is_empty(     QUEUE* queue)",
        "snippet": "static int _yr_ac_queue_is_empty(\n    QUEUE* queue)\n{\n  return queue->head == NULL;\n}",
        "begin_line": 147,
        "end_line": 151,
        "is_bug": false
    },
    {
        "name": "libyara.ahocorasick._yr_ac_queue_pop#111",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick._yr_ac_queue_pop(     QUEUE* queue)",
        "snippet": "static YR_AC_STATE* _yr_ac_queue_pop(\n    QUEUE* queue)\n{\n  YR_AC_STATE* result;\n  QUEUE_NODE* popped_node;\n\n  if (queue->head == NULL)\n    return NULL;\n\n  popped_node = queue->head;\n  queue->head = popped_node->next;\n\n  if (queue->head)\n    queue->head->previous = NULL;\n  else // queue is empty\n    queue->tail = NULL;\n\n  result = popped_node->value;\n\n  yr_free(popped_node);\n  return result;\n}",
        "begin_line": 111,
        "end_line": 132,
        "is_bug": false
    },
    {
        "name": "libyara.ahocorasick._yr_ac_queue_push#73",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick._yr_ac_queue_push(     QUEUE* queue, YR_AC_STATE* value)",
        "snippet": "static int _yr_ac_queue_push(\n    QUEUE* queue,\n    YR_AC_STATE* value)\n{\n  QUEUE_NODE* pushed_node;\n\n  pushed_node = (QUEUE_NODE*) yr_malloc(sizeof(QUEUE_NODE));\n\n  if (pushed_node == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  pushed_node->previous = queue->tail;\n  pushed_node->next = NULL;\n  pushed_node->value = value;\n\n  if (queue->tail != NULL)\n    queue->tail->next = pushed_node;\n  else // queue is empty\n    queue->head = pushed_node;\n\n  queue->tail = pushed_node;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 73,
        "end_line": 96,
        "is_bug": false
    },
    {
        "name": "libyara.ahocorasick._yr_ac_state_create#200",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick._yr_ac_state_create(     YR_AC_STATE* state, uint8_t input)",
        "snippet": "static YR_AC_STATE* _yr_ac_state_create(\n    YR_AC_STATE* state,\n    uint8_t input)\n{\n  YR_AC_STATE* new_state = (YR_AC_STATE*) yr_malloc(sizeof(YR_AC_STATE));\n\n  if (new_state == NULL)\n    return NULL;\n\n  new_state->input = input;\n  new_state->depth = state->depth + 1;\n  new_state->matches = NULL;\n  new_state->failure = NULL;\n  new_state->t_table_slot = 0;\n  new_state->first_child = NULL;\n  new_state->siblings = state->first_child;\n  state->first_child = new_state;\n\n  return new_state;\n}",
        "begin_line": 200,
        "end_line": 219,
        "is_bug": false
    },
    {
        "name": "libyara.ahocorasick._yr_ac_state_destroy#226",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick._yr_ac_state_destroy(     YR_AC_STATE* state)",
        "snippet": "static int _yr_ac_state_destroy(\n    YR_AC_STATE* state)\n{\n  YR_AC_STATE* child_state = state->first_child;\n\n  while (child_state != NULL)\n  {\n    YR_AC_STATE* next_child_state = child_state->siblings;\n    _yr_ac_state_destroy(child_state);\n    child_state = next_child_state;\n  }\n\n  yr_free(state);\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 226,
        "end_line": 241,
        "is_bug": false
    },
    {
        "name": "libyara.ahocorasick._yr_ac_transitions_subset#367",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick._yr_ac_transitions_subset(     YR_AC_STATE* s1, YR_AC_STATE* s2)",
        "snippet": "static bool _yr_ac_transitions_subset(\n    YR_AC_STATE* s1,\n    YR_AC_STATE* s2)\n{\n  uint8_t set[32];\n\n  YR_AC_STATE* state = s1->first_child;\n\n  memset(set, 0, 32);\n\n  while (state != NULL)\n  {\n    set[state->input / 8] |= 1 << state->input % 8;\n    state = state->siblings;\n  }\n\n  state = s2->first_child;\n\n  while (state != NULL)\n  {\n    if (!(set[state->input / 8] & 1 << state->input % 8))\n      return false;\n\n    state = state->siblings;\n  }\n\n  return true;\n}",
        "begin_line": 367,
        "end_line": 394,
        "is_bug": false
    },
    {
        "name": "libyara.ahocorasick.yr_ac_add_string#832",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick.yr_ac_add_string(     YR_AC_AUTOMATON* automaton, YR_STRING* string, YR_ATOM_LIST_ITEM* atom, YR_ARENA* matches_arena)",
        "snippet": "int yr_ac_add_string(\n    YR_AC_AUTOMATON* automaton,\n    YR_STRING* string,\n    YR_ATOM_LIST_ITEM* atom,\n    YR_ARENA* matches_arena)\n{\n  int result = ERROR_SUCCESS;\n  int i;\n\n  YR_AC_STATE* state;\n  YR_AC_STATE* next_state;\n  YR_AC_MATCH* new_match;\n\n  // For each atom create the states in the automaton.\n\n  while (atom != NULL)\n  {\n    state = automaton->root;\n\n    for (i = 0; i < atom->atom.length; i++)\n    {\n      next_state = _yr_ac_next_state(state, atom->atom.bytes[i]);\n\n      if (next_state == NULL)\n      {\n        next_state = _yr_ac_state_create(state, atom->atom.bytes[i]);\n\n        if (next_state == NULL)\n          return ERROR_INSUFFICIENT_MEMORY;\n      }\n\n      state = next_state;\n    }\n\n    result = yr_arena_allocate_struct(\n        matches_arena,\n        sizeof(YR_AC_MATCH),\n        (void**) &new_match,\n        offsetof(YR_AC_MATCH, string),\n        offsetof(YR_AC_MATCH, forward_code),\n        offsetof(YR_AC_MATCH, backward_code),\n        offsetof(YR_AC_MATCH, next),\n        EOL);\n\n    if (result == ERROR_SUCCESS)\n    {\n      new_match->backtrack = state->depth + atom->backtrack;\n      new_match->string = string;\n      new_match->forward_code = atom->forward_code;\n      new_match->backward_code = atom->backward_code;\n      new_match->next = state->matches;\n      state->matches = new_match;\n    }\n    else\n    {\n      break;\n    }\n\n    atom = atom->next;\n  }\n\n  return result;\n}",
        "begin_line": 832,
        "end_line": 894,
        "is_bug": false
    },
    {
        "name": "libyara.ahocorasick.yr_ac_automaton_create#769",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick.yr_ac_automaton_create(     YR_AC_AUTOMATON** automaton)",
        "snippet": "int yr_ac_automaton_create(\n    YR_AC_AUTOMATON** automaton)\n{\n  YR_AC_AUTOMATON* new_automaton;\n  YR_AC_STATE* root_state;\n\n  new_automaton = (YR_AC_AUTOMATON*) yr_malloc(sizeof(YR_AC_AUTOMATON));\n  root_state = (YR_AC_STATE*) yr_malloc(sizeof(YR_AC_STATE));\n\n  if (new_automaton == NULL || root_state == NULL)\n  {\n    yr_free(new_automaton);\n    yr_free(root_state);\n\n    return ERROR_INSUFFICIENT_MEMORY;\n  }\n\n  root_state->depth = 0;\n  root_state->matches = NULL;\n  root_state->failure = NULL;\n  root_state->first_child = NULL;\n  root_state->siblings = NULL;\n  root_state->t_table_slot = 0;\n\n  new_automaton->root = root_state;\n  new_automaton->m_table = NULL;\n  new_automaton->t_table = NULL;\n  new_automaton->bitmask = NULL;\n  new_automaton->tables_size = 0;\n\n  *automaton = new_automaton;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 769,
        "end_line": 802,
        "is_bug": false
    },
    {
        "name": "libyara.ahocorasick.yr_ac_automaton_destroy#811",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick.yr_ac_automaton_destroy(     YR_AC_AUTOMATON* automaton)",
        "snippet": "int yr_ac_automaton_destroy(\n    YR_AC_AUTOMATON* automaton)\n{\n  _yr_ac_state_destroy(automaton->root);\n\n  yr_free(automaton->t_table);\n  yr_free(automaton->m_table);\n  yr_free(automaton->bitmask);\n  yr_free(automaton);\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 811,
        "end_line": 822,
        "is_bug": false
    },
    {
        "name": "libyara.ahocorasick.yr_ac_compile#901",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick.yr_ac_compile(     YR_AC_AUTOMATON* automaton, YR_ARENA* arena, YR_AC_TABLES* tables)",
        "snippet": "int yr_ac_compile(\n    YR_AC_AUTOMATON* automaton,\n    YR_ARENA* arena,\n    YR_AC_TABLES* tables)\n{\n  uint32_t i;\n\n  FAIL_ON_ERROR(_yr_ac_create_failure_links(automaton));\n  FAIL_ON_ERROR(_yr_ac_optimize_failure_links(automaton));\n  FAIL_ON_ERROR(_yr_ac_build_transition_table(automaton));\n\n  FAIL_ON_ERROR(yr_arena_reserve_memory(\n      arena,\n      automaton->tables_size * sizeof(tables->transitions[0]) +\n      automaton->tables_size * sizeof(tables->matches[0])));\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      arena,\n      automaton->t_table,\n      sizeof(YR_AC_TRANSITION),\n      (void**) &tables->transitions));\n\n  for (i = 1; i < automaton->tables_size; i++)\n  {\n    FAIL_ON_ERROR(yr_arena_write_data(\n        arena,\n        automaton->t_table + i,\n        sizeof(YR_AC_TRANSITION),\n        NULL));\n  }\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      arena,\n      automaton->m_table,\n      sizeof(YR_AC_MATCH_TABLE_ENTRY),\n      (void**) &tables->matches));\n\n  FAIL_ON_ERROR(yr_arena_make_ptr_relocatable(\n      arena,\n      tables->matches,\n      offsetof(YR_AC_MATCH_TABLE_ENTRY, match),\n      EOL));\n\n  for (i = 1; i < automaton->tables_size; i++)\n  {\n    void* ptr;\n\n    FAIL_ON_ERROR(yr_arena_write_data(\n        arena,\n        automaton->m_table + i,\n        sizeof(YR_AC_MATCH_TABLE_ENTRY),\n        (void**) &ptr));\n\n    FAIL_ON_ERROR(yr_arena_make_ptr_relocatable(\n        arena,\n        ptr,\n        offsetof(YR_AC_MATCH_TABLE_ENTRY, match),\n        EOL));\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 901,
        "end_line": 962,
        "is_bug": false
    },
    {
        "name": "libyara.arena._yr_arena_make_ptr_relocatable#171",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena._yr_arena_make_ptr_relocatable(     YR_ARENA* arena, void* base, va_list offsets)",
        "snippet": "static int _yr_arena_make_ptr_relocatable(\n    YR_ARENA* arena,\n    void* base,\n    va_list offsets)\n{\n  YR_RELOC* reloc;\n  YR_ARENA_PAGE* page;\n\n  size_t offset;\n  size_t base_offset;\n\n  int result = ERROR_SUCCESS;\n\n  // If the arena must be relocatable.\n  assert(arena->flags & ARENA_FLAGS_RELOCATABLE);\n\n  page = yr_arena_page_for_address(arena, base);\n\n  assert(page != NULL);\n\n  base_offset = (uint8_t*) base - page->address;\n  offset = va_arg(offsets, size_t);\n\n  while (offset != -1)\n  {\n    assert(page->used >= sizeof(int64_t));\n    assert(base_offset + offset <= page->used - sizeof(int64_t));\n\n    reloc = (YR_RELOC*) yr_malloc(sizeof(YR_RELOC));\n\n    if (reloc == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    reloc->offset = (uint32_t) (base_offset + offset);\n    reloc->next = NULL;\n\n    if (page->reloc_list_head == NULL)\n      page->reloc_list_head = reloc;\n\n    if (page->reloc_list_tail != NULL)\n      page->reloc_list_tail->next = reloc;\n\n    page->reloc_list_tail = reloc;\n    offset = va_arg(offsets, size_t);\n  }\n\n  return result;\n}",
        "begin_line": 171,
        "end_line": 218,
        "is_bug": false
    },
    {
        "name": "libyara.arena._yr_arena_new_page#82",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena._yr_arena_new_page(     size_t size)",
        "snippet": "static YR_ARENA_PAGE* _yr_arena_new_page(\n    size_t size)\n{\n  YR_ARENA_PAGE* new_page;\n\n  new_page = (YR_ARENA_PAGE*) yr_malloc(sizeof(YR_ARENA_PAGE));\n\n  if (new_page == NULL)\n    return NULL;\n\n  new_page->address = (uint8_t*) yr_malloc(size);\n\n  if (new_page->address == NULL)\n  {\n    yr_free(new_page);\n    return NULL;\n  }\n\n  new_page->size = size;\n  new_page->used = 0;\n  new_page->next = NULL;\n  new_page->prev = NULL;\n  new_page->reloc_list_head = NULL;\n  new_page->reloc_list_tail = NULL;\n\n  return new_page;\n}",
        "begin_line": 82,
        "end_line": 108,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_allocate_memory#592",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_allocate_memory(     YR_ARENA* arena, size_t size, void** allocated_memory)",
        "snippet": "int yr_arena_allocate_memory(\n    YR_ARENA* arena,\n    size_t size,\n    void** allocated_memory)\n{\n  FAIL_ON_ERROR(yr_arena_reserve_memory(arena, size));\n\n  *allocated_memory = arena->current_page->address + \\\n                      arena->current_page->used;\n\n  arena->current_page->used += size;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 592,
        "end_line": 605,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_allocate_struct#640",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_allocate_struct(     YR_ARENA* arena, size_t size, void** allocated_memory, ...)",
        "snippet": "int yr_arena_allocate_struct(\n    YR_ARENA* arena,\n    size_t size,\n    void** allocated_memory,\n    ...)\n{\n  int result;\n\n  va_list offsets;\n  va_start(offsets, allocated_memory);\n\n  result = yr_arena_allocate_memory(arena, size, allocated_memory);\n\n  if (result == ERROR_SUCCESS && arena->flags & ARENA_FLAGS_RELOCATABLE)\n    result = _yr_arena_make_ptr_relocatable(arena, *allocated_memory, offsets);\n\n  va_end(offsets);\n\n  if (result == ERROR_SUCCESS)\n    memset(*allocated_memory, 0, size);\n\n  return result;\n}",
        "begin_line": 640,
        "end_line": 662,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_append#789",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_append(     YR_ARENA* target_arena, YR_ARENA* source_arena)",
        "snippet": "int yr_arena_append(\n    YR_ARENA* target_arena,\n    YR_ARENA* source_arena)\n{\n  uint8_t padding_data[15];\n  size_t padding_size = 16 - target_arena->current_page->used % 16;\n\n  if (padding_size < 16)\n  {\n    memset(&padding_data, 0xCC, padding_size);\n\n    FAIL_ON_ERROR(yr_arena_write_data(\n        target_arena,\n        padding_data,\n        padding_size,\n        NULL));\n  }\n\n  target_arena->current_page->next = source_arena->page_list_head;\n  source_arena->page_list_head->prev = target_arena->current_page;\n  target_arena->current_page = source_arena->current_page;\n\n  yr_free(source_arena);\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 789,
        "end_line": 814,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_base_address#327",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_base_address(   YR_ARENA* arena)",
        "snippet": "void* yr_arena_base_address(\n  YR_ARENA* arena)\n{\n  if (arena->page_list_head->used == 0)\n    return NULL;\n\n  return arena->page_list_head->address;\n}",
        "begin_line": 327,
        "end_line": 334,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_coalesce#420",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_coalesce(     YR_ARENA* arena)",
        "snippet": "int yr_arena_coalesce(\n    YR_ARENA* arena)\n{\n  YR_ARENA_PAGE* page;\n  YR_ARENA_PAGE* big_page;\n  YR_ARENA_PAGE* next_page;\n  YR_RELOC* reloc;\n\n  uint8_t** reloc_address;\n  uint8_t* reloc_target;\n  size_t total_size = 0;\n\n  page = arena->page_list_head;\n\n  while(page != NULL)\n  {\n    total_size += page->used;\n    page = page->next;\n  }\n\n  // Create a new page that will contain the entire arena.\n  big_page = _yr_arena_new_page(total_size);\n\n  if (big_page == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  // Copy data from current pages to the big page and adjust relocs.\n  page = arena->page_list_head;\n\n  while (page != NULL)\n  {\n    page->new_address = big_page->address + big_page->used;\n    memcpy(page->new_address, page->address, page->used);\n\n    reloc = page->reloc_list_head;\n\n    while (reloc != NULL)\n    {\n      reloc->offset += (uint32_t) big_page->used;\n      reloc = reloc->next;\n    }\n\n    if (big_page->reloc_list_head == NULL)\n      big_page->reloc_list_head = page->reloc_list_head;\n\n    if (big_page->reloc_list_tail != NULL)\n      big_page->reloc_list_tail->next = page->reloc_list_head;\n\n    if (page->reloc_list_tail != NULL)\n      big_page->reloc_list_tail = page->reloc_list_tail;\n\n    big_page->used += page->used;\n    page = page->next;\n  }\n\n  // Relocate pointers.\n  reloc = big_page->reloc_list_head;\n\n  while (reloc != NULL)\n  {\n    reloc_address = (uint8_t**) (big_page->address + reloc->offset);\n    reloc_target = *reloc_address;\n\n    if (reloc_target != NULL)\n    {\n      page = yr_arena_page_for_address(arena, reloc_target);\n      assert(page != NULL);\n      *reloc_address = page->new_address + (reloc_target - page->address);\n    }\n\n    reloc = reloc->next;\n  }\n\n  // Release current pages.\n  page = arena->page_list_head;\n\n  while(page != NULL)\n  {\n    next_page = page->next;\n    yr_free(page->address);\n    yr_free(page);\n    page = next_page;\n  }\n\n  arena->page_list_head = big_page;\n  arena->current_page = big_page;\n  arena->flags |= ARENA_FLAGS_COALESCED;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 420,
        "end_line": 509,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_create#236",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_create(     size_t initial_size, int flags, YR_ARENA** arena)",
        "snippet": "int yr_arena_create(\n    size_t initial_size,\n    int flags,\n    YR_ARENA** arena)\n{\n  YR_ARENA* new_arena;\n  YR_ARENA_PAGE* new_page;\n\n  *arena = NULL;\n  new_arena = (YR_ARENA*) yr_malloc(sizeof(YR_ARENA));\n\n  if (new_arena == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  new_page = _yr_arena_new_page(initial_size);\n\n  if (new_page == NULL)\n  {\n    yr_free(new_arena);\n    return ERROR_INSUFFICIENT_MEMORY;\n  }\n\n  new_arena->page_list_head = new_page;\n  new_arena->current_page = new_page;\n  new_arena->flags = flags | ARENA_FLAGS_COALESCED;\n\n  *arena = new_arena;\n  return ERROR_SUCCESS;\n}",
        "begin_line": 236,
        "end_line": 264,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_destroy#279",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_destroy(     YR_ARENA* arena)",
        "snippet": "void yr_arena_destroy(\n    YR_ARENA* arena)\n{\n  YR_RELOC* reloc;\n  YR_RELOC* next_reloc;\n  YR_ARENA_PAGE* page;\n  YR_ARENA_PAGE* next_page;\n\n  if (arena == NULL)\n    return;\n\n  page = arena->page_list_head;\n\n  while(page != NULL)\n  {\n    next_page = page->next;\n    reloc = page->reloc_list_head;\n\n    while (reloc != NULL)\n    {\n      next_reloc = reloc->next;\n      yr_free(reloc);\n      reloc = next_reloc;\n    }\n\n    yr_free(page->address);\n    yr_free(page);\n\n    page = next_page;\n  }\n\n  yr_free(arena);\n}",
        "begin_line": 279,
        "end_line": 311,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_duplicate#832",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_duplicate(     YR_ARENA* arena, YR_ARENA** duplicated)",
        "snippet": "int yr_arena_duplicate(\n    YR_ARENA* arena,\n    YR_ARENA** duplicated)\n{\n  YR_RELOC* reloc;\n  YR_RELOC* new_reloc;\n  YR_ARENA_PAGE* page;\n  YR_ARENA_PAGE* new_page;\n  YR_ARENA* new_arena;\n  uint8_t** reloc_address;\n  uint8_t* reloc_target;\n\n  // Arena must be coalesced and relocatable in order to be duplicated.\n  assert(arena->flags & ARENA_FLAGS_COALESCED);\n  assert(arena->flags & ARENA_FLAGS_RELOCATABLE);\n\n  page = arena->page_list_head;\n\n  FAIL_ON_ERROR(yr_arena_create(page->size, arena->flags, &new_arena));\n\n  new_page = new_arena->current_page;\n  new_page->used = page->used;\n\n  memcpy(new_page->address, page->address, page->size);\n\n  reloc = page->reloc_list_head;\n\n  while (reloc != NULL)\n  {\n    new_reloc = (YR_RELOC*) yr_malloc(sizeof(YR_RELOC));\n\n    if (new_reloc == NULL)\n    {\n      yr_arena_destroy(new_arena);\n      return ERROR_INSUFFICIENT_MEMORY;\n    }\n\n    new_reloc->offset = reloc->offset;\n    new_reloc->next = NULL;\n\n    if (new_page->reloc_list_head == NULL)\n      new_page->reloc_list_head = new_reloc;\n\n    if (new_page->reloc_list_tail != NULL)\n      new_page->reloc_list_tail->next = new_reloc;\n\n    new_page->reloc_list_tail = new_reloc;\n\n    reloc_address = (uint8_t**) (new_page->address + new_reloc->offset);\n    reloc_target = *reloc_address;\n\n    if (reloc_target != NULL)\n    {\n      assert(reloc_target >= page->address);\n      assert(reloc_target < page->address + page->used);\n\n      *reloc_address = reloc_target - \\\n                       page->address + \\\n                       new_page->address;\n    }\n\n    reloc = reloc->next;\n  }\n\n  *duplicated = new_arena;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 832,
        "end_line": 899,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_make_ptr_relocatable#680",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_make_ptr_relocatable(     YR_ARENA* arena, void* base, ...)",
        "snippet": "int yr_arena_make_ptr_relocatable(\n    YR_ARENA* arena,\n    void* base,\n    ...)\n{\n  int result;\n\n  va_list offsets;\n  va_start(offsets, base);\n\n  result = _yr_arena_make_ptr_relocatable(arena, base, offsets);\n\n  va_end(offsets);\n\n  return result;\n}",
        "begin_line": 680,
        "end_line": 695,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_next_address#357",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_next_address(   YR_ARENA* arena, void* address, size_t offset)",
        "snippet": "void* yr_arena_next_address(\n  YR_ARENA* arena,\n  void* address,\n  size_t offset)\n{\n  YR_ARENA_PAGE* page;\n\n  page = yr_arena_page_for_address(arena, address);\n\n  assert(page != NULL);\n\n  if ((uint8_t*) address + offset >= page->address &&\n      (uint8_t*) address + offset < page->address + page->used)\n  {\n    return (uint8_t*) address + offset;\n  }\n\n  if (offset > 0)\n  {\n    offset -= page->address + page->used - (uint8_t*) address;\n    page = page->next;\n\n    while (page != NULL)\n    {\n      if (offset < page->used)\n        return page->address + offset;\n\n      offset -= page->used;\n      page = page->next;\n    }\n  }\n  else\n  {\n    offset += page->used;\n    page = page->prev;\n\n    while (page != NULL)\n    {\n      if (offset < page->used)\n        return page->address + page->used + offset;\n\n      offset += page->used;\n      page = page->prev;\n    }\n  }\n\n  return NULL;\n}",
        "begin_line": 357,
        "end_line": 404,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_page_for_address#125",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_page_for_address(     YR_ARENA* arena, void* address)",
        "snippet": "YR_ARENA_PAGE* yr_arena_page_for_address(\n    YR_ARENA* arena,\n    void* address)\n{\n  YR_ARENA_PAGE* page;\n\n  // Most of the times this function is called with an address within\n  // the current page, let's check the current page first to avoid\n  // looping through the page list.\n\n  page = arena->current_page;\n\n  if (page != NULL &&\n      (uint8_t*) address >= page->address &&\n      (uint8_t*) address < page->address + page->used)\n    return page;\n\n  page = arena->page_list_head;\n\n  while (page != NULL)\n  {\n    if ((uint8_t*) address >= page->address &&\n        (uint8_t*) address < page->address + page->used)\n      return page;\n\n    page = page->next;\n  }\n\n  return NULL;\n}",
        "begin_line": 125,
        "end_line": 154,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_reserve_memory#528",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_reserve_memory(     YR_ARENA* arena, size_t size)",
        "snippet": "int yr_arena_reserve_memory(\n    YR_ARENA* arena,\n    size_t size)\n{\n  YR_ARENA_PAGE* new_page;\n  size_t new_page_size;\n  uint8_t* new_page_address;\n\n  if (size > free_space(arena->current_page))\n  {\n    // Requested space is bigger than current page's empty space,\n    // lets calculate the size for a new page.\n\n    new_page_size = arena->current_page->size * 2;\n\n    while (new_page_size < size)\n      new_page_size *= 2;\n\n    if (arena->current_page->used == 0)\n    {\n      // Current page is not used at all, it can be reallocated.\n\n      new_page_address = (uint8_t*) yr_realloc(\n          arena->current_page->address,\n          new_page_size);\n\n      if (new_page_address == NULL)\n        return ERROR_INSUFFICIENT_MEMORY;\n\n      arena->current_page->address = new_page_address;\n      arena->current_page->size = new_page_size;\n    }\n    else\n    {\n      new_page = _yr_arena_new_page(new_page_size);\n\n      if (new_page == NULL)\n        return ERROR_INSUFFICIENT_MEMORY;\n\n      new_page->prev = arena->current_page;\n      arena->current_page->next = new_page;\n      arena->current_page = new_page;\n      arena->flags &= ~ARENA_FLAGS_COALESCED;\n    }\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 528,
        "end_line": 575,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_write_data#714",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_write_data(     YR_ARENA* arena, const void* data, size_t size, void** written_data)",
        "snippet": "int yr_arena_write_data(\n    YR_ARENA* arena,\n    const void* data,\n    size_t size,\n    void** written_data)\n{\n  void* output;\n  int result;\n\n  if (size > free_space(arena->current_page))\n  {\n    result = yr_arena_allocate_memory(arena, size, &output);\n\n    if (result != ERROR_SUCCESS)\n      return result;\n  }\n  else\n  {\n    output = arena->current_page->address + arena->current_page->used;\n    arena->current_page->used += size;\n  }\n\n  memcpy(output, data, size);\n\n  if (written_data != NULL)\n    *written_data = output;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 714,
        "end_line": 742,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_write_string#760",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_write_string(     YR_ARENA* arena, const char* string, char** written_string)",
        "snippet": "int yr_arena_write_string(\n    YR_ARENA* arena,\n    const char* string,\n    char** written_string)\n{\n  return yr_arena_write_data(\n      arena,\n      (void*) string,\n      strlen(string) + 1,\n      (void**) written_string);\n}",
        "begin_line": 760,
        "end_line": 770,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_case_combinations#684",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_case_combinations(     uint8_t* atom, int atom_length, int atom_offset, uint8_t* output_buffer)",
        "snippet": "static uint8_t* _yr_atoms_case_combinations(\n    uint8_t* atom,\n    int atom_length,\n    int atom_offset,\n    uint8_t* output_buffer)\n{\n  uint8_t c;\n  uint8_t* new_atom;\n\n  if (atom_offset + 1 < atom_length)\n    output_buffer = _yr_atoms_case_combinations(\n        atom,\n        atom_length,\n        atom_offset + 1,\n        output_buffer);\n\n  c = atom[atom_offset];\n\n  if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))\n  {\n    // Write atom length.\n    *output_buffer = atom_length;\n    output_buffer++;\n\n    memcpy(output_buffer, atom, atom_length);\n\n    new_atom = output_buffer;\n    output_buffer += atom_length;\n\n    // Swap character case.\n    if (c >= 'a' && c <= 'z')\n      new_atom[atom_offset] -= 32;\n    else\n      new_atom[atom_offset] += 32;\n\n    if (atom_offset + 1 < atom_length)\n      output_buffer = _yr_atoms_case_combinations(\n          new_atom,\n          atom_length,\n          atom_offset + 1,\n          output_buffer);\n  }\n\n  if (atom_offset == 0)\n    *output_buffer = 0;\n\n  return output_buffer;\n}",
        "begin_line": 684,
        "end_line": 731,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_case_insensitive#750",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_case_insensitive(     YR_ATOM_LIST_ITEM* atoms, YR_ATOM_LIST_ITEM** case_insensitive_atoms)",
        "snippet": "static int _yr_atoms_case_insensitive(\n    YR_ATOM_LIST_ITEM* atoms,\n    YR_ATOM_LIST_ITEM** case_insensitive_atoms)\n{\n  YR_ATOM_LIST_ITEM* atom;\n  YR_ATOM_LIST_ITEM* new_atom;\n\n  uint8_t buffer[CASE_COMBINATIONS_BUFFER_SIZE];\n  uint8_t atom_length;\n  uint8_t* atoms_cursor;\n\n  int i;\n\n  *case_insensitive_atoms = NULL;\n  atom = atoms;\n\n  while (atom != NULL)\n  {\n    _yr_atoms_case_combinations(\n        atom->atom.bytes,\n        atom->atom.length,\n        0,\n        buffer);\n\n    atoms_cursor = buffer;\n    atom_length = *atoms_cursor;\n    atoms_cursor++;\n\n    while (atom_length != 0)\n    {\n      new_atom = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));\n\n      if (new_atom == NULL)\n        return ERROR_INSUFFICIENT_MEMORY;\n\n      for (i = 0; i < atom_length; i++)\n      {\n        new_atom->atom.bytes[i] = atoms_cursor[i];\n        new_atom->atom.mask[i] = 0xFF;\n      }\n\n      new_atom->atom.length = atom_length;\n      new_atom->forward_code = atom->forward_code;\n      new_atom->backward_code = atom->backward_code;\n      new_atom->backtrack = atom->backtrack;\n      new_atom->next = *case_insensitive_atoms;\n\n      *case_insensitive_atoms = new_atom;\n\n      atoms_cursor += atom_length;\n      atom_length = *atoms_cursor;\n      atoms_cursor++;\n    }\n\n    atom = atom->next;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 750,
        "end_line": 808,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_choose#556",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_choose(     YR_ATOMS_CONFIG* config, YR_ATOM_TREE_NODE* node, YR_ATOM_LIST_ITEM** chosen_atoms, int* atoms_quality)",
        "snippet": "static int _yr_atoms_choose(\n    YR_ATOMS_CONFIG* config,\n    YR_ATOM_TREE_NODE* node,\n    YR_ATOM_LIST_ITEM** chosen_atoms,\n    int* atoms_quality)\n{\n  YR_ATOM_TREE_NODE* child;\n  YR_ATOM_LIST_ITEM* item;\n  YR_ATOM_LIST_ITEM* tail;\n\n  int shift, quality;\n\n  int max_quality = YR_MIN_ATOM_QUALITY;\n  int min_quality = YR_MAX_ATOM_QUALITY;\n\n  *chosen_atoms = NULL;\n  *atoms_quality = YR_MIN_ATOM_QUALITY;\n\n  switch (node->type)\n  {\n  case ATOM_TREE_LEAF:\n\n    item = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));\n\n    if (item == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    memcpy(&item->atom, &node->atom, sizeof(YR_ATOM));\n\n    shift = _yr_atoms_trim(&item->atom);\n\n    if (item->atom.length > 0)\n    {\n      item->forward_code = node->re_nodes[shift]->forward_code;\n      item->backward_code = node->re_nodes[shift]->backward_code;\n      item->backtrack = 0;\n      item->next = NULL;\n\n      *chosen_atoms = item;\n      *atoms_quality = config->get_atom_quality(config, &item->atom);\n    }\n    else\n    {\n      yr_free(item);\n    }\n\n    break;\n\n  case ATOM_TREE_OR:\n\n    // The choosen nodes are those coming from the highest quality child.\n\n    child = node->children_head;\n\n    while (child != NULL)\n    {\n      FAIL_ON_ERROR(_yr_atoms_choose(config, child, &item, &quality));\n\n      if (quality > max_quality)\n      {\n        max_quality = quality;\n        yr_atoms_list_destroy(*chosen_atoms);\n        *chosen_atoms = item;\n      }\n      else\n      {\n        yr_atoms_list_destroy(item);\n      }\n\n      if (max_quality == YR_MAX_ATOM_QUALITY)\n        break;\n\n      child = child->next_sibling;\n    }\n\n    *atoms_quality = max_quality;\n    break;\n\n  case ATOM_TREE_AND:\n\n    // The choosen nodes are the concatenation of the the nodes choosen from\n    // all the children.\n\n    child = node->children_head;\n\n    while (child != NULL)\n    {\n      FAIL_ON_ERROR(_yr_atoms_choose(config, child, &item, &quality));\n\n      if (quality < min_quality)\n        min_quality = quality;\n\n      if (item != NULL)\n      {\n        tail = item;\n        while (tail->next != NULL)\n          tail = tail->next;\n\n        tail->next = *chosen_atoms;\n        *chosen_atoms = item;\n      }\n\n      child = child->next_sibling;\n    }\n\n    *atoms_quality = min_quality;\n    break;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 556,
        "end_line": 666,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_clone_list_item#1251",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_clone_list_item(     YR_ATOM_LIST_ITEM* item)",
        "snippet": "static YR_ATOM_LIST_ITEM* _yr_atoms_clone_list_item(\n    YR_ATOM_LIST_ITEM* item)\n{\n  YR_ATOM_LIST_ITEM* clone = (YR_ATOM_LIST_ITEM*) yr_malloc(\n      sizeof(YR_ATOM_LIST_ITEM));\n\n  if (clone == NULL)\n    return NULL;\n\n  memcpy(clone, item, sizeof(YR_ATOM_LIST_ITEM));\n\n  return clone;\n}",
        "begin_line": 1251,
        "end_line": 1263,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_expand_wildcards#1282",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_expand_wildcards(     YR_ATOM_LIST_ITEM* atoms)",
        "snippet": "static int _yr_atoms_expand_wildcards(\n    YR_ATOM_LIST_ITEM* atoms)\n{\n  int i;\n\n  YR_ATOM_LIST_ITEM* atom = atoms;\n  YR_ATOM_LIST_ITEM* new_atom;\n  YR_ATOM_LIST_ITEM* prev_atom;\n  YR_ATOM_LIST_ITEM* next_atom;\n\n  while (atom != NULL)\n  {\n    bool expanded = false;\n\n    for (i = 0; i < atom->atom.length; i++)\n    {\n      uint16_t a, s, e, incr = 1;\n\n      switch(atom->atom.mask[i])\n      {\n        case 0x00:\n          expanded = true;\n          s = 0x00;\n          e = 0xFF;\n          break;\n\n        case 0x0F:\n          expanded = true;\n          s = atom->atom.bytes[i];\n          e = atom->atom.bytes[i] | 0xF0;\n          incr = 0x10;\n          break;\n\n        case 0xF0:\n          expanded = true;\n          s = atom->atom.bytes[i];\n          e = atom->atom.bytes[i] | 0x0F;\n          break;\n\n        default:\n          s = 0;\n          e = 0;\n      }\n\n      if (s != e)\n      {\n        atom->atom.bytes[i] = (uint8_t) s;\n        atom->atom.mask[i] = 0xFF;\n      }\n\n      prev_atom = atom;\n      next_atom = atom->next;\n\n      for (a = s + incr; a <= e; a += incr)\n      {\n        new_atom = _yr_atoms_clone_list_item(atom);\n\n        if (new_atom == NULL)\n          return ERROR_INSUFFICIENT_MEMORY;\n\n        new_atom->atom.bytes[i] = (uint8_t) a;\n        new_atom->atom.mask[i] = 0xFF;\n        new_atom->next = next_atom;\n        prev_atom->next = new_atom;\n        prev_atom = new_atom;\n      }\n    }\n\n    if (!expanded)\n      atom = atom->next;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 1282,
        "end_line": 1355,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_extract_from_re#943",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_extract_from_re(     YR_ATOMS_CONFIG* config, RE_AST* re_ast, YR_ATOM_TREE_NODE* appending_node)",
        "snippet": "static int _yr_atoms_extract_from_re(\n    YR_ATOMS_CONFIG* config,\n    RE_AST* re_ast,\n    YR_ATOM_TREE_NODE* appending_node)\n{\n  YR_STACK* stack;\n  RE_NODE* re_node;\n\n  YR_ATOM atom;\n  YR_ATOM best_atom;\n\n  struct STACK_ITEM si;\n\n  int i, shift;\n  int quality;\n  int best_quality = -1;\n  int n = 0;\n\n  YR_ATOM_TREE_NODE* and_node;\n  YR_ATOM_TREE_NODE* left_node;\n  YR_ATOM_TREE_NODE* right_node;\n\n  // The RE_NODEs most recently visited that can conform an atom (ie:\n  // RE_NODE_LITERAL, RE_NODE_MASKED_LITERAL and RE_NODE_ANY). The number of\n  // items in this array is n.\n  RE_NODE* recent_re_nodes[YR_MAX_ATOM_LENGTH];\n\n  // The RE_NODEs corresponding to the best atom found so far for the current\n  // appending node.\n  RE_NODE* best_atom_re_nodes[YR_MAX_ATOM_LENGTH];\n\n  // This holds the ATOM_TREE_OR node where leaves (ATOM_TREE_LEAF) are\n  // currently being appended.\n  YR_ATOM_TREE_NODE* current_appending_node = NULL;\n\n  // This holds the ATOM_TREE_LEAF node whose atom is currently being updated.\n  YR_ATOM_TREE_NODE* leaf = NULL;\n\n  FAIL_ON_ERROR(yr_stack_create(1024, sizeof(si), &stack));\n\n  // This first item pushed in the stack is the last one to be poped out, its\n  // sole purpose is forcing that any pending\n  si.re_node = NULL;\n  si.new_appending_node = appending_node;\n\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      yr_stack_push(stack, (void*) &si),\n      yr_stack_destroy(stack));\n\n  // Start processing the root node.\n  si.re_node = re_ast->root_node;\n\n  // Leaf nodes are initially appended to the node passed in the appending_node,\n  // argument which is the root ATOM_TREE_OR node that is empty at this point.\n  si.new_appending_node = appending_node;\n\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      yr_stack_push(stack, (void*) &si),\n      yr_stack_destroy(stack));\n\n  while (yr_stack_pop(stack, (void*) &si))\n  {\n    // Change the appending node if the item poped from the stack says so.\n    if (si.new_appending_node != NULL)\n    {\n      // Before changing the appending node let's append any pending leaf to\n      // the current appending node.\n      if (n > 0)\n      {\n        make_atom_from_re_nodes(atom, n, recent_re_nodes);\n        shift = _yr_atoms_trim(&atom);\n        quality = config->get_atom_quality(config, &atom);\n\n        FAIL_ON_NULL_WITH_CLEANUP(\n            leaf = _yr_atoms_tree_node_create(ATOM_TREE_LEAF),\n            yr_stack_destroy(stack));\n\n        if (quality > best_quality)\n        {\n          memcpy(&leaf->atom, &atom, sizeof(atom));\n          memcpy(\n              &leaf->re_nodes,\n              &recent_re_nodes[shift],\n              sizeof(recent_re_nodes) - shift * sizeof(recent_re_nodes[0]));\n        }\n        else\n        {\n          memcpy(&leaf->atom, &best_atom, sizeof(best_atom));\n          memcpy(\n              &leaf->re_nodes,\n              &best_atom_re_nodes,\n              sizeof(best_atom_re_nodes));\n        }\n\n        _yr_atoms_tree_node_append(current_appending_node, leaf);\n        n = 0;\n      }\n\n      current_appending_node = si.new_appending_node;\n    }\n\n    if (si.re_node != NULL)\n    {\n      switch(si.re_node->type)\n      {\n        case RE_NODE_LITERAL:\n        case RE_NODE_MASKED_LITERAL:\n        case RE_NODE_ANY:\n\n          if (n < YR_MAX_ATOM_LENGTH)\n          {\n            recent_re_nodes[n] = si.re_node;\n            best_atom_re_nodes[n] = si.re_node;\n            best_atom.bytes[n] = (uint8_t) si.re_node->value;\n            best_atom.mask[n] = (uint8_t) si.re_node->mask;\n            best_atom.length = ++n;\n          }\n          else if (best_quality < YR_MAX_ATOM_QUALITY)\n          {\n            make_atom_from_re_nodes(atom, n, recent_re_nodes);\n            shift = _yr_atoms_trim(&atom);\n            quality = config->get_atom_quality(config, &atom);\n\n            if (quality > best_quality)\n            {\n              for (i = 0; i < atom.length; i++)\n              {\n                best_atom.bytes[i] = atom.bytes[i];\n                best_atom.mask[i] = atom.mask[i];\n                best_atom_re_nodes[i] = recent_re_nodes[i + shift];\n              }\n\n              best_quality = quality;\n            }\n\n            for (i = 1; i < YR_MAX_ATOM_LENGTH; i++)\n              recent_re_nodes[i - 1] = recent_re_nodes[i];\n\n            recent_re_nodes[YR_MAX_ATOM_LENGTH - 1] = si.re_node;\n          }\n\n          break;\n\n        case RE_NODE_CONCAT:\n\n          re_node = si.re_node->children_tail;\n\n          // Push children right to left, they are poped left to right.\n          while (re_node != NULL)\n          {\n            si.new_appending_node = NULL;\n            si.re_node = re_node;\n\n            FAIL_ON_ERROR_WITH_CLEANUP(\n                yr_stack_push(stack, &si),\n                yr_stack_destroy(stack));\n\n            re_node = re_node->prev_sibling;\n          }\n\n          break;\n\n        case RE_NODE_ALT:\n\n          // Create ATOM_TREE_AND node with two ATOM_TREE_OR children nodes.\n          and_node = _yr_atoms_tree_node_create(ATOM_TREE_AND);\n          left_node = _yr_atoms_tree_node_create(ATOM_TREE_OR);\n          right_node = _yr_atoms_tree_node_create(ATOM_TREE_OR);\n\n          if (and_node == NULL || left_node == NULL || right_node == NULL)\n          {\n            _yr_atoms_tree_node_destroy(and_node);\n            _yr_atoms_tree_node_destroy(left_node);\n            _yr_atoms_tree_node_destroy(right_node);\n\n            yr_stack_destroy(stack);\n\n            return ERROR_INSUFFICIENT_MEMORY;\n          }\n\n          and_node->children_head = left_node;\n          and_node->children_tail = right_node;\n          left_node->next_sibling = right_node;\n\n          // Add the ATOM_TREE_AND as children of the current node.\n          _yr_atoms_tree_node_append(current_appending_node, and_node);\n\n          re_node = si.re_node;\n\n          si.new_appending_node = current_appending_node;\n          si.re_node = NULL;\n\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              yr_stack_push(stack, &si),\n              yr_stack_destroy(stack));\n\n          // RE_NODE_ALT nodes has only two children, so children_head is the\n          // left one, and children_tail is right one.\n          si.new_appending_node = right_node;\n          si.re_node = re_node->children_tail;\n\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              yr_stack_push(stack, &si),\n              yr_stack_destroy(stack));\n\n          si.new_appending_node = left_node;\n          si.re_node = re_node->children_head;\n\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              yr_stack_push(stack, &si),\n              yr_stack_destroy(stack));\n\n          break;\n\n        case RE_NODE_PLUS:\n\n          re_node = si.re_node;\n\n          si.new_appending_node = current_appending_node;\n          si.re_node = NULL;\n\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              yr_stack_push(stack, &si),\n              yr_stack_destroy(stack));\n\n          si.new_appending_node = NULL;\n          // RE_NODE_PLUS nodes has a single child, which is children_head.\n          si.re_node = re_node->children_head;\n\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              yr_stack_push(stack, &si),\n              yr_stack_destroy(stack));\n\n          break;\n\n        case RE_NODE_RANGE:\n\n          re_node = si.re_node;\n\n          si.new_appending_node = current_appending_node;\n          si.re_node = NULL;\n\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              yr_stack_push(stack, &si),\n              yr_stack_destroy(stack));\n\n          si.new_appending_node = NULL;\n          // RE_NODE_RANGE nodes has a single child, which is children_head.\n          si.re_node = re_node->children_head;\n\n          // In a regexp like /a{10,20}/ the optimal atom is 'aaaa' (assuming\n          // that YR_MAX_ATOM_LENGTH = 4) because the 'a' character must appear\n          // at least 10 times in the matching string. Each call in the loop\n          // will append one 'a' to the atom, so YR_MAX_ATOM_LENGTH iterations\n          // are enough.\n\n          for (i = 0; i < yr_min(re_node->start, YR_MAX_ATOM_LENGTH); i++)\n          {\n            FAIL_ON_ERROR_WITH_CLEANUP(\n                yr_stack_push(stack, &si),\n                yr_stack_destroy(stack));\n          }\n\n          break;\n\n        case RE_NODE_RANGE_ANY:\n        case RE_NODE_STAR:\n        case RE_NODE_CLASS:\n        case RE_NODE_WORD_CHAR:\n        case RE_NODE_NON_WORD_CHAR:\n        case RE_NODE_SPACE:\n        case RE_NODE_NON_SPACE:\n        case RE_NODE_DIGIT:\n        case RE_NODE_NON_DIGIT:\n        case RE_NODE_EMPTY:\n        case RE_NODE_ANCHOR_START:\n        case RE_NODE_ANCHOR_END:\n        case RE_NODE_WORD_BOUNDARY:\n        case RE_NODE_NON_WORD_BOUNDARY:\n\n          si.new_appending_node = current_appending_node;\n          si.re_node = NULL;\n\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              yr_stack_push(stack, &si),\n              yr_stack_destroy(stack));\n\n          break;\n\n        default:\n          assert(false);\n      }\n    }\n  }\n\n  yr_stack_destroy(stack);\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 943,
        "end_line": 1241,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_list_concat#454",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_list_concat(     YR_ATOM_LIST_ITEM* list1, YR_ATOM_LIST_ITEM* list2)",
        "snippet": "static YR_ATOM_LIST_ITEM* _yr_atoms_list_concat(\n    YR_ATOM_LIST_ITEM* list1,\n    YR_ATOM_LIST_ITEM* list2)\n{\n  YR_ATOM_LIST_ITEM* item;\n\n  if (list1 == NULL)\n    return list2;\n\n  item = list1;\n\n  while (item->next != NULL)\n  {\n    item = item->next;\n  }\n\n  item->next = list2;\n  return list1;\n}",
        "begin_line": 454,
        "end_line": 472,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_tree_destroy#419",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_tree_destroy(     YR_ATOM_TREE* atom_tree)",
        "snippet": "static void _yr_atoms_tree_destroy(\n    YR_ATOM_TREE* atom_tree)\n{\n  _yr_atoms_tree_node_destroy(atom_tree->root_node);\n  yr_free(atom_tree);\n}",
        "begin_line": 419,
        "end_line": 424,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_tree_node_append#399",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_tree_node_append(     YR_ATOM_TREE_NODE* dest, YR_ATOM_TREE_NODE* node)",
        "snippet": "static void _yr_atoms_tree_node_append(\n    YR_ATOM_TREE_NODE* dest,\n    YR_ATOM_TREE_NODE* node)\n{\n  if (dest->children_head == NULL)\n    dest->children_head = node;\n\n  if (dest->children_tail != NULL)\n    dest->children_tail->next_sibling = node;\n\n  dest->children_tail = node;\n}",
        "begin_line": 399,
        "end_line": 410,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_tree_node_create#343",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_tree_node_create(     uint8_t type)",
        "snippet": "static YR_ATOM_TREE_NODE* _yr_atoms_tree_node_create(\n    uint8_t type)\n{\n  YR_ATOM_TREE_NODE* new_node = (YR_ATOM_TREE_NODE*) \\\n      yr_malloc(sizeof(YR_ATOM_TREE_NODE));\n\n  if (new_node != NULL)\n  {\n    new_node->type = type;\n    new_node->atom.length = 0;\n    new_node->next_sibling = NULL;\n    new_node->children_head = NULL;\n    new_node->children_tail = NULL;\n  }\n\n  return new_node;\n}",
        "begin_line": 343,
        "end_line": 359,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_tree_node_destroy#368",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_tree_node_destroy(     YR_ATOM_TREE_NODE* node)",
        "snippet": "static void _yr_atoms_tree_node_destroy(\n    YR_ATOM_TREE_NODE* node)\n{\n  YR_ATOM_TREE_NODE* child;\n  YR_ATOM_TREE_NODE* next_child;\n\n  if (node == NULL)\n    return;\n\n  if (node->type == ATOM_TREE_OR || node->type == ATOM_TREE_AND)\n  {\n    child = node->children_head;\n\n    while (child != NULL)\n    {\n      next_child = child->next_sibling;\n      _yr_atoms_tree_node_destroy(child);\n      child = next_child;\n    }\n  }\n\n  yr_free(node);\n}",
        "begin_line": 368,
        "end_line": 390,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_trim#490",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_trim(     YR_ATOM* atom)",
        "snippet": "int _yr_atoms_trim(\n    YR_ATOM* atom)\n{\n  int mask_00 = 0;\n  int mask_ff = 0;\n\n  int i, trim_left = 0;\n\n  while (trim_left < atom->length && atom->mask[trim_left] == 0)\n    trim_left++;\n\n  while (atom->length > trim_left && atom->mask[atom->length - 1] == 0)\n    atom->length--;\n\n  atom->length -= trim_left;\n\n  if (atom->length == 0)\n    return 0;\n\n  // At this point the actual atom goes from i to i + atom->length and the\n  // first and last byte in the atom are known (mask == 0xFF). Now count the\n  // number of known and unknown bytes in the atom (mask == 0xFF and\n  // mask == 0x00 respectively).\n\n  for (i = 0; i < atom->length; i++)\n  {\n    if (atom->mask[trim_left + i] == 0xFF)\n      mask_ff++;\n    else if (atom->mask[trim_left + i] == 0x00)\n      mask_00++;\n  }\n\n  // If the number of unknown bytes is >= than the number of known bytes\n  // it doesn't make sense the to use this atom, so we use the a single byte\n  // atom with the first known byte. If YR_MAX_ATOM_LENGTH == 4 this happens\n  // only when the atom is like { XX ?? ?? YY }, so using the first known\n  // atom is good enough. For larger values of YR_MAX_ATOM_LENGTH this is not\n  // the most efficient solution, as better atoms could be choosen. For\n  // example, in { XX ?? ?? ?? YY ZZ } the best atom is { YY ZZ } not { XX }.\n  // But let's keep it like this for simplicity.\n\n  if (mask_00 >= mask_ff)\n    atom->length = 1;\n\n  if (trim_left == 0)\n    return 0;\n\n  // Shift bytes and mask trim_left positions to the left.\n\n  for (i = 0; i < YR_MAX_ATOM_LENGTH - trim_left; i++)\n  {\n    atom->bytes[i] = atom->bytes[trim_left + i];\n    atom->mask[i] = atom->mask[trim_left + i];\n  }\n\n  return trim_left;\n}",
        "begin_line": 490,
        "end_line": 546,
        "is_bug": false
    },
    {
        "name": "libyara.atoms._yr_atoms_wide#867",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms._yr_atoms_wide(     YR_ATOM_LIST_ITEM* atoms, YR_ATOM_LIST_ITEM** wide_atoms)",
        "snippet": "static int _yr_atoms_wide(\n    YR_ATOM_LIST_ITEM* atoms,\n    YR_ATOM_LIST_ITEM** wide_atoms)\n{\n  YR_ATOM_LIST_ITEM* atom;\n  YR_ATOM_LIST_ITEM* new_atom;\n\n  int i;\n\n  *wide_atoms = NULL;\n  atom = atoms;\n\n  while (atom != NULL)\n  {\n    new_atom = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));\n\n    if (new_atom == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    for (i = 0; i < YR_MAX_ATOM_LENGTH; i++)\n    {\n      new_atom->atom.bytes[i] = 0;\n      new_atom->atom.mask[i] = 0xFF;\n    }\n\n    for (i = 0; i < atom->atom.length; i++)\n    {\n      if (i * 2 < YR_MAX_ATOM_LENGTH)\n        new_atom->atom.bytes[i * 2] = atom->atom.bytes[i];\n      else\n        break;\n    }\n\n    new_atom->atom.length = yr_min(atom->atom.length * 2, YR_MAX_ATOM_LENGTH);\n    new_atom->forward_code = atom->forward_code;\n    new_atom->backward_code = atom->backward_code;\n    new_atom->backtrack = atom->backtrack * 2;\n    new_atom->next = *wide_atoms;\n\n    *wide_atoms = new_atom;\n\n    atom = atom->next;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 867,
        "end_line": 912,
        "is_bug": false
    },
    {
        "name": "libyara.atoms.yr_atoms_extract_from_re#1366",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms.yr_atoms_extract_from_re(     YR_ATOMS_CONFIG* config, RE_AST* re_ast, int flags, YR_ATOM_LIST_ITEM** atoms, int* min_atom_quality)",
        "snippet": "int yr_atoms_extract_from_re(\n    YR_ATOMS_CONFIG* config,\n    RE_AST* re_ast,\n    int flags,\n    YR_ATOM_LIST_ITEM** atoms,\n    int* min_atom_quality)\n{\n  YR_ATOM_TREE* atom_tree = (YR_ATOM_TREE*) yr_malloc(sizeof(YR_ATOM_TREE));\n\n  YR_ATOM_LIST_ITEM* wide_atoms;\n  YR_ATOM_LIST_ITEM* case_insensitive_atoms;\n\n  if (atom_tree == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  atom_tree->root_node = _yr_atoms_tree_node_create(ATOM_TREE_OR);\n\n  if (atom_tree->root_node == NULL)\n  {\n    _yr_atoms_tree_destroy(atom_tree);\n    return ERROR_INSUFFICIENT_MEMORY;\n  }\n\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      _yr_atoms_extract_from_re(config, re_ast, atom_tree->root_node),\n      _yr_atoms_tree_destroy(atom_tree));\n\n  // Initialize atom list\n  *atoms = NULL;\n\n  // Choose the atoms that will be used.\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      _yr_atoms_choose(config, atom_tree->root_node, atoms, min_atom_quality),\n      _yr_atoms_tree_destroy(atom_tree));\n\n  _yr_atoms_tree_destroy(atom_tree);\n\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      _yr_atoms_expand_wildcards(*atoms),\n      {\n        yr_atoms_list_destroy(*atoms);\n        *atoms = NULL;\n      });\n\n  if (flags & STRING_GFLAGS_WIDE)\n  {\n    FAIL_ON_ERROR_WITH_CLEANUP(\n        _yr_atoms_wide(*atoms, &wide_atoms),\n        {\n          yr_atoms_list_destroy(*atoms);\n          yr_atoms_list_destroy(wide_atoms);\n          *atoms = NULL;\n        });\n\n    if (flags & STRING_GFLAGS_ASCII)\n    {\n      *atoms = _yr_atoms_list_concat(*atoms, wide_atoms);\n    }\n    else\n    {\n      yr_atoms_list_destroy(*atoms);\n      *atoms = wide_atoms;\n    }\n  }\n\n  if (flags & STRING_GFLAGS_NO_CASE)\n  {\n    FAIL_ON_ERROR_WITH_CLEANUP(\n        _yr_atoms_case_insensitive(*atoms, &case_insensitive_atoms),\n        {\n          yr_atoms_list_destroy(*atoms);\n          yr_atoms_list_destroy(case_insensitive_atoms);\n          *atoms = NULL;\n        });\n\n    *atoms = _yr_atoms_list_concat(*atoms, case_insensitive_atoms);\n  }\n\n  // No atoms has been extracted, let's add a zero-length atom.\n\n  if (*atoms == NULL)\n  {\n    *atoms = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));\n\n    if (*atoms == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    (*atoms)->atom.length = 0;\n    (*atoms)->backtrack = 0;\n    (*atoms)->forward_code = re_ast->root_node->forward_code;\n    (*atoms)->backward_code = NULL;\n    (*atoms)->next = NULL;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 1366,
        "end_line": 1461,
        "is_bug": false
    },
    {
        "name": "libyara.atoms.yr_atoms_extract_from_string#1470",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms.yr_atoms_extract_from_string(     YR_ATOMS_CONFIG* config, uint8_t* string, int32_t string_length, int flags, YR_ATOM_LIST_ITEM** atoms, int* min_atom_quality)",
        "snippet": "int yr_atoms_extract_from_string(\n    YR_ATOMS_CONFIG* config,\n    uint8_t* string,\n    int32_t string_length,\n    int flags,\n    YR_ATOM_LIST_ITEM** atoms,\n    int* min_atom_quality)\n{\n  YR_ATOM_LIST_ITEM* item;\n  YR_ATOM_LIST_ITEM* case_insensitive_atoms;\n  YR_ATOM_LIST_ITEM* xor_atoms;\n  YR_ATOM_LIST_ITEM* wide_atoms;\n\n  YR_ATOM atom;\n\n  int quality, max_quality;\n  int i;\n\n  item = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));\n\n  if (item == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  item->forward_code = NULL;\n  item->backward_code = NULL;\n  item->next = NULL;\n  item->backtrack = 0;\n\n  item->atom.length = yr_min(string_length, YR_MAX_ATOM_LENGTH);\n\n  for (i = 0; i < item->atom.length; i++)\n  {\n    item->atom.bytes[i] = string[i];\n    item->atom.mask[i] = 0xFF;\n  }\n\n  max_quality = config->get_atom_quality(config, &item->atom);\n\n  atom.length = YR_MAX_ATOM_LENGTH;\n  memset(atom.mask, 0xFF, atom.length);\n\n  for (i = YR_MAX_ATOM_LENGTH;\n       i < string_length && max_quality < YR_MAX_ATOM_QUALITY;\n       i++)\n  {\n    atom.length = YR_MAX_ATOM_LENGTH;\n    memcpy(atom.bytes, string + i - YR_MAX_ATOM_LENGTH + 1, atom.length);\n\n    quality = config->get_atom_quality(config, &atom);\n\n    if (quality > max_quality)\n    {\n      memcpy(&item->atom, &atom, sizeof(atom));\n      item->backtrack = i - YR_MAX_ATOM_LENGTH + 1;\n      max_quality = quality;\n    }\n  }\n\n  *atoms = item;\n  *min_atom_quality = max_quality;\n\n  if (flags & STRING_GFLAGS_WIDE)\n  {\n    FAIL_ON_ERROR_WITH_CLEANUP(\n        _yr_atoms_wide(*atoms, &wide_atoms),\n        {\n          yr_atoms_list_destroy(*atoms);\n          yr_atoms_list_destroy(wide_atoms);\n          *atoms = NULL;\n        });\n\n    if (flags & STRING_GFLAGS_ASCII)\n    {\n      *atoms = _yr_atoms_list_concat(*atoms, wide_atoms);\n    }\n    else\n    {\n      yr_atoms_list_destroy(*atoms);\n      *atoms = wide_atoms;\n    }\n  }\n\n  if (flags & STRING_GFLAGS_NO_CASE)\n  {\n    FAIL_ON_ERROR_WITH_CLEANUP(\n        _yr_atoms_case_insensitive(*atoms, &case_insensitive_atoms),\n        {\n          yr_atoms_list_destroy(*atoms);\n          yr_atoms_list_destroy(case_insensitive_atoms);\n          *atoms = NULL;\n        });\n\n    *atoms = _yr_atoms_list_concat(*atoms, case_insensitive_atoms);\n  }\n\n  if (flags & STRING_GFLAGS_XOR)\n  {\n    FAIL_ON_ERROR_WITH_CLEANUP(\n      _yr_atoms_xor(*atoms, &xor_atoms),\n      {\n        yr_atoms_list_destroy(*atoms);\n        yr_atoms_list_destroy(xor_atoms);\n        *atoms = NULL;\n      });\n\n    if (flags & STRING_GFLAGS_ASCII ||\n        flags & STRING_GFLAGS_WIDE ||\n        flags & STRING_GFLAGS_NO_CASE)\n    {\n      *atoms = _yr_atoms_list_concat(*atoms, xor_atoms);\n    }\n    else\n    {\n      yr_atoms_list_destroy(*atoms);\n      *atoms = xor_atoms;\n    }\n\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 1470,
        "end_line": 1590,
        "is_bug": false
    },
    {
        "name": "libyara.atoms.yr_atoms_heuristic_quality#112",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms.yr_atoms_heuristic_quality(     YR_ATOMS_CONFIG* config, YR_ATOM* atom)",
        "snippet": "int yr_atoms_heuristic_quality(\n    YR_ATOMS_CONFIG* config,\n    YR_ATOM* atom)\n{\n  YR_BITMASK seen_bytes[YR_BITMASK_SIZE(256)];\n\n  int quality = 0;\n  int unique_bytes = 0;\n  int masked_nibbles = 0;\n  int i;\n\n  assert(atom->length <= YR_MAX_ATOM_LENGTH);\n\n  yr_bitmask_clear_all(seen_bytes);\n\n  for (i = 0; i < atom->length; i++)\n  {\n    switch (atom->mask[i])\n    {\n      case 0x00:\n        masked_nibbles += 2;\n        break;\n      case 0x0F:\n        masked_nibbles += 1;\n        quality += 4;\n        break;\n      case 0xF0:\n        masked_nibbles += 1;\n        quality += 4;\n        break;\n      case 0xFF:\n        switch (atom->bytes[i])\n        {\n          case 0x00:\n          case 0x20:\n          case 0xCC:\n          case 0xFF:\n            // Common bytes contribute less to the quality than the rest.\n            quality += 15;\n            break;\n          default:\n            // Bytes in the a-z and A-Z ranges have a slightly lower quality\n            // than the rest. We want to favor atoms that contain bytes outside\n            // those ranges because they generate less additional atoms during\n            // calls to _yr_atoms_case_combinations.\n            if ( yr_lowercase[atom->bytes[i]] >= 'a' &&\n                 yr_lowercase[atom->bytes[i]] <= 'z')\n              quality += 19;\n            else\n              quality += 20;\n        };\n        if (!yr_bitmask_isset(seen_bytes, atom->bytes[i]))\n        {\n          yr_bitmask_set(seen_bytes, atom->bytes[i]);\n          unique_bytes++;\n        }\n    }\n  }\n\n  // If all the bytes in the atom are equal and very common, let's penalize\n  // it heavily.\n\n  if (unique_bytes == 1 &&\n      (yr_bitmask_isset(seen_bytes, 0x00) ||\n       yr_bitmask_isset(seen_bytes, 0x20) ||\n       yr_bitmask_isset(seen_bytes, 0xCC) ||\n       yr_bitmask_isset(seen_bytes, 0xFF)))\n  {\n    quality -= 10 * atom->length;\n  }\n\n  quality -= masked_nibbles * 3;\n\n  return YR_MAX_ATOM_QUALITY - 20 * YR_MAX_ATOM_LENGTH + quality;\n}",
        "begin_line": 112,
        "end_line": 186,
        "is_bug": false
    },
    {
        "name": "libyara.atoms.yr_atoms_list_destroy#433",
        "src_path": "libyara/atoms.c",
        "class_name": "libyara.atoms",
        "signature": "libyara.atoms.yr_atoms_list_destroy(     YR_ATOM_LIST_ITEM* list_head)",
        "snippet": "void yr_atoms_list_destroy(\n    YR_ATOM_LIST_ITEM* list_head)\n{\n  YR_ATOM_LIST_ITEM* item = list_head;\n  YR_ATOM_LIST_ITEM* next;\n\n  while (item != NULL)\n  {\n    next = item->next;\n    yr_free(item);\n    item = next;\n  }\n}",
        "begin_line": 433,
        "end_line": 445,
        "is_bug": false
    },
    {
        "name": "libyara.bitmask.yr_bitmask_find_non_colliding_offset#63",
        "src_path": "libyara/bitmask.c",
        "class_name": "libyara.bitmask",
        "signature": "libyara.bitmask.yr_bitmask_find_non_colliding_offset(     YR_BITMASK* a, YR_BITMASK* b, uint32_t len_a, uint32_t len_b, uint32_t* off_a)",
        "snippet": "uint32_t yr_bitmask_find_non_colliding_offset(\n    YR_BITMASK* a,\n    YR_BITMASK* b,\n    uint32_t len_a,\n    uint32_t len_b,\n    uint32_t* off_a)\n{\n  uint32_t i, j, k;\n\n  // Ensure that the first bit of bitmask B is set, as this function does some\n  // optimizations that rely on that.\n  assert(yr_bitmask_isset(b, 0));\n\n  // Skip all slots that are filled with 1s. It's safe to do that because the\n  // first bit of B is 1, so we won't be able to accommodate B at any offset\n  // within such slots.\n  for (i = *off_a / YR_BITMASK_SLOT_BITS;\n       i <= len_a / YR_BITMASK_SLOT_BITS && a[i] == -1L;\n       i++);\n\n  *off_a = i;\n\n  for (; i <= len_a / YR_BITMASK_SLOT_BITS; i++)\n  {\n    // The slot is filled with 1s, we can safely skip it.\n    if (a[i] == -1L)\n      continue;\n\n    for (j = 0; j <= yr_min(len_a, YR_BITMASK_SLOT_BITS - 1); j++)\n    {\n      bool found = true;\n\n      for (k = 0; k <= len_b / YR_BITMASK_SLOT_BITS; k++)\n      {\n        YR_BITMASK m = b[k] << j;\n\n        if (j > 0 && k > 0)\n          m |= b[k - 1] >> (YR_BITMASK_SLOT_BITS - j);\n\n        if ((i + k <= len_a / YR_BITMASK_SLOT_BITS) && (m & a[i + k]) != 0)\n        {\n          found = false;\n          break ;\n        }\n      }\n\n      if (found)\n        return i * YR_BITMASK_SLOT_BITS + j;\n    }\n  }\n\n  return len_a;\n}",
        "begin_line": 63,
        "end_line": 115,
        "is_bug": false
    },
    {
        "name": "libyara.compiler._yr_compiler_compile_rules#645",
        "src_path": "libyara/compiler.c",
        "class_name": "libyara.compiler",
        "signature": "libyara.compiler._yr_compiler_compile_rules(     YR_COMPILER* compiler)",
        "snippet": "static int _yr_compiler_compile_rules(\n    YR_COMPILER* compiler)\n{\n  YARA_RULES_FILE_HEADER* rules_file_header = NULL;\n  YR_ARENA* arena = NULL;\n  YR_RULE null_rule;\n  YR_EXTERNAL_VARIABLE null_external;\n  YR_AC_TABLES tables;\n\n  uint8_t halt = OP_HALT;\n  int result;\n\n  // Write halt instruction at the end of code.\n  yr_arena_write_data(\n      compiler->code_arena,\n      &halt,\n      sizeof(uint8_t),\n      NULL);\n\n  // Write a null rule indicating the end.\n  memset(&null_rule, 0xFA, sizeof(YR_RULE));\n  null_rule.g_flags = RULE_GFLAGS_NULL;\n\n  yr_arena_write_data(\n      compiler->rules_arena,\n      &null_rule,\n      sizeof(YR_RULE),\n      NULL);\n\n  // Write a null external the end.\n  memset(&null_external, 0xFA, sizeof(YR_EXTERNAL_VARIABLE));\n  null_external.type = EXTERNAL_VARIABLE_TYPE_NULL;\n\n  yr_arena_write_data(\n      compiler->externals_arena,\n      &null_external,\n      sizeof(YR_EXTERNAL_VARIABLE),\n      NULL);\n\n  // Write Aho-Corasick automaton to arena.\n  result = yr_ac_compile(\n      compiler->automaton,\n      compiler->automaton_arena,\n      &tables);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_create(1024, ARENA_FLAGS_RELOCATABLE, &arena);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_allocate_struct(\n        arena,\n        sizeof(YARA_RULES_FILE_HEADER),\n        (void**) &rules_file_header,\n        offsetof(YARA_RULES_FILE_HEADER, rules_list_head),\n        offsetof(YARA_RULES_FILE_HEADER, externals_list_head),\n        offsetof(YARA_RULES_FILE_HEADER, code_start),\n        offsetof(YARA_RULES_FILE_HEADER, ac_match_table),\n        offsetof(YARA_RULES_FILE_HEADER, ac_transition_table),\n        EOL);\n\n  if (result == ERROR_SUCCESS)\n  {\n    rules_file_header->rules_list_head = (YR_RULE*) yr_arena_base_address(\n        compiler->rules_arena);\n\n    rules_file_header->externals_list_head = (YR_EXTERNAL_VARIABLE*)\n\t\tyr_arena_base_address(compiler->externals_arena);\n\n    rules_file_header->code_start = (uint8_t*) yr_arena_base_address(\n        compiler->code_arena);\n\n    rules_file_header->ac_match_table = tables.matches;\n    rules_file_header->ac_transition_table = tables.transitions;\n    rules_file_header->ac_tables_size = compiler->automaton->tables_size;\n  }\n\n  if (result == ERROR_SUCCESS)\n  {\n    result = yr_arena_append(\n        arena,\n        compiler->code_arena);\n  }\n\n  if (result == ERROR_SUCCESS)\n  {\n    compiler->code_arena = NULL;\n    result = yr_arena_append(\n        arena,\n        compiler->re_code_arena);\n  }\n\n  if (result == ERROR_SUCCESS)\n  {\n    compiler->re_code_arena = NULL;\n    result = yr_arena_append(\n        arena,\n        compiler->rules_arena);\n  }\n\n  if (result == ERROR_SUCCESS)\n  {\n    compiler->rules_arena = NULL;\n    result = yr_arena_append(\n        arena,\n        compiler->strings_arena);\n  }\n\n  if (result == ERROR_SUCCESS)\n  {\n    compiler->strings_arena = NULL;\n    result = yr_arena_append(\n        arena,\n        compiler->externals_arena);\n  }\n\n  if (result == ERROR_SUCCESS)\n  {\n    compiler->externals_arena = NULL;\n    result = yr_arena_append(\n        arena,\n        compiler->namespaces_arena);\n  }\n\n  if (result == ERROR_SUCCESS)\n  {\n    compiler->namespaces_arena = NULL;\n    result = yr_arena_append(\n        arena,\n        compiler->metas_arena);\n  }\n\n  if (result == ERROR_SUCCESS)\n  {\n    compiler->metas_arena = NULL;\n    result = yr_arena_append(\n        arena,\n        compiler->sz_arena);\n  }\n\n  if (result == ERROR_SUCCESS)\n  {\n    compiler->sz_arena = NULL;\n    result = yr_arena_append(\n        arena,\n        compiler->automaton_arena);\n  }\n\n  if (result == ERROR_SUCCESS)\n  {\n    compiler->automaton_arena = NULL;\n    result = yr_arena_append(\n        arena,\n        compiler->matches_arena);\n  }\n\n  if (result == ERROR_SUCCESS)\n  {\n    compiler->matches_arena = NULL;\n    compiler->compiled_rules_arena = arena;\n    result = yr_arena_coalesce(arena);\n  }\n  else\n  {\n    yr_arena_destroy(arena);\n  }\n\n  return result;\n}",
        "begin_line": 645,
        "end_line": 812,
        "is_bug": false
    },
    {
        "name": "libyara.compiler._yr_compiler_set_namespace#483",
        "src_path": "libyara/compiler.c",
        "class_name": "libyara.compiler",
        "signature": "libyara.compiler._yr_compiler_set_namespace(     YR_COMPILER* compiler, const char* namespace_)",
        "snippet": "static int _yr_compiler_set_namespace(\n    YR_COMPILER* compiler,\n    const char* namespace_)\n{\n  YR_NAMESPACE* ns;\n\n  char* ns_name;\n  int result;\n  int i;\n  bool found;\n\n  ns = (YR_NAMESPACE*) yr_arena_base_address(compiler->namespaces_arena);\n  found = false;\n\n  for (i = 0; i < compiler->namespaces_count; i++)\n  {\n    if (strcmp(ns->name, namespace_) == 0)\n    {\n      found = true;\n      break;\n    }\n\n    ns = (YR_NAMESPACE*) yr_arena_next_address(\n        compiler->namespaces_arena,\n        ns,\n        sizeof(YR_NAMESPACE));\n  }\n\n  if (!found)\n  {\n    result = yr_arena_write_string(\n        compiler->sz_arena,\n        namespace_,\n        &ns_name);\n\n    if (result == ERROR_SUCCESS)\n      result = yr_arena_allocate_struct(\n          compiler->namespaces_arena,\n          sizeof(YR_NAMESPACE),\n          (void**) &ns,\n          offsetof(YR_NAMESPACE, name),\n          EOL);\n\n    if (result != ERROR_SUCCESS)\n      return result;\n\n    ns->name = ns_name;\n\n    for (i = 0; i < YR_MAX_THREADS; i++)\n      ns->t_flags[i] = 0;\n\n    compiler->namespaces_count++;\n  }\n\n  compiler->current_namespace = ns;\n  return ERROR_SUCCESS;\n}",
        "begin_line": 483,
        "end_line": 539,
        "is_bug": false
    },
    {
        "name": "libyara.compiler.yr_compiler_add_string#618",
        "src_path": "libyara/compiler.c",
        "class_name": "libyara.compiler",
        "signature": "libyara.compiler.yr_compiler_add_string(     YR_COMPILER* compiler, const char* rules_string, const char* namespace_)",
        "snippet": "YR_API int yr_compiler_add_string(\n    YR_COMPILER* compiler,\n    const char* rules_string,\n    const char* namespace_)\n{\n  // Don't allow calls to yr_compiler_add_string() after\n  // yr_compiler_get_rules() has been called.\n\n  assert(compiler->compiled_rules_arena == NULL);\n\n  // Don't allow calls to yr_compiler_add_string() if a previous call to\n  // yr_compiler_add_XXXX failed.\n\n  assert(compiler->errors == 0);\n\n  if (namespace_ != NULL)\n    compiler->last_error = _yr_compiler_set_namespace(compiler, namespace_);\n  else\n    compiler->last_error = _yr_compiler_set_namespace(compiler, \"default\");\n\n  if (compiler->last_error != ERROR_SUCCESS)\n    return ++compiler->errors;\n\n  return yr_lex_parse_rules_string(rules_string, compiler);\n}",
        "begin_line": 618,
        "end_line": 642,
        "is_bug": false
    },
    {
        "name": "libyara.compiler.yr_compiler_create#153",
        "src_path": "libyara/compiler.c",
        "class_name": "libyara.compiler",
        "signature": "libyara.compiler.yr_compiler_create(     YR_COMPILER** compiler)",
        "snippet": "YR_API int yr_compiler_create(\n    YR_COMPILER** compiler)\n{\n  int result;\n  YR_COMPILER* new_compiler;\n\n  new_compiler = (YR_COMPILER*) yr_calloc(1, sizeof(YR_COMPILER));\n\n  if (new_compiler == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  new_compiler->errors = 0;\n  new_compiler->callback = NULL;\n  new_compiler->include_callback = _yr_compiler_default_include_callback;\n  new_compiler->incl_clbk_user_data = NULL;\n  new_compiler->include_free = _yr_compiler_default_include_free;\n  new_compiler->re_ast_callback = NULL;\n  new_compiler->re_ast_clbk_user_data = NULL;\n  new_compiler->last_error = ERROR_SUCCESS;\n  new_compiler->last_error_line = 0;\n  new_compiler->current_line = 0;\n  new_compiler->file_name_stack_ptr = 0;\n  new_compiler->fixup_stack_head = NULL;\n  new_compiler->loop_depth = 0;\n  new_compiler->loop_for_of_mem_offset = -1;\n  new_compiler->compiled_rules_arena = NULL;\n  new_compiler->namespaces_count = 0;\n  new_compiler->current_rule = NULL;\n  new_compiler->atoms_config.get_atom_quality = yr_atoms_heuristic_quality;\n  new_compiler->atoms_config.quality_warning_threshold = \\\n      YR_ATOM_QUALITY_WARNING_THRESHOLD;\n\n  result = yr_hash_table_create(10007, &new_compiler->rules_table);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_hash_table_create(10007, &new_compiler->objects_table);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_hash_table_create(101, &new_compiler->strings_table);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_create(\n        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->sz_arena);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_create(\n        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->rules_arena);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_create(\n        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->strings_arena);\n\n  if (result == ERROR_SUCCESS)\n      result = yr_arena_create(\n        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->code_arena);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_create(\n        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->re_code_arena);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_create(\n        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->externals_arena);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_create(\n        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->namespaces_arena);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_create(\n        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->metas_arena);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_create(\n        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->automaton_arena);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_create(\n        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->matches_arena);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_ac_automaton_create(&new_compiler->automaton);\n\n  if (result == ERROR_SUCCESS)\n  {\n    *compiler = new_compiler;\n  }\n  else  // if error, do cleanup\n  {\n    yr_compiler_destroy(new_compiler);\n  }\n\n  return result;\n}",
        "begin_line": 153,
        "end_line": 246,
        "is_bug": false
    },
    {
        "name": "libyara.compiler.yr_compiler_destroy#249",
        "src_path": "libyara/compiler.c",
        "class_name": "libyara.compiler",
        "signature": "libyara.compiler.yr_compiler_destroy(     YR_COMPILER* compiler)",
        "snippet": "YR_API void yr_compiler_destroy(\n    YR_COMPILER* compiler)\n{\n  YR_FIXUP* fixup;\n  int i;\n\n  yr_arena_destroy(compiler->compiled_rules_arena);\n  yr_arena_destroy(compiler->sz_arena);\n  yr_arena_destroy(compiler->rules_arena);\n  yr_arena_destroy(compiler->strings_arena);\n  yr_arena_destroy(compiler->code_arena);\n  yr_arena_destroy(compiler->re_code_arena);\n  yr_arena_destroy(compiler->externals_arena);\n  yr_arena_destroy(compiler->namespaces_arena);\n  yr_arena_destroy(compiler->metas_arena);\n  yr_arena_destroy(compiler->automaton_arena);\n  yr_arena_destroy(compiler->matches_arena);\n\n  yr_ac_automaton_destroy(compiler->automaton);\n\n  yr_hash_table_destroy(\n      compiler->rules_table,\n      NULL);\n\n  yr_hash_table_destroy(\n      compiler->strings_table,\n      NULL);\n\n  yr_hash_table_destroy(\n      compiler->objects_table,\n      (YR_HASH_TABLE_FREE_VALUE_FUNC) yr_object_destroy);\n\n  if (compiler->  atoms_config.free_quality_table)\n    yr_free(compiler->atoms_config.quality_table);\n\n  for (i = 0; i < compiler->file_name_stack_ptr; i++)\n    yr_free(compiler->file_name_stack[i]);\n\n  fixup = compiler->fixup_stack_head;\n\n  while (fixup != NULL)\n  {\n    YR_FIXUP* next_fixup = fixup->next;\n    yr_free(fixup);\n    fixup = next_fixup;\n  }\n\n  yr_free(compiler);\n}",
        "begin_line": 249,
        "end_line": 297,
        "is_bug": false
    },
    {
        "name": "libyara.compiler.yr_compiler_get_error_message#1008",
        "src_path": "libyara/compiler.c",
        "class_name": "libyara.compiler",
        "signature": "libyara.compiler.yr_compiler_get_error_message(     YR_COMPILER* compiler, char* buffer, int buffer_size)",
        "snippet": "YR_API char* yr_compiler_get_error_message(\n    YR_COMPILER* compiler,\n    char* buffer,\n    int buffer_size)\n{\n  uint32_t max_strings_per_rule;\n\n  switch(compiler->last_error)\n  {\n    case ERROR_INSUFFICIENT_MEMORY:\n      snprintf(buffer, buffer_size, \"not enough memory\");\n      break;\n    case ERROR_DUPLICATED_IDENTIFIER:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"duplicated identifier \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_DUPLICATED_STRING_IDENTIFIER:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"duplicated string identifier \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_DUPLICATED_TAG_IDENTIFIER:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"duplicated tag identifier \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_DUPLICATED_META_IDENTIFIER:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"duplicated metadata identifier \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_DUPLICATED_LOOP_IDENTIFIER:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"duplicated loop identifier \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_UNDEFINED_STRING:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"undefined string \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_UNDEFINED_IDENTIFIER:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"undefined identifier \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_UNREFERENCED_STRING:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"unreferenced string \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_EMPTY_STRING:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"empty string \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_NOT_A_STRUCTURE:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"\\\"%s\\\" is not a structure\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_NOT_INDEXABLE:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"\\\"%s\\\" is not an array or dictionary\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_NOT_A_FUNCTION:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"\\\"%s\\\" is not a function\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_INVALID_FIELD_NAME:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"invalid field name \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_MISPLACED_ANONYMOUS_STRING:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"wrong use of anonymous string\");\n      break;\n    case ERROR_INCLUDES_CIRCULAR_REFERENCE:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"include circular reference\");\n      break;\n    case ERROR_INCLUDE_DEPTH_EXCEEDED:\n      snprintf(buffer,\n          buffer_size,\n          \"too many levels of included rules\");\n      break;\n    case ERROR_LOOP_NESTING_LIMIT_EXCEEDED:\n      snprintf(buffer,\n          buffer_size,\n          \"loop nesting limit exceeded\");\n      break;\n    case ERROR_NESTED_FOR_OF_LOOP:\n      snprintf(buffer,\n          buffer_size,\n          \"'for <quantifier> of <string set>' loops can't be nested\");\n      break;\n    case ERROR_UNKNOWN_MODULE:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"unknown module \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_INVALID_MODULE_NAME:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"invalid module name \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_DUPLICATED_STRUCTURE_MEMBER:\n      snprintf(buffer,\n          buffer_size,\n          \"duplicated structure member\");\n      break;\n    case ERROR_WRONG_ARGUMENTS:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"wrong arguments for function \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_WRONG_RETURN_TYPE:\n      snprintf(buffer,\n          buffer_size,\n          \"wrong return type for overloaded function\");\n      break;\n    case ERROR_INVALID_HEX_STRING:\n    case ERROR_INVALID_REGULAR_EXPRESSION:\n    case ERROR_SYNTAX_ERROR:\n    case ERROR_WRONG_TYPE:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"%s\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_INTERNAL_FATAL_ERROR:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"internal fatal error\");\n      break;\n    case ERROR_DIVISION_BY_ZERO:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"division by zero\");\n      break;\n    case ERROR_REGULAR_EXPRESSION_TOO_LARGE:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"regular expression is too large\");\n      break;\n    case ERROR_REGULAR_EXPRESSION_TOO_COMPLEX:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"regular expression is too complex\");\n      break;\n    case ERROR_TOO_MANY_STRINGS:\n       yr_get_configuration(\n          YR_CONFIG_MAX_STRINGS_PER_RULE,\n          &max_strings_per_rule);\n       snprintf(\n          buffer,\n          buffer_size,\n          \"too many strings in rule \\\"%s\\\" (limit: %d)\",\n          compiler->last_error_extra_info,\n          max_strings_per_rule);\n      break;\n    case ERROR_INTEGER_OVERFLOW:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"integer overflow in \\\"%s\\\"\",\n          compiler->last_error_extra_info);\n      break;\n    case ERROR_COULD_NOT_READ_FILE:\n      snprintf(\n          buffer,\n          buffer_size,\n          \"could not read file\");\n      break;\n  }\n\n  return buffer;\n}",
        "begin_line": 1008,
        "end_line": 1230,
        "is_bug": false
    },
    {
        "name": "libyara.compiler.yr_compiler_get_rules#815",
        "src_path": "libyara/compiler.c",
        "class_name": "libyara.compiler",
        "signature": "libyara.compiler.yr_compiler_get_rules(     YR_COMPILER* compiler, YR_RULES** rules)",
        "snippet": "YR_API int yr_compiler_get_rules(\n    YR_COMPILER* compiler,\n    YR_RULES** rules)\n{\n  YR_RULES* yara_rules;\n  YARA_RULES_FILE_HEADER* rules_file_header;\n\n  // Don't allow calls to yr_compiler_get_rules() if a previous call to\n  // yr_compiler_add_XXXX failed.\n\n  assert(compiler->errors == 0);\n\n  *rules = NULL;\n\n  if (compiler->compiled_rules_arena == NULL)\n     FAIL_ON_ERROR(_yr_compiler_compile_rules(compiler));\n\n  yara_rules = (YR_RULES*) yr_malloc(sizeof(YR_RULES));\n\n  if (yara_rules == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      yr_arena_duplicate(compiler->compiled_rules_arena, &yara_rules->arena),\n      yr_free(yara_rules));\n\n  rules_file_header = (YARA_RULES_FILE_HEADER*) yr_arena_base_address(\n      yara_rules->arena);\n\n  yara_rules->externals_list_head = rules_file_header->externals_list_head;\n  yara_rules->rules_list_head = rules_file_header->rules_list_head;\n  yara_rules->ac_match_table = rules_file_header->ac_match_table;\n  yara_rules->ac_transition_table = rules_file_header->ac_transition_table;\n  yara_rules->ac_tables_size = rules_file_header->ac_tables_size;\n  yara_rules->code_start = rules_file_header->code_start;\n  yara_rules->time_cost = 0;\n\n  memset(yara_rules->tidx_mask, 0, sizeof(yara_rules->tidx_mask));\n\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      yr_mutex_create(&yara_rules->mutex),\n      // cleanup\n      yr_arena_destroy(yara_rules->arena);\n      yr_free(yara_rules));\n\n  *rules = yara_rules;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 815,
        "end_line": 863,
        "is_bug": false
    },
    {
        "name": "libyara.compiler.yr_compiler_set_callback#300",
        "src_path": "libyara/compiler.c",
        "class_name": "libyara.compiler",
        "signature": "libyara.compiler.yr_compiler_set_callback(     YR_COMPILER* compiler, YR_COMPILER_CALLBACK_FUNC callback, void* user_data)",
        "snippet": "YR_API void yr_compiler_set_callback(\n    YR_COMPILER* compiler,\n    YR_COMPILER_CALLBACK_FUNC callback,\n    void* user_data)\n{\n  compiler->callback = callback;\n  compiler->user_data = user_data;\n}",
        "begin_line": 300,
        "end_line": 307,
        "is_bug": false
    },
    {
        "name": "libyara.exec.yr_execute_code#190",
        "src_path": "libyara/exec.c",
        "class_name": "libyara.exec",
        "signature": "libyara.exec.yr_execute_code(     YR_SCAN_CONTEXT* context)",
        "snippet": "int yr_execute_code(\n    YR_SCAN_CONTEXT* context)\n{\n  int64_t mem[MEM_SIZE];\n  int32_t sp = 0;\n\n  const uint8_t* ip = context->rules->code_start;\n\n  YR_VALUE args[YR_MAX_FUNCTION_ARGS];\n  YR_VALUE *stack;\n  YR_VALUE r1;\n  YR_VALUE r2;\n  YR_VALUE r3;\n\n  uint64_t elapsed_time;\n\n  #ifdef PROFILING_ENABLED\n  uint64_t start_time;\n  YR_RULE* current_rule = NULL;\n  #endif\n\n  YR_INIT_RULE_ARGS init_rule_args;\n\n  YR_RULE* rule;\n  YR_MATCH* match;\n  YR_OBJECT_FUNCTION* function;\n  YR_OBJECT** obj_ptr;\n  YR_ARENA* obj_arena;\n\n  char* identifier;\n  char* args_fmt;\n\n  int i;\n  int found;\n  int count;\n  int result = ERROR_SUCCESS;\n  int cycle = 0;\n  int tidx = context->tidx;\n  int stack_size;\n\n  bool stop = false;\n\n  uint8_t opcode;\n\n  yr_get_configuration(YR_CONFIG_STACK_SIZE, (void*) &stack_size);\n\n  stack = (YR_VALUE*) yr_malloc(stack_size * sizeof(YR_VALUE));\n\n  if (stack == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      yr_arena_create(1024, 0, &obj_arena),\n      yr_free(stack));\n\n  #ifdef PROFILING_ENABLED\n  start_time = yr_stopwatch_elapsed_us(&context->stopwatch);\n  #endif\n\n  #if PARANOID_EXEC\n  memset(mem, 0, MEM_SIZE * sizeof(mem[0]));\n  #endif\n\n  while(!stop)\n  {\n    opcode = *ip;\n    ip++;\n\n    switch(opcode)\n    {\n      case OP_NOP:\n        break;\n\n      case OP_HALT:\n        assert(sp == 0); // When HALT is reached the stack should be empty.\n        stop = true;\n        break;\n\n      case OP_PUSH:\n        r1.i = *(uint64_t*)(ip);\n        ip += sizeof(uint64_t);\n        push(r1);\n        break;\n\n      case OP_POP:\n        pop(r1);\n        break;\n\n      case OP_CLEAR_M:\n        r1.i = *(uint64_t*)(ip);\n        ip += sizeof(uint64_t);\n        #if PARANOID_EXEC\n        ensure_within_mem(r1.i);\n        #endif\n        mem[r1.i] = 0;\n        break;\n\n      case OP_ADD_M:\n        r1.i = *(uint64_t*)(ip);\n        ip += sizeof(uint64_t);\n        #if PARANOID_EXEC\n        ensure_within_mem(r1.i);\n        #endif\n        pop(r2);\n        if (!is_undef(r2))\n          mem[r1.i] += r2.i;\n        break;\n\n      case OP_INCR_M:\n        r1.i = *(uint64_t*)(ip);\n        ip += sizeof(uint64_t);\n        #if PARANOID_EXEC\n        ensure_within_mem(r1.i);\n        #endif\n        mem[r1.i]++;\n        break;\n\n      case OP_PUSH_M:\n        r1.i = *(uint64_t*)(ip);\n        ip += sizeof(uint64_t);\n        #if PARANOID_EXEC\n        ensure_within_mem(r1.i);\n        #endif\n        r1.i = mem[r1.i];\n        push(r1);\n        break;\n\n      case OP_POP_M:\n        r1.i = *(uint64_t*)(ip);\n        ip += sizeof(uint64_t);\n        #if PARANOID_EXEC\n        ensure_within_mem(r1.i);\n        #endif\n        pop(r2);\n        mem[r1.i] = r2.i;\n        break;\n\n      case OP_SWAPUNDEF:\n        r1.i = *(uint64_t*)(ip);\n        ip += sizeof(uint64_t);\n        #if PARANOID_EXEC\n        ensure_within_mem(r1.i);\n        #endif\n        pop(r2);\n\n        if (is_undef(r2))\n        {\n          r1.i = mem[r1.i];\n          push(r1);\n        }\n        else\n        {\n          push(r2);\n        }\n        break;\n\n      case OP_JNUNDEF:\n        pop(r1);\n        push(r1);\n\n        ip = jmp_if(!is_undef(r1), ip);\n        break;\n\n      case OP_JLE:\n        pop(r2);\n        pop(r1);\n        push(r1);\n        push(r2);\n\n        ip = jmp_if(r1.i <= r2.i, ip);\n        break;\n\n      case OP_JTRUE:\n        pop(r1);\n        push(r1);\n\n        ip = jmp_if(!is_undef(r1) && r1.i, ip);\n        break;\n\n      case OP_JFALSE:\n        pop(r1);\n        push(r1);\n\n        ip = jmp_if(is_undef(r1) || !r1.i, ip);\n        break;\n\n      case OP_AND:\n        pop(r2);\n        pop(r1);\n\n        if (is_undef(r1) || is_undef(r2))\n          r1.i = 0;\n        else\n          r1.i = r1.i && r2.i;\n\n        push(r1);\n        break;\n\n      case OP_OR:\n        pop(r2);\n        pop(r1);\n\n        if (is_undef(r1))\n        {\n          push(r2);\n        }\n        else if (is_undef(r2))\n        {\n          push(r1);\n        }\n        else\n        {\n          r1.i = r1.i || r2.i;\n          push(r1);\n        }\n        break;\n\n      case OP_NOT:\n        pop(r1);\n\n        if (is_undef(r1))\n          r1.i = UNDEFINED;\n        else\n          r1.i= !r1.i;\n\n        push(r1);\n        break;\n\n      case OP_MOD:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        if (r2.i != 0)\n          r1.i = r1.i % r2.i;\n        else\n          r1.i = UNDEFINED;\n        push(r1);\n        break;\n\n      case OP_SHR:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        if (r2.i < 0)\n          r1.i = UNDEFINED;\n        else if (r2.i < 64)\n          r1.i = r1.i >> r2.i;\n        else\n          r1.i = 0;\n        push(r1);\n        break;\n\n      case OP_SHL:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        if (r2.i < 0)\n          r1.i = UNDEFINED;\n        else if (r2.i < 64)\n          r1.i = r1.i << r2.i;\n        else\n          r1.i = 0;\n        push(r1);\n        break;\n\n      case OP_BITWISE_NOT:\n        pop(r1);\n        ensure_defined(r1);\n        r1.i = ~r1.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_AND:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i & r2.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_OR:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i | r2.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_XOR:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i ^ r2.i;\n        push(r1);\n        break;\n\n      case OP_PUSH_RULE:\n        rule = *(YR_RULE**)(ip);\n        ip += sizeof(uint64_t);\n        if (RULE_IS_DISABLED(rule))\n          r1.i = UNDEFINED;\n        else\n          r1.i = rule->t_flags[tidx] & RULE_TFLAGS_MATCH ? 1 : 0;\n        push(r1);\n        break;\n\n      case OP_INIT_RULE:\n        memcpy(&init_rule_args, ip, sizeof(init_rule_args));\n        #ifdef PROFILING_ENABLED\n        current_rule = init_rule_args.rule;\n        #endif\n        if (RULE_IS_DISABLED(init_rule_args.rule))\n          ip = init_rule_args.jmp_addr;\n        else\n          ip += sizeof(init_rule_args);\n        break;\n\n      case OP_MATCH_RULE:\n        pop(r1);\n        rule = *(YR_RULE**)(ip);\n        ip += sizeof(uint64_t);\n\n        if (!is_undef(r1) && r1.i)\n          rule->t_flags[tidx] |= RULE_TFLAGS_MATCH;\n        else if (RULE_IS_GLOBAL(rule))\n          rule->ns->t_flags[tidx] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL;\n\n        #ifdef PROFILING_ENABLED\n        elapsed_time = yr_stopwatch_elapsed_us(&context->stopwatch);\n        rule->time_cost_per_thread[tidx] += (elapsed_time - start_time);\n        start_time = elapsed_time;\n        #endif\n\n        assert(sp == 0); // at this point the stack should be empty.\n        break;\n\n      case OP_OBJ_LOAD:\n        identifier = *(char**)(ip);\n        ip += sizeof(uint64_t);\n\n        r1.o = (YR_OBJECT*) yr_hash_table_lookup(\n            context->objects_table,\n            identifier,\n            NULL);\n\n        assert(r1.o != NULL);\n        push(r1);\n        break;\n\n      case OP_OBJ_FIELD:\n        identifier = *(char**)(ip);\n        ip += sizeof(uint64_t);\n\n        pop(r1);\n        ensure_defined(r1);\n\n        r1.o = yr_object_lookup_field(r1.o, identifier);\n\n        assert(r1.o != NULL);\n        push(r1);\n        break;\n\n      case OP_OBJ_VALUE:\n        pop(r1);\n        ensure_defined(r1);\n\n        #if PARANOID_EXEC\n        check_object_canary(r1.o);\n        #endif\n\n        switch(r1.o->type)\n        {\n          case OBJECT_TYPE_INTEGER:\n            r1.i = r1.o->value.i;\n            break;\n\n          case OBJECT_TYPE_FLOAT:\n            if (isnan(r1.o->value.d))\n              r1.i = UNDEFINED;\n            else\n              r1.d = r1.o->value.d;\n            break;\n\n          case OBJECT_TYPE_STRING:\n            if (r1.o->value.ss == NULL)\n              r1.i = UNDEFINED;\n            else\n              r1.ss = r1.o->value.ss;\n            break;\n\n          default:\n            assert(false);\n        }\n\n        push(r1);\n        break;\n\n      case OP_INDEX_ARRAY:\n        pop(r1);  // index\n        pop(r2);  // array\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n\n        assert(r2.o->type == OBJECT_TYPE_ARRAY);\n\n        #if PARANOID_EXEC\n        check_object_canary(r2.o);\n        #endif\n\n        r1.o = yr_object_array_get_item(r2.o, 0, (int) r1.i);\n\n        if (r1.o == NULL)\n          r1.i = UNDEFINED;\n\n        push(r1);\n        break;\n\n      case OP_LOOKUP_DICT:\n        pop(r1);  // key\n        pop(r2);  // dictionary\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n\n        assert(r2.o->type == OBJECT_TYPE_DICTIONARY);\n\n        #if PARANOID_EXEC\n        check_object_canary(r2.o);\n        #endif\n\n        r1.o = yr_object_dict_get_item(\n            r2.o, 0, r1.ss->c_string);\n\n        if (r1.o == NULL)\n          r1.i = UNDEFINED;\n\n        push(r1);\n        break;\n\n      case OP_CALL:\n        args_fmt = *(char**)(ip);\n        ip += sizeof(uint64_t);\n\n        i = (int) strlen(args_fmt);\n        count = 0;\n\n        #if PARANOID_EXEC\n        if (i > YR_MAX_FUNCTION_ARGS)\n        {\n          stop = true;\n          result = ERROR_INTERNAL_FATAL_ERROR;\n          break;\n        }\n        #endif\n\n        // pop arguments from stack and copy them to args array\n\n        while (i > 0)\n        {\n          pop(r1);\n\n          if (is_undef(r1))  // count the number of undefined args\n            count++;\n\n          args[i - 1] = r1;\n          i--;\n        }\n\n        pop(r2);\n        ensure_defined(r2);\n\n        #if PARANOID_EXEC\n        check_object_canary(r2.o);\n        #endif\n\n        if (count > 0)\n        {\n          // if there are undefined args, result for function call\n          // is undefined as well.\n\n          r1.i = UNDEFINED;\n          push(r1);\n          break;\n        }\n\n        function = object_as_function(r2.o);\n        result = ERROR_INTERNAL_FATAL_ERROR;\n\n        for (i = 0; i < YR_MAX_OVERLOADED_FUNCTIONS; i++)\n        {\n          if (function->prototypes[i].arguments_fmt == NULL)\n            break;\n\n          if (strcmp(function->prototypes[i].arguments_fmt, args_fmt) == 0)\n          {\n            result = function->prototypes[i].code(args, context, function);\n            break;\n          }\n        }\n\n        // if i == YR_MAX_OVERLOADED_FUNCTIONS at this point no matching\n        // prototype was found, but this shouldn't happen.\n\n        assert(i < YR_MAX_OVERLOADED_FUNCTIONS);\n\n        // make a copy of the returned object and push the copy into the stack\n        // function->return_obj can't be pushed because it can change in\n        // subsequent calls to the same function.\n\n        if (result == ERROR_SUCCESS)\n          result = yr_object_copy(function->return_obj, &r1.o);\n\n        // a pointer to the copied object is stored in a arena in order to\n        // free the object before exiting yr_execute_code\n\n        if (result == ERROR_SUCCESS)\n          result = yr_arena_write_data(obj_arena, &r1.o, sizeof(r1.o), NULL);\n\n        stop = (result != ERROR_SUCCESS);\n        push(r1);\n        break;\n\n      case OP_FOUND:\n        pop(r1);\n        r1.i = r1.s->matches[tidx].tail != NULL ? 1 : 0;\n        push(r1);\n        break;\n\n      case OP_FOUND_AT:\n        pop(r2);\n        pop(r1);\n\n        if (is_undef(r1))\n        {\n          r1.i = 0;\n          push(r1);\n          break;\n        }\n\n        match = r2.s->matches[tidx].head;\n        r3.i = false;\n\n        while (match != NULL)\n        {\n          if (r1.i == match->base + match->offset)\n          {\n            r3.i = true;\n            break;\n          }\n\n          if (r1.i < match->base + match->offset)\n            break;\n\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_FOUND_IN:\n        pop(r3);\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n\n        match = r3.s->matches[tidx].head;\n        r3.i = false;\n\n        while (match != NULL && !r3.i)\n        {\n          if (match->base + match->offset >= r1.i &&\n              match->base + match->offset <= r2.i)\n          {\n            r3.i = true;\n          }\n\n          if (match->base + match->offset > r2.i)\n            break;\n\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_COUNT:\n        pop(r1);\n\n        #if PARANOID_EXEC\n        // Make sure that the string pointer is within the rules arena.\n        if (yr_arena_page_for_address(context->rules->arena, r1.p) == NULL)\n          return ERROR_INTERNAL_FATAL_ERROR;\n        #endif\n\n        r1.i = r1.s->matches[tidx].count;\n        push(r1);\n        break;\n\n      case OP_OFFSET:\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n\n        match = r2.s->matches[tidx].head;\n        i = 1;\n        r3.i = UNDEFINED;\n\n        while (match != NULL && r3.i == UNDEFINED)\n        {\n          if (r1.i == i)\n            r3.i = match->base + match->offset;\n\n          i++;\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_LENGTH:\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n\n        match = r2.s->matches[tidx].head;\n        i = 1;\n        r3.i = UNDEFINED;\n\n        while (match != NULL && r3.i == UNDEFINED)\n        {\n          if (r1.i == i)\n            r3.i = match->match_length;\n\n          i++;\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_OF:\n        found = 0;\n        count = 0;\n        pop(r1);\n\n        while (!is_undef(r1))\n        {\n          if (r1.s->matches[tidx].tail != NULL)\n            found++;\n          count++;\n          pop(r1);\n        }\n\n        pop(r2);\n\n        if (is_undef(r2))\n          r1.i = found >= count ? 1 : 0;\n        else\n          r1.i = found >= r2.i ? 1 : 0;\n\n        push(r1);\n        break;\n\n      case OP_FILESIZE:\n        r1.i = context->file_size;\n        push(r1);\n        break;\n\n      case OP_ENTRYPOINT:\n        r1.i = context->entry_point;\n        push(r1);\n        break;\n\n      case OP_INT8:\n        pop(r1);\n        r1.i = read_int8_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT16:\n        pop(r1);\n        r1.i = read_int16_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT32:\n        pop(r1);\n        r1.i = read_int32_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT8:\n        pop(r1);\n        r1.i = read_uint8_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT16:\n        pop(r1);\n        r1.i = read_uint16_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT32:\n        pop(r1);\n        r1.i = read_uint32_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT8BE:\n        pop(r1);\n        r1.i = read_int8_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT16BE:\n        pop(r1);\n        r1.i = read_int16_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT32BE:\n        pop(r1);\n        r1.i = read_int32_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT8BE:\n        pop(r1);\n        r1.i = read_uint8_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT16BE:\n        pop(r1);\n        r1.i = read_uint16_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT32BE:\n        pop(r1);\n        r1.i = read_uint32_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_CONTAINS:\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n\n        r1.i = memmem(r1.ss->c_string, r1.ss->length,\n                      r2.ss->c_string, r2.ss->length) != NULL;\n        push(r1);\n        break;\n\n      case OP_IMPORT:\n        r1.i = *(uint64_t*)(ip);\n        ip += sizeof(uint64_t);\n\n        result = yr_modules_load((char*) r1.p, context);\n\n        if (result != ERROR_SUCCESS)\n          stop = true;\n\n        break;\n\n      case OP_MATCHES:\n\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r2);\n        ensure_defined(r1);\n\n        if (r1.ss->length == 0)\n        {\n          r1.i = false;\n          push(r1);\n          break;\n        }\n\n        result = yr_re_exec(\n          context,\n          (uint8_t*) r2.re->code,\n          (uint8_t*) r1.ss->c_string,\n          r1.ss->length,\n          0,\n          r2.re->flags | RE_FLAGS_SCAN,\n          NULL,\n          NULL,\n          &found);\n\n        if (result != ERROR_SUCCESS)\n          stop = true;\n\n        r1.i = found >= 0;\n        push(r1);\n        break;\n\n      case OP_INT_TO_DBL:\n\n        r1.i = *(uint64_t*)(ip);\n        ip += sizeof(uint64_t);\n\n        #if PARANOID_EXEC\n        if (r1.i > sp || sp - r1.i >= stack_size)\n        {\n          stop = true;\n          result = ERROR_INTERNAL_FATAL_ERROR;\n          break;\n        }\n        #endif\n\n        r2 = stack[sp - r1.i];\n\n        if (is_undef(r2))\n          stack[sp - r1.i].i = UNDEFINED;\n        else\n          stack[sp - r1.i].d = (double) r2.i;\n        break;\n\n      case OP_STR_TO_BOOL:\n        pop(r1);\n        ensure_defined(r1);\n        r1.i = r1.ss->length > 0;\n        push(r1);\n        break;\n\n      case OP_INT_EQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i == r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_NEQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i != r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_LT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i < r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_GT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i > r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_LE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i <= r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_GE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i >= r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_ADD:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i + r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_SUB:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i - r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_MUL:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i * r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_DIV:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        if (r2.i != 0)\n          r1.i = r1.i / r2.i;\n        else\n          r1.i = UNDEFINED;\n        push(r1);\n        break;\n\n      case OP_INT_MINUS:\n        pop(r1);\n        ensure_defined(r1);\n        r1.i = -r1.i;\n        push(r1);\n        break;\n\n      case OP_DBL_LT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d < r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_GT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d > r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_LE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d <= r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_GE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d >= r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_EQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = fabs(r1.d - r2.d) < DBL_EPSILON;\n        push(r1);\n        break;\n\n      case OP_DBL_NEQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = fabs(r1.d - r2.d) >= DBL_EPSILON;\n        push(r1);\n        break;\n\n      case OP_DBL_ADD:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d + r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_SUB:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d - r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_MUL:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d * r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_DIV:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d / r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_MINUS:\n        pop(r1);\n        ensure_defined(r1);\n        r1.d = -r1.d;\n        push(r1);\n        break;\n\n      case OP_STR_EQ:\n      case OP_STR_NEQ:\n      case OP_STR_LT:\n      case OP_STR_LE:\n      case OP_STR_GT:\n      case OP_STR_GE:\n\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n\n        switch(opcode)\n        {\n          case OP_STR_EQ:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) == 0);\n            break;\n          case OP_STR_NEQ:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) != 0);\n            break;\n          case OP_STR_LT:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) < 0);\n            break;\n          case OP_STR_LE:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) <= 0);\n            break;\n          case OP_STR_GT:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) > 0);\n            break;\n          case OP_STR_GE:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) >= 0);\n            break;\n        }\n\n        push(r1);\n        break;\n\n      default:\n        // Unknown instruction, this shouldn't happen.\n        assert(false);\n    }\n\n    // Check for timeout every 10 instruction cycles. If timeout == 0 it means\n    // no timeout at all.\n\n    if (context->timeout > 0L && ++cycle == 10)\n    {\n      elapsed_time = yr_stopwatch_elapsed_us(&context->stopwatch);\n\n      if (elapsed_time > context->timeout)\n      {\n        #ifdef PROFILING_ENABLED\n        assert(current_rule != NULL);\n        current_rule->time_cost_per_thread[tidx] += elapsed_time - start_time;\n        #endif\n        result = ERROR_SCAN_TIMEOUT;\n        stop = true;\n      }\n\n      cycle = 0;\n    }\n  }\n\n  obj_ptr = (YR_OBJECT**) yr_arena_base_address(obj_arena);\n\n  while (obj_ptr != NULL)\n  {\n    yr_object_destroy(*obj_ptr);\n\n    obj_ptr = (YR_OBJECT**) yr_arena_next_address(\n        obj_arena, obj_ptr, sizeof(YR_OBJECT*));\n  }\n\n  yr_arena_destroy(obj_arena);\n  yr_modules_unload_all(context);\n  yr_free(stack);\n\n  return result;\n}",
        "begin_line": 190,
        "end_line": 1307,
        "is_bug": false
    },
    {
        "name": "libyara.exefiles.yr_get_elf_type#131",
        "src_path": "libyara/exefiles.c",
        "class_name": "libyara.exefiles",
        "signature": "libyara.exefiles.yr_get_elf_type(     const uint8_t* buffer, size_t buffer_length)",
        "snippet": "int yr_get_elf_type(\n    const uint8_t* buffer,\n    size_t buffer_length)\n{\n  elf_ident_t* elf_ident;\n\n  if (buffer_length < sizeof(elf_ident_t))\n    return 0;\n\n  elf_ident = (elf_ident_t*) buffer;\n\n  if (yr_le32toh(elf_ident->magic) != ELF_MAGIC)\n  {\n    return 0;\n  }\n\n  switch (elf_ident->_class) {\n    case ELF_CLASS_32:\n      if (buffer_length < sizeof(elf32_header_t))\n      {\n        return 0;\n      }\n      break;\n    case ELF_CLASS_64:\n      if (buffer_length < sizeof(elf64_header_t))\n      {\n        return 0;\n      }\n      break;\n    default:\n      /* Unexpected class */\n      return 0;\n  }\n\n  return elf_ident->_class;\n}",
        "begin_line": 131,
        "end_line": 166,
        "is_bug": false
    },
    {
        "name": "libyara.exefiles.yr_get_entry_point_offset#347",
        "src_path": "libyara/exefiles.c",
        "class_name": "libyara.exefiles",
        "signature": "libyara.exefiles.yr_get_entry_point_offset(     const uint8_t* buffer, size_t buffer_length)",
        "snippet": "uint64_t yr_get_entry_point_offset(\n    const uint8_t* buffer,\n    size_t buffer_length)\n{\n  PIMAGE_NT_HEADERS32 pe_header;\n  elf32_header_t* elf_header32;\n  elf64_header_t* elf_header64;\n\n  pe_header = yr_get_pe_header(buffer, buffer_length);\n\n  if (pe_header != NULL)\n  {\n    return yr_pe_rva_to_offset(\n        pe_header,\n        yr_le32toh(pe_header->OptionalHeader.AddressOfEntryPoint),\n        buffer_length - ((uint8_t*) pe_header - buffer));\n  }\n\n  switch(yr_get_elf_type(buffer, buffer_length))\n  {\n    case ELF_CLASS_32:\n      elf_header32 = (elf32_header_t*) buffer;\n      return yr_elf_rva_to_offset_32(\n          elf_header32,\n          yr_le32toh(elf_header32->entry),\n          buffer_length);\n\n    case ELF_CLASS_64:\n      elf_header64 = (elf64_header_t*) buffer;\n      return yr_elf_rva_to_offset_64(\n          elf_header64,\n          yr_le64toh(elf_header64->entry),\n          buffer_length);\n  }\n\n  return UNDEFINED;\n}",
        "begin_line": 347,
        "end_line": 383,
        "is_bug": false
    },
    {
        "name": "libyara.exefiles.yr_get_pe_header#47",
        "src_path": "libyara/exefiles.c",
        "class_name": "libyara.exefiles",
        "signature": "libyara.exefiles.yr_get_pe_header(     const uint8_t* buffer, size_t buffer_length)",
        "snippet": "PIMAGE_NT_HEADERS32 yr_get_pe_header(\n    const uint8_t* buffer,\n    size_t buffer_length)\n{\n  PIMAGE_DOS_HEADER mz_header;\n  PIMAGE_NT_HEADERS32 pe_header;\n\n  size_t headers_size = 0;\n\n  if (buffer_length < sizeof(IMAGE_DOS_HEADER))\n    return NULL;\n\n  mz_header = (PIMAGE_DOS_HEADER) buffer;\n\n  if (yr_le16toh(mz_header->e_magic) != IMAGE_DOS_SIGNATURE)\n    return NULL;\n\n  if ((int32_t) yr_le32toh(mz_header->e_lfanew) < 0)\n    return NULL;\n\n  headers_size = yr_le32toh(mz_header->e_lfanew) + \\\n                 sizeof(pe_header->Signature) + \\\n                 sizeof(IMAGE_FILE_HEADER);\n\n  if (buffer_length < headers_size)\n    return NULL;\n\n  pe_header = (PIMAGE_NT_HEADERS32) (buffer + yr_le32toh(mz_header->e_lfanew));\n\n  headers_size += sizeof(IMAGE_OPTIONAL_HEADER32);\n\n  if (yr_le32toh(pe_header->Signature) == IMAGE_NT_SIGNATURE &&\n      (yr_le16toh(pe_header->FileHeader.Machine) == IMAGE_FILE_MACHINE_I386 ||\n       yr_le16toh(pe_header->FileHeader.Machine) == IMAGE_FILE_MACHINE_AMD64) &&\n      buffer_length > headers_size)\n  {\n    return pe_header;\n  }\n  else\n  {\n    return NULL;\n  }\n}",
        "begin_line": 47,
        "end_line": 89,
        "is_bug": false
    },
    {
        "name": "libyara.exefiles.yr_pe_rva_to_offset#92",
        "src_path": "libyara/exefiles.c",
        "class_name": "libyara.exefiles",
        "signature": "libyara.exefiles.yr_pe_rva_to_offset(     PIMAGE_NT_HEADERS32 pe_header, uint64_t rva, size_t buffer_length)",
        "snippet": "uint64_t yr_pe_rva_to_offset(\n    PIMAGE_NT_HEADERS32 pe_header,\n    uint64_t rva,\n    size_t buffer_length)\n{\n  int i = 0;\n  PIMAGE_SECTION_HEADER section;\n  DWORD section_rva;\n  DWORD section_offset;\n\n  section = IMAGE_FIRST_SECTION(pe_header);\n  section_rva = 0;\n  section_offset = 0;\n\n  while(i < MIN(yr_le16toh(pe_header->FileHeader.NumberOfSections), 60))\n  {\n    if ((uint8_t*) section - \\\n        (uint8_t*) pe_header + sizeof(IMAGE_SECTION_HEADER) < buffer_length)\n    {\n      if (rva >= section->VirtualAddress &&\n          section_rva <= yr_le32toh(section->VirtualAddress))\n      {\n        section_rva = yr_le32toh(section->VirtualAddress);\n        section_offset = yr_le32toh(section->PointerToRawData);\n      }\n\n      section++;\n      i++;\n    }\n    else\n    {\n      return 0;\n    }\n  }\n\n  return section_offset + (rva - section_rva);\n}",
        "begin_line": 92,
        "end_line": 128,
        "is_bug": false
    },
    {
        "name": "libyara.grammar.yara_yyparse#1518",
        "src_path": "libyara/grammar.c",
        "class_name": "libyara.grammar",
        "signature": "libyara.grammar.)",
        "snippet": "int\nyyparse (void *yyscanner, YR_COMPILER* compiler)\n{\n/* The lookahead symbol.  */\nint yychar;\n\n\n/* The semantic value of the lookahead symbol.  */\n/* Default value used for initialization, for pacifying older GCCs\n   or non-GCC compilers.  */\nYY_INITIAL_VALUE (static YYSTYPE yyval_default;)\nYYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n\n    /* Number of syntax errors so far.  */\n    int yynerrs;\n\n    yy_state_fast_t yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yy_state_t yyssa[YYINITDEPTH];\n    yy_state_t *yyss;\n    yy_state_t *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYPTRDIFF_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYPTRDIFF_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n  goto yysetstate;\n\n\n/*------------------------------------------------------------.\n| yynewstate -- push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\nyynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n\n/*--------------------------------------------------------------------.\n| yysetstate -- set current state (the top of the stack) to yystate.  |\n`--------------------------------------------------------------------*/\nyysetstate:\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);\n  YY_IGNORE_USELESS_CAST_BEGIN\n  *yyssp = YY_CAST (yy_state_t, yystate);\n  YY_IGNORE_USELESS_CAST_END\n\n  if (yyss + yystacksize - 1 <= yyssp)\n#if !defined yyoverflow && !defined YYSTACK_RELOCATE\n    goto yyexhaustedlab;\n#else\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYPTRDIFF_T yysize = yyssp - yyss + 1;\n\n# if defined yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        yy_state_t *yyss1 = yyss;\n        YYSTYPE *yyvs1 = yyvs;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * YYSIZEOF (*yyssp),\n                    &yyvs1, yysize * YYSIZEOF (*yyvsp),\n                    &yystacksize);\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n# else /* defined YYSTACK_RELOCATE */\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yy_state_t *yyss1 = yyss;\n        union yyalloc *yyptr =\n          YY_CAST (union yyalloc *,\n                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n# undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YY_IGNORE_USELESS_CAST_BEGIN\n      YYDPRINTF ((stderr, \"Stack size increased to %ld\\n\",\n                  YY_CAST (long, yystacksize)));\n      YY_IGNORE_USELESS_CAST_END\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex (&yylval, yyscanner, compiler);\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n  case 8:\n#line 259 \"grammar.y\"\n      {\n        _yr_compiler_pop_file_name(compiler);\n      }\n#line 1779 \"grammar.c\"\n    break;\n\n  case 9:\n#line 267 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));\n\n        yr_free((yyvsp[0].sized_string));\n\n        fail_if_error(result);\n      }\n#line 1791 \"grammar.c\"\n    break;\n\n  case 10:\n#line 279 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_reduce_rule_declaration_phase_1(\n            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string), &(yyval.rule)));\n      }\n#line 1800 \"grammar.c\"\n    break;\n\n  case 11:\n#line 284 \"grammar.y\"\n      {\n        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1\n\n        rule->tags = (yyvsp[-3].c_string);\n        rule->metas = (yyvsp[-1].meta);\n        rule->strings = (yyvsp[0].string);\n      }\n#line 1812 \"grammar.c\"\n    break;\n\n  case 12:\n#line 292 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_rule_declaration_phase_2(\n            yyscanner, (yyvsp[-7].rule)); // rule created in phase 1\n\n        yr_free((yyvsp[-8].c_string));\n\n        fail_if_error(result);\n      }\n#line 1825 \"grammar.c\"\n    break;\n\n  case 13:\n#line 305 \"grammar.y\"\n      {\n        (yyval.meta) = NULL;\n      }\n#line 1833 \"grammar.c\"\n    break;\n\n  case 14:\n#line 309 \"grammar.y\"\n      {\n        int result;\n\n        // Each rule have a list of meta-data info, consisting in a\n        // sequence of YR_META structures. The last YR_META structure does\n        // not represent a real meta-data, it's just a end-of-list marker\n        // identified by a specific type (META_TYPE_NULL). Here we\n        // write the end-of-list marker.\n\n        YR_META null_meta;\n\n        memset(&null_meta, 0xFF, sizeof(YR_META));\n        null_meta.type = META_TYPE_NULL;\n\n        result = yr_arena_write_data(\n            compiler->metas_arena,\n            &null_meta,\n            sizeof(YR_META),\n            NULL);\n\n        (yyval.meta) = (yyvsp[0].meta);\n\n        fail_if_error(result);\n      }\n#line 1862 \"grammar.c\"\n    break;\n\n  case 15:\n#line 338 \"grammar.y\"\n      {\n        (yyval.string) = NULL;\n      }\n#line 1870 \"grammar.c\"\n    break;\n\n  case 16:\n#line 342 \"grammar.y\"\n      {\n        // Each rule have a list of strings, consisting in a sequence\n        // of YR_STRING structures. The last YR_STRING structure does not\n        // represent a real string, it's just a end-of-list marker\n        // identified by a specific flag (STRING_FLAGS_NULL). Here we\n        // write the end-of-list marker.\n\n        YR_STRING null_string;\n\n        memset(&null_string, 0xFF, sizeof(YR_STRING));\n        null_string.g_flags = STRING_GFLAGS_NULL;\n\n        fail_if_error(yr_arena_write_data(\n            compiler->strings_arena,\n            &null_string,\n            sizeof(YR_STRING),\n            NULL));\n\n        (yyval.string) = (yyvsp[0].string);\n      }\n#line 1895 \"grammar.c\"\n    break;\n\n  case 18:\n#line 371 \"grammar.y\"\n                                       { (yyval.integer) = 0;  }\n#line 1901 \"grammar.c\"\n    break;\n\n  case 19:\n#line 372 \"grammar.y\"\n                                       { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }\n#line 1907 \"grammar.c\"\n    break;\n\n  case 20:\n#line 377 \"grammar.y\"\n                     { (yyval.integer) = RULE_GFLAGS_PRIVATE; }\n#line 1913 \"grammar.c\"\n    break;\n\n  case 21:\n#line 378 \"grammar.y\"\n                     { (yyval.integer) = RULE_GFLAGS_GLOBAL; }\n#line 1919 \"grammar.c\"\n    break;\n\n  case 22:\n#line 384 \"grammar.y\"\n      {\n        (yyval.c_string) = NULL;\n      }\n#line 1927 \"grammar.c\"\n    break;\n\n  case 23:\n#line 388 \"grammar.y\"\n      {\n        // Tags list is represented in the arena as a sequence\n        // of null-terminated strings, the sequence ends with an\n        // additional null character. Here we write the ending null\n        //character. Example: tag1\\0tag2\\0tag3\\0\\0\n\n        int result = yr_arena_write_string(\n            yyget_extra(yyscanner)->sz_arena, \"\", NULL);\n\n        fail_if_error(result);\n\n        (yyval.c_string) = (yyvsp[0].c_string);\n      }\n#line 1945 \"grammar.c\"\n    break;\n\n  case 24:\n#line 406 \"grammar.y\"\n      {\n        int result = yr_arena_write_string(\n            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &(yyval.c_string));\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n      }\n#line 1958 \"grammar.c\"\n    break;\n\n  case 25:\n#line 415 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        char* tag_name = (yyvsp[-1].c_string);\n        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;\n\n        while (tag_length > 0)\n        {\n          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)\n          {\n            yr_compiler_set_error_extra_info(compiler, tag_name);\n            result = ERROR_DUPLICATED_TAG_IDENTIFIER;\n            break;\n          }\n\n          tag_name = (char*) yr_arena_next_address(\n              yyget_extra(yyscanner)->sz_arena,\n              tag_name,\n              tag_length + 1);\n\n          tag_length = tag_name != NULL ? strlen(tag_name) : 0;\n        }\n\n        if (result == ERROR_SUCCESS)\n          result = yr_arena_write_string(\n              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n\n        (yyval.c_string) = (yyvsp[-1].c_string);\n      }\n#line 1996 \"grammar.c\"\n    break;\n\n  case 26:\n#line 453 \"grammar.y\"\n                                          {  (yyval.meta) = (yyvsp[0].meta); }\n#line 2002 \"grammar.c\"\n    break;\n\n  case 27:\n#line 454 \"grammar.y\"\n                                          {  (yyval.meta) = (yyvsp[-1].meta); }\n#line 2008 \"grammar.c\"\n    break;\n\n  case 28:\n#line 460 \"grammar.y\"\n      {\n        SIZED_STRING* sized_string = (yyvsp[0].sized_string);\n\n        int result = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_STRING,\n            (yyvsp[-2].c_string),\n            sized_string->c_string,\n            0,\n            &(yyval.meta));\n\n        yr_free((yyvsp[-2].c_string));\n        yr_free((yyvsp[0].sized_string));\n\n        fail_if_error(result);\n      }\n#line 2029 \"grammar.c\"\n    break;\n\n  case 29:\n#line 477 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_INTEGER,\n            (yyvsp[-2].c_string),\n            NULL,\n            (yyvsp[0].integer),\n            &(yyval.meta));\n\n        yr_free((yyvsp[-2].c_string));\n\n        fail_if_error(result);\n      }\n#line 2047 \"grammar.c\"\n    break;\n\n  case 30:\n#line 491 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_INTEGER,\n            (yyvsp[-3].c_string),\n            NULL,\n            -(yyvsp[0].integer),\n            &(yyval.meta));\n\n        yr_free((yyvsp[-3].c_string));\n\n        fail_if_error(result);\n      }\n#line 2065 \"grammar.c\"\n    break;\n\n  case 31:\n#line 505 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_BOOLEAN,\n            (yyvsp[-2].c_string),\n            NULL,\n            true,\n            &(yyval.meta));\n\n        yr_free((yyvsp[-2].c_string));\n\n        fail_if_error(result);\n      }\n#line 2083 \"grammar.c\"\n    break;\n\n  case 32:\n#line 519 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_BOOLEAN,\n            (yyvsp[-2].c_string),\n            NULL,\n            false,\n            &(yyval.meta));\n\n        yr_free((yyvsp[-2].c_string));\n\n        fail_if_error(result);\n      }\n#line 2101 \"grammar.c\"\n    break;\n\n  case 33:\n#line 536 \"grammar.y\"\n                                              { (yyval.string) = (yyvsp[0].string); }\n#line 2107 \"grammar.c\"\n    break;\n\n  case 34:\n#line 537 \"grammar.y\"\n                                              { (yyval.string) = (yyvsp[-1].string); }\n#line 2113 \"grammar.c\"\n    break;\n\n  case 35:\n#line 543 \"grammar.y\"\n      {\n        compiler->current_line = yyget_lineno(yyscanner);\n      }\n#line 2121 \"grammar.c\"\n    break;\n\n  case 36:\n#line 547 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_string_declaration(\n            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string), &(yyval.string));\n\n        yr_free((yyvsp[-4].c_string));\n        yr_free((yyvsp[-1].sized_string));\n\n        fail_if_error(result);\n        compiler->current_line = 0;\n      }\n#line 2136 \"grammar.c\"\n    break;\n\n  case 37:\n#line 558 \"grammar.y\"\n      {\n        compiler->current_line = yyget_lineno(yyscanner);\n      }\n#line 2144 \"grammar.c\"\n    break;\n\n  case 38:\n#line 562 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_string_declaration(\n            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string), &(yyval.string));\n\n        yr_free((yyvsp[-4].c_string));\n        yr_free((yyvsp[-1].sized_string));\n\n        fail_if_error(result);\n\n        compiler->current_line = 0;\n      }\n#line 2160 \"grammar.c\"\n    break;\n\n  case 39:\n#line 574 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_string_declaration(\n            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string), &(yyval.string));\n\n        yr_free((yyvsp[-2].c_string));\n        yr_free((yyvsp[0].sized_string));\n\n        fail_if_error(result);\n      }\n#line 2174 \"grammar.c\"\n    break;\n\n  case 40:\n#line 587 \"grammar.y\"\n                                          { (yyval.integer) = 0; }\n#line 2180 \"grammar.c\"\n    break;\n\n  case 41:\n#line 588 \"grammar.y\"\n                                          { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }\n#line 2186 \"grammar.c\"\n    break;\n\n  case 42:\n#line 593 \"grammar.y\"\n                    { (yyval.integer) = STRING_GFLAGS_WIDE; }\n#line 2192 \"grammar.c\"\n    break;\n\n  case 43:\n#line 594 \"grammar.y\"\n                    { (yyval.integer) = STRING_GFLAGS_ASCII; }\n#line 2198 \"grammar.c\"\n    break;\n\n  case 44:\n#line 595 \"grammar.y\"\n                    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }\n#line 2204 \"grammar.c\"\n    break;\n\n  case 45:\n#line 596 \"grammar.y\"\n                    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }\n#line 2210 \"grammar.c\"\n    break;\n\n  case 46:\n#line 597 \"grammar.y\"\n                    { (yyval.integer) = STRING_GFLAGS_XOR; }\n#line 2216 \"grammar.c\"\n    break;\n\n  case 47:\n#line 603 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));\n\n        if (var_index >= 0)\n        {\n          result = yr_parser_emit_with_arg(\n              yyscanner,\n              OP_PUSH_M,\n              LOOP_LOCAL_VARS * var_index,\n              NULL,\n              NULL);\n\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = UNDEFINED;\n          (yyval.expression).identifier = compiler->loop_identifier[var_index];\n        }\n        else\n        {\n          // Search for identifier within the global namespace, where the\n          // externals variables reside.\n\n          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(\n              compiler->objects_table, (yyvsp[0].c_string), NULL);\n\n          if (object == NULL)\n          {\n            // If not found, search within the current namespace.\n            char* ns = compiler->current_namespace->name;\n\n            object = (YR_OBJECT*) yr_hash_table_lookup(\n                compiler->objects_table, (yyvsp[0].c_string), ns);\n          }\n\n          if (object != NULL)\n          {\n            char* id;\n\n            result = yr_arena_write_string(\n                compiler->sz_arena, (yyvsp[0].c_string), &id);\n\n            if (result == ERROR_SUCCESS)\n              result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_OBJ_LOAD,\n                  id,\n                  NULL,\n                  NULL);\n\n            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n            (yyval.expression).value.object = object;\n            (yyval.expression).identifier = object->identifier;\n          }\n          else\n          {\n            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(\n                compiler->rules_table,\n                (yyvsp[0].c_string),\n                compiler->current_namespace->name);\n\n            if (rule != NULL)\n            {\n              result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_PUSH_RULE,\n                  rule,\n                  NULL,\n                  NULL);\n\n              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n              (yyval.expression).value.integer = UNDEFINED;\n              (yyval.expression).identifier = rule->identifier;\n            }\n            else\n            {\n              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\n              result = ERROR_UNDEFINED_IDENTIFIER;\n            }\n          }\n        }\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n      }\n#line 2306 \"grammar.c\"\n    break;\n\n  case 48:\n#line 689 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n        YR_OBJECT* field = NULL;\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)\n        {\n          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));\n\n          if (field != NULL)\n          {\n            char* ident;\n\n            result = yr_arena_write_string(\n                compiler->sz_arena, (yyvsp[0].c_string), &ident);\n\n            if (result == ERROR_SUCCESS)\n              result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_OBJ_FIELD,\n                  ident,\n                  NULL,\n                  NULL);\n\n            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n            (yyval.expression).value.object = field;\n            (yyval.expression).identifier = field->identifier;\n          }\n          else\n          {\n            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\n            result = ERROR_INVALID_FIELD_NAME;\n          }\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-2].expression).identifier);\n\n          result = ERROR_NOT_A_STRUCTURE;\n        }\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n      }\n#line 2357 \"grammar.c\"\n    break;\n\n  case 49:\n#line 736 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n        YR_OBJECT_ARRAY* array;\n        YR_OBJECT_DICTIONARY* dict;\n\n        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)\n        {\n          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)\n          {\n            yr_compiler_set_error_extra_info(\n                compiler, \"array indexes must be of integer type\");\n            result = ERROR_WRONG_TYPE;\n          }\n\n          fail_if_error(result);\n\n          result = yr_parser_emit(\n              yyscanner, OP_INDEX_ARRAY, NULL);\n\n          array = object_as_array((yyvsp[-3].expression).value.object);\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = array->prototype_item;\n          (yyval.expression).identifier = array->identifier;\n        }\n        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)\n        {\n          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)\n          {\n            yr_compiler_set_error_extra_info(\n                compiler, \"dictionary keys must be of string type\");\n            result = ERROR_WRONG_TYPE;\n          }\n\n          fail_if_error(result);\n\n          result = yr_parser_emit(\n              yyscanner, OP_LOOKUP_DICT, NULL);\n\n          dict = object_as_dictionary((yyvsp[-3].expression).value.object);\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = dict->prototype_item;\n          (yyval.expression).identifier = dict->identifier;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-3].expression).identifier);\n\n          result = ERROR_NOT_INDEXABLE;\n        }\n\n        fail_if_error(result);\n      }\n#line 2419 \"grammar.c\"\n    break;\n\n  case 50:\n#line 795 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n        YR_OBJECT_FUNCTION* function;\n        char* args_fmt;\n\n        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)\n        {\n          result = yr_parser_check_types(\n              compiler, object_as_function((yyvsp[-3].expression).value.object), (yyvsp[-1].c_string));\n\n          if (result == ERROR_SUCCESS)\n            result = yr_arena_write_string(\n                compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);\n\n          if (result == ERROR_SUCCESS)\n            result = yr_parser_emit_with_arg_reloc(\n                yyscanner,\n                OP_CALL,\n                args_fmt,\n                NULL,\n                NULL);\n\n          function = object_as_function((yyvsp[-3].expression).value.object);\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = function->return_obj;\n          (yyval.expression).identifier = function->identifier;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-3].expression).identifier);\n\n          result = ERROR_NOT_A_FUNCTION;\n        }\n\n        yr_free((yyvsp[-1].c_string));\n\n        fail_if_error(result);\n      }\n#line 2465 \"grammar.c\"\n    break;\n\n  case 51:\n#line 840 \"grammar.y\"\n                      { (yyval.c_string) = yr_strdup(\"\"); }\n#line 2471 \"grammar.c\"\n    break;\n\n  case 52:\n#line 841 \"grammar.y\"\n                      { (yyval.c_string) = (yyvsp[0].c_string); }\n#line 2477 \"grammar.c\"\n    break;\n\n  case 53:\n#line 846 \"grammar.y\"\n      {\n        (yyval.c_string) = (char*) yr_malloc(YR_MAX_FUNCTION_ARGS + 1);\n\n        if ((yyval.c_string) == NULL)\n          fail_if_error(ERROR_INSUFFICIENT_MEMORY);\n\n        switch((yyvsp[0].expression).type)\n        {\n          case EXPRESSION_TYPE_INTEGER:\n            strlcpy((yyval.c_string), \"i\", YR_MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_FLOAT:\n            strlcpy((yyval.c_string), \"f\", YR_MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_BOOLEAN:\n            strlcpy((yyval.c_string), \"b\", YR_MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_STRING:\n            strlcpy((yyval.c_string), \"s\", YR_MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_REGEXP:\n            strlcpy((yyval.c_string), \"r\", YR_MAX_FUNCTION_ARGS);\n            break;\n          default:\n            assert(false);\n        }\n      }\n#line 2509 \"grammar.c\"\n    break;\n\n  case 54:\n#line 874 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        if (strlen((yyvsp[-2].c_string)) == YR_MAX_FUNCTION_ARGS)\n        {\n          result = ERROR_TOO_MANY_ARGUMENTS;\n        }\n        else\n        {\n          switch((yyvsp[0].expression).type)\n          {\n            case EXPRESSION_TYPE_INTEGER:\n              strlcat((yyvsp[-2].c_string), \"i\", YR_MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_FLOAT:\n              strlcat((yyvsp[-2].c_string), \"f\", YR_MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_BOOLEAN:\n              strlcat((yyvsp[-2].c_string), \"b\", YR_MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_STRING:\n              strlcat((yyvsp[-2].c_string), \"s\", YR_MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_REGEXP:\n              strlcat((yyvsp[-2].c_string), \"r\", YR_MAX_FUNCTION_ARGS);\n              break;\n            default:\n              assert(false);\n          }\n        }\n\n        fail_if_error(result);\n\n        (yyval.c_string) = (yyvsp[-2].c_string);\n      }\n#line 2549 \"grammar.c\"\n    break;\n\n  case 55:\n#line 914 \"grammar.y\"\n      {\n        SIZED_STRING* sized_string = (yyvsp[0].sized_string);\n        RE* re;\n        RE_ERROR error;\n\n        int result = ERROR_SUCCESS;\n        int re_flags = 0;\n\n        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)\n          re_flags |= RE_FLAGS_NO_CASE;\n\n        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)\n          re_flags |= RE_FLAGS_DOT_ALL;\n\n        result = yr_re_compile(\n            sized_string->c_string,\n            re_flags,\n            compiler->re_code_arena,\n            &re,\n            &error);\n\n        yr_free((yyvsp[0].sized_string));\n\n        if (result == ERROR_INVALID_REGULAR_EXPRESSION)\n          yr_compiler_set_error_extra_info(compiler, error.message);\n\n        if (result == ERROR_SUCCESS)\n          result = yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_PUSH,\n              re,\n              NULL,\n              NULL);\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;\n      }\n#line 2592 \"grammar.c\"\n    break;\n\n  case 56:\n#line 957 \"grammar.y\"\n      {\n        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)\n        {\n          if ((yyvsp[0].expression).value.sized_string != NULL)\n          {\n            yywarning(yyscanner,\n              \"Using literal string \\\"%s\\\" in a boolean operation.\",\n              (yyvsp[0].expression).value.sized_string->c_string);\n          }\n\n          fail_if_error(yr_parser_emit(\n              yyscanner, OP_STR_TO_BOOL, NULL));\n        }\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2613 \"grammar.c\"\n    break;\n\n  case 57:\n#line 977 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 1, NULL, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2624 \"grammar.c\"\n    break;\n\n  case 58:\n#line 984 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 0, NULL, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2635 \"grammar.c\"\n    break;\n\n  case 59:\n#line 991 \"grammar.y\"\n      {\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"matches\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, \"matches\");\n\n        fail_if_error(yr_parser_emit(\n            yyscanner,\n            OP_MATCHES,\n            NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2651 \"grammar.c\"\n    break;\n\n  case 60:\n#line 1003 \"grammar.y\"\n      {\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"contains\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_STRING, \"contains\");\n\n        fail_if_error(yr_parser_emit(\n            yyscanner, OP_CONTAINS, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2665 \"grammar.c\"\n    break;\n\n  case 61:\n#line 1013 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_string_identifier(\n            yyscanner,\n            (yyvsp[0].c_string),\n            OP_FOUND,\n            UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2683 \"grammar.c\"\n    break;\n\n  case 62:\n#line 1027 \"grammar.y\"\n      {\n        int result;\n\n        check_type_with_cleanup((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"at\", yr_free((yyvsp[-2].c_string)));\n\n        result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);\n\n        yr_free((yyvsp[-2].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2702 \"grammar.c\"\n    break;\n\n  case 63:\n#line 1042 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);\n\n        yr_free((yyvsp[-2].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2717 \"grammar.c\"\n    break;\n\n  case 64:\n#line 1053 \"grammar.y\"\n      {\n        if (compiler->loop_depth > 0)\n        {\n          compiler->loop_depth--;\n          compiler->loop_identifier[compiler->loop_depth] = NULL;\n        }\n\n        YYERROR;\n      }\n#line 2731 \"grammar.c\"\n    break;\n\n  case 65:\n#line 1063 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n        int var_index;\n\n        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)\n          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;\n\n        fail_if_error(result);\n\n        var_index = yr_parser_lookup_loop_variable(\n            yyscanner, (yyvsp[-1].c_string));\n\n        if (var_index >= 0)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-1].c_string));\n\n          result = ERROR_DUPLICATED_LOOP_IDENTIFIER;\n        }\n\n        fail_if_error(result);\n\n        // Push end-of-list marker\n        result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n\n        fail_if_error(result);\n      }\n#line 2764 \"grammar.c\"\n    break;\n\n  case 66:\n#line 1092 \"grammar.y\"\n      {\n        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n        uint8_t* addr;\n\n        // Clear counter for number of expressions evaluating\n        // to true.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\n\n        // Clear iterations counter\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\n\n        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)\n        {\n          // Pop the first integer\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset, &addr, NULL);\n        }\n        else // INTEGER_SET_RANGE\n        {\n          // Pop higher bound of set range\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);\n\n          // Pop lower bound of set range\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset, NULL, NULL);\n        }\n\n        compiler->loop_address[compiler->loop_depth] = addr;\n        compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);\n        compiler->loop_depth++;\n      }\n#line 2803 \"grammar.c\"\n    break;\n\n  case 67:\n#line 1127 \"grammar.y\"\n      {\n        int mem_offset;\n\n        compiler->loop_depth--;\n        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n\n        // The value at the top of the stack is the result of\n        // evaluating the boolean expression, so it could be\n        // 0, 1 or UNDEFINED. Add this value to a counter\n        // keeping the number of expressions evaluating to true.\n        // If the value is UNDEFINED instruction OP_ADD_M\n        // does nothing.\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\n\n        // Increment iterations counter\n        yr_parser_emit_with_arg(\n            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\n\n        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)\n        {\n          yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_JNUNDEF,\n              compiler->loop_address[compiler->loop_depth],\n              NULL,\n              NULL);\n        }\n        else // INTEGER_SET_RANGE\n        {\n          // Increment lower bound of integer set\n          yr_parser_emit_with_arg(\n              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);\n\n          // Push lower bound of integer set\n          yr_parser_emit_with_arg(\n              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);\n\n          // Push higher bound of integer set\n          yr_parser_emit_with_arg(\n              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);\n\n          // Compare higher bound with lower bound, do loop again\n          // if lower bound is still lower or equal than higher bound\n          yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_JLE,\n              compiler->loop_address[compiler->loop_depth],\n              NULL,\n              NULL);\n\n          yr_parser_emit(yyscanner, OP_POP, NULL);\n          yr_parser_emit(yyscanner, OP_POP, NULL);\n        }\n\n        // Pop end-of-list marker.\n        yr_parser_emit(yyscanner, OP_POP, NULL);\n\n        // At this point the loop quantifier (any, all, 1, 2,..)\n        // is at the top of the stack. Check if the quantifier\n        // is undefined (meaning \"all\") and replace it with the\n        // iterations counter in that case.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\n\n        // Compare the loop quantifier with the number of\n        // expressions evaluating to true.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit(yyscanner, OP_INT_LE, NULL);\n\n        compiler->loop_identifier[compiler->loop_depth] = NULL;\n        yr_free((yyvsp[-8].c_string));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2886 \"grammar.c\"\n    break;\n\n  case 68:\n#line 1206 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n        uint8_t* addr;\n\n        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)\n          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;\n\n        if (compiler->loop_for_of_mem_offset != -1)\n          result = ERROR_NESTED_FOR_OF_LOOP;\n\n        fail_if_error(result);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\n\n        // Pop the first string.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_POP_M, mem_offset, &addr, NULL);\n\n        compiler->loop_for_of_mem_offset = mem_offset;\n        compiler->loop_address[compiler->loop_depth] = addr;\n        compiler->loop_identifier[compiler->loop_depth] = NULL;\n        compiler->loop_depth++;\n      }\n#line 2919 \"grammar.c\"\n    break;\n\n  case 69:\n#line 1235 \"grammar.y\"\n      {\n        int mem_offset;\n\n        compiler->loop_depth--;\n        compiler->loop_for_of_mem_offset = -1;\n\n        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n\n        // Increment counter by the value returned by the\n        // boolean expression (0 or 1). If the boolean expression\n        // returned UNDEFINED the OP_ADD_M won't do anything.\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\n\n        // Increment iterations counter.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\n\n        // If next string is not undefined, go back to the\n        // beginning of the loop.\n        yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JNUNDEF,\n            compiler->loop_address[compiler->loop_depth],\n            NULL,\n            NULL);\n\n        // Pop end-of-list marker.\n        yr_parser_emit(yyscanner, OP_POP, NULL);\n\n        // At this point the loop quantifier (any, all, 1, 2,..)\n        // is at top of the stack. Check if the quantifier is\n        // undefined (meaning \"all\") and replace it with the\n        // iterations counter in that case.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\n\n        // Compare the loop quantifier with the number of\n        // expressions evaluating to true.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit(yyscanner, OP_INT_LE, NULL);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n\n      }\n#line 2972 \"grammar.c\"\n    break;\n\n  case 70:\n#line 1284 \"grammar.y\"\n      {\n        yr_parser_emit(yyscanner, OP_OF, NULL);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2982 \"grammar.c\"\n    break;\n\n  case 71:\n#line 1290 \"grammar.y\"\n      {\n        yr_parser_emit(yyscanner, OP_NOT, NULL);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2992 \"grammar.c\"\n    break;\n\n  case 72:\n#line 1296 \"grammar.y\"\n      {\n        YR_FIXUP* fixup;\n        void* jmp_destination_addr;\n\n        fail_if_error(yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JFALSE,\n            0,          // still don't know the jump destination\n            NULL,\n            &jmp_destination_addr));\n\n        // create a fixup entry for the jump and push it in the stack\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          fail_if_error(ERROR_INSUFFICIENT_MEMORY);\n\n        fixup->address = jmp_destination_addr;\n        fixup->next = compiler->fixup_stack_head;\n        compiler->fixup_stack_head = fixup;\n      }\n#line 3018 \"grammar.c\"\n    break;\n\n  case 73:\n#line 1318 \"grammar.y\"\n      {\n        YR_FIXUP* fixup;\n        uint8_t* nop_addr;\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_AND, NULL));\n\n        // Generate a do-nothing instruction (NOP) in order to get its address\n        // and use it as the destination for the OP_JFALSE. We can not simply\n        // use the address of the OP_AND instruction +1 because we can't be\n        // sure that the instruction following the OP_AND is going to be in\n        // the same arena page. As we don't have a reliable way of getting the\n        // address of the next instruction we generate the OP_NOP.\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_NOP, &nop_addr));\n\n        fixup = compiler->fixup_stack_head;\n        *(void**)(fixup->address) = (void*) nop_addr;\n        compiler->fixup_stack_head = fixup->next;\n        yr_free(fixup);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3045 \"grammar.c\"\n    break;\n\n  case 74:\n#line 1341 \"grammar.y\"\n      {\n        YR_FIXUP* fixup;\n        void* jmp_destination_addr;\n\n        fail_if_error(yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JTRUE,\n            0,         // still don't know the jump destination\n            NULL,\n            &jmp_destination_addr));\n\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          fail_if_error(ERROR_INSUFFICIENT_MEMORY);\n\n        fixup->address = jmp_destination_addr;\n        fixup->next = compiler->fixup_stack_head;\n        compiler->fixup_stack_head = fixup;\n      }\n#line 3070 \"grammar.c\"\n    break;\n\n  case 75:\n#line 1362 \"grammar.y\"\n      {\n        YR_FIXUP* fixup;\n        uint8_t* nop_addr;\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_OR, NULL));\n\n        // Generate a do-nothing instruction (NOP) in order to get its address\n        // and use it as the destination for the OP_JFALSE. We can not simply\n        // use the address of the OP_OR instruction +1 because we can't be\n        // sure that the instruction following the OP_AND is going to be in\n        // the same arena page. As we don't have a reliable way of getting the\n        // address of the next instruction we generate the OP_NOP.\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_NOP, &nop_addr));\n\n        fixup = compiler->fixup_stack_head;\n        *(void**)(fixup->address) = (void*)(nop_addr);\n        compiler->fixup_stack_head = fixup->next;\n        yr_free(fixup);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3097 \"grammar.c\"\n    break;\n\n  case 76:\n#line 1385 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_reduce_operation(\n            yyscanner, \"<\", (yyvsp[-2].expression), (yyvsp[0].expression)));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3108 \"grammar.c\"\n    break;\n\n  case 77:\n#line 1392 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_reduce_operation(\n            yyscanner, \">\", (yyvsp[-2].expression), (yyvsp[0].expression)));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3119 \"grammar.c\"\n    break;\n\n  case 78:\n#line 1399 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_reduce_operation(\n            yyscanner, \"<=\", (yyvsp[-2].expression), (yyvsp[0].expression)));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3130 \"grammar.c\"\n    break;\n\n  case 79:\n#line 1406 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_reduce_operation(\n            yyscanner, \">=\", (yyvsp[-2].expression), (yyvsp[0].expression)));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3141 \"grammar.c\"\n    break;\n\n  case 80:\n#line 1413 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_reduce_operation(\n            yyscanner, \"==\", (yyvsp[-2].expression), (yyvsp[0].expression)));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3152 \"grammar.c\"\n    break;\n\n  case 81:\n#line 1420 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_reduce_operation(\n            yyscanner, \"!=\", (yyvsp[-2].expression), (yyvsp[0].expression)));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3163 \"grammar.c\"\n    break;\n\n  case 82:\n#line 1427 \"grammar.y\"\n      {\n        (yyval.expression) = (yyvsp[0].expression);\n      }\n#line 3171 \"grammar.c\"\n    break;\n\n  case 83:\n#line 1431 \"grammar.y\"\n      {\n        (yyval.expression) = (yyvsp[-1].expression);\n      }\n#line 3179 \"grammar.c\"\n    break;\n\n  case 84:\n#line 1438 \"grammar.y\"\n                                   { (yyval.integer) = INTEGER_SET_ENUMERATION; }\n#line 3185 \"grammar.c\"\n    break;\n\n  case 85:\n#line 1439 \"grammar.y\"\n                                   { (yyval.integer) = INTEGER_SET_RANGE; }\n#line 3191 \"grammar.c\"\n    break;\n\n  case 86:\n#line 1445 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for range's lower bound\");\n          result = ERROR_WRONG_TYPE;\n        }\n\n        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for range's upper bound\");\n          result = ERROR_WRONG_TYPE;\n        }\n\n        fail_if_error(result);\n      }\n#line 3215 \"grammar.c\"\n    break;\n\n  case 87:\n#line 1469 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for enumeration item\");\n          result = ERROR_WRONG_TYPE;\n        }\n\n        fail_if_error(result);\n      }\n#line 3232 \"grammar.c\"\n    break;\n\n  case 88:\n#line 1482 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for enumeration item\");\n          result = ERROR_WRONG_TYPE;\n        }\n\n        fail_if_error(result);\n      }\n#line 3249 \"grammar.c\"\n    break;\n\n  case 89:\n#line 1499 \"grammar.y\"\n      {\n        // Push end-of-list marker\n        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n      }\n#line 3258 \"grammar.c\"\n    break;\n\n  case 91:\n#line 1505 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL));\n\n        fail_if_error(yr_parser_emit_pushes_for_strings(\n            yyscanner, \"$*\"));\n      }\n#line 3270 \"grammar.c\"\n    break;\n\n  case 94:\n#line 1523 \"grammar.y\"\n      {\n        int result = yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n      }\n#line 3281 \"grammar.c\"\n    break;\n\n  case 95:\n#line 1530 \"grammar.y\"\n      {\n        int result = yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n      }\n#line 3292 \"grammar.c\"\n    break;\n\n  case 97:\n#line 1542 \"grammar.y\"\n      {\n        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n      }\n#line 3300 \"grammar.c\"\n    break;\n\n  case 98:\n#line 1546 \"grammar.y\"\n      {\n        yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);\n      }\n#line 3308 \"grammar.c\"\n    break;\n\n  case 99:\n#line 1554 \"grammar.y\"\n      {\n        (yyval.expression) = (yyvsp[-1].expression);\n      }\n#line 3316 \"grammar.c\"\n    break;\n\n  case 100:\n#line 1558 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_emit(\n            yyscanner, OP_FILESIZE, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = UNDEFINED;\n      }\n#line 3328 \"grammar.c\"\n    break;\n\n  case 101:\n#line 1566 \"grammar.y\"\n      {\n        yywarning(yyscanner,\n            \"Using deprecated \\\"entrypoint\\\" keyword. Use the \\\"entry_point\\\" \"\n            \"function from PE module instead.\");\n\n        fail_if_error(yr_parser_emit(\n            yyscanner, OP_ENTRYPOINT, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = UNDEFINED;\n      }\n#line 3344 \"grammar.c\"\n    break;\n\n  case 102:\n#line 1578 \"grammar.y\"\n      {\n        check_type((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, \"intXXXX or uintXXXX\");\n\n        // _INTEGER_FUNCTION_ could be any of int8, int16, int32, uint8,\n        // uint32, etc. $1 contains an index that added to OP_READ_INT results\n        // in the proper OP_INTXX opcode.\n\n        fail_if_error(yr_parser_emit(\n            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = UNDEFINED;\n      }\n#line 3362 \"grammar.c\"\n    break;\n\n  case 103:\n#line 1592 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = (yyvsp[0].integer);\n      }\n#line 3374 \"grammar.c\"\n    break;\n\n  case 104:\n#line 1600 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_emit_with_arg_double(\n            yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n      }\n#line 3385 \"grammar.c\"\n    break;\n\n  case 105:\n#line 1607 \"grammar.y\"\n      {\n        SIZED_STRING* sized_string;\n\n        int result = yr_arena_write_data(\n            compiler->sz_arena,\n            (yyvsp[0].sized_string),\n            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),\n            (void**) &sized_string);\n\n        yr_free((yyvsp[0].sized_string));\n\n        if (result == ERROR_SUCCESS)\n          result = yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_PUSH,\n              sized_string,\n              NULL,\n              NULL);\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_STRING;\n        (yyval.expression).value.sized_string = sized_string;\n      }\n#line 3414 \"grammar.c\"\n    break;\n\n  case 106:\n#line 1632 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = UNDEFINED;\n      }\n#line 3430 \"grammar.c\"\n    break;\n\n  case 107:\n#line 1644 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);\n\n        yr_free((yyvsp[-3].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = UNDEFINED;\n      }\n#line 3446 \"grammar.c\"\n    break;\n\n  case 108:\n#line 1656 \"grammar.y\"\n      {\n        int result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        if (result == ERROR_SUCCESS)\n          result = yr_parser_reduce_string_identifier(\n              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = UNDEFINED;\n      }\n#line 3466 \"grammar.c\"\n    break;\n\n  case 109:\n#line 1672 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);\n\n        yr_free((yyvsp[-3].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = UNDEFINED;\n      }\n#line 3482 \"grammar.c\"\n    break;\n\n  case 110:\n#line 1684 \"grammar.y\"\n      {\n        int result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        if (result == ERROR_SUCCESS)\n          result = yr_parser_reduce_string_identifier(\n              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = UNDEFINED;\n      }\n#line 3502 \"grammar.c\"\n    break;\n\n  case 111:\n#line 1700 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = UNDEFINED;\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n          (yyval.expression).value.integer = UNDEFINED;\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)\n        {\n          result = yr_parser_emit(\n              yyscanner, OP_OBJ_VALUE, NULL);\n\n          switch((yyvsp[0].expression).value.object->type)\n          {\n            case OBJECT_TYPE_INTEGER:\n              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n              (yyval.expression).value.integer = UNDEFINED;\n              break;\n            case OBJECT_TYPE_FLOAT:\n              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n              break;\n            case OBJECT_TYPE_STRING:\n              (yyval.expression).type = EXPRESSION_TYPE_STRING;\n              (yyval.expression).value.sized_string = NULL;\n              break;\n            default:\n              yr_compiler_set_error_extra_info_fmt(\n                  compiler,\n                  \"wrong usage of identifier \\\"%s\\\"\",\n                  (yyvsp[0].expression).identifier);\n              result = ERROR_WRONG_TYPE;\n          }\n        }\n        else\n        {\n          assert(false);\n        }\n\n        fail_if_error(result);\n      }\n#line 3553 \"grammar.c\"\n    break;\n\n  case 112:\n#line 1747 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, \"-\");\n\n        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\n              UNDEFINED : -((yyvsp[0].expression).value.integer);\n          result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n          result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);\n        }\n\n        fail_if_error(result);\n      }\n#line 3578 \"grammar.c\"\n    break;\n\n  case 113:\n#line 1768 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_operation(\n            yyscanner, \"+\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          int64_t i1 = (yyvsp[-2].expression).value.integer;\n          int64_t i2 = (yyvsp[0].expression).value.integer;\n\n          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&\n              (\n                (i2 > 0 && i1 > INT64_MAX - i2) ||\n                (i2 < 0 && i1 < INT64_MIN - i2)\n              ))\n          {\n            yr_compiler_set_error_extra_info_fmt(\n                compiler, \"%\" PRId64 \" + %\" PRId64, i1, i2);\n\n            result = ERROR_INTEGER_OVERFLOW;\n          }\n          else\n          {\n            (yyval.expression).value.integer = OPERATION(+, i1, i2);\n            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          }\n        }\n        else\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n        }\n\n        fail_if_error(result);\n      }\n#line 3617 \"grammar.c\"\n    break;\n\n  case 114:\n#line 1803 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_operation(\n            yyscanner, \"-\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          int64_t i1 = (yyvsp[-2].expression).value.integer;\n          int64_t i2 = (yyvsp[0].expression).value.integer;\n\n          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&\n              (\n                (i2 < 0 && i1 > INT64_MAX + i2) ||\n                (i2 > 0 && i1 < INT64_MIN + i2)\n              ))\n          {\n            yr_compiler_set_error_extra_info_fmt(\n                compiler, \"%\" PRId64 \" - %\" PRId64, i1, i2);\n\n            result = ERROR_INTEGER_OVERFLOW;\n          }\n          else\n          {\n            (yyval.expression).value.integer = OPERATION(-, i1, i2);\n            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          }\n        }\n        else\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n        }\n\n        fail_if_error(result);\n      }\n#line 3656 \"grammar.c\"\n    break;\n\n  case 115:\n#line 1838 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_operation(\n            yyscanner, \"*\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          int64_t i1 = (yyvsp[-2].expression).value.integer;\n          int64_t i2 = (yyvsp[0].expression).value.integer;\n\n          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&\n              (\n                i2 != 0 && llabs(i1) > INT64_MAX / llabs(i2)\n              ))\n          {\n            yr_compiler_set_error_extra_info_fmt(\n                compiler, \"%\" PRId64 \" * %\" PRId64, i1, i2);\n\n            result = ERROR_INTEGER_OVERFLOW;\n          }\n          else\n          {\n            (yyval.expression).value.integer = OPERATION(*, i1, i2);\n            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          }\n        }\n        else\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n        }\n\n        fail_if_error(result);\n      }\n#line 3694 \"grammar.c\"\n    break;\n\n  case 116:\n#line 1872 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_operation(\n            yyscanner, \"\\\\\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          if ((yyvsp[0].expression).value.integer != 0)\n          {\n            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          }\n          else\n          {\n            result = ERROR_DIVISION_BY_ZERO;\n          }\n        }\n        else\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n        }\n\n        fail_if_error(result);\n      }\n#line 3723 \"grammar.c\"\n    break;\n\n  case 117:\n#line 1897 \"grammar.y\"\n      {\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"%\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"%\");\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_MOD, NULL));\n\n        if ((yyvsp[0].expression).value.integer != 0)\n        {\n          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n          fail_if_error(ERROR_DIVISION_BY_ZERO);\n        }\n      }\n#line 3744 \"grammar.c\"\n    break;\n\n  case 118:\n#line 1914 \"grammar.y\"\n      {\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n      }\n#line 3758 \"grammar.c\"\n    break;\n\n  case 119:\n#line 1924 \"grammar.y\"\n      {\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n      }\n#line 3772 \"grammar.c\"\n    break;\n\n  case 120:\n#line 1934 \"grammar.y\"\n      {\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"|\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"|\");\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n      }\n#line 3786 \"grammar.c\"\n    break;\n\n  case 121:\n#line 1944 \"grammar.y\"\n      {\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"~\");\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\n            UNDEFINED : ~((yyvsp[0].expression).value.integer);\n      }\n#line 3800 \"grammar.c\"\n    break;\n\n  case 122:\n#line 1954 \"grammar.y\"\n      {\n        int result;\n\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\n\n        result = yr_parser_emit(yyscanner, OP_SHL, NULL);\n\n        if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer < 0)\n          result = ERROR_INVALID_OPERAND;\n        else if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer >= 64)\n          (yyval.expression).value.integer = 0;\n        else\n          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n\n        fail_if_error(result);\n      }\n#line 3824 \"grammar.c\"\n    break;\n\n  case 123:\n#line 1974 \"grammar.y\"\n      {\n        int result;\n\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \">>\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \">>\");\n\n        result = yr_parser_emit(yyscanner, OP_SHR, NULL);\n\n        if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer < 0)\n          result = ERROR_INVALID_OPERAND;\n        else if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer >= 64)\n          (yyval.expression).value.integer = 0;\n        else\n          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n\n        fail_if_error(result);\n      }\n#line 3848 \"grammar.c\"\n    break;\n\n  case 124:\n#line 1994 \"grammar.y\"\n      {\n        (yyval.expression) = (yyvsp[0].expression);\n      }\n#line 3856 \"grammar.c\"\n    break;\n\n\n#line 3860 \"grammar.c\"\n\n      default: break;\n    }\n  /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n  {\n    const int yylhs = yyr1[yyn] - YYNTOKENS;\n    const int yyi = yypgoto[yylhs] + *yyssp;\n    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp\n               ? yytable[yyi]\n               : yydefgoto[yylhs]);\n  }\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (yyscanner, compiler, YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        int yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = YY_CAST (char *, YYSTACK_ALLOC (YY_CAST (YYSIZE_T, yymsg_alloc)));\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (yyscanner, compiler, yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n         error, discard it.  */\n\n      if (yychar <= YYEOF)\n        {\n          /* Return failure if at end of input.  */\n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval, yyscanner, compiler);\n          yychar = YYEMPTY;\n        }\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n  /* Pacify compilers when the user code never invokes YYERROR and the\n     label yyerrorlab therefore never appears in user code.  */\n  if (0)\n    YYERROR;\n\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYTERROR;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n        YYABORT;\n\n\n      yydestruct (\"Error: popping\",\n                  yystos[yystate], yyvsp, yyscanner, compiler);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (yyscanner, compiler, YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\n\n/*-----------------------------------------------------.\n| yyreturn -- parsing is finished, return the result.  |\n`-----------------------------------------------------*/\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval, yyscanner, compiler);\n    }\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  yystos[+*yyssp], yyvsp, yyscanner, compiler);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n#endif\n  return yyresult;\n}",
        "begin_line": 1518,
        "end_line": 4090,
        "is_bug": false
    },
    {
        "name": "libyara.grammar.yydestruct#1426",
        "src_path": "libyara/grammar.c",
        "class_name": "libyara.grammar",
        "signature": "libyara.grammar.yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, YR_COMPILER* compiler)",
        "snippet": "static void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, YR_COMPILER* compiler)\n{\n  YYUSE (yyvaluep);\n  YYUSE (yyscanner);\n  YYUSE (compiler);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  switch (yytype)\n    {\n    case 11: /* \"identifier\"  */\n#line 224 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1443 \"grammar.c\"\n        break;\n\n    case 12: /* \"string identifier\"  */\n#line 228 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1449 \"grammar.c\"\n        break;\n\n    case 13: /* \"string count\"  */\n#line 225 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1455 \"grammar.c\"\n        break;\n\n    case 14: /* \"string offset\"  */\n#line 226 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1461 \"grammar.c\"\n        break;\n\n    case 15: /* \"string length\"  */\n#line 227 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1467 \"grammar.c\"\n        break;\n\n    case 16: /* \"string identifier with wildcard\"  */\n#line 229 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1473 \"grammar.c\"\n        break;\n\n    case 20: /* \"text string\"  */\n#line 230 \"grammar.y\"\n            { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }\n#line 1479 \"grammar.c\"\n        break;\n\n    case 21: /* \"hex string\"  */\n#line 231 \"grammar.y\"\n            { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }\n#line 1485 \"grammar.c\"\n        break;\n\n    case 22: /* \"regular expression\"  */\n#line 232 \"grammar.y\"\n            { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }\n#line 1491 \"grammar.c\"\n        break;\n\n    case 96: /* arguments  */\n#line 234 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1497 \"grammar.c\"\n        break;\n\n    case 97: /* arguments_list  */\n#line 235 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1503 \"grammar.c\"\n        break;\n\n      default:\n        break;\n    }\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}",
        "begin_line": 1426,
        "end_line": 1509,
        "is_bug": false
    },
    {
        "name": "libyara.grammar.yysyntax_error#1287",
        "src_path": "libyara/grammar.c",
        "class_name": "libyara.grammar",
        "signature": "libyara.grammar.yysyntax_error (YYPTRDIFF_T *yymsg_alloc, char **yymsg, yy_state_t *yyssp, int yytoken)",
        "snippet": "static int\nyysyntax_error (YYPTRDIFF_T *yymsg_alloc, char **yymsg,\n                yy_state_t *yyssp, int yytoken)\n{\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *yyformat = YY_NULLPTR;\n  /* Arguments of yyformat: reported tokens (one for the \"unexpected\",\n     one per \"expected\"). */\n  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Actual size of YYARG. */\n  int yycount = 0;\n  /* Cumulated lengths of YYARG.  */\n  YYPTRDIFF_T yysize = 0;\n\n  /* There are many possibilities here to consider:\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in yychar) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated yychar.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (yytoken != YYEMPTY)\n    {\n      int yyn = yypact[+*yyssp];\n      YYPTRDIFF_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);\n      yysize = yysize0;\n      yyarg[yycount++] = yytname[yytoken];\n      if (!yypact_value_is_default (yyn))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int yyxbegin = yyn < 0 ? -yyn : 0;\n          /* Stay within bounds of both yycheck and yytname.  */\n          int yychecklim = YYLAST - yyn + 1;\n          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n          int yyx;\n\n          for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR\n                && !yytable_value_is_error (yytable[yyx + yyn]))\n              {\n                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    yycount = 1;\n                    yysize = yysize0;\n                    break;\n                  }\n                yyarg[yycount++] = yytname[yyx];\n                {\n                  YYPTRDIFF_T yysize1\n                    = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);\n                  if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)\n                    yysize = yysize1;\n                  else\n                    return 2;\n                }\n              }\n        }\n    }\n\n  switch (yycount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        yyformat = S;                       \\\n      break\n    default: /* Avoid compiler warnings. */\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  {\n    /* Don't count the \"%s\"s in the final size, but reserve room for\n       the terminator.  */\n    YYPTRDIFF_T yysize1 = yysize + (yystrlen (yyformat) - 2 * yycount) + 1;\n    if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)\n      yysize = yysize1;\n    else\n      return 2;\n  }\n\n  if (*yymsg_alloc < yysize)\n    {\n      *yymsg_alloc = 2 * yysize;\n      if (! (yysize <= *yymsg_alloc\n             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *yyp = *yymsg;\n    int yyi = 0;\n    while ((*yyp = *yyformat) != '\\0')\n      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)\n        {\n          yyp += yytnamerr (yyp, yyarg[yyi++]);\n          yyformat += 2;\n        }\n      else\n        {\n          ++yyp;\n          ++yyformat;\n        }\n  }\n  return 0;\n}",
        "begin_line": 1287,
        "end_line": 1419,
        "is_bug": false
    },
    {
        "name": "libyara.grammar.yytnamerr#1236",
        "src_path": "libyara/grammar.c",
        "class_name": "libyara.grammar",
        "signature": "libyara.grammar.yytnamerr (char *yyres, const char *yystr)",
        "snippet": "static YYPTRDIFF_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYPTRDIFF_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n        switch (*++yyp)\n          {\n          case '\\'':\n          case ',':\n            goto do_not_strip_quotes;\n\n          case '\\\\':\n            if (*++yyp != '\\\\')\n              goto do_not_strip_quotes;\n            else\n              goto append;\n\n          append:\n          default:\n            if (yyres)\n              yyres[yyn] = *yyp;\n            yyn++;\n            break;\n\n          case '\"':\n            if (yyres)\n              yyres[yyn] = '\\0';\n            return yyn;\n          }\n    do_not_strip_quotes: ;\n    }\n\n  if (yyres)\n    return yystpcpy (yyres, yystr) - yyres;\n  else\n    return yystrlen (yystr);\n}",
        "begin_line": 1236,
        "end_line": 1276,
        "is_bug": false
    },
    {
        "name": "libyara.libyara.yr_finalize#207",
        "src_path": "libyara/libyara.c",
        "class_name": "libyara.libyara",
        "signature": "libyara.libyara.yr_finalize(void)",
        "snippet": "YR_API int yr_finalize(void)\n{\n  #if defined HAVE_LIBCRYPTO && OPENSSL_VERSION_NUMBER < 0x10100000L\n  int i;\n  #endif\n\n  // yr_finalize shouldn't be called without calling yr_initialize first\n\n  if (init_count == 0)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  init_count--;\n\n  if (init_count > 0)\n    return ERROR_SUCCESS;\n\n  #if defined HAVE_LIBCRYPTO && OPENSSL_VERSION_NUMBER < 0x10100000L\n\n  for (i = 0; i < CRYPTO_num_locks(); i ++)\n    yr_mutex_destroy(&openssl_locks[i]);\n\n  OPENSSL_free(openssl_locks);\n  CRYPTO_set_id_callback(NULL);\n  CRYPTO_set_locking_callback(NULL);\n\n  #elif defined(HAVE_WINCRYPT_H)\n\n  CryptReleaseContext(yr_cryptprov, 0);\n\n  #endif\n\n  FAIL_ON_ERROR(yr_thread_storage_destroy(&yr_tidx_key));\n  FAIL_ON_ERROR(yr_thread_storage_destroy(&yr_recovery_state_key));\n  FAIL_ON_ERROR(yr_modules_finalize());\n  FAIL_ON_ERROR(yr_heap_free());\n\n  #if defined(JEMALLOC)\n  malloc_stats_print(NULL, NULL, NULL);\n  mallctl(\"prof.dump\", NULL, NULL, NULL, 0);\n  #endif\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 207,
        "end_line": 249,
        "is_bug": false
    },
    {
        "name": "libyara.libyara.yr_get_configuration#328",
        "src_path": "libyara/libyara.c",
        "class_name": "libyara.libyara",
        "signature": "libyara.libyara.yr_get_configuration(     YR_CONFIG_NAME name, void *dest)",
        "snippet": "YR_API int yr_get_configuration(\n    YR_CONFIG_NAME name,\n    void *dest)\n{\n  if (dest == NULL)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  switch (name)\n  { // lump all the cases using same types together in one cascade\n    case YR_CONFIG_STACK_SIZE:\n    case YR_CONFIG_MAX_STRINGS_PER_RULE:\n    case YR_CONFIG_MAX_MATCH_DATA:\n      *(uint32_t*) dest = yr_cfgs[name].ui32;\n      break;\n\n    default:\n      return ERROR_INTERNAL_FATAL_ERROR;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 328,
        "end_line": 348,
        "is_bug": false
    },
    {
        "name": "libyara.libyara.yr_get_tidx#279",
        "src_path": "libyara/libyara.c",
        "class_name": "libyara.libyara",
        "signature": "libyara.libyara.yr_get_tidx(void)",
        "snippet": "YR_API int yr_get_tidx(void)\n{\n  return (int) (size_t) yr_thread_storage_get_value(&yr_tidx_key) - 1;\n}",
        "begin_line": 279,
        "end_line": 282,
        "is_bug": false
    },
    {
        "name": "libyara.libyara.yr_initialize#117",
        "src_path": "libyara/libyara.c",
        "class_name": "libyara.libyara",
        "signature": "libyara.libyara.yr_initialize(void)",
        "snippet": "YR_API int yr_initialize(void)\n{\n  uint32_t def_stack_size = DEFAULT_STACK_SIZE;\n  uint32_t def_max_strings_per_rule = DEFAULT_MAX_STRINGS_PER_RULE;\n  uint32_t def_max_match_data = DEFAULT_MAX_MATCH_DATA;\n\n  int i;\n\n  init_count++;\n\n  if (init_count > 1)\n    return ERROR_SUCCESS;\n\n  srand((unsigned) time(NULL));\n\n  yr_canary = rand();\n\n  for (i = 0; i < 256; i++)\n  {\n    if (i >= 'a' && i <= 'z')\n      yr_altercase[i] = i - 32;\n    else if (i >= 'A' && i <= 'Z')\n      yr_altercase[i] = i + 32;\n    else\n      yr_altercase[i] = i;\n\n    yr_lowercase[i] = tolower(i);\n  }\n\n  FAIL_ON_ERROR(yr_heap_alloc());\n  FAIL_ON_ERROR(yr_thread_storage_create(&yr_tidx_key));\n  FAIL_ON_ERROR(yr_thread_storage_create(&yr_recovery_state_key));\n\n  #if defined HAVE_LIBCRYPTO && OPENSSL_VERSION_NUMBER < 0x10100000L\n\n  openssl_locks = (YR_MUTEX*) OPENSSL_malloc(\n      CRYPTO_num_locks() * sizeof(YR_MUTEX));\n\n  for (i = 0; i < CRYPTO_num_locks(); i++)\n    yr_mutex_create(&openssl_locks[i]);\n\n  CRYPTO_set_id_callback(_thread_id);\n  CRYPTO_set_locking_callback(_locking_function);\n\n  #elif defined(HAVE_WINCRYPT_H)\n\n  if (!CryptAcquireContext(&yr_cryptprov, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {\n    return ERROR_INTERNAL_FATAL_ERROR;\n  }\n\n  #elif defined(HAVE_COMMON_CRYPTO)\n\n  ...\n\n  #endif\n\n  FAIL_ON_ERROR(yr_modules_initialize());\n\n  // Initialize default configuration options\n  FAIL_ON_ERROR(yr_set_configuration(\n      YR_CONFIG_STACK_SIZE, &def_stack_size));\n\n  FAIL_ON_ERROR(yr_set_configuration(\n      YR_CONFIG_MAX_STRINGS_PER_RULE, &def_max_strings_per_rule));\n\n  FAIL_ON_ERROR(yr_set_configuration(\n      YR_CONFIG_MAX_MATCH_DATA, &def_max_match_data));\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 117,
        "end_line": 186,
        "is_bug": false
    },
    {
        "name": "libyara.libyara.yr_set_configuration#305",
        "src_path": "libyara/libyara.c",
        "class_name": "libyara.libyara",
        "signature": "libyara.libyara.yr_set_configuration(     YR_CONFIG_NAME name, void *src)",
        "snippet": "YR_API int yr_set_configuration(\n    YR_CONFIG_NAME name,\n    void *src)\n{\n  if (src == NULL)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  switch (name)\n  { // lump all the cases using same types together in one cascade\n    case YR_CONFIG_STACK_SIZE:\n    case YR_CONFIG_MAX_STRINGS_PER_RULE:\n    case YR_CONFIG_MAX_MATCH_DATA:\n      yr_cfgs[name].ui32 = *(uint32_t*) src;\n      break;\n\n    default:\n      return ERROR_INTERNAL_FATAL_ERROR;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 305,
        "end_line": 325,
        "is_bug": false
    },
    {
        "name": "libyara.libyara.yr_set_tidx#263",
        "src_path": "libyara/libyara.c",
        "class_name": "libyara.libyara",
        "signature": "libyara.libyara.yr_set_tidx(int tidx)",
        "snippet": "YR_API void yr_set_tidx(int tidx)\n{\n  yr_thread_storage_set_value(&yr_tidx_key, (void*) (size_t) (tidx + 1));\n}",
        "begin_line": 263,
        "end_line": 266,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_calloc#133",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_calloc(size_t count, size_t size)",
        "snippet": "void* yr_calloc(size_t count, size_t size)\n{\n  return calloc(count, size);\n}",
        "begin_line": 133,
        "end_line": 136,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_free#151",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_free(void *ptr)",
        "snippet": "void yr_free(void *ptr)\n{\n  free(ptr);\n}",
        "begin_line": 151,
        "end_line": 154,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_heap_alloc#121",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_heap_alloc(void)",
        "snippet": "int yr_heap_alloc(void)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 121,
        "end_line": 124,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_heap_free#127",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_heap_free(void)",
        "snippet": "int yr_heap_free(void)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 127,
        "end_line": 130,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_malloc#139",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_malloc(size_t size)",
        "snippet": "void* yr_malloc(size_t size)\n{\n  return malloc(size);\n}",
        "begin_line": 139,
        "end_line": 142,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_realloc#145",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_realloc(void* ptr, size_t size)",
        "snippet": "void* yr_realloc(void* ptr, size_t size)\n{\n  return realloc(ptr, size);\n}",
        "begin_line": 145,
        "end_line": 148,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_strdup#157",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_strdup(const char *str)",
        "snippet": "char* yr_strdup(const char *str)\n{\n  return strdup(str);\n}",
        "begin_line": 157,
        "end_line": 160,
        "is_bug": false
    },
    {
        "name": "libyara.modules.elf.module_finalize#582",
        "src_path": "libyara/modules/elf.c",
        "class_name": "libyara.modules.elf",
        "signature": "libyara.modules.elf.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 582,
        "end_line": 586,
        "is_bug": false
    },
    {
        "name": "libyara.modules.elf.module_initialize#575",
        "src_path": "libyara/modules/elf.c",
        "class_name": "libyara.modules.elf",
        "signature": "libyara.modules.elf.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 575,
        "end_line": 579,
        "is_bug": false
    },
    {
        "name": "libyara.modules.hash.module_finalize#506",
        "src_path": "libyara/modules/hash.c",
        "class_name": "libyara.modules.hash",
        "signature": "libyara.modules.hash.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 506,
        "end_line": 510,
        "is_bug": false
    },
    {
        "name": "libyara.modules.hash.module_initialize#499",
        "src_path": "libyara/modules/hash.c",
        "class_name": "libyara.modules.hash",
        "signature": "libyara.modules.hash.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 499,
        "end_line": 503,
        "is_bug": false
    },
    {
        "name": "libyara.modules.math.module_finalize#645",
        "src_path": "libyara/modules/math.c",
        "class_name": "libyara.modules.math",
        "signature": "libyara.modules.math.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 645,
        "end_line": 649,
        "is_bug": false
    },
    {
        "name": "libyara.modules.math.module_initialize#638",
        "src_path": "libyara/modules/math.c",
        "class_name": "libyara.modules.math",
        "signature": "libyara.modules.math.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 638,
        "end_line": 642,
        "is_bug": false
    },
    {
        "name": "libyara.modules.pe.module_finalize#2604",
        "src_path": "libyara/modules/pe.c",
        "class_name": "libyara.modules.pe",
        "signature": "libyara.modules.pe.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 2604,
        "end_line": 2608,
        "is_bug": false
    },
    {
        "name": "libyara.modules.pe.module_initialize#2597",
        "src_path": "libyara/modules/pe.c",
        "class_name": "libyara.modules.pe",
        "signature": "libyara.modules.pe.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 2597,
        "end_line": 2601,
        "is_bug": false
    },
    {
        "name": "libyara.modules.tests.module_finalize#163",
        "src_path": "libyara/modules/tests.c",
        "class_name": "libyara.modules.tests",
        "signature": "libyara.modules.tests.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 163,
        "end_line": 167,
        "is_bug": false
    },
    {
        "name": "libyara.modules.tests.module_initialize#156",
        "src_path": "libyara/modules/tests.c",
        "class_name": "libyara.modules.tests",
        "signature": "libyara.modules.tests.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 156,
        "end_line": 160,
        "is_bug": false
    },
    {
        "name": "libyara.modules.time.module_finalize#59",
        "src_path": "libyara/modules/time.c",
        "class_name": "libyara.modules.time",
        "signature": "libyara.modules.time.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 59,
        "end_line": 63,
        "is_bug": false
    },
    {
        "name": "libyara.modules.time.module_initialize#52",
        "src_path": "libyara/modules/time.c",
        "class_name": "libyara.modules.time",
        "signature": "libyara.modules.time.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 52,
        "end_line": 56,
        "is_bug": false
    },
    {
        "name": "libyara.modules.yr_modules_finalize#85",
        "src_path": "libyara/modules.c",
        "class_name": "libyara.modules",
        "signature": "libyara.modules.yr_modules_finalize()",
        "snippet": "int yr_modules_finalize()\n{\n  int i;\n\n  for (i = 0; i < sizeof(yr_modules_table) / sizeof(YR_MODULE); i++)\n  {\n    int result = yr_modules_table[i].finalize(&yr_modules_table[i]);\n\n    if (result != ERROR_SUCCESS)\n      return result;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 85,
        "end_line": 98,
        "is_bug": false
    },
    {
        "name": "libyara.modules.yr_modules_initialize#69",
        "src_path": "libyara/modules.c",
        "class_name": "libyara.modules",
        "signature": "libyara.modules.yr_modules_initialize()",
        "snippet": "int yr_modules_initialize()\n{\n  int i;\n\n  for (i = 0; i < sizeof(yr_modules_table) / sizeof(YR_MODULE); i++)\n  {\n    int result = yr_modules_table[i].initialize(&yr_modules_table[i]);\n\n    if (result != ERROR_SUCCESS)\n      return result;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 69,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "libyara.modules.yr_modules_unload_all#198",
        "src_path": "libyara/modules.c",
        "class_name": "libyara.modules",
        "signature": "libyara.modules.yr_modules_unload_all(     YR_SCAN_CONTEXT* context)",
        "snippet": "int yr_modules_unload_all(\n    YR_SCAN_CONTEXT* context)\n{\n  int i;\n\n  for (i = 0; i < sizeof(yr_modules_table) / sizeof(YR_MODULE); i++)\n  {\n    YR_OBJECT* module_structure = (YR_OBJECT*) yr_hash_table_remove(\n        context->objects_table,\n        yr_modules_table[i].name,\n        NULL);\n\n    if (module_structure != NULL)\n    {\n      yr_modules_table[i].unload(module_structure);\n      yr_object_destroy(module_structure);\n    }\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 198,
        "end_line": 218,
        "is_bug": false
    },
    {
        "name": "libyara.parser._yr_parser_operator_to_opcode#1141",
        "src_path": "libyara/parser.c",
        "class_name": "libyara.parser",
        "signature": "libyara.parser._yr_parser_operator_to_opcode(     const char* op, int expression_type)",
        "snippet": "static int _yr_parser_operator_to_opcode(\n    const char* op,\n    int expression_type)\n{\n  int opcode = 0;\n\n  switch(expression_type)\n  {\n    case EXPRESSION_TYPE_INTEGER:\n      opcode = OP_INT_BEGIN;\n      break;\n    case EXPRESSION_TYPE_FLOAT:\n      opcode = OP_DBL_BEGIN;\n      break;\n    case EXPRESSION_TYPE_STRING:\n      opcode = OP_STR_BEGIN;\n      break;\n    default:\n      assert(false);\n  }\n\n  if (op[0] == '<')\n  {\n    if (op[1] == '=')\n      opcode += _OP_LE;\n    else\n      opcode += _OP_LT;\n  }\n  else if (op[0] == '>')\n  {\n    if (op[1] == '=')\n      opcode += _OP_GE;\n    else\n      opcode += _OP_GT;\n  }\n  else if (op[1] == '=')\n  {\n    if (op[0] == '=')\n      opcode += _OP_EQ;\n    else\n      opcode += _OP_NEQ;\n  }\n  else if (op[0] == '+')\n  {\n    opcode += _OP_ADD;\n  }\n  else if (op[0] == '-')\n  {\n    opcode += _OP_SUB;\n  }\n  else if (op[0] == '*')\n  {\n    opcode += _OP_MUL;\n  }\n  else if (op[0] == '\\\\')\n  {\n    opcode += _OP_DIV;\n  }\n\n  if (IS_INT_OP(opcode) || IS_DBL_OP(opcode) || IS_STR_OP(opcode))\n  {\n    return opcode;\n  }\n\n  return OP_ERROR;\n}",
        "begin_line": 1141,
        "end_line": 1206,
        "is_bug": false
    },
    {
        "name": "libyara.parser._yr_parser_write_string#291",
        "src_path": "libyara/parser.c",
        "class_name": "libyara.parser",
        "signature": "libyara.parser._yr_parser_write_string(     const char* identifier, int flags, YR_COMPILER* compiler, SIZED_STRING* str, RE_AST* re_ast, YR_STRING** string, int* min_atom_quality, int* num_atom)",
        "snippet": "static int _yr_parser_write_string(\n    const char* identifier,\n    int flags,\n    YR_COMPILER* compiler,\n    SIZED_STRING* str,\n    RE_AST* re_ast,\n    YR_STRING** string,\n    int* min_atom_quality,\n    int* num_atom)\n{\n  SIZED_STRING* literal_string;\n  YR_ATOM_LIST_ITEM* atom;\n  YR_ATOM_LIST_ITEM* atom_list = NULL;\n\n  int c, result;\n  int max_string_len;\n  bool free_literal = false;\n\n  *string = NULL;\n\n  result = yr_arena_allocate_struct(\n      compiler->strings_arena,\n      sizeof(YR_STRING),\n      (void**) string,\n      offsetof(YR_STRING, identifier),\n      offsetof(YR_STRING, string),\n      offsetof(YR_STRING, chained_to),\n      offsetof(YR_STRING, rule),\n      EOL);\n\n  if (result != ERROR_SUCCESS)\n    return result;\n\n  result = yr_arena_write_string(\n      compiler->sz_arena,\n      identifier,\n      &(*string)->identifier);\n\n  if (result != ERROR_SUCCESS)\n    return result;\n\n  if (flags & STRING_GFLAGS_HEXADECIMAL ||\n      flags & STRING_GFLAGS_REGEXP)\n  {\n    literal_string = yr_re_ast_extract_literal(re_ast);\n\n    if (literal_string != NULL)\n    {\n      flags |= STRING_GFLAGS_LITERAL;\n      free_literal = true;\n    }\n    else\n    {\n      // Non-literal strings can't be marked as fixed offset because once we\n      // find a string atom in the scanned data we don't know the offset where\n      // the string should start, as the non-literal strings can contain\n      // variable-length portions.\n\n      flags &= ~STRING_GFLAGS_FIXED_OFFSET;\n    }\n  }\n  else\n  {\n    literal_string = str;\n    flags |= STRING_GFLAGS_LITERAL;\n  }\n\n  (*string)->g_flags = flags;\n  (*string)->chained_to = NULL;\n  (*string)->fixed_offset = UNDEFINED;\n  (*string)->rule = compiler->current_rule;\n\n  memset((*string)->matches, 0,\n         sizeof((*string)->matches));\n\n  memset((*string)->unconfirmed_matches, 0,\n         sizeof((*string)->unconfirmed_matches));\n\n  if (flags & STRING_GFLAGS_LITERAL)\n  {\n    (*string)->length = (uint32_t) literal_string->length;\n\n    result = yr_arena_write_data(\n        compiler->sz_arena,\n        literal_string->c_string,\n        literal_string->length + 1,   // +1 to include terminating NULL\n        (void**) &(*string)->string);\n\n    if (result == ERROR_SUCCESS)\n    {\n      result = yr_atoms_extract_from_string(\n          &compiler->atoms_config,\n          (uint8_t*) literal_string->c_string,\n          (int32_t) literal_string->length,\n          flags,\n          &atom_list,\n          min_atom_quality);\n    }\n  }\n  else\n  {\n    // Emit forwards code\n    result = yr_re_ast_emit_code(re_ast, compiler->re_code_arena, false);\n\n    // Emit backwards code\n    if (result == ERROR_SUCCESS)\n      result = yr_re_ast_emit_code(re_ast, compiler->re_code_arena, true);\n\n    if (result == ERROR_SUCCESS)\n      result = yr_atoms_extract_from_re(\n          &compiler->atoms_config,\n          re_ast,\n          flags,\n          &atom_list,\n          min_atom_quality);\n  }\n\n  if (result == ERROR_SUCCESS)\n  {\n    // Add the string to Aho-Corasick automaton.\n    result = yr_ac_add_string(\n        compiler->automaton,\n        *string,\n        atom_list,\n        compiler->matches_arena);\n  }\n\n  if (flags & STRING_GFLAGS_LITERAL)\n  {\n    if (flags & STRING_GFLAGS_WIDE)\n      max_string_len = (*string)->length * 2;\n    else\n      max_string_len = (*string)->length;\n\n    if (max_string_len <= YR_MAX_ATOM_LENGTH)\n      (*string)->g_flags |= STRING_GFLAGS_FITS_IN_ATOM;\n  }\n\n  atom = atom_list;\n  c = 0;\n\n  while (atom != NULL)\n  {\n    atom = atom->next;\n    c++;\n  }\n\n  (*num_atom) += c;\n\n  if (free_literal)\n    yr_free(literal_string);\n\n  if (atom_list != NULL)\n    yr_atoms_list_destroy(atom_list);\n\n  return result;\n}",
        "begin_line": 291,
        "end_line": 447,
        "is_bug": false
    },
    {
        "name": "libyara.parser.yr_parser_emit#50",
        "src_path": "libyara/parser.c",
        "class_name": "libyara.parser",
        "signature": "libyara.parser.yr_parser_emit(     yyscan_t yyscanner, uint8_t instruction, uint8_t** instruction_address)",
        "snippet": "int yr_parser_emit(\n    yyscan_t yyscanner,\n    uint8_t instruction,\n    uint8_t** instruction_address)\n{\n  return yr_arena_write_data(\n      yyget_extra(yyscanner)->code_arena,\n      &instruction,\n      sizeof(int8_t),\n      (void**) instruction_address);\n}",
        "begin_line": 50,
        "end_line": 60,
        "is_bug": false
    },
    {
        "name": "libyara.parser.yr_parser_emit_with_arg#87",
        "src_path": "libyara/parser.c",
        "class_name": "libyara.parser",
        "signature": "libyara.parser.yr_parser_emit_with_arg(     yyscan_t yyscanner, uint8_t instruction, int64_t argument, uint8_t** instruction_address, int64_t** argument_address)",
        "snippet": "int yr_parser_emit_with_arg(\n    yyscan_t yyscanner,\n    uint8_t instruction,\n    int64_t argument,\n    uint8_t** instruction_address,\n    int64_t** argument_address)\n{\n  int result = yr_arena_write_data(\n      yyget_extra(yyscanner)->code_arena,\n      &instruction,\n      sizeof(uint8_t),\n      (void**) instruction_address);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_write_data(\n        yyget_extra(yyscanner)->code_arena,\n        &argument,\n        sizeof(int64_t),\n        (void**) argument_address);\n\n  return result;\n}",
        "begin_line": 87,
        "end_line": 108,
        "is_bug": false
    },
    {
        "name": "libyara.parser.yr_parser_emit_with_arg_reloc#111",
        "src_path": "libyara/parser.c",
        "class_name": "libyara.parser",
        "signature": "libyara.parser.yr_parser_emit_with_arg_reloc(     yyscan_t yyscanner, uint8_t instruction, void* argument, uint8_t** instruction_address, void** argument_address)",
        "snippet": "int yr_parser_emit_with_arg_reloc(\n    yyscan_t yyscanner,\n    uint8_t instruction,\n    void* argument,\n    uint8_t** instruction_address,\n    void** argument_address)\n{\n  int64_t* ptr = NULL;\n  int result;\n\n  DECLARE_REFERENCE(void*, ptr) arg;\n\n  memset(&arg, 0, sizeof(arg));\n  arg.ptr = argument;\n\n  result = yr_arena_write_data(\n      yyget_extra(yyscanner)->code_arena,\n      &instruction,\n      sizeof(uint8_t),\n      (void**) instruction_address);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_write_data(\n        yyget_extra(yyscanner)->code_arena,\n        &arg,\n        sizeof(arg),\n        (void**) &ptr);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_make_ptr_relocatable(\n        yyget_extra(yyscanner)->code_arena,\n        ptr,\n        0,\n        EOL);\n\n  if (argument_address != NULL)\n    *argument_address = (void*) ptr;\n\n  return result;\n}",
        "begin_line": 111,
        "end_line": 150,
        "is_bug": false
    },
    {
        "name": "libyara.parser.yr_parser_lookup_string#237",
        "src_path": "libyara/parser.c",
        "class_name": "libyara.parser",
        "signature": "libyara.parser.yr_parser_lookup_string(     yyscan_t yyscanner, const char* identifier, YR_STRING** string)",
        "snippet": "int yr_parser_lookup_string(\n    yyscan_t yyscanner,\n    const char* identifier,\n    YR_STRING** string)\n{\n  YR_COMPILER* compiler = yyget_extra(yyscanner);\n\n  *string = compiler->current_rule->strings;\n\n  while(!STRING_IS_NULL(*string))\n  {\n    // If some string $a gets fragmented into multiple chained\n    // strings, all those fragments have the same $a identifier\n    // but we are interested in the heading fragment, which is\n    // that with chained_to == NULL\n\n    if (strcmp((*string)->identifier, identifier) == 0 &&\n        (*string)->chained_to == NULL)\n    {\n      return ERROR_SUCCESS;\n    }\n\n    *string = (YR_STRING*) yr_arena_next_address(\n        compiler->strings_arena,\n        *string,\n        sizeof(YR_STRING));\n  }\n\n  yr_compiler_set_error_extra_info(compiler, identifier);\n\n  *string = NULL;\n\n  return ERROR_UNDEFINED_STRING;\n}",
        "begin_line": 237,
        "end_line": 270,
        "is_bug": false
    },
    {
        "name": "libyara.parser.yr_parser_reduce_operation#1209",
        "src_path": "libyara/parser.c",
        "class_name": "libyara.parser",
        "signature": "libyara.parser.yr_parser_reduce_operation(     yyscan_t yyscanner, const char* op, EXPRESSION left_operand, EXPRESSION right_operand)",
        "snippet": "int yr_parser_reduce_operation(\n    yyscan_t yyscanner,\n    const char* op,\n    EXPRESSION left_operand,\n    EXPRESSION right_operand)\n{\n  int expression_type;\n\n  YR_COMPILER* compiler = yyget_extra(yyscanner);\n\n  if ((left_operand.type == EXPRESSION_TYPE_INTEGER ||\n       left_operand.type == EXPRESSION_TYPE_FLOAT) &&\n      (right_operand.type == EXPRESSION_TYPE_INTEGER ||\n       right_operand.type == EXPRESSION_TYPE_FLOAT))\n  {\n    if (left_operand.type != right_operand.type)\n    {\n      // One operand is double and the other is integer,\n      // cast the integer to double\n\n      FAIL_ON_ERROR(yr_parser_emit_with_arg(\n          yyscanner,\n          OP_INT_TO_DBL,\n          (left_operand.type == EXPRESSION_TYPE_INTEGER) ? 2 : 1,\n          NULL,\n          NULL));\n    }\n\n    expression_type = EXPRESSION_TYPE_FLOAT;\n\n    if (left_operand.type == EXPRESSION_TYPE_INTEGER &&\n        right_operand.type == EXPRESSION_TYPE_INTEGER)\n    {\n      expression_type = EXPRESSION_TYPE_INTEGER;\n    }\n\n    FAIL_ON_ERROR(yr_parser_emit(\n        yyscanner,\n        _yr_parser_operator_to_opcode(op, expression_type),\n        NULL));\n  }\n  else if (left_operand.type == EXPRESSION_TYPE_STRING &&\n           right_operand.type == EXPRESSION_TYPE_STRING)\n  {\n    int opcode = _yr_parser_operator_to_opcode(op, EXPRESSION_TYPE_STRING);\n\n    if (opcode != OP_ERROR)\n    {\n      FAIL_ON_ERROR(yr_parser_emit(\n          yyscanner,\n          opcode,\n          NULL));\n    }\n    else\n    {\n      yr_compiler_set_error_extra_info_fmt(\n          compiler, \"strings don't support \\\"%s\\\" operation\", op);\n\n      return ERROR_WRONG_TYPE;\n    }\n  }\n  else\n  {\n    yr_compiler_set_error_extra_info(compiler, \"type mismatch\");\n\n    return ERROR_WRONG_TYPE;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 1209,
        "end_line": 1278,
        "is_bug": false
    },
    {
        "name": "libyara.parser.yr_parser_reduce_rule_declaration_phase_1#728",
        "src_path": "libyara/parser.c",
        "class_name": "libyara.parser",
        "signature": "libyara.parser.yr_parser_reduce_rule_declaration_phase_1(     yyscan_t yyscanner, int32_t flags, const char* identifier, YR_RULE** rule)",
        "snippet": "int yr_parser_reduce_rule_declaration_phase_1(\n    yyscan_t yyscanner,\n    int32_t flags,\n    const char* identifier,\n    YR_RULE** rule)\n{\n  YR_FIXUP *fixup;\n  YR_INIT_RULE_ARGS *init_rule_args;\n  YR_COMPILER* compiler = yyget_extra(yyscanner);\n\n  *rule = NULL;\n\n  if (yr_hash_table_lookup(\n        compiler->rules_table,\n        identifier,\n        compiler->current_namespace->name) != NULL ||\n      yr_hash_table_lookup(\n        compiler->objects_table,\n        identifier,\n        NULL) != NULL)\n  {\n    // A rule or variable with the same identifier already exists, return the\n    // appropriate error.\n\n    yr_compiler_set_error_extra_info(compiler, identifier);\n    return ERROR_DUPLICATED_IDENTIFIER;\n  }\n\n  FAIL_ON_ERROR(yr_arena_allocate_struct(\n      compiler->rules_arena,\n      sizeof(YR_RULE),\n      (void**) rule,\n      offsetof(YR_RULE, identifier),\n      offsetof(YR_RULE, tags),\n      offsetof(YR_RULE, strings),\n      offsetof(YR_RULE, metas),\n      offsetof(YR_RULE, ns),\n      EOL))\n\n  (*rule)->g_flags = flags;\n  (*rule)->ns = compiler->current_namespace;\n  (*rule)->num_atoms = 0;\n\n  #ifdef PROFILING_ENABLED\n  (*rule)->time_cost = 0;\n\n  memset(\n      (*rule)->time_cost_per_thread, 0, sizeof((*rule)->time_cost_per_thread));\n  #endif\n\n  FAIL_ON_ERROR(yr_arena_write_string(\n      compiler->sz_arena,\n      identifier,\n      (char**) &(*rule)->identifier));\n\n  FAIL_ON_ERROR(yr_parser_emit(\n      yyscanner,\n      OP_INIT_RULE,\n      NULL));\n\n  FAIL_ON_ERROR(yr_arena_allocate_struct(\n      compiler->code_arena,\n      sizeof(YR_INIT_RULE_ARGS),\n      (void**) &init_rule_args,\n      offsetof(YR_INIT_RULE_ARGS, rule),\n      offsetof(YR_INIT_RULE_ARGS, jmp_addr),\n      EOL));\n\n  init_rule_args->rule = *rule;\n\n  // jmp_addr holds the address to jump to when we want to skip the code for\n  // the rule. It is iniatialized as NULL at this point because we don't know\n  // the address until emmiting the code for the rule's condition. The address\n  // is set in yr_parser_reduce_rule_declaration_phase_2.\n  init_rule_args->jmp_addr = NULL;\n\n  // Create a fixup entry for the jump and push it in the stack\n  fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n  if (fixup == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  fixup->address = (void*) &(init_rule_args->jmp_addr);\n  fixup->next = compiler->fixup_stack_head;\n  compiler->fixup_stack_head = fixup;\n\n  // Clean strings_table as we are starting to parse a new rule.\n  yr_hash_table_clean(compiler->strings_table, NULL);\n\n  FAIL_ON_ERROR(yr_hash_table_add(\n      compiler->rules_table,\n      identifier,\n      compiler->current_namespace->name,\n      (void*) *rule));\n\n  compiler->current_rule = *rule;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 728,
        "end_line": 826,
        "is_bug": false
    },
    {
        "name": "libyara.parser.yr_parser_reduce_rule_declaration_phase_2#828",
        "src_path": "libyara/parser.c",
        "class_name": "libyara.parser",
        "signature": "libyara.parser.yr_parser_reduce_rule_declaration_phase_2(     yyscan_t yyscanner, YR_RULE* rule)",
        "snippet": "int yr_parser_reduce_rule_declaration_phase_2(\n    yyscan_t yyscanner,\n    YR_RULE* rule)\n{\n  uint32_t max_strings_per_rule;\n  uint32_t strings_in_rule = 0;\n  uint8_t* nop_inst_addr = NULL;\n\n  int result;\n\n  YR_FIXUP *fixup;\n  YR_STRING* string;\n  YR_COMPILER* compiler = yyget_extra(yyscanner);\n\n  yr_get_configuration(\n      YR_CONFIG_MAX_STRINGS_PER_RULE,\n      (void*) &max_strings_per_rule);\n\n  // Show warning if the rule is generating too many atoms. The warning is\n  // shown if the number of atoms is greater than 20 times the maximum number\n  // of strings allowed for a rule, as 20 is minimum number of atoms generated\n  // for a string using *nocase*, *ascii* and *wide* modifiers simultaneosly.\n\n  if (rule->num_atoms > YR_ATOMS_PER_RULE_WARNING_THRESHOLD)\n  {\n    yywarning(\n        yyscanner,\n        \"rule %s is slowing down scanning\",\n        rule->identifier);\n  }\n\n  // Check for unreferenced (unused) strings.\n  string = rule->strings;\n\n  while (!STRING_IS_NULL(string))\n  {\n    // Only the heading fragment in a chain of strings (the one with\n    // chained_to == NULL) must be referenced. All other fragments\n    // are never marked as referenced.\n\n    if (!STRING_IS_REFERENCED(string) &&\n        string->chained_to == NULL)\n    {\n      yr_compiler_set_error_extra_info(compiler, string->identifier);\n      return ERROR_UNREFERENCED_STRING;\n    }\n\n    strings_in_rule++;\n\n    if (strings_in_rule > max_strings_per_rule)\n    {\n      yr_compiler_set_error_extra_info(compiler, rule->identifier);\n      return ERROR_TOO_MANY_STRINGS;\n    }\n\n    string = (YR_STRING*) yr_arena_next_address(\n        compiler->strings_arena,\n        string,\n        sizeof(YR_STRING));\n  }\n\n  result = yr_parser_emit_with_arg_reloc(\n      yyscanner,\n      OP_MATCH_RULE,\n      rule,\n      NULL,\n      NULL);\n\n  // Generate a do-nothing instruction (NOP) in order to get its address\n  // and use it as the destination for the OP_INIT_RULE skip jump. We can not\n  // simply use the address of the OP_MATCH_RULE instruction +1 because we\n  // can't be sure that the instruction following the OP_MATCH_RULE is going to\n  // be in the same arena page. As we don't have a reliable way of getting the\n  // address of the next instruction we generate the OP_NOP.\n\n  if (result == ERROR_SUCCESS)\n    result = yr_parser_emit(yyscanner, OP_NOP, &nop_inst_addr);\n\n  fixup = compiler->fixup_stack_head;\n  *(void**)(fixup->address) = (void*) nop_inst_addr;\n  compiler->fixup_stack_head = fixup->next;\n  yr_free(fixup);\n\n  return result;\n}",
        "begin_line": 828,
        "end_line": 912,
        "is_bug": false
    },
    {
        "name": "libyara.parser.yr_parser_reduce_string_declaration#454",
        "src_path": "libyara/parser.c",
        "class_name": "libyara.parser",
        "signature": "libyara.parser.yr_parser_reduce_string_declaration(     yyscan_t yyscanner, int32_t string_flags, const char* identifier, SIZED_STRING* str, YR_STRING** string)",
        "snippet": "int yr_parser_reduce_string_declaration(\n    yyscan_t yyscanner,\n    int32_t string_flags,\n    const char* identifier,\n    SIZED_STRING* str,\n    YR_STRING** string)\n{\n  int min_atom_quality = YR_MIN_ATOM_QUALITY;\n  int min_atom_quality_aux = YR_MIN_ATOM_QUALITY;\n\n  int32_t min_gap;\n  int32_t max_gap;\n\n  char message[512];\n\n  YR_COMPILER* compiler = yyget_extra(yyscanner);\n  YR_STRING* aux_string;\n  YR_STRING* prev_string;\n\n  RE_AST* re_ast = NULL;\n  RE_AST* remainder_re_ast = NULL;\n\n  RE_ERROR re_error;\n\n  int result = ERROR_SUCCESS;\n\n  // Determine if a string with the same identifier was already defined\n  // by searching for the identifier in string_table.\n\n  *string = (YR_STRING*) yr_hash_table_lookup(\n      compiler->strings_table,\n      identifier,\n      NULL);\n\n  if (*string != NULL)\n  {\n    result = ERROR_DUPLICATED_STRING_IDENTIFIER;\n    yr_compiler_set_error_extra_info(compiler, identifier);\n    goto _exit;\n  }\n\n  // Empty strings are not allowed\n\n  if (str->length == 0)\n  {\n    result = ERROR_EMPTY_STRING;\n    yr_compiler_set_error_extra_info(compiler, identifier);\n    goto _exit;\n  }\n\n  if (str->flags & SIZED_STRING_FLAGS_NO_CASE)\n    string_flags |= STRING_GFLAGS_NO_CASE;\n\n  if (str->flags & SIZED_STRING_FLAGS_DOT_ALL)\n    string_flags |= STRING_GFLAGS_DOT_ALL;\n\n  if (strcmp(identifier,\"$\") == 0)\n    string_flags |= STRING_GFLAGS_ANONYMOUS;\n\n  if (!(string_flags & STRING_GFLAGS_WIDE) &&\n      !(string_flags & STRING_GFLAGS_XOR))\n    string_flags |= STRING_GFLAGS_ASCII;\n\n  // Hex strings are always handled as DOT_ALL regexps.\n\n  if (string_flags & STRING_GFLAGS_HEXADECIMAL)\n    string_flags |= STRING_GFLAGS_DOT_ALL;\n\n  // The STRING_GFLAGS_SINGLE_MATCH flag indicates that finding\n  // a single match for the string is enough. This is true in\n  // most cases, except when the string count (#) and string offset (@)\n  // operators are used. All strings are marked STRING_FLAGS_SINGLE_MATCH\n  // initially, and unmarked later if required.\n\n  string_flags |= STRING_GFLAGS_SINGLE_MATCH;\n\n  // The STRING_GFLAGS_FIXED_OFFSET indicates that the string doesn't\n  // need to be searched all over the file because the user is using the\n  // \"at\" operator. The string must be searched at a fixed offset in the\n  // file. All strings are marked STRING_GFLAGS_FIXED_OFFSET initially,\n  // and unmarked later if required.\n\n  string_flags |= STRING_GFLAGS_FIXED_OFFSET;\n\n  if (string_flags & STRING_GFLAGS_HEXADECIMAL ||\n      string_flags & STRING_GFLAGS_REGEXP)\n  {\n    if (string_flags & STRING_GFLAGS_HEXADECIMAL)\n      result = yr_re_parse_hex(str->c_string, &re_ast, &re_error);\n    else\n      result = yr_re_parse(str->c_string, &re_ast, &re_error);\n\n    if (result != ERROR_SUCCESS)\n    {\n      snprintf(\n          message,\n          sizeof(message),\n          \"invalid %s \\\"%s\\\": %s\",\n          (string_flags & STRING_GFLAGS_HEXADECIMAL) ?\n              \"hex string\" : \"regular expression\",\n          identifier,\n          re_error.message);\n\n      yr_compiler_set_error_extra_info(\n          compiler, message);\n\n      goto _exit;\n    }\n\n    if (re_ast->flags & RE_FLAGS_FAST_REGEXP)\n      string_flags |= STRING_GFLAGS_FAST_REGEXP;\n\n    // Regular expressions in the strings section can't mix greedy and ungreedy\n    // quantifiers like .* and .*?. That's because these regular expressions can\n    // be matched forwards and/or backwards depending on the atom found, and we\n    // need the regexp to be all-greedy or all-ungreedy to be able to properly\n    // calculate the length of the match.\n\n    if ((re_ast->flags & RE_FLAGS_GREEDY) &&\n        (re_ast->flags & RE_FLAGS_UNGREEDY))\n    {\n      result = ERROR_INVALID_REGULAR_EXPRESSION;\n\n      yr_compiler_set_error_extra_info(compiler,\n          \"greedy and ungreedy quantifiers can't be mixed in a regular \"\n          \"expression\");\n\n      goto _exit;\n    }\n\n    if (re_ast->flags & RE_FLAGS_GREEDY)\n      string_flags |= STRING_GFLAGS_GREEDY_REGEXP;\n\n    if (yr_re_ast_contains_dot_star(re_ast))\n    {\n      yywarning(\n          yyscanner,\n          \"%s contains .* or .+, consider using .{N} or .{1,N} with a reasonable value for N\",\n          identifier);\n    }\n\n    if (compiler->re_ast_callback != NULL)\n    {\n      compiler->re_ast_callback(\n          compiler->current_rule,\n          identifier,\n          re_ast,\n          compiler->re_ast_clbk_user_data);\n    }\n\n    result = yr_re_ast_split_at_chaining_point(\n        re_ast, &re_ast, &remainder_re_ast, &min_gap, &max_gap);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n\n    result = _yr_parser_write_string(\n        identifier,\n        string_flags,\n        compiler,\n        NULL,\n        re_ast,\n        string,\n        &min_atom_quality,\n        &compiler->current_rule->num_atoms);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n\n    if (remainder_re_ast != NULL)\n    {\n      (*string)->g_flags |= STRING_GFLAGS_CHAIN_TAIL | STRING_GFLAGS_CHAIN_PART;\n      (*string)->chain_gap_min = min_gap;\n      (*string)->chain_gap_max = max_gap;\n    }\n\n    // Use \"aux_string\" from now on, we want to keep the value of \"string\"\n    // because it will returned.\n\n    aux_string = *string;\n\n    while (remainder_re_ast != NULL)\n    {\n      // Destroy regexp pointed by 're_ast' before yr_re_split_at_chaining_point\n      // overwrites 're_ast' with another value.\n\n      yr_re_ast_destroy(re_ast);\n\n      result = yr_re_ast_split_at_chaining_point(\n          remainder_re_ast, &re_ast, &remainder_re_ast, &min_gap, &max_gap);\n\n      if (result != ERROR_SUCCESS)\n        goto _exit;\n\n      prev_string = aux_string;\n\n      result = _yr_parser_write_string(\n          identifier,\n          string_flags,\n          compiler,\n          NULL,\n          re_ast,\n          &aux_string,\n          &min_atom_quality_aux,\n          &compiler->current_rule->num_atoms);\n\n      if (result != ERROR_SUCCESS)\n        goto _exit;\n\n      if (min_atom_quality_aux < min_atom_quality)\n        min_atom_quality = min_atom_quality_aux;\n\n      aux_string->g_flags |= STRING_GFLAGS_CHAIN_PART;\n      aux_string->chain_gap_min = min_gap;\n      aux_string->chain_gap_max = max_gap;\n\n      prev_string->chained_to = aux_string;\n\n      // prev_string is now chained to aux_string, an string chained\n      // to another one can't have a fixed offset, only the head of the\n      // string chain can have a fixed offset.\n\n      prev_string->g_flags &= ~STRING_GFLAGS_FIXED_OFFSET;\n    }\n  }\n  else\n  {\n    result = _yr_parser_write_string(\n        identifier,\n        string_flags,\n        compiler,\n        str,\n        NULL,\n        string,\n        &min_atom_quality,\n        &compiler->current_rule->num_atoms);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n  }\n\n  if (!STRING_IS_ANONYMOUS(*string))\n  {\n    result = yr_hash_table_add(\n      compiler->strings_table,\n      identifier,\n      NULL,\n      *string);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n  }\n\n  if (min_atom_quality < compiler->atoms_config.quality_warning_threshold)\n  {\n    yywarning(\n        yyscanner,\n        \"%s in rule %s is slowing down scanning\",\n        (*string)->identifier,\n        compiler->current_rule->identifier);\n  }\n\n_exit:\n\n  if (re_ast != NULL)\n    yr_re_ast_destroy(re_ast);\n\n  if (remainder_re_ast != NULL)\n    yr_re_ast_destroy(remainder_re_ast);\n\n  return result;\n}",
        "begin_line": 454,
        "end_line": 725,
        "is_bug": false
    },
    {
        "name": "libyara.parser.yr_parser_reduce_string_identifier#915",
        "src_path": "libyara/parser.c",
        "class_name": "libyara.parser",
        "signature": "libyara.parser.yr_parser_reduce_string_identifier(     yyscan_t yyscanner, const char* identifier, uint8_t instruction, uint64_t at_offset)",
        "snippet": "int yr_parser_reduce_string_identifier(\n    yyscan_t yyscanner,\n    const char* identifier,\n    uint8_t instruction,\n    uint64_t at_offset)\n{\n  YR_STRING* string;\n  YR_COMPILER* compiler = yyget_extra(yyscanner);\n\n  if (strcmp(identifier, \"$\") == 0) // is an anonymous string ?\n  {\n    if (compiler->loop_for_of_mem_offset >= 0) // inside a loop ?\n    {\n      yr_parser_emit_with_arg(\n          yyscanner,\n          OP_PUSH_M,\n          compiler->loop_for_of_mem_offset,\n          NULL,\n          NULL);\n\n      yr_parser_emit(yyscanner, instruction, NULL);\n\n      string = compiler->current_rule->strings;\n\n      while(!STRING_IS_NULL(string))\n      {\n        if (instruction != OP_FOUND)\n          string->g_flags &= ~STRING_GFLAGS_SINGLE_MATCH;\n\n        if (instruction == OP_FOUND_AT)\n        {\n          // Avoid overwriting any previous fixed offset\n\n          if (string->fixed_offset == UNDEFINED)\n            string->fixed_offset = at_offset;\n\n          // If a previous fixed offset was different, disable\n          // the STRING_GFLAGS_FIXED_OFFSET flag because we only\n          // have room to store a single fixed offset value\n\n          if (string->fixed_offset != at_offset)\n            string->g_flags &= ~STRING_GFLAGS_FIXED_OFFSET;\n        }\n        else\n        {\n          string->g_flags &= ~STRING_GFLAGS_FIXED_OFFSET;\n        }\n\n        string = (YR_STRING*) yr_arena_next_address(\n            compiler->strings_arena,\n            string,\n            sizeof(YR_STRING));\n      }\n    }\n    else\n    {\n      // Anonymous strings not allowed outside of a loop\n      return ERROR_MISPLACED_ANONYMOUS_STRING;\n    }\n  }\n  else\n  {\n    FAIL_ON_ERROR(yr_parser_lookup_string(\n        yyscanner, identifier, &string));\n\n    FAIL_ON_ERROR(yr_parser_emit_with_arg_reloc(\n        yyscanner,\n        OP_PUSH,\n        string,\n        NULL,\n        NULL));\n\n    if (instruction != OP_FOUND)\n      string->g_flags &= ~STRING_GFLAGS_SINGLE_MATCH;\n\n    if (instruction == OP_FOUND_AT)\n    {\n      // Avoid overwriting any previous fixed offset\n\n      if (string->fixed_offset == UNDEFINED)\n        string->fixed_offset = at_offset;\n\n      // If a previous fixed offset was different, disable\n      // the STRING_GFLAGS_FIXED_OFFSET flag because we only\n      // have room to store a single fixed offset value\n\n      if (string->fixed_offset == UNDEFINED ||\n          string->fixed_offset != at_offset)\n      {\n        string->g_flags &= ~STRING_GFLAGS_FIXED_OFFSET;\n      }\n    }\n    else\n    {\n      string->g_flags &= ~STRING_GFLAGS_FIXED_OFFSET;\n    }\n\n    FAIL_ON_ERROR(yr_parser_emit(yyscanner, instruction, NULL));\n\n    string->g_flags |= STRING_GFLAGS_REFERENCED;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 915,
        "end_line": 1018,
        "is_bug": false
    },
    {
        "name": "libyara.re._yr_emit_inst#525",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re._yr_emit_inst(     RE_EMIT_CONTEXT* emit_context, uint8_t opcode, uint8_t** instruction_addr, size_t* code_size)",
        "snippet": "int _yr_emit_inst(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    uint8_t** instruction_addr,\n    size_t* code_size)\n{\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &opcode,\n      sizeof(uint8_t),\n      (void**) instruction_addr));\n\n  *code_size = sizeof(uint8_t);\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 525,
        "end_line": 540,
        "is_bug": false
    },
    {
        "name": "libyara.re._yr_emit_inst_arg_int16#621",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re._yr_emit_inst_arg_int16(     RE_EMIT_CONTEXT* emit_context, uint8_t opcode, int16_t argument, uint8_t** instruction_addr, int16_t** argument_addr, size_t* code_size)",
        "snippet": "int _yr_emit_inst_arg_int16(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    int16_t argument,\n    uint8_t** instruction_addr,\n    int16_t** argument_addr,\n    size_t* code_size)\n{\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &opcode,\n      sizeof(uint8_t),\n      (void**) instruction_addr));\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &argument,\n      sizeof(int16_t),\n      (void**) argument_addr));\n\n  *code_size = sizeof(uint8_t) + sizeof(int16_t);\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 621,
        "end_line": 644,
        "is_bug": false
    },
    {
        "name": "libyara.re._yr_emit_inst_arg_struct#647",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re._yr_emit_inst_arg_struct(     RE_EMIT_CONTEXT* emit_context, uint8_t opcode, void* structure, size_t structure_size, uint8_t** instruction_addr, void** argument_addr, size_t* code_size)",
        "snippet": "int _yr_emit_inst_arg_struct(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    void* structure,\n    size_t structure_size,\n    uint8_t** instruction_addr,\n    void** argument_addr,\n    size_t* code_size)\n{\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &opcode,\n      sizeof(uint8_t),\n      (void**) instruction_addr));\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      structure,\n      structure_size,\n      (void**) argument_addr));\n\n  *code_size = sizeof(uint8_t) + structure_size;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 647,
        "end_line": 671,
        "is_bug": false
    },
    {
        "name": "libyara.re._yr_emit_inst_arg_uint8#543",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re._yr_emit_inst_arg_uint8(     RE_EMIT_CONTEXT* emit_context, uint8_t opcode, uint8_t argument, uint8_t** instruction_addr, uint8_t** argument_addr, size_t* code_size)",
        "snippet": "int _yr_emit_inst_arg_uint8(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    uint8_t argument,\n    uint8_t** instruction_addr,\n    uint8_t** argument_addr,\n    size_t* code_size)\n{\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &opcode,\n      sizeof(uint8_t),\n      (void**) instruction_addr));\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &argument,\n      sizeof(uint8_t),\n      (void**) argument_addr));\n\n  *code_size = 2 * sizeof(uint8_t);\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 543,
        "end_line": 566,
        "is_bug": false
    },
    {
        "name": "libyara.re._yr_emit_split#674",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re._yr_emit_split(     RE_EMIT_CONTEXT* emit_context, uint8_t opcode, int16_t argument, uint8_t** instruction_addr, int16_t** argument_addr, size_t* code_size)",
        "snippet": "int _yr_emit_split(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    int16_t argument,\n    uint8_t** instruction_addr,\n    int16_t** argument_addr,\n    size_t* code_size)\n{\n  assert(opcode == RE_OPCODE_SPLIT_A || opcode == RE_OPCODE_SPLIT_B);\n\n  if (emit_context->next_split_id == RE_MAX_SPLIT_ID)\n    return ERROR_REGULAR_EXPRESSION_TOO_COMPLEX;\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &opcode,\n      sizeof(uint8_t),\n      (void**) instruction_addr));\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &emit_context->next_split_id,\n      sizeof(RE_SPLIT_ID_TYPE),\n      NULL));\n\n  emit_context->next_split_id++;\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &argument,\n      sizeof(int16_t),\n      (void**) argument_addr));\n\n  *code_size = sizeof(uint8_t) + sizeof(RE_SPLIT_ID_TYPE) + sizeof(int16_t);\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 674,
        "end_line": 710,
        "is_bug": false
    },
    {
        "name": "libyara.re._yr_re_emit#713",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re._yr_re_emit(     RE_EMIT_CONTEXT* emit_context, RE_NODE* re_node, int flags, uint8_t** code_addr, size_t* code_size)",
        "snippet": "static int _yr_re_emit(\n    RE_EMIT_CONTEXT* emit_context,\n    RE_NODE* re_node,\n    int flags,\n    uint8_t** code_addr,\n    size_t* code_size)\n{\n  size_t branch_size;\n  size_t split_size;\n  size_t inst_size;\n  size_t jmp_size;\n\n  bool emit_split;\n  bool emit_repeat;\n  bool emit_prolog;\n  bool emit_epilog;\n\n  RE_REPEAT_ARGS repeat_args;\n  RE_REPEAT_ARGS* repeat_start_args_addr;\n  RE_REPEAT_ANY_ARGS repeat_any_args;\n\n  RE_NODE* child;\n\n  int16_t* split_offset_addr = NULL;\n  int16_t* jmp_offset_addr = NULL;\n  uint8_t* instruction_addr = NULL;\n\n  *code_size = 0;\n\n  switch(re_node->type)\n  {\n  case RE_NODE_LITERAL:\n\n    FAIL_ON_ERROR(_yr_emit_inst_arg_uint8(\n        emit_context,\n        RE_OPCODE_LITERAL,\n        re_node->value,\n        &instruction_addr,\n        NULL,\n        code_size));\n    break;\n\n  case RE_NODE_MASKED_LITERAL:\n\n    FAIL_ON_ERROR(_yr_emit_inst_arg_uint16(\n        emit_context,\n        RE_OPCODE_MASKED_LITERAL,\n        re_node->mask << 8 | re_node->value,\n        &instruction_addr,\n        NULL,\n        code_size));\n    break;\n\n  case RE_NODE_WORD_CHAR:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_WORD_CHAR,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_NON_WORD_CHAR:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_NON_WORD_CHAR,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_WORD_BOUNDARY:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_WORD_BOUNDARY,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_NON_WORD_BOUNDARY:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_NON_WORD_BOUNDARY,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_SPACE:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_SPACE,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_NON_SPACE:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_NON_SPACE,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_DIGIT:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_DIGIT,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_NON_DIGIT:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_NON_DIGIT,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_ANY:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_ANY,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_CLASS:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_CLASS,\n        &instruction_addr,\n        code_size));\n\n    FAIL_ON_ERROR(yr_arena_write_data(\n        emit_context->arena,\n        re_node->re_class,\n        sizeof(*re_node->re_class),\n        NULL));\n\n    *code_size += sizeof(*re_node->re_class);\n    break;\n\n  case RE_NODE_ANCHOR_START:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_MATCH_AT_START,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_ANCHOR_END:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_MATCH_AT_END,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_CONCAT:\n\n    FAIL_ON_ERROR(_yr_re_emit(\n        emit_context,\n        (flags & EMIT_BACKWARDS)?\n            re_node->children_tail:\n            re_node->children_head,\n        flags,\n        &instruction_addr,\n        &branch_size));\n\n    *code_size += branch_size;\n\n    if (flags & EMIT_BACKWARDS)\n      child = re_node->children_tail->prev_sibling;\n    else\n      child = re_node->children_head->next_sibling;\n\n    while (child != NULL)\n    {\n      FAIL_ON_ERROR(_yr_re_emit(\n          emit_context,\n          child,\n          flags,\n          NULL,\n          &branch_size));\n\n      *code_size += branch_size;\n\n      child = (flags & EMIT_BACKWARDS) ?\n          child->prev_sibling:\n          child->next_sibling;\n    }\n\n    break;\n\n  case RE_NODE_PLUS:\n\n    // Code for e+ looks like:\n    //\n    //          L1: code for e\n    //              split L1, L2\n    //          L2:\n\n    FAIL_ON_ERROR(_yr_re_emit(\n        emit_context,\n        re_node->children_head,\n        flags,\n        &instruction_addr,\n        &branch_size));\n\n    *code_size += branch_size;\n\n    FAIL_ON_ERROR(_yr_emit_split(\n        emit_context,\n        re_node->greedy ? RE_OPCODE_SPLIT_B : RE_OPCODE_SPLIT_A,\n        -((int16_t) branch_size),\n        NULL,\n        &split_offset_addr,\n        &split_size));\n\n    *code_size += split_size;\n    break;\n\n  case RE_NODE_STAR:\n\n    // Code for e* looks like:\n    //\n    //          L1: split L1, L2\n    //              code for e\n    //              jmp L1\n    //          L2:\n\n    FAIL_ON_ERROR(_yr_emit_split(\n        emit_context,\n        re_node->greedy ? RE_OPCODE_SPLIT_A : RE_OPCODE_SPLIT_B,\n        0,\n        &instruction_addr,\n        &split_offset_addr,\n        &split_size));\n\n    *code_size += split_size;\n\n    FAIL_ON_ERROR(_yr_re_emit(\n        emit_context,\n        re_node->children_head,\n        flags,\n        NULL,\n        &branch_size));\n\n    *code_size += branch_size;\n\n    // Emit jump with offset set to 0.\n\n    FAIL_ON_ERROR(_yr_emit_inst_arg_int16(\n        emit_context,\n        RE_OPCODE_JUMP,\n        -((uint16_t)(branch_size + split_size)),\n        NULL,\n        &jmp_offset_addr,\n        &jmp_size));\n\n    *code_size += jmp_size;\n\n    if (split_size + branch_size + jmp_size >= INT16_MAX)\n      return ERROR_REGULAR_EXPRESSION_TOO_LARGE;\n\n    // Update split offset.\n    *split_offset_addr = (int16_t) (split_size + branch_size + jmp_size);\n    break;\n\n  case RE_NODE_ALT:\n\n    // Code for e1|e2 looks like:\n    //\n    //              split L1, L2\n    //          L1: code for e1\n    //              jmp L3\n    //          L2: code for e2\n    //          L3:\n\n    // Emit a split instruction with offset set to 0 temporarily. Offset\n    // will be updated after we know the size of the code generated for\n    // the left node (e1).\n\n    FAIL_ON_ERROR(_yr_emit_split(\n        emit_context,\n        RE_OPCODE_SPLIT_A,\n        0,\n        &instruction_addr,\n        &split_offset_addr,\n        &split_size));\n\n    *code_size += split_size;\n\n    FAIL_ON_ERROR(_yr_re_emit(\n        emit_context,\n        re_node->children_head,\n        flags,\n        NULL,\n        &branch_size));\n\n    *code_size += branch_size;\n\n    // Emit jump with offset set to 0.\n\n    FAIL_ON_ERROR(_yr_emit_inst_arg_int16(\n        emit_context,\n        RE_OPCODE_JUMP,\n        0,\n        NULL,\n        &jmp_offset_addr,\n        &jmp_size));\n\n    *code_size += jmp_size;\n\n    if (split_size + branch_size + jmp_size >= INT16_MAX)\n      return ERROR_REGULAR_EXPRESSION_TOO_LARGE;\n\n    // Update split offset.\n    *split_offset_addr = (int16_t) (split_size + branch_size + jmp_size);\n\n    FAIL_ON_ERROR(_yr_re_emit(\n        emit_context,\n        re_node->children_tail,\n        flags,\n        NULL,\n        &branch_size));\n\n    *code_size += branch_size;\n\n    if (branch_size + jmp_size >= INT16_MAX)\n      return ERROR_REGULAR_EXPRESSION_TOO_LARGE;\n\n    // Update offset for jmp instruction.\n    *jmp_offset_addr = (int16_t) (branch_size + jmp_size);\n    break;\n\n  case RE_NODE_RANGE_ANY:\n\n    repeat_any_args.min = re_node->start;\n    repeat_any_args.max = re_node->end;\n\n    FAIL_ON_ERROR(_yr_emit_inst_arg_struct(\n        emit_context,\n        re_node->greedy ?\n            RE_OPCODE_REPEAT_ANY_GREEDY :\n            RE_OPCODE_REPEAT_ANY_UNGREEDY,\n        &repeat_any_args,\n        sizeof(repeat_any_args),\n        &instruction_addr,\n        NULL,\n        &inst_size));\n\n    *code_size += inst_size;\n    break;\n\n  case RE_NODE_RANGE:\n\n    // Code for e{n,m} looks like:\n    //\n    //            code for e              ---   prolog\n    //            repeat_start n, m, L1   --+\n    //        L0: code for e                |   repeat\n    //            repeat_end n, m, L0     --+\n    //        L1: split L2, L3            ---   split\n    //        L2: code for e              ---   epilog\n    //        L3:\n    //\n    // Not all sections (prolog, repeat, split and epilog) are generated in all\n    // cases, it depends on the values of n and m. The following table shows\n    // which sections are generated for the first few values of n and m.\n    //\n    //        n,m   prolog  repeat      split  epilog\n    //                      (min,max)\n    //        ---------------------------------------\n    //        0,0     -       -           -      -\n    //        0,1     -       -           X      X\n    //        0,2     -       0,1         X      X\n    //        0,3     -       0,2         X      X\n    //        0,M     -       0,M-1       X      X\n    //\n    //        1,1     X       -           -      -\n    //        1,2     X       -           X      X\n    //        1,3     X       0,1         X      X\n    //        1,4     X       1,2         X      X\n    //        1,M     X       1,M-2       X      X\n    //\n    //        2,2     X       -           -      X\n    //        2,3     X       1,1         X      X\n    //        2,4     X       1,2         X      X\n    //        2,M     X       1,M-2       X      X\n    //\n    //        3,3     X       1,1         -      X\n    //        3,4     X       2,2         X      X\n    //        3,M     X       2,M-2       X      X\n    //\n    //        4,4     X       2,2         -      X\n    //        4,5     X       3,3         X      X\n    //        4,M     X       3,M-2       X      X\n    //\n    // The code can't consists simply in the repeat section, the prolog and\n    // epilog are required because we can't have atoms pointing to code inside\n    // the repeat loop. Atoms' forwards_code will point to code in the prolog\n    // and backwards_code will point to code in the epilog (or in prolog if\n    // epilog wasn't generated, like in n=1,m=1)\n\n    emit_prolog = re_node->start > 0;\n    emit_repeat = re_node->end > re_node->start + 1 || re_node->end > 2;\n    emit_split = re_node->end > re_node->start;\n    emit_epilog = re_node->end > re_node->start || re_node->end > 1;\n\n    if (emit_prolog)\n    {\n      FAIL_ON_ERROR(_yr_re_emit(\n          emit_context,\n          re_node->children_head,\n          flags,\n          &instruction_addr,\n          &branch_size));\n\n       *code_size += branch_size;\n    }\n\n    if (emit_repeat)\n    {\n      repeat_args.min = re_node->start;\n      repeat_args.max = re_node->end;\n\n      if (emit_prolog)\n      {\n        repeat_args.max--;\n        repeat_args.min--;\n      }\n\n      if (emit_split)\n      {\n        repeat_args.max--;\n      }\n      else\n      {\n        repeat_args.min--;\n        repeat_args.max--;\n      }\n\n      repeat_args.offset = 0;\n\n      FAIL_ON_ERROR(_yr_emit_inst_arg_struct(\n          emit_context,\n          re_node->greedy ?\n              RE_OPCODE_REPEAT_START_GREEDY :\n              RE_OPCODE_REPEAT_START_UNGREEDY,\n          &repeat_args,\n          sizeof(repeat_args),\n          emit_prolog ? NULL : &instruction_addr,\n          (void**) &repeat_start_args_addr,\n          &inst_size));\n\n      *code_size += inst_size;\n\n      FAIL_ON_ERROR(_yr_re_emit(\n          emit_context,\n          re_node->children_head,\n          flags | EMIT_DONT_SET_FORWARDS_CODE | EMIT_DONT_SET_BACKWARDS_CODE,\n          NULL,\n          &branch_size));\n\n      *code_size += branch_size;\n\n      repeat_start_args_addr->offset = (int32_t)(2 * inst_size + branch_size);\n      repeat_args.offset = -((int32_t) branch_size);\n\n      FAIL_ON_ERROR(_yr_emit_inst_arg_struct(\n          emit_context,\n          re_node->greedy ?\n              RE_OPCODE_REPEAT_END_GREEDY :\n              RE_OPCODE_REPEAT_END_UNGREEDY,\n          &repeat_args,\n          sizeof(repeat_args),\n          NULL,\n          NULL,\n          &inst_size));\n\n      *code_size += inst_size;\n    }\n\n    if (emit_split)\n    {\n      FAIL_ON_ERROR(_yr_emit_split(\n          emit_context,\n          re_node->greedy ?\n              RE_OPCODE_SPLIT_A :\n              RE_OPCODE_SPLIT_B,\n          0,\n          NULL,\n          &split_offset_addr,\n          &split_size));\n\n      *code_size += split_size;\n    }\n\n    if (emit_epilog)\n    {\n      FAIL_ON_ERROR(_yr_re_emit(\n          emit_context,\n          re_node->children_head,\n          emit_prolog ? flags | EMIT_DONT_SET_FORWARDS_CODE : flags,\n          emit_prolog || emit_repeat ? NULL : &instruction_addr,\n          &branch_size));\n\n      *code_size += branch_size;\n    }\n\n    if (emit_split)\n    {\n      if (split_size + branch_size >= INT16_MAX)\n        return ERROR_REGULAR_EXPRESSION_TOO_LARGE;\n\n      *split_offset_addr = (int16_t) (split_size + branch_size);\n    }\n\n    break;\n  }\n\n  if (flags & EMIT_BACKWARDS)\n  {\n    if (!(flags & EMIT_DONT_SET_BACKWARDS_CODE))\n      re_node->backward_code = instruction_addr + *code_size;\n  }\n  else\n  {\n    if (!(flags & EMIT_DONT_SET_FORWARDS_CODE))\n      re_node->forward_code = instruction_addr;\n  }\n\n  if (code_addr != NULL)\n    *code_addr = instruction_addr;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 713,
        "end_line": 1261,
        "is_bug": false
    },
    {
        "name": "libyara.re._yr_re_fiber_create#1310",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re._yr_re_fiber_create(     RE_FIBER_POOL* fiber_pool, RE_FIBER** new_fiber)",
        "snippet": "static int _yr_re_fiber_create(\n    RE_FIBER_POOL* fiber_pool,\n    RE_FIBER** new_fiber)\n{\n  RE_FIBER* fiber;\n\n  if (fiber_pool->fibers.head != NULL)\n  {\n    fiber = fiber_pool->fibers.head;\n    fiber_pool->fibers.head = fiber->next;\n\n    if (fiber_pool->fibers.tail == fiber)\n      fiber_pool->fibers.tail = NULL;\n  }\n  else\n  {\n    if (fiber_pool->fiber_count == RE_MAX_FIBERS)\n      return ERROR_TOO_MANY_RE_FIBERS;\n\n    fiber = (RE_FIBER*) yr_malloc(sizeof(RE_FIBER));\n\n    if (fiber == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    fiber_pool->fiber_count++;\n  }\n\n  fiber->ip = NULL;\n  fiber->sp = -1;\n  fiber->rc = -1;\n  fiber->next = NULL;\n  fiber->prev = NULL;\n\n  *new_fiber = fiber;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 1310,
        "end_line": 1346,
        "is_bug": false
    },
    {
        "name": "libyara.re._yr_re_fiber_exists#1386",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re._yr_re_fiber_exists(     RE_FIBER_LIST* fiber_list, RE_FIBER* target_fiber, RE_FIBER* last_fiber)",
        "snippet": "static int _yr_re_fiber_exists(\n    RE_FIBER_LIST* fiber_list,\n    RE_FIBER* target_fiber,\n    RE_FIBER* last_fiber)\n{\n  RE_FIBER* fiber = fiber_list->head;\n\n  int equal_stacks;\n  int i;\n\n  if (last_fiber == NULL)\n    return false;\n\n  while (fiber != last_fiber->next)\n  {\n    if (fiber->ip == target_fiber->ip &&\n        fiber->sp == target_fiber->sp &&\n        fiber->rc == target_fiber->rc)\n    {\n      equal_stacks = true;\n\n      for (i = 0; i <= fiber->sp; i++)\n      {\n        if (fiber->stack[i] != target_fiber->stack[i])\n        {\n          equal_stacks = false;\n          break;\n        }\n      }\n\n      if (equal_stacks)\n        return true;\n    }\n\n    fiber = fiber->next;\n  }\n\n  return false;\n}",
        "begin_line": 1386,
        "end_line": 1424,
        "is_bug": false
    },
    {
        "name": "libyara.re._yr_re_fiber_kill#1482",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re._yr_re_fiber_kill(     RE_FIBER_LIST* fiber_list, RE_FIBER_POOL* fiber_pool, RE_FIBER* fiber)",
        "snippet": "static RE_FIBER* _yr_re_fiber_kill(\n    RE_FIBER_LIST* fiber_list,\n    RE_FIBER_POOL* fiber_pool,\n    RE_FIBER* fiber)\n{\n  RE_FIBER* next_fiber = fiber->next;\n\n  if (fiber->prev != NULL)\n    fiber->prev->next = next_fiber;\n\n  if (next_fiber != NULL)\n    next_fiber->prev = fiber->prev;\n\n  if (fiber_pool->fibers.tail != NULL)\n    fiber_pool->fibers.tail->next = fiber;\n\n  if (fiber_list->tail == fiber)\n    fiber_list->tail = fiber->prev;\n\n  if (fiber_list->head == fiber)\n    fiber_list->head = next_fiber;\n\n  fiber->next = NULL;\n  fiber->prev = fiber_pool->fibers.tail;\n  fiber_pool->fibers.tail = fiber;\n\n  if (fiber_pool->fibers.head == NULL)\n    fiber_pool->fibers.head = fiber;\n\n  return next_fiber;\n}",
        "begin_line": 1482,
        "end_line": 1512,
        "is_bug": false
    },
    {
        "name": "libyara.re._yr_re_fiber_kill_tail#1521",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re._yr_re_fiber_kill_tail(   RE_FIBER_LIST* fiber_list, RE_FIBER_POOL* fiber_pool, RE_FIBER* fiber)",
        "snippet": "static void _yr_re_fiber_kill_tail(\n  RE_FIBER_LIST* fiber_list,\n  RE_FIBER_POOL* fiber_pool,\n  RE_FIBER* fiber)\n{\n  RE_FIBER* prev_fiber = fiber->prev;\n\n  if (prev_fiber != NULL)\n    prev_fiber->next = NULL;\n\n  fiber->prev = fiber_pool->fibers.tail;\n\n  if (fiber_pool->fibers.tail != NULL)\n    fiber_pool->fibers.tail->next = fiber;\n\n  fiber_pool->fibers.tail = fiber_list->tail;\n  fiber_list->tail = prev_fiber;\n\n  if (fiber_list->head == fiber)\n    fiber_list->head = NULL;\n\n  if (fiber_pool->fibers.head == NULL)\n    fiber_pool->fibers.head = fiber;\n}",
        "begin_line": 1521,
        "end_line": 1544,
        "is_bug": false
    },
    {
        "name": "libyara.re._yr_re_fiber_split#1440",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re._yr_re_fiber_split(     RE_FIBER_LIST* fiber_list, RE_FIBER_POOL* fiber_pool, RE_FIBER* fiber, RE_FIBER** new_fiber)",
        "snippet": "static int _yr_re_fiber_split(\n    RE_FIBER_LIST* fiber_list,\n    RE_FIBER_POOL* fiber_pool,\n    RE_FIBER* fiber,\n    RE_FIBER** new_fiber)\n{\n  int32_t i;\n\n  FAIL_ON_ERROR(_yr_re_fiber_create(fiber_pool, new_fiber));\n\n  (*new_fiber)->sp = fiber->sp;\n  (*new_fiber)->ip = fiber->ip;\n  (*new_fiber)->rc = fiber->rc;\n\n  for (i = 0; i <= fiber->sp; i++)\n    (*new_fiber)->stack[i] = fiber->stack[i];\n\n  (*new_fiber)->next = fiber->next;\n  (*new_fiber)->prev = fiber;\n\n  if (fiber->next != NULL)\n    fiber->next->prev = *new_fiber;\n\n  fiber->next = *new_fiber;\n\n  if (fiber_list->tail == fiber)\n    fiber_list->tail = *new_fiber;\n\n  assert(fiber_list->tail->next == NULL);\n  assert(fiber_list->head->prev == NULL);\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 1440,
        "end_line": 1472,
        "is_bug": false
    },
    {
        "name": "libyara.re._yr_re_fiber_sync#1571",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re._yr_re_fiber_sync(     RE_FIBER_LIST* fiber_list, RE_FIBER_POOL* fiber_pool, RE_FIBER* fiber_to_sync)",
        "snippet": "static int _yr_re_fiber_sync(\n    RE_FIBER_LIST* fiber_list,\n    RE_FIBER_POOL* fiber_pool,\n    RE_FIBER* fiber_to_sync)\n{\n  // A array for keeping track of which split instructions has been already\n  // executed. Each split instruction within a regexp has an associated ID\n  // between 0 and RE_MAX_SPLIT_ID. Keeping track of executed splits is\n  // required to avoid infinite loops in regexps like (a*)* or (a|)*\n\n  RE_SPLIT_ID_TYPE splits_executed[RE_MAX_SPLIT_ID];\n  RE_SPLIT_ID_TYPE splits_executed_count = 0;\n  RE_SPLIT_ID_TYPE split_id, splits_executed_idx;\n\n  int split_already_executed;\n\n  RE_REPEAT_ARGS* repeat_args;\n  RE_REPEAT_ANY_ARGS* repeat_any_args;\n\n  RE_FIBER* fiber;\n  RE_FIBER* last;\n  RE_FIBER* next;\n  RE_FIBER* branch_a;\n  RE_FIBER* branch_b;\n\n  fiber = fiber_to_sync;\n  last = fiber_to_sync->next;\n\n  while (fiber != last)\n  {\n    uint8_t opcode = *fiber->ip;\n\n    switch (opcode)\n    {\n      case RE_OPCODE_SPLIT_A:\n      case RE_OPCODE_SPLIT_B:\n\n        split_id = *(RE_SPLIT_ID_TYPE*)(fiber->ip + 1);\n        split_already_executed = false;\n\n        for (splits_executed_idx = 0;\n             splits_executed_idx < splits_executed_count;\n             splits_executed_idx++)\n        {\n          if (split_id == splits_executed[splits_executed_idx])\n          {\n            split_already_executed = true;\n            break;\n          }\n        }\n\n        if (split_already_executed)\n        {\n          fiber = _yr_re_fiber_kill(fiber_list, fiber_pool, fiber);\n        }\n        else\n        {\n          branch_a = fiber;\n\n          FAIL_ON_ERROR(_yr_re_fiber_split(\n              fiber_list, fiber_pool, branch_a, &branch_b));\n\n          // With RE_OPCODE_SPLIT_A the current fiber continues at the next\n          // instruction in the stream (branch A), while the newly created\n          // fiber starts at the address indicated by the instruction (branch B)\n          // RE_OPCODE_SPLIT_B has the opposite behavior.\n\n          if (opcode == RE_OPCODE_SPLIT_B)\n            yr_swap(branch_a, branch_b, RE_FIBER*);\n\n          // Branch A continues at the next instruction\n\n          branch_a->ip += (sizeof(RE_SPLIT_ID_TYPE) + 3);\n\n          // Branch B adds the offset encoded in the opcode to its instruction\n          // pointer.\n\n          branch_b->ip += *(int16_t*)(\n              branch_b->ip\n              + 1  // opcode size\n              + sizeof(RE_SPLIT_ID_TYPE));\n\n          splits_executed[splits_executed_count] = split_id;\n          splits_executed_count++;\n        }\n\n        break;\n\n      case RE_OPCODE_REPEAT_START_GREEDY:\n      case RE_OPCODE_REPEAT_START_UNGREEDY:\n\n        repeat_args = (RE_REPEAT_ARGS*)(fiber->ip + 1);\n        assert(repeat_args->max > 0);\n        branch_a = fiber;\n\n        if (repeat_args->min == 0)\n        {\n          FAIL_ON_ERROR(_yr_re_fiber_split(\n              fiber_list, fiber_pool, branch_a, &branch_b));\n\n          if (opcode == RE_OPCODE_REPEAT_START_UNGREEDY)\n            yr_swap(branch_a, branch_b, RE_FIBER*);\n\n          branch_b->ip += repeat_args->offset;\n        }\n\n        branch_a->stack[++branch_a->sp] = 0;\n        branch_a->ip += (1 + sizeof(RE_REPEAT_ARGS));\n        break;\n\n      case RE_OPCODE_REPEAT_END_GREEDY:\n      case RE_OPCODE_REPEAT_END_UNGREEDY:\n\n        repeat_args = (RE_REPEAT_ARGS*)(fiber->ip + 1);\n        fiber->stack[fiber->sp]++;\n\n        if (fiber->stack[fiber->sp] < repeat_args->min)\n        {\n          fiber->ip += repeat_args->offset;\n          break;\n        }\n\n        branch_a = fiber;\n\n        if (fiber->stack[fiber->sp] < repeat_args->max)\n        {\n          FAIL_ON_ERROR(_yr_re_fiber_split(\n              fiber_list, fiber_pool, branch_a, &branch_b));\n\n          if (opcode == RE_OPCODE_REPEAT_END_GREEDY)\n            yr_swap(branch_a, branch_b, RE_FIBER*);\n\n          branch_a->sp--;\n          branch_b->ip += repeat_args->offset;\n        }\n\n        branch_a->ip += (1 + sizeof(RE_REPEAT_ARGS));\n        break;\n\n      case RE_OPCODE_REPEAT_ANY_GREEDY:\n      case RE_OPCODE_REPEAT_ANY_UNGREEDY:\n\n        repeat_any_args = (RE_REPEAT_ANY_ARGS*)(fiber->ip + 1);\n\n        // If repetition counter (rc) is -1 it means that we are reaching this\n        // instruction from the previous one in the instructions stream. In\n        // this case let's initialize the counter to 0 and start looping.\n\n        if (fiber->rc == -1)\n          fiber->rc = 0;\n\n        if (fiber->rc < repeat_any_args->min)\n        {\n          // Increase repetition counter and continue with next fiber. The\n          // instruction pointer for this fiber is not incremented yet, this\n          // fiber spins in this same instruction until reaching the minimum\n          // number of repetitions.\n\n          fiber->rc++;\n          fiber = fiber->next;\n        }\n        else if (fiber->rc < repeat_any_args->max)\n        {\n          // Once the minimum number of repetitions are matched one fiber\n          // remains spinning in this instruction until reaching the maximum\n          // number of repetitions while new fibers are created. New fibers\n          // start executing at the next instruction.\n\n          next = fiber->next;\n          branch_a = fiber;\n\n          FAIL_ON_ERROR(_yr_re_fiber_split(\n              fiber_list, fiber_pool, branch_a, &branch_b));\n\n          if (opcode == RE_OPCODE_REPEAT_ANY_UNGREEDY)\n            yr_swap(branch_a, branch_b, RE_FIBER*);\n\n          branch_a->rc++;\n          branch_b->ip += (1 + sizeof(RE_REPEAT_ANY_ARGS));\n          branch_b->rc = -1;\n\n          FAIL_ON_ERROR(_yr_re_fiber_sync(\n              fiber_list, fiber_pool, branch_b));\n\n          fiber = next;\n        }\n        else\n        {\n          // When the maximum number of repetitions is reached the fiber keeps\n          // executing at the next instruction. The repetition counter is set\n          // to -1 indicating that we are not spinning in a repeat instruction\n          // anymore.\n\n          fiber->ip += (1 + sizeof(RE_REPEAT_ANY_ARGS));\n          fiber->rc = -1;\n        }\n\n        break;\n\n      case RE_OPCODE_JUMP:\n        fiber->ip += *(int16_t*)(fiber->ip + 1);\n        break;\n\n      default:\n        fiber = fiber->next;\n    }\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 1571,
        "end_line": 1780,
        "is_bug": false
    },
    {
        "name": "libyara.re._yr_re_is_char_in_class#96",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re._yr_re_is_char_in_class(     RE_CLASS* re_class, uint8_t chr, int case_insensitive)",
        "snippet": "static bool _yr_re_is_char_in_class(\n    RE_CLASS* re_class,\n    uint8_t chr,\n    int case_insensitive)\n{\n  int result = CHAR_IN_CLASS(re_class->bitmap, chr);\n\n  if (case_insensitive)\n    result |= CHAR_IN_CLASS(re_class->bitmap, yr_altercase[chr]);\n\n  if (re_class->negated)\n    result = !result;\n\n  return result;\n}",
        "begin_line": 96,
        "end_line": 110,
        "is_bug": false
    },
    {
        "name": "libyara.re._yr_re_is_word_char#113",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re._yr_re_is_word_char(     const uint8_t* input, uint8_t character_size)",
        "snippet": "static bool _yr_re_is_word_char(\n    const uint8_t* input,\n    uint8_t character_size)\n{\n  int result = ((isalnum(*input) || (*input) == '_'));\n\n  if (character_size == 2)\n    result = result && (*(input + 1) == 0);\n\n  return result;\n}",
        "begin_line": 113,
        "end_line": 123,
        "is_bug": false
    },
    {
        "name": "libyara.re._yr_re_node_contains_dot_star#408",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re._yr_re_node_contains_dot_star(     RE_NODE* re_node)",
        "snippet": "int _yr_re_node_contains_dot_star(\n    RE_NODE* re_node)\n{\n  RE_NODE* child;\n\n  if ((re_node->type == RE_NODE_STAR || re_node->type == RE_NODE_PLUS) &&\n      re_node->children_head->type == RE_NODE_ANY)\n    return true;\n\n  if (re_node->type == RE_NODE_CONCAT)\n  {\n    child = re_node->children_tail;\n\n    while (child != NULL)\n    {\n      if (_yr_re_node_contains_dot_star(child))\n        return true;\n\n      child = child->prev_sibling;\n    }\n  }\n\n  return false;\n}",
        "begin_line": 408,
        "end_line": 431,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_ast_contains_dot_star#434",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_ast_contains_dot_star(     RE_AST* re_ast)",
        "snippet": "int yr_re_ast_contains_dot_star(\n    RE_AST* re_ast)\n{\n  return _yr_re_node_contains_dot_star(re_ast->root_node);\n}",
        "begin_line": 434,
        "end_line": 438,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_ast_create#208",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_ast_create(     RE_AST** re_ast)",
        "snippet": "int yr_re_ast_create(\n    RE_AST** re_ast)\n{\n  *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));\n\n  if (*re_ast == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  (*re_ast)->flags = 0;\n  (*re_ast)->root_node = NULL;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 208,
        "end_line": 220,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_ast_destroy#223",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_ast_destroy(     RE_AST* re_ast)",
        "snippet": "void yr_re_ast_destroy(\n    RE_AST* re_ast)\n{\n  if (re_ast->root_node != NULL)\n    yr_re_node_destroy(re_ast->root_node);\n\n  yr_free(re_ast);\n}",
        "begin_line": 223,
        "end_line": 230,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_ast_emit_code#1264",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_ast_emit_code(     RE_AST* re_ast, YR_ARENA* arena, int backwards_code)",
        "snippet": "int yr_re_ast_emit_code(\n    RE_AST* re_ast,\n    YR_ARENA* arena,\n    int backwards_code)\n{\n  RE_EMIT_CONTEXT emit_context;\n\n  size_t code_size;\n  size_t total_size;\n\n  // Ensure that we have enough contiguous memory space in the arena to\n  // contain the regular expression code. The code can't span over multiple\n  // non-contiguous pages.\n\n  FAIL_ON_ERROR(yr_arena_reserve_memory(arena, RE_MAX_CODE_SIZE));\n\n  // Emit code for matching the regular expressions forwards.\n\n  total_size = 0;\n  emit_context.arena = arena;\n  emit_context.next_split_id = 0;\n\n  FAIL_ON_ERROR(_yr_re_emit(\n      &emit_context,\n      re_ast->root_node,\n      backwards_code ? EMIT_BACKWARDS : 0,\n      NULL,\n      &code_size));\n\n  total_size += code_size;\n\n  FAIL_ON_ERROR(_yr_emit_inst(\n      &emit_context,\n      RE_OPCODE_MATCH,\n      NULL,\n      &code_size));\n\n  total_size += code_size;\n\n  if (total_size > RE_MAX_CODE_SIZE)\n    return ERROR_REGULAR_EXPRESSION_TOO_LARGE;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 1264,
        "end_line": 1307,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_ast_extract_literal#353",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_ast_extract_literal(     RE_AST* re_ast)",
        "snippet": "SIZED_STRING* yr_re_ast_extract_literal(\n    RE_AST* re_ast)\n{\n  SIZED_STRING* string;\n  RE_NODE* child;\n\n  int length = 0;\n\n  if (re_ast->root_node->type == RE_NODE_LITERAL)\n  {\n    length = 1;\n  }\n  else if (re_ast->root_node->type == RE_NODE_CONCAT)\n  {\n    child = re_ast->root_node->children_tail;\n\n    while (child != NULL && child->type == RE_NODE_LITERAL)\n    {\n      length++;\n      child = child->prev_sibling;\n    }\n\n    if (child != NULL)\n      return NULL;\n  }\n  else\n  {\n    return NULL;\n  }\n\n  string = (SIZED_STRING*) yr_malloc(sizeof(SIZED_STRING) + length);\n\n  if (string == NULL)\n    return NULL;\n\n  string->length = length;\n\n  if (re_ast->root_node->type == RE_NODE_LITERAL)\n  {\n    string->c_string[0] = re_ast->root_node->value;\n  }\n  else\n  {\n    child = re_ast->root_node->children_tail;\n    while (child != NULL)\n    {\n      string->c_string[--length] = child->value;\n      child = child->prev_sibling;\n    }\n  }\n\n  return string;\n}",
        "begin_line": 353,
        "end_line": 405,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_ast_split_at_chaining_point#456",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_ast_split_at_chaining_point(     RE_AST* re_ast, RE_AST** result_re_ast, RE_AST** remainder_re_ast, int32_t* min_gap, int32_t* max_gap)",
        "snippet": "int yr_re_ast_split_at_chaining_point(\n    RE_AST* re_ast,\n    RE_AST** result_re_ast,\n    RE_AST** remainder_re_ast,\n    int32_t* min_gap,\n    int32_t* max_gap)\n{\n  RE_NODE* child;\n  RE_NODE* concat;\n\n  int result;\n\n  *result_re_ast = re_ast;\n  *remainder_re_ast = NULL;\n  *min_gap = 0;\n  *max_gap = 0;\n\n  if (re_ast->root_node->type != RE_NODE_CONCAT)\n    return ERROR_SUCCESS;\n\n  child = re_ast->root_node->children_head;\n\n  while (child != NULL)\n  {\n    if (!child->greedy &&\n         child->type == RE_NODE_RANGE_ANY &&\n         child->prev_sibling != NULL &&\n         child->next_sibling != NULL &&\n        (child->start > YR_STRING_CHAINING_THRESHOLD ||\n         child->end > YR_STRING_CHAINING_THRESHOLD))\n    {\n      result = yr_re_ast_create(remainder_re_ast);\n\n      if (result != ERROR_SUCCESS)\n        return result;\n\n      concat = yr_re_node_create(RE_NODE_CONCAT);\n\n      if (concat == NULL)\n        return ERROR_INSUFFICIENT_MEMORY;\n\n      concat->children_head = re_ast->root_node->children_head;\n      concat->children_tail = child->prev_sibling;\n\n      re_ast->root_node->children_head = child->next_sibling;\n\n      child->prev_sibling->next_sibling = NULL;\n      child->next_sibling->prev_sibling = NULL;\n\n      *min_gap = child->start;\n      *max_gap = child->end;\n\n      (*result_re_ast)->root_node = re_ast->root_node;\n      (*result_re_ast)->flags = re_ast->flags;\n      (*remainder_re_ast)->root_node = concat;\n      (*remainder_re_ast)->flags = re_ast->flags;\n\n      yr_re_node_destroy(child);\n\n      return ERROR_SUCCESS;\n    }\n\n    child = child->next_sibling;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 456,
        "end_line": 522,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_exec#1822",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_exec(     YR_SCAN_CONTEXT* context, const uint8_t* code, const uint8_t* input_data, size_t input_forwards_size, size_t input_backwards_size, int flags, RE_MATCH_CALLBACK_FUNC callback, void* callback_args, int* matches)",
        "snippet": "int yr_re_exec(\n    YR_SCAN_CONTEXT* context,\n    const uint8_t* code,\n    const uint8_t* input_data,\n    size_t input_forwards_size,\n    size_t input_backwards_size,\n    int flags,\n    RE_MATCH_CALLBACK_FUNC callback,\n    void* callback_args,\n    int* matches)\n{\n  const uint8_t* input;\n  const uint8_t* ip;\n\n  uint8_t mask;\n  uint8_t value;\n  uint8_t character_size;\n\n  RE_FIBER_LIST fibers;\n  RE_FIBER* fiber;\n  RE_FIBER* next_fiber;\n\n  int bytes_matched;\n  int max_bytes_matched;\n  int match;\n  int input_incr;\n  int kill;\n  int action;\n\n  #define ACTION_NONE       0\n  #define ACTION_CONTINUE   1\n  #define ACTION_KILL       2\n  #define ACTION_KILL_TAIL  3\n\n  #define prolog { \\\n      if ((bytes_matched >= max_bytes_matched) || \\\n          (character_size == 2 && *(input + 1) != 0)) \\\n      { \\\n        action = ACTION_KILL; \\\n        break; \\\n      } \\\n    }\n\n  if (matches != NULL)\n    *matches = -1;\n\n  if (flags & RE_FLAGS_WIDE)\n    character_size = 2;\n  else\n    character_size = 1;\n\n  input = input_data;\n  input_incr = character_size;\n\n  if (flags & RE_FLAGS_BACKWARDS)\n  {\n    max_bytes_matched = (int) yr_min(input_backwards_size, RE_SCAN_LIMIT);\n    input -= character_size;\n    input_incr = -input_incr;\n  }\n  else\n  {\n    max_bytes_matched = (int) yr_min(input_forwards_size, RE_SCAN_LIMIT);\n  }\n\n  // Round down max_bytes_matched to a multiple of character_size, this way if\n  // character_size is 2 and max_bytes_matched is odd we are ignoring the\n  // extra byte which can't match anyways.\n\n  max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size;\n  bytes_matched = 0;\n\n  FAIL_ON_ERROR(_yr_re_fiber_create(&context->re_fiber_pool, &fiber));\n\n  fiber->ip = code;\n  fibers.head = fiber;\n  fibers.tail = fiber;\n\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      _yr_re_fiber_sync(&fibers, &context->re_fiber_pool, fiber),\n      _yr_re_fiber_kill_all(&fibers, &context->re_fiber_pool));\n\n  while (fibers.head != NULL)\n  {\n    fiber = fibers.head;\n\n    while (fiber != NULL)\n    {\n      next_fiber = fiber->next;\n\n      if (_yr_re_fiber_exists(&fibers, fiber, fiber->prev))\n        _yr_re_fiber_kill(&fibers, &context->re_fiber_pool, fiber);\n\n      fiber = next_fiber;\n    }\n\n    fiber = fibers.head;\n\n    while (fiber != NULL)\n    {\n      ip = fiber->ip;\n      action = ACTION_NONE;\n\n      switch (*ip)\n      {\n        case RE_OPCODE_ANY:\n          prolog;\n          match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_REPEAT_ANY_GREEDY:\n        case RE_OPCODE_REPEAT_ANY_UNGREEDY:\n          prolog;\n          match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);\n          action = match ? ACTION_NONE : ACTION_KILL;\n\n          // The instruction pointer is not incremented here. The current fiber\n          // spins in this instruction until reaching the required number of\n          // repetitions. The code controlling the number of repetitions is in\n          // _yr_re_fiber_sync.\n\n          break;\n\n        case RE_OPCODE_LITERAL:\n          prolog;\n          if (flags & RE_FLAGS_NO_CASE)\n            match = yr_lowercase[*input] == yr_lowercase[*(ip + 1)];\n          else\n            match = (*input == *(ip + 1));\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 2;\n          break;\n\n        case RE_OPCODE_MASKED_LITERAL:\n          prolog;\n          value = *(int16_t*)(ip + 1) & 0xFF;\n          mask = *(int16_t*)(ip + 1) >> 8;\n\n          // We don't need to take into account the case-insensitive\n          // case because this opcode is only used with hex strings,\n          // which can't be case-insensitive.\n\n          match = ((*input & mask) == value);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 3;\n          break;\n\n        case RE_OPCODE_CLASS:\n          prolog;\n          match = _yr_re_is_char_in_class(\n              (RE_CLASS*) (ip + 1), *input, flags & RE_FLAGS_NO_CASE);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += (sizeof(RE_CLASS) + 1);\n          break;\n\n        case RE_OPCODE_WORD_CHAR:\n          prolog;\n          match = _yr_re_is_word_char(input, character_size);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_NON_WORD_CHAR:\n          prolog;\n          match = !_yr_re_is_word_char(input, character_size);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_SPACE:\n        case RE_OPCODE_NON_SPACE:\n\n          prolog;\n\n          switch (*input)\n          {\n            case ' ':\n            case '\\t':\n            case '\\r':\n            case '\\n':\n            case '\\v':\n            case '\\f':\n              match = true;\n              break;\n            default:\n              match = false;\n          }\n\n          if (*ip == RE_OPCODE_NON_SPACE)\n            match = !match;\n\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_DIGIT:\n          prolog;\n          match = isdigit(*input);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_NON_DIGIT:\n          prolog;\n          match = !isdigit(*input);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_WORD_BOUNDARY:\n        case RE_OPCODE_NON_WORD_BOUNDARY:\n\n          if (bytes_matched == 0 && input_backwards_size < character_size)\n          {\n            match = true;\n          }\n          else if (bytes_matched >= max_bytes_matched)\n          {\n            match = true;\n          }\n          else\n          {\n            assert(input <  input_data + input_forwards_size);\n            assert(input >= input_data - input_backwards_size);\n\n            assert(input - input_incr <  input_data + input_forwards_size);\n            assert(input - input_incr >= input_data - input_backwards_size);\n\n            match = _yr_re_is_word_char(input, character_size) != \\\n                    _yr_re_is_word_char(input - input_incr, character_size);\n          }\n\n          if (*ip == RE_OPCODE_NON_WORD_BOUNDARY)\n            match = !match;\n\n          action = match ? ACTION_CONTINUE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_MATCH_AT_START:\n          if (flags & RE_FLAGS_BACKWARDS)\n            kill = input_backwards_size > (size_t) bytes_matched;\n          else\n            kill = input_backwards_size > 0 || (bytes_matched != 0);\n          action = kill ? ACTION_KILL : ACTION_CONTINUE;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_MATCH_AT_END:\n          kill = flags & RE_FLAGS_BACKWARDS ||\n                 input_forwards_size > (size_t) bytes_matched;\n          action = kill ? ACTION_KILL : ACTION_CONTINUE;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_MATCH:\n\n          if (matches != NULL)\n            *matches = bytes_matched;\n\n          if (flags & RE_FLAGS_EXHAUSTIVE)\n          {\n            if (callback != NULL)\n            {\n              if (flags & RE_FLAGS_BACKWARDS)\n              {\n                FAIL_ON_ERROR_WITH_CLEANUP(\n                    callback(\n                        input + character_size,\n                        bytes_matched,\n                        flags,\n                        callback_args),\n                    _yr_re_fiber_kill_all(&fibers, &context->re_fiber_pool));\n              }\n              else\n              {\n                FAIL_ON_ERROR_WITH_CLEANUP(\n                    callback(\n                        input_data,\n                        bytes_matched,\n                        flags,\n                        callback_args),\n                    _yr_re_fiber_kill_all(&fibers, &context->re_fiber_pool));\n              }\n            }\n\n            action = ACTION_KILL;\n          }\n          else\n          {\n            action = ACTION_KILL_TAIL;\n          }\n\n          break;\n\n        default:\n          assert(false);\n      }\n\n      switch (action)\n      {\n        case ACTION_KILL:\n          fiber = _yr_re_fiber_kill(&fibers, &context->re_fiber_pool, fiber);\n          break;\n\n        case ACTION_KILL_TAIL:\n          _yr_re_fiber_kill_tail(&fibers, &context->re_fiber_pool, fiber);\n          fiber = NULL;\n          break;\n\n        case ACTION_CONTINUE:\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              _yr_re_fiber_sync(&fibers, &context->re_fiber_pool, fiber),\n              _yr_re_fiber_kill_all(&fibers, &context->re_fiber_pool));\n          break;\n\n        default:\n          next_fiber = fiber->next;\n          FAIL_ON_ERROR_WITH_CLEANUP(\n              _yr_re_fiber_sync(&fibers, &context->re_fiber_pool, fiber),\n              _yr_re_fiber_kill_all(&fibers, &context->re_fiber_pool));\n          fiber = next_fiber;\n      }\n    }\n\n    input += input_incr;\n    bytes_matched += character_size;\n\n    if (flags & RE_FLAGS_SCAN && bytes_matched < max_bytes_matched)\n    {\n      FAIL_ON_ERROR_WITH_CLEANUP(\n          _yr_re_fiber_create(&context->re_fiber_pool, &fiber),\n          _yr_re_fiber_kill_all(&fibers, &context->re_fiber_pool));\n\n      fiber->ip = code;\n      _yr_re_fiber_append(&fibers, fiber);\n\n      FAIL_ON_ERROR_WITH_CLEANUP(\n          _yr_re_fiber_sync(&fibers, &context->re_fiber_pool, fiber),\n          _yr_re_fiber_kill_all(&fibers, &context->re_fiber_pool));\n    }\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 1822,
        "end_line": 2168,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_node_append_child#172",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_node_append_child(     RE_NODE* node, RE_NODE* child)",
        "snippet": "void yr_re_node_append_child(\n    RE_NODE* node,\n    RE_NODE* child)\n{\n  if (node->children_head == NULL)\n    node->children_head = child;\n\n  if (node->children_tail != NULL)\n    node->children_tail->next_sibling = child;\n\n  child->prev_sibling = node->children_tail;\n  node->children_tail = child;\n}",
        "begin_line": 172,
        "end_line": 184,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_node_create#126",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_node_create(     int type)",
        "snippet": "RE_NODE* yr_re_node_create(\n    int type)\n{\n  RE_NODE* result = (RE_NODE*) yr_malloc(sizeof(RE_NODE));\n\n  if (result != NULL)\n  {\n    result->type = type;\n    result->children_head = NULL;\n    result->children_tail = NULL;\n    result->prev_sibling = NULL;\n    result->next_sibling = NULL;\n    result->greedy = true;\n    result->forward_code = NULL;\n    result->backward_code = NULL;\n  }\n\n  return result;\n}",
        "begin_line": 126,
        "end_line": 144,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_node_destroy#147",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_node_destroy(     RE_NODE* node)",
        "snippet": "void yr_re_node_destroy(\n    RE_NODE* node)\n{\n  RE_NODE* child = node->children_head;\n  RE_NODE* next_child;\n\n  while (child != NULL)\n  {\n    next_child = child->next_sibling;\n    yr_re_node_destroy(child);\n    child = next_child;\n  }\n\n  if (node->type == RE_NODE_CLASS)\n    yr_free(node->re_class);\n\n  yr_free(node);\n}",
        "begin_line": 147,
        "end_line": 164,
        "is_bug": false
    },
    {
        "name": "libyara.re.yr_re_parse#240",
        "src_path": "libyara/re.c",
        "class_name": "libyara.re",
        "signature": "libyara.re.yr_re_parse(     const char* re_string, RE_AST** re_ast, RE_ERROR* error)",
        "snippet": "int yr_re_parse(\n    const char* re_string,\n    RE_AST** re_ast,\n    RE_ERROR* error)\n{\n  return yr_parse_re_string(re_string, re_ast, error);\n}",
        "begin_line": 240,
        "end_line": 246,
        "is_bug": false
    },
    {
        "name": "libyara.re_grammar.re_yyparse#1172",
        "src_path": "libyara/re_grammar.c",
        "class_name": "libyara.re_grammar",
        "signature": "libyara.re_grammar.)",
        "snippet": "int\nyyparse (void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)\n{\n/* The lookahead symbol.  */\nint yychar;\n\n\n/* The semantic value of the lookahead symbol.  */\n/* Default value used for initialization, for pacifying older GCCs\n   or non-GCC compilers.  */\nYY_INITIAL_VALUE (static YYSTYPE yyval_default;)\nYYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n\n    /* Number of syntax errors so far.  */\n    int yynerrs;\n\n    yy_state_fast_t yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yy_state_t yyssa[YYINITDEPTH];\n    yy_state_t *yyss;\n    yy_state_t *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYPTRDIFF_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYPTRDIFF_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n  goto yysetstate;\n\n\n/*------------------------------------------------------------.\n| yynewstate -- push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\nyynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n\n/*--------------------------------------------------------------------.\n| yysetstate -- set current state (the top of the stack) to yystate.  |\n`--------------------------------------------------------------------*/\nyysetstate:\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);\n  YY_IGNORE_USELESS_CAST_BEGIN\n  *yyssp = YY_CAST (yy_state_t, yystate);\n  YY_IGNORE_USELESS_CAST_END\n\n  if (yyss + yystacksize - 1 <= yyssp)\n#if !defined yyoverflow && !defined YYSTACK_RELOCATE\n    goto yyexhaustedlab;\n#else\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYPTRDIFF_T yysize = yyssp - yyss + 1;\n\n# if defined yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        yy_state_t *yyss1 = yyss;\n        YYSTYPE *yyvs1 = yyvs;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * YYSIZEOF (*yyssp),\n                    &yyvs1, yysize * YYSIZEOF (*yyvsp),\n                    &yystacksize);\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n# else /* defined YYSTACK_RELOCATE */\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yy_state_t *yyss1 = yyss;\n        union yyalloc *yyptr =\n          YY_CAST (union yyalloc *,\n                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n# undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YY_IGNORE_USELESS_CAST_BEGIN\n      YYDPRINTF ((stderr, \"Stack size increased to %ld\\n\",\n                  YY_CAST (long, yystacksize)));\n      YY_IGNORE_USELESS_CAST_END\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex (&yylval, yyscanner, lex_env);\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n  case 2:\n#line 105 \"re_grammar.y\"\n      {\n        RE_AST* re_ast = yyget_extra(yyscanner);\n        re_ast->root_node = (yyvsp[0].re_node);\n      }\n#line 1434 \"re_grammar.c\"\n    break;\n\n  case 4:\n#line 114 \"re_grammar.y\"\n      {\n        (yyval.re_node) = (yyvsp[0].re_node);\n      }\n#line 1442 \"re_grammar.c\"\n    break;\n\n  case 5:\n#line 118 \"re_grammar.y\"\n      {\n        mark_as_not_fast_regexp();\n\n        (yyval.re_node) = yr_re_node_create(RE_NODE_ALT);\n\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[0].re_node));\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        yr_re_node_append_child((yyval.re_node), (yyvsp[-2].re_node));\n        yr_re_node_append_child((yyval.re_node), (yyvsp[0].re_node));\n      }\n#line 1460 \"re_grammar.c\"\n    break;\n\n  case 6:\n#line 132 \"re_grammar.y\"\n      {\n        RE_NODE* node;\n\n        mark_as_not_fast_regexp();\n\n        node = yr_re_node_create(RE_NODE_EMPTY);\n\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));\n        fail_if(node == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        (yyval.re_node) = yr_re_node_create(RE_NODE_ALT);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        yr_re_node_append_child((yyval.re_node), (yyvsp[-1].re_node));\n        yr_re_node_append_child((yyval.re_node), node);\n      }\n#line 1482 \"re_grammar.c\"\n    break;\n\n  case 7:\n#line 153 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT);\n\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[0].re_node));\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        yr_re_node_append_child((yyval.re_node), (yyvsp[0].re_node));\n      }\n#line 1495 \"re_grammar.c\"\n    break;\n\n  case 8:\n#line 162 \"re_grammar.y\"\n      {\n        yr_re_node_append_child((yyvsp[-1].re_node), (yyvsp[0].re_node));\n        (yyval.re_node) = (yyvsp[-1].re_node);\n      }\n#line 1504 \"re_grammar.c\"\n    break;\n\n  case 9:\n#line 170 \"re_grammar.y\"\n      {\n        RE_AST* re_ast;\n\n        mark_as_not_fast_regexp();\n\n        re_ast = yyget_extra(yyscanner);\n        re_ast->flags |= RE_FLAGS_GREEDY;\n\n        (yyval.re_node) = yr_re_node_create(RE_NODE_STAR);\n\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        yr_re_node_append_child((yyval.re_node), (yyvsp[-1].re_node));\n      }\n#line 1524 \"re_grammar.c\"\n    break;\n\n  case 10:\n#line 186 \"re_grammar.y\"\n      {\n        RE_AST* re_ast;\n\n        mark_as_not_fast_regexp();\n\n        re_ast = yyget_extra(yyscanner);\n        re_ast->flags |= RE_FLAGS_UNGREEDY;\n\n        (yyval.re_node) = yr_re_node_create(RE_NODE_STAR);\n\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        yr_re_node_append_child((yyval.re_node), (yyvsp[-2].re_node));\n\n        (yyval.re_node)->greedy = false;\n      }\n#line 1546 \"re_grammar.c\"\n    break;\n\n  case 11:\n#line 204 \"re_grammar.y\"\n      {\n        RE_AST* re_ast;\n\n        mark_as_not_fast_regexp();\n\n        re_ast = yyget_extra(yyscanner);\n        re_ast->flags |= RE_FLAGS_GREEDY;\n\n        (yyval.re_node) = yr_re_node_create(RE_NODE_PLUS);\n\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        yr_re_node_append_child((yyval.re_node), (yyvsp[-1].re_node));\n      }\n#line 1566 \"re_grammar.c\"\n    break;\n\n  case 12:\n#line 220 \"re_grammar.y\"\n      {\n        RE_AST* re_ast;\n\n        mark_as_not_fast_regexp();\n\n        re_ast = yyget_extra(yyscanner);\n        re_ast->flags |= RE_FLAGS_UNGREEDY;\n\n        (yyval.re_node) = yr_re_node_create(RE_NODE_PLUS);\n\n        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        yr_re_node_append_child((yyval.re_node), (yyvsp[-2].re_node));\n        (yyval.re_node)->greedy = false;\n      }\n#line 1587 \"re_grammar.c\"\n    break;\n\n  case 13:\n#line 237 \"re_grammar.y\"\n      {\n        RE_AST* re_ast = yyget_extra(yyscanner);\n        re_ast->flags |= RE_FLAGS_GREEDY;\n\n        if ((yyvsp[-1].re_node)->type == RE_NODE_ANY)\n        {\n          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);\n          destroy_node_if(true, (yyvsp[-1].re_node));\n          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n        }\n        else\n        {\n          mark_as_not_fast_regexp();\n          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE);\n          destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));\n          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n          yr_re_node_append_child((yyval.re_node), (yyvsp[-1].re_node));\n        }\n\n        (yyval.re_node)->start = 0;\n        (yyval.re_node)->end = 1;\n      }\n#line 1614 \"re_grammar.c\"\n    break;\n\n  case 14:\n#line 260 \"re_grammar.y\"\n      {\n        RE_AST* re_ast = yyget_extra(yyscanner);\n        re_ast->flags |= RE_FLAGS_UNGREEDY;\n\n        if ((yyvsp[-2].re_node)->type == RE_NODE_ANY)\n        {\n          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);\n          destroy_node_if(true, (yyvsp[-2].re_node));\n          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n        }\n        else\n        {\n          mark_as_not_fast_regexp();\n          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE);\n          destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));\n          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n          yr_re_node_append_child((yyval.re_node), (yyvsp[-2].re_node));\n        }\n\n        (yyval.re_node)->start = 0;\n        (yyval.re_node)->end = 1;\n        (yyval.re_node)->greedy = false;\n      }\n#line 1642 \"re_grammar.c\"\n    break;\n\n  case 15:\n#line 284 \"re_grammar.y\"\n      {\n        RE_AST* re_ast = yyget_extra(yyscanner);\n        re_ast->flags |= RE_FLAGS_GREEDY;\n\n        if ((yyvsp[-1].re_node)->type == RE_NODE_ANY)\n        {\n          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);\n          destroy_node_if(true, (yyvsp[-1].re_node));\n          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n        }\n        else\n        {\n          mark_as_not_fast_regexp();\n          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE);\n          destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));\n          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n          yr_re_node_append_child((yyval.re_node), (yyvsp[-1].re_node));\n        }\n\n        (yyval.re_node)->start = (yyvsp[0].range) & 0xFFFF;;\n        (yyval.re_node)->end = (yyvsp[0].range) >> 16;;\n      }\n#line 1669 \"re_grammar.c\"\n    break;\n\n  case 16:\n#line 307 \"re_grammar.y\"\n      {\n        RE_AST* re_ast = yyget_extra(yyscanner);\n        re_ast->flags |= RE_FLAGS_UNGREEDY;\n\n        if ((yyvsp[-2].re_node)->type == RE_NODE_ANY)\n        {\n          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY);\n          destroy_node_if(true, (yyvsp[-2].re_node));\n          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n        }\n        else\n        {\n          mark_as_not_fast_regexp();\n          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE);\n          destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));\n          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n          yr_re_node_append_child((yyval.re_node), (yyvsp[-2].re_node));\n        }\n\n        (yyval.re_node)->start = (yyvsp[-1].range) & 0xFFFF;;\n        (yyval.re_node)->end = (yyvsp[-1].range) >> 16;;\n        (yyval.re_node)->greedy = false;\n      }\n#line 1697 \"re_grammar.c\"\n    break;\n\n  case 17:\n#line 331 \"re_grammar.y\"\n      {\n        (yyval.re_node) = (yyvsp[0].re_node);\n      }\n#line 1705 \"re_grammar.c\"\n    break;\n\n  case 18:\n#line 335 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_WORD_BOUNDARY);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n      }\n#line 1715 \"re_grammar.c\"\n    break;\n\n  case 19:\n#line 341 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_NON_WORD_BOUNDARY);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n      }\n#line 1725 \"re_grammar.c\"\n    break;\n\n  case 20:\n#line 347 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_ANCHOR_START);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n      }\n#line 1735 \"re_grammar.c\"\n    break;\n\n  case 21:\n#line 353 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_ANCHOR_END);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n      }\n#line 1745 \"re_grammar.c\"\n    break;\n\n  case 22:\n#line 362 \"re_grammar.y\"\n      {\n        (yyval.re_node) = (yyvsp[-1].re_node);\n      }\n#line 1753 \"re_grammar.c\"\n    break;\n\n  case 23:\n#line 366 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_ANY);\n\n        (yyval.re_node)->value = 0x00;\n        (yyval.re_node)->mask = 0x00;\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n      }\n#line 1766 \"re_grammar.c\"\n    break;\n\n  case 24:\n#line 375 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_LITERAL);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        (yyval.re_node)->value = (yyvsp[0].integer);\n        (yyval.re_node)->mask = 0xFF;\n      }\n#line 1779 \"re_grammar.c\"\n    break;\n\n  case 25:\n#line 384 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_WORD_CHAR);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n      }\n#line 1789 \"re_grammar.c\"\n    break;\n\n  case 26:\n#line 390 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_NON_WORD_CHAR);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n      }\n#line 1799 \"re_grammar.c\"\n    break;\n\n  case 27:\n#line 396 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_SPACE);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n      }\n#line 1809 \"re_grammar.c\"\n    break;\n\n  case 28:\n#line 402 \"re_grammar.y\"\n      {\n         (yyval.re_node) = yr_re_node_create(RE_NODE_NON_SPACE);\n\n         fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n      }\n#line 1819 \"re_grammar.c\"\n    break;\n\n  case 29:\n#line 408 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_DIGIT);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n      }\n#line 1829 \"re_grammar.c\"\n    break;\n\n  case 30:\n#line 414 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_NON_DIGIT);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n      }\n#line 1839 \"re_grammar.c\"\n    break;\n\n  case 31:\n#line 420 \"re_grammar.y\"\n      {\n        (yyval.re_node) = yr_re_node_create(RE_NODE_CLASS);\n\n        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n\n        (yyval.re_node)->re_class = (yyvsp[0].re_class);\n      }\n#line 1851 \"re_grammar.c\"\n    break;\n\n\n#line 1855 \"re_grammar.c\"\n\n      default: break;\n    }\n  /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n  {\n    const int yylhs = yyr1[yyn] - YYNTOKENS;\n    const int yyi = yypgoto[yylhs] + *yyssp;\n    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp\n               ? yytable[yyi]\n               : yydefgoto[yylhs]);\n  }\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (yyscanner, lex_env, YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        int yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = YY_CAST (char *, YYSTACK_ALLOC (YY_CAST (YYSIZE_T, yymsg_alloc)));\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (yyscanner, lex_env, yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n         error, discard it.  */\n\n      if (yychar <= YYEOF)\n        {\n          /* Return failure if at end of input.  */\n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval, yyscanner, lex_env);\n          yychar = YYEMPTY;\n        }\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n  /* Pacify compilers when the user code never invokes YYERROR and the\n     label yyerrorlab therefore never appears in user code.  */\n  if (0)\n    YYERROR;\n\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYTERROR;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n        YYABORT;\n\n\n      yydestruct (\"Error: popping\",\n                  yystos[yystate], yyvsp, yyscanner, lex_env);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (yyscanner, lex_env, YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\n\n/*-----------------------------------------------------.\n| yyreturn -- parsing is finished, return the result.  |\n`-----------------------------------------------------*/\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval, yyscanner, lex_env);\n    }\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  yystos[+*yyssp], yyvsp, yyscanner, lex_env);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n#endif\n  return yyresult;\n}",
        "begin_line": 1172,
        "end_line": 2085,
        "is_bug": false
    },
    {
        "name": "libyara.re_grammar.yydestruct#1116",
        "src_path": "libyara/re_grammar.c",
        "class_name": "libyara.re_grammar",
        "signature": "libyara.re_grammar.yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)",
        "snippet": "static void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)\n{\n  YYUSE (yyvaluep);\n  YYUSE (yyscanner);\n  YYUSE (lex_env);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  switch (yytype)\n    {\n    case 6: /* _CLASS_  */\n#line 96 \"re_grammar.y\"\n            { yr_free(((*yyvaluep).re_class)); ((*yyvaluep).re_class) = NULL; }\n#line 1133 \"re_grammar.c\"\n        break;\n\n    case 26: /* alternative  */\n#line 97 \"re_grammar.y\"\n            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }\n#line 1139 \"re_grammar.c\"\n        break;\n\n    case 27: /* concatenation  */\n#line 98 \"re_grammar.y\"\n            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }\n#line 1145 \"re_grammar.c\"\n        break;\n\n    case 28: /* repeat  */\n#line 99 \"re_grammar.y\"\n            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }\n#line 1151 \"re_grammar.c\"\n        break;\n\n    case 29: /* single  */\n#line 100 \"re_grammar.y\"\n            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }\n#line 1157 \"re_grammar.c\"\n        break;\n\n      default:\n        break;\n    }\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}",
        "begin_line": 1116,
        "end_line": 1163,
        "is_bug": false
    },
    {
        "name": "libyara.re_grammar.yystpcpy#904",
        "src_path": "libyara/re_grammar.c",
        "class_name": "libyara.re_grammar",
        "signature": "libyara.re_grammar.yystpcpy (char *yydest, const char *yysrc)",
        "snippet": "static char *\nyystpcpy (char *yydest, const char *yysrc)\n{\n  char *yyd = yydest;\n  const char *yys = yysrc;\n\n  while ((*yyd++ = *yys++) != '\\0')\n    continue;\n\n  return yyd - 1;\n}",
        "begin_line": 904,
        "end_line": 914,
        "is_bug": false
    },
    {
        "name": "libyara.re_grammar.yysyntax_error#977",
        "src_path": "libyara/re_grammar.c",
        "class_name": "libyara.re_grammar",
        "signature": "libyara.re_grammar.yysyntax_error (YYPTRDIFF_T *yymsg_alloc, char **yymsg, yy_state_t *yyssp, int yytoken)",
        "snippet": "static int\nyysyntax_error (YYPTRDIFF_T *yymsg_alloc, char **yymsg,\n                yy_state_t *yyssp, int yytoken)\n{\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *yyformat = YY_NULLPTR;\n  /* Arguments of yyformat: reported tokens (one for the \"unexpected\",\n     one per \"expected\"). */\n  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Actual size of YYARG. */\n  int yycount = 0;\n  /* Cumulated lengths of YYARG.  */\n  YYPTRDIFF_T yysize = 0;\n\n  /* There are many possibilities here to consider:\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in yychar) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated yychar.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (yytoken != YYEMPTY)\n    {\n      int yyn = yypact[+*yyssp];\n      YYPTRDIFF_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);\n      yysize = yysize0;\n      yyarg[yycount++] = yytname[yytoken];\n      if (!yypact_value_is_default (yyn))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int yyxbegin = yyn < 0 ? -yyn : 0;\n          /* Stay within bounds of both yycheck and yytname.  */\n          int yychecklim = YYLAST - yyn + 1;\n          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n          int yyx;\n\n          for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR\n                && !yytable_value_is_error (yytable[yyx + yyn]))\n              {\n                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    yycount = 1;\n                    yysize = yysize0;\n                    break;\n                  }\n                yyarg[yycount++] = yytname[yyx];\n                {\n                  YYPTRDIFF_T yysize1\n                    = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);\n                  if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)\n                    yysize = yysize1;\n                  else\n                    return 2;\n                }\n              }\n        }\n    }\n\n  switch (yycount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        yyformat = S;                       \\\n      break\n    default: /* Avoid compiler warnings. */\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  {\n    /* Don't count the \"%s\"s in the final size, but reserve room for\n       the terminator.  */\n    YYPTRDIFF_T yysize1 = yysize + (yystrlen (yyformat) - 2 * yycount) + 1;\n    if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)\n      yysize = yysize1;\n    else\n      return 2;\n  }\n\n  if (*yymsg_alloc < yysize)\n    {\n      *yymsg_alloc = 2 * yysize;\n      if (! (yysize <= *yymsg_alloc\n             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *yyp = *yymsg;\n    int yyi = 0;\n    while ((*yyp = *yyformat) != '\\0')\n      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)\n        {\n          yyp += yytnamerr (yyp, yyarg[yyi++]);\n          yyformat += 2;\n        }\n      else\n        {\n          ++yyp;\n          ++yyformat;\n        }\n  }\n  return 0;\n}",
        "begin_line": 977,
        "end_line": 1109,
        "is_bug": false
    },
    {
        "name": "libyara.re_grammar.yytnamerr#926",
        "src_path": "libyara/re_grammar.c",
        "class_name": "libyara.re_grammar",
        "signature": "libyara.re_grammar.yytnamerr (char *yyres, const char *yystr)",
        "snippet": "static YYPTRDIFF_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYPTRDIFF_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n        switch (*++yyp)\n          {\n          case '\\'':\n          case ',':\n            goto do_not_strip_quotes;\n\n          case '\\\\':\n            if (*++yyp != '\\\\')\n              goto do_not_strip_quotes;\n            else\n              goto append;\n\n          append:\n          default:\n            if (yyres)\n              yyres[yyn] = *yyp;\n            yyn++;\n            break;\n\n          case '\"':\n            if (yyres)\n              yyres[yyn] = '\\0';\n            return yyn;\n          }\n    do_not_strip_quotes: ;\n    }\n\n  if (yyres)\n    return yystpcpy (yyres, yystr) - yyres;\n  else\n    return yystrlen (yystr);\n}",
        "begin_line": 926,
        "end_line": 966,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.input#1914",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.input  (yyscan_t yyscanner) #endif",
        "snippet": "static int input  (yyscan_t yyscanner)\n#endif\n\n{\n\tint c;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\t*yyg->yy_c_buf_p = yyg->yy_hold_char;\n\n\tif ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\t/* yy_c_buf_p now points to the character we want to return.\n\t\t * If this occurs *before* the EOB characters, then it's a\n\t\t * valid NUL; if not, then we've hit the end of the buffer.\n\t\t */\n\t\tif ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )\n\t\t\t/* This was really a NUL. */\n\t\t\t*yyg->yy_c_buf_p = '\\0';\n\n\t\telse\n\t\t\t{ /* need more input */\n\t\t\tint offset = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr);\n\t\t\t++yyg->yy_c_buf_p;\n\n\t\t\tswitch ( yy_get_next_buffer( yyscanner ) )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\t/* This happens because yy_g_n_b()\n\t\t\t\t\t * sees that we've accumulated a\n\t\t\t\t\t * token and flags that we need to\n\t\t\t\t\t * try matching the token before\n\t\t\t\t\t * proceeding.  But for input(),\n\t\t\t\t\t * there's no matching to consider.\n\t\t\t\t\t * So convert the EOB_ACT_LAST_MATCH\n\t\t\t\t\t * to EOB_ACT_END_OF_FILE.\n\t\t\t\t\t */\n\n\t\t\t\t\t/* Reset buffer status. */\n\t\t\t\t\tyyrestart( yyin , yyscanner);\n\n\t\t\t\t\t/*FALLTHROUGH*/\n\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( yywrap( yyscanner ) )\n\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput(yyscanner);\n#else\n\t\t\t\t\treturn input(yyscanner);\n#endif\n\t\t\t\t\t}\n\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tc = *(unsigned char *) yyg->yy_c_buf_p;\t/* cast for 8-bit char's */\n\t*yyg->yy_c_buf_p = '\\0';\t/* preserve yytext */\n\tyyg->yy_hold_char = *++yyg->yy_c_buf_p;\n\n\tif ( c == '\\n' )\n\t\t\n    do{ yylineno++;\n        yycolumn=0;\n    }while(0)\n;\n\n\treturn c;\n}",
        "begin_line": 1914,
        "end_line": 1989,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yy_delete_buffer#2090",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "void yy_delete_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tyyfree( (void *) b->yy_ch_buf , yyscanner );\n\n\tyyfree( (void *) b , yyscanner );\n}",
        "begin_line": 2090,
        "end_line": 2104,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yy_flush_buffer#2139",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "void yy_flush_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tyy_load_buffer_state( yyscanner );\n}",
        "begin_line": 2139,
        "end_line": 2161,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yy_init_buffer#2110",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file , yyscan_t yyscanner)\n\n{\n\tint oerrno = errno;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tyy_flush_buffer( b , yyscanner);\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n    /* If b is the current buffer, then yy_init_buffer was _probably_\n     * called from yyrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->yy_bs_lineno = 1;\n        b->yy_bs_column = 0;\n    }\n\n        b->yy_is_interactive = 0;\n    \n\terrno = oerrno;\n}",
        "begin_line": 2110,
        "end_line": 2133,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yy_load_buffer_state#2047",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "static void yy_load_buffer_state  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\tyyg->yytext_ptr = yyg->yy_c_buf_p = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;\n\tyyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;\n\tyyg->yy_hold_char = *yyg->yy_c_buf_p;\n}",
        "begin_line": 2047,
        "end_line": 2054,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yy_scan_buffer#2270",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn NULL;\n\n\tb = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n\n\tb->yy_buf_size = (int) (size - 2);\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = NULL;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tyy_switch_to_buffer( b , yyscanner );\n\n\treturn b;\n}",
        "begin_line": 2270,
        "end_line": 2297,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yy_scan_bytes#2320",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len , yyscan_t yyscanner)\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = (yy_size_t) (_yybytes_len + 2);\n\tbuf = (char *) yyalloc( n , yyscanner );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = yy_scan_buffer( buf, n , yyscanner);\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}",
        "begin_line": 2320,
        "end_line": 2348,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yy_scan_string#2307",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "YY_BUFFER_STATE yy_scan_string (const char * yystr , yyscan_t yyscanner)\n{\n    \n\treturn yy_scan_bytes( yystr, (int) strlen(yystr) , yyscanner);\n}",
        "begin_line": 2307,
        "end_line": 2311,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yy_switch_to_buffer#2015",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tyypop_buffer_state();\n\t *\t\tyypush_buffer_state(new_buffer);\n     */\n\tyyensure_buffer_stack (yyscanner);\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*yyg->yy_c_buf_p = yyg->yy_hold_char;\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tyy_load_buffer_state( yyscanner );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (yywrap()) processing, but the only time this flag\n\t * is looked at is after yywrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\tyyg->yy_did_buffer_switch_on_eof = 1;\n}",
        "begin_line": 2015,
        "end_line": 2045,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yyalloc#2687",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "void *yyalloc (yy_size_t  size , yyscan_t yyscanner)\n{\n\tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\t(void)yyg;\n\treturn malloc(size);\n}",
        "begin_line": 2687,
        "end_line": 2692,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yyensure_buffer_stack#2220",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "static void yyensure_buffer_stack (yyscan_t yyscanner)\n{\n\tyy_size_t num_to_alloc;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tif (!yyg->yy_buffer_stack) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\n\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t\tyyg->yy_buffer_stack_top = 0;\n\t\treturn;\n\t}\n\n\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)yyrealloc\n\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t}\n}",
        "begin_line": 2220,
        "end_line": 2262,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yyfree#2709",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "void yyfree (void * ptr , yyscan_t yyscanner)\n{\n\tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\t(void)yyg;\n\tfree( (char *) ptr );\t/* see yyrealloc() for (char *) cast */\n}",
        "begin_line": 2709,
        "end_line": 2714,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yyget_extra#2384",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "YY_EXTRA_TYPE yyget_extra  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    return yyextra;\n}",
        "begin_line": 2384,
        "end_line": 2388,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yylex#1023",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.L",
        "snippet": "YY_DECL\n{\n\tyy_state_type yy_current_state;\n\tchar *yy_cp, *yy_bp;\n\tint yy_act;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n    yylval = yylval_param;\n\n\tif ( !yyg->yy_init )\n\t\t{\n\t\tyyg->yy_init = 1;\n\n#ifdef YY_USER_INIT\n\t\tYY_USER_INIT;\n#endif\n\n\t\tif ( ! yyg->yy_start )\n\t\t\tyyg->yy_start = 1;\t/* first start state */\n\n\t\tif ( ! yyin )\n\t\t\tyyin = stdin;\n\n\t\tif ( ! yyout )\n\t\t\tyyout = stdout;\n\n\t\tif ( ! YY_CURRENT_BUFFER ) {\n\t\t\tyyensure_buffer_stack (yyscanner);\n\t\t\tYY_CURRENT_BUFFER_LVALUE =\n\t\t\t\tyy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);\n\t\t}\n\n\t\tyy_load_buffer_state( yyscanner );\n\t\t}\n\n\t{\n#line 100 \"re_lexer.l\"\n\n\n#line 1063 \"re_lexer.c\"\n\n\twhile ( /*CONSTCOND*/1 )\t\t/* loops until end-of-file is reached */\n\t\t{\n\t\tyy_cp = yyg->yy_c_buf_p;\n\n\t\t/* Support of yytext. */\n\t\t*yy_cp = yyg->yy_hold_char;\n\n\t\t/* yy_bp points to the position in yy_ch_buf of the start of\n\t\t * the current run.\n\t\t */\n\t\tyy_bp = yy_cp;\n\n\t\tyy_current_state = yyg->yy_start;\nyy_match:\n\t\tdo\n\t\t\t{\n\t\t\tYY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;\n\t\t\tif ( yy_accept[yy_current_state] )\n\t\t\t\t{\n\t\t\t\tyyg->yy_last_accepting_state = yy_current_state;\n\t\t\t\tyyg->yy_last_accepting_cpos = yy_cp;\n\t\t\t\t}\n\t\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t\t{\n\t\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\t\tif ( yy_current_state >= 45 )\n\t\t\t\t\tyy_c = yy_meta[yy_c];\n\t\t\t\t}\n\t\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];\n\t\t\t++yy_cp;\n\t\t\t}\n\t\twhile ( yy_current_state != 44 );\n\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\tyy_current_state = yyg->yy_last_accepting_state;\n\nyy_find_action:\n\t\tyy_act = yy_accept[yy_current_state];\n\n\t\tYY_DO_BEFORE_ACTION;\n\n\t\tif ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )\n\t\t\t{\n\t\t\tint yyl;\n\t\t\tfor ( yyl = 0; yyl < yyleng; ++yyl )\n\t\t\t\tif ( yytext[yyl] == '\\n' )\n\t\t\t\t\t\n    do{ yylineno++;\n        yycolumn=0;\n    }while(0)\n;\n\t\t\t}\n\ndo_action:\t/* This label is used only to access EOF actions. */\n\n\t\tswitch ( yy_act )\n\t{ /* beginning of action switch */\n\t\t\tcase 0: /* must back up */\n\t\t\t/* undo the effects of YY_DO_BEFORE_ACTION */\n\t\t\t*yy_cp = yyg->yy_hold_char;\n\t\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\t\tyy_current_state = yyg->yy_last_accepting_state;\n\t\t\tgoto yy_find_action;\n\ncase 1:\nYY_RULE_SETUP\n#line 102 \"re_lexer.l\"\n{\n\n  // Examples: {3,8} {0,5} {,5} {7,}\n\n  int hi_bound;\n  int lo_bound = atoi(yytext + 1);\n\n  char* comma = strchr(yytext, ',');\n\n  if (comma - yytext == strlen(yytext) - 2)\n    // if comma is followed by the closing curly bracket\n    // (example: {2,}) set high bound value to maximum.\n    hi_bound = INT16_MAX;\n  else\n    hi_bound = atoi(comma + 1);\n\n  if (hi_bound > INT16_MAX)\n  {\n    yyerror(yyscanner, lex_env, \"repeat interval too large\");\n    yyterminate();\n  }\n\n  if (hi_bound < lo_bound || hi_bound < 0 || lo_bound < 0)\n  {\n    yyerror(yyscanner, lex_env, \"bad repeat interval\");\n    yyterminate();\n  }\n\n  if (hi_bound == 0 && lo_bound == 0)\n  {\n    yyerror(yyscanner, lex_env, \"bad repeat interval\");\n    yyterminate();\n  }\n\n  yylval->range = (hi_bound << 16) | lo_bound;\n\n  return _RANGE_;\n}\n\tYY_BREAK\ncase 2:\nYY_RULE_SETUP\n#line 142 \"re_lexer.l\"\n{\n\n  // Example: {10}\n\n  int value = atoi(yytext + 1);\n\n  // atoi can return a negative value if the input string represents a number\n  // too large to fit in an integer.\n\n  if (value > INT16_MAX || value < 0)\n  {\n    yyerror(yyscanner, lex_env, \"repeat interval too large\");\n    yyterminate();\n  }\n\n  if (value == 0)\n  {\n    yyerror(yyscanner, lex_env, \"bad repeat interval\");\n    yyterminate();\n  }\n\n  yylval->range = (value << 16) | value;\n\n  return _RANGE_;\n}\n\tYY_BREAK\ncase 3:\nYY_RULE_SETUP\n#line 169 \"re_lexer.l\"\n{\n\n  // Start of a negated character class. Example: [^abcd]\n\n  BEGIN(char_class);\n  memset(LEX_ENV->re_class.bitmap, 0, 32);\n  LEX_ENV->re_class.negated = true;\n}\n\tYY_BREAK\ncase 4:\nYY_RULE_SETUP\n#line 178 \"re_lexer.l\"\n{\n\n  // Start of character negated class containing a ].\n  // Example: [^]abc] this must be interpreted as a class\n  // not matching ], a, b, nor c\n\n  BEGIN(char_class);\n  memset(LEX_ENV->re_class.bitmap, 0, 32);\n  LEX_ENV->re_class.negated = true;\n  LEX_ENV->re_class.bitmap[']' / 8] |= 1 << ']' % 8;\n}\n\tYY_BREAK\ncase 5:\nYY_RULE_SETUP\n#line 191 \"re_lexer.l\"\n{\n\n  // Start of character class containing a ].\n  // Example: []abc] this must be interpreted as a class\n  // matching ], a, b, or c.\n\n  BEGIN(char_class);\n  memset(LEX_ENV->re_class.bitmap, 0, 32);\n  LEX_ENV->re_class.negated = false;\n  LEX_ENV->re_class.bitmap[']' / 8] |= 1 << ']' % 8;\n}\n\tYY_BREAK\ncase 6:\nYY_RULE_SETUP\n#line 204 \"re_lexer.l\"\n{\n\n  // Start of character class. Example: [abcd]\n\n  BEGIN(char_class);\n  memset(LEX_ENV->re_class.bitmap, 0, 32);\n  LEX_ENV->re_class.negated = false;\n}\n\tYY_BREAK\ncase 7:\n/* rule 7 can match eol */\nYY_RULE_SETUP\n#line 214 \"re_lexer.l\"\n{\n\n  // Any non-special character is passed as a CHAR token to the scanner.\n\n  yylval->integer = yytext[0];\n  return _CHAR_;\n}\n\tYY_BREAK\ncase 8:\nYY_RULE_SETUP\n#line 223 \"re_lexer.l\"\n{\n  return _WORD_CHAR_;\n}\n\tYY_BREAK\ncase 9:\nYY_RULE_SETUP\n#line 228 \"re_lexer.l\"\n{\n  return _NON_WORD_CHAR_;\n}\n\tYY_BREAK\ncase 10:\nYY_RULE_SETUP\n#line 233 \"re_lexer.l\"\n{\n  return _SPACE_;\n}\n\tYY_BREAK\ncase 11:\nYY_RULE_SETUP\n#line 238 \"re_lexer.l\"\n{\n  return _NON_SPACE_;\n}\n\tYY_BREAK\ncase 12:\nYY_RULE_SETUP\n#line 243 \"re_lexer.l\"\n{\n  return _DIGIT_;\n}\n\tYY_BREAK\ncase 13:\nYY_RULE_SETUP\n#line 248 \"re_lexer.l\"\n{\n  return _NON_DIGIT_;\n}\n\tYY_BREAK\ncase 14:\nYY_RULE_SETUP\n#line 253 \"re_lexer.l\"\n{\n  return _WORD_BOUNDARY_;\n}\n\tYY_BREAK\ncase 15:\nYY_RULE_SETUP\n#line 257 \"re_lexer.l\"\n{\n  return _NON_WORD_BOUNDARY_;\n}\n\tYY_BREAK\ncase 16:\nYY_RULE_SETUP\n#line 262 \"re_lexer.l\"\n{\n\n  yyerror(yyscanner, lex_env, \"backreferences are not allowed\");\n  yyterminate();\n}\n\tYY_BREAK\ncase 17:\nYY_RULE_SETUP\n#line 269 \"re_lexer.l\"\n{\n\n  uint8_t c;\n\n  if (read_escaped_char(yyscanner, &c))\n  {\n    yylval->integer = c;\n    return _CHAR_;\n  }\n  else\n  {\n    yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n    yyterminate();\n  }\n}\n\tYY_BREAK\ncase 18:\nYY_RULE_SETUP\n#line 286 \"re_lexer.l\"\n{\n\n  // End of character class.\n  yylval->re_class = (RE_CLASS*) yr_malloc(sizeof(RE_CLASS));\n  memcpy(yylval->re_class->bitmap, LEX_ENV->re_class.bitmap, 32);\n\n  yylval->re_class->negated = LEX_ENV->re_class.negated;\n\n  BEGIN(INITIAL);\n  return _CLASS_;\n}\n\tYY_BREAK\ncase 19:\n/* rule 19 can match eol */\nYY_RULE_SETUP\n#line 300 \"re_lexer.l\"\n{\n\n  // A range inside a character class.\n  //  [abc0-9]\n  //      ^- matching here\n\n  uint16_t c;\n  uint8_t start = yytext[0];\n  uint8_t end = yytext[2];\n\n  if (start == '\\\\')\n  {\n    if (!escaped_char_value(yytext, &start))\n    {\n      yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n      yyterminate();\n    }\n\n    if (yytext[1] == 'x')\n      end = yytext[5];\n    else\n      end = yytext[3];\n  }\n\n  if (end == '\\\\')\n  {\n    if (!read_escaped_char(yyscanner, &end))\n    {\n      yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n      yyterminate();\n    }\n  }\n\n  if (end < start)\n  {\n    yyerror(yyscanner, lex_env, \"bad character range\");\n    yyterminate();\n  }\n\n  for (c = start; c <= end; c++)\n  {\n    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;\n  }\n}\n\tYY_BREAK\ncase 20:\nYY_RULE_SETUP\n#line 346 \"re_lexer.l\"\n{\n\n  int i;\n\n  for (i = 0; i < 32; i++)\n    LEX_ENV->re_class.bitmap[i] |= word_chars[i];\n}\n\tYY_BREAK\ncase 21:\nYY_RULE_SETUP\n#line 355 \"re_lexer.l\"\n{\n\n  int i;\n\n  for (i = 0; i < 32; i++)\n    LEX_ENV->re_class.bitmap[i] |= ~word_chars[i];\n}\n\tYY_BREAK\ncase 22:\nYY_RULE_SETUP\n#line 364 \"re_lexer.l\"\n{\n\n  LEX_ENV->re_class.bitmap[' ' / 8] |= 1 << ' ' % 8;\n  LEX_ENV->re_class.bitmap['\\t' / 8] |= 1 << '\\t' % 8;\n}\n\tYY_BREAK\ncase 23:\nYY_RULE_SETUP\n#line 371 \"re_lexer.l\"\n{\n\n  int i;\n\n  for (i = 0; i < 32; i++)\n  {\n    if (i == ' ' / 8)\n      LEX_ENV->re_class.bitmap[i] |= ~(1 << ' ' % 8);\n    else if (i == '\\t' / 8)\n      LEX_ENV->re_class.bitmap[i] |= ~(1 << '\\t' % 8);\n    else\n      LEX_ENV->re_class.bitmap[i] = 0xFF;\n  }\n}\n\tYY_BREAK\ncase 24:\nYY_RULE_SETUP\n#line 387 \"re_lexer.l\"\n{\n\n  char c;\n\n  for (c = '0'; c <= '9'; c++)\n    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;\n}\n\tYY_BREAK\ncase 25:\nYY_RULE_SETUP\n#line 396 \"re_lexer.l\"\n{\n\n  int i;\n\n  for (i = 0; i < 32; i++)\n  {\n    // digits 0-7 are in the sixth byte of the vector, let that byte alone\n    if (i == 6)\n      continue;\n\n    // digits 8 and 9 are the lowest two bits in the seventh byte of the\n    // vector, let those bits alone.\n    if (i == 7)\n      LEX_ENV->re_class.bitmap[i] |= 0xFC;\n    else\n      LEX_ENV->re_class.bitmap[i] = 0xFF;\n  }\n}\n\tYY_BREAK\ncase 26:\nYY_RULE_SETUP\n#line 416 \"re_lexer.l\"\n{\n\n  uint8_t c;\n\n  if (read_escaped_char(yyscanner, &c))\n  {\n    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;\n  }\n  else\n  {\n    yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n    yyterminate();\n  }\n}\n\tYY_BREAK\ncase 27:\nYY_RULE_SETUP\n#line 432 \"re_lexer.l\"\n{\n\n  if (yytext[0] >= 32 && yytext[0] < 127)\n  {\n    // A character class (i.e: [0-9a-f]) is represented by a 256-bits vector,\n    // here we set to 1 the vector's bit corresponding to the input character.\n\n    LEX_ENV->re_class.bitmap[yytext[0] / 8] |= 1 << yytext[0] % 8;\n  }\n  else\n  {\n    yyerror(yyscanner, lex_env, \"non-ascii character\");\n    yyterminate();\n  }\n}\n\tYY_BREAK\ncase YY_STATE_EOF(char_class):\n#line 449 \"re_lexer.l\"\n{\n\n  // End of regexp reached while scanning a character class.\n\n  yyerror(yyscanner, lex_env, \"missing terminating ] for character class\");\n  yyterminate();\n}\n\tYY_BREAK\ncase 28:\nYY_RULE_SETUP\n#line 458 \"re_lexer.l\"\n{\n\n  if (yytext[0] >= 32 && yytext[0] < 127)\n  {\n    return yytext[0];\n  }\n  else\n  {\n    yyerror(yyscanner, lex_env, \"non-ascii character\");\n    yyterminate();\n  }\n}\n\tYY_BREAK\ncase YY_STATE_EOF(INITIAL):\n#line 472 \"re_lexer.l\"\n{\n\n  yyterminate();\n}\n\tYY_BREAK\ncase 29:\nYY_RULE_SETUP\n#line 477 \"re_lexer.l\"\nECHO;\n\tYY_BREAK\n#line 1570 \"re_lexer.c\"\n\n\tcase YY_END_OF_BUFFER:\n\t\t{\n\t\t/* Amount of text matched not including the EOB char. */\n\t\tint yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;\n\n\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */\n\t\t*yy_cp = yyg->yy_hold_char;\n\t\tYY_RESTORE_YY_MORE_OFFSET\n\n\t\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )\n\t\t\t{\n\t\t\t/* We're scanning a new file or input source.  It's\n\t\t\t * possible that this happened because the user\n\t\t\t * just pointed yyin at a new source and called\n\t\t\t * yylex().  If so, then we have to assure\n\t\t\t * consistency between YY_CURRENT_BUFFER and our\n\t\t\t * globals.  Here is the right place to do so, because\n\t\t\t * this is the first action (other than possibly a\n\t\t\t * back-up) that will match for the new input source.\n\t\t\t */\n\t\t\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;\n\t\t\t}\n\n\t\t/* Note that here we test for yy_c_buf_p \"<=\" to the position\n\t\t * of the first EOB in the buffer, since yy_c_buf_p will\n\t\t * already have been incremented past the NUL character\n\t\t * (since all states make transitions on EOB to the\n\t\t * end-of-buffer state).  Contrast this with the test\n\t\t * in input().\n\t\t */\n\t\tif ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )\n\t\t\t{ /* This was really a NUL. */\n\t\t\tyy_state_type yy_next_state;\n\n\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;\n\n\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t/* Okay, we're now positioned to make the NUL\n\t\t\t * transition.  We couldn't have\n\t\t\t * yy_get_previous_state() go ahead and do it\n\t\t\t * for us because it doesn't know how to deal\n\t\t\t * with the possibility of jamming (and we don't\n\t\t\t * want to build jamming into it because then it\n\t\t\t * will run more slowly).\n\t\t\t */\n\n\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);\n\n\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\n\t\t\tif ( yy_next_state )\n\t\t\t\t{\n\t\t\t\t/* Consume the NUL. */\n\t\t\t\tyy_cp = ++yyg->yy_c_buf_p;\n\t\t\t\tyy_current_state = yy_next_state;\n\t\t\t\tgoto yy_match;\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tyy_cp = yyg->yy_last_accepting_cpos;\n\t\t\t\tyy_current_state = yyg->yy_last_accepting_state;\n\t\t\t\tgoto yy_find_action;\n\t\t\t\t}\n\t\t\t}\n\n\t\telse switch ( yy_get_next_buffer( yyscanner ) )\n\t\t\t{\n\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t{\n\t\t\t\tyyg->yy_did_buffer_switch_on_eof = 0;\n\n\t\t\t\tif ( yywrap( yyscanner ) )\n\t\t\t\t\t{\n\t\t\t\t\t/* Note: because we've taken care in\n\t\t\t\t\t * yy_get_next_buffer() to have set up\n\t\t\t\t\t * yytext, we can now set up\n\t\t\t\t\t * yy_c_buf_p so that if some total\n\t\t\t\t\t * hoser (like flex itself) wants to\n\t\t\t\t\t * call the scanner after we return the\n\t\t\t\t\t * YY_NULL, it'll still work - another\n\t\t\t\t\t * YY_NULL will get returned.\n\t\t\t\t\t */\n\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;\n\n\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);\n\t\t\t\t\tgoto do_action;\n\t\t\t\t\t}\n\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\tyyg->yy_c_buf_p =\n\t\t\t\t\tyyg->yytext_ptr + yy_amount_of_matched_text;\n\n\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t\tyy_cp = yyg->yy_c_buf_p;\n\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_match;\n\n\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\tyyg->yy_c_buf_p =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];\n\n\t\t\t\tyy_current_state = yy_get_previous_state( yyscanner );\n\n\t\t\t\tyy_cp = yyg->yy_c_buf_p;\n\t\t\t\tyy_bp = yyg->yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_find_action;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\tYY_FATAL_ERROR(\n\t\t\t\"fatal flex scanner internal error--no action found\" );\n\t} /* end of action switch */\n\t\t} /* end of scanning one token */\n\t} /* end of user's declarations */\n}",
        "begin_line": 1023,
        "end_line": 1700,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yylex_destroy#2631",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "int yylex_destroy  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tyy_delete_buffer( YY_CURRENT_BUFFER , yyscanner );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tyypop_buffer_state(yyscanner);\n\t}\n\n\t/* Destroy the stack itself. */\n\tyyfree(yyg->yy_buffer_stack , yyscanner);\n\tyyg->yy_buffer_stack = NULL;\n\n    /* Destroy the start condition stack. */\n        yyfree( yyg->yy_start_stack , yyscanner );\n        yyg->yy_start_stack = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * yylex() is called, initialization will occur. */\n    yy_init_globals( yyscanner);\n\n    /* Destroy the main struct (reentrant only). */\n    yyfree ( yyscanner , yyscanner );\n    yyscanner = NULL;\n    return 0;\n}",
        "begin_line": 2631,
        "end_line": 2658,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yylex_init#2543",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "int yylex_init(yyscan_t* ptr_yy_globals)\n{\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n\n    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), NULL );\n\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n\n    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n\n    return yy_init_globals ( *ptr_yy_globals );\n}",
        "begin_line": 2543,
        "end_line": 2561,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yypop_buffer_state#2200",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "void yypop_buffer_state (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tyy_delete_buffer(YY_CURRENT_BUFFER , yyscanner);\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif (yyg->yy_buffer_stack_top > 0)\n\t\t--yyg->yy_buffer_stack_top;\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tyy_load_buffer_state( yyscanner );\n\t\tyyg->yy_did_buffer_switch_on_eof = 1;\n\t}\n}",
        "begin_line": 2200,
        "end_line": 2215,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yyrestart#1997",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "void yyrestart  (FILE * input_file , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tif ( ! YY_CURRENT_BUFFER ){\n        yyensure_buffer_stack (yyscanner);\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);\n\t}\n\n\tyy_init_buffer( YY_CURRENT_BUFFER, input_file , yyscanner);\n\tyy_load_buffer_state( yyscanner );\n}",
        "begin_line": 1997,
        "end_line": 2009,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.re_yyset_extra#2457",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.)",
        "snippet": "void yyset_extra (YY_EXTRA_TYPE  user_defined , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    yyextra = user_defined ;\n}",
        "begin_line": 2457,
        "end_line": 2461,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.yy_get_next_buffer#1709",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.yy_get_next_buffer (yyscan_t yyscanner)",
        "snippet": "static int yy_get_next_buffer (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tchar *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tchar *source = yyg->yytext_ptr;\n\tint number_to_move, i;\n\tint ret_val;\n\n\tif ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr - 1);\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) (yyg->yy_c_buf_p - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tyyrealloc( (void *) b->yy_ch_buf,\n\t\t\t\t\t\t\t (yy_size_t) (b->yy_buf_size + 2) , yyscanner );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = NULL;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\tyyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\tyyg->yy_n_chars, num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;\n\t\t}\n\n\tif ( yyg->yy_n_chars == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tyyrestart( yyin  , yyscanner);\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tint new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(\n\t\t\t(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size , yyscanner );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n\t\t/* \"- 2\" to take care of EOB's */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);\n\t}\n\n\tyyg->yy_n_chars += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;\n\n\tyyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}",
        "begin_line": 1709,
        "end_line": 1844,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.yy_get_previous_state#1848",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.yy_get_previous_state (yyscan_t yyscanner)",
        "snippet": "static yy_state_type yy_get_previous_state (yyscan_t yyscanner)\n{\n\tyy_state_type yy_current_state;\n\tchar *yy_cp;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tyy_current_state = yyg->yy_start;\n\n\tfor ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )\n\t\t{\n\t\tYY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\tyyg->yy_last_accepting_state = yy_current_state;\n\t\t\tyyg->yy_last_accepting_cpos = yy_cp;\n\t\t\t}\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 45 )\n\t\t\t\tyy_c = yy_meta[yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];\n\t\t}\n\n\treturn yy_current_state;\n}",
        "begin_line": 1848,
        "end_line": 1874,
        "is_bug": false
    },
    {
        "name": "libyara.re_lexer.yy_init_globals#2597",
        "src_path": "libyara/re_lexer.c",
        "class_name": "libyara.re_lexer",
        "signature": "libyara.re_lexer.yy_init_globals (yyscan_t yyscanner)",
        "snippet": "static int yy_init_globals (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from yylex_destroy(), so don't allocate here.\n     */\n\n    yyg->yy_buffer_stack = NULL;\n    yyg->yy_buffer_stack_top = 0;\n    yyg->yy_buffer_stack_max = 0;\n    yyg->yy_c_buf_p = NULL;\n    yyg->yy_init = 0;\n    yyg->yy_start = 0;\n\n    yyg->yy_start_stack_ptr = 0;\n    yyg->yy_start_stack_depth = 0;\n    yyg->yy_start_stack =  NULL;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    yyin = stdin;\n    yyout = stdout;\n#else\n    yyin = NULL;\n    yyout = NULL;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * yylex_init()\n     */\n    return 0;\n}",
        "begin_line": 2597,
        "end_line": 2628,
        "is_bug": false
    },
    {
        "name": "libyara.rules._yr_fetch_block_data#239",
        "src_path": "libyara/rules.c",
        "class_name": "libyara.rules",
        "signature": "libyara.rules._yr_fetch_block_data(     YR_MEMORY_BLOCK* block)",
        "snippet": "static const uint8_t* _yr_fetch_block_data(\n    YR_MEMORY_BLOCK* block)\n{\n  return (const uint8_t*) block->context;\n}",
        "begin_line": 239,
        "end_line": 243,
        "is_bug": false
    },
    {
        "name": "libyara.rules._yr_get_first_block#225",
        "src_path": "libyara/rules.c",
        "class_name": "libyara.rules",
        "signature": "libyara.rules._yr_get_first_block(     YR_MEMORY_BLOCK_ITERATOR* iterator)",
        "snippet": "static YR_MEMORY_BLOCK* _yr_get_first_block(\n    YR_MEMORY_BLOCK_ITERATOR* iterator)\n{\n  return (YR_MEMORY_BLOCK*) iterator->context;\n}",
        "begin_line": 225,
        "end_line": 229,
        "is_bug": false
    },
    {
        "name": "libyara.rules._yr_get_next_block#232",
        "src_path": "libyara/rules.c",
        "class_name": "libyara.rules",
        "signature": "libyara.rules._yr_get_next_block(     YR_MEMORY_BLOCK_ITERATOR* iterator)",
        "snippet": "static YR_MEMORY_BLOCK* _yr_get_next_block(\n    YR_MEMORY_BLOCK_ITERATOR* iterator)\n{\n  return NULL;\n}",
        "begin_line": 232,
        "end_line": 236,
        "is_bug": false
    },
    {
        "name": "libyara.rules.yr_rules_destroy#549",
        "src_path": "libyara/rules.c",
        "class_name": "libyara.rules",
        "signature": "libyara.rules.yr_rules_destroy(     YR_RULES* rules)",
        "snippet": "YR_API int yr_rules_destroy(\n    YR_RULES* rules)\n{\n  YR_EXTERNAL_VARIABLE* external = rules->externals_list_head;\n\n  while (!EXTERNAL_VARIABLE_IS_NULL(external))\n  {\n    if (external->type == EXTERNAL_VARIABLE_TYPE_MALLOC_STRING)\n      yr_free(external->value.s);\n\n    external++;\n  }\n\n  yr_mutex_destroy(&rules->mutex);\n  yr_arena_destroy(rules->arena);\n  yr_free(rules);\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 549,
        "end_line": 567,
        "is_bug": false
    },
    {
        "name": "libyara.rules.yr_rules_scan_mem#246",
        "src_path": "libyara/rules.c",
        "class_name": "libyara.rules",
        "signature": "libyara.rules.yr_rules_scan_mem(     YR_RULES* rules, const uint8_t* buffer, size_t buffer_size, int flags, YR_CALLBACK_FUNC callback, void* user_data, int timeout)",
        "snippet": "YR_API int yr_rules_scan_mem(\n    YR_RULES* rules,\n    const uint8_t* buffer,\n    size_t buffer_size,\n    int flags,\n    YR_CALLBACK_FUNC callback,\n    void* user_data,\n    int timeout)\n{\n  YR_MEMORY_BLOCK block;\n  YR_MEMORY_BLOCK_ITERATOR iterator;\n\n  block.size = buffer_size;\n  block.base = 0;\n  block.fetch_data = _yr_fetch_block_data;\n  block.context = (void*) buffer;\n\n  iterator.context = &block;\n  iterator.first = _yr_get_first_block;\n  iterator.next = _yr_get_next_block;\n\n  return yr_rules_scan_mem_blocks(\n      rules,\n      &iterator,\n      flags,\n      callback,\n      user_data,\n      timeout);\n}",
        "begin_line": 246,
        "end_line": 274,
        "is_bug": false
    },
    {
        "name": "libyara.rules.yr_rules_scan_mem_blocks#200",
        "src_path": "libyara/rules.c",
        "class_name": "libyara.rules",
        "signature": "libyara.rules.yr_rules_scan_mem_blocks(     YR_RULES* rules, YR_MEMORY_BLOCK_ITERATOR* iterator, int flags, YR_CALLBACK_FUNC callback, void* user_data, int timeout)",
        "snippet": "YR_API int yr_rules_scan_mem_blocks(\n    YR_RULES* rules,\n    YR_MEMORY_BLOCK_ITERATOR* iterator,\n    int flags,\n    YR_CALLBACK_FUNC callback,\n    void* user_data,\n    int timeout)\n{\n  YR_SCANNER* scanner;\n  int result;\n\n  FAIL_ON_ERROR(yr_scanner_create(rules, &scanner));\n\n  yr_scanner_set_callback(scanner, callback, user_data);\n  yr_scanner_set_timeout(scanner, timeout);\n  yr_scanner_set_flags(scanner, flags);\n\n  result = yr_scanner_scan_mem_blocks(scanner, iterator);\n\n  yr_scanner_destroy(scanner);\n\n  return result;\n}",
        "begin_line": 200,
        "end_line": 222,
        "is_bug": false
    },
    {
        "name": "libyara.scan._yr_scan_add_match_to_list#244",
        "src_path": "libyara/scan.c",
        "class_name": "libyara.scan",
        "signature": "libyara.scan._yr_scan_add_match_to_list(     YR_MATCH* match, YR_MATCHES* matches_list, int replace_if_exists)",
        "snippet": "static int _yr_scan_add_match_to_list(\n    YR_MATCH* match,\n    YR_MATCHES* matches_list,\n    int replace_if_exists)\n{\n  YR_MATCH* insertion_point = matches_list->tail;\n\n  if (matches_list->count == YR_MAX_STRING_MATCHES)\n    return ERROR_TOO_MANY_MATCHES;\n\n  while (insertion_point != NULL)\n  {\n    if (match->offset == insertion_point->offset)\n    {\n      if (replace_if_exists)\n      {\n        insertion_point->match_length = match->match_length;\n        insertion_point->data_length = match->data_length;\n        insertion_point->data = match->data;\n      }\n\n      return ERROR_SUCCESS;\n    }\n\n    if (match->offset > insertion_point->offset)\n      break;\n\n    insertion_point = insertion_point->prev;\n  }\n\n  match->prev = insertion_point;\n\n  if (insertion_point != NULL)\n  {\n    match->next = insertion_point->next;\n    insertion_point->next = match;\n  }\n  else\n  {\n    match->next = matches_list->head;\n    matches_list->head = match;\n  }\n\n  matches_list->count++;\n\n  if (match->next != NULL)\n    match->next->prev = match;\n  else\n    matches_list->tail = match;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 244,
        "end_line": 295,
        "is_bug": false
    },
    {
        "name": "libyara.scan._yr_scan_compare#118",
        "src_path": "libyara/scan.c",
        "class_name": "libyara.scan",
        "signature": "libyara.scan._yr_scan_compare(     const uint8_t* data, size_t data_size, uint8_t* string, size_t string_length)",
        "snippet": "static int _yr_scan_compare(\n    const uint8_t* data,\n    size_t data_size,\n    uint8_t* string,\n    size_t string_length)\n{\n  const uint8_t* s1 = data;\n  const uint8_t* s2 = string;\n\n  size_t i = 0;\n\n  if (data_size < string_length)\n    return 0;\n\n  while (i < string_length && *s1++ == *s2++)\n    i++;\n\n  return (int) ((i == string_length) ? i : 0);\n}",
        "begin_line": 118,
        "end_line": 136,
        "is_bug": false
    },
    {
        "name": "libyara.scan._yr_scan_match_callback#499",
        "src_path": "libyara/scan.c",
        "class_name": "libyara.scan",
        "signature": "libyara.scan._yr_scan_match_callback(     const uint8_t* match_data, int32_t match_length, int flags, void* args)",
        "snippet": "static int _yr_scan_match_callback(\n    const uint8_t* match_data,\n    int32_t match_length,\n    int flags,\n    void* args)\n{\n  CALLBACK_ARGS* callback_args = (CALLBACK_ARGS*) args;\n\n  YR_STRING* string = callback_args->string;\n  YR_MATCH* new_match;\n\n  int result = ERROR_SUCCESS;\n  int tidx = callback_args->context->tidx;\n\n  size_t match_offset = match_data - callback_args->data;\n\n  // total match length is the sum of backward and forward matches.\n  match_length += callback_args->forward_matches;\n\n  // make sure that match fits into the data.\n  assert(match_offset + match_length <= callback_args->data_size);\n\n  if (callback_args->full_word)\n  {\n    if (flags & RE_FLAGS_WIDE)\n    {\n      if (match_offset >= 2 &&\n          *(match_data - 1) == 0 &&\n          isalnum(*(match_data - 2)))\n        return ERROR_SUCCESS;\n\n      if (match_offset + match_length + 1 < callback_args->data_size &&\n          *(match_data + match_length + 1) == 0 &&\n          isalnum(*(match_data + match_length)))\n        return ERROR_SUCCESS;\n    }\n    else\n    {\n      if (match_offset >= 1 &&\n          isalnum(*(match_data - 1)))\n        return ERROR_SUCCESS;\n\n      if (match_offset + match_length < callback_args->data_size &&\n          isalnum(*(match_data + match_length)))\n        return ERROR_SUCCESS;\n    }\n  }\n\n  if (STRING_IS_CHAIN_PART(string))\n  {\n    result = _yr_scan_verify_chained_string_match(\n        string,\n        callback_args->context,\n        match_data,\n        callback_args->data_base,\n        match_offset,\n        match_length);\n  }\n  else\n  {\n    uint32_t max_match_data;\n\n    FAIL_ON_ERROR(yr_get_configuration(\n        YR_CONFIG_MAX_MATCH_DATA,\n        &max_match_data))\n\n    if (string->matches[tidx].count == 0)\n    {\n      // If this is the first match for the string, put the string in the\n      // list of strings whose flags needs to be cleared after the scan.\n\n      FAIL_ON_ERROR(yr_arena_write_data(\n          callback_args->context->matching_strings_arena,\n          &string,\n          sizeof(string),\n          NULL));\n    }\n\n    FAIL_ON_ERROR(yr_arena_allocate_memory(\n        callback_args->context->matches_arena,\n        sizeof(YR_MATCH),\n        (void**) &new_match));\n\n    new_match->data_length = yr_min(match_length, max_match_data);\n\n    if (new_match->data_length > 0)\n    {\n      FAIL_ON_ERROR(yr_arena_write_data(\n          callback_args->context->matches_arena,\n          match_data,\n          new_match->data_length,\n          (void**) &new_match->data));\n    }\n    else\n    {\n      new_match->data = NULL;\n    }\n\n    if (result == ERROR_SUCCESS)\n    {\n      new_match->base = callback_args->data_base;\n      new_match->offset = match_offset;\n      new_match->match_length = match_length;\n      new_match->prev = NULL;\n      new_match->next = NULL;\n\n      FAIL_ON_ERROR(_yr_scan_add_match_to_list(\n          new_match,\n          &string->matches[tidx],\n          STRING_IS_GREEDY_REGEXP(string)));\n    }\n  }\n\n  return result;\n}",
        "begin_line": 499,
        "end_line": 613,
        "is_bug": false
    },
    {
        "name": "libyara.scan._yr_scan_remove_match_from_list#298",
        "src_path": "libyara/scan.c",
        "class_name": "libyara.scan",
        "signature": "libyara.scan._yr_scan_remove_match_from_list(     YR_MATCH* match, YR_MATCHES* matches_list)",
        "snippet": "static void _yr_scan_remove_match_from_list(\n    YR_MATCH* match,\n    YR_MATCHES* matches_list)\n{\n  if (match->prev != NULL)\n    match->prev->next = match->next;\n\n  if (match->next != NULL)\n    match->next->prev = match->prev;\n\n  if (matches_list->head == match)\n    matches_list->head = match->next;\n\n  if (matches_list->tail == match)\n    matches_list->tail = match->prev;\n\n  matches_list->count--;\n  match->next = NULL;\n  match->prev = NULL;\n}",
        "begin_line": 298,
        "end_line": 317,
        "is_bug": false
    },
    {
        "name": "libyara.scan._yr_scan_update_match_chain_length#210",
        "src_path": "libyara/scan.c",
        "class_name": "libyara.scan",
        "signature": "libyara.scan._yr_scan_update_match_chain_length(     int tidx, YR_STRING* string, YR_MATCH* match_to_update, int chain_length)",
        "snippet": "static void _yr_scan_update_match_chain_length(\n    int tidx,\n    YR_STRING* string,\n    YR_MATCH* match_to_update,\n    int chain_length)\n{\n  YR_MATCH* match;\n\n  if (match_to_update->chain_length == chain_length)\n    return;\n\n  match_to_update->chain_length = chain_length;\n\n  if (string->chained_to == NULL)\n    return;\n\n  match = string->chained_to->unconfirmed_matches[tidx].head;\n\n  while (match != NULL)\n  {\n    int64_t ending_offset = match->offset + match->match_length;\n\n    if (ending_offset + string->chain_gap_max >= match_to_update->offset &&\n        ending_offset + string->chain_gap_min <= match_to_update->offset)\n    {\n      _yr_scan_update_match_chain_length(\n          tidx, string->chained_to, match, chain_length + 1);\n    }\n\n    match = match->next;\n  }\n}",
        "begin_line": 210,
        "end_line": 241,
        "is_bug": false
    },
    {
        "name": "libyara.scan._yr_scan_verify_chained_string_match#320",
        "src_path": "libyara/scan.c",
        "class_name": "libyara.scan",
        "signature": "libyara.scan._yr_scan_verify_chained_string_match(     YR_STRING* matching_string, YR_SCAN_CONTEXT* context, const uint8_t* match_data, uint64_t match_base, uint64_t match_offset, int32_t match_length)",
        "snippet": "static int _yr_scan_verify_chained_string_match(\n    YR_STRING* matching_string,\n    YR_SCAN_CONTEXT* context,\n    const uint8_t* match_data,\n    uint64_t match_base,\n    uint64_t match_offset,\n    int32_t match_length)\n{\n  YR_STRING* string;\n  YR_MATCH* match;\n  YR_MATCH* next_match;\n  YR_MATCH* new_match;\n\n  uint64_t lower_offset;\n  uint64_t ending_offset;\n  int32_t full_chain_length;\n\n  int tidx = context->tidx;\n  bool add_match = false;\n\n  if (matching_string->chained_to == NULL)\n  {\n    add_match = true;\n  }\n  else\n  {\n    if (matching_string->unconfirmed_matches[tidx].head != NULL)\n      lower_offset = matching_string->unconfirmed_matches[tidx].head->offset;\n    else\n      lower_offset = match_offset;\n\n    match = matching_string->chained_to->unconfirmed_matches[tidx].head;\n\n    while (match != NULL)\n    {\n      next_match = match->next;\n      ending_offset = match->offset + match->match_length;\n\n      if (ending_offset + matching_string->chain_gap_max < lower_offset)\n      {\n        _yr_scan_remove_match_from_list(\n            match, &matching_string->chained_to->unconfirmed_matches[tidx]);\n      }\n      else\n      {\n        if (ending_offset + matching_string->chain_gap_max >= match_offset &&\n            ending_offset + matching_string->chain_gap_min <= match_offset)\n        {\n          add_match = true;\n          break;\n        }\n      }\n\n      match = next_match;\n    }\n  }\n\n  if (add_match)\n  {\n    uint32_t max_match_data;\n\n    FAIL_ON_ERROR(yr_get_configuration(\n        YR_CONFIG_MAX_MATCH_DATA,\n        &max_match_data))\n\n    if (STRING_IS_CHAIN_TAIL(matching_string))\n    {\n      // Chain tails must be chained to some other string\n      assert(matching_string->chained_to != NULL);\n\n      match = matching_string->chained_to->unconfirmed_matches[tidx].head;\n\n      while (match != NULL)\n      {\n        ending_offset = match->offset + match->match_length;\n\n        if (ending_offset + matching_string->chain_gap_max >= match_offset &&\n            ending_offset + matching_string->chain_gap_min <= match_offset)\n        {\n          _yr_scan_update_match_chain_length(\n              tidx, matching_string->chained_to, match, 1);\n        }\n\n        match = match->next;\n      }\n\n      full_chain_length = 0;\n      string = matching_string;\n\n      while(string->chained_to != NULL)\n      {\n        full_chain_length++;\n        string = string->chained_to;\n      }\n\n      // \"string\" points now to the head of the strings chain\n\n      match = string->unconfirmed_matches[tidx].head;\n\n      while (match != NULL)\n      {\n        next_match = match->next;\n\n        if (match->chain_length == full_chain_length)\n        {\n          _yr_scan_remove_match_from_list(\n              match, &string->unconfirmed_matches[tidx]);\n\n          match->match_length = (int32_t) \\\n              (match_offset - match->offset + match_length);\n\n          match->data_length = yr_min(match->match_length, max_match_data);\n\n          FAIL_ON_ERROR(yr_arena_write_data(\n              context->matches_arena,\n              match_data - match_offset + match->offset,\n              match->data_length,\n              (void**) &match->data));\n\n          FAIL_ON_ERROR(_yr_scan_add_match_to_list(\n              match, &string->matches[tidx], false));\n        }\n\n        match = next_match;\n      }\n    }\n    else\n    {\n      if (matching_string->matches[tidx].count == 0 &&\n          matching_string->unconfirmed_matches[tidx].count == 0)\n      {\n        // If this is the first match for the string, put the string in the\n        // list of strings whose flags needs to be cleared after the scan.\n\n        FAIL_ON_ERROR(yr_arena_write_data(\n            context->matching_strings_arena,\n            &matching_string,\n            sizeof(matching_string),\n            NULL));\n      }\n\n      FAIL_ON_ERROR(yr_arena_allocate_memory(\n          context->matches_arena,\n          sizeof(YR_MATCH),\n          (void**) &new_match));\n\n      new_match->data_length = yr_min(match_length, max_match_data);\n\n      if (new_match->data_length > 0)\n      {\n        FAIL_ON_ERROR(yr_arena_write_data(\n            context->matches_arena,\n            match_data,\n            new_match->data_length,\n            (void**) &new_match->data));\n      }\n      else\n      {\n        new_match->data = NULL;\n      }\n\n      new_match->base = match_base;\n      new_match->offset = match_offset;\n      new_match->match_length = match_length;\n      new_match->chain_length = 0;\n      new_match->prev = NULL;\n      new_match->next = NULL;\n\n      FAIL_ON_ERROR(_yr_scan_add_match_to_list(\n          new_match,\n          &matching_string->unconfirmed_matches[tidx],\n          false));\n    }\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 320,
        "end_line": 496,
        "is_bug": false
    },
    {
        "name": "libyara.scan._yr_scan_verify_literal_match#723",
        "src_path": "libyara/scan.c",
        "class_name": "libyara.scan",
        "signature": "libyara.scan._yr_scan_verify_literal_match(     YR_SCAN_CONTEXT* context, YR_AC_MATCH* ac_match, const uint8_t* data, size_t data_size, uint64_t data_base, size_t offset)",
        "snippet": "static int _yr_scan_verify_literal_match(\n    YR_SCAN_CONTEXT* context,\n    YR_AC_MATCH* ac_match,\n    const uint8_t* data,\n    size_t data_size,\n    uint64_t data_base,\n    size_t offset)\n{\n  int flags = 0;\n  int forward_matches = 0;\n\n  CALLBACK_ARGS callback_args;\n  YR_STRING* string = ac_match->string;\n\n  if (STRING_FITS_IN_ATOM(string))\n  {\n    forward_matches = ac_match->backtrack;\n  }\n  else if (STRING_IS_NO_CASE(string))\n  {\n    if (STRING_IS_ASCII(string))\n    {\n      forward_matches = _yr_scan_icompare(\n          data + offset,\n          data_size - offset,\n          string->string,\n          string->length);\n    }\n\n    if (STRING_IS_WIDE(string) && forward_matches == 0)\n    {\n      forward_matches = _yr_scan_wicompare(\n          data + offset,\n          data_size - offset,\n          string->string,\n          string->length);\n    }\n  }\n  else\n  {\n    if (STRING_IS_ASCII(string))\n    {\n      forward_matches = _yr_scan_compare(\n          data + offset,\n          data_size - offset,\n          string->string,\n          string->length);\n    }\n\n    if (STRING_IS_WIDE(string) && forward_matches == 0)\n    {\n      forward_matches = _yr_scan_wcompare(\n          data + offset,\n          data_size - offset,\n          string->string,\n          string->length);\n    }\n\n    if (STRING_IS_XOR(string) && forward_matches == 0)\n    {\n      if (STRING_IS_WIDE(string))\n      {\n        forward_matches = _yr_scan_xor_wcompare(\n          data + offset,\n          data_size - offset,\n          string->string,\n          string->length);\n      }\n\n      if (forward_matches == 0)\n      {\n        forward_matches = _yr_scan_xor_compare(\n          data + offset,\n          data_size - offset,\n          string->string,\n          string->length);\n      }\n    }\n\n  }\n\n  if (forward_matches == 0)\n    return ERROR_SUCCESS;\n\n  if (forward_matches == string->length * 2)\n    flags |= RE_FLAGS_WIDE;\n\n  if (STRING_IS_NO_CASE(string))\n    flags |= RE_FLAGS_NO_CASE;\n\n  callback_args.context = context;\n  callback_args.string = string;\n  callback_args.data = data;\n  callback_args.data_size = data_size;\n  callback_args.data_base = data_base;\n  callback_args.forward_matches = forward_matches;\n  callback_args.full_word = STRING_IS_FULL_WORD(string);\n\n  FAIL_ON_ERROR(_yr_scan_match_callback(\n      data + offset, 0, flags, &callback_args));\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 723,
        "end_line": 825,
        "is_bug": false
    },
    {
        "name": "libyara.scan._yr_scan_verify_re_match#628",
        "src_path": "libyara/scan.c",
        "class_name": "libyara.scan",
        "signature": "libyara.scan._yr_scan_verify_re_match(     YR_SCAN_CONTEXT* context, YR_AC_MATCH* ac_match, const uint8_t* data, size_t data_size, uint64_t data_base, size_t offset)",
        "snippet": "static int _yr_scan_verify_re_match(\n    YR_SCAN_CONTEXT* context,\n    YR_AC_MATCH* ac_match,\n    const uint8_t* data,\n    size_t data_size,\n    uint64_t data_base,\n    size_t offset)\n{\n  CALLBACK_ARGS callback_args;\n  RE_EXEC_FUNC exec;\n\n  int forward_matches = -1;\n  int backward_matches = -1;\n  int flags = 0;\n\n  if (STRING_IS_GREEDY_REGEXP(ac_match->string))\n    flags |= RE_FLAGS_GREEDY;\n\n  if (STRING_IS_NO_CASE(ac_match->string))\n    flags |= RE_FLAGS_NO_CASE;\n\n  if (STRING_IS_DOT_ALL(ac_match->string))\n    flags |= RE_FLAGS_DOT_ALL;\n\n  if (STRING_IS_FAST_REGEXP(ac_match->string))\n    exec = yr_re_fast_exec;\n  else\n    exec = yr_re_exec;\n\n  if (STRING_IS_ASCII(ac_match->string))\n  {\n    FAIL_ON_ERROR(exec(\n        context,\n        ac_match->forward_code,\n        data + offset,\n        data_size - offset,\n        offset,\n        flags,\n        NULL,\n        NULL,\n        &forward_matches));\n  }\n\n  if (STRING_IS_WIDE(ac_match->string) && forward_matches == -1)\n  {\n    flags |= RE_FLAGS_WIDE;\n    FAIL_ON_ERROR(exec(\n        context,\n        ac_match->forward_code,\n        data + offset,\n        data_size - offset,\n        offset,\n        flags,\n        NULL,\n        NULL,\n        &forward_matches));\n  }\n\n  if (forward_matches == -1)\n    return ERROR_SUCCESS;\n\n  if (forward_matches == 0 && ac_match->backward_code == NULL)\n    return ERROR_SUCCESS;\n\n  callback_args.string = ac_match->string;\n  callback_args.context = context;\n  callback_args.data = data;\n  callback_args.data_size = data_size;\n  callback_args.data_base = data_base;\n  callback_args.forward_matches = forward_matches;\n  callback_args.full_word = STRING_IS_FULL_WORD(ac_match->string);\n\n  if (ac_match->backward_code != NULL)\n  {\n    FAIL_ON_ERROR(exec(\n        context,\n        ac_match->backward_code,\n        data + offset,\n        data_size - offset,\n        offset,\n        flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE,\n        _yr_scan_match_callback,\n        (void*) &callback_args,\n        &backward_matches));\n  }\n  else\n  {\n    FAIL_ON_ERROR(_yr_scan_match_callback(\n        data + offset, 0, flags, &callback_args));\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 628,
        "end_line": 720,
        "is_bug": false
    },
    {
        "name": "libyara.scan._yr_scan_wicompare#185",
        "src_path": "libyara/scan.c",
        "class_name": "libyara.scan",
        "signature": "libyara.scan._yr_scan_wicompare(     const uint8_t* data, size_t data_size, uint8_t* string, size_t string_length)",
        "snippet": "static int _yr_scan_wicompare(\n    const uint8_t* data,\n    size_t data_size,\n    uint8_t* string,\n    size_t string_length)\n{\n  const uint8_t* s1 = data;\n  const uint8_t* s2 = string;\n\n  size_t i = 0;\n\n  if (data_size < string_length * 2)\n    return 0;\n\n  while (i < string_length && yr_lowercase[*s1] == yr_lowercase[*s2])\n  {\n    s1+=2;\n    s2++;\n    i++;\n  }\n\n  return (int) ((i == string_length) ? i * 2 : 0);\n}",
        "begin_line": 185,
        "end_line": 207,
        "is_bug": true
    },
    {
        "name": "libyara.scan.yr_scan_verify_match#828",
        "src_path": "libyara/scan.c",
        "class_name": "libyara.scan",
        "signature": "libyara.scan.yr_scan_verify_match(     YR_SCAN_CONTEXT* context, YR_AC_MATCH* ac_match, const uint8_t* data, size_t data_size, uint64_t data_base, size_t offset)",
        "snippet": "int yr_scan_verify_match(\n    YR_SCAN_CONTEXT* context,\n    YR_AC_MATCH* ac_match,\n    const uint8_t* data,\n    size_t data_size,\n    uint64_t data_base,\n    size_t offset)\n{\n  YR_STRING* string = ac_match->string;\n\n  int result;\n\n  if (data_size - offset <= 0)\n    return ERROR_SUCCESS;\n\n  if (STRING_IS_DISABLED(string))\n    return ERROR_SUCCESS;\n\n  if (context->flags & SCAN_FLAGS_FAST_MODE &&\n      STRING_IS_SINGLE_MATCH(string) &&\n      string->matches[context->tidx].head != NULL)\n    return ERROR_SUCCESS;\n\n  if (STRING_IS_FIXED_OFFSET(string) &&\n      string->fixed_offset != data_base + offset)\n    return ERROR_SUCCESS;\n\n  #ifdef PROFILING_ENABLED\n  uint64_t start_time = yr_stopwatch_elapsed_us(&context->stopwatch);\n  #endif\n\n  if (STRING_IS_LITERAL(string))\n  {\n    result = _yr_scan_verify_literal_match(\n        context, ac_match, data, data_size, data_base, offset);\n  }\n  else\n  {\n    result = _yr_scan_verify_re_match(\n        context, ac_match, data, data_size, data_base, offset);\n  }\n\n  if (result != ERROR_SUCCESS)\n    context->last_error_string = string;\n\n  #ifdef PROFILING_ENABLED\n  uint64_t finish_time = yr_stopwatch_elapsed_us(&context->stopwatch);\n\n  string->rule->time_cost_per_thread[context->tidx] += (\n      finish_time - start_time);\n  #endif\n\n  return result;\n}",
        "begin_line": 828,
        "end_line": 881,
        "is_bug": false
    },
    {
        "name": "libyara.scanner._yr_scanner_clean_matches#128",
        "src_path": "libyara/scanner.c",
        "class_name": "libyara.scanner",
        "signature": "libyara.scanner._yr_scanner_clean_matches(     YR_SCANNER* scanner)",
        "snippet": "static void _yr_scanner_clean_matches(\n    YR_SCANNER* scanner)\n{\n  YR_RULE* rule;\n  YR_STRING** string;\n\n  int tidx = scanner->tidx;\n\n  yr_rules_foreach(scanner->rules, rule)\n  {\n    rule->t_flags[tidx] &= ~RULE_TFLAGS_MATCH;\n    rule->ns->t_flags[tidx] &= ~NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL;\n  }\n\n  if (scanner->matching_strings_arena != NULL)\n  {\n    string = (YR_STRING**) yr_arena_base_address(\n        scanner->matching_strings_arena);\n\n    while (string != NULL)\n    {\n      (*string)->matches[tidx].count = 0;\n      (*string)->matches[tidx].head = NULL;\n      (*string)->matches[tidx].tail = NULL;\n      (*string)->unconfirmed_matches[tidx].count = 0;\n      (*string)->unconfirmed_matches[tidx].head = NULL;\n      (*string)->unconfirmed_matches[tidx].tail = NULL;\n\n      string = (YR_STRING**) yr_arena_next_address(\n          scanner->matching_strings_arena,\n          string,\n          sizeof(YR_STRING*));\n    }\n  }\n}",
        "begin_line": 128,
        "end_line": 162,
        "is_bug": false
    },
    {
        "name": "libyara.scanner._yr_scanner_scan_mem_block#44",
        "src_path": "libyara/scanner.c",
        "class_name": "libyara.scanner",
        "signature": "libyara.scanner._yr_scanner_scan_mem_block(     YR_SCANNER* scanner, const uint8_t* block_data, YR_MEMORY_BLOCK* block)",
        "snippet": "static int _yr_scanner_scan_mem_block(\n    YR_SCANNER* scanner,\n    const uint8_t* block_data,\n    YR_MEMORY_BLOCK* block)\n{\n  YR_RULES* rules = scanner->rules;\n  YR_AC_TRANSITION_TABLE transition_table = rules->ac_transition_table;\n  YR_AC_MATCH_TABLE match_table = rules->ac_match_table;\n\n  YR_AC_MATCH* match;\n  YR_AC_TRANSITION transition;\n\n  size_t i = 0;\n  uint32_t state = YR_AC_ROOT_STATE;\n  uint16_t index;\n\n  while (i < block->size)\n  {\n    match = match_table[state].match;\n\n    if (i % 4096 == 0 && scanner->timeout > 0)\n    {\n      if (yr_stopwatch_elapsed_us(&scanner->stopwatch) > scanner->timeout)\n        return ERROR_SCAN_TIMEOUT;\n    }\n\n    while (match != NULL)\n    {\n      if (match->backtrack <= i)\n      {\n        FAIL_ON_ERROR(yr_scan_verify_match(\n            scanner,\n            match,\n            block_data,\n            block->size,\n            block->base,\n            i - match->backtrack));\n      }\n\n      match = match->next;\n    }\n\n    index = block_data[i++] + 1;\n    transition = transition_table[state + index];\n\n    while (YR_AC_INVALID_TRANSITION(transition, index))\n    {\n      if (state != YR_AC_ROOT_STATE)\n      {\n        state = YR_AC_NEXT_STATE(transition_table[state]);\n        transition = transition_table[state + index];\n      }\n      else\n      {\n        transition = 0;\n        break;\n      }\n    }\n\n    state = YR_AC_NEXT_STATE(transition);\n  }\n\n  match = match_table[state].match;\n\n  while (match != NULL)\n  {\n    if (match->backtrack <= i)\n    {\n      FAIL_ON_ERROR(yr_scan_verify_match(\n          scanner,\n          match,\n          block_data,\n          block->size,\n          block->base,\n          i - match->backtrack));\n    }\n\n    match = match->next;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 44,
        "end_line": 125,
        "is_bug": false
    },
    {
        "name": "libyara.scanner.exception_handler#128",
        "src_path": "libyara/scanner.c",
        "class_name": "libyara.scanner",
        "signature": "libyara.scanner.exception_handler(int sig)",
        "snippet": "static void exception_handler(int sig) {\n  if (sig == SIGBUS || sig == SIGSEGV)\n  {\n    int tidx = yr_get_tidx();\n\n    if (tidx != -1 && exc_jmp_buf[tidx] != NULL)\n      siglongjmp(*exc_jmp_buf[tidx], 1);\n  }\n}",
        "begin_line": 128,
        "end_line": 136,
        "is_bug": false
    },
    {
        "name": "libyara.scanner.yr_scanner_create#165",
        "src_path": "libyara/scanner.c",
        "class_name": "libyara.scanner",
        "signature": "libyara.scanner.yr_scanner_create(     YR_RULES* rules, YR_SCANNER** scanner)",
        "snippet": "YR_API int yr_scanner_create(\n    YR_RULES* rules,\n    YR_SCANNER** scanner)\n{\n  YR_EXTERNAL_VARIABLE* external;\n  YR_SCANNER* new_scanner;\n\n  new_scanner = (YR_SCANNER*) yr_calloc(1, sizeof(YR_SCANNER));\n\n  if (new_scanner == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      yr_hash_table_create(64, &new_scanner->objects_table),\n      yr_scanner_destroy(new_scanner));\n\n  external = rules->externals_list_head;\n\n  while (!EXTERNAL_VARIABLE_IS_NULL(external))\n  {\n    YR_OBJECT* object;\n\n    FAIL_ON_ERROR_WITH_CLEANUP(\n        yr_object_from_external_variable(external, &object),\n        yr_scanner_destroy(new_scanner));\n\n    FAIL_ON_ERROR_WITH_CLEANUP(\n        yr_hash_table_add(\n            new_scanner->objects_table,\n            external->identifier,\n            NULL,\n            (void*) object),\n        yr_scanner_destroy(new_scanner));\n\n    external++;\n  }\n\n  new_scanner->rules = rules;\n  new_scanner->tidx = -1;\n  new_scanner->entry_point = UNDEFINED;\n\n  *scanner = new_scanner;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 165,
        "end_line": 209,
        "is_bug": false
    },
    {
        "name": "libyara.scanner.yr_scanner_destroy#212",
        "src_path": "libyara/scanner.c",
        "class_name": "libyara.scanner",
        "signature": "libyara.scanner.yr_scanner_destroy(     YR_SCANNER* scanner)",
        "snippet": "YR_API void yr_scanner_destroy(\n    YR_SCANNER* scanner)\n{\n  RE_FIBER* fiber;\n  RE_FIBER* next_fiber;\n\n  fiber = scanner->re_fiber_pool.fibers.head;\n\n  while (fiber != NULL)\n  {\n    next_fiber = fiber->next;\n    yr_free(fiber);\n    fiber = next_fiber;\n  }\n\n  if (scanner->objects_table != NULL)\n  {\n    yr_hash_table_destroy(\n        scanner->objects_table,\n        (YR_HASH_TABLE_FREE_VALUE_FUNC) yr_object_destroy);\n  }\n\n  yr_free(scanner);\n}",
        "begin_line": 212,
        "end_line": 235,
        "is_bug": false
    },
    {
        "name": "libyara.scanner.yr_scanner_scan_mem_blocks#333",
        "src_path": "libyara/scanner.c",
        "class_name": "libyara.scanner",
        "signature": "libyara.scanner.yr_scanner_scan_mem_blocks(     YR_SCANNER* scanner, YR_MEMORY_BLOCK_ITERATOR* iterator)",
        "snippet": "YR_API int yr_scanner_scan_mem_blocks(\n    YR_SCANNER* scanner,\n    YR_MEMORY_BLOCK_ITERATOR* iterator)\n{\n  YR_RULES* rules;\n  YR_RULE* rule;\n  YR_MEMORY_BLOCK* block;\n\n  int tidx = 0;\n  int result = ERROR_SUCCESS;\n\n  uint64_t elapsed_time;\n\n  if (scanner->callback == NULL)\n    return ERROR_CALLBACK_REQUIRED;\n\n  scanner->iterator = iterator;\n  rules = scanner->rules;\n  block = iterator->first(iterator);\n\n  if (block == NULL)\n    return ERROR_SUCCESS;\n\n  yr_mutex_lock(&rules->mutex);\n\n  while (tidx < YR_MAX_THREADS && YR_BITARRAY_TEST(rules->tidx_mask, tidx))\n  {\n    tidx++;\n  }\n\n  if (tidx < YR_MAX_THREADS)\n    YR_BITARRAY_SET(rules->tidx_mask, tidx);\n  else\n    result = ERROR_TOO_MANY_SCAN_THREADS;\n\n  yr_mutex_unlock(&rules->mutex);\n\n  if (result != ERROR_SUCCESS)\n    return result;\n\n  scanner->tidx = tidx;\n  scanner->file_size = block->size;\n\n  yr_set_tidx(tidx);\n\n  result = yr_arena_create(1048576, 0, &scanner->matches_arena);\n\n  if (result != ERROR_SUCCESS)\n    goto _exit;\n\n  result = yr_arena_create(4096, 0, &scanner->matching_strings_arena);\n\n  if (result != ERROR_SUCCESS)\n    goto _exit;\n\n  yr_stopwatch_start(&scanner->stopwatch);\n\n  while (block != NULL)\n  {\n    const uint8_t* data = block->fetch_data(block);\n\n    // fetch may fail\n    if (data == NULL)\n    {\n      block = iterator->next(iterator);\n      continue;\n    }\n\n    if (scanner->entry_point == UNDEFINED)\n    {\n      YR_TRYCATCH(\n        !(scanner->flags & SCAN_FLAGS_NO_TRYCATCH),\n        {\n          if (scanner->flags & SCAN_FLAGS_PROCESS_MEMORY)\n            scanner->entry_point = yr_get_entry_point_address(\n                data,\n                block->size,\n                block->base);\n          else\n            scanner->entry_point = yr_get_entry_point_offset(\n                data,\n                block->size);\n        },{});\n    }\n\n    YR_TRYCATCH(\n      !(scanner->flags & SCAN_FLAGS_NO_TRYCATCH),\n      {\n        result = _yr_scanner_scan_mem_block(\n            scanner,\n            data,\n            block);\n      },{\n        result = ERROR_COULD_NOT_MAP_FILE;\n      });\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n\n    block = iterator->next(iterator);\n  }\n\n  YR_TRYCATCH(\n    !(scanner->flags & SCAN_FLAGS_NO_TRYCATCH),\n    {\n      result = yr_execute_code(scanner);\n    },{\n      result = ERROR_COULD_NOT_MAP_FILE;\n    });\n\n  if (result != ERROR_SUCCESS)\n    goto _exit;\n\n  yr_rules_foreach(rules, rule)\n  {\n    int message;\n\n    if (rule->t_flags[tidx] & RULE_TFLAGS_MATCH &&\n        !(rule->ns->t_flags[tidx] & NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL))\n    {\n      message = CALLBACK_MSG_RULE_MATCHING;\n    }\n    else\n    {\n      message = CALLBACK_MSG_RULE_NOT_MATCHING;\n    }\n\n    if (!RULE_IS_PRIVATE(rule))\n    {\n      switch (scanner->callback(message, rule, scanner->user_data))\n      {\n        case CALLBACK_ABORT:\n          result = ERROR_SUCCESS;\n          goto _exit;\n\n        case CALLBACK_ERROR:\n          result = ERROR_CALLBACK_ERROR;\n          goto _exit;\n      }\n    }\n  }\n\n  scanner->callback(CALLBACK_MSG_SCAN_FINISHED, NULL, scanner->user_data);\n\n_exit:\n\n  elapsed_time = yr_stopwatch_elapsed_us(&scanner->stopwatch);\n\n  #ifdef PROFILING_ENABLED\n  yr_rules_foreach(rules, rule)\n  {\n    #ifdef _WIN32\n    InterlockedAdd64(&rule->time_cost, rule->time_cost_per_thread[tidx]);\n    #else\n    __sync_fetch_and_add(&rule->time_cost, rule->time_cost_per_thread[tidx]);\n    #endif\n\n    rule->time_cost_per_thread[tidx] = 0;\n  }\n  #endif\n\n  _yr_scanner_clean_matches(scanner);\n\n  if (scanner->matches_arena != NULL)\n  {\n    yr_arena_destroy(scanner->matches_arena);\n    scanner->matches_arena = NULL;\n  }\n\n  if (scanner->matching_strings_arena != NULL)\n  {\n    yr_arena_destroy(scanner->matching_strings_arena);\n    scanner->matching_strings_arena = NULL;\n  }\n\n  yr_mutex_lock(&rules->mutex);\n  YR_BITARRAY_UNSET(rules->tidx_mask, tidx);\n  rules->time_cost += elapsed_time;\n  yr_mutex_unlock(&rules->mutex);\n\n  yr_set_tidx(-1);\n\n  return result;\n}",
        "begin_line": 333,
        "end_line": 516,
        "is_bug": false
    },
    {
        "name": "libyara.scanner.yr_scanner_set_callback#238",
        "src_path": "libyara/scanner.c",
        "class_name": "libyara.scanner",
        "signature": "libyara.scanner.yr_scanner_set_callback(     YR_SCANNER* scanner, YR_CALLBACK_FUNC callback, void* user_data)",
        "snippet": "YR_API void yr_scanner_set_callback(\n    YR_SCANNER* scanner,\n    YR_CALLBACK_FUNC callback,\n    void* user_data)\n{\n  scanner->callback = callback;\n  scanner->user_data = user_data;\n}",
        "begin_line": 238,
        "end_line": 245,
        "is_bug": false
    },
    {
        "name": "libyara.scanner.yr_scanner_set_flags#256",
        "src_path": "libyara/scanner.c",
        "class_name": "libyara.scanner",
        "signature": "libyara.scanner.yr_scanner_set_flags(     YR_SCANNER* scanner, int flags)",
        "snippet": "YR_API void yr_scanner_set_flags(\n    YR_SCANNER* scanner,\n    int flags)\n{\n  scanner->flags = flags;\n}",
        "begin_line": 256,
        "end_line": 261,
        "is_bug": false
    },
    {
        "name": "libyara.scanner.yr_scanner_set_timeout#248",
        "src_path": "libyara/scanner.c",
        "class_name": "libyara.scanner",
        "signature": "libyara.scanner.yr_scanner_set_timeout(     YR_SCANNER* scanner, int timeout)",
        "snippet": "YR_API void yr_scanner_set_timeout(\n    YR_SCANNER* scanner,\n    int timeout)\n{\n  scanner->timeout = timeout * 1000000L;  // convert timeout to microseconds.\n}",
        "begin_line": 248,
        "end_line": 253,
        "is_bug": false
    },
    {
        "name": "libyara.stack.yr_stack_create#46",
        "src_path": "libyara/stack.c",
        "class_name": "libyara.stack",
        "signature": "libyara.stack.yr_stack_create(     int initial_capacity, int item_size, YR_STACK** stack)",
        "snippet": "int yr_stack_create(\n    int initial_capacity,\n    int item_size,\n    YR_STACK** stack)\n{\n  *stack = (YR_STACK*) yr_malloc(sizeof(YR_STACK));\n\n  if (*stack == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  (*stack)->items = yr_malloc(initial_capacity * item_size);\n\n  if ((*stack)->items == NULL)\n  {\n    yr_free(*stack);\n    *stack = NULL;\n    return ERROR_INSUFFICIENT_MEMORY;\n  }\n\n  (*stack)->capacity = initial_capacity;\n  (*stack)->item_size = item_size;\n  (*stack)->top = 0;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 46,
        "end_line": 70,
        "is_bug": false
    },
    {
        "name": "libyara.stack.yr_stack_destroy#78",
        "src_path": "libyara/stack.c",
        "class_name": "libyara.stack",
        "signature": "libyara.stack.yr_stack_destroy(     YR_STACK* stack)",
        "snippet": "void yr_stack_destroy(\n    YR_STACK* stack)\n{\n  yr_free(stack->items);\n  yr_free(stack);\n}",
        "begin_line": 78,
        "end_line": 83,
        "is_bug": false
    },
    {
        "name": "libyara.stack.yr_stack_pop#130",
        "src_path": "libyara/stack.c",
        "class_name": "libyara.stack",
        "signature": "libyara.stack.yr_stack_pop(     YR_STACK* stack, void* item)",
        "snippet": "int yr_stack_pop(\n    YR_STACK* stack,\n    void* item)\n{\n  if (stack->top == 0)  // Return 0 if stack is empty.\n    return 0;\n\n  stack->top--;\n\n  memcpy(\n      item,\n      (uint8_t*) stack->items + stack->top * stack->item_size,\n      stack->item_size);\n\n  return 1;\n}",
        "begin_line": 130,
        "end_line": 145,
        "is_bug": false
    },
    {
        "name": "libyara.stack.yr_stack_push#94",
        "src_path": "libyara/stack.c",
        "class_name": "libyara.stack",
        "signature": "libyara.stack.yr_stack_push(     YR_STACK* stack, void* item)",
        "snippet": "int yr_stack_push(\n    YR_STACK* stack,\n    void* item)\n{\n  if (stack->top == stack->capacity)\n  {\n    void* items = yr_realloc(\n        stack->items, 2 * stack->capacity * stack->item_size);\n\n    if (items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    stack->items = items;\n    stack->capacity *= 2;\n  }\n\n  memcpy(\n      (uint8_t*) stack->items + stack->top * stack->item_size,\n      item,\n      stack->item_size);\n\n  stack->top++;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 94,
        "end_line": 118,
        "is_bug": false
    },
    {
        "name": "libyara.strutils.strlcpy#92",
        "src_path": "libyara/strutils.c",
        "class_name": "libyara.strutils",
        "signature": "libyara.strutils.strlcpy(     char* dst, const char* src, size_t size)",
        "snippet": "size_t strlcpy(\n    char* dst,\n    const char* src,\n    size_t size)\n{\n  register char* d = dst;\n  register const char* s = src;\n  register size_t n = size;\n\n  // Copy as many bytes as will fit\n\n  if (n != 0 && --n != 0)\n  {\n    do\n    {\n      if ((*d++ = *s++) == 0)\n        break;\n\n    } while (--n != 0);\n  }\n\n  // Not enough room in dst, add NUL and traverse rest of src\n\n  if (n == 0)\n  {\n    if (size != 0)\n      *d = '\\0';    // NULL-terminate dst\n\n    while (*s++);\n  }\n\n  return (s - src - 1);  // count does not include NULL\n}",
        "begin_line": 92,
        "end_line": 124,
        "is_bug": false
    },
    {
        "name": "libyara.threading.yr_mutex_create#132",
        "src_path": "libyara/threading.c",
        "class_name": "libyara.threading",
        "signature": "libyara.threading.yr_mutex_create(     YR_MUTEX* mutex)",
        "snippet": "int yr_mutex_create(\n    YR_MUTEX* mutex)\n{\n  if (pthread_mutex_init(mutex, NULL) != 0)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 132,
        "end_line": 139,
        "is_bug": false
    },
    {
        "name": "libyara.threading.yr_mutex_destroy#142",
        "src_path": "libyara/threading.c",
        "class_name": "libyara.threading",
        "signature": "libyara.threading.yr_mutex_destroy(     YR_MUTEX* mutex)",
        "snippet": "int yr_mutex_destroy(\n    YR_MUTEX* mutex)\n{\n  if (pthread_mutex_destroy(mutex) != 0)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 142,
        "end_line": 149,
        "is_bug": false
    },
    {
        "name": "libyara.threading.yr_mutex_lock#152",
        "src_path": "libyara/threading.c",
        "class_name": "libyara.threading",
        "signature": "libyara.threading.yr_mutex_lock(     YR_MUTEX* mutex)",
        "snippet": "int yr_mutex_lock(\n    YR_MUTEX* mutex)\n{\n  if (pthread_mutex_lock(mutex) != 0)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 152,
        "end_line": 159,
        "is_bug": false
    },
    {
        "name": "libyara.threading.yr_mutex_unlock#162",
        "src_path": "libyara/threading.c",
        "class_name": "libyara.threading",
        "signature": "libyara.threading.yr_mutex_unlock(     YR_MUTEX* mutex)",
        "snippet": "int yr_mutex_unlock(\n    YR_MUTEX* mutex)\n{\n  if (pthread_mutex_unlock(mutex) != 0)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 162,
        "end_line": 169,
        "is_bug": false
    },
    {
        "name": "libyara.threading.yr_thread_storage_create#172",
        "src_path": "libyara/threading.c",
        "class_name": "libyara.threading",
        "signature": "libyara.threading.yr_thread_storage_create(     YR_THREAD_STORAGE_KEY* storage)",
        "snippet": "int yr_thread_storage_create(\n    YR_THREAD_STORAGE_KEY* storage)\n{\n  if (pthread_key_create(storage, NULL) != 0)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 172,
        "end_line": 179,
        "is_bug": false
    },
    {
        "name": "libyara.threading.yr_thread_storage_destroy#182",
        "src_path": "libyara/threading.c",
        "class_name": "libyara.threading",
        "signature": "libyara.threading.yr_thread_storage_destroy(     YR_THREAD_STORAGE_KEY* storage)",
        "snippet": "int yr_thread_storage_destroy(\n    YR_THREAD_STORAGE_KEY* storage)\n{\n  if (pthread_key_delete(*storage) != 0)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 182,
        "end_line": 189,
        "is_bug": false
    },
    {
        "name": "libyara.threading.yr_thread_storage_get_value#203",
        "src_path": "libyara/threading.c",
        "class_name": "libyara.threading",
        "signature": "libyara.threading.yr_thread_storage_get_value(     YR_THREAD_STORAGE_KEY* storage)",
        "snippet": "void* yr_thread_storage_get_value(\n    YR_THREAD_STORAGE_KEY* storage)\n{\n  return pthread_getspecific(*storage);\n}",
        "begin_line": 203,
        "end_line": 207,
        "is_bug": false
    },
    {
        "name": "libyara.threading.yr_thread_storage_set_value#192",
        "src_path": "libyara/threading.c",
        "class_name": "libyara.threading",
        "signature": "libyara.threading.yr_thread_storage_set_value(     YR_THREAD_STORAGE_KEY* storage, void* value)",
        "snippet": "int yr_thread_storage_set_value(\n    YR_THREAD_STORAGE_KEY* storage,\n    void* value)\n{\n  if (pthread_setspecific(*storage, value) != 0)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 192,
        "end_line": 200,
        "is_bug": false
    }
]