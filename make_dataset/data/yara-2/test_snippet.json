[
    {
        "name": "tests.test-alignment.defects4cpp_test_index#4",
        "src_path": "tests/test-alignment.c",
        "class_name": "tests.test-alignment",
        "signature": "tests.test-alignment.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-alignment.main#68",
        "src_path": "tests/test-alignment.c",
        "class_name": "tests.test-alignment",
        "signature": "tests.test-alignment.main (int argc, char **argv)",
        "snippet": "int main (int argc, char **argv)\n{\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 1:\n  CHECK_SIZE(YR_NAMESPACE, 4 * YR_MAX_THREADS + 8);\n          break;\n      case 2:\n  CHECK_OFFSET(YR_NAMESPACE, 4 * YR_MAX_THREADS, name);\n          break;\n      case 3:\n  CHECK_SIZE(YR_META, 32);\n          break;\n      case 4:\n  CHECK_OFFSET(YR_META, 8,  integer);\n          break;\n      case 5:\n  CHECK_OFFSET(YR_META, 16, identifier);\n          break;\n      case 6:\n  CHECK_OFFSET(YR_META, 24, string);\n          break;\n      case 7:\n  CHECK_SIZE(YR_MATCHES, 24);\n          break;\n      case 8:\n  CHECK_OFFSET(YR_MATCHES, 8,  head);\n          break;\n      case 9:\n  CHECK_OFFSET(YR_MATCHES, 16, tail);\n          break;\n      case 10:\n  CHECK_SIZE(YR_STRING, 56 + 2 * 24 /* YR_MATCHES */ * YR_MAX_THREADS);\n          break;\n      case 11:\n  CHECK_OFFSET(YR_STRING, 4,  length);\n          break;\n      case 12:\n  CHECK_OFFSET(YR_STRING, 8,  identifier);\n          break;\n      case 13:\n  CHECK_OFFSET(YR_STRING, 16, string);\n          break;\n      case 14:\n  CHECK_OFFSET(YR_STRING, 24, chained_to);\n          break;\n      case 15:\n  CHECK_OFFSET(YR_STRING, 32, rule);\n          break;\n      case 16:\n  CHECK_OFFSET(YR_STRING, 40, chain_gap_min);\n          break;\n      case 17:\n  CHECK_OFFSET(YR_STRING, 44, chain_gap_max);\n          break;\n      case 18:\n  CHECK_OFFSET(YR_STRING, 48, fixed_offset);\n          break;\n      case 19:\n  CHECK_SIZE(YR_RULE, 64 + 12 * YR_MAX_THREADS);\n          break;\n      case 20:\n  CHECK_OFFSET(YR_RULE, 4,                           t_flags);\n          break;\n      case 21:\n  CHECK_OFFSET(YR_RULE, 8 + 4 * YR_MAX_THREADS,      identifier);\n          break;\n      case 22:\n  CHECK_OFFSET(YR_RULE, 8 + 4 * YR_MAX_THREADS + 8,  tags);\n          break;\n      case 23:\n  CHECK_OFFSET(YR_RULE, 8 + 4 * YR_MAX_THREADS + 16, metas);\n          break;\n      case 24:\n  CHECK_OFFSET(YR_RULE, 8 + 4 * YR_MAX_THREADS + 24, strings);\n          break;\n      case 25:\n  CHECK_OFFSET(YR_RULE, 8 + 4 * YR_MAX_THREADS + 32, ns);\n          break;\n      case 26:\n  CHECK_SIZE(YR_EXTERNAL_VARIABLE, 24);\n          break;\n      case 27:\n  CHECK_OFFSET(YR_EXTERNAL_VARIABLE, 8,  value.i);\n          break;\n      case 28:\n  CHECK_OFFSET(YR_EXTERNAL_VARIABLE, 8,  value.f);\n          break;\n      case 29:\n  CHECK_OFFSET(YR_EXTERNAL_VARIABLE, 8,  value.s);\n          break;\n      case 30:\n  CHECK_OFFSET(YR_EXTERNAL_VARIABLE, 16, identifier);\n          break;\n      case 31:\n  CHECK_SIZE(YR_AC_MATCH, 40);\n          break;\n      case 32:\n  CHECK_OFFSET(YR_AC_MATCH, 8,  string);\n          break;\n      case 33:\n  CHECK_OFFSET(YR_AC_MATCH, 16, forward_code);\n          break;\n      case 34:\n  CHECK_OFFSET(YR_AC_MATCH, 24, backward_code);\n          break;\n      case 35:\n  CHECK_OFFSET(YR_AC_MATCH, 32, next);\n          break;\n      case 36:\n  CHECK_SIZE(YARA_RULES_FILE_HEADER, 48);\n          break;\n      case 37:\n  CHECK_OFFSET(YARA_RULES_FILE_HEADER, 0, rules_list_head);\n          break;\n      case 38:\n  CHECK_OFFSET(YARA_RULES_FILE_HEADER, 8, externals_list_head);\n          break;\n      case 39:\n  CHECK_OFFSET(YARA_RULES_FILE_HEADER, 16, code_start);\n          break;\n      case 40:\n  CHECK_OFFSET(YARA_RULES_FILE_HEADER, 24, ac_match_table);\n          break;\n      case 41:\n  CHECK_OFFSET(YARA_RULES_FILE_HEADER, 32, ac_transition_table);\n          break;\n      case 42:\n  CHECK_SIZE(SIZED_STRING, 12);\n          break;\n      case 43:\n  CHECK_OFFSET(SIZED_STRING, 4, flags);\n          break;\n      case 44:\n  CHECK_OFFSET(SIZED_STRING, 8, c_string);\n          break;\n  }\n\n  return err;\n}",
        "begin_line": 68,
        "end_line": 207,
        "is_bug": false
    },
    {
        "name": "tests.test-api._include_callback#59",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api._include_callback(   const char* include_name, const char* calling_rule_filename, const char* calling_rule_namespace, void* user_data)",
        "snippet": "const char* _include_callback(\n  const char* include_name,\n  const char* calling_rule_filename,\n  const char* calling_rule_namespace,\n  void* user_data)\n{\nif (strcmp(include_name, \"ok\") == 0)\n  return \"rule test {condition: true}\";\nelse\n  return NULL;\n}",
        "begin_line": 59,
        "end_line": 69,
        "is_bug": false
    },
    {
        "name": "tests.test-api.ast_callback#535",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.ast_callback(     const YR_RULE* rule, const char* string_identifier, const RE_AST* re_ast, void* user_data)",
        "snippet": "void ast_callback(\n    const YR_RULE* rule,\n    const char* string_identifier,\n    const RE_AST* re_ast,\n    void* user_data)\n{\n  if (strcmp(rule->identifier, \"test\") == 0 &&\n      strcmp(string_identifier, \"$foo\") == 0)\n  {\n    *((int*) user_data) = 1;\n  }\n}",
        "begin_line": 535,
        "end_line": 546,
        "is_bug": false
    },
    {
        "name": "tests.test-api.defects4cpp_test_index#4",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-api.main#746",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  char *top_srcdir = getenv(\"TOP_SRCDIR\");\n  if (top_srcdir)\n    chdir(top_srcdir);\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 45:\n  test_disabled_rules();\n          break;\n      case 46:\n  test_file_descriptor();\n          break;\n      case 47:\n  test_max_string_per_rules();\n          break;\n      case 48:\n  test_max_match_data();\n          break;\n      case 49:\n  test_include_callback();\n          break;\n      case 50:\n  test_save_load_rules();\n          break;\n      case 51:\n  test_scanner();\n          break;\n      case 52:\n  test_ast_callback();\n          break;\n      case 53:\n  test_rules_stats();\n          break;\n      case 54:\n  test_issue_834();\n          break;\n      case 55:\n  test_issue_920();\n          break;\n  }\n}",
        "begin_line": 746,
        "end_line": 787,
        "is_bug": false
    },
    {
        "name": "tests.test-api.stats_for_rules#591",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.stats_for_rules(     const char* rules_str, YR_RULES_STATS* stats)",
        "snippet": "void stats_for_rules(\n    const char* rules_str,\n    YR_RULES_STATS* stats)\n{\n  YR_COMPILER* compiler = NULL;\n  YR_RULES* rules = NULL;\n\n  yr_initialize();\n\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (yr_compiler_add_string(compiler, rules_str, NULL) != 0)\n  {\n    yr_compiler_destroy(compiler);\n    perror(\"yr_compiler_add_string\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (yr_compiler_get_rules(compiler, &rules) != ERROR_SUCCESS)\n  {\n    yr_compiler_destroy(compiler);\n    perror(\"yr_compiler_get_rules\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_rules_get_stats(rules, stats);\n\n  yr_compiler_destroy(compiler);\n  yr_rules_destroy(rules);\n  yr_finalize();\n}",
        "begin_line": 591,
        "end_line": 625,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_ast_callback#548",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_ast_callback()",
        "snippet": "void test_ast_callback()\n{\n  const char* rules_str = \"\\\n      rule test { \\\n      strings: $foo = /a.*b/ \\\n      condition: $foo }\";\n\n  YR_COMPILER* compiler = NULL;\n\n  yr_initialize();\n\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  int ok = 0;\n\n  yr_compiler_set_re_ast_callback(\n      compiler,\n      ast_callback,\n      &ok);\n\n  // Compile a rule that use the variables in the condition.\n  if (yr_compiler_add_string(compiler, rules_str, NULL) != 0)\n  {\n    yr_compiler_destroy(compiler);\n    perror(\"yr_compiler_add_string\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (!ok)\n  {\n    printf(\"ast callback failed\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_compiler_destroy(compiler);\n  yr_finalize();\n}",
        "begin_line": 548,
        "end_line": 588,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_disabled_rules#15",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_disabled_rules()",
        "snippet": "void test_disabled_rules()\n{\n  YR_RULES* rules;\n  YR_RULE* rule;\n\n  int matches = 0;\n  char* buf = \"foo bar\";\n  char* rules_str = \" \\\n    rule disabled_rule {condition: true} \\\n    rule false_rule {condition: true and disabled_rule} \\\n    rule true_rule {condition: true or disabled_rule}\";\n\n\n  yr_initialize();\n\n  if (compile_rule(rules_str, &rules) != ERROR_SUCCESS)\n  {\n    perror(\"compile_rule\");\n    exit(EXIT_FAILURE);\n  }\n\n  // diable any rule containing disable in its identifier\n  yr_rules_foreach(rules, rule)\n  {\n    if (strstr(rule->identifier, \"disabled\"))\n      yr_rule_disable(rule);\n  }\n\n  yr_rules_scan_mem(\n      rules, (uint8_t *) buf, strlen(buf), 0, count_matches, &matches, 0);\n\n  yr_rules_destroy(rules);\n\n  // matches should be exactly one.\n  if (matches != 1)\n  {\n    fprintf(stderr, \"test_disabled_rules failed\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_finalize();\n}",
        "begin_line": 15,
        "end_line": 56,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_file_descriptor#105",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_file_descriptor()",
        "snippet": "void test_file_descriptor()\n{\n  YR_COMPILER* compiler = NULL;\n  YR_RULES* rules = NULL;\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n  HANDLE fd = CreateFile(\"tests/data/baz.yar\", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);\n  if (fd == INVALID_HANDLE_VALUE)\n  {\n    fputs(\"CreateFile failed\", stderr);\n    exit(1);\n  }\n#else\n  int fd = open(\"tests/data/baz.yar\", O_RDONLY);\n  if (fd < 0)\n  {\n    perror(\"open\");\n    exit(EXIT_FAILURE);\n  }\n#endif\n\n  yr_initialize();\n\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (yr_compiler_add_fd(compiler, fd, NULL, NULL) != 0)\n  {\n    perror(\"yr_compiler_add_fd\");\n    exit(EXIT_FAILURE);\n  }\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n  CloseHandle(fd);\n#else\n  close(fd);\n#endif\n\n  if (yr_compiler_get_rules(compiler, &rules) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_add_fd\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (compiler)\n    yr_compiler_destroy(compiler);\n\n  if (rules)\n    yr_rules_destroy(rules);\n\n  yr_finalize();\n\n  return;\n}",
        "begin_line": 105,
        "end_line": 161,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_include_callback#72",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_include_callback()",
        "snippet": "void test_include_callback()\n{\n  YR_COMPILER* compiler = NULL;\n\n  yr_initialize();\n\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_compiler_set_include_callback(compiler, _include_callback, NULL, NULL);\n\n  // This include produces no error.\n  if (yr_compiler_add_string(compiler, \"include \\\"ok\\\"\", NULL) != 0)\n  {\n    yr_compiler_destroy(compiler);\n    exit(EXIT_FAILURE);\n  }\n\n  // This include one error.\n  if (yr_compiler_add_string(compiler, \"include \\\"fail\\\"\", NULL) != 1)\n  {\n    yr_compiler_destroy(compiler);\n    exit(EXIT_FAILURE);\n  }\n\n  yr_compiler_destroy(compiler);\n  yr_finalize();\n}",
        "begin_line": 72,
        "end_line": 102,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_issue_834#483",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_issue_834()",
        "snippet": "void test_issue_834()\n{\n  const char* buf = \"dummy\";\n  const char* rules_str = \"import \\\"tests\\\" rule test { condition: true }\";\n\n  YR_COMPILER* compiler = NULL;\n  YR_RULES* rules = NULL;\n  YR_SCANNER* scanner = NULL;\n\n  yr_initialize();\n\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (yr_compiler_add_string(compiler, rules_str, NULL) != 0)\n  {\n    yr_compiler_destroy(compiler);\n    perror(\"yr_compiler_add_string\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (yr_compiler_get_rules(compiler, &rules) != ERROR_SUCCESS)\n  {\n    yr_compiler_destroy(compiler);\n    perror(\"yr_compiler_get_rules\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_compiler_destroy(compiler);\n\n  if (yr_scanner_create(rules, &scanner)!= ERROR_SUCCESS)\n  {\n    yr_rules_destroy(rules);\n    perror(\"yr_scanner_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_scanner_set_callback(scanner, do_nothing, NULL);\n\n  // Call yr_scanner_scan_mem twice.\n  yr_scanner_scan_mem(scanner, (uint8_t *) buf, strlen(buf));\n  yr_scanner_scan_mem(scanner, (uint8_t *) buf, strlen(buf));\n\n  yr_scanner_destroy(scanner);\n  yr_rules_destroy(rules);\n  yr_finalize();\n}",
        "begin_line": 483,
        "end_line": 532,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_issue_920#710",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_issue_920()",
        "snippet": "void test_issue_920()\n{\n  const char* rules_str = \"\\\n      rule test { \\\n        condition: true \\\n      }\";\n\n  YR_COMPILER* compiler = NULL;\n\n  yr_initialize();\n\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  // Define a variable named \"test\"\n  yr_compiler_define_boolean_variable(compiler, \"test\", 1);\n\n  // The compilation should not succeed, as the rule is named \"test\" and a\n  // a variable with the same name already exists.\n  yr_compiler_add_string(compiler, rules_str, NULL);\n\n  if (compiler->last_error != ERROR_DUPLICATED_IDENTIFIER)\n  {\n    yr_compiler_destroy(compiler);\n    printf(\"expecting ERROR_CALLBACK_REQUIRED (%d), got: %d\\n\",\n           ERROR_DUPLICATED_IDENTIFIER, compiler->last_error);\n    exit(EXIT_FAILURE);\n  }\n\n  yr_compiler_destroy(compiler);\n  yr_finalize();\n}",
        "begin_line": 710,
        "end_line": 744,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_max_match_data#235",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_max_match_data()",
        "snippet": "void test_max_match_data()\n{\n  YR_RULES* rules;\n\n  uint32_t new_max_match_data = 0;\n  uint32_t old_max_match_data;\n\n  char* rules_str = \"rule t { strings: $a = \\\"foobar\\\" condition: $a }\";\n\n  yr_initialize();\n\n  yr_get_configuration(\n      YR_CONFIG_MAX_MATCH_DATA,\n      (void*) &old_max_match_data);\n\n  yr_set_configuration(\n      YR_CONFIG_MAX_MATCH_DATA,\n      (void*) &new_max_match_data);\n\n  if (compile_rule(rules_str, &rules) != ERROR_SUCCESS)\n  {\n    perror(\"compile_rule\");\n    exit(EXIT_FAILURE);\n  }\n\n  int err = yr_rules_scan_mem(\n      rules,\n      (const uint8_t *) \"foobar\",\n      6,\n      0,\n      test_max_match_data_callback,\n      NULL,\n      0);\n\n  if (err != ERROR_SUCCESS)\n  {\n    fprintf(stderr, \"test_max_match_data failed\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_rules_destroy(rules);\n  yr_finalize();\n}",
        "begin_line": 235,
        "end_line": 277,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_max_match_data_callback#210",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_max_match_data_callback(     int message, void* message_data, void* user_data)",
        "snippet": "int test_max_match_data_callback(\n    int message,\n    void* message_data,\n    void* user_data)\n{\n  if (message == CALLBACK_MSG_RULE_MATCHING)\n  {\n    YR_RULE* r = (YR_RULE*) message_data;\n    YR_STRING* s;\n\n    yr_rule_strings_foreach(r, s)\n    {\n      YR_MATCH* m;\n\n      yr_string_matches_foreach(s, m)\n      {\n        if (m->data_length > 0)\n          return CALLBACK_ERROR;\n      }\n    }\n  }\n\n  return CALLBACK_CONTINUE;\n}",
        "begin_line": 210,
        "end_line": 233,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_max_string_per_rules#163",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_max_string_per_rules()",
        "snippet": "void test_max_string_per_rules()\n{\n  uint32_t new_max_strings_per_rule = 1;\n  uint32_t old_max_strings_per_rule;\n\n  yr_initialize();\n\n  yr_get_configuration(\n      YR_CONFIG_MAX_STRINGS_PER_RULE,\n      (void*) &old_max_strings_per_rule);\n\n  yr_set_configuration(\n      YR_CONFIG_MAX_STRINGS_PER_RULE,\n      (void*) &new_max_strings_per_rule);\n\n  assert_error(\n      \"rule test { \\\n         strings: \\\n           $ = \\\"uno\\\" \\\n           $ = \\\"dos\\\" \\\n         condition: \\\n           all of them }\",\n      ERROR_TOO_MANY_STRINGS);\n\n  new_max_strings_per_rule = 2;\n\n  yr_set_configuration(\n      YR_CONFIG_MAX_STRINGS_PER_RULE,\n      (void*) &new_max_strings_per_rule);\n\n  assert_error(\n      \"rule test { \\\n         strings: \\\n           $ = \\\"uno\\\" \\\n           $ = \\\"dos\\\" \\\n         condition: \\\n           all of them }\",\n      ERROR_SUCCESS);\n\n  yr_set_configuration(\n      YR_CONFIG_MAX_STRINGS_PER_RULE,\n      (void*) &old_max_strings_per_rule);\n\n  yr_finalize();\n}",
        "begin_line": 163,
        "end_line": 207,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_rules_stats#628",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_rules_stats()",
        "snippet": "void test_rules_stats()\n{\n  YR_RULES_STATS stats;\n\n  stats_for_rules(\"\\\n      rule test { \\\n      strings: $ = /.*/ \\\n      condition: all of them }\",\n      &stats);\n\n  assert_true_expr(stats.rules == 1);\n  assert_true_expr(stats.strings == 1);\n  assert_true_expr(stats.ac_root_match_list_length == 1);\n\n  stats_for_rules(\"\\\n      rule test { \\\n      strings: $ = \\\"abc\\\" \\\n      condition: all of them }\",\n      &stats);\n\n  assert_true_expr(stats.rules == 1);\n  assert_true_expr(stats.strings == 1);\n  assert_true_expr(stats.ac_matches == 1);\n  assert_true_expr(stats.ac_root_match_list_length == 0);\n  assert_true_expr(stats.top_ac_match_list_lengths[0] == 1);\n  assert_true_expr(stats.ac_match_list_length_pctls[1] == 1);\n  assert_true_expr(stats.ac_match_list_length_pctls[100] == 1);\n\n  stats_for_rules(\"\\\n      rule test { \\\n      strings: \\\n        $ = \\\"00000\\\" \\\n        $ = \\\"00001\\\" \\\n        $ = \\\"00002\\\" \\\n        $ = \\\"11110\\\" \\\n        $ = \\\"11111\\\" \\\n        $ = \\\"11112\\\" \\\n      condition: all of them }\",\n      &stats);\n\n  assert_true_expr(stats.rules == 1);\n  assert_true_expr(stats.strings == 6);\n  assert_true_expr(stats.ac_matches == 6);\n  assert_true_expr(stats.ac_root_match_list_length == 0);\n  assert_true_expr(stats.top_ac_match_list_lengths[0] == 3);\n  assert_true_expr(stats.ac_match_list_length_pctls[1] == 3);\n  assert_true_expr(stats.ac_match_list_length_pctls[100] == 3);\n\n  stats_for_rules(\"\\\n      rule test { \\\n      strings: \\\n        $ = \\\"00000\\\" \\\n        $ = \\\"00001\\\" \\\n        $ = \\\"00002\\\" \\\n        $ = \\\"11110\\\" \\\n        $ = \\\"22220\\\" \\\n        $ = \\\"33330\\\" \\\n        $ = \\\"33331\\\" \\\n        $ = \\\"44440\\\" \\\n      condition: all of them }\",\n      &stats);\n\n  assert_true_expr(stats.rules == 1);\n  assert_true_expr(stats.strings == 8);\n  assert_true_expr(stats.ac_matches == 8);\n  assert_true_expr(stats.ac_root_match_list_length == 0);\n  assert_true_expr(stats.top_ac_match_list_lengths[0] == 3);\n  assert_true_expr(stats.ac_match_list_length_pctls[1] == 1);\n  assert_true_expr(stats.ac_match_list_length_pctls[100] == 3);\n\n  stats_for_rules(\"\\\n      rule test { \\\n      condition: true }\",\n      &stats);\n\n  assert_true_expr(stats.rules == 1);\n  assert_true_expr(stats.strings == 0);\n  assert_true_expr(stats.ac_matches == 0);\n  assert_true_expr(stats.ac_root_match_list_length == 0);\n}",
        "begin_line": 628,
        "end_line": 707,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_save_load_rules#280",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_save_load_rules()",
        "snippet": "void test_save_load_rules()\n{\n  YR_COMPILER* compiler = NULL;\n  YR_RULES* rules = NULL;\n\n  int matches = 0;\n  char* rules_str = \"rule t {condition: bool_var and str_var == \\\"foobar\\\"}\";\n\n  yr_initialize();\n\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_compiler_define_boolean_variable(compiler, \"bool_var\", 1);\n  yr_compiler_define_string_variable(compiler, \"str_var\", \"foobar\");\n\n  if (yr_compiler_add_string(compiler, rules_str, NULL) != 0)\n  {\n    yr_compiler_destroy(compiler);\n    perror(\"yr_compiler_add_string\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (yr_compiler_get_rules(compiler, &rules) != ERROR_SUCCESS)\n  {\n    yr_compiler_destroy(compiler);\n    perror(\"yr_compiler_add_fd\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_compiler_destroy(compiler);\n\n  if (yr_rules_save(rules, \"test-rules.yarc\") != ERROR_SUCCESS)\n  {\n    yr_rules_destroy(rules);\n    perror(\"yr_rules_save\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_rules_destroy(rules);\n\n  if (yr_rules_load(\"test-rules.yarc\", &rules) != ERROR_SUCCESS)\n  {\n    perror(\"yr_rules_load\");\n    exit(EXIT_FAILURE);\n  }\n\n  int err = yr_rules_scan_mem(\n      rules,\n      (uint8_t *) \"\",\n       0,\n       0,\n       count_matches,\n       &matches,\n       0);\n\n  if (err != ERROR_SUCCESS)\n  {\n    fprintf(stderr, \"test_save_load_rules: error: %d\\n\", err);\n    exit(EXIT_FAILURE);\n  }\n\n  if (matches != 1)\n  {\n    fprintf(stderr, \"test_save_load_rules: expecting 1 match, got: %d\\n\", matches);\n    exit(EXIT_FAILURE);\n  }\n\n  yr_rules_destroy(rules);\n  yr_finalize();\n}",
        "begin_line": 280,
        "end_line": 353,
        "is_bug": false
    },
    {
        "name": "tests.test-api.test_scanner#356",
        "src_path": "tests/test-api.c",
        "class_name": "tests.test-api",
        "signature": "tests.test-api.test_scanner()",
        "snippet": "void test_scanner()\n{\n  int matches = 0;\n  const char* buf = \"dummy\";\n  const char* rules_str = \"\\\n    rule test { \\\n    condition: bool_var and int_var == 1 and str_var == \\\"foo\\\" }\";\n\n  YR_COMPILER* compiler = NULL;\n  YR_RULES* rules = NULL;\n  YR_SCANNER* scanner1 = NULL;\n  YR_SCANNER* scanner2 = NULL;\n\n  int result;\n\n  yr_initialize();\n\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  // Define a few variables\n  yr_compiler_define_integer_variable(compiler, \"int_var\", 0);\n  yr_compiler_define_boolean_variable(compiler, \"bool_var\", 0);\n  yr_compiler_define_string_variable(compiler, \"str_var\", \"\");\n\n\n  if (yr_compiler_define_string_variable(\n      compiler, \"str_var\", \"\") != ERROR_DUPLICATED_EXTERNAL_VARIABLE)\n  {\n    yr_compiler_destroy(compiler);\n    perror(\"expecting ERROR_DUPLICATED_EXTERNAL_VARIABLE\");\n    exit(EXIT_FAILURE);\n  }\n\n  // Compile a rule that use the variables in the condition.\n  if (yr_compiler_add_string(compiler, rules_str, NULL) != 0)\n  {\n    yr_compiler_destroy(compiler);\n    perror(\"yr_compiler_add_string\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (yr_compiler_get_rules(compiler, &rules) != ERROR_SUCCESS)\n  {\n    yr_compiler_destroy(compiler);\n    perror(\"yr_compiler_get_rules\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_compiler_destroy(compiler);\n\n  // Create an scanner\n  if (yr_scanner_create(rules, &scanner1)!= ERROR_SUCCESS)\n  {\n    yr_rules_destroy(rules);\n    perror(\"yr_scanner_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  // Create another scanner\n  if (yr_scanner_create(rules, &scanner2)!= ERROR_SUCCESS)\n  {\n    yr_scanner_destroy(scanner1);\n    yr_rules_destroy(rules);\n    perror(\"yr_scanner_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  // Let's check the yr_scanner_scan_mem returns the appropriate error when\n  // called without specifying a callback.\n  result = yr_scanner_scan_mem(scanner1, (uint8_t *) buf, strlen(buf));\n\n  if (result != ERROR_CALLBACK_REQUIRED)\n  {\n    yr_scanner_destroy(scanner1);\n    yr_scanner_destroy(scanner2);\n    yr_rules_destroy(rules);\n    printf(\"expecting ERROR_CALLBACK_REQUIRED (%d), got: %d\\n\",\n           ERROR_CALLBACK_REQUIRED, result);\n    exit(EXIT_FAILURE);\n  }\n\n  // Set the callback and a some the correct values for the rule to match.\n  yr_scanner_set_callback(scanner1, count_matches, &matches);\n  yr_scanner_define_integer_variable(scanner1, \"int_var\", 1);\n  yr_scanner_define_boolean_variable(scanner1, \"bool_var\", 1);\n  yr_scanner_define_string_variable(scanner1, \"str_var\", \"foo\");\n\n  // Set some other values for the second scanner to make sure it doesn't\n  // interfere with the first one.\n  yr_scanner_define_integer_variable(scanner2, \"int_var\", 2);\n  yr_scanner_define_boolean_variable(scanner2, \"bool_var\", 0);\n  yr_scanner_define_string_variable(scanner2, \"str_var\", \"bar\");\n\n  result = yr_scanner_scan_mem(scanner1, (uint8_t *) buf, strlen(buf));\n\n  if (result != ERROR_SUCCESS)\n  {\n    yr_scanner_destroy(scanner1);\n    yr_scanner_destroy(scanner2);\n    yr_rules_destroy(rules);\n    printf(\"expecting ERROR_SUCCESS (%d), got: %d\\n\",\n           ERROR_SUCCESS, result);\n    exit(EXIT_FAILURE);\n  }\n\n  if (matches != 1)\n  {\n    yr_scanner_destroy(scanner1);\n    yr_scanner_destroy(scanner2);\n    yr_rules_destroy(rules);\n    exit(EXIT_FAILURE);\n  }\n\n  yr_scanner_destroy(scanner1);\n  yr_scanner_destroy(scanner2);\n  yr_rules_destroy(rules);\n  yr_finalize();\n}",
        "begin_line": 356,
        "end_line": 477,
        "is_bug": false
    },
    {
        "name": "tests.test-atoms.defects4cpp_test_index#4",
        "src_path": "tests/test-atoms.c",
        "class_name": "tests.test-atoms",
        "signature": "tests.test-atoms.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-atoms.main#661",
        "src_path": "tests/test-atoms.c",
        "class_name": "tests.test-atoms",
        "signature": "tests.test-atoms.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  yr_initialize();\n\n  test_table_quality();\n  test_heuristic_quality();\n  test_atom_choose();\n}",
        "begin_line": 661,
        "end_line": 668,
        "is_bug": false
    },
    {
        "name": "tests.test-atoms.test_atom_choose#277",
        "src_path": "tests/test-atoms.c",
        "class_name": "tests.test-atoms",
        "signature": "tests.test-atoms.test_atom_choose()",
        "snippet": "void test_atom_choose()\n{\n\n  struct atom atoms_61_XX_63_64[] = {\n      {4, {0x61, 0x00, 0x63, 0x64}},\n      {4, {0x61, 0x01, 0x63, 0x64}},\n      {4, {0x61, 0x02, 0x63, 0x64}},\n      {4, {0x61, 0x03, 0x63, 0x64}},\n      {4, {0x61, 0x04, 0x63, 0x64}},\n      {4, {0x61, 0x05, 0x63, 0x64}},\n      {4, {0x61, 0x06, 0x63, 0x64}},\n      {4, {0x61, 0x07, 0x63, 0x64}},\n      {4, {0x61, 0x08, 0x63, 0x64}},\n      {4, {0x61, 0x09, 0x63, 0x64}},\n      {4, {0x61, 0x0A, 0x63, 0x64}},\n      {4, {0x61, 0x0B, 0x63, 0x64}},\n      {4, {0x61, 0x0C, 0x63, 0x64}},\n      {4, {0x61, 0x0D, 0x63, 0x64}},\n      {4, {0x61, 0x0E, 0x63, 0x64}},\n      {4, {0x61, 0x0F, 0x63, 0x64}},\n      {4, {0x61, 0x10, 0x63, 0x64}},\n      {4, {0x61, 0x11, 0x63, 0x64}},\n      {4, {0x61, 0x12, 0x63, 0x64}},\n      {4, {0x61, 0x13, 0x63, 0x64}},\n      {4, {0x61, 0x14, 0x63, 0x64}},\n      {4, {0x61, 0x15, 0x63, 0x64}},\n      {4, {0x61, 0x16, 0x63, 0x64}},\n      {4, {0x61, 0x17, 0x63, 0x64}},\n      {4, {0x61, 0x18, 0x63, 0x64}},\n      {4, {0x61, 0x19, 0x63, 0x64}},\n      {4, {0x61, 0x1A, 0x63, 0x64}},\n      {4, {0x61, 0x1B, 0x63, 0x64}},\n      {4, {0x61, 0x1C, 0x63, 0x64}},\n      {4, {0x61, 0x1D, 0x63, 0x64}},\n      {4, {0x61, 0x1E, 0x63, 0x64}},\n      {4, {0x61, 0x1F, 0x63, 0x64}},\n      {4, {0x61, 0x20, 0x63, 0x64}},\n      {4, {0x61, 0x21, 0x63, 0x64}},\n      {4, {0x61, 0x22, 0x63, 0x64}},\n      {4, {0x61, 0x23, 0x63, 0x64}},\n      {4, {0x61, 0x24, 0x63, 0x64}},\n      {4, {0x61, 0x25, 0x63, 0x64}},\n      {4, {0x61, 0x26, 0x63, 0x64}},\n      {4, {0x61, 0x27, 0x63, 0x64}},\n      {4, {0x61, 0x28, 0x63, 0x64}},\n      {4, {0x61, 0x29, 0x63, 0x64}},\n      {4, {0x61, 0x2A, 0x63, 0x64}},\n      {4, {0x61, 0x2B, 0x63, 0x64}},\n      {4, {0x61, 0x2C, 0x63, 0x64}},\n      {4, {0x61, 0x2D, 0x63, 0x64}},\n      {4, {0x61, 0x2E, 0x63, 0x64}},\n      {4, {0x61, 0x2F, 0x63, 0x64}},\n      {4, {0x61, 0x30, 0x63, 0x64}},\n      {4, {0x61, 0x31, 0x63, 0x64}},\n      {4, {0x61, 0x32, 0x63, 0x64}},\n      {4, {0x61, 0x33, 0x63, 0x64}},\n      {4, {0x61, 0x34, 0x63, 0x64}},\n      {4, {0x61, 0x35, 0x63, 0x64}},\n      {4, {0x61, 0x36, 0x63, 0x64}},\n      {4, {0x61, 0x37, 0x63, 0x64}},\n      {4, {0x61, 0x38, 0x63, 0x64}},\n      {4, {0x61, 0x39, 0x63, 0x64}},\n      {4, {0x61, 0x3A, 0x63, 0x64}},\n      {4, {0x61, 0x3B, 0x63, 0x64}},\n      {4, {0x61, 0x3C, 0x63, 0x64}},\n      {4, {0x61, 0x3D, 0x63, 0x64}},\n      {4, {0x61, 0x3E, 0x63, 0x64}},\n      {4, {0x61, 0x3F, 0x63, 0x64}},\n      {4, {0x61, 0x40, 0x63, 0x64}},\n      {4, {0x61, 0x41, 0x63, 0x64}},\n      {4, {0x61, 0x42, 0x63, 0x64}},\n      {4, {0x61, 0x43, 0x63, 0x64}},\n      {4, {0x61, 0x44, 0x63, 0x64}},\n      {4, {0x61, 0x45, 0x63, 0x64}},\n      {4, {0x61, 0x46, 0x63, 0x64}},\n      {4, {0x61, 0x47, 0x63, 0x64}},\n      {4, {0x61, 0x48, 0x63, 0x64}},\n      {4, {0x61, 0x49, 0x63, 0x64}},\n      {4, {0x61, 0x4A, 0x63, 0x64}},\n      {4, {0x61, 0x4B, 0x63, 0x64}},\n      {4, {0x61, 0x4C, 0x63, 0x64}},\n      {4, {0x61, 0x4D, 0x63, 0x64}},\n      {4, {0x61, 0x4E, 0x63, 0x64}},\n      {4, {0x61, 0x4F, 0x63, 0x64}},\n      {4, {0x61, 0x50, 0x63, 0x64}},\n      {4, {0x61, 0x51, 0x63, 0x64}},\n      {4, {0x61, 0x52, 0x63, 0x64}},\n      {4, {0x61, 0x53, 0x63, 0x64}},\n      {4, {0x61, 0x54, 0x63, 0x64}},\n      {4, {0x61, 0x55, 0x63, 0x64}},\n      {4, {0x61, 0x56, 0x63, 0x64}},\n      {4, {0x61, 0x57, 0x63, 0x64}},\n      {4, {0x61, 0x58, 0x63, 0x64}},\n      {4, {0x61, 0x59, 0x63, 0x64}},\n      {4, {0x61, 0x5A, 0x63, 0x64}},\n      {4, {0x61, 0x5B, 0x63, 0x64}},\n      {4, {0x61, 0x5C, 0x63, 0x64}},\n      {4, {0x61, 0x5D, 0x63, 0x64}},\n      {4, {0x61, 0x5E, 0x63, 0x64}},\n      {4, {0x61, 0x5F, 0x63, 0x64}},\n      {4, {0x61, 0x60, 0x63, 0x64}},\n      {4, {0x61, 0x61, 0x63, 0x64}},\n      {4, {0x61, 0x62, 0x63, 0x64}},\n      {4, {0x61, 0x63, 0x63, 0x64}},\n      {4, {0x61, 0x64, 0x63, 0x64}},\n      {4, {0x61, 0x65, 0x63, 0x64}},\n      {4, {0x61, 0x66, 0x63, 0x64}},\n      {4, {0x61, 0x67, 0x63, 0x64}},\n      {4, {0x61, 0x68, 0x63, 0x64}},\n      {4, {0x61, 0x69, 0x63, 0x64}},\n      {4, {0x61, 0x6A, 0x63, 0x64}},\n      {4, {0x61, 0x6B, 0x63, 0x64}},\n      {4, {0x61, 0x6C, 0x63, 0x64}},\n      {4, {0x61, 0x6D, 0x63, 0x64}},\n      {4, {0x61, 0x6E, 0x63, 0x64}},\n      {4, {0x61, 0x6F, 0x63, 0x64}},\n      {4, {0x61, 0x70, 0x63, 0x64}},\n      {4, {0x61, 0x71, 0x63, 0x64}},\n      {4, {0x61, 0x72, 0x63, 0x64}},\n      {4, {0x61, 0x73, 0x63, 0x64}},\n      {4, {0x61, 0x74, 0x63, 0x64}},\n      {4, {0x61, 0x75, 0x63, 0x64}},\n      {4, {0x61, 0x76, 0x63, 0x64}},\n      {4, {0x61, 0x77, 0x63, 0x64}},\n      {4, {0x61, 0x78, 0x63, 0x64}},\n      {4, {0x61, 0x79, 0x63, 0x64}},\n      {4, {0x61, 0x7A, 0x63, 0x64}},\n      {4, {0x61, 0x7B, 0x63, 0x64}},\n      {4, {0x61, 0x7C, 0x63, 0x64}},\n      {4, {0x61, 0x7D, 0x63, 0x64}},\n      {4, {0x61, 0x7E, 0x63, 0x64}},\n      {4, {0x61, 0x7F, 0x63, 0x64}},\n      {4, {0x61, 0x80, 0x63, 0x64}},\n      {4, {0x61, 0x81, 0x63, 0x64}},\n      {4, {0x61, 0x82, 0x63, 0x64}},\n      {4, {0x61, 0x83, 0x63, 0x64}},\n      {4, {0x61, 0x84, 0x63, 0x64}},\n      {4, {0x61, 0x85, 0x63, 0x64}},\n      {4, {0x61, 0x86, 0x63, 0x64}},\n      {4, {0x61, 0x87, 0x63, 0x64}},\n      {4, {0x61, 0x88, 0x63, 0x64}},\n      {4, {0x61, 0x89, 0x63, 0x64}},\n      {4, {0x61, 0x8A, 0x63, 0x64}},\n      {4, {0x61, 0x8B, 0x63, 0x64}},\n      {4, {0x61, 0x8C, 0x63, 0x64}},\n      {4, {0x61, 0x8D, 0x63, 0x64}},\n      {4, {0x61, 0x8E, 0x63, 0x64}},\n      {4, {0x61, 0x8F, 0x63, 0x64}},\n      {4, {0x61, 0x90, 0x63, 0x64}},\n      {4, {0x61, 0x91, 0x63, 0x64}},\n      {4, {0x61, 0x92, 0x63, 0x64}},\n      {4, {0x61, 0x93, 0x63, 0x64}},\n      {4, {0x61, 0x94, 0x63, 0x64}},\n      {4, {0x61, 0x95, 0x63, 0x64}},\n      {4, {0x61, 0x96, 0x63, 0x64}},\n      {4, {0x61, 0x97, 0x63, 0x64}},\n      {4, {0x61, 0x98, 0x63, 0x64}},\n      {4, {0x61, 0x99, 0x63, 0x64}},\n      {4, {0x61, 0x9A, 0x63, 0x64}},\n      {4, {0x61, 0x9B, 0x63, 0x64}},\n      {4, {0x61, 0x9C, 0x63, 0x64}},\n      {4, {0x61, 0x9D, 0x63, 0x64}},\n      {4, {0x61, 0x9E, 0x63, 0x64}},\n      {4, {0x61, 0x9F, 0x63, 0x64}},\n      {4, {0x61, 0xA0, 0x63, 0x64}},\n      {4, {0x61, 0xA1, 0x63, 0x64}},\n      {4, {0x61, 0xA2, 0x63, 0x64}},\n      {4, {0x61, 0xA3, 0x63, 0x64}},\n      {4, {0x61, 0xA4, 0x63, 0x64}},\n      {4, {0x61, 0xA5, 0x63, 0x64}},\n      {4, {0x61, 0xA6, 0x63, 0x64}},\n      {4, {0x61, 0xA7, 0x63, 0x64}},\n      {4, {0x61, 0xA8, 0x63, 0x64}},\n      {4, {0x61, 0xA9, 0x63, 0x64}},\n      {4, {0x61, 0xAA, 0x63, 0x64}},\n      {4, {0x61, 0xAB, 0x63, 0x64}},\n      {4, {0x61, 0xAC, 0x63, 0x64}},\n      {4, {0x61, 0xAD, 0x63, 0x64}},\n      {4, {0x61, 0xAE, 0x63, 0x64}},\n      {4, {0x61, 0xAF, 0x63, 0x64}},\n      {4, {0x61, 0xB0, 0x63, 0x64}},\n      {4, {0x61, 0xB1, 0x63, 0x64}},\n      {4, {0x61, 0xB2, 0x63, 0x64}},\n      {4, {0x61, 0xB3, 0x63, 0x64}},\n      {4, {0x61, 0xB4, 0x63, 0x64}},\n      {4, {0x61, 0xB5, 0x63, 0x64}},\n      {4, {0x61, 0xB6, 0x63, 0x64}},\n      {4, {0x61, 0xB7, 0x63, 0x64}},\n      {4, {0x61, 0xB8, 0x63, 0x64}},\n      {4, {0x61, 0xB9, 0x63, 0x64}},\n      {4, {0x61, 0xBA, 0x63, 0x64}},\n      {4, {0x61, 0xBB, 0x63, 0x64}},\n      {4, {0x61, 0xBC, 0x63, 0x64}},\n      {4, {0x61, 0xBD, 0x63, 0x64}},\n      {4, {0x61, 0xBE, 0x63, 0x64}},\n      {4, {0x61, 0xBF, 0x63, 0x64}},\n      {4, {0x61, 0xC0, 0x63, 0x64}},\n      {4, {0x61, 0xC1, 0x63, 0x64}},\n      {4, {0x61, 0xC2, 0x63, 0x64}},\n      {4, {0x61, 0xC3, 0x63, 0x64}},\n      {4, {0x61, 0xC4, 0x63, 0x64}},\n      {4, {0x61, 0xC5, 0x63, 0x64}},\n      {4, {0x61, 0xC6, 0x63, 0x64}},\n      {4, {0x61, 0xC7, 0x63, 0x64}},\n      {4, {0x61, 0xC8, 0x63, 0x64}},\n      {4, {0x61, 0xC9, 0x63, 0x64}},\n      {4, {0x61, 0xCA, 0x63, 0x64}},\n      {4, {0x61, 0xCB, 0x63, 0x64}},\n      {4, {0x61, 0xCC, 0x63, 0x64}},\n      {4, {0x61, 0xCD, 0x63, 0x64}},\n      {4, {0x61, 0xCE, 0x63, 0x64}},\n      {4, {0x61, 0xCF, 0x63, 0x64}},\n      {4, {0x61, 0xD0, 0x63, 0x64}},\n      {4, {0x61, 0xD1, 0x63, 0x64}},\n      {4, {0x61, 0xD2, 0x63, 0x64}},\n      {4, {0x61, 0xD3, 0x63, 0x64}},\n      {4, {0x61, 0xD4, 0x63, 0x64}},\n      {4, {0x61, 0xD5, 0x63, 0x64}},\n      {4, {0x61, 0xD6, 0x63, 0x64}},\n      {4, {0x61, 0xD7, 0x63, 0x64}},\n      {4, {0x61, 0xD8, 0x63, 0x64}},\n      {4, {0x61, 0xD9, 0x63, 0x64}},\n      {4, {0x61, 0xDA, 0x63, 0x64}},\n      {4, {0x61, 0xDB, 0x63, 0x64}},\n      {4, {0x61, 0xDC, 0x63, 0x64}},\n      {4, {0x61, 0xDD, 0x63, 0x64}},\n      {4, {0x61, 0xDE, 0x63, 0x64}},\n      {4, {0x61, 0xDF, 0x63, 0x64}},\n      {4, {0x61, 0xE0, 0x63, 0x64}},\n      {4, {0x61, 0xE1, 0x63, 0x64}},\n      {4, {0x61, 0xE2, 0x63, 0x64}},\n      {4, {0x61, 0xE3, 0x63, 0x64}},\n      {4, {0x61, 0xE4, 0x63, 0x64}},\n      {4, {0x61, 0xE5, 0x63, 0x64}},\n      {4, {0x61, 0xE6, 0x63, 0x64}},\n      {4, {0x61, 0xE7, 0x63, 0x64}},\n      {4, {0x61, 0xE8, 0x63, 0x64}},\n      {4, {0x61, 0xE9, 0x63, 0x64}},\n      {4, {0x61, 0xEA, 0x63, 0x64}},\n      {4, {0x61, 0xEB, 0x63, 0x64}},\n      {4, {0x61, 0xEC, 0x63, 0x64}},\n      {4, {0x61, 0xED, 0x63, 0x64}},\n      {4, {0x61, 0xEE, 0x63, 0x64}},\n      {4, {0x61, 0xEF, 0x63, 0x64}},\n      {4, {0x61, 0xF0, 0x63, 0x64}},\n      {4, {0x61, 0xF1, 0x63, 0x64}},\n      {4, {0x61, 0xF2, 0x63, 0x64}},\n      {4, {0x61, 0xF3, 0x63, 0x64}},\n      {4, {0x61, 0xF4, 0x63, 0x64}},\n      {4, {0x61, 0xF5, 0x63, 0x64}},\n      {4, {0x61, 0xF6, 0x63, 0x64}},\n      {4, {0x61, 0xF7, 0x63, 0x64}},\n      {4, {0x61, 0xF8, 0x63, 0x64}},\n      {4, {0x61, 0xF9, 0x63, 0x64}},\n      {4, {0x61, 0xFA, 0x63, 0x64}},\n      {4, {0x61, 0xFB, 0x63, 0x64}},\n      {4, {0x61, 0xFC, 0x63, 0x64}},\n      {4, {0x61, 0xFD, 0x63, 0x64}},\n      {4, {0x61, 0xFE, 0x63, 0x64}},\n      {4, {0x61, 0xFF, 0x63, 0x64}},\n    };\n\n    struct atom atoms_61_62_0X_64[] = {\n      {4, {0x61, 0x62, 0x00, 0x64}},\n      {4, {0x61, 0x62, 0x01, 0x64}},\n      {4, {0x61, 0x62, 0x02, 0x64}},\n      {4, {0x61, 0x62, 0x03, 0x64}},\n      {4, {0x61, 0x62, 0x04, 0x64}},\n      {4, {0x61, 0x62, 0x05, 0x64}},\n      {4, {0x61, 0x62, 0x06, 0x64}},\n      {4, {0x61, 0x62, 0x07, 0x64}},\n      {4, {0x61, 0x62, 0x08, 0x64}},\n      {4, {0x61, 0x62, 0x09, 0x64}},\n      {4, {0x61, 0x62, 0x0A, 0x64}},\n      {4, {0x61, 0x62, 0x0B, 0x64}},\n      {4, {0x61, 0x62, 0x0C, 0x64}},\n      {4, {0x61, 0x62, 0x0D, 0x64}},\n      {4, {0x61, 0x62, 0x0E, 0x64}},\n      {4, {0x61, 0x62, 0x0F, 0x64}},\n    };\n\n    struct atom atoms_61_6X_63[] = {\n      {3, {0x61, 0x60, 0x63}},\n      {3, {0x61, 0x61, 0x63}},\n      {3, {0x61, 0x62, 0x63}},\n      {3, {0x61, 0x63, 0x63}},\n      {3, {0x61, 0x64, 0x63}},\n      {3, {0x61, 0x65, 0x63}},\n      {3, {0x61, 0x66, 0x63}},\n      {3, {0x61, 0x67, 0x63}},\n      {3, {0x61, 0x68, 0x63}},\n      {3, {0x61, 0x69, 0x63}},\n      {3, {0x61, 0x6A, 0x63}},\n      {3, {0x61, 0x6B, 0x63}},\n      {3, {0x61, 0x6C, 0x63}},\n      {3, {0x61, 0x6D, 0x63}},\n      {3, {0x61, 0x6E, 0x63}},\n      {3, {0x61, 0x6F, 0x63}},\n    };\n\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 86:\n    assert_re_atoms(\"abcd\", 1, (struct atom[]) {\n      {4, {0x61, 0x62, 0x63, 0x64}},\n    });\n          break;\n      case 87:\n    assert_re_atoms(\"abcd1234\", 1, (struct atom[]) {\n      {4, {0x31, 0x32, 0x33, 0x34}},\n    });\n          break;\n      case 88:\n    assert_re_atoms(\"a..d\", 1, (struct atom[]) {\n      {1, {0x61}},\n    });\n          break;\n      case 89:\n    assert_re_atoms(\"a..de\", 1, (struct atom[]) {\n      {2, {0x64, 0x65}},\n    });\n          break;\n      case 90:\n    assert_re_atoms(\"abcd.efgh\", 1, (struct atom[]) {\n      {4, {0x61, 0x62, 0x63, 0x64}},\n    });\n          break;\n      case 91:\n    assert_re_atoms(\"(abcd|efgh)\", 2, (struct atom[]) {\n      {4, {0x65, 0x66, 0x67, 0x68}},\n      {4, {0x61, 0x62, 0x63, 0x64}},\n    });\n          break;\n      case 92:\n    assert_re_atoms(\"(abcd|efgh|ij)\", 3, (struct atom[]) {\n      {2, {0x69, 0x6A}},\n      {4, {0x65, 0x66, 0x67, 0x68}},\n      {4, {0x61, 0x62, 0x63, 0x64}},\n    });\n          break;\n      case 93:\n    assert_re_atoms(\"a.cd\", 256, atoms_61_XX_63_64);\n          break;\n      case 94:\n    assert_hex_atoms(\"{61 62 63 64}\", 1, (struct atom[]) {\n      {4, {0x61, 0x62, 0x63, 0x64}},\n    });\n          break;\n      case 95:\n    assert_hex_atoms(\"{61 62 63 64 [1-5] 65 66 67 68}\", 1, (struct atom[]) {\n      {4, {0x61, 0x62, 0x63, 0x64}},\n    });\n          break;\n      case 96:\n    assert_hex_atoms(\"{61 62 63 [1-5] 65 66 67 68}\", 1, (struct atom[]) {\n      {4, {0x65, 0x66, 0x67, 0x68}},\n    });\n          break;\n      case 97:\n    assert_hex_atoms(\"{61 62 63 [1-5] 65 66 }\", 1, (struct atom[]) {\n      {3, {0x61, 0x62, 0x63}},\n    });\n          break;\n      case 98:\n    assert_hex_atoms(\"{61 6? 63 [1-5] 65 66 }\", 16, atoms_61_6X_63);\n          break;\n      case 99:\n    assert_hex_atoms(\"{(61 62 63 | 65 66 67 68)}\", 2, (struct atom[]) {\n      {4, {0x65, 0x66, 0x67, 0x68}},\n      {3, {0x61, 0x62, 0x63}},\n    });\n          break;\n      case 100:\n    assert_hex_atoms(\"{61 62 0? 64}\", 16, atoms_61_62_0X_64);\n          break;\n      case 101:\n    assert_hex_atoms(\"{11 ?? 11 ?? 22 33 44 55 66 }\", 1, (struct atom[]) {\n      {4, {0x22, 0x33, 0x44, 0x55}},\n    });\n          break;\n  }\n}",
        "begin_line": 277,
        "end_line": 658,
        "is_bug": false
    },
    {
        "name": "tests.test-atoms.test_heuristic_quality#105",
        "src_path": "tests/test-atoms.c",
        "class_name": "tests.test-atoms",
        "signature": "tests.test-atoms.test_heuristic_quality()",
        "snippet": "void test_heuristic_quality()\n{\n  YR_ATOMS_CONFIG c;\n\n  YR_ATOM a00000000 = {\n    .length = 4,\n    .bytes = {0x00, 0x00, 0x00, 0x00},\n    .mask = {0xFF, 0xFF, 0xFF, 0xFF}};\n\n  YR_ATOM a00000001 = {\n    .length = 4,\n    .bytes = {0x00, 0x00, 0x00, 0x01},\n    .mask = {0xFF, 0xFF, 0xFF, 0xFF}};\n\n  YR_ATOM a00000102 = {\n    .length = 4,\n    .bytes = {0x00, 0x00, 0x01, 0x02},\n    .mask = {0xFF, 0xFF, 0xFF, 0xFF}};\n\n  YR_ATOM a00010203 = {\n    .length = 4,\n    .bytes = {0x00, 0x01, 0x02, 0x03},\n    .mask = {0xFF, 0xFF, 0xFF, 0xFF}};\n\n  YR_ATOM a01020304 = {\n    .length = 4,\n    .bytes = {0x01, 0x02, 0x03, 0x04},\n    .mask = {0xFF, 0xFF, 0xFF, 0xFF}};\n\n  YR_ATOM a01 = {\n    .length = 1,\n    .bytes = {0x01},\n    .mask = {0xFF}};\n\n  YR_ATOM a0001 = {\n    .length = 2,\n    .bytes = {0x00, 0x01},\n    .mask = {0xFF, 0xFF}};\n\n  YR_ATOM a000001 = {\n    .length = 3,\n    .bytes = {0x00, 0x00, 0x01},\n    .mask = {0xFF, 0xFF, 0xFF}};\n\n  YR_ATOM a000102 = {\n    .length = 3,\n    .bytes = {0x00, 0x01, 0x02},\n    .mask = {0xFF, 0xFF, 0xFF}};\n\n  YR_ATOM a010203 = {\n    .length = 3,\n    .bytes = {0x01, 0x02, 0x03},\n    .mask = {0xFF, 0xFF, 0xFF}};\n\n  YR_ATOM a0102 = {\n    .length = 2,\n    .bytes = {0x01, 0x02},\n    .mask = {0xFF, 0xFF}};\n\n  YR_ATOM a01020000 = {\n    .length = 4,\n    .bytes = {0x01, 0x02, 0x00, 0x00},\n    .mask = {0xFF, 0xFF, 0xFF, 0xFF}};\n\n  YR_ATOM a0102XX04 = {\n    .length = 4,\n    .bytes = {0x01, 0x02, 0x03, 0x04},\n    .mask = {0xFF, 0xFF, 0x00, 0xFF}};\n\n  c.get_atom_quality = yr_atoms_heuristic_quality;\n\n  int q00000000 = yr_atoms_heuristic_quality(&c, &a00000000);\n  int q00000001 = yr_atoms_heuristic_quality(&c, &a00000001);\n  int q00000102 = yr_atoms_heuristic_quality(&c, &a00000102);\n  int q00010203 = yr_atoms_heuristic_quality(&c, &a00010203);\n  int q01020304 = yr_atoms_heuristic_quality(&c, &a01020304);\n  int q010203   = yr_atoms_heuristic_quality(&c, &a010203);\n  int q0102     = yr_atoms_heuristic_quality(&c, &a0102);\n  int q01       = yr_atoms_heuristic_quality(&c, &a01);\n  int q0001     = yr_atoms_heuristic_quality(&c, &a0001);\n  int q000001   = yr_atoms_heuristic_quality(&c, &a000001);\n  int q000102   = yr_atoms_heuristic_quality(&c, &a000102);\n  int q01020000 = yr_atoms_heuristic_quality(&c, &a01020000);\n  int q0102XX04 = yr_atoms_heuristic_quality(&c, &a0102XX04);\n\n\n  a010203.mask[1] = 0x00;\n\n  int q01XX03   = yr_atoms_heuristic_quality(&c, &a010203);\n\n  a010203.mask[1] = 0x0F;\n\n  int q01X203   = yr_atoms_heuristic_quality(&c, &a010203);\n\n  a010203.mask[1] = 0x0F;\n\n  int q010X03   = yr_atoms_heuristic_quality(&c, &a010203);\n\n  a010203.mask[2] = 0x0F;\n\n  int q010X0X   = yr_atoms_heuristic_quality(&c, &a010203);\n\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 65:\n  assert_true_expr(q00000001 > q00000000);\n          break;\n      case 66:\n  assert_true_expr(q00000001 > q000001);\n          break;\n      case 67:\n  assert_true_expr(q000001   > q0001);\n          break;\n      case 68:\n  assert_true_expr(q00000102 > q00000001);\n          break;\n      case 69:\n  assert_true_expr(q00010203 > q00000102);\n          break;\n      case 70:\n  assert_true_expr(q01020304 > q00010203);\n          break;\n      case 71:\n  assert_true_expr(q000102   > q000001);\n          break;\n      case 72:\n  assert_true_expr(q00010203 > q010203);\n          break;\n      case 73:\n  assert_true_expr(q010203   > q0102);\n          break;\n      case 74:\n  assert_true_expr(q0102     > q01);\n          break;\n      case 75:\n  assert_true_expr(q01X203   > q0102);\n          break;\n      case 76:\n  assert_true_expr(q01X203   > q0001);\n          break;\n      case 77:\n  assert_true_expr(q01X203   < q010203);\n          break;\n      case 78:\n  assert_true_expr(q01X203   == q010X03);\n          break;\n      case 79:\n  assert_true_expr(q01XX03   <= q0102);\n          break;\n      case 80:\n  assert_true_expr(q01XX03   < q010X03);\n          break;\n      case 81:\n  assert_true_expr(q01XX03   < q010203);\n          break;\n      case 82:\n  assert_true_expr(q010X0X   > q01);\n          break;\n      case 83:\n  assert_true_expr(q010X0X   < q010203);\n          break;\n      case 84:\n  assert_true_expr(q01020000 > q0102XX04);\n          break;\n      case 85:\n  assert_true_expr(q01020304 == YR_MAX_ATOM_QUALITY);\n          break;\n  }\n}",
        "begin_line": 105,
        "end_line": 273,
        "is_bug": false
    },
    {
        "name": "tests.test-atoms.test_table_quality#35",
        "src_path": "tests/test-atoms.c",
        "class_name": "tests.test-atoms",
        "signature": "tests.test-atoms.test_table_quality()",
        "snippet": "void test_table_quality()\n{\n  YR_ATOM_QUALITY_TABLE_ENTRY l1[] = {\n    {{0x00, 0x00, 0x00, 0x00}, 1},\n    {{0x00, 0x00, 0x00, 0x01}, 2},\n    {{0x00, 0x00, 0x00, 0x02}, 3},\n  };\n\n  YR_ATOM_QUALITY_TABLE_ENTRY l2[] = {\n    {{0x00, 0x00, 0x00, 0x00}, 1},\n    {{0x00, 0x00, 0x00, 0x01}, 2},\n    {{0x00, 0x00, 0x00, 0x02}, 3},\n    {{0x00, 0x00, 0x00, 0x03}, 4},\n  };\n\n  YR_ATOM a0 = {\n    .length = 4,\n    .bytes = {0x00, 0x00, 0x00, 0x00},\n    .mask = {0xFF, 0xFF, 0xFF, 0xFF}};\n\n  YR_ATOM a1 = {4, {0x00, 0x00, 0x00, 0x01}, {0xFF, 0xFF, 0xFF, 0xFF}};\n  YR_ATOM a2 = {4, {0x00, 0x00, 0x00, 0x02}, {0xFF, 0xFF, 0xFF, 0xFF}};\n  YR_ATOM a3 = {4, {0x00, 0x00, 0x00, 0x03}, {0xFF, 0xFF, 0xFF, 0xFF}};\n  YR_ATOM a4 = {4, {0x00, 0x00, 0x00, 0x00}, {0xFF, 0xFF, 0xFF, 0x00}};\n\n  YR_ATOMS_CONFIG c;\n\n  c.get_atom_quality = yr_atoms_table_quality;\n  c.quality_table = l1;\n  c.quality_table_entries = 3;\n\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 56:\n  assert_true_expr(yr_atoms_table_quality(&c, &a0) == 1);\n          break;\n      case 57:\n  assert_true_expr(yr_atoms_table_quality(&c, &a1) == 2);\n          break;\n      case 58:\n  assert_true_expr(yr_atoms_table_quality(&c, &a2) == 3);\n          break;\n      case 59:\n  assert_true_expr(yr_atoms_table_quality(&c, &a3) == YR_MAX_ATOM_QUALITY);\n          break;\n  }\n\n  c.quality_table = l2;\n  c.quality_table_entries = 4;\n\n  switch (index) {\n      case 60:\n  assert_true_expr(yr_atoms_table_quality(&c, &a0) == 1);\n          break;\n      case 61:\n  assert_true_expr(yr_atoms_table_quality(&c, &a1) == 2);\n          break;\n      case 62:\n  assert_true_expr(yr_atoms_table_quality(&c, &a2) == 3);\n          break;\n      case 63:\n  assert_true_expr(yr_atoms_table_quality(&c, &a3) == 4);\n          break;\n      case 64:\n  assert_true_expr(yr_atoms_table_quality(&c, &a4) == 1);\n          break;\n  }\n}",
        "begin_line": 35,
        "end_line": 102,
        "is_bug": false
    },
    {
        "name": "tests.test-bitmask.assert_clear_all#39",
        "src_path": "tests/test-bitmask.c",
        "class_name": "tests.test-bitmask",
        "signature": "tests.test-bitmask.assert_clear_all(YR_BITMASK* bitmask)",
        "snippet": "void assert_clear_all(YR_BITMASK* bitmask)\n{\n  for (int i = 0; i < BITMAP_SIZE; i++)\n  {\n    if (yr_bitmask_isset(bitmask, i))\n    {\n      fprintf(stderr, \"bit %d is set and should not\\n\", i);\n      exit(EXIT_FAILURE);\n    }\n  }\n}",
        "begin_line": 39,
        "end_line": 49,
        "is_bug": false
    },
    {
        "name": "tests.test-bitmask.defects4cpp_test_index#4",
        "src_path": "tests/test-bitmask.c",
        "class_name": "tests.test-bitmask",
        "signature": "tests.test-bitmask.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-bitmask.main#234",
        "src_path": "tests/test-bitmask.c",
        "class_name": "tests.test-bitmask",
        "signature": "tests.test-bitmask.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 102:\n  test_set_clear();\n          break;\n      case 103:\n  test_find_non_colliding_offsets_1();\n          break;\n      case 104:\n  test_find_non_colliding_offsets_2();\n          break;\n  }\n}",
        "begin_line": 234,
        "end_line": 248,
        "is_bug": false
    },
    {
        "name": "tests.test-bitmask.test_find_non_colliding_offsets_1#116",
        "src_path": "tests/test-bitmask.c",
        "class_name": "tests.test-bitmask",
        "signature": "tests.test-bitmask.test_find_non_colliding_offsets_1()",
        "snippet": "void test_find_non_colliding_offsets_1()\n{\n  uint32_t o = 0;\n\n  YR_BITMASK a[YR_BITMASK_SIZE(18)];\n  YR_BITMASK b[YR_BITMASK_SIZE(13)];\n\n  yr_bitmask_clear_all(a);\n  yr_bitmask_clear_all(b);\n\n  // Set odd bits in B and odd bits in A.\n  for (int i = 0; i < 13; i++)\n  {\n    if (i % 2 == 0)\n      yr_bitmask_set(b, i);\n    else\n      yr_bitmask_set(a, i);\n  }\n\n  // Bitmask A can accommodate B at offset 0.\n  if (yr_bitmask_find_non_colliding_offset(a, b, 18, 13, &o) != 0)\n    exit(EXIT_FAILURE);\n\n  yr_bitmask_clear_all(a);\n  yr_bitmask_clear_all(b);\n\n  // Set the following pattern in A:\n  // 1 0 1 0   0 0 0 1   0 0 0 0   0 0 1 1   0 0\n  yr_bitmask_set(a, 0);\n  yr_bitmask_set(a, 2);\n  yr_bitmask_set(a, 7);\n  yr_bitmask_set(a, 14);\n  yr_bitmask_set(a, 15);\n\n  // Set B to:\n  // 1 1 0 0   0 0 0 1   0 1 0 0  1\n  yr_bitmask_set(b, 0);\n  yr_bitmask_set(b, 1);\n  yr_bitmask_set(b, 7);\n  yr_bitmask_set(b, 9);\n  yr_bitmask_set(b, 12);\n\n  // Bitmask A can accommodate B at offset 4.\n  if (yr_bitmask_find_non_colliding_offset(a, b, 18, 13, &o) != 4)\n    exit(EXIT_FAILURE);\n\n\n  // Set the A to:\n  // 1 0 1 0   0 0 0 1   0 0 0 0   0 0 1 1   1 0\n  yr_bitmask_set(a, 16);\n\n  // Bitmask A can accommodate B at offset 10.\n  if (yr_bitmask_find_non_colliding_offset(a, b, 18, 13, &o) != 10)\n    exit(EXIT_FAILURE);\n\n\n  yr_bitmask_clear_all(a);\n  yr_bitmask_clear_all(b);\n\n  yr_bitmask_set(a, 0);\n  yr_bitmask_set(a, 3);\n\n  yr_bitmask_set(b, 0);\n  yr_bitmask_set(b, 1);\n  yr_bitmask_set(b, 3);\n\n  // Bitmask 1001 can accommodate 1101 at offset 2.\n  if (yr_bitmask_find_non_colliding_offset(a, b, 4, 4, &o) != 1)\n    exit(EXIT_FAILURE);\n\n  // Bitmask 1001 can accommodate 1001 at offset 1.\n  if (yr_bitmask_find_non_colliding_offset(a, a, 4, 4, &o) != 1)\n    exit(EXIT_FAILURE);\n\n  yr_bitmask_clear(a, 0);\n\n  // Bitmask 0001 can accommodate 1101 at offset 0.\n  if (yr_bitmask_find_non_colliding_offset(a, b, 4, 4, &o) != 1)\n    exit(EXIT_FAILURE);\n}",
        "begin_line": 116,
        "end_line": 195,
        "is_bug": false
    },
    {
        "name": "tests.test-bitmask.test_find_non_colliding_offsets_2#198",
        "src_path": "tests/test-bitmask.c",
        "class_name": "tests.test-bitmask",
        "signature": "tests.test-bitmask.test_find_non_colliding_offsets_2()",
        "snippet": "void test_find_non_colliding_offsets_2()\n{\n  uint32_t o = 0;\n\n  YR_BITMASK a[YR_BITMASK_SIZE(140)];\n  YR_BITMASK b[YR_BITMASK_SIZE(200)];\n\n  yr_bitmask_clear_all(a);\n  yr_bitmask_clear_all(b);\n\n  // Set odds bits in A and even bits in B.\n  for (int i = 0; i < 13; i++)\n  {\n    if (i % 2 == 0)\n      yr_bitmask_set(b, i);\n    else\n      yr_bitmask_set(a, i);\n  }\n\n  // Bitmask A can accommodate B at offset 0.\n  if (yr_bitmask_find_non_colliding_offset(a, b, 200, 140, &o) != 0)\n    exit(EXIT_FAILURE);\n\n  yr_bitmask_clear_all(a);\n  yr_bitmask_clear_all(b);\n\n  yr_bitmask_set(a, 130);\n\n  yr_bitmask_set(b, 0);\n  yr_bitmask_set(b, 130);\n\n  if (yr_bitmask_find_non_colliding_offset(a, b, 200, 140, &o) != 1)\n    exit(EXIT_FAILURE);\n}",
        "begin_line": 198,
        "end_line": 231,
        "is_bug": false
    },
    {
        "name": "tests.test-bitmask.test_set_clear#51",
        "src_path": "tests/test-bitmask.c",
        "class_name": "tests.test-bitmask",
        "signature": "tests.test-bitmask.test_set_clear()",
        "snippet": "void test_set_clear()\n{\n  YR_BITMASK bitmask[YR_BITMASK_SIZE(BITMAP_SIZE)];\n\n  yr_bitmask_clear_all(bitmask);\n\n  assert_clear_all(bitmask);\n\n  yr_bitmask_set(bitmask, 0);\n\n  if (!yr_bitmask_isset(bitmask, 0))\n    exit(EXIT_FAILURE);\n\n  yr_bitmask_clear(bitmask, 0);\n\n  if (yr_bitmask_isset(bitmask, 0))\n    exit(EXIT_FAILURE);\n\n  yr_bitmask_set(bitmask, BITMAP_SIZE-1);\n\n  if (!yr_bitmask_isset(bitmask, BITMAP_SIZE-1))\n    exit(EXIT_FAILURE);\n\n  yr_bitmask_clear(bitmask, BITMAP_SIZE-1);\n\n  if (yr_bitmask_isset(bitmask, BITMAP_SIZE-1))\n    exit(EXIT_FAILURE);\n\n  yr_bitmask_set(bitmask, 31);\n  yr_bitmask_set(bitmask, 32);\n  yr_bitmask_set(bitmask, 33);\n  yr_bitmask_set(bitmask, 63);\n  yr_bitmask_set(bitmask, 64);\n  yr_bitmask_set(bitmask, 65);\n\n  if (!yr_bitmask_isset(bitmask, 31))\n    exit(EXIT_FAILURE);\n\n  if (!yr_bitmask_isset(bitmask, 32))\n    exit(EXIT_FAILURE);\n\n  if (!yr_bitmask_isset(bitmask, 33))\n    exit(EXIT_FAILURE);\n\n  if (!yr_bitmask_isset(bitmask, 63))\n    exit(EXIT_FAILURE);\n\n  if (!yr_bitmask_isset(bitmask, 64))\n    exit(EXIT_FAILURE);\n\n  if (!yr_bitmask_isset(bitmask, 65))\n    exit(EXIT_FAILURE);\n\n  yr_bitmask_clear(bitmask, 31);\n  yr_bitmask_clear(bitmask, 32);\n  yr_bitmask_clear(bitmask, 33);\n  yr_bitmask_clear(bitmask, 63);\n  yr_bitmask_clear(bitmask, 64);\n  yr_bitmask_clear(bitmask, 65);\n\n  assert_clear_all(bitmask);\n}",
        "begin_line": 51,
        "end_line": 112,
        "is_bug": false
    },
    {
        "name": "tests.test-dex.defects4cpp_test_index#4",
        "src_path": "tests/test-dex.c",
        "class_name": "tests.test-dex",
        "signature": "tests.test-dex.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-dex.main#6",
        "src_path": "tests/test-dex.c",
        "class_name": "tests.test-dex",
        "signature": "tests.test-dex.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  yr_initialize();\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 105:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.header.magic == \\\n        dex.DEX_FILE_MAGIC_035 }\",\n      DEX_FILE);\n          break;\n      case 106:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.header.checksum == \\\n        0x3F9C602F }\",\n      DEX_FILE);\n          break;\n      case 107:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.header.data_size == \\\n        0x18C }\",\n      DEX_FILE);\n          break;\n      case 108:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.string_ids[0].value ==\\\n      \\\"<clinit>\\\" }\",\n      DEX_FILE);\n          break;\n      case 109:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.string_ids[8].value == \\\n        \\\"com.google.helloyara\\\" }\",\n      DEX_FILE);\n          break;\n      case 110:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.type_ids[0].descriptor_idx == \\\n        0x2 }\",\n      DEX_FILE);\n          break;\n      case 111:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.proto_ids[0].shorty_idx == \\\n        0x6 }\",\n      DEX_FILE);\n          break;\n      case 112:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.field_ids[0].class_idx == \\\n        0x1 }\",\n      DEX_FILE);\n          break;\n      case 113:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.method_ids[0].class_idx == \\\n        0x1 }\",\n      DEX_FILE);\n          break;\n      case 114:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.class_defs[0].class_idx == \\\n        0x1 }\",\n      DEX_FILE);\n          break;\n      case 115:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.number_of_fields == 2 }\",\n      DEX_FILE);\n          break;\n      case 116:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.field[0].class_name == \\\n        \\\"Lcom/android/tools/ir/server/AppInfo;\\\" }\",\n      DEX_FILE);\n          break;\n      case 117:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.field[0].name == \\\n        \\\"applicationId\\\" }\",\n      DEX_FILE);\n          break;\n      case 118:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.number_of_methods == 2 }\",\n      DEX_FILE);\n          break;\n      case 119:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.method[0].class_name == \\\n        \\\"Lcom/android/tools/ir/server/AppInfo;\\\" }\",\n      DEX_FILE);\n          break;\n      case 120:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.method[0].proto == \\\"V\\\" }\",\n      DEX_FILE);\n          break;\n      case 121:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.method[0].name == \\\n        \\\"<clinit>\\\" }\",\n      DEX_FILE);\n          break;\n      case 122:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.method[1].name == \\\n        \\\"<init>\\\" }\",\n      DEX_FILE);\n          break;\n      case 123:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: dex.map_list.size == 12 }\",\n      DEX_FILE);\n          break;\n      case 124:\n  assert_true_rule_blob(\n      \"import \\\"dex\\\" rule test { condition: \\\n          dex.map_list.map_item[0].type == dex.TYPE_HEADER_ITEM \\\n        }\",\n      DEX_FILE);\n          break;\n  }\n\n  yr_finalize();\n}",
        "begin_line": 6,
        "end_line": 131,
        "is_bug": false
    },
    {
        "name": "tests.test-elf.defects4cpp_test_index#4",
        "src_path": "tests/test-elf.c",
        "class_name": "tests.test-elf",
        "signature": "tests.test-elf.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-elf.main#6",
        "src_path": "tests/test-elf.c",
        "class_name": "tests.test-elf",
        "signature": "tests.test-elf.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  yr_initialize();\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 125:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" rule test { condition: elf.type }\",\n      ELF32_FILE);\n          break;\n      case 126:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" rule test { condition: elf.type }\",\n      ELF64_FILE);\n          break;\n      case 127:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" rule test { condition: elf.machine == elf.EM_386 }\",\n      ELF32_FILE)\n          break;\n      case 128:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" rule test { condition: elf.machine == elf.EM_X86_64 }\",\n      ELF64_FILE)\n          break;\n      case 129:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        strings: $a = { b8 01 00 00 00 bb 2a } \\\n        condition: $a at elf.entry_point \\\n      }\",\n      ELF32_FILE);\n          break;\n      case 130:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        strings: $a = { b8 01 00 00 00 bb 2a } \\\n        condition: $a at elf.entry_point \\\n      }\",\n      ELF64_FILE);\n          break;\n      case 131:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" rule test { condition: elf.entry_point == 0xa0 }\",\n      ELF32_NOSECTIONS);\n          break;\n      case 132:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" rule test { condition: elf.entry_point == 0x1a0 }\",\n      ELF32_SHAREDOBJ);\n        break;\n      case 133:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: elf.sections[2].name == \\\".comment\\\" \\\n      }\",\n      ELF64_FILE);\n          break;\n      case 134:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: elf.machine == elf.EM_MIPS \\\n      }\",\n      ELF32_MIPS_FILE);\n          break;\n      case 135:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          elf.number_of_sections == 35 and elf.number_of_segments == 10 \\\n      }\",\n      ELF32_MIPS_FILE);\n          break;\n      case 136:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          for any i in (0..elf.number_of_sections): ( \\\n            elf.sections[i].type == elf.SHT_PROGBITS and  \\\n            elf.sections[i].address == 0x400600 and \\\n            elf.sections[i].name == \\\".text\\\") \\\n      }\",\n      ELF32_MIPS_FILE);\n          break;\n      case 137:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n        rule test { \\\n          condition: \\\n            for any i in (0..elf.number_of_segments): ( \\\n            elf.segments[i].type == elf.PT_LOAD and \\\n            elf.segments[i].virtual_address == 0x00400000 and \\\n            elf.segments[i].file_size == 0x95c)\\\n      }\",\n      ELF32_MIPS_FILE);\n          break;\n      case 138:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          elf.dynamic_section_entries == 19 and \\\n          elf.symtab_entries == 80 \\\n      }\",\n      ELF32_MIPS_FILE);\n          break;\n      case 139:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          for any i in (0..elf.symtab_entries): ( \\\n            elf.symtab[i].shndx == 9 and \\\n            elf.symtab[i].value == 0x400650 and \\\n            elf.symtab[i].name == \\\"_start_c\\\") \\\n      }\",\n      ELF32_MIPS_FILE);\n          break;\n      case 140:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          elf.symtab[68].name == \\\"_start_c\\\" and \\\n          elf.symtab[68].type == elf.STT_FUNC and \\\n          elf.symtab[68].bind == elf.STB_GLOBAL and \\\n          elf.symtab[68].value == 0x400650 and \\\n          elf.symtab[68].size == 56 \\\n      }\",\n      ELF32_MIPS_FILE);\n          break;\n      case 141:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          elf.dynamic[4].type == elf.DT_STRTAB and \\\n          elf.dynamic[4].val == 0x400484\\\n      }\",\n      ELF32_MIPS_FILE);\n          break;\n      case 142:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          for any i in (0..elf.dynamic_section_entries): ( \\\n            elf.dynamic[i].type == 0x70000006 and \\\n            elf.dynamic[i].val == 0x400000)\\\n      }\",\n      ELF32_MIPS_FILE);\n          break;\n      case 143:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: elf.machine == elf.EM_X86_64 \\\n      }\",\n      ELF_x64_FILE);\n          break;\n      case 144:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          elf.number_of_sections == 22 and \\\n          elf.number_of_segments == 7 \\\n      }\",\n      ELF_x64_FILE);\n          break;\n      case 145:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          for any i in (0..elf.number_of_sections): ( \\\n            elf.sections[i].type == elf.SHT_PROGBITS and \\\n            elf.sections[i].address == 0x601000 and \\\n            elf.sections[i].name == \\\".got.plt\\\") \\\n      }\",\n      ELF_x64_FILE);\n          break;\n      case 146:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n         condition: \\\n            for any i in (0..elf.number_of_segments): ( \\\n              elf.segments[i].type == elf.PT_LOAD and \\\n              elf.segments[i].virtual_address == 0x600e78 and \\\n              elf.segments[i].file_size == 0x1b0) \\\n      }\",\n      ELF_x64_FILE);\n          break;\n      case 147:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n         condition: \\\n            elf.dynamic_section_entries == 18 and \\\n            elf.symtab_entries == 48  \\\n      }\",\n      ELF_x64_FILE);\n          break;\n      case 148:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          for any i in (0..elf.symtab_entries): ( \\\n            elf.symtab[i].shndx == 8 and \\\n            elf.symtab[i].value == 0x400400 and \\\n            elf.symtab[i].name == \\\"main\\\") \\\n     }\",\n     ELF_x64_FILE);\n          break;\n      case 149:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          elf.symtab[20].name == \\\"__JCR_LIST__\\\" and \\\n          elf.symtab[20].type == elf.STT_OBJECT and \\\n          elf.symtab[20].bind == elf.STB_LOCAL and \\\n          elf.symtab[20].value == 0x600e88 and \\\n          elf.symtab[20].size == 0 \\\n      }\",\n      ELF_x64_FILE);\n          break;\n      case 150:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          elf.dynamic[13].type == elf.DT_PLTGOT and \\\n          elf.dynamic[13].val == 0x601000 \\\n     }\",\n     ELF_x64_FILE);\n          break;\n      case 151:\n  assert_true_rule_blob(\n      \"import \\\"elf\\\" \\\n      rule test { \\\n        condition: \\\n          for any i in (0..elf.dynamic_section_entries): ( \\\n            elf.dynamic[i].type == elf.DT_JMPREL and \\\n            elf.dynamic[i].val == 0x4003c0) \\\n      }\",\n      ELF_x64_FILE);\n          break;\n  }\n  yr_finalize();\n}",
        "begin_line": 6,
        "end_line": 264,
        "is_bug": false
    },
    {
        "name": "tests.test-exception.crasher_func#99",
        "src_path": "tests/test-exception.c",
        "class_name": "tests.test-exception",
        "signature": "tests.test-exception.crasher_func (void* x)",
        "snippet": "void* crasher_func (void* x)\n{\n  sleep(1);\n  int *i = 0;\n  puts(\"crashing process...\");\n  *i = 0;\n  return NULL;\n}",
        "begin_line": 99,
        "end_line": 106,
        "is_bug": false
    },
    {
        "name": "tests.test-exception.defects4cpp_test_index#4",
        "src_path": "tests/test-exception.c",
        "class_name": "tests.test-exception",
        "signature": "tests.test-exception.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-exception.delay_callback#118",
        "src_path": "tests/test-exception.c",
        "class_name": "tests.test-exception",
        "signature": "tests.test-exception.delay_callback(int message, void* message_data, void* user_data)",
        "snippet": "int delay_callback(int message,\n    void* message_data,\n    void* user_data)\n{\n  if (message == CALLBACK_MSG_RULE_MATCHING)\n  {\n    (*(int*) user_data)++;\n  }\n  puts(\"callback: delaying execution...\");\n  sleep(2);\n  return CALLBACK_CONTINUE;\n}",
        "begin_line": 118,
        "end_line": 129,
        "is_bug": false
    },
    {
        "name": "tests.test-exception.main#227",
        "src_path": "tests/test-exception.c",
        "class_name": "tests.test-exception",
        "signature": "tests.test-exception.main(int argc, char **argv)",
        "snippet": "int main(int argc, char **argv)\n{\n  char *op = getenv(\"TEST_OP\");\n  if (op == NULL)\n  {\n    int status;\n    int index = defects4cpp_test_index();\n    switch (index) {\n        case 152:\n    puts(\"Test: crash\");\n    setenv(\"TEST_OP\", \"CRASH\", 1);\n    status = reexec(argv[0]);\n    if (status != 0)\n      return 1;\n            break;\n        case 153:\n    puts(\"Test: crash-no-handle\");\n    setenv(\"TEST_OP\", \"CRASH-NO-HANDLE\", 1);\n    status = reexec(argv[0]);\n    if (!WIFSIGNALED(status))\n    {\n      fputs(\"Expected subprocess to be terminated by signal\\n\", stderr);\n      return 1;\n    }\n            break;\n        case 154:\n    puts(\"Test: blocked-signal\");\n    setenv(\"TEST_OP\", \"BLOCKED-SIGNAL\", 1);\n    status = reexec(argv[0]);\n    if (status != 0)\n      return 1;\n            break;\n        case 155:\n    puts(\"Test: crash-other-thread\");\n    setenv(\"TEST_OP\", \"CRASH-OTHER-THREAD\", 1);\n    status = reexec(argv[0]);\n    if (!WIFSIGNALED(status))\n    {\n      fputs(\"Expected subprocess to be terminated by signal\\n\", stderr);\n      return 1;\n    }\n            break;\n    }\n    puts(\"Done.\");\n  }\n  else if (!strcmp(op, \"CRASH\"))\n    return test_crash(1);\n  else if (!strcmp(op, \"CRASH-NO-HANDLE\"))\n    return test_crash(0);\n  else if (!strcmp(op, \"BLOCKED-SIGNAL\"))\n    return test_blocked_signal();\n  else if (!strcmp(op, \"CRASH-OTHER-THREAD\"))\n    return test_crash_other_thread();\n  else\n  {\n    fprintf(stderr, \"wrong op '%s'\\n\", op);\n    return 77;\n  }\n  return 0;\n}",
        "begin_line": 227,
        "end_line": 286,
        "is_bug": false
    },
    {
        "name": "tests.test-exception.reexec#211",
        "src_path": "tests/test-exception.c",
        "class_name": "tests.test-exception",
        "signature": "tests.test-exception.reexec(char *program)",
        "snippet": "int reexec(char *program)\n{\n  char *argv[] = { program, NULL };\n  int status;\n  int pid = fork();\n  switch(pid)\n  {\n  case 0:\n    return execve(program, argv, environ);\n  case -1:\n    return -1;\n  }\n  waitpid(pid, &status, 0);\n  return status;\n}",
        "begin_line": 211,
        "end_line": 225,
        "is_bug": false
    },
    {
        "name": "tests.test-exception.setup_crasher#109",
        "src_path": "tests/test-exception.c",
        "class_name": "tests.test-exception",
        "signature": "tests.test-exception.setup_crasher()",
        "snippet": "void setup_crasher()\n{\n  pthread_t t;\n  pthread_attr_t attr;\n  pthread_attr_init(&attr);\n  pthread_create(&t, &attr, &crasher_func, NULL);\n}",
        "begin_line": 109,
        "end_line": 115,
        "is_bug": false
    },
    {
        "name": "tests.test-exception.setup_mmap#58",
        "src_path": "tests/test-exception.c",
        "class_name": "tests.test-exception",
        "signature": "tests.test-exception.setup_mmap()",
        "snippet": "void setup_mmap()\n{\n  char* filename = strdup(\"yara-testblob.XXXXXX\");\n  fd = mkstemp(filename);\n\n  if (fd <= 0)\n  {\n    perror(\"Create temp file\");\n    exit(77);\n  }\n\n  unlink(filename);\n\n  memset(wbuf, 'a', sizeof(wbuf));\n\n  for (int i = 0; i < COUNT; i++)\n  {\n    if (write(fd, wbuf, sizeof(wbuf)) != sizeof(wbuf))\n      exit(EXIT_FAILURE);\n  }\n\n  mapped_region = mmap(\n      NULL, COUNT * sizeof(wbuf), PROT_READ, MAP_SHARED, fd, 0);\n\n  if (ftruncate(fd, COUNT * sizeof(wbuf) / 2) != 0)\n    exit(EXIT_FAILURE);\n}",
        "begin_line": 58,
        "end_line": 84,
        "is_bug": false
    },
    {
        "name": "tests.test-exception.setup_rules#86",
        "src_path": "tests/test-exception.c",
        "class_name": "tests.test-exception",
        "signature": "tests.test-exception.setup_rules()",
        "snippet": "void setup_rules()\n{\n  yr_initialize();\n\n  compile_rule(\n      \"rule test { strings: $a = \\\"aaaa\\\" condition: all of them }\",\n      &rules_a);\n\n  compile_rule(\n      \"rule test { strings: $a = { 00 00 00 00 } condition: all of them }\",\n      &rules_0);\n}",
        "begin_line": 86,
        "end_line": 97,
        "is_bug": false
    },
    {
        "name": "tests.test-exception.test_blocked_signal#185",
        "src_path": "tests/test-exception.c",
        "class_name": "tests.test-exception",
        "signature": "tests.test-exception.test_blocked_signal()",
        "snippet": "int test_blocked_signal() {\n  setup_mmap();\n  setup_rules();\n\n  puts(\"Sending blocked SIGUSR1 to ourselves...\");\n\n  sigset_t set;\n  sigemptyset(&set);\n  sigaddset(&set, SIGUSR1);\n  sigprocmask(SIG_BLOCK, &set, NULL);\n  kill(getpid(), SIGUSR1);\n\n  puts(\"Scanning for {00 00 00 00}...\");\n  int matches = 0;\n\n  int rc = yr_rules_scan_mem(\n      rules_0, mapped_region, COUNT * sizeof(wbuf), 0, count_matches, &matches, 0);\n\n  printf(\"err = %d, matches = %d\\n\", rc, matches);\n\n  if (rc == ERROR_SUCCESS || matches != 0)\n    return 1;\n\n  return 0;\n}",
        "begin_line": 185,
        "end_line": 209,
        "is_bug": false
    },
    {
        "name": "tests.test-exception.test_crash#132",
        "src_path": "tests/test-exception.c",
        "class_name": "tests.test-exception",
        "signature": "tests.test-exception.test_crash(int handle_exceptions)",
        "snippet": "int test_crash(int handle_exceptions)\n{\n  setup_mmap();\n  setup_rules();\n\n  puts(\"Scanning for \\\"aaaa\\\"...\");\n  int matches = 0;\n\n  int flags = (handle_exceptions ? 0 : SCAN_FLAGS_NO_TRYCATCH);\n\n  int rc = yr_rules_scan_mem(\n      rules_a, mapped_region, COUNT * sizeof(wbuf), flags, count_matches, &matches, 0);\n\n  printf(\"err = %d, matches = %d\\n\", rc, matches);\n\n  if (rc == ERROR_SUCCESS || matches != 0)\n    return 1;\n\n  return 0;\n}",
        "begin_line": 132,
        "end_line": 151,
        "is_bug": false
    },
    {
        "name": "tests.test-exception.test_crash_other_thread#158",
        "src_path": "tests/test-exception.c",
        "class_name": "tests.test-exception",
        "signature": "tests.test-exception.test_crash_other_thread()",
        "snippet": "int test_crash_other_thread()\n{\n  setup_mmap();\n  setup_rules();\n  setup_crasher();\n\n  uint8_t mem[4096];\n  memset(mem, 'a', sizeof(mem));\n\n  puts(\"Scanning for \\\"aaaa\\\"...\");\n  int matches = 0;\n\n  int rc = yr_rules_scan_mem(\n      rules_a, mem, sizeof(mem), 0, delay_callback, &matches, 0);\n\n  printf(\"err = %d, matches = %d\\n\", rc, matches);\n\n  if (rc == ERROR_SUCCESS || matches != 0)\n    return 1;\n\n  return 0;\n}",
        "begin_line": 158,
        "end_line": 179,
        "is_bug": false
    },
    {
        "name": "tests.test-macho.defects4cpp_test_index#4",
        "src_path": "tests/test-macho.c",
        "class_name": "tests.test-macho",
        "signature": "tests.test-macho.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-macho.main#8",
        "src_path": "tests/test-macho.c",
        "class_name": "tests.test-macho",
        "signature": "tests.test-macho.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  char *top_srcdir = getenv(\"TOP_SRCDIR\");\n  if (top_srcdir)\n    chdir(top_srcdir);\n\n  yr_initialize();\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 156:\n  //  Tests for executable files\n\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.cputype == macho.CPU_TYPE_X86 }\", MACHO_X86_FILE);\n          break;\n      case 157:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.filetype == macho.MH_EXECUTE }\", MACHO_X86_FILE);\n          break;\n      case 158:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.flags & macho.MH_PIE }\", MACHO_X86_FILE);\n          break;\n      case 159:\n  // Segments\n\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.number_of_segments == 4 }\", MACHO_X86_FILE);\n          break;\n      case 160:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.segments[0].segname == \\\"__PAGEZERO\\\" and \\\n    macho.segments[1].segname == \\\"__TEXT\\\" and \\\n    macho.segments[2].segname == \\\"__DATA\\\" and \\\n    macho.segments[3].segname == \\\"__LINKEDIT\\\" }\", MACHO_X86_FILE);\n          break;\n      case 161:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.segments[0].vmaddr == 0 and \\\n    macho.segments[0].vmsize == 0x1000 and \\\n    macho.segments[2].nsects == 2 and \\\n    macho.segments[3].fsize == 0x118 }\", MACHO_X86_FILE);\n          break;\n      case 162:\n  // Sections\n\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.segments[1].sections[0].addr == 0x1e90 and \\\n    macho.segments[1].sections[0].size == 0xa6 and \\\n    macho.segments[1].sections[0].offset == 0x0e90 }\", MACHO_X86_FILE);\n          break;\n      case 163:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.segments[1].sections[0].sectname == \\\"__text\\\" and \\\n    macho.segments[1].sections[0].segname == \\\"__TEXT\\\" }\", MACHO_X86_FILE);\n          break;\n      case 164:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.segments[1].sections[1].sectname == \\\"__symbol_stub\\\" and \\\n    macho.segments[1].sections[2].sectname == \\\"__stub_helper\\\" and \\\n    macho.segments[1].sections[3].sectname == \\\"__cstring\\\" and \\\n    macho.segments[1].sections[4].sectname == \\\"__unwind_info\\\" and \\\n    macho.segments[2].sections[0].sectname == \\\"__nl_symbol_ptr\\\" and \\\n    macho.segments[2].sections[1].sectname == \\\"__la_symbol_ptr\\\" }\",\n    MACHO_X86_FILE);\n          break;\n      case 165:\n  // Entry point (LC_MAIN)\n\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.entry_point == 0xe90 }\", MACHO_X86_FILE);\n          break;\n      case 166:\n  // Tests for object files\n\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.cputype == macho.CPU_TYPE_X86 }\", MACHO_X86_OBJECT_FILE);\n          break;\n      case 167:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.filetype == macho.MH_OBJECT }\", MACHO_X86_OBJECT_FILE);\n          break;\n      case 168:\n  // Segments and sections\n\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.number_of_segments == 1 and macho.segments[0].segname == \\\"\\\" and \\\n    macho.segments[0].sections[0].sectname == \\\"__text\\\" and \\\n    macho.segments[0].sections[0].segname == \\\"__TEXT\\\" }\",\n    MACHO_X86_OBJECT_FILE);\n          break;\n      case 169:\n  // Tests for big-endian byte order\n\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.cputype == macho.CPU_TYPE_POWERPC }\", MACHO_PPC_FILE);\n          break;\n      case 170:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.filetype == macho.MH_EXECUTE }\", MACHO_PPC_FILE);\n          break;\n      case 171:\n  // Segments\n\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.number_of_segments == 4 and \\\n    macho.segments[0].segname == \\\"__PAGEZERO\\\" and \\\n    macho.segments[2].segname == \\\"__DATA\\\" and \\\n    macho.segments[2].nsects == 6 and \\\n    macho.segments[0].vmaddr == 0 and \\\n    macho.segments[0].vmsize == 0x1000 and \\\n    macho.segments[3].fileoff == 65536 and \\\n    macho.segments[3].fsize == 46032 }\", MACHO_PPC_FILE);\n          break;\n      case 172:\n  // Entry point (LC_UNIXTHREAD)\n\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.entry_point == 0xeb8 }\", MACHO_PPC_FILE);\n          break;\n      case 173:\n  // Tests for 64-bit and shared library files\n\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.cputype == macho.CPU_TYPE_X86_64 }\", MACHO_X86_64_DYLIB_FILE);\n          break;\n      case 174:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.filetype == macho.MH_DYLIB }\", MACHO_X86_64_DYLIB_FILE);\n          break;\n      case 175:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.flags & macho.MH_DYLDLINK and \\\n    macho.flags & macho.MH_NOUNDEFS and \\\n    macho.flags & macho.MH_NO_REEXPORTED_DYLIBS and \\\n    macho.flags & macho.MH_TWOLEVEL }\", MACHO_X86_64_DYLIB_FILE);\n          break;\n      case 176:\n  // Segments and sections\n\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.number_of_segments == 2 }\", MACHO_X86_64_DYLIB_FILE);\n          break;\n      case 177:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.segments[0].segname == \\\"__TEXT\\\" and \\\n    macho.segments[1].segname == \\\"__LINKEDIT\\\" }\", MACHO_X86_64_DYLIB_FILE);\n          break;\n      case 178:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.segments[1].vmaddr == 0x0000000000001000 and \\\n    macho.segments[1].vmsize == 0x0000000000001000 and \\\n    macho.segments[1].nsects == 0 and \\\n    macho.segments[1].fsize == 128 }\", MACHO_X86_64_DYLIB_FILE);\n          break;\n      case 179:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.segments[0].sections[0].sectname == \\\"__text\\\" and \\\n    macho.segments[0].sections[0].segname == \\\"__TEXT\\\" }\",\n    MACHO_X86_64_DYLIB_FILE);\n          break;\n      case 180:\n  assert_true_rule_blob(\"import \\\"macho\\\" rule test { condition: \\\n    macho.segments[0].sections[1].addr == 0x0000000000000f98 and \\\n    macho.segments[0].sections[1].size == 0x0000000000000048 and \\\n    macho.segments[0].sections[1].offset == 3992 }\", MACHO_X86_64_DYLIB_FILE);\n          break;\n      case 181:\n  // Mach-O Universal Binaries tests\n\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { condition: \\\n    macho.fat_magic == macho.FAT_MAGIC and macho.nfat_arch == 2 }\",\n    \"tests/data/tiny-universal\");\n          break;\n      case 182:\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { condition: \\\n    macho.fat_arch[0].cputype == macho.CPU_TYPE_I386 and \\\n    macho.fat_arch[0].cpusubtype == macho.CPU_SUBTYPE_I386_ALL and \\\n    macho.fat_arch[0].offset == 4096 and \\\n    macho.fat_arch[1].cputype == macho.CPU_TYPE_X86_64 and \\\n    macho.fat_arch[1].cpusubtype == macho.CPU_SUBTYPE_X86_64_ALL | \\\n    macho.CPU_SUBTYPE_LIB64 and macho.fat_arch[1].align == 12 }\",\n    \"tests/data/tiny-universal\");\n          break;\n      case 183:\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { condition: \\\n    macho.file[0].cputype == macho.fat_arch[0].cputype and \\\n    macho.file[1].cputype == macho.fat_arch[1].cputype }\",\n    \"tests/data/tiny-universal\");\n          break;\n      case 184:\n  // Entry points for files (LC_MAIN)\n\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { \\\n    strings: $1 = { 55 89 e5 56 83 ec 34 } \\\n    condition: $1 at macho.file[0].entry_point + macho.fat_arch[0].offset }\",\n    \"tests/data/tiny-universal\");\n          break;\n      case 185:\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { \\\n    strings: $1 = { 55 48 89 e5 48 83 ec 20 } \\\n    condition: $1 at macho.file[1].entry_point + macho.fat_arch[1].offset }\",\n    \"tests/data/tiny-universal\");\n          break;\n      case 186:\n  // Helper functions\n\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { condition: \\\n    macho.file[macho.file_index_for_arch(macho.CPU_TYPE_I386)].entry_point == \\\n    macho.file[0].entry_point }\", \"tests/data/tiny-universal\");\n          break;\n      case 187:\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { condition: \\\n    macho.file[macho.file_index_for_arch(macho.CPU_TYPE_X86_64)].entry_point == \\\n    macho.file[1].entry_point }\", \"tests/data/tiny-universal\");\n          break;\n      case 188:\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { condition: \\\n    macho.file[macho.file_index_for_arch(macho.CPU_TYPE_I386, \\\n               macho.CPU_SUBTYPE_I386_ALL)].entry_point == \\\n    macho.file[0].entry_point }\", \"tests/data/tiny-universal\");\n          break;\n      case 189:\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { condition: \\\n    macho.file[macho.file_index_for_arch(macho.CPU_TYPE_X86_64, \\\n               macho.CPU_SUBTYPE_X86_64_ALL | \\\n               macho.CPU_SUBTYPE_LIB64)].entry_point == \\\n    macho.file[1].entry_point }\", \"tests/data/tiny-universal\");\n          break;\n      case 190:\n  // Entry point for specific architecture\n\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { \\\n    strings: $1 = { 55 89 e5 56 83 ec 34 } \\\n    condition: $1 at macho.entry_point_for_arch(macho.CPU_TYPE_I386, \\\n                                       macho.CPU_SUBTYPE_I386_ALL) }\",\n    \"tests/data/tiny-universal\");\n          break;\n      case 191:\n  assert_true_rule_file(\"import \\\"macho\\\" rule test { \\\n    strings: $1 = { 55 48 89 e5 48 83 ec 20 } \\\n    condition: $1 at macho.entry_point_for_arch(macho.CPU_TYPE_X86_64) }\",\n    \"tests/data/tiny-universal\");\n          break;\n  }\n  yr_finalize();\n}",
        "begin_line": 8,
        "end_line": 254,
        "is_bug": false
    },
    {
        "name": "tests.test-math.defects4cpp_test_index#4",
        "src_path": "tests/test-math.c",
        "class_name": "tests.test-math",
        "signature": "tests.test-math.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-math.main#6",
        "src_path": "tests/test-math.c",
        "class_name": "tests.test-math",
        "signature": "tests.test-math.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  yr_initialize();\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 192:\n  assert_true_rule_blob(\n      \"import \\\"math\\\" \\\n      rule test { \\\n        condition: \\\n          math.min(0, 1) == 0 \\\n      }\",\n      \"A\");\n          break;\n      case 193:\n  assert_true_rule_blob(\n      \"import \\\"math\\\" \\\n      rule test { \\\n        condition: \\\n          math.max(0, 1) == 1 \\\n      }\",\n      \"A\");\n          break;\n  }\n  yr_finalize();\n  return 0;\n}",
        "begin_line": 6,
        "end_line": 32,
        "is_bug": false
    },
    {
        "name": "tests.test-pe.defects4cpp_test_index#4",
        "src_path": "tests/test-pe.c",
        "class_name": "tests.test-pe",
        "signature": "tests.test-pe.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-pe.main#8",
        "src_path": "tests/test-pe.c",
        "class_name": "tests.test-pe",
        "signature": "tests.test-pe.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  char *top_srcdir = getenv(\"TOP_SRCDIR\");\n  if (top_srcdir)\n    chdir(top_srcdir);\n\n  yr_initialize();\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 194:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.imports(\\\"KERNEL32.dll\\\", \\\"DeleteCriticalSection\\\") \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 195:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.imports(\\\"KERNEL32.dll\\\", \\\"DeleteCriticalSection\\\") \\\n      }\",\n      \"tests/data/tiny-idata-51ff\");\n          break;\n      case 196:\n  assert_false_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.imports(\\\"KERNEL32.dll\\\", \\\"DeleteCriticalSection\\\") \\\n      }\",\n      \"tests/data/tiny-idata-5200\");\n          break;\n      case 197:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.imports(/.*/, /.*CriticalSection/) \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 198:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.imports(/kernel32\\\\.dll/i, /.*/) \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 199:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.imports(/.*/, /.*/) \\\n      }\",\n      \"tests/data/tiny-idata-5200\");\n          break;\n      case 200:\n  assert_false_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.imports(/.*/, /.*CriticalSection/) \\\n      }\",\n      \"tests/data/tiny-idata-5200\");\n          break;\n      case 201:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.number_of_imports == 2 \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 202:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.number_of_sections == 7 \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 203:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.entry_point == 0x14E0 \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 204:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.linker_version.major == 2 and \\\n          pe.linker_version.minor == 26 \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 205:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.sections[0].name == \\\".text\\\" and \\\n          pe.sections[1].name == \\\".data\\\" and \\\n          pe.sections[2].name == \\\".rdata\\\" and \\\n          pe.sections[3].name == \\\".bss\\\" and \\\n          pe.sections[4].name == \\\".idata\\\" and \\\n          pe.sections[5].name == \\\".CRT\\\" and \\\n          pe.sections[6].name == \\\".tls\\\" \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 206:\n  #if defined(HAVE_LIBCRYPTO) || \\\n      defined(HAVE_WINCRYPT_H) || \\\n      defined(HAVE_COMMONCRYPTO_COMMONCRYPTO_H)\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.imphash() == \\\"1720bf764274b7a4052bbef0a71adc0d\\\" \\\n      }\",\n      \"tests/data/tiny\");\n  #endif\n  #if defined(HAVE_LIBCRYPTO)\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.number_of_signatures == 1 and \\\n          pe.signatures[0].thumbprint == \\\"c1bf1b8f751bf97626ed77f755f0a393106f2454\\\" and \\\n          pe.signatures[0].subject == \\\"/C=US/ST=California/L=Menlo Park/O=Quicken, Inc./OU=Operations/CN=Quicken, Inc.\\\" \\\n      }\",\n      \"tests/data/079a472d22290a94ebb212aa8015cdc8dd28a968c6b4d3b88acdd58ce2d3b885\");\n  #endif\n      break;\n      case 207:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.section_index(\\\".text\\\") == 0 \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 208:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.section_index(pe.entry_point) == 0 \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 209:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.is_32bit() and not pe.is_64bit() \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 210:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.checksum == 0xA8DC \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 211:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.checksum == pe.calculate_checksum() \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 212:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.overlay.offset == 0x8000 and pe.overlay.size == 7 \\\n      }\",\n      \"tests/data/tiny-overlay\");\n          break;\n      case 213:\n  assert_true_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n         pe.overlay.size == 0 \\\n      }\",\n      \"tests/data/tiny\");\n          break;\n      case 214:\n  assert_false_rule_file(\n      \"import \\\"pe\\\" \\\n      rule test { \\\n        condition: \\\n          pe.checksum == pe.calculate_checksum() \\\n      }\",\n      \"tests/data/tiny-idata-51ff\");\n          break;\n  }\n  yr_finalize();\n  return 0;\n}",
        "begin_line": 8,
        "end_line": 231,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.defects4cpp_test_index#4",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.main#2031",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  char *top_srcdir = getenv(\"TOP_SRCDIR\");\n  if (top_srcdir)\n    chdir(top_srcdir);\n\n  yr_initialize();\n  int index = defects4cpp_test_index();\n  switch (index) {\n      case 215:\n  test_boolean_operators();\n          break;\n      case 216:\n  test_comparison_operators();\n          break;\n      case 217:\n  test_arithmetic_operators();\n          break;\n      case 218:\n  test_bitwise_operators();\n          break;\n      case 219:\n  test_matches_operator();\n          break;\n      case 220:\n  test_syntax();\n          break;\n      case 221:\n  test_anonymous_strings();\n          break;\n      case 222:\n  test_strings();\n          break;\n      case 223:\n  test_wildcard_strings();\n          break;\n      case 224:\n  test_hex_strings();\n          break;\n      case 225:\n  test_count();\n          break;\n      case 226:\n  test_at();\n          break;\n      case 227:\n  test_in();\n          break;\n      case 228:\n  test_offset();\n          break;\n      case 229:\n  test_length();\n          break;\n      case 230:\n  test_of();\n          break;\n      case 231:\n  test_for();\n          break;\n      case 232:\n  test_re();\n          break;\n      case 233:\n  test_filesize();\n          break;\n      case 234:\n  test_include_files();\n          break;\n      case 235:\n  // test_compile_file();\n  // test_compile_files();\n\n  // test_externals();\n  // test_callback();\n  // test_compare();\n  test_comments();\n          break;\n      case 236:\n  test_modules();\n          break;\n      case 237:\n  test_integer_functions();\n          break;\n      case 238:\n  // test_string_io();\n  test_entrypoint();\n          break;\n      case 239:\n  test_global_rules();\n          break;\n      case 240:\n  #if !defined(USE_WINDOWS_PROC) && !defined(USE_NO_PROC)\n  test_process_scan();\n  #endif\n          break;\n      case 241:\n  #if defined(HASH_MODULE)\n  test_hash_module();\n  #endif\n          break;\n      case 242:\n  test_time_module();\n          break;\n      case 243:\n  test_performance_warnings();\n          break;\n  }\n  yr_finalize();\n  return 0;\n}",
        "begin_line": 2031,
        "end_line": 2141,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_anonymous_strings#362",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_anonymous_strings()",
        "snippet": "static void test_anonymous_strings()\n{\n  assert_true_rule(\n      \"rule test { strings: $ = \\\"a\\\" $ = \\\"b\\\" condition: all of them }\",\n      \"ab\");\n}",
        "begin_line": 362,
        "end_line": 367,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_arithmetic_operators#174",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_arithmetic_operators()",
        "snippet": "static void test_arithmetic_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: (1 + 1) * 2 == (9 - 1) \\\\ 2 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 5 % 2 == 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 + 1.5 == 3}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 3 \\\\ 2 == 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 3.0 \\\\ 2 == 1.5}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 + -1 == 0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -1 + -1 == -2}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 4 --2 * 2 == 8}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -1.0 * 1 == -1.0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1-1 == 0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -2.0-3.0 == -5}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: --1 == 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1--1 == 2}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 2 * -2 == -4}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -4 * 2 == -8}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -4 * -4 == 16}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -0x01 == -1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0o10 == 8 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0o100 == 64 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0o755 == 493 }\", NULL);\n\n  // TODO: This should return ERROR_INTEGER_OVERFLOW, but right now it returns\n  // ERROR_SYNTAX_ERROR because after the lexer aborts with ERROR_INTEGER_OVERFLOW\n  // the parser finds an unexpected end fails with error: unexpected $end.\n  assert_error(\n      \"rule test { condition: 9223372036854775808 > 0 }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(\n      \"rule test { condition: 9007199254740992KB > 0 }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(  // integer too long\n      \"rule test { condition: 8796093022208MB > 0 }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(  // integer too long\n     \"rule test { condition: 0x8000000000000000 > 0 }\",\n     ERROR_SYNTAX_ERROR);\n\n  assert_error(  // integer too long\n     \"rule test { condition: 0o1000000000000000000000 > 0 }\",\n     ERROR_SYNTAX_ERROR);\n\n  assert_error(\n     \"rule test { condition: 0x7FFFFFFFFFFFFFFF + 1 > 0 }\",\n     ERROR_INTEGER_OVERFLOW);\n\n  assert_error(\n     \"rule test { condition: 9223372036854775807 + 1 > 0 }\",\n     ERROR_INTEGER_OVERFLOW);\n\n  assert_error(\n     \"rule test { condition: -9223372036854775807 - 2 > 0 }\",\n     ERROR_INTEGER_OVERFLOW);\n\n  assert_error(\n     \"rule test { condition: -2 + -9223372036854775807 > 0 }\",\n     ERROR_INTEGER_OVERFLOW);\n\n  assert_error(\n     \"rule test { condition: 1 - -9223372036854775807 > 0 }\",\n     ERROR_INTEGER_OVERFLOW);\n\n  assert_error(\n     \"rule test { condition: 0x4000000000000000 * 2 }\",\n     ERROR_INTEGER_OVERFLOW);\n\n  assert_error(\n     \"rule test { condition: 4611686018427387904 * 2 }\",\n     ERROR_INTEGER_OVERFLOW);\n\n  assert_error(\n     \"rule test { condition: 4611686018427387904 * -2 }\",\n     ERROR_INTEGER_OVERFLOW);\n\n  assert_error(\n     \"rule test { condition: -4611686018427387904 * 2 }\",\n     ERROR_INTEGER_OVERFLOW);\n\n  assert_error(\n     \"rule test { condition: -4611686018427387904 * -2 }\",\n     ERROR_INTEGER_OVERFLOW);\n}",
        "begin_line": 174,
        "end_line": 298,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_at#811",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_at()",
        "snippet": "static void test_at()\n{\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = \\\"ssi\\\" \\\n        condition: $a at 2 and $a at 5 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = \\\"mis\\\" \\\n        condition: $a at ~0xFF & 0xFF }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 00 00 00 00 ?? 74 65 78 74 } \\\n        condition: $a at 308}\",\n      PE32_FILE);\n}",
        "begin_line": 811,
        "end_line": 830,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_bitwise_operators#301",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_bitwise_operators()",
        "snippet": "static void test_bitwise_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: 0x55 | 0xAA == 0xFF }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: ~0xAA ^ 0x5A & 0xFF == (~0xAA) ^ (0x5A & 0xFF) }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: ~0x55 & 0xFF == 0xAA }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 8 >> 2 == 2 }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 << 3 == 8 }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 << 64 == 0 }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 >> 64 == 0 }\",\n      NULL);\n\n  assert_error(\n      \"rule test { condition: 1 << -1 == 0 }\",\n      ERROR_INVALID_OPERAND);\n\n  assert_error(\n      \"rule test { condition: 1 >> -1 == 0 }\",\n      ERROR_INVALID_OPERAND);\n\n  assert_true_rule(\n      \"rule test { condition: 1 | 3 ^ 3 == 1 | (3 ^ 3) }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: ~0xAA ^ 0x5A & 0xFF == 0x0F }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 1 | 3 ^ 3 == (1 | 3) ^ 3}\",\n      NULL);\n\n}",
        "begin_line": 301,
        "end_line": 351,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_boolean_operators#43",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_boolean_operators()",
        "snippet": "static void test_boolean_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: true }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: true or false }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: true and true }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0x1 and 0x2}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: false }\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: true and false }\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: false or false }\", NULL);\n}",
        "begin_line": 43,
        "end_line": 65,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_comments#1468",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_comments()",
        "snippet": "static void test_comments()\n{\n  assert_true_rule(\n      \"rule test {\\n\\\n         condition:\\n\\\n             //  this is a comment\\n\\\n             /*** this is a comment ***/\\n\\\n             /* /* /*\\n\\\n                 this is a comment\\n\\\n             */\\n\\\n             true\\n\\\n      }\",\n      NULL);\n}",
        "begin_line": 1468,
        "end_line": 1481,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_comparison_operators#68",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_comparison_operators()",
        "snippet": "static void test_comparison_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: 2 > 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 < 2 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 2 >= 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 <= 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 == 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 == 1.5}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.0 == 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 >= 1.0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.0 != 1.000000000000001 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.0 < 1.000000000000001 }\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 1.0 >= 1.000000000000001 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.000000000000001 > 1 }\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 1.000000000000001 <= 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.0 == 1.0000000000000001 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.0 >= 1.0000000000000001 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 >= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.0 >= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0.5 < 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0.5 <= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: 1.0 <= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" == \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" <= \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" >= \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"ab\\\" < \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" > \\\"ab\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" < \\\"abd\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abd\\\" > \\\"abc\\\"}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 1 != 1}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 1 != 1.0}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 2 > 3}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 2.1 < 2}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"abc\\\" != \\\"abc\\\"}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"abc\\\" > \\\"abc\\\"}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"abc\\\" < \\\"abc\\\"}\", NULL);\n\n}",
        "begin_line": 68,
        "end_line": 172,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_count#803",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_count()",
        "snippet": "static void test_count()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: #a == 2 }\",\n      \"mississippi\");\n}",
        "begin_line": 803,
        "end_line": 808,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_entrypoint#1426",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_entrypoint()",
        "snippet": "static void test_entrypoint()\n{\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 6a 2a 58 c3 } \\\n        condition: $a at entrypoint }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { b8 01 00 00 00 bb 2a } \\\n        condition: $a at entrypoint }\",\n      ELF32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { b8 01 00 00 00 bb 2a } \\\n        condition: $a at entrypoint }\",\n      ELF64_FILE);\n\n  assert_false_rule(\n      \"rule test { condition: entrypoint >= 0 }\",\n      NULL);\n}",
        "begin_line": 1426,
        "end_line": 1449,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_filesize#1452",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_filesize()",
        "snippet": "static void test_filesize()\n{\n  char rule[80];\n\n  snprintf(\n      rule,\n      sizeof(rule),\n      \"rule test { condition: filesize == %zd }\",\n      sizeof(PE32_FILE));\n\n  assert_true_rule_blob(\n      rule,\n      PE32_FILE);\n}",
        "begin_line": 1452,
        "end_line": 1465,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_for#957",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_for()",
        "snippet": "void test_for()\n{\n  assert_true_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n        condition: \\\n          for all i in (1..#a) : (@a[i] >= 2 and @a[i] <= 5) \\\n      }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n          $b = \\\"mi\\\" \\\n        condition: \\\n          for all i in (1..#a) : ( for all j in (1..#b) : (@a[i] >= @b[j])) \\\n      }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n        condition: \\\n          for all i in (1..#a) : (@a[i] == 5) \\\n      }\",\n      \"mississippi\");\n}",
        "begin_line": 957,
        "end_line": 986,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_global_rules#1523",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_global_rules()",
        "snippet": "static void test_global_rules()\n{\n  assert_true_rule(\n      \"global private rule global_rule { \\\n        condition: \\\n          true \\\n      } \\\n      rule test { \\\n        condition: true \\\n      }\",\n      NULL);\n\n  assert_false_rule(\n      \"global private rule global_rule { \\\n        condition: \\\n          false \\\n      } \\\n      rule test { \\\n        condition: true \\\n      }\",\n      NULL);\n}",
        "begin_line": 1523,
        "end_line": 1544,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_hex_strings#561",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_hex_strings()",
        "snippet": "static void test_hex_strings()\n{\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 01 00 00 60 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 0? 00 00 ?0 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\\\n\n      \"rule test { \\\n        strings: $a = { 6? 01 00 00 60 0? } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 01 [1-3] 60 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 01 [1-3] (60|61) 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [-] 6A 2A [-] 58 C3} \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [300-] 6A 2A [-] 58 C3} \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 2e 7? (65 | ?? ) 78 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_false_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [0-300] 6A 2A } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_false_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [0-128] 45 [0-128] 01 [0-128]  C3 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] // Inline comment\\n\\r \\\n          38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 /* Inline comment */ [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 /* Inline multi-line\\n\\r \\\n                                 comment */ [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = {\\n 31 32 [-] 38 39 \\n\\r} \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 33 34 [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [1] 34 35 [2] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test {\\\n         strings: $a = { 31 32 [1-] 34 35 [1-] 38 39 } \\\n         condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-3] 34 35 [1-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-2] 35 [1-] 37 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 33 } \\\n        condition: !a == 3}\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 34 } \\\n        condition: !a == 4}\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-2] 34 } \\\n        condition: !a == 4 }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 38 39 } \\\n        condition: all of them }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 32 33 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 35 36 [-] 31 32 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [2-] 34 35 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 33 34 [0-2] 36 37 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 34 35 [0-2] 36 37 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-3] 37 38 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [1] 33 34 } \\\n        condition: $a }\",\n      \"12\\n34\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = {31 32 [3-6] 32} \\\n        condition: !a == 6 }\",\n      \"12111222\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = {31 [0-3] (32|33)} \\\n        condition: !a == 2 }\",\n      \"122222222\");\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 [0] 02 } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { [-] 01 02 } condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 [-] } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 ([-] 03 | 04) } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 (03 [-] | 04) } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 (03 | 04 [-]) } \\\n        condition: $a \",\n      ERROR_INVALID_HEX_STRING);\n\n  /* TODO: tests.py:551 ff. */\n}",
        "begin_line": 561,
        "end_line": 800,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_in#833",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_in()",
        "snippet": "static void test_in()\n{\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 6a 2a 58 c3 } \\\n        condition: $a in (entrypoint .. entrypoint + 1) }\",\n      PE32_FILE);\n}",
        "begin_line": 833,
        "end_line": 840,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_include_files#1831",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_include_files()",
        "snippet": "void test_include_files()\n{\n  assert_true_rule(\n    \"include \\\"tests/data/baz.yar\\\" rule t { condition: baz }\",\n    NULL);\n\n  assert_true_rule(\n    \"include \\\"tests/data/foo.yar\\\" rule t { condition: foo }\",\n    NULL);\n}",
        "begin_line": 1831,
        "end_line": 1840,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_integer_functions#1803",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_integer_functions()",
        "snippet": "void test_integer_functions()\n{\n  assert_true_rule(\n      \"rule test { condition: uint8(0) == 0xAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint16(0) == 0xBBAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint32(0) == 0xDDCCBBAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint8be(0) == 0xAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint16be(0) == 0xAABB}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint32be(0) == 0xAABBCCDD}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n}",
        "begin_line": 1803,
        "end_line": 1828,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_length#859",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_length()",
        "snippet": "static void test_length()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*?ssi/ condition: !a == 5 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*?ssi/ condition: !a[1] == 5 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*ssi/ condition: !a == 8 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*ssi/ condition: !a[1] == 8 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi.*ppi/ condition: !a[1] == 9 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi.*ppi/ condition: !a[2] == 6 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D [1-3] 73 73 69 } condition: !a == 5}\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D [-] 73 73 69 } condition: !a == 5}\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D [-] 70 70 69 } condition: !a == 11}\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D 69 73 73 [-] 70 69 } condition: !a == 11}\",\n      \"mississippi\");\n}",
        "begin_line": 859,
        "end_line": 900,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_matches_operator#1483",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_matches_operator()",
        "snippet": "static void test_matches_operator()\n{\n  assert_true_rule(\n      \"rule test { condition: \\\"foo\\\" matches /foo/ }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"foo\\\" matches /bar/ }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"FoO\\\" matches /fOo/i }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"xxFoOxx\\\" matches /fOo/i }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"xxFoOxx\\\" matches /^fOo/i }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"xxFoOxx\\\" matches /fOo$/i }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"foo\\\" matches /^foo$/i }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"foo\\\\nbar\\\" matches /foo.*bar/s }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"foo\\\\nbar\\\" matches /foo.*bar/ }\",\n      NULL);\n}",
        "begin_line": 1483,
        "end_line": 1520,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_modules#1547",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_modules()",
        "snippet": "static void test_modules()\n{\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.one + 1 == tests.constants.two \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.foo == \\\"foo\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.empty == \\\"\\\"  \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.empty() == \\\"\\\"  \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.struct_array[1].i == 1  \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.struct_array[0].i == 1 or true \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.integer_array[0] == 0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.integer_array[1] == 1 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.integer_array[256] == 256 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_array[0] == \\\"foo\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_array[2] == \\\"baz\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_dict[\\\"foo\\\"] == \\\"foo\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_dict[\\\"bar\\\"] == \\\"bar\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.isum(1,2) == 3 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.isum(1,2,3) == 6 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.fsum(1.0,2.0) == 3.0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.fsum(1.0,2.0,3.0) == 6.0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.foobar(1) == tests.foobar(1) \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.foobar(1) != tests.foobar(2) \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.length(\\\"dummy\\\") == 5 \\\n      }\",\n      NULL);\n\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.struct_array[0].i == 1  \\\n      }\",\n      NULL);\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.isum(1,1) == 3 \\\n      }\",\n      NULL);\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.fsum(1.0,1.0) == 3.0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo/,\\\"foo\\\") == 3 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo/,\\\"bar\\\") == -1\\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo.bar/i,\\\"FOO\\\\nBAR\\\") == -1\\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo.bar/is,\\\"FOO\\\\nBAR\\\") == 7\\\n      }\",\n      NULL);\n\n  assert_error(\n      \"import \\\"\\\\x00\\\"\",\n      ERROR_INVALID_MODULE_NAME);\n\n  assert_error(\n      \"import \\\"\\\"\",\n      ERROR_INVALID_MODULE_NAME);\n}",
        "begin_line": 1547,
        "end_line": 1739,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_of#903",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_of()",
        "snippet": "static void test_of()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" $b = \\\"mis\\\" $c = \\\"oops\\\" \"\n      \"condition: any of them }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" $b = \\\"mis\\\" $c = \\\"oops\\\" \"\n      \"condition: 1 of them }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" $b = \\\"mis\\\" $c = \\\"oops\\\" \"\n      \"condition: 2 of them }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a1 = \\\"dummy1\\\" $b1 = \\\"dummy1\\\" $b2 = \\\"ssi\\\"\"\n      \"condition: any of ($a*, $b*) }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { \\\n         strings: \\\n           $ = /abc/ \\\n           $ = /def/ \\\n           $ = /ghi/ \\\n         condition: \\\n           for any of ($*) : ( for any i in (1..#): (uint8(@[i] - 1) == 0x00) )\\\n       }\",\n       \"abc\\000def\\000ghi\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n          $b = \\\"mis\\\" \\\n          $c = \\\"oops\\\" \\\n        condition: \\\n          all of them \\\n      }\",\n      \"mississippi\");\n\n  assert_error(\n      \"rule test { condition: all of ($a*) }\",\n      ERROR_UNDEFINED_STRING);\n\n  assert_error(\n      \"rule test { condition: all of them }\",\n      ERROR_UNDEFINED_STRING);\n}",
        "begin_line": 903,
        "end_line": 954,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_offset#843",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_offset()",
        "snippet": "static void test_offset()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: @a == 2 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: @a == @a[1] }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: @a[2] == 5 }\",\n      \"mississippi\");\n}",
        "begin_line": 843,
        "end_line": 856,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_performance_warnings#1902",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_performance_warnings()",
        "snippet": "void test_performance_warnings()\n{\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 01 } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 01 ?? } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 01 ?? ?? } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 01 ?? ?? 02 } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 01 ?? ?2 03 } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 01 ?? 02 1? } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 1? 2? 3? } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 1? 2? 3? 04 } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 1? ?? 03 } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 00 01 } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 01 00 } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 00 00 } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 00 00 00 } \\\n        condition: $a }\")\n\n  assert_no_warnings(\n      \"rule test { \\\n        strings: $a = { 00 00 01 } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { 00 00 00 00 } \\\n        condition: $a }\")\n\n  assert_no_warnings(\n      \"rule test { \\\n        strings: $a = { 00 00 00 01 } \\\n        condition: $a }\")\n\n  assert_warning(\n      \"rule test { \\\n        strings: $a = { FF FF FF FF } \\\n        condition: $a }\")\n\n  assert_no_warnings(\n      \"rule test { \\\n        strings: $a = { 00 00 01 02 } \\\n        condition: $a }\")\n\n  assert_no_warnings(\n       \"rule test { \\\n        strings: $a = { 00 01 02 03 } \\\n        condition: $a }\")\n\n  assert_no_warnings(\n       \"rule test { \\\n        strings: $a = { 01 02 03 04 } \\\n        condition: $a }\")\n\n  assert_no_warnings(\n       \"rule test { \\\n        strings: $a = { 01 02 03 } \\\n        condition: $a }\")\n\n  assert_no_warnings(\n       \"rule test { \\\n        strings: $a = { 20 01 02 } \\\n        condition: $a }\")\n\n  assert_no_warnings(\n       \"rule test { \\\n        strings: $a = { 01 02 } \\\n        condition: $a }\")\n\n  assert_no_warnings(\n       \"rule test { \\\n        strings: $a = \\\"foo\\\" wide \\\n        condition: $a }\")\n\n  assert_no_warnings(\n       \"rule test { \\\n        strings: $a = \\\"MZ\\\" \\\n        condition: $a }\")\n}",
        "begin_line": 1902,
        "end_line": 2028,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_process_scan#1843",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_process_scan()",
        "snippet": "void test_process_scan()\n{\n  int pid = fork();\n  int status = 0;\n  int matches = 0;\n  YR_RULES* rules;\n  int rc1, rc2;\n\n  if (pid == 0)\n  {\n    /* The string should appear somewhere in the shell's process space. */\n    if (execl(\"/bin/sh\", \"/bin/sh\", \"-c\", \"VAR='Hello, world!'; sleep 5; true\", NULL) == -1)\n      exit(1);\n  }\n  assert(pid > 0);\n\n  /* Give child process time to initialize */\n  sleep(1);\n\n  assert( compile_rule(\"\\\n    rule test {\\\n      strings:\\\n        $a = { 48 65 6c 6c 6f 2c 20 77 6f 72 6c 64 21 }\\\n      condition:\\\n        all of them\\\n    }\", &rules) == ERROR_SUCCESS);\n  rc1 = yr_rules_scan_proc(rules, pid, 0, count_matches, &matches, 0);\n  kill(pid, SIGALRM);\n\n  rc2 = waitpid(pid, &status, 0);\n  if (rc2 == -1)\n  {\n    perror(\"waitpid\");\n    exit(EXIT_FAILURE);\n  }\n  if (status != SIGALRM)\n  {\n    fprintf(stderr, \"Scanned process exited with unexpected status %d\\n\", status);\n    exit(EXIT_FAILURE);\n  }\n\n  switch (rc1) {\n  case ERROR_SUCCESS:\n    if (matches == 0)\n    {\n      fputs(\"Found no matches\\n\", stderr);\n      exit(EXIT_FAILURE);\n    }\n    break;\n  case ERROR_COULD_NOT_ATTACH_TO_PROCESS:\n    fputs(\"Could not attach to process, ignoring this error\\n\", stderr);\n    break;\n  default:\n    fprintf(stderr, \"yr_rules_scan_proc: Got unexpected error %d\\n\", rc1);\n    exit(EXIT_FAILURE);\n  }\n}",
        "begin_line": 1843,
        "end_line": 1899,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_re#989",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_re()",
        "snippet": "void test_re()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi(s|p)/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssim*/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssa?/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /Miss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /(M|N)iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /[M-N]iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /(Mi|ssi)ssippi/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\tmi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\.mi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /^mississippi/ fullword condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /mississippi.*mississippi$/s condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /^ssi/ condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /ssi$/ condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /ssissi/ fullword condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /^[isp]+/ condition: $a }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 6 }\",\n      \"a\\0x\\0b\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 8 }\",\n      \"a\\0x\\0x\\0b\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"\\ta\\0b\\0c\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"x\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"x\\ta\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\\t\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0x\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0b\\t\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /\\\\b/ wide condition: $a }\",\n      \"abc\");\n\n  assert_regexp_syntax_error(\")\");\n  assert_true_regexp(\"abc\", \"abc\", \"abc\");\n  assert_false_regexp(\"abc\", \"xbc\");\n  assert_false_regexp(\"abc\", \"axc\");\n  assert_false_regexp(\"abc\", \"abx\");\n  assert_true_regexp(\"abc\", \"xabcx\", \"abc\");\n  assert_true_regexp(\"abc\", \"ababc\", \"abc\");\n  assert_true_regexp(\"a.c\", \"abc\", \"abc\");\n  assert_false_regexp(\"a.b\", \"a\\nb\");\n  assert_false_regexp(\"a.*b\", \"acc\\nccb\");\n  assert_false_regexp(\"a.{4,5}b\", \"acc\\nccb\");\n  assert_true_regexp(\"a.b\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"ab*c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab*bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*bc\", \"abbc\", \"abbc\");\n  assert_true_regexp(\"a.*bb\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"a.*?bbb\", \"abbbbbb\", \"abbb\");\n  assert_true_regexp(\"a.*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a.*c\", \"axyzc\", \"axyzc\");\n  assert_true_regexp(\"ab+c\", \"abbc\", \"abbc\");\n  assert_false_regexp(\"ab+c\", \"ac\");\n  assert_true_regexp(\"ab+\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"ab+?\", \"abbbb\", \"ab\");\n  assert_false_regexp(\"ab+bc\", \"abc\");\n  assert_false_regexp(\"ab+bc\", \"abq\");\n  assert_true_regexp(\"a+b+c\", \"aabbabc\", \"abc\");\n  assert_false_regexp(\"ab?bc\", \"abbbbc\");\n  assert_true_regexp(\"ab?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*?\", \"abbb\", \"a\");\n  assert_true_regexp(\"ab?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab??\", \"ab\", \"a\");\n  assert_true_regexp(\"a(b|x)c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a(b|x)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|.)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|x|y)c\", \"ayc\", \"ayc\");\n  assert_true_regexp(\"(a+|b)*\", \"ab\", \"ab\");\n  assert_true_regexp(\"a|b|c|d|e\", \"e\", \"e\");\n  assert_true_regexp(\"(a|b|c|d|e)f\", \"ef\", \"ef\");\n  assert_true_regexp(\"a|b\", \"a\", \"a\");\n  assert_true_regexp(\".b{2}\", \"abb\", \"abb\");\n  assert_true_regexp(\".b{2,3}\", \"abbb\", \"abbb\");\n  assert_true_regexp(\".b{2,3}?\", \"abbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\".b{2,3}cccc\", \"abbbcccc\", \"abbbcccc\");\n  assert_true_regexp(\".b{2,3}?cccc\", \"abbbcccc\", \"bbbcccc\");\n  assert_true_regexp(\"a.b{2,3}cccc\", \"aabbbcccc\", \"aabbbcccc\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{0,1}?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}bc\", \"bbc\", \"bc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"bc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1,2}c\", \"abbc\", \"abbc\");\n  assert_false_regexp(\"ab{1,2}c\", \"abbbc\");\n  assert_true_regexp(\"ab{1,}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{1,}b\", \"ab\");\n  assert_false_regexp(\"ab{1}c\", \"abbc\");\n  assert_false_regexp(\"ab{1}c\", \"ac\");\n  assert_true_regexp(\"ab{0,}c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab{1,1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{0,}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{,3}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{,2}c\", \"abbbc\");\n  assert_false_regexp(\"ab{4,5}bc\", \"abbbbc\");\n  assert_false_regexp(\"ab{3}c\", \"abbbbc\");  // Issue #817\n  assert_false_regexp(\"ab{4}c\", \"abbbbbc\");\n  assert_false_regexp(\"ab{5}c\", \"abbbbbbc\");\n  assert_true_regexp(\"ab{0,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{0,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{0,4}\", \"abbbbb\", \"abbbb\");\n  assert_true_regexp(\"ab{1,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{1,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{2,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{2,4}\", \"abbbbc\", \"abbbb\");\n  assert_true_regexp(\"ab{3,4}\", \"abbb\", \"abbb\");\n  assert_true_regexp(\"ab{3,5}\", \"abbbbb\", \"abbbbb\");\n  assert_false_regexp(\"ab{3,4}c\", \"abbbbbc\");\n  assert_false_regexp(\"ab{3,4}c\", \"abbc\");\n  assert_false_regexp(\"ab{3,5}c\", \"abbbbbbc\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,1}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,2}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,3}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,4}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{1,1}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{2,2}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\".(abc){0,1}\", \"xabcabcabcabc\", \"xabc\");\n  assert_true_regexp(\".(abc){0,2}\", \"xabcabcabcabc\", \"xabcabc\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"ab{.*}\", \"ab{c}\", \"ab{c}\");\n  assert_true_regexp(\".(aa){1,2}\", \"aaaaaaaaaa\", \"aaaaa\");\n  assert_true_regexp(\"a.(bc.){2}\", \"aabcabca\", \"aabcabca\");\n  assert_true_regexp(\"(ab{1,2}c){1,3}\", \"abbcabc\", \"abbcabc\");\n  assert_true_regexp(\"ab(c|cc){1,3}d\", \"abccccccd\", \"abccccccd\");\n  assert_true_regexp(\"a[bx]c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a[bx]c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a[0-9]*b\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[0-9]*b\", \"a0123456789b\", \"a0123456789b\");\n  assert_true_regexp(\"[0-9a-f]+\", \"0123456789abcdef\", \"0123456789abcdef\");\n  assert_true_regexp(\"[0-9a-f]+\", \"xyz0123456789xyz\", \"0123456789\");\n  assert_true_regexp(\"a[\\\\s\\\\S]b\", \"a b\", \"a b\");\n  assert_true_regexp(\"a[\\\\d\\\\D]b\", \"a1b\", \"a1b\");\n  assert_false_regexp(\"[x-z]+\", \"abc\");\n  assert_true_regexp(\"a[-]?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a[-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[b-]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[b-]\", \"ab\", \"ab\");\n  assert_true_regexp(\"[a-c-e]\", \"b\", \"b\");\n  assert_true_regexp(\"[a-c-e]\", \"-\", \"-\");\n  assert_false_regexp(\"[a-c-e]\", \"d\");\n  assert_regexp_syntax_error(\"[b-a]\");\n  assert_regexp_syntax_error(\"(abc\");\n  assert_regexp_syntax_error(\"abc)\");\n  assert_regexp_syntax_error(\"a[]b\");\n  assert_true_regexp(\"a[\\\\-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[\\\\-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a]\", \"a]\", \"a]\");\n  assert_true_regexp(\"a[]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[\\\\]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[^bc]d\", \"aed\", \"aed\");\n  assert_false_regexp(\"a[^bc]d\", \"abd\");\n  assert_true_regexp(\"a[^-b]c\", \"adc\", \"adc\");\n  assert_false_regexp(\"a[^-b]c\", \"a-c\");\n  assert_false_regexp(\"a[^]b]c\", \"a]c\");\n  assert_true_regexp(\"a[^]b]c\", \"adc\", \"adc\");\n  assert_true_regexp(\"[^ab]*\", \"cde\", \"cde\");\n  assert_regexp_syntax_error(\")(\");\n  assert_true_regexp(\"a\\\\sb\", \"a b\", \"a b\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\tb\", \"a\\tb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\nb\", \"a\\nb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\vb\", \"a\\vb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\fb\", \"a\\fb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a b\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\tb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\rb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\nb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\vb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\fb\");\n  assert_true_regexp(\"\\\\n\\\\r\\\\t\\\\f\\\\a\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"[\\\\n][\\\\r][\\\\t][\\\\f][\\\\a]\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"\\\\x01\\\\x02\\\\x03\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_true_regexp(\"[\\\\x01-\\\\x03]+\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_false_regexp(\"[\\\\x00-\\\\x02]+\", \"\\x03\\x04\\x05\");\n  assert_true_regexp(\"[\\\\x5D]\", \"]\", \"]\");\n  assert_true_regexp(\"[\\\\0x5A-\\\\x5D]\", \"\\x5B\", \"\\x5B\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5C-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"a\\\\wc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a\\\\wc\", \"a_c\", \"a_c\");\n  assert_true_regexp(\"a\\\\wc\", \"a0c\", \"a0c\");\n  assert_false_regexp(\"a\\\\wc\", \"a*c\");\n  assert_true_regexp(\"\\\\w+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"[\\\\w]+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"\\\\D+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\d]+\", \"0123456789\", \"0123456789\");\n  assert_true_regexp(\"[\\\\D]+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\da-fA-F]+\", \"123abc\", \"123abc\");\n  assert_false_regexp(\"^(ab|cd)e\", \"abcde\");\n  assert_true_regexp(\"(abc|)ef\", \"abcdef\", \"ef\");\n  assert_true_regexp(\"(abc|)ef\", \"abcef\", \"abcef\");\n  assert_true_regexp(\"\\\\babc\", \"abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\b\", \"abc\", \"abc\");\n  assert_false_regexp(\"\\\\babc\", \"1abc\");\n  assert_false_regexp(\"abc\\\\b\", \"abc1\");\n  assert_true_regexp(\"abc\\\\s\\\\b\", \"abc x\", \"abc \");\n  assert_false_regexp(\"abc\\\\s\\\\b\", \"abc  \");\n  assert_true_regexp(\"\\\\babc\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\b\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\", \"abcd\", \"abc\");\n  assert_false_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \"abcd\");\n  assert_false_regexp(\"\\\\Babc\", \"abc\");\n  assert_false_regexp(\"abc\\\\B\", \"abc\");\n  assert_true_regexp(\"\\\\Babc\", \"1abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\B\", \"abc1\", \"abc\");\n  assert_false_regexp(\"abc\\\\s\\\\B\", \"abc x\");\n  assert_true_regexp(\"abc\\\\s\\\\B\", \"abc  \", \"abc \");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\B\", \"abcd\", \"abc\");\n  assert_true_regexp(\"\\\\B\\\\w\\\\w\\\\w\", \"abcd\", \"bcd\");\n  assert_false_regexp(\"\\\\B\\\\w\\\\w\\\\w\\\\B\", \"abcd\");\n\n  // This is allowed in most regexp engines but in order to keep the\n  // grammar free of shift/reduce conflicts I've decided not supporting\n  // it. Users can use the (abc|) form instead.\n  assert_regexp_syntax_error(\"(|abc)ef\");\n\n  assert_true_regexp(\"((a)(b)c)(d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"(a|b)c*d\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"(ab|ab*)bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"ac\", \"ac\");\n  assert_true_regexp(\"a([bc]*)c*\", \"a\", \"a\");\n  assert_true_regexp(\"a([bc]*)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]+)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]*)(c+d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a[bcd]*dcdcde\", \"adcdcde\", \"adcdcde\");\n  assert_false_regexp(\"a[bcd]+dcdcde\", \"adcdcde\");\n  assert_true_regexp(\"\\\\((.*), (.*)\\\\)\", \"(a, b)\", \"(a, b)\");\n  assert_true_regexp(\"abc|123$\", \"abcx\", \"abc\");\n  assert_false_regexp(\"abc|123$\", \"123x\");\n  assert_true_regexp(\"abc|^123\", \"123\", \"123\");\n  assert_false_regexp(\"abc|^123\", \"x123\");\n  assert_true_regexp(\"^abc$\", \"abc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"abcc\");\n  assert_true_regexp(\"^abc\", \"abcc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"aabc\");\n  assert_false_regexp(\"abc^\", \"abc\");\n  assert_false_regexp(\"ab^c\", \"abc\");\n  assert_false_regexp(\"a^bcdef\", \"abcdef\")\n  assert_true_regexp(\"abc$\", \"aabc\", \"abc\");\n  assert_false_regexp(\"$abc\", \"abc\");\n  assert_true_regexp(\"(a|a$)bcd\", \"abcd\", \"abcd\");\n  assert_false_regexp(\"(a$|a$)bcd\", \"abcd\");\n  assert_false_regexp(\"(abc$|ab$)\", \"abcd\");\n  assert_true_regexp(\"^a(bc+|b[eh])g|.h$\", \"abhg\", \"abhg\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effgz\", \"effgz\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"ij\", \"ij\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effg\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"bcdd\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"reffgz\", \"effgz\");\n\n  // Test case for issue #324\n  assert_true_regexp(\"whatever|   x.   x\", \"   xy   x\", \"   xy   x\");\n\n  // Test case for issue #503, \\x without two following hex-digits\n  assert_regexp_syntax_error(\"\\\\x0\");\n  assert_regexp_syntax_error(\"\\\\x\");\n\n  assert_regexp_syntax_error(\"x{0,0}\");\n  assert_regexp_syntax_error(\"x{0}\");\n\n  assert_regexp_syntax_error(\"\\\\xxy\");\n\n  // Test case for issue #682\n  assert_true_regexp(\"(a|\\\\b)[a]{1,}\", \"aaaa\", \"aaaa\");\n\n  // Test for integer overflow in repeat interval\n  assert_regexp_syntax_error(\"a{2977952116}\");\n\n  assert_error(\n      \"rule test { strings: $a = /a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(\n      \"rule test { strings: $a = /[a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  // Test case for issue #996\n  assert_error(\n      \"rule test {strings:$=/.{,}? /\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}t/ \\\n        condition: !a == 317 }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}?t/ \\\n        condition: !a == 314 }\",\n      PE32_FILE);\n\n  assert_false_rule(\n      \"rule test { strings: $a = /abc[^d]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /abc[^d]/ condition: $a }\",\n      \"abcd\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /abc[^D]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^D]/ condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^f]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^f]/ condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^F]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n       \"rule test { strings: $a = /abc[^F]/ condition: $a }\",\n       \"abcd\");\n\n  // Test case for issue #1006\n  assert_false_rule_blob(\n       \"rule test { strings: $a = \\\" cmd.exe \\\" nocase wide condition: $a }\",\n       ISSUE_1006);\n}",
        "begin_line": 989,
        "end_line": 1423,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_strings#370",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_strings()",
        "snippet": "static void test_strings()\n{\n  char* str = \"---- abc ---- xyz\";\n  uint8_t blob[] = \"---- a\\0b\\0c\\0 -\\0-\\0-\\0-\\0x\\0y\\0z\\0\";\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"a\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ab\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"xyz\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" nocase fullword condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"aBc\\\" nocase  condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      str);\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"a\\\" fullword condition: $a }\",\n      str);\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"ab\\\" fullword condition: $a }\",\n      str);\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      str);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"a\\\" wide condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"a\\\" wide ascii condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"ab\\\" wide condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"ab\\\" wide ascii condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide nocase fullword condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"aBc\\\" wide nocase condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"aBc\\\" wide ascii nocase condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"---xyz\\\" wide nocase condition: $a }\",\n      blob);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"abc\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"xabcx\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"xabc\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"abcx\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide condition: $a }\",\n      \"a\\1b\\0c\\0d\\0e\\0f\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"abcdef\\\" wide condition: $a }\",\n      \"a\\0b\\0c\\0d\\0e\\0f\\1\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" ascii wide fullword condition: $a }\",\n      \"abcx\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" ascii wide fullword condition: $a }\",\n      \"a\\0abc\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"x\\0a\\0b\\0c\\0x\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"ab\\\" wide fullword condition: $a }\",\n      \"x\\0a\\0b\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"x\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"x\\001a\\0b\\0c\\0\");\n\n  assert_true_rule(\n      \"rule test {\\n\\\n         strings:\\n\\\n             $a = \\\"abcdef\\\"\\n\\\n             $b = \\\"cdef\\\"\\n\\\n             $c = \\\"ef\\\"\\n\\\n         condition:\\n\\\n             all of them\\n\\\n       }\", \"abcdef\");\n\n  assert_true_rule_file(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"This program cannot\\\" xor\\n\\\n      condition:\\n\\\n        #a == 255\\n\\\n    }\", \"tests/data/xor.out\");\n\n  assert_true_rule_file(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"This program cannot\\\" xor ascii\\n\\\n      condition:\\n\\\n        #a == 256\\n\\\n    }\", \"tests/data/xor.out\");\n\n  assert_true_rule_file(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"This program cannot\\\" xor wide\\n\\\n      condition:\\n\\\n        #a == 256\\n\\\n    }\", \"tests/data/xorwide.out\");\n\n  assert_true_rule_file(\n    \"rule test {\\n\\\n      strings:\\n\\\n        $a = \\\"ab\\\" xor nocase\\n\\\n      condition:\\n\\\n        #a == 1084\\n\\\n    }\", \"tests/data/xornocase.out\");\n}",
        "begin_line": 370,
        "end_line": 544,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_syntax#354",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_syntax()",
        "snippet": "static void test_syntax()\n{\n  assert_error(\n      \"rule test { strings: $a = \\\"a\\\" $a = \\\"a\\\" condition: all of them }\",\n      ERROR_DUPLICATED_STRING_IDENTIFIER);\n}",
        "begin_line": 354,
        "end_line": 359,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_time_module#1742",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_time_module()",
        "snippet": "static void test_time_module()\n{\n    assert_true_rule(\n        \"import \\\"time\\\" \\\n        rule test { condition: time.now() > 0 }\",\n        NULL);\n}",
        "begin_line": 1742,
        "end_line": 1748,
        "is_bug": false
    },
    {
        "name": "tests.test-rules.test_wildcard_strings#547",
        "src_path": "tests/test-rules.c",
        "class_name": "tests.test-rules",
        "signature": "tests.test-rules.test_wildcard_strings()",
        "snippet": "static void test_wildcard_strings()\n{\n  assert_true_rule_blob(\n      \"rule test {\\n\\\n         strings:\\n\\\n             $s1 = \\\"abc\\\"\\n\\\n             $s2 = \\\"xyz\\\"\\n\\\n         condition:\\n\\\n             for all of ($*) : ($)\\n\\\n      }\",\n      \"---- abc ---- A\\x00\"\"B\\x00\"\"C\\x00 ---- xyz\");\n}",
        "begin_line": 547,
        "end_line": 558,
        "is_bug": false
    },
    {
        "name": "tests.test-stack.defects4cpp_test_index#4",
        "src_path": "tests/test-stack.c",
        "class_name": "tests.test-stack",
        "signature": "tests.test-stack.defects4cpp_test_index()",
        "snippet": "static int defects4cpp_test_index() {\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);\n  luaL_dofile(L, \"tests/defects4cpp.lua\");\n  int ret = lua_tonumber(L, -1);\n  lua_close(L);\n  return ret;\n}",
        "begin_line": 4,
        "end_line": 11,
        "is_bug": false
    },
    {
        "name": "tests.test-stack.main#37",
        "src_path": "tests/test-stack.c",
        "class_name": "tests.test-stack",
        "signature": "tests.test-stack.main(int argc, char** argv)",
        "snippet": "int main(int argc, char** argv)\n{\n  YR_STACK* stack;\n\n  int item;\n\n  yr_initialize();\n  yr_stack_create(1, sizeof(item),  &stack);\n\n  int index = defects4cpp_test_index();\n  switch (index) {\n    case 244:\n  item = 1;\n\n  if (yr_stack_push(stack, &item) != ERROR_SUCCESS)\n    exit(EXIT_FAILURE);\n\n  item = 2;\n\n  if (yr_stack_push(stack, &item) != ERROR_SUCCESS)\n    exit(EXIT_FAILURE);\n\n  item = 3;\n\n  if (yr_stack_push(stack, &item) != ERROR_SUCCESS)\n    exit(EXIT_FAILURE);\n\n  item = 4;\n\n  if (yr_stack_push(stack, &item) != ERROR_SUCCESS)\n    exit(EXIT_FAILURE);\n\n  if (!yr_stack_pop(stack, &item) || item != 4)\n    exit(EXIT_FAILURE);\n\n  if (!yr_stack_pop(stack, &item) || item != 3)\n    exit(EXIT_FAILURE);\n\n  if (!yr_stack_pop(stack, &item) || item != 2)\n    exit(EXIT_FAILURE);\n\n  if (!yr_stack_pop(stack, &item) || item != 1)\n    exit(EXIT_FAILURE);\n\n  if (yr_stack_pop(stack, &item) || item != 1)\n    exit(EXIT_FAILURE);\n\n        break;\n  }\n  yr_stack_destroy(stack);\n}",
        "begin_line": 37,
        "end_line": 87,
        "is_bug": false
    },
    {
        "name": "tests.test-version.main#33",
        "src_path": "tests/test-version.c",
        "class_name": "tests.test-version",
        "signature": "tests.test-version.main (int argc, char **argv)",
        "snippet": "int main (int argc, char **argv)\n{\n  // make sure that versions defined in configure.ac and in\n  // libyara/include/yara/libyara.h are in sync.\n\n  return strcmp(PACKAGE_VERSION, YR_VERSION);\n}",
        "begin_line": 33,
        "end_line": 39,
        "is_bug": false
    },
    {
        "name": "tests.util._assert_atoms#266",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util._assert_atoms(     RE_AST* re_ast, int expected_atom_count, atom* expected_atoms)",
        "snippet": "void _assert_atoms(\n    RE_AST* re_ast,\n    int expected_atom_count,\n    atom* expected_atoms)\n{\n  YR_ATOMS_CONFIG c;\n  YR_ATOM_LIST_ITEM* atoms;\n  YR_ATOM_LIST_ITEM* atom;\n\n  int min_atom_quality;\n\n  c.get_atom_quality = yr_atoms_heuristic_quality;\n\n  yr_atoms_extract_from_re(&c, re_ast, 0, &atoms, &min_atom_quality);\n\n  atom = atoms;\n\n  while (atom != NULL)\n  {\n    if (expected_atom_count == 0)\n      exit(EXIT_FAILURE);\n\n    if (atom->atom.length != expected_atoms->length ||\n       memcmp(atom->atom.bytes, expected_atoms->data, atom->atom.length) != 0)\n    {\n      exit(EXIT_FAILURE);\n    }\n\n    expected_atoms++;\n    expected_atom_count--;\n    atom = atom->next;\n  }\n}",
        "begin_line": 266,
        "end_line": 298,
        "is_bug": false
    },
    {
        "name": "tests.util.assert_hex_atoms#314",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util.assert_hex_atoms(     char* hex, int expected_atom_count, atom* expected_atoms)",
        "snippet": "void assert_hex_atoms(\n    char* hex,\n    int expected_atom_count,\n    atom* expected_atoms)\n{\n  RE_AST* re_ast;\n  RE_ERROR re_error;\n\n  yr_re_parse_hex(hex, &re_ast, &re_error);\n  _assert_atoms(re_ast, expected_atom_count, expected_atoms);\n}",
        "begin_line": 314,
        "end_line": 324,
        "is_bug": false
    },
    {
        "name": "tests.util.assert_re_atoms#301",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util.assert_re_atoms(     char* re, int expected_atom_count, atom* expected_atoms)",
        "snippet": "void assert_re_atoms(\n    char* re,\n    int expected_atom_count,\n    atom* expected_atoms)\n{\n  RE_AST* re_ast;\n  RE_ERROR re_error;\n\n  yr_re_parse(re, &re_ast, &re_error);\n  _assert_atoms(re_ast, expected_atom_count, expected_atoms);\n}",
        "begin_line": 301,
        "end_line": 311,
        "is_bug": false
    },
    {
        "name": "tests.util.callback_function#43",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util.callback_function(     int error_level, const char* file_name, int line_number, const char* message, void* user_data)",
        "snippet": "static void callback_function(\n    int error_level,\n    const char* file_name,\n    int line_number,\n    const char* message,\n    void* user_data)\n{\n  if (error_level == YARA_ERROR_LEVEL_WARNING)\n    (*((int*) user_data))++;\n\n  snprintf(\n      compile_error,\n      sizeof(compile_error),\n      \"line %d: %s\",\n      line_number,\n      message);\n}",
        "begin_line": 43,
        "end_line": 59,
        "is_bug": false
    },
    {
        "name": "tests.util.capture_matches#171",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util.capture_matches(     int message, void* message_data, void* user_data)",
        "snippet": "static int capture_matches(\n    int message,\n    void* message_data,\n    void* user_data)\n{\n  if (message == CALLBACK_MSG_RULE_MATCHING)\n  {\n    find_string_t* f = (find_string_t*) user_data;\n\n    YR_RULE* rule = (YR_RULE*) message_data;\n    YR_STRING* string;\n\n    yr_rule_strings_foreach(rule, string)\n    {\n      YR_MATCH* match;\n\n      yr_string_matches_foreach(string, match)\n      {\n        if (strlen(f->expected) == match->data_length &&\n            strncmp(f->expected, (char*)(match->data), match->data_length) == 0)\n        {\n          f->found++;\n        }\n      }\n    }\n  }\n\n  return CALLBACK_CONTINUE;\n}",
        "begin_line": 171,
        "end_line": 199,
        "is_bug": false
    },
    {
        "name": "tests.util.capture_string#202",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util.capture_string(     char* rule, char* string, char* expected_string)",
        "snippet": "int capture_string(\n    char* rule,\n    char* string,\n    char* expected_string)\n{\n  YR_RULES* rules;\n\n  if (compile_rule(rule, &rules) != ERROR_SUCCESS)\n  {\n    fprintf(stderr, \"failed to compile rule << %s >>: %s\\n\", rule, compile_error);\n    exit(EXIT_FAILURE);\n  }\n\n  find_string_t f;\n\n  f.found = 0;\n  f.expected = expected_string;\n\n  if (yr_rules_scan_mem(rules, (uint8_t*)string, strlen(string), 0,\n                        capture_matches, &f, 0) != ERROR_SUCCESS)\n  {\n    fprintf(stderr, \"yr_rules_scan_mem: error\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_rules_destroy(rules);\n\n  return f.found;\n}",
        "begin_line": 202,
        "end_line": 230,
        "is_bug": false
    },
    {
        "name": "tests.util.compile_rule#62",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util.compile_rule(     char* string, YR_RULES** rules)",
        "snippet": "int compile_rule(\n    char* string,\n    YR_RULES** rules)\n{\n  YR_COMPILER* compiler = NULL;\n  int result = ERROR_SUCCESS;\n\n  compile_error[0] = '\\0';\n  warnings = 0;\n\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    goto _exit;\n  }\n\n  yr_compiler_set_callback(compiler, callback_function, &warnings);\n\n  if (yr_compiler_add_string(compiler, string, NULL) != 0)\n  {\n    result = compiler->last_error;\n    goto _exit;\n  }\n\n  result = yr_compiler_get_rules(compiler, rules);\n\n_exit:\n  yr_compiler_destroy(compiler);\n  return result;\n}",
        "begin_line": 62,
        "end_line": 91,
        "is_bug": false
    },
    {
        "name": "tests.util.count_matches#94",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util.count_matches(     int message, void* message_data, void* user_data)",
        "snippet": "int count_matches(\n    int message,\n    void* message_data,\n    void* user_data)\n{\n  if (message == CALLBACK_MSG_RULE_MATCHING)\n  {\n    (*(int*) user_data)++;\n  }\n\n  return CALLBACK_CONTINUE;\n}",
        "begin_line": 94,
        "end_line": 105,
        "is_bug": false
    },
    {
        "name": "tests.util.do_nothing#107",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util.do_nothing(     int message, void* message_data, void* user_data)",
        "snippet": "int do_nothing(\n    int message,\n    void* message_data,\n    void* user_data)\n{\n  return CALLBACK_CONTINUE;\n}",
        "begin_line": 107,
        "end_line": 113,
        "is_bug": false
    },
    {
        "name": "tests.util.matches_blob#116",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util.matches_blob(     char* rule, uint8_t* blob, size_t len)",
        "snippet": "int matches_blob(\n    char* rule,\n    uint8_t* blob,\n    size_t len)\n{\n  YR_RULES* rules;\n\n  if (blob == NULL)\n  {\n    blob = (uint8_t*) \"dummy\";\n    len = 5;\n  }\n\n  if (compile_rule(rule, &rules) != ERROR_SUCCESS)\n  {\n    fprintf(stderr, \"failed to compile rule << %s >>: %s\\n\", rule, compile_error);\n    exit(EXIT_FAILURE);\n  }\n\n  int matches = 0;\n  int scan_result = yr_rules_scan_mem(\n      rules, blob, len, 0, count_matches, &matches, 0);\n\n  if (scan_result != ERROR_SUCCESS)\n  {\n    fprintf(stderr, \"yr_rules_scan_mem: error\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  yr_rules_destroy(rules);\n\n  return matches;\n}",
        "begin_line": 116,
        "end_line": 148,
        "is_bug": false
    },
    {
        "name": "tests.util.matches_string#151",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util.matches_string(     char* rule, char* string)",
        "snippet": "int matches_string(\n    char* rule,\n    char* string)\n{\n  size_t len = 0;\n\n  if (string != NULL)\n    len = strlen(string);\n\n  return matches_blob(rule, (uint8_t*)string, len);\n}",
        "begin_line": 151,
        "end_line": 161,
        "is_bug": false
    },
    {
        "name": "tests.util.read_file#233",
        "src_path": "tests/util.c",
        "class_name": "tests.util",
        "signature": "tests.util.read_file(     char* filename, char** buf)",
        "snippet": "int read_file(\n    char* filename,\n    char** buf)\n{\n  int fd;\n\n  if ((fd = open(filename, O_RDONLY)) < 0)\n    return -1;\n\n  size_t sz = lseek(fd, 0, SEEK_END);\n  int rc = -1;\n\n  if (sz == -1)\n    goto _exit;\n\n  if (lseek(fd, 0, SEEK_SET) != 0)\n    goto _exit;\n\n  if ((*buf = malloc(sz)) == NULL)\n    goto _exit;\n\n  if ((rc = read(fd, *buf, sz)) != sz)\n  {\n    rc = -1;\n    free(*buf);\n  }\n\n_exit:\n  close(fd);\n  return rc;\n}",
        "begin_line": 233,
        "end_line": 263,
        "is_bug": false
    }
]