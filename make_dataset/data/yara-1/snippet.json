[
    {
        "name": "libyara.ahocorasick._yr_ac_state_destroy#227",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick._yr_ac_state_destroy(     YR_AC_STATE* state)",
        "snippet": "static int _yr_ac_state_destroy(\n    YR_AC_STATE* state)\n{\n  YR_AC_STATE* child_state = state->first_child;\n\n  while (child_state != NULL)\n  {\n    YR_AC_STATE* next_child_state = child_state->siblings;\n    _yr_ac_state_destroy(child_state);\n    child_state = next_child_state;\n  }\n\n  yr_free(state);\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 227,
        "end_line": 242,
        "is_bug": false
    },
    {
        "name": "libyara.ahocorasick.yr_ac_automaton_create#770",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick.yr_ac_automaton_create(     YR_AC_AUTOMATON** automaton)",
        "snippet": "int yr_ac_automaton_create(\n    YR_AC_AUTOMATON** automaton)\n{\n  YR_AC_AUTOMATON* new_automaton;\n  YR_AC_STATE* root_state;\n\n  new_automaton = (YR_AC_AUTOMATON*) yr_malloc(sizeof(YR_AC_AUTOMATON));\n  root_state = (YR_AC_STATE*) yr_malloc(sizeof(YR_AC_STATE));\n\n  if (new_automaton == NULL || root_state == NULL)\n  {\n    yr_free(new_automaton);\n    yr_free(root_state);\n\n    return ERROR_INSUFFICIENT_MEMORY;\n  }\n\n  root_state->depth = 0;\n  root_state->matches = NULL;\n  root_state->failure = NULL;\n  root_state->first_child = NULL;\n  root_state->siblings = NULL;\n  root_state->t_table_slot = 0;\n\n  new_automaton->root = root_state;\n  new_automaton->m_table = NULL;\n  new_automaton->t_table = NULL;\n  new_automaton->bitmask = NULL;\n  new_automaton->tables_size = 0;\n\n  *automaton = new_automaton;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 770,
        "end_line": 803,
        "is_bug": false
    },
    {
        "name": "libyara.ahocorasick.yr_ac_automaton_destroy#812",
        "src_path": "libyara/ahocorasick.c",
        "class_name": "libyara.ahocorasick",
        "signature": "libyara.ahocorasick.yr_ac_automaton_destroy(     YR_AC_AUTOMATON* automaton)",
        "snippet": "int yr_ac_automaton_destroy(\n    YR_AC_AUTOMATON* automaton)\n{\n  _yr_ac_state_destroy(automaton->root);\n\n  yr_free(automaton->t_table);\n  yr_free(automaton->m_table);\n  yr_free(automaton->bitmask);\n  yr_free(automaton);\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 812,
        "end_line": 823,
        "is_bug": false
    },
    {
        "name": "libyara.arena._yr_arena_make_ptr_relocatable#171",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena._yr_arena_make_ptr_relocatable(     YR_ARENA* arena, void* base, va_list offsets)",
        "snippet": "static int _yr_arena_make_ptr_relocatable(\n    YR_ARENA* arena,\n    void* base,\n    va_list offsets)\n{\n  YR_RELOC* reloc;\n  YR_ARENA_PAGE* page;\n\n  size_t offset;\n  size_t base_offset;\n\n  int result = ERROR_SUCCESS;\n\n  // If the arena must be relocatable.\n  assert(arena->flags & ARENA_FLAGS_RELOCATABLE);\n\n  page = _yr_arena_page_for_address(arena, base);\n\n  assert(page != NULL);\n\n  base_offset = (uint8_t*) base - page->address;\n  offset = va_arg(offsets, size_t);\n\n  while (offset != -1)\n  {\n    assert(page->used >= sizeof(int64_t));\n    assert(base_offset + offset <= page->used - sizeof(int64_t));\n\n    reloc = (YR_RELOC*) yr_malloc(sizeof(YR_RELOC));\n\n    if (reloc == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    reloc->offset = (uint32_t) (base_offset + offset);\n    reloc->next = NULL;\n\n    if (page->reloc_list_head == NULL)\n      page->reloc_list_head = reloc;\n\n    if (page->reloc_list_tail != NULL)\n      page->reloc_list_tail->next = reloc;\n\n    page->reloc_list_tail = reloc;\n    offset = va_arg(offsets, size_t);\n  }\n\n  return result;\n}",
        "begin_line": 171,
        "end_line": 218,
        "is_bug": false
    },
    {
        "name": "libyara.arena._yr_arena_new_page#82",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena._yr_arena_new_page(     size_t size)",
        "snippet": "static YR_ARENA_PAGE* _yr_arena_new_page(\n    size_t size)\n{\n  YR_ARENA_PAGE* new_page;\n\n  new_page = (YR_ARENA_PAGE*) yr_malloc(sizeof(YR_ARENA_PAGE));\n\n  if (new_page == NULL)\n    return NULL;\n\n  new_page->address = (uint8_t*) yr_malloc(size);\n\n  if (new_page->address == NULL)\n  {\n    yr_free(new_page);\n    return NULL;\n  }\n\n  new_page->size = size;\n  new_page->used = 0;\n  new_page->next = NULL;\n  new_page->prev = NULL;\n  new_page->reloc_list_head = NULL;\n  new_page->reloc_list_tail = NULL;\n\n  return new_page;\n}",
        "begin_line": 82,
        "end_line": 108,
        "is_bug": false
    },
    {
        "name": "libyara.arena._yr_arena_page_for_address#125",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena._yr_arena_page_for_address(     YR_ARENA* arena, void* address)",
        "snippet": "static YR_ARENA_PAGE* _yr_arena_page_for_address(\n    YR_ARENA* arena,\n    void* address)\n{\n  YR_ARENA_PAGE* page;\n\n  // Most of the times this function is called with an address within\n  // the current page, let's check the current page first to avoid\n  // looping through the page list.\n\n  page = arena->current_page;\n\n  if (page != NULL &&\n      (uint8_t*) address >= page->address &&\n      (uint8_t*) address < page->address + page->used)\n    return page;\n\n  page = arena->page_list_head;\n\n  while (page != NULL)\n  {\n    if ((uint8_t*) address >= page->address &&\n        (uint8_t*) address < page->address + page->used)\n      return page;\n\n    page = page->next;\n  }\n\n  return NULL;\n}",
        "begin_line": 125,
        "end_line": 154,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_allocate_memory#592",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_allocate_memory(     YR_ARENA* arena, size_t size, void** allocated_memory)",
        "snippet": "int yr_arena_allocate_memory(\n    YR_ARENA* arena,\n    size_t size,\n    void** allocated_memory)\n{\n  FAIL_ON_ERROR(yr_arena_reserve_memory(arena, size));\n\n  *allocated_memory = arena->current_page->address + \\\n                      arena->current_page->used;\n\n  arena->current_page->used += size;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 592,
        "end_line": 605,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_allocate_struct#640",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_allocate_struct(     YR_ARENA* arena, size_t size, void** allocated_memory, ...)",
        "snippet": "int yr_arena_allocate_struct(\n    YR_ARENA* arena,\n    size_t size,\n    void** allocated_memory,\n    ...)\n{\n  int result;\n\n  va_list offsets;\n  va_start(offsets, allocated_memory);\n\n  result = yr_arena_allocate_memory(arena, size, allocated_memory);\n\n  if (result == ERROR_SUCCESS && arena->flags & ARENA_FLAGS_RELOCATABLE)\n    result = _yr_arena_make_ptr_relocatable(arena, *allocated_memory, offsets);\n\n  va_end(offsets);\n\n  if (result == ERROR_SUCCESS)\n    memset(*allocated_memory, 0, size);\n\n  return result;\n}",
        "begin_line": 640,
        "end_line": 662,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_base_address#327",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_base_address(   YR_ARENA* arena)",
        "snippet": "void* yr_arena_base_address(\n  YR_ARENA* arena)\n{\n  if (arena->page_list_head->used == 0)\n    return NULL;\n\n  return arena->page_list_head->address;\n}",
        "begin_line": 327,
        "end_line": 334,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_create#236",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_create(     size_t initial_size, int flags, YR_ARENA** arena)",
        "snippet": "int yr_arena_create(\n    size_t initial_size,\n    int flags,\n    YR_ARENA** arena)\n{\n  YR_ARENA* new_arena;\n  YR_ARENA_PAGE* new_page;\n\n  *arena = NULL;\n  new_arena = (YR_ARENA*) yr_malloc(sizeof(YR_ARENA));\n\n  if (new_arena == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  new_page = _yr_arena_new_page(initial_size);\n\n  if (new_page == NULL)\n  {\n    yr_free(new_arena);\n    return ERROR_INSUFFICIENT_MEMORY;\n  }\n\n  new_arena->page_list_head = new_page;\n  new_arena->current_page = new_page;\n  new_arena->flags = flags | ARENA_FLAGS_COALESCED;\n\n  *arena = new_arena;\n  return ERROR_SUCCESS;\n}",
        "begin_line": 236,
        "end_line": 264,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_destroy#279",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_destroy(     YR_ARENA* arena)",
        "snippet": "void yr_arena_destroy(\n    YR_ARENA* arena)\n{\n  YR_RELOC* reloc;\n  YR_RELOC* next_reloc;\n  YR_ARENA_PAGE* page;\n  YR_ARENA_PAGE* next_page;\n\n  if (arena == NULL)\n    return;\n\n  page = arena->page_list_head;\n\n  while(page != NULL)\n  {\n    next_page = page->next;\n    reloc = page->reloc_list_head;\n\n    while (reloc != NULL)\n    {\n      next_reloc = reloc->next;\n      yr_free(reloc);\n      reloc = next_reloc;\n    }\n\n    yr_free(page->address);\n    yr_free(page);\n\n    page = next_page;\n  }\n\n  yr_free(arena);\n}",
        "begin_line": 279,
        "end_line": 311,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_make_ptr_relocatable#680",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_make_ptr_relocatable(     YR_ARENA* arena, void* base, ...)",
        "snippet": "int yr_arena_make_ptr_relocatable(\n    YR_ARENA* arena,\n    void* base,\n    ...)\n{\n  int result;\n\n  va_list offsets;\n  va_start(offsets, base);\n\n  result = _yr_arena_make_ptr_relocatable(arena, base, offsets);\n\n  va_end(offsets);\n\n  return result;\n}",
        "begin_line": 680,
        "end_line": 695,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_reserve_memory#528",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_reserve_memory(     YR_ARENA* arena, size_t size)",
        "snippet": "int yr_arena_reserve_memory(\n    YR_ARENA* arena,\n    size_t size)\n{\n  YR_ARENA_PAGE* new_page;\n  size_t new_page_size;\n  uint8_t* new_page_address;\n\n  if (size > free_space(arena->current_page))\n  {\n    // Requested space is bigger than current page's empty space,\n    // lets calculate the size for a new page.\n\n    new_page_size = arena->current_page->size * 2;\n\n    while (new_page_size < size)\n      new_page_size *= 2;\n\n    if (arena->current_page->used == 0)\n    {\n      // Current page is not used at all, it can be reallocated.\n\n      new_page_address = (uint8_t*) yr_realloc(\n          arena->current_page->address,\n          new_page_size);\n\n      if (new_page_address == NULL)\n        return ERROR_INSUFFICIENT_MEMORY;\n\n      arena->current_page->address = new_page_address;\n      arena->current_page->size = new_page_size;\n    }\n    else\n    {\n      new_page = _yr_arena_new_page(new_page_size);\n\n      if (new_page == NULL)\n        return ERROR_INSUFFICIENT_MEMORY;\n\n      new_page->prev = arena->current_page;\n      arena->current_page->next = new_page;\n      arena->current_page = new_page;\n      arena->flags &= ~ARENA_FLAGS_COALESCED;\n    }\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 528,
        "end_line": 575,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_write_data#714",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_write_data(     YR_ARENA* arena, const void* data, size_t size, void** written_data)",
        "snippet": "int yr_arena_write_data(\n    YR_ARENA* arena,\n    const void* data,\n    size_t size,\n    void** written_data)\n{\n  void* output;\n  int result;\n\n  if (size > free_space(arena->current_page))\n  {\n    result = yr_arena_allocate_memory(arena, size, &output);\n\n    if (result != ERROR_SUCCESS)\n      return result;\n  }\n  else\n  {\n    output = arena->current_page->address + arena->current_page->used;\n    arena->current_page->used += size;\n  }\n\n  memcpy(output, data, size);\n\n  if (written_data != NULL)\n    *written_data = output;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 714,
        "end_line": 742,
        "is_bug": false
    },
    {
        "name": "libyara.arena.yr_arena_write_string#760",
        "src_path": "libyara/arena.c",
        "class_name": "libyara.arena",
        "signature": "libyara.arena.yr_arena_write_string(     YR_ARENA* arena, const char* string, char** written_string)",
        "snippet": "int yr_arena_write_string(\n    YR_ARENA* arena,\n    const char* string,\n    char** written_string)\n{\n  return yr_arena_write_data(\n      arena,\n      (void*) string,\n      strlen(string) + 1,\n      (void**) written_string);\n}",
        "begin_line": 760,
        "end_line": 770,
        "is_bug": false
    },
    {
        "name": "libyara.compiler._yr_compiler_define_variable#857",
        "src_path": "libyara/compiler.c",
        "class_name": "libyara.compiler",
        "signature": "libyara.compiler._yr_compiler_define_variable(     YR_COMPILER* compiler, YR_EXTERNAL_VARIABLE* external)",
        "snippet": "int _yr_compiler_define_variable(\n    YR_COMPILER* compiler,\n    YR_EXTERNAL_VARIABLE* external)\n{\n  YR_EXTERNAL_VARIABLE* ext;\n  YR_OBJECT* object;\n\n  char* id;\n\n  object = (YR_OBJECT*) yr_hash_table_lookup(\n      compiler->objects_table,\n      external->identifier,\n      NULL);\n\n  if (object != NULL)\n    return ERROR_DUPLICATED_EXTERNAL_VARIABLE;\n\n  FAIL_ON_ERROR(yr_arena_write_string(\n      compiler->sz_arena,\n      external->identifier,\n      &id));\n\n  FAIL_ON_ERROR(yr_arena_allocate_struct(\n      compiler->externals_arena,\n      sizeof(YR_EXTERNAL_VARIABLE),\n      (void**) &ext,\n      offsetof(YR_EXTERNAL_VARIABLE, identifier),\n      EOL));\n\n  ext->identifier = id;\n  ext->type = external->type;\n  ext->value = external->value;\n\n  if (external->type == EXTERNAL_VARIABLE_TYPE_STRING)\n  {\n    char* val;\n\n    FAIL_ON_ERROR(yr_arena_write_string(\n        compiler->sz_arena,\n        external->value.s,\n        &val));\n\n    ext->value.s = val;\n\n    FAIL_ON_ERROR(yr_arena_make_ptr_relocatable(\n        compiler->externals_arena,\n        ext,\n        offsetof(YR_EXTERNAL_VARIABLE, value.s),\n        EOL));\n  }\n\n  FAIL_ON_ERROR(yr_object_from_external_variable(\n      external,\n      &object));\n\n  FAIL_ON_ERROR(yr_hash_table_add(\n      compiler->objects_table,\n      external->identifier,\n      NULL,\n      (void*) object));\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 857,
        "end_line": 919,
        "is_bug": false
    },
    {
        "name": "libyara.compiler._yr_compiler_pop_file_name#454",
        "src_path": "libyara/compiler.c",
        "class_name": "libyara.compiler",
        "signature": "libyara.compiler._yr_compiler_pop_file_name(     YR_COMPILER* compiler)",
        "snippet": "void _yr_compiler_pop_file_name(\n    YR_COMPILER* compiler)\n{\n  if (compiler->file_name_stack_ptr > 0)\n  {\n    compiler->file_name_stack_ptr--;\n    yr_free(compiler->file_name_stack[compiler->file_name_stack_ptr]);\n    compiler->file_name_stack[compiler->file_name_stack_ptr] = NULL;\n  }\n}",
        "begin_line": 454,
        "end_line": 463,
        "is_bug": false
    },
    {
        "name": "libyara.compiler._yr_compiler_set_namespace#480",
        "src_path": "libyara/compiler.c",
        "class_name": "libyara.compiler",
        "signature": "libyara.compiler._yr_compiler_set_namespace(     YR_COMPILER* compiler, const char* namespace_)",
        "snippet": "static int _yr_compiler_set_namespace(\n    YR_COMPILER* compiler,\n    const char* namespace_)\n{\n  YR_NAMESPACE* ns;\n\n  char* ns_name;\n  int result;\n  int i;\n  bool found;\n\n  ns = (YR_NAMESPACE*) yr_arena_base_address(compiler->namespaces_arena);\n  found = false;\n\n  for (i = 0; i < compiler->namespaces_count; i++)\n  {\n    if (strcmp(ns->name, namespace_) == 0)\n    {\n      found = true;\n      break;\n    }\n\n    ns = (YR_NAMESPACE*) yr_arena_next_address(\n        compiler->namespaces_arena,\n        ns,\n        sizeof(YR_NAMESPACE));\n  }\n\n  if (!found)\n  {\n    result = yr_arena_write_string(\n        compiler->sz_arena,\n        namespace_,\n        &ns_name);\n\n    if (result == ERROR_SUCCESS)\n      result = yr_arena_allocate_struct(\n          compiler->namespaces_arena,\n          sizeof(YR_NAMESPACE),\n          (void**) &ns,\n          offsetof(YR_NAMESPACE, name),\n          EOL);\n\n    if (result != ERROR_SUCCESS)\n      return result;\n\n    ns->name = ns_name;\n\n    for (i = 0; i < YR_MAX_THREADS; i++)\n      ns->t_flags[i] = 0;\n\n    compiler->namespaces_count++;\n  }\n\n  compiler->current_namespace = ns;\n  return ERROR_SUCCESS;\n}",
        "begin_line": 480,
        "end_line": 536,
        "is_bug": false
    },
    {
        "name": "libyara.compiler.yr_compiler_add_string#607",
        "src_path": "libyara/compiler.c",
        "class_name": "libyara.compiler",
        "signature": "libyara.compiler.yr_compiler_add_string(     YR_COMPILER* compiler, const char* rules_string, const char* namespace_)",
        "snippet": "YR_API int yr_compiler_add_string(\n    YR_COMPILER* compiler,\n    const char* rules_string,\n    const char* namespace_)\n{\n  // Don't allow calls to yr_compiler_add_string() after\n  // yr_compiler_get_rules() has been called.\n\n  assert(compiler->compiled_rules_arena == NULL);\n\n  // Don't allow calls to yr_compiler_add_string() if a previous call to\n  // yr_compiler_add_XXXX failed.\n\n  assert(compiler->errors == 0);\n\n  if (namespace_ != NULL)\n    compiler->last_error = _yr_compiler_set_namespace(compiler, namespace_);\n  else\n    compiler->last_error = _yr_compiler_set_namespace(compiler, \"default\");\n\n  if (compiler->last_error != ERROR_SUCCESS)\n  {\n    compiler->errors++;\n    return compiler->errors;\n  }\n\n  return yr_lex_parse_rules_string(rules_string, compiler);\n}",
        "begin_line": 607,
        "end_line": 634,
        "is_bug": false
    },
    {
        "name": "libyara.compiler.yr_compiler_create#154",
        "src_path": "libyara/compiler.c",
        "class_name": "libyara.compiler",
        "signature": "libyara.compiler.yr_compiler_create(     YR_COMPILER** compiler)",
        "snippet": "YR_API int yr_compiler_create(\n    YR_COMPILER** compiler)\n{\n  int result;\n  YR_COMPILER* new_compiler;\n\n  new_compiler = (YR_COMPILER*) yr_calloc(1, sizeof(YR_COMPILER));\n\n  if (new_compiler == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  new_compiler->errors = 0;\n  new_compiler->callback = NULL;\n  new_compiler->include_callback = _yr_compiler_default_include_callback;\n  new_compiler->incl_clbk_user_data = NULL;\n  new_compiler->include_free = _yr_compiler_default_include_free;\n  new_compiler->re_ast_callback = NULL;\n  new_compiler->re_ast_clbk_user_data = NULL;\n  new_compiler->last_error = ERROR_SUCCESS;\n  new_compiler->last_error_line = 0;\n  new_compiler->current_line = 0;\n  new_compiler->file_name_stack_ptr = 0;\n  new_compiler->fixup_stack_head = NULL;\n  new_compiler->loop_depth = 0;\n  new_compiler->loop_for_of_mem_offset = -1;\n  new_compiler->compiled_rules_arena = NULL;\n  new_compiler->namespaces_count = 0;\n  new_compiler->current_rule = NULL;\n  new_compiler->atoms_config.get_atom_quality = yr_atoms_heuristic_quality;\n  new_compiler->atoms_config.quality_warning_threshold = \\\n      YR_ATOM_QUALITY_WARNING_THRESHOLD;\n\n  result = yr_hash_table_create(10007, &new_compiler->rules_table);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_hash_table_create(10007, &new_compiler->objects_table);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_hash_table_create(101, &new_compiler->strings_table);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_create(\n        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->sz_arena);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_create(\n        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->rules_arena);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_create(\n        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->strings_arena);\n\n  if (result == ERROR_SUCCESS)\n      result = yr_arena_create(\n        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->code_arena);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_create(\n        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->re_code_arena);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_create(\n        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->externals_arena);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_create(\n        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->namespaces_arena);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_create(\n        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->metas_arena);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_create(\n        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->automaton_arena);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_create(\n        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->matches_arena);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_ac_automaton_create(&new_compiler->automaton);\n\n  if (result == ERROR_SUCCESS)\n  {\n    *compiler = new_compiler;\n  }\n  else  // if error, do cleanup\n  {\n    yr_compiler_destroy(new_compiler);\n  }\n\n  return result;\n}",
        "begin_line": 154,
        "end_line": 247,
        "is_bug": false
    },
    {
        "name": "libyara.compiler.yr_compiler_define_boolean_variable#940",
        "src_path": "libyara/compiler.c",
        "class_name": "libyara.compiler",
        "signature": "libyara.compiler.yr_compiler_define_boolean_variable(     YR_COMPILER* compiler, const char* identifier, int value)",
        "snippet": "YR_API int yr_compiler_define_boolean_variable(\n    YR_COMPILER* compiler,\n    const char* identifier,\n    int value)\n{\n  YR_EXTERNAL_VARIABLE external;\n\n  external.type = EXTERNAL_VARIABLE_TYPE_BOOLEAN;\n  external.identifier = identifier;\n  external.value.i = value;\n\n  FAIL_ON_ERROR(_yr_compiler_define_variable(\n      compiler, &external));\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 940,
        "end_line": 955,
        "is_bug": false
    },
    {
        "name": "libyara.compiler.yr_compiler_destroy#250",
        "src_path": "libyara/compiler.c",
        "class_name": "libyara.compiler",
        "signature": "libyara.compiler.yr_compiler_destroy(     YR_COMPILER* compiler)",
        "snippet": "YR_API void yr_compiler_destroy(\n    YR_COMPILER* compiler)\n{\n  YR_FIXUP* fixup;\n  int i;\n\n  yr_arena_destroy(compiler->compiled_rules_arena);\n  yr_arena_destroy(compiler->sz_arena);\n  yr_arena_destroy(compiler->rules_arena);\n  yr_arena_destroy(compiler->strings_arena);\n  yr_arena_destroy(compiler->code_arena);\n  yr_arena_destroy(compiler->re_code_arena);\n  yr_arena_destroy(compiler->externals_arena);\n  yr_arena_destroy(compiler->namespaces_arena);\n  yr_arena_destroy(compiler->metas_arena);\n  yr_arena_destroy(compiler->automaton_arena);\n  yr_arena_destroy(compiler->matches_arena);\n\n  yr_ac_automaton_destroy(compiler->automaton);\n\n  yr_hash_table_destroy(\n      compiler->rules_table,\n      NULL);\n\n  yr_hash_table_destroy(\n      compiler->strings_table,\n      NULL);\n\n  yr_hash_table_destroy(\n      compiler->objects_table,\n      (YR_HASH_TABLE_FREE_VALUE_FUNC) yr_object_destroy);\n\n  if (compiler->  atoms_config.free_quality_table)\n    yr_free(compiler->atoms_config.quality_table);\n\n  for (i = 0; i < compiler->file_name_stack_ptr; i++)\n    yr_free(compiler->file_name_stack[i]);\n\n  fixup = compiler->fixup_stack_head;\n\n  while (fixup != NULL)\n  {\n    YR_FIXUP* next_fixup = fixup->next;\n    yr_free(fixup);\n    fixup = next_fixup;\n  }\n\n  yr_free(compiler);\n}",
        "begin_line": 250,
        "end_line": 298,
        "is_bug": false
    },
    {
        "name": "libyara.grammar.yara_yyparse#1516",
        "src_path": "libyara/grammar.c",
        "class_name": "libyara.grammar",
        "signature": "libyara.grammar.)",
        "snippet": "int\nyyparse (void *yyscanner, YR_COMPILER* compiler)\n{\n/* The lookahead symbol.  */\nint yychar;\n\n\n/* The semantic value of the lookahead symbol.  */\n/* Default value used for initialization, for pacifying older GCCs\n   or non-GCC compilers.  */\nYY_INITIAL_VALUE (static YYSTYPE yyval_default;)\nYYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n\n    /* Number of syntax errors so far.  */\n    int yynerrs;\n\n    yy_state_fast_t yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yy_state_t yyssa[YYINITDEPTH];\n    yy_state_t *yyss;\n    yy_state_t *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYPTRDIFF_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYPTRDIFF_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n  goto yysetstate;\n\n\n/*------------------------------------------------------------.\n| yynewstate -- push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\nyynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n\n/*--------------------------------------------------------------------.\n| yysetstate -- set current state (the top of the stack) to yystate.  |\n`--------------------------------------------------------------------*/\nyysetstate:\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);\n  YY_IGNORE_USELESS_CAST_BEGIN\n  *yyssp = YY_CAST (yy_state_t, yystate);\n  YY_IGNORE_USELESS_CAST_END\n\n  if (yyss + yystacksize - 1 <= yyssp)\n#if !defined yyoverflow && !defined YYSTACK_RELOCATE\n    goto yyexhaustedlab;\n#else\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYPTRDIFF_T yysize = yyssp - yyss + 1;\n\n# if defined yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        yy_state_t *yyss1 = yyss;\n        YYSTYPE *yyvs1 = yyvs;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * YYSIZEOF (*yyssp),\n                    &yyvs1, yysize * YYSIZEOF (*yyvsp),\n                    &yystacksize);\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n# else /* defined YYSTACK_RELOCATE */\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yy_state_t *yyss1 = yyss;\n        union yyalloc *yyptr =\n          YY_CAST (union yyalloc *,\n                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n# undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YY_IGNORE_USELESS_CAST_BEGIN\n      YYDPRINTF ((stderr, \"Stack size increased to %ld\\n\",\n                  YY_CAST (long, yystacksize)));\n      YY_IGNORE_USELESS_CAST_END\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex (&yylval, yyscanner, compiler);\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n  case 8:\n#line 244 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));\n\n        yr_free((yyvsp[0].sized_string));\n\n        fail_if_error(result);\n      }\n#line 1781 \"grammar.c\"\n    break;\n\n  case 9:\n#line 256 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_reduce_rule_declaration_phase_1(\n            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string), &(yyval.rule)));\n      }\n#line 1790 \"grammar.c\"\n    break;\n\n  case 10:\n#line 261 \"grammar.y\"\n      {\n        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1\n\n        rule->tags = (yyvsp[-3].c_string);\n        rule->metas = (yyvsp[-1].meta);\n        rule->strings = (yyvsp[0].string);\n      }\n#line 1802 \"grammar.c\"\n    break;\n\n  case 11:\n#line 269 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_rule_declaration_phase_2(\n            yyscanner, (yyvsp[-7].rule)); // rule created in phase 1\n\n        yr_free((yyvsp[-8].c_string));\n\n        fail_if_error(result);\n      }\n#line 1815 \"grammar.c\"\n    break;\n\n  case 12:\n#line 282 \"grammar.y\"\n      {\n        (yyval.meta) = NULL;\n      }\n#line 1823 \"grammar.c\"\n    break;\n\n  case 13:\n#line 286 \"grammar.y\"\n      {\n        // Each rule have a list of meta-data info, consisting in a\n        // sequence of YR_META structures. The last YR_META structure does\n        // not represent a real meta-data, it's just a end-of-list marker\n        // identified by a specific type (META_TYPE_NULL). Here we\n        // write the end-of-list marker.\n\n        YR_META null_meta;\n\n        memset(&null_meta, 0xFF, sizeof(YR_META));\n        null_meta.type = META_TYPE_NULL;\n\n        int result = yr_arena_write_data(\n            compiler->metas_arena,\n            &null_meta,\n            sizeof(YR_META),\n            NULL);\n\n        (yyval.meta) = (yyvsp[0].meta);\n\n        fail_if_error(result);\n      }\n#line 1850 \"grammar.c\"\n    break;\n\n  case 14:\n#line 313 \"grammar.y\"\n      {\n        (yyval.string) = NULL;\n      }\n#line 1858 \"grammar.c\"\n    break;\n\n  case 15:\n#line 317 \"grammar.y\"\n      {\n        // Each rule have a list of strings, consisting in a sequence\n        // of YR_STRING structures. The last YR_STRING structure does not\n        // represent a real string, it's just a end-of-list marker\n        // identified by a specific flag (STRING_FLAGS_NULL). Here we\n        // write the end-of-list marker.\n\n        YR_STRING null_string;\n\n        memset(&null_string, 0xFF, sizeof(YR_STRING));\n        null_string.g_flags = STRING_GFLAGS_NULL;\n\n        fail_if_error(yr_arena_write_data(\n            compiler->strings_arena,\n            &null_string,\n            sizeof(YR_STRING),\n            NULL));\n\n        (yyval.string) = (yyvsp[0].string);\n      }\n#line 1883 \"grammar.c\"\n    break;\n\n  case 17:\n#line 346 \"grammar.y\"\n                                       { (yyval.integer) = 0;  }\n#line 1889 \"grammar.c\"\n    break;\n\n  case 18:\n#line 347 \"grammar.y\"\n                                       { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }\n#line 1895 \"grammar.c\"\n    break;\n\n  case 19:\n#line 352 \"grammar.y\"\n                     { (yyval.integer) = RULE_GFLAGS_PRIVATE; }\n#line 1901 \"grammar.c\"\n    break;\n\n  case 20:\n#line 353 \"grammar.y\"\n                     { (yyval.integer) = RULE_GFLAGS_GLOBAL; }\n#line 1907 \"grammar.c\"\n    break;\n\n  case 21:\n#line 359 \"grammar.y\"\n      {\n        (yyval.c_string) = NULL;\n      }\n#line 1915 \"grammar.c\"\n    break;\n\n  case 22:\n#line 363 \"grammar.y\"\n      {\n        // Tags list is represented in the arena as a sequence\n        // of null-terminated strings, the sequence ends with an\n        // additional null character. Here we write the ending null\n        //character. Example: tag1\\0tag2\\0tag3\\0\\0\n\n        int result = yr_arena_write_string(\n            yyget_extra(yyscanner)->sz_arena, \"\", NULL);\n\n        fail_if_error(result);\n\n        (yyval.c_string) = (yyvsp[0].c_string);\n      }\n#line 1933 \"grammar.c\"\n    break;\n\n  case 23:\n#line 381 \"grammar.y\"\n      {\n        int result = yr_arena_write_string(\n            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &(yyval.c_string));\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n      }\n#line 1946 \"grammar.c\"\n    break;\n\n  case 24:\n#line 390 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        char* tag_name = (yyvsp[-1].c_string);\n        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;\n\n        while (tag_length > 0)\n        {\n          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)\n          {\n            yr_compiler_set_error_extra_info(compiler, tag_name);\n            result = ERROR_DUPLICATED_TAG_IDENTIFIER;\n            break;\n          }\n\n          tag_name = (char*) yr_arena_next_address(\n              yyget_extra(yyscanner)->sz_arena,\n              tag_name,\n              tag_length + 1);\n\n          tag_length = tag_name != NULL ? strlen(tag_name) : 0;\n        }\n\n        if (result == ERROR_SUCCESS)\n          result = yr_arena_write_string(\n              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n\n        (yyval.c_string) = (yyvsp[-1].c_string);\n      }\n#line 1984 \"grammar.c\"\n    break;\n\n  case 25:\n#line 428 \"grammar.y\"\n                                          {  (yyval.meta) = (yyvsp[0].meta); }\n#line 1990 \"grammar.c\"\n    break;\n\n  case 26:\n#line 429 \"grammar.y\"\n                                          {  (yyval.meta) = (yyvsp[-1].meta); }\n#line 1996 \"grammar.c\"\n    break;\n\n  case 27:\n#line 435 \"grammar.y\"\n      {\n        SIZED_STRING* sized_string = (yyvsp[0].sized_string);\n\n        int result = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_STRING,\n            (yyvsp[-2].c_string),\n            sized_string->c_string,\n            0,\n            &(yyval.meta));\n\n        yr_free((yyvsp[-2].c_string));\n        yr_free((yyvsp[0].sized_string));\n\n        fail_if_error(result);\n      }\n#line 2017 \"grammar.c\"\n    break;\n\n  case 28:\n#line 452 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_INTEGER,\n            (yyvsp[-2].c_string),\n            NULL,\n            (yyvsp[0].integer),\n            &(yyval.meta));\n\n        yr_free((yyvsp[-2].c_string));\n\n        fail_if_error(result);\n      }\n#line 2035 \"grammar.c\"\n    break;\n\n  case 29:\n#line 466 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_INTEGER,\n            (yyvsp[-3].c_string),\n            NULL,\n            -(yyvsp[0].integer),\n            &(yyval.meta));\n\n        yr_free((yyvsp[-3].c_string));\n\n        fail_if_error(result);\n      }\n#line 2053 \"grammar.c\"\n    break;\n\n  case 30:\n#line 480 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_BOOLEAN,\n            (yyvsp[-2].c_string),\n            NULL,\n            true,\n            &(yyval.meta));\n\n        yr_free((yyvsp[-2].c_string));\n\n        fail_if_error(result);\n      }\n#line 2071 \"grammar.c\"\n    break;\n\n  case 31:\n#line 494 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_meta_declaration(\n            yyscanner,\n            META_TYPE_BOOLEAN,\n            (yyvsp[-2].c_string),\n            NULL,\n            false,\n            &(yyval.meta));\n\n        yr_free((yyvsp[-2].c_string));\n\n        fail_if_error(result);\n      }\n#line 2089 \"grammar.c\"\n    break;\n\n  case 32:\n#line 511 \"grammar.y\"\n                                              { (yyval.string) = (yyvsp[0].string); }\n#line 2095 \"grammar.c\"\n    break;\n\n  case 33:\n#line 512 \"grammar.y\"\n                                              { (yyval.string) = (yyvsp[-1].string); }\n#line 2101 \"grammar.c\"\n    break;\n\n  case 34:\n#line 518 \"grammar.y\"\n      {\n        compiler->current_line = yyget_lineno(yyscanner);\n      }\n#line 2109 \"grammar.c\"\n    break;\n\n  case 35:\n#line 522 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_string_declaration(\n            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string), &(yyval.string));\n\n        yr_free((yyvsp[-4].c_string));\n        yr_free((yyvsp[-1].sized_string));\n\n        fail_if_error(result);\n        compiler->current_line = 0;\n      }\n#line 2124 \"grammar.c\"\n    break;\n\n  case 36:\n#line 533 \"grammar.y\"\n      {\n        compiler->current_line = yyget_lineno(yyscanner);\n      }\n#line 2132 \"grammar.c\"\n    break;\n\n  case 37:\n#line 537 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_string_declaration(\n            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string), &(yyval.string));\n\n        yr_free((yyvsp[-4].c_string));\n        yr_free((yyvsp[-1].sized_string));\n\n        fail_if_error(result);\n\n        compiler->current_line = 0;\n      }\n#line 2148 \"grammar.c\"\n    break;\n\n  case 38:\n#line 549 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_string_declaration(\n            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string), &(yyval.string));\n\n        yr_free((yyvsp[-2].c_string));\n        yr_free((yyvsp[0].sized_string));\n\n        fail_if_error(result);\n      }\n#line 2162 \"grammar.c\"\n    break;\n\n  case 39:\n#line 562 \"grammar.y\"\n                                          { (yyval.integer) = 0; }\n#line 2168 \"grammar.c\"\n    break;\n\n  case 40:\n#line 563 \"grammar.y\"\n                                          { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }\n#line 2174 \"grammar.c\"\n    break;\n\n  case 41:\n#line 568 \"grammar.y\"\n                    { (yyval.integer) = STRING_GFLAGS_WIDE; }\n#line 2180 \"grammar.c\"\n    break;\n\n  case 42:\n#line 569 \"grammar.y\"\n                    { (yyval.integer) = STRING_GFLAGS_ASCII; }\n#line 2186 \"grammar.c\"\n    break;\n\n  case 43:\n#line 570 \"grammar.y\"\n                    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }\n#line 2192 \"grammar.c\"\n    break;\n\n  case 44:\n#line 571 \"grammar.y\"\n                    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }\n#line 2198 \"grammar.c\"\n    break;\n\n  case 45:\n#line 572 \"grammar.y\"\n                    { (yyval.integer) = STRING_GFLAGS_XOR; }\n#line 2204 \"grammar.c\"\n    break;\n\n  case 46:\n#line 578 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));\n\n        if (var_index >= 0)\n        {\n          result = yr_parser_emit_with_arg(\n              yyscanner,\n              OP_PUSH_M,\n              LOOP_LOCAL_VARS * var_index,\n              NULL,\n              NULL);\n\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = UNDEFINED;\n          (yyval.expression).identifier = compiler->loop_identifier[var_index];\n        }\n        else\n        {\n          // Search for identifier within the global namespace, where the\n          // externals variables reside.\n\n          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(\n              compiler->objects_table, (yyvsp[0].c_string), NULL);\n\n          if (object == NULL)\n          {\n            // If not found, search within the current namespace.\n            char* ns = compiler->current_namespace->name;\n\n            object = (YR_OBJECT*) yr_hash_table_lookup(\n                compiler->objects_table, (yyvsp[0].c_string), ns);\n          }\n\n          if (object != NULL)\n          {\n            char* id;\n\n            result = yr_arena_write_string(\n                compiler->sz_arena, (yyvsp[0].c_string), &id);\n\n            if (result == ERROR_SUCCESS)\n              result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_OBJ_LOAD,\n                  id,\n                  NULL,\n                  NULL);\n\n            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n            (yyval.expression).value.object = object;\n            (yyval.expression).identifier = object->identifier;\n          }\n          else\n          {\n            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(\n                compiler->rules_table,\n                (yyvsp[0].c_string),\n                compiler->current_namespace->name);\n\n            if (rule != NULL)\n            {\n              result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_PUSH_RULE,\n                  rule,\n                  NULL,\n                  NULL);\n\n              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n              (yyval.expression).value.integer = UNDEFINED;\n              (yyval.expression).identifier = rule->identifier;\n            }\n            else\n            {\n              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\n              result = ERROR_UNDEFINED_IDENTIFIER;\n            }\n          }\n        }\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n      }\n#line 2294 \"grammar.c\"\n    break;\n\n  case 47:\n#line 664 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n        YR_OBJECT* field = NULL;\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)\n        {\n          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));\n\n          if (field != NULL)\n          {\n            char* ident;\n\n            result = yr_arena_write_string(\n                compiler->sz_arena, (yyvsp[0].c_string), &ident);\n\n            if (result == ERROR_SUCCESS)\n              result = yr_parser_emit_with_arg_reloc(\n                  yyscanner,\n                  OP_OBJ_FIELD,\n                  ident,\n                  NULL,\n                  NULL);\n\n            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n            (yyval.expression).value.object = field;\n            (yyval.expression).identifier = field->identifier;\n          }\n          else\n          {\n            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));\n            result = ERROR_INVALID_FIELD_NAME;\n          }\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-2].expression).identifier);\n\n          result = ERROR_NOT_A_STRUCTURE;\n        }\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n      }\n#line 2345 \"grammar.c\"\n    break;\n\n  case 48:\n#line 711 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n        YR_OBJECT_ARRAY* array;\n        YR_OBJECT_DICTIONARY* dict;\n\n        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)\n        {\n          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)\n          {\n            yr_compiler_set_error_extra_info(\n                compiler, \"array indexes must be of integer type\");\n            result = ERROR_WRONG_TYPE;\n          }\n\n          fail_if_error(result);\n\n          result = yr_parser_emit(\n              yyscanner, OP_INDEX_ARRAY, NULL);\n\n          array = object_as_array((yyvsp[-3].expression).value.object);\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = array->prototype_item;\n          (yyval.expression).identifier = array->identifier;\n        }\n        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)\n        {\n          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)\n          {\n            yr_compiler_set_error_extra_info(\n                compiler, \"dictionary keys must be of string type\");\n            result = ERROR_WRONG_TYPE;\n          }\n\n          fail_if_error(result);\n\n          result = yr_parser_emit(\n              yyscanner, OP_LOOKUP_DICT, NULL);\n\n          dict = object_as_dictionary((yyvsp[-3].expression).value.object);\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = dict->prototype_item;\n          (yyval.expression).identifier = dict->identifier;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-3].expression).identifier);\n\n          result = ERROR_NOT_INDEXABLE;\n        }\n\n        fail_if_error(result);\n      }\n#line 2407 \"grammar.c\"\n    break;\n\n  case 49:\n#line 770 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n        YR_OBJECT_FUNCTION* function;\n        char* args_fmt;\n\n        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&\n            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)\n        {\n          result = yr_parser_check_types(\n              compiler, object_as_function((yyvsp[-3].expression).value.object), (yyvsp[-1].c_string));\n\n          if (result == ERROR_SUCCESS)\n            result = yr_arena_write_string(\n                compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);\n\n          if (result == ERROR_SUCCESS)\n            result = yr_parser_emit_with_arg_reloc(\n                yyscanner,\n                OP_CALL,\n                args_fmt,\n                NULL,\n                NULL);\n\n          function = object_as_function((yyvsp[-3].expression).value.object);\n\n          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;\n          (yyval.expression).value.object = function->return_obj;\n          (yyval.expression).identifier = function->identifier;\n        }\n        else\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-3].expression).identifier);\n\n          result = ERROR_NOT_A_FUNCTION;\n        }\n\n        yr_free((yyvsp[-1].c_string));\n\n        fail_if_error(result);\n      }\n#line 2453 \"grammar.c\"\n    break;\n\n  case 50:\n#line 815 \"grammar.y\"\n                      { (yyval.c_string) = yr_strdup(\"\"); }\n#line 2459 \"grammar.c\"\n    break;\n\n  case 51:\n#line 816 \"grammar.y\"\n                      { (yyval.c_string) = (yyvsp[0].c_string); }\n#line 2465 \"grammar.c\"\n    break;\n\n  case 52:\n#line 821 \"grammar.y\"\n      {\n        (yyval.c_string) = (char*) yr_malloc(YR_MAX_FUNCTION_ARGS + 1);\n\n        if ((yyval.c_string) == NULL)\n          fail_if_error(ERROR_INSUFFICIENT_MEMORY);\n\n        switch((yyvsp[0].expression).type)\n        {\n          case EXPRESSION_TYPE_INTEGER:\n            strlcpy((yyval.c_string), \"i\", YR_MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_FLOAT:\n            strlcpy((yyval.c_string), \"f\", YR_MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_BOOLEAN:\n            strlcpy((yyval.c_string), \"b\", YR_MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_STRING:\n            strlcpy((yyval.c_string), \"s\", YR_MAX_FUNCTION_ARGS);\n            break;\n          case EXPRESSION_TYPE_REGEXP:\n            strlcpy((yyval.c_string), \"r\", YR_MAX_FUNCTION_ARGS);\n            break;\n          default:\n            assert(false);\n        }\n      }\n#line 2497 \"grammar.c\"\n    break;\n\n  case 53:\n#line 849 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        if (strlen((yyvsp[-2].c_string)) == YR_MAX_FUNCTION_ARGS)\n        {\n          result = ERROR_TOO_MANY_ARGUMENTS;\n        }\n        else\n        {\n          switch((yyvsp[0].expression).type)\n          {\n            case EXPRESSION_TYPE_INTEGER:\n              strlcat((yyvsp[-2].c_string), \"i\", YR_MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_FLOAT:\n              strlcat((yyvsp[-2].c_string), \"f\", YR_MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_BOOLEAN:\n              strlcat((yyvsp[-2].c_string), \"b\", YR_MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_STRING:\n              strlcat((yyvsp[-2].c_string), \"s\", YR_MAX_FUNCTION_ARGS);\n              break;\n            case EXPRESSION_TYPE_REGEXP:\n              strlcat((yyvsp[-2].c_string), \"r\", YR_MAX_FUNCTION_ARGS);\n              break;\n            default:\n              assert(false);\n          }\n        }\n\n        fail_if_error(result);\n\n        (yyval.c_string) = (yyvsp[-2].c_string);\n      }\n#line 2537 \"grammar.c\"\n    break;\n\n  case 54:\n#line 889 \"grammar.y\"\n      {\n        SIZED_STRING* sized_string = (yyvsp[0].sized_string);\n        RE* re;\n        RE_ERROR error;\n\n        int result = ERROR_SUCCESS;\n        int re_flags = 0;\n\n        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)\n          re_flags |= RE_FLAGS_NO_CASE;\n\n        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)\n          re_flags |= RE_FLAGS_DOT_ALL;\n\n        result = yr_re_compile(\n            sized_string->c_string,\n            re_flags,\n            compiler->re_code_arena,\n            &re,\n            &error);\n\n        yr_free((yyvsp[0].sized_string));\n\n        if (result == ERROR_INVALID_REGULAR_EXPRESSION)\n          yr_compiler_set_error_extra_info(compiler, error.message);\n\n        if (result == ERROR_SUCCESS)\n          result = yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_PUSH,\n              re,\n              NULL,\n              NULL);\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;\n      }\n#line 2580 \"grammar.c\"\n    break;\n\n  case 55:\n#line 932 \"grammar.y\"\n      {\n        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)\n        {\n          if ((yyvsp[0].expression).value.sized_string != NULL)\n          {\n            yywarning(yyscanner,\n              \"Using literal string \\\"%s\\\" in a boolean operation.\",\n              (yyvsp[0].expression).value.sized_string->c_string);\n          }\n\n          fail_if_error(yr_parser_emit(\n              yyscanner, OP_STR_TO_BOOL, NULL));\n        }\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2601 \"grammar.c\"\n    break;\n\n  case 56:\n#line 952 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 1, NULL, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2612 \"grammar.c\"\n    break;\n\n  case 57:\n#line 959 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 0, NULL, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2623 \"grammar.c\"\n    break;\n\n  case 58:\n#line 966 \"grammar.y\"\n      {\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"matches\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, \"matches\");\n\n        fail_if_error(yr_parser_emit(\n            yyscanner,\n            OP_MATCHES,\n            NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2639 \"grammar.c\"\n    break;\n\n  case 59:\n#line 978 \"grammar.y\"\n      {\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"contains\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_STRING, \"contains\");\n\n        fail_if_error(yr_parser_emit(\n            yyscanner, OP_CONTAINS, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2653 \"grammar.c\"\n    break;\n\n  case 60:\n#line 988 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_string_identifier(\n            yyscanner,\n            (yyvsp[0].c_string),\n            OP_FOUND,\n            UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2671 \"grammar.c\"\n    break;\n\n  case 61:\n#line 1002 \"grammar.y\"\n      {\n        check_type_with_cleanup((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"at\", yr_free((yyvsp[-2].c_string)));\n\n        int result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);\n\n        yr_free((yyvsp[-2].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2688 \"grammar.c\"\n    break;\n\n  case 62:\n#line 1015 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);\n\n        yr_free((yyvsp[-2].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2703 \"grammar.c\"\n    break;\n\n  case 63:\n#line 1026 \"grammar.y\"\n      {\n        if (compiler->loop_depth > 0)\n        {\n          compiler->loop_depth--;\n          compiler->loop_identifier[compiler->loop_depth] = NULL;\n        }\n\n        YYERROR;\n      }\n#line 2717 \"grammar.c\"\n    break;\n\n  case 64:\n#line 1036 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n        int var_index;\n\n        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)\n          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;\n\n        fail_if_error(result);\n\n        var_index = yr_parser_lookup_loop_variable(\n            yyscanner, (yyvsp[-1].c_string));\n\n        if (var_index >= 0)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, (yyvsp[-1].c_string));\n\n          result = ERROR_DUPLICATED_LOOP_IDENTIFIER;\n        }\n\n        fail_if_error(result);\n\n        // Push end-of-list marker\n        result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n\n        fail_if_error(result);\n      }\n#line 2750 \"grammar.c\"\n    break;\n\n  case 65:\n#line 1065 \"grammar.y\"\n      {\n        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n        uint8_t* addr;\n\n        // Clear counter for number of expressions evaluating\n        // to true.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\n\n        // Clear iterations counter\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\n\n        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)\n        {\n          // Pop the first integer\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset, &addr, NULL);\n        }\n        else // INTEGER_SET_RANGE\n        {\n          // Pop higher bound of set range\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);\n\n          // Pop lower bound of set range\n          yr_parser_emit_with_arg(\n              yyscanner, OP_POP_M, mem_offset, NULL, NULL);\n        }\n\n        compiler->loop_address[compiler->loop_depth] = addr;\n        compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);\n        compiler->loop_depth++;\n      }\n#line 2789 \"grammar.c\"\n    break;\n\n  case 66:\n#line 1100 \"grammar.y\"\n      {\n        int mem_offset;\n\n        compiler->loop_depth--;\n        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n\n        // The value at the top of the stack is the result of\n        // evaluating the boolean expression, so it could be\n        // 0, 1 or UNDEFINED. Add this value to a counter\n        // keeping the number of expressions evaluating to true.\n        // If the value is UNDEFINED instruction OP_ADD_M\n        // does nothing.\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\n\n        // Increment iterations counter\n        yr_parser_emit_with_arg(\n            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\n\n        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)\n        {\n          yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_JNUNDEF,\n              compiler->loop_address[compiler->loop_depth],\n              NULL,\n              NULL);\n        }\n        else // INTEGER_SET_RANGE\n        {\n          // Increment lower bound of integer set\n          yr_parser_emit_with_arg(\n              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);\n\n          // Push lower bound of integer set\n          yr_parser_emit_with_arg(\n              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);\n\n          // Push higher bound of integer set\n          yr_parser_emit_with_arg(\n              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);\n\n          // Compare higher bound with lower bound, do loop again\n          // if lower bound is still lower or equal than higher bound\n          yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_JLE,\n              compiler->loop_address[compiler->loop_depth],\n              NULL,\n              NULL);\n\n          yr_parser_emit(yyscanner, OP_POP, NULL);\n          yr_parser_emit(yyscanner, OP_POP, NULL);\n        }\n\n        // Pop end-of-list marker.\n        yr_parser_emit(yyscanner, OP_POP, NULL);\n\n        // At this point the loop quantifier (any, all, 1, 2,..)\n        // is at the top of the stack. Check if the quantifier\n        // is undefined (meaning \"all\") and replace it with the\n        // iterations counter in that case.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\n\n        // Compare the loop quantifier with the number of\n        // expressions evaluating to true.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit(yyscanner, OP_INT_LE, NULL);\n\n        compiler->loop_identifier[compiler->loop_depth] = NULL;\n        yr_free((yyvsp[-8].c_string));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2872 \"grammar.c\"\n    break;\n\n  case 67:\n#line 1179 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n        uint8_t* addr;\n\n        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)\n          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;\n\n        if (compiler->loop_for_of_mem_offset != -1)\n          result = ERROR_NESTED_FOR_OF_LOOP;\n\n        fail_if_error(result);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);\n\n        // Pop the first string.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_POP_M, mem_offset, &addr, NULL);\n\n        compiler->loop_for_of_mem_offset = mem_offset;\n        compiler->loop_address[compiler->loop_depth] = addr;\n        compiler->loop_identifier[compiler->loop_depth] = NULL;\n        compiler->loop_depth++;\n      }\n#line 2905 \"grammar.c\"\n    break;\n\n  case 68:\n#line 1208 \"grammar.y\"\n      {\n        int mem_offset;\n\n        compiler->loop_depth--;\n        compiler->loop_for_of_mem_offset = -1;\n\n        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n\n        // Increment counter by the value returned by the\n        // boolean expression (0 or 1). If the boolean expression\n        // returned UNDEFINED the OP_ADD_M won't do anything.\n\n        yr_parser_emit_with_arg(\n            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);\n\n        // Increment iterations counter.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);\n\n        // If next string is not undefined, go back to the\n        // beginning of the loop.\n        yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JNUNDEF,\n            compiler->loop_address[compiler->loop_depth],\n            NULL,\n            NULL);\n\n        // Pop end-of-list marker.\n        yr_parser_emit(yyscanner, OP_POP, NULL);\n\n        // At this point the loop quantifier (any, all, 1, 2,..)\n        // is at top of the stack. Check if the quantifier is\n        // undefined (meaning \"all\") and replace it with the\n        // iterations counter in that case.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);\n\n        // Compare the loop quantifier with the number of\n        // expressions evaluating to true.\n        yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);\n\n        yr_parser_emit(yyscanner, OP_INT_LE, NULL);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n\n      }\n#line 2958 \"grammar.c\"\n    break;\n\n  case 69:\n#line 1257 \"grammar.y\"\n      {\n        yr_parser_emit(yyscanner, OP_OF, NULL);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2968 \"grammar.c\"\n    break;\n\n  case 70:\n#line 1263 \"grammar.y\"\n      {\n        yr_parser_emit(yyscanner, OP_NOT, NULL);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 2978 \"grammar.c\"\n    break;\n\n  case 71:\n#line 1269 \"grammar.y\"\n      {\n        YR_FIXUP* fixup;\n        void* jmp_destination_addr;\n\n        fail_if_error(yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JFALSE,\n            0,          // still don't know the jump destination\n            NULL,\n            &jmp_destination_addr));\n\n        // create a fixup entry for the jump and push it in the stack\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          fail_if_error(ERROR_INSUFFICIENT_MEMORY);\n\n        fixup->address = jmp_destination_addr;\n        fixup->next = compiler->fixup_stack_head;\n        compiler->fixup_stack_head = fixup;\n      }\n#line 3004 \"grammar.c\"\n    break;\n\n  case 72:\n#line 1291 \"grammar.y\"\n      {\n        YR_FIXUP* fixup;\n        uint8_t* nop_addr;\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_AND, NULL));\n\n        // Generate a do-nothing instruction (NOP) in order to get its address\n        // and use it as the destination for the OP_JFALSE. We can not simply\n        // use the address of the OP_AND instruction +1 because we can't be\n        // sure that the instruction following the OP_AND is going to be in\n        // the same arena page. As we don't have a reliable way of getting the\n        // address of the next instruction we generate the OP_NOP.\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_NOP, &nop_addr));\n\n        fixup = compiler->fixup_stack_head;\n        *(void**)(fixup->address) = (void*) nop_addr;\n        compiler->fixup_stack_head = fixup->next;\n        yr_free(fixup);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3031 \"grammar.c\"\n    break;\n\n  case 73:\n#line 1314 \"grammar.y\"\n      {\n        YR_FIXUP* fixup;\n        void* jmp_destination_addr;\n\n        fail_if_error(yr_parser_emit_with_arg_reloc(\n            yyscanner,\n            OP_JTRUE,\n            0,         // still don't know the jump destination\n            NULL,\n            &jmp_destination_addr));\n\n        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n        if (fixup == NULL)\n          fail_if_error(ERROR_INSUFFICIENT_MEMORY);\n\n        fixup->address = jmp_destination_addr;\n        fixup->next = compiler->fixup_stack_head;\n        compiler->fixup_stack_head = fixup;\n      }\n#line 3056 \"grammar.c\"\n    break;\n\n  case 74:\n#line 1335 \"grammar.y\"\n      {\n        YR_FIXUP* fixup;\n        uint8_t* nop_addr;\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_OR, NULL));\n\n        // Generate a do-nothing instruction (NOP) in order to get its address\n        // and use it as the destination for the OP_JFALSE. We can not simply\n        // use the address of the OP_OR instruction +1 because we can't be\n        // sure that the instruction following the OP_AND is going to be in\n        // the same arena page. As we don't have a reliable way of getting the\n        // address of the next instruction we generate the OP_NOP.\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_NOP, &nop_addr));\n\n        fixup = compiler->fixup_stack_head;\n        *(void**)(fixup->address) = (void*)(nop_addr);\n        compiler->fixup_stack_head = fixup->next;\n        yr_free(fixup);\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3083 \"grammar.c\"\n    break;\n\n  case 75:\n#line 1358 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_reduce_operation(\n            yyscanner, \"<\", (yyvsp[-2].expression), (yyvsp[0].expression)));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3094 \"grammar.c\"\n    break;\n\n  case 76:\n#line 1365 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_reduce_operation(\n            yyscanner, \">\", (yyvsp[-2].expression), (yyvsp[0].expression)));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3105 \"grammar.c\"\n    break;\n\n  case 77:\n#line 1372 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_reduce_operation(\n            yyscanner, \"<=\", (yyvsp[-2].expression), (yyvsp[0].expression)));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3116 \"grammar.c\"\n    break;\n\n  case 78:\n#line 1379 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_reduce_operation(\n            yyscanner, \">=\", (yyvsp[-2].expression), (yyvsp[0].expression)));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3127 \"grammar.c\"\n    break;\n\n  case 79:\n#line 1386 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_reduce_operation(\n            yyscanner, \"==\", (yyvsp[-2].expression), (yyvsp[0].expression)));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3138 \"grammar.c\"\n    break;\n\n  case 80:\n#line 1393 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_reduce_operation(\n            yyscanner, \"!=\", (yyvsp[-2].expression), (yyvsp[0].expression)));\n\n        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n      }\n#line 3149 \"grammar.c\"\n    break;\n\n  case 81:\n#line 1400 \"grammar.y\"\n      {\n        (yyval.expression) = (yyvsp[0].expression);\n      }\n#line 3157 \"grammar.c\"\n    break;\n\n  case 82:\n#line 1404 \"grammar.y\"\n      {\n        (yyval.expression) = (yyvsp[-1].expression);\n      }\n#line 3165 \"grammar.c\"\n    break;\n\n  case 83:\n#line 1411 \"grammar.y\"\n                                   { (yyval.integer) = INTEGER_SET_ENUMERATION; }\n#line 3171 \"grammar.c\"\n    break;\n\n  case 84:\n#line 1412 \"grammar.y\"\n                                   { (yyval.integer) = INTEGER_SET_RANGE; }\n#line 3177 \"grammar.c\"\n    break;\n\n  case 85:\n#line 1418 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for range's lower bound\");\n          result = ERROR_WRONG_TYPE;\n        }\n\n        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for range's upper bound\");\n          result = ERROR_WRONG_TYPE;\n        }\n\n        fail_if_error(result);\n      }\n#line 3201 \"grammar.c\"\n    break;\n\n  case 86:\n#line 1442 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for enumeration item\");\n          result = ERROR_WRONG_TYPE;\n        }\n\n        fail_if_error(result);\n      }\n#line 3218 \"grammar.c\"\n    break;\n\n  case 87:\n#line 1455 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n        {\n          yr_compiler_set_error_extra_info(\n              compiler, \"wrong type for enumeration item\");\n          result = ERROR_WRONG_TYPE;\n        }\n\n        fail_if_error(result);\n      }\n#line 3235 \"grammar.c\"\n    break;\n\n  case 88:\n#line 1472 \"grammar.y\"\n      {\n        // Push end-of-list marker\n        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n      }\n#line 3244 \"grammar.c\"\n    break;\n\n  case 90:\n#line 1478 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL));\n\n        fail_if_error(yr_parser_emit_pushes_for_strings(\n            yyscanner, \"$*\"));\n      }\n#line 3256 \"grammar.c\"\n    break;\n\n  case 93:\n#line 1496 \"grammar.y\"\n      {\n        int result = yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n      }\n#line 3267 \"grammar.c\"\n    break;\n\n  case 94:\n#line 1503 \"grammar.y\"\n      {\n        int result = yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n      }\n#line 3278 \"grammar.c\"\n    break;\n\n  case 96:\n#line 1515 \"grammar.y\"\n      {\n        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n      }\n#line 3286 \"grammar.c\"\n    break;\n\n  case 97:\n#line 1519 \"grammar.y\"\n      {\n        yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);\n      }\n#line 3294 \"grammar.c\"\n    break;\n\n  case 98:\n#line 1527 \"grammar.y\"\n      {\n        (yyval.expression) = (yyvsp[-1].expression);\n      }\n#line 3302 \"grammar.c\"\n    break;\n\n  case 99:\n#line 1531 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_emit(\n            yyscanner, OP_FILESIZE, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = UNDEFINED;\n      }\n#line 3314 \"grammar.c\"\n    break;\n\n  case 100:\n#line 1539 \"grammar.y\"\n      {\n        yywarning(yyscanner,\n            \"Using deprecated \\\"entrypoint\\\" keyword. Use the \\\"entry_point\\\" \"\n            \"function from PE module instead.\");\n\n        fail_if_error(yr_parser_emit(\n            yyscanner, OP_ENTRYPOINT, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = UNDEFINED;\n      }\n#line 3330 \"grammar.c\"\n    break;\n\n  case 101:\n#line 1551 \"grammar.y\"\n      {\n        check_type((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, \"intXXXX or uintXXXX\");\n\n        // _INTEGER_FUNCTION_ could be any of int8, int16, int32, uint8,\n        // uint32, etc. $1 contains an index that added to OP_READ_INT results\n        // in the proper OP_INTXX opcode.\n\n        fail_if_error(yr_parser_emit(\n            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = UNDEFINED;\n      }\n#line 3348 \"grammar.c\"\n    break;\n\n  case 102:\n#line 1565 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = (yyvsp[0].integer);\n      }\n#line 3360 \"grammar.c\"\n    break;\n\n  case 103:\n#line 1573 \"grammar.y\"\n      {\n        fail_if_error(yr_parser_emit_with_arg_double(\n            yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n      }\n#line 3371 \"grammar.c\"\n    break;\n\n  case 104:\n#line 1580 \"grammar.y\"\n      {\n        SIZED_STRING* sized_string;\n\n        int result = yr_arena_write_data(\n            compiler->sz_arena,\n            (yyvsp[0].sized_string),\n            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),\n            (void**) &sized_string);\n\n        yr_free((yyvsp[0].sized_string));\n\n        if (result == ERROR_SUCCESS)\n          result = yr_parser_emit_with_arg_reloc(\n              yyscanner,\n              OP_PUSH,\n              sized_string,\n              NULL,\n              NULL);\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_STRING;\n        (yyval.expression).value.sized_string = sized_string;\n      }\n#line 3400 \"grammar.c\"\n    break;\n\n  case 105:\n#line 1605 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = UNDEFINED;\n      }\n#line 3416 \"grammar.c\"\n    break;\n\n  case 106:\n#line 1617 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);\n\n        yr_free((yyvsp[-3].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = UNDEFINED;\n      }\n#line 3432 \"grammar.c\"\n    break;\n\n  case 107:\n#line 1629 \"grammar.y\"\n      {\n        int result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        if (result == ERROR_SUCCESS)\n          result = yr_parser_reduce_string_identifier(\n              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = UNDEFINED;\n      }\n#line 3452 \"grammar.c\"\n    break;\n\n  case 108:\n#line 1645 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_string_identifier(\n            yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);\n\n        yr_free((yyvsp[-3].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = UNDEFINED;\n      }\n#line 3468 \"grammar.c\"\n    break;\n\n  case 109:\n#line 1657 \"grammar.y\"\n      {\n        int result = yr_parser_emit_with_arg(\n            yyscanner, OP_PUSH, 1, NULL, NULL);\n\n        if (result == ERROR_SUCCESS)\n          result = yr_parser_reduce_string_identifier(\n              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);\n\n        yr_free((yyvsp[0].c_string));\n\n        fail_if_error(result);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = UNDEFINED;\n      }\n#line 3488 \"grammar.c\"\n    break;\n\n  case 110:\n#line 1673 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = UNDEFINED;\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n          (yyval.expression).value.integer = UNDEFINED;\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)\n        {\n          result = yr_parser_emit(\n              yyscanner, OP_OBJ_VALUE, NULL);\n\n          switch((yyvsp[0].expression).value.object->type)\n          {\n            case OBJECT_TYPE_INTEGER:\n              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n              (yyval.expression).value.integer = UNDEFINED;\n              break;\n            case OBJECT_TYPE_FLOAT:\n              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n              break;\n            case OBJECT_TYPE_STRING:\n              (yyval.expression).type = EXPRESSION_TYPE_STRING;\n              (yyval.expression).value.sized_string = NULL;\n              break;\n            default:\n              yr_compiler_set_error_extra_info_fmt(\n                  compiler,\n                  \"wrong usage of identifier \\\"%s\\\"\",\n                  (yyvsp[0].expression).identifier);\n              result = ERROR_WRONG_TYPE;\n          }\n        }\n        else\n        {\n          assert(false);\n        }\n\n        fail_if_error(result);\n      }\n#line 3539 \"grammar.c\"\n    break;\n\n  case 111:\n#line 1720 \"grammar.y\"\n      {\n        int result = ERROR_SUCCESS;\n\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, \"-\");\n\n        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\n              UNDEFINED : -((yyvsp[0].expression).value.integer);\n          result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);\n        }\n        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n          result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);\n        }\n\n        fail_if_error(result);\n      }\n#line 3564 \"grammar.c\"\n    break;\n\n  case 112:\n#line 1741 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_operation(\n            yyscanner, \"+\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          int64_t i1 = (yyvsp[-2].expression).value.integer;\n          int64_t i2 = (yyvsp[0].expression).value.integer;\n\n          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&\n              (\n                (i2 > 0 && i1 > INT64_MAX - i2) ||\n                (i2 < 0 && i1 < INT64_MIN - i2)\n              ))\n          {\n            yr_compiler_set_error_extra_info_fmt(\n                compiler, \"%\" PRId64 \" + %\" PRId64, i1, i2);\n\n            result = ERROR_INTEGER_OVERFLOW;\n          }\n          else\n          {\n            (yyval.expression).value.integer = OPERATION(+, i1, i2);\n            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          }\n        }\n        else\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n        }\n\n        fail_if_error(result);\n      }\n#line 3603 \"grammar.c\"\n    break;\n\n  case 113:\n#line 1776 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_operation(\n            yyscanner, \"-\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          int64_t i1 = (yyvsp[-2].expression).value.integer;\n          int64_t i2 = (yyvsp[0].expression).value.integer;\n\n          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&\n              (\n                (i2 < 0 && i1 > INT64_MAX + i2) ||\n                (i2 > 0 && i1 < INT64_MIN + i2)\n              ))\n          {\n            yr_compiler_set_error_extra_info_fmt(\n                compiler, \"%\" PRId64 \" - %\" PRId64, i1, i2);\n\n            result = ERROR_INTEGER_OVERFLOW;\n          }\n          else\n          {\n            (yyval.expression).value.integer = OPERATION(-, i1, i2);\n            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          }\n        }\n        else\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n        }\n\n        fail_if_error(result);\n      }\n#line 3642 \"grammar.c\"\n    break;\n\n  case 114:\n#line 1811 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_operation(\n            yyscanner, \"*\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          int64_t i1 = (yyvsp[-2].expression).value.integer;\n          int64_t i2 = (yyvsp[0].expression).value.integer;\n\n          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&\n              (\n                i2 != 0 && llabs(i1) > INT64_MAX / llabs(i2)\n              ))\n          {\n            yr_compiler_set_error_extra_info_fmt(\n                compiler, \"%\" PRId64 \" * %\" PRId64, i1, i2);\n\n            result = ERROR_INTEGER_OVERFLOW;\n          }\n          else\n          {\n            (yyval.expression).value.integer = OPERATION(*, i1, i2);\n            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          }\n        }\n        else\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n        }\n\n        fail_if_error(result);\n      }\n#line 3680 \"grammar.c\"\n    break;\n\n  case 115:\n#line 1845 \"grammar.y\"\n      {\n        int result = yr_parser_reduce_operation(\n            yyscanner, \"\\\\\", (yyvsp[-2].expression), (yyvsp[0].expression));\n\n        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&\n            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)\n        {\n          if ((yyvsp[0].expression).value.integer != 0)\n          {\n            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n          }\n          else\n          {\n            result = ERROR_DIVISION_BY_ZERO;\n          }\n        }\n        else\n        {\n          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n        }\n\n        fail_if_error(result);\n      }\n#line 3709 \"grammar.c\"\n    break;\n\n  case 116:\n#line 1870 \"grammar.y\"\n      {\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"%\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"%\");\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_MOD, NULL));\n\n        if ((yyvsp[0].expression).value.integer != 0)\n        {\n          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        }\n        else\n        {\n          fail_if_error(ERROR_DIVISION_BY_ZERO);\n        }\n      }\n#line 3730 \"grammar.c\"\n    break;\n\n  case 117:\n#line 1887 \"grammar.y\"\n      {\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n      }\n#line 3744 \"grammar.c\"\n    break;\n\n  case 118:\n#line 1897 \"grammar.y\"\n      {\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n      }\n#line 3758 \"grammar.c\"\n    break;\n\n  case 119:\n#line 1907 \"grammar.y\"\n      {\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"|\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"|\");\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n      }\n#line 3772 \"grammar.c\"\n    break;\n\n  case 120:\n#line 1917 \"grammar.y\"\n      {\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"~\");\n\n        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL));\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n        (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\n            UNDEFINED : ~((yyvsp[0].expression).value.integer);\n      }\n#line 3786 \"grammar.c\"\n    break;\n\n  case 121:\n#line 1927 \"grammar.y\"\n      {\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\n\n        int result = yr_parser_emit(yyscanner, OP_SHL, NULL);\n\n        if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer < 0)\n          result = ERROR_INVALID_OPERAND;\n        else if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer >= 64)\n          (yyval.expression).value.integer = 0;\n        else\n          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n\n        fail_if_error(result);\n      }\n#line 3808 \"grammar.c\"\n    break;\n\n  case 122:\n#line 1945 \"grammar.y\"\n      {\n        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \">>\");\n        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \">>\");\n\n        int result = yr_parser_emit(yyscanner, OP_SHR, NULL);\n\n        if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer < 0)\n          result = ERROR_INVALID_OPERAND;\n        else if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer >= 64)\n          (yyval.expression).value.integer = 0;\n        else\n          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n\n        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n\n        fail_if_error(result);\n      }\n#line 3830 \"grammar.c\"\n    break;\n\n  case 123:\n#line 1963 \"grammar.y\"\n      {\n        (yyval.expression) = (yyvsp[0].expression);\n      }\n#line 3838 \"grammar.c\"\n    break;\n\n\n#line 3842 \"grammar.c\"\n\n      default: break;\n    }\n  /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n  {\n    const int yylhs = yyr1[yyn] - YYNTOKENS;\n    const int yyi = yypgoto[yylhs] + *yyssp;\n    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp\n               ? yytable[yyi]\n               : yydefgoto[yylhs]);\n  }\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (yyscanner, compiler, YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        int yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = YY_CAST (char *, YYSTACK_ALLOC (YY_CAST (YYSIZE_T, yymsg_alloc)));\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (yyscanner, compiler, yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n         error, discard it.  */\n\n      if (yychar <= YYEOF)\n        {\n          /* Return failure if at end of input.  */\n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval, yyscanner, compiler);\n          yychar = YYEMPTY;\n        }\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n  /* Pacify compilers when the user code never invokes YYERROR and the\n     label yyerrorlab therefore never appears in user code.  */\n  if (0)\n    YYERROR;\n\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYTERROR;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n        YYABORT;\n\n\n      yydestruct (\"Error: popping\",\n                  yystos[yystate], yyvsp, yyscanner, compiler);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (yyscanner, compiler, YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\n\n/*-----------------------------------------------------.\n| yyreturn -- parsing is finished, return the result.  |\n`-----------------------------------------------------*/\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval, yyscanner, compiler);\n    }\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  yystos[+*yyssp], yyvsp, yyscanner, compiler);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n#endif\n  return yyresult;\n}",
        "begin_line": 1516,
        "end_line": 4072,
        "is_bug": false
    },
    {
        "name": "libyara.grammar.yydestruct#1424",
        "src_path": "libyara/grammar.c",
        "class_name": "libyara.grammar",
        "signature": "libyara.grammar.yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, YR_COMPILER* compiler)",
        "snippet": "static void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, YR_COMPILER* compiler)\n{\n  YYUSE (yyvaluep);\n  YYUSE (yyscanner);\n  YYUSE (compiler);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  switch (yytype)\n    {\n    case 10: /* _IDENTIFIER_  */\n#line 205 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1441 \"grammar.c\"\n        break;\n\n    case 11: /* _STRING_IDENTIFIER_  */\n#line 209 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1447 \"grammar.c\"\n        break;\n\n    case 12: /* _STRING_COUNT_  */\n#line 206 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1453 \"grammar.c\"\n        break;\n\n    case 13: /* _STRING_OFFSET_  */\n#line 207 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1459 \"grammar.c\"\n        break;\n\n    case 14: /* _STRING_LENGTH_  */\n#line 208 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1465 \"grammar.c\"\n        break;\n\n    case 15: /* _STRING_IDENTIFIER_WITH_WILDCARD_  */\n#line 210 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1471 \"grammar.c\"\n        break;\n\n    case 19: /* _TEXT_STRING_  */\n#line 211 \"grammar.y\"\n            { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }\n#line 1477 \"grammar.c\"\n        break;\n\n    case 20: /* _HEX_STRING_  */\n#line 212 \"grammar.y\"\n            { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }\n#line 1483 \"grammar.c\"\n        break;\n\n    case 21: /* _REGEXP_  */\n#line 213 \"grammar.y\"\n            { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }\n#line 1489 \"grammar.c\"\n        break;\n\n    case 95: /* arguments  */\n#line 215 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1495 \"grammar.c\"\n        break;\n\n    case 96: /* arguments_list  */\n#line 216 \"grammar.y\"\n            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }\n#line 1501 \"grammar.c\"\n        break;\n\n      default:\n        break;\n    }\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}",
        "begin_line": 1424,
        "end_line": 1507,
        "is_bug": false
    },
    {
        "name": "libyara.libyara.yr_finalize#207",
        "src_path": "libyara/libyara.c",
        "class_name": "libyara.libyara",
        "signature": "libyara.libyara.yr_finalize(void)",
        "snippet": "YR_API int yr_finalize(void)\n{\n  #if defined HAVE_LIBCRYPTO && OPENSSL_VERSION_NUMBER < 0x10100000L\n  int i;\n  #endif\n\n  // yr_finalize shouldn't be called without calling yr_initialize first\n\n  if (init_count == 0)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  init_count--;\n\n  if (init_count > 0)\n    return ERROR_SUCCESS;\n\n  #if defined HAVE_LIBCRYPTO && OPENSSL_VERSION_NUMBER < 0x10100000L\n\n  for (i = 0; i < CRYPTO_num_locks(); i ++)\n    yr_mutex_destroy(&openssl_locks[i]);\n\n  OPENSSL_free(openssl_locks);\n  CRYPTO_set_id_callback(NULL);\n  CRYPTO_set_locking_callback(NULL);\n\n  #elif defined(HAVE_WINCRYPT_H)\n\n  CryptReleaseContext(yr_cryptprov, 0);\n\n  #endif\n\n  FAIL_ON_ERROR(yr_thread_storage_destroy(&yr_tidx_key));\n  FAIL_ON_ERROR(yr_thread_storage_destroy(&yr_recovery_state_key));\n  FAIL_ON_ERROR(yr_modules_finalize());\n  FAIL_ON_ERROR(yr_heap_free());\n\n  #if defined(JEMALLOC)\n  malloc_stats_print(NULL, NULL, NULL);\n  mallctl(\"prof.dump\", NULL, NULL, NULL, 0);\n  #endif\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 207,
        "end_line": 249,
        "is_bug": false
    },
    {
        "name": "libyara.libyara.yr_get_configuration#328",
        "src_path": "libyara/libyara.c",
        "class_name": "libyara.libyara",
        "signature": "libyara.libyara.yr_get_configuration(     YR_CONFIG_NAME name, void *dest)",
        "snippet": "YR_API int yr_get_configuration(\n    YR_CONFIG_NAME name,\n    void *dest)\n{\n  if (dest == NULL)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  switch (name)\n  { // lump all the cases using same types together in one cascade\n    case YR_CONFIG_STACK_SIZE:\n    case YR_CONFIG_MAX_STRINGS_PER_RULE:\n    case YR_CONFIG_MAX_MATCH_DATA:\n      *(uint32_t*) dest = yr_cfgs[name].ui32;\n      break;\n\n    default:\n      return ERROR_INTERNAL_FATAL_ERROR;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 328,
        "end_line": 348,
        "is_bug": false
    },
    {
        "name": "libyara.libyara.yr_initialize#117",
        "src_path": "libyara/libyara.c",
        "class_name": "libyara.libyara",
        "signature": "libyara.libyara.yr_initialize(void)",
        "snippet": "YR_API int yr_initialize(void)\n{\n  uint32_t def_stack_size = DEFAULT_STACK_SIZE;\n  uint32_t def_max_strings_per_rule = DEFAULT_MAX_STRINGS_PER_RULE;\n  uint32_t def_max_match_data = DEFAULT_MAX_MATCH_DATA;\n\n  int i;\n\n  init_count++;\n\n  if (init_count > 1)\n    return ERROR_SUCCESS;\n\n  srand((unsigned) time(NULL));\n\n  yr_canary = rand();\n\n  for (i = 0; i < 256; i++)\n  {\n    if (i >= 'a' && i <= 'z')\n      yr_altercase[i] = i - 32;\n    else if (i >= 'A' && i <= 'Z')\n      yr_altercase[i] = i + 32;\n    else\n      yr_altercase[i] = i;\n\n    yr_lowercase[i] = tolower(i);\n  }\n\n  FAIL_ON_ERROR(yr_heap_alloc());\n  FAIL_ON_ERROR(yr_thread_storage_create(&yr_tidx_key));\n  FAIL_ON_ERROR(yr_thread_storage_create(&yr_recovery_state_key));\n\n  #if defined HAVE_LIBCRYPTO && OPENSSL_VERSION_NUMBER < 0x10100000L\n\n  openssl_locks = (YR_MUTEX*) OPENSSL_malloc(\n      CRYPTO_num_locks() * sizeof(YR_MUTEX));\n\n  for (i = 0; i < CRYPTO_num_locks(); i++)\n    yr_mutex_create(&openssl_locks[i]);\n\n  CRYPTO_set_id_callback(_thread_id);\n  CRYPTO_set_locking_callback(_locking_function);\n\n  #elif defined(HAVE_WINCRYPT_H)\n\n  if (!CryptAcquireContext(&yr_cryptprov, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {\n    return ERROR_INTERNAL_FATAL_ERROR;\n  }\n\n  #elif defined(HAVE_COMMON_CRYPTO)\n\n  ...\n\n  #endif\n\n  FAIL_ON_ERROR(yr_modules_initialize());\n\n  // Initialize default configuration options\n  FAIL_ON_ERROR(yr_set_configuration(\n      YR_CONFIG_STACK_SIZE, &def_stack_size));\n\n  FAIL_ON_ERROR(yr_set_configuration(\n      YR_CONFIG_MAX_STRINGS_PER_RULE, &def_max_strings_per_rule));\n\n  FAIL_ON_ERROR(yr_set_configuration(\n      YR_CONFIG_MAX_MATCH_DATA, &def_max_match_data));\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 117,
        "end_line": 186,
        "is_bug": false
    },
    {
        "name": "libyara.libyara.yr_set_configuration#305",
        "src_path": "libyara/libyara.c",
        "class_name": "libyara.libyara",
        "signature": "libyara.libyara.yr_set_configuration(     YR_CONFIG_NAME name, void *src)",
        "snippet": "YR_API int yr_set_configuration(\n    YR_CONFIG_NAME name,\n    void *src)\n{\n  if (src == NULL)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  switch (name)\n  { // lump all the cases using same types together in one cascade\n    case YR_CONFIG_STACK_SIZE:\n    case YR_CONFIG_MAX_STRINGS_PER_RULE:\n    case YR_CONFIG_MAX_MATCH_DATA:\n      yr_cfgs[name].ui32 = *(uint32_t*) src;\n      break;\n\n    default:\n      return ERROR_INTERNAL_FATAL_ERROR;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 305,
        "end_line": 325,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_calloc#133",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_calloc(size_t count, size_t size)",
        "snippet": "void* yr_calloc(size_t count, size_t size)\n{\n  return calloc(count, size);\n}",
        "begin_line": 133,
        "end_line": 136,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_free#151",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_free(void *ptr)",
        "snippet": "void yr_free(void *ptr)\n{\n  free(ptr);\n}",
        "begin_line": 151,
        "end_line": 154,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_heap_alloc#121",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_heap_alloc(void)",
        "snippet": "int yr_heap_alloc(void)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 121,
        "end_line": 124,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_heap_free#127",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_heap_free(void)",
        "snippet": "int yr_heap_free(void)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 127,
        "end_line": 130,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_malloc#139",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_malloc(size_t size)",
        "snippet": "void* yr_malloc(size_t size)\n{\n  return malloc(size);\n}",
        "begin_line": 139,
        "end_line": 142,
        "is_bug": false
    },
    {
        "name": "libyara.mem.yr_strdup#157",
        "src_path": "libyara/mem.c",
        "class_name": "libyara.mem",
        "signature": "libyara.mem.yr_strdup(const char *str)",
        "snippet": "char* yr_strdup(const char *str)\n{\n  return strdup(str);\n}",
        "begin_line": 157,
        "end_line": 160,
        "is_bug": false
    },
    {
        "name": "libyara.modules.elf.module_finalize#582",
        "src_path": "libyara/modules/elf.c",
        "class_name": "libyara.modules.elf",
        "signature": "libyara.modules.elf.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 582,
        "end_line": 586,
        "is_bug": false
    },
    {
        "name": "libyara.modules.elf.module_initialize#575",
        "src_path": "libyara/modules/elf.c",
        "class_name": "libyara.modules.elf",
        "signature": "libyara.modules.elf.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 575,
        "end_line": 579,
        "is_bug": false
    },
    {
        "name": "libyara.modules.hash.module_finalize#506",
        "src_path": "libyara/modules/hash.c",
        "class_name": "libyara.modules.hash",
        "signature": "libyara.modules.hash.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 506,
        "end_line": 510,
        "is_bug": false
    },
    {
        "name": "libyara.modules.hash.module_initialize#499",
        "src_path": "libyara/modules/hash.c",
        "class_name": "libyara.modules.hash",
        "signature": "libyara.modules.hash.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 499,
        "end_line": 503,
        "is_bug": false
    },
    {
        "name": "libyara.modules.math.module_finalize#645",
        "src_path": "libyara/modules/math.c",
        "class_name": "libyara.modules.math",
        "signature": "libyara.modules.math.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 645,
        "end_line": 649,
        "is_bug": false
    },
    {
        "name": "libyara.modules.math.module_initialize#638",
        "src_path": "libyara/modules/math.c",
        "class_name": "libyara.modules.math",
        "signature": "libyara.modules.math.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 638,
        "end_line": 642,
        "is_bug": false
    },
    {
        "name": "libyara.modules.pe.module_finalize#2371",
        "src_path": "libyara/modules/pe.c",
        "class_name": "libyara.modules.pe",
        "signature": "libyara.modules.pe.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 2371,
        "end_line": 2375,
        "is_bug": false
    },
    {
        "name": "libyara.modules.pe.module_initialize#2364",
        "src_path": "libyara/modules/pe.c",
        "class_name": "libyara.modules.pe",
        "signature": "libyara.modules.pe.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 2364,
        "end_line": 2368,
        "is_bug": false
    },
    {
        "name": "libyara.modules.tests.module_finalize#163",
        "src_path": "libyara/modules/tests.c",
        "class_name": "libyara.modules.tests",
        "signature": "libyara.modules.tests.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 163,
        "end_line": 167,
        "is_bug": false
    },
    {
        "name": "libyara.modules.tests.module_initialize#156",
        "src_path": "libyara/modules/tests.c",
        "class_name": "libyara.modules.tests",
        "signature": "libyara.modules.tests.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 156,
        "end_line": 160,
        "is_bug": false
    },
    {
        "name": "libyara.modules.time.module_finalize#59",
        "src_path": "libyara/modules/time.c",
        "class_name": "libyara.modules.time",
        "signature": "libyara.modules.time.module_finalize(     YR_MODULE* module)",
        "snippet": "int module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 59,
        "end_line": 63,
        "is_bug": false
    },
    {
        "name": "libyara.modules.time.module_initialize#52",
        "src_path": "libyara/modules/time.c",
        "class_name": "libyara.modules.time",
        "signature": "libyara.modules.time.module_initialize(     YR_MODULE* module)",
        "snippet": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}",
        "begin_line": 52,
        "end_line": 56,
        "is_bug": false
    },
    {
        "name": "libyara.modules.yr_modules_finalize#85",
        "src_path": "libyara/modules.c",
        "class_name": "libyara.modules",
        "signature": "libyara.modules.yr_modules_finalize()",
        "snippet": "int yr_modules_finalize()\n{\n  int i;\n\n  for (i = 0; i < sizeof(yr_modules_table) / sizeof(YR_MODULE); i++)\n  {\n    int result = yr_modules_table[i].finalize(&yr_modules_table[i]);\n\n    if (result != ERROR_SUCCESS)\n      return result;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 85,
        "end_line": 98,
        "is_bug": false
    },
    {
        "name": "libyara.modules.yr_modules_initialize#69",
        "src_path": "libyara/modules.c",
        "class_name": "libyara.modules",
        "signature": "libyara.modules.yr_modules_initialize()",
        "snippet": "int yr_modules_initialize()\n{\n  int i;\n\n  for (i = 0; i < sizeof(yr_modules_table) / sizeof(YR_MODULE); i++)\n  {\n    int result = yr_modules_table[i].initialize(&yr_modules_table[i]);\n\n    if (result != ERROR_SUCCESS)\n      return result;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 69,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "libyara.object.yr_object_create#47",
        "src_path": "libyara/object.c",
        "class_name": "libyara.object",
        "signature": "libyara.object.yr_object_create(     int8_t type, const char* identifier, YR_OBJECT* parent, YR_OBJECT** object)",
        "snippet": "int yr_object_create(\n    int8_t type,\n    const char* identifier,\n    YR_OBJECT* parent,\n    YR_OBJECT** object)\n{\n  YR_OBJECT* obj;\n  int i;\n  size_t object_size = 0;\n\n  assert(parent != NULL || object != NULL);\n\n  switch (type)\n  {\n    case OBJECT_TYPE_STRUCTURE:\n      object_size = sizeof(YR_OBJECT_STRUCTURE);\n      break;\n    case OBJECT_TYPE_ARRAY:\n      object_size = sizeof(YR_OBJECT_ARRAY);\n      break;\n    case OBJECT_TYPE_DICTIONARY:\n      object_size = sizeof(YR_OBJECT_DICTIONARY);\n      break;\n    case OBJECT_TYPE_INTEGER:\n      object_size = sizeof(YR_OBJECT);\n      break;\n    case OBJECT_TYPE_FLOAT:\n      object_size = sizeof(YR_OBJECT);\n      break;\n    case OBJECT_TYPE_STRING:\n      object_size = sizeof(YR_OBJECT);\n      break;\n    case OBJECT_TYPE_FUNCTION:\n      object_size = sizeof(YR_OBJECT_FUNCTION);\n      break;\n    default:\n      assert(false);\n  }\n\n  obj = (YR_OBJECT*) yr_malloc(object_size);\n\n  if (obj == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  obj->canary = yr_canary;\n  obj->type = type;\n  obj->identifier = yr_strdup(identifier);\n  obj->parent = parent;\n  obj->data = NULL;\n\n  switch(type)\n  {\n    case OBJECT_TYPE_INTEGER:\n      obj->value.i = UNDEFINED;\n      break;\n    case OBJECT_TYPE_FLOAT:\n      obj->value.d = NAN;\n      break;\n    case OBJECT_TYPE_STRING:\n      obj->value.ss = NULL;\n      break;\n    case OBJECT_TYPE_STRUCTURE:\n      object_as_structure(obj)->members = NULL;\n      break;\n    case OBJECT_TYPE_ARRAY:\n      object_as_array(obj)->items = NULL;\n      object_as_array(obj)->prototype_item = NULL;\n      break;\n    case OBJECT_TYPE_DICTIONARY:\n      object_as_dictionary(obj)->items = NULL;\n      object_as_dictionary(obj)->prototype_item = NULL;\n      break;\n    case OBJECT_TYPE_FUNCTION:\n      object_as_function(obj)->return_obj = NULL;\n      for (i = 0; i < YR_MAX_OVERLOADED_FUNCTIONS; i++)\n      {\n        object_as_function(obj)->prototypes[i].arguments_fmt = NULL;\n        object_as_function(obj)->prototypes[i].code = NULL;\n      }\n      break;\n  }\n\n  if (obj->identifier == NULL)\n  {\n    yr_free(obj);\n    return ERROR_INSUFFICIENT_MEMORY;\n  }\n\n  if (parent != NULL)\n  {\n    assert(parent->type == OBJECT_TYPE_STRUCTURE ||\n           parent->type == OBJECT_TYPE_ARRAY ||\n           parent->type == OBJECT_TYPE_DICTIONARY ||\n           parent->type == OBJECT_TYPE_FUNCTION);\n\n    switch(parent->type)\n    {\n      case OBJECT_TYPE_STRUCTURE:\n        FAIL_ON_ERROR_WITH_CLEANUP(\n            yr_object_structure_set_member(parent, obj),\n            {\n              yr_free((void*) obj->identifier);\n              yr_free(obj);\n            });\n        break;\n\n      case OBJECT_TYPE_ARRAY:\n        object_as_array(parent)->prototype_item = obj;\n        break;\n\n      case OBJECT_TYPE_DICTIONARY:\n        object_as_dictionary(parent)->prototype_item = obj;\n        break;\n\n      case OBJECT_TYPE_FUNCTION:\n        object_as_function(parent)->return_obj = obj;\n        break;\n    }\n  }\n\n  if (object != NULL)\n    *object = obj;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 47,
        "end_line": 171,
        "is_bug": false
    },
    {
        "name": "libyara.object.yr_object_destroy#320",
        "src_path": "libyara/object.c",
        "class_name": "libyara.object",
        "signature": "libyara.object.yr_object_destroy(     YR_OBJECT* object)",
        "snippet": "void yr_object_destroy(\n    YR_OBJECT* object)\n{\n  YR_STRUCTURE_MEMBER* member;\n  YR_STRUCTURE_MEMBER* next_member;\n  YR_ARRAY_ITEMS* array_items;\n  YR_DICTIONARY_ITEMS* dict_items;\n\n  int i;\n\n  if (object == NULL)\n    return;\n\n  switch(object->type)\n  {\n    case OBJECT_TYPE_STRUCTURE:\n      member = object_as_structure(object)->members;\n\n      while (member != NULL)\n      {\n        next_member = member->next;\n        yr_object_destroy(member->object);\n        yr_free(member);\n        member = next_member;\n      }\n      break;\n\n    case OBJECT_TYPE_STRING:\n      if (object->value.ss != NULL)\n        yr_free(object->value.ss);\n      break;\n\n    case OBJECT_TYPE_ARRAY:\n      if (object_as_array(object)->prototype_item != NULL)\n        yr_object_destroy(object_as_array(object)->prototype_item);\n\n      array_items = object_as_array(object)->items;\n\n      if (array_items != NULL)\n      {\n        for (i = 0; i < array_items->count; i++)\n          if (array_items->objects[i] != NULL)\n            yr_object_destroy(array_items->objects[i]);\n      }\n\n      yr_free(array_items);\n      break;\n\n    case OBJECT_TYPE_DICTIONARY:\n      if (object_as_dictionary(object)->prototype_item != NULL)\n        yr_object_destroy(object_as_dictionary(object)->prototype_item);\n\n      dict_items = object_as_dictionary(object)->items;\n\n      if (dict_items != NULL)\n      {\n        for (i = 0; i < dict_items->used; i++)\n        {\n          if (dict_items->objects[i].key != NULL)\n            yr_free(dict_items->objects[i].key);\n\n          if (dict_items->objects[i].obj != NULL)\n            yr_object_destroy(dict_items->objects[i].obj);\n        }\n      }\n\n      yr_free(dict_items);\n      break;\n\n    case OBJECT_TYPE_FUNCTION:\n      yr_object_destroy(object_as_function(object)->return_obj);\n      break;\n  }\n\n  yr_free((void*) object->identifier);\n  yr_free(object);\n}",
        "begin_line": 320,
        "end_line": 396,
        "is_bug": false
    },
    {
        "name": "libyara.object.yr_object_from_external_variable#259",
        "src_path": "libyara/object.c",
        "class_name": "libyara.object",
        "signature": "libyara.object.yr_object_from_external_variable(     YR_EXTERNAL_VARIABLE* external, YR_OBJECT** object)",
        "snippet": "int yr_object_from_external_variable(\n    YR_EXTERNAL_VARIABLE* external,\n    YR_OBJECT** object)\n{\n  YR_OBJECT* obj;\n  int result;\n  uint8_t obj_type = 0;\n\n  switch(external->type)\n  {\n    case EXTERNAL_VARIABLE_TYPE_INTEGER:\n    case EXTERNAL_VARIABLE_TYPE_BOOLEAN:\n      obj_type = OBJECT_TYPE_INTEGER;\n      break;\n\n    case EXTERNAL_VARIABLE_TYPE_FLOAT:\n      obj_type = OBJECT_TYPE_FLOAT;\n      break;\n\n    case EXTERNAL_VARIABLE_TYPE_STRING:\n    case EXTERNAL_VARIABLE_TYPE_MALLOC_STRING:\n      obj_type = OBJECT_TYPE_STRING;\n      break;\n\n    default:\n      assert(false);\n  }\n\n  result = yr_object_create(\n      obj_type,\n      external->identifier,\n      NULL,\n      &obj);\n\n  if (result == ERROR_SUCCESS)\n  {\n    switch(external->type)\n    {\n      case EXTERNAL_VARIABLE_TYPE_INTEGER:\n      case EXTERNAL_VARIABLE_TYPE_BOOLEAN:\n        result = yr_object_set_integer(external->value.i, obj, NULL);\n        break;\n\n      case EXTERNAL_VARIABLE_TYPE_FLOAT:\n        result = yr_object_set_float(external->value.f, obj, NULL);\n        break;\n\n      case EXTERNAL_VARIABLE_TYPE_STRING:\n      case EXTERNAL_VARIABLE_TYPE_MALLOC_STRING:\n        result = yr_object_set_string(\n            external->value.s, strlen(external->value.s), obj, NULL);\n        break;\n    }\n\n    *object = obj;\n  }\n\n  return result;\n}",
        "begin_line": 259,
        "end_line": 317,
        "is_bug": false
    },
    {
        "name": "libyara.object.yr_object_set_integer#977",
        "src_path": "libyara/object.c",
        "class_name": "libyara.object",
        "signature": "libyara.object.yr_object_set_integer(     int64_t value, YR_OBJECT* object, const char* field, ...)",
        "snippet": "int yr_object_set_integer(\n    int64_t value,\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT* integer_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    integer_obj = _yr_object_lookup(object, OBJECT_CREATE, field, args);\n  else\n    integer_obj = object;\n\n  va_end(args);\n\n  if (integer_obj == NULL)\n  {\n    if (field != NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n    else\n      return ERROR_INVALID_ARGUMENT;\n  }\n\n  assert(integer_obj->type == OBJECT_TYPE_INTEGER);\n\n  integer_obj->value.i = value;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 977,
        "end_line": 1008,
        "is_bug": false
    },
    {
        "name": "libyara.parser.yr_parser_emit#51",
        "src_path": "libyara/parser.c",
        "class_name": "libyara.parser",
        "signature": "libyara.parser.yr_parser_emit(     yyscan_t yyscanner, uint8_t instruction, uint8_t** instruction_address)",
        "snippet": "int yr_parser_emit(\n    yyscan_t yyscanner,\n    uint8_t instruction,\n    uint8_t** instruction_address)\n{\n  return yr_arena_write_data(\n      yyget_extra(yyscanner)->code_arena,\n      &instruction,\n      sizeof(int8_t),\n      (void**) instruction_address);\n}",
        "begin_line": 51,
        "end_line": 61,
        "is_bug": false
    },
    {
        "name": "libyara.parser.yr_parser_emit_with_arg#88",
        "src_path": "libyara/parser.c",
        "class_name": "libyara.parser",
        "signature": "libyara.parser.yr_parser_emit_with_arg(     yyscan_t yyscanner, uint8_t instruction, int64_t argument, uint8_t** instruction_address, int64_t** argument_address)",
        "snippet": "int yr_parser_emit_with_arg(\n    yyscan_t yyscanner,\n    uint8_t instruction,\n    int64_t argument,\n    uint8_t** instruction_address,\n    int64_t** argument_address)\n{\n  int result = yr_arena_write_data(\n      yyget_extra(yyscanner)->code_arena,\n      &instruction,\n      sizeof(uint8_t),\n      (void**) instruction_address);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_write_data(\n        yyget_extra(yyscanner)->code_arena,\n        &argument,\n        sizeof(int64_t),\n        (void**) argument_address);\n\n  return result;\n}",
        "begin_line": 88,
        "end_line": 109,
        "is_bug": false
    },
    {
        "name": "libyara.parser.yr_parser_emit_with_arg_reloc#112",
        "src_path": "libyara/parser.c",
        "class_name": "libyara.parser",
        "signature": "libyara.parser.yr_parser_emit_with_arg_reloc(     yyscan_t yyscanner, uint8_t instruction, void* argument, uint8_t** instruction_address, void** argument_address)",
        "snippet": "int yr_parser_emit_with_arg_reloc(\n    yyscan_t yyscanner,\n    uint8_t instruction,\n    void* argument,\n    uint8_t** instruction_address,\n    void** argument_address)\n{\n  int64_t* ptr = NULL;\n  int result;\n\n  DECLARE_REFERENCE(void*, ptr) arg;\n\n  memset(&arg, 0, sizeof(arg));\n  arg.ptr = argument;\n\n  result = yr_arena_write_data(\n      yyget_extra(yyscanner)->code_arena,\n      &instruction,\n      sizeof(uint8_t),\n      (void**) instruction_address);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_write_data(\n        yyget_extra(yyscanner)->code_arena,\n        &arg,\n        sizeof(arg),\n        (void**) &ptr);\n\n  if (result == ERROR_SUCCESS)\n    result = yr_arena_make_ptr_relocatable(\n        yyget_extra(yyscanner)->code_arena,\n        ptr,\n        0,\n        EOL);\n\n  if (argument_address != NULL)\n    *argument_address = (void*) ptr;\n\n  return result;\n}",
        "begin_line": 112,
        "end_line": 151,
        "is_bug": false
    },
    {
        "name": "libyara.parser.yr_parser_reduce_rule_declaration_phase_1#714",
        "src_path": "libyara/parser.c",
        "class_name": "libyara.parser",
        "signature": "libyara.parser.yr_parser_reduce_rule_declaration_phase_1(     yyscan_t yyscanner, int32_t flags, const char* identifier, YR_RULE** rule)",
        "snippet": "int yr_parser_reduce_rule_declaration_phase_1(\n    yyscan_t yyscanner,\n    int32_t flags,\n    const char* identifier,\n    YR_RULE** rule)\n{\n  YR_FIXUP *fixup;\n  YR_INIT_RULE_ARGS *init_rule_args;\n  YR_COMPILER* compiler = yyget_extra(yyscanner);\n\n  *rule = NULL;\n\n  if (yr_hash_table_lookup(\n        compiler->rules_table,\n        identifier,\n        compiler->current_namespace->name) != NULL ||\n      yr_hash_table_lookup(\n        compiler->objects_table,\n        identifier,\n        compiler->current_namespace->name) != NULL)\n  {\n    // A rule or variable with the same identifier already exists, return the\n    // appropriate error.\n\n    yr_compiler_set_error_extra_info(compiler, identifier);\n    return ERROR_DUPLICATED_IDENTIFIER;\n  }\n\n  FAIL_ON_ERROR(yr_arena_allocate_struct(\n      compiler->rules_arena,\n      sizeof(YR_RULE),\n      (void**) rule,\n      offsetof(YR_RULE, identifier),\n      offsetof(YR_RULE, tags),\n      offsetof(YR_RULE, strings),\n      offsetof(YR_RULE, metas),\n      offsetof(YR_RULE, ns),\n      EOL))\n\n  (*rule)->g_flags = flags;\n  (*rule)->ns = compiler->current_namespace;\n\n  #ifdef PROFILING_ENABLED\n  rule->time_cost = 0;\n  #endif\n\n  FAIL_ON_ERROR(yr_arena_write_string(\n      compiler->sz_arena,\n      identifier,\n      (char**) &(*rule)->identifier));\n\n  FAIL_ON_ERROR(yr_parser_emit(\n      yyscanner,\n      OP_INIT_RULE,\n      NULL));\n\n  FAIL_ON_ERROR(yr_arena_allocate_struct(\n      compiler->code_arena,\n      sizeof(YR_INIT_RULE_ARGS),\n      (void**) &init_rule_args,\n      offsetof(YR_INIT_RULE_ARGS, rule),\n      offsetof(YR_INIT_RULE_ARGS, jmp_addr),\n      EOL));\n\n  init_rule_args->rule = *rule;\n\n  // jmp_addr holds the address to jump to when we want to skip the code for\n  // the rule. It is iniatialized as NULL at this point because we don't know\n  // the address until emmiting the code for the rule's condition. The address\n  // is set in yr_parser_reduce_rule_declaration_phase_2.\n  init_rule_args->jmp_addr = NULL;\n\n  // Create a fixup entry for the jump and push it in the stack\n  fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));\n\n  if (fixup == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  fixup->address = (void*) &(init_rule_args->jmp_addr);\n  fixup->next = compiler->fixup_stack_head;\n  compiler->fixup_stack_head = fixup;\n\n  // Clean strings_table as we are starting to parse a new rule.\n  yr_hash_table_clean(compiler->strings_table, NULL);\n\n  FAIL_ON_ERROR(yr_hash_table_add(\n      compiler->rules_table,\n      identifier,\n      compiler->current_namespace->name,\n      (void*) *rule));\n\n  compiler->current_rule = *rule;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 714,
        "end_line": 808,
        "is_bug": true
    },
    {
        "name": "libyara.parser.yr_parser_reduce_rule_declaration_phase_2#810",
        "src_path": "libyara/parser.c",
        "class_name": "libyara.parser",
        "signature": "libyara.parser.yr_parser_reduce_rule_declaration_phase_2(     yyscan_t yyscanner, YR_RULE* rule)",
        "snippet": "int yr_parser_reduce_rule_declaration_phase_2(\n    yyscan_t yyscanner,\n    YR_RULE* rule)\n{\n  uint32_t max_strings_per_rule;\n  uint32_t strings_in_rule = 0;\n  uint8_t* nop_inst_addr = NULL;\n\n  int result;\n\n  YR_FIXUP *fixup;\n  YR_COMPILER* compiler = yyget_extra(yyscanner);\n\n  // Check for unreferenced (unused) strings.\n\n  YR_STRING* string = rule->strings;\n\n  yr_get_configuration(\n      YR_CONFIG_MAX_STRINGS_PER_RULE,\n      (void*) &max_strings_per_rule);\n\n  while (!STRING_IS_NULL(string))\n  {\n    // Only the heading fragment in a chain of strings (the one with\n    // chained_to == NULL) must be referenced. All other fragments\n    // are never marked as referenced.\n\n    if (!STRING_IS_REFERENCED(string) &&\n        string->chained_to == NULL)\n    {\n      yr_compiler_set_error_extra_info(compiler, string->identifier);\n      return ERROR_UNREFERENCED_STRING;\n    }\n\n    strings_in_rule++;\n\n    if (strings_in_rule > max_strings_per_rule)\n    {\n      yr_compiler_set_error_extra_info(compiler, rule->identifier);\n      return ERROR_TOO_MANY_STRINGS;\n    }\n\n    string = (YR_STRING*) yr_arena_next_address(\n        compiler->strings_arena,\n        string,\n        sizeof(YR_STRING));\n  }\n\n  result = yr_parser_emit_with_arg_reloc(\n      yyscanner,\n      OP_MATCH_RULE,\n      rule,\n      NULL,\n      NULL);\n\n  // Generate a do-nothing instruction (NOP) in order to get its address\n  // and use it as the destination for the OP_INIT_RULE skip jump. We can not\n  // simply use the address of the OP_MATCH_RULE instruction +1 because we\n  // can't be sure that the instruction following the OP_MATCH_RULE is going to\n  // be in the same arena page. As we don't have a reliable way of getting the\n  // address of the next instruction we generate the OP_NOP.\n\n  if (result == ERROR_SUCCESS)\n    result = yr_parser_emit(yyscanner, OP_NOP, &nop_inst_addr);\n\n  fixup = compiler->fixup_stack_head;\n  *(void**)(fixup->address) = (void*) nop_inst_addr;\n  compiler->fixup_stack_head = fixup->next;\n  yr_free(fixup);\n\n  return result;\n}",
        "begin_line": 810,
        "end_line": 881,
        "is_bug": false
    },
    {
        "name": "libyara.threading.yr_thread_storage_create#172",
        "src_path": "libyara/threading.c",
        "class_name": "libyara.threading",
        "signature": "libyara.threading.yr_thread_storage_create(     YR_THREAD_STORAGE_KEY* storage)",
        "snippet": "int yr_thread_storage_create(\n    YR_THREAD_STORAGE_KEY* storage)\n{\n  if (pthread_key_create(storage, NULL) != 0)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 172,
        "end_line": 179,
        "is_bug": false
    },
    {
        "name": "libyara.threading.yr_thread_storage_destroy#182",
        "src_path": "libyara/threading.c",
        "class_name": "libyara.threading",
        "signature": "libyara.threading.yr_thread_storage_destroy(     YR_THREAD_STORAGE_KEY* storage)",
        "snippet": "int yr_thread_storage_destroy(\n    YR_THREAD_STORAGE_KEY* storage)\n{\n  if (pthread_key_delete(*storage) != 0)\n    return ERROR_INTERNAL_FATAL_ERROR;\n\n  return ERROR_SUCCESS;\n}",
        "begin_line": 182,
        "end_line": 189,
        "is_bug": false
    }
]