[
    {
        "name": "libtiff.tif_aux.TIFFGetFieldDefaulted#309",
        "src_path": "libtiff/tif_aux.c",
        "class_name": "libtiff.tif_aux",
        "signature": "libtiff.tif_aux.TIFFGetFieldDefaulted(TIFF* tif, uint32 tag, ...)",
        "snippet": "int\nTIFFGetFieldDefaulted(TIFF* tif, uint32 tag, ...)\n{\n\tint ok;\n\tva_list ap;\n\n\tva_start(ap, tag);\n\tok =  TIFFVGetFieldDefaulted(tif, tag, ap);\n\tva_end(ap);\n\treturn (ok);\n}",
        "begin_line": 309,
        "end_line": 319,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_aux.TIFFVGetFieldDefaulted#173",
        "src_path": "libtiff/tif_aux.c",
        "class_name": "libtiff.tif_aux",
        "signature": "libtiff.tif_aux.TIFFVGetFieldDefaulted(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "int\nTIFFVGetFieldDefaulted(TIFF* tif, uint32 tag, va_list ap)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\n\tif (TIFFVGetField(tif, tag, ap))\n\t\treturn (1);\n\tswitch (tag) {\n\tcase TIFFTAG_SUBFILETYPE:\n\t\t*va_arg(ap, uint32 *) = td->td_subfiletype;\n\t\treturn (1);\n\tcase TIFFTAG_BITSPERSAMPLE:\n\t\t*va_arg(ap, uint16 *) = td->td_bitspersample;\n\t\treturn (1);\n\tcase TIFFTAG_THRESHHOLDING:\n\t\t*va_arg(ap, uint16 *) = td->td_threshholding;\n\t\treturn (1);\n\tcase TIFFTAG_FILLORDER:\n\t\t*va_arg(ap, uint16 *) = td->td_fillorder;\n\t\treturn (1);\n\tcase TIFFTAG_ORIENTATION:\n\t\t*va_arg(ap, uint16 *) = td->td_orientation;\n\t\treturn (1);\n\tcase TIFFTAG_SAMPLESPERPIXEL:\n\t\t*va_arg(ap, uint16 *) = td->td_samplesperpixel;\n\t\treturn (1);\n\tcase TIFFTAG_ROWSPERSTRIP:\n\t\t*va_arg(ap, uint32 *) = td->td_rowsperstrip;\n\t\treturn (1);\n\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\t*va_arg(ap, uint16 *) = td->td_minsamplevalue;\n\t\treturn (1);\n\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\t*va_arg(ap, uint16 *) = td->td_maxsamplevalue;\n\t\treturn (1);\n\tcase TIFFTAG_PLANARCONFIG:\n\t\t*va_arg(ap, uint16 *) = td->td_planarconfig;\n\t\treturn (1);\n\tcase TIFFTAG_RESOLUTIONUNIT:\n\t\t*va_arg(ap, uint16 *) = td->td_resolutionunit;\n\t\treturn (1);\n\tcase TIFFTAG_PREDICTOR:\n    {\n        TIFFPredictorState* sp = (TIFFPredictorState*) tif->tif_data;\n        if( sp == NULL )\n        {\n            TIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n                         \"Cannot get \\\"Predictor\\\" tag as plugin is not configured\");\n            *va_arg(ap, uint16*) = 0;\n            return 0;\n        }\n        *va_arg(ap, uint16*) = (uint16) sp->predictor;\n        return 1;\n    }\n\tcase TIFFTAG_DOTRANGE:\n\t\t*va_arg(ap, uint16 *) = 0;\n\t\t*va_arg(ap, uint16 *) = (1<<td->td_bitspersample)-1;\n\t\treturn (1);\n\tcase TIFFTAG_INKSET:\n\t\t*va_arg(ap, uint16 *) = INKSET_CMYK;\n\t\treturn 1;\n\tcase TIFFTAG_NUMBEROFINKS:\n\t\t*va_arg(ap, uint16 *) = 4;\n\t\treturn (1);\n\tcase TIFFTAG_EXTRASAMPLES:\n\t\t*va_arg(ap, uint16 *) = td->td_extrasamples;\n\t\t*va_arg(ap, uint16 **) = td->td_sampleinfo;\n\t\treturn (1);\n\tcase TIFFTAG_MATTEING:\n\t\t*va_arg(ap, uint16 *) =\n\t\t    (td->td_extrasamples == 1 &&\n\t\t     td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);\n\t\treturn (1);\n\tcase TIFFTAG_TILEDEPTH:\n\t\t*va_arg(ap, uint32 *) = td->td_tiledepth;\n\t\treturn (1);\n\tcase TIFFTAG_DATATYPE:\n\t\t*va_arg(ap, uint16 *) = td->td_sampleformat-1;\n\t\treturn (1);\n\tcase TIFFTAG_SAMPLEFORMAT:\n\t\t*va_arg(ap, uint16 *) = td->td_sampleformat;\n                return(1);\n\tcase TIFFTAG_IMAGEDEPTH:\n\t\t*va_arg(ap, uint32 *) = td->td_imagedepth;\n\t\treturn (1);\n\tcase TIFFTAG_YCBCRCOEFFICIENTS:\n\t\t{\n\t\t\t/* defaults are from CCIR Recommendation 601-1 */\n\t\t\tstatic float ycbcrcoeffs[] = { 0.299f, 0.587f, 0.114f };\n\t\t\t*va_arg(ap, float **) = ycbcrcoeffs;\n\t\t\treturn 1;\n\t\t}\n\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t*va_arg(ap, uint16 *) = td->td_ycbcrsubsampling[0];\n\t\t*va_arg(ap, uint16 *) = td->td_ycbcrsubsampling[1];\n\t\treturn (1);\n\tcase TIFFTAG_YCBCRPOSITIONING:\n\t\t*va_arg(ap, uint16 *) = td->td_ycbcrpositioning;\n\t\treturn (1);\n\tcase TIFFTAG_WHITEPOINT:\n\t\t{\n\t\t\tstatic float whitepoint[2];\n\n\t\t\t/* TIFF 6.0 specification tells that it is no default\n\t\t\t   value for the WhitePoint, but AdobePhotoshop TIFF\n\t\t\t   Technical Note tells that it should be CIE D50. */\n\t\t\twhitepoint[0] =\tD50_X0 / (D50_X0 + D50_Y0 + D50_Z0);\n\t\t\twhitepoint[1] =\tD50_Y0 / (D50_X0 + D50_Y0 + D50_Z0);\n\t\t\t*va_arg(ap, float **) = whitepoint;\n\t\t\treturn 1;\n\t\t}\n\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\tif (!td->td_transferfunction[0] &&\n\t\t    !TIFFDefaultTransferFunction(td)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"No space for \\\"TransferFunction\\\" tag\");\n\t\t\treturn (0);\n\t\t}\n\t\t*va_arg(ap, uint16 **) = td->td_transferfunction[0];\n\t\tif (td->td_samplesperpixel - td->td_extrasamples > 1) {\n\t\t\t*va_arg(ap, uint16 **) = td->td_transferfunction[1];\n\t\t\t*va_arg(ap, uint16 **) = td->td_transferfunction[2];\n\t\t}\n\t\treturn (1);\n\tcase TIFFTAG_REFERENCEBLACKWHITE:\n\t\tif (!td->td_refblackwhite && !TIFFDefaultRefBlackWhite(td))\n\t\t\treturn (0);\n\t\t*va_arg(ap, float **) = td->td_refblackwhite;\n\t\treturn (1);\n\t}\n\treturn 0;\n}",
        "begin_line": 173,
        "end_line": 303,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_aux._TIFFCheckMalloc#85",
        "src_path": "libtiff/tif_aux.c",
        "class_name": "libtiff.tif_aux",
        "signature": "libtiff.tif_aux._TIFFCheckMalloc(TIFF* tif, tmsize_t nmemb, tmsize_t elem_size, const char* what)",
        "snippet": "void*\n_TIFFCheckMalloc(TIFF* tif, tmsize_t nmemb, tmsize_t elem_size, const char* what)\n{\n\treturn _TIFFCheckRealloc(tif, NULL, nmemb, elem_size, what);  \n}",
        "begin_line": 85,
        "end_line": 89,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_aux._TIFFCheckRealloc#62",
        "src_path": "libtiff/tif_aux.c",
        "class_name": "libtiff.tif_aux",
        "signature": "libtiff.tif_aux._TIFFCheckRealloc(TIFF* tif, void* buffer, tmsize_t nmemb, tmsize_t elem_size, const char* what)",
        "snippet": "void*\n_TIFFCheckRealloc(TIFF* tif, void* buffer,\n\t\t  tmsize_t nmemb, tmsize_t elem_size, const char* what)\n{\n\tvoid* cp = NULL;\n\ttmsize_t bytes = nmemb * elem_size;\n\n\t/*\n\t * XXX: Check for integer overflow.\n\t */\n\tif (nmemb && elem_size && bytes / elem_size == nmemb)\n\t\tcp = _TIFFrealloc(buffer, bytes);\n\n\tif (cp == NULL) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t     \"Failed to allocate memory for %s \"\n\t\t\t     \"(%ld elements of %ld bytes each)\",\n\t\t\t     what,(long) nmemb, (long) elem_size);\n\t}\n\n\treturn cp;\n}",
        "begin_line": 62,
        "end_line": 83,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_aux._TIFFMultiply64#49",
        "src_path": "libtiff/tif_aux.c",
        "class_name": "libtiff.tif_aux",
        "signature": "libtiff.tif_aux._TIFFMultiply64(TIFF* tif, uint64 first, uint64 second, const char* where)",
        "snippet": "uint64\n_TIFFMultiply64(TIFF* tif, uint64 first, uint64 second, const char* where)\n{\n\tuint64 bytes = first * second;\n\n\tif (second && bytes / second != first) {\n\t\tTIFFErrorExt(tif->tif_clientdata, where, \"Integer overflow in %s\", where);\n\t\tbytes = 0;\n\t}\n\n\treturn bytes;\n}",
        "begin_line": 49,
        "end_line": 60,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_compress.TIFFFindCODEC#186",
        "src_path": "libtiff/tif_compress.c",
        "class_name": "libtiff.tif_compress",
        "signature": "libtiff.tif_compress.TIFFFindCODEC(uint16 scheme)",
        "snippet": "const TIFFCodec*\nTIFFFindCODEC(uint16 scheme)\n{\n\tconst TIFFCodec* c;\n\tcodec_t* cd;\n\n\tfor (cd = registeredCODECS; cd; cd = cd->next)\n\t\tif (cd->info->scheme == scheme)\n\t\t\treturn ((const TIFFCodec*) cd->info);\n\tfor (c = _TIFFBuiltinCODECS; c->name; c++)\n\t\tif (c->scheme == scheme)\n\t\t\treturn (c);\n\treturn ((const TIFFCodec*) 0);\n}",
        "begin_line": 186,
        "end_line": 199,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_compress.TIFFSetCompressionScheme#160",
        "src_path": "libtiff/tif_compress.c",
        "class_name": "libtiff.tif_compress",
        "signature": "libtiff.tif_compress.TIFFSetCompressionScheme(TIFF* tif, int scheme)",
        "snippet": "int\nTIFFSetCompressionScheme(TIFF* tif, int scheme)\n{\n\tconst TIFFCodec *c = TIFFFindCODEC((uint16) scheme);\n\n\t_TIFFSetDefaultCompressionState(tif);\n\t/*\n\t * Don't treat an unknown compression scheme as an error.\n\t * This permits applications to open files with data that\n\t * the library does not have builtin support for, but which\n\t * may still be meaningful.\n\t */\n\treturn (c ? (*c->init)(tif, scheme) : 1);\n}",
        "begin_line": 160,
        "end_line": 173,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_compress._TIFFNoPreCode#125",
        "src_path": "libtiff/tif_compress.c",
        "class_name": "libtiff.tif_compress",
        "signature": "libtiff.tif_compress._TIFFNoPreCode(TIFF* tif, uint16 s)",
        "snippet": "int\n_TIFFNoPreCode(TIFF* tif, uint16 s)\n{\n\t(void) tif; (void) s;\n\treturn (1);\n}",
        "begin_line": 125,
        "end_line": 130,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_compress._TIFFSetDefaultCompressionState#135",
        "src_path": "libtiff/tif_compress.c",
        "class_name": "libtiff.tif_compress",
        "signature": "libtiff.tif_compress._TIFFSetDefaultCompressionState(TIFF* tif)",
        "snippet": "void\n_TIFFSetDefaultCompressionState(TIFF* tif)\n{\n\ttif->tif_fixuptags = _TIFFNoFixupTags; \n\ttif->tif_decodestatus = TRUE;\n\ttif->tif_setupdecode = _TIFFtrue;\n\ttif->tif_predecode = _TIFFNoPreCode;\n\ttif->tif_decoderow = _TIFFNoRowDecode;  \n\ttif->tif_decodestrip = _TIFFNoStripDecode;\n\ttif->tif_decodetile = _TIFFNoTileDecode;  \n\ttif->tif_encodestatus = TRUE;\n\ttif->tif_setupencode = _TIFFtrue;\n\ttif->tif_preencode = _TIFFNoPreCode;\n\ttif->tif_postencode = _TIFFtrue;\n\ttif->tif_encoderow = _TIFFNoRowEncode;\n\ttif->tif_encodestrip = _TIFFNoStripEncode;  \n\ttif->tif_encodetile = _TIFFNoTileEncode;  \n\ttif->tif_close = _TIFFvoid;\n\ttif->tif_seek = _TIFFNoSeek;\n\ttif->tif_cleanup = _TIFFvoid;\n\ttif->tif_defstripsize = _TIFFDefaultStripSize;\n\ttif->tif_deftilesize = _TIFFDefaultTileSize;\n\ttif->tif_flags &= ~(TIFF_NOBITREV|TIFF_NOREADRAW);\n}",
        "begin_line": 135,
        "end_line": 158,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_compress._TIFFtrue#132",
        "src_path": "libtiff/tif_compress.c",
        "class_name": "libtiff.tif_compress",
        "signature": "libtiff.tif_compress._TIFFtrue(TIFF* tif)",
        "snippet": "static int _TIFFtrue(TIFF* tif) { (void) tif; return (1); }",
        "begin_line": 132,
        "end_line": 132,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_compress._TIFFvoid#133",
        "src_path": "libtiff/tif_compress.c",
        "class_name": "libtiff.tif_compress",
        "signature": "libtiff.tif_compress._TIFFvoid(TIFF* tif)",
        "snippet": "static void _TIFFvoid(TIFF* tif) { (void) tif; }",
        "begin_line": 133,
        "end_line": 133,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.OkToChangeTag#749",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.OkToChangeTag(TIFF* tif, uint32 tag)",
        "snippet": "static int\nOkToChangeTag(TIFF* tif, uint32 tag)\n{\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\tif (!fip) {\t\t\t/* unknown tag */\n\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFSetField\", \"%s: Unknown %stag %u\",\n\t\t    tif->tif_name, isPseudoTag(tag) ? \"pseudo-\" : \"\", tag);\n\t\treturn (0);\n\t}\n\tif (tag != TIFFTAG_IMAGELENGTH && (tif->tif_flags & TIFF_BEENWRITING) &&\n\t    !fip->field_oktochange) {\n\t\t/*\n\t\t * Consult info table to see if tag can be changed\n\t\t * after we've started writing.  We only allow changes\n\t\t * to those tags that don't/shouldn't affect the\n\t\t * compression and/or format of the data.\n\t\t */\n\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFSetField\",\n\t\t    \"%s: Cannot modify tag \\\"%s\\\" while writing\",\n\t\t    tif->tif_name, fip->field_name);\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
        "begin_line": 749,
        "end_line": 772,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFDefaultDirectory#1342",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFDefaultDirectory(TIFF* tif)",
        "snippet": "int\nTIFFDefaultDirectory(TIFF* tif)\n{\n\tregister TIFFDirectory* td = &tif->tif_dir;\n\tconst TIFFFieldArray* tiffFieldArray;\n\n\ttiffFieldArray = _TIFFGetFields();\n\t_TIFFSetupFields(tif, tiffFieldArray);   \n\n\t_TIFFmemset(td, 0, sizeof (*td));\n\ttd->td_fillorder = FILLORDER_MSB2LSB;\n\ttd->td_bitspersample = 1;\n\ttd->td_threshholding = THRESHHOLD_BILEVEL;\n\ttd->td_orientation = ORIENTATION_TOPLEFT;\n\ttd->td_samplesperpixel = 1;\n\ttd->td_rowsperstrip = (uint32) -1;\n\ttd->td_tilewidth = 0;\n\ttd->td_tilelength = 0;\n\ttd->td_tiledepth = 1;\n\ttd->td_stripbytecountsorted = 1; /* Our own arrays always sorted. */  \n\ttd->td_resolutionunit = RESUNIT_INCH;\n\ttd->td_sampleformat = SAMPLEFORMAT_UINT;\n\ttd->td_imagedepth = 1;\n\ttd->td_ycbcrsubsampling[0] = 2;\n\ttd->td_ycbcrsubsampling[1] = 2;\n\ttd->td_ycbcrpositioning = YCBCRPOSITION_CENTERED;\n\ttif->tif_postdecode = _TIFFNoPostDecode;  \n\ttif->tif_foundfield = NULL;\n\ttif->tif_tagmethods.vsetfield = _TIFFVSetField;  \n\ttif->tif_tagmethods.vgetfield = _TIFFVGetField;\n\ttif->tif_tagmethods.printdir = NULL;\n\t/*\n\t *  Give client code a chance to install their own\n\t *  tag extensions & methods, prior to compression overloads,\n\t *  but do some prior cleanup first. (http://trac.osgeo.org/gdal/ticket/5054)\n\t */\n\tif (tif->tif_nfieldscompat > 0) {\n\t\tuint32 i;\n\n\t\tfor (i = 0; i < tif->tif_nfieldscompat; i++) {\n\t\t\t\tif (tif->tif_fieldscompat[i].allocated_size)\n\t\t\t\t\t\t_TIFFfree(tif->tif_fieldscompat[i].fields);\n\t\t}\n\t\t_TIFFfree(tif->tif_fieldscompat);\n\t\ttif->tif_nfieldscompat = 0;\n\t\ttif->tif_fieldscompat = NULL;\n\t}\n\tif (_TIFFextender)\n\t\t(*_TIFFextender)(tif);\n\t(void) TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t/*\n\t * NB: The directory is marked dirty as a result of setting\n\t * up the default compression scheme.  However, this really\n\t * isn't correct -- we want TIFF_DIRTYDIRECT to be set only\n\t * if the user does something.  We could just do the setup\n\t * by hand, but it seems better to use the normal mechanism\n\t * (i.e. TIFFSetField).\n\t */\n\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\n\n\t/*\n\t * As per http://bugzilla.remotesensing.org/show_bug.cgi?id=19\n\t * we clear the ISTILED flag when setting up a new directory.\n\t * Should we also be clearing stuff like INSUBIFD?\n\t */\n\ttif->tif_flags &= ~TIFF_ISTILED;\n\n\treturn (1);\n}",
        "begin_line": 1342,
        "end_line": 1410,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFFreeDirectory#1237",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFFreeDirectory(TIFF* tif)",
        "snippet": "void\nTIFFFreeDirectory(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tint            i;\n\n\t_TIFFmemset(td->td_fieldsset, 0, FIELD_SETLONGS);\n\tCleanupField(td_sminsamplevalue);\n\tCleanupField(td_smaxsamplevalue);\n\tCleanupField(td_colormap[0]);\n\tCleanupField(td_colormap[1]);\n\tCleanupField(td_colormap[2]);\n\tCleanupField(td_sampleinfo);\n\tCleanupField(td_subifd);\n\tCleanupField(td_inknames);\n\tCleanupField(td_refblackwhite);\n\tCleanupField(td_transferfunction[0]);\n\tCleanupField(td_transferfunction[1]);\n\tCleanupField(td_transferfunction[2]);\n\tCleanupField(td_stripoffset);\n\tCleanupField(td_stripbytecount);\n\tTIFFClrFieldBit(tif, FIELD_YCBCRSUBSAMPLING);\n\tTIFFClrFieldBit(tif, FIELD_YCBCRPOSITIONING);\n\n\t/* Cleanup custom tag values */\n\tfor( i = 0; i < td->td_customValueCount; i++ ) {\n\t\tif (td->td_customValues[i].value)\n\t\t\t_TIFFfree(td->td_customValues[i].value);\n\t}\n\n\ttd->td_customValueCount = 0;\n\tCleanupField(td_customValues);\n\n#if defined(DEFER_STRILE_LOAD)\n        _TIFFmemset( &(td->td_stripoffset_entry), 0, sizeof(TIFFDirEntry));\n        _TIFFmemset( &(td->td_stripbytecount_entry), 0, sizeof(TIFFDirEntry));\n#endif        \n}",
        "begin_line": 1237,
        "end_line": 1274,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFGetField#1201",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFGetField(TIFF* tif, uint32 tag, ...)",
        "snippet": "int\nTIFFGetField(TIFF* tif, uint32 tag, ...)\n{\n\tint status;\n\tva_list ap;\n\n\tva_start(ap, tag);\n\tstatus = TIFFVGetField(tif, tag, ap);\n\tva_end(ap);\n\treturn (status);\n}",
        "begin_line": 1201,
        "end_line": 1211,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFSetField#781",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFSetField(TIFF* tif, uint32 tag, ...)",
        "snippet": "int\nTIFFSetField(TIFF* tif, uint32 tag, ...)\n{\n\tva_list ap;\n\tint status;\n\n\tva_start(ap, tag);\n\tstatus = TIFFVSetField(tif, tag, ap);\n\tva_end(ap);\n\treturn (status);\n}",
        "begin_line": 781,
        "end_line": 791,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFVGetField#1219",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "int\nTIFFVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\treturn (fip && (isPseudoTag(tag) || TIFFFieldSet(tif, fip->field_bit)) ?\n\t    (*tif->tif_tagmethods.vgetfield)(tif, tag, ap) : 0);\n}",
        "begin_line": 1219,
        "end_line": 1225,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.TIFFVSetField#840",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "int\nTIFFVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\treturn OkToChangeTag(tif, tag) ?\n\t    (*tif->tif_tagmethods.vsetfield)(tif, tag, ap) : 0;\n}",
        "begin_line": 840,
        "end_line": 845,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir._TIFFVGetField#847",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir._TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "static int\n_TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tTIFFDirectory* td = &tif->tif_dir;\n\tint ret_val = 1;\n\tuint32 standard_tag = tag;\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\tif( fip == NULL ) /* cannot happen since TIFFGetField() already checks it */\n\t    return 0;\n\t\n        if( tag == TIFFTAG_NUMBEROFINKS )\n        {\n            int i;\n            for (i = 0; i < td->td_customValueCount; i++) {\n                uint16 val;\n                TIFFTagValue *tv = td->td_customValues + i;\n                if (tv->info->field_tag != tag)\n                    continue;\n                val = *(uint16 *)tv->value;\n                /* Truncate to SamplesPerPixel, since the */\n                /* setting code for INKNAMES assume that there are SamplesPerPixel */\n                /* inknames. */\n                /* Fixes http://bugzilla.maptools.org/show_bug.cgi?id=2599 */\n                if( val > td->td_samplesperpixel )\n                {\n                    TIFFWarningExt(tif->tif_clientdata,\"_TIFFVGetField\",\n                                   \"Truncating NumberOfInks from %u to %u\",\n                                   val, td->td_samplesperpixel);\n                    val = td->td_samplesperpixel;\n                }\n                *va_arg(ap, uint16*) = val;\n                return 1;\n            }\n            return 0;\n        }\n\n\t/*\n\t * We want to force the custom code to be used for custom\n\t * fields even if the tag happens to match a well known \n\t * one - important for reinterpreted handling of standard\n\t * tag values in custom directories (i.e. EXIF) \n\t */\n\tif (fip->field_bit == FIELD_CUSTOM) {\n\t\tstandard_tag = 0;\n\t}\n\n\tswitch (standard_tag) {\n\t\tcase TIFFTAG_SUBFILETYPE:\n\t\t\t*va_arg(ap, uint32*) = td->td_subfiletype;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGEWIDTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagewidth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGELENGTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagelength;\n\t\t\tbreak;\n\t\tcase TIFFTAG_BITSPERSAMPLE:\n\t\t\t*va_arg(ap, uint16*) = td->td_bitspersample;\n\t\t\tbreak;\n\t\tcase TIFFTAG_COMPRESSION:\n\t\t\t*va_arg(ap, uint16*) = td->td_compression;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PHOTOMETRIC:\n\t\t\t*va_arg(ap, uint16*) = td->td_photometric;\n\t\t\tbreak;\n\t\tcase TIFFTAG_THRESHHOLDING:\n\t\t\t*va_arg(ap, uint16*) = td->td_threshholding;\n\t\t\tbreak;\n\t\tcase TIFFTAG_FILLORDER:\n\t\t\t*va_arg(ap, uint16*) = td->td_fillorder;\n\t\t\tbreak;\n\t\tcase TIFFTAG_ORIENTATION:\n\t\t\t*va_arg(ap, uint16*) = td->td_orientation;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SAMPLESPERPIXEL:\n\t\t\t*va_arg(ap, uint16*) = td->td_samplesperpixel;\n\t\t\tbreak;\n\t\tcase TIFFTAG_ROWSPERSTRIP:\n\t\t\t*va_arg(ap, uint32*) = td->td_rowsperstrip;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\t\t*va_arg(ap, uint16*) = td->td_minsamplevalue;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\t\t*va_arg(ap, uint16*) = td->td_maxsamplevalue;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t\t*va_arg(ap, double**) = td->td_sminsamplevalue;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* libtiff historically treats this as a single value. */\n\t\t\t\tuint16 i;\n\t\t\t\tdouble v = td->td_sminsamplevalue[0];\n\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\n\t\t\t\t\tif( td->td_sminsamplevalue[i] < v )\n\t\t\t\t\t\tv = td->td_sminsamplevalue[i];\n\t\t\t\t*va_arg(ap, double*) = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t\t*va_arg(ap, double**) = td->td_smaxsamplevalue;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* libtiff historically treats this as a single value. */\n\t\t\t\tuint16 i;\n\t\t\t\tdouble v = td->td_smaxsamplevalue[0];\n\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\n\t\t\t\t\tif( td->td_smaxsamplevalue[i] > v )\n\t\t\t\t\t\tv = td->td_smaxsamplevalue[i];\n\t\t\t\t*va_arg(ap, double*) = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_XRESOLUTION:\n\t\t\t*va_arg(ap, float*) = td->td_xresolution;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YRESOLUTION:\n\t\t\t*va_arg(ap, float*) = td->td_yresolution;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PLANARCONFIG:\n\t\t\t*va_arg(ap, uint16*) = td->td_planarconfig;\n\t\t\tbreak;\n\t\tcase TIFFTAG_XPOSITION:\n\t\t\t*va_arg(ap, float*) = td->td_xposition;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YPOSITION:\n\t\t\t*va_arg(ap, float*) = td->td_yposition;\n\t\t\tbreak;\n\t\tcase TIFFTAG_RESOLUTIONUNIT:\n\t\t\t*va_arg(ap, uint16*) = td->td_resolutionunit;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PAGENUMBER:\n\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_HALFTONEHINTS:\n\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_COLORMAP:\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[0];\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[1];\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[2];\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\tcase TIFFTAG_TILEOFFSETS:\n\t\t\t_TIFFFillStriles( tif );\n\t\t\t*va_arg(ap, uint64**) = td->td_stripoffset;\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\t\t_TIFFFillStriles( tif );\n\t\t\t*va_arg(ap, uint64**) = td->td_stripbytecount;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MATTEING:\n\t\t\t*va_arg(ap, uint16*) =\n\t\t\t    (td->td_extrasamples == 1 &&\n\t\t\t    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);\n\t\t\tbreak;\n\t\tcase TIFFTAG_EXTRASAMPLES:\n\t\t\t*va_arg(ap, uint16*) = td->td_extrasamples;\n\t\t\t*va_arg(ap, uint16**) = td->td_sampleinfo;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILEWIDTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tilewidth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILELENGTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tilelength;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILEDEPTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tiledepth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_DATATYPE:\n\t\t\tswitch (td->td_sampleformat) {\n\t\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_UINT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_INT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_IEEEFP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_VOID:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_VOID;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_SAMPLEFORMAT:\n\t\t\t*va_arg(ap, uint16*) = td->td_sampleformat;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGEDEPTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagedepth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SUBIFD:\n\t\t\t*va_arg(ap, uint16*) = td->td_nsubifd;\n\t\t\t*va_arg(ap, uint64**) = td->td_subifd;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRPOSITIONING:\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrpositioning;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[0];\n\t\t\tif (td->td_samplesperpixel - td->td_extrasamples > 1) {\n\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[1];\n\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[2];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_REFERENCEBLACKWHITE:\n\t\t\t*va_arg(ap, float**) = td->td_refblackwhite;\n\t\t\tbreak;\n\t\tcase TIFFTAG_INKNAMES:\n\t\t\t*va_arg(ap, char**) = td->td_inknames;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\t/*\n\t\t\t\t * This can happen if multiple images are open\n\t\t\t\t * with different codecs which have private\n\t\t\t\t * tags.  The global tag information table may\n\t\t\t\t * then have tags that are valid for one file\n\t\t\t\t * but not the other. If the client tries to\n\t\t\t\t * get a tag that is not valid for the image's\n\t\t\t\t * codec then we'll arrive here.\n\t\t\t\t */\n\t\t\t\tif( fip->field_bit != FIELD_CUSTOM )\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, \"_TIFFVGetField\",\n\t\t\t\t\t    \"%s: Invalid %stag \\\"%s\\\" \"\n\t\t\t\t\t    \"(not supported by codec)\",\n\t\t\t\t\t    tif->tif_name,\n\t\t\t\t\t    isPseudoTag(tag) ? \"pseudo-\" : \"\",\n\t\t\t\t\t    fip->field_name);\n\t\t\t\t\tret_val = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Do we have a custom value?\n\t\t\t\t */\n\t\t\t\tret_val = 0;\n\t\t\t\tfor (i = 0; i < td->td_customValueCount; i++) {\n\t\t\t\t\tTIFFTagValue *tv = td->td_customValues + i;\n\n\t\t\t\t\tif (tv->info->field_tag != tag)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (fip->field_passcount) {\n\t\t\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE2)\n\t\t\t\t\t\t\t*va_arg(ap, uint32*) = (uint32)tv->count;\n\t\t\t\t\t\telse  /* Assume TIFF_VARIABLE */\n\t\t\t\t\t\t\t*va_arg(ap, uint16*) = (uint16)tv->count;\n\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\n\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t} else if (fip->field_tag == TIFFTAG_DOTRANGE\n\t\t\t\t\t\t   && strcmp(fip->field_name,\"DotRange\") == 0) {\n\t\t\t\t\t\t/* TODO: This is an evil exception and should not have been\n\t\t\t\t\t\t   handled this way ... likely best if we move it into\n\t\t\t\t\t\t   the directory structure with an explicit field in \n\t\t\t\t\t\t   libtiff 4.1 and assign it a FIELD_ value */\n\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];\n\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];\n\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (fip->field_type == TIFF_ASCII\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE2\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_SPP\n\t\t\t\t\t\t    || tv->count > 1) {\n\t\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\n\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchar *val = (char *)tv->value;\n\t\t\t\t\t\t\tassert( tv->count == 1 );\n\t\t\t\t\t\t\tswitch (fip->field_type) {\n\t\t\t\t\t\t\tcase TIFF_BYTE:\n\t\t\t\t\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint8*) =\n\t\t\t\t\t\t\t\t\t*(uint8 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SBYTE:\n\t\t\t\t\t\t\t\t*va_arg(ap, int8*) =\n\t\t\t\t\t\t\t\t\t*(int8 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SHORT:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint16*) =\n\t\t\t\t\t\t\t\t\t*(uint16 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SSHORT:\n\t\t\t\t\t\t\t\t*va_arg(ap, int16*) =\n\t\t\t\t\t\t\t\t\t*(int16 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_LONG:\n\t\t\t\t\t\t\tcase TIFF_IFD:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint32*) =\n\t\t\t\t\t\t\t\t\t*(uint32 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SLONG:\n\t\t\t\t\t\t\t\t*va_arg(ap, int32*) =\n\t\t\t\t\t\t\t\t\t*(int32 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_LONG8:\n\t\t\t\t\t\t\tcase TIFF_IFD8:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint64*) =\n\t\t\t\t\t\t\t\t\t*(uint64 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SLONG8:\n\t\t\t\t\t\t\t\t*va_arg(ap, int64*) =\n\t\t\t\t\t\t\t\t\t*(int64 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_RATIONAL:\n\t\t\t\t\t\t\tcase TIFF_SRATIONAL:\n\t\t\t\t\t\t\tcase TIFF_FLOAT:\n\t\t\t\t\t\t\t\t*va_arg(ap, float*) =\n\t\t\t\t\t\t\t\t\t*(float *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_DOUBLE:\n\t\t\t\t\t\t\t\t*va_arg(ap, double*) =\n\t\t\t\t\t\t\t\t\t*(double *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tret_val = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn(ret_val);\n}",
        "begin_line": 847,
        "end_line": 1195,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir._TIFFVSetField#157",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir._TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)",
        "snippet": "static int\n_TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tstatic const char module[] = \"_TIFFVSetField\";\n\n\tTIFFDirectory* td = &tif->tif_dir;\n\tint status = 1;\n\tuint32 v32, i, v;\n    double dblval;\n\tchar* s;\n\tconst TIFFField *fip = TIFFFindField(tif, tag, TIFF_ANY);\n\tuint32 standard_tag = tag;\n\tif( fip == NULL ) /* cannot happen since OkToChangeTag() already checks it */\n\t    return 0;\n\t/*\n\t * We want to force the custom code to be used for custom\n\t * fields even if the tag happens to match a well known \n\t * one - important for reinterpreted handling of standard\n\t * tag values in custom directories (i.e. EXIF) \n\t */\n\tif (fip->field_bit == FIELD_CUSTOM) {\n\t\tstandard_tag = 0;\n\t}\n\n\tswitch (standard_tag) {\n\tcase TIFFTAG_SUBFILETYPE:\n\t\ttd->td_subfiletype = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_IMAGEWIDTH:\n\t\ttd->td_imagewidth = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_IMAGELENGTH:\n\t\ttd->td_imagelength = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_BITSPERSAMPLE:\n\t\ttd->td_bitspersample = (uint16) va_arg(ap, uint16_vap);\n\t\t/*\n\t\t * If the data require post-decoding processing to byte-swap\n\t\t * samples, set it up here.  Note that since tags are required\n\t\t * to be ordered, compression code can override this behaviour\n\t\t * in the setup method if it wants to roll the post decoding\n\t\t * work in with its normal work.\n\t\t */\n\t\tif (tif->tif_flags & TIFF_SWAB) {\n\t\t\tif (td->td_bitspersample == 8)\n\t\t\t\ttif->tif_postdecode = _TIFFNoPostDecode;\n\t\t\telse if (td->td_bitspersample == 16)\n\t\t\t\ttif->tif_postdecode = _TIFFSwab16BitData;\n\t\t\telse if (td->td_bitspersample == 24)\n\t\t\t\ttif->tif_postdecode = _TIFFSwab24BitData;\n\t\t\telse if (td->td_bitspersample == 32)\n\t\t\t\ttif->tif_postdecode = _TIFFSwab32BitData;\n\t\t\telse if (td->td_bitspersample == 64)\n\t\t\t\ttif->tif_postdecode = _TIFFSwab64BitData;\n\t\t\telse if (td->td_bitspersample == 128) /* two 64's */\n\t\t\t\ttif->tif_postdecode = _TIFFSwab64BitData;\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_COMPRESSION:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\t/*\n\t\t * If we're changing the compression scheme, the notify the\n\t\t * previous module so that it can cleanup any state it's\n\t\t * setup.\n\t\t */\n\t\tif (TIFFFieldSet(tif, FIELD_COMPRESSION)) {\n\t\t\tif ((uint32)td->td_compression == v)\n\t\t\t\tbreak;\n\t\t\t(*tif->tif_cleanup)(tif);\n\t\t\ttif->tif_flags &= ~TIFF_CODERSETUP;\n\t\t}\n\t\t/*\n\t\t * Setup new compression routine state.\n\t\t */\n\t\tif( (status = TIFFSetCompressionScheme(tif, v)) != 0 )\n\t\t    td->td_compression = (uint16) v;\n\t\telse\n\t\t    status = 0;\n\t\tbreak;\n\tcase TIFFTAG_PHOTOMETRIC:\n\t\ttd->td_photometric = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_THRESHHOLDING:\n\t\ttd->td_threshholding = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_FILLORDER:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v != FILLORDER_LSB2MSB && v != FILLORDER_MSB2LSB)\n\t\t\tgoto badvalue;\n\t\ttd->td_fillorder = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_ORIENTATION:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v < ORIENTATION_TOPLEFT || ORIENTATION_LEFTBOT < v)\n\t\t\tgoto badvalue;\n\t\telse\n\t\t\ttd->td_orientation = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_SAMPLESPERPIXEL:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v == 0)\n\t\t\tgoto badvalue;\n        if( v != td->td_samplesperpixel )\n        {\n            /* See http://bugzilla.maptools.org/show_bug.cgi?id=2500 */\n            if( td->td_sminsamplevalue != NULL )\n            {\n                TIFFWarningExt(tif->tif_clientdata,module,\n                    \"SamplesPerPixel tag value is changing, \"\n                    \"but SMinSampleValue tag was read with a different value. Cancelling it\");\n                TIFFClrFieldBit(tif,FIELD_SMINSAMPLEVALUE);\n                _TIFFfree(td->td_sminsamplevalue);\n                td->td_sminsamplevalue = NULL;\n            }\n            if( td->td_smaxsamplevalue != NULL )\n            {\n                TIFFWarningExt(tif->tif_clientdata,module,\n                    \"SamplesPerPixel tag value is changing, \"\n                    \"but SMaxSampleValue tag was read with a different value. Cancelling it\");\n                TIFFClrFieldBit(tif,FIELD_SMAXSAMPLEVALUE);\n                _TIFFfree(td->td_smaxsamplevalue);\n                td->td_smaxsamplevalue = NULL;\n            }\n        }\n\t\ttd->td_samplesperpixel = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_ROWSPERSTRIP:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 == 0)\n\t\t\tgoto badvalue32;\n\t\ttd->td_rowsperstrip = v32;\n\t\tif (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {\n\t\t\ttd->td_tilelength = v32;\n\t\t\ttd->td_tilewidth = td->td_imagewidth;\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\ttd->td_minsamplevalue = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\ttd->td_maxsamplevalue = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t_TIFFsetDoubleArray(&td->td_sminsamplevalue, va_arg(ap, double*), td->td_samplesperpixel);\n\t\telse\n\t\t\tsetDoubleArrayOneValue(&td->td_sminsamplevalue, va_arg(ap, double), td->td_samplesperpixel);\n\t\tbreak;\n\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t_TIFFsetDoubleArray(&td->td_smaxsamplevalue, va_arg(ap, double*), td->td_samplesperpixel);\n\t\telse\n\t\t\tsetDoubleArrayOneValue(&td->td_smaxsamplevalue, va_arg(ap, double), td->td_samplesperpixel);\n\t\tbreak;\n\tcase TIFFTAG_XRESOLUTION:\n        dblval = va_arg(ap, double);\n        if( dblval < 0 )\n            goto badvaluedouble;\n\t\ttd->td_xresolution = (float) dblval;\n\t\tbreak;\n\tcase TIFFTAG_YRESOLUTION:\n        dblval = va_arg(ap, double);\n        if( dblval < 0 )\n            goto badvaluedouble;\n\t\ttd->td_yresolution = (float) dblval;\n\t\tbreak;\n\tcase TIFFTAG_PLANARCONFIG:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v != PLANARCONFIG_CONTIG && v != PLANARCONFIG_SEPARATE)\n\t\t\tgoto badvalue;\n\t\ttd->td_planarconfig = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_XPOSITION:\n\t\ttd->td_xposition = (float) va_arg(ap, double);\n\t\tbreak;\n\tcase TIFFTAG_YPOSITION:\n\t\ttd->td_yposition = (float) va_arg(ap, double);\n\t\tbreak;\n\tcase TIFFTAG_RESOLUTIONUNIT:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v < RESUNIT_NONE || RESUNIT_CENTIMETER < v)\n\t\t\tgoto badvalue;\n\t\ttd->td_resolutionunit = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_PAGENUMBER:\n\t\ttd->td_pagenumber[0] = (uint16) va_arg(ap, uint16_vap);\n\t\ttd->td_pagenumber[1] = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_HALFTONEHINTS:\n\t\ttd->td_halftonehints[0] = (uint16) va_arg(ap, uint16_vap);\n\t\ttd->td_halftonehints[1] = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_COLORMAP:\n\t\tv32 = (uint32)(1L<<td->td_bitspersample);\n\t\t_TIFFsetShortArray(&td->td_colormap[0], va_arg(ap, uint16*), v32);\n\t\t_TIFFsetShortArray(&td->td_colormap[1], va_arg(ap, uint16*), v32);\n\t\t_TIFFsetShortArray(&td->td_colormap[2], va_arg(ap, uint16*), v32);\n\t\tbreak;\n\tcase TIFFTAG_EXTRASAMPLES:\n\t\tif (!setExtraSamples(td, ap, &v))\n\t\t\tgoto badvalue;\n\t\tbreak;\n\tcase TIFFTAG_MATTEING:\n\t\ttd->td_extrasamples =  (((uint16) va_arg(ap, uint16_vap)) != 0);\n\t\tif (td->td_extrasamples) {\n\t\t\tuint16 sv = EXTRASAMPLE_ASSOCALPHA;\n\t\t\t_TIFFsetShortArray(&td->td_sampleinfo, &sv, 1);\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_TILEWIDTH:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 % 16) {\n\t\t\tif (tif->tif_mode != O_RDONLY)\n\t\t\t\tgoto badvalue32;\n\t\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t\t\"Nonstandard tile width %d, convert file\", v32);\n\t\t}\n\t\ttd->td_tilewidth = v32;\n\t\ttif->tif_flags |= TIFF_ISTILED;\n\t\tbreak;\n\tcase TIFFTAG_TILELENGTH:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 % 16) {\n\t\t\tif (tif->tif_mode != O_RDONLY)\n\t\t\t\tgoto badvalue32;\n\t\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t    \"Nonstandard tile length %d, convert file\", v32);\n\t\t}\n\t\ttd->td_tilelength = v32;\n\t\ttif->tif_flags |= TIFF_ISTILED;\n\t\tbreak;\n\tcase TIFFTAG_TILEDEPTH:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 == 0)\n\t\t\tgoto badvalue32;\n\t\ttd->td_tiledepth = v32;\n\t\tbreak;\n\tcase TIFFTAG_DATATYPE:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tswitch (v) {\n\t\tcase DATATYPE_VOID:\tv = SAMPLEFORMAT_VOID;\tbreak;\n\t\tcase DATATYPE_INT:\tv = SAMPLEFORMAT_INT;\tbreak;\n\t\tcase DATATYPE_UINT:\tv = SAMPLEFORMAT_UINT;\tbreak;\n\t\tcase DATATYPE_IEEEFP:\tv = SAMPLEFORMAT_IEEEFP;break;\n\t\tdefault:\t\tgoto badvalue;\n\t\t}\n\t\ttd->td_sampleformat = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_SAMPLEFORMAT:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v < SAMPLEFORMAT_UINT || SAMPLEFORMAT_COMPLEXIEEEFP < v)\n\t\t\tgoto badvalue;\n\t\ttd->td_sampleformat = (uint16) v;\n\n\t\t/*  Try to fix up the SWAB function for complex data. */\n\t\tif( td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT\n\t\t    && td->td_bitspersample == 32\n\t\t    && tif->tif_postdecode == _TIFFSwab32BitData )\n\t\t    tif->tif_postdecode = _TIFFSwab16BitData;\n\t\telse if( (td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT\n\t\t\t  || td->td_sampleformat == SAMPLEFORMAT_COMPLEXIEEEFP)\n\t\t\t && td->td_bitspersample == 64\n\t\t\t && tif->tif_postdecode == _TIFFSwab64BitData )\n\t\t    tif->tif_postdecode = _TIFFSwab32BitData;\n\t\tbreak;\n\tcase TIFFTAG_IMAGEDEPTH:\n\t\ttd->td_imagedepth = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_SUBIFD:\n\t\tif ((tif->tif_flags & TIFF_INSUBIFD) == 0) {\n\t\t\ttd->td_nsubifd = (uint16) va_arg(ap, uint16_vap);\n\t\t\t_TIFFsetLong8Array(&td->td_subifd, (uint64*) va_arg(ap, uint64*),\n\t\t\t    (uint32) td->td_nsubifd);\n\t\t} else {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"%s: Sorry, cannot nest SubIFDs\",\n\t\t\t\t     tif->tif_name);\n\t\t\tstatus = 0;\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_YCBCRPOSITIONING:\n\t\ttd->td_ycbcrpositioning = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\ttd->td_ycbcrsubsampling[0] = (uint16) va_arg(ap, uint16_vap);\n\t\ttd->td_ycbcrsubsampling[1] = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\tv = (td->td_samplesperpixel - td->td_extrasamples) > 1 ? 3 : 1;\n\t\tfor (i = 0; i < v; i++)\n\t\t\t_TIFFsetShortArray(&td->td_transferfunction[i],\n\t\t\t    va_arg(ap, uint16*), 1U<<td->td_bitspersample);\n\t\tbreak;\n\tcase TIFFTAG_REFERENCEBLACKWHITE:\n\t\t/* XXX should check for null range */\n\t\t_TIFFsetFloatArray(&td->td_refblackwhite, va_arg(ap, float*), 6);\n\t\tbreak;\n\tcase TIFFTAG_INKNAMES:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\ts = va_arg(ap, char*);\n\t\tv = checkInkNamesString(tif, v, s);\n\t\tstatus = v > 0;\n\t\tif( v > 0 ) {\n\t\t\t_TIFFsetNString(&td->td_inknames, s, v);\n\t\t\ttd->td_inknameslen = v;\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_PERSAMPLE:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif( v == PERSAMPLE_MULTI )\n\t\t\ttif->tif_flags |= TIFF_PERSAMPLE;\n\t\telse\n\t\t\ttif->tif_flags &= ~TIFF_PERSAMPLE;\n\t\tbreak;\n\tdefault: {\n\t\tTIFFTagValue *tv;\n\t\tint tv_size, iCustom;\n\n\t\t/*\n\t\t * This can happen if multiple images are open with different\n\t\t * codecs which have private tags.  The global tag information\n\t\t * table may then have tags that are valid for one file but not\n\t\t * the other. If the client tries to set a tag that is not valid\n\t\t * for the image's codec then we'll arrive here.  This\n\t\t * happens, for example, when tiffcp is used to convert between\n\t\t * compression schemes and codec-specific tags are blindly copied.\n\t\t */\n\t\tif(fip->field_bit != FIELD_CUSTOM) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"%s: Invalid %stag \\\"%s\\\" (not supported by codec)\",\n\t\t\t    tif->tif_name, isPseudoTag(tag) ? \"pseudo-\" : \"\",\n\t\t\t    fip->field_name);\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Find the existing entry for this custom value.\n\t\t */\n\t\ttv = NULL;\n\t\tfor (iCustom = 0; iCustom < td->td_customValueCount; iCustom++) {\n\t\t\tif (td->td_customValues[iCustom].info->field_tag == tag) {\n\t\t\t\ttv = td->td_customValues + iCustom;\n\t\t\t\tif (tv->value != NULL) {\n\t\t\t\t\t_TIFFfree(tv->value);\n\t\t\t\t\ttv->value = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Grow the custom list if the entry was not found.\n\t\t */\n\t\tif(tv == NULL) {\n\t\t\tTIFFTagValue *new_customValues;\n\n\t\t\ttd->td_customValueCount++;\n\t\t\tnew_customValues = (TIFFTagValue *)\n\t\t\t    _TIFFrealloc(td->td_customValues,\n\t\t\t    sizeof(TIFFTagValue) * td->td_customValueCount);\n\t\t\tif (!new_customValues) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"%s: Failed to allocate space for list of custom values\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\ttd->td_customValues = new_customValues;\n\n\t\t\ttv = td->td_customValues + (td->td_customValueCount - 1);\n\t\t\ttv->info = fip;\n\t\t\ttv->value = NULL;\n\t\t\ttv->count = 0;\n\t\t}\n\n\t\t/*\n\t\t * Set custom value ... save a copy of the custom tag value.\n\t\t */\n\t\ttv_size = _TIFFDataSize(fip->field_type);\n\t\tif (tv_size == 0) {\n\t\t\tstatus = 0;\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"%s: Bad field type %d for \\\"%s\\\"\",\n\t\t\t    tif->tif_name, fip->field_type,\n\t\t\t    fip->field_name);\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (fip->field_type == TIFF_ASCII)\n\t\t{\n\t\t\tuint32 ma;\n\t\t\tchar* mb;\n\t\t\tif (fip->field_passcount)\n\t\t\t{\n\t\t\t\tassert(fip->field_writecount==TIFF_VARIABLE2);\n\t\t\t\tma=(uint32)va_arg(ap,uint32);\n\t\t\t\tmb=(char*)va_arg(ap,char*);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmb=(char*)va_arg(ap,char*);\n\t\t\t\tma=(uint32)(strlen(mb)+1);\n\t\t\t}\n\t\t\ttv->count=ma;\n\t\t\tsetByteArray(&tv->value,mb,ma,1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (fip->field_passcount) {\n\t\t\t\tif (fip->field_writecount == TIFF_VARIABLE2)\n\t\t\t\t\ttv->count = (uint32) va_arg(ap, uint32);\n\t\t\t\telse\n\t\t\t\t\ttv->count = (int) va_arg(ap, int);\n\t\t\t} else if (fip->field_writecount == TIFF_VARIABLE\n\t\t\t   || fip->field_writecount == TIFF_VARIABLE2)\n\t\t\t\ttv->count = 1;\n\t\t\telse if (fip->field_writecount == TIFF_SPP)\n\t\t\t\ttv->count = td->td_samplesperpixel;\n\t\t\telse\n\t\t\t\ttv->count = fip->field_writecount;\n\n\t\t\tif (tv->count == 0) {\n\t\t\t\tstatus = 0;\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"%s: Null count for \\\"%s\\\" (type \"\n\t\t\t\t\t     \"%d, writecount %d, passcount %d)\",\n\t\t\t\t\t     tif->tif_name,\n\t\t\t\t\t     fip->field_name,\n\t\t\t\t\t     fip->field_type,\n\t\t\t\t\t     fip->field_writecount,\n\t\t\t\t\t     fip->field_passcount);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\ttv->value = _TIFFCheckMalloc(tif, tv->count, tv_size,\n\t\t\t    \"custom tag binary object\");\n\t\t\tif (!tv->value) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tif (fip->field_tag == TIFFTAG_DOTRANGE \n\t\t\t    && strcmp(fip->field_name,\"DotRange\") == 0) {\n\t\t\t\t/* TODO: This is an evil exception and should not have been\n\t\t\t\t   handled this way ... likely best if we move it into\n\t\t\t\t   the directory structure with an explicit field in \n\t\t\t\t   libtiff 4.1 and assign it a FIELD_ value */\n\t\t\t\tuint16 v2[2];\n\t\t\t\tv2[0] = (uint16)va_arg(ap, int);\n\t\t\t\tv2[1] = (uint16)va_arg(ap, int);\n\t\t\t\t_TIFFmemcpy(tv->value, &v2, 4);\n\t\t\t}\n\n\t\t\telse if (fip->field_passcount\n\t\t\t\t  || fip->field_writecount == TIFF_VARIABLE\n\t\t\t\t  || fip->field_writecount == TIFF_VARIABLE2\n\t\t\t\t  || fip->field_writecount == TIFF_SPP\n\t\t\t\t  || tv->count > 1) {\n\t\t\t\t_TIFFmemcpy(tv->value, va_arg(ap, void *),\n\t\t\t\t    tv->count * tv_size);\n\t\t\t} else {\n\t\t\t\tchar *val = (char *)tv->value;\n\t\t\t\tassert( tv->count == 1 );\n\n\t\t\t\tswitch (fip->field_type) {\n\t\t\t\tcase TIFF_BYTE:\n\t\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8 v2 = (uint8)va_arg(ap, int);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SBYTE:\n\t\t\t\t\t{\n\t\t\t\t\t\tint8 v2 = (int8)va_arg(ap, int);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SHORT:\n\t\t\t\t\t{\n\t\t\t\t\t\tuint16 v2 = (uint16)va_arg(ap, int);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SSHORT:\n\t\t\t\t\t{\n\t\t\t\t\t\tint16 v2 = (int16)va_arg(ap, int);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_LONG:\n\t\t\t\tcase TIFF_IFD:\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32 v2 = va_arg(ap, uint32);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SLONG:\n\t\t\t\t\t{\n\t\t\t\t\t\tint32 v2 = va_arg(ap, int32);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_LONG8:\n\t\t\t\tcase TIFF_IFD8:\n\t\t\t\t\t{\n\t\t\t\t\t\tuint64 v2 = va_arg(ap, uint64);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SLONG8:\n\t\t\t\t\t{\n\t\t\t\t\t\tint64 v2 = va_arg(ap, int64);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_RATIONAL:\n\t\t\t\tcase TIFF_SRATIONAL:\n\t\t\t\tcase TIFF_FLOAT:\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat v2 = (float)va_arg(ap, double);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_DOUBLE:\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble v2 = va_arg(ap, double);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t_TIFFmemset(val, 0, tv_size);\n\t\t\t\t\tstatus = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t}\n\tif (status) {\n\t\tconst TIFFField* fip2=TIFFFieldWithTag(tif,tag);\n\t\tif (fip2)                \n\t\t\tTIFFSetFieldBit(tif, fip2->field_bit);\n\t\ttif->tif_flags |= TIFF_DIRTYDIRECT;\n\t}\n\nend:\n\tva_end(ap);\n\treturn (status);\nbadvalue:\n        {\n\t\tconst TIFFField* fip2=TIFFFieldWithTag(tif,tag);\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t     \"%s: Bad value %u for \\\"%s\\\" tag\",\n\t\t     tif->tif_name, v,\n\t\t     fip2 ? fip2->field_name : \"Unknown\");\n\t\tva_end(ap);\n        }\n\treturn (0);\nbadvalue32:\n        {\n\t\tconst TIFFField* fip2=TIFFFieldWithTag(tif,tag);\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t     \"%s: Bad value %u for \\\"%s\\\" tag\",\n\t\t     tif->tif_name, v32,\n\t\t     fip2 ? fip2->field_name : \"Unknown\");\n\t\tva_end(ap);\n        }\n\treturn (0);\nbadvaluedouble:\n        {\n        const TIFFField* fip2=TIFFFieldWithTag(tif,tag);\n        TIFFErrorExt(tif->tif_clientdata, module,\n             \"%s: Bad value %f for \\\"%s\\\" tag\",\n             tif->tif_name, dblval,\n             fip2 ? fip2->field_name : \"Unknown\");\n        va_end(ap);\n        }\n    return (0);\n}",
        "begin_line": 157,
        "end_line": 738,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir._TIFFsetShortArray#64",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir._TIFFsetShortArray(uint16** wpp, uint16* wp, uint32 n)",
        "snippet": "void _TIFFsetShortArray(uint16** wpp, uint16* wp, uint32 n)\n    { setByteArray((void**) wpp, (void*) wp, n, sizeof (uint16)); }",
        "begin_line": 64,
        "end_line": 65,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.setByteArray#43",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.setByteArray(void** vpp, void* vp, size_t nmemb, size_t elem_size)",
        "snippet": "static void\nsetByteArray(void** vpp, void* vp, size_t nmemb, size_t elem_size)\n{\n\tif (*vpp) {\n\t\t_TIFFfree(*vpp);\n\t\t*vpp = 0;\n\t}\n\tif (vp) {\n\t\ttmsize_t bytes = (tmsize_t)(nmemb * elem_size);\n\t\tif (elem_size && bytes / elem_size == nmemb)\n\t\t\t*vpp = (void*) _TIFFmalloc(bytes);\n\t\tif (*vpp)\n\t\t\t_TIFFmemcpy(*vpp, vp, bytes);\n\t}\n}",
        "begin_line": 43,
        "end_line": 57,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dir.setExtraSamples#91",
        "src_path": "libtiff/tif_dir.c",
        "class_name": "libtiff.tif_dir",
        "signature": "libtiff.tif_dir.setExtraSamples(TIFFDirectory* td, va_list ap, uint32* v)",
        "snippet": "static int\nsetExtraSamples(TIFFDirectory* td, va_list ap, uint32* v)\n{\n/* XXX: Unassociated alpha data == 999 is a known Corel Draw bug, see below */\n#define EXTRASAMPLE_COREL_UNASSALPHA 999 \n\n\tuint16* va;\n\tuint32 i;\n\n\t*v = (uint16) va_arg(ap, uint16_vap);\n\tif ((uint16) *v > td->td_samplesperpixel)\n\t\treturn 0;\n\tva = va_arg(ap, uint16*);\n\tif (*v > 0 && va == NULL)\t\t/* typically missing param */\n\t\treturn 0;\n\tfor (i = 0; i < *v; i++) {\n\t\tif (va[i] > EXTRASAMPLE_UNASSALPHA) {\n\t\t\t/*\n\t\t\t * XXX: Corel Draw is known to produce incorrect\n\t\t\t * ExtraSamples tags which must be patched here if we\n\t\t\t * want to be able to open some of the damaged TIFF\n\t\t\t * files: \n\t\t\t */\n\t\t\tif (va[i] == EXTRASAMPLE_COREL_UNASSALPHA)\n\t\t\t\tva[i] = EXTRASAMPLE_UNASSALPHA;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\ttd->td_extrasamples = (uint16) *v;\n\t_TIFFsetShortArray(&td->td_sampleinfo, va, td->td_extrasamples);\n\treturn 1;\n\n#undef EXTRASAMPLE_COREL_UNASSALPHA\n}",
        "begin_line": 91,
        "end_line": 125,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo.TIFFDataWidth#439",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo.TIFFDataWidth(TIFFDataType type)",
        "snippet": "int\nTIFFDataWidth(TIFFDataType type)\n{\n\tswitch(type)\n\t{\n\t\tcase 0:  /* nothing */\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_UNDEFINED:\n\t\t\treturn 1;\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t\treturn 2;\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_FLOAT:\n\t\tcase TIFF_IFD:\n\t\t\treturn 4;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\tcase TIFF_DOUBLE:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\tcase TIFF_IFD8:\n\t\t\treturn 8;\n\t\tdefault:\n\t\t\treturn 0; /* will return 0 for unknown types */\n\t}\n}",
        "begin_line": 439,
        "end_line": 468,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo.TIFFFieldWithTag#559",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo.TIFFFieldWithTag(TIFF* tif, uint32 tag)",
        "snippet": "const TIFFField*\nTIFFFieldWithTag(TIFF* tif, uint32 tag)\n{\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\tif (!fip) {\n\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFFieldWithTag\",\n\t\t\t     \"Internal error, unknown tag 0x%x\",\n\t\t\t     (unsigned int) tag);\n\t}\n\treturn (fip);\n}",
        "begin_line": 559,
        "end_line": 569,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo.TIFFFindField#507",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo.TIFFFindField(TIFF* tif, uint32 tag, TIFFDataType dt)",
        "snippet": "const TIFFField*\nTIFFFindField(TIFF* tif, uint32 tag, TIFFDataType dt)\n{\n\tTIFFField key = {0, 0, 0, TIFF_NOTYPE, 0, 0, 0, 0, 0, 0, NULL, NULL};\n\tTIFFField* pkey = &key;\n\tconst TIFFField **ret;\n\tif (tif->tif_foundfield && tif->tif_foundfield->field_tag == tag &&\n\t    (dt == TIFF_ANY || dt == tif->tif_foundfield->field_type))\n\t\treturn tif->tif_foundfield;\n\n\t/* If we are invoked with no field information, then just return. */\n\tif (!tif->tif_fields)\n\t\treturn NULL;\n\n\t/* NB: use sorted search (e.g. binary search) */\n\n\tkey.field_tag = tag;\n\tkey.field_type = dt;\n\n\tret = (const TIFFField **) bsearch(&pkey, tif->tif_fields,\n\t\t\t\t\t   tif->tif_nfields,\n\t\t\t\t\t   sizeof(TIFFField *), tagCompare);\n\treturn tif->tif_foundfield = (ret ? *ret : NULL);\n}",
        "begin_line": 507,
        "end_line": 530,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo._TIFFDataSize#477",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo._TIFFDataSize(TIFFDataType type)",
        "snippet": "int\n_TIFFDataSize(TIFFDataType type)\n{\n\tswitch (type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_UNDEFINED:\n\t\t    return 1;\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t    return 2;\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_FLOAT:\n\t\tcase TIFF_IFD:\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\t    return 4;\n\t\tcase TIFF_DOUBLE:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\tcase TIFF_IFD8:\n\t\t    return 8;\n\t\tdefault:\n\t\t    return 0;\n\t}\n}",
        "begin_line": 477,
        "end_line": 505,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo._TIFFGetFields#306",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo._TIFFGetFields(void)",
        "snippet": "const TIFFFieldArray*\n_TIFFGetFields(void)\n{\n\treturn(&tiffFieldArray);\n}",
        "begin_line": 306,
        "end_line": 310,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo._TIFFMergeFields#370",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo._TIFFMergeFields(TIFF* tif, const TIFFField info[], uint32 n)",
        "snippet": "int\n_TIFFMergeFields(TIFF* tif, const TIFFField info[], uint32 n)\n{\n\tstatic const char module[] = \"_TIFFMergeFields\";\n\tstatic const char reason[] = \"for fields array\";\n\t/* TIFFField** tp; */\n\tuint32 i;\n\n        tif->tif_foundfield = NULL;\n\n\tif (tif->tif_fields && tif->tif_nfields > 0) {\n\t\ttif->tif_fields = (TIFFField**)\n\t\t\t_TIFFCheckRealloc(tif, tif->tif_fields,\n\t\t\t\t\t  (tif->tif_nfields + n),\n\t\t\t\t\t  sizeof(TIFFField *), reason);\n\t} else {\n\t\ttif->tif_fields = (TIFFField **)\n\t\t\t_TIFFCheckMalloc(tif, n, sizeof(TIFFField *),\n\t\t\t\t\t reason);\n\t}\n\tif (!tif->tif_fields) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Failed to allocate fields array\");\n\t\treturn 0;\n\t}\n\n\t/* tp = tif->tif_fields + tif->tif_nfields; */\n\tfor (i = 0; i < n; i++) {\n\t\tconst TIFFField *fip =\n\t\t\tTIFFFindField(tif, info[i].field_tag, TIFF_ANY);\n\n                /* only add definitions that aren't already present */\n\t\tif (!fip) {\n                        tif->tif_fields[tif->tif_nfields] = (TIFFField *) (info+i);\n                        tif->tif_nfields++;\n                }\n\t}\n\n        /* Sort the field info by tag number */\n\tqsort(tif->tif_fields, tif->tif_nfields,\n\t      sizeof(TIFFField *), tagCompare);\n\n\treturn n;\n}",
        "begin_line": 370,
        "end_line": 413,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo._TIFFSetupFields#318",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo._TIFFSetupFields(TIFF* tif, const TIFFFieldArray* fieldarray)",
        "snippet": "void\n_TIFFSetupFields(TIFF* tif, const TIFFFieldArray* fieldarray)\n{\n\tif (tif->tif_fields && tif->tif_nfields > 0) {\n\t\tuint32 i;\n\n\t\tfor (i = 0; i < tif->tif_nfields; i++) {\n\t\t\tTIFFField *fld = tif->tif_fields[i];\n\t\t\tif (fld->field_bit == FIELD_CUSTOM &&\n\t\t\t\tstrncmp(\"Tag \", fld->field_name, 4) == 0) {\n\t\t\t\t\t_TIFFfree(fld->field_name);\n\t\t\t\t\t_TIFFfree(fld);\n\t\t\t\t}\n\t\t}\n\n\t\t_TIFFfree(tif->tif_fields);\n\t\ttif->tif_fields = NULL;\n\t\ttif->tif_nfields = 0;\n\t}\n\tif (!_TIFFMergeFields(tif, fieldarray->fields, fieldarray->count)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, \"_TIFFSetupFields\",\n\t\t\t     \"Setting up field info failed\");\n\t}\n}",
        "begin_line": 318,
        "end_line": 341,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirinfo.tagCompare#343",
        "src_path": "libtiff/tif_dirinfo.c",
        "class_name": "libtiff.tif_dirinfo",
        "signature": "libtiff.tif_dirinfo.tagCompare(const void* a, const void* b)",
        "snippet": "static int\ntagCompare(const void* a, const void* b)\n{\n\tconst TIFFField* ta = *(const TIFFField**) a;\n\tconst TIFFField* tb = *(const TIFFField**) b;\n\t/* NB: be careful of return values for 16-bit platforms */\n\tif (ta->field_tag != tb->field_tag)\n\t\treturn (int)ta->field_tag - (int)tb->field_tag;\n\telse\n\t\treturn (ta->field_type == TIFF_ANY) ?\n\t\t\t0 : ((int)tb->field_type - (int)ta->field_type);\n}",
        "begin_line": 343,
        "end_line": 354,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.ChopUpSingleUncompressedStrip#5495",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.ChopUpSingleUncompressedStrip(TIFF* tif)",
        "snippet": "static void\nChopUpSingleUncompressedStrip(TIFF* tif)\n{\n\tregister TIFFDirectory *td = &tif->tif_dir;\n\tuint64 bytecount;\n\tuint64 offset;\n\tuint32 rowblock;\n\tuint64 rowblockbytes;\n\tuint64 stripbytes;\n\tuint32 strip;\n\tuint32 nstrips;\n\tuint32 rowsperstrip;\n\tuint64* newcounts;\n\tuint64* newoffsets;\n\n\tbytecount = td->td_stripbytecount[0];\n\toffset = td->td_stripoffset[0];\n\tassert(td->td_planarconfig == PLANARCONFIG_CONTIG);\n\tif ((td->td_photometric == PHOTOMETRIC_YCBCR)&&\n\t    (!isUpSampled(tif)))\n\t\trowblock = td->td_ycbcrsubsampling[1];\n\telse\n\t\trowblock = 1;\n\trowblockbytes = TIFFVTileSize64(tif, rowblock);\n\t/*\n\t * Make the rows hold at least one scanline, but fill specified amount\n\t * of data if possible.\n\t */\n\tif (rowblockbytes > STRIP_SIZE_DEFAULT) {\n\t\tstripbytes = rowblockbytes;\n\t\trowsperstrip = rowblock;\n\t} else if (rowblockbytes > 0 ) {\n\t\tuint32 rowblocksperstrip;\n\t\trowblocksperstrip = (uint32) (STRIP_SIZE_DEFAULT / rowblockbytes);\n\t\trowsperstrip = rowblocksperstrip * rowblock;\n\t\tstripbytes = rowblocksperstrip * rowblockbytes;\n\t}\n\telse\n\t    return;\n\n\t/*\n\t * never increase the number of rows per strip\n\t */\n\tif (rowsperstrip >= td->td_rowsperstrip)\n\t\treturn;\n        nstrips = TIFFhowmany_32(td->td_imagelength, rowsperstrip);\n        if( nstrips == 0 )\n            return;\n\n\tnewcounts = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),\n\t\t\t\t\"for chopped \\\"StripByteCounts\\\" array\");\n\tnewoffsets = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),\n\t\t\t\t\"for chopped \\\"StripOffsets\\\" array\");\n\tif (newcounts == NULL || newoffsets == NULL) {\n\t\t/*\n\t\t * Unable to allocate new strip information, give up and use\n\t\t * the original one strip information.\n\t\t */\n\t\tif (newcounts != NULL)\n\t\t\t_TIFFfree(newcounts);\n\t\tif (newoffsets != NULL)\n\t\t\t_TIFFfree(newoffsets);\n\t\treturn;\n\t}\n\t/*\n\t * Fill the strip information arrays with new bytecounts and offsets\n\t * that reflect the broken-up format.\n\t */\n\tfor (strip = 0; strip < nstrips; strip++) {\n\t\tif (stripbytes > bytecount)\n\t\t\tstripbytes = bytecount;\n\t\tnewcounts[strip] = stripbytes;\n\t\tnewoffsets[strip] = stripbytes ? offset : 0;\n\t\toffset += stripbytes;\n\t\tbytecount -= stripbytes;\n\t}\n\t/*\n\t * Replace old single strip info with multi-strip info.\n\t */\n\ttd->td_stripsperimage = td->td_nstrips = nstrips;\n\tTIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\n\t_TIFFfree(td->td_stripbytecount);\n\t_TIFFfree(td->td_stripoffset);\n\ttd->td_stripbytecount = newcounts;\n\ttd->td_stripoffset = newoffsets;\n\ttd->td_stripbytecountsorted = 1;\n}",
        "begin_line": 5495,
        "end_line": 5582,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFCheckDirOffset#4383",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFCheckDirOffset(TIFF* tif, uint64 diroff)",
        "snippet": "static int\nTIFFCheckDirOffset(TIFF* tif, uint64 diroff)\n{\n\tuint16 n;\n\n\tif (diroff == 0)\t\t\t/* no more directories */\n\t\treturn 0;\n\tif (tif->tif_dirnumber == 65535) {\n\t    TIFFErrorExt(tif->tif_clientdata, \"TIFFCheckDirOffset\",\n\t\t\t \"Cannot handle more than 65535 TIFF directories\");\n\t    return 0;\n\t}\n\n\tfor (n = 0; n < tif->tif_dirnumber && tif->tif_dirlist; n++) {\n\t\tif (tif->tif_dirlist[n] == diroff)\n\t\t\treturn 0;\n\t}\n\n\ttif->tif_dirnumber++;\n\n\tif (tif->tif_dirlist == NULL || tif->tif_dirnumber > tif->tif_dirlistsize) {\n\t\tuint64* new_dirlist;\n\n\t\t/*\n\t\t * XXX: Reduce memory allocation granularity of the dirlist\n\t\t * array.\n\t\t */\n\t\tnew_dirlist = (uint64*)_TIFFCheckRealloc(tif, tif->tif_dirlist,\n\t\t    tif->tif_dirnumber, 2 * sizeof(uint64), \"for IFD list\");\n\t\tif (!new_dirlist)\n\t\t\treturn 0;\n\t\tif( tif->tif_dirnumber >= 32768 )\n\t\t    tif->tif_dirlistsize = 65535;\n\t\telse\n\t\t    tif->tif_dirlistsize = 2 * tif->tif_dirnumber;\n\t\ttif->tif_dirlist = new_dirlist;\n\t}\n\n\ttif->tif_dirlist[tif->tif_dirnumber - 1] = diroff;\n\n\treturn 1;\n}",
        "begin_line": 4383,
        "end_line": 4424,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFFetchDirectory#4457",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir, uint64 *nextdiroff)",
        "snippet": "static uint16\nTIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir,\n                   uint64 *nextdiroff)\n{\n\tstatic const char module[] = \"TIFFFetchDirectory\";\n\n\tvoid* origdir;\n\tuint16 dircount16;\n\tuint32 dirsize;\n\tTIFFDirEntry* dir;\n\tuint8* ma;\n\tTIFFDirEntry* mb;\n\tuint16 n;\n\n\tassert(pdir);\n\n\ttif->tif_diroff = diroff;\n\tif (nextdiroff)\n\t\t*nextdiroff = 0;\n\tif (!isMapped(tif)) {\n\t\tif (!SeekOK(tif, tif->tif_diroff)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%s: Seek error accessing TIFF directory\",\n\t\t\t\ttif->tif_name);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tif (!ReadOK(tif, &dircount16, sizeof (uint16))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"%s: Can not read TIFF directory count\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&dircount16);\n\t\t\tif (dircount16>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdirsize = 12;\n\t\t} else {\n\t\t\tuint64 dircount64;\n\t\t\tif (!ReadOK(tif, &dircount64, sizeof (uint64))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\"%s: Can not read TIFF directory count\",\n\t\t\t\t\ttif->tif_name);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\tif (dircount64>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdircount16 = (uint16)dircount64;\n\t\t\tdirsize = 20;\n\t\t}\n\t\torigdir = _TIFFCheckMalloc(tif, dircount16,\n\t\t    dirsize, \"to read TIFF directory\");\n\t\tif (origdir == NULL)\n\t\t\treturn 0;\n\t\tif (!ReadOK(tif, origdir, (tmsize_t)(dircount16*dirsize))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%.100s: Can not read TIFF directory\",\n\t\t\t\ttif->tif_name);\n\t\t\t_TIFFfree(origdir);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Read offset to next directory for sequential scans if\n\t\t * needed.\n\t\t */\n\t\tif (nextdiroff)\n\t\t{\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t{\n\t\t\t\tuint32 nextdiroff32;\n\t\t\t\tif (!ReadOK(tif, &nextdiroff32, sizeof(uint32)))\n\t\t\t\t\tnextdiroff32 = 0;\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong(&nextdiroff32);\n\t\t\t\t*nextdiroff=nextdiroff32;\n\t\t\t} else {\n\t\t\t\tif (!ReadOK(tif, nextdiroff, sizeof(uint64)))\n\t\t\t\t\t*nextdiroff = 0;\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong8(nextdiroff);\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttmsize_t m;\n\t\ttmsize_t off = (tmsize_t) tif->tif_diroff;\n\t\tif ((uint64)off!=tif->tif_diroff)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Can not read TIFF directory count\");\n\t\t\treturn(0);\n\t\t}\n\n\t\t/*\n\t\t * Check for integer overflow when validating the dir_off,\n\t\t * otherwise a very high offset may cause an OOB read and\n\t\t * crash the client. Make two comparisons instead of\n\t\t *\n\t\t *  off + sizeof(uint16) > tif->tif_size\n\t\t *\n\t\t * to avoid overflow.\n\t\t */\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tm=off+sizeof(uint16);\n\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint16))||(m>tif->tif_size)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\"Can not read TIFF directory count\");\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t_TIFFmemcpy(&dircount16, tif->tif_base + off,\n\t\t\t\t\t    sizeof(uint16));\n\t\t\t}\n\t\t\toff += sizeof (uint16);\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&dircount16);\n\t\t\tif (dircount16>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdirsize = 12;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint64 dircount64;\n\t\t\tm=off+sizeof(uint64);\n\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint64))||(m>tif->tif_size)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\"Can not read TIFF directory count\");\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t_TIFFmemcpy(&dircount64, tif->tif_base + off,\n\t\t\t\t\t    sizeof(uint64));\n\t\t\t}\n\t\t\toff += sizeof (uint64);\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\tif (dircount64>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdircount16 = (uint16)dircount64;\n\t\t\tdirsize = 20;\n\t\t}\n\t\tif (dircount16 == 0 )\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t             \"Sanity check on directory count failed, zero tag directories not supported\");\n\t\t\treturn 0;\n\t\t}\n\t\torigdir = _TIFFCheckMalloc(tif, dircount16,\n\t\t\t\t\t\tdirsize,\n\t\t\t\t\t\t\"to read TIFF directory\");\n\t\tif (origdir == NULL)\n\t\t\treturn 0;\n\t\tm=off+dircount16*dirsize;\n\t\tif ((m<off)||(m<(tmsize_t)(dircount16*dirsize))||(m>tif->tif_size)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"Can not read TIFF directory\");\n\t\t\t_TIFFfree(origdir);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t_TIFFmemcpy(origdir, tif->tif_base + off,\n\t\t\t\t    dircount16 * dirsize);\n\t\t}\n\t\tif (nextdiroff) {\n\t\t\toff += dircount16 * dirsize;\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t{\n\t\t\t\tuint32 nextdiroff32;\n\t\t\t\tm=off+sizeof(uint32);\n\t\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint32))||(m>tif->tif_size))\n\t\t\t\t\tnextdiroff32 = 0;\n\t\t\t\telse\n\t\t\t\t\t_TIFFmemcpy(&nextdiroff32, tif->tif_base + off,\n\t\t\t\t\t\t    sizeof (uint32));\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong(&nextdiroff32);\n\t\t\t\t*nextdiroff = nextdiroff32;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm=off+sizeof(uint64);\n\t\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint64))||(m>tif->tif_size))\n\t\t\t\t\t*nextdiroff = 0;\n\t\t\t\telse\n\t\t\t\t\t_TIFFmemcpy(nextdiroff, tif->tif_base + off,\n\t\t\t\t\t\t    sizeof (uint64));\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong8(nextdiroff);\n\t\t\t}\n\t\t}\n\t}\n\tdir = (TIFFDirEntry*)_TIFFCheckMalloc(tif, dircount16,\n\t\t\t\t\t\tsizeof(TIFFDirEntry),\n\t\t\t\t\t\t\"to read TIFF directory\");\n\tif (dir==0)\n\t{\n\t\t_TIFFfree(origdir);\n\t\treturn 0;\n\t}\n\tma=(uint8*)origdir;\n\tmb=dir;\n\tfor (n=0; n<dircount16; n++)\n\t{\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabShort((uint16*)ma);\n\t\tmb->tdir_tag=*(uint16*)ma;\n\t\tma+=sizeof(uint16);\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabShort((uint16*)ma);\n\t\tmb->tdir_type=*(uint16*)ma;\n\t\tma+=sizeof(uint16);\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\tmb->tdir_count=(uint64)(*(uint32*)ma);\n\t\t\tma+=sizeof(uint32);\n\t\t\t*(uint32*)(&mb->tdir_offset)=*(uint32*)ma;\n\t\t\tma+=sizeof(uint32);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8((uint64*)ma);\n                        mb->tdir_count=TIFFReadUInt64(ma);\n\t\t\tma+=sizeof(uint64);\n\t\t\tmb->tdir_offset.toff_long8=TIFFReadUInt64(ma);\n\t\t\tma+=sizeof(uint64);\n\t\t}\n\t\tmb++;\n\t}\n\t_TIFFfree(origdir);\n\t*pdir = dir;\n\treturn dircount16;\n}",
        "begin_line": 4457,
        "end_line": 4707,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFFetchNormalTag#4712",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)",
        "snippet": "static int\nTIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)\n{\n\tstatic const char module[] = \"TIFFFetchNormalTag\";\n\tenum TIFFReadDirEntryErr err;\n\tuint32 fii;\n\tconst TIFFField* fip = NULL;\n\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n        if( fii == FAILED_FII )\n        {\n            TIFFErrorExt(tif->tif_clientdata, \"TIFFFetchNormalTag\",\n                         \"No definition found for tag %d\",\n                         dp->tdir_tag);\n            return 0;\n        }\n\tfip=tif->tif_fields[fii];\n\tassert(fip != NULL); /* should not happen */\n\tassert(fip->set_field_type!=TIFF_SETGET_OTHER);  /* if so, we shouldn't arrive here but deal with this in specialized code */\n\tassert(fip->set_field_type!=TIFF_SETGET_INT);    /* if so, we shouldn't arrive here as this is only the case for pseudo-tags */\n\terr=TIFFReadDirEntryErrOk;\n\tswitch (fip->set_field_type)\n\t{\n\t\tcase TIFF_SETGET_UNDEFINED:\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_ASCII:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tuint8* ma;\n\t\t\t\t\tuint32 mb;\n\t\t\t\t\tint n;\n\t\t\t\t\tma=data;\n\t\t\t\t\tmb=0;\n\t\t\t\t\twhile (mb<(uint32)dp->tdir_count)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (*ma==0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tma++;\n\t\t\t\t\t\tmb++;\n\t\t\t\t\t}\n\t\t\t\t\tif (mb+1<(uint32)dp->tdir_count)\n\t\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" contains null byte in value; value incorrectly truncated during reading due to implementation limitations\",fip->field_name);\n\t\t\t\t\telse if (mb+1>(uint32)dp->tdir_count)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8* o;\n\t\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" does not end in null byte\",fip->field_name);\n\t\t\t\t\t\tif ((uint32)dp->tdir_count+1!=dp->tdir_count+1)\n\t\t\t\t\t\t\to=NULL;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\to=_TIFFmalloc((uint32)dp->tdir_count+1);\n\t\t\t\t\t\tif (o==NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (data!=NULL)\n\t\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_TIFFmemcpy(o,data,(uint32)dp->tdir_count);\n\t\t\t\t\t\to[(uint32)dp->tdir_count]=0;\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tdata=o;\n\t\t\t\t\t}\n\t\t\t\t\tn=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!n)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT8:\n\t\t\t{\n\t\t\t\tuint8 data=0;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryByte(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT16:\n\t\t\t{\n\t\t\t\tuint16 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryShort(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT32:\n\t\t\t{\n\t\t\t\tuint32 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryLong(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT64:\n\t\t\t{\n\t\t\t\tuint64 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryLong8(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_FLOAT:\n\t\t\t{\n\t\t\t\tfloat data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryFloat(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_DOUBLE:\n\t\t\t{\n\t\t\t\tdouble data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryDouble(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_IFD8:\n\t\t\t{\n\t\t\t\tuint64 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryIfd8(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT16_PAIR:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount==2);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=2) {\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t\t\t       \"incorrect count for field \\\"%s\\\", expected 2, got %d\",\n\t\t\t\t\t\t       fip->field_name,(int)dp->tdir_count);\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data[0],data[1]);\n\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_UINT8:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount) {\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t\t\t       \"incorrect count for field \\\"%s\\\", expected %d, got %d\",\n\t\t\t\t\t\t       fip->field_name,(int) fip->field_readcount, (int)dp->tdir_count);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_UINT16:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)\n                                    /* corrupt file */;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_UINT32:\n\t\t\t{\n\t\t\t\tuint32* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)\n                                    /* corrupt file */;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_FLOAT:\n\t\t\t{\n\t\t\t\tfloat* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)\n                                    /* corrupt file */;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_ASCII:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n                        if( dp->tdir_count > 0 && data[dp->tdir_count-1] != '\\0' )\n                        {\n                            TIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" does not end in null byte. Forcing it to be null\",fip->field_name);\n                            data[dp->tdir_count-1] = '\\0';\n                        }\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT8:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT16:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT32:\n\t\t\t{\n\t\t\t\tuint32* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT64:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryLong8Array(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_FLOAT:\n\t\t\t{\n\t\t\t\tfloat* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_DOUBLE:\n\t\t\t{\n\t\t\t\tdouble* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryDoubleArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_IFD8:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryIfd8Array(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_ASCII:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n                    if( dp->tdir_count > 0 && data[dp->tdir_count-1] != '\\0' )\n                    {\n                        TIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" does not end in null byte. Forcing it to be null\",fip->field_name);\n                        data[dp->tdir_count-1] = '\\0';\n                    }\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT8:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT8:\n\t\t\t{\n\t\t\t\tint8* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySbyteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT16:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT16:\n\t\t\t{\n\t\t\t\tint16* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySshortArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT32:\n\t\t\t{\n\t\t\t\tuint32* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT32:\n\t\t\t{\n\t\t\t\tint32* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySlongArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT64:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryLong8Array(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT64:\n\t\t\t{\n\t\t\t\tint64* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySlong8Array(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_FLOAT:\n\t\t\t{\n\t\t\t\tfloat* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_DOUBLE:\n\t\t\t{\n\t\t\t\tdouble* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryDoubleArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_IFD8:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryIfd8Array(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);    /* we should never get here */\n\t\t\tbreak;\n\t}\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip->field_name,recover);\n\t\treturn(0);\n\t}\n\treturn(1);\n}",
        "begin_line": 4712,
        "end_line": 5390,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFFetchStripThing#5396",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32 nstrips, uint64** lpp)",
        "snippet": "static int\nTIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32 nstrips, uint64** lpp)\n{\n\tstatic const char module[] = \"TIFFFetchStripThing\";\n\tenum TIFFReadDirEntryErr err;\n\tuint64* data;\n\terr=TIFFReadDirEntryLong8Array(tif,dir,&data);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\tconst TIFFField* fip = TIFFFieldWithTag(tif,dir->tdir_tag); \n\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",0);\n\t\treturn(0);\n\t}\n\tif (dir->tdir_count!=(uint64)nstrips)\n\t{\n\t\tuint64* resizeddata;\n\t\tresizeddata=(uint64*)_TIFFCheckMalloc(tif,nstrips,sizeof(uint64),\"for strip array\");\n\t\tif (resizeddata==0) {\n\t\t\t_TIFFfree(data);\n\t\t\treturn(0);\n\t\t}\n\t\tif (dir->tdir_count<(uint64)nstrips)\n\t\t{\n\t\t\t_TIFFmemcpy(resizeddata,data,(uint32)dir->tdir_count*sizeof(uint64));\n\t\t\t_TIFFmemset(resizeddata+(uint32)dir->tdir_count,0,(nstrips-(uint32)dir->tdir_count)*sizeof(uint64));\n\t\t}\n\t\telse\n\t\t\t_TIFFmemcpy(resizeddata,data,nstrips*sizeof(uint64));\n\t\t_TIFFfree(data);\n\t\tdata=resizeddata;\n\t}\n\t*lpp=data;\n\treturn(1);\n}",
        "begin_line": 5396,
        "end_line": 5429,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryArray#767",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryArray(TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize, void** value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryArray(TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize, void** value)\n{\n\tint typesize;\n\tuint32 datasize;\n\tvoid* data;\n\ttypesize=TIFFDataWidth(direntry->tdir_type);\n\tif ((direntry->tdir_count==0)||(typesize==0))\n\t{\n\t\t*value=0;\n\t\treturn(TIFFReadDirEntryErrOk);\n\t}\n        (void) desttypesize;\n\n        /* \n         * As a sanity check, make sure we have no more than a 2GB tag array \n         * in either the current data type or the dest data type.  This also\n         * avoids problems with overflow of tmsize_t on 32bit systems.\n         */\n\tif ((uint64)(2147483647/typesize)<direntry->tdir_count)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\tif ((uint64)(2147483647/desttypesize)<direntry->tdir_count)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\n\t*count=(uint32)direntry->tdir_count;\n\tdatasize=(*count)*typesize;\n\tassert((tmsize_t)datasize>0);\n\tdata=_TIFFCheckMalloc(tif, *count, typesize, \"ReadDirEntryArray\");\n\tif (data==0)\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tif (datasize<=4)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint32 offset = direntry->tdir_offset.toff_long;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&offset);\n\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (datasize<=8)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint64 offset = direntry->tdir_offset.toff_long8;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&offset);\n\t\t\terr=TIFFReadDirEntryData(tif,offset,(tmsize_t)datasize,data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 767,
        "end_line": 834,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryByteArray#836",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntry* direntry, uint8** value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntry* direntry, uint8** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tuint8* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_UNDEFINED:\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,1,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_UNDEFINED:\n\t\tcase TIFF_BYTE:\n\t\t\t*value=(uint8*)origdata;\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8* m;\n\t\t\t\tuint32 n;\n\t\t\t\tm=(int8*)origdata;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSbyte(*m);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\t_TIFFfree(origdata);\n\t\t\t\t\t\treturn(err);\n\t\t\t\t\t}\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t\t*value=(uint8*)origdata;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t}\n\tdata=(uint8*)_TIFFmalloc(count);\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteShort(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort((uint16*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSshort(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteLong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSlong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteLong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8((uint64*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSlong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\t_TIFFfree(data);\n\t\treturn(err);\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 836,
        "end_line": 1015,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryCheckedRational#2854",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryCheckedRational(TIFF* tif, TIFFDirEntry* direntry, double* value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedRational(TIFF* tif, TIFFDirEntry* direntry, double* value)\n{\n\tUInt64Aligned_t m;\n\n\tassert(sizeof(double)==8);\n\tassert(sizeof(uint64)==8);\n\tassert(sizeof(uint32)==4);\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tenum TIFFReadDirEntryErr err;\n\t\tuint32 offset = direntry->tdir_offset.toff_long;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong(&offset);\n\t\terr=TIFFReadDirEntryData(tif,offset,8,m.i);\n\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\treturn(err);\n\t}\n\telse\n\t\tm.l = direntry->tdir_offset.toff_long8;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfLong(m.i,2);\n\tif (m.i[0]==0)\n\t\t*value=0.0;\n\telse\n\t\t*value=(double)m.i[0]/(double)m.i[1];\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 2854,
        "end_line": 2880,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryCheckedShort#2787",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryCheckedShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)",
        "snippet": "static void TIFFReadDirEntryCheckedShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)\n{\n\t*value = direntry->tdir_offset.toff_short;\n\t/* *value=*(uint16*)(&direntry->tdir_offset); */\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabShort(value);\n}",
        "begin_line": 2787,
        "end_line": 2793,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryData#3282",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryData(TIFF* tif, uint64 offset, tmsize_t size, void* dest)",
        "snippet": "static enum TIFFReadDirEntryErr\nTIFFReadDirEntryData(TIFF* tif, uint64 offset, tmsize_t size, void* dest)\n{\n\tassert(size>0);\n\tif (!isMapped(tif)) {\n\t\tif (!SeekOK(tif,offset))\n\t\t\treturn(TIFFReadDirEntryErrIo);\n\t\tif (!ReadOK(tif,dest,size))\n\t\t\treturn(TIFFReadDirEntryErrIo);\n\t} else {\n\t\tsize_t ma,mb;\n\t\tma=(size_t)offset;\n\t\tmb=ma+size;\n\t\tif (((uint64)ma!=offset)\n\t\t    || (mb < ma)\n\t\t    || (mb - ma != (size_t) size)\n\t\t    || (mb < (size_t)size)\n\t\t    || (mb > (size_t)tif->tif_size)\n\t\t    )\n\t\t\treturn(TIFFReadDirEntryErrIo);\n\t\t_TIFFmemcpy(dest,tif->tif_base+ma,size);\n\t}\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 3282,
        "end_line": 3305,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryDouble#646",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryDouble(TIFF* tif, TIFFDirEntry* direntry, double* value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryDouble(TIFF* tif, TIFFDirEntry* direntry, double* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tif (direntry->tdir_count!=1)\n\t\treturn(TIFFReadDirEntryErrCount);\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedByte(tif,direntry,&m);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedSbyte(tif,direntry,&m);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedShort(tif,direntry,&m);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedSshort(tif,direntry,&m);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedLong(tif,direntry,&m);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedSlong(tif,direntry,&m);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n#if defined(__WIN32__) && (_MSC_VER < 1500)\n\t\t\t\t/*\n\t\t\t\t * XXX: MSVC 6.0 does not support conversion\n\t\t\t\t * of 64-bit integers into floating point\n\t\t\t\t * values.\n\t\t\t\t */\n\t\t\t\t*value = _TIFFUInt64ToDouble(m);\n#else\n\t\t\t\t*value = (double)m;\n#endif\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_RATIONAL:\n\t\t\terr=TIFFReadDirEntryCheckedRational(tif,direntry,value);\n\t\t\treturn(err);\n\t\tcase TIFF_SRATIONAL:\n\t\t\terr=TIFFReadDirEntryCheckedSrational(tif,direntry,value);\n\t\t\treturn(err);\n\t\tcase TIFF_FLOAT:\n\t\t\t{\n\t\t\t\tfloat m;\n\t\t\t\tTIFFReadDirEntryCheckedFloat(tif,direntry,&m);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_DOUBLE:\n\t\t\terr=TIFFReadDirEntryCheckedDouble(tif,direntry,value);\n\t\t\treturn(err);\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n}",
        "begin_line": 646,
        "end_line": 741,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryLong#374",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryLong(TIFF* tif, TIFFDirEntry* direntry, uint32* value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryLong(TIFF* tif, TIFFDirEntry* direntry, uint32* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tif (direntry->tdir_count!=1)\n\t\treturn(TIFFReadDirEntryErrCount);\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedByte(tif,direntry,&m);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedSbyte(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSbyte(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedShort(tif,direntry,&m);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedSshort(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSshort(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG:\n\t\t\tTIFFReadDirEntryCheckedLong(tif,direntry,value);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedSlong(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSlong(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongLong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSlong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n}",
        "begin_line": 374,
        "end_line": 455,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryLong8Array#1865",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tuint64* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,8,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_LONG8:\n\t\t\t*value=(uint64*)origdata;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabArrayOfLong8(*value,count);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64* m;\n\t\t\t\tuint32 n;\n\t\t\t\tm=(int64*)origdata;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8((uint64*)m);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Slong8(*m);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\t_TIFFfree(origdata);\n\t\t\t\t\t\treturn(err);\n\t\t\t\t\t}\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t\t*value=(uint64*)origdata;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t}\n\tdata=(uint64*)_TIFFmalloc(count*8);\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Sbyte(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort(ma);\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort((uint16*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Sshort(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Slong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\t_TIFFfree(data);\n\t\treturn(err);\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 1865,
        "end_line": 2029,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryOutputErr#3307",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryOutputErr(TIFF* tif, enum TIFFReadDirEntryErr err, const char* module, const char* tagname, int recover)",
        "snippet": "static void TIFFReadDirEntryOutputErr(TIFF* tif, enum TIFFReadDirEntryErr err, const char* module, const char* tagname, int recover)\n{\n\tif (!recover) {\n\t\tswitch (err) {\n\t\t\tcase TIFFReadDirEntryErrCount:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Incorrect count for \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrType:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Incompatible type for \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrIo:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"IO error during reading of \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrRange:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Incorrect value for \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrPsdif:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"Cannot handle different values per sample for \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrSizesan:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"Sanity check on size of \\\"%s\\\" value failed\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrAlloc:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Out of memory reading of \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);   /* we should never get here */\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (err) {\n\t\t\tcase TIFFReadDirEntryErrCount:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"Incorrect count for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrType:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"Incompatible type for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrIo:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\"IO error during reading of \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrRange:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"Incorrect value for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrPsdif:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\"Cannot handle different values per sample for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrSizesan:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\"Sanity check on size of \\\"%s\\\" value failed; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrAlloc:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"Out of memory reading of \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);   /* we should never get here */\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
        "begin_line": 3307,
        "end_line": 3392,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryPersampleShort#2717",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryPersampleShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryPersampleShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint16* m;\n\tuint16* na;\n\tuint16 nb;\n\tif (direntry->tdir_count<(uint64)tif->tif_dir.td_samplesperpixel)\n\t\treturn(TIFFReadDirEntryErrCount);\n\terr=TIFFReadDirEntryShortArray(tif,direntry,&m);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t\treturn(err);\n\tna=m;\n\tnb=tif->tif_dir.td_samplesperpixel;\n\t*value=*na++;\n\tnb--;\n\twhile (nb>0)\n\t{\n\t\tif (*na++!=*value)\n\t\t{\n\t\t\terr=TIFFReadDirEntryErrPsdif;\n\t\t\tbreak;\n\t\t}\n\t\tnb--;\n\t}\n\t_TIFFfree(m);\n\treturn(err);\n}",
        "begin_line": 2717,
        "end_line": 2743,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryShort#288",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tif (direntry->tdir_count!=1)\n\t\treturn(TIFFReadDirEntryErrCount);\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedByte(tif,direntry,&m);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedSbyte(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSbyte(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SHORT:\n\t\t\tTIFFReadDirEntryCheckedShort(tif,direntry,value);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedSshort(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSshort(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedLong(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortLong(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedSlong(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSlong(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortLong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSlong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n}",
        "begin_line": 288,
        "end_line": 372,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirEntryShortArray#1196",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirEntryShortArray(TIFF* tif, TIFFDirEntry* direntry, uint16** value)",
        "snippet": "static enum TIFFReadDirEntryErr TIFFReadDirEntryShortArray(TIFF* tif, TIFFDirEntry* direntry, uint16** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tuint16* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,2,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_SHORT:\n\t\t\t*value=(uint16*)origdata;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabArrayOfShort(*value,count);  \n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16* m;\n\t\t\t\tuint32 n;\n\t\t\t\tm=(int16*)origdata;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort((uint16*)m);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSshort(*m);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\t_TIFFfree(origdata);\n\t\t\t\t\t\treturn(err);\n\t\t\t\t\t}\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t\t*value=(uint16*)origdata;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t}\n\tdata=(uint16*)_TIFFmalloc(count*2);\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSbyte(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortLong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSlong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortLong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8((uint64*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSlong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\t_TIFFfree(data);\n\t\treturn(err);\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "begin_line": 1196,
        "end_line": 1366,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirectory#3398",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirectory(TIFF* tif)",
        "snippet": "int\nTIFFReadDirectory(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFReadDirectory\";\n\tTIFFDirEntry* dir;\n\tuint16 dircount;\n\tTIFFDirEntry* dp;\n\tuint16 di;\n\tconst TIFFField* fip;\n\tuint32 fii=FAILED_FII;\n        toff_t nextdiroff;\n    int bitspersample_read = FALSE;\n\n\ttif->tif_diroff=tif->tif_nextdiroff;\n\tif (!TIFFCheckDirOffset(tif,tif->tif_nextdiroff))\n\t\treturn 0;           /* last offset or bad offset (IFD looping) */\n\t(*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */\n\ttif->tif_curdir++;\n        nextdiroff = tif->tif_nextdiroff;\n\tdircount=TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff);\n\tif (!dircount)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"Failed to read directory at offset \" TIFF_UINT64_FORMAT,nextdiroff);\n\t\treturn 0;\n\t}\n\tTIFFReadDirectoryCheckOrder(tif,dir,dircount);\n\n        /*\n         * Mark duplicates of any tag to be ignored (bugzilla 1994)\n         * to avoid certain pathological problems.\n         */\n\t{\n\t\tTIFFDirEntry* ma;\n\t\tuint16 mb;\n\t\tfor (ma=dir, mb=0; mb<dircount; ma++, mb++)\n\t\t{\n\t\t\tTIFFDirEntry* na;\n\t\t\tuint16 nb;\n\t\t\tfor (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)\n\t\t\t{\n\t\t\t\tif (ma->tdir_tag==na->tdir_tag)\n\t\t\t\t\tna->tdir_tag=IGNORE;\n\t\t\t}\n\t\t}\n\t}\n        \n\ttif->tif_flags &= ~TIFF_BEENWRITING;    /* reset before new dir */\n\ttif->tif_flags &= ~TIFF_BUF4WRITE;      /* reset before new dir */\n\t/* free any old stuff and reinit */\n\tTIFFFreeDirectory(tif);\n\tTIFFDefaultDirectory(tif);\n\t/*\n\t * Electronic Arts writes gray-scale TIFF files\n\t * without a PlanarConfiguration directory entry.\n\t * Thus we setup a default value here, even though\n\t * the TIFF spec says there is no default value.\n\t */\n\tTIFFSetField(tif,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n\t/*\n\t * Setup default value and then make a pass over\n\t * the fields to check type and tag information,\n\t * and to extract info required to size data\n\t * structures.  A second pass is made afterwards\n\t * to read in everything not taken in the first pass.\n\t * But we must process the Compression tag first\n\t * in order to merge in codec-private tag definitions (otherwise\n\t * we may get complaints about unknown tags).  However, the\n\t * Compression tag may be dependent on the SamplesPerPixel\n\t * tag value because older TIFF specs permitted Compression\n\t * to be written as a SamplesPerPixel-count tag entry.\n\t * Thus if we don't first figure out the correct SamplesPerPixel\n\t * tag value then we may end up ignoring the Compression tag\n\t * value because it has an incorrect count value (if the\n\t * true value of SamplesPerPixel is not 1).\n\t */\n\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_SAMPLESPERPIXEL);\n\tif (dp)\n\t{\n\t\tif (!TIFFFetchNormalTag(tif,dp,0))\n\t\t\tgoto bad;\n\t\tdp->tdir_tag=IGNORE;\n\t}\n\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_COMPRESSION);\n\tif (dp)\n\t{\n\t\t/*\n\t\t * The 5.0 spec says the Compression tag has one value, while\n\t\t * earlier specs say it has one value per sample.  Because of\n\t\t * this, we accept the tag if one value is supplied with either\n\t\t * count.\n\t\t */\n\t\tuint16 value;\n\t\tenum TIFFReadDirEntryErr err;\n\t\terr=TIFFReadDirEntryShort(tif,dp,&value);\n\t\tif (err==TIFFReadDirEntryErrCount)\n\t\t\terr=TIFFReadDirEntryPersampleShort(tif,dp,&value);\n\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t{\n\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,\"Compression\",0);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (!TIFFSetField(tif,TIFFTAG_COMPRESSION,value))\n\t\t\tgoto bad;\n\t\tdp->tdir_tag=IGNORE;\n\t}\n\telse\n\t{\n\t\tif (!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE))\n\t\t\tgoto bad;\n\t}\n\t/*\n\t * First real pass over the directory.\n\t */\n\tfor (di=0, dp=dir; di<dircount; di++, dp++)\n\t{\n\t\tif (dp->tdir_tag!=IGNORE)\n\t\t{\n\t\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\t\tif (fii == FAILED_FII)\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Unknown field with tag %d (0x%x) encountered\",\n\t\t\t\t    dp->tdir_tag,dp->tdir_tag);\n                                /* the following knowingly leaks the \n                                   anonymous field structure */\n\t\t\t\tif (!_TIFFMergeFields(tif,\n\t\t\t\t\t_TIFFCreateAnonField(tif,\n\t\t\t\t\t\tdp->tdir_tag,\n\t\t\t\t\t\t(TIFFDataType) dp->tdir_type),\n\t\t\t\t\t1)) {\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t    module,\n\t\t\t\t\t    \"Registering anonymous field with tag %d (0x%x) failed\",\n\t\t\t\t\t    dp->tdir_tag,\n\t\t\t\t\t    dp->tdir_tag);\n\t\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\t\t} else {\n\t\t\t\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\t\t\t\tassert(fii != FAILED_FII);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dp->tdir_tag!=IGNORE)\n\t\t{\n\t\t\tfip=tif->tif_fields[fii];\n\t\t\tif (fip->field_bit==FIELD_IGNORE)\n\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tswitch (dp->tdir_tag)\n\t\t\t\t{\n\t\t\t\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\t\t\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\t\t\t\tcase TIFFTAG_TILEOFFSETS:\n\t\t\t\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\t\t\t\t\tTIFFSetFieldBit(tif,fip->field_bit);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TIFFTAG_IMAGEWIDTH:\n\t\t\t\t\tcase TIFFTAG_IMAGELENGTH:\n\t\t\t\t\tcase TIFFTAG_IMAGEDEPTH:\n\t\t\t\t\tcase TIFFTAG_TILELENGTH:\n\t\t\t\t\tcase TIFFTAG_TILEWIDTH:\n\t\t\t\t\tcase TIFFTAG_TILEDEPTH:\n\t\t\t\t\tcase TIFFTAG_PLANARCONFIG:\n\t\t\t\t\tcase TIFFTAG_ROWSPERSTRIP:\n\t\t\t\t\tcase TIFFTAG_EXTRASAMPLES:\n\t\t\t\t\t\tif (!TIFFFetchNormalTag(tif,dp,0))\n\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * XXX: OJPEG hack.\n\t * If a) compression is OJPEG, b) planarconfig tag says it's separate,\n\t * c) strip offsets/bytecounts tag are both present and\n\t * d) both contain exactly one value, then we consistently find\n\t * that the buggy implementation of the buggy compression scheme\n\t * matches contig planarconfig best. So we 'fix-up' the tag here\n\t */\n\tif ((tif->tif_dir.td_compression==COMPRESSION_OJPEG)&&\n\t    (tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE))\n\t{\n        if (!_TIFFFillStriles(tif))\n            goto bad;\n\t\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS);\n\t\tif ((dp!=0)&&(dp->tdir_count==1))\n\t\t{\n\t\t\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,\n\t\t\t    TIFFTAG_STRIPBYTECOUNTS);\n\t\t\tif ((dp!=0)&&(dp->tdir_count==1))\n\t\t\t{\n\t\t\t\ttif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t    \"Planarconfig tag value assumed incorrect, \"\n\t\t\t\t    \"assuming data is contig instead of chunky\");\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Allocate directory structure and setup defaults.\n\t */\n\tif (!TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))\n\t{\n\t\tMissingRequired(tif,\"ImageLength\");\n\t\tgoto bad;\n\t}\n\t/*\n\t * Setup appropriate structures (by strip or by tile)\n\t */\n\tif (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {\n\t\ttif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif);  \n\t\ttif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;\n\t\ttif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;\n\t\ttif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;\n\t\ttif->tif_flags &= ~TIFF_ISTILED;\n\t} else {\n\t\ttif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);\n\t\ttif->tif_flags |= TIFF_ISTILED;\n\t}\n\tif (!tif->tif_dir.td_nstrips) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Cannot handle zero number of %s\",\n\t\t    isTiled(tif) ? \"tiles\" : \"strips\");\n\t\tgoto bad;\n\t}\n\ttif->tif_dir.td_stripsperimage = tif->tif_dir.td_nstrips;\n\tif (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\ttif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel;\n\tif (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {\n#ifdef OJPEG_SUPPORT\n\t\tif ((tif->tif_dir.td_compression==COMPRESSION_OJPEG) &&\n\t\t    (isTiled(tif)==0) &&\n\t\t    (tif->tif_dir.td_nstrips==1)) {\n\t\t\t/*\n\t\t\t * XXX: OJPEG hack.\n\t\t\t * If a) compression is OJPEG, b) it's not a tiled TIFF,\n\t\t\t * and c) the number of strips is 1,\n\t\t\t * then we tolerate the absence of stripoffsets tag,\n\t\t\t * because, presumably, all required data is in the\n\t\t\t * JpegInterchangeFormat stream.\n\t\t\t */\n\t\t\tTIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);\n\t\t} else\n#endif\n        {\n\t\t\tMissingRequired(tif,\n\t\t\t\tisTiled(tif) ? \"TileOffsets\" : \"StripOffsets\");\n\t\t\tgoto bad;\n\t\t}\n\t}\n\t/*\n\t * Second pass: extract other information.\n\t */\n\tfor (di=0, dp=dir; di<dircount; di++, dp++)\n\t{\n\t\tswitch (dp->tdir_tag)\n\t\t{\n\t\t\tcase IGNORE:\n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\t\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\t\tcase TIFFTAG_BITSPERSAMPLE:\n\t\t\tcase TIFFTAG_DATATYPE:\n\t\t\tcase TIFFTAG_SAMPLEFORMAT:\n\t\t\t\t/*\n\t\t\t\t * The MinSampleValue, MaxSampleValue, BitsPerSample\n\t\t\t\t * DataType and SampleFormat tags are supposed to be\n\t\t\t\t * written as one value/sample, but some vendors\n\t\t\t\t * incorrectly write one value only -- so we accept\n\t\t\t\t * that as well (yuck). Other vendors write correct\n\t\t\t\t * value for NumberOfSamples, but incorrect one for\n\t\t\t\t * BitsPerSample and friends, and we will read this\n\t\t\t\t * too.\n\t\t\t\t */\n\t\t\t\t{\n\t\t\t\t\tuint16 value;\n\t\t\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\t\t\terr=TIFFReadDirEntryShort(tif,dp,&value);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrCount)\n\t\t\t\t\t\terr=TIFFReadDirEntryPersampleShort(tif,dp,&value);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tfip = TIFFFieldWithTag(tif,dp->tdir_tag);\n\t\t\t\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",0);\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t}\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,value))\n\t\t\t\t\t\tgoto bad;\n                    if( dp->tdir_tag == TIFFTAG_BITSPERSAMPLE )\n                        bitspersample_read = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\t\t\t{\n\n\t\t\t\t\tdouble *data = NULL;\n\t\t\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\t\t\tuint32 saved_flags;\n\t\t\t\t\tint m;\n\t\t\t\t\tif (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)\n\t\t\t\t\t\terr = TIFFReadDirEntryErrCount;\n\t\t\t\t\telse\n\t\t\t\t\t\terr = TIFFReadDirEntryDoubleArray(tif, dp, &data);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tfip = TIFFFieldWithTag(tif,dp->tdir_tag);\n\t\t\t\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",0);\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t}\n\t\t\t\t\tsaved_flags = tif->tif_flags;\n\t\t\t\t\ttif->tif_flags |= TIFF_PERSAMPLE;\n\t\t\t\t\tm = TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\ttif->tif_flags = saved_flags;\n\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\t\tcase TIFFTAG_TILEOFFSETS:\n#if defined(DEFER_STRILE_LOAD)\n                                _TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),\n                                             dp, sizeof(TIFFDirEntry) );\n#else                          \n\t\t\t\tif (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset))  \n\t\t\t\t\tgoto bad;\n#endif                                \n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\t\tcase TIFFTAG_TILEBYTECOUNTS:\n#if defined(DEFER_STRILE_LOAD)\n                                _TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),\n                                             dp, sizeof(TIFFDirEntry) );\n#else                          \n\t\t\t\tif (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount))  \n\t\t\t\t\tgoto bad;\n#endif                                \n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_COLORMAP:\n\t\t\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\t\t\t{\n\t\t\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\t\t\tuint32 countpersample;\n\t\t\t\t\tuint32 countrequired;\n\t\t\t\t\tuint32 incrementpersample;\n\t\t\t\t\tuint16* value=NULL;\n                    /* It would be dangerous to instantiate those tag values */\n                    /* since if td_bitspersample has not yet been read (due to */\n                    /* unordered tags), it could be read afterwards with a */\n                    /* values greater than the default one (1), which may cause */\n                    /* crashes in user code */\n                    if( !bitspersample_read )\n                    {\n                        fip = TIFFFieldWithTag(tif,dp->tdir_tag);\n                        TIFFWarningExt(tif->tif_clientdata,module,\n                                       \"Ignoring %s since BitsPerSample tag not found\",\n                                       fip ? fip->field_name : \"unknown tagname\");\n                        continue;\n                    }\n\t\t\t\t\t/* ColorMap or TransferFunction for high bit */\n\t\t\t\t\t/* depths do not make much sense and could be */\n\t\t\t\t\t/* used as a denial of service vector */\n\t\t\t\t\tif (tif->tif_dir.td_bitspersample > 24)\n\t\t\t\t\t{\n\t\t\t\t\t    fip = TIFFFieldWithTag(tif,dp->tdir_tag);\n\t\t\t\t\t    TIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t\t\t\"Ignoring %s because BitsPerSample=%d>24\",\n\t\t\t\t\t\tfip ? fip->field_name : \"unknown tagname\",\n\t\t\t\t\t\ttif->tif_dir.td_bitspersample);\n\t\t\t\t\t    continue;\n\t\t\t\t\t}\n\t\t\t\t\tcountpersample=(1U<<tif->tif_dir.td_bitspersample);\n\t\t\t\t\tif ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))\n\t\t\t\t\t{\n\t\t\t\t\t\tcountrequired=countpersample;\n\t\t\t\t\t\tincrementpersample=0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcountrequired=3*countpersample;\n\t\t\t\t\t\tincrementpersample=countpersample;\n\t\t\t\t\t}\n\t\t\t\t\tif (dp->tdir_count!=(uint64)countrequired)\n\t\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\t\telse\n\t\t\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&value);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n                    {\n\t\t\t\t\t\tfip = TIFFFieldWithTag(tif,dp->tdir_tag);\n\t\t\t\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",1);\n                    }\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tTIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);\n\t\t\t\t\t\t_TIFFfree(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n/* BEGIN REV 4.0 COMPATIBILITY */\n\t\t\tcase TIFFTAG_OSUBFILETYPE:\n\t\t\t\t{\n\t\t\t\t\tuint16 valueo;\n\t\t\t\t\tuint32 value;\n\t\t\t\t\tif (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (valueo)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;\n\t\t\t\t\t\t\tcase OFILETYPE_PAGE: value=FILETYPE_PAGE; break;\n\t\t\t\t\t\t\tdefault: value=0; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value!=0)\n\t\t\t\t\t\t\tTIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n/* END REV 4.0 COMPATIBILITY */\n\t\t\tdefault:\n\t\t\t\t(void) TIFFFetchNormalTag(tif, dp, TRUE);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * OJPEG hack:\n\t * - If a) compression is OJPEG, and b) photometric tag is missing,\n\t * then we consistently find that photometric should be YCbCr\n\t * - If a) compression is OJPEG, and b) photometric tag says it's RGB,\n\t * then we consistently find that the buggy implementation of the\n\t * buggy compression scheme matches photometric YCbCr instead.\n\t * - If a) compression is OJPEG, and b) bitspersample tag is missing,\n\t * then we consistently find bitspersample should be 8.\n\t * - If a) compression is OJPEG, b) samplesperpixel tag is missing,\n\t * and c) photometric is RGB or YCbCr, then we consistently find\n\t * samplesperpixel should be 3\n\t * - If a) compression is OJPEG, b) samplesperpixel tag is missing,\n\t * and c) photometric is MINISWHITE or MINISBLACK, then we consistently\n\t * find samplesperpixel should be 3\n\t */\n\tif (tif->tif_dir.td_compression==COMPRESSION_OJPEG)\n\t{\n\t\tif (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Photometric tag is missing, assuming data is YCbCr\");\n\t\t\tif (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))\n\t\t\t\tgoto bad;\n\t\t}\n\t\telse if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)\n\t\t{\n\t\t\ttif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Photometric tag value assumed incorrect, \"\n\t\t\t    \"assuming data is YCbCr instead of RGB\");\n\t\t}\n\t\tif (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t    \"BitsPerSample tag is missing, assuming 8 bits per sample\");\n\t\t\tif (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))\n\t\t\t\tgoto bad;\n\t\t}\n\t\tif (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\n\t\t{\n\t\t\tif (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t    \"SamplesPerPixel tag is missing, \"\n\t\t\t\t    \"assuming correct SamplesPerPixel value is 3\");\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t    \"SamplesPerPixel tag is missing, \"\n\t\t\t\t    \"applying correct SamplesPerPixel value of 3\");\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\telse if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)\n\t\t\t\t || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * SamplesPerPixel tag is missing, but is not required\n\t\t\t\t * by spec.  Assume correct SamplesPerPixel value of 1.\n\t\t\t\t */\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Verify Palette image has a Colormap.\n\t */\n\tif (tif->tif_dir.td_photometric == PHOTOMETRIC_PALETTE &&\n\t    !TIFFFieldSet(tif, FIELD_COLORMAP)) {\n\t\tif ( tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3)\n\t\t\ttif->tif_dir.td_photometric = PHOTOMETRIC_RGB;\n\t\telse if (tif->tif_dir.td_bitspersample>=8)\n\t\t\ttif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;\n\t\telse {\n\t\t\tMissingRequired(tif, \"Colormap\");\n\t\t\tgoto bad;\n\t\t}\n\t}\n\t/*\n\t * OJPEG hack:\n\t * We do no further messing with strip/tile offsets/bytecounts in OJPEG\n\t * TIFFs\n\t */\n\tif (tif->tif_dir.td_compression!=COMPRESSION_OJPEG)\n\t{\n\t\t/*\n\t\t * Attempt to deal with a missing StripByteCounts tag.\n\t\t */\n\t\tif (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {\n\t\t\t/*\n\t\t\t * Some manufacturers violate the spec by not giving\n\t\t\t * the size of the strips.  In this case, assume there\n\t\t\t * is one uncompressed strip of data.\n\t\t\t */\n\t\t\tif ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&\n\t\t\t    tif->tif_dir.td_nstrips > 1) ||\n\t\t\t    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&\n\t\t\t     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {\n\t\t\t    MissingRequired(tif, \"StripByteCounts\");\n\t\t\t    goto bad;\n\t\t\t}\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"TIFF directory is missing required \"\n\t\t\t\t\"\\\"StripByteCounts\\\" field, calculating from imagelength\");\n\t\t\tif (EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n\t\t/*\n\t\t * Assume we have wrong StripByteCount value (in case\n\t\t * of single strip) in following cases:\n\t\t *   - it is equal to zero along with StripOffset;\n\t\t *   - it is larger than file itself (in case of uncompressed\n\t\t *     image);\n\t\t *   - it is smaller than the size of the bytes per row\n\t\t *     multiplied on the number of rows.  The last case should\n\t\t *     not be checked in the case of writing new image,\n\t\t *     because we may do not know the exact strip size\n\t\t *     until the whole image will be written and directory\n\t\t *     dumped out.\n\t\t */\n\t\t#define\tBYTECOUNTLOOKSBAD \\\n\t\t    ( (tif->tif_dir.td_stripbytecount[0] == 0 && tif->tif_dir.td_stripoffset[0] != 0) || \\\n\t\t      (tif->tif_dir.td_compression == COMPRESSION_NONE && \\\n\t\t       tif->tif_dir.td_stripbytecount[0] > TIFFGetFileSize(tif) - tif->tif_dir.td_stripoffset[0]) || \\\n\t\t      (tif->tif_mode == O_RDONLY && \\\n\t\t       tif->tif_dir.td_compression == COMPRESSION_NONE && \\\n\t\t       tif->tif_dir.td_stripbytecount[0] < TIFFScanlineSize64(tif) * tif->tif_dir.td_imagelength) )\n\n\t\t} else if (tif->tif_dir.td_nstrips == 1\n                           && _TIFFFillStriles(tif)\n\t\t\t   && tif->tif_dir.td_stripoffset[0] != 0\n\t\t\t   && BYTECOUNTLOOKSBAD) {\n\t\t\t/*\n\t\t\t * XXX: Plexus (and others) sometimes give a value of\n\t\t\t * zero for a tag when they don't know what the\n\t\t\t * correct value is!  Try and handle the simple case\n\t\t\t * of estimating the size of a one strip image.\n\t\t\t */\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Bogus \\\"StripByteCounts\\\" field, ignoring and calculating from imagelength\");\n\t\t\tif(EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n\n#if !defined(DEFER_STRILE_LOAD)\n\t\t} else if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG\n\t\t\t   && tif->tif_dir.td_nstrips > 2\n\t\t\t   && tif->tif_dir.td_compression == COMPRESSION_NONE\n\t\t\t   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]\n\t\t\t   && tif->tif_dir.td_stripbytecount[0] != 0\n\t\t\t   && tif->tif_dir.td_stripbytecount[1] != 0 ) {\n\t\t\t/*\n\t\t\t * XXX: Some vendors fill StripByteCount array with\n\t\t\t * absolutely wrong values (it can be equal to\n\t\t\t * StripOffset array, for example). Catch this case\n\t\t\t * here.\n                         *\n                         * We avoid this check if deferring strile loading\n                         * as it would always force us to load the strip/tile\n                         * information.\n\t\t\t */\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Wrong \\\"StripByteCounts\\\" field, ignoring and calculating from imagelength\");\n\t\t\tif (EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n#endif /* !defined(DEFER_STRILE_LOAD) */                        \n\t\t}\n\t}\n\tif (dir)\n\t{\n\t\t_TIFFfree(dir);\n\t\tdir=NULL;\n\t}\n\tif (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))\n\t{\n\t\tif (tif->tif_dir.td_bitspersample>=16)\n\t\t\ttif->tif_dir.td_maxsamplevalue=0xFFFF;\n\t\telse\n\t\t\ttif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1);\n\t}\n\t/*\n\t * XXX: We can optimize checking for the strip bounds using the sorted\n\t * bytecounts array. See also comments for TIFFAppendToStrip()\n\t * function in tif_write.c.\n\t */\n#if !defined(DEFER_STRILE_LOAD)        \n\tif (tif->tif_dir.td_nstrips > 1) {\n\t\tuint32 strip;\n\n\t\ttif->tif_dir.td_stripbytecountsorted = 1;\n\t\tfor (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {\n\t\t\tif (tif->tif_dir.td_stripoffset[strip - 1] >\n\t\t\t    tif->tif_dir.td_stripoffset[strip]) {\n\t\t\t\ttif->tif_dir.td_stripbytecountsorted = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif /* !defined(DEFER_STRILE_LOAD) */\n        \n\t/*\n\t * An opportunity for compression mode dependent tag fixup\n\t */\n\t(*tif->tif_fixuptags)(tif);\n\n\t/*\n\t * Some manufacturers make life difficult by writing\n\t * large amounts of uncompressed data as a single strip.\n\t * This is contrary to the recommendations of the spec.\n\t * The following makes an attempt at breaking such images\n\t * into strips closer to the recommended 8k bytes.  A\n\t * side effect, however, is that the RowsPerStrip tag\n\t * value may be changed.\n\t */\n\tif ((tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&\n\t    (tif->tif_dir.td_nstrips==1)&&\n\t    (tif->tif_dir.td_compression==COMPRESSION_NONE)&&  \n\t    ((tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP))\n    {\n        if ( !_TIFFFillStriles(tif) || !tif->tif_dir.td_stripbytecount )\n            return 0;\n\t\tChopUpSingleUncompressedStrip(tif);\n    }\n\n        /*\n         * Clear the dirty directory flag. \n         */\n\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\n\ttif->tif_flags &= ~TIFF_DIRTYSTRIP;\n\n\t/*\n\t * Reinitialize i/o since we are starting on a new directory.\n\t */\n\ttif->tif_row = (uint32) -1;\n\ttif->tif_curstrip = (uint32) -1;\n\ttif->tif_col = (uint32) -1;\n\ttif->tif_curtile = (uint32) -1;\n\ttif->tif_tilesize = (tmsize_t) -1;\n\n\ttif->tif_scanlinesize = TIFFScanlineSize(tif);\n\tif (!tif->tif_scanlinesize) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Cannot handle zero scanline size\");\n\t\treturn (0);\n\t}\n\n\tif (isTiled(tif)) {\n\t\ttif->tif_tilesize = TIFFTileSize(tif);\n\t\tif (!tif->tif_tilesize) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Cannot handle zero tile size\");\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\tif (!TIFFStripSize(tif)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Cannot handle zero strip size\");\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (1);\nbad:\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn (0);\n}",
        "begin_line": 3398,
        "end_line": 4093,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirectoryCheckOrder#4095",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirectoryCheckOrder(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)",
        "snippet": "static void\nTIFFReadDirectoryCheckOrder(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)\n{\n\tstatic const char module[] = \"TIFFReadDirectoryCheckOrder\";\n\tuint16 m;\n\tuint16 n;\n\tTIFFDirEntry* o;\n\tm=0;\n\tfor (n=0, o=dir; n<dircount; n++, o++)\n\t{\n\t\tif (o->tdir_tag<m)\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t    \"Invalid TIFF directory; tags are not sorted in ascending order\");\n\t\t\tbreak;\n\t\t}\n\t\tm=o->tdir_tag+1;\n\t}\n}",
        "begin_line": 4095,
        "end_line": 4113,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirectoryFindEntry#4115",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirectoryFindEntry(TIFF* tif, TIFFDirEntry* dir, uint16 dircount, uint16 tagid)",
        "snippet": "static TIFFDirEntry*\nTIFFReadDirectoryFindEntry(TIFF* tif, TIFFDirEntry* dir, uint16 dircount, uint16 tagid)\n{\n\tTIFFDirEntry* m;\n\tuint16 n;\n\t(void) tif;\n\tfor (m=dir, n=0; n<dircount; m++, n++)\n\t{\n\t\tif (m->tdir_tag==tagid)\n\t\t\treturn(m);\n\t}\n\treturn(0);\n}",
        "begin_line": 4115,
        "end_line": 4127,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread.TIFFReadDirectoryFindFieldInfo#4129",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread.TIFFReadDirectoryFindFieldInfo(TIFF* tif, uint16 tagid, uint32* fii)",
        "snippet": "static void\nTIFFReadDirectoryFindFieldInfo(TIFF* tif, uint16 tagid, uint32* fii)\n{\n\tint32 ma,mb,mc;\n\tma=-1;\n\tmc=(int32)tif->tif_nfields;\n\twhile (1)\n\t{\n\t\tif (ma+1==mc)\n\t\t{\n\t\t\t*fii = FAILED_FII;\n\t\t\treturn;\n\t\t}\n\t\tmb=(ma+mc)/2;\n\t\tif (tif->tif_fields[mb]->field_tag==(uint32)tagid)\n\t\t\tbreak;\n\t\tif (tif->tif_fields[mb]->field_tag<(uint32)tagid)\n\t\t\tma=mb;\n\t\telse\n\t\t\tmc=mb;\n\t}\n\twhile (1)\n\t{\n\t\tif (mb==0)\n\t\t\tbreak;\n\t\tif (tif->tif_fields[mb-1]->field_tag!=(uint32)tagid)\n\t\t\tbreak;\n\t\tmb--;\n\t}\n\t*fii=mb;\n}",
        "begin_line": 4129,
        "end_line": 4159,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread._TIFFFillStriles#5584",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread._TIFFFillStriles( TIFF *tif )",
        "snippet": "int _TIFFFillStriles( TIFF *tif )\n{\n    return _TIFFFillStrilesInternal( tif, 1 );\n}",
        "begin_line": 5584,
        "end_line": 5587,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dirread._TIFFFillStrilesInternal#5589",
        "src_path": "libtiff/tif_dirread.c",
        "class_name": "libtiff.tif_dirread",
        "signature": "libtiff.tif_dirread._TIFFFillStrilesInternal( TIFF *tif, int loadStripByteCount )",
        "snippet": "static int _TIFFFillStrilesInternal( TIFF *tif, int loadStripByteCount )\n{\n#if defined(DEFER_STRILE_LOAD)\n        register TIFFDirectory *td = &tif->tif_dir;\n        int return_value = 1;\n\n        if( td->td_stripoffset != NULL )\n                return 1;\n\n        if( td->td_stripoffset_entry.tdir_count == 0 )\n                return 0;\n\n        if (!TIFFFetchStripThing(tif,&(td->td_stripoffset_entry),\n                                 td->td_nstrips,&td->td_stripoffset))\n        {\n                return_value = 0;\n        }\n\n        if (loadStripByteCount &&\n            !TIFFFetchStripThing(tif,&(td->td_stripbytecount_entry),\n                                 td->td_nstrips,&td->td_stripbytecount))\n        {\n                return_value = 0;\n        }\n\n        _TIFFmemset( &(td->td_stripoffset_entry), 0, sizeof(TIFFDirEntry));\n        _TIFFmemset( &(td->td_stripbytecount_entry), 0, sizeof(TIFFDirEntry));\n\n\tif (tif->tif_dir.td_nstrips > 1 && return_value == 1 ) {\n\t\tuint32 strip;\n\n\t\ttif->tif_dir.td_stripbytecountsorted = 1;\n\t\tfor (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {\n\t\t\tif (tif->tif_dir.td_stripoffset[strip - 1] >\n\t\t\t    tif->tif_dir.td_stripoffset[strip]) {\n\t\t\t\ttif->tif_dir.td_stripbytecountsorted = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n        return return_value;\n#else /* !defined(DEFER_STRILE_LOAD) */\n        (void) tif;\n        (void) loadStripByteCount;\n        return 1;\n#endif \n}",
        "begin_line": 5589,
        "end_line": 5636,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dumpmode.DumpFixupTags#34",
        "src_path": "libtiff/tif_dumpmode.c",
        "class_name": "libtiff.tif_dumpmode",
        "signature": "libtiff.tif_dumpmode.DumpFixupTags(TIFF* tif)",
        "snippet": "static int\nDumpFixupTags(TIFF* tif)\n{\n\t(void) tif;\n\treturn (1);\n}",
        "begin_line": 34,
        "end_line": 39,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dumpmode.DumpModeDecode#77",
        "src_path": "libtiff/tif_dumpmode.c",
        "class_name": "libtiff.tif_dumpmode",
        "signature": "libtiff.tif_dumpmode.DumpModeDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)",
        "snippet": "static int\nDumpModeDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)\n{\n\tstatic const char module[] = \"DumpModeDecode\";\n\t(void) s;\n\tif (tif->tif_rawcc < cc) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\"Not enough data for scanline %lu, expected a request for at most %I64d bytes, got a request for %I64d bytes\",\n\t\t             (unsigned long) tif->tif_row,\n\t\t             (signed __int64) tif->tif_rawcc,\n\t\t             (signed __int64) cc);\n#else\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\"Not enough data for scanline %lu, expected a request for at most %lld bytes, got a request for %lld bytes\",\n\t\t             (unsigned long) tif->tif_row,\n\t\t             (signed long long) tif->tif_rawcc,\n\t\t             (signed long long) cc);\n#endif\n\t\treturn (0);\n\t}\n\t/*\n\t * Avoid copy if client has setup raw\n\t * data buffer to avoid extra copy.\n\t */\n\tif (tif->tif_rawcp != buf)\n\t\t_TIFFmemcpy(buf, tif->tif_rawcp, cc);\n\ttif->tif_rawcp += cc;\n\ttif->tif_rawcc -= cc;  \n\treturn (1);\n}",
        "begin_line": 77,
        "end_line": 107,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_dumpmode.TIFFInitDumpMode#123",
        "src_path": "libtiff/tif_dumpmode.c",
        "class_name": "libtiff.tif_dumpmode",
        "signature": "libtiff.tif_dumpmode.TIFFInitDumpMode(TIFF* tif, int scheme)",
        "snippet": "int\nTIFFInitDumpMode(TIFF* tif, int scheme)\n{\n\t(void) scheme;\n\ttif->tif_fixuptags = DumpFixupTags;  \n\ttif->tif_decoderow = DumpModeDecode;\n\ttif->tif_decodestrip = DumpModeDecode;\n\ttif->tif_decodetile = DumpModeDecode;\n\ttif->tif_encoderow = DumpModeEncode;\n\ttif->tif_encodestrip = DumpModeEncode;\n\ttif->tif_encodetile = DumpModeEncode; \n\ttif->tif_seek = DumpModeSeek;\n\treturn (1);\n}",
        "begin_line": 123,
        "end_line": 136,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_open.TIFFClientOpen#72",
        "src_path": "libtiff/tif_open.c",
        "class_name": "libtiff.tif_open",
        "signature": "libtiff.tif_open.TIFFClientOpen( \tconst char* name, const char* mode, thandle_t clientdata, TIFFReadWriteProc readproc, TIFFReadWriteProc writeproc, TIFFSeekProc seekproc, TIFFCloseProc closeproc, TIFFSizeProc sizeproc, TIFFMapFileProc mapproc, TIFFUnmapFileProc unmapproc )",
        "snippet": "TIFF*\nTIFFClientOpen(\n\tconst char* name, const char* mode,\n\tthandle_t clientdata,\n\tTIFFReadWriteProc readproc,\n\tTIFFReadWriteProc writeproc,\n\tTIFFSeekProc seekproc,\n\tTIFFCloseProc closeproc,\n\tTIFFSizeProc sizeproc,\n\tTIFFMapFileProc mapproc,\n\tTIFFUnmapFileProc unmapproc\n)\n{\n\tstatic const char module[] = \"TIFFClientOpen\";\n\tTIFF *tif;\n\tint m;\n\tconst char* cp;\n\n\t/* The following are configuration checks. They should be redundant, but should not\n\t * compile to any actual code in an optimised release build anyway. If any of them\n\t * fail, (makefile-based or other) configuration is not correct */\n\tassert(sizeof(uint8)==1);\n\tassert(sizeof(int8)==1);\n\tassert(sizeof(uint16)==2);\n\tassert(sizeof(int16)==2);\n\tassert(sizeof(uint32)==4);\n\tassert(sizeof(int32)==4);\n\tassert(sizeof(uint64)==8);\n\tassert(sizeof(int64)==8);\n\tassert(sizeof(tmsize_t)==sizeof(void*));\n\t{\n\t\tunion{\n\t\t\tuint8 a8[2];\n\t\t\tuint16 a16;\n\t\t} n;\n\t\tn.a8[0]=1;\n\t\tn.a8[1]=0;\n\t\t#ifdef WORDS_BIGENDIAN\n\t\tassert(n.a16==256);\n\t\t#else\n\t\tassert(n.a16==1);\n\t\t#endif\n\t}\n\n\tm = _TIFFgetMode(mode, module);\n\tif (m == -1)\n\t\tgoto bad2;\n\ttif = (TIFF *)_TIFFmalloc((tmsize_t)(sizeof (TIFF) + strlen(name) + 1));\n\tif (tif == NULL) {\n\t\tTIFFErrorExt(clientdata, module, \"%s: Out of memory (TIFF structure)\", name);\n\t\tgoto bad2;\n\t}\n\t_TIFFmemset(tif, 0, sizeof (*tif));\n\ttif->tif_name = (char *)tif + sizeof (TIFF);\n\tstrcpy(tif->tif_name, name);\n\ttif->tif_mode = m &~ (O_CREAT|O_TRUNC);\n\ttif->tif_curdir = (uint16) -1;\t\t/* non-existent directory */\n\ttif->tif_curoff = 0;\n\ttif->tif_curstrip = (uint32) -1;\t/* invalid strip */\n\ttif->tif_row = (uint32) -1;\t\t/* read/write pre-increment */\n\ttif->tif_clientdata = clientdata;\n\tif (!readproc || !writeproc || !seekproc || !closeproc || !sizeproc) {\n\t\tTIFFErrorExt(clientdata, module,\n\t\t    \"One of the client procedures is NULL pointer.\");\n\t\tgoto bad2;\n\t}\n\ttif->tif_readproc = readproc;\n\ttif->tif_writeproc = writeproc;\n\ttif->tif_seekproc = seekproc;\n\ttif->tif_closeproc = closeproc;\n\ttif->tif_sizeproc = sizeproc;\n\tif (mapproc)\n\t\ttif->tif_mapproc = mapproc;\n\telse\n\t\ttif->tif_mapproc = _tiffDummyMapProc;\n\tif (unmapproc)\n\t\ttif->tif_unmapproc = unmapproc;\n\telse\n\t\ttif->tif_unmapproc = _tiffDummyUnmapProc;\n\t_TIFFSetDefaultCompressionState(tif);    /* setup default state */\n\t/*\n\t * Default is to return data MSB2LSB and enable the\n\t * use of memory-mapped files and strip chopping when\n\t * a file is opened read-only.\n\t */\n\ttif->tif_flags = FILLORDER_MSB2LSB;\n\tif (m == O_RDONLY )\n\t\ttif->tif_flags |= TIFF_MAPPED;\n\n\t#ifdef STRIPCHOP_DEFAULT\n\tif (m == O_RDONLY || m == O_RDWR)\n\t\ttif->tif_flags |= STRIPCHOP_DEFAULT;\n\t#endif\n\n\t/*\n\t * Process library-specific flags in the open mode string.\n\t * The following flags may be used to control intrinsic library\n\t * behaviour that may or may not be desirable (usually for\n\t * compatibility with some application that claims to support\n\t * TIFF but only supports some brain dead idea of what the\n\t * vendor thinks TIFF is):\n\t *\n\t * 'l' use little-endian byte order for creating a file\n\t * 'b' use big-endian byte order for creating a file\n\t * 'L' read/write information using LSB2MSB bit order\n\t * 'B' read/write information using MSB2LSB bit order\n\t * 'H' read/write information using host bit order\n\t * 'M' enable use of memory-mapped files when supported\n\t * 'm' disable use of memory-mapped files\n\t * 'C' enable strip chopping support when reading\n\t * 'c' disable strip chopping support\n\t * 'h' read TIFF header only, do not load the first IFD\n\t * '4' ClassicTIFF for creating a file (default)\n\t * '8' BigTIFF for creating a file\n\t *\n\t * The use of the 'l' and 'b' flags is strongly discouraged.\n\t * These flags are provided solely because numerous vendors,\n\t * typically on the PC, do not correctly support TIFF; they\n\t * only support the Intel little-endian byte order.  This\n\t * support is not configured by default because it supports\n\t * the violation of the TIFF spec that says that readers *MUST*\n\t * support both byte orders.  It is strongly recommended that\n\t * you not use this feature except to deal with busted apps\n\t * that write invalid TIFF.  And even in those cases you should\n\t * bang on the vendors to fix their software.\n\t *\n\t * The 'L', 'B', and 'H' flags are intended for applications\n\t * that can optimize operations on data by using a particular\n\t * bit order.  By default the library returns data in MSB2LSB\n\t * bit order for compatibility with older versions of this\n\t * library.  Returning data in the bit order of the native CPU\n\t * makes the most sense but also requires applications to check\n\t * the value of the FillOrder tag; something they probably do\n\t * not do right now.\n\t *\n\t * The 'M' and 'm' flags are provided because some virtual memory\n\t * systems exhibit poor behaviour when large images are mapped.\n\t * These options permit clients to control the use of memory-mapped\n\t * files on a per-file basis.\n\t *\n\t * The 'C' and 'c' flags are provided because the library support\n\t * for chopping up large strips into multiple smaller strips is not\n\t * application-transparent and as such can cause problems.  The 'c'\n\t * option permits applications that only want to look at the tags,\n\t * for example, to get the unadulterated TIFF tag information.\n\t */\n\tfor (cp = mode; *cp; cp++)\n\t\tswitch (*cp) {\n\t\t\tcase 'b':\n\t\t\t\t#ifndef WORDS_BIGENDIAN\n\t\t\t\tif (m&O_CREAT)\n\t\t\t\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t\t\t#endif\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\t#ifdef WORDS_BIGENDIAN\n\t\t\t\tif ((m&O_CREAT))\n\t\t\t\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t\t\t#endif\n\t\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\t\ttif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |\n\t\t\t\t    FILLORDER_MSB2LSB;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\ttif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |\n\t\t\t\t    FILLORDER_LSB2MSB;\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\ttif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |\n\t\t\t\t    HOST_FILLORDER;\n\t\t\t\tbreak;\n\t\t\tcase 'M':\n\t\t\t\tif (m == O_RDONLY)\n\t\t\t\t\ttif->tif_flags |= TIFF_MAPPED;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tif (m == O_RDONLY)\n\t\t\t\t\ttif->tif_flags &= ~TIFF_MAPPED;\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tif (m == O_RDONLY)\n\t\t\t\t\ttif->tif_flags |= TIFF_STRIPCHOP;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tif (m == O_RDONLY)\n\t\t\t\t\ttif->tif_flags &= ~TIFF_STRIPCHOP;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\t\ttif->tif_flags |= TIFF_HEADERONLY;\n\t\t\t\tbreak;\n\t\t\tcase '8':\n\t\t\t\tif (m&O_CREAT)\n\t\t\t\t\ttif->tif_flags |= TIFF_BIGTIFF;\n\t\t\t\tbreak;\n\t\t}\n\t/*\n\t * Read in TIFF header.\n\t */\n\tif ((m & O_TRUNC) ||\n\t    !ReadOK(tif, &tif->tif_header, sizeof (TIFFHeaderClassic))) {\n\t\tif (tif->tif_mode == O_RDONLY) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t\t    \"Cannot read TIFF header\");\n\t\t\tgoto bad;\n\t\t}\n\t\t/*\n\t\t * Setup header and write.\n\t\t */\n\t\t#ifdef WORDS_BIGENDIAN\n\t\ttif->tif_header.common.tiff_magic = (tif->tif_flags & TIFF_SWAB)\n\t\t    ? TIFF_LITTLEENDIAN : TIFF_BIGENDIAN;\n\t\t#else\n\t\ttif->tif_header.common.tiff_magic = (tif->tif_flags & TIFF_SWAB)\n\t\t    ? TIFF_BIGENDIAN : TIFF_LITTLEENDIAN;\n\t\t#endif\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\ttif->tif_header.common.tiff_version = TIFF_VERSION_CLASSIC;\n\t\t\ttif->tif_header.classic.tiff_diroff = 0;\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&tif->tif_header.common.tiff_version);\n\t\t\ttif->tif_header_size = sizeof(TIFFHeaderClassic);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttif->tif_header.common.tiff_version = TIFF_VERSION_BIG;\n\t\t\ttif->tif_header.big.tiff_offsetsize = 8;\n\t\t\ttif->tif_header.big.tiff_unused = 0;\n\t\t\ttif->tif_header.big.tiff_diroff = 0;\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t{\n\t\t\t\tTIFFSwabShort(&tif->tif_header.common.tiff_version);\n\t\t\t\tTIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);\n\t\t\t}\n\t\t\ttif->tif_header_size = sizeof (TIFFHeaderBig);\n\t\t}\n\t\t/*\n\t\t * The doc for \"fopen\" for some STD_C_LIBs says that if you\n\t\t * open a file for modify (\"+\"), then you must fseek (or\n\t\t * fflush?) between any freads and fwrites.  This is not\n\t\t * necessary on most systems, but has been shown to be needed\n\t\t * on Solaris.\n\t\t */\n\t\tTIFFSeekFile( tif, 0, SEEK_SET );\n\t\tif (!WriteOK(tif, &tif->tif_header, (tmsize_t)(tif->tif_header_size))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t\t    \"Error writing TIFF header\");\n\t\t\tgoto bad;\n\t\t}\n\t\t/*\n\t\t * Setup the byte order handling.\n\t\t */\n\t\tif (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN) {\n\t\t\t#ifndef WORDS_BIGENDIAN\n\t\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t\t#endif\n\t\t} else {\n\t\t\t#ifdef WORDS_BIGENDIAN\n\t\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t\t#endif\n\t\t}\n\t\t/*\n\t\t * Setup default directory.\n\t\t */\n\t\tif (!TIFFDefaultDirectory(tif))\n\t\t\tgoto bad;\n\t\ttif->tif_diroff = 0;\n\t\ttif->tif_dirlist = NULL;\n\t\ttif->tif_dirlistsize = 0;\n\t\ttif->tif_dirnumber = 0;\n\t\treturn (tif);\n\t}\n\t/*\n\t * Setup the byte order handling.\n\t */\n\tif (tif->tif_header.common.tiff_magic != TIFF_BIGENDIAN &&\n\t    tif->tif_header.common.tiff_magic != TIFF_LITTLEENDIAN\n\t    #if MDI_SUPPORT\n\t    &&\n\t    #if HOST_BIGENDIAN\n\t    tif->tif_header.common.tiff_magic != MDI_BIGENDIAN\n\t    #else\n\t    tif->tif_header.common.tiff_magic != MDI_LITTLEENDIAN\n\t    #endif\n\t    ) {\n\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t    \"Not a TIFF or MDI file, bad magic number %d (0x%x)\",\n\t    #else\n\t    ) {\n\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t    \"Not a TIFF file, bad magic number %d (0x%x)\",\n\t    #endif\n\t\t    tif->tif_header.common.tiff_magic,\n\t\t    tif->tif_header.common.tiff_magic);\n\t\tgoto bad;\n\t}\n\tif (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN) {\n\t\t#ifndef WORDS_BIGENDIAN\n\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t#endif\n\t} else {\n\t\t#ifdef WORDS_BIGENDIAN\n\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t#endif\n\t}\n\tif (tif->tif_flags & TIFF_SWAB) \n\t\tTIFFSwabShort(&tif->tif_header.common.tiff_version);\n\tif ((tif->tif_header.common.tiff_version != TIFF_VERSION_CLASSIC)&&\n\t    (tif->tif_header.common.tiff_version != TIFF_VERSION_BIG)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t    \"Not a TIFF file, bad version number %d (0x%x)\",\n\t\t    tif->tif_header.common.tiff_version,\n\t\t    tif->tif_header.common.tiff_version);\n\t\tgoto bad;\n\t}\n\tif (tif->tif_header.common.tiff_version == TIFF_VERSION_CLASSIC)\n\t{\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabLong(&tif->tif_header.classic.tiff_diroff);\n\t\ttif->tif_header_size = sizeof(TIFFHeaderClassic);\n\t}\n\telse\n\t{\n\t\tif (!ReadOK(tif, ((uint8*)(&tif->tif_header) + sizeof(TIFFHeaderClassic)), (sizeof(TIFFHeaderBig)-sizeof(TIFFHeaderClassic))))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t\t    \"Cannot read TIFF header\");\n\t\t\tgoto bad;\n\t\t}\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t{\n\t\t\tTIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);\n\t\t\tTIFFSwabLong8(&tif->tif_header.big.tiff_diroff);\n\t\t}\n\t\tif (tif->tif_header.big.tiff_offsetsize != 8)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t\t    \"Not a TIFF file, bad BigTIFF offsetsize %d (0x%x)\",\n\t\t\t    tif->tif_header.big.tiff_offsetsize,\n\t\t\t    tif->tif_header.big.tiff_offsetsize);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (tif->tif_header.big.tiff_unused != 0)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t\t    \"Not a TIFF file, bad BigTIFF unused %d (0x%x)\",\n\t\t\t    tif->tif_header.big.tiff_unused,\n\t\t\t    tif->tif_header.big.tiff_unused);\n\t\t\tgoto bad;\n\t\t}\n\t\ttif->tif_header_size = sizeof(TIFFHeaderBig);\n\t\ttif->tif_flags |= TIFF_BIGTIFF;\n\t}\n\ttif->tif_flags |= TIFF_MYBUFFER;\n\ttif->tif_rawcp = tif->tif_rawdata = 0;\n\ttif->tif_rawdatasize = 0;\n        tif->tif_rawdataoff = 0;\n        tif->tif_rawdataloaded = 0;\n\n\tswitch (mode[0]) {\n\t\tcase 'r':\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t\ttif->tif_nextdiroff = tif->tif_header.classic.tiff_diroff;\n\t\t\telse\n\t\t\t\ttif->tif_nextdiroff = tif->tif_header.big.tiff_diroff;\n\t\t\t/*\n\t\t\t * Try to use a memory-mapped file if the client\n\t\t\t * has not explicitly suppressed usage with the\n\t\t\t * 'm' flag in the open mode (see above).\n\t\t\t */\n\t\t\tif (tif->tif_flags & TIFF_MAPPED)\n\t\t\t{\n\t\t\t\ttoff_t n;\n\t\t\t\tif (TIFFMapFileContents(tif,(void**)(&tif->tif_base),&n))\n\t\t\t\t{\n\t\t\t\t\ttif->tif_size=(tmsize_t)n;\n\t\t\t\t\tassert((toff_t)tif->tif_size==n);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\ttif->tif_flags &= ~TIFF_MAPPED;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Sometimes we do not want to read the first directory (for example,\n\t\t\t * it may be broken) and want to proceed to other directories. I this\n\t\t\t * case we use the TIFF_HEADERONLY flag to open file and return\n\t\t\t * immediately after reading TIFF header.\n\t\t\t */\n\t\t\tif (tif->tif_flags & TIFF_HEADERONLY)\n\t\t\t\treturn (tif);\n\n\t\t\t/*\n\t\t\t * Setup initial directory.\n\t\t\t */\n\t\t\tif (TIFFReadDirectory(tif)) {\n\t\t\t\ttif->tif_rawcc = (tmsize_t)-1;\n\t\t\t\ttif->tif_flags |= TIFF_BUFFERSETUP;\n\t\t\t\treturn (tif);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\t/*\n\t\t\t * New directories are automatically append\n\t\t\t * to the end of the directory chain when they\n\t\t\t * are written out (see TIFFWriteDirectory).\n\t\t\t */\n\t\t\tif (!TIFFDefaultDirectory(tif))\n\t\t\t\tgoto bad;\n\t\t\treturn (tif);\n\t}\nbad:\n\ttif->tif_mode = O_RDONLY;\t/* XXX avoid flush */\n        TIFFCleanup(tif);\nbad2:\n\treturn ((TIFF*)0);\n}",
        "begin_line": 72,
        "end_line": 487,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_open._TIFFgetMode#48",
        "src_path": "libtiff/tif_open.c",
        "class_name": "libtiff.tif_open",
        "signature": "libtiff.tif_open._TIFFgetMode(const char* mode, const char* module)",
        "snippet": "int\n_TIFFgetMode(const char* mode, const char* module)\n{\n\tint m = -1;\n\n\tswitch (mode[0]) {\n\tcase 'r':\n\t\tm = O_RDONLY;\n\t\tif (mode[1] == '+')\n\t\t\tm = O_RDWR;\n\t\tbreak;\n\tcase 'w':\n\tcase 'a':\n\t\tm = O_RDWR|O_CREAT;\n\t\tif (mode[0] == 'w')\n\t\t\tm |= O_TRUNC;\n\t\tbreak;\n\tdefault:\n\t\tTIFFErrorExt(0, module, \"\\\"%s\\\": Bad mode\", mode);\n\t\tbreak;\n\t}\n\treturn (m);\n}",
        "begin_line": 48,
        "end_line": 70,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_read.TIFFCheckRead#1074",
        "src_path": "libtiff/tif_read.c",
        "class_name": "libtiff.tif_read",
        "signature": "libtiff.tif_read.TIFFCheckRead(TIFF* tif, int tiles)",
        "snippet": "static int\nTIFFCheckRead(TIFF* tif, int tiles)\n{\n\tif (tif->tif_mode == O_WRONLY) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"File not open for reading\");\n\t\treturn (0);\n\t}\n\tif (tiles ^ isTiled(tif)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, tiles ?\n\t\t    \"Can not read tiles from a stripped image\" :\n\t\t    \"Can not read scanlines from a tiled image\");\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
        "begin_line": 1074,
        "end_line": 1088,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_read.TIFFFillStrip#512",
        "src_path": "libtiff/tif_read.c",
        "class_name": "libtiff.tif_read",
        "signature": "libtiff.tif_read.TIFFFillStrip(TIFF* tif, uint32 strip)",
        "snippet": "int\nTIFFFillStrip(TIFF* tif, uint32 strip)\n{\n\tstatic const char module[] = \"TIFFFillStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\n        if (!_TIFFFillStriles( tif ) || !tif->tif_dir.td_stripbytecount)\n            return 0;\n\n\tif ((tif->tif_flags&TIFF_NOREADRAW)==0)\n\t{\n\t\tuint64 bytecount = td->td_stripbytecount[strip];\n\t\tif ((int64)bytecount <= 0) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"Invalid strip byte count %I64u, strip %lu\",\n\t\t\t\t     (unsigned __int64) bytecount,\n\t\t\t\t     (unsigned long) strip);\n#else\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"Invalid strip byte count %llu, strip %lu\",\n\t\t\t\t     (unsigned long long) bytecount,\n\t\t\t\t     (unsigned long) strip);\n#endif\n\t\t\treturn (0);\n\t\t}\n\t\tif (isMapped(tif) &&\n\t\t    (isFillOrder(tif, td->td_fillorder)\n\t\t    || (tif->tif_flags & TIFF_NOBITREV))) {\n\t\t\t/*\n\t\t\t * The image is mapped into memory and we either don't\n\t\t\t * need to flip bits or the compression routine is\n\t\t\t * going to handle this operation itself.  In this\n\t\t\t * case, avoid copying the raw data and instead just\n\t\t\t * reference the data from the memory mapped file\n\t\t\t * image.  This assumes that the decompression\n\t\t\t * routines do not modify the contents of the raw data\n\t\t\t * buffer (if they try to, the application will get a\n\t\t\t * fault since the file is mapped read-only).\n\t\t\t */\n\t\t\tif ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) {\n\t\t\t\t_TIFFfree(tif->tif_rawdata);\n\t\t\t\ttif->tif_rawdata = NULL;\n\t\t\t\ttif->tif_rawdatasize = 0;\n\t\t\t}\n\t\t\ttif->tif_flags &= ~TIFF_MYBUFFER;\n\t\t\t/*\n\t\t\t * We must check for overflow, potentially causing\n\t\t\t * an OOB read. Instead of simple\n\t\t\t *\n\t\t\t *  td->td_stripoffset[strip]+bytecount > tif->tif_size\n\t\t\t *\n\t\t\t * comparison (which can overflow) we do the following\n\t\t\t * two comparisons:\n\t\t\t */\n\t\t\tif (bytecount > (uint64)tif->tif_size ||\n\t\t\t    td->td_stripoffset[strip] > (uint64)tif->tif_size - bytecount) {\n\t\t\t\t/*\n\t\t\t\t * This error message might seem strange, but\n\t\t\t\t * it's what would happen if a read were done\n\t\t\t\t * instead.\n\t\t\t\t */\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\n\t\t\t\t\t\"Read error on strip %lu; \"\n\t\t\t\t\t\"got %I64u bytes, expected %I64u\",\n\t\t\t\t\t(unsigned long) strip,\n\t\t\t\t\t(unsigned __int64) tif->tif_size - td->td_stripoffset[strip],\n\t\t\t\t\t(unsigned __int64) bytecount);\n#else\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\n\t\t\t\t\t\"Read error on strip %lu; \"\n\t\t\t\t\t\"got %llu bytes, expected %llu\",\n\t\t\t\t\t(unsigned long) strip,\n\t\t\t\t\t(unsigned long long) tif->tif_size - td->td_stripoffset[strip],\n\t\t\t\t\t(unsigned long long) bytecount);\n#endif\n\t\t\t\ttif->tif_curstrip = NOSTRIP;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\ttif->tif_rawdatasize = (tmsize_t)bytecount;\n\t\t\ttif->tif_rawdata = tif->tif_base + (tmsize_t)td->td_stripoffset[strip];\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = (tmsize_t) bytecount;\n\n\t\t\t/* \n\t\t\t * When we have tif_rawdata reference directly into the memory mapped file\n\t\t\t * we need to be pretty careful about how we use the rawdata.  It is not\n\t\t\t * a general purpose working buffer as it normally otherwise is.  So we\n\t\t\t * keep track of this fact to avoid using it improperly.\n\t\t\t */\n\t\t\ttif->tif_flags |= TIFF_BUFFERMMAP;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Expand raw data buffer, if needed, to hold data\n\t\t\t * strip coming from file (perhaps should set upper\n\t\t\t * bound on the size of a buffer we'll use?).\n\t\t\t */\n\t\t\ttmsize_t bytecountm;\n\t\t\tbytecountm=(tmsize_t)bytecount;\n\t\t\tif ((uint64)bytecountm!=bytecount)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (bytecountm > tif->tif_rawdatasize) {\n\t\t\t\ttif->tif_curstrip = NOSTRIP;\n\t\t\t\tif ((tif->tif_flags & TIFF_MYBUFFER) == 0) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t    \"Data buffer too small to hold strip %lu\",\n\t\t\t\t\t    (unsigned long) strip);\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tif (!TIFFReadBufferSetup(tif, 0, bytecountm))\n\t\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags&TIFF_BUFFERMMAP) {\n\t\t\t\ttif->tif_curstrip = NOSTRIP;\n\t\t\t\tif (!TIFFReadBufferSetup(tif, 0, bytecountm))\n\t\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (TIFFReadRawStrip1(tif, strip, tif->tif_rawdata,\n\t\t\t\tbytecountm, module) != bytecountm)\n\t\t\t\treturn (0);\n\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = bytecountm;\n                        \n\t\t\tif (!isFillOrder(tif, td->td_fillorder) &&\n\t\t\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\t\t\tTIFFReverseBits(tif->tif_rawdata, bytecountm);\n                }\n\t}\n\treturn (TIFFStartStrip(tif, strip));\n}",
        "begin_line": 512,
        "end_line": 648,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_read.TIFFReadScanline#293",
        "src_path": "libtiff/tif_read.c",
        "class_name": "libtiff.tif_read",
        "signature": "libtiff.tif_read.TIFFReadScanline(TIFF* tif, void* buf, uint32 row, uint16 sample)",
        "snippet": "int\nTIFFReadScanline(TIFF* tif, void* buf, uint32 row, uint16 sample)\n{\n\tint e;\n\n\tif (!TIFFCheckRead(tif, 0))\n\t\treturn (-1);\n\tif( (e = TIFFSeek(tif, row, sample)) != 0) {\n\t\t/*\n\t\t * Decompress desired row into user buffer.\n\t\t */\n\t\te = (*tif->tif_decoderow)\n\t\t    (tif, (uint8*) buf, tif->tif_scanlinesize, sample);  \n\n\t\t/* we are now poised at the beginning of the next row */\n\t\ttif->tif_row = row + 1;\n\n\t\tif (e)\n\t\t\t(*tif->tif_postdecode)(tif, (uint8*) buf,\n\t\t\t    tif->tif_scanlinesize);  \n\t}\n\treturn (e > 0 ? 1 : -1);\n}",
        "begin_line": 293,
        "end_line": 315,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_read.TIFFSeek#178",
        "src_path": "libtiff/tif_read.c",
        "class_name": "libtiff.tif_read",
        "signature": "libtiff.tif_read.TIFFSeek(TIFF* tif, uint32 row, uint16 sample )",
        "snippet": "static int\nTIFFSeek(TIFF* tif, uint32 row, uint16 sample )\n{\n\tregister TIFFDirectory *td = &tif->tif_dir;\n\tuint32 strip;\n        int    whole_strip;\n\ttmsize_t read_ahead = 0;\n\n        /*\n        ** Establish what strip we are working from.\n        */\n\tif (row >= td->td_imagelength) {\t/* out of range */\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t    \"%lu: Row out of range, max %lu\",\n\t\t    (unsigned long) row,\n\t\t    (unsigned long) td->td_imagelength);\n\t\treturn (0);\n\t}\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE) {\n\t\tif (sample >= td->td_samplesperpixel) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t    \"%lu: Sample out of range, max %lu\",\n\t\t\t    (unsigned long) sample, (unsigned long) td->td_samplesperpixel);\n\t\t\treturn (0);\n\t\t}\n\t\tstrip = (uint32)sample*td->td_stripsperimage + row/td->td_rowsperstrip;\n\t} else\n\t\tstrip = row / td->td_rowsperstrip;\n\n        /*\n         * Do we want to treat this strip as one whole chunk or\n         * read it a few lines at a time?\n         */\n#if defined(CHUNKY_STRIP_READ_SUPPORT)\n        if (!_TIFFFillStriles( tif ) || !tif->tif_dir.td_stripbytecount)\n            return 0;\n        whole_strip = tif->tif_dir.td_stripbytecount[strip] < 10\n                || isMapped(tif);\n#else\n        whole_strip = 1;\n#endif\n        \n        if( !whole_strip )\n        {\n                read_ahead = tif->tif_scanlinesize * 16 + 5000;\n        }\n\n        /*\n         * If we haven't loaded this strip, do so now, possibly\n         * only reading the first part.\n         */\n\tif (strip != tif->tif_curstrip) {\t/* different strip, refill */\n                \n                if( whole_strip )\n                {\n                        if (!TIFFFillStrip(tif, strip))\n                                return (0);\n                }\n                else\n                {\n                        if( !TIFFFillStripPartial(tif,strip,read_ahead,1) )\n                                return 0;\n                }\n\t}\n\n        /*\n        ** If we already have some data loaded, do we need to read some more?\n        */\n        else if( !whole_strip )\n        {\n                if( ((tif->tif_rawdata + tif->tif_rawdataloaded) - tif->tif_rawcp) < read_ahead \n                    && (uint64) tif->tif_rawdataoff+tif->tif_rawdataloaded < td->td_stripbytecount[strip] )\n                {\n                        if( !TIFFFillStripPartial(tif,strip,read_ahead,0) )\n                                return 0;\n                }\n        }\n\n        if (row < tif->tif_row) {\n\t\t/*\n\t\t * Moving backwards within the same strip: backup\n\t\t * to the start and then decode forward (below).\n\t\t *\n\t\t * NB: If you're planning on lots of random access within a\n\t\t * strip, it's better to just read and decode the entire\n\t\t * strip, and then access the decoded data in a random fashion.\n\t\t */\n\n                if( tif->tif_rawdataoff != 0 )\n                {\n                        if( !TIFFFillStripPartial(tif,strip,read_ahead,1) )\n                                return 0;\n                }\n                else\n                {\n                        if (!TIFFStartStrip(tif, strip))\n                                return (0);\n                }\n\t}\n        \n\tif (row != tif->tif_row) {\n\t\t/*\n\t\t * Seek forward to the desired row.\n\t\t */\n\n                /* TODO: Will this really work with partial buffers? */\n                \n\t\tif (!(*tif->tif_seek)(tif, row - tif->tif_row))\n\t\t\treturn (0);\n\t\ttif->tif_row = row;\n\t}\n\n\treturn (1);\n}",
        "begin_line": 178,
        "end_line": 291,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_read.TIFFStartStrip#996",
        "src_path": "libtiff/tif_read.c",
        "class_name": "libtiff.tif_read",
        "signature": "libtiff.tif_read.TIFFStartStrip(TIFF* tif, uint32 strip)",
        "snippet": "static int\nTIFFStartStrip(TIFF* tif, uint32 strip)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\n        if (!_TIFFFillStriles( tif ) || !tif->tif_dir.td_stripbytecount)\n            return 0;\n\n\tif ((tif->tif_flags & TIFF_CODERSETUP) == 0) {\n\t\tif (!(*tif->tif_setupdecode)(tif))\n\t\t\treturn (0);\n\t\ttif->tif_flags |= TIFF_CODERSETUP;\n\t}\n\ttif->tif_curstrip = strip;\n\ttif->tif_row = (strip % td->td_stripsperimage) * td->td_rowsperstrip;\n        tif->tif_flags &= ~TIFF_BUF4WRITE;\n\n\tif (tif->tif_flags&TIFF_NOREADRAW)\n\t{\n\t\ttif->tif_rawcp = NULL;\n\t\ttif->tif_rawcc = 0;  \n\t}\n\telse\n\t{\n\t\ttif->tif_rawcp = tif->tif_rawdata;\n\t\ttif->tif_rawcc = (tmsize_t)td->td_stripbytecount[strip];\n\t}\n\treturn ((*tif->tif_predecode)(tif,\n\t\t\t(uint16)(strip / td->td_stripsperimage)));\n}",
        "begin_line": 996,
        "end_line": 1025,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_read._TIFFNoPostDecode#1090",
        "src_path": "libtiff/tif_read.c",
        "class_name": "libtiff.tif_read",
        "signature": "libtiff.tif_read._TIFFNoPostDecode(TIFF* tif, uint8* buf, tmsize_t cc)",
        "snippet": "void\n_TIFFNoPostDecode(TIFF* tif, uint8* buf, tmsize_t cc)\n{\n    (void) tif; (void) buf; (void) cc;\n}",
        "begin_line": 1090,
        "end_line": 1094,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip.TIFFNumberOfStrips#60",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip.TIFFNumberOfStrips(TIFF* tif)",
        "snippet": "uint32\nTIFFNumberOfStrips(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 nstrips;\n\n\tnstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :\n\t     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\tnstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel,\n\t\t    \"TIFFNumberOfStrips\");\n\treturn (nstrips);\n}",
        "begin_line": 60,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip.TIFFScanlineSize#330",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip.TIFFScanlineSize(TIFF* tif)",
        "snippet": "tmsize_t\nTIFFScanlineSize(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFScanlineSize\";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFScanlineSize64(tif);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m) {\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer arithmetic overflow\");\n\t\tn=0;\n\t}\n\treturn(n);\n}",
        "begin_line": 330,
        "end_line": 343,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip.TIFFScanlineSize64#273",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip.TIFFScanlineSize64(TIFF* tif)",
        "snippet": "uint64\nTIFFScanlineSize64(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFScanlineSize64\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint64 scanline_size;\n\tif (td->td_planarconfig==PLANARCONFIG_CONTIG)\n\t{\n\t\tif ((td->td_photometric==PHOTOMETRIC_YCBCR)&&\n\t\t    (td->td_samplesperpixel==3)&&\n\t\t    (!isUpSampled(tif)))\n\t\t{\n\t\t\tuint16 ycbcrsubsampling[2];\n\t\t\tuint16 samplingblock_samples;\n\t\t\tuint32 samplingblocks_hor;\n\t\t\tuint64 samplingrow_samples;\n\t\t\tuint64 samplingrow_size;\n\t\t\tif(td->td_samplesperpixel!=3)\n\t\t\t{\n                            TIFFErrorExt(tif->tif_clientdata,module,\n                                         \"Invalid td_samplesperpixel value\");\n                            return 0;\n\t\t\t}\n\t\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_YCBCRSUBSAMPLING,\n                                              ycbcrsubsampling+0,\n                                              ycbcrsubsampling+1);\n\t\t\tif (((ycbcrsubsampling[0]!=1)&&(ycbcrsubsampling[0]!=2)&&(ycbcrsubsampling[0]!=4)) ||\n\t\t\t    ((ycbcrsubsampling[1]!=1)&&(ycbcrsubsampling[1]!=2)&&(ycbcrsubsampling[1]!=4)))\n\t\t\t{\n                            TIFFErrorExt(tif->tif_clientdata,module,\n                                         \"Invalid YCbCr subsampling\");\n                            return 0;\n\t\t\t}\n\t\t\tsamplingblock_samples = ycbcrsubsampling[0]*ycbcrsubsampling[1]+2;\n\t\t\tsamplingblocks_hor = TIFFhowmany_32(td->td_imagewidth,ycbcrsubsampling[0]);\n\t\t\tsamplingrow_samples = _TIFFMultiply64(tif,samplingblocks_hor,samplingblock_samples,module);\n\t\t\tsamplingrow_size = TIFFhowmany_64(_TIFFMultiply64(tif,samplingrow_samples,td->td_bitspersample,module),8);\n\t\t\tscanline_size = (samplingrow_size/ycbcrsubsampling[1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint64 scanline_samples;\n\t\t\tscanline_samples=_TIFFMultiply64(tif,td->td_imagewidth,td->td_samplesperpixel,module);\n\t\t\tscanline_size=TIFFhowmany_64(_TIFFMultiply64(tif,scanline_samples,td->td_bitspersample,module),8);\n\t\t}\n\t}\n\telse\n        {\n\t\tscanline_size=TIFFhowmany_64(_TIFFMultiply64(tif,td->td_imagewidth,td->td_bitspersample,module),8);\n        }\n        if (scanline_size == 0)\n        {\n                TIFFErrorExt(tif->tif_clientdata,module,\"Computed scanline size is zero\");\n                return 0;\n        }\n\treturn(scanline_size);\n}",
        "begin_line": 273,
        "end_line": 329,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip.TIFFStripSize#211",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip.TIFFStripSize(TIFF* tif)",
        "snippet": "tmsize_t\nTIFFStripSize(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFStripSize\";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFStripSize64(tif);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\n\t\tn=0;\n\t}\n\treturn(n);\n}",
        "begin_line": 211,
        "end_line": 225,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip.TIFFStripSize64#202",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip.TIFFStripSize64(TIFF* tif)",
        "snippet": "uint64\nTIFFStripSize64(TIFF* tif)\n{\n\tTIFFDirectory* td = &tif->tif_dir;\n\tuint32 rps = td->td_rowsperstrip;\n\tif (rps > td->td_imagelength)\n\t\trps = td->td_imagelength;\n\treturn (TIFFVStripSize64(tif, rps));\n}",
        "begin_line": 202,
        "end_line": 210,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_strip.TIFFVStripSize64#77",
        "src_path": "libtiff/tif_strip.c",
        "class_name": "libtiff.tif_strip",
        "signature": "libtiff.tif_strip.TIFFVStripSize64(TIFF* tif, uint32 nrows)",
        "snippet": "uint64\nTIFFVStripSize64(TIFF* tif, uint32 nrows)\n{\n\tstatic const char module[] = \"TIFFVStripSize64\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tif (nrows==(uint32)(-1))\n\t\tnrows=td->td_imagelength;\n\tif ((td->td_planarconfig==PLANARCONFIG_CONTIG)&&\n\t    (td->td_photometric == PHOTOMETRIC_YCBCR)&&\n\t    (!isUpSampled(tif)))\n\t{\n\t\t/*\n\t\t * Packed YCbCr data contain one Cb+Cr for every\n\t\t * HorizontalSampling*VerticalSampling Y values.\n\t\t * Must also roundup width and height when calculating\n\t\t * since images that are not a multiple of the\n\t\t * horizontal/vertical subsampling area include\n\t\t * YCbCr data for the extended image.\n\t\t */\n\t\tuint16 ycbcrsubsampling[2];\n\t\tuint16 samplingblock_samples;\n\t\tuint32 samplingblocks_hor;\n\t\tuint32 samplingblocks_ver;\n\t\tuint64 samplingrow_samples;\n\t\tuint64 samplingrow_size;\n\t\tif(td->td_samplesperpixel!=3)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t\t    \"Invalid td_samplesperpixel value\");\n\t\t\treturn 0;\n\t\t}\n\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_YCBCRSUBSAMPLING,ycbcrsubsampling+0,\n\t\t    ycbcrsubsampling+1);\n\t\tif ((ycbcrsubsampling[0] != 1 && ycbcrsubsampling[0] != 2 && ycbcrsubsampling[0] != 4)\n\t\t    ||(ycbcrsubsampling[1] != 1 && ycbcrsubsampling[1] != 2 && ycbcrsubsampling[1] != 4))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t\t\t     \"Invalid YCbCr subsampling (%dx%d)\", \n\t\t\t\t     ycbcrsubsampling[0], \n\t\t\t\t     ycbcrsubsampling[1] );\n\t\t\treturn 0;\n\t\t}\n\t\tsamplingblock_samples=ycbcrsubsampling[0]*ycbcrsubsampling[1]+2;\n\t\tsamplingblocks_hor=TIFFhowmany_32(td->td_imagewidth,ycbcrsubsampling[0]);\n\t\tsamplingblocks_ver=TIFFhowmany_32(nrows,ycbcrsubsampling[1]);\n\t\tsamplingrow_samples=_TIFFMultiply64(tif,samplingblocks_hor,samplingblock_samples,module);\n\t\tsamplingrow_size=TIFFhowmany8_64(_TIFFMultiply64(tif,samplingrow_samples,td->td_bitspersample,module));\n\t\treturn(_TIFFMultiply64(tif,samplingrow_size,samplingblocks_ver,module));\n\t}\n\telse\n\t\treturn(_TIFFMultiply64(tif,nrows,TIFFScanlineSize64(tif),module));\n}",
        "begin_line": 77,
        "end_line": 128,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_tile.TIFFTileRowSize64#143",
        "src_path": "libtiff/tif_tile.c",
        "class_name": "libtiff.tif_tile",
        "signature": "libtiff.tif_tile.TIFFTileRowSize64(TIFF* tif)",
        "snippet": "uint64\nTIFFTileRowSize64(TIFF* tif)\n{\n        static const char module[] = \"TIFFTileRowSize64\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint64 rowsize;\n\tuint64 tilerowsize;\n\n\tif (td->td_tilelength == 0)\n        {\n                TIFFErrorExt(tif->tif_clientdata,module,\"Tile length is zero\");\n                return 0;\n        }\n        if (td->td_tilewidth == 0)\n        {\n                TIFFErrorExt(tif->tif_clientdata,module,\"Tile width is zero\");\n\t\treturn (0);\n        }\n\trowsize = _TIFFMultiply64(tif, td->td_bitspersample, td->td_tilewidth,\n\t    \"TIFFTileRowSize\");\n\tif (td->td_planarconfig == PLANARCONFIG_CONTIG)\n        {\n                if (td->td_samplesperpixel == 0)\n                {\n                        TIFFErrorExt(tif->tif_clientdata,module,\"Samples per pixel is zero\");\n                        return 0;\n                }\n\t\trowsize = _TIFFMultiply64(tif, rowsize, td->td_samplesperpixel,\n\t\t    \"TIFFTileRowSize\");\n        }\n        tilerowsize=TIFFhowmany8_64(rowsize);\n        if (tilerowsize == 0)\n        {\n                TIFFErrorExt(tif->tif_clientdata,module,\"Computed tile row size is zero\");\n                return 0;\n        }\n\treturn (tilerowsize);\n}",
        "begin_line": 143,
        "end_line": 180,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_tile.TIFFVTileSize64#200",
        "src_path": "libtiff/tif_tile.c",
        "class_name": "libtiff.tif_tile",
        "signature": "libtiff.tif_tile.TIFFVTileSize64(TIFF* tif, uint32 nrows)",
        "snippet": "uint64\nTIFFVTileSize64(TIFF* tif, uint32 nrows)\n{\n\tstatic const char module[] = \"TIFFVTileSize64\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tif (td->td_tilelength == 0 || td->td_tilewidth == 0 ||\n\t    td->td_tiledepth == 0)\n\t\treturn (0);\n\tif ((td->td_planarconfig==PLANARCONFIG_CONTIG)&&\n\t    (td->td_photometric==PHOTOMETRIC_YCBCR)&&\n\t    (td->td_samplesperpixel==3)&&\n\t    (!isUpSampled(tif)))\n\t{\n\t\t/*\n\t\t * Packed YCbCr data contain one Cb+Cr for every\n\t\t * HorizontalSampling*VerticalSampling Y values.\n\t\t * Must also roundup width and height when calculating\n\t\t * since images that are not a multiple of the\n\t\t * horizontal/vertical subsampling area include\n\t\t * YCbCr data for the extended image.\n\t\t */\n\t\tuint16 ycbcrsubsampling[2];\n\t\tuint16 samplingblock_samples;\n\t\tuint32 samplingblocks_hor;\n\t\tuint32 samplingblocks_ver;\n\t\tuint64 samplingrow_samples;\n\t\tuint64 samplingrow_size;\n\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_YCBCRSUBSAMPLING,ycbcrsubsampling+0,\n\t\t    ycbcrsubsampling+1);\n\t\tif ((ycbcrsubsampling[0] != 1 && ycbcrsubsampling[0] != 2 && ycbcrsubsampling[0] != 4)\n\t\t    ||(ycbcrsubsampling[1] != 1 && ycbcrsubsampling[1] != 2 && ycbcrsubsampling[1] != 4))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t\t\t     \"Invalid YCbCr subsampling (%dx%d)\", \n\t\t\t\t     ycbcrsubsampling[0], \n\t\t\t\t     ycbcrsubsampling[1] );\n\t\t\treturn 0;\n\t\t}\n\t\tsamplingblock_samples=ycbcrsubsampling[0]*ycbcrsubsampling[1]+2;\n\t\tsamplingblocks_hor=TIFFhowmany_32(td->td_tilewidth,ycbcrsubsampling[0]);\n\t\tsamplingblocks_ver=TIFFhowmany_32(nrows,ycbcrsubsampling[1]);\n\t\tsamplingrow_samples=_TIFFMultiply64(tif,samplingblocks_hor,samplingblock_samples,module);\n\t\tsamplingrow_size=TIFFhowmany8_64(_TIFFMultiply64(tif,samplingrow_samples,td->td_bitspersample,module));\n\t\treturn(_TIFFMultiply64(tif,samplingrow_size,samplingblocks_ver,module));\n\t}\n\telse\n\t\treturn(_TIFFMultiply64(tif,nrows,TIFFTileRowSize64(tif),module));\n}",
        "begin_line": 200,
        "end_line": 247,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix.TIFFFdOpen#204",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix.TIFFFdOpen(int fd, const char* name, const char* mode)",
        "snippet": "TIFF*\nTIFFFdOpen(int fd, const char* name, const char* mode)\n{\n\tTIFF* tif;\n\n\tfd_as_handle_union_t fdh;\n\tfdh.fd = fd;\n\ttif = TIFFClientOpen(name, mode,\n\t    fdh.h,\n\t    _tiffReadProc, _tiffWriteProc,\n\t    _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,\n\t    _tiffMapProc, _tiffUnmapProc);\n\tif (tif)\n\t\ttif->tif_fd = fd;\n\treturn (tif);\n}",
        "begin_line": 204,
        "end_line": 219,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix.TIFFOpen#224",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix.TIFFOpen(const char* name, const char* mode)",
        "snippet": "TIFF*\nTIFFOpen(const char* name, const char* mode)\n{\n\tstatic const char module[] = \"TIFFOpen\";\n\tint m, fd;\n\tTIFF* tif;\n\n\tm = _TIFFgetMode(mode, module);\n\tif (m == -1)\n\t\treturn ((TIFF*)0);\n\n/* for cygwin and mingw */\n#ifdef O_BINARY\n\tm |= O_BINARY;\n#endif\n\n\tfd = open(name, m, 0666);\n\tif (fd < 0) {\n\t\tif (errno > 0 && strerror(errno) != NULL ) {\n\t\t\tTIFFErrorExt(0, module, \"%s: %s\", name, strerror(errno) );\n\t\t} else {\n\t\t\tTIFFErrorExt(0, module, \"%s: Cannot open\", name);\n\t\t}\n\t\treturn ((TIFF *)0);\n\t}\n\n\ttif = TIFFFdOpen((int)fd, name, mode);\n\tif(!tif)\n\t\tclose(fd);\n\treturn tif;\n}",
        "begin_line": 224,
        "end_line": 254,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._TIFFfree#319",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._TIFFfree(void* p)",
        "snippet": "void\n_TIFFfree(void* p)\n{\n\tfree(p);\n}",
        "begin_line": 319,
        "end_line": 323,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._TIFFmalloc#310",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._TIFFmalloc(tmsize_t s)",
        "snippet": "void*\n_TIFFmalloc(tmsize_t s)\n{\n        if (s == 0)\n                return ((void *) NULL);\n\n\treturn (malloc((size_t) s));\n}",
        "begin_line": 310,
        "end_line": 317,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._TIFFmemcpy#337",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._TIFFmemcpy(void* d, const void* s, tmsize_t c)",
        "snippet": "void\n_TIFFmemcpy(void* d, const void* s, tmsize_t c)\n{\n\tmemcpy(d, s, (size_t) c);\n}",
        "begin_line": 337,
        "end_line": 341,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._TIFFmemset#331",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._TIFFmemset(void* p, int v, tmsize_t c)",
        "snippet": "void\n_TIFFmemset(void* p, int v, tmsize_t c)\n{\n\tmemset(p, v, (size_t) c);\n}",
        "begin_line": 331,
        "end_line": 335,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._TIFFrealloc#325",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._TIFFrealloc(void* p, tmsize_t s)",
        "snippet": "void*\n_TIFFrealloc(void* p, tmsize_t s)\n{\n\treturn (realloc(p, (size_t) s));\n}",
        "begin_line": 325,
        "end_line": 329,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._tiffMapProc#162",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._tiffMapProc(thandle_t fd, void** pbase, toff_t* psize)",
        "snippet": "static int\n_tiffMapProc(thandle_t fd, void** pbase, toff_t* psize)\n{\n\tuint64 size64 = _tiffSizeProc(fd);\n\ttmsize_t sizem = (tmsize_t)size64;\n\tif ((uint64)sizem==size64) {\n\t\tfd_as_handle_union_t fdh;\n\t\tfdh.h = fd;\n\t\t*pbase = (void*)\n\t\t    mmap(0, (size_t)sizem, PROT_READ, MAP_SHARED, fdh.fd, 0);\n\t\tif (*pbase != (void*) -1) {\n\t\t\t*psize = (tmsize_t)sizem;\n\t\t\treturn (1);\n\t\t}\n\t}\n\treturn (0);\n}",
        "begin_line": 162,
        "end_line": 178,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._tiffReadProc#68",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._tiffReadProc(thandle_t fd, void* buf, tmsize_t size)",
        "snippet": "static tmsize_t\n_tiffReadProc(thandle_t fd, void* buf, tmsize_t size)\n{\n\tfd_as_handle_union_t fdh;\n        const size_t bytes_total = (size_t) size;\n        size_t bytes_read;\n        tmsize_t count = -1;\n\tif ((tmsize_t) bytes_total != size)\n\t{\n\t\terrno=EINVAL;\n\t\treturn (tmsize_t) -1;\n\t}\n\tfdh.h = fd;\n        for (bytes_read=0; bytes_read < bytes_total; bytes_read+=count)\n        {\n                char *buf_offset = (char *) buf+bytes_read;\n                size_t io_size = bytes_total-bytes_read;\n                if (io_size > TIFF_IO_MAX)\n                        io_size = TIFF_IO_MAX;\n                count=read(fdh.fd, buf_offset, (TIFFIOSize_t) io_size);\n                if (count <= 0)\n                        break;\n        }\n        if (count < 0)\n                return (tmsize_t)-1;\n        return (tmsize_t) bytes_read;\n}",
        "begin_line": 68,
        "end_line": 94,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix._tiffSizeProc#147",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix._tiffSizeProc(thandle_t fd)",
        "snippet": "static uint64\n_tiffSizeProc(thandle_t fd)\n{\n\t_TIFF_stat_s sb;\n\tfd_as_handle_union_t fdh;\n\tfdh.h = fd;\n\tif (_TIFF_fstat_f(fdh.fd,&sb)<0)\n\t\treturn(0);\n\telse\n\t\treturn((uint64)sb.st_size);\n}",
        "begin_line": 147,
        "end_line": 157,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_unix.unixWarningHandler#349",
        "src_path": "libtiff/tif_unix.c",
        "class_name": "libtiff.tif_unix",
        "signature": "libtiff.tif_unix.unixWarningHandler(const char* module, const char* fmt, va_list ap)",
        "snippet": "static void\nunixWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n\tif (module != NULL)\n\t\tfprintf(stderr, \"%s: \", module);\n\tfprintf(stderr, \"Warning, \");\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \".\\n\");\n}",
        "begin_line": 349,
        "end_line": 357,
        "is_bug": false
    },
    {
        "name": "libtiff.tif_warning.TIFFWarningExt#62",
        "src_path": "libtiff/tif_warning.c",
        "class_name": "libtiff.tif_warning",
        "signature": "libtiff.tif_warning.TIFFWarningExt(thandle_t fd, const char* module, const char* fmt, ...)",
        "snippet": "void\nTIFFWarningExt(thandle_t fd, const char* module, const char* fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tif (_TIFFwarningHandler)\n\t\t(*_TIFFwarningHandler)(module, fmt, ap);\n\tif (_TIFFwarningHandlerExt)\n\t\t(*_TIFFwarningHandlerExt)(fd, module, fmt, ap);\n\tva_end(ap);\n}",
        "begin_line": 62,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "tools.tiff2ps.PSColorContigPreamble#2420",
        "src_path": "tools/tiff2ps.c",
        "class_name": "tools.tiff2ps",
        "signature": "tools.tiff2ps.PSColorContigPreamble(FILE* fd, uint32 w, uint32 h, int nc)",
        "snippet": "void\nPSColorContigPreamble(FILE* fd, uint32 w, uint32 h, int nc)\n{\n\tps_bytesperrow = nc * (tf_bytesperrow / samplesperpixel);\n\tPhotoshopBanner(fd, w, h, 1, nc, \"false %d colorimage\");\n\tfprintf(fd, \"/line %ld string def\\n\", (long) ps_bytesperrow);\n\tfprintf(fd, \"%lu %lu %d\\n\",\n\t    (unsigned long) w, (unsigned long) h, bitspersample);\n\tfprintf(fd, \"[%lu 0 0 -%lu 0 %lu]\\n\",\n\t    (unsigned long) w, (unsigned long) h, (unsigned long) h);\n\tfprintf(fd, \"{currentfile line readhexstring pop} bind\\n\");\n\tfprintf(fd, \"false %d colorimage\\n\", nc);\n}",
        "begin_line": 2420,
        "end_line": 2432,
        "is_bug": false
    },
    {
        "name": "tools.tiff2ps.PSDataColorContig#2459",
        "src_path": "tools/tiff2ps.c",
        "class_name": "tools.tiff2ps",
        "signature": "tools.tiff2ps.PSDataColorContig(FILE* fd, TIFF* tif, uint32 w, uint32 h, int nc)",
        "snippet": "void\nPSDataColorContig(FILE* fd, TIFF* tif, uint32 w, uint32 h, int nc)\n{\n\tuint32 row;\n\tint breaklen = MAXLINE, es = samplesperpixel - nc;\n\ttsize_t cc;\n\tunsigned char *tf_buf;\n\tunsigned char *cp, c;\n\n\t(void) w;\n\ttf_buf = (unsigned char *) _TIFFmalloc(tf_bytesperrow);\n\tif (tf_buf == NULL) {\n\t\tTIFFError(filename, \"No space for scanline buffer\");\n\t\treturn;\n\t}\n\tfor (row = 0; row < h; row++) {\n\t\tif (TIFFReadScanline(tif, tf_buf, row, 0) < 0)\n\t\t\tbreak;\n\t\tcp = tf_buf;\n\t\t/*\n\t\t * for 16 bits, the two bytes must be most significant\n\t\t * byte first\n\t\t */\n\t\tif (bitspersample == 16 && !HOST_BIGENDIAN) {\n\t\t\tPS_FlipBytes(cp, tf_bytesperrow);\n\t\t}\n\t\tif (alpha) {\n\t\t\tint adjust;\n\t\t\tcc = 0;\n\t\t\tfor (; cc < tf_bytesperrow; cc += samplesperpixel) {\n\t\t\t\tDOBREAK(breaklen, nc, fd);\n\t\t\t\t/*\n\t\t\t\t * For images with alpha, matte against\n\t\t\t\t * a white background; i.e.\n\t\t\t\t *    Cback * (1 - Aimage)\n\t\t\t\t * where Cback = 1.\n\t\t\t\t */\n\t\t\t\tadjust = 255 - cp[nc];\n\t\t\t\tswitch (nc) {\n\t\t\t\tcase 4: c = *cp++ + adjust; PUTHEX(c,fd);\n\t\t\t\tcase 3: c = *cp++ + adjust; PUTHEX(c,fd);\n\t\t\t\tcase 2: c = *cp++ + adjust; PUTHEX(c,fd);\n\t\t\t\tcase 1: c = *cp++ + adjust; PUTHEX(c,fd);\n\t\t\t\t}\n\t\t\t\tcp += es;\n\t\t\t}\n\t\t} else {\n\t\t\tcc = 0;\n\t\t\tfor (; cc < tf_bytesperrow; cc += samplesperpixel) {\n\t\t\t\tDOBREAK(breaklen, nc, fd);\n\t\t\t\tswitch (nc) {\n\t\t\t\tcase 4: c = *cp++; PUTHEX(c,fd);\n\t\t\t\tcase 3: c = *cp++; PUTHEX(c,fd);\n\t\t\t\tcase 2: c = *cp++; PUTHEX(c,fd);\n\t\t\t\tcase 1: c = *cp++; PUTHEX(c,fd);\n\t\t\t\t}\n\t\t\t\tcp += es;\n\t\t\t}\n\t\t}\n\t}\n\t_TIFFfree((char *) tf_buf);\n}",
        "begin_line": 2459,
        "end_line": 2520,
        "is_bug": true
    },
    {
        "name": "tools.tiff2ps.PSHead#1680",
        "src_path": "tools/tiff2ps.c",
        "class_name": "tools.tiff2ps",
        "signature": "tools.tiff2ps.PSHead(FILE *fd, double pagewidth, double pageheight, double xoff, double yoff)",
        "snippet": "void\nPSHead(FILE *fd, double pagewidth, double pageheight, double xoff, double yoff)\n{\n\ttime_t t;\n\n\tt = time(0);\n\tfprintf(fd, \"%%!PS-Adobe-3.0%s\\n\", generateEPSF ? \" EPSF-3.0\" : \"\");\n\tfprintf(fd, \"%%%%Creator: %s\\n\", creator ? creator : \"tiff2ps\");\n        fprintf(fd, \"%%%%Title: %s\\n\", title ? title : filename);\n\tfprintf(fd, \"%%%%CreationDate: %s\", ctime(&t));\n\tfprintf(fd, \"%%%%DocumentData: Clean7Bit\\n\");\n\t/* NB: should use PageBoundingBox for each page instead of BoundingBox *\n         * PageBoundingBox DSC added in PSPageSize function, R Nolde 09-01-2010\n         */\n\tfprintf(fd, \"%%%%Origin: %ld %ld\\n\", (long) xoff, (long) yoff);\n        fprintf(fd, \"%%%%BoundingBox: 0 0 %ld %ld\\n\",\n\t       (long) ceil(pagewidth), (long) ceil(pageheight));\n\n\tfprintf(fd, \"%%%%LanguageLevel: %d\\n\", (level3 ? 3 : (level2 ? 2 : 1)));\n        if (generateEPSF == TRUE)\n\t  fprintf(fd, \"%%%%Pages: 1 1\\n\");\n        else\n\t  fprintf(fd, \"%%%%Pages: (atend)\\n\");\n\tfprintf(fd, \"%%%%EndComments\\n\");\n        if (generateEPSF == FALSE)\n          {\n  \t  fprintf(fd, \"%%%%BeginSetup\\n\");\n\t  if (PSduplex)\n\t\tfprintf(fd, \"%s\", DuplexPreamble);\n\t  if (PStumble)\n\t\tfprintf(fd, \"%s\", TumblePreamble);\n\t  if (PSavoiddeadzone && (level2 || level3))\n\t\tfprintf(fd, \"%s\", AvoidDeadZonePreamble);\n\t  fprintf(fd, \"%%%%EndSetup\\n\");\n\t  }\n}",
        "begin_line": 1680,
        "end_line": 1715,
        "is_bug": false
    },
    {
        "name": "tools.tiff2ps.PSpage#2357",
        "src_path": "tools/tiff2ps.c",
        "class_name": "tools.tiff2ps",
        "signature": "tools.tiff2ps.PSpage(FILE* fd, TIFF* tif, uint32 w, uint32 h)",
        "snippet": "void\nPSpage(FILE* fd, TIFF* tif, uint32 w, uint32 h)\n{\n\tchar\t*\timageOp = \"image\";\n\n\tif ( useImagemask && (bitspersample == 1) )\n\t\timageOp = \"imagemask\";\n\n\tif ((level2 || level3) && PS_Lvl2page(fd, tif, w, h))\n\t\treturn;\n\tps_bytesperrow = tf_bytesperrow - (extrasamples * bitspersample / 8)*w;\n\tswitch (photometric) {\n\tcase PHOTOMETRIC_RGB:\n\t\tif (planarconfiguration == PLANARCONFIG_CONTIG) {\n\t\t\tfprintf(fd, \"%s\", RGBcolorimage);\n\t\t\tPSColorContigPreamble(fd, w, h, 3);\n\t\t\tPSDataColorContig(fd, tif, w, h, 3);\n\t\t} else {\n\t\t\tPSColorSeparatePreamble(fd, w, h, 3);\n\t\t\tPSDataColorSeparate(fd, tif, w, h, 3);\n\t\t}\n\t\tbreak;\n\tcase PHOTOMETRIC_SEPARATED:\n\t\t/* XXX should emit CMYKcolorimage */\n\t\tif (planarconfiguration == PLANARCONFIG_CONTIG) {\n\t\t\tPSColorContigPreamble(fd, w, h, 4);\n\t\t\tPSDataColorContig(fd, tif, w, h, 4);\n\t\t} else {\n\t\t\tPSColorSeparatePreamble(fd, w, h, 4);\n\t\t\tPSDataColorSeparate(fd, tif, w, h, 4);\n\t\t}\n\t\tbreak;\n\tcase PHOTOMETRIC_PALETTE:\n\t\tfprintf(fd, \"%s\", RGBcolorimage);\n\t\tPhotoshopBanner(fd, w, h, 1, 3, \"false 3 colorimage\");\n\t\tfprintf(fd, \"/scanLine %ld string def\\n\",\n\t\t    (long) ps_bytesperrow * 3L);\n\t\tfprintf(fd, \"%lu %lu 8\\n\",\n\t\t    (unsigned long) w, (unsigned long) h);\n\t\tfprintf(fd, \"[%lu 0 0 -%lu 0 %lu]\\n\",\n\t\t    (unsigned long) w, (unsigned long) h, (unsigned long) h);\n\t\tfprintf(fd, \"{currentfile scanLine readhexstring pop} bind\\n\");\n\t\tfprintf(fd, \"false 3 colorimage\\n\");\n\t\tPSDataPalette(fd, tif, w, h);\n\t\tbreak;\n\tcase PHOTOMETRIC_MINISBLACK:\n\tcase PHOTOMETRIC_MINISWHITE:\n\t\tPhotoshopBanner(fd, w, h, 1, 1, imageOp);\n\t\tfprintf(fd, \"/scanLine %ld string def\\n\",\n\t\t    (long) ps_bytesperrow);\n\t\tfprintf(fd, \"%lu %lu %d\\n\",\n\t\t    (unsigned long) w, (unsigned long) h, bitspersample);\n\t\tfprintf(fd, \"[%lu 0 0 -%lu 0 %lu]\\n\",\n\t\t    (unsigned long) w, (unsigned long) h, (unsigned long) h);\n\t\tfprintf(fd,\n\t\t    \"{currentfile scanLine readhexstring pop} bind\\n\");\n\t\tfprintf(fd, \"%s\\n\", imageOp);\n\t\tPSDataBW(fd, tif, w, h);\n\t\tbreak;\n\t}\n\tputc('\\n', fd);\n}",
        "begin_line": 2357,
        "end_line": 2418,
        "is_bug": false
    },
    {
        "name": "tools.tiff2ps.PhotoshopBanner#629",
        "src_path": "tools/tiff2ps.c",
        "class_name": "tools.tiff2ps",
        "signature": "tools.tiff2ps.PhotoshopBanner(FILE* fd, uint32 w, uint32 h, int bs, int nc, char* startline)",
        "snippet": "static void\nPhotoshopBanner(FILE* fd, uint32 w, uint32 h, int bs, int nc, char* startline)\n{\n\tfprintf(fd, \"%%ImageData: %ld %ld %d %d 0 %d 2 \\\"\",\n\t    (long) w, (long) h, bitspersample, nc, bs);\n\tfprintf(fd, startline, nc);\n\tfprintf(fd, \"\\\"\\n\");\n}",
        "begin_line": 629,
        "end_line": 636,
        "is_bug": false
    },
    {
        "name": "tools.tiff2ps.TIFF2PS#1508",
        "src_path": "tools/tiff2ps.c",
        "class_name": "tools.tiff2ps",
        "signature": "tools.tiff2ps.TIFF2PS(FILE* fd, TIFF* tif, double pgwidth, double pgheight, double lm, double bm, int center)",
        "snippet": "int TIFF2PS(FILE* fd, TIFF* tif, double pgwidth, double pgheight, double lm, double bm, int center)\n  {\n  uint32 pixwidth = 0, pixheight = 0;  /* Image width and height in pixels */\n  double ox = 0.0, oy = 0.0;  /* Offset from current Postscript origin */\n  double pswidth, psheight;   /* Original raw image width and height in points */\n  double view_width, view_height; /* Viewport width and height in points */\n  double scale = 1.0;\n  double left_offset = lm * PS_UNIT_SIZE;\n  double bottom_offset = bm * PS_UNIT_SIZE;\n  uint32 subfiletype;\n  uint16* sampleinfo;\n  static int npages = 0;\n\n  if (!TIFFGetField(tif, TIFFTAG_XPOSITION, &ox))\n     ox = 0;\n  if (!TIFFGetField(tif, TIFFTAG_YPOSITION, &oy))\n     oy = 0;\n\n  /* Consolidated all the tag information into one code segment, Richard Nolde */\n  do {\n     tf_numberstrips = TIFFNumberOfStrips(tif);\n     TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &tf_rowsperstrip);\n     TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n     TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n     TIFFGetFieldDefaulted(tif, TIFFTAG_PLANARCONFIG, &planarconfiguration);\n     TIFFGetField(tif, TIFFTAG_COMPRESSION, &compression);\n     TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES, &extrasamples, &sampleinfo);\n     alpha = (extrasamples == 1 && sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);\n     if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric))\n       {\n       switch (samplesperpixel - extrasamples)\n             {\n            case 1: if (isCCITTCompression(tif))\n                      photometric = PHOTOMETRIC_MINISWHITE;\n                    else\n                       photometric = PHOTOMETRIC_MINISBLACK;\n                    break;\n            case 3: photometric = PHOTOMETRIC_RGB;\n                    break;\n            case 4: photometric = PHOTOMETRIC_SEPARATED;\n                    break;\n            }\n       }\n\n     /* Read image tags for width and height in pixels pixwidth, pixheight,\n      * and convert to points pswidth, psheight\n      */\n     setupPageState(tif, &pixwidth, &pixheight, &pswidth, &psheight);\n     view_width = pswidth;\n     view_height = psheight;\n\n     if (get_viewport (pgwidth, pgheight, pswidth, psheight, &view_width, &view_height, rotation))\n       {\n       TIFFError(\"get_viewport\", \"Unable to set image viewport\");\n       return (1);\n       }\n\n     /* Write the Postscript file header with Bounding Box and Page Size definitions */\n     if (psStart(fd, npages, auto_rotate, &rotation, &scale, ox, oy,\n                pgwidth, pgheight, view_width, view_height, pswidth, psheight,\n                 left_offset, bottom_offset))\n       return (-1);\n\n     if (checkImage(tif))  /* Aborts if unsupported image parameters */\n       {\n       tf_bytesperrow = TIFFScanlineSize(tif);\n\n       /* Set viewport clipping and scaling options */\n       if ((maxPageHeight) || (maxPageWidth)  || (pgwidth != 0) || (pgheight != 0))\n         {\n        if ((maxPageHeight) || (maxPageWidth)) /* used -H or -W  option */\n           {\n          if (psMaskImage(fd, tif, rotation, center, &npages, pixwidth, pixheight,\n                          left_offset, bottom_offset, pgwidth, pgheight,\n                           pswidth, psheight, scale) < 0)\n            return (-1);\n          }\n         else  /* N.B. Setting maxPageHeight no longer sets pgheight */\n           {\n           if (pgwidth != 0 || pgheight != 0)\n             {\n             /* User did not specify a maxium page height or width using -H or -W flag\n              * but did use -h or -w flag to scale to a specific size page.\n              */\n             npages++;\n             fprintf(fd, \"%%%%Page: %d %d\\n\", npages, npages);\n\n             if (!generateEPSF && ( level2 || level3 ))\n               {\n              /* Write out the PageSize info for non EPS files */\n              if (psPageSize(fd, rotation, pgwidth, pgheight,\n                              view_width, view_height, pswidth, psheight))\n                return (-1);\n               }\n             fprintf(fd, \"gsave\\n\");\n             fprintf(fd, \"100 dict begin\\n\");\n             if (psScaleImage(fd, scale, rotation, center, view_width, view_height,\n                              pswidth, psheight, left_offset, bottom_offset))\n              return (-1);\n\n             PSpage(fd, tif, pixwidth, pixheight);\n             fprintf(fd, \"end\\n\");\n             fprintf(fd, \"grestore\\n\");\n             fprintf(fd, \"showpage\\n\");\n            }\n          }\n        }\n       else  /* Simple rotation: user did not use -H, -W, -h or -w */\n         {\n         npages++;\n         fprintf(fd, \"%%%%Page: %d %d\\n\", npages, npages);\n\n         if (!generateEPSF && ( level2 || level3 ))\n           {\n          /* Write out the PageSize info for non EPS files */\n          if (psPageSize(fd, rotation, pgwidth, pgheight,\n                          view_width, view_height, pswidth, psheight))\n           return (-1);\n         }\n         fprintf(fd, \"gsave\\n\");\n         fprintf(fd, \"100 dict begin\\n\");\n        if (psRotateImage(fd, rotation, pswidth, psheight, left_offset, bottom_offset))\n           return (-1);\n\n         PSpage(fd, tif, pixwidth, pixheight);\n         fprintf(fd, \"end\\n\");\n         fprintf(fd, \"grestore\\n\");\n         fprintf(fd, \"showpage\\n\");\n         }\n       }\n  if (generateEPSF)\n    break;\n  if (auto_rotate)\n    rotation = 0.0;\n  TIFFGetFieldDefaulted(tif, TIFFTAG_SUBFILETYPE, &subfiletype);\n  } while (((subfiletype & FILETYPE_PAGE) || printAll) && TIFFReadDirectory(tif));\n\nreturn(npages);\n}",
        "begin_line": 1508,
        "end_line": 1646,
        "is_bug": false
    },
    {
        "name": "tools.tiff2ps.__asan_on_error#250",
        "src_path": "tools/tiff2ps.c",
        "class_name": "tools.tiff2ps",
        "signature": "tools.tiff2ps.__asan_on_error(void)",
        "snippet": "void __asan_on_error(void) {\n#ifdef DPP_ENABLE_GCOV\n    __gcov_flush();\n#endif\n}",
        "begin_line": 250,
        "end_line": 254,
        "is_bug": false
    },
    {
        "name": "tools.tiff2ps.checkImage#525",
        "src_path": "tools/tiff2ps.c",
        "class_name": "tools.tiff2ps",
        "signature": "tools.tiff2ps.checkImage(TIFF* tif)",
        "snippet": "static int\ncheckImage(TIFF* tif)\n{\n\tswitch (photometric) {\n\tcase PHOTOMETRIC_YCBCR:\n\t\tif ((compression == COMPRESSION_JPEG || compression == COMPRESSION_OJPEG)\n\t\t\t&& planarconfiguration == PLANARCONFIG_CONTIG) {\n\t\t\t/* can rely on libjpeg to convert to RGB */\n\t\t\tTIFFSetField(tif, TIFFTAG_JPEGCOLORMODE,\n\t\t\t\t     JPEGCOLORMODE_RGB);\n\t\t\tphotometric = PHOTOMETRIC_RGB;\n\t\t} else {\n\t\t\tif (level2 || level3)\n\t\t\t\tbreak;\n\t\t\tTIFFError(filename, \"Can not handle image with %s\",\n\t\t\t    \"PhotometricInterpretation=YCbCr\");\n\t\t\treturn (0);\n\t\t}\n\t\t/* fall thru... */\n\tcase PHOTOMETRIC_RGB:\n\t\tif (alpha && bitspersample != 8) {\n\t\t\tTIFFError(filename,\n\t\t\t    \"Can not handle %d-bit/sample RGB image with alpha\",\n\t\t\t    bitspersample);\n\t\t\treturn (0);\n\t\t}\n\t\t/* fall thru... */\n\tcase PHOTOMETRIC_SEPARATED:\n\tcase PHOTOMETRIC_PALETTE:\n\tcase PHOTOMETRIC_MINISBLACK:\n\tcase PHOTOMETRIC_MINISWHITE:\n\t\tbreak;\n\tcase PHOTOMETRIC_LOGL:\n\tcase PHOTOMETRIC_LOGLUV:\n\t\tif (compression != COMPRESSION_SGILOG &&\n\t\t    compression != COMPRESSION_SGILOG24) {\n\t\t\tTIFFError(filename,\n\t\t    \"Can not handle %s data with compression other than SGILog\",\n\t\t\t    (photometric == PHOTOMETRIC_LOGL) ?\n\t\t\t\t\"LogL\" : \"LogLuv\"\n\t\t\t);\n\t\t\treturn (0);\n\t\t}\n\t\t/* rely on library to convert to RGB/greyscale */\n\t\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n\t\tphotometric = (photometric == PHOTOMETRIC_LOGL) ?\n\t\t    PHOTOMETRIC_MINISBLACK : PHOTOMETRIC_RGB;\n\t\tbitspersample = 8;\n\t\tbreak;\n\tcase PHOTOMETRIC_CIELAB:\n\t\t/* fall thru... */\n\tdefault:\n\t\tTIFFError(filename,\n\t\t    \"Can not handle image with PhotometricInterpretation=%d\",\n\t\t    photometric);\n\t\treturn (0);\n\t}\n\tswitch (bitspersample) {\n\tcase 1: case 2:\n\tcase 4: case 8:\n\tcase 16:\n\t\tbreak;\n\tdefault:\n\t\tTIFFError(filename, \"Can not handle %d-bit/sample image\",\n\t\t    bitspersample);\n\t\treturn (0);\n\t}\n\tif (planarconfiguration == PLANARCONFIG_SEPARATE && extrasamples > 0)\n\t\tTIFFWarning(filename, \"Ignoring extra samples\");\n\treturn (1);\n}",
        "begin_line": 525,
        "end_line": 595,
        "is_bug": false
    },
    {
        "name": "tools.tiff2ps.get_viewport#1429",
        "src_path": "tools/tiff2ps.c",
        "class_name": "tools.tiff2ps",
        "signature": "tools.tiff2ps.get_viewport (double pgwidth, double pgheight, double pswidth, double psheight, double *view_width, double *view_height, int rotation)",
        "snippet": "int get_viewport (double pgwidth, double pgheight, double pswidth, double psheight,\n                  double *view_width, double *view_height, int rotation)\n  {\n  /* Only one of maxPageHeight or maxPageWidth can be specified */\n  if (maxPageHeight != 0)   /* Clip the viewport to maxPageHeight on each page */\n    {\n    if (pgheight != 0 && pgheight < maxPageHeight)\n      *view_height = pgheight * PS_UNIT_SIZE;\n    else\n      *view_height = maxPageHeight * PS_UNIT_SIZE;\n    /*\n     * if (res_unit == RESUNIT_CENTIMETER)\n     * *view_height /= 2.54F;\n     */\n    }\n  else\n    {\n    if (pgheight != 0) /* User has set PageHeight with -h flag */\n      {\n      *view_height = pgheight * PS_UNIT_SIZE; /* Postscript size for Page Height in inches */\n      /* if (res_unit == RESUNIT_CENTIMETER)\n       *  *view_height /= 2.54F;\n       */\n      }\n    else /* If no width or height are specified, use the original size from image */\n      switch (rotation)\n        {\n        default:\n        case   0:\n        case 180: *view_height = psheight;\n                 break;\n        case  90:\n        case 270: *view_height = pswidth;\n                 break;\n       }\n    }\n\n  if (maxPageWidth != 0)   /* Clip the viewport to maxPageWidth on each page */\n    {\n    if (pgwidth != 0 && pgwidth < maxPageWidth)\n      *view_width = pgwidth * PS_UNIT_SIZE;\n    else\n      *view_width = maxPageWidth * PS_UNIT_SIZE;\n    /* if (res_unit == RESUNIT_CENTIMETER)\n     *  *view_width /= 2.54F;\n     */\n    }\n  else\n    {\n    if (pgwidth != 0)  /* User has set PageWidth with -w flag */\n      {\n      *view_width = pgwidth * PS_UNIT_SIZE; /* Postscript size for Page Width in inches */\n      /* if (res_unit == RESUNIT_CENTIMETER)\n       * *view_width /= 2.54F;\n       */\n      }\n    else  /* If no width or height are specified, use the original size from image */\n      switch (rotation)\n        {\n        default:\n        case   0:\n        case 180: *view_width = pswidth;\n                 break;\n        case  90:\n        case 270: *view_width = psheight; /* (*view_height / psheight) * psheight; */\n                 break;\n       }\n    }\n\n  return (0);\n  }",
        "begin_line": 1429,
        "end_line": 1499,
        "is_bug": false
    },
    {
        "name": "tools.tiff2ps.main#255",
        "src_path": "tools/tiff2ps.c",
        "class_name": "tools.tiff2ps",
        "signature": "tools.tiff2ps.main(int argc, char* argv[])",
        "snippet": "int\nmain(int argc, char* argv[])\n{\n#ifdef DPP_ENABLE_GCOV\n\t  {\n\t\t  dpp_gcov_sigaction.sa_handler = dpp_sighandler;\n\t\t  sigemptyset(&dpp_gcov_sigaction.sa_mask);\n\t\t  dpp_gcov_sigaction.sa_flags = 0;\n\t\t  sigaction(SIGSEGV, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n\t\t  sigaction(SIGFPE, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n\t\t  sigaction(SIGABRT, &dpp_gcov_sigaction, &dpp_orig_sigaction);\n\t  }\n#endif\n\tint dirnum = -1, c, np = 0;\n\tint centered = 0;\n\tdouble bottommargin = 0;\n\tdouble leftmargin = 0;\n\tdouble pageWidth = 0;\n\tdouble pageHeight = 0;\n\tuint32 diroff = 0;\n#if !HAVE_DECL_OPTARG\n\textern char *optarg;\n\textern int optind;\n#endif\n\tFILE* output = stdout;\n\n        pageOrientation[0] = '\\0';\n\n\twhile ((c = getopt(argc, argv, \"b:d:h:H:W:L:i:w:l:o:O:P:C:r:t:acemxyzps1238DT\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'b':\n\t\t\tbottommargin = atof(optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tcentered = 1;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tcreator = optarg;\n\t\t\tbreak;\n\t\tcase 'd': /* without -a, this only processes one image at this IFD */\n\t\t\tdirnum = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tPSduplex = TRUE;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tinterpolate = atoi(optarg) ? TRUE:FALSE;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tPStumble = TRUE;\n\t\t\tbreak;\n\t\tcase 'e':\n                        PSavoiddeadzone = FALSE;\n\t\t\tgenerateEPSF = TRUE;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tpageHeight = atof(optarg);\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tmaxPageHeight = atof(optarg);\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\tmaxPageWidth = atof(optarg);\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tsplitOverlap = atof(optarg);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tuseImagemask = TRUE;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t        switch (optarg[0])\n                          {\n                          case '0':\n                          case '1':\n                          case '2':\n                          case '3':\n                          case '4':\n                          case '5':\n                          case '6':\n                          case '7':\n                          case '8':\n                          case '9': diroff = (uint32) strtoul(optarg, NULL, 0);\n\t\t\t          break;\n                          default: TIFFError (\"-o\", \"Offset must be a numeric value.\");\n\t\t\t    exit (1);\n\t\t\t  }\n\t\t\tbreak;\n\t\tcase 'O':\t\t/* XXX too bad -o is already taken */\n\t\t\toutput = fopen(optarg, \"w\");\n\t\t\tif (output == NULL) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"%s: %s: Cannot open output file.\\n\",\n\t\t\t\t    argv[0], optarg);\n\t\t\t\texit(-2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'P':\n                        switch (optarg[0])\n                          {\n                          case 'l':\n                          case 'L': strcpy (pageOrientation, \"Landscape\");\n\t\t\t            break; \n                          case 'p':\n                          case 'P': strcpy (pageOrientation, \"Portrait\");\n\t\t\t            break; \n                          default: TIFFError (\"-P\", \"Page orientation must be Landscape or Portrait\");\n\t\t\t           exit (-1);\n\t\t\t  }\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tleftmargin = atof(optarg);\n\t\t\tbreak;\n\t\tcase 'a': /* removed fall through to generate warning below, R Nolde 09-01-2010 */\n\t\t\tprintAll = TRUE;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tgenerateEPSF = FALSE;\n\t\t\tbreak;\n\t\tcase 'r':\n                        if (strcmp (optarg, \"auto\") == 0)\n\t\t\t  {\n                          rotation = 0;\n                          auto_rotate = TRUE;\n                          }\n                        else\n\t\t\t  {\n \t\t\t  rotation = atoi(optarg);\n                          auto_rotate = FALSE;\n\t\t\t  }\n                        switch (rotation)\n                          {\n\t\t\t  case   0:\n                          case  90:\n                          case 180:\n                          case 270:\n\t\t\t    break;\n\t\t\t  default:\n                            fprintf (stderr, \"Rotation angle must be 90, 180, 270 (degrees ccw) or auto\\n\");\n\t\t\t    exit (-1);\n\t\t\t  }\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tprintAll = FALSE;\n\t\t\tbreak;\n                case 't':\n                        title = optarg;\n                        break;\n\t\tcase 'w':\n\t\t\tpageWidth = atof(optarg);\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tPSavoiddeadzone = FALSE;\n\t\t\tbreak;\n\t\tcase '1':\n\t\t\tlevel2 = FALSE;\n\t\t\tlevel3 = FALSE;\n\t\t\tascii85 = FALSE;\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\tlevel2 = TRUE;\n\t\t\tascii85 = TRUE;\t\t\t/* default to yes */\n\t\t\tbreak;\n\t\tcase '3':\n\t\t\tlevel3 = TRUE;\n\t\t\tascii85 = TRUE;\t\t\t/* default to yes */\n\t\t\tbreak;\n\t\tcase '8':\n\t\t\tascii85 = FALSE;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tres_unit = RESUNIT_CENTIMETER;\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tres_unit = RESUNIT_INCH;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage(-1);\n\t\t}\n\n        if (useImagemask == TRUE)\n          {\n\t  if ((level2 == FALSE) && (level3 == FALSE))\n            {\n\t    TIFFError (\"-m \",\" imagemask operator requres Postscript Level2 or Level3\");\n\t    exit (1);\n            }\n          }\n\n        if (pageWidth && (maxPageWidth > pageWidth))\n\t  {\n\t  TIFFError (\"-W\", \"Max viewport width cannot exceed page width\");\n\t  exit (1);\n          }\n\n        /* auto rotate requires a specified page width and height */\n        if (auto_rotate == TRUE)\n          {\n\t    /*\n\t  if ((pageWidth == 0) || (pageHeight == 0))\n\t    TIFFWarning (\"-r auto\", \" requires page height and width specified with -h and -w\");\n\t    */\n          if ((maxPageWidth > 0) || (maxPageHeight > 0))\n            {\n\t    TIFFError (\"-r auto\", \" is incompatible with maximum page width/height specified by -H or -W\");\n            exit (1);\n            }\n          }\n        if ((maxPageWidth > 0) && (maxPageHeight > 0))\n            {\n\t    TIFFError (\"-H and -W\", \" Use only one of -H or -W to define a viewport\");\n            exit (1);\n            }\n\n        if ((generateEPSF == TRUE) && (printAll == TRUE))\n          {\n\t  TIFFError(\" -e and -a\", \"Warning: Cannot generate Encapsulated Postscript for multiple images\");\n\t  generateEPSF = FALSE;\n          }\n\n        if ((generateEPSF == TRUE) && (PSduplex == TRUE))\n          {\n\t  TIFFError(\" -e and -D\", \"Warning: Encapsulated Postscript does not support Duplex option\");\n\t  PSduplex = FALSE;\n          }\n\n        if ((generateEPSF == TRUE) && (PStumble == TRUE))\n          {\n\t  TIFFError(\" -e and -T\", \"Warning: Encapsulated Postscript does not support Top Edge Binding option\");\n\t  PStumble = FALSE;\n          }\n\n        if ((generateEPSF == TRUE) && (PSavoiddeadzone == TRUE))\n\t  PSavoiddeadzone = FALSE;\n\n\tfor (; argc - optind > 0; optind++) {\n\t\tTIFF* tif = TIFFOpen(filename = argv[optind], \"r\");\n\t\tif (tif != NULL) {\n\t\t\tif (dirnum != -1\n                            && !TIFFSetDirectory(tif, (tdir_t)dirnum))\n\t\t\t\treturn (-1);\n\t\t\telse if (diroff != 0 &&\n\t\t\t    !TIFFSetSubDirectory(tif, diroff))\n\t\t\t\treturn (-1);\n\t\t\tnp = TIFF2PS(output, tif, pageWidth, pageHeight,\n\t\t\t\t     leftmargin, bottommargin, centered);\n                        if (np < 0)\n                          {\n\t\t\t  TIFFError(\"Error\", \"Unable to process %s\", filename);\n                          }\n\t\t\tTIFFClose(tif);\n\t\t}\n\t}\n\tif (np)\n\t\tPSTail(output, np);\n\telse\n\t\tusage(-1);\n\tif (output != stdout)\n\t\tfclose(output);\n\treturn (0);\n}",
        "begin_line": 255,
        "end_line": 515,
        "is_bug": false
    },
    {
        "name": "tools.tiff2ps.psRotateImage#1005",
        "src_path": "tools/tiff2ps.c",
        "class_name": "tools.tiff2ps",
        "signature": "tools.tiff2ps.psRotateImage (FILE * fd, int rotation, double pswidth, double psheight, double left_offset, double bottom_offset)",
        "snippet": "int  psRotateImage (FILE * fd, int rotation, double pswidth, double psheight,\n                    double left_offset, double bottom_offset)\n  {\n  if ((left_offset != 0.0) || (bottom_offset != 0))\n    fprintf (fd, \"%f %f translate\\n\", left_offset, bottom_offset);\n\n  /* Exchange width and height for 90/270 rotations */\n  switch (rotation)\n    {\n    case   0: fprintf (fd, \"%f %f scale\\n\", pswidth, psheight);\n              break;\n    case  90: fprintf (fd, \"%f %f scale\\n1 0 translate 90 rotate\\n\", psheight, pswidth);\n              break;\n    case 180: fprintf (fd, \"%f %f scale\\n1 1 translate 180 rotate\\n\", pswidth, psheight);\n              break;\n    case 270: fprintf (fd, \"%f %f scale\\n0 1 translate 270 rotate\\n\", psheight, pswidth);\n              break;\n    default:  TIFFError (\"psRotateImage\", \"Unsupported rotation %d.\", rotation);\n             fprintf( fd, \"%f %f scale\\n\", pswidth, psheight);\n              return (1);\n    }\n  return (0);\n  }",
        "begin_line": 1005,
        "end_line": 1027,
        "is_bug": false
    },
    {
        "name": "tools.tiff2ps.psStart#1268",
        "src_path": "tools/tiff2ps.c",
        "class_name": "tools.tiff2ps",
        "signature": "tools.tiff2ps.psStart(FILE *fd, int npages, int auto_rotate, int *rotation, double *scale, double ox, double oy, double pgwidth, double pgheight, double reqwidth, double reqheight, double pswidth, double psheight, double left_offset, double bottom_offset)",
        "snippet": "int psStart(FILE *fd, int npages, int auto_rotate, int *rotation, double *scale,\n            double ox, double oy, double pgwidth, double pgheight,\n           double reqwidth, double reqheight, double pswidth, double psheight,\n           double left_offset, double bottom_offset)\n  {\n  double maxsource = 0.0;    /* Used for auto rotations */\n  double maxtarget = 0.0;\n  double xscale = 1.0, yscale = 1.0;\n  double splitheight;\n  double splitwidth;\n  double view_width = 0.0, view_height = 0.0;\n  double page_width = 0.0, page_height = 0.0;\n\n  /* Splitheight and splitwidth are in inches */\n  splitheight = maxPageHeight * PS_UNIT_SIZE;\n  splitwidth  = maxPageWidth * PS_UNIT_SIZE;\n\n  page_width = pgwidth * PS_UNIT_SIZE;\n  page_height = pgheight * PS_UNIT_SIZE;\n\n  /* If user has specified a page width and height and requested the\n   * image to be auto-rotated to fit on that media, we match the\n   * longest dimension of the image to the longest dimension of the\n   * target media but we have to ignore auto rotate if user specified\n   * maxPageHeight since this makes life way too complicated. */\n  if (auto_rotate)\n    {\n    if ((splitheight != 0) || (splitwidth != 0))\n      {\n      TIFFError (\"psStart\", \"Auto-rotate is incompatible with page splitting \");\n      return (1);\n      }\n\n    /* Find longest edges in image and output media */\n    maxsource = (pswidth >= psheight) ? pswidth : psheight;\n    maxtarget = (reqwidth >= reqheight) ? reqwidth : reqheight;\n\n    if (((maxsource == pswidth) && (maxtarget != reqwidth)) ||\n        ((maxsource == psheight) && (maxtarget != reqheight)))\n      {  /* optimal orientaion does not match input orientation */\n      *rotation = 90;\n      xscale = (reqwidth - left_offset)/psheight;\n      yscale = (reqheight - bottom_offset)/pswidth;\n      }\n    else /* optimal orientaion matches input orientation */\n      {\n      xscale = (reqwidth - left_offset)/pswidth;\n      yscale = (reqheight - bottom_offset)/psheight;\n      }\n    *scale = (xscale < yscale) ? xscale : yscale;\n\n    /* Do not scale image beyound original size */\n    if (*scale > 1.0)\n      *scale = 1.0;\n\n    /* Set the size of the displayed image to requested page size\n     * and optimal orientation.\n     */\n    if (!npages)\n      PSHead(fd, reqwidth, reqheight, ox, oy);\n\n    return (0);\n    }\n\n  /* N.B. If pgwidth or pgheight are set from maxPageHeight/Width,\n   * we have a problem with the tests below under splitheight.\n   */\n\n  switch (*rotation)  /* Auto rotate has NOT been specified */\n    {\n    case   0:\n    case 180: if ((splitheight != 0)  || (splitwidth != 0))\n                {  /* Viewport clipped to maxPageHeight or maxPageWidth */\n                if ((page_width != 0) || (page_height != 0)) /* Image scaled */\n                  {\n                 xscale = (reqwidth  - left_offset) / (page_width ? page_width : pswidth);\n                 yscale = (reqheight - bottom_offset) / (page_height ? page_height : psheight);\n                  *scale = (xscale < yscale) ? xscale : yscale;\n                  /*\n                  if (*scale > 1.0)\n                    *scale = 1.0;\n                   */\n                 }\n                else       /* Image clipped but not scaled */\n                 *scale = 1.0;\n\n                view_width = splitwidth ? splitwidth : *scale * pswidth;\n                view_height = splitheight ? splitheight: *scale * psheight;\n               }\n              else   /* Viewport not clipped to maxPageHeight or maxPageWidth */\n                {\n                if ((page_width != 0) || (page_height != 0))\n                  {   /* Image scaled  */\n                  xscale = (reqwidth - left_offset) / pswidth;\n                  yscale = (reqheight - bottom_offset) / psheight;\n\n                  view_width = reqwidth;\n                  view_height = reqheight;\n                 }\n                else\n                  {  /* Image not scaled  */\n                  xscale = (pswidth - left_offset)/pswidth;\n                  yscale = (psheight - bottom_offset)/psheight;\n\n                  view_width = pswidth;\n                  view_height = psheight;\n                 }\n               }\n             break;\n    case  90:\n    case 270: if ((splitheight != 0) || (splitwidth != 0))\n                {  /* Viewport clipped to maxPageHeight or maxPageWidth */\n                if ((page_width != 0) || (page_height != 0)) /* Image scaled */\n                  {\n                 xscale = (reqwidth - left_offset)/ psheight;\n                 yscale = (reqheight - bottom_offset)/ pswidth;\n                  *scale = (xscale < yscale) ? xscale : yscale;\n                  /*\n                  if (*scale > 1.0)\n                    *scale = 1.0;\n                 */\n                 }\n                else  /* Image clipped but not scaled */\n                 *scale = 1.0;\n                view_width = splitwidth ? splitwidth : *scale * psheight;\n                view_height = splitheight ? splitheight : *scale * pswidth;\n               }\n              else /* Viewport not clipped to maxPageHeight or maxPageWidth */\n                {\n                if ((page_width != 0) || (page_height != 0)) /* Image scaled */\n                  {\n                  xscale = (reqwidth - left_offset) / psheight;\n                  yscale = (reqheight - bottom_offset) / pswidth;\n\n                 view_width = reqwidth;\n                 view_height = reqheight;\n                 }\n                else\n                  {\n                  xscale = (pswidth  - left_offset)/ psheight;\n                 yscale = (psheight  - bottom_offset)/ pswidth;\n\n                 view_width = psheight;\n                 view_height = pswidth;\n                  }\n                }\n              break;\n    default:  TIFFError (\"psPageSize\", \"Invalid rotation %d\", *rotation);\n              return (1);\n    }\n\n  if (!npages)\n    PSHead(fd, (page_width ? page_width : view_width), (page_height ? page_height : view_height), ox, oy);\n\n  *scale = (xscale < yscale) ? xscale : yscale;\n  if (*scale > 1.0)\n    *scale = 1.0;\n\n  return (0);\n  }",
        "begin_line": 1268,
        "end_line": 1427,
        "is_bug": false
    },
    {
        "name": "tools.tiff2ps.setupPageState#645",
        "src_path": "tools/tiff2ps.c",
        "class_name": "tools.tiff2ps",
        "signature": "tools.tiff2ps.setupPageState(TIFF* tif, uint32* pw, uint32* ph, double* pprw, double* pprh)",
        "snippet": "static void\nsetupPageState(TIFF* tif, uint32* pw, uint32* ph, double* pprw, double* pprh)\n{\n\tfloat xres = 0.0F, yres = 0.0F;\n\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, pw);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, ph);\n\tif (res_unit == 0)\t/* Not specified as command line option */\n\t\tif (!TIFFGetFieldDefaulted(tif, TIFFTAG_RESOLUTIONUNIT, &res_unit))\n\t\t\tres_unit = RESUNIT_INCH;\n\t/*\n\t * Calculate printable area.\n\t */\n\tif (!TIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres)\n            || fabs(xres) < 0.0000001)\n\t\txres = PS_UNIT_SIZE;\n\tif (!TIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres)\n            || fabs(yres) < 0.0000001)\n\t\tyres = PS_UNIT_SIZE;\n\tswitch (res_unit) {\n\tcase RESUNIT_CENTIMETER:\n\t\txres *= 2.54F, yres *= 2.54F;\n\t\tbreak;\n\tcase RESUNIT_INCH:\n\t\tbreak;\n\tcase RESUNIT_NONE:\t/* Subsequent code assumes we have converted to inches! */\n\t\tres_unit = RESUNIT_INCH;\n\t\tbreak;\n\tdefault:\t/* Last ditch guess for unspecified RESUNIT case\n\t\t\t * check that the resolution is not inches before scaling it.\n\t\t\t * Moved to end of function with additional check, RJN, 08-31-2010\n\t\t\t * if (xres != PS_UNIT_SIZE || yres != PS_UNIT_SIZE)\n\t\t\t * xres *= PS_UNIT_SIZE, yres *= PS_UNIT_SIZE;\n\t\t\t */\n\t\tbreak;\n\t}\n\t/* This is a hack to deal with images that have no meaningful Resolution Size\n\t * but may have x and/or y resolutions of 1 pixel per undefined unit.\n\t */\n\tif ((xres > 1.0) && (xres != PS_UNIT_SIZE))\n\t\t*pprw = PSUNITS(*pw, xres);\n\telse\n\t\t*pprw = PSUNITS(*pw, PS_UNIT_SIZE);\n\tif ((yres > 1.0) && (yres != PS_UNIT_SIZE))\n\t\t*pprh = PSUNITS(*ph, yres);\n\telse\n\t\t*pprh = PSUNITS(*ph, PS_UNIT_SIZE);\n}",
        "begin_line": 645,
        "end_line": 692,
        "is_bug": false
    }
]