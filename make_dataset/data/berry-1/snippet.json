[
    {
        "name": "be_baselib.l_assert#21",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.l_assert(bvm *vm)",
        "snippet": "static int l_assert(bvm *vm)\n{\n    int argc = be_top(vm);\n    /* assertion fails when there is no argument\n     * or the first argument is nil or false. */\n    if (!argc || !be_tobool(vm, 1)) {\n        const char *msg = \"assert failed!\";\n        if (argc >= 2 && be_isstring(vm, 2)) {\n            msg = be_tostring(vm, 2);\n        }\n        be_raise(vm, \"assert_failed\", msg);\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 21,
        "end_line": 34,
        "is_bug": false
    },
    {
        "name": "be_object.be_indexof#37",
        "src_path": "src/be_object.c",
        "class_name": "be_object",
        "signature": "be_object.be_indexof(bvm *vm, int idx)",
        "snippet": "bvalue* be_indexof(bvm *vm, int idx)\n{\n    if (idx > 0) { /* absolute index */\n        be_assert(vm->reg + idx <= vm->top);\n        return vm->reg + idx - 1;\n    }\n    /* relative index */\n    be_assert(vm->top + idx >= vm->reg);\n    return vm->top + idx;\n}",
        "begin_line": 37,
        "end_line": 46,
        "is_bug": false
    },
    {
        "name": "be_map._hashcode#84",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map._hashcode(bvm *vm, int type, union bvaldata v)",
        "snippet": "static uint32_t _hashcode(bvm *vm, int type, union bvaldata v)\n{\n    (void)vm;\n    switch (type) {\n    case BE_NIL: return 0;\n    case BE_BOOL: return (uint32_t)v.b;\n    case BE_INT: return (uint32_t)v.i;\n    case BE_REAL: return hashreal(v);\n    case BE_STRING: return be_strhash(v.s);\n#if BE_USE_OVERLOAD_HASH\n    case BE_INSTANCE: return hashins(vm, v.p);\n#endif\n    default: return hashptr(v.p);\n    }\n}",
        "begin_line": 84,
        "end_line": 98,
        "is_bug": false
    },
    {
        "name": "be_map.eqnode#100",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.eqnode(bvm *vm, bmapnode *node, bvalue *key, uint32_t hash)",
        "snippet": "static int eqnode(bvm *vm, bmapnode *node, bvalue *key, uint32_t hash)\n{\n    (void)vm;\n    if (!var_isnil(key)) {\n        bmapkey *k = key(node);\n#if BE_USE_OVERLOAD_HASH\n        if (var_isinstance(key)) {\n            bvalue kv;\n            kv.type = k->type;\n            kv.v = k->v;\n            return be_vm_iseq(vm, key, &kv);\n        }\n#endif\n        if(keytype(k) == key->type && hashcode(k) == hash) {\n            switch (key->type) {\n            case BE_INT: return var_toint(key) == var_toint(k);\n            case BE_REAL: return var_toreal(key) == var_toreal(k);\n            case BE_STRING: return be_eqstr(var_tostr(key), var_tostr(k));\n            default: return var_toobj(key) == var_toobj(k);\n            }\n        }\n    }\n    return 0;\n}",
        "begin_line": 100,
        "end_line": 123,
        "is_bug": false
    },
    {
        "name": "be_map.nextfree#139",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.nextfree(bmap *map)",
        "snippet": "static bmapnode* nextfree(bmap *map)\n{\n    bmapnode *base = map->slots;\n    while (map->lastfree >= base) {\n        if (isnil(map->lastfree)) {\n            return map->lastfree;\n        }\n        --map->lastfree;\n    }\n    return NULL;\n}",
        "begin_line": 139,
        "end_line": 149,
        "is_bug": false
    },
    {
        "name": "be_map.insert#151",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.insert(bvm *vm, bmap *map, bvalue *key, uint32_t hash)",
        "snippet": "static bmapnode* insert(bvm *vm, bmap *map, bvalue *key, uint32_t hash)\n{\n    bmapnode *slot = hash2slot(map, hash);\n    if (isnil(slot)) { /* empty slot */\n        setkey(slot, key);\n        next(slot) = LASTNODE;\n    } else {\n        uint32_t h = hashcode(key(slot)); /* get the hashcode of the exist node */\n        bmapnode *mainslot = hash2slot(map, h); /* get the main-slot */\n        bmapnode *new = nextfree(map); /* get a free slot */\n        if (mainslot == slot) { /* old is main slot */\n            /* insert in first */\n            setkey(new, key);\n            next(new) = next(slot);\n            next(slot) = pos(map, new);\n            slot = new;\n        } else {\n            bmapnode *prev = findprev(map, mainslot, slot);\n            next(prev) = pos(map, new); /* link the previous node */\n            *new = *slot; /* copy to new slot */\n            setkey(slot, key);\n            next(slot) = LASTNODE;\n        }\n    }\n    return slot;\n}",
        "begin_line": 151,
        "end_line": 176,
        "is_bug": false
    },
    {
        "name": "be_map.find#178",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.find(bvm *vm, bmap *map, bvalue *key, uint32_t hash)",
        "snippet": "static bmapnode* find(bvm *vm, bmap *map, bvalue *key, uint32_t hash)\n{\n    bmapnode *slot = hash2slot(map, hash);\n    if (isnil(slot)) {\n        return NULL;\n    }\n    while (!eqnode(vm, slot, key, hash)) {\n        int n = next(slot);\n        if (n == LASTNODE) {\n            return NULL;\n        }\n        slot = map->slots + n;\n    }\n    return slot;\n}",
        "begin_line": 178,
        "end_line": 192,
        "is_bug": false
    },
    {
        "name": "be_map.resize#194",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.resize(bvm *vm, bmap *map, int size)",
        "snippet": "static void resize(bvm *vm, bmap *map, int size)\n{\n    int i, oldsize;\n    bmapnode *slots, *oldslots;\n    if (size < map->count) {\n        return;\n    }\n    oldsize = map->size;\n    oldslots = map->slots;\n    slots = be_malloc(vm, datasize(size));\n    for (i = 0; i < size; ++i) {\n        setnil(slots + i);\n    }\n    map->size = size;\n    map->slots = slots;\n    map->lastfree = slots + size - 1;\n    /* rehash */\n    for (i = 0; i < oldsize; ++i) {\n        bmapnode *node = oldslots + i;\n        if (!isnil(node)) {\n            bvalue v;\n            bmapnode *newslot;\n            v.type = node->key.type;\n            v.v = node->key.v;\n            newslot = insert(vm, map, &v, hashcode(&v));\n            newslot->value = node->value;\n        }\n    }\n    be_free(vm, oldslots, datasize(oldsize));\n}",
        "begin_line": 194,
        "end_line": 223,
        "is_bug": false
    },
    {
        "name": "be_map.be_map_new#225",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.be_map_new(bvm *vm)",
        "snippet": "bmap* be_map_new(bvm *vm)\n{\n    bgcobject *gco = be_gcnew(vm, BE_MAP, bmap);\n    bmap *map = cast_map(gco);\n    if (map) {\n        map->size = 0;\n        map->count = 0;\n        map->slots = NULL;\n        var_setmap(vm->top, map);\n        be_incrtop(vm);\n        resize(vm, map, 2);\n        be_stackpop(vm, 1);\n    }\n    return map;\n}",
        "begin_line": 225,
        "end_line": 239,
        "is_bug": false
    },
    {
        "name": "be_map.be_map_delete#241",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.be_map_delete(bvm *vm, bmap *map)",
        "snippet": "void be_map_delete(bvm *vm, bmap *map)\n{\n    be_free(vm, map->slots, datasize(map->size));\n    be_free(vm, map, sizeof(bmap));\n}",
        "begin_line": 241,
        "end_line": 245,
        "is_bug": false
    },
    {
        "name": "be_map.be_map_find#247",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.be_map_find(bvm *vm, bmap *map, bvalue *key)",
        "snippet": "bvalue* be_map_find(bvm *vm, bmap *map, bvalue *key)\n{\n    bmapnode *entry = find(vm, map, key, hashcode(key));\n    return entry ? value(entry) : NULL;\n}",
        "begin_line": 247,
        "end_line": 251,
        "is_bug": false
    },
    {
        "name": "be_map.be_map_insert#253",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.be_map_insert(bvm *vm, bmap *map, bvalue *key, bvalue *value)",
        "snippet": "bvalue* be_map_insert(bvm *vm, bmap *map, bvalue *key, bvalue *value)\n{\n    uint32_t hash = hashcode(key);\n    bmapnode *entry = find(vm, map, key, hash);\n    if (!entry) { /* new entry */\n        if (map->count >= map->size) {\n            resize(vm, map, map_nextsize(map->size));\n        }\n        entry = insert(vm, map, key, hash);\n        ++map->count;\n    }\n    if (value) {\n        entry->value = *value;\n    }\n    return value(entry);\n}",
        "begin_line": 253,
        "end_line": 268,
        "is_bug": false
    },
    {
        "name": "be_map.be_map_findstr#307",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.be_map_findstr(bvm *vm, bmap *map, bstring *key)",
        "snippet": "bvalue* be_map_findstr(bvm *vm, bmap *map, bstring *key)\n{\n    bvalue v;\n    var_setstr(&v, key);\n    return be_map_find(vm, map, &v);\n}",
        "begin_line": 307,
        "end_line": 312,
        "is_bug": false
    },
    {
        "name": "be_map.be_map_insertstr#314",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.be_map_insertstr(bvm *vm, bmap *map, bstring *key, bvalue *value)",
        "snippet": "bvalue* be_map_insertstr(bvm *vm, bmap *map, bstring *key, bvalue *value)\n{\n    bvalue v;\n    var_setstr(&v, key);\n    set_fixed(key);\n    bvalue * r = be_map_insert(vm, map, &v, value);\n    restore_fixed(key);\n    return r;\n}",
        "begin_line": 314,
        "end_line": 322,
        "is_bug": false
    },
    {
        "name": "be_map.be_map_next#331",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.be_map_next(bmap *map, bmapiter *iter)",
        "snippet": "bmapnode* be_map_next(bmap *map, bmapiter *iter)\n{\n    bmapnode *end = map->slots + map->size;\n    *iter = *iter ? *iter + 1 : map->slots;\n    while (*iter < end && isnil(*iter)) {\n        ++(*iter);\n    }\n    return *iter < end ? *iter : NULL;\n}",
        "begin_line": 331,
        "end_line": 339,
        "is_bug": false
    },
    {
        "name": "be_map.be_map_val2node#341",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.be_map_val2node(bvalue *value)",
        "snippet": "bmapnode* be_map_val2node(bvalue *value)\n{\n    return (bmapnode *)((size_t)value - sizeof(bmapkey));\n}",
        "begin_line": 341,
        "end_line": 344,
        "is_bug": false
    },
    {
        "name": "be_map.be_map_release#346",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.be_map_release(bvm *vm, bmap *map)",
        "snippet": "void be_map_release(bvm *vm, bmap *map)\n{\n    (void)vm;\n    resize(vm, map, map->count ? map->count : 1);\n}",
        "begin_line": 346,
        "end_line": 350,
        "is_bug": false
    },
    {
        "name": "be_libs.be_loadlibs#18",
        "src_path": "src/be_libs.c",
        "class_name": "be_libs",
        "signature": "be_libs.be_loadlibs(bvm *vm)",
        "snippet": "void be_loadlibs(bvm *vm)\n{\n    be_load_baselib(vm);\n#if !BE_USE_PRECOMPILED_OBJECT\n    be_load_listlib(vm);\n    be_load_maplib(vm);\n    be_load_rangelib(vm);\n    be_load_filelib(vm);\n    be_load_byteslib(vm);\n    be_load_baselib_call(vm);\n#endif\n}",
        "begin_line": 18,
        "end_line": 29,
        "is_bug": false
    },
    {
        "name": "be_vector.be_vector_init#15",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.be_vector_init(bvm *vm, bvector *vector, int size)",
        "snippet": "void be_vector_init(bvm *vm, bvector *vector, int size)\n{\n    vector->capacity = 2; /* the default capacity */\n    vector->size = size;\n    vector->count = 0;\n    vector->data = be_malloc(vm, (size_t)vector->capacity * size);\n    vector->end = (char*)vector->data - size;\n    memset(vector->data, 0, (size_t)vector->capacity * size);\n}",
        "begin_line": 15,
        "end_line": 23,
        "is_bug": false
    },
    {
        "name": "be_vector.be_vector_delete#25",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.be_vector_delete(bvm *vm, bvector *vector)",
        "snippet": "void be_vector_delete(bvm *vm, bvector *vector)\n{\n    be_free(vm, vector->data, (size_t)vector->capacity * vector->size);\n}",
        "begin_line": 25,
        "end_line": 28,
        "is_bug": false
    },
    {
        "name": "be_vector.be_vector_at#30",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.be_vector_at(bvector *vector, int index)",
        "snippet": "void* be_vector_at(bvector *vector, int index)\n{\n    return (char*)vector->data + (size_t)index * vector->size;\n}",
        "begin_line": 30,
        "end_line": 33,
        "is_bug": false
    },
    {
        "name": "be_vector.be_vector_push#35",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.be_vector_push(bvm *vm, bvector *vector, void *data)",
        "snippet": "void be_vector_push(bvm *vm, bvector *vector, void *data)\n{\n    size_t size = vector->size;\n    size_t capacity = vector->capacity;\n    size_t count = vector->count++;\n    if (count >= capacity) {\n        int newcap = be_nextsize(vector->capacity);\n        vector->data = be_realloc(vm,\n                vector->data, vector->capacity * size, newcap * size);\n        vector->end = (char*)vector->data + count * size;\n        vector->capacity = newcap;\n    } else {\n        vector->end = (char*)vector->end + size;\n    }\n    if (data != NULL) {\n        memcpy(vector->end, data, size);\n    }\n}",
        "begin_line": 35,
        "end_line": 52,
        "is_bug": false
    },
    {
        "name": "be_vector.be_vector_push_c#55",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.be_vector_push_c(bvm *vm, bvector *vector, void *data)",
        "snippet": "void be_vector_push_c(bvm *vm, bvector *vector, void *data)\n{\n    int capacity = vector->capacity + 1;\n    be_vector_push(vm, vector, data);\n    if (vector->capacity > capacity) {\n        size_t size = ((size_t)vector->capacity - capacity) * vector->size;\n        memset(be_vector_at(vector, capacity), 0, size);\n    }\n}",
        "begin_line": 55,
        "end_line": 63,
        "is_bug": false
    },
    {
        "name": "be_vector.be_vector_remove_end#65",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.be_vector_remove_end(bvector *vector)",
        "snippet": "void be_vector_remove_end(bvector *vector)\n{\n    be_assert(vector->count > 0);\n    vector->count--;\n    vector->end = (char*)vector->end - vector->size;\n}",
        "begin_line": 65,
        "end_line": 70,
        "is_bug": false
    },
    {
        "name": "be_vector.be_vector_resize#72",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.be_vector_resize(bvm *vm, bvector *vector, int count)",
        "snippet": "void be_vector_resize(bvm *vm, bvector *vector, int count)\n{\n    size_t size = vector->size;\n    be_assert(count >= 0);\n    if (count != be_vector_count(vector)) {\n        int newcap = be_nextsize(count);\n        if (newcap > vector->capacity) { /* extended capacity */\n            vector->data = be_realloc(vm,\n                vector->data, vector->capacity * size, newcap * size);\n            vector->capacity = newcap;\n        }\n        vector->count = count;\n        vector->end = (char*)vector->data + size * ((size_t)count - 1);\n    }\n}",
        "begin_line": 72,
        "end_line": 86,
        "is_bug": false
    },
    {
        "name": "be_vector.be_vector_clear#88",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.be_vector_clear(bvector *vector)",
        "snippet": "void be_vector_clear(bvector *vector)\n{\n    vector->count = 0;\n    vector->end = (char*)vector->data - vector->size;\n}",
        "begin_line": 88,
        "end_line": 92,
        "is_bug": false
    },
    {
        "name": "be_vector.be_vector_release#95",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.be_vector_release(bvm *vm, bvector *vector)",
        "snippet": "void* be_vector_release(bvm *vm, bvector *vector)\n{\n    size_t size = vector->size;\n    int count = be_vector_count(vector);\n    if (count == 0) {\n        be_free(vm, vector->data, vector->capacity * size);\n        vector->capacity = 0;\n        vector->data = NULL;\n        vector->end = NULL;\n    } else if (count < vector->capacity) {\n        vector->data = be_realloc(vm,\n            vector->data, vector->capacity * size, count * size);\n        vector->end = (char*)vector->data + ((size_t)count - 1) * size;\n        vector->capacity = count;\n    }\n    return vector->data;\n}",
        "begin_line": 95,
        "end_line": 111,
        "is_bug": false
    },
    {
        "name": "be_vector.binary_search#114",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.binary_search(int value)",
        "snippet": "static int binary_search(int value)\n{\n    static const uint16_t tab[] = {\n        0, 2, 4, 6, 8, 10, 12, 14, 16,\n        20, 24, 28, 32, 40, 48, 64, 96, 128,\n        192, 256, 384, 512, 768, 1024\n    };\n    const uint16_t *low = tab;\n    const uint16_t *high = tab + array_count(tab) - 1;\n    while (low <= high) {\n        const uint16_t *mid = low + ((high - low) >> 1);\n        if (*mid == value) {\n            return mid[1];\n        }\n        if (*mid < value) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return *low;\n}",
        "begin_line": 114,
        "end_line": 135,
        "is_bug": false
    },
    {
        "name": "be_vector.be_nextsize#147",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.be_nextsize(int size)",
        "snippet": "int be_nextsize(int size)\n{\n    if (size < 1024) {\n        return binary_search(size);\n    }\n    return nextpow(size);\n}",
        "begin_line": 147,
        "end_line": 153,
        "is_bug": false
    },
    {
        "name": "be_module.pathlist#380",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.pathlist(bvm *vm)",
        "snippet": "static blist* pathlist(bvm *vm)\n{\n    if (!vm->module.path) {\n        vm->module.path = be_list_new(vm);\n    }\n    return vm->module.path;\n}",
        "begin_line": 380,
        "end_line": 386,
        "is_bug": false
    },
    {
        "name": "be_module.be_module_path_set#396",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.be_module_path_set(bvm *vm, const char *path)",
        "snippet": "BERRY_API void be_module_path_set(bvm *vm, const char *path)\n{\n    blist *list = pathlist(vm);\n    bvalue *value = be_list_push(vm, list, NULL);\n    var_setnil(value);\n    var_setstr(value, be_newstr(vm, path))\n}",
        "begin_line": 396,
        "end_line": 402,
        "is_bug": false
    },
    {
        "name": "be_var.be_globalvar_init#18",
        "src_path": "src/be_var.c",
        "class_name": "be_var",
        "signature": "be_var.be_globalvar_init(bvm *vm)",
        "snippet": "void be_globalvar_init(bvm *vm)\n{\n    global(vm).vtab = be_map_new(vm);\n    be_gc_fix(vm, gc_object(global(vm).vtab));\n    be_vector_init(vm, &global(vm).vlist, sizeof(bvalue));\n#if !BE_USE_PRECOMPILED_OBJECT\n    builtin(vm).vtab = be_map_new(vm);\n    be_vector_init(vm, &builtin(vm).vlist, sizeof(bvalue));\n    be_gc_fix(vm, gc_object(builtin(vm).vtab));\n#endif\n}",
        "begin_line": 18,
        "end_line": 28,
        "is_bug": false
    },
    {
        "name": "be_var.be_globalvar_deinit#30",
        "src_path": "src/be_var.c",
        "class_name": "be_var",
        "signature": "be_var.be_globalvar_deinit(bvm *vm)",
        "snippet": "void be_globalvar_deinit(bvm *vm)\n{\n    global(vm).vtab = NULL;\n    be_vector_delete(vm, &global(vm).vlist);\n#if !BE_USE_PRECOMPILED_OBJECT\n    builtin(vm).vtab = NULL;\n    be_vector_delete(vm, &builtin(vm).vlist);\n#endif\n}",
        "begin_line": 30,
        "end_line": 38,
        "is_bug": false
    },
    {
        "name": "be_var.global_find#40",
        "src_path": "src/be_var.c",
        "class_name": "be_var",
        "signature": "be_var.global_find(bvm *vm, bstring *name)",
        "snippet": "static int global_find(bvm *vm, bstring *name)\n{\n    bvalue *res = be_map_findstr(vm, global(vm).vtab, name);\n    if (res) {\n        return var_toidx(res) + be_builtin_count(vm);\n    }\n    return -1; /* not found */\n}",
        "begin_line": 40,
        "end_line": 47,
        "is_bug": false
    },
    {
        "name": "be_var.be_global_find#49",
        "src_path": "src/be_var.c",
        "class_name": "be_var",
        "signature": "be_var.be_global_find(bvm *vm, bstring *name)",
        "snippet": "int be_global_find(bvm *vm, bstring *name)\n{\n    int res = global_find(vm, name);\n    return res != -1 ? res : be_builtin_find(vm, name);\n}",
        "begin_line": 49,
        "end_line": 53,
        "is_bug": false
    },
    {
        "name": "be_var.global_new_anonymous#55",
        "src_path": "src/be_var.c",
        "class_name": "be_var",
        "signature": "be_var.global_new_anonymous(bvm *vm)",
        "snippet": "static int global_new_anonymous(bvm *vm)\n{\n    int idx = be_global_count(vm);\n    /* allocate space for new variables */\n    be_vector_resize(vm, &global(vm).vlist, idx + 1);\n    /* set the new variable to nil */\n    var_setnil((bvalue *)global(vm).vlist.end);\n    return idx;\n}",
        "begin_line": 55,
        "end_line": 63,
        "is_bug": false
    },
    {
        "name": "be_var.be_global_new#65",
        "src_path": "src/be_var.c",
        "class_name": "be_var",
        "signature": "be_var.be_global_new(bvm *vm, bstring *name)",
        "snippet": "int be_global_new(bvm *vm, bstring *name)\n{\n    int idx = global_find(vm, name);\n    if (idx == -1) {\n        bvalue *desc;\n        idx = global_new_anonymous(vm);\n        desc = be_map_insertstr(vm, global(vm).vtab, name, NULL);\n        var_setint(desc, idx);\n        idx += be_builtin_count(vm);\n    }\n    return idx;\n}",
        "begin_line": 65,
        "end_line": 76,
        "is_bug": false
    },
    {
        "name": "be_var.be_global_var#78",
        "src_path": "src/be_var.c",
        "class_name": "be_var",
        "signature": "be_var.be_global_var(bvm *vm, int index)",
        "snippet": "bvalue* be_global_var(bvm *vm, int index)\n{\n    int bcnt = be_builtin_count(vm);\n    if (index < bcnt) {\n        return be_vector_at(&builtin(vm).vlist, index);\n    }\n    index -= bcnt;\n    return be_vector_at(&global(vm).vlist, index);\n}",
        "begin_line": 78,
        "end_line": 86,
        "is_bug": false
    },
    {
        "name": "be_var.be_global_release_space#88",
        "src_path": "src/be_var.c",
        "class_name": "be_var",
        "signature": "be_var.be_global_release_space(bvm *vm)",
        "snippet": "void be_global_release_space(bvm *vm)\n{\n    be_map_release(vm, global(vm).vtab);\n    be_vector_release(vm, &global(vm).vlist);\n}",
        "begin_line": 88,
        "end_line": 92,
        "is_bug": false
    },
    {
        "name": "be_var.be_builtin_find#94",
        "src_path": "src/be_var.c",
        "class_name": "be_var",
        "signature": "be_var.be_builtin_find(bvm *vm, bstring *name)",
        "snippet": "int be_builtin_find(bvm *vm, bstring *name)\n{\n    bvalue *res = be_map_findstr(vm, builtin(vm).vtab, name);\n    if (res) {\n        return var_toidx(res);\n    }\n    return -1; /* not found */\n}",
        "begin_line": 94,
        "end_line": 101,
        "is_bug": false
    },
    {
        "name": "be_string.be_eqstr#41",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.be_eqstr(bstring *s1, bstring *s2)",
        "snippet": "int be_eqstr(bstring *s1, bstring *s2)\n{\n    int slen;\n    if (s1 == s2) { /* short string or the same string */\n        return 1;\n    }\n    slen = s1->slen;\n    /* discard different lengths */\n    if (slen != s2->slen) {\n        return 0;\n    }\n    /* long string */\n    if (slen == 255) {  /* s2->slen is also 255 */\n        blstring *ls1 = cast(blstring*, s1);\n        blstring *ls2 = cast(blstring*, s2);\n        return ls1->llen == ls2->llen && !strcmp(lstr(ls1), lstr(ls2));\n    }\n    /* const short strings */\n    if (gc_isconst(s1) || gc_isconst(s2)) { /* one of the two string is short const */\n        if (cast(bcstring*, s1)->hash && cast(bcstring*, s2)->hash) {\n            return 0; /* if they both have a hash, then we know they are different */\n        }\n        return !strcmp(str(s1), str(s2));\n    }\n\n    return 0;\n}",
        "begin_line": 41,
        "end_line": 67,
        "is_bug": false
    },
    {
        "name": "be_string.resize#69",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.resize(bvm *vm, int size)",
        "snippet": "static void resize(bvm *vm, int size)\n{\n    int i;\n    struct bstringtable *tab = &vm->strtab;\n    if (size > tab->size) {\n        tab->table = be_realloc(vm, tab->table,\n            tab->size * sizeof(bstring*), size * sizeof(bstring*));\n        for (i = tab->size; i < size; ++i) {\n            tab->table[i] = NULL;\n        }\n    }\n    for (i = 0; i < tab->size; ++i) { /* rehash */\n        bstring *p = tab->table[i];\n        tab->table[i] = NULL;\n        while (p) { /* for each node in the list */\n            bstring *hnext = next(p);\n            uint32_t hash = be_strhash(p) & (size - 1);\n            p->next = cast(void*, tab->table[hash]);\n            tab->table[hash] = p;\n            p = hnext;\n        }\n    }\n    if (size < tab->size) {\n        for (i = size; i < tab->size; ++i) {\n            tab->table[i] = NULL;\n        }\n        tab->table = be_realloc(vm, tab->table,\n            tab->size * sizeof(bstring*), size * sizeof(bstring*));\n    }\n    tab->size = size;\n}",
        "begin_line": 69,
        "end_line": 99,
        "is_bug": false
    },
    {
        "name": "be_string.free_sstring#101",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.free_sstring(bvm *vm, bstring *str)",
        "snippet": "static void free_sstring(bvm *vm, bstring *str)\n{\n    be_free(vm, str, sizeof(bsstring) + str->slen + 1);\n}",
        "begin_line": 101,
        "end_line": 104,
        "is_bug": false
    },
    {
        "name": "be_string.str_hash#107",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.str_hash(const char *str, size_t len)",
        "snippet": "static uint32_t str_hash(const char *str, size_t len)\n{\n    uint32_t hash = 2166136261u;\n    be_assert(str || len);\n    while (len--) {\n        hash = (hash ^ (unsigned char)*str++) * 16777619u;\n    }\n    return hash;\n}",
        "begin_line": 107,
        "end_line": 115,
        "is_bug": false
    },
    {
        "name": "be_string.be_string_init#117",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.be_string_init(bvm *vm)",
        "snippet": "void be_string_init(bvm *vm)\n{\n    resize(vm, 8);\n#if !BE_USE_PRECOMPILED_OBJECT\n    /* the destructor name deinit needs to exist all the time, to ensure\n     * that it does not need to be created when the heap is exhausted. */\n    be_gc_fix(vm, cast(bgcobject*, str_literal(vm, \"deinit\")));\n#endif\n    /* be_const_str_deinit --> for precompiled */\n}",
        "begin_line": 117,
        "end_line": 126,
        "is_bug": false
    },
    {
        "name": "be_string.be_string_deleteall#128",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.be_string_deleteall(bvm *vm)",
        "snippet": "void be_string_deleteall(bvm *vm)\n{\n    int i;\n    struct bstringtable *tab = &vm->strtab;\n    for (i = 0; i < tab->size; ++i) {\n        bstring *node = tab->table[i];\n        while (node) {\n            bstring *next = next(node);\n            free_sstring(vm, node);\n            node = next;\n        }\n    }\n    be_free(vm, tab->table, tab->size * sizeof(bstring*));\n}",
        "begin_line": 128,
        "end_line": 141,
        "is_bug": false
    },
    {
        "name": "be_string.createstrobj#143",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.createstrobj(bvm *vm, size_t len, int islong)",
        "snippet": "static bstring* createstrobj(bvm *vm, size_t len, int islong)\n{\n    size_t size = (islong ? sizeof(blstring)\n                : sizeof(bsstring)) + len + 1;\n    bgcobject *gco = be_gc_newstr(vm, size, islong);\n    bstring *s = cast_str(gco);\n    if (s) {\n        s->slen = islong ? 255 : (bbyte)len;\n        char *str = cast(char *, islong ? lstr(s) : sstr(s));\n        str[len] = '\\0';\n    }\n    return s;\n}",
        "begin_line": 143,
        "end_line": 155,
        "is_bug": false
    },
    {
        "name": "be_string.newshortstr#172",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.newshortstr(bvm *vm, const char *str, size_t len)",
        "snippet": "static bstring* newshortstr(bvm *vm, const char *str, size_t len)\n{\n    bstring *s;\n    int size = vm->strtab.size;\n    uint32_t hash = str_hash(str, len);\n    bstring **list = vm->strtab.table + (hash & (size - 1));\n\n    for (s = *list; s != NULL; s = next(s)) {\n        if (len == s->slen && !strncmp(str, sstr(s), len)) {\n            return s;\n        }\n    }\n    s = createstrobj(vm, len, 0);\n    if (s) {\n        memcpy(cast(char *, sstr(s)), str, len);\n        s->extra = 0;\n        s->next = cast(void*, *list);\n#if BE_USE_STR_HASH_CACHE\n        cast(bsstring*, s)->hash = hash;\n#endif\n        *list = s;\n        vm->strtab.count++;\n        if (vm->strtab.count > size << 2) {\n            resize(vm, size << 1);\n        }\n    }\n    return s;\n}",
        "begin_line": 172,
        "end_line": 199,
        "is_bug": false
    },
    {
        "name": "be_string.be_newstr#215",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.be_newstr(bvm *vm, const char *str)",
        "snippet": "bstring* be_newstr(bvm *vm, const char *str)\n{\n    return be_newstrn(vm, str, strlen(str));\n}",
        "begin_line": 215,
        "end_line": 218,
        "is_bug": false
    },
    {
        "name": "be_string.be_newstrn#220",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.be_newstrn(bvm *vm, const char *str, size_t len)",
        "snippet": "bstring *be_newstrn(bvm *vm, const char *str, size_t len)\n{\n    if (len <= SHORT_STR_MAX_LEN) {\n#if BE_USE_PRECOMPILED_OBJECT\n        bstring *s = find_conststr(str, len);\n        return s ? s : newshortstr(vm, str, len);\n#else\n        return newshortstr(vm, str, len);\n#endif\n    }\n    return be_newlongstr(vm, str, len); /* long string */\n}",
        "begin_line": 220,
        "end_line": 231,
        "is_bug": false
    },
    {
        "name": "be_string.be_gcstrtab#233",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.be_gcstrtab(bvm *vm)",
        "snippet": "void be_gcstrtab(bvm *vm)\n{\n    struct bstringtable *tab = &vm->strtab;\n    int size = tab->size, i;\n    for (i = 0; i < size; ++i) {\n        bstring **list = tab->table + i;\n        bstring *prev = NULL, *node, *next;\n        for (node = *list; node; node = next) {\n            next = next(node);\n            if (!gc_isfixed(node) && gc_iswhite(node)) {\n                free_sstring(vm, node);\n                tab->count--;\n                if (prev) { /* link list */\n                    prev->next = cast(void*, next);\n                } else {\n                    *list = next;\n                }\n            } else {\n                prev = node;\n                gc_setwhite(node);\n            }\n        }\n    }\n    if (tab->count < size >> 2 && size > 8) {\n        resize(vm, size >> 1);\n    }\n}",
        "begin_line": 233,
        "end_line": 259,
        "is_bug": false
    },
    {
        "name": "be_string.be_strhash#261",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.be_strhash(const bstring *s)",
        "snippet": "uint32_t be_strhash(const bstring *s)\n{\n    if (gc_isconst(s)) {\n        bcstring* cs = cast(bcstring*, s);\n        if (cs->hash) {  /* if hash is null we need to compute it */\n            return cs->hash;\n        } else {\n            return str_hash(cstr(s), str_len(s));\n        }\n    }\n#if BE_USE_STR_HASH_CACHE\n    if (s->slen != 255) {\n        return cast(bsstring*, s)->hash;\n    }\n#endif\n    return str_hash(str(s), str_len(s));\n}",
        "begin_line": 261,
        "end_line": 277,
        "is_bug": false
    },
    {
        "name": "be_string.be_str2cstr#279",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.be_str2cstr(const bstring *s)",
        "snippet": "const char* be_str2cstr(const bstring *s)\n{\n    be_assert(cast_str(s) != NULL);\n    if (gc_isconst(s)) {\n        return cstr(s);\n    }\n    if (s->slen == 255) {\n        return lstr(s);\n    }\n    return sstr(s);\n}",
        "begin_line": 279,
        "end_line": 289,
        "is_bug": false
    },
    {
        "name": "be_string.be_str_setextra#291",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.be_str_setextra(bstring *s, int extra)",
        "snippet": "void be_str_setextra(bstring *s, int extra)\n{\n    if (!gc_isconst(s)) {\n        s->extra = cast(bbyte, extra);\n    }\n}",
        "begin_line": 291,
        "end_line": 296,
        "is_bug": false
    },
    {
        "name": "be_debug.sourceinfo#167",
        "src_path": "src/be_debug.c",
        "class_name": "be_debug",
        "signature": "be_debug.sourceinfo(bproto *proto, binstruction *ip)",
        "snippet": "static void sourceinfo(bproto *proto, binstruction *ip)\n{\n#if BE_DEBUG_RUNTIME_INFO\n    char buf[24];\n    be_assert(proto != NULL);\n    if (proto->lineinfo && proto->nlineinfo) {\n        blineinfo *it = proto->lineinfo;\n        blineinfo *end = it + proto->nlineinfo;\n        int pc = cast_int(ip - proto->code - 1); /* now vm->ip has been increased */\n        for (; it < end && pc > it->endpc; ++it);\n        sprintf(buf, \":%d:\", it->linenumber);\n        be_writestring(str(proto->source));\n        be_writestring(buf);\n    } else {\n        be_writestring(\"<unknow source>:\");\n    }\n#else\n    (void)proto; (void)ip;\n    be_writestring(\"<unknow source>:\");\n#endif\n}",
        "begin_line": 167,
        "end_line": 187,
        "is_bug": false
    },
    {
        "name": "be_debug.tracestack#189",
        "src_path": "src/be_debug.c",
        "class_name": "be_debug",
        "signature": "be_debug.tracestack(bvm *vm)",
        "snippet": "static void tracestack(bvm *vm)\n{\n    bcallsnapshot *cf;\n    bcallsnapshot *base = be_stack_base(&vm->tracestack);\n    bcallsnapshot *top = be_stack_top(&vm->tracestack);\n    be_writestring(\"stack traceback:\\n\");\n    for (cf = top; cf >= base; --cf) {\n        if (cf <= top - 10 && cf >= base + 10) {\n            if (cf == top - 10)\n                be_writestring(\"\\t...\\n\");\n            continue;\n        }\n        if (var_isclosure(&cf->func)) {\n            bclosure *cl = var_toobj(&cf->func);\n            be_writestring(\"\\t\");\n            sourceinfo(cl->proto, cf->ip);\n            be_writestring(\" in function `\");\n            be_writestring(str(cl->proto->name));\n            be_writestring(\"`\\n\");\n        } else {\n            be_writestring(\"\\t<native>: in native function\\n\");\n        }\n    }\n}",
        "begin_line": 189,
        "end_line": 212,
        "is_bug": false
    },
    {
        "name": "be_debug.repair_stack#214",
        "src_path": "src/be_debug.c",
        "class_name": "be_debug",
        "signature": "be_debug.repair_stack(bvm *vm)",
        "snippet": "static void repair_stack(bvm *vm)\n{\n    bcallsnapshot *cf;\n    bcallsnapshot *base = be_stack_base(&vm->tracestack);\n    bcallsnapshot *top = be_stack_top(&vm->tracestack);\n    /* Because the native function does not push `ip` to the\n     * stack, the ip on the native function frame corresponds\n     * to the previous Berry closure. */\n    for (cf = top; cf >= base; --cf) {\n        if (!var_isclosure(&cf->func)) {\n            /* the last native function stack frame has the `ip` of\n             * the previous Berry frame */\n            binstruction *ip = cf->ip;\n            /* skip native function stack frames */\n            for (; cf >= base && !var_isclosure(&cf->func); --cf);\n            /* fixed `ip` of Berry closure frame near native function frame */\n            if (cf >= base) cf->ip = ip;\n        }\n    }\n}",
        "begin_line": 214,
        "end_line": 233,
        "is_bug": false
    },
    {
        "name": "be_debug.be_tracestack#235",
        "src_path": "src/be_debug.c",
        "class_name": "be_debug",
        "signature": "be_debug.be_tracestack(bvm *vm)",
        "snippet": "void be_tracestack(bvm *vm)\n{\n    if (be_stack_count(&vm->tracestack)) {\n        repair_stack(vm);\n        tracestack(vm);\n    }\n}",
        "begin_line": 235,
        "end_line": 241,
        "is_bug": false
    },
    {
        "name": "be_strlib.be_str2int#237",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.be_str2int(const char *str, const char **endstr)",
        "snippet": "BERRY_API bint be_str2int(const char *str, const char **endstr)\n{\n    int c, sign;\n    bint sum = 0;\n    skip_space(str);\n    sign = c = *str++;\n    if (c == '+' || c == '-') {\n        c = *str++;\n    }\n    while (is_digit(c)) {\n        sum = sum * 10 + c - '0';\n        c = *str++;\n    }\n    if (endstr) {\n        *endstr = str - 1;\n    }\n    return sign == '-' ? -sum : sum;\n}",
        "begin_line": 237,
        "end_line": 254,
        "is_bug": false
    },
    {
        "name": "be_gc.be_gc_init#39",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_gc_init(bvm *vm)",
        "snippet": "void be_gc_init(bvm *vm)\n{\n    vm->gc.usage = sizeof(bvm);\n    be_gc_setsteprate(vm, 200);\n}",
        "begin_line": 39,
        "end_line": 43,
        "is_bug": false
    },
    {
        "name": "be_gc.be_gc_deleteall#45",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_gc_deleteall(bvm *vm)",
        "snippet": "void be_gc_deleteall(bvm *vm)\n{\n    bupval *uv, *uvnext;\n    bgcobject *node, *next;\n    /* halt GC and delete all objects */\n    vm->gc.status |= GC_HALT;\n    /* first: call destructor */\n    for (node = vm->gc.list; node; node = node->next) {\n        destruct_object(vm, node);\n    }\n    /* second: free objects */\n    for (node = vm->gc.list; node; node = next) {\n        next = node->next;\n        free_object(vm, node);\n    }\n    /* delete open upvalue list */\n    for (uv = vm->upvalist; uv; uv = uvnext) {\n        uvnext = uv->u.next;\n        be_free(vm, uv, sizeof(bupval));\n    }\n}",
        "begin_line": 45,
        "end_line": 65,
        "is_bug": false
    },
    {
        "name": "be_gc.be_gc_setsteprate#67",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_gc_setsteprate(bvm *vm, int rate)",
        "snippet": "void be_gc_setsteprate(bvm *vm, int rate)\n{\n    be_assert(rate >= 100 && rate <= 355);\n    vm->gc.steprate = (bbyte)(rate - 100);\n    vm->gc.threshold = next_threshold(vm->gc);\n}",
        "begin_line": 67,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "be_gc.be_gc_setpause#74",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_gc_setpause(bvm *vm, int pause)",
        "snippet": "void be_gc_setpause(bvm *vm, int pause)\n{\n    if (pause) {\n        vm->gc.status |= GC_PAUSE;\n    } else {\n        vm->gc.status &= ~GC_PAUSE;\n    }\n}",
        "begin_line": 74,
        "end_line": 81,
        "is_bug": false
    },
    {
        "name": "be_gc.be_newgcobj#83",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_newgcobj(bvm *vm, int type, size_t size)",
        "snippet": "bgcobject* be_newgcobj(bvm *vm, int type, size_t size)\n{\n    bgcobject *obj = be_malloc(vm, size);\n    be_gc_auto(vm);\n    var_settype(obj, (bbyte)type); /* mark the object type */\n    obj->marked = GC_WHITE; /* default gc object type is white */\n    obj->next = vm->gc.list; /* link to the next field */\n    vm->gc.list = obj; /* insert to head */\n    return obj;\n}",
        "begin_line": 83,
        "end_line": 92,
        "is_bug": false
    },
    {
        "name": "be_gc.be_gc_newstr#94",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_gc_newstr(bvm *vm, size_t size, int islong)",
        "snippet": "bgcobject* be_gc_newstr(bvm *vm, size_t size, int islong)\n{\n    bgcobject *obj;\n    if (islong) { /* creating long strings is similar to ordinary GC objects */\n        return be_newgcobj(vm, BE_STRING, size);\n    }\n    obj = be_malloc(vm, size);\n    be_gc_auto(vm);\n    var_settype(obj, BE_STRING); /* mark the object type to BE_STRING */\n    obj->marked = GC_WHITE; /* default string type is white */\n    return obj;\n}",
        "begin_line": 94,
        "end_line": 105,
        "is_bug": false
    },
    {
        "name": "be_gc.be_gc_fix#107",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_gc_fix(bvm *vm, bgcobject *obj)",
        "snippet": "void be_gc_fix(bvm *vm, bgcobject *obj)\n{\n    (void)vm;\n    if (!gc_isconst(obj)) {\n        gc_setfixed(obj);\n    }\n}",
        "begin_line": 107,
        "end_line": 113,
        "is_bug": false
    },
    {
        "name": "be_gc.be_gc_unfix#115",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_gc_unfix(bvm *vm, bgcobject *obj)",
        "snippet": "void be_gc_unfix(bvm *vm, bgcobject *obj)\n{\n    (void)vm;\n    if (!gc_isconst(obj)) {\n        gc_clearfixed(obj);\n    }\n}",
        "begin_line": 115,
        "end_line": 121,
        "is_bug": false
    },
    {
        "name": "be_gc.be_gc_fix_set#123",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_gc_fix_set(bvm *vm, bgcobject *obj, bbool fix)",
        "snippet": "bbool be_gc_fix_set(bvm *vm, bgcobject *obj, bbool fix)\n{\n    (void)vm;\n    bbool was_fixed = gc_isfixed(obj);\n    if (!gc_isconst(obj)) {\n        if (fix) {\n            gc_setfixed(obj);\n        } else {\n            gc_clearfixed(obj);\n        }\n    }\n    return was_fixed;\n}",
        "begin_line": 123,
        "end_line": 135,
        "is_bug": false
    },
    {
        "name": "be_gc.mark_gray#137",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.mark_gray(bvm *vm, bgcobject *obj)",
        "snippet": "static void mark_gray(bvm *vm, bgcobject *obj)\n{\n    if (obj && gc_iswhite(obj) && !gc_isconst(obj)) {\n        gc_setgray(obj);\n        switch (var_type(obj)) {\n        case BE_STRING: gc_setdark(obj); break; /* just set dark */\n        case BE_CLASS: link_gray(vm, cast_class(obj)); break;\n        case BE_PROTO: link_gray(vm, cast_proto(obj)); break;\n        case BE_INSTANCE: link_gray(vm, cast_instance(obj)); break;\n        case BE_MAP: link_gray(vm, cast_map(obj)); break;\n        case BE_LIST: link_gray(vm, cast_list(obj)); break;\n        case BE_CLOSURE: link_gray(vm, cast_closure(obj)); break;\n        case BE_NTVCLOS: link_gray(vm, cast_ntvclos(obj)); break;\n        case BE_MODULE: link_gray(vm, cast_module(obj)); break;\n        case BE_COMOBJ: gc_setdark(obj); break; /* just set dark */\n        default: break;\n        }\n    }\n}",
        "begin_line": 137,
        "end_line": 155,
        "is_bug": false
    },
    {
        "name": "be_gc.mark_gray_var#157",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.mark_gray_var(bvm *vm, bvalue *value)",
        "snippet": "static void mark_gray_var(bvm *vm, bvalue *value)\n{\n    if (be_isgcobj(value)) {\n        mark_gray(vm, var_togc(value));\n    }\n}",
        "begin_line": 157,
        "end_line": 162,
        "is_bug": false
    },
    {
        "name": "be_gc.mark_map#164",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.mark_map(bvm *vm, bgcobject *obj)",
        "snippet": "static void mark_map(bvm *vm, bgcobject *obj)\n{\n    bmap *map = cast_map(obj);\n    gc_try (map != NULL) {\n        bmapnode *node;\n        bmapiter iter = be_map_iter();\n        vm->gc.gray = map->gray; /* remove object from gray list */\n        while ((node = be_map_next(map, &iter)) != NULL) {\n            bmapkey *key = &node->key;\n            bvalue *val = &node->value;\n            if (be_isgctype((signed char)key->type)) {\n                mark_gray(vm, var_togc(key));\n            }\n            mark_gray_var(vm, val);\n        }\n    }\n}",
        "begin_line": 164,
        "end_line": 180,
        "is_bug": false
    },
    {
        "name": "be_gc.free_proto#292",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.free_proto(bvm *vm, bgcobject *obj)",
        "snippet": "static void free_proto(bvm *vm, bgcobject *obj)\n{\n    bproto *proto = cast_proto(obj);\n    gc_try (proto != NULL) {\n        be_free(vm, proto->upvals, proto->nupvals * sizeof(bupvaldesc));\n        be_free(vm, proto->ktab, proto->nconst * sizeof(bvalue));\n        be_free(vm, proto->ptab, proto->nproto * sizeof(bproto*));\n        be_free(vm, proto->code, proto->codesize * sizeof(binstruction));\n#if BE_DEBUG_RUNTIME_INFO\n        be_free(vm, proto->lineinfo, proto->nlineinfo * sizeof(blineinfo));\n#endif\n#if BE_DEBUG_VAR_INFO\n        be_free(vm, proto->varinfo, proto->nvarinfo * sizeof(bvarinfo));\n#endif\n        be_free(vm, proto, sizeof(bproto));\n    }\n}",
        "begin_line": 292,
        "end_line": 308,
        "is_bug": false
    },
    {
        "name": "be_gc.free_closure#310",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.free_closure(bvm *vm, bgcobject *obj)",
        "snippet": "static void free_closure(bvm *vm, bgcobject *obj)\n{\n    bclosure *cl = cast_closure(obj);\n    gc_try (cl != NULL) {\n        int count = cl->nupvals;\n        be_release_upvalues(vm, cl);\n        be_free(vm, cl, sizeof(bclosure)\n            + sizeof(bupval*) * ((size_t)count - 1));\n    }\n}",
        "begin_line": 310,
        "end_line": 319,
        "is_bug": false
    },
    {
        "name": "be_gc.free_instance#342",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.free_instance(bvm *vm, bgcobject *obj)",
        "snippet": "static void free_instance(bvm *vm, bgcobject *obj)\n{\n    binstance *o = cast_instance(obj);\n    int nvar = be_instance_member_count(o);\n    be_free(vm, obj, sizeof(binstance) + sizeof(bvalue) * (nvar - 1));\n}",
        "begin_line": 342,
        "end_line": 347,
        "is_bug": false
    },
    {
        "name": "be_gc.free_object#349",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.free_object(bvm *vm, bgcobject *obj)",
        "snippet": "static void free_object(bvm *vm, bgcobject *obj)\n{\n    switch (obj->type) {\n    case BE_STRING: free_lstring(vm, obj); break; /* long string */\n    case BE_CLASS: be_free(vm, obj, sizeof(bclass)); break;\n    case BE_INSTANCE: free_instance(vm, obj); break;\n    case BE_MAP: be_map_delete(vm, cast_map(obj)); break;\n    case BE_LIST: be_list_delete(vm, cast_list(obj)); break;\n    case BE_CLOSURE: free_closure(vm, obj); break;\n    case BE_NTVCLOS: free_ntvclos(vm, obj); break;\n    case BE_PROTO: free_proto(vm, obj); break;\n    case BE_MODULE: be_module_delete(vm, cast_module(obj)); break;\n    case BE_COMOBJ: be_commonobj_delete(vm, obj); break;\n    default: break; /* case BE_STRING: break; */\n    }\n}",
        "begin_line": 349,
        "end_line": 364,
        "is_bug": false
    },
    {
        "name": "be_gc.premark_internal#366",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.premark_internal(bvm *vm)",
        "snippet": "static void premark_internal(bvm *vm)\n{\n    mark_gray(vm, gc_object(vm->module.loaded));\n    mark_gray(vm, gc_object(vm->module.path));\n    mark_gray(vm, gc_object(vm->ntvclass));\n    mark_gray(vm, gc_object(vm->registry));\n#if BE_USE_DEBUG_HOOK\n    if (be_isgcobj(&vm->hook)) {\n        mark_gray(vm, gc_object(var_toobj(&vm->hook)));\n    }\n#endif\n}",
        "begin_line": 366,
        "end_line": 377,
        "is_bug": false
    },
    {
        "name": "be_gc.premark_global#379",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.premark_global(bvm *vm)",
        "snippet": "static void premark_global(bvm *vm)\n{\n    bvalue *v = vm->gbldesc.global.vlist.data;\n    bvalue *end = v + be_global_count(vm);\n    while (v < end) {\n        if (be_isgcobj(v)) {\n            mark_gray(vm, var_togc(v));\n        }\n        ++v;\n    }\n    v = vm->gbldesc.builtin.vlist.data;\n    end = v + be_builtin_count(vm);\n    while (v < end) {\n        mark_gray_var(vm, v++);\n    }\n}",
        "begin_line": 379,
        "end_line": 394,
        "is_bug": false
    },
    {
        "name": "be_gc.premark_stack#396",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.premark_stack(bvm *vm)",
        "snippet": "static void premark_stack(bvm *vm)\n{\n    bvalue *v = vm->stack, *end = vm->top;\n    /* mark live objects */\n    for (; v < end; ++v) {\n        mark_gray_var(vm, v);\n    }\n    /* set other values to nil */\n    end = vm->stacktop;\n    for (; v < end; ++v) {\n        var_setnil(v);\n    }\n}",
        "begin_line": 396,
        "end_line": 408,
        "is_bug": false
    },
    {
        "name": "be_gc.premark_tracestack#410",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.premark_tracestack(bvm *vm)",
        "snippet": "static void premark_tracestack(bvm *vm)\n{\n    bcallsnapshot *cf = be_vector_data(&vm->tracestack);\n    bcallsnapshot *end = be_vector_end(&vm->tracestack);\n    for (; cf <= end; ++cf) {\n        mark_gray_var(vm, &cf->func);\n    }\n}",
        "begin_line": 410,
        "end_line": 417,
        "is_bug": false
    },
    {
        "name": "be_gc.premark_fixed#419",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.premark_fixed(bvm *vm)",
        "snippet": "static void premark_fixed(bvm *vm)\n{\n    bgcobject *node = vm->gc.list;\n    for (; node; node = node->next) {\n        if (gc_isfixed(node) && gc_iswhite(node)) {\n            mark_gray(vm, node);\n        }\n    }\n}",
        "begin_line": 419,
        "end_line": 427,
        "is_bug": false
    },
    {
        "name": "be_gc.mark_unscanned#429",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.mark_unscanned(bvm *vm)",
        "snippet": "static void mark_unscanned(bvm *vm)\n{\n    while (vm->gc.gray) {\n        bgcobject *obj = vm->gc.gray;\n        if (obj && !gc_isdark(obj) && !gc_isconst(obj)) {\n            gc_setdark(obj);\n            switch (var_type(obj)) {\n            case BE_CLASS: mark_class(vm, obj); break;\n            case BE_PROTO: mark_proto(vm, obj); break;\n            case BE_INSTANCE: mark_instance(vm, obj); break;\n            case BE_MAP: mark_map(vm, obj); break;\n            case BE_LIST: mark_list(vm, obj); break;\n            case BE_CLOSURE: mark_closure(vm, obj); break;\n            case BE_NTVCLOS: mark_ntvclos(vm, obj); break;\n            case BE_MODULE: mark_module(vm, obj); break;\n            default:\n                be_assert(0); /* error */\n                break;\n            }\n        }\n    }\n}",
        "begin_line": 429,
        "end_line": 450,
        "is_bug": false
    },
    {
        "name": "be_gc.destruct_object#452",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.destruct_object(bvm *vm, bgcobject *obj)",
        "snippet": "static void destruct_object(bvm *vm, bgcobject *obj)\n{\n    if (vm->gc.status & GC_ALLOC) {\n        return; /* no destructor is called during the allocation. */\n    }\n    if (obj->type == BE_INSTANCE) {\n        int type;\n        binstance *ins = cast_instance(obj);\n        /* does not GC when creating the string \"deinit\". */\n        type = be_instance_member_simple(vm, ins, str_literal(vm, \"deinit\"), vm->top);\n        be_incrtop(vm);\n        if (basetype(type) == BE_FUNCTION) {\n            var_setinstance(vm->top, ins);  /* push instance on stack as arg 1 */\n            be_incrtop(vm);\n            be_dofunc(vm, vm->top - 2, 1);  /* warning, there shoudln't be any exception raised here, or the gc stops */\n            be_stackpop(vm, 1);\n        }\n        be_stackpop(vm, 1);\n    }\n}",
        "begin_line": 452,
        "end_line": 471,
        "is_bug": false
    },
    {
        "name": "be_gc.destruct_white#473",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.destruct_white(bvm *vm)",
        "snippet": "static void destruct_white(bvm *vm)\n{\n    bgcobject *node = vm->gc.list;\n    /* since the destructor may allocate objects, we must first suspend the GC */\n    vm->gc.status |= GC_HALT; /* mark GC is halt */\n    while (node) {\n        if (gc_iswhite(node)) {\n            destruct_object(vm, node);\n        }\n        node = node->next;\n    }\n    vm->gc.status &= ~GC_HALT; /* reset GC halt flag */\n}",
        "begin_line": 473,
        "end_line": 485,
        "is_bug": false
    },
    {
        "name": "be_gc.delete_white#487",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.delete_white(bvm *vm)",
        "snippet": "static void delete_white(bvm *vm)\n{\n    bgcobject *node, *prev, *next;\n    for (node = vm->gc.list, prev = node; node; node = next) {\n        next = node->next;\n        if (gc_iswhite(node)) {\n            if (node == vm->gc.list) { /* first node */\n                vm->gc.list = node->next;\n                prev = node->next;\n            } else { /* not first node */\n                prev->next = next;\n            }\n            free_object(vm, node);\n        } else {\n            gc_setwhite(node);\n            prev = node;\n        }\n    }\n}",
        "begin_line": 487,
        "end_line": 505,
        "is_bug": false
    },
    {
        "name": "be_gc.reset_fixedlist#507",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.reset_fixedlist(bvm *vm)",
        "snippet": "static void reset_fixedlist(bvm *vm)\n{\n    bgcobject *node;\n    for (node = vm->gc.fixed; node; node = node->next) {\n        if (gc_isdark(node)) {\n            gc_setwhite(node);\n        }\n    }\n}",
        "begin_line": 507,
        "end_line": 515,
        "is_bug": false
    },
    {
        "name": "be_gc.be_gc_auto#517",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_gc_auto(bvm *vm)",
        "snippet": "void be_gc_auto(bvm *vm)\n{\n#if BE_USE_DEBUG_GC\n    if (vm->gc.status & GC_PAUSE) { /* force gc each time it's possible */\n        be_gc_collect(vm);\n    }\n#else\n    if (vm->gc.status & GC_PAUSE && vm->gc.usage > vm->gc.threshold) {\n        be_gc_collect(vm);\n    }\n#endif\n}",
        "begin_line": 517,
        "end_line": 528,
        "is_bug": false
    },
    {
        "name": "be_gc.be_gc_collect#535",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_gc_collect(bvm *vm)",
        "snippet": "void be_gc_collect(bvm *vm)\n{\n    if (vm->gc.status & GC_HALT) {\n        return; /* the GC cannot run for some reason */\n    }\n#if BE_USE_OBSERVABILITY_HOOK\n    if (vm->obshook != NULL)\n        (*vm->obshook)(vm, BE_OBS_GC_START, vm->gc.usage);\n#endif\n    /* step 1: set root-set reference objects to unscanned */\n    premark_internal(vm); /* object internal the VM */\n    premark_global(vm); /* global objects */\n    premark_stack(vm); /* stack objects */\n    premark_tracestack(vm); /* trace stack objects */\n    premark_fixed(vm); /* fixed objects */\n    /* step 2: set unscanned objects to black */\n    mark_unscanned(vm);\n    /* step 3: destruct and delete unreachable objects */\n    destruct_white(vm);\n    delete_white(vm);\n    be_gcstrtab(vm);\n    /* step 4: reset the fixed objects */\n    reset_fixedlist(vm);\n    /* step 5: calculate the next GC threshold */\n    vm->gc.threshold = next_threshold(vm->gc);\n#if BE_USE_OBSERVABILITY_HOOK\n    if (vm->obshook != NULL)\n        (*vm->obshook)(vm, BE_OBS_GC_END, vm->gc.usage);\n#endif\n}",
        "begin_line": 535,
        "end_line": 564,
        "is_bug": false
    },
    {
        "name": "be_listlib.m_init#35",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.m_init(bvm *vm)",
        "snippet": "static int m_init(bvm *vm)\n{\n    int i, argc = be_top(vm);\n    if (argc > 1 && be_islist(vm, 2)) {\n        be_pushvalue(vm, 2);\n        be_setmember(vm, 1, \".p\");\n    } else {\n        be_newlist(vm);\n        be_setmember(vm, 1, \".p\");\n        for (i = 2; i <= argc; ++i) {\n            be_pushvalue(vm, i);\n            be_data_push(vm, -2);\n            be_pop(vm, 1);\n        }\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 35,
        "end_line": 51,
        "is_bug": false
    },
    {
        "name": "be_func.be_release_upvalues#75",
        "src_path": "src/be_func.c",
        "class_name": "be_func",
        "signature": "be_func.be_release_upvalues(bvm *vm, bclosure *cl)",
        "snippet": "void be_release_upvalues(bvm *vm, bclosure *cl)\n{\n    int i, count = cl->nupvals;\n    for (i = 0; i < count; ++i) {\n        bupval *uv = cl->upvals[i];\n        if (uv) {\n            if (uv->refcnt) {\n                --uv->refcnt;\n            }\n            /* delete non-referenced closed upvalue */\n            if (uv->value == &uv->u.value && !uv->refcnt) {\n                be_free(vm, uv, sizeof(bupval));\n            }\n        }\n    }\n}",
        "begin_line": 75,
        "end_line": 90,
        "is_bug": false
    },
    {
        "name": "be_func.be_newproto#92",
        "src_path": "src/be_func.c",
        "class_name": "be_func",
        "signature": "be_func.be_newproto(bvm *vm)",
        "snippet": "bproto* be_newproto(bvm *vm)\n{\n    bgcobject *gco = be_gcnew(vm, BE_PROTO, bproto);\n    bproto *p = cast_proto(gco);\n    if (p) {\n        p->upvals = NULL;\n        p->ktab = NULL;\n        p->ptab = NULL;\n        p->code = NULL;\n        p->name = NULL;\n        p->gray = NULL;\n        p->codesize = 0;\n        p->nupvals = 0;\n        p->nproto = 0;\n        p->nconst = 0;\n        p->nstack = 0;\n        p->codesize = 0;\n        p->argc = 0;\n        p->varg = 0;\n        p->source = NULL;\n#if BE_DEBUG_RUNTIME_INFO\n        p->lineinfo = NULL;\n        p->nlineinfo = 0;\n#endif\n#if BE_DEBUG_VAR_INFO\n        p->varinfo = NULL;\n        p->nvarinfo = 0;\n#endif\n    }\n    return p;\n}",
        "begin_line": 92,
        "end_line": 122,
        "is_bug": false
    },
    {
        "name": "be_func.be_newclosure#124",
        "src_path": "src/be_func.c",
        "class_name": "be_func",
        "signature": "be_func.be_newclosure(bvm *vm, int nupval)",
        "snippet": "bclosure* be_newclosure(bvm *vm, int nupval)\n{\n    bgcobject *gco = be_newgcobj(vm, BE_CLOSURE, clousersize(nupval));\n    bclosure *cl = cast_closure(gco);\n    if (cl) {\n        cl->proto = NULL;\n        cl->nupvals = (bbyte)nupval;\n        while (nupval--) {\n            cl->upvals[nupval] = NULL;\n        }\n    }\n    return cl;\n}",
        "begin_line": 124,
        "end_line": 136,
        "is_bug": false
    },
    {
        "name": "be_api.be_top#119",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_top(bvm *vm)",
        "snippet": "BERRY_API int be_top(bvm *vm)\n{\n    return cast_int(vm->top - vm->reg);\n}",
        "begin_line": 119,
        "end_line": 122,
        "is_bug": false
    },
    {
        "name": "be_api.be_pop#124",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pop(bvm *vm, int n)",
        "snippet": "BERRY_API void be_pop(bvm *vm, int n)\n{\n    be_assert(n <= vm->top - vm->reg);\n    be_stackpop(vm, n);\n}",
        "begin_line": 124,
        "end_line": 128,
        "is_bug": false
    },
    {
        "name": "be_api.be_absindex#130",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_absindex(bvm *vm, int index)",
        "snippet": "BERRY_API int be_absindex(bvm *vm, int index)\n{\n    if (index > 0) {\n        return index;\n    }\n    be_assert(vm->reg <= vm->top + index);\n    return cast_int(vm->top + index - vm->reg + 1);\n}",
        "begin_line": 130,
        "end_line": 137,
        "is_bug": false
    },
    {
        "name": "be_api.be_tobool#265",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_tobool(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_tobool(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    return be_value2bool(vm, v);\n}",
        "begin_line": 265,
        "end_line": 269,
        "is_bug": false
    },
    {
        "name": "be_api.be_tostring#271",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_tostring(bvm *vm, int index)",
        "snippet": "BERRY_API const char* be_tostring(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    if (!var_isstr(v)) {\n        be_val2str(vm, index);\n        v = be_indexof(vm, index);\n    }\n    return str(var_tostr(v));\n}",
        "begin_line": 271,
        "end_line": 279,
        "is_bug": false
    },
    {
        "name": "be_api.be_pushstring#325",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pushstring(bvm *vm, const char *str)",
        "snippet": "BERRY_API void be_pushstring(bvm *vm, const char *str)\n{\n    /* to create a string and then push the top registor,\n     * otherwise the GC may crash due to uninitialized values.\n     **/\n    bstring *s = be_newstr(vm, str);\n    bvalue *reg = be_incrtop(vm);\n    be_assert(reg < vm->stacktop);\n    var_setstr(reg, s);\n}",
        "begin_line": 325,
        "end_line": 334,
        "is_bug": false
    },
    {
        "name": "be_api.be_pushvalue#364",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pushvalue(bvm *vm, int index)",
        "snippet": "BERRY_API void be_pushvalue(bvm *vm, int index)\n{\n    bvalue *reg = vm->top;\n    var_setval(reg, be_indexof(vm, index));\n    be_incrtop(vm);\n}",
        "begin_line": 364,
        "end_line": 369,
        "is_bug": false
    },
    {
        "name": "be_api.be_pushntvfunction#388",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pushntvfunction(bvm *vm, bntvfunc f)",
        "snippet": "BERRY_API void be_pushntvfunction(bvm *vm, bntvfunc f)\n{\n    bvalue *top = be_incrtop(vm);\n    var_setntvfunc(top, f);\n}",
        "begin_line": 388,
        "end_line": 392,
        "is_bug": false
    },
    {
        "name": "be_api.be_remove#416",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_remove(bvm *vm, int index)",
        "snippet": "BERRY_API void be_remove(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    bvalue *top = --vm->top;\n    while (v < top) {\n        *v = v[1];\n        ++v;\n    }\n}",
        "begin_line": 416,
        "end_line": 424,
        "is_bug": false
    },
    {
        "name": "be_api.be_newlist#535",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_newlist(bvm *vm)",
        "snippet": "BERRY_API void be_newlist(bvm *vm)\n{\n    blist *list = be_list_new(vm);\n    bvalue *top = be_incrtop(vm);\n    var_setlist(top, list);\n}",
        "begin_line": 535,
        "end_line": 540,
        "is_bug": false
    },
    {
        "name": "be_api.be_newobject#556",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_newobject(bvm *vm, const char *name)",
        "snippet": "BERRY_API void be_newobject(bvm *vm, const char *name)\n{\n    be_getbuiltin(vm, name);\n    be_call(vm, 0);\n    be_getmember(vm, -1, \".p\");\n}",
        "begin_line": 556,
        "end_line": 561,
        "is_bug": false
    },
    {
        "name": "be_api.be_setglobal#585",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_setglobal(bvm *vm, const char *name)",
        "snippet": "BERRY_API void be_setglobal(bvm *vm, const char *name)\n{\n    int idx;\n    bstring *s = be_newstr(vm, name);\n    bvalue *v = be_incrtop(vm);\n    var_setstr(v, s);\n    idx = be_global_new(vm, s);\n    v = be_global_var(vm, idx);\n    *v = *be_indexof(vm, -2);\n    be_stackpop(vm, 1);\n}",
        "begin_line": 585,
        "end_line": 595,
        "is_bug": false
    },
    {
        "name": "be_api.be_getbuiltin#597",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_getbuiltin(bvm *vm, const char *name)",
        "snippet": "BERRY_API bbool be_getbuiltin(bvm *vm, const char *name)\n{\n    int idx = be_builtin_find(vm, be_newstr(vm, name));\n    bvalue *top = be_incrtop(vm);\n    if (idx > -1) {\n        *top = *be_global_var(vm, idx);\n        return btrue;\n    }\n    var_setnil(top);\n    return bfalse;\n}",
        "begin_line": 597,
        "end_line": 607,
        "is_bug": false
    },
    {
        "name": "be_api.be_setmember#609",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_setmember(bvm *vm, int index, const char *k)",
        "snippet": "BERRY_API bbool be_setmember(bvm *vm, int index, const char *k)\n{\n    bvalue *o = be_indexof(vm, index);\n    bvalue *v = be_indexof(vm, -1);\n    if (var_isinstance(o)) {\n        bstring *key = be_newstr(vm, k);\n        binstance *obj = var_toobj(o);\n        return be_instance_setmember(vm, obj, key, v);\n    } else if (var_ismodule(o)) {\n        bstring *key = be_newstr(vm, k);\n        bmodule *mod = var_toobj(o);\n        return be_module_setmember(vm, mod, key, v);\n    }\n    return bfalse;\n}",
        "begin_line": 609,
        "end_line": 623,
        "is_bug": false
    },
    {
        "name": "be_api.ins_member#639",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.ins_member(bvm *vm, int index, const char *k, bbool onlyins)",
        "snippet": "static int ins_member(bvm *vm, int index, const char *k, bbool onlyins)\n{\n    int type = BE_NIL;\n    bvalue *o = be_indexof(vm, index);\n    bvalue *top = be_incrtop(vm);\n    var_setnil(top);\n    if (var_isinstance(o)) {\n        binstance *obj = var_toobj(o);\n        type = be_instance_member(vm, obj, be_newstr(vm, k), top);\n    } else if (var_isclass(o) && !onlyins) {\n        bclass *cl = var_toobj(o);\n        type = be_class_member(vm, cl, be_newstr(vm, k), top);\n    } else if (var_ismodule(o) && !onlyins) {\n        bmodule *module = var_toobj(o);\n        type = be_module_attr(vm, module, be_newstr(vm, k), top);\n    }\n    if (type == BE_NONE) {\n        type = BE_NIL;\n    }\n    return type;\n}",
        "begin_line": 639,
        "end_line": 659,
        "is_bug": false
    },
    {
        "name": "be_api.be_getmember#661",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_getmember(bvm *vm, int index, const char *k)",
        "snippet": "BERRY_API bbool be_getmember(bvm *vm, int index, const char *k)\n{\n    return ins_member(vm, index, k, bfalse) != BE_NIL;\n}",
        "begin_line": 661,
        "end_line": 664,
        "is_bug": false
    },
    {
        "name": "be_api.be_data_push#786",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_data_push(bvm *vm, int index)",
        "snippet": "BERRY_API void be_data_push(bvm *vm, int index)\n{\n    bvalue *o = be_indexof(vm, index);\n    bvalue *v = be_indexof(vm, -1);\n    if (var_islist(o)) {\n        blist *list = var_toobj(o);\n        be_list_push(vm, list, v);\n    }\n}",
        "begin_line": 786,
        "end_line": 794,
        "is_bug": false
    },
    {
        "name": "be_api.be_returnnilvalue#1000",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_returnnilvalue(bvm *vm)",
        "snippet": "BERRY_API int be_returnnilvalue(bvm *vm)\n{\n    bvalue *ret = retreg(vm);\n    var_setnil(ret);\n    return 0;\n}",
        "begin_line": 1000,
        "end_line": 1005,
        "is_bug": false
    },
    {
        "name": "be_api.be_call#1007",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_call(bvm *vm, int argc)",
        "snippet": "BERRY_API void be_call(bvm *vm, int argc)\n{\n    bvalue *fval = vm->top - argc - 1;\n    be_dofunc(vm, fval, argc);\n}",
        "begin_line": 1007,
        "end_line": 1011,
        "is_bug": false
    },
    {
        "name": "be_api.be_pcall#1013",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pcall(bvm *vm, int argc)",
        "snippet": "BERRY_API int be_pcall(bvm *vm, int argc)\n{\n    bvalue *f = vm->top - argc - 1;\n    return be_protectedcall(vm, f, argc);\n}",
        "begin_line": 1013,
        "end_line": 1017,
        "is_bug": false
    },
    {
        "name": "be_api.be_raise#1019",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_raise(bvm *vm, const char *except, const char *msg)",
        "snippet": "BERRY_API void be_raise(bvm *vm, const char *except, const char *msg)\n{\n    be_pushstring(vm, except);\n    if (msg) {\n        be_pushstring(vm, msg);\n    } else {\n        be_pushnil(vm);\n    }\n    be_pop(vm, 2);\n    be_save_stacktrace(vm);\n    be_throw(vm, BE_EXCEPTION);\n}",
        "begin_line": 1019,
        "end_line": 1030,
        "is_bug": false
    },
    {
        "name": "be_api._dvfunc#1054",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api._dvfunc(bvm *vm, bbool esc)",
        "snippet": "static int _dvfunc(bvm *vm, bbool esc)\n{\n    const char* s = esc ?\n        be_toescape(vm, 1, 'x') : be_tostring(vm, 1);\n    be_writestring(s);\n    be_return_nil(vm);\n}",
        "begin_line": 1054,
        "end_line": 1060,
        "is_bug": false
    },
    {
        "name": "be_api._dumpdir#1067",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api._dumpdir(bvm *vm)",
        "snippet": "static int _dumpdir(bvm *vm)\n{\n    return _dvfunc(vm, bfalse);\n}",
        "begin_line": 1067,
        "end_line": 1070,
        "is_bug": false
    },
    {
        "name": "be_api.dump_value#1072",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.dump_value(bvm *vm, int index, bbool esc)",
        "snippet": "static int dump_value(bvm *vm, int index, bbool esc)\n{\n    int res, top = be_top(vm) + 1;\n    index = be_absindex(vm, index);\n    be_pushntvfunction(vm, esc ? _dumpesc : _dumpdir);\n    be_pushvalue(vm, index);\n    res = be_pcall(vm, 1); /* using index to store result */\n    be_remove(vm, top); /* remove '_dumpvalue' function */\n    be_remove(vm, top); /* remove the value */\n    if (res == BE_EXCEPTION) {\n        be_dumpexcept(vm);\n    }\n    return res;\n}",
        "begin_line": 1072,
        "end_line": 1085,
        "is_bug": false
    },
    {
        "name": "be_api.be_dumpexcept#1094",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_dumpexcept(bvm *vm)",
        "snippet": "BERRY_API void be_dumpexcept(bvm *vm)\n{\n    do {\n        /* print exception value */\n        if (dump_value(vm, -2, bfalse)) break;\n        be_writestring(\": \");\n        /* print exception argument */\n        if (dump_value(vm, -1, bfalse)) break;\n        be_writenewline();\n        /* print stack traceback */\n        be_tracestack(vm);\n    } while (0);\n    be_pop(vm, 2); /* pop the exception value & argument */\n}",
        "begin_line": 1094,
        "end_line": 1107,
        "is_bug": false
    },
    {
        "name": "be_list.be_list_new#18",
        "src_path": "src/be_list.c",
        "class_name": "be_list",
        "signature": "be_list.be_list_new(bvm *vm)",
        "snippet": "blist* be_list_new(bvm *vm)\n{\n    bgcobject *gco = be_gcnew(vm, BE_LIST, blist);\n    blist *list = cast_list(gco);\n    if (list) {\n        list->count = 0;\n        list->capacity = 2;\n        var_setlist(vm->top, list);\n        be_incrtop(vm);\n        list->data = be_malloc(vm, datasize(list->capacity));\n        be_stackpop(vm, 1);\n    }\n    return list;\n}",
        "begin_line": 18,
        "end_line": 31,
        "is_bug": false
    },
    {
        "name": "be_list.be_list_delete#33",
        "src_path": "src/be_list.c",
        "class_name": "be_list",
        "signature": "be_list.be_list_delete(bvm *vm, blist *list)",
        "snippet": "void be_list_delete(bvm *vm, blist *list)\n{\n    be_free(vm, list->data, datasize(list->capacity));\n    be_free(vm, list, sizeof(blist));\n}",
        "begin_line": 33,
        "end_line": 37,
        "is_bug": false
    },
    {
        "name": "be_list.be_list_push#67",
        "src_path": "src/be_list.c",
        "class_name": "be_list",
        "signature": "be_list.be_list_push(bvm *vm, blist *list, bvalue *value)",
        "snippet": "bvalue* be_list_push(bvm *vm, blist *list, bvalue *value)\n{\n    bvalue *slot;\n    if (list->count >= list->capacity) {\n        int newcap = be_nextsize(list->capacity);\n        list->data = be_realloc(vm, list->data,\n            datasize(list->capacity), datasize(newcap));\n        list->capacity = newcap;\n    }\n    slot = list->data + list->count++;\n    if (value != NULL) {\n        *slot = *value;\n    }\n    return slot;\n}",
        "begin_line": 67,
        "end_line": 81,
        "is_bug": false
    },
    {
        "name": "be_list.be_list_resize#129",
        "src_path": "src/be_list.c",
        "class_name": "be_list",
        "signature": "be_list.be_list_resize(bvm *vm, blist *list, int count)",
        "snippet": "void be_list_resize(bvm *vm, blist *list, int count)\n{\n    if (count != list->count) {\n        int newcap = be_nextsize(count);\n        if (newcap > list->capacity) {\n            bvalue *v, *end;\n            list->data = be_realloc(vm, list->data,\n                datasize(list->capacity), datasize(newcap));\n            list->capacity = newcap;\n            v = list->data + list->count;\n            end = list->data + count;\n            while (v < end) {\n                var_setnil(v++);\n            }\n        }\n        list->count = count;\n    }\n}",
        "begin_line": 129,
        "end_line": 146,
        "is_bug": false
    },
    {
        "name": "be_mem.be_os_malloc#29",
        "src_path": "src/be_mem.c",
        "class_name": "be_mem",
        "signature": "be_mem.be_os_malloc(size_t size)",
        "snippet": "BERRY_API void* be_os_malloc(size_t size)\n{\n    return malloc(size);\n}",
        "begin_line": 29,
        "end_line": 32,
        "is_bug": false
    },
    {
        "name": "be_mem.be_os_free#34",
        "src_path": "src/be_mem.c",
        "class_name": "be_mem",
        "signature": "be_mem.be_os_free(void *ptr)",
        "snippet": "BERRY_API void be_os_free(void *ptr)\n{\n    free(ptr);\n}",
        "begin_line": 34,
        "end_line": 37,
        "is_bug": false
    },
    {
        "name": "be_mem._realloc#44",
        "src_path": "src/be_mem.c",
        "class_name": "be_mem",
        "signature": "be_mem._realloc(void *ptr, size_t old_size, size_t new_size)",
        "snippet": "static void* _realloc(void *ptr, size_t old_size, size_t new_size)\n{\n    if (old_size == new_size) { /* the block unchanged */\n        return ptr;\n    }\n    if (ptr && new_size) { /* realloc block */\n        return realloc(ptr, new_size);\n    }\n    if (new_size) { /* alloc a new block */\n        be_assert(ptr == NULL && old_size == 0);\n        return malloc(new_size);\n    }\n    be_assert(new_size == 0);\n\n#if BE_USE_DEBUG_GC\n    memset(ptr, 0xFF, old_size); /* fill the structure with invalid pointers */\n#endif\n    free(ptr);\n    return NULL;\n}",
        "begin_line": 44,
        "end_line": 63,
        "is_bug": false
    },
    {
        "name": "be_mem.be_realloc#65",
        "src_path": "src/be_mem.c",
        "class_name": "be_mem",
        "signature": "be_mem.be_realloc(bvm *vm, void *ptr, size_t old_size, size_t new_size)",
        "snippet": "BERRY_API void* be_realloc(bvm *vm, void *ptr, size_t old_size, size_t new_size)\n{\n    void *block = _realloc(ptr, old_size, new_size);\n    if (!block && new_size) { /* allocation failure */\n        vm->gc.status |= GC_ALLOC;\n        be_gc_collect(vm); /* try to allocate again after GC */\n        vm->gc.status &= ~GC_ALLOC;\n        block = _realloc(ptr, old_size, new_size);\n        if (!block) { /* lack of heap space */\n            be_throw(vm, BE_MALLOC_FAIL);\n        }\n    }\n    vm->gc.usage = vm->gc.usage + new_size - old_size; /* update allocated count */\n    return block;\n}",
        "begin_line": 65,
        "end_line": 79,
        "is_bug": false
    },
    {
        "name": "be_vm.precall#193",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.precall(bvm *vm, bvalue *func, int nstack, int mode)",
        "snippet": "static void precall(bvm *vm, bvalue *func, int nstack, int mode)\n{\n    bcallframe *cf;\n    int expan = nstack + BE_STACK_FREE_MIN; /* `expan` is the minimum required space on the stack */\n    if (vm->stacktop < func + expan) {  /* do we have too little space left on the stack? */\n        size_t fpos = func - vm->stack;  /* compute offset of `func` from base stack, in case stack is reallocated and base address changes */\n        be_stack_expansion(vm, expan);  /* expand stack (vector object), warning stack address changes */\n        func = vm->stack + fpos;  /* recompute `func` address with new stack address */\n    }\n    be_stack_push(vm, &vm->callstack, NULL);  /* push a NULL value on callstack */\n    cf = be_stack_top(&vm->callstack);  /* get address of new callframe at top of callstack */\n    cf->func = func - mode;\n    cf->top = vm->top;  /* save previous stack top */\n    cf->reg = vm->reg;  /* save previous stack base */\n    vm->reg = func + 1;  /* new stack base is right after function */\n    vm->top = vm->reg + nstack; /* new stack top is above the registers used by the function, so we don\u00b4t mess with them */\n    vm->cf = cf;  /* set new current callframe */\n}\n",
        "begin_line": 193,
        "end_line": 210,
        "is_bug": false
    },
    {
        "name": "be_vm.push_closure#213",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.push_closure(bvm *vm, bvalue *func, int nstack, int mode)",
        "snippet": "static void push_closure(bvm *vm, bvalue *func, int nstack, int mode)\n{\n    bclosure *cl = var_toobj(func);\n    precall(vm, func, nstack, mode);\n    vm->cf->ip = vm->ip;\n    vm->cf->status = NONE_FLAG;\n    vm->ip = cl->proto->code;\n#if BE_USE_DEBUG_HOOK\n    vm->cf->lineinfo = cl->proto->lineinfo;\n    be_callhook(vm, BE_HOOK_CALL);\n#endif\n}",
        "begin_line": 213,
        "end_line": 224,
        "is_bug": false
    },
    {
        "name": "be_vm.ret_native#226",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.ret_native(bvm *vm)",
        "snippet": "static void ret_native(bvm *vm)\n{\n    bcallframe *_cf = vm->cf;\n    vm->reg = _cf->reg;\n    vm->top = _cf->top;\n    be_stack_pop(&vm->callstack);\n    vm->cf = be_stack_top(&vm->callstack);\n}",
        "begin_line": 226,
        "end_line": 233,
        "is_bug": false
    },
    {
        "name": "be_vm.be_value2bool#251",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.be_value2bool(bvm *vm, bvalue *v)",
        "snippet": "bbool be_value2bool(bvm *vm, bvalue *v)\n{\n    switch (var_basetype(v)) {\n    case BE_NIL:\n        return bfalse;\n    case BE_BOOL:\n        return var_tobool(v);\n    case BE_INT:\n        return val2bool(v->v.i);\n    case BE_REAL:\n        return val2bool(v->v.r);\n    case BE_INSTANCE:\n        return obj2bool(vm, v);\n    default:\n        return btrue;\n    }\n}",
        "begin_line": 251,
        "end_line": 267,
        "is_bug": false
    },
    {
        "name": "be_vm.be_vm_iseq#367",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.be_vm_iseq(bvm *vm, bvalue *a, bvalue *b)",
        "snippet": "bbool be_vm_iseq(bvm *vm, bvalue *a, bvalue *b)\n{\n    equal_rule(==, btrue);\n}",
        "begin_line": 367,
        "end_line": 370,
        "is_bug": false
    },
    {
        "name": "be_vm.be_vm_new#426",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.be_vm_new(void)",
        "snippet": "BERRY_API bvm* be_vm_new(void)\n{\n    bvm *vm = be_os_malloc(sizeof(bvm));\n    be_assert(vm != NULL);\n    memset(vm, 0, sizeof(bvm)); /* clear all members */\n    be_gc_init(vm);\n    be_string_init(vm);\n    be_stack_init(vm, &vm->callstack, sizeof(bcallframe));\n    be_stack_init(vm, &vm->refstack, sizeof(binstance*));\n    be_stack_init(vm, &vm->exceptstack, sizeof(struct bexecptframe));\n    be_stack_init(vm, &vm->tracestack, sizeof(bcallsnapshot));\n    vm->stack = be_malloc(vm, sizeof(bvalue) * BE_STACK_FREE_MIN);\n    vm->stacktop = vm->stack + BE_STACK_FREE_MIN;\n    vm->reg = vm->stack;\n    vm->top = vm->reg;\n    be_globalvar_init(vm);\n    be_gc_setpause(vm, 1);\n    be_loadlibs(vm);\n    vm->compopt = 0;\n#if BE_USE_OBSERVABILITY_HOOK\n    vm->obshook = NULL;\n#endif\n    return vm;\n}",
        "begin_line": 426,
        "end_line": 449,
        "is_bug": false
    },
    {
        "name": "be_vm.be_vm_delete#451",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.be_vm_delete(bvm *vm)",
        "snippet": "BERRY_API void be_vm_delete(bvm *vm)\n{\n    be_gc_deleteall(vm);\n    be_string_deleteall(vm);\n    be_stack_delete(vm, &vm->callstack);\n    be_stack_delete(vm, &vm->refstack);\n    be_stack_delete(vm, &vm->exceptstack);\n    be_stack_delete(vm, &vm->tracestack);\n    be_free(vm, vm->stack, (vm->stacktop - vm->stack) * sizeof(bvalue));\n    be_globalvar_deinit(vm);\n#if BE_USE_DEBUG_HOOK\n    /* free native hook */\n    if (var_istype(&vm->hook, BE_COMPTR))\n        be_free(vm, var_toobj(&vm->hook), sizeof(struct bhookblock));\n#endif\n    /* free VM structure */\n    be_os_free(vm);\n}",
        "begin_line": 451,
        "end_line": 468,
        "is_bug": false
    },
    {
        "name": "be_vm.vm_exec#470",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.vm_exec(bvm *vm)",
        "snippet": "static void vm_exec(bvm *vm)\n{\n    bclosure *clos;\n    bvalue *ktab, *reg;\n    binstruction ins;\n    vm->cf->status |= BASE_FRAME;\nnewframe: /* a new call frame */\n    be_assert(var_isclosure(vm->cf->func));\n    clos = var_toobj(vm->cf->func);  /* `clos` is the current function/closure */\n    ktab = clos->proto->ktab;  /* `ktab` is the current constant table */\n    reg = vm->reg;  /* `reg` is the current stack base for the callframe */\n    vm_exec_loop() {\n        opcase(LDNIL): {\n            var_setnil(RA());\n            dispatch();\n        }\n        opcase(LDBOOL): {\n            bvalue *v = RA();\n            var_setbool(v, IGET_RKB(ins));\n            if (IGET_RKC(ins)) { /* skip next instruction */\n                vm->ip += 1;\n            }\n            dispatch();\n        }\n        opcase(LDINT): {\n            bvalue *v = RA();\n            var_setint(v, IGET_sBx(ins));\n            dispatch();\n        }\n        opcase(LDCONST): {\n            bvalue *dst = RA();\n            *dst = ktab[IGET_Bx(ins)];\n            dispatch();\n        }\n        opcase(GETGBL): {\n            bvalue *v = RA();\n            int idx = IGET_Bx(ins);\n            *v = *be_global_var(vm, idx);\n            dispatch();\n        }\n        opcase(GETNGBL): {  /* get Global by name */\n            bvalue *v = RA();\n            bvalue *b = RKB();\n            if (var_isstr(b)) {\n                bstring *name = var_tostr(b);\n                int idx = be_global_find(vm, name);\n                if (idx > -1) {\n                    *v = *be_global_var(vm, idx);\n                } else {\n                    vm_error(vm, \"attribute_error\", \"'%s' undeclared\", str(name));\n                }\n            } else {\n                vm_error(vm, \"internal_error\", \"global name must be a string\");\n            }\n            dispatch();\n        }\n        opcase(SETNGBL): {  /* set Global by name */\n            bvalue *v = RA();\n            bvalue *b = RKB();\n            if (var_isstr(b)) {\n                bstring *name = var_tostr(b);\n                int idx = be_global_new(vm, name);\n                *be_global_var(vm, idx) = *v;\n            } else {\n                vm_error(vm, \"internal_error\", \"global name must be a string\");\n            }\n            dispatch();\n        }\n        opcase(SETGBL): {\n            bvalue *v = RA();\n            int idx = IGET_Bx(ins);\n            *be_global_var(vm, idx) = *v;\n            dispatch();\n        }\n        opcase(GETUPV): {\n            bvalue *v = RA();\n            int idx = IGET_Bx(ins);\n            be_assert(*clos->upvals != NULL);\n            *v = *clos->upvals[idx]->value;\n            dispatch();\n        }\n        opcase(SETUPV): {\n            bvalue *v = RA();\n            int idx = IGET_Bx(ins);\n            be_assert(*clos->upvals != NULL);\n            *clos->upvals[idx]->value = *v;\n            dispatch();\n        }\n        opcase(MOVE): {\n            bvalue *dst = RA();\n            *dst = *RKB();\n            dispatch();\n        }\n        opcase(ADD): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                var_setint(dst, ibinop(+, a, b));\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                breal x = var2real(a), y = var2real(b);\n                var_setreal(dst, x + y);\n            } else if (var_isstr(a) && var_isstr(b)) { /* strcat */\n                bstring *s = be_strcat(vm, var_tostr(a), var_tostr(b));\n                reg = vm->reg;\n                dst = RA();\n                var_setstr(dst, s);\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, \"+\", ins);\n            } else {\n                binop_error(vm, \"+\", a, b);\n            }\n            dispatch();\n        }\n        opcase(SUB): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                var_setint(dst, ibinop(-, a, b));\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                breal x = var2real(a), y = var2real(b);\n                var_setreal(dst, x - y);\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, \"-\", ins);\n            } else {\n                binop_error(vm, \"-\", a, b);\n            }\n            dispatch();\n        }\n        opcase(MUL): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                var_setint(dst, ibinop(*, a, b));\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                breal x = var2real(a), y = var2real(b);\n                var_setreal(dst, x * y);\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, \"*\", ins);\n            } else {\n                binop_error(vm, \"*\", a, b);\n            }\n            dispatch();\n        }\n        opcase(DIV): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                bint x = var_toint(a), y = var_toint(b);\n                if (y == 0) {\n                    vm_error(vm, \"divzero_error\", \"division by zero\");\n                } else {\n                    var_setint(dst, x / y);\n                }\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                breal x = var2real(a), y = var2real(b);\n                if (y == cast(breal, 0)) {\n                    vm_error(vm, \"divzero_error\", \"division by zero\");\n                }\n                var_setreal(dst, x / y);\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, \"/\", ins);\n            } else {\n                binop_error(vm, \"/\", a, b);\n            }\n            dispatch();\n        }\n        opcase(MOD): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                var_setint(dst, ibinop(%, a, b));\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                var_setreal(dst, mathfunc(fmod)(var_toreal(a), var_toreal(b)));\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, \"%\", ins);\n            } else {\n                binop_error(vm, \"%\", a, b);\n            }\n            dispatch();\n        }\n        opcase(LT): {\n            bbool res = be_vm_islt(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(LE): {\n            bbool res = be_vm_isle(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(EQ): {\n            bbool res = be_vm_iseq(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(NE): {\n            bbool res = be_vm_isneq(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(GT): {\n            bbool res = be_vm_isgt(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(GE): {\n            bbool res = be_vm_isge(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(CONNECT): {\n            bvalue *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                make_range(vm, *RKB(), *RKC());\n            } else if (var_isstr(a)) {\n                connect_str(vm, var_tostr(a), b);\n            } else if (var_isinstance(a)) {\n                object_binop(vm, \"..\", *RKB(), *RKC());\n            } else {\n                binop_error(vm, \"..\", RKB(), RKC());\n            }\n            reg = vm->reg;\n            *RA() = *vm->top; /* copy result to R(A) */\n            dispatch();\n        }\n        opcase(AND): {\n            bitwise_block(&);\n            dispatch();\n        }\n        opcase(OR): {\n            bitwise_block(|);\n            dispatch();\n        }\n        opcase(XOR): {\n            bitwise_block(^);\n            dispatch();\n        }\n        opcase(SHL): {\n            bitwise_block(<<);\n            dispatch();\n        }\n        opcase(SHR): {\n            bitwise_block(>>);\n            dispatch();\n        }\n        opcase(NEG): {\n            bvalue *dst = RA(), *a = RKB();\n            if (var_isint(a)) {\n                var_setint(dst, -a->v.i);\n            } else if (var_isreal(a)) {\n                var_setreal(dst, -a->v.r);\n            } else if (var_isinstance(a)) {\n                ins_unop(vm, \"-*\", *RKB());\n                reg = vm->reg;\n                *RA() = *vm->top; /* copy result to dst */\n            } else {\n                unop_error(vm, \"-\", a);\n            }\n            dispatch();\n        }\n        opcase(FLIP): {\n            bvalue *dst = RA(), *a = RKB();\n            if (var_isint(a)) {\n                var_setint(dst, -a->v.i);\n            } else if (var_isinstance(a)) {\n                ins_unop(vm, \"~\", *RKB());\n                reg = vm->reg;\n                *RA() = *vm->top; /* copy result to dst */\n            } else {\n                unop_error(vm, \"~\", a);\n            }\n            dispatch();\n        }\n        opcase(JMP): {\n            vm->ip += IGET_sBx(ins);\n            dispatch();\n        }\n        opcase(JMPT): {\n            if (be_value2bool(vm, RA())) {\n                vm->ip += IGET_sBx(ins);\n            }\n            dispatch();\n        }\n        opcase(JMPF): {\n            if (!be_value2bool(vm, RA())) {\n                vm->ip += IGET_sBx(ins);\n            }\n            dispatch();\n        }\n        opcase(CLOSURE): {\n            bvalue *dst;\n            bproto *p = clos->proto->ptab[IGET_Bx(ins)];\n            bclosure *cl = be_newclosure(vm, p->nupvals);\n            cl->proto = p;\n            reg = vm->reg;\n            dst = RA();\n            var_setclosure(dst, cl);\n            be_initupvals(vm, cl);\n            dispatch();\n        }\n        opcase(CLASS): {\n            bclass *c = var_toobj(ktab + IGET_Bx(ins));\n            be_class_upvalue_init(vm, c);\n            dispatch();\n        }\n        opcase(GETMBR): {\n            bvalue *a = RA(), *b = RKB(), *c = RKC();\n            if (var_isinstance(b) && var_isstr(c)) {\n                obj_attribute(vm, b, var_tostr(c), a);\n                reg = vm->reg;\n            } else if (var_isclass(b) && var_isstr(c)) {\n                class_attribute(vm, b, c, a);\n                reg = vm->reg;\n            } else if (var_ismodule(b) && var_isstr(c)) {\n                module_attribute(vm, b, c, a);\n                reg = vm->reg;\n            } else {\n                attribute_error(vm, \"attribute\", b, c);\n            }\n            dispatch();\n        }\n        opcase(GETMET): {\n            bvalue *a = RA(), *b = RKB(), *c = RKC();\n            if (var_isinstance(b) && var_isstr(c)) {\n                binstance *obj = var_toobj(b);\n                int type = obj_attribute(vm, b, var_tostr(c), a);\n                reg = vm->reg;\n                if (basetype(type) == BE_FUNCTION) {\n                    /* check if the object is a superinstance, if so get the lowest possible subclass */\n                    while (obj->sub) {\n                        obj = obj->sub;\n                    }\n                    var_setinstance(&a[1], obj);  /* replace superinstance by lowest subinstance */\n                } else {\n                    vm_error(vm, \"attribute_error\",\n                        \"class '%s' has no method '%s'\",\n                        str(be_instance_name(obj)), str(var_tostr(c)));\n                }\n            } else if (var_ismodule(b) && var_isstr(c)) {\n                module_attribute(vm, b, c, &a[1]);\n                var_settype(a, NOT_METHOD);\n            } else {\n                attribute_error(vm, \"method\", b, c);\n            }\n            dispatch();\n        }\n        opcase(SETMBR): {\n            bvalue *a = RA(), *b = RKB(), *c = RKC();\n            if (var_isinstance(a) && var_isstr(b)) {\n                binstance *obj = var_toobj(a);\n                bstring *attr = var_tostr(b);\n                if (!be_instance_setmember(vm, obj, attr, c)) {\n                    vm_error(vm, \"attribute_error\",\n                        \"class '%s' cannot assign to attribute '%s'\",\n                        str(be_instance_name(obj)), str(attr));\n                }\n                dispatch();\n            }\n            if (var_isclass(a) && var_isstr(b)) {\n                bclass *obj = var_toobj(a);\n                bstring *attr = var_tostr(b);\n                if (!be_class_setmember(vm, obj, attr, c)) {\n                    vm_error(vm, \"attribute_error\",\n                        \"class '%s' cannot assign to static attribute '%s'\",\n                        str(be_class_name(obj)), str(attr));\n                }\n                dispatch();\n            }\n            if (var_ismodule(a) && var_isstr(b)) {\n                bmodule *obj = var_toobj(a);\n                bstring *attr = var_tostr(b);\n                if (be_module_setmember(vm, obj, attr, c)) {\n                    dispatch();\n                } else {\n                    // fall through exception below\n                }\n            }\n            attribute_error(vm, \"writable attribute\", a, b);\n            dispatch();\n        }\n        opcase(GETIDX): {\n            bvalue *b = RKB(), *c = RKC();\n            if (var_isinstance(b)) {\n                bvalue *top = vm->top;\n                /* get method 'item' */\n                obj_method(vm, b, str_literal(vm, \"item\"), vm->top);\n                top[1] = *b; /* move object to argv[0] */\n                top[2] = *c; /* move key to argv[1] */\n                vm->top += 3;   /* prevent collection results */\n                be_dofunc(vm, top, 2); /* call method 'item' */\n                vm->top -= 3;\n                reg = vm->reg;\n                *RA() = *vm->top;   /* copy result to R(A) */\n            } else if (var_isstr(b)) {\n                bstring *s = be_strindex(vm, var_tostr(b), c);\n                reg = vm->reg;\n                var_setstr(RA(), s);\n            } else {\n                vm_error(vm, \"type_error\",\n                    \"value '%s' does not support subscriptable\",\n                    be_vtype2str(b));\n            }\n            dispatch();\n        }\n        opcase(SETIDX): {\n            bvalue *a = RA(), *b = RKB(), *c = RKC();\n            if (var_isinstance(a)) {\n                bvalue *top = vm->top;\n                /* get method 'setitem' */\n                obj_method(vm, a, str_literal(vm, \"setitem\"), vm->top);\n                top[1] = *a; /* move object to argv[0] */\n                top[2] = *b; /* move key to argv[1] */\n                top[3] = *c; /* move src to argv[2] */\n                vm->top += 4;\n                be_dofunc(vm, top, 3); /* call method 'setitem' */\n                vm->top -= 4;\n                reg = vm->reg;\n            } else {\n                vm_error(vm, \"type_error\",\n                    \"value '%s' does not support index assignment\",\n                    be_vtype2str(a));\n            }\n            dispatch();\n        }\n        opcase(SETSUPER): {\n            bvalue *a = RA(), *b = RKB();\n            if (var_isclass(a) && var_isclass(b)) {\n                bclass *obj = var_toobj(a);\n                be_class_setsuper(obj, var_toobj(b));\n            } else {\n                vm_error(vm, \"type_error\",\n                    \"value '%s' does not support set super\",\n                    be_vtype2str(b));\n            }\n            dispatch();\n        }\n        opcase(CLOSE): {\n            be_upvals_close(vm, RA());\n            dispatch();\n        }\n        opcase(IMPORT): {\n            bvalue *b = RKB();\n            if (var_isstr(b)) {\n                bstring *name = var_tostr(b);\n                int res = be_module_load(vm, name);\n                reg = vm->reg;\n                switch (res) {\n                case BE_OK: /* find the module */\n                    be_stackpop(vm, 1);\n                    *RA() = *vm->top;\n                    break;\n                case BE_EXCEPTION: /* pop the exception value and message */\n                    be_pop(vm, 2);\n                    be_throw(vm, BE_EXCEPTION);\n                    break;\n                default:\n                    vm_error(vm, \"import_error\", \"module '%s' not found\", str(name));\n                }\n            } else {\n                vm_error(vm, \"type_error\",\n                    \"import '%s' does not support import\",\n                    be_vtype2str(b));\n            }\n            dispatch();\n        }\n        opcase(CATCH): {\n            bvalue *base = RA(), *top = vm->top;\n            int i = 0, ecnt = IGET_RKB(ins), vcnt = IGET_RKC(ins);\n            while (i < ecnt && !be_vm_iseq(vm, top, base + i)) {\n                ++i;\n            }\n            if (!ecnt || i < ecnt) { /* exception catched */\n                base = RA(), top = vm->top;\n                for (i = 0; i < vcnt; ++i) {\n                    *base++ = *top++;\n                }\n                vm->ip += 1; /* skip next instruction */\n            }\n            dispatch();\n        }\n        opcase(RAISE): {\n            if (IGET_RA(ins) < 2) {  /* A==2 means no arguments are passed to RAISE, i.e. rethrow with current exception */\n                bvalue *top = vm->top;\n                top[0] = *RKB(); /* push the exception value to top */\n                if (IGET_RA(ins)) { /* has exception argument? */\n                    top[1] = *RKC(); /* push the exception argument to top + 1 */\n                } else {\n                    var_setnil(top + 1);\n                }\n                be_save_stacktrace(vm);\n            }\n            be_throw(vm, BE_EXCEPTION); /* throw / rethrow the exception */\n            dispatch();\n        }\n        opcase(EXBLK): {\n            if (!IGET_RA(ins)) {\n                be_except_block_setup(vm);\n                if (be_setjmp(vm->errjmp->b)) {\n                    be_except_block_resume(vm);\n                    goto newframe;\n                }\n                reg = vm->reg;\n            } else {\n                be_except_block_close(vm, IGET_Bx(ins));\n            }\n            dispatch();\n        }\n        opcase(CALL): {\n            bvalue *var = RA();  /* `var` is the register for the call followed by arguments */\n            int mode = 0, argc = IGET_RKB(ins);  /* B contains number of arguments pushed on stack */\n        recall: /* goto: instantiation class and call constructor */\n            switch (var_type(var)) {\n            case NOT_METHOD:\n                var[0] = var[1];\n                ++var, --argc, mode = 1;\n                goto recall;\n            case BE_CLASS:\n                if (be_class_newobj(vm, var_toobj(var), var, ++argc, mode)) {  /* instanciate object and find constructor */\n                    reg = vm->reg + mode;  /* constructor found */\n                    mode = 0;\n                    var = RA() + 1; /* to next register */\n                    goto recall; /* call constructor */\n                }\n                break;\n            case BE_INSTANCE: {\n                bvalue *v = var + argc++, temp;\n                /* load the '()' method to `temp' */\n                obj_method(vm, var, str_literal(vm, \"()\"), &temp);\n                for (; v >= var; --v) v[1] = v[0];\n                *var = temp;\n                goto recall; /* call '()' method */\n            }\n            case BE_CLOSURE: {\n                // bvalue *v, *end;\n                // bproto *proto = var2cl(var)->proto;  /* get proto for closure */\n                // push_closure(vm, var, proto->nstack, mode);  /* prepare stack for closure */\n                // reg = vm->reg;  /* `reg` has changed, now new base register */\n                // v = reg + argc;  /* end of provided arguments */\n                // end = reg + proto->argc;  /* end of expected arguments */\n                // for (; v < end; ++v) {  /* set all not provided arguments to nil */\n                //     var_setnil(v);\n                // }\n                // if (proto->varg) {  /* there are vararg at the last argument, build the list */\n                //     /* code below uses mostly low-level calls for performance */\n                //     be_stack_require(vm, argc + 2);   /* make sure we don't overflow the stack */\n                //     bvalue *top_save = vm->top;  /* save original stack, we need fresh slots to create the 'list' instance */\n                //     vm->top = v;  /* move top of stack right after last argument */\n                //     be_newobject(vm, \"list\");  /* this creates 2 objects on stack: list instance, BE_LIST object */\n                //     blist *list = var_toobj(vm->top-1);  /* get low-level BE_LIST structure */\n                //     v = reg + proto->argc - 1;  /* last argument */\n                //     for (; v < reg + argc; v++) {\n                //         be_list_push(vm, list, v); /* push all varargs into list */       \n                //     }\n                //     *(reg + proto->argc - 1) = *(vm->top-2);  /* change the vararg argument to now contain the list instance */\n                //     vm->top = top_save;  /* restore top of stack pointer */\n                // }\n                prep_closure(vm, var, argc, mode);\n                reg = vm->reg;  /* `reg` has changed, now new base register */\n                goto newframe;  /* continue execution of the closure */\n            }\n            case BE_NTVCLOS: {\n                bntvclos *f = var_toobj(var);\n                push_native(vm, var, argc, mode);\n                f->f(vm); /* call C primitive function */\n                ret_native(vm);\n                break;\n            }\n            case BE_NTVFUNC: {\n                bntvfunc f = var_tontvfunc(var);\n                push_native(vm, var, argc, mode);\n                f(vm); /* call C primitive function */\n                ret_native(vm);\n                break;\n            }\n            case BE_MODULE: {\n                bvalue attr;\n                var_setstr(&attr, str_literal(vm, \"()\"));\n                module_attribute(vm, var, &attr, var);  /* exception if not found */\n                goto recall; /* call '()' method */\n                break;\n            }\n            default:\n                call_error(vm, var);\n            }\n            reg = vm->reg;\n            dispatch();\n        }\n        opcase(RET): {\n            bcallframe *cf;\n            bvalue *ret;\n#if BE_USE_DEBUG_HOOK\n            be_callhook(vm, BE_HOOK_RET);\n#endif\n            cf = vm->cf;\n            ret = vm->cf->func;\n            /* copy return value */\n            if (IGET_RA(ins)) {\n                *ret = *RKB();\n            } else {\n                var_setnil(ret);\n            }\n            vm->reg = cf->reg;\n            vm->top = cf->top;\n            vm->ip = cf->ip;\n            be_stack_pop(&vm->callstack); /* pop don't delete */\n            if (cf->status & BASE_FRAME) { /* entrance function */\n                bstack *cs = &vm->callstack;\n                if (!be_stack_isempty(cs)) {\n                    vm->cf = be_stack_top(cs);\n                }\n                return;\n            }\n            vm->cf = be_stack_top(&vm->callstack);\n            goto newframe;\n        }\n    }\n}",
        "begin_line": 470,
        "end_line": 1099,
        "is_bug": true
    },
    {
        "name": "be_vm.prep_closure#1101",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.prep_closure(bvm *vm, bvalue *reg, int argc, int mode)",
        "snippet": "static void prep_closure(bvm *vm, bvalue *reg, int argc, int mode)\n{\n    bvalue *v, *end;\n    bproto *proto = var2cl(reg)->proto;\n    push_closure(vm, reg, proto->nstack, mode);\n    v = vm->reg + argc;\n    end = vm->reg + proto->argc;\n    for (; v <= end; ++v) {\n        var_setnil(v);\n    }\n    if (proto->varg) {  /* there are vararg at the last argument, build the list */\n        /* code below uses mostly low-level calls for performance */\n        be_stack_require(vm, argc + 2);   /* make sure we don't overflow the stack */\n        bvalue *top_save = vm->top;  /* save original stack, we need fresh slots to create the 'list' instance */\n        vm->top = v;  /* move top of stack right after last argument */\n        be_newobject(vm, \"list\");  /* this creates 2 objects on stack: list instance, BE_LIST object */\n        blist *list = var_toobj(vm->top-1);  /* get low-level BE_LIST structure */\n        v = vm->reg + proto->argc - 1;  /* last argument */\n        for (; v < vm->reg + argc; v++) {\n            be_list_push(vm, list, v); /* push all varargs into list */       \n        }\n        *(vm->reg + proto->argc - 1) = *(vm->top-2);  /* change the vararg argument to now contain the list instance */\n        vm->top = top_save;  /* restore top of stack pointer */\n    }\n}",
        "begin_line": 1101,
        "end_line": 1125,
        "is_bug": false
    },
    {
        "name": "be_vm.do_closure#1127",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.do_closure(bvm *vm, bvalue *reg, int argc)",
        "snippet": "static void do_closure(bvm *vm, bvalue *reg, int argc)\n{\n    // bvalue *v, *end;\n    // bproto *proto = var2cl(reg)->proto;\n    // push_closure(vm, reg, proto->nstack, 0);\n    // v = vm->reg + argc;\n    // end = vm->reg + proto->argc;\n    // for (; v <= end; ++v) {\n    //     var_setnil(v);\n    // }\n    prep_closure(vm, reg, argc, 0);\n    vm_exec(vm);\n}",
        "begin_line": 1127,
        "end_line": 1139,
        "is_bug": false
    },
    {
        "name": "be_vm.do_ntvfunc#1149",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.do_ntvfunc(bvm *vm, bvalue *reg, int argc)",
        "snippet": "static void do_ntvfunc(bvm *vm, bvalue *reg, int argc)\n{\n    bntvfunc f = var_tontvfunc(reg);\n    push_native(vm, reg, argc, 0);\n    f(vm); /* call C primitive function */\n    ret_native(vm);\n}",
        "begin_line": 1149,
        "end_line": 1155,
        "is_bug": false
    },
    {
        "name": "be_vm.do_class#1157",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.do_class(bvm *vm, bvalue *reg, int argc)",
        "snippet": "static void do_class(bvm *vm, bvalue *reg, int argc)\n{\n    if (be_class_newobj(vm, var_toobj(reg), reg, ++argc, 0)) {\n        be_incrtop(vm);\n        be_dofunc(vm, reg + 1, argc);\n        be_stackpop(vm, 1);\n    }\n}",
        "begin_line": 1157,
        "end_line": 1164,
        "is_bug": false
    },
    {
        "name": "be_vm.be_dofunc#1166",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.be_dofunc(bvm *vm, bvalue *v, int argc)",
        "snippet": "void be_dofunc(bvm *vm, bvalue *v, int argc)\n{\n    be_assert(vm->reg <= v && v < vm->stacktop);\n    be_assert(vm->stack <= vm->reg && vm->reg < vm->stacktop);\n    switch (var_type(v)) {\n    case BE_CLASS: do_class(vm, v, argc); break;\n    case BE_CLOSURE: do_closure(vm, v, argc); break;\n    case BE_NTVCLOS: do_ntvclos(vm, v, argc); break;\n    case BE_NTVFUNC: do_ntvfunc(vm, v, argc); break;\n    default: call_error(vm, v);\n    }\n}",
        "begin_line": 1166,
        "end_line": 1177,
        "is_bug": false
    },
    {
        "name": "be_class.instance_member#129",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.instance_member(bvm *vm, binstance *obj, bstring *name, bvalue *dst)",
        "snippet": "static binstance* instance_member(bvm *vm,\n    binstance *obj, bstring *name, bvalue *dst)\n{\n    for (; obj; obj = obj->super) {\n        bmap *members = obj->_class->members;\n        if (members) {\n            bvalue *v = be_map_findstr(vm, members, name);\n            if (v) {\n                *dst = *v;\n                return obj;\n            }\n        }\n    }\n    var_setnil(dst);\n    return NULL;\n}",
        "begin_line": 129,
        "end_line": 144,
        "is_bug": false
    },
    {
        "name": "be_class.newobjself#183",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.newobjself(bvm *vm, bclass *c)",
        "snippet": "static binstance* newobjself(bvm *vm, bclass *c)\n{\n    size_t size = sizeof(binstance) + sizeof(bvalue) * (c->nvar - 1);\n    bgcobject *gco = be_newgcobj(vm, BE_INSTANCE, size);\n    binstance *obj = cast_instance(gco);\n    be_assert(obj != NULL);\n    if (obj) { /* initialize members */\n        bvalue *v = obj->members, *end = v + c->nvar;  /* instance variables is a simple array of pointers at obj->members of size c->nvar */\n        while (v < end) { var_setnil(v); ++v; }  /* Initialize all instance variables to `nil` */\n        obj->_class = c;  /* set its class object */\n        obj->super = NULL;  /* no super class instance for now */\n        obj->sub = NULL;  /* no subclass instance for now */\n    }\n    return obj;\n}",
        "begin_line": 183,
        "end_line": 197,
        "is_bug": false
    },
    {
        "name": "be_class.newobject#201",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.newobject(bvm *vm, bclass *c)",
        "snippet": "static binstance* newobject(bvm *vm, bclass *c)\n{\n    binstance *obj, *prev;\n    be_assert(c != NULL);\n    obj = prev = newobjself(vm, c);\n    var_setinstance(vm->top, obj);\n    be_incrtop(vm); /* protect new objects from GC */\n    for (c = c->super; c; c = c->super) {  /* initialize one instance object per class and per superclass */\n        prev->super = newobjself(vm, c);\n        prev->super->sub = prev;  /* link the super/sub classes instances */\n        prev = prev->super;\n    }\n    be_stackpop(vm, 1);\n    return obj;\n}",
        "begin_line": 201,
        "end_line": 215,
        "is_bug": false
    },
    {
        "name": "be_class.be_class_newobj#220",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.be_class_newobj(bvm *vm, bclass *c, bvalue *reg, int argc, int mode)",
        "snippet": "bbool be_class_newobj(bvm *vm, bclass *c, bvalue *reg, int argc, int mode)\n{\n    bvalue init;\n    size_t pos = reg - vm->reg;\n    binstance *obj = newobject(vm, c);  /* create empty object hierarchy from class hierarchy */\n    reg = vm->reg + pos - mode; /* the stack may have changed, mode=1 when class is instanciated from module #104 */\n    var_setinstance(reg, obj);\n    var_setinstance(reg + mode, obj);  /* copy to reg and reg+1 if mode==1 */\n    /* find constructor */\n    obj = instance_member(vm, obj, str_literal(vm, \"init\"), &init);\n    if (obj && var_type(&init) != MT_VARIABLE) {\n        /* copy argv */\n        for (reg = vm->reg + pos + 1; argc > 0; --argc) {\n            reg[argc] = reg[argc - 2];\n        }\n        *reg = init; /* set constructor */\n        return btrue;\n    }\n    return bfalse;\n}",
        "begin_line": 220,
        "end_line": 239,
        "is_bug": false
    },
    {
        "name": "be_class.be_instance_member_simple#248",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.be_instance_member_simple(bvm *vm, binstance *instance, bstring *name, bvalue *dst)",
        "snippet": "int be_instance_member_simple(bvm *vm, binstance *instance, bstring *name, bvalue *dst)\n{\n    int type;\n    be_assert(name != NULL);\n    binstance * obj = instance_member(vm, instance, name, dst);\n    type = var_type(dst);\n    if (obj && type == MT_VARIABLE) {\n        *dst = obj->members[dst->v.i];\n    }\n    return type;\n}",
        "begin_line": 248,
        "end_line": 258,
        "is_bug": false
    },
    {
        "name": "be_class.be_instance_member#264",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.be_instance_member(bvm *vm, binstance *instance, bstring *name, bvalue *dst)",
        "snippet": "int be_instance_member(bvm *vm, binstance *instance, bstring *name, bvalue *dst)\n{\n    int type;\n    be_assert(name != NULL);\n    binstance * obj = instance_member(vm, instance, name, dst);\n    type = var_type(dst);\n    if (obj && type == MT_VARIABLE) {\n        *dst = obj->members[dst->v.i];\n    }\n    if (obj) {\n        return type;\n    } else {  /* if no method found, try virtual */\n        /* if 'init' does not exist, create a virtual empty constructor */\n        if (strcmp(str(name), \"init\") == 0) {\n            var_setntvfunc(dst, default_init_native_method);\n            return var_type(dst);\n        } else {\n            /* get method 'member' */\n            obj = instance_member(vm, instance, str_literal(vm, \"member\"), vm->top);\n            if (obj && basetype(var_type(vm->top)) == BE_FUNCTION) {\n                bvalue *top = vm->top;\n                var_setinstance(&top[1], instance);\n                var_setstr(&top[2], name);\n                vm->top += 3;   /* prevent gc collection results */\n                be_dofunc(vm, top, 2); /* call method 'member' */\n                vm->top -= 3;\n                *dst = *vm->top;   /* copy result to R(A) */\n                if (obj && var_type(dst) == MT_VARIABLE) {\n                    *dst = obj->members[dst->v.i];\n                }\n                type = var_type(dst);\n                if (type != BE_NIL) {\n                    return type;\n                }\n            }\n        }\n    }\n    return BE_NONE;\n}",
        "begin_line": 264,
        "end_line": 302,
        "is_bug": false
    },
    {
        "name": "be_class.be_instance_setmember#317",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.be_instance_setmember(bvm *vm, binstance *o, bstring *name, bvalue *src)",
        "snippet": "bbool be_instance_setmember(bvm *vm, binstance *o, bstring *name, bvalue *src)\n{\n    bvalue v;\n    be_assert(name != NULL);\n    binstance * obj = instance_member(vm, o, name, &v);\n    if (obj && var_istype(&v, MT_VARIABLE)) {\n        obj->members[var_toint(&v)] = *src;\n        return btrue;\n    } else {\n        obj = instance_member(vm, o, str_literal(vm, \"setmember\"), &v);\n        if (obj && var_type(&v) == MT_VARIABLE) {\n            v = obj->members[v.v.i];\n        }\n        if (var_basetype(&v) == BE_FUNCTION) {\n            bvalue *top = vm->top;\n            var_setval(top, &v);\n            var_setinstance(top + 1, o); /* move instance to argv[0] */\n            var_setstr(top + 2, name); /* move method name to argv[1] */\n            var_setval(top + 3, src); /* move method name to argv[1] */\n            vm->top += 4;   /* prevent collection results */\n            be_dofunc(vm, top, 3); /* call method 'member' */\n            vm->top -= 4;\n            return var_tobool(top);\n        }\n    }\n    return bfalse;\n}",
        "begin_line": 317,
        "end_line": 343,
        "is_bug": false
    },
    {
        "name": "be_exec.be_throw#75",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.be_throw(bvm *vm, int errorcode)",
        "snippet": "void be_throw(bvm *vm, int errorcode)\n{\n    if (vm->errjmp) {\n        vm->errjmp->status = errorcode;\n        exec_throw(vm->errjmp);\n    } else {\n        _os_abort();\n    }\n}",
        "begin_line": 75,
        "end_line": 83,
        "is_bug": false
    },
    {
        "name": "be_exec.be_execprotected#106",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.be_execprotected(bvm *vm, bpfunc f, void *data)",
        "snippet": "int be_execprotected(bvm *vm, bpfunc f, void *data)\n{\n    struct blongjmp jmp;\n    jmp.status = 0;\n    jmp.prev = vm->errjmp; /* save long jump position */\n    vm->errjmp = &jmp;\n    exec_try(vm->errjmp) {\n        f(vm, data);\n    }\n    vm->errjmp = jmp.prev; /* restore long jump position */\n    return jmp.status;\n}",
        "begin_line": 106,
        "end_line": 117,
        "is_bug": false
    },
    {
        "name": "be_exec.vm_state_save#119",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.vm_state_save(bvm *vm, struct vmstate *state)",
        "snippet": "static void vm_state_save(bvm *vm, struct vmstate *state)\n{\n    state->depth = be_stack_count(&vm->callstack);\n    state->top = cast_int(vm->top - vm->stack);\n    state->reg = cast_int(vm->reg - vm->stack);\n}",
        "begin_line": 119,
        "end_line": 124,
        "is_bug": false
    },
    {
        "name": "be_exec.copy_exception#126",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.copy_exception(bvm *vm, int res, int dstindex)",
        "snippet": "static void copy_exception(bvm *vm, int res, int dstindex)\n{\n    bvalue *dst = vm->stack + dstindex;\n    if (res == BE_EXCEPTION || res == BE_EXIT) {\n        bvalue *src = vm->top;\n        *dst++ = *src++;\n        if (res == BE_EXCEPTION) {\n            *dst++ = *src++;\n        }\n    }\n    vm->top = dst;\n}",
        "begin_line": 126,
        "end_line": 137,
        "is_bug": false
    },
    {
        "name": "be_exec.vm_state_restore#139",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.vm_state_restore(bvm *vm, const struct vmstate *state, int res)",
        "snippet": "static void vm_state_restore(bvm *vm, const struct vmstate *state, int res)\n{\n    vm->reg = vm->stack + state->reg;\n    /* copy exception information to top */\n    copy_exception(vm, res, state->top);\n    be_assert(be_stack_count(&vm->callstack) >= state->depth);\n    if (be_stack_count(&vm->callstack) > state->depth) {\n        be_vector_resize(vm, &vm->callstack, state->depth);\n        vm->cf = be_stack_top(&vm->callstack);\n    }\n}",
        "begin_line": 139,
        "end_line": 149,
        "is_bug": false
    },
    {
        "name": "be_exec.be_loadmode#254",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.be_loadmode(bvm *vm, const char *name, bbool islocal)",
        "snippet": "BERRY_API int be_loadmode(bvm *vm, const char *name, bbool islocal)\n{\n    int res = load_bytecode(vm, name);\n#if BE_USE_SCRIPT_COMPILER\n    if (res && res != BE_IO_ERROR) {\n        res = fileparser(vm, name, islocal);\n    }\n#else\n    (void)islocal;\n#endif\n    if (res == BE_IO_ERROR) {\n        be_pushfstring(vm, \"cannot open file '%s'.\", name);\n    }\n    return res;\n}",
        "begin_line": 254,
        "end_line": 268,
        "is_bug": false
    },
    {
        "name": "be_exec.m_pcall#293",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.m_pcall(bvm *vm, void *data)",
        "snippet": "static void m_pcall(bvm *vm, void *data)\n{\n    struct pcall *p = cast(struct pcall*, data);\n    be_dofunc(vm, p->v, p->argc);\n}",
        "begin_line": 293,
        "end_line": 297,
        "is_bug": false
    },
    {
        "name": "be_exec.be_protectedcall#300",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.be_protectedcall(bvm *vm, bvalue *v, int argc)",
        "snippet": "int be_protectedcall(bvm *vm, bvalue *v, int argc)\n{\n    int res;\n    struct pcall s;\n    struct vmstate state;\n    s.v = v;\n    s.argc = argc;\n    vm_state_save(vm, &state);\n    res = be_execprotected(vm, m_pcall, &s);\n    if (res) { /* restore call stack */\n        vm_state_restore(vm, &state, res);\n    }\n    return res;\n}",
        "begin_line": 300,
        "end_line": 313,
        "is_bug": false
    },
    {
        "name": "be_exec.be_stackpush#327",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.be_stackpush(bvm *vm)",
        "snippet": "void be_stackpush(bvm *vm)\n{\n    /* make sure there is enough stack space */\n    be_stack_require(vm, 1 + BE_STACK_FREE_MIN);\n    be_incrtop(vm);\n}",
        "begin_line": 327,
        "end_line": 332,
        "is_bug": false
    },
    {
        "name": "be_exec.be_stack_require#335",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.be_stack_require(bvm *vm, int count)",
        "snippet": "void be_stack_require(bvm *vm, int count)\n{\n    if (vm->top + count >= vm->stacktop) {\n        be_stack_expansion(vm, count);\n    }\n}",
        "begin_line": 335,
        "end_line": 340,
        "is_bug": false
    },
    {
        "name": "be_exec.update_callstack#343",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.update_callstack(bvm *vm, intptr_t offset)",
        "snippet": "static void update_callstack(bvm *vm, intptr_t offset)\n{\n    bcallframe *cf = be_stack_top(&vm->callstack);\n    bcallframe *base = be_stack_base(&vm->callstack);\n    for (; cf >= base; --cf) {\n        fixup_ptr(cf->func, offset);\n        fixup_ptr(cf->top, offset);\n        fixup_ptr(cf->reg, offset);\n    }\n    fixup_ptr(vm->top, offset);\n    fixup_ptr(vm->reg, offset);\n}",
        "begin_line": 343,
        "end_line": 354,
        "is_bug": false
    },
    {
        "name": "be_exec.update_upvalues#356",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.update_upvalues(bvm *vm, intptr_t offset)",
        "snippet": "static void update_upvalues(bvm *vm, intptr_t offset)\n{\n    bupval *node = vm->upvalist;\n    /* update the value referenced by open upvalues */\n    for (; node != NULL; node = node->u.next) {\n        fixup_ptr(node->value, offset);\n    }\n}",
        "begin_line": 356,
        "end_line": 363,
        "is_bug": false
    },
    {
        "name": "be_exec.stack_resize#367",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.stack_resize(bvm *vm, size_t size)",
        "snippet": "static void stack_resize(bvm *vm, size_t size)\n{\n    intptr_t offset;\n    bvalue *old = vm->stack;  /* save original pointer of stack before resize */\n    size_t os = (vm->stacktop - old) * sizeof(bvalue);  /* size of current stack allocated in bytes */\n    vm->stack = be_realloc(vm, old, os, sizeof(bvalue) * size);  /* reallocate with the new size */\n    vm->stacktop = vm->stack + size;  /* compute new stacktop */\n    offset = ptr_offset(vm->stack, old);  /* compute the address difference between old and ne stack addresses */\n    /* update callframes */\n    update_callstack(vm, offset);\n    /* update open upvalues */\n    update_upvalues(vm, offset);\n}",
        "begin_line": 367,
        "end_line": 379,
        "is_bug": false
    },
    {
        "name": "be_exec.be_stack_expansion#384",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.be_stack_expansion(bvm *vm, int n)",
        "snippet": "void be_stack_expansion(bvm *vm, int n)\n{\n    size_t size = vm->stacktop - vm->stack;\n    /* check new stack size */\n    if (size + n > BE_STACK_TOTAL_MAX) {\n        /* ensure the stack is enough when generating error messages. */\n        stack_resize(vm, size + 1);\n        be_raise(vm, \"runtime_error\", STACK_OVER_MSG(BE_STACK_TOTAL_MAX));\n    }\n    stack_resize(vm, size + n);\n}",
        "begin_line": 384,
        "end_line": 394,
        "is_bug": false
    },
    {
        "name": "be_exec.be_save_stacktrace#477",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.be_save_stacktrace(bvm *vm)",
        "snippet": "void be_save_stacktrace(bvm *vm)\n{\n    bstack *stack = &vm->tracestack;\n    be_stack_clear(stack);\n    if (be_stack_count(&vm->callstack)) {\n        bcallframe *cf;\n        bcallframe *base = be_stack_base(&vm->callstack);\n        bcallframe *top = be_stack_top(&vm->callstack);\n        for (cf = base; cf <= top; ++cf) {\n            bcallsnapshot *st;\n            be_stack_push(vm, stack, NULL);\n            st = be_stack_top(stack);\n            st->func = *cf->func;\n            st->ip = cf == top ? vm->ip : cf[1].ip;\n        }\n    }\n}",
        "begin_line": 477,
        "end_line": 493,
        "is_bug": false
    }
]