[
    {
        "name": "be_maplib.m_init#25",
        "src_path": "src/be_maplib.c",
        "class_name": "be_maplib",
        "signature": "be_maplib.m_init(bvm *vm)",
        "snippet": "static int m_init(bvm *vm)\n{\n    if (be_top(vm) > 1 && be_ismap(vm, 2)) {\n        be_pushvalue(vm, 2);\n        be_setmember(vm, 1, \".p\");\n    } else {\n        be_newmap(vm);\n        be_setmember(vm, 1, \".p\");\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 25,
        "end_line": 35,
        "is_bug": false
    },
    {
        "name": "be_maplib.push_key#37",
        "src_path": "src/be_maplib.c",
        "class_name": "be_maplib",
        "signature": "be_maplib.push_key(bvm *vm)",
        "snippet": "static void push_key(bvm *vm)\n{\n    be_toescape(vm, -2, 'x'); /* escape string */\n    be_pushvalue(vm, -2); /* push to top */\n    be_strconcat(vm, -5);\n    be_pop(vm, 1);\n}",
        "begin_line": 37,
        "end_line": 43,
        "is_bug": false
    },
    {
        "name": "be_maplib.push_value#45",
        "src_path": "src/be_maplib.c",
        "class_name": "be_maplib",
        "signature": "be_maplib.push_value(bvm *vm)",
        "snippet": "static void push_value(bvm *vm)\n{\n    be_toescape(vm, -1, 'x'); /* escape string */\n    be_strconcat(vm, -4);\n    be_pop(vm, 2);\n    if (be_iter_hasnext(vm, -3)) {\n        be_pushstring(vm, \", \");\n        be_strconcat(vm, -3);\n        be_pop(vm, 1);\n    }\n}",
        "begin_line": 45,
        "end_line": 55,
        "is_bug": false
    },
    {
        "name": "be_maplib.m_tostring#57",
        "src_path": "src/be_maplib.c",
        "class_name": "be_maplib",
        "signature": "be_maplib.m_tostring(bvm *vm)",
        "snippet": "static int m_tostring(bvm *vm)\n{\n    be_getmember(vm, 1, \".p\");\n    map_check_data(vm, 1);\n    map_check_ref(vm);\n    be_refpush(vm, 1);\n    be_pushstring(vm, \"{\");\n    be_pushiter(vm, -2); /* map iterator use 1 register */\n    while (be_iter_hasnext(vm, -3)) {\n        be_iter_next(vm, -3);\n        push_key(vm); /* key.tostring() */\n        be_pushstring(vm, \": \"); /* add ': ' */\n        be_strconcat(vm, -5);\n        be_pop(vm, 1);\n        push_value(vm); /* value.tostring() */\n    }\n    be_pop(vm, 1); /* pop iterator */\n    be_pushstring(vm, \"}\");\n    be_strconcat(vm, -2);\n    be_pop(vm, 1);\n    be_refpop(vm);\n    be_return(vm);\n}",
        "begin_line": 57,
        "end_line": 79,
        "is_bug": false
    },
    {
        "name": "be_maplib.m_remove#81",
        "src_path": "src/be_maplib.c",
        "class_name": "be_maplib",
        "signature": "be_maplib.m_remove(bvm *vm)",
        "snippet": "static int m_remove(bvm *vm)\n{\n    be_getmember(vm, 1, \".p\");\n    map_check_data(vm, 2);\n    be_pushvalue(vm, 2);\n    be_data_remove(vm, -2);\n    be_return_nil(vm);\n}",
        "begin_line": 81,
        "end_line": 88,
        "is_bug": false
    },
    {
        "name": "be_maplib.m_item#90",
        "src_path": "src/be_maplib.c",
        "class_name": "be_maplib",
        "signature": "be_maplib.m_item(bvm *vm)",
        "snippet": "static int m_item(bvm *vm)\n{\n    be_getmember(vm, 1, \".p\");\n    map_check_data(vm, 2);\n    be_pushvalue(vm, 2);\n    if (!be_getindex(vm, -2)) {\n        be_raise(vm, \"key_error\", be_tostring(vm, 2));\n    }\n    be_return(vm);\n}",
        "begin_line": 90,
        "end_line": 99,
        "is_bug": false
    },
    {
        "name": "be_maplib.m_setitem#101",
        "src_path": "src/be_maplib.c",
        "class_name": "be_maplib",
        "signature": "be_maplib.m_setitem(bvm *vm)",
        "snippet": "static int m_setitem(bvm *vm)\n{\n    be_getmember(vm, 1, \".p\");\n    map_check_data(vm, 3);\n    be_pushvalue(vm, 2);\n    be_pushvalue(vm, 3);\n    be_setindex(vm, -3);\n    be_return_nil(vm);\n}",
        "begin_line": 101,
        "end_line": 109,
        "is_bug": false
    },
    {
        "name": "be_maplib.m_find#111",
        "src_path": "src/be_maplib.c",
        "class_name": "be_maplib",
        "signature": "be_maplib.m_find(bvm *vm)",
        "snippet": "static int m_find(bvm *vm)\n{\n    int argc = be_top(vm);\n    be_getmember(vm, 1, \".p\");\n    map_check_data(vm, 2);\n    be_pushvalue(vm, 2);\n    /* not find and has default value */\n    if (!be_getindex(vm, -2) && argc >= 3) {\n        be_pushvalue(vm, 3);\n    }\n    be_return(vm);\n}",
        "begin_line": 111,
        "end_line": 122,
        "is_bug": false
    },
    {
        "name": "be_maplib.m_insert#124",
        "src_path": "src/be_maplib.c",
        "class_name": "be_maplib",
        "signature": "be_maplib.m_insert(bvm *vm)",
        "snippet": "static int m_insert(bvm *vm)\n{\n    bbool res;\n    be_getmember(vm, 1, \".p\");\n    map_check_data(vm, 3);\n    be_pushvalue(vm, 2);\n    be_pushvalue(vm, 3);\n    res = be_data_insert(vm, -3);\n    be_pushbool(vm, res);\n    be_return(vm);\n}",
        "begin_line": 124,
        "end_line": 134,
        "is_bug": false
    },
    {
        "name": "be_maplib.m_size#136",
        "src_path": "src/be_maplib.c",
        "class_name": "be_maplib",
        "signature": "be_maplib.m_size(bvm *vm)",
        "snippet": "static int m_size(bvm *vm)\n{\n    be_getmember(vm, 1, \".p\");\n    map_check_data(vm, 1);\n    be_pushint(vm, be_data_size(vm, -1));\n    be_return(vm);\n}",
        "begin_line": 136,
        "end_line": 142,
        "is_bug": false
    },
    {
        "name": "be_maplib.iter_closure#144",
        "src_path": "src/be_maplib.c",
        "class_name": "be_maplib",
        "signature": "be_maplib.iter_closure(bvm *vm)",
        "snippet": "static int iter_closure(bvm *vm)\n{\n    /* for better performance, we operate the upvalues\n     * directly without using by the stack. */\n    bntvclos *func = var_toobj(vm->cf->func);\n    bvalue *uv0 = be_ntvclos_upval(func, 0)->value; /* list value */\n    bvalue *uv1 = be_ntvclos_upval(func, 1)->value; /* iter value */\n    bmapiter iter = var_toobj(uv1);\n    bmapnode *next = be_map_next(var_toobj(uv0), &iter);\n    if (next == NULL) {\n        be_stop_iteration(vm);\n        be_return_nil(vm); /* will not be executed */\n    }\n    var_setobj(uv1, BE_COMPTR, iter); /* set upvale[1] (iter value) */\n    /* push next value to top */\n    var_setval(vm->top, &next->value);\n    be_incrtop(vm);\n    be_return(vm);\n}",
        "begin_line": 144,
        "end_line": 162,
        "is_bug": false
    },
    {
        "name": "be_maplib.m_iter#164",
        "src_path": "src/be_maplib.c",
        "class_name": "be_maplib",
        "signature": "be_maplib.m_iter(bvm *vm)",
        "snippet": "static int m_iter(bvm *vm)\n{\n    be_pushntvclosure(vm, iter_closure, 2);\n    be_getmember(vm, 1, \".p\");\n    be_setupval(vm, -2, 0);\n    be_pushiter(vm, -1);\n    be_setupval(vm, -3, 1);\n    be_pop(vm, 2);\n    be_return(vm);\n}",
        "begin_line": 164,
        "end_line": 173,
        "is_bug": false
    },
    {
        "name": "be_maplib.keys_iter_closure#175",
        "src_path": "src/be_maplib.c",
        "class_name": "be_maplib",
        "signature": "be_maplib.keys_iter_closure(bvm *vm)",
        "snippet": "static int keys_iter_closure(bvm *vm)\n{\n    /* for better performance, we operate the upvalues\n     * directly without using by the stack. */\n    bntvclos *func = var_toobj(vm->cf->func);\n    bvalue *uv0 = be_ntvclos_upval(func, 0)->value; /* list value */\n    bvalue *uv1 = be_ntvclos_upval(func, 1)->value; /* iter value */\n    bmapiter iter = var_toobj(uv1);\n    bmapnode *next = be_map_next(var_toobj(uv0), &iter);\n    if (next == NULL) {\n        be_stop_iteration(vm);\n        be_return_nil(vm); /* will not be executed */\n    }\n    var_setobj(uv1, BE_COMPTR, iter); /* set upvale[1] (iter value) */\n    /* push next value to top */\n    var_setobj(vm->top, next->key.type, next->key.v.p);\n    be_incrtop(vm);\n    be_return(vm);\n}",
        "begin_line": 175,
        "end_line": 193,
        "is_bug": false
    },
    {
        "name": "be_maplib.m_keys#195",
        "src_path": "src/be_maplib.c",
        "class_name": "be_maplib",
        "signature": "be_maplib.m_keys(bvm *vm)",
        "snippet": "static int m_keys(bvm *vm)\n{\n    be_pushntvclosure(vm, keys_iter_closure, 2);\n    be_getmember(vm, 1, \".p\");\n    be_setupval(vm, -2, 0);\n    be_pushiter(vm, -1);\n    be_setupval(vm, -3, 1);\n    be_pop(vm, 2);\n    be_return(vm);\n}",
        "begin_line": 195,
        "end_line": 204,
        "is_bug": false
    },
    {
        "name": "be_maplib.be_load_maplib#207",
        "src_path": "src/be_maplib.c",
        "class_name": "be_maplib",
        "signature": "be_maplib.be_load_maplib(bvm *vm)",
        "snippet": "void be_load_maplib(bvm *vm)\n{\n    static const bnfuncinfo members[] = {\n        { \".p\", NULL },\n        { \"init\", m_init },\n        { \"tostring\", m_tostring },\n        { \"remove\", m_remove },\n        { \"item\", m_item },\n        { \"setitem\", m_setitem },\n        { \"find\", m_find },\n        { \"size\", m_size },\n        { \"insert\", m_insert },\n        { \"iter\", m_iter },\n        { \"keys\", m_keys },\n        { NULL, NULL }\n    };\n    be_regclass(vm, \"map\", members);\n}",
        "begin_line": 207,
        "end_line": 224,
        "is_bug": false
    },
    {
        "name": "be_baselib.l_assert#21",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.l_assert(bvm *vm)",
        "snippet": "static int l_assert(bvm *vm)\n{\n    int argc = be_top(vm);\n    /* assertion fails when there is no argument\n     * or the first argument is nil or false. */\n    if (!argc || !be_tobool(vm, 1)) {\n        const char *msg = \"assert failed!\";\n        if (argc >= 2 && be_isstring(vm, 2)) {\n            msg = be_tostring(vm, 2);\n        }\n        be_raise(vm, \"assert_failed\", msg);\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 21,
        "end_line": 34,
        "is_bug": false
    },
    {
        "name": "be_baselib.l_print#36",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.l_print(bvm *vm)",
        "snippet": "static int l_print(bvm *vm)\n{\n    int i, argc = be_top(vm);\n    for (i = 1; i <= argc; ++i) {\n        const char *str = be_tostring(vm, i);\n        size_t len = be_strlen(vm, i);\n        be_writebuffer(str, len);\n        if (i < argc) {\n            be_writebuffer(\" \", 1);\n        }\n    }\n    be_writenewline();\n    be_return_nil(vm);\n}",
        "begin_line": 36,
        "end_line": 49,
        "is_bug": false
    },
    {
        "name": "be_baselib.m_readline#51",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.m_readline(bvm *vm)",
        "snippet": "static int m_readline(bvm *vm)\n{\n    size_t pos = 0, size = READLINE_STEP;\n    char *buffer = be_malloc(vm, size);\n    char *res = be_readstring(buffer, (int)size);\n    while (res) {\n        pos += strlen(buffer + pos) - 1;\n        if (!pos || buffer[pos] == '\\n') {\n            buffer[pos] = '\\0'; /* trim \\n */\n            break;\n        }\n        buffer = be_realloc(vm, buffer, size, size + READLINE_STEP);\n        res = be_readstring(buffer + pos + 1, READLINE_STEP);\n        size += READLINE_STEP;\n    }\n    be_pushstring(vm, buffer);\n    be_free(vm, buffer, size);\n    be_return(vm);\n}",
        "begin_line": 51,
        "end_line": 69,
        "is_bug": false
    },
    {
        "name": "be_baselib.l_input#71",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.l_input(bvm *vm)",
        "snippet": "static int l_input(bvm *vm)\n{\n    if (be_top(vm) && be_isstring(vm, 1)) { /* echo prompt */\n        be_writestring(be_tostring(vm, 1));\n    }\n    return m_readline(vm);\n}",
        "begin_line": 71,
        "end_line": 77,
        "is_bug": false
    },
    {
        "name": "be_baselib.find_class_closure#80",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.find_class_closure(bclass *cl, bclosure *needle)",
        "snippet": "static bclass *find_class_closure(bclass *cl, bclosure *needle)\n{\n    while (cl) {\n        bmapnode *node;  /* iterate on members of the class */\n        bmap *members = be_class_members(cl);\n        if (members) {  /* only iterate if there are members */\n            bmapiter iter = be_map_iter();\n            while ((node = be_map_next(members, &iter)) != NULL) {\n                if (var_type(&node->value) == BE_CLOSURE) {  /* only native functions are considered */\n                    bclosure *clos_iter = var_toobj(&node->value);  /* retrieve the method's closure */\n                    if (clos_iter == needle) {\n                        /* we found the closure, we now know its class */\n                        return cl;\n                    }\n                }\n            }\n        }\n        cl = be_class_super(cl);  /* move to super class */\n    }\n    return NULL;  /* not found */\n}",
        "begin_line": 80,
        "end_line": 100,
        "is_bug": false
    },
    {
        "name": "be_baselib.l_super#102",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.l_super(bvm *vm)",
        "snippet": "static int l_super(bvm *vm)\n{\n    int argc = be_top(vm);\n\n    /* if no argument, or arg 1 is nil, return nil */\n    if (argc == 0 || be_isnil(vm, 1)) {\n        be_return_nil(vm);\n    }\n\n    /* if arg 1 is a class, simply return super */\n    if (be_isclass(vm, 1)) {\n        be_getsuper(vm, 1);\n        be_return(vm);\n    }\n\n    /* arg 1 is an instance */\n    if (be_isinstance(vm, 1)) {\n        binstance *o = var_toobj(be_indexof(vm, 1));\n        bclass *target_class = NULL;  /* the minimal class expected, or any super class */\n        bclass *base_class = NULL;  /* current class of the caller, if any */\n\n        /* if arg 2 is present, it must be a class */\n        if (argc >= 2) {\n            if (be_isclass(vm, 2)) {\n                target_class = var_toobj(be_indexof(vm, 2));\n            } else if (be_isnil(vm, 2)) {\n                // ignore, revert to standard super() behavior if second arg is explicit nil\n            } else {\n                be_raise(vm, \"type_error\", \"leveled super() requires 'instance' and 'class' arguments\");\n            }\n        }\n\n        /* now the more complex part, if arg 1 is an instance */\n        /* if instance is the sole argument, try to find if it comes from a method of a class and set 'base_class' accordinly */\n        /* later it will be equivalent to passing this class as second argument */\n        if (argc == 1) {\n            /* we look in the callstack for the caller's closure */\n            int size = be_stack_count(&vm->callstack);\n            if (size >= 2) {  /* need at least 2 stackframes: current (for super() native) and caller (the one we are interested in) */\n                bcallframe *caller = be_vector_at(&vm->callstack, size - 2);  /* get the callframe of caller */\n                bvalue *func = caller->func;  /* function object of caller */\n                if (var_type(func) == BE_CLOSURE) {  /* only useful if the caller is a Berry closure (i.e. not native) */\n                    bclosure *clos_ctx = var_toobj(func);  /* this is the closure we look for in the class chain */\n                    base_class = find_class_closure(o->_class, clos_ctx);  /* iterate on current and super classes to find where the closure belongs */\n                }\n            }\n        }\n\n        if (base_class || target_class) {\n            if (base_class) {\n                target_class = base_class->super;\n                if (!target_class) be_return_nil(vm);   /* fast exit if top class */\n            }\n            /* leveled super, i.e. fix the parenthood class level */\n            if (o) {\n                o = be_instance_super(o);   /* always skip the current class and move to super */\n            }\n            while (o) {\n                bclass *c = be_instance_class(o);\n                if (c == target_class) break;         /* found */\n                o = be_instance_super(o);\n            }\n            bvalue *top = be_incrtop(vm);\n            if (o) {\n                var_setinstance(top, o);    /* return the instance with the specified parent class */\n            } else {\n                var_setnil(top);            /* not found, return nil */\n            }\n            be_return(vm);\n        } else {\n            be_getsuper(vm, 1);\n            be_return(vm);\n        }\n    }\n\n    /* fall through, return nil if we don't know what to do */\n    be_return_nil(vm);\n}",
        "begin_line": 102,
        "end_line": 179,
        "is_bug": false
    },
    {
        "name": "be_baselib.l_type#181",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.l_type(bvm *vm)",
        "snippet": "static int l_type(bvm *vm)\n{\n    if (be_top(vm)) {\n        be_pushstring(vm, be_typename(vm, 1));\n        be_return(vm);\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 181,
        "end_line": 188,
        "is_bug": false
    },
    {
        "name": "be_baselib.l_classname#190",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.l_classname(bvm *vm)",
        "snippet": "static int l_classname(bvm *vm)\n{\n    if (be_top(vm)) {\n        const char *t = be_classname(vm, 1);\n        if (t) {\n            be_pushstring(vm, t);\n            be_return(vm);\n        }\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 190,
        "end_line": 200,
        "is_bug": false
    },
    {
        "name": "be_baselib.l_classof#202",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.l_classof(bvm *vm)",
        "snippet": "static int l_classof(bvm *vm)\n{\n    if (be_top(vm) && be_classof(vm, 1)) {\n        be_return(vm);\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 202,
        "end_line": 208,
        "is_bug": false
    },
    {
        "name": "be_baselib.l_number#210",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.l_number(bvm *vm)",
        "snippet": "static int l_number(bvm *vm)\n{\n    if (be_top(vm)) {\n        if (be_isstring(vm, 1)) {\n            be_str2num(vm, be_tostring(vm, 1));\n            be_return(vm);\n        } else if (be_isnumber(vm, 1)) {\n            be_pushvalue(vm, 1);\n            be_return(vm);\n        }\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 210,
        "end_line": 222,
        "is_bug": false
    },
    {
        "name": "be_baselib.l_int#224",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.l_int(bvm *vm)",
        "snippet": "static int l_int(bvm *vm)\n{\n    if (be_top(vm)) {\n        if (be_isstring(vm, 1)) {\n            const char *s = be_tostring(vm, 1);\n            be_pushint(vm, be_str2int(s, NULL));\n        } else if (be_isreal(vm, 1)) {\n            be_pushint(vm, (bint)be_toreal(vm, 1));\n        } else if (be_isint(vm, 1)) {\n            be_pushvalue(vm, 1);\n        } else {\n            be_return_nil(vm);\n        }\n        be_return(vm);\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 224,
        "end_line": 240,
        "is_bug": false
    },
    {
        "name": "be_baselib.l_real#242",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.l_real(bvm *vm)",
        "snippet": "static int l_real(bvm *vm)\n{\n    if (be_top(vm)) {\n        if (be_isstring(vm, 1)) {\n            const char *s = be_tostring(vm, 1);\n            be_pushreal(vm, be_str2real(s, NULL));\n        } else if (be_isint(vm, 1)) {\n            be_pushreal(vm, (breal)be_toint(vm, 1));\n        } else if (be_isreal(vm, 1)) {\n            be_pushvalue(vm, 1);\n        } else {\n            be_return_nil(vm);\n        }\n        be_return(vm);\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 242,
        "end_line": 258,
        "is_bug": false
    },
    {
        "name": "be_baselib.check_method#260",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.check_method(bvm *vm, const char *attr)",
        "snippet": "static int check_method(bvm *vm, const char *attr)\n{\n    return be_top(vm) &&\n        be_isinstance(vm, 1) && be_getmethod(vm, 1, attr);\n}",
        "begin_line": 260,
        "end_line": 264,
        "is_bug": false
    },
    {
        "name": "be_baselib.l_iterator#266",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.l_iterator(bvm *vm)",
        "snippet": "static int l_iterator(bvm *vm)\n{\n    if (be_top(vm) && be_isfunction(vm, 1)) {\n        be_return(vm); /* return the argument[0]::function */\n    }\n    if (check_method(vm, \"iter\")) {\n        be_pushvalue(vm, 1);\n        be_call(vm, 1);\n        be_pop(vm, 1);\n        be_return(vm);\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 266,
        "end_line": 278,
        "is_bug": false
    },
    {
        "name": "be_baselib.l_call#285",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.l_call(bvm *vm)",
        "snippet": "static int l_call(bvm *vm)\n{\n    int top = be_top(vm);\n    if (top >= 1 && be_isfunction(vm, 1)) {\n        size_t arg_count = top - 1;  /* we have at least 'top - 1' arguments */\n        /* test if last argument is a list */\n\n        if (top > 1 && be_isinstance(vm, top) && be_getmember(vm, top, \".p\") && be_islist(vm, top + 1)) {\n            int32_t list_size = be_data_size(vm, top + 1);\n\n            if (list_size > 0) {\n                be_stack_require(vm, list_size + 3);   /* make sure we don't overflow the stack */\n                for (int i = 0; i < list_size; i++) {\n                    be_pushnil(vm);\n                }\n                be_moveto(vm, top + 1, top + 1 + list_size);\n                be_moveto(vm, top, top + list_size);\n\n                be_refpush(vm, -2);\n                be_pushiter(vm, -1);\n                while (be_iter_hasnext(vm, -2)) {\n                    be_iter_next(vm, -2);\n                    be_moveto(vm, -1, top);\n                    top++;\n                    be_pop(vm, 1);\n                }\n                be_pop(vm, 1);  /* remove iterator */\n                be_refpop(vm);\n            }\n            be_pop(vm, 2);\n            arg_count = arg_count - 1 + list_size;\n        }\n        /* actual call */\n        be_call(vm, arg_count);\n        /* remove args */\n        be_pop(vm, arg_count);\n        /* return value */\n\n        be_return(vm);\n    }\n    be_raise(vm, \"value_error\", \"first argument must be a function\");\n    be_return_nil(vm);\n}",
        "begin_line": 285,
        "end_line": 327,
        "is_bug": false
    },
    {
        "name": "be_baselib.l_str#329",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.l_str(bvm *vm)",
        "snippet": "static int l_str(bvm *vm)\n{\n    if (be_top(vm)) {\n        be_tostring(vm, 1);\n    } else {\n        be_pushstring(vm, \"\");\n    }\n    be_return(vm);\n}",
        "begin_line": 329,
        "end_line": 337,
        "is_bug": false
    },
    {
        "name": "be_baselib.l_size#339",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.l_size(bvm *vm)",
        "snippet": "static int l_size(bvm *vm)\n{\n    if (be_top(vm) && be_isstring(vm, 1)) {\n        be_pushint(vm, be_strlen(vm, 1));\n        be_return(vm);\n    }\n    if (check_method(vm, \"size\")) {\n        be_pushvalue(vm, 1);\n        be_call(vm, 1);\n        be_pop(vm, 1);\n        be_return(vm);\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 339,
        "end_line": 352,
        "is_bug": false
    },
    {
        "name": "be_baselib.l_module#354",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.l_module(bvm *vm)",
        "snippet": "static int l_module(bvm *vm)\n{\n    int argc = be_top(vm);\n    be_newmodule(vm);\n    if (argc > 0 && be_isstring(vm, 1)) {\n        be_setname(vm, -1, be_tostring(vm, 1));\n    }\n    be_return(vm);\n}",
        "begin_line": 354,
        "end_line": 362,
        "is_bug": false
    },
    {
        "name": "be_baselib.l_compile#397",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.l_compile(bvm *vm)",
        "snippet": "static int l_compile(bvm *vm)\n{\n#if BE_USE_SCRIPT_COMPILER\n    if (be_top(vm) && be_isstring(vm, 1)) {\n        if (be_top(vm) >= 2 && be_isstring(vm, 2)) {\n            const char *s = be_tostring(vm, 2);\n            if (!strcmp(s, \"string\")) {\n                return m_compile_str(vm);\n            }\n            if (!strcmp(s, \"file\")) {\n                return m_compile_file(vm);\n            }\n        } else {\n            return m_compile_str(vm);\n        }\n    }\n#endif\n    be_return_nil(vm);\n}",
        "begin_line": 397,
        "end_line": 415,
        "is_bug": false
    },
    {
        "name": "be_baselib._issubv#417",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib._issubv(bvm *vm, bbool (*filter)(bvm*, int))",
        "snippet": "static int _issubv(bvm *vm, bbool (*filter)(bvm*, int))\n{\n    bbool status = bfalse;\n    if (be_top(vm) >= 2 && filter(vm, 1)) {\n        be_pushvalue(vm, 2);\n        status = be_isderived(vm, 1);\n    }\n    be_pushbool(vm, status);\n    be_return(vm);\n}",
        "begin_line": 417,
        "end_line": 426,
        "is_bug": false
    },
    {
        "name": "be_baselib.l_issubclass#428",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.l_issubclass(bvm *vm)",
        "snippet": "static int l_issubclass(bvm *vm)\n{\n    return _issubv(vm, be_isclass);\n}",
        "begin_line": 428,
        "end_line": 431,
        "is_bug": false
    },
    {
        "name": "be_baselib.l_isinstance#433",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.l_isinstance(bvm *vm)",
        "snippet": "static int l_isinstance(bvm *vm)\n{\n    return _issubv(vm, be_isinstance);\n}",
        "begin_line": 433,
        "end_line": 436,
        "is_bug": false
    },
    {
        "name": "be_baselib.be_load_baselib#439",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.be_load_baselib(bvm *vm)",
        "snippet": "void be_load_baselib(bvm *vm)\n{\n    be_regfunc(vm, \"assert\", l_assert);\n    be_regfunc(vm, \"print\", l_print);\n    be_regfunc(vm, \"input\", l_input);\n    be_regfunc(vm, \"super\", l_super);\n    be_regfunc(vm, \"type\", l_type);\n    be_regfunc(vm, \"classname\", l_classname);\n    be_regfunc(vm, \"classof\", l_classof);\n    be_regfunc(vm, \"number\", l_number);\n    be_regfunc(vm, \"str\", l_str);\n    be_regfunc(vm, \"int\", l_int);\n    be_regfunc(vm, \"real\", l_real);\n    be_regfunc(vm, \"module\", l_module);\n    be_regfunc(vm, \"size\", l_size);\n    be_regfunc(vm, \"compile\", l_compile);\n    be_regfunc(vm, \"issubclass\", l_issubclass);\n    be_regfunc(vm, \"isinstance\", l_isinstance);\n    be_regfunc(vm, \"__iterator__\", l_iterator);\n}",
        "begin_line": 439,
        "end_line": 458,
        "is_bug": false
    },
    {
        "name": "be_baselib.be_load_baselib_call#461",
        "src_path": "src/be_baselib.c",
        "class_name": "be_baselib",
        "signature": "be_baselib.be_load_baselib_call(bvm *vm)",
        "snippet": "void be_load_baselib_call(bvm *vm)\n{\n    be_regfunc(vm, \"call\", l_call);\n}",
        "begin_line": 461,
        "end_line": 464,
        "is_bug": false
    },
    {
        "name": "be_object.be_vtype2str#16",
        "src_path": "src/be_object.c",
        "class_name": "be_object",
        "signature": "be_object.be_vtype2str(bvalue *v)",
        "snippet": "const char* be_vtype2str(bvalue *v)\n{\n    switch(var_type(v)) {\n    case BE_NIL: return \"nil\";\n    case BE_INT: return \"int\";\n    case BE_REAL: return \"real\";\n    case BE_BOOL: return \"bool\";\n    case BE_CLOSURE: case BE_NTVCLOS:\n    case BE_NTVFUNC: return \"function\";\n    case BE_PROTO: return \"proto\";\n    case BE_CLASS: return \"class\";\n    case BE_STRING: return \"string\";\n    case BE_LIST: return \"list\";\n    case BE_MAP: return \"map\";\n    case BE_INSTANCE: return \"instance\";\n    case BE_MODULE: return \"module\";\n    case BE_INDEX: return \"var\";\n    default: return \"invalid type\";\n    }\n}",
        "begin_line": 16,
        "end_line": 35,
        "is_bug": false
    },
    {
        "name": "be_object.be_indexof#37",
        "src_path": "src/be_object.c",
        "class_name": "be_object",
        "signature": "be_object.be_indexof(bvm *vm, int idx)",
        "snippet": "bvalue* be_indexof(bvm *vm, int idx)\n{\n    if (idx > 0) { /* absolute index */\n        be_assert(vm->reg + idx <= vm->top);\n        return vm->reg + idx - 1;\n    }\n    /* relative index */\n    be_assert(vm->top + idx >= vm->reg);\n    return vm->top + idx;\n}",
        "begin_line": 37,
        "end_line": 46,
        "is_bug": false
    },
    {
        "name": "be_object.be_newcomobj#48",
        "src_path": "src/be_object.c",
        "class_name": "be_object",
        "signature": "be_object.be_newcomobj(bvm *vm, void *data, bntvfunc destory)",
        "snippet": "BERRY_API void be_newcomobj(bvm *vm, void *data, bntvfunc destory)\n{\n    bcommomobj *obj;\n    bgcobject *gco = be_gcnew(vm, BE_COMOBJ, bcommomobj);\n    if ((obj = cast_comobj(gco)) != NULL) {\n        bvalue* top = be_incrtop(vm);\n        obj->data = data;\n        obj->destory = destory;\n        var_setobj(top, BE_COMOBJ, obj);\n    }\n}",
        "begin_line": 48,
        "end_line": 58,
        "is_bug": false
    },
    {
        "name": "be_object.be_commonobj_delete#60",
        "src_path": "src/be_object.c",
        "class_name": "be_object",
        "signature": "be_object.be_commonobj_delete(bvm *vm, bgcobject *obj)",
        "snippet": "void be_commonobj_delete(bvm *vm, bgcobject *obj)\n{\n    bcommomobj *co = cast_comobj(obj);\n    if (co) {\n        if (co->destory && co->data) {\n            be_pushntvfunction(vm, co->destory);\n            be_pushcomptr(vm, co->data);\n            be_call(vm, 1);\n            be_pop(vm, 2);\n        }\n        be_free(vm, co, sizeof(bcommomobj));\n    }\n}",
        "begin_line": 60,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "be_map.map_nextsize#36",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.map_nextsize(int size)",
        "snippet": "static int map_nextsize(int size)\n{\n    be_assert(size < LASTNODE);\n    if (size < LASTNODE) {\n        return be_nextsize(size);\n    }\n    return LASTNODE + 1;\n}",
        "begin_line": 36,
        "end_line": 43,
        "is_bug": false
    },
    {
        "name": "be_map.hashptr#45",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.hashptr(void *p)",
        "snippet": "static uint32_t hashptr(void *p)\n{\n    uintptr_t i = (uintptr_t)p;\n    return (uint32_t)((i ^ (i >> 16)) & 0xFFFFFFFF);\n}",
        "begin_line": 45,
        "end_line": 49,
        "is_bug": false
    },
    {
        "name": "be_map.hashreal#54",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.hashreal(union bvaldata v)",
        "snippet": "static uint32_t hashreal(union bvaldata v)\n{\n    union { breal r; uint32_t i[2]; } u;\n    u.r = v.r;\n    return u.i[0] ^ u.i[1];\n}",
        "begin_line": 54,
        "end_line": 59,
        "is_bug": false
    },
    {
        "name": "be_map._hashcode#84",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map._hashcode(bvm *vm, int type, union bvaldata v)",
        "snippet": "static uint32_t _hashcode(bvm *vm, int type, union bvaldata v)\n{\n    (void)vm;\n    switch (type) {\n    case BE_NIL: return 0;\n    case BE_BOOL: return (uint32_t)v.b;\n    case BE_INT: return (uint32_t)v.i;\n    case BE_REAL: return hashreal(v);\n    case BE_STRING: return be_strhash(v.s);\n#if BE_USE_OVERLOAD_HASH\n    case BE_INSTANCE: return hashins(vm, v.p);\n#endif\n    default: return hashptr(v.p);\n    }\n}",
        "begin_line": 84,
        "end_line": 98,
        "is_bug": false
    },
    {
        "name": "be_map.eqnode#100",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.eqnode(bvm *vm, bmapnode *node, bvalue *key, uint32_t hash)",
        "snippet": "static int eqnode(bvm *vm, bmapnode *node, bvalue *key, uint32_t hash)\n{\n    (void)vm;\n    if (!var_isnil(key)) {\n        bmapkey *k = key(node);\n#if BE_USE_OVERLOAD_HASH\n        if (var_isinstance(key)) {\n            bvalue kv;\n            kv.type = k->type;\n            kv.v = k->v;\n            return be_vm_iseq(vm, key, &kv);\n        }\n#endif\n        if(keytype(k) == key->type && hashcode(k) == hash) {\n            switch (key->type) {\n            case BE_INT: return var_toint(key) == var_toint(k);\n            case BE_REAL: return var_toreal(key) == var_toreal(k);\n            case BE_STRING: return be_eqstr(var_tostr(key), var_tostr(k));\n            default: return var_toobj(key) == var_toobj(k);\n            }\n        }\n    }\n    return 0;\n}",
        "begin_line": 100,
        "end_line": 123,
        "is_bug": false
    },
    {
        "name": "be_map.findprev#125",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.findprev(bmap *map, bmapnode *list, bmapnode *slot)",
        "snippet": "static bmapnode* findprev(bmap *map, bmapnode *list, bmapnode *slot)\n{\n    int n, pos = pos(map, slot);\n    bmapnode *prev = list;\n    for (;;) {\n        n = next(prev);\n        if (n == pos || n == LASTNODE) {\n            break;\n        }\n        prev = map->slots + n;\n    }\n    return n == pos ? prev : NULL;\n}",
        "begin_line": 125,
        "end_line": 137,
        "is_bug": false
    },
    {
        "name": "be_map.nextfree#139",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.nextfree(bmap *map)",
        "snippet": "static bmapnode* nextfree(bmap *map)\n{\n    bmapnode *base = map->slots;\n    while (map->lastfree >= base) {\n        if (isnil(map->lastfree)) {\n            return map->lastfree;\n        }\n        --map->lastfree;\n    }\n    return NULL;\n}",
        "begin_line": 139,
        "end_line": 149,
        "is_bug": false
    },
    {
        "name": "be_map.insert#151",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.insert(bvm *vm, bmap *map, bvalue *key, uint32_t hash)",
        "snippet": "static bmapnode* insert(bvm *vm, bmap *map, bvalue *key, uint32_t hash)\n{\n    bmapnode *slot = hash2slot(map, hash);\n    if (isnil(slot)) { /* empty slot */\n        setkey(slot, key);\n        next(slot) = LASTNODE;\n    } else {\n        uint32_t h = hashcode(key(slot)); /* get the hashcode of the exist node */\n        bmapnode *mainslot = hash2slot(map, h); /* get the main-slot */\n        bmapnode *new = nextfree(map); /* get a free slot */\n        if (mainslot == slot) { /* old is main slot */\n            /* insert in first */\n            setkey(new, key);\n            next(new) = next(slot);\n            next(slot) = pos(map, new);\n            slot = new;\n        } else {\n            bmapnode *prev = findprev(map, mainslot, slot);\n            next(prev) = pos(map, new); /* link the previous node */\n            *new = *slot; /* copy to new slot */\n            setkey(slot, key);\n            next(slot) = LASTNODE;\n        }\n    }\n    return slot;\n}",
        "begin_line": 151,
        "end_line": 176,
        "is_bug": false
    },
    {
        "name": "be_map.find#178",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.find(bvm *vm, bmap *map, bvalue *key, uint32_t hash)",
        "snippet": "static bmapnode* find(bvm *vm, bmap *map, bvalue *key, uint32_t hash)\n{\n    bmapnode *slot = hash2slot(map, hash);\n    if (isnil(slot)) {\n        return NULL;\n    }\n    while (!eqnode(vm, slot, key, hash)) {\n        int n = next(slot);\n        if (n == LASTNODE) {\n            return NULL;\n        }\n        slot = map->slots + n;\n    }\n    return slot;\n}",
        "begin_line": 178,
        "end_line": 192,
        "is_bug": false
    },
    {
        "name": "be_map.resize#194",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.resize(bvm *vm, bmap *map, int size)",
        "snippet": "static void resize(bvm *vm, bmap *map, int size)\n{\n    int i, oldsize;\n    bmapnode *slots, *oldslots;\n    if (size < map->count) {\n        return;\n    }\n    oldsize = map->size;\n    oldslots = map->slots;\n    slots = be_malloc(vm, datasize(size));\n    for (i = 0; i < size; ++i) {\n        setnil(slots + i);\n    }\n    map->size = size;\n    map->slots = slots;\n    map->lastfree = slots + size - 1;\n    /* rehash */\n    for (i = 0; i < oldsize; ++i) {\n        bmapnode *node = oldslots + i;\n        if (!isnil(node)) {\n            bvalue v;\n            bmapnode *newslot;\n            v.type = node->key.type;\n            v.v = node->key.v;\n            newslot = insert(vm, map, &v, hashcode(&v));\n            newslot->value = node->value;\n        }\n    }\n    be_free(vm, oldslots, datasize(oldsize));\n}",
        "begin_line": 194,
        "end_line": 223,
        "is_bug": false
    },
    {
        "name": "be_map.be_map_new#225",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.be_map_new(bvm *vm)",
        "snippet": "bmap* be_map_new(bvm *vm)\n{\n    bgcobject *gco = be_gcnew(vm, BE_MAP, bmap);\n    bmap *map = cast_map(gco);\n    if (map) {\n        map->size = 0;\n        map->count = 0;\n        map->slots = NULL;\n        var_setmap(vm->top, map);\n        be_incrtop(vm);\n        resize(vm, map, 2);\n        be_stackpop(vm, 1);\n    }\n    return map;\n}",
        "begin_line": 225,
        "end_line": 239,
        "is_bug": false
    },
    {
        "name": "be_map.be_map_delete#241",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.be_map_delete(bvm *vm, bmap *map)",
        "snippet": "void be_map_delete(bvm *vm, bmap *map)\n{\n    be_free(vm, map->slots, datasize(map->size));\n    be_free(vm, map, sizeof(bmap));\n}",
        "begin_line": 241,
        "end_line": 245,
        "is_bug": false
    },
    {
        "name": "be_map.be_map_find#247",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.be_map_find(bvm *vm, bmap *map, bvalue *key)",
        "snippet": "bvalue* be_map_find(bvm *vm, bmap *map, bvalue *key)\n{\n    bmapnode *entry = find(vm, map, key, hashcode(key));\n    return entry ? value(entry) : NULL;\n}",
        "begin_line": 247,
        "end_line": 251,
        "is_bug": false
    },
    {
        "name": "be_map.be_map_insert#253",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.be_map_insert(bvm *vm, bmap *map, bvalue *key, bvalue *value)",
        "snippet": "bvalue* be_map_insert(bvm *vm, bmap *map, bvalue *key, bvalue *value)\n{\n    uint32_t hash = hashcode(key);\n    bmapnode *entry = find(vm, map, key, hash);\n    if (!entry) { /* new entry */\n        if (map->count >= map->size) {\n            resize(vm, map, map_nextsize(map->size));\n        }\n        entry = insert(vm, map, key, hash);\n        ++map->count;\n    }\n    if (value) {\n        entry->value = *value;\n    }\n    return value(entry);\n}",
        "begin_line": 253,
        "end_line": 268,
        "is_bug": false
    },
    {
        "name": "be_map.be_map_remove#270",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.be_map_remove(bvm *vm, bmap *map, bvalue *key)",
        "snippet": "int be_map_remove(bvm *vm, bmap *map, bvalue *key)\n{\n    uint32_t hash = hashcode(key);\n    bmapnode *slot = hash2slot(map, hash); /* main slot */\n\n    if (eqnode(vm, slot, key, hash)) { /* first node */\n        bmapnode *next = pos2slot(map, next(slot));\n        if (next) { /* has next */\n            *slot = *next; /* first: copy the second node to the slot */\n            slot = next; /* second: set the second node to nil (empty) */\n        }\n    } else { /* the node will be remove is not first-node */\n        bmapnode *prev = slot;\n        for (;;) { /* find the previous node */\n            int n = next(prev);\n            slot = pos2slot(map, n);\n            if (slot == NULL) { /* node not found */\n                return bfalse;\n            }\n            if (eqnode(vm, slot, key, hash)) {\n                break;\n            }\n            prev = slot;\n        }\n        /* link the list */\n        next(prev) = next(slot);\n    }\n    /* set to nil */\n    setnil(slot);\n    /* add to lastfree */\n    if (map->lastfree < slot) {\n        map->lastfree = slot;\n    }\n    --map->count;\n    return btrue;\n}",
        "begin_line": 270,
        "end_line": 305,
        "is_bug": false
    },
    {
        "name": "be_map.be_map_findstr#307",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.be_map_findstr(bvm *vm, bmap *map, bstring *key)",
        "snippet": "bvalue* be_map_findstr(bvm *vm, bmap *map, bstring *key)\n{\n    bvalue v;\n    var_setstr(&v, key);\n    return be_map_find(vm, map, &v);\n}",
        "begin_line": 307,
        "end_line": 312,
        "is_bug": false
    },
    {
        "name": "be_map.be_map_insertstr#314",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.be_map_insertstr(bvm *vm, bmap *map, bstring *key, bvalue *value)",
        "snippet": "bvalue* be_map_insertstr(bvm *vm, bmap *map, bstring *key, bvalue *value)\n{\n    bvalue v;\n    var_setstr(&v, key);\n    set_fixed(key);\n    bvalue * r = be_map_insert(vm, map, &v, value);\n    restore_fixed(key);\n    return r;\n}",
        "begin_line": 314,
        "end_line": 322,
        "is_bug": false
    },
    {
        "name": "be_map.be_map_removestr#324",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.be_map_removestr(bvm *vm, bmap *map, bstring *key)",
        "snippet": "void be_map_removestr(bvm *vm, bmap *map, bstring *key)\n{\n    bvalue v;\n    var_setstr(&v, key);\n    be_map_remove(vm, map, &v);\n}",
        "begin_line": 324,
        "end_line": 329,
        "is_bug": false
    },
    {
        "name": "be_map.be_map_next#331",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.be_map_next(bmap *map, bmapiter *iter)",
        "snippet": "bmapnode* be_map_next(bmap *map, bmapiter *iter)\n{\n    bmapnode *end = map->slots + map->size;\n    *iter = *iter ? *iter + 1 : map->slots;\n    while (*iter < end && isnil(*iter)) {\n        ++(*iter);\n    }\n    return *iter < end ? *iter : NULL;\n}",
        "begin_line": 331,
        "end_line": 339,
        "is_bug": false
    },
    {
        "name": "be_map.be_map_val2node#341",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.be_map_val2node(bvalue *value)",
        "snippet": "bmapnode* be_map_val2node(bvalue *value)\n{\n    return (bmapnode *)((size_t)value - sizeof(bmapkey));\n}",
        "begin_line": 341,
        "end_line": 344,
        "is_bug": false
    },
    {
        "name": "be_map.be_map_release#346",
        "src_path": "src/be_map.c",
        "class_name": "be_map",
        "signature": "be_map.be_map_release(bvm *vm, bmap *map)",
        "snippet": "void be_map_release(bvm *vm, bmap *map)\n{\n    (void)vm;\n    resize(vm, map, map->count ? map->count : 1);\n}",
        "begin_line": 346,
        "end_line": 350,
        "is_bug": false
    },
    {
        "name": "be_libs.be_loadlibs#18",
        "src_path": "src/be_libs.c",
        "class_name": "be_libs",
        "signature": "be_libs.be_loadlibs(bvm *vm)",
        "snippet": "void be_loadlibs(bvm *vm)\n{\n    be_load_baselib(vm);\n#if !BE_USE_PRECOMPILED_OBJECT\n    be_load_listlib(vm);\n    be_load_maplib(vm);\n    be_load_rangelib(vm);\n    be_load_filelib(vm);\n    be_load_byteslib(vm);\n    be_load_baselib_call(vm);\n#endif\n}",
        "begin_line": 18,
        "end_line": 29,
        "is_bug": false
    },
    {
        "name": "be_vector.be_vector_init#15",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.be_vector_init(bvm *vm, bvector *vector, int size)",
        "snippet": "void be_vector_init(bvm *vm, bvector *vector, int size)\n{\n    vector->capacity = 2; /* the default capacity */\n    vector->size = size;\n    vector->count = 0;\n    vector->data = be_malloc(vm, (size_t)vector->capacity * size);\n    vector->end = (char*)vector->data - size;\n    memset(vector->data, 0, (size_t)vector->capacity * size);\n}",
        "begin_line": 15,
        "end_line": 23,
        "is_bug": false
    },
    {
        "name": "be_vector.be_vector_delete#25",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.be_vector_delete(bvm *vm, bvector *vector)",
        "snippet": "void be_vector_delete(bvm *vm, bvector *vector)\n{\n    be_free(vm, vector->data, (size_t)vector->capacity * vector->size);\n}",
        "begin_line": 25,
        "end_line": 28,
        "is_bug": false
    },
    {
        "name": "be_vector.be_vector_at#30",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.be_vector_at(bvector *vector, int index)",
        "snippet": "void* be_vector_at(bvector *vector, int index)\n{\n    return (char*)vector->data + (size_t)index * vector->size;\n}",
        "begin_line": 30,
        "end_line": 33,
        "is_bug": false
    },
    {
        "name": "be_vector.be_vector_push#35",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.be_vector_push(bvm *vm, bvector *vector, void *data)",
        "snippet": "void be_vector_push(bvm *vm, bvector *vector, void *data)\n{\n    size_t size = vector->size;\n    size_t capacity = vector->capacity;\n    size_t count = vector->count++;\n    if (count >= capacity) {\n        int newcap = be_nextsize(vector->capacity);\n        vector->data = be_realloc(vm,\n                vector->data, vector->capacity * size, newcap * size);\n        vector->end = (char*)vector->data + count * size;\n        vector->capacity = newcap;\n    } else {\n        vector->end = (char*)vector->end + size;\n    }\n    if (data != NULL) {\n        memcpy(vector->end, data, size);\n    }\n}",
        "begin_line": 35,
        "end_line": 52,
        "is_bug": false
    },
    {
        "name": "be_vector.be_vector_push_c#55",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.be_vector_push_c(bvm *vm, bvector *vector, void *data)",
        "snippet": "void be_vector_push_c(bvm *vm, bvector *vector, void *data)\n{\n    int capacity = vector->capacity + 1;\n    be_vector_push(vm, vector, data);\n    if (vector->capacity > capacity) {\n        size_t size = ((size_t)vector->capacity - capacity) * vector->size;\n        memset(be_vector_at(vector, capacity), 0, size);\n    }\n}",
        "begin_line": 55,
        "end_line": 63,
        "is_bug": false
    },
    {
        "name": "be_vector.be_vector_remove_end#65",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.be_vector_remove_end(bvector *vector)",
        "snippet": "void be_vector_remove_end(bvector *vector)\n{\n    be_assert(vector->count > 0);\n    vector->count--;\n    vector->end = (char*)vector->end - vector->size;\n}",
        "begin_line": 65,
        "end_line": 70,
        "is_bug": false
    },
    {
        "name": "be_vector.be_vector_resize#72",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.be_vector_resize(bvm *vm, bvector *vector, int count)",
        "snippet": "void be_vector_resize(bvm *vm, bvector *vector, int count)\n{\n    size_t size = vector->size;\n    be_assert(count >= 0);\n    if (count != be_vector_count(vector)) {\n        int newcap = be_nextsize(count);\n        if (newcap > vector->capacity) { /* extended capacity */\n            vector->data = be_realloc(vm,\n                vector->data, vector->capacity * size, newcap * size);\n            vector->capacity = newcap;\n        }\n        vector->count = count;\n        vector->end = (char*)vector->data + size * ((size_t)count - 1);\n    }\n}",
        "begin_line": 72,
        "end_line": 86,
        "is_bug": false
    },
    {
        "name": "be_vector.be_vector_clear#88",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.be_vector_clear(bvector *vector)",
        "snippet": "void be_vector_clear(bvector *vector)\n{\n    vector->count = 0;\n    vector->end = (char*)vector->data - vector->size;\n}",
        "begin_line": 88,
        "end_line": 92,
        "is_bug": false
    },
    {
        "name": "be_vector.be_vector_release#95",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.be_vector_release(bvm *vm, bvector *vector)",
        "snippet": "void* be_vector_release(bvm *vm, bvector *vector)\n{\n    size_t size = vector->size;\n    int count = be_vector_count(vector);\n    if (count == 0) {\n        be_free(vm, vector->data, vector->capacity * size);\n        vector->capacity = 0;\n        vector->data = NULL;\n        vector->end = NULL;\n    } else if (count < vector->capacity) {\n        vector->data = be_realloc(vm,\n            vector->data, vector->capacity * size, count * size);\n        vector->end = (char*)vector->data + ((size_t)count - 1) * size;\n        vector->capacity = count;\n    }\n    return vector->data;\n}",
        "begin_line": 95,
        "end_line": 111,
        "is_bug": false
    },
    {
        "name": "be_vector.binary_search#114",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.binary_search(int value)",
        "snippet": "static int binary_search(int value)\n{\n    static const uint16_t tab[] = {\n        0, 2, 4, 6, 8, 10, 12, 14, 16,\n        20, 24, 28, 32, 40, 48, 64, 96, 128,\n        192, 256, 384, 512, 768, 1024\n    };\n    const uint16_t *low = tab;\n    const uint16_t *high = tab + array_count(tab) - 1;\n    while (low <= high) {\n        const uint16_t *mid = low + ((high - low) >> 1);\n        if (*mid == value) {\n            return mid[1];\n        }\n        if (*mid < value) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return *low;\n}",
        "begin_line": 114,
        "end_line": 135,
        "is_bug": false
    },
    {
        "name": "be_vector.nextpow#137",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.nextpow(int value)",
        "snippet": "static int nextpow(int value)\n{\n    value |= value >> 1;\n    value |= value >> 2;\n    value |= value >> 4;\n    value |= value >> 8;\n    value |= value >> 16;\n    return value + 1;\n}",
        "begin_line": 137,
        "end_line": 145,
        "is_bug": false
    },
    {
        "name": "be_vector.be_nextsize#147",
        "src_path": "src/be_vector.c",
        "class_name": "be_vector",
        "signature": "be_vector.be_nextsize(int size)",
        "snippet": "int be_nextsize(int size)\n{\n    if (size < 1024) {\n        return binary_search(size);\n    }\n    return nextpow(size);\n}",
        "begin_line": 147,
        "end_line": 153,
        "is_bug": false
    },
    {
        "name": "be_module.find_native#43",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.find_native(bstring *path)",
        "snippet": "static const bntvmodule* find_native(bstring *path)\n{\n    const bntvmodule *module;\n    const bntvmodule* const *node = be_module_table;\n    for (; (module = *node) != NULL; ++node) {\n        if (!strcmp(module->name, str(path))) {\n            return module;\n        }\n    }\n    return NULL;\n}",
        "begin_line": 43,
        "end_line": 53,
        "is_bug": false
    },
    {
        "name": "be_module.insert_attrs#55",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.insert_attrs(bvm *vm, bmap *table, const bntvmodule *nm)",
        "snippet": "static void insert_attrs(bvm *vm, bmap *table, const bntvmodule *nm)\n{\n    size_t i;\n    for (i = 0; i < nm->size; ++i) {\n        const bntvmodobj *node = nm->attrs + i;\n        bstring *name = be_newstr(vm, node->name);\n        bvalue *v = be_map_insertstr(vm, table, name, NULL);\n        be_assert(node->type <= BE_CMODULE);\n        switch (node->type) {\n        case BE_CNIL:\n            var_setnil(v);\n            break;\n        case BE_CINT:\n            var_setint(v, node->u.i);\n            break;\n        case BE_CREAL:\n            var_setreal(v, node->u.r);\n            break;\n        case BE_CBOOL:\n            var_setbool(v, node->u.b);\n            break;\n        case BE_CFUNCTION:\n            var_setntvfunc(v, node->u.f);\n            break;\n        case BE_CSTRING:\n            var_setstr(v, be_newstr(vm, node->u.s));\n            break;\n        case BE_CMODULE:\n            native_module(vm, node->u.o, v);\n            break;\n        default: /* error */\n            break;\n        }\n    }\n}",
        "begin_line": 55,
        "end_line": 89,
        "is_bug": false
    },
    {
        "name": "be_module.new_module#91",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.new_module(bvm *vm, const bntvmodule *nm)",
        "snippet": "static bmodule* new_module(bvm *vm, const bntvmodule *nm)\n{\n    bgcobject *gco = be_gcnew(vm, BE_MODULE, bmodule);\n    bmodule *obj = cast_module(gco);\n    if (obj) {\n        var_setmodule(vm->top, obj);\n        be_incrtop(vm);\n        obj->info.native = nm;\n        obj->table = NULL; /* gc protection */\n        obj->table = be_map_new(vm);\n        insert_attrs(vm, obj->table, nm);\n        be_map_release(vm, obj->table); /* clear space */\n        be_stackpop(vm, 1);\n    }\n    return obj;\n}",
        "begin_line": 91,
        "end_line": 106,
        "is_bug": false
    },
    {
        "name": "be_module.native_module#108",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.native_module(bvm *vm, const bntvmodule *nm, bvalue *dst)",
        "snippet": "static bmodule* native_module(bvm *vm, const bntvmodule *nm, bvalue *dst)\n{\n    if (nm) {\n        bmodule *obj;\n        if (nm->module) {\n            obj = (bmodule *)nm->module;\n        } else { /* new module */\n            obj = new_module(vm, nm);\n        }\n        if (obj && dst) {\n            var_setmodule(dst, obj);\n        }\n        return obj;\n    }\n    return NULL;\n}",
        "begin_line": 108,
        "end_line": 123,
        "is_bug": false
    },
    {
        "name": "be_module.fixpath#125",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.fixpath(bvm *vm, bstring *path, size_t *size)",
        "snippet": "static char* fixpath(bvm *vm, bstring *path, size_t *size)\n{\n    char *buffer;\n    const char *split, *base;\n    bvalue *func = vm->cf->func;\n    bclosure *cl = var_toobj(func);\n    be_assert(var_isclosure(func));\n    base = str(cl->proto->source); /* get the source file path */\n    split = be_splitpath(base);\n    *size = split - base + (size_t)str_len(path) + SUFFIX_LEN;\n    buffer = be_malloc(vm, *size);\n    strncpy(buffer, base, split - base);\n    strcpy(buffer + (split - base), str(path));\n    return buffer;\n}",
        "begin_line": 125,
        "end_line": 139,
        "is_bug": false
    },
    {
        "name": "be_module.conpath#141",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.conpath(bvm *vm, bstring *path1, bstring *path2, size_t *size)",
        "snippet": "static char* conpath(bvm *vm, bstring *path1, bstring *path2, size_t *size)\n{\n    char *buffer;\n    int len1 = str_len(path1);\n    *size = (size_t)len1 + (size_t)str_len(path2) + 1 + SUFFIX_LEN;\n    buffer = be_malloc(vm, *size);\n    strcpy(buffer, str(path1));\n    buffer[len1] = '/';\n    strcpy(buffer + len1 + 1, str(path2));\n    return buffer;\n}",
        "begin_line": 141,
        "end_line": 151,
        "is_bug": false
    },
    {
        "name": "be_module.open_script#153",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.open_script(bvm *vm, char *path)",
        "snippet": "static int open_script(bvm *vm, char *path)\n{\n    int res = be_loadmodule(vm, path);\n    if (res == BE_OK)\n        be_call(vm, 0);\n    return res;\n}",
        "begin_line": 153,
        "end_line": 159,
        "is_bug": false
    },
    {
        "name": "be_module.open_libfile#171",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.open_libfile(bvm *vm, char *path, size_t size)",
        "snippet": "static int open_libfile(bvm *vm, char *path, size_t size)\n{\n    int res, idx = 0;\n    const char *sfxs[] = { \"\", \".bec\", \".be\" };\n    do {\n        strcpy(path + size - SUFFIX_LEN, sfxs[idx]);\n        res = open_script(vm, path);\n    } while (idx++ < 2 && res == BE_IO_ERROR);\n    if (res == BE_IO_ERROR) {\n#if BE_USE_SHARED_LIB\n        strcpy(path + size - SUFFIX_LEN, DLL_SUFFIX);\n        res = open_dllib(vm, path);\n#endif\n    }\n    be_free(vm, path, size);\n    return res;\n}",
        "begin_line": 171,
        "end_line": 187,
        "is_bug": false
    },
    {
        "name": "be_module.load_path#189",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.load_path(bvm *vm, bstring *path, bstring *mod)",
        "snippet": "static int load_path(bvm *vm, bstring *path, bstring *mod)\n{\n    size_t size;\n    char *fullpath = conpath(vm, path, mod, &size);\n    return open_libfile(vm, fullpath, size);\n}",
        "begin_line": 189,
        "end_line": 194,
        "is_bug": false
    },
    {
        "name": "be_module.load_cwd#196",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.load_cwd(bvm *vm, bstring *path)",
        "snippet": "static int load_cwd(bvm *vm, bstring *path)\n{\n    size_t size;\n    char *fullpath = fixpath(vm, path, &size);\n    return open_libfile(vm, fullpath, size);\n}",
        "begin_line": 196,
        "end_line": 201,
        "is_bug": false
    },
    {
        "name": "be_module.load_package#203",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.load_package(bvm *vm, bstring *path)",
        "snippet": "static int load_package(bvm *vm, bstring *path)\n{\n    int res = load_cwd(vm, path); /* load from current directory */\n    if (res == BE_IO_ERROR && vm->module.path) {\n        blist *list = vm->module.path;\n        bvalue *v = be_list_end(list) - 1;\n        bvalue *first = be_list_data(list);\n        for (; res == BE_IO_ERROR && v >= first; v--) {\n            if (var_isstr(v)) {\n                res = load_path(vm, var_tostr(v), path);\n            }\n        }\n    }\n    return res;\n}",
        "begin_line": 203,
        "end_line": 217,
        "is_bug": false
    },
    {
        "name": "be_module.load_native#219",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.load_native(bvm *vm, bstring *path)",
        "snippet": "static int load_native(bvm *vm, bstring *path)\n{\n    const bntvmodule *nm = find_native(path);\n    bmodule *mod = native_module(vm, nm, NULL);\n    if (mod != NULL) {\n        /* the pointer vm->top may be changed */\n        var_setmodule(vm->top, mod);\n        be_incrtop(vm);\n        return BE_OK;\n    }\n    return BE_IO_ERROR;\n}",
        "begin_line": 219,
        "end_line": 230,
        "is_bug": false
    },
    {
        "name": "be_module.load_cached#232",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.load_cached(bvm *vm, bstring *path)",
        "snippet": "static bvalue* load_cached(bvm *vm, bstring *path)\n{\n    bvalue *v = NULL;\n    if (vm->module.loaded) {\n        v = be_map_findstr(vm, vm->module.loaded, path);\n        if (v) {\n            *vm->top = *v;\n            be_incrtop(vm);\n        }\n    }\n    return v;\n}",
        "begin_line": 232,
        "end_line": 243,
        "is_bug": false
    },
    {
        "name": "be_module.cache_module#245",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.cache_module(bvm *vm, bstring *name)",
        "snippet": "static void cache_module(bvm *vm, bstring *name)\n{\n    bvalue *v;\n    if (vm->module.loaded == NULL) {\n        vm->module.loaded = be_map_new(vm);\n    }\n    v = be_map_insertstr(vm, vm->module.loaded, name, NULL);\n    *v = vm->top[-1];\n}",
        "begin_line": 245,
        "end_line": 253,
        "is_bug": false
    },
    {
        "name": "be_module.module_init#256",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.module_init(bvm *vm)",
        "snippet": "static void module_init(bvm *vm) {\n    if (be_getmember(vm, -1, \"init\")) {\n        /* found, call it with no parameter */\n        be_call(vm, 0);\n        /* we don't care about the result */\n    }\n    be_pop(vm, 1);\n}",
        "begin_line": 256,
        "end_line": 263,
        "is_bug": false
    },
    {
        "name": "be_module.be_module_load#266",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.be_module_load(bvm *vm, bstring *path)",
        "snippet": "int be_module_load(bvm *vm, bstring *path)\n{\n    int res = BE_OK;\n    if (!load_cached(vm, path)) {\n        res = load_native(vm, path);\n        if (res == BE_IO_ERROR)\n            res = load_package(vm, path);\n        if (res == BE_OK) {\n            cache_module(vm, path);\n            /* on first load of the module, try running the '()' function */\n            module_init(vm);\n        }\n    }\n    return res;\n}",
        "begin_line": 266,
        "end_line": 280,
        "is_bug": false
    },
    {
        "name": "be_module.be_module_new#282",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.be_module_new(bvm *vm)",
        "snippet": "bmodule* be_module_new(bvm *vm)\n{\n    bgcobject *gco = be_gcnew(vm, BE_MODULE, bmodule);\n    bmodule *obj = cast_module(gco);\n    if (obj) {\n        var_setmodule(vm->top, obj);\n        be_incrtop(vm);\n        obj->info.native = NULL;\n        obj->table = NULL; /* gc protection */\n        obj->table = be_map_new(vm);\n        be_stackpop(vm, 1);\n    }\n    return obj;\n}",
        "begin_line": 282,
        "end_line": 295,
        "is_bug": false
    },
    {
        "name": "be_module.be_module_delete#297",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.be_module_delete(bvm *vm, bmodule *module)",
        "snippet": "void be_module_delete(bvm *vm, bmodule *module)\n{\n    be_free(vm, module, sizeof(bmodule));\n}",
        "begin_line": 297,
        "end_line": 300,
        "is_bug": false
    },
    {
        "name": "be_module.be_module_attr#302",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.be_module_attr(bvm *vm, bmodule *module, bstring *attr, bvalue *dst)",
        "snippet": "int be_module_attr(bvm *vm, bmodule *module, bstring *attr, bvalue *dst)\n{\n    bvalue *member = be_map_findstr(vm, module->table, attr);\n    if (!member) {  /* try the 'member' function */\n        member = be_map_findstr(vm, module->table, str_literal(vm, \"member\"));\n        if (member && var_basetype(member) == BE_FUNCTION) {\n            bvalue *top = vm->top;\n            top[0] = *member;\n            var_setstr(&top[1], attr);\n            vm->top += 2;   /* prevent collection results */\n            be_dofunc(vm, top, 1); /* call method 'method' */\n            vm->top -= 2;\n            *dst = *vm->top;   /* copy result to R(A) */\n            if (var_basetype(dst) != BE_NIL) {\n                return var_type(dst);\n            }\n        }\n        return BE_NONE;\n    } else {\n        *dst = *member;\n        return var_type(dst);\n    }\n}",
        "begin_line": 302,
        "end_line": 324,
        "is_bug": false
    },
    {
        "name": "be_module.be_module_setmember#326",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.be_module_setmember(bvm *vm, bmodule *module, bstring *attr, bvalue *src)",
        "snippet": "bbool be_module_setmember(bvm *vm, bmodule *module, bstring *attr, bvalue *src)\n{\n    assert(src);\n    bmap *attrs = module->table;\n    if (!gc_isconst(attrs)) {\n        bvalue *v = be_map_findstr(vm, attrs, attr);\n        if (v == NULL) {\n            v = be_map_insertstr(vm, attrs, attr, NULL);\n        }\n        if (v) {\n            *v = *src;\n            return btrue;\n        }\n    } else {\n        /* if not writable, try 'setmember' */\n        int type = be_module_attr(vm, module, str_literal(vm, \"setmember\"), vm->top);\n        if (type == BE_FUNCTION) {\n            bvalue *top = vm->top;\n            // top[0] already has 'member'\n            var_setstr(&top[1], attr);  /* attribute name */\n            top[2] = *src;  /* new value */\n            vm->top += 3;   /* prevent collection results */\n            be_dofunc(vm, top, 2); /* call method 'setmember' */\n            vm->top -= 3;\n            return btrue;\n        }\n    }\n    return bfalse;\n}",
        "begin_line": 326,
        "end_line": 354,
        "is_bug": false
    },
    {
        "name": "be_module.be_module_name#356",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.be_module_name(bmodule *module)",
        "snippet": "const char* be_module_name(bmodule *module)\n{\n    if (gc_isconst(module)) {\n        return module->info.name;\n    }\n    if (gc_exmark(module) & BE_MODULE_NAME) {\n        return str(module->info.sname);\n    }\n    if (module->info.native) {\n        return module->info.native->name;\n    }\n    return NULL;\n}",
        "begin_line": 356,
        "end_line": 368,
        "is_bug": false
    },
    {
        "name": "be_module.be_module_setname#370",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.be_module_setname(bmodule *module, bstring *name)",
        "snippet": "bbool be_module_setname(bmodule *module, bstring *name)\n{\n    if (!gc_isconst(module)) {\n        module->info.sname = name;\n        gc_setexmark(module, BE_MODULE_NAME);\n        return btrue;\n    }\n    return bfalse;\n}",
        "begin_line": 370,
        "end_line": 378,
        "is_bug": false
    },
    {
        "name": "be_module.pathlist#380",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.pathlist(bvm *vm)",
        "snippet": "static blist* pathlist(bvm *vm)\n{\n    if (!vm->module.path) {\n        vm->module.path = be_list_new(vm);\n    }\n    return vm->module.path;\n}",
        "begin_line": 380,
        "end_line": 386,
        "is_bug": false
    },
    {
        "name": "be_module.be_module_path#389",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.be_module_path(bvm *vm)",
        "snippet": "BERRY_API void be_module_path(bvm *vm)\n{\n    blist *list = pathlist(vm);\n    bvalue *reg = be_incrtop(vm);\n    var_setlist(reg, list);\n}",
        "begin_line": 389,
        "end_line": 394,
        "is_bug": false
    },
    {
        "name": "be_module.be_module_path_set#396",
        "src_path": "src/be_module.c",
        "class_name": "be_module",
        "signature": "be_module.be_module_path_set(bvm *vm, const char *path)",
        "snippet": "BERRY_API void be_module_path_set(bvm *vm, const char *path)\n{\n    blist *list = pathlist(vm);\n    bvalue *value = be_list_push(vm, list, NULL);\n    var_setnil(value);\n    var_setstr(value, be_newstr(vm, path))\n}",
        "begin_line": 396,
        "end_line": 402,
        "is_bug": false
    },
    {
        "name": "be_var.be_globalvar_init#18",
        "src_path": "src/be_var.c",
        "class_name": "be_var",
        "signature": "be_var.be_globalvar_init(bvm *vm)",
        "snippet": "void be_globalvar_init(bvm *vm)\n{\n    global(vm).vtab = be_map_new(vm);\n    be_gc_fix(vm, gc_object(global(vm).vtab));\n    be_vector_init(vm, &global(vm).vlist, sizeof(bvalue));\n#if !BE_USE_PRECOMPILED_OBJECT\n    builtin(vm).vtab = be_map_new(vm);\n    be_vector_init(vm, &builtin(vm).vlist, sizeof(bvalue));\n    be_gc_fix(vm, gc_object(builtin(vm).vtab));\n#endif\n}",
        "begin_line": 18,
        "end_line": 28,
        "is_bug": false
    },
    {
        "name": "be_var.be_globalvar_deinit#30",
        "src_path": "src/be_var.c",
        "class_name": "be_var",
        "signature": "be_var.be_globalvar_deinit(bvm *vm)",
        "snippet": "void be_globalvar_deinit(bvm *vm)\n{\n    global(vm).vtab = NULL;\n    be_vector_delete(vm, &global(vm).vlist);\n#if !BE_USE_PRECOMPILED_OBJECT\n    builtin(vm).vtab = NULL;\n    be_vector_delete(vm, &builtin(vm).vlist);\n#endif\n}",
        "begin_line": 30,
        "end_line": 38,
        "is_bug": false
    },
    {
        "name": "be_var.global_find#40",
        "src_path": "src/be_var.c",
        "class_name": "be_var",
        "signature": "be_var.global_find(bvm *vm, bstring *name)",
        "snippet": "static int global_find(bvm *vm, bstring *name)\n{\n    bvalue *res = be_map_findstr(vm, global(vm).vtab, name);\n    if (res) {\n        return var_toidx(res) + be_builtin_count(vm);\n    }\n    return -1; /* not found */\n}",
        "begin_line": 40,
        "end_line": 47,
        "is_bug": false
    },
    {
        "name": "be_var.be_global_find#49",
        "src_path": "src/be_var.c",
        "class_name": "be_var",
        "signature": "be_var.be_global_find(bvm *vm, bstring *name)",
        "snippet": "int be_global_find(bvm *vm, bstring *name)\n{\n    int res = global_find(vm, name);\n    return res != -1 ? res : be_builtin_find(vm, name);\n}",
        "begin_line": 49,
        "end_line": 53,
        "is_bug": false
    },
    {
        "name": "be_var.global_new_anonymous#55",
        "src_path": "src/be_var.c",
        "class_name": "be_var",
        "signature": "be_var.global_new_anonymous(bvm *vm)",
        "snippet": "static int global_new_anonymous(bvm *vm)\n{\n    int idx = be_global_count(vm);\n    /* allocate space for new variables */\n    be_vector_resize(vm, &global(vm).vlist, idx + 1);\n    /* set the new variable to nil */\n    var_setnil((bvalue *)global(vm).vlist.end);\n    return idx;\n}",
        "begin_line": 55,
        "end_line": 63,
        "is_bug": false
    },
    {
        "name": "be_var.be_global_new#65",
        "src_path": "src/be_var.c",
        "class_name": "be_var",
        "signature": "be_var.be_global_new(bvm *vm, bstring *name)",
        "snippet": "int be_global_new(bvm *vm, bstring *name)\n{\n    int idx = global_find(vm, name);\n    if (idx == -1) {\n        bvalue *desc;\n        idx = global_new_anonymous(vm);\n        desc = be_map_insertstr(vm, global(vm).vtab, name, NULL);\n        var_setint(desc, idx);\n        idx += be_builtin_count(vm);\n    }\n    return idx;\n}",
        "begin_line": 65,
        "end_line": 76,
        "is_bug": false
    },
    {
        "name": "be_var.be_global_var#78",
        "src_path": "src/be_var.c",
        "class_name": "be_var",
        "signature": "be_var.be_global_var(bvm *vm, int index)",
        "snippet": "bvalue* be_global_var(bvm *vm, int index)\n{\n    int bcnt = be_builtin_count(vm);\n    if (index < bcnt) {\n        return be_vector_at(&builtin(vm).vlist, index);\n    }\n    index -= bcnt;\n    return be_vector_at(&global(vm).vlist, index);\n}",
        "begin_line": 78,
        "end_line": 86,
        "is_bug": false
    },
    {
        "name": "be_var.be_global_release_space#88",
        "src_path": "src/be_var.c",
        "class_name": "be_var",
        "signature": "be_var.be_global_release_space(bvm *vm)",
        "snippet": "void be_global_release_space(bvm *vm)\n{\n    be_map_release(vm, global(vm).vtab);\n    be_vector_release(vm, &global(vm).vlist);\n}",
        "begin_line": 88,
        "end_line": 92,
        "is_bug": false
    },
    {
        "name": "be_var.be_builtin_find#94",
        "src_path": "src/be_var.c",
        "class_name": "be_var",
        "signature": "be_var.be_builtin_find(bvm *vm, bstring *name)",
        "snippet": "int be_builtin_find(bvm *vm, bstring *name)\n{\n    bvalue *res = be_map_findstr(vm, builtin(vm).vtab, name);\n    if (res) {\n        return var_toidx(res);\n    }\n    return -1; /* not found */\n}",
        "begin_line": 94,
        "end_line": 101,
        "is_bug": false
    },
    {
        "name": "be_var.be_builtin_name#103",
        "src_path": "src/be_var.c",
        "class_name": "be_var",
        "signature": "be_var.be_builtin_name(bvm *vm, int index)",
        "snippet": "bstring* be_builtin_name(bvm *vm, int index)\n{\n    bmap *map = builtin(vm).vtab;\n    bmapnode *end, *node = map->slots;\n    for (end = node + map->size; node < end; ++node) {\n        if (var_isstr(&node->key) && node->value.v.i == index) {\n            return node->key.v.s;\n        }\n    }\n    return NULL;\n}",
        "begin_line": 103,
        "end_line": 113,
        "is_bug": false
    },
    {
        "name": "be_var.be_builtin_new#116",
        "src_path": "src/be_var.c",
        "class_name": "be_var",
        "signature": "be_var.be_builtin_new(bvm *vm, bstring *name)",
        "snippet": "int be_builtin_new(bvm *vm, bstring *name)\n{\n    int idx = be_builtin_find(vm, name);\n    if (idx == -1) {\n        bvalue *desc;\n        idx = be_map_count(builtin(vm).vtab);\n        desc = be_map_insertstr(vm, builtin(vm).vtab, name, NULL);\n        var_setint(desc, idx);\n        be_vector_resize(vm, &builtin(vm).vlist, idx + 1);\n        /* set the new variable to nil */\n        var_setnil((bvalue*)(builtin(vm).vlist.end));\n    }\n    return idx;\n}",
        "begin_line": 116,
        "end_line": 129,
        "is_bug": false
    },
    {
        "name": "be_var.be_bulitin_release_space#131",
        "src_path": "src/be_var.c",
        "class_name": "be_var",
        "signature": "be_var.be_bulitin_release_space(bvm *vm)",
        "snippet": "void be_bulitin_release_space(bvm *vm)\n{\n    be_map_release(vm, builtin(vm).vtab);\n    be_vector_release(vm, &builtin(vm).vlist);\n}",
        "begin_line": 131,
        "end_line": 135,
        "is_bug": false
    },
    {
        "name": "be_string.be_eqstr#41",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.be_eqstr(bstring *s1, bstring *s2)",
        "snippet": "int be_eqstr(bstring *s1, bstring *s2)\n{\n    int slen;\n    if (s1 == s2) { /* short string or the same string */\n        return 1;\n    }\n    slen = s1->slen;\n    /* discard different lengths */\n    if (slen != s2->slen) {\n        return 0;\n    }\n    /* long string */\n    if (slen == 255) {  /* s2->slen is also 255 */\n        blstring *ls1 = cast(blstring*, s1);\n        blstring *ls2 = cast(blstring*, s2);\n        return ls1->llen == ls2->llen && !strcmp(lstr(ls1), lstr(ls2));\n    }\n    /* const short strings */\n    if (gc_isconst(s1) || gc_isconst(s2)) { /* one of the two string is short const */\n        if (cast(bcstring*, s1)->hash && cast(bcstring*, s2)->hash) {\n            return 0; /* if they both have a hash, then we know they are different */\n        }\n        return !strcmp(str(s1), str(s2));\n    }\n\n    return 0;\n}",
        "begin_line": 41,
        "end_line": 67,
        "is_bug": false
    },
    {
        "name": "be_string.resize#69",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.resize(bvm *vm, int size)",
        "snippet": "static void resize(bvm *vm, int size)\n{\n    int i;\n    struct bstringtable *tab = &vm->strtab;\n    if (size > tab->size) {\n        tab->table = be_realloc(vm, tab->table,\n            tab->size * sizeof(bstring*), size * sizeof(bstring*));\n        for (i = tab->size; i < size; ++i) {\n            tab->table[i] = NULL;\n        }\n    }\n    for (i = 0; i < tab->size; ++i) { /* rehash */\n        bstring *p = tab->table[i];\n        tab->table[i] = NULL;\n        while (p) { /* for each node in the list */\n            bstring *hnext = next(p);\n            uint32_t hash = be_strhash(p) & (size - 1);\n            p->next = cast(void*, tab->table[hash]);\n            tab->table[hash] = p;\n            p = hnext;\n        }\n    }\n    if (size < tab->size) {\n        for (i = size; i < tab->size; ++i) {\n            tab->table[i] = NULL;\n        }\n        tab->table = be_realloc(vm, tab->table,\n            tab->size * sizeof(bstring*), size * sizeof(bstring*));\n    }\n    tab->size = size;\n}",
        "begin_line": 69,
        "end_line": 99,
        "is_bug": false
    },
    {
        "name": "be_string.free_sstring#101",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.free_sstring(bvm *vm, bstring *str)",
        "snippet": "static void free_sstring(bvm *vm, bstring *str)\n{\n    be_free(vm, str, sizeof(bsstring) + str->slen + 1);\n}",
        "begin_line": 101,
        "end_line": 104,
        "is_bug": false
    },
    {
        "name": "be_string.str_hash#107",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.str_hash(const char *str, size_t len)",
        "snippet": "static uint32_t str_hash(const char *str, size_t len)\n{\n    uint32_t hash = 2166136261u;\n    be_assert(str || len);\n    while (len--) {\n        hash = (hash ^ (unsigned char)*str++) * 16777619u;\n    }\n    return hash;\n}",
        "begin_line": 107,
        "end_line": 115,
        "is_bug": false
    },
    {
        "name": "be_string.be_string_init#117",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.be_string_init(bvm *vm)",
        "snippet": "void be_string_init(bvm *vm)\n{\n    resize(vm, 8);\n#if !BE_USE_PRECOMPILED_OBJECT\n    /* the destructor name deinit needs to exist all the time, to ensure\n     * that it does not need to be created when the heap is exhausted. */\n    be_gc_fix(vm, cast(bgcobject*, str_literal(vm, \"deinit\")));\n#endif\n    /* be_const_str_deinit --> for precompiled */\n}",
        "begin_line": 117,
        "end_line": 126,
        "is_bug": false
    },
    {
        "name": "be_string.be_string_deleteall#128",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.be_string_deleteall(bvm *vm)",
        "snippet": "void be_string_deleteall(bvm *vm)\n{\n    int i;\n    struct bstringtable *tab = &vm->strtab;\n    for (i = 0; i < tab->size; ++i) {\n        bstring *node = tab->table[i];\n        while (node) {\n            bstring *next = next(node);\n            free_sstring(vm, node);\n            node = next;\n        }\n    }\n    be_free(vm, tab->table, tab->size * sizeof(bstring*));\n}",
        "begin_line": 128,
        "end_line": 141,
        "is_bug": false
    },
    {
        "name": "be_string.createstrobj#143",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.createstrobj(bvm *vm, size_t len, int islong)",
        "snippet": "static bstring* createstrobj(bvm *vm, size_t len, int islong)\n{\n    size_t size = (islong ? sizeof(blstring)\n                : sizeof(bsstring)) + len + 1;\n    bgcobject *gco = be_gc_newstr(vm, size, islong);\n    bstring *s = cast_str(gco);\n    if (s) {\n        s->slen = islong ? 255 : (bbyte)len;\n        char *str = cast(char *, islong ? lstr(s) : sstr(s));\n        str[len] = '\\0';\n    }\n    return s;\n}",
        "begin_line": 143,
        "end_line": 155,
        "is_bug": false
    },
    {
        "name": "be_string.newshortstr#172",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.newshortstr(bvm *vm, const char *str, size_t len)",
        "snippet": "static bstring* newshortstr(bvm *vm, const char *str, size_t len)\n{\n    bstring *s;\n    int size = vm->strtab.size;\n    uint32_t hash = str_hash(str, len);\n    bstring **list = vm->strtab.table + (hash & (size - 1));\n\n    for (s = *list; s != NULL; s = next(s)) {\n        if (len == s->slen && !strncmp(str, sstr(s), len)) {\n            return s;\n        }\n    }\n    s = createstrobj(vm, len, 0);\n    if (s) {\n        memcpy(cast(char *, sstr(s)), str, len);\n        s->extra = 0;\n        s->next = cast(void*, *list);\n#if BE_USE_STR_HASH_CACHE\n        cast(bsstring*, s)->hash = hash;\n#endif\n        *list = s;\n        vm->strtab.count++;\n        if (vm->strtab.count > size << 2) {\n            resize(vm, size << 1);\n        }\n    }\n    return s;\n}",
        "begin_line": 172,
        "end_line": 199,
        "is_bug": false
    },
    {
        "name": "be_string.be_newlongstr#201",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.be_newlongstr(bvm *vm, const char *str, size_t len)",
        "snippet": "bstring* be_newlongstr(bvm *vm, const char *str, size_t len)\n{\n    bstring *s;\n    blstring *ls;\n    s = createstrobj(vm, len, 1);\n    ls = cast(blstring*, s);\n    s->extra = 0;\n    ls->llen = cast_int(len);\n    if (str) { /* if the argument 'str' is NULL, we just allocate space */\n        memcpy(cast(char *, lstr(s)), str, len);\n    }\n    return s;\n}",
        "begin_line": 201,
        "end_line": 213,
        "is_bug": false
    },
    {
        "name": "be_string.be_newstr#215",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.be_newstr(bvm *vm, const char *str)",
        "snippet": "bstring* be_newstr(bvm *vm, const char *str)\n{\n    return be_newstrn(vm, str, strlen(str));\n}",
        "begin_line": 215,
        "end_line": 218,
        "is_bug": false
    },
    {
        "name": "be_string.be_newstrn#220",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.be_newstrn(bvm *vm, const char *str, size_t len)",
        "snippet": "bstring *be_newstrn(bvm *vm, const char *str, size_t len)\n{\n    if (len <= SHORT_STR_MAX_LEN) {\n#if BE_USE_PRECOMPILED_OBJECT\n        bstring *s = find_conststr(str, len);\n        return s ? s : newshortstr(vm, str, len);\n#else\n        return newshortstr(vm, str, len);\n#endif\n    }\n    return be_newlongstr(vm, str, len); /* long string */\n}",
        "begin_line": 220,
        "end_line": 231,
        "is_bug": false
    },
    {
        "name": "be_string.be_gcstrtab#233",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.be_gcstrtab(bvm *vm)",
        "snippet": "void be_gcstrtab(bvm *vm)\n{\n    struct bstringtable *tab = &vm->strtab;\n    int size = tab->size, i;\n    for (i = 0; i < size; ++i) {\n        bstring **list = tab->table + i;\n        bstring *prev = NULL, *node, *next;\n        for (node = *list; node; node = next) {\n            next = next(node);\n            if (!gc_isfixed(node) && gc_iswhite(node)) {\n                free_sstring(vm, node);\n                tab->count--;\n                if (prev) { /* link list */\n                    prev->next = cast(void*, next);\n                } else {\n                    *list = next;\n                }\n            } else {\n                prev = node;\n                gc_setwhite(node);\n            }\n        }\n    }\n    if (tab->count < size >> 2 && size > 8) {\n        resize(vm, size >> 1);\n    }\n}",
        "begin_line": 233,
        "end_line": 259,
        "is_bug": false
    },
    {
        "name": "be_string.be_strhash#261",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.be_strhash(const bstring *s)",
        "snippet": "uint32_t be_strhash(const bstring *s)\n{\n    if (gc_isconst(s)) {\n        bcstring* cs = cast(bcstring*, s);\n        if (cs->hash) {  /* if hash is null we need to compute it */\n            return cs->hash;\n        } else {\n            return str_hash(cstr(s), str_len(s));\n        }\n    }\n#if BE_USE_STR_HASH_CACHE\n    if (s->slen != 255) {\n        return cast(bsstring*, s)->hash;\n    }\n#endif\n    return str_hash(str(s), str_len(s));\n}",
        "begin_line": 261,
        "end_line": 277,
        "is_bug": false
    },
    {
        "name": "be_string.be_str2cstr#279",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.be_str2cstr(const bstring *s)",
        "snippet": "const char* be_str2cstr(const bstring *s)\n{\n    be_assert(cast_str(s) != NULL);\n    if (gc_isconst(s)) {\n        return cstr(s);\n    }\n    if (s->slen == 255) {\n        return lstr(s);\n    }\n    return sstr(s);\n}",
        "begin_line": 279,
        "end_line": 289,
        "is_bug": false
    },
    {
        "name": "be_string.be_str_setextra#291",
        "src_path": "src/be_string.c",
        "class_name": "be_string",
        "signature": "be_string.be_str_setextra(bstring *s, int extra)",
        "snippet": "void be_str_setextra(bstring *s, int extra)\n{\n    if (!gc_isconst(s)) {\n        s->extra = cast(bbyte, extra);\n    }\n}",
        "begin_line": 291,
        "end_line": 296,
        "is_bug": false
    },
    {
        "name": "be_rangelib.m_init#12",
        "src_path": "src/be_rangelib.c",
        "class_name": "be_rangelib",
        "signature": "be_rangelib.m_init(bvm *vm)",
        "snippet": "static int m_init(bvm *vm)\n{\n    be_pushvalue(vm, 2);\n    be_setmember(vm, 1, \"__lower__\");\n    be_pop(vm, 1);\n    be_pushvalue(vm, 3);\n    be_setmember(vm, 1, \"__upper__\");\n    be_return_nil(vm);\n}",
        "begin_line": 12,
        "end_line": 20,
        "is_bug": false
    },
    {
        "name": "be_rangelib.m_tostring#22",
        "src_path": "src/be_rangelib.c",
        "class_name": "be_rangelib",
        "signature": "be_rangelib.m_tostring(bvm *vm)",
        "snippet": "static int m_tostring(bvm *vm)\n{\n    be_pushstring(vm, \"(\");\n    be_getmember(vm, 1, \"__lower__\");\n    be_tostring(vm, -1);\n    be_strconcat(vm, -2);\n    be_pop(vm, 1);\n    be_pushstring(vm, \"..\");\n    be_strconcat(vm, -2);\n    be_pop(vm, 1);\n    be_getmember(vm, 1, \"__upper__\");\n    be_tostring(vm, -1);\n    be_strconcat(vm, -2);\n    be_pop(vm, 1);\n    be_pushstring(vm, \")\");\n    be_strconcat(vm, -2);\n    be_pop(vm, 1);\n    be_return(vm);\n}",
        "begin_line": 22,
        "end_line": 40,
        "is_bug": false
    },
    {
        "name": "be_rangelib.m_upper#42",
        "src_path": "src/be_rangelib.c",
        "class_name": "be_rangelib",
        "signature": "be_rangelib.m_upper(bvm *vm)",
        "snippet": "static int m_upper(bvm *vm)\n{\n    be_getmember(vm, 1, \"__upper__\");\n    be_return(vm);\n}",
        "begin_line": 42,
        "end_line": 46,
        "is_bug": false
    },
    {
        "name": "be_rangelib.m_lower#48",
        "src_path": "src/be_rangelib.c",
        "class_name": "be_rangelib",
        "signature": "be_rangelib.m_lower(bvm *vm)",
        "snippet": "static int m_lower(bvm *vm)\n{\n    be_getmember(vm, 1, \"__lower__\");\n    be_return(vm);\n}",
        "begin_line": 48,
        "end_line": 52,
        "is_bug": false
    },
    {
        "name": "be_rangelib.m_setrange#54",
        "src_path": "src/be_rangelib.c",
        "class_name": "be_rangelib",
        "signature": "be_rangelib.m_setrange(bvm *vm)",
        "snippet": "static int m_setrange(bvm *vm)\n{\n    be_pushvalue(vm, 2);\n    be_setmember(vm, 1, \"__lower__\");\n    be_pop(vm, 1);\n    be_pushvalue(vm, 3);\n    be_setmember(vm, 1, \"__upper__\");\n    be_return_nil(vm);\n}",
        "begin_line": 54,
        "end_line": 62,
        "is_bug": false
    },
    {
        "name": "be_rangelib.iter_closure#64",
        "src_path": "src/be_rangelib.c",
        "class_name": "be_rangelib",
        "signature": "be_rangelib.iter_closure(bvm *vm)",
        "snippet": "static int iter_closure(bvm *vm)\n{\n    /* for better performance, we operate the upvalues\n     * directly without using by the stack. */\n    bntvclos *func = var_toobj(vm->cf->func);\n    bvalue *uv0 = be_ntvclos_upval(func, 0)->value;\n    bvalue *uv1 = be_ntvclos_upval(func, 1)->value;\n    bint lower = var_toint(uv0); /* upvalue[0] => lower */\n    bint upper = var_toint(uv1); /* upvalue[1] => upper */\n    if (lower > upper) {\n        be_stop_iteration(vm);\n    }\n    var_toint(uv0) = lower + 1; /* set upvale[0] */\n    be_pushint(vm, lower); /* push the return value */\n    be_return(vm);\n}",
        "begin_line": 64,
        "end_line": 79,
        "is_bug": false
    },
    {
        "name": "be_rangelib.m_iter#81",
        "src_path": "src/be_rangelib.c",
        "class_name": "be_rangelib",
        "signature": "be_rangelib.m_iter(bvm *vm)",
        "snippet": "static int m_iter(bvm *vm)\n{\n    be_pushntvclosure(vm, iter_closure, 2);\n    be_getmember(vm, 1, \"__lower__\");\n    be_setupval(vm, -2, 0);\n    be_pop(vm, 1);\n    be_getmember(vm, 1, \"__upper__\");\n    be_setupval(vm, -2, 1);\n    be_pop(vm, 1);\n    be_return(vm);\n}",
        "begin_line": 81,
        "end_line": 91,
        "is_bug": false
    },
    {
        "name": "be_rangelib.be_load_rangelib#94",
        "src_path": "src/be_rangelib.c",
        "class_name": "be_rangelib",
        "signature": "be_rangelib.be_load_rangelib(bvm *vm)",
        "snippet": "void be_load_rangelib(bvm *vm)\n{\n    static const bnfuncinfo members[] = {\n        { \"__lower__\", NULL },\n        { \"__upper__\", NULL },\n        { \"init\", m_init },\n        { \"tostring\", m_tostring },\n        { \"lower\", m_lower },\n        { \"upper\", m_upper },\n        { \"setrange\", m_setrange },\n        { \"iter\", m_iter },\n        { NULL, NULL }\n    };\n    be_regclass(vm, \"range\", members);\n}",
        "begin_line": 94,
        "end_line": 108,
        "is_bug": false
    },
    {
        "name": "be_debug.sourceinfo#167",
        "src_path": "src/be_debug.c",
        "class_name": "be_debug",
        "signature": "be_debug.sourceinfo(bproto *proto, binstruction *ip)",
        "snippet": "static void sourceinfo(bproto *proto, binstruction *ip)\n{\n#if BE_DEBUG_RUNTIME_INFO\n    char buf[24];\n    be_assert(proto != NULL);\n    if (proto->lineinfo && proto->nlineinfo) {\n        blineinfo *it = proto->lineinfo;\n        blineinfo *end = it + proto->nlineinfo;\n        int pc = cast_int(ip - proto->code - 1); /* now vm->ip has been increased */\n        for (; it < end && pc > it->endpc; ++it);\n        sprintf(buf, \":%d:\", it->linenumber);\n        be_writestring(str(proto->source));\n        be_writestring(buf);\n    } else {\n        be_writestring(\"<unknow source>:\");\n    }\n#else\n    (void)proto; (void)ip;\n    be_writestring(\"<unknow source>:\");\n#endif\n}",
        "begin_line": 167,
        "end_line": 187,
        "is_bug": false
    },
    {
        "name": "be_debug.tracestack#189",
        "src_path": "src/be_debug.c",
        "class_name": "be_debug",
        "signature": "be_debug.tracestack(bvm *vm)",
        "snippet": "static void tracestack(bvm *vm)\n{\n    bcallsnapshot *cf;\n    bcallsnapshot *base = be_stack_base(&vm->tracestack);\n    bcallsnapshot *top = be_stack_top(&vm->tracestack);\n    be_writestring(\"stack traceback:\\n\");\n    for (cf = top; cf >= base; --cf) {\n        if (cf <= top - 10 && cf >= base + 10) {\n            if (cf == top - 10)\n                be_writestring(\"\\t...\\n\");\n            continue;\n        }\n        if (var_isclosure(&cf->func)) {\n            bclosure *cl = var_toobj(&cf->func);\n            be_writestring(\"\\t\");\n            sourceinfo(cl->proto, cf->ip);\n            be_writestring(\" in function `\");\n            be_writestring(str(cl->proto->name));\n            be_writestring(\"`\\n\");\n        } else {\n            be_writestring(\"\\t<native>: in native function\\n\");\n        }\n    }\n}",
        "begin_line": 189,
        "end_line": 212,
        "is_bug": false
    },
    {
        "name": "be_debug.repair_stack#214",
        "src_path": "src/be_debug.c",
        "class_name": "be_debug",
        "signature": "be_debug.repair_stack(bvm *vm)",
        "snippet": "static void repair_stack(bvm *vm)\n{\n    bcallsnapshot *cf;\n    bcallsnapshot *base = be_stack_base(&vm->tracestack);\n    bcallsnapshot *top = be_stack_top(&vm->tracestack);\n    /* Because the native function does not push `ip` to the\n     * stack, the ip on the native function frame corresponds\n     * to the previous Berry closure. */\n    for (cf = top; cf >= base; --cf) {\n        if (!var_isclosure(&cf->func)) {\n            /* the last native function stack frame has the `ip` of\n             * the previous Berry frame */\n            binstruction *ip = cf->ip;\n            /* skip native function stack frames */\n            for (; cf >= base && !var_isclosure(&cf->func); --cf);\n            /* fixed `ip` of Berry closure frame near native function frame */\n            if (cf >= base) cf->ip = ip;\n        }\n    }\n}",
        "begin_line": 214,
        "end_line": 233,
        "is_bug": false
    },
    {
        "name": "be_debug.be_tracestack#235",
        "src_path": "src/be_debug.c",
        "class_name": "be_debug",
        "signature": "be_debug.be_tracestack(bvm *vm)",
        "snippet": "void be_tracestack(bvm *vm)\n{\n    if (be_stack_count(&vm->tracestack)) {\n        repair_stack(vm);\n        tracestack(vm);\n    }\n}",
        "begin_line": 235,
        "end_line": 241,
        "is_bug": false
    },
    {
        "name": "be_strlib.be_strcat#25",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.be_strcat(bvm *vm, bstring *s1, bstring *s2)",
        "snippet": "bstring* be_strcat(bvm *vm, bstring *s1, bstring *s2)\n{\n    size_t len = (size_t)str_len(s1) + str_len(s2);\n    if (len <= SHORT_STR_MAX_LEN) {\n        char buf[SHORT_STR_MAX_LEN + 1];\n        strcpy(buf, str(s1));\n        strncat(buf, str(s2), len);\n        return be_newstrn(vm, buf, len);\n    } else { /* long string */\n        bstring *s = be_newstrn(vm, NULL, len);\n        char *sbuf = (char*)str(s);\n        strcpy(sbuf, str(s1));\n        strcpy(sbuf + str_len(s1), str(s2));\n        return s;\n    }\n}",
        "begin_line": 25,
        "end_line": 40,
        "is_bug": false
    },
    {
        "name": "be_strlib.be_strcmp#42",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.be_strcmp(bstring *s1, bstring *s2)",
        "snippet": "int be_strcmp(bstring *s1, bstring *s2)\n{\n    if (be_eqstr(s1, s2)) {\n        return 0;\n    }\n    return strcmp(str(s1), str(s2));\n}",
        "begin_line": 42,
        "end_line": 48,
        "is_bug": false
    },
    {
        "name": "be_strlib.be_num2str#50",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.be_num2str(bvm *vm, bvalue *v)",
        "snippet": "bstring* be_num2str(bvm *vm, bvalue *v)\n{\n    char buf[25];\n    if (var_isint(v)) {\n        sprintf(buf, BE_INT_FORMAT, var_toint(v));\n    } else if (var_isreal(v)) {\n        sprintf(buf, \"%g\", var_toreal(v));\n    } else {\n        sprintf(buf, \"(nan)\");\n    }\n    return be_newstr(vm, buf);\n}",
        "begin_line": 50,
        "end_line": 61,
        "is_bug": false
    },
    {
        "name": "be_strlib.module2str#63",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.module2str(char *buf, bvalue *v)",
        "snippet": "static void module2str(char *buf, bvalue *v)\n{\n    const char *name = be_module_name(cast(bmodule*, var_toobj(v)));\n    if (name) {\n        sprintf(buf, \"<module: %s>\", name);\n    } else {\n        sprintf(buf, \"<module: %p>\", var_toobj(v));\n    }\n}",
        "begin_line": 63,
        "end_line": 71,
        "is_bug": false
    },
    {
        "name": "be_strlib.sim2str#73",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.sim2str(bvm *vm, bvalue *v)",
        "snippet": "static bstring* sim2str(bvm *vm, bvalue *v)\n{\n    char sbuf[64]; /* BUG: memory overflow */\n    switch (var_type(v)) {\n    case BE_NIL:\n        strcpy(sbuf, \"nil\");\n        break;\n    case BE_BOOL:\n        strcpy(sbuf, var_tobool(v) ? \"true\" : \"false\");\n        break;\n    case BE_INDEX:\n    case BE_INT:\n        sprintf(sbuf, BE_INT_FORMAT, var_toint(v));\n        break;\n    case BE_REAL:\n        sprintf(sbuf, \"%g\", var_toreal(v));\n        break;\n    case BE_CLOSURE: case BE_NTVCLOS: case BE_NTVFUNC:\n        sprintf(sbuf, \"<function: %p>\", var_toobj(v));\n        break;\n    case BE_CLASS:\n        sprintf(sbuf, \"<class: %s>\",\n            str(be_class_name(cast(bclass*, var_toobj(v)))));\n        break;\n    case BE_MODULE:\n        module2str(sbuf, v);\n        break;\n    default:\n        strcpy(sbuf, \"(unknow value)\");\n        break;\n    }\n    return be_newstr(vm, sbuf);\n}",
        "begin_line": 73,
        "end_line": 105,
        "is_bug": false
    },
    {
        "name": "be_strlib.ins2str#107",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.ins2str(bvm *vm, int idx)",
        "snippet": "static bstring* ins2str(bvm *vm, int idx)\n{\n    bstring *s = str_literal(vm, \"tostring\");\n    binstance *obj = var_toobj(vm->reg + idx);\n    /* get method 'tostring' */\n    int type = be_instance_member(vm, obj, s, vm->top);\n    be_incrtop(vm); /* push the obj::tostring to stack */\n    if (basetype(type) != BE_FUNCTION) {\n        bstring *name = be_class_name(be_instance_class(obj));\n        char *sbuf = be_malloc(vm, (size_t)str_len(name) + 16);\n        sprintf(sbuf, \"<instance: %s()>\", str(name));\n        be_stackpop(vm, 1); /* pop the obj::tostring */\n        s = be_newstr(vm, sbuf);\n        be_free(vm, sbuf, (size_t)str_len(name) + 16);\n    } else {\n        *vm->top = vm->reg[idx];\n        be_dofunc(vm, vm->top - 1, 1);\n        be_stackpop(vm, 1); /* pop the obj::tostring */\n        if (!var_isstr(vm->top)) { /* check the return value */\n            const char *name = str(be_instance_name(obj));\n            be_raise(vm, \"runtime_error\", be_pushfstring(vm,\n                \"the value of `%s::tostring()` is not a 'string'\",\n                strlen(name) ? name : \"<anonymous>\"));\n        }\n        s = var_tostr(vm->top);\n    }\n    return s;\n}",
        "begin_line": 107,
        "end_line": 134,
        "is_bug": false
    },
    {
        "name": "be_strlib.be_val2str#136",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.be_val2str(bvm *vm, int index)",
        "snippet": "void be_val2str(bvm *vm, int index)\n{\n    bstring *s;\n    int idx = be_absindex(vm, index) - 1;\n    bvalue *v = vm->reg + idx;\n    if (var_isstr(v)) return; /* do nothing */\n    s = var_isinstance(v) ? ins2str(vm, idx) : sim2str(vm, v);\n    v = vm->reg + idx; /* the stack may change */\n    var_setstr(v, s);\n}",
        "begin_line": 136,
        "end_line": 145,
        "is_bug": false
    },
    {
        "name": "be_strlib.pushstr#147",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.pushstr(bvm *vm, const char *s, size_t len)",
        "snippet": "static void pushstr(bvm *vm, const char *s, size_t len)\n{\n    /* to create a string and then update the top pointer,\n     * otherwise the GC may crash due to uninitialized values.\n     **/\n    bstring *str = be_newstrn(vm, s, len);\n    bvalue *reg = be_incrtop(vm);\n    var_setstr(reg, str);\n}",
        "begin_line": 147,
        "end_line": 155,
        "is_bug": false
    },
    {
        "name": "be_strlib.concat2#157",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.concat2(bvm *vm)",
        "snippet": "static const char* concat2(bvm *vm)\n{\n    bvalue *dst = vm->top - 2;\n    bstring *s1 = var_tostr(dst);\n    bstring *s2 = var_tostr(dst + 1);\n    bstring *s = be_strcat(vm, s1, s2);\n    be_assert(var_isstr(vm->top - 2) && var_isstr(vm->top - 1));\n    dst = vm->top - 2; /* the stack may change */\n    var_setstr(dst, s);\n    --vm->top;\n    return str(s);\n}",
        "begin_line": 157,
        "end_line": 168,
        "is_bug": false
    },
    {
        "name": "be_strlib.be_pushvfstr#170",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.be_pushvfstr(bvm *vm, const char *format, va_list arg)",
        "snippet": "const char* be_pushvfstr(bvm *vm, const char *format, va_list arg)\n{\n    pushstr(vm, \"\", 0);\n    for (;;) {\n        const char *p = strchr(format, '%');\n        if (p == NULL) {\n            break;\n        }\n        pushstr(vm, format, p - format);\n        concat2(vm);\n        switch (p[1]) {\n        case 's': {\n            const char *s = va_arg(arg, char*);\n            if (s == NULL) {\n                s = \"(null)\";\n            }\n            pushstr(vm, s, strlen(s));\n            break;\n        }\n        case 'd': {\n            bstring *s;\n            bvalue *v = be_incrtop(vm);\n            var_setint(v, va_arg(arg, int));\n            s = be_num2str(vm, v);\n            var_setstr(v, s);\n            break;\n        }\n        case 'f': case 'g': {\n            bstring *s;\n            bvalue *v = be_incrtop(vm);\n            var_setreal(v, cast(breal, va_arg(arg, double)));\n            s = be_num2str(vm, v);\n            var_setstr(v, s);\n            break;\n        }\n        case 'c': {\n            char c = cast(char, va_arg(arg, int));\n            pushstr(vm, &c, 1);\n            break;\n        }\n        case '%': {\n            pushstr(vm, \"%\", 1);\n            break;\n        }\n        case 'p': {\n            char buf[2 * sizeof(void*) + 4];\n            sprintf(buf, \"%p\", va_arg(arg, void*));\n            pushstr(vm, buf, strlen(buf));\n            break;\n        }\n        default:\n            pushstr(vm, \"(unknow)\", 8);\n            break;\n        }\n        concat2(vm);\n        format = p + 2;\n    }\n    pushstr(vm, format, strlen(format));\n    return concat2(vm);\n}",
        "begin_line": 170,
        "end_line": 229,
        "is_bug": false
    },
    {
        "name": "be_strlib.be_str2int#237",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.be_str2int(const char *str, const char **endstr)",
        "snippet": "BERRY_API bint be_str2int(const char *str, const char **endstr)\n{\n    int c, sign;\n    bint sum = 0;\n    skip_space(str);\n    sign = c = *str++;\n    if (c == '+' || c == '-') {\n        c = *str++;\n    }\n    while (is_digit(c)) {\n        sum = sum * 10 + c - '0';\n        c = *str++;\n    }\n    if (endstr) {\n        *endstr = str - 1;\n    }\n    return sign == '-' ? -sum : sum;\n}",
        "begin_line": 237,
        "end_line": 254,
        "is_bug": false
    },
    {
        "name": "be_strlib.be_str2real#267",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.be_str2real(const char *str, const char **endstr)",
        "snippet": "BERRY_API breal be_str2real(const char *str, const char **endstr)\n{\n    int c, sign;\n    breal sum = 0, deci = 0, point = (breal)0.1;\n    skip_space(str);\n    sign = c = *str++;\n    if (c == '+' || c == '-') {\n        c = *str++;\n    }\n    while (is_digit(c)) {\n        sum = sum * 10 + c - '0';\n        c = *str++;\n    }\n    if (c == '.') {\n        c = *str++;\n        while (is_digit(c)) {\n            deci = deci + ((breal)c - '0') * point;\n            point *= (breal)0.1;\n            c = *str++;\n        }\n    }\n    sum = sum + deci;\n    if (c == 'e' || c == 'E') {\n        int e = 0;\n        breal ratio = (c = *str++) == '-' ? (breal)0.1 : 10;\n        if (c == '+' || c == '-') {\n            c = *str++;\n        }\n        while (is_digit(c)) {\n            e = e * 10 + c - '0';\n            c = *str++;\n        }\n        while (e--) {\n            sum *= ratio;\n        }\n    }\n    if (endstr) {\n        *endstr = str - 1;\n    }\n    return sign == '-' ? -sum : sum;\n}",
        "begin_line": 267,
        "end_line": 307,
        "is_bug": false
    },
    {
        "name": "be_strlib.be_str2num#313",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.be_str2num(bvm *vm, const char *str)",
        "snippet": "BERRY_API const char *be_str2num(bvm *vm, const char *str)\n{\n    const char *sout; \n    bint c, vint = be_str2int(str, &sout);\n    c = *sout;\n    if (c == '.' || c == 'e' || c == 'E') {\n        be_pushreal(vm, be_str2real(str, &sout));\n    } else {\n        be_pushint(vm, vint);\n    }\n    return sout;\n}",
        "begin_line": 313,
        "end_line": 324,
        "is_bug": false
    },
    {
        "name": "be_strlib.be_strindex#327",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.be_strindex(bvm *vm, bstring *str, bvalue *idx)",
        "snippet": "bstring* be_strindex(bvm *vm, bstring *str, bvalue *idx)\n{\n    if (var_isint(idx)) {\n        int pos = var_toidx(idx);\n        if (pos < str_len(str)) {\n            return be_newstrn(vm, str(str) + pos, 1);\n        }\n        be_raise(vm, \"index_error\", \"string index out of range\");\n    }\n    be_raise(vm, \"index_error\", \"string indices must be integers\");\n    return NULL;\n}",
        "begin_line": 327,
        "end_line": 338,
        "is_bug": false
    },
    {
        "name": "be_strlib.be_strlcpy#340",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.be_strlcpy(char *dst, const char *src, size_t maxlen)",
        "snippet": "size_t be_strlcpy(char *dst, const char *src, size_t maxlen)\n{\n    const size_t srclen = strlen(src);\n    if (srclen + 1 < maxlen) {\n        memcpy(dst, src, srclen + 1);\n    } else if (maxlen != 0) {\n        memcpy(dst, src, maxlen - 1);\n        dst[maxlen-1] = '\\0';\n    }\n    return srclen;\n}",
        "begin_line": 340,
        "end_line": 350,
        "is_bug": false
    },
    {
        "name": "be_strlib.be_splitpath#352",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.be_splitpath(const char *path)",
        "snippet": "const char* be_splitpath(const char *path)\n{\n    const char *p;\n    for (p = path - 1; *path != '\\0'; ++path) {\n        if (*path == '/') {\n            p = path;\n        }\n    }\n    return p + 1; /* return the file name pointer */\n}",
        "begin_line": 352,
        "end_line": 361,
        "is_bug": false
    },
    {
        "name": "be_strlib.be_splitname#363",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.be_splitname(const char *path)",
        "snippet": "const char* be_splitname(const char *path)\n{\n    const char *p, *q, *end = path + strlen(path);\n    for (p = end; *p != '.' && p > path; --p); /* skip [^\\.] */\n    for (q = p; *q == '.' && q > path; --q); /* skip \\. */\n    if ((q == path && *q == '.') || *q == '/') {\n        return end;\n    }\n    return p;\n}",
        "begin_line": 363,
        "end_line": 372,
        "is_bug": false
    },
    {
        "name": "be_strlib.escape_length#374",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.escape_length(const char *s, int quote)",
        "snippet": "static unsigned escape_length(const char *s, int quote)\n{\n    unsigned c, len = 0, step = quote == '\"' ? 5 : 3;\n    for (; (c = *s) != '\\0'; ++s) {\n        switch (c) {\n        case '\\\\': case '\\n': case '\\r': case '\\t':\n            len += 1;\n            break;\n        default:\n            if (c < 0x20)\n                len += step;\n            else if (c == (unsigned)quote)\n                len += 1;\n            break;\n        }\n    }\n    return len;\n}",
        "begin_line": 374,
        "end_line": 391,
        "is_bug": false
    },
    {
        "name": "be_strlib.eschex#393",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.eschex(unsigned num)",
        "snippet": "static unsigned eschex(unsigned num)\n{\n    return num <= 9 ? '0' + num : 'a' + num - 10;\n}",
        "begin_line": 393,
        "end_line": 396,
        "is_bug": false
    },
    {
        "name": "be_strlib.escape#399",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.escape(char *q, unsigned c, int quote)",
        "snippet": "static char* escape(char *q, unsigned c, int quote)\n{\n    int json = quote == '\"';\n    switch (c) {\n    case '\\\\': *q++ = '\\\\'; *q = '\\\\'; break;\n    case '\\n': *q++ = '\\\\'; *q = 'n'; break;\n    case '\\r': *q++ = '\\\\'; *q = 'r'; break;\n    case '\\t': *q++ = '\\\\'; *q = 't'; break;\n    default:\n        if (c < 0x20) { /* other characters are escaped using '\\uxxxx' */\n            *q++ = '\\\\';\n            if (json) {\n                *q++ = 'u'; *q++ = '0'; *q++ = '0';\n                *q++ = (char)eschex(c >> 4);\n                *q = (char)eschex(c & 0x0f);\n            } else {\n                *q++ = 'x';\n                *q++ = (char)eschex(c >> 4);\n                *q = (char)eschex(c & 0x0f);\n            }\n        } else { /* quotes and unescaped characters */\n            if (c == (unsigned)quote)\n                *q++ = '\\\\';\n            *q = (char)c;\n        }\n        break;\n    }\n    return q;\n}",
        "begin_line": 399,
        "end_line": 427,
        "is_bug": false
    },
    {
        "name": "be_strlib.toescape#429",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.toescape(bvm *vm, int index, int quote)",
        "snippet": "static void toescape(bvm *vm, int index, int quote)\n{\n    char *buf, *q;\n    const char *p, *s = be_tostring(vm, index);\n    size_t len = (size_t)be_strlen(vm, index);\n    len += escape_length(s, quote) + 2; /* escape length + quote mark */\n    buf = q = be_pushbuffer(vm, len);\n    *q++ = (char)quote; /* add first quote */\n    /* generate escape string */\n    for (p = s; *p != '\\0'; ++p, ++q) {\n        q = escape(q, *p, quote);\n    }\n    *q = (char)quote; /* add last quote */\n    be_pushnstring(vm, buf, len); /* make escape string from buffer */\n    be_moveto(vm, -1, index);\n    be_pop(vm, 2); /* remove buffer & top string */\n}",
        "begin_line": 429,
        "end_line": 445,
        "is_bug": false
    },
    {
        "name": "be_strlib.be_toescape#447",
        "src_path": "src/be_strlib.c",
        "class_name": "be_strlib",
        "signature": "be_strlib.be_toescape(bvm *vm, int index, int mode)",
        "snippet": "BERRY_API const char* be_toescape(bvm *vm, int index, int mode)\n{\n    if (be_isstring(vm, index)) {\n        index = be_absindex(vm, index);\n        toescape(vm, index, mode == 'u' ? '\"' : '\\'');\n    }\n    return be_tostring(vm, index);\n}",
        "begin_line": 447,
        "end_line": 454,
        "is_bug": false
    },
    {
        "name": "be_gc.be_gc_init#39",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_gc_init(bvm *vm)",
        "snippet": "void be_gc_init(bvm *vm)\n{\n    vm->gc.usage = sizeof(bvm);\n    be_gc_setsteprate(vm, 200);\n}",
        "begin_line": 39,
        "end_line": 43,
        "is_bug": false
    },
    {
        "name": "be_gc.be_gc_deleteall#45",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_gc_deleteall(bvm *vm)",
        "snippet": "void be_gc_deleteall(bvm *vm)\n{\n    bupval *uv, *uvnext;\n    bgcobject *node, *next;\n    /* halt GC and delete all objects */\n    vm->gc.status |= GC_HALT;\n    /* first: call destructor */\n    for (node = vm->gc.list; node; node = node->next) {\n        destruct_object(vm, node);\n    }\n    /* second: free objects */\n    for (node = vm->gc.list; node; node = next) {\n        next = node->next;\n        free_object(vm, node);\n    }\n    /* delete open upvalue list */\n    for (uv = vm->upvalist; uv; uv = uvnext) {\n        uvnext = uv->u.next;\n        be_free(vm, uv, sizeof(bupval));\n    }\n}",
        "begin_line": 45,
        "end_line": 65,
        "is_bug": false
    },
    {
        "name": "be_gc.be_gc_setsteprate#67",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_gc_setsteprate(bvm *vm, int rate)",
        "snippet": "void be_gc_setsteprate(bvm *vm, int rate)\n{\n    be_assert(rate >= 100 && rate <= 355);\n    vm->gc.steprate = (bbyte)(rate - 100);\n    vm->gc.threshold = next_threshold(vm->gc);\n}",
        "begin_line": 67,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "be_gc.be_gc_setpause#74",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_gc_setpause(bvm *vm, int pause)",
        "snippet": "void be_gc_setpause(bvm *vm, int pause)\n{\n    if (pause) {\n        vm->gc.status |= GC_PAUSE;\n    } else {\n        vm->gc.status &= ~GC_PAUSE;\n    }\n}",
        "begin_line": 74,
        "end_line": 81,
        "is_bug": false
    },
    {
        "name": "be_gc.be_newgcobj#83",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_newgcobj(bvm *vm, int type, size_t size)",
        "snippet": "bgcobject* be_newgcobj(bvm *vm, int type, size_t size)\n{\n    bgcobject *obj = be_malloc(vm, size);\n    be_gc_auto(vm);\n    var_settype(obj, (bbyte)type); /* mark the object type */\n    obj->marked = GC_WHITE; /* default gc object type is white */\n    obj->next = vm->gc.list; /* link to the next field */\n    vm->gc.list = obj; /* insert to head */\n    return obj;\n}",
        "begin_line": 83,
        "end_line": 92,
        "is_bug": false
    },
    {
        "name": "be_gc.be_gc_newstr#94",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_gc_newstr(bvm *vm, size_t size, int islong)",
        "snippet": "bgcobject* be_gc_newstr(bvm *vm, size_t size, int islong)\n{\n    bgcobject *obj;\n    if (islong) { /* creating long strings is similar to ordinary GC objects */\n        return be_newgcobj(vm, BE_STRING, size);\n    }\n    obj = be_malloc(vm, size);\n    be_gc_auto(vm);\n    var_settype(obj, BE_STRING); /* mark the object type to BE_STRING */\n    obj->marked = GC_WHITE; /* default string type is white */\n    return obj;\n}",
        "begin_line": 94,
        "end_line": 105,
        "is_bug": false
    },
    {
        "name": "be_gc.be_gc_fix#107",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_gc_fix(bvm *vm, bgcobject *obj)",
        "snippet": "void be_gc_fix(bvm *vm, bgcobject *obj)\n{\n    (void)vm;\n    if (!gc_isconst(obj)) {\n        gc_setfixed(obj);\n    }\n}",
        "begin_line": 107,
        "end_line": 113,
        "is_bug": false
    },
    {
        "name": "be_gc.be_gc_unfix#115",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_gc_unfix(bvm *vm, bgcobject *obj)",
        "snippet": "void be_gc_unfix(bvm *vm, bgcobject *obj)\n{\n    (void)vm;\n    if (!gc_isconst(obj)) {\n        gc_clearfixed(obj);\n    }\n}",
        "begin_line": 115,
        "end_line": 121,
        "is_bug": false
    },
    {
        "name": "be_gc.be_gc_fix_set#123",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_gc_fix_set(bvm *vm, bgcobject *obj, bbool fix)",
        "snippet": "bbool be_gc_fix_set(bvm *vm, bgcobject *obj, bbool fix)\n{\n    (void)vm;\n    bbool was_fixed = gc_isfixed(obj);\n    if (!gc_isconst(obj)) {\n        if (fix) {\n            gc_setfixed(obj);\n        } else {\n            gc_clearfixed(obj);\n        }\n    }\n    return was_fixed;\n}",
        "begin_line": 123,
        "end_line": 135,
        "is_bug": false
    },
    {
        "name": "be_gc.mark_gray#137",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.mark_gray(bvm *vm, bgcobject *obj)",
        "snippet": "static void mark_gray(bvm *vm, bgcobject *obj)\n{\n    if (obj && gc_iswhite(obj) && !gc_isconst(obj)) {\n        gc_setgray(obj);\n        switch (var_type(obj)) {\n        case BE_STRING: gc_setdark(obj); break; /* just set dark */\n        case BE_CLASS: link_gray(vm, cast_class(obj)); break;\n        case BE_PROTO: link_gray(vm, cast_proto(obj)); break;\n        case BE_INSTANCE: link_gray(vm, cast_instance(obj)); break;\n        case BE_MAP: link_gray(vm, cast_map(obj)); break;\n        case BE_LIST: link_gray(vm, cast_list(obj)); break;\n        case BE_CLOSURE: link_gray(vm, cast_closure(obj)); break;\n        case BE_NTVCLOS: link_gray(vm, cast_ntvclos(obj)); break;\n        case BE_MODULE: link_gray(vm, cast_module(obj)); break;\n        case BE_COMOBJ: gc_setdark(obj); break; /* just set dark */\n        default: break;\n        }\n    }\n}",
        "begin_line": 137,
        "end_line": 155,
        "is_bug": false
    },
    {
        "name": "be_gc.mark_gray_var#157",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.mark_gray_var(bvm *vm, bvalue *value)",
        "snippet": "static void mark_gray_var(bvm *vm, bvalue *value)\n{\n    if (be_isgcobj(value)) {\n        mark_gray(vm, var_togc(value));\n    }\n}",
        "begin_line": 157,
        "end_line": 162,
        "is_bug": false
    },
    {
        "name": "be_gc.mark_map#164",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.mark_map(bvm *vm, bgcobject *obj)",
        "snippet": "static void mark_map(bvm *vm, bgcobject *obj)\n{\n    bmap *map = cast_map(obj);\n    gc_try (map != NULL) {\n        bmapnode *node;\n        bmapiter iter = be_map_iter();\n        vm->gc.gray = map->gray; /* remove object from gray list */\n        while ((node = be_map_next(map, &iter)) != NULL) {\n            bmapkey *key = &node->key;\n            bvalue *val = &node->value;\n            if (be_isgctype((signed char)key->type)) {\n                mark_gray(vm, var_togc(key));\n            }\n            mark_gray_var(vm, val);\n        }\n    }\n}",
        "begin_line": 164,
        "end_line": 180,
        "is_bug": false
    },
    {
        "name": "be_gc.mark_list#182",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.mark_list(bvm *vm, bgcobject *obj)",
        "snippet": "static void mark_list(bvm *vm, bgcobject *obj)\n{\n    blist *list = cast_list(obj);\n    gc_try (list != NULL) {\n        bvalue *val = be_list_data(list);\n        bvalue *end = be_list_end(list);\n        vm->gc.gray = list->gray; /* remove object from gray list */\n        for (; val < end; val++) {\n            mark_gray_var(vm, val);\n        }\n    }\n}",
        "begin_line": 182,
        "end_line": 193,
        "is_bug": false
    },
    {
        "name": "be_gc.mark_proto#195",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.mark_proto(bvm *vm, bgcobject *obj)",
        "snippet": "static void mark_proto(bvm *vm, bgcobject *obj)\n{\n    bproto *p = cast_proto(obj);\n    gc_try (p != NULL) {\n        int count;\n        bvalue *k = p->ktab;\n        bproto **ptab = p->ptab;\n        vm->gc.gray = p->gray; /* remove object from gray list */\n        for (count = p->nconst; count--; ++k) {\n            mark_gray_var(vm, k);\n        }\n        for (count = p->nproto; count--; ++ptab) {\n            mark_gray(vm, gc_object(*ptab));\n        }\n        gc_setdark_safe(p->name);\n        gc_setdark_safe(p->source);\n#if BE_DEBUG_VAR_INFO\n        if (p->nvarinfo) {\n            bvarinfo *vinfo = p->varinfo;\n            be_assert(vinfo != NULL);\n            for (count = p->nvarinfo; count--; ++vinfo) {\n                gc_setdark_safe(vinfo->name);\n            }\n        }\n#endif\n    }\n}",
        "begin_line": 195,
        "end_line": 221,
        "is_bug": false
    },
    {
        "name": "be_gc.mark_closure#223",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.mark_closure(bvm *vm, bgcobject *obj)",
        "snippet": "static void mark_closure(bvm *vm, bgcobject *obj)\n{\n    bclosure *cl = cast_closure(obj);\n    gc_try (cl != NULL) {\n        int count = cl->nupvals;\n        bupval **uv = cl->upvals;\n        vm->gc.gray = cl->gray; /* remove object from gray list */\n        for (; count--; ++uv) {\n            if (*uv && (*uv)->refcnt) {\n                mark_gray_var(vm, (*uv)->value);\n            }\n        }\n        mark_gray(vm, gc_object(cl->proto));\n    }\n}",
        "begin_line": 223,
        "end_line": 237,
        "is_bug": false
    },
    {
        "name": "be_gc.mark_ntvclos#239",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.mark_ntvclos(bvm *vm, bgcobject *obj)",
        "snippet": "static void mark_ntvclos(bvm *vm, bgcobject *obj)\n{\n    bntvclos *f = cast_ntvclos(obj);\n    gc_try (f != NULL) {\n        int count = f->nupvals;\n        bupval **uv = &be_ntvclos_upval(f, 0);\n        vm->gc.gray = f->gray; /* remove object from gray list */\n        for (; count--; ++uv) {\n            if (*uv && (*uv)->refcnt) {\n                mark_gray_var(vm, (*uv)->value);\n            }\n        }\n    }\n}",
        "begin_line": 239,
        "end_line": 252,
        "is_bug": false
    },
    {
        "name": "be_gc.mark_class#254",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.mark_class(bvm *vm, bgcobject *obj)",
        "snippet": "static void mark_class(bvm *vm, bgcobject *obj)\n{\n    bclass *c = cast_class(obj);\n    gc_try (c != NULL) {\n        vm->gc.gray = c->gray; /* remove object from gray list */\n        mark_gray(vm, gc_object(be_class_name(c)));\n        mark_gray(vm, gc_object(be_class_members(c)));\n        mark_gray(vm, gc_object(be_class_super(c)));\n    }\n}",
        "begin_line": 254,
        "end_line": 263,
        "is_bug": false
    },
    {
        "name": "be_gc.mark_instance#265",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.mark_instance(bvm *vm, bgcobject *obj)",
        "snippet": "static void mark_instance(bvm *vm, bgcobject *obj)\n{\n    binstance *o = cast_instance(obj);\n    gc_try (o != NULL) {\n        bvalue *var = be_instance_members(o);\n        int nvar = be_instance_member_count(o);\n        vm->gc.gray = o->gray; /* remove object from gray list */\n        mark_gray(vm, gc_object(be_instance_class(o)));\n        mark_gray(vm, gc_object(be_instance_super(o)));\n        for (; nvar--; var++) { /* mark variables */\n            mark_gray_var(vm, var);\n        }\n    }\n}",
        "begin_line": 265,
        "end_line": 278,
        "is_bug": false
    },
    {
        "name": "be_gc.mark_module#280",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.mark_module(bvm *vm, bgcobject *obj)",
        "snippet": "static void mark_module(bvm *vm, bgcobject *obj)\n{\n    bmodule *o = cast_module(obj);\n    gc_try (o != NULL) {\n        vm->gc.gray = o->gray; /* remove object from gray list */\n        mark_gray(vm, gc_object(o->table));\n        if (!gc_isconst(o) && gc_exmark(o) & BE_MODULE_NAME) {\n            mark_gray(vm, gc_object(o->info.sname));\n        }\n    }\n}",
        "begin_line": 280,
        "end_line": 290,
        "is_bug": false
    },
    {
        "name": "be_gc.free_proto#292",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.free_proto(bvm *vm, bgcobject *obj)",
        "snippet": "static void free_proto(bvm *vm, bgcobject *obj)\n{\n    bproto *proto = cast_proto(obj);\n    gc_try (proto != NULL) {\n        be_free(vm, proto->upvals, proto->nupvals * sizeof(bupvaldesc));\n        be_free(vm, proto->ktab, proto->nconst * sizeof(bvalue));\n        be_free(vm, proto->ptab, proto->nproto * sizeof(bproto*));\n        be_free(vm, proto->code, proto->codesize * sizeof(binstruction));\n#if BE_DEBUG_RUNTIME_INFO\n        be_free(vm, proto->lineinfo, proto->nlineinfo * sizeof(blineinfo));\n#endif\n#if BE_DEBUG_VAR_INFO\n        be_free(vm, proto->varinfo, proto->nvarinfo * sizeof(bvarinfo));\n#endif\n        be_free(vm, proto, sizeof(bproto));\n    }\n}",
        "begin_line": 292,
        "end_line": 308,
        "is_bug": false
    },
    {
        "name": "be_gc.free_closure#310",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.free_closure(bvm *vm, bgcobject *obj)",
        "snippet": "static void free_closure(bvm *vm, bgcobject *obj)\n{\n    bclosure *cl = cast_closure(obj);\n    gc_try (cl != NULL) {\n        int count = cl->nupvals;\n        be_release_upvalues(vm, cl);\n        be_free(vm, cl, sizeof(bclosure)\n            + sizeof(bupval*) * ((size_t)count - 1));\n    }\n}",
        "begin_line": 310,
        "end_line": 319,
        "is_bug": false
    },
    {
        "name": "be_gc.free_ntvclos#321",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.free_ntvclos(bvm *vm, bgcobject *obj)",
        "snippet": "static void free_ntvclos(bvm *vm, bgcobject *obj)\n{\n    bntvclos *f = cast_ntvclos(obj);\n    gc_try (f != NULL)  {\n        int count = f->nupvals;\n        bupval **uv = &be_ntvclos_upval(f, 0);\n        while (count--) {\n            be_free(vm, *uv++, sizeof(bupval));\n        }\n        be_free(vm, f, sizeof(bntvclos) + sizeof(bupval*) * f->nupvals);\n    }\n}",
        "begin_line": 321,
        "end_line": 332,
        "is_bug": false
    },
    {
        "name": "be_gc.free_lstring#334",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.free_lstring(bvm *vm, bgcobject *obj)",
        "snippet": "static void free_lstring(bvm *vm, bgcobject *obj)\n{\n    blstring *ls = gc_cast(obj, BE_STRING, blstring);\n    gc_try (ls != NULL)  {\n        be_free(vm, ls, sizeof(blstring) + ls->llen + 1);\n    }\n}",
        "begin_line": 334,
        "end_line": 340,
        "is_bug": false
    },
    {
        "name": "be_gc.free_instance#342",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.free_instance(bvm *vm, bgcobject *obj)",
        "snippet": "static void free_instance(bvm *vm, bgcobject *obj)\n{\n    binstance *o = cast_instance(obj);\n    int nvar = be_instance_member_count(o);\n    be_free(vm, obj, sizeof(binstance) + sizeof(bvalue) * (nvar - 1));\n}",
        "begin_line": 342,
        "end_line": 347,
        "is_bug": false
    },
    {
        "name": "be_gc.free_object#349",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.free_object(bvm *vm, bgcobject *obj)",
        "snippet": "static void free_object(bvm *vm, bgcobject *obj)\n{\n    switch (obj->type) {\n    case BE_STRING: free_lstring(vm, obj); break; /* long string */\n    case BE_CLASS: be_free(vm, obj, sizeof(bclass)); break;\n    case BE_INSTANCE: free_instance(vm, obj); break;\n    case BE_MAP: be_map_delete(vm, cast_map(obj)); break;\n    case BE_LIST: be_list_delete(vm, cast_list(obj)); break;\n    case BE_CLOSURE: free_closure(vm, obj); break;\n    case BE_NTVCLOS: free_ntvclos(vm, obj); break;\n    case BE_PROTO: free_proto(vm, obj); break;\n    case BE_MODULE: be_module_delete(vm, cast_module(obj)); break;\n    case BE_COMOBJ: be_commonobj_delete(vm, obj); break;\n    default: break; /* case BE_STRING: break; */\n    }\n}",
        "begin_line": 349,
        "end_line": 364,
        "is_bug": false
    },
    {
        "name": "be_gc.premark_internal#366",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.premark_internal(bvm *vm)",
        "snippet": "static void premark_internal(bvm *vm)\n{\n    mark_gray(vm, gc_object(vm->module.loaded));\n    mark_gray(vm, gc_object(vm->module.path));\n    mark_gray(vm, gc_object(vm->ntvclass));\n    mark_gray(vm, gc_object(vm->registry));\n#if BE_USE_DEBUG_HOOK\n    if (be_isgcobj(&vm->hook)) {\n        mark_gray(vm, gc_object(var_toobj(&vm->hook)));\n    }\n#endif\n}",
        "begin_line": 366,
        "end_line": 377,
        "is_bug": false
    },
    {
        "name": "be_gc.premark_global#379",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.premark_global(bvm *vm)",
        "snippet": "static void premark_global(bvm *vm)\n{\n    bvalue *v = vm->gbldesc.global.vlist.data;\n    bvalue *end = v + be_global_count(vm);\n    while (v < end) {\n        if (be_isgcobj(v)) {\n            mark_gray(vm, var_togc(v));\n        }\n        ++v;\n    }\n    v = vm->gbldesc.builtin.vlist.data;\n    end = v + be_builtin_count(vm);\n    while (v < end) {\n        mark_gray_var(vm, v++);\n    }\n}",
        "begin_line": 379,
        "end_line": 394,
        "is_bug": false
    },
    {
        "name": "be_gc.premark_stack#396",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.premark_stack(bvm *vm)",
        "snippet": "static void premark_stack(bvm *vm)\n{\n    bvalue *v = vm->stack, *end = vm->top;\n    /* mark live objects */\n    for (; v < end; ++v) {\n        mark_gray_var(vm, v);\n    }\n    /* set other values to nil */\n    end = vm->stacktop;\n    for (; v < end; ++v) {\n        var_setnil(v);\n    }\n}",
        "begin_line": 396,
        "end_line": 408,
        "is_bug": false
    },
    {
        "name": "be_gc.premark_tracestack#410",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.premark_tracestack(bvm *vm)",
        "snippet": "static void premark_tracestack(bvm *vm)\n{\n    bcallsnapshot *cf = be_vector_data(&vm->tracestack);\n    bcallsnapshot *end = be_vector_end(&vm->tracestack);\n    for (; cf <= end; ++cf) {\n        mark_gray_var(vm, &cf->func);\n    }\n}",
        "begin_line": 410,
        "end_line": 417,
        "is_bug": false
    },
    {
        "name": "be_gc.premark_fixed#419",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.premark_fixed(bvm *vm)",
        "snippet": "static void premark_fixed(bvm *vm)\n{\n    bgcobject *node = vm->gc.list;\n    for (; node; node = node->next) {\n        if (gc_isfixed(node) && gc_iswhite(node)) {\n            mark_gray(vm, node);\n        }\n    }\n}",
        "begin_line": 419,
        "end_line": 427,
        "is_bug": false
    },
    {
        "name": "be_gc.mark_unscanned#429",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.mark_unscanned(bvm *vm)",
        "snippet": "static void mark_unscanned(bvm *vm)\n{\n    while (vm->gc.gray) {\n        bgcobject *obj = vm->gc.gray;\n        if (obj && !gc_isdark(obj) && !gc_isconst(obj)) {\n            gc_setdark(obj);\n            switch (var_type(obj)) {\n            case BE_CLASS: mark_class(vm, obj); break;\n            case BE_PROTO: mark_proto(vm, obj); break;\n            case BE_INSTANCE: mark_instance(vm, obj); break;\n            case BE_MAP: mark_map(vm, obj); break;\n            case BE_LIST: mark_list(vm, obj); break;\n            case BE_CLOSURE: mark_closure(vm, obj); break;\n            case BE_NTVCLOS: mark_ntvclos(vm, obj); break;\n            case BE_MODULE: mark_module(vm, obj); break;\n            default:\n                be_assert(0); /* error */\n                break;\n            }\n        }\n    }\n}",
        "begin_line": 429,
        "end_line": 450,
        "is_bug": false
    },
    {
        "name": "be_gc.destruct_object#452",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.destruct_object(bvm *vm, bgcobject *obj)",
        "snippet": "static void destruct_object(bvm *vm, bgcobject *obj)\n{\n    if (vm->gc.status & GC_ALLOC) {\n        return; /* no destructor is called during the allocation. */\n    }\n    if (obj->type == BE_INSTANCE) {\n        int type;\n        binstance *ins = cast_instance(obj);\n        /* does not GC when creating the string \"deinit\". */\n        type = be_instance_member_simple(vm, ins, str_literal(vm, \"deinit\"), vm->top);\n        be_incrtop(vm);\n        if (basetype(type) == BE_FUNCTION) {\n            var_setinstance(vm->top, ins);  /* push instance on stack as arg 1 */\n            be_incrtop(vm);\n            be_dofunc(vm, vm->top - 2, 1);  /* warning, there shoudln't be any exception raised here, or the gc stops */\n            be_stackpop(vm, 1);\n        }\n        be_stackpop(vm, 1);\n    }\n}",
        "begin_line": 452,
        "end_line": 471,
        "is_bug": false
    },
    {
        "name": "be_gc.destruct_white#473",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.destruct_white(bvm *vm)",
        "snippet": "static void destruct_white(bvm *vm)\n{\n    bgcobject *node = vm->gc.list;\n    /* since the destructor may allocate objects, we must first suspend the GC */\n    vm->gc.status |= GC_HALT; /* mark GC is halt */\n    while (node) {\n        if (gc_iswhite(node)) {\n            destruct_object(vm, node);\n        }\n        node = node->next;\n    }\n    vm->gc.status &= ~GC_HALT; /* reset GC halt flag */\n}",
        "begin_line": 473,
        "end_line": 485,
        "is_bug": false
    },
    {
        "name": "be_gc.delete_white#487",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.delete_white(bvm *vm)",
        "snippet": "static void delete_white(bvm *vm)\n{\n    bgcobject *node, *prev, *next;\n    for (node = vm->gc.list, prev = node; node; node = next) {\n        next = node->next;\n        if (gc_iswhite(node)) {\n            if (node == vm->gc.list) { /* first node */\n                vm->gc.list = node->next;\n                prev = node->next;\n            } else { /* not first node */\n                prev->next = next;\n            }\n            free_object(vm, node);\n        } else {\n            gc_setwhite(node);\n            prev = node;\n        }\n    }\n}",
        "begin_line": 487,
        "end_line": 505,
        "is_bug": false
    },
    {
        "name": "be_gc.reset_fixedlist#507",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.reset_fixedlist(bvm *vm)",
        "snippet": "static void reset_fixedlist(bvm *vm)\n{\n    bgcobject *node;\n    for (node = vm->gc.fixed; node; node = node->next) {\n        if (gc_isdark(node)) {\n            gc_setwhite(node);\n        }\n    }\n}",
        "begin_line": 507,
        "end_line": 515,
        "is_bug": false
    },
    {
        "name": "be_gc.be_gc_auto#517",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_gc_auto(bvm *vm)",
        "snippet": "void be_gc_auto(bvm *vm)\n{\n#if BE_USE_DEBUG_GC\n    if (vm->gc.status & GC_PAUSE) { /* force gc each time it's possible */\n        be_gc_collect(vm);\n    }\n#else\n    if (vm->gc.status & GC_PAUSE && vm->gc.usage > vm->gc.threshold) {\n        be_gc_collect(vm);\n    }\n#endif\n}",
        "begin_line": 517,
        "end_line": 528,
        "is_bug": false
    },
    {
        "name": "be_gc.be_gc_memcount#530",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_gc_memcount(bvm *vm)",
        "snippet": "size_t be_gc_memcount(bvm *vm)\n{\n    return vm->gc.usage;\n}",
        "begin_line": 530,
        "end_line": 533,
        "is_bug": false
    },
    {
        "name": "be_gc.be_gc_collect#535",
        "src_path": "src/be_gc.c",
        "class_name": "be_gc",
        "signature": "be_gc.be_gc_collect(bvm *vm)",
        "snippet": "void be_gc_collect(bvm *vm)\n{\n    if (vm->gc.status & GC_HALT) {\n        return; /* the GC cannot run for some reason */\n    }\n#if BE_USE_OBSERVABILITY_HOOK\n    if (vm->obshook != NULL)\n        (*vm->obshook)(vm, BE_OBS_GC_START, vm->gc.usage);\n#endif\n    /* step 1: set root-set reference objects to unscanned */\n    premark_internal(vm); /* object internal the VM */\n    premark_global(vm); /* global objects */\n    premark_stack(vm); /* stack objects */\n    premark_tracestack(vm); /* trace stack objects */\n    premark_fixed(vm); /* fixed objects */\n    /* step 2: set unscanned objects to black */\n    mark_unscanned(vm);\n    /* step 3: destruct and delete unreachable objects */\n    destruct_white(vm);\n    delete_white(vm);\n    be_gcstrtab(vm);\n    /* step 4: reset the fixed objects */\n    reset_fixedlist(vm);\n    /* step 5: calculate the next GC threshold */\n    vm->gc.threshold = next_threshold(vm->gc);\n#if BE_USE_OBSERVABILITY_HOOK\n    if (vm->obshook != NULL)\n        (*vm->obshook)(vm, BE_OBS_GC_END, vm->gc.usage);\n#endif\n}",
        "begin_line": 535,
        "end_line": 564,
        "is_bug": false
    },
    {
        "name": "be_listlib.list_getindex#28",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.list_getindex(bvm *vm, int index)",
        "snippet": "static void list_getindex(bvm *vm, int index)\n{\n    if (!be_getindex(vm, index)) {\n        be_raise(vm, \"index_error\", \"list index out of range\");\n    }\n}",
        "begin_line": 28,
        "end_line": 33,
        "is_bug": false
    },
    {
        "name": "be_listlib.m_init#35",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.m_init(bvm *vm)",
        "snippet": "static int m_init(bvm *vm)\n{\n    int i, argc = be_top(vm);\n    if (argc > 1 && be_islist(vm, 2)) {\n        be_pushvalue(vm, 2);\n        be_setmember(vm, 1, \".p\");\n    } else {\n        be_newlist(vm);\n        be_setmember(vm, 1, \".p\");\n        for (i = 2; i <= argc; ++i) {\n            be_pushvalue(vm, i);\n            be_data_push(vm, -2);\n            be_pop(vm, 1);\n        }\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 35,
        "end_line": 51,
        "is_bug": false
    },
    {
        "name": "be_listlib.push_element#53",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.push_element(bvm *vm)",
        "snippet": "static void push_element(bvm *vm)\n{\n    be_toescape(vm, -1, 'x'); /* escape string */\n    be_strconcat(vm, -3);\n    be_pop(vm, 1);\n}",
        "begin_line": 53,
        "end_line": 58,
        "is_bug": false
    },
    {
        "name": "be_listlib.m_tostring#60",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.m_tostring(bvm *vm)",
        "snippet": "static int m_tostring(bvm *vm)\n{\n    be_getmember(vm, 1, \".p\");\n    list_check_data(vm, 1);\n    list_check_ref(vm);\n    be_refpush(vm, 1);\n    be_pushstring(vm, \"[\");\n    be_pushiter(vm, -2);\n    while (be_iter_hasnext(vm, -3)) {\n        be_iter_next(vm, -3);\n        push_element(vm);\n        if (be_iter_hasnext(vm, -3)) {\n            be_pushstring(vm, \", \");\n            be_strconcat(vm, -3);\n            be_pop(vm, 1);\n        }\n    }\n    be_pop(vm, 1); /* pop iterator */\n    be_pushstring(vm, \"]\");\n    be_strconcat(vm, -2);\n    be_pop(vm, 1);\n    be_refpop(vm);\n    be_return(vm);\n}",
        "begin_line": 60,
        "end_line": 83,
        "is_bug": false
    },
    {
        "name": "be_listlib.m_push#85",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.m_push(bvm *vm)",
        "snippet": "static int m_push(bvm *vm)\n{\n    be_getmember(vm, 1, \".p\");\n    list_check_data(vm, 2);\n    be_pushvalue(vm, 2);\n    be_data_push(vm, -2);\n    be_return_nil(vm);\n}",
        "begin_line": 85,
        "end_line": 92,
        "is_bug": false
    },
    {
        "name": "be_listlib.m_pop#94",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.m_pop(bvm *vm)",
        "snippet": "static int m_pop(bvm *vm)\n{\n    int argc = be_top(vm);\n    be_getmember(vm, 1, \".p\");\n    list_check_data(vm, 1);\n    if (argc >= 2) {\n        be_pushvalue(vm, 2);\n    } else {\n        be_pushint(vm, -1);\n    }\n    list_getindex(vm, -2);\n    be_pushvalue(vm, -2);\n    be_data_remove(vm, -4);\n    be_pop(vm, 1);\n    be_return(vm);\n}",
        "begin_line": 94,
        "end_line": 109,
        "is_bug": false
    },
    {
        "name": "be_listlib.m_insert#111",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.m_insert(bvm *vm)",
        "snippet": "static int m_insert(bvm *vm)\n{\n    be_getmember(vm, 1, \".p\");\n    list_check_data(vm, 3);\n    be_pushvalue(vm, 2);\n    be_pushvalue(vm, 3);\n    be_data_insert(vm, -3);\n    be_return_nil(vm);\n}",
        "begin_line": 111,
        "end_line": 119,
        "is_bug": false
    },
    {
        "name": "be_listlib.m_remove#121",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.m_remove(bvm *vm)",
        "snippet": "static int m_remove(bvm *vm)\n{\n    be_getmember(vm, 1, \".p\");\n    list_check_data(vm, 2);\n    be_pushvalue(vm, 2);\n    be_data_remove(vm, -2);\n    be_return_nil(vm);\n}",
        "begin_line": 121,
        "end_line": 128,
        "is_bug": false
    },
    {
        "name": "be_listlib.item_range#130",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.item_range(bvm *vm)",
        "snippet": "static int item_range(bvm *vm)\n{\n    bint lower, upper;\n    bint size = be_data_size(vm, -1); /* get source list size */\n    /* get index range */\n    be_getmember(vm, 2, \"__lower__\");\n    lower = be_toint(vm, -1);\n    be_pop(vm, 1);\n    be_getmember(vm, 2, \"__upper__\");\n    upper = be_toint(vm, -1);\n    be_pop(vm, 1);\n    /* protection scope */\n    upper = upper < size ? upper : size - 1;\n    lower = lower < 0 ? 0 : lower;\n    /* construction result list instance */\n    be_newobject(vm, \"list\"); /* result list */\n    be_getmember(vm, 1, \".p\"); /* source list */\n    /* copy elements */\n    for (; lower <= upper; ++lower) {\n        be_pushint(vm, lower);\n        list_getindex(vm, -2);\n        be_data_push(vm, -4);\n        be_pop(vm, 2);\n    }\n    be_pop(vm, 2);\n    be_return(vm);\n}",
        "begin_line": 130,
        "end_line": 156,
        "is_bug": false
    },
    {
        "name": "be_listlib.item_list#158",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.item_list(bvm *vm)",
        "snippet": "static int item_list(bvm *vm)\n{\n    int i, srcsize, idxsize;\n    be_getmember(vm, 2, \".p\"); /* get index list */\n    srcsize = be_data_size(vm, -2); /* get source list size */\n    idxsize = be_data_size(vm, -1); /* get index list size */\n    /* construction result list instance */\n    be_newobject(vm, \"list\"); /* result list */\n    be_getmember(vm, 1, \".p\"); /* source list */\n    /* copy elements */\n    for (i = 0; i < idxsize; ++i) {\n        be_pushint(vm, i);\n        be_getindex(vm, -5);\n        if (be_isint(vm, -1)) {\n            int idx = be_toindex(vm, -1);\n            if (idx >= 0 && idx < srcsize) {\n                be_getindex(vm, -3);\n            } else {\n                be_pushnil(vm);\n            }\n        } else {\n            be_pushnil(vm);\n        }\n        be_data_push(vm, -5);\n        be_pop(vm, 3);\n    }\n    be_pop(vm, 2);\n    be_return(vm);\n}",
        "begin_line": 158,
        "end_line": 186,
        "is_bug": false
    },
    {
        "name": "be_listlib.m_item#188",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.m_item(bvm *vm)",
        "snippet": "static int m_item(bvm *vm)\n{\n    be_getmember(vm, 1, \".p\");\n    list_check_data(vm, 2);\n    if (be_isint(vm, 2)) {\n        be_pushvalue(vm, 2);\n        list_getindex(vm, -2);\n        be_return(vm);\n    }\n    if (be_isinstance(vm, 2)) {\n        const char *cname = be_classname(vm, 2);\n        if (!strcmp(cname, \"range\")) {\n            return item_range(vm);\n        }\n        if (!strcmp(cname, \"list\")) {\n            return item_list(vm);\n        }\n    }\n    be_raise(vm, \"index_error\", \"list index out of range\");\n    be_return_nil(vm);\n}",
        "begin_line": 188,
        "end_line": 208,
        "is_bug": false
    },
    {
        "name": "be_listlib.m_find#210",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.m_find(bvm *vm)",
        "snippet": "static int m_find(bvm *vm)\n{\n    bbool found = bfalse;\n    int idx;\n    be_getmember(vm, 1, \".p\");\n    list_check_data(vm, 2);\n    list_check_ref(vm);\n    be_refpush(vm, 1);\n    be_pushiter(vm, -1);\n    for (idx=0; be_iter_hasnext(vm, -2); idx++) {\n        be_iter_next(vm, -2);\n        be_pushvalue(vm, 2);    /* push needle to compare */\n        if (be_iseq(vm)) {\n            found = btrue;\n            be_pop(vm, 2);\n            break;\n        }\n        be_pop(vm, 2);\n    }\n    be_pop(vm, 1); /* pop iterator */\n    be_refpop(vm);\n    if (found) {\n        be_pushint(vm, idx);\n        be_return(vm);\n    } else {\n        be_return_nil(vm);\n    }\n}",
        "begin_line": 210,
        "end_line": 237,
        "is_bug": false
    },
    {
        "name": "be_listlib.m_setitem#239",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.m_setitem(bvm *vm)",
        "snippet": "static int m_setitem(bvm *vm)\n{\n    be_getmember(vm, 1, \".p\");\n    list_check_data(vm, 3);\n    be_pushvalue(vm, 2);\n    be_pushvalue(vm, 3);\n    if (!be_setindex(vm, -3)) {\n        be_raise(vm, \"index_error\", \"list assignment index out of range\");\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 239,
        "end_line": 249,
        "is_bug": false
    },
    {
        "name": "be_listlib.m_size#251",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.m_size(bvm *vm)",
        "snippet": "static int m_size(bvm *vm)\n{\n    be_getmember(vm, 1, \".p\");\n    list_check_data(vm, 1);\n    be_pushint(vm, be_data_size(vm, -1));\n    be_return(vm);\n}",
        "begin_line": 251,
        "end_line": 257,
        "is_bug": false
    },
    {
        "name": "be_listlib.m_resize#259",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.m_resize(bvm *vm)",
        "snippet": "static int m_resize(bvm *vm)\n{\n    be_getmember(vm, 1, \".p\");\n    list_check_data(vm, 2);\n    be_pushvalue(vm, 2);\n    be_data_resize(vm, -2);\n    be_return_nil(vm);\n}",
        "begin_line": 259,
        "end_line": 266,
        "is_bug": false
    },
    {
        "name": "be_listlib.m_clear#268",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.m_clear(bvm *vm)",
        "snippet": "static int m_clear(bvm *vm)\n{\n    be_getmember(vm, 1, \".p\");\n    list_check_data(vm, 1);\n    be_pushint(vm, 0);\n    be_data_resize(vm, -2);\n    be_return_nil(vm);\n}",
        "begin_line": 268,
        "end_line": 275,
        "is_bug": false
    },
    {
        "name": "be_listlib.iter_closure#277",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.iter_closure(bvm *vm)",
        "snippet": "static int iter_closure(bvm *vm)\n{\n    /* for better performance, we operate the upvalues\n     * directly without using by the stack. */\n    bntvclos *func = var_toobj(vm->cf->func);\n    bvalue *uv0 = be_ntvclos_upval(func, 0)->value; /* list value */\n    bvalue *uv1 = be_ntvclos_upval(func, 1)->value; /* iter value */\n    bvalue *next = cast(bvalue*, var_toobj(uv1)) + 1;\n    blist *list = var_toobj(uv0);\n    if (next >= be_list_end(list)) {\n        be_stop_iteration(vm);\n    }\n    var_toobj(uv1) = next; /* set upvale[1] (iter value) */\n    /* push next value to top */\n    var_setval(vm->top, next);\n    be_incrtop(vm);\n    be_return(vm);\n}",
        "begin_line": 277,
        "end_line": 294,
        "is_bug": false
    },
    {
        "name": "be_listlib.m_iter#296",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.m_iter(bvm *vm)",
        "snippet": "static int m_iter(bvm *vm)\n{\n    be_pushntvclosure(vm, iter_closure, 2);\n    be_getmember(vm, 1, \".p\");\n    be_setupval(vm, -2, 0);\n    be_pushiter(vm, -1);\n    be_setupval(vm, -3, 1);\n    be_pop(vm, 2);\n    be_return(vm);\n}",
        "begin_line": 296,
        "end_line": 305,
        "is_bug": false
    },
    {
        "name": "be_listlib.m_connect#307",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.m_connect(bvm *vm)",
        "snippet": "static int m_connect(bvm *vm)\n{\n    int argc = be_top(vm);\n    if (argc >= 2) {\n        be_getmember(vm, 1, \".p\");\n        be_pushvalue(vm, 2);\n        be_data_push(vm, -2);\n        be_pop(vm, argc + 1);\n    }\n    be_return(vm); /* return self */\n}",
        "begin_line": 307,
        "end_line": 317,
        "is_bug": false
    },
    {
        "name": "be_listlib.m_merge#319",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.m_merge(bvm *vm)",
        "snippet": "static int m_merge(bvm *vm)\n{\n    int argc = be_top(vm);\n    if (argc >= 2) {\n        be_newobject(vm, \"list\"); /* stack contains instance and .p */\n        be_getmember(vm, 1, \".p\");\n        be_data_merge(vm, -2);\n        be_getmember(vm, 2, \".p\");\n        if (!be_islist(vm, -1)) {\n            be_raise(vm, \"type_error\", \"operand must be a list\");\n        }\n        be_data_merge(vm, -3);\n        be_pop(vm, 3);\n    }\n    be_return(vm); /* return self */\n}",
        "begin_line": 319,
        "end_line": 334,
        "is_bug": false
    },
    {
        "name": "be_listlib.connect#336",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.connect(bvm *vm, bvalue *begin, bvalue *end)",
        "snippet": "static void connect(bvm *vm, bvalue *begin, bvalue *end)\n{\n    size_t l0 = be_strlen(vm, -1), len = l0;\n    char *buf, *p;\n    bvalue *it;\n    for (it = begin; it < end; ++it) {\n        len += str_len(var_tostr(it));\n    }\n    buf = be_pushbuffer(vm, len);\n    memcpy(buf, be_tostring(vm, -2), l0);\n    p = buf + l0;\n    for (it = begin; it < end; ++it) {\n        bstring *s = var_tostr(it);\n        size_t l = str_len(s);\n        memcpy(p, str(s), l);\n        p += l;\n    }\n    be_pushstring(vm, buf);\n    be_moveto(vm, -1, -3);\n    be_pop(vm, 2);\n}",
        "begin_line": 336,
        "end_line": 356,
        "is_bug": false
    },
    {
        "name": "be_listlib.list_concat#358",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.list_concat(bvm *vm, blist *list)",
        "snippet": "static void list_concat(bvm *vm, blist *list)\n{\n    bvalue *it, *begin = be_list_data(list);\n    bvalue *end = be_list_end(list);\n    be_pushstring(vm, \"\"); /* push a empty string */\n    for (it = begin; it < end;) {\n        for (; it < end && var_isstr(it); ++it);\n        connect(vm, begin, it); /* connect string list */\n        if (it < end) {\n            /* connect other value */\n            var_setval(vm->top, it);\n            be_incrtop(vm);\n            be_val2str(vm, -1);\n            be_strconcat(vm, -2);\n            be_pop(vm, 1);\n            begin = ++it;\n        }\n    }\n}",
        "begin_line": 358,
        "end_line": 376,
        "is_bug": false
    },
    {
        "name": "be_listlib.m_concat#378",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.m_concat(bvm *vm)",
        "snippet": "static int m_concat(bvm *vm)\n{\n    bvalue *value;\n    be_getmember(vm, 1, \".p\");\n    list_check_data(vm, 1);\n    value = be_indexof(vm, -1);\n    list_concat(vm, var_toobj(value));\n    be_return(vm);\n}",
        "begin_line": 378,
        "end_line": 386,
        "is_bug": false
    },
    {
        "name": "be_listlib.m_reverse#388",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.m_reverse(bvm *vm)",
        "snippet": "static int m_reverse(bvm *vm)\n{\n    int top = be_top(vm);\n    be_getmember(vm, 1, \".p\");\n    list_check_data(vm, 1);\n    be_data_reverse(vm, -1);\n    be_pop(vm, top);\n    be_return(vm);\n}",
        "begin_line": 388,
        "end_line": 396,
        "is_bug": false
    },
    {
        "name": "be_listlib.m_copy#398",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.m_copy(bvm *vm)",
        "snippet": "static int m_copy(bvm *vm)\n{\n    be_getmember(vm, 1, \".p\");\n    list_check_data(vm, 1);\n    be_getbuiltin(vm, \"list\");\n    be_copy(vm, -2);\n    be_call(vm, 1);\n    be_pop(vm, 1);\n    be_return(vm);\n}",
        "begin_line": 398,
        "end_line": 407,
        "is_bug": false
    },
    {
        "name": "be_listlib.list_equal#409",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.list_equal(bvm *vm, bbool iseq)",
        "snippet": "static int list_equal(bvm *vm, bbool iseq)\n{\n    int i, j, res;\n    bbool (*eqfunc)(bvm*) = iseq ? be_iseq : be_isneq;\n    be_getmember(vm, 1, \".p\");\n    be_getmember(vm, 2, \".p\");\n    i = be_data_size(vm, -2);\n    j = be_data_size(vm, -1);\n    if (i == j) {\n        res = iseq;\n        for (i = 0; res == iseq && i < j; ++i) {\n            be_pushint(vm, i);\n            be_getindex(vm, -3);\n            be_pushint(vm, i);\n            be_getindex(vm, -4);\n            be_remove(vm, -2);\n            res = eqfunc(vm);\n            be_pop(vm, 3);\n        }\n    } else {\n        res = !iseq;\n    }\n    be_pushbool(vm, res);\n    be_return(vm);\n}",
        "begin_line": 409,
        "end_line": 433,
        "is_bug": false
    },
    {
        "name": "be_listlib.m_equal#435",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.m_equal(bvm *vm)",
        "snippet": "static int m_equal(bvm *vm)\n{\n    return list_equal(vm, btrue);\n}",
        "begin_line": 435,
        "end_line": 438,
        "is_bug": false
    },
    {
        "name": "be_listlib.m_nequal#440",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.m_nequal(bvm *vm)",
        "snippet": "static int m_nequal(bvm *vm)\n{\n    return list_equal(vm, bfalse);\n}",
        "begin_line": 440,
        "end_line": 443,
        "is_bug": false
    },
    {
        "name": "be_listlib.be_load_listlib#446",
        "src_path": "src/be_listlib.c",
        "class_name": "be_listlib",
        "signature": "be_listlib.be_load_listlib(bvm *vm)",
        "snippet": "void be_load_listlib(bvm *vm)\n{\n    static const bnfuncinfo members[] = {\n        { \".p\", NULL },\n        { \"init\", m_init },\n        { \"tostring\", m_tostring },\n        { \"push\", m_push },\n        { \"pop\", m_pop },\n        { \"insert\", m_insert },\n        { \"remove\", m_remove },\n        { \"item\", m_item },\n        { \"find\", m_find },\n        { \"setitem\", m_setitem },\n        { \"size\", m_size },\n        { \"resize\", m_resize },\n        { \"clear\", m_clear },\n        { \"iter\", m_iter },\n        { \"concat\", m_concat },\n        { \"reverse\", m_reverse },\n        { \"copy\", m_copy },\n        { \"..\", m_connect },\n        { \"+\", m_merge },\n        { \"==\", m_equal },\n        { \"!=\", m_nequal },\n        { NULL, NULL }\n    };\n    be_regclass(vm, \"list\", members);\n}",
        "begin_line": 446,
        "end_line": 473,
        "is_bug": false
    },
    {
        "name": "be_func.findupval#18",
        "src_path": "src/be_func.c",
        "class_name": "be_func",
        "signature": "be_func.findupval(bvm *vm, bvalue *level)",
        "snippet": "static bupval* findupval(bvm *vm, bvalue *level)\n{\n    bupval *node = vm->upvalist;\n    while (node != NULL && node->value > level) {\n        node = node->u.next;\n    }\n    if (!node || node->value != level) {\n        /* not found */\n        node = be_malloc(vm, sizeof(bupval));\n        node->value = level;\n        node->refcnt = 0;\n        /* insert to list head */\n        node->u.next = vm->upvalist;\n        vm->upvalist = node;\n    }\n    return node;\n}",
        "begin_line": 18,
        "end_line": 34,
        "is_bug": false
    },
    {
        "name": "be_func.be_initupvals#36",
        "src_path": "src/be_func.c",
        "class_name": "be_func",
        "signature": "be_func.be_initupvals(bvm *vm, bclosure *cl)",
        "snippet": "void be_initupvals(bvm *vm, bclosure *cl)\n{\n    int count = cl->proto->nupvals;\n    bupvaldesc *desc = cl->proto->upvals;\n    bvalue *stack = vm->reg;\n    bupval **uv = cl->upvals;\n    bupval **superuv = cast(bclosure*, var_toobj(vm->cf->func))->upvals;\n    for (; count--; desc++, uv++) {\n        if (desc->instack) {\n            bvalue *ref = stack + desc->idx;\n            *uv = findupval(vm, ref);\n        } else {\n            *uv = superuv[desc->idx];\n        }\n        (*uv)->refcnt++;\n    }\n}",
        "begin_line": 36,
        "end_line": 52,
        "is_bug": false
    },
    {
        "name": "be_func.be_upvals_close#54",
        "src_path": "src/be_func.c",
        "class_name": "be_func",
        "signature": "be_func.be_upvals_close(bvm *vm, bvalue *level)",
        "snippet": "void be_upvals_close(bvm *vm, bvalue *level)\n{\n    bupval *node = vm->upvalist, *next;\n    bupval **prev = &vm->upvalist;\n    while (node) {\n        next = node->u.next;\n        if (node->value >= level) {\n            if (!node->refcnt) {\n                be_free(vm, node, sizeof(bupval));\n            } else {\n                node->u.value = *node->value; /* move value to upvalue slot */\n                node->value = &node->u.value;\n            }\n            *prev = next;   /* remove from linked list */\n        } else {\n            prev = &node->u.next;\n        }\n        node = next;\n    }\n}",
        "begin_line": 54,
        "end_line": 73,
        "is_bug": false
    },
    {
        "name": "be_func.be_release_upvalues#75",
        "src_path": "src/be_func.c",
        "class_name": "be_func",
        "signature": "be_func.be_release_upvalues(bvm *vm, bclosure *cl)",
        "snippet": "void be_release_upvalues(bvm *vm, bclosure *cl)\n{\n    int i, count = cl->nupvals;\n    for (i = 0; i < count; ++i) {\n        bupval *uv = cl->upvals[i];\n        if (uv) {\n            if (uv->refcnt) {\n                --uv->refcnt;\n            }\n            /* delete non-referenced closed upvalue */\n            if (uv->value == &uv->u.value && !uv->refcnt) {\n                be_free(vm, uv, sizeof(bupval));\n            }\n        }\n    }\n}",
        "begin_line": 75,
        "end_line": 90,
        "is_bug": false
    },
    {
        "name": "be_func.be_newproto#92",
        "src_path": "src/be_func.c",
        "class_name": "be_func",
        "signature": "be_func.be_newproto(bvm *vm)",
        "snippet": "bproto* be_newproto(bvm *vm)\n{\n    bgcobject *gco = be_gcnew(vm, BE_PROTO, bproto);\n    bproto *p = cast_proto(gco);\n    if (p) {\n        p->upvals = NULL;\n        p->ktab = NULL;\n        p->ptab = NULL;\n        p->code = NULL;\n        p->name = NULL;\n        p->gray = NULL;\n        p->codesize = 0;\n        p->nupvals = 0;\n        p->nproto = 0;\n        p->nconst = 0;\n        p->nstack = 0;\n        p->codesize = 0;\n        p->argc = 0;\n        p->varg = 0;\n        p->source = NULL;\n#if BE_DEBUG_RUNTIME_INFO\n        p->lineinfo = NULL;\n        p->nlineinfo = 0;\n#endif\n#if BE_DEBUG_VAR_INFO\n        p->varinfo = NULL;\n        p->nvarinfo = 0;\n#endif\n    }\n    return p;\n}",
        "begin_line": 92,
        "end_line": 122,
        "is_bug": false
    },
    {
        "name": "be_func.be_newclosure#124",
        "src_path": "src/be_func.c",
        "class_name": "be_func",
        "signature": "be_func.be_newclosure(bvm *vm, int nupval)",
        "snippet": "bclosure* be_newclosure(bvm *vm, int nupval)\n{\n    bgcobject *gco = be_newgcobj(vm, BE_CLOSURE, clousersize(nupval));\n    bclosure *cl = cast_closure(gco);\n    if (cl) {\n        cl->proto = NULL;\n        cl->nupvals = (bbyte)nupval;\n        while (nupval--) {\n            cl->upvals[nupval] = NULL;\n        }\n    }\n    return cl;\n}",
        "begin_line": 124,
        "end_line": 136,
        "is_bug": false
    },
    {
        "name": "be_func.init_upvals#138",
        "src_path": "src/be_func.c",
        "class_name": "be_func",
        "signature": "be_func.init_upvals(bvm *vm, bntvclos *f)",
        "snippet": "static void init_upvals(bvm *vm, bntvclos *f)\n{\n    int count = f->nupvals;\n    bupval **upvals = &be_ntvclos_upval(f, 0);\n    while (count--) {\n        bupval *uv = be_malloc(vm, sizeof(bupval)); /* was closed */\n        uv->value = &uv->u.value;\n        uv->refcnt = 1;\n        var_setnil(uv->value);\n        *upvals++ = uv;\n    }\n}",
        "begin_line": 138,
        "end_line": 149,
        "is_bug": false
    },
    {
        "name": "be_func.be_newntvclosure#151",
        "src_path": "src/be_func.c",
        "class_name": "be_func",
        "signature": "be_func.be_newntvclosure(bvm *vm, bntvfunc cf, int nupvals)",
        "snippet": "bntvclos* be_newntvclosure(bvm *vm, bntvfunc cf, int nupvals)\n{\n    size_t size = sizeof(bntvclos) + sizeof(bupval*) * nupvals;\n    bgcobject *gco = be_newgcobj(vm, BE_NTVCLOS, size);\n    bntvclos *f = cast_ntvclos(gco);\n    if (f) {\n        f->f = cf;\n        f->nupvals = (bbyte)nupvals;\n        if (nupvals) {\n            var_setntvclos(vm->top, f);\n            be_incrtop(vm);\n            init_upvals(vm, f); /* may be GC */\n            be_stackpop(vm, 1);\n        }\n    }\n    return f;\n}",
        "begin_line": 151,
        "end_line": 167,
        "is_bug": false
    },
    {
        "name": "be_byteslib.binary_to_base64#100",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.binary_to_base64(unsigned char v)",
        "snippet": "static unsigned char binary_to_base64(unsigned char v) {\n  // Capital letters - 'A' is ascii 65 and base64 0\n  if(v < 26) return v + 'A';\n  \n  // Lowercase letters - 'a' is ascii 97 and base64 26\n  if(v < 52) return v + 71;\n  \n  // Digits - '0' is ascii 48 and base64 52\n  if(v < 62) return v - 4;\n  \n  // '+' is ascii 43 and base64 62\n  if(v == 62) return '+';\n  \n  // '/' is ascii 47 and base64 63\n  if(v == 63) return '/';\n  \n  return 64;\n}",
        "begin_line": 100,
        "end_line": 117,
        "is_bug": false
    },
    {
        "name": "be_byteslib.base64_to_binary#119",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.base64_to_binary(unsigned char c)",
        "snippet": "static unsigned char base64_to_binary(unsigned char c) {\n  // Capital letters - 'A' is ascii 65 and base64 0\n  if('A' <= c && c <= 'Z') return c - 'A';\n  \n  // Lowercase letters - 'a' is ascii 97 and base64 26\n  if('a' <= c && c <= 'z') return c - 71;\n  \n  // Digits - '0' is ascii 48 and base64 52\n  if('0' <= c && c <= '9') return c + 4;\n  \n  // '+' is ascii 43 and base64 62\n  if(c == '+') return 62;\n  \n  // '/' is ascii 47 and base64 63\n  if(c == '/') return 63;\n  \n  return 255;\n}",
        "begin_line": 119,
        "end_line": 136,
        "is_bug": false
    },
    {
        "name": "be_byteslib.encode_base64_length#138",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.encode_base64_length(unsigned int input_length)",
        "snippet": "static unsigned int encode_base64_length(unsigned int input_length) {\n  return (input_length + 2)/3*4;\n}",
        "begin_line": 138,
        "end_line": 140,
        "is_bug": false
    },
    {
        "name": "be_byteslib.decode_base64_length#142",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.decode_base64_length(unsigned char input[])",
        "snippet": "static unsigned int decode_base64_length(unsigned char input[]) {\n  unsigned char *start = input;\n  \n  while(base64_to_binary(input[0]) < 64) {\n    ++input;\n  }\n  \n  unsigned int input_length = input - start;\n  \n  unsigned int output_length = input_length/4*3;\n  \n  switch(input_length % 4) {\n    default: return output_length;\n    case 2: return output_length + 1;\n    case 3: return output_length + 2;\n  }\n}",
        "begin_line": 142,
        "end_line": 158,
        "is_bug": false
    },
    {
        "name": "be_byteslib.encode_base64#160",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.encode_base64(unsigned char input[], unsigned int input_length, unsigned char output[])",
        "snippet": "static unsigned int encode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {\n  unsigned int full_sets = input_length/3;\n  \n  // While there are still full sets of 24 bits...\n  for(unsigned int i = 0; i < full_sets; ++i) {\n    output[0] = binary_to_base64(                         input[0] >> 2);\n    output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);\n    output[2] = binary_to_base64((input[1] & 0x0F) << 2 | input[2] >> 6);\n    output[3] = binary_to_base64( input[2] & 0x3F);\n    \n    input += 3;\n    output += 4;\n  }\n  \n  switch(input_length % 3) {\n    case 0:\n      output[0] = '\\0';\n      break;\n    case 1:\n      output[0] = binary_to_base64(                         input[0] >> 2);\n      output[1] = binary_to_base64((input[0] & 0x03) << 4);\n      output[2] = '=';\n      output[3] = '=';\n      output[4] = '\\0';\n      break;\n    case 2:\n      output[0] = binary_to_base64(                         input[0] >> 2);\n      output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);\n      output[2] = binary_to_base64((input[1] & 0x0F) << 2);\n      output[3] = '=';\n      output[4] = '\\0';\n      break;\n  }\n  \n  return encode_base64_length(input_length);\n}",
        "begin_line": 160,
        "end_line": 195,
        "is_bug": false
    },
    {
        "name": "be_byteslib.decode_base64#197",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.decode_base64(unsigned char input[], unsigned char output[])",
        "snippet": "static unsigned int decode_base64(unsigned char input[], unsigned char output[]) {\n  unsigned int output_length = decode_base64_length(input);\n  \n  // While there are still full sets of 24 bits...\n  for(unsigned int i = 2; i < output_length; i += 3) {\n    output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;\n    output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;\n    output[2] = base64_to_binary(input[2]) << 6 | base64_to_binary(input[3]);\n    \n    input += 4;\n    output += 3;\n  }\n  \n  switch(output_length % 3) {\n    case 1:\n      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;\n      break;\n    case 2:\n      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;\n      output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;\n      break;\n  }\n  \n  return output_length;\n}",
        "begin_line": 197,
        "end_line": 221,
        "is_bug": false
    },
    {
        "name": "be_byteslib.buf_get_buf#228",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.buf_get_buf(buf_impl* buf)",
        "snippet": "static inline uint8_t* buf_get_buf(buf_impl* buf)\n{\n    return &buf->buf[0];\n}",
        "begin_line": 228,
        "end_line": 231,
        "is_bug": false
    },
    {
        "name": "be_byteslib.buf_set_len#234",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.buf_set_len(buf_impl* buf, const size_t len)",
        "snippet": "static void buf_set_len(buf_impl* buf, const size_t len)\n{\n    uint16_t old_len = buf->len;\n    buf->len = (len <= buf->size) ? len : buf->size;\n    if (old_len < buf->len) {\n        memset((void*) &buf->buf[old_len], 0, buf->len - old_len);\n    }\n}",
        "begin_line": 234,
        "end_line": 241,
        "is_bug": false
    },
    {
        "name": "be_byteslib.buf_add1#243",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.buf_add1(buf_impl* buf, const uint8_t data) // append 8 bits value",
        "snippet": "static size_t buf_add1(buf_impl* buf, const uint8_t data) // append 8 bits value\n{\n    if (buf->len < buf->size) {       // do we have room for 1 byte\n        buf->buf[buf->len++] = data;\n    }\n    return buf->len;\n}",
        "begin_line": 243,
        "end_line": 249,
        "is_bug": false
    },
    {
        "name": "be_byteslib.buf_add2_le#251",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.buf_add2_le(buf_impl* buf, const uint16_t data) // append 16 bits value",
        "snippet": "static size_t buf_add2_le(buf_impl* buf, const uint16_t data) // append 16 bits value\n{\n    if (buf->len < buf->size - 1) {    // do we have room for 2 bytes\n        buf->buf[buf->len++] = data;\n        buf->buf[buf->len++] = data >> 8;\n    }\n    return buf->len;\n}",
        "begin_line": 251,
        "end_line": 258,
        "is_bug": false
    },
    {
        "name": "be_byteslib.buf_add2_be#260",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.buf_add2_be(buf_impl* buf, const uint16_t data) // append 16 bits value",
        "snippet": "static size_t buf_add2_be(buf_impl* buf, const uint16_t data) // append 16 bits value\n{\n    if (buf->len < buf->size - 1) {    // do we have room for 2 bytes\n        buf->buf[buf->len++] = data >> 8;\n        buf->buf[buf->len++] = data;\n    }\n    return buf->len;\n}",
        "begin_line": 260,
        "end_line": 267,
        "is_bug": false
    },
    {
        "name": "be_byteslib.buf_add4_le#269",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.buf_add4_le(buf_impl* buf, const uint32_t data) // append 32 bits value",
        "snippet": "static size_t buf_add4_le(buf_impl* buf, const uint32_t data) // append 32 bits value\n{\n    if (buf->len < buf->size - 3) {     // do we have room for 4 bytes\n        buf->buf[buf->len++] = data;\n        buf->buf[buf->len++] = data >> 8;\n        buf->buf[buf->len++] = data >> 16;\n        buf->buf[buf->len++] = data >> 24;\n    }\n    return buf->len;\n}",
        "begin_line": 269,
        "end_line": 278,
        "is_bug": false
    },
    {
        "name": "be_byteslib.buf_add4_be#280",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.buf_add4_be(buf_impl* buf, const uint32_t data) // append 32 bits value",
        "snippet": "size_t buf_add4_be(buf_impl* buf, const uint32_t data) // append 32 bits value\n{\n    if (buf->len < buf->size - 3) {     // do we have room for 4 bytes\n        buf->buf[buf->len++] = data >> 24;\n        buf->buf[buf->len++] = data >> 16;\n        buf->buf[buf->len++] = data >> 8;\n        buf->buf[buf->len++] = data;\n    }\n    return buf->len;\n}",
        "begin_line": 280,
        "end_line": 289,
        "is_bug": false
    },
    {
        "name": "be_byteslib.buf_add_buf#291",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.buf_add_buf(buf_impl* buf, buf_impl* buf2)",
        "snippet": "static size_t buf_add_buf(buf_impl* buf, buf_impl* buf2)\n{\n    if (buf->len + buf2->len <= buf->size) {\n        for (uint32_t i = 0; i < buf2->len; i++) {\n            buf->buf[buf->len++] = buf2->buf[i];\n        }\n    }\n    return buf->len;\n}",
        "begin_line": 291,
        "end_line": 299,
        "is_bug": false
    },
    {
        "name": "be_byteslib.buf_get1#301",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.buf_get1(buf_impl* buf, int offset)",
        "snippet": "static uint8_t buf_get1(buf_impl* buf, int offset)\n{\n    if ((offset >= 0) && (offset < buf->len)) {\n        return buf->buf[offset];\n    }\n    return 0;\n}",
        "begin_line": 301,
        "end_line": 307,
        "is_bug": false
    },
    {
        "name": "be_byteslib.buf_set1#309",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.buf_set1(buf_impl* buf, size_t offset, uint8_t data)",
        "snippet": "static void buf_set1(buf_impl* buf, size_t offset, uint8_t data)\n{\n    if (offset < buf->len) {\n        buf->buf[offset] = data;\n    }\n}",
        "begin_line": 309,
        "end_line": 314,
        "is_bug": false
    },
    {
        "name": "be_byteslib.buf_set2_le#316",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.buf_set2_le(buf_impl* buf, size_t offset, uint16_t data)",
        "snippet": "static void buf_set2_le(buf_impl* buf, size_t offset, uint16_t data)\n{\n    if (offset + 1 < buf->len) {\n        buf->buf[offset] = data & 0xFF;\n        buf->buf[offset+1] = data >> 8;\n    }\n}",
        "begin_line": 316,
        "end_line": 322,
        "is_bug": false
    },
    {
        "name": "be_byteslib.buf_set2_be#324",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.buf_set2_be(buf_impl* buf, size_t offset, uint16_t data)",
        "snippet": "static void buf_set2_be(buf_impl* buf, size_t offset, uint16_t data)\n{\n    if (offset + 1 < buf->len) {\n        buf->buf[offset+1] = data & 0xFF;\n        buf->buf[offset] = data >> 8;\n    }\n}",
        "begin_line": 324,
        "end_line": 330,
        "is_bug": false
    },
    {
        "name": "be_byteslib.buf_get2_le#332",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.buf_get2_le(buf_impl* buf, size_t offset)",
        "snippet": "static uint16_t buf_get2_le(buf_impl* buf, size_t offset)\n{\n    if (offset + 1 < buf->len) {\n        return buf->buf[offset] | (buf->buf[offset+1] << 8);\n    }\n    return 0;\n}",
        "begin_line": 332,
        "end_line": 338,
        "is_bug": false
    },
    {
        "name": "be_byteslib.buf_get2_be#340",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.buf_get2_be(buf_impl* buf, size_t offset)",
        "snippet": "static uint16_t buf_get2_be(buf_impl* buf, size_t offset)\n{\n    if (offset + 1 < buf->len) {\n        return buf->buf[offset+1] | (buf->buf[offset] << 8);\n    }\n    return 0;\n}",
        "begin_line": 340,
        "end_line": 346,
        "is_bug": false
    },
    {
        "name": "be_byteslib.buf_set4_le#348",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.buf_set4_le(buf_impl* buf, size_t offset, uint32_t data)",
        "snippet": "static void buf_set4_le(buf_impl* buf, size_t offset, uint32_t data)\n{\n    if (offset + 3 < buf->len) {\n        buf->buf[offset] = data & 0xFF;\n        buf->buf[offset+1] = (data >> 8) & 0xFF;\n        buf->buf[offset+2] = (data >> 16) & 0xFF;\n        buf->buf[offset+3] = data >> 24;\n    }\n}",
        "begin_line": 348,
        "end_line": 356,
        "is_bug": false
    },
    {
        "name": "be_byteslib.buf_set4_be#358",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.buf_set4_be(buf_impl* buf, size_t offset, uint32_t data)",
        "snippet": "static void buf_set4_be(buf_impl* buf, size_t offset, uint32_t data)\n{\n    if (offset + 3 < buf->len) {\n        buf->buf[offset+3] = data & 0xFF;\n        buf->buf[offset+2] = (data >> 8) & 0xFF;\n        buf->buf[offset+1] = (data >> 16) & 0xFF;\n        buf->buf[offset] = data >> 24;\n    }\n}",
        "begin_line": 358,
        "end_line": 366,
        "is_bug": false
    },
    {
        "name": "be_byteslib.buf_get4_le#368",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.buf_get4_le(buf_impl* buf, size_t offset)",
        "snippet": "static uint32_t buf_get4_le(buf_impl* buf, size_t offset)\n{\n    if (offset + 3 < buf->len) {\n        return buf->buf[offset] | (buf->buf[offset+1] << 8) |\n            (buf->buf[offset+2] << 16) | (buf->buf[offset+3] << 24);\n    }\n    return 0;\n}",
        "begin_line": 368,
        "end_line": 375,
        "is_bug": false
    },
    {
        "name": "be_byteslib.buf_get4_be#377",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.buf_get4_be(buf_impl* buf, size_t offset)",
        "snippet": "static uint32_t buf_get4_be(buf_impl* buf, size_t offset)\n{\n    if (offset + 3 < buf->len) {\n        return buf->buf[offset+3] | (buf->buf[offset+2] << 8) |\n            (buf->buf[offset+1] << 16) | (buf->buf[offset] << 24);\n    }\n    return 0;\n}",
        "begin_line": 377,
        "end_line": 384,
        "is_bug": false
    },
    {
        "name": "be_byteslib.buf_equals#387",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.buf_equals(buf_impl* buf1, buf_impl* buf2)",
        "snippet": "static bbool buf_equals(buf_impl* buf1, buf_impl* buf2)\n{\n    if (buf1 == buf2) { return btrue; }\n    if (!buf1 || !buf2) { return bfalse; }   // at least one buf is not empty\n    // we know that both buf1 and buf2 are non-null\n    if (buf1->len != buf2->len) { return bfalse; }\n    size_t len = buf1->len;\n    for (uint32_t i=0; i<len; i++) {\n        if (buf_get1(buf1, i) != buf_get1(buf2, i)) { return bfalse; }\n    }\n    return btrue;\n}",
        "begin_line": 387,
        "end_line": 398,
        "is_bug": false
    },
    {
        "name": "be_byteslib.asc2byte#400",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.asc2byte(char chr)",
        "snippet": "static uint8_t asc2byte(char chr)\n{\n    uint8_t rVal = 0;\n    if (isdigit(chr)) { rVal = chr - '0'; }\n    else if (chr >= 'A' && chr <= 'F') { rVal = chr + 10 - 'A'; }\n    else if (chr >= 'a' && chr <= 'f') { rVal = chr + 10 - 'a'; }\n    return rVal;\n}",
        "begin_line": 400,
        "end_line": 407,
        "is_bug": false
    },
    {
        "name": "be_byteslib.buf_add_hex#409",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.buf_add_hex(buf_impl* buf, const char *hex, size_t len)",
        "snippet": "static void buf_add_hex(buf_impl* buf, const char *hex, size_t len)\n{\n    uint8_t val;\n    for (; len > 1; len -= 2) {\n        val = asc2byte(*hex++) << 4;\n        val |= asc2byte(*hex++);\n        buf_add1(buf, val);\n    }\n}",
        "begin_line": 409,
        "end_line": 417,
        "is_bug": false
    },
    {
        "name": "be_byteslib.bytes_realloc#423",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.bytes_realloc(bvm *vm, buf_impl *oldbuf, int32_t size)",
        "snippet": "buf_impl * bytes_realloc(bvm *vm, buf_impl *oldbuf, int32_t size)\n{\n    if (size < 4) { size = 4; }\n    if (size > BYTES_MAX_SIZE) { size = BYTES_MAX_SIZE; }\n    size_t oldsize = oldbuf ? oldbuf->size + BYTES_OVERHEAD : 0;\n    buf_impl * next = (buf_impl*) be_realloc(vm, oldbuf, oldsize, size + BYTES_OVERHEAD);  /* malloc */\n    next->size = size;\n    if (!oldbuf) {\n        next->len = 0; /* allocate a new buffer */\n    }\n    return next;\n}",
        "begin_line": 423,
        "end_line": 434,
        "is_bug": false
    },
    {
        "name": "be_byteslib.bytes_new_object#437",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.bytes_new_object(bvm *vm, size_t size)",
        "snippet": "static void bytes_new_object(bvm *vm, size_t size)\n{\n    be_getglobal(vm, \"bytes\"); /* eventually change with be_getbuiltin */\n    be_call(vm, 0); /* stack has only instance */\n    be_getmember(vm, -1, \"init\");\n    be_pushvalue(vm, -2);\n    be_pushint(vm, size); /* stack: instance, init func, instance, size */\n    be_call(vm, 2); /* stack: instance, ret, instance, size */\n    be_pop(vm, 3); /* remove ret, instance, size */\n}",
        "begin_line": 437,
        "end_line": 446,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_init#448",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_init(bvm *vm)",
        "snippet": "static int m_init(bvm *vm)\n{\n    int argc = be_top(vm);\n    int size = BYTES_DEFAULT_SIZE;\n    const char * hex_in = NULL;\n    if (argc > 1 && be_isint(vm, 2)) {\n        int new_size = be_toint(vm, 2) + BYTES_HEADROOM;\n        if (new_size > size) {\n            size = new_size;\n        }\n    } else if (argc > 1 && be_isstring(vm, 2)) {\n        hex_in = be_tostring(vm, 2);\n        if (hex_in) {\n            size = strlen(hex_in) / 2 + BYTES_HEADROOM;        /* allocate headroom */\n        }\n    }\n    buf_impl * buf = bytes_realloc(vm, NULL, size); /* allocate new buffer */\n    if (!buf) {\n        be_throw(vm, BE_MALLOC_FAIL);\n    }\n    \n    if (hex_in) {\n        buf_add_hex(buf, hex_in, strlen(hex_in));\n    } \n    be_pushcomptr(vm, buf);\n    be_setmember(vm, 1, \".p\");\n    be_return_nil(vm);\n}",
        "begin_line": 448,
        "end_line": 475,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_deinit#478",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_deinit(bvm *vm)",
        "snippet": "static int m_deinit(bvm *vm) {\n{\n    be_getmember(vm, 1, \".p\");\n    buf_impl * buf = be_tocomptr(vm, -1);\n    be_pop(vm, 1);\n    if (buf != NULL) {\n        be_realloc(vm, buf, buf->size + BYTES_OVERHEAD, 0);\n    }\n    be_pushcomptr(vm, NULL);  /* push NULL pointer instead, just in case */\n    be_setmember(vm, 1, \".p\");\n    be_return_nil(vm);\n}\n}",
        "begin_line": 478,
        "end_line": 490,
        "is_bug": false
    },
    {
        "name": "be_byteslib._bytes_resize#494",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib._bytes_resize(bvm *vm, buf_impl * buf, size_t new_size)",
        "snippet": "static buf_impl * _bytes_resize(bvm *vm, buf_impl * buf, size_t new_size) {\n    buf_impl *new_buf = bytes_realloc(vm, buf, new_size);\n    if (!new_buf) {\n        be_throw(vm, BE_MALLOC_FAIL);\n    }\n    /* replace the .p attribute since address may have changed */\n    be_pushcomptr(vm, new_buf);\n    be_setmember(vm, 1, \".p\");\n    be_pop(vm, 1); /* remove comobj from stack */\n    /* the old buffer will be garbage collected later */\n    return new_buf;\n}",
        "begin_line": 494,
        "end_line": 505,
        "is_bug": false
    },
    {
        "name": "be_byteslib.bytes_resize#510",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.bytes_resize(bvm *vm, buf_impl * buf, size_t new_size)",
        "snippet": "static buf_impl * bytes_resize(bvm *vm, buf_impl * buf, size_t new_size) {\n    /* when resized to smaller, we introduce a new heurstic */\n    /* If the buffer is 64 bytes or smaller, don't shrink */\n    /* Shrink buffer only if target size is smaller than half the original size */\n    if (buf->size >= new_size) {  /* enough room, consider if need to shrink */\n        if (buf->size <= 64) { return buf; }  /* don't shrink if below 64 bytes */\n        if (buf->size < new_size * 2) { return buf; }\n    }\n    return _bytes_resize(vm, buf, new_size + BYTES_HEADROOM);\n}",
        "begin_line": 510,
        "end_line": 519,
        "is_bug": false
    },
    {
        "name": "be_byteslib.bytes_check_data#521",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.bytes_check_data(bvm *vm, size_t add_size)",
        "snippet": "static buf_impl * bytes_check_data(bvm *vm, size_t add_size) {\n    be_getmember(vm, 1, \".p\");\n    buf_impl * buf = be_tocomptr(vm, -1);\n    be_pop(vm, 1); /* remove member from stack */\n    /* check if the `size` is big enough */\n    if (buf->len + add_size > buf->size) {\n        /* it does not fit so we need to realocate the buffer */\n        buf = bytes_resize(vm, buf, buf->len + add_size);\n    }\n    return buf;\n}",
        "begin_line": 521,
        "end_line": 531,
        "is_bug": false
    },
    {
        "name": "be_byteslib.tohex#533",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.tohex(char * out, size_t outsz, const uint8_t * in, size_t insz)",
        "snippet": "static size_t tohex(char * out, size_t outsz, const uint8_t * in, size_t insz) {\n  static const char * hex = \"0123456789ABCDEF\";\n  const uint8_t * pin = in;\n  char * pout = out;\n  for (; pin < in + insz; pout += 2, pin++) {\n    pout[0] = hex[((*pin)>>4) & 0xF];\n    pout[1] = hex[ (*pin)     & 0xF];\n    if (pout + 3 > out + outsz) { break; } /* check overflow */\n  }\n  pout[0] = 0; /* terminating Nul char */\n  return pout - out;\n}",
        "begin_line": 533,
        "end_line": 544,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_tostring#546",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_tostring(bvm *vm)",
        "snippet": "static int m_tostring(bvm *vm)\n{\n    int argc = be_top(vm);\n    size_t max_len = 32;  /* limit to 32 bytes by default */\n    int truncated = 0;\n    if (argc > 1 && be_isint(vm, 2)) {\n        max_len = be_toint(vm, 2);  /* you can specify the len as second argument, or 0 for unlimited */\n    }\n    buf_impl * buf = bytes_check_data(vm, 0);\n    size_t len = buf->len;\n    if (max_len > 0 && len > max_len) {\n        len = max_len;  /* limit output size */\n        truncated = 1;\n    }\n    size_t hex_len = len * 2 + 5 + 2 + 2 + 1 + truncated * 3;  /* reserve size for `bytes(\"\")\\0` - 9 chars */\n\n    char * hex_out = be_pushbuffer(vm, hex_len);\n    size_t l = be_strlcpy(hex_out, \"bytes('\", hex_len);\n    l += tohex(&hex_out[l], hex_len - l, buf_get_buf(buf), len);\n    if (truncated) {\n        l += be_strlcpy(&hex_out[l], \"...\", hex_len - l);\n    }\n    l += be_strlcpy(&hex_out[l], \"')\", hex_len - l);\n\n    be_pushnstring(vm, hex_out, l); /* make escape string from buffer */\n    be_remove(vm, -2); /* remove buffer */\n    be_return(vm);\n}",
        "begin_line": 546,
        "end_line": 573,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_asstring#578",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_asstring(bvm *vm)",
        "snippet": "static int m_asstring(bvm *vm)\n{\n    buf_impl * buf = bytes_check_data(vm, 0);\n    be_pushnstring(vm, (const char*) buf_get_buf(buf), buf->len);\n    be_return(vm);\n}",
        "begin_line": 578,
        "end_line": 583,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_fromstring#585",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_fromstring(bvm *vm)",
        "snippet": "static int m_fromstring(bvm *vm)\n{\n    int argc = be_top(vm);\n    if (argc >= 2 && be_isstring(vm, 2)) {\n        const char *s = be_tostring(vm, 2);\n        size_t len = be_strlen(vm, 2);\n        buf_impl * buf = bytes_check_data(vm, 0);\n        buf = bytes_resize(vm, buf, len); /* resize if needed */\n        if (len > buf->size) { len = buf->size; } /* avoid overflow */\n        memmove(buf_get_buf(buf), s, len);\n        buf->len = len;\n        be_pop(vm, 1); /* remove arg to leave instance */\n        be_return(vm);\n    }\n    be_raise(vm, \"type_error\", \"operand must be a string\");\n    be_return_nil(vm);\n}",
        "begin_line": 585,
        "end_line": 601,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_add#611",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_add(bvm *vm)",
        "snippet": "static int m_add(bvm *vm)\n{\n    int argc = be_top(vm);\n    buf_impl * buf = bytes_check_data(vm, 4); /* we reserve 4 bytes anyways */\n    if (argc >= 2 && be_isint(vm, 2)) {\n        int32_t v = be_toint(vm, 2);\n        int vsize = 1;\n        if (argc >= 3 && be_isint(vm, 3)) {\n            vsize = be_toint(vm, 3);\n        }\n        switch (vsize) {\n            case 0:                             break;\n            case -1:    /* fallback below */\n            case 1:     buf_add1(buf, v);       break;\n            case 2:     buf_add2_le(buf, v);    break;\n            case 4:     buf_add4_le(buf, v);    break;\n            case -2:    buf_add2_be(buf, v);    break;\n            case -4:    buf_add4_be(buf, v);    break;\n            default:    be_raise(vm, \"type_error\", \"size must be -4, -2, -1, 0, 1, 2 or 4.\");\n        }\n        be_pop(vm, argc - 1);\n        be_return(vm);\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 611,
        "end_line": 635,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_get#645",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_get(bvm *vm, bbool sign)",
        "snippet": "static int m_get(bvm *vm, bbool sign)\n{\n    int argc = be_top(vm);\n    buf_impl * buf = bytes_check_data(vm, 0); /* we reserve 4 bytes anyways */\n    if (argc >=2 && be_isint(vm, 2)) {\n        int32_t idx = be_toint(vm, 2);\n        int vsize = 1;\n        if (argc >= 3 && be_isint(vm, 3)) {\n            vsize = be_toint(vm, 3);\n        }\n        int ret = 0;\n        switch (vsize) {\n            case 0:                                     break;\n            case -1:    /* fallback below */\n            case 1:     ret = buf_get1(buf, idx);\n                        if (sign) { ret = (int8_t)(uint8_t) ret; }\n                        break;\n            case 2:     ret = buf_get2_le(buf, idx);\n                        if (sign) { ret = (int16_t)(uint16_t) ret; }\n                        break;\n            case 4:     ret = buf_get4_le(buf, idx);    break;\n            case -2:    ret = buf_get2_be(buf, idx);\n                        if (sign) { ret = (int16_t)(uint16_t) ret; }\n                        break;\n            case -4:    ret = buf_get4_be(buf, idx);    break;\n            default:    be_raise(vm, \"type_error\", \"size must be -4, -2, -1, 0, 1, 2 or 4.\");\n        }\n        be_pop(vm, argc - 1);\n        if (vsize != 0) {\n            be_pushint(vm, ret);\n        } else {\n            be_pushnil(vm);\n        }\n        be_return(vm);\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 645,
        "end_line": 681,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_geti#684",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_geti(bvm *vm)",
        "snippet": "static int m_geti(bvm *vm)\n{\n    return m_get(vm, 1);\n}",
        "begin_line": 684,
        "end_line": 687,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_getu#690",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_getu(bvm *vm)",
        "snippet": "static int m_getu(bvm *vm)\n{\n    return m_get(vm, 0);\n}",
        "begin_line": 690,
        "end_line": 693,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_set#703",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_set(bvm *vm)",
        "snippet": "static int m_set(bvm *vm)\n{\n    int argc = be_top(vm);\n    buf_impl * buf = bytes_check_data(vm, 0); /* we reserve 4 bytes anyways */\n    if (argc >=3 && be_isint(vm, 2) && be_isint(vm, 3)) {\n        int32_t idx = be_toint(vm, 2);\n        int32_t value = be_toint(vm, 3);\n        int vsize = 1;\n        if (argc >= 4 && be_isint(vm, 4)) {\n            vsize = be_toint(vm, 4);\n        }\n        switch (vsize) {\n            case 0:                                     break;\n            case -1:    /* fallback below */\n            case 1:     buf_set1(buf, idx, value);      break;\n            case 2:     buf_set2_le(buf, idx, value);   break;\n            case 4:     buf_set4_le(buf, idx, value);   break;\n            case -2:    buf_set2_be(buf, idx, value);   break;\n            case -4:    buf_set4_be(buf, idx, value);   break;\n            default:    be_raise(vm, \"type_error\", \"size must be -4, -2, -1, 0, 1, 2 or 4.\");\n        }\n        be_pop(vm, argc - 1);\n        be_return_nil(vm);\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 703,
        "end_line": 728,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_setitem#730",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_setitem(bvm *vm)",
        "snippet": "static int m_setitem(bvm *vm)\n{\n    int argc = be_top(vm);\n    buf_impl * buf = bytes_check_data(vm, 0); /* we reserve 4 bytes anyways */\n    if (argc >=3 && be_isint(vm, 2) && be_isint(vm, 3)) {\n        int index = be_toint(vm, 2);\n        int val = be_toint(vm, 3);\n        if (index >= 0 && index < buf->len) {\n            buf_set1(buf, index, val);\n            be_return_nil(vm);\n        }\n    }\n    be_raise(vm, \"index_error\", \"bytes index out of range or value non int\");\n    be_return_nil(vm);\n}",
        "begin_line": 730,
        "end_line": 744,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_item#746",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_item(bvm *vm)",
        "snippet": "static int m_item(bvm *vm)\n{\n    int argc = be_top(vm);\n    buf_impl * buf = bytes_check_data(vm, 0); /* we reserve 4 bytes anyways */\n    if (argc >=2 && be_isint(vm, 2)) {\n        int index = be_toint(vm,2);\n        if (index >= 0 && index < buf->len) {\n            be_pushint(vm, buf_get1(buf, index));\n            be_return(vm);\n        }\n    }\n    if (argc >= 2 && be_isinstance(vm, 2)) {\n        const char *cname = be_classname(vm, 2);\n        if (!strcmp(cname, \"range\")) {\n            bint lower, upper;\n            bint size = buf->len;\n            /* get index range */\n            be_getmember(vm, 2, \"__lower__\");\n            lower = be_toint(vm, -1);\n            be_pop(vm, 1);\n            be_getmember(vm, 2, \"__upper__\");\n            upper = be_toint(vm, -1);\n            be_pop(vm, 1);\n            /* protection scope */\n            upper = upper < size ? upper : size - 1;\n            lower = lower < 0 ? 0 : lower;\n            /* construction result list instance */\n            bytes_new_object(vm, upper > lower ? upper-lower : 0);\n            be_getmember(vm, -1, \".p\");\n            buf_impl * buf2 = be_tocomptr(vm, -1);\n            be_pop(vm, 1);  /* remove .p and leave bytes instance */\n            for (; lower <= upper; ++lower) {\n                buf_add1(buf2, buf->buf[lower]);\n            }\n            be_return(vm);    \n        }\n    }\n    be_raise(vm, \"index_error\", \"bytes index out of range\");\n    be_return_nil(vm);\n}",
        "begin_line": 746,
        "end_line": 785,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_size#787",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_size(bvm *vm)",
        "snippet": "static int m_size(bvm *vm)\n{\n    buf_impl * buf = bytes_check_data(vm, 0);\n    be_pushint(vm, buf->len);\n    be_return(vm);\n}",
        "begin_line": 787,
        "end_line": 792,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_resize#794",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_resize(bvm *vm)",
        "snippet": "static int m_resize(bvm *vm)\n{\n    int argc = be_top(vm);\n    be_getmember(vm, 1, \".p\");\n    buf_impl * buf = be_tocomptr(vm, -1);\n    be_pop(vm, 1);\n\n    if (argc <= 1 || !be_isint(vm, 2)) {\n        be_raise(vm, \"type_error\", \"size must be of type 'int'\");\n    }\n    int new_len = be_toint(vm, 2);\n    if (new_len < 0) {\n        new_len = 0;\n    }\n\n    buf = bytes_resize(vm, buf, new_len);\n    buf_set_len(buf, new_len);\n    be_pop(vm, 1);\n    be_return(vm);\n}",
        "begin_line": 794,
        "end_line": 813,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_clear#815",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_clear(bvm *vm)",
        "snippet": "static int m_clear(bvm *vm)\n{\n    buf_impl * buf = bytes_check_data(vm, 0);\n    buf->len = 0;\n    be_return_nil(vm);\n}",
        "begin_line": 815,
        "end_line": 820,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_merge#822",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_merge(bvm *vm)",
        "snippet": "static int m_merge(bvm *vm)\n{\n    int argc = be_top(vm);\n    buf_impl * buf1 = bytes_check_data(vm, 0); /* no resize yet */\n    if (argc >= 2 && be_isinstance(vm, 2)) {\n        be_getglobal(vm, \"bytes\"); /* get the bytes class */ /* TODO eventually replace with be_getbuiltin */\n        if (be_isderived(vm, 2)) {\n            be_getmember(vm, 2, \".p\");\n            buf_impl * buf2 = be_tocomptr(vm, -1);\n            be_pop(vm, 4); /* remove class, member, and 2 operands */\n\n            /* allocate new object */\n            bytes_new_object(vm, buf1->len + buf2->len);\n            be_getmember(vm, -1, \".p\");\n            /* .p is on top of stack, then instance */\n            buf_impl * buf3 = be_tocomptr(vm, -1);\n            be_pop(vm, 1);\n            buf_add_buf(buf3, buf1);\n            buf_add_buf(buf3, buf2);\n\n            be_return(vm); /* return self */\n        }\n    }\n    be_raise(vm, \"type_error\", \"operand must be bytes\");\n    be_return_nil(vm); /* return self */\n}",
        "begin_line": 822,
        "end_line": 847,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_copy#849",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_copy(bvm *vm)",
        "snippet": "static int m_copy(bvm *vm)\n{\n    buf_impl * buf1 = bytes_check_data(vm, 0); /* no resize */\n    bytes_new_object(vm, buf1->len);\n    be_getmember(vm, -1, \".p\");\n    buf_impl * buf2 = be_tocomptr(vm, -1);\n    be_pop(vm, 1);\n    buf_add_buf(buf2, buf1);\n    be_return(vm); /* return self */\n}",
        "begin_line": 849,
        "end_line": 858,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_connect#861",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_connect(bvm *vm)",
        "snippet": "static int m_connect(bvm *vm)\n{\n    int argc = be_top(vm);\n    buf_impl * buf1 = bytes_check_data(vm, 0); /* don't resize yet */\n    if (argc >= 2 && (be_isinstance(vm, 2) || be_isint(vm, 2))) {\n        if (be_isint(vm, 2)) {\n            buf1 = bytes_resize(vm, buf1, buf1->len + 1); /* resize */\n            buf_add1(buf1, be_toint(vm, 2));\n            be_pop(vm, 1);  /* remove operand */\n            be_return(vm); /* return self */\n        } else {\n            be_getglobal(vm, \"bytes\"); /* get the bytes class */ /* TODO eventually replace with be_getbuiltin */\n            if (be_isderived(vm, 2)) {\n                be_getmember(vm, 2, \".p\");\n                buf_impl * buf2 = be_tocomptr(vm, -1);\n                buf1 = bytes_resize(vm, buf1, buf1->len + buf2->len); /* resize buf1 for total size */\n                buf_add_buf(buf1, buf2);\n                be_pop(vm, 3); /* remove class, member, and last operand */\n                be_return(vm); /* return self */\n            }\n        }\n    }\n    be_raise(vm, \"type_error\", \"operand must be bytes or int\");\n    be_return_nil(vm); /* return self */\n}",
        "begin_line": 861,
        "end_line": 885,
        "is_bug": false
    },
    {
        "name": "be_byteslib.bytes_equal#887",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.bytes_equal(bvm *vm, bbool iseq)",
        "snippet": "static int bytes_equal(bvm *vm, bbool iseq)\n{\n    be_getmember(vm, 1, \".p\");\n    buf_impl * buf1 = be_tocomptr(vm, -1);\n    be_pop(vm, 1);\n\n    be_getmember(vm, 2, \".p\");\n    buf_impl * buf2 = be_tocomptr(vm, -1);\n    be_pop(vm, 1);\n\n    bbool ret;\n    if (buf_equals(buf1, buf2)) {\n        ret = iseq;\n    } else {\n        ret = !iseq;\n    }\n    be_pushbool(vm, ret);\n    be_return(vm);\n}",
        "begin_line": 887,
        "end_line": 905,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_equal#907",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_equal(bvm *vm)",
        "snippet": "static int m_equal(bvm *vm)\n{\n    return bytes_equal(vm, btrue);\n}",
        "begin_line": 907,
        "end_line": 910,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_nequal#912",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_nequal(bvm *vm)",
        "snippet": "static int m_nequal(bvm *vm)\n{\n    return bytes_equal(vm, bfalse);\n}",
        "begin_line": 912,
        "end_line": 915,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_tob64#924",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_tob64(bvm *vm)",
        "snippet": "static int m_tob64(bvm *vm)\n{\n    buf_impl * buf = bytes_check_data(vm, 0);\n    size_t len = buf->len;\n    size_t b64_len = encode_base64_length(len) + 1;  /* size of base64 encoded string for this binary length, add NULL terminator */\n\n    char * b64_out = be_pushbuffer(vm, b64_len);\n    size_t converted = encode_base64(buf_get_buf(buf), len, (unsigned char*)b64_out);\n\n    be_pushnstring(vm, b64_out, converted); /* make string from buffer */\n    be_remove(vm, -2); /* remove buffer */\n    be_return(vm);\n}",
        "begin_line": 924,
        "end_line": 936,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_fromb64#943",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_fromb64(bvm *vm)",
        "snippet": "static int m_fromb64(bvm *vm)\n{\n    int argc = be_top(vm);\n    if (argc >= 2 && be_isstring(vm, 2)) {\n        const char *s = be_tostring(vm, 2);\n        size_t bin_len = decode_base64_length((unsigned char*)s);   /* do a first pass to calculate the buffer size */\n\n        buf_impl * buf = bytes_check_data(vm, 0);\n        buf = bytes_resize(vm, buf, bin_len); /* resize if needed */\n        if (bin_len > buf->size) { /* avoid overflow */\n            be_raise(vm, \"memory_error\", \"cannot allocate buffer\");\n        }\n\n        size_t bin_len_final = decode_base64((unsigned char*)s, buf_get_buf(buf));  /* decode */\n        buf->len = bin_len_final;\n        be_pop(vm, 1); /* remove arg to leave instance */\n        be_return(vm);\n    }\n    be_raise(vm, \"type_error\", \"operand must be a string\");\n    be_return_nil(vm);\n}",
        "begin_line": 943,
        "end_line": 963,
        "is_bug": false
    },
    {
        "name": "be_byteslib.m_buffer#979",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.m_buffer(bvm *vm)",
        "snippet": "static int m_buffer(bvm *vm)\n{\n    buf_impl * buf = bytes_check_data(vm, 0);\n    be_pushcomptr(vm, &buf->buf);\n    be_return(vm);\n}",
        "begin_line": 979,
        "end_line": 984,
        "is_bug": false
    },
    {
        "name": "be_byteslib.be_pushbytes#989",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.be_pushbytes(bvm *vm, const void * bytes, size_t len)",
        "snippet": "BERRY_API void be_pushbytes(bvm *vm, const void * bytes, size_t len)\n{\n    bytes_new_object(vm, len);\n    be_getmember(vm, -1, \".p\");\n    buf_impl * buf = be_tocomptr(vm, -1);\n    be_pop(vm, 1); /* remove .p1 and leave instance */\n    if (len > buf->size) { len = buf->size; } /* double check if the buffer allocated was smaller */\n    memmove((void*)buf_get_buf(buf), bytes, len);\n    buf->len = len;\n    /* bytes instance is on top of stack */\n}",
        "begin_line": 989,
        "end_line": 999,
        "is_bug": false
    },
    {
        "name": "be_byteslib.be_tobytes#1001",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.be_tobytes(bvm *vm, int rel_index, size_t *len)",
        "snippet": "BERRY_API const void *be_tobytes(bvm *vm, int rel_index, size_t *len)\n{\n    int index = be_absindex(vm, rel_index);\n    if (be_isinstance(vm, index)) {\n        be_getglobal(vm, \"bytes\"); /* get the bytes class */ /* TODO eventually replace with be_getbuiltin */\n        if (be_isderived(vm, index)) {\n            be_getmember(vm, index, \".p\");\n            buf_impl * buf = be_tocomptr(vm, -1);\n            be_pop(vm, 2); /* class and .p */\n            if (len) { *len = buf->len; }\n            return (void*) buf_get_buf(buf);\n        } else {\n            be_pop(vm, 1);  /* remove class */\n        }\n    }\n    if (len) { *len = 0; }\n    return NULL;\n}",
        "begin_line": 1001,
        "end_line": 1018,
        "is_bug": false
    },
    {
        "name": "be_byteslib.be_isbytes#1020",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.be_isbytes(bvm *vm, int rel_index)",
        "snippet": "BERRY_API bbool be_isbytes(bvm *vm, int rel_index)\n{\n    bbool ret = bfalse;\n    int index = be_absindex(vm, rel_index);\n    if (be_isinstance(vm, index)) {\n        be_getbuiltin(vm, \"bytes\");\n        if (be_isderived(vm, index)) {\n            ret = btrue;\n        }\n        be_pop(vm, 1);\n    }\n    return ret;\n}",
        "begin_line": 1020,
        "end_line": 1032,
        "is_bug": false
    },
    {
        "name": "be_byteslib.be_load_byteslib#1233",
        "src_path": "src/be_byteslib.c",
        "class_name": "be_byteslib",
        "signature": "be_byteslib.be_load_byteslib(bvm *vm)",
        "snippet": "void be_load_byteslib(bvm *vm)\n{\n    static const bnfuncinfo members[] = {\n        { \".p\", NULL },\n        { \"_buffer\", m_buffer },\n        { \"init\", m_init },\n        { \"deinit\", m_deinit },\n        { \"tostring\", m_tostring },\n        { \"asstring\", m_asstring },\n        { \"fromstring\", m_fromstring },\n        { \"tob64\", m_tob64 },\n        { \"fromb64\", m_fromb64 },\n        { \"add\", m_add },\n        { \"get\", m_getu },\n        { \"geti\", m_geti },\n        { \"set\", m_set },\n        { \"seti\", m_set },      // setters for signed and unsigned are identical\n        { \"item\", m_item },\n        { \"setitem\", m_setitem },\n        { \"size\", m_size },\n        { \"resize\", m_resize },\n        { \"clear\", m_clear },\n        { \"copy\", m_copy },\n        { \"+\", m_merge },\n        { \"..\", m_connect },\n        { \"==\", m_equal },\n        { \"!=\", m_nequal },\n\n        { NULL, (bntvfunc) BE_CLOSURE }, /* mark section for berry closures */\n        { \"getbits\", (bntvfunc) &getbits_closure },\n        { \"setbits\", (bntvfunc) &setbits_closure },\n\n        { NULL, NULL }\n    };\n    be_regclass(vm, \"bytes\", members);\n}",
        "begin_line": 1233,
        "end_line": 1268,
        "is_bug": false
    },
    {
        "name": "be_filelib.i_write#16",
        "src_path": "src/be_filelib.c",
        "class_name": "be_filelib",
        "signature": "be_filelib.i_write(bvm *vm)",
        "snippet": "static int i_write(bvm *vm)\n{\n    be_getmember(vm, 1, \".p\");\n    if(be_iscomptr(vm, -1) && (be_isstring(vm, 2) || be_isbytes(vm, 2))) {\n        void *fh = be_tocomptr(vm, -1);\n        size_t size = 0;\n        const char *data = NULL;\n        if (be_isstring(vm, 2)) {\n            data = be_tostring(vm, 2);\n            size = be_strlen(vm, 2);\n        } else {\n            data = be_tobytes(vm, 2, &size);\n        }\n        be_fwrite(fh, data, size);\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 16,
        "end_line": 32,
        "is_bug": false
    },
    {
        "name": "be_filelib.readsize#34",
        "src_path": "src/be_filelib.c",
        "class_name": "be_filelib",
        "signature": "be_filelib.readsize(bvm *vm, int argc, void *fh)",
        "snippet": "static size_t readsize(bvm *vm, int argc, void *fh)\n{\n    if (argc >=2 && be_isint(vm, 2)) {\n        return be_toindex(vm, 2);\n    }\n    return be_fsize(fh) - be_ftell(fh);\n}",
        "begin_line": 34,
        "end_line": 40,
        "is_bug": false
    },
    {
        "name": "be_filelib.i_read#42",
        "src_path": "src/be_filelib.c",
        "class_name": "be_filelib",
        "signature": "be_filelib.i_read(bvm *vm)",
        "snippet": "static int i_read(bvm *vm)\n{\n    int argc = be_top(vm);\n    be_getmember(vm, 1, \".p\");\n    if (be_iscomptr(vm, -1)) {\n        void *fh = be_tocomptr(vm, -1);\n        size_t size = readsize(vm, argc, fh);\n        if (size) {\n            char *buffer = be_malloc(vm, size);\n            size = be_fread(fh, buffer, size);\n            be_pushnstring(vm, buffer, size);\n            be_free(vm, buffer, size);\n        } else {\n            be_pushstring(vm, \"\");\n        }\n        be_return(vm);\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 42,
        "end_line": 60,
        "is_bug": false
    },
    {
        "name": "be_filelib.i_readbytes#62",
        "src_path": "src/be_filelib.c",
        "class_name": "be_filelib",
        "signature": "be_filelib.i_readbytes(bvm *vm)",
        "snippet": "static int i_readbytes(bvm *vm)\n{\n    int argc = be_top(vm);\n    be_getmember(vm, 1, \".p\");\n    if (be_iscomptr(vm, -1)) {\n        void *fh = be_tocomptr(vm, -1);\n        size_t size = readsize(vm, argc, fh);\n        if (size) {\n            /* avoid double allocation, using directly the internal buffer of bytes() */\n            be_getbuiltin(vm, \"bytes\");\n            be_pushint(vm, size);\n            be_call(vm, 1);  /* call bytes() constructor with pre-sized buffer */\n            be_pop(vm, 1);  /* bytes() instance is at top */\n\n            be_getmember(vm, -1, \"resize\");\n            be_pushvalue(vm, -2);\n            be_pushint(vm, size);\n            be_call(vm, 2); /* call b.resize(size) */\n            be_pop(vm, 3);  /* bytes() instance is at top */\n\n            char *buffer = (char*) be_tobytes(vm, -1, NULL); /* we get the address of the internam buffer of size 'size' */\n            size = be_fread(fh, buffer, size);\n\n            /* resize if something went wrong */\n            be_getmember(vm, -1, \"resize\");\n            be_pushvalue(vm, -2);\n            be_pushint(vm, size);\n            be_call(vm, 2); /* call b.resize(size) */\n            be_pop(vm, 3);  /* bytes() instance is at top */\n        } else {\n            be_pushbytes(vm, NULL, 0);\n        }\n        be_return(vm);\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 62,
        "end_line": 97,
        "is_bug": false
    },
    {
        "name": "be_filelib.i_readline#99",
        "src_path": "src/be_filelib.c",
        "class_name": "be_filelib",
        "signature": "be_filelib.i_readline(bvm *vm)",
        "snippet": "static int i_readline(bvm *vm)\n{\n    be_getmember(vm, 1, \".p\");\n    if (be_iscomptr(vm, -1)) {\n        void *fh = be_tocomptr(vm, -1);\n        size_t pos = 0, size = READLINE_STEP;\n        char *buffer = be_malloc(vm, size);\n        char *res = be_fgets(fh, buffer, (int)size);\n        while (res) {\n            pos += strlen(buffer + pos);\n            if (!pos || buffer[pos - 1] == '\\n') {\n                break;\n            }\n            buffer = be_realloc(vm, buffer, size, size + READLINE_STEP);\n            res = be_fgets(fh, buffer + pos, READLINE_STEP);\n            size += READLINE_STEP;\n        }\n        be_pushnstring(vm, buffer, pos);\n        be_free(vm, buffer, size);\n        be_return(vm);\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 99,
        "end_line": 121,
        "is_bug": false
    },
    {
        "name": "be_filelib.i_seek#123",
        "src_path": "src/be_filelib.c",
        "class_name": "be_filelib",
        "signature": "be_filelib.i_seek(bvm *vm)",
        "snippet": "static int i_seek(bvm *vm)\n{\n    be_getmember(vm, 1, \".p\");\n    if (be_iscomptr(vm, -1) && be_isint(vm, 2)) {\n        void *fh = be_tocomptr(vm, -1);\n        be_fseek(fh, be_toindex(vm, 2));\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 123,
        "end_line": 131,
        "is_bug": false
    },
    {
        "name": "be_filelib.i_tell#133",
        "src_path": "src/be_filelib.c",
        "class_name": "be_filelib",
        "signature": "be_filelib.i_tell(bvm *vm)",
        "snippet": "static int i_tell(bvm *vm)\n{\n    be_getmember(vm, 1, \".p\");\n    if (be_iscomptr(vm, -1)) {\n        void *fh = be_tocomptr(vm, -1);\n        size_t pos = be_ftell(fh);\n        be_pushint(vm, cast(bint, pos));\n        be_return(vm);\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 133,
        "end_line": 143,
        "is_bug": false
    },
    {
        "name": "be_filelib.i_size#145",
        "src_path": "src/be_filelib.c",
        "class_name": "be_filelib",
        "signature": "be_filelib.i_size(bvm *vm)",
        "snippet": "static int i_size(bvm *vm)\n{\n    be_getmember(vm, 1, \".p\");\n    if (be_iscomptr(vm, -1)) {\n        void *fh = be_tocomptr(vm, -1);\n        size_t pos = be_fsize(fh);\n        be_pushint(vm, cast(bint, pos));\n        be_return(vm);\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 145,
        "end_line": 155,
        "is_bug": false
    },
    {
        "name": "be_filelib.i_flush#157",
        "src_path": "src/be_filelib.c",
        "class_name": "be_filelib",
        "signature": "be_filelib.i_flush(bvm *vm)",
        "snippet": "static int i_flush(bvm *vm)\n{\n    be_getmember(vm, 1, \".p\");\n    if (be_iscomptr(vm, -1)) {\n        void *fh = be_tocomptr(vm, -1);\n        be_fflush(fh);\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 157,
        "end_line": 165,
        "is_bug": false
    },
    {
        "name": "be_filelib.i_close#167",
        "src_path": "src/be_filelib.c",
        "class_name": "be_filelib",
        "signature": "be_filelib.i_close(bvm *vm)",
        "snippet": "static int i_close(bvm *vm)\n{\n    be_getmember(vm, 1, \".p\");\n    if (be_iscomptr(vm, -1)) {\n        void *fh = be_tocomptr(vm, -1);\n        be_fclose(fh);\n        be_pushnil(vm);\n        be_setmember(vm, 1, \".p\");\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 167,
        "end_line": 177,
        "is_bug": false
    },
    {
        "name": "be_filelib.m_open#180",
        "src_path": "src/be_filelib.c",
        "class_name": "be_filelib",
        "signature": "be_filelib.m_open(bvm *vm) #else int be_nfunc_open(bvm *vm) #endif",
        "snippet": "static int m_open(bvm *vm)\n#else\nint be_nfunc_open(bvm *vm)\n#endif\n{\n    int argc = be_top(vm);\n    const char *fname, *mode;\n    static const bnfuncinfo members[] = {\n        { \".p\", NULL },\n        { \"write\", i_write },\n        { \"read\", i_read },\n        { \"readbytes\", i_readbytes },\n        { \"readline\", i_readline },\n        { \"seek\", i_seek },\n        { \"tell\", i_tell },\n        { \"size\", i_size },\n        { \"flush\", i_flush },\n        { \"close\", i_close },\n        { \"deinit\", i_close },\n        { NULL, NULL }\n    };\n    fname = argc >= 1 && be_isstring(vm, 1) ? be_tostring(vm, 1) : NULL;\n    mode = argc >= 2 && be_isstring(vm, 2) ? be_tostring(vm, 2) : \"r\";\n    if (fname) {\n        void *fh = be_fopen(fname, mode);\n        if (fh == NULL) {\n            be_raise(vm, \"io_error\",\n                be_pushfstring(vm, \"cannot open file '%s'\", fname));\n        }\n        be_pushclass(vm, \"file\", members);\n        be_call(vm, 0);\n        be_pushcomptr(vm, fh);\n        be_setmember(vm, -2, \".p\");\n        be_pop(vm, 1);\n        be_return(vm);\n    }\n    be_return_nil(vm);\n}",
        "begin_line": 180,
        "end_line": 217,
        "is_bug": false
    },
    {
        "name": "be_filelib.be_load_filelib#220",
        "src_path": "src/be_filelib.c",
        "class_name": "be_filelib",
        "signature": "be_filelib.be_load_filelib(bvm *vm)",
        "snippet": "void be_load_filelib(bvm *vm)\n{\n    be_regfunc(vm, \"open\", m_open);\n}",
        "begin_line": 220,
        "end_line": 223,
        "is_bug": false
    },
    {
        "name": "be_api.class_init#31",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.class_init(bvm *vm, bclass *c, const bnfuncinfo *lib)",
        "snippet": "static void class_init(bvm *vm, bclass *c, const bnfuncinfo *lib)\n{\n    if (lib) {\n        while (lib->name) {\n            bstring *s = be_newstr(vm, lib->name);\n            if (lib->function) { /* method */\n                be_prim_method_bind(vm, c, s, lib->function);\n            } else {\n                be_member_bind(vm, c, s, btrue); /* member */\n            }\n            ++lib;\n        }\n        if (lib->function == (bntvfunc) BE_CLOSURE) {\n            /* next section is closures */\n            struct solidfuncinfo *slib = (struct solidfuncinfo*)++lib;\n            while (slib->name) {\n                if (slib->function) { /* method */\n                    bstring *s = be_newstr(vm, slib->name);\n                    be_closure_method_bind(vm, c, s, slib->function);\n                }\n                ++slib;\n            }\n        }\n        be_map_release(vm, c->members); /* clear space */\n    }\n}",
        "begin_line": 31,
        "end_line": 56,
        "is_bug": false
    },
    {
        "name": "be_api.class_auto_make#58",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.class_auto_make(bvm *vm, bstring *name, const bnfuncinfo *lib)",
        "snippet": "static bclass* class_auto_make(bvm *vm, bstring *name, const bnfuncinfo *lib)\n{\n    bvalue key, *res;\n    var_setobj(&key, BE_COMPTR, (void*)lib);\n    if (vm->ntvclass == NULL) {\n        vm->ntvclass = be_map_new(vm);\n    }\n    res = be_map_find(vm, vm->ntvclass, &key);\n    if (res == NULL || !var_isclass(res)) {\n        bclass *c;\n        /* insert class to native class table */\n        res = be_map_insert(vm, vm->ntvclass, &key, NULL);\n        var_setnil(res); /* must be initialized to ensure correct GC */\n        c = be_newclass(vm, name, NULL);\n        var_setclass(res, c);\n        class_init(vm, c, lib); /* bind members */\n        return c;\n    }\n    return var_toobj(res);\n}",
        "begin_line": 58,
        "end_line": 77,
        "is_bug": false
    },
    {
        "name": "be_api.be_regfunc#79",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_regfunc(bvm *vm, const char *name, bntvfunc f)",
        "snippet": "BERRY_API void be_regfunc(bvm *vm, const char *name, bntvfunc f)\n{\n    bvalue *var;\n    bstring *s = be_newstr(vm, name);\n#if !BE_USE_PRECOMPILED_OBJECT\n    int idx = be_builtin_find(vm, s);\n    be_assert(idx == -1);\n    if (idx == -1) { /* new function */\n        idx = be_builtin_new(vm, s);\n#else\n    int idx = be_global_find(vm, s);\n    be_assert(idx < be_builtin_count(vm));\n    if (idx < be_builtin_count(vm)) { /* new function */\n        idx = be_global_new(vm, s);\n#endif\n        var = be_global_var(vm, idx);\n        var_setntvfunc(var, f);\n    } /* error case, do nothing */\n}",
        "begin_line": 79,
        "end_line": 97,
        "is_bug": false
    },
    {
        "name": "be_api.be_regclass#99",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_regclass(bvm *vm, const char *name, const bnfuncinfo *lib)",
        "snippet": "BERRY_API void be_regclass(bvm *vm, const char *name, const bnfuncinfo *lib)\n{\n    bvalue *var;\n    bstring *s = be_newstr(vm, name);\n#if !BE_USE_PRECOMPILED_OBJECT\n    int idx = be_builtin_find(vm, s);\n    be_assert(idx == -1);\n    if (idx == -1) { /* new function */\n        idx = be_builtin_new(vm, s);\n#else\n    int idx = be_global_find(vm, s);\n    be_assert(idx < be_builtin_count(vm));\n    if (idx < be_builtin_count(vm)) { /* new function */\n        idx = be_global_new(vm, s);\n#endif\n        var = be_global_var(vm, idx);\n        var_setclass(var, class_auto_make(vm, s, lib));\n    } /* error case, do nothing */\n}",
        "begin_line": 99,
        "end_line": 117,
        "is_bug": false
    },
    {
        "name": "be_api.be_top#119",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_top(bvm *vm)",
        "snippet": "BERRY_API int be_top(bvm *vm)\n{\n    return cast_int(vm->top - vm->reg);\n}",
        "begin_line": 119,
        "end_line": 122,
        "is_bug": false
    },
    {
        "name": "be_api.be_pop#124",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pop(bvm *vm, int n)",
        "snippet": "BERRY_API void be_pop(bvm *vm, int n)\n{\n    be_assert(n <= vm->top - vm->reg);\n    be_stackpop(vm, n);\n}",
        "begin_line": 124,
        "end_line": 128,
        "is_bug": false
    },
    {
        "name": "be_api.be_absindex#130",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_absindex(bvm *vm, int index)",
        "snippet": "BERRY_API int be_absindex(bvm *vm, int index)\n{\n    if (index > 0) {\n        return index;\n    }\n    be_assert(vm->reg <= vm->top + index);\n    return cast_int(vm->top + index - vm->reg + 1);\n}",
        "begin_line": 130,
        "end_line": 137,
        "is_bug": false
    },
    {
        "name": "be_api.be_isnil#139",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_isnil(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_isnil(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    return var_isnil(v);\n}",
        "begin_line": 139,
        "end_line": 143,
        "is_bug": false
    },
    {
        "name": "be_api.be_isbool#145",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_isbool(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_isbool(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    return var_isbool(v);\n}",
        "begin_line": 145,
        "end_line": 149,
        "is_bug": false
    },
    {
        "name": "be_api.be_isint#151",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_isint(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_isint(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    return var_isint(v);\n}",
        "begin_line": 151,
        "end_line": 155,
        "is_bug": false
    },
    {
        "name": "be_api.be_isreal#157",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_isreal(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_isreal(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    return var_isreal(v);\n}",
        "begin_line": 157,
        "end_line": 161,
        "is_bug": false
    },
    {
        "name": "be_api.be_isnumber#163",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_isnumber(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_isnumber(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    return var_isnumber(v);\n}",
        "begin_line": 163,
        "end_line": 167,
        "is_bug": false
    },
    {
        "name": "be_api.be_isstring#169",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_isstring(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_isstring(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    return var_isstr(v);\n}",
        "begin_line": 169,
        "end_line": 173,
        "is_bug": false
    },
    {
        "name": "be_api.be_isclosure#175",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_isclosure(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_isclosure(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    return var_isclosure(v);\n}",
        "begin_line": 175,
        "end_line": 179,
        "is_bug": false
    },
    {
        "name": "be_api.be_isntvclos#181",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_isntvclos(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_isntvclos(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    return var_isntvclos(v);\n}",
        "begin_line": 181,
        "end_line": 185,
        "is_bug": false
    },
    {
        "name": "be_api.be_isfunction#187",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_isfunction(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_isfunction(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    return var_isfunction(v);\n}",
        "begin_line": 187,
        "end_line": 191,
        "is_bug": false
    },
    {
        "name": "be_api.be_isproto#193",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_isproto(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_isproto(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    return var_isproto(v);\n}",
        "begin_line": 193,
        "end_line": 197,
        "is_bug": false
    },
    {
        "name": "be_api.be_isclass#199",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_isclass(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_isclass(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    return var_isclass(v);\n}",
        "begin_line": 199,
        "end_line": 203,
        "is_bug": false
    },
    {
        "name": "be_api.be_isinstance#205",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_isinstance(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_isinstance(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    return var_isinstance(v);\n}",
        "begin_line": 205,
        "end_line": 209,
        "is_bug": false
    },
    {
        "name": "be_api.be_ismodule#211",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_ismodule(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_ismodule(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    return var_ismodule(v);\n}",
        "begin_line": 211,
        "end_line": 215,
        "is_bug": false
    },
    {
        "name": "be_api.be_islist#217",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_islist(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_islist(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    return var_islist(v);\n}",
        "begin_line": 217,
        "end_line": 221,
        "is_bug": false
    },
    {
        "name": "be_api.be_ismap#223",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_ismap(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_ismap(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    return var_ismap(v);\n}",
        "begin_line": 223,
        "end_line": 227,
        "is_bug": false
    },
    {
        "name": "be_api.be_iscomptr#229",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_iscomptr(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_iscomptr(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    return var_istype(v, BE_COMPTR);\n}",
        "begin_line": 229,
        "end_line": 233,
        "is_bug": false
    },
    {
        "name": "be_api.be_iscomobj#235",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_iscomobj(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_iscomobj(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    return var_istype(v, BE_COMOBJ);\n}",
        "begin_line": 235,
        "end_line": 239,
        "is_bug": false
    },
    {
        "name": "be_api.be_toint#241",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_toint(bvm *vm, int index)",
        "snippet": "BERRY_API bint be_toint(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    return var_toint(v);\n}",
        "begin_line": 241,
        "end_line": 245,
        "is_bug": false
    },
    {
        "name": "be_api.be_toreal#247",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_toreal(bvm *vm, int index)",
        "snippet": "BERRY_API breal be_toreal(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    if (var_isreal(v)) {\n        return var_toreal(v);\n    }\n    if (var_isint(v)) {\n        return cast(breal, var_toint(v));\n    }\n    return cast(breal, 0.0);\n}",
        "begin_line": 247,
        "end_line": 257,
        "is_bug": false
    },
    {
        "name": "be_api.be_toindex#259",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_toindex(bvm *vm, int index)",
        "snippet": "BERRY_API int be_toindex(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    return var_toidx(v);\n}",
        "begin_line": 259,
        "end_line": 263,
        "is_bug": false
    },
    {
        "name": "be_api.be_tobool#265",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_tobool(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_tobool(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    return be_value2bool(vm, v);\n}",
        "begin_line": 265,
        "end_line": 269,
        "is_bug": false
    },
    {
        "name": "be_api.be_tostring#271",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_tostring(bvm *vm, int index)",
        "snippet": "BERRY_API const char* be_tostring(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    if (!var_isstr(v)) {\n        be_val2str(vm, index);\n        v = be_indexof(vm, index);\n    }\n    return str(var_tostr(v));\n}",
        "begin_line": 271,
        "end_line": 279,
        "is_bug": false
    },
    {
        "name": "be_api.be_tocomptr#281",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_tocomptr(bvm *vm, int index)",
        "snippet": "BERRY_API void* be_tocomptr(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    if (var_istype(v, BE_COMPTR)) {\n        return var_toobj(v);\n    }\n    if (var_istype(v, BE_COMOBJ)) {\n        bcommomobj *obj = var_toobj(v);\n        return obj->data;\n    }\n    return NULL;\n}",
        "begin_line": 281,
        "end_line": 292,
        "is_bug": false
    },
    {
        "name": "be_api.be_moveto#294",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_moveto(bvm *vm, int from, int to)",
        "snippet": "BERRY_API void be_moveto(bvm *vm, int from, int to)\n{\n    bvalue *src = be_indexof(vm, from);\n    bvalue *dst = be_indexof(vm, to);\n    var_setval(dst, src);\n}",
        "begin_line": 294,
        "end_line": 299,
        "is_bug": false
    },
    {
        "name": "be_api.be_pushnil#301",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pushnil(bvm *vm)",
        "snippet": "BERRY_API void be_pushnil(bvm *vm)\n{\n    bvalue *reg = be_incrtop(vm);\n    var_setnil(reg);\n}",
        "begin_line": 301,
        "end_line": 305,
        "is_bug": false
    },
    {
        "name": "be_api.be_pushbool#307",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pushbool(bvm *vm, int b)",
        "snippet": "BERRY_API void be_pushbool(bvm *vm, int b)\n{\n    bvalue *reg = be_incrtop(vm);\n    var_setbool(reg, b != bfalse);\n}",
        "begin_line": 307,
        "end_line": 311,
        "is_bug": false
    },
    {
        "name": "be_api.be_pushint#313",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pushint(bvm *vm, bint i)",
        "snippet": "BERRY_API void be_pushint(bvm *vm, bint i)\n{\n    bvalue *reg = be_incrtop(vm);\n    var_setint(reg, i);\n}",
        "begin_line": 313,
        "end_line": 317,
        "is_bug": false
    },
    {
        "name": "be_api.be_pushreal#319",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pushreal(bvm *vm, breal r)",
        "snippet": "BERRY_API void be_pushreal(bvm *vm, breal r)\n{\n    bvalue *reg = be_incrtop(vm);\n    var_setreal(reg, r);\n}",
        "begin_line": 319,
        "end_line": 323,
        "is_bug": false
    },
    {
        "name": "be_api.be_pushstring#325",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pushstring(bvm *vm, const char *str)",
        "snippet": "BERRY_API void be_pushstring(bvm *vm, const char *str)\n{\n    /* to create a string and then push the top registor,\n     * otherwise the GC may crash due to uninitialized values.\n     **/\n    bstring *s = be_newstr(vm, str);\n    bvalue *reg = be_incrtop(vm);\n    be_assert(reg < vm->stacktop);\n    var_setstr(reg, s);\n}",
        "begin_line": 325,
        "end_line": 334,
        "is_bug": false
    },
    {
        "name": "be_api.be_pushnstring#336",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pushnstring(bvm *vm, const char *str, size_t n)",
        "snippet": "BERRY_API void be_pushnstring(bvm *vm, const char *str, size_t n)\n{\n    /* to create a string and then push the top registor,\n     * otherwise the GC may crash due to uninitialized values.\n     **/\n    bstring *s = be_newstrn(vm, str, n);\n    bvalue *reg = be_incrtop(vm);\n    var_setstr(reg, s);\n}",
        "begin_line": 336,
        "end_line": 344,
        "is_bug": false
    },
    {
        "name": "be_api.be_pushfstring#346",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pushfstring(bvm *vm, const char *format, ...)",
        "snippet": "BERRY_API const char* be_pushfstring(bvm *vm, const char *format, ...)\n{\n    const char* s;\n    va_list arg_ptr;\n    va_start(arg_ptr, format);\n    s = be_pushvfstr(vm, format, arg_ptr);\n    va_end(arg_ptr);\n    return s;\n}",
        "begin_line": 346,
        "end_line": 354,
        "is_bug": false
    },
    {
        "name": "be_api.be_pushbuffer#356",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pushbuffer(bvm *vm, size_t size)",
        "snippet": "BERRY_API void* be_pushbuffer(bvm *vm, size_t size)\n{\n    bstring *s = be_newlongstr(vm, NULL, size);\n    bvalue *reg = be_incrtop(vm);\n    var_setstr(reg, s);\n    return (void*)str(s);\n}",
        "begin_line": 356,
        "end_line": 362,
        "is_bug": false
    },
    {
        "name": "be_api.be_pushvalue#364",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pushvalue(bvm *vm, int index)",
        "snippet": "BERRY_API void be_pushvalue(bvm *vm, int index)\n{\n    bvalue *reg = vm->top;\n    var_setval(reg, be_indexof(vm, index));\n    be_incrtop(vm);\n}",
        "begin_line": 364,
        "end_line": 369,
        "is_bug": false
    },
    {
        "name": "be_api.be_pushclosure#371",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pushclosure(bvm *vm, void *cl)",
        "snippet": "BERRY_API void be_pushclosure(bvm *vm, void *cl)\n{\n    bvalue *reg = be_incrtop(vm);\n    bclosure * closure = (bclosure*) cl;\n    var_setclosure(reg, closure);\n}",
        "begin_line": 371,
        "end_line": 376,
        "is_bug": false
    },
    {
        "name": "be_api.be_pushntvclosure#378",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pushntvclosure(bvm *vm, bntvfunc f, int nupvals)",
        "snippet": "BERRY_API void be_pushntvclosure(bvm *vm, bntvfunc f, int nupvals)\n{\n    /* to create a native closure and then push the top registor,\n     * otherwise the GC may crash due to uninitialized values.\n     **/\n    bntvclos *cl = be_newntvclosure(vm, f, nupvals);\n    bvalue *top = be_incrtop(vm);\n    var_setntvclos(top, cl);\n}",
        "begin_line": 378,
        "end_line": 386,
        "is_bug": false
    },
    {
        "name": "be_api.be_pushntvfunction#388",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pushntvfunction(bvm *vm, bntvfunc f)",
        "snippet": "BERRY_API void be_pushntvfunction(bvm *vm, bntvfunc f)\n{\n    bvalue *top = be_incrtop(vm);\n    var_setntvfunc(top, f);\n}",
        "begin_line": 388,
        "end_line": 392,
        "is_bug": false
    },
    {
        "name": "be_api.be_pushclass#394",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pushclass(bvm *vm, const char *name, const bnfuncinfo *lib)",
        "snippet": "BERRY_API void be_pushclass(bvm *vm, const char *name, const bnfuncinfo *lib)\n{\n    bclass *c;\n    bstring *s = be_newstr(vm, name);\n    bvalue *dst = be_incrtop(vm);\n    var_setstr(dst, s);\n    c = class_auto_make(vm, s, lib);\n    var_setclass(vm->top - 1, c);\n}",
        "begin_line": 394,
        "end_line": 402,
        "is_bug": false
    },
    {
        "name": "be_api.be_pushntvclass#404",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pushntvclass(bvm *vm, const struct bclass * c)",
        "snippet": "BERRY_API void be_pushntvclass(bvm *vm, const struct bclass * c)\n{\n    bvalue *top = be_incrtop(vm);\n    var_setclass(top, (bclass *) c);\n}",
        "begin_line": 404,
        "end_line": 408,
        "is_bug": false
    },
    {
        "name": "be_api.be_pushcomptr#410",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pushcomptr(bvm *vm, void *ptr)",
        "snippet": "BERRY_API void be_pushcomptr(bvm *vm, void *ptr)\n{\n    bvalue *top = be_incrtop(vm);\n    var_setobj(top, BE_COMPTR, ptr);\n}",
        "begin_line": 410,
        "end_line": 414,
        "is_bug": false
    },
    {
        "name": "be_api.be_remove#416",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_remove(bvm *vm, int index)",
        "snippet": "BERRY_API void be_remove(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    bvalue *top = --vm->top;\n    while (v < top) {\n        *v = v[1];\n        ++v;\n    }\n}",
        "begin_line": 416,
        "end_line": 424,
        "is_bug": false
    },
    {
        "name": "be_api.be_strconcat#426",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_strconcat(bvm *vm, int index)",
        "snippet": "BERRY_API void be_strconcat(bvm *vm, int index)\n{\n    bstring *s;\n    bvalue *dst = be_indexof(vm, index);\n    bvalue *src = be_indexof(vm, -1);\n    be_assert(var_isstr(src) && var_isstr(dst));\n    s = be_strcat(vm, var_tostr(dst), var_tostr(src));\n    var_setstr(dst, s);\n}",
        "begin_line": 426,
        "end_line": 434,
        "is_bug": false
    },
    {
        "name": "be_api.be_setsuper#436",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_setsuper(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_setsuper(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    bvalue *top = be_indexof(vm, -1);\n    if (var_isclass(v) && var_isclass(top)) {\n        bclass *c = var_toobj(v);\n        if (!gc_isconst(c)) {\n            bclass *super = var_toobj(top);\n            be_class_setsuper(c, super);\n            return btrue;\n        }\n    }\n    return bfalse;\n}",
        "begin_line": 436,
        "end_line": 449,
        "is_bug": false
    },
    {
        "name": "be_api.be_getsuper#451",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_getsuper(bvm *vm, int index)",
        "snippet": "BERRY_API void be_getsuper(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    bvalue *top = be_incrtop(vm);\n    if (var_isclass(v)) {\n        bclass *c = var_toobj(v);\n        c = be_class_super(c);\n        if (c) {\n            var_setclass(top, c);\n            return;\n        }\n    } else if (var_isinstance(v)) {\n        binstance *o = var_toobj(v);\n        o = be_instance_super(o);\n        if (o) {\n            var_setinstance(top, o);\n            return;\n        }\n    }\n    var_setnil(top);\n}",
        "begin_line": 451,
        "end_line": 471,
        "is_bug": false
    },
    {
        "name": "be_api._getclass#473",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api._getclass(bvalue *v)",
        "snippet": "static bclass* _getclass(bvalue *v)\n{ \n    if (var_isinstance(v)) {\n        binstance *ins = var_toobj(v);\n        return be_instance_class(ins);\n    }\n    return var_isclass(v) ? var_toobj(v) : NULL;\n}",
        "begin_line": 473,
        "end_line": 480,
        "is_bug": false
    },
    {
        "name": "be_api.be_isderived#482",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_isderived(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_isderived(bvm *vm, int index)\n{\n    bclass *sup = _getclass(be_indexof(vm, -1));\n    if (sup) {\n        bclass *c = _getclass(be_indexof(vm, index));\n        while (c && c != sup)\n            c = be_class_super(c);\n        return c != NULL;\n    }\n    return bfalse;\n}",
        "begin_line": 482,
        "end_line": 492,
        "is_bug": false
    },
    {
        "name": "be_api.be_typename#494",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_typename(bvm *vm, int index)",
        "snippet": "BERRY_API const char *be_typename(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    return be_vtype2str(v);\n}",
        "begin_line": 494,
        "end_line": 498,
        "is_bug": false
    },
    {
        "name": "be_api.be_classname#500",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_classname(bvm *vm, int index)",
        "snippet": "BERRY_API const char *be_classname(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    if (var_isclass(v)) {\n        bclass *c = var_toobj(v);\n        return str(be_class_name(c));\n    }\n    if (var_isinstance(v)) {\n        binstance *i = var_toobj(v);\n        return str(be_instance_name(i));\n    }\n    return NULL;\n}",
        "begin_line": 500,
        "end_line": 512,
        "is_bug": false
    },
    {
        "name": "be_api.be_classof#514",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_classof(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_classof(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    if (var_isinstance(v)) {\n        bvalue *top = be_incrtop(vm);\n        binstance *ins = var_toobj(v);\n        var_setclass(top, be_instance_class(ins));\n        return btrue;\n    }\n    return bfalse;\n}",
        "begin_line": 514,
        "end_line": 524,
        "is_bug": false
    },
    {
        "name": "be_api.be_strlen#526",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_strlen(bvm *vm, int index)",
        "snippet": "BERRY_API int be_strlen(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    if (var_isstr(v)) {\n        return str_len(var_tostr(v));\n    }\n    return 0;\n}",
        "begin_line": 526,
        "end_line": 533,
        "is_bug": false
    },
    {
        "name": "be_api.be_newlist#535",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_newlist(bvm *vm)",
        "snippet": "BERRY_API void be_newlist(bvm *vm)\n{\n    blist *list = be_list_new(vm);\n    bvalue *top = be_incrtop(vm);\n    var_setlist(top, list);\n}",
        "begin_line": 535,
        "end_line": 540,
        "is_bug": false
    },
    {
        "name": "be_api.be_newmap#542",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_newmap(bvm *vm)",
        "snippet": "BERRY_API void be_newmap(bvm *vm)\n{\n    bmap *map = be_map_new(vm);\n    bvalue *top = be_incrtop(vm);\n    var_setobj(top, BE_MAP, map);\n}",
        "begin_line": 542,
        "end_line": 547,
        "is_bug": false
    },
    {
        "name": "be_api.be_newmodule#549",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_newmodule(bvm *vm)",
        "snippet": "BERRY_API void be_newmodule(bvm *vm)\n{\n    bmodule *mod = be_module_new(vm);\n    bvalue *top = be_incrtop(vm);\n    var_setobj(top, BE_MODULE, mod);\n}",
        "begin_line": 549,
        "end_line": 554,
        "is_bug": false
    },
    {
        "name": "be_api.be_newobject#556",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_newobject(bvm *vm, const char *name)",
        "snippet": "BERRY_API void be_newobject(bvm *vm, const char *name)\n{\n    be_getbuiltin(vm, name);\n    be_call(vm, 0);\n    be_getmember(vm, -1, \".p\");\n}",
        "begin_line": 556,
        "end_line": 561,
        "is_bug": false
    },
    {
        "name": "be_api.be_setname#563",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_setname(bvm *vm, int index, const char *name)",
        "snippet": "BERRY_API bbool be_setname(bvm *vm, int index, const char *name)\n{\n    bvalue *v = be_indexof(vm, index);\n    if (var_ismodule(v)) {\n        bmodule *module = var_toobj(v);\n        return be_module_setname(module, be_newstr(vm, name));\n    }\n    return bfalse;\n}",
        "begin_line": 563,
        "end_line": 571,
        "is_bug": false
    },
    {
        "name": "be_api.be_getglobal#573",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_getglobal(bvm *vm, const char *name)",
        "snippet": "BERRY_API bbool be_getglobal(bvm *vm, const char *name)\n{\n    int idx = be_global_find(vm, be_newstr(vm, name));\n    bvalue *top = be_incrtop(vm);\n    if (idx > -1) {\n        *top = *be_global_var(vm, idx);\n        return btrue;\n    }\n    var_setnil(top);\n    return bfalse;\n}",
        "begin_line": 573,
        "end_line": 583,
        "is_bug": false
    },
    {
        "name": "be_api.be_setglobal#585",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_setglobal(bvm *vm, const char *name)",
        "snippet": "BERRY_API void be_setglobal(bvm *vm, const char *name)\n{\n    int idx;\n    bstring *s = be_newstr(vm, name);\n    bvalue *v = be_incrtop(vm);\n    var_setstr(v, s);\n    idx = be_global_new(vm, s);\n    v = be_global_var(vm, idx);\n    *v = *be_indexof(vm, -2);\n    be_stackpop(vm, 1);\n}",
        "begin_line": 585,
        "end_line": 595,
        "is_bug": false
    },
    {
        "name": "be_api.be_getbuiltin#597",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_getbuiltin(bvm *vm, const char *name)",
        "snippet": "BERRY_API bbool be_getbuiltin(bvm *vm, const char *name)\n{\n    int idx = be_builtin_find(vm, be_newstr(vm, name));\n    bvalue *top = be_incrtop(vm);\n    if (idx > -1) {\n        *top = *be_global_var(vm, idx);\n        return btrue;\n    }\n    var_setnil(top);\n    return bfalse;\n}",
        "begin_line": 597,
        "end_line": 607,
        "is_bug": false
    },
    {
        "name": "be_api.be_setmember#609",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_setmember(bvm *vm, int index, const char *k)",
        "snippet": "BERRY_API bbool be_setmember(bvm *vm, int index, const char *k)\n{\n    bvalue *o = be_indexof(vm, index);\n    bvalue *v = be_indexof(vm, -1);\n    if (var_isinstance(o)) {\n        bstring *key = be_newstr(vm, k);\n        binstance *obj = var_toobj(o);\n        return be_instance_setmember(vm, obj, key, v);\n    } else if (var_ismodule(o)) {\n        bstring *key = be_newstr(vm, k);\n        bmodule *mod = var_toobj(o);\n        return be_module_setmember(vm, mod, key, v);\n    }\n    return bfalse;\n}",
        "begin_line": 609,
        "end_line": 623,
        "is_bug": false
    },
    {
        "name": "be_api.be_copy#625",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_copy(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_copy(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    bvalue *top = be_incrtop(vm);\n    if (var_type(v) == BE_LIST) {\n        blist *list = be_list_copy(vm, var_toobj(v));\n        var_setlist(top, list)\n        return btrue;\n    }\n    var_setnil(top);\n    return bfalse;\n}",
        "begin_line": 625,
        "end_line": 636,
        "is_bug": false
    },
    {
        "name": "be_api.ins_member#639",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.ins_member(bvm *vm, int index, const char *k, bbool onlyins)",
        "snippet": "static int ins_member(bvm *vm, int index, const char *k, bbool onlyins)\n{\n    int type = BE_NIL;\n    bvalue *o = be_indexof(vm, index);\n    bvalue *top = be_incrtop(vm);\n    var_setnil(top);\n    if (var_isinstance(o)) {\n        binstance *obj = var_toobj(o);\n        type = be_instance_member(vm, obj, be_newstr(vm, k), top);\n    } else if (var_isclass(o) && !onlyins) {\n        bclass *cl = var_toobj(o);\n        type = be_class_member(vm, cl, be_newstr(vm, k), top);\n    } else if (var_ismodule(o) && !onlyins) {\n        bmodule *module = var_toobj(o);\n        type = be_module_attr(vm, module, be_newstr(vm, k), top);\n    }\n    if (type == BE_NONE) {\n        type = BE_NIL;\n    }\n    return type;\n}",
        "begin_line": 639,
        "end_line": 659,
        "is_bug": false
    },
    {
        "name": "be_api.be_getmember#661",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_getmember(bvm *vm, int index, const char *k)",
        "snippet": "BERRY_API bbool be_getmember(bvm *vm, int index, const char *k)\n{\n    return ins_member(vm, index, k, bfalse) != BE_NIL;\n}",
        "begin_line": 661,
        "end_line": 664,
        "is_bug": false
    },
    {
        "name": "be_api.be_getmethod#666",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_getmethod(bvm *vm, int index, const char *k)",
        "snippet": "BERRY_API bbool be_getmethod(bvm *vm, int index, const char *k)\n{\n    return basetype(ins_member(vm, index, k, btrue)) == BE_FUNCTION;\n}",
        "begin_line": 666,
        "end_line": 669,
        "is_bug": false
    },
    {
        "name": "be_api.be_getindex#671",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_getindex(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_getindex(bvm *vm, int index)\n{\n    bvalue *o = be_indexof(vm, index);\n    bvalue *k = be_indexof(vm, -1);\n    bvalue *dst = be_incrtop(vm);\n    switch (var_type(o)) {\n    case BE_LIST:\n        if (var_isint(k)) {\n            blist *list = cast(blist*, var_toobj(o));\n            int idx = var_toidx(k);\n            bvalue *src = be_list_index(list, idx);\n            if (src) {\n                var_setval(dst, src);\n                return btrue;\n            }\n        }\n        break;\n    case BE_MAP:\n        if (!var_isnil(k)) {\n            bmap *map = cast(bmap*, var_toobj(o));\n            bvalue *src = be_map_find(vm, map, k);\n            if (src) {\n                var_setval(dst, src);\n                return btrue;\n            }\n        }\n        break;\n    default:\n        break;\n    }\n    var_setnil(dst);\n    return bfalse;\n}",
        "begin_line": 671,
        "end_line": 703,
        "is_bug": false
    },
    {
        "name": "be_api.list_setindex#705",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.list_setindex(blist *list, bvalue *key)",
        "snippet": "static bvalue* list_setindex(blist *list, bvalue *key)\n{\n    int idx = var_toidx(key);\n    if (idx < be_list_count(list)) {\n        return be_list_at(list, idx);\n    }\n    return NULL;\n}",
        "begin_line": 705,
        "end_line": 712,
        "is_bug": false
    },
    {
        "name": "be_api.be_setindex#714",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_setindex(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_setindex(bvm *vm, int index)\n{\n    bvalue *dst = NULL;\n    bvalue *o = be_indexof(vm, index);\n    bvalue *k = be_indexof(vm, -2);\n    bvalue *v = be_indexof(vm, -1);\n    switch (var_type(o)) {\n    case BE_LIST:\n        if (var_isint(k)) {\n            blist *list = var_toobj(o);\n            dst = list_setindex(list, k);\n        }\n        break;\n    case BE_MAP:\n        if (!var_isnil(k)) {\n            bmap *map = var_toobj(o);\n            dst = be_map_insert(vm, map, k, NULL);\n        }\n        break;\n    default:\n        break;\n    }\n    if (dst) {\n        var_setval(dst, v);\n        return btrue;\n    }\n    return bfalse;\n}",
        "begin_line": 714,
        "end_line": 741,
        "is_bug": false
    },
    {
        "name": "be_api.be_getupval#743",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_getupval(bvm *vm, int index, int pos)",
        "snippet": "BERRY_API void be_getupval(bvm *vm, int index, int pos)\n{\n    bvalue *f = index ? be_indexof(vm, index) : vm->cf->func;\n    bvalue *uv, *top = be_incrtop(vm);\n    be_assert(var_istype(f, BE_NTVCLOS));\n    if (var_istype(f, BE_NTVCLOS)) {\n        bntvclos *nf = var_toobj(f);\n        be_assert(pos >= 0 && pos < nf->nupvals);\n        uv = be_ntvclos_upval(nf, pos)->value;\n        var_setval(top, uv);\n    } else {\n        var_setnil(top);\n    }\n}",
        "begin_line": 743,
        "end_line": 756,
        "is_bug": false
    },
    {
        "name": "be_api.be_setupval#758",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_setupval(bvm *vm, int index, int pos)",
        "snippet": "BERRY_API bbool be_setupval(bvm *vm, int index, int pos)\n{\n    bvalue *f = index ? be_indexof(vm, index) : vm->cf->func;\n    bvalue *uv, *v = be_indexof(vm, -1);\n    be_assert(var_istype(f, BE_NTVCLOS));\n    if (var_istype(f, BE_NTVCLOS)) {\n        bntvclos *nf = var_toobj(f);\n        be_assert(pos >= 0 && pos < nf->nupvals);\n        uv = be_ntvclos_upval(nf, pos)->value;\n        var_setval(uv, v);\n        return btrue;\n    }\n    return bfalse;\n}",
        "begin_line": 758,
        "end_line": 771,
        "is_bug": false
    },
    {
        "name": "be_api.be_data_size#773",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_data_size(bvm *vm, int index)",
        "snippet": "BERRY_API int be_data_size(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    if (var_islist(v)) {\n        blist *list = var_toobj(v);\n        return be_list_count(list);\n    } else if (var_ismap(v)) {\n        bmap *map = cast(bmap*, var_toobj(v));\n        return be_map_count(map);\n    }\n    return -1;\n}",
        "begin_line": 773,
        "end_line": 784,
        "is_bug": false
    },
    {
        "name": "be_api.be_data_push#786",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_data_push(bvm *vm, int index)",
        "snippet": "BERRY_API void be_data_push(bvm *vm, int index)\n{\n    bvalue *o = be_indexof(vm, index);\n    bvalue *v = be_indexof(vm, -1);\n    if (var_islist(o)) {\n        blist *list = var_toobj(o);\n        be_list_push(vm, list, v);\n    }\n}",
        "begin_line": 786,
        "end_line": 794,
        "is_bug": false
    },
    {
        "name": "be_api.be_data_insert#796",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_data_insert(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_data_insert(bvm *vm, int index)\n{\n    bvalue *o = be_indexof(vm, index);\n    bvalue *k = be_indexof(vm, -2);\n    bvalue *v = be_indexof(vm, -1);\n    switch (var_type(o)) {\n    case BE_MAP:\n        if (!var_isnil(k)) {\n            bmap *map = cast(bmap*, var_toobj(o));\n            bvalue *dst = be_map_find(vm, map, k);\n            if (dst == NULL) {\n                return be_map_insert(vm, map, k, v) != NULL;\n            }\n        }\n        break;\n    case BE_LIST:\n        if (var_isint(k)) {\n            blist *list = cast(blist*, var_toobj(o));\n            return be_list_insert(vm, list, var_toidx(k), v) != NULL;\n        }\n        break;\n    default:\n        break;\n    }\n    return bfalse;\n}",
        "begin_line": 796,
        "end_line": 821,
        "is_bug": false
    },
    {
        "name": "be_api.be_data_remove#823",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_data_remove(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_data_remove(bvm *vm, int index)\n{\n    bvalue *o = be_indexof(vm, index);\n    bvalue *k = be_indexof(vm, -1);\n    switch (var_type(o)) {\n    case BE_MAP:\n        if (!var_isnil(k)) {\n            bmap *map = cast(bmap*, var_toobj(o));\n            return be_map_remove(vm, map, k);\n        }\n        break;\n    case BE_LIST:\n        if (var_isint(k)) {\n            blist *list = cast(blist*, var_toobj(o));\n            return be_list_remove(vm, list, var_toidx(k));\n        }\n        break;\n    default:\n        break;\n    }\n    return bfalse;\n}",
        "begin_line": 823,
        "end_line": 844,
        "is_bug": false
    },
    {
        "name": "be_api.be_data_merge#846",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_data_merge(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_data_merge(bvm *vm, int index)\n{\n    bvalue *a = be_indexof(vm, index);\n    bvalue *b = be_indexof(vm, -1);\n    if (var_islist(a) && var_islist(b)) {\n        blist *dst = var_toobj(a), *src = var_toobj(b);\n        be_list_merge(vm, dst, src);\n        return btrue;\n    }\n    return bfalse;\n}",
        "begin_line": 846,
        "end_line": 856,
        "is_bug": false
    },
    {
        "name": "be_api.be_data_resize#858",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_data_resize(bvm *vm, int index)",
        "snippet": "BERRY_API void be_data_resize(bvm *vm, int index)\n{\n    bvalue *o = be_indexof(vm, index);\n    bvalue *v = be_indexof(vm, -1);\n    if (var_islist(o)) {\n        blist *list = var_toobj(o);\n        if (var_isint(v)) {\n            be_list_resize(vm, list, var_toidx(v));\n        }\n    }\n}",
        "begin_line": 858,
        "end_line": 868,
        "is_bug": false
    },
    {
        "name": "be_api.be_data_reverse#870",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_data_reverse(bvm *vm, int index)",
        "snippet": "BERRY_API void be_data_reverse(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    if (var_type(v) == BE_LIST) {\n        be_list_reverse(var_toobj(v));\n    }\n}",
        "begin_line": 870,
        "end_line": 876,
        "is_bug": false
    },
    {
        "name": "be_api.be_pushiter#878",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pushiter(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_pushiter(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    if (var_ismap(v)) {\n        bvalue *iter = be_incrtop(vm);\n        var_setobj(iter, BE_COMPTR, NULL);\n        return btrue;\n    } else if (var_islist(v)) {\n        blist *list = var_toobj(v);\n        bvalue *iter = be_incrtop(vm);\n        var_setobj(iter, BE_COMPTR, be_list_data(list) - 1);\n        return btrue;\n    }\n    return bfalse;\n}",
        "begin_line": 878,
        "end_line": 892,
        "is_bug": false
    },
    {
        "name": "be_api.list_next#894",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.list_next(bvm *vm)",
        "snippet": "static int list_next(bvm *vm)\n{\n    bvalue *iter = be_indexof(vm, -1);\n    bvalue *next, *dst = be_incrtop(vm);\n    next = cast(bvalue*, var_toobj(iter)) + 1;\n    var_setobj(iter, BE_COMPTR, next);\n    var_setval(dst, next);\n    return 1;\n}",
        "begin_line": 894,
        "end_line": 902,
        "is_bug": false
    },
    {
        "name": "be_api.list_hasnext#904",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.list_hasnext(bvm *vm, bvalue *v)",
        "snippet": "static bbool list_hasnext(bvm *vm, bvalue *v)\n{\n    bvalue *next;\n    bvalue *iter = be_indexof(vm, -1);\n    blist *obj = var_toobj(v);\n    next = cast(bvalue*, var_toobj(iter)) + 1;\n    return next >= be_list_data(obj) && next < be_list_end(obj);\n}",
        "begin_line": 904,
        "end_line": 911,
        "is_bug": false
    },
    {
        "name": "be_api.map_next#913",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.map_next(bvm *vm, bvalue *v)",
        "snippet": "static int map_next(bvm *vm, bvalue *v)\n{\n    bmapiter iter;\n    bmapnode *entry;\n    bvalue *dst = vm->top;\n    bvalue *itvar = be_indexof(vm, -1);\n    iter = var_toobj(itvar);\n    entry = be_map_next(var_toobj(v), &iter);\n    var_setobj(itvar, BE_COMPTR, iter);\n    if (entry) {\n        be_map_key2value(dst, entry);\n        var_setval(dst + 1, &entry->value);\n        vm->top += 2;\n        return 2;\n    }\n    return 0;\n}",
        "begin_line": 913,
        "end_line": 929,
        "is_bug": false
    },
    {
        "name": "be_api.map_hasnext#931",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.map_hasnext(bvm *vm, bvalue *v)",
        "snippet": "static bbool map_hasnext(bvm *vm, bvalue *v)\n{\n    bvalue *node = be_indexof(vm, -1);\n    bmapiter iter = var_toobj(node);\n    return be_map_next(var_toobj(v), &iter) != NULL;\n}",
        "begin_line": 931,
        "end_line": 936,
        "is_bug": false
    },
    {
        "name": "be_api.be_iter_next#938",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_iter_next(bvm *vm, int index)",
        "snippet": "BERRY_API int be_iter_next(bvm *vm, int index)\n{\n    bvalue *o = be_indexof(vm, index);\n    if (var_islist(o)) {\n        return list_next(vm);\n    } else if (var_ismap(o)) {\n        return map_next(vm, o);\n    }\n    return 0;\n}",
        "begin_line": 938,
        "end_line": 947,
        "is_bug": false
    },
    {
        "name": "be_api.be_iter_hasnext#949",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_iter_hasnext(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_iter_hasnext(bvm *vm, int index)\n{\n    bvalue *o = be_indexof(vm, index);\n    if (var_islist(o)) {\n        return list_hasnext(vm, o);\n    } else if (var_ismap(o)) {\n        return map_hasnext(vm, o);\n    }\n    return bfalse;\n}",
        "begin_line": 949,
        "end_line": 958,
        "is_bug": false
    },
    {
        "name": "be_api.be_refcontains#960",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_refcontains(bvm *vm, int index)",
        "snippet": "BERRY_API bbool be_refcontains(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    binstance **ref = be_stack_base(&vm->refstack);\n    binstance **top = be_stack_top(&vm->refstack);\n    binstance *ins = var_toobj(v);\n    be_assert(var_isinstance(v));\n    if (ref) {\n        while (ref <= top && *ref != ins) {\n            ++ref;\n        }\n        return ref <= top;\n    }\n    return bfalse;\n}",
        "begin_line": 960,
        "end_line": 974,
        "is_bug": false
    },
    {
        "name": "be_api.be_refpush#976",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_refpush(bvm *vm, int index)",
        "snippet": "BERRY_API void be_refpush(bvm *vm, int index)\n{\n    bvalue *v = be_indexof(vm, index);\n    binstance *ins = var_toobj(v);\n    be_assert(var_isinstance(v));\n    be_stack_push(vm, &vm->refstack, &ins);\n}",
        "begin_line": 976,
        "end_line": 982,
        "is_bug": false
    },
    {
        "name": "be_api.be_refpop#984",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_refpop(bvm *vm)",
        "snippet": "BERRY_API void be_refpop(bvm *vm)\n{\n    be_stack_pop(&vm->refstack);\n    if (be_stack_isempty(&vm->refstack)) {\n        be_vector_release(vm, &vm->refstack);\n    }\n}",
        "begin_line": 984,
        "end_line": 990,
        "is_bug": false
    },
    {
        "name": "be_api.be_returnvalue#992",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_returnvalue(bvm *vm)",
        "snippet": "BERRY_API int be_returnvalue(bvm *vm)\n{\n    bvalue *src = vm->top - 1;\n    bvalue *ret = retreg(vm);\n    var_setval(ret, src);\n    return 0;\n}",
        "begin_line": 992,
        "end_line": 998,
        "is_bug": false
    },
    {
        "name": "be_api.be_returnnilvalue#1000",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_returnnilvalue(bvm *vm)",
        "snippet": "BERRY_API int be_returnnilvalue(bvm *vm)\n{\n    bvalue *ret = retreg(vm);\n    var_setnil(ret);\n    return 0;\n}",
        "begin_line": 1000,
        "end_line": 1005,
        "is_bug": false
    },
    {
        "name": "be_api.be_call#1007",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_call(bvm *vm, int argc)",
        "snippet": "BERRY_API void be_call(bvm *vm, int argc)\n{\n    bvalue *fval = vm->top - argc - 1;\n    be_dofunc(vm, fval, argc);\n}",
        "begin_line": 1007,
        "end_line": 1011,
        "is_bug": false
    },
    {
        "name": "be_api.be_pcall#1013",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_pcall(bvm *vm, int argc)",
        "snippet": "BERRY_API int be_pcall(bvm *vm, int argc)\n{\n    bvalue *f = vm->top - argc - 1;\n    return be_protectedcall(vm, f, argc);\n}",
        "begin_line": 1013,
        "end_line": 1017,
        "is_bug": false
    },
    {
        "name": "be_api.be_raise#1019",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_raise(bvm *vm, const char *except, const char *msg)",
        "snippet": "BERRY_API void be_raise(bvm *vm, const char *except, const char *msg)\n{\n    be_pushstring(vm, except);\n    if (msg) {\n        be_pushstring(vm, msg);\n    } else {\n        be_pushnil(vm);\n    }\n    be_pop(vm, 2);\n    be_save_stacktrace(vm);\n    be_throw(vm, BE_EXCEPTION);\n}",
        "begin_line": 1019,
        "end_line": 1030,
        "is_bug": false
    },
    {
        "name": "be_api.be_stop_iteration#1032",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_stop_iteration(bvm *vm)",
        "snippet": "BERRY_API void be_stop_iteration(bvm *vm)\n{\n    be_raise(vm, \"stop_iteration\", NULL);\n}",
        "begin_line": 1032,
        "end_line": 1035,
        "is_bug": false
    },
    {
        "name": "be_api.be_getexcept#1037",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_getexcept(bvm *vm, int code)",
        "snippet": "BERRY_API int be_getexcept(bvm *vm, int code)\n{\n    if (code == BE_EXCEPTION) {\n        if (be_isstring(vm, -2)) {\n            const char *except = be_tostring(vm, -2);\n            if (!strcmp(except, \"syntax_error\")) {\n                return BE_SYNTAX_ERROR;\n            }\n            if (!strcmp(except, \"io_error\")) {\n                return BE_IO_ERROR;\n            }\n        }\n        return BE_EXEC_ERROR;\n    }\n    return code;\n}",
        "begin_line": 1037,
        "end_line": 1052,
        "is_bug": false
    },
    {
        "name": "be_api._dvfunc#1054",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api._dvfunc(bvm *vm, bbool esc)",
        "snippet": "static int _dvfunc(bvm *vm, bbool esc)\n{\n    const char* s = esc ?\n        be_toescape(vm, 1, 'x') : be_tostring(vm, 1);\n    be_writestring(s);\n    be_return_nil(vm);\n}",
        "begin_line": 1054,
        "end_line": 1060,
        "is_bug": false
    },
    {
        "name": "be_api._dumpesc#1062",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api._dumpesc(bvm *vm)",
        "snippet": "static int _dumpesc(bvm *vm)\n{\n    return _dvfunc(vm, btrue);\n}",
        "begin_line": 1062,
        "end_line": 1065,
        "is_bug": false
    },
    {
        "name": "be_api._dumpdir#1067",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api._dumpdir(bvm *vm)",
        "snippet": "static int _dumpdir(bvm *vm)\n{\n    return _dvfunc(vm, bfalse);\n}",
        "begin_line": 1067,
        "end_line": 1070,
        "is_bug": false
    },
    {
        "name": "be_api.dump_value#1072",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.dump_value(bvm *vm, int index, bbool esc)",
        "snippet": "static int dump_value(bvm *vm, int index, bbool esc)\n{\n    int res, top = be_top(vm) + 1;\n    index = be_absindex(vm, index);\n    be_pushntvfunction(vm, esc ? _dumpesc : _dumpdir);\n    be_pushvalue(vm, index);\n    res = be_pcall(vm, 1); /* using index to store result */\n    be_remove(vm, top); /* remove '_dumpvalue' function */\n    be_remove(vm, top); /* remove the value */\n    if (res == BE_EXCEPTION) {\n        be_dumpexcept(vm);\n    }\n    return res;\n}",
        "begin_line": 1072,
        "end_line": 1085,
        "is_bug": false
    },
    {
        "name": "be_api.be_dumpvalue#1087",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_dumpvalue(bvm *vm, int index)",
        "snippet": "BERRY_API void be_dumpvalue(bvm *vm, int index)\n{\n    if (dump_value(vm, index, btrue) == BE_OK) {\n        be_writenewline();\n    }\n}",
        "begin_line": 1087,
        "end_line": 1092,
        "is_bug": false
    },
    {
        "name": "be_api.be_dumpexcept#1094",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_dumpexcept(bvm *vm)",
        "snippet": "BERRY_API void be_dumpexcept(bvm *vm)\n{\n    do {\n        /* print exception value */\n        if (dump_value(vm, -2, bfalse)) break;\n        be_writestring(\": \");\n        /* print exception argument */\n        if (dump_value(vm, -1, bfalse)) break;\n        be_writenewline();\n        /* print stack traceback */\n        be_tracestack(vm);\n    } while (0);\n    be_pop(vm, 2); /* pop the exception value & argument */\n}",
        "begin_line": 1094,
        "end_line": 1107,
        "is_bug": false
    },
    {
        "name": "be_api.be_iseq#1109",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_iseq(bvm *vm)",
        "snippet": "BERRY_API bbool be_iseq(bvm *vm)\n{\n    be_assert(vm->reg + 2 <= vm->top);\n    return be_vm_iseq(vm, vm->top - 2, vm->top - 1);\n}",
        "begin_line": 1109,
        "end_line": 1113,
        "is_bug": false
    },
    {
        "name": "be_api.be_isneq#1115",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_isneq(bvm *vm)",
        "snippet": "BERRY_API bbool be_isneq(bvm *vm)\n{\n    be_assert(vm->reg + 2 <= vm->top);\n    return be_vm_isneq(vm, vm->top - 2, vm->top - 1);\n}",
        "begin_line": 1115,
        "end_line": 1119,
        "is_bug": false
    },
    {
        "name": "be_api.be_islt#1121",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_islt(bvm *vm)",
        "snippet": "BERRY_API bbool be_islt(bvm *vm)\n{\n    be_assert(vm->reg + 2 <= vm->top);\n    return be_vm_islt(vm, vm->top - 2, vm->top - 1);\n}",
        "begin_line": 1121,
        "end_line": 1125,
        "is_bug": false
    },
    {
        "name": "be_api.be_isle#1127",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_isle(bvm *vm)",
        "snippet": "BERRY_API bbool be_isle(bvm *vm)\n{\n    be_assert(vm->reg + 2 <= vm->top);\n    return be_vm_isle(vm, vm->top - 2, vm->top - 1);\n}",
        "begin_line": 1127,
        "end_line": 1131,
        "is_bug": false
    },
    {
        "name": "be_api.be_isgt#1133",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_isgt(bvm *vm)",
        "snippet": "BERRY_API bbool be_isgt(bvm *vm)\n{\n    be_assert(vm->reg + 2 <= vm->top);\n    return be_vm_isgt(vm, vm->top - 2, vm->top - 1);\n}",
        "begin_line": 1133,
        "end_line": 1137,
        "is_bug": false
    },
    {
        "name": "be_api.be_isge#1139",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_isge(bvm *vm)",
        "snippet": "BERRY_API bbool be_isge(bvm *vm)\n{\n    be_assert(vm->reg + 2 <= vm->top);\n    return be_vm_isge(vm, vm->top - 2, vm->top - 1);\n}",
        "begin_line": 1139,
        "end_line": 1143,
        "is_bug": false
    },
    {
        "name": "be_api.be_register#1145",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_register(bvm *vm, int index)",
        "snippet": "BERRY_API int be_register(bvm *vm, int index)\n{\n    bvalue *v;\n    if (!vm->registry) {\n        vm->registry = be_list_new(vm);\n        be_list_pool_init(vm, vm->registry);\n    }\n    be_assert(vm->registry != NULL);\n    v = be_indexof(vm, index);\n    return be_list_pool_alloc(vm, vm->registry, v);\n}",
        "begin_line": 1145,
        "end_line": 1155,
        "is_bug": false
    },
    {
        "name": "be_api.be_unregister#1157",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_unregister(bvm *vm, int id)",
        "snippet": "BERRY_API void be_unregister(bvm *vm, int id)\n{\n    be_assert(vm->registry != NULL);\n    be_list_pool_free(vm->registry, id);\n}",
        "begin_line": 1157,
        "end_line": 1161,
        "is_bug": false
    },
    {
        "name": "be_api.be_getregister#1163",
        "src_path": "src/be_api.c",
        "class_name": "be_api",
        "signature": "be_api.be_getregister(bvm *vm, int id)",
        "snippet": "BERRY_API void be_getregister(bvm *vm, int id)\n{\n    blist *reg = vm->registry;\n    be_assert(reg && id > 0 && id < be_list_count(reg));\n    var_setval(vm->top, be_list_at(reg, id));\n    be_incrtop(vm);\n}",
        "begin_line": 1163,
        "end_line": 1169,
        "is_bug": false
    },
    {
        "name": "be_list.be_list_new#18",
        "src_path": "src/be_list.c",
        "class_name": "be_list",
        "signature": "be_list.be_list_new(bvm *vm)",
        "snippet": "blist* be_list_new(bvm *vm)\n{\n    bgcobject *gco = be_gcnew(vm, BE_LIST, blist);\n    blist *list = cast_list(gco);\n    if (list) {\n        list->count = 0;\n        list->capacity = 2;\n        var_setlist(vm->top, list);\n        be_incrtop(vm);\n        list->data = be_malloc(vm, datasize(list->capacity));\n        be_stackpop(vm, 1);\n    }\n    return list;\n}",
        "begin_line": 18,
        "end_line": 31,
        "is_bug": false
    },
    {
        "name": "be_list.be_list_delete#33",
        "src_path": "src/be_list.c",
        "class_name": "be_list",
        "signature": "be_list.be_list_delete(bvm *vm, blist *list)",
        "snippet": "void be_list_delete(bvm *vm, blist *list)\n{\n    be_free(vm, list->data, datasize(list->capacity));\n    be_free(vm, list, sizeof(blist));\n}",
        "begin_line": 33,
        "end_line": 37,
        "is_bug": false
    },
    {
        "name": "be_list.be_list_copy#39",
        "src_path": "src/be_list.c",
        "class_name": "be_list",
        "signature": "be_list.be_list_copy(bvm *vm, blist *original)",
        "snippet": "blist* be_list_copy(bvm *vm, blist *original)\n{\n    bgcobject *gco = be_gcnew(vm, BE_LIST, blist);\n    blist *list = cast_list(gco);\n    if (list) {\n        size_t size = datasize(original->capacity);\n        list->count = original->count;\n        list->capacity = original->capacity;\n        var_setlist(vm->top, list);\n        be_incrtop(vm);\n        list->data = be_malloc(vm, size);\n        be_stackpop(vm, 1);\n        memcpy(list->data, original->data, size);\n    }\n    return list;\n}",
        "begin_line": 39,
        "end_line": 54,
        "is_bug": false
    },
    {
        "name": "be_list.be_list_index#56",
        "src_path": "src/be_list.c",
        "class_name": "be_list",
        "signature": "be_list.be_list_index(blist *list, int index)",
        "snippet": "bvalue* be_list_index(blist *list, int index)\n{\n    if (index < 0) {\n        index = list->count + index;\n    }\n    if (index < 0 || index >= list->count) {\n        return NULL;\n    }\n    return be_list_at(list, index);\n}",
        "begin_line": 56,
        "end_line": 65,
        "is_bug": false
    },
    {
        "name": "be_list.be_list_push#67",
        "src_path": "src/be_list.c",
        "class_name": "be_list",
        "signature": "be_list.be_list_push(bvm *vm, blist *list, bvalue *value)",
        "snippet": "bvalue* be_list_push(bvm *vm, blist *list, bvalue *value)\n{\n    bvalue *slot;\n    if (list->count >= list->capacity) {\n        int newcap = be_nextsize(list->capacity);\n        list->data = be_realloc(vm, list->data,\n            datasize(list->capacity), datasize(newcap));\n        list->capacity = newcap;\n    }\n    slot = list->data + list->count++;\n    if (value != NULL) {\n        *slot = *value;\n    }\n    return slot;\n}",
        "begin_line": 67,
        "end_line": 81,
        "is_bug": false
    },
    {
        "name": "be_list.be_list_insert#83",
        "src_path": "src/be_list.c",
        "class_name": "be_list",
        "signature": "be_list.be_list_insert(bvm *vm, blist *list, int index, bvalue *value)",
        "snippet": "bvalue* be_list_insert(bvm *vm, blist *list, int index, bvalue *value)\n{\n    int i;\n    bvalue *data;\n    if (index < 0) {\n        index = list->count + index;\n    }\n    if (index < 0 || index > list->count) {\n        return NULL;\n    }\n    if (list->count >= list->capacity) {\n        int newcap = be_nextsize(list->capacity);\n        list->data = be_realloc(vm, list->data,\n            datasize(list->capacity), datasize(newcap));\n        list->capacity = newcap;\n    }\n    data = list->data;\n    for (i = list->count++; i > index; --i) {\n        data[i] = data[i - 1];\n    }\n    data = list->data + index;\n    if (value != NULL) {\n        *data = *value;\n    }\n    return data;\n}",
        "begin_line": 83,
        "end_line": 108,
        "is_bug": false
    },
    {
        "name": "be_list.be_list_remove#110",
        "src_path": "src/be_list.c",
        "class_name": "be_list",
        "signature": "be_list.be_list_remove(bvm *vm, blist *list, int index)",
        "snippet": "int be_list_remove(bvm *vm, blist *list, int index)\n{\n    int i;\n    bvalue *data;\n    (void)vm;\n    if (index < 0) {\n        index = list->count + index;\n    }\n    if (index < 0 || index >= list->count) {\n        return bfalse;\n    }\n    data = list->data;\n    list->count--;\n    for (i = index; i < list->count; ++i) {\n        data[i] = data[i + 1];\n    }\n    return btrue;\n}",
        "begin_line": 110,
        "end_line": 127,
        "is_bug": false
    },
    {
        "name": "be_list.be_list_resize#129",
        "src_path": "src/be_list.c",
        "class_name": "be_list",
        "signature": "be_list.be_list_resize(bvm *vm, blist *list, int count)",
        "snippet": "void be_list_resize(bvm *vm, blist *list, int count)\n{\n    if (count != list->count) {\n        int newcap = be_nextsize(count);\n        if (newcap > list->capacity) {\n            bvalue *v, *end;\n            list->data = be_realloc(vm, list->data,\n                datasize(list->capacity), datasize(newcap));\n            list->capacity = newcap;\n            v = list->data + list->count;\n            end = list->data + count;\n            while (v < end) {\n                var_setnil(v++);\n            }\n        }\n        list->count = count;\n    }\n}",
        "begin_line": 129,
        "end_line": 146,
        "is_bug": false
    },
    {
        "name": "be_list.be_list_merge#148",
        "src_path": "src/be_list.c",
        "class_name": "be_list",
        "signature": "be_list.be_list_merge(bvm *vm, blist *list, const blist *other)",
        "snippet": "void be_list_merge(bvm *vm, blist *list, const blist *other)\n{\n    int dst_len = list->count;\n    int src_len = other->count;\n    int length = src_len + dst_len;\n    if (length != 0) {\n        int newcap = be_nextsize(length);\n        if (newcap > list->capacity) {\n            list->data = be_realloc(vm, list->data,\n                datasize(list->capacity), datasize(newcap));\n            list->capacity = newcap;\n        }\n        memcpy(list->data + dst_len, other->data, src_len * sizeof(bvalue));\n        list->count = length;\n    }\n}",
        "begin_line": 148,
        "end_line": 163,
        "is_bug": false
    },
    {
        "name": "be_list.be_list_reverse#165",
        "src_path": "src/be_list.c",
        "class_name": "be_list",
        "signature": "be_list.be_list_reverse(blist *list)",
        "snippet": "void be_list_reverse(blist *list)\n{\n    bvalue *left = list->data;\n    bvalue *right = left + list->count - 1;\n    for (; left < right; ++left, --right) {\n        bvalue temp = *left;\n        *left = *right;\n        *right = temp;\n    }\n}",
        "begin_line": 165,
        "end_line": 174,
        "is_bug": false
    },
    {
        "name": "be_list.be_list_pool_init#176",
        "src_path": "src/be_list.c",
        "class_name": "be_list",
        "signature": "be_list.be_list_pool_init(bvm *vm, blist *list)",
        "snippet": "void be_list_pool_init(bvm *vm, blist *list)\n{\n    bvalue *head;\n    be_list_resize(vm, list, 0);\n    head = be_list_push(vm, list, NULL);\n    var_setint(head, 0);\n}",
        "begin_line": 176,
        "end_line": 182,
        "is_bug": false
    },
    {
        "name": "be_list.be_list_pool_alloc#184",
        "src_path": "src/be_list.c",
        "class_name": "be_list",
        "signature": "be_list.be_list_pool_alloc(bvm *vm, blist *list, bvalue *src)",
        "snippet": "int be_list_pool_alloc(bvm *vm, blist *list, bvalue *src)\n{\n    bvalue *head = be_list_data(list), *node;\n    int id = var_toidx(head); /* get the first free node */\n    if (id) {\n        node = head + id;\n        head->v.i = var_toint(node); /* link the next free node to head */\n    } else {\n        id = be_list_count(list);\n        node = be_list_push(vm, list, NULL);\n    }\n    *node = *src;\n    return id;\n}",
        "begin_line": 184,
        "end_line": 197,
        "is_bug": false
    },
    {
        "name": "be_list.be_list_pool_free#199",
        "src_path": "src/be_list.c",
        "class_name": "be_list",
        "signature": "be_list.be_list_pool_free(blist *list, int id)",
        "snippet": "void be_list_pool_free(blist *list, int id)\n{\n    bvalue *head = be_list_data(list);\n    bvalue *node = head + id;\n    be_assert(id > 0 && id < list->count);\n    /* insert a new free node to head */\n    *node = *head;\n    head->v.i = id;\n}",
        "begin_line": 199,
        "end_line": 207,
        "is_bug": false
    },
    {
        "name": "be_mem.be_os_malloc#29",
        "src_path": "src/be_mem.c",
        "class_name": "be_mem",
        "signature": "be_mem.be_os_malloc(size_t size)",
        "snippet": "BERRY_API void* be_os_malloc(size_t size)\n{\n    return malloc(size);\n}",
        "begin_line": 29,
        "end_line": 32,
        "is_bug": false
    },
    {
        "name": "be_mem.be_os_free#34",
        "src_path": "src/be_mem.c",
        "class_name": "be_mem",
        "signature": "be_mem.be_os_free(void *ptr)",
        "snippet": "BERRY_API void be_os_free(void *ptr)\n{\n    free(ptr);\n}",
        "begin_line": 34,
        "end_line": 37,
        "is_bug": false
    },
    {
        "name": "be_mem.be_os_realloc#39",
        "src_path": "src/be_mem.c",
        "class_name": "be_mem",
        "signature": "be_mem.be_os_realloc(void *ptr, size_t size)",
        "snippet": "BERRY_API void* be_os_realloc(void *ptr, size_t size)\n{\n    return realloc(ptr, size);\n}",
        "begin_line": 39,
        "end_line": 42,
        "is_bug": false
    },
    {
        "name": "be_mem._realloc#44",
        "src_path": "src/be_mem.c",
        "class_name": "be_mem",
        "signature": "be_mem._realloc(void *ptr, size_t old_size, size_t new_size)",
        "snippet": "static void* _realloc(void *ptr, size_t old_size, size_t new_size)\n{\n    if (old_size == new_size) { /* the block unchanged */\n        return ptr;\n    }\n    if (ptr && new_size) { /* realloc block */\n        return realloc(ptr, new_size);\n    }\n    if (new_size) { /* alloc a new block */\n        be_assert(ptr == NULL && old_size == 0);\n        return malloc(new_size);\n    }\n    be_assert(new_size == 0);\n\n#if BE_USE_DEBUG_GC\n    memset(ptr, 0xFF, old_size); /* fill the structure with invalid pointers */\n#endif\n    free(ptr);\n    return NULL;\n}",
        "begin_line": 44,
        "end_line": 63,
        "is_bug": false
    },
    {
        "name": "be_mem.be_realloc#65",
        "src_path": "src/be_mem.c",
        "class_name": "be_mem",
        "signature": "be_mem.be_realloc(bvm *vm, void *ptr, size_t old_size, size_t new_size)",
        "snippet": "BERRY_API void* be_realloc(bvm *vm, void *ptr, size_t old_size, size_t new_size)\n{\n    void *block = _realloc(ptr, old_size, new_size);\n    if (!block && new_size) { /* allocation failure */\n        vm->gc.status |= GC_ALLOC;\n        be_gc_collect(vm); /* try to allocate again after GC */\n        vm->gc.status &= ~GC_ALLOC;\n        block = _realloc(ptr, old_size, new_size);\n        if (!block) { /* lack of heap space */\n            be_throw(vm, BE_MALLOC_FAIL);\n        }\n    }\n    vm->gc.usage = vm->gc.usage + new_size - old_size; /* update allocated count */\n    return block;\n}",
        "begin_line": 65,
        "end_line": 79,
        "is_bug": false
    },
    {
        "name": "be_vm.attribute_error#128",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.attribute_error(bvm *vm, const char *t, bvalue *b, bvalue *c)",
        "snippet": "static void attribute_error(bvm *vm, const char *t, bvalue *b, bvalue *c)\n{\n    const char *attr = var_isstr(c) ? str(var_tostr(c)) : be_vtype2str(c);\n    vm_error(vm, \"attribute_error\",\n        \"'%s' value has no %s '%s'\", be_vtype2str(b), t, attr);\n}",
        "begin_line": 128,
        "end_line": 133,
        "is_bug": false
    },
    {
        "name": "be_vm.binop_error#135",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.binop_error(bvm *vm, const char *op, bvalue *a, bvalue *b)",
        "snippet": "static void binop_error(bvm *vm, const char *op, bvalue *a, bvalue *b)\n{\n    vm_error(vm, \"type_error\",\n        \"unsupported operand type(s) for %s: '%s' and '%s'\",\n        op, be_vtype2str(a), be_vtype2str(b));\n}",
        "begin_line": 135,
        "end_line": 140,
        "is_bug": false
    },
    {
        "name": "be_vm.unop_error#142",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.unop_error(bvm *vm, const char *op, bvalue *a)",
        "snippet": "static void unop_error(bvm *vm, const char *op, bvalue *a)\n{\n    vm_error(vm, \"type_error\",\n        \"unsupported operand type(s) for %s: '%s'\",\n        op, be_vtype2str(a));\n}",
        "begin_line": 142,
        "end_line": 147,
        "is_bug": false
    },
    {
        "name": "be_vm.call_error#149",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.call_error(bvm *vm, bvalue *v)",
        "snippet": "static void call_error(bvm *vm, bvalue *v)\n{\n    vm_error(vm, \"type_error\",\n        \"'%s' value is not callable\", be_vtype2str(v));\n}",
        "begin_line": 149,
        "end_line": 153,
        "is_bug": false
    },
    {
        "name": "be_vm.check_bool#157",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.check_bool(bvm *vm, binstance *obj, const char *method)",
        "snippet": "static void check_bool(bvm *vm, binstance *obj, const char *method)\n{\n    if (!var_isbool(vm->top)) {\n        const char *name = str(be_instance_name(obj));\n        vm_error(vm, \"type_error\",\n            \"`%s::%s` return value error, the expected type is 'bool'\",\n            strlen(name) ? name : \"<anonymous>\", method);\n    }\n}",
        "begin_line": 157,
        "end_line": 165,
        "is_bug": false
    },
    {
        "name": "be_vm.precall#193",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.precall(bvm *vm, bvalue *func, int nstack, int mode)",
        "snippet": "static void precall(bvm *vm, bvalue *func, int nstack, int mode)\n{\n    bcallframe *cf;\n    int expan = nstack + BE_STACK_FREE_MIN; /* `expan` is the minimum required space on the stack */\n    if (vm->stacktop < func + expan) {  /* do we have too little space left on the stack? */\n        size_t fpos = func - vm->stack;  /* compute offset of `func` from base stack, in case stack is reallocated and base address changes */\n        be_stack_expansion(vm, expan);  /* expand stack (vector object), warning stack address changes */\n        func = vm->stack + fpos;  /* recompute `func` address with new stack address */\n    }\n    be_stack_push(vm, &vm->callstack, NULL);  /* push a NULL value on callstack */\n    cf = be_stack_top(&vm->callstack);  /* get address of new callframe at top of callstack */\n    cf->func = func - mode;\n    cf->top = vm->top;  /* save previous stack top */\n    cf->reg = vm->reg;  /* save previous stack base */\n    vm->reg = func + 1;  /* new stack base is right after function */\n    vm->top = vm->reg + nstack; /* new stack top is above the registers used by the function, so we don\u00b4t mess with them */\n    vm->cf = cf;  /* set new current callframe */\n}\n",
        "begin_line": 193,
        "end_line": 210,
        "is_bug": false
    },
    {
        "name": "be_vm.push_closure#213",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.push_closure(bvm *vm, bvalue *func, int nstack, int mode)",
        "snippet": "static void push_closure(bvm *vm, bvalue *func, int nstack, int mode)\n{\n    bclosure *cl = var_toobj(func);\n    precall(vm, func, nstack, mode);\n    vm->cf->ip = vm->ip;\n    vm->cf->status = NONE_FLAG;\n    vm->ip = cl->proto->code;\n#if BE_USE_DEBUG_HOOK\n    vm->cf->lineinfo = cl->proto->lineinfo;\n    be_callhook(vm, BE_HOOK_CALL);\n#endif\n}",
        "begin_line": 213,
        "end_line": 224,
        "is_bug": false
    },
    {
        "name": "be_vm.ret_native#226",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.ret_native(bvm *vm)",
        "snippet": "static void ret_native(bvm *vm)\n{\n    bcallframe *_cf = vm->cf;\n    vm->reg = _cf->reg;\n    vm->top = _cf->top;\n    be_stack_pop(&vm->callstack);\n    vm->cf = be_stack_top(&vm->callstack);\n}",
        "begin_line": 226,
        "end_line": 233,
        "is_bug": false
    },
    {
        "name": "be_vm.obj2bool#235",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.obj2bool(bvm *vm, bvalue *var)",
        "snippet": "static bbool obj2bool(bvm *vm, bvalue *var)\n{\n    binstance *obj = var_toobj(var);\n    bstring *tobool = str_literal(vm, \"tobool\");\n    /* get operator method */\n    int type = be_instance_member(vm, obj, tobool, vm->top);\n    if (type != BE_NONE && type != BE_NIL) {\n        vm->top[1] = *var; /* move self to argv[0] */\n        be_dofunc(vm, vm->top, 1); /* call method 'tobool' */\n        /* check the return value */\n        check_bool(vm, obj, \"tobool\");\n        return var_tobool(vm->top);\n    }\n    return btrue;\n}",
        "begin_line": 235,
        "end_line": 249,
        "is_bug": false
    },
    {
        "name": "be_vm.be_value2bool#251",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.be_value2bool(bvm *vm, bvalue *v)",
        "snippet": "bbool be_value2bool(bvm *vm, bvalue *v)\n{\n    switch (var_basetype(v)) {\n    case BE_NIL:\n        return bfalse;\n    case BE_BOOL:\n        return var_tobool(v);\n    case BE_INT:\n        return val2bool(v->v.i);\n    case BE_REAL:\n        return val2bool(v->v.r);\n    case BE_INSTANCE:\n        return obj2bool(vm, v);\n    default:\n        return btrue;\n    }\n}",
        "begin_line": 251,
        "end_line": 267,
        "is_bug": false
    },
    {
        "name": "be_vm.obj_method#269",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.obj_method(bvm *vm, bvalue *o, bstring *attr, bvalue *dst)",
        "snippet": "static void obj_method(bvm *vm, bvalue *o, bstring *attr, bvalue *dst)\n{\n    binstance *obj = var_toobj(o);\n    int type = be_instance_member_simple(vm, obj, attr, dst);\n    if (basetype(type) != BE_FUNCTION) {\n        vm_error(vm, \"attribute_error\",\n            \"the '%s' object has no method '%s'\",\n            str(be_instance_name(obj)), str(attr));\n    }\n}",
        "begin_line": 269,
        "end_line": 278,
        "is_bug": false
    },
    {
        "name": "be_vm.obj_attribute#280",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.obj_attribute(bvm *vm, bvalue *o, bstring *attr, bvalue *dst)",
        "snippet": "static int obj_attribute(bvm *vm, bvalue *o, bstring *attr, bvalue *dst)\n{\n    binstance *obj = var_toobj(o);\n    int type = be_instance_member(vm, obj, attr, dst);\n    if (type == BE_NONE) {\n        vm_error(vm, \"attribute_error\",\n            \"the '%s' object has no attribute '%s'\",\n            str(be_instance_name(obj)), str(attr));\n    }\n    return type;\n}",
        "begin_line": 280,
        "end_line": 290,
        "is_bug": false
    },
    {
        "name": "be_vm.class_attribute#292",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.class_attribute(bvm *vm, bvalue *o, bvalue *c, bvalue *dst)",
        "snippet": "static int class_attribute(bvm *vm, bvalue *o, bvalue *c, bvalue *dst)\n{\n    bstring *attr = var_tostr(c);\n    bclass *obj = var_toobj(o);\n    int type = be_class_member(vm, obj, attr, dst);\n    if (type == BE_NONE || type == BE_INDEX) {\n        vm_error(vm, \"attribute_error\",\n            \"the '%s' class has no static attribute '%s'\",\n            str(obj->name), str(attr));\n    }\n    return type;\n}",
        "begin_line": 292,
        "end_line": 303,
        "is_bug": false
    },
    {
        "name": "be_vm.module_attribute#305",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.module_attribute(bvm *vm, bvalue *o, bvalue *c, bvalue *dst)",
        "snippet": "static int module_attribute(bvm *vm, bvalue *o, bvalue *c, bvalue *dst)\n{\n    bstring *attr = var_tostr(c);\n    bmodule *module = var_toobj(o);\n    int type = be_module_attr(vm, module, attr, dst);\n    if (type == BE_NONE) {\n        vm_error(vm, \"attribute_error\",\n            \"module '%s' has no member '%s'\",\n            be_module_name(module), str(attr));\n    }\n    return type;\n}",
        "begin_line": 305,
        "end_line": 316,
        "is_bug": false
    },
    {
        "name": "be_vm.object_eqop#318",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.object_eqop(bvm *vm, const char *op, bbool iseq, bvalue *a, bvalue *b)",
        "snippet": "static bbool object_eqop(bvm *vm,\n    const char *op, bbool iseq, bvalue *a, bvalue *b)\n{\n    binstance *o = var_toobj(a);\n    bvalue self = *a, other = *b;\n    bbool isself = var_isinstance(b) && o == var_toobj(b);\n    /* first, try to call the overloaded operator of the object */\n    int type = be_instance_member(vm, o, be_newstr(vm, op), vm->top);\n    if (basetype(type) == BE_FUNCTION) { /* call method */\n        bvalue *top = vm->top;\n        top[1] = self;  /* move self to argv[0] */\n        top[2] = other; /* move other to argv[1] */\n        be_incrtop(vm); /* prevent collection results */\n        be_dofunc(vm, top, 2); /* call method 'item' */\n        be_stackpop(vm, 1);\n        check_bool(vm, o, op); /* check return value */\n        return var_tobool(vm->top); /* copy result to dst */\n    }\n    /* the default equal operation rule */\n    return iseq == isself; /* check object self */\n}",
        "begin_line": 318,
        "end_line": 338,
        "is_bug": false
    },
    {
        "name": "be_vm.object_binop#340",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.object_binop(bvm *vm, const char *op, bvalue self, bvalue other)",
        "snippet": "static void object_binop(bvm *vm, const char *op, bvalue self, bvalue other)\n{\n    bvalue *top = vm->top;\n    /* get operator method (possible GC) */\n    obj_method(vm, &self, be_newstr(vm, op), vm->top);\n    top[1] = self; /* move self to argv[0] */\n    top[2] = other; /* move other to argv[1] */\n    be_incrtop(vm); /* prevent collection results */\n    be_dofunc(vm, top, 2); /* call method 'item' */\n    be_stackpop(vm, 1);\n}",
        "begin_line": 340,
        "end_line": 350,
        "is_bug": false
    },
    {
        "name": "be_vm.ins_unop#358",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.ins_unop(bvm *vm, const char *op, bvalue self)",
        "snippet": "static void ins_unop(bvm *vm, const char *op, bvalue self)\n{\n    bvalue *top = vm->top;\n    /* get operator method (possible GC) */\n    obj_method(vm, &self, be_newstr(vm, op), vm->top);\n    top[1] = self; /* move self to argv[0] */\n    be_dofunc(vm, top, 1); /* call method 'item' */\n}",
        "begin_line": 358,
        "end_line": 365,
        "is_bug": false
    },
    {
        "name": "be_vm.be_vm_iseq#367",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.be_vm_iseq(bvm *vm, bvalue *a, bvalue *b)",
        "snippet": "bbool be_vm_iseq(bvm *vm, bvalue *a, bvalue *b)\n{\n    equal_rule(==, btrue);\n}",
        "begin_line": 367,
        "end_line": 370,
        "is_bug": false
    },
    {
        "name": "be_vm.be_vm_isneq#372",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.be_vm_isneq(bvm *vm, bvalue *a, bvalue *b)",
        "snippet": "bbool be_vm_isneq(bvm *vm, bvalue *a, bvalue *b)\n{\n    equal_rule(!=, bfalse);\n}",
        "begin_line": 372,
        "end_line": 375,
        "is_bug": false
    },
    {
        "name": "be_vm.be_vm_islt#377",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.be_vm_islt(bvm *vm, bvalue *a, bvalue *b)",
        "snippet": "bbool be_vm_islt(bvm *vm, bvalue *a, bvalue *b)\n{\n    relop_rule(<);\n}",
        "begin_line": 377,
        "end_line": 380,
        "is_bug": false
    },
    {
        "name": "be_vm.be_vm_isle#382",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.be_vm_isle(bvm *vm, bvalue *a, bvalue *b)",
        "snippet": "bbool be_vm_isle(bvm *vm, bvalue *a, bvalue *b)\n{\n    relop_rule(<=);\n}",
        "begin_line": 382,
        "end_line": 385,
        "is_bug": false
    },
    {
        "name": "be_vm.be_vm_isgt#387",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.be_vm_isgt(bvm *vm, bvalue *a, bvalue *b)",
        "snippet": "bbool be_vm_isgt(bvm *vm, bvalue *a, bvalue *b)\n{\n    relop_rule(>);\n}",
        "begin_line": 387,
        "end_line": 390,
        "is_bug": false
    },
    {
        "name": "be_vm.be_vm_isge#392",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.be_vm_isge(bvm *vm, bvalue *a, bvalue *b)",
        "snippet": "bbool be_vm_isge(bvm *vm, bvalue *a, bvalue *b)\n{\n    relop_rule(>=);\n}",
        "begin_line": 392,
        "end_line": 395,
        "is_bug": false
    },
    {
        "name": "be_vm.make_range#397",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.make_range(bvm *vm, bvalue lower, bvalue upper)",
        "snippet": "static void make_range(bvm *vm, bvalue lower, bvalue upper)\n{\n    /* get method 'item' (possible GC) */\n    int idx = be_builtin_find(vm, str_literal(vm, \"range\"));\n    bvalue *top = vm->top;\n    top[0] = *be_global_var(vm, idx);\n    top[1] = lower; /* move lower to argv[0] */\n    top[2] = upper; /* move upper to argv[1] */\n    vm->top += 3; /* prevent collection results */\n    be_dofunc(vm, top, 2); /* call method 'item' */\n    vm->top -= 3;\n}",
        "begin_line": 397,
        "end_line": 408,
        "is_bug": false
    },
    {
        "name": "be_vm.connect_str#410",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.connect_str(bvm *vm, bstring *a, bvalue *b)",
        "snippet": "static void connect_str(bvm *vm, bstring *a, bvalue *b)\n{\n    bstring *s;\n    if (var_isstr(b)) {\n        s = be_strcat(vm, a, var_tostr(b));\n        var_setstr(vm->top, s);\n    } else {\n        *vm->top++ = *b;\n        be_val2str(vm, -1);\n        b = vm->top - 1;\n        s = be_strcat(vm, a, var_tostr(b));\n        var_setstr(b, s);\n        vm->top -= 1;\n    }\n}",
        "begin_line": 410,
        "end_line": 424,
        "is_bug": false
    },
    {
        "name": "be_vm.be_vm_new#426",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.be_vm_new(void)",
        "snippet": "BERRY_API bvm* be_vm_new(void)\n{\n    bvm *vm = be_os_malloc(sizeof(bvm));\n    be_assert(vm != NULL);\n    memset(vm, 0, sizeof(bvm)); /* clear all members */\n    be_gc_init(vm);\n    be_string_init(vm);\n    be_stack_init(vm, &vm->callstack, sizeof(bcallframe));\n    be_stack_init(vm, &vm->refstack, sizeof(binstance*));\n    be_stack_init(vm, &vm->exceptstack, sizeof(struct bexecptframe));\n    be_stack_init(vm, &vm->tracestack, sizeof(bcallsnapshot));\n    vm->stack = be_malloc(vm, sizeof(bvalue) * BE_STACK_FREE_MIN);\n    vm->stacktop = vm->stack + BE_STACK_FREE_MIN;\n    vm->reg = vm->stack;\n    vm->top = vm->reg;\n    be_globalvar_init(vm);\n    be_gc_setpause(vm, 1);\n    be_loadlibs(vm);\n    vm->compopt = 0;\n#if BE_USE_OBSERVABILITY_HOOK\n    vm->obshook = NULL;\n#endif\n    return vm;\n}",
        "begin_line": 426,
        "end_line": 449,
        "is_bug": false
    },
    {
        "name": "be_vm.be_vm_delete#451",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.be_vm_delete(bvm *vm)",
        "snippet": "BERRY_API void be_vm_delete(bvm *vm)\n{\n    be_gc_deleteall(vm);\n    be_string_deleteall(vm);\n    be_stack_delete(vm, &vm->callstack);\n    be_stack_delete(vm, &vm->refstack);\n    be_stack_delete(vm, &vm->exceptstack);\n    be_stack_delete(vm, &vm->tracestack);\n    be_free(vm, vm->stack, (vm->stacktop - vm->stack) * sizeof(bvalue));\n    be_globalvar_deinit(vm);\n#if BE_USE_DEBUG_HOOK\n    /* free native hook */\n    if (var_istype(&vm->hook, BE_COMPTR))\n        be_free(vm, var_toobj(&vm->hook), sizeof(struct bhookblock));\n#endif\n    /* free VM structure */\n    be_os_free(vm);\n}",
        "begin_line": 451,
        "end_line": 468,
        "is_bug": false
    },
    {
        "name": "be_vm.vm_exec#470",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.vm_exec(bvm *vm)",
        "snippet": "static void vm_exec(bvm *vm)\n{\n    bclosure *clos;\n    bvalue *ktab, *reg;\n    binstruction ins;\n    vm->cf->status |= BASE_FRAME;\nnewframe: /* a new call frame */\n    be_assert(var_isclosure(vm->cf->func));\n    clos = var_toobj(vm->cf->func);  /* `clos` is the current function/closure */\n    ktab = clos->proto->ktab;  /* `ktab` is the current constant table */\n    reg = vm->reg;  /* `reg` is the current stack base for the callframe */\n    vm_exec_loop() {\n        opcase(LDNIL): {\n            var_setnil(RA());\n            dispatch();\n        }\n        opcase(LDBOOL): {\n            bvalue *v = RA();\n            var_setbool(v, IGET_RKB(ins));\n            if (IGET_RKC(ins)) { /* skip next instruction */\n                vm->ip += 1;\n            }\n            dispatch();\n        }\n        opcase(LDINT): {\n            bvalue *v = RA();\n            var_setint(v, IGET_sBx(ins));\n            dispatch();\n        }\n        opcase(LDCONST): {\n            bvalue *dst = RA();\n            *dst = ktab[IGET_Bx(ins)];\n            dispatch();\n        }\n        opcase(GETGBL): {\n            bvalue *v = RA();\n            int idx = IGET_Bx(ins);\n            *v = *be_global_var(vm, idx);\n            dispatch();\n        }\n        opcase(GETNGBL): {  /* get Global by name */\n            bvalue *v = RA();\n            bvalue *b = RKB();\n            if (var_isstr(b)) {\n                bstring *name = var_tostr(b);\n                int idx = be_global_find(vm, name);\n                if (idx > -1) {\n                    *v = *be_global_var(vm, idx);\n                } else {\n                    vm_error(vm, \"attribute_error\", \"'%s' undeclared\", str(name));\n                }\n            } else {\n                vm_error(vm, \"internal_error\", \"global name must be a string\");\n            }\n            dispatch();\n        }\n        opcase(SETNGBL): {  /* set Global by name */\n            bvalue *v = RA();\n            bvalue *b = RKB();\n            if (var_isstr(b)) {\n                bstring *name = var_tostr(b);\n                int idx = be_global_new(vm, name);\n                *be_global_var(vm, idx) = *v;\n            } else {\n                vm_error(vm, \"internal_error\", \"global name must be a string\");\n            }\n            dispatch();\n        }\n        opcase(SETGBL): {\n            bvalue *v = RA();\n            int idx = IGET_Bx(ins);\n            *be_global_var(vm, idx) = *v;\n            dispatch();\n        }\n        opcase(GETUPV): {\n            bvalue *v = RA();\n            int idx = IGET_Bx(ins);\n            be_assert(*clos->upvals != NULL);\n            *v = *clos->upvals[idx]->value;\n            dispatch();\n        }\n        opcase(SETUPV): {\n            bvalue *v = RA();\n            int idx = IGET_Bx(ins);\n            be_assert(*clos->upvals != NULL);\n            *clos->upvals[idx]->value = *v;\n            dispatch();\n        }\n        opcase(MOVE): {\n            bvalue *dst = RA();\n            *dst = *RKB();\n            dispatch();\n        }\n        opcase(ADD): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                var_setint(dst, ibinop(+, a, b));\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                breal x = var2real(a), y = var2real(b);\n                var_setreal(dst, x + y);\n            } else if (var_isstr(a) && var_isstr(b)) { /* strcat */\n                bstring *s = be_strcat(vm, var_tostr(a), var_tostr(b));\n                reg = vm->reg;\n                dst = RA();\n                var_setstr(dst, s);\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, \"+\", ins);\n            } else {\n                binop_error(vm, \"+\", a, b);\n            }\n            dispatch();\n        }\n        opcase(SUB): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                var_setint(dst, ibinop(-, a, b));\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                breal x = var2real(a), y = var2real(b);\n                var_setreal(dst, x - y);\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, \"-\", ins);\n            } else {\n                binop_error(vm, \"-\", a, b);\n            }\n            dispatch();\n        }\n        opcase(MUL): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                var_setint(dst, ibinop(*, a, b));\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                breal x = var2real(a), y = var2real(b);\n                var_setreal(dst, x * y);\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, \"*\", ins);\n            } else {\n                binop_error(vm, \"*\", a, b);\n            }\n            dispatch();\n        }\n        opcase(DIV): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                bint x = var_toint(a), y = var_toint(b);\n                if (y == 0) {\n                    vm_error(vm, \"divzero_error\", \"division by zero\");\n                } else {\n                    var_setint(dst, x / y);\n                }\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                breal x = var2real(a), y = var2real(b);\n                if (y == cast(breal, 0)) {\n                    vm_error(vm, \"divzero_error\", \"division by zero\");\n                }\n                var_setreal(dst, x / y);\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, \"/\", ins);\n            } else {\n                binop_error(vm, \"/\", a, b);\n            }\n            dispatch();\n        }\n        opcase(MOD): {\n            bvalue *dst = RA(), *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                var_setint(dst, ibinop(%, a, b));\n            } else if (var_isnumber(a) && var_isnumber(b)) {\n                var_setreal(dst, mathfunc(fmod)(var_toreal(a), var_toreal(b)));\n            } else if (var_isinstance(a)) {\n                ins_binop(vm, \"%\", ins);\n            } else {\n                binop_error(vm, \"%\", a, b);\n            }\n            dispatch();\n        }\n        opcase(LT): {\n            bbool res = be_vm_islt(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(LE): {\n            bbool res = be_vm_isle(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(EQ): {\n            bbool res = be_vm_iseq(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(NE): {\n            bbool res = be_vm_isneq(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(GT): {\n            bbool res = be_vm_isgt(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(GE): {\n            bbool res = be_vm_isge(vm, RKB(), RKC());\n            bvalue *dst;\n            reg = vm->reg;\n            dst = RA();\n            var_setbool(dst, res);\n            dispatch();\n        }\n        opcase(CONNECT): {\n            bvalue *a = RKB(), *b = RKC();\n            if (var_isint(a) && var_isint(b)) {\n                make_range(vm, *RKB(), *RKC());\n            } else if (var_isstr(a)) {\n                connect_str(vm, var_tostr(a), b);\n            } else if (var_isinstance(a)) {\n                object_binop(vm, \"..\", *RKB(), *RKC());\n            } else {\n                binop_error(vm, \"..\", RKB(), RKC());\n            }\n            reg = vm->reg;\n            *RA() = *vm->top; /* copy result to R(A) */\n            dispatch();\n        }\n        opcase(AND): {\n            bitwise_block(&);\n            dispatch();\n        }\n        opcase(OR): {\n            bitwise_block(|);\n            dispatch();\n        }\n        opcase(XOR): {\n            bitwise_block(^);\n            dispatch();\n        }\n        opcase(SHL): {\n            bitwise_block(<<);\n            dispatch();\n        }\n        opcase(SHR): {\n            bitwise_block(>>);\n            dispatch();\n        }\n        opcase(NEG): {\n            bvalue *dst = RA(), *a = RKB();\n            if (var_isint(a)) {\n                var_setint(dst, -a->v.i);\n            } else if (var_isreal(a)) {\n                var_setreal(dst, -a->v.r);\n            } else if (var_isinstance(a)) {\n                ins_unop(vm, \"-*\", *RKB());\n                reg = vm->reg;\n                *RA() = *vm->top; /* copy result to dst */\n            } else {\n                unop_error(vm, \"-\", a);\n            }\n            dispatch();\n        }\n        opcase(FLIP): {\n            bvalue *dst = RA(), *a = RKB();\n            if (var_isint(a)) {\n                var_setint(dst, -a->v.i);\n            } else if (var_isinstance(a)) {\n                ins_unop(vm, \"~\", *RKB());\n                reg = vm->reg;\n                *RA() = *vm->top; /* copy result to dst */\n            } else {\n                unop_error(vm, \"~\", a);\n            }\n            dispatch();\n        }\n        opcase(JMP): {\n            vm->ip += IGET_sBx(ins);\n            dispatch();\n        }\n        opcase(JMPT): {\n            if (be_value2bool(vm, RA())) {\n                vm->ip += IGET_sBx(ins);\n            }\n            dispatch();\n        }\n        opcase(JMPF): {\n            if (!be_value2bool(vm, RA())) {\n                vm->ip += IGET_sBx(ins);\n            }\n            dispatch();\n        }\n        opcase(CLOSURE): {\n            bvalue *dst;\n            bproto *p = clos->proto->ptab[IGET_Bx(ins)];\n            bclosure *cl = be_newclosure(vm, p->nupvals);\n            cl->proto = p;\n            reg = vm->reg;\n            dst = RA();\n            var_setclosure(dst, cl);\n            be_initupvals(vm, cl);\n            dispatch();\n        }\n        opcase(CLASS): {\n            bclass *c = var_toobj(ktab + IGET_Bx(ins));\n            be_class_upvalue_init(vm, c);\n            dispatch();\n        }\n        opcase(GETMBR): {\n            bvalue *a = RA(), *b = RKB(), *c = RKC();\n            if (var_isinstance(b) && var_isstr(c)) {\n                obj_attribute(vm, b, var_tostr(c), a);\n                reg = vm->reg;\n            } else if (var_isclass(b) && var_isstr(c)) {\n                class_attribute(vm, b, c, a);\n                reg = vm->reg;\n            } else if (var_ismodule(b) && var_isstr(c)) {\n                module_attribute(vm, b, c, a);\n                reg = vm->reg;\n            } else {\n                attribute_error(vm, \"attribute\", b, c);\n            }\n            dispatch();\n        }\n        opcase(GETMET): {\n            bvalue *a = RA(), *b = RKB(), *c = RKC();\n            if (var_isinstance(b) && var_isstr(c)) {\n                binstance *obj = var_toobj(b);\n                int type = obj_attribute(vm, b, var_tostr(c), a);\n                reg = vm->reg;\n                if (basetype(type) == BE_FUNCTION) {\n                    /* check if the object is a superinstance, if so get the lowest possible subclass */\n                    while (obj->sub) {\n                        obj = obj->sub;\n                    }\n                    var_setinstance(&a[1], obj);  /* replace superinstance by lowest subinstance */\n                } else {\n                    vm_error(vm, \"attribute_error\",\n                        \"class '%s' has no method '%s'\",\n                        str(be_instance_name(obj)), str(var_tostr(c)));\n                }\n            } else if (var_ismodule(b) && var_isstr(c)) {\n                module_attribute(vm, b, c, &a[1]);\n                var_settype(a, NOT_METHOD);\n            } else {\n                attribute_error(vm, \"method\", b, c);\n            }\n            dispatch();\n        }\n        opcase(SETMBR): {\n            bvalue *a = RA(), *b = RKB(), *c = RKC();\n            if (var_isinstance(a) && var_isstr(b)) {\n                binstance *obj = var_toobj(a);\n                bstring *attr = var_tostr(b);\n                if (!be_instance_setmember(vm, obj, attr, c)) {\n                    vm_error(vm, \"attribute_error\",\n                        \"class '%s' cannot assign to attribute '%s'\",\n                        str(be_instance_name(obj)), str(attr));\n                }\n                dispatch();\n            }\n            if (var_isclass(a) && var_isstr(b)) {\n                bclass *obj = var_toobj(a);\n                bstring *attr = var_tostr(b);\n                if (!be_class_setmember(vm, obj, attr, c)) {\n                    vm_error(vm, \"attribute_error\",\n                        \"class '%s' cannot assign to static attribute '%s'\",\n                        str(be_class_name(obj)), str(attr));\n                }\n                dispatch();\n            }\n            if (var_ismodule(a) && var_isstr(b)) {\n                bmodule *obj = var_toobj(a);\n                bstring *attr = var_tostr(b);\n                if (be_module_setmember(vm, obj, attr, c)) {\n                    dispatch();\n                } else {\n                    // fall through exception below\n                }\n            }\n            attribute_error(vm, \"writable attribute\", a, b);\n            dispatch();\n        }\n        opcase(GETIDX): {\n            bvalue *b = RKB(), *c = RKC();\n            if (var_isinstance(b)) {\n                bvalue *top = vm->top;\n                /* get method 'item' */\n                obj_method(vm, b, str_literal(vm, \"item\"), vm->top);\n                top[1] = *b; /* move object to argv[0] */\n                top[2] = *c; /* move key to argv[1] */\n                vm->top += 3;   /* prevent collection results */\n                be_dofunc(vm, top, 2); /* call method 'item' */\n                vm->top -= 3;\n                reg = vm->reg;\n                *RA() = *vm->top;   /* copy result to R(A) */\n            } else if (var_isstr(b)) {\n                bstring *s = be_strindex(vm, var_tostr(b), c);\n                reg = vm->reg;\n                var_setstr(RA(), s);\n            } else {\n                vm_error(vm, \"type_error\",\n                    \"value '%s' does not support subscriptable\",\n                    be_vtype2str(b));\n            }\n            dispatch();\n        }\n        opcase(SETIDX): {\n            bvalue *a = RA(), *b = RKB(), *c = RKC();\n            if (var_isinstance(a)) {\n                bvalue *top = vm->top;\n                /* get method 'setitem' */\n                obj_method(vm, a, str_literal(vm, \"setitem\"), vm->top);\n                top[1] = *a; /* move object to argv[0] */\n                top[2] = *b; /* move key to argv[1] */\n                top[3] = *c; /* move src to argv[2] */\n                vm->top += 4;\n                be_dofunc(vm, top, 3); /* call method 'setitem' */\n                vm->top -= 4;\n                reg = vm->reg;\n            } else {\n                vm_error(vm, \"type_error\",\n                    \"value '%s' does not support index assignment\",\n                    be_vtype2str(a));\n            }\n            dispatch();\n        }\n        opcase(SETSUPER): {\n            bvalue *a = RA(), *b = RKB();\n            if (var_isclass(a) && var_isclass(b)) {\n                bclass *obj = var_toobj(a);\n                be_class_setsuper(obj, var_toobj(b));\n            } else {\n                vm_error(vm, \"type_error\",\n                    \"value '%s' does not support set super\",\n                    be_vtype2str(b));\n            }\n            dispatch();\n        }\n        opcase(CLOSE): {\n            be_upvals_close(vm, RA());\n            dispatch();\n        }\n        opcase(IMPORT): {\n            bvalue *b = RKB();\n            if (var_isstr(b)) {\n                bstring *name = var_tostr(b);\n                int res = be_module_load(vm, name);\n                reg = vm->reg;\n                switch (res) {\n                case BE_OK: /* find the module */\n                    be_stackpop(vm, 1);\n                    *RA() = *vm->top;\n                    break;\n                case BE_EXCEPTION: /* pop the exception value and message */\n                    be_pop(vm, 2);\n                    be_throw(vm, BE_EXCEPTION);\n                    break;\n                default:\n                    vm_error(vm, \"import_error\", \"module '%s' not found\", str(name));\n                }\n            } else {\n                vm_error(vm, \"type_error\",\n                    \"import '%s' does not support import\",\n                    be_vtype2str(b));\n            }\n            dispatch();\n        }\n        opcase(CATCH): {\n            bvalue *base = RA(), *top = vm->top;\n            int i = 0, ecnt = IGET_RKB(ins), vcnt = IGET_RKC(ins);\n            while (i < ecnt && !be_vm_iseq(vm, top, base + i)) {\n                ++i;\n            }\n            if (!ecnt || i < ecnt) { /* exception catched */\n                base = RA(), top = vm->top;\n                for (i = 0; i < vcnt; ++i) {\n                    *base++ = *top++;\n                }\n                vm->ip += 1; /* skip next instruction */\n            }\n            dispatch();\n        }\n        opcase(RAISE): {\n            if (IGET_RA(ins) < 2) {  /* A==2 means no arguments are passed to RAISE, i.e. rethrow with current exception */\n                bvalue *top = vm->top;\n                top[0] = *RKB(); /* push the exception value to top */\n                if (IGET_RA(ins)) { /* has exception argument? */\n                    top[1] = *RKC(); /* push the exception argument to top + 1 */\n                } else {\n                    var_setnil(top + 1);\n                }\n                be_save_stacktrace(vm);\n            }\n            be_throw(vm, BE_EXCEPTION); /* throw / rethrow the exception */\n            dispatch();\n        }\n        opcase(EXBLK): {\n            if (!IGET_RA(ins)) {\n                be_except_block_setup(vm);\n                if (be_setjmp(vm->errjmp->b)) {\n                    be_except_block_resume(vm);\n                    goto newframe;\n                }\n                reg = vm->reg;\n            } else {\n                be_except_block_close(vm, IGET_Bx(ins));\n            }\n            dispatch();\n        }\n        opcase(CALL): {\n            bvalue *var = RA();  /* `var` is the register for the call followed by arguments */\n            int mode = 0, argc = IGET_RKB(ins);  /* B contains number of arguments pushed on stack */\n        recall: /* goto: instantiation class and call constructor */\n            switch (var_type(var)) {\n            case NOT_METHOD:\n                var[0] = var[1];\n                ++var, --argc, mode = 1;\n                goto recall;\n            case BE_CLASS:\n                if (be_class_newobj(vm, var_toobj(var), var, ++argc, mode)) {  /* instanciate object and find constructor */\n                    reg = vm->reg + mode;  /* constructor found */\n                    mode = 0;\n                    var = RA() + 1; /* to next register */\n                    goto recall; /* call constructor */\n                }\n                break;\n            case BE_INSTANCE: {\n                bvalue *v = var + argc++, temp;\n                /* load the '()' method to `temp' */\n                obj_method(vm, var, str_literal(vm, \"()\"), &temp);\n                for (; v >= var; --v) v[1] = v[0];\n                *var = temp;\n                goto recall; /* call '()' method */\n            }\n            case BE_CLOSURE: {\n                // bvalue *v, *end;\n                // bproto *proto = var2cl(var)->proto;  /* get proto for closure */\n                // push_closure(vm, var, proto->nstack, mode);  /* prepare stack for closure */\n                // reg = vm->reg;  /* `reg` has changed, now new base register */\n                // v = reg + argc;  /* end of provided arguments */\n                // end = reg + proto->argc;  /* end of expected arguments */\n                // for (; v < end; ++v) {  /* set all not provided arguments to nil */\n                //     var_setnil(v);\n                // }\n                // if (proto->varg) {  /* there are vararg at the last argument, build the list */\n                //     /* code below uses mostly low-level calls for performance */\n                //     be_stack_require(vm, argc + 2);   /* make sure we don't overflow the stack */\n                //     bvalue *top_save = vm->top;  /* save original stack, we need fresh slots to create the 'list' instance */\n                //     vm->top = v;  /* move top of stack right after last argument */\n                //     be_newobject(vm, \"list\");  /* this creates 2 objects on stack: list instance, BE_LIST object */\n                //     blist *list = var_toobj(vm->top-1);  /* get low-level BE_LIST structure */\n                //     v = reg + proto->argc - 1;  /* last argument */\n                //     for (; v < reg + argc; v++) {\n                //         be_list_push(vm, list, v); /* push all varargs into list */       \n                //     }\n                //     *(reg + proto->argc - 1) = *(vm->top-2);  /* change the vararg argument to now contain the list instance */\n                //     vm->top = top_save;  /* restore top of stack pointer */\n                // }\n                prep_closure(vm, var, argc, mode);\n                reg = vm->reg;  /* `reg` has changed, now new base register */\n                goto newframe;  /* continue execution of the closure */\n            }\n            case BE_NTVCLOS: {\n                bntvclos *f = var_toobj(var);\n                push_native(vm, var, argc, mode);\n                f->f(vm); /* call C primitive function */\n                ret_native(vm);\n                break;\n            }\n            case BE_NTVFUNC: {\n                bntvfunc f = var_tontvfunc(var);\n                push_native(vm, var, argc, mode);\n                f(vm); /* call C primitive function */\n                ret_native(vm);\n                break;\n            }\n            case BE_MODULE: {\n                bvalue attr;\n                var_setstr(&attr, str_literal(vm, \"()\"));\n                module_attribute(vm, var, &attr, var);  /* exception if not found */\n                goto recall; /* call '()' method */\n                break;\n            }\n            default:\n                call_error(vm, var);\n            }\n            reg = vm->reg;\n            dispatch();\n        }\n        opcase(RET): {\n            bcallframe *cf;\n            bvalue *ret;\n#if BE_USE_DEBUG_HOOK\n            be_callhook(vm, BE_HOOK_RET);\n#endif\n            cf = vm->cf;\n            ret = vm->cf->func;\n            /* copy return value */\n            if (IGET_RA(ins)) {\n                *ret = *RKB();\n            } else {\n                var_setnil(ret);\n            }\n            vm->reg = cf->reg;\n            vm->top = cf->top;\n            vm->ip = cf->ip;\n            be_stack_pop(&vm->callstack); /* pop don't delete */\n            if (cf->status & BASE_FRAME) { /* entrance function */\n                bstack *cs = &vm->callstack;\n                if (!be_stack_isempty(cs)) {\n                    vm->cf = be_stack_top(cs);\n                }\n                return;\n            }\n            vm->cf = be_stack_top(&vm->callstack);\n            goto newframe;\n        }\n    }\n}",
        "begin_line": 470,
        "end_line": 1099,
        "is_bug": true
    },
    {
        "name": "be_vm.prep_closure#1101",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.prep_closure(bvm *vm, bvalue *reg, int argc, int mode)",
        "snippet": "static void prep_closure(bvm *vm, bvalue *reg, int argc, int mode)\n{\n    bvalue *v, *end;\n    bproto *proto = var2cl(reg)->proto;\n    push_closure(vm, reg, proto->nstack, mode);\n    v = vm->reg + argc;\n    end = vm->reg + proto->argc;\n    for (; v <= end; ++v) {\n        var_setnil(v);\n    }\n    if (proto->varg) {  /* there are vararg at the last argument, build the list */\n        /* code below uses mostly low-level calls for performance */\n        be_stack_require(vm, argc + 2);   /* make sure we don't overflow the stack */\n        bvalue *top_save = vm->top;  /* save original stack, we need fresh slots to create the 'list' instance */\n        vm->top = v;  /* move top of stack right after last argument */\n        be_newobject(vm, \"list\");  /* this creates 2 objects on stack: list instance, BE_LIST object */\n        blist *list = var_toobj(vm->top-1);  /* get low-level BE_LIST structure */\n        v = vm->reg + proto->argc - 1;  /* last argument */\n        for (; v < vm->reg + argc; v++) {\n            be_list_push(vm, list, v); /* push all varargs into list */       \n        }\n        *(vm->reg + proto->argc - 1) = *(vm->top-2);  /* change the vararg argument to now contain the list instance */\n        vm->top = top_save;  /* restore top of stack pointer */\n    }\n}",
        "begin_line": 1101,
        "end_line": 1125,
        "is_bug": false
    },
    {
        "name": "be_vm.do_closure#1127",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.do_closure(bvm *vm, bvalue *reg, int argc)",
        "snippet": "static void do_closure(bvm *vm, bvalue *reg, int argc)\n{\n    // bvalue *v, *end;\n    // bproto *proto = var2cl(reg)->proto;\n    // push_closure(vm, reg, proto->nstack, 0);\n    // v = vm->reg + argc;\n    // end = vm->reg + proto->argc;\n    // for (; v <= end; ++v) {\n    //     var_setnil(v);\n    // }\n    prep_closure(vm, reg, argc, 0);\n    vm_exec(vm);\n}",
        "begin_line": 1127,
        "end_line": 1139,
        "is_bug": false
    },
    {
        "name": "be_vm.do_ntvclos#1141",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.do_ntvclos(bvm *vm, bvalue *reg, int argc)",
        "snippet": "static void do_ntvclos(bvm *vm, bvalue *reg, int argc)\n{\n    bntvclos *f = var_toobj(reg);\n    push_native(vm, reg, argc, 0);\n    f->f(vm); /* call C primitive function */\n    ret_native(vm);\n}",
        "begin_line": 1141,
        "end_line": 1147,
        "is_bug": false
    },
    {
        "name": "be_vm.do_ntvfunc#1149",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.do_ntvfunc(bvm *vm, bvalue *reg, int argc)",
        "snippet": "static void do_ntvfunc(bvm *vm, bvalue *reg, int argc)\n{\n    bntvfunc f = var_tontvfunc(reg);\n    push_native(vm, reg, argc, 0);\n    f(vm); /* call C primitive function */\n    ret_native(vm);\n}",
        "begin_line": 1149,
        "end_line": 1155,
        "is_bug": false
    },
    {
        "name": "be_vm.do_class#1157",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.do_class(bvm *vm, bvalue *reg, int argc)",
        "snippet": "static void do_class(bvm *vm, bvalue *reg, int argc)\n{\n    if (be_class_newobj(vm, var_toobj(reg), reg, ++argc, 0)) {\n        be_incrtop(vm);\n        be_dofunc(vm, reg + 1, argc);\n        be_stackpop(vm, 1);\n    }\n}",
        "begin_line": 1157,
        "end_line": 1164,
        "is_bug": false
    },
    {
        "name": "be_vm.be_dofunc#1166",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.be_dofunc(bvm *vm, bvalue *v, int argc)",
        "snippet": "void be_dofunc(bvm *vm, bvalue *v, int argc)\n{\n    be_assert(vm->reg <= v && v < vm->stacktop);\n    be_assert(vm->stack <= vm->reg && vm->reg < vm->stacktop);\n    switch (var_type(v)) {\n    case BE_CLASS: do_class(vm, v, argc); break;\n    case BE_CLOSURE: do_closure(vm, v, argc); break;\n    case BE_NTVCLOS: do_ntvclos(vm, v, argc); break;\n    case BE_NTVFUNC: do_ntvfunc(vm, v, argc); break;\n    default: call_error(vm, v);\n    }\n}",
        "begin_line": 1166,
        "end_line": 1177,
        "is_bug": false
    },
    {
        "name": "be_vm.be_set_obs_hook#1179",
        "src_path": "src/be_vm.c",
        "class_name": "be_vm",
        "signature": "be_vm.be_set_obs_hook(bvm *vm, bobshook hook)",
        "snippet": "BERRY_API void be_set_obs_hook(bvm *vm, bobshook hook)\n{\n    (void)vm;       /* avoid comiler warning */\n    (void)hook;     /* avoid comiler warning */\n\n#if BE_USE_OBSERVABILITY_HOOK\n    vm->obshook = hook;\n#endif\n}",
        "begin_line": 1179,
        "end_line": 1187,
        "is_bug": false
    },
    {
        "name": "be_class.be_newclass#24",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.be_newclass(bvm *vm, bstring *name, bclass *super)",
        "snippet": "bclass* be_newclass(bvm *vm, bstring *name, bclass *super)\n{\n    bgcobject *gco = be_gcnew(vm, BE_CLASS, bclass);\n    bclass *obj = cast_class(gco);\n    bvalue *buf = be_incrtop(vm); /* protect new objects from GC */\n    var_setclass(buf, obj);\n    if (obj) {\n        obj->super = super;\n        obj->members = NULL; /* gc protection */\n        obj->nvar = 0;\n        obj->name = name;\n    }\n    be_stackpop(vm, 1);\n    return obj;\n}",
        "begin_line": 24,
        "end_line": 38,
        "is_bug": false
    },
    {
        "name": "be_class.be_class_compress#40",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.be_class_compress(bvm *vm, bclass *c)",
        "snippet": "void be_class_compress(bvm *vm, bclass *c)\n{\n    if (!gc_isconst(c) && c->members) {\n        be_map_release(vm, c->members); /* clear space */\n    }\n}",
        "begin_line": 40,
        "end_line": 45,
        "is_bug": false
    },
    {
        "name": "be_class.be_class_attribute#47",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.be_class_attribute(bvm *vm, bclass *c, bstring *attr)",
        "snippet": "int be_class_attribute(bvm *vm, bclass *c, bstring *attr)\n{\n    for (; c; c = c->super) {\n        if (c->members) {\n            bvalue *v = be_map_findstr(vm, c->members, attr);\n            if (v) {\n                return var_type(v);\n            }\n        }\n    }\n    return BE_NONE;\n}",
        "begin_line": 47,
        "end_line": 58,
        "is_bug": false
    },
    {
        "name": "be_class.be_member_bind#60",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.be_member_bind(bvm *vm, bclass *c, bstring *name, bbool var)",
        "snippet": "void be_member_bind(bvm *vm, bclass *c, bstring *name, bbool var)\n{\n    bvalue *attr;\n    set_fixed(name);\n    check_members(vm, c);\n    attr = be_map_insertstr(vm, c->members, name, NULL);\n    restore_fixed(name);\n    if (var) {\n        /* this is an instance variable so we set it as MT_VARIABLE */\n        attr->v.i = c->nvar++;\n        attr->type = MT_VARIABLE;\n    } else {\n        /* this is a static class constant, leave it as BE_NIL */\n        attr->v.i = 0;\n        attr->type = BE_NIL;\n    }\n}",
        "begin_line": 60,
        "end_line": 76,
        "is_bug": false
    },
    {
        "name": "be_class.be_method_bind#78",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.be_method_bind(bvm *vm, bclass *c, bstring *name, bproto *p)",
        "snippet": "void be_method_bind(bvm *vm, bclass *c, bstring *name, bproto *p)\n{\n    bclosure *cl;\n    bvalue *attr;\n    set_fixed(name);\n    check_members(vm, c);\n    attr = be_map_insertstr(vm, c->members, name, NULL);\n    restore_fixed(name);\n    var_setnil(attr);\n    cl = be_newclosure(vm, p->nupvals);\n    cl->proto = p;\n    var_setclosure(attr, cl);\n}",
        "begin_line": 78,
        "end_line": 90,
        "is_bug": false
    },
    {
        "name": "be_class.be_prim_method_bind#92",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.be_prim_method_bind(bvm *vm, bclass *c, bstring *name, bntvfunc f)",
        "snippet": "void be_prim_method_bind(bvm *vm, bclass *c, bstring *name, bntvfunc f)\n{\n    bvalue *attr;\n    set_fixed(name);\n    check_members(vm, c);\n    attr = be_map_insertstr(vm, c->members, name, NULL);\n    restore_fixed(name);\n    attr->v.nf = f;\n    attr->type = MT_PRIMMETHOD;\n}",
        "begin_line": 92,
        "end_line": 101,
        "is_bug": false
    },
    {
        "name": "be_class.be_closure_method_bind#103",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.be_closure_method_bind(bvm *vm, bclass *c, bstring *name, bclosure *cl)",
        "snippet": "void be_closure_method_bind(bvm *vm, bclass *c, bstring *name, bclosure *cl)\n{\n    bvalue *attr;\n    check_members(vm, c);\n    attr = be_map_insertstr(vm, c->members, name, NULL);\n    attr->v.gc = (bgcobject*) cl;\n    attr->type = MT_METHOD;\n}",
        "begin_line": 103,
        "end_line": 110,
        "is_bug": false
    },
    {
        "name": "be_class.be_class_closure_count#113",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.be_class_closure_count(bclass *c)",
        "snippet": "int be_class_closure_count(bclass *c)\n{\n    int count = 0;\n    if (c->members) {\n        bmapnode *node;\n        bmap *members = c->members;\n        bmapiter iter = be_map_iter();\n        while ((node = be_map_next(members, &iter)) != NULL) {\n            if (var_isproto(&node->value)) {\n                ++count;\n            }\n        }\n    }\n    return count;\n}",
        "begin_line": 113,
        "end_line": 127,
        "is_bug": false
    },
    {
        "name": "be_class.instance_member#129",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.instance_member(bvm *vm, binstance *obj, bstring *name, bvalue *dst)",
        "snippet": "static binstance* instance_member(bvm *vm,\n    binstance *obj, bstring *name, bvalue *dst)\n{\n    for (; obj; obj = obj->super) {\n        bmap *members = obj->_class->members;\n        if (members) {\n            bvalue *v = be_map_findstr(vm, members, name);\n            if (v) {\n                *dst = *v;\n                return obj;\n            }\n        }\n    }\n    var_setnil(dst);\n    return NULL;\n}",
        "begin_line": 129,
        "end_line": 144,
        "is_bug": false
    },
    {
        "name": "be_class.class_member#146",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.class_member(bvm *vm, bclass *obj, bstring *name, bvalue *dst)",
        "snippet": "static bclass* class_member(bvm *vm,\n    bclass *obj, bstring *name, bvalue *dst)\n{\n    for (; obj; obj = obj->super) {\n        bmap *members = obj->members;\n        if (members) {\n            bvalue *v = be_map_findstr(vm, members, name);\n            if (v) {\n                *dst = *v;\n                return obj;\n            }\n        }\n    }\n    var_setnil(dst);\n    return NULL;\n}",
        "begin_line": 146,
        "end_line": 161,
        "is_bug": false
    },
    {
        "name": "be_class.be_class_upvalue_init#163",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.be_class_upvalue_init(bvm *vm, bclass *c)",
        "snippet": "void be_class_upvalue_init(bvm *vm, bclass *c)\n{\n    bmap *mbr = c->members;\n    if (mbr != NULL) {\n        bmapnode *node;\n        bmapiter iter = be_map_iter();\n        while ((node = be_map_next(mbr, &iter)) != NULL) {\n            if (var_isclosure(&node->value)) {\n                bclosure *cl = var_toobj(&node->value);\n                if (cl->proto->nupvals) {\n                    /* initialize the closure's upvalues */\n                    be_release_upvalues(vm, cl);\n                    be_initupvals(vm, cl);\n                }\n            }\n        }\n    }\n}",
        "begin_line": 163,
        "end_line": 180,
        "is_bug": false
    },
    {
        "name": "be_class.newobjself#183",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.newobjself(bvm *vm, bclass *c)",
        "snippet": "static binstance* newobjself(bvm *vm, bclass *c)\n{\n    size_t size = sizeof(binstance) + sizeof(bvalue) * (c->nvar - 1);\n    bgcobject *gco = be_newgcobj(vm, BE_INSTANCE, size);\n    binstance *obj = cast_instance(gco);\n    be_assert(obj != NULL);\n    if (obj) { /* initialize members */\n        bvalue *v = obj->members, *end = v + c->nvar;  /* instance variables is a simple array of pointers at obj->members of size c->nvar */\n        while (v < end) { var_setnil(v); ++v; }  /* Initialize all instance variables to `nil` */\n        obj->_class = c;  /* set its class object */\n        obj->super = NULL;  /* no super class instance for now */\n        obj->sub = NULL;  /* no subclass instance for now */\n    }\n    return obj;\n}",
        "begin_line": 183,
        "end_line": 197,
        "is_bug": false
    },
    {
        "name": "be_class.newobject#201",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.newobject(bvm *vm, bclass *c)",
        "snippet": "static binstance* newobject(bvm *vm, bclass *c)\n{\n    binstance *obj, *prev;\n    be_assert(c != NULL);\n    obj = prev = newobjself(vm, c);\n    var_setinstance(vm->top, obj);\n    be_incrtop(vm); /* protect new objects from GC */\n    for (c = c->super; c; c = c->super) {  /* initialize one instance object per class and per superclass */\n        prev->super = newobjself(vm, c);\n        prev->super->sub = prev;  /* link the super/sub classes instances */\n        prev = prev->super;\n    }\n    be_stackpop(vm, 1);\n    return obj;\n}",
        "begin_line": 201,
        "end_line": 215,
        "is_bug": false
    },
    {
        "name": "be_class.be_class_newobj#220",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.be_class_newobj(bvm *vm, bclass *c, bvalue *reg, int argc, int mode)",
        "snippet": "bbool be_class_newobj(bvm *vm, bclass *c, bvalue *reg, int argc, int mode)\n{\n    bvalue init;\n    size_t pos = reg - vm->reg;\n    binstance *obj = newobject(vm, c);  /* create empty object hierarchy from class hierarchy */\n    reg = vm->reg + pos - mode; /* the stack may have changed, mode=1 when class is instanciated from module #104 */\n    var_setinstance(reg, obj);\n    var_setinstance(reg + mode, obj);  /* copy to reg and reg+1 if mode==1 */\n    /* find constructor */\n    obj = instance_member(vm, obj, str_literal(vm, \"init\"), &init);\n    if (obj && var_type(&init) != MT_VARIABLE) {\n        /* copy argv */\n        for (reg = vm->reg + pos + 1; argc > 0; --argc) {\n            reg[argc] = reg[argc - 2];\n        }\n        *reg = init; /* set constructor */\n        return btrue;\n    }\n    return bfalse;\n}",
        "begin_line": 220,
        "end_line": 239,
        "is_bug": false
    },
    {
        "name": "be_class.default_init_native_method#242",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.default_init_native_method(bvm *vm)",
        "snippet": "static int default_init_native_method(bvm *vm) {\n    be_return_nil(vm);\n}",
        "begin_line": 242,
        "end_line": 244,
        "is_bug": false
    },
    {
        "name": "be_class.be_instance_member_simple#248",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.be_instance_member_simple(bvm *vm, binstance *instance, bstring *name, bvalue *dst)",
        "snippet": "int be_instance_member_simple(bvm *vm, binstance *instance, bstring *name, bvalue *dst)\n{\n    int type;\n    be_assert(name != NULL);\n    binstance * obj = instance_member(vm, instance, name, dst);\n    type = var_type(dst);\n    if (obj && type == MT_VARIABLE) {\n        *dst = obj->members[dst->v.i];\n    }\n    return type;\n}",
        "begin_line": 248,
        "end_line": 258,
        "is_bug": false
    },
    {
        "name": "be_class.be_instance_member#264",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.be_instance_member(bvm *vm, binstance *instance, bstring *name, bvalue *dst)",
        "snippet": "int be_instance_member(bvm *vm, binstance *instance, bstring *name, bvalue *dst)\n{\n    int type;\n    be_assert(name != NULL);\n    binstance * obj = instance_member(vm, instance, name, dst);\n    type = var_type(dst);\n    if (obj && type == MT_VARIABLE) {\n        *dst = obj->members[dst->v.i];\n    }\n    if (obj) {\n        return type;\n    } else {  /* if no method found, try virtual */\n        /* if 'init' does not exist, create a virtual empty constructor */\n        if (strcmp(str(name), \"init\") == 0) {\n            var_setntvfunc(dst, default_init_native_method);\n            return var_type(dst);\n        } else {\n            /* get method 'member' */\n            obj = instance_member(vm, instance, str_literal(vm, \"member\"), vm->top);\n            if (obj && basetype(var_type(vm->top)) == BE_FUNCTION) {\n                bvalue *top = vm->top;\n                var_setinstance(&top[1], instance);\n                var_setstr(&top[2], name);\n                vm->top += 3;   /* prevent gc collection results */\n                be_dofunc(vm, top, 2); /* call method 'member' */\n                vm->top -= 3;\n                *dst = *vm->top;   /* copy result to R(A) */\n                if (obj && var_type(dst) == MT_VARIABLE) {\n                    *dst = obj->members[dst->v.i];\n                }\n                type = var_type(dst);\n                if (type != BE_NIL) {\n                    return type;\n                }\n            }\n        }\n    }\n    return BE_NONE;\n}",
        "begin_line": 264,
        "end_line": 302,
        "is_bug": false
    },
    {
        "name": "be_class.be_class_member#304",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.be_class_member(bvm *vm, bclass *obj, bstring *name, bvalue *dst)",
        "snippet": "int be_class_member(bvm *vm, bclass *obj, bstring *name, bvalue *dst)\n{\n    int type;\n    be_assert(name != NULL);\n    obj = class_member(vm, obj, name, dst);\n    type = var_type(dst);\n    if (obj) {\n        return type;\n    } else {\n        return BE_NONE;\n    }\n}",
        "begin_line": 304,
        "end_line": 315,
        "is_bug": false
    },
    {
        "name": "be_class.be_instance_setmember#317",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.be_instance_setmember(bvm *vm, binstance *o, bstring *name, bvalue *src)",
        "snippet": "bbool be_instance_setmember(bvm *vm, binstance *o, bstring *name, bvalue *src)\n{\n    bvalue v;\n    be_assert(name != NULL);\n    binstance * obj = instance_member(vm, o, name, &v);\n    if (obj && var_istype(&v, MT_VARIABLE)) {\n        obj->members[var_toint(&v)] = *src;\n        return btrue;\n    } else {\n        obj = instance_member(vm, o, str_literal(vm, \"setmember\"), &v);\n        if (obj && var_type(&v) == MT_VARIABLE) {\n            v = obj->members[v.v.i];\n        }\n        if (var_basetype(&v) == BE_FUNCTION) {\n            bvalue *top = vm->top;\n            var_setval(top, &v);\n            var_setinstance(top + 1, o); /* move instance to argv[0] */\n            var_setstr(top + 2, name); /* move method name to argv[1] */\n            var_setval(top + 3, src); /* move method name to argv[1] */\n            vm->top += 4;   /* prevent collection results */\n            be_dofunc(vm, top, 3); /* call method 'member' */\n            vm->top -= 4;\n            return var_tobool(top);\n        }\n    }\n    return bfalse;\n}",
        "begin_line": 317,
        "end_line": 343,
        "is_bug": false
    },
    {
        "name": "be_class.be_class_setmember#345",
        "src_path": "src/be_class.c",
        "class_name": "be_class",
        "signature": "be_class.be_class_setmember(bvm *vm, bclass *o, bstring *name, bvalue *src)",
        "snippet": "bbool be_class_setmember(bvm *vm, bclass *o, bstring *name, bvalue *src)\n{\n    bvalue v;\n    be_assert(name != NULL);\n    bclass * obj = class_member(vm, o, name, &v);\n    if (obj && !var_istype(&v, MT_VARIABLE)) {\n        be_map_insertstr(vm, obj->members, name, src);\n        return btrue;\n    }\n    return bfalse;\n}",
        "begin_line": 345,
        "end_line": 355,
        "is_bug": false
    },
    {
        "name": "be_exec.be_throw#75",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.be_throw(bvm *vm, int errorcode)",
        "snippet": "void be_throw(bvm *vm, int errorcode)\n{\n    if (vm->errjmp) {\n        vm->errjmp->status = errorcode;\n        exec_throw(vm->errjmp);\n    } else {\n        _os_abort();\n    }\n}",
        "begin_line": 75,
        "end_line": 83,
        "is_bug": false
    },
    {
        "name": "be_exec.be_exit#87",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.be_exit(bvm *vm, int status)",
        "snippet": "BERRY_API void be_exit(bvm *vm, int status)\n{\n    if (vm->errjmp) {\n        be_pushint(vm, status);\n        be_pop(vm, 1);\n        be_throw(vm, BE_EXIT);\n    } else {\n        _os_exit(status);\n    }\n}",
        "begin_line": 87,
        "end_line": 96,
        "is_bug": false
    },
    {
        "name": "be_exec.be_throw_message#98",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.be_throw_message(bvm *vm, int errorcode, const char *msg)",
        "snippet": "void be_throw_message(bvm *vm, int errorcode, const char *msg)\n{\n    be_pushstring(vm, msg);\n    be_throw(vm, errorcode);\n}",
        "begin_line": 98,
        "end_line": 102,
        "is_bug": false
    },
    {
        "name": "be_exec.be_execprotected#106",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.be_execprotected(bvm *vm, bpfunc f, void *data)",
        "snippet": "int be_execprotected(bvm *vm, bpfunc f, void *data)\n{\n    struct blongjmp jmp;\n    jmp.status = 0;\n    jmp.prev = vm->errjmp; /* save long jump position */\n    vm->errjmp = &jmp;\n    exec_try(vm->errjmp) {\n        f(vm, data);\n    }\n    vm->errjmp = jmp.prev; /* restore long jump position */\n    return jmp.status;\n}",
        "begin_line": 106,
        "end_line": 117,
        "is_bug": false
    },
    {
        "name": "be_exec.vm_state_save#119",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.vm_state_save(bvm *vm, struct vmstate *state)",
        "snippet": "static void vm_state_save(bvm *vm, struct vmstate *state)\n{\n    state->depth = be_stack_count(&vm->callstack);\n    state->top = cast_int(vm->top - vm->stack);\n    state->reg = cast_int(vm->reg - vm->stack);\n}",
        "begin_line": 119,
        "end_line": 124,
        "is_bug": false
    },
    {
        "name": "be_exec.copy_exception#126",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.copy_exception(bvm *vm, int res, int dstindex)",
        "snippet": "static void copy_exception(bvm *vm, int res, int dstindex)\n{\n    bvalue *dst = vm->stack + dstindex;\n    if (res == BE_EXCEPTION || res == BE_EXIT) {\n        bvalue *src = vm->top;\n        *dst++ = *src++;\n        if (res == BE_EXCEPTION) {\n            *dst++ = *src++;\n        }\n    }\n    vm->top = dst;\n}",
        "begin_line": 126,
        "end_line": 137,
        "is_bug": false
    },
    {
        "name": "be_exec.vm_state_restore#139",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.vm_state_restore(bvm *vm, const struct vmstate *state, int res)",
        "snippet": "static void vm_state_restore(bvm *vm, const struct vmstate *state, int res)\n{\n    vm->reg = vm->stack + state->reg;\n    /* copy exception information to top */\n    copy_exception(vm, res, state->top);\n    be_assert(be_stack_count(&vm->callstack) >= state->depth);\n    if (be_stack_count(&vm->callstack) > state->depth) {\n        be_vector_resize(vm, &vm->callstack, state->depth);\n        vm->cf = be_stack_top(&vm->callstack);\n    }\n}",
        "begin_line": 139,
        "end_line": 149,
        "is_bug": false
    },
    {
        "name": "be_exec.be_loadmode#254",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.be_loadmode(bvm *vm, const char *name, bbool islocal)",
        "snippet": "BERRY_API int be_loadmode(bvm *vm, const char *name, bbool islocal)\n{\n    int res = load_bytecode(vm, name);\n#if BE_USE_SCRIPT_COMPILER\n    if (res && res != BE_IO_ERROR) {\n        res = fileparser(vm, name, islocal);\n    }\n#else\n    (void)islocal;\n#endif\n    if (res == BE_IO_ERROR) {\n        be_pushfstring(vm, \"cannot open file '%s'.\", name);\n    }\n    return res;\n}",
        "begin_line": 254,
        "end_line": 268,
        "is_bug": false
    },
    {
        "name": "be_exec.m_pcall#293",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.m_pcall(bvm *vm, void *data)",
        "snippet": "static void m_pcall(bvm *vm, void *data)\n{\n    struct pcall *p = cast(struct pcall*, data);\n    be_dofunc(vm, p->v, p->argc);\n}",
        "begin_line": 293,
        "end_line": 297,
        "is_bug": false
    },
    {
        "name": "be_exec.be_protectedcall#300",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.be_protectedcall(bvm *vm, bvalue *v, int argc)",
        "snippet": "int be_protectedcall(bvm *vm, bvalue *v, int argc)\n{\n    int res;\n    struct pcall s;\n    struct vmstate state;\n    s.v = v;\n    s.argc = argc;\n    vm_state_save(vm, &state);\n    res = be_execprotected(vm, m_pcall, &s);\n    if (res) { /* restore call stack */\n        vm_state_restore(vm, &state, res);\n    }\n    return res;\n}",
        "begin_line": 300,
        "end_line": 313,
        "is_bug": false
    },
    {
        "name": "be_exec.be_stackpush#327",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.be_stackpush(bvm *vm)",
        "snippet": "void be_stackpush(bvm *vm)\n{\n    /* make sure there is enough stack space */\n    be_stack_require(vm, 1 + BE_STACK_FREE_MIN);\n    be_incrtop(vm);\n}",
        "begin_line": 327,
        "end_line": 332,
        "is_bug": false
    },
    {
        "name": "be_exec.be_stack_require#335",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.be_stack_require(bvm *vm, int count)",
        "snippet": "void be_stack_require(bvm *vm, int count)\n{\n    if (vm->top + count >= vm->stacktop) {\n        be_stack_expansion(vm, count);\n    }\n}",
        "begin_line": 335,
        "end_line": 340,
        "is_bug": false
    },
    {
        "name": "be_exec.update_callstack#343",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.update_callstack(bvm *vm, intptr_t offset)",
        "snippet": "static void update_callstack(bvm *vm, intptr_t offset)\n{\n    bcallframe *cf = be_stack_top(&vm->callstack);\n    bcallframe *base = be_stack_base(&vm->callstack);\n    for (; cf >= base; --cf) {\n        fixup_ptr(cf->func, offset);\n        fixup_ptr(cf->top, offset);\n        fixup_ptr(cf->reg, offset);\n    }\n    fixup_ptr(vm->top, offset);\n    fixup_ptr(vm->reg, offset);\n}",
        "begin_line": 343,
        "end_line": 354,
        "is_bug": false
    },
    {
        "name": "be_exec.update_upvalues#356",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.update_upvalues(bvm *vm, intptr_t offset)",
        "snippet": "static void update_upvalues(bvm *vm, intptr_t offset)\n{\n    bupval *node = vm->upvalist;\n    /* update the value referenced by open upvalues */\n    for (; node != NULL; node = node->u.next) {\n        fixup_ptr(node->value, offset);\n    }\n}",
        "begin_line": 356,
        "end_line": 363,
        "is_bug": false
    },
    {
        "name": "be_exec.stack_resize#367",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.stack_resize(bvm *vm, size_t size)",
        "snippet": "static void stack_resize(bvm *vm, size_t size)\n{\n    intptr_t offset;\n    bvalue *old = vm->stack;  /* save original pointer of stack before resize */\n    size_t os = (vm->stacktop - old) * sizeof(bvalue);  /* size of current stack allocated in bytes */\n    vm->stack = be_realloc(vm, old, os, sizeof(bvalue) * size);  /* reallocate with the new size */\n    vm->stacktop = vm->stack + size;  /* compute new stacktop */\n    offset = ptr_offset(vm->stack, old);  /* compute the address difference between old and ne stack addresses */\n    /* update callframes */\n    update_callstack(vm, offset);\n    /* update open upvalues */\n    update_upvalues(vm, offset);\n}",
        "begin_line": 367,
        "end_line": 379,
        "is_bug": false
    },
    {
        "name": "be_exec.be_stack_expansion#384",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.be_stack_expansion(bvm *vm, int n)",
        "snippet": "void be_stack_expansion(bvm *vm, int n)\n{\n    size_t size = vm->stacktop - vm->stack;\n    /* check new stack size */\n    if (size + n > BE_STACK_TOTAL_MAX) {\n        /* ensure the stack is enough when generating error messages. */\n        stack_resize(vm, size + 1);\n        be_raise(vm, \"runtime_error\", STACK_OVER_MSG(BE_STACK_TOTAL_MAX));\n    }\n    stack_resize(vm, size + n);\n}",
        "begin_line": 384,
        "end_line": 394,
        "is_bug": false
    },
    {
        "name": "be_exec.fixup_exceptstack#396",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.fixup_exceptstack(bvm* vm, struct bexecptframe* lbase)",
        "snippet": "static void fixup_exceptstack(bvm* vm, struct bexecptframe* lbase)\n{\n    struct bexecptframe *base = be_stack_base(&vm->exceptstack);\n    if (lbase != base) { /* the address has changed when the stack is expanded */\n        struct bexecptframe *top = be_stack_top(&vm->exceptstack);\n        bbyte *begin = (bbyte*)&lbase->errjmp;\n        bbyte *end = (bbyte*)&(lbase + (top - base))->errjmp;\n        intptr_t offset = ptr_offset(base, lbase);\n        struct blongjmp *errjmp = vm->errjmp;\n        while (errjmp) {\n            bbyte *prev = (bbyte*)errjmp->prev;\n            if (prev >= begin && prev < end) {\n                fixup_ptr(prev, offset); /* fixup the prev pointer */\n                errjmp->prev = (struct blongjmp*)prev;\n            }\n            errjmp = (struct blongjmp*)prev;\n        }\n    }\n}",
        "begin_line": 396,
        "end_line": 414,
        "is_bug": false
    },
    {
        "name": "be_exec.be_except_block_setup#418",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.be_except_block_setup(bvm *vm)",
        "snippet": "void be_except_block_setup(bvm *vm)\n{\n    struct bexecptframe *frame;\n    struct bexecptframe *lbase = be_stack_base(&vm->exceptstack);\n    be_stack_push(vm, &vm->exceptstack, NULL);\n    frame = be_stack_top(&vm->exceptstack);\n    frame->depth = be_stack_count(&vm->callstack); /* the call stack depth */\n    frame->ip = vm->ip; /* OP_EXBLK's next instruction pointer */\n    /* set longjmp() jump point */\n    frame->errjmp.status = 0;\n    frame->errjmp.prev = vm->errjmp; /* save long jump list */\n    vm->errjmp = &frame->errjmp;\n    fixup_exceptstack(vm, lbase);\n}",
        "begin_line": 418,
        "end_line": 431,
        "is_bug": false
    },
    {
        "name": "be_exec.be_except_block_resume#434",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.be_except_block_resume(bvm *vm)",
        "snippet": "void be_except_block_resume(bvm *vm)\n{\n    int errorcode = vm->errjmp->status;\n    struct bexecptframe *frame = be_stack_top(&vm->exceptstack);\n    if (errorcode == BE_EXCEPTION) {\n        vm->errjmp = vm->errjmp->prev;\n        /* jump to except instruction */\n        vm->ip = frame->ip + IGET_sBx(frame->ip[-1]);\n        if (be_stack_count(&vm->callstack) > frame->depth) {\n            bvalue *top = vm->top;\n            bcallframe *cf = be_vector_at(&vm->callstack, frame->depth);\n            vm->top = cf->top;\n            vm->reg = cf->reg;\n            vm->cf = frame->depth ? cf - 1 : NULL;\n            be_vector_resize(vm, &vm->callstack, frame->depth);\n            /* copy the exception value and argument to the top of\n             * the current function */\n            vm->top[0] = top[0]; /* exception value */\n            vm->top[1] = top[1]; /* exception argument */\n        }\n        be_stack_pop(&vm->exceptstack);\n    } else { /* other errors cannot be catch by the except block */\n        /* find the next error handling location */\n        while (vm->errjmp == &frame->errjmp) {\n            vm->errjmp = vm->errjmp->prev;\n            be_stack_pop(&vm->exceptstack);\n            frame = be_stack_top(&vm->exceptstack);\n        }\n        be_throw(vm, errorcode); /* rethrow this exception */\n    }\n}",
        "begin_line": 434,
        "end_line": 464,
        "is_bug": false
    },
    {
        "name": "be_exec.be_except_block_close#467",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.be_except_block_close(bvm *vm, int count)",
        "snippet": "void be_except_block_close(bvm *vm, int count)\n{\n    struct bexecptframe *frame;\n    int size = be_stack_count(&vm->exceptstack);\n    be_assert(count > 0 && count <= size);\n    frame = be_vector_at(&vm->exceptstack, size - count);\n    vm->errjmp = frame->errjmp.prev;\n    be_vector_resize(vm, &vm->exceptstack, size - count);\n}",
        "begin_line": 467,
        "end_line": 475,
        "is_bug": false
    },
    {
        "name": "be_exec.be_save_stacktrace#477",
        "src_path": "src/be_exec.c",
        "class_name": "be_exec",
        "signature": "be_exec.be_save_stacktrace(bvm *vm)",
        "snippet": "void be_save_stacktrace(bvm *vm)\n{\n    bstack *stack = &vm->tracestack;\n    be_stack_clear(stack);\n    if (be_stack_count(&vm->callstack)) {\n        bcallframe *cf;\n        bcallframe *base = be_stack_base(&vm->callstack);\n        bcallframe *top = be_stack_top(&vm->callstack);\n        for (cf = base; cf <= top; ++cf) {\n            bcallsnapshot *st;\n            be_stack_push(vm, stack, NULL);\n            st = be_stack_top(stack);\n            st->func = *cf->func;\n            st->ip = cf == top ? vm->ip : cf[1].ip;\n        }\n    }\n}",
        "begin_line": 477,
        "end_line": 493,
        "is_bug": false
    }
]