[
    {
        "name": "jerry-core.api.jerryscript.jerry_current_realm#1079",
        "src_path": "jerry-core/api/jerryscript.c",
        "class_name": "jerry-core.api.jerryscript",
        "signature": "jerry-core.api.jerryscript.jerry_current_realm (void)",
        "snippet": "jerry_value_t\njerry_current_realm (void)\n{\n  jerry_assert_api_enabled ();\n  ecma_object_t *global_obj_p = ecma_builtin_get_global ();\n  ecma_ref_object (global_obj_p);\n  return ecma_make_object_value (global_obj_p);\n}",
        "begin_line": 1079,
        "end_line": 1086,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerryscript.jerry_function_external#2480",
        "src_path": "jerry-core/api/jerryscript.c",
        "class_name": "jerry-core.api.jerryscript",
        "signature": "jerry-core.api.jerryscript.jerry_function_external (jerry_external_handler_t handler) /**< native handler                                                             *   for the function */",
        "snippet": "jerry_value_t\njerry_function_external (jerry_external_handler_t handler) /**< native handler\n                                                            *   for the function */\n{\n  jerry_assert_api_enabled ();\n\n  ecma_object_t *func_obj_p = ecma_op_create_external_function_object (handler);\n  return ecma_make_object_value (func_obj_p);\n}",
        "begin_line": 2480,
        "end_line": 2488,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerryscript.jerry_init#166",
        "src_path": "jerry-core/api/jerryscript.c",
        "class_name": "jerry-core.api.jerryscript",
        "signature": "jerry-core.api.jerryscript.jerry_init (jerry_init_flag_t flags) /**< combination of Jerry flags */",
        "snippet": "void\njerry_init (jerry_init_flag_t flags) /**< combination of Jerry flags */\n{\n  /* This function cannot be called twice unless jerry_cleanup is called. */\n  JERRY_ASSERT (!(JERRY_CONTEXT (status_flags) & ECMA_STATUS_API_ENABLED));\n\n  /* Zero out all non-external members. */\n  memset ((char *) &JERRY_CONTEXT_STRUCT + offsetof (jerry_context_t, JERRY_CONTEXT_FIRST_MEMBER),\n          0,\n          sizeof (jerry_context_t) - offsetof (jerry_context_t, JERRY_CONTEXT_FIRST_MEMBER));\n\n  JERRY_CONTEXT (jerry_init_flags) = flags;\n\n  jerry_api_enable ();\n\n  jmem_init ();\n  ecma_init ();\n}",
        "begin_line": 166,
        "end_line": 183,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerryscript.jerry_object_set#3515",
        "src_path": "jerry-core/api/jerryscript.c",
        "class_name": "jerry-core.api.jerryscript",
        "signature": "jerry-core.api.jerryscript.jerry_object_set (const jerry_value_t object, /**< object value */                   const jerry_value_t key, /**< property name (string value) */                   const jerry_value_t value) /**< value to set */",
        "snippet": "jerry_value_t\njerry_object_set (const jerry_value_t object, /**< object value */\n                  const jerry_value_t key, /**< property name (string value) */\n                  const jerry_value_t value) /**< value to set */\n{\n  jerry_assert_api_enabled ();\n\n  if (ecma_is_value_exception (value) || !ecma_is_value_object (object) || !ecma_is_value_prop_name (key))\n  {\n    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));\n  }\n\n  return jerry_return (\n    ecma_op_object_put (ecma_get_object_from_value (object), ecma_get_prop_name_from_value (key), value, true));\n}",
        "begin_line": 3515,
        "end_line": 3529,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerryscript.jerry_parse#456",
        "src_path": "jerry-core/api/jerryscript.c",
        "class_name": "jerry-core.api.jerryscript",
        "signature": "jerry-core.api.jerryscript.jerry_parse (const jerry_char_t *source_p, /**< script source */              size_t source_size, /**< script source size */              const jerry_parse_options_t *options_p) /**< parsing options, can be NULL if not used */",
        "snippet": "jerry_value_t\njerry_parse (const jerry_char_t *source_p, /**< script source */\n             size_t source_size, /**< script source size */\n             const jerry_parse_options_t *options_p) /**< parsing options, can be NULL if not used */\n{\n#if JERRY_PARSER\n  parser_source_char_t source_char;\n  source_char.source_p = source_p;\n  source_char.source_size = source_size;\n\n  return jerry_parse_common ((void *) &source_char, options_p, JERRY_PARSE_NO_OPTS);\n#else /* !JERRY_PARSER */\n  JERRY_UNUSED (source_p);\n  JERRY_UNUSED (source_size);\n  JERRY_UNUSED (options_p);\n\n  return jerry_throw_sz (JERRY_ERROR_SYNTAX, ecma_get_error_msg (ECMA_ERR_PARSER_NOT_SUPPORTED));\n#endif /* JERRY_PARSER */\n}",
        "begin_line": 456,
        "end_line": 474,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerryscript.jerry_promise_on_event#4821",
        "src_path": "jerry-core/api/jerryscript.c",
        "class_name": "jerry-core.api.jerryscript",
        "signature": "jerry-core.api.jerryscript.jerry_promise_on_event (jerry_promise_event_filter_t filters, /**< combination of event filters */                         jerry_promise_event_cb_t callback, /**< notification callback */                         void *user_p) /**< user pointer passed to the callback */",
        "snippet": "void\njerry_promise_on_event (jerry_promise_event_filter_t filters, /**< combination of event filters */\n                        jerry_promise_event_cb_t callback, /**< notification callback */\n                        void *user_p) /**< user pointer passed to the callback */\n{\n  jerry_assert_api_enabled ();\n\n#if JERRY_ESNEXT && JERRY_PROMISE_CALLBACK\n  if (filters == JERRY_PROMISE_EVENT_FILTER_DISABLE || callback == NULL)\n  {\n    JERRY_CONTEXT (promise_callback_filters) = JERRY_PROMISE_EVENT_FILTER_DISABLE;\n    return;\n  }\n\n  JERRY_CONTEXT (promise_callback_filters) = (uint32_t) filters;\n  JERRY_CONTEXT (promise_callback) = callback;\n  JERRY_CONTEXT (promise_callback_user_p) = user_p;\n#else /* !JERRY_ESNEXT && !JERRY_PROMISE_CALLBACK */\n  JERRY_UNUSED (filters);\n  JERRY_UNUSED (callback);\n  JERRY_UNUSED (user_p);\n#endif /* JERRY_ESNEXT && JERRY_PROMISE_CALLBACK */\n}",
        "begin_line": 4821,
        "end_line": 4843,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerryscript.jerry_return#152",
        "src_path": "jerry-core/api/jerryscript.c",
        "class_name": "jerry-core.api.jerryscript",
        "signature": "jerry-core.api.jerryscript.jerry_return (const jerry_value_t value) /**< return value */",
        "snippet": "static jerry_value_t\njerry_return (const jerry_value_t value) /**< return value */\n{\n  if (ECMA_IS_VALUE_ERROR (value))\n  {\n    return ecma_create_exception_from_context ();\n  }\n\n  return value;\n}",
        "begin_line": 152,
        "end_line": 161,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerryscript.jerry_run#510",
        "src_path": "jerry-core/api/jerryscript.c",
        "class_name": "jerry-core.api.jerryscript",
        "signature": "jerry-core.api.jerryscript.jerry_run (const jerry_value_t script) /**< script or module to run */",
        "snippet": "jerry_value_t\njerry_run (const jerry_value_t script) /**< script or module to run */\n{\n  jerry_assert_api_enabled ();\n\n  if (!ecma_is_value_object (script))\n  {\n    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));\n  }\n\n  ecma_object_t *object_p = ecma_get_object_from_value (script);\n\n  if (!ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_SCRIPT))\n  {\n    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));\n  }\n\n  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n  const ecma_compiled_code_t *bytecode_data_p;\n  bytecode_data_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, ext_object_p->u.cls.u3.value);\n\n  JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (bytecode_data_p->status_flags) == CBC_FUNCTION_SCRIPT);\n\n  return jerry_return (vm_run_global (bytecode_data_p, object_p));\n}",
        "begin_line": 510,
        "end_line": 535,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerryscript.jerry_string#2700",
        "src_path": "jerry-core/api/jerryscript.c",
        "class_name": "jerry-core.api.jerryscript",
        "signature": "jerry-core.api.jerryscript.jerry_string (const jerry_char_t *buffer_p, /**< pointer to buffer */               jerry_size_t buffer_size, /**< buffer size */               jerry_encoding_t encoding) /**< buffer encoding */",
        "snippet": "jerry_value_t\njerry_string (const jerry_char_t *buffer_p, /**< pointer to buffer */\n              jerry_size_t buffer_size, /**< buffer size */\n              jerry_encoding_t encoding) /**< buffer encoding */\n{\n  jerry_assert_api_enabled ();\n  ecma_string_t *ecma_str_p = NULL;\n  JERRY_ASSERT (jerry_validate_string (buffer_p, buffer_size, encoding));\n\n  switch (encoding)\n  {\n    case JERRY_ENCODING_CESU8:\n    {\n      ecma_str_p = ecma_new_ecma_string_from_utf8 (buffer_p, buffer_size);\n      break;\n    }\n    case JERRY_ENCODING_UTF8:\n    {\n      ecma_str_p = ecma_new_ecma_string_from_utf8_converted_to_cesu8 (buffer_p, buffer_size);\n      break;\n    }\n    default:\n    {\n      return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_INVALID_ENCODING));\n    }\n  }\n\n  return ecma_make_string_value (ecma_str_p);\n}",
        "begin_line": 2700,
        "end_line": 2728,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerryscript.jerry_string_sz#2684",
        "src_path": "jerry-core/api/jerryscript.c",
        "class_name": "jerry-core.api.jerryscript",
        "signature": "jerry-core.api.jerryscript.jerry_string_sz (const char *str_p) /**< pointer to string */",
        "snippet": "jerry_value_t\njerry_string_sz (const char *str_p) /**< pointer to string */\n{\n  const jerry_char_t *data_p = (const jerry_char_t *) str_p;\n  return jerry_string (data_p, lit_zt_utf8_string_size (data_p), JERRY_ENCODING_CESU8);\n}",
        "begin_line": 2684,
        "end_line": 2689,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerryscript.jerry_validate_string#5061",
        "src_path": "jerry-core/api/jerryscript.c",
        "class_name": "jerry-core.api.jerryscript",
        "signature": "jerry-core.api.jerryscript.jerry_validate_string (const jerry_char_t *buffer_p, /**< string buffer */                        jerry_size_t buffer_size, /**< buffer size */                        jerry_encoding_t encoding) /**< buffer encoding */",
        "snippet": "bool\njerry_validate_string (const jerry_char_t *buffer_p, /**< string buffer */\n                       jerry_size_t buffer_size, /**< buffer size */\n                       jerry_encoding_t encoding) /**< buffer encoding */\n{\n  switch (encoding)\n  {\n    case JERRY_ENCODING_CESU8:\n    {\n      return lit_is_valid_cesu8_string (buffer_p, buffer_size);\n    }\n    case JERRY_ENCODING_UTF8:\n    {\n      return lit_is_valid_utf8_string (buffer_p, buffer_size, true);\n    }\n    default:\n    {\n      return false;\n    }\n  }\n}",
        "begin_line": 5061,
        "end_line": 5081,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerryscript.jerry_value_free#2354",
        "src_path": "jerry-core/api/jerryscript.c",
        "class_name": "jerry-core.api.jerryscript",
        "signature": "jerry-core.api.jerryscript.jerry_value_free (jerry_value_t value) /**< value */",
        "snippet": "void\njerry_value_free (jerry_value_t value) /**< value */\n{\n  jerry_assert_api_enabled ();\n\n  if (JERRY_UNLIKELY (ecma_is_value_exception (value)))\n  {\n    ecma_deref_exception (ecma_get_extended_primitive_from_value (value));\n    return;\n  }\n\n  ecma_free_value (value);\n}",
        "begin_line": 2354,
        "end_line": 2366,
        "is_bug": false
    },
    {
        "name": "jerry-core.api.jerryscript.jerry_value_is_exception#1186",
        "src_path": "jerry-core/api/jerryscript.c",
        "class_name": "jerry-core.api.jerryscript",
        "signature": "jerry-core.api.jerryscript.jerry_value_is_exception (const jerry_value_t value) /**< api value */",
        "snippet": "bool\njerry_value_is_exception (const jerry_value_t value) /**< api value */\n{\n  jerry_assert_api_enabled ();\n\n  return ecma_is_value_exception (value);\n}",
        "begin_line": 1186,
        "end_line": 1192,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_free_unused_memory#2292",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_free_unused_memory (jmem_pressure_t pressure) /**< current pressure */",
        "snippet": "void\necma_free_unused_memory (jmem_pressure_t pressure) /**< current pressure */\n{\n#if JERRY_DEBUGGER\n  while ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n         && JERRY_CONTEXT (debugger_byte_code_free_tail) != ECMA_NULL_POINTER)\n  {\n    /* Wait until all byte code is freed or the connection is aborted. */\n    jerry_debugger_receive (NULL);\n  }\n#endif /* JERRY_DEBUGGER */\n\n  if (JERRY_LIKELY (pressure == JMEM_PRESSURE_LOW))\n  {\n#if JERRY_PROPERTY_HASHMAP\n    if (JERRY_CONTEXT (ecma_prop_hashmap_alloc_state) > ECMA_PROP_HASHMAP_ALLOC_ON)\n    {\n      --JERRY_CONTEXT (ecma_prop_hashmap_alloc_state);\n    }\n    JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_HIGH_PRESSURE_GC;\n#endif /* JERRY_PROPERTY_HASHMAP */\n    /*\n     * If there is enough newly allocated objects since last GC, probably it is worthwhile to start GC now.\n     * Otherwise, probability to free sufficient space is considered to be low.\n     */\n    size_t new_objects_fraction = CONFIG_ECMA_GC_NEW_OBJECTS_FRACTION;\n\n    if (JERRY_CONTEXT (ecma_gc_new_objects) * new_objects_fraction > JERRY_CONTEXT (ecma_gc_objects_number))\n    {\n      ecma_gc_run ();\n    }\n\n    return;\n  }\n  else if (pressure == JMEM_PRESSURE_HIGH)\n  {\n    /* Freeing as much memory as we currently can */\n#if JERRY_PROPERTY_HASHMAP\n    if (JERRY_CONTEXT (status_flags) & ECMA_STATUS_HIGH_PRESSURE_GC)\n    {\n      JERRY_CONTEXT (ecma_prop_hashmap_alloc_state) = ECMA_PROP_HASHMAP_ALLOC_MAX;\n    }\n    else if (JERRY_CONTEXT (ecma_prop_hashmap_alloc_state) < ECMA_PROP_HASHMAP_ALLOC_MAX)\n    {\n      ++JERRY_CONTEXT (ecma_prop_hashmap_alloc_state);\n      JERRY_CONTEXT (status_flags) |= ECMA_STATUS_HIGH_PRESSURE_GC;\n    }\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n    ecma_gc_run ();\n\n#if JERRY_PROPERTY_HASHMAP\n    /* Free hashmaps of remaining objects. */\n    jmem_cpointer_t obj_iter_cp = JERRY_CONTEXT (ecma_gc_objects_cp);\n\n    while (obj_iter_cp != JMEM_CP_NULL)\n    {\n      ecma_object_t *obj_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_iter_cp);\n\n      if (!ecma_is_lexical_environment (obj_iter_p)\n          || ecma_get_lex_env_type (obj_iter_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n      {\n        if (!ecma_is_lexical_environment (obj_iter_p) && ecma_op_object_is_fast_array (obj_iter_p))\n        {\n          obj_iter_cp = obj_iter_p->gc_next_cp;\n          continue;\n        }\n\n        jmem_cpointer_t prop_iter_cp = obj_iter_p->u1.property_list_cp;\n\n        if (prop_iter_cp != JMEM_CP_NULL)\n        {\n          ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n\n          if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n          {\n            ecma_property_hashmap_free (obj_iter_p);\n          }\n        }\n      }\n\n      obj_iter_cp = obj_iter_p->gc_next_cp;\n    }\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n    jmem_pools_collect_empty ();\n    return;\n  }\n  else if (JERRY_UNLIKELY (pressure == JMEM_PRESSURE_FULL))\n  {\n    jerry_fatal (ERR_OUT_OF_MEMORY);\n  }\n  else\n  {\n    JERRY_ASSERT (pressure == JMEM_PRESSURE_NONE);\n    JERRY_UNREACHABLE ();\n  }\n}",
        "begin_line": 2292,
        "end_line": 2389,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_gc_mark#817",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_gc_mark (ecma_object_t *object_p) /**< object to mark from */",
        "snippet": "static void\necma_gc_mark (ecma_object_t *object_p) /**< object to mark from */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (ecma_gc_is_object_visited (object_p));\n\n  if (ecma_is_lexical_environment (object_p))\n  {\n    jmem_cpointer_t outer_lex_env_cp = object_p->u2.outer_reference_cp;\n\n    if (outer_lex_env_cp != JMEM_CP_NULL)\n    {\n      ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER (ecma_object_t, outer_lex_env_cp));\n    }\n\n    switch (ecma_get_lex_env_type (object_p))\n    {\n#if JERRY_ESNEXT\n      case ECMA_LEXICAL_ENVIRONMENT_CLASS:\n      {\n#if JERRY_MODULE_SYSTEM\n        if (object_p->type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA)\n        {\n          if (ECMA_LEX_ENV_CLASS_IS_MODULE (object_p))\n          {\n            ecma_gc_mark_properties (object_p, true);\n          }\n\n          ecma_gc_set_object_visited (((ecma_lexical_environment_class_t *) object_p)->object_p);\n          return;\n        }\n#endif /* JERRY_MODULE_SYSTEM */\n        /* FALLTHRU */\n      }\n#endif /* JERRY_ESNEXT */\n      case ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND:\n      {\n        ecma_object_t *binding_object_p = ecma_get_lex_env_binding_object (object_p);\n        ecma_gc_set_object_visited (binding_object_p);\n        return;\n      }\n      default:\n      {\n        break;\n      }\n    }\n  }\n  else\n  {\n    /**\n     * Have the object's prototype here so the object could set it to JMEM_CP_NULL\n     * if the prototype should be ignored (like in case of PROXY).\n     */\n    jmem_cpointer_t proto_cp = object_p->u2.prototype_cp;\n\n    switch (ecma_get_object_type (object_p))\n    {\n      case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:\n      {\n        ecma_extended_object_t *extended_object_p = (ecma_extended_object_t *) object_p;\n\n        if (extended_object_p->u.built_in.id == ECMA_BUILTIN_ID_GLOBAL)\n        {\n          ecma_gc_mark_global_object ((ecma_global_object_t *) object_p);\n        }\n\n#if JERRY_BUILTIN_REALMS\n        ecma_value_t realm_value = extended_object_p->u.built_in.realm_value;\n        ecma_gc_set_object_visited (ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, realm_value));\n#endif /* JERRY_BUILTIN_REALMS */\n        break;\n      }\n      case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:\n      {\n#if JERRY_BUILTIN_REALMS\n        ecma_value_t realm_value = ((ecma_extended_built_in_object_t *) object_p)->built_in.realm_value;\n        ecma_gc_set_object_visited (ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, realm_value));\n#endif /* JERRY_BUILTIN_REALMS */\n        /* FALLTHRU */\n      }\n      case ECMA_OBJECT_TYPE_CLASS:\n      {\n        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n        switch (ext_object_p->u.cls.type)\n        {\n          case ECMA_OBJECT_CLASS_ARGUMENTS:\n          {\n            ecma_gc_mark_arguments_object (ext_object_p);\n            break;\n          }\n#if JERRY_PARSER\n          case ECMA_OBJECT_CLASS_SCRIPT:\n          {\n            const ecma_compiled_code_t *compiled_code_p;\n            compiled_code_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, ext_object_p->u.cls.u3.value);\n\n            JERRY_ASSERT (!(compiled_code_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION));\n            ecma_gc_mark_compiled_code (((cbc_uint8_arguments_t *) compiled_code_p)->script_value);\n            break;\n          }\n#endif /* JERRY_PARSER */\n#if JERRY_BUILTIN_TYPEDARRAY\n          case ECMA_OBJECT_CLASS_TYPEDARRAY:\n          {\n            ecma_gc_set_object_visited (ecma_typedarray_get_arraybuffer (object_p));\n            break;\n          }\n#endif /* JERRY_BUILTIN_TYPEDARRAY */\n#if JERRY_MODULE_SYSTEM\n          case ECMA_OBJECT_CLASS_MODULE_NAMESPACE:\n          {\n            JERRY_ASSERT (proto_cp == JMEM_CP_NULL);\n            ecma_gc_set_object_visited (ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, ext_object_p->u.cls.u3.value));\n            ecma_gc_mark_properties (object_p, true);\n            return;\n          }\n#endif /* JERRY_MODULE_SYSTEM */\n#if JERRY_MODULE_SYSTEM\n          case ECMA_OBJECT_CLASS_MODULE:\n          {\n            ecma_module_t *module_p = ((ecma_module_t *) ext_object_p);\n\n            if (module_p->scope_p != NULL)\n            {\n              ecma_gc_set_object_visited (((ecma_module_t *) ext_object_p)->scope_p);\n            }\n\n            if (module_p->namespace_object_p != NULL)\n            {\n              ecma_gc_set_object_visited (((ecma_module_t *) ext_object_p)->namespace_object_p);\n            }\n\n            if (!(module_p->header.u.cls.u2.module_flags & ECMA_MODULE_IS_NATIVE)\n                && module_p->u.compiled_code_p != NULL)\n            {\n              const ecma_compiled_code_t *compiled_code_p = module_p->u.compiled_code_p;\n\n              JERRY_ASSERT (!(compiled_code_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION));\n              ecma_gc_mark_compiled_code (((cbc_uint8_arguments_t *) compiled_code_p)->script_value);\n            }\n\n            ecma_module_node_t *node_p = module_p->imports_p;\n\n            while (node_p != NULL)\n            {\n              if (ecma_is_value_object (node_p->u.path_or_module))\n              {\n                ecma_gc_set_object_visited (ecma_get_object_from_value (node_p->u.path_or_module));\n              }\n\n              node_p = node_p->next_p;\n            }\n            break;\n          }\n#endif /* JERRY_MODULE_SYSTEM */\n#if JERRY_BUILTIN_DATAVIEW\n          case ECMA_OBJECT_CLASS_DATAVIEW:\n          {\n            ecma_dataview_object_t *dataview_p = (ecma_dataview_object_t *) object_p;\n            ecma_gc_set_object_visited (dataview_p->buffer_p);\n            break;\n          }\n#endif /* JERRY_BUILTIN_DATAVIEW */\n#if JERRY_BUILTIN_CONTAINER\n          case ECMA_OBJECT_CLASS_CONTAINER:\n          {\n            if (ext_object_p->u.cls.u2.container_id == LIT_MAGIC_STRING_MAP_UL)\n            {\n              ecma_gc_mark_map_object (object_p);\n              break;\n            }\n            if (ext_object_p->u.cls.u2.container_id == LIT_MAGIC_STRING_WEAKMAP_UL)\n            {\n              ecma_gc_mark_weakmap_object (object_p);\n              break;\n            }\n            if (ext_object_p->u.cls.u2.container_id == LIT_MAGIC_STRING_SET_UL)\n            {\n              ecma_gc_mark_set_object (object_p);\n              break;\n            }\n            JERRY_ASSERT (ext_object_p->u.cls.u2.container_id == LIT_MAGIC_STRING_WEAKSET_UL);\n            break;\n          }\n#endif /* JERRY_BUILTIN_CONTAINER */\n#if JERRY_ESNEXT\n          case ECMA_OBJECT_CLASS_GENERATOR:\n          case ECMA_OBJECT_CLASS_ASYNC_GENERATOR:\n          {\n            ecma_gc_mark_executable_object (object_p);\n            break;\n          }\n          case ECMA_OBJECT_CLASS_PROMISE:\n          {\n            ecma_gc_mark_promise_object (ext_object_p);\n            break;\n          }\n          case ECMA_OBJECT_CLASS_PROMISE_CAPABILITY:\n          {\n            ecma_promise_capabality_t *capability_p = (ecma_promise_capabality_t *) object_p;\n\n            if (ecma_is_value_object (capability_p->header.u.cls.u3.promise))\n            {\n              ecma_gc_set_object_visited (ecma_get_object_from_value (capability_p->header.u.cls.u3.promise));\n            }\n            if (ecma_is_value_object (capability_p->resolve))\n            {\n              ecma_gc_set_object_visited (ecma_get_object_from_value (capability_p->resolve));\n            }\n            if (ecma_is_value_object (capability_p->reject))\n            {\n              ecma_gc_set_object_visited (ecma_get_object_from_value (capability_p->reject));\n            }\n            break;\n          }\n          case ECMA_OBJECT_CLASS_ASYNC_FROM_SYNC_ITERATOR:\n          {\n            ecma_async_from_sync_iterator_object_t *iter_p = (ecma_async_from_sync_iterator_object_t *) ext_object_p;\n\n            ecma_gc_set_object_visited (ecma_get_object_from_value (iter_p->header.u.cls.u3.sync_iterator));\n\n            if (!ecma_is_value_undefined (iter_p->sync_next_method))\n            {\n              ecma_gc_set_object_visited (ecma_get_object_from_value (iter_p->sync_next_method));\n            }\n\n            break;\n          }\n          case ECMA_OBJECT_CLASS_ARRAY_ITERATOR:\n          case ECMA_OBJECT_CLASS_SET_ITERATOR:\n          case ECMA_OBJECT_CLASS_MAP_ITERATOR:\n          {\n            ecma_value_t iterated_value = ext_object_p->u.cls.u3.iterated_value;\n            if (!ecma_is_value_empty (iterated_value))\n            {\n              ecma_gc_set_object_visited (ecma_get_object_from_value (iterated_value));\n            }\n            break;\n          }\n#if JERRY_BUILTIN_REGEXP\n          case ECMA_OBJECT_CLASS_REGEXP_STRING_ITERATOR:\n          {\n            ecma_regexp_string_iterator_t *regexp_string_iterator_obj = (ecma_regexp_string_iterator_t *) object_p;\n            ecma_value_t regexp = regexp_string_iterator_obj->iterating_regexp;\n            ecma_gc_set_object_visited (ecma_get_object_from_value (regexp));\n            break;\n          }\n#endif /* JERRY_BUILTIN_REGEXP */\n#endif /* JERRY_ESNEXT */\n          default:\n          {\n            /* The ECMA_OBJECT_CLASS__MAX type represents an uninitialized class. */\n            JERRY_ASSERT (ext_object_p->u.cls.type <= ECMA_OBJECT_CLASS__MAX);\n            break;\n          }\n        }\n\n        break;\n      }\n      case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:\n      {\n#if JERRY_BUILTIN_REALMS\n        ecma_value_t realm_value = ((ecma_extended_built_in_object_t *) object_p)->built_in.realm_value;\n        ecma_gc_set_object_visited (ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, realm_value));\n#endif /* JERRY_BUILTIN_REALMS */\n        /* FALLTHRU */\n      }\n      case ECMA_OBJECT_TYPE_ARRAY:\n      {\n        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n#if JERRY_ESNEXT\n        if (JERRY_UNLIKELY (ext_object_p->u.array.length_prop_and_hole_count & ECMA_ARRAY_TEMPLATE_LITERAL))\n        {\n          /* Template objects are never marked. */\n          JERRY_ASSERT (object_p->type_flags_refs >= ECMA_OBJECT_REF_ONE);\n          return;\n        }\n#endif /* JERRY_ESNEXT */\n\n        if (ecma_op_array_is_fast_array (ext_object_p))\n        {\n          if (object_p->u1.property_list_cp != JMEM_CP_NULL)\n          {\n            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);\n\n            for (uint32_t i = 0; i < ext_object_p->u.array.length; i++)\n            {\n              if (ecma_is_value_object (values_p[i]))\n              {\n                ecma_gc_set_object_visited (ecma_get_object_from_value (values_p[i]));\n              }\n            }\n          }\n\n          if (proto_cp != JMEM_CP_NULL)\n          {\n            ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp));\n          }\n          return;\n        }\n        break;\n      }\n#if JERRY_BUILTIN_PROXY\n      case ECMA_OBJECT_TYPE_PROXY:\n      {\n        ecma_gc_mark_proxy_object (object_p);\n        /* Prototype of proxy object is a bit set. */\n        proto_cp = JMEM_CP_NULL;\n        break;\n      }\n#endif /* JERRY_BUILTIN_PROXY */\n      case ECMA_OBJECT_TYPE_FUNCTION:\n      {\n        ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;\n        ecma_gc_set_object_visited (\n          ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t, ext_func_p->u.function.scope_cp));\n\n        const ecma_compiled_code_t *compiled_code_p = ecma_op_function_get_compiled_code (ext_func_p);\n\n#if JERRY_ESNEXT\n        if (CBC_FUNCTION_IS_ARROW (compiled_code_p->status_flags))\n        {\n          ecma_arrow_function_t *arrow_func_p = (ecma_arrow_function_t *) object_p;\n\n          if (ecma_is_value_object (arrow_func_p->this_binding))\n          {\n            ecma_gc_set_object_visited (ecma_get_object_from_value (arrow_func_p->this_binding));\n          }\n\n          if (ecma_is_value_object (arrow_func_p->new_target))\n          {\n            ecma_gc_set_object_visited (ecma_get_object_from_value (arrow_func_p->new_target));\n          }\n        }\n#endif /* JERRY_ESNEXT */\n\n#if JERRY_SNAPSHOT_EXEC\n        if (JERRY_UNLIKELY (compiled_code_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION))\n        {\n          /* Static snapshot functions have a global realm */\n          break;\n        }\n#endif /* JERRY_SNAPSHOT_EXEC */\n\n        JERRY_ASSERT (!(compiled_code_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION));\n        ecma_gc_mark_compiled_code (((cbc_uint8_arguments_t *) compiled_code_p)->script_value);\n        break;\n      }\n      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n      {\n        ecma_gc_mark_bound_function_object (object_p);\n        break;\n      }\n#if JERRY_ESNEXT || JERRY_BUILTIN_REALMS\n      case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:\n      {\n        ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;\n#endif /* JERRY_ESNEXT || JERRY_BUILTIN_REALMS */\n\n#if JERRY_BUILTIN_REALMS\n        ecma_value_t realm_value = ext_func_p->u.built_in.realm_value;\n        ecma_gc_set_object_visited (ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, realm_value));\n#endif /* JERRY_BUILTIN_REALMS */\n\n#if JERRY_ESNEXT\n        if (ext_func_p->u.built_in.id == ECMA_BUILTIN_ID_HANDLER)\n        {\n          switch (ext_func_p->u.built_in.routine_id)\n          {\n            case ECMA_NATIVE_HANDLER_PROMISE_RESOLVE:\n            case ECMA_NATIVE_HANDLER_PROMISE_REJECT:\n            {\n              ecma_promise_resolver_t *resolver_obj_p = (ecma_promise_resolver_t *) object_p;\n              ecma_gc_set_object_visited (ecma_get_object_from_value (resolver_obj_p->promise));\n              break;\n            }\n            case ECMA_NATIVE_HANDLER_PROMISE_THEN_FINALLY:\n            case ECMA_NATIVE_HANDLER_PROMISE_CATCH_FINALLY:\n            {\n              ecma_promise_finally_function_t *finally_obj_p = (ecma_promise_finally_function_t *) object_p;\n              ecma_gc_set_object_visited (ecma_get_object_from_value (finally_obj_p->constructor));\n              ecma_gc_set_object_visited (ecma_get_object_from_value (finally_obj_p->on_finally));\n              break;\n            }\n            case ECMA_NATIVE_HANDLER_PROMISE_CAPABILITY_EXECUTOR:\n            {\n              ecma_promise_capability_executor_t *executor_p = (ecma_promise_capability_executor_t *) object_p;\n              ecma_gc_set_object_visited (ecma_get_object_from_value (executor_p->capability));\n              break;\n            }\n            case ECMA_NATIVE_HANDLER_PROMISE_ALL_HELPER:\n            {\n              ecma_promise_all_executor_t *executor_p = (ecma_promise_all_executor_t *) object_p;\n              ecma_gc_set_object_visited (ecma_get_object_from_value (executor_p->capability));\n              ecma_gc_set_object_visited (ecma_get_object_from_value (executor_p->values));\n              ecma_gc_set_object_visited (ecma_get_object_from_value (executor_p->remaining_elements));\n              break;\n            }\n#if JERRY_BUILTIN_PROXY\n            case ECMA_NATIVE_HANDLER_PROXY_REVOKE:\n            {\n              ecma_revocable_proxy_object_t *rev_proxy_p = (ecma_revocable_proxy_object_t *) object_p;\n\n              if (!ecma_is_value_null (rev_proxy_p->proxy))\n              {\n                ecma_gc_set_object_visited (ecma_get_object_from_value (rev_proxy_p->proxy));\n              }\n\n              break;\n            }\n#endif /* JERRY_BUILTIN_PROXY */\n            case ECMA_NATIVE_HANDLER_VALUE_THUNK:\n            case ECMA_NATIVE_HANDLER_VALUE_THROWER:\n            {\n              ecma_promise_value_thunk_t *thunk_obj_p = (ecma_promise_value_thunk_t *) object_p;\n\n              if (ecma_is_value_object (thunk_obj_p->value))\n              {\n                ecma_gc_set_object_visited (ecma_get_object_from_value (thunk_obj_p->value));\n              }\n              break;\n            }\n            case ECMA_NATIVE_HANDLER_ASYNC_FROM_SYNC_ITERATOR_UNWRAP:\n            {\n              break;\n            }\n            default:\n            {\n              JERRY_UNREACHABLE ();\n            }\n          }\n        }\n#endif /* JERRY_ESNEXT */\n\n#if JERRY_ESNEXT || JERRY_BUILTIN_REALMS\n        break;\n      }\n#endif /* JERRY_ESNEXT || JERRY_BUILTIN_REALMS */\n#if JERRY_ESNEXT\n      case ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION:\n      {\n        ecma_gc_mark_compiled_code (((ecma_extended_object_t *) object_p)->u.constructor_function.script_value);\n        break;\n      }\n#endif /* JERRY_ESNEXT */\n#if JERRY_BUILTIN_REALMS\n      case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:\n      {\n        ecma_native_function_t *native_function_p = (ecma_native_function_t *) object_p;\n        ecma_gc_set_object_visited (ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, native_function_p->realm_value));\n        break;\n      }\n#endif /* JERRY_BUILTIN_REALMS */\n      default:\n      {\n        break;\n      }\n    }\n\n    if (proto_cp != JMEM_CP_NULL)\n    {\n      ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp));\n    }\n  }\n\n  ecma_gc_mark_properties (object_p, false);\n}",
        "begin_line": 817,
        "end_line": 1285,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_gc_mark_compiled_code#444",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_gc_mark_compiled_code (ecma_value_t script_value) /**< script value */",
        "snippet": "static void\necma_gc_mark_compiled_code (ecma_value_t script_value) /**< script value */\n{\n  cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);\n\n  if (script_p->refs_and_type & CBC_SCRIPT_USER_VALUE_IS_OBJECT)\n  {\n    ecma_value_t user_value = CBC_SCRIPT_GET_USER_VALUE (script_p);\n\n    JERRY_ASSERT (ecma_is_value_object (user_value));\n    ecma_gc_set_object_visited (ecma_get_object_from_value (user_value));\n  }\n\n#if JERRY_MODULE_SYSTEM\n  if (script_p->refs_and_type & CBC_SCRIPT_HAS_IMPORT_META)\n  {\n    ecma_value_t import_meta = CBC_SCRIPT_GET_IMPORT_META (script_p, script_p->refs_and_type);\n\n    JERRY_ASSERT (ecma_is_value_object (import_meta));\n    ecma_gc_set_object_visited (ecma_get_object_from_value (import_meta));\n  }\n#endif /* JERRY_MODULE_SYSTEM */\n\n#if JERRY_BUILTIN_REALMS\n  ecma_gc_set_object_visited (script_p->realm_p);\n#endif /* JERRY_BUILTIN_REALMS */\n}",
        "begin_line": 444,
        "end_line": 470,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_gc_mark_global_object#168",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_gc_mark_global_object (ecma_global_object_t *global_object_p) /**< global object */",
        "snippet": "static void\necma_gc_mark_global_object (ecma_global_object_t *global_object_p) /**< global object */\n{\n  JERRY_ASSERT (global_object_p->extended_object.u.built_in.routine_id == 0);\n\n  ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER (ecma_object_t, global_object_p->global_env_cp));\n\n#if JERRY_BUILTIN_REALMS\n  ecma_gc_set_object_visited (ecma_get_object_from_value (global_object_p->this_binding));\n#endif /* JERRY_BUILTIN_REALMS */\n\n#if JERRY_ESNEXT\n  if (global_object_p->global_scope_cp != global_object_p->global_env_cp)\n  {\n    ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER (ecma_object_t, global_object_p->global_scope_cp));\n  }\n#endif /* JERRY_ESNEXT */\n\n  jmem_cpointer_t *builtin_objects_p = global_object_p->builtin_objects;\n\n  for (int i = 0; i < ECMA_BUILTIN_OBJECTS_COUNT; i++)\n  {\n    if (builtin_objects_p[i] != JMEM_CP_NULL)\n    {\n      ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER (ecma_object_t, builtin_objects_p[i]));\n    }\n  }\n}",
        "begin_line": 168,
        "end_line": 195,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_gc_mark_properties#232",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_gc_mark_properties (ecma_object_t *object_p, /**< object */                          bool mark_references) /**< mark references */",
        "snippet": "static void\necma_gc_mark_properties (ecma_object_t *object_p, /**< object */\n                         bool mark_references) /**< mark references */\n{\n  JERRY_UNUSED (mark_references);\n\n#if !JERRY_MODULE_SYSTEM\n  JERRY_ASSERT (!mark_references);\n#endif /* !JERRY_MODULE_SYSTEM */\n\n  jmem_cpointer_t prop_iter_cp = object_p->u1.property_list_cp;\n\n#if JERRY_PROPERTY_HASHMAP\n  if (prop_iter_cp != JMEM_CP_NULL)\n  {\n    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n    if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n    {\n      prop_iter_cp = prop_iter_p->next_property_cp;\n    }\n  }\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n  while (prop_iter_cp != JMEM_CP_NULL)\n  {\n    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n    ecma_property_pair_t *property_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n    for (uint32_t index = 0; index < ECMA_PROPERTY_PAIR_ITEM_COUNT; index++)\n    {\n      uint8_t property = property_pair_p->header.types[index];\n\n      if (JERRY_LIKELY (ECMA_PROPERTY_IS_RAW (property)))\n      {\n        if (property & ECMA_PROPERTY_FLAG_DATA)\n        {\n          ecma_value_t value = property_pair_p->values[index].value;\n\n          if (ecma_is_value_object (value))\n          {\n            ecma_gc_set_object_visited (ecma_get_object_from_value (value));\n          }\n          continue;\n        }\n\n#if JERRY_MODULE_SYSTEM\n        if (mark_references)\n        {\n          continue;\n        }\n#endif /* JERRY_MODULE_SYSTEM */\n\n        ecma_property_value_t *accessor_objs_p = property_pair_p->values + index;\n\n        ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (accessor_objs_p);\n\n        if (get_set_pair_p->getter_cp != JMEM_CP_NULL)\n        {\n          ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp));\n        }\n\n        if (get_set_pair_p->setter_cp != JMEM_CP_NULL)\n        {\n          ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->setter_cp));\n        }\n\n        continue;\n      }\n\n      if (!ECMA_PROPERTY_IS_INTERNAL (property))\n      {\n        JERRY_ASSERT (property == ECMA_PROPERTY_TYPE_DELETED || property == ECMA_PROPERTY_TYPE_HASHMAP);\n        continue;\n      }\n\n      JERRY_ASSERT (property_pair_p->names_cp[index] >= LIT_INTERNAL_MAGIC_STRING_FIRST_DATA\n                    && property_pair_p->names_cp[index] < LIT_MAGIC_STRING__COUNT);\n\n      switch (property_pair_p->names_cp[index])\n      {\n#if JERRY_ESNEXT\n        case LIT_INTERNAL_MAGIC_STRING_ENVIRONMENT_RECORD:\n        {\n          ecma_environment_record_t *environment_record_p;\n          environment_record_p =\n            ECMA_GET_INTERNAL_VALUE_POINTER (ecma_environment_record_t, property_pair_p->values[index].value);\n\n          if (environment_record_p->this_binding != ECMA_VALUE_UNINITIALIZED)\n          {\n            JERRY_ASSERT (ecma_is_value_object (environment_record_p->this_binding));\n            ecma_gc_set_object_visited (ecma_get_object_from_value (environment_record_p->this_binding));\n          }\n\n          JERRY_ASSERT (ecma_is_value_object (environment_record_p->function_object));\n          ecma_gc_set_object_visited (ecma_get_object_from_value (environment_record_p->function_object));\n          break;\n        }\n        case LIT_INTERNAL_MAGIC_STRING_CLASS_PRIVATE_ELEMENTS:\n        {\n          ecma_value_t *compact_collection_p;\n          compact_collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, property_pair_p->values[index].value);\n\n          ecma_value_t *end_p = ecma_compact_collection_end (compact_collection_p);\n          ecma_value_t *current_p = compact_collection_p + 1;\n\n          while (end_p - current_p >= ECMA_PRIVATE_ELEMENT_LIST_SIZE)\n          {\n            current_p++; /* skip the type */\n            current_p++; /* skip the name */\n            ecma_value_t value = *current_p++;\n\n            if (!ecma_is_value_undefined (value))\n            {\n              ecma_gc_set_object_visited (ecma_get_object_from_value (value));\n            }\n          }\n          break;\n        }\n#endif /* JERRY_ESNEXT */\n#if JERRY_BUILTIN_CONTAINER\n        case LIT_INTERNAL_MAGIC_STRING_WEAK_REFS:\n        {\n          ecma_value_t key_arg = ecma_make_object_value (object_p);\n          ecma_collection_t *refs_p;\n\n          refs_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, property_pair_p->values[index].value);\n\n          for (uint32_t j = 0; j < refs_p->item_count; j++)\n          {\n            const ecma_value_t reference_value = refs_p->buffer_p[j];\n\n            if (ecma_is_value_empty (reference_value))\n            {\n              continue;\n            }\n\n            ecma_object_t *reference_object_p = ecma_get_object_from_value (reference_value);\n\n            JERRY_ASSERT (ecma_get_object_type (reference_object_p) == ECMA_OBJECT_TYPE_CLASS);\n\n            ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) reference_object_p;\n\n            if (map_object_p->u.cls.type != ECMA_OBJECT_CLASS_CONTAINER\n                || map_object_p->u.cls.u2.container_id != LIT_MAGIC_STRING_WEAKMAP_UL\n                || !ecma_gc_is_object_visited (reference_object_p))\n            {\n              continue;\n            }\n\n            ecma_value_t value = ecma_op_container_find_weak_value (reference_object_p, key_arg);\n\n            if (ecma_is_value_object (value))\n            {\n              ecma_gc_set_object_visited (ecma_get_object_from_value (value));\n            }\n          }\n          break;\n        }\n#endif /* JERRY_BUILTIN_CONTAINER */\n        case LIT_INTERNAL_MAGIC_STRING_NATIVE_POINTER_WITH_REFERENCES:\n        {\n          jerry_value_t value = property_pair_p->values[index].value;\n\n          if (value == JMEM_CP_NULL)\n          {\n            JERRY_ASSERT (!(property & ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL));\n            break;\n          }\n\n          ecma_native_pointer_t *item_p;\n          item_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_native_pointer_t, value);\n\n          do\n          {\n            jerry_object_native_info_t *native_info_p = item_p->native_info_p;\n\n            JERRY_ASSERT (native_info_p != NULL && native_info_p->number_of_references > 0);\n\n            uint8_t *start_p = ((uint8_t *) item_p->native_p) + native_info_p->offset_of_references;\n            ecma_value_t *value_p = (ecma_value_t *) start_p;\n            ecma_value_t *end_p = value_p + native_info_p->number_of_references;\n\n            do\n            {\n              if (ecma_is_value_object (*value_p))\n              {\n                ecma_gc_set_object_visited (ecma_get_object_from_value (*value_p));\n              }\n            } while (++value_p < end_p);\n\n            if (property & ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL)\n            {\n              break;\n            }\n\n            item_p = &(((ecma_native_pointer_chain_t *) item_p)->next_p->data);\n          } while (item_p != NULL);\n\n          break;\n        }\n      }\n    }\n\n    prop_iter_cp = prop_iter_p->next_property_cp;\n  }\n}",
        "begin_line": 232,
        "end_line": 439,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_gc_run#2156",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_gc_run (void)",
        "snippet": "void\necma_gc_run (void)\n{\n#if (JERRY_GC_MARK_LIMIT != 0)\n  JERRY_ASSERT (JERRY_CONTEXT (ecma_gc_mark_recursion_limit) == JERRY_GC_MARK_LIMIT);\n#endif /* (JERRY_GC_MARK_LIMIT != 0) */\n\n  JERRY_CONTEXT (ecma_gc_new_objects) = 0;\n\n  ecma_object_t black_list_head;\n  black_list_head.gc_next_cp = JMEM_CP_NULL;\n  ecma_object_t *black_end_p = &black_list_head;\n\n  ecma_object_t white_gray_list_head;\n  white_gray_list_head.gc_next_cp = JERRY_CONTEXT (ecma_gc_objects_cp);\n\n  ecma_object_t *obj_prev_p = &white_gray_list_head;\n  jmem_cpointer_t obj_iter_cp = obj_prev_p->gc_next_cp;\n  ecma_object_t *obj_iter_p;\n\n  /* Move root objects (i.e. they have global or stack references) to the black list. */\n  while (obj_iter_cp != JMEM_CP_NULL)\n  {\n    obj_iter_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_object_t, obj_iter_cp);\n    const jmem_cpointer_t obj_next_cp = obj_iter_p->gc_next_cp;\n\n    JERRY_ASSERT (obj_prev_p == NULL\n                  || ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_prev_p->gc_next_cp) == obj_iter_p);\n\n    if (obj_iter_p->type_flags_refs >= ECMA_OBJECT_REF_ONE)\n    {\n      /* Moving the object to list of marked objects. */\n      obj_prev_p->gc_next_cp = obj_next_cp;\n\n      black_end_p->gc_next_cp = obj_iter_cp;\n      black_end_p = obj_iter_p;\n    }\n    else\n    {\n      obj_iter_p->type_flags_refs |= ECMA_OBJECT_NON_VISITED;\n      obj_prev_p = obj_iter_p;\n    }\n\n    obj_iter_cp = obj_next_cp;\n  }\n\n  black_end_p->gc_next_cp = JMEM_CP_NULL;\n\n  /* Mark root objects. */\n  obj_iter_cp = black_list_head.gc_next_cp;\n  while (obj_iter_cp != JMEM_CP_NULL)\n  {\n    obj_iter_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_object_t, obj_iter_cp);\n    ecma_gc_mark (obj_iter_p);\n    obj_iter_cp = obj_iter_p->gc_next_cp;\n  }\n\n  /* Mark non-root objects. */\n  bool marked_anything_during_current_iteration;\n\n  do\n  {\n#if (JERRY_GC_MARK_LIMIT != 0)\n    JERRY_ASSERT (JERRY_CONTEXT (ecma_gc_mark_recursion_limit) == JERRY_GC_MARK_LIMIT);\n#endif /* (JERRY_GC_MARK_LIMIT != 0) */\n\n    marked_anything_during_current_iteration = false;\n\n    obj_prev_p = &white_gray_list_head;\n    obj_iter_cp = obj_prev_p->gc_next_cp;\n\n    while (obj_iter_cp != JMEM_CP_NULL)\n    {\n      obj_iter_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_object_t, obj_iter_cp);\n      const jmem_cpointer_t obj_next_cp = obj_iter_p->gc_next_cp;\n\n      JERRY_ASSERT (obj_prev_p == NULL\n                    || ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_prev_p->gc_next_cp) == obj_iter_p);\n\n      if (ecma_gc_is_object_visited (obj_iter_p))\n      {\n        /* Moving the object to list of marked objects */\n        obj_prev_p->gc_next_cp = obj_next_cp;\n\n        black_end_p->gc_next_cp = obj_iter_cp;\n        black_end_p = obj_iter_p;\n\n#if (JERRY_GC_MARK_LIMIT != 0)\n        if (obj_iter_p->type_flags_refs >= ECMA_OBJECT_REF_ONE)\n        {\n          /* Set the reference count of non-marked gray object to 0 */\n          obj_iter_p->type_flags_refs &= (ecma_object_descriptor_t) (ECMA_OBJECT_REF_ONE - 1);\n          ecma_gc_mark (obj_iter_p);\n          marked_anything_during_current_iteration = true;\n        }\n#else /* (JERRY_GC_MARK_LIMIT == 0) */\n        marked_anything_during_current_iteration = true;\n#endif /* (JERRY_GC_MARK_LIMIT != 0) */\n      }\n      else\n      {\n        obj_prev_p = obj_iter_p;\n      }\n\n      obj_iter_cp = obj_next_cp;\n    }\n  } while (marked_anything_during_current_iteration);\n\n  black_end_p->gc_next_cp = JMEM_CP_NULL;\n  JERRY_CONTEXT (ecma_gc_objects_cp) = black_list_head.gc_next_cp;\n\n  /* Sweep objects that are currently unmarked. */\n  obj_iter_cp = white_gray_list_head.gc_next_cp;\n\n  while (obj_iter_cp != JMEM_CP_NULL)\n  {\n    obj_iter_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_object_t, obj_iter_cp);\n    const jmem_cpointer_t obj_next_cp = obj_iter_p->gc_next_cp;\n\n    JERRY_ASSERT (!ecma_gc_is_object_visited (obj_iter_p));\n\n    ecma_gc_free_object (obj_iter_p);\n    obj_iter_cp = obj_next_cp;\n  }\n\n#if JERRY_BUILTIN_REGEXP\n  /* Free RegExp bytecodes stored in cache */\n  re_cache_gc ();\n#endif /* JERRY_BUILTIN_REGEXP */\n}",
        "begin_line": 2156,
        "end_line": 2285,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_gc_set_object_visited#87",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_gc_set_object_visited (ecma_object_t *object_p) /**< object */",
        "snippet": "static void\necma_gc_set_object_visited (ecma_object_t *object_p) /**< object */\n{\n  if (object_p->type_flags_refs >= ECMA_OBJECT_NON_VISITED)\n  {\n#if (JERRY_GC_MARK_LIMIT != 0)\n    if (JERRY_CONTEXT (ecma_gc_mark_recursion_limit) != 0)\n    {\n      JERRY_CONTEXT (ecma_gc_mark_recursion_limit)--;\n      /* Set the reference count of gray object to 0 */\n      object_p->type_flags_refs &= (ecma_object_descriptor_t) (ECMA_OBJECT_REF_ONE - 1);\n      ecma_gc_mark (object_p);\n      JERRY_CONTEXT (ecma_gc_mark_recursion_limit)++;\n    }\n    else\n    {\n      /* Set the reference count of the non-marked gray object to 1 */\n      object_p->type_flags_refs &= (ecma_object_descriptor_t) ((ECMA_OBJECT_REF_ONE << 1) - 1);\n      JERRY_ASSERT (object_p->type_flags_refs >= ECMA_OBJECT_REF_ONE);\n    }\n#else /* (JERRY_GC_MARK_LIMIT == 0) */\n    /* Set the reference count of gray object to 0 */\n    object_p->type_flags_refs &= (ecma_object_descriptor_t) (ECMA_OBJECT_REF_ONE - 1);\n#endif /* (JERRY_GC_MARK_LIMIT != 0) */\n  }\n}",
        "begin_line": 87,
        "end_line": 112,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_init_gc_info#117",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_init_gc_info (ecma_object_t *object_p) /**< object */",
        "snippet": "extern inline void\necma_init_gc_info (ecma_object_t *object_p) /**< object */\n{\n  JERRY_CONTEXT (ecma_gc_objects_number)++;\n  JERRY_CONTEXT (ecma_gc_new_objects)++;\n\n  JERRY_ASSERT (object_p->type_flags_refs < ECMA_OBJECT_REF_ONE);\n  object_p->type_flags_refs |= ECMA_OBJECT_REF_ONE;\n\n  object_p->gc_next_cp = JERRY_CONTEXT (ecma_gc_objects_cp);\n  ECMA_SET_NON_NULL_POINTER (JERRY_CONTEXT (ecma_gc_objects_cp), object_p);\n}",
        "begin_line": 117,
        "end_line": 128,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-gc.ecma_ref_object#149",
        "src_path": "jerry-core/ecma/base/ecma-gc.c",
        "class_name": "jerry-core.ecma.base.ecma-gc",
        "signature": "jerry-core.ecma.base.ecma-gc.ecma_ref_object (ecma_object_t *object_p) /**< object */",
        "snippet": "void\necma_ref_object (ecma_object_t *object_p) /**< object */\n{\n  ecma_ref_object_inline (object_p);\n}",
        "begin_line": 149,
        "end_line": 153,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_compare_get_string_chars#1565",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_compare_get_string_chars (const ecma_string_t *string_p, /**< ecma-string */                                lit_utf8_size_t *size_and_length_p) /**< [out] size and length */",
        "snippet": "static const lit_utf8_byte_t *\necma_compare_get_string_chars (const ecma_string_t *string_p, /**< ecma-string */\n                               lit_utf8_size_t *size_and_length_p) /**< [out] size and length */\n{\n  switch (ECMA_STRING_GET_CONTAINER (string_p))\n  {\n    case ECMA_STRING_CONTAINER_HEAP_UTF8_STRING:\n    {\n      ecma_short_string_t *short_string_p = (ecma_short_string_t *) string_p;\n      size_and_length_p[0] = short_string_p->size;\n      size_and_length_p[1] = short_string_p->length;\n      return ECMA_SHORT_STRING_GET_BUFFER (string_p);\n    }\n    case ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING:\n    {\n      ecma_long_string_t *long_string_p = (ecma_long_string_t *) string_p;\n      size_and_length_p[0] = long_string_p->size;\n      size_and_length_p[1] = long_string_p->length;\n      return long_string_p->string_p;\n    }\n    case ECMA_STRING_CONTAINER_HEAP_ASCII_STRING:\n    {\n      size_and_length_p[0] = ECMA_ASCII_STRING_GET_SIZE (string_p);\n      size_and_length_p[1] = size_and_length_p[0];\n      return ECMA_ASCII_STRING_GET_BUFFER (string_p);\n    }\n    default:\n    {\n      return NULL;\n    }\n  }\n}",
        "begin_line": 1565,
        "end_line": 1596,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_deref_ecma_string#936",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_deref_ecma_string (ecma_string_t *string_p) /**< ecma-string */",
        "snippet": "void\necma_deref_ecma_string (ecma_string_t *string_p) /**< ecma-string */\n{\n  JERRY_ASSERT (string_p != NULL);\n\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    return;\n  }\n\n  ecma_deref_ecma_string_non_direct (string_p);\n}",
        "begin_line": 936,
        "end_line": 947,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_destroy_ecma_string#952",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_destroy_ecma_string (ecma_string_t *string_p) /**< ecma-string */",
        "snippet": "void\necma_destroy_ecma_string (ecma_string_t *string_p) /**< ecma-string */\n{\n  JERRY_ASSERT (string_p != NULL);\n  JERRY_ASSERT (!ECMA_IS_DIRECT_STRING (string_p));\n  JERRY_ASSERT ((string_p->refs_and_container < ECMA_STRING_REF_ONE) || ECMA_STRING_IS_STATIC (string_p));\n\n  switch (ECMA_STRING_GET_CONTAINER (string_p))\n  {\n    case ECMA_STRING_CONTAINER_HEAP_UTF8_STRING:\n    {\n      ecma_dealloc_string_buffer (string_p, ((ecma_short_string_t *) string_p)->size + sizeof (ecma_short_string_t));\n      return;\n    }\n    case ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING:\n    {\n      ecma_long_string_t *long_string_p = (ecma_long_string_t *) string_p;\n\n      if (long_string_p->string_p == ECMA_LONG_STRING_BUFFER_START (long_string_p))\n      {\n        ecma_dealloc_string_buffer (string_p, long_string_p->size + sizeof (ecma_long_string_t));\n        return;\n      }\n\n      ecma_external_string_t *external_string_p = (ecma_external_string_t *) string_p;\n      jerry_external_string_free_cb_t free_cb = JERRY_CONTEXT (external_string_free_callback_p);\n\n      if (free_cb != NULL)\n      {\n        free_cb ((lit_utf8_byte_t *) external_string_p->header.string_p,\n                 external_string_p->header.size,\n                 external_string_p->user_p);\n      }\n\n      ecma_dealloc_external_string (external_string_p);\n      return;\n    }\n    case ECMA_STRING_CONTAINER_HEAP_ASCII_STRING:\n    {\n      ecma_dealloc_string_buffer (string_p, ECMA_ASCII_STRING_GET_SIZE (string_p) + ECMA_ASCII_STRING_HEADER_SIZE);\n      return;\n    }\n#if JERRY_ESNEXT\n    case ECMA_STRING_CONTAINER_SYMBOL:\n    {\n      ecma_extended_string_t *symbol_p = (ecma_extended_string_t *) string_p;\n      ecma_free_value (symbol_p->u.symbol_descriptor);\n      ecma_dealloc_extended_string (symbol_p);\n      return;\n    }\n#endif /* JERRY_ESNEXT */\n    default:\n    {\n      JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC\n                    || ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);\n\n      /* only the string descriptor itself should be freed */\n      ecma_dealloc_string (string_p);\n    }\n  }\n}",
        "begin_line": 952,
        "end_line": 1012,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_find_special_string#297",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_find_special_string (const lit_utf8_byte_t *string_p, /**< utf8 string */                           lit_utf8_size_t string_size) /**< string size */",
        "snippet": "static ecma_string_t *\necma_find_special_string (const lit_utf8_byte_t *string_p, /**< utf8 string */\n                          lit_utf8_size_t string_size) /**< string size */\n{\n  JERRY_ASSERT (string_p != NULL || string_size == 0);\n  lit_magic_string_id_t magic_string_id = lit_is_utf8_string_magic (string_p, string_size);\n\n  if (magic_string_id != LIT_MAGIC_STRING__COUNT)\n  {\n    return ecma_get_magic_string (magic_string_id);\n  }\n\n  JERRY_ASSERT (string_size > 0);\n\n  if (*string_p >= LIT_CHAR_0 && *string_p <= LIT_CHAR_9)\n  {\n    uint32_t array_index;\n\n    if (ecma_string_to_array_index (string_p, string_size, &array_index))\n    {\n      return ecma_new_ecma_string_from_uint32 (array_index);\n    }\n  }\n\n  if (lit_get_magic_string_ex_count () > 0)\n  {\n    lit_magic_string_ex_id_t magic_string_ex_id = lit_is_ex_utf8_string_magic (string_p, string_size);\n\n    if (magic_string_ex_id < lit_get_magic_string_ex_count ())\n    {\n      return ecma_new_ecma_string_from_magic_string_ex_id (magic_string_ex_id);\n    }\n  }\n\n  return NULL;\n}",
        "begin_line": 297,
        "end_line": 332,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_get_string_magic#2158",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_get_string_magic (const ecma_string_t *string_p) /**< ecma-string */",
        "snippet": "lit_magic_string_id_t\necma_get_string_magic (const ecma_string_t *string_p) /**< ecma-string */\n{\n  if (ECMA_IS_DIRECT_STRING_WITH_TYPE (string_p, ECMA_DIRECT_STRING_MAGIC))\n  {\n    uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);\n\n    if (id < LIT_MAGIC_STRING__COUNT)\n    {\n      return (lit_magic_string_id_t) id;\n    }\n  }\n\n  return LIT_MAGIC_STRING__COUNT;\n}",
        "begin_line": 2158,
        "end_line": 2172,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_new_ecma_string_from_utf8#366",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_new_ecma_string_from_utf8 (const lit_utf8_byte_t *string_p, /**< utf-8 string */                                 lit_utf8_size_t string_size) /**< string size */",
        "snippet": "ecma_string_t *\necma_new_ecma_string_from_utf8 (const lit_utf8_byte_t *string_p, /**< utf-8 string */\n                                lit_utf8_size_t string_size) /**< string size */\n{\n  JERRY_ASSERT (string_p != NULL || string_size == 0);\n  JERRY_ASSERT (lit_is_valid_cesu8_string (string_p, string_size));\n\n  ecma_string_t *string_desc_p = ecma_find_special_string (string_p, string_size);\n\n  if (string_desc_p != NULL)\n  {\n    return string_desc_p;\n  }\n\n  lit_utf8_byte_t *data_p;\n  string_desc_p =\n    ecma_new_ecma_string_from_utf8_buffer (lit_utf8_string_length (string_p, string_size), string_size, &data_p);\n\n  string_desc_p->u.hash = lit_utf8_string_calc_hash (string_p, string_size);\n  memcpy (data_p, string_p, string_size);\n\n  return string_desc_p;\n}",
        "begin_line": 366,
        "end_line": 388,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_new_ecma_string_from_utf8_converted_to_cesu8#396",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_new_ecma_string_from_utf8_converted_to_cesu8 (const lit_utf8_byte_t *string_p, /**< utf-8 string */                                                    lit_utf8_size_t string_size) /**< utf-8 string size */",
        "snippet": "ecma_string_t *\necma_new_ecma_string_from_utf8_converted_to_cesu8 (const lit_utf8_byte_t *string_p, /**< utf-8 string */\n                                                   lit_utf8_size_t string_size) /**< utf-8 string size */\n{\n  JERRY_ASSERT (string_p != NULL || string_size == 0);\n\n  lit_utf8_size_t converted_string_length = 0;\n  lit_utf8_size_t converted_string_size = 0;\n  lit_utf8_size_t pos = 0;\n\n  /* Calculate the required length and size information of the converted cesu-8 encoded string */\n  while (pos < string_size)\n  {\n    if ((string_p[pos] & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)\n    {\n      pos++;\n    }\n    else if ((string_p[pos] & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)\n    {\n      pos += 2;\n    }\n    else if ((string_p[pos] & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER)\n    {\n      pos += 3;\n    }\n    else\n    {\n      JERRY_ASSERT ((string_p[pos] & LIT_UTF8_4_BYTE_MASK) == LIT_UTF8_4_BYTE_MARKER);\n      pos += 4;\n      converted_string_size += 2;\n      converted_string_length++;\n    }\n\n    converted_string_length++;\n  }\n\n  JERRY_ASSERT (pos == string_size);\n\n  if (converted_string_size == 0)\n  {\n    return ecma_new_ecma_string_from_utf8 (string_p, string_size);\n  }\n\n  converted_string_size += string_size;\n\n  JERRY_ASSERT (lit_is_valid_utf8_string (string_p, string_size, false));\n\n  lit_utf8_byte_t *data_p;\n  ecma_string_t *string_desc_p =\n    ecma_new_ecma_string_from_utf8_buffer (converted_string_length, converted_string_size, &data_p);\n\n  const lit_utf8_byte_t *const begin_data_p = data_p;\n  pos = 0;\n\n  while (pos < string_size)\n  {\n    if ((string_p[pos] & LIT_UTF8_4_BYTE_MASK) == LIT_UTF8_4_BYTE_MARKER)\n    {\n      /* Processing 4 byte unicode sequence. Always converted to two 3 byte long sequence. */\n      lit_four_byte_utf8_char_to_cesu8 (data_p, string_p + pos);\n      data_p += 3 * 2;\n      pos += 4;\n    }\n    else\n    {\n      *data_p++ = string_p[pos++];\n    }\n  }\n\n  JERRY_ASSERT (pos == string_size);\n\n  string_desc_p->u.hash = lit_utf8_string_calc_hash (begin_data_p, converted_string_size);\n\n  return (ecma_string_t *) string_desc_p;\n}",
        "begin_line": 396,
        "end_line": 470,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-string.ecma_ref_ecma_string#890",
        "src_path": "jerry-core/ecma/base/ecma-helpers-string.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-string",
        "signature": "jerry-core.ecma.base.ecma-helpers-string.ecma_ref_ecma_string (ecma_string_t *string_p) /**< string descriptor */",
        "snippet": "void\necma_ref_ecma_string (ecma_string_t *string_p) /**< string descriptor */\n{\n  JERRY_ASSERT (string_p != NULL);\n\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    return;\n  }\n\n  ecma_ref_ecma_string_non_direct (string_p);\n}",
        "begin_line": 890,
        "end_line": 901,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_copy_value#878",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_copy_value (ecma_value_t value) /**< value description */",
        "snippet": "ecma_value_t\necma_copy_value (ecma_value_t value) /**< value description */\n{\n  switch (ecma_get_value_type_field (value))\n  {\n    case ECMA_TYPE_FLOAT:\n    {\n      ecma_number_t *num_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (value);\n      ecma_number_t *new_num_p = ecma_alloc_number ();\n\n      *new_num_p = *num_p;\n\n      return ecma_make_float_value (new_num_p);\n    }\n#if JERRY_ESNEXT\n    case ECMA_TYPE_SYMBOL:\n#endif /* JERRY_ESNEXT */\n    case ECMA_TYPE_STRING:\n    {\n      ecma_string_t *string_p = (ecma_string_t *) ecma_get_pointer_from_ecma_value (value);\n      ecma_ref_ecma_string_non_direct (string_p);\n      return value;\n    }\n#if JERRY_BUILTIN_BIGINT\n    case ECMA_TYPE_BIGINT:\n    {\n      if (value != ECMA_BIGINT_ZERO)\n      {\n        ecma_ref_extended_primitive (ecma_get_extended_primitive_from_value (value));\n      }\n      return value;\n    }\n#endif /* JERRY_BUILTIN_BIGINT */\n    case ECMA_TYPE_OBJECT:\n    {\n      ecma_ref_object_inline (ecma_get_object_from_value (value));\n      return value;\n    }\n    default:\n    {\n      JERRY_ASSERT (ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT\n                    || ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT_STRING);\n\n      return value;\n    }\n  }\n}",
        "begin_line": 878,
        "end_line": 924,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_free_value#1105",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_free_value (ecma_value_t value) /**< value description */",
        "snippet": "void\necma_free_value (ecma_value_t value) /**< value description */\n{\n  switch (ecma_get_value_type_field (value))\n  {\n    case ECMA_TYPE_FLOAT:\n    {\n      ecma_number_t *number_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (value);\n      ecma_dealloc_number (number_p);\n      break;\n    }\n#if JERRY_ESNEXT\n    case ECMA_TYPE_SYMBOL:\n#endif /* JERRY_ESNEXT */\n    case ECMA_TYPE_STRING:\n    {\n      ecma_string_t *string_p = (ecma_string_t *) ecma_get_pointer_from_ecma_value (value);\n      ecma_deref_ecma_string_non_direct (string_p);\n      break;\n    }\n    case ECMA_TYPE_OBJECT:\n    {\n      ecma_deref_object (ecma_get_object_from_value (value));\n      break;\n    }\n#if JERRY_BUILTIN_BIGINT\n    case ECMA_TYPE_BIGINT:\n    {\n      if (value != ECMA_BIGINT_ZERO)\n      {\n        ecma_deref_bigint (ecma_get_extended_primitive_from_value (value));\n      }\n\n      break;\n    }\n#endif /* JERRY_BUILTIN_BIGINT */\n    default:\n    {\n      JERRY_ASSERT (ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT\n                    || ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT_STRING);\n\n      /* no memory is allocated */\n      break;\n    }\n  }\n}",
        "begin_line": 1105,
        "end_line": 1150,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_free_value_if_not_object#1173",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_free_value_if_not_object (ecma_value_t value) /**< value description */",
        "snippet": "void\necma_free_value_if_not_object (ecma_value_t value) /**< value description */\n{\n  if (ecma_get_value_type_field (value) != ECMA_TYPE_OBJECT)\n  {\n    ecma_free_value (value);\n  }\n}",
        "begin_line": 1173,
        "end_line": 1180,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers-value.ecma_value_assign_value#989",
        "src_path": "jerry-core/ecma/base/ecma-helpers-value.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers-value",
        "signature": "jerry-core.ecma.base.ecma-helpers-value.ecma_value_assign_value (ecma_value_t *value_p, /**< [in, out] ecma value */                          ecma_value_t ecma_value) /**< value to assign */",
        "snippet": "void\necma_value_assign_value (ecma_value_t *value_p, /**< [in, out] ecma value */\n                         ecma_value_t ecma_value) /**< value to assign */\n{\n  JERRY_STATIC_ASSERT (ECMA_TYPE_DIRECT == 0, ecma_type_direct_must_be_zero_for_the_next_check);\n\n  if (*value_p == ecma_value)\n  {\n    return;\n  }\n\n  if (ecma_get_value_type_field (ecma_value || *value_p) == ECMA_TYPE_DIRECT)\n  {\n    *value_p = ecma_value;\n  }\n  else if (ecma_is_value_float_number (ecma_value) && ecma_is_value_float_number (*value_p))\n  {\n    const ecma_number_t *num_src_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (ecma_value);\n    ecma_number_t *num_dst_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (*value_p);\n\n    *num_dst_p = *num_src_p;\n  }\n  else\n  {\n    ecma_free_value_if_not_object (*value_p);\n    *value_p = ecma_copy_value_if_not_object (ecma_value);\n  }\n}",
        "begin_line": 989,
        "end_line": 1016,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_assert_object_contains_the_property#881",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_assert_object_contains_the_property (const ecma_object_t *object_p, /**< ecma-object */                                           const ecma_property_value_t *prop_value_p, /**< property value */                                           bool is_data) /**< property should be data property */",
        "snippet": "static void\necma_assert_object_contains_the_property (const ecma_object_t *object_p, /**< ecma-object */\n                                          const ecma_property_value_t *prop_value_p, /**< property value */\n                                          bool is_data) /**< property should be data property */\n{\n#ifndef JERRY_NDEBUG\n  jmem_cpointer_t prop_iter_cp = object_p->u1.property_list_cp;\n  JERRY_ASSERT (prop_iter_cp != JMEM_CP_NULL);\n\n  ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n\n  if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n  {\n    prop_iter_cp = prop_iter_p->next_property_cp;\n  }\n\n  while (prop_iter_cp != JMEM_CP_NULL)\n  {\n    prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n\n    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)\n    {\n      if ((prop_pair_p->values + i) == prop_value_p)\n      {\n        JERRY_ASSERT (is_data == ((prop_pair_p->header.types[i] & ECMA_PROPERTY_FLAG_DATA) != 0));\n        return;\n      }\n    }\n\n    prop_iter_cp = prop_iter_p->next_property_cp;\n  }\n#else /* JERRY_NDEBUG */\n  JERRY_UNUSED (object_p);\n  JERRY_UNUSED (prop_value_p);\n  JERRY_UNUSED (is_data);\n#endif /* !JERRY_NDEBUG */\n}",
        "begin_line": 881,
        "end_line": 921,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_bytecode_ref#1467",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_bytecode_ref (ecma_compiled_code_t *bytecode_p) /**< byte code pointer */",
        "snippet": "void\necma_bytecode_ref (ecma_compiled_code_t *bytecode_p) /**< byte code pointer */\n{\n  /* Abort program if maximum reference number is reached. */\n  if (bytecode_p->refs >= UINT16_MAX)\n  {\n    jerry_fatal (ERR_REF_COUNT_LIMIT);\n  }\n\n  bytecode_p->refs++;\n}",
        "begin_line": 1467,
        "end_line": 1477,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_compiled_code_resolve_arguments_start#1684",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_compiled_code_resolve_arguments_start (const ecma_compiled_code_t *bytecode_header_p) /**< compiled code */",
        "snippet": "ecma_value_t *\necma_compiled_code_resolve_arguments_start (const ecma_compiled_code_t *bytecode_header_p) /**< compiled code */\n{\n  JERRY_ASSERT (bytecode_header_p != NULL);\n\n  uint8_t *byte_p = (uint8_t *) bytecode_header_p;\n  byte_p += ((size_t) bytecode_header_p->size) << JMEM_ALIGNMENT_LOG;\n\n  if (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_MAPPED_ARGUMENTS_NEEDED))\n  {\n    return ((ecma_value_t *) byte_p);\n  }\n\n  if (JERRY_LIKELY (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)))\n  {\n    return ((ecma_value_t *) byte_p) - ((cbc_uint8_arguments_t *) bytecode_header_p)->argument_end;\n  }\n\n  return ((ecma_value_t *) byte_p) - ((cbc_uint16_arguments_t *) bytecode_header_p)->argument_end;\n}",
        "begin_line": 1684,
        "end_line": 1703,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_create_named_data_property#527",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_create_named_data_property (ecma_object_t *object_p, /**< object */                                  ecma_string_t *name_p, /**< property name */                                  uint8_t prop_attributes, /**< property attributes (See: ecma_property_flags_t) */                                  ecma_property_t **out_prop_p) /**< [out] the property is also returned                                                                 *         if this field is non-NULL */",
        "snippet": "ecma_property_value_t *\necma_create_named_data_property (ecma_object_t *object_p, /**< object */\n                                 ecma_string_t *name_p, /**< property name */\n                                 uint8_t prop_attributes, /**< property attributes (See: ecma_property_flags_t) */\n                                 ecma_property_t **out_prop_p) /**< [out] the property is also returned\n                                                                *         if this field is non-NULL */\n{\n  JERRY_ASSERT (object_p != NULL && name_p != NULL);\n  JERRY_ASSERT (ecma_is_lexical_environment (object_p) || !ecma_op_object_is_fast_array (object_p));\n  JERRY_ASSERT (ecma_find_named_property (object_p, name_p) == NULL);\n  JERRY_ASSERT ((prop_attributes & ~ECMA_PROPERTY_BUILT_IN_CONFIGURABLE_ENUMERABLE_WRITABLE) == 0);\n\n  uint8_t type_and_flags = ECMA_PROPERTY_FLAG_DATA | prop_attributes;\n\n  ecma_property_value_t value;\n  value.value = ECMA_VALUE_UNDEFINED;\n\n  return ecma_create_property (object_p, name_p, type_and_flags, value, out_prop_p);\n}",
        "begin_line": 527,
        "end_line": 545,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_create_object#85",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_create_object (ecma_object_t *prototype_object_p, /**< pointer to prototybe of the object (or NULL) */                     size_t ext_object_size, /**< size of extended objects */                     ecma_object_type_t type) /**< object type */",
        "snippet": "ecma_object_t *\necma_create_object (ecma_object_t *prototype_object_p, /**< pointer to prototybe of the object (or NULL) */\n                    size_t ext_object_size, /**< size of extended objects */\n                    ecma_object_type_t type) /**< object type */\n{\n  ecma_object_t *new_object_p;\n\n  if (ext_object_size > 0)\n  {\n    new_object_p = (ecma_object_t *) ecma_alloc_extended_object (ext_object_size);\n  }\n  else\n  {\n    new_object_p = ecma_alloc_object ();\n  }\n\n  new_object_p->type_flags_refs = (ecma_object_descriptor_t) (type | ECMA_OBJECT_FLAG_EXTENSIBLE);\n\n  ecma_init_gc_info (new_object_p);\n\n  new_object_p->u1.property_list_cp = JMEM_CP_NULL;\n\n  ECMA_SET_POINTER (new_object_p->u2.prototype_cp, prototype_object_p);\n\n  return new_object_p;\n}",
        "begin_line": 85,
        "end_line": 110,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_create_object_lex_env#148",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_create_object_lex_env (ecma_object_t *outer_lexical_environment_p, /**< outer lexical environment */                             ecma_object_t *binding_obj_p) /**< binding object */",
        "snippet": "ecma_object_t *\necma_create_object_lex_env (ecma_object_t *outer_lexical_environment_p, /**< outer lexical environment */\n                            ecma_object_t *binding_obj_p) /**< binding object */\n{\n  JERRY_ASSERT (binding_obj_p != NULL && !ecma_is_lexical_environment (binding_obj_p));\n\n  ecma_object_t *new_lexical_environment_p = ecma_alloc_object ();\n\n  new_lexical_environment_p->type_flags_refs = ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND;\n\n  ecma_init_gc_info (new_lexical_environment_p);\n\n  ECMA_SET_NON_NULL_POINTER (new_lexical_environment_p->u1.bound_object_cp, binding_obj_p);\n\n  ECMA_SET_POINTER (new_lexical_environment_p->u2.outer_reference_cp, outer_lexical_environment_p);\n\n  return new_lexical_environment_p;\n}",
        "begin_line": 148,
        "end_line": 165,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_create_property#396",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_create_property (ecma_object_t *object_p, /**< the object */                       ecma_string_t *name_p, /**< property name */                       uint8_t type_and_flags, /**< type and flags, see ecma_property_info_t */                       ecma_property_value_t value, /**< property value */                       ecma_property_t **out_prop_p) /**< [out] the property is also returned                                                      *         if this field is non-NULL */",
        "snippet": "static ecma_property_value_t *\necma_create_property (ecma_object_t *object_p, /**< the object */\n                      ecma_string_t *name_p, /**< property name */\n                      uint8_t type_and_flags, /**< type and flags, see ecma_property_info_t */\n                      ecma_property_value_t value, /**< property value */\n                      ecma_property_t **out_prop_p) /**< [out] the property is also returned\n                                                     *         if this field is non-NULL */\n{\n  JERRY_ASSERT (ECMA_PROPERTY_PAIR_ITEM_COUNT == 2);\n  JERRY_ASSERT (name_p != NULL);\n  JERRY_ASSERT (object_p != NULL);\n\n  jmem_cpointer_t *property_list_head_p = &object_p->u1.property_list_cp;\n\n  if (*property_list_head_p != ECMA_NULL_POINTER)\n  {\n    /* If the first entry is free (deleted), it is reused. */\n    ecma_property_header_t *first_property_p =\n      ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, *property_list_head_p);\n\n#if JERRY_PROPERTY_HASHMAP\n    bool has_hashmap = false;\n\n    if (first_property_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n    {\n      property_list_head_p = &first_property_p->next_property_cp;\n      first_property_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, *property_list_head_p);\n      has_hashmap = true;\n    }\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (first_property_p));\n\n    if (first_property_p->types[0] == ECMA_PROPERTY_TYPE_DELETED)\n    {\n      ecma_property_pair_t *first_property_pair_p = (ecma_property_pair_t *) first_property_p;\n\n      ecma_property_t name_type;\n      first_property_pair_p->names_cp[0] = ecma_string_to_property_name (name_p, &name_type);\n      first_property_p->types[0] = (ecma_property_t) (type_and_flags | name_type);\n\n      ecma_property_t *property_p = first_property_p->types + 0;\n\n      JERRY_ASSERT (ECMA_PROPERTY_VALUE_PTR (property_p) == first_property_pair_p->values + 0);\n\n      if (out_prop_p != NULL)\n      {\n        *out_prop_p = property_p;\n      }\n\n      first_property_pair_p->values[0] = value;\n\n#if JERRY_PROPERTY_HASHMAP\n      /* The property must be fully initialized before ecma_property_hashmap_insert\n       * is called, because the insert operation may reallocate the hashmap, and\n       * that triggers garbage collection which scans all properties of all objects.\n       * A not fully initialized but queued property may cause a crash. */\n\n      if (has_hashmap)\n      {\n        ecma_property_hashmap_insert (object_p, name_p, first_property_pair_p, 0);\n      }\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n      return first_property_pair_p->values + 0;\n    }\n  }\n\n  /* Otherwise we create a new property pair and use its second value. */\n  ecma_property_pair_t *first_property_pair_p = ecma_alloc_property_pair ();\n\n  /* Need to query property_list_head_p again and recheck the existennce\n   * of property hasmap, because ecma_alloc_property_pair may delete them. */\n  property_list_head_p = &object_p->u1.property_list_cp;\n#if JERRY_PROPERTY_HASHMAP\n  bool has_hashmap = false;\n\n  if (*property_list_head_p != ECMA_NULL_POINTER)\n  {\n    ecma_property_header_t *first_property_p =\n      ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, *property_list_head_p);\n\n    if (first_property_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n    {\n      property_list_head_p = &first_property_p->next_property_cp;\n      has_hashmap = true;\n    }\n  }\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n  /* Just copy the previous value (no need to decompress, compress). */\n  first_property_pair_p->header.next_property_cp = *property_list_head_p;\n  first_property_pair_p->header.types[0] = ECMA_PROPERTY_TYPE_DELETED;\n  first_property_pair_p->names_cp[0] = LIT_INTERNAL_MAGIC_STRING_DELETED;\n\n  ecma_property_t name_type;\n  first_property_pair_p->names_cp[1] = ecma_string_to_property_name (name_p, &name_type);\n\n  first_property_pair_p->header.types[1] = (ecma_property_t) (type_and_flags | name_type);\n\n  ECMA_SET_NON_NULL_POINTER (*property_list_head_p, &first_property_pair_p->header);\n\n  ecma_property_t *property_p = first_property_pair_p->header.types + 1;\n\n  JERRY_ASSERT (ECMA_PROPERTY_VALUE_PTR (property_p) == first_property_pair_p->values + 1);\n\n  if (out_prop_p != NULL)\n  {\n    *out_prop_p = property_p;\n  }\n\n  first_property_pair_p->values[1] = value;\n\n#if JERRY_PROPERTY_HASHMAP\n  /* See the comment before the other ecma_property_hashmap_insert above. */\n\n  if (has_hashmap)\n  {\n    ecma_property_hashmap_insert (object_p, name_p, first_property_pair_p, 1);\n  }\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n  return first_property_pair_p->values + 1;\n}",
        "begin_line": 396,
        "end_line": 519,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_find_named_property#615",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_find_named_property (ecma_object_t *obj_p, /**< object to find property in */                           ecma_string_t *name_p) /**< property's name */",
        "snippet": "ecma_property_t *\necma_find_named_property (ecma_object_t *obj_p, /**< object to find property in */\n                          ecma_string_t *name_p) /**< property's name */\n{\n  JERRY_ASSERT (obj_p != NULL);\n  JERRY_ASSERT (name_p != NULL);\n  JERRY_ASSERT (ecma_is_lexical_environment (obj_p) || !ecma_op_object_is_fast_array (obj_p));\n\n#if JERRY_LCACHE\n  ecma_property_t *property_p = ecma_lcache_lookup (obj_p, name_p);\n  if (property_p != NULL)\n  {\n    return property_p;\n  }\n#else /* !JERRY_LCACHE */\n  ecma_property_t *property_p = NULL;\n#endif /* JERRY_LCACHE */\n\n  jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp;\n\n#if JERRY_PROPERTY_HASHMAP\n  if (prop_iter_cp != JMEM_CP_NULL)\n  {\n    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n    if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n    {\n      jmem_cpointer_t property_real_name_cp;\n      property_p = ecma_property_hashmap_find ((ecma_property_hashmap_t *) prop_iter_p, name_p, &property_real_name_cp);\n#if JERRY_LCACHE\n      if (property_p != NULL && !ecma_is_property_lcached (property_p))\n      {\n        ecma_lcache_insert (obj_p, property_real_name_cp, property_p);\n      }\n#endif /* JERRY_LCACHE */\n      return property_p;\n    }\n  }\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n#if JERRY_PROPERTY_HASHMAP\n  uint32_t steps = 0;\n#endif /* JERRY_PROPERTY_HASHMAP */\n  jmem_cpointer_t property_name_cp = ECMA_NULL_POINTER;\n\n  if (ECMA_IS_DIRECT_STRING (name_p))\n  {\n    ecma_property_t prop_name_type = (ecma_property_t) ECMA_GET_DIRECT_STRING_TYPE (name_p);\n    property_name_cp = (jmem_cpointer_t) ECMA_GET_DIRECT_STRING_VALUE (name_p);\n\n    JERRY_ASSERT (prop_name_type > 0);\n\n    while (prop_iter_cp != JMEM_CP_NULL)\n    {\n      ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n\n      JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n      ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n      if (prop_pair_p->names_cp[0] == property_name_cp\n          && ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[0]) == prop_name_type)\n      {\n        JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (prop_iter_p->types[0]));\n\n        property_p = prop_iter_p->types + 0;\n        break;\n      }\n\n      if (prop_pair_p->names_cp[1] == property_name_cp\n          && ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[1]) == prop_name_type)\n      {\n        JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (prop_iter_p->types[1]));\n\n        property_p = prop_iter_p->types + 1;\n        break;\n      }\n\n#if JERRY_PROPERTY_HASHMAP\n      steps++;\n#endif /* JERRY_PROPERTY_HASHMAP */\n      prop_iter_cp = prop_iter_p->next_property_cp;\n    }\n  }\n  else\n  {\n    while (prop_iter_cp != JMEM_CP_NULL)\n    {\n      ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n\n      JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n      ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n      if (ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[0]) == ECMA_DIRECT_STRING_PTR)\n      {\n        property_name_cp = prop_pair_p->names_cp[0];\n        ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, property_name_cp);\n\n        if (ecma_compare_ecma_non_direct_strings (name_p, prop_name_p))\n        {\n          property_p = prop_iter_p->types + 0;\n          break;\n        }\n      }\n\n      if (ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[1]) == ECMA_DIRECT_STRING_PTR)\n      {\n        property_name_cp = prop_pair_p->names_cp[1];\n        ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, property_name_cp);\n\n        if (ecma_compare_ecma_non_direct_strings (name_p, prop_name_p))\n        {\n          property_p = prop_iter_p->types + 1;\n          break;\n        }\n      }\n\n#if JERRY_PROPERTY_HASHMAP\n      steps++;\n#endif /* JERRY_PROPERTY_HASHMAP */\n      prop_iter_cp = prop_iter_p->next_property_cp;\n    }\n  }\n\n#if JERRY_PROPERTY_HASHMAP\n  if (steps >= (ECMA_PROPERTY_HASMAP_MINIMUM_SIZE / 2))\n  {\n    ecma_property_hashmap_create (obj_p);\n  }\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n#if JERRY_LCACHE\n  if (property_p != NULL && !ecma_is_property_lcached (property_p))\n  {\n    ecma_lcache_insert (obj_p, property_name_cp, property_p);\n  }\n#endif /* JERRY_LCACHE */\n\n  return property_p;\n}",
        "begin_line": 615,
        "end_line": 754,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_make_empty_property_descriptor#1199",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_make_empty_property_descriptor (void)",
        "snippet": "ecma_property_descriptor_t\necma_make_empty_property_descriptor (void)\n{\n  ecma_property_descriptor_t prop_desc;\n\n  prop_desc.flags = 0;\n  prop_desc.value = ECMA_VALUE_UNDEFINED;\n  prop_desc.get_p = NULL;\n  prop_desc.set_p = NULL;\n\n  return prop_desc;\n}",
        "begin_line": 1199,
        "end_line": 1210,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-helpers.ecma_op_ordinary_object_set_extensible#222",
        "src_path": "jerry-core/ecma/base/ecma-helpers.c",
        "class_name": "jerry-core.ecma.base.ecma-helpers",
        "signature": "jerry-core.ecma.base.ecma-helpers.ecma_op_ordinary_object_set_extensible (ecma_object_t *object_p) /**< object */",
        "snippet": "extern inline void\necma_op_ordinary_object_set_extensible (ecma_object_t *object_p) /**< object */\n{\n  JERRY_ASSERT (object_p != NULL);\n  JERRY_ASSERT (!ecma_is_lexical_environment (object_p));\n\n  object_p->type_flags_refs |= ECMA_OBJECT_FLAG_EXTENSIBLE;\n}",
        "begin_line": 222,
        "end_line": 229,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-init-finalize.ecma_init#42",
        "src_path": "jerry-core/ecma/base/ecma-init-finalize.c",
        "class_name": "jerry-core.ecma.base.ecma-init-finalize",
        "signature": "jerry-core.ecma.base.ecma-init-finalize.ecma_init (void)",
        "snippet": "void\necma_init (void)\n{\n#if (JERRY_GC_MARK_LIMIT != 0)\n  JERRY_CONTEXT (ecma_gc_mark_recursion_limit) = JERRY_GC_MARK_LIMIT;\n#endif /* (JERRY_GC_MARK_LIMIT != 0) */\n\n  ecma_init_global_environment ();\n\n#if JERRY_PROPERTY_HASHMAP\n  JERRY_CONTEXT (ecma_prop_hashmap_alloc_state) = ECMA_PROP_HASHMAP_ALLOC_ON;\n  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_HIGH_PRESSURE_GC;\n#endif /* JERRY_PROPERTY_HASHMAP */\n\n#if (JERRY_STACK_LIMIT != 0)\n  volatile int sp;\n  JERRY_CONTEXT (stack_base) = (uintptr_t) &sp;\n#endif /* (JERRY_STACK_LIMIT != 0) */\n\n#if JERRY_ESNEXT\n  ecma_job_queue_init ();\n#endif /* JERRY_ESNEXT */\n\n#if JERRY_ESNEXT\n  JERRY_CONTEXT (current_new_target_p) = NULL;\n#endif /* JERRY_ESNEXT */\n\n#if JERRY_BUILTIN_TYPEDARRAY\n  JERRY_CONTEXT (arraybuffer_compact_allocation_limit) = 256;\n#endif /* JERRY_BUILTIN_TYPEDARRAY */\n}",
        "begin_line": 42,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.base.ecma-literal-storage.ecma_find_or_create_literal_string#164",
        "src_path": "jerry-core/ecma/base/ecma-literal-storage.c",
        "class_name": "jerry-core.ecma.base.ecma-literal-storage",
        "signature": "jerry-core.ecma.base.ecma-literal-storage.ecma_find_or_create_literal_string (const lit_utf8_byte_t *chars_p, /**< string to be searched */                                     lit_utf8_size_t size, /**< size of the string */                                     bool is_ascii) /**< encode of the string */",
        "snippet": "ecma_value_t\necma_find_or_create_literal_string (const lit_utf8_byte_t *chars_p, /**< string to be searched */\n                                    lit_utf8_size_t size, /**< size of the string */\n                                    bool is_ascii) /**< encode of the string */\n{\n  ecma_string_t *string_p =\n    (is_ascii ? ecma_new_ecma_string_from_ascii (chars_p, size) : ecma_new_ecma_string_from_utf8 (chars_p, size));\n\n  if (ECMA_IS_DIRECT_STRING (string_p))\n  {\n    return ecma_make_string_value (string_p);\n  }\n\n  jmem_cpointer_t string_list_cp = JERRY_CONTEXT (string_list_first_cp);\n  jmem_cpointer_t *empty_cpointer_p = NULL;\n\n  while (string_list_cp != JMEM_CP_NULL)\n  {\n    ecma_lit_storage_item_t *string_list_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_lit_storage_item_t, string_list_cp);\n\n    for (int i = 0; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)\n    {\n      if (string_list_p->values[i] == JMEM_CP_NULL)\n      {\n        if (empty_cpointer_p == NULL)\n        {\n          empty_cpointer_p = string_list_p->values + i;\n        }\n      }\n      else\n      {\n        ecma_string_t *value_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_string_t, string_list_p->values[i]);\n\n        if (ecma_compare_ecma_strings (string_p, value_p))\n        {\n          /* Return with string if found in the list. */\n          ecma_deref_ecma_string (string_p);\n          return ecma_make_string_value (value_p);\n        }\n      }\n    }\n\n    string_list_cp = string_list_p->next_cp;\n  }\n\n  ECMA_SET_STRING_AS_STATIC (string_p);\n  jmem_cpointer_t result;\n  JMEM_CP_SET_NON_NULL_POINTER (result, string_p);\n\n  if (empty_cpointer_p != NULL)\n  {\n    *empty_cpointer_p = result;\n    return ecma_make_string_value (string_p);\n  }\n\n  ecma_lit_storage_item_t *new_item_p;\n  new_item_p = (ecma_lit_storage_item_t *) jmem_pools_alloc (sizeof (ecma_lit_storage_item_t));\n\n  new_item_p->values[0] = result;\n  for (int i = 1; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)\n  {\n    new_item_p->values[i] = JMEM_CP_NULL;\n  }\n\n  new_item_p->next_cp = JERRY_CONTEXT (string_list_first_cp);\n  JMEM_CP_SET_NON_NULL_POINTER (JERRY_CONTEXT (string_list_first_cp), new_item_p);\n\n  return ecma_make_string_value (string_p);\n}",
        "begin_line": 164,
        "end_line": 232,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtin-helpers.ecma_builtin_helper_def_prop#874",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtin-helpers.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtin-helpers",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtin-helpers.ecma_builtin_helper_def_prop (ecma_object_t *obj_p, /**< object */                               ecma_string_t *name_p, /**< name string */                               ecma_value_t value, /**< value */                               uint32_t opts) /**< any combination of ecma_property_descriptor_status_flags_t bits */",
        "snippet": "ecma_value_t\necma_builtin_helper_def_prop (ecma_object_t *obj_p, /**< object */\n                              ecma_string_t *name_p, /**< name string */\n                              ecma_value_t value, /**< value */\n                              uint32_t opts) /**< any combination of ecma_property_descriptor_status_flags_t bits */\n{\n  ecma_property_descriptor_t prop_desc;\n\n  prop_desc.flags = (uint16_t) (ECMA_NAME_DATA_PROPERTY_DESCRIPTOR_BITS | opts);\n\n  prop_desc.value = value;\n\n  return ecma_op_object_define_own_property (obj_p, name_p, &prop_desc);\n}",
        "begin_line": 874,
        "end_line": 887,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_create_global_object#509",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_create_global_object (void)",
        "snippet": "ecma_global_object_t *\necma_builtin_create_global_object (void)\n{\n  ecma_builtin_descriptor_t builtin_desc = ecma_builtin_descriptors[ECMA_BUILTIN_ID_GLOBAL];\n  ecma_builtin_id_t prototype_builtin_id = (ecma_builtin_id_t) (builtin_desc >> ECMA_BUILTIN_PROTOTYPE_ID_SHIFT);\n  ecma_object_type_t obj_type = (ecma_object_type_t) (builtin_desc & ECMA_BUILTIN_OBJECT_TYPE_MASK);\n  size_t property_count = ecma_builtin_get_property_count (ECMA_BUILTIN_ID_GLOBAL);\n\n  JERRY_ASSERT (prototype_builtin_id != ECMA_BUILTIN_ID__COUNT);\n  JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_GENERAL);\n\n  /* Whenever this assertion fails, the size of extra_instantiated_bitset in ecma_global_object_t\n   * must be increased and 32 must be added to these constants. Furthermore the new uint32 item\n   * must be set to zero. */\n#if JERRY_BUILTIN_REALMS\n  JERRY_ASSERT (property_count <= ECMA_BUILTIN_INSTANTIATED_BITSET_MIN_SIZE + 64);\n#else /* !JERRY_BUILTIN_REALMS */\n  JERRY_ASSERT (property_count <= ECMA_BUILTIN_INSTANTIATED_BITSET_MIN_SIZE + 32);\n#endif /* JERRY_BUILTIN_REALMS */\n\n  ecma_object_t *object_p = ecma_create_object (NULL, sizeof (ecma_global_object_t), obj_type);\n\n  ecma_op_ordinary_object_set_extensible (object_p);\n\n  ecma_global_object_t *global_object_p = (ecma_global_object_t *) object_p;\n\n  global_object_p->extended_object.u.built_in.id = (uint8_t) ECMA_BUILTIN_ID_GLOBAL;\n  global_object_p->extended_object.u.built_in.routine_id = 0;\n  /* Bitset size is ignored by the gc. */\n  global_object_p->extended_object.u.built_in.u.length_and_bitset_size = 0;\n  global_object_p->extended_object.u.built_in.u2.instantiated_bitset[0] = 0;\n  global_object_p->extra_instantiated_bitset[0] = 0;\n#if JERRY_BUILTIN_REALMS\n  ECMA_SET_INTERNAL_VALUE_POINTER (global_object_p->extended_object.u.built_in.realm_value, global_object_p);\n  global_object_p->extra_realms_bitset = 0;\n  global_object_p->this_binding = ecma_make_object_value (object_p);\n#else /* !JERRY_BUILTIN_REALMS */\n  global_object_p->extended_object.u.built_in.continue_instantiated_bitset[0] = 0;\n#endif /* JERRY_BUILTIN_REALMS */\n\n  memset (global_object_p->builtin_objects, 0, (sizeof (jmem_cpointer_t) * ECMA_BUILTIN_OBJECTS_COUNT));\n\n  /* Temporary self reference for GC mark. */\n  ECMA_SET_NON_NULL_POINTER (global_object_p->global_env_cp, object_p);\n#if JERRY_ESNEXT\n  global_object_p->global_scope_cp = global_object_p->global_env_cp;\n#endif /* JERRY_ESNEXT */\n\n  ecma_object_t *global_lex_env_p = ecma_create_object_lex_env (NULL, object_p);\n  ECMA_SET_NON_NULL_POINTER (global_object_p->global_env_cp, global_lex_env_p);\n#if JERRY_ESNEXT\n  global_object_p->global_scope_cp = global_object_p->global_env_cp;\n#endif /* JERRY_ESNEXT */\n  ecma_deref_object (global_lex_env_p);\n\n  ecma_object_t *prototype_object_p;\n  prototype_object_p = ecma_instantiate_builtin (global_object_p, prototype_builtin_id);\n  JERRY_ASSERT (prototype_object_p != NULL);\n\n  ECMA_SET_NON_NULL_POINTER (object_p->u2.prototype_cp, prototype_object_p);\n\n  return global_object_p;\n}",
        "begin_line": 509,
        "end_line": 571,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get#581",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get (ecma_builtin_id_t builtin_id) /**< id of built-in to check on */",
        "snippet": "ecma_object_t *\necma_builtin_get (ecma_builtin_id_t builtin_id) /**< id of built-in to check on */\n{\n  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_OBJECTS_COUNT);\n\n  ecma_global_object_t *global_object_p = (ecma_global_object_t *) ecma_builtin_get_global ();\n  jmem_cpointer_t *builtin_p = global_object_p->builtin_objects + builtin_id;\n\n  if (JERRY_UNLIKELY (*builtin_p == JMEM_CP_NULL))\n  {\n    return ecma_instantiate_builtin (global_object_p, builtin_id);\n  }\n\n  return ECMA_GET_NON_NULL_POINTER (ecma_object_t, *builtin_p);\n}",
        "begin_line": 581,
        "end_line": 595,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get_property_count#213",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_get_property_count (ecma_builtin_id_t builtin_id) /**< built-in ID */",
        "snippet": "static size_t\necma_builtin_get_property_count (ecma_builtin_id_t builtin_id) /**< built-in ID */\n{\n  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_ID__COUNT);\n  const ecma_builtin_property_descriptor_t *property_list_p = ecma_builtin_property_list_references[builtin_id];\n\n  const ecma_builtin_property_descriptor_t *curr_property_p = property_list_p;\n\n  while (curr_property_p->magic_string_id != LIT_MAGIC_STRING__COUNT)\n  {\n    curr_property_p++;\n  }\n\n  return (size_t) (curr_property_p - property_list_p);\n}",
        "begin_line": 213,
        "end_line": 227,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_is_global#235",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_is_global (ecma_object_t *object_p) /**< pointer to an object */",
        "snippet": "bool\necma_builtin_is_global (ecma_object_t *object_p) /**< pointer to an object */\n{\n  return (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_BUILT_IN_GENERAL\n          && ((ecma_extended_object_t *) object_p)->u.built_in.id == ECMA_BUILTIN_ID_GLOBAL);\n}",
        "begin_line": 235,
        "end_line": 240,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_try_to_instantiate_property#934",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_builtin_try_to_instantiate_property (ecma_object_t *object_p, /**< object */                                           ecma_string_t *property_name_p) /**< property's name */",
        "snippet": "ecma_property_t *\necma_builtin_try_to_instantiate_property (ecma_object_t *object_p, /**< object */\n                                          ecma_string_t *property_name_p) /**< property's name */\n{\n  lit_magic_string_id_t magic_string_id = ecma_get_string_magic (property_name_p);\n\n#if JERRY_ESNEXT\n  if (JERRY_UNLIKELY (ecma_prop_name_is_symbol (property_name_p)) && property_name_p->u.hash & ECMA_SYMBOL_FLAG_GLOBAL)\n  {\n    magic_string_id = (property_name_p->u.hash >> ECMA_SYMBOL_FLAGS_SHIFT);\n  }\n#endif /* JERRY_ESNEXT */\n\n  if (magic_string_id == LIT_MAGIC_STRING__COUNT)\n  {\n    return NULL;\n  }\n\n  ecma_built_in_props_t *built_in_props_p;\n  ecma_object_type_t object_type = ecma_get_object_type (object_p);\n\n  JERRY_ASSERT (object_type == ECMA_OBJECT_TYPE_BUILT_IN_GENERAL || object_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS\n                || object_type == ECMA_OBJECT_TYPE_BUILT_IN_ARRAY\n                || (object_type == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION && !ecma_builtin_function_is_routine (object_p)));\n\n  if (ECMA_BUILTIN_IS_EXTENDED_BUILT_IN (object_type))\n  {\n    built_in_props_p = &((ecma_extended_built_in_object_t *) object_p)->built_in;\n  }\n  else\n  {\n    built_in_props_p = &((ecma_extended_object_t *) object_p)->u.built_in;\n  }\n\n  ecma_builtin_id_t builtin_id = (ecma_builtin_id_t) built_in_props_p->id;\n\n  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_ID__COUNT);\n\n  const ecma_builtin_property_descriptor_t *property_list_p = ecma_builtin_property_list_references[builtin_id];\n  const ecma_builtin_property_descriptor_t *curr_property_p = property_list_p;\n\n  while (curr_property_p->magic_string_id != magic_string_id)\n  {\n    if (curr_property_p->magic_string_id == LIT_MAGIC_STRING__COUNT)\n    {\n      return NULL;\n    }\n    curr_property_p++;\n  }\n\n  uint32_t index = (uint32_t) (curr_property_p - property_list_p);\n  uint8_t *bitset_p = built_in_props_p->u2.instantiated_bitset + (index >> 3);\n\n#if JERRY_BUILTIN_REALMS\n  if (index >= 8 * sizeof (uint8_t))\n  {\n    bitset_p += sizeof (ecma_value_t);\n  }\n#endif /* JERRY_BUILTIN_REALMS */\n\n  uint8_t bit_for_index = (uint8_t) (1u << (index & 0x7));\n\n  if (*bitset_p & bit_for_index)\n  {\n    /* This property was instantiated before. */\n    return NULL;\n  }\n\n  ecma_value_t value = ECMA_VALUE_EMPTY;\n  bool is_accessor = false;\n  ecma_object_t *getter_p = NULL;\n  ecma_object_t *setter_p = NULL;\n\n  switch (curr_property_p->type)\n  {\n    case ECMA_BUILTIN_PROPERTY_SIMPLE:\n    {\n      value = curr_property_p->value;\n\n#if JERRY_BUILTIN_GLOBAL_THIS\n      if (value == ECMA_VALUE_GLOBAL_THIS)\n      {\n        /* Only the global object has globalThis property. */\n        JERRY_ASSERT (ecma_builtin_is_global (object_p));\n        ecma_ref_object (object_p);\n        value = ecma_make_object_value (object_p);\n      }\n#endif /* JERRY_BUILTIN_GLOBAL_THIS */\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_NUMBER:\n    {\n      ecma_number_t num = 0.0;\n\n      if (curr_property_p->value < ECMA_BUILTIN_NUMBER_MAX)\n      {\n        num = curr_property_p->value;\n      }\n      else if (curr_property_p->value < ECMA_BUILTIN_NUMBER_NAN)\n      {\n        static const ecma_number_t builtin_number_list[] = {\n          ECMA_NUMBER_MAX_VALUE,\n          ECMA_NUMBER_MIN_VALUE,\n#if JERRY_ESNEXT\n          ECMA_NUMBER_EPSILON,\n          ECMA_NUMBER_MAX_SAFE_INTEGER,\n          ECMA_NUMBER_MIN_SAFE_INTEGER,\n#endif /* JERRY_ESNEXT */\n          ECMA_NUMBER_E,\n          ECMA_NUMBER_PI,\n          ECMA_NUMBER_LN10,\n          ECMA_NUMBER_LN2,\n          ECMA_NUMBER_LOG2E,\n          ECMA_NUMBER_LOG10E,\n          ECMA_NUMBER_SQRT2,\n          ECMA_NUMBER_SQRT_1_2,\n        };\n\n        num = builtin_number_list[curr_property_p->value - ECMA_BUILTIN_NUMBER_MAX];\n      }\n      else\n      {\n        switch (curr_property_p->value)\n        {\n          case ECMA_BUILTIN_NUMBER_POSITIVE_INFINITY:\n          {\n            num = ecma_number_make_infinity (false);\n            break;\n          }\n          case ECMA_BUILTIN_NUMBER_NEGATIVE_INFINITY:\n          {\n            num = ecma_number_make_infinity (true);\n            break;\n          }\n          default:\n          {\n            JERRY_ASSERT (curr_property_p->value == ECMA_BUILTIN_NUMBER_NAN);\n\n            num = ecma_number_make_nan ();\n            break;\n          }\n        }\n      }\n\n      value = ecma_make_number_value (num);\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_STRING:\n    {\n      value = ecma_make_magic_string_value ((lit_magic_string_id_t) curr_property_p->value);\n      break;\n    }\n#if JERRY_ESNEXT\n    case ECMA_BUILTIN_PROPERTY_SYMBOL:\n    {\n      lit_magic_string_id_t symbol_id = (lit_magic_string_id_t) curr_property_p->value;\n\n      value = ecma_make_symbol_value (ecma_op_get_global_symbol (symbol_id));\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_INTRINSIC_PROPERTY:\n    {\n      ecma_object_t *intrinsic_object_p = ecma_builtin_get_from_builtin (object_p, ECMA_BUILTIN_ID_INTRINSIC_OBJECT);\n      value = ecma_op_object_get_by_magic_id (intrinsic_object_p, (lit_magic_string_id_t) curr_property_p->value);\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_ACCESSOR_BUILTIN_FUNCTION:\n    {\n      is_accessor = true;\n      uint16_t getter_id = ECMA_ACCESSOR_READ_WRITE_GET_GETTER_ID (curr_property_p->value);\n      uint16_t setter_id = ECMA_ACCESSOR_READ_WRITE_GET_SETTER_ID (curr_property_p->value);\n      getter_p = ecma_builtin_get_from_builtin (object_p, getter_id);\n      setter_p = ecma_builtin_get_from_builtin (object_p, setter_id);\n      ecma_ref_object (getter_p);\n      ecma_ref_object (setter_p);\n      break;\n    }\n#endif /* JERRY_ESNEXT */\n    case ECMA_BUILTIN_PROPERTY_OBJECT:\n    {\n      ecma_object_t *builtin_object_p;\n      builtin_object_p = ecma_builtin_get_from_builtin (object_p, (ecma_builtin_id_t) curr_property_p->value);\n      ecma_ref_object (builtin_object_p);\n      value = ecma_make_object_value (builtin_object_p);\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_ROUTINE:\n    {\n      ecma_object_t *func_obj_p;\n      func_obj_p = ecma_builtin_make_function_object_for_routine (object_p,\n                                                                  ECMA_GET_ROUTINE_ID (curr_property_p->value),\n                                                                  index,\n                                                                  ECMA_BUILTIN_ROUTINE_NO_OPTS);\n      value = ecma_make_object_value (func_obj_p);\n      break;\n    }\n    case ECMA_BUILTIN_PROPERTY_ACCESSOR_READ_WRITE:\n    {\n      is_accessor = true;\n      uint8_t getter_id = ECMA_ACCESSOR_READ_WRITE_GET_GETTER_ID (curr_property_p->value);\n      uint8_t setter_id = ECMA_ACCESSOR_READ_WRITE_GET_SETTER_ID (curr_property_p->value);\n      getter_p = ecma_builtin_make_function_object_for_getter_accessor (object_p, getter_id, index);\n      setter_p = ecma_builtin_make_function_object_for_setter_accessor (object_p, setter_id, index);\n      break;\n    }\n    default:\n    {\n      JERRY_ASSERT (curr_property_p->type == ECMA_BUILTIN_PROPERTY_ACCESSOR_READ_ONLY);\n\n      is_accessor = true;\n      uint8_t getter_id = (uint8_t) curr_property_p->value;\n      getter_p = ecma_builtin_make_function_object_for_getter_accessor (object_p, getter_id, index);\n      break;\n    }\n  }\n\n  ecma_property_t *prop_p;\n\n  JERRY_ASSERT (curr_property_p->attributes & ECMA_PROPERTY_FLAG_BUILT_IN);\n\n  if (is_accessor)\n  {\n    ecma_create_named_accessor_property (object_p,\n                                         property_name_p,\n                                         getter_p,\n                                         setter_p,\n                                         curr_property_p->attributes,\n                                         &prop_p);\n\n    if (setter_p)\n    {\n      ecma_deref_object (setter_p);\n    }\n    if (getter_p)\n    {\n      ecma_deref_object (getter_p);\n    }\n  }\n  else\n  {\n    ecma_property_value_t *prop_value_p =\n      ecma_create_named_data_property (object_p, property_name_p, curr_property_p->attributes, &prop_p);\n    prop_value_p->value = value;\n\n    /* Reference count of objects must be decreased. */\n    ecma_deref_if_object (value);\n  }\n\n  return prop_p;\n}",
        "begin_line": 934,
        "end_line": 1183,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_instantiate_builtin#311",
        "src_path": "jerry-core/ecma/builtin-objects/ecma-builtins.c",
        "class_name": "jerry-core.ecma.builtin-objects.ecma-builtins",
        "signature": "jerry-core.ecma.builtin-objects.ecma-builtins.ecma_instantiate_builtin (ecma_global_object_t *global_object_p, /**< global object */                           ecma_builtin_id_t obj_builtin_id) /**< built-in id */",
        "snippet": "static ecma_object_t *\necma_instantiate_builtin (ecma_global_object_t *global_object_p, /**< global object */\n                          ecma_builtin_id_t obj_builtin_id) /**< built-in id */\n{\n  jmem_cpointer_t *builtin_objects = global_object_p->builtin_objects;\n\n  JERRY_ASSERT (obj_builtin_id < ECMA_BUILTIN_OBJECTS_COUNT);\n  JERRY_ASSERT (builtin_objects[obj_builtin_id] == JMEM_CP_NULL);\n\n  ecma_builtin_descriptor_t builtin_desc = ecma_builtin_descriptors[obj_builtin_id];\n  ecma_builtin_id_t object_prototype_builtin_id = (ecma_builtin_id_t) (builtin_desc >> ECMA_BUILTIN_PROTOTYPE_ID_SHIFT);\n\n  ecma_object_t *prototype_obj_p;\n\n  if (JERRY_UNLIKELY (object_prototype_builtin_id == ECMA_BUILTIN_ID__COUNT))\n  {\n    prototype_obj_p = NULL;\n  }\n  else\n  {\n    if (builtin_objects[object_prototype_builtin_id] == JMEM_CP_NULL)\n    {\n      ecma_instantiate_builtin (global_object_p, object_prototype_builtin_id);\n    }\n    prototype_obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, builtin_objects[object_prototype_builtin_id]);\n    JERRY_ASSERT (prototype_obj_p != NULL);\n  }\n\n  ecma_object_type_t obj_type = (ecma_object_type_t) (builtin_desc & ECMA_BUILTIN_OBJECT_TYPE_MASK);\n\n  JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_GENERAL || obj_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS\n                || obj_type == ECMA_OBJECT_TYPE_BUILT_IN_ARRAY || obj_type == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);\n\n  bool is_extended_built_in = ECMA_BUILTIN_IS_EXTENDED_BUILT_IN (obj_type);\n\n  size_t ext_object_size =\n    (is_extended_built_in ? sizeof (ecma_extended_built_in_object_t) : sizeof (ecma_extended_object_t));\n\n  size_t property_count = ecma_builtin_get_property_count (obj_builtin_id);\n\n  if (property_count > ECMA_BUILTIN_INSTANTIATED_BITSET_MIN_SIZE)\n  {\n    /* Only 64 extra properties supported at the moment.\n     * This can be extended to 256 later. */\n    JERRY_ASSERT (property_count <= (ECMA_BUILTIN_INSTANTIATED_BITSET_MIN_SIZE + 64));\n\n    ext_object_size += sizeof (uint64_t);\n  }\n\n  ecma_object_t *obj_p = ecma_create_object (prototype_obj_p, ext_object_size, obj_type);\n\n  if (JERRY_UNLIKELY (obj_builtin_id == ECMA_BUILTIN_ID_TYPE_ERROR_THROWER))\n  {\n    ecma_op_ordinary_object_prevent_extensions (obj_p);\n  }\n  else\n  {\n    ecma_op_ordinary_object_set_extensible (obj_p);\n  }\n\n  /*\n   * [[Class]] property of built-in object is not stored explicitly.\n   *\n   * See also: ecma_object_get_class_name\n   */\n\n  ecma_built_in_props_t *built_in_props_p;\n\n  if (is_extended_built_in)\n  {\n    built_in_props_p = &((ecma_extended_built_in_object_t *) obj_p)->built_in;\n  }\n  else\n  {\n    built_in_props_p = &((ecma_extended_object_t *) obj_p)->u.built_in;\n  }\n\n  built_in_props_p->id = (uint8_t) obj_builtin_id;\n  built_in_props_p->routine_id = 0;\n  built_in_props_p->u.length_and_bitset_size = 0;\n  built_in_props_p->u2.instantiated_bitset[0] = 0;\n#if JERRY_BUILTIN_REALMS\n  ECMA_SET_INTERNAL_VALUE_POINTER (built_in_props_p->realm_value, global_object_p);\n#else /* !JERRY_BUILTIN_REALMS */\n  built_in_props_p->continue_instantiated_bitset[0] = 0;\n#endif /* JERRY_BUILTIN_REALMS */\n\n  if (property_count > ECMA_BUILTIN_INSTANTIATED_BITSET_MIN_SIZE)\n  {\n    built_in_props_p->u.length_and_bitset_size = 1 << ECMA_BUILT_IN_BITSET_SHIFT;\n\n    uint32_t *instantiated_bitset_p = (uint32_t *) (built_in_props_p + 1);\n    instantiated_bitset_p[0] = 0;\n    instantiated_bitset_p[1] = 0;\n  }\n\n  /** Initializing [[PrimitiveValue]] properties of built-in prototype objects */\n  switch (obj_builtin_id)\n  {\n#if JERRY_BUILTIN_ARRAY\n    case ECMA_BUILTIN_ID_ARRAY_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_ARRAY);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.array.length = 0;\n      ext_object_p->u.array.length_prop_and_hole_count = ECMA_PROPERTY_FLAG_WRITABLE | ECMA_PROPERTY_VIRTUAL;\n      break;\n    }\n#endif /* JERRY_BUILTIN_ARRAY */\n\n#if JERRY_BUILTIN_STRING\n    case ECMA_BUILTIN_ID_STRING_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_STRING;\n      ext_object_p->u.cls.u3.value = ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);\n      break;\n    }\n#endif /* JERRY_BUILTIN_STRING */\n\n#if JERRY_BUILTIN_NUMBER\n    case ECMA_BUILTIN_ID_NUMBER_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_NUMBER;\n      ext_object_p->u.cls.u3.value = ecma_make_integer_value (0);\n      break;\n    }\n#endif /* JERRY_BUILTIN_NUMBER */\n\n#if JERRY_BUILTIN_BOOLEAN\n    case ECMA_BUILTIN_ID_BOOLEAN_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_BOOLEAN;\n      ext_object_p->u.cls.u3.value = ECMA_VALUE_FALSE;\n      break;\n    }\n#endif /* JERRY_BUILTIN_BOOLEAN */\n\n#if !JERRY_ESNEXT\n#if JERRY_BUILTIN_DATE\n    case ECMA_BUILTIN_ID_DATE_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_DATE;\n\n      ecma_number_t *prim_prop_num_value_p = ecma_alloc_number ();\n      *prim_prop_num_value_p = ecma_number_make_nan ();\n      ECMA_SET_INTERNAL_VALUE_POINTER (ext_object_p->u.cls.u3.value, prim_prop_num_value_p);\n      break;\n    }\n#endif /* JERRY_BUILTIN_DATE */\n\n#if JERRY_BUILTIN_REGEXP\n    case ECMA_BUILTIN_ID_REGEXP_PROTOTYPE:\n    {\n      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS);\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_REGEXP;\n\n      re_compiled_code_t *bc_p =\n        re_compile_bytecode (ecma_get_magic_string (LIT_MAGIC_STRING_EMPTY_NON_CAPTURE_GROUP), RE_FLAG_EMPTY);\n\n      JERRY_ASSERT (bc_p != NULL);\n\n      ECMA_SET_INTERNAL_VALUE_POINTER (ext_object_p->u.cls.u3.value, bc_p);\n      break;\n    }\n#endif /* JERRY_BUILTIN_REGEXP */\n#endif /* !JERRY_ESNEXT */\n    default:\n    {\n      JERRY_ASSERT (obj_type != ECMA_OBJECT_TYPE_BUILT_IN_CLASS);\n      break;\n    }\n  }\n\n  ECMA_SET_NON_NULL_POINTER (builtin_objects[obj_builtin_id], obj_p);\n  ecma_deref_object (obj_p);\n  return obj_p;\n}",
        "begin_line": 311,
        "end_line": 502,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_object_check_constructor#159",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_object_check_constructor (ecma_object_t *obj_p) /**< ecma object */",
        "snippet": "ecma_error_msg_t\necma_object_check_constructor (ecma_object_t *obj_p) /**< ecma object */\n{\n  JERRY_ASSERT (!ecma_is_lexical_environment (obj_p));\n\n  ecma_object_type_t type = ecma_get_object_type (obj_p);\n\n  if (JERRY_UNLIKELY (type < ECMA_OBJECT_TYPE_PROXY))\n  {\n    return ECMA_ERR_INVALID_TYPE_FOR_CONSTRUCTOR_CALL;\n  }\n\n  while (JERRY_UNLIKELY (type == ECMA_OBJECT_TYPE_BOUND_FUNCTION))\n  {\n    ecma_bound_function_t *bound_func_p = (ecma_bound_function_t *) obj_p;\n\n    obj_p =\n      ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t, bound_func_p->header.u.bound_function.target_function);\n\n    type = ecma_get_object_type (obj_p);\n  }\n\n  if (JERRY_LIKELY (type == ECMA_OBJECT_TYPE_FUNCTION))\n  {\n#if JERRY_ESNEXT\n    const ecma_compiled_code_t *byte_code_p = ecma_op_function_get_compiled_code ((ecma_extended_object_t *) obj_p);\n\n    if (!CBC_FUNCTION_IS_CONSTRUCTABLE (byte_code_p->status_flags))\n    {\n#if JERRY_ERROR_MESSAGES\n      switch (CBC_FUNCTION_GET_TYPE (byte_code_p->status_flags))\n      {\n        case CBC_FUNCTION_SCRIPT:\n        {\n          return ECMA_ERR_SCRIPT_GLOBAL_FUNCTIONS_INVOKE_WITH_NEW;\n        }\n        case CBC_FUNCTION_GENERATOR:\n        {\n          return ECMA_ERR_GENERATOR_FUNCTIONS_INVOKE_WITH_NEW;\n        }\n        case CBC_FUNCTION_ASYNC:\n        {\n          return ECMA_ERR_ASYNC_FUNCTIONS_INVOKE_WITH_NEW;\n        }\n        case CBC_FUNCTION_ASYNC_GENERATOR:\n        {\n          return ECMA_ERR_ASYNC_GENERATOR_FUNCTIONS_INVOKE_WITH_NEW;\n        }\n        case CBC_FUNCTION_ACCESSOR:\n        {\n          return ECMA_ERR_ACCESSOR_FUNCTIONS_INVOKE_WITH_NEW;\n        }\n        case CBC_FUNCTION_METHOD:\n        {\n          return ECMA_ERR_METHODS_INVOKE_WITH_NEW;\n        }\n        case CBC_FUNCTION_ARROW:\n        {\n          return ECMA_ERR_ARROW_FUNCTIONS_INVOKE_WITH_NEW;\n        }\n        default:\n        {\n          JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (byte_code_p->status_flags) == CBC_FUNCTION_ASYNC_ARROW);\n          return ECMA_ERR_ASYNC_ARROW_FUNCTIONS_INVOKE_WITH_NEW;\n        }\n      }\n#else /* !JERRY_ERROR_MESSAGES */\n      return ECMA_ERR_EMPTY;\n#endif /* JERRY_ERROR_MESSAGES */\n    }\n#endif /* JERRY_NEXT */\n\n    return ECMA_IS_VALID_CONSTRUCTOR;\n  }\n\n#if JERRY_BUILTIN_PROXY\n  if (ECMA_OBJECT_TYPE_IS_PROXY (type))\n  {\n    if (!(obj_p->u2.prototype_cp & ECMA_PROXY_IS_CONSTRUCTABLE))\n    {\n      return ECMA_ERR_PROXY_TARGET_IS_NOT_A_CONSTRUCTOR;\n    }\n\n    return ECMA_IS_VALID_CONSTRUCTOR;\n  }\n#endif /* JERRY_BUILTIN_PROXY */\n\n  JERRY_ASSERT (type == ECMA_OBJECT_TYPE_NATIVE_FUNCTION || type == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION\n                || type == ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION);\n\n  if (type == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION)\n  {\n    if (ecma_builtin_function_is_routine (obj_p))\n    {\n      return ECMA_ERR_BULTIN_ROUTINES_HAVE_NO_CONSTRUCTOR;\n    }\n\n#if JERRY_ESNEXT\n    JERRY_ASSERT (((ecma_extended_object_t *) obj_p)->u.built_in.id != ECMA_BUILTIN_ID_HANDLER);\n#endif /* !JERRY_ESNEXT */\n  }\n\n  return ECMA_IS_VALID_CONSTRUCTOR;\n}",
        "begin_line": 159,
        "end_line": 262,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_create_external_function_object#680",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_create_external_function_object (ecma_native_handler_t handler_cb) /**< pointer to external native handler */",
        "snippet": "ecma_object_t *\necma_op_create_external_function_object (ecma_native_handler_t handler_cb) /**< pointer to external native handler */\n{\n  ecma_object_t *prototype_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_FUNCTION_PROTOTYPE);\n\n  ecma_object_t *function_obj_p =\n    ecma_create_object (prototype_obj_p, sizeof (ecma_native_function_t), ECMA_OBJECT_TYPE_NATIVE_FUNCTION);\n\n  /*\n   * [[Class]] property is not stored explicitly for objects of ECMA_OBJECT_TYPE_NATIVE_FUNCTION type.\n   *\n   * See also: ecma_object_get_class_name\n   */\n\n  ecma_native_function_t *native_function_p = (ecma_native_function_t *) function_obj_p;\n#if JERRY_BUILTIN_REALMS\n  ECMA_SET_INTERNAL_VALUE_POINTER (native_function_p->realm_value, ecma_builtin_get_global ());\n#endif /* JERRY_BUILTIN_REALMS */\n  native_function_p->native_handler_cb = handler_cb;\n\n  return function_obj_p;\n}",
        "begin_line": 680,
        "end_line": 701,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_create_function_object#366",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_create_function_object (ecma_object_t *scope_p, /**< function's scope */                                 const ecma_compiled_code_t *bytecode_data_p, /**< byte-code array */                                 ecma_builtin_id_t proto_id) /**< builtin id of the prototype object */",
        "snippet": "static ecma_object_t *\necma_op_create_function_object (ecma_object_t *scope_p, /**< function's scope */\n                                const ecma_compiled_code_t *bytecode_data_p, /**< byte-code array */\n                                ecma_builtin_id_t proto_id) /**< builtin id of the prototype object */\n{\n  JERRY_ASSERT (ecma_is_lexical_environment (scope_p));\n\n  /* 1., 4., 13. */\n  ecma_object_t *prototype_obj_p = ecma_builtin_get (proto_id);\n\n  size_t function_object_size = sizeof (ecma_extended_object_t);\n\n#if JERRY_SNAPSHOT_EXEC\n  if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)\n  {\n    function_object_size = sizeof (ecma_static_function_t);\n  }\n#endif /* JERRY_SNAPSHOT_EXEC */\n\n  ecma_object_t *func_p = ecma_create_object (prototype_obj_p, function_object_size, ECMA_OBJECT_TYPE_FUNCTION);\n\n  /* 2., 6., 7., 8. */\n  /*\n   * We don't setup [[Get]], [[Call]], [[Construct]], [[HasInstance]] for each function object.\n   * Instead we set the object's type to ECMA_OBJECT_TYPE_FUNCTION\n   * that defines which version of the routine should be used on demand.\n   */\n\n  /* 3. */\n  /*\n   * [[Class]] property is not stored explicitly for objects of ECMA_OBJECT_TYPE_FUNCTION type.\n   *\n   * See also: ecma_object_get_class_name\n   */\n\n  ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_p;\n\n  /* 9. */\n  ECMA_SET_NON_NULL_POINTER_TAG (ext_func_p->u.function.scope_cp, scope_p, 0);\n\n  /* 10., 11., 12. */\n\n#if JERRY_SNAPSHOT_EXEC\n  if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)\n  {\n    ext_func_p->u.function.bytecode_cp = JMEM_CP_NULL;\n    ((ecma_static_function_t *) func_p)->bytecode_p = bytecode_data_p;\n  }\n  else\n#endif /* JERRY_SNAPSHOT_EXEC */\n  {\n    ECMA_SET_INTERNAL_VALUE_POINTER (ext_func_p->u.function.bytecode_cp, bytecode_data_p);\n    ecma_bytecode_ref ((ecma_compiled_code_t *) bytecode_data_p);\n  }\n\n  /* 14., 15., 16., 17., 18. */\n  /*\n   * 'length' and 'prototype' properties are instantiated lazily\n   *\n   * See also: ecma_op_function_try_to_lazy_instantiate_property\n   */\n\n  return func_p;\n}",
        "begin_line": 366,
        "end_line": 429,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_call#1421",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_call (ecma_object_t *func_obj_p, /**< Function object */                        ecma_value_t this_arg_value, /**< 'this' argument's value */                        const ecma_value_t *arguments_list_p, /**< arguments list */                        uint32_t arguments_list_len) /**< length of arguments list */",
        "snippet": "ecma_value_t\necma_op_function_call (ecma_object_t *func_obj_p, /**< Function object */\n                       ecma_value_t this_arg_value, /**< 'this' argument's value */\n                       const ecma_value_t *arguments_list_p, /**< arguments list */\n                       uint32_t arguments_list_len) /**< length of arguments list */\n{\n  JERRY_ASSERT (func_obj_p != NULL && !ecma_is_lexical_environment (func_obj_p));\n\n  ECMA_CHECK_STACK_USAGE ();\n\n#if JERRY_ESNEXT\n  ecma_object_t *old_new_target_p = JERRY_CONTEXT (current_new_target_p);\n\n  if (JERRY_UNLIKELY (!(JERRY_CONTEXT (status_flags) & ECMA_STATUS_DIRECT_EVAL)))\n  {\n    JERRY_CONTEXT (current_new_target_p) = NULL;\n  }\n#endif /* JERRY_ESNEXT */\n\n  ecma_value_t result;\n\n  switch (ecma_get_object_type (func_obj_p))\n  {\n    case ECMA_OBJECT_TYPE_FUNCTION:\n    {\n      result = ecma_op_function_call_simple (func_obj_p, this_arg_value, arguments_list_p, arguments_list_len);\n      break;\n    }\n    case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:\n    {\n      result = ecma_op_function_call_native_built_in (func_obj_p, this_arg_value, arguments_list_p, arguments_list_len);\n      break;\n    }\n#if JERRY_BUILTIN_PROXY\n    case ECMA_OBJECT_TYPE_PROXY:\n    {\n      result = ecma_proxy_object_call (func_obj_p, this_arg_value, arguments_list_p, arguments_list_len);\n      break;\n    }\n#endif /* JERRY_BUILTIN_PROXY */\n#if JERRY_ESNEXT\n    case ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION:\n    {\n      result = ecma_raise_type_error (ECMA_ERR_CLASS_CONSTRUCTOR_NEW);\n      break;\n    }\n#endif /* JERRY_ESNEXT */\n    case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:\n    {\n      result = ecma_op_function_call_native (func_obj_p, this_arg_value, arguments_list_p, arguments_list_len);\n      break;\n    }\n    case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n    {\n      result = ecma_op_function_call_bound (func_obj_p, arguments_list_p, arguments_list_len);\n      break;\n    }\n    default:\n    {\n      result = ecma_raise_type_error (ECMA_ERR_EXPECTED_A_FUNCTION);\n      break;\n    }\n  }\n\n#if JERRY_ESNEXT\n  JERRY_CONTEXT (current_new_target_p) = old_new_target_p;\n#endif /* JERRY_ESNEXT */\n\n  return result;\n}",
        "begin_line": 1421,
        "end_line": 1490,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_call_simple#1104",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_call_simple (ecma_object_t *func_obj_p, /**< Function object */                               ecma_value_t this_binding, /**< 'this' argument's value */                               const ecma_value_t *arguments_list_p, /**< arguments list */                               uint32_t arguments_list_len) /**< length of arguments list */",
        "snippet": "static ecma_value_t\necma_op_function_call_simple (ecma_object_t *func_obj_p, /**< Function object */\n                              ecma_value_t this_binding, /**< 'this' argument's value */\n                              const ecma_value_t *arguments_list_p, /**< arguments list */\n                              uint32_t arguments_list_len) /**< length of arguments list */\n{\n  JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_FUNCTION);\n\n  vm_frame_ctx_shared_args_t shared_args;\n  shared_args.header.status_flags = VM_FRAME_CTX_SHARED_HAS_ARG_LIST;\n  shared_args.header.function_object_p = func_obj_p;\n  shared_args.arg_list_p = arguments_list_p;\n  shared_args.arg_list_len = arguments_list_len;\n\n  /* Entering Function Code (ECMA-262 v5, 10.4.3) */\n  ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_obj_p;\n\n  ecma_object_t *scope_p = ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t, ext_func_p->u.function.scope_cp);\n\n  /* 8. */\n  const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);\n  uint16_t status_flags = bytecode_data_p->status_flags;\n\n  shared_args.header.bytecode_header_p = bytecode_data_p;\n\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *realm_p = ecma_op_function_get_realm (bytecode_data_p);\n#endif /* JERRY_BUILTIN_REALMS */\n\n  /* 5. */\n  if (!(status_flags & CBC_CODE_FLAGS_LEXICAL_ENV_NOT_NEEDED))\n  {\n    shared_args.header.status_flags |= VM_FRAME_CTX_SHARED_FREE_LOCAL_ENV;\n    scope_p = ecma_create_decl_lex_env (scope_p);\n  }\n\n  /* 1. */\n  switch (CBC_FUNCTION_GET_TYPE (status_flags))\n  {\n#if JERRY_ESNEXT\n    case CBC_FUNCTION_CONSTRUCTOR:\n    {\n      return ecma_op_function_call_constructor (&shared_args, scope_p, this_binding);\n    }\n    case CBC_FUNCTION_ARROW:\n    {\n      ecma_arrow_function_t *arrow_func_p = (ecma_arrow_function_t *) func_obj_p;\n\n      if (ecma_is_value_undefined (arrow_func_p->new_target))\n      {\n        JERRY_CONTEXT (current_new_target_p) = NULL;\n      }\n      else\n      {\n        JERRY_CONTEXT (current_new_target_p) = ecma_get_object_from_value (arrow_func_p->new_target);\n      }\n\n      this_binding = arrow_func_p->this_binding;\n\n      if (JERRY_UNLIKELY (this_binding == ECMA_VALUE_UNINITIALIZED))\n      {\n        ecma_environment_record_t *env_record_p = ecma_op_get_environment_record (scope_p);\n        JERRY_ASSERT (env_record_p);\n        this_binding = env_record_p->this_binding;\n      }\n      break;\n    }\n\n#endif /* JERRY_ESNEXT */\n    default:\n    {\n#if JERRY_ESNEXT\n      shared_args.header.status_flags |= VM_FRAME_CTX_SHARED_NON_ARROW_FUNC;\n#endif /* JERRY_ESNEXT */\n\n      if (status_flags & CBC_CODE_FLAGS_STRICT_MODE)\n      {\n        break;\n      }\n\n      if (ecma_is_value_undefined (this_binding) || ecma_is_value_null (this_binding))\n      {\n        /* 2. */\n#if JERRY_BUILTIN_REALMS\n        this_binding = realm_p->this_binding;\n#else /* !JERRY_BUILTIN_REALMS */\n        this_binding = ecma_make_object_value (ecma_builtin_get_global ());\n#endif /* JERRY_BUILTIN_REALMS */\n      }\n      else if (!ecma_is_value_object (this_binding))\n      {\n        /* 3., 4. */\n        this_binding = ecma_op_to_object (this_binding);\n        shared_args.header.status_flags |= VM_FRAME_CTX_SHARED_FREE_THIS;\n\n        JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (this_binding));\n      }\n      break;\n    }\n  }\n\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);\n  JERRY_CONTEXT (global_object_p) = realm_p;\n#endif /* JERRY_BUILTIN_REALMS */\n\n  ecma_value_t ret_value = vm_run (&shared_args.header, this_binding, scope_p);\n\n#if JERRY_BUILTIN_REALMS\n  JERRY_CONTEXT (global_object_p) = saved_global_object_p;\n#endif /* JERRY_BUILTIN_REALMS */\n\n  if (JERRY_UNLIKELY (shared_args.header.status_flags & VM_FRAME_CTX_SHARED_FREE_LOCAL_ENV))\n  {\n    ecma_deref_object (scope_p);\n  }\n\n  if (JERRY_UNLIKELY (shared_args.header.status_flags & VM_FRAME_CTX_SHARED_FREE_THIS))\n  {\n    ecma_free_value (this_binding);\n  }\n\n  return ret_value;\n}",
        "begin_line": 1104,
        "end_line": 1227,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_construct#1764",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_construct (ecma_object_t *func_obj_p, /**< Function object */                             ecma_object_t *new_target_p, /**< new target */                             const ecma_value_t *arguments_list_p, /**< arguments list */                             uint32_t arguments_list_len) /**< length of arguments list */",
        "snippet": "ecma_value_t\necma_op_function_construct (ecma_object_t *func_obj_p, /**< Function object */\n                            ecma_object_t *new_target_p, /**< new target */\n                            const ecma_value_t *arguments_list_p, /**< arguments list */\n                            uint32_t arguments_list_len) /**< length of arguments list */\n{\n  JERRY_ASSERT (func_obj_p != NULL && !ecma_is_lexical_environment (func_obj_p));\n\n\n  switch (ecma_get_object_type (func_obj_p))\n  {\n    case ECMA_OBJECT_TYPE_FUNCTION:\n    {\n      return ecma_op_function_construct_simple (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n    }\n    case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:\n    {\n      return ecma_op_function_construct_built_in (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n    }\n#if JERRY_BUILTIN_PROXY\n    case ECMA_OBJECT_TYPE_PROXY:\n    {\n      return ecma_proxy_object_construct (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n    }\n#endif /* JERRY_BUILTIN_PROXY */\n#if JERRY_ESNEXT\n    case ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION:\n    {\n      return ecma_op_function_construct_constructor (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n    }\n#endif /* JERRY_ESNEXT */\n    case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n    {\n      return ecma_op_function_construct_bound (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n    }\n    case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:\n    {\n      return ecma_op_function_construct_native (func_obj_p, new_target_p, arguments_list_p, arguments_list_len);\n    }\n    default:\n    {\n      JERRY_UNREACHABLE ();\n    }\n  }\n\n  return ECMA_VALUE_UNDEFINED;\n}",
        "begin_line": 1764,
        "end_line": 1810,
        "is_bug": true
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_construct_simple#1498",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_construct_simple (ecma_object_t *func_obj_p, /**< Function object */                                    ecma_object_t *new_target_p, /**< new target */                                    const ecma_value_t *arguments_list_p, /**< arguments list */                                    uint32_t arguments_list_len) /**< length of arguments list */",
        "snippet": "static ecma_value_t\necma_op_function_construct_simple (ecma_object_t *func_obj_p, /**< Function object */\n                                   ecma_object_t *new_target_p, /**< new target */\n                                   const ecma_value_t *arguments_list_p, /**< arguments list */\n                                   uint32_t arguments_list_len) /**< length of arguments list */\n{\n  JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_FUNCTION);\n\n  ecma_object_t *new_this_obj_p = NULL;\n  ecma_value_t this_arg;\n\n#if JERRY_ESNEXT\n  ecma_extended_object_t *ext_func_obj_p = (ecma_extended_object_t *) func_obj_p;\n\n  /* 5. */\n  if (!ECMA_GET_THIRD_BIT_FROM_POINTER_TAG (ext_func_obj_p->u.function.scope_cp))\n  {\n#endif /* JERRY_ESNEXT */\n    /* 5.a */\n    ecma_object_t *proto_p = ecma_op_get_prototype_from_constructor (new_target_p, ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);\n\n    /* 5.b */\n    if (JERRY_UNLIKELY (proto_p == NULL))\n    {\n      return ECMA_VALUE_ERROR;\n    }\n\n    new_this_obj_p = ecma_create_object (proto_p, 0, ECMA_OBJECT_TYPE_GENERAL);\n    ecma_deref_object (proto_p);\n    this_arg = ecma_make_object_value (new_this_obj_p);\n#if JERRY_ESNEXT\n  }\n  else\n  {\n    this_arg = ECMA_VALUE_UNDEFINED;\n  }\n\n  /* 6. */\n  ecma_object_t *old_new_target_p = JERRY_CONTEXT (current_new_target_p);\n  JERRY_CONTEXT (current_new_target_p) = new_target_p;\n#endif /* JERRY_ESNEXT */\n\n  ecma_value_t ret_value = ecma_op_function_call_simple (func_obj_p, this_arg, arguments_list_p, arguments_list_len);\n\n#if JERRY_ESNEXT\n  JERRY_CONTEXT (current_new_target_p) = old_new_target_p;\n#endif /* JERRY_ESNEXT */\n\n  /* 13.a */\n  if (ECMA_IS_VALUE_ERROR (ret_value) || ecma_is_value_object (ret_value))\n  {\n#if JERRY_ESNEXT\n    if (new_this_obj_p != NULL)\n    {\n      ecma_deref_object (new_this_obj_p);\n    }\n#else /* !JERRY_ESNEXT */\n    ecma_deref_object (new_this_obj_p);\n#endif /* JERRY_ESNEXT */\n    return ret_value;\n  }\n\n  /* 13.b */\n  ecma_free_value (ret_value);\n  return this_arg;\n}",
        "begin_line": 1498,
        "end_line": 1563,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_try_to_lazy_instantiate_property#1939",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_function_try_to_lazy_instantiate_property (ecma_object_t *object_p, /**< the function object */                                                    ecma_string_t *property_name_p) /**< property name */",
        "snippet": "ecma_property_t *\necma_op_function_try_to_lazy_instantiate_property (ecma_object_t *object_p, /**< the function object */\n                                                   ecma_string_t *property_name_p) /**< property name */\n{\n  JERRY_ASSERT (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_FUNCTION);\n\n#if JERRY_ESNEXT\n  if (ecma_compare_ecma_string_to_magic_id (property_name_p, LIT_MAGIC_STRING_LENGTH))\n  {\n    ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;\n\n    if (ECMA_GET_FIRST_BIT_FROM_POINTER_TAG (ext_func_p->u.function.scope_cp))\n    {\n      return NULL;\n    }\n\n    /* Initialize 'length' property */\n    const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);\n    uint32_t len;\n\n    if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n    {\n      cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_data_p;\n      len = args_p->argument_end;\n    }\n    else\n    {\n      cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_data_p;\n      len = args_p->argument_end;\n    }\n\n    if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_HAS_EXTENDED_INFO)\n    {\n      uint8_t *extended_info_p = ecma_compiled_code_resolve_extended_info (bytecode_data_p);\n\n      if (*extended_info_p & CBC_EXTENDED_CODE_FLAGS_HAS_ARGUMENT_LENGTH)\n      {\n        len = ecma_extended_info_decode_vlq (&extended_info_p);\n      }\n    }\n\n    ecma_property_t *value_prop_p;\n    ecma_property_value_t *value_p =\n      ecma_create_named_data_property (object_p, property_name_p, ECMA_PROPERTY_BUILT_IN_CONFIGURABLE, &value_prop_p);\n    value_p->value = ecma_make_uint32_value (len);\n    return value_prop_p;\n  }\n\n  if (ecma_compare_ecma_string_to_magic_id (property_name_p, LIT_MAGIC_STRING_NAME))\n  {\n    ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;\n\n    if (ECMA_GET_SECOND_BIT_FROM_POINTER_TAG (ext_func_p->u.function.scope_cp))\n    {\n      return NULL;\n    }\n\n    const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);\n\n    if (CBC_FUNCTION_GET_TYPE (bytecode_data_p->status_flags) == CBC_FUNCTION_CONSTRUCTOR)\n    {\n      return NULL;\n    }\n\n    ecma_value_t value = *ecma_compiled_code_resolve_function_name (bytecode_data_p);\n    JERRY_ASSERT (ecma_is_value_string (value));\n\n    /* Initialize 'name' property */\n    ecma_property_t *value_prop_p;\n    ecma_property_value_t *value_p =\n      ecma_create_named_data_property (object_p, property_name_p, ECMA_PROPERTY_BUILT_IN_CONFIGURABLE, &value_prop_p);\n    value_p->value = ecma_copy_value (value);\n    return value_prop_p;\n  }\n#endif /* JERRY_ESNEXT */\n\n  if (ecma_compare_ecma_string_to_magic_id (property_name_p, LIT_MAGIC_STRING_PROTOTYPE)\n      && ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_FUNCTION)\n  {\n    return ecma_op_lazy_instantiate_prototype_object (object_p);\n  }\n\n  const bool is_arguments = ecma_compare_ecma_string_to_magic_id (property_name_p, LIT_MAGIC_STRING_ARGUMENTS);\n\n  if (is_arguments || ecma_compare_ecma_string_to_magic_id (property_name_p, LIT_MAGIC_STRING_CALLER))\n  {\n    const ecma_compiled_code_t *bytecode_data_p;\n    bytecode_data_p = ecma_op_function_get_compiled_code ((ecma_extended_object_t *) object_p);\n\n#if JERRY_ESNEXT\n    if (!(bytecode_data_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE)\n        && CBC_FUNCTION_GET_TYPE (bytecode_data_p->status_flags) == CBC_FUNCTION_NORMAL)\n    {\n      ecma_property_t *value_prop_p;\n      /* The property_name_p argument contains the name. */\n      ecma_property_value_t *value_p =\n        ecma_create_named_data_property (object_p, property_name_p, ECMA_PROPERTY_BUILT_IN_FIXED, &value_prop_p);\n      value_p->value = is_arguments ? ECMA_VALUE_NULL : ECMA_VALUE_UNDEFINED;\n      return value_prop_p;\n    }\n#else /* !JERRY_ESNEXT */\n    if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE)\n    {\n      ecma_object_t *thrower_p = ecma_builtin_get (ECMA_BUILTIN_ID_TYPE_ERROR_THROWER);\n\n      ecma_property_t *caller_prop_p;\n      /* The property_name_p argument contains the name. */\n      ecma_create_named_accessor_property (object_p,\n                                           property_name_p,\n                                           thrower_p,\n                                           thrower_p,\n                                           ECMA_PROPERTY_BUILT_IN_FIXED,\n                                           &caller_prop_p);\n      return caller_prop_p;\n    }\n#endif /* JERRY_ESNEXT */\n  }\n\n  return NULL;\n}",
        "begin_line": 1939,
        "end_line": 2058,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_get_prototype_from_constructor#980",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_get_prototype_from_constructor (ecma_object_t *ctor_obj_p, /**< constructor to get prototype from  */                                         ecma_builtin_id_t default_proto_id) /**< intrinsicDefaultProto */",
        "snippet": "ecma_object_t *\necma_op_get_prototype_from_constructor (ecma_object_t *ctor_obj_p, /**< constructor to get prototype from  */\n                                        ecma_builtin_id_t default_proto_id) /**< intrinsicDefaultProto */\n{\n  JERRY_ASSERT (ecma_op_object_is_callable (ctor_obj_p));\n  JERRY_ASSERT (default_proto_id < ECMA_BUILTIN_ID__COUNT);\n\n  ecma_value_t proto = ecma_op_object_get_by_magic_id (ctor_obj_p, LIT_MAGIC_STRING_PROTOTYPE);\n\n  if (ECMA_IS_VALUE_ERROR (proto))\n  {\n    return NULL;\n  }\n\n  ecma_object_t *proto_obj_p;\n\n  if (!ecma_is_value_object (proto))\n  {\n    ecma_free_value (proto);\n\n#if JERRY_BUILTIN_PROXY\n    if (ECMA_OBJECT_IS_PROXY (ctor_obj_p))\n    {\n      ecma_proxy_object_t *proxy_obj_p = (ecma_proxy_object_t *) ctor_obj_p;\n      if (ecma_is_value_null (proxy_obj_p->handler))\n      {\n        ecma_raise_type_error (ECMA_ERR_PROTOTYPE_FROM_REVOKED_PROXY_IS_INVALID);\n        return NULL;\n      }\n    }\n#endif /* JERRY_BUILTIN_PROXY */\n\n#if JERRY_BUILTIN_REALMS\n    proto_obj_p = ecma_builtin_get_from_realm (ecma_op_function_get_function_realm (ctor_obj_p), default_proto_id);\n#else /* !JERRY_BUILTIN_REALMS */\n    proto_obj_p = ecma_builtin_get (default_proto_id);\n#endif /* JERRY_BUILTIN_REALMS */\n    ecma_ref_object (proto_obj_p);\n  }\n  else\n  {\n    proto_obj_p = ecma_get_object_from_value (proto);\n  }\n\n  return proto_obj_p;\n}",
        "begin_line": 980,
        "end_line": 1025,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-function-object.ecma_op_lazy_instantiate_prototype_object#1817",
        "src_path": "jerry-core/ecma/operations/ecma-function-object.c",
        "class_name": "jerry-core.ecma.operations.ecma-function-object",
        "signature": "jerry-core.ecma.operations.ecma-function-object.ecma_op_lazy_instantiate_prototype_object (ecma_object_t *object_p) /**< the function object */",
        "snippet": "static ecma_property_t *\necma_op_lazy_instantiate_prototype_object (ecma_object_t *object_p) /**< the function object */\n{\n  JERRY_ASSERT (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_FUNCTION\n                || ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_NATIVE_FUNCTION);\n\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *global_object_p;\n\n  if (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_FUNCTION)\n  {\n    const ecma_compiled_code_t *bytecode_data_p;\n    bytecode_data_p = ecma_op_function_get_compiled_code ((ecma_extended_object_t *) object_p);\n\n    global_object_p = ecma_op_function_get_realm (bytecode_data_p);\n  }\n  else\n  {\n    ecma_native_function_t *native_function_p = (ecma_native_function_t *) object_p;\n\n    global_object_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_global_object_t, native_function_p->realm_value);\n  }\n#endif /* JERRY_BUILTIN_REALMS */\n\n  /* ECMA-262 v5, 13.2, 16-18 */\n\n  ecma_object_t *proto_object_p = NULL;\n  bool init_constructor = true;\n\n#if JERRY_ESNEXT\n  if (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_FUNCTION)\n  {\n    const ecma_compiled_code_t *byte_code_p = ecma_op_function_get_compiled_code ((ecma_extended_object_t *) object_p);\n\n    if (!CBC_FUNCTION_HAS_PROTOTYPE (byte_code_p->status_flags))\n    {\n      return NULL;\n    }\n\n    if (CBC_FUNCTION_GET_TYPE (byte_code_p->status_flags) == CBC_FUNCTION_GENERATOR)\n    {\n      ecma_object_t *prototype_p;\n\n#if JERRY_BUILTIN_REALMS\n      prototype_p = ecma_builtin_get_from_realm (global_object_p, ECMA_BUILTIN_ID_GENERATOR_PROTOTYPE);\n#else /* !JERRY_BUILTIN_REALMS */\n      prototype_p = ecma_builtin_get (ECMA_BUILTIN_ID_GENERATOR_PROTOTYPE);\n#endif /* JERRY_BUILTIN_REALMS */\n\n      proto_object_p = ecma_create_object (prototype_p, 0, ECMA_OBJECT_TYPE_GENERAL);\n      init_constructor = false;\n    }\n\n    if (CBC_FUNCTION_GET_TYPE (byte_code_p->status_flags) == CBC_FUNCTION_ASYNC_GENERATOR)\n    {\n      ecma_object_t *prototype_p;\n\n#if JERRY_BUILTIN_REALMS\n      prototype_p = ecma_builtin_get_from_realm (global_object_p, ECMA_BUILTIN_ID_ASYNC_GENERATOR_PROTOTYPE);\n#else /* !JERRY_BUILTIN_REALMS */\n      prototype_p = ecma_builtin_get (ECMA_BUILTIN_ID_ASYNC_GENERATOR_PROTOTYPE);\n#endif /* JERRY_BUILTIN_REALMS */\n\n      proto_object_p = ecma_create_object (prototype_p, 0, ECMA_OBJECT_TYPE_GENERAL);\n      init_constructor = false;\n    }\n  }\n#endif /* JERRY_ESNEXT */\n\n#if JERRY_ESNEXT\n  if (proto_object_p == NULL)\n#endif /* JERRY_ESNEXT */\n  {\n    ecma_object_t *prototype_p;\n\n#if JERRY_BUILTIN_REALMS\n    prototype_p = ecma_builtin_get_from_realm (global_object_p, ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);\n#else /* !JERRY_BUILTIN_REALMS */\n    prototype_p = ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);\n#endif /* JERRY_BUILTIN_REALMS */\n\n    proto_object_p = ecma_op_create_object_object_noarg_and_set_prototype (prototype_p);\n  }\n\n  /* 17. */\n  if (init_constructor)\n  {\n    ecma_property_value_t *constructor_prop_value_p;\n    constructor_prop_value_p = ecma_create_named_data_property (proto_object_p,\n                                                                ecma_get_magic_string (LIT_MAGIC_STRING_CONSTRUCTOR),\n                                                                ECMA_PROPERTY_CONFIGURABLE_WRITABLE,\n                                                                NULL);\n\n    constructor_prop_value_p->value = ecma_make_object_value (object_p);\n  }\n\n  /* 18. */\n  ecma_property_t *prototype_prop_p;\n  ecma_property_value_t *prototype_prop_value_p;\n  prototype_prop_value_p = ecma_create_named_data_property (object_p,\n                                                            ecma_get_magic_string (LIT_MAGIC_STRING_PROTOTYPE),\n                                                            ECMA_PROPERTY_BUILT_IN_WRITABLE,\n                                                            &prototype_prop_p);\n\n  prototype_prop_value_p->value = ecma_make_object_value (proto_object_p);\n\n  ecma_deref_object (proto_object_p);\n\n  return prototype_prop_p;\n}",
        "begin_line": 1817,
        "end_line": 1926,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-get-put-value.ecma_op_put_value_lex_env_base#225",
        "src_path": "jerry-core/ecma/operations/ecma-get-put-value.c",
        "class_name": "jerry-core.ecma.operations.ecma-get-put-value",
        "signature": "jerry-core.ecma.operations.ecma-get-put-value.ecma_op_put_value_lex_env_base (ecma_object_t *lex_env_p, /**< lexical environment */                                 ecma_string_t *name_p, /**< variable name */                                 bool is_strict, /**< flag indicating strict mode */                                 ecma_value_t value) /**< ECMA-value */",
        "snippet": "ecma_value_t\necma_op_put_value_lex_env_base (ecma_object_t *lex_env_p, /**< lexical environment */\n                                ecma_string_t *name_p, /**< variable name */\n                                bool is_strict, /**< flag indicating strict mode */\n                                ecma_value_t value) /**< ECMA-value */\n{\n  JERRY_ASSERT (lex_env_p != NULL && ecma_is_lexical_environment (lex_env_p));\n\n  while (true)\n  {\n    switch (ecma_get_lex_env_type (lex_env_p))\n    {\n#if JERRY_ESNEXT\n      case ECMA_LEXICAL_ENVIRONMENT_CLASS:\n      {\n        if (!ECMA_LEX_ENV_CLASS_IS_MODULE (lex_env_p))\n        {\n          break;\n        }\n        /* FALLTHRU */\n      }\n#endif /* JERRY_ESNEXT */\n      case ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE:\n      {\n        ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n        if (property_p != NULL)\n        {\n#if JERRY_ESNEXT\n          ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n          JERRY_ASSERT (!(*property_p & ECMA_PROPERTY_FLAG_WRITABLE) || (*property_p & ECMA_PROPERTY_FLAG_DATA));\n\n          if ((*property_p & ECMA_PROPERTY_FLAG_WRITABLE) && property_value_p->value != ECMA_VALUE_UNINITIALIZED)\n          {\n            ecma_named_data_property_assign_value (lex_env_p, property_value_p, value);\n            return ECMA_VALUE_EMPTY;\n          }\n#else /* JERRY_ESNEXT */\n          if (ecma_is_property_writable (*property_p))\n          {\n            ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n            ecma_named_data_property_assign_value (lex_env_p, property_value_p, value);\n            return ECMA_VALUE_EMPTY;\n          }\n#endif /* JERRY_ESNEXT */\n\n          return ecma_op_raise_set_binding_error (property_p, is_strict);\n        }\n        break;\n      }\n      default:\n      {\n        JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n\n        ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);\n\n        ecma_value_t has_property = ecma_op_object_has_property (binding_obj_p, name_p);\n\n#if JERRY_BUILTIN_PROXY\n        if (ECMA_IS_VALUE_ERROR (has_property))\n        {\n          return has_property;\n        }\n#endif /* JERRY_BUILTIN_PROXY */\n\n        if (ecma_is_value_true (has_property))\n        {\n          ecma_value_t completion = ecma_op_object_put (binding_obj_p, name_p, value, is_strict);\n\n          if (ECMA_IS_VALUE_ERROR (completion))\n          {\n            return completion;\n          }\n\n          JERRY_ASSERT (ecma_is_value_boolean (completion));\n          return ECMA_VALUE_EMPTY;\n        }\n\n        break;\n      }\n    }\n\n    if (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);\n  }\n\n  JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n\n  if (is_strict)\n  {\n#if JERRY_ERROR_MESSAGES\n    return ecma_raise_standard_error_with_format (JERRY_ERROR_REFERENCE,\n                                                  \"% is not defined\",\n                                                  ecma_make_string_value (name_p));\n#else /* !JERRY_ERROR_MESSAGES */\n    return ecma_raise_reference_error (ECMA_ERR_EMPTY);\n#endif /* JERRY_ERROR_MESSAGES */\n  }\n\n  ecma_value_t completion = ecma_op_object_put (ecma_get_lex_env_binding_object (lex_env_p), name_p, value, false);\n\n  JERRY_ASSERT (ecma_is_value_boolean (completion));\n\n  return ECMA_VALUE_EMPTY;\n}",
        "begin_line": 225,
        "end_line": 334,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_get_global_scope#135",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_get_global_scope (ecma_object_t *global_object_p) /**< global object */",
        "snippet": "ecma_object_t *\necma_get_global_scope (ecma_object_t *global_object_p) /**< global object */\n{\n#if JERRY_ESNEXT\n  JERRY_ASSERT (global_object_p != NULL && ecma_builtin_is_global (global_object_p));\n  return ECMA_GET_NON_NULL_POINTER (ecma_object_t, ((ecma_global_object_t *) global_object_p)->global_scope_cp);\n#else /* !JERRY_ESNEXT */\n  return ecma_get_global_environment (global_object_p);\n#endif /* !JERRY_ESNEXT */\n}",
        "begin_line": 135,
        "end_line": 144,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_init_global_environment#42",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_init_global_environment (void)",
        "snippet": "void\necma_init_global_environment (void)\n{\n  JERRY_CONTEXT (global_object_p) = ecma_builtin_create_global_object ();\n}",
        "begin_line": 42,
        "end_line": 46,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_create_mutable_binding#203",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_create_mutable_binding (ecma_object_t *lex_env_p, /**< lexical environment */                                 ecma_string_t *name_p, /**< argument N */                                 bool is_deletable) /**< argument D */",
        "snippet": "ecma_property_t *\necma_op_create_mutable_binding (ecma_object_t *lex_env_p, /**< lexical environment */\n                                ecma_string_t *name_p, /**< argument N */\n                                bool is_deletable) /**< argument D */\n{\n  JERRY_ASSERT (lex_env_p != NULL && ecma_is_lexical_environment (lex_env_p));\n  JERRY_ASSERT (name_p != NULL);\n\n  if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)\n  {\n    uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;\n\n    if (is_deletable)\n    {\n      prop_attributes = (uint8_t) (prop_attributes | ECMA_PROPERTY_FLAG_CONFIGURABLE);\n    }\n\n    ecma_property_t *prop_p;\n\n    ecma_create_named_data_property (lex_env_p, name_p, prop_attributes, &prop_p);\n    return prop_p;\n  }\n  else\n  {\n    JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n\n    ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);\n\n#if JERRY_BUILTIN_PROXY && JERRY_BUILTIN_REALMS\n    if (ECMA_OBJECT_IS_PROXY (binding_obj_p))\n    {\n      ecma_value_t result = ecma_proxy_object_is_extensible (binding_obj_p);\n\n      if (ECMA_IS_VALUE_ERROR (result))\n      {\n        return ECMA_PROPERTY_POINTER_ERROR;\n      }\n\n      if (result == ECMA_VALUE_FALSE)\n      {\n        return NULL;\n      }\n    }\n    else if (!ecma_op_ordinary_object_is_extensible (binding_obj_p))\n    {\n      return NULL;\n    }\n#else /* !JERRY_BUILTIN_PROXY || !JERRY_BUILTIN_REALMS */\n    if (!ecma_op_ordinary_object_is_extensible (binding_obj_p))\n    {\n      return NULL;\n    }\n#endif /* JERRY_BUILTIN_PROXY && JERRY_BUILTIN_REALMS */\n\n    const uint32_t flags = ECMA_PROPERTY_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;\n\n    ecma_value_t completion =\n      ecma_builtin_helper_def_prop (binding_obj_p,\n                                    name_p,\n                                    ECMA_VALUE_UNDEFINED,\n                                    is_deletable ? flags | ECMA_PROPERTY_FLAG_CONFIGURABLE : flags);\n\n    if (ECMA_IS_VALUE_ERROR (completion))\n    {\n      return ECMA_PROPERTY_POINTER_ERROR;\n    }\n    else\n    {\n      JERRY_ASSERT (ecma_is_value_boolean (completion));\n    }\n  }\n\n  return NULL;\n}",
        "begin_line": 203,
        "end_line": 276,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_has_binding#157",
        "src_path": "jerry-core/ecma/operations/ecma-lex-env.c",
        "class_name": "jerry-core.ecma.operations.ecma-lex-env",
        "signature": "jerry-core.ecma.operations.ecma-lex-env.ecma_op_has_binding (ecma_object_t *lex_env_p, /**< lexical environment */                      ecma_string_t *name_p) /**< argument N */",
        "snippet": "ecma_value_t\necma_op_has_binding (ecma_object_t *lex_env_p, /**< lexical environment */\n                     ecma_string_t *name_p) /**< argument N */\n{\n  JERRY_ASSERT (lex_env_p != NULL && ecma_is_lexical_environment (lex_env_p));\n\n  ecma_lexical_environment_type_t lex_env_type = ecma_get_lex_env_type (lex_env_p);\n\n  switch (lex_env_type)\n  {\n#if JERRY_ESNEXT\n    case ECMA_LEXICAL_ENVIRONMENT_CLASS:\n    {\n      if (!ECMA_LEX_ENV_CLASS_IS_MODULE (lex_env_p))\n      {\n        return ECMA_VALUE_FALSE;\n      }\n      /* FALLTHRU */\n    }\n#endif /* JERRY_ESNEXT */\n    case ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE:\n    {\n      ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n      return ecma_make_boolean_value (property_p != NULL);\n    }\n    default:\n    {\n      JERRY_ASSERT (lex_env_type == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n\n      ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);\n\n      return ecma_op_object_has_property (binding_obj_p, name_p);\n    }\n  }\n}",
        "begin_line": 157,
        "end_line": 192,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects-general.ecma_op_create_object_object_noarg_and_set_prototype#60",
        "src_path": "jerry-core/ecma/operations/ecma-objects-general.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects-general",
        "signature": "jerry-core.ecma.operations.ecma-objects-general.ecma_op_create_object_object_noarg_and_set_prototype (ecma_object_t *object_prototype_p) /**< pointer to prototype of                                                                                               the object                                                                                               (can be NULL) */",
        "snippet": "ecma_object_t *\necma_op_create_object_object_noarg_and_set_prototype (ecma_object_t *object_prototype_p) /**< pointer to prototype of\n                                                                                              the object\n                                                                                              (can be NULL) */\n{\n  ecma_object_t *obj_p = ecma_create_object (object_prototype_p, 0, ECMA_OBJECT_TYPE_GENERAL);\n\n  /*\n   * [[Class]] property of ECMA_OBJECT_TYPE_GENERAL type objects\n   * without ECMA_INTERNAL_PROPERTY_CLASS internal property\n   * is \"Object\".\n   *\n   * See also: ecma_object_get_class_name\n   */\n\n  return obj_p;\n}",
        "begin_line": 60,
        "end_line": 76,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects-general.ecma_op_general_object_define_own_property#356",
        "src_path": "jerry-core/ecma/operations/ecma-objects-general.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects-general",
        "signature": "jerry-core.ecma.operations.ecma-objects-general.ecma_op_general_object_define_own_property (ecma_object_t *object_p, /**< the object */                                             ecma_string_t *property_name_p, /**< property name */                                             const ecma_property_descriptor_t *property_desc_p) /**< property                                                                                                 *   descriptor */",
        "snippet": "ecma_value_t\necma_op_general_object_define_own_property (ecma_object_t *object_p, /**< the object */\n                                            ecma_string_t *property_name_p, /**< property name */\n                                            const ecma_property_descriptor_t *property_desc_p) /**< property\n                                                                                                *   descriptor */\n{\n#if JERRY_BUILTIN_PROXY\n  if (ECMA_OBJECT_IS_PROXY (object_p))\n  {\n    return ecma_proxy_object_define_own_property (object_p, property_name_p, property_desc_p);\n  }\n#endif /* JERRY_BUILTIN_PROXY */\n\n  JERRY_ASSERT (object_p != NULL && !ecma_is_lexical_environment (object_p));\n  JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));\n  JERRY_ASSERT (property_name_p != NULL);\n\n  uint8_t property_desc_type = ECMA_OP_OBJECT_DEFINE_GENERIC;\n\n  if (property_desc_p->flags & (JERRY_PROP_IS_VALUE_DEFINED | JERRY_PROP_IS_WRITABLE_DEFINED))\n  {\n    /* A property descriptor cannot be both named data and named accessor. */\n    JERRY_ASSERT ((property_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED))\n                  != (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED));\n    property_desc_type = ECMA_OP_OBJECT_DEFINE_DATA;\n  }\n  else if (property_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED))\n  {\n    JERRY_ASSERT (!(property_desc_p->flags & JERRY_PROP_IS_WRITABLE_DEFINED));\n    property_desc_type = ECMA_OP_OBJECT_DEFINE_ACCESSOR;\n  }\n\n  /* These three asserts ensures that a new property is created with the appropriate default flags.\n   * E.g. if JERRY_PROP_IS_CONFIGURABLE_DEFINED is false, the newly created property must be non-configurable. */\n  JERRY_ASSERT ((property_desc_p->flags & JERRY_PROP_IS_CONFIGURABLE_DEFINED)\n                || !(property_desc_p->flags & JERRY_PROP_IS_CONFIGURABLE));\n  JERRY_ASSERT ((property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE_DEFINED)\n                || !(property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE));\n  JERRY_ASSERT ((property_desc_p->flags & JERRY_PROP_IS_WRITABLE_DEFINED)\n                || !(property_desc_p->flags & JERRY_PROP_IS_WRITABLE));\n\n  /* 1. */\n  ecma_extended_property_ref_t ext_property_ref = { .property_ref.value_p = NULL, .property_p = NULL };\n  ecma_property_t current_prop;\n\n  current_prop = ecma_op_object_get_own_property (object_p,\n                                                  property_name_p,\n                                                  &ext_property_ref.property_ref,\n                                                  ECMA_PROPERTY_GET_VALUE | ECMA_PROPERTY_GET_EXT_REFERENCE);\n\n  if (!ECMA_PROPERTY_IS_FOUND (current_prop))\n  {\n    JERRY_ASSERT (current_prop == ECMA_PROPERTY_TYPE_NOT_FOUND\n                  || current_prop == ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP);\n\n    /* 3. */\n    if (!ecma_op_ordinary_object_is_extensible (object_p))\n    {\n      /* 2. */\n      return ECMA_REJECT_WITH_FORMAT (property_desc_p->flags & JERRY_PROP_SHOULD_THROW,\n                                      \"Cannot define property '%', object is not extensible\",\n                                      ecma_make_prop_name_value (property_name_p));\n    }\n\n    /* 4. */\n    uint8_t prop_attributes = (uint8_t) (property_desc_p->flags & ECMA_PROPERTY_FLAGS_MASK);\n\n    if (property_desc_type != ECMA_OP_OBJECT_DEFINE_ACCESSOR)\n    {\n      /* a. */\n      JERRY_ASSERT (property_desc_type == ECMA_OP_OBJECT_DEFINE_GENERIC\n                    || property_desc_type == ECMA_OP_OBJECT_DEFINE_DATA);\n\n      ecma_property_value_t *new_prop_value_p =\n        ecma_create_named_data_property (object_p, property_name_p, prop_attributes, NULL);\n\n      JERRY_ASSERT ((property_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)\n                    || ecma_is_value_undefined (property_desc_p->value));\n\n      new_prop_value_p->value = ecma_copy_value_if_not_object (property_desc_p->value);\n    }\n    else\n    {\n      /* b. */\n      ecma_create_named_accessor_property (object_p,\n                                           property_name_p,\n                                           property_desc_p->get_p,\n                                           property_desc_p->set_p,\n                                           prop_attributes,\n                                           NULL);\n    }\n\n    return ECMA_VALUE_TRUE;\n  }\n\n  /* 6. */\n  const bool is_current_configurable = ecma_is_property_configurable (current_prop);\n\n  /* 7. a., b. */\n  bool is_enumerable = (property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE) != 0;\n  if (!is_current_configurable\n      && ((property_desc_p->flags & JERRY_PROP_IS_CONFIGURABLE)\n          || ((property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE_DEFINED)\n              && (is_enumerable != ecma_is_property_enumerable (current_prop)))))\n  {\n    if (ECMA_PROPERTY_IS_VIRTUAL (current_prop))\n    {\n      ecma_free_value (ext_property_ref.property_ref.virtual_value);\n    }\n\n    return ecma_raise_property_redefinition (property_name_p, property_desc_p->flags);\n  }\n\n  if (ECMA_PROPERTY_IS_VIRTUAL (current_prop))\n  {\n    bool writable_check_failed = (property_desc_p->flags & JERRY_PROP_IS_WRITABLE);\n\n#if JERRY_MODULE_SYSTEM\n    if (ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_MODULE_NAMESPACE))\n    {\n      if (JERRY_UNLIKELY (ext_property_ref.property_ref.virtual_value == ECMA_VALUE_UNINITIALIZED))\n      {\n        return ecma_raise_reference_error (ECMA_ERR_LET_CONST_NOT_INITIALIZED);\n      }\n\n      if (property_desc_p->flags & JERRY_PROP_IS_WRITABLE_DEFINED)\n      {\n        writable_check_failed = ((property_desc_p->flags ^ current_prop) & JERRY_PROP_IS_WRITABLE) != 0;\n      }\n    }\n    else\n    {\n      JERRY_ASSERT (!is_current_configurable && !ecma_is_property_writable (current_prop));\n    }\n#else /* !JERRY_MODULE_SYSTEM */\n    JERRY_ASSERT (!is_current_configurable && !ecma_is_property_writable (current_prop));\n#endif /* JERRY_MODULE_SYSTEM */\n\n    ecma_value_t result = ECMA_VALUE_TRUE;\n\n    if (property_desc_type == ECMA_OP_OBJECT_DEFINE_ACCESSOR || writable_check_failed\n        || ((property_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)\n            && !ecma_op_same_value (property_desc_p->value, ext_property_ref.property_ref.virtual_value)))\n    {\n      result = ecma_raise_property_redefinition (property_name_p, property_desc_p->flags);\n    }\n\n    ecma_free_value (ext_property_ref.property_ref.virtual_value);\n    return result;\n  }\n\n  /* 8. */\n  if (property_desc_type == ECMA_OP_OBJECT_DEFINE_GENERIC)\n  {\n    /* No action required. */\n  }\n  else if (JERRY_LIKELY (property_desc_type == (current_prop & ECMA_PROPERTY_FLAG_DATA)))\n  {\n    /* If property is configurable, there is no need for checks. */\n    if (JERRY_UNLIKELY (!is_current_configurable))\n    {\n      if (property_desc_type == ECMA_OP_OBJECT_DEFINE_DATA)\n      {\n        /* 10. a. i. & ii. */\n        if (!ecma_is_property_writable (current_prop)\n            && ((property_desc_p->flags & JERRY_PROP_IS_WRITABLE)\n                || ((property_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)\n                    && !ecma_op_same_value (property_desc_p->value, ext_property_ref.property_ref.value_p->value))))\n        {\n          return ecma_raise_property_redefinition (property_name_p, property_desc_p->flags);\n        }\n      }\n      else\n      {\n        /* 11. */\n\n        /* a. */\n        ecma_property_value_t *value_p = ext_property_ref.property_ref.value_p;\n\n        ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (value_p);\n        jmem_cpointer_t prop_desc_getter_cp, prop_desc_setter_cp;\n        ECMA_SET_POINTER (prop_desc_getter_cp, property_desc_p->get_p);\n        ECMA_SET_POINTER (prop_desc_setter_cp, property_desc_p->set_p);\n\n        if (((property_desc_p->flags & JERRY_PROP_IS_GET_DEFINED) && prop_desc_getter_cp != get_set_pair_p->getter_cp)\n            || ((property_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)\n                && prop_desc_setter_cp != get_set_pair_p->setter_cp))\n        {\n          /* i., ii. */\n          return ecma_raise_property_redefinition (property_name_p, property_desc_p->flags);\n        }\n      }\n    }\n  }\n  else\n  {\n    /* 9. */\n    if (!is_current_configurable)\n    {\n      /* a. */\n      return ecma_raise_property_redefinition (property_name_p, property_desc_p->flags);\n    }\n\n    ecma_property_value_t *value_p = ext_property_ref.property_ref.value_p;\n\n    if (property_desc_type == ECMA_OP_OBJECT_DEFINE_ACCESSOR)\n    {\n      JERRY_ASSERT (current_prop & ECMA_PROPERTY_FLAG_DATA);\n      ecma_free_value_if_not_object (value_p->value);\n\n#if JERRY_CPOINTER_32_BIT\n      ecma_getter_setter_pointers_t *getter_setter_pair_p;\n      getter_setter_pair_p = jmem_pools_alloc (sizeof (ecma_getter_setter_pointers_t));\n      getter_setter_pair_p->getter_cp = JMEM_CP_NULL;\n      getter_setter_pair_p->setter_cp = JMEM_CP_NULL;\n      ECMA_SET_NON_NULL_POINTER (value_p->getter_setter_pair_cp, getter_setter_pair_p);\n#else /* !JERRY_CPOINTER_32_BIT */\n      value_p->getter_setter_pair.getter_cp = JMEM_CP_NULL;\n      value_p->getter_setter_pair.setter_cp = JMEM_CP_NULL;\n#endif /* JERRY_CPOINTER_32_BIT */\n    }\n    else\n    {\n      JERRY_ASSERT (!(current_prop & ECMA_PROPERTY_FLAG_DATA));\n#if JERRY_CPOINTER_32_BIT\n      ecma_getter_setter_pointers_t *getter_setter_pair_p;\n      getter_setter_pair_p = ECMA_GET_NON_NULL_POINTER (ecma_getter_setter_pointers_t, value_p->getter_setter_pair_cp);\n      jmem_pools_free (getter_setter_pair_p, sizeof (ecma_getter_setter_pointers_t));\n#endif /* JERRY_CPOINTER_32_BIT */\n      value_p->value = ECMA_VALUE_UNDEFINED;\n    }\n\n    /* Update flags */\n    ecma_property_t prop_flags = *(ext_property_ref.property_p);\n    prop_flags = (ecma_property_t) (prop_flags & ~ECMA_PROPERTY_FLAG_WRITABLE);\n    prop_flags ^= ECMA_PROPERTY_FLAG_DATA;\n    *(ext_property_ref.property_p) = prop_flags;\n  }\n\n  /* 12. */\n  if (property_desc_type == ECMA_OP_OBJECT_DEFINE_DATA)\n  {\n    JERRY_ASSERT (ECMA_PROPERTY_IS_RAW_DATA (*ext_property_ref.property_p));\n\n    if (property_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)\n    {\n      ecma_named_data_property_assign_value (object_p, ext_property_ref.property_ref.value_p, property_desc_p->value);\n    }\n\n    if (property_desc_p->flags & JERRY_PROP_IS_WRITABLE_DEFINED)\n    {\n      ecma_set_property_writable_attr (ext_property_ref.property_p, (property_desc_p->flags & JERRY_PROP_IS_WRITABLE));\n    }\n  }\n  else if (property_desc_type == ECMA_OP_OBJECT_DEFINE_ACCESSOR)\n  {\n    JERRY_ASSERT (!(*ext_property_ref.property_p & ECMA_PROPERTY_FLAG_DATA));\n\n    if (property_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)\n    {\n      ecma_set_named_accessor_property_getter (object_p, ext_property_ref.property_ref.value_p, property_desc_p->get_p);\n    }\n\n    if (property_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)\n    {\n      ecma_set_named_accessor_property_setter (object_p, ext_property_ref.property_ref.value_p, property_desc_p->set_p);\n    }\n  }\n\n  if (property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE_DEFINED)\n  {\n    ecma_set_property_enumerable_attr (ext_property_ref.property_p,\n                                       (property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE));\n  }\n\n  if (property_desc_p->flags & JERRY_PROP_IS_CONFIGURABLE_DEFINED)\n  {\n    ecma_set_property_configurable_attr (ext_property_ref.property_p,\n                                         (property_desc_p->flags & JERRY_PROP_IS_CONFIGURABLE));\n  }\n\n  return ECMA_VALUE_TRUE;\n}",
        "begin_line": 356,
        "end_line": 638,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_define_own_property#1792",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_define_own_property (ecma_object_t *obj_p, /**< the object */                                     ecma_string_t *property_name_p, /**< property name */                                     const ecma_property_descriptor_t *property_desc_p) /**< property                                                                                         *   descriptor */",
        "snippet": "ecma_value_t\necma_op_object_define_own_property (ecma_object_t *obj_p, /**< the object */\n                                    ecma_string_t *property_name_p, /**< property name */\n                                    const ecma_property_descriptor_t *property_desc_p) /**< property\n                                                                                        *   descriptor */\n{\n  JERRY_ASSERT (obj_p != NULL && !ecma_is_lexical_environment (obj_p));\n  JERRY_ASSERT (property_name_p != NULL);\n\n  const ecma_object_type_t type = ecma_get_object_type (obj_p);\n\n  switch (type)\n  {\n    case ECMA_OBJECT_TYPE_CLASS:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n      switch (ext_object_p->u.cls.type)\n      {\n        case ECMA_OBJECT_CLASS_ARGUMENTS:\n        {\n          return ecma_op_arguments_object_define_own_property (obj_p, property_name_p, property_desc_p);\n        }\n#if JERRY_BUILTIN_TYPEDARRAY\n        /* ES2015 9.4.5.1 */\n        case ECMA_OBJECT_CLASS_TYPEDARRAY:\n        {\n          return ecma_op_typedarray_define_own_property (obj_p, property_name_p, property_desc_p);\n        }\n#endif /* JERRY_BUILTIN_TYPEDARRAY */\n      }\n      break;\n    }\n    case ECMA_OBJECT_TYPE_ARRAY:\n    case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:\n    {\n      return ecma_op_array_object_define_own_property (obj_p, property_name_p, property_desc_p);\n    }\n#if JERRY_BUILTIN_PROXY\n    case ECMA_OBJECT_TYPE_PROXY:\n    {\n      return ecma_proxy_object_define_own_property (obj_p, property_name_p, property_desc_p);\n    }\n#endif /* JERRY_BUILTIN_PROXY */\n    default:\n    {\n      break;\n    }\n  }\n\n  return ecma_op_general_object_define_own_property (obj_p, property_name_p, property_desc_p);\n}",
        "begin_line": 1792,
        "end_line": 1843,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_find_own#489",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_find_own (ecma_value_t base_value, /**< base value */                          ecma_object_t *object_p, /**< target object */                          ecma_string_t *property_name_p) /**< property name */",
        "snippet": "ecma_value_t\necma_op_object_find_own (ecma_value_t base_value, /**< base value */\n                         ecma_object_t *object_p, /**< target object */\n                         ecma_string_t *property_name_p) /**< property name */\n{\n  JERRY_ASSERT (object_p != NULL && !ecma_is_lexical_environment (object_p));\n  JERRY_ASSERT (property_name_p != NULL);\n  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));\n\n  ecma_object_base_type_t base_type = ecma_get_object_base_type (object_p);\n\n  switch (base_type)\n  {\n    case ECMA_OBJECT_BASE_TYPE_CLASS:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      switch (ext_object_p->u.cls.type)\n      {\n        case ECMA_OBJECT_CLASS_STRING:\n        {\n          if (ecma_string_is_length (property_name_p))\n          {\n            ecma_value_t prim_value_p = ext_object_p->u.cls.u3.value;\n\n            ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);\n            lit_utf8_size_t length = ecma_string_get_length (prim_value_str_p);\n\n            return ecma_make_uint32_value (length);\n          }\n\n          uint32_t index = ecma_string_get_array_index (property_name_p);\n\n          if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n          {\n            ecma_value_t prim_value_p = ext_object_p->u.cls.u3.value;\n\n            ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);\n\n            if (index < ecma_string_get_length (prim_value_str_p))\n            {\n              ecma_char_t char_at_idx = ecma_string_get_char_at_pos (prim_value_str_p, index);\n              return ecma_make_string_value (ecma_new_ecma_string_from_code_unit (char_at_idx));\n            }\n          }\n          break;\n        }\n        case ECMA_OBJECT_CLASS_ARGUMENTS:\n        {\n          if (!(ext_object_p->u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED))\n          {\n            break;\n          }\n\n          uint32_t index = ecma_string_get_array_index (property_name_p);\n\n          if (index < ext_object_p->u.cls.u2.formal_params_number)\n          {\n            ecma_mapped_arguments_t *mapped_arguments_p = (ecma_mapped_arguments_t *) ext_object_p;\n\n            ecma_value_t *argv_p = (ecma_value_t *) (mapped_arguments_p + 1);\n\n            if (!ecma_is_value_empty (argv_p[index]) && argv_p[index] != ECMA_VALUE_ARGUMENT_NO_TRACK)\n            {\n              ecma_string_t *name_p = ecma_op_arguments_object_get_formal_parameter (mapped_arguments_p, index);\n              ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, mapped_arguments_p->lex_env);\n\n              return ecma_op_get_binding_value (lex_env_p, name_p, true);\n            }\n          }\n          break;\n        }\n#if JERRY_BUILTIN_TYPEDARRAY\n        /* ES2015 9.4.5.4 */\n        case ECMA_OBJECT_CLASS_TYPEDARRAY:\n        {\n          if (ecma_prop_name_is_symbol (property_name_p))\n          {\n            break;\n          }\n\n          uint32_t index = ecma_string_get_array_index (property_name_p);\n\n          if (index == ECMA_STRING_NOT_ARRAY_INDEX)\n          {\n            JERRY_ASSERT (index == UINT32_MAX);\n\n            if (!ecma_typedarray_is_element_index (property_name_p))\n            {\n              break;\n            }\n          }\n\n          ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);\n          return ecma_get_typedarray_element (&info, index);\n        }\n#endif /* JERRY_BUILTIN_TYPEDARRAY */\n#if JERRY_MODULE_SYSTEM\n        case ECMA_OBJECT_CLASS_MODULE_NAMESPACE:\n        {\n          if (JERRY_UNLIKELY (ecma_prop_name_is_symbol (property_name_p)))\n          {\n            /* ECMA-262 v11, 26.3.1 */\n            if (ecma_op_compare_string_to_global_symbol (property_name_p, LIT_GLOBAL_SYMBOL_TO_STRING_TAG))\n            {\n              return ecma_make_magic_string_value (LIT_MAGIC_STRING_MODULE_UL);\n            }\n\n            return ECMA_VALUE_NOT_FOUND;\n          }\n\n          ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);\n\n          if (property_p == NULL)\n          {\n            return ECMA_VALUE_NOT_FOUND;\n          }\n\n          JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));\n\n          ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n          if (!(*property_p & ECMA_PROPERTY_FLAG_DATA))\n          {\n            prop_value_p = ecma_get_property_value_from_named_reference (prop_value_p);\n\n            if (JERRY_UNLIKELY (prop_value_p->value == ECMA_VALUE_UNINITIALIZED))\n            {\n              return ecma_raise_reference_error (ECMA_ERR_LET_CONST_NOT_INITIALIZED);\n            }\n          }\n\n          return ecma_fast_copy_value (prop_value_p->value);\n        }\n#endif /* JERRY_MODULE_SYSTEM */\n      }\n      break;\n    }\n    case ECMA_OBJECT_BASE_TYPE_ARRAY:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      if (ecma_string_is_length (property_name_p))\n      {\n        return ecma_make_uint32_value (ext_object_p->u.array.length);\n      }\n\n      if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)))\n      {\n        uint32_t index = ecma_string_get_array_index (property_name_p);\n\n        if (JERRY_LIKELY (index != ECMA_STRING_NOT_ARRAY_INDEX))\n        {\n          if (JERRY_LIKELY (index < ext_object_p->u.array.length))\n          {\n            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);\n\n            return (ecma_is_value_array_hole (values_p[index]) ? ECMA_VALUE_NOT_FOUND\n                                                               : ecma_fast_copy_value (values_p[index]));\n          }\n        }\n        return ECMA_VALUE_NOT_FOUND;\n      }\n\n      break;\n    }\n    default:\n    {\n      break;\n    }\n  }\n\n  ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);\n\n  if (property_p == NULL)\n  {\n    switch (ecma_get_object_type (object_p))\n    {\n      case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:\n      {\n        if (ecma_builtin_function_is_routine (object_p))\n        {\n          property_p = ecma_builtin_routine_try_to_instantiate_property (object_p, property_name_p);\n          break;\n        }\n        /* FALLTHRU */\n      }\n      case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:\n      case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:\n      case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:\n      {\n        property_p = ecma_builtin_try_to_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      case ECMA_OBJECT_TYPE_CLASS:\n      {\n        if (((ecma_extended_object_t *) object_p)->u.cls.type == ECMA_OBJECT_CLASS_ARGUMENTS)\n        {\n          property_p = ecma_op_arguments_object_try_to_lazy_instantiate_property (object_p, property_name_p);\n        }\n        break;\n      }\n      case ECMA_OBJECT_TYPE_FUNCTION:\n      {\n#if !JERRY_ESNEXT\n        if (ecma_string_is_length (property_name_p))\n        {\n          /* Get length virtual property. */\n          ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;\n          const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);\n\n          uint32_t len;\n          if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n          {\n            cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_data_p;\n            len = args_p->argument_end;\n          }\n          else\n          {\n            cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_data_p;\n            len = args_p->argument_end;\n          }\n\n          return ecma_make_uint32_value (len);\n        }\n#endif /* !JERRY_ESNEXT */\n\n        /* Get prototype physical property. */\n        property_p = ecma_op_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:\n      {\n        property_p = ecma_op_external_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n      {\n        property_p = ecma_op_bound_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      default:\n      {\n        break;\n      }\n    }\n\n    if (property_p == NULL)\n    {\n      return ECMA_VALUE_NOT_FOUND;\n    }\n  }\n\n  JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));\n\n  ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n  if (*property_p & ECMA_PROPERTY_FLAG_DATA)\n  {\n    return ecma_fast_copy_value (prop_value_p->value);\n  }\n\n  ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (prop_value_p);\n\n  if (get_set_pair_p->getter_cp == JMEM_CP_NULL)\n  {\n    return ECMA_VALUE_UNDEFINED;\n  }\n\n  ecma_object_t *getter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp);\n\n  return ecma_op_function_call (getter_p, base_value, NULL, 0);\n}",
        "begin_line": 489,
        "end_line": 761,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_own_property#73",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_own_property (ecma_object_t *object_p, /**< the object */                                  ecma_string_t *property_name_p, /**< property name */                                  ecma_property_ref_t *property_ref_p, /**< property reference */                                  uint32_t options) /**< option bits */",
        "snippet": "ecma_property_t\necma_op_object_get_own_property (ecma_object_t *object_p, /**< the object */\n                                 ecma_string_t *property_name_p, /**< property name */\n                                 ecma_property_ref_t *property_ref_p, /**< property reference */\n                                 uint32_t options) /**< option bits */\n{\n  JERRY_ASSERT (object_p != NULL && !ecma_is_lexical_environment (object_p));\n#if JERRY_BUILTIN_PROXY\n  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));\n#endif /* JERRY_BUILTIN_PROXY */\n  JERRY_ASSERT (property_name_p != NULL);\n  JERRY_ASSERT (options == ECMA_PROPERTY_GET_NO_OPTIONS || property_ref_p != NULL);\n\n  ecma_object_base_type_t base_type = ecma_get_object_base_type (object_p);\n\n  switch (base_type)\n  {\n    case ECMA_OBJECT_BASE_TYPE_CLASS:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      switch (ext_object_p->u.cls.type)\n      {\n        case ECMA_OBJECT_CLASS_STRING:\n        {\n          if (ecma_string_is_length (property_name_p))\n          {\n            if (options & ECMA_PROPERTY_GET_VALUE)\n            {\n              ecma_value_t prim_value_p = ext_object_p->u.cls.u3.value;\n              ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);\n\n              lit_utf8_size_t length = ecma_string_get_length (prim_value_str_p);\n              property_ref_p->virtual_value = ecma_make_uint32_value (length);\n            }\n\n            return ECMA_PROPERTY_VIRTUAL;\n          }\n\n          uint32_t index = ecma_string_get_array_index (property_name_p);\n\n          if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n          {\n            ecma_value_t prim_value_p = ext_object_p->u.cls.u3.value;\n            ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);\n\n            if (index < ecma_string_get_length (prim_value_str_p))\n            {\n              if (options & ECMA_PROPERTY_GET_VALUE)\n              {\n                ecma_char_t char_at_idx = ecma_string_get_char_at_pos (prim_value_str_p, index);\n                ecma_string_t *char_str_p = ecma_new_ecma_string_from_code_unit (char_at_idx);\n                property_ref_p->virtual_value = ecma_make_string_value (char_str_p);\n              }\n\n              return ECMA_PROPERTY_FLAG_ENUMERABLE | ECMA_PROPERTY_VIRTUAL;\n            }\n          }\n          break;\n        }\n#if JERRY_BUILTIN_TYPEDARRAY\n        /* ES2015 9.4.5.1 */\n        case ECMA_OBJECT_CLASS_TYPEDARRAY:\n        {\n          if (ecma_prop_name_is_symbol (property_name_p))\n          {\n            break;\n          }\n\n          uint32_t index = ecma_string_get_array_index (property_name_p);\n\n          if (index == ECMA_STRING_NOT_ARRAY_INDEX)\n          {\n            JERRY_ASSERT (index == UINT32_MAX);\n\n            if (!ecma_typedarray_is_element_index (property_name_p))\n            {\n              break;\n            }\n          }\n\n          ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);\n          ecma_value_t value = ecma_get_typedarray_element (&info, index);\n\n          if (ECMA_IS_VALUE_ERROR (value))\n          {\n            return ECMA_PROPERTY_TYPE_NOT_FOUND_AND_THROW;\n          }\n\n          if (JERRY_UNLIKELY (ecma_is_value_undefined (value)))\n          {\n            return ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP;\n          }\n\n          if (options & ECMA_PROPERTY_GET_VALUE)\n          {\n            property_ref_p->virtual_value = value;\n          }\n          else\n          {\n            ecma_fast_free_value (value);\n          }\n\n          return ECMA_PROPERTY_ENUMERABLE_WRITABLE | ECMA_PROPERTY_VIRTUAL;\n        }\n#endif /* JERRY_BUILTIN_TYPEDARRAY */\n#if JERRY_MODULE_SYSTEM\n        case ECMA_OBJECT_CLASS_MODULE_NAMESPACE:\n        {\n          if (JERRY_UNLIKELY (ecma_prop_name_is_symbol (property_name_p)))\n          {\n            if (!ecma_op_compare_string_to_global_symbol (property_name_p, LIT_GLOBAL_SYMBOL_TO_STRING_TAG))\n            {\n              return ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP;\n            }\n\n            /* ECMA-262 v11, 26.3.1 */\n            if (options & ECMA_PROPERTY_GET_VALUE)\n            {\n              property_ref_p->virtual_value = ecma_make_magic_string_value (LIT_MAGIC_STRING_MODULE_UL);\n            }\n\n            return ECMA_PROPERTY_VIRTUAL;\n          }\n\n          ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);\n\n          if (property_p == NULL)\n          {\n            return ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP;\n          }\n\n          JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));\n\n          if (*property_p & ECMA_PROPERTY_FLAG_DATA)\n          {\n            if (options & ECMA_PROPERTY_GET_EXT_REFERENCE)\n            {\n              ((ecma_extended_property_ref_t *) property_ref_p)->property_p = property_p;\n            }\n\n            if (property_ref_p != NULL)\n            {\n              property_ref_p->value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n            }\n\n            return *property_p;\n          }\n\n          if (options & ECMA_PROPERTY_GET_VALUE)\n          {\n            ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n            prop_value_p = ecma_get_property_value_from_named_reference (prop_value_p);\n            property_ref_p->virtual_value = ecma_fast_copy_value (prop_value_p->value);\n          }\n\n          return ECMA_PROPERTY_ENUMERABLE_WRITABLE | ECMA_PROPERTY_VIRTUAL;\n        }\n#endif /* JERRY_MODULE_SYSTEM */\n      }\n      break;\n    }\n    case ECMA_OBJECT_BASE_TYPE_ARRAY:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      if (ecma_string_is_length (property_name_p))\n      {\n        if (options & ECMA_PROPERTY_GET_VALUE)\n        {\n          property_ref_p->virtual_value = ecma_make_uint32_value (ext_object_p->u.array.length);\n        }\n\n        uint32_t length_prop = ext_object_p->u.array.length_prop_and_hole_count;\n        return length_prop & (ECMA_PROPERTY_FLAG_WRITABLE | ECMA_PROPERTY_VIRTUAL);\n      }\n\n      if (ecma_op_array_is_fast_array (ext_object_p))\n      {\n        uint32_t index = ecma_string_get_array_index (property_name_p);\n\n        if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n        {\n          if (JERRY_LIKELY (index < ext_object_p->u.array.length))\n          {\n            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);\n\n            if (ecma_is_value_array_hole (values_p[index]))\n            {\n              return ECMA_PROPERTY_TYPE_NOT_FOUND;\n            }\n\n            if (options & ECMA_PROPERTY_GET_VALUE)\n            {\n              property_ref_p->virtual_value = ecma_fast_copy_value (values_p[index]);\n            }\n\n            return ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | ECMA_PROPERTY_VIRTUAL;\n          }\n        }\n\n        return ECMA_PROPERTY_TYPE_NOT_FOUND;\n      }\n\n      break;\n    }\n    default:\n    {\n      break;\n    }\n  }\n\n  ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);\n  ecma_object_type_t type = ecma_get_object_type (object_p);\n\n  if (property_p == NULL)\n  {\n    switch (type)\n    {\n      case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:\n      {\n        if (ecma_builtin_function_is_routine (object_p))\n        {\n          property_p = ecma_builtin_routine_try_to_instantiate_property (object_p, property_name_p);\n          break;\n        }\n        /* FALLTHRU */\n      }\n      case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:\n      case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:\n      case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:\n      {\n        property_p = ecma_builtin_try_to_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      case ECMA_OBJECT_TYPE_CLASS:\n      {\n        if (((ecma_extended_object_t *) object_p)->u.cls.type == ECMA_OBJECT_CLASS_ARGUMENTS)\n        {\n          property_p = ecma_op_arguments_object_try_to_lazy_instantiate_property (object_p, property_name_p);\n        }\n        break;\n      }\n      case ECMA_OBJECT_TYPE_FUNCTION:\n      {\n#if !JERRY_ESNEXT\n        if (ecma_string_is_length (property_name_p))\n        {\n          if (options & ECMA_PROPERTY_GET_VALUE)\n          {\n            /* Get length virtual property. */\n            ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;\n            const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);\n\n            uint32_t len;\n            if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n            {\n              cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_data_p;\n              len = args_p->argument_end;\n            }\n            else\n            {\n              cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_data_p;\n              len = args_p->argument_end;\n            }\n\n            property_ref_p->virtual_value = ecma_make_uint32_value (len);\n          }\n\n          return ECMA_PROPERTY_VIRTUAL;\n        }\n#endif /* !JERRY_ESNEXT */\n\n        /* Get prototype physical property. */\n        property_p = ecma_op_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:\n      {\n        property_p = ecma_op_external_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n      {\n        property_p = ecma_op_bound_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      default:\n      {\n        break;\n      }\n    }\n\n    if (property_p == NULL)\n    {\n      return ECMA_PROPERTY_TYPE_NOT_FOUND;\n    }\n  }\n  else if (type == ECMA_OBJECT_TYPE_CLASS\n           && ((ecma_extended_object_t *) object_p)->u.cls.type == ECMA_OBJECT_CLASS_ARGUMENTS\n           && (((ecma_extended_object_t *) object_p)->u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED))\n  {\n    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n    uint32_t index = ecma_string_get_array_index (property_name_p);\n\n    if (index < ext_object_p->u.cls.u2.formal_params_number)\n    {\n      ecma_mapped_arguments_t *mapped_arguments_p = (ecma_mapped_arguments_t *) ext_object_p;\n\n      ecma_value_t *argv_p = (ecma_value_t *) (mapped_arguments_p + 1);\n\n      if (!ecma_is_value_empty (argv_p[index]) && argv_p[index] != ECMA_VALUE_ARGUMENT_NO_TRACK)\n      {\n#if JERRY_LCACHE\n        /* Mapped arguments initialized properties MUST not be lcached */\n        if (ecma_is_property_lcached (property_p))\n        {\n          jmem_cpointer_t prop_name_cp;\n\n          if (JERRY_UNLIKELY (ECMA_IS_DIRECT_STRING (property_name_p)))\n          {\n            prop_name_cp = (jmem_cpointer_t) ECMA_GET_DIRECT_STRING_VALUE (property_name_p);\n          }\n          else\n          {\n            ECMA_SET_NON_NULL_POINTER (prop_name_cp, property_name_p);\n          }\n          ecma_lcache_invalidate (object_p, prop_name_cp, property_p);\n        }\n#endif /* JERRY_LCACHE */\n        ecma_string_t *name_p = ecma_op_arguments_object_get_formal_parameter (mapped_arguments_p, index);\n        ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, mapped_arguments_p->lex_env);\n\n        ecma_value_t binding_value = ecma_op_get_binding_value (lex_env_p, name_p, true);\n\n        ecma_named_data_property_assign_value (object_p, ECMA_PROPERTY_VALUE_PTR (property_p), binding_value);\n        ecma_free_value (binding_value);\n      }\n    }\n  }\n\n  if (options & ECMA_PROPERTY_GET_EXT_REFERENCE)\n  {\n    ((ecma_extended_property_ref_t *) property_ref_p)->property_p = property_p;\n  }\n\n  if (property_ref_p != NULL)\n  {\n    property_ref_p->value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n  }\n\n  return *property_p;\n}",
        "begin_line": 73,
        "end_line": 426,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_own_property_descriptor#1860",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_own_property_descriptor (ecma_object_t *object_p, /**< the object */                                             ecma_string_t *property_name_p, /**< property name */                                             ecma_property_descriptor_t *prop_desc_p) /**< property descriptor */",
        "snippet": "ecma_value_t\necma_op_object_get_own_property_descriptor (ecma_object_t *object_p, /**< the object */\n                                            ecma_string_t *property_name_p, /**< property name */\n                                            ecma_property_descriptor_t *prop_desc_p) /**< property descriptor */\n{\n  *prop_desc_p = ecma_make_empty_property_descriptor ();\n\n#if JERRY_BUILTIN_PROXY\n  if (ECMA_OBJECT_IS_PROXY (object_p))\n  {\n    return ecma_proxy_object_get_own_property_descriptor (object_p, property_name_p, prop_desc_p);\n  }\n#endif /* JERRY_BUILTIN_PROXY */\n\n  ecma_property_ref_t property_ref;\n  property_ref.virtual_value = ECMA_VALUE_EMPTY;\n  ecma_property_t property =\n    ecma_op_object_get_own_property (object_p, property_name_p, &property_ref, ECMA_PROPERTY_GET_VALUE);\n\n  if (!ECMA_PROPERTY_IS_FOUND (property))\n  {\n#if JERRY_BUILTIN_TYPEDARRAY\n    if (JERRY_UNLIKELY (property == ECMA_PROPERTY_TYPE_NOT_FOUND_AND_THROW))\n    {\n      return ECMA_VALUE_ERROR;\n    }\n#endif /* JERRY_BUILTIN_TYPEDARRAY */\n\n    JERRY_ASSERT (property == ECMA_PROPERTY_TYPE_NOT_FOUND || property == ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP);\n\n    return ECMA_VALUE_FALSE;\n  }\n\n  uint32_t flags = ecma_is_property_enumerable (property) ? JERRY_PROP_IS_ENUMERABLE : JERRY_PROP_NO_OPTS;\n  flags |= ecma_is_property_configurable (property) ? JERRY_PROP_IS_CONFIGURABLE : JERRY_PROP_NO_OPTS;\n\n  prop_desc_p->flags = (uint16_t) (JERRY_PROP_IS_ENUMERABLE_DEFINED | JERRY_PROP_IS_CONFIGURABLE_DEFINED | flags);\n\n  if (property & ECMA_PROPERTY_FLAG_DATA)\n  {\n    if (!ECMA_PROPERTY_IS_VIRTUAL (property))\n    {\n      prop_desc_p->value = ecma_copy_value (property_ref.value_p->value);\n    }\n    else\n    {\n#if JERRY_MODULE_SYSTEM\n      if (JERRY_UNLIKELY (property_ref.virtual_value == ECMA_VALUE_UNINITIALIZED))\n      {\n        return ecma_raise_reference_error (ECMA_ERR_LET_CONST_NOT_INITIALIZED);\n      }\n#endif /* JERRY_MODULE_SYSTEM */\n      prop_desc_p->value = property_ref.virtual_value;\n    }\n\n    prop_desc_p->flags |= (JERRY_PROP_IS_VALUE_DEFINED | JERRY_PROP_IS_WRITABLE_DEFINED);\n    prop_desc_p->flags = (uint16_t) (\n      prop_desc_p->flags | (ecma_is_property_writable (property) ? JERRY_PROP_IS_WRITABLE : JERRY_PROP_NO_OPTS));\n  }\n  else\n  {\n    ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (property_ref.value_p);\n    prop_desc_p->flags |= (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED);\n\n    if (get_set_pair_p->getter_cp == JMEM_CP_NULL)\n    {\n      prop_desc_p->get_p = NULL;\n    }\n    else\n    {\n      prop_desc_p->get_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp);\n      ecma_ref_object (prop_desc_p->get_p);\n    }\n\n    if (get_set_pair_p->setter_cp == JMEM_CP_NULL)\n    {\n      prop_desc_p->set_p = NULL;\n    }\n    else\n    {\n      prop_desc_p->set_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->setter_cp);\n      ecma_ref_object (prop_desc_p->set_p);\n    }\n  }\n\n  return ECMA_VALUE_TRUE;\n}",
        "begin_line": 1860,
        "end_line": 1946,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_with_receiver#865",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_get_with_receiver (ecma_object_t *object_p, /**< the object */                                   ecma_string_t *property_name_p, /**< property name */                                   ecma_value_t receiver) /**< receiver to invoke getter function */",
        "snippet": "ecma_value_t\necma_op_object_get_with_receiver (ecma_object_t *object_p, /**< the object */\n                                  ecma_string_t *property_name_p, /**< property name */\n                                  ecma_value_t receiver) /**< receiver to invoke getter function */\n{\n  while (true)\n  {\n#if JERRY_BUILTIN_PROXY\n    if (ECMA_OBJECT_IS_PROXY (object_p))\n    {\n      return ecma_proxy_object_get (object_p, property_name_p, receiver);\n    }\n#endif /* JERRY_BUILTIN_PROXY */\n\n    ecma_value_t value = ecma_op_object_find_own (receiver, object_p, property_name_p);\n\n    if (ecma_is_value_found (value))\n    {\n      return value;\n    }\n\n    jmem_cpointer_t proto_cp = ecma_op_ordinary_object_get_prototype_of (object_p);\n\n    if (proto_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    object_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp);\n  }\n\n  return ECMA_VALUE_UNDEFINED;\n}",
        "begin_line": 865,
        "end_line": 897,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_put_with_receiver#1326",
        "src_path": "jerry-core/ecma/operations/ecma-objects.c",
        "class_name": "jerry-core.ecma.operations.ecma-objects",
        "signature": "jerry-core.ecma.operations.ecma-objects.ecma_op_object_put_with_receiver (ecma_object_t *object_p, /**< the object */                                   ecma_string_t *property_name_p, /**< property name */                                   ecma_value_t value, /**< ecma value */                                   ecma_value_t receiver, /**< receiver */                                   bool is_throw) /**< flag that controls failure handling */",
        "snippet": "ecma_value_t\necma_op_object_put_with_receiver (ecma_object_t *object_p, /**< the object */\n                                  ecma_string_t *property_name_p, /**< property name */\n                                  ecma_value_t value, /**< ecma value */\n                                  ecma_value_t receiver, /**< receiver */\n                                  bool is_throw) /**< flag that controls failure handling */\n{\n  JERRY_ASSERT (object_p != NULL && !ecma_is_lexical_environment (object_p));\n  JERRY_ASSERT (property_name_p != NULL);\n\n#if JERRY_BUILTIN_PROXY\n  if (ECMA_OBJECT_IS_PROXY (object_p))\n  {\n    return ecma_proxy_object_set (object_p, property_name_p, value, receiver, is_throw);\n  }\n#endif /* JERRY_BUILTIN_PROXY */\n\n  ecma_object_base_type_t base_type = ecma_get_object_base_type (object_p);\n\n  switch (base_type)\n  {\n    case ECMA_OBJECT_BASE_TYPE_CLASS:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      switch (ext_object_p->u.cls.type)\n      {\n        case ECMA_OBJECT_CLASS_ARGUMENTS:\n        {\n          if (!(ext_object_p->u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED))\n          {\n            break;\n          }\n\n          uint32_t index = ecma_string_get_array_index (property_name_p);\n\n          if (index < ext_object_p->u.cls.u2.formal_params_number)\n          {\n            ecma_mapped_arguments_t *mapped_arguments_p = (ecma_mapped_arguments_t *) ext_object_p;\n\n            ecma_value_t *argv_p = (ecma_value_t *) (mapped_arguments_p + 1);\n\n            if (!ecma_is_value_empty (argv_p[index]) && argv_p[index] != ECMA_VALUE_ARGUMENT_NO_TRACK)\n            {\n              ecma_string_t *name_p = ecma_op_arguments_object_get_formal_parameter (mapped_arguments_p, index);\n              ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, mapped_arguments_p->lex_env);\n              ecma_op_set_mutable_binding (lex_env_p, name_p, value, true);\n              return ECMA_VALUE_TRUE;\n            }\n          }\n          break;\n        }\n#if JERRY_BUILTIN_TYPEDARRAY\n        /* ES2015 9.4.5.5 */\n        case ECMA_OBJECT_CLASS_TYPEDARRAY:\n        {\n          if (ecma_prop_name_is_symbol (property_name_p))\n          {\n            break;\n          }\n\n          uint32_t index = ecma_string_get_array_index (property_name_p);\n\n          if (index == ECMA_STRING_NOT_ARRAY_INDEX)\n          {\n            JERRY_ASSERT (index == UINT32_MAX);\n\n            if (!ecma_typedarray_is_element_index (property_name_p))\n            {\n              break;\n            }\n          }\n\n          ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);\n          return ecma_set_typedarray_element (&info, value, index);\n        }\n#endif /* JERRY_BUILTIN_TYPEDARRAY */\n#if JERRY_MODULE_SYSTEM\n        case ECMA_OBJECT_CLASS_MODULE_NAMESPACE:\n        {\n          return ecma_raise_readonly_assignment (property_name_p, is_throw);\n        }\n#endif /* JERRY_MODULE_SYSTEM */\n      }\n      break;\n    }\n    case ECMA_OBJECT_BASE_TYPE_ARRAY:\n    {\n      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n      if (ecma_string_is_length (property_name_p))\n      {\n        if (ecma_is_property_writable ((ecma_property_t) ext_object_p->u.array.length_prop_and_hole_count))\n        {\n          return ecma_op_array_object_set_length (object_p, value, 0);\n        }\n\n        return ecma_raise_readonly_assignment (property_name_p, is_throw);\n      }\n\n      if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)))\n      {\n        uint32_t index = ecma_string_get_array_index (property_name_p);\n\n        if (JERRY_UNLIKELY (index == ECMA_STRING_NOT_ARRAY_INDEX))\n        {\n          ecma_fast_array_convert_to_normal (object_p);\n        }\n        else if (ecma_fast_array_set_property (object_p, index, value))\n        {\n          return ECMA_VALUE_TRUE;\n        }\n      }\n\n      JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));\n      break;\n    }\n    default:\n    {\n      break;\n    }\n  }\n\n  ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);\n\n  if (property_p == NULL)\n  {\n    switch (ecma_get_object_type (object_p))\n    {\n      case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:\n      {\n        if (ecma_builtin_function_is_routine (object_p))\n        {\n          property_p = ecma_builtin_routine_try_to_instantiate_property (object_p, property_name_p);\n          break;\n        }\n        /* FALLTHRU */\n      }\n      case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:\n      case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:\n      case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:\n      {\n        property_p = ecma_builtin_try_to_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      case ECMA_OBJECT_TYPE_CLASS:\n      {\n        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n        switch (ext_object_p->u.cls.type)\n        {\n          case ECMA_OBJECT_CLASS_STRING:\n          {\n            uint32_t index = ecma_string_get_array_index (property_name_p);\n\n            if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n            {\n              ecma_value_t prim_value_p = ext_object_p->u.cls.u3.value;\n              ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);\n\n              if (index < ecma_string_get_length (prim_value_str_p))\n              {\n                return ecma_raise_readonly_assignment (property_name_p, is_throw);\n              }\n            }\n            break;\n          }\n          case ECMA_OBJECT_CLASS_ARGUMENTS:\n          {\n            property_p = ecma_op_arguments_object_try_to_lazy_instantiate_property (object_p, property_name_p);\n            break;\n          }\n        }\n        break;\n      }\n      case ECMA_OBJECT_TYPE_FUNCTION:\n      {\n        if (ecma_string_is_length (property_name_p))\n        {\n          /* Uninitialized 'length' property is non-writable (ECMA-262 v6, 19.2.4.1) */\n#if JERRY_ESNEXT\n          if (!ECMA_GET_FIRST_BIT_FROM_POINTER_TAG (((ecma_extended_object_t *) object_p)->u.function.scope_cp))\n#endif /* JERRY_ESNEXT */\n          {\n            return ecma_raise_readonly_assignment (property_name_p, is_throw);\n          }\n        }\n\n        /* Get prototype physical property. */\n        property_p = ecma_op_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:\n      {\n        property_p = ecma_op_external_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n      {\n        property_p = ecma_op_bound_function_try_to_lazy_instantiate_property (object_p, property_name_p);\n        break;\n      }\n      default:\n      {\n        break;\n      }\n    }\n  }\n\n  jmem_cpointer_t setter_cp = JMEM_CP_NULL;\n\n  if (property_p != NULL)\n  {\n    JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));\n\n    if (*property_p & ECMA_PROPERTY_FLAG_DATA)\n    {\n      if (ecma_is_property_writable (*property_p))\n      {\n#if JERRY_ESNEXT\n        if (ecma_make_object_value (object_p) != receiver)\n        {\n          return ecma_op_object_put_apply_receiver (receiver, property_name_p, value, is_throw);\n        }\n#endif /* JERRY_ESNEXT */\n\n        /* There is no need for special casing arrays here because changing the\n         * value of an existing property never changes the length of an array. */\n        ecma_named_data_property_assign_value (object_p, ECMA_PROPERTY_VALUE_PTR (property_p), value);\n        return ECMA_VALUE_TRUE;\n      }\n    }\n    else\n    {\n      ecma_getter_setter_pointers_t *get_set_pair_p;\n      get_set_pair_p = ecma_get_named_accessor_property (ECMA_PROPERTY_VALUE_PTR (property_p));\n      setter_cp = get_set_pair_p->setter_cp;\n    }\n  }\n  else\n  {\n    bool create_new_property = true;\n\n    jmem_cpointer_t obj_cp;\n    ECMA_SET_NON_NULL_POINTER (obj_cp, object_p);\n    ecma_object_t *proto_p = object_p;\n\n    while (true)\n    {\n      obj_cp = ecma_op_ordinary_object_get_prototype_of (proto_p);\n\n      if (obj_cp == JMEM_CP_NULL)\n      {\n        break;\n      }\n\n      ecma_property_ref_t property_ref = { NULL };\n      proto_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_cp);\n\n#if JERRY_BUILTIN_PROXY\n      if (ECMA_OBJECT_IS_PROXY (proto_p))\n      {\n        return ecma_op_object_put_with_receiver (proto_p, property_name_p, value, receiver, is_throw);\n      }\n#endif /* JERRY_BUILTIN_PROXY */\n\n      ecma_property_t inherited_property =\n        ecma_op_object_get_own_property (proto_p, property_name_p, &property_ref, ECMA_PROPERTY_GET_NO_OPTIONS);\n\n      if (ECMA_PROPERTY_IS_FOUND (inherited_property))\n      {\n        JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (inherited_property));\n\n        if (!(inherited_property & ECMA_PROPERTY_FLAG_DATA))\n        {\n          setter_cp = ecma_get_named_accessor_property (property_ref.value_p)->setter_cp;\n          create_new_property = false;\n          break;\n        }\n\n        create_new_property = ecma_is_property_writable (inherited_property);\n        break;\n      }\n\n      JERRY_ASSERT (inherited_property == ECMA_PROPERTY_TYPE_NOT_FOUND\n                    || inherited_property == ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP);\n    }\n\n#if JERRY_BUILTIN_PROXY\n    if (create_new_property && ecma_is_value_object (receiver)\n        && ECMA_OBJECT_IS_PROXY (ecma_get_object_from_value (receiver)))\n    {\n      return ecma_op_object_put_apply_receiver (receiver, property_name_p, value, is_throw);\n    }\n#endif /* JERRY_BUILTIN_PROXY */\n\n    if (create_new_property && ecma_op_ordinary_object_is_extensible (object_p))\n    {\n      const ecma_object_base_type_t obj_base_type = ecma_get_object_base_type (object_p);\n\n      if (obj_base_type == ECMA_OBJECT_BASE_TYPE_CLASS)\n      {\n        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n        if (ext_object_p->u.cls.type == ECMA_OBJECT_CLASS_ARGUMENTS\n            && ext_object_p->u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED)\n        {\n          const uint32_t flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;\n          return ecma_builtin_helper_def_prop (object_p, property_name_p, value, flags);\n        }\n      }\n\n      uint32_t index = ecma_string_get_array_index (property_name_p);\n\n      if (obj_base_type == ECMA_OBJECT_BASE_TYPE_ARRAY && index != ECMA_STRING_NOT_ARRAY_INDEX)\n      {\n        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;\n\n        if (index < UINT32_MAX && index >= ext_object_p->u.array.length)\n        {\n          if (!ecma_is_property_writable ((ecma_property_t) ext_object_p->u.array.length_prop_and_hole_count))\n          {\n            return ecma_raise_readonly_assignment (property_name_p, is_throw);\n          }\n\n          ext_object_p->u.array.length = index + 1;\n        }\n      }\n\n#if JERRY_ESNEXT\n      return ecma_op_object_put_apply_receiver (receiver, property_name_p, value, is_throw);\n#endif /* JERRY_ESNEXT */\n\n      ecma_property_value_t *new_prop_value_p;\n      new_prop_value_p = ecma_create_named_data_property (object_p,\n                                                          property_name_p,\n                                                          ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,\n                                                          NULL);\n\n      JERRY_ASSERT (ecma_is_value_undefined (new_prop_value_p->value));\n      new_prop_value_p->value = ecma_copy_value_if_not_object (value);\n      return ECMA_VALUE_TRUE;\n    }\n  }\n\n  if (setter_cp == JMEM_CP_NULL)\n  {\n    return ecma_raise_readonly_assignment (property_name_p, is_throw);\n  }\n\n  ecma_value_t ret_value =\n    ecma_op_function_call (ECMA_GET_NON_NULL_POINTER (ecma_object_t, setter_cp), receiver, &value, 1);\n\n  if (!ECMA_IS_VALUE_ERROR (ret_value))\n  {\n    ecma_fast_free_value (ret_value);\n    ret_value = ECMA_VALUE_TRUE;\n  }\n\n  return ret_value;\n}",
        "begin_line": 1326,
        "end_line": 1686,
        "is_bug": false
    },
    {
        "name": "jerry-core.ecma.operations.ecma-reference.ecma_op_resolve_reference_value#287",
        "src_path": "jerry-core/ecma/operations/ecma-reference.c",
        "class_name": "jerry-core.ecma.operations.ecma-reference",
        "signature": "jerry-core.ecma.operations.ecma-reference.ecma_op_resolve_reference_value (ecma_object_t *lex_env_p, /**< starting lexical environment */                                  ecma_string_t *name_p) /**< identifier's name */",
        "snippet": "ecma_value_t\necma_op_resolve_reference_value (ecma_object_t *lex_env_p, /**< starting lexical environment */\n                                 ecma_string_t *name_p) /**< identifier's name */\n{\n  JERRY_ASSERT (lex_env_p != NULL);\n\n  while (true)\n  {\n    switch (ecma_get_lex_env_type (lex_env_p))\n    {\n      case ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE:\n      {\n        ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n        if (property_p == NULL)\n        {\n          break;\n        }\n\n        ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n#if JERRY_ESNEXT\n        if (JERRY_UNLIKELY (property_value_p->value == ECMA_VALUE_UNINITIALIZED))\n        {\n          return ecma_raise_reference_error (ECMA_ERR_LET_CONST_NOT_INITIALIZED);\n        }\n#endif /* JERRY_ESNEXT */\n\n        return ecma_fast_copy_value (property_value_p->value);\n      }\n#if JERRY_ESNEXT\n      case ECMA_LEXICAL_ENVIRONMENT_CLASS:\n      {\n#if JERRY_MODULE_SYSTEM\n        if (ECMA_LEX_ENV_CLASS_IS_MODULE (lex_env_p))\n        {\n          ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);\n\n          if (property_p == NULL)\n          {\n            break;\n          }\n\n          ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n          if (!(*property_p & ECMA_PROPERTY_FLAG_DATA))\n          {\n            property_value_p = ecma_get_property_value_from_named_reference (property_value_p);\n          }\n\n          if (JERRY_UNLIKELY (property_value_p->value == ECMA_VALUE_UNINITIALIZED))\n          {\n            return ecma_raise_reference_error (ECMA_ERR_LET_CONST_NOT_INITIALIZED);\n          }\n\n          return ecma_fast_copy_value (property_value_p->value);\n        }\n#endif /* JERRY_MODULE_SYSTEM */\n        break;\n      }\n#endif /* JERRY_ESNEXT */\n      default:\n      {\n        JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);\n#if JERRY_ESNEXT\n        bool lcache_lookup_allowed = ecma_op_is_global_environment (lex_env_p);\n#else /* !JERRY_ESNEXT*/\n        bool lcache_lookup_allowed = true;\n#endif /* JERRY_ESNEXT */\n\n        if (lcache_lookup_allowed)\n        {\n#if JERRY_LCACHE\n          ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);\n          ecma_property_t *property_p = ecma_lcache_lookup (binding_obj_p, name_p);\n\n          if (property_p != NULL)\n          {\n            JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));\n\n            ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);\n\n            if (*property_p & ECMA_PROPERTY_FLAG_DATA)\n            {\n              return ecma_fast_copy_value (prop_value_p->value);\n            }\n\n            ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (prop_value_p);\n\n            if (get_set_pair_p->getter_cp == JMEM_CP_NULL)\n            {\n              return ECMA_VALUE_UNDEFINED;\n            }\n\n            ecma_object_t *getter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp);\n\n            ecma_value_t base_value = ecma_make_object_value (binding_obj_p);\n            return ecma_op_function_call (getter_p, base_value, NULL, 0);\n          }\n#endif /* JERRY_LCACHE */\n        }\n\n        ecma_value_t result = ecma_op_object_bound_environment_resolve_reference_value (lex_env_p, name_p);\n\n        if (ecma_is_value_found (result))\n        {\n          /* Note: the result may contains ECMA_VALUE_ERROR */\n          return result;\n        }\n        break;\n      }\n    }\n\n    if (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);\n  }\n\n#if JERRY_ERROR_MESSAGES\n  ecma_value_t name_val = ecma_make_string_value (name_p);\n  ecma_value_t error_value =\n    ecma_raise_standard_error_with_format (JERRY_ERROR_REFERENCE, \"% is not defined\", name_val);\n#else /* JERRY_ERROR_MESSAGES */\n  ecma_value_t error_value = ecma_raise_reference_error (ECMA_ERR_EMPTY);\n#endif /* !JERRY_ERROR_MESSAGES */\n  return error_value;\n}",
        "begin_line": 287,
        "end_line": 416,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-allocator.jmem_init#150",
        "src_path": "jerry-core/jmem/jmem-allocator.c",
        "class_name": "jerry-core.jmem.jmem-allocator",
        "signature": "jerry-core.jmem.jmem-allocator.jmem_init (void)",
        "snippet": "void\njmem_init (void)\n{\n  jmem_heap_init ();\n}",
        "begin_line": 150,
        "end_line": 154,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_gc_and_alloc_block#270",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_gc_and_alloc_block (const size_t size, /**< required memory size */                               jmem_pressure_t max_pressure) /**< pressure limit */",
        "snippet": "static void *\njmem_heap_gc_and_alloc_block (const size_t size, /**< required memory size */\n                              jmem_pressure_t max_pressure) /**< pressure limit */\n{\n  if (JERRY_UNLIKELY (size == 0))\n  {\n    return NULL;\n  }\n\n  jmem_pressure_t pressure = JMEM_PRESSURE_NONE;\n\n#if !JERRY_MEM_GC_BEFORE_EACH_ALLOC\n  if (JERRY_CONTEXT (jmem_heap_allocated_size) + size >= JERRY_CONTEXT (jmem_heap_limit))\n  {\n    pressure = JMEM_PRESSURE_LOW;\n    ecma_free_unused_memory (pressure);\n  }\n#else /* !JERRY_MEM_GC_BEFORE_EACH_ALLOC */\n  ecma_gc_run ();\n#endif /* JERRY_MEM_GC_BEFORE_EACH_ALLOC */\n\n  void *data_space_p = jmem_heap_alloc (size);\n\n  while (JERRY_UNLIKELY (data_space_p == NULL) && JERRY_LIKELY (pressure < max_pressure))\n  {\n    pressure++;\n    ecma_free_unused_memory (pressure);\n    data_space_p = jmem_heap_alloc (size);\n  }\n\n  return data_space_p;\n}",
        "begin_line": 270,
        "end_line": 301,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_heap_init#73",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_heap_init (void)",
        "snippet": "void\njmem_heap_init (void)\n{\n#if !JERRY_SYSTEM_ALLOCATOR\n#if !JERRY_CPOINTER_32_BIT\n  /* the maximum heap size for 16bit compressed pointers should be 512K */\n  JERRY_ASSERT (((UINT16_MAX + 1) << JMEM_ALIGNMENT_LOG) >= JMEM_HEAP_SIZE);\n#endif /* !JERRY_CPOINTER_32_BIT */\n  JERRY_ASSERT ((uintptr_t) JERRY_HEAP_CONTEXT (area) % JMEM_ALIGNMENT == 0);\n\n  JERRY_CONTEXT (jmem_heap_limit) = CONFIG_GC_LIMIT;\n\n  jmem_heap_free_t *const region_p = (jmem_heap_free_t *) JERRY_HEAP_CONTEXT (area);\n\n  region_p->size = JMEM_HEAP_AREA_SIZE;\n  region_p->next_offset = JMEM_HEAP_END_OF_LIST;\n\n  JERRY_HEAP_CONTEXT (first).size = 0;\n  JERRY_HEAP_CONTEXT (first).next_offset = JMEM_HEAP_GET_OFFSET_FROM_ADDR (region_p);\n\n  JERRY_CONTEXT (jmem_heap_list_skip_p) = &JERRY_HEAP_CONTEXT (first);\n\n  JMEM_VALGRIND_NOACCESS_SPACE (&JERRY_HEAP_CONTEXT (first), sizeof (jmem_heap_free_t));\n  JMEM_VALGRIND_NOACCESS_SPACE (JERRY_HEAP_CONTEXT (area), JMEM_HEAP_AREA_SIZE);\n\n#endif /* !JERRY_SYSTEM_ALLOCATOR */\n  JMEM_HEAP_STAT_INIT ();\n}",
        "begin_line": 73,
        "end_line": 100,
        "is_bug": false
    },
    {
        "name": "jerry-core.jmem.jmem-heap.jmem_is_heap_pointer#706",
        "src_path": "jerry-core/jmem/jmem-heap.c",
        "class_name": "jerry-core.jmem.jmem-heap",
        "signature": "jerry-core.jmem.jmem-heap.jmem_is_heap_pointer (const void *pointer) /**< pointer */",
        "snippet": "bool\njmem_is_heap_pointer (const void *pointer) /**< pointer */\n{\n#if !JERRY_SYSTEM_ALLOCATOR\n  return ((uint8_t *) pointer >= JERRY_HEAP_CONTEXT (area)\n          && (uint8_t *) pointer <= (JERRY_HEAP_CONTEXT (area) + JMEM_HEAP_AREA_SIZE));\n#else /* JERRY_SYSTEM_ALLOCATOR */\n  JERRY_UNUSED (pointer);\n  return true;\n#endif /* !JERRY_SYSTEM_ALLOCATOR */\n}",
        "begin_line": 706,
        "end_line": 716,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-char-helpers.lit_code_point_is_identifier_part#275",
        "src_path": "jerry-core/lit/lit-char-helpers.c",
        "class_name": "jerry-core.lit.lit-char-helpers",
        "signature": "jerry-core.lit.lit-char-helpers.lit_code_point_is_identifier_part (lit_code_point_t code_point) /**< code point */",
        "snippet": "bool\nlit_code_point_is_identifier_part (lit_code_point_t code_point) /**< code point */\n{\n  /* Fast path for ASCII-defined letters. */\n  if (code_point <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)\n  {\n    return ((LEXER_TO_ASCII_LOWERCASE (code_point) >= LIT_CHAR_LOWERCASE_A\n             && LEXER_TO_ASCII_LOWERCASE (code_point) <= LIT_CHAR_LOWERCASE_Z)\n            || (code_point >= LIT_CHAR_0 && code_point <= LIT_CHAR_9) || code_point == LIT_CHAR_DOLLAR_SIGN\n            || code_point == LIT_CHAR_UNDERSCORE);\n  }\n\n  return lit_char_is_unicode_id_continue (code_point);\n}",
        "begin_line": 275,
        "end_line": 288,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-char-helpers.lit_code_point_is_identifier_start#256",
        "src_path": "jerry-core/lit/lit-char-helpers.c",
        "class_name": "jerry-core.lit.lit-char-helpers",
        "signature": "jerry-core.lit.lit-char-helpers.lit_code_point_is_identifier_start (lit_code_point_t code_point) /**< code point */",
        "snippet": "bool\nlit_code_point_is_identifier_start (lit_code_point_t code_point) /**< code point */\n{\n  /* Fast path for ASCII-defined letters. */\n  if (code_point <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)\n  {\n    return ((LEXER_TO_ASCII_LOWERCASE (code_point) >= LIT_CHAR_LOWERCASE_A\n             && LEXER_TO_ASCII_LOWERCASE (code_point) <= LIT_CHAR_LOWERCASE_Z)\n            || code_point == LIT_CHAR_DOLLAR_SIGN || code_point == LIT_CHAR_UNDERSCORE);\n  }\n\n  return lit_char_is_unicode_id_start (code_point);\n}",
        "begin_line": 256,
        "end_line": 268,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_size#66",
        "src_path": "jerry-core/lit/lit-magic-strings.c",
        "class_name": "jerry-core.lit.lit-magic-strings",
        "signature": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_size (uint32_t id) /**< magic string id */",
        "snippet": "lit_utf8_size_t\nlit_get_magic_string_size (uint32_t id) /**< magic string id */\n{\n  static const lit_magic_size_t lit_magic_string_sizes[] JERRY_ATTR_CONST_DATA = {\n/** @cond doxygen_suppress */\n#define LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE(size, id)\n#define LIT_MAGIC_STRING_DEF(id, utf8_string) sizeof (utf8_string) - 1,\n#include \"lit-magic-strings.inc.h\"\n#undef LIT_MAGIC_STRING_DEF\n#undef LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE\n    /** @endcond */\n  };\n\n  JERRY_ASSERT (id < LIT_NON_INTERNAL_MAGIC_STRING__COUNT);\n\n  return lit_magic_string_sizes[id];\n}",
        "begin_line": 66,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_size_block_start#90",
        "src_path": "jerry-core/lit/lit-magic-strings.c",
        "class_name": "jerry-core.lit.lit-magic-strings",
        "signature": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_size_block_start (lit_utf8_size_t size) /**< magic string size */",
        "snippet": "static lit_magic_string_id_t\nlit_get_magic_string_size_block_start (lit_utf8_size_t size) /**< magic string size */\n{\n  static const lit_magic_string_id_t lit_magic_string_size_block_starts[] JERRY_ATTR_CONST_DATA = {\n/** @cond doxygen_suppress */\n#define LIT_MAGIC_STRING_DEF(id, utf8_string)\n#define LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE(size, id) id,\n#include \"lit-magic-strings.inc.h\"\n    LIT_NON_INTERNAL_MAGIC_STRING__COUNT\n#undef LIT_MAGIC_STRING_DEF\n#undef LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE\n    /** @endcond */\n  };\n\n  JERRY_ASSERT (size <= (sizeof (lit_magic_string_size_block_starts) / sizeof (lit_magic_string_id_t)));\n\n  return lit_magic_string_size_block_starts[size];\n}",
        "begin_line": 90,
        "end_line": 107,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_utf8#43",
        "src_path": "jerry-core/lit/lit-magic-strings.c",
        "class_name": "jerry-core.lit.lit-magic-strings",
        "signature": "jerry-core.lit.lit-magic-strings.lit_get_magic_string_utf8 (uint32_t id) /**< magic string id */",
        "snippet": "const lit_utf8_byte_t *\nlit_get_magic_string_utf8 (uint32_t id) /**< magic string id */\n{\n  static const lit_utf8_byte_t *const lit_magic_strings[] JERRY_ATTR_CONST_DATA = {\n/** @cond doxygen_suppress */\n#define LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE(size, id)\n#define LIT_MAGIC_STRING_DEF(id, utf8_string) (const lit_utf8_byte_t *) utf8_string,\n#include \"lit-magic-strings.inc.h\"\n#undef LIT_MAGIC_STRING_DEF\n#undef LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE\n    /** @endcond */\n  };\n\n  JERRY_ASSERT (id < LIT_NON_INTERNAL_MAGIC_STRING__COUNT);\n\n  return lit_magic_strings[id];\n}",
        "begin_line": 43,
        "end_line": 59,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-magic-strings.lit_is_utf8_string_magic#195",
        "src_path": "jerry-core/lit/lit-magic-strings.c",
        "class_name": "jerry-core.lit.lit-magic-strings",
        "signature": "jerry-core.lit.lit-magic-strings.lit_is_utf8_string_magic (const lit_utf8_byte_t *string_p, /**< utf-8 string */                           lit_utf8_size_t string_size) /**< string size in bytes */",
        "snippet": "lit_magic_string_id_t\nlit_is_utf8_string_magic (const lit_utf8_byte_t *string_p, /**< utf-8 string */\n                          lit_utf8_size_t string_size) /**< string size in bytes */\n{\n  if (string_size > lit_get_magic_string_size (LIT_NON_INTERNAL_MAGIC_STRING__COUNT - 1))\n  {\n    return LIT_MAGIC_STRING__COUNT;\n  }\n\n  /**< The string must be in this id range. */\n  lit_utf8_size_t first = lit_get_magic_string_size_block_start (string_size);\n  lit_utf8_size_t last = lit_get_magic_string_size_block_start (string_size + 1);\n\n  while (first < last)\n  {\n    lit_utf8_size_t middle = ((first + last) / 2); /**< mid point of search */\n    int compare = memcmp (lit_get_magic_string_utf8 ((lit_magic_string_id_t) middle), string_p, string_size);\n\n    if (compare == 0)\n    {\n      return (lit_magic_string_id_t) middle;\n    }\n    else if (compare > 0)\n    {\n      last = middle;\n    }\n    else\n    {\n      first = middle + 1;\n    }\n  }\n\n  return LIT_MAGIC_STRING__COUNT;\n}",
        "begin_line": 195,
        "end_line": 228,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_is_valid_cesu8_string#112",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_is_valid_cesu8_string (const lit_utf8_byte_t *cesu8_buf_p, /**< cesu-8 string */                            lit_utf8_size_t buf_size) /**< string size */",
        "snippet": "bool\nlit_is_valid_cesu8_string (const lit_utf8_byte_t *cesu8_buf_p, /**< cesu-8 string */\n                           lit_utf8_size_t buf_size) /**< string size */\n{\n  lit_utf8_size_t idx = 0;\n\n  while (idx < buf_size)\n  {\n    lit_utf8_byte_t c = cesu8_buf_p[idx++];\n    if ((c & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)\n    {\n      continue;\n    }\n\n    lit_code_point_t code_point = 0;\n    lit_code_point_t min_code_point = 0;\n    lit_utf8_size_t extra_bytes_count;\n    if ((c & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)\n    {\n      extra_bytes_count = 1;\n      min_code_point = LIT_UTF8_2_BYTE_CODE_POINT_MIN;\n      code_point = ((uint32_t) (c & LIT_UTF8_LAST_5_BITS_MASK));\n    }\n    else if ((c & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER)\n    {\n      extra_bytes_count = 2;\n      min_code_point = LIT_UTF8_3_BYTE_CODE_POINT_MIN;\n      code_point = ((uint32_t) (c & LIT_UTF8_LAST_4_BITS_MASK));\n    }\n    else\n    {\n      return false;\n    }\n\n    if (idx + extra_bytes_count > buf_size)\n    {\n      /* cesu-8 string breaks in the middle */\n      return false;\n    }\n\n    for (lit_utf8_size_t offset = 0; offset < extra_bytes_count; ++offset)\n    {\n      c = cesu8_buf_p[idx + offset];\n      if ((c & LIT_UTF8_EXTRA_BYTE_MASK) != LIT_UTF8_EXTRA_BYTE_MARKER)\n      {\n        /* invalid continuation byte */\n        return false;\n      }\n      code_point <<= LIT_UTF8_BITS_IN_EXTRA_BYTES;\n      code_point |= (c & LIT_UTF8_LAST_6_BITS_MASK);\n    }\n\n    if (code_point < min_code_point)\n    {\n      /* cesu-8 string doesn't encode valid unicode code point */\n      return false;\n    }\n\n    idx += extra_bytes_count;\n  }\n\n  return true;\n}",
        "begin_line": 112,
        "end_line": 174,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_is_valid_utf8_string#38",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_is_valid_utf8_string (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */                           lit_utf8_size_t buf_size, /**< string size */                           bool is_strict) /**< true if surrogate pairs are not allowed */",
        "snippet": "bool\nlit_is_valid_utf8_string (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */\n                          lit_utf8_size_t buf_size, /**< string size */\n                          bool is_strict) /**< true if surrogate pairs are not allowed */\n{\n  const unsigned char *end = buf_size + utf8_buf_p;\n\n  const unsigned char *idx = (const unsigned char *) utf8_buf_p;\n\n  while (idx < end)\n  {\n    const uint8_t first_byte = *idx++;\n\n    if (first_byte < LIT_UTF8_EXTRA_BYTE_MARKER)\n    {\n      continue;\n    }\n\n    if (first_byte < LIT_UTF8_VALID_TWO_BYTE_START || idx >= end)\n    {\n      return false;\n    }\n\n    const uint8_t second_byte = *idx++;\n\n    if ((second_byte & LIT_UTF8_EXTRA_BYTE_MASK) != LIT_UTF8_EXTRA_BYTE_MARKER)\n    {\n      return false;\n    }\n\n    if (first_byte < LIT_UTF8_3_BYTE_MARKER)\n    {\n      continue;\n    }\n\n    if (idx >= end || (*idx++ & LIT_UTF8_EXTRA_BYTE_MASK) != LIT_UTF8_EXTRA_BYTE_MARKER)\n    {\n      return false;\n    }\n\n    if (first_byte < LIT_UTF8_4_BYTE_MARKER)\n    {\n      if (first_byte == LIT_UTF8_3_BYTE_MARKER && (second_byte & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_EXTRA_BYTE_MARKER)\n      {\n        return false;\n      }\n\n      if (is_strict && first_byte == LIT_UTF8_SURROGATE_MARKER && second_byte >= LIT_UTF8_HIGH_SURROGATE_MIN\n          && second_byte <= LIT_UTF8_HIGH_SURROGATE_MAX && idx + 3 <= end && idx[0] == LIT_UTF8_SURROGATE_MARKER\n          && idx[1] >= LIT_UTF8_LOW_SURROGATE_MIN && idx[1] <= LIT_UTF8_LOW_SURROGATE_MAX)\n      {\n        return false;\n      }\n      continue;\n    }\n\n    if (idx >= end || first_byte > LIT_UTF8_1_BYTE_MAX\n        || (first_byte == LIT_UTF8_4_BYTE_MARKER && second_byte <= LIT_UTF8_EXTRA_BYTE_MARKER)\n        || (first_byte == LIT_UTF8_1_BYTE_MAX && second_byte > LIT_UTF8_2_BYTE_MAX)\n        || (*idx++ & LIT_UTF8_EXTRA_BYTE_MASK) != LIT_UTF8_EXTRA_BYTE_MARKER)\n    {\n      return false;\n    }\n  }\n\n  return true;\n}",
        "begin_line": 38,
        "end_line": 104,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_utf8_string_length#275",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_utf8_string_length (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */                         lit_utf8_size_t utf8_buf_size) /**< string size */",
        "snippet": "lit_utf8_size_t\nlit_utf8_string_length (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */\n                        lit_utf8_size_t utf8_buf_size) /**< string size */\n{\n  lit_utf8_size_t length = 0;\n  lit_utf8_size_t size = 0;\n\n  while (size < utf8_buf_size)\n  {\n    size += lit_get_unicode_char_size_by_utf8_first_byte (*(utf8_buf_p + size));\n    length++;\n  }\n\n  JERRY_ASSERT (size == utf8_buf_size);\n\n  return length;\n}",
        "begin_line": 275,
        "end_line": 291,
        "is_bug": false
    },
    {
        "name": "jerry-core.lit.lit-strings.lit_zt_utf8_string_size#263",
        "src_path": "jerry-core/lit/lit-strings.c",
        "class_name": "jerry-core.lit.lit-strings",
        "signature": "jerry-core.lit.lit-strings.lit_zt_utf8_string_size (const lit_utf8_byte_t *utf8_str_p) /**< zero-terminated utf-8 string */",
        "snippet": "lit_utf8_size_t\nlit_zt_utf8_string_size (const lit_utf8_byte_t *utf8_str_p) /**< zero-terminated utf-8 string */\n{\n  JERRY_ASSERT (utf8_str_p != NULL);\n  return (lit_utf8_size_t) strlen ((const char *) utf8_str_p);\n}",
        "begin_line": 263,
        "end_line": 268,
        "is_bug": false
    },
    {
        "name": "jerry-core.parser.js.js-parser.parser_parse_script#3407",
        "src_path": "jerry-core/parser/js/js-parser.c",
        "class_name": "jerry-core.parser.js.js-parser",
        "signature": "jerry-core.parser.js.js-parser.parser_parse_script (void *source_p, /**< source code */                      uint32_t parse_opts, /**< ecma_parse_opts_t option bits */                      const jerry_parse_options_t *options_p) /**< additional configuration options */",
        "snippet": "ecma_compiled_code_t *\nparser_parse_script (void *source_p, /**< source code */\n                     uint32_t parse_opts, /**< ecma_parse_opts_t option bits */\n                     const jerry_parse_options_t *options_p) /**< additional configuration options */\n{\n#if JERRY_PARSER\n  ecma_compiled_code_t *bytecode_p = parser_parse_source (source_p, parse_opts, options_p);\n\n  if (JERRY_UNLIKELY (bytecode_p == NULL))\n  {\n    /* Exception has already thrown. */\n    return NULL;\n  }\n\n#if JERRY_DEBUGGER\n  if ((JERRY_CONTEXT (debugger_flags) & (JERRY_DEBUGGER_CONNECTED | JERRY_DEBUGGER_PARSER_WAIT))\n      == (JERRY_DEBUGGER_CONNECTED | JERRY_DEBUGGER_PARSER_WAIT))\n  {\n    JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_PARSER_WAIT_MODE);\n    jerry_debugger_send_type (JERRY_DEBUGGER_WAITING_AFTER_PARSE);\n\n    while (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_PARSER_WAIT_MODE)\n    {\n      jerry_debugger_receive (NULL);\n\n      if (!(JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED))\n      {\n        break;\n      }\n\n      jerry_debugger_transport_sleep ();\n    }\n  }\n#endif /* JERRY_DEBUGGER */\n\n  return bytecode_p;\n#else /* !JERRY_PARSER */\n  JERRY_UNUSED (arg_list_p);\n  JERRY_UNUSED (arg_list_size);\n  JERRY_UNUSED (source_p);\n  JERRY_UNUSED (source_size);\n  JERRY_UNUSED (parse_opts);\n  JERRY_UNUSED (source_name);\n\n  ecma_raise_syntax_error (ECMA_ERR_PARSER_NOT_SUPPORTED);\n  return NULL;\n#endif /* JERRY_PARSER */\n}",
        "begin_line": 3407,
        "end_line": 3454,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.opfunc_call#741",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.opfunc_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */",
        "snippet": "static void\nopfunc_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */\n{\n  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;\n  uint8_t opcode = byte_code_p[-1];\n  uint32_t arguments_list_len;\n\n  if (opcode >= CBC_CALL0)\n  {\n    arguments_list_len = (unsigned int) ((opcode - CBC_CALL0) / 6);\n  }\n  else\n  {\n    arguments_list_len = *byte_code_p++;\n  }\n\n  bool is_call_prop = ((opcode - CBC_CALL) % 6) >= 3;\n\n  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;\n  ecma_value_t this_value = is_call_prop ? stack_top_p[-3] : ECMA_VALUE_UNDEFINED;\n  ecma_value_t func_value = stack_top_p[-1];\n\n  ecma_value_t completion_value =\n    ecma_op_function_validated_call (func_value, this_value, stack_top_p, arguments_list_len);\n\n  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_DIRECT_EVAL;\n\n  /* Free registers. */\n  for (uint32_t i = 0; i < arguments_list_len; i++)\n  {\n    ecma_fast_free_value (stack_top_p[i]);\n  }\n\n  if (is_call_prop)\n  {\n    ecma_free_value (*(--stack_top_p));\n    ecma_free_value (*(--stack_top_p));\n  }\n\n  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))\n  {\n#if JERRY_DEBUGGER\n    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;\n#endif /* JERRY_DEBUGGER */\n    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;\n  }\n  else\n  {\n    frame_ctx_p->byte_code_p = byte_code_p;\n    ecma_free_value (*(--stack_top_p));\n    uint32_t opcode_data = vm_decode_table[opcode];\n\n    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))\n    {\n      ecma_fast_free_value (completion_value);\n    }\n    else if (opcode_data & VM_OC_PUT_STACK)\n    {\n      *stack_top_p++ = completion_value;\n    }\n    else\n    {\n      ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));\n      VM_GET_REGISTERS (frame_ctx_p)[0] = completion_value;\n    }\n  }\n\n  frame_ctx_p->stack_top_p = stack_top_p;\n}",
        "begin_line": 741,
        "end_line": 809,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.opfunc_construct#816",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.opfunc_construct (vm_frame_ctx_t *frame_ctx_p) /**< frame context */",
        "snippet": "static void\nopfunc_construct (vm_frame_ctx_t *frame_ctx_p) /**< frame context */\n{\n  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;\n  uint8_t opcode = byte_code_p[-1];\n  unsigned int arguments_list_len;\n\n  if (opcode >= CBC_NEW0)\n  {\n    arguments_list_len = (unsigned int) (opcode - CBC_NEW0);\n  }\n  else\n  {\n    arguments_list_len = *byte_code_p++;\n  }\n\n  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;\n  ecma_value_t constructor_value = stack_top_p[-1];\n  ecma_value_t completion_value;\n\n  ecma_error_msg_t constructor_message_id = ecma_check_constructor (constructor_value);\n  if (constructor_message_id != ECMA_IS_VALID_CONSTRUCTOR)\n  {\n    completion_value = ecma_raise_type_error (constructor_message_id);\n  }\n  else\n  {\n    ecma_object_t *constructor_obj_p = ecma_get_object_from_value (constructor_value);\n\n    completion_value =\n      ecma_op_function_construct (constructor_obj_p, constructor_obj_p, stack_top_p, arguments_list_len);\n  }\n\n  /* Free registers. */\n  for (uint32_t i = 0; i < arguments_list_len; i++)\n  {\n    ecma_fast_free_value (stack_top_p[i]);\n  }\n\n  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))\n  {\n#if JERRY_DEBUGGER\n    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;\n#endif /* JERRY_DEBUGGER */\n    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;\n  }\n  else\n  {\n    ecma_free_value (stack_top_p[-1]);\n    frame_ctx_p->byte_code_p = byte_code_p;\n    stack_top_p[-1] = completion_value;\n  }\n\n  frame_ctx_p->stack_top_p = stack_top_p;\n}",
        "begin_line": 816,
        "end_line": 870,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_construct_literal_object#430",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_construct_literal_object (vm_frame_ctx_t *frame_ctx_p, /**< frame context */                              ecma_value_t lit_value) /**< literal */",
        "snippet": "static ecma_value_t\nvm_construct_literal_object (vm_frame_ctx_t *frame_ctx_p, /**< frame context */\n                             ecma_value_t lit_value) /**< literal */\n{\n  ecma_compiled_code_t *bytecode_p;\n\n#if JERRY_SNAPSHOT_EXEC\n  if (JERRY_LIKELY (!(frame_ctx_p->shared_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))\n  {\n#endif /* JERRY_SNAPSHOT_EXEC */\n    bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, lit_value);\n#if JERRY_SNAPSHOT_EXEC\n  }\n  else\n  {\n    uint8_t *byte_p = ((uint8_t *) frame_ctx_p->shared_p->bytecode_header_p) + lit_value;\n    bytecode_p = (ecma_compiled_code_t *) byte_p;\n  }\n#endif /* JERRY_SNAPSHOT_EXEC */\n\n#if JERRY_BUILTIN_REGEXP\n  if (JERRY_UNLIKELY (!CBC_IS_FUNCTION (bytecode_p->status_flags)))\n  {\n    ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);\n\n    if (JERRY_UNLIKELY (regexp_obj_p == NULL))\n    {\n      return ECMA_VALUE_ERROR;\n    }\n\n    return ecma_op_create_regexp_from_bytecode (regexp_obj_p, (re_compiled_code_t *) bytecode_p);\n  }\n#else /* !JERRY_BUILTIN_REGEXP */\n  JERRY_ASSERT (CBC_IS_FUNCTION (bytecode_p->status_flags));\n#endif /* JERRY_BUILTIN_REGEXP */\n\n  ecma_object_t *func_obj_p;\n\n#if JERRY_ESNEXT\n  if (JERRY_UNLIKELY (CBC_FUNCTION_IS_ARROW (bytecode_p->status_flags)))\n  {\n    func_obj_p = ecma_op_create_arrow_function_object (frame_ctx_p->lex_env_p, bytecode_p, frame_ctx_p->this_binding);\n  }\n  else\n  {\n    func_obj_p = ecma_op_create_any_function_object (frame_ctx_p->lex_env_p, bytecode_p);\n  }\n#else /* !JERRY_ESNEXT */\n  func_obj_p = ecma_op_create_simple_function_object (frame_ctx_p->lex_env_p, bytecode_p);\n#endif /* JERRY_ESNEXT */\n\n  return ecma_make_object_value (func_obj_p);\n}",
        "begin_line": 430,
        "end_line": 482,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_run#5346",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_run (vm_frame_ctx_shared_t *shared_p, /**< shared data */         ecma_value_t this_binding_value, /**< value of 'ThisBinding' */         ecma_object_t *lex_env_p) /**< lexical environment to use */",
        "snippet": "ecma_value_t\nvm_run (vm_frame_ctx_shared_t *shared_p, /**< shared data */\n        ecma_value_t this_binding_value, /**< value of 'ThisBinding' */\n        ecma_object_t *lex_env_p) /**< lexical environment to use */\n{\n  const ecma_compiled_code_t *bytecode_header_p = shared_p->bytecode_header_p;\n  vm_frame_ctx_t *frame_ctx_p;\n  size_t frame_size;\n\n  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)\n  {\n    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;\n    frame_size = (size_t) (args_p->register_end + args_p->stack_limit);\n  }\n  else\n  {\n    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;\n    frame_size = (size_t) (args_p->register_end + args_p->stack_limit);\n  }\n\n  JERRY_VLA (ecma_value_t, stack, frame_size + (sizeof (vm_frame_ctx_t) / sizeof (ecma_value_t)));\n\n  frame_ctx_p = (vm_frame_ctx_t *) stack;\n\n  frame_ctx_p->shared_p = shared_p;\n  frame_ctx_p->lex_env_p = lex_env_p;\n  frame_ctx_p->this_binding = this_binding_value;\n\n  vm_init_exec (frame_ctx_p);\n  return vm_execute (frame_ctx_p);\n}",
        "begin_line": 5346,
        "end_line": 5376,
        "is_bug": false
    },
    {
        "name": "jerry-core.vm.vm.vm_run_global#257",
        "src_path": "jerry-core/vm/vm.c",
        "class_name": "jerry-core.vm.vm",
        "signature": "jerry-core.vm.vm.vm_run_global (const ecma_compiled_code_t *bytecode_p, /**< pointer to bytecode to run */                ecma_object_t *function_object_p) /**< function object if available */",
        "snippet": "ecma_value_t\nvm_run_global (const ecma_compiled_code_t *bytecode_p, /**< pointer to bytecode to run */\n               ecma_object_t *function_object_p) /**< function object if available */\n{\n#if JERRY_BUILTIN_REALMS\n  ecma_object_t *global_obj_p = (ecma_object_t *) ecma_op_function_get_realm (bytecode_p);\n#else /* !JERRY_BUILTIN_REALMS */\n  ecma_object_t *global_obj_p = ecma_builtin_get_global ();\n#endif /* JERRY_BUILTIN_REALMS */\n\n#if JERRY_ESNEXT\n  if (bytecode_p->status_flags & CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED)\n  {\n    ecma_create_global_lexical_block (global_obj_p);\n  }\n#endif /* JERRY_ESNEXT */\n\n  ecma_object_t *const global_scope_p = ecma_get_global_scope (global_obj_p);\n\n  vm_frame_ctx_shared_t shared;\n  shared.bytecode_header_p = bytecode_p;\n  shared.function_object_p = function_object_p;\n  shared.status_flags = 0;\n\n#if JERRY_BUILTIN_REALMS\n  ecma_value_t this_binding = ((ecma_global_object_t *) global_obj_p)->this_binding;\n\n  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);\n  JERRY_CONTEXT (global_object_p) = (ecma_global_object_t *) global_obj_p;\n#else /* !JERRY_BUILTIN_REALMS */\n  ecma_value_t this_binding = ecma_make_object_value (global_obj_p);\n#endif /* JERRY_BUILTIN_REALMS */\n\n  ecma_value_t result = vm_run (&shared, this_binding, global_scope_p);\n\n#if JERRY_BUILTIN_REALMS\n  JERRY_CONTEXT (global_object_p) = saved_global_object_p;\n#endif /* JERRY_BUILTIN_REALMS */\n\n  return result;\n}",
        "begin_line": 257,
        "end_line": 297,
        "is_bug": false
    }
]