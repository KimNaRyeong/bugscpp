[
    {
        "name": "test.stress.random256#44",
        "src_path": "test/stress.c",
        "class_name": "test.stress",
        "signature": "test.stress.random256()",
        "snippet": "static int random256()\n{\n    return rand() % 256;\n}",
        "begin_line": 44,
        "end_line": 47,
        "is_bug": false
    },
    {
        "name": "test.stress.commit_string#49",
        "src_path": "test/stress.c",
        "class_name": "test.stress",
        "signature": "test.stress.commit_string(ChewingContext *ctx)",
        "snippet": "void commit_string(ChewingContext *ctx)\n{\n    char *s;\n\n    if (chewing_commit_Check(ctx)) {\n        s = chewing_commit_String(ctx);\n        free(s);\n    }\n}",
        "begin_line": 49,
        "end_line": 57,
        "is_bug": false
    },
    {
        "name": "test.stress.read_from_fd#59",
        "src_path": "test/stress.c",
        "class_name": "test.stress",
        "signature": "test.stress.read_from_fd()",
        "snippet": "int read_from_fd()\n{\n    unsigned char c;\n    int len = read(input_fd, &c, 1);\n    if (len <= 0)\n        return EOF;\n    return c;\n}",
        "begin_line": 59,
        "end_line": 66,
        "is_bug": false
    },
    {
        "name": "test.stress.verbose_logger#68",
        "src_path": "test/stress.c",
        "class_name": "test.stress",
        "signature": "test.stress.verbose_logger(void *data, int level, const char *fmt, ...)",
        "snippet": "static void verbose_logger(void *data, int level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    vprintf(fmt, ap);\n    va_end(ap);\n    printf(\"\\r\");\n    fflush(stdout);\n}",
        "begin_line": 68,
        "end_line": 77,
        "is_bug": false
    },
    {
        "name": "test.stress.main#79",
        "src_path": "test/stress.c",
        "class_name": "test.stress",
        "signature": "test.stress.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    int i;\n    int flag_random_init = 0;\n    int flag_random_extra = 0;\n    int flag_loop = -1;\n    int flag_verbose = 0;\n    int (*get_input)() = &random256;\n    void (*logger) (void *data, int level, const char *fmt, ...) = NULL;\n    char *chewing_sys_path;\n    char *userphrase_path;\n    int num_special_key = 0;\n    int num_normal_key = sizeof(normal_keys) / sizeof(normal_keys[0]);\n    TestKeyEntry *key_entry;\n\n    for (i = 1; i < argc; i++) {\n        if (strcmp(argv[i], \"-init\") == 0)\n            flag_random_init = 1;\n        else if (strcmp(argv[i], \"-extra\") == 0)\n            flag_random_extra = 1;\n        else if (strcmp(argv[i], \"-verbose\") == 0) {\n            flag_verbose = 1;\n            logger = verbose_logger;\n        } else if (strcmp(argv[i], \"-loop\") == 0 && argv[i + 1])\n            flag_loop = atoi(argv[++i]);\n        else if (strcmp(argv[i], \"-stdin\") == 0) {\n            input_fd = 0;\n            get_input = &read_from_fd;\n        } else if (strcmp(argv[i], \"-file\") == 0 && argv[i + 1]) {\n            input_fd = open(argv[i + 1], O_RDONLY);\n            if (input_fd < 0) {\n                fprintf(stderr, \"failed to open '%s'\\n\", argv[i + 1]);\n                exit(1);\n            }\n            get_input = &read_from_fd;\n            i++;\n        } else {\n            printf(\"Usage: %s [-init] [-extra] [-loop N] [-stdin]\\n\", argv[0]);\n            printf(\"\\t-init           Random initial configuration\\n\");\n            printf(\"\\t-extra          Random change all configurations during input.\\n\");\n            printf(\"\\t                This is usually unexpected.\\n\");\n            printf(\"\\t-stdin          Get random input from stdin\\n\");\n            printf(\"\\t-loop N         How many iterations to test (default infinite=-1)\\n\");\n            printf(\"\\t-verbose        Verbose\\n\");\n            exit(1);\n        }\n    }\n\n    /* Initialize for testing */\n    for (key_entry = chewing_test_special_keys; key_entry->key; key_entry++)\n        num_special_key++;\n\n    /* Initialize libchewing */\n    chewing_sys_path = getenv(\"CHEWING_PATH\");\n    if (!chewing_sys_path)\n        chewing_sys_path = CHEWING_DATA_PREFIX;\n\n    /* for the sake of testing, we should not change existing hash data */\n    userphrase_path = get_test_userphrase_path();\n\n    for (i = 0; i != flag_loop; i++) {\n        ChewingContext *ctx;\n        clean_userphrase();\n        ctx = chewing_new2(chewing_sys_path, userphrase_path, logger, NULL);\n\n        /* typical configuration */\n        chewing_set_KBType(ctx, chewing_KBStr2Num(\"KB_DEFAULT\"));\n        chewing_set_candPerPage(ctx, 9);\n        chewing_set_maxChiSymbolLen(ctx, 16);\n        chewing_set_addPhraseDirection(ctx, 1);\n        chewing_set_selKey(ctx, selKey_define, 10);\n        chewing_set_spaceAsSelection(ctx, 1);\n\n        if (flag_random_init) {\n            chewing_set_KBType(ctx, get_input());\n            chewing_set_candPerPage(ctx, get_input());\n            chewing_set_maxChiSymbolLen(ctx, get_input());\n            chewing_set_addPhraseDirection(ctx, get_input());\n            chewing_set_selKey(ctx, selKey_define, get_input() % 11);\n            chewing_set_spaceAsSelection(ctx, get_input());\n            chewing_set_escCleanAllBuf(ctx, get_input());\n            chewing_set_autoShiftCur(ctx, get_input());\n            chewing_set_easySymbolInput(ctx, get_input());\n            chewing_set_phraseChoiceRearward(ctx, get_input());\n        }\n\n        while (1) {\n            /* Random value: [0, max_key) for keys, [max_key, 0xff] for\n             * configurations. Use a fixed range here because I don't want the\n             * meaning of input changed a lot frequently if we add more keys in\n             * the future. */\n            const int max_key = 192;  /* arbitrary number */\n            int v = get_input();\n            if (v == EOF)\n                break;\n            assert(max_key >= (num_special_key + num_normal_key));\n            if (v >= max_key) {\n                const int typical = 2;\n                int handled = 1;\n                v = v - max_key;\n                if (flag_random_extra || v < typical) {\n                    switch (v) {\n                    /* typical configurations may be changed during input */\n                    case 0:\n                        chewing_set_ChiEngMode(ctx, get_input());\n                        break;\n                    case 1:\n                        chewing_set_ShapeMode(ctx, get_input());\n                        break;\n                    /* usually not changed during input */\n                    case 2:\n                        chewing_set_KBType(ctx, get_input());\n                        break;\n                    case 3:\n                        chewing_set_candPerPage(ctx, get_input());\n                        break;\n                    case 4:\n                        chewing_set_maxChiSymbolLen(ctx, get_input());\n                        break;\n                    case 5:\n                        chewing_set_addPhraseDirection(ctx, get_input());\n                        break;\n                    case 6:\n                        chewing_set_selKey(ctx, selKey_define, get_input() % 11);\n                        break;\n                    case 7:\n                        chewing_set_spaceAsSelection(ctx, get_input());\n                        break;\n                    case 8:\n                        chewing_set_escCleanAllBuf(ctx, get_input());\n                        break;\n                    case 9:\n                        chewing_set_autoShiftCur(ctx, get_input());\n                        break;\n                    case 10:\n                        chewing_set_easySymbolInput(ctx, get_input());\n                        break;\n                    case 11:\n                        chewing_set_phraseChoiceRearward(ctx, get_input());\n                        break;\n                    default:\n                        handled = 0;\n                        break;\n                    }\n                } else {\n                    handled = 0;\n                }\n                if (!handled)\n                    break;\n            } else {\n                if (0 <= v && v < num_special_key) {\n                    int key = chewing_test_special_keys[v].key;\n                    if (flag_verbose) {\n                        printf(\"\\r\\n------------------------------\\r\\n\");\n                        printf(\"keystroke: %s\\r\\n\", chewing_test_special_keys[v].str);\n                        fflush(stdout);\n                    }\n                    type_single_keystroke(ctx, key);\n                } else if (num_special_key <= v && v < num_special_key + num_normal_key) {\n                    int key = normal_keys[v - num_special_key];\n                    if (flag_verbose) {\n                        printf(\"\\r\\n------------------------------\\r\\n\");\n                        printf(\"keystroke: [%c]\\r\\n\", key);\n                        fflush(stdout);\n                    }\n                    type_single_keystroke(ctx, key);\n                } else {\n                    break;\n                }\n            }\n            commit_string(ctx);\n        }\n        if (flag_verbose)\n            printf(\"\\r\\n\");\n        chewing_delete(ctx);\n\n#if !defined(_WIN32) && !defined(_WIN64) && !defined(_WIN32_WCE)\n        if (getenv(\"AFL_PERSISTENT\"))\n            raise(SIGSTOP);\n#endif\n    }\n    clean_userphrase();\n\n    if (input_fd > 0)\n        close(input_fd);\n\n    return 0;\n}",
        "begin_line": 79,
        "end_line": 266,
        "is_bug": false
    },
    {
        "name": "test.test-keyboard.test_set_keyboard_type#42",
        "src_path": "test/test-keyboard.c",
        "class_name": "test.test-keyboard",
        "signature": "test.test-keyboard.test_set_keyboard_type()",
        "snippet": "void test_set_keyboard_type()\n{\n    ChewingContext *ctx;\n    size_t i;\n    char *keyboard_string;\n    int keyboard_type;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    keyboard_string = chewing_get_KBString(ctx);\n    ok(strcmp(keyboard_string, KEYBOARD_STRING[KEYBOARD_DEFAULT_TYPE]) == 0,\n       \"`%s' shall be `%s'\", keyboard_string, KEYBOARD_STRING[KEYBOARD_DEFAULT_TYPE]);\n    chewing_free(keyboard_string);\n    keyboard_type = chewing_get_KBType(ctx);\n    ok(keyboard_type == KEYBOARD_DEFAULT_TYPE, \"`%d' shall be `%d'\", keyboard_type, KEYBOARD_DEFAULT_TYPE);\n\n    for (i = 0; i < ARRAY_SIZE(KEYBOARD_STRING); ++i) {\n        ok(chewing_set_KBType(ctx, i) == 0, \"return shall be 0\");\n\n        keyboard_string = chewing_get_KBString(ctx);\n        ok(strcmp(keyboard_string, KEYBOARD_STRING[i]) == 0, \"`%s' shall be `%s'\", keyboard_string, KEYBOARD_STRING[i]);\n        chewing_free(keyboard_string);\n        keyboard_type = chewing_get_KBType(ctx);\n        ok(keyboard_type == (int) i, \"`%d' shall be `%d'\", keyboard_type, (int) i);\n    }\n\n    // The invalid KBType will reset KBType to default value.\n    ok(chewing_set_KBType(ctx, -1) == -1, \"return shall be -1\");\n    keyboard_type = chewing_get_KBType(ctx);\n    ok(keyboard_type == KEYBOARD_DEFAULT_TYPE, \"`%d' shall be `%d'\", keyboard_type, KEYBOARD_DEFAULT_TYPE);\n\n    ok(chewing_set_KBType(ctx, ARRAY_SIZE(KEYBOARD_STRING) + 1), \"return shall be -1\");\n    keyboard_type = chewing_get_KBType(ctx);\n    ok(keyboard_type == KEYBOARD_DEFAULT_TYPE, \"`%d' shall be `%d'\", keyboard_type, KEYBOARD_DEFAULT_TYPE);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 42,
        "end_line": 79,
        "is_bug": false
    },
    {
        "name": "test.test-keyboard.test_KBStr2Num#81",
        "src_path": "test/test-keyboard.c",
        "class_name": "test.test-keyboard",
        "signature": "test.test-keyboard.test_KBStr2Num()",
        "snippet": "void test_KBStr2Num()\n{\n    int i;\n    int ret;\n\n    start_testcase(NULL, fd);\n\n    for (i = 0; i < (int) ARRAY_SIZE(KEYBOARD_STRING); ++i) {\n        // XXX: chewing_KBStr2Num shall accept const char *.\n        ret = chewing_KBStr2Num(KEYBOARD_STRING[i]);\n        ok(ret == i, \"%d shall be %d\", ret, i);\n    }\n}",
        "begin_line": 81,
        "end_line": 93,
        "is_bug": false
    },
    {
        "name": "test.test-keyboard.test_enumerate_keyboard_type#95",
        "src_path": "test/test-keyboard.c",
        "class_name": "test.test-keyboard",
        "signature": "test.test-keyboard.test_enumerate_keyboard_type()",
        "snippet": "void test_enumerate_keyboard_type()\n{\n    ChewingContext *ctx;\n    size_t i;\n    char *keyboard_string;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    ok(chewing_kbtype_Total(ctx) == ARRAY_SIZE(KEYBOARD_STRING),\n       \"total keyboard_string type shall be %d\", ARRAY_SIZE(KEYBOARD_STRING));\n\n    chewing_kbtype_Enumerate(ctx);\n    for (i = 0; i < ARRAY_SIZE(KEYBOARD_STRING); ++i) {\n        ok(chewing_kbtype_hasNext(ctx) == 1, \"shall have next keyboard_string type\");\n        keyboard_string = chewing_kbtype_String(ctx);\n        ok(strcmp(keyboard_string, KEYBOARD_STRING[i]) == 0, \"`%s' shall be `%s'\", keyboard_string, KEYBOARD_STRING[i]);\n        chewing_free(keyboard_string);\n    }\n    ok(chewing_kbtype_hasNext(ctx) == 0, \"shall not have next keyboard_string type\");\n    keyboard_string = chewing_kbtype_String(ctx);\n    ok(strcmp(keyboard_string, \"\") == 0, \"`%s' shall be `%s'\", keyboard_string, \"\");\n    chewing_free(keyboard_string);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 95,
        "end_line": 120,
        "is_bug": false
    },
    {
        "name": "test.test-keyboard.test_hsu_po_to_bo#122",
        "src_path": "test/test-keyboard.c",
        "class_name": "test.test-keyboard",
        "signature": "test.test-keyboard.test_hsu_po_to_bo()",
        "snippet": "void test_hsu_po_to_bo()\n{\n    // https://github.com/chewing/libchewing/issues/170\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_KBType(ctx, chewing_KBStr2Num(\"KB_HSU\"));\n\n    type_keystroke_by_string(ctx, \"p\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x86\" /* \u3106 */ );\n\n    type_keystroke_by_string(ctx, \"b\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x85\" /* \u3105 */ );\n\n    chewing_delete(ctx);\n}\n\nvo",
        "begin_line": 122,
        "end_line": 139,
        "is_bug": false
    },
    {
        "name": "test.test-keyboard.test_hsu#141",
        "src_path": "test/test-keyboard.c",
        "class_name": "test.test-keyboard",
        "signature": "test.test-keyboard.test_hsu()",
        "snippet": "void test_hsu()\n{\n    test_hsu_po_to_bo();\n}",
        "begin_line": 141,
        "end_line": 144,
        "is_bug": false
    },
    {
        "name": "test.test-keyboard.test_et26_po_to_bo#146",
        "src_path": "test/test-keyboard.c",
        "class_name": "test.test-keyboard",
        "signature": "test.test-keyboard.test_et26_po_to_bo()",
        "snippet": "void test_et26_po_to_bo()\n{\n    // https://github.com/chewing/libchewing/issues/170\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_KBType(ctx, chewing_KBStr2Num(\"KB_ET26\"));\n\n    type_keystroke_by_string(ctx, \"p\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x86\" /* \u3106 */ );\n\n    type_keystroke_by_string(ctx, \"b\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x85\" /* \u3105 */ );\n\n    chewing_delete(ctx);\n}\n\nvo",
        "begin_line": 146,
        "end_line": 163,
        "is_bug": false
    },
    {
        "name": "test.test-keyboard.test_et26#165",
        "src_path": "test/test-keyboard.c",
        "class_name": "test.test-keyboard",
        "signature": "test.test-keyboard.test_et26()",
        "snippet": "void test_et26()\n{\n    test_et26_po_to_bo();\n}",
        "begin_line": 165,
        "end_line": 168,
        "is_bug": false
    },
    {
        "name": "test.test-keyboard.main#170",
        "src_path": "test/test-keyboard.c",
        "class_name": "test.test-keyboard",
        "signature": "test.test-keyboard.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    char *logname;\n    int ret;\n\n    putenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n    putenv(\"CHEWING_USER_PATH=\" TEST_HASH_DIR);\n\n    ret = asprintf(&logname, \"%s.log\", argv[0]);\n    if (ret == -1)\n        return -1;\n    fd = fopen(logname, \"w\");\n    assert(fd);\n    free(logname);\n\n    test_set_keyboard_type();\n    test_KBStr2Num();\n    test_enumerate_keyboard_type();\n\n    test_hsu();\n    test_et26();\n\n    fclose(fd);\n\n    return exit_status();\n}",
        "begin_line": 170,
        "end_line": 195,
        "is_bug": false
    },
    {
        "name": "test.test-fullshape.test_fullshape_input#101",
        "src_path": "test/test-fullshape.c",
        "class_name": "test.test-fullshape",
        "signature": "test.test-fullshape.test_fullshape_input()",
        "snippet": "void test_fullshape_input()\n{\n    ChewingContext *ctx;\n    size_t i;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_ChiEngMode(ctx, SYMBOL_MODE);\n    chewing_set_ShapeMode(ctx, FULLSHAPE_MODE);\n\n    for (i = 0; i < ARRAY_SIZE(FULLSHAPE_DATA); ++i) {\n        type_keystroke_by_string(ctx, FULLSHAPE_DATA[i].token);\n        // fullshape symbol does not present in preedit buffer.\n        ok_preedit_buffer(ctx, \"\");\n        ok_commit_buffer(ctx, FULLSHAPE_DATA[i].expected);\n    }\n\n    chewing_delete(ctx);\n}",
        "begin_line": 101,
        "end_line": 120,
        "is_bug": false
    },
    {
        "name": "test.test-fullshape.test_set_fullshape#122",
        "src_path": "test/test-fullshape.c",
        "class_name": "test.test-fullshape",
        "signature": "test.test-fullshape.test_set_fullshape()",
        "snippet": "void test_set_fullshape()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    ok(chewing_get_ShapeMode(ctx) == HALFSHAPE_MODE, \"default is HALFSHAPE_MODE\");\n\n    chewing_set_ShapeMode(ctx, FULLSHAPE_MODE);\n    ok(chewing_get_ShapeMode(ctx) == FULLSHAPE_MODE, \"mode shall change to FULLSHAPE_MODE\");\n\n    chewing_set_ShapeMode(ctx, -1);\n    ok(chewing_get_ShapeMode(ctx) == FULLSHAPE_MODE, \"mode shall not change when parameter is invalid\");\n\n    chewing_set_ShapeMode(ctx, HALFSHAPE_MODE);\n    ok(chewing_get_ShapeMode(ctx) == HALFSHAPE_MODE, \"mode shall change to HALFSHAPE_MODE\");\n\n    chewing_set_ShapeMode(ctx, -1);\n    ok(chewing_get_ShapeMode(ctx) == HALFSHAPE_MODE, \"mode shall not change when parameter is invalid\");\n\n\n    chewing_delete(ctx);\n}",
        "begin_line": 122,
        "end_line": 145,
        "is_bug": false
    },
    {
        "name": "test.test-fullshape.main#147",
        "src_path": "test/test-fullshape.c",
        "class_name": "test.test-fullshape",
        "signature": "test.test-fullshape.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    char *logname;\n    int ret;\n\n    putenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n    putenv(\"CHEWING_USER_PATH=\" TEST_HASH_DIR);\n\n    ret = asprintf(&logname, \"%s.log\", argv[0]);\n    if (ret == -1)\n        return -1;\n    fd = fopen(logname, \"w\");\n    assert(fd);\n    free(logname);\n\n\n    test_set_fullshape();\n    test_fullshape_input();\n\n    fclose(fd);\n\n    return exit_status();\n}",
        "begin_line": 147,
        "end_line": 169,
        "is_bug": false
    },
    {
        "name": "test.test-special-symbol.is_bopomofo_collision_key#56",
        "src_path": "test/test-special-symbol.c",
        "class_name": "test.test-special-symbol",
        "signature": "test.test-special-symbol.is_bopomofo_collision_key(const char *key)",
        "snippet": "int is_bopomofo_collision_key(const char *key)\n{\n    static const char *COLLISION_KEY[] = {\n        \"<<>\",\n        \">\",\n        \";\",\n        \",\",\n        \".\",\n    };\n    size_t i;\n\n    for (i = 0; i < ARRAY_SIZE(COLLISION_KEY); ++i) {\n        if (strcmp(key, COLLISION_KEY[i]) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}",
        "begin_line": 56,
        "end_line": 73,
        "is_bug": false
    },
    {
        "name": "test.test-special-symbol.test_in_chinese_mode#75",
        "src_path": "test/test-special-symbol.c",
        "class_name": "test.test-special-symbol",
        "signature": "test.test-special-symbol.test_in_chinese_mode()",
        "snippet": "void test_in_chinese_mode()\n{\n    ChewingContext *ctx;\n    size_t i;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_maxChiSymbolLen(ctx, 16);\n\n    for (i = 0; i < ARRAY_SIZE(SPECIAL_SYMBOL_TABLE); ++i) {\n        // If bopomofo symbol is collided with special symbol, use\n        // bopomofo symbol\n        if (is_bopomofo_collision_key(SPECIAL_SYMBOL_TABLE[i].token))\n            continue;\n\n        type_keystroke_by_string(ctx, SPECIAL_SYMBOL_TABLE[i].token);\n        ok_preedit_buffer(ctx, SPECIAL_SYMBOL_TABLE[i].expected);\n        type_keystroke_by_string(ctx, \"<E>\");\n        ok_commit_buffer(ctx, SPECIAL_SYMBOL_TABLE[i].expected);\n    }\n\n    chewing_delete(ctx);\n}",
        "begin_line": 75,
        "end_line": 98,
        "is_bug": false
    },
    {
        "name": "test.test-special-symbol.test_in_easy_symbol_mode#100",
        "src_path": "test/test-special-symbol.c",
        "class_name": "test.test-special-symbol",
        "signature": "test.test-special-symbol.test_in_easy_symbol_mode()",
        "snippet": "void test_in_easy_symbol_mode()\n{\n    ChewingContext *ctx;\n    size_t i;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_maxChiSymbolLen(ctx, 16);\n    chewing_set_easySymbolInput(ctx, 1);\n\n    for (i = 0; i < ARRAY_SIZE(SPECIAL_SYMBOL_TABLE); ++i) {\n        type_keystroke_by_string(ctx, SPECIAL_SYMBOL_TABLE[i].token);\n        ok_preedit_buffer(ctx, SPECIAL_SYMBOL_TABLE[i].expected);\n        type_keystroke_by_string(ctx, \"<E>\");\n        ok_commit_buffer(ctx, SPECIAL_SYMBOL_TABLE[i].expected);\n    }\n\n    chewing_delete(ctx);\n}",
        "begin_line": 100,
        "end_line": 119,
        "is_bug": false
    },
    {
        "name": "test.test-special-symbol.is_fullshape_collision_key#121",
        "src_path": "test/test-special-symbol.c",
        "class_name": "test.test-special-symbol",
        "signature": "test.test-special-symbol.is_fullshape_collision_key(const char *key)",
        "snippet": "int is_fullshape_collision_key(const char *key)\n{\n    static const char *COLLISION_KEY[] = {\n        \"\\\"\",\n        \"'\",\n        \"/\",\n        \"<<>\",\n        \">\",\n        \"`\",\n        \"[\",\n        \"]\",\n        \"{\",\n        \"}\",\n        \"+\",\n        \"-\",\n    };\n    size_t i;\n\n    for (i = 0; i < ARRAY_SIZE(COLLISION_KEY); ++i) {\n        if (strcmp(key, COLLISION_KEY[i]) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}",
        "begin_line": 121,
        "end_line": 145,
        "is_bug": false
    },
    {
        "name": "test.test-special-symbol.test_in_fullshape_mode#147",
        "src_path": "test/test-special-symbol.c",
        "class_name": "test.test-special-symbol",
        "signature": "test.test-special-symbol.test_in_fullshape_mode()",
        "snippet": "void test_in_fullshape_mode()\n{\n    ChewingContext *ctx;\n    size_t i;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_maxChiSymbolLen(ctx, 16);\n    chewing_set_ChiEngMode(ctx, SYMBOL_MODE);\n    chewing_set_ShapeMode(ctx, FULLSHAPE_MODE);\n\n    for (i = 0; i < ARRAY_SIZE(SPECIAL_SYMBOL_TABLE); ++i) {\n        // If fullshape symbol is collided with special symbol, use\n        // fullshape symbol\n        if (is_fullshape_collision_key(SPECIAL_SYMBOL_TABLE[i].token))\n            continue;\n\n        type_keystroke_by_string(ctx, SPECIAL_SYMBOL_TABLE[i].token);\n        ok_preedit_buffer(ctx, \"\");\n        ok_commit_buffer(ctx, SPECIAL_SYMBOL_TABLE[i].expected);\n    }\n\n    chewing_delete(ctx);\n}",
        "begin_line": 147,
        "end_line": 171,
        "is_bug": false
    },
    {
        "name": "test.test-special-symbol.main#173",
        "src_path": "test/test-special-symbol.c",
        "class_name": "test.test-special-symbol",
        "signature": "test.test-special-symbol.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    char *logname;\n    int ret;\n\n    putenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n    putenv(\"CHEWING_USER_PATH=\" TEST_HASH_DIR);\n\n    ret = asprintf(&logname, \"%s.log\", argv[0]);\n    if (ret == -1)\n        return -1;\n    fd = fopen(logname, \"w\");\n    assert(fd);\n    free(logname);\n\n\n    test_in_chinese_mode();\n    test_in_easy_symbol_mode();\n    test_in_fullshape_mode();\n\n    fclose(fd);\n\n    return exit_status();\n}",
        "begin_line": 173,
        "end_line": 196,
        "is_bug": false
    },
    {
        "name": "test.randkeystroke.usage#36",
        "src_path": "test/randkeystroke.c",
        "class_name": "test.randkeystroke",
        "signature": "test.randkeystroke.usage()",
        "snippet": "void usage()\n{\n    printf(\"usage: randkeystroke [-r] [-n num] [-h]\\n\"\n           \"\\t -r     - total random\\n\"\n           \"\\t -n num - generate num keystrokes\\n\" \"\\t -s seed - random seed\\n\" \"\\t -h     - help\\n\");\n}",
        "begin_line": 36,
        "end_line": 41,
        "is_bug": false
    },
    {
        "name": "test.randkeystroke.main#43",
        "src_path": "test/randkeystroke.c",
        "class_name": "test.randkeystroke",
        "signature": "test.randkeystroke.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    int nk = 100;\n    int total_random = 0;\n    int i, n;\n    int n_tab1 = strlen(zhuin_keys[0]);\n    int n_tab2 = strlen(zhuin_keys[1]);\n    int n_tab3 = strlen(zhuin_keys[2]);\n    int n_tab4 = strlen(zhuin_keys[3]);\n\tint n_okeys = 0;\n\n    TestKeyEntry *key_entry;\n    for (key_entry = chewing_test_special_keys; key_entry->key; key_entry++) {\n\tn_okeys++;\n    }\n\n    srand(time(NULL));\n\n    for (i = 1; i < argc; i++) {\n        if (!strcmp(argv[i], \"-n\")) {\n            if (++i < argc)\n                nk = atoi(argv[i]);\n        } else if (!strcmp(argv[i], \"-r\")) {\n            total_random = 1;\n        } else if (!strcmp(argv[i], \"-s\")) {\n            if (++i < argc)\n                srand(atoi(argv[i]));\n        } else if (!strcmp(argv[i], \"-h\")) {\n            usage();\n            return 0;\n        }\n    }\n    if (total_random) {\n        for (i = 0; i < nk; i++) {\n            n = rand() % (n_nkeys + n_okeys);\n            if (n >= n_nkeys)\n                printf(\"%s\", chewing_test_special_keys[n - n_nkeys].str);\n            else\n                printf(\"%c\", normal_keys[n]);\n        }\n    } else {\n        for (i = 0; i < nk; i++) {\n            if (rand() % 2)\n                printf(\"%c\", zhuin_keys[0][rand() % n_tab1]);\n            if (rand() % 2)\n                printf(\"%c\", zhuin_keys[1][rand() % n_tab2]);\n            if (rand() % 2)\n                printf(\"%c\", zhuin_keys[2][rand() % n_tab3]);\n            if (rand() % 2)\n                printf(\"%c\", zhuin_keys[3][rand() % n_tab4]);\n            else\n                printf(\" \");\n            if (rand() % 2)\n                printf(\"<E>\");\n        }\n    }\n    printf(\"\\n\");\n\n    return 0;\n}",
        "begin_line": 43,
        "end_line": 102,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.drawline#71",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.drawline(int x, int y)",
        "snippet": "void drawline(int x, int y)\n{\n    move(x, y);\n    addstr(FILL_LINE);\n}",
        "begin_line": 71,
        "end_line": 75,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.show_edit_buffer#77",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.show_edit_buffer(int x, int y, ChewingContext *ctx)",
        "snippet": "void show_edit_buffer(int x, int y, ChewingContext *ctx)\n{\n    int i, cursor, count;\n    const char *buffer_string;\n    const char *p;\n\n    move(x, y);\n    addstr(FILL_BLANK);\n    if (!chewing_buffer_Check(ctx)) {\n        move(x, y);\n        return;\n    }\n    buffer_string = chewing_buffer_String_static(ctx);\n    mvaddstr(x, y, buffer_string);\n    cursor = chewing_cursor_Current(ctx);\n    p = buffer_string;\n    count = 0;\n    for (i = 0; i < cursor; i++) {\n        count += ueBytesFromChar(*p) <= 1 ? 1 : 2;\n        p += ueBytesFromChar(*p);\n    }\n    move(x, count);\n}",
        "begin_line": 77,
        "end_line": 99,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.show_interval_buffer#101",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.show_interval_buffer(int x, int y, ChewingContext *ctx)",
        "snippet": "void show_interval_buffer(int x, int y, ChewingContext *ctx)\n{\n    const char *buf;\n    const char *p;\n    int buf_len;\n    char out_buf[100];\n    int i, count;\n    int arrPos[50];\n    IntervalType it;\n\n    move(x, y);\n    addstr(FILL_BLANK);\n    move(x, y);\n\n    /* Check if buffer is available. */\n    if (!chewing_buffer_Check(ctx)) {\n        return;\n    }\n\n    buf = chewing_buffer_String_static(ctx);\n    buf_len = chewing_buffer_Len(ctx);\n\n    p = buf;\n    count = 0;\n    for (i = 0; i < buf_len; i++) {\n        arrPos[i] = count;\n        count += ueBytesFromChar(*p) <= 1 ? 1 : 2;\n        p += ueBytesFromChar(*p);\n    }\n    arrPos[i] = count;\n\n    memset(out_buf, ' ', count * (sizeof(char)));\n    out_buf[count] = '\\0';\n\n    chewing_interval_Enumerate(ctx);\n    while (chewing_interval_hasNext(ctx)) {\n        chewing_interval_Get(ctx, &it);\n        out_buf[arrPos[it.from]] = '[';\n        out_buf[arrPos[it.to] - 1] = ']';\n        memset(&out_buf[arrPos[it.from] + 1], '-', arrPos[it.to] - arrPos[it.from] - 2);\n    }\n    addstr(out_buf);\n}",
        "begin_line": 101,
        "end_line": 143,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.showBopomofo#145",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.showBopomofo(ChewingContext *ctx)",
        "snippet": "void showBopomofo(ChewingContext *ctx)\n{\n    if (chewing_get_ChiEngMode(ctx))\n        addstr(\"[\u4e2d]\");\n    else\n        addstr(\"[\u82f1]\");\n    addstr(\"        \");\n    addstr(chewing_bopomofo_String_static(ctx));\n}\n\nvo",
        "begin_line": 145,
        "end_line": 153,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.show_bopomofo_buffer#155",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.show_bopomofo_buffer(int x, int y, ChewingContext *ctx)",
        "snippet": "void show_bopomofo_buffer(int x, int y, ChewingContext *ctx)\n{\n    move(x, y);\n    addstr(FILL_BLANK);\n    move(x, y);\n    if (hasColor)\n        attron(COLOR_PAIR(1));\n    showBopomofo(ctx);\n    if (hasColor)\n        attroff(COLOR_PAIR(1));\n}",
        "begin_line": 155,
        "end_line": 165,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.show_full_shape#167",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.show_full_shape(int x, int y, ChewingContext *ctx)",
        "snippet": "void show_full_shape(int x, int y, ChewingContext *ctx)\n{\n    move(x, y);\n    addstr(\"[\");\n    if (hasColor)\n        attron(COLOR_PAIR(2));\n    if (chewing_get_ShapeMode(ctx) == FULLSHAPE_MODE)\n        addstr(\"\u5168\u5f62\");\n    else\n        addstr(\"\u534a\u5f62\");\n    if (hasColor)\n        attroff(COLOR_PAIR(2));\n    addstr(\"]\");\n}\n\nvoid s",
        "begin_line": 167,
        "end_line": 180,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.show_userphrase#182",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.show_userphrase(int x, int y, ChewingContext *ctx)",
        "snippet": "void show_userphrase(int x, int y, ChewingContext *ctx)\n{\n    const char *aux_string;\n\n    if (chewing_aux_Length(ctx) == 0)\n        return;\n\n    move(x, y);\n    addstr(FILL_BLANK);\n    move(x, y);\n    if (hasColor)\n        attron(COLOR_PAIR(2));\n    aux_string = chewing_aux_String_static(ctx);\n    addstr(aux_string);\n    if (hasColor)\n        attroff(COLOR_PAIR(2));\n}",
        "begin_line": 182,
        "end_line": 198,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.show_choose_buffer#200",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.show_choose_buffer(int x, int y, ChewingContext *ctx)",
        "snippet": "void show_choose_buffer(int x, int y, ChewingContext *ctx)\n{\n    int i = 1;\n    int currentPageNo;\n    char str[20];\n    const char *cand_string;\n\n    move(x, y);\n    addstr(FILL_BLANK);\n    move(x, y);\n\n    if (chewing_cand_TotalPage(ctx) == 0)\n        return;\n\n    chewing_cand_Enumerate(ctx);\n    while (chewing_cand_hasNext(ctx)) {\n        if (i > chewing_cand_ChoicePerPage(ctx))\n            break;\n        snprintf(str, sizeof(str), \"%d.\", i);\n        if (hasColor)\n            attron(COLOR_PAIR(3));\n        addstr(str);\n        if (hasColor)\n            attroff(COLOR_PAIR(3));\n        cand_string = chewing_cand_String_static(ctx);\n        addstr(cand_string);\n        i++;\n    }\n    currentPageNo = chewing_cand_CurrentPage(ctx);\n    if (chewing_cand_TotalPage(ctx) != 1) {\n        if (currentPageNo == 0)\n            addstr(\"  >\");\n        else if (currentPageNo == (chewing_cand_TotalPage(ctx) - 1))\n            addstr(\"<  \");\n        else\n            addstr(\"< >\");\n    }\n}",
        "begin_line": 200,
        "end_line": 237,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.show_commit_string#239",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.show_commit_string(int x, int y, ChewingContext *ctx)",
        "snippet": "void show_commit_string(int x, int y, ChewingContext *ctx)\n{\n    const char *commit_string;\n\n#if 0\n    if (pgo->keystrokeRtn & KEYSTROKE_COMMIT) {\n        for (i = 0; i < pgo->CommitBufLen; i++) {\n            mvaddstr(x, y, (const char *) pgo->commitStr[i].s);\n            y = (y >= 54) ? 0 : (y + strlen((const char *) pgo->commitStr[i].s) - 3 < 0 ? y + 1 : y + 2);\n            x = (y == 0) ? (x + 1) : x;\n        }\n    }\n#endif\n    if (chewing_commit_Check(ctx)) {\n        commit_string = chewing_commit_String_static(ctx);\n        mvaddstr(x, y, FILL_BLANK);\n        mvaddstr(x, y, commit_string);\n    }\n}",
        "begin_line": 239,
        "end_line": 257,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.logger#259",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.logger(void *data, int level, const char *fmt, ...)",
        "snippet": "static void logger(void *data, int level, const char *fmt, ...)\n{\n    va_list ap;\n    FILE *fd = (FILE *) data;\n\n    va_start(ap, fmt);\n    vfprintf(fd, fmt, ap);\n    va_end(ap);\n}",
        "begin_line": 259,
        "end_line": 267,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.main#269",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    ChewingContext *ctx = NULL;\n    FILE *fout = NULL;\n    FILE *log = NULL;\n    int ch;\n    int add_phrase_length;\n\n    if (argc < 2) {\n        fprintf(stderr, \"usage: genkeystroke filename\\n\");\n        exit(1);\n    } else {\n        fout = fopen(argv[1], \"w\");\n        if (!fout) {\n            fprintf(stderr, \"Error: failed to open %s\\n\", argv[1]);\n            exit(1);\n        }\n    }\n\n    log = fopen(LOGNAME, \"w\");\n    if (!log) {\n        fprintf(stderr, \"Error: failed to open %s\\n\", LOGNAME);\n        goto end;\n    }\n\n    /* Initialize curses library */\n    setlocale(LC_CTYPE, \"\");\n    initscr();\n    if (has_colors() == TRUE) {\n        start_color();\n        init_pair(1, COLOR_WHITE, COLOR_BLUE);\n        init_pair(2, COLOR_RED, COLOR_YELLOW);\n        init_pair(3, COLOR_WHITE, COLOR_RED);\n        hasColor = 1;\n    }\n    cbreak();\n    noecho();\n    keypad(stdscr, 1);\n    start_color();\n    clear();\n    refresh();\n\n    /* Initialize libchewing */\n    putenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n    /* for the sake of testing, we should not change existing hash data */\n    putenv(\"CHEWING_USER_PATH=\" TEST_HASH_DIR);\n\n    /* Request handle to ChewingContext */\n    ctx = chewing_new2(NULL, NULL, logger, log);\n\n    /* Set keyboard type */\n    chewing_set_KBType(ctx, chewing_KBStr2Num(\"KB_DEFAULT\"));\n\n    /* Fill configuration values */\n    chewing_set_candPerPage(ctx, 9);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n    chewing_set_addPhraseDirection(ctx, 1);\n    chewing_set_selKey(ctx, selKey_define, 10);\n    chewing_set_spaceAsSelection(ctx, 1);\n    chewing_set_autoShiftCur(ctx, 1);\n    chewing_set_phraseChoiceRearward(ctx, 1);\n\n    clear();\n    mvaddstr(0, 0, \"Any key to start testing...\");\n\n    while (TRUE) {\n        ch = getch();\n        switch (ch) {\n        case KEY_LEFT:\n            chewing_handle_Left(ctx);\n            fprintf(fout, \"<L>\");\n            break;\n        case KEY_SLEFT:\n            chewing_handle_ShiftLeft(ctx);\n            fprintf(fout, \"<SL>\");\n            break;\n        case KEY_RIGHT:\n            chewing_handle_Right(ctx);\n            fprintf(fout, \"<R>\");\n            break;\n        case KEY_SRIGHT:\n            chewing_handle_ShiftRight(ctx);\n            fprintf(fout, \"<SR>\");\n            break;\n        case KEY_UP:\n            chewing_handle_Up(ctx);\n            fprintf(fout, \"<U>\");\n            break;\n        case KEY_DOWN:\n            chewing_handle_Down(ctx);\n            fprintf(fout, \"<D>\");\n            break;\n        case KEY_SPACE:\n            chewing_handle_Space(ctx);\n            fprintf(fout, \" \");\n            break;\n        case KEY_ENTER:\n            chewing_handle_Enter(ctx);\n            fprintf(fout, \"<E>\");\n            break;\n        case KEY_BACKSPACE:\n            chewing_handle_Backspace(ctx);\n            fprintf(fout, \"<B>\");\n            break;\n        case KEY_ESC:\n            chewing_handle_Esc(ctx);\n            fprintf(fout, \"<EE>\");\n            break;\n        case KEY_DC:\n            chewing_handle_Del(ctx);\n            fprintf(fout, \"<DC>\");\n            break;\n        case KEY_HOME:\n            chewing_handle_Home(ctx);\n            fprintf(fout, \"<H>\");\n            break;\n        case KEY_END:\n            chewing_handle_End(ctx);\n            fprintf(fout, \"<EN>\");\n            break;\n        case KEY_TAB:\n            chewing_handle_Tab(ctx);\n            fprintf(fout, \"<T>\");\n            break;\n        case CTRL_0:\n        case CTRL_1:\n        case CTRL_2:\n        case CTRL_3:\n        case CTRL_4:\n        case CTRL_5:\n        case CTRL_6:\n        case CTRL_7:\n        case CTRL_8:\n        case CTRL_9:\n            add_phrase_length = (ch - CTRL_0 + '0');\n            chewing_handle_CtrlNum(ctx, add_phrase_length);\n            fprintf(fout, \"<C%c>\", add_phrase_length);\n            break;\n        case KEY_CTRL_('B'):   /* emulate CapsLock */\n            chewing_handle_Capslock(ctx);\n            fprintf(fout, \"<CB>\");\n            break;\n        case KEY_CTRL_('D'):\n            goto end;\n        case KEY_CTRL_('H'):   /* emulate Shift */\n            if (chewing_get_ShapeMode(ctx) == FULLSHAPE_MODE)\n                chewing_set_ShapeMode(ctx, HALFSHAPE_MODE);\n            else\n                chewing_set_ShapeMode(ctx, FULLSHAPE_MODE);\n            break;\n        case KEY_NPAGE:\n            chewing_handle_PageDown(ctx);\n            fprintf(fout, \"<PD>\");\n            break;\n        case KEY_PPAGE:\n            chewing_handle_PageUp(ctx);\n            fprintf(fout, \"<PU>\");\n            break;\n        default:\n            chewing_handle_Default(ctx, (char) ch);\n            if (ch != '<' && ch != '>')\n                fprintf(fout, \"%c\", (char) ch);\n            else\n                fprintf(fout, \"<%c>\", (char) ch);\n            break;\n        }\n        drawline(0, 0);\n        drawline(2, 0);\n        show_interval_buffer(3, 0, ctx);\n        drawline(4, 0);\n        show_choose_buffer(5, 0, ctx);\n        drawline(6, 0);\n        show_bopomofo_buffer(7, 0, ctx);\n        show_full_shape(7, 5, ctx);\n        drawline(8, 0);\n        mvaddstr(9, 0, \"Ctrl + d : leave\");\n        mvaddstr(9, 20, \"Ctrl + b : toggle Eng/Chi mode\");\n        mvaddstr(10, 0, \"F1, F2, F3, ..., F9 : Add user defined phrase\");\n        mvaddstr(11, 0, \"Ctrl + h : toggle Full/Half shape mode\");\n        show_commit_string(12, 0, ctx);\n        show_userphrase(7, 12, ctx);\n        show_edit_buffer(1, 0, ctx);\n    }\n  end:\n    endwin();\n\n    /* Release Chewing context */\n    chewing_delete(ctx);\n\n    /* Termate Chewing services */\n\n    fprintf(fout, \"\\n\");\n    fclose(fout);\n    return 0;\n}",
        "begin_line": 269,
        "end_line": 463,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_ShiftLeft_not_entering_chewing#26",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_ShiftLeft_not_entering_chewing()",
        "snippet": "void test_ShiftLeft_not_entering_chewing()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    type_keystroke_by_string(ctx, \"<SL>\");\n    ok_keystroke_rtn(ctx, KEYSTROKE_IGNORE);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 26,
        "end_line": 36,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_ShiftLeft_add_userphrase#38",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_ShiftLeft_add_userphrase()",
        "snippet": "void test_ShiftLeft_add_userphrase()\n{\n    static const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ ;\n    static const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\" /* \u3118\u311c\u02cb \u3115\u02cb */ ;\n    int cursor;\n    ChewingContext *ctx;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n\n    ok(has_userphrase(ctx, bopomofo, phrase) == 0, \"`%s' shall not be in userphrase\", phrase);\n\n    type_keystroke_by_string(ctx, \"hk4g4<SL><SL><E>\");\n    ok_preedit_buffer(ctx, phrase);\n    cursor = chewing_cursor_Current(ctx);\n    ok(cursor == 0, \"cursor position `%d' shall be 0\", cursor);\n    ok(has_userphrase(ctx, bopomofo, phrase) == 1, \"`%s' shall be in userphrase\", phrase);\n\n    chewing_delete(ctx);\n}\n\nvoid test_",
        "begin_line": 38,
        "end_line": 60,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_ShiftLeft#62",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_ShiftLeft()",
        "snippet": "void test_ShiftLeft()\n{\n    test_ShiftLeft_not_entering_chewing();\n    test_ShiftLeft_add_userphrase();\n}",
        "begin_line": 62,
        "end_line": 66,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_ShiftRight_not_entering_chewing#68",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_ShiftRight_not_entering_chewing()",
        "snippet": "void test_ShiftRight_not_entering_chewing()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    type_keystroke_by_string(ctx, \"<SR>\");\n    ok_keystroke_rtn(ctx, KEYSTROKE_IGNORE);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 68,
        "end_line": 78,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_ShiftRight_add_userphrase#80",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_ShiftRight_add_userphrase()",
        "snippet": "void test_ShiftRight_add_userphrase()\n{\n    static const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ ;\n    static const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\" /* \u3118\u311c\u02cb \u3115\u02cb */ ;\n    int cursor;\n    ChewingContext *ctx;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n\n    ok(has_userphrase(ctx, bopomofo, phrase) == 0, \"`%s' shall not be in userphrase\", phrase);\n\n    type_keystroke_by_string(ctx, \"hk4g4<L><L><SR><SR><E>\");\n    ok_preedit_buffer(ctx, phrase);\n    cursor = chewing_cursor_Current(ctx);\n    ok(cursor == 2, \"cursor position `%d' shall be 2\", cursor);\n    ok(has_userphrase(ctx, bopomofo, phrase) == 1, \"`%s' shall be in userphrase\", phrase);\n\n    chewing_delete(ctx);\n}\n\nvoid test_",
        "begin_line": 80,
        "end_line": 102,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_ShiftRight#104",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_ShiftRight()",
        "snippet": "void test_ShiftRight()\n{\n    test_ShiftRight_not_entering_chewing();\n    test_ShiftRight_add_userphrase();\n}",
        "begin_line": 104,
        "end_line": 108,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_CtrlNum_add_phrase_right#110",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_CtrlNum_add_phrase_right()",
        "snippet": "void test_CtrlNum_add_phrase_right()\n{\n    static const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ ;\n    static const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\" /* \u3118\u311c\u02cb \u3115\u02cb */ ;\n    static const char msg[] = \"\\xE5\\x8A\\xA0\\xE5\\x85\\xA5\\xEF\\xBC\\x9A\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u52a0\u5165\uff1a\u6e2c\u8a66 */ ;\n    static const char msg_already_have[] =\n        \"\\xE5\\xB7\\xB2\\xE6\\x9C\\x89\\xEF\\xBC\\x9A\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u5df2\u6709\uff1a\u6e2c\u8a66 */ ;\n    int cursor;\n    ChewingContext *ctx;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n    chewing_set_addPhraseDirection(ctx, 0);\n\n    ok(has_userphrase(ctx, bopomofo, phrase) == 0, \"`%s' shall not be in userphrase\", phrase);\n\n    type_keystroke_by_string(ctx, \"hk4g4<H><C2>\");\n    ok_aux_buffer(ctx, msg);\n    ok_preedit_buffer(ctx, phrase);\n    cursor = chewing_cursor_Current(ctx);\n    ok(cursor == 0, \"cursor position `%d' shall be 0\", cursor);\n    ok(has_userphrase(ctx, bopomofo, phrase) == 1, \"`%s' shall be in userphrase\", phrase);\n\n    type_keystroke_by_string(ctx, \"<C2>\");\n    ok_aux_buffer(ctx, msg_already_have);\n\n    chewing_delete(ctx);\n}\n\nvoid test_CtrlNum_add_phrase_l",
        "begin_line": 110,
        "end_line": 140,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_CtrlNum_add_phrase_left#142",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_CtrlNum_add_phrase_left()",
        "snippet": "void test_CtrlNum_add_phrase_left()\n{\n    static const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ ;\n    static const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\" /* \u3118\u311c\u02cb \u3115\u02cb */ ;\n    static const char msg_add[] = \"\\xE5\\x8A\\xA0\\xE5\\x85\\xA5\\xEF\\xBC\\x9A\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u52a0\u5165\uff1a\u6e2c\u8a66 */ ;\n    static const char msg_already_have[] =\n        \"\\xE5\\xB7\\xB2\\xE6\\x9C\\x89\\xEF\\xBC\\x9A\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u5df2\u6709\uff1a\u6e2c\u8a66 */ ;\n    int cursor;\n    ChewingContext *ctx;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n    chewing_set_addPhraseDirection(ctx, 1);\n\n    ok(has_userphrase(ctx, bopomofo, phrase) == 0, \"`%s' shall not be in userphrase\", phrase);\n\n    type_keystroke_by_string(ctx, \"hk4g4<C2>\");\n    ok_aux_buffer(ctx, msg_add);\n    ok_preedit_buffer(ctx, phrase);\n    cursor = chewing_cursor_Current(ctx);\n    ok(cursor == 2, \"cursor position `%d' shall be 2\", cursor);\n    ok(has_userphrase(ctx, bopomofo, phrase) == 1, \"`%s' shall be in userphrase\", phrase);\n\n    type_keystroke_by_string(ctx, \"<C2>\");\n    ok_aux_buffer(ctx, msg_already_have);\n\n    chewing_delete(ctx);\n}\n\nvoid test_CtrlNum_add_phrase_r",
        "begin_line": 142,
        "end_line": 172,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_CtrlNum_add_phrase_right_symbol_in_between#174",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_CtrlNum_add_phrase_right_symbol_in_between()",
        "snippet": "void test_CtrlNum_add_phrase_right_symbol_in_between()\n{\n    static const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\" /* \u3118\u311c\u02cb \u3115\u02cb */ ;\n    int cursor;\n    ChewingContext *ctx;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n    chewing_set_addPhraseDirection(ctx, 0);\n\n    ok(has_userphrase(ctx, bopomofo, NULL) == 0, \"`%s' shall not be in userphrase\", bopomofo);\n\n    type_keystroke_by_string(ctx, \"hk4`1g4<H><C2>\");\n    cursor = chewing_cursor_Current(ctx);\n    ok(cursor == 0, \"cursor position `%d' shall be 0\", cursor);\n\n    ok(has_userphrase(ctx, bopomofo, NULL) == 0, \"`%s' shall not be in userphrase\", bopomofo);\n\n    chewing_delete(ctx);\n}\n\nvoid t",
        "begin_line": 174,
        "end_line": 196,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_CtrlNum_add_phrase_left_symbol_in_between#198",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_CtrlNum_add_phrase_left_symbol_in_between()",
        "snippet": "void test_CtrlNum_add_phrase_left_symbol_in_between()\n{\n    static const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\" /* \u3118\u311c\u02cb \u3115\u02cb */ ;\n    int cursor;\n    ChewingContext *ctx;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n    chewing_set_addPhraseDirection(ctx, 1);\n\n    ok(has_userphrase(ctx, bopomofo, NULL) == 0, \"`%s' shall not be in userphrase\", bopomofo);\n\n    type_keystroke_by_string(ctx, \"hk4`1g4<C2>\");\n    cursor = chewing_cursor_Current(ctx);\n    ok(cursor == 3, \"cursor position `%d' shall be 3\", cursor);\n\n    ok(has_userphrase(ctx, bopomofo, NULL) == 0, \"`%s' shall not be in userphrase\", bopomofo);\n\n    chewing_delete(ctx);\n}\n\nvoid t",
        "begin_line": 198,
        "end_line": 220,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_CtrlNum#222",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_CtrlNum()",
        "snippet": "void test_CtrlNum()\n{\n    test_CtrlNum_add_phrase_right();\n    test_CtrlNum_add_phrase_left();\n    test_CtrlNum_add_phrase_right_symbol_in_between();\n    test_CtrlNum_add_phrase_left_symbol_in_between();\n}",
        "begin_line": 222,
        "end_line": 228,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_auto_learn#230",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_auto_learn()",
        "snippet": "void test_userphrase_auto_learn()\n{\n    static const char bopomofo_1[] =\n        \"\\xE3\\x84\\x8E\\xE3\\x84\\x9C \\xE3\\x84\\x8E\\xE3\\x84\\x9C \\xE3\\x84\\x8E\\xE3\\x84\\x9C\" /* \u310e\u311c \u310e\u311c \u310e\u311c */ ;\n    static const char bopomofo_2[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\";   /* \u3118\u311c\u02cb \u3115\u02cb */\n    ChewingContext *ctx;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    ok(has_userphrase(ctx, bopomofo_1, NULL) == 0, \"`%s' shall not be in userphrase\", bopomofo_1);\n    ok(has_userphrase(ctx, bopomofo_2, NULL) == 0, \"`%s' shall not be in userphrase\", bopomofo_2);\n\n    chewing_set_autoLearn(ctx, AUTOLEARN_DISABLED);\n    ok(chewing_get_autoLearn(ctx) == AUTOLEARN_DISABLED, \"AutoLearn shall be `%d'\", AUTOLEARN_DISABLED);\n    type_keystroke_by_string(ctx, \"dk dk dk hk4g4<E>\");\n    ok(has_userphrase(ctx, bopomofo_1, NULL) == 0, \"`%s' shall not be in userphrase\", bopomofo_1);\n    ok(has_userphrase(ctx, bopomofo_2, NULL) == 0, \"`%s' shall not be in userphrase\", bopomofo_2);\n\n    chewing_set_autoLearn(ctx, AUTOLEARN_ENABLED);\n    ok(chewing_get_autoLearn(ctx) == AUTOLEARN_ENABLED, \"AutoLearn shall be `%d'\", AUTOLEARN_ENABLED);\n    type_keystroke_by_string(ctx, \"dk dk dk hk4g4<E>\");\n    ok(has_userphrase(ctx, bopomofo_1, NULL) == 1, \"`%s' shall be in userphrase\", bopomofo_1);\n    ok(has_userphrase(ctx, bopomofo_2, NULL) == 1, \"`%s' shall be in userphrase\", bopomofo_2);\n\n    chewing_delete(ctx);\n}\n\nvoid test_userphra",
        "begin_line": 230,
        "end_line": 258,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_auto_learn_with_symbol#260",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_auto_learn_with_symbol()",
        "snippet": "void test_userphrase_auto_learn_with_symbol()\n{\n    static const char bopomofo_1[] = \"\\xE3\\x84\\x8E\\xE3\\x84\\x9C\" /* \u310e\u311c */ ;\n    static const char bopomofo_2[] = \"\\xE3\\x84\\x8E\\xE3\\x84\\x9C \\xE3\\x84\\x8E\\xE3\\x84\\x9C\" /* \u310e\u311c \u310e\u311c */ ;\n    static const char bopomofo_3[] =\n        \"\\xE3\\x84\\x8E\\xE3\\x84\\x9C \\xE3\\x84\\x8E\\xE3\\x84\\x9C \\xE3\\x84\\x8E\\xE3\\x84\\x9C\" /* \u310e\u311c \u310e\u311c \u310e\u311c */ ;\n    ChewingContext *ctx;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    ok(has_userphrase(ctx, bopomofo_1, NULL) == 0, \"`%s' shall not be in userphrase\", bopomofo_1);\n\n    ok(has_userphrase(ctx, bopomofo_2, NULL) == 0, \"`%s' shall not be in userphrase\", bopomofo_2);\n\n    ok(has_userphrase(ctx, bopomofo_3, NULL) == 0, \"`%s' shall not be in userphrase\", bopomofo_3);\n\n    type_keystroke_by_string(ctx, \"`31dk `31dk dk `31<E>\");\n\n    ok(has_userphrase(ctx, bopomofo_1, NULL) == 1, \"`%s' shall be in userphrase\", bopomofo_1);\n\n    ok(has_userphrase(ctx, bopomofo_2, NULL) == 1, \"`%s' shall be in userphrase\", bopomofo_2);\n\n    ok(has_userphrase(ctx, bopomofo_3, NULL) == 0, \"`%s' shall not be in userphrase\", bopomofo_3);\n\n    chewing_delete(ctx);\n}\n\nvoid test_userphrase_a",
        "begin_line": 260,
        "end_line": 288,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_auto_learn_hardcode_break#290",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_auto_learn_hardcode_break()",
        "snippet": "void test_userphrase_auto_learn_hardcode_break()\n{\n    /* \u7684 is a hardcode break point, see ChewingIsBreakPoint */\n    static const char phrase[] = \"\\xE7\\x9A\\x84\\xE7\\x9A\\x84\" /* \u7684\u7684 */ ;\n    static const char bopomofo[] =\n        \"\\xE3\\x84\\x89\\xE3\\x84\\x9C\\xCB\\x99 \\xE3\\x84\\x89\\xE3\\x84\\x9C\\xCB\\x99\" /* \u3109\u311c\u02d9 \u3109\u311c\u02d9 */ ;\n    ChewingContext *ctx;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n    chewing_set_addPhraseDirection(ctx, 1);\n\n    ok(has_userphrase(ctx, bopomofo, phrase) == 0, \"`%s' shall not be in userphrase\", phrase);\n\n    type_keystroke_by_string(ctx, \"2k72k7<E>\");\n    ok(has_userphrase(ctx, bopomofo, phrase) == 0, \"`%s' shall not be in userphrase\", phrase);\n\n    chewing_delete(ctx);\n}\n\nvoid test_user",
        "begin_line": 290,
        "end_line": 311,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_auto_learn_only_after_commit#313",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_auto_learn_only_after_commit()",
        "snippet": "void test_userphrase_auto_learn_only_after_commit()\n{\n    /* GitHub #206: It should add the word after user actually finish the character selection. */\n\n    const char bopomofo_1[] = \"\\xE3\\x84\\x94\\xE3\\x84\\xA4\\xCB\\x8A \\xE3\\x84\\x86\\xE3\\x84\\xA2\\xCB\\x8A\"; /* \u3114\u3124\u02ca \u3106\u3122\u02ca */\n    const char bopomofo_2[] = \"\\xE3\\x84\\x94\\xE3\\x84\\xA4\\xCB\\x8A\"; /* \u3114\u3124\u02ca */\n\n    ChewingContext *ctx;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    /* user just inputs some characters: don't auto learn. */\n    type_keystroke_by_string(ctx, \"t;6q06\");\n    ok(has_userphrase(ctx, bopomofo_1, NULL) == 0, \"`%s' shall not be in userphrase\", bopomofo_1);\n    ok(has_userphrase(ctx, bopomofo_2, NULL) == 0, \"`%s' shall not be in userphrase\", bopomofo_2);\n\n    /* user selectes a candidate on the list, but doesn't commit: don't auto learn. */\n    type_keystroke_by_string(ctx, \"<L><L><D>7\");\n    ok(has_userphrase(ctx, bopomofo_1, NULL) == 0, \"`%s' shall not be in userphrase\", bopomofo_1);\n    ok(has_userphrase(ctx, bopomofo_2, NULL) == 0, \"`%s' shall not be in userphrase\", bopomofo_2);\n\n    /* user selectes another cadidate and commit: auto learn phrase(s), but not the selected candidate. */\n    type_keystroke_by_string(ctx, \"<L><D>2<E>\");\n    ok(has_userphrase(ctx, bopomofo_1, NULL) == 1, \"`%s' shall be in userphrase\", bopomofo_1);\n    ok(has_userphrase(ctx, bopomofo_2, NULL) == 0, \"`%s' shall not be in userphrase\", bopomofo_2);\n\n    chewing_delete(ctx);\n}\n\nvoid test_use",
        "begin_line": 313,
        "end_line": 343,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase#345",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase()",
        "snippet": "void test_userphrase()\n{\n    test_userphrase_auto_learn();\n    test_userphrase_auto_learn_with_symbol();\n    test_userphrase_auto_learn_hardcode_break();\n    test_userphrase_auto_learn_only_after_commit();\n}",
        "begin_line": 345,
        "end_line": 351,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_enumerate_normal#353",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_enumerate_normal()",
        "snippet": "void test_userphrase_enumerate_normal()\n{\n    ChewingContext *ctx;\n    int ret;\n    unsigned int expect_len;\n\n    const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ ;\n    char phrase_buf[50];\n    unsigned int phrase_len;\n\n    const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\";    /* \u3118\u311c\u02cb \u3115\u02cb */\n    char bopomofo_buf[50];\n    unsigned int bopomofo_len;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    ret = chewing_userphrase_add(ctx, phrase, bopomofo);\n    ok(ret == 1, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 1);\n    ret = chewing_userphrase_lookup(ctx, phrase, bopomofo);\n    ok(ret == 1, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 1);\n\n    ret = chewing_userphrase_enumerate(ctx);\n    ok(ret == 0, \"chewing_userphrase_enumerate() return value `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_userphrase_has_next(ctx, &phrase_len, &bopomofo_len);\n    ok(ret == 1, \"chewing_userphrase_has_next() return value `%d' shall be `%d'\", ret, 1);\n    expect_len = strlen(phrase) + 1;\n    ok(phrase_len >= expect_len, \"chewing_userphrase_has_next() shall set phrase_len `%d' >= `%d'\", phrase_len,\n       expect_len);\n    expect_len = strlen(bopomofo) + 1;\n    ok(bopomofo_len >= expect_len, \"chewing_userphrase_has_next() shall set bopomofo_len `%d' >= `%d'\", bopomofo_len,\n       expect_len);\n    ret = chewing_userphrase_get(ctx, phrase_buf, sizeof(phrase_buf), bopomofo_buf, sizeof(bopomofo_buf));\n    ok(ret == 0, \"chewing_userphrase_get() return value `%d' shall be `%d'\", ret, 0);\n    ok(strcmp(phrase_buf, phrase) == 0, \"chewing_userphrase_get() shall set phrase_buf `%s' to `%s'\", phrase_buf,\n       phrase);\n    ok(strcmp(bopomofo_buf, bopomofo) == 0, \"chewing_userphrase_get() shall set bopomofo_buf `%s' to `%s'\",\n       bopomofo_buf, bopomofo);\n\n    ret = chewing_userphrase_has_next(ctx, &phrase_len, &bopomofo_len);\n    ok(ret == 0, \"chewing_userphrase_has_next() return value `%d' shall be `%d'\", ret, 0);\n\n    chewing_delete(ctx);\n}\n\nvoid test_",
        "begin_line": 353,
        "end_line": 399,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_enumerate_empty#401",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_enumerate_empty()",
        "snippet": "void test_userphrase_enumerate_empty()\n{\n    ChewingContext *ctx;\n    int ret;\n    const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ ;\n    unsigned int phrase_len;\n    const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\";    /* \u3118\u311c\u02cb \u3115\u02cb */\n    unsigned int bopomofo_len;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    ret = chewing_userphrase_lookup(ctx, phrase, bopomofo);\n    ok(ret == 0, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_userphrase_enumerate(ctx);\n    ok(ret == 0, \"chewing_userphrase_enumerate() return value `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_userphrase_has_next(ctx, &phrase_len, &bopomofo_len);\n    ok(ret == 0, \"chewing_userphrase_has_next() return value `%d' shall be `%d'\", ret, 0);\n\n    chewing_delete(ctx);\n}\n\nvoid test_",
        "begin_line": 401,
        "end_line": 425,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_enumerate_rewind#427",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_enumerate_rewind()",
        "snippet": "void test_userphrase_enumerate_rewind()\n{\n    ChewingContext *ctx;\n    int ret;\n    unsigned int expect_len;\n\n    const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ ;\n    char phrase_buf[50];\n    unsigned int phrase_len;\n\n    const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\";    /* \u3118\u311c\u02cb \u3115\u02cb */\n    char bopomofo_buf[50];\n    unsigned int bopomofo_len;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    ret = chewing_userphrase_add(ctx, phrase, bopomofo);\n    ok(ret == 1, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 1);\n    ret = chewing_userphrase_lookup(ctx, phrase, bopomofo);\n    ok(ret == 1, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 1);\n\n    ret = chewing_userphrase_enumerate(ctx);\n    ok(ret == 0, \"chewing_userphrase_enumerate() return value `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_userphrase_has_next(ctx, &phrase_len, &bopomofo_len);\n    ok(ret == 1, \"chewing_userphrase_has_next() return value `%d' shall be `%d'\", ret, 1);\n    expect_len = strlen(phrase) + 1;\n    ok(phrase_len >= expect_len, \"chewing_userphrase_has_next() shall set phrase_len `%d' >= `%d'\", phrase_len,\n       expect_len);\n    expect_len = strlen(bopomofo) + 1;\n    ok(bopomofo_len >= expect_len, \"chewing_userphrase_has_next() shall set bopomofo_len `%d' >= `%d'\", bopomofo_len,\n       expect_len);\n    ret = chewing_userphrase_get(ctx, phrase_buf, sizeof(phrase_buf), bopomofo_buf, sizeof(bopomofo_buf));\n    ok(ret == 0, \"chewing_userphrase_get() return value `%d' shall be `%d'\", ret, 0);\n    ok(strcmp(phrase_buf, phrase) == 0, \"chewing_userphrase_get() shall set phrase_buf `%s' to `%s'\", phrase_buf,\n       phrase);\n    ok(strcmp(bopomofo_buf, bopomofo) == 0, \"chewing_userphrase_get() shall set bopomofo_buf `%s' to `%s'\",\n       bopomofo_buf, bopomofo);\n\n    ret = chewing_userphrase_enumerate(ctx);\n    ok(ret == 0, \"chewing_userphrase_enumerate() return value `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_userphrase_has_next(ctx, &phrase_len, &bopomofo_len);\n    ok(ret == 1, \"chewing_userphrase_has_next() return value `%d' shall be `%d'\", ret, 1);\n    expect_len = strlen(phrase) + 1;\n    ok(phrase_len >= expect_len, \"chewing_userphrase_has_next() shall set phrase_len `%d' >= `%d'\", phrase_len,\n       expect_len);\n    expect_len = strlen(bopomofo) + 1;\n    ok(bopomofo_len >= expect_len, \"chewing_userphrase_has_next() shall set bopomofo_len `%d' >= `%d'\", bopomofo_len,\n       expect_len);\n    ret = chewing_userphrase_get(ctx, phrase_buf, sizeof(phrase_buf), bopomofo_buf, sizeof(bopomofo_buf));\n    ok(ret == 0, \"chewing_userphrase_get() return value `%d' shall be `%d'\", ret, 0);\n    ok(strcmp(phrase_buf, phrase) == 0, \"chewing_userphrase_get() shall set phrase_buf `%s' to `%s'\", phrase_buf,\n       phrase);\n    ok(strcmp(bopomofo_buf, bopomofo) == 0, \"chewing_userphrase_get() shall set bopomofo_buf `%s' to `%s'\",\n       bopomofo_buf, bopomofo);\n\n    chewing_delete(ctx);\n}\n\nvoid test_",
        "begin_line": 427,
        "end_line": 488,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_enumerate#490",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_enumerate()",
        "snippet": "void test_userphrase_enumerate()\n{\n    test_userphrase_enumerate_normal();\n    test_userphrase_enumerate_empty();\n    test_userphrase_enumerate_rewind();\n}",
        "begin_line": 490,
        "end_line": 495,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_manipulate_normal#497",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_manipulate_normal()",
        "snippet": "void test_userphrase_manipulate_normal()\n{\n    ChewingContext *ctx;\n    const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ ;\n    const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\";    /* \u3118\u311c\u02cb \u3115\u02cb */\n    int ret;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    ret = chewing_userphrase_lookup(ctx, phrase, bopomofo);\n    ok(ret == 0, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_userphrase_add(ctx, phrase, bopomofo);\n    ok(ret == 1, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 1);\n    ret = chewing_userphrase_lookup(ctx, phrase, bopomofo);\n    ok(ret == 1, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 1);\n\n    ret = chewing_userphrase_remove(ctx, phrase, bopomofo);\n    ok(ret == 1, \"chewing_userphrase_remove() return value `%d' shall be `%d'\", ret, 1);\n    ret = chewing_userphrase_lookup(ctx, phrase, bopomofo);\n    ok(ret == 0, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 0);\n\n    chewing_delete(ctx);\n\n    /* New chewing instance shall not have remove userphrase. */\n    ctx = chewing_new();\n\n    ret = chewing_userphrase_lookup(ctx, phrase, bopomofo);\n    ok(ret == 0, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 0);\n\n    chewing_delete(ctx);\n}\n\nvoid test_",
        "begin_line": 497,
        "end_line": 530,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_manipulate_maximum#532",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_manipulate_maximum()",
        "snippet": "void test_userphrase_manipulate_maximum()\n{\n    ChewingContext *ctx;\n    const char phrase_in_limit[] =\n        \"\\xE9\\x87\\x91\\xE7\\xAA\\xA9\\xE9\\x8A\\x80\\xE7\\xAA\\xA9\\xE4\\xB8\\x8D\\xE5\\xA6\\x82\\xE8\\x87\\xAA\\xE5\\xB7\\xB1\\xE7\\x9A\\x84\\xE7\\x8B\\x97\\xE7\\xAA\\xA9\";\n    /* \u91d1\u7aa9\u9280\u7aa9\u4e0d\u5982\u81ea\u5df1\u7684\u72d7\u7aa9 */\n    const char bopomofo_in_limit[] =\n        \"\\xE3\\x84\\x90\\xE3\\x84\\xA7\\xE3\\x84\\xA3\\x20\\xE3\\x84\\xA8\\xE3\\x84\\x9B\\x20\\xE3\\x84\\xA7\\xE3\\x84\\xA3\\xCB\\x8A\\x20\\xE3\\x84\\xA8\\xE3\\x84\\x9B\\x20\\xE3\\x84\\x85\\xE3\\x84\\xA8\\xCB\\x8B\\x20\\xE3\\x84\\x96\\xE3\\x84\\xA8\\xCB\\x8A\\x20\\xE3\\x84\\x97\\xCB\\x8B\\x20\\xE3\\x84\\x90\\xE3\\x84\\xA7\\xCB\\x87\\x20\\xE3\\x84\\x89\\xE3\\x84\\x9C\\xCB\\x99\\x20\\xE3\\x84\\x8D\\xE3\\x84\\xA1\\xCB\\x87\\x20\\xE3\\x84\\xA8\\xE3\\x84\\x9B\";\n    /* \u3110\u3127\u3123 \u3128\u311b \u3127\u3123\u02ca \u3128\u311b \u3105\u3128\u02cb \u3116\u3128\u02ca \u3117\u02cb \u3110\u3127\u02c7 \u3109\u311c\u02d9 \u310d\u3121\u02c7 \u3128\u311b */\n    const char phrase_out_of_limit[] =\n        \"\\xE9\\x87\\x91\\xE7\\xAA\\xA9\\xE9\\x8A\\x80\\xE7\\xAA\\xA9\\xE4\\xB8\\x8D\\xE5\\xA6\\x82\\xE8\\x87\\xAA\\xE5\\xB7\\xB1\\xE7\\x9A\\x84\\xE7\\x8B\\x97\\xE7\\xAA\\xA9\\xE5\\x97\\x8E\";\n    /* \u91d1\u7aa9\u9280\u7aa9\u4e0d\u5982\u81ea\u5df1\u7684\u72d7\u7aa9\u55ce */\n    const char bopomofo_out_of_limit[] =\n        \"\\xE3\\x84\\x90\\xE3\\x84\\xA7\\xE3\\x84\\xA3\\x20\\xE3\\x84\\xA8\\xE3\\x84\\x9B\\x20\\xE3\\x84\\xA7\\xE3\\x84\\xA3\\xCB\\x8A\\x20\\xE3\\x84\\xA8\\xE3\\x84\\x9B\\x20\\xE3\\x84\\x85\\xE3\\x84\\xA8\\xCB\\x8B\\x20\\xE3\\x84\\x96\\xE3\\x84\\xA8\\xCB\\x8A\\x20\\xE3\\x84\\x97\\xCB\\x8B\\x20\\xE3\\x84\\x90\\xE3\\x84\\xA7\\xCB\\x87\\x20\\xE3\\x84\\x89\\xE3\\x84\\x9C\\xCB\\x99\\x20\\xE3\\x84\\x8D\\xE3\\x84\\xA1\\xCB\\x87\\x20\\xE3\\x84\\xA8\\xE3\\x84\\x9B \\xE3\\x84\\x87\\xE3\\x84\\x9A\\xCB\\x99\";\n    /* \u3110\u3127\u3123 \u3128\u311b \u3127\u3123\u02ca \u3128\u311b \u3105\u3128\u02cb \u3116\u3128\u02ca \u3117\u02cb \u3110\u3127\u02c7 \u3109\u311c\u02d9 \u310d\u3121\u02c7 \u3128\u311b \u3107\u311a\u02d9 */\n    int ret;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    ret = chewing_userphrase_add(ctx, phrase_in_limit, bopomofo_in_limit);\n    ok(ret == 1, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 1);\n    ret = chewing_userphrase_lookup(ctx, phrase_in_limit, bopomofo_in_limit);\n    ok(ret == 1, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 1);\n\n    ret = chewing_userphrase_add(ctx, phrase_out_of_limit, bopomofo_out_of_limit);\n    ok(ret == 0, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 0);\n    ret = chewing_userphrase_lookup(ctx, phrase_out_of_limit, bopomofo_out_of_limit);\n    ok(ret == 0, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 0);\n\n    chewing_delete(ctx);\n}\n\nvoid test_userphrase_manipulate_hash_collision()\n{\n    ChewingContext *ctx;\n\n    /* \u6e2c\u8a66 */\n    const char phrase_1[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\";\n\n    ",
        "begin_line": 532,
        "end_line": 565,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_manipulate_hash_collision#567",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_manipulate_hash_collision()",
        "snippet": "void test_userphrase_manipulate_hash_collision()\n{\n    ChewingContext *ctx;\n\n    /* \u6e2c\u8a66 */\n    const char phrase_1[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\";\n\n    /* \u3118\u311c\u02cb \u3115\u02cb */\n    const char bopomofo_1[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\";\n\n    /* \u6e2c\u8a66\u6e2c\u8a66\u6e2c\u8a66 */\n    const char phrase_2[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\";\n\n    /* \u3118\u311c\u02cb \u3115\u02cb \u3118\u311c\u02cb \u3115\u02cb \u3118\u311c\u02cb \u3115\u02cb */\n    const char bopomofo_2[] =\n        \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B \"\n        \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B \"\n        \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\";\n\n    int ret;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    ret = chewing_userphrase_add(ctx, phrase_1, bopomofo_1);\n    ok(ret == 1, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 1);\n    ret = chewing_userphrase_add(ctx, phrase_2, bopomofo_2);\n    ok(ret == 1, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 1);\n\n    ret = chewing_userphrase_lookup(ctx, phrase_1, bopomofo_1);\n    ok(ret == 1, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 1);\n    ret = chewing_userphrase_lookup(ctx, phrase_2, bopomofo_2);\n    ok(ret == 1, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 1);\n\n    ret = chewing_userphrase_remove(ctx, phrase_1, bopomofo_1);\n    ok(ret == 1, \"chewing_userphrase_remove() return value `%d' shall be `%d'\", ret, 1);\n    ret = chewing_userphrase_remove(ctx, phrase_2, bopomofo_2);\n    ok(ret == 1, \"chewing_userphrase_remove() return value `%d' shall be `%d'\", ret, 1);\n\n    ret = chewing_userphrase_lookup(ctx, phrase_1, bopomofo_1);\n    ok(ret == 0, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 0);\n    ret = chewing_userphrase_lookup(ctx, phrase_2, bopomofo_2);\n    ok(ret == 0, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 0);\n\n    chewing_delete(ctx);\n}\n\nvoid test_userphrase_manipulate_error_handling",
        "begin_line": 567,
        "end_line": 614,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_manipulate_error_handling#616",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_manipulate_error_handling()",
        "snippet": "void test_userphrase_manipulate_error_handling()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    ret = chewing_userphrase_add(ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ ,\n                                 \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B\" /* \u3118\u311c\u02cb */ );\n    ok(ret == 0, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_userphrase_add(ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ ,\n                                 \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xCB\\x8B\\xE3\\x84\\x95\" /* \u3118\u311c\u02cb \u02cb\u3115 */ );\n    ok(ret == 0, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_userphrase_remove(ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ ,\n                                    \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xCB\\x8B\\xE3\\x84\\x95\" /* \u3118\u311c\u02cb \u02cb\u3115 */ );\n    ok(ret == 0, \"chewing_userphrase_remove() return value `%d' shall be `%d'\", ret, 0);\n\n    chewing_delete(ctx);\n}\n\nvoid test_userphrase_manipulate",
        "begin_line": 616,
        "end_line": 639,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_manipulate_remove_same_phone#641",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_manipulate_remove_same_phone()",
        "snippet": "void test_userphrase_manipulate_remove_same_phone()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    const char phrase_1[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ ;\n    const char phrase_2[] = \"\\xE5\\x81\\xB4\\xE5\\xAE\\xA4\" /* \u5074\u5ba4 */ ;\n    const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\" /* \u3118\u311c\u02cb \u3115\u02cb */ ;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    ret = chewing_userphrase_add(ctx, phrase_1, bopomofo);\n    ok(ret == 1, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 1);\n    ret = chewing_userphrase_add(ctx, phrase_2, bopomofo);\n    ok(ret == 1, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 1);\n\n    ret = chewing_userphrase_lookup(ctx, phrase_1, bopomofo);\n    ok(ret == 1, \"chewing_lookup() return value `%d' shall be `%d'\", ret, 1);\n    ret = chewing_userphrase_lookup(ctx, phrase_2, bopomofo);\n    ok(ret == 1, \"chewing_lookup() return value `%d' shall be `%d'\", ret, 1);\n\n    ret = chewing_userphrase_remove(ctx, phrase_1, bopomofo);\n    ok(ret == 1, \"chewing_userphrase_remove() return value `%d' shall be `%d'\", ret, 1);\n\n    ret = chewing_userphrase_lookup(ctx, phrase_1, bopomofo);\n    ok(ret == 0, \"chewing_lookup() return value `%d' shall be `%d'\", ret, 0);\n    ret = chewing_userphrase_lookup(ctx, phrase_2, bopomofo);\n    ok(ret == 1, \"chewing_lookup() return value `%d' shall be `%d'\", ret, 1);\n\n    chewing_delete(ctx);\n}\n\nvoid test_user",
        "begin_line": 641,
        "end_line": 674,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_manipulate_remove_same_phrase#676",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_manipulate_remove_same_phrase()",
        "snippet": "void test_userphrase_manipulate_remove_same_phrase()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    const char phrase[] = \"\\xE4\\xBB\\x80\\xE9\\xBA\\xBC\" /* \u4ec0\u9ebc */ ;\n    const char bopomofo_1[] =\n        \"\\xE3\\x84\\x95\\xE3\\x84\\xA3\\xCB\\x8A \\xE3\\x84\\x87\\xE3\\x84\\x9C\\xCB\\x99\" /* \u3115\u3123\u02ca \u3107\u311c\u02d9 */ ;\n    const char bopomofo_2[] =\n        \"\\xE3\\x84\\x95\\xE3\\x84\\x9C\\xCB\\x8A \\xE3\\x84\\x87\\xE3\\x84\\x9C\\xCB\\x99\" /* \u3115\u311c\u02ca \u3107\u311c\u02d9 */ ;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    ret = chewing_userphrase_add(ctx, phrase, bopomofo_1);\n    ok(ret == 1, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 1);\n    ret = chewing_userphrase_add(ctx, phrase, bopomofo_2);\n    ok(ret == 1, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 1);\n\n    ret = chewing_userphrase_lookup(ctx, phrase, bopomofo_1);\n    ok(ret == 1, \"chewing_lookup() return value `%d' shall be `%d'\", ret, 1);\n    ret = chewing_userphrase_lookup(ctx, phrase, bopomofo_2);\n    ok(ret == 1, \"chewing_lookup() return value `%d' shall be `%d'\", ret, 1);\n\n    ret = chewing_userphrase_remove(ctx, phrase, bopomofo_1);\n    ok(ret == 1, \"chewing_userphrase_remove() return value `%d' shall be `%d'\", ret, 1);\n\n    ret = chewing_userphrase_lookup(ctx, phrase, bopomofo_1);\n    ok(ret == 0, \"chewing_lookup() return value `%d' shall be `%d'\", ret, 0);\n    ret = chewing_userphrase_lookup(ctx, phrase, bopomofo_2);\n    ok(ret == 1, \"chewing_lookup() return value `%d' shall be `%d'\", ret, 1);\n\n    chewing_delete(ctx);\n}\n\nvoid test_userphrase_m",
        "begin_line": 676,
        "end_line": 711,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_manipulate_remove_non_userphrase#713",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_manipulate_remove_non_userphrase()",
        "snippet": "void test_userphrase_manipulate_remove_non_userphrase()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ ;\n    const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\" /* \u3118\u311c\u02cb \u3115\u02cb */ ;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    ret = chewing_userphrase_lookup(ctx, phrase, bopomofo);\n    ok(ret == 0, \"chewing_lookup() return value `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_userphrase_remove(ctx, phrase, bopomofo);\n    ok(ret == 0, \"chewing_userphrase_remove() return value `%d' shall be `%d'\", ret, 0);\n\n    chewing_delete(ctx);\n}\n\nvoid test_",
        "begin_line": 713,
        "end_line": 733,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_manipulate#735",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_manipulate()",
        "snippet": "void test_userphrase_manipulate()\n{\n    test_userphrase_manipulate_normal();\n    test_userphrase_manipulate_maximum();\n    test_userphrase_manipulate_hash_collision();\n    test_userphrase_manipulate_error_handling();\n    test_userphrase_manipulate_remove_same_phone();\n    test_userphrase_manipulate_remove_same_phrase();\n    test_userphrase_manipulate_remove_non_userphrase();\n}",
        "begin_line": 735,
        "end_line": 744,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_lookup#746",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_lookup()",
        "snippet": "void test_userphrase_lookup()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    ret = chewing_userphrase_lookup(ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ ,\n                                    \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B\" /* \u3118\u311c\u02cb */ );\n    ok(ret == 0, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_userphrase_lookup(ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ ,\n                                    \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xCB\\x8B\\xE3\\x84\\x95\" /* \u3118\u311c\u02cb \u02cb\u3115 */ );\n    ok(ret == 0, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 0);\n\n    chewing_delete(ctx);\n}\n\nvoid test_userphras",
        "begin_line": 746,
        "end_line": 765,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_double_free#767",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_double_free()",
        "snippet": "void test_userphrase_double_free()\n{\n    ChewingContext *ctx = NULL;\n    char p1[] = \"\\xE6\\xB8\\xAC\";\n    char p2[] = \"\\xE7\\xAD\\x96\";\n    char b1[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B\";\n    int ret = 0;\n\n    clean_userphrase();\n\n    start_testcase(ctx, fd);\n\n    ctx = chewing_new();\n    ret = chewing_userphrase_add(ctx, p1, b1);\n    ok(ret == 1, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 1);\n    ret = chewing_userphrase_add(ctx, p2, b1);\n    ok(ret == 1, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 1);\n    ret = chewing_userphrase_remove(ctx, p1, b1);\n    ok(ret == 1, \"chewing_userphrase_remove() return value `%d' shall be `%d'\", ret, 1);\n    chewing_delete(ctx);\n    ctx = NULL;\n\n    ctx = chewing_new();\n    ret = chewing_userphrase_add(ctx, p1, b1);\n    ok(ret == 1, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 1);\n    ret = chewing_userphrase_add(ctx, p2, b1);\n    ok(ret == 1, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 1);\n    chewing_userphrase_remove(ctx, p1, b1);\n    ok(ret == 1, \"chewing_userphrase_remove() return value `%d' shall be `%d'\", ret, 1);\n    chewing_delete(ctx);\n    ctx = NULL;\n}",
        "begin_line": 767,
        "end_line": 798,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_remove#800",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_remove()",
        "snippet": "void test_userphrase_remove()\n{\n    ChewingContext *ctx = NULL;\n    char p1[] = \"\\xE6\\xB8\\xAC\";\n    char p2[] = \"\\xE7\\xAD\\x96\";\n    char b1[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B\";\n    int ret = 0;\n\n    clean_userphrase();\n\n    start_testcase(ctx, fd);\n\n    ctx = chewing_new();\n    ret = chewing_userphrase_add(ctx, p1, b1);\n    ok(ret == 1, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 1);\n    ret = chewing_userphrase_add(ctx, p2, b1);\n    ok(ret == 1, \"chewing_userphrase_add() return value `%d' shall be `%d'\", ret, 1);\n    ret = chewing_userphrase_remove(ctx, p1, b1);\n    ok(ret == 1, \"chewing_userphrase_remove() return value `%d' shall be `%d'\", ret, 1);\n    chewing_delete(ctx);\n    ctx = NULL;\n\n    ctx = chewing_new();\n    ret = chewing_userphrase_remove(ctx, p2, b1);\n    ok(ret == 1, \"chewing_userphrase_remove() return value `%d' shall be `%d'\", ret, 1);\n    chewing_delete(ctx);\n    ctx = NULL;\n\n    ctx = chewing_new();\n    ret = chewing_userphrase_lookup(ctx, p2, b1);\n    ok(ret == 0, \"chewing_userphrase_lookup() return value `%d' shall be `%d'\", ret, 0);\n    chewing_delete(ctx);\n    ctx = NULL;\n}",
        "begin_line": 800,
        "end_line": 833,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.main#835",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    char *logname;\n    int ret;\n\n    putenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n    putenv(\"CHEWING_USER_PATH=\" TEST_HASH_DIR);\n\n    ret = asprintf(&logname, \"%s.log\", argv[0]);\n    if (ret == -1)\n        return -1;\n    fd = fopen(logname, \"w\");\n    assert(fd);\n    free(logname);\n\n    test_ShiftLeft();\n    test_ShiftRight();\n    test_CtrlNum();\n    test_userphrase();\n    test_userphrase_enumerate();\n    test_userphrase_manipulate();\n    test_userphrase_lookup();\n    test_userphrase_double_free();\n    test_userphrase_remove();\n\n    fclose(fd);\n\n    return exit_status();\n}",
        "begin_line": 835,
        "end_line": 863,
        "is_bug": false
    },
    {
        "name": "test.test-reset.test_reset_shall_not_clean_static_data#24",
        "src_path": "test/test-reset.c",
        "class_name": "test.test-reset",
        "signature": "test.test-reset.test_reset_shall_not_clean_static_data()",
        "snippet": "void test_reset_shall_not_clean_static_data()\n{\n    const TestData DATA = { \"hk4g4<E>\", \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */  };\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_KBType(ctx, chewing_KBStr2Num(\"KB_DEFAULT\"));\n\n    chewing_set_maxChiSymbolLen(ctx, 16);\n\n    chewing_Reset(ctx);\n\n    type_keystroke_by_string(ctx, DATA.token);\n    ok_commit_buffer(ctx, DATA.expected);\n\n    chewing_delete(ctx);\n}\n\nin",
        "begin_line": 24,
        "end_line": 42,
        "is_bug": false
    },
    {
        "name": "test.test-reset.main#44",
        "src_path": "test/test-reset.c",
        "class_name": "test.test-reset",
        "signature": "test.test-reset.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    char *logname;\n    int ret;\n\n    putenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n    putenv(\"CHEWING_USER_PATH=\" TEST_HASH_DIR);\n\n    ret = asprintf(&logname, \"%s.log\", argv[0]);\n    if (ret == -1)\n        return -1;\n    fd = fopen(logname, \"w\");\n    assert(fd);\n    free(logname);\n\n    test_reset_shall_not_clean_static_data();\n\n    fclose(fd);\n\n    return exit_status();\n}",
        "begin_line": 44,
        "end_line": 64,
        "is_bug": false
    },
    {
        "name": "test.test-error-handling.test_null#19",
        "src_path": "test/test-error-handling.c",
        "class_name": "test.test-error-handling",
        "signature": "test.test-error-handling.test_null()",
        "snippet": "void test_null()\n{\n    int ret;\n    char *buf;\n    const char *const_buf;\n    int *key;\n    unsigned short *phone;\n\n    start_testcase(NULL, fd);\n\n    chewing_Reset(NULL);        // shall not crash\n\n    ret = chewing_set_KBType(NULL, 0);\n    ok(ret == -1, \"chewing_set_KBType() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_get_KBType(NULL);\n    ok(ret == -1, \"chewing_get_KBType() returns `%d' shall be `%d'\", ret, -1);\n\n    buf = chewing_get_KBString(NULL);\n    ok(strcmp(buf, \"\") == 0, \"chewing_get_KBString() returns `%s' shall be `%s'\", buf, \"\");\n    chewing_free(buf);\n\n    chewing_delete(NULL);       // shall not crash\n\n    chewing_free(NULL);         // shall not crash\n\n    chewing_set_candPerPage(NULL, 0);   // shall not crash\n\n    ret = chewing_get_candPerPage(NULL);\n    ok(ret == -1, \"chewing_get_candPerPage() returns `%d' shall be `%d'\", ret, -1);\n\n    chewing_set_maxChiSymbolLen(NULL, 0);       // shall not crash\n\n    ret = chewing_get_maxChiSymbolLen(NULL);\n    ok(ret == -1, \"chewing_get_maxChiSymbolLen() returns `%d' shall be `%d'\", ret, -1);\n\n    chewing_set_selKey(NULL, NULL, 0);  // shall not crash\n\n    key = chewing_get_selKey(NULL);\n    ok(key == NULL, \"chewing_get_selKey() returns NULL\");\n    chewing_free(key);\n\n    chewing_set_addPhraseDirection(NULL, 0);    // shall not crash\n\n    ret = chewing_get_addPhraseDirection(NULL);\n    ok(ret == -1, \"chewing_get_addPhraseDirection() returns `%d' shall be `%d'\", ret, -1);\n\n    chewing_set_spaceAsSelection(NULL, 0);      // shall not crash\n\n    ret = chewing_get_spaceAsSelection(NULL);\n    ok(ret == -1, \"chewing_get_spaceAsSelection() returns `%d' shall be `%d'\", ret, -1);\n\n    chewing_set_escCleanAllBuf(NULL, 0);        // shall not crash\n\n    ret = chewing_get_escCleanAllBuf(NULL);\n    ok(ret == -1, \"chewing_get_escCleanAllBuf() returns `%d' shall be `%d'\", ret, -1);\n\n    chewing_set_autoShiftCur(NULL, 0);  // shall not crash\n\n    ret = chewing_get_autoShiftCur(NULL);\n    ok(ret == -1, \"chewing_get_autoShiftCur() returns `%d' shall be `%d'\", ret, -1);\n\n    chewing_set_easySymbolInput(NULL, 0);       // shall not crash\n\n    ret = chewing_get_easySymbolInput(NULL);\n    ok(ret == -1, \"chewing_get_easySymbolInput() returns `%d' shall be `%d'\", ret, -1);\n\n    chewing_set_phraseChoiceRearward(NULL, 0);\n\n    ret = chewing_get_phraseChoiceRearward(NULL);\n    ok(ret == -1, \"chewing_get_phraseChoiceRearward() returns `%d' shall be `%d'\", ret, -1);\n\n    chewing_set_ChiEngMode(NULL, 0);    // shall not crash\n\n    ret = chewing_get_ChiEngMode(NULL);\n    ok(ret == -1, \"chewing_get_ChiEngMode() returns `%d' shall be `%d'\", ret, -1);\n\n    chewing_set_ShapeMode(NULL, 0);     // shall not crash\n\n    ret = chewing_handle_Space(NULL);\n    ok(ret == -1, \"chewing_handle_Space() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_handle_Esc(NULL);\n    ok(ret == -1, \"chewing_handle_Esc() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_handle_Enter(NULL);\n    ok(ret == -1, \"chewing_handle_Enter() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_handle_Del(NULL);\n    ok(ret == -1, \"chewing_handle_Del() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_handle_Backspace(NULL);\n    ok(ret == -1, \"chewing_handle_Backspace() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_handle_Up(NULL);\n    ok(ret == -1, \"chewing_handle_Up() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_handle_Down(NULL);\n    ok(ret == -1, \"chewing_handle_Down() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_handle_ShiftLeft(NULL);\n    ok(ret == -1, \"chewing_handle_ShiftLeft() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_handle_Left(NULL);\n    ok(ret == -1, \"chewing_handle_Left() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_handle_ShiftRight(NULL);\n    ok(ret == -1, \"chewing_handle_ShiftRight() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_handle_Right(NULL);\n    ok(ret == -1, \"chewing_handle_Right() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_handle_Tab(NULL);\n    ok(ret == -1, \"chewing_handle_Tab() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_handle_DblTab(NULL);\n    ok(ret == -1, \"chewing_handle_DblTab() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_handle_Capslock(NULL);\n    ok(ret == -1, \"chewing_handle_Capslock() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_handle_Home(NULL);\n    ok(ret == -1, \"chewing_handle_Home() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_handle_PageUp(NULL);\n    ok(ret == -1, \"chewing_handle_PageUp() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_handle_PageDown(NULL);\n    ok(ret == -1, \"chewing_handle_PageDown() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_handle_Default(NULL, 0);\n    ok(ret == -1, \"chewing_handle_Default() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_handle_CtrlNum(NULL, 0);\n    ok(ret == -1, \"chewing_handle_CtrlNum() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_handle_ShiftSpace(NULL);\n    ok(ret == -1, \"chewing_handle_ShiftSpace() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_handle_Numlock(NULL, 0);\n    ok(ret == -1, \"chewing_handle_Numlock() returns `%d' shall be `%d'\", ret, -1);\n\n    phone = chewing_get_phoneSeq(NULL);\n    ok(phone == NULL, \"chewing_get_phoneSeq() returns NULL\");\n    chewing_free(phone);\n\n    ret = chewing_get_phoneSeqLen(NULL);\n    ok(ret == -1, \"chewing_get_phoneSeqLen() returns `%d' shall be `%d'\", ret, -1);\n\n    chewing_set_logger(NULL, NULL, NULL);\n\n    ret = chewing_userphrase_enumerate(NULL);\n    ok(ret == -1, \"chewing_userphrase_enumerate() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_userphrase_has_next(NULL, NULL, NULL);\n    ok(ret == 0, \"chewing_userphrase_has_next() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_userphrase_get(NULL, NULL, 0, NULL, 0);\n    ok(ret == -1, \"chewing_userphrase_get() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_userphrase_add(NULL, NULL, NULL);\n    ok(ret == -1, \"chewing_userphrase_add() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_userphrase_remove(NULL, NULL, NULL);\n    ok(ret == -1, \"chewing_userphrase_remove() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_userphrase_lookup(NULL, NULL, NULL);\n    ok(ret == 0, \"chewing_userphrase_lookup() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_open(NULL);\n    ok(ret == -1, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_cand_close(NULL);\n    ok(ret == -1, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_cand_choose_by_index(NULL, 0);\n    ok(ret == -1, \"chewing_cand_choose_by_index() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_cand_list_first(NULL);\n    ok(ret == -1, \"chewing_cand_list_first() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_cand_list_last(NULL);\n    ok(ret == -1, \"chewing_cand_list_last() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_cand_list_has_next(NULL);\n    ok(ret == 0, \"chewing_cand_list_has_next() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_list_has_prev(NULL);\n    ok(ret == 0, \"chewing_cand_list_has_prev() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_list_next(NULL);\n    ok(ret == -1, \"chewing_cand_list_next() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_cand_list_prev(NULL);\n    ok(ret == -1, \"chewing_cand_list_prev() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_commit_preedit_buf(NULL);\n    ok(ret == -1, \"chewing_commit_preedit_buf() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_clean_preedit_buf(NULL);\n    ok(ret == -1, \"chewing_clean_preedit_buf() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_clean_bopomofo_buf(NULL);\n    ok(ret == -1, \"chewing_clean_bopomofo_buf() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_commit_Check(NULL);\n    ok(ret == -1, \"chewing_commit_Check() returns `%d' shall be `%d'\", ret, -1);\n\n    buf = chewing_commit_String(NULL);\n    ok(strcmp(buf, \"\") == 0, \"chewing_commit_String() returns `%s' shall be `%s'\", buf, \"\");\n    chewing_free(buf);\n\n    const_buf = chewing_commit_String_static(NULL);\n    ok(strcmp(const_buf, \"\") == 0, \"chewing_commit_String() returns `%s' shall be `%s'\", const_buf, \"\");\n\n    ret = chewing_buffer_Check(NULL);\n    ok(ret == -1, \"chewing_buffer_Check() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_buffer_Len(NULL);\n    ok(ret == -1, \"chewing_buffer_Len() returns `%d' shall be `%d'\", ret, -1);\n\n    buf = chewing_buffer_String(NULL);\n    ok(strcmp(buf, \"\") == 0, \"chewing_buffer_String() returns `%s' shall be `%s'\", buf, \"\");\n    chewing_free(buf);\n\n    const_buf = chewing_buffer_String_static(NULL);\n    ok(strcmp(const_buf, \"\") == 0, \"chewing_buffer_String_static() returns `%s' shall be `%s'\", const_buf, \"\");\n\n    const_buf = chewing_bopomofo_String_static(NULL);\n    ok(strcmp(const_buf, \"\") == 0, \"chewing_bopomofo_String_static() returns `%s' shall be `%s'\", const_buf, \"\");\n\nBEGIN_IGNORE_DEPRECATIONS\n    buf = chewing_zuin_String(NULL, NULL);\nEND_IGNORE_DEPRECATIONS\n    ok(strcmp(buf, \"\") == 0, \"chewing_zuin_String() returns `%s' shall be `%s'\", buf, \"\");\n    chewing_free(buf);\n\n    ret = chewing_bopomofo_Check(NULL);\n    ok(ret == -1, \"chewing_bopomofo_Check() returns `%d' shall be `%d'\", ret, -1);\n\nBEGIN_IGNORE_DEPRECATIONS\n    chewing_zuin_Check(NULL); // shall not crash\nEND_IGNORE_DEPRECATIONS\n\n    ret = chewing_cursor_Current(NULL);\n    ok(ret == -1, \"chewing_cursor_Current() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_cand_CheckDone(NULL);\n    ok(ret == -1, \"chewing_cand_CheckDone() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_cand_TotalPage(NULL);\n    ok(ret == -1, \"chewing_cand_TotalPage() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_cand_ChoicePerPage(NULL);\n    ok(ret == -1, \"chewing_cand_ChoicePerPage() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_cand_TotalChoice(NULL);\n    ok(ret == -1, \"chewing_cand_TotalChoice() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_cand_CurrentPage(NULL);\n    ok(ret == -1, \"chewing_cand_CurrentPage() returns `%d' shall be `%d'\", ret, -1);\n\n    chewing_cand_Enumerate(NULL);       // shall not crash\n\n    ret = chewing_cand_hasNext(NULL);\n    ok(ret == -1, \"chewing_cand_hasNext() returns `%d' shall be `%d'\", ret, -1);\n\n    const_buf = chewing_cand_String_static(NULL);\n    ok(strcmp(const_buf, \"\") == 0, \"chewing_cand_String_static() returns `%s' shall be `%s'\", const_buf, \"\");\n\n    buf = chewing_cand_String(NULL);\n    ok(strcmp(buf, \"\") == 0, \"chewing_cand_String() returns `%s' shall be `%s'\", buf, \"\");\n    chewing_free(buf);\n\n    chewing_interval_Enumerate(NULL);   // shall not crash\n\n    ret = chewing_interval_hasNext(NULL);\n    ok(ret == -1, \"chewing_interval_hasNext() returns `%d' shall be `%d'\", ret, -1);\n\n    chewing_interval_Get(NULL, NULL);   // shall not crash\n\n    ret = chewing_aux_Check(NULL);\n    ok(ret == -1, \"chewing_aux_Check() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_aux_Length(NULL);\n    ok(ret == -1, \"chewing_aux_Length() returns `%d' shall be `%d'\", ret, -1);\n\n    const_buf = chewing_aux_String_static(NULL);\n    ok(strcmp(const_buf, \"\") == 0, \"chewing_aux_String_static() returns `%s' shall be `%s'\", const_buf, \"\");\n\n    buf = chewing_aux_String(NULL);\n    ok(strcmp(buf, \"\") == 0, \"chewing_aux_String() returns `%s' shall be `%s'\", buf, \"\");\n    chewing_free(buf);\n\n    ret = chewing_keystroke_CheckIgnore(NULL);\n    ok(ret == -1, \"chewing_keystroke_CheckIgnore() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_keystroke_CheckAbsorb(NULL);\n    ok(ret == -1, \"chewing_keystroke_CheckAbsorb() returns `%d' shall be `%d'\", ret, -1);\n\n    chewing_kbtype_Enumerate(NULL);     // shall not crash\n\n    ret = chewing_kbtype_hasNext(NULL);\n    ok(ret == -1, \"chewing_kbtype_hasNext() returns `%d' shall be `%d'\", ret, -1);\n\n    const_buf = chewing_kbtype_String_static(NULL);\n    ok(strcmp(const_buf, \"\") == 0, \"chewing_kbtype_String_static() returns `%s' shall be `%s'\", const_buf, \"\");\n\n    buf = chewing_kbtype_String(NULL);\n    ok(strcmp(buf, \"\") == 0, \"chewing_kbtype_String() returns `%s' shall be `%s'\", buf, \"\");\n    chewing_free(buf);\n}",
        "begin_line": 19,
        "end_line": 330,
        "is_bug": false
    },
    {
        "name": "test.test-error-handling.main#332",
        "src_path": "test/test-error-handling.c",
        "class_name": "test.test-error-handling",
        "signature": "test.test-error-handling.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    char *logname;\n    int ret;\n\n    putenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n    putenv(\"CHEWING_USER_PATH=\" TEST_HASH_DIR);\n\n    ret = asprintf(&logname, \"%s.log\", argv[0]);\n    if (ret == -1)\n        return -1;\n    fd = fopen(logname, \"w\");\n    assert(fd);\n    free(logname);\n\n\n    test_null();\n\n    fclose(fd);\n\n    return exit_status();\n}",
        "begin_line": 332,
        "end_line": 353,
        "is_bug": false
    },
    {
        "name": "test.test-path.test_plat_get_search_path#39",
        "src_path": "test/test-path.c",
        "class_name": "test.test-path",
        "signature": "test.test-path.test_plat_get_search_path()",
        "snippet": "void test_plat_get_search_path()\n{\n    int ret;\n    char output[PATH_MAX];\n\n    start_testcase(NULL, fd);\n\n    putenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n    ret = get_search_path(output, sizeof(output));\n    ok(ret == 0, \"get_search_path return 0\");\n    ok(!strcmp(output, CHEWING_DATA_PREFIX), \"get_search_path succes\");\n    // TODO plat specific test\n}",
        "begin_line": 39,
        "end_line": 51,
        "is_bug": false
    },
    {
        "name": "test.test-path.test_plat_path_found#53",
        "src_path": "test/test-path.c",
        "class_name": "test.test-path",
        "signature": "test.test-path.test_plat_path_found()",
        "snippet": "void test_plat_path_found()\n{\n    int ret;\n    char output[PATH_MAX];\n\n    start_testcase(NULL, fd);\n\n    ret = find_path_by_files(CHEWING_DATA_PREFIX \"_no_such_path\" SEARCH_PATH_SEP\n                             CHEWING_DATA_PREFIX, FILES, output, sizeof(output));\n\n    ok(ret == 0, \"find_path_by_files shall return 0\");\n    ok(strcmp(output, CHEWING_DATA_PREFIX) == 0, \"output shall be \" CHEWING_DATA_PREFIX);\n}",
        "begin_line": 53,
        "end_line": 65,
        "is_bug": false
    },
    {
        "name": "test.test-path.test_plat_path_cannot_find#67",
        "src_path": "test/test-path.c",
        "class_name": "test.test-path",
        "signature": "test.test-path.test_plat_path_cannot_find()",
        "snippet": "void test_plat_path_cannot_find()\n{\n    int ret;\n    char output[PATH_MAX];\n\n    start_testcase(NULL, fd);\n\n    ret = find_path_by_files(CHEWING_DATA_PREFIX \"_no_such_path_1\" SEARCH_PATH_SEP\n                             CHEWING_DATA_PREFIX \"_no_such_path_2\", FILES, output, sizeof(output));\n\n    ok(ret != 0, \"find_path_by_files shall not return 0\");\n}",
        "begin_line": 67,
        "end_line": 78,
        "is_bug": false
    },
    {
        "name": "test.test-path.main#80",
        "src_path": "test/test-path.c",
        "class_name": "test.test-path",
        "signature": "test.test-path.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    char *logname;\n    int ret;\n\n    putenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n    putenv(\"CHEWING_USER_PATH=\" TEST_HASH_DIR);\n\n    ret = asprintf(&logname, \"%s.log\", argv[0]);\n    if (ret == -1)\n        return -1;\n    fd = fopen(logname, \"w\");\n    assert(fd);\n    free(logname);\n\n\n    test_plat_get_search_path();\n    test_plat_path_found();\n    test_plat_path_cannot_find();\n\n    fclose(fd);\n\n    return exit_status();\n}",
        "begin_line": 80,
        "end_line": 103,
        "is_bug": false
    },
    {
        "name": "test.test-logger.test_set_null_logger#25",
        "src_path": "test/test-logger.c",
        "class_name": "test.test-logger",
        "signature": "test.test-logger.test_set_null_logger()",
        "snippet": "void test_set_null_logger()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_logger(ctx, NULL, 0);\n    type_keystroke_by_string(ctx, \"hk4g4\");\n\n    chewing_delete(ctx);\n}",
        "begin_line": 25,
        "end_line": 36,
        "is_bug": false
    },
    {
        "name": "test.test-logger.main#38",
        "src_path": "test/test-logger.c",
        "class_name": "test.test-logger",
        "signature": "test.test-logger.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    char *logname;\n    int ret;\n\n    putenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n    putenv(\"CHEWING_USER_PATH=\" TEST_HASH_DIR);\n\n    ret = asprintf(&logname, \"%s.log\", argv[0]);\n    if (ret == -1)\n        return -1;\n    fd = fopen(logname, \"w\");\n    assert(fd);\n    free(logname);\n\n\n    test_set_null_logger();\n\n    fclose(fd);\n\n    return exit_status();\n}",
        "begin_line": 38,
        "end_line": 59,
        "is_bug": false
    },
    {
        "name": "test.testhelper.get_keystroke#121",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.get_keystroke(get_char_func get_char, void *param)",
        "snippet": "int get_keystroke(get_char_func get_char, void *param)\n{\n    TestKeyEntry *key_entry;\n    int ch;\n    char current_key[10];\n    int current_keylen = 0;\n    int partial_match;\n\n    assert(get_char);\n\n    while ((ch = get_char(param)) != END) {\n        current_key[current_keylen++] = ch;\n        current_key[current_keylen] = '\\0';\n\n        partial_match = 0;\n        for (key_entry = chewing_test_special_keys; key_entry->key; key_entry++) {\n            if (strcmp(key_entry->str, current_key) == 0) {\n                current_keylen = 0;\n                return key_entry->key;\n            }\n            if (strncmp(key_entry->str, current_key, current_keylen) == 0)\n                partial_match = 1;\n        }\n\n        /* special case: partial match but not special key */\n        if (strcmp(current_key, \"<<\") == 0 || strcmp(current_key, \"<>\") == 0) {\n            partial_match = 1;\n            continue;\n        }\n        if (strcmp(current_key, \"<<>\") == 0 || strcmp(current_key, \"<>>\") == 0) {\n            current_keylen = 0;\n            return current_key[1];\n        }\n\n\n        if (partial_match)\n            continue;\n\n        if (current_keylen > 1) {\n            fprintf(stderr, \"unknown key: '%s'\\n\", current_key);\n        }\n\n        return current_key[0];\n    }\n    return END;\n}",
        "begin_line": 121,
        "end_line": 166,
        "is_bug": false
    },
    {
        "name": "test.testhelper.type_single_keystroke#168",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.type_single_keystroke(ChewingContext *ctx, int key)",
        "snippet": "void type_single_keystroke(ChewingContext *ctx, int key)\n{\n    TestKeyEntry *key_entry;\n\n    for (key_entry = chewing_test_special_keys; key_entry->key; key_entry++) {\n        if (key_entry->key == key && key_entry->handler) {\n            key_entry->handler(ctx);\n            return;\n        }\n    }\n\n    if (KEY_CTRL_BASE <= key && key < KEY_NUMPAD_BASE)\n        chewing_handle_CtrlNum(ctx, key - KEY_CTRL_BASE);\n    else if (KEY_NUMPAD_BASE <= key)\n        chewing_handle_Numlock(ctx, key - KEY_NUMPAD_BASE);\n    else\n        chewing_handle_Default(ctx, (char) key);\n}",
        "begin_line": 168,
        "end_line": 185,
        "is_bug": false
    },
    {
        "name": "test.testhelper.type_keystroke#187",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.type_keystroke(ChewingContext *ctx, get_char_func get_char, void *param)",
        "snippet": "static void type_keystroke(ChewingContext *ctx, get_char_func get_char, void *param)\n{\n    int ch;\n\n    while ((ch = get_keystroke(get_char, param)) != END)\n        type_single_keystroke(ctx, ch);\n}",
        "begin_line": 187,
        "end_line": 193,
        "is_bug": false
    },
    {
        "name": "test.testhelper.get_char_by_string#195",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.get_char_by_string(void *param)",
        "snippet": "int get_char_by_string(void *param)\n{\n    const char **ptr = param;\n    char ch;\n\n    assert(param);\n\n    if (**ptr == 0) {\n        return END;\n    }\n\n    ch = **ptr;\n    ++*ptr;\n    return ch;\n}",
        "begin_line": 195,
        "end_line": 209,
        "is_bug": false
    },
    {
        "name": "test.testhelper.get_char_from_stdin#211",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.get_char_from_stdin(void *param UNUSED)",
        "snippet": "int get_char_from_stdin(void *param UNUSED)\n{\n    int ch = getchar();\n\n    if (ch == EOF)\n        return END;\n    return ch;\n}",
        "begin_line": 211,
        "end_line": 218,
        "is_bug": false
    },
    {
        "name": "test.testhelper.get_char_from_fp#220",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.get_char_from_fp(void *param)",
        "snippet": "int get_char_from_fp(void *param)\n{\n    FILE *fp = param;\n\n    assert(fp);\n    int ch = fgetc(fp);\n\n    if (ch == EOF)\n        return END;\n    return ch;\n}",
        "begin_line": 220,
        "end_line": 230,
        "is_bug": false
    },
    {
        "name": "test.testhelper.internal_ok#232",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.internal_ok(const char *file, int line, int test, const char *test_txt, const char *fmt, ...)",
        "snippet": "void internal_ok(const char *file, int line, int test, const char *test_txt, const char *fmt, ...)\n{\n    va_list ap;\n\n    ++test_run;\n    if (test) {\n        ++test_ok;\n        printf(\"ok %u \", test_run);\n\n        va_start(ap, fmt);\n        vprintf(fmt, ap);\n        va_end(ap);\n\n        printf(\"\\n\");\n    } else {\n        printf(\"not ok %u \", test_run);\n\n        va_start(ap, fmt);\n        vprintf(fmt, ap);\n        va_end(ap);\n\n        printf(\"\\n# %s failed in %s:%d\\n\", test_txt, file, line);\n    }\n}",
        "begin_line": 232,
        "end_line": 255,
        "is_bug": false
    },
    {
        "name": "test.testhelper.type_keystroke_by_string#257",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.type_keystroke_by_string(ChewingContext *ctx, const char *keystroke)",
        "snippet": "void type_keystroke_by_string(ChewingContext *ctx, const char *keystroke)\n{\n    type_keystroke(ctx, get_char_by_string, &keystroke);\n}",
        "begin_line": 257,
        "end_line": 260,
        "is_bug": false
    },
    {
        "name": "test.testhelper.internal_ok_buffer#262",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.internal_ok_buffer(const char *file, int line, ChewingContext *ctx, const char *expected, const BufferType *buffer)",
        "snippet": "void internal_ok_buffer(const char *file, int line, ChewingContext *ctx, const char *expected, const BufferType *buffer)\n{\n    char *buf;\n    const char *const_buf;\n    int actual_ret;\n    int expected_ret;\n    int expected_len;\n\n    assert(ctx);\n    assert(expected);\n    assert(buffer);\n\n    expected_len = ueStrLen(expected);\n\n    if (buffer->check) {\n        actual_ret = buffer->check(ctx);\n        expected_ret = ! !expected_len;\n        internal_ok(file, line, actual_ret == expected_ret,\n                    \"actual_ret == expected_ret\",\n                    \"%s check function returned `%d' shall be `%d'\", buffer->name, actual_ret, expected_ret);\n    }\n\n    if (buffer->check_alt) {\n        actual_ret = buffer->check_alt(ctx);\n        expected_ret = !expected_len;\n        internal_ok(file, line, actual_ret == expected_ret,\n                    \"actual_ret == expected_ret\",\n                    \"%s check function returned `%d' shall be `%d'\", buffer->name, actual_ret, expected_ret);\n    }\n\n    if (buffer->get_length) {\n        actual_ret = buffer->get_length(ctx);\n        expected_ret = expected_len;\n        internal_ok(file, line, actual_ret == expected_ret,\n                    \"actual_ret == expected_ret\",\n                    \"%s get length function returned `%d' shall be `%d'\", buffer->name, actual_ret, expected_ret);\n    }\n\n    if (buffer->get_string) {\n        buf = buffer->get_string(ctx);\n        internal_ok(file, line, !strcmp(buf, expected), \"!strcmp( buf, expected )\",\n                    \"%s string function returned `%s' shall be `%s'\", buffer->name, buf, expected);\n        chewing_free(buf);\n    }\n\n    if (buffer->get_string_alt) {\n        buf = buffer->get_string_alt(ctx, &actual_ret);\n        expected_ret = expected_len;\n        internal_ok(file, line, actual_ret == expected_ret,\n                    \"actual_ret == expected_ret\",\n                    \"%s string function returned parameter `%d' shall be `%d'\", buffer->name, actual_ret, expected_ret);\n        internal_ok(file, line, !strcmp(buf, expected), \"!strcmp( buf, expected )\",\n                    \"%s string function returned `%s' shall be `%s'\", buffer->name, buf, expected);\n        chewing_free(buf);\n    }\n\n    if (buffer->get_string_static) {\n        const_buf = buffer->get_string_static(ctx);\n        internal_ok(file, line, !strcmp(const_buf, expected), \"!strcmp( const_buf, expected )\",\n                    \"%s string function returned `%s' shall be `%s'\", buffer->name, const_buf, expected);\n    }\n}",
        "begin_line": 262,
        "end_line": 323,
        "is_bug": false
    },
    {
        "name": "test.testhelper.internal_ok_candidate#325",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.internal_ok_candidate(const char *file, int line, ChewingContext *ctx, const char *cand[], size_t cand_len)",
        "snippet": "void internal_ok_candidate(const char *file, int line, ChewingContext *ctx, const char *cand[], size_t cand_len)\n{\n    size_t i;\n    char *buf;\n    const char *const_buf;\n\n    assert(ctx);\n\n    chewing_cand_Enumerate(ctx);\n    for (i = 0; i < cand_len; ++i) {\n        internal_ok(file, line, chewing_cand_hasNext(ctx), __func__, \"shall has next candidate\");\n\n        buf = chewing_cand_String(ctx);\n        internal_ok(file, line, strcmp(buf, cand[i]) == 0, __func__, \"candidate `%s' shall be `%s'\", buf, cand[i]);\n        chewing_free(buf);\n\n        const_buf = chewing_cand_string_by_index_static(ctx, i);\n        internal_ok(file, line, strcmp(const_buf, cand[i]) == 0, __func__,\n                    \"candndate `%s' shall be `%s'\", const_buf, cand[i]);\n    }\n\n    internal_ok(file, line, !chewing_cand_hasNext(ctx), __func__, \"shall not have next candidate\");\n    buf = chewing_cand_String(ctx);\n\n    internal_ok(file, line, strcmp(buf, \"\") == 0, __func__, \"candndate `%s' shall be `%s'\", buf, \"\");\n\n    const_buf = chewing_cand_string_by_index_static(ctx, i);\n    internal_ok(file, line, strcmp(const_buf, \"\") == 0, __func__, \"candndate `%s' shall be `%s'\", const_buf, \"\");\n\n    chewing_free(buf);\n}",
        "begin_line": 325,
        "end_line": 355,
        "is_bug": false
    },
    {
        "name": "test.testhelper.internal_ok_candidate_len#357",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.internal_ok_candidate_len(const char *file, int line, ChewingContext *ctx, size_t expected_len)",
        "snippet": "void internal_ok_candidate_len(const char *file, int line, ChewingContext *ctx, size_t expected_len)\n{\n    const char *buf;\n    size_t actual_len;\n\n    assert(ctx);\n\n    buf = chewing_cand_string_by_index_static(ctx, 0);\n    actual_len = ueStrLen(buf);\n    internal_ok(file, line, actual_len == expected_len, __func__,\n                \"candidate length `%d' shall be `%d'\", actual_len, expected_len);\n}",
        "begin_line": 357,
        "end_line": 368,
        "is_bug": false
    },
    {
        "name": "test.testhelper.internal_ok_keystroke_rtn#370",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.internal_ok_keystroke_rtn(const char *file, int line, ChewingContext *ctx, int rtn)",
        "snippet": "void internal_ok_keystroke_rtn(const char *file, int line, ChewingContext *ctx, int rtn)\n{\n    const struct {\n        int rtn;\n        int (*func) (const ChewingContext *ctx);\n    } TABLE[] = {\n        {KEYSTROKE_IGNORE, chewing_keystroke_CheckIgnore},\n        {KEYSTROKE_COMMIT, chewing_commit_Check},\n        // No function to check KEYSTROKE_BELL\n        {KEYSTROKE_ABSORB, chewing_keystroke_CheckAbsorb},\n    };\n    size_t i;\n    int actual;\n    int expected;\n\n    assert(ctx);\n\n    for (i = 0; i < ARRAY_SIZE(TABLE); ++i) {\n        actual = TABLE[i].func(ctx);\n        expected = ! !(rtn & TABLE[i].rtn);\n\n        internal_ok(file, line, actual == expected, __func__, \"keystroke rtn `%d' shall be `%d'\", actual, expected);\n    }\n}",
        "begin_line": 370,
        "end_line": 393,
        "is_bug": false
    },
    {
        "name": "test.testhelper.logger#395",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.logger(void *data, int level UNUSED, const char *fmt, ...)",
        "snippet": "void logger(void *data, int level UNUSED, const char *fmt, ...)\n{\n    va_list ap;\n    FILE *fd = (FILE *) data;\n\n    va_start(ap, fmt);\n    vfprintf(fd, fmt, ap);\n    va_end(ap);\n}",
        "begin_line": 395,
        "end_line": 403,
        "is_bug": false
    },
    {
        "name": "test.testhelper.internal_start_testcase#405",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.internal_start_testcase(const char *func, ChewingContext *ctx, FILE * file)",
        "snippet": "void internal_start_testcase(const char *func, ChewingContext *ctx, FILE * file)\n{\n    assert(func);\n\n    printf(\"#\\n# %s\\n#\\n\", func);\n    fprintf(file, \"#\\n# %s\\n#\\n\", func);\n    chewing_set_logger(ctx, logger, file);\n}",
        "begin_line": 405,
        "end_line": 412,
        "is_bug": false
    },
    {
        "name": "test.testhelper.exit_status#414",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.exit_status()",
        "snippet": "int exit_status()\n{\n    return test_run == test_ok ? 0 : -1;\n}",
        "begin_line": 414,
        "end_line": 417,
        "is_bug": false
    },
    {
        "name": "test.testhelper.get_test_userphrase_path#419",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.get_test_userphrase_path()",
        "snippet": "char *get_test_userphrase_path()\n{\n    char *userphrase_path = getenv(\"TEST_USERPHRASE_PATH\");\n\n    if (userphrase_path)\n        return userphrase_path;\n    else\n        return TEST_HASH_DIR PLAT_SEPARATOR DB_NAME;\n}",
        "begin_line": 419,
        "end_line": 427,
        "is_bug": false
    },
    {
        "name": "test.testhelper.clean_userphrase#429",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.clean_userphrase()",
        "snippet": "void clean_userphrase()\n{\n    char *userphrase_path = get_test_userphrase_path();\n\n    if (remove(userphrase_path) != 0 && errno != ENOENT)\n        fprintf(stderr, \"remove fails at %s:%d\\n\", __FILE__, __LINE__);\n}",
        "begin_line": 429,
        "end_line": 435,
        "is_bug": false
    },
    {
        "name": "test.test-easy-symbol.test_type_easy_symbol#55",
        "src_path": "test/test-easy-symbol.c",
        "class_name": "test.test-easy-symbol",
        "signature": "test.test-easy-symbol.test_type_easy_symbol()",
        "snippet": "void test_type_easy_symbol()\n{\n    ChewingContext *ctx;\n    size_t i;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_maxChiSymbolLen(ctx, 16);\n    chewing_set_easySymbolInput(ctx, 1);\n\n    for (i = 0; i < ARRAY_SIZE(EASY_SYMBOL); ++i) {\n        type_keystroke_by_string(ctx, EASY_SYMBOL[i].token);\n        ok_preedit_buffer(ctx, EASY_SYMBOL[i].expected);\n        type_keystroke_by_string(ctx, \"<E>\");\n        ok_commit_buffer(ctx, EASY_SYMBOL[i].expected);\n    }\n\n    chewing_delete(ctx);\n}",
        "begin_line": 55,
        "end_line": 74,
        "is_bug": false
    },
    {
        "name": "test.test-easy-symbol.test_mode_change#76",
        "src_path": "test/test-easy-symbol.c",
        "class_name": "test.test-easy-symbol",
        "signature": "test.test-easy-symbol.test_mode_change()",
        "snippet": "void test_mode_change()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_maxChiSymbolLen(ctx, 16);\n\n    type_keystroke_by_string(ctx, CHINESE.token);\n    ok_commit_buffer(ctx, CHINESE.expected);\n\n    chewing_set_easySymbolInput(ctx, 1);\n    type_keystroke_by_string(ctx, EASY_SYMBOL[0].token);\n    type_keystroke_by_string(ctx, \"<E>\");\n    ok_commit_buffer(ctx, EASY_SYMBOL[0].expected);\n\n    chewing_set_easySymbolInput(ctx, 0);\n    type_keystroke_by_string(ctx, CHINESE.token);\n    ok_commit_buffer(ctx, CHINESE.expected);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 76,
        "end_line": 98,
        "is_bug": false
    },
    {
        "name": "test.test-easy-symbol.main#100",
        "src_path": "test/test-easy-symbol.c",
        "class_name": "test.test-easy-symbol",
        "signature": "test.test-easy-symbol.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    char *logname;\n    int ret;\n\n    putenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n    putenv(\"CHEWING_USER_PATH=\" TEST_HASH_DIR);\n\n    ret = asprintf(&logname, \"%s.log\", argv[0]);\n    if (ret == -1)\n        return -1;\n    fd = fopen(logname, \"w\");\n    assert(fd);\n    free(logname);\n\n\n    test_type_easy_symbol();\n    test_mode_change();\n\n    fclose(fd);\n\n    return exit_status();\n}",
        "begin_line": 100,
        "end_line": 122,
        "is_bug": false
    },
    {
        "name": "test.test-key2pho.test_uint_and_phone#24",
        "src_path": "test/test-key2pho.c",
        "class_name": "test.test-key2pho",
        "signature": "test.test-key2pho.test_uint_and_phone()",
        "snippet": "void test_uint_and_phone()\n{\n    char *u8phone;\n    char rt[MAX_UTF8_SIZE * BOPOMOFO_SIZE + 1];\n    uint16_t phone;\n    uint16_t expect;\n\n    start_testcase(NULL, fd);\n\n    u8phone = \"\\xE3\\x84\\x86\\xE3\\x84\\xA3\" /* \u3106\u3123 */ ;\n    phone = UintFromPhone(u8phone);\n    expect = 1104;\n    ok(phone == expect, \"UintFromPhone `%s' shall be `%d', got `%d'\", u8phone, expect, phone);\n\n    PhoneFromUint(rt, sizeof(rt), expect);\n    ok(strcmp(rt, u8phone) == 0, \"PhoneFromUint d%d' shall be `%s', got `%s'\", expect, u8phone, rt);\n\n\n    u8phone = \"\\xE3\\x84\\x8A\\xE3\\x84\\xA7\\xE3\\x84\\xA2\" /* \u310a\u3127\u3122 */ ;\n    phone = UintFromPhone(u8phone);\n    expect = 3272;\n    ok(phone == expect, \"UintFromPhone `%s' shall be `%d', got `%d'\", u8phone, expect, phone);\n\n    PhoneFromUint(rt, sizeof(rt), expect);\n    ok(strcmp(rt, u8phone) == 0, \"PhoneFromUint d%d' shall be `%s', got `%s'\", expect, u8phone, rt);\n\n\n    u8phone = \"\\xE3\\x84\\x92\\xE3\\x84\\xA7\\xE3\\x84\\x9A\\xCB\\x8B\" /* \u3112\u3127\u311a\u02cb */ ;\n    phone = UintFromPhone(u8phone);\n    expect = 7308;\n    ok(phone == expect, \"UintFromPhone `%s' shall be `%d', got `%d'\", u8phone, expect, phone);\n\n    PhoneFromUint(rt, sizeof(rt), expect);\n    ok(strcmp(rt, u8phone) == 0, \"PhoneFromUint `%d' shall be `%s', got `%s'\", expect, u8phone, rt);\n}\n\nvoid test_uint_",
        "begin_line": 24,
        "end_line": 58,
        "is_bug": false
    },
    {
        "name": "test.test-key2pho.test_uint_and_phone_error#60",
        "src_path": "test/test-key2pho.c",
        "class_name": "test.test-key2pho",
        "signature": "test.test-key2pho.test_uint_and_phone_error()",
        "snippet": "void test_uint_and_phone_error()\n{\n    char *u8phone;\n    char rt[MAX_UTF8_SIZE * BOPOMOFO_SIZE + 1];\n    uint16_t phone;\n    uint16_t expect;\n\n    start_testcase(NULL, fd);\n\n    u8phone = \"\\xE3\\x84\\x8A\\xE3\\x84\\xA7\\xE6\\xB8\\xAC\" /* \u310a\u3127\u6e2c */ ;\n    phone = UintFromPhone(u8phone);\n    expect = 0;\n    ok(phone == expect, \"UintFromPhone `%s' shall be `%d', got `%d'\", u8phone, expect, phone);\n\n    u8phone = \"\\xE3\\x84\\x8E\\xE3\\x84\\x8E\" /* \u310e\u310e */ ;\n    phone = UintFromPhone(u8phone);\n    expect = 0;\n    ok(phone == expect, \"UintFromPhone `%s' shall be `%d', got `%d'\", u8phone, expect, phone);\n\n    u8phone = \"\\xE3\\x84\\xA8\\xE3\\x84\\x8E\" /* \u3128\u310e */ ;\n    phone = UintFromPhone(u8phone);\n    expect = 0;\n    ok(phone == expect, \"UintFromPhone `%s' shall be `%d', got `%d'\", u8phone, expect, phone);\n\n    PhoneFromUint(rt, sizeof(rt), 0);\n    ok(strcmp(rt, \"\") == 0, \"PhoneFromUint `%d' shall be `%s', got `%s'\", 0, \"\", rt);\n\n}\n\nvoid test_ke",
        "begin_line": 60,
        "end_line": 87,
        "is_bug": false
    },
    {
        "name": "test.test-key2pho.test_key_and_phone#89",
        "src_path": "test/test-key2pho.c",
        "class_name": "test.test-key2pho",
        "signature": "test.test-key2pho.test_key_and_phone()",
        "snippet": "void test_key_and_phone()\n{\n    char rt[MAX_UTF8_SIZE * BOPOMOFO_SIZE + 1];\n\n    start_testcase(NULL, fd);\n\n    PhoneFromKey(rt, \"dj\", KB_DEFAULT, 1);\n    ok(!strcmp(rt, \"\\xE3\\x84\\x8E\\xE3\\x84\\xA8\" /* \u310e\u3128 */ ), \"dj\");\n\n    PhoneFromKey(rt, \"dj6\", KB_DEFAULT, 1);\n    ok(!strcmp(rt, \"\\xE3\\x84\\x8E\\xE3\\x84\\xA8\\xCB\\x8A\" /* \u310e\u3128\u02ca */ ), \"dj6\");\n\n    PhoneFromKey(rt, \"dj3\", KB_DEFAULT, 1);\n    ok(!strcmp(rt, \"\\xE3\\x84\\x8E\\xE3\\x84\\xA8\\xCB\\x87\" /* \u310e\u3128\u02c7 */ ), \"dj3\");\n\n    PhoneFromKey(rt, \"dj4\", KB_DEFAULT, 1);\n    ok(!strcmp(rt, \"\\xE3\\x84\\x8E\\xE3\\x84\\xA8\\xCB\\x8B\" /* \u310e\u3128\u02cb */ ), \"dj4\");\n\n    PhoneFromKey(rt, \"dj7\", KB_DEFAULT, 1);\n    ok(!strcmp(rt, \"\\xE3\\x84\\x8E\\xE3\\x84\\xA8\\xCB\\x99\" /* \u310e\u3128\u02d9 */ ), \"dj7\");\n}\n\nint main(int argc, cha",
        "begin_line": 89,
        "end_line": 109,
        "is_bug": false
    },
    {
        "name": "test.test-key2pho.main#111",
        "src_path": "test/test-key2pho.c",
        "class_name": "test.test-key2pho",
        "signature": "test.test-key2pho.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    char *logname;\n    int ret;\n\n    putenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n    putenv(\"CHEWING_USER_PATH=\" TEST_HASH_DIR);\n\n    ret = asprintf(&logname, \"%s.log\", argv[0]);\n    if (ret == -1)\n        return -1;\n    fd = fopen(logname, \"w\");\n    assert(fd);\n    free(logname);\n\n\n    test_uint_and_phone();\n    test_uint_and_phone_error();\n    test_key_and_phone();\n\n    fclose(fd);\n\n    return exit_status();\n}",
        "begin_line": 111,
        "end_line": 134,
        "is_bug": false
    },
    {
        "name": "test.simulate.init_sim#31",
        "src_path": "test/simulate.c",
        "class_name": "test.simulate",
        "signature": "test.simulate.init_sim()",
        "snippet": "int init_sim()\n{\n    if (0 == access(FN_MATERIALS \"-random\", R_OK))\n        fp = fopen(FN_MATERIALS \"-random\", \"r\");\n    else\n        fp = fopen(FN_MATERIALS, \"r\");\n    return (fp != NULL);\n}",
        "begin_line": 31,
        "end_line": 38,
        "is_bug": false
    },
    {
        "name": "test.simulate.fini_sim#40",
        "src_path": "test/simulate.c",
        "class_name": "test.simulate",
        "signature": "test.simulate.fini_sim()",
        "snippet": "int fini_sim()\n{\n    if (fp)\n        fclose(fp);\n    fflush(stdout);\n    return 0;\n}",
        "begin_line": 40,
        "end_line": 46,
        "is_bug": false
    },
    {
        "name": "test.simulate.get_test_case#56",
        "src_path": "test/simulate.c",
        "class_name": "test.simulate",
        "signature": "test.simulate.get_test_case()",
        "snippet": "static int get_test_case()\n{\n    while (fgets(linebuf, sizeof(linebuf), fp)) {\n        char *pos;\n        if (linebuf[0] == '#' || linebuf[0] == ' ')\n            continue;\n\n        /* input string */\n        pos = strstr(linebuf, \"<E>\");\n        if (!pos) {\n            fprintf(stderr, \"error: no <E> in input string\\n\");\n            return 0;\n        }\n        *(pos + 3) = '\\0';\n\n        /* expected string */\n        pos += 4;\n        while (*pos == '\\t' || *pos == ' ')\n            pos++;\n        strcpy(expect_string_buf, pos);\n        return 1;\n    }\n    return 0;\n}",
        "begin_line": 56,
        "end_line": 79,
        "is_bug": false
    },
    {
        "name": "test.simulate.commit_string#81",
        "src_path": "test/simulate.c",
        "class_name": "test.simulate",
        "signature": "test.simulate.commit_string(ChewingContext *ctx)",
        "snippet": "static void commit_string(ChewingContext *ctx)\n{\n    char *s;\n\n    if (chewing_commit_Check(ctx)) {\n        s = chewing_commit_String(ctx);\n        strcat(commit_string_buf, s);\n        free(s);\n    }\n}",
        "begin_line": 81,
        "end_line": 90,
        "is_bug": false
    },
    {
        "name": "test.simulate.compare_per_run#92",
        "src_path": "test/simulate.c",
        "class_name": "test.simulate",
        "signature": "test.simulate.compare_per_run()",
        "snippet": "void compare_per_run()\n{\n    int i, len;\n    char utf8buf_expect[16];\n    char utf8buf_commit[16];\n\n    printf(\"Expected:  %s\", expect_string_buf);\n    printf(\"Committed: \");\n\n    tested_word_count += (len = ueStrLen(expect_string_buf) - 1);\n    /* omit the suffix character */\n    for (i = 0; i < len; i++) {\n        ueStrNCpy(utf8buf_expect, ueStrSeek(expect_string_buf, i), 1, STRNCPY_CLOSE);\n        ueStrNCpy(utf8buf_commit, ueStrSeek(commit_string_buf, i), 1, STRNCPY_CLOSE);\n        if (!strcmp(utf8buf_expect, utf8buf_commit))\n            printf(\"%s\", utf8buf_commit);\n        else {\n            printf(\"\\033[44;37m%s\\033[m\", utf8buf_commit);\n            failed_word_count++;\n        }\n    }\n    memset(commit_string_buf, 0, MAXLEN);\n    printf(\"\\n\\n\");\n}",
        "begin_line": 92,
        "end_line": 115,
        "is_bug": false
    },
    {
        "name": "test.simulate.main#117",
        "src_path": "test/simulate.c",
        "class_name": "test.simulate",
        "signature": "test.simulate.main()",
        "snippet": "int main()\n{\n    if (!init_sim())\n        return 1;\n\n    /* Initialize libchewing */\n    putenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n    /* for the sake of testing, we should not change existing hash data */\n    putenv(\"CHEWING_USER_PATH=\" TEST_HASH_DIR);\n\n    while (get_test_case()) {\n        /* Request handle to ChewingContext */\n        ChewingContext *ctx = chewing_new();\n\n        chewing_set_KBType(ctx, chewing_KBStr2Num(\"KB_DEFAULT\"));\n        chewing_set_candPerPage(ctx, 9);\n        chewing_set_maxChiSymbolLen(ctx, 16);\n        chewing_set_addPhraseDirection(ctx, 1);\n        chewing_set_selKey(ctx, selKey_define, 10);\n        chewing_set_spaceAsSelection(ctx, 1);\n\n        int ch;\n        char *keystroke = linebuf;\n        while ((ch = get_keystroke(get_char_by_string, &keystroke)) != END) {\n            type_single_keystroke(ctx, ch);\n            commit_string(ctx);\n        }\n        compare_per_run();\n\n        chewing_delete(ctx);\n    }\n\n    printf(\"_________________________________________________________________________\\n\" \"[ Report ]\\n\");\n    printf(\"Checks: %d words,  Failures: %d words\\n\", tested_word_count, failed_word_count);\n    printf(\"Ratio: %.2f%%\\n\", (float) (tested_word_count - failed_word_count) / tested_word_count * 100);\n\n    fini_sim();\n    return 0;\n}",
        "begin_line": 117,
        "end_line": 155,
        "is_bug": false
    },
    {
        "name": "test.test-regression.test_libchewing_googlecode_issue_472#25",
        "src_path": "test/test-regression.c",
        "class_name": "test.test-regression",
        "signature": "test.test-regression.test_libchewing_googlecode_issue_472()",
        "snippet": "void test_libchewing_googlecode_issue_472()\n{\n    static const char *const INPUT[] = {\n        \"<T>|&Wt<H>mrJY)G<C2>OqJ<H><H>Yl<R>p0<EE>QE[^<C1>k\",\n        \"+F<C9>hQ$UIICMr!X8/9<C3>(N<T>yU2!-LUI<D>`CS<D>jShm9SF}<EN>[`QYu<C8>k\",\n        \"hk4`2<D>jk\",\n        \"hk4`j 0\",\n        \"hk4<C0>j 0\",\n    };\n    size_t i;\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n    chewing_set_autoShiftCur(ctx, 1);\n\n    for (i = 0; i < ARRAY_SIZE(INPUT); ++i) {\n        chewing_Reset(ctx);\n        type_keystroke_by_string(ctx, INPUT[i]);\n    }\n\n    chewing_delete(ctx);\n}",
        "begin_line": 25,
        "end_line": 48,
        "is_bug": false
    },
    {
        "name": "test.test-regression.test_libchewing_googlecode_issue_473#50",
        "src_path": "test/test-regression.c",
        "class_name": "test.test-regression",
        "signature": "test.test-regression.test_libchewing_googlecode_issue_473()",
        "snippet": "void test_libchewing_googlecode_issue_473()\n{\n    static const char *const INPUT[] = {\n        \"t<N->_ M1<N+>H[Ls3<L><N1>PL+Z]4<C1>&(^H*H<TT>Sc<N->P]!|<CB>-<C6>S<H><N1><C0>U<B>d}P!f<EN><N.><C7>V!U!w|4-=S<C1>b<N2>Q\",\n        \"wv<C0><C5><N9>$FIF<D><N4>B *<C2>E4*<C2>q)Kf)<SS><TT>4=<N5>%<R>mN4<EN>H<N9><N.>8s{XTD<N6>jZV(y3G`9<C6>JTy<B>J<C1>SNc<E>hC<SL><N/><R><C6>@an<C3><N7>wzF<C3>P*<N*><B>l<C3><N6>W<N*> $<SR><N.><N1><E><E><N0><N6>Y\",\n    };\n    size_t i;\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n    chewing_set_autoShiftCur(ctx, 1);\n    chewing_set_candPerPage(ctx, 9);\n    chewing_set_addPhraseDirection(ctx, 1);\n    chewing_set_spaceAsSelection(ctx, 1);\n\n    for (i = 0; i < ARRAY_SIZE(INPUT); ++i) {\n        chewing_Reset(ctx);\n        type_keystroke_by_string(ctx, INPUT[i]);\n    }\n\n    chewing_delete(ctx);\n}",
        "begin_line": 50,
        "end_line": 73,
        "is_bug": false
    },
    {
        "name": "test.test-regression.test_libchewing_issue_30#75",
        "src_path": "test/test-regression.c",
        "class_name": "test.test-regression",
        "signature": "test.test-regression.test_libchewing_issue_30()",
        "snippet": "void test_libchewing_issue_30()\n{\n    ChewingContext *ctx;\n    int cursor;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n    chewing_set_autoShiftCur(ctx, 1);\n    chewing_set_spaceAsSelection(ctx, 1);\n    chewing_set_phraseChoiceRearward(ctx, 1);\n\n    type_keystroke_by_string(ctx, \"hk4g4<H> 3 1\");\n    cursor = chewing_cursor_Current(ctx);\n    ok(cursor == 2, \"cursor position `%d' shall be `2'\", cursor);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 75,
        "end_line": 94,
        "is_bug": false
    },
    {
        "name": "test.test-regression.test_libchewing_issue_108#96",
        "src_path": "test/test-regression.c",
        "class_name": "test.test-regression",
        "signature": "test.test-regression.test_libchewing_issue_108()",
        "snippet": "void test_libchewing_issue_108()\n{\n    ChewingContext *ctx;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"yjo4cl3183<E>\");\n\n    chewing_delete(ctx);\n}",
        "begin_line": 96,
        "end_line": 108,
        "is_bug": false
    },
    {
        "name": "test.test-regression.test_libchewing_issue_194#110",
        "src_path": "test/test-regression.c",
        "class_name": "test.test-regression",
        "signature": "test.test-regression.test_libchewing_issue_194()",
        "snippet": "void test_libchewing_issue_194()\n{\n    ChewingContext *ctx;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_ChiEngMode(ctx, SYMBOL_MODE);\n    type_keystroke_by_string(ctx, \"test\");\n    chewing_set_ChiEngMode(ctx, CHINESE_MODE);\n\n    ok_commit_buffer(ctx, \"t\");\n\n    chewing_delete(ctx);\n}",
        "begin_line": 110,
        "end_line": 126,
        "is_bug": false
    },
    {
        "name": "test.test-regression.test_libchewing_data_issue_1#128",
        "src_path": "test/test-regression.c",
        "class_name": "test.test-regression",
        "signature": "test.test-regression.test_libchewing_data_issue_1()",
        "snippet": "void test_libchewing_data_issue_1()\n{\n    const TestData DATA = { \"e03y.3\", \"\\xE8\\xB6\\x95\\xE8\\xB5\\xB0\" /* \u8d95\u8d70 */  };\n    ChewingContext *ctx;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n    type_keystroke_by_string(ctx, DATA.token);\n    ok_preedit_buffer(ctx, DATA.expected);\n\n    chewing_delete(ctx);\n}\n\nin",
        "begin_line": 128,
        "end_line": 142,
        "is_bug": false
    },
    {
        "name": "test.test-regression.main#144",
        "src_path": "test/test-regression.c",
        "class_name": "test.test-regression",
        "signature": "test.test-regression.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    char *logname;\n    int ret;\n\n    putenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n    putenv(\"CHEWING_USER_PATH=\" TEST_HASH_DIR);\n\n    ret = asprintf(&logname, \"%s.log\", argv[0]);\n    if (ret == -1)\n        return -1;\n    fd = fopen(logname, \"w\");\n    assert(fd);\n    free(logname);\n\n\n    test_libchewing_data_issue_1();\n    test_libchewing_issue_30();\n    test_libchewing_issue_108();\n    test_libchewing_issue_194();\n    test_libchewing_googlecode_issue_472();\n    test_libchewing_googlecode_issue_473();\n\n    fclose(fd);\n\n    return exit_status();\n}",
        "begin_line": 144,
        "end_line": 170,
        "is_bug": false
    },
    {
        "name": "test.test-utf8.test_utf8#20",
        "src_path": "test/test-utf8.c",
        "class_name": "test.test-utf8",
        "signature": "test.test-utf8.test_utf8()",
        "snippet": "void test_utf8()\n{\n    char *u8string;\n    int u8len;\n    int len;\n    char u8string2[16];\n\n    start_testcase(NULL, fd);\n\n    u8string = \"HelloWorld\";\n    u8len = ueStrLen(u8string);\n    len = strlen(u8string);\n    ok(u8len == len, \"ueStrLen\");\n\n    u8string = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE8\\xA8\\x88\\xE7\\xAE\\x97\\xE9\\x95\\xB7\\xE5\\xBA\\xA6\";      /* \u6e2c\u8a66\u8a08\u7b97\u9577\u5ea6 */\n    u8len = ueStrLen(u8string);\n    ok(u8len == 6, \"ueStrLen\");\n\n    u8string = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE8\\xA8\\x88\\xE7\\xAE\\x97\\xE9\\x95\\xB7\\xE5\\xBA\\xA6\";      /* \u6e2c\u8a66\u8a08\u7b97\u9577\u5ea6 */\n    ueStrNCpy(u8string2, u8string, 3, STRNCPY_CLOSE);\n    ok(!strcmp(u8string2, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE8\\xA8\\x88\" /* \u6e2c\u8a66\u8a08 */ ), \"ueStrNCpy\");\n\n    u8string = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE8\\xA8\\x88\\xE7\\xAE\\x97\\xE9\\x95\\xB7\\xE5\\xBA\\xA6\";      /* \u6e2c\u8a66\u8a08\u7b97\u9577\u5ea6 */\n    u8string = ueStrSeek(u8string, 3);\n    ok(!strcmp(u8string, \"\\xE7\\xAE\\x97\\xE9\\x95\\xB7\\xE5\\xBA\\xA6\" /* \u7b97\u9577\u5ea6 */ ), \"ueStrSeek\");\n\n    u8string = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE8\\xA8\\x88\\xE7\\xAE\\x97\\xE9\\x95\\xB7\\xE5\\xBA\\xA6\";      /* \u6e2c\u8a66\u8a08\u7b97\u9577\u5ea6 */\n    u8string = ueStrSeek(u8string, 0);\n    ok(!strcmp\n       (u8string, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE8\\xA8\\x88\\xE7\\xAE\\x97\\xE9\\x95\\xB7\\xE5\\xBA\\xA6\" /* \u6e2c\u8a66\u8a08\u7b97\u9577\u5ea6 */ ),\n       \"ueStrSeek\");\n\n}\n\nint main(int argc, char *argv[])\n{\n    char *logname;\n    int ret;\n\n  ",
        "begin_line": 20,
        "end_line": 52,
        "is_bug": false
    },
    {
        "name": "test.test-utf8.main#54",
        "src_path": "test/test-utf8.c",
        "class_name": "test.test-utf8",
        "signature": "test.test-utf8.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    char *logname;\n    int ret;\n\n    putenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n    putenv(\"CHEWING_USER_PATH=\" TEST_HASH_DIR);\n\n    ret = asprintf(&logname, \"%s.log\", argv[0]);\n    if (ret == -1)\n        return -1;\n    fd = fopen(logname, \"w\");\n    assert(fd);\n    free(logname);\n\n    test_utf8();\n\n    fclose(fd);\n\n    return exit_status();\n}",
        "begin_line": 54,
        "end_line": 74,
        "is_bug": false
    },
    {
        "name": "test.performance.main#15",
        "src_path": "test/performance.c",
        "class_name": "test.performance",
        "signature": "test.performance.main()",
        "snippet": "int main()\n{\n    ChewingContext *ctx;\n    int ch;\n\n    /* Initialize libchewing */\n    putenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n    /* for the sake of testing, we should not change existing hash data */\n    putenv(\"CHEWING_USER_PATH=\" TEST_HASH_DIR);\n\n    ctx = chewing_new();\n\n    while ((ch = getchar()) != EOF) {\n        chewing_handle_Default(ctx, ch);\n    }\n\n    chewing_delete(ctx);\n    return 0;\n}",
        "begin_line": 15,
        "end_line": 33,
        "is_bug": false
    },
    {
        "name": "test.test-mmap.test_UnitFromPlatMmap#29",
        "src_path": "test/test-mmap.c",
        "class_name": "test.test-mmap",
        "signature": "test.test-mmap.test_UnitFromPlatMmap()",
        "snippet": "void test_UnitFromPlatMmap()\n{\n    unsigned int idx;\n    plat_mmap m_mmap;\n    size_t offset = 0;\n    size_t csize;\n    char *data_buf;\n    char hard_copy[] = \"ji3cp3vu3cj0 vup dj4up <E>\";\n    int i;\n\n    start_testcase(NULL, fd);\n\n    idx = plat_mmap_create(&m_mmap, TEST_DATA_DIR PLAT_SEPARATOR \"default-test.txt\", FLAG_ATTRIBUTE_READ);\n    ok(idx == 28, \"plat_mmap_create\");\n    if (idx > 0) {\n        csize = idx;\n        data_buf = (char *) plat_mmap_set_view(&m_mmap, &offset, &csize);\n        for (i = 0; i < 26; i++) {\n            if (data_buf[i] != hard_copy[i])\n                break;\n        }\n        ok(i == 26, \"plat_mmap_set_view\");\n    }\n    plat_mmap_close(&m_mmap);\n}",
        "begin_line": 29,
        "end_line": 53,
        "is_bug": false
    },
    {
        "name": "test.test-mmap.main#55",
        "src_path": "test/test-mmap.c",
        "class_name": "test.test-mmap",
        "signature": "test.test-mmap.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    char *logname;\n    int ret;\n\n    putenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n    putenv(\"CHEWING_USER_PATH=\" TEST_HASH_DIR);\n\n    ret = asprintf(&logname, \"%s.log\", argv[0]);\n    if (ret == -1)\n        return -1;\n    fd = fopen(logname, \"w\");\n    assert(fd);\n    free(logname);\n\n\n    test_UnitFromPlatMmap();\n\n    fclose(fd);\n\n    return exit_status();\n}",
        "begin_line": 55,
        "end_line": 76,
        "is_bug": false
    },
    {
        "name": "test.test-symbol.test_type_symbol#338",
        "src_path": "test/test-symbol.c",
        "class_name": "test.test-symbol",
        "signature": "test.test-symbol.test_type_symbol()",
        "snippet": "void test_type_symbol()\n{\n    ChewingContext *ctx;\n    size_t i;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_candPerPage(ctx, 10);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n\n    for (i = 0; i < ARRAY_SIZE(SYMBOL); ++i) {\n        type_keystroke_by_string(ctx, SYMBOL[i].token);\n        ok_preedit_buffer(ctx, \"\");\n        ok_commit_buffer(ctx, SYMBOL[i].expected);\n    }\n\n    chewing_delete(ctx);\n}",
        "begin_line": 338,
        "end_line": 356,
        "is_bug": false
    },
    {
        "name": "test.test-symbol.test_symbol_cand_page#358",
        "src_path": "test/test-symbol.c",
        "class_name": "test.test-symbol",
        "signature": "test.test-symbol.test_symbol_cand_page()",
        "snippet": "void test_symbol_cand_page()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_candPerPage(ctx, 10);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n\n    chewing_handle_Default(ctx, '`');\n    ok(chewing_cand_CurrentPage(ctx) == 0, \"current page shall be 0\");\n    ok(chewing_cand_TotalPage(ctx) == 2, \"total page shall be 2\");\n\n    ok_candidate(ctx, CAND, ARRAY_SIZE(CAND));\n\n    chewing_delete(ctx);\n}",
        "begin_line": 358,
        "end_line": 375,
        "is_bug": false
    },
    {
        "name": "test.test-symbol.test_symbol_count#377",
        "src_path": "test/test-symbol.c",
        "class_name": "test.test-symbol",
        "signature": "test.test-symbol.test_symbol_count()",
        "snippet": "void test_symbol_count()\n{\n    ChewingContext *ctx;\n    int total;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"`3\");\n    total = chewing_cand_TotalChoice(ctx);\n    ok(total == 30, \"total candidate for `3 is %d, shall be %d\", total, 30);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 377,
        "end_line": 390,
        "is_bug": false
    },
    {
        "name": "test.test-symbol.test_symbol#392",
        "src_path": "test/test-symbol.c",
        "class_name": "test.test-symbol",
        "signature": "test.test-symbol.test_symbol()",
        "snippet": "void test_symbol()\n{\n    test_symbol_cand_page();\n    test_symbol_count();\n}",
        "begin_line": 392,
        "end_line": 396,
        "is_bug": false
    },
    {
        "name": "test.test-symbol.test_nocand_symbol#398",
        "src_path": "test/test-symbol.c",
        "class_name": "test.test-symbol",
        "signature": "test.test-symbol.test_nocand_symbol()",
        "snippet": "void test_nocand_symbol()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_candPerPage(ctx, 10);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n\n    type_keystroke_by_string(ctx, \"`<R>20\");\n    ok_preedit_buffer(ctx, \"\\xE2\\x96\\x88\"); /* \u2588 */\n\n    type_keystroke_by_string(ctx, \"<D>\");\n    ok_candidate(ctx, CAND, ARRAY_SIZE(CAND));\n\n    type_keystroke_by_string(ctx, \"1<E>\"); /* select \u2026 */\n    ok_commit_buffer(ctx, \"\\xE2\\x80\\xA6\");\n\n    chewing_delete(ctx);\n}\n\nin",
        "begin_line": 398,
        "end_line": 418,
        "is_bug": false
    },
    {
        "name": "test.test-symbol.main#420",
        "src_path": "test/test-symbol.c",
        "class_name": "test.test-symbol",
        "signature": "test.test-symbol.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    char *logname;\n    int ret;\n\n    putenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n    putenv(\"CHEWING_USER_PATH=\" TEST_HASH_DIR);\n\n    ret = asprintf(&logname, \"%s.log\", argv[0]);\n    if (ret == -1)\n        return -1;\n    fd = fopen(logname, \"w\");\n    assert(fd);\n    free(logname);\n\n    test_type_symbol();\n    test_symbol();\n    test_nocand_symbol();\n\n    fclose(fd);\n\n    return exit_status();\n}",
        "begin_line": 420,
        "end_line": 442,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_default_value#40",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_default_value()",
        "snippet": "void test_default_value()\n{\n    int *select_key;\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    select_key = chewing_get_selKey(ctx);\n    ok(select_key, \"chewing_get_selKey shall not return NULL\");\n    ok(!memcmp(select_key, DEFAULT_SELECT_KEY,\n               sizeof(DEFAULT_SELECT_KEY)), \"default select key shall be default value\");\n    chewing_free(select_key);\n\n    ok(chewing_get_candPerPage(ctx) == DEFAULT_CAND_PER_PAGE, \"default candPerPage shall be %d\", DEFAULT_CAND_PER_PAGE);\n\n    ok(chewing_get_maxChiSymbolLen(ctx) == MAX_CHI_SYMBOL_LEN,\n       \"default maxChiSymbolLen shall be %d\", MAX_CHI_SYMBOL_LEN);\n\n    ok(chewing_get_addPhraseDirection(ctx) == 0, \"default addPhraseDirection shall be 0\");\n\n    ok(chewing_get_spaceAsSelection(ctx) == 0, \"default spaceAsSelection shall be 0\");\n\n    ok(chewing_get_escCleanAllBuf(ctx) == 0, \"default escCleanAllBuf shall be 0\");\n\nBEGIN_IGNORE_DEPRECATIONS\n    ok(chewing_get_hsuSelKeyType(ctx) == 0, \"default hsuSelKeyType shall be 0\");\nEND_IGNORE_DEPRECATIONS\n\n    ok(chewing_get_autoShiftCur(ctx) == 0, \"default autoShiftCur shall be 0\");\n\n    ok(chewing_get_easySymbolInput(ctx) == 0, \"default easySymbolInput shall be 0\");\n\n    ok(chewing_get_phraseChoiceRearward(ctx) == 0, \"default phraseChoiceRearward shall be 0\");\n\n    ok(chewing_get_ChiEngMode(ctx) == CHINESE_MODE, \"default ChiEngMode shall be CHINESE_MODE\");\n\n    ok(chewing_get_ShapeMode(ctx) == HALFSHAPE_MODE, \"default ShapeMode shall be HALFSHAPE_MODE\");\n\n    chewing_delete(ctx);\n}",
        "begin_line": 40,
        "end_line": 80,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_candPerPage#82",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_candPerPage()",
        "snippet": "void test_set_candPerPage()\n{\n    const int VALUE[] = {\n        MIN_CAND_PER_PAGE,\n        MAX_CAND_PER_PAGE,\n    };\n\n    const int INVALID_VALUE[] = {\n        MIN_CAND_PER_PAGE - 1,\n        MAX_CAND_PER_PAGE + 1,\n    };\n\n    ChewingContext *ctx;\n    size_t i;\n    size_t j;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    for (i = 0; i < ARRAY_SIZE(VALUE); ++i) {\n        chewing_set_candPerPage(ctx, VALUE[i]);\n        ok(chewing_get_candPerPage(ctx) == VALUE[i], \"candPerPage shall be `%d'\", VALUE[i]);\n\n        for (j = 0; j < ARRAY_SIZE(INVALID_VALUE); ++j) {\n            // mode shall not change when set mode has invalid value.\n            chewing_set_candPerPage(ctx, INVALID_VALUE[j]);\n            ok(chewing_get_candPerPage(ctx) == VALUE[i], \"candPerPage shall be `%d'\", VALUE[i]);\n        }\n    }\n\n    chewing_delete(ctx);\n}",
        "begin_line": 82,
        "end_line": 113,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_maxChiSymbolLen#115",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_maxChiSymbolLen()",
        "snippet": "void test_set_maxChiSymbolLen()\n{\n    ChewingContext *ctx;\n    int i;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_maxChiSymbolLen(ctx, 16);\n    ok(chewing_get_maxChiSymbolLen(ctx) == 16, \"maxChiSymbolLen shall be 16\");\n\n    chewing_set_maxChiSymbolLen(ctx, MIN_CHI_SYMBOL_LEN - 1);\n    ok(chewing_get_maxChiSymbolLen(ctx) == 16,\n       \"maxChiSymbolLen shall not change when set to %d\", MIN_CHI_SYMBOL_LEN - 1);\n\n    chewing_set_maxChiSymbolLen(ctx, MAX_CHI_SYMBOL_LEN + 1);\n    ok(chewing_get_maxChiSymbolLen(ctx) == 16,\n       \"maxChiSymbolLen shall not change when set to %d\", MAX_CHI_SYMBOL_LEN + 1);\n\n\n    // Test auto commit\n    chewing_set_maxChiSymbolLen(ctx, MAX_CHI_SYMBOL_LEN);\n\n    // In boundary\n    for (i = 0; i < MAX_CHI_SYMBOL_LEN; ++i)\n        type_keystroke_by_string(ctx, \"hk4\");\n    ok(chewing_commit_Check(ctx) == 0,\n       \"auto commit shall not be triggered when entering %d symbols\", MAX_CHI_SYMBOL_LEN);\n\n    // Out of boundary\n    type_keystroke_by_string(ctx, \"hk4\");\n    ok(chewing_commit_Check(ctx) == 1,\n       \"auto commit shall be triggered when entering %d symbols\", MAX_CHI_SYMBOL_LEN + 1);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 115,
        "end_line": 150,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_maxChiSymbolLen#152",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_maxChiSymbolLen()",
        "snippet": "void test_maxChiSymbolLen()\n{\n    ChewingContext *ctx;\n    int i;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_maxChiSymbolLen(ctx, MAX_CHI_SYMBOL_LEN);\n\n    for (i = 0; i < MAX_CHI_SYMBOL_LEN; ++i) {\n        type_keystroke_by_string(ctx, \"hk4\");\n    }\n\n    // Use easy symbol 'Orz' as last input for worst case scenario.\n    chewing_set_easySymbolInput(ctx, 1);\n    type_keystroke_by_string(ctx, \"L\");\n\n    chewing_delete(ctx);\n}",
        "begin_line": 152,
        "end_line": 171,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_selKey_normal#173",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_selKey_normal()",
        "snippet": "void test_set_selKey_normal()\n{\n    ChewingContext *ctx;\n    int *select_key;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    // XXX: chewing_set_selKey shall accept const char *.\n    chewing_set_selKey(ctx, ALTERNATE_SELECT_KEY, ARRAY_SIZE(ALTERNATE_SELECT_KEY));\n    select_key = chewing_get_selKey(ctx);\n    ok(select_key, \"chewing_get_selKey shall not return NULL\");\n    ok(!memcmp(select_key, ALTERNATE_SELECT_KEY,\n               sizeof(ALTERNATE_SELECT_KEY)), \"select key shall be ALTERNATE_SELECT_KEY\");\n\n    type_keystroke_by_string(ctx, DATA.token);\n    ok_preedit_buffer(ctx, DATA.expected);\n\n    chewing_free(select_key);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 173,
        "end_line": 194,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_selKey_error_handling#196",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_selKey_error_handling()",
        "snippet": "void test_set_selKey_error_handling()\n{\n    ChewingContext *ctx;\n    int *select_key;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_selKey(NULL, ALTERNATE_SELECT_KEY, ARRAY_SIZE(ALTERNATE_SELECT_KEY));\n    select_key = chewing_get_selKey(ctx);\n    ok(select_key, \"chewing_get_selKey shall not return NULL\");\n    ok(!memcmp(select_key, DEFAULT_SELECT_KEY, sizeof(DEFAULT_SELECT_KEY)), \"select key shall be DEFAULT_SELECT_KEY\");\n    chewing_free(select_key);\n\n    chewing_set_selKey(ctx, NULL, ARRAY_SIZE(ALTERNATE_SELECT_KEY));\n    select_key = chewing_get_selKey(ctx);\n    ok(select_key, \"chewing_get_selKey shall not return NULL\");\n    ok(!memcmp(select_key, DEFAULT_SELECT_KEY, sizeof(DEFAULT_SELECT_KEY)), \"select key shall be DEFAULT_SELECT_KEY\");\n    chewing_free(select_key);\n\n    chewing_set_selKey(ctx, ALTERNATE_SELECT_KEY, 0);\n    select_key = chewing_get_selKey(ctx);\n    ok(select_key, \"chewing_get_selKey shall not return NULL\");\n    ok(!memcmp(select_key, DEFAULT_SELECT_KEY, sizeof(DEFAULT_SELECT_KEY)), \"select key shall be DEFAULT_SELECT_KEY\");\n    chewing_free(select_key);\n\n    chewing_set_selKey(ctx, ALTERNATE_SELECT_KEY, 11);\n    select_key = chewing_get_selKey(ctx);\n    ok(select_key, \"chewing_get_selKey shall not return NULL\");\n    ok(!memcmp(select_key, DEFAULT_SELECT_KEY, sizeof(DEFAULT_SELECT_KEY)), \"select key shall be DEFAULT_SELECT_KEY\");\n    chewing_free(select_key);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 196,
        "end_line": 229,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_selKey#231",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_selKey()",
        "snippet": "void test_set_selKey()\n{\n    test_set_selKey_normal();\n    test_set_selKey_error_handling();\n}",
        "begin_line": 231,
        "end_line": 235,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_addPhraseDirection#237",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_addPhraseDirection()",
        "snippet": "void test_set_addPhraseDirection()\n{\n    ChewingContext *ctx;\n    int value;\n    int mode;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    for (value = 0; value < 2; ++value) {\n        chewing_set_addPhraseDirection(ctx, value);\n        mode = chewing_get_addPhraseDirection(ctx);\n        ok(mode == value, \"addPhraseDirection `%d' shall be `%d'\", mode, value);\n\n        chewing_set_addPhraseDirection(ctx, -1);\n        mode = chewing_get_addPhraseDirection(ctx);\n        ok(mode == value, \"addPhraseDirection `%d' shall be `%d'\", mode, value);\n\n        chewing_set_addPhraseDirection(ctx, 2);\n        mode = chewing_get_addPhraseDirection(ctx);\n        ok(mode == value, \"addPhraseDirection `%d' shall be `%d'\", mode, value);\n    }\n\n    chewing_delete(ctx);\n}",
        "begin_line": 237,
        "end_line": 261,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_spaceAsSelection#263",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_spaceAsSelection()",
        "snippet": "void test_set_spaceAsSelection()\n{\n    ChewingContext *ctx;\n    int value;\n    int mode;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    for (value = 0; value < 2; ++value) {\n        chewing_set_spaceAsSelection(ctx, value);\n        mode = chewing_get_spaceAsSelection(ctx);\n        ok(mode == value, \"spaceAsSelection `%d' shall be `%d'\", mode, value);\n\n        chewing_set_spaceAsSelection(ctx, -1);\n        mode = chewing_get_spaceAsSelection(ctx);\n        ok(mode == value, \"spaceAsSelection `%d' shall be `%d'\", mode, value);\n\n        chewing_set_spaceAsSelection(ctx, 2);\n        mode = chewing_get_spaceAsSelection(ctx);\n        ok(mode == value, \"spaceAsSelection `%d' shall be `%d'\", mode, value);\n    }\n\n    chewing_delete(ctx);\n}",
        "begin_line": 263,
        "end_line": 287,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_escCleanAllBuf#289",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_escCleanAllBuf()",
        "snippet": "void test_set_escCleanAllBuf()\n{\n    ChewingContext *ctx;\n    int value;\n    int mode;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    for (value = 0; value < 2; ++value) {\n        chewing_set_escCleanAllBuf(ctx, value);\n        mode = chewing_get_escCleanAllBuf(ctx);\n        ok(mode == value, \"escCleanAllBuf shall be `%d'\", value);\n\n        chewing_set_escCleanAllBuf(ctx, -1);\n        mode = chewing_get_escCleanAllBuf(ctx);\n        ok(mode == value, \"escCleanAllBuf shall be `%d'\", value);\n\n        chewing_set_escCleanAllBuf(ctx, 2);\n        mode = chewing_get_escCleanAllBuf(ctx);\n        ok(mode == value, \"escCleanAllBuf shall be `%d'\", value);\n    }\n\n    chewing_delete(ctx);\n}",
        "begin_line": 289,
        "end_line": 313,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_autoShiftCur#315",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_autoShiftCur()",
        "snippet": "void test_set_autoShiftCur()\n{\n    ChewingContext *ctx;\n    int value;\n    int mode;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    for (value = 0; value < 2; ++value) {\n        chewing_set_autoShiftCur(ctx, value);\n        mode = chewing_get_autoShiftCur(ctx);\n        ok(mode == value, \"autoShiftCur shall be `%d'\", value);\n\n        chewing_set_autoShiftCur(ctx, -1);\n        mode = chewing_get_autoShiftCur(ctx);\n        ok(mode == value, \"autoShiftCur shall be `%d'\", value);\n\n        chewing_set_autoShiftCur(ctx, 2);\n        mode = chewing_get_autoShiftCur(ctx);\n        ok(mode == value, \"autoShiftCur shall be `%d'\", value);\n    }\n\n    chewing_delete(ctx);\n}",
        "begin_line": 315,
        "end_line": 339,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_easySymbolInput#341",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_easySymbolInput()",
        "snippet": "void test_set_easySymbolInput()\n{\n    ChewingContext *ctx;\n    int value;\n    int mode;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    for (value = 0; value < 2; ++value) {\n        chewing_set_easySymbolInput(ctx, value);\n        mode = chewing_get_easySymbolInput(ctx);\n        ok(mode == value, \"easySymbolInput `%d', shall be `%d'\", mode, value);\n\n        chewing_set_easySymbolInput(ctx, -1);\n        mode = chewing_get_easySymbolInput(ctx);\n        ok(mode == value, \"easySymbolInput `%d', shall be `%d'\", mode, value);\n\n        chewing_set_easySymbolInput(ctx, 2);\n        mode = chewing_get_easySymbolInput(ctx);\n        ok(mode == value, \"easySymbolInput `%d', shall be `%d'\", mode, value);\n    }\n\n    chewing_delete(ctx);\n}",
        "begin_line": 341,
        "end_line": 365,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_phraseChoiceRearward#367",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_phraseChoiceRearward()",
        "snippet": "void test_set_phraseChoiceRearward()\n{\n    ChewingContext *ctx;\n    int value;\n    int mode;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    for (value = 0; value < 2; ++value) {\n        chewing_set_phraseChoiceRearward(ctx, value);\n        mode = chewing_get_phraseChoiceRearward(ctx);\n        ok(mode == value, \"phraseChoiceRearward `%d' shall be `%d'\", mode, value);\n\n        chewing_set_phraseChoiceRearward(ctx, -1);\n        mode = chewing_get_phraseChoiceRearward(ctx);\n        ok(mode == value, \"phraseChoiceRearward `%d' shall be `%d'\", mode, value);\n\n        chewing_set_phraseChoiceRearward(ctx, 2);\n        mode = chewing_get_phraseChoiceRearward(ctx);\n        ok(mode == value, \"phraseChoiceRearward `%d' shall be `%d'\", mode, value);\n    }\n\n    chewing_delete(ctx);\n}",
        "begin_line": 367,
        "end_line": 391,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_ChiEngMode#393",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_ChiEngMode()",
        "snippet": "void test_set_ChiEngMode()\n{\n    const int VALUE[] = {\n        CHINESE_MODE,\n        SYMBOL_MODE,\n    };\n\n    const int INVALID_VALUE[] = {\n        -1,\n        2,\n    };\n\n    ChewingContext *ctx;\n    size_t i;\n    size_t j;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    for (i = 0; i < ARRAY_SIZE(VALUE); ++i) {\n        chewing_set_ChiEngMode(ctx, VALUE[i]);\n        ok(chewing_get_ChiEngMode(ctx) == VALUE[i], \"ChiEngMode shall be `%d'\", VALUE[i]);\n\n        for (j = 0; j < ARRAY_SIZE(INVALID_VALUE); ++j) {\n            // mode shall not change when set mode has invalid value.\n            chewing_set_ChiEngMode(ctx, INVALID_VALUE[j]);\n            ok(chewing_get_ChiEngMode(ctx) == VALUE[i], \"ChiEngMode shall be `%d'\", VALUE[i]);\n        }\n    }\n\n    chewing_delete(ctx);\n}",
        "begin_line": 393,
        "end_line": 424,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_ShapeMode#426",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_ShapeMode()",
        "snippet": "void test_set_ShapeMode()\n{\n    const int VALUE[] = {\n        HALFSHAPE_MODE,\n        FULLSHAPE_MODE,\n    };\n\n    const int INVALID_VALUE[] = {\n        -1,\n        2,\n    };\n\n    ChewingContext *ctx;\n    size_t i;\n    size_t j;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    for (i = 0; i < ARRAY_SIZE(VALUE); ++i) {\n        chewing_set_ShapeMode(ctx, VALUE[i]);\n        ok(chewing_get_ShapeMode(ctx) == VALUE[i], \"ShapeMode shall be `%d'\", VALUE[i]);\n\n        for (j = 0; j < ARRAY_SIZE(INVALID_VALUE); ++j) {\n            // mode shall not change when set mode has invalid value.\n            chewing_set_ShapeMode(ctx, INVALID_VALUE[j]);\n            ok(chewing_get_ShapeMode(ctx) == VALUE[i], \"ShapeMode shall be `%d'\", VALUE[i]);\n        }\n    }\n\n    chewing_delete(ctx);\n}",
        "begin_line": 426,
        "end_line": 457,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_autoLearn#459",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_autoLearn()",
        "snippet": "void test_set_autoLearn()\n{\n    const int VALUE[] = {\n        AUTOLEARN_ENABLED,\n        AUTOLEARN_DISABLED,\n    };\n\n    const int INVALID_VALUE[] = {\n        -1,\n        2,\n    };\n\n    ChewingContext *ctx;\n    size_t i;\n    size_t j;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    for (i = 0; i < ARRAY_SIZE(VALUE); ++i) {\n        chewing_set_autoLearn(ctx, VALUE[i]);\n        ok(chewing_get_autoLearn(ctx) == VALUE[i], \"AutoLearn shall be `%d'\", VALUE[i]);\n\n        for (j = 0; j < ARRAY_SIZE(INVALID_VALUE); ++j) {\n            // mode shall not change when set mode has invalid value.\n            chewing_set_autoLearn(ctx, INVALID_VALUE[j]);\n            ok(chewing_get_autoLearn(ctx) == VALUE[i], \"AutoLearn shall be `%d'\", VALUE[i]);\n        }\n    }\n\n    chewing_delete(ctx);\n}",
        "begin_line": 459,
        "end_line": 490,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_deprecated#492",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_deprecated()",
        "snippet": "void test_deprecated()\n{\n    ChewingContext *ctx;\n    int type;\n    ChewingConfigData configure;\n\n    memset(&configure, 0, sizeof(ChewingConfigData));\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\nBEGIN_IGNORE_DEPRECATIONS\n    chewing_set_hsuSelKeyType(ctx, HSU_SELKEY_TYPE1);\n    type = chewing_get_hsuSelKeyType(ctx);\n    ok(type == 0, \"`%d' shall be `%d'\", type, 0);\n\n    chewing_Configure(ctx, &configure);\nEND_IGNORE_DEPRECATIONS\n\n    chewing_delete(ctx);\n}",
        "begin_line": 492,
        "end_line": 512,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_new2_syspath_alternative#514",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_new2_syspath_alternative()",
        "snippet": "void test_new2_syspath_alternative()\n{\n    ChewingContext *ctx;\n\n    printf(\"#\\n# %s\\n#\\n\", __func__);\n    fprintf(fd, \"#\\n# %s\\n#\\n\", __func__);\n\n    ctx = chewing_new2(TEST_DATA_DIR, NULL, logger, fd);\n    ok(ctx != NULL, \"chewing_new2 returns `%#p' shall not be `%#p'\", ctx, NULL);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 514,
        "end_line": 525,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_new2_syspath_error#527",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_new2_syspath_error()",
        "snippet": "void test_new2_syspath_error()\n{\n    ChewingContext *ctx;\n\n    printf(\"#\\n# %s\\n#\\n\", __func__);\n    fprintf(fd, \"#\\n# %s\\n#\\n\", __func__);\n\n    ctx = chewing_new2(\"NoSuchPath\", NULL, logger, fd);\n    ok(ctx == NULL, \"chewing_new2 returns `%#p' shall be `%#p'\", ctx, NULL);\n}",
        "begin_line": 527,
        "end_line": 536,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_new2_syspath#538",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_new2_syspath()",
        "snippet": "void test_new2_syspath()\n{\n    test_new2_syspath_alternative();\n    test_new2_syspath_error();\n}",
        "begin_line": 538,
        "end_line": 542,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_new2_userpath_alternative#544",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_new2_userpath_alternative()",
        "snippet": "void test_new2_userpath_alternative()\n{\n    ChewingContext *ctx;\n\n    printf(\"#\\n# %s\\n#\\n\", __func__);\n    fprintf(fd, \"#\\n# %s\\n#\\n\", __func__);\n\n    ctx = chewing_new2(NULL, TEST_HASH_DIR \"/test.sqlite3\", logger, fd);\n    ok(ctx != NULL, \"chewing_new2 returns `%#p' shall not be `%#p'\", ctx, NULL);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 544,
        "end_line": 555,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_new2_userpath_error#557",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_new2_userpath_error()",
        "snippet": "void test_new2_userpath_error()\n{\n    ChewingContext *ctx;\n\n    printf(\"#\\n# %s\\n#\\n\", __func__);\n    fprintf(fd, \"#\\n# %s\\n#\\n\", __func__);\n\n    ctx = chewing_new2(NULL, TEST_HASH_DIR, logger, fd);\n    ok(ctx == NULL, \"chewing_new2 returns `%#p' shall be `%#p'\", ctx, NULL);\n}",
        "begin_line": 557,
        "end_line": 566,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_new2_userpath#568",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_new2_userpath()",
        "snippet": "void test_new2_userpath()\n{\n    test_new2_userpath_alternative();\n    test_new2_userpath_error();\n}",
        "begin_line": 568,
        "end_line": 572,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_new2#574",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_new2()",
        "snippet": "void test_new2()\n{\n    test_new2_syspath();\n    test_new2_userpath();\n}",
        "begin_line": 574,
        "end_line": 578,
        "is_bug": false
    },
    {
        "name": "test.test-config.main#580",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    char *logname;\n    int ret;\n\n    putenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n    putenv(\"CHEWING_USER_PATH=\" TEST_HASH_DIR);\n\n    ret = asprintf(&logname, \"%s.log\", argv[0]);\n    if (ret == -1)\n        return -1;\n    fd = fopen(logname, \"w\");\n    assert(fd);\n    free(logname);\n\n\n    test_default_value();\n\n    test_set_candPerPage();\n    test_set_maxChiSymbolLen();\n    test_maxChiSymbolLen();\n    test_set_selKey();\n    test_set_addPhraseDirection();\n    test_set_spaceAsSelection();\n    test_set_escCleanAllBuf();\n    test_set_autoShiftCur();\n    test_set_easySymbolInput();\n    test_set_phraseChoiceRearward();\n    test_set_ChiEngMode();\n    test_set_ShapeMode();\n    test_set_autoLearn();\n\n    test_deprecated();\n\n    test_new2();\n\n    fclose(fd);\n\n    return exit_status();\n}",
        "begin_line": 580,
        "end_line": 619,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_no_rearward#28",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_no_rearward()",
        "snippet": "void test_select_candidate_no_rearward()\n{\n    /*\n     * The following phrases are in dict\n     * \u4e00\u4e0a\u4f86\n     * \u4e0a\u4f86\n     * \u79fb\u4e0a\u4f86\n     * \u79fb\u4e0a\n     */\n\n    static const char *CAND_1[] = {\n        \"\\xE4\\xB8\\x80\\xE4\\xB8\\x8A\\xE4\\xBE\\x86\" /* \u4e00\u4e0a\u4f86 */ ,\n        \"\\xE7\\xA7\\xBB\\xE4\\xB8\\x8A\\xE4\\xBE\\x86\" /* \u79fb\u4e0a\u4f86 */ ,\n    };\n\n    static const char *CAND_2[] = {\n        \"\\xE7\\xA7\\xBB\\xE4\\xB8\\x8A\" /* \u79fb\u4e0a */ ,\n    };\n\n    ChewingContext *ctx;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_maxChiSymbolLen(ctx, 16);\n\n    type_keystroke_by_string(ctx, \"u6g;4x96<L><L><L>\"); /* \u3127\u02ca\u3115\u3124\u02cb\u310c\u311e\u02ca */\n\n    type_keystroke_by_string(ctx, \"<D>\");       /* \u3127\u02ca\u3115\u3124\u02cb\u310c\u311e\u02ca */\n    ok_candidate(ctx, CAND_1, ARRAY_SIZE(CAND_1));\n\n    type_keystroke_by_string(ctx, \"<D>\");       /* \u3115\u3124\u02cb\u310c\u311e\u02ca */\n    ok_candidate(ctx, CAND_2, ARRAY_SIZE(CAND_2));\n\n    type_keystroke_by_string(ctx, \"<D><D>2<E>\");        /* select \u79fb\u4e0a\u4f86 */\n    ok_commit_buffer(ctx, CAND_1[1]);\n\n    chewing_delete(ctx);\n}\n\nvoid test_select_candidate_rearward()\n{\n    /*\n     * The following phrases ",
        "begin_line": 28,
        "end_line": 68,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_rearward#70",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_rearward()",
        "snippet": "void test_select_candidate_rearward()\n{\n    /*\n     * The following phrases are in dict\n     * \u4e00\u4e0a\u4f86\n     * \u4e0a\u4f86\n     * \u79fb\u4e0a\u4f86\n     * \u79fb\u4e0a\n     */\n\n    static const char *CAND_1[] = {\n        \"\\xE4\\xB8\\x80\\xE4\\xB8\\x8A\\xE4\\xBE\\x86\" /* \u4e00\u4e0a\u4f86 */ ,\n        \"\\xE7\\xA7\\xBB\\xE4\\xB8\\x8A\\xE4\\xBE\\x86\" /* \u79fb\u4e0a\u4f86 */ ,\n    };\n\n    static const char *CAND_2[] = {\n        \"\\xE4\\xB8\\x8A\\xE4\\xBE\\x86\" /* \u4e0a\u4f86 */ ,\n    };\n    ChewingContext *ctx;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_maxChiSymbolLen(ctx, 16);\n    chewing_set_phraseChoiceRearward(ctx, 1);\n\n    type_keystroke_by_string(ctx, \"u6g;4x96\");  /* \u3127\u02ca\u3115\u3124\u02cb\u310c\u311e\u02ca */\n    ok_preedit_buffer(ctx, CAND_1[0]);\n\n    type_keystroke_by_string(ctx, \"<D>\");       /* \u3127\u02ca\u3115\u3124\u02cb\u310c\u311e\u02ca */\n    ok_candidate(ctx, CAND_1, ARRAY_SIZE(CAND_1));\n\n    type_keystroke_by_string(ctx, \"<D>\");       /* \u3115\u3124\u02cb\u310c\u311e\u02ca */\n    ok_candidate(ctx, CAND_2, ARRAY_SIZE(CAND_2));\n\n    type_keystroke_by_string(ctx, \"<D><D>2<E>\");        /* select \u79fb\u4e0a\u4f86 */\n    ok_commit_buffer(ctx, CAND_1[1]);\n\n    chewing_delete(ctx);\n}\n\nvoid test_select_candidate_no_rearward_with_symbol()\n{\n    ChewingContext *c",
        "begin_line": 70,
        "end_line": 111,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_no_rearward_with_symbol#113",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_no_rearward_with_symbol()",
        "snippet": "void test_select_candidate_no_rearward_with_symbol()\n{\n    ChewingContext *ctx;\n    int ret;\n    char *buf;\n    int len;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"hk4g4`31u6vu84\" /* \u6e2c\u8a66\uff0c\u4e00\u4e0b */ );\n\n    type_keystroke_by_string(ctx, \"<EE><H><D>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 0);\n    chewing_cand_Enumerate(ctx);\n    buf = chewing_cand_String(ctx);\n    len = ueStrLen(buf);\n    ok(len == 2, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 2, 0);\n    chewing_free(buf);\n\n    type_keystroke_by_string(ctx, \"<EE><H><R><D>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 1);\n    chewing_cand_Enumerate(ctx);\n    buf = chewing_cand_String(ctx);\n    len = ueStrLen(buf);\n    ok(len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 1);\n    chewing_free(buf);\n\n    type_keystroke_by_string(ctx, \"<EE><H><R><R><D>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 2);\n    chewing_cand_Enumerate(ctx);\n    buf = chewing_cand_String(ctx);\n    len = ueStrLen(buf);\n    ok(len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 2);\n    chewing_free(buf);\n\n    type_keystroke_by_string(ctx, \"<EE><H><R><R><R><D>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 3);\n    chewing_cand_Enumerate(ctx);\n    buf = chewing_cand_String(ctx);\n    len = ueStrLen(buf);\n    ok(len == 2, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 2, 3);\n    chewing_free(buf);\n\n    type_keystroke_by_string(ctx, \"<EE><H><R><R><R><R><D>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 4);\n    chewing_cand_Enumerate(ctx);\n    buf = chewing_cand_String(ctx);\n    len = ueStrLen(buf);\n    ok(len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 4);\n    chewing_free(buf);\n\n    chewing_delete(ctx);\n}\n\nvoid tes",
        "begin_line": 113,
        "end_line": 173,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_rearward_with_symbol#175",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_rearward_with_symbol()",
        "snippet": "void test_select_candidate_rearward_with_symbol()\n{\n    ChewingContext *ctx;\n    int ret;\n    char *buf;\n    int len;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_phraseChoiceRearward(ctx, 1);\n\n    type_keystroke_by_string(ctx, \"hk4g4`31u6vu84\" /* \u6e2c\u8a66\uff0c\u4e00\u4e0b */ );\n\n    type_keystroke_by_string(ctx, \"<EE><H><D>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 0);\n    chewing_cand_Enumerate(ctx);\n    buf = chewing_cand_String(ctx);\n    len = ueStrLen(buf);\n    ok(len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 0);\n    chewing_free(buf);\n\n    type_keystroke_by_string(ctx, \"<EE><H><R><D>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 1);\n    chewing_cand_Enumerate(ctx);\n    buf = chewing_cand_String(ctx);\n    len = ueStrLen(buf);\n    ok(len == 2, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 2, 1);\n    chewing_free(buf);\n\n    type_keystroke_by_string(ctx, \"<EE><H><R><R><D>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 2);\n    chewing_cand_Enumerate(ctx);\n    buf = chewing_cand_String(ctx);\n    len = ueStrLen(buf);\n    ok(len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 2);\n    chewing_free(buf);\n\n    type_keystroke_by_string(ctx, \"<EE><H><R><R><R><D>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 3);\n    chewing_cand_Enumerate(ctx);\n    buf = chewing_cand_String(ctx);\n    len = ueStrLen(buf);\n    ok(len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 3);\n    chewing_free(buf);\n\n    type_keystroke_by_string(ctx, \"<EE><H><R><R><R><R><D>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 4);\n    chewing_cand_Enumerate(ctx);\n    buf = chewing_cand_String(ctx);\n    len = ueStrLen(buf);\n    ok(len == 2, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 2, 4);\n    chewing_free(buf);\n\n    chewing_delete(ctx);\n}\n\nvoid tes",
        "begin_line": 175,
        "end_line": 236,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_no_rearward_start_with_symbol#238",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_no_rearward_start_with_symbol()",
        "snippet": "void test_select_candidate_no_rearward_start_with_symbol()\n{\n    ChewingContext *ctx;\n    int ret;\n    char *buf;\n    int len;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"`31hk4g4\" /* \uff0c\u6e2c\u8a66 */ );\n\n    type_keystroke_by_string(ctx, \"<EE><H><D>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 0);\n    chewing_cand_Enumerate(ctx);\n    buf = chewing_cand_String(ctx);\n    len = ueStrLen(buf);\n    ok(len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 0);\n    chewing_free(buf);\n\n    type_keystroke_by_string(ctx, \"<EE><H><R><D>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 1);\n    chewing_cand_Enumerate(ctx);\n    buf = chewing_cand_String(ctx);\n    len = ueStrLen(buf);\n    ok(len == 2, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 2, 1);\n    chewing_free(buf);\n\n    type_keystroke_by_string(ctx, \"<EE><H><R><R><D>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 2);\n    chewing_cand_Enumerate(ctx);\n    buf = chewing_cand_String(ctx);\n    len = ueStrLen(buf);\n    ok(len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 2);\n    chewing_free(buf);\n\n    chewing_delete(ctx);\n}\n\nvoid",
        "begin_line": 238,
        "end_line": 280,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_rearward_start_with_symbol#282",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_rearward_start_with_symbol()",
        "snippet": "void test_select_candidate_rearward_start_with_symbol()\n{\n    ChewingContext *ctx;\n    int ret;\n    char *buf;\n    int len;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_phraseChoiceRearward(ctx, 1);\n\n    type_keystroke_by_string(ctx, \"`31hk4g4\" /* \uff0c\u6e2c\u8a66 */ );\n\n    type_keystroke_by_string(ctx, \"<EE><H><D>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 0);\n    chewing_cand_Enumerate(ctx);\n    buf = chewing_cand_String(ctx);\n    len = ueStrLen(buf);\n    ok(len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 0);\n    chewing_free(buf);\n\n    type_keystroke_by_string(ctx, \"<EE><H><R><D>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 1);\n    chewing_cand_Enumerate(ctx);\n    buf = chewing_cand_String(ctx);\n    len = ueStrLen(buf);\n    ok(len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 1);\n    chewing_free(buf);\n\n    type_keystroke_by_string(ctx, \"<EE><H><R><R><D>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 2);\n    chewing_cand_Enumerate(ctx);\n    buf = chewing_cand_String(ctx);\n    len = ueStrLen(buf);\n    ok(len == 2, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 2, 2);\n    chewing_free(buf);\n\n    chewing_delete(ctx);\n}\n\nvoid",
        "begin_line": 282,
        "end_line": 325,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_del_bopomofo_as_mode_switch#327",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_del_bopomofo_as_mode_switch()",
        "snippet": "void test_del_bopomofo_as_mode_switch()\n{\n    ChewingContext *ctx;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"2k\");        /* \u3109\u311c */\n    ok_bopomofo_buffer(ctx, \"\\xe3\\x84\\x89\\xe3\\x84\\x9c\" /* \u3109\u311c */ );\n    ok_preedit_buffer(ctx, \"\");\n    chewing_set_ChiEngMode(ctx, SYMBOL_MODE);\n    ok_bopomofo_buffer(ctx, \"\");\n    ok_preedit_buffer(ctx, \"\");\n\n    chewing_set_ChiEngMode(ctx, CHINESE_MODE);\n\n    type_keystroke_by_string(ctx, \"ji\");        /* \u3128\u311b */\n    ok_bopomofo_buffer(ctx, \"\\xe3\\x84\\xa8\\xe3\\x84\\x9b\" /* \u3128\u311b */ );\n    ok_preedit_buffer(ctx, \"\");\n    chewing_set_ChiEngMode(ctx, SYMBOL_MODE);\n    ok_bopomofo_buffer(ctx, \"\");\n    ok_preedit_buffer(ctx, \"\");\n\n    chewing_delete(ctx);\n}\n\nvoid test_sele",
        "begin_line": 327,
        "end_line": 353,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_4_bytes_utf8#355",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_4_bytes_utf8()",
        "snippet": "void test_select_candidate_4_bytes_utf8()\n{\n    ChewingContext *ctx;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n    chewing_set_phraseChoiceRearward(ctx, 1);\n    chewing_set_autoShiftCur(ctx, 1);\n\n    type_keystroke_by_string(ctx, \"2k62k6\");    /* \u3109\u311c\u02ca \u3109\u311c\u02ca */\n    ok_preedit_buffer(ctx, \"\\xE5\\xBE\\x97\\xE5\\xBE\\x97\" /* \u5f97\u5f97 */ );\n\n    type_keystroke_by_string(ctx, \"<H>\");\n\n    type_keystroke_by_string(ctx, \"<D>8\");\n    ok_preedit_buffer(ctx, \"\\xF0\\xA2\\x94\\xA8\\xE5\\xBE\\x97\" /* \ud849\udd28\u5f97 */ );\n\n    type_keystroke_by_string(ctx, \"<D>8\");\n\n    ok_preedit_buffer(ctx, \"\\xF0\\xA2\\x94\\xA8\\xF0\\xA2\\x94\\xA8\" /* \ud849\udd28\ud849\udd28 */ );\n\n    chewing_delete(ctx);\n}\n\nvoid test_select_candid",
        "begin_line": 355,
        "end_line": 380,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_in_middle_no_reaward#382",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_in_middle_no_reaward()",
        "snippet": "void test_select_candidate_in_middle_no_reaward()\n{\n    ChewingContext *ctx;\n    int ret;\n    const char *cand;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"hk4g4u6<L><L>\" /* \u6e2c\u8a66\u5100*/);\n\n    ret = chewing_cand_open(ctx);\n    ok(ret == 0, \"chewing_cand_open return %d shall be %d\", ret, 0);\n\n    cand = chewing_cand_string_by_index_static(ctx, 0);\n    ok(strcmp(cand, \"\\xE9\\x81\\xA9\\xE5\\xAE\\x9C\") == 0, \"first candidate `%s' shall be `%s'\", cand, \"\\xE9\\x81\\xA9\\xE5\\xAE\\x9C\" /* \u9069\u5b9c */);\n\n    ret = chewing_cand_list_next(ctx);\n    ok(ret == 0, \"chewing_cand_list_next return %d shall be %d\", ret, 0);\n\n    cand = chewing_cand_string_by_index_static(ctx, 0);\n    ok(strcmp(cand, \"\\xE5\\xB8\\x82\") == 0, \"first candidate `%s' shall be `%s'\", cand, \"\\xE5\\xB8\\x82\" /* \u5e02 */);\n\n    chewing_delete(ctx);\n}\n\nvoid test_",
        "begin_line": 382,
        "end_line": 408,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_in_middle_reaward#410",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_in_middle_reaward()",
        "snippet": "void test_select_candidate_in_middle_reaward()\n{\n    ChewingContext *ctx;\n    int ret;\n    const char *cand;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_phraseChoiceRearward(ctx, 1);\n\n    type_keystroke_by_string(ctx, \"hk4g4u6<L><L>\" /* \u6e2c\u8a66\u5100*/);\n\n    ret = chewing_cand_open(ctx);\n    ok(ret == 0, \"chewing_cand_open return %d shall be %d\", ret, 0);\n\n    cand = chewing_cand_string_by_index_static(ctx, 0);\n    ok(strcmp(cand, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\") == 0, \"first candidate `%s' shall be `%s'\", cand, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */);\n\n    ret = chewing_cand_list_next(ctx);\n    ok(ret == 0, \"chewing_cand_list_next return %d shall be %d\", ret, 0);\n\n    cand = chewing_cand_string_by_index_static(ctx, 0);\n    ok(strcmp(cand, \"\\xE5\\xB8\\x82\") == 0, \"first candidate `%s' shall be `%s'\", cand, \"\\xE5\\xB8\\x82\" /* \u5e02 */);\n\n    chewing_delete(ctx);\n}\n\nvoid test_",
        "begin_line": 410,
        "end_line": 437,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate#439",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate()",
        "snippet": "void test_select_candidate()\n{\n    test_select_candidate_no_rearward();\n    test_select_candidate_rearward();\n    test_select_candidate_no_rearward_with_symbol();\n    test_select_candidate_rearward_with_symbol();\n    test_select_candidate_no_rearward_start_with_symbol();\n    test_select_candidate_rearward_start_with_symbol();\n    test_select_candidate_4_bytes_utf8();\n    test_del_bopomofo_as_mode_switch();\n    test_select_candidate_in_middle_no_reaward();\n    test_select_candidate_in_middle_reaward();\n}",
        "begin_line": 439,
        "end_line": 451,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Esc_not_entering_chewing#453",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Esc_not_entering_chewing()",
        "snippet": "void test_Esc_not_entering_chewing()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    type_keystroke_by_string(ctx, \"<EE>\");\n    ok_keystroke_rtn(ctx, KEYSTROKE_IGNORE);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 453,
        "end_line": 463,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Esc_in_select#465",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Esc_in_select()",
        "snippet": "void test_Esc_in_select()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    type_keystroke_by_string(ctx, \"`<EE>\");\n    ok_candidate(ctx, NULL, 0);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 465,
        "end_line": 475,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Esc_entering_bopomofo#477",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Esc_entering_bopomofo()",
        "snippet": "void test_Esc_entering_bopomofo()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    type_keystroke_by_string(ctx, \"hk<EE>\");\n    ok_bopomofo_buffer(ctx, \"\");\n\n    chewing_delete(ctx);\n}",
        "begin_line": 477,
        "end_line": 487,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Esc_escCleanAllBuf#489",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Esc_escCleanAllBuf()",
        "snippet": "void test_Esc_escCleanAllBuf()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_escCleanAllBuf(ctx, 1);\n\n    type_keystroke_by_string(ctx, \"hk4g4<EE>\");\n    ok_bopomofo_buffer(ctx, \"\");\n    ok_preedit_buffer(ctx, \"\");\n    ok_commit_buffer(ctx, \"\");\n\n    chewing_delete(ctx);\n}",
        "begin_line": 489,
        "end_line": 503,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Esc#505",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Esc()",
        "snippet": "void test_Esc()\n{\n    test_Esc_not_entering_chewing();\n    test_Esc_in_select();\n    test_Esc_entering_bopomofo();\n    test_Esc_escCleanAllBuf();\n}",
        "begin_line": 505,
        "end_line": 511,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Del_not_entering_chewing#513",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Del_not_entering_chewing()",
        "snippet": "void test_Del_not_entering_chewing()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    type_keystroke_by_string(ctx, \"<DC>\");\n    ok_keystroke_rtn(ctx, KEYSTROKE_IGNORE);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 513,
        "end_line": 523,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Del_in_select#525",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Del_in_select()",
        "snippet": "void test_Del_in_select()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    type_keystroke_by_string(ctx, \"`<DC>\");\n    ok_keystroke_rtn(ctx, KEYSTROKE_ABSORB);    /* XXX: shall be ignore? */\n\n    chewing_delete(ctx);\n}",
        "begin_line": 525,
        "end_line": 535,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Del_word#537",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Del_word()",
        "snippet": "void test_Del_word()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n\n    type_keystroke_by_string(ctx, \"hk4u g4<L><L><DC><E>\");\n    ok_commit_buffer(ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ );\n\n    chewing_delete(ctx);\n}\n\nvo",
        "begin_line": 537,
        "end_line": 549,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Del#551",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Del()",
        "snippet": "void test_Del()\n{\n    test_Del_not_entering_chewing();\n    test_Del_in_select();\n    test_Del_word();\n}",
        "begin_line": 551,
        "end_line": 556,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Backspace_not_entering_chewing#558",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Backspace_not_entering_chewing()",
        "snippet": "void test_Backspace_not_entering_chewing()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    type_keystroke_by_string(ctx, \"<B>\");\n    ok_keystroke_rtn(ctx, KEYSTROKE_IGNORE);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 558,
        "end_line": 568,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Backspace_in_select#570",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Backspace_in_select()",
        "snippet": "void test_Backspace_in_select()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"`<B>\");\n    ok_candidate(ctx, NULL, 0);\n\n    type_keystroke_by_string(ctx, \"hk4\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be `%d'\", ret, 0);\n\n    type_keystroke_by_string(ctx, \"<D>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n\n    type_keystroke_by_string(ctx, \"<B>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be `%d'\", ret, 0);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 570,
        "end_line": 594,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Backspace_remove_bopomofo#596",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Backspace_remove_bopomofo()",
        "snippet": "void test_Backspace_remove_bopomofo()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    type_keystroke_by_string(ctx, \"hk<B>\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x98\" /* \u3118 */ );\n\n    chewing_delete(ctx);\n}\n\n",
        "begin_line": 596,
        "end_line": 606,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Backspace_word#608",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Backspace_word()",
        "snippet": "void test_Backspace_word()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n\n    type_keystroke_by_string(ctx, \"hk4u g4<L><B><E>\");\n    ok_commit_buffer(ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ );\n\n    chewing_delete(ctx);\n}\n\nvo",
        "begin_line": 608,
        "end_line": 620,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Backspace#622",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Backspace()",
        "snippet": "void test_Backspace()\n{\n    test_Backspace_not_entering_chewing();\n    test_Backspace_in_select();\n    test_Backspace_remove_bopomofo();\n    test_Backspace_word();\n}",
        "begin_line": 622,
        "end_line": 628,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Up_close_candidate_window_word#630",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Up_close_candidate_window_word()",
        "snippet": "void test_Up_close_candidate_window_word()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"hk4\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be `%d'\", ret, 0);\n\n    type_keystroke_by_string(ctx, \"<D>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n\n    type_keystroke_by_string(ctx, \"<U>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be `%d'\", ret, 0);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 630,
        "end_line": 651,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Up_close_candidate_window_symbol#653",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Up_close_candidate_window_symbol()",
        "snippet": "void test_Up_close_candidate_window_symbol()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"_\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be `%d'\", ret, 0);\n\n    type_keystroke_by_string(ctx, \"<D>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n\n    type_keystroke_by_string(ctx, \"<U>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be `%d'\", ret, 0);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 653,
        "end_line": 674,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Up_not_entering_chewing#676",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Up_not_entering_chewing()",
        "snippet": "void test_Up_not_entering_chewing()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    type_keystroke_by_string(ctx, \"<U>\");\n    ok_keystroke_rtn(ctx, KEYSTROKE_IGNORE);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 676,
        "end_line": 686,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Up#688",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Up()",
        "snippet": "void test_Up()\n{\n    test_Up_close_candidate_window_word();\n    test_Up_close_candidate_window_symbol();\n    test_Up_not_entering_chewing();\n}",
        "begin_line": 688,
        "end_line": 693,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Down_open_candidate_window#695",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Down_open_candidate_window()",
        "snippet": "void test_Down_open_candidate_window()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"hk4\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be `%d'\", ret, 0);\n\n    type_keystroke_by_string(ctx, \"<D>\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n\n    type_keystroke_by_string(ctx, \"3\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be `%d'\", ret, 0);\n    ok_preedit_buffer(ctx, \"\\xE6\\xB8\\xAC\" /* \u6e2c */ );\n\n    chewing_delete(ctx);\n}\n\n",
        "begin_line": 695,
        "end_line": 717,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Down_reopen_symbol_candidate#719",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Down_reopen_symbol_candidate()",
        "snippet": "void test_Down_reopen_symbol_candidate()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"_<D><R>\");\n    ok(chewing_cand_CurrentPage(ctx) == 1, \"current page shall be 1\");\n\n    type_keystroke_by_string(ctx, \"<D>\");\n    ok(chewing_cand_CurrentPage(ctx) == 0, \"current page shall be 0\");\n\n    chewing_delete(ctx);\n}",
        "begin_line": 719,
        "end_line": 733,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Down_not_entering_chewing#735",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Down_not_entering_chewing()",
        "snippet": "void test_Down_not_entering_chewing()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    type_keystroke_by_string(ctx, \"<D>\");\n    ok_keystroke_rtn(ctx, KEYSTROKE_IGNORE);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 735,
        "end_line": 745,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Down_open_candidate_window_after_deleting_symbol#747",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Down_open_candidate_window_after_deleting_symbol()",
        "snippet": "void test_Down_open_candidate_window_after_deleting_symbol()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"<<>hk4g4<<>\" /* \uff0c\u6e2c\u8a66\uff0c */);\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be `%d'\", ret, 0);\n\n    type_keystroke_by_string(ctx, \"<H><DC><EN><D>\" /* Home Delete End Down */);\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n\n    type_keystroke_by_string(ctx, \"2\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be `%d'\", ret, 0);\n    ok_preedit_buffer(ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE2\\x86\\x90\" /* \u6e2c\u8a66\u2190 */ );\n\n    chewing_delete(ctx);\n}\n\nvoid test_Do",
        "begin_line": 747,
        "end_line": 769,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Down#771",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Down()",
        "snippet": "void test_Down()\n{\n    test_Down_open_candidate_window();\n    test_Down_not_entering_chewing();\n    test_Down_open_candidate_window_after_deleting_symbol();\n}",
        "begin_line": 771,
        "end_line": 776,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Tab_insert_breakpoint_between_word#778",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Tab_insert_breakpoint_between_word()",
        "snippet": "void test_Tab_insert_breakpoint_between_word()\n{\n    ChewingContext *ctx;\n    IntervalType it;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n\n    type_keystroke_by_string(ctx, \"hk4g4<L>\");\n    chewing_interval_Enumerate(ctx);\n\n    ok(chewing_interval_hasNext(ctx) == 1, \"shall have next interval\");\n    chewing_interval_Get(ctx, &it);\n    ok(it.from == 0 && it.to == 2, \"interval (%d, %d) shall be (0, 2)\", it.from, it.to);\n\n    ok(chewing_interval_hasNext(ctx) == 0, \"shall not have next interval\");\n\n    /* inserts a breakpoint between \u6e2c and \u8a66 */\n    type_keystroke_by_string(ctx, \"<T>\");\n    chewing_interval_Enumerate(ctx);\n\n    ok(chewing_interval_hasNext(ctx) == 1, \"shall have next interval\");\n    chewing_interval_Get(ctx, &it);\n    ok(it.from == 0 && it.to == 1, \"interval (%d, %d) shall be (0, 1)\", it.from, it.to);\n\n    ok(chewing_interval_hasNext(ctx) == 1, \"shall have next interval\");\n    chewing_interval_Get(ctx, &it);\n    ok(it.from == 1 && it.to == 2, \"interval (%d, %d) shall be (1, 2)\", it.from, it.to);\n\n    ok(chewing_interval_hasNext(ctx) == 0, \"shall not have next interval\");\n\n    chewing_delete(ctx);\n}\n\nvo",
        "begin_line": 778,
        "end_line": 811,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Tab_connect_word#813",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Tab_connect_word()",
        "snippet": "void test_Tab_connect_word()\n{\n    ChewingContext *ctx;\n    IntervalType it;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n\n    type_keystroke_by_string(ctx, \"u -4<L>\");\n    chewing_interval_Enumerate(ctx);\n\n    ok(chewing_interval_hasNext(ctx) == 1, \"shall have next interval\");\n    chewing_interval_Get(ctx, &it);\n    ok(it.from == 0 && it.to == 1, \"interval (%d, %d) shall be (0, 1)\", it.from, it.to);\n\n    ok(chewing_interval_hasNext(ctx) == 1, \"shall have next interval\");\n    chewing_interval_Get(ctx, &it);\n    ok(it.from == 1 && it.to == 2, \"interval (%d, %d) shall be (1, 2)\", it.from, it.to);\n\n    ok(chewing_interval_hasNext(ctx) == 0, \"shall not have next interval\");\n\n    /* connect \u4e00 and \u4e8c */\n    type_keystroke_by_string(ctx, \"<T>\");\n    chewing_interval_Enumerate(ctx);\n\n    ok(chewing_interval_hasNext(ctx) == 1, \"shall have next interval\");\n    chewing_interval_Get(ctx, &it);\n    ok(it.from == 0 && it.to == 2, \"interval (%d, %d) shall be (0, 2)\", it.from, it.to);\n\n    ok(chewing_interval_hasNext(ctx) == 0, \"shall not have next interval\");\n\n    chewing_delete(ctx);\n}\n\nvo",
        "begin_line": 813,
        "end_line": 846,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Tab_at_the_end#848",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Tab_at_the_end()",
        "snippet": "void test_Tab_at_the_end()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"hk4g4u6vu84\");\n    ok_preedit_buffer(ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE4\\xB8\\x80\\xE4\\xB8\\x8B\" /* \u6e2c\u8a66\u4e00\u4e0b */ );\n\n    type_keystroke_by_string(ctx, \"<T>\");\n    ok_preedit_buffer(ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE5\\x84\\x80\\xE4\\xB8\\x8B\" /* \u6e2c\u8a66\u5100\u4e0b */ );\n\n    type_keystroke_by_string(ctx, \"<T>\");\n    ok_preedit_buffer(ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE4\\xB8\\x80\\xE4\\xB8\\x8B\" /* \u6e2c\u8a66\u4e00\u4e0b */ );\n\n    chewing_delete(ctx);\n}\n\nvoid test_Tab()\n{\n    ",
        "begin_line": 848,
        "end_line": 865,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Tab#867",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Tab()",
        "snippet": "void test_Tab()\n{\n    test_Tab_insert_breakpoint_between_word();\n    test_Tab_connect_word();\n    test_Tab_at_the_end();\n}",
        "begin_line": 867,
        "end_line": 872,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_DblTab#874",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_DblTab()",
        "snippet": "void test_DblTab()\n{\n    /* FIXME: Implement this. */\n}",
        "begin_line": 874,
        "end_line": 877,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Capslock#879",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Capslock()",
        "snippet": "void test_Capslock()\n{\n    ChewingContext *ctx;\n    int mode;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    mode = chewing_get_ChiEngMode(ctx);\n    ok(mode == CHINESE_MODE, \"mode shall be CHINESE_MODE\");\n\n    type_keystroke_by_string(ctx, \"ji\");        /* \u3128\u311b */\n    ok_bopomofo_buffer(ctx, \"\\xe3\\x84\\xa8\\xe3\\x84\\x9b\" /* \u3128\u311b */ );\n    ok_preedit_buffer(ctx, \"\");\n    ok_commit_buffer(ctx, \"\");\n\n    type_keystroke_by_string(ctx, \"<CB>\");\n\n    mode = chewing_get_ChiEngMode(ctx);\n    ok(mode == SYMBOL_MODE, \"mode shall change to SYMBOL_MODE\");\n\n    ok_bopomofo_buffer(ctx, \"\");\n    ok_preedit_buffer(ctx, \"\");\n    ok_commit_buffer(ctx, \"\");\n\n    chewing_delete(ctx);\n}\n\nvoid t",
        "begin_line": 879,
        "end_line": 905,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Home#907",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Home()",
        "snippet": "void test_Home()\n{\n    ChewingContext *ctx;\n    int cursor;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n\n    type_keystroke_by_string(ctx, \"hk4g4\");\n    cursor = chewing_cursor_Current(ctx);\n    ok(cursor == 2, \"cursor `%d' shall be 2\", cursor);\n\n    type_keystroke_by_string(ctx, \"<H>\");\n    cursor = chewing_cursor_Current(ctx);\n    ok(cursor == 0, \"cursor `%d' shall be 0\", cursor);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 907,
        "end_line": 925,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_End#927",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_End()",
        "snippet": "void test_End()\n{\n    ChewingContext *ctx;\n    int cursor;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n\n    type_keystroke_by_string(ctx, \"hk4g4<L><L>\");\n    cursor = chewing_cursor_Current(ctx);\n    ok(cursor == 0, \"cursor `%d' shall be 0\", cursor);\n\n    type_keystroke_by_string(ctx, \"<EN>\");\n    cursor = chewing_cursor_Current(ctx);\n    ok(cursor == 2, \"cursor `%d' shall be 2\", cursor);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 927,
        "end_line": 945,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_PageUp_not_entering_chewing#947",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_PageUp_not_entering_chewing()",
        "snippet": "void test_PageUp_not_entering_chewing()\n{\n    ChewingContext *ctx;\n    int cursor;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n\n    type_keystroke_by_string(ctx, \"hk4g4<L><L>\");\n    cursor = chewing_cursor_Current(ctx);\n    ok(cursor == 0, \"cursor `%d' shall be 0\", cursor);\n\n    type_keystroke_by_string(ctx, \"<PU>\");\n    cursor = chewing_cursor_Current(ctx);\n    ok(cursor == 2, \"cursor `%d' shall be 2\", cursor);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 947,
        "end_line": 965,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_PageUp_in_select#967",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_PageUp_in_select()",
        "snippet": "void test_PageUp_in_select()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_candPerPage(ctx, 10);\n\n    type_keystroke_by_string(ctx, \"hk4<D>\");\n    ok(chewing_cand_TotalPage(ctx) == 3, \"total page shall be 3\");\n    ok(chewing_cand_CurrentPage(ctx) == 0, \"current page shall be 0\");\n\n    type_keystroke_by_string(ctx, \"<PU>\");      /* rollover */\n    ok(chewing_cand_CurrentPage(ctx) == 2, \"current page shall be 2\");\n\n    type_keystroke_by_string(ctx, \"<PU>\");      /* to previous page */\n    ok(chewing_cand_CurrentPage(ctx) == 1, \"current page shall be 1\");\n\n    chewing_delete(ctx);\n}",
        "begin_line": 967,
        "end_line": 987,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_PageUp#989",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_PageUp()",
        "snippet": "void test_PageUp()\n{\n    test_PageUp_not_entering_chewing();\n    test_PageUp_in_select();\n}",
        "begin_line": 989,
        "end_line": 993,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_PageDown_not_entering_chewing#995",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_PageDown_not_entering_chewing()",
        "snippet": "void test_PageDown_not_entering_chewing()\n{\n    ChewingContext *ctx;\n    int cursor;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n\n    type_keystroke_by_string(ctx, \"hk4g4<L><L>\");\n    cursor = chewing_cursor_Current(ctx);\n    ok(cursor == 0, \"cursor `%d' shall be 0\", cursor);\n\n    type_keystroke_by_string(ctx, \"<PD>\");\n    cursor = chewing_cursor_Current(ctx);\n    ok(cursor == 2, \"cursor `%d' shall be 2\", cursor);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 995,
        "end_line": 1013,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_PageDown_in_select#1015",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_PageDown_in_select()",
        "snippet": "void test_PageDown_in_select()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_candPerPage(ctx, 10);\n\n    type_keystroke_by_string(ctx, \"hk4<D>\");\n    ok(chewing_cand_TotalPage(ctx) == 3, \"total page shall be 3\");\n    ok(chewing_cand_CurrentPage(ctx) == 0, \"current page shall be 0\");\n\n    type_keystroke_by_string(ctx, \"<PD>\");\n    ok(chewing_cand_CurrentPage(ctx) == 1, \"current page shall be 1\");\n\n    type_keystroke_by_string(ctx, \"<PD><PD>\");  /* rollover */\n    ok(chewing_cand_CurrentPage(ctx) == 0, \"current page shall be 0\");\n\n    chewing_delete(ctx);\n}",
        "begin_line": 1015,
        "end_line": 1035,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_PageDown#1037",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_PageDown()",
        "snippet": "void test_PageDown()\n{\n    test_PageDown_not_entering_chewing();\n    test_PageDown_in_select();\n}",
        "begin_line": 1037,
        "end_line": 1041,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_ShiftSpace#1043",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_ShiftSpace()",
        "snippet": "void test_ShiftSpace()\n{\n    ChewingContext *ctx;\n    int mode;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    mode = chewing_get_ShapeMode(ctx);\n    ok(mode == HALFSHAPE_MODE, \"mode shall be HALFSHAPE_MODE\");\n\n    type_keystroke_by_string(ctx, \"<SS>\");\n    mode = chewing_get_ShapeMode(ctx);\n    ok(mode == FULLSHAPE_MODE, \"mode shall be FULLSHAPE_MODE\");\n\n    type_keystroke_by_string(ctx, \" \");\n    ok_commit_buffer(ctx, \"\\xE3\\x80\\x80\"); /* Fullshape Space (U+3000) */\n\n    chewing_set_ChiEngMode(ctx, SYMBOL_MODE);\n    type_keystroke_by_string(ctx, \"a\");\n    ok_commit_buffer(ctx, \"\\xEF\\xBD\\x81\"); /* Fullshape a */\n\n    chewing_delete(ctx);\n}",
        "begin_line": 1043,
        "end_line": 1066,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Numlock_numeric_input#1068",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Numlock_numeric_input()",
        "snippet": "void test_Numlock_numeric_input()\n{\n    const TestData NUMLOCK_INPUT[] = {\n        {\"<N0>\", \"0\"},\n        {\"<N1>\", \"1\"},\n        {\"<N2>\", \"2\"},\n        {\"<N3>\", \"3\"},\n        {\"<N4>\", \"4\"},\n        {\"<N5>\", \"5\"},\n        {\"<N6>\", \"6\"},\n        {\"<N7>\", \"7\"},\n        {\"<N8>\", \"8\"},\n        {\"<N9>\", \"9\"},\n        {\"<N+>\", \"+\"},\n        {\"<N->\", \"-\"},\n        {\"<N*>\", \"*\"},\n        {\"<N/>\", \"/\"},\n        {\"<N.>\", \".\"},\n    };\n    size_t i;\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n\n    for (i = 0; i < ARRAY_SIZE(NUMLOCK_INPUT); ++i) {\n        type_keystroke_by_string(ctx, NUMLOCK_INPUT[i].token);\n        ok_commit_buffer(ctx, NUMLOCK_INPUT[i].expected);\n    }\n\n    chewing_delete(ctx);\n}",
        "begin_line": 1068,
        "end_line": 1100,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Numlock_select_candidate#1102",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Numlock_select_candidate()",
        "snippet": "void test_Numlock_select_candidate()\n{\n    const TestData NUMLOCK_SELECT[] = {\n        {\"hk4<D><N1><E>\", \"\\xE5\\x86\\x8A\" /* \u518a */ },\n        {\"hk4<D><N2><E>\", \"\\xE7\\xAD\\x96\" /* \u7b56 */ },\n        {\"hk4<D><N3><E>\", \"\\xE6\\xB8\\xAC\" /* \u6e2c */ },\n        {\"hk4<D><N4><E>\", \"\\xE5\\x81\\xB4\" /* \u5074 */ },\n        {\"hk4<D><N5><E>\", \"\\xE5\\xBB\\x81\" /* \u5ec1 */ },\n        {\"hk4<D><N6><E>\", \"\\xE6\\x83\\xBB\" /* \u60fb */ },\n        {\"hk4<D><N7><E>\", \"\\xE7\\xAD\\xB4\" /* \u7b74 */ },\n        {\"hk4<D><N8><E>\", \"\\xE7\\x95\\x9F\" /* \u755f */ },\n        {\"hk4<D><N9><E>\", \"\\xE8\\x8C\\xA6\" /* \u8326 */ },\n        {\"hk4<D><N0><E>\", \"\\xE7\\xB2\\xA3\" /* \u7ca3 */ },\n    };\n    size_t i;\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n\n    for (i = 0; i < ARRAY_SIZE(NUMLOCK_SELECT); ++i) {\n        type_keystroke_by_string(ctx, NUMLOCK_SELECT[i].token);\n        ok_commit_buffer(ctx, NUMLOCK_SELECT[i].expected);\n    }\n\n    chewing_delete(ctx);\n}\n\nvoid test_Numlock(",
        "begin_line": 1102,
        "end_line": 1129,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Numlock#1131",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Numlock()",
        "snippet": "void test_Numlock()\n{\n    test_Numlock_numeric_input();\n    test_Numlock_select_candidate();\n}",
        "begin_line": 1131,
        "end_line": 1135,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Space_empty_buffer#1137",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Space_empty_buffer()",
        "snippet": "void test_Space_empty_buffer()\n{\n    ChewingContext *ctx;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_spaceAsSelection(ctx, 1);\n\n    type_keystroke_by_string(ctx, \" \");\n    ok_preedit_buffer(ctx, \"\");\n    ok_commit_buffer(ctx, \" \");\n\n    chewing_delete(ctx);\n}",
        "begin_line": 1137,
        "end_line": 1152,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Space_selection_word#1154",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Space_selection_word()",
        "snippet": "void test_Space_selection_word()\n{\n    ChewingContext *ctx;\n    char *buf;\n    int len;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_spaceAsSelection(ctx, 1);\n\n    type_keystroke_by_string(ctx, \"hk4g4<H>\" /* \u6e2c\u8a66 */ );\n\n    type_keystroke_by_string(ctx, \" \"); /* open candidate window */\n\n    chewing_cand_Enumerate(ctx);\n    buf = chewing_cand_String(ctx);\n    len = ueStrLen(buf);\n    ok(len == 2, \"candidate `%s' length `%d' shall be `%d'\", buf, len, 2);\n    chewing_free(buf);\n\n    type_keystroke_by_string(ctx, \" \"); /* next candidate list */\n\n    chewing_cand_Enumerate(ctx);\n    buf = chewing_cand_String(ctx);\n    len = ueStrLen(buf);\n    ok(len == 1, \"candidate `%s' length `%d' shall be `%d'\", buf, len, 1);\n    chewing_free(buf);\n\n    type_keystroke_by_string(ctx, \" \"); /* next page */\n    ok(chewing_cand_CurrentPage(ctx) == 1, \"current page shall be 1\");\n\n    chewing_delete(ctx);\n}\n\nvo",
        "begin_line": 1154,
        "end_line": 1188,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Space_selection_symbol#1190",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Space_selection_symbol()",
        "snippet": "void test_Space_selection_symbol()\n{\n    const char CAND_1[] = \"\\xE2\\x80\\xA6\" /* \u2026 */ ;\n    const char CAND_2[] = \"\\xE9\\x9B\\x99\\xE7\\xB7\\x9A\\xE6\\xA1\\x86\" /* \u96d9\u7dda\u6846 */ ;\n\n    ChewingContext *ctx;\n    const char *const_buf;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_spaceAsSelection(ctx, 1);\n\n    type_keystroke_by_string(ctx, \"`\");\n    chewing_cand_Enumerate(ctx);\n    const_buf = chewing_cand_String_static(ctx);\n    ok(strcmp(const_buf, CAND_1) == 0, \"first candidate list head `%s' shall be `%s'\", const_buf, CAND_1);\n\n    type_keystroke_by_string(ctx, \" \");\n    chewing_cand_Enumerate(ctx);\n    const_buf = chewing_cand_String_static(ctx);\n    ok(strcmp(const_buf, CAND_2) == 0, \"second candidate list head `%s' shall be `%s'\", const_buf, CAND_2);\n\n    /* rollover */\n    type_keystroke_by_string(ctx, \" \");\n    chewing_cand_Enumerate(ctx);\n    const_buf = chewing_cand_String_static(ctx);\n    ok(strcmp(const_buf, CAND_1) == 0, \"first candidate list head `%s' shall be `%s'\", const_buf, CAND_1);\n\n    chewing_delete(ctx);\n}\n\nvoid t",
        "begin_line": 1190,
        "end_line": 1221,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Space#1223",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Space()",
        "snippet": "void test_Space()\n{\n    test_Space_empty_buffer();\n    test_Space_selection_word();\n    test_Space_selection_symbol();\n}",
        "begin_line": 1223,
        "end_line": 1228,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_get_phoneSeq#1230",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_get_phoneSeq()",
        "snippet": "void test_get_phoneSeq()\n{\n    static const struct {\n        char *token;\n        unsigned short phone[5];\n    } DATA[] = {\n        {\n            \"hk4g4\", {10268, 8708, 0}\n        },\n        {\n            \"hk4g4`31hk4g4\", {10268, 8708, 10268, 8708, 0}\n        },\n        {\n            \"`31`31\", {0}\n        },\n    };\n    ChewingContext *ctx;\n    size_t i;\n    int expected_len;\n    int len;\n    unsigned short *phone;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n\n    for (i = 0; i < ARRAY_SIZE(DATA); ++i) {\n        chewing_Reset(ctx);\n        type_keystroke_by_string(ctx, DATA[i].token);\n\n        expected_len = 0;\n        while (DATA[i].phone[expected_len] != 0)\n            ++expected_len;\n        len = chewing_get_phoneSeqLen(ctx);\n        ok(len == expected_len, \"phoneSeqLen `%d' shall be `%d'\", len, expected_len);\n\n        phone = chewing_get_phoneSeq(ctx);\n        ok(memcmp(phone, DATA[i].phone, sizeof(phone[0]) * expected_len) == 0, \"phoneSeq shall be expected value\");\n        chewing_free(phone);\n    }\n\n    chewing_delete(ctx);\n}",
        "begin_line": 1230,
        "end_line": 1272,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_bopomofo_buffer#1274",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_bopomofo_buffer()",
        "snippet": "void test_bopomofo_buffer()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"1ul\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x85\\xE3\\x84\\xA7\\xE3\\x84\\xA0\" /* \u3105\u3127\u3120 */ );\n\n    type_keystroke_by_string(ctx, \" \");\n    ok_bopomofo_buffer(ctx, \"\");\n\n    type_keystroke_by_string(ctx, \"ul\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\xA7\\xE3\\x84\\xA0\" /* \u3127\u3120 */ );\n\n    type_keystroke_by_string(ctx, \" \");\n    ok_bopomofo_buffer(ctx, \"\");\n\n    type_keystroke_by_string(ctx, \"3\");\n    ok_bopomofo_buffer(ctx, \"\\xCB\\x87\" /* \u02c7 */ );\n\n    type_keystroke_by_string(ctx, \" \");\n    ok_bopomofo_buffer(ctx, \"\");\n\n    chewing_delete(ctx);\n}\n\nvoid test",
        "begin_line": 1274,
        "end_line": 1300,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_longest_phrase#1302",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_longest_phrase()",
        "snippet": "void test_longest_phrase()\n{\n    ChewingContext *ctx;\n    IntervalType it;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"rup ji up6ji 1j4bj6y4ru32k7e.3ji \"\n                             /* \u3110\u3127\u3123 \u3128\u311b \u3127\u3123\u02ca \u3128\u311b \u3105\u3128\u02cb \u3116\u3128\u02ca \u3117\u02cb \u3110\u3127\u02c7 \u3109\u311c\u02d9 \u310d\u3121\u02c7 \u3128\u311b */\n        );\n    ok_preedit_buffer(ctx,\n                      \"\\xE9\\x87\\x91\\xE7\\xAA\\xA9\\xE9\\x8A\\x80\\xE7\\xAA\\xA9\\xE4\\xB8\\x8D\\xE5\\xA6\\x82\\xE8\\x87\\xAA\\xE5\\xB7\\xB1\\xE7\\x9A\\x84\\xE7\\x8B\\x97\\xE7\\xAA\\xA9\"\n                      /* \u91d1\u7aa9\u9280\u7aa9\u4e0d\u5982\u81ea\u5df1\u7684\u72d7\u7aa9 */ );\n\n    chewing_interval_Enumerate(ctx);\n\n    ok(chewing_interval_hasNext(ctx) == 1, \"shall have next interval\");\n    chewing_interval_Get(ctx, &it);\n    ok(it.from == 0 && it.to == 11, \"interval (%d, %d) shall be (0, 11)\", it.from, it.to);\n\n    chewing_delete(ctx);\n}\n\nvoid test_auto_commit_phrase()\n{\n    ChewingContext *ctx;\n\n    ctx = ch",
        "begin_line": 1302,
        "end_line": 1324,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_auto_commit_phrase#1326",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_auto_commit_phrase()",
        "snippet": "void test_auto_commit_phrase()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 3);\n\n    type_keystroke_by_string(ctx, \"hk4g4hk4g4\" /* \u6e2c\u8a66\u6e2c\u8a66 */ );\n    ok_preedit_buffer(ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ );\n    ok_commit_buffer(ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ );\n\n    chewing_delete(ctx);\n}\n\nvoid test_auto",
        "begin_line": 1326,
        "end_line": 1339,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_auto_commit_symbol#1341",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_auto_commit_symbol()",
        "snippet": "void test_auto_commit_symbol()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_maxChiSymbolLen(ctx, 2);\n\n    type_keystroke_by_string(ctx, \"`31hk4g4\" /* \uff0c\u6e2c\u8a66 */ );\n    ok_preedit_buffer(ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ );\n    ok_commit_buffer(ctx, \"\\xEF\\xBC\\x8C\" /* \uff0c */ );\n\n    chewing_delete(ctx);\n}\n\nvoid test_",
        "begin_line": 1341,
        "end_line": 1354,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_auto_commit#1356",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_auto_commit()",
        "snippet": "void test_auto_commit()\n{\n    test_auto_commit_phrase();\n    test_auto_commit_symbol();\n}",
        "begin_line": 1356,
        "end_line": 1360,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_interval#1362",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_interval()",
        "snippet": "void test_interval()\n{\n    ChewingContext *ctx;\n    IntervalType it;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"`31hk4g4`31hk4g4`31\" /* \uff0c\u6e2c\u8a66\uff0c\u6e2c\u8a66\uff0c */ );\n\n    ok_preedit_buffer(ctx, \"\\xEF\\xBC\\x8C\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xEF\\xBC\\x8C\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xEF\\xBC\\x8C\"\n                      /* \uff0c\u6e2c\u8a66\uff0c\u6e2c\u8a66\uff0c */ );\n\n    chewing_interval_Enumerate(ctx);\n\n    ok(chewing_interval_hasNext(ctx) == 1, \"shall have next interval\");\n    chewing_interval_Get(ctx, &it);\n    ok(it.from == 1 && it.to == 3, \"interval (%d, %d) shall be (1, 3)\", it.from, it.to);\n\n    ok(chewing_interval_hasNext(ctx) == 1, \"shall have next interval\");\n    chewing_interval_Get(ctx, &it);\n    ok(it.from == 4 && it.to == 6, \"interval (%d, %d) shall be (4, 6)\", it.from, it.to);\n\n    ok(chewing_interval_hasNext(ctx) == 0, \"shall not have next interval\");\n\n    chewing_delete(ctx);\n}\n\nvoid test_jk_selection()\n{",
        "begin_line": 1362,
        "end_line": 1388,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_jk_selection#1390",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_jk_selection()",
        "snippet": "void test_jk_selection()\n{\n    ChewingContext *ctx;\n    int ret;\n    int i;\n    const int EXPECT_CAND_LEN[] = { 1, 2, 1, 1, 2, 1, 1 };\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"`31hk4g4`31hk4g4`31\" /* \uff0c\u6e2c\u8a66\uff0c\u6e2c\u8a66\uff0c */ );\n\n    ret = chewing_cand_open(ctx);\n    ok(ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0);\n\n    for (i = ARRAY_SIZE(EXPECT_CAND_LEN) - 1; i >= 0; --i) {\n        ret = chewing_cand_TotalChoice(ctx);\n        ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n        ok_candidate_len(ctx, EXPECT_CAND_LEN[i]);\n        type_keystroke_by_string(ctx, \"j\");\n    }\n\n    for (i = 0; i < ARRAY_SIZE(EXPECT_CAND_LEN); ++i) {\n        ret = chewing_cand_TotalChoice(ctx);\n        ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n        ok_candidate_len(ctx, EXPECT_CAND_LEN[i]);\n        type_keystroke_by_string(ctx, \"k\");\n    }\n    chewing_delete(ctx);\n}\n\n\nvoid test_K",
        "begin_line": 1390,
        "end_line": 1419,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_KB_HSU#1422",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_KB_HSU()",
        "snippet": "void test_KB_HSU()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_KBType(ctx, KB_HSU);\n\n    type_keystroke_by_string(ctx, \"cen kxjen jn dgshnfbkj\");\n    ok_preedit_buffer(ctx, \"\\xE6\\x96\\xB0\\xE9\\x85\\xB7\\xE9\\x9F\\xB3\\xE7\\x9C\\x9F\\xE7\\x9A\\x84\\xE5\\xBE\\x88\\xE6\\xA3\\x92\"\n                      /* \u65b0\u9177\u97f3\u771f\u7684\u5f88\u68d2 */ );\n    chewing_clean_preedit_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"m\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x87\" /* \u3107 */ );\n    type_keystroke_by_string(ctx, \" \"); /* convert \"\u3107\" to \"\u3122\" */\n    ok_bopomofo_buffer(ctx, \"\");\n    ok_preedit_buffer(ctx, \"\\xE5\\xAE\\x89\" /* \u5b89 */);\n    chewing_clean_preedit_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"h\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x8F\" /* \u310f */ );\n    type_keystroke_by_string(ctx, \"d\");  /* convert \"\u310f\" to \"\u311b\" */\n    ok_bopomofo_buffer(ctx, \"\");\n    ok_preedit_buffer(ctx, \"\\xE5\\x93\\xA6\" /* \u54e6 */);\n    chewing_clean_preedit_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"g\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x8D\" /* \u310d */ );\n    type_keystroke_by_string(ctx, \" \"); /* convert \"\u310d\" to \"\u311c\" */\n    ok_bopomofo_buffer(ctx, \"\");\n    ok_preedit_buffer(ctx, \"\\xE9\\x98\\xBF\" /* \u963f */);\n    chewing_clean_preedit_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"n\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x8B\" /* \u310b */ );\n    type_keystroke_by_string(ctx, \"f\"); /* convert \"\u310b\" to \"\u3123\" */\n    ok_bopomofo_buffer(ctx, \"\");\n    ok_preedit_buffer(ctx, \"\\xE5\\xB3\\x8E\" /* \u5cce */);\n    chewing_clean_preedit_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"k\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x8E\" /* \u310e */ );\n    type_keystroke_by_string(ctx, \" \"); /* convert \"\u310e\" to \"\u3124\" */\n    ok_bopomofo_buffer(ctx, \"\");\n    ok_preedit_buffer(ctx, \"\\xE9\\xAA\\xAF\" /* \u9aaf */);\n    chewing_clean_preedit_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"l\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x8C\" /* \u310c */);\n    type_keystroke_by_string(ctx, \"f\"); /* convert \"\u310c\" to \"\u3126\" */\n    ok_bopomofo_buffer(ctx, \"\");\n    ok_preedit_buffer(ctx, \"\\xE7\\x88\\xBE\" /* \u723e */);\n    chewing_clean_preedit_buf(ctx);\n\n    chewing_delete(ctx);\n}\n\nvoid test_KB_HSU_choice_append()\n{\n    const TestData CHOICE",
        "begin_line": 1422,
        "end_line": 1479,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_KB_HSU_choice_append#1481",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_KB_HSU_choice_append()",
        "snippet": "void test_KB_HSU_choice_append()\n{\n    const TestData CHOICE_INFO_APPEND[] = {\n        {\"e \" /* \u3127 */, \"\\xE3\\x84\\x9D\" /* \u311d */ },\n        {\"g \" /* \u311c */, \"\\xE3\\x84\\x8D\" /* \u310d */ },\n        {\"h \" /* \u311b */, \"\\xE3\\x84\\x8F\" /* \u310f */ },\n        {\"k \" /* \u3124 */, \"\\xE3\\x84\\x8E\" /* \u310e */ },\n        {\"c \" /* \u3115 */, \"\\xE3\\x84\\x92\" /* \u3112 */ },\n        {\"n \" /* \u3123 */, \"\\xE3\\x84\\x8B\" /* \u310b */ },\n        {\"m \" /* \u3122 */, \"\\xE3\\x84\\x87\" /* \u3107 */ },\n        {\"s \" /* \u3119 */, \"\\xCB\\x99\" /* \u02d9 */ },\n        {\"d \" /* \u3109 */, \"\\xCB\\x8A\" /* \u02ca */ },\n        {\"f \" /* \u3108 */, \"\\xCB\\x87\" /* \u02c7 */ },\n        {\"j \" /* \u3113 */, \"\\xCB\\x8B\" /* \u02cb */ },\n        {\"l \" /* \u3126 */, \"\\xE3\\x84\\xA5\" /* \u3125 */ },\n        {\"a \" /* \u3118 */, \"\\xE3\\x84\\x9F\" /* \u311f */ },\n        {\"j \" /* \u3113 */, \"\\xE3\\x84\\x90\" /* \u3110 */ },\n        {\"l \" /* \u3126 */, \"\\xE3\\x84\\x8C\" /* \u310c */ },\n    };\n    size_t i;\n    ChewingContext *ctx;\n    int totalChoice;\n    const char *cand;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_KBType(ctx, KB_HSU);\n\n    for (i = 0; i < ARRAY_SIZE(CHOICE_INFO_APPEND); ++i) {\n\n        type_keystroke_by_string(ctx, CHOICE_INFO_APPEND[i].token);\n\n        chewing_cand_open(ctx);\n        totalChoice = chewing_cand_TotalChoice(ctx);\n\n        if (i == 14) {\n            cand = chewing_cand_string_by_index_static(ctx, totalChoice - 3);\n        } else if (i == 13 || i == 12) {\n            cand = chewing_cand_string_by_index_static(ctx, totalChoice - 2);\n        } else {\n            cand = chewing_cand_string_by_index_static(ctx, totalChoice - 1);\n        }\n\n        ok(strcmp(cand, CHOICE_INFO_APPEND[i].expected) == 0, \"returned candidate is `%s' shall be `%s'\", cand, CHOICE_INFO_APPEND[i].expected);\n\n        chewing_cand_close(ctx);\n        chewing_clean_preedit_buf(ctx);\n    }\n    chewing_delete(ctx);\n}\n\nvoid test_KB_HSU_JVC()\n{\n    static const struct {\n   ",
        "begin_line": 1481,
        "end_line": 1530,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_KB_HSU_JVC#1532",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_KB_HSU_JVC()",
        "snippet": "void test_KB_HSU_JVC()\n{\n    static const struct {\n        char *keystroke;\n        char *bopomofo;\n        char *cand;\n    } DATA[] = {\n        { \"j\", \"\\xE3\\x84\\x93\", /* \u3113 */ \"\\xE4\\xB9\\x8B\", /* \u4e4b */ },\n        { \"v\", \"\\xE3\\x84\\x94\", /* \u3114 */ \"\\xE5\\x90\\x83\", /* \u5403 */ },\n        { \"c\", \"\\xE3\\x84\\x95\", /* \u3115 */ \"\\xE5\\xA4\\xB1\", /* \u5931 */ },\n    };\n\n    ChewingContext *ctx;\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_KBType(ctx, KB_HSU);\n\n    for (int i = 0; i < ARRAY_SIZE(DATA); ++i) {\n        type_keystroke_by_string(ctx, DATA[i].keystroke);\n        ok_bopomofo_buffer(ctx, DATA[i].bopomofo);\n        type_keystroke_by_string(ctx, \" \");\n        ok_bopomofo_buffer(ctx, \"\");\n        ok_preedit_buffer(ctx, DATA[i].cand);\n\n        chewing_cand_close(ctx);\n        chewing_clean_preedit_buf(ctx);\n    }\n\n    type_keystroke_by_string(ctx, \"cek\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x92\\xE3\\x84\\xA7\\xE3\\x84\\xA4\" /* \u3112\u3127\u3124 */ );\n    type_keystroke_by_string(ctx, \"<EE>\");\n\n    type_keystroke_by_string(ctx, \"cke\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x92\\xE3\\x84\\xA7\\xE3\\x84\\xA4\" /* \u3112\u3127\u3124 */ );\n    type_keystroke_by_string(ctx, \"<B><B>k\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x95\\xE3\\x84\\xA4\" /* \u3115\u3124 */ );\n    chewing_clean_preedit_buf(ctx);\n\n    chewing_delete(ctx);\n}\n\nvoid test_KB_ET26()\n{\n    ",
        "begin_line": 1532,
        "end_line": 1571,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_KB_ET26#1573",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_KB_ET26()",
        "snippet": "void test_KB_ET26()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_KBType(ctx, KB_ET26);\n\n    type_keystroke_by_string(ctx, \"cen kxken gn drdhnjbtk\");\n    ok_preedit_buffer(ctx, \"\\xE6\\x96\\xB0\\xE9\\x85\\xB7\\xE9\\x9F\\xB3\\xE7\\x9C\\x9F\\xE7\\x9A\\x84\\xE5\\xBE\\x88\\xE6\\xA3\\x92\"\n                      /* \u65b0\u9177\u97f3\u771f\u7684\u5f88\u68d2 */ );\n    chewing_clean_preedit_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"p\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x86\" /* \u3106 */ );\n    type_keystroke_by_string(ctx, \"f\"); /* convert \"\u3106\" to \"\u3121\" */\n    ok_bopomofo_buffer(ctx, \"\");\n    ok_preedit_buffer(ctx, \"\\xE5\\x90\\xBD\" /* \u543d */);\n    chewing_clean_preedit_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"m\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x87\" /* \u3107 */ );\n    type_keystroke_by_string(ctx, \" \"); /* convert \"\u3107\" to \"\u3122\" */\n    ok_bopomofo_buffer(ctx, \"\");\n    ok_preedit_buffer(ctx, \"\\xE5\\xAE\\x89\" /* \u5b89 */);\n    chewing_clean_preedit_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"n\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x8B\" /* \u310b */ );\n    type_keystroke_by_string(ctx, \"j\"); /* convert \"\u310b\" to \"\u3123\" */\n    ok_bopomofo_buffer(ctx, \"\");\n    ok_preedit_buffer(ctx, \"\\xE5\\xB3\\x8E\" /* \u5cce */);\n    chewing_clean_preedit_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"t\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x8A\" /* \u310a */ );\n    type_keystroke_by_string(ctx, \" \"); /* convert \"\u310a\" to \"\u3124\" */\n    ok_bopomofo_buffer(ctx, \"\");\n    ok_preedit_buffer(ctx, \"\\xE9\\xAA\\xAF\" /* \u9aaf */);\n    chewing_clean_preedit_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"l\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x8C\" /* \u310c */ );\n    type_keystroke_by_string(ctx, \" \"); /* convert \"\u310c\" to \"\u3125\" */\n    ok_bopomofo_buffer(ctx, \"\");\n    ok_preedit_buffer(ctx, \"\\xE9\\x9E\\xA5\" /* \u97a5 */);\n    chewing_clean_preedit_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"h\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x8F\" /* \u310f */);\n    type_keystroke_by_string(ctx, \"j\"); /* convert \"\u310f\" to \"\u3126\" */\n    ok_bopomofo_buffer(ctx, \"\");\n    ok_preedit_buffer(ctx, \"\\xE7\\x88\\xBE\" /* \u723e */);\n    chewing_clean_preedit_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"g\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x90\" /* \u3110 */);\n    type_keystroke_by_string(ctx, \" \"); /* convert \"\u3110,\u3112\" to \"\u3113,\u3115\" */\n    ok_bopomofo_buffer(ctx, \"\");\n    ok_preedit_buffer(ctx, \"\\xE4\\xB9\\x8B\" /* \u4e4b */);\n    chewing_clean_preedit_buf(ctx);\n\n    chewing_delete(ctx);\n}\n\nvoid test_KB_ET26_choice_append()\n{\n    const TestData CHOICE_INFO_APPEN",
        "begin_line": 1573,
        "end_line": 1637,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_KB_ET26_choice_append#1639",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_KB_ET26_choice_append()",
        "snippet": "void test_KB_ET26_choice_append()\n{\n    const TestData CHOICE_INFO_APPEND[] = {\n        { \"p \" /* \u3121 */, \"\\xE3\\x84\\x86\" /* \u3106 */ },\n        { \"t \" /* \u3124 */, \"\\xE3\\x84\\x8A\" /* \u310a */ },\n        { \"w \" /* \u3118 */, \"\\xE3\\x84\\x9D\" /* \u311d */ },\n        { \"g \" /* \u3113 */, \"\\xE3\\x84\\x90\" /* \u3110 */ },\n        { \"h \" /* \u3126 */, \"\\xE3\\x84\\x8F\" /* \u310f */ },\n        { \"l \" /* \u3125 */, \"\\xE3\\x84\\x8C\" /* \u310c */ },\n        { \"c \" /* \u3115 */, \"\\xE3\\x84\\x92\" /* \u3112 */ },\n        { \"n \" /* \u3123 */, \"\\xE3\\x84\\x8B\" /* \u310b */ },\n        { \"m \" /* \u3122 */, \"\\xE3\\x84\\x87\" /* \u3107 */ },\n        { \"d \" /* \u3109 */, \"\\xCB\\x99\" /* \u02d9 */ },\n        { \"f \" /* \u3108 */, \"\\xCB\\x8A\" /* \u02ca */ },\n        { \"j \" /* \u3116 */, \"\\xCB\\x87\" /* \u02c7 */ },\n        { \"k \" /* \u310e */, \"\\xCB\\x8B\" /* \u02cb */ },\n        { \"q \" /* \u3117 */, \"\\xE3\\x84\\x9F\" /* \u311f */ },\n        { \"v \" /* \u310d */, \"\\xE3\\x84\\x91\" /* \u3111 */ },\n    };\n\n    size_t i;\n    ChewingContext *ctx;\n    int totalChoice;\n    const char *cand;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_KBType(ctx, KB_ET26);\n\n    for (i = 0; i < ARRAY_SIZE(CHOICE_INFO_APPEND); ++i) {\n\n        type_keystroke_by_string(ctx, CHOICE_INFO_APPEND[i].token);\n\n        chewing_cand_open(ctx);\n        totalChoice = chewing_cand_TotalChoice(ctx);\n\n        if (i == 13 || i == 14) {\n            cand = chewing_cand_string_by_index_static(ctx, totalChoice - 2);\n        } else {\n            cand = chewing_cand_string_by_index_static(ctx, totalChoice - 1);\n        }\n\n        ok(strcmp(cand, CHOICE_INFO_APPEND[i].expected) == 0, \"returned candidate is `%s' shall be `%s'\", cand, CHOICE_INFO_APPEND[i].expected);\n\n        chewing_cand_close(ctx);\n        chewing_clean_preedit_buf(ctx);\n    }\n    chewing_delete(ctx);\n}\n\nvoid test_KB_DACHEN_CP26()\n{\n    ChewingContext *ctx;\n",
        "begin_line": 1639,
        "end_line": 1687,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_KB_DACHEN_CP26#1689",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_KB_DACHEN_CP26()",
        "snippet": "void test_KB_DACHEN_CP26()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_KBType(ctx, KB_DACHEN_CP26);\n\n    type_keystroke_by_string(ctx, \"vup djdup tp wkycprqlld\");\n    ok_preedit_buffer(ctx, \"\\xE6\\x96\\xB0\\xE9\\x85\\xB7\\xE9\\x9F\\xB3\\xE7\\x9C\\x9F\\xE7\\x9A\\x84\\xE5\\xBE\\x88\\xE6\\xA3\\x92\"\n                      /* \u65b0\u9177\u97f3\u771f\u7684\u5f88\u68d2 */ );\n    chewing_clean_preedit_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"qq\"); /* switch between \"\u3105\" and \"\u3106\" */\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x86\" /* \u3106 */);\n    chewing_clean_bopomofo_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"ww\"); /* switch between \"\u3109\" and \"\u310a\" */\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x8A\" /* \u310a */);\n    chewing_clean_bopomofo_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"tt\"); /* switch between \"\u3113\" and \"\u3114\" */\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x94\" /* \u3114 */);\n    chewing_clean_bopomofo_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"xmm\"); /* switch between \"\u3129\" and \"\u3121\" */\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x8C\\xE3\\x84\\xA1\" /* \u310c\u3121 */);\n    chewing_clean_bopomofo_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"xum\"); /* convert \"\u3127\u3129\" to \"\u3127\u3121\" */\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x8C\\xE3\\x84\\xA7\\xE3\\x84\\xA1\" /* \u310c\u3127\u3121 */);\n    type_keystroke_by_string(ctx, \"m\"); /* convert \"\u3127\u3121\" to \"\u3129\" */\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x8C\\xE3\\x84\\xA9\" /* \u310c\u3129 */);\n    chewing_clean_bopomofo_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"ii\"); /* switch between \"\u311b\" and \"\u311e\" */\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x9E\" /* \u311e */);\n    chewing_clean_bopomofo_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"oo\"); /* switch between \"\u311f\" and \"\u3122\" */\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\xA2\" /* \u3122 */);\n    chewing_clean_bopomofo_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"ll\"); /* switch between \"\u3120\" and \"\u3124\" */\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\xA4\" /* \u3124 */);\n    chewing_clean_bopomofo_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"pp\"); /* switch between \"\u3123\" and \"\u3126\" */\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\xA6\" /* \u3126 */);\n    chewing_clean_bopomofo_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"wu\"); /* switch among \"\u3127\", \"\u311a\" and \"\u3127\u311a\" */\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x89\\xE3\\x84\\xA7\" /* \u3109\u3127 */);\n    type_keystroke_by_string(ctx, \"u\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x89\\xE3\\x84\\x9A\" /* \u3109\u311a */);\n    type_keystroke_by_string(ctx, \"u\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x89\\xE3\\x84\\xA7\\xE3\\x84\\x9A\" /* \u3109\u3127\u311a */);\n    type_keystroke_by_string(ctx, \"u\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x89\" /* \u3109 */);\n    type_keystroke_by_string(ctx, \"ju\");\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x89\\xE3\\x84\\xA8\\xE3\\x84\\x9A\" /* \u3109\u3128\u311a */);\n    chewing_clean_bopomofo_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"bb\"); /* convert \"\u3116\" to \"\u311d\" */\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x96\\xE3\\x84\\x9D\" /* \u3116\u311d */);\n    chewing_clean_bopomofo_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"njn\"); /* convert \"\u3119\" to \"\u3125\" */\n    ok_bopomofo_buffer(ctx, \"\\xE3\\x84\\x99\\xE3\\x84\\xA8\\xE3\\x84\\xA5\" /* \u3119\u3128\u3125 */);\n    chewing_clean_bopomofo_buf(ctx);\n\n    chewing_delete(ctx);\n}\n\n\nvoid test_KB_HANYU()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_KBType(ctx, K",
        "begin_line": 1689,
        "end_line": 1762,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_KB_HANYU#1765",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_KB_HANYU()",
        "snippet": "void test_KB_HANYU()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_KBType(ctx, KB_HANYU_PINYIN);\n\n    type_keystroke_by_string(ctx, \"xin ku4yin zhen de5hen3bang4\");\n    ok_preedit_buffer(ctx, \"\\xE6\\x96\\xB0\\xE9\\x85\\xB7\\xE9\\x9F\\xB3\\xE7\\x9C\\x9F\\xE7\\x9A\\x84\\xE5\\xBE\\x88\\xE6\\xA3\\x92\"\n                      /* \u65b0\u9177\u97f3\u771f\u7684\u5f88\u68d2 */ );\n    chewing_clean_preedit_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"huan ying2shi3yong4pin yin mo2shi4\");\n    ok_preedit_buffer(ctx, \"\\xE6\\xAD\\xA1\\xE8\\xBF\\x8E\\xE4\\xBD\\xBF\\xE7\\x94\\xA8\\xE6\\x8B\\xBC\\xE9\\x9F\\xB3\\xE6\\xA8\\xA1\\xE5\\xBC\\x8F\"\n                      /* \u6b61\u8fce\u4f7f\u7528\u62fc\u97f3\u6a21\u5f0f */ );\n    chewing_clean_preedit_buf(ctx);\n\n    chewing_delete(ctx);\n}\n\n\nvoid test_KB_THL()\n{\n    Ch",
        "begin_line": 1765,
        "end_line": 1785,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_KB_THL#1788",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_KB_THL()",
        "snippet": "void test_KB_THL()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_KBType(ctx, KB_THL_PINYIN);\n\n    type_keystroke_by_string(ctx, \"sin ku4yin jhen de5hen3bang4\");\n    ok_preedit_buffer(ctx, \"\\xE6\\x96\\xB0\\xE9\\x85\\xB7\\xE9\\x9F\\xB3\\xE7\\x9C\\x9F\\xE7\\x9A\\x84\\xE5\\xBE\\x88\\xE6\\xA3\\x92\"\n                      /* \u65b0\u9177\u97f3\u771f\u7684\u5f88\u68d2 */ );\n    chewing_clean_preedit_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"huan ying2shih3yong4pin yin mo2shih4\");\n    ok_preedit_buffer(ctx, \"\\xE6\\xAD\\xA1\\xE8\\xBF\\x8E\\xE4\\xBD\\xBF\\xE7\\x94\\xA8\\xE6\\x8B\\xBC\\xE9\\x9F\\xB3\\xE6\\xA8\\xA1\\xE5\\xBC\\x8F\"\n                      /* \u6b61\u8fce\u4f7f\u7528\u62fc\u97f3\u6a21\u5f0f */ );\n    chewing_clean_preedit_buf(ctx);\n\n    chewing_delete(ctx);\n}\n\n\nvoid test_KB_MPS2()\n{\n    C",
        "begin_line": 1788,
        "end_line": 1808,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_KB_MPS2#1811",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_KB_MPS2()",
        "snippet": "void test_KB_MPS2()\n{\n    ChewingContext *ctx;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_KBType(ctx, KB_MPS2_PINYIN);\n\n    type_keystroke_by_string(ctx, \"shin ku4in jen de5hen3bang4\");\n    ok_preedit_buffer(ctx, \"\\xE6\\x96\\xB0\\xE9\\x85\\xB7\\xE9\\x9F\\xB3\\xE7\\x9C\\x9F\\xE7\\x9A\\x84\\xE5\\xBE\\x88\\xE6\\xA3\\x92\"\n                      /* \u65b0\u9177\u97f3\u771f\u7684\u5f88\u68d2 */ );\n    chewing_clean_preedit_buf(ctx);\n\n    type_keystroke_by_string(ctx, \"huan ing2shr3iung4pin in muo2shz4\");\n    ok_preedit_buffer(ctx, \"\\xE6\\xAD\\xA1\\xE8\\xBF\\x8E\\xE4\\xBD\\xBF\\xE7\\x94\\xA8\\xE6\\x8B\\xBC\\xE9\\x9F\\xB3\\xE6\\xA8\\xA1\\xE5\\xBC\\x8F\"\n                      /* \u6b61\u8fce\u4f7f\u7528\u62fc\u97f3\u6a21\u5f0f */ );\n    chewing_clean_preedit_buf(ctx);\n\n    chewing_delete(ctx);\n}\n\n\nvoid test_KB()\n{\n    test_K",
        "begin_line": 1811,
        "end_line": 1831,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_KB#1834",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_KB()",
        "snippet": "void test_KB()\n{\n    test_KB_HSU();\n    test_KB_HSU_choice_append();\n    test_KB_HSU_JVC();\n    test_KB_ET26();\n    test_KB_ET26_choice_append();\n    test_KB_DACHEN_CP26();\n\n    test_KB_HANYU();\n    test_KB_THL();\n    test_KB_MPS2();\n}",
        "begin_line": 1834,
        "end_line": 1846,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_chewing_phone_to_bopomofo#1848",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_chewing_phone_to_bopomofo()",
        "snippet": "void test_chewing_phone_to_bopomofo()\n{\n    char *u8phone;\n    char *rt;\n    int  expected_len;\n    int  len;\n    uint16_t phone;\n    uint16_t expect;\n    /*\n     *  the libchewing divides a completed bopomofo into 4 parts,\n     *      1st part: \u3105\u3106\u3107\u3108\u3109\u310a\u310b\u310c\u310d\u310e\u310f\u3110\u3111\u3112\u3113\u3114\u3115\u3116\u3117\u3118\u3119\n     *      2nd part: \u3127\u3128\u3129\n     *      3rd part: \u311a\u311b\u311c\u311d\u311e\u311f\u3120\u3121\u3122\u3123\u3124\u3125\u3126\n     *      4th part:  \u02d9\u02ca\u02c7\u02cb\n     *\n     *  calculates each part's offset and stores into a 16-bit unsigned by following rule:\n     *  16-bit unsinged = ( 1st part offset )<<9 + ( 2nd part offset )<<7 + ( 3rd part offset )<<3 + (4th part offset),\n     *\n     *  e.g., \u3106\u3123, 1st part offset = 2, 2nd part offset = 0, 3rd part offset = 10, 4th part offset = 0,\n     *  so the number for \u3106\u3123 is (2<<9)+(0<<7)+(10<<3)+(0) = 1104\n     */\n\n    start_testcase(NULL, fd);\n\n    u8phone = \"\\xE3\\x84\\x86\\xE3\\x84\\xA3\" /* \u3106\u3123 */ ;\n    phone = UintFromPhone(u8phone);\n    expect = (2 << 9) + (0 << 7) + (10 << 3) + (0);\n    ok(phone == expect, \"UintFromPhone `%s' shall be `%d', got `%d'\", u8phone, expect, phone);\n\n    expected_len = strlen(u8phone) + 1;\n    len = chewing_phone_to_bopomofo(expect, NULL, 0);\n    ok(len == expected_len, \"chewing_phone_to_bopomofo returns `%d' shall be `%d'\", len, expected_len);\n    rt = calloc(sizeof(char), len);\n    chewing_phone_to_bopomofo(expect, rt, len);\n    ok(strcmp(rt, u8phone) == 0, \"PhoneFromUint d%d' shall be `%s', got `%s'\", expect, u8phone, rt);\n    free(rt);\n\n    u8phone = \"\\xE3\\x84\\x8A\\xE3\\x84\\xA7\\xE3\\x84\\xA2\" /* \u310a\u3127\u3122 */ ;\n    phone = UintFromPhone(u8phone);\n    expect = (6 << 9) + (1 << 7) + (9 << 3) + (0);\n    ok(phone == expect, \"UintFromPhone `%s' shall be `%d', got `%d'\", u8phone, expect, phone);\n\n    expected_len = strlen(u8phone) + 1;\n    len = chewing_phone_to_bopomofo(expect, NULL, 0);\n    ok(len == expected_len, \"chewing_phone_to_bopomofo returns `%d' shall be `%d'\", len, expected_len);\n    rt = calloc(sizeof(char), len);\n    chewing_phone_to_bopomofo(expect, rt, len);\n    ok(strcmp(rt, u8phone) == 0, \"PhoneFromUint d%d' shall be `%s', got `%s'\", expect, u8phone, rt);\n    free(rt);\n\n    u8phone = \"\\xE3\\x84\\x92\\xE3\\x84\\xA7\\xE3\\x84\\x9A\\xCB\\x8B\" /* \u3112\u3127\u311a\u02cb */ ;\n    phone = UintFromPhone(u8phone);\n    expect = (14 << 9) + (1 << 7) + (1 << 3)+ (4);\n    ok(phone == expect, \"UintFromPhone `%s' shall be `%d', got `%d'\", u8phone, expect, phone);\n\n    expected_len = strlen(u8phone) + 1;\n    len = chewing_phone_to_bopomofo(expect, NULL, 0);\n    ok(len == expected_len, \"chewing_phone_to_bopomofo returns `%d' shall be `%d'\", len, expected_len);\n    rt = calloc(sizeof(char), len);\n    chewing_phone_to_bopomofo(expect, rt, len);\n    ok(strcmp(rt, u8phone) == 0, \"PhoneFromUint `%d' shall be `%s', got `%s'\", expect, u8phone, rt);\n    free(rt);\n\n    len = chewing_phone_to_bopomofo(0, NULL, 0);\n    ok(len == -1, \"chewing_phone_to_bopomofo returns `%d' shall be `%d'\", len, -1);\n}\n\nint main(int argc, char *argv[])\n{\n    char *logname;\n    int ret;\n\n    putenv(\"CHEWING_PATH=\" CHEWIN",
        "begin_line": 1848,
        "end_line": 1913,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.main#1915",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    char *logname;\n    int ret;\n\n    putenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n    putenv(\"CHEWING_USER_PATH=\" TEST_HASH_DIR);\n\n    ret = asprintf(&logname, \"%s.log\", argv[0]);\n    if (ret == -1)\n        return -1;\n    fd = fopen(logname, \"w\");\n    assert(fd);\n    free(logname);\n\n\n    test_select_candidate();\n    test_Esc();\n    test_Del();\n    test_Backspace();\n    test_Up();\n    test_Down();\n    test_Tab();\n    test_DblTab();\n    test_Capslock();\n    test_Home();\n    test_End();\n    test_PageUp();\n    test_PageDown();\n    test_ShiftSpace();\n    test_Numlock();\n    test_Space();\n\n    test_get_phoneSeq();\n    test_bopomofo_buffer();\n\n    test_longest_phrase();\n    test_auto_commit();\n\n    test_interval();\n\n    test_jk_selection();\n\n    test_KB();\n\n    test_chewing_phone_to_bopomofo();\n\n    fclose(fd);\n\n    return exit_status();\n}",
        "begin_line": 1915,
        "end_line": 1965,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_open_word#18",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_open_word()",
        "snippet": "void test_cand_open_word()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"hk4\" /* \u3118\u311c\u02cb */ );\n\n    ret = chewing_cand_open(ctx);\n    ok(ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n\n    chewing_delete(ctx);\n}\n\nvoi",
        "begin_line": 18,
        "end_line": 35,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_open_symbol#37",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_open_symbol()",
        "snippet": "void test_cand_open_symbol()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"`31\" /* \uff0c */ );\n\n    ret = chewing_cand_open(ctx);\n    ok(ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n\n    chewing_delete(ctx);\n}\n\n",
        "begin_line": 37,
        "end_line": 54,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_open_already_opened#56",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_open_already_opened()",
        "snippet": "void test_cand_open_already_opened()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"hk4\" /* \u3118\u311c\u02cb */ );\n\n    ret = chewing_cand_open(ctx);\n    ok(ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n\n    /* FIXME: Need to ensure the candidate windows does not change */\n    ret = chewing_cand_open(ctx);\n    ok(ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n\n    chewing_delete(ctx);\n}\n\nvoi",
        "begin_line": 56,
        "end_line": 80,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_open_nothing_in_preedit#82",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_open_nothing_in_preedit()",
        "snippet": "void test_cand_open_nothing_in_preedit()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    ret = chewing_cand_open(ctx);\n    ok(ret == -1, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be `%d'\", ret, 0);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 82,
        "end_line": 97,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_open_during_bopomofo#99",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_open_during_bopomofo()",
        "snippet": "void test_cand_open_during_bopomofo()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    /* FIXME: shall we clean bopomofo when chewing_cand_open is called? */\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"hk\" /* \u3118\u311c */ );\n\n    ret = chewing_cand_open(ctx);\n    ok(ret == -1, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be `%d'\", ret, 0);\n\n    chewing_Reset(ctx);\n\n    type_keystroke_by_string(ctx, \"hk4g\" /* \u3118\u311c\u02cb \u3115 */ );\n    ret = chewing_cand_open(ctx);\n    ok(ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n\n    chewing_delete(ctx);\n}\n\nvoid test",
        "begin_line": 99,
        "end_line": 127,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_open#129",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_open()",
        "snippet": "void test_cand_open()\n{\n    test_cand_open_word();\n    test_cand_open_symbol();\n    test_cand_open_already_opened();\n    test_cand_open_nothing_in_preedit();\n    test_cand_open_during_bopomofo();\n}",
        "begin_line": 129,
        "end_line": 136,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_close_word#138",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_close_word()",
        "snippet": "void test_cand_close_word()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"hk4\" /* \u3118\u311c\u02cb */ );\n\n    ret = chewing_cand_open(ctx);\n    ok(ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n\n    ret = chewing_cand_close(ctx);\n    ok(ret == 0, \"chewing_cand_close() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be 0 than `%d'\", ret, 0);\n\n    ok_commit_buffer(ctx, \"\");\n\n    chewing_delete(ctx);\n}\n\n\nvo",
        "begin_line": 138,
        "end_line": 163,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_close_symbol#166",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_close_symbol()",
        "snippet": "void test_cand_close_symbol()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"`31\" /* \uff0c */ );\n\n    ret = chewing_cand_open(ctx);\n    ok(ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n\n    ret = chewing_cand_close(ctx);\n    ok(ret == 0, \"chewing_cand_close() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be 0 than `%d'\", ret, 0);\n\n    ok_commit_buffer(ctx, \"\");\n\n    chewing_delete(ctx);\n}\n\n",
        "begin_line": 166,
        "end_line": 191,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_close_already_closed#193",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_close_already_closed()",
        "snippet": "void test_cand_close_already_closed()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"hk4\" /* \u3118\u311c\u02cb */ );\n\n    ret = chewing_cand_close(ctx);\n    ok(ret == 0, \"chewing_cand_close() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be 0 than `%d'\", ret, 0);\n\n    chewing_delete(ctx);\n}\n\nvoi",
        "begin_line": 193,
        "end_line": 210,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_close_nothing_in_preedit#212",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_close_nothing_in_preedit()",
        "snippet": "void test_cand_close_nothing_in_preedit()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    ret = chewing_cand_close(ctx);\n    ok(ret == 0, \"chewing_cand_close() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be 0 than `%d'\", ret, 0);\n\n    chewing_delete(ctx);\n}",
        "begin_line": 212,
        "end_line": 227,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_close#229",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_close()",
        "snippet": "void test_cand_close()\n{\n    test_cand_close_word();\n    test_cand_close_symbol();\n    test_cand_close_already_closed();\n    test_cand_close_nothing_in_preedit();\n}",
        "begin_line": 229,
        "end_line": 235,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_choose_word#237",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_choose_word()",
        "snippet": "void test_cand_choose_word()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"hk4\" /* \u3118\u311c\u02cb */ );\n\n    ret = chewing_cand_open(ctx);\n    ok(ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n\n    ret = chewing_cand_choose_by_index(ctx, 2);\n    ok(ret == 0, \"chewing_cand_choose_by_index() returns `%d' shall be `%d'\", ret, 0);\n\n    ok_preedit_buffer(ctx, \"\\xE6\\xB8\\xAC\" /* \u6e2c */ );\n\n    chewing_delete(ctx);\n}\n\nvoid ",
        "begin_line": 237,
        "end_line": 261,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_choose_symbol#263",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_choose_symbol()",
        "snippet": "void test_cand_choose_symbol()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"`\" /* \uff0c */ );\n\n    ret = chewing_cand_choose_by_index(ctx, 2);\n    ok(ret == 0, \"chewing_cand_choose_by_index() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_choose_by_index(ctx, 0);\n    ok(ret == 0, \"chewing_cand_choose_by_index() returns `%d' shall be `%d'\", ret, 0);\n\n    ok_preedit_buffer(ctx, \"\\xEF\\xBC\\x8C\" /* \uff0c */ );\n\n    chewing_delete(ctx);\n}\n\nvo",
        "begin_line": 263,
        "end_line": 282,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_choose_out_of_range#284",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_choose_out_of_range()",
        "snippet": "void test_cand_choose_out_of_range()\n{\n    ChewingContext *ctx;\n    int ret;\n    int total_choice;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"hk4\" /* \u3118\u311c\u02cb */ );\n\n    ret = chewing_cand_open(ctx);\n    ok(ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0);\n\n    total_choice = chewing_cand_TotalChoice(ctx);\n    ok(total_choice > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", total_choice, 0);\n\n    ret = chewing_cand_choose_by_index(ctx, total_choice);\n    ok(ret == -1, \"chewing_cand_choose_by_index() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_cand_choose_by_index(ctx, -1);\n    ok(ret == -1, \"chewing_cand_choose_by_index() returns `%d' shall be `%d'\", ret, -1);\n\n    ok_preedit_buffer(ctx, \"\\xE5\\x86\\x8A\" /* \u518a */ );\n\n    chewing_delete(ctx);\n}\n\nvoid ",
        "begin_line": 284,
        "end_line": 312,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_choose_second_layer#314",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_choose_second_layer()",
        "snippet": "void test_cand_choose_second_layer()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"`\");\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n    ret = chewing_cand_choose_by_index(ctx, 2);\n    ok(ret == 0, \"chewing_cand_choose_by_index() returns `%d' shall be `%d'\", ret, 0);\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n    ret = chewing_cand_choose_by_index(ctx, 0);\n    ok(ret == 0, \"chewing_cand_choose_by_index() returns `%d' shall be `%d'\", ret, 0);\n    ok_preedit_buffer(ctx, \"\\xEF\\xBC\\x8C\" /* \uff0c */ );\n\n    chewing_delete(ctx);\n}\n\n",
        "begin_line": 314,
        "end_line": 334,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_choose_not_in_select#336",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_choose_not_in_select()",
        "snippet": "void test_cand_choose_not_in_select()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"hk4\" /* \u3118\u311c\u02cb */ );\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret == 0, \"chewing_cand_TotalChoice() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_choose_by_index(ctx, 2);\n    ok(ret == -1, \"chewing_cand_choose_by_index() returns `%d' shall be `%d'\", ret, -1);\n\n    ok_preedit_buffer(ctx, \"\\xE5\\x86\\x8A\" /* \u518a */ );\n\n    chewing_delete(ctx);\n}\n\nvoid ",
        "begin_line": 336,
        "end_line": 357,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_choose#359",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_choose()",
        "snippet": "void test_cand_choose()\n{\n    test_cand_choose_word();\n    test_cand_choose_symbol();\n    test_cand_choose_second_layer();\n    test_cand_choose_out_of_range();\n    test_cand_choose_not_in_select();\n}",
        "begin_line": 359,
        "end_line": 366,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_list_word_no_rearward#368",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_list_word_no_rearward()",
        "snippet": "void test_cand_list_word_no_rearward()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_phraseChoiceRearward(ctx, 0);\n\n    type_keystroke_by_string(ctx, \"hk4g4<H>\" /* \u6e2c\u8a66 */ );\n\n    ret = chewing_cand_open(ctx);\n    ok(ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0);\n    ok_candidate_len(ctx, 2);\n\n    ret = chewing_cand_list_has_next(ctx);\n    ok(ret == 1, \"chewing_cand_list_has_next() returns `%d' shall be `%d'\", ret, 1);\n    ret = chewing_cand_list_next(ctx);\n    ok(ret == 0, \"chewing_cand_list_next() returns `%d' shall be `%d'\", ret, 0);\n    ok_candidate_len(ctx, 1);\n\n    ret = chewing_cand_list_has_next(ctx);\n    ok(ret == 0, \"chewing_cand_list_has_next() returns `%d' shall be `%d'\", ret, 0);\n    ret = chewing_cand_list_next(ctx);\n    ok(ret == -1, \"chewing_cand_list_next() returns `%d' shall be `%d'\", ret, -1);\n    ok_candidate_len(ctx, 1);\n\n    ret = chewing_cand_list_has_prev(ctx);\n    ok(ret == 1, \"chewing_cand_list_has_prev() returns `%d' shall be `%d'\", ret, 1);\n    ret = chewing_cand_list_prev(ctx);\n    ok(ret == 0, \"chewing_cand_list_prev() returns `%d' shall be `%d'\", ret, 0);\n    ok_candidate_len(ctx, 2);\n\n    ret = chewing_cand_list_has_prev(ctx);\n    ok(ret == 0, \"chewing_cand_list_has_prev() returns `%d' shall be `%d'\", ret, 0);\n    ret = chewing_cand_list_prev(ctx);\n    ok(ret == -1, \"chewing_cand_list_prev() returns `%d' shall be `%d'\", ret, -1);\n    ok_candidate_len(ctx, 2);\n\n    ret = chewing_cand_list_last(ctx);\n    ok(ret == 0, \"chewing_cand_list_last() returns `%d' shall be `%d'\", ret, 0);\n    ok_candidate_len(ctx, 1);\n\n    ret = chewing_cand_list_first(ctx);\n    ok(ret == 0, \"chewing_cand_list_first() returns `%d' shall be `%d'\", ret, 0);\n    ok_candidate_len(ctx, 2);\n\n    chewing_delete(ctx);\n}\n\nvo",
        "begin_line": 368,
        "end_line": 416,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_list_word_rearward#418",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_list_word_rearward()",
        "snippet": "void test_cand_list_word_rearward()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    chewing_set_phraseChoiceRearward(ctx, 1);\n\n    type_keystroke_by_string(ctx, \"hk4g4\" /* \u6e2c\u8a66 */ );\n\n    ret = chewing_cand_open(ctx);\n    ok(ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0);\n    ok_candidate_len(ctx, 2);\n\n    ret = chewing_cand_list_has_next(ctx);\n    ok(ret == 1, \"chewing_cand_list_has_next() returns `%d' shall be `%d'\", ret, 1);\n    ret = chewing_cand_list_next(ctx);\n    ok(ret == 0, \"chewing_cand_list_next() returns `%d' shall be `%d'\", ret, 0);\n    ok_candidate_len(ctx, 1);\n\n    ret = chewing_cand_list_has_next(ctx);\n    ok(ret == 0, \"chewing_cand_list_has_next() returns `%d' shall be `%d'\", ret, 0);\n    ret = chewing_cand_list_next(ctx);\n    ok(ret == -1, \"chewing_cand_list_next() returns `%d' shall be `%d'\", ret, -1);\n    ok_candidate_len(ctx, 1);\n\n    ret = chewing_cand_list_has_prev(ctx);\n    ok(ret == 1, \"chewing_cand_list_has_prev() returns `%d' shall be `%d'\", ret, 1);\n    ret = chewing_cand_list_prev(ctx);\n    ok(ret == 0, \"chewing_cand_list_prev() returns `%d' shall be `%d'\", ret, 0);\n    ok_candidate_len(ctx, 2);\n\n    ret = chewing_cand_list_has_prev(ctx);\n    ok(ret == 0, \"chewing_cand_list_has_prev() returns `%d' shall be `%d'\", ret, 0);\n    ret = chewing_cand_list_prev(ctx);\n    ok(ret == -1, \"chewing_cand_list_prev() returns `%d' shall be `%d'\", ret, -1);\n    ok_candidate_len(ctx, 2);\n\n    ret = chewing_cand_list_last(ctx);\n    ok(ret == 0, \"chewing_cand_list_last() returns `%d' shall be `%d'\", ret, 0);\n    ok_candidate_len(ctx, 1);\n\n    ret = chewing_cand_list_first(ctx);\n    ok(ret == 0, \"chewing_cand_list_first() returns `%d' shall be `%d'\", ret, 0);\n    ok_candidate_len(ctx, 2);\n\n    chewing_delete(ctx);\n}\n\n\nv",
        "begin_line": 418,
        "end_line": 466,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_list_word_selection_next_no_rearward#469",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_list_word_selection_next_no_rearward()",
        "snippet": "void test_cand_list_word_selection_next_no_rearward()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"u61o4y7<H>\" /* \u3127\u02ca \u3105\u311f\u02cb \u3117\u02d9 */ );\n\n    ret = chewing_cand_open(ctx);\n    ok(ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n    ok_candidate_len(ctx, 3);\n\n    ret = chewing_cand_list_has_next(ctx);\n    ok(ret == 1, \"chewing_cand_list_has_next() returns `%d' shall be `%d'\", ret, 1);\n    ret = chewing_cand_list_next(ctx);\n    ok(ret == 0, \"chewing_cand_list_next() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n    ok_candidate_len(ctx, 2);\n\n    ret = chewing_cand_choose_by_index(ctx, 1);\n    ok(ret == 0, \"chewing_cand_choose_by_index() returns `%d' shall be `%d'\", ret, 0);\n\n    ok_preedit_buffer(ctx, \"\\xE4\\xB8\\x80\\xE8\\xBC\\xA9\\xE5\\xAD\\x90\" /* \u4e00\u8f29\u5b50 */ );\n\n    chewing_delete(ctx);\n}\n\nvoid test_cand_",
        "begin_line": 469,
        "end_line": 503,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_list_word_selection_next_rearward#505",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_list_word_selection_next_rearward()",
        "snippet": "void test_cand_list_word_selection_next_rearward()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_phraseChoiceRearward(ctx, 1);\n\n    type_keystroke_by_string(ctx, \"u61o4y7\" /* \u3127\u02ca \u3105\u311f\u02cb \u3117\u02d9 */ );\n\n    ret = chewing_cand_open(ctx);\n    ok(ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n    ok_candidate_len(ctx, 3);\n\n    ret = chewing_cand_list_has_next(ctx);\n    ok(ret == 1, \"chewing_cand_list_has_next() returns `%d' shall be `%d'\", ret, 1);\n    ret = chewing_cand_list_next(ctx);\n    ok(ret == 0, \"chewing_cand_list_next() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n    ok_candidate_len(ctx, 2);\n\n    ret = chewing_cand_choose_by_index(ctx, 0);\n    ok(ret == 0, \"chewing_cand_choose_by_index() returns `%d' shall be `%d'\", ret, 0);\n\n    ok_preedit_buffer(ctx, \"\\xE4\\xB8\\x80\\xE8\\xBC\\xA9\\xE5\\xAD\\x90\" /* \u4e00\u8f29\u5b50 */ );\n\n    chewing_delete(ctx);\n}\n\nvoid test_cand_",
        "begin_line": 505,
        "end_line": 541,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_list_word_selection_prev_no_rearward#543",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_list_word_selection_prev_no_rearward()",
        "snippet": "void test_cand_list_word_selection_prev_no_rearward()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"u61o4y7<H>\" /* \u3127\u02ca \u3105\u311f\u02cb \u3117\u02d9 */ );\n\n    ret = chewing_cand_open(ctx);\n    ok(ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n    ok_candidate_len(ctx, 3);\n\n    ret = chewing_cand_list_last(ctx);\n    ok(ret == 0, \"chewing_cand_list_last() returns `%d' shall be `%d'\", ret, 1);\n    ok_candidate_len(ctx, 1);\n\n    ret = chewing_cand_list_has_prev(ctx);\n    ok(ret == 1, \"chewing_cand_list_has_prev() returns `%d' shall be `%d'\", ret, 1);\n    ret = chewing_cand_list_prev(ctx);\n    ok(ret == 0, \"chewing_cand_list_prev() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n    ok_candidate_len(ctx, 2);\n\n    ret = chewing_cand_choose_by_index(ctx, 1);\n    ok(ret == 0, \"chewing_cand_choose_by_index() returns `%d' shall be `%d'\", ret, 0);\n\n    ok_preedit_buffer(ctx, \"\\xE4\\xB8\\x80\\xE8\\xBC\\xA9\\xE5\\xAD\\x90\" /* \u4e00\u8f29\u5b50 */ );\n\n    chewing_delete(ctx);\n}\n\nvoid test_cand_",
        "begin_line": 543,
        "end_line": 581,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_list_word_selection_prev_rearward#583",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_list_word_selection_prev_rearward()",
        "snippet": "void test_cand_list_word_selection_prev_rearward()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    clean_userphrase();\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    chewing_set_phraseChoiceRearward(ctx, 1);\n\n    type_keystroke_by_string(ctx, \"u61o4y7\" /* \u3127\u02ca \u3105\u311f\u02cb \u3117\u02d9 */ );\n\n    ret = chewing_cand_open(ctx);\n    ok(ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n    ok_candidate_len(ctx, 3);\n\n    ret = chewing_cand_list_last(ctx);\n    ok(ret == 0, \"chewing_cand_list_last() returns `%d' shall be `%d'\", ret, 1);\n    ok_candidate_len(ctx, 1);\n\n    ret = chewing_cand_list_has_prev(ctx);\n    ok(ret == 1, \"chewing_cand_list_has_prev() returns `%d' shall be `%d'\", ret, 1);\n    ret = chewing_cand_list_prev(ctx);\n    ok(ret == 0, \"chewing_cand_list_prev() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_TotalChoice(ctx);\n    ok(ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall be greater than `%d'\", ret, 0);\n    ok_candidate_len(ctx, 2);\n\n    ret = chewing_cand_choose_by_index(ctx, 0);\n    ok(ret == 0, \"chewing_cand_choose_by_index() returns `%d' shall be `%d'\", ret, 0);\n\n    ok_preedit_buffer(ctx, \"\\xE4\\xB8\\x80\\xE8\\xBC\\xA9\\xE5\\xAD\\x90\" /* \u4e00\u8f29\u5b50 */ );\n\n    chewing_delete(ctx);\n}\n\nvoid test_cand_",
        "begin_line": 583,
        "end_line": 623,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_list_word#625",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_list_word()",
        "snippet": "void test_cand_list_word()\n{\n    test_cand_list_word_no_rearward();\n    test_cand_list_word_rearward();\n    test_cand_list_word_selection_next_no_rearward();\n    test_cand_list_word_selection_next_rearward();\n    test_cand_list_word_selection_prev_no_rearward();\n    test_cand_list_word_selection_prev_rearward();\n}",
        "begin_line": 625,
        "end_line": 633,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_list_symbol#635",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_list_symbol()",
        "snippet": "void test_cand_list_symbol()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n    type_keystroke_by_string(ctx, \"`31\" /* \uff0c */ );\n\n    ret = chewing_cand_open(ctx);\n    ok(ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0);\n    ok_candidate_len(ctx, 1);\n\n    ret = chewing_cand_list_has_next(ctx);\n    ok(ret == 0, \"chewing_cand_list_has_next() returns `%d' shall be `%d'\", ret, 0);\n    ret = chewing_cand_list_next(ctx);\n    ok(ret == -1, \"chewing_cand_list_has_next() returns `%d' shall be `%d'\", ret, -1);\n    ok_candidate_len(ctx, 1);\n\n    ret = chewing_cand_list_has_prev(ctx);\n    ok(ret == 0, \"chewing_cand_list_has_prev() returns `%d' shall be `%d'\", ret, 0);\n    ret = chewing_cand_list_prev(ctx);\n    ok(ret == -1, \"chewing_cand_list_prev() returns `%d' shall be `%d'\", ret, -1);\n    ok_candidate_len(ctx, 1);\n\n    ret = chewing_cand_list_first(ctx);\n    ok(ret == 0, \"chewing_cand_list_first() returns `%d' shall be `%d'\", ret, 0);\n    ok_candidate_len(ctx, 1);\n\n    ret = chewing_cand_list_last(ctx);\n    ok(ret == 0, \"chewing_cand_list_last() returns `%d' shall be `%d'\", ret, 0);\n    ok_candidate_len(ctx, 1);\n\n    chewing_delete(ctx);\n}\n\n",
        "begin_line": 635,
        "end_line": 669,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_list_no_cand_windows#671",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_list_no_cand_windows()",
        "snippet": "void test_cand_list_no_cand_windows()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"hk4g4\" /* \u6e2c\u8a66 */ );\n\n    ret = chewing_cand_list_has_next(ctx);\n    ok(ret == 0, \"chewing_cand_list_has_next() returns `%d' shall be `%d'\", ret, 0);\n    ret = chewing_cand_list_next(ctx);\n    ok(ret == -1, \"chewing_cand_list_next() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_cand_list_has_prev(ctx);\n    ok(ret == 0, \"chewing_cand_list_has_prev() returns `%d' shall be `%d'\", ret, 0);\n    ret = chewing_cand_list_prev(ctx);\n    ok(ret == -1, \"chewing_cand_list_prev() returns `%d' shall be `%d'\", ret, -1);\n\n    ret = chewing_cand_list_first(ctx);\n    ok(ret == -1, \"chewing_cand_list_first() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_cand_list_last(ctx);\n    ok(ret == -1, \"chewing_cand_list_last() returns `%d' shall be `%d'\", ret, 0);\n\n    chewing_delete(ctx);\n}\n\nvo",
        "begin_line": 671,
        "end_line": 698,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_cand_list#700",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_cand_list()",
        "snippet": "void test_cand_list()\n{\n    test_cand_list_word();\n    test_cand_list_symbol();\n    test_cand_list_no_cand_windows();\n}",
        "begin_line": 700,
        "end_line": 705,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_commit_preedit_normal#707",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_commit_preedit_normal()",
        "snippet": "void test_commit_preedit_normal()\n{\n    static const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ ;\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"hk4g4\" /* \u6e2c\u8a66 */ );\n    ret = chewing_commit_preedit_buf(ctx);\n    ok(ret == 0, \"chewing_commit_preedit_buf() returns `%d' shall be `%d'\", ret, 0);\n\n    ok_preedit_buffer(ctx, \"\");\n    ok_commit_buffer(ctx, phrase);\n\n    chewing_delete(ctx);\n}\n\nvoid t",
        "begin_line": 707,
        "end_line": 724,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_commit_preedit_empty#726",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_commit_preedit_empty()",
        "snippet": "void test_commit_preedit_empty()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    ret = chewing_commit_preedit_buf(ctx);\n    ok(ret == -1, \"chewing_commit_preedit_buf() returns `%d' shall be `%d'\", ret, -1);\n\n    ok_preedit_buffer(ctx, \"\");\n    ok_commit_buffer(ctx, \"\");\n\n    chewing_delete(ctx);\n}",
        "begin_line": 726,
        "end_line": 741,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_commit_preedit_during_cand_selecting#743",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_commit_preedit_during_cand_selecting()",
        "snippet": "void test_commit_preedit_during_cand_selecting()\n{\n    static const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ ;\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"hk4g4\" /* \u6e2c\u8a66 */ );\n\n    ret = chewing_cand_open(ctx);\n    ok(ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_commit_preedit_buf(ctx);\n    ok(ret == -1, \"chewing_commit_preedit_buf() returns `%d' shall be `%d'\", ret, -1);\n\n    ok_preedit_buffer(ctx, phrase);\n    ok_commit_buffer(ctx, \"\");\n\n    chewing_delete(ctx);\n}\n\nvoid t",
        "begin_line": 743,
        "end_line": 764,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_commit_preedit#766",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_commit_preedit()",
        "snippet": "void test_commit_preedit()\n{\n    test_commit_preedit_normal();\n    test_commit_preedit_empty();\n    test_commit_preedit_during_cand_selecting();\n}",
        "begin_line": 766,
        "end_line": 771,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_clean_preedit_normal#773",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_clean_preedit_normal()",
        "snippet": "void test_clean_preedit_normal()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"hk4g4\" /* \u6e2c\u8a66 */ );\n    ret = chewing_clean_preedit_buf(ctx);\n    ok(ret == 0, \"chewing_clean_preedit_buf() returns `%d' shall be `%d'\", ret, 0);\n\n    ok_preedit_buffer(ctx, \"\");\n    ok_commit_buffer(ctx, \"\");\n\n    chewing_delete(ctx);\n}\n\nvo",
        "begin_line": 773,
        "end_line": 789,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_clean_preedit_empty#791",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_clean_preedit_empty()",
        "snippet": "void test_clean_preedit_empty()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    ret = chewing_clean_preedit_buf(ctx);\n    ok(ret == 0, \"chewing_clean_preedit_buf() returns `%d' shall be `%d'\", ret, 0);\n\n    ok_preedit_buffer(ctx, \"\");\n    ok_commit_buffer(ctx, \"\");\n\n    chewing_delete(ctx);\n}",
        "begin_line": 791,
        "end_line": 806,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_clean_preedit_during_cand_selecting#808",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_clean_preedit_during_cand_selecting()",
        "snippet": "void test_clean_preedit_during_cand_selecting()\n{\n    static const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ ;\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"hk4g4\" /* \u6e2c\u8a66 */ );\n\n    ret = chewing_cand_open(ctx);\n    ok(ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0);\n\n    ret = chewing_clean_preedit_buf(ctx);\n    ok(ret == -1, \"chewing_commit_preedit_buf() returns `%d' shall be `%d'\", ret, -1);\n\n    ok_preedit_buffer(ctx, phrase);\n    ok_commit_buffer(ctx, \"\");\n\n    chewing_delete(ctx);\n}\n\nvoid t",
        "begin_line": 808,
        "end_line": 829,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_clean_preedit#831",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_clean_preedit()",
        "snippet": "void test_clean_preedit()\n{\n    test_clean_preedit_normal();\n    test_clean_preedit_empty();\n    test_clean_preedit_during_cand_selecting();\n}",
        "begin_line": 831,
        "end_line": 836,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_clean_bopomofo_normal#838",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_clean_bopomofo_normal()",
        "snippet": "void test_clean_bopomofo_normal()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"hk\" /* \u3118\u311c */ );\n    ret = chewing_clean_bopomofo_buf(ctx);\n    ok(ret == 0, \"chewing_clean_bopomofo_buf() returns `%d' shall be `%d'\", ret, 0);\n\n    ok_bopomofo_buffer(ctx, \"\");\n\n    chewing_delete(ctx);\n}\n\nvo",
        "begin_line": 838,
        "end_line": 853,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_clean_bopomofo_empty#855",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_clean_bopomofo_empty()",
        "snippet": "void test_clean_bopomofo_empty()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    ret = chewing_clean_bopomofo_buf(ctx);\n    ok(ret == 0, \"chewing_clean_bopomofo_buf() returns `%d' shall be `%d'\", ret, 0);\n\n    ok_bopomofo_buffer(ctx, \"\");\n\n    chewing_delete(ctx);\n}",
        "begin_line": 855,
        "end_line": 869,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_clean_bopomofo_after_complete#871",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_clean_bopomofo_after_complete()",
        "snippet": "void test_clean_bopomofo_after_complete()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"hk4\" /* \u3118\u311c\u02cb */ );\n    ret = chewing_clean_bopomofo_buf(ctx);\n    ok(ret == 0, \"chewing_clean_bopomofo_buf() returns `%d' shall be `%d'\", ret, 0);\n\n    ok_preedit_buffer(ctx, \"\\xE5\\x86\\x8A\" /* \u518a */ );\n    ok_bopomofo_buffer(ctx, \"\");\n\n    chewing_delete(ctx);\n}\n\nvoid ",
        "begin_line": 871,
        "end_line": 887,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_clean_bopomofo_during_cand_selecting#889",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_clean_bopomofo_during_cand_selecting()",
        "snippet": "void test_clean_bopomofo_during_cand_selecting()\n{\n    ChewingContext *ctx;\n    int ret;\n\n    ctx = chewing_new();\n    start_testcase(ctx, fd);\n\n    type_keystroke_by_string(ctx, \"hk4g4\" /* \u6e2c\u8a66 */ );\n\n    ret = chewing_cand_open(ctx);\n    ok(ret == 0, \"chewing_cand_open() returns `%d' shall be `%d'\", ret, 0);\n\n    /* XXX: Shall return 0 in select mode? */\n    ret = chewing_clean_bopomofo_buf(ctx);\n    ok(ret == 0, \"chewing_clean_bopomofo_buf() returns `%d' shall be `%d'\", ret, 0);\n\n    ok_bopomofo_buffer(ctx, \"\");\n\n    chewing_delete(ctx);\n}\n\nvo",
        "begin_line": 889,
        "end_line": 909,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.test_clean_bopomofo#911",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.test_clean_bopomofo()",
        "snippet": "void test_clean_bopomofo()\n{\n    test_clean_bopomofo_normal();\n    test_clean_bopomofo_empty();\n    test_clean_bopomofo_after_complete();\n    test_clean_bopomofo_during_cand_selecting();\n}",
        "begin_line": 911,
        "end_line": 917,
        "is_bug": false
    },
    {
        "name": "test.test-keyboardless.main#919",
        "src_path": "test/test-keyboardless.c",
        "class_name": "test.test-keyboardless",
        "signature": "test.test-keyboardless.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    char *logname;\n    int ret;\n\n    putenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n    putenv(\"CHEWING_USER_PATH=\" TEST_HASH_DIR);\n\n    ret = asprintf(&logname, \"%s.log\", argv[0]);\n    if (ret == -1)\n        return -1;\n    fd = fopen(logname, \"w\");\n    assert(fd);\n    free(logname);\n\n\n    test_cand_open();\n    test_cand_close();\n    test_cand_choose();\n    test_cand_list();\n\n    test_commit_preedit();\n    test_clean_preedit();\n\n    test_clean_bopomofo();\n\n    fclose(fd);\n\n    return exit_status();\n}",
        "begin_line": 919,
        "end_line": 948,
        "is_bug": false
    },
    {
        "name": "test.test-struct-size.test_ChewingConfigData#31",
        "src_path": "test/test-struct-size.c",
        "class_name": "test.test-struct-size",
        "signature": "test.test-struct-size.test_ChewingConfigData()",
        "snippet": "void test_ChewingConfigData()\n{\n    size_t expect = sizeof(OrigianlChewingConfigData);\n    size_t actual = sizeof(ChewingConfigData);\n    ok(actual == expect,\n        \"sizeof(ChewingConfigData) = %d shall be %d for ABI compatibility\", actual, expect);\n}",
        "begin_line": 31,
        "end_line": 37,
        "is_bug": false
    },
    {
        "name": "test.test-struct-size.test_IntervalType#39",
        "src_path": "test/test-struct-size.c",
        "class_name": "test.test-struct-size",
        "signature": "test.test-struct-size.test_IntervalType()",
        "snippet": "void test_IntervalType()\n{\n    size_t expect = sizeof(OrigianlIntervalType);\n    size_t actual = sizeof(IntervalType);\n    ok(actual == expect,\n        \"sizeof(IntervalType) = %d shall be %d for ABI compatibility\", actual, expect);\n}",
        "begin_line": 39,
        "end_line": 45,
        "is_bug": false
    },
    {
        "name": "test.test-struct-size.main#47",
        "src_path": "test/test-struct-size.c",
        "class_name": "test.test-struct-size",
        "signature": "test.test-struct-size.main()",
        "snippet": "int main()\n{\n    test_ChewingConfigData();\n    test_IntervalType();\n\n    return exit_status();\n}",
        "begin_line": 47,
        "end_line": 53,
        "is_bug": false
    },
    {
        "name": "test.testchewing.commit_string#20",
        "src_path": "test/testchewing.c",
        "class_name": "test.testchewing",
        "signature": "test.testchewing.commit_string(ChewingContext *ctx)",
        "snippet": "void commit_string(ChewingContext *ctx)\n{\n    char *s;\n\n    if (chewing_commit_Check(ctx)) {\n        s = chewing_commit_String(ctx);\n        printf(\"%s\", s);\n        fflush(stdout);\n        free(s);\n    }\n}",
        "begin_line": 20,
        "end_line": 30,
        "is_bug": false
    },
    {
        "name": "test.testchewing.main#32",
        "src_path": "test/testchewing.c",
        "class_name": "test.testchewing",
        "signature": "test.testchewing.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    ChewingContext *ctx;\n    int i;\n    FILE *fp = stdin;\n\n    /* Initialize libchewing */\n    putenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n    /* for the sake of testing, we should not change existing hash data */\n    putenv(\"CHEWING_USER_PATH=\" TEST_HASH_DIR);\n\n    if (argc == 2) {\n        fp = fopen(argv[1], \"r\");\n        if (!fp) {\n            fprintf(stderr, \"failed to open '%s'\\n\", argv[1]);\n            return 1;\n        }\n    }\n\n    /* Request handle to ChewingContext */\n    ctx = chewing_new();\n\n    /* Set keyboard type */\n    chewing_set_KBType(ctx, chewing_KBStr2Num(\"KB_DEFAULT\"));\n\n    chewing_set_candPerPage(ctx, 9);\n    chewing_set_maxChiSymbolLen(ctx, 16);\n    chewing_set_addPhraseDirection(ctx, 1);\n    chewing_set_selKey(ctx, selKey_define, 10);\n    chewing_set_spaceAsSelection(ctx, 1);\n\n    while (1) {\n        i = get_keystroke(get_char_from_fp, fp);\n        if (i == END)\n            goto end;\n        type_single_keystroke(ctx, i);\n        commit_string(ctx);\n    }\n  end:\n    /* Free Chewing IM handle */\n    chewing_delete(ctx);\n    if (fp)\n        fclose(fp);\n\n    return 0;\n}",
        "begin_line": 32,
        "end_line": 77,
        "is_bug": false
    }
]