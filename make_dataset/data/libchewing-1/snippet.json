[
    {
        "name": "dict.TerminateDict#30",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.TerminateDict(ChewingData *pgdata)",
        "snippet": "void TerminateDict(ChewingData *pgdata)\n{\n    plat_mmap_close(&pgdata->static_data.dict_mmap);\n}",
        "begin_line": 30,
        "end_line": 33,
        "is_bug": false
    },
    {
        "name": "dict.InitDict#35",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.InitDict(ChewingData *pgdata, const char *prefix)",
        "snippet": "int InitDict(ChewingData *pgdata, const char *prefix)\n{\n    char filename[PATH_MAX];\n    size_t len;\n    size_t offset;\n    size_t file_size;\n    size_t csize;\n\n    len = snprintf(filename, sizeof(filename), \"%s\" PLAT_SEPARATOR \"%s\", prefix, DICT_FILE);\n    if (len + 1 > sizeof(filename))\n        return -1;\n\n    plat_mmap_set_invalid(&pgdata->static_data.dict_mmap);\n    file_size = plat_mmap_create(&pgdata->static_data.dict_mmap, filename, FLAG_ATTRIBUTE_READ);\n    if (file_size <= 0)\n        return -1;\n\n    offset = 0;\n    csize = file_size;\n    pgdata->static_data.dict = (const char *) plat_mmap_set_view(&pgdata->static_data.dict_mmap, &offset, &csize);\n    if (!pgdata->static_data.dict)\n        return -1;\n\n    return 0;\n}",
        "begin_line": 35,
        "end_line": 59,
        "is_bug": false
    },
    {
        "name": "dict.GetVocabFromDict#65",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.GetVocabFromDict(ChewingData *pgdata, Phrase *phr_ptr)",
        "snippet": "static void GetVocabFromDict(ChewingData *pgdata, Phrase *phr_ptr)\n{\n    snprintf(phr_ptr->phrase, sizeof(phr_ptr->phrase), \"%s\", pgdata->static_data.dict + GetUint24(pgdata->static_data.tree_cur_pos->phrase.pos));\n    phr_ptr->freq = GetUint24(pgdata->static_data.tree_cur_pos->phrase.freq);\n    pgdata->static_data.tree_cur_pos++;\n}",
        "begin_line": 65,
        "end_line": 70,
        "is_bug": false
    },
    {
        "name": "dict.GetCharFirst#72",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.GetCharFirst(ChewingData *pgdata, Phrase *wrd_ptr, uint16_t key)",
        "snippet": "int GetCharFirst(ChewingData *pgdata, Phrase *wrd_ptr, uint16_t key)\n{\n    /* &key serves as an array whose begin and end are both 0. */\n    const TreeType *pinx = TreeFindPhrase(pgdata, 0, 0, &key);\n\n    if (!pinx)\n        return 0;\n    TreeChildRange(pgdata, pinx);\n    GetVocabFromDict(pgdata, wrd_ptr);\n    return 1;\n}",
        "begin_line": 72,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "dict.GetPhraseFirst#89",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.GetPhraseFirst(ChewingData *pgdata, Phrase *phr_ptr, const TreeType *phrase_parent)",
        "snippet": "int GetPhraseFirst(ChewingData *pgdata, Phrase *phr_ptr, const TreeType *phrase_parent)\n{\n    assert(phrase_parent);\n\n    TreeChildRange(pgdata, phrase_parent);\n    GetVocabFromDict(pgdata, phr_ptr);\n    return 1;\n}",
        "begin_line": 89,
        "end_line": 96,
        "is_bug": false
    },
    {
        "name": "dict.GetVocabNext#98",
        "src_path": "src/dict.c",
        "class_name": "dict",
        "signature": "dict.GetVocabNext(ChewingData *pgdata, Phrase *phr_ptr)",
        "snippet": "int GetVocabNext(ChewingData *pgdata, Phrase *phr_ptr)\n{\n    if (pgdata->static_data.tree_cur_pos >= pgdata->static_data.tree_end_pos\n        || GetUint16(pgdata->static_data.tree_cur_pos->key) != 0)\n        return 0;\n    GetVocabFromDict(pgdata, phr_ptr);\n    return 1;\n}",
        "begin_line": 98,
        "end_line": 105,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_commit_Check#30",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_commit_Check(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_commit_Check(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return ! !(ctx->output->keystrokeRtn & KEYSTROKE_COMMIT);\n}",
        "begin_line": 30,
        "end_line": 42,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_commit_String#50",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_commit_String(const ChewingContext *ctx)",
        "snippet": "CHEWING_API char *chewing_commit_String(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return strdup(\"\");\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return strdup(ctx->output->commitBuf);\n}",
        "begin_line": 50,
        "end_line": 62,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_commit_String_static#70",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_commit_String_static(const ChewingContext *ctx)",
        "snippet": "CHEWING_API const char *chewing_commit_String_static(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return \"\";\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return ctx->output->commitBuf;\n}",
        "begin_line": 70,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_buffer_Check#84",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_buffer_Check(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_buffer_Check(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return (ctx->output->chiSymbolBufLen != 0);\n}",
        "begin_line": 84,
        "end_line": 96,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_buffer_Len#98",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_buffer_Len(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_buffer_Len(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return ctx->output->chiSymbolBufLen;\n}",
        "begin_line": 98,
        "end_line": 110,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_buffer_String#112",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_buffer_String(const ChewingContext *ctx)",
        "snippet": "CHEWING_API char *chewing_buffer_String(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return strdup(\"\");\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return strdup(ctx->output->preeditBuf);\n}",
        "begin_line": 112,
        "end_line": 124,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_buffer_String_static#126",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_buffer_String_static(const ChewingContext *ctx)",
        "snippet": "CHEWING_API const char *chewing_buffer_String_static(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return \"\";\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return ctx->output->preeditBuf;\n}",
        "begin_line": 126,
        "end_line": 138,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_bopomofo_String_static#146",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_bopomofo_String_static(const ChewingContext *ctx)",
        "snippet": "CHEWING_API const char *chewing_bopomofo_String_static(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return \"\";\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return ctx->output->bopomofoBuf;\n}",
        "begin_line": 146,
        "end_line": 158,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_bopomofo_Check#160",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_bopomofo_Check(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_bopomofo_Check(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return ctx->output->bopomofoBuf[0] != 0;\n}",
        "begin_line": 160,
        "end_line": 172,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_cursor_Current#174",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_cursor_Current(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_cursor_Current(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return (ctx->output->chiSymbolCursor);\n}",
        "begin_line": 174,
        "end_line": 186,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_cand_CheckDone#188",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_cand_CheckDone(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_cand_CheckDone(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return (!ctx->output->pci);\n}",
        "begin_line": 188,
        "end_line": 200,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_cand_TotalPage#202",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_cand_TotalPage(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_cand_TotalPage(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return (ctx->output->pci ? ctx->output->pci->nPage : 0);\n}",
        "begin_line": 202,
        "end_line": 214,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_cand_ChoicePerPage#216",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_cand_ChoicePerPage(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_cand_ChoicePerPage(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return (ctx->output->pci ? ctx->output->pci->nChoicePerPage : 0);\n}",
        "begin_line": 216,
        "end_line": 228,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_cand_TotalChoice#230",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_cand_TotalChoice(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_cand_TotalChoice(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return (ctx->output->pci ? ctx->output->pci->nTotalChoice : 0);\n}",
        "begin_line": 230,
        "end_line": 242,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_cand_CurrentPage#244",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_cand_CurrentPage(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_cand_CurrentPage(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return (ctx->output->pci ? ctx->output->pci->pageNo : -1);\n}",
        "begin_line": 244,
        "end_line": 256,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_cand_Enumerate#258",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_cand_Enumerate(ChewingContext *ctx)",
        "snippet": "CHEWING_API void chewing_cand_Enumerate(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    ctx->cand_no = ctx->output->pci->pageNo * ctx->output->pci->nChoicePerPage;\n}",
        "begin_line": 258,
        "end_line": 270,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_cand_hasNext#272",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_cand_hasNext(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_cand_hasNext(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return (ctx->cand_no < ctx->output->pci->nTotalChoice);\n}",
        "begin_line": 272,
        "end_line": 284,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_cand_String_static#286",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_cand_String_static(ChewingContext *ctx)",
        "snippet": "CHEWING_API const char *chewing_cand_String_static(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    const char *s = \"\";\n\n    if (!ctx) {\n        return s;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    if (chewing_cand_hasNext(ctx)) {\n        s = ctx->output->pci->totalChoiceStr[ctx->cand_no];\n        ctx->cand_no++;\n    }\n\n    return s;\n}",
        "begin_line": 286,
        "end_line": 304,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_cand_String#306",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_cand_String(ChewingContext *ctx)",
        "snippet": "CHEWING_API char *chewing_cand_String(ChewingContext *ctx)\n{\n    return strdup(chewing_cand_String_static(ctx));\n}",
        "begin_line": 306,
        "end_line": 309,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_interval_Enumerate#311",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_interval_Enumerate(ChewingContext *ctx)",
        "snippet": "CHEWING_API void chewing_interval_Enumerate(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    ctx->it_no = 0;\n}",
        "begin_line": 311,
        "end_line": 323,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_interval_hasNext#325",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_interval_hasNext(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_interval_hasNext(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return (ctx->it_no < ctx->output->nDispInterval);\n}",
        "begin_line": 325,
        "end_line": 337,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_interval_Get#339",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_interval_Get(ChewingContext *ctx, IntervalType * it)",
        "snippet": "CHEWING_API void chewing_interval_Get(ChewingContext *ctx, IntervalType * it)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    if (chewing_interval_hasNext(ctx)) {\n        if (it) {\n            it->from = ctx->output->dispInterval[ctx->it_no].from;\n            it->to = ctx->output->dispInterval[ctx->it_no].to;\n        }\n        ctx->it_no++;\n    }\n}",
        "begin_line": 339,
        "end_line": 357,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_aux_Check#359",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_aux_Check(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_aux_Check(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return (ctx->data->bShowMsg);\n}",
        "begin_line": 359,
        "end_line": 371,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_aux_Length#373",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_aux_Length(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_aux_Length(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return (ctx->data->bShowMsg ? ctx->data->showMsgLen : 0);\n}",
        "begin_line": 373,
        "end_line": 385,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_aux_String_static#387",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_aux_String_static(const ChewingContext *ctx)",
        "snippet": "CHEWING_API const char *chewing_aux_String_static(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return \"\";\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return ctx->data->showMsg;\n}",
        "begin_line": 387,
        "end_line": 399,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_aux_String#401",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_aux_String(const ChewingContext *ctx)",
        "snippet": "CHEWING_API char *chewing_aux_String(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return strdup(\"\");\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return strdup(chewing_aux_String_static(ctx));\n}",
        "begin_line": 401,
        "end_line": 413,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_keystroke_CheckIgnore#415",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_keystroke_CheckIgnore(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_keystroke_CheckIgnore(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return ! !(ctx->output->keystrokeRtn & KEYSTROKE_IGNORE);\n}",
        "begin_line": 415,
        "end_line": 427,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_keystroke_CheckAbsorb#429",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_keystroke_CheckAbsorb(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_keystroke_CheckAbsorb(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return ! !(ctx->output->keystrokeRtn & KEYSTROKE_ABSORB);\n}",
        "begin_line": 429,
        "end_line": 441,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_kbtype_Total#443",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_kbtype_Total(const ChewingContext *ctx UNUSED)",
        "snippet": "CHEWING_API int chewing_kbtype_Total(const ChewingContext *ctx UNUSED)\n{\n    return KB_TYPE_NUM;\n}",
        "begin_line": 443,
        "end_line": 446,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_kbtype_Enumerate#448",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_kbtype_Enumerate(ChewingContext *ctx)",
        "snippet": "CHEWING_API void chewing_kbtype_Enumerate(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    ctx->kb_no = 0;\n}",
        "begin_line": 448,
        "end_line": 460,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_kbtype_hasNext#462",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_kbtype_hasNext(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_kbtype_hasNext(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return ctx->kb_no < KB_TYPE_NUM;\n}",
        "begin_line": 462,
        "end_line": 474,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_kbtype_String_static#478",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_kbtype_String_static(ChewingContext *ctx)",
        "snippet": "CHEWING_API const char *chewing_kbtype_String_static(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    const char *s = \"\";\n\n    if (!ctx) {\n        return s;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    if (chewing_kbtype_hasNext(ctx)) {\n        s = kb_type_str[ctx->kb_no];\n        ctx->kb_no++;\n    }\n\n    return s;\n}",
        "begin_line": 478,
        "end_line": 496,
        "is_bug": false
    },
    {
        "name": "mod_aux.chewing_kbtype_String#498",
        "src_path": "src/mod_aux.c",
        "class_name": "mod_aux",
        "signature": "mod_aux.chewing_kbtype_String(ChewingContext *ctx)",
        "snippet": "CHEWING_API char *chewing_kbtype_String(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return strdup(\"\");\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    return strdup(chewing_kbtype_String_static(ctx));\n}",
        "begin_line": 498,
        "end_line": 510,
        "is_bug": false
    },
    {
        "name": "tools.dump_database.dump#47",
        "src_path": "src/tools/dump_database.c",
        "class_name": "tools.dump_database",
        "signature": "tools.dump_database.dump(uint32_t node_pos, uint32_t indent)",
        "snippet": "void dump(uint32_t node_pos, uint32_t indent)\n{\n    uint16_t key = 0;\n    uint32_t i;\n\n    for (i = 0; i < indent; i++)\n        fputs(\"    \", stdout);\n\n    key = GetUint16(root[node_pos].key);\n    if (key != 0) {\n        uint32_t beg = GetUint24(root[node_pos].child.begin);\n        uint32_t end = GetUint24(root[node_pos].child.end);\n        assert (beg < end);\n\n        if (indent == 0)\n            printf(\"count=%u,\", key);\n        else {\n            char buf[MAX_UTF8_SIZE * BOPOMOFO_SIZE + 1];\n\n            PhoneFromUint(buf, sizeof(buf), key);\n            printf(\"key=%s,\", buf);\n        }\n        printf(\" begin=%u, end=%u\\n\", beg, end);\n\n        for (i = beg; i < end; i++)\n            dump(i, indent + 1);\n    } else {\n        uint32_t pos = GetUint24(root[node_pos].phrase.pos);\n        uint32_t freq = GetUint24(root[node_pos].phrase.freq);\n\n        printf(\"phrase=%s, freq=%u\\n\", &dict[pos], freq);\n    }\n}",
        "begin_line": 47,
        "end_line": 79,
        "is_bug": false
    },
    {
        "name": "tools.dump_database.read_input#81",
        "src_path": "src/tools/dump_database.c",
        "class_name": "tools.dump_database",
        "signature": "tools.dump_database.read_input(const char *dir_name, const char *base_name, plat_mmap *mmap)",
        "snippet": "void *read_input(const char *dir_name, const char *base_name, plat_mmap *mmap)\n{\n    char filename[PATH_MAX];\n    size_t len;\n    size_t offset;\n    size_t file_size;\n    size_t csize;\n    void *buf = NULL;\n\n    assert(dir_name);\n    assert(base_name);\n\n    len = snprintf(filename, sizeof(filename), \"%s\" PLAT_SEPARATOR \"%s\", dir_name, base_name);\n    if (len + 1 > sizeof(filename)) {\n        fprintf(stderr, \"Too long path %s\" PLAT_SEPARATOR \"%s\\n\", dir_name, base_name);\n        exit(-1);\n    }\n\n    file_size = plat_mmap_create(mmap, filename, FLAG_ATTRIBUTE_READ);\n    if (file_size <= 0) {\n        fprintf(stderr, \"Error opening the file %s\\n\", filename);\n        exit(-1);\n    }\n\n    offset = 0;\n    csize = file_size;\n    buf = plat_mmap_set_view(mmap, &offset, &csize);\n    if (!buf) {\n        fprintf(stderr, \"Error reading the file %s\\n\", filename);\n        exit(-1);\n    }\n\n    return buf;\n}",
        "begin_line": 81,
        "end_line": 114,
        "is_bug": false
    },
    {
        "name": "tools.dump_database.main#116",
        "src_path": "src/tools/dump_database.c",
        "class_name": "tools.dump_database",
        "signature": "tools.dump_database.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    plat_mmap dict_mmap;\n    plat_mmap tree_mmap;\n\n    if (argc != 2) {\n        printf(USAGE, argv[0]);\n        return -1;\n    }\n\n\n    dict = (const char *) read_input(argv[1], DICT_FILE, &dict_mmap);\n    root = (const TreeType *) read_input(argv[1], PHONE_TREE_FILE, &tree_mmap);\n\n    dump(0, 0);\n\n    plat_mmap_close(&dict_mmap);\n    plat_mmap_close(&tree_mmap);\n\n    return 0;\n}",
        "begin_line": 116,
        "end_line": 136,
        "is_bug": false
    },
    {
        "name": "tools.init_database.strip#128",
        "src_path": "src/tools/init_database.c",
        "class_name": "tools.init_database",
        "signature": "tools.init_database.strip(char *line)",
        "snippet": "void strip(char *line)\n{\n    char *end;\n    size_t i;\n\n    /* remove comment */\n    for (i = 0; i < strlen(line); ++i) {\n        if (line[i] == '#') {\n            line[i] = '\\0';\n            break;\n        }\n    }\n\n    /* remove tailing space */\n    end = line + strlen(line) - 1;\n    while (end >= line && isspace((unsigned char) *end)) {\n        *end = 0;\n        --end;\n    }\n}",
        "begin_line": 128,
        "end_line": 147,
        "is_bug": false
    },
    {
        "name": "tools.init_database.compare_word_by_phone#150",
        "src_path": "src/tools/init_database.c",
        "class_name": "tools.init_database",
        "signature": "tools.init_database.compare_word_by_phone(const void *x, const void *y)",
        "snippet": "int compare_word_by_phone(const void *x, const void *y)\n{\n    const WordData *a = (const WordData *) x;\n    const WordData *b = (const WordData *) y;\n\n    if (a->text->phone[0] != b->text->phone[0])\n        return b->text->phone[0] - a->text->phone[0];\n\n    /* Compare original index for stable sort */\n    return b->index - a->index;\n}",
        "begin_line": 150,
        "end_line": 160,
        "is_bug": false
    },
    {
        "name": "tools.init_database.compare_word_by_text#162",
        "src_path": "src/tools/init_database.c",
        "class_name": "tools.init_database",
        "signature": "tools.init_database.compare_word_by_text(const void *x, const void *y)",
        "snippet": "int compare_word_by_text(const void *x, const void *y)\n{\n    const WordData *a = (const WordData *) x;\n    const WordData *b = (const WordData *) y;\n    int ret = strcmp(a->text->phrase, b->text->phrase);\n\n    if (ret != 0)\n        return ret;\n\n    if (a->text->phone[0] != b->text->phone[0])\n        return a->text->phone[0] - b->text->phone[0];\n\n    return 0;\n}",
        "begin_line": 162,
        "end_line": 175,
        "is_bug": false
    },
    {
        "name": "tools.init_database.compare_word_no_duplicated#177",
        "src_path": "src/tools/init_database.c",
        "class_name": "tools.init_database",
        "signature": "tools.init_database.compare_word_no_duplicated(const void *x, const void *y)",
        "snippet": "int compare_word_no_duplicated(const void *x, const void *y)\n{\n    int ret = compare_word_by_text(x, y);\n\n    if (!ret) {\n        const WordData *a = (const WordData *) x;\n\n        fprintf(stderr, \"Duplicated word found (`%s', %d).\\n\", a->text->phrase, a->text->phone[0]);\n        exit(-1);\n    }\n\n    return ret;\n}",
        "begin_line": 177,
        "end_line": 189,
        "is_bug": false
    },
    {
        "name": "tools.init_database.is_exception_phrase#191",
        "src_path": "src/tools/init_database.c",
        "class_name": "tools.init_database",
        "signature": "tools.init_database.is_exception_phrase(PhraseData *phrase, int pos)",
        "snippet": "int is_exception_phrase(PhraseData *phrase, int pos)\n{\n    size_t i;\n    char word[MAX_UTF8_SIZE + 1];\n\n    ueStrNCpy(word, ueStrSeek(phrase->phrase, pos), 1, 1);\n\n    /*\n     * Check if the phrase is an exception phrase.\n     */\n    for (i = 0; i < sizeof(EXCEPTION_PHRASE) / sizeof(EXCEPTION_PHRASE[0]); ++i) {\n        if (strcmp(phrase->phrase, EXCEPTION_PHRASE[i].phrase) == 0 &&\n            memcmp(phrase->phone, EXCEPTION_PHRASE[i].phone, sizeof(phrase->phone)) == 0) {\n            return 1;\n        }\n    }\n\n    /*\n     * Check if the word in phrase is an exception word.\n     */\n    for (i = 0; i < sizeof(EXCEPTION_WORD) / sizeof(EXCEPTION_WORD[0]); ++i) {\n        if (strcmp(word, EXCEPTION_WORD[i].phrase) == 0 && phrase->phone[pos] == EXCEPTION_WORD[i].phone[0]) {\n            return 1;\n        }\n    }\n\n    /*\n     * If the same word appears continuous in a phrase (\u758a\u5b57), the second\n     * word can change to light tone.\n     * ex:\n     * \u7238\u7238 -> \u3105\u311a\u02cb \u3105\u311a\u02d9\n     */\n    if (pos > 0) {\n        char previous[MAX_UTF8_SIZE + 1];\n\n        ueStrNCpy(previous, ueStrSeek(phrase->phrase, pos - 1), 1, 1);\n\n        if (strcmp(previous, word) == 0) {\n            if (((phrase->phone[pos - 1] & ~0x7) | 0x1) == phrase->phone[pos]) {\n                return 1;\n            }\n        }\n    }\n\n    return 0;\n}\n\nvoid store_phras",
        "begin_line": 191,
        "end_line": 236,
        "is_bug": false
    },
    {
        "name": "tools.init_database.store_phrase#238",
        "src_path": "src/tools/init_database.c",
        "class_name": "tools.init_database",
        "signature": "tools.init_database.store_phrase(const char *line, int line_num)",
        "snippet": "void store_phrase(const char *line, int line_num)\n{\n    const char DELIM[] = \" \\t\\n\";\n    char buf[MAX_LINE_LEN];\n    char *phrase;\n    char *freq;\n    char *endptr = NULL;\n    char *bopomofo;\n    char bopomofo_buf[MAX_UTF8_SIZE * BOPOMOFO_SIZE + 1];\n    size_t phrase_len;\n    WordData word;              /* For check. */\n    WordData *found_word = NULL;\n    size_t i, j;\n\n    snprintf(buf, sizeof(buf), \"%s\", line);\n    strip(buf);\n    if (strlen(buf) == 0)\n        return;\n\n    if (num_phrase_data >= top_phrase_data) {\n        fprintf(stderr, \"Need to increase MAX_PHRASE_DATA to process\\n\");\n        exit(-1);\n    }\n\n    /* read phrase */\n    phrase = strtok(buf, DELIM);\n    if (!phrase) {\n        fprintf(stderr, \"Error reading line %d, `%s'\\n\", line_num, line);\n        exit(-1);\n    }\n    strncpy(phrase_data[num_phrase_data].phrase, phrase, sizeof(phrase_data[0].phrase) - 1);\n\n    /* read frequency */\n    freq = strtok(NULL, DELIM);\n    if (!freq) {\n        fprintf(stderr, \"Error reading line %d, `%s'\\n\", line_num, line);\n        exit(-1);\n    }\n\n    phrase_data[num_phrase_data].freq = strtoul(freq, &endptr, 0);\n    if ((*freq == '\\0' || *endptr != '\\0') ||\n        (phrase_data[num_phrase_data].freq == UINT32_MAX && errno == ERANGE)) {\n        fprintf(stderr, \"Error reading frequency `%s' in line %d, `%s'\\n\", freq, line_num, line);\n        exit(-1);\n    }\n\n    /* read bopomofo */\n    for (bopomofo = strtok(NULL, DELIM), phrase_len = 0;\n         bopomofo && phrase_len < MAX_PHRASE_LEN; bopomofo = strtok(NULL, DELIM), ++phrase_len) {\n\n        phrase_data[num_phrase_data].phone[phrase_len] = UintFromPhone(bopomofo);\n        if (phrase_data[num_phrase_data].phone[phrase_len] == 0) {\n            fprintf(stderr, \"Error reading bopomofo `%s' in line %d, `%s'\\n\", bopomofo, line_num, line);\n            exit(-1);\n        }\n    }\n    if (bopomofo) {\n        fprintf(stderr, \"Phrase `%s' too long in line %d\\n\", phrase, line_num);\n    }\n\n    /* check phrase length & bopomofo length */\n    if ((size_t) ueStrLen(phrase_data[num_phrase_data].phrase) != phrase_len) {\n        fprintf(stderr, \"Phrase length and bopomofo length mismatch in line %d, `%s'\\n\", line_num, line);\n        exit(-1);\n    }\n\n    /* Check that each word in phrase can be found in word list. */\n    word.text = ALC(PhraseData, 1);\n\n    assert(word.text);\n    for (i = 0; i < phrase_len; ++i) {\n        ueStrNCpy(word.text->phrase, ueStrSeek(phrase_data[num_phrase_data].phrase, i), 1, 1);\n        word.text->phone[0] = phrase_data[num_phrase_data].phone[i];\n        found_word = bsearch(&word, word_data, num_word_data, sizeof(word), compare_word_by_text);\n        if ((found_word == NULL ||\n             (phrase_len == 1 &&\n              word_matched[found_word - word_data])) && !is_exception_phrase(&phrase_data[num_phrase_data], i)) {\n\n            PhoneFromUint(bopomofo_buf, sizeof(bopomofo_buf), word.text->phone[0]);\n\n            fprintf(stderr, \"Error in phrase `%s'. Word `%s' has no phone %d (%s) in line %d\\n\",\n                    phrase_data[num_phrase_data].phrase, word.text->phrase, word.text->phone[0], bopomofo_buf,\n                    line_num);\n            fprintf(stderr, \"\\tAdd the following struct to EXCEPTION_PHRASE if this is good phrase\\n\\t{\\\"\");\n            for (j = 0; j < strlen(phrase_data[num_phrase_data].phrase); ++j) {\n                fprintf(stderr, \"\\\\x%02X\", (unsigned char) phrase_data[num_phrase_data].phrase[j]);\n            }\n            fprintf(stderr, \"\\\" /* %s */ , 0, {%d\", phrase_data[num_phrase_data].phrase,\n                    phrase_data[num_phrase_data].phone[0]);\n            for (j = 1; j < phrase_len; ++j) {\n                fprintf(stderr, \", %d\", phrase_data[num_phrase_data].phone[j]);\n            }\n            fprintf(stderr, \"} /* \");\n            for (j = 0; j < phrase_len; ++j) {\n                PhoneFromUint(bopomofo_buf, sizeof(bopomofo_buf), phrase_data[num_phrase_data].phone[j]);\n                fprintf(stderr, \"%s \", bopomofo_buf);\n            }\n            fprintf(stderr, \"*/, 0},\\n\");\n            exit(-1);\n        }\n    }\n    free(word.text);\n\n    if (phrase_len >= 2)\n        ++num_phrase_data;\n    else\n        word_matched[found_word - word_data] = 1;\n}",
        "begin_line": 238,
        "end_line": 345,
        "is_bug": false
    },
    {
        "name": "tools.init_database.compare_phrase#347",
        "src_path": "src/tools/init_database.c",
        "class_name": "tools.init_database",
        "signature": "tools.init_database.compare_phrase(const void *x, const void *y)",
        "snippet": "int compare_phrase(const void *x, const void *y)\n{\n    const PhraseData *a = (const PhraseData *) x;\n    const PhraseData *b = (const PhraseData *) y;\n    int cmp = strcmp(a->phrase, b->phrase);\n\n    /* If phrases are different, it returns the result of strcmp(); else it\n     * reports an error when the same phone sequence is found.\n     */\n    if (cmp)\n        return cmp;\n    if (!memcmp(a->phone, b->phone, sizeof(a->phone))) {\n        fprintf(stderr, \"Duplicated phrase `%s' found.\\n\", a->phrase);\n        exit(-1);\n    }\n    return b->freq - a->freq;\n}",
        "begin_line": 347,
        "end_line": 363,
        "is_bug": false
    },
    {
        "name": "tools.init_database.read_tsi_src#365",
        "src_path": "src/tools/init_database.c",
        "class_name": "tools.init_database",
        "signature": "tools.init_database.read_tsi_src(const char *filename)",
        "snippet": "void read_tsi_src(const char *filename)\n{\n    FILE *tsi_src;\n    char buf[MAX_LINE_LEN];\n    int line_num = 0;\n\n    tsi_src = fopen(filename, \"r\");\n    if (!tsi_src) {\n        fprintf(stderr, \"Error opening the file %s\\n\", filename);\n        exit(-1);\n    }\n\n    while (fgets(buf, sizeof(buf), tsi_src)) {\n        ++line_num;\n        store_phrase(buf, line_num);\n    }\n\n    qsort(phrase_data, num_phrase_data, sizeof(phrase_data[0]), compare_phrase);\n    fclose(tsi_src);\n}",
        "begin_line": 365,
        "end_line": 384,
        "is_bug": false
    },
    {
        "name": "tools.init_database.store_word#386",
        "src_path": "src/tools/init_database.c",
        "class_name": "tools.init_database",
        "signature": "tools.init_database.store_word(const char *line, const int line_num)",
        "snippet": "void store_word(const char *line, const int line_num)\n{\n    char phone_buf[MAX_UTF8_SIZE * BOPOMOFO_SIZE + 1];\n    char key_buf[BOPOMOFO_SIZE + 1];\n    char buf[MAX_LINE_LEN + 1] = {0};\n\n    strncpy(buf, line, sizeof(buf) - 1);\n\n    strip(buf);\n    if (strlen(buf) == 0)\n        return;\n\n    if (num_word_data >= MAX_WORD_DATA) {\n        fprintf(stderr, \"Need to increase MAX_WORD_DATA to process\\n\");\n        exit(-1);\n    }\n    if (top_phrase_data <= num_phrase_data) {\n        fprintf(stderr, \"Need to increase MAX_PHRASE_DATA to process\\n\");\n        exit(-1);\n    }\n    word_data[num_word_data].text = &phrase_data[--top_phrase_data];\n\n#define UTF8_FORMAT_STRING(len1, len2) \\\n    \"%\" __stringify(len1) \"[^ ]\" \" \" \\\n    \"%\" __stringify(len2) \"[^ ]\"\n    sscanf(buf, UTF8_FORMAT_STRING(BOPOMOFO_SIZE, MAX_UTF8_SIZE), key_buf, word_data[num_word_data].text->phrase);\n\n    if (strlen(key_buf) > BOPOMOFO_SIZE) {\n        fprintf(stderr, \"Error reading line %d, `%s'\\n\", line_num, line);\n        exit(-1);\n    }\n    PhoneFromKey(phone_buf, key_buf, KB_DEFAULT, 1);\n    word_data[num_word_data].text->phone[0] = UintFromPhone(phone_buf);\n\n    word_data[num_word_data].index = num_word_data;\n    ++num_word_data;\n}",
        "begin_line": 386,
        "end_line": 422,
        "is_bug": false
    },
    {
        "name": "tools.init_database.read_phone_cin#424",
        "src_path": "src/tools/init_database.c",
        "class_name": "tools.init_database",
        "signature": "tools.init_database.read_phone_cin(const char *filename)",
        "snippet": "void read_phone_cin(const char *filename)\n{\n    FILE *phone_cin;\n    char buf[MAX_LINE_LEN];\n    char *ret;\n    int line_num = 0;\n    enum { INIT, HAS_CHARDEF_BEGIN, HAS_CHARDEF_END } status;\n\n    phone_cin = fopen(filename, \"r\");\n    if (!phone_cin) {\n        fprintf(stderr, \"Error opening the file %s\\n\", filename);\n        exit(-1);\n    }\n\n    for (status = INIT; status != HAS_CHARDEF_BEGIN;) {\n        ret = fgets(buf, sizeof(buf), phone_cin);\n        ++line_num;\n        if (!ret) {\n            fprintf(stderr, \"%s: No expected %s %s\\n\", filename, CHARDEF, BEGIN);\n            exit(-1);\n        }\n\n        strip(buf);\n        ret = strtok(buf, \" \\t\");\n        if (!strcmp(ret, CHARDEF)) {\n            ret = strtok(NULL, \" \\t\");\n            if (!strcmp(ret, BEGIN))\n                status = HAS_CHARDEF_BEGIN;\n            else {\n                fprintf(stderr, \"%s:%d: Unexpected %s %s\\n\", filename, line_num, CHARDEF, ret);\n                exit(-1);\n            }\n        }\n    }\n\n    while (status != HAS_CHARDEF_END) {\n        ret = fgets(buf, sizeof(buf), phone_cin);\n        ++line_num;\n        if (!ret) {\n            fprintf(stderr, \"%s: No expected %s %s\\n\", filename, CHARDEF, END);\n            exit(-1);\n        }\n\n        strip(buf);\n        if (!strncmp(buf, CHARDEF, strlen(CHARDEF))) {\n            strtok(buf, \" \\t\");\n            ret = strtok(NULL, \" \\t\");\n            if (!strcmp(ret, END))\n                status = HAS_CHARDEF_END;\n            else {\n                fprintf(stderr, \"%s:%d: Unexpected %s %s\\n\", filename, line_num, CHARDEF, ret);\n                exit(-1);\n            }\n        } else\n            store_word(buf, line_num);\n    }\n\n    fclose(phone_cin);\n\n    qsort(word_data, num_word_data, sizeof(word_data[0]), compare_word_no_duplicated);\n}",
        "begin_line": 424,
        "end_line": 484,
        "is_bug": false
    },
    {
        "name": "tools.init_database.new_node#486",
        "src_path": "src/tools/init_database.c",
        "class_name": "tools.init_database",
        "signature": "tools.init_database.new_node(uint32_t key)",
        "snippet": "NODE *new_node(uint32_t key)\n{\n    NODE *pnew = ALC(NODE, 1);\n\n    if (pnew == NULL) {\n        fprintf(stderr, \"Memory allocation failed on constructing phrase tree.\\n\");\n        exit(-1);\n    }\n\n    memset(&pnew->data, 0, sizeof(pnew->data));\n    PutUint16(key, pnew->data.key);\n    pnew->pFirstChild = NULL;\n    pnew->pNextSibling = NULL;\n    return pnew;\n}",
        "begin_line": 486,
        "end_line": 500,
        "is_bug": false
    },
    {
        "name": "tools.init_database.find_or_insert#507",
        "src_path": "src/tools/init_database.c",
        "class_name": "tools.init_database",
        "signature": "tools.init_database.find_or_insert(NODE * parent, uint32_t key)",
        "snippet": "NODE *find_or_insert(NODE * parent, uint32_t key)\n{\n    NODE *prev = NULL;\n    NODE *p;\n    NODE *pnew;\n\n    for (p = parent->pFirstChild; p && GetUint16(p->data.key) <= key; prev = p, p = p->pNextSibling)\n        if (GetUint16(p->data.key) == key)\n            return p;\n\n    pnew = new_node(key);\n    pnew->pNextSibling = p;\n    if (prev == NULL)\n        parent->pFirstChild = pnew;\n    else\n        prev->pNextSibling = pnew;\n    pnew->pNextSibling = p;\n    return pnew;\n}",
        "begin_line": 507,
        "end_line": 525,
        "is_bug": false
    },
    {
        "name": "tools.init_database.insert_leaf#527",
        "src_path": "src/tools/init_database.c",
        "class_name": "tools.init_database",
        "signature": "tools.init_database.insert_leaf(NODE * parent, long phr_pos, uint32_t freq)",
        "snippet": "void insert_leaf(NODE * parent, long phr_pos, uint32_t freq)\n{\n    NODE *prev = NULL;\n    NODE *p;\n    NODE *pnew;\n\n    for (p = parent->pFirstChild; p && GetUint16(p->data.key) == 0; prev = p, p = p->pNextSibling)\n        if (GetUint16(p->data.phrase.freq) <= freq)\n            break;\n\n    pnew = new_node(0);\n    PutUint24((uint32_t) phr_pos, pnew->data.phrase.pos);\n    PutUint24(freq, pnew->data.phrase.freq);\n    if (prev == NULL)\n        parent->pFirstChild = pnew;\n    else\n        prev->pNextSibling = pnew;\n    pnew->pNextSibling = p;\n}",
        "begin_line": 527,
        "end_line": 545,
        "is_bug": false
    },
    {
        "name": "tools.init_database.construct_phrase_tree#547",
        "src_path": "src/tools/init_database.c",
        "class_name": "tools.init_database",
        "signature": "tools.init_database.construct_phrase_tree()",
        "snippet": "void construct_phrase_tree()\n{\n    NODE *levelPtr;\n    int i;\n    int j;\n\n    /* First, assume that words are in order of their phones and indices. */\n    qsort(word_data, num_word_data, sizeof(word_data[0]), compare_word_by_phone);\n\n    /* Key value of root will become tree_size later. */\n    root = new_node(1);\n\n    /* Second, insert word_data as the first level of children. */\n    for (i = 0; i < num_word_data; i++) {\n        if (i == 0 || word_data[i].text->phone[0] != word_data[i - 1].text->phone[0]) {\n            levelPtr = new_node(word_data[i].text->phone[0]);\n            levelPtr->pNextSibling = root->pFirstChild;\n            root->pFirstChild = levelPtr;\n        }\n        levelPtr = new_node(0);\n        PutUint24((uint32_t) word_data[i].text->pos, levelPtr->data.phrase.pos);\n        PutUint24(word_data[i].text->freq, levelPtr->data.phrase.freq);\n        levelPtr->pNextSibling = root->pFirstChild->pFirstChild;\n        root->pFirstChild->pFirstChild = levelPtr;\n    }\n\n    /* Third, insert phrases having length at least 2. */\n    for (i = 0; i < num_phrase_data; ++i) {\n        levelPtr = root;\n        for (j = 0; phrase_data[i].phone[j] != 0; ++j)\n            levelPtr = find_or_insert(levelPtr, phrase_data[i].phone[j]);\n        insert_leaf(levelPtr, phrase_data[i].pos, phrase_data[i].freq);\n    }\n}",
        "begin_line": 547,
        "end_line": 580,
        "is_bug": false
    },
    {
        "name": "tools.init_database.write_phrase_data#582",
        "src_path": "src/tools/init_database.c",
        "class_name": "tools.init_database",
        "signature": "tools.init_database.write_phrase_data()",
        "snippet": "void write_phrase_data()\n{\n    FILE *dict_file;\n    PhraseData *cur_phr;\n    PhraseData *last_phr = NULL;\n    int i;\n    int j;\n\n    dict_file = fopen(DICT_FILE, \"wb\");\n\n    if (!dict_file) {\n        fprintf(stderr, \"Cannot open output file.\\n\");\n        exit(-1);\n    }\n\n    /*\n     * Duplicate Chinese strings with common pronunciation are detected and\n     * not written into system dictionary. Written phrases are separated by\n     * '\\0', for convenience of mmap usage.\n     * Note: word_data and phrase_data have been qsorted by strcmp in\n     *       reading.\n     */\n    for (i = j = 0; i < num_word_data || j < num_phrase_data; last_phr = cur_phr) {\n        if (i == num_word_data)\n            cur_phr = &phrase_data[j++];\n        else if (j == num_phrase_data)\n            cur_phr = word_data[i++].text;\n        else if (strcmp(word_data[i].text->phrase, phrase_data[j].phrase) < 0)\n            cur_phr = word_data[i++].text;\n        else\n            cur_phr = &phrase_data[j++];\n\n        if (last_phr && !strcmp(cur_phr->phrase, last_phr->phrase))\n            cur_phr->pos = last_phr->pos;\n        else {\n            cur_phr->pos = ftell(dict_file);\n            fwrite(cur_phr->phrase, strlen(cur_phr->phrase) + 1, 1, dict_file);\n        }\n    }\n\n    fclose(dict_file);\n}",
        "begin_line": 582,
        "end_line": 623,
        "is_bug": false
    },
    {
        "name": "tools.init_database.write_index_tree#630",
        "src_path": "src/tools/init_database.c",
        "class_name": "tools.init_database",
        "signature": "tools.init_database.write_index_tree()",
        "snippet": "void write_index_tree()\n{\n    /* (Circular) queue implementation is hidden within this function. */\n    NODE **queue;\n    NODE *p;\n    NODE *pNext;\n    size_t head = 0, tail = 0;\n    size_t tree_size = 1;\n    size_t q_len = num_word_data + num_phrase_data + 1;\n\n    FILE *output = fopen(PHONE_TREE_FILE, \"wb\");\n\n    if (!output) {\n        fprintf(stderr, \"Error opening file \" PHONE_TREE_FILE \" for output.\\n\");\n        exit(-1);\n    }\n\n    queue = ALC(NODE *, q_len);\n    assert(queue);\n\n    queue[head++] = root;\n    while (head != tail) {\n        p = queue[tail++];\n        if (tail >= q_len)\n            tail = 0;\n        if (GetUint16(p->data.key) != 0) {\n            PutUint24(tree_size, p->data.child.begin);\n\n            /*\n             * The latest inserted element must have a NULL\n             * pNextSibling value, and the following code let\n             * it point to the next child list to serialize\n             * them.\n             */\n            if (head == 0)\n                queue[q_len - 1]->pNextSibling = p->pFirstChild;\n            else\n                queue[head - 1]->pNextSibling = p->pFirstChild;\n\n            for (pNext = p->pFirstChild; pNext; pNext = pNext->pNextSibling) {\n                queue[head++] = pNext;\n                if (head == q_len)\n                    head = 0;\n                tree_size++;\n            }\n\n            PutUint24(tree_size, p->data.child.end);\n        }\n    }\n    PutUint16(tree_size, root->data.key);\n\n    for (p = root; p; p = pNext) {\n        fwrite(&p->data, sizeof(TreeType), 1, output);\n        pNext = p->pNextSibling;\n        free(p);\n    }\n    free(queue);\n\n    fclose(output);\n}",
        "begin_line": 630,
        "end_line": 689,
        "is_bug": false
    },
    {
        "name": "tools.init_database.main#691",
        "src_path": "src/tools/init_database.c",
        "class_name": "tools.init_database",
        "signature": "tools.init_database.main(int argc, char *argv[])",
        "snippet": "int main(int argc, char *argv[])\n{\n    if (argc != 3) {\n        printf(USAGE, argv[0]);\n        return -1;\n    }\n\n    read_phone_cin(argv[1]);\n    read_tsi_src(argv[2]);\n    write_phrase_data();\n    construct_phrase_tree();\n    write_index_tree();\n    return 0;\n}",
        "begin_line": 691,
        "end_line": 704,
        "is_bug": false
    },
    {
        "name": "compat.chewing_zuin_Check#23",
        "src_path": "src/compat.c",
        "class_name": "compat",
        "signature": "compat.chewing_zuin_Check(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_zuin_Check(const ChewingContext *ctx)\n{\n    return !chewing_bopomofo_Check(ctx);\n}",
        "begin_line": 23,
        "end_line": 26,
        "is_bug": false
    },
    {
        "name": "compat.chewing_zuin_String#28",
        "src_path": "src/compat.c",
        "class_name": "compat",
        "signature": "compat.chewing_zuin_String(const ChewingContext *ctx, int *bopomofo_count)",
        "snippet": "CHEWING_API char *chewing_zuin_String(const ChewingContext *ctx, int *bopomofo_count)\n{\n    char *s = strdup(chewing_bopomofo_String_static(ctx));\n\n    if (bopomofo_count) {\n        *bopomofo_count = ueStrLen(s);\n    }\n\n    return s;\n}",
        "begin_line": 28,
        "end_line": 37,
        "is_bug": false
    },
    {
        "name": "compat.chewing_Init#39",
        "src_path": "src/compat.c",
        "class_name": "compat",
        "signature": "compat.chewing_Init(const char *dataPath UNUSED, const char *hashPath UNUSED)",
        "snippet": "CHEWING_API int chewing_Init(const char *dataPath UNUSED, const char *hashPath UNUSED)\n{\n    return 0;\n}",
        "begin_line": 39,
        "end_line": 42,
        "is_bug": false
    },
    {
        "name": "compat.chewing_Terminate#44",
        "src_path": "src/compat.c",
        "class_name": "compat",
        "signature": "compat.chewing_Terminate()",
        "snippet": "CHEWING_API void chewing_Terminate()\n{\n}",
        "begin_line": 44,
        "end_line": 46,
        "is_bug": false
    },
    {
        "name": "compat.chewing_Configure#48",
        "src_path": "src/compat.c",
        "class_name": "compat",
        "signature": "compat.chewing_Configure(ChewingContext *ctx, ChewingConfigData * pcd)",
        "snippet": "CHEWING_API int chewing_Configure(ChewingContext *ctx, ChewingConfigData * pcd)\n{\n    chewing_set_candPerPage(ctx, pcd->candPerPage);\n    chewing_set_maxChiSymbolLen(ctx, pcd->maxChiSymbolLen);\n    chewing_set_selKey(ctx, pcd->selKey, MAX_SELKEY);\n    chewing_set_addPhraseDirection(ctx, pcd->bAddPhraseForward);\n    chewing_set_spaceAsSelection(ctx, pcd->bSpaceAsSelection);\n    chewing_set_escCleanAllBuf(ctx, pcd->bEscCleanAllBuf);\n    chewing_set_autoShiftCur(ctx, pcd->bAutoShiftCur);\n    chewing_set_easySymbolInput(ctx, pcd->bEasySymbolInput);\n    chewing_set_phraseChoiceRearward(ctx, pcd->bPhraseChoiceRearward);\n    chewing_set_autoLearn(ctx, pcd->bAutoLearn);\n\n    return 0;\n}",
        "begin_line": 48,
        "end_line": 62,
        "is_bug": false
    },
    {
        "name": "compat.chewing_set_hsuSelKeyType#64",
        "src_path": "src/compat.c",
        "class_name": "compat",
        "signature": "compat.chewing_set_hsuSelKeyType(ChewingContext *ctx UNUSED, int mode UNUSED)",
        "snippet": "CHEWING_API void chewing_set_hsuSelKeyType(ChewingContext *ctx UNUSED, int mode UNUSED)\n{\n}",
        "begin_line": 64,
        "end_line": 66,
        "is_bug": false
    },
    {
        "name": "compat.chewing_get_hsuSelKeyType#68",
        "src_path": "src/compat.c",
        "class_name": "compat",
        "signature": "compat.chewing_get_hsuSelKeyType(ChewingContext *ctx UNUSED)",
        "snippet": "CHEWING_API int chewing_get_hsuSelKeyType(ChewingContext *ctx UNUSED)\n{\n    return 0;\n}",
        "begin_line": 68,
        "end_line": 71,
        "is_bug": false
    },
    {
        "name": "chewingutil.FindEasySymbolIndex#66",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.FindEasySymbolIndex(char ch)",
        "snippet": "static int FindEasySymbolIndex(char ch)\n{\n        /**\n         * '0' => 0, ..., '9' => 9\n         * 'A' => 10, 'B' => 11, ... 'Z' => 35\n         */\n    if (isdigit(ch)) {\n        return ch - '0';\n    } else if (isupper(ch)) {\n        return ch - 'A' + 10;\n    } else {\n        return -1;\n    }\n}",
        "begin_line": 66,
        "end_line": 79,
        "is_bug": false
    },
    {
        "name": "chewingutil.SetUpdatePhraseMsg#81",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.SetUpdatePhraseMsg(ChewingData *pgdata, const char *addWordSeq, int len, int state)",
        "snippet": "void SetUpdatePhraseMsg(ChewingData *pgdata, const char *addWordSeq, int len, int state)\n{\n    if (state == USER_UPDATE_INSERT) {\n        /* \u52a0\u5165\uff1a */\n        snprintf(pgdata->showMsg, sizeof(pgdata->showMsg), \"\\xE5\\x8A\\xA0\\xE5\\x85\\xA5\\xEF\\xBC\\x9A%s\", addWordSeq);\n    } else {\n        /* \u5df2\u6709\uff1a */\n        snprintf(pgdata->showMsg, sizeof(pgdata->showMsg), \"\\xE5\\xB7\\xB2\\xE6\\x9C\\x89\\xEF\\xBC\\x9A%s\", addWordSeq);\n    }\n    pgdata->showMsgLen = AUX_PREFIX_LEN + len;\n}\n\nint NoSymb",
        "begin_line": 81,
        "end_line": 91,
        "is_bug": false
    },
    {
        "name": "chewingutil.NoSymbolBetween#93",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.NoSymbolBetween(ChewingData *pgdata, int begin, int end)",
        "snippet": "int NoSymbolBetween(ChewingData *pgdata, int begin, int end)\n{\n    int i;\n\n    for (i = begin; i < end; ++i) {\n        if (pgdata->preeditBuf[i].category == CHEWING_SYMBOL) {\n            return 0;\n        }\n    }\n\n    return 1;\n}",
        "begin_line": 93,
        "end_line": 104,
        "is_bug": false
    },
    {
        "name": "chewingutil.ChewingIsEntering#106",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ChewingIsEntering(ChewingData *pgdata)",
        "snippet": "int ChewingIsEntering(ChewingData *pgdata)\n{\n    if (pgdata->choiceInfo.isSymbol != WORD_CHOICE)\n        return 1;\n    return (pgdata->chiSymbolBufLen != 0 || BopomofoIsEntering(&(pgdata->bopomofoData)));\n}",
        "begin_line": 106,
        "end_line": 111,
        "is_bug": false
    },
    {
        "name": "chewingutil.HaninSymbolInput#113",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.HaninSymbolInput(ChewingData *pgdata)",
        "snippet": "int HaninSymbolInput(ChewingData *pgdata)\n{\n    unsigned int i;\n\n    ChoiceInfo *pci = &(pgdata->choiceInfo);\n    AvailInfo *pai = &(pgdata->availInfo);\n\n    /* No available symbol table */\n    if (!pgdata->static_data.symbol_table)\n        return BOPOMOFO_ABSORB;\n\n    pci->nTotalChoice = 0;\n    for (i = 0; i < pgdata->static_data.n_symbol_entry; i++) {\n        strcpy(pci->totalChoiceStr[pci->nTotalChoice], pgdata->static_data.symbol_table[i]->category);\n        pci->nTotalChoice++;\n    }\n    pai->avail[0].len = 1;\n    pai->avail[0].id = NULL;\n    pai->nAvail = 1;\n    pai->currentAvail = 0;\n    pci->nChoicePerPage = pgdata->config.candPerPage;\n    assert(pci->nTotalChoice > 0);\n    pci->nPage = CEIL_DIV(pci->nTotalChoice, pci->nChoicePerPage);\n    pci->pageNo = 0;\n    pci->isSymbol = SYMBOL_CATEGORY_CHOICE;\n    return BOPOMOFO_ABSORB;\n}",
        "begin_line": 113,
        "end_line": 139,
        "is_bug": false
    },
    {
        "name": "chewingutil._Inner_InternalSpecialSymbol#141",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil._Inner_InternalSpecialSymbol(int key, ChewingData *pgdata, char symkey, const char *const chibuf)",
        "snippet": "static int _Inner_InternalSpecialSymbol(int key, ChewingData *pgdata, char symkey, const char *const chibuf)\n{\n    int kbtype;\n    PreeditBuf *buf;\n\n    if (key == symkey && NULL != chibuf) {\n        assert(pgdata->chiSymbolBufLen >= pgdata->chiSymbolCursor);\n\n        buf = &pgdata->preeditBuf[pgdata->chiSymbolCursor];\n\n        memmove(&pgdata->preeditBuf[pgdata->chiSymbolCursor + 1],\n                &pgdata->preeditBuf[pgdata->chiSymbolCursor],\n                sizeof(pgdata->preeditBuf[0]) * (pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));\n\n        strncpy(buf->char_, chibuf, sizeof(buf->char_) - 1);\n        buf->category = CHEWING_SYMBOL;\n\n        /* Save Symbol Key */\n        memmove(&(pgdata->symbolKeyBuf[pgdata->chiSymbolCursor + 1]),\n                &(pgdata->symbolKeyBuf[pgdata->chiSymbolCursor]),\n                sizeof(pgdata->symbolKeyBuf[0]) * (pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));\n        pgdata->symbolKeyBuf[pgdata->chiSymbolCursor] = key;\n        pgdata->bUserArrCnnct[PhoneSeqCursor(pgdata)] = 0;\n        pgdata->chiSymbolCursor++;\n        pgdata->chiSymbolBufLen++;\n        /* reset Bopomofo data */\n        /* Don't forget the kbtype */\n        kbtype = pgdata->bopomofoData.kbtype;\n        memset(&(pgdata->bopomofoData), 0, sizeof(BopomofoData));\n        pgdata->bopomofoData.kbtype = kbtype;\n        return 1;\n    }\n    return 0;\n}",
        "begin_line": 141,
        "end_line": 174,
        "is_bug": false
    },
    {
        "name": "chewingutil.InternalSpecialSymbol#176",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.InternalSpecialSymbol(int key, ChewingData *pgdata, int nSpecial, const char keybuf[], const char *const chibuf[])",
        "snippet": "static int InternalSpecialSymbol(int key, ChewingData *pgdata,\n                                 int nSpecial, const char keybuf[], const char *const chibuf[])\n{\n    int i, rtn = BOPOMOFO_IGNORE;   /* very strange and difficult to understand */\n\n    for (i = 0; i < nSpecial; i++) {\n        if (1 == _Inner_InternalSpecialSymbol(key, pgdata, keybuf[i], chibuf[i])) {\n            rtn = BOPOMOFO_ABSORB;\n            break;\n        }\n    }\n    return rtn;\n}",
        "begin_line": 176,
        "end_line": 188,
        "is_bug": false
    },
    {
        "name": "chewingutil.SpecialSymbolInput#190",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.SpecialSymbolInput(int key, ChewingData *pgdata)",
        "snippet": "int SpecialSymbolInput(int key, ChewingData *pgdata)\n{\n    static const char keybuf[] = {\n        '[', ']', '{', '}', '\\'', '<', ':', '\\\"', '>',\n        '~', '!', '@', '#', '$', '%', '^', '&', '*',\n        '(', ')', '_', '+', '=', '\\\\', '|', '?',\n        ',', '.', ';'\n    };\n\n    static const char *const chibuf[] = {\n        \"\\xE3\\x80\\x8C\", \"\\xE3\\x80\\x8D\", \"\\xE3\\x80\\x8E\", \"\\xE3\\x80\\x8F\",\n        /* \"\u300c\", \"\u300d\", \"\u300e\", \"\u300f\" */\n        \"\\xE3\\x80\\x81\", \"\\xEF\\xBC\\x8C\", \"\\xEF\\xBC\\x9A\", \"\\xEF\\xBC\\x9B\",\n        /* \"\u3001\", \"\uff0c\", \"\uff1a\", \"\uff1b\" */\n        \"\\xE3\\x80\\x82\", \"\\xEF\\xBD\\x9E\", \"\\xEF\\xBC\\x81\", \"\\xEF\\xBC\\xA0\",\n        /* \"\u3002\", \"\uff5e\", \"\uff01\", \"\uff20\" */\n        \"\\xEF\\xBC\\x83\", \"\\xEF\\xBC\\x84\", \"\\xEF\\xBC\\x85\", \"\\xEF\\xB8\\xBF\",\n        /* \"\uff03\", \"\uff04\", \"\uff05\", \"\ufe3f\" */\n        \"\\xEF\\xBC\\x86\", \"\\xEF\\xBC\\x8A\", \"\\xEF\\xBC\\x88\", \"\\xEF\\xBC\\x89\",\n        /* \"\uff06\", \"\uff0a\", \"\uff08\", \"\uff09\" */\n        \"\\xE2\\x80\\x94\", \"\\xEF\\xBC\\x8B\", \"\\xEF\\xBC\\x9D\", \"\\xEF\\xBC\\xBC\",\n        /* \"\u2014\", \"\uff0b\", \"\uff1d\", \"\uff3c\" */\n        \"\\xEF\\xBD\\x9C\", \"\\xEF\\xBC\\x9F\", \"\\xEF\\xBC\\x8C\", \"\\xE3\\x80\\x82\",\n        /* \"\uff5c\", \"\uff1f\", \"\uff0c\", \"\u3002\" */\n        \"\\xEF\\xBC\\x9B\"\n            /* \"\uff1b\" */\n    };\n    STATIC_ASSERT(ARRAY_SIZE(keybuf) == ARRAY_SIZE(chibuf));\n\n    return InternalSpecialSymbol(key, pgdata, ARRAY_SIZE(keybuf), keybuf, chibuf);\n}\n\nint FullShapeSymbolInput(int key, ChewingData *pgdata)\n{",
        "begin_line": 190,
        "end_line": 220,
        "is_bug": false
    },
    {
        "name": "chewingutil.FullShapeSymbolInput#222",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.FullShapeSymbolInput(int key, ChewingData *pgdata)",
        "snippet": "int FullShapeSymbolInput(int key, ChewingData *pgdata)\n{\n    int rtn;\n\n    static char keybuf[] = {\n        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n        'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n        'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D',\n        'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\n        'Y', 'Z', ' ', '\\\"', '\\'', '/', '<', '>', '`', '[',\n        ']', '{', '}', '+', '-'\n    };\n    static const char *chibuf[] = {\n        \"\\xEF\\xBC\\x90\", \"\\xEF\\xBC\\x91\", \"\\xEF\\xBC\\x92\", \"\\xEF\\xBC\\x93\",\n        /* \"\uff10\",\"\uff11\",\"\uff12\",\"\uff13\" */\n        \"\\xEF\\xBC\\x94\", \"\\xEF\\xBC\\x95\", \"\\xEF\\xBC\\x96\", \"\\xEF\\xBC\\x97\",\n        /* \"\uff14\",\"\uff15\",\"\uff16\",\"\uff17\" */\n        \"\\xEF\\xBC\\x98\", \"\\xEF\\xBC\\x99\", \"\\xEF\\xBD\\x81\", \"\\xEF\\xBD\\x82\",\n        /* \"\uff18\",\"\uff19\",\"\uff41\",\"\uff42\" */\n        \"\\xEF\\xBD\\x83\", \"\\xEF\\xBD\\x84\", \"\\xEF\\xBD\\x85\", \"\\xEF\\xBD\\x86\",\n        /* \"\uff43\",\"\uff44\",\"\uff45\",\"\uff46\" */\n        \"\\xEF\\xBD\\x87\", \"\\xEF\\xBD\\x88\", \"\\xEF\\xBD\\x89\", \"\\xEF\\xBD\\x8A\",\n        /* \"\uff47\",\"\uff48\",\"\uff49\",\"\uff4a\" */\n        \"\\xEF\\xBD\\x8B\", \"\\xEF\\xBD\\x8C\", \"\\xEF\\xBD\\x8D\", \"\\xEF\\xBD\\x8E\",\n        /* \"\uff4b\",\"\uff4c\",\"\uff4d\",\"\uff4e\" */\n        \"\\xEF\\xBD\\x8F\", \"\\xEF\\xBD\\x90\", \"\\xEF\\xBD\\x91\", \"\\xEF\\xBD\\x92\",\n        /* \"\uff4f\",\"\uff50\",\"\uff51\",\"\uff52\" */\n        \"\\xEF\\xBD\\x93\", \"\\xEF\\xBD\\x94\", \"\\xEF\\xBD\\x95\", \"\\xEF\\xBD\\x96\",\n        /* \"\uff53\",\"\uff54\",\"\uff55\",\"\uff56\" */\n        \"\\xEF\\xBD\\x97\", \"\\xEF\\xBD\\x98\", \"\\xEF\\xBD\\x99\", \"\\xEF\\xBD\\x9A\",\n        /* \"\uff57\",\"\uff58\",\"\uff59\",\"\uff5a\" */\n        \"\\xEF\\xBC\\xA1\", \"\\xEF\\xBC\\xA2\", \"\\xEF\\xBC\\xA3\", \"\\xEF\\xBC\\xA4\",\n        /* \"\uff21\",\"\uff22\",\"\uff23\",\"\uff24\" */\n        \"\\xEF\\xBC\\xA5\", \"\\xEF\\xBC\\xA6\", \"\\xEF\\xBC\\xA7\", \"\\xEF\\xBC\\xA8\",\n        /* \"\uff25\",\"\uff26\",\"\uff27\",\"\uff28\" */\n        \"\\xEF\\xBC\\xA9\", \"\\xEF\\xBC\\xAA\", \"\\xEF\\xBC\\xAB\", \"\\xEF\\xBC\\xAC\",\n        /* \"\uff29\",\"\uff2a\",\"\uff2b\",\"\uff2c\" */\n        \"\\xEF\\xBC\\xAD\", \"\\xEF\\xBC\\xAE\", \"\\xEF\\xBC\\xAF\", \"\\xEF\\xBC\\xB0\",\n        /* \"\uff2d\",\"\uff2e\",\"\uff2f\",\"\uff30\" */\n        \"\\xEF\\xBC\\xB1\", \"\\xEF\\xBC\\xB2\", \"\\xEF\\xBC\\xB3\", \"\\xEF\\xBC\\xB4\",\n        /* \"\uff31\",\"\uff32\",\"\uff33\",\"\uff34\" */\n        \"\\xEF\\xBC\\xB5\", \"\\xEF\\xBC\\xB6\", \"\\xEF\\xBC\\xB7\", \"\\xEF\\xBC\\xB8\",\n        /* \"\uff35\",\"\uff36\",\"\uff37\",\"\uff38\" */\n        \"\\xEF\\xBC\\xB9\", \"\\xEF\\xBC\\xBA\", \"\\xE3\\x80\\x80\", \"\\xE2\\x80\\x9D\",\n        /* \"\uff39\",\"\uff3a\",\"\u3000\",\"\u201d\" */\n        \"\\xE2\\x80\\x99\", \"\\xEF\\xBC\\x8F\", \"\\xEF\\xBC\\x9C\", \"\\xEF\\xBC\\x9E\",\n        /* \"\u2019\",\"\uff0f\",\"\uff1c\",\"\uff1e\" */\n        \"\\xE2\\x80\\xB5\", \"\\xE3\\x80\\x94\", \"\\xE3\\x80\\x95\", \"\\xEF\\xBD\\x9B\",\n        /* \"\u2035\",\"\u3014\"\"\u3015\",\"\uff5b\" */\n        \"\\xEF\\xBD\\x9D\", \"\\xEF\\xBC\\x8B\", \"\\xEF\\xBC\\x8D\"\n            /* \"\uff5d\",\"\uff0b\",\"\uff0d\" */\n    };\n    STATIC_ASSERT(ARRAY_SIZE(keybuf) == ARRAY_SIZE(chibuf));\n\n    rtn = InternalSpecialSymbol(key, pgdata, ARRAY_SIZE(keybuf), keybuf, chibuf);\n    if (rtn == BOPOMOFO_IGNORE)\n        rtn = SpecialSymbolInput(key, pgdata);\n    return (rtn == BOPOMOFO_IGNORE ? SYMBOL_KEY_ERROR : SYMBOL_KEY_OK);\n}\n\nint EasySymbolInput(int key, ChewingData *pgdata)\n{\n    int rtn, loop, _index;\n    char wordbuf[8];\n\n    int nSpecial = EASY_SYMBOL_KEY_TAB_LEN;\n\n  ",
        "begin_line": 222,
        "end_line": 282,
        "is_bug": false
    },
    {
        "name": "chewingutil.EasySymbolInput#284",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.EasySymbolInput(int key, ChewingData *pgdata)",
        "snippet": "int EasySymbolInput(int key, ChewingData *pgdata)\n{\n    int rtn, loop, _index;\n    char wordbuf[8];\n\n    int nSpecial = EASY_SYMBOL_KEY_TAB_LEN;\n\n    _index = FindEasySymbolIndex(key);\n    if (-1 != _index) {\n        for (loop = 0; loop < pgdata->static_data.g_easy_symbol_num[_index]; ++loop) {\n            ueStrNCpy(wordbuf, ueStrSeek(pgdata->static_data.g_easy_symbol_value[_index], loop), 1, 1);\n            (void) _Inner_InternalSpecialSymbol(key, pgdata, key, wordbuf);\n        }\n        return SYMBOL_KEY_OK;\n    }\n\n    rtn = InternalSpecialSymbol(key, pgdata, nSpecial,\n                                G_EASY_SYMBOL_KEY, (const char **) pgdata->static_data.g_easy_symbol_value);\n    if (rtn == BOPOMOFO_IGNORE)\n        rtn = SpecialSymbolInput(key, pgdata);\n    return (rtn == BOPOMOFO_IGNORE ? SYMBOL_KEY_ERROR : SYMBOL_KEY_OK);\n}",
        "begin_line": 284,
        "end_line": 305,
        "is_bug": false
    },
    {
        "name": "chewingutil.SymbolChoice#307",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.SymbolChoice(ChewingData *pgdata, int sel_i)",
        "snippet": "int SymbolChoice(ChewingData *pgdata, int sel_i)\n{\n    int kbtype;\n    int i;\n    int symbol_type;\n    int key;\n\n    if (!pgdata->static_data.symbol_table && pgdata->choiceInfo.isSymbol != SYMBOL_CHOICE_UPDATE)\n        return BOPOMOFO_ABSORB;\n\n    if (pgdata->choiceInfo.isSymbol == SYMBOL_CATEGORY_CHOICE && 0 == pgdata->static_data.symbol_table[sel_i]->nSymbols)\n        symbol_type = SYMBOL_CHOICE_INSERT;\n    else\n        symbol_type = pgdata->choiceInfo.isSymbol;\n\n    /* level one, symbol category */\n    if (symbol_type == SYMBOL_CATEGORY_CHOICE) {\n        ChoiceInfo *pci = &pgdata->choiceInfo;\n        AvailInfo *pai = &pgdata->availInfo;\n\n        /* Display all symbols in this category */\n        pci->nTotalChoice = 0;\n        for (i = 0; i < pgdata->static_data.symbol_table[sel_i]->nSymbols; i++) {\n            ueStrNCpy(pci->totalChoiceStr[pci->nTotalChoice],\n                      pgdata->static_data.symbol_table[sel_i]->symbols[i], 1, 1);\n            pci->nTotalChoice++;\n        }\n        pai->avail[0].len = 1;\n        pai->avail[0].id = NULL;\n        pai->nAvail = 1;\n        pai->currentAvail = 0;\n        pci->nChoicePerPage = pgdata->config.candPerPage;\n        assert(pci->nTotalChoice > 0);\n        pci->nPage = CEIL_DIV(pci->nTotalChoice, pci->nChoicePerPage);\n        pci->pageNo = 0;\n        pci->isSymbol = SYMBOL_CHOICE_INSERT;\n    } else {                    /* level 2 symbol or OpenSymbolChoice */\n        /* TODO: FIXME, this part is buggy! */\n        PreeditBuf *buf = &pgdata->preeditBuf[pgdata->chiSymbolCursor];\n\n        if (symbol_type == SYMBOL_CHOICE_INSERT) {\n            assert(pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen);\n\n            if (pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen ||\n                    pgdata->symbolKeyBuf[pgdata->chiSymbolCursor] != NO_SYM_KEY) {\n                memmove(&pgdata->preeditBuf[pgdata->chiSymbolCursor + 1],\n                        &pgdata->preeditBuf[pgdata->chiSymbolCursor],\n                        sizeof(pgdata->preeditBuf[0]) * (pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));\n            } else {\n                symbol_type = SYMBOL_CHOICE_UPDATE;\n            }\n        }\n        strncpy(buf->char_, pgdata->choiceInfo.totalChoiceStr[sel_i], sizeof(buf->char_) - 1);\n        buf->category = CHEWING_SYMBOL;\n\n        /* This is very strange */\n        key = FindSymbolKey(pgdata->choiceInfo.totalChoiceStr[sel_i]);\n        pgdata->symbolKeyBuf[pgdata->chiSymbolCursor] = key ? key : NO_SYM_KEY;\n\n        pgdata->bUserArrCnnct[PhoneSeqCursor(pgdata)] = 0;\n        ChoiceEndChoice(pgdata);\n        /* Don't forget the kbtype */\n        kbtype = pgdata->bopomofoData.kbtype;\n        memset(&(pgdata->bopomofoData), 0, sizeof(BopomofoData));\n        pgdata->bopomofoData.kbtype = kbtype;\n\n        if (symbol_type == SYMBOL_CHOICE_INSERT) {\n            pgdata->chiSymbolBufLen++;\n            pgdata->chiSymbolCursor++;\n        }\n\n        pgdata->choiceInfo.isSymbol = WORD_CHOICE;\n    }\n    return BOPOMOFO_ABSORB;\n}",
        "begin_line": 307,
        "end_line": 381,
        "is_bug": false
    },
    {
        "name": "chewingutil.SymbolInput#383",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.SymbolInput(int key, ChewingData *pgdata)",
        "snippet": "int SymbolInput(int key, ChewingData *pgdata)\n{\n    if (isprint((char) key) &&  /* other character was ignored */\n        (pgdata->chiSymbolBufLen < MAX_PHONE_SEQ_LEN)) {        /* protect the buffer */\n        PreeditBuf *buf = &pgdata->preeditBuf[pgdata->chiSymbolCursor];\n\n        assert(pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen);\n\n        memmove(&pgdata->preeditBuf[pgdata->chiSymbolCursor + 1],\n                &pgdata->preeditBuf[pgdata->chiSymbolCursor],\n                sizeof(pgdata->preeditBuf[0]) * (pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));\n\n        buf->char_[0] = (char) key;\n        buf->char_[1] = 0;\n        buf->category = CHEWING_SYMBOL;\n\n        /* Save Symbol Key */\n        memmove(&(pgdata->symbolKeyBuf[pgdata->chiSymbolCursor + 1]),\n                &(pgdata->symbolKeyBuf[pgdata->chiSymbolCursor]),\n                sizeof(pgdata->symbolKeyBuf[0]) * (pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));\n        pgdata->symbolKeyBuf[pgdata->chiSymbolCursor] = toupper(key);\n\n        pgdata->bUserArrCnnct[PhoneSeqCursor(pgdata)] = 0;\n        pgdata->chiSymbolCursor++;\n        pgdata->chiSymbolBufLen++;\n        return SYMBOL_KEY_OK;\n    }\n    return SYMBOL_KEY_ERROR;\n}",
        "begin_line": 383,
        "end_line": 411,
        "is_bug": false
    },
    {
        "name": "chewingutil.CompInterval#413",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.CompInterval(const IntervalType * a, const IntervalType * b)",
        "snippet": "static int CompInterval(const IntervalType * a, const IntervalType * b)\n{\n    int cmp = a->from - b->from;\n\n    if (cmp)\n        return cmp;\n    return (a->to - b->to);\n}",
        "begin_line": 413,
        "end_line": 420,
        "is_bug": false
    },
    {
        "name": "chewingutil.FindIntervalFrom#422",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.FindIntervalFrom(int from, IntervalType inte[], int nInte)",
        "snippet": "static int FindIntervalFrom(int from, IntervalType inte[], int nInte)\n{\n    int i;\n\n    for (i = 0; i < nInte; i++)\n        if (inte[i].from == from)\n            return i;\n    return -1;\n}",
        "begin_line": 422,
        "end_line": 430,
        "is_bug": false
    },
    {
        "name": "chewingutil.WriteChiSymbolToCommitBuf#432",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.WriteChiSymbolToCommitBuf(ChewingData *pgdata, ChewingOutput *pgo, int len)",
        "snippet": "void WriteChiSymbolToCommitBuf(ChewingData *pgdata, ChewingOutput *pgo, int len)\n{\n    int i;\n    char *pos;\n\n    assert(pgdata);\n    assert(pgo);\n\n    pgo->commitBufLen = len;\n\n    pos = pgo->commitBuf;\n    for (i = 0; i < pgo->commitBufLen; ++i) {\n        assert(pos + MAX_UTF8_SIZE + 1 < pgo->commitBuf + sizeof(pgo->commitBuf));\n        strcpy(pos, pgdata->preeditBuf[i].char_);\n        pos += strlen(pgdata->preeditBuf[i].char_);\n    }\n    *pos = 0;\n}",
        "begin_line": 432,
        "end_line": 449,
        "is_bug": false
    },
    {
        "name": "chewingutil.CountReleaseNum#451",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.CountReleaseNum(ChewingData *pgdata)",
        "snippet": "static int CountReleaseNum(ChewingData *pgdata)\n{\n    int remain, i;\n\n    remain = pgdata->config.maxChiSymbolLen - pgdata->chiSymbolBufLen;\n    if (remain >= 0)\n        return 0;\n\n    qsort(pgdata->preferInterval, pgdata->nPrefer, sizeof(IntervalType), (CompFuncType) CompInterval);\n\n    if (!ChewingIsChiAt(0, pgdata)) {\n        for (i = 0; i < pgdata->chiSymbolCursor; ++i) {\n            if (ChewingIsChiAt(i, pgdata)) {\n                break;\n            }\n        }\n        return i;\n    }\n\n    i = FindIntervalFrom(0, pgdata->preferInterval, pgdata->nPrefer);\n    if (i >= 0) {\n        return (pgdata->preferInterval[i].to - pgdata->preferInterval[i].from);\n    }\n\n    return 1;\n}",
        "begin_line": 451,
        "end_line": 476,
        "is_bug": false
    },
    {
        "name": "chewingutil.KillFromLeft#478",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.KillFromLeft(ChewingData *pgdata, int nKill)",
        "snippet": "static void KillFromLeft(ChewingData *pgdata, int nKill)\n{\n    int i;\n\n    for (i = 0; i < nKill; i++)\n        ChewingKillChar(pgdata, 0, DECREASE_CURSOR);\n}",
        "begin_line": 478,
        "end_line": 484,
        "is_bug": false
    },
    {
        "name": "chewingutil.CleanAllBuf#486",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.CleanAllBuf(ChewingData *pgdata)",
        "snippet": "void CleanAllBuf(ChewingData *pgdata)\n{\n    /* 1 */\n    pgdata->nPhoneSeq = 0;\n    memset(pgdata->phoneSeq, 0, sizeof(pgdata->phoneSeq));\n    /* 2 */\n    pgdata->chiSymbolBufLen = 0;\n    memset(pgdata->preeditBuf, 0, sizeof(pgdata->preeditBuf));\n    /* 3 */\n    memset(pgdata->bUserArrBrkpt, 0, sizeof(pgdata->bUserArrBrkpt));\n    /* 4 */\n    pgdata->nSelect = 0;\n    /* 5 */\n    pgdata->chiSymbolCursor = 0;\n    /* 6 */\n    memset(pgdata->bUserArrCnnct, 0, sizeof(pgdata->bUserArrCnnct));\n\n    pgdata->phrOut.nNumCut = 0;\n\n    memset(pgdata->symbolKeyBuf, 0, sizeof(pgdata->symbolKeyBuf));\n\n    pgdata->nPrefer = 0;\n}",
        "begin_line": 486,
        "end_line": 508,
        "is_bug": false
    },
    {
        "name": "chewingutil.ReleaseChiSymbolBuf#510",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ReleaseChiSymbolBuf(ChewingData *pgdata, ChewingOutput *pgo)",
        "snippet": "int ReleaseChiSymbolBuf(ChewingData *pgdata, ChewingOutput *pgo)\n{\n    int throwEnd;\n\n    throwEnd = CountReleaseNum(pgdata);\n\n    /*\n     * When current buffer size exceeds maxChiSymbolLen,\n     * we need to throw some of the characters at the head of the buffer and\n     * commit them.\n     */\n    if (throwEnd) {\n        /*\n         * count how many chinese words in \"chiSymbolBuf[ 0 .. (throwEnd - 1)]\"\n         * And release from \"chiSymbolBuf\" && \"phoneSeq\"\n         */\n        WriteChiSymbolToCommitBuf(pgdata, pgo, throwEnd);\n        KillFromLeft(pgdata, throwEnd);\n    }\n    return throwEnd;\n}",
        "begin_line": 510,
        "end_line": 530,
        "is_bug": false
    },
    {
        "name": "chewingutil.ChewingIsBreakPoint#532",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ChewingIsBreakPoint(int cursor, ChewingData *pgdata)",
        "snippet": "static int ChewingIsBreakPoint(int cursor, ChewingData *pgdata)\n{\n    static const char *const BREAK_WORD[] = {\n        \"\\xE6\\x98\\xAF\", \"\\xE7\\x9A\\x84\", \"\\xE4\\xBA\\x86\", \"\\xE4\\xB8\\x8D\",\n        /* \u662f              \u7684              \u4e86              \u4e0d */\n        \"\\xE4\\xB9\\x9F\", \"\\xE8\\x80\\x8C\", \"\\xE4\\xBD\\xA0\", \"\\xE6\\x88\\x91\",\n        /* \u4e5f              \u800c              \u4f60              \u6211 */\n        \"\\xE4\\xBB\\x96\", \"\\xE8\\x88\\x87\", \"\\xE5\\xAE\\x83\", \"\\xE5\\xA5\\xB9\",\n        /* \u4ed6              \u8207              \u5b83              \u5979 */\n        \"\\xE5\\x85\\xB6\", \"\\xE5\\xB0\\xB1\", \"\\xE5\\x92\\x8C\", \"\\xE6\\x88\\x96\",\n        /* \u5176              \u5c31              \u548c              \u6216 */\n        \"\\xE5\\x80\\x91\", \"\\xE6\\x80\\xA7\", \"\\xE5\\x93\\xA1\", \"\\xE5\\xAD\\x90\",\n        /* \u5011              \u6027              \u54e1              \u5b50 */\n        \"\\xE4\\xB8\\x8A\", \"\\xE4\\xB8\\x8B\", \"\\xE4\\xB8\\xAD\", \"\\xE5\\x85\\xA7\",\n        /* \u4e0a              \u4e0b              \u4e2d              \u5167 */\n        \"\\xE5\\xA4\\x96\", \"\\xE5\\x8C\\x96\", \"\\xE8\\x80\\x85\", \"\\xE5\\xAE\\xB6\",\n        /* \u5916              \u5316              \u8005              \u5bb6 */\n        \"\\xE5\\x85\\x92\", \"\\xE5\\xB9\\xB4\", \"\\xE6\\x9C\\x88\", \"\\xE6\\x97\\xA5\",\n        /* \u5152              \u5e74              \u6708              \u65e5 */\n        \"\\xE6\\x99\\x82\", \"\\xE5\\x88\\x86\", \"\\xE7\\xA7\\x92\", \"\\xE8\\xA1\\x97\",\n        /* \u6642              \u5206              \u79d2              \u8857 */\n        \"\\xE8\\xB7\\xAF\", \"\\xE6\\x9D\\x91\",\n        /* \u8def              \u6751 */\n        \"\\xE5\\x9C\\xA8\",\n        /* \u5728 */\n    };\n    size_t i;\n\n    if (!ChewingIsChiAt(cursor, pgdata))\n        return 1;\n\n    for (i = 0; i < ARRAY_SIZE(BREAK_WORD); ++i)\n        if (!strcmp(pgdata->preeditBuf[cursor].char_, BREAK_WORD[i]))\n            return 1;\n\n    return 0;\n}\n\nvoid AutoLearnPhrase(ChewingData *pgdata)\n{\n    uint16_t bufPhoneSeq[MAX_PHO",
        "begin_line": 532,
        "end_line": 568,
        "is_bug": false
    },
    {
        "name": "chewingutil.AutoLearnPhrase#570",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.AutoLearnPhrase(ChewingData *pgdata)",
        "snippet": "void AutoLearnPhrase(ChewingData *pgdata)\n{\n    uint16_t bufPhoneSeq[MAX_PHONE_SEQ_LEN + 1];\n    char bufWordSeq[MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1] = { 0 };\n    char *pos;\n    int i;\n    int from;\n    int fromPreeditBuf;\n    int len;\n    int prev_pos = 0;\n    int pending_pos = 0;\n\n    /*\n     * FIXME: pgdata->preferInterval does not consider symbol, so we need to\n     * do translate when using APIs that considering symbol.\n     */\n\n    UserUpdatePhraseBegin(pgdata);\n\n    for (i = 0; i < pgdata->nPrefer; i++) {\n        from = pgdata->preferInterval[i].from;\n        len = pgdata->preferInterval[i].to - from;\n        fromPreeditBuf = toPreeditBufIndex(pgdata, from);\n\n        LOG_VERBOSE(\"interval from = %d, fromPreeditBuf = %d, len = %d, pending_pos = %d\", from, fromPreeditBuf, len,\n                    pending_pos);\n\n        if (pending_pos != 0 && pending_pos < fromPreeditBuf) {\n            /*\n             * There is a pending phrase in buffer and it is not\n             * connected to current phrase. We store it as\n             * userphrase here.\n             */\n            UserUpdatePhrase(pgdata, bufPhoneSeq, bufWordSeq);\n            prev_pos = 0;\n            pending_pos = 0;\n        }\n\n        if (len == 1 && !ChewingIsBreakPoint(fromPreeditBuf, pgdata)) {\n            /*\n             * There is a length one phrase and it is not a break\n             * point. We store it and try to connect to other length\n             * one phrase if possible.\n             */\n            memcpy(bufPhoneSeq + prev_pos, &pgdata->phoneSeq[from], sizeof(uint16_t) * len);\n            bufPhoneSeq[prev_pos + len] = (uint16_t) 0;\n\n            pos = ueStrSeek(bufWordSeq, prev_pos);\n            copyStringFromPreeditBuf(pgdata, fromPreeditBuf, len, pos, bufWordSeq + sizeof(bufWordSeq) - pos);\n            prev_pos += len;\n            pending_pos = fromPreeditBuf + len;\n\n        } else {\n            if (pending_pos) {\n                /*\n                 * Clean pending phrase because we cannot join\n                 * it with current phrase.\n                 */\n                UserUpdatePhrase(pgdata, bufPhoneSeq, bufWordSeq);\n                prev_pos = 0;\n                pending_pos = 0;\n            }\n            memcpy(bufPhoneSeq, &pgdata->phoneSeq[from], sizeof(uint16_t) * len);\n            bufPhoneSeq[len] = (uint16_t) 0;\n            copyStringFromPreeditBuf(pgdata, fromPreeditBuf, len, bufWordSeq, sizeof(bufWordSeq));\n            UserUpdatePhrase(pgdata, bufPhoneSeq, bufWordSeq);\n        }\n    }\n\n    if (pending_pos) {\n        UserUpdatePhrase(pgdata, bufPhoneSeq, bufWordSeq);\n    }\n\n    UserUpdatePhraseEnd(pgdata);\n}",
        "begin_line": 570,
        "end_line": 644,
        "is_bug": false
    },
    {
        "name": "chewingutil.AddChi#646",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.AddChi(uint16_t phone, uint16_t phoneAlt, ChewingData *pgdata)",
        "snippet": "int AddChi(uint16_t phone, uint16_t phoneAlt, ChewingData *pgdata)\n{\n    int i;\n    int cursor = PhoneSeqCursor(pgdata);\n\n    /* shift the selectInterval */\n    for (i = 0; i < pgdata->nSelect; i++) {\n        if (pgdata->selectInterval[i].from >= cursor) {\n            pgdata->selectInterval[i].from++;\n            pgdata->selectInterval[i].to++;\n        }\n    }\n\n    /* shift the Brkpt */\n    assert(pgdata->nPhoneSeq >= cursor);\n    memmove(&(pgdata->bUserArrBrkpt[cursor + 2]),\n            &(pgdata->bUserArrBrkpt[cursor + 1]), sizeof(int) * (pgdata->nPhoneSeq - cursor));\n    memmove(&(pgdata->bUserArrCnnct[cursor + 2]),\n            &(pgdata->bUserArrCnnct[cursor + 1]), sizeof(int) * (pgdata->nPhoneSeq - cursor));\n\n    /* add to phoneSeq */\n    memmove(&(pgdata->phoneSeq[cursor + 1]),\n            &(pgdata->phoneSeq[cursor]), sizeof(uint16_t) * (pgdata->nPhoneSeq - cursor));\n    pgdata->phoneSeq[cursor] = phone;\n    memmove(&(pgdata->phoneSeqAlt[cursor + 1]),\n            &(pgdata->phoneSeqAlt[cursor]), sizeof(uint16_t) * (pgdata->nPhoneSeq - cursor));\n    pgdata->phoneSeqAlt[cursor] = phoneAlt;\n    pgdata->nPhoneSeq++;\n\n    /* add to chiSymbolBuf */\n    assert(pgdata->chiSymbolBufLen >= pgdata->chiSymbolCursor);\n    memmove(&(pgdata->preeditBuf[pgdata->chiSymbolCursor + 1]),\n            &(pgdata->preeditBuf[pgdata->chiSymbolCursor]),\n            sizeof(pgdata->preeditBuf[0]) * (pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));\n    /* \"0\" means Chinese word */\n    pgdata->preeditBuf[pgdata->chiSymbolCursor].category = CHEWING_CHINESE;\n    pgdata->chiSymbolBufLen++;\n    pgdata->chiSymbolCursor++;\n\n    return 0;\n}",
        "begin_line": 646,
        "end_line": 686,
        "is_bug": false
    },
    {
        "name": "chewingutil.ShowChewingData#688",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ShowChewingData(ChewingData *pgdata)",
        "snippet": "static void ShowChewingData(ChewingData *pgdata)\n{\n    int i;\n\n    DEBUG_OUT(\"nPhoneSeq : %d\\n\" \"phoneSeq  : \", pgdata->nPhoneSeq);\n    for (i = 0; i < pgdata->nPhoneSeq; i++)\n        DEBUG_OUT(\"%hu \", pgdata->phoneSeq[i]);\n    DEBUG_OUT(\"[cursor : %d]\\n\"\n              \"nSelect : %d\\n\" \"selectStr       selectInterval\\n\", PhoneSeqCursor(pgdata), pgdata->nSelect);\n    for (i = 0; i < pgdata->nSelect; i++) {\n        DEBUG_OUT(\"  %14s%4d%4d\\n\", pgdata->selectStr[i], pgdata->selectInterval[i].from, pgdata->selectInterval[i].to);\n    }\n\n    DEBUG_OUT(\"bUserArrCnnct : \");\n    for (i = 0; i <= pgdata->nPhoneSeq; i++)\n        DEBUG_OUT(\"%d \", pgdata->bUserArrCnnct[i]);\n    DEBUG_OUT(\"\\n\");\n\n    DEBUG_OUT(\"bUserArrBrkpt : \");\n    for (i = 0; i <= pgdata->nPhoneSeq; i++)\n        DEBUG_OUT(\"%d \", pgdata->bUserArrBrkpt[i]);\n    DEBUG_OUT(\"\\n\");\n\n    DEBUG_OUT(\"bArrBrkpt     : \");\n    for (i = 0; i <= pgdata->nPhoneSeq; i++)\n        DEBUG_OUT(\"%d \", pgdata->bArrBrkpt[i]);\n    DEBUG_OUT(\"\\n\");\n\n    DEBUG_OUT(\"bChiSym : %d , bSelect : %d\\n\", pgdata->bChiSym, pgdata->bSelect);\n}",
        "begin_line": 688,
        "end_line": 717,
        "is_bug": false
    },
    {
        "name": "chewingutil.CallPhrasing#719",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.CallPhrasing(ChewingData *pgdata, int all_phrasing)",
        "snippet": "int CallPhrasing(ChewingData *pgdata, int all_phrasing)\n{\n    /* set \"bSymbolArrBrkpt\" && \"bArrBrkpt\" */\n    int i, ch_count = 0;\n\n    memcpy(pgdata->bArrBrkpt, pgdata->bUserArrBrkpt, (MAX_PHONE_SEQ_LEN + 1) * sizeof(int));\n    memset(pgdata->bSymbolArrBrkpt, 0, (MAX_PHONE_SEQ_LEN + 1) * sizeof(int));\n\n    for (i = 0; i < pgdata->chiSymbolBufLen; i++) {\n        if (ChewingIsChiAt(i, pgdata))\n            ch_count++;\n        else {\n            pgdata->bArrBrkpt[ch_count] = 1;\n            pgdata->bSymbolArrBrkpt[i] = 1;\n        }\n    }\n\n    /* kill select interval */\n    for (i = 0; i < pgdata->nPhoneSeq; i++) {\n        if (pgdata->bArrBrkpt[i]) {\n            ChewingKillSelectIntervalAcross(i, pgdata);\n        }\n    }\n\n    ShowChewingData(pgdata);\n\n    /* then phrasing */\n    Phrasing(pgdata, all_phrasing);\n\n    /* and then make prefer interval */\n    MakePreferInterval(pgdata);\n\n    return 0;\n}",
        "begin_line": 719,
        "end_line": 752,
        "is_bug": false
    },
    {
        "name": "chewingutil.Union#755",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.Union(int set1, int set2, int parent[])",
        "snippet": "static void Union(int set1, int set2, int parent[])\n{\n    if (set1 != set2)\n        parent[max(set1, set2)] = min(set1, set2);\n}",
        "begin_line": 755,
        "end_line": 759,
        "is_bug": false
    },
    {
        "name": "chewingutil.SameSet#761",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.SameSet(int set1, int set2, int parent[])",
        "snippet": "static int SameSet(int set1, int set2, int parent[])\n{\n    while (parent[set1] != 0) {\n        set1 = parent[set1];\n    }\n    while (parent[set2] != 0) {\n        set2 = parent[set2];\n    }\n    return (set1 == set2);\n}",
        "begin_line": 761,
        "end_line": 770,
        "is_bug": false
    },
    {
        "name": "chewingutil.MakePreferInterval#773",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.MakePreferInterval(ChewingData *pgdata)",
        "snippet": "static void MakePreferInterval(ChewingData *pgdata)\n{\n    int i, j, set_no;\n    int belong_set[MAX_PHONE_SEQ_LEN + 1];\n    int parent[MAX_PHONE_SEQ_LEN + 1];\n\n    memset(belong_set, 0, sizeof(int) * (MAX_PHONE_SEQ_LEN + 1));\n    memset(parent, 0, sizeof(int) * (MAX_PHONE_SEQ_LEN + 1));\n\n    /* for each interval */\n    for (i = 0; i < pgdata->phrOut.nDispInterval; i++) {\n        for (j = pgdata->phrOut.dispInterval[i].from; j < pgdata->phrOut.dispInterval[i].to; j++) {\n            belong_set[j] = i + 1;\n        }\n    }\n    set_no = i + 1;\n    for (i = 0; i < pgdata->nPhoneSeq; i++)\n        if (belong_set[i] == 0)\n            belong_set[i] = set_no++;\n\n    /* for each connect point */\n    for (i = 1; i < pgdata->nPhoneSeq; i++) {\n        if (pgdata->bUserArrCnnct[i]) {\n            Union(belong_set[i - 1], belong_set[i], parent);\n        }\n    }\n\n    /* generate new intervals */\n    pgdata->nPrefer = 0;\n    i = 0;\n    while (i < pgdata->nPhoneSeq) {\n        for (j = i + 1; j < pgdata->nPhoneSeq; j++)\n            if (!SameSet(belong_set[i], belong_set[j], parent))\n                break;\n\n        pgdata->preferInterval[pgdata->nPrefer].from = i;\n        pgdata->preferInterval[pgdata->nPrefer].to = j;\n        pgdata->nPrefer++;\n        i = j;\n    }\n}",
        "begin_line": 773,
        "end_line": 813,
        "is_bug": false
    },
    {
        "name": "chewingutil.ShiftInterval#816",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ShiftInterval(ChewingOutput *pgo, ChewingData *pgdata)",
        "snippet": "static void ShiftInterval(ChewingOutput *pgo, ChewingData *pgdata)\n{\n    int i, arrPos[MAX_PHONE_SEQ_LEN], k = 0, from, len;\n\n    for (i = 0; i < pgdata->chiSymbolBufLen; i++) {\n        if (ChewingIsChiAt(i, pgdata)) {\n            arrPos[k++] = i;\n        }\n    }\n    arrPos[k] = i;\n\n    pgo->nDispInterval = pgdata->nPrefer;\n    for (i = 0; i < pgdata->nPrefer; i++) {\n        from = pgdata->preferInterval[i].from;\n        len = pgdata->preferInterval[i].to - from;\n        pgo->dispInterval[i].from = arrPos[from];\n        pgo->dispInterval[i].to = arrPos[from] + len;\n    }\n}",
        "begin_line": 816,
        "end_line": 834,
        "is_bug": false
    },
    {
        "name": "chewingutil.MakeOutput#836",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.MakeOutput(ChewingOutput *pgo, ChewingData *pgdata)",
        "snippet": "int MakeOutput(ChewingOutput *pgo, ChewingData *pgdata)\n{\n    int i;\n    int inx;\n    char *pos;\n\n    /* fill zero to chiSymbolBuf first */\n    pgo->preeditBuf[0] = 0;\n    pgo->bopomofoBuf[0] = 0;\n\n    pos = pgo->preeditBuf;\n    for (i = 0; i < pgdata->chiSymbolBufLen && pos < pgo->preeditBuf + sizeof(pgo->preeditBuf) + MAX_UTF8_SIZE + 1; ++i) {\n        strncpy(pos, pgdata->preeditBuf[i].char_, MAX_UTF8_SIZE + 1);\n        pos += strlen(pgdata->preeditBuf[i].char_);\n    }\n\n    /* fill point */\n    pgo->PointStart = pgdata->PointStart;\n    pgo->PointEnd = pgdata->PointEnd;\n\n    /* fill other fields */\n    pgo->chiSymbolBufLen = pgdata->chiSymbolBufLen;\n    pgo->chiSymbolCursor = pgdata->chiSymbolCursor;\n\n    /* fill bopomofoBuf */\n    if (pgdata->bopomofoData.kbtype >= KB_HANYU_PINYIN) {\n        strcpy(pgo->bopomofoBuf, pgdata->bopomofoData.pinYinData.keySeq);\n    } else {\n        for (i = 0; i < BOPOMOFO_SIZE; i++) {\n            inx = pgdata->bopomofoData.pho_inx[i];\n            if (inx != 0) {\n                ueStrNCpy(pgo->bopomofoBuf + strlen(pgo->bopomofoBuf),\n                          ueConstStrSeek(zhuin_tab[i], inx - 1),\n                          1, STRNCPY_CLOSE);\n            }\n        }\n    }\n\n    ShiftInterval(pgo, pgdata);\n    memcpy(pgo->dispBrkpt, pgdata->bUserArrBrkpt, sizeof(pgo->dispBrkpt[0]) * (MAX_PHONE_SEQ_LEN + 1));\n    pgo->pci = &(pgdata->choiceInfo);\n    pgo->bChiSym = pgdata->bChiSym;\n    memcpy(pgo->selKey, pgdata->config.selKey, sizeof(pgdata->config.selKey));\n    pgdata->bShowMsg = 0;\n    return 0;\n}",
        "begin_line": 836,
        "end_line": 881,
        "is_bug": false
    },
    {
        "name": "chewingutil.MakeOutputWithRtn#883",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.MakeOutputWithRtn(ChewingOutput *pgo, ChewingData *pgdata, int keystrokeRtn)",
        "snippet": "int MakeOutputWithRtn(ChewingOutput *pgo, ChewingData *pgdata, int keystrokeRtn)\n{\n    pgo->keystrokeRtn = keystrokeRtn;\n    return MakeOutput(pgo, pgdata);\n}",
        "begin_line": 883,
        "end_line": 887,
        "is_bug": false
    },
    {
        "name": "chewingutil.MakeOutputAddMsgAndCleanInterval#889",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.MakeOutputAddMsgAndCleanInterval(ChewingOutput *pgo, ChewingData *pgdata)",
        "snippet": "void MakeOutputAddMsgAndCleanInterval(ChewingOutput *pgo, ChewingData *pgdata)\n{\n    pgdata->bShowMsg = 1;\n    pgo->nDispInterval = 0;\n}",
        "begin_line": 889,
        "end_line": 893,
        "is_bug": false
    },
    {
        "name": "chewingutil.AddSelect#895",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.AddSelect(ChewingData *pgdata, int sel_i)",
        "snippet": "int AddSelect(ChewingData *pgdata, int sel_i)\n{\n    int length, nSelect, cursor;\n\n    /* save the typing time */\n    length = pgdata->availInfo.avail[pgdata->availInfo.currentAvail].len;\n    nSelect = pgdata->nSelect;\n\n    /* change \"selectStr\" , \"selectInterval\" , and \"nSelect\" of ChewingData */\n    ueStrNCpy(pgdata->selectStr[nSelect], pgdata->choiceInfo.totalChoiceStr[sel_i], length, 1);\n    cursor = PhoneSeqCursor(pgdata);\n    pgdata->selectInterval[nSelect].from = cursor;\n    pgdata->selectInterval[nSelect].to = cursor + length;\n    pgdata->nSelect++;\n    return 0;\n}",
        "begin_line": 895,
        "end_line": 910,
        "is_bug": false
    },
    {
        "name": "chewingutil.CountSelKeyNum#912",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.CountSelKeyNum(int key, const ChewingData *pgdata)         /* return value starts from 0.  If less than zero : error key */",
        "snippet": "int CountSelKeyNum(int key, const ChewingData *pgdata)\n        /* return value starts from 0.  If less than zero : error key */\n{\n    int i;\n\n    for (i = 0; i < MAX_SELKEY; i++)\n        if (pgdata->config.selKey[i] == key)\n            return i;\n    return -1;\n}",
        "begin_line": 912,
        "end_line": 921,
        "is_bug": false
    },
    {
        "name": "chewingutil.CountSymbols#923",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.CountSymbols(ChewingData *pgdata, int to)",
        "snippet": "int CountSymbols(ChewingData *pgdata, int to)\n{\n    int chi;\n    int i;\n\n    for (chi = i = 0; i < to; i++) {\n        if (ChewingIsChiAt(i, pgdata))\n            chi++;\n    }\n    return to - chi;\n}",
        "begin_line": 923,
        "end_line": 933,
        "is_bug": false
    },
    {
        "name": "chewingutil.PhoneSeqCursor#935",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.PhoneSeqCursor(ChewingData *pgdata)",
        "snippet": "int PhoneSeqCursor(ChewingData *pgdata)\n{\n    int cursor = pgdata->chiSymbolCursor - CountSymbols(pgdata, pgdata->chiSymbolCursor);\n\n    return cursor > 0 ? cursor : 0;\n}",
        "begin_line": 935,
        "end_line": 940,
        "is_bug": false
    },
    {
        "name": "chewingutil.ChewingIsChiAt#942",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ChewingIsChiAt(int chiSymbolCursor, ChewingData *pgdata)",
        "snippet": "int ChewingIsChiAt(int chiSymbolCursor, ChewingData *pgdata)\n{\n    assert(0 <= chiSymbolCursor);\n    assert(chiSymbolCursor < ARRAY_SIZE(pgdata->preeditBuf));\n    return pgdata->preeditBuf[chiSymbolCursor].category == CHEWING_CHINESE;\n}",
        "begin_line": 942,
        "end_line": 947,
        "is_bug": false
    },
    {
        "name": "chewingutil.RemoveSelectElement#949",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.RemoveSelectElement(int i, ChewingData *pgdata)",
        "snippet": "void RemoveSelectElement(int i, ChewingData *pgdata)\n{\n    if (--pgdata->nSelect == i)\n        return;\n    pgdata->selectInterval[i] = pgdata->selectInterval[pgdata->nSelect];\n    strcpy(pgdata->selectStr[i], pgdata->selectStr[pgdata->nSelect]);\n}",
        "begin_line": 949,
        "end_line": 955,
        "is_bug": false
    },
    {
        "name": "chewingutil.ChewingKillSelectIntervalAcross#957",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ChewingKillSelectIntervalAcross(int cursor, ChewingData *pgdata)",
        "snippet": "static int ChewingKillSelectIntervalAcross(int cursor, ChewingData *pgdata)\n{\n    int i;\n\n    for (i = 0; i < pgdata->nSelect; i++) {\n        if (pgdata->selectInterval[i].from < cursor && pgdata->selectInterval[i].to > cursor) {\n            RemoveSelectElement(i, pgdata);\n            i--;\n        }\n    }\n    return 0;\n}",
        "begin_line": 957,
        "end_line": 968,
        "is_bug": false
    },
    {
        "name": "chewingutil.KillCharInSelectIntervalAndBrkpt#970",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.KillCharInSelectIntervalAndBrkpt(ChewingData *pgdata, int cursorToKill)",
        "snippet": "static int KillCharInSelectIntervalAndBrkpt(ChewingData *pgdata, int cursorToKill)\n{\n    int i;\n\n    for (i = 0; i < pgdata->nSelect; i++) {\n        if (pgdata->selectInterval[i].from <= cursorToKill && pgdata->selectInterval[i].to > cursorToKill) {\n            RemoveSelectElement(i, pgdata);\n            i--;                /* the last one was swap to i, we need to recheck i */\n        } else if (pgdata->selectInterval[i].from > cursorToKill) {\n            pgdata->selectInterval[i].from--;\n            pgdata->selectInterval[i].to--;\n        }\n    }\n    assert(pgdata->nPhoneSeq >= cursorToKill);\n    memmove(&(pgdata->bUserArrBrkpt[cursorToKill]),\n            &(pgdata->bUserArrBrkpt[cursorToKill + 1]), sizeof(int) * (pgdata->nPhoneSeq - cursorToKill));\n    memmove(&(pgdata->bUserArrCnnct[cursorToKill]),\n            &(pgdata->bUserArrCnnct[cursorToKill + 1]), sizeof(int) * (pgdata->nPhoneSeq - cursorToKill));\n\n    return 0;\n}",
        "begin_line": 970,
        "end_line": 990,
        "is_bug": false
    },
    {
        "name": "chewingutil.ChewingKillChar#992",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.ChewingKillChar(ChewingData *pgdata, int chiSymbolCursorToKill, int minus)",
        "snippet": "int ChewingKillChar(ChewingData *pgdata, int chiSymbolCursorToKill, int minus)\n{\n    int tmp, cursorToKill;\n\n    tmp = pgdata->chiSymbolCursor;\n    pgdata->chiSymbolCursor = chiSymbolCursorToKill;\n    cursorToKill = PhoneSeqCursor(pgdata);\n    pgdata->chiSymbolCursor = tmp;\n    if (ChewingIsChiAt(chiSymbolCursorToKill, pgdata)) {\n        KillCharInSelectIntervalAndBrkpt(pgdata, cursorToKill);\n        assert(pgdata->nPhoneSeq - cursorToKill - 1 >= 0);\n        memmove(&(pgdata->phoneSeq[cursorToKill]),\n                &(pgdata->phoneSeq[cursorToKill + 1]), (pgdata->nPhoneSeq - cursorToKill - 1) * sizeof(uint16_t));\n        pgdata->nPhoneSeq--;\n    }\n    pgdata->symbolKeyBuf[chiSymbolCursorToKill] = 0;\n    assert(pgdata->chiSymbolBufLen - chiSymbolCursorToKill);\n    memmove(&pgdata->symbolKeyBuf[chiSymbolCursorToKill],\n            &pgdata->symbolKeyBuf[chiSymbolCursorToKill + 1],\n            sizeof(pgdata->symbolKeyBuf[0]) * (pgdata->chiSymbolBufLen - chiSymbolCursorToKill));\n    memmove(&pgdata->preeditBuf[chiSymbolCursorToKill],\n            &pgdata->preeditBuf[chiSymbolCursorToKill + 1],\n            sizeof(pgdata->preeditBuf[0]) * (pgdata->chiSymbolBufLen - chiSymbolCursorToKill));\n    pgdata->chiSymbolBufLen--;\n    pgdata->chiSymbolCursor -= minus;\n    if (pgdata->chiSymbolCursor < 0)\n        pgdata->chiSymbolCursor = 0;\n    return 0;\n}",
        "begin_line": 992,
        "end_line": 1020,
        "is_bug": false
    },
    {
        "name": "chewingutil.IsPreferIntervalConnted#1022",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.IsPreferIntervalConnted(int cursor, ChewingData *pgdata)",
        "snippet": "int IsPreferIntervalConnted(int cursor, ChewingData *pgdata)\n{\n    int i;\n\n    for (i = 0; i < pgdata->nPrefer; i++) {\n        if (pgdata->preferInterval[i].from < cursor && pgdata->preferInterval[i].to > cursor)\n            return 1;\n    }\n    return 0;\n}",
        "begin_line": 1022,
        "end_line": 1031,
        "is_bug": false
    },
    {
        "name": "chewingutil.FindSymbolKey#1191",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.FindSymbolKey(const char *symbol)",
        "snippet": "static int FindSymbolKey(const char *symbol)\n{\n    unsigned int i;\n    const char *const *buf;\n\n    for (i = 0; i < ARRAY_SIZE(symbol_buf); ++i) {\n        for (buf = symbol_buf[i]; *buf; ++buf) {\n            if (0 == strcmp(*buf, symbol))\n                return *symbol_buf[i][0];\n        }\n    }\n    return 0;\n}",
        "begin_line": 1191,
        "end_line": 1203,
        "is_bug": false
    },
    {
        "name": "chewingutil.OpenSymbolChoice#1205",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.OpenSymbolChoice(ChewingData *pgdata)",
        "snippet": "int OpenSymbolChoice(ChewingData *pgdata)\n{\n    int i, symbol_buf_len = ARRAY_SIZE(symbol_buf);\n    const char *const *pBuf;\n    ChoiceInfo *pci = &(pgdata->choiceInfo);\n\n    pci->oldChiSymbolCursor = pgdata->chiSymbolCursor;\n\n    /* see if there is some word in the cursor position */\n    if (pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen && pgdata->chiSymbolCursor > 0)\n        pgdata->chiSymbolCursor--;\n    if (pgdata->symbolKeyBuf[pgdata->chiSymbolCursor] == NO_SYM_KEY) {\n        pgdata->bSelect = 1;\n        HaninSymbolInput(pgdata);\n        return 0;\n    }\n    for (i = 0; i < symbol_buf_len; i++) {\n        if (symbol_buf[i][0][0] == pgdata->symbolKeyBuf[pgdata->chiSymbolCursor]) {\n            pBuf = symbol_buf[i];\n            break;\n        }\n    }\n    if (i == symbol_buf_len) {\n        ChoiceEndChoice(pgdata);\n        return 0;\n    }\n    pci->nTotalChoice = 0;\n    for (i = 1; pBuf[i]; i++) {\n        ueStrNCpy(pci->totalChoiceStr[pci->nTotalChoice], pBuf[i], ueStrLen(pBuf[i]), 1);\n        pci->nTotalChoice++;\n    }\n\n    pci->nChoicePerPage = pgdata->config.candPerPage;\n    assert(pci->nTotalChoice > 0);\n    pci->nPage = CEIL_DIV(pci->nTotalChoice, pci->nChoicePerPage);\n    pci->pageNo = 0;\n    pci->isSymbol = SYMBOL_CHOICE_UPDATE;\n\n    pgdata->bSelect = 1;\n    pgdata->availInfo.nAvail = 1;\n    pgdata->availInfo.currentAvail = 0;\n    pgdata->availInfo.avail[0].id = NULL;\n    pgdata->availInfo.avail[0].len = 1;\n    return 0;\n}",
        "begin_line": 1205,
        "end_line": 1249,
        "is_bug": false
    },
    {
        "name": "chewingutil.InitSymbolTable#1251",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.InitSymbolTable(ChewingData *pgdata, const char *prefix)",
        "snippet": "int InitSymbolTable(ChewingData *pgdata, const char *prefix)\n{\n    static const unsigned int MAX_SYMBOL_ENTRY = 100;\n    static const size_t LINE_LEN = 512; // shall be long enough?\n\n    char *filename = NULL;\n    FILE *file = NULL;\n    char *line = NULL;\n    SymbolEntry **entry = NULL;\n    char *category_end;\n    const char *symbols;\n    char *symbols_end;\n    const char *symbol;\n    size_t i;\n    size_t len;\n    size_t size;\n    int ret = -1;\n\n    pgdata->static_data.n_symbol_entry = 0;\n    pgdata->static_data.symbol_table = NULL;\n\n    ret = asprintf(&filename, \"%s\" PLAT_SEPARATOR \"%s\", prefix, SYMBOL_TABLE_FILE);\n    if (ret == -1)\n        goto error;\n\n    file = fopen(filename, \"r\");\n    if (!file)\n        goto error;\n\n    line = ALC(char, LINE_LEN);\n\n    if (!line)\n        goto error;\n\n    entry = ALC(SymbolEntry *, MAX_SYMBOL_ENTRY);\n\n    if (!entry)\n        goto error;\n\n    while (fgets(line, LINE_LEN, file) && pgdata->static_data.n_symbol_entry < MAX_SYMBOL_ENTRY) {\n\n        category_end = strpbrk(line, \"=\\r\\n\");\n        if (!category_end)\n            goto error;\n\n        symbols = category_end + 1;\n        symbols_end = strpbrk(symbols, \"\\r\\n\");\n        if (symbols_end) {\n            *symbols_end = 0;\n            len = ueStrLen(symbols);\n\n            entry[pgdata->static_data.n_symbol_entry] =\n                (SymbolEntry *) malloc(sizeof(entry[0][0]) + sizeof(entry[0][0].symbols[0]) * len);\n            if (!entry[pgdata->static_data.n_symbol_entry])\n                goto error;\n            entry[pgdata->static_data.n_symbol_entry]\n                ->nSymbols = len;\n\n            symbol = symbols;\n\n            for (i = 0; i < len; ++i) {\n                ueStrNCpy(entry[pgdata->static_data.n_symbol_entry]->symbols[i], symbol, 1, 1);\n                // FIXME: What if symbol is combining sequences.\n                symbol += ueBytesFromChar(symbol[0]);\n            }\n\n\n        } else {\n            entry[pgdata->static_data.n_symbol_entry] = (SymbolEntry *) malloc(sizeof(entry[0][0]));\n            if (!entry[pgdata->static_data.n_symbol_entry])\n                goto error;\n\n            entry[pgdata->static_data.n_symbol_entry]\n                ->nSymbols = 0;\n        }\n\n        *category_end = 0;\n        ueStrNCpy(entry[pgdata->static_data.n_symbol_entry]->category, line, MAX_PHRASE_LEN, 1);\n\n        ++pgdata->static_data.n_symbol_entry;\n    }\n\n    size = sizeof(*pgdata->static_data.symbol_table) * pgdata->static_data.n_symbol_entry;\n    if (!size)\n        goto end;\n    pgdata->static_data.symbol_table = (SymbolEntry **) malloc(size);\n    if (!pgdata->static_data.symbol_table)\n        goto error;\n    memcpy(pgdata->static_data.symbol_table, entry, size);\n\n    ret = 0;\n  end:\n    free(entry);\n    free(line);\n    fclose(file);\n    free(filename);\n    return ret;\n\n  error:\n    for (i = 0; i < pgdata->static_data.n_symbol_entry; ++i) {\n        free(entry[i]);\n    }\n    goto end;\n}",
        "begin_line": 1251,
        "end_line": 1354,
        "is_bug": false
    },
    {
        "name": "chewingutil.TerminateSymbolTable#1356",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.TerminateSymbolTable(ChewingData *pgdata)",
        "snippet": "void TerminateSymbolTable(ChewingData *pgdata)\n{\n    unsigned int i;\n\n    if (pgdata->static_data.symbol_table) {\n        for (i = 0; i < pgdata->static_data.n_symbol_entry; ++i)\n            free(pgdata->static_data.symbol_table[i]);\n        free(pgdata->static_data.symbol_table);\n        pgdata->static_data.n_symbol_entry = 0;\n        pgdata->static_data.symbol_table = NULL;\n    }\n}",
        "begin_line": 1356,
        "end_line": 1367,
        "is_bug": false
    },
    {
        "name": "chewingutil.InitEasySymbolInput#1369",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.InitEasySymbolInput(ChewingData *pgdata, const char *prefix)",
        "snippet": "int InitEasySymbolInput(ChewingData *pgdata, const char *prefix)\n{\n    static const size_t LINE_LEN = 512; // shall be long enough?\n\n    FILE *file = NULL;\n    char *filename = NULL;\n    char *line = NULL;\n    int len;\n    int _index;\n    char *symbol;\n    int ret = -1;\n\n    ret = asprintf(&filename, \"%s\" PLAT_SEPARATOR \"%s\", prefix, SOFTKBD_TABLE_FILE);\n    if (ret == -1)\n        goto filenamefail;\n\n    file = fopen(filename, \"r\");\n    if (!file)\n        goto fileopenfail;\n\n    line = ALC(char, LINE_LEN);\n    if (!line)\n        goto linefail;\n\n    while (fgets(line, LINE_LEN, file)) {\n        if (' ' != line[1])\n            continue;\n\n        // Remove tailing \\n\n        len = strcspn(line, \"\\r\\n\");\n\n        line[len] = '\\0';\n\n        _index = FindEasySymbolIndex(line[0]);\n        if (-1 == _index)\n            continue;\n\n        len = ueStrLen(&line[2]);\n        if (0 == len || len > MAX_PHRASE_LEN)\n            continue;\n\n        symbol = ALC(char, strlen(&line[2]) + 1);\n\n        if (!symbol)\n            goto end;\n\n        ueStrNCpy(symbol, &line[2], len, 1);\n\n        free(pgdata->static_data.g_easy_symbol_value[_index]);\n        pgdata->static_data.g_easy_symbol_value[_index] = symbol;\n        pgdata->static_data.g_easy_symbol_num[_index] = len;\n    }\n    ret = 0;\n\nend:\n    free(line);\n\nlinefail:\n    fclose(file);\n\nfileopenfail:\n    free(filename);\n\nfilenamefail:\n    return ret;\n}",
        "begin_line": 1369,
        "end_line": 1434,
        "is_bug": false
    },
    {
        "name": "chewingutil.TerminateEasySymbolTable#1436",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.TerminateEasySymbolTable(ChewingData *pgdata)",
        "snippet": "void TerminateEasySymbolTable(ChewingData *pgdata)\n{\n    unsigned int i;\n\n    for (i = 0; i < EASY_SYMBOL_KEY_TAB_LEN; ++i) {\n        if (NULL != pgdata->static_data.g_easy_symbol_value[i]) {\n            free(pgdata->static_data.g_easy_symbol_value[i]);\n            pgdata->static_data.g_easy_symbol_value[i] = NULL;\n        }\n        pgdata->static_data.g_easy_symbol_num[i] = 0;\n    }\n}",
        "begin_line": 1436,
        "end_line": 1447,
        "is_bug": false
    },
    {
        "name": "chewingutil.copyStringFromPreeditBuf#1449",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.copyStringFromPreeditBuf(ChewingData *pgdata, int pos, int len, char *output, int output_len)",
        "snippet": "void copyStringFromPreeditBuf(ChewingData *pgdata, int pos, int len, char *output, int output_len)\n{\n    int i;\n    int x;\n\n    assert(pgdata);\n    assert(0 <= pos && (size_t) (pos + len) < ARRAY_SIZE(pgdata->preeditBuf));\n    assert(output);\n    assert(output_len);\n\n    LOG_VERBOSE(\"Copy pos %d, len %d from preeditBuf\", pos, len);\n\n    for (i = pos; i < pos + len; ++i) {\n        x = strlen(pgdata->preeditBuf[i].char_);\n        if (x >= output_len)    // overflow\n            return;\n        memcpy(output, pgdata->preeditBuf[i].char_, x);\n        output += x;\n        output_len -= x;\n    }\n    output[0] = 0;\n}",
        "begin_line": 1449,
        "end_line": 1470,
        "is_bug": false
    },
    {
        "name": "chewingutil.toPreeditBufIndex#1476",
        "src_path": "src/chewingutil.c",
        "class_name": "chewingutil",
        "signature": "chewingutil.toPreeditBufIndex(ChewingData *pgdata, int pos)",
        "snippet": "int toPreeditBufIndex(ChewingData *pgdata, int pos)\n{\n    int word_count;\n    int i;\n\n    assert(pgdata);\n    assert(0 <= pos && pos <= MAX_CHI_SYMBOL_LEN);\n\n    for (i = 0, word_count = 0; i < MAX_CHI_SYMBOL_LEN; ++i) {\n        if (ChewingIsChiAt(i, pgdata))\n            ++word_count;\n\n        /*\n         * pos = 0 means finding the first word, so we need to add one\n         * here.\n         */\n        if (word_count == pos + 1)\n            break;\n    }\n\n    LOG_VERBOSE(\"translate phoneSeq index %d to preeditBuf index %d\", pos, i);\n\n    return i;\n}",
        "begin_line": 1476,
        "end_line": 1499,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UserBindPhone#23",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UserBindPhone(ChewingData *pgdata, int index, const uint16_t phoneSeq[], int len)",
        "snippet": "static int UserBindPhone(ChewingData *pgdata, int index, const uint16_t phoneSeq[], int len)\n{\n    int i;\n    int ret;\n\n    assert(pgdata);\n    assert(phoneSeq);\n\n    if (len > MAX_PHRASE_LEN) {\n        LOG_WARN(\"phoneSeq length %d > MAX_PHRASE_LEN(%d)\", len, MAX_PHRASE_LEN);\n        return -1;\n    }\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_userphrase[index], BIND_USERPHRASE_LENGTH, len);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n        return ret;\n    }\n\n    for (i = 0; i < len; ++i) {\n        ret = sqlite3_bind_int(pgdata->static_data.stmt_userphrase[index], BIND_USERPHRASE_PHONE_0 + i, phoneSeq[i]);\n        if (ret != SQLITE_OK) {\n            LOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n            return ret;\n        }\n    }\n\n    for (i = len; i < MAX_PHRASE_LEN; ++i) {\n        ret = sqlite3_bind_int(pgdata->static_data.stmt_userphrase[index], BIND_USERPHRASE_PHONE_0 + i, 0);\n        if (ret != SQLITE_OK) {\n            LOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n            return ret;\n        }\n    }\n\n    return SQLITE_OK;\n}",
        "begin_line": 23,
        "end_line": 59,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.LoadOriginalFreq#63",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.LoadOriginalFreq(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int len)",
        "snippet": "static int LoadOriginalFreq(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int len)\n{\n    const TreeType *tree_pos;\n    int retval;\n    Phrase *phrase = ALC(Phrase, 1);\n\n    tree_pos = TreeFindPhrase(pgdata, 0, len - 1, phoneSeq);\n    if (tree_pos) {\n        GetPhraseFirst(pgdata, phrase, tree_pos);\n        do {\n            /* find the same phrase */\n            if (!strcmp(phrase->phrase, wordSeq)) {\n                retval = phrase->freq;\n                free(phrase);\n                return retval;\n            }\n        } while (GetVocabNext(pgdata, phrase));\n    }\n\n    free(phrase);\n    return FREQ_INIT_VALUE;\n}",
        "begin_line": 63,
        "end_line": 84,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.LoadMaxFreq#87",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.LoadMaxFreq(ChewingData *pgdata, const uint16_t phoneSeq[], int len)",
        "snippet": "static int LoadMaxFreq(ChewingData *pgdata, const uint16_t phoneSeq[], int len)\n{\n    const TreeType *tree_pos;\n    Phrase *phrase = ALC(Phrase, 1);\n    int maxFreq = FREQ_INIT_VALUE;\n    int max_userphrase_freq;\n    int ret;\n\n    tree_pos = TreeFindPhrase(pgdata, 0, len - 1, phoneSeq);\n    if (tree_pos) {\n        GetPhraseFirst(pgdata, phrase, tree_pos);\n        do {\n            if (phrase->freq > maxFreq)\n                maxFreq = phrase->freq;\n        } while (GetVocabNext(pgdata, phrase));\n    }\n    free(phrase);\n\n    assert(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_GET_MAX_FREQ]);\n\n    ret = UserBindPhone(pgdata, STMT_USERPHRASE_GET_MAX_FREQ, phoneSeq, len);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"UserBindPhone returns %d\", ret);\n        return maxFreq;\n    }\n\n    ret = sqlite3_step(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_GET_MAX_FREQ]);\n    if (ret != SQLITE_ROW)\n        return maxFreq;\n\n    ret = sqlite3_reset(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_GET_MAX_FREQ]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n        return maxFreq;\n    }\n\n    max_userphrase_freq = sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_GET_MAX_FREQ],\n                                             SQL_STMT_USERPHRASE[STMT_USERPHRASE_GET_MAX_FREQ].column\n                                             [COLUMN_USERPHRASE_USER_FREQ]);\n\n    if (max_userphrase_freq > maxFreq)\n        maxFreq = max_userphrase_freq;\n\n    return maxFreq;\n}",
        "begin_line": 87,
        "end_line": 131,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UpdateFreq#134",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UpdateFreq(int freq, int maxfreq, int origfreq, int deltatime)",
        "snippet": "static int UpdateFreq(int freq, int maxfreq, int origfreq, int deltatime)\n{\n    int delta;\n\n    /* Short interval */\n    if (deltatime < 4000) {\n        delta = (freq >= maxfreq) ?\n            min((maxfreq - origfreq) / 5 + 1,\n                SHORT_INCREASE_FREQ) : max((maxfreq - origfreq) / 5 + 1, SHORT_INCREASE_FREQ);\n        return min(freq + delta, MAX_ALLOW_FREQ);\n    }\n    /* Medium interval */\n    else if (deltatime < 50000) {\n        delta = (freq >= maxfreq) ?\n            min((maxfreq - origfreq) / 10 + 1,\n                MEDIUM_INCREASE_FREQ) : max((maxfreq - origfreq) / 10 + 1, MEDIUM_INCREASE_FREQ);\n        return min(freq + delta, MAX_ALLOW_FREQ);\n    }\n    /* long interval */\n    else {\n        delta = max((freq - origfreq) / 5, LONG_DECREASE_FREQ);\n        return max(freq - delta, origfreq);\n    }\n}",
        "begin_line": 134,
        "end_line": 157,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.GetCurrentLifeTime#159",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.GetCurrentLifeTime(ChewingData *pgdata)",
        "snippet": "static int GetCurrentLifeTime(ChewingData *pgdata)\n{\n    return pgdata->static_data.new_lifetime;\n}",
        "begin_line": 159,
        "end_line": 162,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.LogUserPhrase#164",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.LogUserPhrase(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int orig_freq, int max_freq, int user_freq, int recent_time)",
        "snippet": "static void LogUserPhrase(ChewingData *pgdata,\n                          const uint16_t phoneSeq[],\n                          const char wordSeq[], int orig_freq, int max_freq, int user_freq, int recent_time)\n{\n    /* Size of each phone is len(\"0x1234 \") = 7 */\n    char buf[7 * MAX_PHRASE_LEN + 1] = { 0 };\n    int i;\n\n    for (i = 0; i < MAX_PHRASE_LEN; ++i) {\n        if (phoneSeq[i] == 0)\n            break;\n        snprintf(buf + 7 * i, 7 + 1, \"%#06x \", phoneSeq[i]);\n    }\n\n    LOG_INFO(\"userphrase %s, phone = %s, orig_freq = %d, max_freq = %d, user_freq = %d, recent_time = %d\",\n             wordSeq, buf, orig_freq, max_freq, user_freq, recent_time);\n}",
        "begin_line": 164,
        "end_line": 180,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UserUpdatePhraseBegin#182",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UserUpdatePhraseBegin(ChewingData *pgdata)",
        "snippet": "void UserUpdatePhraseBegin(ChewingData *pgdata)\n{\n    sqlite3_exec(pgdata->static_data.db, \"BEGIN\", 0, 0, 0);\n}",
        "begin_line": 182,
        "end_line": 185,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UserUpdatePhrase#187",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UserUpdatePhrase(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[])",
        "snippet": "int UserUpdatePhrase(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[])\n{\n    int ret;\n    int action;\n    int phone_len;\n    int word_len;\n\n    int orig_freq;\n    int max_freq;\n    int user_freq;\n    int recent_time;\n    int orig_time;\n\n    assert(pgdata);\n    assert(phoneSeq);\n    assert(wordSeq);\n\n    phone_len = GetPhoneLen(phoneSeq);\n    word_len = ueStrLen(wordSeq);\n\n    if (phone_len != word_len) {\n        LOG_WARN(\"Do not update userphrase because phoneSeq length %d != wordSeq length %d\", phone_len, word_len);\n        return USER_UPDATE_FAIL;\n    }\n\n    if (word_len > MAX_PHRASE_LEN) {\n        LOG_WARN(\"wordSeq length %d > MAX_PHRASE_LEN (%d)\", word_len, MAX_PHRASE_LEN);\n        return USER_UPDATE_FAIL;\n    }\n\n    ret = UserBindPhone(pgdata, STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE, phoneSeq, phone_len);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"UserBindPhone returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    ret = sqlite3_bind_text(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE],\n                            BIND_USERPHRASE_PHRASE, wordSeq, -1, SQLITE_STATIC);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_bind_text returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    recent_time = GetCurrentLifeTime(pgdata);\n\n    ret = sqlite3_step(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE]);\n    if (ret == SQLITE_ROW) {\n        action = USER_UPDATE_MODIFY;\n\n        orig_freq = sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE],\n                                       SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE].column\n                                       [COLUMN_USERPHRASE_ORIG_FREQ]);\n\n        max_freq = LoadMaxFreq(pgdata, phoneSeq, phone_len);\n\n        user_freq = sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE],\n                                       SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE].column\n                                       [COLUMN_USERPHRASE_USER_FREQ]);\n\n        orig_time = sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE],\n                                       SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE].column\n                                       [COLUMN_USERPHRASE_TIME]);\n\n        user_freq = UpdateFreq(user_freq, max_freq, orig_freq, recent_time - orig_time);\n    } else {\n        action = USER_UPDATE_INSERT;\n\n        orig_freq = LoadOriginalFreq(pgdata, phoneSeq, wordSeq, word_len);\n        max_freq = LoadMaxFreq(pgdata, phoneSeq, phone_len);\n        user_freq = orig_freq;\n    }\n\n    assert(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT]);\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT],\n                           BIND_USERPHRASE_TIME, recent_time);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT],\n                           BIND_USERPHRASE_USER_FREQ, user_freq);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT],\n                           BIND_USERPHRASE_MAX_FREQ, max_freq);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT],\n                           BIND_USERPHRASE_ORIG_FREQ, orig_freq);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_bind_int returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    ret = UserBindPhone(pgdata, STMT_USERPHRASE_UPSERT, phoneSeq, phone_len);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"UserBindPhone returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    ret = sqlite3_bind_text(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT],\n                            BIND_USERPHRASE_PHRASE, wordSeq, -1, SQLITE_STATIC);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_bind_text returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    ret = sqlite3_step(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT]);\n    if (ret != SQLITE_DONE) {\n        LOG_ERROR(\"sqlite3_step returns %d\", ret);\n        action = USER_UPDATE_FAIL;\n        goto end;\n    }\n\n    LogUserPhrase(pgdata, phoneSeq, wordSeq, orig_freq, max_freq, user_freq, recent_time);\n\n  end:\n    ret = sqlite3_reset(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_UPSERT]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n    }\n\n    ret = sqlite3_reset(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE_PHRASE]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n    }\n\n    return action;\n}",
        "begin_line": 187,
        "end_line": 331,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UserUpdatePhraseEnd#333",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UserUpdatePhraseEnd(ChewingData *pgdata)",
        "snippet": "void UserUpdatePhraseEnd(ChewingData *pgdata)\n{\n    sqlite3_exec(pgdata->static_data.db, \"END\", 0, 0, 0);\n}",
        "begin_line": 333,
        "end_line": 336,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UserRemovePhrase#338",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UserRemovePhrase(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[])",
        "snippet": "int UserRemovePhrase(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[])\n{\n    int ret;\n    int len;\n    int affected = 0;\n\n    assert(pgdata);\n    assert(phoneSeq);\n    assert(wordSeq);\n\n    assert(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_DELETE]);\n\n    len = GetPhoneLen(phoneSeq);\n    ret = UserBindPhone(pgdata, STMT_USERPHRASE_DELETE, phoneSeq, len);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"UserBindPhone returns %d\", ret);\n        goto end;\n    }\n\n    ret = sqlite3_bind_text(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_DELETE],\n                            BIND_USERPHRASE_PHRASE, wordSeq, -1, SQLITE_STATIC);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_bind_text returns %d\", ret);\n        goto end;\n    }\n\n    ret = sqlite3_step(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_DELETE]);\n    if (ret != SQLITE_DONE) {\n        LOG_ERROR(\"sqlite3_step returns %d\", ret);\n        goto end;\n    }\n\n    affected = sqlite3_changes(pgdata->static_data.db);\n\n  end:\n    ret = sqlite3_reset(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_DELETE]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n    }\n\n    return affected;\n}",
        "begin_line": 338,
        "end_line": 379,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UserGetPhraseFirst#382",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UserGetPhraseFirst(ChewingData *pgdata, const uint16_t phoneSeq[])",
        "snippet": "UserPhraseData *UserGetPhraseFirst(ChewingData *pgdata, const uint16_t phoneSeq[])\n{\n    int ret;\n    int len;\n\n    assert(pgdata);\n    assert(phoneSeq);\n\n    assert(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE]);\n    ret = sqlite3_reset(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n        return NULL;\n    }\n\n    len = GetPhoneLen(phoneSeq);\n    ret = UserBindPhone(pgdata, STMT_USERPHRASE_SELECT_BY_PHONE, phoneSeq, len);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"UserBindPhone returns %d\", ret);\n        return NULL;\n    }\n\n    return UserGetPhraseNext(pgdata, phoneSeq);\n}",
        "begin_line": 382,
        "end_line": 405,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UserGetPhraseNext#407",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UserGetPhraseNext(ChewingData *pgdata, const uint16_t phoneSeq[])",
        "snippet": "UserPhraseData *UserGetPhraseNext(ChewingData *pgdata, const uint16_t phoneSeq[])\n{\n    int ret;\n\n    assert(pgdata);\n    assert(phoneSeq);\n\n    ret = sqlite3_step(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE]);\n    if (ret != SQLITE_ROW)\n        return NULL;\n\n    /* FIXME: shall not remove const here. */\n    pgdata->userphrase_data.wordSeq =\n        (char *) sqlite3_column_text(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE],\n                                     SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE].column\n                                     [COLUMN_USERPHRASE_PHRASE]);\n    pgdata->userphrase_data.phoneSeq = (uint16_t *) phoneSeq;\n\n    pgdata->userphrase_data.recentTime =\n        sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE],\n                           SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE].column[COLUMN_USERPHRASE_TIME]);\n\n    pgdata->userphrase_data.userfreq =\n        sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE],\n                           SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE].column[COLUMN_USERPHRASE_USER_FREQ]);\n\n    pgdata->userphrase_data.maxfreq =\n        sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE],\n                           SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE].column[COLUMN_USERPHRASE_MAX_FREQ]);\n\n    pgdata->userphrase_data.origfreq =\n        sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT_BY_PHONE],\n                           SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT_BY_PHONE].column[COLUMN_USERPHRASE_ORIG_FREQ]);\n\n    return &pgdata->userphrase_data;\n}",
        "begin_line": 407,
        "end_line": 442,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.UserGetPhraseEnd#444",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.UserGetPhraseEnd(ChewingData *pgdata UNUSED, const uint16_t phoneSeq[] UNUSED)",
        "snippet": "void UserGetPhraseEnd(ChewingData *pgdata UNUSED, const uint16_t phoneSeq[] UNUSED)\n{\n    /* FIXME: Remove this */\n}",
        "begin_line": 444,
        "end_line": 447,
        "is_bug": false
    },
    {
        "name": "userphrase-sql.IncreaseLifeTime#449",
        "src_path": "src/userphrase-sql.c",
        "class_name": "userphrase-sql",
        "signature": "userphrase-sql.IncreaseLifeTime(ChewingData *pgdata)",
        "snippet": "void IncreaseLifeTime(ChewingData *pgdata)\n{\n    ++pgdata->static_data.new_lifetime;\n}",
        "begin_line": 449,
        "end_line": 452,
        "is_bug": false
    },
    {
        "name": "userphrase.GetDefaultChewingUserPath#130",
        "src_path": "src/userphrase.c",
        "class_name": "userphrase",
        "signature": "userphrase.GetDefaultChewingUserPath(ChewingData *pgdata)",
        "snippet": "char *GetDefaultChewingUserPath(ChewingData *pgdata)\n{\n    char *tmp;\n    char *path;\n    int ret;\n\n    assert(pgdata);\n\n    tmp = getenv(\"CHEWING_USER_PATH\");\n    if (tmp) {\n        ret = asprintf(&path, \"%s\", tmp);\n        if (ret == -1) {\n            LOG_ERROR(\"asprintf returns %d\", ret);\n            exit(-1);\n        }\n        return path;\n    }\n\n    tmp = getenv(\"HOME\");\n    if (!tmp) {\n        tmp = PLAT_TMPDIR;\n    }\n\n    ret = asprintf(&path, \"%s/%s\", tmp, USERPHRASE_DIR);\n    if (ret == -1) {\n        LOG_ERROR(\"asprintf returns %d\", ret);\n        exit(-1);\n    }\n\n    PLAT_MKDIR(path);\n\n    return path;\n}",
        "begin_line": 130,
        "end_line": 162,
        "is_bug": false
    },
    {
        "name": "userphrase.GetDefaultUserPhrasePath#164",
        "src_path": "src/userphrase.c",
        "class_name": "userphrase",
        "signature": "userphrase.GetDefaultUserPhrasePath(ChewingData *pgdata)",
        "snippet": "char *GetDefaultUserPhrasePath(ChewingData *pgdata)\n{\n    char *tmp;\n    char *path;\n    int ret;\n\n    assert(pgdata);\n\n    tmp = GetDefaultChewingUserPath(pgdata);\n    if (tmp && access(tmp, W_OK) == 0) {\n        ret = asprintf(&path, \"%s/%s\", tmp, DB_NAME);\n        if (ret == -1) {\n            free(tmp);\n            LOG_ERROR(\"asprintf returns %d\", ret);\n            exit(-1);\n        }\n        free(tmp);\n        return path;\n    }\n    free(tmp);\n\n    return NULL;\n}",
        "begin_line": 164,
        "end_line": 186,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_KBStr2Num#89",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_KBStr2Num(const char str[])",
        "snippet": "CHEWING_API int chewing_KBStr2Num(const char str[])\n{\n    int i;\n\n    STATIC_ASSERT(KB_TYPE_NUM == ARRAY_SIZE(kb_type_str));\n    for (i = 0; i < KB_TYPE_NUM; i++) {\n        if (!strcmp(str, kb_type_str[i]))\n            return i;\n    }\n    return KB_DEFAULT;\n}",
        "begin_line": 89,
        "end_line": 99,
        "is_bug": false
    },
    {
        "name": "chewingio.chooseCandidate#101",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chooseCandidate(ChewingContext *ctx, int toSelect, int key_buf_cursor)",
        "snippet": "static void chooseCandidate(ChewingContext *ctx, int toSelect, int key_buf_cursor)\n{\n    ChewingData *pgdata = ctx->data;\n\n    if (toSelect) {\n        if (!pgdata->bSelect) {\n            ChoiceInitAvail(pgdata);\n        } else {\n            if (ChoiceHasNextAvail(pgdata))\n                ChoiceNextAvail(pgdata);\n            else                /* rollover */\n                ChoiceFirstAvail(pgdata);\n        }\n    } else if (pgdata->symbolKeyBuf[key_buf_cursor]) {\n        /* Open Symbol Choice List */\n        if (pgdata->choiceInfo.isSymbol == WORD_CHOICE) {\n            OpenSymbolChoice(pgdata);\n        }\n        /**\n         * If these's only one candidate list available, ChoiceFirstAvail\n         * will re-open the list, namely turn back to the firt page.\n         * However, it doesn't work for symbols, therefore we\n         * set the page number to 0 directly.\n         */\n        else if (pgdata->bSelect) {\n            pgdata->choiceInfo.pageNo = 0;\n        }\n    } else {\n        /*\n         * The cursor position is not word, nor symbol. The only\n         * possible case is that user just uses ` to open symbol\n         * selection. In this case, when chooseCandidate is called,\n         * libchewing needs to reset pageNo to 0 to do rollover.\n         */\n        if (pgdata->bSelect) {\n            pgdata->choiceInfo.pageNo = 0;\n        }\n    }\n}",
        "begin_line": 101,
        "end_line": 139,
        "is_bug": false
    },
    {
        "name": "chewingio.NullLogger#141",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.NullLogger(void *data UNUSED, int level UNUSED, const char *fmt UNUSED, ...)",
        "snippet": "static void NullLogger(void *data UNUSED, int level UNUSED, const char *fmt UNUSED, ...)\n{\n}",
        "begin_line": 141,
        "end_line": 143,
        "is_bug": false
    },
    {
        "name": "chewingio.allocate_ChewingData#145",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.allocate_ChewingData(void (*logger) (void *data, int level, const char *fmt, ...), void *loggerdata)",
        "snippet": "static ChewingData *allocate_ChewingData(void (*logger) (void *data, int level, const char *fmt, ...), void *loggerdata)\n{\n    static const int DEFAULT_SELKEY[] = { '1', '2', '3', '4', '5', '6', '7', '8', '9', '0' };\n\n    ChewingData *data = ALC(ChewingData, 1);\n\n    if (data) {\n        data->config.candPerPage = MAX_SELKEY;\n        data->config.maxChiSymbolLen = MAX_CHI_SYMBOL_LEN;\n        data->logger = logger;\n        data->loggerData = loggerdata;\n        memcpy(data->config.selKey, DEFAULT_SELKEY, sizeof(data->config.selKey));\n    }\n\n    return data;\n}",
        "begin_line": 145,
        "end_line": 160,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_Reset#292",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_Reset(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_Reset(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingStaticData static_data;\n    ChewingConfigData old_config;\n    void (*logger) (void *data, int level, const char *fmt, ...);\n    void *loggerData;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    /* Backup old config and restore it after clearing pgdata structure. */\n    old_config = pgdata->config;\n    static_data = pgdata->static_data;\n    logger = pgdata->logger;\n    loggerData = pgdata->loggerData;\n    memset(pgdata, 0, sizeof(ChewingData));\n    pgdata->config = old_config;\n    pgdata->static_data = static_data;\n    pgdata->logger = logger;\n    pgdata->loggerData = loggerData;\n\n    /* bopomofoData */\n    memset(&(pgdata->bopomofoData), 0, sizeof(BopomofoData));\n\n    /* choiceInfo */\n    memset(&(pgdata->choiceInfo), 0, sizeof(ChoiceInfo));\n\n    pgdata->chiSymbolCursor = 0;\n    pgdata->chiSymbolBufLen = 0;\n    pgdata->nPhoneSeq = 0;\n    memset(pgdata->bUserArrCnnct, 0, sizeof(int) * (MAX_PHONE_SEQ_LEN + 1));\n    memset(pgdata->bUserArrBrkpt, 0, sizeof(int) * (MAX_PHONE_SEQ_LEN + 1));\n    pgdata->bChiSym = CHINESE_MODE;\n    pgdata->bFullShape = HALFSHAPE_MODE;\n    pgdata->bSelect = 0;\n    pgdata->nSelect = 0;\n    pgdata->PointStart = -1;\n    pgdata->PointEnd = 0;\n    pgdata->phrOut.nNumCut = 0;\n    return 0;\n}",
        "begin_line": 292,
        "end_line": 337,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_KBType#339",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_KBType(ChewingContext *ctx, int kbtype)",
        "snippet": "CHEWING_API int chewing_set_KBType(ChewingContext *ctx, int kbtype)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"kbtype = %d\", kbtype);\n\n    if (kbtype < KB_TYPE_NUM && kbtype >= 0) {\n        ctx->data->bopomofoData.kbtype = kbtype;\n        return 0;\n    } else {\n        ctx->data->bopomofoData.kbtype = KB_DEFAULT;\n        return -1;\n    }\n}",
        "begin_line": 339,
        "end_line": 357,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_get_KBType#359",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_get_KBType(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_get_KBType(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"kbtype = %d\", ctx->data->bopomofoData.kbtype);\n\n    return ctx->data->bopomofoData.kbtype;\n}",
        "begin_line": 359,
        "end_line": 371,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_get_KBString#373",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_get_KBString(const ChewingContext *ctx)",
        "snippet": "CHEWING_API char *chewing_get_KBString(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return strdup(\"\");\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"KBString = %s\", kb_type_str[ctx->data->bopomofoData.kbtype]);\n\n    return strdup(kb_type_str[ctx->data->bopomofoData.kbtype]);\n}",
        "begin_line": 373,
        "end_line": 385,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_delete#387",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_delete(ChewingContext *ctx)",
        "snippet": "CHEWING_API void chewing_delete(ChewingContext *ctx)\n{\n    if (ctx) {\n        if (ctx->data) {\n            TerminatePinyin(ctx->data);\n            TerminateEasySymbolTable(ctx->data);\n            TerminateSymbolTable(ctx->data);\n            TerminateUserphrase(ctx->data);\n            TerminateTree(ctx->data);\n            TerminateDict(ctx->data);\n            free(ctx->data);\n        }\n\n        if (ctx->output)\n            free(ctx->output);\n        free(ctx);\n    }\n    return;\n}",
        "begin_line": 387,
        "end_line": 405,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_free#407",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_free(void *p)",
        "snippet": "CHEWING_API void chewing_free(void *p)\n{\n    free(p);\n}",
        "begin_line": 407,
        "end_line": 410,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_candPerPage#412",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_candPerPage(ChewingContext *ctx, int n)",
        "snippet": "CHEWING_API void chewing_set_candPerPage(ChewingContext *ctx, int n)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"n = %d\", n);\n\n    if (MIN_SELKEY <= n && n <= MAX_SELKEY && ctx->data->config.selKey[n - 1])\n        ctx->data->config.candPerPage = n;\n}",
        "begin_line": 412,
        "end_line": 425,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_get_candPerPage#427",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_get_candPerPage(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_get_candPerPage(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"candPerPage = %d\", ctx->data->config.candPerPage);\n\n    return ctx->data->config.candPerPage;\n}",
        "begin_line": 427,
        "end_line": 439,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_maxChiSymbolLen#441",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_maxChiSymbolLen(ChewingContext *ctx, int n)",
        "snippet": "CHEWING_API void chewing_set_maxChiSymbolLen(ChewingContext *ctx, int n)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"n = %d\", n);\n\n    if (MIN_CHI_SYMBOL_LEN <= n && n <= MAX_CHI_SYMBOL_LEN)\n        ctx->data->config.maxChiSymbolLen = n;\n}",
        "begin_line": 441,
        "end_line": 454,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_get_maxChiSymbolLen#456",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_get_maxChiSymbolLen(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_get_maxChiSymbolLen(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"maxChiSymbolLen = %d\", ctx->data->config.maxChiSymbolLen);\n\n    return ctx->data->config.maxChiSymbolLen;\n}",
        "begin_line": 456,
        "end_line": 468,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_selKey#470",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_selKey(ChewingContext *ctx, const int *selkeys, int len)",
        "snippet": "CHEWING_API void chewing_set_selKey(ChewingContext *ctx, const int *selkeys, int len)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    if (!selkeys) {\n        return;\n    }\n\n    if (MIN_SELKEY <= len && len <= MAX_SELKEY) {\n        memset(ctx->data->config.selKey, 0, sizeof(ctx->data->config.selKey));\n        memcpy(ctx->data->config.selKey, selkeys, sizeof(*selkeys) * len);\n    }\n}",
        "begin_line": 470,
        "end_line": 489,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_get_selKey#491",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_get_selKey(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int *chewing_get_selKey(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n    int *selkeys;\n\n    if (!ctx) {\n        return NULL;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    selkeys = ALC(int, MAX_SELKEY);\n    if (selkeys) {\n        memcpy(selkeys, ctx->data->config.selKey, sizeof(*selkeys) * MAX_SELKEY);\n    }\n    return selkeys;\n}",
        "begin_line": 491,
        "end_line": 508,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_addPhraseDirection#510",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_addPhraseDirection(ChewingContext *ctx, int direction)",
        "snippet": "CHEWING_API void chewing_set_addPhraseDirection(ChewingContext *ctx, int direction)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"direction = %d\", direction);\n\n    if (direction == 0 || direction == 1)\n        ctx->data->config.bAddPhraseForward = direction;\n}",
        "begin_line": 510,
        "end_line": 523,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_get_addPhraseDirection#525",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_get_addPhraseDirection(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_get_addPhraseDirection(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"bAddPhraseForward = %d\", ctx->data->config.bAddPhraseForward);\n\n    return ctx->data->config.bAddPhraseForward;\n}",
        "begin_line": 525,
        "end_line": 537,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_spaceAsSelection#539",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_spaceAsSelection(ChewingContext *ctx, int mode)",
        "snippet": "CHEWING_API void chewing_set_spaceAsSelection(ChewingContext *ctx, int mode)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"mode = %d\", mode);\n\n    if (mode == 0 || mode == 1)\n        ctx->data->config.bSpaceAsSelection = mode;\n}",
        "begin_line": 539,
        "end_line": 552,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_get_spaceAsSelection#554",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_get_spaceAsSelection(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_get_spaceAsSelection(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"bSpaceAsSelection = %d\", ctx->data->config.bSpaceAsSelection);\n\n    return ctx->data->config.bSpaceAsSelection;\n}",
        "begin_line": 554,
        "end_line": 566,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_escCleanAllBuf#568",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_escCleanAllBuf(ChewingContext *ctx, int mode)",
        "snippet": "CHEWING_API void chewing_set_escCleanAllBuf(ChewingContext *ctx, int mode)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"mode = %d\", mode);\n\n    if (mode == 0 || mode == 1)\n        ctx->data->config.bEscCleanAllBuf = mode;\n}",
        "begin_line": 568,
        "end_line": 581,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_get_escCleanAllBuf#583",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_get_escCleanAllBuf(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_get_escCleanAllBuf(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"bEscCleanAllBuf = %d\", ctx->data->config.bEscCleanAllBuf);\n\n    return ctx->data->config.bEscCleanAllBuf;\n}",
        "begin_line": 583,
        "end_line": 595,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_autoShiftCur#597",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_autoShiftCur(ChewingContext *ctx, int mode)",
        "snippet": "CHEWING_API void chewing_set_autoShiftCur(ChewingContext *ctx, int mode)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"mode = %d\", mode);\n\n    if (mode == 0 || mode == 1)\n        ctx->data->config.bAutoShiftCur = mode;\n}",
        "begin_line": 597,
        "end_line": 610,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_get_autoShiftCur#612",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_get_autoShiftCur(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_get_autoShiftCur(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"bAutoShiftCur = %d\", ctx->data->config.bAutoShiftCur);\n\n    return ctx->data->config.bAutoShiftCur;\n}",
        "begin_line": 612,
        "end_line": 624,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_easySymbolInput#626",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_easySymbolInput(ChewingContext *ctx, int mode)",
        "snippet": "CHEWING_API void chewing_set_easySymbolInput(ChewingContext *ctx, int mode)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"mode = %d\", mode);\n\n    if (mode == 0 || mode == 1)\n        ctx->data->config.bEasySymbolInput = mode;\n}",
        "begin_line": 626,
        "end_line": 639,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_get_easySymbolInput#641",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_get_easySymbolInput(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_get_easySymbolInput(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"bEasySymbolInput = %d\", ctx->data->config.bEasySymbolInput);\n\n    return ctx->data->config.bEasySymbolInput;\n}",
        "begin_line": 641,
        "end_line": 653,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_phraseChoiceRearward#655",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_phraseChoiceRearward(ChewingContext *ctx, int mode)",
        "snippet": "CHEWING_API void chewing_set_phraseChoiceRearward(ChewingContext *ctx, int mode)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"mode = %d\", mode);\n\n    if (mode == 0 || mode == 1)\n        ctx->data->config.bPhraseChoiceRearward = mode;\n}",
        "begin_line": 655,
        "end_line": 668,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_get_phraseChoiceRearward#670",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_get_phraseChoiceRearward(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_get_phraseChoiceRearward(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"bPhraseChoiceRearward = %d\", ctx->data->config.bPhraseChoiceRearward);\n\n    return ctx->data->config.bPhraseChoiceRearward;\n}",
        "begin_line": 670,
        "end_line": 682,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_ChiEngMode#684",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_ChiEngMode(ChewingContext *ctx, int mode)",
        "snippet": "CHEWING_API void chewing_set_ChiEngMode(ChewingContext *ctx, int mode)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"mode = %d\", mode);\n\n    if (mode == CHINESE_MODE || mode == SYMBOL_MODE) {\n        // remove all data inside buffer as switching mode.\n        BopomofoRemoveAll(&(ctx->data->bopomofoData));\n        MakeOutputWithRtn(ctx->output, ctx->data, KEYSTROKE_ABSORB);\n        ctx->data->bChiSym = mode;\n    }\n}",
        "begin_line": 684,
        "end_line": 701,
        "is_bug": true
    },
    {
        "name": "chewingio.chewing_get_ChiEngMode#703",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_get_ChiEngMode(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_get_ChiEngMode(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"bChiSym = %d\", ctx->data->bChiSym);\n\n    return ctx->data->bChiSym;\n}",
        "begin_line": 703,
        "end_line": 715,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_ShapeMode#717",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_ShapeMode(ChewingContext *ctx, int mode)",
        "snippet": "CHEWING_API void chewing_set_ShapeMode(ChewingContext *ctx, int mode)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"mode = %d\", mode);\n\n    if (mode == HALFSHAPE_MODE || mode == FULLSHAPE_MODE)\n        ctx->data->bFullShape = mode;\n}",
        "begin_line": 717,
        "end_line": 730,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_get_ShapeMode#732",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_get_ShapeMode(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_get_ShapeMode(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"ctx->data->bFullShape = %d\", ctx->data->bFullShape);\n\n    return ctx->data->bFullShape;\n}",
        "begin_line": 732,
        "end_line": 744,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_autoLearn#746",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_autoLearn(ChewingContext *ctx, int mode)",
        "snippet": "CHEWING_API void chewing_set_autoLearn(ChewingContext *ctx, int mode)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"mode = %d\", mode);\n\n    if (mode == AUTOLEARN_ENABLED || mode == AUTOLEARN_DISABLED)\n        ctx->data->config.bAutoLearn = mode;\n}",
        "begin_line": 746,
        "end_line": 759,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_get_autoLearn#761",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_get_autoLearn(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_get_autoLearn(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"bAutoLearn = %d\", ctx->data->config.bAutoLearn);\n\n    return ctx->data->config.bAutoLearn;\n}",
        "begin_line": 761,
        "end_line": 773,
        "is_bug": false
    },
    {
        "name": "chewingio.CheckAndResetRange#775",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.CheckAndResetRange(ChewingData *pgdata)",
        "snippet": "static void CheckAndResetRange(ChewingData *pgdata)\n{\n    if (pgdata->PointStart > -1) {\n        pgdata->PointStart = -1;\n        pgdata->PointEnd = 0;\n    }\n}",
        "begin_line": 775,
        "end_line": 781,
        "is_bug": false
    },
    {
        "name": "chewingio.SelectCandidate#783",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.SelectCandidate(ChewingData *pgdata, int num)",
        "snippet": "static int SelectCandidate(ChewingData *pgdata, int num)\n{\n    assert(pgdata);\n    assert(pgdata->choiceInfo.pageNo >= 0);\n\n    if (0 <= num && num < pgdata->choiceInfo.nTotalChoice) {\n        if (pgdata->choiceInfo.isSymbol != WORD_CHOICE) {\n            SymbolChoice(pgdata, num);\n        } else {\n            /* change the select interval & selectStr & nSelect */\n            AddSelect(pgdata, num);\n            /* second, call choice module */\n            ChoiceSelect(pgdata, num);\n            /* automatically shift the cursor to next phrase */\n            if (pgdata->config.bAutoShiftCur != 0 &&\n                /* if cursor at end of string, do not shift the cursor. */\n                pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen) {\n                if (pgdata->config.bPhraseChoiceRearward) {\n                    ++pgdata->chiSymbolCursor;\n                } else {\n                    pgdata->chiSymbolCursor += pgdata->availInfo.avail[pgdata->availInfo.currentAvail].len;\n                }\n            }\n        }\n        return 0;\n    }\n\n    return -1;\n}",
        "begin_line": 783,
        "end_line": 811,
        "is_bug": false
    },
    {
        "name": "chewingio.DoSelect#813",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.DoSelect(ChewingData *pgdata, int num)",
        "snippet": "static void DoSelect(ChewingData *pgdata, int num)\n{\n    assert(pgdata->choiceInfo.pageNo >= 0);\n    if (num >= 0 && num < pgdata->choiceInfo.nChoicePerPage) {\n        num += pgdata->choiceInfo.pageNo * pgdata->choiceInfo.nChoicePerPage;\n        SelectCandidate(pgdata, num);\n    }\n}",
        "begin_line": 813,
        "end_line": 820,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Space#822",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Space(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_Space(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    /*\n     * Use chewing_handle_Default( ctx, ' ' ) to handle space when:\n     * - \"space as selection\" mode is disable\n     * - mode is not CHINESE_MODE\n     * - has incompleted bopomofo (space is needed to complete it)\n     * - pre-edit buffer is empty\n     */\n    if (!pgdata->config.bSpaceAsSelection || pgdata->bChiSym != CHINESE_MODE ||\n        BopomofoIsEntering(&ctx->data->bopomofoData) || pgdata->chiSymbolBufLen == 0) {\n        return chewing_handle_Default(ctx, ' ');\n    }\n\n    /*\n     * space = right when the follogin conditions are true\n     * 1. In select mode\n     * 2. The candidate page is not last page\n     *\n     * Otherwise, space = down\n     */\n    if (pgdata->bSelect && ctx->output->pci->pageNo < ctx->output->pci->nPage - 1) {\n        return chewing_handle_Right(ctx);\n    }\n\n    return chewing_handle_Down(ctx);\n}",
        "begin_line": 822,
        "end_line": 857,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Esc#859",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Esc(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_Esc(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    CheckAndResetRange(pgdata);\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    } else if (pgdata->bSelect) {\n        ChoiceEndChoice(pgdata);\n    } else if (BopomofoIsEntering(&(pgdata->bopomofoData))) {\n        BopomofoRemoveAll(&(pgdata->bopomofoData));\n    } else if (pgdata->config.bEscCleanAllBuf) {\n        CleanAllBuf(pgdata);\n        pgo->commitBufLen = pgdata->chiSymbolBufLen;\n    }\n\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 859,
        "end_line": 888,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Enter#890",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Enter(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_Enter(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int nCommitStr;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    nCommitStr = pgdata->chiSymbolBufLen;\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    } else if (pgdata->bSelect) {\n        keystrokeRtn = KEYSTROKE_ABSORB | KEYSTROKE_BELL;\n    } else if (pgdata->PointStart > -1) {\n        int buf = pgdata->chiSymbolCursor;\n        int key = '0';\n\n        if (pgdata->PointEnd > 1) {\n            if (!pgdata->config.bAddPhraseForward) {\n                pgdata->chiSymbolCursor = pgdata->PointStart;\n            } else {\n                pgdata->chiSymbolCursor = pgdata->PointStart + pgdata->PointEnd;\n            }\n            key = '0' + pgdata->PointEnd;\n        } else if (pgdata->PointEnd < 1) {\n            if (pgdata->config.bAddPhraseForward)\n                pgdata->chiSymbolCursor = buf - pgdata->PointEnd;\n            key = '0' - pgdata->PointEnd;\n        }\n        chewing_handle_CtrlNum(ctx, key);\n        pgdata->chiSymbolCursor = buf;\n        pgdata->PointStart = -1;\n        pgdata->PointEnd = 0;\n    } else {\n        keystrokeRtn = KEYSTROKE_COMMIT;\n        WriteChiSymbolToCommitBuf(pgdata, pgo, nCommitStr);\n        if (!pgdata->config.bAutoLearn) {\n            AutoLearnPhrase(pgdata);\n        }\n        CleanAllBuf(pgdata);\n        pgo->commitBufLen = nCommitStr;\n    }\n\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 890,
        "end_line": 943,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Del#945",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Del(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_Del(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    CheckAndResetRange(pgdata);\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    }\n\n    if (!pgdata->bSelect) {\n        if (!BopomofoIsEntering(&(pgdata->bopomofoData)) && pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen) {\n            ChewingKillChar(pgdata, pgdata->chiSymbolCursor, NONDECREASE_CURSOR);\n        }\n        CallPhrasing(pgdata, 0);\n    }\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 945,
        "end_line": 973,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Backspace#975",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Backspace(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_Backspace(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    CheckAndResetRange(pgdata);\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    }\n\n    if (!pgdata->bSelect) {\n        if (BopomofoIsEntering(&(pgdata->bopomofoData))) {\n            BopomofoRemoveLast(&(pgdata->bopomofoData));\n        } else if (pgdata->chiSymbolCursor > 0) {\n            ChewingKillChar(pgdata, pgdata->chiSymbolCursor - 1, DECREASE_CURSOR);\n        }\n        CallPhrasing(pgdata, 0);\n    } else if (pgdata->bSelect) {\n        chewing_cand_close(ctx);\n    }\n\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 975,
        "end_line": 1008,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Up#1010",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Up(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_Up(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n    int key_buf_cursor;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    CheckAndResetRange(pgdata);\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    }\n\n    key_buf_cursor = pgdata->chiSymbolCursor;\n    // FIXME: when pgdata->chiSymbolBufLen == 0, key_buf_cursor will be -1.\n    if (pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen)\n        key_buf_cursor--;\n\n    /* close candidate list, compared to Down key to open candidate list. */\n    if (pgdata->bSelect) {\n        ChoiceEndChoice(pgdata);\n    }\n\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1010,
        "end_line": 1043,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Down#1045",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Down(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_Down(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int toSelect = 0;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n    int key_buf_cursor;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    CheckAndResetRange(pgdata);\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    }\n\n    key_buf_cursor = pgdata->chiSymbolCursor;\n    if (pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen && key_buf_cursor > 0)\n        key_buf_cursor--;\n\n    /* see if to select */\n    if (ChewingIsChiAt(key_buf_cursor, pgdata))\n        toSelect = 1;\n\n    chooseCandidate(ctx, toSelect, key_buf_cursor);\n\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1045,
        "end_line": 1079,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_ShiftLeft#1082",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_ShiftLeft(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_ShiftLeft(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    }\n    if (!pgdata->bSelect) {\n        /*  PointEnd locates (-9, +9) */\n        if (!BopomofoIsEntering(&(pgdata->bopomofoData)) && pgdata->chiSymbolCursor > 0 && pgdata->PointEnd > -9) {\n            if (pgdata->PointStart == -1)\n                pgdata->PointStart = pgdata->chiSymbolCursor;\n            pgdata->chiSymbolCursor--;\n            if (ChewingIsChiAt(pgdata->chiSymbolCursor, pgdata)) {\n                pgdata->PointEnd--;\n            }\n            if (pgdata->PointEnd == 0)\n                pgdata->PointStart = -1;\n        }\n    }\n\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1082,
        "end_line": 1115,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Left#1117",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Left(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_Left(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    }\n\n    if (pgdata->bSelect) {\n        assert(pgdata->choiceInfo.nPage > 0);\n        if (pgdata->choiceInfo.pageNo > 0)\n            pgdata->choiceInfo.pageNo--;\n        else\n            pgdata->choiceInfo.pageNo = pgdata->choiceInfo.nPage - 1;\n    } else {\n        if (!BopomofoIsEntering(&(pgdata->bopomofoData)) && pgdata->chiSymbolCursor > 0) {\n            CheckAndResetRange(pgdata);\n            pgdata->chiSymbolCursor--;\n        }\n    }\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1117,
        "end_line": 1149,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_ShiftRight#1152",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_ShiftRight(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_ShiftRight(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    }\n\n    if (!pgdata->bSelect) {\n        /* PointEnd locates (-9, +9) */\n        if (!BopomofoIsEntering(&(pgdata->bopomofoData)) &&\n            pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen && pgdata->PointEnd < 9) {\n            if (pgdata->PointStart == -1)\n                pgdata->PointStart = pgdata->chiSymbolCursor;\n            if (ChewingIsChiAt(pgdata->chiSymbolCursor, pgdata)) {\n                pgdata->PointEnd++;\n            }\n            pgdata->chiSymbolCursor++;\n            if (pgdata->PointEnd == 0)\n                pgdata->PointStart = -1;\n        }\n    }\n\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1152,
        "end_line": 1187,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Right#1189",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Right(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_Right(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    }\n\n    if (pgdata->bSelect) {\n        if (pgdata->choiceInfo.pageNo < pgdata->choiceInfo.nPage - 1)\n            pgdata->choiceInfo.pageNo++;\n        else\n            pgdata->choiceInfo.pageNo = 0;\n    } else {\n        if (!BopomofoIsEntering(&(pgdata->bopomofoData)) && pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen) {\n            CheckAndResetRange(pgdata);\n            pgdata->chiSymbolCursor++;\n        }\n    }\n\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1189,
        "end_line": 1221,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Tab#1223",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Tab(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_Tab(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n    int all_phrasing = 0;\n    int cursor;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    CheckAndResetRange(pgdata);\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    }\n\n\n    if (!pgdata->bSelect) {\n        if (pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen) {\n            pgdata->phrOut.nNumCut++;\n            all_phrasing = 1;\n        } else if (pgdata->chiSymbolCursor > 0 &&\n                   ChewingIsChiAt(pgdata->chiSymbolCursor - 1, pgdata)) {\n            cursor = PhoneSeqCursor(pgdata);\n            if (IsPreferIntervalConnted(cursor, pgdata)) {\n                pgdata->bUserArrBrkpt[cursor] = 1;\n                pgdata->bUserArrCnnct[cursor] = 0;\n            } else {\n                pgdata->bUserArrBrkpt[cursor] = 0;\n                pgdata->bUserArrCnnct[cursor] = 1;\n            }\n        }\n        CallPhrasing(pgdata, all_phrasing);\n    }\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1223,
        "end_line": 1265,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_DblTab#1267",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_DblTab(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_DblTab(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n    int cursor;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    CheckAndResetRange(pgdata);\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    }\n\n    if (!pgdata->bSelect) {\n        cursor = PhoneSeqCursor(pgdata);\n        pgdata->bUserArrBrkpt[cursor] = 0;\n        pgdata->bUserArrCnnct[cursor] = 0;\n    }\n    CallPhrasing(pgdata, 0);\n\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1267,
        "end_line": 1297,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Capslock#1300",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Capslock(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_Capslock(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    chewing_set_ChiEngMode(ctx, 1 - chewing_get_ChiEngMode(ctx));\n    MakeOutputWithRtn(pgo, pgdata, KEYSTROKE_ABSORB);\n    return 0;\n}",
        "begin_line": 1300,
        "end_line": 1316,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Home#1318",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Home(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_Home(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    CheckAndResetRange(pgdata);\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    } else if (!pgdata->bSelect) {\n        pgdata->chiSymbolCursor = 0;\n    }\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1318,
        "end_line": 1341,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_End#1343",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_End(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_End(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    CheckAndResetRange(pgdata);\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    } else if (!pgdata->bSelect) {\n        pgdata->chiSymbolCursor = pgdata->chiSymbolBufLen;\n    }\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1343,
        "end_line": 1366,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_PageUp#1368",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_PageUp(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_PageUp(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    CheckAndResetRange(pgdata);\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    } else if (!pgdata->bSelect) {\n        pgdata->chiSymbolCursor = pgdata->chiSymbolBufLen;\n    } else if (pgdata->bSelect) {\n        assert(pgdata->choiceInfo.nPage > 0);\n        if (pgdata->choiceInfo.pageNo > 0)\n            pgdata->choiceInfo.pageNo--;\n        else\n            pgdata->choiceInfo.pageNo = pgdata->choiceInfo.nPage - 1;\n    }\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1368,
        "end_line": 1397,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_PageDown#1399",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_PageDown(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_PageDown(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    CheckAndResetRange(pgdata);\n\n    if (!ChewingIsEntering(pgdata)) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n    } else if (!pgdata->bSelect) {\n        pgdata->chiSymbolCursor = pgdata->chiSymbolBufLen;\n    } else if (pgdata->bSelect) {\n        if (pgdata->choiceInfo.pageNo < pgdata->choiceInfo.nPage - 1)\n            pgdata->choiceInfo.pageNo++;\n        else\n            pgdata->choiceInfo.pageNo = 0;\n    }\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1399,
        "end_line": 1427,
        "is_bug": false
    },
    {
        "name": "chewingio.dvorak_convert#1430",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.dvorak_convert(int key)",
        "snippet": "static int dvorak_convert(int key)\n{\n    const char dkey[] = {\n        '\\'', '\\\"', ',', '<', '.', '>', 'p', 'P', 'y', 'Y', 'f', 'F', 'g', 'G',\n        'c', 'C', 'r', 'R', 'l', 'L', '/', '?', '=', '+', '\\\\', '|',\n        'a', 'A', 'o', 'O', 'e', 'E', 'u', 'U', 'i', 'I', 'd', 'D', 'h', 'H',\n        't', 'T', 'n', 'N', 's', 'S', '-', '_',\n        ';', ':', 'q', 'Q', 'j', 'J', 'k', 'K', 'x', 'X', 'b', 'B', 'm', 'M',\n        'w', 'W', 'v', 'V', 'z', 'Z'\n    };\n    const char qkey[] = {\n        'q', 'Q', 'w', 'W', 'e', 'E', 'r', 'R', 't', 'T', 'y', 'Y', 'u', 'U',\n        'i', 'I', 'o', 'O', 'p', 'P', '[', '{', ']', '}', '\\\\', '|',\n        'a', 'A', 's', 'S', 'd', 'D', 'f', 'F', 'g', 'G', 'h', 'H', 'j', 'J',\n        'k', 'K', 'l', 'L', ';', ':', '\\'', '\\\"',\n        'z', 'Z', 'x', 'X', 'c', 'C', 'v', 'V', 'b', 'B', 'n', 'N', 'm', 'M',\n        ',', '<', '.', '>', '/', '?'\n    };\n    size_t i;\n\n    STATIC_ASSERT(ARRAY_SIZE(dkey) == ARRAY_SIZE(qkey));\n\n    for (i = 0; i < ARRAY_SIZE(dkey); i++) {\n        if (key == qkey[i]) {\n            key = dkey[i];\n            return key;\n        }\n    }\n    return key;\n}",
        "begin_line": 1430,
        "end_line": 1459,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Default#1461",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Default(ChewingContext *ctx, int key)",
        "snippet": "CHEWING_API int chewing_handle_Default(ChewingContext *ctx, int key)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n    int rtn;\n    int num;\n    int bQuickCommit = 0;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"key = %d\", key);\n\n    /* Update lifetime */\n    IncreaseLifeTime(ctx->data);\n\n    /* Skip the special key */\n    if (key & 0xFF00) {\n        keystrokeRtn = KEYSTROKE_IGNORE;\n        goto End_KeyDefault;\n    }\n\n    /* We ignore non-printable input */\n    if (!isprint(key))\n        goto End_KeyDefault;\n\n    CheckAndResetRange(pgdata);\n\n    DEBUG_CHECKPOINT();\n    DEBUG_OUT(\"   key=%d\", key);\n\n    /* Dvorak Hsu */\n    if (pgdata->bopomofoData.kbtype == KB_DVORAK_HSU) {\n        key = dvorak_convert(key);\n    }\n\n    /* selecting */\n    if (pgdata->bSelect) {\n        if (key == ' ')\n            return chewing_handle_Right(ctx);\n        /* num starts from 0 */\n        num = CountSelKeyNum(key, pgdata);\n        if (num >= 0) {\n            DoSelect(pgdata, num);\n            goto End_keyproc;\n        }\n\n        /* Otherwise, use 'j' and 'k' for paging in selection mode */\n        DEBUG_OUT(\"\\t\\tchecking paging key, got '%c'\\n\", key);\n        switch (key) {\n        case 'j':\n        case 'J':\n            if (pgdata->chiSymbolCursor > 0) {\n                if (!ChewingIsEntering(pgdata)) {\n                    keystrokeRtn = KEYSTROKE_IGNORE;\n                }\n                CheckAndResetRange(pgdata);\n                pgdata->chiSymbolCursor--;\n                if (ChewingIsChiAt(pgdata->chiSymbolCursor, pgdata))\n                    ChoiceInitAvail(pgdata);\n                else\n                    OpenSymbolChoice(pgdata);\n\n            }\n            goto End_Paging;\n        case 'k':\n        case 'K':\n            if (pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen) {\n                if (!ChewingIsEntering(pgdata)) {\n                    keystrokeRtn = KEYSTROKE_IGNORE;\n                }\n                CheckAndResetRange(pgdata);\n                pgdata->chiSymbolCursor++;\n                if (ChewingIsChiAt(pgdata->chiSymbolCursor, pgdata))\n                    ChoiceInitAvail(pgdata);\n                else\n                    OpenSymbolChoice(pgdata);\n            }\n            goto End_Paging;\n        default:\n            break;\n        }\n    }\n    /* editing */\n    else {\n        if (pgdata->bChiSym == CHINESE_MODE) {\n            if (pgdata->config.bEasySymbolInput != 0) {\n                EasySymbolInput(key, pgdata);\n                goto End_keyproc;\n            }\n\n            rtn = BopomofoPhoInput(pgdata, key);\n            DEBUG_OUT(\"\\t\\tChinese mode key, \" \"BopomofoPhoInput return value = %d\\n\", rtn);\n\n            if (rtn == BOPOMOFO_KEY_ERROR)\n                rtn = SpecialSymbolInput(key, pgdata);\n            switch (rtn) {\n            case BOPOMOFO_ABSORB:\n                keystrokeRtn = KEYSTROKE_ABSORB;\n                break;\n            case BOPOMOFO_COMMIT:\n                AddChi(pgdata->bopomofoData.phone, pgdata->bopomofoData.phoneAlt, pgdata);\n                break;\n            case BOPOMOFO_NO_WORD:\n                keystrokeRtn = KEYSTROKE_BELL | KEYSTROKE_ABSORB;\n                break;\n            case BOPOMOFO_KEY_ERROR:\n            case BOPOMOFO_IGNORE:\n                DEBUG_OUT(\"\\t\\tbefore isupper(key),key=%d\\n\", key);\n                /* change upper case into lower case */\n                if (isupper(key))\n                    key = tolower(key);\n\n                DEBUG_OUT(\"\\t\\tafter isupper(key),key=%d\\n\", key);\n\n                /* see if buffer contains nothing */\n                if (pgdata->chiSymbolBufLen == 0) {\n                    bQuickCommit = 1;\n                }\n\n                if (pgdata->config.bEasySymbolInput == 0) {\n                    if (pgdata->bFullShape)\n                        rtn = FullShapeSymbolInput(key, pgdata);\n                    else\n                        rtn = SymbolInput(key, pgdata);\n                }\n\n                if (rtn == SYMBOL_KEY_ERROR) {\n                    keystrokeRtn = KEYSTROKE_IGNORE;\n                    /*\n                     * If the key is not a printable symbol,\n                     * then it's wrong to commit it.\n                     */\n                    bQuickCommit = 0;\n                } else\n                    keystrokeRtn = KEYSTROKE_ABSORB;\n\n                break;\n            default:\n                goto End_KeyDefault;\n            }\n        }\n        /* English mode */\n        else {\n            /* see if buffer contains nothing */\n            if (pgdata->chiSymbolBufLen == 0) {\n                bQuickCommit = 1;\n            }\n            if (pgdata->bFullShape) {\n                rtn = FullShapeSymbolInput(key, pgdata);\n            } else {\n                rtn = SymbolInput(key, pgdata);\n            }\n\n            if (rtn == SYMBOL_KEY_ERROR) {\n                keystrokeRtn = KEYSTROKE_IGNORE;\n                bQuickCommit = 0;\n            }\n        }\n    }\n\n  End_keyproc:\n    if (!bQuickCommit) {\n        CallPhrasing(pgdata, 0);\n        if (ReleaseChiSymbolBuf(pgdata, pgo) != 0)\n            keystrokeRtn = KEYSTROKE_COMMIT;\n    }\n    /* Quick commit */\n    else {\n        DEBUG_OUT(\"\\t\\tQuick commit buf[0]=%c\\n\", pgdata->preeditBuf[0].char_);\n        WriteChiSymbolToCommitBuf(pgdata, pgo, 1);\n        pgdata->chiSymbolBufLen = 0;\n        pgdata->chiSymbolCursor = 0;\n        keystrokeRtn = KEYSTROKE_COMMIT;\n    }\n\n    if (pgdata->phrOut.nNumCut > 0) {\n        int i;\n\n        for (i = 0; i < pgdata->phrOut.nDispInterval; i++) {\n            pgdata->bUserArrBrkpt[pgdata->phrOut.dispInterval[i].from] = 1;\n            pgdata->bUserArrBrkpt[pgdata->phrOut.dispInterval[i].to] = 1;\n        }\n        pgdata->phrOut.nNumCut = 0;\n    }\n\n  End_KeyDefault:\n    CallPhrasing(pgdata, 0);\n  End_Paging:\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1461,
        "end_line": 1656,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_CtrlNum#1658",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_CtrlNum(ChewingContext *ctx, int key)",
        "snippet": "CHEWING_API int chewing_handle_CtrlNum(ChewingContext *ctx, int key)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n    int newPhraseLen;\n    int i;\n    uint16_t addPhoneSeq[MAX_PHONE_SEQ_LEN];\n    char addWordSeq[MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1];\n    int phraseState;\n    int cursor;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    CheckAndResetRange(pgdata);\n\n    if (pgdata->bSelect)\n        return 0;\n\n    CallPhrasing(pgdata, 0);\n    newPhraseLen = key - '0';\n\n    if (key == '0' || key == '1') {\n        pgdata->bSelect = 1;\n        pgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;\n\n        HaninSymbolInput(pgdata);\n        CallPhrasing(pgdata, 0);\n        MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n        return 0;\n    }\n\n    cursor = PhoneSeqCursor(pgdata);\n    if (!pgdata->config.bAddPhraseForward) {\n        if (newPhraseLen >= 1 && cursor + newPhraseLen - 1 <= pgdata->nPhoneSeq) {\n            if (NoSymbolBetween(pgdata, cursor, cursor + newPhraseLen)) {\n                /* Manually add phrase to the user phrase database. */\n                memcpy(addPhoneSeq, &pgdata->phoneSeq[cursor], sizeof(uint16_t) * newPhraseLen);\n                addPhoneSeq[newPhraseLen] = 0;\n\n                copyStringFromPreeditBuf(pgdata, cursor, newPhraseLen, addWordSeq, sizeof(addWordSeq));\n\n                phraseState = UserUpdatePhrase(pgdata, addPhoneSeq, addWordSeq);\n                SetUpdatePhraseMsg(pgdata, addWordSeq, newPhraseLen, phraseState);\n\n                /* Clear the breakpoint between the New Phrase */\n                for (i = 1; i < newPhraseLen; i++)\n                    pgdata->bUserArrBrkpt[cursor + i] = 0;\n            }\n        }\n    } else {\n        if (newPhraseLen >= 1 && cursor - newPhraseLen >= 0) {\n            if (NoSymbolBetween(pgdata, cursor - newPhraseLen, cursor)) {\n                /* Manually add phrase to the user phrase database. */\n                memcpy(addPhoneSeq, &pgdata->phoneSeq[cursor - newPhraseLen], sizeof(uint16_t) * newPhraseLen);\n                addPhoneSeq[newPhraseLen] = 0;\n\n                copyStringFromPreeditBuf(pgdata, cursor - newPhraseLen, newPhraseLen, addWordSeq, sizeof(addWordSeq));\n\n                phraseState = UserUpdatePhrase(pgdata, addPhoneSeq, addWordSeq);\n                SetUpdatePhraseMsg(pgdata, addWordSeq, newPhraseLen, phraseState);\n\n                /* Clear the breakpoint between the New Phrase */\n                for (i = 1; i < newPhraseLen; i++)\n                    pgdata->bUserArrBrkpt[cursor - newPhraseLen + i] = 0;\n            }\n        }\n    }\n    CallPhrasing(pgdata, 0);\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    MakeOutputAddMsgAndCleanInterval(pgo, pgdata);\n    return 0;\n}",
        "begin_line": 1658,
        "end_line": 1736,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_ShiftSpace#1738",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_ShiftSpace(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_handle_ShiftSpace(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    if (!pgdata->bSelect) {\n        CheckAndResetRange(pgdata);\n    }\n\n    chewing_set_ShapeMode(ctx, 1 - chewing_get_ShapeMode(ctx));\n\n    CallPhrasing(pgdata, 0);\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1738,
        "end_line": 1761,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_handle_Numlock#1763",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_handle_Numlock(ChewingContext *ctx, int key)",
        "snippet": "CHEWING_API int chewing_handle_Numlock(ChewingContext *ctx, int key)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int keystrokeRtn = KEYSTROKE_ABSORB;\n    int rtn;\n    int QuickCommit = 0;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    if (!pgdata->bSelect) {\n        /* If we're not selecting words, we should send out numeric\n         * characters at once.\n         */\n        if (pgdata->chiSymbolBufLen == 0) {\n            QuickCommit = 1;\n        }\n        rtn = SymbolInput(key, pgdata);\n        /* copied from chewing_handle_Default */\n        if (rtn == SYMBOL_KEY_ERROR) {\n            keystrokeRtn = KEYSTROKE_IGNORE;\n        } else if (QuickCommit) {\n            WriteChiSymbolToCommitBuf(pgdata, pgo, 1);\n            pgdata->chiSymbolBufLen = 0;\n            pgdata->chiSymbolCursor = 0;\n            keystrokeRtn = KEYSTROKE_COMMIT;\n        } else {                /* Not quick commit */\n            CallPhrasing(pgdata, 0);\n            if (ReleaseChiSymbolBuf(pgdata, pgo) != 0)\n                keystrokeRtn = KEYSTROKE_COMMIT;\n        }\n    } else {\n        /* Otherwise, if we are selecting words, we use numeric keys\n         * as selkey\n         * and submit the words.\n         */\n        int num = -1;\n\n        if (key > '0' && key <= '9')\n            num = key - '1';\n        else if (key == '0')\n            num = 9;\n        DoSelect(pgdata, num);\n    }\n    CallPhrasing(pgdata, 0);\n    if (ReleaseChiSymbolBuf(pgdata, pgo) != 0)\n        keystrokeRtn = KEYSTROKE_COMMIT;\n    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);\n    return 0;\n}",
        "begin_line": 1763,
        "end_line": 1818,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_get_phoneSeq#1820",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_get_phoneSeq(const ChewingContext *ctx)",
        "snippet": "CHEWING_API unsigned short *chewing_get_phoneSeq(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n    uint16_t *seq;\n\n    if (!ctx) {\n        return NULL;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    seq = ALC(uint16_t, ctx->data->nPhoneSeq);\n    if (seq)\n        memcpy(seq, ctx->data->phoneSeq, sizeof(uint16_t) * ctx->data->nPhoneSeq);\n    return seq;\n}",
        "begin_line": 1820,
        "end_line": 1836,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_get_phoneSeqLen#1838",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_get_phoneSeqLen(const ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_get_phoneSeqLen(const ChewingContext *ctx)\n{\n    const ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"nPhoneSeq = %d\", ctx->data->nPhoneSeq);\n\n    return ctx->data->nPhoneSeq;\n}",
        "begin_line": 1838,
        "end_line": 1850,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_set_logger#1852",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_set_logger(ChewingContext *ctx, void (*logger) (void *data, int level, const char *fmt, ...), void *data)",
        "snippet": "CHEWING_API void chewing_set_logger(ChewingContext *ctx,\n                                    void (*logger) (void *data, int level, const char *fmt, ...), void *data)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    if (!logger) {\n        logger = NullLogger;\n        data = 0;\n    }\n    ctx->data->logger = logger;\n    ctx->data->loggerData = data;\n}",
        "begin_line": 1852,
        "end_line": 1870,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_userphrase_enumerate#1872",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_userphrase_enumerate(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_userphrase_enumerate(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n\n#if WITH_SQLITE3\n    int ret;\n#endif\n\n    if (!ctx) {\n        return -1;\n    }\n\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n#if WITH_SQLITE3\n    assert(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT]);\n    ret = sqlite3_reset(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n        return -1;\n    }\n#else\n    pgdata->static_data.userphrase_enum = FindNextHash(pgdata, NULL);\n#endif\n    return 0;\n}",
        "begin_line": 1872,
        "end_line": 1899,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_userphrase_has_next#1901",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_userphrase_has_next(ChewingContext *ctx, unsigned int *phrase_len, unsigned int *bopomofo_len)",
        "snippet": "CHEWING_API int chewing_userphrase_has_next(ChewingContext *ctx, unsigned int *phrase_len, unsigned int *bopomofo_len)\n{\n    ChewingData *pgdata;\n\n#if WITH_SQLITE3\n    int ret;\n#endif\n\n    if (!ctx || !phrase_len || !bopomofo_len) {\n        return 0;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n#if WITH_SQLITE3\n    ret = sqlite3_step(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT]);\n    if (ret != SQLITE_ROW) {\n        if (ret != SQLITE_DONE) {\n            LOG_ERROR(\"sqlite3_step returns %d\", ret);\n        }\n        return 0;\n    }\n\n    *phrase_len = strlen((const char *) sqlite3_column_text(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT],\n                                                            SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT].column\n                                                            [COLUMN_USERPHRASE_PHRASE])) + 1;\n\n    *bopomofo_len = GetBopomofoBufLen(sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT],\n                                                         SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT].column\n                                                         [COLUMN_USERPHRASE_LENGTH]));\n\n    return 1;\n#else\n    if (pgdata->static_data.userphrase_enum) {\n        *phrase_len = strlen(pgdata->static_data.userphrase_enum->data.wordSeq) + 1;\n        *bopomofo_len = BopomofoFromUintArray(NULL, 0, pgdata->static_data.userphrase_enum->data.phoneSeq);\n        return 1;\n\n    }\n    return 0;\n#endif\n}",
        "begin_line": 1901,
        "end_line": 1943,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_userphrase_get#1945",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_userphrase_get(ChewingContext *ctx, char *phrase_buf, unsigned int phrase_len, char *bopomofo_buf, unsigned int bopomofo_len)",
        "snippet": "CHEWING_API int chewing_userphrase_get(ChewingContext *ctx,\n                                       char *phrase_buf, unsigned int phrase_len,\n                                       char *bopomofo_buf, unsigned int bopomofo_len)\n{\n    ChewingData *pgdata;\n\n#if WITH_SQLITE3\n    const char *phrase;\n    int length;\n    int i;\n    uint16_t phone_array[MAX_PHRASE_LEN + 1] = { 0 };\n#endif\n\n    if (!ctx || !phrase_buf || !phrase_len || !bopomofo_buf || !bopomofo_len) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n#if WITH_SQLITE3\n    phrase = (const char *) sqlite3_column_text(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT],\n                                                SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT].column\n                                                [COLUMN_USERPHRASE_PHRASE]);\n    length =\n        sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT],\n                           SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT].column[COLUMN_USERPHRASE_LENGTH]);\n\n    if (phrase_len < strlen(phrase) + 1) {\n        LOG_ERROR(\"phrase_len %d is smaller than %d\", phrase_len, strlen(phrase) + 1);\n        return -1;\n    }\n\n    if (bopomofo_len < GetBopomofoBufLen(length)) {\n        LOG_ERROR(\"bopomofo_len %d is smaller than %d\", bopomofo_len, GetBopomofoBufLen(length));\n        return -1;\n    }\n\n    for (i = 0; i < length && i < MAX_PHRASE_LEN; ++i) {\n        phone_array[i] = sqlite3_column_int(pgdata->static_data.stmt_userphrase[STMT_USERPHRASE_SELECT],\n                                            SQL_STMT_USERPHRASE[STMT_USERPHRASE_SELECT].column[COLUMN_USERPHRASE_PHONE_0\n                                                                                               + i]);\n    }\n\n    strncpy(phrase_buf, phrase, phrase_len);\n    BopomofoFromUintArray(bopomofo_buf, bopomofo_len, phone_array);\n\n    return 0;\n#else\n    if (pgdata->static_data.userphrase_enum) {\n        strncpy(phrase_buf, pgdata->static_data.userphrase_enum->data.wordSeq, phrase_len);\n        phrase_buf[phrase_len - 1] = 0;\n\n        BopomofoFromUintArray(bopomofo_buf, bopomofo_len, pgdata->static_data.userphrase_enum->data.phoneSeq);\n        bopomofo_buf[bopomofo_len - 1] = 0;\n\n        pgdata->static_data.userphrase_enum = FindNextHash(pgdata, pgdata->static_data.userphrase_enum);\n\n        return 0;\n    }\n\n    return -1;\n#endif\n}",
        "begin_line": 1945,
        "end_line": 2008,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_userphrase_add#2010",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_userphrase_add(ChewingContext *ctx, const char *phrase_buf, const char *bopomofo_buf)",
        "snippet": "CHEWING_API int chewing_userphrase_add(ChewingContext *ctx, const char *phrase_buf, const char *bopomofo_buf)\n{\n    ChewingData *pgdata;\n    ssize_t phrase_len;\n    ssize_t phone_len;\n    uint16_t *phone_buf = 0;\n    int ret;\n\n    if (!ctx || !phrase_buf || !bopomofo_buf) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    phrase_len = ueStrLen(phrase_buf);\n    phone_len = UintArrayFromBopomofo(NULL, 0, bopomofo_buf);\n\n    if (phrase_len != phone_len) {\n        return 0;\n    }\n\n    phone_buf = ALC(uint16_t, phone_len + 1);\n    if (!phone_buf)\n        return -1;\n    ret = UintArrayFromBopomofo(phone_buf, phone_len + 1, bopomofo_buf);\n    if (ret == -1) {\n        free(phone_buf);\n        return 0;\n    }\n\n    ret = UserUpdatePhrase(pgdata, phone_buf, phrase_buf);\n    free(phone_buf);\n\n    if (ret == USER_UPDATE_FAIL) {\n        return 0;\n    }\n\n    return 1;\n}",
        "begin_line": 2010,
        "end_line": 2049,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_userphrase_remove#2051",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_userphrase_remove(ChewingContext *ctx, const char *phrase_buf, const char *bopomofo_buf)",
        "snippet": "CHEWING_API int chewing_userphrase_remove(ChewingContext *ctx, const char *phrase_buf, const char *bopomofo_buf)\n{\n    ChewingData *pgdata;\n    ssize_t phone_len;\n    uint16_t *phone_buf = 0;\n    int ret;\n\n    if (!ctx || !phrase_buf || !bopomofo_buf) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    phone_len = UintArrayFromBopomofo(NULL, 0, bopomofo_buf);\n    phone_buf = ALC(uint16_t, phone_len + 1);\n    if (!phone_buf)\n        return 0;\n    ret = UintArrayFromBopomofo(phone_buf, phone_len + 1, bopomofo_buf);\n    if (ret == -1) {\n        free(phone_buf);\n        return 0;\n    }\n    ret = UserRemovePhrase(pgdata, phone_buf, phrase_buf);\n    free(phone_buf);\n\n    return ret;\n}",
        "begin_line": 2051,
        "end_line": 2078,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_userphrase_lookup#2080",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_userphrase_lookup(ChewingContext *ctx, const char *phrase_buf, const char *bopomofo_buf)",
        "snippet": "CHEWING_API int chewing_userphrase_lookup(ChewingContext *ctx, const char *phrase_buf, const char *bopomofo_buf)\n{\n    ChewingData *pgdata;\n    ssize_t phone_len;\n    uint16_t *phone_buf = 0;\n    int ret;\n    UserPhraseData *user_phrase_data;\n\n    if (!ctx || !bopomofo_buf) {\n        return 0;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    phone_len = UintArrayFromBopomofo(NULL, 0, bopomofo_buf);\n    phone_buf = ALC(uint16_t, phone_len + 1);\n    if (!phone_buf)\n        return 0;\n    ret = UintArrayFromBopomofo(phone_buf, phone_len + 1, bopomofo_buf);\n    if (ret == -1) {\n        free(phone_buf);\n        return 0;\n    }\n\n    user_phrase_data = UserGetPhraseFirst(pgdata, phone_buf);\n    while (user_phrase_data) {\n        if (phrase_buf == NULL || strcmp(phrase_buf, user_phrase_data->wordSeq) == 0)\n            break;\n        user_phrase_data = UserGetPhraseNext(pgdata, phone_buf);\n    }\n    UserGetPhraseEnd(pgdata, phone_buf);\n    free(phone_buf);\n    return user_phrase_data == NULL ? 0 : 1;\n}",
        "begin_line": 2080,
        "end_line": 2114,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_cand_string_by_index_static#2116",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_cand_string_by_index_static(ChewingContext *ctx, int index)",
        "snippet": "CHEWING_API const char *chewing_cand_string_by_index_static(ChewingContext *ctx, int index)\n{\n    ChewingData *pgdata;\n    const char *s;\n\n    if (!ctx) {\n        return NULL;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"index = %d\", index);\n\n    if (0 <= index && index < ctx->output->pci->nTotalChoice) {\n        s = ctx->output->pci->totalChoiceStr[index];\n    } else {\n        s = \"\";\n    }\n    return s;\n}",
        "begin_line": 2116,
        "end_line": 2134,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_cand_choose_by_index#2136",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_cand_choose_by_index(ChewingContext *ctx, int index)",
        "snippet": "CHEWING_API int chewing_cand_choose_by_index(ChewingContext *ctx, int index)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n\n    int ret;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"index = %d\", index);\n\n    if (pgdata->choiceInfo.nTotalChoice == 0)\n        return -1;\n\n    ret = SelectCandidate(pgdata, index);\n    if (ret == 0) {\n        CallPhrasing(pgdata, 0);\n        MakeOutputWithRtn(pgo, pgdata, KEYSTROKE_ABSORB);\n    }\n    return ret;\n}",
        "begin_line": 2136,
        "end_line": 2160,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_cand_open#2162",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_cand_open(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_cand_open(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    int pos;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    if (pgdata->bSelect)\n        return 0;\n    if (pgdata->chiSymbolBufLen == 0)\n        return -1;\n\n    pos = pgdata->chiSymbolCursor;\n    if (pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen)\n        --pos;\n\n    chooseCandidate(ctx, ChewingIsChiAt(pos, pgdata), pos);\n\n    return 0;\n}",
        "begin_line": 2162,
        "end_line": 2186,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_cand_close#2188",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_cand_close(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_cand_close(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    if (ctx->data->bSelect) {\n        ChoiceEndChoice(ctx->data);\n    }\n\n    return 0;\n\n}",
        "begin_line": 2188,
        "end_line": 2205,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_cand_list_first#2207",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_cand_list_first(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_cand_list_first(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    if (!pgdata->bSelect)\n        return -1;\n\n    return ChoiceFirstAvail(pgdata);\n}",
        "begin_line": 2207,
        "end_line": 2222,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_cand_list_last#2224",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_cand_list_last(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_cand_list_last(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    if (!pgdata->bSelect)\n        return -1;\n\n    return ChoiceLastAvail(pgdata);\n}",
        "begin_line": 2224,
        "end_line": 2239,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_cand_list_has_next#2241",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_cand_list_has_next(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_cand_list_has_next(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return 0;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    if (!pgdata->bSelect)\n        return 0;\n\n    return ChoiceHasNextAvail(pgdata);\n}",
        "begin_line": 2241,
        "end_line": 2256,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_cand_list_has_prev#2258",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_cand_list_has_prev(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_cand_list_has_prev(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return 0;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    if (!pgdata->bSelect)\n        return 0;\n\n    return ChoiceHasPrevAvail(pgdata);\n}",
        "begin_line": 2258,
        "end_line": 2273,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_cand_list_next#2275",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_cand_list_next(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_cand_list_next(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    if (!pgdata->bSelect)\n        return -1;\n\n    return ChoiceNextAvail(pgdata);\n}",
        "begin_line": 2275,
        "end_line": 2290,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_cand_list_prev#2292",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_cand_list_prev(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_cand_list_prev(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n\n    LOG_API(\"\");\n\n    if (!pgdata->bSelect)\n        return -1;\n\n    return ChoicePrevAvail(pgdata);\n}",
        "begin_line": 2292,
        "end_line": 2307,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_commit_preedit_buf#2309",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_commit_preedit_buf(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_commit_preedit_buf(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n    int len;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    if (pgdata->bSelect)\n        return -1;\n\n    len = pgdata->chiSymbolBufLen;\n\n    if (!len)\n        return -1;\n\n    WriteChiSymbolToCommitBuf(pgdata, pgo, len);\n    if (!pgdata->config.bAutoLearn) {\n        AutoLearnPhrase(pgdata);\n    }\n    CleanAllBuf(pgdata);\n\n    MakeOutputWithRtn(pgo, pgdata, KEYSTROKE_COMMIT);\n\n    return 0;\n}",
        "begin_line": 2309,
        "end_line": 2340,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_clean_preedit_buf#2342",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_clean_preedit_buf(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_clean_preedit_buf(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    if (pgdata->bSelect)\n        return -1;\n\n    CleanAllBuf(pgdata);\n\n    MakeOutput(pgo, pgdata);\n    return 0;\n}",
        "begin_line": 2342,
        "end_line": 2362,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_clean_bopomofo_buf#2364",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_clean_bopomofo_buf(ChewingContext *ctx)",
        "snippet": "CHEWING_API int chewing_clean_bopomofo_buf(ChewingContext *ctx)\n{\n    ChewingData *pgdata;\n    ChewingOutput *pgo;\n\n    if (!ctx) {\n        return -1;\n    }\n    pgdata = ctx->data;\n    pgo = ctx->output;\n\n    LOG_API(\"\");\n\n    if (BopomofoIsEntering(&pgdata->bopomofoData)) {\n        BopomofoRemoveAll(&pgdata->bopomofoData);\n    }\n\n    MakeOutput(pgo, pgdata);\n    return 0;\n}",
        "begin_line": 2364,
        "end_line": 2383,
        "is_bug": false
    },
    {
        "name": "chewingio.chewing_phone_to_bopomofo#2385",
        "src_path": "src/chewingio.c",
        "class_name": "chewingio",
        "signature": "chewingio.chewing_phone_to_bopomofo(unsigned short phone, char *buf, unsigned short len)",
        "snippet": "CHEWING_API int chewing_phone_to_bopomofo(unsigned short phone, char *buf, unsigned short len)\n{\n    if (!buf)\n        return GetPhoneLenFromUint(phone);\n    else if (len <= 0)\n        return -1;\n\n    return PhoneFromUint(buf, len, phone);\n}",
        "begin_line": 2385,
        "end_line": 2393,
        "is_bug": false
    },
    {
        "name": "hash.AlcUserPhraseSeq#28",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.AlcUserPhraseSeq(UserPhraseData *pData, int phonelen, int wordlen)",
        "snippet": "int AlcUserPhraseSeq(UserPhraseData *pData, int phonelen, int wordlen)\n{\n    memset(pData, 0, sizeof(*pData));\n    pData->phoneSeq = ALC(uint16_t, phonelen + 1);\n\n    if (!pData->phoneSeq)\n        goto error;\n    pData->wordSeq = ALC(char, wordlen + 1);\n\n    if (!pData->wordSeq)\n        goto error;\n\n    return 1;\n\n  error:\n    DestroyUserPhraseData(pData);\n    return 0;\n}",
        "begin_line": 28,
        "end_line": 45,
        "is_bug": false
    },
    {
        "name": "hash.DestroyUserPhraseData#47",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.DestroyUserPhraseData(UserPhraseData* pData)",
        "snippet": "void DestroyUserPhraseData(UserPhraseData* pData)\n{\n    free(pData->phoneSeq);\n    pData->phoneSeq = NULL;\n    free(pData->wordSeq);\n    pData->wordSeq = NULL;\n}",
        "begin_line": 47,
        "end_line": 53,
        "is_bug": false
    },
    {
        "name": "hash.PhoneSeqTheSame#55",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.PhoneSeqTheSame(const uint16_t p1[], const uint16_t p2[])",
        "snippet": "static int PhoneSeqTheSame(const uint16_t p1[], const uint16_t p2[])\n{\n    int i;\n\n    if (!p1 || !p2)             /* FIXME: should not happened. */\n        return 0;\n\n    for (i = 0; (p1[i] != 0 && p2[i] != 0); i++) {\n        if (p1[i] != p2[i])\n            return 0;\n    }\n    if (p1[i] != p2[i])\n        return 0;\n    return 1;\n}",
        "begin_line": 55,
        "end_line": 69,
        "is_bug": false
    },
    {
        "name": "hash.HashFunc#71",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.HashFunc(const uint16_t phoneSeq[])",
        "snippet": "static unsigned int HashFunc(const uint16_t phoneSeq[])\n{\n    int i, value = 0;\n\n    for (i = 0; phoneSeq[i] != 0; i++)\n        value ^= phoneSeq[i];\n    return (value & (HASH_TABLE_SIZE - 1));\n}",
        "begin_line": 71,
        "end_line": 78,
        "is_bug": false
    },
    {
        "name": "hash.HashFindPhonePhrase#80",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.HashFindPhonePhrase(ChewingData *pgdata, const uint16_t phoneSeq[], HASH_ITEM *pItemLast)",
        "snippet": "HASH_ITEM *HashFindPhonePhrase(ChewingData *pgdata, const uint16_t phoneSeq[], HASH_ITEM *pItemLast)\n{\n    HASH_ITEM *pNow = pItemLast ? pItemLast->next : pgdata->static_data.hashtable[HashFunc(phoneSeq)];\n\n    for (; pNow; pNow = pNow->next)\n        if (PhoneSeqTheSame(pNow->data.phoneSeq, phoneSeq))\n            return pNow;\n    return NULL;\n}",
        "begin_line": 80,
        "end_line": 88,
        "is_bug": false
    },
    {
        "name": "hash.HashFindHead#90",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.HashFindHead(ChewingData *pgdata, const uint16_t phoneSeq[])",
        "snippet": "HASH_ITEM **HashFindHead(ChewingData *pgdata, const uint16_t phoneSeq[])\n{\n    assert(pgdata);\n    assert(phoneSeq);\n\n    return &pgdata->static_data.hashtable[HashFunc(phoneSeq)];\n}",
        "begin_line": 90,
        "end_line": 96,
        "is_bug": false
    },
    {
        "name": "hash.HashFindEntry#98",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.HashFindEntry(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[])",
        "snippet": "HASH_ITEM *HashFindEntry(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[])\n{\n    HASH_ITEM *pItem;\n    int hashvalue;\n\n    hashvalue = HashFunc(phoneSeq);\n\n    for (pItem = pgdata->static_data.hashtable[hashvalue]; pItem; pItem = pItem->next) {\n        if (!strcmp(pItem->data.wordSeq, wordSeq) && PhoneSeqTheSame(pItem->data.phoneSeq, phoneSeq)) {\n            return pItem;\n        }\n    }\n    return NULL;\n}",
        "begin_line": 98,
        "end_line": 111,
        "is_bug": false
    },
    {
        "name": "hash.HashInsert#113",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.HashInsert(ChewingData *pgdata, UserPhraseData *pData)",
        "snippet": "HASH_ITEM *HashInsert(ChewingData *pgdata, UserPhraseData *pData)\n{\n    int hashvalue;\n    HASH_ITEM *pItem;\n\n    pItem = HashFindEntry(pgdata, pData->phoneSeq, pData->wordSeq);\n    if (pItem != NULL)\n        return pItem;\n\n    pItem = ALC(HASH_ITEM, 1);\n    if (!pItem)\n        return NULL;            /* Error occurs */\n\n    hashvalue = HashFunc(pData->phoneSeq);\n    /* set the new element */\n    pItem->next = pgdata->static_data.hashtable[hashvalue];\n\n    /* transfer ownership of pointers inside |pData| to |pItem->data| */\n    pItem->data = *pData;\n    memset(pData, 0, sizeof(*pData));\n    pItem->item_index = -1;\n\n    /* set link to the new element */\n    pgdata->static_data.hashtable[hashvalue] = pItem;\n\n    return pItem;\n}",
        "begin_line": 113,
        "end_line": 139,
        "is_bug": false
    },
    {
        "name": "hash.FindNextHash#141",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.FindNextHash(const ChewingData *pgdata, HASH_ITEM *curr)",
        "snippet": "HASH_ITEM *FindNextHash(const ChewingData *pgdata, HASH_ITEM *curr)\n{\n    unsigned int hash_value = 0;\n\n    assert(pgdata);\n\n    if (curr) {\n        if (curr->next)\n            return curr->next;\n        /* Find next entry in hash table. */\n        hash_value = HashFunc(curr->data.phoneSeq) + 1;\n    }\n\n    for (; hash_value < HASH_TABLE_SIZE; ++hash_value)\n        if (pgdata->static_data.hashtable[hash_value])\n            return pgdata->static_data.hashtable[hash_value];\n    return NULL;\n}",
        "begin_line": 141,
        "end_line": 158,
        "is_bug": false
    },
    {
        "name": "hash.HashItem2String#160",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.HashItem2String(char *str, HASH_ITEM *pItem)",
        "snippet": "static void HashItem2String(char *str, HASH_ITEM *pItem)\n{\n    int i, len;\n    char buf[FIELD_SIZE];\n\n    sprintf(str, \"%s \", pItem->data.wordSeq);\n    len = ueStrLen(pItem->data.wordSeq);\n    for (i = 0; i < len; i++) {\n        sprintf(buf, \"%hu \", pItem->data.phoneSeq[i]);\n        strcat(str, buf);\n    }\n    sprintf(buf, \"%d %d %d %d\",\n            pItem->data.userfreq, pItem->data.recentTime, pItem->data.maxfreq, pItem->data.origfreq);\n    strcat(str, buf);\n}",
        "begin_line": 160,
        "end_line": 174,
        "is_bug": false
    },
    {
        "name": "hash.HashItem2Binary#179",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.HashItem2Binary(char *str, HASH_ITEM *pItem)",
        "snippet": "static void HashItem2Binary(char *str, HASH_ITEM *pItem)\n{\n    int i, phraselen;\n    char *pc;\n\n    memset(str, 0, FIELD_SIZE);\n    if (sizeof(int) * 4 + ueStrLen(pItem->data.wordSeq) * 2 + strlen(pItem->data.wordSeq) >= FIELD_SIZE) {\n        /* exceed buffer size */\n        return;\n    }\n\n    /* freq info */\n    PutInt32PreservedEndian(pItem->data.userfreq, &str[0]);\n    PutInt32PreservedEndian(pItem->data.recentTime, &str[4]);\n    PutInt32PreservedEndian(pItem->data.maxfreq, &str[8]);\n    PutInt32PreservedEndian(pItem->data.origfreq, &str[12]);\n\n    /* phone seq */\n    phraselen = ueStrLen(pItem->data.wordSeq);\n    str[16] = phraselen;\n    pc = &str[17];\n    for (i = 0; i < phraselen; i++) {\n        PutUint16PreservedEndian(pItem->data.phoneSeq[i], pc);\n        pc += 2;\n    }\n\n    /* phrase */\n    *pc = strlen(pItem->data.wordSeq);\n    strcpy((pc + 1), pItem->data.wordSeq);\n    pItem->data.wordSeq[(unsigned char) *pc] = '\\0';\n}",
        "begin_line": 179,
        "end_line": 209,
        "is_bug": false
    },
    {
        "name": "hash.HashModify#211",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.HashModify(ChewingData *pgdata, HASH_ITEM *pItem)",
        "snippet": "void HashModify(ChewingData *pgdata, HASH_ITEM *pItem)\n{\n    FILE *outfile;\n    char str[FIELD_SIZE + 1];\n\n    outfile = fopen(pgdata->static_data.hashfilename, \"r+b\");\n    if (!outfile)\n        return;\n\n    /* update \"lifetime\" */\n    fseek(outfile, strlen(BIN_HASH_SIG), SEEK_SET);\n    fwrite(&pgdata->static_data.chewing_lifetime, 1, 4, outfile);\n    sprintf(str, \"%d\", pgdata->static_data.chewing_lifetime);\n    DEBUG_OUT(\"HashModify-1: '%-75s'\\n\", str);\n\n    /* update record */\n    if (pItem->item_index < 0) {\n        fseek(outfile, 0, SEEK_END);\n        pItem->item_index = (ftell(outfile) - 4 - strlen(BIN_HASH_SIG)) / FIELD_SIZE;\n    } else if (!HashFileSeekToUserPhrase(pgdata, pItem, outfile)) {\n        goto cleanup;\n    }\n\n    if (pItem->data.phoneSeq[0] == 0)\n        pItem->data.wordSeq[0] = 0;\n\n    HashItem2String(str, pItem);\n    DEBUG_OUT(\"HashModify-2: '%-75s'\\n\", str);\n\n    HashItem2Binary(str, pItem);\n    fwrite(str, 1, FIELD_SIZE, outfile);\n\ncleanup:\n    fflush(outfile);\n    fclose(outfile);\n}",
        "begin_line": 211,
        "end_line": 246,
        "is_bug": false
    },
    {
        "name": "hash.isValidChineseString#248",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.isValidChineseString(char *str)",
        "snippet": "static int isValidChineseString(char *str)\n{\n    if (str == NULL || *str == '\\0') {\n        return 0;\n    }\n    while (*str != '\\0') {\n        int len = ueBytesFromChar((unsigned char) *str);\n\n        if (len <= 1) {\n            return 0;\n        }\n        str += len;\n    };\n    return 1;\n}",
        "begin_line": 248,
        "end_line": 262,
        "is_bug": false
    },
    {
        "name": "hash.ReadHashItem_bin#270",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.ReadHashItem_bin(const char *srcbuf, HASH_ITEM *pItem, int item_index)",
        "snippet": "static int ReadHashItem_bin(const char *srcbuf, HASH_ITEM *pItem, int item_index)\n{\n    int len, i;\n    const char *pc;\n\n    memset(pItem, 0, sizeof(HASH_ITEM));\n\n    /* freq info */\n    pItem->data.userfreq = GetInt32PreservedEndian(&srcbuf[0]);\n    pItem->data.recentTime = GetInt32PreservedEndian(&srcbuf[4]);\n    pItem->data.maxfreq = GetInt32PreservedEndian(&srcbuf[8]);\n    pItem->data.origfreq = GetInt32PreservedEndian(&srcbuf[12]);\n\n    /*\n     * Due to a bug in 0.3.5, some userphrase has negative frequency value.\n     * In this case, we just skip this record.\n     *\n     * See https://github.com/chewing/libchewing/issues/75\n     */\n    if (pItem->data.userfreq < 0 || pItem->data.recentTime < 0 || pItem->data.maxfreq < 0 || pItem->data.origfreq < 0)\n        goto ignore_corrupted_record;\n\n    /* phone seq, length in num of chi words */\n    len = (int) srcbuf[16];\n    pItem->data.phoneSeq = ALC(uint16_t, len + 1);\n\n    pc = &srcbuf[17];\n    for (i = 0; i < len; i++) {\n        pItem->data.phoneSeq[i] = GetUint16PreservedEndian(pc);\n        pc += 2;\n    }\n    pItem->data.phoneSeq[i] = 0;\n\n    /* phrase, length in num of bytes */\n    pItem->data.wordSeq = ALC(char, (*pc) + 1);\n\n    strcpy(pItem->data.wordSeq, (char *) (pc + 1));\n    pItem->data.wordSeq[(unsigned int) *pc] = '\\0';\n\n    /* This record is removed by UserRemovePhrase */\n    if (pItem->data.wordSeq[0] == 0 && pItem->data.phoneSeq[0] == 0)\n        goto ignore_corrupted_record;\n\n    /* Invalid UTF-8 Chinese characters found */\n    if (!isValidChineseString(pItem->data.wordSeq)) {\n        goto ignore_corrupted_record;\n    }\n\n    /* set item_index */\n    pItem->item_index = item_index;\n\n    return 1;                   /* continue */\n\n  ignore_corrupted_record:\n    DestroyUserPhraseData(&pItem->data);\n    return -1;                  /* ignore */\n}",
        "begin_line": 270,
        "end_line": 326,
        "is_bug": false
    },
    {
        "name": "hash.ReadHashItem_txt#332",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.ReadHashItem_txt(FILE * infile, HASH_ITEM *pItem, int item_index)",
        "snippet": "static int ReadHashItem_txt(FILE * infile, HASH_ITEM *pItem, int item_index)\n{\n    int len, i, word_len;\n    char wordbuf[64];\n\n    /* read wordSeq */\n    if (fscanf(infile, \"%s\", wordbuf) != 1)\n        return 0;\n\n    /* Invalid UTF-8 Chinese characters found */\n    if (!isValidChineseString(wordbuf)) {\n        fseek(infile, FIELD_SIZE - strlen(wordbuf) - 1, SEEK_CUR);\n        return -1;\n    }\n\n    word_len = strlen(wordbuf);\n    pItem->data.wordSeq = ALC(char, word_len + 1);\n    strcpy(pItem->data.wordSeq, wordbuf);\n\n    /* read phoneSeq */\n    len = ueStrLen(pItem->data.wordSeq);\n    pItem->data.phoneSeq = ALC(uint16_t, len + 1);\n\n    for (i = 0; i < len; i++)\n        if (fscanf(infile, \"%hu\", &(pItem->data.phoneSeq[i])) != 1)\n            return 0;\n    pItem->data.phoneSeq[len] = 0;\n\n    /* read userfreq & recentTime */\n    if (fscanf(infile, \"%d %d %d %d\",\n               &(pItem->data.userfreq),\n               &(pItem->data.recentTime), &(pItem->data.maxfreq), &(pItem->data.origfreq)) != 4)\n        return 0;\n\n    /* set item_index */\n    pItem->item_index = item_index;\n\n    return 1;\n}",
        "begin_line": 332,
        "end_line": 370,
        "is_bug": false
    },
    {
        "name": "hash.open_file_get_length#372",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.open_file_get_length(const char *filename, const char *otype, int *size)",
        "snippet": "static FILE *open_file_get_length(const char *filename, const char *otype, int *size)\n{\n    FILE *tf = fopen(filename, otype);\n\n    if (tf == NULL) {\n        return NULL;\n    }\n    if (size != NULL) {\n        int ok;\n        ok = fseek(tf, 0, SEEK_END);\n        if (ok < 0) {\n            fclose(tf);\n            return NULL;\n        }\n        *size = ftell(tf);\n        if (*size < 0) {\n            fclose(tf);\n            return NULL;\n        }\n        ok = fseek(tf, 0, SEEK_SET);\n        if (ok < 0) {\n            fclose(tf);\n            return NULL;\n        }\n    }\n    return tf;\n}",
        "begin_line": 372,
        "end_line": 398,
        "is_bug": false
    },
    {
        "name": "hash._load_hash_file#400",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash._load_hash_file(const char *filename, int *size)",
        "snippet": "static char *_load_hash_file(const char *filename, int *size)\n{\n    int flen;\n    char *pd = NULL;\n    FILE *tf;\n\n    tf = open_file_get_length(filename, \"rb\", &flen);\n    if (tf == NULL) {\n        goto err_load_file;\n    }\n    pd = ALC(char, flen);\n\n    if (pd == NULL) {\n        goto err_load_file;\n    }\n    if (fread(pd, flen, 1, tf) != 1) {\n        goto err_load_file;\n    }\n    fclose(tf);\n    if (size != NULL)\n        *size = flen;\n    return pd;\n\n  err_load_file:\n    if (pd != NULL)\n        free(pd);\n    if (tf != NULL)\n        fclose(tf);\n    return NULL;\n}",
        "begin_line": 400,
        "end_line": 429,
        "is_bug": false
    },
    {
        "name": "hash.migrate_hash_to_bin#432",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.migrate_hash_to_bin(ChewingData *pgdata)",
        "snippet": "static int migrate_hash_to_bin(ChewingData *pgdata)\n{\n    FILE *txtfile;\n    char oldname[256], *dump, *seekdump;\n    HASH_ITEM item;\n    int item_index, iret, tflen;\n    int ret;\n    const char *ofilename = pgdata->static_data.hashfilename;\n\n    /* allocate dump buffer */\n    txtfile = open_file_get_length(ofilename, \"r\", &tflen);\n    if (txtfile == NULL) {\n        return 0;\n    }\n    dump = ALC(char, tflen * 2);\n    if (dump == NULL) {\n        fclose(txtfile);\n        return 0;\n    }\n    ret = fscanf(txtfile, \"%d\", &pgdata->static_data.chewing_lifetime);\n    if (ret != 1) {\n        free(dump);\n        return 0;\n    }\n\n    /* prepare the bin file */\n    seekdump = dump;\n    memcpy(seekdump, BIN_HASH_SIG, strlen(BIN_HASH_SIG));\n    memcpy(seekdump + strlen(BIN_HASH_SIG),\n           &pgdata->static_data.chewing_lifetime, sizeof(pgdata->static_data.chewing_lifetime));\n    seekdump += strlen(BIN_HASH_SIG) + sizeof(pgdata->static_data.chewing_lifetime);\n\n    /* migrate */\n    item_index = 0;\n    while (1) {\n        iret = ReadHashItem_txt(txtfile, &item, ++item_index);\n\n        if (iret == -1) {\n            --item_index;\n            continue;\n        } else if (iret == 0)\n            break;\n\n        HashItem2Binary(seekdump, &item);\n        seekdump += FIELD_SIZE;\n        DestroyUserPhraseData(&item.data);\n    };\n    fclose(txtfile);\n\n    /* backup as *.old */\n    snprintf(oldname, sizeof(oldname), \"%s%s\", ofilename, \".old\");\n    PLAT_UNLINK(oldname);\n    PLAT_RENAME(ofilename, oldname);\n\n    /* dump new file */\n    PLAT_UNLINK(ofilename);\n    txtfile = fopen(ofilename, \"w+b\");\n    fwrite(dump, seekdump - dump, 1, txtfile);\n    fflush(txtfile);\n    fclose(txtfile);\n    free(dump);\n\n    return 1;\n}",
        "begin_line": 432,
        "end_line": 495,
        "is_bug": false
    },
    {
        "name": "hash.FreeHashItem#497",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.FreeHashItem(HASH_ITEM *pItem)",
        "snippet": "void FreeHashItem(HASH_ITEM *pItem)\n{\n    while (pItem) {\n        HASH_ITEM *next = pItem->next;\n\n        DestroyUserPhraseData(&pItem->data);\n        free(pItem);\n        pItem = next;\n    }\n}",
        "begin_line": 497,
        "end_line": 506,
        "is_bug": false
    },
    {
        "name": "hash.TerminateUserphrase#508",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.TerminateUserphrase(ChewingData *pgdata)",
        "snippet": "void TerminateUserphrase(ChewingData *pgdata)\n{\n    HASH_ITEM *pItem;\n    int i;\n\n    for (i = 0; i < HASH_TABLE_SIZE; ++i) {\n        pItem = pgdata->static_data.hashtable[i];\n        FreeHashItem(pItem);\n    }\n}",
        "begin_line": 508,
        "end_line": 517,
        "is_bug": false
    },
    {
        "name": "hash.InitUserphrase#519",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.InitUserphrase(struct ChewingData *pgdata, const char *path)",
        "snippet": "int InitUserphrase(struct ChewingData *pgdata, const char *path)\n{\n    HASH_ITEM item, *pItem, *pPool = NULL;\n    int item_index, hashvalue, iret, fsize, hdrlen, oldest = INT_MAX;\n    char *dump, *seekdump;\n\n    strncpy(pgdata->static_data.hashfilename, path, sizeof(pgdata->static_data.hashfilename));\n    memset(pgdata->static_data.hashtable, 0, sizeof(pgdata->static_data.hashtable));\n\n  open_hash_file:\n    dump = _load_hash_file(pgdata->static_data.hashfilename, &fsize);\n    hdrlen = strlen(BIN_HASH_SIG) + sizeof(pgdata->static_data.chewing_lifetime);\n    item_index = 0;\n    if (dump == NULL || fsize < hdrlen) {\n        FILE *outfile;\n\n        outfile = fopen(pgdata->static_data.hashfilename, \"w+b\");\n        if (!outfile) {\n            if (dump) {\n                free(dump);\n            }\n            return -1;\n        }\n        pgdata->static_data.chewing_lifetime = 0;\n        fwrite(BIN_HASH_SIG, 1, strlen(BIN_HASH_SIG), outfile);\n        fwrite(&pgdata->static_data.chewing_lifetime, 1, sizeof(pgdata->static_data.chewing_lifetime), outfile);\n        fclose(outfile);\n    } else {\n        if (memcmp(dump, BIN_HASH_SIG, strlen(BIN_HASH_SIG)) != 0) {\n            /* perform migrate from text-based to binary form */\n            free(dump);\n            if (!migrate_hash_to_bin(pgdata)) {\n                return -1;\n            }\n            goto open_hash_file;\n        }\n\n        pgdata->static_data.chewing_lifetime = *(int *) (dump + strlen(BIN_HASH_SIG));\n        seekdump = dump + hdrlen;\n        fsize -= hdrlen;\n\n        while (fsize >= FIELD_SIZE) {\n            iret = ReadHashItem_bin(seekdump, &item, item_index++);\n            /* Ignore illegal data */\n            if (iret == -1) {\n                seekdump += FIELD_SIZE;\n                fsize -= FIELD_SIZE;\n                --item_index;\n                continue;\n            } else if (iret == 0)\n                break;\n\n            pItem = ALC(HASH_ITEM, 1);\n\n            memcpy(pItem, &item, sizeof(HASH_ITEM));\n            pItem->next = pPool;\n            pPool = pItem;\n\n            if (oldest > pItem->data.recentTime) {\n                oldest = pItem->data.recentTime;\n            }\n\n            seekdump += FIELD_SIZE;\n            fsize -= FIELD_SIZE;\n        }\n        free(dump);\n\n        while (pPool) {\n            pItem = pPool;\n            pPool = pItem->next;\n\n            hashvalue = HashFunc(pItem->data.phoneSeq);\n            pItem->next = pgdata->static_data.hashtable[hashvalue];\n            pgdata->static_data.hashtable[hashvalue] = pItem;\n            pItem->data.recentTime -= oldest;\n        }\n        pgdata->static_data.chewing_lifetime -= oldest;\n    }\n    return 0;\n}",
        "begin_line": 519,
        "end_line": 598,
        "is_bug": false
    },
    {
        "name": "hash.HashFileSeekToUserPhrase#600",
        "src_path": "src/hash.c",
        "class_name": "hash",
        "signature": "hash.HashFileSeekToUserPhrase(struct ChewingData *pgdata, HASH_ITEM *pItem, FILE *fpHash)",
        "snippet": "int HashFileSeekToUserPhrase(struct ChewingData *pgdata, HASH_ITEM *pItem, FILE *fpHash)\n{\n    int fsize           = 0;\n    int iret            = 0;\n    int item_index      = 0;\n    int hdrlen          = 0;\n    int result          = 0;\n    char *seekdump      = NULL;\n    char *buf           = NULL;\n    HASH_ITEM *pItemTmp = NULL;\n\n    pItemTmp = ALC(HASH_ITEM, 1);\n    if (!pItemTmp)\n        return 0;\n\n    fseek(fpHash, 0, SEEK_END);\n    fsize = ftell(fpHash);\n\n    buf = ALC(char, fsize);\n    if (!buf) {\n        free(pItemTmp);\n        return 0;\n    }\n\n    fseek(fpHash, 0, SEEK_SET);\n    if (fread(buf, fsize, 1, fpHash) != 1) {\n        free(pItemTmp);\n        free(buf);\n        return 0;\n    }\n\n    hdrlen = strlen(BIN_HASH_SIG) + sizeof(pgdata->static_data.chewing_lifetime);\n    seekdump = buf + hdrlen;\n    fsize -= hdrlen;\n\n    while (fsize >= FIELD_SIZE) {\n        iret = ReadHashItem_bin(seekdump, pItemTmp, item_index);\n        if (iret == 1) {\n            if (strlen(pItem->data.wordSeq) == strlen(pItemTmp->data.wordSeq) &&\n                !strncmp(pItem->data.wordSeq, pItemTmp->data.wordSeq, strlen(pItem->data.wordSeq))) {\n                fseek(fpHash, (item_index * FIELD_SIZE) + hdrlen, SEEK_SET);\n                DestroyUserPhraseData(&pItemTmp->data);\n                result = 1;\n                break;\n            }\n            DestroyUserPhraseData(&pItemTmp->data);\n        }\n\n        seekdump += FIELD_SIZE;\n        fsize -= FIELD_SIZE;\n        item_index++;\n    }\n\n    free(pItemTmp);\n    free(buf);\n    return result;\n}",
        "begin_line": 600,
        "end_line": 656,
        "is_bug": false
    },
    {
        "name": "porting_layer.rpl_malloc.rpl_malloc#14",
        "src_path": "src/porting_layer/src/rpl_malloc.c",
        "class_name": "porting_layer.rpl_malloc",
        "signature": "porting_layer.rpl_malloc.rpl_malloc(size_t n)",
        "snippet": "void *rpl_malloc(size_t n)\n{\n    if (n == 0)\n        n = 1;\n    return malloc(n);\n}",
        "begin_line": 14,
        "end_line": 19,
        "is_bug": false
    },
    {
        "name": "porting_layer.plat_path.strtok_r#99",
        "src_path": "src/porting_layer/src/plat_path.c",
        "class_name": "porting_layer.plat_path",
        "signature": "porting_layer.plat_path.strtok_r(char *s, const char *delim, char **save_ptr)",
        "snippet": "char *strtok_r(char *s, const char *delim, char **save_ptr)\n{\n    char *token;\n\n    if (s == NULL)\n        s = *save_ptr;\n\n    /* Scan leading delimiters.  */\n    s += strspn(s, delim);\n    if (*s == '\\0') {\n        *save_ptr = s;\n        return NULL;\n    }\n\n    /* Find the end of the token.  */\n    token = s;\n    s = strpbrk(token, delim);\n    if (s == NULL) {\n        /* This token finishes the string.  */\n        *save_ptr = token + strlen(token);\n    } else {\n        /* Terminate the token and make *SAVE_PTR point past it.  */\n        *s = '\\0';\n        *save_ptr = s + 1;\n    }\n    return token;\n}",
        "begin_line": 99,
        "end_line": 125,
        "is_bug": false
    },
    {
        "name": "porting_layer.plat_path.asprintf#129",
        "src_path": "src/porting_layer/src/plat_path.c",
        "class_name": "porting_layer.plat_path",
        "signature": "porting_layer.plat_path.asprintf(char **strp, const char *fmt, ...)",
        "snippet": "int asprintf(char **strp, const char *fmt, ...)\n{\n    char *buf;\n    size_t len;\n    va_list ap;\n\n    va_start(ap, fmt);\n    len = vsnprintf(NULL, 0, fmt, ap);\n    va_end(ap);\n\n    buf = (char *) malloc(len + 1);\n    if (!buf)\n        return -1;\n\n    va_start(ap, fmt);\n    len = vsnprintf(buf, len + 1, fmt, ap);\n    va_end(ap);\n\n    *strp = buf;\n\n    return len;\n}",
        "begin_line": 129,
        "end_line": 150,
        "is_bug": false
    },
    {
        "name": "porting_layer.plat_path.are_all_files_readable#153",
        "src_path": "src/porting_layer/src/plat_path.c",
        "class_name": "porting_layer.plat_path",
        "signature": "porting_layer.plat_path.are_all_files_readable(const char *path, const char *const *files, char *output, size_t output_len)",
        "snippet": "static int are_all_files_readable(const char *path,\n                                  const char *const *files,\n                                  char *output, size_t output_len)\n{\n    int i;\n\n    assert(path);\n    assert(files);\n\n    for (i = 0; files[i] != NULL; ++i) {\n        snprintf(output, output_len,\n                 \"%s\" PLAT_SEPARATOR \"%s\", path, files[i]);\n        if (access(output, R_OK) != 0)\n            return 0;\n    }\n\n    return 1;\n}",
        "begin_line": 153,
        "end_line": 170,
        "is_bug": false
    },
    {
        "name": "porting_layer.plat_path.find_path_by_files#172",
        "src_path": "src/porting_layer/src/plat_path.c",
        "class_name": "porting_layer.plat_path",
        "signature": "porting_layer.plat_path.find_path_by_files(const char *search_path, const char *const *files, char *output, size_t output_len)",
        "snippet": "int find_path_by_files(const char *search_path,\n                       const char *const *files,\n                       char *output, size_t output_len)\n{\n    char buffer[PATH_MAX + 1] = {0};\n    char *path;\n    char *saveptr;\n    int ret;\n\n    assert(search_path);\n    assert(files);\n    assert(output);\n    assert(output_len);\n\n    /* strtok_r will modify its first parameter. */\n    strncpy(buffer, search_path, sizeof(buffer) - 1);\n\n    for (path = strtok_r(buffer, SEARCH_PATH_SEP, &saveptr); path;\n         path = strtok_r(NULL, SEARCH_PATH_SEP, &saveptr)) {\n        ret = are_all_files_readable(path, files, output, output_len);\n        if (ret) {\n            snprintf(output, output_len, \"%s\", path);\n            return 0;\n        }\n    }\n    return -1;\n}",
        "begin_line": 172,
        "end_line": 198,
        "is_bug": false
    },
    {
        "name": "common.key2pho.UintFromPhone#93",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.UintFromPhone(const char *zhuin)",
        "snippet": "uint16_t UintFromPhone(const char *zhuin)\n{\n    const char *iter;\n    char *pos;\n    char buf[MAX_UTF8_SIZE + 1];\n    int len, result = 0;\n    int zhuin_index = 0;\n\n    iter = zhuin;\n\n    /* 0x20: space character */\n    while (*iter && *iter != 0x20) {\n        len = ueStrNCpy(buf, iter, 1, STRNCPY_CLOSE);\n\n        for (; zhuin_index < BOPOMOFO_SIZE; ++zhuin_index) {\n            pos = strstr(zhuin_tab[zhuin_index], buf);\n            if (pos) {\n                break;\n            }\n        }\n\n        if (zhuin_index >= BOPOMOFO_SIZE) {\n            return 0;\n        }\n\n        result |= (zhuin_tab_num[zhuin_index] - ueStrLen(pos)) << shift[zhuin_index];\n        ++zhuin_index;\n        iter += len;\n    }\n    return result;\n}",
        "begin_line": 93,
        "end_line": 123,
        "is_bug": false
    },
    {
        "name": "common.key2pho.PhoneFromKey#125",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.PhoneFromKey(char *pho, const char *inputkey, KBTYPE kbtype, int searchTimes)",
        "snippet": "int PhoneFromKey(char *pho, const char *inputkey, KBTYPE kbtype, int searchTimes)\n{\n    int len;\n    int i;\n    int s;\n    const char *pTarget;\n\n    len = strlen(inputkey);\n\n    pho[0] = '\\0';\n    for (i = 0; i < len; i++) {\n        char *findptr = NULL;\n        int _index;\n\n        pTarget = key_str[kbtype];\n        for (s = 0; s < searchTimes; s++) {\n            findptr = strchr(pTarget, inputkey[i]);\n            if (!findptr) {\n                return 0;\n            }\n            pTarget = findptr + 1;\n        }\n        _index = findptr - key_str[kbtype];\n        ueStrNCpy(ueStrSeek(pho, i), ueConstStrSeek(ph_str, _index), 1, STRNCPY_NOT_CLOSE);\n    }\n    pho = ueStrSeek(pho, len);\n    pho[0] = '\\0';\n    return 1;\n}",
        "begin_line": 125,
        "end_line": 153,
        "is_bug": false
    },
    {
        "name": "common.key2pho.PhoneFromUint#155",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.PhoneFromUint(char *phone, size_t phone_len, uint16_t phone_num)",
        "snippet": "int PhoneFromUint(char *phone, size_t phone_len, uint16_t phone_num)\n{\n    int i;\n    int index;\n    const char *pos;\n    char tmp[MAX_UTF8_SIZE + 1];\n    char buffer[MAX_UTF8_SIZE * BOPOMOFO_SIZE + 1] = { 0 };\n\n    for (i = 0; i < BOPOMOFO_SIZE; ++i) {\n        /* The first two characters in zhuin_tab are space, so we need\n           to add 1 here. */\n        index = ((phone_num >> shift[i]) & mask[i]);\n        if (index >= 1) {\n            pos = ueConstStrSeek(zhuin_tab[i], index - 1);\n            ueStrNCpy(tmp, pos, 1, STRNCPY_CLOSE);\n            strcat(buffer, tmp);\n        }\n    }\n    if (!buffer[0]) {\n        phone[0] = 0;\n        return -1;\n    }\n    strncpy(phone, buffer, phone_len);\n    phone[phone_len - 1] = 0;\n    if (phone_len < strlen(buffer) + 1)\n        return -1;\n    return 0;\n}",
        "begin_line": 155,
        "end_line": 182,
        "is_bug": false
    },
    {
        "name": "common.key2pho.PhoneInxFromKey#184",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.PhoneInxFromKey(int key, int type, KBTYPE kbtype, int searchTimes)",
        "snippet": "int PhoneInxFromKey(int key, int type, KBTYPE kbtype, int searchTimes)\n{\n    char keyStr[2];\n    char rtStr[10];\n    char *p;\n\n    keyStr[0] = key;\n    keyStr[1] = '\\0';\n\n    if (!PhoneFromKey(rtStr, keyStr, kbtype, searchTimes))\n        return 0;\n\n    p = strstr(zhuin_tab[type], rtStr);\n    if (!p)\n        return 0;\n\n    return zhuin_tab_num[type] - ueStrLen(p);\n}",
        "begin_line": 184,
        "end_line": 201,
        "is_bug": false
    },
    {
        "name": "common.key2pho.UintFromPhoneInx#203",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.UintFromPhoneInx(const int ph_inx[])",
        "snippet": "uint16_t UintFromPhoneInx(const int ph_inx[])\n{\n    int i;\n    uint16_t result = 0;\n\n    for (i = 0; i < BOPOMOFO_SIZE; i++) {\n        if (ph_inx[i] < 0 || ph_inx[i] >= zhuin_tab_num[i])\n            return 0;\n\n        result |= ph_inx[i] << shift[i];\n    }\n\n    return result;\n}",
        "begin_line": 203,
        "end_line": 216,
        "is_bug": false
    },
    {
        "name": "common.key2pho.GetPhoneLen#218",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.GetPhoneLen(const uint16_t *phoneSeq)",
        "snippet": "size_t GetPhoneLen(const uint16_t *phoneSeq)\n{\n    size_t len = 0;\n\n    assert(phoneSeq);\n\n    while (phoneSeq[len])\n        ++len;\n    return len;\n}",
        "begin_line": 218,
        "end_line": 227,
        "is_bug": false
    },
    {
        "name": "common.key2pho.GetBopomofoCount#229",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.GetBopomofoCount(const char *bopomofo_buf)",
        "snippet": "static size_t GetBopomofoCount(const char *bopomofo_buf)\n{\n    size_t count = 0;\n\n    assert(bopomofo_buf);\n\n    while ((bopomofo_buf = strpbrk(bopomofo_buf, \" \")) != NULL) {\n        ++count;\n        bopomofo_buf += 1;\n    }\n\n    return count;\n}",
        "begin_line": 229,
        "end_line": 241,
        "is_bug": false
    },
    {
        "name": "common.key2pho.BopomofoFromUintArray#243",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.BopomofoFromUintArray(char *const bopomofo_buf, const size_t bopomofo_len, const uint16_t *phoneSeq)",
        "snippet": "size_t BopomofoFromUintArray(char *const bopomofo_buf, const size_t bopomofo_len, const uint16_t *phoneSeq)\n{\n    size_t i;\n    size_t len;\n    size_t buf_len;\n    size_t shift = 0;\n\n    assert(phoneSeq);\n\n    len = GetPhoneLen(phoneSeq);\n    buf_len = GetBopomofoBufLen(len);\n\n    if (bopomofo_buf && bopomofo_len >= buf_len) {\n        for (i = 0; i < len; ++i) {\n            PhoneFromUint(bopomofo_buf + shift, bopomofo_len - shift, phoneSeq[i]);\n            strcat(bopomofo_buf + shift, \" \");\n            shift += strlen(bopomofo_buf + shift);\n        }\n        if (shift)\n            bopomofo_buf[shift - 1] = 0;\n    }\n    return buf_len;\n}",
        "begin_line": 243,
        "end_line": 265,
        "is_bug": false
    },
    {
        "name": "common.key2pho.UintArrayFromBopomofo#267",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.UintArrayFromBopomofo(uint16_t *phone_seq, const size_t phone_len, const char *bopomofo_buf)",
        "snippet": "ssize_t UintArrayFromBopomofo(uint16_t *phone_seq, const size_t phone_len, const char *bopomofo_buf)\n{\n    size_t i;\n    size_t len;\n\n    assert(bopomofo_buf);\n\n    len = GetBopomofoCount(bopomofo_buf) + 1;\n    if (!phone_seq)\n        return len;\n\n    if (phone_len <= len)\n        return -1;\n\n    for (i = 0; i < len; ++i) {\n        phone_seq[i] = UintFromPhone(bopomofo_buf);\n        if (phone_seq[i] == 0)\n            return -1;\n        bopomofo_buf = strpbrk(bopomofo_buf, \" \") + 1;\n    }\n    phone_seq[len] = 0;\n\n    return len;\n}",
        "begin_line": 267,
        "end_line": 290,
        "is_bug": false
    },
    {
        "name": "common.key2pho.GetBopomofoBufLen#292",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.GetBopomofoBufLen(size_t len)",
        "snippet": "size_t GetBopomofoBufLen(size_t len)\n{\n    return (MAX_UTF8_SIZE * BOPOMOFO_SIZE + 1) * len;\n}",
        "begin_line": 292,
        "end_line": 295,
        "is_bug": false
    },
    {
        "name": "common.key2pho.GetPhoneLenFromUint#297",
        "src_path": "src/common/key2pho.c",
        "class_name": "common.key2pho",
        "signature": "common.key2pho.GetPhoneLenFromUint(uint16_t phone_num)",
        "snippet": "size_t GetPhoneLenFromUint(uint16_t phone_num)\n{\n    int i;\n    size_t len = 0 ;\n\n    for (i = 0; i < BOPOMOFO_SIZE; ++i) {\n        /* The first two characters in zhuin_tab are space, so we need\n           to add 1 here. */\n        int index = ((phone_num >> shift[i]) & mask[i]);\n        if (index >= 1) {\n            const char *pos = ueConstStrSeek(zhuin_tab[i], index - 1);\n            len += ueStrNBytes(pos, 1);\n        }\n    }\n    return len > 0 ? (len + 1) : -1;\n}",
        "begin_line": 297,
        "end_line": 312,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueStrLen#28",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueStrLen(const char *str)",
        "snippet": "int ueStrLen(const char *str)\n{\n    int length = 0;\n    const char *strptr = str;\n\n    while (strptr[0] != '\\0') {\n        strptr += ueBytesFromChar(strptr[0]);\n        ++length;\n    }\n    return length;\n}",
        "begin_line": 28,
        "end_line": 38,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueBytesFromChar#41",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueBytesFromChar(unsigned char b)",
        "snippet": "int ueBytesFromChar(unsigned char b)\n{\n    return utf8len_tab[b];\n}",
        "begin_line": 41,
        "end_line": 44,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueStrNBytes#47",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueStrNBytes(const char *str, int n)",
        "snippet": "int ueStrNBytes(const char *str, int n)\n{\n    int i = 0, len = 0;\n    const char *iter = str;\n\n    for (i = 0; i < n; i++) {\n        len += ueBytesFromChar(iter[len]);\n    }\n    return len;\n}",
        "begin_line": 47,
        "end_line": 56,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueStrNCpy#59",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueStrNCpy(char dest[], const char *src, size_t n, int end)",
        "snippet": "int ueStrNCpy(char dest[], const char *src, size_t n, int end)\n{\n    int len = 0;\n\n    len = ueStrNBytes(src, n);\n    memcpy(dest, src, len);\n    if (end == STRNCPY_CLOSE)\n        dest[len] = '\\0';\n    return len;\n}",
        "begin_line": 59,
        "end_line": 68,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueConstStrSeek#70",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueConstStrSeek(const char *src, size_t n)",
        "snippet": "const char *ueConstStrSeek(const char *src, size_t n)\n{\n    size_t i = 0;\n    const char *iter = src;\n\n    for (i = 0; i < n; i++) {\n        iter += ueBytesFromChar(iter[0]);\n    }\n    return iter;\n}",
        "begin_line": 70,
        "end_line": 79,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueStrSeek#81",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueStrSeek(char *src, size_t n)",
        "snippet": "char *ueStrSeek(char *src, size_t n)\n{\n    size_t i = 0;\n    char *iter = src;\n\n    for (i = 0; i < n; i++) {\n        iter += ueBytesFromChar(iter[0]);\n    }\n    return iter;\n}",
        "begin_line": 81,
        "end_line": 90,
        "is_bug": false
    },
    {
        "name": "common.chewing-utf8-util.ueStrStr#93",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "common.chewing-utf8-util",
        "signature": "common.chewing-utf8-util.ueStrStr(const char *str, size_t lstr, const char *substr, size_t lsub)",
        "snippet": "const char *ueStrStr(const char *str, size_t lstr, const char *substr, size_t lsub)\n{\n    const char *p = str;\n    size_t ub;\n\n    if (lstr < lsub)\n        return NULL;\n    ub = lstr - lsub;\n    for (; (size_t) (p - str) <= ub; p++) {\n        if (!strncmp(p, substr, lsub))\n            return p;\n    }\n    return NULL;\n}",
        "begin_line": 93,
        "end_line": 106,
        "is_bug": false
    },
    {
        "name": "userphrase-hash.LoadOriginalFreq#28",
        "src_path": "src/userphrase-hash.c",
        "class_name": "userphrase-hash",
        "signature": "userphrase-hash.LoadOriginalFreq(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int len)",
        "snippet": "static int LoadOriginalFreq(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int len)\n{\n    const TreeType *tree_pos;\n    int retval;\n    Phrase *phrase = ALC(Phrase, 1);\n\n    tree_pos = TreeFindPhrase(pgdata, 0, len - 1, phoneSeq);\n    if (tree_pos) {\n        GetPhraseFirst(pgdata, phrase, tree_pos);\n        do {\n            /* find the same phrase */\n            if (!strcmp(phrase->phrase, wordSeq)) {\n                retval = phrase->freq;\n                free(phrase);\n                return retval;\n            }\n        } while (GetVocabNext(pgdata, phrase));\n    }\n\n    free(phrase);\n    return FREQ_INIT_VALUE;\n}",
        "begin_line": 28,
        "end_line": 49,
        "is_bug": false
    },
    {
        "name": "userphrase-hash.LoadMaxFreq#52",
        "src_path": "src/userphrase-hash.c",
        "class_name": "userphrase-hash",
        "signature": "userphrase-hash.LoadMaxFreq(ChewingData *pgdata, const uint16_t phoneSeq[], int len)",
        "snippet": "static int LoadMaxFreq(ChewingData *pgdata, const uint16_t phoneSeq[], int len)\n{\n    const TreeType *tree_pos;\n    Phrase *phrase = ALC(Phrase, 1);\n    int maxFreq = FREQ_INIT_VALUE;\n    UserPhraseData *uphrase;\n\n    tree_pos = TreeFindPhrase(pgdata, 0, len - 1, phoneSeq);\n    if (tree_pos) {\n        GetPhraseFirst(pgdata, phrase, tree_pos);\n        do {\n            if (phrase->freq > maxFreq)\n                maxFreq = phrase->freq;\n        } while (GetVocabNext(pgdata, phrase));\n    }\n    free(phrase);\n\n    uphrase = UserGetPhraseFirst(pgdata, phoneSeq);\n    while (uphrase) {\n        if (uphrase->userfreq > maxFreq)\n            maxFreq = uphrase->userfreq;\n        uphrase = UserGetPhraseNext(pgdata, phoneSeq);\n    }\n\n    return maxFreq;\n}",
        "begin_line": 52,
        "end_line": 77,
        "is_bug": false
    },
    {
        "name": "userphrase-hash.UpdateFreq#80",
        "src_path": "src/userphrase-hash.c",
        "class_name": "userphrase-hash",
        "signature": "userphrase-hash.UpdateFreq(int freq, int maxfreq, int origfreq, int deltatime)",
        "snippet": "static int UpdateFreq(int freq, int maxfreq, int origfreq, int deltatime)\n{\n    int delta;\n\n    /* Short interval */\n    if (deltatime < 4000) {\n        delta = (freq >= maxfreq) ?\n            min((maxfreq - origfreq) / 5 + 1,\n                SHORT_INCREASE_FREQ) : max((maxfreq - origfreq) / 5 + 1, SHORT_INCREASE_FREQ);\n        return min(freq + delta, MAX_ALLOW_FREQ);\n    }\n    /* Medium interval */\n    else if (deltatime < 50000) {\n        delta = (freq >= maxfreq) ?\n            min((maxfreq - origfreq) / 10 + 1,\n                MEDIUM_INCREASE_FREQ) : max((maxfreq - origfreq) / 10 + 1, MEDIUM_INCREASE_FREQ);\n        return min(freq + delta, MAX_ALLOW_FREQ);\n    }\n    /* long interval */\n    else {\n        delta = max((freq - origfreq) / 5, LONG_DECREASE_FREQ);\n        return max(freq - delta, origfreq);\n    }\n}",
        "begin_line": 80,
        "end_line": 103,
        "is_bug": false
    },
    {
        "name": "userphrase-hash.LogUserPhrase#105",
        "src_path": "src/userphrase-hash.c",
        "class_name": "userphrase-hash",
        "signature": "userphrase-hash.LogUserPhrase(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int orig_freq, int max_freq, int user_freq, int recent_time)",
        "snippet": "static void LogUserPhrase(ChewingData *pgdata,\n                          const uint16_t phoneSeq[],\n                          const char wordSeq[], int orig_freq, int max_freq, int user_freq, int recent_time)\n{\n    /* Size of each phone is len(\"0x1234 \") = 7 */\n    char buf[7 * MAX_PHRASE_LEN + 1] = { 0 };\n    int i;\n\n    for (i = 0; i < MAX_PHRASE_LEN; ++i) {\n        if (phoneSeq[i] == 0)\n            break;\n        snprintf(buf + 7 * i, 7 + 1, \"%#06x \", phoneSeq[i]);\n    }\n\n    LOG_INFO(\"userphrase %s, phone = %s, orig_freq = %d, max_freq = %d, user_freq = %d, recent_time = %d\",\n             wordSeq, buf, orig_freq, max_freq, user_freq, recent_time);\n}",
        "begin_line": 105,
        "end_line": 121,
        "is_bug": false
    },
    {
        "name": "userphrase-hash.UserUpdatePhraseBegin#123",
        "src_path": "src/userphrase-hash.c",
        "class_name": "userphrase-hash",
        "signature": "userphrase-hash.UserUpdatePhraseBegin(ChewingData *pgdata)",
        "snippet": "void UserUpdatePhraseBegin(ChewingData *pgdata)\n{\n    /* compatibile with sqlite userphrase */\n}",
        "begin_line": 123,
        "end_line": 126,
        "is_bug": false
    },
    {
        "name": "userphrase-hash.UserUpdatePhrase#128",
        "src_path": "src/userphrase-hash.c",
        "class_name": "userphrase-hash",
        "signature": "userphrase-hash.UserUpdatePhrase(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[])",
        "snippet": "int UserUpdatePhrase(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[])\n{\n    HASH_ITEM *pItem;\n    UserPhraseData data;\n    int len;\n\n    len = ueStrLen(wordSeq);\n    if (len > MAX_PHRASE_LEN)\n        return USER_UPDATE_FAIL;\n\n    pItem = HashFindEntry(pgdata, phoneSeq, wordSeq);\n    if (!pItem) {\n        if (!AlcUserPhraseSeq(&data, len, strlen(wordSeq))) {\n            return USER_UPDATE_FAIL;\n        }\n\n        memcpy(data.phoneSeq, phoneSeq, len * sizeof(phoneSeq[0]));\n        data.phoneSeq[len] = 0;\n        strcpy(data.wordSeq, wordSeq);\n\n        /* load initial freq */\n        data.origfreq = LoadOriginalFreq(pgdata, phoneSeq, wordSeq, len);\n        data.maxfreq = LoadMaxFreq(pgdata, phoneSeq, len);\n\n        data.userfreq = data.origfreq;\n        data.recentTime = pgdata->static_data.chewing_lifetime;\n        pItem = HashInsert(pgdata, &data);\n        DestroyUserPhraseData(&data);\n        LogUserPhrase(pgdata, phoneSeq, wordSeq, pItem->data.origfreq, pItem->data.maxfreq, pItem->data.userfreq,\n                      pItem->data.recentTime);\n        HashModify(pgdata, pItem);\n        return USER_UPDATE_INSERT;\n    } else {\n        pItem->data.maxfreq = LoadMaxFreq(pgdata, phoneSeq, len);\n        pItem->data.userfreq = UpdateFreq(pItem->data.userfreq,\n                                          pItem->data.maxfreq,\n                                          pItem->data.origfreq,\n                                          pgdata->static_data.chewing_lifetime - pItem->data.recentTime);\n        pItem->data.recentTime = pgdata->static_data.chewing_lifetime;\n        LogUserPhrase(pgdata, phoneSeq, wordSeq, pItem->data.origfreq, pItem->data.maxfreq, pItem->data.userfreq,\n                      pItem->data.recentTime);\n        HashModify(pgdata, pItem);\n        return USER_UPDATE_MODIFY;\n    }\n}",
        "begin_line": 128,
        "end_line": 172,
        "is_bug": false
    },
    {
        "name": "userphrase-hash.UserUpdatePhraseEnd#174",
        "src_path": "src/userphrase-hash.c",
        "class_name": "userphrase-hash",
        "signature": "userphrase-hash.UserUpdatePhraseEnd(ChewingData *pgdata)",
        "snippet": "void UserUpdatePhraseEnd(ChewingData *pgdata)\n{\n    /* compatibile with sqlite userphrase */\n}",
        "begin_line": 174,
        "end_line": 177,
        "is_bug": false
    },
    {
        "name": "userphrase-hash.UserRemovePhrase#179",
        "src_path": "src/userphrase-hash.c",
        "class_name": "userphrase-hash",
        "signature": "userphrase-hash.UserRemovePhrase(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[])",
        "snippet": "int UserRemovePhrase(ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[])\n{\n    HASH_ITEM **prev = NULL;\n    HASH_ITEM *item = NULL;\n\n    assert(pgdata);\n    assert(phoneSeq);\n    assert(wordSeq);\n\n    prev = HashFindHead(pgdata, phoneSeq);\n    item = *prev;\n\n    while (item) {\n        if (strcmp(item->data.wordSeq, wordSeq) == 0) {\n            /* Remove this phrase by removing */\n            item->data.phoneSeq[0] = 0;\n            HashModify(pgdata, item);\n\n            *prev = item->next;\n            item->next = NULL;\n            FreeHashItem(item);\n\n            return 1;\n        }\n        prev = &item->next;\n        item = item->next;\n    }\n\n    return 0;\n}",
        "begin_line": 179,
        "end_line": 208,
        "is_bug": false
    },
    {
        "name": "userphrase-hash.UserGetPhraseFirst#210",
        "src_path": "src/userphrase-hash.c",
        "class_name": "userphrase-hash",
        "signature": "userphrase-hash.UserGetPhraseFirst(ChewingData *pgdata, const uint16_t phoneSeq[])",
        "snippet": "UserPhraseData *UserGetPhraseFirst(ChewingData *pgdata, const uint16_t phoneSeq[])\n{\n    pgdata->prev_userphrase = HashFindPhonePhrase(pgdata, phoneSeq, NULL);\n    if (!pgdata->prev_userphrase)\n        return NULL;\n    return &(pgdata->prev_userphrase->data);\n}",
        "begin_line": 210,
        "end_line": 216,
        "is_bug": false
    },
    {
        "name": "userphrase-hash.UserGetPhraseNext#218",
        "src_path": "src/userphrase-hash.c",
        "class_name": "userphrase-hash",
        "signature": "userphrase-hash.UserGetPhraseNext(ChewingData *pgdata, const uint16_t phoneSeq[])",
        "snippet": "UserPhraseData *UserGetPhraseNext(ChewingData *pgdata, const uint16_t phoneSeq[])\n{\n    pgdata->prev_userphrase = HashFindPhonePhrase(pgdata, phoneSeq, pgdata->prev_userphrase);\n    if (!pgdata->prev_userphrase)\n        return NULL;\n    return &(pgdata->prev_userphrase->data);\n}",
        "begin_line": 218,
        "end_line": 224,
        "is_bug": false
    },
    {
        "name": "userphrase-hash.UserGetPhraseEnd#226",
        "src_path": "src/userphrase-hash.c",
        "class_name": "userphrase-hash",
        "signature": "userphrase-hash.UserGetPhraseEnd(ChewingData *pgdata, const uint16_t phoneSeq[])",
        "snippet": "void UserGetPhraseEnd(ChewingData *pgdata, const uint16_t phoneSeq[])\n{\n    /* FIXME: Remove this */\n}",
        "begin_line": 226,
        "end_line": 229,
        "is_bug": false
    },
    {
        "name": "userphrase-hash.IncreaseLifeTime#231",
        "src_path": "src/userphrase-hash.c",
        "class_name": "userphrase-hash",
        "signature": "userphrase-hash.IncreaseLifeTime(ChewingData *pgdata)",
        "snippet": "void IncreaseLifeTime(ChewingData *pgdata)\n{\n    assert(pgdata);\n\n    ++pgdata->static_data.chewing_lifetime;\n}",
        "begin_line": 231,
        "end_line": 236,
        "is_bug": false
    },
    {
        "name": "pinyin.TerminatePinyin#23",
        "src_path": "src/pinyin.c",
        "class_name": "pinyin",
        "signature": "pinyin.TerminatePinyin(ChewingData *pgdata)",
        "snippet": "void TerminatePinyin(ChewingData *pgdata)\n{\n    free(pgdata->static_data.hanyuInitialsMap);\n    free(pgdata->static_data.hanyuFinalsMap);\n}",
        "begin_line": 23,
        "end_line": 27,
        "is_bug": false
    },
    {
        "name": "pinyin.InitPinyin#29",
        "src_path": "src/pinyin.c",
        "class_name": "pinyin",
        "signature": "pinyin.InitPinyin(ChewingData *pgdata, const char *prefix)",
        "snippet": "int InitPinyin(ChewingData *pgdata, const char *prefix)\n{\n    char filename[PATH_MAX];\n    int i;\n    FILE *fd;\n    int ret;\n\n    sprintf(filename, \"%s\" PLAT_SEPARATOR \"%s\", prefix, PINYIN_TAB_NAME);\n\n    fd = fopen(filename, \"r\");\n\n    if (!fd)\n        return 0;\n\n    ret = fscanf(fd, \"%d\", &pgdata->static_data.HANYU_INITIALS);\n    if (ret != 1) {\n        goto fail;\n    }\n    ++pgdata->static_data.HANYU_INITIALS;\n    pgdata->static_data.hanyuInitialsMap = ALC(keymap, pgdata->static_data.HANYU_INITIALS);\n    for (i = 0; i < pgdata->static_data.HANYU_INITIALS - 1; i++) {\n        ret = fscanf(fd, \"%s %s\",\n                     pgdata->static_data.hanyuInitialsMap[i].pinyin, pgdata->static_data.hanyuInitialsMap[i].bopomofo);\n        if (ret != 2) {\n            goto fail;\n        }\n    }\n\n    ret = fscanf(fd, \"%d\", &pgdata->static_data.HANYU_FINALS);\n    if (ret != 1) {\n        goto fail;\n    }\n    ++pgdata->static_data.HANYU_FINALS;\n    pgdata->static_data.hanyuFinalsMap = ALC(keymap, pgdata->static_data.HANYU_FINALS);\n    for (i = 0; i < pgdata->static_data.HANYU_FINALS - 1; i++) {\n        ret = fscanf(fd, \"%s %s\",\n                     pgdata->static_data.hanyuFinalsMap[i].pinyin, pgdata->static_data.hanyuFinalsMap[i].bopomofo);\n        if (ret != 2) {\n            goto fail;\n        }\n    }\n\n    fclose(fd);\n    return 1;\n\nfail:\n    fclose(fd);\n    return 0;\n}",
        "begin_line": 29,
        "end_line": 77,
        "is_bug": false
    },
    {
        "name": "pinyin.PinyinToBopomofo#87",
        "src_path": "src/pinyin.c",
        "class_name": "pinyin",
        "signature": "pinyin.PinyinToBopomofo(ChewingData *pgdata, const char *pinyinKeySeq, char *bopomofoKeySeq, char *bopomofoKeySeqAlt)",
        "snippet": "int PinyinToBopomofo(ChewingData *pgdata, const char *pinyinKeySeq, char *bopomofoKeySeq, char *bopomofoKeySeqAlt)\n{\n    const char *p, *cursor = NULL;\n    const char *initial = 0;\n    const char *final = 0;\n    const char *seq = 0;\n    int i;\n\n    /* special cases for WG */\n    if (!strcmp(pinyinKeySeq, \"tzu\")) {\n        seq = \"y yj\";           /* \u3117|\u3117\u3128 */\n    } else if (!strcmp(pinyinKeySeq, \"ssu\") || !strcmp(pinyinKeySeq, \"szu\")) {\n        seq = \"n n\";            /* \u3119|\u3119\u3128 */\n    }\n\n    /* common multiple mapping */\n    if (!strcmp(pinyinKeySeq, \"e\")) {\n        seq = \"k ,\";            /* \u311c|\u311d */\n    } else if (!strcmp(pinyinKeySeq, \"ch\")) {\n        seq = \"t f\";            /* \u3114|\u3111 */\n    } else if (!strcmp(pinyinKeySeq, \"sh\")) {\n        seq = \"g v\";            /* \u3115|\u3112 */\n    } else if (!strcmp(pinyinKeySeq, \"c\")) {\n        seq = \"h f\";            /* \u3118|\u3111 */\n    } else if (!strcmp(pinyinKeySeq, \"s\")) {\n        seq = \"n v\";            /* \u3119|\u3112 */\n    } else if (!strcmp(pinyinKeySeq, \"nu\")) {\n        seq = \"sj sm\";          /* \u310b\u3128|\u310b\u3129 */\n    } else if (!strcmp(pinyinKeySeq, \"lu\")) {\n        seq = \"xj xm\";          /* \u310c\u3128|\u310c\u3129 */\n    } else if (!strcmp(pinyinKeySeq, \"luan\")) {\n        seq = \"xj0 xm0\";        /* \u310c\u3128\u3122|\u310c\u3129\u3122 */\n    } else if (!strcmp(pinyinKeySeq, \"niu\")) {\n        seq = \"su. sm\";         /* \u310b\u3127\u3121|\u310b\u3129 */\n    } else if (!strcmp(pinyinKeySeq, \"liu\")) {\n        seq = \"xu. xm\";         /* \u310c\u3127\u3121|\u310c\u3129 */\n    } else if (!strcmp(pinyinKeySeq, \"jiu\")) {\n        seq = \"ru. rm\";         /* \u3110\u3127\u3121|\u3110\u3129 */\n    } else if (!strcmp(pinyinKeySeq, \"chiu\")) {\n        seq = \"fu. fm\";         /* \u3111\u3127\u3121|\u3111\u3129 */\n    } else if (!strcmp(pinyinKeySeq, \"shiu\")) {\n        seq = \"vu. vm\";         /* \u3112\u3127\u3121|\u3112\u3129 */\n    } else if (!strcmp(pinyinKeySeq, \"ju\")) {\n        seq = \"rm 5j\";          /* \u3110\u3129|\u3113\u3128 */\n    } else if (!strcmp(pinyinKeySeq, \"juan\")) {\n        seq = \"rm0 5j0\";        /* \u3110\u3129\u3122|\u3113\u3128\u3122 */\n    }\n\n    /* multiple mapping for each kbtype */\n    switch (pgdata->bopomofoData.kbtype) {\n    case KB_HANYU_PINYIN:\n        if (!strcmp(pinyinKeySeq, \"chi\")) {\n            seq = \"t fu\";       /* \u3114|\u3111\u3127 */\n        } else if (!strcmp(pinyinKeySeq, \"shi\")) {\n            seq = \"g vu\";       /* \u3115|\u3112\u3127 */\n        } else if (!strcmp(pinyinKeySeq, \"ci\")) {\n            seq = \"h fu\";       /* \u3118|\u3111\u3127 */\n        } else if (!strcmp(pinyinKeySeq, \"si\")) {\n            seq = \"n vu\";       /* \u3119|\u3112\u3127 */\n        }\n        break;\n    case KB_THL_PINYIN:\n        if (!strcmp(pinyinKeySeq, \"chi\")) {\n            seq = \"fu t\";       /* \u3111\u3127|\u3114 */\n        } else if (!strcmp(pinyinKeySeq, \"shi\")) {\n            seq = \"vu g\";       /* \u3112\u3127|\u3115 */\n        } else if (!strcmp(pinyinKeySeq, \"ci\")) {\n            seq = \"fu h\";       /* \u3111\u3127|\u3118 */\n        } else if (!strcmp(pinyinKeySeq, \"si\")) {\n            seq = \"vu n\";       /* \u3112\u3127|\u3119 */\n        }\n        break;\n    case KB_MPS2_PINYIN:\n        if (!strcmp(pinyinKeySeq, \"chi\")) {\n            seq = \"fu t\";       /* \u3111\u3127|\u3114 */\n        } else if (!strcmp(pinyinKeySeq, \"shi\")) {\n            seq = \"vu g\";       /* \u3112\u3127|\u3115 */\n        } else if (!strcmp(pinyinKeySeq, \"ci\")) {\n            seq = \"fu h\";       /* \u3111\u3127|\u3118 */\n        } else if (!strcmp(pinyinKeySeq, \"si\")) {\n            seq = \"vu n\";       /* \u3112\u3127|\u3119 */\n        } else if (!strcmp(pinyinKeySeq, \"niu\")) {\n            seq = \"sm su.\";     /* \u310b\u3129|\u310b\u3127\u3121 */\n        } else if (!strcmp(pinyinKeySeq, \"liu\")) {\n            seq = \"xm xu.\";     /* \u310c\u3129|\u310c\u3127\u3121 */\n        } else if (!strcmp(pinyinKeySeq, \"jiu\")) {\n            seq = \"rm ru.\";     /* \u3110\u3129|\u3110\u3127\u3121 */\n        } else if (!strcmp(pinyinKeySeq, \"chiu\")) {\n            seq = \"fm fu.\";     /* \u3111\u3129|\u3111\u3127\u3121 */\n        } else if (!strcmp(pinyinKeySeq, \"shiu\")) {\n            seq = \"vm vu.\";     /* \u3112\u3129|\u3112\u3127\u3121 */\n        } else if (!strcmp(pinyinKeySeq, \"ju\")) {\n            seq = \"5j rm\";      /* \u3113\u3128|\u3110\u3129 */\n        } else if (!strcmp(pinyinKeySeq, \"juan\")) {\n            seq = \"5j0 rm0\";    /* \u3113\u3128\u3122|\u3110\u3129\u3122 */\n        } else if (!strcmp(pinyinKeySeq, \"juen\")) {\n            seq = \"5jp 5jp\";    /* \u3113\u3128\u3123|\u3113\u3128\u3123 */\n        } else if (!strcmp(pinyinKeySeq, \"tzu\")) {\n            seq = \"yj y\";       /* \u3117\u3128|\u3117 */\n        }\n        break;\n    }\n    if (seq != NULL) {\n        char s[BOPOMOFO_SIZE * 2 + 1];\n\n        strcpy(s, seq);\n        initial = strtok(s, \" \");\n        strcpy(bopomofoKeySeq, initial);\n        initial = strtok(NULL, \" \");\n        strcpy(bopomofoKeySeqAlt, initial);\n        return 0;\n    }\n\n\n    for (i = 0; i < pgdata->static_data.HANYU_INITIALS; i++) {\n        p = strstr(pinyinKeySeq, pgdata->static_data.hanyuInitialsMap[i].pinyin);\n        if (p == pinyinKeySeq) {\n            initial = pgdata->static_data.hanyuInitialsMap[i].bopomofo;\n            cursor = pinyinKeySeq + strlen(pgdata->static_data.hanyuInitialsMap[i].pinyin);\n            break;\n        }\n    }\n    if (i == pgdata->static_data.HANYU_INITIALS) {\n        /* No initials. might be \u3127\u3128\u3129 */\n        /* XXX: I NEED Implementation\n           if(finalsKeySeq[0] != ) {\n           }\n         */\n        return 1;\n    }\n\n    if (cursor) {\n        for (i = 0; i < pgdata->static_data.HANYU_FINALS; i++) {\n            if (strcmp(cursor, pgdata->static_data.hanyuFinalsMap[i].pinyin) == 0) {\n                final = pgdata->static_data.hanyuFinalsMap[i].bopomofo;\n                break;\n            }\n        }\n        if (i == pgdata->static_data.HANYU_FINALS) {\n            return 2;\n        }\n    }\n\n    /* catch the above exceptions */\n    if (!final) final = \"\";\n    if (!initial) initial = \"\";\n\n    /* THL empty rime\n     * we use '=' in pinyin.tab as empty rime, restore it to ''\n     */\n    if (!strcmp(final, \"=\")) {\n        final = \"\";\n    }\n\n    /* Hanyu empty rime\n     * \u3113/\u3114/\u3115/\u3116/\u3117/\u3118/\u3119 + -i, -i is empty rime, not \u3127\n     * */\n    if (!strcmp(final, \"u\")) {\n        if (!strcmp(initial, \"5\") ||\n            !strcmp(initial, \"t\") ||\n            !strcmp(initial, \"g\") ||\n            !strcmp(initial, \"b\") || !strcmp(initial, \"y\") || !strcmp(initial, \"h\") || !strcmp(initial, \"n\")) {\n            final = \"\";\n        }\n    }\n\n    /* Hanyu uan/un/u :\n     * \u3110/\u3111/\u3112 + -uan, -uan is \u3129\u3122, not \u3128\u3122\n     * \u3110/\u3111/\u3112 + -un,  -un is \u3129\u3123, not \u3128\u3123\n     * \u3110/\u3111/\u3112 + -u,   -u is \u3127, not \u3128\n     */\n    if (!strcmp(initial, \"f\") || !strcmp(initial, \"r\") || !strcmp(initial, \"v\")) {\n        if (!strcmp(final, \"j0\")) {\n            final = \"m0\";\n        } else if (!strcmp(final, \"jp\")) {\n            final = \"mp\";\n        } else if (!strcmp(final, \"j\")) {\n            final = \"m\";\n        }\n\n    }\n\n    /* THL/MPS2 s/sh/c/ch/j :\n     * s-  + \u30fc/\u3129, s-  is \u3112, not \u3119 (THL/Tongyong)\n     * sh- + \u30fc/\u3129, sh- is \u3112, not \u3115 (MPS2)\n     * c-  + \u30fc/\u3129, c-  is \u3111, not \u3118 (Tongyong)\n     * ch- + \u3127/\u3129, ch- is \u3111, not \u3114 (THL)\n     * j-  + other than \u30fc/\u3129, j-  is \u3113, not \u3110 (MPS2)\n     */\n\n    if (final == strstr(final, \"u\") || final == strstr(final, \"m\")) {\n        if (!strcmp(initial, \"n\")) {\n            initial = \"v\";\n        } else if (!strcmp(initial, \"g\")) {\n            initial = \"v\";\n        } else if (!strcmp(initial, \"h\")) {\n            initial = \"f\";\n        } else if (!strcmp(initial, \"t\")) {\n            initial = \"f\";\n        }\n    } else {\n        if (!strcmp(initial, \"r\")) {\n            initial = \"5\";\n        }\n    }\n\n    /* THL supplemental set\n     * \u3105/\u3106/\u3107/\u3108 + -\u3128\u3125, -\u3128\u3125 is another reading of -\u3125\n     * \u3105/\u3106/\u3107/\u3108 + -\u3128\u311b, -\u3128\u311b is another reading of -\u311b\n     */\n    if (!strcmp(initial, \"1\") || !strcmp(initial, \"q\") || !strcmp(initial, \"a\") || !strcmp(initial, \"z\")) {\n\n        if (!strcmp(final, \"ji\")) {\n            final = \"i\";\n        } else if (!strcmp(final, \"j/\")) {\n            final = \"/\";\n        }\n\n    }\n\n    sprintf(bopomofoKeySeq, \"%s%s\", initial, final);\n    strcpy(bopomofoKeySeqAlt, bopomofoKeySeq);\n    return 0;\n}\n",
        "begin_line": 87,
        "end_line": 310,
        "is_bug": false
    },
    {
        "name": "choice.ChangeSelectIntervalAndBreakpoint#33",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChangeSelectIntervalAndBreakpoint(ChewingData *pgdata, int from, int to, const char *str)",
        "snippet": "static void ChangeSelectIntervalAndBreakpoint(ChewingData *pgdata, int from, int to, const char *str)\n{\n    int i;\n    int user_alloc;\n\n    IntervalType inte;\n\n    inte.from = from;\n    inte.to = to;\n    for (i = 0; i < pgdata->nSelect; i++) {\n        if (IsIntersect(inte, pgdata->selectInterval[i])) {\n            RemoveSelectElement(i, pgdata);\n            i--;\n        }\n    }\n\n    pgdata->selectInterval[pgdata->nSelect].from = from;\n    pgdata->selectInterval[pgdata->nSelect].to = to;\n\n    /* No available selection */\n    if ((user_alloc = (to - from)) == 0)\n        return;\n\n    ueStrNCpy(pgdata->selectStr[pgdata->nSelect], str, user_alloc, 1);\n    pgdata->nSelect++;\n\n    if (user_alloc > 1) {\n        memset(&pgdata->bUserArrBrkpt[from + 1], 0, sizeof(int) * (user_alloc - 1));\n        memset(&pgdata->bUserArrCnnct[from + 1], 0, sizeof(int) * (user_alloc - 1));\n    }\n}",
        "begin_line": 33,
        "end_line": 63,
        "is_bug": false
    },
    {
        "name": "choice.SetAvailInfo#66",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.SetAvailInfo(ChewingData *pgdata, int begin, int end)",
        "snippet": "static void SetAvailInfo(ChewingData *pgdata, int begin, int end)\n{\n    AvailInfo *pai = &(pgdata->availInfo);\n    const uint16_t *phoneSeq = pgdata->phoneSeq;\n    int nPhoneSeq = pgdata->nPhoneSeq;\n    const int *bSymbolArrBrkpt = pgdata->bSymbolArrBrkpt;\n    int symbolArrBrkpt[ARRAY_SIZE(pgdata->bSymbolArrBrkpt)] = { 0 };\n\n    const TreeType *tree_pos;\n    int diff;\n    uint16_t userPhoneSeq[MAX_PHONE_SEQ_LEN];\n\n    int i, head, head_tmp;\n    int tail, tail_tmp;\n    int pos;\n\n    head = tail = 0;\n\n    pai->nAvail = 0;\n\n    /*\n     * XXX: The phoneSeq, nPhoneSeq skip any symbol in preedit buffer,\n     * while bSymbolArrBrkpt, does not skip any symbol in preedit\n     * buffer. So we need to do some translate here.\n     */\n    for (i = 0; i < pgdata->chiSymbolBufLen; ++i) {\n        if (bSymbolArrBrkpt[i]) {\n            /*\n             * XXX: If preedit buffer starts with symbol, the pos\n             * will become negative. In this case, we just ignore\n             * this symbol because it does not create any break\n             * point.\n             */\n            pos = i - CountSymbols(pgdata, i + 1);\n            if (pos >= 0)\n                symbolArrBrkpt[pos] = 1;\n        }\n    }\n\n    if (pgdata->config.bPhraseChoiceRearward) {\n        for (i = end; i >= begin; i--) {\n            if (symbolArrBrkpt[i])\n                break;\n            head = i;\n        }\n        head_tmp = end;\n    } else {\n        head_tmp = head = begin;\n    }\n\n    if (pgdata->config.bPhraseChoiceRearward) {\n        tail_tmp = tail = end;\n    } else {\n        for (i = begin; i < nPhoneSeq; i++) {\n            tail = i;\n            if (symbolArrBrkpt[i])\n                break;\n        }\n        tail_tmp = begin;\n    }\n\n    while (head <= head_tmp && tail_tmp <= tail) {\n        diff = tail_tmp - head_tmp;\n        tree_pos = TreeFindPhrase(pgdata, head_tmp, tail_tmp, phoneSeq);\n\n        if (tree_pos) {\n            /* save it! */\n            pai->avail[pai->nAvail].len = diff + 1;\n            pai->avail[pai->nAvail].id = tree_pos;\n            pai->nAvail++;\n        } else {\n            memcpy(userPhoneSeq, &phoneSeq[head_tmp], sizeof(uint16_t) * (diff + 1));\n            userPhoneSeq[diff + 1] = 0;\n            if (UserGetPhraseFirst(pgdata, userPhoneSeq)) {\n                /* save it! */\n                pai->avail[pai->nAvail].len = diff + 1;\n                pai->avail[pai->nAvail].id = NULL;\n                pai->nAvail++;\n            } else {\n                pai->avail[pai->nAvail].len = 0;\n                pai->avail[pai->nAvail].id = NULL;\n            }\n            UserGetPhraseEnd(pgdata, userPhoneSeq);\n        }\n\n        if (pgdata->config.bPhraseChoiceRearward) {\n            head_tmp--;\n        } else {\n            tail_tmp++;\n        }\n    }\n}",
        "begin_line": 66,
        "end_line": 157,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceTheSame#160",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceTheSame(ChoiceInfo *pci, const char *str, int len)",
        "snippet": "static int ChoiceTheSame(ChoiceInfo *pci, const char *str, int len)\n{\n    int i;\n\n    for (i = 0; i < pci->nTotalChoice; i++)\n        if (!strncmp(pci->totalChoiceStr[i], str, len))\n            return 1;\n    return 0;\n}",
        "begin_line": 160,
        "end_line": 168,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceInfoAppendChi#170",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceInfoAppendChi(ChewingData *pgdata, ChoiceInfo *pci, uint16_t phone)",
        "snippet": "static void ChoiceInfoAppendChi(ChewingData *pgdata, ChoiceInfo *pci, uint16_t phone)\n{\n    Phrase tempWord;\n    int len;\n\n    if (GetCharFirst(pgdata, &tempWord, phone)) {\n        do {\n            len = ueBytesFromChar(tempWord.phrase[0]);\n            if (ChoiceTheSame(pci, tempWord.phrase, len))\n                continue;\n            assert(pci->nTotalChoice < MAX_CHOICE);\n            memcpy(pci->totalChoiceStr[pci->nTotalChoice], tempWord.phrase, len);\n            pci->totalChoiceStr[pci->nTotalChoice]\n                [len] = '\\0';\n            pci->nTotalChoice++;\n        } while (GetVocabNext(pgdata, &tempWord));\n    }\n}",
        "begin_line": 170,
        "end_line": 187,
        "is_bug": false
    },
    {
        "name": "choice.SetChoiceInfo#195",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.SetChoiceInfo(ChewingData *pgdata)",
        "snippet": "static void SetChoiceInfo(ChewingData *pgdata)\n{\n    Phrase tempPhrase;\n    int len;\n    UserPhraseData *pUserPhraseData;\n    uint16_t userPhoneSeq[MAX_PHONE_SEQ_LEN];\n\n    ChoiceInfo *pci = &(pgdata->choiceInfo);\n    AvailInfo *pai = &(pgdata->availInfo);\n    uint16_t *phoneSeq = pgdata->phoneSeq;\n    uint16_t *phoneSeqAlt = pgdata->phoneSeqAlt;\n    int cursor = PhoneSeqCursor(pgdata);\n    int candPerPage = pgdata->config.candPerPage;\n\n    /* Clears previous candidates. */\n    memset(pci->totalChoiceStr, '\\0', MAX_CHOICE * MAX_PHRASE_LEN * MAX_UTF8_SIZE + 1);\n\n    pci->nTotalChoice = 0;\n    len = pai->avail[pai->currentAvail].len;\n    assert(len);\n\n    /* secondly, read tree phrase */\n    if (len == 1) {             /* single character */\n        ChoiceInfoAppendChi(pgdata, pci, phoneSeq[cursor]);\n\n        if (phoneSeq[cursor] != phoneSeqAlt[cursor]) {\n            ChoiceInfoAppendChi(pgdata, pci, phoneSeqAlt[cursor]);\n        }\n\n        if (pgdata->bopomofoData.kbtype == KB_HSU || pgdata->bopomofoData.kbtype == KB_DVORAK_HSU) {\n            switch (phoneSeq[cursor]) {\n            case 0x2800:       /* '\u3118' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x30);     /* '\u311f' */\n                break;\n            case 0x80:         /* '\u3127' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x20);     /* '\u311d' */\n                break;\n            case 0x2A00:       /* '\u3119' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1);      /* '\u02d9' */\n                break;\n            case 0xA00:        /* '\u3109' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x2);      /* '\u02ca' */\n                break;\n            case 0x800:        /* '\u3108' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x3);      /* '\u02c7' */\n                break;\n            case 0x18:         /* '\u311c' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1200);   /* '\u310d' */\n                break;\n            case 0x10:         /* '\u311b' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1600);   /* '\u310f' */\n                break;\n            case 0x1E00:       /* '\u3113' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1800);   /* '\u3110' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x4);      /* '\u02cb' */\n                break;\n            case 0x58:         /* '\u3124' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1400);   /* '\u310e' */\n                break;\n            case 0x68:         /* '\u3126' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1000);   /* '\u310c' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x60);     /* '\u3125' */\n                break;\n            case 0x2200:       /* '\u3115' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1C00);   /* '\u3112' */\n                break;\n            case 0x2000:       /* '\u3114' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1A00);   /* '\u3111' */\n                break;\n            case 0x50:         /* '\u3123' */\n                ChoiceInfoAppendChi(pgdata, pci, 0xE00);    /* '\u310b' */\n                break;\n            case 0x48:         /* '\u3122' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x600);    /* '\u3107' */\n                break;\n            default:\n                break;\n            }\n        }\n\n        if (pgdata->bopomofoData.kbtype == KB_ET26) {\n            switch (phoneSeq[cursor]) {\n            case 0x40:      /* '\u3121' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x400);    /* '\u3106' */\n                break;\n            case 0x58:      /* '\u3124' */\n                ChoiceInfoAppendChi(pgdata, pci, 0xC00);    /* '\u310a' */\n                break;\n            case 0x2800:    /* '\u3118' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x20);     /* '\u311d' */\n                break;\n            case 0x2600:    /* '\u3117' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x30);     /* '\u311f' */\n                break;\n            case 0x1E00:    /* '\u3113' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1800);   /* '\u3110' */\n                break;\n            case 0x68:      /* '\u3126' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1600);   /* '\u310f' */\n                break;\n            case 0x60:      /* '\u3125' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1000);   /* '\u310c' */\n                break;\n            case 0x2200:    /* '\u3115' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1C00);   /* '\u3112' */\n                break;\n            case 0x1200:    /* '\u310d' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1A00);   /* '\u3111' */\n                break;\n            case 0x50:      /* '\u3123' */\n                ChoiceInfoAppendChi(pgdata, pci, 0xE00);    /* '\u310b' */\n                break;\n            case 0x48:      /* '\u3122' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x600);    /* '\u3107' */\n                break;\n            case 0xA00:     /* '\u3109' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x1);      /* '\u02d9' */\n                break;\n            case 0x800:     /* '\u3108' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x2);      /* '\u02ca' */\n                break;\n            case 0x2400:    /* '\u3116' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x3);      /* '\u02c7' */\n                break;\n            case 0x1400:    /* '\u310e' */\n                ChoiceInfoAppendChi(pgdata, pci, 0x4);      /* '\u02cb' */\n                break;\n            default:\n                break;\n            }\n        }\n    }\n    /* phrase */\n    else {\n        if (pai->avail[pai->currentAvail].id) {\n            GetPhraseFirst(pgdata, &tempPhrase, pai->avail[pai->currentAvail].id);\n            do {\n                if (ChoiceTheSame(pci, tempPhrase.phrase, len * ueBytesFromChar(tempPhrase.phrase[0]))) {\n                    continue;\n                }\n                ueStrNCpy(pci->totalChoiceStr[pci->nTotalChoice], tempPhrase.phrase, len, 1);\n                pci->nTotalChoice++;\n            } while (GetVocabNext(pgdata, &tempPhrase));\n        }\n\n        memcpy(userPhoneSeq, &phoneSeq[cursor], sizeof(uint16_t) * len);\n        userPhoneSeq[len] = 0;\n        pUserPhraseData = UserGetPhraseFirst(pgdata, userPhoneSeq);\n        if (pUserPhraseData) {\n            do {\n                /* check if the phrase is already in the choice list */\n                if (ChoiceTheSame(pci, pUserPhraseData->wordSeq, len * ueBytesFromChar(pUserPhraseData->wordSeq[0])))\n                    continue;\n                /* otherwise store it */\n                ueStrNCpy(pci->totalChoiceStr[pci->nTotalChoice], pUserPhraseData->wordSeq, len, 1);\n                pci->nTotalChoice++;\n            } while ((pUserPhraseData = UserGetPhraseNext(pgdata, userPhoneSeq)) != NULL);\n        }\n        UserGetPhraseEnd(pgdata, userPhoneSeq);\n\n    }\n\n    /* magic number */\n    pci->nChoicePerPage = candPerPage;\n    assert(pci->nTotalChoice > 0);\n    pci->nPage = CEIL_DIV(pci->nTotalChoice, pci->nChoicePerPage);\n    pci->pageNo = 0;\n    pci->isSymbol = WORD_CHOICE;\n}\n\n/*\n * Seek the start of the phrase (English characters are skipped.)\n */\nstatic int SeekPhraseHead(ChewingData",
        "begin_line": 195,
        "end_line": 363,
        "is_bug": false
    },
    {
        "name": "choice.SeekPhraseHead#368",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.SeekPhraseHead(ChewingData *pgdata)",
        "snippet": "static int SeekPhraseHead(ChewingData *pgdata)\n{\n    int i;\n    int phoneSeq = PhoneSeqCursor(pgdata);\n\n    for (i = pgdata->nPrefer - 1; i >= 0; i--) {\n        if (pgdata->preferInterval[i].from > phoneSeq || pgdata->preferInterval[i].to < phoneSeq)\n            continue;\n        return pgdata->preferInterval[i].from;\n    }\n    return 0;\n}",
        "begin_line": 368,
        "end_line": 379,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceInitAvail#382",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceInitAvail(ChewingData *pgdata)",
        "snippet": "int ChoiceInitAvail(ChewingData *pgdata)\n{\n    int end, begin;\n\n    /* save old cursor position */\n    pgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;\n\n    /* see if there is some word in the cursor position */\n    if (pgdata->chiSymbolBufLen == pgdata->chiSymbolCursor) {\n        pgdata->chiSymbolCursor--;\n    }\n\n    end = PhoneSeqCursor(pgdata);\n\n    if (pgdata->config.bPhraseChoiceRearward) {\n        pgdata->chiSymbolCursor = SeekPhraseHead(pgdata) + CountSymbols(pgdata, pgdata->chiSymbolCursor);\n    }\n    begin = PhoneSeqCursor(pgdata);\n\n    pgdata->bSelect = 1;\n\n    SetAvailInfo(pgdata, begin, end);\n\n    if (!pgdata->availInfo.nAvail)\n        return ChoiceEndChoice(pgdata);\n\n    pgdata->availInfo.currentAvail = pgdata->availInfo.nAvail - 1;\n    SetChoiceInfo(pgdata);\n    return 0;\n}",
        "begin_line": 382,
        "end_line": 411,
        "is_bug": false
    },
    {
        "name": "choice.ChangeCurrentAvailInfo#413",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChangeCurrentAvailInfo(ChewingData *pgdata, int current)",
        "snippet": "static void ChangeCurrentAvailInfo(ChewingData *pgdata, int current)\n{\n    assert(pgdata);\n\n    if (pgdata->config.bPhraseChoiceRearward) {\n        pgdata->chiSymbolCursor = pgdata->choiceInfo.oldChiSymbolCursor - pgdata->availInfo.avail[current].len + 1;\n\n        /*\n         * When oldChiSymbolCursor == chiSymbolBufLen, the old cursor is at the\n         * end of buffer. This mean the end of phrase is in (oldChiSymbolCursor\n         * - 1) instead of oldChiSymbolCursor. In this case, we need to adjust\n         * chiSymbolCursor.\n         */\n        assert(pgdata->choiceInfo.oldChiSymbolCursor <= pgdata->chiSymbolBufLen);\n        if (pgdata->choiceInfo.oldChiSymbolCursor == pgdata->chiSymbolBufLen) {\n            --pgdata->chiSymbolCursor;\n        }\n    }\n\n    pgdata->availInfo.currentAvail = current;\n}",
        "begin_line": 413,
        "end_line": 433,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceFirstAvail#435",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceFirstAvail(ChewingData *pgdata)",
        "snippet": "int ChoiceFirstAvail(ChewingData *pgdata)\n{\n    assert(pgdata);\n    assert(pgdata->bSelect);\n\n    if (pgdata->choiceInfo.isSymbol != WORD_CHOICE)\n        return 0;\n\n    ChangeCurrentAvailInfo(pgdata, pgdata->availInfo.nAvail - 1);\n\n    SetChoiceInfo(pgdata);\n\n    return 0;\n}",
        "begin_line": 435,
        "end_line": 448,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceLastAvail#450",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceLastAvail(ChewingData *pgdata)",
        "snippet": "int ChoiceLastAvail(ChewingData *pgdata)\n{\n    assert(pgdata);\n    assert(pgdata->bSelect);\n\n    if (pgdata->choiceInfo.isSymbol != WORD_CHOICE)\n        return 0;\n\n    ChangeCurrentAvailInfo(pgdata, 0);\n\n    SetChoiceInfo(pgdata);\n\n    return 0;\n}",
        "begin_line": 450,
        "end_line": 463,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceHasNextAvail#465",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceHasNextAvail(ChewingData *pgdata)",
        "snippet": "int ChoiceHasNextAvail(ChewingData *pgdata)\n{\n    assert(pgdata);\n    assert(pgdata->bSelect);\n\n    if (pgdata->choiceInfo.isSymbol != WORD_CHOICE)\n        return 0;\n\n    return pgdata->availInfo.currentAvail > 0;\n}",
        "begin_line": 465,
        "end_line": 474,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceHasPrevAvail#477",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceHasPrevAvail(ChewingData *pgdata)",
        "snippet": "int ChoiceHasPrevAvail(ChewingData *pgdata)\n{\n    assert(pgdata);\n    assert(pgdata->bSelect);\n\n    if (pgdata->choiceInfo.isSymbol != WORD_CHOICE)\n        return 0;\n\n    return pgdata->availInfo.currentAvail < pgdata->availInfo.nAvail - 1;\n}",
        "begin_line": 477,
        "end_line": 486,
        "is_bug": false
    },
    {
        "name": "choice.ChoicePrevAvail#488",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoicePrevAvail(ChewingData *pgdata)",
        "snippet": "int ChoicePrevAvail(ChewingData *pgdata)\n{\n    assert(pgdata);\n    assert(pgdata->bSelect);\n\n    if (!ChoiceHasPrevAvail(pgdata)) {\n        return -1;\n    }\n\n    ChangeCurrentAvailInfo(pgdata, pgdata->availInfo.currentAvail + 1);\n\n    SetChoiceInfo(pgdata);\n\n    return 0;\n}",
        "begin_line": 488,
        "end_line": 502,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceNextAvail#504",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceNextAvail(ChewingData *pgdata)",
        "snippet": "int ChoiceNextAvail(ChewingData *pgdata)\n{\n    assert(pgdata);\n    assert(pgdata->bSelect);\n\n    if (!ChoiceHasNextAvail(pgdata)) {\n        return -1;\n    }\n\n    ChangeCurrentAvailInfo(pgdata, pgdata->availInfo.currentAvail - 1);\n\n    SetChoiceInfo(pgdata);\n\n    return 0;\n}",
        "begin_line": 504,
        "end_line": 518,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceEndChoice#520",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceEndChoice(ChewingData *pgdata)",
        "snippet": "int ChoiceEndChoice(ChewingData *pgdata)\n{\n    pgdata->bSelect = 0;\n    pgdata->choiceInfo.nTotalChoice = 0;\n    pgdata->choiceInfo.nPage = 0;\n\n    pgdata->chiSymbolCursor = pgdata->choiceInfo.oldChiSymbolCursor;\n    assert(pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen);\n\n    pgdata->choiceInfo.isSymbol = WORD_CHOICE;\n    return 0;\n}",
        "begin_line": 520,
        "end_line": 531,
        "is_bug": false
    },
    {
        "name": "choice.ChoiceSelect#534",
        "src_path": "src/choice.c",
        "class_name": "choice",
        "signature": "choice.ChoiceSelect(ChewingData *pgdata, int selectNo)",
        "snippet": "int ChoiceSelect(ChewingData *pgdata, int selectNo)\n{\n    ChoiceInfo *pci = &(pgdata->choiceInfo);\n    AvailInfo *pai = &(pgdata->availInfo);\n\n    ChangeSelectIntervalAndBreakpoint(pgdata,\n                                      PhoneSeqCursor(pgdata),\n                                      PhoneSeqCursor(pgdata) + pai->avail[pai->currentAvail].len,\n                                      pci->totalChoiceStr[selectNo]);\n    ChoiceEndChoice(pgdata);\n    return 0;\n}",
        "begin_line": 534,
        "end_line": 545,
        "is_bug": false
    },
    {
        "name": "chewing-sql.GetSQLiteInstance#94",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.GetSQLiteInstance(ChewingData *pgdata, const char *path)",
        "snippet": "static sqlite3 *GetSQLiteInstance(ChewingData *pgdata, const char *path)\n{\n    int ret;\n    sqlite3 *db = NULL;\n\n    assert(pgdata);\n    assert(path);\n\n    ret = sqlite3_open(path, &db);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_open returns %d\", ret);\n        goto end;\n    }\n\n  end:\n    return db;\n}",
        "begin_line": 94,
        "end_line": 110,
        "is_bug": false
    },
    {
        "name": "chewing-sql.CreateTable#113",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.CreateTable(ChewingData *pgdata)",
        "snippet": "static int CreateTable(ChewingData *pgdata)\n{\n    int ret;\n\n    STATIC_ASSERT(MAX_PHRASE_LEN == 11);\n\n    ret = sqlite3_exec(pgdata->static_data.db,\n                       \"CREATE TABLE IF NOT EXISTS userphrase_v1 (\"\n                       \"time INTEGER,\"\n                       \"user_freq INTEGER,\"\n                       \"max_freq INTEGER,\"\n                       \"orig_freq INTEGER,\"\n                       \"length INTEGER,\"\n                       \"phone_0 INTEGER,\"\n                       \"phone_1 INTEGER,\"\n                       \"phone_2 INTEGER,\"\n                       \"phone_3 INTEGER,\"\n                       \"phone_4 INTEGER,\"\n                       \"phone_5 INTEGER,\"\n                       \"phone_6 INTEGER,\"\n                       \"phone_7 INTEGER,\"\n                       \"phone_8 INTEGER,\"\n                       \"phone_9 INTEGER,\"\n                       \"phone_10 INTEGER,\"\n                       \"phrase TEXT,\"\n                       \"PRIMARY KEY (\"\n                       \"phone_0,\"\n                       \"phone_1,\"\n                       \"phone_2,\"\n                       \"phone_3,\"\n                       \"phone_4,\"\n                       \"phone_5,\"\n                       \"phone_6,\"\n                       \"phone_7,\"\n                       \"phone_8,\"\n                       \"phone_9,\"\n                       \"phone_10,\"\n                       \"phrase)\" \")\", NULL, NULL, NULL);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot create table userphrase_v1, error = %d\", ret);\n        return -1;\n    }\n\n    ret = sqlite3_exec(pgdata->static_data.db,\n                       \"CREATE TABLE IF NOT EXISTS config_v1 (\"\n                       \"id INTEGER,\"\n                       \"value INTEGER,\"\n                       \"PRIMARY KEY (id)\" \")\", NULL, NULL, NULL);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot create table config_v1, error = %d\", ret);\n        return -1;\n    }\n\n    return 0;\n}",
        "begin_line": 113,
        "end_line": 167,
        "is_bug": false
    },
    {
        "name": "chewing-sql.SetupUserphraseLifeTime#169",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.SetupUserphraseLifeTime(ChewingData *pgdata)",
        "snippet": "static int SetupUserphraseLifeTime(ChewingData *pgdata)\n{\n    int ret;\n\n    assert(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT]);\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT], BIND_CONFIG_ID, CONFIG_ID_LIFETIME);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot bind ?%d to %d in stmt %s, error = %d\",\n                  BIND_CONFIG_ID, CONFIG_ID_LIFETIME, SQL_STMT_CONFIG[STMT_CONFIG_INSERT].stmt, ret);\n        return -1;\n    }\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT], BIND_CONFIG_VALUE, 0);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot bind ?%d to %d in stmt %s, error = %d\",\n                  BIND_CONFIG_VALUE, 0, SQL_STMT_CONFIG[STMT_CONFIG_INSERT].stmt, ret);\n        return -1;\n    }\n\n    ret = sqlite3_step(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT]);\n    if (ret != SQLITE_DONE) {\n        LOG_ERROR(\"sqlite3_step returns %d\", ret);\n        return -1;\n    }\n\n    ret = sqlite3_reset(pgdata->static_data.stmt_config[STMT_CONFIG_INSERT]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n        return -1;\n    }\n\n    assert(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT]);\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT], BIND_CONFIG_ID, CONFIG_ID_LIFETIME);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot bind ?%d to %d in stmt %s, error = %d\",\n                  BIND_CONFIG_ID, CONFIG_ID_LIFETIME, SQL_STMT_CONFIG[STMT_CONFIG_SELECT].stmt, ret);\n        return -1;\n    }\n\n    ret = sqlite3_step(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT]);\n    if (ret != SQLITE_ROW) {\n        LOG_ERROR(\"sqlite3_step returns %d\", ret);\n        return -1;\n    }\n\n    pgdata->static_data.original_lifetime = sqlite3_column_int(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT],\n                                                               SQL_STMT_CONFIG[STMT_CONFIG_SELECT].column\n                                                               [COLUMN_CONFIG_VALUE]);\n    pgdata->static_data.new_lifetime = pgdata->static_data.original_lifetime;\n\n    ret = sqlite3_reset(pgdata->static_data.stmt_config[STMT_CONFIG_SELECT]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n        return -1;\n    }\n\n    return 0;\n}",
        "begin_line": 169,
        "end_line": 228,
        "is_bug": false
    },
    {
        "name": "chewing-sql.UpdateLifeTime#230",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.UpdateLifeTime(ChewingData *pgdata)",
        "snippet": "static int UpdateLifeTime(ChewingData *pgdata)\n{\n    int ret;\n    int result = 0;\n\n    if (!pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE]) {\n        LOG_ERROR(\"pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE] is NULL\");\n        result = -1;\n        goto end;\n    }\n\n    ret = sqlite3_clear_bindings(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_clear_bindings returns %d\", ret);\n        result = -1;\n        goto end;\n    }\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE], BIND_CONFIG_ID, CONFIG_ID_LIFETIME);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot bind ?%d to %d in stmt %s, error = %d\",\n                  BIND_CONFIG_ID, CONFIG_ID_LIFETIME, SQL_STMT_CONFIG[STMT_CONFIG_INCREASE].stmt, ret);\n        result = -1;\n        goto end;\n    }\n\n    ret = sqlite3_bind_int(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE],\n                           BIND_CONFIG_VALUE, pgdata->static_data.new_lifetime - pgdata->static_data.original_lifetime);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot bind ?%d to %d in stmt %s, error = %d\",\n                  BIND_CONFIG_VALUE,\n                  pgdata->static_data.new_lifetime - pgdata->static_data.original_lifetime,\n                  SQL_STMT_CONFIG[STMT_CONFIG_INCREASE].stmt, ret);\n        result = -1;\n        goto end;\n    }\n\n    ret = sqlite3_step(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE]);\n    if (ret != SQLITE_DONE) {\n        LOG_ERROR(\"sqlite3_step returns %d\", ret);\n        result = -1;\n        goto end;\n    }\n\n  end:\n    ret = sqlite3_reset(pgdata->static_data.stmt_config[STMT_CONFIG_INCREASE]);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"sqlite3_reset returns %d\", ret);\n        result = -1;\n    }\n\n    return result;\n}",
        "begin_line": 230,
        "end_line": 282,
        "is_bug": false
    },
    {
        "name": "chewing-sql.ConfigDatabase#284",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.ConfigDatabase(ChewingData *pgdata)",
        "snippet": "static int ConfigDatabase(ChewingData *pgdata)\n{\n    int ret;\n\n    assert(pgdata);\n    assert(pgdata->static_data.db);\n\n    ret = sqlite3_exec(pgdata->static_data.db, \"PRAGMA synchronous=OFF\", NULL, NULL, NULL);\n    if (ret != SQLITE_OK) {\n        LOG_ERROR(\"Cannot set synchronous=OFF, error = %d\", ret);\n        return -1;\n    }\n\n    return 0;\n}",
        "begin_line": 284,
        "end_line": 298,
        "is_bug": false
    },
    {
        "name": "chewing-sql.CreateStmt#300",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.CreateStmt(ChewingData *pgdata)",
        "snippet": "static int CreateStmt(ChewingData *pgdata)\n{\n    size_t i;\n    int ret;\n\n    assert(pgdata);\n\n    STATIC_ASSERT(ARRAY_SIZE(SQL_STMT_CONFIG) == ARRAY_SIZE(pgdata->static_data.stmt_config));\n    STATIC_ASSERT(ARRAY_SIZE(SQL_STMT_USERPHRASE) == ARRAY_SIZE(pgdata->static_data.stmt_userphrase));\n\n    for (i = 0; i < ARRAY_SIZE(SQL_STMT_CONFIG); ++i) {\n        ret = sqlite3_prepare_v2(pgdata->static_data.db,\n                                 SQL_STMT_CONFIG[i].stmt, -1, &pgdata->static_data.stmt_config[i], NULL);\n        if (ret != SQLITE_OK) {\n            LOG_ERROR(\"Cannot create stmt %s\", SQL_STMT_CONFIG[i].stmt);\n            return -1;\n        }\n    }\n\n    for (i = 0; i < ARRAY_SIZE(SQL_STMT_USERPHRASE); ++i) {\n        ret = sqlite3_prepare_v2(pgdata->static_data.db,\n                                 SQL_STMT_USERPHRASE[i].stmt, -1, &pgdata->static_data.stmt_userphrase[i], NULL);\n        if (ret != SQLITE_OK) {\n            LOG_ERROR(\"Cannot create stmt %s\", SQL_STMT_USERPHRASE[i].stmt);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
        "begin_line": 300,
        "end_line": 329,
        "is_bug": false
    },
    {
        "name": "chewing-sql.MigrateOldFormat#331",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.MigrateOldFormat(ChewingData *pgdata, const char *path)",
        "snippet": "static void MigrateOldFormat(ChewingData *pgdata, const char *path)\n{\n    char *uhash;\n    char *old_uhash;\n    FILE *fd = NULL;\n    char buf[HASH_FIELD_SIZE];\n    uint16_t phoneSeq[MAX_PHRASE_LEN + 1];\n    char *pos;\n    int len;\n    int i;\n    int ret;\n\n    assert(pgdata);\n    assert(path);\n\n    len = strlen(path) + 1 + strlen(HASH_NAME) + 1;\n    uhash = calloc(sizeof(*uhash), len);\n    if (!uhash) {\n        LOG_ERROR(\"calloc returns %#p\", uhash);\n        exit(-1);\n    }\n    snprintf(uhash, len, \"%s\" PLAT_SEPARATOR \"%s\", path, HASH_NAME);\n\n    len = strlen(path) + 1 + strlen(HASH_OLD_NAME) + 1;\n    old_uhash = calloc(sizeof(*old_uhash), len);\n    if (!old_uhash) {\n        LOG_ERROR(\"calloc returns %#p\", old_uhash);\n        exit(-1);\n    }\n    snprintf(old_uhash, len, \"%s\" PLAT_SEPARATOR \"%s\", path, HASH_OLD_NAME);\n\n    /*\n     * The binary format is described as following:\n     *\n     * 0 ~ 3                signature (CBiH)\n     * 4 ~ 7                lifttime, platform endianness\n     * 8 ~ 8 + 125 * n      array of hash item, 125 bytes each\n     *\n     * 0 ~ 3                user frequency, platform endianness\n     * 4 ~ 7                recent time, platform endianness\n     * 8 ~ 11               max frequency, platform endianness\n     * 12 ~ 15              original frequency, platform endianness\n     * 16                   phone length\n     * 17 ~ 17 + 2 * n      phone sequence, uint16_t, platform endianness\n     * 17 + 2 * n + 1       phrase length in bytes\n     * 17 + 2 * n + 2 ~ y   phrase in UTF-8\n     *\n     */\n\n    fd = fopen(uhash, \"r\");\n    if (!fd)\n        goto end;\n\n    LOG_INFO(\"Migrate old format from %s\", uhash);\n    ret = fread(buf, 4, 1, fd);\n    if (ret != 1) {\n        LOG_WARN(\"fread returns %d\", ret);\n        goto end_remove_hash;\n    }\n\n    if (memcmp(buf, HASH_SIGS, 4) != 0) {\n        LOG_WARN(\"signature is not %d\", HASH_SIGS);\n        goto end_remove_hash;\n    }\n\n    ret = fseek(fd, 8, SEEK_SET);\n    if (ret) {\n        LOG_WARN(\"fseek returns %d\", ret);\n        goto end_remove_hash;\n    }\n\n    while (fread(buf, HASH_FIELD_SIZE, 1, fd) == 1) {\n        pos = &buf[HASH_LENGTH_OFFSET];\n        len = *pos;\n        ++pos;\n\n        if (len > MAX_PHRASE_LEN || len < 1) {\n            LOG_WARN(\"skip field due to len = %d\", len);\n            continue;\n        }\n\n        for (i = 0; i < len; ++i) {\n            phoneSeq[i] = GetUint16PreservedEndian(pos);\n            pos += 2;\n        }\n        phoneSeq[len] = 0;\n\n        ++pos;\n        UserUpdatePhrase(pgdata, phoneSeq, pos);\n    }\n\n  end_remove_hash:\n    if (fd)\n        fclose(fd);\n    PLAT_RENAME(uhash, old_uhash);\n  end:\n    free(old_uhash);\n    free(uhash);\n}",
        "begin_line": 331,
        "end_line": 429,
        "is_bug": false
    },
    {
        "name": "chewing-sql.InitUserphrase#431",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.InitUserphrase(ChewingData *pgdata, const char *path)",
        "snippet": "int InitUserphrase(ChewingData *pgdata, const char *path)\n{\n    int ret;\n\n    assert(!pgdata->static_data.db);\n    assert(path);\n\n    pgdata->static_data.db = GetSQLiteInstance(pgdata, path);\n    if (!pgdata->static_data.db) {\n        LOG_ERROR(\"GetSQLiteInstance fails\");\n        goto error;\n    }\n\n    ret = ConfigDatabase(pgdata);\n    if (ret) {\n        LOG_ERROR(\"ConfigDatabase returns %d\", ret);\n        goto error;\n    }\n\n    ret = CreateTable(pgdata);\n    if (ret) {\n        LOG_ERROR(\"CreateTable returns %d\", ret);\n        goto error;\n    }\n\n    ret = CreateStmt(pgdata);\n    if (ret) {\n        LOG_ERROR(\"CreateStmt returns %d\", ret);\n        goto error;\n    }\n\n    ret = SetupUserphraseLifeTime(pgdata);\n    if (ret) {\n        LOG_ERROR(\"SetupUserphraseLiftTime returns %d\", ret);\n        goto error;\n    }\n\n    /* FIXME: Normalize lifttime when necessary. */\n\n    MigrateOldFormat(pgdata, path);\n\n    return 0;\n\n  error:\n    TerminateUserphrase(pgdata);\n    return -1;\n}",
        "begin_line": 431,
        "end_line": 477,
        "is_bug": false
    },
    {
        "name": "chewing-sql.TerminateUserphrase#479",
        "src_path": "src/chewing-sql.c",
        "class_name": "chewing-sql",
        "signature": "chewing-sql.TerminateUserphrase(ChewingData *pgdata)",
        "snippet": "void TerminateUserphrase(ChewingData *pgdata)\n{\n    size_t i;\n    int ret;\n\n    UpdateLifeTime(pgdata);\n\n    for (i = 0; i < ARRAY_SIZE(pgdata->static_data.stmt_config); ++i) {\n        sqlite3_finalize(pgdata->static_data.stmt_config[i]);\n        pgdata->static_data.stmt_config[i] = NULL;\n    }\n\n    for (i = 0; i < ARRAY_SIZE(pgdata->static_data.stmt_userphrase); ++i) {\n        sqlite3_finalize(pgdata->static_data.stmt_userphrase[i]);\n        pgdata->static_data.stmt_userphrase[i] = NULL;\n    }\n\n    ret = sqlite3_close(pgdata->static_data.db);\n    assert(SQLITE_OK == ret);\n    pgdata->static_data.db = NULL;\n}",
        "begin_line": 479,
        "end_line": 499,
        "is_bug": false
    },
    {
        "name": "bopomofo.IsHsuPhoEndKey#40",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.IsHsuPhoEndKey(const int pho_inx[], int key)",
        "snippet": "static int IsHsuPhoEndKey(const int pho_inx[], int key)\n{\n    switch (key) {\n    case 's':\n    case 'd':\n    case 'f':\n    case 'j':\n    case ' ':\n        return (pho_inx[0] || pho_inx[1] || pho_inx[2]);\n    default:\n        return 0;\n    }\n}",
        "begin_line": 40,
        "end_line": 52,
        "is_bug": false
    },
    {
        "name": "bopomofo.IsET26PhoEndKey#55",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.IsET26PhoEndKey(const int pho_inx[], int key)",
        "snippet": "static int IsET26PhoEndKey(const int pho_inx[], int key)\n{\n    switch (key) {\n    case 'd':\n    case 'f':\n    case 'j':\n    case 'k':\n    case ' ':\n        return (pho_inx[0] || pho_inx[1] || pho_inx[2]);\n    default:\n        return 0;\n    }\n}",
        "begin_line": 55,
        "end_line": 67,
        "is_bug": false
    },
    {
        "name": "bopomofo.IsDACHENCP26PhoEndKey#70",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.IsDACHENCP26PhoEndKey(const int pho_inx[], int key)",
        "snippet": "static int IsDACHENCP26PhoEndKey(const int pho_inx[], int key)\n{\n    switch (key) {\n    case 'e':\n    case 'r':\n    case 'd':\n    case 'y':\n    case ' ':\n        return (pho_inx[0] || pho_inx[1] || pho_inx[2]);\n    default:\n        return 0;\n    }\n}",
        "begin_line": 70,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "bopomofo.IsDefPhoEndKey#84",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.IsDefPhoEndKey(int key, int kbtype)",
        "snippet": "static int IsDefPhoEndKey(int key, int kbtype)\n{\n    if (PhoneInxFromKey(key, 3, kbtype, 1))\n        return 1;\n\n    if (key == ' ')\n        return 1;\n    return 0;\n}",
        "begin_line": 84,
        "end_line": 92,
        "is_bug": false
    },
    {
        "name": "bopomofo.EndKeyProcess#94",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.EndKeyProcess(ChewingData *pgdata, int key, int searchTimes)",
        "snippet": "static int EndKeyProcess(ChewingData *pgdata, int key, int searchTimes)\n{\n    BopomofoData *pBopomofo = &(pgdata->bopomofoData);\n    uint16_t u16Pho, u16PhoAlt;\n    Phrase tempword;\n    int pho_inx;\n\n    if (pBopomofo->pho_inx[0] == 0 && pBopomofo->pho_inx[1] == 0 && pBopomofo->pho_inx[2] == 0 && pBopomofo->pho_inx[3] == 0) {\n        /*\n         * Special handle for space key (Indeed very special one).\n         * Un-break the situation that OnKeySpace() is not called,\n         * hence the Candidate window doesn't show up, because\n         * BOPOMOFO_NO_WORD is returned.\n         */\n        return (key == ' ') ? BOPOMOFO_KEY_ERROR : BOPOMOFO_NO_WORD;\n    }\n\n    pho_inx = PhoneInxFromKey(key, 3, pBopomofo->kbtype, searchTimes);\n    if (pBopomofo->pho_inx[3] == 0) {\n        pBopomofo->pho_inx[3] = pho_inx;\n        pBopomofo->pho_inx_alt[3] = pho_inx;\n    } else if (key != ' ') {\n        pBopomofo->pho_inx[3] = pho_inx;\n        pBopomofo->pho_inx_alt[3] = pho_inx;\n        return BOPOMOFO_NO_WORD;\n    }\n\n    u16Pho = UintFromPhoneInx(pBopomofo->pho_inx);\n    if (GetCharFirst(pgdata, &tempword, u16Pho) == 0) {\n        BopomofoRemoveAll(pBopomofo);\n        return BOPOMOFO_NO_WORD;\n    }\n\n    pBopomofo->phone = u16Pho;\n\n    if (pBopomofo->pho_inx_alt[0] == 0 && pBopomofo->pho_inx_alt[1] == 0 && pBopomofo->pho_inx_alt[2] == 0) {\n        /* no alternative phone, copy from default as alt */\n        pBopomofo->phoneAlt = u16Pho;\n    } else {\n        u16PhoAlt = UintFromPhoneInx(pBopomofo->pho_inx_alt);\n        pBopomofo->phoneAlt = u16PhoAlt;\n    }\n\n    memset(pBopomofo->pho_inx, 0, sizeof(pBopomofo->pho_inx));\n    memset(pBopomofo->pho_inx_alt, 0, sizeof(pBopomofo->pho_inx_alt));\n    return BOPOMOFO_COMMIT;\n}",
        "begin_line": 94,
        "end_line": 140,
        "is_bug": false
    },
    {
        "name": "bopomofo.DefPhoInput#142",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.DefPhoInput(ChewingData *pgdata, int key)",
        "snippet": "static int DefPhoInput(ChewingData *pgdata, int key)\n{\n    BopomofoData *pBopomofo = &(pgdata->bopomofoData);\n    int type = 0, inx = 0;\n    int i;\n\n    if (IsDefPhoEndKey(key, pBopomofo->kbtype)) {\n        for (i = 0; i < BOPOMOFO_SIZE; ++i)\n            if (pBopomofo->pho_inx[i] != 0)\n                break;\n        if (i < BOPOMOFO_SIZE)\n            return EndKeyProcess(pgdata, key, 1);\n    } else {\n        pBopomofo->pho_inx[3] = 0;\n    }\n\n    /* decide if the key is a phone */\n    for (type = 0; type <= 3; type++) {\n        inx = PhoneInxFromKey(key, type, pBopomofo->kbtype, 1);\n        if (inx)\n            break;\n    }\n\n    /* the key is NOT a phone */\n    if (type > 3) {\n        return BOPOMOFO_KEY_ERROR;\n    }\n\n    /* fill the key into the phone buffer */\n    pBopomofo->pho_inx[type] = inx;\n    return BOPOMOFO_ABSORB;\n}",
        "begin_line": 142,
        "end_line": 173,
        "is_bug": false
    },
    {
        "name": "bopomofo.HsuPhoInput#175",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.HsuPhoInput(ChewingData *pgdata, int key)",
        "snippet": "static int HsuPhoInput(ChewingData *pgdata, int key)\n{\n    BopomofoData *pBopomofo = &(pgdata->bopomofoData);\n    int type = 0, searchTimes = 0, inx = 0;\n\n    /* Dvorak Hsu key has already converted to Hsu */\n    if (IsHsuPhoEndKey(pBopomofo->pho_inx, key)) {\n        if (pBopomofo->pho_inx[1] == 0 && pBopomofo->pho_inx[2] == 0) {\n            /* convert \"\u3110\u3111\u3112\" to \"\u3113\u3114\u3115\" */\n            if (12 <= pBopomofo->pho_inx[0] && pBopomofo->pho_inx[0] <= 14) {\n                pBopomofo->pho_inx[0] += 3;\n            }\n            /* convert \"\u310f\" to \"\u311b\" */\n            else if (pBopomofo->pho_inx[0] == 11) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 2;\n            }\n            /* convert \"\u310d\" to \"\u311c\" */\n            else if (pBopomofo->pho_inx[0] == 9) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 3;\n            }\n            /* convert \"\u3107\" to \"\u3122\" */\n            else if (pBopomofo->pho_inx[0] == 3) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 9;\n            }\n            /* convert \"\u310b\" to \"\u3123\" */\n            else if (pBopomofo->pho_inx[0] == 7) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 10;\n            }\n            /* convert \"\u310e\" to \"\u3124\" */\n            else if (pBopomofo->pho_inx[0] == 10) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 11;\n            }\n            /* convert \"\u310c\" to \"\u3126\" */\n            else if (pBopomofo->pho_inx[0] == 8) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 13;\n            }\n        }\n\n        /* fuzzy \u310d\u3127 to \u3110\u3127 and \u310d\u3129 to \u3110\u3129 */\n        if ((pBopomofo->pho_inx[0] == 9) && ((pBopomofo->pho_inx[1] == 1) || (pBopomofo->pho_inx[1] == 3))) {\n            pBopomofo->pho_inx[0] = 12;\n        }\n\n        searchTimes = (key == 'j') ? 3 : 2;\n\n        return EndKeyProcess(pgdata, key, searchTimes);\n    } else {\n        /* decide if the key is a phone */\n        for (type = 0, searchTimes = 1; type < 3; type++) {\n            inx = PhoneInxFromKey(key, type, pBopomofo->kbtype, searchTimes);\n            if (!inx)\n                continue;       /* if inx == 0, next type */\n            else if (type == 0) {\n                /**\n                 * Hsu maps multiple bopomofo into one single key.\n                 * Therefore, if a consonant or a medial already exists\n                 * in buffer, and the user presses a key with consonant\n                 * and rhyme, libchewing should consider that the user\n                 * wants to input the rhyme.\n                 */\n                if ((inx == 3 || (7 <= inx && inx <= 11) || inx == 20)\n                    && (pBopomofo->pho_inx[0] || pBopomofo->pho_inx[1])) {\n                    /* if inx !=0 */\n                    searchTimes = 2;    /* possible infinite loop here */\n                } else if (12 <= inx && inx <= 14) {\n                    /* \u3110\u3111\u3112 always come with \u3127\u3129, so set \u3113\u3114\u3115 as default. */\n                    pBopomofo->pho_inx[0] = inx + 3;\n                } else\n                    break;\n            } else if (type == 1 && inx == 1) { /* handle i and e */\n                if (pBopomofo->pho_inx[1]) {\n                    searchTimes = 2;\n                } else\n                    break;\n            } else\n                break;\n        }\n\n        /* fuzzy \u310d\u3127 to \u3110\u3127 and \u310d\u3129 to \u3110\u3129 */\n        if ((pBopomofo->pho_inx[0] == 9) && ((pBopomofo->pho_inx[1] == 1) || (pBopomofo->pho_inx[1] == 3))) {\n            pBopomofo->pho_inx[0] = 12;\n        }\n\n        /* \u3110\u3111\u3112 must be followed by \u3127 or \u3129. If not, convert them to \u3113\u3114\u3115. */\n        if (12 <= pBopomofo->pho_inx[0] && pBopomofo->pho_inx[0] <= 14) {\n\t        if ((type == 1 && inx == 2) || (type == 2 && pBopomofo->pho_inx[1] == 0)) {\n\t\t        pBopomofo->pho_inx[0] += 3;\n\t        }\n        }\n\n        /* Likeweis, when \u3113\u3114\u3115 is followed by \u3127 or \u3129, convert them to \u3110\u3111\u3112. */\n        if (15 <= pBopomofo->pho_inx[0] && pBopomofo->pho_inx[0] <= 17) {\n\t        if ((type == 1) && (inx == 1 || inx == 3)) {\n\t\t        pBopomofo->pho_inx[0] -= 3;\n\t        }\n        }\n\n        if (type == 3) {        /* the key is NOT a phone */\n            if (isalpha(key))\n                return BOPOMOFO_NO_WORD;\n            return BOPOMOFO_KEY_ERROR;\n        }\n        /* fill the key into the phone buffer */\n        pBopomofo->pho_inx[type] = inx;\n        return BOPOMOFO_ABSORB;\n    }\n}\n\n/* copy the idea from hsu */\nstatic int ET26PhoInput(ChewingData *pgdata, int key)\n{\n    BopomofoData *pBopomofo =",
        "begin_line": 175,
        "end_line": 287,
        "is_bug": false
    },
    {
        "name": "bopomofo.ET26PhoInput#290",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.ET26PhoInput(ChewingData *pgdata, int key)",
        "snippet": "static int ET26PhoInput(ChewingData *pgdata, int key)\n{\n    BopomofoData *pBopomofo = &(pgdata->bopomofoData);\n    int type = 0, searchTimes = 0, inx = 0;\n\n    if (IsET26PhoEndKey(pBopomofo->pho_inx, key)) {\n        if (pBopomofo->pho_inx[1] == 0 && pBopomofo->pho_inx[2] == 0) {\n            /* convert \"\u3110\u3112\" to \"\u3113\u3115\" */\n            if (pBopomofo->pho_inx[0] == 12 || pBopomofo->pho_inx[0] == 14) {\n                pBopomofo->pho_inx[0] += 3;\n            }\n            /* convert \"\u3106\" to \"\u3121\" */\n            else if (pBopomofo->pho_inx[0] == 2) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 8;\n            }\n            /* convert \"\u3107\" to \"\u3122\" */\n            else if (pBopomofo->pho_inx[0] == 3) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 9;\n            }\n            /* convert \"\u310b\" to \"\u3123\" */\n            else if (pBopomofo->pho_inx[0] == 7) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 10;\n            }\n            /* convert \"\u310a\" to \"\u3124\" */\n            else if (pBopomofo->pho_inx[0] == 6) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 11;\n            }\n            /* convert \"\u310c\" to \"\u3125\" */\n            else if (pBopomofo->pho_inx[0] == 8) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 12;\n            }\n            /* convert \"\u310f\" to \"\u3126\" */\n            else if (pBopomofo->pho_inx[0] == 11) {\n                pBopomofo->pho_inx[0] = 0;\n                pBopomofo->pho_inx[2] = 13;\n            }\n        }\n        searchTimes = 2;\n        return EndKeyProcess(pgdata, key, searchTimes);\n    } else {\n        /* decide if the key is a phone */\n        for (type = 0, searchTimes = 1; type < 3; type++) {\n            inx = PhoneInxFromKey(key, type, pBopomofo->kbtype, searchTimes);\n            if (!inx)\n                continue;       /* if inx == 0, next type */\n            else if (type == 0) {\n                 /**\n                  * Same as Hsu: If a consonant or a medial already exists\n                  * in buffer, and the user presses a key with consonant\n                  * and rhyme, libchewing should consider that the user\n                  * wants to input the rhyme.\n                  */\n                if ((inx == 2 || inx == 3 || inx == 11 || inx == 19 || inx == 20 ||\n                    (6 <= inx && inx <= 8)) && (pBopomofo->pho_inx[0] || pBopomofo->pho_inx[1])) {\n                    /* if inx !=0 */\n                    searchTimes = 2;    /* possible infinite loop here */\n                } else\n                    break;\n            } else\n                break;\n        }\n        /* convert \"\u3110\u3112\" to \"\u3113\u3115\" */\n        if (type == 1) {\n            if (inx == 2) {\n                if (pBopomofo->pho_inx[0] == 12 || pBopomofo->pho_inx[0] == 14) {\n                    pBopomofo->pho_inx[0] += 3;\n                }\n            } else {\n                /* convert \"\u310d\" to \"\u3111\" */\n                if (pBopomofo->pho_inx[0] == 9) {\n                    pBopomofo->pho_inx[0] = 13;\n                }\n            }\n        }\n\n        if (type == 2 && pBopomofo->pho_inx[1] == 0 && (pBopomofo->pho_inx[0] == 12 || pBopomofo->pho_inx[0] == 14)) {\n            pBopomofo->pho_inx[0] += 3;\n        }\n\n        if (type == 3) {        /* the key is NOT a phone */\n            if (isalpha(key))\n                return BOPOMOFO_NO_WORD;\n            return BOPOMOFO_KEY_ERROR;\n        }\n        /* fill the key into the phone buffer */\n        pBopomofo->pho_inx[type] = inx;\n        return BOPOMOFO_ABSORB;\n    }\n}\n\nstatic int SwitchingBetween(int *pho_idx, ",
        "begin_line": 290,
        "end_line": 383,
        "is_bug": false
    },
    {
        "name": "bopomofo.SwitchingBetween#385",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.SwitchingBetween(int *pho_idx, int a, int b)",
        "snippet": "static int SwitchingBetween(int *pho_idx, int a, int b)\n{\n    if (*pho_idx == a) {\n        *pho_idx = b;\n        return 1;\n    } else if (*pho_idx == b) {\n        *pho_idx = a;\n        return 1;\n    }\n    return 0;\n}",
        "begin_line": 385,
        "end_line": 395,
        "is_bug": false
    },
    {
        "name": "bopomofo.DACHENCP26PhoInput#397",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.DACHENCP26PhoInput(ChewingData *pgdata, int key)",
        "snippet": "static int DACHENCP26PhoInput(ChewingData *pgdata, int key)\n{\n    BopomofoData *pBopomofo = &(pgdata->bopomofoData);\n    int type = 0, searchTimes = 0, inx = 0;\n\n    if (IsDACHENCP26PhoEndKey(pBopomofo->pho_inx, key)) {\n        searchTimes = 2;\n        return EndKeyProcess(pgdata, key, searchTimes);\n    } else {\n        /* decide if the key is a phone */\n        for (type = 0, searchTimes = 1; type < 3; type++) {\n            inx = PhoneInxFromKey(key, type, pBopomofo->kbtype, searchTimes);\n            if (!inx)\n                continue;       /* if inx == 0, next type */\n            else if (type == 0) {\n                break;\n                if (pBopomofo->pho_inx[0] || pBopomofo->pho_inx[1]) {\n                    /* if inx !=0 */\n                    searchTimes = 2;    /* possible infinite loop here */\n                } else\n                    break;\n            } else\n                break;\n        }\n        /* switching between \"\u3105\" and \"\u3106\" */\n        if (key == 'q') {\n            if (SwitchingBetween(&pBopomofo->pho_inx[0], 1, 2)) {\n                return BOPOMOFO_ABSORB;\n            }\n        }\n        /* switching between \"\u3109\" and \"\u310a\" */\n        else if (key == 'w') {\n            if (SwitchingBetween(&pBopomofo->pho_inx[0], 5, 6)) {\n                return BOPOMOFO_ABSORB;\n            }\n        }\n        /* switching between \"\u3113\" and \"\u3114\" */\n        else if (key == 't') {\n            if (SwitchingBetween(&pBopomofo->pho_inx[0], 15, 16)) {\n                return BOPOMOFO_ABSORB;\n            }\n        }\n        /* converting \"\u3116\" to \"\u311d\" */\n        else if (key == 'b') {\n            if (pBopomofo->pho_inx[0] != 0 || pBopomofo->pho_inx[1] != 0) {\n                pBopomofo->pho_inx[2] = 4;\n                return BOPOMOFO_ABSORB;\n            }\n        }\n        /* converting \"\u3119\" to \"\u3125\" */\n        else if (key == 'n') {\n            if (pBopomofo->pho_inx[0] != 0 || pBopomofo->pho_inx[1] != 0) {\n                pBopomofo->pho_inx[2] = 12;\n                return BOPOMOFO_ABSORB;\n            }\n        }\n        /* switching between \"\u3127\", \"\u311a\", and \"\u3127\u311a\" */\n        else if (key == 'u') {\n            if (pBopomofo->pho_inx[1] == 1 && pBopomofo->pho_inx[2] != 1) {\n                pBopomofo->pho_inx[1] = 0;\n                pBopomofo->pho_inx[2] = 1;\n                return BOPOMOFO_ABSORB;\n            } else if (pBopomofo->pho_inx[1] != 1 && pBopomofo->pho_inx[2] == 1) {\n                pBopomofo->pho_inx[1] = 1;\n                return BOPOMOFO_ABSORB;\n            } else if (pBopomofo->pho_inx[1] == 1 && pBopomofo->pho_inx[2] == 1) {\n                pBopomofo->pho_inx[1] = 0;\n                pBopomofo->pho_inx[2] = 0;\n                return BOPOMOFO_ABSORB;\n            } else if (pBopomofo->pho_inx[1] != 0) {\n                pBopomofo->pho_inx[2] = 1;\n                return BOPOMOFO_ABSORB;\n            }\n        }\n        /* switching between \"\u3129\" and \"\u3121\" */\n        else if (key == 'm') {\n            if (pBopomofo->pho_inx[1] == 3 && pBopomofo->pho_inx[2] != 8) {\n                pBopomofo->pho_inx[1] = 0;\n                pBopomofo->pho_inx[2] = 8;\n                return BOPOMOFO_ABSORB;\n            } else if (pBopomofo->pho_inx[1] != 3 && pBopomofo->pho_inx[2] == 8) {\n                pBopomofo->pho_inx[1] = 3;\n                pBopomofo->pho_inx[2] = 0;\n                return BOPOMOFO_ABSORB;\n            } else if (pBopomofo->pho_inx[1] != 0) {\n                pBopomofo->pho_inx[2] = 8;\n                return BOPOMOFO_ABSORB;\n            }\n        }\n        /* switching between \"\u311b\" and \"\u311e\" */\n        else if (key == 'i') {\n            if (SwitchingBetween(&pBopomofo->pho_inx[2], 2, 5)) {\n                return BOPOMOFO_ABSORB;\n            }\n        }\n        /* switching between \"\u311f\" and \"\u3122\" */\n        else if (key == 'o') {\n            if (SwitchingBetween(&pBopomofo->pho_inx[2], 6, 9)) {\n                return BOPOMOFO_ABSORB;\n            }\n        }\n        /* switching between \"\u3120\" and \"\u3124\" */\n        else if (key == 'l') {\n            if (SwitchingBetween(&pBopomofo->pho_inx[2], 7, 11)) {\n                return BOPOMOFO_ABSORB;\n            }\n        }\n        /* switching between \"\u3123\" and \"\u3126\" */\n        else if (key == 'p') {\n            if (SwitchingBetween(&pBopomofo->pho_inx[2], 10, 13)) {\n                return BOPOMOFO_ABSORB;\n            }\n        }\n        if (type == 3) {        /* the key is NOT a phone */\n            if (isalpha(key))\n                return BOPOMOFO_NO_WORD;\n            return BOPOMOFO_KEY_ERROR;\n        }\n        /* fill the key into the phone buffer */\n        pBopomofo->pho_inx[type] = inx;\n        return BOPOMOFO_ABSORB;\n    }\n}\n\nstatic int IsPinYinEndKey(int key)\n{\n    if ((",
        "begin_line": 397,
        "end_line": 519,
        "is_bug": false
    },
    {
        "name": "bopomofo.IsPinYinEndKey#521",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.IsPinYinEndKey(int key)",
        "snippet": "static int IsPinYinEndKey(int key)\n{\n    if ((key == ' ') || (key == '1') || (key == '2') || (key == '3') || (key == '4') || (key == '5')) {\n        return 1;\n    }\n    return 0;\n}",
        "begin_line": 521,
        "end_line": 527,
        "is_bug": false
    },
    {
        "name": "bopomofo.IsSymbolKey#529",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.IsSymbolKey(int key)",
        "snippet": "static int IsSymbolKey(int key)\n{\n    if ((key < 97) || (key > 122)) {\n        return 1;\n    }\n\n    return 0;\n}",
        "begin_line": 529,
        "end_line": 536,
        "is_bug": false
    },
    {
        "name": "bopomofo.PinYinInput#538",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.PinYinInput(ChewingData *pgdata, int key)",
        "snippet": "static int PinYinInput(ChewingData *pgdata, int key)\n{\n    BopomofoData *pBopomofo = &(pgdata->bopomofoData);\n    int err = 0;\n    unsigned int i;\n    char bopomofoKeySeq[5], bopomofoKeySeqAlt[5], buf[2];\n    size_t len;\n\n    DEBUG_CHECKPOINT();\n\n    if (pBopomofo->pinYinData.keySeq[0] == 0 && IsSymbolKey(key)) {\n        return BOPOMOFO_KEY_ERROR;\n    }\n\n    if (IsPinYinEndKey(key)) {\n        err = PinyinToBopomofo(pgdata, pBopomofo->pinYinData.keySeq, bopomofoKeySeq, bopomofoKeySeqAlt);\n        if (err) {\n            pBopomofo->pinYinData.keySeq[0] = '\\0';\n            return BOPOMOFO_ABSORB;\n        }\n\n        DEBUG_OUT(\"bopomofoKeySeq: %s\\n\", bopomofoKeySeq);\n        DEBUG_OUT(\"bopomofoKeySeqAlt: %s\\n\", bopomofoKeySeqAlt);\n\n        len = strlen(bopomofoKeySeq);\n        for (i = 0; i < len; i++) {\n            int type = 0, inx = 0;\n\n            for (type = 0; type <= 3; type++) {\n                inx = PhoneInxFromKey(bopomofoKeySeq[i], type, pBopomofo->kbtype, 1);\n                if (inx)\n                    break;\n            }\n\n            /* the key is NOT a phone */\n            if (type > 3) {\n                return BOPOMOFO_KEY_ERROR;\n            }\n\n            pBopomofo->pho_inx[type] = inx;\n\n        }\n\n        len = strlen(bopomofoKeySeqAlt);\n        for (i = 0; i < len; i++) {\n            int type = 0, inx = 0;\n\n            for (type = 0; type <= 3; type++) {\n                inx = PhoneInxFromKey(bopomofoKeySeqAlt[i], type, pBopomofo->kbtype, 1);\n                if (inx)\n                    break;\n            }\n\n            /* the key is NOT a phone */\n            if (type > 3) {\n                return BOPOMOFO_KEY_ERROR;\n            }\n\n            pBopomofo->pho_inx_alt[type] = inx;\n\n        }\n\n        switch (key) {\n        case '1':\n            key = ' ';\n            break;\n        case '2':\n            key = '6';\n            break;\n        case '5':\n            key = '7';\n        }\n        pBopomofo->pinYinData.keySeq[0] = '\\0';\n        return EndKeyProcess(pgdata, key, 1);\n    }\n\n    if (strlen(pBopomofo->pinYinData.keySeq) + 1 < sizeof(pBopomofo->pinYinData.keySeq)) {\n        buf[0] = key;\n        buf[1] = '\\0';\n        strcat(pBopomofo->pinYinData.keySeq, buf);\n    } else {\n        /* buffer is full, ignore this keystroke */\n        return BOPOMOFO_NO_WORD;\n    }\n\n    DEBUG_OUT(\"PinYin Seq: %s\\n\", pBopomofo->pinYinData.keySeq);\n\n    return BOPOMOFO_ABSORB;\n}",
        "begin_line": 538,
        "end_line": 626,
        "is_bug": false
    },
    {
        "name": "bopomofo.BopomofoPhoInput#629",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.BopomofoPhoInput(ChewingData *pgdata, int key)",
        "snippet": "int BopomofoPhoInput(ChewingData *pgdata, int key)\n{\n    BopomofoData *pBopomofo = &(pgdata->bopomofoData);\n\n    /* open symbol table */\n    if (key == '`') {\n        pgdata->bSelect = 1;\n        pgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;\n        HaninSymbolInput(pgdata);\n        return BOPOMOFO_OPEN_SYMBOL_TABLE;\n    }\n    switch (pBopomofo->kbtype) {\n    case KB_HSU:\n    case KB_DVORAK_HSU:\n        return HsuPhoInput(pgdata, key);\n        break;\n    case KB_ET26:\n        return ET26PhoInput(pgdata, key);\n        break;\n    case KB_DACHEN_CP26:\n        return DACHENCP26PhoInput(pgdata, key);\n        break;\n    case KB_HANYU_PINYIN:\n    case KB_THL_PINYIN:\n    case KB_MPS2_PINYIN:\n        return PinYinInput(pgdata, key);\n        break;\n    default:\n        return DefPhoInput(pgdata, key);\n    }\n    return BOPOMOFO_ERROR;\n}",
        "begin_line": 629,
        "end_line": 660,
        "is_bug": false
    },
    {
        "name": "bopomofo.BopomofoRemoveLast#663",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.BopomofoRemoveLast(BopomofoData *pBopomofo)",
        "snippet": "int BopomofoRemoveLast(BopomofoData *pBopomofo)\n{\n    int i;\n\n    if (pBopomofo->kbtype >= KB_HANYU_PINYIN) {\n        i = strlen(pBopomofo->pinYinData.keySeq);\n        pBopomofo->pinYinData.keySeq[i - 1] = '\\0';\n    } else {\n        for (i = 3; i >= 0; i--) {\n            if (pBopomofo->pho_inx[i]) {\n                pBopomofo->pho_inx[i] = 0;\n                return 0;\n            }\n        }\n    }\n    return 0;\n}",
        "begin_line": 663,
        "end_line": 679,
        "is_bug": false
    },
    {
        "name": "bopomofo.BopomofoRemoveAll#682",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.BopomofoRemoveAll(BopomofoData *pBopomofo)",
        "snippet": "int BopomofoRemoveAll(BopomofoData *pBopomofo)\n{\n    memset(pBopomofo->pho_inx, 0, sizeof(pBopomofo->pho_inx));\n    memset(pBopomofo->pinYinData.keySeq, 0, sizeof(pBopomofo->pinYinData.keySeq));\n    return 0;\n}",
        "begin_line": 682,
        "end_line": 687,
        "is_bug": false
    },
    {
        "name": "bopomofo.BopomofoIsEntering#689",
        "src_path": "src/bopomofo.c",
        "class_name": "bopomofo",
        "signature": "bopomofo.BopomofoIsEntering(BopomofoData *pBopomofo)",
        "snippet": "int BopomofoIsEntering(BopomofoData *pBopomofo)\n{\n    int i;\n\n    if (pBopomofo->kbtype >= KB_HANYU_PINYIN) {\n        if (pBopomofo->pinYinData.keySeq[0])\n            return 1;\n    } else {\n        for (i = 0; i < BOPOMOFO_SIZE; i++)\n            if (pBopomofo->pho_inx[i])\n                return 1;\n    }\n    return 0;\n}",
        "begin_line": 689,
        "end_line": 702,
        "is_bug": false
    },
    {
        "name": "tree.IsContain#59",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.IsContain(IntervalType in1, IntervalType in2)",
        "snippet": "static int IsContain(IntervalType in1, IntervalType in2)\n{\n    return (in1.from <= in2.from && in1.to >= in2.to);\n}",
        "begin_line": 59,
        "end_line": 62,
        "is_bug": false
    },
    {
        "name": "tree.IsIntersect#64",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.IsIntersect(IntervalType in1, IntervalType in2)",
        "snippet": "int IsIntersect(IntervalType in1, IntervalType in2)\n{\n    return (max(in1.from, in2.from) < min(in1.to, in2.to));\n}",
        "begin_line": 64,
        "end_line": 67,
        "is_bug": false
    },
    {
        "name": "tree.PhraseIntervalContain#69",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.PhraseIntervalContain(PhraseIntervalType in1, PhraseIntervalType in2)",
        "snippet": "static int PhraseIntervalContain(PhraseIntervalType in1, PhraseIntervalType in2)\n{\n    return (in1.from <= in2.from && in1.to >= in2.to);\n}",
        "begin_line": 69,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "tree.PhraseIntervalIntersect#74",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.PhraseIntervalIntersect(PhraseIntervalType in1, PhraseIntervalType in2)",
        "snippet": "static int PhraseIntervalIntersect(PhraseIntervalType in1, PhraseIntervalType in2)\n{\n    return (max(in1.from, in2.from) < min(in1.to, in2.to));\n}",
        "begin_line": 74,
        "end_line": 77,
        "is_bug": false
    },
    {
        "name": "tree.TerminateTree#79",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.TerminateTree(ChewingData *pgdata)",
        "snippet": "void TerminateTree(ChewingData *pgdata)\n{\n    pgdata->static_data.tree = NULL;\n    plat_mmap_close(&pgdata->static_data.tree_mmap);\n}",
        "begin_line": 79,
        "end_line": 83,
        "is_bug": false
    },
    {
        "name": "tree.InitTree#86",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.InitTree(ChewingData *pgdata, const char *prefix)",
        "snippet": "int InitTree(ChewingData *pgdata, const char *prefix)\n{\n    char filename[PATH_MAX];\n    size_t len;\n    size_t offset;\n\n    len = snprintf(filename, sizeof(filename), \"%s\" PLAT_SEPARATOR \"%s\", prefix, PHONE_TREE_FILE);\n    if (len + 1 > sizeof(filename))\n        return -1;\n\n    plat_mmap_set_invalid(&pgdata->static_data.tree_mmap);\n    pgdata->static_data.tree_size = plat_mmap_create(&pgdata->static_data.tree_mmap, filename, FLAG_ATTRIBUTE_READ);\n    if (pgdata->static_data.tree_size <= 0)\n        return -1;\n\n    offset = 0;\n    pgdata->static_data.tree =\n        (const TreeType *) plat_mmap_set_view(&pgdata->static_data.tree_mmap, &offset, &pgdata->static_data.tree_size);\n    if (!pgdata->static_data.tree)\n        return -1;\n\n    return 0;\n}",
        "begin_line": 86,
        "end_line": 108,
        "is_bug": false
    },
    {
        "name": "tree.CheckBreakpoint#110",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CheckBreakpoint(int from, int to, int bArrBrkpt[])",
        "snippet": "static int CheckBreakpoint(int from, int to, int bArrBrkpt[])\n{\n    int i;\n\n    for (i = from + 1; i < to; i++)\n        if (bArrBrkpt[i])\n            return 0;\n    return 1;\n}",
        "begin_line": 110,
        "end_line": 118,
        "is_bug": false
    },
    {
        "name": "tree.CheckUserChoose#120",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CheckUserChoose(ChewingData *pgdata, uint16_t *new_phoneSeq, int from, int to, Phrase **pp_phr, char selectStr[][MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1], IntervalType selectInterval[], int nSelect)",
        "snippet": "static int CheckUserChoose(ChewingData *pgdata,\n                           uint16_t *new_phoneSeq, int from, int to,\n                           Phrase **pp_phr,\n                           char selectStr[][MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1],\n                           IntervalType selectInterval[], int nSelect)\n{\n    IntervalType inte, c;\n    int chno, len;\n    int user_alloc;\n    UserPhraseData *pUserPhraseData;\n    Phrase *p_phr = ALC(Phrase, 1);\n\n    assert(p_phr);\n    inte.from = from;\n    inte.to = to;\n    *pp_phr = NULL;\n\n    /* pass 1\n     * if these exist one selected interval which is not contained by inte\n     * but has intersection with inte, then inte is an unacceptable interval\n     */\n    for (chno = 0; chno < nSelect; chno++) {\n        c = selectInterval[chno];\n        if (IsIntersect(inte, c) && !IsContain(inte, c)) {\n            free(p_phr);\n            return 0;\n        }\n    }\n\n    /* pass 2\n     * if there exist one phrase satisfied all selectStr then return 1, else return 0.\n     * also store the phrase with highest freq\n     */\n    pUserPhraseData = UserGetPhraseFirst(pgdata, new_phoneSeq);\n    if (pUserPhraseData == NULL)\n      goto end;\n    p_phr->freq = -1;\n    do {\n        for (chno = 0; chno < nSelect; chno++) {\n            c = selectInterval[chno];\n\n            if (IsContain(inte, c)) {\n                /*\n                 * find a phrase of ph_id where the text contains\n                 * 'selectStr[chno]' test if not ok then return 0,\n                 * if ok then continue to test. */\n                len = c.to - c.from;\n                if (strncmp(ueStrSeek(pUserPhraseData->wordSeq, c.from - from),\n                            selectStr[chno],\n                            ueStrNBytes(selectStr[chno], len))) {\n                    break;\n                }\n            }\n\n        }\n        if (chno == nSelect) {\n            /* save phrase data to \"pp_phr\" */\n            if (pUserPhraseData->userfreq > p_phr->freq) {\n                if ((user_alloc = (to - from)) > 0) {\n                    ueStrNCpy(p_phr->phrase, pUserPhraseData->wordSeq, user_alloc, 1);\n                }\n                p_phr->freq = pUserPhraseData->userfreq;\n                *pp_phr = p_phr;\n            }\n        }\n    } while ((pUserPhraseData = UserGetPhraseNext(pgdata, new_phoneSeq)) != NULL);\n    UserGetPhraseEnd(pgdata, new_phoneSeq);\n\n    if (p_phr->freq != -1)\n        return 1;\n  end:\n    free(p_phr);\n    return 0;\n}",
        "begin_line": 120,
        "end_line": 193,
        "is_bug": false
    },
    {
        "name": "tree.CheckChoose#198",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CheckChoose(ChewingData *pgdata, const TreeType *phrase_parent, int from, int to, Phrase **pp_phr, char selectStr[][MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1], IntervalType selectInterval[], int nSelect)",
        "snippet": "static int CheckChoose(ChewingData *pgdata,\n                       const TreeType *phrase_parent, int from, int to, Phrase **pp_phr,\n                       char selectStr[][MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1],\n                       IntervalType selectInterval[], int nSelect)\n{\n    IntervalType inte, c;\n    int chno, len;\n    Phrase *phrase = ALC(Phrase, 1);\n\n    assert(phrase);\n    inte.from = from;\n    inte.to = to;\n    *pp_phr = NULL;\n\n    /* if there exist one phrase satisfied all selectStr then return 1, else return 0. */\n    GetPhraseFirst(pgdata, phrase, phrase_parent);\n    do {\n        for (chno = 0; chno < nSelect; chno++) {\n            c = selectInterval[chno];\n\n            if (IsContain(inte, c)) {\n                /* find a phrase under phrase_parent where the text contains\n                 * 'selectStr[chno]' test if not ok then return 0, if ok\n                 * then continue to test\n                 */\n                len = c.to - c.from;\n                if (memcmp(ueStrSeek(phrase->phrase, c.from - from),\n                           selectStr[chno], ueStrNBytes(selectStr[chno], len)))\n                    break;\n            } else if (IsIntersect(inte, selectInterval[chno])) {\n                free(phrase);\n                return 0;\n            }\n        }\n        if (chno == nSelect) {\n            *pp_phr = phrase;\n            return 1;\n        }\n    } while (GetVocabNext(pgdata, phrase));\n    free(phrase);\n    return 0;\n}",
        "begin_line": 198,
        "end_line": 239,
        "is_bug": false
    },
    {
        "name": "tree.CompTreeType#241",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CompTreeType(const void *a, const void *b)",
        "snippet": "static int CompTreeType(const void *a, const void *b)\n{\n    return GetUint16(((TreeType *) a)->key) - GetUint16(((TreeType *) b)->key);\n}",
        "begin_line": 241,
        "end_line": 244,
        "is_bug": false
    },
    {
        "name": "tree.TreeFindPhrase#250",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.TreeFindPhrase(ChewingData *pgdata, int begin, int end, const uint16_t *phoneSeq)",
        "snippet": "const TreeType *TreeFindPhrase(ChewingData *pgdata, int begin, int end, const uint16_t *phoneSeq)\n{\n    TreeType target;\n    const TreeType *tree_p = pgdata->static_data.tree;\n    uint32_t range[2];\n    int i;\n\n    for (i = begin; i <= end; i++) {\n        PutUint16(phoneSeq[i], target.key);\n        range[0] = GetUint24(tree_p->child.begin);\n        range[1] = GetUint24(tree_p->child.end);\n        assert(range[1] >= range[0]);\n        tree_p = (const TreeType *) bsearch(&target, pgdata->static_data.tree + range[0],\n                                            range[1] - range[0], sizeof(TreeType), CompTreeType);\n\n        /* if not found any word then fail. */\n        if (!tree_p)\n            return NULL;\n    }\n\n    /* If its child has no key value of 0, then it is only a \"half\" phrase. */\n    if (GetUint16(pgdata->static_data.tree[GetUint24(tree_p->child.begin)].key) != 0)\n        return NULL;\n    return tree_p;\n}",
        "begin_line": 250,
        "end_line": 274,
        "is_bug": false
    },
    {
        "name": "tree.TreeChildRange#279",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.TreeChildRange(ChewingData *pgdata, const TreeType *parent)",
        "snippet": "void TreeChildRange(ChewingData *pgdata, const TreeType *parent)\n{\n    pgdata->static_data.tree_cur_pos = pgdata->static_data.tree + GetUint24(parent->child.begin);\n    pgdata->static_data.tree_end_pos = pgdata->static_data.tree + GetUint24(parent->child.end);\n}",
        "begin_line": 279,
        "end_line": 283,
        "is_bug": false
    },
    {
        "name": "tree.AddInterval#285",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.AddInterval(TreeDataType *ptd, int begin, int end, Phrase *p_phrase, int dict_or_user)",
        "snippet": "static void AddInterval(TreeDataType *ptd, int begin, int end, Phrase *p_phrase, int dict_or_user)\n{\n    ptd->interval[ptd->nInterval].from = begin;\n    ptd->interval[ptd->nInterval].to = end + 1;\n    ptd->interval[ptd->nInterval].p_phr = p_phrase;\n    ptd->interval[ptd->nInterval].source = dict_or_user;\n    ptd->nInterval++;\n}",
        "begin_line": 285,
        "end_line": 292,
        "is_bug": false
    },
    {
        "name": "tree.internal_release_Phrase#301",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.internal_release_Phrase(UsedPhraseMode mode, Phrase *pUser, Phrase *pDict)",
        "snippet": "static void internal_release_Phrase(UsedPhraseMode mode, Phrase *pUser, Phrase *pDict)\n{\n    /* we must free unused phrase entry to avoid memory leak. */\n    switch (mode) {\n    case USED_PHRASE_USER:\n        if (pDict != NULL)\n            free(pDict);\n        break;\n    case USED_PHRASE_DICT:\n        if (pUser != NULL)\n            free(pUser);\n        break;\n    default:                   /* In fact, it is always 0 */\n        if (pDict != NULL)\n            free(pDict);\n        if (pUser != NULL)\n            free(pUser);\n        break;\n    }\n}",
        "begin_line": 301,
        "end_line": 320,
        "is_bug": false
    },
    {
        "name": "tree.FindInterval#322",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.FindInterval(ChewingData *pgdata, TreeDataType *ptd)",
        "snippet": "static void FindInterval(ChewingData *pgdata, TreeDataType *ptd)\n{\n    int end, begin;\n    const TreeType *phrase_parent;\n    Phrase *p_phrase, *puserphrase, *pdictphrase;\n    UsedPhraseMode i_used_phrase;\n    uint16_t new_phoneSeq[MAX_PHONE_SEQ_LEN];\n    UserPhraseData *userphrase;\n\n    for (begin = 0; begin < pgdata->nPhoneSeq; begin++) {\n        for (end = begin; end < min(pgdata->nPhoneSeq, begin + MAX_PHRASE_LEN); end++) {\n            if (!CheckBreakpoint(begin, end + 1, pgdata->bArrBrkpt))\n                break;\n\n            /* set new_phoneSeq */\n            memcpy(new_phoneSeq, &pgdata->phoneSeq[begin], sizeof(uint16_t) * (end - begin + 1));\n            new_phoneSeq[end - begin + 1] = 0;\n            puserphrase = pdictphrase = NULL;\n            i_used_phrase = USED_PHRASE_NONE;\n\n            userphrase = UserGetPhraseFirst(pgdata, new_phoneSeq);\n            UserGetPhraseEnd(pgdata, new_phoneSeq);\n\n            if (userphrase && CheckUserChoose(pgdata, new_phoneSeq, begin, end + 1,\n                                              &p_phrase, pgdata->selectStr, pgdata->selectInterval, pgdata->nSelect)) {\n                puserphrase = p_phrase;\n            }\n\n            /* check dict phrase */\n            phrase_parent = TreeFindPhrase(pgdata, begin, end, pgdata->phoneSeq);\n            if (phrase_parent &&\n                CheckChoose(pgdata,\n                            phrase_parent, begin, end + 1,\n                            &p_phrase, pgdata->selectStr, pgdata->selectInterval, pgdata->nSelect)) {\n                pdictphrase = p_phrase;\n            }\n\n            /* add only one interval, which has the largest freqency\n             * but when the phrase is the same, the user phrase overrides\n             * static dict\n             */\n            if (puserphrase != NULL && pdictphrase == NULL) {\n                i_used_phrase = USED_PHRASE_USER;\n            } else if (puserphrase == NULL && pdictphrase != NULL) {\n                i_used_phrase = USED_PHRASE_DICT;\n            } else if (puserphrase != NULL && pdictphrase != NULL) {\n                /* the same phrase, userphrase overrides */\n                if (!strcmp(puserphrase->phrase, pdictphrase->phrase)) {\n                    i_used_phrase = USED_PHRASE_USER;\n                } else {\n                    if (puserphrase->freq > pdictphrase->freq) {\n                        i_used_phrase = USED_PHRASE_USER;\n                    } else {\n                        i_used_phrase = USED_PHRASE_DICT;\n                    }\n                }\n            }\n            switch (i_used_phrase) {\n            case USED_PHRASE_USER:\n                AddInterval(ptd, begin, end, puserphrase, IS_USER_PHRASE);\n                break;\n            case USED_PHRASE_DICT:\n                AddInterval(ptd, begin, end, pdictphrase, IS_DICT_PHRASE);\n                break;\n            case USED_PHRASE_NONE:\n            default:\n                break;\n            }\n            internal_release_Phrase(i_used_phrase, puserphrase, pdictphrase);\n        }\n    }\n}",
        "begin_line": 322,
        "end_line": 393,
        "is_bug": false
    },
    {
        "name": "tree.SetInfo#395",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.SetInfo(int len, TreeDataType *ptd)",
        "snippet": "static void SetInfo(int len, TreeDataType *ptd)\n{\n    int i, a;\n\n    for (i = 0; i <= len; i++)\n        ptd->leftmost[i] = i;\n    for (i = 0; i < ptd->nInterval; i++) {\n        ptd->graph[ptd->interval[i].from][ptd->interval[i].to] = 1;\n        ptd->graph[ptd->interval[i].to][ptd->interval[i].from] = 1;\n    }\n\n    /* set leftmost */\n    for (a = 0; a <= len; a++) {\n        for (i = 0; i <= len; i++) {\n            if (!(ptd->graph[a][i]))\n                continue;\n            if (ptd->leftmost[i] < ptd->leftmost[a])\n                ptd->leftmost[a] = ptd->leftmost[i];\n        }\n    }\n}",
        "begin_line": 395,
        "end_line": 415,
        "is_bug": false
    },
    {
        "name": "tree.CompRecord#421",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CompRecord(const RecordNode **pa, const RecordNode **pb)",
        "snippet": "static int CompRecord(const RecordNode **pa, const RecordNode **pb)\n{\n    int diff = (*pb)->nMatchCnnct - (*pa)->nMatchCnnct;\n\n    if (diff)\n        return diff;\n    return ((*pb)->score - (*pa)->score);\n}",
        "begin_line": 421,
        "end_line": 428,
        "is_bug": false
    },
    {
        "name": "tree.Discard1#437",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.Discard1(TreeDataType *ptd)",
        "snippet": "static void Discard1(TreeDataType *ptd)\n{\n    int a, b;\n    char failflag[INTERVAL_SIZE];\n    int nInterval2;\n\n    memset(failflag, 0, sizeof(failflag));\n    for (a = 0; a < ptd->nInterval; a++) {\n        if (failflag[a])\n            continue;\n        for (b = 0; b < ptd->nInterval; b++) {\n            if (a == b || failflag[b])\n                continue;\n\n            /* interval b is in interval a */\n            if (PhraseIntervalContain(ptd->interval[a], ptd->interval[b]))\n                continue;\n\n            /* interval b is in front of interval a */\n            if (ptd->interval[b].to <= ptd->interval[a].from)\n                continue;\n\n            /* interval b is in back of interval a */\n            if (ptd->interval[a].to <= ptd->interval[b].from)\n                continue;\n\n            break;\n        }\n        /* if any other interval b is inside or leftside or rightside the\n         * interval a */\n        if (b >= ptd->nInterval) {\n            /* then kill all the intervals inside the interval a */\n            int i;\n\n            for (i = 0; i < ptd->nInterval; i++) {\n                if (!failflag[i] && i != a && PhraseIntervalContain(ptd->interval[a], ptd->interval[i])) {\n                    failflag[i] = 1;\n                }\n            }\n        }\n    }\n    /* discard all the intervals whose failflag[a] = 1 */\n    nInterval2 = 0;\n    for (a = 0; a < ptd->nInterval; a++) {\n        if (!failflag[a]) {\n            ptd->interval[nInterval2++] = ptd->interval[a];\n        } else {\n            if (ptd->interval[a].p_phr != NULL) {\n                free(ptd->interval[a].p_phr);\n            }\n        }\n    }\n    ptd->nInterval = nInterval2;\n}",
        "begin_line": 437,
        "end_line": 490,
        "is_bug": false
    },
    {
        "name": "tree.Discard2#503",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.Discard2(TreeDataType *ptd)",
        "snippet": "static void Discard2(TreeDataType *ptd)\n{\n    int i, j;\n    char overwrite[MAX_PHONE_SEQ_LEN];\n    char failflag[INTERVAL_SIZE];\n    int nInterval2;\n\n    memset(failflag, 0, sizeof(failflag));\n    for (i = 0; i < ptd->nInterval; i++) {\n        if (ptd->leftmost[ptd->interval[i].from] == 0)\n            continue;\n        /* test if interval i is overwrited by other intervals */\n        memset(overwrite, 0, sizeof(overwrite));\n        for (j = 0; j < ptd->nInterval; j++) {\n            if (j == i)\n                continue;\n            memset(&overwrite[ptd->interval[j].from], 1, ptd->interval[j].to - ptd->interval[j].from);\n        }\n        if (memchr(&overwrite[ptd->interval[i].from], 1, ptd->interval[i].to - ptd->interval[i].from))\n            failflag[i] = 1;\n    }\n    /* discard all the intervals whose failflag[a] = 1 */\n    nInterval2 = 0;\n    for (i = 0; i < ptd->nInterval; i++)\n        if (!failflag[i])\n            ptd->interval[nInterval2++] = ptd->interval[i];\n        else if (ptd->interval[i].p_phr != NULL)\n            free(ptd->interval[i].p_phr);\n    ptd->nInterval = nInterval2;\n}",
        "begin_line": 503,
        "end_line": 532,
        "is_bug": false
    },
    {
        "name": "tree.FillPreeditBuf#534",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.FillPreeditBuf(ChewingData *pgdata, char *phrase, int from, int to)",
        "snippet": "static void FillPreeditBuf(ChewingData *pgdata, char *phrase, int from, int to)\n{\n    int i;\n    int start = 0;\n\n    assert(pgdata);\n    assert(phrase);\n    assert(from < to);\n\n    start = toPreeditBufIndex(pgdata, from);\n\n    LOG_VERBOSE(\"Fill preeditBuf start %d, from = %d, to = %d\", start, from, to);\n\n    for (i = start; i < start - from + to; ++i) {\n        ueStrNCpy(pgdata->preeditBuf[i].char_, ueStrSeek(phrase, i - start), 1, STRNCPY_CLOSE);\n    }\n}",
        "begin_line": 534,
        "end_line": 550,
        "is_bug": false
    },
    {
        "name": "tree.OutputRecordStr#553",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.OutputRecordStr(ChewingData *pgdata, const TreeDataType *ptd)",
        "snippet": "static void OutputRecordStr(ChewingData *pgdata, const TreeDataType *ptd)\n{\n    PhraseIntervalType inter;\n    int i;\n\n    for (i = 0; i < ptd->phList->nInter; i++) {\n        inter = ptd->interval[ptd->phList->arrIndex[i]];\n        FillPreeditBuf(pgdata, inter.p_phr->phrase, inter.from, inter.to);\n    }\n\n    for (i = 0; i < pgdata->nSelect; i++) {\n        FillPreeditBuf(pgdata, pgdata->selectStr[i], pgdata->selectInterval[i].from, pgdata->selectInterval[i].to);\n    }\n}",
        "begin_line": 553,
        "end_line": 566,
        "is_bug": false
    },
    {
        "name": "tree.rule_largest_sum#568",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.rule_largest_sum(const int *record, int nRecord, const TreeDataType *ptd)",
        "snippet": "static int rule_largest_sum(const int *record, int nRecord, const TreeDataType *ptd)\n{\n    int i, score = 0;\n    PhraseIntervalType inter;\n\n    for (i = 0; i < nRecord; i++) {\n        inter = ptd->interval[record[i]];\n        assert(inter.p_phr);\n        score += inter.to - inter.from;\n    }\n    return score;\n}",
        "begin_line": 568,
        "end_line": 579,
        "is_bug": false
    },
    {
        "name": "tree.rule_largest_avgwordlen#581",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.rule_largest_avgwordlen(const int *record, int nRecord, const TreeDataType *ptd)",
        "snippet": "static int rule_largest_avgwordlen(const int *record, int nRecord, const TreeDataType *ptd)\n{\n    /* constant factor 6=1*2*3, to keep value as integer */\n    return 6 * rule_largest_sum(record, nRecord, ptd) / nRecord;\n}",
        "begin_line": 581,
        "end_line": 585,
        "is_bug": false
    },
    {
        "name": "tree.rule_smallest_lenvariance#587",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.rule_smallest_lenvariance(const int *record, int nRecord, const TreeDataType *ptd)",
        "snippet": "static int rule_smallest_lenvariance(const int *record, int nRecord, const TreeDataType *ptd)\n{\n    int i, j, score = 0;\n    PhraseIntervalType inter1, inter2;\n\n    /* kcwu: heuristic? why variance no square function? */\n    for (i = 0; i < nRecord; i++) {\n        for (j = i + 1; j < nRecord; j++) {\n            inter1 = ptd->interval[record[i]];\n            inter2 = ptd->interval[record[j]];\n            assert(inter1.p_phr && inter2.p_phr);\n            score += abs((inter1.to - inter1.from) - (inter2.to - inter2.from));\n        }\n    }\n    return -score;\n}",
        "begin_line": 587,
        "end_line": 602,
        "is_bug": false
    },
    {
        "name": "tree.rule_largest_freqsum#604",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.rule_largest_freqsum(const int *record, int nRecord, const TreeDataType *ptd)",
        "snippet": "static int rule_largest_freqsum(const int *record, int nRecord, const TreeDataType *ptd)\n{\n    int i, score = 0;\n    PhraseIntervalType inter;\n\n    for (i = 0; i < nRecord; i++) {\n        inter = ptd->interval[record[i]];\n        assert(inter.p_phr);\n\n        /* We adjust the 'freq' of One-word Phrase */\n        score += (inter.to - inter.from == 1) ? (inter.p_phr->freq / 512) : inter.p_phr->freq;\n    }\n    return score;\n}",
        "begin_line": 604,
        "end_line": 617,
        "is_bug": false
    },
    {
        "name": "tree.LoadPhraseAndCountScore#619",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.LoadPhraseAndCountScore(const int *record, int nRecord, const TreeDataType *ptd)",
        "snippet": "static int LoadPhraseAndCountScore(const int *record, int nRecord, const TreeDataType *ptd)\n{\n    int total_score = 0;\n\n    /* NOTE: the balance factor is tuneable */\n    if (nRecord) {\n        total_score += 1000 * rule_largest_sum(record, nRecord, ptd);\n        total_score += 1000 * rule_largest_avgwordlen(record, nRecord, ptd);\n        total_score += 100 * rule_smallest_lenvariance(record, nRecord, ptd);\n        total_score += rule_largest_freqsum(record, nRecord, ptd);\n    }\n    return total_score;\n}",
        "begin_line": 619,
        "end_line": 631,
        "is_bug": false
    },
    {
        "name": "tree.IsRecContain#633",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.IsRecContain(const int *intA, int nA, const int *intB, int nB, const TreeDataType *ptd)",
        "snippet": "static int IsRecContain(const int *intA, int nA, const int *intB, int nB, const TreeDataType *ptd)\n{\n    int big, sml;\n\n    for (big = 0, sml = 0; sml < nB; sml++) {\n        while ((big < nA) && ptd->interval[intA[big]].from < ptd->interval[intB[sml]].to) {\n            if (PhraseIntervalContain(ptd->interval[intA[big]], ptd->interval[intB[sml]]))\n                break;\n            big++;\n        }\n        if ((big >= nA) || ptd->interval[intA[big]].from >= ptd->interval[intB[sml]].to)\n            return 0;\n    }\n    return 1;\n}",
        "begin_line": 633,
        "end_line": 647,
        "is_bug": false
    },
    {
        "name": "tree.SortListByScore#649",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.SortListByScore(TreeDataType *ptd)",
        "snippet": "static void SortListByScore(TreeDataType *ptd)\n{\n    int i, listLen;\n    RecordNode *p, **arr;\n\n    for (listLen = 0, p = ptd->phList; p; listLen++, p = p->next);\n    ptd->nPhListLen = listLen;\n\n    assert(listLen);\n    arr = ALC(RecordNode *, listLen);\n    assert(arr);\n\n    for (i = 0, p = ptd->phList; i < listLen; p = p->next, i++) {\n        arr[i] = p;\n        p->score = LoadPhraseAndCountScore(p->arrIndex, p->nInter, ptd);\n    }\n\n    qsort(arr, listLen, sizeof(RecordNode *), (CompFuncType) CompRecord);\n\n    ptd->phList = arr[0];\n    for (i = 1; i < listLen; i++) {\n        arr[i - 1]->next = arr[i];\n    }\n    arr[listLen - 1]->next = NULL;\n\n    free(arr);\n}",
        "begin_line": 649,
        "end_line": 675,
        "is_bug": false
    },
    {
        "name": "tree.SaveRecord#678",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.SaveRecord(const int *record, int nInter, TreeDataType *ptd)",
        "snippet": "static void SaveRecord(const int *record, int nInter, TreeDataType *ptd)\n{\n    RecordNode *now, *p, *pre;\n\n    pre = NULL;\n    for (p = ptd->phList; p;) {\n        /* if  'p' contains 'record', then discard 'record'. */\n        if (IsRecContain(p->arrIndex, p->nInter, record, nInter, ptd))\n            return;\n\n        /* if 'record' contains 'p', then discard 'p'\n         * -- We must deal with the linked list. */\n        if (IsRecContain(record, nInter, p->arrIndex, p->nInter, ptd)) {\n            RecordNode *tp = p;\n\n            if (pre)\n                pre->next = p->next;\n            else\n                ptd->phList = ptd->phList->next;\n            p = p->next;\n            free(tp->arrIndex);\n            free(tp);\n        } else\n            pre = p, p = p->next;\n    }\n    now = ALC(RecordNode, 1);\n\n    assert(now);\n    now->next = ptd->phList;\n    now->arrIndex = ALC(int, nInter);\n\n    assert(now->arrIndex);\n    now->nInter = nInter;\n    memcpy(now->arrIndex, record, nInter * sizeof(int));\n    ptd->phList = now;\n}",
        "begin_line": 678,
        "end_line": 713,
        "is_bug": false
    },
    {
        "name": "tree.RecursiveSave#715",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.RecursiveSave(int depth, int to, int *record, TreeDataType *ptd)",
        "snippet": "static void RecursiveSave(int depth, int to, int *record, TreeDataType *ptd)\n{\n    int first, i;\n\n    /* to find first interval */\n    for (first = record[depth - 1] + 1; ptd->interval[first].from < to && first < ptd->nInterval; first++);\n\n    if (first == ptd->nInterval) {\n        SaveRecord(record + 1, depth - 1, ptd);\n        return;\n    }\n    record[depth] = first;\n    RecursiveSave(depth + 1, ptd->interval[first].to, record, ptd);\n    /* for each interval which intersects first */\n    for (i = first + 1; PhraseIntervalIntersect(ptd->interval[first], ptd->interval[i]) && i < ptd->nInterval; i++) {\n        record[depth] = i;\n        RecursiveSave(depth + 1, ptd->interval[i].to, record, ptd);\n    }\n}",
        "begin_line": 715,
        "end_line": 733,
        "is_bug": false
    },
    {
        "name": "tree.SaveList#735",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.SaveList(TreeDataType *ptd)",
        "snippet": "static void SaveList(TreeDataType *ptd)\n{\n    int record[MAX_PHONE_SEQ_LEN + 1] = { -1 };\n\n    RecursiveSave(1, 0, record, ptd);\n}",
        "begin_line": 735,
        "end_line": 740,
        "is_bug": false
    },
    {
        "name": "tree.InitPhrasing#742",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.InitPhrasing(TreeDataType *ptd)",
        "snippet": "static void InitPhrasing(TreeDataType *ptd)\n{\n    memset(ptd, 0, sizeof(TreeDataType));\n}",
        "begin_line": 742,
        "end_line": 745,
        "is_bug": false
    },
    {
        "name": "tree.SaveDispInterval#747",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.SaveDispInterval(PhrasingOutput *ppo, TreeDataType *ptd)",
        "snippet": "static void SaveDispInterval(PhrasingOutput *ppo, TreeDataType *ptd)\n{\n    int i;\n\n    for (i = 0; i < ptd->phList->nInter; i++) {\n        ppo->dispInterval[i].from = ptd->interval[ptd->phList->arrIndex[i]].from;\n        ppo->dispInterval[i].to = ptd->interval[ptd->phList->arrIndex[i]].to;\n    }\n    ppo->nDispInterval = ptd->phList->nInter;\n}",
        "begin_line": 747,
        "end_line": 756,
        "is_bug": false
    },
    {
        "name": "tree.CleanUpMem#758",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CleanUpMem(TreeDataType *ptd)",
        "snippet": "static void CleanUpMem(TreeDataType *ptd)\n{\n    int i;\n    RecordNode *pNode;\n\n    for (i = 0; i < ptd->nInterval; i++) {\n        if (ptd->interval[i].p_phr) {\n            free(ptd->interval[i].p_phr);\n            ptd->interval[i].p_phr = NULL;\n        }\n    }\n    while (ptd->phList != NULL) {\n        pNode = ptd->phList;\n        ptd->phList = pNode->next;\n        free(pNode->arrIndex);\n        free(pNode);\n    }\n}",
        "begin_line": 758,
        "end_line": 775,
        "is_bug": false
    },
    {
        "name": "tree.CountMatchCnnct#777",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CountMatchCnnct(TreeDataType *ptd, const int *bUserArrCnnct, int nPhoneSeq)",
        "snippet": "static void CountMatchCnnct(TreeDataType *ptd, const int *bUserArrCnnct, int nPhoneSeq)\n{\n    RecordNode *p;\n    int i, k, sum;\n\n    for (p = ptd->phList; p; p = p->next) {\n        /* for each record, count its 'nMatchCnnct' */\n        for (sum = 0, i = 1; i < nPhoneSeq; i++) {\n            if (!bUserArrCnnct[i])\n                continue;\n            /* check if matching 'cnnct' */\n            for (k = 0; k < p->nInter; k++) {\n                if (ptd->interval[p->arrIndex[k]].from < i && ptd->interval[p->arrIndex[k]].to > i) {\n                    sum++;\n                    break;\n                }\n            }\n        }\n        p->nMatchCnnct = sum;\n    }\n}",
        "begin_line": 777,
        "end_line": 797,
        "is_bug": false
    },
    {
        "name": "tree.ShowList#799",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.ShowList(ChewingData *pgdata, const TreeDataType *ptd)",
        "snippet": "static void ShowList(ChewingData *pgdata, const TreeDataType *ptd)\n{\n    const RecordNode *p;\n    int i;\n\n    DEBUG_OUT(\"After SaveList :\\n\");\n    for (p = ptd->phList; p; p = p->next) {\n        DEBUG_OUT(\"  interval : \");\n        for (i = 0; i < p->nInter; i++) {\n            DEBUG_OUT(\"[%d %d] \", ptd->interval[p->arrIndex[i]].from, ptd->interval[p->arrIndex[i]].to);\n        }\n        DEBUG_OUT(\"\\n\" \"      score : %d , nMatchCnnct : %d\\n\", p->score, p->nMatchCnnct);\n    }\n    DEBUG_OUT(\"\\n\");\n}",
        "begin_line": 799,
        "end_line": 813,
        "is_bug": false
    },
    {
        "name": "tree.NextCut#815",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.NextCut(TreeDataType *tdt, PhrasingOutput *ppo)",
        "snippet": "static RecordNode *NextCut(TreeDataType *tdt, PhrasingOutput *ppo)\n{\n    /* pop nNumCut-th candidate to first */\n    int i;\n    RecordNode *former;\n    RecordNode *want;\n\n    if (ppo->nNumCut >= tdt->nPhListLen)\n        ppo->nNumCut = 0;\n    if (ppo->nNumCut == 0)\n        return tdt->phList;\n\n    /* find the former of our candidate */\n    former = tdt->phList;\n    for (i = 0; i < ppo->nNumCut - 1; i++) {\n        former = former->next;\n        assert(former);\n    }\n\n    /* take the candidate out of the listed list */\n    want = former->next;\n    assert(want);\n    former->next = former->next->next;\n\n    /* prepend to front of list */\n    want->next = tdt->phList;\n    tdt->phList = want;\n\n    return tdt->phList;\n}",
        "begin_line": 815,
        "end_line": 844,
        "is_bug": false
    },
    {
        "name": "tree.SortByIncreaseEnd#846",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.SortByIncreaseEnd(const void *x, const void *y)",
        "snippet": "static int SortByIncreaseEnd(const void *x, const void *y)\n{\n    const PhraseIntervalType *interval_x = (const PhraseIntervalType *) x;\n    const PhraseIntervalType *interval_y = (const PhraseIntervalType *) y;\n\n    if (interval_x->to < interval_y->to)\n        return -1;\n\n    if (interval_x->to > interval_y->to)\n        return 1;\n\n    return 0;\n}",
        "begin_line": 846,
        "end_line": 858,
        "is_bug": false
    },
    {
        "name": "tree.DuplicateRecordAndInsertInterval#860",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.DuplicateRecordAndInsertInterval(const RecordNode *record, TreeDataType *pdt, const int interval_id)",
        "snippet": "static RecordNode *DuplicateRecordAndInsertInterval(const RecordNode *record, TreeDataType *pdt, const int interval_id)\n{\n    RecordNode *ret = NULL;\n\n    assert(record);\n    assert(pdt);\n\n    ret = ALC(RecordNode, 1);\n\n    if (!ret)\n        return NULL;\n\n    assert(record->nInter + 1);\n    ret->arrIndex = ALC(int, record->nInter + 1);\n    if (!ret->arrIndex) {\n        free(ret);\n        return NULL;\n    }\n    ret->nInter = record->nInter + 1;\n    memcpy(ret->arrIndex, record->arrIndex, sizeof(record->arrIndex[0]) * record->nInter);\n\n    ret->arrIndex[ret->nInter - 1] = interval_id;\n\n    ret->score = LoadPhraseAndCountScore(ret->arrIndex, ret->nInter, pdt);\n\n    return ret;\n}",
        "begin_line": 860,
        "end_line": 886,
        "is_bug": false
    },
    {
        "name": "tree.CreateSingleIntervalRecord#888",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CreateSingleIntervalRecord(TreeDataType *pdt, const int interval_id)",
        "snippet": "static RecordNode *CreateSingleIntervalRecord(TreeDataType *pdt, const int interval_id)\n{\n    RecordNode *ret = NULL;\n\n    assert(pdt);\n\n    ret = ALC(RecordNode, 1);\n\n    if (!ret)\n        return NULL;\n\n    ret->arrIndex = ALC(int, 1);\n    if (!ret->arrIndex) {\n        free(ret);\n        return NULL;\n    }\n\n    ret->nInter = 1;\n    ret->arrIndex[0] = interval_id;\n\n    ret->score = LoadPhraseAndCountScore(ret->arrIndex, ret->nInter, pdt);\n\n    return ret;\n}",
        "begin_line": 888,
        "end_line": 911,
        "is_bug": false
    },
    {
        "name": "tree.CreateNullIntervalRecord#913",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.CreateNullIntervalRecord()",
        "snippet": "static RecordNode *CreateNullIntervalRecord()\n{\n    RecordNode *ret = NULL;\n    ret = ALC(RecordNode, 1);\n\n    if (!ret)\n        return NULL;\n\n    ret->arrIndex = ALC(int, 1);\n    if (!ret->arrIndex) {\n        free(ret);\n        return NULL;\n    }\n\n    ret->nInter = 0;\n    ret->score = 0;\n\n    return ret;\n}",
        "begin_line": 913,
        "end_line": 931,
        "is_bug": false
    },
    {
        "name": "tree.FreeRecord#933",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.FreeRecord(RecordNode *node)",
        "snippet": "static void FreeRecord(RecordNode *node)\n{\n    if (node) {\n        free(node->arrIndex);\n        free(node);\n    }\n}",
        "begin_line": 933,
        "end_line": 939,
        "is_bug": false
    },
    {
        "name": "tree.DoDpPhrasing#941",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.DoDpPhrasing(ChewingData *pgdata, TreeDataType *pdt)",
        "snippet": "static void DoDpPhrasing(ChewingData *pgdata, TreeDataType *pdt)\n{\n    RecordNode *highest_score[MAX_PHONE_SEQ_LEN] = { 0 };\n    RecordNode *tmp;\n    int prev_end;\n    int end;\n    int interval_id;\n\n    assert(pgdata);\n    assert(pdt);\n\n    /*\n     * Assume P(x,y) is the highest score phrasing result from x to y. The\n     * following is formula for P(x,y):\n     *\n     * P(x,y) = MAX( P(x,y-1)+P(y-1,y), P(x,y-2)+P(y-2,y), ... )\n     *\n     * While P(x,y-1) is stored in highest_score array, and P(y-1,y) is\n     * interval end at y. In this formula, x is always 0.\n     *\n     * The format of highest_score array is described as following:\n     *\n     * highest_score[0] = P(0,0)\n     * highest_score[1] = P(0,1)\n     * ...\n     * highest_score[y-1] = P(0,y-1)\n     */\n\n    /* The interval shall be sorted by the increase order of end. */\n    qsort(pdt->interval, pdt->nInterval, sizeof(pdt->interval[0]), SortByIncreaseEnd);\n\n    for (interval_id = 0; interval_id < pdt->nInterval; ++interval_id) {\n        /*\n         * XXX: pdt->interval.to is excluding, while end is\n         * including, so we need to minus one here.\n         */\n        end = pdt->interval[interval_id].to - 1;\n\n        prev_end = pdt->interval[interval_id].from - 1;\n\n        if (prev_end >= 0)\n            tmp = DuplicateRecordAndInsertInterval(highest_score[prev_end], pdt, interval_id);\n        else\n            tmp = CreateSingleIntervalRecord(pdt, interval_id);\n\n        /* FIXME: shall exit immediately? */\n        if (!tmp)\n            continue;\n\n        if (highest_score[end] == NULL || highest_score[end]->score < tmp->score) {\n            FreeRecord(highest_score[end]);\n            highest_score[end] = tmp;\n        } else\n            FreeRecord(tmp);\n    }\n\n    if (pgdata->nPhoneSeq - 1 < 0 || highest_score[pgdata->nPhoneSeq - 1] == NULL) {\n        pdt->phList = CreateNullIntervalRecord();\n    } else {\n        pdt->phList = highest_score[pgdata->nPhoneSeq - 1];\n    }\n    pdt->nPhListLen = 1;\n\n    for (end = 0; end < pgdata->nPhoneSeq - 1; ++end)\n        FreeRecord(highest_score[end]);\n}",
        "begin_line": 941,
        "end_line": 1006,
        "is_bug": false
    },
    {
        "name": "tree.Phrasing#1008",
        "src_path": "src/tree.c",
        "class_name": "tree",
        "signature": "tree.Phrasing(ChewingData *pgdata, int all_phrasing)",
        "snippet": "int Phrasing(ChewingData *pgdata, int all_phrasing)\n{\n    TreeDataType treeData;\n\n    InitPhrasing(&treeData);\n\n    FindInterval(pgdata, &treeData);\n    SetInfo(pgdata->nPhoneSeq, &treeData);\n    Discard1(&treeData);\n    Discard2(&treeData);\n    if (all_phrasing) {\n        SaveList(&treeData);\n        CountMatchCnnct(&treeData, pgdata->bUserArrCnnct, pgdata->nPhoneSeq);\n        SortListByScore(&treeData);\n        NextCut(&treeData, &pgdata->phrOut);\n    } else {\n        DoDpPhrasing(pgdata, &treeData);\n    }\n\n    ShowList(pgdata, &treeData);\n\n    /* set phrasing output */\n    OutputRecordStr(pgdata, &treeData);\n    SaveDispInterval(&pgdata->phrOut, &treeData);\n\n    /* free \"phrase\" */\n    CleanUpMem(&treeData);\n    return 0;\n}",
        "begin_line": 1008,
        "end_line": 1036,
        "is_bug": false
    }
]